Title: Time for Intersection Observer
Publication date: 2018-01-31
Playlist: Front-End London
Description: 
	Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:04,859
today I'm going to talk about

00:00:00,900 --> 00:00:08,280
intersection observer a new API and why

00:00:04,859 --> 00:00:10,440
a new HTML javascript api and why it's

00:00:08,280 --> 00:00:12,389
time to start using it but before I

00:00:10,440 --> 00:00:15,179
start I'll just quickly say something

00:00:12,389 --> 00:00:18,480
about myself so my name is Jonas I am a

00:00:15,179 --> 00:00:20,250
Swedish guy who now live in Paris I love

00:00:18,480 --> 00:00:23,010
open-source web performance tooling

00:00:20,250 --> 00:00:25,050
react written some yeah it's like like

00:00:23,010 --> 00:00:26,609
Ilya said some open-source tools that

00:00:25,050 --> 00:00:29,490
work with critical CSS to make websites

00:00:26,609 --> 00:00:31,019
faster in the past I created a SAS

00:00:29,490 --> 00:00:32,640
business on top of one of them called

00:00:31,019 --> 00:00:35,910
the business school critical CSS comm

00:00:32,640 --> 00:00:37,739
now I work for AI startup in in France

00:00:35,910 --> 00:00:40,920
in Paris where I lead our front-end team

00:00:37,739 --> 00:00:42,960
and snips this company we use voice AI

00:00:40,920 --> 00:00:45,329
to basically make technology disappear

00:00:42,960 --> 00:00:47,340
we have a platform you can create voice

00:00:45,329 --> 00:00:48,960
assistants that can control smart

00:00:47,340 --> 00:00:51,300
speakers they can control coffee

00:00:48,960 --> 00:00:54,960
machines control anything you want

00:00:51,300 --> 00:00:56,449
basically so that's what I do daily but

00:00:54,960 --> 00:00:59,039
today we're going to talk about

00:00:56,449 --> 00:01:00,149
intersection of server so roughly the

00:00:59,039 --> 00:01:01,680
outline of this talk is going to be

00:01:00,149 --> 00:01:04,610
first I'm going to tell you what

00:01:01,680 --> 00:01:07,560
intersection server observer it's about

00:01:04,610 --> 00:01:09,619
why you need it and what it is good for

00:01:07,560 --> 00:01:12,600
but also what it's not so good for and

00:01:09,619 --> 00:01:13,950
how you can use it today so that you can

00:01:12,600 --> 00:01:16,229
go home and make use of this on your

00:01:13,950 --> 00:01:19,920
websites or web apps or whatever it is

00:01:16,229 --> 00:01:22,259
that you are building so what is

00:01:19,920 --> 00:01:24,030
intersection observer can I get a raise

00:01:22,259 --> 00:01:25,380
of hands first how many here have heard

00:01:24,030 --> 00:01:29,040
about the intersection server before

00:01:25,380 --> 00:01:29,490
this talk a few how many have used it at

00:01:29,040 --> 00:01:32,670
all

00:01:29,490 --> 00:01:35,220
ok ok few people that's good a good mix

00:01:32,670 --> 00:01:37,250
so hopefully it's not not a great

00:01:35,220 --> 00:01:39,180
mystery the name is meant to be kind of

00:01:37,250 --> 00:01:41,100
descriptive intersection of service

00:01:39,180 --> 00:01:45,149
about observing when elements on your

00:01:41,100 --> 00:01:46,740
website intersect when they overlap they

00:01:45,149 --> 00:01:49,320
could have kind of given it a better

00:01:46,740 --> 00:01:51,600
name like the most common use case for

00:01:49,320 --> 00:01:53,159
intersection observing is in view

00:01:51,600 --> 00:01:56,040
monitoring it's monitoring when things

00:01:53,159 --> 00:01:57,600
come into view on your website and onto

00:01:56,040 --> 00:01:59,880
the screen but the reason it's not

00:01:57,600 --> 00:02:02,579
called in view monitor or something like

00:01:59,880 --> 00:02:04,439
that it's because the that's the default

00:02:02,579 --> 00:02:06,479
behavior but you can modify the route so

00:02:04,439 --> 00:02:08,640
that you no longer monitor whether if

00:02:06,479 --> 00:02:10,020
something is in the view but whether

00:02:08,640 --> 00:02:13,410
something is intersecting with something

00:02:10,020 --> 00:02:13,730
else so you can use that for more custom

00:02:13,410 --> 00:02:15,530
use

00:02:13,730 --> 00:02:17,060
but today I'm going to talk about in

00:02:15,530 --> 00:02:18,620
view monitoring for that that's the most

00:02:17,060 --> 00:02:21,140
common use case for intersection

00:02:18,620 --> 00:02:23,269
observer so what do we use that form we

00:02:21,140 --> 00:02:24,590
can use in view monitoring with

00:02:23,269 --> 00:02:27,230
intersection server to do things like

00:02:24,590 --> 00:02:28,670
lazy loading content to instead of

00:02:27,230 --> 00:02:31,430
loading all the images that you have on

00:02:28,670 --> 00:02:32,660
a long website web page up front you can

00:02:31,430 --> 00:02:34,280
load just a few of them and then

00:02:32,660 --> 00:02:35,900
progressively load more and more as the

00:02:34,280 --> 00:02:37,670
user Scrolls down on the page you can

00:02:35,900 --> 00:02:39,230
use the same technique for locate

00:02:37,670 --> 00:02:42,260
loading in more content when you have an

00:02:39,230 --> 00:02:43,970
infinite scrolling list and these kind

00:02:42,260 --> 00:02:46,489
of use cases you can use it for in view

00:02:43,970 --> 00:02:48,830
tracking to report when certain content

00:02:46,489 --> 00:02:50,540
was seen by users so if they ever scroll

00:02:48,830 --> 00:02:53,780
down to that video that you have on the

00:02:50,540 --> 00:02:55,010
last part of your web page you can also

00:02:53,780 --> 00:02:57,980
use it for something like in animation

00:02:55,010 --> 00:03:00,739
track triggers to fade in content as

00:02:57,980 --> 00:03:02,780
they come in onto the screen like this

00:03:00,739 --> 00:03:05,470
so we all know what I'm talking about

00:03:02,780 --> 00:03:10,730
hopefully I can play this I couldn't

00:03:05,470 --> 00:03:11,900
that's ok ok you can see it I can't yeah

00:03:10,730 --> 00:03:14,030
so you just you know fade in some

00:03:11,900 --> 00:03:16,549
content when it comes interview you can

00:03:14,030 --> 00:03:18,560
do things like this so a legit question

00:03:16,549 --> 00:03:21,260
here is why do we need a new API for

00:03:18,560 --> 00:03:22,730
this because really we've been doing

00:03:21,260 --> 00:03:24,350
these kind of things on the web for

00:03:22,730 --> 00:03:26,510
years I've been doing them for years

00:03:24,350 --> 00:03:28,790
there are certainly ways to do these

00:03:26,510 --> 00:03:30,019
things without intersection observer so

00:03:28,790 --> 00:03:33,200
why did we come up with this new API

00:03:30,019 --> 00:03:35,569
well the thing is without intersection

00:03:33,200 --> 00:03:37,489
observer if you want to write this kind

00:03:35,569 --> 00:03:40,010
of code yourself you're very likely to

00:03:37,489 --> 00:03:42,170
end up with a little bit of code more

00:03:40,010 --> 00:03:44,780
than you would like and it starts to get

00:03:42,170 --> 00:03:47,450
a little bit complex quite quickly and

00:03:44,780 --> 00:03:50,810
most of this resolves around performance

00:03:47,450 --> 00:03:52,250
issues which was a another big reason

00:03:50,810 --> 00:03:55,340
why intersection observer was fought off

00:03:52,250 --> 00:03:56,690
because basically what people generally

00:03:55,340 --> 00:03:57,829
do when they try to do in view

00:03:56,690 --> 00:03:59,840
monitoring is they start setting up

00:03:57,829 --> 00:04:02,349
scroll listeners and this is what has

00:03:59,840 --> 00:04:05,090
been responsible mostly for why people

00:04:02,349 --> 00:04:07,459
think the web is slow why we have things

00:04:05,090 --> 00:04:08,660
like websites that lag or have scroll

00:04:07,459 --> 00:04:11,810
jank when you try to scroll them down

00:04:08,660 --> 00:04:14,030
and why people think things like that

00:04:11,810 --> 00:04:16,039
the web can never be as smooth and

00:04:14,030 --> 00:04:20,090
provide as good as an experience as

00:04:16,039 --> 00:04:22,150
native applications so all of this comes

00:04:20,090 --> 00:04:24,349
from not having better support for

00:04:22,150 --> 00:04:26,750
things like in view monitoring and this

00:04:24,349 --> 00:04:29,180
is why intersection of server

00:04:26,750 --> 00:04:31,580
was fought off but let me say something

00:04:29,180 --> 00:04:33,470
a little bit more in detail on why it's

00:04:31,580 --> 00:04:35,690
kind of complex and and badly confirmed

00:04:33,470 --> 00:04:36,920
performing to do in view monitoring on

00:04:35,690 --> 00:04:39,770
your own without something like the

00:04:36,920 --> 00:04:42,410
intersection observer API so I already

00:04:39,770 --> 00:04:46,370
said briefly that if you listen to the

00:04:42,410 --> 00:04:47,780
scroll event by yourself it's a little

00:04:46,370 --> 00:04:49,880
bit problematic you can't just use it in

00:04:47,780 --> 00:04:52,340
a naive way this naive way the scroll

00:04:49,880 --> 00:04:54,560
event fires continuously and quite

00:04:52,340 --> 00:04:56,060
repeatedly you can fire several hundred

00:04:54,560 --> 00:04:57,710
times a second and you have basically no

00:04:56,060 --> 00:04:59,960
control over how often a fire it will

00:04:57,710 --> 00:05:02,660
vary depending on what browser you're in

00:04:59,960 --> 00:05:04,040
what OS what type of device so if you

00:05:02,660 --> 00:05:05,330
use something like a scroll listener you

00:05:04,040 --> 00:05:07,520
have to make sure you throttle it and

00:05:05,330 --> 00:05:09,560
you have to know about throttling if you

00:05:07,520 --> 00:05:12,680
want to determine whether something is

00:05:09,560 --> 00:05:14,900
in view you probably use an API like get

00:05:12,680 --> 00:05:16,700
bounding client rectangle on Dom

00:05:14,900 --> 00:05:18,980
elements because this gives you the

00:05:16,700 --> 00:05:21,350
relative view coordinates of an element

00:05:18,980 --> 00:05:23,240
in relative to the viewport this is what

00:05:21,350 --> 00:05:25,400
you want to use but the problem is this

00:05:23,240 --> 00:05:27,200
API is this method is too slow it can

00:05:25,400 --> 00:05:28,820
take several hundred milliseconds every

00:05:27,200 --> 00:05:30,880
time you call it so if you call it

00:05:28,820 --> 00:05:33,380
continuously every time the user Scrolls

00:05:30,880 --> 00:05:35,690
on multiple elements at the same time

00:05:33,380 --> 00:05:37,610
it's just gonna take too much time and

00:05:35,690 --> 00:05:41,270
it you can't really use something like

00:05:37,610 --> 00:05:43,160
this inside a scroll event listener and

00:05:41,270 --> 00:05:44,930
finally you know okay so these are some

00:05:43,160 --> 00:05:46,370
problems but obviously you can work

00:05:44,930 --> 00:05:49,870
around and you can start cashing

00:05:46,370 --> 00:05:52,880
expensive don't method calls you can

00:05:49,870 --> 00:05:54,650
throttle your scroll handler but if you

00:05:52,880 --> 00:05:56,540
for example start cashing the expensive

00:05:54,650 --> 00:05:59,090
course you need to start at taking

00:05:56,540 --> 00:06:00,410
handle the case where after you've

00:05:59,090 --> 00:06:03,350
cashed the position of an element

00:06:00,410 --> 00:06:05,630
relative to the view if you modify the

00:06:03,350 --> 00:06:07,010
page content maybe you expand an

00:06:05,630 --> 00:06:09,110
accordion or something like that the

00:06:07,010 --> 00:06:11,570
cached values are no longer relevant and

00:06:09,110 --> 00:06:16,010
it just gets more and more complex and

00:06:11,570 --> 00:06:17,419
it's totally possible to do but most

00:06:16,010 --> 00:06:19,610
people on the web didn't do it well

00:06:17,419 --> 00:06:22,490
enough basically and it's not easy to do

00:06:19,610 --> 00:06:24,290
well enough so intersection server makes

00:06:22,490 --> 00:06:28,700
it a lot more easy to do the right thing

00:06:24,290 --> 00:06:30,410
by default so that's why it's here so in

00:06:28,700 --> 00:06:33,560
contrast to what I've talked about so

00:06:30,410 --> 00:06:35,150
far let's look at what it looks like to

00:06:33,560 --> 00:06:38,279
do something like in view monitoring

00:06:35,150 --> 00:06:42,869
with intersection observer API

00:06:38,279 --> 00:06:44,069
so we start by setting up an observer

00:06:42,869 --> 00:06:45,659
can everyone see the code by the way

00:06:44,069 --> 00:06:50,429
even even in the back is it's big enough

00:06:45,659 --> 00:06:52,529
or yeah okay good we start by setting up

00:06:50,429 --> 00:06:54,539
and a new observer with the window at

00:06:52,529 --> 00:06:58,709
the intersection observer method call

00:06:54,539 --> 00:07:01,949
the argument to this API is a callback

00:06:58,709 --> 00:07:04,049
function which I called on intersection

00:07:01,949 --> 00:07:06,719
which we will look at next and then at

00:07:04,049 --> 00:07:09,179
the bottom we use call observe observe

00:07:06,719 --> 00:07:13,110
observe with any Dom element that we can

00:07:09,179 --> 00:07:16,049
find on the page and then in the

00:07:13,110 --> 00:07:18,509
callback function we receive an array of

00:07:16,049 --> 00:07:19,979
entries and we receive an array because

00:07:18,509 --> 00:07:22,199
we can observe multiple elements at the

00:07:19,979 --> 00:07:24,269
same time then we can look through each

00:07:22,199 --> 00:07:26,579
of these entries and the interesting

00:07:24,269 --> 00:07:28,679
line is just entry dot is intersecting

00:07:26,579 --> 00:07:32,039
which basically just tells us out of the

00:07:28,679 --> 00:07:34,289
box where the element is in view which

00:07:32,039 --> 00:07:35,519
basically replace any of these replaces

00:07:34,289 --> 00:07:36,659
all the code and all the hacks and all

00:07:35,519 --> 00:07:38,699
the workarounds we have to do before

00:07:36,659 --> 00:07:40,259
this is all you need to do a simple in

00:07:38,699 --> 00:07:42,959
view monitoring with intersection

00:07:40,259 --> 00:07:45,959
observer so it's pretty neat it's much

00:07:42,959 --> 00:07:49,619
better than before the code is much

00:07:45,959 --> 00:07:53,129
cleaner but it also avoids performance

00:07:49,619 --> 00:07:54,809
issues and I'll tell you I'll say a

00:07:53,129 --> 00:07:56,939
little bit more about how it avoids

00:07:54,809 --> 00:07:58,589
performance issues so intersection

00:07:56,939 --> 00:08:00,869
observer basically basically comes with

00:07:58,589 --> 00:08:03,119
performance built-in it's built to be

00:08:00,869 --> 00:08:04,919
performant it's built so that we avoid

00:08:03,119 --> 00:08:06,809
repeating the mistakes of the web

00:08:04,919 --> 00:08:11,129
accidentally becoming broken and really

00:08:06,809 --> 00:08:13,469
slow because of the way people use it so

00:08:11,129 --> 00:08:15,539
it's hard to make this not work well

00:08:13,469 --> 00:08:17,729
basically so I said that something like

00:08:15,539 --> 00:08:19,769
get bound in client rectangle which is

00:08:17,729 --> 00:08:21,329
what we would use to natively on our own

00:08:19,769 --> 00:08:23,099
figure out if something's in view or not

00:08:21,329 --> 00:08:25,289
there's no need what intersection

00:08:23,099 --> 00:08:27,179
observer to make any call like this all

00:08:25,289 --> 00:08:29,039
the intersection checks are already

00:08:27,179 --> 00:08:31,229
handled by the browser and then handled

00:08:29,039 --> 00:08:32,969
in an optimized way so that you get

00:08:31,229 --> 00:08:37,309
static values basically that you can

00:08:32,969 --> 00:08:37,309
make use of that is it's just fast I

00:08:38,300 --> 00:08:43,620
also talked about the scroll event

00:08:41,610 --> 00:08:44,850
firing too often you don't really have

00:08:43,620 --> 00:08:47,069
this problem at the intersection of

00:08:44,850 --> 00:08:48,660
survey API because the callback that you

00:08:47,069 --> 00:08:51,900
get it doesn't fire continuously all the

00:08:48,660 --> 00:08:55,080
time and it's also set

00:08:51,900 --> 00:08:57,870
upto internally make use of an API

00:08:55,080 --> 00:08:59,100
called request I know callback I don't

00:08:57,870 --> 00:09:01,650
know if you heard about this API but

00:08:59,100 --> 00:09:02,850
basically it's something that tell when

00:09:01,650 --> 00:09:04,470
you call the request I do whole back

00:09:02,850 --> 00:09:06,510
with some work it tells the browser that

00:09:04,470 --> 00:09:08,130
I want you to do this but when you have

00:09:06,510 --> 00:09:10,260
some time when you when you're not busy

00:09:08,130 --> 00:09:12,000
with you know too much going on with

00:09:10,260 --> 00:09:15,600
videos playing the user scrolling too

00:09:12,000 --> 00:09:18,540
fast don't it's never gonna be called in

00:09:15,600 --> 00:09:20,580
a way that makes you lose frames and

00:09:18,540 --> 00:09:22,920
cause scroll jank it's it's happy it can

00:09:20,580 --> 00:09:25,700
happen a little bit later if your

00:09:22,920 --> 00:09:27,780
browsers too busy for when it would have

00:09:25,700 --> 00:09:32,520
otherwise fired a callback the callback

00:09:27,780 --> 00:09:36,090
is gonna be delayed a little bit carry

00:09:32,520 --> 00:09:37,170
on so it by this itself avoids the

00:09:36,090 --> 00:09:40,260
performance issues the type of

00:09:37,170 --> 00:09:42,390
performance issues we would get when we

00:09:40,260 --> 00:09:45,360
write this kind of code on our own but

00:09:42,390 --> 00:09:47,130
it's worth noting here that I said the

00:09:45,360 --> 00:09:50,700
callback doesn't fire continuously

00:09:47,130 --> 00:09:52,530
doesn't fire exactly when the

00:09:50,700 --> 00:09:54,450
intersection happened it fires when the

00:09:52,530 --> 00:09:56,670
bra off to the intersection has happened

00:09:54,450 --> 00:09:58,260
when the browser has some time but it

00:09:56,670 --> 00:10:00,450
has some implementation implications for

00:09:58,260 --> 00:10:02,640
how we can use an API like this and one

00:10:00,450 --> 00:10:04,080
usage area where people talk to later

00:10:02,640 --> 00:10:05,820
about intersection observer and how

00:10:04,080 --> 00:10:07,650
whether we can use it or not is for

00:10:05,820 --> 00:10:09,540
animations some people were saying

00:10:07,650 --> 00:10:10,890
because the updates are delayed and we

00:10:09,540 --> 00:10:13,320
don't have any control over exactly when

00:10:10,890 --> 00:10:15,630
they fire it might not be a good use

00:10:13,320 --> 00:10:19,410
case to use them for animations so I

00:10:15,630 --> 00:10:20,910
would say yes if you need continuous app

00:10:19,410 --> 00:10:22,860
updates if you want to animate something

00:10:20,910 --> 00:10:24,870
to trace the scroll position to keep on

00:10:22,860 --> 00:10:25,890
moving as you keep on scrolling if you

00:10:24,870 --> 00:10:28,140
want to do something like parallax

00:10:25,890 --> 00:10:29,700
effects you shouldn't use anything like

00:10:28,140 --> 00:10:30,870
the intersection of serve API it's not

00:10:29,700 --> 00:10:32,700
meant for this kind of use case and it

00:10:30,870 --> 00:10:35,940
will not work well if you just want to

00:10:32,700 --> 00:10:37,650
do a one-off start of fading animation

00:10:35,940 --> 00:10:38,730
of something that comes into view and if

00:10:37,650 --> 00:10:40,620
you're okay with it happening in a

00:10:38,730 --> 00:10:43,530
little bit delayed you possibly if the

00:10:40,620 --> 00:10:44,850
browser is busy then it's fine to use it

00:10:43,530 --> 00:10:47,280
for something like enter and exit

00:10:44,850 --> 00:10:52,070
animation triggers it's perfect for this

00:10:47,280 --> 00:10:55,410
use case so I would say in general sorry

00:10:52,070 --> 00:10:57,740
make sure you test your use case but you

00:10:55,410 --> 00:11:01,410
can use it for animations absolutely

00:10:57,740 --> 00:11:02,850
okay let's see a little bit more what

00:11:01,410 --> 00:11:05,030
the intersection observer API it looks

00:11:02,850 --> 00:11:05,030
like

00:11:05,279 --> 00:11:08,160
I want to note that I'm not going to

00:11:06,749 --> 00:11:09,240
show you every single method and

00:11:08,160 --> 00:11:10,589
property you can get from the

00:11:09,240 --> 00:11:12,810
intersection observer API and will tell

00:11:10,589 --> 00:11:13,350
you the most useful ones and what

00:11:12,810 --> 00:11:15,269
they're used for

00:11:13,350 --> 00:11:17,370
and if you are really interested in a

00:11:15,269 --> 00:11:19,529
few more things you can look up on

00:11:17,370 --> 00:11:22,949
yourself by yourself or you can come and

00:11:19,529 --> 00:11:24,870
ask me afterwards so I already the first

00:11:22,949 --> 00:11:27,620
example I gave you what was how to do in

00:11:24,870 --> 00:11:31,649
view detection via the entry rows

00:11:27,620 --> 00:11:33,740
intersecting I need to do a little bit

00:11:31,649 --> 00:11:36,649
little warning here that entry is

00:11:33,740 --> 00:11:38,999
intersecting unfortunately isn't exactly

00:11:36,649 --> 00:11:41,430
what you kind of think it would be

00:11:38,999 --> 00:11:43,800
it doesn't actually correspond to

00:11:41,430 --> 00:11:45,949
whether an entry is intersecting or not

00:11:43,800 --> 00:11:48,059
whether it's in view or not it

00:11:45,949 --> 00:11:51,110
corresponds to whether the element now

00:11:48,059 --> 00:11:54,269
intersects more or less than before

00:11:51,110 --> 00:11:55,470
which for the most common use case

00:11:54,269 --> 00:11:57,509
whether you just wanted to say whether

00:11:55,470 --> 00:11:59,249
something came into view or not it will

00:11:57,509 --> 00:12:00,660
still be the same because before it was

00:11:59,249 --> 00:12:03,509
not incident I mean you will still have

00:12:00,660 --> 00:12:04,559
become more but it says the name is

00:12:03,509 --> 00:12:06,329
livid misleading but this was just

00:12:04,559 --> 00:12:08,490
because in the first version of the spec

00:12:06,329 --> 00:12:09,959
the behavior was the former but then

00:12:08,490 --> 00:12:11,540
they realized that it's more useful with

00:12:09,959 --> 00:12:14,629
the latter and they kept the same name

00:12:11,540 --> 00:12:17,189
so that's the way it is it's fine

00:12:14,629 --> 00:12:18,600
there's another way to do in view

00:12:17,189 --> 00:12:21,089
detection with intersection observer

00:12:18,600 --> 00:12:22,319
which you see a lot of you if you look

00:12:21,089 --> 00:12:24,480
at blogs and what people talk about the

00:12:22,319 --> 00:12:26,879
intersection observer this is pretty

00:12:24,480 --> 00:12:28,529
much the same example as before I don't

00:12:26,879 --> 00:12:31,649
have I have a pointer don't you think I

00:12:28,529 --> 00:12:32,730
do okay it's a semi someplace before but

00:12:31,649 --> 00:12:34,740
instead of doing checking is

00:12:32,730 --> 00:12:36,930
intersecting I'm checking entry dot

00:12:34,740 --> 00:12:41,250
intersection ratio and checking that

00:12:36,930 --> 00:12:43,139
it's greater than zero and what does one

00:12:41,250 --> 00:12:45,149
most line is what does the intersection

00:12:43,139 --> 00:12:46,740
ratio correspond to so intersection

00:12:45,149 --> 00:12:48,870
ratio is basically the area this

00:12:46,740 --> 00:12:51,449
intersecting out of the total area that

00:12:48,870 --> 00:12:52,800
we're viewing there are monitoring so by

00:12:51,449 --> 00:12:54,449
default with the default behavior it's

00:12:52,800 --> 00:12:57,480
the area that's in view how much the

00:12:54,449 --> 00:12:59,699
element is now in view so visually with

00:12:57,480 --> 00:13:02,910
the picture I took from google developer

00:12:59,699 --> 00:13:05,249
blog if an element is completely outside

00:13:02,910 --> 00:13:07,170
of the view which is the default

00:13:05,249 --> 00:13:08,910
behavior the intersection area is zero

00:13:07,170 --> 00:13:10,470
if it's completely in view intersection

00:13:08,910 --> 00:13:11,089
area is 100% and then anything in

00:13:10,470 --> 00:13:13,500
between

00:13:11,089 --> 00:13:14,790
so obviously we can we can also use this

00:13:13,500 --> 00:13:18,520
for determining whether something is in

00:13:14,790 --> 00:13:20,440
view or not but there's one more

00:13:18,520 --> 00:13:22,540
- given on when you use this particular

00:13:20,440 --> 00:13:24,340
method for determining whether

00:13:22,540 --> 00:13:28,780
something's in view you need to also

00:13:24,340 --> 00:13:30,970
specify a threshold which is can go into

00:13:28,780 --> 00:13:33,460
the config which the intersection

00:13:30,970 --> 00:13:35,530
observer call takes as a second

00:13:33,460 --> 00:13:38,740
parameter and what is the threshold

00:13:35,530 --> 00:13:41,140
threshold is an array of intersection

00:13:38,740 --> 00:13:43,000
ratio values values so do intersection

00:13:41,140 --> 00:13:44,500
ratio that I just showed you you can

00:13:43,000 --> 00:13:48,310
specify a bunch of them so these are

00:13:44,500 --> 00:13:50,320
percentages so so 0.01 means 1% in view

00:13:48,310 --> 00:13:51,940
Syrah means sir percent TMU you can

00:13:50,320 --> 00:13:53,200
specify a bunch of them and when each of

00:13:51,940 --> 00:13:55,210
them are crossed when the element

00:13:53,200 --> 00:13:57,610
becomes more or less visible than this

00:13:55,210 --> 00:14:00,040
you will get a callback that I've

00:13:57,610 --> 00:14:01,980
specified only intersect callback so in

00:14:00,040 --> 00:14:04,660
this example let's just look at the

00:14:01,980 --> 00:14:10,660
JavaScript it's the most interesting

00:14:04,660 --> 00:14:12,330
part I'm taking a bunch of Dom elements

00:14:10,660 --> 00:14:14,680
from the dorm I'm selecting them all

00:14:12,330 --> 00:14:16,630
here I'm is converting the node list

00:14:14,680 --> 00:14:19,240
that we get by default into an array

00:14:16,630 --> 00:14:23,920
because we want to call for each don't

00:14:19,240 --> 00:14:26,410
worry too much about that it's just not

00:14:23,920 --> 00:14:29,260
the way the Dom API is work then we call

00:14:26,410 --> 00:14:31,300
intersection observer three times one

00:14:29,260 --> 00:14:34,420
time went without any custom configured

00:14:31,300 --> 00:14:38,170
with nothing one time with a threshold

00:14:34,420 --> 00:14:39,550
array with three values zero that can

00:14:38,170 --> 00:14:44,710
probably made bigger that's a good point

00:14:39,550 --> 00:14:46,810
so better yeah the second element will

00:14:44,710 --> 00:14:48,310
have three values zero 50% one and the

00:14:46,810 --> 00:14:50,110
third one will have a lot of values

00:14:48,310 --> 00:14:52,120
basically and the only thing I'm doing

00:14:50,110 --> 00:14:54,430
in the intersect is I'm setting in a

00:14:52,120 --> 00:14:56,530
Nena HTML I'm changing the text inside a

00:14:54,430 --> 00:14:59,050
label to be the intersection ratio value

00:14:56,530 --> 00:14:59,950
converted as a into a percentage so let

00:14:59,050 --> 00:15:01,540
me assure you what I mean

00:14:59,950 --> 00:15:04,150
so with the default behavior threshold

00:15:01,540 --> 00:15:06,460
one as a special of zero we're gonna get

00:15:04,150 --> 00:15:08,350
one update when we cross into this

00:15:06,460 --> 00:15:10,990
element it's gonna update once and no

00:15:08,350 --> 00:15:13,720
more if we add more special various

00:15:10,990 --> 00:15:14,020
values so zero it's just too small as

00:15:13,720 --> 00:15:18,760
well

00:15:14,020 --> 00:15:21,760
zero 50% and one no I get a really small

00:15:18,760 --> 00:15:23,620
you oughta stay with this then we get

00:15:21,760 --> 00:15:26,170
three updates one its beginning one when

00:15:23,620 --> 00:15:29,320
we cross 50% and one when we leave at

00:15:26,170 --> 00:15:32,020
100% and we can't see that anymore it's

00:15:29,320 --> 00:15:33,520
a bit of a shame anyway and then

00:15:32,020 --> 00:15:34,870
if you if you use this you would only

00:15:33,520 --> 00:15:37,120
use this for demo purposes but if you

00:15:34,870 --> 00:15:39,310
specify one one value per percentage

00:15:37,120 --> 00:15:40,779
points between 0 and 100 cent you get

00:15:39,310 --> 00:15:42,640
two continuous updates all the time as

00:15:40,779 --> 00:15:44,040
you expect so this is what thresholds do

00:15:42,640 --> 00:15:47,230
this is what they're used for

00:15:44,040 --> 00:15:49,330
one thing that is interesting to note

00:15:47,230 --> 00:15:50,920
here is the delayed in asynchronous

00:15:49,330 --> 00:15:53,230
nature of this API that I talked about

00:15:50,920 --> 00:15:54,700
before even though you specified CRS the

00:15:53,230 --> 00:15:57,250
value here you can get a much higher

00:15:54,700 --> 00:15:59,020
value because by the time the browser

00:15:57,250 --> 00:16:01,120
had time to execute the work you

00:15:59,020 --> 00:16:03,160
scheduled you have already passed a

00:16:01,120 --> 00:16:04,600
threshold by a bit of a margin so this

00:16:03,160 --> 00:16:06,160
is important to know for how this works

00:16:04,600 --> 00:16:08,320
the other thing that I think is

00:16:06,160 --> 00:16:10,420
important to note is that even though

00:16:08,320 --> 00:16:12,399
you specified serum and the behavior is

00:16:10,420 --> 00:16:14,380
supposed to be when we cross that

00:16:12,399 --> 00:16:16,839
threshold so when the intersection ratio

00:16:14,380 --> 00:16:18,910
is greater than zero you can get exactly

00:16:16,839 --> 00:16:23,080
zero so I was saying we have to specify

00:16:18,910 --> 00:16:26,980
a threshold greater than zero and this

00:16:23,080 --> 00:16:28,630
is because if we specify zero we can get

00:16:26,980 --> 00:16:30,100
an own intersect update that actually

00:16:28,630 --> 00:16:32,410
means it's supposed to mean that element

00:16:30,100 --> 00:16:33,940
is now in view but we can't distinguish

00:16:32,410 --> 00:16:35,890
it with any intersection ratio check

00:16:33,940 --> 00:16:37,420
from an update that said element is not

00:16:35,890 --> 00:16:40,029
in view because zero is the lowest

00:16:37,420 --> 00:16:42,339
possible value you can get so it's just

00:16:40,029 --> 00:16:43,600
yeah something you need to be aware of

00:16:42,339 --> 00:16:45,520
if you'd use this method you have to

00:16:43,600 --> 00:16:48,610
specify a higher threshold I got burnt

00:16:45,520 --> 00:16:51,820
by this I didn't realize you had to also

00:16:48,610 --> 00:16:55,779
use threshold in this case so something

00:16:51,820 --> 00:16:57,550
to be aware of I've brought up some

00:16:55,779 --> 00:16:59,170
questions about when with the

00:16:57,550 --> 00:17:01,089
intersection observer API about

00:16:59,170 --> 00:17:04,300
thresholds and callbacks so I want to

00:17:01,089 --> 00:17:07,089
say a little bit about that as you may

00:17:04,300 --> 00:17:09,459
be already into it from the demo I gave

00:17:07,089 --> 00:17:11,199
when I specify the hundred values in the

00:17:09,459 --> 00:17:13,660
last threshold array so that it was

00:17:11,199 --> 00:17:15,490
supposed to update with each percentage

00:17:13,660 --> 00:17:18,059
point point of the of the element that I

00:17:15,490 --> 00:17:22,959
crossed you don't actually get one

00:17:18,059 --> 00:17:24,780
callback per threshold per intersection

00:17:22,959 --> 00:17:27,309
ratio threshold in the threshold array

00:17:24,780 --> 00:17:29,920
because of the async nature of this API

00:17:27,309 --> 00:17:31,630
because it's also kind of throttled if

00:17:29,920 --> 00:17:34,059
too many of your callbacks if you have a

00:17:31,630 --> 00:17:36,280
lot of thresholds fire at the same in

00:17:34,059 --> 00:17:39,010
closer to each other in time they will

00:17:36,280 --> 00:17:42,070
just get the latest update basically so

00:17:39,010 --> 00:17:43,929
just note that this isn't it's not most

00:17:42,070 --> 00:17:45,680
so important for most use cases but you

00:17:43,929 --> 00:17:47,900
won't get updates

00:17:45,680 --> 00:17:53,380
at corresponding to each single an to

00:17:47,900 --> 00:17:53,380
section ratio value more interesting is

00:17:54,850 --> 00:18:03,890
okay also that on intersect this

00:18:01,640 --> 00:18:07,000
callback that you get when you set up

00:18:03,890 --> 00:18:08,930
when you when you when the element is

00:18:07,000 --> 00:18:11,990
crossed when when you when the

00:18:08,930 --> 00:18:14,600
intersection ratio changes it also fires

00:18:11,990 --> 00:18:17,000
as soon as you call the initial observe

00:18:14,600 --> 00:18:18,820
it observe so when you first to the

00:18:17,000 --> 00:18:22,640
first set up you will get one callback

00:18:18,820 --> 00:18:24,470
which is useful to know this is what I

00:18:22,640 --> 00:18:26,810
already said because or the change sorry

00:18:24,470 --> 00:18:29,390
about that this is what's also

00:18:26,810 --> 00:18:34,550
interesting to know because I wasn't

00:18:29,390 --> 00:18:36,770
really expecting this so what happens if

00:18:34,550 --> 00:18:38,540
the browser is really really busy if you

00:18:36,770 --> 00:18:40,160
used to Scrolls really really fast you

00:18:38,540 --> 00:18:41,840
have a lot going on and you're doing

00:18:40,160 --> 00:18:43,820
intersection observing on like a really

00:18:41,840 --> 00:18:47,540
thin element that passes by on the

00:18:43,820 --> 00:18:49,670
screen for 10 milliseconds it's actually

00:18:47,540 --> 00:18:52,400
possible that you don't get any call

00:18:49,670 --> 00:18:55,280
backs at all I'm not sure if this is a

00:18:52,400 --> 00:18:57,440
bug or not in chrome for example this

00:18:55,280 --> 00:18:58,700
doesn't seem to happen much at all like

00:18:57,440 --> 00:19:00,950
it's really hard to reproduce this but

00:18:58,700 --> 00:19:03,710
in Firefox in my tests you can get this

00:19:00,950 --> 00:19:06,290
to happen quite reliably it's just

00:19:03,710 --> 00:19:09,860
another point to note about this API

00:19:06,290 --> 00:19:12,830
that this API is not about getting exact

00:19:09,860 --> 00:19:16,580
data it's about getting a performance in

00:19:12,830 --> 00:19:17,990
you monitoring the trade-offs are in

00:19:16,580 --> 00:19:22,370
order for it to be performant rather

00:19:17,990 --> 00:19:24,290
than to be super accurate but for most

00:19:22,370 --> 00:19:25,520
use cases which we use intersection of

00:19:24,290 --> 00:19:27,050
server for this should not really be a

00:19:25,520 --> 00:19:30,050
problem it's just something worth noting

00:19:27,050 --> 00:19:31,820
okay a few more things little bit

00:19:30,050 --> 00:19:33,410
quickly what I've said so far I will not

00:19:31,820 --> 00:19:36,050
allow you to determine what direction

00:19:33,410 --> 00:19:37,430
something is coming into view from we

00:19:36,050 --> 00:19:40,100
can only tell whether it's going

00:19:37,430 --> 00:19:41,690
interview or out of view but remember

00:19:40,100 --> 00:19:43,760
the bounding client rectangle that I

00:19:41,690 --> 00:19:46,100
said we had an expensive gift bounding

00:19:43,760 --> 00:19:47,390
client rectangle method we could call

00:19:46,100 --> 00:19:49,420
before but we couldn't call it because

00:19:47,390 --> 00:19:51,920
was too slow intersection of server

00:19:49,420 --> 00:19:54,410
provides us a static read value of this

00:19:51,920 --> 00:19:56,150
exact same kind that comes on each entry

00:19:54,410 --> 00:19:59,270
that you get in the callback so you get

00:19:56,150 --> 00:20:00,559
this value for free and using the this

00:19:59,270 --> 00:20:02,840
which tells you the relative position

00:20:00,559 --> 00:20:03,920
together with is intersecting you can

00:20:02,840 --> 00:20:05,330
tell whether something is coming

00:20:03,920 --> 00:20:06,410
interview or coming out of you and

00:20:05,330 --> 00:20:09,110
whether it's coming in from the bottom

00:20:06,410 --> 00:20:10,550
or left to right or if you can use it to

00:20:09,110 --> 00:20:13,940
determine their direction which is

00:20:10,550 --> 00:20:16,040
useful at something else about observers

00:20:13,940 --> 00:20:18,530
from another useful thing in the API I

00:20:16,040 --> 00:20:21,770
already covered that you can reuse the

00:20:18,530 --> 00:20:23,750
observer you can call observer that

00:20:21,770 --> 00:20:27,170
observe multiple times with multiple Dom

00:20:23,750 --> 00:20:29,480
elements it's also possible to use

00:20:27,170 --> 00:20:31,010
multiple observers at the same time if

00:20:29,480 --> 00:20:33,170
you need to spot pass in different

00:20:31,010 --> 00:20:34,250
configurations which is what I did in

00:20:33,170 --> 00:20:36,920
the demo when I passed different

00:20:34,250 --> 00:20:38,960
thresholds for each of the elements just

00:20:36,920 --> 00:20:40,760
to show off what the threshold does it's

00:20:38,960 --> 00:20:42,110
probably more common to actually call

00:20:40,760 --> 00:20:46,910
observe multiple times on the same

00:20:42,110 --> 00:20:49,790
elements but you can do both to clean up

00:20:46,910 --> 00:20:54,140
our intersection observers after we've

00:20:49,790 --> 00:20:56,690
done with them you can call observer the

00:20:54,140 --> 00:20:58,250
unobserved inside the callback so in

00:20:56,690 --> 00:21:00,290
this example let's say you your lazy

00:20:58,250 --> 00:21:02,090
loading some images once they come into

00:21:00,290 --> 00:21:05,179
view you do some lazy loading image

00:21:02,090 --> 00:21:06,980
logic then you stop observing them so

00:21:05,179 --> 00:21:09,050
the browser can free up that space and

00:21:06,980 --> 00:21:12,350
like stop consuming resources for this

00:21:09,050 --> 00:21:14,090
and you call up unobserved we enter the

00:21:12,350 --> 00:21:15,650
target which is the Dom element that you

00:21:14,090 --> 00:21:17,750
observed to begin with so this will be

00:21:15,650 --> 00:21:19,280
your link or your div or whatever it is

00:21:17,750 --> 00:21:21,530
you passed in and you can obviously use

00:21:19,280 --> 00:21:23,150
entry to target obviously okay you can

00:21:21,530 --> 00:21:27,530
also use entry to target for other

00:21:23,150 --> 00:21:30,140
things but on observing is one of the

00:21:27,530 --> 00:21:31,910
things you can use it for further to

00:21:30,140 --> 00:21:34,640
clean up you can also use call

00:21:31,910 --> 00:21:36,470
disconnect on the observer itself this

00:21:34,640 --> 00:21:38,390
can be very useful for example if you

00:21:36,470 --> 00:21:40,010
have a single page application you set

00:21:38,390 --> 00:21:42,020
up a lot of observing and now you're

00:21:40,010 --> 00:21:43,190
leaving page to another page and you

00:21:42,020 --> 00:21:45,350
just want to clean everything up then

00:21:43,190 --> 00:21:47,179
you call observe the disconnect and it

00:21:45,350 --> 00:21:49,970
just unobserved all the elements for you

00:21:47,179 --> 00:21:53,179
just cleans everything up so it's useful

00:21:49,970 --> 00:21:54,920
for that the final thing I think that I

00:21:53,179 --> 00:21:57,590
wanted to say from the API and that it's

00:21:54,920 --> 00:21:59,570
quite useful is there's another option

00:21:57,590 --> 00:22:01,670
on the config for the intersection

00:21:59,570 --> 00:22:06,740
observer when we initiate it which is

00:22:01,670 --> 00:22:08,660
called route margin which changes the

00:22:06,740 --> 00:22:12,460
dimensions that are used for the routes

00:22:08,660 --> 00:22:13,600
by default viewport when it's considered

00:22:12,460 --> 00:22:15,610
when we consider whether something is

00:22:13,600 --> 00:22:16,870
intersecting or not and I'll show you

00:22:15,610 --> 00:22:19,090
what I mean by that but first I just

00:22:16,870 --> 00:22:22,120
want to say Ruth Margene is a CSS margin

00:22:19,090 --> 00:22:23,950
it's but it's pixels so it's top top

00:22:22,120 --> 00:22:26,620
right bottom left just as we've used to

00:22:23,950 --> 00:22:29,170
it can be pixels or percentages no other

00:22:26,620 --> 00:22:31,930
values are supported currently but these

00:22:29,170 --> 00:22:35,080
are the ones that can be used and I had

00:22:31,930 --> 00:22:36,850
a very quick and yes you can use

00:22:35,080 --> 00:22:39,640
negative margins which is also very

00:22:36,850 --> 00:22:43,080
useful so we have one more demo it's

00:22:39,640 --> 00:22:45,340
very quick in this on intersect

00:22:43,080 --> 00:22:46,600
callback I'm you're starting a class if

00:22:45,340 --> 00:22:48,250
it's in view and removing the class

00:22:46,600 --> 00:22:49,840
service and the elements out of you and

00:22:48,250 --> 00:22:51,210
with the class I'm only changing the

00:22:49,840 --> 00:22:58,240
background color so it's kind of simple

00:22:51,210 --> 00:23:00,580
it's kind of fuse well never mind what

00:22:58,240 --> 00:23:02,770
it is so the interesting point here is

00:23:00,580 --> 00:23:06,490
I'm setting a root margin of negative

00:23:02,770 --> 00:23:08,590
200 pixels and used to show off that you

00:23:06,490 --> 00:23:10,420
would expect that as soon as the

00:23:08,590 --> 00:23:12,370
elements come into view they will be

00:23:10,420 --> 00:23:14,800
green but because I've said a negative

00:23:12,370 --> 00:23:16,510
root margin of 200 pixels the change

00:23:14,800 --> 00:23:19,270
happens 200 pixels later

00:23:16,510 --> 00:23:20,860
that's what root margin thus if I set it

00:23:19,270 --> 00:23:23,380
to a positive value you know you can't

00:23:20,860 --> 00:23:25,480
really see this because then the change

00:23:23,380 --> 00:23:30,690
will happen when when elements outside

00:23:25,480 --> 00:23:30,690
of screen so that's not so easy to demo

00:23:32,010 --> 00:23:35,650
but-but-but I will say something about

00:23:33,730 --> 00:23:37,270
that you said the most common use case

00:23:35,650 --> 00:23:40,450
though of a root margin I would say is

00:23:37,270 --> 00:23:42,910
use the positive margin to start some

00:23:40,450 --> 00:23:44,590
lazy loading logic not just exactly when

00:23:42,910 --> 00:23:47,800
the element is about to enter the screen

00:23:44,590 --> 00:23:49,120
but maybe you know one screen ahead of

00:23:47,800 --> 00:23:51,700
time something like that you do it a

00:23:49,120 --> 00:23:53,320
little bit earlier you could use

00:23:51,700 --> 00:23:54,820
negative margins for certain things but

00:23:53,320 --> 00:23:56,170
let's not go into that because it's I

00:23:54,820 --> 00:23:58,870
haven't thought of a good use case for a

00:23:56,170 --> 00:24:00,130
negative margin actually okay so this

00:23:58,870 --> 00:24:02,200
API is pretty cool but what about

00:24:00,130 --> 00:24:03,850
support can we actually use it today

00:24:02,200 --> 00:24:05,440
this is something you always needing to

00:24:03,850 --> 00:24:09,400
know when you're working with new web

00:24:05,440 --> 00:24:11,230
api's generally the support is quite

00:24:09,400 --> 00:24:13,150
good nowadays it's already supported in

00:24:11,230 --> 00:24:16,180
the latest versions of edge Firefox and

00:24:13,150 --> 00:24:18,430
Chrome and opera but unfortunately it's

00:24:16,180 --> 00:24:20,560
not yet supported in Safari although

00:24:18,430 --> 00:24:22,630
they're working on it but this means

00:24:20,560 --> 00:24:25,150
that you need a support strategy but

00:24:22,630 --> 00:24:25,789
it's quite this is quite easy it's quite

00:24:25,150 --> 00:24:28,369
you can

00:24:25,789 --> 00:24:32,299
do it well without any but some with

00:24:28,369 --> 00:24:34,639
some work I have two different support

00:24:32,299 --> 00:24:35,929
strategies to recommend it so you can

00:24:34,639 --> 00:24:37,070
use progressive enhancements and used to

00:24:35,929 --> 00:24:38,720
something like have a baseline that

00:24:37,070 --> 00:24:39,409
works even when intersection of service

00:24:38,720 --> 00:24:40,850
not available

00:24:39,409 --> 00:24:42,169
so instead of lazy loading the images

00:24:40,850 --> 00:24:43,820
used load them in some traditional way

00:24:42,169 --> 00:24:45,799
and you start the lazy loading if you

00:24:43,820 --> 00:24:47,690
haven't a second observer available but

00:24:45,799 --> 00:24:49,009
I would Jackson Lee recommend to use the

00:24:47,690 --> 00:24:51,499
polyfill for intersection observer

00:24:49,009 --> 00:24:53,419
because the polyfill that the ones that

00:24:51,499 --> 00:24:55,279
are available they come in at about one

00:24:53,419 --> 00:24:58,669
kilobyte gzipped and if you use a

00:24:55,279 --> 00:25:02,929
polyfill service like this one by yeah

00:24:58,669 --> 00:25:04,789
it's quite nice they they only return

00:25:02,929 --> 00:25:06,499
the polyfill the code that's needed and

00:25:04,789 --> 00:25:08,149
only executed for browsers that actually

00:25:06,499 --> 00:25:09,710
need it so you don't incur any real

00:25:08,149 --> 00:25:14,840
penalty if you use it in a modern

00:25:09,710 --> 00:25:15,889
browser one thing really quickly to know

00:25:14,840 --> 00:25:17,419
what the pole the field obviously

00:25:15,889 --> 00:25:19,279
doesn't work exactly the same as the

00:25:17,419 --> 00:25:22,729
real code because it doesn't use the

00:25:19,279 --> 00:25:24,799
same API so it's as performant as the

00:25:22,729 --> 00:25:26,450
real intersection observer but the trade

00:25:24,799 --> 00:25:28,279
of they made to make it as performant is

00:25:26,450 --> 00:25:30,289
that unlike the real intersection

00:25:28,279 --> 00:25:32,539
observer API the polyfill by default

00:25:30,289 --> 00:25:34,580
does not for example react to if you

00:25:32,539 --> 00:25:37,249
change dimensions of an element inside a

00:25:34,580 --> 00:25:39,710
CSS hover or transform or something like

00:25:37,249 --> 00:25:43,039
that it doesn't update if you resize a

00:25:39,710 --> 00:25:44,029
text area on your page so by default it

00:25:43,039 --> 00:25:45,440
doesn't do anything like that it's

00:25:44,029 --> 00:25:47,029
probably you probably won't need it for

00:25:45,440 --> 00:25:48,559
your use case but the palatal can be

00:25:47,029 --> 00:25:51,499
configured to support anything you

00:25:48,559 --> 00:25:54,200
needed to do it's just not doing that by

00:25:51,499 --> 00:25:54,950
default for performance reasons so the

00:25:54,200 --> 00:25:58,129
final thing I'm going to talk about

00:25:54,950 --> 00:25:59,509
today is how we use intersection

00:25:58,129 --> 00:26:02,509
observer at snip so the company I work

00:25:59,509 --> 00:26:05,450
at so we use react how many people use

00:26:02,509 --> 00:26:08,210
react in this room quite a few yeah

00:26:05,450 --> 00:26:09,470
nowadays it's very popular so I'll say

00:26:08,210 --> 00:26:11,269
something about how we use it with react

00:26:09,470 --> 00:26:13,940
so we use react because react uses

00:26:11,269 --> 00:26:16,789
components and react focuses on

00:26:13,940 --> 00:26:18,409
declarative code which we love and I'll

00:26:16,789 --> 00:26:20,139
say something about declarative code so

00:26:18,409 --> 00:26:23,149
everybody knows what I'm talking about

00:26:20,139 --> 00:26:25,070
declarative is like placing an order

00:26:23,149 --> 00:26:27,109
like saying I want a Big Mac and I don't

00:26:25,070 --> 00:26:29,210
care how you make it I'm just specifying

00:26:27,109 --> 00:26:30,499
the result whereas imperative is a

00:26:29,210 --> 00:26:33,080
little bit more like a recipe it's like

00:26:30,499 --> 00:26:34,849
okay cut the cucumber rinse the salad

00:26:33,080 --> 00:26:36,139
step by step you have to kind of read

00:26:34,849 --> 00:26:38,059
the whole recipe to know what you're

00:26:36,139 --> 00:26:39,530
going to get in the end and where I'm

00:26:38,059 --> 00:26:41,540
going with this is Dom

00:26:39,530 --> 00:26:44,720
manipulation is kind of imperative it's

00:26:41,540 --> 00:26:47,690
like we create an observer we observe

00:26:44,720 --> 00:26:50,780
some elements we specify step by step

00:26:47,690 --> 00:26:52,340
what we're going to do when an update we

00:26:50,780 --> 00:26:54,410
receive an update so we don't want to

00:26:52,340 --> 00:26:56,900
sprinkle this kind of code everywhere in

00:26:54,410 --> 00:26:59,210
our code base if we have usage use cases

00:26:56,900 --> 00:27:01,760
for intersection observer commonly which

00:26:59,210 --> 00:27:03,830
we do so we create a react component to

00:27:01,760 --> 00:27:06,110
handle this of course so we have an

00:27:03,830 --> 00:27:08,480
element that we want to animate in we

00:27:06,110 --> 00:27:10,700
wrap it in our own in view monitor and

00:27:08,480 --> 00:27:14,000
we say when it comes into view we add a

00:27:10,700 --> 00:27:16,190
class name like animate it and fade it

00:27:14,000 --> 00:27:18,080
in so with this you can use reveal

00:27:16,190 --> 00:27:20,600
animations like the animation I showed

00:27:18,080 --> 00:27:22,880
in the beginning you can pass child

00:27:20,600 --> 00:27:24,650
props so you can start playing a video

00:27:22,880 --> 00:27:26,900
as soon as the elements come into view

00:27:24,650 --> 00:27:28,430
and this is really handy not just to

00:27:26,900 --> 00:27:30,470
start water playing videos but also to

00:27:28,430 --> 00:27:32,720
stop them and they go out of view so you

00:27:30,470 --> 00:27:35,660
stop using that GPU and you stop killing

00:27:32,720 --> 00:27:37,220
mobile battery which can you can drain

00:27:35,660 --> 00:27:39,290
really fast if you have a lot of videos

00:27:37,220 --> 00:27:41,720
that just keep on playing as even after

00:27:39,290 --> 00:27:43,550
you scrolled past them you can all you

00:27:41,720 --> 00:27:45,140
can use this for for more things you can

00:27:43,550 --> 00:27:46,190
you can do things like tracking when

00:27:45,140 --> 00:27:47,780
elements come into you which is

00:27:46,190 --> 00:27:49,280
something I mentioned before and with a

00:27:47,780 --> 00:27:52,820
custom callback function you can do

00:27:49,280 --> 00:27:55,490
anything you want it's just a wrapper on

00:27:52,820 --> 00:27:57,020
top of intersection observer so we call

00:27:55,490 --> 00:27:58,550
this library acting view monitor it's

00:27:57,020 --> 00:28:00,200
declarative easy to use it uses

00:27:58,550 --> 00:28:02,780
intersection observer under the hood and

00:28:00,200 --> 00:28:06,940
it's open source so if you want to use

00:28:02,780 --> 00:28:09,110
it you can do so you can find it here in

00:28:06,940 --> 00:28:11,540
summary about intersection observer

00:28:09,110 --> 00:28:13,400
intersection service here you can use it

00:28:11,540 --> 00:28:15,110
today you can use it with this polyfill

00:28:13,400 --> 00:28:17,360
this is what we do it it works now you

00:28:15,110 --> 00:28:19,580
don't have to wait for in view detection

00:28:17,360 --> 00:28:21,440
it is an easier and much better option

00:28:19,580 --> 00:28:23,030
than what we've had before manually

00:28:21,440 --> 00:28:25,520
declaring scroll event listeners and

00:28:23,030 --> 00:28:28,940
writing all that code for yourself so

00:28:25,520 --> 00:28:31,190
closing we are also hiring at snips if

00:28:28,940 --> 00:28:33,440
you are open to an amazing adventure

00:28:31,190 --> 00:28:35,660
like follow I worked in London before I

00:28:33,440 --> 00:28:37,640
took a journey to Paris where I work now

00:28:35,660 --> 00:28:39,200
and I work in an amazing company and a I

00:28:37,640 --> 00:28:40,010
company which is the greatest company I

00:28:39,200 --> 00:28:41,330
work ever worked in

00:28:40,010 --> 00:28:43,220
we are also hiring we're having

00:28:41,330 --> 00:28:45,560
specifically for the front end so if

00:28:43,220 --> 00:28:50,250
you're interested check us out or come

00:28:45,560 --> 00:28:52,310
and talk to me and that's all thank you

00:28:50,250 --> 00:28:52,310

YouTube URL: https://www.youtube.com/watch?v=O3S5K6yPHz4


