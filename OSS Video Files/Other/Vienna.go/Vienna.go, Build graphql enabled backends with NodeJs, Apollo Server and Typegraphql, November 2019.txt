Title: Vienna.go, Build graphql enabled backends with NodeJs, Apollo Server and Typegraphql, November 2019
Publication date: 2019-11-28
Playlist: Vienna.go
Description: 
	Talk by Markus HÃ¶sel
Captions: 
	00:00:00,030 --> 00:00:06,390
so today I actually want to show you a

00:00:03,330 --> 00:00:08,400
side project I've been working on the

00:00:06,390 --> 00:00:11,460
last couple of days and in my free time

00:00:08,400 --> 00:00:15,420
and I want to go through the code and

00:00:11,460 --> 00:00:18,660
then show you in which problems I run so

00:00:15,420 --> 00:00:21,449
as I already mentioned I build a graph

00:00:18,660 --> 00:00:24,859
curl back and using no chairs and a polo

00:00:21,449 --> 00:00:30,449
and for the four story at a time using

00:00:24,859 --> 00:00:32,550
Postgres database database and as my

00:00:30,449 --> 00:00:37,649
object relational map I'm using typo I

00:00:32,550 --> 00:00:40,170
am now - kinda cute a graph QL part and

00:00:37,649 --> 00:00:45,379
database part together I'm using a

00:00:40,170 --> 00:00:48,420
library called typed graph quail so

00:00:45,379 --> 00:00:50,789
after we saw it setup and how you can

00:00:48,420 --> 00:00:52,170
build a basic graphical so I want to

00:00:50,789 --> 00:00:54,660
walk through some problems I've

00:00:52,170 --> 00:00:57,030
encountered so there are five problems

00:00:54,660 --> 00:01:01,850
I've listed here and then I'll show you

00:00:57,030 --> 00:01:05,880
how I solved them so just to give you

00:01:01,850 --> 00:01:08,850
the context and I want to show you the

00:01:05,880 --> 00:01:11,100
application of field it's for a fitness

00:01:08,850 --> 00:01:14,220
studio and you can see here take fitness

00:01:11,100 --> 00:01:17,030
courses they offer so for example today

00:01:14,220 --> 00:01:19,920
at 9 a.m. there was this yoga course and

00:01:17,030 --> 00:01:24,270
we've we've subscribed to this course

00:01:19,920 --> 00:01:27,000
and now there are other courses where we

00:01:24,270 --> 00:01:28,680
can subscribe or unsubscribe - so we can

00:01:27,000 --> 00:01:31,259
see here on the right side by this part

00:01:28,680 --> 00:01:34,259
that this is a fully paid generated list

00:01:31,259 --> 00:01:36,150
where we can scroll up and down then we

00:01:34,259 --> 00:01:40,170
also can click on the detail page and

00:01:36,150 --> 00:01:45,329
for example write the comment and your

00:01:40,170 --> 00:01:50,970
exploit explore those now the way I've

00:01:45,329 --> 00:01:52,770
built this is we can see this here so

00:01:50,970 --> 00:01:55,920
the basic structure is I have an entity

00:01:52,770 --> 00:01:58,770
folder and here I have all my entities

00:01:55,920 --> 00:02:02,180
so each file represents a table in my

00:01:58,770 --> 00:02:07,649
database then I have some middleware and

00:02:02,180 --> 00:02:09,629
my graph Cal resolvers so these are

00:02:07,649 --> 00:02:11,610
actually the handless which go out to

00:02:09,629 --> 00:02:13,190
the database fetch the data and return

00:02:11,610 --> 00:02:16,880
those to the

00:02:13,190 --> 00:02:19,280
questing' user and then I have some

00:02:16,880 --> 00:02:21,260
helper methods for mailing and so on but

00:02:19,280 --> 00:02:24,980
it's not so important for this talk and

00:02:21,260 --> 00:02:30,650
then I have the main file the index ts

00:02:24,980 --> 00:02:33,020
file where I start my server so and here

00:02:30,650 --> 00:02:35,510
we can see that the first thing I'm

00:02:33,020 --> 00:02:39,590
doing i create my database connection

00:02:35,510 --> 00:02:42,440
and i'm load is loading my entities so

00:02:39,590 --> 00:02:45,500
let's just explore how such an entity

00:02:42,440 --> 00:02:47,540
looks so here we have for example the

00:02:45,500 --> 00:02:51,110
access token which is a very simple

00:02:47,540 --> 00:02:53,180
entity we see that it's a this whole

00:02:51,110 --> 00:02:56,360
type or anything is care space and users

00:02:53,180 --> 00:02:58,610
decorators so here with this entity

00:02:56,360 --> 00:03:00,500
decorator we are telling type or M okay

00:02:58,610 --> 00:03:02,870
this is a table we want to have in our

00:03:00,500 --> 00:03:06,470
database and then we have some fields

00:03:02,870 --> 00:03:09,530
here and we annotate them so that type

00:03:06,470 --> 00:03:14,300
where M knows how this field should out

00:03:09,530 --> 00:03:16,160
which type the column should have now we

00:03:14,300 --> 00:03:19,160
can also see an example here of how the

00:03:16,160 --> 00:03:22,900
relation look in type o M so here an

00:03:19,160 --> 00:03:27,430
access token belongs to one user and

00:03:22,900 --> 00:03:30,200
gets deleted when the user gets deleted

00:03:27,430 --> 00:03:32,390
now let's jump back to our index file

00:03:30,200 --> 00:03:36,040
here we can see that our as a next step

00:03:32,390 --> 00:03:39,020
we initializing our server and then

00:03:36,040 --> 00:03:44,560
we'll come back to this part later but

00:03:39,020 --> 00:03:47,900
here we are finding our CLS context and

00:03:44,560 --> 00:03:50,300
here we already almost finished in this

00:03:47,900 --> 00:03:51,980
step we are building our schema so in

00:03:50,300 --> 00:03:54,620
graph curl you have actually two parts

00:03:51,980 --> 00:03:57,410
you have a schema which define the types

00:03:54,620 --> 00:03:59,930
that back-end offers and then you have

00:03:57,410 --> 00:04:02,030
the resolvers which I already mentioned

00:03:59,930 --> 00:04:04,880
go out to the database get a data of

00:04:02,030 --> 00:04:08,739
from some other data source and return

00:04:04,880 --> 00:04:11,989
it so the resolvers act upon these types

00:04:08,739 --> 00:04:14,420
yeah and with the schema we can then

00:04:11,989 --> 00:04:18,200
create our Paulo server if the schema

00:04:14,420 --> 00:04:21,019
and we are also having some some hooks

00:04:18,200 --> 00:04:24,169
like the authentication hook and some

00:04:21,019 --> 00:04:26,510
plugins we also will take a look at the

00:04:24,169 --> 00:04:27,139
plugins later on and then we can bind

00:04:26,510 --> 00:04:31,870
the support

00:04:27,139 --> 00:04:34,909
servitor Express server and started now

00:04:31,870 --> 00:04:38,090
when you are creating an Apollo server

00:04:34,909 --> 00:04:40,129
you'll also have this playground which

00:04:38,090 --> 00:04:42,289
you can disable for production but for

00:04:40,129 --> 00:04:44,389
development it's nice to use so can you

00:04:42,289 --> 00:04:47,659
can play around with your back-end and

00:04:44,389 --> 00:04:50,029
here we also have this schema part we

00:04:47,659 --> 00:04:53,419
can see which types and which end point

00:04:50,029 --> 00:04:57,710
our back-end gives us so if we scroll

00:04:53,419 --> 00:05:01,219
down here for example you can see our

00:04:57,710 --> 00:05:05,210
mutations so here we can login a user

00:05:01,219 --> 00:05:08,569
create a comment delete a user and so on

00:05:05,210 --> 00:05:11,979
and then we have our queries so this is

00:05:08,569 --> 00:05:14,539
for example the query which I used to

00:05:11,979 --> 00:05:17,210
get a paginated list on the web web

00:05:14,539 --> 00:05:20,479
working and we also have for example

00:05:17,210 --> 00:05:23,240
this me query which returns the user who

00:05:20,479 --> 00:05:26,180
is performing the request and here we

00:05:23,240 --> 00:05:28,759
can see the type so on the me query I as

00:05:26,180 --> 00:05:33,589
a client can access some properties from

00:05:28,759 --> 00:05:35,569
this user type and this user type is the

00:05:33,589 --> 00:05:37,699
scribe down here so these are all the

00:05:35,569 --> 00:05:38,300
properties we can request from the user

00:05:37,699 --> 00:05:40,129
type

00:05:38,300 --> 00:05:42,139
these are simple types like an email

00:05:40,129 --> 00:05:44,719
which is a string but we also can

00:05:42,139 --> 00:05:47,110
include subscriptions so we also can

00:05:44,719 --> 00:05:51,649
fetch for example the trainings which

00:05:47,110 --> 00:05:56,509
we've been to which we subscribed now

00:05:51,649 --> 00:06:00,139
how does this look in the code actually

00:05:56,509 --> 00:06:05,839
the types which we want to be able are

00:06:00,139 --> 00:06:07,009
also annotated on the yes here so we

00:06:05,839 --> 00:06:08,779
didn't see this on the access token

00:06:07,009 --> 00:06:09,860
because the access shouldn't be

00:06:08,779 --> 00:06:15,099
queryable

00:06:09,860 --> 00:06:17,750
but here on this user entity we can see

00:06:15,099 --> 00:06:19,909
we are creating a table and we can see

00:06:17,750 --> 00:06:23,589
the annotations we already saw on the

00:06:19,909 --> 00:06:26,120
access token but now we also have our

00:06:23,589 --> 00:06:28,399
decorators which come in from the type

00:06:26,120 --> 00:06:31,639
graphical library and so here we are

00:06:28,399 --> 00:06:33,830
telling the type craft curl back end ok

00:06:31,639 --> 00:06:37,250
we have here an object and this object

00:06:33,830 --> 00:06:40,790
has some types that you'll be able query

00:06:37,250 --> 00:06:43,670
able for example the ID the email Antony

00:06:40,790 --> 00:06:46,550
so that's why we see those properties

00:06:43,670 --> 00:06:50,150
here back here in our schema and for

00:06:46,550 --> 00:06:51,770
example the password does not have to

00:06:50,150 --> 00:06:54,860
feel decorate and that's why it's not

00:06:51,770 --> 00:06:57,860
popping up here now the way we get the

00:06:54,860 --> 00:07:01,160
data from our back-end is by writing

00:06:57,860 --> 00:07:05,510
resolvers so here on this use of a

00:07:01,160 --> 00:07:08,150
resolver for example we can see it's a

00:07:05,510 --> 00:07:10,520
class annotated with the resolver class

00:07:08,150 --> 00:07:12,950
which also comes in from this typed

00:07:10,520 --> 00:07:17,140
graphic where library so it considers

00:07:12,950 --> 00:07:19,850
here and then on this class we have our

00:07:17,140 --> 00:07:22,280
queries and mutations which are related

00:07:19,850 --> 00:07:24,140
to the user so here for example we can

00:07:22,280 --> 00:07:27,640
see this me query I've been talking

00:07:24,140 --> 00:07:30,850
about and we're getting an argument

00:07:27,640 --> 00:07:33,890
named context and based on this we can

00:07:30,850 --> 00:07:36,890
return the user which is currently

00:07:33,890 --> 00:07:40,340
requesting which is currently performing

00:07:36,890 --> 00:07:43,250
a request so back here in our playground

00:07:40,340 --> 00:07:45,890
we can now close the schema and I've

00:07:43,250 --> 00:07:48,260
already have this query here so that's

00:07:45,890 --> 00:07:52,070
the my query and we can see here which

00:07:48,260 --> 00:07:54,710
are types we can fetch so i'm now

00:07:52,070 --> 00:07:56,720
requesting those four properties and if

00:07:54,710 --> 00:07:58,790
i hit play we're now getting back

00:07:56,720 --> 00:08:02,750
exactly those four properties we've been

00:07:58,790 --> 00:08:05,090
asking for and yeah this is how we can

00:08:02,750 --> 00:08:07,820
set up our queries and for the mutations

00:08:05,090 --> 00:08:09,770
it's very similar for example here we

00:08:07,820 --> 00:08:12,470
have a mutation to create the user and

00:08:09,770 --> 00:08:15,650
this mutation takes in an argument a

00:08:12,470 --> 00:08:18,740
payload and this payload is further

00:08:15,650 --> 00:08:20,930
described with the type graph graph

00:08:18,740 --> 00:08:23,270
quail library again and I'm also making

00:08:20,930 --> 00:08:25,520
use of a case validator so here I say

00:08:23,270 --> 00:08:27,860
okay in order to create the user I am

00:08:25,520 --> 00:08:30,110
expecting an email and the name and the

00:08:27,860 --> 00:08:33,530
password in the payload and I also can

00:08:30,110 --> 00:08:37,099
do some validation so for the email

00:08:33,530 --> 00:08:39,410
field I want to have it that it has a

00:08:37,099 --> 00:08:42,560
min length and a max length and it

00:08:39,410 --> 00:08:48,350
should have the typical symbols for an

00:08:42,560 --> 00:08:50,840
email in it all right so that's

00:08:48,350 --> 00:08:52,820
basically how you can set up a graphical

00:08:50,840 --> 00:08:53,840
server with some queries and with some

00:08:52,820 --> 00:08:57,090
mutations

00:08:53,840 --> 00:09:00,780
now if we take a look back here we saw

00:08:57,090 --> 00:09:03,510
that we have a few problems problems the

00:09:00,780 --> 00:09:08,040
first one is a rather simple problem and

00:09:03,510 --> 00:09:10,580
it's not related to craft wear so if we

00:09:08,040 --> 00:09:19,800
take a look at our trainings query here

00:09:10,580 --> 00:09:22,560
we can sorry we can fetch a list of

00:09:19,800 --> 00:09:26,610
trainings now in this example I've

00:09:22,560 --> 00:09:29,910
fetched five trainings and now we as a

00:09:26,610 --> 00:09:31,910
grant could to write

00:09:29,910 --> 00:09:34,860
malicious query by for example X

00:09:31,910 --> 00:09:35,970
requesting five millions of the

00:09:34,860 --> 00:09:37,650
trainings or so on

00:09:35,970 --> 00:09:39,690
if the server really would start to

00:09:37,650 --> 00:09:42,720
process it we would probably get a

00:09:39,690 --> 00:09:46,760
problem now in this case I'm getting an

00:09:42,720 --> 00:09:50,190
error back that we reached a maximum and

00:09:46,760 --> 00:09:52,590
the way I solve this with this stack

00:09:50,190 --> 00:09:58,710
here is if we take a look at training

00:09:52,590 --> 00:10:01,320
three sofa so this is this is the query

00:09:58,710 --> 00:10:04,110
I've just executed and here we can see

00:10:01,320 --> 00:10:05,640
the two arguments of certain limit they

00:10:04,110 --> 00:10:08,160
are an object and this is the type

00:10:05,640 --> 00:10:09,930
definition here and if you jump a champ

00:10:08,160 --> 00:10:11,520
to this type definition I say okay for

00:10:09,930 --> 00:10:13,860
the offset it's okay to be an integer

00:10:11,520 --> 00:10:16,620
but for the limit I want it to be of

00:10:13,860 --> 00:10:21,450
type pagination limit and dissipation

00:10:16,620 --> 00:10:24,300
agent limit is a custom scalar type so

00:10:21,450 --> 00:10:26,220
in Kafka well you have some basic types

00:10:24,300 --> 00:10:29,790
like the object type the arrow type and

00:10:26,220 --> 00:10:33,450
some some simple types like string

00:10:29,790 --> 00:10:35,520
integer float and so and boolean I guess

00:10:33,450 --> 00:10:37,560
and you can use these types to create

00:10:35,520 --> 00:10:40,710
your own custom types and this is what I

00:10:37,560 --> 00:10:43,380
did here and I say ok maximum of 100 is

00:10:40,710 --> 00:10:50,840
allowed otherwise I shoot the back and

00:10:43,380 --> 00:10:54,990
should raise an error oops okay so now

00:10:50,840 --> 00:10:58,620
another problem which arrived riced and

00:10:54,990 --> 00:11:03,050
which is which can be hard to track is a

00:10:58,620 --> 00:11:03,050
graph through traversal attack

00:11:04,170 --> 00:11:10,449
so if we take a look back at our

00:11:07,179 --> 00:11:13,329
playground and the me query we saw that

00:11:10,449 --> 00:11:15,189
we can't create a password field now

00:11:13,329 --> 00:11:18,009
let's say for some reason the users

00:11:15,189 --> 00:11:19,990
should be able to see its own hash

00:11:18,009 --> 00:11:22,689
password but not the pass the hash

00:11:19,990 --> 00:11:24,550
password from some different user now a

00:11:22,689 --> 00:11:27,069
naive approach would be to jump back

00:11:24,550 --> 00:11:35,499
over to our user resolver to a user

00:11:27,069 --> 00:11:39,240
entity and let's add the field decorator

00:11:35,499 --> 00:11:39,240
to this password

00:11:47,760 --> 00:11:51,120
I'm here on the wrong window I was

00:11:50,040 --> 00:11:57,660
wondering where the server did not

00:11:51,120 --> 00:12:00,829
restart but it actually did so the

00:11:57,660 --> 00:12:00,829
server still starting

00:12:12,770 --> 00:12:22,640
okay no no it took a few seconds so if I

00:12:18,800 --> 00:12:26,930
reload this tap here now I should be

00:12:22,640 --> 00:12:29,690
able to create a password as well and if

00:12:26,930 --> 00:12:31,880
I perform this query I'm getting back

00:12:29,690 --> 00:12:34,250
the password but if I jump over to this

00:12:31,880 --> 00:12:37,399
user query I can now access the password

00:12:34,250 --> 00:12:40,550
of each user and that's not what I want

00:12:37,399 --> 00:12:42,680
so I need a way to do authorization not

00:12:40,550 --> 00:12:47,300
only based on the endpoint but also on

00:12:42,680 --> 00:12:49,580
that property layer and the problem now

00:12:47,300 --> 00:12:52,100
is that on this user entity I don't have

00:12:49,580 --> 00:12:54,920
access to the context I don't know which

00:12:52,100 --> 00:12:57,589
user is like performing the request and

00:12:54,920 --> 00:13:00,170
one way to solve this is to use a

00:12:57,589 --> 00:13:03,380
library called a continuation local

00:13:00,170 --> 00:13:08,060
storage so if we jump back to our index

00:13:03,380 --> 00:13:12,190
file I'm using this library here

00:13:08,060 --> 00:13:16,730
CAS which I import from this library and

00:13:12,190 --> 00:13:20,089
then I create a namespace and now I can

00:13:16,730 --> 00:13:24,920
I can use this namespace as a kind of

00:13:20,089 --> 00:13:28,339
key value store and if I scroll down

00:13:24,920 --> 00:13:30,620
here on my authentication hook which is

00:13:28,339 --> 00:13:37,520
executed each time a request comes in

00:13:30,620 --> 00:13:41,270
and try to look up a user if there is a

00:13:37,520 --> 00:13:43,550
header that kind sent along where the

00:13:41,270 --> 00:13:48,829
bureau's token is stored and if that's

00:13:43,550 --> 00:13:51,560
the case I'm setting an entry to this

00:13:48,829 --> 00:13:57,589
namespace so the key here is a user

00:13:51,560 --> 00:14:00,440
that's just a constant and sorry for

00:13:57,589 --> 00:14:04,190
jumping around that much and the value

00:14:00,440 --> 00:14:06,380
is the ID of the user so I now have the

00:14:04,190 --> 00:14:09,920
ID of the user stored in a namespace and

00:14:06,380 --> 00:14:13,690
if I go back to my user resolver item a

00:14:09,920 --> 00:14:16,339
user entity I can scroll down here and

00:14:13,690 --> 00:14:19,220
here I added a field called my password

00:14:16,339 --> 00:14:24,529
and in this field I try to look up the

00:14:19,220 --> 00:14:26,240
user ID of this namespace and then once

00:14:24,529 --> 00:14:29,860
I read I got this current you

00:14:26,240 --> 00:14:32,660
our ID I can check if the row which is

00:14:29,860 --> 00:14:34,550
which I fetched from the password if the

00:14:32,660 --> 00:14:37,220
ID is the same as the ID from the

00:14:34,550 --> 00:14:40,279
current user and it's if that's the case

00:14:37,220 --> 00:14:43,790
then I set the password this password so

00:14:40,279 --> 00:14:45,800
this field above here - this is my

00:14:43,790 --> 00:14:47,570
password variable otherwise I set it to

00:14:45,800 --> 00:14:50,720
an empty string I could also set it to

00:14:47,570 --> 00:14:51,740
null or throw an error or handling in

00:14:50,720 --> 00:14:55,910
some other way

00:14:51,740 --> 00:15:00,500
now on this user's query if I regressed

00:14:55,910 --> 00:15:02,899
my password I get back my password on

00:15:00,500 --> 00:15:04,940
this entity because that's me but on

00:15:02,899 --> 00:15:07,760
this other user here I just get an empty

00:15:04,940 --> 00:15:12,290
string so that's how one could solve

00:15:07,760 --> 00:15:14,510
this problem now if we jump back to our

00:15:12,290 --> 00:15:17,209
problem slide here we see that the next

00:15:14,510 --> 00:15:19,670
problem is called M plus 1 problem now

00:15:17,209 --> 00:15:21,770
an empress plus one problem duplicate or

00:15:19,670 --> 00:15:24,200
curse when you have an entity a parent

00:15:21,770 --> 00:15:27,649
entity and it has a many child entities

00:15:24,200 --> 00:15:29,390
so one-to-many Association now if you

00:15:27,649 --> 00:15:32,480
fetch the main entity and then you fetch

00:15:29,390 --> 00:15:35,510
each pair child entity separately you

00:15:32,480 --> 00:15:38,870
get a lot of queries I'm not having this

00:15:35,510 --> 00:15:41,230
exact problem but man is very similar so

00:15:38,870 --> 00:15:45,860
if we jump back over to the strainings

00:15:41,230 --> 00:15:54,800
query and execute it again let's put the

00:15:45,860 --> 00:15:59,300
limit break down to 5 we see that this

00:15:54,800 --> 00:16:00,800
kind of works but yeah we are fetching

00:15:59,300 --> 00:16:05,180
the title the common content

00:16:00,800 --> 00:16:07,760
subscription count now however there's a

00:16:05,180 --> 00:16:13,910
problem with that and if we go I just

00:16:07,760 --> 00:16:19,970
need to enable logging of the database

00:16:13,910 --> 00:16:22,130
statements and wait till the real server

00:16:19,970 --> 00:16:23,810
restarts we will see that ok we are

00:16:22,130 --> 00:16:27,079
fetching a list of trainings in this

00:16:23,810 --> 00:16:29,360
example 5 just one query but to get the

00:16:27,079 --> 00:16:32,990
common count we are performing one query

00:16:29,360 --> 00:16:36,610
for each training we fetch so let's

00:16:32,990 --> 00:16:36,610
perform this query again

00:16:38,779 --> 00:16:47,120
now it goes so we'll see above here we

00:16:44,779 --> 00:16:49,149
are fetching the trainings we see here

00:16:47,120 --> 00:16:52,370
there you at least of five we fetch and

00:16:49,149 --> 00:16:54,740
then we have one two three four five

00:16:52,370 --> 00:16:58,370
comment count queries and that does not

00:16:54,740 --> 00:17:08,780
scale and the problem for this is

00:16:58,370 --> 00:17:11,150
because on our training entity we have

00:17:08,780 --> 00:17:13,339
here this comment count and this goes

00:17:11,150 --> 00:17:15,559
out with a separate query to get the

00:17:13,339 --> 00:17:20,449
comment from the comment for the current

00:17:15,559 --> 00:17:22,850
training now there's a problem and one

00:17:20,449 --> 00:17:25,579
way to get around this problem is by

00:17:22,850 --> 00:17:27,020
using a library called data loader this

00:17:25,579 --> 00:17:29,330
is a library which is available in

00:17:27,020 --> 00:17:32,260
different languages because this problem

00:17:29,330 --> 00:17:35,150
occurs in in other contexts as well and

00:17:32,260 --> 00:17:37,940
I use this library to solve this problem

00:17:35,150 --> 00:17:39,410
for the subscription count so here we

00:17:37,940 --> 00:17:41,030
also have a subscription count how many

00:17:39,410 --> 00:17:44,240
people are subscribed to this training

00:17:41,030 --> 00:17:47,120
and before I use the data loader it was

00:17:44,240 --> 00:17:48,470
implemented the same way now I can't go

00:17:47,120 --> 00:17:50,240
into the details of the data loader

00:17:48,470 --> 00:17:53,840
because this would be a talk on its own

00:17:50,240 --> 00:17:57,679
part it gives us the possibility to

00:17:53,840 --> 00:18:00,620
write a function where we get an array

00:17:57,679 --> 00:18:03,590
of all IDs and that really helps us

00:18:00,620 --> 00:18:06,740
because now what we can do is we write a

00:18:03,590 --> 00:18:09,710
query which fetches all subscriptions at

00:18:06,740 --> 00:18:12,380
once and then it does some grouping so

00:18:09,710 --> 00:18:15,320
that we know okay which subscription

00:18:12,380 --> 00:18:18,620
belong to which training and as you can

00:18:15,320 --> 00:18:21,740
see down here we only doing one query

00:18:18,620 --> 00:18:24,200
for all subscriptions instead of n

00:18:21,740 --> 00:18:28,419
queries so we are reducing the n plus

00:18:24,200 --> 00:18:32,000
one or problem to a one plus one problem

00:18:28,419 --> 00:18:37,850
alright so with this library we have

00:18:32,000 --> 00:18:42,350
been able to get around this issue now

00:18:37,850 --> 00:18:43,220
the next thing we have is we can add

00:18:42,350 --> 00:18:48,440
query cost

00:18:43,220 --> 00:18:50,240
analyzers to specify if we want to allow

00:18:48,440 --> 00:18:53,630
this query in our back-end

00:18:50,240 --> 00:18:57,380
because with freedom we give to the

00:18:53,630 --> 00:18:59,240
client raises some some problems for

00:18:57,380 --> 00:19:05,270
example if we take a look at this

00:18:59,240 --> 00:19:07,730
training I'm query here it's a big query

00:19:05,270 --> 00:19:10,100
and like no one is stopping the client

00:19:07,730 --> 00:19:13,850
from writing this query or also bigger

00:19:10,100 --> 00:19:15,680
queries and what we see here is that on

00:19:13,850 --> 00:19:17,450
the trainings we can fetch subscriptions

00:19:15,680 --> 00:19:19,880
and on the subscription we can fight

00:19:17,450 --> 00:19:21,560
fetch a user and from the user we can

00:19:19,880 --> 00:19:23,330
fetch the trainings again so we are

00:19:21,560 --> 00:19:25,160
getting in a loop and we could create

00:19:23,330 --> 00:19:27,200
therefore we could create an endless

00:19:25,160 --> 00:19:29,150
long query and if the query is big

00:19:27,200 --> 00:19:33,170
enough and sent to the client it would

00:19:29,150 --> 00:19:36,560
bring our back-end down in this case

00:19:33,170 --> 00:19:40,990
we're rejecting the query now before I

00:19:36,560 --> 00:19:45,080
show you how this done I just want to

00:19:40,990 --> 00:19:47,420
talk about another option how we could

00:19:45,080 --> 00:19:49,730
prevent this we could prevent this by

00:19:47,420 --> 00:19:51,920
deftly meeting so we could say okay we

00:19:49,730 --> 00:19:53,330
only allow queries with a def of five or

00:19:51,920 --> 00:19:57,500
six and all the other queries are

00:19:53,330 --> 00:19:59,270
rejected however there's another query

00:19:57,500 --> 00:20:00,920
which could bring our server down like

00:19:59,270 --> 00:20:03,590
this one here we're fetching the

00:20:00,920 --> 00:20:05,780
trainings which is not too bad but then

00:20:03,590 --> 00:20:08,750
we are copying this query and here we

00:20:05,780 --> 00:20:12,650
have the same query again just with an

00:20:08,750 --> 00:20:14,720
alias before it and you can like copy

00:20:12,650 --> 00:20:17,450
this thousands of times and then send it

00:20:14,720 --> 00:20:21,710
off to the backend and there the def

00:20:17,450 --> 00:20:25,340
limiting option wouldn't wouldn't bring

00:20:21,710 --> 00:20:27,620
us much now one other option would be to

00:20:25,340 --> 00:20:29,270
count the characters and say okay if the

00:20:27,620 --> 00:20:31,940
query is bigger than 4,000 characters

00:20:29,270 --> 00:20:34,640
for example rejected but a solution I

00:20:31,940 --> 00:20:37,990
implemented is to count the properties

00:20:34,640 --> 00:20:43,330
and calculate weight of this properties

00:20:37,990 --> 00:20:49,250
so if we go back into our index file and

00:20:43,330 --> 00:20:54,530
scroll down here to the Apollo server

00:20:49,250 --> 00:20:57,260
here we have a query complexity they

00:20:54,530 --> 00:21:01,100
create complexity hook and here are

00:20:57,260 --> 00:21:04,360
doing some setup and then I'm using the

00:21:01,100 --> 00:21:07,000
simple estimator to calculate

00:21:04,360 --> 00:21:09,429
wait of this query and what a simple

00:21:07,000 --> 00:21:11,880
estimated two tasks and there are the

00:21:09,429 --> 00:21:14,529
estimators out there if you need them it

00:21:11,880 --> 00:21:17,409
calculates a one wait for each property

00:21:14,529 --> 00:21:20,710
we fetch so if we go back to our user

00:21:17,409 --> 00:21:23,850
key our let's say for this query we are

00:21:20,710 --> 00:21:26,830
fetching the me property which is one

00:21:23,850 --> 00:21:29,169
one wait and then we're fetching one two

00:21:26,830 --> 00:21:32,080
three four five other properties so this

00:21:29,169 --> 00:21:33,880
query has a total weight of six and now

00:21:32,080 --> 00:21:36,070
if you take a look back at our index

00:21:33,880 --> 00:21:39,340
file each query which has a weight

00:21:36,070 --> 00:21:42,820
greater than 50 gets rejected so this is

00:21:39,340 --> 00:21:46,919
why we why those two queries got

00:21:42,820 --> 00:21:53,620
rejected I'm sorry those two queries

00:21:46,919 --> 00:21:56,260
yeah yeah so that's basically it however

00:21:53,620 --> 00:21:58,799
we can customize it a bit so if we jump

00:21:56,260 --> 00:22:02,950
back to any entity and we would say okay

00:21:58,799 --> 00:22:05,380
fetching the name is like more easier

00:22:02,950 --> 00:22:07,059
than fetching the subscriptions so we

00:22:05,380 --> 00:22:09,519
could jump in here to the subscriptions

00:22:07,059 --> 00:22:11,610
and pass in an options object where we

00:22:09,519 --> 00:22:14,950
say okay the complexity of the

00:22:11,610 --> 00:22:16,570
subscription sub should be set to 10 now

00:22:14,950 --> 00:22:19,179
if the kind is regressing the

00:22:16,570 --> 00:22:21,549
subscriptions it automates automatically

00:22:19,179 --> 00:22:26,340
counts a weight of 10 for this property

00:22:21,549 --> 00:22:29,529
so we could further customize this and

00:22:26,340 --> 00:22:36,159
with this approach we can prevent this

00:22:29,529 --> 00:22:39,880
harmful attacks on our server okay so

00:22:36,159 --> 00:22:44,730
the last thing I wanted to talk about is

00:22:39,880 --> 00:22:47,559
data loading so if we go back to our

00:22:44,730 --> 00:22:51,850
playground and jump over to this query

00:22:47,559 --> 00:22:54,700
on this create looks fine but when we

00:22:51,850 --> 00:22:56,889
execute it we get an error and this

00:22:54,700 --> 00:23:00,600
shouldn't happen now if we go back to

00:22:56,889 --> 00:23:00,600
our trainings resolver

00:23:05,790 --> 00:23:11,530
we can see here this query and we see

00:23:08,590 --> 00:23:13,870
here that we are generating or that we

00:23:11,530 --> 00:23:18,480
write in this career manually and we

00:23:13,870 --> 00:23:21,580
that we edit some relations to it now

00:23:18,480 --> 00:23:25,800
while the type allows us to write this

00:23:21,580 --> 00:23:29,050
query we actually don't have

00:23:25,800 --> 00:23:34,630
subscriptions on the user so we're only

00:23:29,050 --> 00:23:37,270
including the user but yeah but you're

00:23:34,630 --> 00:23:39,400
not adding the subscriptions on the user

00:23:37,270 --> 00:23:43,090
so what's missing here is the user punk

00:23:39,400 --> 00:23:45,280
dot subscriptions so with this the query

00:23:43,090 --> 00:23:50,140
would work but now of course we would

00:23:45,280 --> 00:23:54,310
only optimize this query for one for one

00:23:50,140 --> 00:24:00,940
request so what we actually want is for

00:23:54,310 --> 00:24:02,950
example this this function here can be

00:24:00,940 --> 00:24:04,510
called with four arguments and one of

00:24:02,950 --> 00:24:08,230
these is the info argument and in the

00:24:04,510 --> 00:24:10,090
info argument we can parse the ast so

00:24:08,230 --> 00:24:12,610
that we have the information with how

00:24:10,090 --> 00:24:15,100
the query looks like and based on this

00:24:12,610 --> 00:24:19,120
we could dynamically um write our SQL

00:24:15,100 --> 00:24:21,790
statement now I did a bit of research on

00:24:19,120 --> 00:24:25,750
the internet and for typos M and this

00:24:21,790 --> 00:24:29,290
stack there's one library out there but

00:24:25,750 --> 00:24:33,570
it's kind of working

00:24:29,290 --> 00:24:38,440
but sometimes are also not that good so

00:24:33,570 --> 00:24:41,640
I've added it in another branch and I

00:24:38,440 --> 00:24:41,640
wanted to I want to show it

00:24:52,730 --> 00:24:59,399
so we can see here I've commented out a

00:24:56,070 --> 00:25:01,080
query we've just seen before and now we

00:24:59,399 --> 00:25:04,889
can see here that I'm using a library

00:25:01,080 --> 00:25:07,529
and this library expects the entity I

00:25:04,889 --> 00:25:10,440
want to load and it also expects the

00:25:07,529 --> 00:25:12,629
info object so now here I'm specifying

00:25:10,440 --> 00:25:15,389
the info object which has the

00:25:12,629 --> 00:25:18,059
information how the query looks like and

00:25:15,389 --> 00:25:21,419
with this info object the library is

00:25:18,059 --> 00:25:25,740
able to create the SQL statement on the

00:25:21,419 --> 00:25:29,249
fly so this has two advantages once we

00:25:25,740 --> 00:25:32,779
we can create our queries like we want

00:25:29,249 --> 00:25:35,009
in def and it will it will work and

00:25:32,779 --> 00:25:36,960
secondly we are not going out to fetch

00:25:35,009 --> 00:25:40,230
all attributes but only the attributes

00:25:36,960 --> 00:25:43,350
which the kind requested now if we jump

00:25:40,230 --> 00:25:46,919
over to our playground now this query it

00:25:43,350 --> 00:25:49,710
should work yep and it worked because

00:25:46,919 --> 00:25:50,279
the query was created by this library on

00:25:49,710 --> 00:25:57,960
the fly

00:25:50,279 --> 00:25:59,940
based on the input we sent all right so

00:25:57,960 --> 00:26:03,330
now we've been able to go through these

00:25:59,940 --> 00:26:05,909
five issues and I hope there are not any

00:26:03,330 --> 00:26:08,179
more issues in this backend because I

00:26:05,909 --> 00:26:10,710
want to finish the project but that

00:26:08,179 --> 00:26:13,480
brings me to the end of my presentation

00:26:10,710 --> 00:26:17,460
so thank you

00:26:13,480 --> 00:26:17,460

YouTube URL: https://www.youtube.com/watch?v=zEOwsHeXiXw


