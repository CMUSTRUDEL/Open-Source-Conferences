Title: Vienna Go, Reference in Golang, March 2018
Publication date: 2018-03-20
Playlist: Vienna.go
Description: 
	Klaus Ita gives a beginner friendly talk on references in Go, passing by reference, and more.
Captions: 
	00:00:00,149 --> 00:00:05,490
my talk is going to be beginners talk

00:00:02,340 --> 00:00:08,580
this time last time we went more into

00:00:05,490 --> 00:00:11,910
death but now I want to talk about

00:00:08,580 --> 00:00:16,920
things that happen to the two newbies

00:00:11,910 --> 00:00:21,510
actually quite a lot that fullscreen

00:00:16,920 --> 00:00:23,130
yeah and I think it could be helpful for

00:00:21,510 --> 00:00:25,260
those especially those switching

00:00:23,130 --> 00:00:29,220
languages and coming to go for the first

00:00:25,260 --> 00:00:32,279
time to understand what's the headline

00:00:29,220 --> 00:00:36,000
go is passed by value so whenever you

00:00:32,279 --> 00:00:38,670
call a function or you use the range

00:00:36,000 --> 00:00:42,690
parameter or whatever it's always passed

00:00:38,670 --> 00:00:45,539
by value and this is actually many

00:00:42,690 --> 00:00:47,309
languages follow that paradigm but I

00:00:45,539 --> 00:00:50,629
think not many languages have it

00:00:47,309 --> 00:00:53,989
implemented as well as go has and

00:00:50,629 --> 00:00:59,280
therefore people are actually used to

00:00:53,989 --> 00:01:01,829
faulty behavior and have difficulty

00:00:59,280 --> 00:01:06,270
adapting to it and go ooh it's not

00:01:01,829 --> 00:01:10,979
working yet sorry mm-hmm

00:01:06,270 --> 00:01:12,619
I really want to use that clicker there

00:01:10,979 --> 00:01:15,900
we go

00:01:12,619 --> 00:01:18,150
credits thanks Janos once again for

00:01:15,900 --> 00:01:20,189
sponsoring things we accelerate for for

00:01:18,150 --> 00:01:22,590
letting us be here that's really great

00:01:20,189 --> 00:01:26,159
opportunity especially with sector 5

00:01:22,590 --> 00:01:29,610
breaking off and thanks Robert for

00:01:26,159 --> 00:01:33,329
usually organizing this and I'm pretty

00:01:29,610 --> 00:01:36,060
sad that he's not here today myself I'm

00:01:33,329 --> 00:01:38,759
a software developer for actually at

00:01:36,060 --> 00:01:41,820
least 10 years and I'm doing golang

00:01:38,759 --> 00:01:44,820
nowadays and do a lot of Perl and

00:01:41,820 --> 00:01:46,890
typescript I used to be a sister that's

00:01:44,820 --> 00:01:52,380
actually the slides from my last talk at

00:01:46,890 --> 00:01:54,600
a different venue so I had to talk more

00:01:52,380 --> 00:01:58,200
about my sister admin experience but

00:01:54,600 --> 00:02:01,880
matches your requirements I've done that

00:01:58,200 --> 00:02:04,610
15 years and for I don't know

00:02:01,880 --> 00:02:08,759
installations of 20,000 users and more

00:02:04,610 --> 00:02:11,879
and I'm an expert still at causing and

00:02:08,759 --> 00:02:13,730
fixing disasters and if you are

00:02:11,879 --> 00:02:16,159
interested in what I tweet too

00:02:13,730 --> 00:02:20,540
follow my twitter handle it's quite easy

00:02:16,159 --> 00:02:24,680
to remember and my email address if you

00:02:20,540 --> 00:02:28,700
don't remember my twitter this is a

00:02:24,680 --> 00:02:31,069
beginners talk and it's about go passing

00:02:28,700 --> 00:02:33,920
everything strictly by value if you have

00:02:31,069 --> 00:02:35,599
questions I'm I can't recall but I think

00:02:33,920 --> 00:02:37,580
that there was a reason last time that

00:02:35,599 --> 00:02:39,829
you couldn't ask me questions during the

00:02:37,580 --> 00:02:42,470
talk because I think it's due to the

00:02:39,829 --> 00:02:46,750
recording so ask questions after the

00:02:42,470 --> 00:02:50,090
talk has something to do with the record

00:02:46,750 --> 00:02:53,870
what is passed by value all parameters

00:02:50,090 --> 00:02:55,879
are always passed as values that there's

00:02:53,870 --> 00:02:58,280
two paradigms the one is passed by

00:02:55,879 --> 00:03:02,450
reference and the one is passed by value

00:02:58,280 --> 00:03:05,269
and if you pass by value the or if you

00:03:02,450 --> 00:03:08,329
pass by reference it's easier to explain

00:03:05,269 --> 00:03:10,310
the the calling and the Khalif function

00:03:08,329 --> 00:03:12,709
actually just share the same variable

00:03:10,310 --> 00:03:15,349
and so whatever you do to the value in

00:03:12,709 --> 00:03:16,849
that variable happens on both sides to

00:03:15,349 --> 00:03:20,060
the calling and to call each side and

00:03:16,849 --> 00:03:23,660
people got quite used to that in some

00:03:20,060 --> 00:03:33,410
languages like javascript perl python

00:03:23,660 --> 00:03:37,069
and so it's hard to see that the go

00:03:33,410 --> 00:03:40,639
follows it actually the same that all

00:03:37,069 --> 00:03:44,120
languages say they do pass by value but

00:03:40,639 --> 00:03:47,440
not all behave that way and so I want to

00:03:44,120 --> 00:03:50,889
talk about the details in in this talk

00:03:47,440 --> 00:03:54,709
let's start with examples we have a

00:03:50,889 --> 00:03:57,470
struct example here it's quite easy we

00:03:54,709 --> 00:03:59,329
have the skill struct with a person

00:03:57,470 --> 00:04:02,629
struct and we have can you read all that

00:03:59,329 --> 00:04:06,530
is it big enough and we have a very

00:04:02,629 --> 00:04:09,220
simple main function and it's just okay

00:04:06,530 --> 00:04:12,349
what is this what is it going to print

00:04:09,220 --> 00:04:14,599
output is going to be cokie has a

00:04:12,349 --> 00:04:16,459
painting skill of two which is an

00:04:14,599 --> 00:04:20,359
excited duration because i can't paint

00:04:16,459 --> 00:04:22,039
at all and but this is just the

00:04:20,359 --> 00:04:22,370
introduction with this truck we are

00:04:22,039 --> 00:04:24,710
going

00:04:22,370 --> 00:04:27,590
to work on so we have person with name

00:04:24,710 --> 00:04:31,870
and skill we have a skill and we have

00:04:27,590 --> 00:04:34,820
some main function working with that so

00:04:31,870 --> 00:04:38,090
we now we want to increase the skill and

00:04:34,820 --> 00:04:41,990
and this is what happens quite a lot we

00:04:38,090 --> 00:04:45,830
have a function and we have receiving

00:04:41,990 --> 00:04:48,620
type that can call the increased skill

00:04:45,830 --> 00:04:50,930
and so we construct our person and say

00:04:48,620 --> 00:04:54,350
increased skill and what is it going to

00:04:50,930 --> 00:04:56,120
to print and for those who are new to

00:04:54,350 --> 00:04:59,539
the language they might be astonished

00:04:56,120 --> 00:05:05,470
that actually from print line is going

00:04:59,539 --> 00:05:08,570
to print too so what is happening we are

00:05:05,470 --> 00:05:11,840
constructing a person we are actually

00:05:08,570 --> 00:05:14,570
passing that person into the increased

00:05:11,840 --> 00:05:19,880
skill function and we are incrementing

00:05:14,570 --> 00:05:22,310
the level printing and it says ok your

00:05:19,880 --> 00:05:26,150
skill is now three which is increased

00:05:22,310 --> 00:05:28,820
and but when we call print line for the

00:05:26,150 --> 00:05:31,430
for the calling or in the calling

00:05:28,820 --> 00:05:35,740
function we reduce to 2 again and this

00:05:31,430 --> 00:05:39,380
is the basic idea of pass by value we

00:05:35,740 --> 00:05:42,050
copied all the values of person into the

00:05:39,380 --> 00:05:44,120
function did something here and the

00:05:42,050 --> 00:05:46,039
calling function doesn't know anything

00:05:44,120 --> 00:05:52,220
because they are not sharing the the

00:05:46,039 --> 00:05:56,570
values or the variables sorry ok so what

00:05:52,220 --> 00:05:59,919
can we do to fix this problem we can

00:05:56,570 --> 00:06:02,690
pass in a pointer to a person which is

00:05:59,919 --> 00:06:05,570
probably what most people do and it's

00:06:02,690 --> 00:06:09,169
not a bad way I'm going to show another

00:06:05,570 --> 00:06:11,660
way as well so we constructing a person

00:06:09,169 --> 00:06:12,800
coqui skill is painting you know this

00:06:11,660 --> 00:06:17,479
notation as well

00:06:12,800 --> 00:06:20,479
and we say increased skill once again we

00:06:17,479 --> 00:06:22,460
increment the level and now what we are

00:06:20,479 --> 00:06:25,550
passing into the function we are not

00:06:22,460 --> 00:06:28,010
passing destruct itself but a pointer to

00:06:25,550 --> 00:06:31,610
that struct so what is happening the

00:06:28,010 --> 00:06:34,610
pointer is also copied by value but the

00:06:31,610 --> 00:06:35,050
pointer is pointing to an address of the

00:06:34,610 --> 00:06:38,050
or

00:06:35,050 --> 00:06:41,440
all struct so keep that in mind we're

00:06:38,050 --> 00:06:44,319
actually dereferencing and copying the

00:06:41,440 --> 00:06:46,330
value of the pointer so now the output

00:06:44,319 --> 00:06:50,979
is as expected

00:06:46,330 --> 00:06:54,639
painting three painting three there's an

00:06:50,979 --> 00:06:57,610
alternative way to do it and you have to

00:06:54,639 --> 00:07:01,780
decide depending on the situation what

00:06:57,610 --> 00:07:05,080
you prefer is to have a receiving

00:07:01,780 --> 00:07:07,150
function P person increase kill person

00:07:05,080 --> 00:07:09,340
if you like chaining for example then

00:07:07,150 --> 00:07:14,139
this would be so this dysfunction

00:07:09,340 --> 00:07:16,740
because you're looking the astonished we

00:07:14,139 --> 00:07:19,599
have a function that's called on person

00:07:16,740 --> 00:07:24,460
called increased skill that returns a

00:07:19,599 --> 00:07:29,409
person okay so what we do is we actually

00:07:24,460 --> 00:07:32,560
copy this person into here and then we

00:07:29,409 --> 00:07:38,650
increase the level of this new variable

00:07:32,560 --> 00:07:40,300
and we return this new struct okay so

00:07:38,650 --> 00:07:44,500
this whole thing only works because I'm

00:07:40,300 --> 00:07:49,199
saying P equals so I'm reassigning P two

00:07:44,500 --> 00:07:52,750
to my old P and now print line also says

00:07:49,199 --> 00:07:57,270
painting is three yes

00:07:52,750 --> 00:07:57,270
questions after the talk but ask now

00:08:12,070 --> 00:08:23,090
skill is part of it is another scrap but

00:08:18,410 --> 00:08:27,800
it's also it's also copied okay it's a

00:08:23,090 --> 00:08:30,530
deep copy oh yeah it's a deep copy but

00:08:27,800 --> 00:08:33,890
of course I could have implemented the

00:08:30,530 --> 00:08:36,830
struct as having skill of being a

00:08:33,890 --> 00:08:39,250
pointer to something so in the type

00:08:36,830 --> 00:08:42,529
definition er you can say is it is it

00:08:39,250 --> 00:08:46,910
skill the type skill or is it a pointer

00:08:42,529 --> 00:08:51,830
type skill that would have been in the

00:08:46,910 --> 00:08:56,050
in the initial slide here then I would

00:08:51,830 --> 00:08:56,050
have said skill is asterisk skill

00:08:58,750 --> 00:09:08,720
wouldn't make a difference in wouldn't

00:09:07,010 --> 00:09:12,290
have made a difference because we oh

00:09:08,720 --> 00:09:16,720
because we're copying that person

00:09:12,290 --> 00:09:20,930
structs okay because it's it's not the

00:09:16,720 --> 00:09:23,300
when you copy you you copy I mean okay

00:09:20,930 --> 00:09:24,610
you think you said it's a point yes then

00:09:23,300 --> 00:09:28,070
I would have dereference that pointer

00:09:24,610 --> 00:09:29,960
instructor yeah it would have been this

00:09:28,070 --> 00:09:39,140
same yeah it would have dereference this

00:09:29,960 --> 00:09:40,670
skill yes correct yeah yeah but be

00:09:39,140 --> 00:09:48,040
careful with those drugs

00:09:40,670 --> 00:09:48,040
yeah yes okay good so

00:09:49,270 --> 00:09:59,840
okay now I explained that the basic

00:09:52,160 --> 00:10:02,540
thing and now let's that's the question

00:09:59,840 --> 00:10:06,250
which one is going to work okay so we're

00:10:02,540 --> 00:10:10,030
now a func main and we have a person I

00:10:06,250 --> 00:10:13,880
still have the painting skill of two and

00:10:10,030 --> 00:10:21,620
now what do we do we have a P equals P

00:10:13,880 --> 00:10:25,640
set name a Hannes and so what is going

00:10:21,620 --> 00:10:32,000
to happen when we are here in this print

00:10:25,640 --> 00:10:35,350
line thumb anyone so what do you think

00:10:32,000 --> 00:10:35,350
are we going to print

00:10:39,690 --> 00:10:45,060
you can make mistakes or just guesses or

00:10:42,800 --> 00:10:50,310
well let's do it the other way around

00:10:45,060 --> 00:10:55,860
who thinks we are going to return cookie

00:10:50,310 --> 00:10:59,640
or print out cookie nobody ok who thinks

00:10:55,860 --> 00:11:04,620
we're going to print out Hanna's are

00:10:59,640 --> 00:11:09,030
good ok said name B what's going to

00:11:04,620 --> 00:11:12,360
happen so said name B is being called

00:11:09,030 --> 00:11:13,860
after that's a weird Hannah snow and now

00:11:12,360 --> 00:11:16,740
we're sitting get hood what are we going

00:11:13,860 --> 00:11:18,300
to have printed in the next line are we

00:11:16,740 --> 00:11:23,790
going to have Hannah's or are we going

00:11:18,300 --> 00:11:26,820
to have casual sorry Hannah's correct

00:11:23,790 --> 00:11:34,080
because we are only changing the copies

00:11:26,820 --> 00:11:35,640
value ok and set names see Bella Bella

00:11:34,080 --> 00:11:41,340
ok very good

00:11:35,640 --> 00:11:44,670
and for the newcomers also quite good to

00:11:41,340 --> 00:11:47,370
know and and it's quite useful in go if

00:11:44,670 --> 00:11:48,960
you have a pointer receiver then you can

00:11:47,370 --> 00:11:51,030
still access the fields but just

00:11:48,960 --> 00:11:52,860
accessing them so you don't need you

00:11:51,030 --> 00:11:57,420
could but you don't need to dereference

00:11:52,860 --> 00:12:02,250
the receiving struck and and just set it

00:11:57,420 --> 00:12:04,230
and go does that for you so I've I've

00:12:02,250 --> 00:12:06,330
seen this being criticized I actually

00:12:04,230 --> 00:12:14,000
love that feature

00:12:06,330 --> 00:12:18,050
ok did we save this I hope we did ok so

00:12:14,000 --> 00:12:21,990
the second example I want to give is

00:12:18,050 --> 00:12:25,230
four slices and I think slices are

00:12:21,990 --> 00:12:27,870
really the implementation where where

00:12:25,230 --> 00:12:31,140
you see that the most the effect of that

00:12:27,870 --> 00:12:32,850
copy by value and I don't know if you

00:12:31,140 --> 00:12:36,330
all know the difference between array

00:12:32,850 --> 00:12:39,060
and slice and so this is how you define

00:12:36,330 --> 00:12:41,280
an array an array has a fixed size you

00:12:39,060 --> 00:12:47,610
know exactly how many elements something

00:12:41,280 --> 00:12:52,800
has and a slice has a sliced is actually

00:12:47,610 --> 00:12:58,800
a struct pointing to an underlying array

00:12:52,800 --> 00:13:03,480
and does not defined it did the length

00:12:58,800 --> 00:13:07,320
of the array by itself you initiated a

00:13:03,480 --> 00:13:10,170
slice with the make function so a nil

00:13:07,320 --> 00:13:12,930
slice is always useless and you can't

00:13:10,170 --> 00:13:15,560
work with it unless you append to it but

00:13:12,930 --> 00:13:20,610
then a paint actually creates an array

00:13:15,560 --> 00:13:22,589
and the slice has the advantage that you

00:13:20,610 --> 00:13:24,920
can append to it and you can use slicing

00:13:22,589 --> 00:13:28,470
on it and and so it's the it's a useful

00:13:24,920 --> 00:13:32,160
implementation of array array is very

00:13:28,470 --> 00:13:35,279
performing but slices are actually what

00:13:32,160 --> 00:13:42,620
you see in the wild and the important

00:13:35,279 --> 00:13:46,500
thing to note here is that slice is as

00:13:42,620 --> 00:13:48,839
let's call it a struct with a pointer to

00:13:46,500 --> 00:13:52,050
an array with the information of length

00:13:48,839 --> 00:13:54,269
and capacity so length is how many

00:13:52,050 --> 00:13:57,420
values we have actually used from that

00:13:54,269 --> 00:13:59,520
array capacities how big the the

00:13:57,420 --> 00:14:02,459
underlying array is so how many more

00:13:59,520 --> 00:14:04,410
values could we just add to the

00:14:02,459 --> 00:14:06,510
underlying array without doing

00:14:04,410 --> 00:14:10,770
additional work like increasing the

00:14:06,510 --> 00:14:14,339
array assigning another array so our

00:14:10,770 --> 00:14:16,350
example again person but a simplified

00:14:14,339 --> 00:14:20,870
person it's not so important what the

00:14:16,350 --> 00:14:25,589
person can do with just a name field and

00:14:20,870 --> 00:14:32,300
we have data is in a slice of person

00:14:25,589 --> 00:14:33,779
with Frank doors and B be at okay I

00:14:32,300 --> 00:14:38,550
think that's it

00:14:33,779 --> 00:14:42,930
switch name and when we print that we we

00:14:38,550 --> 00:14:45,300
get this result okay we already know the

00:14:42,930 --> 00:14:49,740
deal from our first example from the

00:14:45,300 --> 00:14:51,449
struct example and so let's just return

00:14:49,740 --> 00:14:55,050
a person slice we learned that before

00:14:51,449 --> 00:14:58,500
that always works right so what do we do

00:14:55,050 --> 00:15:01,500
we we have data equals modified slice

00:14:58,500 --> 00:15:05,190
modify slice returns a slice of person

00:15:01,500 --> 00:15:06,420
wonderful and we have data we range over

00:15:05,190 --> 00:15:13,950
data everybody know

00:15:06,420 --> 00:15:17,910
the range so range can go through slices

00:15:13,950 --> 00:15:22,620
and maps and stuff and returns an index

00:15:17,910 --> 00:15:27,360
and the the element the copy of the

00:15:22,620 --> 00:15:30,630
element itself but I now I told you the

00:15:27,360 --> 00:15:33,839
solution already so and we say if p name

00:15:30,630 --> 00:15:36,630
equals the search parameter then replace

00:15:33,839 --> 00:15:40,170
p name with the replacing so these are

00:15:36,630 --> 00:15:45,449
both strings so we want to find Frank

00:15:40,170 --> 00:15:47,970
and replace it by turin and our initial

00:15:45,449 --> 00:15:51,810
data array you remember is Frank Torres

00:15:47,970 --> 00:15:57,899
beard and the output is Frank Torres

00:15:51,810 --> 00:16:01,829
beard what happened what happened here

00:15:57,899 --> 00:16:05,730
is we say arrange data and so we go

00:16:01,829 --> 00:16:09,779
through each person range copies the

00:16:05,730 --> 00:16:13,140
value of the element and if we change

00:16:09,779 --> 00:16:15,870
name in here we're actually changing the

00:16:13,140 --> 00:16:18,209
name of a copied element and we're not

00:16:15,870 --> 00:16:22,829
changing the name of the underlying

00:16:18,209 --> 00:16:26,640
array and this is actually code that

00:16:22,829 --> 00:16:29,279
I've found two weeks ago in our code

00:16:26,640 --> 00:16:30,690
base which is advanced so it happens it

00:16:29,279 --> 00:16:34,380
happens especially when you switch

00:16:30,690 --> 00:16:37,079
languages this does nothing ok I mean it

00:16:34,380 --> 00:16:41,579
burns CPU cycles it does it does

00:16:37,079 --> 00:16:45,240
something so okay it is copied by by

00:16:41,579 --> 00:16:49,319
value especially careful be careful with

00:16:45,240 --> 00:16:51,990
range and so let's fix that okay we can

00:16:49,319 --> 00:16:54,810
deconstruct of actually returning a

00:16:51,990 --> 00:16:59,760
slice wasn't bad what we can do is for

00:16:54,810 --> 00:17:02,399
IP so I is an index peas the copied I'm

00:16:59,760 --> 00:17:05,189
just I wouldn't usually write it this

00:17:02,399 --> 00:17:09,329
way probably but I did now for for

00:17:05,189 --> 00:17:12,390
making it more clear we range over data

00:17:09,329 --> 00:17:18,059
and say if p name equals the search

00:17:12,390 --> 00:17:19,980
parameter then change data I theta I so

00:17:18,059 --> 00:17:21,839
the index of data

00:17:19,980 --> 00:17:26,429
named to the replaced ring so why is

00:17:21,839 --> 00:17:28,559
this working because we copied data in

00:17:26,429 --> 00:17:31,530
here and data is a slice it's not the

00:17:28,559 --> 00:17:33,780
array so we didn't spread the array but

00:17:31,530 --> 00:17:38,460
we are actually copying the slice which

00:17:33,780 --> 00:17:41,340
is a descriptor to what we said it's

00:17:38,460 --> 00:17:44,250
pointing to an array it has the value of

00:17:41,340 --> 00:17:46,260
length and capacity so this is what we

00:17:44,250 --> 00:17:48,540
copied we didn't copy the underlying

00:17:46,260 --> 00:17:52,830
array we just copied the descripting

00:17:48,540 --> 00:17:55,110
thing and we returned data and modify

00:17:52,830 --> 00:17:59,960
slice is actually going to be as

00:17:55,110 --> 00:18:05,730
expected torrent or is being so clear

00:17:59,960 --> 00:18:09,030
okay what would happen if we do not

00:18:05,730 --> 00:18:14,040
assign it to our data so we have the

00:18:09,030 --> 00:18:17,640
same function modify slice and from main

00:18:14,040 --> 00:18:21,270
we called the same function and but we

00:18:17,640 --> 00:18:27,540
do not assign it to data again what is

00:18:21,270 --> 00:18:39,110
going to be printed yeah of course it's

00:18:27,540 --> 00:18:39,110
a question you have to yes yeah

00:18:39,640 --> 00:18:49,130
yeah you are correct

00:18:44,870 --> 00:18:52,280
okay but this is this is unexpected

00:18:49,130 --> 00:18:54,950
when you when you don't think about what

00:18:52,280 --> 00:18:58,990
you are actually passing it is correct

00:18:54,950 --> 00:19:02,360
what you're saying because we are still

00:18:58,990 --> 00:19:03,980
working on the same array right it was

00:19:02,360 --> 00:19:07,730
the pointer and we changed the pointers

00:19:03,980 --> 00:19:10,220
value of element whatever the one that

00:19:07,730 --> 00:19:14,600
matched it Matt okay

00:19:10,220 --> 00:19:17,390
but this is we're getting to the next

00:19:14,600 --> 00:19:18,230
example why this is important to notice

00:19:17,390 --> 00:19:22,850
okay

00:19:18,230 --> 00:19:25,640
so wise go behaving that way it's a

00:19:22,850 --> 00:19:29,420
question like in JavaScript it's so easy

00:19:25,640 --> 00:19:33,110
I just pass an array and I say airy push

00:19:29,420 --> 00:19:35,750
and it it pushes to that array and if I

00:19:33,110 --> 00:19:38,180
return I get the same array and if the

00:19:35,750 --> 00:19:41,780
calling function has this collie and

00:19:38,180 --> 00:19:45,890
kala have the same thing okay we said it

00:19:41,780 --> 00:19:48,230
was passed by value and slice is not the

00:19:45,890 --> 00:19:51,200
array slice is pointing to an array and

00:19:48,230 --> 00:19:54,220
this is I think this is the main thing I

00:19:51,200 --> 00:19:56,900
want to tell you actually in this talk

00:19:54,220 --> 00:20:02,270
so it's a descriptor for a segment of an

00:19:56,900 --> 00:20:05,770
array a slice okay and another important

00:20:02,270 --> 00:20:09,890
thing to mention is one array can have

00:20:05,770 --> 00:20:12,170
many slices pointing to it and they can

00:20:09,890 --> 00:20:14,390
actually be mixed so you can have an

00:20:12,170 --> 00:20:17,450
array of ten elements and you can have a

00:20:14,390 --> 00:20:20,300
slice taking the first three elements

00:20:17,450 --> 00:20:23,180
and another slice taking all ten

00:20:20,300 --> 00:20:25,100
elements and you can have another slice

00:20:23,180 --> 00:20:27,800
just taking the last three elements so

00:20:25,100 --> 00:20:31,300
you have to be very cautious what you do

00:20:27,800 --> 00:20:35,390
with your underlying data structures and

00:20:31,300 --> 00:20:38,840
all descriptors are pointing to the same

00:20:35,390 --> 00:20:43,100
array so even if you do slicing of this

00:20:38,840 --> 00:20:45,800
slice you have to be careful are you

00:20:43,100 --> 00:20:48,320
doing lazy slicing or do you are you

00:20:45,800 --> 00:20:50,980
actually really copying the values of

00:20:48,320 --> 00:20:53,140
the underlying array into a new array

00:20:50,980 --> 00:20:59,800
think I'll show you another example of

00:20:53,140 --> 00:21:03,190
that later and yeah a slice is only the

00:20:59,800 --> 00:21:05,700
Pointer capacity and length and the

00:21:03,190 --> 00:21:06,880
actually data is being held in the array

00:21:05,700 --> 00:21:13,810
okay

00:21:06,880 --> 00:21:17,380
so sounds easy but this is the again the

00:21:13,810 --> 00:21:19,540
questionnaire part and so we have

00:21:17,380 --> 00:21:22,120
another function called a pen to slice

00:21:19,540 --> 00:21:24,460
and okay we've found that pattern

00:21:22,120 --> 00:21:26,290
somehow useful we're returning slice

00:21:24,460 --> 00:21:30,600
that that somehow worked for us in the

00:21:26,290 --> 00:21:34,300
past and we're doing two things so first

00:21:30,600 --> 00:21:39,550
we're passing Kim Kim named and we're

00:21:34,300 --> 00:21:42,580
actually appending him to data and what

00:21:39,550 --> 00:21:44,650
we're also doing is I mean this is a bit

00:21:42,580 --> 00:21:49,080
dangerous because we can't know that the

00:21:44,650 --> 00:21:51,700
slice has more than more than one

00:21:49,080 --> 00:21:54,000
elements but for the sake of this

00:21:51,700 --> 00:21:57,340
example I think it's not important and

00:21:54,000 --> 00:21:59,650
we're actually assigning new name to the

00:21:57,340 --> 00:22:04,720
first to the second element in the slice

00:21:59,650 --> 00:22:11,850
so mod data append to slice what is data

00:22:04,720 --> 00:22:11,850
what is mod data sorry

00:22:12,919 --> 00:22:24,179
data is going to so our initial Frank

00:22:17,009 --> 00:22:31,459
what was it Frank Frank it was Frank

00:22:24,179 --> 00:22:31,459
Torres and Piatt what's gonna happen so

00:22:37,789 --> 00:22:45,449
no oh yeah you're correct

00:22:41,789 --> 00:22:48,059
yeah compiler error okay sorry for that

00:22:45,449 --> 00:22:51,209
because I copied from code to to this

00:22:48,059 --> 00:22:54,299
slide no we want to but it's a very good

00:22:51,209 --> 00:23:01,159
point we want we would have written a

00:22:54,299 --> 00:23:05,249
person person name okay sorry for that

00:23:01,159 --> 00:23:08,639
but if it compiled so what we'd get is

00:23:05,249 --> 00:23:12,839
actually Frank new name beard it's the

00:23:08,639 --> 00:23:18,779
same thing with we are changing the

00:23:12,839 --> 00:23:21,419
underlying array the initial the the

00:23:18,779 --> 00:23:23,789
initial slice is still the same and the

00:23:21,419 --> 00:23:29,009
initial slice has the information length

00:23:23,789 --> 00:23:32,219
is three so it doesn't care that the

00:23:29,009 --> 00:23:35,279
array actually holds more values but

00:23:32,219 --> 00:23:37,919
this slice still only holds three values

00:23:35,279 --> 00:23:43,739
and the mod data that is being returned

00:23:37,919 --> 00:23:46,789
if it had compiled is actually longer

00:23:43,739 --> 00:23:50,190
than the origin so I think these are

00:23:46,789 --> 00:23:56,039
caveats where you really have to be very

00:23:50,190 --> 00:23:59,729
cautious that stick to how you modify

00:23:56,039 --> 00:24:01,949
your data and and don't don't trick

00:23:59,729 --> 00:24:05,789
around with what you're doing either

00:24:01,949 --> 00:24:07,529
copy or modify in place but don't mix

00:24:05,789 --> 00:24:12,089
match because you're going to have

00:24:07,529 --> 00:24:17,869
results like that totally unexpected so

00:24:12,089 --> 00:24:22,049
rules the the behavior of goal is

00:24:17,869 --> 00:24:24,749
extremely consistent there's whenever

00:24:22,049 --> 00:24:25,680
you wrap your brain around it and think

00:24:24,749 --> 00:24:27,300
about it it's a

00:24:25,680 --> 00:24:32,430
she's super consistent there's there's

00:24:27,300 --> 00:24:33,870
nothing that's strange about it I really

00:24:32,430 --> 00:24:36,900
I talked to

00:24:33,870 --> 00:24:41,010
super advanced Perl developer the other

00:24:36,900 --> 00:24:43,890
day about this topic and we actually

00:24:41,010 --> 00:24:47,850
came to the conclusion that in in Perl

00:24:43,890 --> 00:24:51,480
its although Perl is a very well-defined

00:24:47,850 --> 00:24:53,490
language and consistent we actually came

00:24:51,480 --> 00:24:59,910
to the conclusion that this is more

00:24:53,490 --> 00:25:03,630
consistent and more you can more count

00:24:59,910 --> 00:25:05,340
on what's actually happening and you

00:25:03,630 --> 00:25:09,360
really need to know the basic datatypes

00:25:05,340 --> 00:25:13,860
so everybody says that read up the

00:25:09,360 --> 00:25:16,260
language specification and it's hard to

00:25:13,860 --> 00:25:20,490
read document to actually read it

00:25:16,260 --> 00:25:21,810
correct and reread it in and really to

00:25:20,490 --> 00:25:24,900
parse it correctly but it is

00:25:21,810 --> 00:25:27,810
well-written and in corner cases you can

00:25:24,900 --> 00:25:30,980
always reference it and use it to to

00:25:27,810 --> 00:25:30,980
actually know what's happening and

00:25:31,370 --> 00:25:36,360
always whenever you call a function keep

00:25:34,680 --> 00:25:38,940
in mind what are you actually passing

00:25:36,360 --> 00:25:41,610
are you passing a value or are you

00:25:38,940 --> 00:25:44,010
passing or you're always passing a value

00:25:41,610 --> 00:25:47,810
but is the value they pointer to

00:25:44,010 --> 00:25:50,760
something or is it the data itself and I

00:25:47,810 --> 00:25:55,080
mean this is true for all the languages

00:25:50,760 --> 00:25:58,740
and is a very useful paradigm nowadays I

00:25:55,080 --> 00:26:00,870
mean in in JavaScript we're starting to

00:25:58,740 --> 00:26:02,580
use Rhonda and and libraries like that

00:26:00,870 --> 00:26:05,010
where you actually you don't ever modify

00:26:02,580 --> 00:26:07,560
data anymore you just generate new data

00:26:05,010 --> 00:26:10,680
and pipe that out to the calling

00:26:07,560 --> 00:26:13,710
function and I think this holds true for

00:26:10,680 --> 00:26:15,780
go as well if you want to do something

00:26:13,710 --> 00:26:18,600
and it's not performance isn't your

00:26:15,780 --> 00:26:20,520
biggest issue and believe me performance

00:26:18,600 --> 00:26:22,580
isn't your biggest issue because your

00:26:20,520 --> 00:26:27,140
biggest issue is readability and

00:26:22,580 --> 00:26:32,250
maintainability and bug-free actually

00:26:27,140 --> 00:26:33,300
then don't share too much data ok that's

00:26:32,250 --> 00:26:34,600
it thank you

00:26:33,300 --> 00:26:38,220
easy talk

00:26:34,600 --> 00:26:38,220

YouTube URL: https://www.youtube.com/watch?v=WLMtDCqUCV4


