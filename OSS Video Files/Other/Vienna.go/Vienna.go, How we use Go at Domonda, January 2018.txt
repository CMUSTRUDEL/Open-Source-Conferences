Title: Vienna.go, How we use Go at Domonda, January 2018
Publication date: 2018-01-30
Playlist: Vienna.go
Description: 
	In this video: Erik will show us how Domonda use Go, from files and CLIs as building blocks, to wrapping functions to be available at the command line and as REST API.

More about Erik Unger: https://twitter.com/ungerik

More about Vienna.go: https://www.meetup.com/vienna-go-Vienna-Go-User-Group/
Captions: 
	00:00:00,030 --> 00:00:05,759
okay so what I'm going to show you now

00:00:03,179 --> 00:00:10,349
is the tech stack and especially the

00:00:05,759 --> 00:00:12,929
goal code we are using at Amanda in

00:00:10,349 --> 00:00:14,929
general there's no rocket science

00:00:12,929 --> 00:00:17,880
involved here it's more like

00:00:14,929 --> 00:00:21,720
architecture and the way we go about

00:00:17,880 --> 00:00:24,080
doing solving the usual things you have

00:00:21,720 --> 00:00:24,080
to do

00:00:24,420 --> 00:00:30,750
yeah we're using go for server and

00:00:26,640 --> 00:00:36,660
command-line tools we are using Postgres

00:00:30,750 --> 00:00:40,620
and are very happy we've PostgreSQL who

00:00:36,660 --> 00:00:44,250
knows that yeah I guess so nobody so

00:00:40,620 --> 00:00:49,649
basically what that is it's a graph QL

00:00:44,250 --> 00:00:53,930
API layer for Posterous so basically you

00:00:49,649 --> 00:00:59,879
can create a graph QL API from a schema

00:00:53,930 --> 00:01:02,489
where you can query your schema and you

00:00:59,879 --> 00:01:05,790
can also do mutations those mutations

00:01:02,489 --> 00:01:09,740
are SQL functions that are called on you

00:01:05,790 --> 00:01:09,740
can implement them however you want and

00:01:09,799 --> 00:01:16,799
yeah basically it really gives you an

00:01:13,080 --> 00:01:20,100
API for your application out of the box

00:01:16,799 --> 00:01:24,330
if you have matching schema for that and

00:01:20,100 --> 00:01:26,850
by using different schemas and fuse you

00:01:24,330 --> 00:01:29,670
can also do things like different API so

00:01:26,850 --> 00:01:31,680
if you have an external API for your

00:01:29,670 --> 00:01:34,860
customers that's somehow different you

00:01:31,680 --> 00:01:38,070
create another schema with fuse on your

00:01:34,860 --> 00:01:43,049
internal structures and basically you

00:01:38,070 --> 00:01:45,750
get an API free out-of-the-box so we've

00:01:43,049 --> 00:01:49,350
been really happy with that that's

00:01:45,750 --> 00:01:55,259
implemented in node it respects and uses

00:01:49,350 --> 00:02:00,149
all kinds of Postgres wizardry to make

00:01:55,259 --> 00:02:02,729
that happen but it really worked out of

00:02:00,149 --> 00:02:05,040
the box and really good we have a

00:02:02,729 --> 00:02:08,459
proprietary document database with

00:02:05,040 --> 00:02:11,520
Russian ink so as I said we are into

00:02:08,459 --> 00:02:14,150
accounting and the most important thing

00:02:11,520 --> 00:02:17,730
here is to never lose anything

00:02:14,150 --> 00:02:20,099
and always be able to prove that this

00:02:17,730 --> 00:02:24,360
document has been delivered that way has

00:02:20,099 --> 00:02:26,849
been changed and all this stuff and for

00:02:24,360 --> 00:02:29,959
that we created our own document

00:02:26,849 --> 00:02:33,900
database that's completely file paste

00:02:29,959 --> 00:02:36,569
and has things like versioning and

00:02:33,900 --> 00:02:39,690
checking out checking in and so on I'll

00:02:36,569 --> 00:02:43,980
get into that later for the front-end we

00:02:39,690 --> 00:02:49,470
are using the usual react Redux stack

00:02:43,980 --> 00:02:54,780
and get up like many for source code and

00:02:49,470 --> 00:02:57,090
also for deployment so how we go at

00:02:54,780 --> 00:03:01,579
demanda how do we structure those things

00:02:57,090 --> 00:03:06,660
so we have a single repo in github and

00:03:01,579 --> 00:03:09,379
we have a monolith first and serverless

00:03:06,660 --> 00:03:11,849
later meaning we always start with the

00:03:09,379 --> 00:03:13,709
monolith everything is much easier that

00:03:11,849 --> 00:03:17,400
way and when we see we can split

00:03:13,709 --> 00:03:20,130
something off to something on AWS lambda

00:03:17,400 --> 00:03:22,919
or something like that we do that we

00:03:20,130 --> 00:03:25,709
don't go for micro services first and

00:03:22,919 --> 00:03:27,870
build a lot of micro services only when

00:03:25,709 --> 00:03:30,870
we see there's a benefit from going away

00:03:27,870 --> 00:03:33,540
from the monolith may also change when

00:03:30,870 --> 00:03:36,150
we have a bigger team but for a really

00:03:33,540 --> 00:03:41,450
small team a monolith and the same

00:03:36,150 --> 00:03:45,209
single repo brings the most productivity

00:03:41,450 --> 00:03:48,799
we are very strongly following the UNIX

00:03:45,209 --> 00:03:53,489
philosophies so everything is a file and

00:03:48,799 --> 00:03:56,370
command-line tools that's basically all

00:03:53,489 --> 00:03:59,430
we are using or basically everything you

00:03:56,370 --> 00:04:02,400
can do at the mount at the mando with

00:03:59,430 --> 00:04:06,510
our data you can basically do with files

00:04:02,400 --> 00:04:11,400
and command-line tools and Postgres is

00:04:06,510 --> 00:04:15,629
basically for us just an indexed cache

00:04:11,400 --> 00:04:18,690
for clearing but everything is also

00:04:15,629 --> 00:04:23,130
available as file and we can recreate

00:04:18,690 --> 00:04:25,950
our complete database from files also

00:04:23,130 --> 00:04:27,990
very important for backup reasons never

00:04:25,950 --> 00:04:32,370
lose any financial

00:04:27,990 --> 00:04:37,139
documents so about our own document

00:04:32,370 --> 00:04:41,669
database it's completely file paste it

00:04:37,139 --> 00:04:44,849
can run on s3 and we don't rely on any

00:04:41,669 --> 00:04:46,910
features like five dates it's just the

00:04:44,849 --> 00:04:50,669
content and the naming of the whole

00:04:46,910 --> 00:04:53,610
structure and we have versioning we have

00:04:50,669 --> 00:04:56,550
checking out working on some files

00:04:53,610 --> 00:05:01,199
checking them in again which is locking

00:04:56,550 --> 00:05:03,570
so one client is doing something with

00:05:01,199 --> 00:05:05,880
the document of course nobody else

00:05:03,570 --> 00:05:08,039
should be doing something else to the

00:05:05,880 --> 00:05:10,020
document at the same time

00:05:08,039 --> 00:05:12,000
that's basically a lot of functionality

00:05:10,020 --> 00:05:15,240
that you get from version control

00:05:12,000 --> 00:05:18,750
systems so while we're not just using

00:05:15,240 --> 00:05:22,349
git for something like that well we have

00:05:18,750 --> 00:05:27,659
lots of data and performance is always

00:05:22,349 --> 00:05:32,120
an issue here and if we use some version

00:05:27,659 --> 00:05:37,740
control system we can't use storage like

00:05:32,120 --> 00:05:40,130
AWS s3 and quisha which really helps

00:05:37,740 --> 00:05:44,009
together especially with things like

00:05:40,130 --> 00:05:45,919
lambda and we have our own special

00:05:44,009 --> 00:05:49,860
requirements so by developing our own

00:05:45,919 --> 00:05:53,909
thing we have complete control over

00:05:49,860 --> 00:05:57,060
what's going on and that has paid off so

00:05:53,909 --> 00:05:59,430
far there have been lots of things going

00:05:57,060 --> 00:06:01,199
wrong in development but we never lost

00:05:59,430 --> 00:06:04,530
any data and we have the complete

00:06:01,199 --> 00:06:10,169
history of everything and yeah that has

00:06:04,530 --> 00:06:13,520
paid off so far so yeah the nitty-gritty

00:06:10,169 --> 00:06:16,979
stuff you always have to do logging I

00:06:13,520 --> 00:06:20,909
mean it's it's here more a philosophy

00:06:16,979 --> 00:06:23,639
thing basically you can say every

00:06:20,909 --> 00:06:26,430
developer develops his own locking

00:06:23,639 --> 00:06:29,699
system once in his life or twice or

00:06:26,430 --> 00:06:31,770
three times why not use like whatever

00:06:29,699 --> 00:06:35,699
logging library is a favorite library

00:06:31,770 --> 00:06:38,279
because it can do everything well

00:06:35,699 --> 00:06:41,289
maybe that there are some other logging

00:06:38,279 --> 00:06:43,569
systems in the background but what

00:06:41,289 --> 00:06:45,999
dealing here is more like the philosophy

00:06:43,569 --> 00:06:50,919
what we want to lock you know there are

00:06:45,999 --> 00:06:53,919
different things like 100,000 locked

00:06:50,919 --> 00:06:56,020
levers and different kinds of logging

00:06:53,919 --> 00:06:58,270
messages and warnings and errors and all

00:06:56,020 --> 00:07:00,990
this stuff and how you want to handle

00:06:58,270 --> 00:07:03,669
that is basically a philosophy and

00:07:00,990 --> 00:07:07,990
something you have to decide for

00:07:03,669 --> 00:07:10,930
yourself and we are going with a very

00:07:07,990 --> 00:07:14,409
simple approach like everything else in

00:07:10,930 --> 00:07:16,659
go make it as simple as possible not

00:07:14,409 --> 00:07:18,939
simpler so basically we have a locker

00:07:16,659 --> 00:07:23,050
which has which is an interface with

00:07:18,939 --> 00:07:27,249
three methods we have print F which

00:07:23,050 --> 00:07:33,520
prints lock messages we have T Park F

00:07:27,249 --> 00:07:35,080
which outputs debug output and that's

00:07:33,520 --> 00:07:36,939
something you're just using for

00:07:35,080 --> 00:07:42,189
development and then we have unresolved

00:07:36,939 --> 00:07:45,309
error and it's especially on purpose

00:07:42,189 --> 00:07:49,899
this long name this cumbersome name

00:07:45,309 --> 00:07:53,800
because in go you don't throw panics you

00:07:49,899 --> 00:07:56,349
don't have exceptions you want to return

00:07:53,800 --> 00:07:58,779
all errors and all those errors bubble

00:07:56,349 --> 00:08:02,459
up and even at the highest level you

00:07:58,779 --> 00:08:05,139
have some way to handle those errors and

00:08:02,459 --> 00:08:10,059
the only case where you have an error

00:08:05,139 --> 00:08:11,860
that isn't handled because for instance

00:08:10,059 --> 00:08:13,839
you had another error first and you

00:08:11,860 --> 00:08:16,089
can't continue and then an error is

00:08:13,839 --> 00:08:17,769
created because of the error before and

00:08:16,089 --> 00:08:19,930
you have no way out

00:08:17,769 --> 00:08:23,369
that is when you would use this

00:08:19,930 --> 00:08:28,029
unresolved error everything else is just

00:08:23,369 --> 00:08:29,800
printf lock message and you decide

00:08:28,029 --> 00:08:32,260
yourself what's in the lock message in

00:08:29,800 --> 00:08:34,269
the format of the lock message decides

00:08:32,260 --> 00:08:34,930
what you're logging and if that's an

00:08:34,269 --> 00:08:38,529
error or not

00:08:34,930 --> 00:08:41,409
so usually you also lock errors with the

00:08:38,529 --> 00:08:44,259
normal printf and only if you don't find

00:08:41,409 --> 00:08:49,769
any way out of your state basically you

00:08:44,259 --> 00:08:54,600
use the unresolved error and that's

00:08:49,769 --> 00:08:58,740
basically how this is set up so

00:08:54,600 --> 00:09:00,690
what we have is in our repository we

00:08:58,740 --> 00:09:03,839
have a go directory where all the

00:09:00,690 --> 00:09:07,050
packages we are using from the circle

00:09:03,839 --> 00:09:10,079
server and the go command-line tool are

00:09:07,050 --> 00:09:13,259
in there and we have one Singh locker

00:09:10,079 --> 00:09:16,800
package and this locker logger package

00:09:13,259 --> 00:09:19,410
is used by all other packages for

00:09:16,800 --> 00:09:23,250
logging and the whole configuration is

00:09:19,410 --> 00:09:27,870
done here so basically what you don't

00:09:23,250 --> 00:09:31,470
have a mouse what you can see here is

00:09:27,870 --> 00:09:34,410
basically we lock to the command line

00:09:31,470 --> 00:09:41,220
with some colors and we can set a log

00:09:34,410 --> 00:09:45,569
file if we want to and every package

00:09:41,220 --> 00:09:49,550
then has its own lock variable so for

00:09:45,569 --> 00:09:52,649
logging we are not using this locker

00:09:49,550 --> 00:09:57,269
package directly we create a lock

00:09:52,649 --> 00:10:02,509
variable which is this locking VARs here

00:09:57,269 --> 00:10:05,069
which just references other variables

00:10:02,509 --> 00:10:07,680
that's used for locking the reason for

00:10:05,069 --> 00:10:10,769
that is if you have all those

00:10:07,680 --> 00:10:14,550
dependencies everything depends on this

00:10:10,769 --> 00:10:17,459
locker packages package and so on you

00:10:14,550 --> 00:10:20,750
have the problems of initialization and

00:10:17,459 --> 00:10:23,810
in which all is our things initially

00:10:20,750 --> 00:10:26,399
initialized and so on and basically by

00:10:23,810 --> 00:10:29,819
referencing just other variables with

00:10:26,399 --> 00:10:30,779
the address operator like you can see

00:10:29,819 --> 00:10:34,050
here the lockvar

00:10:30,779 --> 00:10:36,600
is the real logger we are using from the

00:10:34,050 --> 00:10:40,139
log a package and then we also are

00:10:36,600 --> 00:10:44,040
referencing the P Park variable which is

00:10:40,139 --> 00:10:47,810
defined in the line above that means

00:10:44,040 --> 00:10:51,920
that those can be changed at any time

00:10:47,810 --> 00:10:54,120
and we don't depend on the order of

00:10:51,920 --> 00:10:57,829
initialization and if you want to debug

00:10:54,120 --> 00:11:01,529
or get tipper debug messages from

00:10:57,829 --> 00:11:04,430
package you change the debug variable in

00:11:01,529 --> 00:11:04,430
that package

00:11:06,810 --> 00:11:14,370
error handling in general so we said we

00:11:09,300 --> 00:11:19,430
always want to return errors never panic

00:11:14,370 --> 00:11:23,940
and one pattern we are using is that we

00:11:19,430 --> 00:11:26,610
are wrapping arrows to get a better call

00:11:23,940 --> 00:11:29,990
stack error information so for that

00:11:26,610 --> 00:11:34,050
we're using this github

00:11:29,990 --> 00:11:34,800
pkg errors package which we can highly

00:11:34,050 --> 00:11:37,700
recommend

00:11:34,800 --> 00:11:40,650
it's very simple all you do here is just

00:11:37,700 --> 00:11:43,560
wrapping some errors with a call stack

00:11:40,650 --> 00:11:47,220
and some metadata and that helps you in

00:11:43,560 --> 00:11:49,560
debugging if you print out that message

00:11:47,220 --> 00:11:52,350
and what you can see here is the differ

00:11:49,560 --> 00:11:57,840
call if you're not that family familiar

00:11:52,350 --> 00:12:01,400
with go differ makes this call wrap

00:11:57,840 --> 00:12:05,280
error resort run after the whole

00:12:01,400 --> 00:12:10,380
function has been executed and it will

00:12:05,280 --> 00:12:16,170
be called in any case even if a panic

00:12:10,380 --> 00:12:20,070
occurs and if you're using resort

00:12:16,170 --> 00:12:24,660
variables like error here this error

00:12:20,070 --> 00:12:28,050
will always hold the result of that

00:12:24,660 --> 00:12:31,880
function so even if you define another

00:12:28,050 --> 00:12:34,170
error and basically overwrite original

00:12:31,880 --> 00:12:38,760
whatever will be returned from that

00:12:34,170 --> 00:12:41,730
result will be available in this differ

00:12:38,760 --> 00:12:43,830
rep result error function and what we're

00:12:41,730 --> 00:12:47,940
using here is it can be taking the

00:12:43,830 --> 00:12:51,750
address of that result variable that way

00:12:47,940 --> 00:12:54,900
we can look at the variable and that's

00:12:51,750 --> 00:12:59,730
basically the function that we deferring

00:12:54,900 --> 00:13:02,580
here so if the pointer points to a nil

00:12:59,730 --> 00:13:05,640
error we don't have anything to do but

00:13:02,580 --> 00:13:08,640
if there is some error then we create a

00:13:05,640 --> 00:13:12,780
nice error message we lock the whole

00:13:08,640 --> 00:13:14,680
thing and we also wrap in the last line

00:13:12,780 --> 00:13:18,580
the original error we

00:13:14,680 --> 00:13:21,430
all these metadata that we've created in

00:13:18,580 --> 00:13:26,620
that way basically if you crash and get

00:13:21,430 --> 00:13:32,529
a call stack you see what functions have

00:13:26,620 --> 00:13:35,880
been called with what arguments so

00:13:32,529 --> 00:13:38,560
another convention for defining errors

00:13:35,880 --> 00:13:41,830
usually you have something that

00:13:38,560 --> 00:13:43,930
describes the this error so this error

00:13:41,830 --> 00:13:48,459
here document not found we're using uu

00:13:43,930 --> 00:13:51,330
IDs for document IDs and basically we

00:13:48,459 --> 00:13:56,100
can define this error just as an

00:13:51,330 --> 00:13:59,350
basically extension of that type by

00:13:56,100 --> 00:14:02,709
adding an error method that creates the

00:13:59,350 --> 00:14:05,560
error message and one convention that we

00:14:02,709 --> 00:14:08,830
are using is that if we create such an

00:14:05,560 --> 00:14:12,370
error we also create an is error named

00:14:08,830 --> 00:14:14,350
function that checks if an error is of

00:14:12,370 --> 00:14:17,589
that type so usually if you return

00:14:14,350 --> 00:14:19,480
errors in go if you want to do some

00:14:17,589 --> 00:14:22,450
error handling you have to check what

00:14:19,480 --> 00:14:25,870
type of error are you using and because

00:14:22,450 --> 00:14:28,600
we're using this errors package that

00:14:25,870 --> 00:14:32,380
does wrapping of errors you don't get

00:14:28,600 --> 00:14:35,800
the original error and in that case if

00:14:32,380 --> 00:14:39,250
you just check for the type you wouldn't

00:14:35,800 --> 00:14:43,060
get the right type and basically what

00:14:39,250 --> 00:14:47,279
this errors package has here to resolve

00:14:43,060 --> 00:14:49,839
that is the errors caused function but

00:14:47,279 --> 00:14:53,140
something that happens all the time is

00:14:49,839 --> 00:14:55,360
that we forget to use this error cause

00:14:53,140 --> 00:14:57,520
when we check for the error type so the

00:14:55,360 --> 00:15:02,020
convention is to always use this is

00:14:57,520 --> 00:15:09,910
error whatever type function because it

00:15:02,020 --> 00:15:12,910
always has that in it and yeah that was

00:15:09,910 --> 00:15:15,730
more than mundane stuff now for the

00:15:12,910 --> 00:15:18,339
interesting things so as I said we have

00:15:15,730 --> 00:15:23,079
this UNIX philosophy where everything is

00:15:18,339 --> 00:15:25,440
files and commands and basically in an

00:15:23,079 --> 00:15:28,240
application a command is a function and

00:15:25,440 --> 00:15:32,800
what we are doing is we are

00:15:28,240 --> 00:15:36,730
being functions as commands so to do

00:15:32,800 --> 00:15:38,830
that what do you need for command to run

00:15:36,730 --> 00:15:41,459
then you need the arguments and you'd

00:15:38,830 --> 00:15:44,410
need to do something with the research

00:15:41,459 --> 00:15:48,220
here's an example for this patch

00:15:44,410 --> 00:15:51,880
overview text function which returns

00:15:48,220 --> 00:15:56,170
just some overview plain text that we

00:15:51,880 --> 00:16:01,230
use in different places and we are

00:15:56,170 --> 00:16:05,260
wrapping that with C lightest patcher

00:16:01,230 --> 00:16:08,529
where this function can be called as a

00:16:05,260 --> 00:16:11,440
command from our command line tool but

00:16:08,529 --> 00:16:14,860
the same function can also be wrapped or

00:16:11,440 --> 00:16:21,540
the same command can be wrapped as a

00:16:14,860 --> 00:16:27,970
server out for a guerilla max the server

00:16:21,540 --> 00:16:31,600
framework and you can see that we are

00:16:27,970 --> 00:16:34,089
just adding these basically few lines of

00:16:31,600 --> 00:16:36,160
code and we have the same function

00:16:34,089 --> 00:16:42,300
available from the command line and also

00:16:36,160 --> 00:16:46,329
as plain text responds with a server rod

00:16:42,300 --> 00:16:49,899
so that's basically how the command line

00:16:46,329 --> 00:16:53,440
tool looks like internally so we have

00:16:49,899 --> 00:16:56,440
this string arc sticks dispatcher which

00:16:53,440 --> 00:16:58,930
takes string arguments when you call the

00:16:56,440 --> 00:17:02,620
command line tool and converts them to

00:16:58,930 --> 00:17:06,640
whatever types the arguments of those

00:17:02,620 --> 00:17:08,709
commands take so it's a standard

00:17:06,640 --> 00:17:11,010
built-in conversion for the usual stuff

00:17:08,709 --> 00:17:13,660
you have integers you have you you IDs

00:17:11,010 --> 00:17:17,650
if you have structs then it's

00:17:13,660 --> 00:17:21,010
automatically using jason to convert to

00:17:17,650 --> 00:17:23,890
and from that from a string and

00:17:21,010 --> 00:17:28,449
basically you can wrap any go function

00:17:23,890 --> 00:17:31,420
as a command and then here this struct

00:17:28,449 --> 00:17:34,870
flag load file if it exists and passed

00:17:31,420 --> 00:17:38,150
command line it's fancy for basically

00:17:34,870 --> 00:17:41,880
look if there's a config file use that

00:17:38,150 --> 00:17:46,230
create initialize our configuration with

00:17:41,880 --> 00:17:49,580
that and you can also change this

00:17:46,230 --> 00:17:52,260
configuration with command line flags

00:17:49,580 --> 00:17:56,220
that overwrite whatever you have in your

00:17:52,260 --> 00:17:58,740
configuration file and what's returned

00:17:56,220 --> 00:18:01,080
from that function is the arguments that

00:17:58,740 --> 00:18:05,160
don't have any flags in them and they

00:18:01,080 --> 00:18:08,280
are then used to dispatch a command

00:18:05,160 --> 00:18:14,159
which you see this dispatcher dispatch

00:18:08,280 --> 00:18:17,610
combined and that basically runs the

00:18:14,159 --> 00:18:20,280
command and if there was no era we entry

00:18:17,610 --> 00:18:23,220
have still some cleanup work like we

00:18:20,280 --> 00:18:25,580
have here the thumbnails work until work

00:18:23,220 --> 00:18:32,010
have finished

00:18:25,580 --> 00:18:35,280
that's code like we use it here's

00:18:32,010 --> 00:18:38,159
something more complex here we have a

00:18:35,280 --> 00:18:41,940
function with one argument they get

00:18:38,159 --> 00:18:44,840
table row with primary key so we're

00:18:41,940 --> 00:18:47,400
using you you ITES for everything and

00:18:44,840 --> 00:18:50,580
what we have here is a function where

00:18:47,400 --> 00:18:53,580
you can just look up any UUID and it

00:18:50,580 --> 00:18:55,740
will find whatever table is using that

00:18:53,580 --> 00:18:58,200
as primary key and return you the data

00:18:55,740 --> 00:19:00,030
which is quite handy if you're having a

00:18:58,200 --> 00:19:02,809
lot of you you at ease in your locks and

00:19:00,030 --> 00:19:05,580
you don't know what this is you can just

00:19:02,809 --> 00:19:09,090
fire up the command line tool and it

00:19:05,580 --> 00:19:12,000
returns you what table what content that

00:19:09,090 --> 00:19:15,270
UUID reference and what you can see here

00:19:12,000 --> 00:19:21,890
is this very able to get table row with

00:19:15,270 --> 00:19:24,750
primary key arcs this struct defines the

00:19:21,890 --> 00:19:28,610
arguments for this command so it has

00:19:24,750 --> 00:19:32,100
this command arcs def that's basically

00:19:28,610 --> 00:19:35,250
inheriting the methods you need to

00:19:32,100 --> 00:19:38,880
handle that thing as a command argument

00:19:35,250 --> 00:19:44,010
description and then every field in that

00:19:38,880 --> 00:19:48,360
struct describes one command argument

00:19:44,010 --> 00:19:51,340
and we're using reflection to get the

00:19:48,360 --> 00:19:57,100
type and also as

00:19:51,340 --> 00:20:02,230
can see the tax in the end the ID

00:19:57,100 --> 00:20:05,650
lowercase like we want to use the the

00:20:02,230 --> 00:20:09,280
name for the command argument because

00:20:05,650 --> 00:20:14,380
we're forced to use upper case for

00:20:09,280 --> 00:20:17,140
exported struct fields and so we have

00:20:14,380 --> 00:20:20,530
yeah the name and also some description

00:20:17,140 --> 00:20:23,550
that will also be used when printing

00:20:20,530 --> 00:20:26,920
help information for that command and

00:20:23,550 --> 00:20:31,270
basically for commands we always have

00:20:26,920 --> 00:20:37,900
those pairs of these arcs def variable

00:20:31,270 --> 00:20:42,010
and the function itself and yeah below

00:20:37,900 --> 00:20:44,710
that again you can see how this command

00:20:42,010 --> 00:20:48,480
is added to a command line dispatcher or

00:20:44,710 --> 00:20:58,480
to router that handles that same command

00:20:48,480 --> 00:21:01,690
as a web server yeah I can show you a

00:20:58,480 --> 00:21:04,510
little bit more from our code base here

00:21:01,690 --> 00:21:08,680
so basically what we have is this

00:21:04,510 --> 00:21:12,400
tomando CLI that's the thing that can do

00:21:08,680 --> 00:21:22,180
everything basically that we can do on

00:21:12,400 --> 00:21:29,590
data we have quite a lot of commands

00:21:22,180 --> 00:21:31,860
here and if we call that yeah looks like

00:21:29,590 --> 00:21:31,860
that

00:21:35,789 --> 00:21:44,610
okay can't increase the size but yeah

00:21:40,210 --> 00:21:51,700
here are all commands that you can do to

00:21:44,610 --> 00:21:54,970
add Amanda data and and then also the

00:21:51,700 --> 00:21:57,490
channel configuration flags that we use

00:21:54,970 --> 00:22:04,990
basically to configure everything for

00:21:57,490 --> 00:22:07,529
for all tools to work and yeah doc

00:22:04,990 --> 00:22:13,990
service so I said we have this

00:22:07,529 --> 00:22:16,809
PostgreSQL API for Postgres data and for

00:22:13,990 --> 00:22:19,330
accessing the document database we have

00:22:16,809 --> 00:22:24,999
our doc server which is basically normal

00:22:19,330 --> 00:22:29,350
rest services and just to show you how

00:22:24,999 --> 00:22:33,190
that looks like so what we have here is

00:22:29,350 --> 00:22:37,889
this server run function with gorillas

00:22:33,190 --> 00:22:41,820
MOOCs and creating lots of routes and

00:22:37,889 --> 00:22:46,779
basically they are all wrapping just

00:22:41,820 --> 00:22:49,929
functions so this top database create

00:22:46,779 --> 00:22:55,509
restructure group is a normal function

00:22:49,929 --> 00:22:59,710
it receives destruct destruct is

00:22:55,509 --> 00:23:03,279
automatically converted between Jason so

00:22:59,710 --> 00:23:07,119
yeah if you call this route with Jason

00:23:03,279 --> 00:23:11,049
input data it will convert it and call

00:23:07,119 --> 00:23:15,029
this function if there's an error return

00:23:11,049 --> 00:23:18,580
this error will automatically be

00:23:15,029 --> 00:23:20,830
converted to 500 internal server error

00:23:18,580 --> 00:23:25,809
if it's not a special error if it's a

00:23:20,830 --> 00:23:29,710
special error like a 404 error then it

00:23:25,809 --> 00:23:33,669
will use that for the response and if we

00:23:29,710 --> 00:23:37,809
go back to the route so yeah what we see

00:23:33,669 --> 00:23:42,369
here is this is the route and we have

00:23:37,809 --> 00:23:45,700
this request body argument in that's

00:23:42,369 --> 00:23:47,619
taking and converted as the in argument

00:23:45,700 --> 00:23:48,470
for the command and it calls that

00:23:47,619 --> 00:23:51,500
function

00:23:48,470 --> 00:23:55,419
with that arguments definition and the

00:23:51,500 --> 00:24:00,700
result when it's not an error will be

00:23:55,419 --> 00:24:03,049
returned as a JSON response and

00:24:00,700 --> 00:24:06,070
basically the same function is available

00:24:03,049 --> 00:24:06,070
from the command line

00:24:11,740 --> 00:24:18,800
yeah that's it so this is again an

00:24:15,650 --> 00:24:21,980
overview of those packages that do this

00:24:18,800 --> 00:24:25,660
command magic and the errors and the

00:24:21,980 --> 00:24:27,830
gorilla mooks package we are using

00:24:25,660 --> 00:24:32,740
questions

00:24:27,830 --> 00:24:32,740

YouTube URL: https://www.youtube.com/watch?v=BtZNJIlguUo


