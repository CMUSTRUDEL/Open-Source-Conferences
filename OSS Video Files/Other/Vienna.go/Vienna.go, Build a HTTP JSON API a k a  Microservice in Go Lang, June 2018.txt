Title: Vienna.go, Build a HTTP JSON API a k a  Microservice in Go Lang, June 2018
Publication date: 2018-06-30
Playlist: Vienna.go
Description: 
	Getting Ready For the (Football) World Cup in Russia 2018 - Build a HTTP JSON API (a.k.a.) Microservice in Go Lang and SQLite using the (open) football.db, by Gerald Bauer
Captions: 
	00:00:00,000 --> 00:00:04,920
as of 10 minutes or something short talk

00:00:02,760 --> 00:00:08,010
on building a web service where nowadays

00:00:04,920 --> 00:00:14,660
you know it's more fashion to say it's a

00:00:08,010 --> 00:00:19,289
micro service or HTTP JSON API so and

00:00:14,660 --> 00:00:23,250
the World Cup yeah so the idea is to

00:00:19,289 --> 00:00:26,160
build a World Cup web service that gives

00:00:23,250 --> 00:00:29,820
you the scores the groups and teams

00:00:26,160 --> 00:00:32,130
there are 65 games 32 teams and now

00:00:29,820 --> 00:00:33,719
we're and today there's no match in that

00:00:32,130 --> 00:00:36,350
in the knockout

00:00:33,719 --> 00:00:40,680
so anybody has a favorite team or

00:00:36,350 --> 00:00:41,840
watching the World Cup so okay so let's

00:00:40,680 --> 00:00:47,100
get started

00:00:41,840 --> 00:00:49,410
yeah so to build and how to get started

00:00:47,100 --> 00:00:51,860
first you need the data so how would you

00:00:49,410 --> 00:00:54,260
where do you get the data so one

00:00:51,860 --> 00:00:58,710
interesting thing is it's hard to get

00:00:54,260 --> 00:01:00,690
open public data for the World Cup but I

00:00:58,710 --> 00:01:07,080
have a little project it's called open

00:01:00,690 --> 00:01:08,670
football database and and the open

00:01:07,080 --> 00:01:14,250
football database it has all the World

00:01:08,670 --> 00:01:18,270
Cups but it has on the release tab you

00:01:14,250 --> 00:01:20,880
can download a prebuilt SQLite database

00:01:18,270 --> 00:01:23,909
that has all the World Cups and so we

00:01:20,880 --> 00:01:26,759
are using the SQLite database as the

00:01:23,909 --> 00:01:34,079
source and the idea is to build at Jason

00:01:26,759 --> 00:01:38,450
service and so here's an example of the

00:01:34,079 --> 00:01:41,490
Chasen service so it would have all the

00:01:38,450 --> 00:01:44,790
so Jason for the data interchange I

00:01:41,490 --> 00:01:49,200
think everybody knows Jason and so this

00:01:44,790 --> 00:01:55,079
one tests the first match day Russia

00:01:49,200 --> 00:01:57,799
against Saudi Arabia and so that's the

00:01:55,079 --> 00:02:02,340
idea to have the database and then to

00:01:57,799 --> 00:02:03,479
provide a service in go with in Jason so

00:02:02,340 --> 00:02:08,009
let's get started

00:02:03,479 --> 00:02:11,790
so how would you build it so that's

00:02:08,009 --> 00:02:12,340
what's that how we get the data and the

00:02:11,790 --> 00:02:16,420
first

00:02:12,340 --> 00:02:21,180
this to map the tables in the database

00:02:16,420 --> 00:02:24,040
to go structures and so in this case

00:02:21,180 --> 00:02:28,000
let's say we have the event the World

00:02:24,040 --> 00:02:30,069
Cup and then the team's and/or the old

00:02:28,000 --> 00:02:33,220
strings so there's no magic but the

00:02:30,069 --> 00:02:36,670
first part if you use Chasen go has the

00:02:33,220 --> 00:02:39,400
convention that if you have a field that

00:02:36,670 --> 00:02:42,430
has an uppercase letter then it's

00:02:39,400 --> 00:02:44,140
automatically a public and so usually if

00:02:42,430 --> 00:02:48,040
you have a structure you want all your

00:02:44,140 --> 00:02:49,840
fields to be public but the convention

00:02:48,040 --> 00:02:54,280
if you've seen in jason is that your

00:02:49,840 --> 00:02:57,970
your columns are lowercase and so what

00:02:54,280 --> 00:03:00,910
what can you do to to map it to

00:02:57,970 --> 00:03:04,450
lowercase so inko you can use annotation

00:03:00,910 --> 00:03:07,209
so in this case if you see the a chase

00:03:04,450 --> 00:03:12,579
jason team and chase an event start it

00:03:07,209 --> 00:03:17,500
uses the annotation to map like the

00:03:12,579 --> 00:03:22,769
names to lowercase and so the first step

00:03:17,500 --> 00:03:25,930
is to do a database query and so that's

00:03:22,769 --> 00:03:28,389
later we can discuss or ask you know

00:03:25,930 --> 00:03:31,120
what kind of database library you're

00:03:28,389 --> 00:03:35,680
using so in this example I'm just using

00:03:31,120 --> 00:03:39,810
all the standard gold libraries and not

00:03:35,680 --> 00:03:43,959
any you know advanced extra fancy

00:03:39,810 --> 00:03:48,030
libraries and so I'll do this SQL query

00:03:43,959 --> 00:03:53,980
and so the SQL query is just you know

00:03:48,030 --> 00:03:57,940
getting the getting the event and the

00:03:53,980 --> 00:04:03,069
season and for the SQL light so there is

00:03:57,940 --> 00:04:05,739
a package on github go SQLite it

00:04:03,069 --> 00:04:08,109
actually includes because the SQLite

00:04:05,739 --> 00:04:11,260
database doesn't have a server it's like

00:04:08,109 --> 00:04:15,370
a C library so if you download it it

00:04:11,260 --> 00:04:18,430
actually you need as a C compiler so it

00:04:15,370 --> 00:04:21,750
has they go interface plus it compiles

00:04:18,430 --> 00:04:24,930
less it compiles the SQLite library

00:04:21,750 --> 00:04:27,750
itself to so they might take you know

00:04:24,930 --> 00:04:32,070
a little more than a couple of seconds

00:04:27,750 --> 00:04:35,280
but that's the only external library

00:04:32,070 --> 00:04:38,699
using and it has the standard SQL they

00:04:35,280 --> 00:04:42,180
go as in the database SQL module the

00:04:38,699 --> 00:04:45,180
standard interface and so now to fetch

00:04:42,180 --> 00:04:48,419
to fetch the event the world-cup from

00:04:45,180 --> 00:04:51,690
the database you just opened the

00:04:48,419 --> 00:04:54,600
database in this case football DB which

00:04:51,690 --> 00:04:58,349
would be a single file on your on your

00:04:54,600 --> 00:05:00,900
hard disk there's no server and SQLite

00:04:58,349 --> 00:05:03,720
and then you get the connection and once

00:05:00,900 --> 00:05:06,990
you have the database connection you do

00:05:03,720 --> 00:05:10,139
a query and the query was the SQL string

00:05:06,990 --> 00:05:14,520
so I get the information about the World

00:05:10,139 --> 00:05:16,919
Cup and it you get back a list of rows

00:05:14,520 --> 00:05:21,570
from a table and if you want to have

00:05:16,919 --> 00:05:24,060
more in the example above if you want to

00:05:21,570 --> 00:05:26,610
have more tables in one row you just

00:05:24,060 --> 00:05:32,190
joined the table so standard SQL

00:05:26,610 --> 00:05:34,380
procedure and you get the rows there but

00:05:32,190 --> 00:05:37,139
in in that's the hard part

00:05:34,380 --> 00:05:40,050
in golang if you have a script language

00:05:37,139 --> 00:05:42,599
you know you would be done but in go you

00:05:40,050 --> 00:05:46,620
have to do it manually to map the

00:05:42,599 --> 00:05:48,630
structure the data rows to the structure

00:05:46,620 --> 00:05:51,419
so you've seen the event structure and

00:05:48,630 --> 00:05:54,360
the team structure so you have to

00:05:51,419 --> 00:05:58,139
manually loop over the rows and then you

00:05:54,360 --> 00:06:00,750
scan and in scan you pass in the fields

00:05:58,139 --> 00:06:04,830
in this case key and title would be the

00:06:00,750 --> 00:06:14,009
world cup and then to fill up the data

00:06:04,830 --> 00:06:16,620
structure so now I have I have the the

00:06:14,009 --> 00:06:18,659
rows in Co structures and if you're new

00:06:16,620 --> 00:06:23,940
to if you're coming from from other

00:06:18,659 --> 00:06:27,180
languages one downside of go is or it's

00:06:23,940 --> 00:06:30,150
the upside the echo headline feature is

00:06:27,180 --> 00:06:32,130
the concurrency and so if you have

00:06:30,150 --> 00:06:33,870
concurrency there cannot be any

00:06:32,130 --> 00:06:36,719
exceptions because if you have a

00:06:33,870 --> 00:06:38,380
synchronous where do you send the errors

00:06:36,719 --> 00:06:40,990
and the exceptions

00:06:38,380 --> 00:06:43,270
so the downside is if there are no

00:06:40,990 --> 00:06:46,420
exceptions you have to do all the error

00:06:43,270 --> 00:06:49,150
handling manually and so if you look at

00:06:46,420 --> 00:06:52,570
this code every the database connection

00:06:49,150 --> 00:06:54,820
you know might not work or if you do a

00:06:52,570 --> 00:06:55,710
query there might be an error so every

00:06:54,820 --> 00:06:58,630
call

00:06:55,710 --> 00:07:00,670
always returns the error code and then

00:06:58,630 --> 00:07:04,900
you have to check the error so in this

00:07:00,670 --> 00:07:07,060
case SQL open it gets you the the error

00:07:04,900 --> 00:07:09,430
code and you have to check the error

00:07:07,060 --> 00:07:12,310
code you do the database query you have

00:07:09,430 --> 00:07:14,590
to check the error code and do you do

00:07:12,310 --> 00:07:16,930
Rose scan and you have to check the

00:07:14,590 --> 00:07:18,670
error code so you know if you use a

00:07:16,930 --> 00:07:20,500
scripting language or something you

00:07:18,670 --> 00:07:22,690
really don't care about the error

00:07:20,500 --> 00:07:25,300
because it would throw an exception but

00:07:22,690 --> 00:07:29,290
Inco there is no there are no exception

00:07:25,300 --> 00:07:32,500
so that's kind of a little bear pose but

00:07:29,290 --> 00:07:36,190
that's a feature for a synchronous for

00:07:32,500 --> 00:07:38,950
the concurrent role and so the next step

00:07:36,190 --> 00:07:41,830
is now there's the data structure is to

00:07:38,950 --> 00:07:44,140
generate the JSON and to generate the

00:07:41,830 --> 00:07:49,230
JSON there's the building encoding and

00:07:44,140 --> 00:07:54,370
you just provide the data structure and

00:07:49,230 --> 00:07:56,980
it encodes it into into a JSON string so

00:07:54,370 --> 00:07:59,470
there's not much magic and the great

00:07:56,980 --> 00:08:02,290
part is if you use go so that's one

00:07:59,470 --> 00:08:04,320
advantage for using go for web services

00:08:02,290 --> 00:08:08,260
it has a built in high-performance

00:08:04,320 --> 00:08:10,570
concurrent web server and so to build

00:08:08,260 --> 00:08:14,080
your own web server and go all you have

00:08:10,570 --> 00:08:18,130
to do is to include the net HTTP module

00:08:14,080 --> 00:08:20,740
library and that's it and if you look at

00:08:18,130 --> 00:08:24,130
the main code all you have to do is

00:08:20,740 --> 00:08:27,730
listen and serve so HTTP not listen and

00:08:24,130 --> 00:08:31,210
serve starts up the web server and for

00:08:27,730 --> 00:08:34,120
your services you pass in the the handle

00:08:31,210 --> 00:08:37,630
function with the what services what

00:08:34,120 --> 00:08:40,390
routes you support so usually you would

00:08:37,630 --> 00:08:42,810
use a routing package so in this case I

00:08:40,390 --> 00:08:46,810
do it manually so they handle function

00:08:42,810 --> 00:08:49,240
in this case I only have two services or

00:08:46,810 --> 00:08:52,209
in this case I have the events service

00:08:49,240 --> 00:08:55,779
and so if there's the event service

00:08:52,209 --> 00:08:59,499
if it's matching with the incoming link

00:08:55,779 --> 00:09:04,019
then I do the database query which is

00:08:59,499 --> 00:09:08,410
the get events and then get events

00:09:04,019 --> 00:09:12,009
that's already the the conversion to to

00:09:08,410 --> 00:09:17,559
chasten and a returns it the B the B is

00:09:12,009 --> 00:09:22,050
four bytes and then the bytes get get

00:09:17,559 --> 00:09:25,660
gets passed along to the web server and

00:09:22,050 --> 00:09:28,540
and serviced and again you see you know

00:09:25,660 --> 00:09:32,800
half the code is just the the error

00:09:28,540 --> 00:09:35,610
handling so I mean I think you can make

00:09:32,800 --> 00:09:39,249
it easier with check errors to use a

00:09:35,610 --> 00:09:42,819
check error function but otherwise

00:09:39,249 --> 00:09:48,660
there's not much magic so that's pretty

00:09:42,819 --> 00:09:52,839
much there's no magic that's not not so

00:09:48,660 --> 00:09:55,869
so much but why would you use go so for

00:09:52,839 --> 00:09:57,819
example and great feature about using go

00:09:55,869 --> 00:10:01,240
even if it's a little bit posed as the

00:09:57,819 --> 00:10:06,189
error handling is you get super fast

00:10:01,240 --> 00:10:09,309
code so go with super fast and compared

00:10:06,189 --> 00:10:11,019
compared to C to other systems

00:10:09,309 --> 00:10:14,139
programming language it's actually a

00:10:11,019 --> 00:10:16,420
less less code so if you're compared to

00:10:14,139 --> 00:10:19,209
biting you know there's more error

00:10:16,420 --> 00:10:21,670
handling and more verbose code but if

00:10:19,209 --> 00:10:24,639
you compare it to C code like how would

00:10:21,670 --> 00:10:26,860
you add a web server in C and and so

00:10:24,639 --> 00:10:29,740
there are no standard libraries so

00:10:26,860 --> 00:10:34,360
compared to see it's actually super easy

00:10:29,740 --> 00:10:36,160
and the real part is you know you don't

00:10:34,360 --> 00:10:38,649
need a virtual machine that's compared

00:10:36,160 --> 00:10:42,160
to Java if you would do it in Java you

00:10:38,649 --> 00:10:44,439
have to use all like it needs lots of

00:10:42,160 --> 00:10:47,230
memory and it's a virtual machine but in

00:10:44,439 --> 00:10:49,360
inko it they create standalone binaries

00:10:47,230 --> 00:10:51,160
and the standalone binary includes

00:10:49,360 --> 00:10:54,009
everything so in this case it would

00:10:51,160 --> 00:10:57,549
include the SQLite database and it would

00:10:54,009 --> 00:11:01,559
include the web server and to deploy it

00:10:57,549 --> 00:11:05,400
all you have to do to upload executable

00:11:01,559 --> 00:11:07,890
and again the headline feature

00:11:05,400 --> 00:11:09,780
is the concurrency which in this case

00:11:07,890 --> 00:11:12,360
the concurrency works for your web

00:11:09,780 --> 00:11:15,960
server which makes it fast and the other

00:11:12,360 --> 00:11:19,620
headline feature is the superfast built

00:11:15,960 --> 00:11:23,070
so go if you build it compared to C++ if

00:11:19,620 --> 00:11:26,330
you have big lots of source code the

00:11:23,070 --> 00:11:29,370
build is super fast in this case it's

00:11:26,330 --> 00:11:31,890
it's kind of with the SQLite database

00:11:29,370 --> 00:11:34,830
it's not working because the SQLite

00:11:31,890 --> 00:11:38,820
database module is actually C code and

00:11:34,830 --> 00:11:40,710
then it has to just a wrapper around the

00:11:38,820 --> 00:11:44,030
C code and then it have to has to use AG

00:11:40,710 --> 00:11:47,850
new company compiler to compile the

00:11:44,030 --> 00:11:52,650
SQLite extension but otherwise it's

00:11:47,850 --> 00:11:54,930
super fast the built and yeah there's

00:11:52,650 --> 00:12:00,230
another anybody knows the how a start

00:11:54,930 --> 00:12:00,230
website so they how I start the website

00:12:02,630 --> 00:12:12,900
is getting started with all kinds of

00:12:07,500 --> 00:12:15,990
languages C++ Ruby Haskell and there's

00:12:12,900 --> 00:12:18,330
how I start with Cisco and if anybody's

00:12:15,990 --> 00:12:22,080
interesting in building a web service so

00:12:18,330 --> 00:12:25,110
this web service shows he's not using a

00:12:22,080 --> 00:12:28,380
database but he's using a meadow service

00:12:25,110 --> 00:12:31,830
and he's fetching the weather forecast

00:12:28,380 --> 00:12:34,400
for my city and then republishing the

00:12:31,830 --> 00:12:38,850
web better service we seen with his own

00:12:34,400 --> 00:12:43,730
web service but and so there's a nice

00:12:38,850 --> 00:12:43,730
little making the web server and the

00:12:44,510 --> 00:12:50,420
Jason service end zone on the force

00:12:47,190 --> 00:12:53,160
yeah so there's really not lots of magic

00:12:50,420 --> 00:12:55,590
that's pretty much yeah

00:12:53,160 --> 00:12:57,300
and and the code if you want to look at

00:12:55,590 --> 00:13:02,810
the code it's actually the code is

00:12:57,300 --> 00:13:02,810
online for the tiny web service

00:13:05,939 --> 00:13:09,199
okay so

00:13:21,890 --> 00:13:28,630
so that's the the coercion and there's

00:13:25,940 --> 00:13:28,630
the server

00:13:37,410 --> 00:13:44,849
yeah so there's not really uh so it's

00:13:41,669 --> 00:13:48,660
super fast to build you know fast lab

00:13:44,849 --> 00:13:50,279
services in go and usually what you

00:13:48,660 --> 00:13:51,329
would do for the routing to use a

00:13:50,279 --> 00:13:55,709
library

00:13:51,329 --> 00:13:59,329
there's gorila chai and there are so

00:13:55,709 --> 00:14:03,590
many different you know libraries so

00:13:59,329 --> 00:14:07,299
yeah any questions or

00:14:03,590 --> 00:14:07,299

YouTube URL: https://www.youtube.com/watch?v=1P_-s8bv-SU


