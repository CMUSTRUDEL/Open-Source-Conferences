Title: Vienna.go, This is Go - a personal tale on what makes Go unique, November 2019
Publication date: 2019-11-28
Playlist: Vienna.go
Description: 
	Talk by Rodolfo Carvalho
Captions: 
	00:00:00,000 --> 00:00:06,089
yeah so today I brought kind of revived

00:00:03,360 --> 00:00:06,660
some old talk I gave like three years

00:00:06,089 --> 00:00:09,179
ago

00:00:06,660 --> 00:00:13,230
and I tried it this do and choose like

00:00:09,179 --> 00:00:17,340
five five ideas five conversation topics

00:00:13,230 --> 00:00:20,100
as I like to say about go just to bring

00:00:17,340 --> 00:00:23,670
to you I try to combine them with some

00:00:20,100 --> 00:00:25,140
some reason some story and yeah I would

00:00:23,670 --> 00:00:27,240
like to use these also for a

00:00:25,140 --> 00:00:30,710
conversation later if if you'd like to

00:00:27,240 --> 00:00:33,270
to talk or ask questions and it's not

00:00:30,710 --> 00:00:35,010
itself an introduction about go it was

00:00:33,270 --> 00:00:36,420
not meant like that but I think for

00:00:35,010 --> 00:00:39,090
those of you who never wrote a single

00:00:36,420 --> 00:00:41,040
line of go it may also be helpful in

00:00:39,090 --> 00:00:42,540
understanding like what kind of language

00:00:41,040 --> 00:00:47,520
it is and what kind of things you can

00:00:42,540 --> 00:00:51,420
expect yeah so the story begins with

00:00:47,520 --> 00:00:56,520
this guy here his name is Robert

00:00:51,420 --> 00:00:59,670
Lefkowitz and he somehow influenced my

00:00:56,520 --> 00:01:03,920
life it was in 2007

00:00:59,670 --> 00:01:06,299
he gave a talk at the PyCon in US and

00:01:03,920 --> 00:01:10,049
there are so many good things in his

00:01:06,299 --> 00:01:12,390
talk that I took one out of it which was

00:01:10,049 --> 00:01:16,080
the definition he wanted to give for

00:01:12,390 --> 00:01:17,430
computer programming literacy and this

00:01:16,080 --> 00:01:21,030
definition of computer programming

00:01:17,430 --> 00:01:22,890
literacy traveling with me for like I

00:01:21,030 --> 00:01:25,560
don't know more than 10 years now and

00:01:22,890 --> 00:01:27,570
it's something that basically shapes the

00:01:25,560 --> 00:01:29,790
way how I look at programming and how I

00:01:27,570 --> 00:01:33,229
look at programming languages and how I

00:01:29,790 --> 00:01:35,909
look at what it is the job that we do as

00:01:33,229 --> 00:01:38,759
programmers developers and the

00:01:35,909 --> 00:01:40,650
definition is that computer programming

00:01:38,759 --> 00:01:44,189
is the art of communicating through

00:01:40,650 --> 00:01:46,920
symbols ideas about reality and I'll try

00:01:44,189 --> 00:01:50,700
to use that as a way to to look at go

00:01:46,920 --> 00:01:52,530
and see like how can we use golf to

00:01:50,700 --> 00:01:53,990
communicate or symbols ideas about

00:01:52,530 --> 00:01:58,979
reality

00:01:53,990 --> 00:02:01,380
alright so point number one here which I

00:01:58,979 --> 00:02:03,450
could talk about it maybe not me but

00:02:01,380 --> 00:02:05,909
like you could hear a talk from Rob Pike

00:02:03,450 --> 00:02:08,039
one of the creators of the language you

00:02:05,909 --> 00:02:10,560
could hear him talk about it for like I

00:02:08,039 --> 00:02:13,930
don't know 40 minutes or so discussing

00:02:10,560 --> 00:02:17,019
in detail what makes go simple

00:02:13,930 --> 00:02:19,450
and I would just tell you like my my

00:02:17,019 --> 00:02:23,439
experience and my point of view like why

00:02:19,450 --> 00:02:25,890
I think go is simple so let me find here

00:02:23,439 --> 00:02:31,959
there was somebody who is learning go

00:02:25,890 --> 00:02:34,420
yeah and yeah there there it is so I

00:02:31,959 --> 00:02:36,400
just heard so it's not me I heard that

00:02:34,420 --> 00:02:39,700
go is easy to learn so you have to take

00:02:36,400 --> 00:02:41,680
that for granted but alright so what

00:02:39,700 --> 00:02:44,650
makes go is simple language and what's

00:02:41,680 --> 00:02:47,260
that in simplicity and what makes go

00:02:44,650 --> 00:02:49,030
simple so let's start just looking at a

00:02:47,260 --> 00:02:51,159
hello world example right that's like

00:02:49,030 --> 00:02:54,639
the the basic you look into every

00:02:51,159 --> 00:02:59,250
language and that's one way of writing a

00:02:54,639 --> 00:03:06,790
hello world for go and that is just

00:02:59,250 --> 00:03:11,349
small number of lines right and you can

00:03:06,790 --> 00:03:13,750
see that line by line like what what is

00:03:11,349 --> 00:03:16,420
it in a go program so the first thing is

00:03:13,750 --> 00:03:20,010
to talk about packages right packages

00:03:16,420 --> 00:03:23,730
allow you to have namespaces and isolate

00:03:20,010 --> 00:03:26,620
components of your program it's also

00:03:23,730 --> 00:03:30,359
it's also the the way how you can share

00:03:26,620 --> 00:03:33,549
code by having different packages and

00:03:30,359 --> 00:03:35,590
that's in the top of every line of go

00:03:33,549 --> 00:03:38,530
program you see what package it is and

00:03:35,590 --> 00:03:41,440
this small thing but it it comes with a

00:03:38,530 --> 00:03:44,079
lot of consequences that makes using go

00:03:41,440 --> 00:03:45,549
so much easier the next thing and one

00:03:44,079 --> 00:03:49,959
that I really like I really appreciate

00:03:45,549 --> 00:03:52,359
when I look at go programs is the the

00:03:49,959 --> 00:03:54,669
existence of fully qualified imports so

00:03:52,359 --> 00:03:56,650
importing over just a string here

00:03:54,669 --> 00:04:00,340
importing some from the standard library

00:03:56,650 --> 00:04:02,470
but if you have something like a library

00:04:00,340 --> 00:04:04,120
you go from github or anywhere you're

00:04:02,470 --> 00:04:07,090
just gonna see the full path there where

00:04:04,120 --> 00:04:09,040
the thing is coming from and the way

00:04:07,090 --> 00:04:10,180
that that thing is kind of important for

00:04:09,040 --> 00:04:12,040
me is that when I'm working on a

00:04:10,180 --> 00:04:15,129
different language so I have a

00:04:12,040 --> 00:04:16,959
background in Python for example and I

00:04:15,129 --> 00:04:19,150
think it's the same thing with with

00:04:16,959 --> 00:04:21,570
nodejs with javascript typescript so

00:04:19,150 --> 00:04:23,400
correct me if i'm wrong

00:04:21,570 --> 00:04:25,140
but what happens is that you see an

00:04:23,400 --> 00:04:27,210
import in the beginning of a file and

00:04:25,140 --> 00:04:28,950
you have no clue where that thing comes

00:04:27,210 --> 00:04:32,160
from so I have to go look at a

00:04:28,950 --> 00:04:34,050
configuration file and try to find okay

00:04:32,160 --> 00:04:35,820
which version is of this thing is

00:04:34,050 --> 00:04:38,130
installed what is in the environment

00:04:35,820 --> 00:04:40,470
what's not and then go it's kind of

00:04:38,130 --> 00:04:42,930
beautiful because like it's very easy

00:04:40,470 --> 00:04:45,600
you see the name that is here and that's

00:04:42,930 --> 00:04:47,340
where we're gonna find even online where

00:04:45,600 --> 00:04:51,420
where is the code that you're talking

00:04:47,340 --> 00:04:54,030
about so the next thing that go brings

00:04:51,420 --> 00:04:55,590
like to the modern programming languages

00:04:54,030 --> 00:04:58,620
and statically typed programming

00:04:55,590 --> 00:05:01,230
languages it's type inference so even

00:04:58,620 --> 00:05:03,660
though the the program is that

00:05:01,230 --> 00:05:05,670
statically typed and the compiler will

00:05:03,660 --> 00:05:10,260
shout at you if you if you make a

00:05:05,670 --> 00:05:11,910
mistake regarding two types you don't

00:05:10,260 --> 00:05:15,020
have to write types anywhere like you

00:05:11,910 --> 00:05:18,120
see here there is no nothing about types

00:05:15,020 --> 00:05:21,900
because if you assign a string literal

00:05:18,120 --> 00:05:25,380
to a variable s go nose in the compiler

00:05:21,900 --> 00:05:27,750
knows the type of s is a string right so

00:05:25,380 --> 00:05:31,860
you just get a lot less noise in your

00:05:27,750 --> 00:05:33,540
program another little thing is single

00:05:31,860 --> 00:05:36,240
dispatch so if you see here there's a

00:05:33,540 --> 00:05:38,940
method call a function called print line

00:05:36,240 --> 00:05:41,220
there is only one print line available

00:05:38,940 --> 00:05:46,170
so there's no operator overloading

00:05:41,220 --> 00:05:48,690
there's no like no multiple signatures

00:05:46,170 --> 00:05:50,880
for this function so you see a function

00:05:48,690 --> 00:05:53,220
you can grab for it and you know that's

00:05:50,880 --> 00:05:55,500
the thing that gets called in runtime so

00:05:53,220 --> 00:05:57,900
there is a lot less surprise a lot less

00:05:55,500 --> 00:06:00,000
magic happening the language is very

00:05:57,900 --> 00:06:02,910
very predict predictive like you can

00:06:00,000 --> 00:06:05,580
predict what's gonna happen predictable

00:06:02,910 --> 00:06:07,230
sorry and the other thing that might be

00:06:05,580 --> 00:06:11,700
weird for people starting with Co is

00:06:07,230 --> 00:06:15,510
that upper and lower case in in names

00:06:11,700 --> 00:06:17,670
they are actually meaningful so what

00:06:15,510 --> 00:06:20,490
this allows you to do is it allows you

00:06:17,670 --> 00:06:22,680
to tell what names are exported and what

00:06:20,490 --> 00:06:25,140
names are not exported and you don't

00:06:22,680 --> 00:06:27,750
have to add extra keywords for that so

00:06:25,140 --> 00:06:28,950
when you look again the big picture you

00:06:27,750 --> 00:06:32,460
look at the

00:06:28,950 --> 00:06:34,470
at a at a goal source file you don't see

00:06:32,460 --> 00:06:37,260
a lot of extra things saying this

00:06:34,470 --> 00:06:39,600
private public or something you just you

00:06:37,260 --> 00:06:41,250
can read code anywhere and you know if a

00:06:39,600 --> 00:06:43,830
name is public or private by just

00:06:41,250 --> 00:06:47,370
looking at the the capitalisation so for

00:06:43,830 --> 00:06:49,770
me this is this is very very good so I

00:06:47,370 --> 00:06:51,600
like go because it fits fits my brain

00:06:49,770 --> 00:06:53,400
like it's a small language compared to

00:06:51,600 --> 00:06:55,260
other languages you look at the the

00:06:53,400 --> 00:06:58,980
language spec it's really small we could

00:06:55,260 --> 00:07:01,980
print it put it in a small booklet it's

00:06:58,980 --> 00:07:04,860
very stable so I learned go many years

00:07:01,980 --> 00:07:06,630
ago it haven't changed so go is making

00:07:04,860 --> 00:07:10,920
ten years now it haven't changed since

00:07:06,630 --> 00:07:12,810
go 1.0 so it's the same language so this

00:07:10,920 --> 00:07:15,180
is stability sometimes makes the

00:07:12,810 --> 00:07:17,460
language boring but out claim now that

00:07:15,180 --> 00:07:19,280
boring is good boring is something that

00:07:17,460 --> 00:07:21,810
you can predict something that you can

00:07:19,280 --> 00:07:24,660
understand I think of it like learning

00:07:21,810 --> 00:07:27,240
how to ride a bicycle right so you learn

00:07:24,660 --> 00:07:29,640
it once you may not write for years then

00:07:27,240 --> 00:07:31,980
you get to a bike again and you can just

00:07:29,640 --> 00:07:34,860
write write it's ask you you develop and

00:07:31,980 --> 00:07:38,730
you you get like you can easily catch

00:07:34,860 --> 00:07:41,700
again so as I claimed already it's not

00:07:38,730 --> 00:07:43,080
me somebody said go is easy to learn so

00:07:41,700 --> 00:07:47,250
if you're learning go

00:07:43,080 --> 00:07:49,440
you can confirm and again for for having

00:07:47,250 --> 00:07:52,320
a like a very minimal language with less

00:07:49,440 --> 00:07:54,450
constructs less kinds of syntax it's

00:07:52,320 --> 00:07:57,570
very easy to to read look for anybody

00:07:54,450 --> 00:08:01,890
who learned a CC based language like

00:07:57,570 --> 00:08:03,090
JavaScript Python Ruby Java you look at

00:08:01,890 --> 00:08:05,190
go code and you can read it immediately

00:08:03,090 --> 00:08:06,630
even if you haven't read anything about

00:08:05,190 --> 00:08:08,580
it

00:08:06,630 --> 00:08:10,260
yeah all those things put together I

00:08:08,580 --> 00:08:12,540
feel like go is very good for big

00:08:10,260 --> 00:08:14,610
projects and for working with more

00:08:12,540 --> 00:08:15,690
people in larger teams it's something

00:08:14,610 --> 00:08:18,930
that at least has worked for me

00:08:15,690 --> 00:08:19,920
successfully before I worked for some

00:08:18,930 --> 00:08:22,320
time in OpenShift

00:08:19,920 --> 00:08:25,710
which is redheads distribution of

00:08:22,320 --> 00:08:27,960
kubernetes and that's a project with

00:08:25,710 --> 00:08:31,590
hundreds of developers around the globe

00:08:27,960 --> 00:08:33,570
and yeah somehow it's easier to work on

00:08:31,590 --> 00:08:37,170
a codebase then if it was I don't know

00:08:33,570 --> 00:08:39,360
an equivalent in in Python for me like

00:08:37,170 --> 00:08:42,630
because again there are no magic there

00:08:39,360 --> 00:08:44,699
is no way to sneaking complexities

00:08:42,630 --> 00:08:53,910
and a lot of this is due to the

00:08:44,699 --> 00:08:56,850
simplicity in the language right so yeah

00:08:53,910 --> 00:09:00,000
so I said that I want to talk about go

00:08:56,850 --> 00:09:01,680
in in this this framework that computer

00:09:00,000 --> 00:09:03,899
programming is the art of communicating

00:09:01,680 --> 00:09:05,339
through symbols ideas about reality so

00:09:03,899 --> 00:09:08,220
the second point I want to make is very

00:09:05,339 --> 00:09:10,769
short whenever you put people to work on

00:09:08,220 --> 00:09:13,079
something if there are two if there is

00:09:10,769 --> 00:09:14,370
one developer perfect there are two

00:09:13,079 --> 00:09:17,370
people there start discussing about

00:09:14,370 --> 00:09:18,870
useless stuff right and what's the first

00:09:17,370 --> 00:09:21,569
thing that people discuss that is

00:09:18,870 --> 00:09:25,709
completely useless I would say is code

00:09:21,569 --> 00:09:28,470
formatting so we've go yeah just shut up

00:09:25,709 --> 00:09:31,769
run go format or go foamed and that's

00:09:28,470 --> 00:09:32,819
the way your code should be so yeah

00:09:31,769 --> 00:09:38,660
that's it

00:09:32,819 --> 00:09:42,209
love it okay on to the third thing so

00:09:38,660 --> 00:09:45,110
surfing today is I hear it's

00:09:42,209 --> 00:09:49,529
controversial like some people just hate

00:09:45,110 --> 00:09:52,350
errors and error handling go personally

00:09:49,529 --> 00:09:54,569
I like it and I I feel like you have to

00:09:52,350 --> 00:09:57,480
accept the language and try to think in

00:09:54,569 --> 00:10:00,630
terms of the language and I'm gonna show

00:09:57,480 --> 00:10:04,709
you with hopefully that there is a

00:10:00,630 --> 00:10:08,339
benefit that comes from having no

00:10:04,709 --> 00:10:10,829
exceptions and go so normally in other

00:10:08,339 --> 00:10:12,870
languages you have a way to throw an

00:10:10,829 --> 00:10:16,079
exception or cause a mirror that bubbles

00:10:12,870 --> 00:10:18,740
up the stack and suddenly somewhere you

00:10:16,079 --> 00:10:22,139
catch all errors and handle it somehow

00:10:18,740 --> 00:10:24,029
in go what you get instead is explicit

00:10:22,139 --> 00:10:26,639
on-the-spot error handling

00:10:24,029 --> 00:10:28,620
so again if you're reading code it's

00:10:26,639 --> 00:10:31,019
great like you give me any piece of go

00:10:28,620 --> 00:10:33,899
code I've never seen before and I can

00:10:31,019 --> 00:10:38,220
tell in which parts there are errors in

00:10:33,899 --> 00:10:41,009
which parts there should have been ears

00:10:38,220 --> 00:10:45,029
and they're not there how things are

00:10:41,009 --> 00:10:47,370
handled what what like what is done with

00:10:45,029 --> 00:10:49,769
the error because error just a value

00:10:47,370 --> 00:10:51,540
just like an integer a string or

00:10:49,769 --> 00:10:54,510
whatever else you would have in a

00:10:51,540 --> 00:10:55,830
programming language and that's again

00:10:54,510 --> 00:10:58,110
very nice it

00:10:55,830 --> 00:10:59,700
it means you have less things in the

00:10:58,110 --> 00:11:01,680
language again because there are no

00:10:59,700 --> 00:11:03,900
exceptions there are no try caches there

00:11:01,680 --> 00:11:08,910
are no so the grammar of the language is

00:11:03,900 --> 00:11:11,160
smaller and everything you learn to do

00:11:08,910 --> 00:11:13,410
with the language so all the tutorials

00:11:11,160 --> 00:11:14,700
you go through all the ideas you can use

00:11:13,410 --> 00:11:18,810
it with yours as well because they are

00:11:14,700 --> 00:11:21,180
just normal values so good thing about

00:11:18,810 --> 00:11:22,800
having to be explicit about errors is

00:11:21,180 --> 00:11:26,040
that you actually get to think about

00:11:22,800 --> 00:11:29,340
them up front so I I am of the opinion

00:11:26,040 --> 00:11:31,500
that often if you're working on a script

00:11:29,340 --> 00:11:34,620
and trying to get stuff done you just

00:11:31,500 --> 00:11:39,540
like think of the the good the good flow

00:11:34,620 --> 00:11:41,340
like where everything just works and you

00:11:39,540 --> 00:11:43,410
handle the errors later right when you

00:11:41,340 --> 00:11:45,180
get a when you get an exception

00:11:43,410 --> 00:11:46,950
somewhere when your server is burning

00:11:45,180 --> 00:11:49,500
and so on then you know okay I should

00:11:46,950 --> 00:11:51,210
have made this thing better and we've

00:11:49,500 --> 00:11:53,430
gone oh you get you think about error

00:11:51,210 --> 00:11:56,880
conditions up front right from from

00:11:53,430 --> 00:11:59,790
designing your API from calling third

00:11:56,880 --> 00:12:01,740
party API and the reason why a lot of

00:11:59,790 --> 00:12:04,800
people complain about go is when they

00:12:01,740 --> 00:12:06,930
see this repetition in code of you

00:12:04,800 --> 00:12:10,050
basically call a method so let's say

00:12:06,930 --> 00:12:12,750
here I have a file descriptor and it it

00:12:10,050 --> 00:12:16,200
may write 2 to 2 you may write some

00:12:12,750 --> 00:12:18,510
bytes to to a file let's say and return

00:12:16,200 --> 00:12:21,120
a number of bytes written in an error

00:12:18,510 --> 00:12:24,090
and you do it multiple times and you see

00:12:21,120 --> 00:12:26,130
this repetition so you have okay if

00:12:24,090 --> 00:12:27,780
you're different and new then return the

00:12:26,130 --> 00:12:29,790
error and his CD is over and over and

00:12:27,780 --> 00:12:33,720
over and then people complain oh error

00:12:29,790 --> 00:12:36,630
in go sucks right but normally this is

00:12:33,720 --> 00:12:38,430
because people fail to realize that you

00:12:36,630 --> 00:12:40,380
can program your errors just like you

00:12:38,430 --> 00:12:44,280
can program repetition in other parts of

00:12:40,380 --> 00:12:47,820
code so an example of that is that you

00:12:44,280 --> 00:12:50,820
can create a special you can create a

00:12:47,820 --> 00:12:54,690
special type like an error writer that

00:12:50,820 --> 00:12:57,270
that type does the the error checking

00:12:54,690 --> 00:13:01,980
for you only once and then you can call

00:12:57,270 --> 00:13:04,860
it several times without the noise of if

00:13:01,980 --> 00:13:06,900
error new with era new right so there

00:13:04,860 --> 00:13:07,920
are ways around the thing that people

00:13:06,900 --> 00:13:10,679
complain of

00:13:07,920 --> 00:13:14,730
like repetition and again it has the

00:13:10,679 --> 00:13:17,970
advantage of clarity right so it is very

00:13:14,730 --> 00:13:22,920
very like obvious in your face what's

00:13:17,970 --> 00:13:24,419
happening right all right so air

00:13:22,920 --> 00:13:27,329
handling is great

00:13:24,419 --> 00:13:29,100
so if programming is the art of

00:13:27,329 --> 00:13:32,790
communicating through symbols ideas

00:13:29,100 --> 00:13:36,419
about reality one of the ways you you

00:13:32,790 --> 00:13:40,079
haven't go to express ideas and errors

00:13:36,419 --> 00:13:43,049
is one of them is using interfaces right

00:13:40,079 --> 00:13:44,669
so go has this idea of interfaces which

00:13:43,049 --> 00:13:47,399
is also different than other languages

00:13:44,669 --> 00:13:49,949
and it's something for me that caught my

00:13:47,399 --> 00:13:51,749
attention early on and it it helps you

00:13:49,949 --> 00:13:53,489
think about programming also bit

00:13:51,749 --> 00:13:57,230
differently it allows you to do things

00:13:53,489 --> 00:14:01,169
differently and interfaces in go are

00:13:57,230 --> 00:14:05,519
post facto abstraction too so it

00:14:01,169 --> 00:14:10,339
basically allows you to do at any point

00:14:05,519 --> 00:14:13,410
in your code to talk about somehow a

00:14:10,339 --> 00:14:15,480
structure of what you expect without

00:14:13,410 --> 00:14:19,649
talking about the concreteness of a

00:14:15,480 --> 00:14:21,480
certain type right so lots of times I'm

00:14:19,649 --> 00:14:24,600
coding in Python other languages I want

00:14:21,480 --> 00:14:27,589
to say oh I I'm coding here an API and I

00:14:24,600 --> 00:14:30,809
want to say you should pass let's say a

00:14:27,589 --> 00:14:33,660
an object that has this this this and

00:14:30,809 --> 00:14:36,839
that method and the only way to do that

00:14:33,660 --> 00:14:39,899
is to hope that somebody will read your

00:14:36,839 --> 00:14:41,339
Docs or maybe at best you write an

00:14:39,899 --> 00:14:44,959
abstract class or something like that

00:14:41,339 --> 00:14:48,749
but there's no age lying enforce

00:14:44,959 --> 00:14:50,459
interfaces then in majority of other

00:14:48,749 --> 00:14:52,970
languages that do implement the

00:14:50,459 --> 00:14:55,319
interfaces as a concept in the language

00:14:52,970 --> 00:14:58,139
you have a difference that you have to

00:14:55,319 --> 00:15:00,419
implement you have to declare your

00:14:58,139 --> 00:15:01,860
interfaces up front so you have to have

00:15:00,419 --> 00:15:05,509
something in the standard library let's

00:15:01,860 --> 00:15:07,919
say we're in a famous framework and then

00:15:05,509 --> 00:15:10,829
if you want to implement that interface

00:15:07,919 --> 00:15:12,419
you have to explicitly say I'm creating

00:15:10,829 --> 00:15:16,049
here a class that implements this

00:15:12,419 --> 00:15:18,419
interface right so somehow like all the

00:15:16,049 --> 00:15:20,080
code in the world has to agree on what's

00:15:18,419 --> 00:15:21,820
the name of a certain interface

00:15:20,080 --> 00:15:25,330
and everybody needs to implement that

00:15:21,820 --> 00:15:28,360
interface so basically like if I create

00:15:25,330 --> 00:15:30,520
a let's take an example of a reader

00:15:28,360 --> 00:15:34,900
right and I or either something that can

00:15:30,520 --> 00:15:37,930
read bytes right if I have if I have

00:15:34,900 --> 00:15:41,980
only one way to create this interface I

00:15:37,930 --> 00:15:44,890
have to put it in the in the in the

00:15:41,980 --> 00:15:49,240
standard library and let's say somebody

00:15:44,890 --> 00:15:51,160
some framework I'm using did not declare

00:15:49,240 --> 00:15:54,700
that their class implements this

00:15:51,160 --> 00:15:57,640
interface now I'm basically locked I

00:15:54,700 --> 00:15:59,890
can't change that code and I can't take

00:15:57,640 --> 00:16:02,890
that interface instead of the concrete

00:15:59,890 --> 00:16:05,290
class from another framework that's not

00:16:02,890 --> 00:16:08,410
the case and go because then go to

00:16:05,290 --> 00:16:10,420
satisfy an interface you just need to do

00:16:08,410 --> 00:16:11,950
your type just need to implement the

00:16:10,420 --> 00:16:15,160
methods that are in the interface there

00:16:11,950 --> 00:16:18,940
are no implements statement or anything

00:16:15,160 --> 00:16:22,270
like that and it allows you to do very

00:16:18,940 --> 00:16:24,040
very interesting things so there are

00:16:22,270 --> 00:16:26,920
some interfaces already in the standard

00:16:24,040 --> 00:16:36,940
library like this this is one of them to

00:16:26,920 --> 00:16:38,320
read their interface right so another

00:16:36,940 --> 00:16:40,000
difference may be a conceptual

00:16:38,320 --> 00:16:41,830
difference in go is the idea of making

00:16:40,000 --> 00:16:44,260
the interface is really small so you can

00:16:41,830 --> 00:16:47,020
compose them so for example if you if

00:16:44,260 --> 00:16:49,330
you know if you say I want a reader it

00:16:47,020 --> 00:16:50,770
just needs to have a method read and you

00:16:49,330 --> 00:16:51,610
have a writer just needs to have a

00:16:50,770 --> 00:16:53,860
method right

00:16:51,610 --> 00:16:56,200
you can then compose the to say now I

00:16:53,860 --> 00:16:58,240
have a read writer that is both a reader

00:16:56,200 --> 00:17:01,210
and a writer and then you can start for

00:16:58,240 --> 00:17:02,980
example mocking out files right or

00:17:01,210 --> 00:17:05,050
explaining what what's the behavior of a

00:17:02,980 --> 00:17:06,790
fire but it could be a fire it could be

00:17:05,050 --> 00:17:09,640
a network socket it could be anything

00:17:06,790 --> 00:17:13,810
and you can easily like combine these

00:17:09,640 --> 00:17:16,060
things right so to implement an

00:17:13,810 --> 00:17:19,510
interface and go as I said you don't

00:17:16,060 --> 00:17:23,500
need to declare anything upfront so if

00:17:19,510 --> 00:17:27,160
you create a type file which is a struct

00:17:23,500 --> 00:17:29,830
with a name you simply add methods to it

00:17:27,160 --> 00:17:32,080
so for example you read you attach here

00:17:29,830 --> 00:17:34,980
a read method

00:17:32,080 --> 00:17:37,330
with a fire receiver and that thing

00:17:34,980 --> 00:17:42,100
automatically implements the the

00:17:37,330 --> 00:17:44,889
interface for reading so wherever you at

00:17:42,100 --> 00:17:49,299
you you or any code you use expects a

00:17:44,889 --> 00:17:51,419
reader an i/o reader you can pass in

00:17:49,299 --> 00:17:56,980
your file that you just constructed and

00:17:51,419 --> 00:17:59,830
all the things we work I so for me like

00:17:56,980 --> 00:18:02,889
it's it's it's like a very simple very

00:17:59,830 --> 00:18:07,059
lightweight syntax and allows you to do

00:18:02,889 --> 00:18:10,869
a very powerful stuff to define your own

00:18:07,059 --> 00:18:12,519
interfaces again you just say what what

00:18:10,869 --> 00:18:14,049
is the name of the method you want in

00:18:12,519 --> 00:18:16,350
the interface and what's the signature

00:18:14,049 --> 00:18:18,639
so basically it's the name of the method

00:18:16,350 --> 00:18:21,399
what are the arguments it takes and what

00:18:18,639 --> 00:18:23,529
are the return values and I have like a

00:18:21,399 --> 00:18:26,080
I don't remember how I found this

00:18:23,529 --> 00:18:29,830
example but there is a advanced thing

00:18:26,080 --> 00:18:32,919
here a big wall of text but I'll try to

00:18:29,830 --> 00:18:37,269
highlight here this is an example taken

00:18:32,919 --> 00:18:41,289
from the go the go to like the go source

00:18:37,269 --> 00:18:44,049
code again I wish I could find how I

00:18:41,289 --> 00:18:47,320
discover this but it was a way how using

00:18:44,049 --> 00:18:50,700
interfaces they eliminate coded

00:18:47,320 --> 00:18:54,249
dependencies between an HTTP server and

00:18:50,700 --> 00:18:57,100
HTTP client code code in the in the

00:18:54,249 --> 00:18:59,440
standard library so what it means and

00:18:57,100 --> 00:19:02,080
for me the importance of this is that

00:18:59,440 --> 00:19:04,570
whenever import a package

00:19:02,080 --> 00:19:06,940
maybe report a package for one symbol

00:19:04,570 --> 00:19:09,369
that is defined there right for for

00:19:06,940 --> 00:19:12,039
let's say an interface name or anything

00:19:09,369 --> 00:19:14,409
right or a certain type you want to use

00:19:12,039 --> 00:19:15,970
whenever import one of the things from

00:19:14,409 --> 00:19:18,669
the package you magically gets

00:19:15,970 --> 00:19:23,440
everything of the package so your binary

00:19:18,669 --> 00:19:25,809
size just grows boom you import another

00:19:23,440 --> 00:19:27,249
package and you're you're linked binary

00:19:25,809 --> 00:19:29,950
just keeps growing because you keep

00:19:27,249 --> 00:19:32,649
importing more and more stuff so if you

00:19:29,950 --> 00:19:35,769
code for interfaces then you have a way

00:19:32,649 --> 00:19:38,200
to say I expect something of a certain

00:19:35,769 --> 00:19:40,389
type but you don't have to import

00:19:38,200 --> 00:19:42,369
anything from the other package so you

00:19:40,389 --> 00:19:45,159
basically don't have any dependency on

00:19:42,369 --> 00:19:45,710
any other thing as long as things have

00:19:45,159 --> 00:19:49,279
same

00:19:45,710 --> 00:19:53,120
same name same arguments so what

00:19:49,279 --> 00:19:54,919
happened here this is code the the

00:19:53,120 --> 00:19:57,620
source code changed a little bit from

00:19:54,919 --> 00:20:00,529
from what is in master now but it's a

00:19:57,620 --> 00:20:03,380
code on the next HTTP library which is

00:20:00,529 --> 00:20:08,600
both an HTTP server and Initiative P

00:20:03,380 --> 00:20:13,159
client and it had here a a to large

00:20:08,600 --> 00:20:19,340
method that before before this change it

00:20:13,159 --> 00:20:22,309
referred here to to a type response but

00:20:19,340 --> 00:20:25,820
this was only used on the the response

00:20:22,309 --> 00:20:29,899
is is defined as part of the part of the

00:20:25,820 --> 00:20:34,130
server server side of code but this too

00:20:29,899 --> 00:20:35,500
large thing is only used sorry so let's

00:20:34,130 --> 00:20:42,110
try again

00:20:35,500 --> 00:20:46,130
it used to depend on on a type that is

00:20:42,110 --> 00:20:48,799
only used well that is defined on the

00:20:46,130 --> 00:20:53,419
server but only only necessary for for

00:20:48,799 --> 00:20:57,559
if you are using the the HTTP server

00:20:53,419 --> 00:20:59,870
part of the library right and now with

00:20:57,559 --> 00:21:03,200
this little magic here you declare an

00:20:59,870 --> 00:21:05,360
inline interface and say you know I

00:21:03,200 --> 00:21:07,850
don't depend on that type specifically I

00:21:05,360 --> 00:21:10,909
just need something that has a request

00:21:07,850 --> 00:21:13,250
to large method and suddenly you don't

00:21:10,909 --> 00:21:16,899
depend so suddenly this method don't

00:21:13,250 --> 00:21:19,640
depend on that package again anymore so

00:21:16,899 --> 00:21:21,500
it basically allows you to split parts

00:21:19,640 --> 00:21:24,169
and they don't need to know about each

00:21:21,500 --> 00:21:26,960
other and the way how you can keep them

00:21:24,169 --> 00:21:30,740
in sync is you can make the tests depend

00:21:26,960 --> 00:21:33,679
on the on the other library that you're

00:21:30,740 --> 00:21:35,659
trying to to follow the interface and

00:21:33,679 --> 00:21:38,720
you can make sure that they they always

00:21:35,659 --> 00:21:41,029
return the same compatible things so

00:21:38,720 --> 00:21:42,770
yeah that's a rather advanced example

00:21:41,029 --> 00:21:44,630
but for me like it's just really

00:21:42,770 --> 00:21:47,960
interesting and I just wanted to share

00:21:44,630 --> 00:21:49,399
it with you so if we talk about the art

00:21:47,960 --> 00:21:51,500
of communicating through symbols ideas

00:21:49,399 --> 00:21:54,230
about reality again for me the best way

00:21:51,500 --> 00:21:57,440
to express reality is through automated

00:21:54,230 --> 00:21:59,330
tests and that's the the last point I'll

00:21:57,440 --> 00:22:02,630
talk about today

00:21:59,330 --> 00:22:06,380
testing Ingo is a success story it's

00:22:02,630 --> 00:22:08,690
really good there is a framework built

00:22:06,380 --> 00:22:10,670
in into the standard library and there

00:22:08,690 --> 00:22:12,620
is a command called go test which is

00:22:10,670 --> 00:22:17,240
again part of the - when you install go

00:22:12,620 --> 00:22:19,370
in your machine and now connecting back

00:22:17,240 --> 00:22:21,830
with the the points that we said we

00:22:19,370 --> 00:22:25,490
talked about errors being values and

00:22:21,830 --> 00:22:28,480
there being no exceptions normally when

00:22:25,490 --> 00:22:31,340
you have exceptions there is a norm

00:22:28,480 --> 00:22:32,990
unwritten rule that you say when you're

00:22:31,340 --> 00:22:36,770
writing unit tests you want to have one

00:22:32,990 --> 00:22:38,690
assertion per per test method right and

00:22:36,770 --> 00:22:40,870
the reason why we say that and we will

00:22:38,690 --> 00:22:44,210
follow that best practice is because

00:22:40,870 --> 00:22:46,310
normally an error happens in your code

00:22:44,210 --> 00:22:48,740
because there is some exception and when

00:22:46,310 --> 00:22:51,590
the exception happens your test code

00:22:48,740 --> 00:22:53,690
loses control so all the framework can

00:22:51,590 --> 00:22:55,910
do is capture the exception and then

00:22:53,690 --> 00:22:58,430
report the test fail so if you had

00:22:55,910 --> 00:23:01,280
several assertions in the same method

00:22:58,430 --> 00:23:04,220
you've only ever run the first one right

00:23:01,280 --> 00:23:08,060
in go because there is no exceptions and

00:23:04,220 --> 00:23:10,100
errors are just values all of that is

00:23:08,060 --> 00:23:13,490
not true anymore and you can design a

00:23:10,100 --> 00:23:15,890
test framework differently so the way it

00:23:13,490 --> 00:23:18,890
works with the test framework in go is

00:23:15,890 --> 00:23:21,350
that you can mark test as failed but the

00:23:18,890 --> 00:23:23,840
execution may continue so you can have

00:23:21,350 --> 00:23:26,630
several checks in the same method and

00:23:23,840 --> 00:23:29,300
all of the checks get reported and this

00:23:26,630 --> 00:23:31,880
allows to do things like table driven

00:23:29,300 --> 00:23:35,260
tests and the example here is that you

00:23:31,880 --> 00:23:37,670
define what is the input and output for

00:23:35,260 --> 00:23:40,810
your test this is also taken from the

00:23:37,670 --> 00:23:43,550
gold standard library is how to test I

00:23:40,810 --> 00:23:47,120
think this is a string to integer

00:23:43,550 --> 00:23:50,030
conversion you know just create a table

00:23:47,120 --> 00:23:52,670
you just create a list of inputs and

00:23:50,030 --> 00:23:56,020
outputs and this list here is huge so

00:23:52,670 --> 00:23:58,910
you just set out a lot of expected

00:23:56,020 --> 00:24:01,310
input/output cases and then when it

00:23:58,910 --> 00:24:03,020
comes to the test function you just need

00:24:01,310 --> 00:24:05,510
to write it once and again you just use

00:24:03,020 --> 00:24:07,610
the language you use for loops which is

00:24:05,510 --> 00:24:10,600
what you use every other day to do any

00:24:07,610 --> 00:24:13,750
other thing use for test too

00:24:10,600 --> 00:24:16,450
and you basically range over all of

00:24:13,750 --> 00:24:19,000
those tests in the table and you just

00:24:16,450 --> 00:24:21,130
need to check once you run your function

00:24:19,000 --> 00:24:26,799
so the case here is your running parts

00:24:21,130 --> 00:24:29,650
integer from an input in base 10 and you

00:24:26,799 --> 00:24:31,690
get an output and an error so if the

00:24:29,650 --> 00:24:33,880
output doesn't match the expected output

00:24:31,690 --> 00:24:36,910
or if the error doesn't match the

00:24:33,880 --> 00:24:38,890
expected error you just report to the

00:24:36,910 --> 00:24:40,660
test framework an error but execution

00:24:38,890 --> 00:24:42,730
continues you're going to always run

00:24:40,660 --> 00:24:44,860
through all the test cases and your gut

00:24:42,730 --> 00:24:48,970
you're gonna get a report and now all

00:24:44,860 --> 00:24:52,290
the ears so that that's pretty cool

00:24:48,970 --> 00:24:55,510
again it makes testing real lightweight

00:24:52,290 --> 00:24:58,030
and it just makes it very easy to add

00:24:55,510 --> 00:25:01,630
new tests you just need to add like a

00:24:58,030 --> 00:25:04,360
simple line to the table with a new

00:25:01,630 --> 00:25:06,520
input new output so if you get for

00:25:04,360 --> 00:25:08,980
example bug report you don't need to

00:25:06,520 --> 00:25:10,960
copy/paste like a huge chunk of code and

00:25:08,980 --> 00:25:14,380
repeat it and hope that it's not

00:25:10,960 --> 00:25:18,190
repeated somewhere else already so it's

00:25:14,380 --> 00:25:20,740
really easy to keep things tidy yeah and

00:25:18,190 --> 00:25:24,850
the go-to in particular the go test to

00:25:20,740 --> 00:25:27,840
gives you yet a lot more that I miss in

00:25:24,850 --> 00:25:31,210
other languages I feel like it's a shame

00:25:27,840 --> 00:25:34,090
this didn't spread out yet and that's

00:25:31,210 --> 00:25:37,179
the availability of benchmarks so you

00:25:34,090 --> 00:25:40,299
can write benchmarks to test if your

00:25:37,179 --> 00:25:43,600
implementation is for example degrading

00:25:40,299 --> 00:25:45,520
is if your performance is degrading from

00:25:43,600 --> 00:25:47,049
one release to another or if you want to

00:25:45,520 --> 00:25:49,450
compare two implementations of an

00:25:47,049 --> 00:25:51,010
algorithm you can write benchmarks it

00:25:49,450 --> 00:25:53,530
allows you to do CPU and memory

00:25:51,010 --> 00:25:56,320
profiling right out of the box you don't

00:25:53,530 --> 00:25:58,600
need to install any plugin nothing you

00:25:56,320 --> 00:26:01,510
get very nice like web interface or

00:25:58,600 --> 00:26:03,940
console interface whatever you like it

00:26:01,510 --> 00:26:06,280
allows you to do tracing mutex

00:26:03,940 --> 00:26:09,429
contention so many things there is a

00:26:06,280 --> 00:26:12,070
race detector so if you're enjoying

00:26:09,429 --> 00:26:14,830
doing concurrent programming if you're

00:26:12,070 --> 00:26:16,480
crazy enough you've got tools actually

00:26:14,830 --> 00:26:19,570
to help you should help you find

00:26:16,480 --> 00:26:22,059
problems in your code and again that

00:26:19,570 --> 00:26:24,820
that's very good to have in the language

00:26:22,059 --> 00:26:26,680
so I took here one

00:26:24,820 --> 00:26:29,950
from Rob Pike one of the outers of the

00:26:26,680 --> 00:26:33,250
language and he said that the goal

00:26:29,950 --> 00:26:36,640
language was an attempt to get a safe

00:26:33,250 --> 00:26:38,800
and performant language that is too

00:26:36,640 --> 00:26:40,930
expressive and fun to use

00:26:38,800 --> 00:26:43,540
right it's convenient and fun to use

00:26:40,930 --> 00:26:46,710
personally I think that's true it's a

00:26:43,540 --> 00:26:50,140
language that have pleasure coding in I

00:26:46,710 --> 00:26:53,200
hope I'm not the only one I'm sure I'm

00:26:50,140 --> 00:26:55,450
not the only one and yeah I think that

00:26:53,200 --> 00:26:59,140
that's that's basically the success

00:26:55,450 --> 00:27:02,260
story of go ten years and we keep going

00:26:59,140 --> 00:27:06,580
so just to recap things we talked about

00:27:02,260 --> 00:27:09,280
simplicity I valued that a lot whenever

00:27:06,580 --> 00:27:12,520
I look at another language is it simple

00:27:09,280 --> 00:27:14,920
does it fit my brain goal does go has

00:27:12,520 --> 00:27:17,320
great tooling in fact a lot of languages

00:27:14,920 --> 00:27:21,850
are learning lessons and doing things

00:27:17,320 --> 00:27:23,560
like go format or equivalent it helps

00:27:21,850 --> 00:27:26,040
you think upfront about layers so I

00:27:23,560 --> 00:27:30,490
think it's also somehow a good practice

00:27:26,040 --> 00:27:33,970
allows you to compose abstractions with

00:27:30,490 --> 00:27:38,020
interfaces that again allows it to do

00:27:33,970 --> 00:27:39,670
like very nice things and all we know it

00:27:38,020 --> 00:27:42,040
empowers us to communicate through

00:27:39,670 --> 00:27:44,800
symbols ideas about reality that's

00:27:42,040 --> 00:27:48,820
that's what I take for go that's what go

00:27:44,800 --> 00:27:52,060
is for me yeah thank you

00:27:48,820 --> 00:27:52,060

YouTube URL: https://www.youtube.com/watch?v=9n2YUCwDGFA


