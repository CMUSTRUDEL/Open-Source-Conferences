Title: Function Composition - Bristol JS - November 2019
Publication date: 2019-12-21
Playlist: Bristol JS
Description: 
	Composing small bits of easy-to-understand code is one of the most important skills you can develop as a programmer. This talk will cover the more general concept of composition in programming and then focus on function composition in the more technical sense.

About Mark

Mark is the Curriculum Director and an instructor on the DevelopMe_ web development bootcamp. In his spare time he writes Haskell apps and is the creator of taskell - a sort of Trello for the command-line.

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,060 --> 00:00:10,820
I'm muck I don't have any social media

00:00:05,400 --> 00:00:13,740
accounts or anything follow me here

00:00:10,820 --> 00:00:19,279
hire a private investigator if you want

00:00:13,740 --> 00:00:21,480
to follow me I guess um I'd so I'm a

00:00:19,279 --> 00:00:24,779
Haskell developer that's what I tell

00:00:21,480 --> 00:00:26,220
myself if that's true or not it's for

00:00:24,779 --> 00:00:28,410
others to decide I'd also like to

00:00:26,220 --> 00:00:32,790
apologize in advance I've basically not

00:00:28,410 --> 00:00:36,829
slept for about a week so apologies in

00:00:32,790 --> 00:00:36,829
advance if nothing I say makes sense

00:00:36,860 --> 00:00:46,710
that's just an excuse so Adam said I

00:00:44,550 --> 00:00:49,610
might have to do some shameless

00:00:46,710 --> 00:00:53,250
self-promotion shameless self-promotion

00:00:49,610 --> 00:00:56,850
so I work for a company called developed

00:00:53,250 --> 00:01:00,000
me about half of the people here have

00:00:56,850 --> 00:01:02,789
already done our course so speaking to

00:01:00,000 --> 00:01:06,030
the converted um if you want to learn

00:01:02,789 --> 00:01:07,380
web development you're probably already

00:01:06,030 --> 00:01:10,229
doing it but if you want to learn even

00:01:07,380 --> 00:01:12,270
more do look us up also we're interested

00:01:10,229 --> 00:01:14,509
in looking at people who could

00:01:12,270 --> 00:01:19,799
potentially teach for us at the moment

00:01:14,509 --> 00:01:23,430
the syllabus is JavaScript and laravel

00:01:19,799 --> 00:01:27,600
mostly so yeah so PHP mostly using

00:01:23,430 --> 00:01:30,630
laravel so if that's stuff you've got

00:01:27,600 --> 00:01:32,880
expertise in and you might like to teach

00:01:30,630 --> 00:01:35,130
on the course at some point I do just

00:01:32,880 --> 00:01:38,159
drop me a line at market development

00:01:35,130 --> 00:01:39,689
Tech um we might not have places but

00:01:38,159 --> 00:01:41,400
immediately but like if you're

00:01:39,689 --> 00:01:48,600
interested just at any point in the

00:01:41,400 --> 00:01:50,340
future to get in touch great also so

00:01:48,600 --> 00:01:52,740
this is how I can call myself a Haskell

00:01:50,340 --> 00:01:54,170
developer I felt a little command line

00:01:52,740 --> 00:01:58,380
app called

00:01:54,170 --> 00:02:01,500
Haskell and it's basically Trello but on

00:01:58,380 --> 00:02:03,390
the command line so if you love you've

00:02:01,500 --> 00:02:05,070
in key bindings and you live in the

00:02:03,390 --> 00:02:07,799
terminal which is where I spend most of

00:02:05,070 --> 00:02:11,360
my time now you can have Trello without

00:02:07,799 --> 00:02:14,300
having to go to some awful website

00:02:11,360 --> 00:02:18,160
I love Trello it's one of my favorite

00:02:14,300 --> 00:02:22,760
websites like um that command line

00:02:18,160 --> 00:02:26,180
that's what I waste my time doing so a

00:02:22,760 --> 00:02:31,240
long time ago I did a talk at Bristol

00:02:26,180 --> 00:02:34,760
yes it was roughly three years ago and

00:02:31,240 --> 00:02:36,530
month or two later Adam I joined the

00:02:34,760 --> 00:02:39,110
Bristol day a slack channel I think it's

00:02:36,530 --> 00:02:41,690
fairly new at the time and Adam sent me

00:02:39,110 --> 00:02:45,290
a message saying did I want to give a

00:02:41,690 --> 00:02:48,950
talk so Adam I literally just gave a

00:02:45,290 --> 00:02:52,910
talk like last month so I said one talk

00:02:48,950 --> 00:03:00,980
every three years is quite enough hook

00:02:52,910 --> 00:03:03,320
me in for December 2019 which he did so

00:03:00,980 --> 00:03:07,910
this event has been on meetup for three

00:03:03,320 --> 00:03:09,530
years we've been having to update the

00:03:07,910 --> 00:03:11,990
title of it over the years because I'm

00:03:09,530 --> 00:03:13,250
meet over just says November and so

00:03:11,990 --> 00:03:16,850
people have been signing up for this

00:03:13,250 --> 00:03:20,350
event since we basically put it up as

00:03:16,850 --> 00:03:24,230
anyone been signed up for it since 2016

00:03:20,350 --> 00:03:29,600
okay thanks

00:03:24,230 --> 00:03:31,489
I admire your commitment so yeah I'm

00:03:29,600 --> 00:03:37,640
kind of only doing this talk as a as a

00:03:31,489 --> 00:03:41,110
running joke apologies if it's not very

00:03:37,640 --> 00:03:47,180
good so in those three years I got a cat

00:03:41,110 --> 00:03:51,280
I have a son now he didn't exist few

00:03:47,180 --> 00:03:54,100
years ago I became the second highest

00:03:51,280 --> 00:03:57,560
trending Haskell developer in the world

00:03:54,100 --> 00:04:00,500
to do that just write a Haskell project

00:03:57,560 --> 00:04:02,060
that gets 20 stars in their day the

00:04:00,500 --> 00:04:03,560
secret to getting higher up here is to

00:04:02,060 --> 00:04:07,580
use a programming language that no one

00:04:03,560 --> 00:04:14,269
else uses except for Facebook apparently

00:04:07,580 --> 00:04:16,780
but who's heard of them so I also said

00:04:14,269 --> 00:04:18,560
I've been teaching for develop me for

00:04:16,780 --> 00:04:20,510
three and a half years now but I

00:04:18,560 --> 00:04:22,010
actually six months ago got a job with

00:04:20,510 --> 00:04:22,820
them that's on now the curriculum

00:04:22,010 --> 00:04:28,540
directory

00:04:22,820 --> 00:04:28,540
this is our sixth cohort I'm all happy

00:04:28,940 --> 00:04:33,920
unfortunally also wrote this talk three

00:04:31,520 --> 00:04:37,250
years ago so hopefully it's still

00:04:33,920 --> 00:04:40,040
relevant three years ago I gave a talk

00:04:37,250 --> 00:04:42,700
about functional programming I'm gonna

00:04:40,040 --> 00:04:45,800
be talk about function composition I

00:04:42,700 --> 00:04:50,300
decided to talk about this about a year

00:04:45,800 --> 00:04:53,140
ago I guess and it was having taught a

00:04:50,300 --> 00:04:56,990
lot of people how to program JavaScript

00:04:53,140 --> 00:04:58,970
and I realized that this is something

00:04:56,990 --> 00:05:01,610
that actually comes up again and again

00:04:58,970 --> 00:05:03,950
and again in their curriculum in sort of

00:05:01,610 --> 00:05:05,870
different ways sometimes they call

00:05:03,950 --> 00:05:09,850
different things but sort of the

00:05:05,870 --> 00:05:14,000
underlying idea just keeps on coming up

00:05:09,850 --> 00:05:15,620
so the first thing says you already know

00:05:14,000 --> 00:05:17,090
a lot of the stuff I'm going to tell you

00:05:15,620 --> 00:05:19,490
I don't think I'm going to be telling

00:05:17,090 --> 00:05:21,020
you the stuff near the end maybe if we

00:05:19,490 --> 00:05:23,180
get on to that where it gets a bit

00:05:21,020 --> 00:05:24,770
technical maybe that's that's new a lot

00:05:23,180 --> 00:05:27,050
of this stuff so I'm gonna tell you I I

00:05:24,770 --> 00:05:30,890
suspect you probably already saw of know

00:05:27,050 --> 00:05:32,270
deep down in your heart of hearts so

00:05:30,890 --> 00:05:36,400
it's kind of more just sort of

00:05:32,270 --> 00:05:38,810
encouraging you to live live that life

00:05:36,400 --> 00:05:47,750
embrace function composition like you

00:05:38,810 --> 00:05:51,080
know you really should so on the course

00:05:47,750 --> 00:05:52,880
I teach these five weeks of the course

00:05:51,080 --> 00:05:55,550
it's 12-week course I teach these folks

00:05:52,880 --> 00:05:58,070
just seems like a big long thing this

00:05:55,550 --> 00:05:59,420
does tie in so I teach the fundamental

00:05:58,070 --> 00:06:01,340
programming so that's when people first

00:05:59,420 --> 00:06:03,920
sort of learn and we use JavaScript to

00:06:01,340 --> 00:06:06,770
teach that I teach the Dom I teach

00:06:03,920 --> 00:06:09,200
object-oriented programming with PHP and

00:06:06,770 --> 00:06:12,260
then we do react and redux at the end of

00:06:09,200 --> 00:06:14,540
the course and as I say it was teaching

00:06:12,260 --> 00:06:16,670
these weeks of the course that I

00:06:14,540 --> 00:06:17,900
realized that this this thing comes up

00:06:16,670 --> 00:06:21,460
again and again

00:06:17,900 --> 00:06:24,110
so with fundamentals of programming

00:06:21,460 --> 00:06:25,670
functions we learn about function then

00:06:24,110 --> 00:06:29,600
we use functions all the time if you

00:06:25,670 --> 00:06:32,360
want to do a bit of code again and again

00:06:29,600 --> 00:06:33,130
then that's what a function if you

00:06:32,360 --> 00:06:35,500
probably

00:06:33,130 --> 00:06:38,680
aware of that um will pretend that I

00:06:35,500 --> 00:06:40,780
don't teach the dorm um doesn't really

00:06:38,680 --> 00:06:45,070
come up in the dorm object-oriented

00:06:40,780 --> 00:06:46,540
programming so the solid principles if

00:06:45,070 --> 00:06:49,870
anyone's done a lot of object-oriented

00:06:46,540 --> 00:06:52,090
programming then those are things you're

00:06:49,870 --> 00:06:54,910
probably aware of single responsibility

00:06:52,090 --> 00:06:56,290
stuff like that again some function

00:06:54,910 --> 00:06:57,990
composition the ideas of function

00:06:56,290 --> 00:07:02,410
composition to come up a lot in

00:06:57,990 --> 00:07:05,440
object-oriented programming in react we

00:07:02,410 --> 00:07:07,990
use components and again function

00:07:05,440 --> 00:07:10,870
composition and components really key

00:07:07,990 --> 00:07:14,410
ideas and with redux

00:07:10,870 --> 00:07:17,920
we have reduces and again it's it's all

00:07:14,410 --> 00:07:19,330
about function composition really so

00:07:17,920 --> 00:07:21,070
what do I mean when I'm talking about

00:07:19,330 --> 00:07:23,170
function composition so at the moment

00:07:21,070 --> 00:07:25,060
I'm talking about it in sort of not

00:07:23,170 --> 00:07:28,810
technical terms I'm using the term

00:07:25,060 --> 00:07:30,580
really quite loosely if there is time at

00:07:28,810 --> 00:07:32,860
the end I will briefly talk about sort

00:07:30,580 --> 00:07:35,500
of technically what function composition

00:07:32,860 --> 00:07:38,310
means there is a sort of is the Haskell

00:07:35,500 --> 00:07:41,560
come function composition stuff but um

00:07:38,310 --> 00:07:47,200
for now I'm just using it fairly loosely

00:07:41,560 --> 00:07:49,600
um and all I really mean is right little

00:07:47,200 --> 00:07:51,580
short functions that do one thing well

00:07:49,600 --> 00:07:52,870
and then just use them in your app

00:07:51,580 --> 00:07:56,910
that's all I'm saying

00:07:52,870 --> 00:07:59,350
and as I say you already know to do that

00:07:56,910 --> 00:08:02,290
but the simple fact is I bet a lot of

00:07:59,350 --> 00:08:05,320
you probably don't do that I say all the

00:08:02,290 --> 00:08:09,370
time I write these big messy functions

00:08:05,320 --> 00:08:11,320
and you know I'll often react but um

00:08:09,370 --> 00:08:16,450
the simple fact is often we do just

00:08:11,320 --> 00:08:20,710
quite big am off functions that aren't

00:08:16,450 --> 00:08:23,440
actually very nice um so why why is it a

00:08:20,710 --> 00:08:26,560
good idea to write small reusable

00:08:23,440 --> 00:08:28,240
functions so the thing that all of those

00:08:26,560 --> 00:08:32,950
have in common is they're effectively

00:08:28,240 --> 00:08:36,969
black boxes so I'm sure you've all heard

00:08:32,950 --> 00:08:39,430
the term black box before but the idea

00:08:36,969 --> 00:08:42,339
is that we we know what the inputs are

00:08:39,430 --> 00:08:44,740
and we know what we expect the output to

00:08:42,339 --> 00:08:45,660
be but fundamentally we don't need to

00:08:44,740 --> 00:08:48,589
know

00:08:45,660 --> 00:08:51,779
see how it does that if we have a number

00:08:48,589 --> 00:08:54,449
sorry a function for example that we

00:08:51,779 --> 00:08:56,970
pass it a number and it tells us if that

00:08:54,449 --> 00:08:59,370
number is prime or not we don't actually

00:08:56,970 --> 00:09:00,839
need to know how the function does that

00:08:59,370 --> 00:09:02,970
we just need to know that the function

00:09:00,839 --> 00:09:06,180
works like we can assume that the

00:09:02,970 --> 00:09:07,579
function works that it's been passed as

00:09:06,180 --> 00:09:11,069
long as we know that the functions work

00:09:07,579 --> 00:09:12,480
we can just give it an input and as long

00:09:11,069 --> 00:09:15,060
as we know what the outputs meant to be

00:09:12,480 --> 00:09:19,170
we'll get back so as well as long as

00:09:15,060 --> 00:09:21,420
it's well-documented black box is a

00:09:19,170 --> 00:09:23,670
great way of working and I say these

00:09:21,420 --> 00:09:25,860
come up again and again and again so

00:09:23,670 --> 00:09:27,569
when we're using functions ideally we

00:09:25,860 --> 00:09:30,000
want functions that when we pass them

00:09:27,569 --> 00:09:32,160
some values the things that will get

00:09:30,000 --> 00:09:36,449
Mike are predictable results that they

00:09:32,160 --> 00:09:38,629
don't go and break things when we do

00:09:36,449 --> 00:09:41,850
object-oriented programming we want our

00:09:38,629 --> 00:09:44,370
objects that we use to be predictable we

00:09:41,850 --> 00:09:45,689
want them to accept certain methods and

00:09:44,370 --> 00:09:48,120
give us back certain sorts of results

00:09:45,689 --> 00:09:50,610
and not to just unexpectedly do other

00:09:48,120 --> 00:09:53,459
weird stuff when we're not when we

00:09:50,610 --> 00:09:55,290
haven't asked them to components and

00:09:53,459 --> 00:09:56,639
react the whole purpose of components is

00:09:55,290 --> 00:10:01,050
in reactors we can create these little

00:09:56,639 --> 00:10:03,269
reusable bits of view UI that we can

00:10:01,050 --> 00:10:05,850
then put anywhere in our app and they're

00:10:03,269 --> 00:10:10,110
just reusable and the smaller those are

00:10:05,850 --> 00:10:12,839
the more reusable and they become and in

00:10:10,110 --> 00:10:15,509
Redux we have reducers little bits of

00:10:12,839 --> 00:10:18,740
codes that update the state and again

00:10:15,509 --> 00:10:21,540
the smaller those are the more reusable

00:10:18,740 --> 00:10:26,639
they become so this concept of black

00:10:21,540 --> 00:10:30,209
boxes it's really important so there's

00:10:26,639 --> 00:10:32,939
this thing called galls law proposed by

00:10:30,209 --> 00:10:35,970
a chap called someone or of a Gaul mr.

00:10:32,939 --> 00:10:41,220
Gaul um I think he was a doctor he's a

00:10:35,970 --> 00:10:43,110
pediatrician and he studied systems and

00:10:41,220 --> 00:10:45,000
this quote come generators

00:10:43,110 --> 00:10:46,949
a complex system that works is

00:10:45,000 --> 00:10:50,279
invariably found to have evolved from a

00:10:46,949 --> 00:10:52,379
simple system that worked a complex

00:10:50,279 --> 00:10:54,809
system designed from scratch never works

00:10:52,379 --> 00:10:57,300
and can't be patched up to make it work

00:10:54,809 --> 00:11:00,120
you have to start over with a working

00:10:57,300 --> 00:11:03,180
simple system this is sort of the key

00:11:00,120 --> 00:11:06,870
idea that I want to get if we build our

00:11:03,180 --> 00:11:09,120
programs of small little things that we

00:11:06,870 --> 00:11:11,190
know work well we can actually get a

00:11:09,120 --> 00:11:13,290
surprising amount of complexity from

00:11:11,190 --> 00:11:18,240
them when we know that each individual

00:11:13,290 --> 00:11:21,000
part works perfectly well so the idea is

00:11:18,240 --> 00:11:25,500
that we can get complexity from

00:11:21,000 --> 00:11:27,570
simplicity and that that's the only way

00:11:25,500 --> 00:11:30,660
that you should get complex apps by

00:11:27,570 --> 00:11:34,470
building up lots of simple things to

00:11:30,660 --> 00:11:38,370
create complex behaviors so it's kind of

00:11:34,470 --> 00:11:40,670
black box inception in a way and I found

00:11:38,370 --> 00:11:43,260
this nice little gift that doesn't

00:11:40,670 --> 00:11:48,480
really illustrate anything but I figured

00:11:43,260 --> 00:11:51,930
I should get there there's a gif and you

00:11:48,480 --> 00:11:54,540
say you already know this UNIX pipes I'm

00:11:51,930 --> 00:11:57,090
sure most people have probably used

00:11:54,540 --> 00:11:59,040
pipes in Unix maybe not fully knowing

00:11:57,090 --> 00:12:01,320
what they do but the sort of UNIX

00:11:59,040 --> 00:12:03,720
philosophy is you write small little

00:12:01,320 --> 00:12:07,140
bits of code that just do a single thing

00:12:03,720 --> 00:12:09,030
and then you can use pipes to get the

00:12:07,140 --> 00:12:11,460
output of one to go into the output of

00:12:09,030 --> 00:12:13,680
the next one so this is one I use all

00:12:11,460 --> 00:12:16,650
the time so when I'm teaching I have a

00:12:13,680 --> 00:12:20,010
little script file sorry your scripts

00:12:16,650 --> 00:12:22,080
folder even where all my little notes

00:12:20,010 --> 00:12:23,970
that I'm working from free today in

00:12:22,080 --> 00:12:25,050
little markdown files and at the

00:12:23,970 --> 00:12:26,430
beginning of the week I just need to

00:12:25,050 --> 00:12:28,830
print all of those out so I've got

00:12:26,430 --> 00:12:31,380
something to work from and so I just do

00:12:28,830 --> 00:12:34,140
cat scripts mdns it's gonna find all of

00:12:31,380 --> 00:12:36,720
the markdown files and then I piped that

00:12:34,140 --> 00:12:40,110
into PB copy which just adds it to the

00:12:36,720 --> 00:12:41,550
clipboard on the Mac and then I can just

00:12:40,110 --> 00:12:46,470
paste that into an app and I've suddenly

00:12:41,550 --> 00:12:48,270
got all of them in a single file this is

00:12:46,470 --> 00:12:50,820
a slightly more involved one so we list

00:12:48,270 --> 00:12:52,620
all the files we then use grep to find

00:12:50,820 --> 00:12:54,930
all of the ones that have all because if

00:12:52,620 --> 00:12:56,940
they have August in the date then we

00:12:54,930 --> 00:12:59,010
sort by the date column and then we

00:12:56,940 --> 00:13:02,760
output that using less so that we can

00:12:59,010 --> 00:13:05,130
see lots of lines of code without it all

00:13:02,760 --> 00:13:07,350
running off the screen so again this is

00:13:05,130 --> 00:13:09,300
function composition we're listing some

00:13:07,350 --> 00:13:10,800
files we then take the output of that

00:13:09,300 --> 00:13:14,339
and pass it

00:13:10,800 --> 00:13:15,959
to grep we then output that to sort and

00:13:14,339 --> 00:13:19,529
then that to less we're just combining

00:13:15,959 --> 00:13:24,209
simple things to get much more complex

00:13:19,529 --> 00:13:26,940
behaviour um so I've already covered

00:13:24,209 --> 00:13:30,779
this there's something thing why do we

00:13:26,940 --> 00:13:33,060
want to do this so I mean the first

00:13:30,779 --> 00:13:36,510
reason is that brains are unlimited

00:13:33,060 --> 00:13:38,820
there's that famous pop psychology thing

00:13:36,510 --> 00:13:42,149
that brains can remember seven plus or

00:13:38,820 --> 00:13:44,760
minus two chunks of data whatever a

00:13:42,149 --> 00:13:46,800
chunk is I don't know if that was being

00:13:44,760 --> 00:13:50,070
disproved most psychology has nowadays

00:13:46,800 --> 00:13:53,399
but um you know the general idea is your

00:13:50,070 --> 00:13:55,230
memory is not very good I had someone on

00:13:53,399 --> 00:13:58,140
the last course put the hand up as I was

00:13:55,230 --> 00:14:01,079
sort of explaining some quite in-depth

00:13:58,140 --> 00:14:06,540
dumb thing and he was like do we have to

00:14:01,079 --> 00:14:09,779
remember everything about good lord no

00:14:06,540 --> 00:14:11,190
like I mean as a developer I can't

00:14:09,779 --> 00:14:13,620
remember muster code that I wrote let

00:14:11,190 --> 00:14:15,089
alone other people like that's why we

00:14:13,620 --> 00:14:16,529
have documentation and that's why black

00:14:15,089 --> 00:14:18,480
boxes are so important because we don't

00:14:16,529 --> 00:14:21,390
need to know how the things work we just

00:14:18,480 --> 00:14:22,829
need to know what they do and it's

00:14:21,390 --> 00:14:24,540
because our brains are limited like we

00:14:22,829 --> 00:14:27,209
don't we shouldn't need to remember how

00:14:24,540 --> 00:14:29,730
everything works and function

00:14:27,209 --> 00:14:33,480
composition can that help us a lot to

00:14:29,730 --> 00:14:35,130
get around this problem the other thing

00:14:33,480 --> 00:14:37,649
is if you've got small little functions

00:14:35,130 --> 00:14:41,430
that do one thing well you'll never need

00:14:37,649 --> 00:14:45,180
to change those bits of code so Sandi

00:14:41,430 --> 00:14:45,600
Metz people heard of Sandi Metz show of

00:14:45,180 --> 00:14:49,170
hands

00:14:45,600 --> 00:14:51,149
Sandi yes she haven't heard of Sandi

00:14:49,170 --> 00:14:52,709
Metz and you're doing any sort of

00:14:51,149 --> 00:14:53,910
object-oriented programming or just

00:14:52,709 --> 00:14:56,940
programming generally you should look

00:14:53,910 --> 00:15:00,060
her up she is life changing

00:14:56,940 --> 00:15:03,329
I honestly changed how I program after I

00:15:00,060 --> 00:15:04,980
read her book which all the Ruby people

00:15:03,329 --> 00:15:07,529
called poodle I call it poo doctor

00:15:04,980 --> 00:15:11,279
because it's funny which is practical

00:15:07,529 --> 00:15:12,839
object-oriented design in Ruby so it's

00:15:11,279 --> 00:15:14,399
about Ruby but it's it's really about

00:15:12,839 --> 00:15:18,320
object-oriented programming and how to

00:15:14,399 --> 00:15:20,640
do it well and she talks about sort of

00:15:18,320 --> 00:15:23,440
we often talk about code being elegant

00:15:20,640 --> 00:15:24,910
and Sandi Metz as the elegant code

00:15:23,440 --> 00:15:26,889
is code that can be changed easily

00:15:24,910 --> 00:15:30,970
because actually most of your time as a

00:15:26,889 --> 00:15:32,259
developer changing code and so if you

00:15:30,970 --> 00:15:33,550
using function composition properly

00:15:32,259 --> 00:15:35,410
you're going to have lots of bits of

00:15:33,550 --> 00:15:36,819
code that you will never need to change

00:15:35,410 --> 00:15:38,800
again you can just use them again and

00:15:36,819 --> 00:15:42,579
again and again and that makes changing

00:15:38,800 --> 00:15:44,290
other bits of your code much easier so

00:15:42,579 --> 00:15:47,139
function composition can really help

00:15:44,290 --> 00:15:48,699
with change ability um I say if you've

00:15:47,139 --> 00:15:50,680
not heard of Sandi Metz do look her up

00:15:48,699 --> 00:15:53,620
on YouTube and watch every single video

00:15:50,680 --> 00:15:55,779
that she's ever done because she's been

00:15:53,620 --> 00:15:57,250
doing it since she was like working with

00:15:55,779 --> 00:15:58,810
small talk the very original

00:15:57,250 --> 00:16:01,329
object-oriented programming language and

00:15:58,810 --> 00:16:02,829
has been doing object-oriented

00:16:01,329 --> 00:16:05,230
programming basically as long as it's

00:16:02,829 --> 00:16:07,889
possible to do it she she really knows

00:16:05,230 --> 00:16:11,290
what she's talking about

00:16:07,889 --> 00:16:12,610
so another thing it makes unit testing

00:16:11,290 --> 00:16:15,040
really easy if your codes made up of

00:16:12,610 --> 00:16:16,569
lots of small units you can test those

00:16:15,040 --> 00:16:19,180
units really easily without having to

00:16:16,569 --> 00:16:20,410
rely on more complicated things to do

00:16:19,180 --> 00:16:21,910
with the environment or what the

00:16:20,410 --> 00:16:25,509
program's actually trying to do you can

00:16:21,910 --> 00:16:26,800
just test individual functions see that

00:16:25,509 --> 00:16:28,420
they do the thing they're meant to do

00:16:26,800 --> 00:16:30,670
and then you don't need to worry about

00:16:28,420 --> 00:16:32,589
it again you know if you've got a

00:16:30,670 --> 00:16:35,529
function that works for telling you if a

00:16:32,589 --> 00:16:37,269
prime number is a prime number you'd

00:16:35,529 --> 00:16:41,050
never need to change that again it just

00:16:37,269 --> 00:16:43,209
works and unit testing that is

00:16:41,050 --> 00:16:47,259
relatively easy as well so those are

00:16:43,209 --> 00:16:50,350
free reasons to think about it so it's

00:16:47,259 --> 00:16:51,939
all about reuse and again this is stuff

00:16:50,350 --> 00:16:53,170
everyone knows this this is stuff

00:16:51,939 --> 00:16:56,579
everyone knows you should write short

00:16:53,170 --> 00:16:58,779
functions we should reuse them and

00:16:56,579 --> 00:17:02,189
that's how we're gonna build stuff so

00:16:58,779 --> 00:17:06,250
I'm gonna give a couple of examples that

00:17:02,189 --> 00:17:07,659
have come up through the teaching stuff

00:17:06,250 --> 00:17:09,339
I've done as well because it turns out

00:17:07,659 --> 00:17:15,339
my students are much better this than I

00:17:09,339 --> 00:17:17,740
am so this is a max function in

00:17:15,339 --> 00:17:19,480
JavaScript so we pass it to numbers and

00:17:17,740 --> 00:17:22,329
it just gives us back which of those

00:17:19,480 --> 00:17:24,250
numbers is bigger and a lot of people

00:17:22,329 --> 00:17:27,539
probably wouldn't bother writing a max

00:17:24,250 --> 00:17:29,950
because it doesn't seem terribly useful

00:17:27,539 --> 00:17:31,720
you could probably just write the

00:17:29,950 --> 00:17:32,450
ternary expression wherever you needed

00:17:31,720 --> 00:17:36,559
it

00:17:32,450 --> 00:17:38,809
I don't need them at all so it kind of

00:17:36,559 --> 00:17:40,519
seems a tad on the points are the same

00:17:38,809 --> 00:17:41,809
with an odd function and then a function

00:17:40,519 --> 00:17:44,210
that takes two numbers and just adds

00:17:41,809 --> 00:17:46,879
those two numbers together you just use

00:17:44,210 --> 00:17:49,190
the plus operator um but it turns out

00:17:46,879 --> 00:17:54,009
this seemingly quite pointless function

00:17:49,190 --> 00:17:58,279
is actually very useful so one of the

00:17:54,009 --> 00:17:59,299
questions that the students get in of

00:17:58,279 --> 00:18:02,809
the day when they're learning about

00:17:59,299 --> 00:18:05,570
functions is write a function that takes

00:18:02,809 --> 00:18:07,159
three numbers as arguments so a B and C

00:18:05,570 --> 00:18:11,899
and just return which of those numbers

00:18:07,159 --> 00:18:13,489
is the biggest number so if we pass in

00:18:11,899 --> 00:18:19,879
one two and three you will get free back

00:18:13,489 --> 00:18:23,389
5 minus 5 0 will get 5 and my sort of

00:18:19,879 --> 00:18:25,789
the answer that I always gave them was

00:18:23,389 --> 00:18:27,559
this and I think this is probably what

00:18:25,789 --> 00:18:32,450
most people would like something like

00:18:27,559 --> 00:18:34,369
this you you take the three values you

00:18:32,450 --> 00:18:38,330
say if a is bigger than B and it's

00:18:34,369 --> 00:18:39,769
bigger than C then then it's a if B is

00:18:38,330 --> 00:18:41,779
bigger than a and it's bigger than C

00:18:39,769 --> 00:18:44,269
then you can return B it's not either of

00:18:41,779 --> 00:18:46,009
those then we can just return C don't

00:18:44,269 --> 00:18:49,609
need an else statement save ourselves a

00:18:46,009 --> 00:18:52,519
few lines of code and that is the

00:18:49,609 --> 00:18:56,869
example answer that I had in the notes

00:18:52,519 --> 00:18:58,519
for a number of years then one of the

00:18:56,869 --> 00:19:00,649
other instructors on the course oli

00:18:58,519 --> 00:19:04,970
pointed out actually we can simplify a

00:19:00,649 --> 00:19:09,259
bit we don't need the two checks on this

00:19:04,970 --> 00:19:10,820
line here we can just if we've got to

00:19:09,259 --> 00:19:12,830
this point then a can't be the biggest

00:19:10,820 --> 00:19:14,419
so we don't need to check if B is bigger

00:19:12,830 --> 00:19:17,480
than a because they can't be the biggest

00:19:14,419 --> 00:19:18,919
anyway so we can we can simplify it so

00:19:17,480 --> 00:19:21,679
and I thought that's not a nice thing

00:19:18,919 --> 00:19:24,470
we've made this code and then a couple

00:19:21,679 --> 00:19:26,450
of cohorts ago someone called Tom who'd

00:19:24,470 --> 00:19:29,899
literally been programming for two days

00:19:26,450 --> 00:19:31,489
at that point I asked has anyone done it

00:19:29,899 --> 00:19:33,080
I always like get them to put their code

00:19:31,489 --> 00:19:36,139
up on I always say has anyone done it

00:19:33,080 --> 00:19:38,889
differently and he put his hand okay

00:19:36,139 --> 00:19:41,820
what have you done and he puts that up

00:19:38,889 --> 00:19:45,239
and I'm right

00:19:41,820 --> 00:19:45,869
that's so much simpler than what I've

00:19:45,239 --> 00:19:49,109
done

00:19:45,869 --> 00:19:51,539
he's I mentioned function composition

00:19:49,109 --> 00:19:54,539
and he took it seriously he he spent the

00:19:51,539 --> 00:19:56,399
time and he noticed that if you already

00:19:54,539 --> 00:19:57,899
have a function called max that you can

00:19:56,399 --> 00:20:00,659
pass two numbers and get back the

00:19:57,899 --> 00:20:03,960
biggest number then you can write one

00:20:00,659 --> 00:20:06,389
called max free where you just first get

00:20:03,960 --> 00:20:08,909
the biggest number of a and B and that's

00:20:06,389 --> 00:20:11,129
either going to return a or B depending

00:20:08,909 --> 00:20:12,989
on which one is bigger and then just do

00:20:11,129 --> 00:20:15,599
max of whatever you get back from that

00:20:12,989 --> 00:20:19,799
and C and you get exactly the same thing

00:20:15,599 --> 00:20:22,309
but the code is so much and this is

00:20:19,799 --> 00:20:24,509
function composition of previously

00:20:22,309 --> 00:20:27,629
fairly pointless looking function

00:20:24,509 --> 00:20:30,749
actually becomes very useful I know that

00:20:27,629 --> 00:20:32,700
this is a really simple example you

00:20:30,749 --> 00:20:35,879
might think this isn't the sort of thing

00:20:32,700 --> 00:20:37,889
you have to do all that often um but you

00:20:35,879 --> 00:20:43,320
know I need to use fairly simple things

00:20:37,889 --> 00:20:44,940
to illustrate my point so a related

00:20:43,320 --> 00:20:47,450
thing if you've got an array of numbers

00:20:44,940 --> 00:20:49,769
and you want to find the biggest number

00:20:47,450 --> 00:20:51,599
this is another challenge that I set

00:20:49,769 --> 00:20:52,739
them they'll normally come up with

00:20:51,599 --> 00:20:55,799
something like this to start with

00:20:52,739 --> 00:20:58,080
earlier to for loop get the first value

00:20:55,799 --> 00:21:00,179
to start with go over each one and just

00:20:58,080 --> 00:21:02,009
say if the current value is bigger just

00:21:00,179 --> 00:21:06,720
keep track of that and then at the end

00:21:02,009 --> 00:21:08,669
of it you know seems nice and simple I

00:21:06,720 --> 00:21:11,519
then teach them about array iterator

00:21:08,669 --> 00:21:14,429
methods and so they use reduce instead

00:21:11,519 --> 00:21:15,989
if you're trying to get an array down to

00:21:14,429 --> 00:21:17,609
a single value you should use reduce

00:21:15,989 --> 00:21:21,629
it's nice functional way of doing things

00:21:17,609 --> 00:21:25,739
your codes much tidier and they'll write

00:21:21,629 --> 00:21:27,599
something like this normally and then i

00:21:25,739 --> 00:21:29,909
point out what you've actually got here

00:21:27,599 --> 00:21:33,450
is a function that takes two values and

00:21:29,909 --> 00:21:34,950
if the first value is sorry the second

00:21:33,450 --> 00:21:37,590
value is bigger than the first value you

00:21:34,950 --> 00:21:40,529
return that of wise you return the first

00:21:37,590 --> 00:21:42,269
value so you have here a function that

00:21:40,529 --> 00:21:44,789
takes two numbers and gives you back the

00:21:42,269 --> 00:21:47,789
biggest of those two numbers so what you

00:21:44,789 --> 00:21:50,580
have here is the max function so using a

00:21:47,789 --> 00:21:53,369
bit of functional programming we've

00:21:50,580 --> 00:21:55,080
already got the max function we can just

00:21:53,369 --> 00:21:55,740
reduce it down to the single line of

00:21:55,080 --> 00:21:58,080
code here

00:21:55,740 --> 00:22:01,410
it is exactly the same thing as that six

00:21:58,080 --> 00:22:03,480
or seven line falling before and it sort

00:22:01,410 --> 00:22:06,270
of almost reads is what its gonna give

00:22:03,480 --> 00:22:10,580
you you're taking some values and you're

00:22:06,270 --> 00:22:13,410
getting the maximum value out of them so

00:22:10,580 --> 00:22:14,880
this seemingly not very useful form can

00:22:13,410 --> 00:22:17,850
actually you can use it all over the

00:22:14,880 --> 00:22:22,530
place and that's true of all sorts of

00:22:17,850 --> 00:22:26,940
functions so another use case for this

00:22:22,530 --> 00:22:30,840
sort of stuff is Redux reducers if

00:22:26,940 --> 00:22:32,940
you've not used Redux much then the

00:22:30,840 --> 00:22:35,429
basic idea is that you get past the

00:22:32,940 --> 00:22:38,010
current state of the application and an

00:22:35,429 --> 00:22:40,650
action depending on what the action is

00:22:38,010 --> 00:22:44,400
you then do stuff to state just to

00:22:40,650 --> 00:22:47,580
change some value inside it this is from

00:22:44,400 --> 00:22:50,400
the ping pong scoring app that we create

00:22:47,580 --> 00:22:52,770
if the player one action is fired then

00:22:50,400 --> 00:22:55,470
we want to just add one to play a one

00:22:52,770 --> 00:22:58,440
score and then give that back to player

00:22:55,470 --> 00:23:00,480
to action then we want to add player one

00:22:58,440 --> 00:23:02,940
to player two and then return that

00:23:00,480 --> 00:23:04,559
updated state so this this works and

00:23:02,940 --> 00:23:08,429
that's normally what people come up with

00:23:04,559 --> 00:23:10,110
I then as the next challenge ask them

00:23:08,429 --> 00:23:13,500
okay now you need to keep track of who's

00:23:10,110 --> 00:23:15,780
serving so every time someone scores

00:23:13,500 --> 00:23:17,960
you're gonna have to work out if the

00:23:15,780 --> 00:23:22,380
server's change them up so every five

00:23:17,960 --> 00:23:23,929
serves this server changes and what most

00:23:22,380 --> 00:23:26,640
people end up writing is something

00:23:23,929 --> 00:23:29,280
something like this so they're going to

00:23:26,640 --> 00:23:31,110
update their player one function because

00:23:29,280 --> 00:23:34,440
it has to run when the player one or the

00:23:31,110 --> 00:23:36,600
player to action fires so they need to

00:23:34,440 --> 00:23:38,160
get this so player one is serving they

00:23:36,600 --> 00:23:40,170
then get the score they need to make

00:23:38,160 --> 00:23:41,820
sure they've got the latest score so

00:23:40,170 --> 00:23:43,800
they add one to the player one score

00:23:41,820 --> 00:23:46,200
they then work out if the server does

00:23:43,800 --> 00:23:48,480
need to change and then if the server is

00:23:46,200 --> 00:23:50,850
changing they flip whether player one

00:23:48,480 --> 00:23:54,740
serving the value of that otherwise they

00:23:50,850 --> 00:23:57,870
just keep it as it is and they update

00:23:54,740 --> 00:23:59,220
and that will work that's fine I mean a

00:23:57,870 --> 00:24:01,230
bit of a problem is you're gonna have to

00:23:59,220 --> 00:24:03,900
repeat a lot of the same logic for

00:24:01,230 --> 00:24:07,450
player two it's going to be largely the

00:24:03,900 --> 00:24:11,510
same but it works and that's fine

00:24:07,450 --> 00:24:11,930
but I would say if it works don't touch

00:24:11,510 --> 00:24:13,940
it

00:24:11,930 --> 00:24:16,400
if you've got a function that works it

00:24:13,940 --> 00:24:19,850
does something well leave it alone use

00:24:16,400 --> 00:24:21,410
function composition instead and you can

00:24:19,850 --> 00:24:23,930
do that by doing something like this so

00:24:21,410 --> 00:24:25,850
we keep the player 1 and the player 2

00:24:23,930 --> 00:24:29,990
functions exactly as they are they just

00:24:25,850 --> 00:24:32,240
add one to the relevant players score to

00:24:29,990 --> 00:24:35,060
work out the server we take the state

00:24:32,240 --> 00:24:36,980
again we get the total of the two

00:24:35,060 --> 00:24:39,740
players scores see if they're divisible

00:24:36,980 --> 00:24:41,600
by five if they're not I would just keep

00:24:39,740 --> 00:24:44,330
the same state a server hasn't changed

00:24:41,600 --> 00:24:46,640
if they are divisible by five then we

00:24:44,330 --> 00:24:49,760
just change the player one serving and

00:24:46,640 --> 00:24:51,740
then to get that to work we just use

00:24:49,760 --> 00:24:54,260
function composition so player one

00:24:51,740 --> 00:24:56,840
function gets called and we pass it the

00:24:54,260 --> 00:24:59,540
state that then returns the state which

00:24:56,840 --> 00:25:02,090
then gets passed into server which then

00:24:59,540 --> 00:25:04,220
has the updated scores and then updates

00:25:02,090 --> 00:25:05,870
the state it's necessary and then what

00:25:04,220 --> 00:25:07,970
you get back from that is the fully

00:25:05,870 --> 00:25:10,580
updated state that's got the server

00:25:07,970 --> 00:25:12,770
stuff and the player one stuff the nice

00:25:10,580 --> 00:25:13,970
thing is we've not had to change the

00:25:12,770 --> 00:25:16,570
functions that work we've got nice

00:25:13,970 --> 00:25:20,090
simple functions that we're composing

00:25:16,570 --> 00:25:22,340
together and the nice thing about that

00:25:20,090 --> 00:25:24,410
is it scales really well you now want

00:25:22,340 --> 00:25:27,920
the next challenge you now need to know

00:25:24,410 --> 00:25:29,300
if someone's won or not so again we're

00:25:27,920 --> 00:25:30,710
going to have to update something in the

00:25:29,300 --> 00:25:33,170
state to keep track of that most

00:25:30,710 --> 00:25:35,330
people's initial reaction go back in and

00:25:33,170 --> 00:25:37,370
update the serving one or the player one

00:25:35,330 --> 00:25:39,860
one or the player two but again we can

00:25:37,370 --> 00:25:43,280
use function composition so we have one

00:25:39,860 --> 00:25:45,410
that just takes the state again if it's

00:25:43,280 --> 00:25:48,050
over 21 then we can say player one as

00:25:45,410 --> 00:25:51,440
one if not then we say if player two is

00:25:48,050 --> 00:25:53,060
over 21 davon otherwise nobody's won and

00:25:51,440 --> 00:25:56,630
then again we just wrapped the whole

00:25:53,060 --> 00:25:58,940
thing here so we get the state and then

00:25:56,630 --> 00:26:01,310
player one that's going to update the

00:25:58,940 --> 00:26:03,110
score we then pass the state immediately

00:26:01,310 --> 00:26:05,600
to the server function which updates the

00:26:03,110 --> 00:26:07,190
story server if necessary and then we

00:26:05,600 --> 00:26:09,950
pass that to the winner which again

00:26:07,190 --> 00:26:15,230
updates the winner if necessary and all

00:26:09,950 --> 00:26:18,950
of our functions are nice and simple so

00:26:15,230 --> 00:26:21,059
how can use of get towards code like

00:26:18,950 --> 00:26:23,409
this

00:26:21,059 --> 00:26:24,969
so I mean these aren't hard and fast

00:26:23,409 --> 00:26:26,619
rules they're just sort of if you do

00:26:24,969 --> 00:26:28,869
these things you'll probably find it a

00:26:26,619 --> 00:26:31,629
bit easier so the first one is to write

00:26:28,869 --> 00:26:33,909
pure functions so that means functions

00:26:31,629 --> 00:26:35,769
that if you give them the same arguments

00:26:33,909 --> 00:26:37,869
you get back the same results and they

00:26:35,769 --> 00:26:40,570
don't change anything else if you write

00:26:37,869 --> 00:26:42,849
largely pure functions you're gonna find

00:26:40,570 --> 00:26:44,590
function composition much easier because

00:26:42,849 --> 00:26:48,669
you can reuse those functions any way

00:26:44,590 --> 00:26:50,409
you like the other thing is if you treat

00:26:48,669 --> 00:26:52,570
everything as an expression so in

00:26:50,409 --> 00:26:54,549
Haskell the language that I mostly write

00:26:52,570 --> 00:26:56,409
in there you don't have statements

00:26:54,549 --> 00:26:58,929
everything is an expression everything

00:26:56,409 --> 00:27:01,719
equates to a value and if you think that

00:26:58,929 --> 00:27:05,200
way you don't use if statements or

00:27:01,719 --> 00:27:08,499
anything like that it forces you to

00:27:05,200 --> 00:27:09,940
write much more composable code because

00:27:08,499 --> 00:27:11,799
you will end up writing lots of much

00:27:09,940 --> 00:27:13,299
smaller functions and then you'll

00:27:11,799 --> 00:27:15,899
discover that you can then reuse those

00:27:13,299 --> 00:27:18,759
functions in lots of different places

00:27:15,899 --> 00:27:20,589
I'd say it unless it's dumb you can't

00:27:18,759 --> 00:27:22,659
really do this with DOM because Dom is

00:27:20,589 --> 00:27:25,179
very much just property base and they

00:27:22,659 --> 00:27:26,769
don't return values so if you're doing

00:27:25,179 --> 00:27:32,019
Dom so if you'll want to use some sort

00:27:26,769 --> 00:27:33,999
of library to do that the functions

00:27:32,019 --> 00:27:36,879
purpose shouldn't contain the word and

00:27:33,999 --> 00:27:38,979
so if I say what does this function do

00:27:36,879 --> 00:27:41,979
and you say well it does this and it

00:27:38,979 --> 00:27:43,389
does that you've just there got two

00:27:41,979 --> 00:27:46,149
functions that you should compose

00:27:43,389 --> 00:27:48,669
together rather than having one function

00:27:46,149 --> 00:27:50,169
split up for two different things and

00:27:48,669 --> 00:27:52,899
now you've probably got code that's

00:27:50,169 --> 00:27:57,159
going to be much easier to make changes

00:27:52,899 --> 00:27:58,330
to later on when you're doing this

00:27:57,159 --> 00:28:00,129
you're going to end up with way more

00:27:58,330 --> 00:28:02,320
functions than you probably had before

00:28:00,129 --> 00:28:04,330
so named functions or methods if you're

00:28:02,320 --> 00:28:05,799
doing object-oriented programming name

00:28:04,330 --> 00:28:07,570
them sensibly if you don't name them

00:28:05,799 --> 00:28:09,339
sensibly it's going to be very hard to

00:28:07,570 --> 00:28:11,999
do anything put them in sensibly named

00:28:09,339 --> 00:28:15,210
modules give the function sensible names

00:28:11,999 --> 00:28:18,969
that can be hard naming is is difficult

00:28:15,210 --> 00:28:22,450
but do try and name them sensibly and

00:28:18,969 --> 00:28:24,009
the final thing is just avoid anonymous

00:28:22,450 --> 00:28:25,269
functions so when you're using anonymous

00:28:24,009 --> 00:28:28,450
functions at the moment think about

00:28:25,269 --> 00:28:30,460
pulling it out into a variable give it a

00:28:28,450 --> 00:28:31,570
name and you might discover that you've

00:28:30,460 --> 00:28:32,190
actually got a function that does that

00:28:31,570 --> 00:28:35,100
like that

00:28:32,190 --> 00:28:36,360
max function you might write the reduced

00:28:35,100 --> 00:28:37,740
version way you've got biggest in

00:28:36,360 --> 00:28:39,299
current and then just realize actually

00:28:37,740 --> 00:28:42,120
that's a function that I've already got

00:28:39,299 --> 00:28:44,039
so if you don't use anonymous functions

00:28:42,120 --> 00:28:45,330
which is not always possible but it's

00:28:44,039 --> 00:28:48,419
generally possible

00:28:45,330 --> 00:28:50,009
90% of the time pull them out give them

00:28:48,419 --> 00:28:53,570
a sensible name and you'll probably

00:28:50,009 --> 00:28:57,960
discover but again can you get much more

00:28:53,570 --> 00:29:00,620
composable code so I do have some slides

00:28:57,960 --> 00:29:02,669
about the sort of technical aspect of

00:29:00,620 --> 00:29:06,450
function composition but I've been

00:29:02,669 --> 00:29:12,629
talking for 30 minutes so I'm not going

00:29:06,450 --> 00:29:14,490
to cover that so it's just about sort of

00:29:12,629 --> 00:29:16,200
the more mathematical side of it

00:29:14,490 --> 00:29:20,700
I don't anyone really wants to be doing

00:29:16,200 --> 00:29:22,740
this at 7 o'clock in the evening and if

00:29:20,700 --> 00:29:29,789
you would like to go through that stuff

00:29:22,740 --> 00:29:33,659
there is the slides are online small

00:29:29,789 --> 00:29:38,009
Agron Collider /function composition you

00:29:33,659 --> 00:29:40,830
can talk to me in the break if you want

00:29:38,009 --> 00:29:59,610
to talk more about that stuff and if

00:29:40,830 --> 00:30:01,139
anyone has questions well that's nice

00:29:59,610 --> 00:30:04,139
for you at composition you can break it

00:30:01,139 --> 00:30:06,059
up into smaller parts so I'm not getting

00:30:04,139 --> 00:30:07,379
on to the technical thing so the

00:30:06,059 --> 00:30:09,649
technical thing I wanted to show you is

00:30:07,379 --> 00:30:15,210
you can have this function here compose

00:30:09,649 --> 00:30:17,179
which looks like madness on stills if

00:30:15,210 --> 00:30:21,470
you can work out what that does then

00:30:17,179 --> 00:30:25,139
well then um it's it's a crazy thing but

00:30:21,470 --> 00:30:27,480
very nice and what it lets you do is

00:30:25,139 --> 00:30:29,370
basically once you've got that in your

00:30:27,480 --> 00:30:32,490
code base this is always like the first

00:30:29,370 --> 00:30:34,230
line in my JavaScript code bases I often

00:30:32,490 --> 00:30:35,490
put it as underscore because it's

00:30:34,230 --> 00:30:39,540
something that I you

00:30:35,490 --> 00:30:41,670
so much you can then take any old

00:30:39,540 --> 00:30:43,740
functions and then you can compose them

00:30:41,670 --> 00:30:45,210
together so you can say weird because

00:30:43,740 --> 00:30:46,230
this is a bit of a weird function to be

00:30:45,210 --> 00:30:48,060
honest weird

00:30:46,230 --> 00:30:50,280
equals the composition of the max

00:30:48,060 --> 00:30:52,650
function followed by the times free

00:30:50,280 --> 00:30:54,810
function followed by the square function

00:30:52,650 --> 00:30:56,850
and now you have a function that when

00:30:54,810 --> 00:30:59,670
you pass it two numbers first it gets

00:30:56,850 --> 00:31:01,620
the max of those two numbers then it x

00:30:59,670 --> 00:31:03,690
is that number by three and then it

00:31:01,620 --> 00:31:05,820
squares that number and what you'll get

00:31:03,690 --> 00:31:09,540
back is the result of those free

00:31:05,820 --> 00:31:11,130
operations so the first thing in the

00:31:09,540 --> 00:31:13,560
composition can take as many arguments

00:31:11,130 --> 00:31:15,900
as you like all the others just take the

00:31:13,560 --> 00:31:17,820
return value of the previous one and

00:31:15,900 --> 00:31:21,470
it's kind of backwards so does this one

00:31:17,820 --> 00:31:25,050
first and then that one and that one

00:31:21,470 --> 00:31:26,460
once you've got a compose function and

00:31:25,050 --> 00:31:29,820
as I say I'd only have it as like

00:31:26,460 --> 00:31:31,920
underscore you can then so Redux if you

00:31:29,820 --> 00:31:33,900
doing stuff with Redux that's based on

00:31:31,920 --> 00:31:41,490
Elm and Elm was based on Haskell so

00:31:33,900 --> 00:31:43,050
unsurprisingly composition you can write

00:31:41,490 --> 00:31:45,360
something like this you can say compose

00:31:43,050 --> 00:31:47,970
winner server player one and then you

00:31:45,360 --> 00:31:50,640
can just call that P one function down

00:31:47,970 --> 00:31:52,380
here which keeps that a bit shorter but

00:31:50,640 --> 00:31:56,250
you'll notice here we're composing

00:31:52,380 --> 00:31:57,810
winner and server both times and so we

00:31:56,250 --> 00:31:59,520
could actually pull that out into a

00:31:57,810 --> 00:32:02,100
function that just as those two things

00:31:59,520 --> 00:32:03,750
and then compose that function with the

00:32:02,100 --> 00:32:05,190
player one and player two functions and

00:32:03,750 --> 00:32:07,680
you might discover that this is actually

00:32:05,190 --> 00:32:09,810
then usable elsewhere and you almost

00:32:07,680 --> 00:32:11,280
certainly will the nice thing about

00:32:09,810 --> 00:32:12,900
function composition is the second you

00:32:11,280 --> 00:32:15,600
start doing it you will find your

00:32:12,900 --> 00:32:17,490
functions oh I can use this oh I can use

00:32:15,600 --> 00:32:19,260
this here and you'll suddenly just

00:32:17,490 --> 00:32:21,390
discover that things that you previously

00:32:19,260 --> 00:32:27,900
thought that's not very useful but I'll

00:32:21,390 --> 00:32:29,940
do it anyway so I mean as I have school

00:32:27,900 --> 00:32:32,730
develop panella usually everything I

00:32:29,940 --> 00:32:34,950
write is composition now this is an

00:32:32,730 --> 00:32:38,220
example of some of the tassel code base

00:32:34,950 --> 00:32:39,600
like this is probably the bit of task

00:32:38,220 --> 00:32:42,750
all that does all of the work this is

00:32:39,600 --> 00:32:46,650
basically saying when they click on the

00:32:42,750 --> 00:32:48,660
new key story create a new item

00:32:46,650 --> 00:32:54,120
and start editing it right it's all just

00:32:48,660 --> 00:32:55,980
the dot in Haskell is composition so all

00:32:54,120 --> 00:32:57,720
of the behavior of my app is written

00:32:55,980 --> 00:33:00,090
basically in a single file that's just

00:32:57,720 --> 00:33:03,380
composing lots of individual functions

00:33:00,090 --> 00:33:06,750
together when a key is pressed I think

00:33:03,380 --> 00:33:08,190
so I mean you know you can know if

00:33:06,750 --> 00:33:10,560
they're sensibly named you can almost

00:33:08,190 --> 00:33:14,840
read it as what it is which is really

00:33:10,560 --> 00:33:17,520
nice so you can never have too much

00:33:14,840 --> 00:33:19,740
there may be performance reasons for not

00:33:17,520 --> 00:33:21,420
doing fracturing composition if you're

00:33:19,740 --> 00:33:24,480
writing a game and it needs to run at 60

00:33:21,420 --> 00:33:26,340
frames per second maybe don't use this

00:33:24,480 --> 00:33:28,170
stuff quite so much because it can lead

00:33:26,340 --> 00:33:32,940
to garbage collection and stuff like

00:33:28,170 --> 00:33:56,940
that but third sort of regular apps

00:33:32,940 --> 00:34:00,660
which is what most people are yeah so

00:33:56,940 --> 00:34:03,780
Ram de which is the one that when I gave

00:34:00,660 --> 00:34:07,500
a talk careers ago was also the library

00:34:03,780 --> 00:34:10,200
that I recommended at the time Randa it

00:34:07,500 --> 00:34:11,760
has the compose function built in I did

00:34:10,200 --> 00:34:12,990
quite a lot of those sort of libraries

00:34:11,760 --> 00:34:15,720
you know things that underscore and

00:34:12,990 --> 00:34:19,290
lodash north of us off they often have a

00:34:15,720 --> 00:34:20,520
compose function built in they often

00:34:19,290 --> 00:34:23,940
have compose function but they also

00:34:20,520 --> 00:34:27,030
include your base functions like Max and

00:34:23,940 --> 00:34:28,290
AD and stuff like that so if you've got

00:34:27,030 --> 00:34:30,360
one of those libraries you can save

00:34:28,290 --> 00:34:31,980
yourself a huge amount of time because

00:34:30,360 --> 00:34:33,679
they've worked out what a lot of the

00:34:31,980 --> 00:34:35,640
functions that you will use all the time

00:34:33,679 --> 00:34:40,940
and just put it in one place with

00:34:35,640 --> 00:34:40,940

YouTube URL: https://www.youtube.com/watch?v=HIYrzYcf3SY


