Title: Bristol JS, Server Sent Events, January 2018
Publication date: 2018-02-10
Playlist: Bristol JS
Description: 
	Overview of the Server-Sent Events API, which is a lightweight alternative to WebSockets.

More about Bristol JS: https://www.meetup.com/BristolJS/
Captions: 
	00:00:00,060 --> 00:00:07,200
hello everyone so today I'm gonna talk

00:00:04,620 --> 00:00:10,050
about server-sent events which is

00:00:07,200 --> 00:00:12,690
handling events in JavaScript on the

00:00:10,050 --> 00:00:17,250
client site where the events literally

00:00:12,690 --> 00:00:20,460
happen on the server my name is Cornell

00:00:17,250 --> 00:00:23,070
ocinski you might know me from apps like

00:00:20,460 --> 00:00:26,010
imageoptim and image optimization in

00:00:23,070 --> 00:00:30,260
general but I also do JavaScript not

00:00:26,010 --> 00:00:33,870
just images so that's why today's talk

00:00:30,260 --> 00:00:37,649
server sent events is now kind of old

00:00:33,870 --> 00:00:40,230
API it's older than its competitor

00:00:37,649 --> 00:00:43,620
WebSockets it's and I've been I've been

00:00:40,230 --> 00:00:48,420
involved in designing the API at what

00:00:43,620 --> 00:00:52,920
working group what while ago so let's

00:00:48,420 --> 00:00:56,460
just start you probably know the Ajax

00:00:52,920 --> 00:00:59,780
the XML HTTP request which is simple

00:00:56,460 --> 00:01:03,510
just downloading a single file over HTTP

00:00:59,780 --> 00:01:07,049
on the other end of the spectrum we have

00:01:03,510 --> 00:01:10,380
WebSockets which is a completely custom

00:01:07,049 --> 00:01:12,540
protocol with a dedication permanent

00:01:10,380 --> 00:01:17,119
connection to the server where you can

00:01:12,540 --> 00:01:21,930
exchange messages in two directions

00:01:17,119 --> 00:01:24,530
however between those two between just a

00:01:21,930 --> 00:01:27,810
simple download on a HTTP connection and

00:01:24,530 --> 00:01:31,680
full-blown custom protocol there can be

00:01:27,810 --> 00:01:34,920
a simpler alternative which is server

00:01:31,680 --> 00:01:38,549
sent events server sent events started

00:01:34,920 --> 00:01:42,540
as as a hack it used to be called comet

00:01:38,549 --> 00:01:44,520
or long polling where instead of

00:01:42,540 --> 00:01:47,970
downloading a file from the server

00:01:44,520 --> 00:01:50,880
immediately the server wouldn't respond

00:01:47,970 --> 00:01:54,240
until something happened so to the

00:01:50,880 --> 00:01:56,579
browser it looks like the file is just

00:01:54,240 --> 00:01:58,619
taking a very very long time to respond

00:01:56,579 --> 00:02:01,110
but the server is deliberately not

00:01:58,619 --> 00:02:04,560
responding until it has something to say

00:02:01,110 --> 00:02:06,240
to the client and then it sends the rest

00:02:04,560 --> 00:02:09,720
of the message and closes connection so

00:02:06,240 --> 00:02:14,040
that was long polling and this sort of a

00:02:09,720 --> 00:02:17,909
hack got fully standardized

00:02:14,040 --> 00:02:19,500
into server-sent events API and even

00:02:17,909 --> 00:02:21,900
extended that not only you just send one

00:02:19,500 --> 00:02:24,150
thing in close connection but the server

00:02:21,900 --> 00:02:29,030
can keep responding and responding and

00:02:24,150 --> 00:02:32,519
responding on the same HTTP connection

00:02:29,030 --> 00:02:35,269
what would you use it for for example

00:02:32,519 --> 00:02:37,769
you can implement your own slack clone

00:02:35,269 --> 00:02:41,219
server sent events is just from the

00:02:37,769 --> 00:02:43,769
server down to the client so if you want

00:02:41,219 --> 00:02:46,260
to send a message to the server you

00:02:43,769 --> 00:02:49,290
still have to use the classic Ajax

00:02:46,260 --> 00:02:53,010
request or a forum or whatever you use

00:02:49,290 --> 00:02:56,939
to communicate with the server up to the

00:02:53,010 --> 00:02:59,189
cloud but then with server sent events

00:02:56,939 --> 00:03:00,780
you can make all the clients all the

00:02:59,189 --> 00:03:02,790
other windows all the other users

00:03:00,780 --> 00:03:05,400
everyone else

00:03:02,790 --> 00:03:07,349
subscribe to listening to this events

00:03:05,400 --> 00:03:09,000
that happen on the server so the server

00:03:07,349 --> 00:03:10,859
can say hey there's a new message

00:03:09,000 --> 00:03:15,209
there's a notification there something

00:03:10,859 --> 00:03:19,199
happened and then all the clients will

00:03:15,209 --> 00:03:21,870
immediately in real-time get get the

00:03:19,199 --> 00:03:24,810
message you can observe logs on the

00:03:21,870 --> 00:03:28,049
server in real-time and probably the

00:03:24,810 --> 00:03:30,829
biggest users user of the server sent

00:03:28,049 --> 00:03:33,180
events API specifically is github I

00:03:30,829 --> 00:03:35,760
don't know if you notice but if you keep

00:03:33,180 --> 00:03:38,549
a github window open and a push new

00:03:35,760 --> 00:03:40,650
branch to the repository that message

00:03:38,549 --> 00:03:44,849
will pop up automatically you don't have

00:03:40,650 --> 00:03:46,769
to refresh github.com will detect that

00:03:44,849 --> 00:03:48,780
you've pushed to your git repository

00:03:46,769 --> 00:03:51,479
using command-line git or any

00:03:48,780 --> 00:03:53,790
application or anything else and notify

00:03:51,479 --> 00:03:56,250
all your open browser windows in

00:03:53,790 --> 00:03:58,109
real-time that you've just created

00:03:56,250 --> 00:04:00,569
something that there are new files

00:03:58,109 --> 00:04:03,870
there's new new branch or that you've

00:04:00,569 --> 00:04:06,569
posted a comment and it pops

00:04:03,870 --> 00:04:08,609
automatically because github it uses

00:04:06,569 --> 00:04:10,650
server sent events and makes all your

00:04:08,609 --> 00:04:14,340
browser windows always subscribe to

00:04:10,650 --> 00:04:21,329
events that happen on the web server on

00:04:14,340 --> 00:04:25,560
the web server from the client-side it's

00:04:21,329 --> 00:04:26,340
it's a very minimal API there's

00:04:25,560 --> 00:04:27,090
eventsource

00:04:26,340 --> 00:04:30,720
construct

00:04:27,090 --> 00:04:34,250
so you subscribe to a stream of events

00:04:30,720 --> 00:04:38,340
giving URL on the server I'll briefly

00:04:34,250 --> 00:04:40,980
shortly describe how to what descend

00:04:38,340 --> 00:04:44,160
from that URL but you'll create your own

00:04:40,980 --> 00:04:45,840
server-side endpoint for messages on the

00:04:44,160 --> 00:04:48,240
client-side you just subscribe to that

00:04:45,840 --> 00:04:52,110
endpoint and you get a source of end

00:04:48,240 --> 00:04:55,260
object and it will fire a message event

00:04:52,110 --> 00:04:57,540
event every time the server send says

00:04:55,260 --> 00:05:00,600
there's something new that happens and

00:04:57,540 --> 00:05:03,450
you'll get event data which is arbitrary

00:05:00,600 --> 00:05:07,860
string usually you can just send a

00:05:03,450 --> 00:05:11,010
string of json and decode that json from

00:05:07,860 --> 00:05:15,600
the server there's also a bit more that

00:05:11,010 --> 00:05:17,490
you can that you can do but that's the

00:05:15,600 --> 00:05:24,150
basic if you just want to know something

00:05:17,490 --> 00:05:25,889
happened on the server now differences

00:05:24,150 --> 00:05:32,850
between WebSocket and server sent events

00:05:25,889 --> 00:05:35,550
are mainly compatibility so service and

00:05:32,850 --> 00:05:37,770
WebSockets he used to sound like a nice

00:05:35,550 --> 00:05:41,700
solution a couple of years ago but I

00:05:37,770 --> 00:05:45,419
think happened HTTP 2 is now very common

00:05:41,700 --> 00:05:48,810
and it happens that WebSockets are not

00:05:45,419 --> 00:05:52,530
compatible with HTTP 2 WebSockets were a

00:05:48,810 --> 00:05:55,410
hack on top of HTTP 1 and that hack no

00:05:52,530 --> 00:05:58,289
longer works in HTTP 2 world however

00:05:55,410 --> 00:06:01,350
server sent events on the network level

00:05:58,289 --> 00:06:03,870
look like it's just a file download a

00:06:01,350 --> 00:06:09,690
regular file being downloaded just very

00:06:03,870 --> 00:06:13,650
slowly one line at a time so service and

00:06:09,690 --> 00:06:18,270
events continue to work with all web

00:06:13,650 --> 00:06:19,919
servers web proxies most CDNs everything

00:06:18,270 --> 00:06:23,820
is actually that you can just distribute

00:06:19,919 --> 00:06:26,840
a regular static file over then it also

00:06:23,820 --> 00:06:30,840
is most likely to be compatible with

00:06:26,840 --> 00:06:36,200
server sent events and compared to hacks

00:06:30,840 --> 00:06:38,640
built on things like XML HTTP request or

00:06:36,200 --> 00:06:40,380
never-ending iframes or slowly

00:06:38,640 --> 00:06:42,660
downloading scripts and so on

00:06:40,380 --> 00:06:44,700
it'sjust is that the browser no

00:06:42,660 --> 00:06:47,400
server-sent events are dedicated to

00:06:44,700 --> 00:06:49,920
sending of events from the server so it

00:06:47,400 --> 00:06:53,190
can be smarter about managing those

00:06:49,920 --> 00:06:55,050
connections avoiding blocking other HTTP

00:06:53,190 --> 00:06:58,710
traffic that would otherwise wait on

00:06:55,050 --> 00:07:05,070
that connection or reuse one connection

00:06:58,710 --> 00:07:09,260
across many event objects so what you're

00:07:05,070 --> 00:07:12,510
sending from the server is a text file

00:07:09,260 --> 00:07:15,900
you have to set mime type that's called

00:07:12,510 --> 00:07:19,530
text event stream and then the server

00:07:15,900 --> 00:07:22,890
sends a line starting with data column

00:07:19,530 --> 00:07:26,870
those five bytes are the entire overhead

00:07:22,890 --> 00:07:29,970
of your message so the protocol is

00:07:26,870 --> 00:07:31,890
actually quite efficient after that it's

00:07:29,970 --> 00:07:34,820
arbitrary data that you want it can be

00:07:31,890 --> 00:07:38,400
plain text it can be JSON string

00:07:34,820 --> 00:07:41,040
whatever you find convenient and the

00:07:38,400 --> 00:07:42,690
blank line blank lines and tells the

00:07:41,040 --> 00:07:44,670
brow browser

00:07:42,690 --> 00:07:50,940
I finished that's the whole set the

00:07:44,670 --> 00:07:54,930
whole message fire an event now so the

00:07:50,940 --> 00:07:56,990
cool thing is the whole protocol can be

00:07:54,930 --> 00:07:58,950
basically described on a single slide

00:07:56,990 --> 00:08:02,040
compared to WebSockets

00:07:58,950 --> 00:08:06,210
protocol which is a binary data protocol

00:08:02,040 --> 00:08:08,870
with special framing compression many

00:08:06,210 --> 00:08:12,480
other features which are like a 50-page

00:08:08,870 --> 00:08:15,450
spec so if you were if you were building

00:08:12,480 --> 00:08:17,970
a WebSocket server from scratch that's

00:08:15,450 --> 00:08:21,990
actually a huge challenge and a library

00:08:17,970 --> 00:08:25,050
and to use WebSockets on a client you'll

00:08:21,990 --> 00:08:27,540
also probably want want to have some

00:08:25,050 --> 00:08:30,570
kind of a library that adds sugar on top

00:08:27,540 --> 00:08:34,590
there on top of the raw API on the other

00:08:30,570 --> 00:08:38,099
hand service and events are just a plain

00:08:34,590 --> 00:08:40,740
text protocol sending line of simple

00:08:38,099 --> 00:08:43,320
instructions so I can it so I can tell

00:08:40,740 --> 00:08:47,730
you everything about the protocol right

00:08:43,320 --> 00:08:50,940
now so as I've mentioned every line

00:08:47,730 --> 00:08:53,600
starting with data is a bit of the event

00:08:50,940 --> 00:09:00,529
that you're sending you can

00:08:53,600 --> 00:09:02,389
sign and ID to every event if you can

00:09:00,529 --> 00:09:05,329
assign an ID the browser will remember

00:09:02,389 --> 00:09:10,730
the ID of the last message that it has

00:09:05,329 --> 00:09:12,949
seen so if the connection is lost the

00:09:10,730 --> 00:09:14,990
server will try the client the browser

00:09:12,949 --> 00:09:17,149
will try to reconnect the server and

00:09:14,990 --> 00:09:21,110
will tell you the ID of the last message

00:09:17,149 --> 00:09:22,940
that it saw this way your server can use

00:09:21,110 --> 00:09:26,000
some kind of a ID that you can get from

00:09:22,940 --> 00:09:28,250
a database or a timestamp or something

00:09:26,000 --> 00:09:31,699
like that and you keep track of how many

00:09:28,250 --> 00:09:33,589
messages the client has seen and in case

00:09:31,699 --> 00:09:36,620
of interrupted connection you can

00:09:33,589 --> 00:09:39,319
gracefully resume sending messages from

00:09:36,620 --> 00:09:43,959
where the browser lost connection this

00:09:39,319 --> 00:09:43,959
way you don't don't lose any messages

00:09:46,120 --> 00:09:53,120
and this also is robust against data

00:09:50,269 --> 00:09:55,579
loss you don't have to worry about user

00:09:53,120 --> 00:09:57,769
having a mobile connection and going

00:09:55,579 --> 00:09:59,389
through a tunnel it will lose connection

00:09:57,769 --> 00:10:03,019
but the browser will automatically

00:09:59,389 --> 00:10:05,750
reconnect tell you with I've last heard

00:10:03,019 --> 00:10:08,180
from you around that time and your

00:10:05,750 --> 00:10:10,600
server can read it and just resume as if

00:10:08,180 --> 00:10:10,600
nothing happened

00:10:10,899 --> 00:10:16,850
another client-side you don't even have

00:10:13,670 --> 00:10:18,470
to see those the IDS on the client-side

00:10:16,850 --> 00:10:20,420
the same event source object will just

00:10:18,470 --> 00:10:23,990
continue firing messages for you which

00:10:20,420 --> 00:10:26,480
is really nice as I mentioned the the

00:10:23,990 --> 00:10:28,370
browser will automatically retry

00:10:26,480 --> 00:10:31,850
connecting to the server in case the

00:10:28,370 --> 00:10:35,779
connection is closed and you can set

00:10:31,850 --> 00:10:38,990
delay in milliseconds how much is the

00:10:35,779 --> 00:10:42,920
browser should wait after before trying

00:10:38,990 --> 00:10:46,100
to reconnect it can be something like

00:10:42,920 --> 00:10:47,720
one second to be almost instant you can

00:10:46,100 --> 00:10:50,689
make it longer if you just want the

00:10:47,720 --> 00:10:52,610
browser to go away for example if you

00:10:50,689 --> 00:10:55,430
have too many users coming to your

00:10:52,610 --> 00:10:57,290
website at the same time and your web

00:10:55,430 --> 00:10:59,660
server just cannot handle so many

00:10:57,290 --> 00:11:03,350
connections you can tell them like go

00:10:59,660 --> 00:11:05,730
away wait 30 seconds I cannot serve you

00:11:03,350 --> 00:11:08,430
right now

00:11:05,730 --> 00:11:11,430
you can name your events by by default

00:11:08,430 --> 00:11:15,180
the source of event source object fires

00:11:11,430 --> 00:11:19,199
message event but if you want to be

00:11:15,180 --> 00:11:21,329
fancy and categorize your events into

00:11:19,199 --> 00:11:25,800
different types you can before sending

00:11:21,329 --> 00:11:29,339
data you can name your your event

00:11:25,800 --> 00:11:32,579
anything else this way for example you

00:11:29,339 --> 00:11:37,019
can have several components on your page

00:11:32,579 --> 00:11:38,910
share the same event stream but each

00:11:37,019 --> 00:11:43,079
component getting its own kind of a

00:11:38,910 --> 00:11:48,050
message or you can just keep sending the

00:11:43,079 --> 00:11:53,130
anonymous anonymous generic message and

00:11:48,050 --> 00:11:58,139
as a data use JSON string and identify

00:11:53,130 --> 00:12:01,170
what happened there in your own

00:11:58,139 --> 00:12:05,279
application specific way from the from

00:12:01,170 --> 00:12:06,630
the data itself as I mentioned if you're

00:12:05,279 --> 00:12:07,320
trying to decide whether you use

00:12:06,630 --> 00:12:09,750
WebSockets

00:12:07,320 --> 00:12:14,730
or server sent events it's mostly about

00:12:09,750 --> 00:12:18,389
simplicity and compatibility if you use

00:12:14,730 --> 00:12:20,399
WebSockets you might it might be so much

00:12:18,389 --> 00:12:23,459
hassle that you'll decide to outsource

00:12:20,399 --> 00:12:27,139
it to a third party company that

00:12:23,459 --> 00:12:27,139
probably happens to sponsor this meetup

00:12:29,750 --> 00:12:36,120
but server sent events are so simple

00:12:33,120 --> 00:12:38,940
that you can reasonably roll them out

00:12:36,120 --> 00:12:41,670
roll them out yourself and you don't

00:12:38,940 --> 00:12:44,010
even need library it's not like NPM

00:12:41,670 --> 00:12:47,000
install this special thing for server

00:12:44,010 --> 00:12:49,949
sent events if you're using nodejs it's

00:12:47,000 --> 00:12:56,579
literally sent set the content type and

00:12:49,949 --> 00:12:58,380
just keep sending lines of text in

00:12:56,579 --> 00:13:01,470
nodejs you don't even have to flush the

00:12:58,380 --> 00:13:03,300
connection it's different if you use

00:13:01,470 --> 00:13:06,139
another programming language or some

00:13:03,300 --> 00:13:11,120
kind of another interface that buffers

00:13:06,139 --> 00:13:11,120
and speaking of buffering

00:13:12,980 --> 00:13:17,990
that buffering is the most annoying

00:13:15,079 --> 00:13:22,550
thing about service and events when you

00:13:17,990 --> 00:13:25,970
try to deploy them so for example nginx

00:13:22,550 --> 00:13:28,639
a server by default will try to buffer 8

00:13:25,970 --> 00:13:32,290
kilobytes of data but if you're sending

00:13:28,639 --> 00:13:34,660
event that is just 100 bytes of data

00:13:32,290 --> 00:13:37,760
well it's gonna sit in the buffer

00:13:34,660 --> 00:13:40,220
waiting for more data to be sent

00:13:37,760 --> 00:13:42,740
eventually which is not good when you

00:13:40,220 --> 00:13:45,709
want to want this data to reach the

00:13:42,740 --> 00:13:49,100
browser immediately so specifically for

00:13:45,709 --> 00:13:51,230
nginx you can send a HTTP header that

00:13:49,100 --> 00:13:53,000
disables buffering or set a

00:13:51,230 --> 00:13:57,399
configuration option that disables

00:13:53,000 --> 00:14:01,370
buffering if you're using other proxy

00:13:57,399 --> 00:14:03,110
proxy servers like HTTP proxy or

00:14:01,370 --> 00:14:04,970
something like that check the

00:14:03,110 --> 00:14:07,130
documentation for your proxy if if

00:14:04,970 --> 00:14:10,220
messages are not arriving it is probably

00:14:07,130 --> 00:14:14,149
just you to do two buffering and in

00:14:10,220 --> 00:14:16,820
other languages like PHP you have to

00:14:14,149 --> 00:14:22,060
call a flush function that actually

00:14:16,820 --> 00:14:24,620
tells it to start sending data though I

00:14:22,060 --> 00:14:26,600
really recommend using node.js because

00:14:24,620 --> 00:14:35,750
if you're using PHP your server will

00:14:26,600 --> 00:14:38,329
look like that so the server sent events

00:14:35,750 --> 00:14:40,819
there is a permanent tcp/ip connection

00:14:38,329 --> 00:14:43,940
open for every visitor of your website

00:14:40,819 --> 00:14:45,740
so if hundreds people are visiting your

00:14:43,940 --> 00:14:47,300
website at the same time you will have

00:14:45,740 --> 00:14:49,730
hundreds connections and if those people

00:14:47,300 --> 00:14:51,350
open through win three browser windows

00:14:49,730 --> 00:14:53,540
at the same time you will have 300

00:14:51,350 --> 00:14:55,610
connections so with something like

00:14:53,540 --> 00:14:59,269
nodejs not a problem at all you can have

00:14:55,610 --> 00:15:03,980
10,000 connections and they'll be

00:14:59,269 --> 00:15:08,180
handled fine as an event queue but if

00:15:03,980 --> 00:15:10,870
something like apache + PHP that setup

00:15:08,180 --> 00:15:15,560
assumes the connections are short-lived

00:15:10,870 --> 00:15:19,819
and you have a limit still like if even

00:15:15,560 --> 00:15:23,500
if you have PHP or Ruby or something

00:15:19,819 --> 00:15:26,540
like that that that's not designed for

00:15:23,500 --> 00:15:28,730
permanent connections you can still use

00:15:26,540 --> 00:15:30,830
server-sent events for your smaller

00:15:28,730 --> 00:15:34,490
scale usage for example if you have

00:15:30,830 --> 00:15:36,890
admin interface for your website you can

00:15:34,490 --> 00:15:40,280
have real-time notifications real-time

00:15:36,890 --> 00:15:43,580
updates or watching the status of your

00:15:40,280 --> 00:15:47,000
server or new customers or whatever you

00:15:43,580 --> 00:15:50,020
want to know do update on your website

00:15:47,000 --> 00:15:53,870
as soon as it happens

00:15:50,020 --> 00:15:55,490
it's just you know that will be prepare

00:15:53,870 --> 00:16:00,920
for 20 connections not 20,000

00:15:55,490 --> 00:16:04,670
connections still if you have problems

00:16:00,920 --> 00:16:06,640
with overloading your servers as I

00:16:04,670 --> 00:16:09,550
mentioned server-sent events

00:16:06,640 --> 00:16:12,110
automatically reconnect to the server

00:16:09,550 --> 00:16:14,450
you don't have to do anything that's a

00:16:12,110 --> 00:16:16,160
beautiful thing you don't have to manage

00:16:14,450 --> 00:16:19,430
errors with servers and events the

00:16:16,160 --> 00:16:21,590
browser already does it for you it will

00:16:19,430 --> 00:16:24,020
do its best to keep connected so you can

00:16:21,590 --> 00:16:27,110
just tell clients to disconnect and

00:16:24,020 --> 00:16:30,050
retry after a delay and you can keep

00:16:27,110 --> 00:16:35,090
increasing this delay as the load on

00:16:30,050 --> 00:16:38,360
your server increases and the printer

00:16:35,090 --> 00:16:42,560
try new line and close connection so the

00:16:38,360 --> 00:16:45,010
client will remember the how long to

00:16:42,560 --> 00:16:48,290
wait the connection will be closed so

00:16:45,010 --> 00:16:51,400
your server doesn't have to handle the

00:16:48,290 --> 00:16:54,590
connection anymore and can serve other

00:16:51,400 --> 00:16:57,620
clients but the client will retry after

00:16:54,590 --> 00:17:01,220
a while and see you you know knock again

00:16:57,620 --> 00:17:05,120
can I can we talk now so that's a very

00:17:01,220 --> 00:17:06,620
very good way to scale beyond what it

00:17:05,120 --> 00:17:09,500
whatever your server can handle by

00:17:06,620 --> 00:17:11,960
default in terms of deployment the story

00:17:09,500 --> 00:17:16,120
for surface and events is the classic

00:17:11,960 --> 00:17:19,220
one which is all the nice browsers

00:17:16,120 --> 00:17:20,810
support it and support it for a long

00:17:19,220 --> 00:17:23,300
time now so you do you don't even have

00:17:20,810 --> 00:17:28,610
to worry about the version of them they

00:17:23,300 --> 00:17:30,940
all do even on mobile except the classic

00:17:28,610 --> 00:17:30,940
villains

00:17:32,530 --> 00:17:39,760
it's not supported in IE fore-edge it's

00:17:38,120 --> 00:17:43,370
under consideration

00:17:39,760 --> 00:17:46,940
so maybe supported maybe not the good

00:17:43,370 --> 00:17:49,400
news is because the protocol is so so

00:17:46,940 --> 00:17:54,980
simple and it's so similar to long

00:17:49,400 --> 00:17:57,590
polling there are polyfills for IE and

00:17:54,980 --> 00:18:01,190
edge that that basically work exactly as

00:17:57,590 --> 00:18:02,950
the native API is just one library on

00:18:01,190 --> 00:18:10,190
the client-side

00:18:02,950 --> 00:18:14,690
that will make it work so that's it for

00:18:10,190 --> 00:18:17,630
the server-sent events I'll add a little

00:18:14,690 --> 00:18:21,170
bit of history for it is the whole idea

00:18:17,630 --> 00:18:22,970
about server-sent events started on what

00:18:21,170 --> 00:18:25,700
working group when somebody said

00:18:22,970 --> 00:18:29,450
wouldn't it be cool to remotely control

00:18:25,700 --> 00:18:31,460
a webpage and the origin that's why it's

00:18:29,450 --> 00:18:33,320
event and that's why you can define your

00:18:31,460 --> 00:18:36,050
own type of event because the original

00:18:33,320 --> 00:18:39,440
idea was to send mouse clicks and

00:18:36,050 --> 00:18:44,450
keystrokes to the web page the idea is

00:18:39,440 --> 00:18:46,790
use add event source tag with a URL for

00:18:44,450 --> 00:18:49,010
the server to remotely control what

00:18:46,790 --> 00:18:52,700
happens on the patients and mouse click

00:18:49,010 --> 00:18:56,440
move Mouse do this to that that remote

00:18:52,700 --> 00:18:59,840
control idea that not really catch on

00:18:56,440 --> 00:19:04,100
but still you can send you can send your

00:18:59,840 --> 00:19:11,960
own events in a currently completely

00:19:04,100 --> 00:19:15,410
native purely JavaScript API so that's

00:19:11,960 --> 00:19:34,640
it if you want the slides there on my

00:19:15,410 --> 00:19:38,270
site and there are questions if you

00:19:34,640 --> 00:19:42,309
google for a server sent events polyfill

00:19:38,270 --> 00:19:44,440
the first result on is

00:19:42,309 --> 00:19:47,739
github with a really nice well-designed

00:19:44,440 --> 00:19:52,119
library there's also a small polyfill

00:19:47,739 --> 00:19:57,879
written by Remy sharp and both of them

00:19:52,119 --> 00:20:00,669
use XML HTTP requests and can straighten

00:19:57,879 --> 00:20:02,169
they can stream and parse the requests

00:20:00,669 --> 00:20:04,599
on the client side so they're fully

00:20:02,169 --> 00:20:07,719
polar filling the same API and it's just

00:20:04,599 --> 00:20:18,719
few kilobytes so IE support is not a big

00:20:07,719 --> 00:20:22,739
deal WebSockets is is an obvious choice

00:20:18,719 --> 00:20:25,330
so if you need a two-way communication

00:20:22,739 --> 00:20:27,879
for example you're implementing a

00:20:25,330 --> 00:20:30,940
first-person shooter and need super

00:20:27,879 --> 00:20:33,789
twitch quick upload of every keystroke

00:20:30,940 --> 00:20:36,489
to the server then yes WebSockets is the

00:20:33,789 --> 00:20:38,649
right choice for that a server sent

00:20:36,489 --> 00:20:41,679
events is from the server down to the

00:20:38,649 --> 00:20:43,989
client in real time and only that

00:20:41,679 --> 00:20:46,570
direction so if you're implementing a

00:20:43,989 --> 00:20:48,070
chess game then you can use servers and

00:20:46,570 --> 00:20:50,099
events if you're implementing

00:20:48,070 --> 00:20:51,920
first-person shooter then use WebSockets

00:20:50,099 --> 00:20:58,299
yeah

00:20:51,920 --> 00:20:58,299

YouTube URL: https://www.youtube.com/watch?v=71hId_-Iwqc


