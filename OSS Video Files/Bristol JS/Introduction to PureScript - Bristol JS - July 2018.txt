Title: Introduction to PureScript - Bristol JS - July 2018
Publication date: 2018-08-13
Playlist: Bristol JS
Description: 
	Presented by Jordan Lord.

Jordan will talk through a few examples as well as explaining how to get up and running with PureScript. He'll also be discussing the advantages and disadvantages of using PureScript over JavaScript.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:04,680
good afternoon good evening my name is

00:00:03,270 --> 00:00:06,750
Jordan Lord I'm going to be talking

00:00:04,680 --> 00:00:09,300
about the pure script programming

00:00:06,750 --> 00:00:11,340
language today just sort of a short

00:00:09,300 --> 00:00:13,980
disclaimer before I start I've never

00:00:11,340 --> 00:00:17,699
really done a talk like this before

00:00:13,980 --> 00:00:19,050
and I am no sort of expert in pure

00:00:17,699 --> 00:00:20,699
scripts but I do think it's a really

00:00:19,050 --> 00:00:24,380
cool technology and hopefully I can sort

00:00:20,699 --> 00:00:28,140
of present that in a decent way tonight

00:00:24,380 --> 00:00:32,309
so pure scripts is a transpiled

00:00:28,140 --> 00:00:33,870
programming language a bit like a bit

00:00:32,309 --> 00:00:37,170
like typescript a bit like Clojure

00:00:33,870 --> 00:00:40,710
script CoffeeScript live script Elm all

00:00:37,170 --> 00:00:42,239
these languages are transpiled to Java

00:00:40,710 --> 00:00:46,800
scripts and pure scripts is another one

00:00:42,239 --> 00:00:48,710
of those but it makes us the question

00:00:46,800 --> 00:00:55,469
especially with languages like

00:00:48,710 --> 00:00:58,140
typescript and coffee scripts they are

00:00:55,469 --> 00:01:00,629
very they do compile very they are very

00:00:58,140 --> 00:01:02,940
similar to JavaScript in some ways so it

00:01:00,629 --> 00:01:05,970
sort of makes us ask the question what

00:01:02,940 --> 00:01:07,799
is what is wrong with Java scripts is

00:01:05,970 --> 00:01:10,229
this is this language terrible that

00:01:07,799 --> 00:01:11,549
we're here we're actually meeting up

00:01:10,229 --> 00:01:14,210
today to talk about this language and

00:01:11,549 --> 00:01:16,740
it's actually yeah a bad language is it

00:01:14,210 --> 00:01:20,369
what why can't JavaScript just be normal

00:01:16,740 --> 00:01:22,590
I mean in what in what language in what

00:01:20,369 --> 00:01:26,369
language doesn't an empty object plus an

00:01:22,590 --> 00:01:29,640
empty array equals zero well whereas the

00:01:26,369 --> 00:01:32,579
logic behind that there's not really any

00:01:29,640 --> 00:01:35,119
types of Java scripts not I mean there

00:01:32,579 --> 00:01:38,520
is sort of like crappy lot types but

00:01:35,119 --> 00:01:40,140
yeah there's not really any types we've

00:01:38,520 --> 00:01:44,280
always got to choose between a double

00:01:40,140 --> 00:01:46,320
equals and a triple equals and again for

00:01:44,280 --> 00:01:47,670
a beginner the very little subtleties

00:01:46,320 --> 00:01:50,490
between those two can be really

00:01:47,670 --> 00:01:56,460
confusing and here's sort of another

00:01:50,490 --> 00:01:58,020
example there's the comparisons I think

00:01:56,460 --> 00:02:00,180
this sort of shows that there isn't

00:01:58,020 --> 00:02:03,619
really any logic behind the empty object

00:02:00,180 --> 00:02:03,619
for sent your equals zero

00:02:04,290 --> 00:02:09,149
we have to choose between let var and

00:02:06,329 --> 00:02:12,270
cons I mean we should know when to use

00:02:09,149 --> 00:02:12,940
Const or when to use let slash val but

00:02:12,270 --> 00:02:14,770
the

00:02:12,940 --> 00:02:20,350
differences between let enviro very very

00:02:14,770 --> 00:02:23,200
subtle and again for a beginner that can

00:02:20,350 --> 00:02:25,090
be really sort of confusing we've got

00:02:23,200 --> 00:02:27,340
two different types of nulls we've got

00:02:25,090 --> 00:02:30,100
null and undefined we've got we've got

00:02:27,340 --> 00:02:33,490
not a number nan and we've got infinity

00:02:30,100 --> 00:02:36,580
again it doesn't really make much sense

00:02:33,490 --> 00:02:39,730
to a beginner I mean this is a perfectly

00:02:36,580 --> 00:02:41,500
valid example of me tasting objects but

00:02:39,730 --> 00:02:45,550
in JavaScript we don't really have any

00:02:41,500 --> 00:02:47,860
immutability so you can pass an object

00:02:45,550 --> 00:02:50,230
to a function and it can change it can

00:02:47,860 --> 00:02:52,120
change the state of that object in that

00:02:50,230 --> 00:02:53,910
function without you actually realizing

00:02:52,120 --> 00:02:56,530
it and some libraries actually do this

00:02:53,910 --> 00:02:59,410
and it can be really difficult to debug

00:02:56,530 --> 00:03:00,940
what's actually happened we can get kind

00:02:59,410 --> 00:03:03,330
of immutability I'm gonna sort of

00:03:00,940 --> 00:03:06,520
justify that last statement a little bit

00:03:03,330 --> 00:03:08,770
immutable J s of course we can use

00:03:06,520 --> 00:03:11,610
things like that but it's not baked it's

00:03:08,770 --> 00:03:14,860
not actually baked into the language

00:03:11,610 --> 00:03:17,350
again we can have we can have the

00:03:14,860 --> 00:03:19,660
side-effects in JavaScript a function

00:03:17,350 --> 00:03:22,030
that does look like an innocent pure

00:03:19,660 --> 00:03:26,200
function might actually be starting

00:03:22,030 --> 00:03:28,780
World War 3 which I mean is if this is a

00:03:26,200 --> 00:03:33,220
piece of code in the in the let's say

00:03:28,780 --> 00:03:36,940
the North Korean military missile

00:03:33,220 --> 00:03:39,610
testing whatever and we accidentally

00:03:36,940 --> 00:03:41,769
execute launch missile then we're

00:03:39,610 --> 00:03:46,660
starting World War 3 without intending

00:03:41,769 --> 00:03:49,720
it but it's it's it's all a bit silly

00:03:46,660 --> 00:03:52,269
all this because these arguments we know

00:03:49,720 --> 00:03:53,950
to use the good parts of JavaScript we

00:03:52,269 --> 00:03:59,170
know to use triple equals instead of

00:03:53,950 --> 00:04:01,300
double equals we know to use I can't

00:03:59,170 --> 00:04:03,180
remember the other example now but we

00:04:01,300 --> 00:04:06,430
know to use the good parts of JavaScript

00:04:03,180 --> 00:04:07,870
so what is what is actually pure scripts

00:04:06,430 --> 00:04:10,320
I'm not talking about JavaScript today

00:04:07,870 --> 00:04:13,480
I'm talking about pure scripts

00:04:10,320 --> 00:04:16,989
well pure scripts is a is a purely

00:04:13,480 --> 00:04:20,890
functional programming language it's

00:04:16,989 --> 00:04:24,610
strongly typed it has Haskell Lee's

00:04:20,890 --> 00:04:26,590
syntax so if you know Haskell then you'd

00:04:24,610 --> 00:04:29,470
be able to pick up pure scripts very

00:04:26,590 --> 00:04:33,699
easily and it compiles to sort of

00:04:29,470 --> 00:04:35,650
readable JavaScript it not kind of like

00:04:33,699 --> 00:04:37,270
coffee scripts and type scripts but you

00:04:35,650 --> 00:04:40,300
can sort of reason with the code that

00:04:37,270 --> 00:04:41,680
has been compiled and the types only

00:04:40,300 --> 00:04:45,660
exists at compile time so it's a

00:04:41,680 --> 00:04:48,370
statically typed programming language I

00:04:45,660 --> 00:04:51,070
mean why don't we just use Haskell

00:04:48,370 --> 00:04:55,300
because we can compile Haskell down to

00:04:51,070 --> 00:04:57,580
JavaScript but Haskell comes with a bit

00:04:55,300 --> 00:04:59,620
of a run time when you do compile it to

00:04:57,580 --> 00:05:03,669
JavaScript so it's much lighter weight

00:04:59,620 --> 00:05:07,330
to compile pure scripts to use pure

00:05:03,669 --> 00:05:09,940
scripts and I'm going to take a little

00:05:07,330 --> 00:05:13,320
bit of a detour for a second so who

00:05:09,940 --> 00:05:16,419
actually as knows what this machine is

00:05:13,320 --> 00:05:19,139
yeah this is for those that don't know

00:05:16,419 --> 00:05:22,900
this is the BBC microcomputer

00:05:19,139 --> 00:05:24,699
it was released in the early 80s believe

00:05:22,900 --> 00:05:27,490
it or not I actually started programming

00:05:24,699 --> 00:05:30,729
on this machine it was my dad who

00:05:27,490 --> 00:05:35,440
introduced me to it and he was showing

00:05:30,729 --> 00:05:37,960
me games like elite and manic miner but

00:05:35,440 --> 00:05:40,810
I was sort of more interested in how to

00:05:37,960 --> 00:05:43,300
program it and make it make it do things

00:05:40,810 --> 00:05:45,099
I was fascinated by how you basically

00:05:43,300 --> 00:05:49,660
had to program it to do anything that

00:05:45,099 --> 00:05:51,220
was the interface to it and for a long

00:05:49,660 --> 00:05:52,780
time for a few years like when I was

00:05:51,220 --> 00:05:56,440
probably 10 or 11 I was programming in

00:05:52,780 --> 00:05:58,630
BBC basic and a lot of people told me

00:05:56,440 --> 00:06:04,210
that this was about it pollutes you mind

00:05:58,630 --> 00:06:07,210
basic also you know try something like

00:06:04,210 --> 00:06:09,460
Java so I tried Java for a little bit I

00:06:07,210 --> 00:06:11,889
didn't really like the ID was too

00:06:09,460 --> 00:06:18,010
it was it was too complicated and it was

00:06:11,889 --> 00:06:19,479
too awkward to set up the JDK so so for

00:06:18,010 --> 00:06:21,639
a long time was programming hidden BBC

00:06:19,479 --> 00:06:23,380
basic but eventually I came across

00:06:21,639 --> 00:06:25,720
JavaScript and what I did like about

00:06:23,380 --> 00:06:29,620
JavaScript was that all you needed was a

00:06:25,720 --> 00:06:31,450
text editor and a web browser and you

00:06:29,620 --> 00:06:33,190
could basically reach anybody in the

00:06:31,450 --> 00:06:36,130
world you can share your JavaScript

00:06:33,190 --> 00:06:38,530
applications with your friends and it

00:06:36,130 --> 00:06:40,660
was it was brilliant so for a long time

00:06:38,530 --> 00:06:43,540
with programs in JavaScript

00:06:40,660 --> 00:06:45,070
and decided that's what I wanted to do

00:06:43,540 --> 00:06:48,040
as a career I wanted to be a software

00:06:45,070 --> 00:06:50,890
developer so I started as an apprentice

00:06:48,040 --> 00:06:53,290
at a company called sage I was doing

00:06:50,890 --> 00:06:55,750
dotnet c-sharp stuff

00:06:53,290 --> 00:07:00,010
and finally I got into Java a bit of

00:06:55,750 --> 00:07:01,210
Java there but then I decided I wanted

00:07:00,010 --> 00:07:04,600
to do something a little bit more

00:07:01,210 --> 00:07:07,780
theoretical so I came to University here

00:07:04,600 --> 00:07:09,970
in Bristol the University of Bristol and

00:07:07,780 --> 00:07:11,470
we have a Haskell module and this is

00:07:09,970 --> 00:07:15,430
where I got into Haskell and I was sort

00:07:11,470 --> 00:07:18,340
of I was blown away by Haskell the the

00:07:15,430 --> 00:07:19,660
power of it the expressiveness of it and

00:07:18,340 --> 00:07:22,150
when I went back to program in Java

00:07:19,660 --> 00:07:23,950
scripts it was always a bit awkward it

00:07:22,150 --> 00:07:28,150
was like I want these nice beaches of

00:07:23,950 --> 00:07:30,160
Haskell in JavaScript and I've tried

00:07:28,150 --> 00:07:31,810
live scripts for a little bit which is

00:07:30,160 --> 00:07:36,130
kind of like an extension onto

00:07:31,810 --> 00:07:37,450
CoffeeScript but eventually I came

00:07:36,130 --> 00:07:41,710
across pure scripts and I was satisfied

00:07:37,450 --> 00:07:47,020
and that was the that was the Holy Grail

00:07:41,710 --> 00:07:49,420
almost and now I'm working for I'm going

00:07:47,020 --> 00:07:50,710
into my second year at university and

00:07:49,420 --> 00:07:53,860
I'm currently working for a company

00:07:50,710 --> 00:07:56,080
called Zuba VR this summer so we do sort

00:07:53,860 --> 00:07:59,050
of virtual reality applications mixed

00:07:56,080 --> 00:08:01,120
reality augmented reality applications

00:07:59,050 --> 00:08:03,490
I've been getting involved in a few

00:08:01,120 --> 00:08:06,120
really interesting projects there with

00:08:03,490 --> 00:08:09,580
web AR JavaScript

00:08:06,120 --> 00:08:13,960
socket IO reacts rxjs so it's been a

00:08:09,580 --> 00:08:16,030
it's been pretty interesting but back to

00:08:13,960 --> 00:08:20,020
pure script I don't think the pure

00:08:16,030 --> 00:08:22,240
script logo displays very well there but

00:08:20,020 --> 00:08:23,710
yeah this is where the talk gets a lot

00:08:22,240 --> 00:08:27,400
more boring I'm gonna go through like

00:08:23,710 --> 00:08:29,800
the the basics of like the language so

00:08:27,400 --> 00:08:33,610
to get started you need to install the

00:08:29,800 --> 00:08:35,800
pure script compiler viewers I don't

00:08:33,610 --> 00:08:37,660
know if that's how you pronounce it but

00:08:35,800 --> 00:08:40,870
you can install that from the website or

00:08:37,660 --> 00:08:44,980
with a package manager it's still a pure

00:08:40,870 --> 00:08:47,740
script actually still uses bower as a as

00:08:44,980 --> 00:08:51,370
a package manager I believe this is to

00:08:47,740 --> 00:08:52,720
do with how it handles dependencies I

00:08:51,370 --> 00:08:53,580
don't know why they haven't really

00:08:52,720 --> 00:08:56,700
switch to NPM

00:08:53,580 --> 00:08:59,520
or something else yet but they use Bower

00:08:56,700 --> 00:09:02,070
and pulp sorry

00:08:59,520 --> 00:09:05,280
pulp is the build tool for pure scripts

00:09:02,070 --> 00:09:07,920
that you'll also need creating a new

00:09:05,280 --> 00:09:12,920
project pulp in its dev service so this

00:09:07,920 --> 00:09:15,210
is like your web pack dev server and

00:09:12,920 --> 00:09:17,220
pure scripts repple so I can actually

00:09:15,210 --> 00:09:18,240
quickly actually I'm not going to

00:09:17,220 --> 00:09:22,170
demonstrate that because this is a

00:09:18,240 --> 00:09:26,010
different monitor so you can bring up

00:09:22,170 --> 00:09:30,450
your pure scripts that'll answer

00:09:26,010 --> 00:09:33,570
functions yeah functions in pure scripts

00:09:30,450 --> 00:09:35,940
this is how functions are defined so you

00:09:33,570 --> 00:09:38,610
have your you have your function name

00:09:35,940 --> 00:09:41,610
and then you have the functions type so

00:09:38,610 --> 00:09:43,110
all functions are defined as you have

00:09:41,610 --> 00:09:47,180
your input type and then you have an

00:09:43,110 --> 00:09:47,180
arrow and then you have your output type

00:09:47,420 --> 00:09:53,610
so it's it's very similar to Haskell if

00:09:50,640 --> 00:09:57,090
you know Haskell but all functions have

00:09:53,610 --> 00:09:59,820
one inputs and one output here's an

00:09:57,090 --> 00:10:01,140
example of just adding two you'll see

00:09:59,820 --> 00:10:03,380
this throughout the talk all the

00:10:01,140 --> 00:10:06,060
examples are really sort of fun creative

00:10:03,380 --> 00:10:08,550
but here's obtuse we take a number and

00:10:06,060 --> 00:10:11,490
we return a number and we're taking the

00:10:08,550 --> 00:10:15,120
parameter X and then adding two and this

00:10:11,490 --> 00:10:17,250
is just a normal JavaScript number if if

00:10:15,120 --> 00:10:18,810
you omit the the decimal point from the

00:10:17,250 --> 00:10:23,130
end and just write the number two that

00:10:18,810 --> 00:10:25,830
the the compiler will infer that it's an

00:10:23,130 --> 00:10:30,900
integer pure scripts as integers and

00:10:25,830 --> 00:10:32,550
this will not compile but what happens

00:10:30,900 --> 00:10:35,730
if you want more than one input to a

00:10:32,550 --> 00:10:38,370
function pure spit-takes

00:10:35,730 --> 00:10:42,960
i've just said that a function takes one

00:10:38,370 --> 00:10:44,970
input and produces one output but here

00:10:42,960 --> 00:10:46,830
we want multiple inputs again this is

00:10:44,970 --> 00:10:52,070
another really uncreated example

00:10:46,830 --> 00:10:54,840
literally aliasing the plus operator but

00:10:52,070 --> 00:11:00,690
all functions in pure scripts are

00:10:54,840 --> 00:11:02,790
curried it's easier to see here so when

00:11:00,690 --> 00:11:04,830
you give it a parameter if you if you

00:11:02,790 --> 00:11:05,880
give the function an argument it will

00:11:04,830 --> 00:11:07,770
return

00:11:05,880 --> 00:11:09,720
a new function that we'll be looking for

00:11:07,770 --> 00:11:11,220
the next argument and then it will keep

00:11:09,720 --> 00:11:13,620
doing that until you actually return the

00:11:11,220 --> 00:11:15,480
result so here we're accepting a number

00:11:13,620 --> 00:11:18,720
and then we're returning a function of

00:11:15,480 --> 00:11:19,860
type number to number and then give it

00:11:18,720 --> 00:11:22,050
another parameter you'll finally get

00:11:19,860 --> 00:11:30,210
your number out and this is just an

00:11:22,050 --> 00:11:38,160
example of using that function but what

00:11:30,210 --> 00:11:41,220
this is really useful for is so here we

00:11:38,160 --> 00:11:43,610
have the map function so in JavaScript

00:11:41,220 --> 00:11:47,220
where we would have to define a lambda

00:11:43,610 --> 00:11:49,650
and we would have to have like X arrow X

00:11:47,220 --> 00:11:52,170
plus 42 in pure script because all

00:11:49,650 --> 00:11:55,230
functions are courage we can have map

00:11:52,170 --> 00:11:58,710
and then just omit the other parameter

00:11:55,230 --> 00:12:01,550
to the function and and then it will

00:11:58,710 --> 00:12:01,550
just sort of work

00:12:02,600 --> 00:12:10,860
so creating types impure scripts we can

00:12:08,730 --> 00:12:13,110
define new types so these these are

00:12:10,860 --> 00:12:15,180
these work very similar to just normal

00:12:13,110 --> 00:12:17,490
objects in Java scripts but it checks

00:12:15,180 --> 00:12:19,020
the types before compile time here we're

00:12:17,490 --> 00:12:21,900
creating a user with username string

00:12:19,020 --> 00:12:26,730
email string and here we're actually

00:12:21,900 --> 00:12:29,670
using the will of we're going to

00:12:26,730 --> 00:12:31,920
actually print out that user so show use

00:12:29,670 --> 00:12:34,530
of it's taking you user and returning a

00:12:31,920 --> 00:12:37,560
string and here we've obviously got the

00:12:34,530 --> 00:12:40,830
just a normal JavaScript style style

00:12:37,560 --> 00:12:44,760
syntax for an object and here's username

00:12:40,830 --> 00:12:47,970
and email and there's the string it

00:12:44,760 --> 00:12:51,330
returns at the bottom well again all the

00:12:47,970 --> 00:12:53,100
compiled all the type inference and and

00:12:51,330 --> 00:12:55,350
the type checking is done at compile

00:12:53,100 --> 00:12:58,140
time so if I went username equals 42

00:12:55,350 --> 00:13:04,140
then the compiler would say no you can't

00:12:58,140 --> 00:13:08,010
do that so new type new type is a bit

00:13:04,140 --> 00:13:12,800
like sort of wrapping an existing type

00:13:08,010 --> 00:13:17,250
in in another type so here we've got

00:13:12,800 --> 00:13:19,050
we've got an email and we're sort of

00:13:17,250 --> 00:13:20,459
wrapping a string as a

00:13:19,050 --> 00:13:24,980
I'm saying an email in the string

00:13:20,459 --> 00:13:30,529
basically why would you want to do that

00:13:24,980 --> 00:13:33,269
well it's very useful for validation so

00:13:30,529 --> 00:13:37,140
here's a function that's passing an

00:13:33,269 --> 00:13:40,829
email so it's testing our email string

00:13:37,140 --> 00:13:43,610
that we passed in to the regex and if it

00:13:40,829 --> 00:13:45,360
is if it does pass then we're returning

00:13:43,610 --> 00:13:48,060
here we're actually using the data

00:13:45,360 --> 00:13:51,300
constructor for email and wrapping that

00:13:48,060 --> 00:13:53,220
string as an email and then if not we're

00:13:51,300 --> 00:13:54,930
returning an error message this was

00:13:53,220 --> 00:13:59,730
actually ripped off from a another toe

00:13:54,930 --> 00:14:01,950
so I think read but this is useful for

00:13:59,730 --> 00:14:05,610
validation because what we can do here

00:14:01,950 --> 00:14:08,279
is we can we can export the past email

00:14:05,610 --> 00:14:10,769
function but we don't export the data

00:14:08,279 --> 00:14:13,589
constructor and what that means is every

00:14:10,769 --> 00:14:16,290
time you ask for an email anywhere in

00:14:13,589 --> 00:14:17,970
your application you know that that

00:14:16,290 --> 00:14:19,320
email could have only been created

00:14:17,970 --> 00:14:22,730
through the pass email function

00:14:19,320 --> 00:14:26,550
so that email would definitely be valid

00:14:22,730 --> 00:14:27,839
here's an example of exporting email so

00:14:26,550 --> 00:14:31,790
that's the type constructor and

00:14:27,839 --> 00:14:36,649
exporting the function part email and

00:14:31,790 --> 00:14:36,649
importing is exactly the same basically

00:14:37,700 --> 00:14:45,630
algebraic data types so algebraic data

00:14:40,890 --> 00:14:48,300
types are a bit like enums but they work

00:14:45,630 --> 00:14:51,060
a little bit differently so here with

00:14:48,300 --> 00:14:53,990
its what it's behaving exactly like what

00:14:51,060 --> 00:14:57,480
and even them how an enum would behave

00:14:53,990 --> 00:15:01,079
user type can either be a guest a member

00:14:57,480 --> 00:15:05,390
or an admin but we can use it for more

00:15:01,079 --> 00:15:09,690
complex tasks so here actually using

00:15:05,390 --> 00:15:11,940
algebraic data types to create a list so

00:15:09,690 --> 00:15:15,510
in a list can either be empty nil or it

00:15:11,940 --> 00:15:22,110
can be a chain of a value and another

00:15:15,510 --> 00:15:26,610
list type classes so type classes behave

00:15:22,110 --> 00:15:29,579
very similar to interfaces in normal

00:15:26,610 --> 00:15:31,170
object-oriented programming so here

00:15:29,579 --> 00:15:32,040
we're actually defining the show type

00:15:31,170 --> 00:15:34,680
class

00:15:32,040 --> 00:15:39,300
and it only has one function which is

00:15:34,680 --> 00:15:41,820
show and then a tostring and here we're

00:15:39,300 --> 00:15:45,110
actually implementing the show type

00:15:41,820 --> 00:15:48,180
class for our user type before and

00:15:45,110 --> 00:15:51,090
here's a kind of a cool feature of pure

00:15:48,180 --> 00:15:52,560
scripts we're using pattern matching so

00:15:51,090 --> 00:15:55,380
instead of writing a bunch of if

00:15:52,560 --> 00:15:58,700
statements if user is guest if use else

00:15:55,380 --> 00:16:01,530
if user is admin or a switch statement

00:15:58,700 --> 00:16:03,810
we can just right well show if we're

00:16:01,530 --> 00:16:06,150
showing a guest this is what the guest

00:16:03,810 --> 00:16:10,680
wing would be show member member and so

00:16:06,150 --> 00:16:14,180
on and again here's an example with our

00:16:10,680 --> 00:16:18,300
email new type as we described earlier

00:16:14,180 --> 00:16:20,900
and here we actually unwrapping the

00:16:18,300 --> 00:16:25,770
email type to get the string out and

00:16:20,900 --> 00:16:27,870
return that string side effects

00:16:25,770 --> 00:16:31,770
so you can actually represent side

00:16:27,870 --> 00:16:33,990
effects in pure script you but you have

00:16:31,770 --> 00:16:36,480
to sort of specify in the type that

00:16:33,990 --> 00:16:38,490
we're using we're returning a monad

00:16:36,480 --> 00:16:44,700
which is here we're actually using the

00:16:38,490 --> 00:16:46,620
effect monad and yeah so you can

00:16:44,700 --> 00:16:48,090
actually see if you think you've got an

00:16:46,620 --> 00:16:50,580
innocent pure function that's going to

00:16:48,090 --> 00:16:52,350
be starting World War three you can

00:16:50,580 --> 00:16:54,600
actually see in the type that it's it's

00:16:52,350 --> 00:16:58,310
not such an innocent pure function it

00:16:54,600 --> 00:17:03,630
will be returning an effect of something

00:16:58,310 --> 00:17:06,240
so I'm going to show an example of a an

00:17:03,630 --> 00:17:08,970
isometric 3d cube written in pure

00:17:06,240 --> 00:17:11,370
scripts so here's just I hope that's

00:17:08,970 --> 00:17:14,280
clearing off but that's just a cube

00:17:11,370 --> 00:17:19,920
that's rotating and this is purely

00:17:14,280 --> 00:17:25,500
written in pure scripts so I will bring

00:17:19,920 --> 00:17:29,360
up the code and the cube is defined here

00:17:25,500 --> 00:17:34,950
so the cube is a new type that wraps a

00:17:29,360 --> 00:17:36,660
matrix of type number and again this

00:17:34,950 --> 00:17:41,100
this can be defined however it runt

00:17:36,660 --> 00:17:42,720
wants but we implement this this again

00:17:41,100 --> 00:17:44,130
it's a little bit confusing because I've

00:17:42,720 --> 00:17:46,000
got two different new types here but

00:17:44,130 --> 00:17:53,879
we're implementing

00:17:46,000 --> 00:17:53,879
the new type type can the new type data

00:17:54,269 --> 00:18:00,070
we're implementing new type of matrix

00:17:57,580 --> 00:18:03,549
number and as long as this cube type

00:18:00,070 --> 00:18:05,639
here can be unwrapped to a matrix and

00:18:03,549 --> 00:18:09,789
can be wrapped up again from a matrix

00:18:05,639 --> 00:18:18,039
that means it's renderable so if I bring

00:18:09,789 --> 00:18:21,519
up the renderable the renderable type

00:18:18,039 --> 00:18:24,850
class so for something to be renderable

00:18:21,519 --> 00:18:32,440
it has to implement a new type of matrix

00:18:24,850 --> 00:18:34,450
number and again for something to be

00:18:32,440 --> 00:18:37,539
renderable it also has to be transform

00:18:34,450 --> 00:18:40,990
all so that's sort of the power of the

00:18:37,539 --> 00:18:42,850
type system and here's another another

00:18:40,990 --> 00:18:45,279
type that I defined which is a permit

00:18:42,850 --> 00:18:47,399
and again this wraps matrix number it

00:18:45,279 --> 00:18:51,639
doesn't necessarily have to wrap a

00:18:47,399 --> 00:19:00,240
matrix number but as long as it unwraps

00:18:51,639 --> 00:19:00,240
and wraps - then that's fine and I go to

00:19:02,129 --> 00:19:15,080
change cube with pyramid

00:19:06,809 --> 00:19:17,340
and hopefully that will recompile then

00:19:15,080 --> 00:19:19,710
refreshing the page to passing that

00:19:17,340 --> 00:19:26,220
pyramiden will then start rendering the

00:19:19,710 --> 00:19:28,350
pyramid so yeah I was actually going to

00:19:26,220 --> 00:19:34,590
do some live coding but it was probably

00:19:28,350 --> 00:19:36,450
boring enough as it was so yeah but what

00:19:34,590 --> 00:19:38,700
happens if you already have an

00:19:36,450 --> 00:19:40,769
application that's written in JavaScript

00:19:38,700 --> 00:19:44,249
and you want sort of the power of pure

00:19:40,769 --> 00:19:45,600
scripts in that application you don't

00:19:44,249 --> 00:19:46,889
want to build your application from the

00:19:45,600 --> 00:19:52,950
ground up in pure scripts

00:19:46,889 --> 00:19:54,269
using like that 3d example was but it's

00:19:52,950 --> 00:19:56,580
actually really really simple to

00:19:54,269 --> 00:19:59,700
integrate pure scripts into your current

00:19:56,580 --> 00:20:02,999
application so we can we can run pulp in

00:19:59,700 --> 00:20:04,740
it or we can just create a we can do

00:20:02,999 --> 00:20:06,509
bower in it and we can install the

00:20:04,740 --> 00:20:10,919
default pure script modules like pure

00:20:06,509 --> 00:20:14,539
scripts prelude but just make sure to

00:20:10,919 --> 00:20:17,669
remove the default main dot pure scripts

00:20:14,539 --> 00:20:20,639
but what makes this really easy is is

00:20:17,669 --> 00:20:25,559
the the web pack loader for pure scripts

00:20:20,639 --> 00:20:29,460
so installing that and then adding the

00:20:25,559 --> 00:20:32,249
pure web pack loader to your web config

00:20:29,460 --> 00:20:35,070
it's then really simple to incorporate

00:20:32,249 --> 00:20:37,639
into your application so I have an

00:20:35,070 --> 00:20:37,639
example application

00:20:42,770 --> 00:20:49,960
yes so if I do NPM starts

00:20:56,480 --> 00:21:02,420
yes this is just a really simple react

00:20:59,570 --> 00:21:05,780
app where when you click Add 42 here lad

00:21:02,420 --> 00:21:07,640
42 to the total but what happens if we

00:21:05,780 --> 00:21:09,970
want that logic and shift it into pure

00:21:07,640 --> 00:21:09,970
script

00:21:20,690 --> 00:21:27,420
I'll open up the root component so here

00:21:25,140 --> 00:21:29,310
this ad 42 function is taking the

00:21:27,420 --> 00:21:33,510
current states and it's returning a new

00:21:29,310 --> 00:21:42,060
state and adding 42 to it so if we

00:21:33,510 --> 00:21:45,780
remove that then the application should

00:21:42,060 --> 00:21:50,120
no longer work at 42 doesn't do anything

00:21:45,780 --> 00:21:54,480
anymore but I want that ad 42 function

00:21:50,120 --> 00:21:59,070
written in pure script so I'm going to

00:21:54,480 --> 00:22:05,100
create a new file source let's let's

00:21:59,070 --> 00:22:06,690
call the module ad 42 module I'm 42

00:22:05,100 --> 00:22:10,040
'this is defining a module and then

00:22:06,690 --> 00:22:15,780
we're going to export the ad 42 function

00:22:10,040 --> 00:22:19,160
where and the ad 42 function will take

00:22:15,780 --> 00:22:26,850
the current state and return a new state

00:22:19,160 --> 00:22:29,490
at 42 we will then and destruct and just

00:22:26,850 --> 00:22:36,060
like you would in in a group six get the

00:22:29,490 --> 00:22:39,000
total out of it which is there and then

00:22:36,060 --> 00:22:44,070
return a new object where total it's

00:22:39,000 --> 00:22:51,900
going to be total plus 42 but we also

00:22:44,070 --> 00:22:57,840
have to define States as a type total is

00:22:51,900 --> 00:23:00,590
going to be of type int and we'll also

00:22:57,840 --> 00:23:11,400
have to import

00:23:00,590 --> 00:23:16,320
valued not 42 plus and then rebuilding

00:23:11,400 --> 00:23:18,990
the application it doesn't work let's

00:23:16,320 --> 00:23:22,080
step up why it doesn't work that

00:23:18,990 --> 00:23:26,720
compiled I think you know why because in

00:23:22,080 --> 00:23:35,520
here we didn't import it if we import

00:23:26,720 --> 00:23:37,790
this ad 42 function from ad $42 your

00:23:35,520 --> 00:23:37,790
script

00:23:38,100 --> 00:23:48,210
it should seamlessly sort of work and it

00:23:43,170 --> 00:23:51,120
does so here we've got the pure script

00:23:48,210 --> 00:23:53,070
code and it's passing it's calling the

00:23:51,120 --> 00:23:56,490
ad 42 function which is defined in pure

00:23:53,070 --> 00:23:59,970
script and that's how easy it sort of is

00:23:56,490 --> 00:24:01,890
to integrate pure scripts into your

00:23:59,970 --> 00:24:06,240
current application if it's built with

00:24:01,890 --> 00:24:09,660
web pack I mean pure script does have a

00:24:06,240 --> 00:24:11,880
lot of disadvantages so you are

00:24:09,660 --> 00:24:14,280
basically learning a new language from

00:24:11,880 --> 00:24:15,360
scratch which if you're working in a

00:24:14,280 --> 00:24:19,200
team that's a big problem because

00:24:15,360 --> 00:24:20,640
everyone then has to solve learn this

00:24:19,200 --> 00:24:23,460
new language

00:24:20,640 --> 00:24:25,950
there are also some breaking changes so

00:24:23,460 --> 00:24:30,240
with that 3d example that I've showed

00:24:25,950 --> 00:24:33,510
earlier I wrote that with pure scripts

00:24:30,240 --> 00:24:37,350
naught point 1 1 7 and a newer version

00:24:33,510 --> 00:24:39,090
of pure scripts was released that's and

00:24:37,350 --> 00:24:41,730
things just didn't seem to compile and I

00:24:39,090 --> 00:24:44,310
was wondering why it works on my desktop

00:24:41,730 --> 00:24:45,960
but it doesn't work on my laptop and my

00:24:44,310 --> 00:24:48,750
laptop had the newer version of the pure

00:24:45,960 --> 00:24:50,670
script compiler and that's why but I

00:24:48,750 --> 00:24:51,990
guess if if you running this in a

00:24:50,670 --> 00:24:53,850
production environment you would have a

00:24:51,990 --> 00:24:56,370
docker container with a specific version

00:24:53,850 --> 00:24:59,400
of the of the pure script compiler

00:24:56,370 --> 00:25:03,060
installed so that wouldn't be too much

00:24:59,400 --> 00:25:05,220
of a problem but advantages it's it's

00:25:03,060 --> 00:25:07,110
like of the showed it's really easy to

00:25:05,220 --> 00:25:12,120
integrate pure scripts into your current

00:25:07,110 --> 00:25:15,720
application it's very expressive it's

00:25:12,120 --> 00:25:20,250
easy to reason about stay

00:25:15,720 --> 00:25:25,409
this is a large LAN library so a lot of

00:25:20,250 --> 00:25:28,710
the the pure script sort of standard

00:25:25,409 --> 00:25:30,870
library which I'll show in a minute

00:25:28,710 --> 00:25:39,149
sort of like alias is a lot of the

00:25:30,870 --> 00:25:40,830
standard browser functions and the type

00:25:39,149 --> 00:25:46,320
system is designed to work with you it's

00:25:40,830 --> 00:25:47,899
not like it's not there how can I

00:25:46,320 --> 00:25:49,980
describe this

00:25:47,899 --> 00:25:52,309
yeah the touch systems there to work

00:25:49,980 --> 00:25:54,779
with you it it has a very powerful

00:25:52,309 --> 00:25:56,610
foreign function interface so if you

00:25:54,779 --> 00:25:59,279
have an existing peer sips application

00:25:56,610 --> 00:26:02,580
and you want to use some of your Java

00:25:59,279 --> 00:26:04,320
scripts in it then it's it's very easy

00:26:02,580 --> 00:26:06,480
to do that with the foreign function

00:26:04,320 --> 00:26:09,149
interface and I think the number one

00:26:06,480 --> 00:26:11,539
reason advantage of using peer scripts

00:26:09,149 --> 00:26:16,320
is that it's actually fun to use it's a

00:26:11,539 --> 00:26:19,760
fun language in here are some of the

00:26:16,320 --> 00:26:22,440
resources that aren't very clear to see

00:26:19,760 --> 00:26:24,840
so peer skit by example this was written

00:26:22,440 --> 00:26:27,210
by the guy who wrote pure scripts Phil

00:26:24,840 --> 00:26:33,019
Freeman this is sort of like the

00:26:27,210 --> 00:26:36,659
standard book pure script documentation

00:26:33,019 --> 00:26:38,880
repository is useful try pure script

00:26:36,659 --> 00:26:42,389
that's a bit like cold pen but it's pure

00:26:38,880 --> 00:26:45,149
script and pursuit so for those that

00:26:42,389 --> 00:26:48,929
know Haskell this is this is very

00:26:45,149 --> 00:26:50,760
similar to Google and it's very sort of

00:26:48,929 --> 00:26:51,899
easy to look up a function that you

00:26:50,760 --> 00:26:57,630
don't know so if I don't know what the

00:26:51,899 --> 00:27:01,440
dollar operator does there is it applies

00:26:57,630 --> 00:27:04,350
a function to an argument or let's say

00:27:01,440 --> 00:27:09,779
if I wanted to find a function that took

00:27:04,350 --> 00:27:11,600
a number two a number to a number and

00:27:09,779 --> 00:27:14,010
there's there's a list of functions that

00:27:11,600 --> 00:27:15,840
take a number a number and return a

00:27:14,010 --> 00:27:21,360
number so the max function and the min

00:27:15,840 --> 00:27:26,370
function so it's a really really useful

00:27:21,360 --> 00:27:27,810
resource and that's it so if you want to

00:27:26,370 --> 00:27:30,360
find the slide it's at

00:27:27,810 --> 00:27:33,120
Jordan take a forward slash intro to

00:27:30,360 --> 00:27:34,460
Peter scripts thank you very much for

00:27:33,120 --> 00:27:39,739
being patient

00:27:34,460 --> 00:27:39,739

YouTube URL: https://www.youtube.com/watch?v=He7gQ56vl4M


