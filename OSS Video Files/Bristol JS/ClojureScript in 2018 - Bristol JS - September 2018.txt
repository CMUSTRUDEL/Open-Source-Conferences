Title: ClojureScript in 2018 - Bristol JS - September 2018
Publication date: 2018-10-09
Playlist: Bristol JS
Description: 
	Presented by Luke Snape. 

Clojure the language hasn't changed all that much in the last 3 years, but the way in which ClojureScript applications are built and deployed has changed massively. In particular, improvements to tooling and a bigger ecosystem now make ClojureScript a practical choice for building modern web applications.

In this talk Luke will aim to give a quick introduction to the Clojure language, as well as a short history of how the ClojureScript compiler and tooling have evolved in recent years. He'll then explore the capabilities of the latest tools and how we're currently using them to build, test and deploy single-page applications in ClojureScript.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:05,490
I'm weak and I work at closure shop in

00:00:03,330 --> 00:00:08,719
Bristol called English language I

00:00:05,490 --> 00:00:12,360
tutoring or a--let's I've been building

00:00:08,719 --> 00:00:16,049
closures script applications for about

00:00:12,360 --> 00:00:17,430
four years four and a half up until

00:00:16,049 --> 00:00:21,570
about three years ago it was you UI

00:00:17,430 --> 00:00:25,439
tooling really and but three years the

00:00:21,570 --> 00:00:27,210
last three years has been production

00:00:25,439 --> 00:00:31,500
sort of single page applications and

00:00:27,210 --> 00:00:34,370
services - so full stack and on building

00:00:31,500 --> 00:00:36,829
our latest single page application I

00:00:34,370 --> 00:00:38,700
noticed that it sort of struck me that

00:00:36,829 --> 00:00:40,710
the way that we were building is

00:00:38,700 --> 00:00:43,200
completely changed and evolved and be

00:00:40,710 --> 00:00:47,250
good to sort of share exactly how that's

00:00:43,200 --> 00:00:49,020
changed in this talk and aware that some

00:00:47,250 --> 00:00:50,520
of you don't know about closure so I'll

00:00:49,020 --> 00:00:55,710
give you a bit of an introduction about

00:00:50,520 --> 00:00:57,989
that and closure scripty for me closure

00:00:55,710 --> 00:01:02,359
script started I first heard about

00:00:57,989 --> 00:01:05,820
closure and closure scripts about 2011

00:01:02,359 --> 00:01:08,010
this is a screen shot for an idea called

00:01:05,820 --> 00:01:10,290
a light table and that was inspired by a

00:01:08,010 --> 00:01:14,369
talk that Bret Victor gave called

00:01:10,290 --> 00:01:16,759
inventing on principle and he was trying

00:01:14,369 --> 00:01:20,520
to emphasize that creators they need an

00:01:16,759 --> 00:01:23,340
immediate connection with what they were

00:01:20,520 --> 00:01:25,470
like what they're creating and here you

00:01:23,340 --> 00:01:27,990
were seeing a game and we have the

00:01:25,470 --> 00:01:31,680
closure functions which represent parts

00:01:27,990 --> 00:01:33,930
of the game and when I started playing

00:01:31,680 --> 00:01:35,790
around with closure scripts it's not

00:01:33,930 --> 00:01:36,689
really the experience that I got the

00:01:35,790 --> 00:01:39,390
sort of the things that were being

00:01:36,689 --> 00:01:41,790
demonstrated at the time the Dom has

00:01:39,390 --> 00:01:43,649
being convenient left-outs I think that

00:01:41,790 --> 00:01:45,259
was a particular pain point for quite

00:01:43,649 --> 00:01:48,270
some time

00:01:45,259 --> 00:01:52,829
so yeah it's 2018 and it's common to

00:01:48,270 --> 00:01:56,700
come a long way since so yeah so start

00:01:52,829 --> 00:01:58,619
at the beginning what is closure it is a

00:01:56,700 --> 00:02:01,979
functional programming language and by

00:01:58,619 --> 00:02:06,540
that I mean emphasis on writing pure

00:02:01,979 --> 00:02:10,160
functions if I call the same function a

00:02:06,540 --> 00:02:12,420
million times I expect the same output I

00:02:10,160 --> 00:02:13,290
don't have any hidden inputs or hidden

00:02:12,420 --> 00:02:16,620
outputs

00:02:13,290 --> 00:02:19,590
my functions so everything that it does

00:02:16,620 --> 00:02:22,560
it depends on the the explicit list of

00:02:19,590 --> 00:02:25,409
arguments I give it likewise I try to

00:02:22,560 --> 00:02:26,790
avoid side effects and move the side

00:02:25,409 --> 00:02:29,400
effects that you do need to make in your

00:02:26,790 --> 00:02:35,190
application or your program to the

00:02:29,400 --> 00:02:37,440
periphery of the system its targets both

00:02:35,190 --> 00:02:40,739
the JVM that's that's what we refer to

00:02:37,440 --> 00:02:44,060
usually as closure and closure scripts

00:02:40,739 --> 00:02:46,980
targets the browser and node is as well

00:02:44,060 --> 00:02:49,620
the backend language of choice is still

00:02:46,980 --> 00:02:52,620
is closure targeting the JVM but there

00:02:49,620 --> 00:02:55,230
are sort of closure script apps to

00:02:52,620 --> 00:02:58,859
compile to no js' out there

00:02:55,230 --> 00:03:01,739
yes it's dynamically types there are

00:02:58,859 --> 00:03:03,989
optional options for typing in closure

00:03:01,739 --> 00:03:07,230
script but they're not sort of widely

00:03:03,989 --> 00:03:09,530
adopted in the community it's still

00:03:07,230 --> 00:03:12,239
ongoing work there's a really good

00:03:09,530 --> 00:03:13,530
validation library called spec which I

00:03:12,239 --> 00:03:15,629
did entered the language a couple of

00:03:13,530 --> 00:03:17,970
years ago and that's pretty useful but

00:03:15,629 --> 00:03:19,560
just know that you can get some sort of

00:03:17,970 --> 00:03:21,480
family over on some exceptions that you

00:03:19,560 --> 00:03:25,769
wouldn't get in a statically typed

00:03:21,480 --> 00:03:29,250
language and and yes this is I suppose

00:03:25,769 --> 00:03:30,959
the most obvious thing that you see when

00:03:29,250 --> 00:03:32,160
you first presented with closure is that

00:03:30,959 --> 00:03:36,750
it looks different

00:03:32,160 --> 00:03:39,870
it's a lisp and so a lisp was invented

00:03:36,750 --> 00:03:42,599
or they say discovered by this guy John

00:03:39,870 --> 00:03:46,680
McCarthy in the 50s they say discovered

00:03:42,599 --> 00:03:49,069
because really I was so simple that it

00:03:46,680 --> 00:03:51,840
almost couldn't be invented it was the

00:03:49,069 --> 00:03:55,709
the core principles can be described in

00:03:51,840 --> 00:03:58,280
no time at all really this here is a is

00:03:55,709 --> 00:04:01,500
how we would represent a list in Lisp

00:03:58,280 --> 00:04:06,810
it's an element 3 element in a list 1 2

00:04:01,500 --> 00:04:08,730
& 3 3 numbers and Lisp extends that and

00:04:06,810 --> 00:04:12,180
says well why can't we express function

00:04:08,730 --> 00:04:14,250
as a list where the first argument is is

00:04:12,180 --> 00:04:16,829
the function and then everything to the

00:04:14,250 --> 00:04:18,690
right of it are the arguments to their

00:04:16,829 --> 00:04:23,070
function and which is known as prefix

00:04:18,690 --> 00:04:26,530
notation so yeah as the rules of our

00:04:23,070 --> 00:04:28,060
evaluation dead simple

00:04:26,530 --> 00:04:31,840
you value a the arguments that's the

00:04:28,060 --> 00:04:34,810
second position from left to right and

00:04:31,840 --> 00:04:38,320
then you apply the arguments that you've

00:04:34,810 --> 00:04:42,610
just evaluated to the function so this

00:04:38,320 --> 00:04:46,389
what we call in s expression reads

00:04:42,610 --> 00:04:49,470
you would evaluate a a first and then

00:04:46,389 --> 00:04:53,110
multiplies the asterisk and then B be

00:04:49,470 --> 00:04:54,910
asterisk and then those two return

00:04:53,110 --> 00:04:56,500
values would be a fill in surplus and

00:04:54,910 --> 00:05:00,640
then a square root to give you the

00:04:56,500 --> 00:05:02,710
results parentheses are a complaint

00:05:00,640 --> 00:05:04,300
Hunan lispers but they just sort of

00:05:02,710 --> 00:05:05,130
disappear eventually you have to trust

00:05:04,300 --> 00:05:07,870
me on that one

00:05:05,130 --> 00:05:11,440
and this is a really nice profound quote

00:05:07,870 --> 00:05:12,970
which is from the textbook sicp all of

00:05:11,440 --> 00:05:14,740
the formal properties can be just can we

00:05:12,970 --> 00:05:16,360
covered it in an hour like the rules of

00:05:14,740 --> 00:05:17,890
chess after a short time we forget about

00:05:16,360 --> 00:05:20,320
the syntactic details in language

00:05:17,890 --> 00:05:21,970
because there are none and get on with

00:05:20,320 --> 00:05:24,340
the real issues figuring out what we

00:05:21,970 --> 00:05:26,229
want to compute how we will decompose

00:05:24,340 --> 00:05:30,400
problems into manageable parts and how

00:05:26,229 --> 00:05:34,390
we will work on the parts I can't that's

00:05:30,400 --> 00:05:35,919
so true really working with this at the

00:05:34,390 --> 00:05:39,250
core of closure

00:05:35,919 --> 00:05:42,250
is the idea of immutability which i

00:05:39,250 --> 00:05:44,979
think is also so heavily prevalent in in

00:05:42,250 --> 00:05:48,900
the JavaScript community as well we

00:05:44,979 --> 00:05:53,350
prefer to program with immutable values

00:05:48,900 --> 00:05:55,450
rather than objects and the main

00:05:53,350 --> 00:05:57,700
motivation for that originally was for

00:05:55,450 --> 00:06:00,490
concurrency reasons if you've got lots

00:05:57,700 --> 00:06:02,740
of processes which mutating shared state

00:06:00,490 --> 00:06:04,450
and you stop your program at any point

00:06:02,740 --> 00:06:07,030
then it's very very difficult to see

00:06:04,450 --> 00:06:08,890
exactly what's going on and understand

00:06:07,030 --> 00:06:11,919
problems if you are having problems win

00:06:08,890 --> 00:06:13,539
and you often are in Australian

00:06:11,919 --> 00:06:13,990
environments obviously that's not a

00:06:13,539 --> 00:06:16,320
problem

00:06:13,990 --> 00:06:19,840
in in JavaScript it's single threaded

00:06:16,320 --> 00:06:22,360
but you'll just have to give it a give

00:06:19,840 --> 00:06:26,620
it a try and realize that it's it's much

00:06:22,360 --> 00:06:30,940
much easier to to reason about if I if I

00:06:26,620 --> 00:06:34,180
define the food to be a string bar I can

00:06:30,940 --> 00:06:36,580
be sure that for the entire duration of

00:06:34,180 --> 00:06:40,330
my program it's it's not going to change

00:06:36,580 --> 00:06:43,900
and it's a really nice property to have

00:06:40,330 --> 00:06:45,669
closure is built around these I say

00:06:43,900 --> 00:06:48,030
mainly for immutable data structures

00:06:45,669 --> 00:06:51,220
that you'll find closure code bases

00:06:48,030 --> 00:06:53,260
you've got on the Left we've got the

00:06:51,220 --> 00:06:56,430
functions which evaluate to the literal

00:06:53,260 --> 00:06:59,220
syntax how you would easily express

00:06:56,430 --> 00:07:01,870
these data structures in closure code

00:06:59,220 --> 00:07:04,860
and they have this sort of semantics

00:07:01,870 --> 00:07:07,870
that you would expect from these sort of

00:07:04,860 --> 00:07:10,090
implementations of data structures you

00:07:07,870 --> 00:07:13,540
know a set has distinct elements for

00:07:10,090 --> 00:07:16,630
example the exception of course is that

00:07:13,540 --> 00:07:24,910
they are immutable they cannot be

00:07:16,630 --> 00:07:26,650
changed and if I apply a function to one

00:07:24,910 --> 00:07:30,010
of these data structures it's going to

00:07:26,650 --> 00:07:31,479
give me a new new so this is a vector

00:07:30,010 --> 00:07:33,389
and I'm using a function called con

00:07:31,479 --> 00:07:37,470
share which means is short for conjoin

00:07:33,389 --> 00:07:39,550
adding six onto a vector one to five

00:07:37,470 --> 00:07:41,530
that's going to give me an entire new

00:07:39,550 --> 00:07:46,660
vector and we don't need to resort to

00:07:41,530 --> 00:07:48,460
copying for this because we can do some

00:07:46,660 --> 00:07:51,810
fancy stuff underneath the hood because

00:07:48,460 --> 00:07:55,210
it's immutable we know that we can share

00:07:51,810 --> 00:07:59,860
states between the old version and the

00:07:55,210 --> 00:08:01,060
new version so here six is the only

00:07:59,860 --> 00:08:03,430
thing that we're actually adding into

00:08:01,060 --> 00:08:05,139
memory and we're referring to the one to

00:08:03,430 --> 00:08:08,320
five elements from the previous data

00:08:05,139 --> 00:08:10,870
structure and it's a really really

00:08:08,320 --> 00:08:14,880
interesting implementation and immutable

00:08:10,870 --> 00:08:19,840
jss is basically that ported to

00:08:14,880 --> 00:08:21,910
JavaScript the trade-off is if we don't

00:08:19,840 --> 00:08:23,650
get constant time lookup s-- because we

00:08:21,910 --> 00:08:25,210
have to traverse a tree but the tree is

00:08:23,650 --> 00:08:29,860
really shallow it might as well be

00:08:25,210 --> 00:08:31,240
constant time oh and there are is an

00:08:29,860 --> 00:08:35,830
abundance of functions in the closure

00:08:31,240 --> 00:08:37,719
core so cons for example also works on

00:08:35,830 --> 00:08:39,669
lists it all work on maps it all work on

00:08:37,719 --> 00:08:42,159
everything and that's true of a lot of

00:08:39,669 --> 00:08:43,659
the functions in closure you know better

00:08:42,159 --> 00:08:45,400
to have a hundred functions that works

00:08:43,659 --> 00:08:48,600
on one data structure than ten functions

00:08:45,400 --> 00:08:48,600
on tend on those data structures

00:08:48,830 --> 00:08:53,580
so if you do need to mutate state or

00:08:51,510 --> 00:08:58,440
share state across processes you do have

00:08:53,580 --> 00:09:00,750
reference sites in closure so closure on

00:08:58,440 --> 00:09:02,040
the JVM has atoms agents and refs

00:09:00,750 --> 00:09:06,510
although the latter two are rarely ever

00:09:02,040 --> 00:09:08,880
used closure script just just atoms are

00:09:06,510 --> 00:09:11,040
implemented and the underlying

00:09:08,880 --> 00:09:13,230
implementation is very very simple this

00:09:11,040 --> 00:09:14,899
is what it looks like in JavaScript it's

00:09:13,230 --> 00:09:17,730
just a really a way of having a

00:09:14,899 --> 00:09:19,680
implementing assignment in closure but

00:09:17,730 --> 00:09:21,450
we had to explicitly do it here but

00:09:19,680 --> 00:09:23,880
using this atom this is the kind of

00:09:21,450 --> 00:09:26,339
preferred way of doing it where you you

00:09:23,880 --> 00:09:33,899
you apply a function to the exist the

00:09:26,339 --> 00:09:36,029
current state of a to get a new state if

00:09:33,899 --> 00:09:39,149
you want to learn more about closure I

00:09:36,029 --> 00:09:41,700
can't recommend rich hickies talks they

00:09:39,149 --> 00:09:43,529
they they I think pretty much changed my

00:09:41,700 --> 00:09:46,200
career when I watched them when I was a

00:09:43,529 --> 00:09:47,970
C++ developer and if you're still not

00:09:46,200 --> 00:09:50,910
convinced about functional programming

00:09:47,970 --> 00:09:53,160
then there's a really good paper called

00:09:50,910 --> 00:10:02,490
out of the Tar Pits that's also

00:09:53,160 --> 00:10:05,459
excellent so closure scripts it it

00:10:02,490 --> 00:10:07,890
transpires JavaScript so this is a

00:10:05,459 --> 00:10:09,630
closure function above here and this is

00:10:07,890 --> 00:10:14,550
what it spits out you can see this is

00:10:09,630 --> 00:10:16,560
quite a simple transformation here the

00:10:14,550 --> 00:10:19,320
jerk the closure compiler spits out

00:10:16,560 --> 00:10:23,399
quite naive JavaScript and in order for

00:10:19,320 --> 00:10:25,709
it to be fast efficient you know size

00:10:23,399 --> 00:10:28,440
and speed we run it through the Google

00:10:25,709 --> 00:10:32,670
closure compiler and that does a good

00:10:28,440 --> 00:10:36,750
job of minifying the the names of the

00:10:32,670 --> 00:10:38,279
functions not only that it also analyzes

00:10:36,750 --> 00:10:40,079
the code and it's much it's much much

00:10:38,279 --> 00:10:41,760
faster than it's a Uggla file which is

00:10:40,079 --> 00:10:43,560
just a minute fire it actually does

00:10:41,760 --> 00:10:48,089
analysis and it will strip away stuff

00:10:43,560 --> 00:10:49,940
that you don't need unfortunately it

00:10:48,089 --> 00:10:53,130
does come at a cost

00:10:49,940 --> 00:10:55,649
Google closure compiler is only its

00:10:53,130 --> 00:10:58,050
world view is only what you feed into it

00:10:55,649 --> 00:11:00,960
for compilation so if you're referencing

00:10:58,050 --> 00:11:03,580
a library in JavaScript

00:11:00,960 --> 00:11:05,340
that Google closure a pilot isn't aware

00:11:03,580 --> 00:11:08,950
of and then you manage all the names

00:11:05,340 --> 00:11:10,780
than any references in your code to a

00:11:08,950 --> 00:11:13,480
function that's external from your codes

00:11:10,780 --> 00:11:15,580
will be managed to so do stuff here

00:11:13,480 --> 00:11:18,370
might become like MB or whatever and

00:11:15,580 --> 00:11:20,560
then your code will break and so for a

00:11:18,370 --> 00:11:24,190
long time we had to do was create these

00:11:20,560 --> 00:11:28,420
externs files which has please don't

00:11:24,190 --> 00:11:33,220
manage these names in it and that was a

00:11:28,420 --> 00:11:37,840
real real pain in the ass see what CIJ

00:11:33,220 --> 00:11:39,160
SJS was an effort to take libraries

00:11:37,840 --> 00:11:40,450
really really nice libraries and

00:11:39,160 --> 00:11:42,760
JavaScript community I mean it's the

00:11:40,450 --> 00:11:46,810
largest ecosystem on the planet really

00:11:42,760 --> 00:11:48,340
and and and making them suitable package

00:11:46,810 --> 00:11:50,980
them up into jars for putting into

00:11:48,340 --> 00:11:54,220
closure Script projects with all the X

00:11:50,980 --> 00:11:55,630
turns in there but every time you want

00:11:54,220 --> 00:11:58,090
to use a JavaScript library it was a

00:11:55,630 --> 00:12:00,160
real pain to actually create one of

00:11:58,090 --> 00:12:01,840
these packages submit a PR for it

00:12:00,160 --> 00:12:05,650
getting merged in and then using it in

00:12:01,840 --> 00:12:07,150
your own projects and unfortunately lot

00:12:05,650 --> 00:12:09,100
as of last year

00:12:07,150 --> 00:12:12,430
this is no this is a problem at the past

00:12:09,100 --> 00:12:15,310
we can just use NPM libraries and

00:12:12,430 --> 00:12:19,420
include those they get passed actually

00:12:15,310 --> 00:12:22,120
into the closure script compiler as for

00:12:19,420 --> 00:12:23,470
the Google closure compiler so because

00:12:22,120 --> 00:12:24,940
the Google closure compiler is aware of

00:12:23,470 --> 00:12:25,800
all these dependencies it can optimize

00:12:24,940 --> 00:12:28,830
those too

00:12:25,800 --> 00:12:32,890
and we've also got a first-class sort of

00:12:28,830 --> 00:12:37,020
es6 imports in in closure namespaces so

00:12:32,890 --> 00:12:39,760
we can actually acquire a module in es6

00:12:37,020 --> 00:12:42,550
module and then reference it in the code

00:12:39,760 --> 00:12:44,200
and it's dead simple we don't even have

00:12:42,550 --> 00:12:46,930
to deal with externs fast anymore we can

00:12:44,200 --> 00:12:49,330
the only other thing we have to do is to

00:12:46,930 --> 00:12:54,420
add some type ins if we're dealing with

00:12:49,330 --> 00:12:58,920
JavaScript objects in enclosure scripts

00:12:54,420 --> 00:13:02,620
so if we want to really nice way of

00:12:58,920 --> 00:13:05,890
representing HTML in closure code is

00:13:02,620 --> 00:13:07,860
using data structures I didn't really

00:13:05,890 --> 00:13:10,519
mention actually back to there but Lisp

00:13:07,860 --> 00:13:13,040
code is data

00:13:10,519 --> 00:13:17,540
emphasize that point in our function is

00:13:13,040 --> 00:13:22,279
a list and here we're representing HTML

00:13:17,540 --> 00:13:26,240
as nested vectors and maps so maps to

00:13:22,279 --> 00:13:29,930
describe attributes and other bits just

00:13:26,240 --> 00:13:32,029
to to to to represent the sort of

00:13:29,930 --> 00:13:35,740
national structure of a Dom you can see

00:13:32,029 --> 00:13:38,059
I hope how this translates over here and

00:13:35,740 --> 00:13:40,129
this is not the only way of representing

00:13:38,059 --> 00:13:44,839
HTML in closure code but it's a really

00:13:40,129 --> 00:13:46,939
nice popular way of doing it so I guess

00:13:44,839 --> 00:13:48,649
the question next question is how do we

00:13:46,939 --> 00:13:51,410
actually work with the Dom how do we

00:13:48,649 --> 00:13:52,970
manipulate it there are a number ways

00:13:51,410 --> 00:13:58,639
you can there are number of options you

00:13:52,970 --> 00:14:01,100
have in in in closure script but I'd say

00:13:58,639 --> 00:14:04,540
the one that we're using is it's quite

00:14:01,100 --> 00:14:08,959
sort of well-trodden pass at the bottom

00:14:04,540 --> 00:14:11,660
is react so pleasure crypt has really

00:14:08,959 --> 00:14:14,110
good support for done rendering

00:14:11,660 --> 00:14:17,509
frameworks so long as they are react

00:14:14,110 --> 00:14:19,059
it's a really really nice fit so that

00:14:17,509 --> 00:14:22,790
handles all of the reconciliation

00:14:19,059 --> 00:14:27,350
between our virtual representation of

00:14:22,790 --> 00:14:29,829
the DOM and the Dom itself on top of

00:14:27,350 --> 00:14:35,559
that we have a library called reagent

00:14:29,829 --> 00:14:39,889
which allows you to represent hiccough

00:14:35,559 --> 00:14:42,980
functions that return hiccup and so

00:14:39,889 --> 00:14:46,250
react components as functions and then

00:14:42,980 --> 00:14:48,019
reframe which is essentially redux it's

00:14:46,250 --> 00:14:53,300
a layer on top to deal with dealing with

00:14:48,019 --> 00:14:55,279
messages and subscribing to change so

00:14:53,300 --> 00:14:59,389
yeah it's a really good fit closure and

00:14:55,279 --> 00:15:02,569
react I say why I mean the underlying

00:14:59,389 --> 00:15:05,449
algorithm is is just it's very very

00:15:02,569 --> 00:15:08,870
functional we'd have a function that

00:15:05,449 --> 00:15:11,120
takes props are states to give a

00:15:08,870 --> 00:15:13,819
representation of the virtual Dom and we

00:15:11,120 --> 00:15:15,679
do it again with a different where the

00:15:13,819 --> 00:15:19,790
state has changed and then we just if

00:15:15,679 --> 00:15:24,080
the two together and the nice thing

00:15:19,790 --> 00:15:27,890
about working with react in closure is

00:15:24,080 --> 00:15:32,570
that because the props the states is

00:15:27,890 --> 00:15:34,610
immutable it's much much faster to

00:15:32,570 --> 00:15:36,550
compare when things have changed when

00:15:34,610 --> 00:15:39,230
the props have changed

00:15:36,550 --> 00:15:46,220
so yeah this sir is that there's a good

00:15:39,230 --> 00:15:49,460
speed speed up there so reagent as I

00:15:46,220 --> 00:15:52,730
said represents a react component as a

00:15:49,460 --> 00:15:55,720
function this is hiccup this is a

00:15:52,730 --> 00:15:59,240
function to return to hiccup reagent

00:15:55,720 --> 00:16:00,260
extends the closure script atom which is

00:15:59,240 --> 00:16:05,230
as I said it's just a bit like

00:16:00,260 --> 00:16:07,910
assignment to make it reactive so this

00:16:05,230 --> 00:16:11,720
this counting components at the bottom

00:16:07,910 --> 00:16:14,390
here is being dereferenced and every

00:16:11,720 --> 00:16:18,650
time this this click count Adam is

00:16:14,390 --> 00:16:24,380
dereferenced oh sorry who's changed this

00:16:18,650 --> 00:16:29,390
reagent the sorry the atom is

00:16:24,380 --> 00:16:30,920
context-aware and will re invoke this

00:16:29,390 --> 00:16:35,330
counting component render function

00:16:30,920 --> 00:16:37,570
whenever its value changes which is a

00:16:35,330 --> 00:16:40,250
really really nice way of working with

00:16:37,570 --> 00:16:42,710
working with react without having to

00:16:40,250 --> 00:16:44,630
sort of get involved in some of the

00:16:42,710 --> 00:16:46,400
details of the API a lot of the time

00:16:44,630 --> 00:16:48,740
we're writing render functions that

00:16:46,400 --> 00:16:51,710
don't don't use life cycles in fact I

00:16:48,740 --> 00:16:53,060
say most of them don't but there's no

00:16:51,710 --> 00:16:55,250
loss of expressiveness at all

00:16:53,060 --> 00:16:58,580
we can still use all of those sort of

00:16:55,250 --> 00:17:00,760
react 16 features so that's not not a

00:16:58,580 --> 00:17:04,400
concern if you're thinking about using

00:17:00,760 --> 00:17:12,050
using reagents in a complicated react

00:17:04,400 --> 00:17:13,400
project and and reframe yeah this is

00:17:12,050 --> 00:17:16,670
this is very very very much similar to

00:17:13,400 --> 00:17:20,270
redux the idea is we put all of our

00:17:16,670 --> 00:17:22,490
state in one place and we transform that

00:17:20,270 --> 00:17:29,120
state using a series of event handlers

00:17:22,490 --> 00:17:32,300
that we define and we we apply a

00:17:29,120 --> 00:17:35,450
function taking the state as argument

00:17:32,300 --> 00:17:39,500
and produce new states

00:17:35,450 --> 00:17:41,929
and our entire sort of the journey from

00:17:39,500 --> 00:17:44,710
the start of our for our starter or

00:17:41,929 --> 00:17:47,360
applications where any point can be

00:17:44,710 --> 00:17:48,559
deterministically built up by just

00:17:47,360 --> 00:17:56,529
applying these or reducing these

00:17:48,559 --> 00:18:01,029
functions and in order to render these

00:17:56,529 --> 00:18:01,029
to render the state of the application

00:18:01,179 --> 00:18:07,010
we we just do the same we almost we

00:18:05,240 --> 00:18:08,570
apply a function to our state's to

00:18:07,010 --> 00:18:10,100
return value which is suitable for

00:18:08,570 --> 00:18:14,120
rendering that gets passed to our

00:18:10,100 --> 00:18:22,250
reagent render functions which we know

00:18:14,120 --> 00:18:24,139
props in in react parlance so an event

00:18:22,250 --> 00:18:29,049
handler this is like a JSON click event

00:18:24,139 --> 00:18:33,260
and when they have been handler triggers

00:18:29,049 --> 00:18:34,730
will dispatch an event handler

00:18:33,260 --> 00:18:37,490
registered up get up they click about

00:18:34,730 --> 00:18:41,779
click count sorry with the value of the

00:18:37,490 --> 00:18:45,289
event and we define a event handler like

00:18:41,779 --> 00:18:48,409
this DB here we take the DB is argument

00:18:45,289 --> 00:18:50,450
plus any any other arguments so click

00:18:48,409 --> 00:18:52,519
count here and then this function

00:18:50,450 --> 00:18:55,309
returns a map one of the keys in the map

00:18:52,519 --> 00:18:59,360
is the MS to change DB or a new version

00:18:55,309 --> 00:19:02,029
of a new value of the DB this bit at the

00:18:59,360 --> 00:19:06,279
bottom here does something extra we are

00:19:02,029 --> 00:19:10,789
making an xhr request to this API

00:19:06,279 --> 00:19:13,929
resource this function does not make the

00:19:10,789 --> 00:19:16,580
request it just contains instructions to

00:19:13,929 --> 00:19:20,750
to make the request and it's handled by

00:19:16,580 --> 00:19:22,279
a downstream effect Handler and this is

00:19:20,750 --> 00:19:25,669
the way that reframe encourages you to

00:19:22,279 --> 00:19:28,970
rights to deal with side effects is that

00:19:25,669 --> 00:19:30,919
you just say look this is how I want you

00:19:28,970 --> 00:19:33,700
to handle NEX HR request and this is

00:19:30,919 --> 00:19:36,559
these are instructions to do it and the

00:19:33,700 --> 00:19:39,500
benefit in doing that is said your your

00:19:36,559 --> 00:19:43,370
code is so much much easier to test you

00:19:39,500 --> 00:19:46,940
know all of our tests Ile it run on the

00:19:43,370 --> 00:19:48,620
JVM all over most of our UI to a unit

00:19:46,940 --> 00:19:51,020
USS sorry

00:19:48,620 --> 00:19:53,720
and we we essentially just like navigate

00:19:51,020 --> 00:19:56,540
we have helped us to navigate to a route

00:19:53,720 --> 00:19:58,580
that triggers a bunch of reframe event

00:19:56,540 --> 00:20:01,580
handler functions and then we subscribe

00:19:58,580 --> 00:20:03,590
to the result and we can stub out effect

00:20:01,580 --> 00:20:05,900
handlers however we like or or mock them

00:20:03,590 --> 00:20:10,070
out and inject behavior however we want

00:20:05,900 --> 00:20:13,580
to so it's really really powerful and

00:20:10,070 --> 00:20:16,340
the subscriptions whereas before the

00:20:13,580 --> 00:20:18,800
example I showed you with reagents we

00:20:16,340 --> 00:20:20,240
have a reagent atom and then we do

00:20:18,800 --> 00:20:23,240
reference item in the render function

00:20:20,240 --> 00:20:25,340
like that to do this with like the red

00:20:23,240 --> 00:20:27,950
direct with the app the DB which can be

00:20:25,340 --> 00:20:30,470
get quite big and it's not really in the

00:20:27,950 --> 00:20:31,880
format in which we want to render it can

00:20:30,470 --> 00:20:35,530
we could be a bit cumbersome and it's

00:20:31,880 --> 00:20:38,210
not going to scale so with reframe

00:20:35,530 --> 00:20:40,610
subscriptions we just replace the

00:20:38,210 --> 00:20:42,500
reagent atom with a subscription that

00:20:40,610 --> 00:20:44,900
we've registered that's registered to

00:20:42,500 --> 00:20:48,350
this keyword click counts and when we do

00:20:44,900 --> 00:20:52,610
ref it's will get the value that's

00:20:48,350 --> 00:20:55,550
returned by this function and that is

00:20:52,610 --> 00:20:59,540
what the the the click count

00:20:55,550 --> 00:21:02,450
subscription returns but this can be any

00:20:59,540 --> 00:21:04,760
as simple as complex as you like really

00:21:02,450 --> 00:21:07,820
and the really nice thing about reframes

00:21:04,760 --> 00:21:09,110
descriptions that deduplicated so if

00:21:07,820 --> 00:21:13,460
you've got lots of elements on the page

00:21:09,110 --> 00:21:16,220
which depend on the same the same

00:21:13,460 --> 00:21:19,040
subscriptions then only one that that

00:21:16,220 --> 00:21:22,670
code will only run once once the app DB

00:21:19,040 --> 00:21:29,720
changes so it's quite efficient a nice

00:21:22,670 --> 00:21:33,890
reactive way of constructing the code so

00:21:29,720 --> 00:21:35,060
i'm going to do a little demo now of one

00:21:33,890 --> 00:21:38,890
of the projects that we're working on at

00:21:35,060 --> 00:21:40,820
the moment a single page application and

00:21:38,890 --> 00:21:46,300
really just to show you some of the

00:21:40,820 --> 00:21:46,300
tools that we're using i can get

00:21:46,890 --> 00:22:00,150
yeah cool so one of the first is is a

00:21:56,730 --> 00:22:03,480
closure I guess we could call most like

00:22:00,150 --> 00:22:06,120
a pattern library called dev cards and

00:22:03,480 --> 00:22:08,880
the idea is that we we build our

00:22:06,120 --> 00:22:14,010
application out of components out

00:22:08,880 --> 00:22:15,540
reusable components and we can see we

00:22:14,010 --> 00:22:16,620
can develop this component in isolation

00:22:15,540 --> 00:22:19,560
we don't have to go through some

00:22:16,620 --> 00:22:22,290
rigorous sort of annoying amount of

00:22:19,560 --> 00:22:26,190
steps to to to get this component to

00:22:22,290 --> 00:22:28,950
appear on the screen and you know I can

00:22:26,190 --> 00:22:31,950
I can I can edit it and I can see the

00:22:28,950 --> 00:22:33,930
changes appear in real time and that's a

00:22:31,950 --> 00:22:36,720
really nice way of working and we've got

00:22:33,930 --> 00:22:38,220
quite a few in our latest project we've

00:22:36,720 --> 00:22:41,100
got quite a few different components

00:22:38,220 --> 00:22:48,060
that where we have here is really useful

00:22:41,100 --> 00:22:49,580
reference to see how things work so this

00:22:48,060 --> 00:22:53,100
is a work in progress

00:22:49,580 --> 00:22:58,970
speaking improve this is sandy the

00:22:53,100 --> 00:22:58,970
avatar and if I get

00:23:05,910 --> 00:23:11,700
I'll hold on don't don't kill you a nice

00:23:16,050 --> 00:23:22,150
cool so a really really nice wet

00:23:19,600 --> 00:23:25,540
interactive way of overwriting enclosure

00:23:22,150 --> 00:23:30,040
scripts is is by connecting a browser

00:23:25,540 --> 00:23:31,750
repple and so i can send commands to the

00:23:30,040 --> 00:23:36,490
browser just like I would in the

00:23:31,750 --> 00:23:40,870
inspector in the console enclosure so

00:23:36,490 --> 00:23:50,620
yeah it's really useful also if I want

00:23:40,870 --> 00:23:54,120
to evaluate I want to evaluate it's

00:23:50,620 --> 00:23:54,120
really hard to program behind your bag

00:23:58,290 --> 00:24:03,630
evaluate code it takes a second or two

00:24:04,590 --> 00:24:11,880
but I don't really I don't really notice

00:24:07,690 --> 00:24:11,880
the delay you know anymore

00:24:12,240 --> 00:24:23,380
and what else yeah there's a tool called

00:24:20,590 --> 00:24:26,080
reef risk which helps with debugging

00:24:23,380 --> 00:24:28,540
refre reframing applications which is

00:24:26,080 --> 00:24:30,900
really useful maybe I can kind of drag

00:24:28,540 --> 00:24:30,900
this up

00:24:34,120 --> 00:24:43,440
here we go you can see this is the state

00:24:38,320 --> 00:24:45,669
of the app at the moment as I perform

00:24:43,440 --> 00:24:48,309
event handlers if one saw a trigger

00:24:45,669 --> 00:24:50,679
event handlers they will appear down the

00:24:48,309 --> 00:24:55,480
right here the last one I did was

00:24:50,679 --> 00:24:57,610
triggered an animation and we can see

00:24:55,480 --> 00:25:01,179
all the subscriptions as well there are

00:24:57,610 --> 00:25:08,110
active on the page which which is really

00:25:01,179 --> 00:25:12,850
really useful when when debugging there

00:25:08,110 --> 00:25:16,929
is a tool called 10x which is a sort of

00:25:12,850 --> 00:25:20,350
revamp version of Reef risky looks like

00:25:16,929 --> 00:25:22,690
this but we're not quite using it yet

00:25:20,350 --> 00:25:26,409
because it's a little bit buggy it's

00:25:22,690 --> 00:25:28,419
very very impressive or what it does it

00:25:26,409 --> 00:25:30,909
allows it you can see some code here and

00:25:28,419 --> 00:25:34,270
you can you can actually see proper

00:25:30,909 --> 00:25:35,110
tracing and these windows but yeah it's

00:25:34,270 --> 00:25:37,240
not quite there yet

00:25:35,110 --> 00:25:41,610
I'm really excited though once they get

00:25:37,240 --> 00:25:46,779
on top of the issues to start using it

00:25:41,610 --> 00:25:53,440
and I suppose just to finish off just to

00:25:46,779 --> 00:25:55,649
say like the the thing which is a

00:25:53,440 --> 00:25:59,340
completely changing experience lately is

00:25:55,649 --> 00:26:05,529
moving from the ALJ's build tools to

00:25:59,340 --> 00:26:07,480
shadow clgs it is a project by a guy

00:26:05,529 --> 00:26:10,779
called Thomas Heller and he's been put a

00:26:07,480 --> 00:26:13,210
lot of effort into it and he's the

00:26:10,779 --> 00:26:15,820
aggressive cashing the NPM dependency

00:26:13,210 --> 00:26:17,169
supports and some of the other sort of

00:26:15,820 --> 00:26:20,649
advanced features that you need when

00:26:17,169 --> 00:26:25,149
building a single page application for

00:26:20,649 --> 00:26:27,309
the masses like code splitting and and

00:26:25,149 --> 00:26:31,270
fingerprinting assets it's all kind of

00:26:27,309 --> 00:26:36,220
there and it's thanks to him so yeah I'd

00:26:31,270 --> 00:26:38,289
say like it's a serious contender now as

00:26:36,220 --> 00:26:41,580
when I started writing single pay

00:26:38,289 --> 00:26:41,580
expectations a couple of years ago

00:26:41,789 --> 00:26:47,049
seriously it was quite painful the areas

00:26:45,100 --> 00:26:47,890
of it some of it was a joy the language

00:26:47,049 --> 00:26:50,650
is a joy but

00:26:47,890 --> 00:26:51,850
but now sort of everything just seems to

00:26:50,650 --> 00:26:54,430
fit together quite nicely so I'd

00:26:51,850 --> 00:26:55,120
encourage you to go out and give it a go

00:26:54,430 --> 00:27:00,530
all right thanks

00:26:55,120 --> 00:27:00,530

YouTube URL: https://www.youtube.com/watch?v=ZZgeBBsHExU


