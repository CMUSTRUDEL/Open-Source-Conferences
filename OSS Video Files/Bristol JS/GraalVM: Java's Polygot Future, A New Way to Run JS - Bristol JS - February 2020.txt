Title: GraalVM: Java's Polygot Future, A New Way to Run JS - Bristol JS - February 2020
Publication date: 2020-03-10
Playlist: Bristol JS
Description: 
	Kris Foster - Lightening talk - GraalVM - Java's Polyglot future, or, new ways to run JS

A quick intro into GraalVM, the new polygot run time from Oracle that can run JS / Node , Python, Ruby and how you can use it to build Polyglot programs

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:05,879
yeah hi I'm Chris and I work Oracle and

00:00:03,000 --> 00:00:08,550
I'm gonna give you a lightning under 10

00:00:05,879 --> 00:00:10,920
minutes hopefully if I don't ramble talk

00:00:08,550 --> 00:00:14,070
about Groff VM and there's any anybody

00:00:10,920 --> 00:00:16,170
heard about it no I come from a Java

00:00:14,070 --> 00:00:18,359
background so it's probably no more

00:00:16,170 --> 00:00:20,640
comment and for people to know about it

00:00:18,359 --> 00:00:24,210
there but basically it's a new language

00:00:20,640 --> 00:00:26,070
runtime from Oracle it's an extension to

00:00:24,210 --> 00:00:27,990
the existing you know Java hotspot

00:00:26,070 --> 00:00:29,670
runtimes which people have been running

00:00:27,990 --> 00:00:31,610
Java programs on for years it comes in

00:00:29,670 --> 00:00:34,680
an open source completely open source

00:00:31,610 --> 00:00:36,600
community supported version as well as a

00:00:34,680 --> 00:00:38,579
you know an enterprise one for those who

00:00:36,600 --> 00:00:40,980
want extra features but it's got some

00:00:38,579 --> 00:00:42,300
interesting and exciting features in it

00:00:40,980 --> 00:00:44,700
that I thought might be interesting to

00:00:42,300 --> 00:00:47,969
people here to stay they might not be do

00:00:44,700 --> 00:00:49,559
tell me at the end I have to put a safe

00:00:47,969 --> 00:00:51,180
harbor statement on the front because I

00:00:49,559 --> 00:00:53,670
work for a recall so nothing in this

00:00:51,180 --> 00:00:55,620
talk can be taken it like exactly

00:00:53,670 --> 00:00:57,260
indicating what Oracle will do but I'm

00:00:55,620 --> 00:01:00,989
sure you've seen this before

00:00:57,260 --> 00:01:03,329
so what what is guava and why should you

00:01:00,989 --> 00:01:06,570
care I know why I care but white who

00:01:03,329 --> 00:01:08,430
care well basically it's it's kind of a

00:01:06,570 --> 00:01:12,420
concept of a universal language runtime

00:01:08,430 --> 00:01:14,490
so the world is changing people are

00:01:12,420 --> 00:01:15,689
running applications or building stacks

00:01:14,490 --> 00:01:17,340
out of lots of different kinds of

00:01:15,689 --> 00:01:18,840
programming languages for lots of

00:01:17,340 --> 00:01:21,119
different reasons you want to go you

00:01:18,840 --> 00:01:22,409
might have Python Ruby JavaScript Java

00:01:21,119 --> 00:01:24,540
and they've all got their place and

00:01:22,409 --> 00:01:27,030
they've all got their own specific set

00:01:24,540 --> 00:01:28,770
of things they're good at and some

00:01:27,030 --> 00:01:30,299
things they're less good at so the

00:01:28,770 --> 00:01:33,380
world's changing and people are starting

00:01:30,299 --> 00:01:36,000
to program in lots more technologies so

00:01:33,380 --> 00:01:37,740
the idea behind Gras one of the ideas

00:01:36,000 --> 00:01:41,100
behind Gua was that we could build one

00:01:37,740 --> 00:01:43,049
language runtime that enables you to put

00:01:41,100 --> 00:01:44,520
many languages and support many ways of

00:01:43,049 --> 00:01:47,159
programming on top of it and to make

00:01:44,520 --> 00:01:49,439
them all fast because we can use the

00:01:47,159 --> 00:01:51,420
Java technology the JIT technology

00:01:49,439 --> 00:01:53,610
within the Java Runtime to make things

00:01:51,420 --> 00:01:56,159
very very fast and I'll explain how that

00:01:53,610 --> 00:01:57,930
how we do that a little bit but

00:01:56,159 --> 00:02:01,649
basically it currently supports fully

00:01:57,930 --> 00:02:04,649
node JavaScript Jehova obviously Python

00:02:01,649 --> 00:02:08,009
3 to a large extent Ruby is almost

00:02:04,649 --> 00:02:10,590
complete our is you know fast along the

00:02:08,009 --> 00:02:11,879
way to being available and it runs

00:02:10,590 --> 00:02:13,060
faster than like the canoe

00:02:11,879 --> 00:02:15,370
implementation

00:02:13,060 --> 00:02:18,190
you can run see on it lots of different

00:02:15,370 --> 00:02:21,190
languages and they can all interrupt so

00:02:18,190 --> 00:02:22,990
you can have a Java program using

00:02:21,190 --> 00:02:26,020
javascript calling JavaScript or you can

00:02:22,990 --> 00:02:28,060
build an express node app into which you

00:02:26,020 --> 00:02:31,000
can natively just include some Java and

00:02:28,060 --> 00:02:33,970
the the node runtime that comes with

00:02:31,000 --> 00:02:35,560
graal will sort out how all of that

00:02:33,970 --> 00:02:38,080
magic happens basically your Java

00:02:35,560 --> 00:02:40,060
objects that you create are usable and

00:02:38,080 --> 00:02:41,740
you don't have to do any kind of clever

00:02:40,060 --> 00:02:45,010
unboxing there's no marshalling or

00:02:41,740 --> 00:02:47,050
anything like that so he goes a little

00:02:45,010 --> 00:02:49,210
picture to show you just how wonderful

00:02:47,050 --> 00:02:52,090
is in the world of graham yet we've got

00:02:49,210 --> 00:02:53,800
node support so twelve point fourteen I

00:02:52,090 --> 00:02:55,390
think isn't it yeah it's a current

00:02:53,800 --> 00:02:58,720
version that we we ship within the

00:02:55,390 --> 00:03:01,000
latest version at 2019

00:02:58,720 --> 00:03:03,490
you know script support with some

00:03:01,000 --> 00:03:05,260
features of 2020 we're constantly adding

00:03:03,490 --> 00:03:08,110
new features and trying to make things

00:03:05,260 --> 00:03:10,930
as standards compliant as possible we

00:03:08,110 --> 00:03:12,790
test against like ten oh sorry hundred

00:03:10,930 --> 00:03:15,100
thousand it's 90 something thousand last

00:03:12,790 --> 00:03:16,989
time a hundred thousand NPM packages of

00:03:15,100 --> 00:03:19,600
which like ninety percent pass with no

00:03:16,989 --> 00:03:21,310
errors at all and there are some that

00:03:19,600 --> 00:03:24,580
there are some slight differences

00:03:21,310 --> 00:03:26,709
between node and our version of node but

00:03:24,580 --> 00:03:28,540
that's to do with very sort of internal

00:03:26,709 --> 00:03:30,519
stuff and usually won't affect you if

00:03:28,540 --> 00:03:33,220
you're using kind of users what I think

00:03:30,519 --> 00:03:36,519
of as user space type libraries packages

00:03:33,220 --> 00:03:39,700
performance wise for the node runtime it

00:03:36,519 --> 00:03:41,769
because it's a JIT technology it warms

00:03:39,700 --> 00:03:44,200
up so it pays attention to what you're

00:03:41,769 --> 00:03:45,550
doing what environment it's executing

00:03:44,200 --> 00:03:47,950
and what data is coming through and it

00:03:45,550 --> 00:03:48,910
makes assumptions about your code you

00:03:47,950 --> 00:03:50,769
know what's going to run what's not

00:03:48,910 --> 00:03:52,420
going to run and that's how it it to

00:03:50,769 --> 00:03:54,610
optimize it and make it fast

00:03:52,420 --> 00:03:58,390
so v8 is always going to be faster

00:03:54,610 --> 00:04:00,430
straight up but given given some warm-up

00:03:58,390 --> 00:04:02,040
time some exposure to your data the

00:04:00,430 --> 00:04:04,690
performance currently of the node

00:04:02,040 --> 00:04:07,720
runtime should start to match the v8

00:04:04,690 --> 00:04:09,400
runtime so and and it's an area that

00:04:07,720 --> 00:04:10,900
we're in a performance is something we

00:04:09,400 --> 00:04:13,120
take very seriously and it's like one of

00:04:10,900 --> 00:04:14,590
the meet the main like you know selling

00:04:13,120 --> 00:04:16,359
points to the runtime that and bring in

00:04:14,590 --> 00:04:18,910
lots of languages together so I expect

00:04:16,359 --> 00:04:22,300
that to improve you can find out about

00:04:18,910 --> 00:04:25,000
the compatibility we test using this

00:04:22,300 --> 00:04:26,440
particular compatibility index test set

00:04:25,000 --> 00:04:28,540
of test tools to find out what

00:04:26,440 --> 00:04:32,920
works what doesn't work and they are all

00:04:28,540 --> 00:04:35,350
in the you know very standards-based the

00:04:32,920 --> 00:04:39,520
architecture so underneath you've got

00:04:35,350 --> 00:04:42,040
basically what you'd consider like

00:04:39,520 --> 00:04:44,440
classic Java like a VM that provides

00:04:42,040 --> 00:04:45,670
your interface to the outside world you

00:04:44,440 --> 00:04:47,590
know how'd you talk to file systems

00:04:45,670 --> 00:04:49,870
how'd you do threading how'd you talk to

00:04:47,590 --> 00:04:51,310
the OS and within that you have like a

00:04:49,870 --> 00:04:54,670
JIT compiler this is the thing that

00:04:51,310 --> 00:04:57,400
makes your code fast this is the so

00:04:54,670 --> 00:04:59,920
typically when you load a Java program

00:04:57,400 --> 00:05:01,120
like one of these jvm languages you when

00:04:59,920 --> 00:05:02,470
you compile them you generate like

00:05:01,120 --> 00:05:04,090
what's called bytecode it's an

00:05:02,470 --> 00:05:07,570
intermediate representation of your

00:05:04,090 --> 00:05:09,690
program and there's an interpreter which

00:05:07,570 --> 00:05:12,570
will just trundle through those

00:05:09,690 --> 00:05:15,190
relatively slow but starts quickly and

00:05:12,570 --> 00:05:18,970
that that will execute your program but

00:05:15,190 --> 00:05:20,440
the the VM will watch and profile what's

00:05:18,970 --> 00:05:22,750
happening you'll notice which things are

00:05:20,440 --> 00:05:25,270
running many times which which which

00:05:22,750 --> 00:05:26,770
pieces go to very tight loops etc and it

00:05:25,270 --> 00:05:28,390
will pass those over to their

00:05:26,770 --> 00:05:30,640
just-in-time compiler which will

00:05:28,390 --> 00:05:34,000
generate optimized machine code for it

00:05:30,640 --> 00:05:36,220
and by slowly over time notes in which

00:05:34,000 --> 00:05:38,380
things need speeding up it will optimize

00:05:36,220 --> 00:05:41,169
them into native machine code and that's

00:05:38,380 --> 00:05:43,450
how you get your speeding provements the

00:05:41,169 --> 00:05:45,070
that the secret sauce the magic I

00:05:43,450 --> 00:05:47,020
suppose might interest people here is

00:05:45,070 --> 00:05:50,890
this language implementation run time

00:05:47,020 --> 00:05:53,919
they've abstracted away the idea of

00:05:50,890 --> 00:05:54,880
creating languages in in Aunt Eller does

00:05:53,919 --> 00:05:56,710
anybody remember that

00:05:54,880 --> 00:05:58,530
you know or any of the other tools for

00:05:56,710 --> 00:06:00,070
crate creating grammars for languages

00:05:58,530 --> 00:06:02,140
programming languages

00:06:00,070 --> 00:06:03,730
they've abstracted all of that kind of

00:06:02,140 --> 00:06:05,980
those kind of ideas into a single

00:06:03,730 --> 00:06:09,580
language implementation layer with

00:06:05,980 --> 00:06:12,280
underneath a shared objects model so if

00:06:09,580 --> 00:06:16,330
you're all creating some JavaScript and

00:06:12,280 --> 00:06:19,510
some are the underlying objects that

00:06:16,330 --> 00:06:20,919
hold your code all your data they're all

00:06:19,510 --> 00:06:22,540
in the same space they're all the same

00:06:20,919 --> 00:06:25,120
kind of things and it's there's almost

00:06:22,540 --> 00:06:27,220
like zero Interop from swapping you know

00:06:25,120 --> 00:06:29,470
an object in your AR program into your

00:06:27,220 --> 00:06:32,919
javascript program which allows you to

00:06:29,470 --> 00:06:34,360
do some interesting things especially in

00:06:32,919 --> 00:06:36,850
terms of like everyone's building lots

00:06:34,360 --> 00:06:38,919
of applications where you've got an app

00:06:36,850 --> 00:06:39,639
here and it talks over some kind of cue

00:06:38,919 --> 00:06:41,080
to something

00:06:39,639 --> 00:06:42,939
and that talks over you know and they've

00:06:41,080 --> 00:06:44,469
got bit of rest and a bit of whatever

00:06:42,939 --> 00:06:45,849
and it gets very complicated and that's

00:06:44,469 --> 00:06:47,919
why people invent things like Cuba

00:06:45,849 --> 00:06:49,629
Nettie's you know and Jager and things

00:06:47,919 --> 00:06:51,879
like that but you know maybe we could

00:06:49,629 --> 00:06:53,110
maybe one of the ways to use growl is

00:06:51,879 --> 00:06:55,180
that to go back to maybe a bit of a

00:06:53,110 --> 00:06:57,400
monolith style programming model where

00:06:55,180 --> 00:06:59,770
you use the right kind of tools but all

00:06:57,400 --> 00:07:01,060
in the same address space so you can

00:06:59,770 --> 00:07:02,650
have your java in there you can have

00:07:01,060 --> 00:07:06,189
your JavaScript in there and I'll show

00:07:02,650 --> 00:07:09,249
you it's a fairly trivial example of

00:07:06,189 --> 00:07:10,419
this in a second wonderful slide that

00:07:09,249 --> 00:07:12,430
shows you all the different ways you

00:07:10,419 --> 00:07:14,110
different environments you can target so

00:07:12,430 --> 00:07:17,680
you can target you know like a java type

00:07:14,110 --> 00:07:19,509
environment with the gray VM runtime you

00:07:17,680 --> 00:07:22,029
can run it on node our version of node

00:07:19,509 --> 00:07:24,310
it's embedded in the Oracle database now

00:07:22,029 --> 00:07:28,029
as well we've got a thing called the

00:07:24,310 --> 00:07:30,939
multi language environment which lets

00:07:28,029 --> 00:07:32,830
you lets you run JavaScript and Python

00:07:30,939 --> 00:07:34,930
it's not yet released fully but it's

00:07:32,830 --> 00:07:36,759
experimental lets you run any of these

00:07:34,930 --> 00:07:39,610
languages directly in the database on

00:07:36,759 --> 00:07:41,620
your sequel queries so instead of

00:07:39,610 --> 00:07:43,479
fetching data shipping it to a server

00:07:41,620 --> 00:07:45,729
doing some kind of processing logic

00:07:43,479 --> 00:07:48,279
there the idea is that you know it's all

00:07:45,729 --> 00:07:49,689
co-located inside the database the data

00:07:48,279 --> 00:07:52,509
is not being shipped across the network

00:07:49,689 --> 00:07:54,009
and the idea really there will be

00:07:52,509 --> 00:07:55,719
returns on that in that there's less

00:07:54,009 --> 00:07:57,520
stuff being shifted around faster

00:07:55,719 --> 00:08:01,810
response times maybe we could do more

00:07:57,520 --> 00:08:04,689
with you know the data oh and we can

00:08:01,810 --> 00:08:07,330
also generate Linux and Mac executables

00:08:04,689 --> 00:08:09,669
not yet with the host languages but

00:08:07,330 --> 00:08:12,789
that's coming soon JavaScript our Python

00:08:09,669 --> 00:08:15,250
but if any of your JVM language is you

00:08:12,789 --> 00:08:17,919
take Java Runtime and a Java program

00:08:15,250 --> 00:08:19,509
which might total for 500 make megabytes

00:08:17,919 --> 00:08:22,839
in size and you can shrink it down to

00:08:19,509 --> 00:08:27,339
like 10 make 10 50 some somewhere in the

00:08:22,839 --> 00:08:29,259
10 to 50 Meg size limp size range and

00:08:27,339 --> 00:08:31,300
make a Linux executable of it that

00:08:29,259 --> 00:08:33,459
starts like near with near-instantaneous

00:08:31,300 --> 00:08:35,740
startup times reduce memory footprint

00:08:33,459 --> 00:08:37,479
and from a security point of view that's

00:08:35,740 --> 00:08:38,919
also really interesting because you can

00:08:37,479 --> 00:08:40,690
chuck away a lot of things you don't

00:08:38,919 --> 00:08:43,000
need like a runtime you just have this

00:08:40,690 --> 00:08:44,949
one possibly statically linked

00:08:43,000 --> 00:08:47,410
executable that has no dependencies on

00:08:44,949 --> 00:08:49,420
anything else so you in a container kind

00:08:47,410 --> 00:08:50,920
of world you can you can make very

00:08:49,420 --> 00:08:53,590
simple containers with your running

00:08:50,920 --> 00:08:55,810
system in it and we hope to have

00:08:53,590 --> 00:09:00,190
that four node and Jas you know sometime

00:08:55,810 --> 00:09:02,740
I think in the next year and as an

00:09:00,190 --> 00:09:04,870
example like this is just a node bit and

00:09:02,740 --> 00:09:08,020
node I have things expresses it was

00:09:04,870 --> 00:09:12,310
something I pulled off the web and stuck

00:09:08,020 --> 00:09:15,820
it into our node implementation ran it

00:09:12,310 --> 00:09:17,860
and it work NPM works and you know

00:09:15,820 --> 00:09:20,050
there's a bit of setting up command-line

00:09:17,860 --> 00:09:21,760
options etc you know various environment

00:09:20,050 --> 00:09:24,250
variables to point to the right version

00:09:21,760 --> 00:09:25,870
of node but you can still use MPM you

00:09:24,250 --> 00:09:28,390
can still use any of the tools that you

00:09:25,870 --> 00:09:33,010
normally use and a node works and

00:09:28,390 --> 00:09:37,000
there's an example of like Interop this

00:09:33,010 --> 00:09:38,950
is a bit of a controller from russia

00:09:37,000 --> 00:09:41,490
really great web app I wrote I'll show

00:09:38,950 --> 00:09:44,710
you in a second you'll be bowled over

00:09:41,490 --> 00:09:47,140
basically this this is just grabbing a

00:09:44,710 --> 00:09:50,320
bunch of poor images I downloaded off

00:09:47,140 --> 00:09:51,640
the internet and against each image and

00:09:50,320 --> 00:09:53,680
you could argue about the way I'm doing

00:09:51,640 --> 00:09:57,880
this all day I'm sure it's not the best

00:09:53,680 --> 00:09:59,350
way but it loads a Java object here

00:09:57,880 --> 00:10:01,720
which is not a Java program I wrote

00:09:59,350 --> 00:10:05,050
separately and compiled and stored as a

00:10:01,720 --> 00:10:08,470
jar and and this loads a tensorflow

00:10:05,050 --> 00:10:10,780
model the classifiers images it turns

00:10:08,470 --> 00:10:12,070
out classifiers image is badly but I

00:10:10,780 --> 00:10:14,440
haven't got R answer finding another

00:10:12,070 --> 00:10:17,440
model yet too many other things to do

00:10:14,440 --> 00:10:18,670
but this this this whole separate Java

00:10:17,440 --> 00:10:21,160
program I wrote which it works

00:10:18,670 --> 00:10:24,550
independently I can by just adding like

00:10:21,160 --> 00:10:26,380
a way to call it as a library basically

00:10:24,550 --> 00:10:28,960
just adding in a bit of extra

00:10:26,380 --> 00:10:31,840
boilerplate I can now just drop it into

00:10:28,960 --> 00:10:34,090
my node application and that Java object

00:10:31,840 --> 00:10:35,320
just can be used there's no funny

00:10:34,090 --> 00:10:37,720
business it just works

00:10:35,320 --> 00:10:40,210
and when I call it further down here

00:10:37,720 --> 00:10:42,610
classifier classify and then pass in a

00:10:40,210 --> 00:10:45,820
JavaScript string it does its business

00:10:42,610 --> 00:10:48,040
and I'll show you the app first because

00:10:45,820 --> 00:10:50,230
it's incredible basically this is a

00:10:48,040 --> 00:10:52,630
really poor image gallery application

00:10:50,230 --> 00:10:55,720
half stolen but the credits are in the

00:10:52,630 --> 00:10:58,530
source code and the and also like any

00:10:55,720 --> 00:11:02,260
good you know consultant I stole the

00:10:58,530 --> 00:11:05,140
stubble goat for always a stole that the

00:11:02,260 --> 00:11:07,209
the accreditations in there the code for

00:11:05,140 --> 00:11:10,449
the image classification and as

00:11:07,209 --> 00:11:12,189
you as it loads the gallery it tries to

00:11:10,449 --> 00:11:14,220
classify the images and let's see how it

00:11:12,189 --> 00:11:17,829
did giant panda it's pretty good

00:11:14,220 --> 00:11:21,100
cheeseburgers pretty good soup not too

00:11:17,829 --> 00:11:23,220
bad he was a famous 80s magician whose

00:11:21,100 --> 00:11:25,420
name I can't remember keeps bugging me

00:11:23,220 --> 00:11:27,759
pill and he gets progressively worse

00:11:25,420 --> 00:11:29,740
right but basically you see the idea

00:11:27,759 --> 00:11:31,119
that the the java application and the

00:11:29,740 --> 00:11:31,959
javascript application are playing

00:11:31,119 --> 00:11:34,119
nicely together

00:11:31,959 --> 00:11:35,529
and i've taken two things that were

00:11:34,119 --> 00:11:38,490
written independently and being able to

00:11:35,529 --> 00:11:41,649
stick them together with relative ease

00:11:38,490 --> 00:11:45,189
so the last two things i'm gonna quickly

00:11:41,649 --> 00:11:46,779
show you so this is an example of

00:11:45,189 --> 00:11:48,100
another way of calling other languages

00:11:46,779 --> 00:11:49,899
so we have the idea of host languages

00:11:48,100 --> 00:11:53,170
these are languages that are implemented

00:11:49,899 --> 00:11:54,699
on top of the truffle layer so from one

00:11:53,170 --> 00:11:56,379
host language to another there's this

00:11:54,699 --> 00:11:59,069
polyglot object that we've created

00:11:56,379 --> 00:12:01,689
that's in node and it lets you evaluate

00:11:59,069 --> 00:12:03,819
code admittedly this is passed in as a

00:12:01,689 --> 00:12:06,879
string and maybe in the future I think

00:12:03,819 --> 00:12:10,600
we might improve the experience around

00:12:06,879 --> 00:12:12,009
this just like a JavaScript or a you

00:12:10,600 --> 00:12:13,929
know a vowel or a valley new makes or

00:12:12,009 --> 00:12:16,329
something you can eval against the host

00:12:13,929 --> 00:12:18,549
language so we've got here just some our

00:12:16,329 --> 00:12:21,249
code no I don't understand our code and

00:12:18,549 --> 00:12:23,290
I don't think this came from somebody

00:12:21,249 --> 00:12:25,089
 different than me

00:12:23,290 --> 00:12:26,529
and I don't pretend to know fully what

00:12:25,089 --> 00:12:30,850
that's doing but I can show you an

00:12:26,529 --> 00:12:32,740
example of an application that that uses

00:12:30,850 --> 00:12:35,079
this and again it's I think it's just a

00:12:32,740 --> 00:12:38,079
little Express app and we have a look at

00:12:35,079 --> 00:12:41,079
the source code we can see up here we've

00:12:38,079 --> 00:12:43,089
got an example of just pulling in Java

00:12:41,079 --> 00:12:46,329
objects big integer for instance which

00:12:43,089 --> 00:12:48,160
is a really handy handy class tons of us

00:12:46,329 --> 00:12:51,490
obviously you know production-ready

00:12:48,160 --> 00:12:53,139
maths classes that in the java space

00:12:51,490 --> 00:12:59,290
that you could take use of make use of

00:12:53,139 --> 00:13:03,040
sorry then we have a bit of evaluation

00:12:59,290 --> 00:13:06,309
here where we we call the our language

00:13:03,040 --> 00:13:09,939
and we basically ask it to generate some

00:13:06,309 --> 00:13:11,860
SVG of like three-dimensional graph with

00:13:09,939 --> 00:13:15,040
like some cars and signs and various

00:13:11,860 --> 00:13:17,259
other things and that just comes back as

00:13:15,040 --> 00:13:19,749
text but it's SVG text and in in the

00:13:17,259 --> 00:13:20,650
final bit of the app the response part

00:13:19,749 --> 00:13:23,080
we just

00:13:20,650 --> 00:13:28,780
for the request we just send back the

00:13:23,080 --> 00:13:30,790
text that we've created and it's really

00:13:28,780 --> 00:13:32,920
not the prettiest application but you

00:13:30,790 --> 00:13:34,840
can see here you know this is this is

00:13:32,920 --> 00:13:36,850
the Java big integer like at the top of

00:13:34,840 --> 00:13:38,380
the application that we called and boom

00:13:36,850 --> 00:13:40,450
and we could do some like really big

00:13:38,380 --> 00:13:42,730
maths in that and you know one of the

00:13:40,450 --> 00:13:44,950
good things about the JVM is that you

00:13:42,730 --> 00:13:48,400
have access to potentially almost like

00:13:44,950 --> 00:13:49,690
huge heap size like if you've got a big

00:13:48,400 --> 00:13:51,970
enough machine you can have gigabytes

00:13:49,690 --> 00:13:53,770
and gigabytes and gigabytes of heap

00:13:51,970 --> 00:13:55,750
space to play with and then underneath

00:13:53,770 --> 00:13:58,420
we've got our SVG plot that was

00:13:55,750 --> 00:14:02,440
generated by the the our host language

00:13:58,420 --> 00:14:04,900
so ours apparently really good between

00:14:02,440 --> 00:14:06,700
dates of science manipulation type

00:14:04,900 --> 00:14:09,580
things I don't know a lot about it but

00:14:06,700 --> 00:14:11,350
I'm sure that's you know very clever but

00:14:09,580 --> 00:14:13,480
it shows how you can seamlessly bring

00:14:11,350 --> 00:14:16,660
one thing into the other you might not

00:14:13,480 --> 00:14:18,370
want to necessarily use like so maybe

00:14:16,660 --> 00:14:21,460
there's not an equivalent library say in

00:14:18,370 --> 00:14:24,220
JavaScript but you know R has a history

00:14:21,460 --> 00:14:25,900
going back many years of building you

00:14:24,220 --> 00:14:27,340
know these kinds of tools it makes sense

00:14:25,900 --> 00:14:29,500
to use the right tool for the right job

00:14:27,340 --> 00:14:31,510
in my mind you know it's also quicker

00:14:29,500 --> 00:14:34,270
we're forever reinventing the wheel in

00:14:31,510 --> 00:14:35,710
software development you know always you

00:14:34,270 --> 00:14:38,410
know we're gonna use this library on

00:14:35,710 --> 00:14:40,030
this runtime or this it's it's nice and

00:14:38,410 --> 00:14:42,190
pragmatic I think to be able to pull

00:14:40,030 --> 00:14:45,280
these different things together and use

00:14:42,190 --> 00:14:46,570
them appropriately right but if you want

00:14:45,280 --> 00:14:47,920
to get in touch or find out anything

00:14:46,570 --> 00:14:49,360
more about it

00:14:47,920 --> 00:14:53,460
I'm sure these guys will give you my

00:14:49,360 --> 00:14:57,029
details no worries hope that makes sense

00:14:53,460 --> 00:14:57,029

YouTube URL: https://www.youtube.com/watch?v=ytifjmZZHP8


