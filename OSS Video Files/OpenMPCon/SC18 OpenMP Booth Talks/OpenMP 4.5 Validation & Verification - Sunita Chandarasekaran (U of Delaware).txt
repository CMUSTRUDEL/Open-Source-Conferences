Title: OpenMP 4.5 Validation & Verification - Sunita Chandarasekaran (U of Delaware)
Publication date: 2018-11-17
Playlist: SC18 OpenMP Booth Talks
Description: 
	SC18 OpenMP Booth Talk - November 13, 2018, Dallas TX
Slides at https://www.openmp.org/wp-content/uploads/SC18-BoothTalks-ChandrasekaranDiaz.pdf
Captions: 
	00:00:00,030 --> 00:00:05,250
so hello everybody I'm Sunita

00:00:02,790 --> 00:00:06,540
Chandrasekaran from University of

00:00:05,250 --> 00:00:07,950
Delaware I'm an assistant professor

00:00:06,540 --> 00:00:10,559
there in the Department of Computer

00:00:07,950 --> 00:00:13,259
Information Sciences so this talk is

00:00:10,559 --> 00:00:15,210
going to be about the validation and

00:00:13,259 --> 00:00:19,289
verification test suite of

00:00:15,210 --> 00:00:22,560
OpenMP 4.5 offloading model and this is

00:00:19,289 --> 00:00:25,050
work in collaboration with Oak Ridge

00:00:22,560 --> 00:00:26,789
National Lab so Swarup Oscar and David

00:00:25,050 --> 00:00:29,310
burn hold our our you know collaborators

00:00:26,789 --> 00:00:33,090
from Oak Ridge National Lab Jose Diaz is

00:00:29,310 --> 00:00:35,010
my PhD student from ECE udel so we will

00:00:33,090 --> 00:00:36,870
walk you through you know why is this

00:00:35,010 --> 00:00:38,850
project important what kind of tests we

00:00:36,870 --> 00:00:40,350
have built and what are the experimental

00:00:38,850 --> 00:00:43,610
setting and what are the compiler

00:00:40,350 --> 00:00:45,840
implementations and so on and so forth

00:00:43,610 --> 00:00:47,610
right so that's the outline we'll give

00:00:45,840 --> 00:00:49,530
you an introduction about problem

00:00:47,610 --> 00:00:51,750
statement contributions but you know

00:00:49,530 --> 00:00:54,719
what is 4.5 off-loading what is a

00:00:51,750 --> 00:00:56,250
methodology the design of the tests what

00:00:54,719 --> 00:00:59,399
are the types of tests we have written

00:00:56,250 --> 00:01:02,489
why we chose what we chose how is our

00:00:59,399 --> 00:01:04,530
infrastructure design looking like what

00:01:02,489 --> 00:01:06,060
are the result logs how are the reports

00:01:04,530 --> 00:01:09,000
you know why how we generate the reports

00:01:06,060 --> 00:01:10,530
and we'll also give you a demo of you

00:01:09,000 --> 00:01:12,630
know where we have captured these

00:01:10,530 --> 00:01:15,000
results in a website and how do you know

00:01:12,630 --> 00:01:19,140
go over it and look at the results for

00:01:15,000 --> 00:01:22,350
yours you know analysis purposes I

00:01:19,140 --> 00:01:24,509
wanted to start this off by letting you

00:01:22,350 --> 00:01:27,689
know that this is part of the exascale

00:01:24,509 --> 00:01:30,900
computing ECP project solved project and

00:01:27,689 --> 00:01:34,979
solve focus is you know building this

00:01:30,900 --> 00:01:37,049
OpenMP programming environment CP so as

00:01:34,979 --> 00:01:38,700
you can see the stack here right so this

00:01:37,049 --> 00:01:40,320
is your hardware stack and you have all

00:01:38,700 --> 00:01:42,600
types of accelerators all types of

00:01:40,320 --> 00:01:45,000
heterogeneous systems going on hardware

00:01:42,600 --> 00:01:47,340
is evolving very rapidly things are

00:01:45,000 --> 00:01:48,979
changing very rapidly and with some it

00:01:47,340 --> 00:01:51,990
like system you have you know a lot of

00:01:48,979 --> 00:01:53,970
unknown concurrency billions of on

00:01:51,990 --> 00:01:55,380
concurrency possibility in a single node

00:01:53,970 --> 00:01:57,540
because single node has become fatter

00:01:55,380 --> 00:01:59,909
and fatter right we're talking about 44

00:01:57,540 --> 00:02:03,810
cores and we are talking about six GPUs

00:01:59,909 --> 00:02:06,360
on a single node the above this hardware

00:02:03,810 --> 00:02:09,539
stack is a software stack where the very

00:02:06,360 --> 00:02:10,829
first layer are your ECP applications

00:02:09,539 --> 00:02:13,140
then comes the different you know

00:02:10,829 --> 00:02:16,170
compilers and then the different runtime

00:02:13,140 --> 00:02:18,329
layers in this case OpenMP runtime bold

00:02:16,170 --> 00:02:20,909
and alga BOTS and then you have the

00:02:18,329 --> 00:02:22,950
operating system and so on so where does

00:02:20,909 --> 00:02:25,769
our project fit into this entire

00:02:22,950 --> 00:02:28,920
paradigm as we come over here where we

00:02:25,769 --> 00:02:30,989
are building the test infrastructure and

00:02:28,920 --> 00:02:33,629
creating these different test cases in

00:02:30,989 --> 00:02:36,959
order to be able to validate and verify

00:02:33,629 --> 00:02:40,439
the compiler implementations of the

00:02:36,959 --> 00:02:41,280
openmp 4.5 offloading features right

00:02:40,439 --> 00:02:43,170
there are several implementations

00:02:41,280 --> 00:02:45,480
available and there are multiple

00:02:43,170 --> 00:02:48,120
platforms available so how do you test

00:02:45,480 --> 00:02:50,189
the quality of the compiler and we go

00:02:48,120 --> 00:02:52,709
back and forth with the vendors and we

00:02:50,189 --> 00:02:54,239
talk to the open MP standard in case you

00:02:52,709 --> 00:02:56,340
know we don't follow anything

00:02:54,239 --> 00:03:00,239
sorry it's wrong way to say in case we

00:02:56,340 --> 00:03:01,829
have questions MP specification right or

00:03:00,239 --> 00:03:03,599
in case we think that this

00:03:01,829 --> 00:03:05,220
implementation should have been done the

00:03:03,599 --> 00:03:07,980
other way around just because our test

00:03:05,220 --> 00:03:09,599
failed which often you know sometimes we

00:03:07,980 --> 00:03:10,799
write a test and we think the test is

00:03:09,599 --> 00:03:12,510
right and the implementation is

00:03:10,799 --> 00:03:14,549
incorrect but only to find out that is

00:03:12,510 --> 00:03:17,099
the other way around so this involves

00:03:14,549 --> 00:03:19,409
you know very frequent interactions with

00:03:17,099 --> 00:03:22,620
the vendors as well as the compiler in

00:03:19,409 --> 00:03:27,299
pelipper's and the open MP standard so I

00:03:22,620 --> 00:03:29,040
would now invite my student Jose Diaz to

00:03:27,299 --> 00:03:31,430
talk about the you know rest of the

00:03:29,040 --> 00:03:35,129
process

00:03:31,430 --> 00:03:39,750
hello everyone my name is Jose moon

00:03:35,129 --> 00:03:43,650
Salva and I am the main developer on the

00:03:39,750 --> 00:03:46,139
University of Delaware side so let's

00:03:43,650 --> 00:03:48,030
start by explaining why are we so

00:03:46,139 --> 00:03:49,859
focused and interested in accelerated

00:03:48,030 --> 00:03:51,379
devices I think this is no surprise for

00:03:49,859 --> 00:03:54,900
anybody who is coming to this conference

00:03:51,379 --> 00:03:58,319
but we see an increase in the power

00:03:54,900 --> 00:04:00,810
usage and this will be for example in

00:03:58,319 --> 00:04:03,030
the top 500 list we can see that the

00:04:00,810 --> 00:04:05,129
average power of the systems that do

00:04:03,030 --> 00:04:07,620
report the power consumption is actually

00:04:05,129 --> 00:04:10,259
increasing and we the problem is how do

00:04:07,620 --> 00:04:12,750
we cool down and how do we increase the

00:04:10,259 --> 00:04:14,970
performance and the best solution that

00:04:12,750 --> 00:04:17,099
they have come out with is using

00:04:14,970 --> 00:04:19,799
accelerators device that will let us use

00:04:17,099 --> 00:04:22,139
part of the code then let us take part

00:04:19,799 --> 00:04:23,220
of the code and accelerate that segment

00:04:22,139 --> 00:04:25,620
of the code and

00:04:23,220 --> 00:04:26,970
obtain more performance for that part

00:04:25,620 --> 00:04:28,230
assuming that that part of the code is

00:04:26,970 --> 00:04:30,920
important for the rest of the

00:04:28,230 --> 00:04:33,920
application then we will get a speed-up

00:04:30,920 --> 00:04:37,230
so the main challenge here is how do we

00:04:33,920 --> 00:04:38,970
increase with increasing with the

00:04:37,230 --> 00:04:40,710
limited power that we have how do we

00:04:38,970 --> 00:04:43,050
increase performance and so one option

00:04:40,710 --> 00:04:44,850
is to feed more devices and do something

00:04:43,050 --> 00:04:47,820
like single program multiple data like

00:04:44,850 --> 00:04:49,800
the way we are doing on the other side

00:04:47,820 --> 00:04:51,720
we have the OpenMP specification which

00:04:49,800 --> 00:04:53,760
is constantly trying to adapt to those

00:04:51,720 --> 00:04:56,550
changes that the hardware is is bringing

00:04:53,760 --> 00:05:00,270
the problem is how can we guarantee the

00:04:56,550 --> 00:05:03,300
specification is made it's built by a

00:05:00,270 --> 00:05:07,830
group of multiple vendors and they try

00:05:03,300 --> 00:05:09,570
to they try to come up with the features

00:05:07,830 --> 00:05:11,130
that make sense for for everyone and

00:05:09,570 --> 00:05:13,800
that make sense for the trend however

00:05:11,130 --> 00:05:15,870
the later on take the res specification

00:05:13,800 --> 00:05:17,520
and do the implementation how can we

00:05:15,870 --> 00:05:19,530
guarantee that that implementation and

00:05:17,520 --> 00:05:22,500
the specifications match in between the

00:05:19,530 --> 00:05:25,590
two so we need to develop a methodology

00:05:22,500 --> 00:05:28,770
that is not vendor specific that is more

00:05:25,590 --> 00:05:30,360
targeting the specification itself that

00:05:28,770 --> 00:05:33,860
goes from the words that are in the

00:05:30,360 --> 00:05:36,840
specification all the way to the the

00:05:33,860 --> 00:05:39,230
vendors instead of the vendors creating

00:05:36,840 --> 00:05:41,190
their own tests for their own specific

00:05:39,230 --> 00:05:42,890
implementation because that is kind of

00:05:41,190 --> 00:05:46,620
like being bias about the implementation

00:05:42,890 --> 00:05:48,300
so what we want is that we treat the

00:05:46,620 --> 00:05:50,850
specification as a legal document the

00:05:48,300 --> 00:05:52,890
specification should be this bound in

00:05:50,850 --> 00:05:59,940
document between the user and the other

00:05:52,890 --> 00:06:01,830
vendors that sorry that without the

00:05:59,940 --> 00:06:03,240
requirement of them both interacting

00:06:01,830 --> 00:06:05,070
directly they can't communicate in

00:06:03,240 --> 00:06:07,350
between the each other so we are somehow

00:06:05,070 --> 00:06:12,090
like the lawyers of those documents by

00:06:07,350 --> 00:06:14,250
creating test tests that can verify if

00:06:12,090 --> 00:06:16,980
the implementation is doing what the

00:06:14,250 --> 00:06:19,230
documents are saying so we can see the

00:06:16,980 --> 00:06:21,750
ecosystem as something like this what we

00:06:19,230 --> 00:06:23,490
have the openmp specification on one

00:06:21,750 --> 00:06:25,290
side and we have the running system on

00:06:23,490 --> 00:06:27,750
the other side the compiler implementer

00:06:25,290 --> 00:06:29,130
can use the specification to decide tree

00:06:27,750 --> 00:06:31,590
to implement

00:06:29,130 --> 00:06:33,660
can use the specification document for

00:06:31,590 --> 00:06:37,139
its implementation and now the running

00:06:33,660 --> 00:06:38,879
system he knows he knows

00:06:37,139 --> 00:06:40,439
of the openmp specification he knows

00:06:38,879 --> 00:06:42,599
that by just using that particular

00:06:40,439 --> 00:06:45,330
compiler he can support that particular

00:06:42,599 --> 00:06:47,279
implementation but the user as long as

00:06:45,330 --> 00:06:50,400
he knows how to use the compiler

00:06:47,279 --> 00:06:52,789
implementation he shouldn't be he

00:06:50,400 --> 00:06:55,830
shouldn't have to learn to how to use

00:06:52,789 --> 00:06:58,050
every single implementation as long as

00:06:55,830 --> 00:07:00,120
the user knows the specification that

00:06:58,050 --> 00:07:04,770
should be enough in terms of programming

00:07:00,120 --> 00:07:07,740
in OpenMP so why not use in for example

00:07:04,770 --> 00:07:09,870
the example so why not why why do we

00:07:07,740 --> 00:07:11,939
want to create more and more code that

00:07:09,870 --> 00:07:13,560
could be somehow redundant with the code

00:07:11,939 --> 00:07:15,840
that isn't the examples or the code that

00:07:13,560 --> 00:07:17,490
each of the vendors is creating well the

00:07:15,840 --> 00:07:20,460
reason is that the examples do not

00:07:17,490 --> 00:07:21,960
really try to cover every possible case

00:07:20,460 --> 00:07:24,000
study in this way that is in the

00:07:21,960 --> 00:07:28,409
specification they just tried to create

00:07:24,000 --> 00:07:30,150
a single case that will work for for the

00:07:28,409 --> 00:07:31,830
user to understand the specification but

00:07:30,150 --> 00:07:34,349
they do not really cover all the

00:07:31,830 --> 00:07:36,749
possibilities and it definitely serves a

00:07:34,349 --> 00:07:39,479
completely different purpose

00:07:36,749 --> 00:07:41,279
why not automatic testing why not having

00:07:39,479 --> 00:07:42,719
a something that will just create the

00:07:41,279 --> 00:07:44,879
test for us well there is a lot of

00:07:42,719 --> 00:07:47,460
understanding of the words there is a

00:07:44,879 --> 00:07:49,139
lot of process of going into into the

00:07:47,460 --> 00:07:50,669
document drilling and seen if the

00:07:49,139 --> 00:07:54,300
language that is in the document is they

00:07:50,669 --> 00:07:57,689
want that they actually are or if it is

00:07:54,300 --> 00:08:00,719
clear enough for the user to use or to

00:07:57,689 --> 00:08:02,969
refer to so there is a lot of human

00:08:00,719 --> 00:08:05,819
effort that is required in order to that

00:08:02,969 --> 00:08:07,589
and the vendor test they are actually

00:08:05,819 --> 00:08:09,659
biased we do not want to replace the

00:08:07,589 --> 00:08:11,339
vendor test we I think that each of the

00:08:09,659 --> 00:08:12,870
vendors they will have testing as part

00:08:11,339 --> 00:08:15,870
of their own development cycles and

00:08:12,870 --> 00:08:17,099
that's completely ok but those tests are

00:08:15,870 --> 00:08:19,379
trying to cover the things that they

00:08:17,099 --> 00:08:20,909
already know they want to cover and that

00:08:19,379 --> 00:08:23,099
they already told in the process of

00:08:20,909 --> 00:08:25,819
creating the development so we want to

00:08:23,099 --> 00:08:29,430
and also sometimes those tests are

00:08:25,819 --> 00:08:32,190
specific like let's say that they are

00:08:29,430 --> 00:08:34,979
doing is something with with an NVIDIA

00:08:32,190 --> 00:08:36,839
GPU then they may use a ps4 the NVIDIA

00:08:34,979 --> 00:08:39,539
GPU and we want to remain vendor

00:08:36,839 --> 00:08:44,200
agnostic completely so we want to move

00:08:39,539 --> 00:08:47,240
away from that as well so

00:08:44,200 --> 00:08:50,510
most of you are probably familiar eyes

00:08:47,240 --> 00:08:52,339
with the open mp4 profile of loadings I

00:08:50,510 --> 00:08:55,190
will just go really quick over this and

00:08:52,339 --> 00:08:57,350
this is just the way that we see the

00:08:55,190 --> 00:09:00,350
machine as the programmers when we are

00:08:57,350 --> 00:09:02,180
trying to target devices what we see is

00:09:00,350 --> 00:09:03,860
we have the host on one side and we have

00:09:02,180 --> 00:09:05,480
a set of devices on the other side and

00:09:03,860 --> 00:09:08,089
those are interconnected in between each

00:09:05,480 --> 00:09:09,980
other there is a storage area like a

00:09:08,089 --> 00:09:11,660
storage address space for each of the

00:09:09,980 --> 00:09:13,459
devices and the disaster - addresses

00:09:11,660 --> 00:09:15,649
space for the host even though sometimes

00:09:13,459 --> 00:09:19,610
those stash addresses space may refer to

00:09:15,649 --> 00:09:22,160
the same physical storage the openmp

00:09:19,610 --> 00:09:24,290
specification does not the 4.5 s

00:09:22,160 --> 00:09:26,930
specification does not say that it has

00:09:24,290 --> 00:09:28,459
to be different but sometimes when we

00:09:26,930 --> 00:09:31,160
use products and pull them up in it says

00:09:28,459 --> 00:09:32,899
that it should seem different from the

00:09:31,160 --> 00:09:36,050
perspective from the perspective of the

00:09:32,899 --> 00:09:37,459
user however sometimes these the fact

00:09:36,050 --> 00:09:38,839
that they could be the same makes

00:09:37,459 --> 00:09:41,899
testing a little bit tricky especially

00:09:38,839 --> 00:09:43,660
if we are trying something like mapping

00:09:41,899 --> 00:09:45,800
or if you are trying to taste

00:09:43,660 --> 00:09:47,899
privatization or things like that so

00:09:45,800 --> 00:09:49,820
sometimes it's a little bit complicated

00:09:47,899 --> 00:09:54,020
we have to conserve some corner cases as

00:09:49,820 --> 00:09:56,420
well so we start in the host the host

00:09:54,020 --> 00:09:59,300
will go over load segment of the

00:09:56,420 --> 00:10:03,020
computation and that starts a sequential

00:09:59,300 --> 00:10:07,010
trail that sequential thread can be

00:10:03,020 --> 00:10:09,950
divided up into multiple teams into

00:10:07,010 --> 00:10:12,740
multiple teams each of them just

00:10:09,950 --> 00:10:15,350
corresponds to a different set of like a

00:10:12,740 --> 00:10:16,880
group of threads however when we use the

00:10:15,350 --> 00:10:18,620
the teams we are just creating the

00:10:16,880 --> 00:10:20,240
master threads the earth threads are

00:10:18,620 --> 00:10:22,579
there but they are not doing really I

00:10:20,240 --> 00:10:24,020
think this is similar to parallel where

00:10:22,579 --> 00:10:26,180
all the different threads are going to

00:10:24,020 --> 00:10:28,190
do exactly the same code that is within

00:10:26,180 --> 00:10:31,220
the teams region when we use the

00:10:28,190 --> 00:10:34,880
distributed we are doing is we are

00:10:31,220 --> 00:10:36,709
taking a loop iteration space and we are

00:10:34,880 --> 00:10:39,920
splitting it up among the multiple

00:10:36,709 --> 00:10:41,540
master teams and when we use a pal for

00:10:39,920 --> 00:10:43,130
inside what we are doing is created

00:10:41,540 --> 00:10:46,010
isn't the rest of the threads in the

00:10:43,130 --> 00:10:49,700
thread team to expand computation and

00:10:46,010 --> 00:10:52,540
finally we can do SIMD and what we do

00:10:49,700 --> 00:10:56,690
this we see this for example in terms of

00:10:52,540 --> 00:10:57,470
the GP we will see that this will be

00:10:56,690 --> 00:11:01,370
like a work

00:10:57,470 --> 00:11:03,590
RUP then we will have a bloke group of

00:11:01,370 --> 00:11:08,150
threads then we'll have blood then we

00:11:03,590 --> 00:11:11,510
have a grid and so on so the first two

00:11:08,150 --> 00:11:14,210
are actually just regions of code while

00:11:11,510 --> 00:11:19,700
the other three at the bottom are for

00:11:14,210 --> 00:11:21,230
for loops for loop kind of of code so

00:11:19,700 --> 00:11:23,780
what is the mythology that we are

00:11:21,230 --> 00:11:27,410
following in order to come up with this

00:11:23,780 --> 00:11:29,750
test we always start from the

00:11:27,410 --> 00:11:33,350
specification and what we do is we take

00:11:29,750 --> 00:11:35,630
this vacation and we read with we first

00:11:33,350 --> 00:11:37,010
we split it up into the different parts

00:11:35,630 --> 00:11:39,050
of the different directives that exist

00:11:37,010 --> 00:11:41,090
and we took this specification and what

00:11:39,050 --> 00:11:43,880
we did was read each of the elements and

00:11:41,090 --> 00:11:46,040
come up with a possible test like a

00:11:43,880 --> 00:11:49,820
testing methodology for particular part

00:11:46,040 --> 00:11:51,710
of the specification so we formulate the

00:11:49,820 --> 00:11:53,960
test and then we discuss the validity of

00:11:51,710 --> 00:11:56,000
that test if that we considered that the

00:11:53,960 --> 00:11:58,100
test is valid we go and make a first

00:11:56,000 --> 00:11:59,510
implementation and we see if that

00:11:58,100 --> 00:12:02,980
implementation passes among the

00:11:59,510 --> 00:12:09,890
different compilers we try GCC we try

00:12:02,980 --> 00:12:11,420
clang we tried a Excel Excel C Excel if

00:12:09,890 --> 00:12:14,930
we have many many of the different

00:12:11,420 --> 00:12:17,120
compilers and we check if if it is

00:12:14,930 --> 00:12:19,070
passing or not if it is passing we open

00:12:17,120 --> 00:12:21,770
it up for review we make sure we always

00:12:19,070 --> 00:12:26,180
do that do that to reviews this one is

00:12:21,770 --> 00:12:28,490
more about how how are we proposing to

00:12:26,180 --> 00:12:30,650
test and this one is more about the code

00:12:28,490 --> 00:12:32,480
itself are we actually doing what we

00:12:30,650 --> 00:12:36,400
proposed at the beginning and are we

00:12:32,480 --> 00:12:39,350
generating code that is P that can be

00:12:36,400 --> 00:12:41,660
and that is valid also for the for the

00:12:39,350 --> 00:12:43,820
specification document itself if that is

00:12:41,660 --> 00:12:46,490
accepted then we added to a test with if

00:12:43,820 --> 00:12:49,730
not then we will have to go and

00:12:46,490 --> 00:12:51,800
reiterate over this process again if the

00:12:49,730 --> 00:12:54,440
test doesn't pass and we know that the

00:12:51,800 --> 00:12:56,660
test is valid it may be because it's an

00:12:54,440 --> 00:12:58,430
ax specification issue probably the work

00:12:56,660 --> 00:12:59,990
the specifications are not clear enough

00:12:58,430 --> 00:13:01,790
or it may be because it's an

00:12:59,990 --> 00:13:04,190
implementation issue and so we have to

00:13:01,790 --> 00:13:06,020
go and report that that bug to to the

00:13:04,190 --> 00:13:08,360
vendors and we have actually reported

00:13:06,020 --> 00:13:11,089
many bugs to the vendors some of them

00:13:08,360 --> 00:13:13,790
have resulted in in Corrections of

00:13:11,089 --> 00:13:16,069
of the implementations and sometimes we

00:13:13,790 --> 00:13:18,379
go and report the world and we end up

00:13:16,069 --> 00:13:19,819
somewhere in between the two because

00:13:18,379 --> 00:13:22,160
they said no we are interpreting the

00:13:19,819 --> 00:13:24,019
specification this way and so we go and

00:13:22,160 --> 00:13:25,639
ask other people we ask the community we

00:13:24,019 --> 00:13:29,809
make sure that that's also the case and

00:13:25,639 --> 00:13:32,329
so on so our test will look something

00:13:29,809 --> 00:13:36,050
like this in this case we are trying to

00:13:32,329 --> 00:13:39,800
use multiple devices and see if the map

00:13:36,050 --> 00:13:42,050
of a an array will work with the device

00:13:39,800 --> 00:13:46,129
class so we are testing the target data

00:13:42,050 --> 00:13:50,300
map device so it will be the target data

00:13:46,129 --> 00:13:53,300
construct with the device class so what

00:13:50,300 --> 00:13:56,089
we do is we create an array with the

00:13:53,300 --> 00:13:58,759
number of devices and size n with first

00:13:56,089 --> 00:14:00,829
we check how many devices there are then

00:13:58,759 --> 00:14:02,839
we create an array and we try to map

00:14:00,829 --> 00:14:05,120
that array we iterate over each of the

00:14:02,839 --> 00:14:07,579
devices and we try to map a segment of

00:14:05,120 --> 00:14:10,279
that array that is equal to the device

00:14:07,579 --> 00:14:12,350
number times n so we we are just taking

00:14:10,279 --> 00:14:14,660
the whole array and we are dividing it

00:14:12,350 --> 00:14:16,910
in segments of N and each of the

00:14:14,660 --> 00:14:19,069
segments will go into a different device

00:14:16,910 --> 00:14:21,499
and then inside we are gonna create a

00:14:19,069 --> 00:14:24,790
target region and that target region

00:14:21,499 --> 00:14:28,069
will just assign the value of the device

00:14:24,790 --> 00:14:29,990
variable into the matrix now this is one

00:14:28,069 --> 00:14:32,149
of the things that because it's four

00:14:29,990 --> 00:14:34,730
point five and we do not have a way of

00:14:32,149 --> 00:14:36,529
knowing which device we are add then we

00:14:34,730 --> 00:14:39,589
have to use the variable from the loop

00:14:36,529 --> 00:14:41,899
and it will give us also a limitation of

00:14:39,589 --> 00:14:44,660
how much we can test if we consider for

00:14:41,899 --> 00:14:47,480
example 5.0 they already include a new

00:14:44,660 --> 00:14:49,759
and your API call that let us query

00:14:47,480 --> 00:14:52,370
which one is the device that we are

00:14:49,759 --> 00:14:54,679
running at okay so there are limitations

00:14:52,370 --> 00:14:57,379
with respect to how much test we can do

00:14:54,679 --> 00:15:01,759
and I think that those could be some

00:14:57,379 --> 00:15:05,240
things that may be may be improved once

00:15:01,759 --> 00:15:08,389
the 5.0 specification comes into the

00:15:05,240 --> 00:15:11,420
implementations and then all we do is we

00:15:08,389 --> 00:15:13,100
check if the value of the device is the

00:15:11,420 --> 00:15:14,809
one that we actually expected and if not

00:15:13,100 --> 00:15:18,499
we increase the number of of errors

00:15:14,809 --> 00:15:20,449
another test a little bit more complex

00:15:18,499 --> 00:15:22,339
or not complex but that is trained

00:15:20,449 --> 00:15:25,130
something with respect to to memory is

00:15:22,339 --> 00:15:28,310
for first private and the idea here

00:15:25,130 --> 00:15:32,060
it's that if we have an initial value of

00:15:28,310 --> 00:15:34,100
the of the privatize variable and then

00:15:32,060 --> 00:15:36,290
we have an inner for loop and we just

00:15:34,100 --> 00:15:39,380
increment that variable because it is

00:15:36,290 --> 00:15:42,170
private within within the teams within

00:15:39,380 --> 00:15:44,120
the thread in the teams then the value

00:15:42,170 --> 00:15:46,280
that we have at the end has to always be

00:15:44,120 --> 00:15:49,220
the expected value if we have a data

00:15:46,280 --> 00:15:50,900
race in this point then we will see if

00:15:49,220 --> 00:15:52,190
we have a data race in this point then

00:15:50,900 --> 00:15:54,170
we will see that the value at the end is

00:15:52,190 --> 00:15:56,930
not the Wonder that we expect so we use

00:15:54,170 --> 00:15:59,570
our test our codes like this they are

00:15:56,930 --> 00:16:01,850
really short they we try to use so we

00:15:59,570 --> 00:16:03,410
have a file that has some markers that

00:16:01,850 --> 00:16:05,930
allows us to keep them sure to always

00:16:03,410 --> 00:16:08,090
they have the same output we always

00:16:05,930 --> 00:16:09,950
point out at which was the line that

00:16:08,090 --> 00:16:12,170
generated the output which was defiled

00:16:09,950 --> 00:16:16,180
that generated the output and we have

00:16:12,170 --> 00:16:16,180
tried to make it as flexible as possible

00:16:17,020 --> 00:16:22,430
so the infrastructure one thing that we

00:16:20,240 --> 00:16:24,530
put a lot of attention into was how do

00:16:22,430 --> 00:16:26,750
we plan for the infrastructure of the

00:16:24,530 --> 00:16:28,550
test suite and what we decided was let's

00:16:26,750 --> 00:16:30,710
use a make file and let's use some

00:16:28,550 --> 00:16:33,260
scripts that allows us to support the

00:16:30,710 --> 00:16:34,730
rest of the of the of the process why

00:16:33,260 --> 00:16:37,580
make file is because it is white

00:16:34,730 --> 00:16:40,490
available in multiple systems like it

00:16:37,580 --> 00:16:42,260
it's really common for for any of the

00:16:40,490 --> 00:16:45,260
systems especially for the systems in do

00:16:42,260 --> 00:16:47,060
e to have support for form a file so we

00:16:45,260 --> 00:16:49,190
have a portal area across multiple

00:16:47,060 --> 00:16:53,000
compilers we have portability a tuple

00:16:49,190 --> 00:16:55,010
systems as well we wanted to make sure

00:16:53,000 --> 00:16:58,130
that most of the tests had the same

00:16:55,010 --> 00:17:01,190
output and that all the results were

00:16:58,130 --> 00:17:02,930
easy easily parts so we our script will

00:17:01,190 --> 00:17:04,850
organize the outputs in a way that we

00:17:02,930 --> 00:17:06,860
come parts the log files and we can

00:17:04,850 --> 00:17:09,290
present them in JSON file we can

00:17:06,860 --> 00:17:11,720
represent them in an HTML view that I

00:17:09,290 --> 00:17:13,400
can show at the end or we can present

00:17:11,720 --> 00:17:15,410
them just in the raw format so we have

00:17:13,400 --> 00:17:17,540
thought about how we collect the data as

00:17:15,410 --> 00:17:21,980
well how do we present the data to the

00:17:17,540 --> 00:17:23,839
final user and so on we organize our

00:17:21,980 --> 00:17:25,220
folder structure in a way that we have

00:17:23,839 --> 00:17:27,770
the test completely separate from the

00:17:25,220 --> 00:17:29,930
rest of the of the infrastructure so we

00:17:27,770 --> 00:17:31,780
create a folder test but they make

00:17:29,930 --> 00:17:36,050
finally sitting outside of that test

00:17:31,780 --> 00:17:38,480
ideally is that a long-term idea would

00:17:36,050 --> 00:17:38,929
be that this make file will also allows

00:17:38,480 --> 00:17:40,669
us to

00:17:38,929 --> 00:17:42,169
changing between one specification and

00:17:40,669 --> 00:17:45,529
the other one so right now we are doing

00:17:42,169 --> 00:17:47,809
4.5 so we only have test for 4.5 but if

00:17:45,529 --> 00:17:50,659
what we are saying is that once we would

00:17:47,809 --> 00:17:52,220
for example from 4.5 to 5.0 there are

00:17:50,659 --> 00:17:55,220
parts of the specification that will

00:17:52,220 --> 00:17:57,740
change also the day test so some of the

00:17:55,220 --> 00:18:00,019
tests may not be valid now for 4.4 5.0

00:17:57,740 --> 00:18:01,909
and they were valid for 4.5 so we have

00:18:00,019 --> 00:18:04,549
to make sure that we divide them up but

00:18:01,909 --> 00:18:07,309
we are trying to keep that as part of

00:18:04,549 --> 00:18:09,529
the design process of our test fit in

00:18:07,309 --> 00:18:12,769
our make file allows you allows you also

00:18:09,529 --> 00:18:16,039
to use multiple Flags

00:18:12,769 --> 00:18:18,619
that let you choose if you want to just

00:18:16,039 --> 00:18:20,210
have did it pass or fail or if you want

00:18:18,619 --> 00:18:22,639
to have some perversity in the results

00:18:20,210 --> 00:18:24,259
do we want to get the actual line the

00:18:22,639 --> 00:18:26,929
execution of the common line that that

00:18:24,259 --> 00:18:29,509
it use do we want to create a log system

00:18:26,929 --> 00:18:32,570
so we use multiple make file options to

00:18:29,509 --> 00:18:35,659
do selections you can also for example

00:18:32,570 --> 00:18:38,809
just run the test just run a single set

00:18:35,659 --> 00:18:42,679
of tests or just run that has that ain't

00:18:38,809 --> 00:18:44,720
in the word underscore something like if

00:18:42,679 --> 00:18:47,570
you want to do tests of all the possible

00:18:44,720 --> 00:18:50,299
maps so you can do a star underscore map

00:18:47,570 --> 00:18:51,950
with star underscore and then sorry

00:18:50,299 --> 00:18:54,049
underscore a star and then that will

00:18:51,950 --> 00:18:58,340
just run the ones that have the map in

00:18:54,049 --> 00:19:02,210
the name so an example it is as easy as

00:18:58,340 --> 00:19:04,369
as this you get the test some people

00:19:02,210 --> 00:19:06,110
will argue that there are some errors

00:19:04,369 --> 00:19:08,179
and we are working on them you get the

00:19:06,110 --> 00:19:09,980
test you go inside and you use make and

00:19:08,179 --> 00:19:12,679
it will start running compiling and

00:19:09,980 --> 00:19:17,809
running the the files so from the git

00:19:12,679 --> 00:19:19,190
clone to the folder to the make it is

00:19:17,809 --> 00:19:21,350
compiling and then at the end you're

00:19:19,190 --> 00:19:22,669
gonna see after the compilation is done

00:19:21,350 --> 00:19:29,059
you're gonna see when it when it starts

00:19:22,669 --> 00:19:30,679
running so we also want to be able to

00:19:29,059 --> 00:19:32,299
split up for example the compilation of

00:19:30,679 --> 00:19:34,249
the test and the run of the test so we

00:19:32,299 --> 00:19:36,529
have different rules in the compiler

00:19:34,249 --> 00:19:40,610
that allow us to split up sometimes you

00:19:36,529 --> 00:19:42,320
want to have you want to create first

00:19:40,610 --> 00:19:44,600
the compilation on on let's say they

00:19:42,320 --> 00:19:46,639
they login node and then they run on the

00:19:44,600 --> 00:19:48,379
compute node so we want to be able to

00:19:46,639 --> 00:19:50,480
split up the two so we create the

00:19:48,379 --> 00:19:52,280
different rules for to support that and

00:19:50,480 --> 00:19:54,560
additionally we have some rules

00:19:52,280 --> 00:19:59,360
for reporting so if once you get the run

00:19:54,560 --> 00:20:02,800
with with the look they own the options

00:19:59,360 --> 00:20:05,180
of the makefile you can get a divide the

00:20:02,800 --> 00:20:07,640
results in JSON or you can get them in

00:20:05,180 --> 00:20:11,600
HTML and it will create a nice view for

00:20:07,640 --> 00:20:13,520
you another thing that we wanted to

00:20:11,600 --> 00:20:15,080
consider is that sometimes there are

00:20:13,520 --> 00:20:18,500
system specific features for example

00:20:15,080 --> 00:20:20,450
where do we get the compilers from if we

00:20:18,500 --> 00:20:23,030
are using system modules if you are

00:20:20,450 --> 00:20:25,400
using Linux like Linux like modules you

00:20:23,030 --> 00:20:27,320
want to be able to load those modules

00:20:25,400 --> 00:20:29,330
and sometimes you want to do that

00:20:27,320 --> 00:20:31,460
loading before each of the tests which

00:20:29,330 --> 00:20:36,140
before it should run so we also support

00:20:31,460 --> 00:20:39,500
this as long as you can easily swap

00:20:36,140 --> 00:20:41,000
develop the de module from one torso

00:20:39,500 --> 00:20:43,850
there are older versions of the Linux

00:20:41,000 --> 00:20:45,230
models that don't let you just swap one

00:20:43,850 --> 00:20:47,180
module for the other one if you try to

00:20:45,230 --> 00:20:49,280
load a new module it will complain

00:20:47,180 --> 00:20:53,180
because you're already module different

00:20:49,280 --> 00:20:54,590
versions of it is intelligent enough to

00:20:53,180 --> 00:20:57,320
figure out which one to unlearn and

00:20:54,590 --> 00:20:59,750
which were to replace it for so that

00:20:57,320 --> 00:21:02,630
goes into our folder structure that is

00:20:59,750 --> 00:21:04,700
going to be a system of a set of system

00:21:02,630 --> 00:21:07,820
files that you can extend and you can

00:21:04,700 --> 00:21:10,150
specify multiple options for for those

00:21:07,820 --> 00:21:16,520
particular

00:21:10,150 --> 00:21:19,280
any question yes so all this is running

00:21:16,520 --> 00:21:21,560
in summit summit they have Titan and we

00:21:19,280 --> 00:21:23,990
are working also in our university

00:21:21,560 --> 00:21:28,670
system so because this is part of the CP

00:21:23,990 --> 00:21:30,950
project this is that these will be part

00:21:28,670 --> 00:21:34,120
of the compliance the acceptance

00:21:30,950 --> 00:21:34,120
compliance for submit as well

00:21:38,330 --> 00:21:44,840
okay so we as I mentioned as I mentioned

00:21:41,250 --> 00:21:48,030
before we support multiple results but

00:21:44,840 --> 00:21:51,570
we I will show what the and some how the

00:21:48,030 --> 00:21:53,460
results look like such as you were

00:21:51,570 --> 00:21:56,670
saying yeah we are running on submit and

00:21:53,460 --> 00:21:58,890
we are also running on summative we it's

00:21:56,670 --> 00:22:02,010
really nice because we are able to to

00:21:58,890 --> 00:22:04,050
extend our test to up to six devices and

00:22:02,010 --> 00:22:07,080
when the Klaus is in the open AP allows

00:22:04,050 --> 00:22:08,880
it we are also trying to include some

00:22:07,080 --> 00:22:11,010
tests that are not there are a little

00:22:08,880 --> 00:22:12,690
bit more functional so we are trying to

00:22:11,010 --> 00:22:15,150
into some application tests like mini

00:22:12,690 --> 00:22:18,870
apps that are part of the code of the

00:22:15,150 --> 00:22:20,280
different users in in the TV labs but

00:22:18,870 --> 00:22:26,040
there is something that we are still

00:22:20,280 --> 00:22:30,750
working on some of the things that we

00:22:26,040 --> 00:22:32,730
are steen oh by the way these diversion

00:22:30,750 --> 00:22:36,840
of crank that I'm reporting in this

00:22:32,730 --> 00:22:39,660
slide here is a special version of Clank

00:22:36,840 --> 00:22:42,240
that is home brewed for for Shyamalan

00:22:39,660 --> 00:22:46,590
and for summative so we call it clang

00:22:42,240 --> 00:22:48,750
coral actually run the test the trunk

00:22:46,590 --> 00:22:52,080
version of clang the result are are

00:22:48,750 --> 00:22:54,000
quite similar we have test for Fortran

00:22:52,080 --> 00:22:56,310
we have more tests for it right now but

00:22:54,000 --> 00:22:58,170
we are trying to move there are many of

00:22:56,310 --> 00:23:00,510
our tests that are in the development

00:22:58,170 --> 00:23:01,920
branch and we are trying to move them we

00:23:00,510 --> 00:23:04,350
have realized that one of the parts that

00:23:01,920 --> 00:23:07,380
is the hardest to do is is that process

00:23:04,350 --> 00:23:10,230
of making sure that are correct so you

00:23:07,380 --> 00:23:12,060
have to constantly be discussing and

00:23:10,230 --> 00:23:14,460
sometimes we get stuck into words of the

00:23:12,060 --> 00:23:16,950
specification point in our at which page

00:23:14,460 --> 00:23:19,320
says what and then we go back and forth

00:23:16,950 --> 00:23:20,910
and that usually take us a lot of time

00:23:19,320 --> 00:23:22,500
so there are more tests in the

00:23:20,910 --> 00:23:25,140
development branch than there are in the

00:23:22,500 --> 00:23:27,740
in the master branch right now the

00:23:25,140 --> 00:23:33,180
example of results that we have seen is

00:23:27,740 --> 00:23:36,330
for example for for IBM Excel compiler

00:23:33,180 --> 00:23:39,360
we realize that the deform in of some of

00:23:36,330 --> 00:23:41,700
the enum variables was not the correct

00:23:39,360 --> 00:23:45,060
one if we see the specification in in

00:23:41,700 --> 00:23:47,700
this page it says that if if you are

00:23:45,060 --> 00:23:49,470
doing a scalar values the default

00:23:47,700 --> 00:23:51,990
mapping should be like an employee

00:23:49,470 --> 00:23:53,760
seed data sharing attribute of first

00:23:51,990 --> 00:23:56,549
private meaning that they value that I

00:23:53,760 --> 00:23:58,620
have here should be copied to the target

00:23:56,549 --> 00:24:01,470
but the implication of the target should

00:23:58,620 --> 00:24:03,780
not be copied back to the two days just

00:24:01,470 --> 00:24:05,610
because of this first private right so

00:24:03,780 --> 00:24:07,740
if you have an integer if you have a

00:24:05,610 --> 00:24:09,330
double all of these elements if you do

00:24:07,740 --> 00:24:11,640
not specify any mapping of those

00:24:09,330 --> 00:24:14,039
elements then they should be first

00:24:11,640 --> 00:24:16,169
private and so we realized that for

00:24:14,039 --> 00:24:18,740
enums they were actually modifying the

00:24:16,169 --> 00:24:21,950
version of the host but this was

00:24:18,740 --> 00:24:24,450
resolved later or thanks for to two hour

00:24:21,950 --> 00:24:26,100
so we have many more examples it's just

00:24:24,450 --> 00:24:28,890
that for the sake of time we we have to

00:24:26,100 --> 00:24:30,870
cut it in there but you are more than

00:24:28,890 --> 00:24:35,600
welcome to visit our website I'll just

00:24:30,870 --> 00:24:35,600
oh really quick and show you

00:24:45,800 --> 00:24:50,790
so we have a website where we have you

00:24:48,870 --> 00:24:52,920
know populated all the tests and the

00:24:50,790 --> 00:24:54,540
reports and you know how to navigate

00:24:52,920 --> 00:24:55,830
through this if it's a field this is a

00:24:54,540 --> 00:24:57,720
home page where we tell you you know

00:24:55,830 --> 00:25:00,360
what the project is about and if you go

00:24:57,720 --> 00:25:03,420
to the repository tab to your left third

00:25:00,360 --> 00:25:05,820
one from the top yes so if you go to

00:25:03,420 --> 00:25:07,380
that one you know we have the structure

00:25:05,820 --> 00:25:09,870
as to how would you pick this up and

00:25:07,380 --> 00:25:11,700
where are the which is the folder you

00:25:09,870 --> 00:25:14,330
know what what is in each folder and

00:25:11,700 --> 00:25:17,790
stuff and if you go to the results tab

00:25:14,330 --> 00:25:19,680
you will see that all the results are

00:25:17,790 --> 00:25:23,670
categorized according to compilers and

00:25:19,680 --> 00:25:25,920
systems if you scroll up a little so

00:25:23,670 --> 00:25:27,870
explore you can choose a compiler choose

00:25:25,920 --> 00:25:29,400
a system and find out what the compiler

00:25:27,870 --> 00:25:31,740
results are looking likes and it's going

00:25:29,400 --> 00:25:34,500
to give you a in a bunch of report cases

00:25:31,740 --> 00:25:36,240
and yes so tell to you what passed what

00:25:34,500 --> 00:25:37,860
failed so this is open source take a

00:25:36,240 --> 00:25:39,540
look at it come back and tell us if you

00:25:37,860 --> 00:25:41,340
know we have misinterpreted something or

00:25:39,540 --> 00:25:47,670
you would like the feedback or you'll

00:25:41,340 --> 00:25:50,250
love this all all feedback welcome yeah

00:25:47,670 --> 00:25:52,590
I just want to mention that this is

00:25:50,250 --> 00:25:54,960
exactly HTML report that we provide

00:25:52,590 --> 00:25:57,420
without the bar just this segment here

00:25:54,960 --> 00:25:59,820
so when you create the report in HTML

00:25:57,420 --> 00:26:01,200
you should be able to get a report like

00:25:59,820 --> 00:26:03,660
this and I think that this is something

00:26:01,200 --> 00:26:04,890
we have work with vendors like AMD and

00:26:03,660 --> 00:26:06,390
they really like something like this

00:26:04,890 --> 00:26:09,960
because it was really easy for them to

00:26:06,390 --> 00:26:12,030
just get the the information that they

00:26:09,960 --> 00:26:15,170
needed so it will look something

00:26:12,030 --> 00:26:15,170
something like this

00:26:19,390 --> 00:26:22,510

YouTube URL: https://www.youtube.com/watch?v=ezV0bQZX-iY


