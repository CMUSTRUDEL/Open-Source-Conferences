Title: OpenMP 4.5 Validation & Verification  -  Sunita Chandrasekaran  (Univ. of Delaware)
Publication date: 2017-11-23
Playlist: SC17 OpenMP Booth Talks
Description: 
	SC17 OpenMP booth talks - November 2017, Denver CO.
PDF slides at http://openmp.org/resources/openmp-presentations/sc17-booth-talks
Captions: 
	00:00:02,600 --> 00:00:09,719
all right so I'm Sunita Chandra sacrum

00:00:07,319 --> 00:00:12,590
from University of Delaware and this

00:00:09,719 --> 00:00:15,770
talk is about OpenMP four point five

00:00:12,590 --> 00:00:18,300
validation and verification test suite

00:00:15,770 --> 00:00:21,180
so I have a bunch of author lists here

00:00:18,300 --> 00:00:23,279
so this is one of my students Jose Diaz

00:00:21,180 --> 00:00:25,289
I had another student

00:00:23,279 --> 00:00:27,180
Sergio Pino who was working on this

00:00:25,289 --> 00:00:30,359
project until he graduated with a

00:00:27,180 --> 00:00:31,949
master's degree and this is work in

00:00:30,359 --> 00:00:36,149
collaboration with Oak Ridge National

00:00:31,949 --> 00:00:37,800
Lab so Oscar Galindez Farook papel and

00:00:36,149 --> 00:00:40,950
David Byrne hold from Oak Ridge National

00:00:37,800 --> 00:00:43,020
Lab so he started this project about six

00:00:40,950 --> 00:00:44,550
months ago so I'm going to go through

00:00:43,020 --> 00:00:46,620
you know what we are doing in the

00:00:44,550 --> 00:00:48,960
validation verifications we project and

00:00:46,620 --> 00:00:51,210
who is involved and what is the

00:00:48,960 --> 00:00:52,800
structure of the project and you know

00:00:51,210 --> 00:00:55,980
how are we planned how do we plan to go

00:00:52,800 --> 00:00:58,680
forward with this test we project so a

00:00:55,980 --> 00:01:00,149
little bit of background here back from

00:00:58,680 --> 00:01:03,120
University of Houston you know dr.

00:01:00,149 --> 00:01:05,010
Chapman and Matthias Muller we they have

00:01:03,120 --> 00:01:08,010
been developing the OpenMP validation

00:01:05,010 --> 00:01:09,600
suite over a period of time and then the

00:01:08,010 --> 00:01:11,700
dr. Chapman myself and a few other

00:01:09,600 --> 00:01:13,500
students came up with a 3.1 OpenMP

00:01:11,700 --> 00:01:15,270
validation suite so we've been

00:01:13,500 --> 00:01:16,890
developing these test cases over a

00:01:15,270 --> 00:01:23,340
period of time and now it's time to

00:01:16,890 --> 00:01:25,790
validate 4.5 so the goal or the

00:01:23,340 --> 00:01:28,920
objective of this project itself is

00:01:25,790 --> 00:01:31,770
evaluating functionality of the target

00:01:28,920 --> 00:01:35,100
offload directives across compilers and

00:01:31,770 --> 00:01:37,920
architectures and we are specifically

00:01:35,100 --> 00:01:41,369
focusing on 4.5 offloading features and

00:01:37,920 --> 00:01:42,840
OpenMP 4.5 and obviously the idea going

00:01:41,369 --> 00:01:44,939
forward is to you know write

00:01:42,840 --> 00:01:46,590
comprehensive test suite so not only

00:01:44,939 --> 00:01:48,390
offloading but you would be covering the

00:01:46,590 --> 00:01:50,759
other features but we started off with

00:01:48,390 --> 00:01:53,310
offloading features and this project is

00:01:50,759 --> 00:01:55,049
part of ECP solve project and that's why

00:01:53,310 --> 00:01:57,560
we have Oakridge involve Brookhaven

00:01:55,049 --> 00:01:59,870
involved Argonne National Lab involved

00:01:57,560 --> 00:02:02,810
there is llnl and Elle

00:01:59,870 --> 00:02:05,020
VM Cray and GCC so it's a massive

00:02:02,810 --> 00:02:08,270
collaboration between National Labs and

00:02:05,020 --> 00:02:10,010
compiler vendors where we have been

00:02:08,270 --> 00:02:12,200
establishing you know lots of dialogue

00:02:10,010 --> 00:02:14,720
and lots of conversations with all these

00:02:12,200 --> 00:02:17,870
partners and we are working very closely

00:02:14,720 --> 00:02:19,610
with the IBM community currently and we

00:02:17,870 --> 00:02:21,050
also talked to the openmp organization

00:02:19,610 --> 00:02:23,150
obviously and we would like to you know

00:02:21,050 --> 00:02:25,400
step that up a bit more involve and

00:02:23,150 --> 00:02:28,070
engage with the open empty standard

00:02:25,400 --> 00:02:31,160
committee more to make a you know much

00:02:28,070 --> 00:02:32,870
larger impact and we have a bit pocket

00:02:31,160 --> 00:02:34,820
where we have all the test codes and

00:02:32,870 --> 00:02:36,260
everything up there so if you would like

00:02:34,820 --> 00:02:38,000
access to the mid bucket and the test

00:02:36,260 --> 00:02:40,550
codes feel free to drop me an e-mail or

00:02:38,000 --> 00:02:42,230
one of us in the contact list so I'm

00:02:40,550 --> 00:02:46,790
trying to put the contact list in every

00:02:42,230 --> 00:02:49,180
slide so that you can reach out to us so

00:02:46,790 --> 00:02:52,640
the idea behind this test feed itself is

00:02:49,180 --> 00:02:54,530
where we have a project workflow where

00:02:52,640 --> 00:02:56,900
we start off with you know first up

00:02:54,530 --> 00:02:58,880
looking at the specification analyzing

00:02:56,900 --> 00:03:01,310
the four-point-five offload directive or

00:02:58,880 --> 00:03:03,200
sometimes Oakridge comes up and say hey

00:03:01,310 --> 00:03:04,730
we have an application use case that we

00:03:03,200 --> 00:03:07,100
would like you to you know validate and

00:03:04,730 --> 00:03:09,350
verify so either that or you know

00:03:07,100 --> 00:03:12,140
features in the OpenMP 4.5 specification

00:03:09,350 --> 00:03:14,600
itself so we write a test trying to you

00:03:12,140 --> 00:03:17,510
know try it very closely to what the

00:03:14,600 --> 00:03:19,550
features definition itself is and we

00:03:17,510 --> 00:03:21,739
discussed the validity and their ins to

00:03:19,550 --> 00:03:23,000
the specification to make sure that you

00:03:21,739 --> 00:03:24,860
know the test is doing what the

00:03:23,000 --> 00:03:27,410
specification is expected it to do and

00:03:24,860 --> 00:03:31,489
we find out if the test is valid or not

00:03:27,410 --> 00:03:32,870
so if the test is you know valid we

00:03:31,489 --> 00:03:34,489
obviously test with the available

00:03:32,870 --> 00:03:36,920
implementations and I'm going to show

00:03:34,489 --> 00:03:38,810
you in a little bit a chart but you know

00:03:36,920 --> 00:03:41,690
the compilers that we test is model and

00:03:38,810 --> 00:03:43,810
if the test passes great we open it to

00:03:41,690 --> 00:03:46,670
the community LLVM community to review

00:03:43,810 --> 00:03:48,920
there is a channel where we post all

00:03:46,670 --> 00:03:50,510
these quotes for LLVM developers to make

00:03:48,920 --> 00:03:52,519
sure that this is the correct way to

00:03:50,510 --> 00:03:54,650
write the test and stuff and if the test

00:03:52,519 --> 00:03:55,820
is accepted fantastic we put this into

00:03:54,650 --> 00:03:58,700
the red packet validation verification

00:03:55,820 --> 00:04:01,519
suite so this is a smooth process now

00:03:58,700 --> 00:04:03,410
the question is what if the test was

00:04:01,519 --> 00:04:05,720
invalid right which means what if there

00:04:03,410 --> 00:04:07,100
was a bug so we go back and rewrite the

00:04:05,720 --> 00:04:08,390
test case after discussions with

00:04:07,100 --> 00:04:11,060
Oakridge and

00:04:08,390 --> 00:04:12,680
you know Argonne National Lab and then

00:04:11,060 --> 00:04:14,870
if the test was and we go through again

00:04:12,680 --> 00:04:16,489
the discussion validation evidence to

00:04:14,870 --> 00:04:18,709
specification and again we try to test

00:04:16,489 --> 00:04:20,709
it so the question is what if the test

00:04:18,709 --> 00:04:23,960
did not pass one of the implementation

00:04:20,709 --> 00:04:25,730
so then the obvious things to think

00:04:23,960 --> 00:04:27,440
about there is is there a problem with

00:04:25,730 --> 00:04:29,630
the test case is that a is it is

00:04:27,440 --> 00:04:32,150
something in the specification that we

00:04:29,630 --> 00:04:34,400
are misinterpreting should we speak to

00:04:32,150 --> 00:04:36,080
the you know application sorry the

00:04:34,400 --> 00:04:38,720
compiler developers about the test case

00:04:36,080 --> 00:04:41,180
and so on so we bring bring it to the

00:04:38,720 --> 00:04:43,160
OpenMP specification openmp standard

00:04:41,180 --> 00:04:44,960
community and we bring it to the LLVM

00:04:43,160 --> 00:04:46,669
community and we talk to them and try

00:04:44,960 --> 00:04:49,490
and find out okay so where is the

00:04:46,669 --> 00:04:51,080
problem and why did the tests fail and

00:04:49,490 --> 00:04:52,970
then if there is a buck we have been

00:04:51,080 --> 00:04:56,360
filing compiler bugs with the different

00:04:52,970 --> 00:04:58,370
compiler vendors and and then eventually

00:04:56,360 --> 00:05:00,140
when the bug is filed and then they

00:04:58,370 --> 00:05:02,419
report it you know if it is fixed and be

00:05:00,140 --> 00:05:04,820
retested and we then put the final

00:05:02,419 --> 00:05:07,190
passed test case into the bit bucket so

00:05:04,820 --> 00:05:08,900
as you see it is an iterative process it

00:05:07,190 --> 00:05:10,610
is not that we write a test case and we

00:05:08,900 --> 00:05:12,800
dump it in the bit bucket right so it is

00:05:10,610 --> 00:05:14,330
a complete cycle that goes through right

00:05:12,800 --> 00:05:18,410
from starting to write the test case

00:05:14,330 --> 00:05:20,150
making sure that it is being compiled

00:05:18,410 --> 00:05:22,520
and executed by more than just one or

00:05:20,150 --> 00:05:24,470
two compilers and making sure we let the

00:05:22,520 --> 00:05:26,150
LLVM community know that you know this

00:05:24,470 --> 00:05:29,510
is a test case are you okay with this is

00:05:26,150 --> 00:05:31,250
making sense in specification etc and

00:05:29,510 --> 00:05:34,940
then if there is a bug there is a whole

00:05:31,250 --> 00:05:37,010
different process we follow so this is

00:05:34,940 --> 00:05:38,540
like I said the openmp the current

00:05:37,010 --> 00:05:41,210
project is heavily focusing on the

00:05:38,540 --> 00:05:42,440
target offload and that's a little you

00:05:41,210 --> 00:05:43,970
know Mickey Mouse picture of you know

00:05:42,440 --> 00:05:45,140
there's a host and there's a device and

00:05:43,970 --> 00:05:48,140
there is an offloading which one of my

00:05:45,140 --> 00:05:50,060
students created thought that was a you

00:05:48,140 --> 00:05:52,010
know quite cool so it's very focuses

00:05:50,060 --> 00:05:54,229
very heavily on the target offloading so

00:05:52,010 --> 00:05:56,240
we're definitely focusing on functional

00:05:54,229 --> 00:05:58,190
and unit test cases what we are also

00:05:56,240 --> 00:06:00,260
interested is in isolator test cases

00:05:58,190 --> 00:06:02,240
because sometimes there are combination

00:06:00,260 --> 00:06:03,620
of directives and so how would you know

00:06:02,240 --> 00:06:05,330
you are testing the directive that you

00:06:03,620 --> 00:06:06,650
want to test right because and sometimes

00:06:05,330 --> 00:06:09,320
the directives have to go hand-in-hand

00:06:06,650 --> 00:06:10,760
you cannot separate them so there so we

00:06:09,320 --> 00:06:13,669
try to create functional unit and

00:06:10,760 --> 00:06:15,260
sometimes orphan test cases and the

00:06:13,669 --> 00:06:16,970
target platforms I'll show you in a

00:06:15,260 --> 00:06:19,580
while the list of racket platforms where

00:06:16,970 --> 00:06:21,360
the tests are currently running and it's

00:06:19,580 --> 00:06:22,710
also a collaborative project with ECP

00:06:21,360 --> 00:06:24,689
application developers to create

00:06:22,710 --> 00:06:27,270
representative specific use cases

00:06:24,689 --> 00:06:28,979
sometimes the application developers you

00:06:27,270 --> 00:06:30,750
know have a code failing but it's a

00:06:28,979 --> 00:06:32,639
massive piece of code so how do you

00:06:30,750 --> 00:06:35,550
narrow down to the piece that actually

00:06:32,639 --> 00:06:36,900
cost the code to fail so Oakridge comes

00:06:35,550 --> 00:06:38,879
up and says okay this is a particular

00:06:36,900 --> 00:06:40,439
use case which is causing this to fail

00:06:38,879 --> 00:06:42,780
so then we trickle it down to something

00:06:40,439 --> 00:06:43,740
meaningful which is much lesser number

00:06:42,780 --> 00:06:46,830
of code compared to the original

00:06:43,740 --> 00:06:48,569
application itself and then we create a

00:06:46,830 --> 00:06:49,949
test case and do the entire process of

00:06:48,569 --> 00:06:54,479
the project workflow that I showed you

00:06:49,949 --> 00:06:56,819
in the last slide so this is probably

00:06:54,479 --> 00:06:59,340
known to anybody who has an idea of what

00:06:56,819 --> 00:07:01,800
the offloading feature itself is but to

00:06:59,340 --> 00:07:03,509
quickly give you an overview it's a

00:07:01,800 --> 00:07:05,789
whole centric execution of code meaning

00:07:03,509 --> 00:07:09,090
the directives provide compiler with

00:07:05,789 --> 00:07:10,770
hints to create device executable code

00:07:09,090 --> 00:07:13,650
as well as inline all the necessary

00:07:10,770 --> 00:07:17,009
calls code execution data movement with

00:07:13,650 --> 00:07:20,279
the idea being that the users you know

00:07:17,009 --> 00:07:21,930
add hints to their application and that

00:07:20,279 --> 00:07:24,000
gets compiled and executed by the

00:07:21,930 --> 00:07:27,029
compiler you know so there's lesser

00:07:24,000 --> 00:07:28,589
burden on the user as a programmer right

00:07:27,029 --> 00:07:31,229
and they're trying to do a better job

00:07:28,589 --> 00:07:32,879
with the program itself and it frees the

00:07:31,229 --> 00:07:35,430
programmer from bookkeeping data

00:07:32,879 --> 00:07:37,169
allocation movement etc and in

00:07:35,430 --> 00:07:38,909
particular provides you know good

00:07:37,169 --> 00:07:40,589
control to the programmer to handle data

00:07:38,909 --> 00:07:42,120
movement between host and device because

00:07:40,589 --> 00:07:43,650
that was a whole purpose of you know

00:07:42,120 --> 00:07:45,990
coming up with an offloading feature and

00:07:43,650 --> 00:07:48,029
that's a little code snippet that shows

00:07:45,990 --> 00:07:49,830
you you know device code generation and

00:07:48,029 --> 00:07:52,319
there is a tag target clause a map

00:07:49,830 --> 00:07:53,550
clause to and from the and then what

00:07:52,319 --> 00:07:55,409
kind of conditional execution on the

00:07:53,550 --> 00:07:59,909
device and the runtime the site's device

00:07:55,409 --> 00:08:02,099
selection so the current status is we

00:07:59,909 --> 00:08:04,589
have created and implemented over

00:08:02,099 --> 00:08:07,050
20-plus validation verification test

00:08:04,589 --> 00:08:08,669
cases for structured data map directives

00:08:07,050 --> 00:08:10,169
and one time library calls and I will

00:08:08,669 --> 00:08:12,469
show you in a little while you know how

00:08:10,169 --> 00:08:14,729
we are structuring the entire test cases

00:08:12,469 --> 00:08:17,699
we committed patches to the LLVM

00:08:14,729 --> 00:08:19,500
compiler community and establishing

00:08:17,699 --> 00:08:21,389
collaboration with you know the rest of

00:08:19,500 --> 00:08:23,849
the parties that I told you and we

00:08:21,389 --> 00:08:26,069
maintain a bit bucket a wiki page where

00:08:23,849 --> 00:08:28,349
we have readme a readme and meeting

00:08:26,069 --> 00:08:30,509
minutes and you know because this is a

00:08:28,349 --> 00:08:31,740
there is a make file and we have a bunch

00:08:30,509 --> 00:08:33,510
of test cases we have a bunch of

00:08:31,740 --> 00:08:34,110
platforms there were several compilers

00:08:33,510 --> 00:08:35,729
so

00:08:34,110 --> 00:08:38,969
needs to be scripted and to make the

00:08:35,729 --> 00:08:41,820
whole process automated and easier and

00:08:38,969 --> 00:08:43,620
we also have a how to use you know LLVM

00:08:41,820 --> 00:08:45,959
lit infrastructure because one of the

00:08:43,620 --> 00:08:47,970
end goals is to be able to integrate

00:08:45,959 --> 00:08:50,790
these tests into the LLVM lit

00:08:47,970 --> 00:08:52,800
infrastructure increase a range of

00:08:50,790 --> 00:08:56,279
different compilers it is not just LLVM

00:08:52,800 --> 00:08:59,730
but we also test with IBM excel GCC Cray

00:08:56,279 --> 00:09:01,589
and of course the LLVM compiler and we

00:08:59,730 --> 00:09:04,980
have been talking to the you know OpenMP

00:09:01,589 --> 00:09:07,260
ARB and how an open-air PRB has also put

00:09:04,980 --> 00:09:09,450
up a bunch of examples so there are

00:09:07,260 --> 00:09:11,070
several quotes you know around here and

00:09:09,450 --> 00:09:14,519
their functional test case of unit test

00:09:11,070 --> 00:09:16,380
cases so what we would like to envision

00:09:14,519 --> 00:09:18,089
this is as a community we come together

00:09:16,380 --> 00:09:20,490
you know gather quotes are already

00:09:18,089 --> 00:09:21,959
available and find out what we have find

00:09:20,490 --> 00:09:24,450
out what they have and put them together

00:09:21,959 --> 00:09:26,940
and build this massive bundle of you

00:09:24,450 --> 00:09:29,790
know good suite that's the overall goal

00:09:26,940 --> 00:09:32,430
and that's just a snapshot of how we

00:09:29,790 --> 00:09:34,920
have been structuring the courts itself

00:09:32,430 --> 00:09:36,660
so if we take the target data and we

00:09:34,920 --> 00:09:38,220
have these you know different types of

00:09:36,660 --> 00:09:41,370
devices or different types of target

00:09:38,220 --> 00:09:43,380
platforms we have like structured each

00:09:41,370 --> 00:09:45,360
of these directive into a bunch of tests

00:09:43,380 --> 00:09:47,730
so you would see arrays contiguous

00:09:45,360 --> 00:09:49,949
sections non-overlapping allocatable one

00:09:47,730 --> 00:09:52,800
level two levels you know simple c++

00:09:49,949 --> 00:09:55,079
object or multiple devices etc and we

00:09:52,800 --> 00:09:57,390
look at some papers that IBM had

00:09:55,079 --> 00:10:01,350
published it with I want so that gave us

00:09:57,390 --> 00:10:03,089
some more test cases to look into and so

00:10:01,350 --> 00:10:04,890
we assign it between you know Oakridge

00:10:03,089 --> 00:10:06,600
in ourselves and we have the test name

00:10:04,890 --> 00:10:07,199
that corroborates with whatever is in

00:10:06,600 --> 00:10:09,390
bitbucket

00:10:07,199 --> 00:10:11,880
so as you can see you know we are trying

00:10:09,390 --> 00:10:13,380
to really do a comprehensive test with

00:10:11,880 --> 00:10:16,290
each of the directives so it is really

00:10:13,380 --> 00:10:18,029
broken down narrowly into selective test

00:10:16,290 --> 00:10:19,920
cases for each of the directive that we

00:10:18,029 --> 00:10:23,250
are dealing with so if done target data

00:10:19,920 --> 00:10:24,899
target target enter exit and target

00:10:23,250 --> 00:10:26,610
enter only target exit only

00:10:24,899 --> 00:10:28,350
so trying this is the way we would

00:10:26,610 --> 00:10:30,149
isolate a particular directive and how

00:10:28,350 --> 00:10:33,750
you know thinks these tests would really

00:10:30,149 --> 00:10:36,000
work so this is one example that I shot

00:10:33,750 --> 00:10:37,589
I thought I will you know let you folks

00:10:36,000 --> 00:10:39,779
know about how do we go about

00:10:37,589 --> 00:10:41,519
constructing this entire test case so

00:10:39,779 --> 00:10:43,020
that's a code piece and what we are

00:10:41,519 --> 00:10:44,970
really trying to do here or what we

00:10:43,020 --> 00:10:46,630
observed is we're trying to distribute

00:10:44,970 --> 00:10:48,070
each row of a matrix

00:10:46,630 --> 00:10:50,710
exactly one of the available devices

00:10:48,070 --> 00:10:53,710
which is this one line three

00:10:50,710 --> 00:10:55,870
so in line eight initially we started to

00:10:53,710 --> 00:10:57,760
put we have the pragma OMP target map

00:10:55,870 --> 00:10:59,950
and we did not have the from clause but

00:10:57,760 --> 00:11:03,100
we had the device depth so although the

00:10:59,950 --> 00:11:05,110
court ran and reported success it so it

00:11:03,100 --> 00:11:06,910
happened at runtime that the entire H

00:11:05,110 --> 00:11:09,130
matrix was being copied to each one of

00:11:06,910 --> 00:11:10,960
the devices when they were supposed to

00:11:09,130 --> 00:11:12,700
have copied like row by row because that

00:11:10,960 --> 00:11:15,210
is the intention of the test case to be

00:11:12,700 --> 00:11:19,420
able to offload this to multiple devices

00:11:15,210 --> 00:11:21,610
and line eight so that is a one so then

00:11:19,420 --> 00:11:23,380
we plucked this you know H matrix array

00:11:21,610 --> 00:11:26,590
back there to implicitly suggest to the

00:11:23,380 --> 00:11:28,420
target region not larger than the

00:11:26,590 --> 00:11:31,180
original size already mapped in the

00:11:28,420 --> 00:11:34,180
outer region which is this one so the

00:11:31,180 --> 00:11:36,400
idea here was without this the although

00:11:34,180 --> 00:11:38,770
it worked and reported success at the

00:11:36,400 --> 00:11:40,660
wrong time we it was the court was

00:11:38,770 --> 00:11:42,520
behaving as though the entire H matrix

00:11:40,660 --> 00:11:47,980
was being copied and it was supposed to

00:11:42,520 --> 00:11:50,020
only copy rows of mattresses and right

00:11:47,980 --> 00:11:51,790
so this was the idea of this whole test

00:11:50,020 --> 00:11:53,920
case and you know this test case helped

00:11:51,790 --> 00:11:56,970
us figure out that adding that kind of

00:11:53,920 --> 00:12:01,390
fixed the philosophy of the test case

00:11:56,970 --> 00:12:02,950
and this is a snapshot of the slack

00:12:01,390 --> 00:12:04,780
channel that we use to do all the

00:12:02,950 --> 00:12:07,510
chattering about the test cases with the

00:12:04,780 --> 00:12:09,640
respective collaborators and that's the

00:12:07,510 --> 00:12:12,100
bit bucket snapshot and again I put the

00:12:09,640 --> 00:12:16,360
you know contact IDs here so this is a

00:12:12,100 --> 00:12:19,180
table that summarizes the list of tests

00:12:16,360 --> 00:12:22,150
the language and the different compilers

00:12:19,180 --> 00:12:23,980
so here we have the clang and the summit

00:12:22,150 --> 00:12:26,770
death which is the development platform

00:12:23,980 --> 00:12:29,260
of it at Oak Ridge National Lab and this

00:12:26,770 --> 00:12:31,930
is the IBM Excel and that's a Titan with

00:12:29,260 --> 00:12:34,720
K 20x summit dev has a Pascal 100 and

00:12:31,930 --> 00:12:37,120
this is a cray compiler and that's again

00:12:34,720 --> 00:12:38,830
on Summit def with the GCC compiler so

00:12:37,120 --> 00:12:41,230
this is a list that shows you know

00:12:38,830 --> 00:12:43,480
passes and fails and one of the ideas to

00:12:41,230 --> 00:12:46,150
be able to use to the reason to use

00:12:43,480 --> 00:12:49,060
different compilers is a to test the

00:12:46,150 --> 00:12:51,130
validity of the implementation and B to

00:12:49,060 --> 00:12:52,180
find out how good our test cases right

00:12:51,130 --> 00:12:54,190
so goes both ways

00:12:52,180 --> 00:12:56,020
so instead of just compiling or

00:12:54,190 --> 00:12:56,370
executing with one compiler we're able

00:12:56,020 --> 00:12:57,839
to

00:12:56,370 --> 00:12:59,880
find out sometimes the test is incorrect

00:12:57,839 --> 00:13:01,950
and one of the compiler points it out so

00:12:59,880 --> 00:13:05,040
it's an iterative process overall

00:13:01,950 --> 00:13:08,330
so that's selective test cases that we

00:13:05,040 --> 00:13:12,390
have you know showing you some some

00:13:08,330 --> 00:13:14,070
cases there and the next step is we

00:13:12,390 --> 00:13:16,470
would like to extract some more test

00:13:14,070 --> 00:13:18,180
cases from application use cases to

00:13:16,470 --> 00:13:19,470
complement the ones we have and this is

00:13:18,180 --> 00:13:21,330
work in collaboration with doctors

00:13:19,470 --> 00:13:23,839
National Lab and Brookhaven and Stony

00:13:21,330 --> 00:13:25,770
Brook here where you know there are

00:13:23,839 --> 00:13:27,360
application developers writing large

00:13:25,770 --> 00:13:28,860
pieces of code and sometimes it fails

00:13:27,360 --> 00:13:30,570
and they need to narrow it down to a

00:13:28,860 --> 00:13:32,250
particular old portion in the code and

00:13:30,570 --> 00:13:33,930
how they do it because the massive piece

00:13:32,250 --> 00:13:35,760
of court so they have to strip it down

00:13:33,930 --> 00:13:37,440
and you know trickle it down to some 50

00:13:35,760 --> 00:13:39,510
lines of code and that way we would help

00:13:37,440 --> 00:13:41,660
them figure out where the real problem

00:13:39,510 --> 00:13:44,880
is and why the application itself failed

00:13:41,660 --> 00:13:47,550
and exactly it's a coordinating with the

00:13:44,880 --> 00:13:49,880
LLVM community and the we have been

00:13:47,550 --> 00:13:53,730
preparing for a release to the solve

00:13:49,880 --> 00:13:56,250
project at during SC so what has been

00:13:53,730 --> 00:13:57,930
the work so far so the the goal here is

00:13:56,250 --> 00:13:59,670
to be able to you know work together in

00:13:57,930 --> 00:14:01,790
collaboration with the LLVM OpenMP

00:13:59,670 --> 00:14:05,339
community to bring all this together and

00:14:01,790 --> 00:14:08,250
and make a big massive bundle of you

00:14:05,339 --> 00:14:10,020
know good test cases to validate the

00:14:08,250 --> 00:14:13,160
implementations and OpenMP compilers

00:14:10,020 --> 00:14:13,160

YouTube URL: https://www.youtube.com/watch?v=Te0uDWEosC4


