Title: OpenMP in an Accelerated World  -  James Beyer (NVIDIA)
Publication date: 2017-11-23
Playlist: SC17 OpenMP Booth Talks
Description: 
	SC17 OpenMP booth talks - November 2017, Denver CO.
PDF Slides at http://openmp.org/resources/openmp-presentations/sc17-booth-talks
Captions: 
	00:00:00,530 --> 00:00:06,029
all right so OpenMP for an accelerated

00:00:03,000 --> 00:00:08,460
world so we're gonna talk about OpenMP

00:00:06,029 --> 00:00:11,160
in the modern architecture world my name

00:00:08,460 --> 00:00:13,200
is James Baier I worked for NVIDIA I've

00:00:11,160 --> 00:00:13,889
been involved with OpenMP for quite a

00:00:13,200 --> 00:00:16,920
long time now

00:00:13,889 --> 00:00:22,859
previously with Craig as their openmp

00:00:16,920 --> 00:00:26,210
representative yes so OpenMP on

00:00:22,859 --> 00:00:29,849
accelerators why is it so important and

00:00:26,210 --> 00:00:32,160
the biggest reason here is the top 60

00:00:29,849 --> 00:00:34,950
machines on the green 500 use

00:00:32,160 --> 00:00:36,780
accelerators even with a new green 500

00:00:34,950 --> 00:00:38,460
even more accelerators are there it's

00:00:36,780 --> 00:00:41,870
the only way to go green these days is

00:00:38,460 --> 00:00:44,399
to use accelerators Mexico sub-committee

00:00:41,870 --> 00:00:46,950
quite a while ago I don't think I have

00:00:44,399 --> 00:00:48,570
the date actually produced a report and

00:00:46,950 --> 00:00:51,329
these were the three key prowl

00:00:48,570 --> 00:00:53,219
challenges they saw power requirements

00:00:51,329 --> 00:00:57,090
explained massive parallelism Cobian

00:00:53,219 --> 00:00:58,920
with runtime errors well we can deal

00:00:57,090 --> 00:01:00,660
with accelerators can solve two of those

00:00:58,920 --> 00:01:02,399
problems they give you power much

00:01:00,660 --> 00:01:06,600
reduced power and they're massively

00:01:02,399 --> 00:01:08,520
parallel so the other thing why is

00:01:06,600 --> 00:01:11,549
OpenMP doing this OpenMP is the de facto

00:01:08,520 --> 00:01:14,369
standard for parallel programming

00:01:11,549 --> 00:01:15,720
it says shared memory most people think

00:01:14,369 --> 00:01:18,060
of shared memory is different than

00:01:15,720 --> 00:01:19,830
accelerators shared memory but they've

00:01:18,060 --> 00:01:23,220
shared memory nonetheless we just expose

00:01:19,830 --> 00:01:25,710
it in a slightly different way all right

00:01:23,220 --> 00:01:28,049
so there's a quick opening peer-support

00:01:25,710 --> 00:01:29,880
accelerator since four oh four five out

00:01:28,049 --> 00:01:31,350
of stuff for five OS and added even more

00:01:29,880 --> 00:01:36,180
stuff we're just going to talk primarily

00:01:31,350 --> 00:01:41,220
about what's in tr6 which is 500 rave

00:01:36,180 --> 00:01:43,290
structures containing arrays or this

00:01:41,220 --> 00:01:45,329
simple structure here so we have a

00:01:43,290 --> 00:01:49,020
pointer inside of a structure we're

00:01:45,329 --> 00:01:50,280
going to map this structure and then

00:01:49,020 --> 00:01:53,759
we're going to map the pointer for that

00:01:50,280 --> 00:01:56,070
structure but there's gonna be a problem

00:01:53,759 --> 00:01:57,899
right now and the old definition of

00:01:56,070 --> 00:02:00,360
things cuz this mapping would not attach

00:01:57,899 --> 00:02:02,219
so when you made this call down here

00:02:00,360 --> 00:02:05,600
this P is actually going to be a host

00:02:02,219 --> 00:02:05,600
address not a device address

00:02:06,640 --> 00:02:12,230
so before tr6 or five-oh fix-up code

00:02:11,090 --> 00:02:14,000
would have looked something like this

00:02:12,230 --> 00:02:17,420
you would have actually had to just snap

00:02:14,000 --> 00:02:21,260
that pointer into it another pointer map

00:02:17,420 --> 00:02:23,090
it update it yourself but this still has

00:02:21,260 --> 00:02:28,160
a problem I made a mistake and I forgot

00:02:23,090 --> 00:02:30,320
to clean up the pointer s top P so I

00:02:28,160 --> 00:02:33,620
need yet another snap to remember this

00:02:30,320 --> 00:02:35,840
saved value so when s top P gets copied

00:02:33,620 --> 00:02:39,110
back off the device onto the host we

00:02:35,840 --> 00:02:43,910
haven't mutilated a pointer so all that

00:02:39,110 --> 00:02:46,730
work is now solved by pointer attachment

00:02:43,910 --> 00:02:51,380
the top-down approach to doing this now

00:02:46,730 --> 00:02:55,760
when you do the mapping map s the net

00:02:51,380 --> 00:02:57,740
map SP this s top P will be moved to the

00:02:55,760 --> 00:03:01,070
device and then will be attached so

00:02:57,740 --> 00:03:03,560
inside of this region s top P actually

00:03:01,070 --> 00:03:06,260
points correctly to the device address

00:03:03,560 --> 00:03:08,709
and when you make the call this s top P

00:03:06,260 --> 00:03:11,930
points the correct address on the device

00:03:08,709 --> 00:03:14,360
when we leave we will clean up properly

00:03:11,930 --> 00:03:16,310
so well release the memory on the device

00:03:14,360 --> 00:03:19,880
and then will detach and part of what

00:03:16,310 --> 00:03:22,489
the detachment does is make the copy of

00:03:19,880 --> 00:03:24,739
s P point to the correct thing on the

00:03:22,489 --> 00:03:29,900
host again so one copy how it occurs you

00:03:24,739 --> 00:03:31,640
get the right addresses all right so

00:03:29,900 --> 00:03:33,350
user defined mapper so this is yet

00:03:31,640 --> 00:03:36,650
another more powerful way of doing what

00:03:33,350 --> 00:03:39,590
I just showed you and so now we can

00:03:36,650 --> 00:03:43,940
declare a mapper and this mapper says

00:03:39,590 --> 00:03:45,910
map s my best got a massive top P is

00:03:43,940 --> 00:03:50,090
length so we have all this fancy thing

00:03:45,910 --> 00:03:54,410
then when we do map s all that's going

00:03:50,090 --> 00:03:56,630
to happen here is s will be map s today

00:03:54,410 --> 00:03:59,200
will be mapped as the P will be mapped s

00:03:56,630 --> 00:04:03,950
dot length will get first privatised

00:03:59,200 --> 00:04:06,380
then the SP is going to be attached so

00:04:03,950 --> 00:04:08,480
that when you do this call it will be

00:04:06,380 --> 00:04:12,190
the proper address again and when you

00:04:08,480 --> 00:04:12,190
free everything gets undone properly

00:04:12,920 --> 00:04:18,140
function availability the biggest

00:04:16,250 --> 00:04:19,609
problem that we heard for people trying

00:04:18,140 --> 00:04:22,160
to program these things is the amount of

00:04:19,609 --> 00:04:23,810
data of Directors they had to add to

00:04:22,160 --> 00:04:26,210
their code just to be able to get all

00:04:23,810 --> 00:04:29,630
the functions I needed available on the

00:04:26,210 --> 00:04:31,580
device and this is why so you have to

00:04:29,630 --> 00:04:33,020
put a pragma in here to say put this on

00:04:31,580 --> 00:04:34,970
the device I have to put a pregnant here

00:04:33,020 --> 00:04:37,910
to say put this on the device and then I

00:04:34,970 --> 00:04:40,310
have a target region that actually

00:04:37,910 --> 00:04:42,770
finally uses one of these the whole

00:04:40,310 --> 00:04:44,210
problem with this is the users don't

00:04:42,770 --> 00:04:46,040
like adding this especially when you

00:04:44,210 --> 00:04:47,540
have hundreds or thousands of tiny

00:04:46,040 --> 00:04:49,970
little functions in your source code and

00:04:47,540 --> 00:04:52,430
the compiler can usually see you okay

00:04:49,970 --> 00:04:54,530
the target construct contains this so I

00:04:52,430 --> 00:04:57,080
know that I can back off and find this

00:04:54,530 --> 00:04:58,520
and recompile it correctly and this one

00:04:57,080 --> 00:05:00,380
is being compiled for the device so I

00:04:58,520 --> 00:05:02,000
can go find this and compile it

00:05:00,380 --> 00:05:05,720
correctly so that's what we've actually

00:05:02,000 --> 00:05:08,180
asked the compilers to do is when you go

00:05:05,720 --> 00:05:10,220
through the code and if you hit a target

00:05:08,180 --> 00:05:12,230
find these things go back and look have

00:05:10,220 --> 00:05:14,450
I compiled them in this function or they

00:05:12,230 --> 00:05:16,580
are in this compilation unit file

00:05:14,450 --> 00:05:18,080
whatever you want to call it is it

00:05:16,580 --> 00:05:19,970
available to become free compiled

00:05:18,080 --> 00:05:21,110
correctly for the device it was not

00:05:19,970 --> 00:05:22,760
available it's still up to the

00:05:21,110 --> 00:05:24,380
programmer to get the prior the proper

00:05:22,760 --> 00:05:25,550
declared target constructs on there but

00:05:24,380 --> 00:05:29,360
if it is available they don't have to

00:05:25,550 --> 00:05:31,479
add any directives inferred function

00:05:29,360 --> 00:05:35,090
mapping is what I just described to

00:05:31,479 --> 00:05:36,979
describe so it's needed it otherwise you

00:05:35,090 --> 00:05:40,610
have to make your code ugly that's what

00:05:36,979 --> 00:05:42,830
it boils down to so this is what you end

00:05:40,610 --> 00:05:44,180
up with your code looks like this you

00:05:42,830 --> 00:05:45,740
just put your pragma in there and these

00:05:44,180 --> 00:05:49,700
things magically get compiled for the

00:05:45,740 --> 00:05:52,330
device because they were available all

00:05:49,700 --> 00:05:57,140
right data availability this is a big

00:05:52,330 --> 00:05:58,700
problem the map types we have to from

00:05:57,140 --> 00:06:00,050
from whatever we have all this mapping

00:05:58,700 --> 00:06:01,610
that we have to do even add a modifier

00:06:00,050 --> 00:06:04,810
so we can guarantee that we update your

00:06:01,610 --> 00:06:04,810
data when we need to

00:06:07,620 --> 00:06:12,400
that they also happen so if the target

00:06:10,390 --> 00:06:14,110
data enter today to exit our data Atari

00:06:12,400 --> 00:06:22,390
update declare target we have all these

00:06:14,110 --> 00:06:24,010
directives so right in four five if you

00:06:22,390 --> 00:06:25,540
wanted eight on the device which as a

00:06:24,010 --> 00:06:29,110
global you'd have to declare it on them

00:06:25,540 --> 00:06:31,300
as a target object if you want B on the

00:06:29,110 --> 00:06:32,770
device same thing if you want bigger

00:06:31,300 --> 00:06:34,000
array on the device you probably don't

00:06:32,770 --> 00:06:37,270
always want it there so you would put it

00:06:34,000 --> 00:06:40,540
as link so this is all just getting the

00:06:37,270 --> 00:06:42,070
data so you can compile and link to a to

00:06:40,540 --> 00:06:44,650
global objects then when you're going to

00:06:42,070 --> 00:06:46,810
use the data in a target region you'd

00:06:44,650 --> 00:06:51,520
still list the mappings these are just

00:06:46,810 --> 00:06:53,350
no ops the big array actually gets a

00:06:51,520 --> 00:06:56,400
slice moved over to the device it gets

00:06:53,350 --> 00:06:58,630
updated and then this link says that the

00:06:56,400 --> 00:07:00,970
global object big array will now it

00:06:58,630 --> 00:07:02,950
should now point to what was just moved

00:07:00,970 --> 00:07:06,190
over to the device that you're when you

00:07:02,950 --> 00:07:07,900
make a call later that uses big array as

00:07:06,190 --> 00:07:10,200
a global object it will work correctly

00:07:07,900 --> 00:07:10,200
and

00:07:12,379 --> 00:07:15,379
the

00:07:17,780 --> 00:07:23,630
at this point here is the always clause

00:07:19,760 --> 00:07:25,820
so if you say always - from a and B do

00:07:23,630 --> 00:07:27,290
get updated and array is just treated

00:07:25,820 --> 00:07:29,270
the same way it was here you just still

00:07:27,290 --> 00:07:31,220
get the data movement allocation and

00:07:29,270 --> 00:07:36,470
everything but the whole point is this

00:07:31,220 --> 00:07:40,070
is a lot of code after right so what we

00:07:36,470 --> 00:07:41,510
did is we added device profiles and it's

00:07:40,070 --> 00:07:43,370
by your the programmer says with the

00:07:41,510 --> 00:07:46,550
device profiles this is what I require

00:07:43,370 --> 00:07:51,020
of the compiler and the target to get

00:07:46,550 --> 00:07:53,480
the correct results it's a simple OMP

00:07:51,020 --> 00:07:55,880
requires the unified address unified

00:07:53,480 --> 00:07:57,740
shared memory unified address just

00:07:55,880 --> 00:08:00,220
guarantees that every address in the

00:07:57,740 --> 00:08:03,260
device in the program will be unique

00:08:00,220 --> 00:08:06,110
unified shared memory means every

00:08:03,260 --> 00:08:08,450
address is both unique and accessible by

00:08:06,110 --> 00:08:13,010
every thread or every execution unit

00:08:08,450 --> 00:08:17,000
available to the device one thing to

00:08:13,010 --> 00:08:19,820
make sure of here is scalars are always

00:08:17,000 --> 00:08:21,350
first private so if the user wants them

00:08:19,820 --> 00:08:23,840
to not be first private they need to say

00:08:21,350 --> 00:08:28,250
something even though they may have

00:08:23,840 --> 00:08:29,900
removed other directives so previously

00:08:28,250 --> 00:08:34,580
we had a whole bunch of directors we had

00:08:29,900 --> 00:08:37,339
a directive for a B and bigger a and we

00:08:34,580 --> 00:08:38,990
had a data movement clauses on the

00:08:37,339 --> 00:08:40,940
target just so that we could get all

00:08:38,990 --> 00:08:43,070
these things properly set up now all we

00:08:40,940 --> 00:08:45,530
do is say oh MP requires unified shared

00:08:43,070 --> 00:08:47,270
memory now a target can touch any of

00:08:45,530 --> 00:08:49,220
these things any way it wants to and

00:08:47,270 --> 00:08:50,870
it's up to the implementation to make

00:08:49,220 --> 00:08:53,960
them available however it makes them

00:08:50,870 --> 00:08:56,420
available for Nvidia that means that we

00:08:53,960 --> 00:08:58,610
would page in the pieces of big array as

00:08:56,420 --> 00:09:00,260
they're touched its small enough it's

00:08:58,610 --> 00:09:03,410
probably one page unless it crosses a

00:09:00,260 --> 00:09:04,850
page boundary so two pages but all the

00:09:03,410 --> 00:09:07,070
linky and everything just magically

00:09:04,850 --> 00:09:12,680
works no heavy lifting done by the

00:09:07,070 --> 00:09:14,780
programmer anymore so the whole point of

00:09:12,680 --> 00:09:16,310
this is to say open MP programming for

00:09:14,780 --> 00:09:17,990
accelerators has gotten a lot easier

00:09:16,310 --> 00:09:21,200
you have pointer attachment you have

00:09:17,990 --> 00:09:24,350
user-defined mappers inferred function

00:09:21,200 --> 00:09:27,370
mapping and the device profiles all of

00:09:24,350 --> 00:09:29,870
which make for a much cleaner

00:09:27,370 --> 00:09:30,930
first go at programming on through

00:09:29,870 --> 00:09:41,820
accelerator

00:09:30,930 --> 00:09:44,130
questions yes all of so does a compiler

00:09:41,820 --> 00:09:55,620
support the tr6

00:09:44,130 --> 00:09:59,100
no so this is all tr6 stuff so the IBM

00:09:55,620 --> 00:10:02,550
the IBM compiler supports open mp4 oh

00:09:59,100 --> 00:10:03,870
and 4/5 it's a claim based compiler and

00:10:02,550 --> 00:10:05,160
they have their X I think it's called

00:10:03,870 --> 00:10:09,720
excel there at their proprietary

00:10:05,160 --> 00:10:14,250
compiler Intel supports it for their

00:10:09,720 --> 00:10:17,460
targets GCC has some supports for it

00:10:14,250 --> 00:10:19,830
PGI has announced that they're going to

00:10:17,460 --> 00:10:21,690
support four or five they have released

00:10:19,830 --> 00:10:26,089
the four five

00:10:21,690 --> 00:10:26,089
mostly I don't know if it's complete for

00:10:29,270 --> 00:10:37,040
CPUs and but not for the GPU yet the GPU

00:10:33,089 --> 00:10:37,040
is four has been announced for next year

00:10:42,170 --> 00:10:47,040
the clean compiler for the these

00:10:45,450 --> 00:10:48,810
features aren't available yet and

00:10:47,040 --> 00:10:51,720
playing but playing compiler for four

00:10:48,810 --> 00:10:53,970
five is out there it works amazingly

00:10:51,720 --> 00:10:56,730
well compared to a few years ago when

00:10:53,970 --> 00:10:59,010
they first released it it does it's they

00:10:56,730 --> 00:11:00,480
fixed the holes that we we told them

00:10:59,010 --> 00:11:03,650
they need to fix I'm sure they have more

00:11:00,480 --> 00:11:03,650
holes we just haven't found them yet

00:11:04,210 --> 00:11:06,839
okay

00:11:08,360 --> 00:11:14,079
we use a primer it is behind the same

00:11:11,360 --> 00:11:14,079
incision

00:11:16,790 --> 00:11:22,230
so the pragma is when you use a pragma

00:11:20,700 --> 00:11:24,900
what it does is it tells that gives the

00:11:22,230 --> 00:11:26,610
compiler extra information and so when

00:11:24,900 --> 00:11:28,770
you put a pragma on a loop if you say

00:11:26,610 --> 00:11:31,320
parallel for your you're telling the

00:11:28,770 --> 00:11:33,090
compiler that this loop should be run in

00:11:31,320 --> 00:11:35,400
parallel and work shared across whatever

00:11:33,090 --> 00:11:37,680
threads you apply to it you can also do

00:11:35,400 --> 00:11:39,330
that with target which target says take

00:11:37,680 --> 00:11:42,480
this block of code and go run it

00:11:39,330 --> 00:11:49,040
someplace else as a task and that's what

00:11:42,480 --> 00:11:51,090
gets you onto an Nvidia device yep yep

00:11:49,040 --> 00:11:52,530
it will actually be able to make use of

00:11:51,090 --> 00:11:55,560
it yep you'd have to get right now the

00:11:52,530 --> 00:11:57,060
only compiler that you could use would

00:11:55,560 --> 00:11:59,040
be the clang compiler and you have to

00:11:57,060 --> 00:12:03,150
actually get parts of that ping compiler

00:11:59,040 --> 00:12:05,310
from the IBM yorktown repository because

00:12:03,150 --> 00:12:06,690
they have they have things over in that

00:12:05,310 --> 00:12:08,310
repository that haven't made it directly

00:12:06,690 --> 00:12:14,630
into clang yet but it's all available

00:12:08,310 --> 00:12:14,630

YouTube URL: https://www.youtube.com/watch?v=fSO7yQdeaUU


