Title: Simplify OpenMP with Cray Reveal -  Heidi Poxon (Cray)
Publication date: 2017-11-23
Playlist: SC17 OpenMP Booth Talks
Description: 
	SC17 OpenMP booth talks - November 2017, Denver CO.
PDF slides at http://openmp.org/resources/openmp-presentations/sc17-booth-talks
Captions: 
	00:00:00,000 --> 00:00:06,120
all right okay so this sounds okay all

00:00:03,810 --> 00:00:08,519
right all right my name is Heidi Paxson

00:00:06,120 --> 00:00:10,830
I work for cray and I'm a member of the

00:00:08,519 --> 00:00:12,750
programming environments group and today

00:00:10,830 --> 00:00:14,849
I wanted to talk about reveal one of the

00:00:12,750 --> 00:00:16,830
tools that we have available in our

00:00:14,849 --> 00:00:20,520
programming environment this particular

00:00:16,830 --> 00:00:24,180
tool we designed to be able to help

00:00:20,520 --> 00:00:27,990
users at OpenMP to their programs so as

00:00:24,180 --> 00:00:31,019
we were as we introduced GPUs into our

00:00:27,990 --> 00:00:33,690
systems several years ago we in addition

00:00:31,019 --> 00:00:36,450
to users who have MPI programs that want

00:00:33,690 --> 00:00:38,160
to add OpenMP we also thought that this

00:00:36,450 --> 00:00:40,320
would be a nice stepping stone to s

00:00:38,160 --> 00:00:43,430
start with OpenMP and then move on to

00:00:40,320 --> 00:00:45,930
GPUs so we found several uses for this

00:00:43,430 --> 00:00:48,360
so today what I want to talk about is

00:00:45,930 --> 00:00:50,489
the capability of reveal the first thing

00:00:48,360 --> 00:00:52,980
is that our intent is to reduce the

00:00:50,489 --> 00:00:55,680
effort associated with adding openmp to

00:00:52,980 --> 00:00:58,260
an MPI program so traditionally most of

00:00:55,680 --> 00:01:01,320
our a lot of our customers have pure MPI

00:00:58,260 --> 00:01:03,600
programs and have added openmp to these

00:01:01,320 --> 00:01:07,890
applications when the programs when the

00:01:03,600 --> 00:01:09,780
MPI stops scaling so the goal is to

00:01:07,890 --> 00:01:12,810
reduce or to produce performance

00:01:09,780 --> 00:01:16,350
portable code so even though we are

00:01:12,810 --> 00:01:18,210
using the cry software stack - - and

00:01:16,350 --> 00:01:20,939
this tool that is provided by creo the

00:01:18,210 --> 00:01:23,009
ultimate end goal is OpenMP directives

00:01:20,939 --> 00:01:24,780
in your source code so technically you

00:01:23,009 --> 00:01:28,770
could take this work that you've done

00:01:24,780 --> 00:01:31,290
and move it to other other platforms we

00:01:28,770 --> 00:01:33,659
also threw a reveal offer the ability to

00:01:31,290 --> 00:01:39,450
gain insight into what the compiler has

00:01:33,659 --> 00:01:41,430
done to your program so first of all

00:01:39,450 --> 00:01:44,340
many of our as I mentioned many of our

00:01:41,430 --> 00:01:46,829
customers have MPI programs and so we

00:01:44,340 --> 00:01:49,500
wanted to develop a way as their MPI

00:01:46,829 --> 00:01:52,409
programs scale and maybe the MPI starts

00:01:49,500 --> 00:01:54,899
leveling off how do you actually start

00:01:52,409 --> 00:01:56,790
adding multiple programming models or a

00:01:54,899 --> 00:01:59,009
hybrid programming model to your to your

00:01:56,790 --> 00:02:01,560
application so a couple of things that

00:01:59,009 --> 00:02:04,049
we look for with a pure MPI code when it

00:02:01,560 --> 00:02:05,850
could be time to add OpenMP is when the

00:02:04,049 --> 00:02:08,789
code isn't a network bound as you're

00:02:05,850 --> 00:02:10,679
scaling as I mentioned as MPI starts

00:02:08,789 --> 00:02:13,020
leveling off or maybe if you have shared

00:02:10,679 --> 00:02:13,810
resource contention on a node you may be

00:02:13,020 --> 00:02:15,550
able to alleviate

00:02:13,810 --> 00:02:19,599
some of this by adding OpenMP to your

00:02:15,550 --> 00:02:22,239
program so the typical approach to

00:02:19,599 --> 00:02:24,310
adding OpenMP to to an application is to

00:02:22,239 --> 00:02:26,709
first identify the loops that you want

00:02:24,310 --> 00:02:29,530
to parallel eyes so if you have a mini

00:02:26,709 --> 00:02:31,209
mini thousand or maybe a several million

00:02:29,530 --> 00:02:33,400
line application sometimes that's

00:02:31,209 --> 00:02:35,080
difficult to do to identify which

00:02:33,400 --> 00:02:36,819
particular loops you want to parallel

00:02:35,080 --> 00:02:39,099
eyes the next step is to actually

00:02:36,819 --> 00:02:43,269
perform the parallel analysis and

00:02:39,099 --> 00:02:45,400
scoping and that depending on the size

00:02:43,269 --> 00:02:47,290
of the loop can be a daunting project

00:02:45,400 --> 00:02:49,959
and we'll show you some examples here in

00:02:47,290 --> 00:02:51,970
a moment and then adding the OpenMP

00:02:49,959 --> 00:02:54,640
Lehrer of parallelism so building the

00:02:51,970 --> 00:02:56,950
directive in so that you can actually

00:02:54,640 --> 00:02:58,510
run the loop in parallel and then in

00:02:56,950 --> 00:03:00,760
addition to that one of the things that

00:02:58,510 --> 00:03:02,590
reveal can help with is giving you some

00:03:00,760 --> 00:03:04,450
optimization feedback so that you can

00:03:02,590 --> 00:03:12,220
also go after vectorization within your

00:03:04,450 --> 00:03:15,010
loops so as an example this is a sample

00:03:12,220 --> 00:03:18,549
loop it's a loop nest from a Fortran

00:03:15,010 --> 00:03:20,230
code and in this particular example I

00:03:18,549 --> 00:03:24,070
want to try and parallel eyes the outer

00:03:20,230 --> 00:03:25,540
loop so the the duje loop so the first

00:03:24,070 --> 00:03:27,370
thing i do is i take a look at this

00:03:25,540 --> 00:03:29,380
particular loop and i'm gonna have to

00:03:27,370 --> 00:03:31,329
determine is this a good loop two

00:03:29,380 --> 00:03:33,370
parallel eyes what prevents me from

00:03:31,329 --> 00:03:35,109
parallelizing it and then can I get any

00:03:33,370 --> 00:03:37,780
help with this because there are a lot

00:03:35,109 --> 00:03:40,150
of variables associated with this loop I

00:03:37,780 --> 00:03:42,310
also noticed that there's a couple of

00:03:40,150 --> 00:03:45,340
calls to some subroutines within this

00:03:42,310 --> 00:03:47,859
loop and so I know that I need to track

00:03:45,340 --> 00:03:50,260
the behavior and the variables through

00:03:47,859 --> 00:03:52,269
those subroutines to be able to

00:03:50,260 --> 00:03:54,519
determine if I can run this loop in

00:03:52,269 --> 00:03:55,810
parallel and as you can see now on the

00:03:54,519 --> 00:03:57,700
other side here I've brought up that

00:03:55,810 --> 00:03:59,859
particular subroutine which makes calls

00:03:57,700 --> 00:04:02,560
to a bunch of other routines and so as a

00:03:59,859 --> 00:04:05,470
user this is a very tedious job to go

00:04:02,560 --> 00:04:07,480
through all of these subroutines and go

00:04:05,470 --> 00:04:10,359
through the path that this loop will

00:04:07,480 --> 00:04:12,280
execute through in order to analyze all

00:04:10,359 --> 00:04:16,090
the variables and the dependencies or

00:04:12,280 --> 00:04:17,590
the potential dependencies so the very

00:04:16,090 --> 00:04:19,180
first thing the first question is is

00:04:17,590 --> 00:04:21,190
this a good loop to parallelize that's

00:04:19,180 --> 00:04:23,289
the very first thing I don't want in a

00:04:21,190 --> 00:04:24,520
large application to just open my first

00:04:23,289 --> 00:04:26,650
file

00:04:24,520 --> 00:04:28,300
and try and parallel eyes my very first

00:04:26,650 --> 00:04:29,919
loop in that file because I may not get

00:04:28,300 --> 00:04:33,940
a performance gain when I'm done

00:04:29,919 --> 00:04:35,800
so we tried we invented a an approach to

00:04:33,940 --> 00:04:37,960
be able to analyze the amount of work or

00:04:35,800 --> 00:04:39,940
estimate the amount of work in the loops

00:04:37,960 --> 00:04:41,949
in your application so that you can more

00:04:39,940 --> 00:04:45,009
quickly identify which particular key

00:04:41,949 --> 00:04:49,120
loops are are useful to try and add

00:04:45,009 --> 00:04:51,250
OpenMP so the way you do this on our

00:04:49,120 --> 00:04:54,009
system is you use a combination of the

00:04:51,250 --> 00:04:57,220
cray compiler the Cray performance tools

00:04:54,009 --> 00:04:58,870
and then ultimately reveal so by using

00:04:57,220 --> 00:05:00,759
the cray compiler we've set up an

00:04:58,870 --> 00:05:02,620
experiment where you load the module to

00:05:00,759 --> 00:05:04,570
access the compiler you load a module to

00:05:02,620 --> 00:05:07,810
access and implement this particular

00:05:04,570 --> 00:05:09,460
experiment for analyzing loops you build

00:05:07,810 --> 00:05:11,590
your program with a crate program

00:05:09,460 --> 00:05:14,710
library which is a feature that we've

00:05:11,590 --> 00:05:16,479
added to our compiler so that it's

00:05:14,710 --> 00:05:18,159
basically a map with a lot of

00:05:16,479 --> 00:05:20,380
information about your application and

00:05:18,159 --> 00:05:22,690
it allows us to communicate the compiler

00:05:20,380 --> 00:05:24,759
can communicate information about that

00:05:22,690 --> 00:05:28,690
application to the performance tools or

00:05:24,759 --> 00:05:30,659
to reveal so you load these modules you

00:05:28,690 --> 00:05:33,070
build your program and you run it an

00:05:30,659 --> 00:05:34,599
example of the type of information that

00:05:33,070 --> 00:05:37,870
you get after running your particular

00:05:34,599 --> 00:05:41,139
program with this experiment is a sorted

00:05:37,870 --> 00:05:42,669
list of loops where they topped loops on

00:05:41,139 --> 00:05:44,710
the list are the key ones that you would

00:05:42,669 --> 00:05:47,080
want to parallel eyes or attempt to

00:05:44,710 --> 00:05:48,789
parallelize over the others so relative

00:05:47,080 --> 00:05:50,620
to the loops in your application the

00:05:48,789 --> 00:05:52,419
important or most important ones the

00:05:50,620 --> 00:05:55,479
ones with the most work in them bubbled

00:05:52,419 --> 00:05:57,870
to the top in addition to them being

00:05:55,479 --> 00:06:01,300
sorted we also give you the trip count

00:05:57,870 --> 00:06:02,560
and we give you the the number of times

00:06:01,300 --> 00:06:04,150
that that particular loop was

00:06:02,560 --> 00:06:06,219
encountered in that execution of your

00:06:04,150 --> 00:06:09,159
program we tell you which particular

00:06:06,219 --> 00:06:11,229
function the loop came from and the line

00:06:09,159 --> 00:06:13,509
number and so you can see as an example

00:06:11,229 --> 00:06:16,990
here I've got two loops one loop at line

00:06:13,509 --> 00:06:18,580
33 one at line 34 you've got the the

00:06:16,990 --> 00:06:21,610
trip counts at one hundred and twenty

00:06:18,580 --> 00:06:25,320
five hundred so you can see by this that

00:06:21,610 --> 00:06:25,320
you have a nested loop

00:06:26,439 --> 00:06:30,849
so now what I've done is I've got my

00:06:28,419 --> 00:06:32,709
loop custom it's my work estimates for

00:06:30,849 --> 00:06:34,479
my loop and I've got my program library

00:06:32,709 --> 00:06:35,919
from the Craig compiler and the next

00:06:34,479 --> 00:06:38,619
thing I do is I'm gonna launch reveal

00:06:35,919 --> 00:06:40,419
with that information so when I do this

00:06:38,619 --> 00:06:42,459
the first thing that the user sees is

00:06:40,419 --> 00:06:44,379
they see a navigation panel on the left

00:06:42,459 --> 00:06:48,369
hand side where the timings or that rank

00:06:44,379 --> 00:06:50,259
of loops is listed the the stars for

00:06:48,369 --> 00:06:52,149
those loops indicate that those

00:06:50,259 --> 00:06:55,689
particular loops have enough work to

00:06:52,149 --> 00:06:57,519
justify starting OpenMP threads if I

00:06:55,689 --> 00:06:59,110
click on one of these particular loops

00:06:57,519 --> 00:07:01,300
I'm brought to the source code for that

00:06:59,110 --> 00:07:03,939
loop and you can see there's some

00:07:01,300 --> 00:07:06,639
letters in this column here if I hover

00:07:03,939 --> 00:07:08,499
over those letters those will those are

00:07:06,639 --> 00:07:10,869
the loop mark that's the loop mark

00:07:08,499 --> 00:07:12,369
information from our compiler listing so

00:07:10,869 --> 00:07:14,559
it tells you basically that the compiler

00:07:12,369 --> 00:07:16,899
for example vectorized and unrolled this

00:07:14,559 --> 00:07:19,269
particular loop by two so you can

00:07:16,899 --> 00:07:22,029
quickly see what sort of optimizations

00:07:19,269 --> 00:07:24,939
were made in addition we also list

00:07:22,029 --> 00:07:28,089
messages from the compiler associated

00:07:24,939 --> 00:07:29,919
with that particular loop nest and we

00:07:28,089 --> 00:07:31,509
color code them as positive and negative

00:07:29,919 --> 00:07:34,149
messages and the good thing about that

00:07:31,509 --> 00:07:36,189
is the user can quickly identify what

00:07:34,149 --> 00:07:39,129
the compiler was able to do and what it

00:07:36,189 --> 00:07:40,899
was not able to do here one of the

00:07:39,129 --> 00:07:43,059
things that happens when you try in

00:07:40,899 --> 00:07:44,769
complex codes is a loop may be accessed

00:07:43,059 --> 00:07:47,259
from more than one location within the

00:07:44,769 --> 00:07:49,599
program and so if you click on this drop

00:07:47,259 --> 00:07:51,579
down you can see all the instances that

00:07:49,599 --> 00:07:54,159
this particular loop was accessed from

00:07:51,579 --> 00:07:56,319
and in the lower area here you will get

00:07:54,159 --> 00:07:58,839
the call back or the trace back of that

00:07:56,319 --> 00:08:01,209
loop from main and so of that instance

00:07:58,839 --> 00:08:04,659
so if you want to see how all the

00:08:01,209 --> 00:08:06,159
different paths to this loop how what

00:08:04,659 --> 00:08:08,019
all the different paths to this loop are

00:08:06,159 --> 00:08:09,970
from main you can quickly get that

00:08:08,019 --> 00:08:13,319
information as well

00:08:09,970 --> 00:08:13,319
[Music]

00:08:13,430 --> 00:08:17,810
the next thing I want to do is I want to

00:08:15,560 --> 00:08:20,030
actually scope my loops so there is a

00:08:17,810 --> 00:08:22,220
button here and by default what we do is

00:08:20,030 --> 00:08:24,080
we select for the user the loops that

00:08:22,220 --> 00:08:26,690
have enough work to justify starting

00:08:24,080 --> 00:08:28,759
OpenMP if the user is free to choose to

00:08:26,690 --> 00:08:32,779
deselect or select additional loops and

00:08:28,759 --> 00:08:35,479
then there is a a batch scoping

00:08:32,779 --> 00:08:38,080
capability so in this particular case I

00:08:35,479 --> 00:08:40,580
have chosen to scope 26 loops

00:08:38,080 --> 00:08:41,870
after the scoping is complete what

00:08:40,580 --> 00:08:44,060
happens is again you've got your

00:08:41,870 --> 00:08:48,050
navigation but now it's highlighted with

00:08:44,060 --> 00:08:49,640
red and green and if you click on one of

00:08:48,050 --> 00:08:50,380
the particular loops you can get some

00:08:49,640 --> 00:08:53,420
more information

00:08:50,380 --> 00:08:55,910
anything that's marked green is able to

00:08:53,420 --> 00:08:57,500
be parallelized as is and we can help

00:08:55,910 --> 00:08:58,730
you insert a directive that you can

00:08:57,500 --> 00:09:00,830
insert into your source code or that

00:08:58,730 --> 00:09:03,650
review concert insert into your source

00:09:00,830 --> 00:09:07,100
code and that code should execute

00:09:03,650 --> 00:09:09,110
correctly anything that's marked red has

00:09:07,100 --> 00:09:11,120
issues there are things that reveal

00:09:09,110 --> 00:09:13,010
could not resolve or things that may

00:09:11,120 --> 00:09:15,140
need to be done by the user in order to

00:09:13,010 --> 00:09:17,630
create a parallel or to make this loop

00:09:15,140 --> 00:09:19,339
parallel so as an example here if I

00:09:17,630 --> 00:09:20,330
click on this particular loop that's

00:09:19,339 --> 00:09:22,000
marked in red

00:09:20,330 --> 00:09:24,080
the additional thing you get is

00:09:22,000 --> 00:09:25,790
information about what the issues are

00:09:24,080 --> 00:09:27,529
with scoping this what are the issues

00:09:25,790 --> 00:09:29,510
with running this loop in parallel and

00:09:27,529 --> 00:09:31,580
as we tried to scope the variables as

00:09:29,510 --> 00:09:34,700
shared or private to build a directive

00:09:31,580 --> 00:09:36,740
what sort of issues did we run into so

00:09:34,700 --> 00:09:38,300
you get a list of variables and you get

00:09:36,740 --> 00:09:40,250
anything that we were able to scope

00:09:38,300 --> 00:09:42,890
correctly is already listed and then

00:09:40,250 --> 00:09:44,720
anything that's not is flaked and then

00:09:42,890 --> 00:09:47,839
we give you a reason as to why a

00:09:44,720 --> 00:09:49,640
particular variable had it we had an

00:09:47,839 --> 00:09:53,000
issue with scoping a particular variable

00:09:49,640 --> 00:09:54,890
so in this in this case here now there's

00:09:53,000 --> 00:09:58,370
a variable name and when we put an @

00:09:54,890 --> 00:10:00,410
sign we are trying to convey that that

00:09:58,370 --> 00:10:02,300
particular variable came from a function

00:10:00,410 --> 00:10:05,390
down the call chain in this loop and the

00:10:02,300 --> 00:10:07,400
function was remap and then it says

00:10:05,390 --> 00:10:10,130
there's a possible occurrence involving

00:10:07,400 --> 00:10:12,290
this particular object and so the user

00:10:10,130 --> 00:10:14,000
gets the type of information at their

00:10:12,290 --> 00:10:16,190
fingertips as to why this particular

00:10:14,000 --> 00:10:20,690
loop cannot be executed in parallel as

00:10:16,190 --> 00:10:22,550
is another thing that we do is as we

00:10:20,690 --> 00:10:24,650
list the variables we may be able to

00:10:22,550 --> 00:10:25,540
scope a variable but we will scope it

00:10:24,650 --> 00:10:28,570
with a warrant

00:10:25,540 --> 00:10:31,600
in this particular case this variable is

00:10:28,570 --> 00:10:33,850
a reduction but it's a shared reduction

00:10:31,600 --> 00:10:36,670
and with openmp that is something that

00:10:33,850 --> 00:10:38,800
has to be called out and protected and

00:10:36,670 --> 00:10:40,900
so we will we will call out that this is

00:10:38,800 --> 00:10:42,580
a reduction with our directive but also

00:10:40,900 --> 00:10:44,050
the user will have to do something to

00:10:42,580 --> 00:10:47,880
create a critical section or something

00:10:44,050 --> 00:10:47,880
such that the loop can execute correctly

00:10:50,940 --> 00:10:54,730
so one of the things I showed you a

00:10:52,900 --> 00:10:58,450
Fortran example the other thing is what

00:10:54,730 --> 00:11:01,180
happens with C and C++ as we have more

00:10:58,450 --> 00:11:03,370
aliasing for example with C++ one of the

00:11:01,180 --> 00:11:07,480
things that we did add is we added the

00:11:03,370 --> 00:11:09,190
ability to more aggressively scope a

00:11:07,480 --> 00:11:10,000
particular variable instead of just

00:11:09,190 --> 00:11:12,190
giving up

00:11:10,000 --> 00:11:14,680
but flagging a warning so in this

00:11:12,190 --> 00:11:16,480
particular case I have a variable a it's

00:11:14,680 --> 00:11:19,180
a scalar and it's scoped is shared but I

00:11:16,480 --> 00:11:20,770
did flag a warning and we're saying that

00:11:19,180 --> 00:11:22,720
we're assuming there's no overlap with

00:11:20,770 --> 00:11:24,550
other objects we actually weren't able

00:11:22,720 --> 00:11:25,630
to determine if there was an overlap and

00:11:24,550 --> 00:11:28,350
that's something that the user is going

00:11:25,630 --> 00:11:30,850
to have to confirm or deny so if you

00:11:28,350 --> 00:11:33,910
request more information about that

00:11:30,850 --> 00:11:35,290
particular note what happens is then we

00:11:33,910 --> 00:11:37,450
will tell you that we're assuming that

00:11:35,290 --> 00:11:39,130
there's no overlap between these

00:11:37,450 --> 00:11:41,050
particular objects so we call it the

00:11:39,130 --> 00:11:43,900
objects again that you need to go and

00:11:41,050 --> 00:11:47,310
look at that are associated with a that

00:11:43,900 --> 00:11:47,310
might have potential overlap

00:11:49,190 --> 00:11:55,470
finally reveal has the ability to insert

00:11:52,620 --> 00:11:58,260
a directive for you so what we do is we

00:11:55,470 --> 00:11:59,910
create a comment and they say that this

00:11:58,260 --> 00:12:01,560
directive was inserted by reveal so it's

00:11:59,910 --> 00:12:03,170
very easy to identify which particular

00:12:01,560 --> 00:12:05,820
directives in your source code were

00:12:03,170 --> 00:12:08,040
inserted by reveal the other thing that

00:12:05,820 --> 00:12:10,020
we do is we can build a directive

00:12:08,040 --> 00:12:12,149
whether or not the loop is ready to be

00:12:10,020 --> 00:12:14,160
parallelized if it's not quite ready and

00:12:12,149 --> 00:12:16,740
there are some issues with particular

00:12:14,160 --> 00:12:19,770
variables we will put them in an illegal

00:12:16,740 --> 00:12:22,680
clause which we claim or which we tagged

00:12:19,770 --> 00:12:25,140
as unresolved and what this does is this

00:12:22,680 --> 00:12:27,750
Clause is basically like a set of

00:12:25,140 --> 00:12:29,220
homework or your your worksheet and so

00:12:27,750 --> 00:12:31,050
you can take this now to your favorite

00:12:29,220 --> 00:12:32,490
editor and you have your list of

00:12:31,050 --> 00:12:35,070
variables that you have to track through

00:12:32,490 --> 00:12:36,899
this particular loop to resolve so

00:12:35,070 --> 00:12:38,520
everything else that we could scope is

00:12:36,899 --> 00:12:41,370
already built into the directive and so

00:12:38,520 --> 00:12:43,170
that this functions just a once these

00:12:41,370 --> 00:12:45,390
particular variables are resolved and

00:12:43,170 --> 00:12:47,940
any potential restructuring or or

00:12:45,390 --> 00:12:50,070
changes are made such that the loop can

00:12:47,940 --> 00:12:52,470
be parallelized then your directive is

00:12:50,070 --> 00:12:55,079
ready to go so the user would overtime

00:12:52,470 --> 00:12:57,600
move these particular variables into

00:12:55,079 --> 00:13:05,370
their into their appropriate scoping

00:12:57,600 --> 00:13:07,829
scoping class so the next thing that we

00:13:05,370 --> 00:13:10,350
did in addition to building helping the

00:13:07,829 --> 00:13:12,690
user build directives scoping loops and

00:13:10,350 --> 00:13:14,550
doing the dependence analysis on loops

00:13:12,690 --> 00:13:17,130
in a batch environment is to take it one

00:13:14,550 --> 00:13:19,800
step further we also did an auto

00:13:17,130 --> 00:13:22,770
parallelization so what we did with this

00:13:19,800 --> 00:13:25,079
particular case is the user does the

00:13:22,770 --> 00:13:27,899
exact same thing as before they collect

00:13:25,079 --> 00:13:30,060
their work loop loop-the-loop estimates

00:13:27,899 --> 00:13:33,300
the work estimates excuse me they build

00:13:30,060 --> 00:13:34,920
their program and they launch reveal now

00:13:33,300 --> 00:13:36,329
the one thing is next to the scoping

00:13:34,920 --> 00:13:39,180
button there's also this lightning bolt

00:13:36,329 --> 00:13:41,670
so what happens if the user chooses this

00:13:39,180 --> 00:13:43,050
is everything that we have automatically

00:13:41,670 --> 00:13:45,450
selected every loop that we

00:13:43,050 --> 00:13:47,579
automatically selected because it has

00:13:45,450 --> 00:13:51,630
enough work to justify starting OpenMP

00:13:47,579 --> 00:13:53,820
threads is scoped on is analyzed the

00:13:51,630 --> 00:13:56,579
dependence analysis is performed the

00:13:53,820 --> 00:13:59,010
variables are scoped any resulting loops

00:13:56,579 --> 00:14:00,870
that were clean that had those green

00:13:59,010 --> 00:14:03,060
markers on them that were ready to be

00:14:00,870 --> 00:14:05,400
parallelized with OpenMP directives are

00:14:03,060 --> 00:14:07,940
automatically done so with virtual

00:14:05,400 --> 00:14:10,730
directives through the compile we

00:14:07,940 --> 00:14:13,949
rebuild the binary for the user and

00:14:10,730 --> 00:14:15,660
deposit a rebuilt binary as if the user

00:14:13,949 --> 00:14:17,610
had already inserted openmp directives

00:14:15,660 --> 00:14:20,040
into their source code so what this does

00:14:17,610 --> 00:14:22,560
is this gives you an experimental binary

00:14:20,040 --> 00:14:24,870
that you can run so this is a quick way

00:14:22,560 --> 00:14:26,400
to say is this gonna make a difference

00:14:24,870 --> 00:14:28,620
in my code I haven't changed a single

00:14:26,400 --> 00:14:30,270
line in my source code yet I just want

00:14:28,620 --> 00:14:33,600
to see if there's any low-hanging fruit

00:14:30,270 --> 00:14:35,850
to get any openmp parallelism and if so

00:14:33,600 --> 00:14:37,980
if it runs well then you just launch

00:14:35,850 --> 00:14:40,170
reveal again and ask it to add those

00:14:37,980 --> 00:14:40,380
those directives and then you're good to

00:14:40,170 --> 00:14:42,810
go

00:14:40,380 --> 00:14:48,390
so the result is OpenMP directives in

00:14:42,810 --> 00:14:50,640
your source code the other capability

00:14:48,390 --> 00:14:53,279
that the tool has is the ability let's

00:14:50,640 --> 00:14:54,810
say that I already added open P open MP

00:14:53,279 --> 00:14:56,370
directives in my source code but now I'm

00:14:54,810 --> 00:14:58,860
getting wrong answers and I don't know

00:14:56,370 --> 00:15:01,260
why one of the things that we can do is

00:14:58,860 --> 00:15:04,620
we can actually analyze your open MP

00:15:01,260 --> 00:15:06,120
directives and determine if there's any

00:15:04,620 --> 00:15:08,550
mismatch from what we think could happen

00:15:06,120 --> 00:15:10,470
what typically happens in this

00:15:08,550 --> 00:15:12,000
particular case I made a simple example

00:15:10,470 --> 00:15:14,160
I've got a directive that I have

00:15:12,000 --> 00:15:15,360
inserted here and I miss scoped one of

00:15:14,160 --> 00:15:17,100
the variables and you can see

00:15:15,360 --> 00:15:19,860
that reveal called it out saying hey

00:15:17,100 --> 00:15:21,300
variable n is marked as private but

00:15:19,860 --> 00:15:23,130
that's not what we agree we don't

00:15:21,300 --> 00:15:25,500
believe that that's the scoping from our

00:15:23,130 --> 00:15:28,440
analysis so that is something that you

00:15:25,500 --> 00:15:29,790
can you can quickly look at what

00:15:28,440 --> 00:15:32,730
typically happens in real applications

00:15:29,790 --> 00:15:34,940
is if somebody inserts directives and

00:15:32,730 --> 00:15:37,920
they're getting incorrect answers the

00:15:34,940 --> 00:15:40,709
what revealed it comes up with

00:15:37,920 --> 00:15:42,089
unresolved because it's a more tricky

00:15:40,709 --> 00:15:44,250
situation to scope that particular

00:15:42,089 --> 00:15:46,470
variable in the first place so the user

00:15:44,250 --> 00:15:49,079
may be overlooked something like overlap

00:15:46,470 --> 00:15:50,970
between other objects and but the

00:15:49,079 --> 00:15:53,880
benefit of reveal is even though it's

00:15:50,970 --> 00:15:55,170
unresolved it tells you why or gives you

00:15:53,880 --> 00:15:56,910
some indication as to why it's

00:15:55,170 --> 00:15:59,100
unresolved that might trigger something

00:15:56,910 --> 00:16:00,540
in your mind as to oh I should have

00:15:59,100 --> 00:16:03,029
really checked this maybe it was a

00:16:00,540 --> 00:16:05,940
shared reduction and I forgot to protect

00:16:03,029 --> 00:16:07,620
that variable or something the other

00:16:05,940 --> 00:16:10,050
thing I want to call out here too is

00:16:07,620 --> 00:16:12,450
that you'll notice this particular loop

00:16:10,050 --> 00:16:14,279
can be parallelized here it's green it's

00:16:12,450 --> 00:16:17,160
mark Greene and there's another loop

00:16:14,279 --> 00:16:19,709
below it so loops tick at line 69 in

00:16:17,160 --> 00:16:21,600
that lion 70 adjacent loops probably a

00:16:19,709 --> 00:16:23,519
nested loop one of the things that we'll

00:16:21,600 --> 00:16:25,560
do is we'll put a caution flag in there

00:16:23,519 --> 00:16:27,510
even though this particular loop at line

00:16:25,560 --> 00:16:30,779
70 could be parallelized

00:16:27,510 --> 00:16:32,370
it actually is better most likely in

00:16:30,779 --> 00:16:34,649
most cases two parallel eyes on the

00:16:32,370 --> 00:16:36,600
outer level and so we tell you even

00:16:34,649 --> 00:16:38,430
though we could put OpenMP directors

00:16:36,600 --> 00:16:44,430
here we really recommend you moving them

00:16:38,430 --> 00:16:46,470
out to the other to the outer level so

00:16:44,430 --> 00:16:47,490
finally the last thing just to give you

00:16:46,470 --> 00:16:50,100
a little bit of additional information

00:16:47,490 --> 00:16:51,959
as the compiler as we have the compiler

00:16:50,100 --> 00:16:53,730
optimization information let's say

00:16:51,959 --> 00:16:55,140
you've built your OpenMP directives and

00:16:53,730 --> 00:16:56,730
now you want to look at it within the

00:16:55,140 --> 00:16:59,220
loop you want to look at optimization

00:16:56,730 --> 00:17:00,810
opportunities such as vectorization one

00:16:59,220 --> 00:17:02,519
of the things that you can do as well as

00:17:00,810 --> 00:17:04,949
you can get your listing of all of your

00:17:02,519 --> 00:17:06,059
loops that by compiler messages so you

00:17:04,949 --> 00:17:07,829
can find all the loops in your

00:17:06,059 --> 00:17:10,589
application that did not vector eyes and

00:17:07,829 --> 00:17:12,360
they also have time associated with them

00:17:10,589 --> 00:17:13,949
so that you can find the ones that took

00:17:12,360 --> 00:17:16,439
the most time to execute and those would

00:17:13,949 --> 00:17:19,189
most likely be the first ones that you

00:17:16,439 --> 00:17:19,189
want to take a look at

00:17:20,130 --> 00:17:25,110
so that's basically an overview of the

00:17:23,130 --> 00:17:27,270
tool that hopefully helps reduce the

00:17:25,110 --> 00:17:29,610
amount of time that it takes to add

00:17:27,270 --> 00:17:31,230
openmp to your program the other thing

00:17:29,610 --> 00:17:32,910
in addition to this is even though it

00:17:31,230 --> 00:17:35,460
needs the Craig compiler and it's a

00:17:32,910 --> 00:17:38,370
crate or run-on cry systems they all the

00:17:35,460 --> 00:17:41,220
goal or the ultimate end is OpenMP

00:17:38,370 --> 00:17:43,289
directives in your source code and so it

00:17:41,220 --> 00:17:44,789
is portable and you can be taken with

00:17:43,289 --> 00:17:47,070
you with your application wherever you

00:17:44,789 --> 00:17:49,580
go with that

00:17:47,070 --> 00:17:49,580

YouTube URL: https://www.youtube.com/watch?v=f9iKCJ1LvIA


