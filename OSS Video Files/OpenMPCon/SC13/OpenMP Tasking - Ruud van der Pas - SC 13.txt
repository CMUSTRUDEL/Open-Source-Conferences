Title: OpenMP Tasking - Ruud van der Pas - SC 13
Publication date: 2014-12-13
Playlist: SC13
Description: 
	Ruud van der Pas (Oracle) gives an overview of tasking in OpenMP 4.0. Recorded at Supercomputing 13, November 20, 2013, in Denver.
Captions: 
	00:00:04,000 --> 00:00:08,490
that possible

00:00:06,049 --> 00:00:10,820
what is the process in the axial

00:00:08,490 --> 00:00:10,820
announced

00:00:15,670 --> 00:00:21,130
all right ready well welcome good

00:00:19,090 --> 00:00:24,730
morning I'm glad you you're taking the

00:00:21,130 --> 00:00:28,689
time to join this session before I start

00:00:24,730 --> 00:00:31,630
you all got the lucky draw so you can

00:00:28,689 --> 00:00:35,199
win a fleece jacket with the openmp logo

00:00:31,630 --> 00:00:38,379
on it as a special surprise I got

00:00:35,199 --> 00:00:41,170
approval to the most active participant

00:00:38,379 --> 00:00:42,670
will get one too so then you won't

00:00:41,170 --> 00:00:44,710
qualify for the lucky draw we're not

00:00:42,670 --> 00:00:47,590
going to give to to the same person but

00:00:44,710 --> 00:00:49,629
yeah so if you're very engaged which is

00:00:47,590 --> 00:00:53,589
may be hard for me to decide and I'm

00:00:49,629 --> 00:00:56,620
biased and whatever but yeah so there's

00:00:53,589 --> 00:00:59,680
going to be 22 prices here so I want to

00:00:56,620 --> 00:01:03,010
talk about tasking in a very fundamental

00:00:59,680 --> 00:01:06,100
way so go back to the basics what is

00:01:03,010 --> 00:01:09,330
tasking about before I do that I like to

00:01:06,100 --> 00:01:13,090
know anybody here used tasking already

00:01:09,330 --> 00:01:15,130
know yeah okay okay so that's good

00:01:13,090 --> 00:01:18,729
that's exactly the target audience for

00:01:15,130 --> 00:01:21,609
this top so let's get started so what

00:01:18,729 --> 00:01:25,840
was missing in OpenMP for a long time

00:01:21,609 --> 00:01:28,680
actually that was the following we

00:01:25,840 --> 00:01:33,670
couldn't deal well with irregular cases

00:01:28,680 --> 00:01:35,859
so it basically the compiler would

00:01:33,670 --> 00:01:38,859
welcome the compiler would have to see

00:01:35,859 --> 00:01:41,170
everything that meant when you would

00:01:38,859 --> 00:01:42,820
have a wide loop for example where you

00:01:41,170 --> 00:01:45,759
don't know how long you will go through

00:01:42,820 --> 00:01:48,310
the wire loop you could not paralyze it

00:01:45,759 --> 00:01:51,850
easily there were ways but it was really

00:01:48,310 --> 00:01:54,880
hard so as soon as you couldn't kind of

00:01:51,850 --> 00:01:56,920
count things in a way at runtime then

00:01:54,880 --> 00:02:00,609
you couldn't use OpenMP anymore and that

00:01:56,920 --> 00:02:03,520
was that was a big missing part another

00:02:00,609 --> 00:02:05,880
part was recursive algorithms there's

00:02:03,520 --> 00:02:09,069
nested parallelism but that's very heavy

00:02:05,880 --> 00:02:11,860
so many recursive algorithms are fairly

00:02:09,069 --> 00:02:13,450
lightweight so the overhead of the

00:02:11,860 --> 00:02:16,540
nested parallelism would kill any

00:02:13,450 --> 00:02:18,940
performance gain you may have so you

00:02:16,540 --> 00:02:22,240
could work your way around it few people

00:02:18,940 --> 00:02:25,840
did that and the solution was ugly at

00:02:22,240 --> 00:02:28,390
best that's how I like to say so we have

00:02:25,840 --> 00:02:32,740
a total new episode called tasking in

00:02:28,390 --> 00:02:36,250
days talk it was an introduced in open

00:02:32,740 --> 00:02:38,170
mp3 dodo so a couple of years ago that

00:02:36,250 --> 00:02:40,390
means by now it's it's available in

00:02:38,170 --> 00:02:43,350
every compiler that supports OpenMP

00:02:40,390 --> 00:02:46,390
should have tasking available for you

00:02:43,350 --> 00:02:48,130
and like I said it was hard to do

00:02:46,390 --> 00:02:51,760
certain types of parallelism until that

00:02:48,130 --> 00:02:55,270
point initially the functionality was

00:02:51,760 --> 00:02:57,910
very simple by design the idea was we

00:02:55,270 --> 00:03:00,550
don't know what we really need so we'll

00:02:57,910 --> 00:03:03,220
give you the basic framework and then as

00:03:00,550 --> 00:03:05,200
we issue new releases will add what

00:03:03,220 --> 00:03:07,540
people asking for and that's that's what

00:03:05,200 --> 00:03:10,150
we see happening now I will focus on the

00:03:07,540 --> 00:03:11,590
initial design for those of you don't

00:03:10,150 --> 00:03:13,630
have some more time I'll have some

00:03:11,590 --> 00:03:17,130
slides after the talk we can go into

00:03:13,630 --> 00:03:17,130
more detail if you if you like

00:03:18,180 --> 00:03:23,810
efficiently

00:03:19,980 --> 00:03:23,810
that means overhead was much higher than

00:03:24,220 --> 00:03:29,800
right so the question is when I say not

00:03:27,400 --> 00:03:32,350
efficient is that about over at exactly

00:03:29,800 --> 00:03:34,150
it would work but it would be really

00:03:32,350 --> 00:03:38,820
hard to get good performance especially

00:03:34,150 --> 00:03:41,320
on higher thread count exactly yeah so

00:03:38,820 --> 00:03:44,340
one comment I would like to make I could

00:03:41,320 --> 00:03:47,890
put it anywhere but you can you can nest

00:03:44,340 --> 00:03:49,900
tasks well I would say that's not for

00:03:47,890 --> 00:03:51,550
the faint of heart it will work but you

00:03:49,900 --> 00:03:56,500
better not really know what you do

00:03:51,550 --> 00:03:59,170
technically it is supported so what's

00:03:56,500 --> 00:04:03,790
the basic idea the basic idea is that

00:03:59,170 --> 00:04:06,450
you have a thread one thread and that

00:04:03,790 --> 00:04:10,060
friend is going to generate task

00:04:06,450 --> 00:04:12,790
actually the actually that implement the

00:04:10,060 --> 00:04:14,470
concept is more general than this but

00:04:12,790 --> 00:04:16,799
this is the most common use so you got

00:04:14,470 --> 00:04:21,930
one thread it will generate tasks and

00:04:16,799 --> 00:04:25,240
those task will be added to some Q so as

00:04:21,930 --> 00:04:29,530
that cube gets filled other threads can

00:04:25,240 --> 00:04:31,780
start executing so one will bond will

00:04:29,530 --> 00:04:33,520
generate the test and the other ones who

00:04:31,780 --> 00:04:36,910
say okay the task is ready i'll start

00:04:33,520 --> 00:04:40,150
executing it that's a very crucial step

00:04:36,910 --> 00:04:46,000
in the whole model of tasking to keep

00:04:40,150 --> 00:04:50,290
that in mind as as as I go further so

00:04:46,000 --> 00:04:54,010
who does what and when you're yeah your

00:04:50,290 --> 00:04:56,680
task is to find pieces of code that are

00:04:54,010 --> 00:04:59,800
independent and again you'll see

00:04:56,680 --> 00:05:01,840
examples soon but you have your

00:04:59,800 --> 00:05:04,290
application you have code blocks and you

00:05:01,840 --> 00:05:08,470
know they can be executed independently

00:05:04,290 --> 00:05:11,130
that's that's when you you you can use

00:05:08,470 --> 00:05:11,130
tasks

00:05:13,390 --> 00:05:19,370
exactly so the question is the user is

00:05:17,150 --> 00:05:21,260
responsible for getting it right yeah

00:05:19,370 --> 00:05:24,200
that's true that's true in general for

00:05:21,260 --> 00:05:26,300
openmp and there's no exception here you

00:05:24,200 --> 00:05:29,480
have to make sure that whatever is

00:05:26,300 --> 00:05:32,150
called the task can execute with another

00:05:29,480 --> 00:05:35,210
task for that same code block in

00:05:32,150 --> 00:05:37,250
parallel no side effects no sneaky

00:05:35,210 --> 00:05:41,140
modification of shared variables without

00:05:37,250 --> 00:05:41,140
having a critical region yeah question

00:05:41,680 --> 00:05:48,460
where it is how to balance your work

00:05:45,110 --> 00:05:52,210
balance you're the master whichever

00:05:48,460 --> 00:05:52,210
introductory task

00:05:52,420 --> 00:05:58,050
in a fast for the other yeah yeah

00:06:01,010 --> 00:06:06,480
no let me let me repeat the question and

00:06:03,720 --> 00:06:08,850
the answer was simple no but the

00:06:06,480 --> 00:06:11,340
question is how about the load balancing

00:06:08,850 --> 00:06:14,190
of all the tasks that's actually that's

00:06:11,340 --> 00:06:17,280
one of those high level design choices

00:06:14,190 --> 00:06:19,650
to not give you that control the runtime

00:06:17,280 --> 00:06:22,860
system is supposed to do the right thing

00:06:19,650 --> 00:06:25,260
always and we know that's not the case

00:06:22,860 --> 00:06:26,910
okay let's be fair about it we know

00:06:25,260 --> 00:06:28,740
that's not the case but it's an

00:06:26,910 --> 00:06:30,600
incentive for runtime systems to improve

00:06:28,740 --> 00:06:33,600
so there are actually very different

00:06:30,600 --> 00:06:37,680
queuing strategies and that's an ongoing

00:06:33,600 --> 00:06:42,750
field of research in judgment in people

00:06:37,680 --> 00:06:45,470
doing run time for openmp so will we

00:06:42,750 --> 00:06:47,940
have control in the future maybe maybe

00:06:45,470 --> 00:06:50,520
that's why then you have to wonder about

00:06:47,940 --> 00:06:53,520
what you know how how do you expose that

00:06:50,520 --> 00:06:56,610
how ugly is it going to be so it's

00:06:53,520 --> 00:06:58,770
certainly a point of attention but right

00:06:56,610 --> 00:07:00,960
now you don't have any control and we do

00:06:58,770 --> 00:07:04,140
no wrong time different runtime systems

00:07:00,960 --> 00:07:06,289
behave in a different way sometimes good

00:07:04,140 --> 00:07:07,720
sometimes bad

00:07:06,289 --> 00:07:10,990
after the basket

00:07:07,720 --> 00:07:12,639
so if i say gave a certain number of

00:07:10,990 --> 00:07:15,780
nostril

00:07:12,639 --> 00:07:15,780
that's not popular number of

00:07:17,760 --> 00:07:22,510
yeah you're basically asking how smart

00:07:20,200 --> 00:07:24,610
is the runtime system it really depends

00:07:22,510 --> 00:07:27,370
it really depends so there's already

00:07:24,610 --> 00:07:30,460
different queuing strategies who are you

00:07:27,370 --> 00:07:32,500
go to assign work too and there's a lot

00:07:30,460 --> 00:07:35,260
of improvement going on right now so

00:07:32,500 --> 00:07:37,930
initially the weak point of this was the

00:07:35,260 --> 00:07:40,630
efficiency of the runtime and we see

00:07:37,930 --> 00:07:44,410
huge improvements as time goes by now so

00:07:40,630 --> 00:07:47,410
yeah but basically right now you cannot

00:07:44,410 --> 00:07:49,360
make any assumption who does what okay

00:07:47,410 --> 00:07:51,790
this thing's like affinity how does that

00:07:49,360 --> 00:07:54,340
translate on a city Neumann machine for

00:07:51,790 --> 00:07:57,900
example again the hope is that runtime

00:07:54,340 --> 00:08:00,040
systems are clever enough to do that and

00:07:57,900 --> 00:08:02,560
I've been around long enough to know

00:08:00,040 --> 00:08:04,150
that that's not the case no but it may

00:08:02,560 --> 00:08:06,760
get there you know that's that's the

00:08:04,150 --> 00:08:10,150
thing so all right so that's the only

00:08:06,760 --> 00:08:12,310
thing you need to do in your program and

00:08:10,150 --> 00:08:14,830
then as i already said here's what

00:08:12,310 --> 00:08:17,110
happens your program executes the

00:08:14,830 --> 00:08:20,590
runtime will X encounter a task

00:08:17,110 --> 00:08:23,770
construct it will generate the task only

00:08:20,590 --> 00:08:25,690
generate it is a little bit like a

00:08:23,770 --> 00:08:28,540
malach when you do a malach you tell the

00:08:25,690 --> 00:08:31,030
OS I want some memory and later i'll be

00:08:28,540 --> 00:08:33,960
using it it's a kind of similar to that

00:08:31,030 --> 00:08:37,240
because nothing may happen at that point

00:08:33,960 --> 00:08:39,750
because the decision when to execute the

00:08:37,240 --> 00:08:43,360
task is really up to the runtime system

00:08:39,750 --> 00:08:45,840
again that's outside of your control so

00:08:43,360 --> 00:08:48,460
it can be immediate it can be delayed

00:08:45,840 --> 00:08:50,860
both can happen sometimes may start

00:08:48,460 --> 00:08:53,100
immediately other ones will be delayed

00:08:50,860 --> 00:08:53,100
so

00:08:53,340 --> 00:08:59,700
there is one thing though you can

00:08:55,920 --> 00:09:01,500
enforce when task should be completed so

00:08:59,700 --> 00:09:03,930
you can tell you'll see that in a minute

00:09:01,500 --> 00:09:07,490
you can tell now I want you to complete

00:09:03,930 --> 00:09:07,490
all children task yep

00:09:08,680 --> 00:09:14,560
multiple instances of the same task well

00:09:11,200 --> 00:09:17,560
there has to be yeah sure yeah it's

00:09:14,560 --> 00:09:21,310
whatever you embed in a pragma OMP task

00:09:17,560 --> 00:09:27,120
will be done yeah so yeah so yeah you

00:09:21,310 --> 00:09:29,950
can have the same task kind of yep so

00:09:27,120 --> 00:09:33,130
this is all you need to do is embed that

00:09:29,950 --> 00:09:35,410
code block use the pragma 1p ties go in

00:09:33,130 --> 00:09:42,370
fortran declared to be attached to the

00:09:35,410 --> 00:09:49,570
system no you can't you can I'll get

00:09:42,370 --> 00:09:52,510
back to that yeah okay so how about the

00:09:49,570 --> 00:09:56,740
whoops sorry for that there are two

00:09:52,510 --> 00:09:59,589
tasks synchronization constructs so this

00:09:56,740 --> 00:10:01,690
is when at a synchronization point is

00:09:59,589 --> 00:10:05,260
when you force the system to complete

00:10:01,690 --> 00:10:08,680
all children tasks it's like you're

00:10:05,260 --> 00:10:12,100
going to PM the queue and one is in the

00:10:08,680 --> 00:10:14,800
barrier so each time you have an implied

00:10:12,100 --> 00:10:18,390
or explicit barrier ties are going to be

00:10:14,800 --> 00:10:18,390
executed yep

00:10:20,010 --> 00:10:26,520
as soon as you hit the barrier the task

00:10:23,110 --> 00:10:26,520
the pending task will be completed

00:10:30,440 --> 00:10:36,990
yeah so the question is will how about a

00:10:33,360 --> 00:10:39,990
nested section yes indeed whenever

00:10:36,990 --> 00:10:43,190
there's a barrier tasks still pending

00:10:39,990 --> 00:10:43,190
will be executed

00:10:46,420 --> 00:10:52,339
yeah it doesn't matter where they are

00:10:48,939 --> 00:10:54,709
okay I as soon as the rent it's a very

00:10:52,339 --> 00:10:57,920
simple concept as soon as the runtime

00:10:54,709 --> 00:11:02,240
hits the barrier they'll start executing

00:10:57,920 --> 00:11:05,089
the tasks whatever is pending still okay

00:11:02,240 --> 00:11:07,730
so could be in a section could be at the

00:11:05,089 --> 00:11:11,089
end of a parallel region as soon or you

00:11:07,730 --> 00:11:15,860
put in a barrier yourself so doesn't

00:11:11,089 --> 00:11:17,540
matter yeah the other point is because

00:11:15,860 --> 00:11:19,189
it's not always you don't know just want

00:11:17,540 --> 00:11:21,379
to sprinkle barriers to complete tasks

00:11:19,189 --> 00:11:24,649
that's not a good idea so that's the

00:11:21,379 --> 00:11:28,129
task wait the task wait we'll wait for

00:11:24,649 --> 00:11:31,310
all pending children task to be to be

00:11:28,129 --> 00:11:35,470
finished so again that's when you p.m.

00:11:31,310 --> 00:11:35,470
the queue and after that you continue

00:11:37,040 --> 00:11:41,460
is that synchronous or asynchronous

00:11:39,230 --> 00:11:43,110
that's doubly synchronous you're going

00:11:41,460 --> 00:11:50,090
to wait you're going to wait for the

00:11:43,110 --> 00:11:52,770
task to be finished yep that's great

00:11:50,090 --> 00:11:54,510
well the bear the question is is there

00:11:52,770 --> 00:11:56,520
difference between the very end attached

00:11:54,510 --> 00:12:00,180
great absolutely the barrier is still

00:11:56,520 --> 00:12:02,460
the barrier so that's why that's why you

00:12:00,180 --> 00:12:05,430
can't just only have the barrier because

00:12:02,460 --> 00:12:08,670
you wouldn't like to add an a redundant

00:12:05,430 --> 00:12:12,660
barrier to complete your tasks okay so

00:12:08,670 --> 00:12:14,490
so that's why you have the task wait so

00:12:12,660 --> 00:12:17,340
you don't have the overhead of a barrier

00:12:14,490 --> 00:12:19,620
the implications with the barrier so you

00:12:17,340 --> 00:12:22,700
definitely need your own console this is

00:12:19,620 --> 00:12:26,840
like a safety net this will just make

00:12:22,700 --> 00:12:29,840
make the whole system easier and yeah

00:12:26,840 --> 00:12:29,840
what

00:12:31,080 --> 00:12:36,930
I don't know what's happening here but

00:12:32,910 --> 00:12:39,090
okay so I'll have one example and for a

00:12:36,930 --> 00:12:41,670
while I was struggling with giving you

00:12:39,090 --> 00:12:43,970
the simplest of simplest examples to

00:12:41,670 --> 00:12:46,860
show you how to asking kind of works

00:12:43,970 --> 00:12:48,930
because people used to start with

00:12:46,860 --> 00:12:50,970
something too complicated I think and

00:12:48,930 --> 00:12:55,140
you get lost in the details so this is

00:12:50,970 --> 00:12:57,180
admittedly very simple and it's going to

00:12:55,140 --> 00:13:00,420
be a little bit of audience audience

00:12:57,180 --> 00:13:03,390
participation time I will ask some

00:13:00,420 --> 00:13:06,360
questions and feel free to answer or

00:13:03,390 --> 00:13:07,920
just totally ignore me this is recorded

00:13:06,360 --> 00:13:10,770
by the way this will show up on the

00:13:07,920 --> 00:13:12,300
website one day I don't know what what

00:13:10,770 --> 00:13:15,930
will happen with the editing phase okay

00:13:12,300 --> 00:13:19,140
so your task for today is write a

00:13:15,930 --> 00:13:21,990
program that either prints a race car or

00:13:19,140 --> 00:13:27,390
a car race and maximize the parallelism

00:13:21,990 --> 00:13:30,870
in that assignment okay so we write a

00:13:27,390 --> 00:13:33,710
very simple program to print away three

00:13:30,870 --> 00:13:37,110
printf statements a race car all right

00:13:33,710 --> 00:13:38,790
so no brain a question what will this

00:13:37,110 --> 00:13:43,080
program print I'm not even going to wait

00:13:38,790 --> 00:13:45,680
for answers so all right so April paint

00:13:43,080 --> 00:13:45,680
a race car

00:13:46,529 --> 00:13:52,079
I could run this in parallel and

00:13:48,889 --> 00:13:55,499
embedded in a parallel region okay now

00:13:52,079 --> 00:13:59,639
it's going to be funny anybody daring to

00:13:55,499 --> 00:14:03,540
try what this will print exactly any

00:13:59,639 --> 00:14:07,230
combination of this as long as you obey

00:14:03,540 --> 00:14:09,509
a racecar okay i hope that clear could

00:14:07,230 --> 00:14:12,540
be a a great race cars it could be very

00:14:09,509 --> 00:14:14,579
funny english so and not being a native

00:14:12,540 --> 00:14:16,439
English speaker I can relate to that so

00:14:14,579 --> 00:14:19,879
although it won't hopefully won't be as

00:14:16,439 --> 00:14:22,410
bad as that oh yeah so so but that's not

00:14:19,879 --> 00:14:24,389
we don't fulfill the assignment that was

00:14:22,410 --> 00:14:26,339
not the question was being asked we

00:14:24,389 --> 00:14:29,220
should still print a race car a car race

00:14:26,339 --> 00:14:33,420
okay so theoretically indeed you can get

00:14:29,220 --> 00:14:35,579
all these combinations all right well we

00:14:33,420 --> 00:14:38,009
could cheat and put it in a single and

00:14:35,579 --> 00:14:39,389
then again we're back to a race car but

00:14:38,009 --> 00:14:42,120
now we don't have paralyzed him anymore

00:14:39,389 --> 00:14:44,430
so that will be rejected by the

00:14:42,120 --> 00:14:48,059
committee that doesn't qualify all right

00:14:44,430 --> 00:14:49,709
so you got this you can finally run and

00:14:48,059 --> 00:14:55,709
you get a race car but that's cheating

00:14:49,709 --> 00:14:59,009
so yeah of course tasking that's the

00:14:55,709 --> 00:15:02,069
answer to this to solve this problem so

00:14:59,009 --> 00:15:05,279
what I do I make each print here so I

00:15:02,069 --> 00:15:08,459
always want to have a okay and then I'll

00:15:05,279 --> 00:15:11,070
have race car racing car being a

00:15:08,459 --> 00:15:16,800
separate task

00:15:11,070 --> 00:15:19,470
hola so I hope that's clear that this

00:15:16,800 --> 00:15:21,840
does what you like it to do because the

00:15:19,470 --> 00:15:23,880
task will be executed independently so

00:15:21,840 --> 00:15:28,070
whoever comes in first will do the job

00:15:23,880 --> 00:15:32,130
so they have race car or car wrecks

00:15:28,070 --> 00:15:35,420
anybody daring to guess what this will

00:15:32,130 --> 00:15:35,420
will print

00:15:36,200 --> 00:15:39,860
you see now gets hard and now it's get

00:15:38,060 --> 00:15:43,070
quiet okay we're on a tight time

00:15:39,860 --> 00:15:46,550
schedule here so it'll it'll actually

00:15:43,070 --> 00:15:55,480
don't print what you expected the a will

00:15:46,550 --> 00:16:00,470
come last okay because he the tasking

00:15:55,480 --> 00:16:05,260
during that a will yeah that the tasking

00:16:00,470 --> 00:16:05,260
will print either car or car race yeah

00:16:05,750 --> 00:16:11,780
alright so you did well but I now I you

00:16:10,310 --> 00:16:14,150
know as in good tradition you get

00:16:11,780 --> 00:16:16,610
punished for good deeds you did well so

00:16:14,150 --> 00:16:20,000
now I want to do more I want you to

00:16:16,610 --> 00:16:23,600
extend the program and imprint a car

00:16:20,000 --> 00:16:27,560
race or race car is fun to watch all

00:16:23,600 --> 00:16:29,300
right so and as usually your teachers

00:16:27,560 --> 00:16:31,130
like to do they give you a useless hint

00:16:29,300 --> 00:16:35,330
use a print statement which is

00:16:31,130 --> 00:16:39,320
absolutely obvious so all right so okay

00:16:35,330 --> 00:16:44,510
i'll add is fun to watch now this is

00:16:39,320 --> 00:16:48,800
going to fail right this is going to

00:16:44,510 --> 00:16:50,510
fail because this is the way i read it

00:16:48,800 --> 00:16:53,750
but that's not how it's executed because

00:16:50,510 --> 00:16:56,120
these task will be deferred there will

00:16:53,750 --> 00:16:58,280
be deferred and they'll be printed in

00:16:56,120 --> 00:17:00,860
the first barrier which is going to be

00:16:58,280 --> 00:17:03,920
the single has an implied barrier so

00:17:00,860 --> 00:17:06,350
what we'll see is first a is fun to

00:17:03,920 --> 00:17:09,620
watch and then car race or race car now

00:17:06,350 --> 00:17:12,050
it's truly broken english and we don't

00:17:09,620 --> 00:17:14,180
we don't get what we want so indeed when

00:17:12,050 --> 00:17:17,569
you run it that's that's what you get so

00:17:14,180 --> 00:17:19,400
you absolutely need the task wait to

00:17:17,569 --> 00:17:21,400
make sure that you first get that part

00:17:19,400 --> 00:17:25,089
of the pins and then you continue

00:17:21,400 --> 00:17:28,209
alright so

00:17:25,089 --> 00:17:31,929
now we we have the whole thing and that

00:17:28,209 --> 00:17:34,179
basically completes the this tutorial

00:17:31,929 --> 00:17:36,789
again I have some more slides but the

00:17:34,179 --> 00:17:39,100
idea is to keep this tutorial in this

00:17:36,789 --> 00:17:42,340
length so if you want to hang around

00:17:39,100 --> 00:17:46,620
have more questions definitely there is

00:17:42,340 --> 00:17:46,620
a lucky draw but first I get to give oh

00:17:48,940 --> 00:17:51,780
did you

00:17:53,410 --> 00:17:57,520
there's some issues with tasking of

00:17:55,570 --> 00:18:00,450
course this was a very simple example I

00:17:57,520 --> 00:18:03,220
didn't talk about the data environment

00:18:00,450 --> 00:18:06,400
that's a fairly complicated part because

00:18:03,220 --> 00:18:09,180
how do you get data into a task and by

00:18:06,400 --> 00:18:11,920
default everything is first private so

00:18:09,180 --> 00:18:14,700
you can change that of course first

00:18:11,920 --> 00:18:17,260
private makes sense another thing is

00:18:14,700 --> 00:18:20,470
when you have typically when you have a

00:18:17,260 --> 00:18:23,230
recursive algorithm it gets smaller and

00:18:20,470 --> 00:18:25,990
smaller as you go down your recursion

00:18:23,230 --> 00:18:28,570
and what can happen is that the amount

00:18:25,990 --> 00:18:30,700
of work is so little that the task

00:18:28,570 --> 00:18:33,010
overhead will kill you that's why

00:18:30,700 --> 00:18:36,100
there's the final clause when you say

00:18:33,010 --> 00:18:38,890
stop generating tasks this start

00:18:36,100 --> 00:18:41,620
executing don't don't generate more task

00:18:38,890 --> 00:18:44,560
just keep on executing so that's like a

00:18:41,620 --> 00:18:47,890
fine tuning before we had that this is

00:18:44,560 --> 00:18:50,620
in three dot one because before we had

00:18:47,890 --> 00:18:54,100
that people would use ugly if if clauses

00:18:50,620 --> 00:18:56,410
and whatever the other one is because of

00:18:54,100 --> 00:18:59,950
the data environment each task inherits

00:18:56,410 --> 00:19:02,440
the data or part of it so when you have

00:18:59,950 --> 00:19:04,750
thousands of task you can need a lot of

00:19:02,440 --> 00:19:07,180
memory so that's when you start well

00:19:04,750 --> 00:19:11,170
merge them merge the data environment

00:19:07,180 --> 00:19:13,450
don't don't add more data to it okay so

00:19:11,170 --> 00:19:17,470
those are fine tunings to control the

00:19:13,450 --> 00:19:20,710
performance and the memory use it here's

00:19:17,470 --> 00:19:22,720
my example more complicated but more

00:19:20,710 --> 00:19:25,570
real-life that's going through a linked

00:19:22,720 --> 00:19:29,500
list so let's say I have this while loop

00:19:25,570 --> 00:19:31,690
and I call some function and it gets an

00:19:29,500 --> 00:19:34,510
entry from the linked list but each

00:19:31,690 --> 00:19:36,580
entry represents independent work so I

00:19:34,510 --> 00:19:39,520
could do them in parallel but this is a

00:19:36,580 --> 00:19:42,670
very sequential process I go through

00:19:39,520 --> 00:19:44,680
that in English you could do that in the

00:19:42,670 --> 00:19:47,350
in the ugly style you could count all

00:19:44,680 --> 00:19:49,210
the iterations and then build a for loop

00:19:47,350 --> 00:19:50,860
out of it but that was you could scan

00:19:49,210 --> 00:19:52,690
your linked list and then build a for

00:19:50,860 --> 00:19:59,590
loop that's really ugly and nobody did

00:19:52,690 --> 00:20:02,020
that so so that's what they said so

00:19:59,590 --> 00:20:04,750
here's the opening Pico let me

00:20:02,020 --> 00:20:09,670
you through it we have the the parallel

00:20:04,750 --> 00:20:12,070
region right and again I want this is a

00:20:09,670 --> 00:20:15,670
sequential process to generate the tasks

00:20:12,070 --> 00:20:17,200
so I put it in a single which is really

00:20:15,670 --> 00:20:19,780
funny when you look at it parallel

00:20:17,200 --> 00:20:22,090
single like that doesn't seem to make

00:20:19,780 --> 00:20:25,900
much sense it makes more sense with

00:20:22,090 --> 00:20:29,200
tasks so 11 threat will encounter the

00:20:25,900 --> 00:20:31,990
single and will start executing this all

00:20:29,200 --> 00:20:34,690
other threats will skip it and they'll

00:20:31,990 --> 00:20:36,700
start waiting in the barrier here that

00:20:34,690 --> 00:20:39,610
means they will start executing the task

00:20:36,700 --> 00:20:48,070
that you're a threat is generating all

00:20:39,610 --> 00:20:49,870
right yeah yeah ending any regular way

00:20:48,070 --> 00:20:55,360
of opening p to set the number of

00:20:49,870 --> 00:20:57,850
threads will be used here right right

00:20:55,360 --> 00:21:01,120
right so you can just set down here none

00:20:57,850 --> 00:21:03,870
fits whatever and whatever mine is one

00:21:01,120 --> 00:21:06,160
will start executing the tasks and

00:21:03,870 --> 00:21:10,440
eventually if this one is finished it

00:21:06,160 --> 00:21:10,440
will also start executing its own tasks

00:21:11,940 --> 00:21:16,990
no they're guess it has that the single

00:21:15,250 --> 00:21:22,360
has a barrier so the task will be

00:21:16,990 --> 00:21:24,790
executed here not here so in the in the

00:21:22,360 --> 00:21:27,010
next version that I'll show I have no

00:21:24,790 --> 00:21:30,630
way because I don't like having two

00:21:27,010 --> 00:21:34,630
barriers now let me let me show that one

00:21:30,630 --> 00:21:37,510
so the right way to do it would be to

00:21:34,630 --> 00:21:40,840
have no wait here so they'll get

00:21:37,510 --> 00:21:42,640
executed here not here okay you don't

00:21:40,840 --> 00:21:46,180
want to have too many barriers Yeah

00:21:42,640 --> 00:21:49,960
right i wish i had another fleece jacket

00:21:46,180 --> 00:21:53,230
for you it's a good question so but yeah

00:21:49,960 --> 00:21:57,670
so so what's happening here is that

00:21:53,230 --> 00:22:01,030
these these tasks will be generated only

00:21:57,670 --> 00:22:02,860
again so they'll grab when you look at

00:22:01,030 --> 00:22:05,500
the full code del grab an entry from the

00:22:02,860 --> 00:22:07,390
list and do some work so now i have all

00:22:05,500 --> 00:22:11,290
these entries being generated they'll be

00:22:07,390 --> 00:22:14,000
executed so the first time i saw this

00:22:11,290 --> 00:22:15,530
this is not counterintuitive

00:22:14,000 --> 00:22:17,360
second time it's less known

00:22:15,530 --> 00:22:20,600
counterintuitive and by the third time

00:22:17,360 --> 00:22:23,990
you get it but it's it's it's some sort

00:22:20,600 --> 00:22:26,450
of template of how you do this I didn't

00:22:23,990 --> 00:22:27,980
put it on the slides here but there's

00:22:26,450 --> 00:22:31,370
this other templates were like a

00:22:27,980 --> 00:22:34,220
recursive functions somewhat somewhat

00:22:31,370 --> 00:22:36,620
different but yeah so that is the same I

00:22:34,220 --> 00:22:40,520
think that was my yes the light one so

00:22:36,620 --> 00:22:45,200
what's new in for dodo the two main

00:22:40,520 --> 00:22:48,380
extensions are dependencies now you can

00:22:45,200 --> 00:22:50,690
say this that should only execute it

00:22:48,380 --> 00:22:53,300
when the other ones when this group has

00:22:50,690 --> 00:22:55,760
finished that's I think a useful

00:22:53,300 --> 00:22:58,610
addition not everybody will need it but

00:22:55,760 --> 00:23:00,530
it was clearly missing in the sense that

00:22:58,610 --> 00:23:02,750
like I said we want to keep it simple

00:23:00,530 --> 00:23:06,320
and this was clearly needed so it has

00:23:02,750 --> 00:23:08,600
been added info todo likewise you can

00:23:06,320 --> 00:23:11,870
talk about this task group you can group

00:23:08,600 --> 00:23:16,040
tasks and actually when when you have

00:23:11,870 --> 00:23:18,590
the task wait it will only preamp to

00:23:16,040 --> 00:23:21,380
direct children not whatever those might

00:23:18,590 --> 00:23:24,130
have generated all right now they'll

00:23:21,380 --> 00:23:26,990
complete all all of them will complete

00:23:24,130 --> 00:23:28,670
that's a last freaking scenario i think

00:23:26,990 --> 00:23:30,380
they depend is very useful this one is

00:23:28,670 --> 00:23:33,050
definitely useful but for a smaller

00:23:30,380 --> 00:23:35,510
audience than depend probably so that's

00:23:33,050 --> 00:23:37,130
good that's on your way to you I don't

00:23:35,510 --> 00:23:40,100
know for you those of you in the buff

00:23:37,130 --> 00:23:42,800
yesterday compiler people are busy

00:23:40,100 --> 00:23:45,950
typing it all in and having folded over

00:23:42,800 --> 00:23:47,740
available so I don't know when it within

00:23:45,950 --> 00:23:51,590
six months I think you'll start seeing

00:23:47,740 --> 00:23:53,570
first por todo compilers being there and

00:23:51,590 --> 00:23:57,160
a year from now think we'll all have

00:23:53,570 --> 00:24:07,010
photo token pirates

00:23:57,160 --> 00:24:09,920
Yeah Yeah right yes yes oh well depend

00:24:07,010 --> 00:24:12,980
is you're not necessarily want to have

00:24:09,920 --> 00:24:15,230
all the tasks finish but when you think

00:24:12,980 --> 00:24:17,090
of for example some sort of pipelines

00:24:15,230 --> 00:24:19,190
approach where you say well I won't

00:24:17,090 --> 00:24:21,380
start until you have completed this work

00:24:19,190 --> 00:24:24,170
you can't do that with task wait this

00:24:21,380 --> 00:24:28,430
very brute force because everybody will

00:24:24,170 --> 00:24:31,160
complete and maybe yeah so maybe you

00:24:28,430 --> 00:24:33,470
only maybe only if a part of the work

00:24:31,160 --> 00:24:36,670
has been done some other tasks can

00:24:33,470 --> 00:24:41,700
continue so you can be more selective

00:24:36,670 --> 00:24:44,330
right Yeah Yeah right yeah so

00:24:41,700 --> 00:24:44,330

YouTube URL: https://www.youtube.com/watch?v=g-kJBaN_xgQ


