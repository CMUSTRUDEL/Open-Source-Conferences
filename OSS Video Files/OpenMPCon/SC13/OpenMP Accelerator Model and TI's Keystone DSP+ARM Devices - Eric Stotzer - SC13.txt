Title: OpenMP Accelerator Model and TI's Keystone DSP+ARM Devices - Eric Stotzer - SC13
Publication date: 2014-12-13
Playlist: SC13
Description: 
	Eric Stotzer (Texas Instruments) describes using OpenMP 4.0 new accelerator model with TI's attached DSP+ARM devices.
Recorded at Supercomputing 13, November 2013 in Denver CO.
Captions: 
	00:00:09,800 --> 00:00:17,070
alright my name is Eric stat sir and I'm

00:00:14,429 --> 00:00:20,010
going to be talking to you about openmp

00:00:17,070 --> 00:00:22,320
accelerator model for TI's arm + DSP

00:00:20,010 --> 00:00:26,340
devices or i would say DSP plus arm

00:00:22,320 --> 00:00:28,680
devices i just want to acknowledge a j

00:00:26,340 --> 00:00:30,980
Jairaj who's actually right over there

00:00:28,680 --> 00:00:33,030
he's done a lot of the actual work in

00:00:30,980 --> 00:00:35,070
what I'm showing you especially in the

00:00:33,030 --> 00:00:39,239
runtime area so it's definitely a

00:00:35,070 --> 00:00:40,920
collaboration here so first off I just

00:00:39,239 --> 00:00:43,020
wanted to give you a feeling for where

00:00:40,920 --> 00:00:46,559
we're coming from where T is coming from

00:00:43,020 --> 00:00:49,079
in this area so we've had this DSP

00:00:46,559 --> 00:00:51,690
processor for quite a long time now that

00:00:49,079 --> 00:00:54,480
has evolved you know one first

00:00:51,690 --> 00:00:56,969
generation back in their 90's to where

00:00:54,480 --> 00:00:59,870
it is today it's a VLIW based processor

00:00:56,969 --> 00:01:03,930
it's got eight functional units it's got

00:00:59,870 --> 00:01:06,510
program cache data cache it gets a lot

00:01:03,930 --> 00:01:09,299
of it's got simdi instructions this is

00:01:06,510 --> 00:01:11,510
our DSP we've gotten a lot of mileage

00:01:09,299 --> 00:01:13,650
out of this DSP in the embedded space

00:01:11,510 --> 00:01:15,659
really in the telecommunication

00:01:13,650 --> 00:01:17,790
infrastructure space so these would be

00:01:15,659 --> 00:01:20,040
like your base stations your networking

00:01:17,790 --> 00:01:22,220
hubs for telecommunications

00:01:20,040 --> 00:01:25,830
infrastructure that's where we made our

00:01:22,220 --> 00:01:28,740
bread and butter to build this processor

00:01:25,830 --> 00:01:30,920
so that's our DSP you can think of a DSP

00:01:28,740 --> 00:01:33,740
is like a heavy-duty math coprocessor

00:01:30,920 --> 00:01:38,930
optimized for doing math computations

00:01:33,740 --> 00:01:41,640
especially multiply accumulate so then

00:01:38,930 --> 00:01:43,079
those were usually single core for many

00:01:41,640 --> 00:01:46,560
years but then you know when the

00:01:43,079 --> 00:01:48,210
multi-core revolution happened we of

00:01:46,560 --> 00:01:50,729
course did the same thing we put

00:01:48,210 --> 00:01:53,189
multiple versions of that processor on

00:01:50,729 --> 00:01:56,310
one trip so we ended up with a processor

00:01:53,189 --> 00:01:58,740
called the c 6 6 7 8 which had eight of

00:01:56,310 --> 00:02:00,210
these DSPs on there and when the other

00:01:58,740 --> 00:02:02,729
things we did was we added

00:02:00,210 --> 00:02:05,070
floating-point so this is the first

00:02:02,729 --> 00:02:08,550
processor that we wanted to run OpenMP

00:02:05,070 --> 00:02:10,770
on and so before we even got into our

00:02:08,550 --> 00:02:13,830
mat + DSP heterogeneous we were trying

00:02:10,770 --> 00:02:15,870
to figure out how to run OpenMP

00:02:13,830 --> 00:02:17,850
this DSP processor which we did we have

00:02:15,870 --> 00:02:20,700
a DS we have a product today that you

00:02:17,850 --> 00:02:24,720
can buy OpenMP product compiler product

00:02:20,700 --> 00:02:27,720
that you can run on this DSP and so then

00:02:24,720 --> 00:02:31,530
that sort of evolved up and then our

00:02:27,720 --> 00:02:33,000
major play to attract HPC was to talk

00:02:31,530 --> 00:02:34,530
about how energy efficient we were

00:02:33,000 --> 00:02:38,100
because again coming from the embedded

00:02:34,530 --> 00:02:41,430
space that was always one of our main

00:02:38,100 --> 00:02:44,310
drivers was to be low power so I'm just

00:02:41,430 --> 00:02:46,680
showing you something that we showed in

00:02:44,310 --> 00:02:51,690
our booth last year this is work done by

00:02:46,680 --> 00:02:53,370
some folks from k th and it's Gilbert

00:02:51,690 --> 00:02:56,400
net sir Leonard Johnson and Daniel

00:02:53,370 --> 00:02:57,780
Conlon they they had a little demo

00:02:56,400 --> 00:03:00,180
running where they showed a limp back

00:02:57,780 --> 00:03:03,360
power profile and then they measured

00:03:00,180 --> 00:03:06,090
various consumption power consumption

00:03:03,360 --> 00:03:08,730
for linpack the key was that they got

00:03:06,090 --> 00:03:10,470
around 2.1 gigaflops per watt which was

00:03:08,730 --> 00:03:13,890
at the time you know that's pretty

00:03:10,470 --> 00:03:15,180
impressive I'm going to leave that for

00:03:13,890 --> 00:03:16,470
you to look at online this is this

00:03:15,180 --> 00:03:18,709
presentation may online to read the

00:03:16,470 --> 00:03:23,970
detail I just wanted to point that out

00:03:18,709 --> 00:03:25,620
it'll be on the openmp website so so

00:03:23,970 --> 00:03:27,989
then then you go we start integrating

00:03:25,620 --> 00:03:29,400
these DSPs onto multiple cards and

00:03:27,989 --> 00:03:32,310
people start talking about putting these

00:03:29,400 --> 00:03:34,019
into pcie slots and using them as

00:03:32,310 --> 00:03:38,940
accelerators so now you're running

00:03:34,019 --> 00:03:40,650
OpenMP programs on these individual DSPs

00:03:38,940 --> 00:03:42,510
that you're getting through from like an

00:03:40,650 --> 00:03:45,750
Intel platform or something like that so

00:03:42,510 --> 00:03:48,390
that's that was sort of our last year

00:03:45,750 --> 00:03:50,130
time frame and then we came out me

00:03:48,390 --> 00:03:52,680
announced this chip at the last

00:03:50,130 --> 00:03:53,940
supercomputing and this is the processor

00:03:52,680 --> 00:03:57,330
I'm really going to focus on more today

00:03:53,940 --> 00:04:01,200
so we took those eight DSPs and we added

00:03:57,330 --> 00:04:03,030
for RMA 15s on the front of them and so

00:04:01,200 --> 00:04:05,190
now we have this heterogeneous processor

00:04:03,030 --> 00:04:07,260
with for a 15 s that are running SMP

00:04:05,190 --> 00:04:09,030
linux and then you've got these eight

00:04:07,260 --> 00:04:11,250
DSPs over there so this is where the

00:04:09,030 --> 00:04:13,769
accelerator model becomes very

00:04:11,250 --> 00:04:15,810
interesting for us because we want to be

00:04:13,769 --> 00:04:18,180
able to people are just taking their arm

00:04:15,810 --> 00:04:22,320
code and then carving out pieces of it

00:04:18,180 --> 00:04:25,020
and offloading it to this DSPs this

00:04:22,320 --> 00:04:27,300
architecture is interesting because the

00:04:25,020 --> 00:04:27,630
dis peas in the arms have access to a

00:04:27,300 --> 00:04:30,660
share

00:04:27,630 --> 00:04:32,520
remembering so there's no copying you

00:04:30,660 --> 00:04:34,590
know over a pcie bus or anything there's

00:04:32,520 --> 00:04:36,300
just some work you need to do to

00:04:34,590 --> 00:04:38,280
translate the virtual memory address

00:04:36,300 --> 00:04:41,040
that Linux cease to a physical memory

00:04:38,280 --> 00:04:43,710
address that the DSP will see but that's

00:04:41,040 --> 00:04:45,240
just a pointer translation it's still

00:04:43,710 --> 00:04:47,670
the same memory space so you don't have

00:04:45,240 --> 00:04:50,190
to do the memory copy there's also some

00:04:47,670 --> 00:04:52,620
interesting io peripherals on this

00:04:50,190 --> 00:04:53,790
device for moving things around in the

00:04:52,620 --> 00:04:55,650
system i'm not going to get into those

00:04:53,790 --> 00:04:58,260
so much today but i just wanted to

00:04:55,650 --> 00:05:00,720
highlight this and there's a lot of

00:04:58,260 --> 00:05:02,790
on-chip actual memory that you use to

00:05:00,720 --> 00:05:04,320
get to get real peak performance you

00:05:02,790 --> 00:05:06,650
move things into this on chip memory

00:05:04,320 --> 00:05:06,650
space

00:05:08,060 --> 00:05:17,419
so what it's a the chip can actually

00:05:13,880 --> 00:05:19,130
access up to 10 gigabytes ok so the arm

00:05:17,419 --> 00:05:21,980
actually has an extension where it has a

00:05:19,130 --> 00:05:25,100
40-bit address space the DSPs can only

00:05:21,980 --> 00:05:26,600
see 32 bits of address at a time so you

00:05:25,100 --> 00:05:28,160
have to figure out a way to kind of

00:05:26,600 --> 00:05:30,590
carve things up you have to work in

00:05:28,160 --> 00:05:33,139
essentially 4 gigabyte blocks that's all

00:05:30,590 --> 00:05:37,760
the DSP can address at one time but the

00:05:33,139 --> 00:05:41,060
arm can actually address 10 gigabytes up

00:05:37,760 --> 00:05:43,160
so then you go from before I was showing

00:05:41,060 --> 00:05:45,350
you those boards to now we actually have

00:05:43,160 --> 00:05:48,500
vendors who are building systems based

00:05:45,350 --> 00:05:50,690
on that SOC that I just showed you so we

00:05:48,500 --> 00:05:51,979
have brett i know that's incredibly

00:05:50,690 --> 00:05:53,360
small you can't read that but again i

00:05:51,979 --> 00:05:55,250
put that on there so it you can go

00:05:53,360 --> 00:05:56,810
online and take a look at it but it come

00:05:55,250 --> 00:05:58,639
by the TI booth we can show you more

00:05:56,810 --> 00:06:00,919
detail on this we have a company called

00:05:58,639 --> 00:06:04,070
n Corps who's taking a chassis that's

00:06:00,919 --> 00:06:05,419
from the traditional embedded world and

00:06:04,070 --> 00:06:07,370
he's saying hey let's use this for

00:06:05,419 --> 00:06:09,110
high-performance computing so he's built

00:06:07,370 --> 00:06:11,150
these compete nodes that plug into this

00:06:09,110 --> 00:06:13,220
chassis based on that processor I just

00:06:11,150 --> 00:06:15,169
showed you he's using the openmp

00:06:13,220 --> 00:06:17,510
accelerator model prototype that we've

00:06:15,169 --> 00:06:20,810
put together to actually run programs on

00:06:17,510 --> 00:06:23,479
it and then we have HP in there moonshot

00:06:20,810 --> 00:06:25,490
program chassis where they've selected

00:06:23,479 --> 00:06:27,080
that chip I just showed you is one of

00:06:25,490 --> 00:06:29,030
their platforms that they're supporting

00:06:27,080 --> 00:06:30,979
in moonshot so they've built this

00:06:29,030 --> 00:06:32,900
cartridge that's got four of those

00:06:30,979 --> 00:06:34,160
processors on there and they've

00:06:32,900 --> 00:06:35,960
connected it using some of those

00:06:34,160 --> 00:06:37,690
high-speed interconnects that I

00:06:35,960 --> 00:06:39,710
highlighted on the chip before so now

00:06:37,690 --> 00:06:42,080
what I'm trying to show you is we've

00:06:39,710 --> 00:06:44,900
evolved from cards that are plugging in

00:06:42,080 --> 00:06:46,940
the PCIe few systems where the arm is

00:06:44,900 --> 00:06:50,500
the main processor in the system and

00:06:46,940 --> 00:06:50,500
it's off letting code to the DSPs

00:06:51,889 --> 00:07:00,279
what are you doing back there man behind

00:06:55,490 --> 00:07:02,120
the curtain okay so I'm just

00:07:00,279 --> 00:07:03,830
transitioning now to explain to you how

00:07:02,120 --> 00:07:07,669
we actually implement the openmp

00:07:03,830 --> 00:07:10,159
accelerator model on our DSP and this is

00:07:07,669 --> 00:07:12,680
just kind of a boilerplate of why openmp

00:07:10,159 --> 00:07:14,749
is good why we wanted to use it for DSP

00:07:12,680 --> 00:07:17,090
you know these are just nice things

00:07:14,749 --> 00:07:18,770
about OpenMP why it was attractive for

00:07:17,090 --> 00:07:21,499
us when we were looking at going from a

00:07:18,770 --> 00:07:24,159
single core DSP to multi-core DSP why we

00:07:21,499 --> 00:07:25,969
were attracted to using OpenMP okay

00:07:24,159 --> 00:07:28,279
mainly it was you know you had this

00:07:25,969 --> 00:07:32,870
incremental approach it was portable and

00:07:28,279 --> 00:07:34,849
it was continuing to evolve so this

00:07:32,870 --> 00:07:38,629
gives you a feel for how we actually run

00:07:34,849 --> 00:07:40,490
OpenMP on the DSP processors so we have

00:07:38,629 --> 00:07:43,279
a stack over here so this is sort of the

00:07:40,490 --> 00:07:45,830
users view of openmp underneath that is

00:07:43,279 --> 00:07:48,379
a runtime layer but our runtime layer is

00:07:45,830 --> 00:07:50,749
running right we call it bare metal it's

00:07:48,379 --> 00:07:53,689
there's no operating system between the

00:07:50,749 --> 00:07:56,180
runtime layer and the device there's

00:07:53,689 --> 00:07:58,490
just these low-level drivers that the

00:07:56,180 --> 00:08:00,439
openmp runtime is sitting on top of so

00:07:58,490 --> 00:08:02,860
that you're very close to the hardware

00:08:00,439 --> 00:08:07,610
when you're running OpenMP on the DSP

00:08:02,860 --> 00:08:10,129
processors we actually leverage hardware

00:08:07,610 --> 00:08:12,229
that's built into our chip called

00:08:10,129 --> 00:08:14,750
navigator which are these hardware to

00:08:12,229 --> 00:08:15,979
use hard that are on the chip that were

00:08:14,750 --> 00:08:18,289
actually put there for doing

00:08:15,979 --> 00:08:23,360
telecommunications but we're repurposing

00:08:18,289 --> 00:08:28,149
them for for putting events between

00:08:23,360 --> 00:08:28,149
threads in our OpenMP implementation

00:08:33,659 --> 00:08:41,579
right now we support 30 and uh oh so how

00:08:38,490 --> 00:08:44,250
much of the openmp specification do we

00:08:41,579 --> 00:08:46,440
currently support on the DSPs we support

00:08:44,250 --> 00:08:47,879
30 and then we have our OpenMP

00:08:46,440 --> 00:08:49,920
accelerator model prototype where we've

00:08:47,879 --> 00:09:00,660
just supported the openmp device

00:08:49,920 --> 00:09:02,879
constructs from bordado so we're are I

00:09:00,660 --> 00:09:04,500
mean we want to support the spec totally

00:09:02,879 --> 00:09:06,899
so you know yeah obviously our customers

00:09:04,500 --> 00:09:10,680
maybe use more parts of it than they do

00:09:06,899 --> 00:09:12,750
other but yeah we you know the the the

00:09:10,680 --> 00:09:16,470
compiler for the DS pieces from us it's

00:09:12,750 --> 00:09:20,910
a proprietary TI compiler it's a see

00:09:16,470 --> 00:09:22,170
compile yeah with C C++ so okay I didn't

00:09:20,910 --> 00:09:26,009
get all those questions but you got it

00:09:22,170 --> 00:09:27,360
all right I just wanted to highlight for

00:09:26,009 --> 00:09:28,740
you what this multi-core navigator

00:09:27,360 --> 00:09:30,720
hardware is so that's a block that's

00:09:28,740 --> 00:09:33,000
actually on the chip it's a bunch of

00:09:30,720 --> 00:09:35,339
hardware to use theirs on this

00:09:33,000 --> 00:09:37,529
particular device there's 16k of these

00:09:35,339 --> 00:09:39,660
Hardware keys the nice thing is that

00:09:37,529 --> 00:09:42,779
they have atomic access so you can have

00:09:39,660 --> 00:09:44,759
one thread be posting an event into

00:09:42,779 --> 00:09:47,639
those q's another thread pulling it out

00:09:44,759 --> 00:09:49,319
and you have this nice atomic access

00:09:47,639 --> 00:09:50,730
capability built into them so you know

00:09:49,319 --> 00:09:54,209
if the lock around them or anything like

00:09:50,730 --> 00:09:59,310
that so it's a very important part of

00:09:54,209 --> 00:10:01,410
our run time all right so now came open

00:09:59,310 --> 00:10:03,600
mp4 Tonto again my description of of

00:10:01,410 --> 00:10:05,250
ti's OpenMP is following kind of what i

00:10:03,600 --> 00:10:07,949
showed you before with the hardware

00:10:05,250 --> 00:10:10,589
first we supported the DSPs and now that

00:10:07,949 --> 00:10:13,470
we have open mp40 we're supporting the

00:10:10,589 --> 00:10:15,509
heterogeneous model lots of good things

00:10:13,470 --> 00:10:18,120
rather than open mp4 dunno but i'm going

00:10:15,509 --> 00:10:21,959
to focus here on what we did with the

00:10:18,120 --> 00:10:23,910
device support do we have customers that

00:10:21,959 --> 00:10:25,500
use fortran we have people that have

00:10:23,910 --> 00:10:27,630
approached us and it said do you have a

00:10:25,500 --> 00:10:31,079
fortran compiler but so far we haven't

00:10:27,630 --> 00:10:32,990
anybody make it a requirement okay

00:10:31,079 --> 00:10:35,519
they've been willing to use C and C++

00:10:32,990 --> 00:10:37,019
but we're always on the edge of saying

00:10:35,519 --> 00:10:42,300
okay we need a fortran compiler we need

00:10:37,019 --> 00:10:44,689
a fortran compiler yeah so i'm going to

00:10:42,300 --> 00:10:44,689
skip this slide

00:11:01,089 --> 00:11:08,379
there we go okay so an open mp4 dono we

00:11:06,069 --> 00:11:09,850
added this target I say we because I'm

00:11:08,379 --> 00:11:12,730
part of the committee that actually

00:11:09,850 --> 00:11:15,550
defined the openmp Florida specification

00:11:12,730 --> 00:11:18,639
in particular the these new device

00:11:15,550 --> 00:11:21,610
constructs accelerator model but we have

00:11:18,639 --> 00:11:24,490
this new OMP target construct that

00:11:21,610 --> 00:11:27,550
allows that enables you to offload code

00:11:24,490 --> 00:11:30,339
and data to a separate device in this

00:11:27,550 --> 00:11:31,870
case our DSP cores so here we have the

00:11:30,339 --> 00:11:34,449
host device which is our arm cores

00:11:31,870 --> 00:11:36,160
running SMP linux offloading code over

00:11:34,449 --> 00:11:38,319
to our target device which is our DSPs

00:11:36,160 --> 00:11:40,360
we have some sort of we have this

00:11:38,319 --> 00:11:42,699
concept of mapping data to the device

00:11:40,360 --> 00:11:44,639
mapping data from the device and our

00:11:42,699 --> 00:11:46,540
device we actually are just leveraging

00:11:44,639 --> 00:11:50,850
the shared memory we're not actually

00:11:46,540 --> 00:11:50,850
doing a copy so

00:11:54,010 --> 00:11:58,600
on the device constructs you have this

00:11:56,110 --> 00:12:02,140
concept of mapping data to a device so

00:11:58,600 --> 00:12:05,320
you say OMP target data map variable a

00:12:02,140 --> 00:12:08,020
to a device map variable B map variable

00:12:05,320 --> 00:12:09,850
X so this is saying map this data from

00:12:08,020 --> 00:12:12,160
the host device to the target device

00:12:09,850 --> 00:12:19,090
will happen from the arm space to the to

00:12:12,160 --> 00:12:20,560
the DSP space now a design goal that we

00:12:19,090 --> 00:12:22,720
had was we want to be able to support

00:12:20,560 --> 00:12:25,120
systems where that was a shared memory

00:12:22,720 --> 00:12:26,980
where the DSP could acts where the

00:12:25,120 --> 00:12:29,530
accelerator and the host could access

00:12:26,980 --> 00:12:31,180
that same memory or a distributed memory

00:12:29,530 --> 00:12:34,020
where you would have to do copies so the

00:12:31,180 --> 00:12:36,880
model is defined in such a way that both

00:12:34,020 --> 00:12:38,680
types of systems are supported so like

00:12:36,880 --> 00:12:41,140
in this first case you know we have our

00:12:38,680 --> 00:12:43,450
DSPs we have our arms and for our

00:12:41,140 --> 00:12:45,160
example they're both accessing basically

00:12:43,450 --> 00:12:47,530
the same variable but they may catch a

00:12:45,160 --> 00:12:50,110
local version of it or in a more

00:12:47,530 --> 00:12:51,550
traditional accelerator case you have

00:12:50,110 --> 00:12:53,380
something we actually have to copy it

00:12:51,550 --> 00:12:55,930
into some other memory both models are

00:12:53,380 --> 00:12:58,710
supported by the open mp4 no

00:12:55,930 --> 00:12:58,710
specification

00:12:59,430 --> 00:13:05,520
so here's just showing you what actually

00:13:01,560 --> 00:13:08,880
happens when you can offload one of

00:13:05,520 --> 00:13:10,950
these regions to the accelerant to

00:13:08,880 --> 00:13:13,649
another device you've got this target

00:13:10,950 --> 00:13:17,850
construct and then within that region

00:13:13,649 --> 00:13:20,160
you can then have a regular OpenMP

00:13:17,850 --> 00:13:22,950
constructs so this says take this region

00:13:20,160 --> 00:13:25,050
of code offload it to the DSPs in our

00:13:22,950 --> 00:13:27,660
case and then go parallel once you get

00:13:25,050 --> 00:13:29,730
there and then you end up you're mapping

00:13:27,660 --> 00:13:31,350
these variables in this case using array

00:13:29,730 --> 00:13:33,920
sections to describe the memory behind

00:13:31,350 --> 00:13:33,920
the pointers

00:13:38,680 --> 00:13:44,260
for us apparel afore yes to get good

00:13:42,490 --> 00:13:47,140
performance on the DSP you don't have to

00:13:44,260 --> 00:13:49,180
do some of the more fancier things that

00:13:47,140 --> 00:13:51,220
were added for like GPUs like the team

00:13:49,180 --> 00:13:54,089
construct and things like that you can

00:13:51,220 --> 00:13:56,980
the DSPs are very good just regular

00:13:54,089 --> 00:14:04,480
OpenMP targets so you can just do things

00:13:56,980 --> 00:14:06,010
like parallel for ya yes so with eight

00:14:04,480 --> 00:14:08,170
the question was how many threads do we

00:14:06,010 --> 00:14:09,910
use we have eight DSPs so we use we

00:14:08,170 --> 00:14:12,040
basically stick at eight threads we hard

00:14:09,910 --> 00:14:16,089
code one thread for each DSP so we'd

00:14:12,040 --> 00:14:17,800
have 8 threads launched to do this we

00:14:16,089 --> 00:14:20,410
really don't do we have affinity issues

00:14:17,800 --> 00:14:23,649
not so much yet because they're all

00:14:20,410 --> 00:14:26,740
basically have the same sort of distance

00:14:23,649 --> 00:14:28,060
to memory but down the road you know

00:14:26,740 --> 00:14:30,089
that might become more of a problem for

00:14:28,060 --> 00:14:30,089
us

00:14:32,720 --> 00:14:40,560
the the the the SOC itself can access

00:14:38,459 --> 00:14:43,110
how many megabytes of memory is on the

00:14:40,560 --> 00:14:45,269
device the SOC can access 10 gigabytes

00:14:43,110 --> 00:14:51,269
but the DSPs have a 32-bit address space

00:14:45,269 --> 00:14:55,649
so they can get 24 all right so how do

00:14:51,269 --> 00:14:58,500
we make open mp4 tardo run on this arm

00:14:55,649 --> 00:14:59,850
plus DSP we call it k2h that's three of

00:14:58,500 --> 00:15:02,850
the letters that are extracted from the

00:14:59,850 --> 00:15:06,209
very long alphabet soup that is the

00:15:02,850 --> 00:15:07,620
official name for it so on k2h this is

00:15:06,209 --> 00:15:10,350
the solution that we that we are

00:15:07,620 --> 00:15:13,620
currently using for implementing the

00:15:10,350 --> 00:15:15,690
openmp florida accelerator model so on

00:15:13,620 --> 00:15:18,800
the arms we're just using the GCC

00:15:15,690 --> 00:15:22,670
toolchain which supports openmp already

00:15:18,800 --> 00:15:25,170
and then on the DSPs we're using the

00:15:22,670 --> 00:15:27,420
openmp compiler that we developed for

00:15:25,170 --> 00:15:30,149
the four that I showed you earlier that

00:15:27,420 --> 00:15:32,100
we developed for the DSPs okay and then

00:15:30,149 --> 00:15:34,680
we have a run time that we've based

00:15:32,100 --> 00:15:36,540
loosely on lib Gump we use the API

00:15:34,680 --> 00:15:38,100
functions but we've rewritten a lot of

00:15:36,540 --> 00:15:44,820
it underneath to use our hardware cues

00:15:38,100 --> 00:15:46,470
ok so we send for example this piece of

00:15:44,820 --> 00:15:48,959
code might come through our compiler we

00:15:46,470 --> 00:15:51,420
use we're using a source to source step

00:15:48,959 --> 00:15:53,940
that extracts the part that needs to go

00:15:51,420 --> 00:15:56,430
to the DSP we take that part we run it

00:15:53,940 --> 00:15:58,890
through our DSP compiler we insert the

00:15:56,430 --> 00:16:01,470
necessary communication code into the

00:15:58,890 --> 00:16:04,160
arm side in the DSP side and then send

00:16:01,470 --> 00:16:08,279
the host code through the GCC compiler

00:16:04,160 --> 00:16:11,790
and then load it up and run it and we

00:16:08,279 --> 00:16:13,980
have the code starts running on the arm

00:16:11,790 --> 00:16:16,589
side and then invokes the code that's

00:16:13,980 --> 00:16:18,149
running over on the DSP side so the

00:16:16,589 --> 00:16:20,640
essence of it is that we use the t-i

00:16:18,149 --> 00:16:22,920
tools to compile for the DSP we use the

00:16:20,640 --> 00:16:25,110
arm tool the GCC compiler for the arm

00:16:22,920 --> 00:16:26,490
side and we have a front-end source the

00:16:25,110 --> 00:16:28,019
source translator that splits the

00:16:26,490 --> 00:16:31,790
original source code into those two

00:16:28,019 --> 00:16:31,790
streams make sense

00:16:32,240 --> 00:16:37,100
and then what we're using actually

00:16:35,089 --> 00:16:40,160
underneath is we have an open CL

00:16:37,100 --> 00:16:43,100
implementation that can offload from our

00:16:40,160 --> 00:16:46,970
arms sore 6 x's so we're reusing that to

00:16:43,100 --> 00:16:48,589
actually implement the if you looked at

00:16:46,970 --> 00:16:51,140
the code that the compiler was producing

00:16:48,589 --> 00:16:53,180
you'd see opencl code calls that are

00:16:51,140 --> 00:16:55,790
being used to offload the code we're not

00:16:53,180 --> 00:16:57,980
using open CL C but we're using the API

00:16:55,790 --> 00:17:00,110
functions to actually marshal the

00:16:57,980 --> 00:17:06,140
kernels that we've already extracted

00:17:00,110 --> 00:17:09,439
into the the DSP code all right so this

00:17:06,140 --> 00:17:11,540
is the that parallel region we outlined

00:17:09,439 --> 00:17:15,439
it into a function but we invoked it

00:17:11,540 --> 00:17:17,449
through an open sale call ok so that's

00:17:15,439 --> 00:17:19,670
basically it it's pretty straightforward

00:17:17,449 --> 00:17:23,329
at this moment we use a source of sorts

00:17:19,670 --> 00:17:27,470
translator we create a GCC side for the

00:17:23,329 --> 00:17:29,210
arm create a DSP side for the DSPs we

00:17:27,470 --> 00:17:32,210
stitch in the necessary communication

00:17:29,210 --> 00:17:34,760
between the two which relies on open CL

00:17:32,210 --> 00:17:37,850
for doing that we load it up and if we

00:17:34,760 --> 00:17:41,510
run it and and you can see a demo of it

00:17:37,850 --> 00:17:43,520
in our booth so I encourage you to come

00:17:41,510 --> 00:17:46,490
on by I can give you more detail I can

00:17:43,520 --> 00:17:51,110
show it running on actual the end core

00:17:46,490 --> 00:17:52,850
platform the brown dwarf system and so

00:17:51,110 --> 00:17:55,000
yeah thank you very much there any more

00:17:52,850 --> 00:17:55,000
questions

00:17:56,649 --> 00:18:00,159
I'm not

00:18:02,130 --> 00:18:08,970
yeah Rooney S&P linux yeah it's like

00:18:06,620 --> 00:18:10,170
there's two two versions out there we

00:18:08,970 --> 00:18:12,870
wrote a bunt too and then we have

00:18:10,170 --> 00:18:17,610
another one that's from TI called a rock

00:18:12,870 --> 00:18:18,720
from linaro okay but the the systems i

00:18:17,610 --> 00:18:22,490
showed you are going to be running a

00:18:18,720 --> 00:18:22,490
bunt too yeah

00:18:25,070 --> 00:18:29,120
we have a lot of we have a lot of

00:18:27,740 --> 00:18:32,919
performance and else on the DSPs

00:18:29,120 --> 00:18:36,529
unfortunately it's hard to make it

00:18:32,919 --> 00:18:38,799
available through the Ubuntu systems

00:18:36,529 --> 00:18:41,779
because we have the special kind of

00:18:38,799 --> 00:18:43,340
adapters that you have to plug into them

00:18:41,779 --> 00:18:46,880
so we're trying to work through how to

00:18:43,340 --> 00:18:49,070
make that stuff available to users

00:18:46,880 --> 00:18:50,419
without having to go you know go into

00:18:49,070 --> 00:18:53,960
the back and plug things into your

00:18:50,419 --> 00:18:56,480
system so we have a lot it's just hard

00:18:53,960 --> 00:18:58,220
to make it available at the moment now

00:18:56,480 --> 00:18:59,120
the embedded guys are used to that you

00:18:58,220 --> 00:19:00,889
know because they just have it on their

00:18:59,120 --> 00:19:03,139
desktop they just plug stuff into it

00:19:00,889 --> 00:19:05,240
this is a different model for us where

00:19:03,139 --> 00:19:08,200
it's back in a room somewhere right yeah

00:19:05,240 --> 00:19:08,200
so

00:19:10,659 --> 00:19:13,379

YouTube URL: https://www.youtube.com/watch?v=NM_-KwG9IYc


