Title: OpenMP BoF - Part 4 - SC13 - Mellor Crummey
Publication date: 2014-12-13
Playlist: SC13
Description: 
	John Mellor-Crummey (Rice U.) presents developments with OpenMP tools.
Captions: 
	00:00:00,000 --> 00:00:04,589
so my name is John Bella crummy I'm

00:00:02,520 --> 00:00:07,410
professor computer science at Rice

00:00:04,589 --> 00:00:09,330
University the today I'm going to tell

00:00:07,410 --> 00:00:12,630
you a little bit about the openmp tools

00:00:09,330 --> 00:00:14,429
API this is about a 16-month effort and

00:00:12,630 --> 00:00:15,960
in part i think the schedule has been

00:00:14,429 --> 00:00:20,250
dragged out because some of us have day

00:00:15,960 --> 00:00:22,740
jobs as well so this is the product of

00:00:20,250 --> 00:00:25,199
the openmp tool subcommittee so the

00:00:22,740 --> 00:00:27,660
executive lead on this is Martin Schulz

00:00:25,199 --> 00:00:29,369
at Lawrence Livermore and the two

00:00:27,660 --> 00:00:31,679
technical leads have been myself in Alex

00:00:29,369 --> 00:00:34,020
eichenberger at IBM and then as you see

00:00:31,679 --> 00:00:35,280
there's a long list of active people on

00:00:34,020 --> 00:00:38,280
the subcommittee who've contributed a

00:00:35,280 --> 00:00:40,890
lot to the Drake drafter we have

00:00:38,280 --> 00:00:42,780
presently so let me start with some of

00:00:40,890 --> 00:00:45,390
the motivations so there's a large gap

00:00:42,780 --> 00:00:46,620
between the openmp expression and a

00:00:45,390 --> 00:00:49,440
source program and the implementation

00:00:46,620 --> 00:00:52,370
and so in particular if you try and drop

00:00:49,440 --> 00:00:55,350
a profiler on top of an open MP

00:00:52,370 --> 00:00:57,449
implementation then what you'll see if

00:00:55,350 --> 00:00:59,430
you don't take any special measures is

00:00:57,449 --> 00:01:01,559
it you'll see this implementation level

00:00:59,430 --> 00:01:05,850
view and so what this is showing is a

00:01:01,559 --> 00:01:09,360
calling context profile of a code that's

00:01:05,850 --> 00:01:11,909
been compiled and run with OpenMP and so

00:01:09,360 --> 00:01:13,590
what we see here in highlighted in red

00:01:11,909 --> 00:01:15,990
is that there's a whole bunch of

00:01:13,590 --> 00:01:17,810
functions that have been outlined and so

00:01:15,990 --> 00:01:21,180
this was done in the context of the

00:01:17,810 --> 00:01:23,520
Intel OpenMP compiler and runtime and so

00:01:21,180 --> 00:01:25,560
there's some calls to launch worker

00:01:23,520 --> 00:01:28,229
launch thread and then invoke funk and

00:01:25,560 --> 00:01:31,110
then all of these calls to things that

00:01:28,229 --> 00:01:32,850
have been outlined from the application

00:01:31,110 --> 00:01:35,280
and so the problem is that is a tool

00:01:32,850 --> 00:01:37,409
developer you lose focus on where how

00:01:35,280 --> 00:01:39,420
all this stuff fits into the larger hole

00:01:37,409 --> 00:01:41,729
and so you need tools to bridge the gap

00:01:39,420 --> 00:01:43,950
to explain program performance and I

00:01:41,729 --> 00:01:48,479
would argue that in this form it's

00:01:43,950 --> 00:01:51,000
really not very easy to digest so the

00:01:48,479 --> 00:01:53,130
fundamental problem is that the calling

00:01:51,000 --> 00:01:54,780
context is distributed across threat so

00:01:53,130 --> 00:01:57,509
the developer view you might have these

00:01:54,780 --> 00:02:00,899
three cove regions code a B and C where

00:01:57,509 --> 00:02:02,880
they can be you think of them as just

00:02:00,899 --> 00:02:04,110
pieces of code and there's function

00:02:02,880 --> 00:02:06,510
calls and what

00:02:04,110 --> 00:02:09,899
and then there's parallel regions that

00:02:06,510 --> 00:02:12,750
separate them and so you might begin in

00:02:09,899 --> 00:02:15,480
thread one executing functions in the

00:02:12,750 --> 00:02:19,470
region code a and then enter a parallel

00:02:15,480 --> 00:02:21,510
region B and then on the same thread now

00:02:19,470 --> 00:02:24,630
you can start executing a piece of code

00:02:21,510 --> 00:02:27,390
B and then on thread too it's an idol a

00:02:24,630 --> 00:02:28,980
worker that's idle and so it sees that

00:02:27,390 --> 00:02:30,930
the parallel region has been entered and

00:02:28,980 --> 00:02:33,690
its member of the team so it starts

00:02:30,930 --> 00:02:36,840
executing code from region B then it

00:02:33,690 --> 00:02:38,430
encounters the parallel Regency and so

00:02:36,840 --> 00:02:40,770
we end up with some frames on the stack

00:02:38,430 --> 00:02:43,470
from the runtime system and then

00:02:40,770 --> 00:02:46,320
eventually a task gets dispatched for

00:02:43,470 --> 00:02:48,450
Regency and so there's a big gap between

00:02:46,320 --> 00:02:50,130
the developers view which is shown on

00:02:48,450 --> 00:02:53,370
the top and the implementation view

00:02:50,130 --> 00:02:55,410
that's shown at the bottom so there been

00:02:53,370 --> 00:02:57,540
a couple of obstacles for runtime

00:02:55,410 --> 00:02:59,970
independent tools while individual

00:02:57,540 --> 00:03:01,290
vendors have their own solutions it's

00:02:59,970 --> 00:03:03,090
been hard to build anything that will

00:03:01,290 --> 00:03:05,310
work with openmp implementations in

00:03:03,090 --> 00:03:07,290
general there's no standard API for

00:03:05,310 --> 00:03:09,390
OpenMP tools and there been some prior

00:03:07,290 --> 00:03:11,489
efforts in this regard the pomp

00:03:09,390 --> 00:03:13,769
interface which was described by more

00:03:11,489 --> 00:03:17,940
Bologna siandien wolf and the collector

00:03:13,769 --> 00:03:20,549
API by Martius grits Asura of cop t and

00:03:17,940 --> 00:03:22,410
Lynn and so the problem with both of

00:03:20,549 --> 00:03:24,239
these is that neither of them gained

00:03:22,410 --> 00:03:26,310
enough traction and so maybe I'm just

00:03:24,239 --> 00:03:28,799
naive but we're trying a third time and

00:03:26,310 --> 00:03:31,320
see if this the third time is going to

00:03:28,799 --> 00:03:33,269
be the charm and so part of the problem

00:03:31,320 --> 00:03:35,100
is that there there are differences in

00:03:33,269 --> 00:03:36,570
OpenMP implementations some of them

00:03:35,100 --> 00:03:37,709
don't have support for static linking

00:03:36,570 --> 00:03:39,570
some of them have an extra monitor

00:03:37,709 --> 00:03:43,380
thread some of the music active stack

00:03:39,570 --> 00:03:45,750
and other things as well and so what we

00:03:43,380 --> 00:03:47,130
need is some support inside the runtime

00:03:45,750 --> 00:03:48,570
system that's going to hide some of

00:03:47,130 --> 00:03:51,480
these differences from tools and just

00:03:48,570 --> 00:03:52,890
tell the tools what they need to know so

00:03:51,480 --> 00:03:55,980
let me tell you a little bit about Oh

00:03:52,890 --> 00:03:57,570
MPT and then I'll finish up with some

00:03:55,980 --> 00:03:59,070
status and next steps and then time

00:03:57,570 --> 00:04:01,680
permitting I can show a little demo of

00:03:59,070 --> 00:04:05,310
what the tool looks like using the opt

00:04:01,680 --> 00:04:07,920
interface so the design objectives for

00:04:05,310 --> 00:04:09,720
the opt interface are to enable tools to

00:04:07,920 --> 00:04:10,180
gather information and associate costs

00:04:09,720 --> 00:04:12,549
with

00:04:10,180 --> 00:04:14,650
the application source code and also at

00:04:12,549 --> 00:04:17,739
the runtime system so we want to be able

00:04:14,650 --> 00:04:19,269
to profile and attribute cost of the

00:04:17,739 --> 00:04:21,880
runtime system as well so it's not just

00:04:19,269 --> 00:04:23,229
useful for application developers but

00:04:21,880 --> 00:04:25,000
it's also useful for all the guys

00:04:23,229 --> 00:04:27,039
sitting here at the table who might be

00:04:25,000 --> 00:04:29,650
working on the implementation of these

00:04:27,039 --> 00:04:31,870
things as well and so what we want to

00:04:29,650 --> 00:04:33,880
support is low overhead tools based on

00:04:31,870 --> 00:04:36,820
asynchronous sampling we want to be able

00:04:33,880 --> 00:04:38,800
to identify which frames belong to the

00:04:36,820 --> 00:04:40,180
application code which frames belong to

00:04:38,800 --> 00:04:42,100
the runtime system and it's not as

00:04:40,180 --> 00:04:43,930
simple as just say which frames are the

00:04:42,100 --> 00:04:45,910
runtime system shared library so the

00:04:43,930 --> 00:04:47,680
runtime system might call see library

00:04:45,910 --> 00:04:50,620
functions and what we want to know is

00:04:47,680 --> 00:04:52,180
which when the C library functions are

00:04:50,620 --> 00:04:53,530
called which calls are on behalf of the

00:04:52,180 --> 00:04:55,449
runtime system in which calls are on

00:04:53,530 --> 00:04:58,000
behalf of the application so we want to

00:04:55,449 --> 00:04:59,740
be able to identify what represents

00:04:58,000 --> 00:05:02,590
application work and what represents

00:04:59,740 --> 00:05:04,810
runtime effort we also want to associate

00:05:02,590 --> 00:05:06,580
a threads activity at any point with

00:05:04,810 --> 00:05:09,250
some sort of descriptive state like to

00:05:06,580 --> 00:05:11,830
say it's executing parallel work or it's

00:05:09,250 --> 00:05:14,199
idle or waiting for a lock this so this

00:05:11,830 --> 00:05:15,940
is individual threads and we want

00:05:14,199 --> 00:05:18,370
negligible overhead if the interface is

00:05:15,940 --> 00:05:19,840
not mute so for it to be acceptable as

00:05:18,370 --> 00:05:21,760
something that people will put in their

00:05:19,840 --> 00:05:25,570
production run time the overhead has to

00:05:21,760 --> 00:05:27,099
be very low if the support is there but

00:05:25,570 --> 00:05:32,080
it's turned off because no tool is

00:05:27,099 --> 00:05:35,080
attached so our goal is is 0 and we'll

00:05:32,080 --> 00:05:37,210
see how close we get well it's not going

00:05:35,080 --> 00:05:39,400
to be 0 but it's going to be we hope

00:05:37,210 --> 00:05:44,020
that rounding down it's going to be

00:05:39,400 --> 00:05:45,400
close ok and so they also we're defining

00:05:44,020 --> 00:05:47,590
support for trade space performance

00:05:45,400 --> 00:05:49,210
tools now the tracing based tools are

00:05:47,590 --> 00:05:51,729
not really my thing but we felt that it

00:05:49,210 --> 00:05:53,289
was important to include this as well so

00:05:51,729 --> 00:05:55,840
that it's a standard that represents the

00:05:53,289 --> 00:05:58,360
entire tools community adding support

00:05:55,840 --> 00:05:59,380
for tracing inside the runtime even just

00:05:58,360 --> 00:06:01,389
the hooks can add some additional

00:05:59,380 --> 00:06:03,520
overhead and so we'll have to see how it

00:06:01,389 --> 00:06:05,110
all plays out as we as we refine the

00:06:03,520 --> 00:06:07,360
implementations to try and bring the

00:06:05,110 --> 00:06:08,270
overhead down to something that

00:06:07,360 --> 00:06:10,970
everybody's willing

00:06:08,270 --> 00:06:12,740
with all the time so we also don't want

00:06:10,970 --> 00:06:15,080
to impose an unreasonable developer

00:06:12,740 --> 00:06:16,790
burden on either the runtime developers

00:06:15,080 --> 00:06:20,000
or the tool developers so these are the

00:06:16,790 --> 00:06:23,900
design objectives and then what we

00:06:20,000 --> 00:06:25,430
focused on in om PT is to provide a

00:06:23,900 --> 00:06:27,230
minimal set of functionality the

00:06:25,430 --> 00:06:29,630
essential support for sampling based

00:06:27,230 --> 00:06:31,520
tools is part of a mandatory core and

00:06:29,630 --> 00:06:33,080
we're only supporting tools that are

00:06:31,520 --> 00:06:36,110
attached at the link time or program

00:06:33,080 --> 00:06:37,640
launch we felt that while it would be

00:06:36,110 --> 00:06:39,170
possible to support tools that are

00:06:37,640 --> 00:06:40,730
dynamically attached we had a lot of

00:06:39,170 --> 00:06:43,000
complexity to it and we would rather

00:06:40,730 --> 00:06:46,190
have something that we can succeed and

00:06:43,000 --> 00:06:48,470
move forward with and maybe augment at a

00:06:46,190 --> 00:06:52,760
later time than trying to design this

00:06:48,470 --> 00:06:54,320
thing in its full glory in one go the

00:06:52,760 --> 00:06:56,840
other point is that we want to minimize

00:06:54,320 --> 00:06:58,280
runtime costs so we want to reduce the

00:06:56,840 --> 00:06:59,720
cost in the runtime and the tool where

00:06:58,280 --> 00:07:02,360
possible to encourage integration and

00:06:59,720 --> 00:07:03,890
optimized run times and one way to do

00:07:02,360 --> 00:07:06,350
that is to make support for some of the

00:07:03,890 --> 00:07:08,510
higher overhead features optional and so

00:07:06,350 --> 00:07:10,220
there are some callbacks for this this

00:07:08,510 --> 00:07:12,110
idea called blame-shifting which came

00:07:10,220 --> 00:07:14,630
from my research group which I'll say a

00:07:12,110 --> 00:07:16,610
bit about and then also callbacks for

00:07:14,630 --> 00:07:19,910
the full-featured tracing based tools

00:07:16,610 --> 00:07:22,880
are optional as well so the major

00:07:19,910 --> 00:07:25,940
functionality in om PT is to track the

00:07:22,880 --> 00:07:27,860
state of each thread so thread will keep

00:07:25,940 --> 00:07:30,470
track of whether it's idle or parallel

00:07:27,860 --> 00:07:33,830
and then tools can query this this state

00:07:30,470 --> 00:07:36,200
at any time in using a function that's a

00:07:33,830 --> 00:07:37,940
sync signal safe so in a signal handler

00:07:36,200 --> 00:07:39,620
they can query the runtime system and

00:07:37,940 --> 00:07:41,300
say what's my thread doing now and find

00:07:39,620 --> 00:07:44,570
out that it's doing parallel work or not

00:07:41,300 --> 00:07:46,700
and then we also want to provide some

00:07:44,570 --> 00:07:49,040
limited persistent storage for tool data

00:07:46,700 --> 00:07:50,810
in the runtime system and this is

00:07:49,040 --> 00:07:52,850
something that has kind of fallen on the

00:07:50,810 --> 00:07:54,560
cutting room floor and so we'll see

00:07:52,850 --> 00:07:57,830
whether any of that survives and they in

00:07:54,560 --> 00:07:59,420
the final version of the draft so one of

00:07:57,830 --> 00:08:01,580
the other things that was important was

00:07:59,420 --> 00:08:02,690
to support the interpretation of the

00:08:01,580 --> 00:08:04,520
call stack so I showed you how

00:08:02,690 --> 00:08:07,550
complicated the implementation level

00:08:04,520 --> 00:08:09,680
view looked compared to the application

00:08:07,550 --> 00:08:11,390
developers view and so what we wanted to

00:08:09,680 --> 00:08:14,330
do in on PT is provide some hooks that

00:08:11,390 --> 00:08:15,210
would enable a tool that's using call

00:08:14,330 --> 00:08:17,190
stack unwinding

00:08:15,210 --> 00:08:19,199
to identify which frames belong to the

00:08:17,190 --> 00:08:21,810
application in which frames belong to

00:08:19,199 --> 00:08:23,430
the runtime system now the third part is

00:08:21,810 --> 00:08:25,620
event notification so we're providing

00:08:23,430 --> 00:08:28,080
support for callbacks for predefined

00:08:25,620 --> 00:08:30,090
events so a tool can register to receive

00:08:28,080 --> 00:08:31,949
callbacks when you're entering a

00:08:30,090 --> 00:08:34,289
parallel region or exiting a parallel

00:08:31,949 --> 00:08:36,870
region or entering a barrier or exiting

00:08:34,289 --> 00:08:39,060
a barrier things like that so there are

00:08:36,870 --> 00:08:41,640
a few notifications that are mandatory

00:08:39,060 --> 00:08:43,320
that we believe that any tool will need

00:08:41,640 --> 00:08:47,550
and so they're going to be required in

00:08:43,320 --> 00:08:49,230
the OM PT specification and then there

00:08:47,550 --> 00:08:51,149
are many optional ones that correspond

00:08:49,230 --> 00:08:54,810
to say the blame shifting notifications

00:08:51,149 --> 00:08:58,830
or the tracing based notifications which

00:08:54,810 --> 00:09:01,020
a vendor could include or not include

00:08:58,830 --> 00:09:02,310
based on the level of effort and based

00:09:01,020 --> 00:09:04,290
on the level of overhead that they

00:09:02,310 --> 00:09:06,720
believe that it would require inside

00:09:04,290 --> 00:09:09,959
their runtime system implementation so

00:09:06,720 --> 00:09:12,240
for runtime state tracking each thread

00:09:09,959 --> 00:09:16,170
is keeping track of its own state and it

00:09:12,240 --> 00:09:18,390
supports this Oh npt gets state API and

00:09:16,170 --> 00:09:20,820
the ideas you can query to find out what

00:09:18,390 --> 00:09:22,560
the state is and if the state is a wait

00:09:20,820 --> 00:09:26,070
state like I'm waiting for a lock or a

00:09:22,560 --> 00:09:29,339
critical region then the function will

00:09:26,070 --> 00:09:31,770
return a weight ID and that will

00:09:29,339 --> 00:09:33,270
identify in some way will identify the

00:09:31,770 --> 00:09:35,730
thing that I'm waiting for whether it's

00:09:33,270 --> 00:09:40,010
a critical region or a lock or an

00:09:35,730 --> 00:09:43,050
ordered section or several other things

00:09:40,010 --> 00:09:46,760
so the runtime states we have states

00:09:43,050 --> 00:09:50,550
that represent work idleness barriers

00:09:46,760 --> 00:09:51,959
task weights mutual exclusion some

00:09:50,550 --> 00:09:54,380
miscellaneous things that I'm not going

00:09:51,959 --> 00:09:58,079
to mention and then the ones that are in

00:09:54,380 --> 00:10:00,890
pink color are optional that wouldn't

00:09:58,079 --> 00:10:03,450
need to be supported the other ones

00:10:00,890 --> 00:10:05,579
while they're mandatory some of them are

00:10:03,450 --> 00:10:07,350
actually rather flexible so you don't

00:10:05,579 --> 00:10:10,490
necessarily have to report that you're

00:10:07,350 --> 00:10:13,320
waiting for a lock as soon as soon as

00:10:10,490 --> 00:10:15,720
there's a call to acquire lock in fact

00:10:13,320 --> 00:10:18,120
you can report I'm waiting for a lock

00:10:15,720 --> 00:10:20,790
only after I actually begin to spin

00:10:18,120 --> 00:10:23,010
weight or only after I spin wait for

00:10:20,790 --> 00:10:25,380
some certain amount of time and I and I

00:10:23,010 --> 00:10:27,279
fall into a second part of the protocol

00:10:25,380 --> 00:10:28,990
so the idea is that we

00:10:27,279 --> 00:10:31,120
want to be too prescriptive that say

00:10:28,990 --> 00:10:32,529
this is how you have to implement it we

00:10:31,120 --> 00:10:34,509
just say if you're waiting for

00:10:32,529 --> 00:10:36,610
substantial amounts of time we'd like a

00:10:34,509 --> 00:10:37,600
notification because the tool would like

00:10:36,610 --> 00:10:41,889
to know that you're waiting for

00:10:37,600 --> 00:10:43,209
something so then there these three

00:10:41,889 --> 00:10:45,069
kinds of notifications so they're

00:10:43,209 --> 00:10:47,019
mandatory notifications and then

00:10:45,069 --> 00:10:49,990
notifications for blame-shifting in for

00:10:47,019 --> 00:10:53,350
the Tracy so the mandatory notifications

00:10:49,990 --> 00:10:55,870
fall into a couple of classes so when a

00:10:53,350 --> 00:10:57,999
thread a worker thread gets created or

00:10:55,870 --> 00:10:59,589
destroyed we want to know when a

00:10:57,999 --> 00:11:04,180
parallel region gets created or

00:10:59,589 --> 00:11:08,379
destroyed we want to know tasks if you

00:11:04,180 --> 00:11:10,300
switch to execute a task then there's a

00:11:08,379 --> 00:11:12,790
task switch event there's also there's

00:11:10,300 --> 00:11:16,319
also supposed to be a create an exit

00:11:12,790 --> 00:11:18,339
event for for tasks as well there's a

00:11:16,319 --> 00:11:20,559
signal to an event when the runtime is

00:11:18,339 --> 00:11:23,170
shut down and there's also a an event

00:11:20,559 --> 00:11:25,120
that supports a user level

00:11:23,170 --> 00:11:26,529
application-level tool control where you

00:11:25,120 --> 00:11:29,889
can specify that you want to turn the

00:11:26,529 --> 00:11:32,709
tool on or off and that's required in

00:11:29,889 --> 00:11:35,019
the implementation as well so for the

00:11:32,709 --> 00:11:37,029
blame shifting events which are optional

00:11:35,019 --> 00:11:39,009
so the idea is these are supporting

00:11:37,029 --> 00:11:41,470
sampling based performance tools and

00:11:39,009 --> 00:11:44,470
what we want to know is when your way

00:11:41,470 --> 00:11:46,569
and so the idea behind this this

00:11:44,470 --> 00:11:49,750
blame-shifting concept is that you might

00:11:46,569 --> 00:11:52,779
be waiting for a lock and so if I'm

00:11:49,750 --> 00:11:54,699
using profiling and I'm measuring that a

00:11:52,779 --> 00:11:57,370
thread is spinning waiting for a lot

00:11:54,699 --> 00:11:58,899
that's measuring a symptom and what we

00:11:57,370 --> 00:12:02,259
actually want to do is report what the

00:11:58,899 --> 00:12:05,379
cause is so we have a strategy where if

00:12:02,259 --> 00:12:07,600
a thread acquires a lock so the but

00:12:05,379 --> 00:12:11,290
let's say we have time flowing from left

00:12:07,600 --> 00:12:13,540
to right so the thread begins and the

00:12:11,290 --> 00:12:15,850
bottom thread acquires a lock and then

00:12:13,540 --> 00:12:17,949
the top thread tries to acquire the lock

00:12:15,850 --> 00:12:21,579
but ends up waiting for it because it

00:12:17,949 --> 00:12:24,069
can't and so then when the bottom thread

00:12:21,579 --> 00:12:26,410
releases the lock what we're going to do

00:12:24,069 --> 00:12:29,139
is we're going to accumulate the lock

00:12:26,410 --> 00:12:31,990
waiting time in a hash table in our tool

00:12:29,139 --> 00:12:33,730
and then when the release occurs we want

00:12:31,990 --> 00:12:36,550
to be able to charge the lock holder for

00:12:33,730 --> 00:12:38,379
all the waiting that occurred because he

00:12:36,550 --> 00:12:40,180
was holding the lock and so that's this

00:12:38,379 --> 00:12:41,860
notion of blame shifting it works

00:12:40,180 --> 00:12:43,830
in a couple of different ways there's

00:12:41,860 --> 00:12:46,660
something called directed blame-shifting

00:12:43,830 --> 00:12:48,730
where you can charge a specific thing

00:12:46,660 --> 00:12:50,529
like I want to charge the lock holder or

00:12:48,730 --> 00:12:54,100
I want to charge the critical section

00:12:50,529 --> 00:12:56,170
holder in other cases you might be just

00:12:54,100 --> 00:12:57,880
waiting for work and what you want to do

00:12:56,170 --> 00:13:00,430
is say well i don't know why i'm waiting

00:12:57,880 --> 00:13:02,649
for work but if any threads are running

00:13:00,430 --> 00:13:03,700
then i've actually like to charge them

00:13:02,649 --> 00:13:05,620
that say that they're not shedding

00:13:03,700 --> 00:13:07,410
enough work to keep me busy so whatever

00:13:05,620 --> 00:13:09,430
code that they're running right now is

00:13:07,410 --> 00:13:11,110
insufficiently parallel to keep me busy

00:13:09,430 --> 00:13:13,180
so that's another kind of blame shifting

00:13:11,110 --> 00:13:16,480
that's supported by the interface that I

00:13:13,180 --> 00:13:18,970
mentioned so this that shows up in our

00:13:16,480 --> 00:13:21,279
tool I have an example here that may be

00:13:18,970 --> 00:13:25,570
a little bit small to read on the screen

00:13:21,279 --> 00:13:27,430
but what it shows is there's a master

00:13:25,570 --> 00:13:29,260
region and inside the master region its

00:13:27,430 --> 00:13:31,510
setting a lock and then performing a

00:13:29,260 --> 00:13:33,220
very long operation and then all of the

00:13:31,510 --> 00:13:34,959
other threads are falling past the

00:13:33,220 --> 00:13:36,490
master region and going into a loop and

00:13:34,959 --> 00:13:38,800
the inside the loop you're trying to

00:13:36,490 --> 00:13:40,720
acquire a lock and there's a short

00:13:38,800 --> 00:13:42,790
operation now this is not a good

00:13:40,720 --> 00:13:44,230
parallel program but this is just it's a

00:13:42,790 --> 00:13:46,360
one slide thing that illustrates the

00:13:44,230 --> 00:13:50,140
point so it turns out that all of the

00:13:46,360 --> 00:13:52,089
waiting occurs where the red arrow is

00:13:50,140 --> 00:13:54,630
pointing and so it every all of the

00:13:52,089 --> 00:13:58,000
threads are waiting waiting for the lock

00:13:54,630 --> 00:14:01,060
inside that loop however all the waiting

00:13:58,000 --> 00:14:03,190
is being caused by the activity of the

00:14:01,060 --> 00:14:04,930
master and so with this blame-shifting

00:14:03,190 --> 00:14:06,490
concept we can tell you where the

00:14:04,930 --> 00:14:11,709
waiting is occurring and we can tell you

00:14:06,490 --> 00:14:14,110
who's responsible so there's a large set

00:14:11,709 --> 00:14:15,400
of tracing events and it's for just

00:14:14,110 --> 00:14:17,920
about everything you would think for

00:14:15,400 --> 00:14:20,410
every open em deconstruct there's where

00:14:17,920 --> 00:14:23,770
there's either like a singleton event or

00:14:20,410 --> 00:14:26,920
there's a begin end pair and I will go

00:14:23,770 --> 00:14:30,130
through these in detail for parallel

00:14:26,920 --> 00:14:31,990
regions and tasks there are identifiers

00:14:30,130 --> 00:14:34,839
that are being maintained by the runtime

00:14:31,990 --> 00:14:36,459
system so that we can collect data and

00:14:34,839 --> 00:14:39,459
associate it with a parallel region or

00:14:36,459 --> 00:14:41,649
associated with task and so there's a

00:14:39,459 --> 00:14:42,730
notion of ancestor levels so there's the

00:14:41,649 --> 00:14:45,519
current task

00:14:42,730 --> 00:14:47,560
then i can by asking it ancestor level

00:14:45,519 --> 00:14:49,540
one i can find the parent of the current

00:14:47,560 --> 00:14:51,399
task and that ancestor level to find the

00:14:49,540 --> 00:14:53,170
grandparent of the current test and the

00:14:51,399 --> 00:14:54,910
same thing for nested parallel regions i

00:14:53,170 --> 00:14:56,649
can walk from an inner region all the

00:14:54,910 --> 00:14:57,970
way through the outer regions and so

00:14:56,649 --> 00:14:59,740
this is something that's going to enable

00:14:57,970 --> 00:15:01,690
us to connect up things that we're

00:14:59,740 --> 00:15:03,339
gathering from these call stack traces

00:15:01,690 --> 00:15:07,329
that are distributed across several

00:15:03,339 --> 00:15:09,459
stacks so the way the call stack has

00:15:07,329 --> 00:15:13,050
interpreted so this is the same example

00:15:09,459 --> 00:15:15,279
as before and now we have these little

00:15:13,050 --> 00:15:17,170
frame gadgets that we're maintaining

00:15:15,279 --> 00:15:19,120
inside the runtime system that tell you

00:15:17,170 --> 00:15:20,889
there's pointers that say when we

00:15:19,120 --> 00:15:23,350
entered the runtime so next to thread

00:15:20,889 --> 00:15:25,389
one you see where we're entering the

00:15:23,350 --> 00:15:27,040
frames the dark gray frames that

00:15:25,389 --> 00:15:29,860
represent the runtime system code

00:15:27,040 --> 00:15:31,750
there's a rien tur that points to the

00:15:29,860 --> 00:15:33,399
top frame where we enter into the

00:15:31,750 --> 00:15:36,970
runtime system and then there's another

00:15:33,399 --> 00:15:38,949
record below it that that is associated

00:15:36,970 --> 00:15:40,750
with the next task that says here's

00:15:38,949 --> 00:15:43,420
where we exited the runtime system in

00:15:40,750 --> 00:15:46,810
frame for and so what we're having is

00:15:43,420 --> 00:15:49,690
these pairs which really end up marking

00:15:46,810 --> 00:15:51,310
out like the begin and end of user code

00:15:49,690 --> 00:15:53,380
and the things that are in the gaps are

00:15:51,310 --> 00:15:55,000
the runtime system code and so with

00:15:53,380 --> 00:15:57,490
these figures that are pointing into the

00:15:55,000 --> 00:15:59,019
stack and it's just as easy as as inside

00:15:57,490 --> 00:16:00,519
the runtime system just gathering the

00:15:59,019 --> 00:16:04,480
frame pointer and sticking it into a

00:16:00,519 --> 00:16:09,819
variable that we can now stitch together

00:16:04,480 --> 00:16:12,459
a view of the call stacks that doesn't

00:16:09,819 --> 00:16:14,500
contain all of the run time frames in

00:16:12,459 --> 00:16:17,920
between so what you see is the

00:16:14,500 --> 00:16:20,949
application level view so there are a

00:16:17,920 --> 00:16:23,560
couple of tool facing API functions one

00:16:20,949 --> 00:16:26,740
for initializing a tool so the idea is

00:16:23,560 --> 00:16:30,010
that there's a call that would be made

00:16:26,740 --> 00:16:32,949
from the openmp runtime system 20 MPT

00:16:30,010 --> 00:16:34,810
initialized and so if it returns 0 that

00:16:32,949 --> 00:16:36,399
means there's not a tool attached so the

00:16:34,810 --> 00:16:38,500
openmp runtime system would have an

00:16:36,399 --> 00:16:40,149
implementation of its own as like a week

00:16:38,500 --> 00:16:42,519
symbol and then if there's a tool that's

00:16:40,149 --> 00:16:45,339
attached it supplies a version that will

00:16:42,519 --> 00:16:46,510
then actually perform initialization and

00:16:45,339 --> 00:16:48,550
indicate so the run

00:16:46,510 --> 00:16:51,040
system there's a something for

00:16:48,550 --> 00:16:54,460
enumerates and then something for tool

00:16:51,040 --> 00:16:56,230
control to turn the tool on and off ok

00:16:54,460 --> 00:16:58,060
so the status of next steps at this

00:16:56,230 --> 00:17:00,370
point the subcommittee has approved the

00:16:58,060 --> 00:17:03,700
document that we've been working on for

00:17:00,370 --> 00:17:07,000
the last 16 months or so and there were

00:17:03,700 --> 00:17:09,280
a few late text changes that got

00:17:07,000 --> 00:17:12,160
committed today based on some feedback

00:17:09,280 --> 00:17:14,140
from someone on the committee so the

00:17:12,160 --> 00:17:16,360
document is available for comment

00:17:14,140 --> 00:17:17,829
there's a bit ly address on here and if

00:17:16,360 --> 00:17:18,880
you don't copy it down from the slides

00:17:17,829 --> 00:17:21,459
I'd be happy to give it to you

00:17:18,880 --> 00:17:24,339
afterwards in the november seventh ARB

00:17:21,459 --> 00:17:25,959
meeting the tools group was approved as

00:17:24,339 --> 00:17:28,840
a subcommittee of the language committee

00:17:25,959 --> 00:17:30,910
and the point here is that we don't want

00:17:28,840 --> 00:17:32,680
a separate tool standard we don't want a

00:17:30,910 --> 00:17:35,200
language standard and the tool standard

00:17:32,680 --> 00:17:37,450
what we want is a few language we want a

00:17:35,200 --> 00:17:39,100
few tool hooks as part of the language

00:17:37,450 --> 00:17:41,080
runtime system and so the appropriate

00:17:39,100 --> 00:17:44,170
thing is for the tools to be part of the

00:17:41,080 --> 00:17:48,220
language committee so we're getting

00:17:44,170 --> 00:17:50,260
ready to submit the TR to the language

00:17:48,220 --> 00:17:52,540
Committee for official comment and then

00:17:50,260 --> 00:17:55,210
I hope to turn it shortly into an

00:17:52,540 --> 00:17:58,330
official open end PT are so right now

00:17:55,210 --> 00:18:00,880
iBM has an implementation of the old DT

00:17:58,330 --> 00:18:03,370
interface at least what it was three

00:18:00,880 --> 00:18:05,680
months ago we've been tinkering with a

00:18:03,370 --> 00:18:08,610
couple of things and that's that's in

00:18:05,680 --> 00:18:11,380
place on blue team q and power and then

00:18:08,610 --> 00:18:12,760
my group at rice and the University of

00:18:11,380 --> 00:18:14,500
Oregon have been building an

00:18:12,760 --> 00:18:17,500
implementation into the open sourced

00:18:14,500 --> 00:18:19,480
Intel runtime and so I'd say that that's

00:18:17,500 --> 00:18:21,040
still in prototype form because we think

00:18:19,480 --> 00:18:22,690
that we couldn't do some things to lower

00:18:21,040 --> 00:18:24,760
the overhead and they're also a couple

00:18:22,690 --> 00:18:26,500
of missing features for some of the

00:18:24,760 --> 00:18:30,220
corner cases that we still need to add

00:18:26,500 --> 00:18:33,340
and so at present my own groups HBC

00:18:30,220 --> 00:18:35,380
toolkit tools are on top of this it's

00:18:33,340 --> 00:18:36,820
not our trunk release it's in the

00:18:35,380 --> 00:18:38,320
development branch because we've still

00:18:36,820 --> 00:18:40,690
been changing things on both sides in

00:18:38,320 --> 00:18:42,460
the interface so we have is an

00:18:40,690 --> 00:18:44,860
implementation of the tool support in

00:18:42,460 --> 00:18:46,810
the interface an implementation in a

00:18:44,860 --> 00:18:48,670
tool and we've been using the tool on

00:18:46,810 --> 00:18:50,530
applications we wanted to make sure is

00:18:48,670 --> 00:18:51,940
that when we have something the forward

00:18:50,530 --> 00:18:53,730
to the language committee we want to say

00:18:51,940 --> 00:18:57,330
we know that this is what we want

00:18:53,730 --> 00:19:01,590
we've built it and it works okay so if I

00:18:57,330 --> 00:19:04,320
have just a minute okay I can show you

00:19:01,590 --> 00:19:11,030
briefly what this looks like inside our

00:19:04,320 --> 00:19:11,030
tools so this is this represents a

00:19:11,090 --> 00:19:16,980
profile on 24 threads of a shock

00:19:15,150 --> 00:19:20,160
hydrodynamics code from lawrence

00:19:16,980 --> 00:19:22,860
livermore called Lou leche and what we

00:19:20,160 --> 00:19:26,340
get with the OM PT interfaces we've

00:19:22,860 --> 00:19:27,900
taken the profiles from all of the the

00:19:26,340 --> 00:19:31,320
worker threads and weave knit everything

00:19:27,900 --> 00:19:34,020
together into a global view and so I can

00:19:31,320 --> 00:19:36,990
look down the call paths and it can show

00:19:34,020 --> 00:19:39,120
me that main inside the function so

00:19:36,990 --> 00:19:41,280
there's the function main inside mean

00:19:39,120 --> 00:19:43,470
there's a loop inside the loop there's a

00:19:41,280 --> 00:19:45,060
call to the ground leapfrog I can get to

00:19:43,470 --> 00:19:46,950
the code so i can look all the way down

00:19:45,060 --> 00:19:49,530
the call stack so the important thing is

00:19:46,950 --> 00:19:55,800
what happens with with openmp well so

00:19:49,530 --> 00:19:59,700
here is a case online 1291 it there's it

00:19:55,800 --> 00:20:01,680
maps to this calc FB hourglass force for

00:19:59,700 --> 00:20:03,630
LM so right now the mapping isn't

00:20:01,680 --> 00:20:05,820
exactly what we'd like so it's an

00:20:03,630 --> 00:20:07,410
outline function and at the moment the

00:20:05,820 --> 00:20:08,520
outline function is being reported with

00:20:07,410 --> 00:20:10,110
the same name with the enclosing

00:20:08,520 --> 00:20:12,090
function I think we can do a little bit

00:20:10,110 --> 00:20:14,880
better based on some information that's

00:20:12,090 --> 00:20:16,650
available in the symbol table and so

00:20:14,880 --> 00:20:19,320
what we're able to do is we're able to

00:20:16,650 --> 00:20:21,840
map back and see that 11.1 percent of

00:20:19,320 --> 00:20:25,980
the execution time is inside this

00:20:21,840 --> 00:20:29,570
function in inside that's outlined code

00:20:25,980 --> 00:20:33,420
that's at this particular line in the

00:20:29,570 --> 00:20:36,900
implementation and also we can look and

00:20:33,420 --> 00:20:39,660
see how much time is spent in the fork

00:20:36,900 --> 00:20:42,090
barrier which is a detail down inside

00:20:39,660 --> 00:20:44,100
the implementation of the Intel runtime

00:20:42,090 --> 00:20:45,960
so we have two ways of doing this one is

00:20:44,100 --> 00:20:47,610
we could just suppress all of the

00:20:45,960 --> 00:20:49,740
details of the runtime system and just

00:20:47,610 --> 00:20:52,530
say it was in the openmp runtime system

00:20:49,740 --> 00:20:54,540
what we've chosen to do is for all of

00:20:52,530 --> 00:20:56,700
the frames that are kind of along the

00:20:54,540 --> 00:20:58,980
way along the path through the middle of

00:20:56,700 --> 00:21:00,690
the user code we spliced those out but

00:20:58,980 --> 00:21:03,930
if we actually took samples in runtime

00:21:00,690 --> 00:21:05,490
code then we reported them as part of

00:21:03,930 --> 00:21:06,330
the phone call chain so we get to see

00:21:05,490 --> 00:21:07,799
all of the sample

00:21:06,330 --> 00:21:09,210
that we're taking the user code is and

00:21:07,799 --> 00:21:11,250
all of the samples that were taken in

00:21:09,210 --> 00:21:14,700
the runtime so what I can say here is

00:21:11,250 --> 00:21:16,559
that six percent of the time was spent

00:21:14,700 --> 00:21:18,929
in the barrier at this statement

00:21:16,559 --> 00:21:20,940
associated with this parallel region so

00:21:18,929 --> 00:21:24,149
one more thing we also have these upward

00:21:20,940 --> 00:21:26,909
looking views so I can see that thirty

00:21:24,149 --> 00:21:29,399
nine point nine percent of this run was

00:21:26,909 --> 00:21:31,080
in wait sleep and I could look up and

00:21:29,399 --> 00:21:32,940
find out that weight sleep was called

00:21:31,080 --> 00:21:35,700
from Hyperborea release which was called

00:21:32,940 --> 00:21:37,710
from fork barrier and now I can see for

00:21:35,700 --> 00:21:39,149
the 32 point eight percent of the time

00:21:37,710 --> 00:21:42,000
in the execution was spent a fork

00:21:39,149 --> 00:21:44,340
barrier how much maps to every parallel

00:21:42,000 --> 00:21:45,870
region so i can see precisely what my

00:21:44,340 --> 00:21:48,809
overhead is associated with each of the

00:21:45,870 --> 00:21:51,090
parallel regions so hopefully what i've

00:21:48,809 --> 00:21:54,149
shown you here shows that this

00:21:51,090 --> 00:21:56,250
high-level application level view is is

00:21:54,149 --> 00:21:59,340
really something that's worth having and

00:21:56,250 --> 00:22:01,230
i think that we can actually carry this

00:21:59,340 --> 00:22:04,980
out with pretty low overhead with the

00:22:01,230 --> 00:22:08,340
OMP tapi and so it's just a matter of

00:22:04,980 --> 00:22:10,080
tuning in the the Intel implementation

00:22:08,340 --> 00:22:13,080
Alex I can burgers done some performance

00:22:10,080 --> 00:22:15,000
studies inside the IBM implementation

00:22:13,080 --> 00:22:18,450
and I believe is his number said it was

00:22:15,000 --> 00:22:21,149
less than one percent I'd be happy to

00:22:18,450 --> 00:22:26,789
take any questions or can all head for a

00:22:21,149 --> 00:22:28,970
beer any questions sounds pretty

00:22:26,789 --> 00:22:28,970
exciting

00:22:29,610 --> 00:22:33,470

YouTube URL: https://www.youtube.com/watch?v=Ztz8E4tZFFM


