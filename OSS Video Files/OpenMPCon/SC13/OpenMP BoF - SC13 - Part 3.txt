Title: OpenMP BoF - SC13 - Part 3
Publication date: 2014-12-13
Playlist: SC13
Description: 
	Jim Cownie (Intel) presents OpenMP and Clang developments
Captions: 
	00:00:00,000 --> 00:00:10,410
alright so thank you very much always

00:00:03,270 --> 00:00:13,380
entertaining and relevant but a next

00:00:10,410 --> 00:00:18,359
talk I really am excited because I want

00:00:13,380 --> 00:00:21,869
to hear about where we are with with

00:00:18,359 --> 00:00:23,609
climbing implementations on on openmp so

00:00:21,869 --> 00:00:25,050
let me see if I can I'm successful this

00:00:23,609 --> 00:00:28,920
time they're trying to put this thing on

00:00:25,050 --> 00:00:32,940
the screen yes now let's scroll properly

00:00:28,920 --> 00:00:35,579
yes thank you thank you so I'm Jim

00:00:32,940 --> 00:00:37,500
County from Intel a lot of this work has

00:00:35,579 --> 00:00:40,469
been done by Intel but mostly in our

00:00:37,500 --> 00:00:43,559
Russian compiler lab I'm our architect

00:00:40,469 --> 00:00:47,700
for the openmp runtime so I can talk in

00:00:43,559 --> 00:00:49,230
more detail about the runtime and I'll

00:00:47,700 --> 00:00:51,809
try and skip through this quite fast

00:00:49,230 --> 00:00:54,059
because I know that John has a lot of

00:00:51,809 --> 00:00:55,530
interesting stuff to show and we're both

00:00:54,059 --> 00:00:57,149
standing between you and beer or

00:00:55,530 --> 00:01:00,750
whoever's party you're choosing to go to

00:00:57,149 --> 00:01:04,619
this evening so a little history just to

00:01:00,750 --> 00:01:08,159
set the tone what we're talking about

00:01:04,619 --> 00:01:09,990
openmp supporting in lv m there are two

00:01:08,159 --> 00:01:14,460
ways that you can choose to compile

00:01:09,990 --> 00:01:16,200
openmp inside the compiler either so

00:01:14,460 --> 00:01:18,150
normally what you have to do you have to

00:01:16,200 --> 00:01:19,740
outline the function of the body of the

00:01:18,150 --> 00:01:23,040
parallel region so that you can execute

00:01:19,740 --> 00:01:25,409
it in parallel you can do that early or

00:01:23,040 --> 00:01:28,350
late there were several proposals in

00:01:25,409 --> 00:01:30,329
2012 all of them which involved late

00:01:28,350 --> 00:01:33,270
outlining and therefore changes to the

00:01:30,329 --> 00:01:35,070
llvm intermediate representation which

00:01:33,270 --> 00:01:36,600
were not acceptable to the llvm

00:01:35,070 --> 00:01:38,130
community effectively they thought that

00:01:36,600 --> 00:01:42,150
there were two large changes and too

00:01:38,130 --> 00:01:45,540
complicated so instead of that there was

00:01:42,150 --> 00:01:47,790
a OpenMP project in two proposed which

00:01:45,540 --> 00:01:49,500
would do the outlining right up at the

00:01:47,790 --> 00:01:51,420
front of the process so that the rest of

00:01:49,500 --> 00:01:53,250
the system doesn't really isn't really

00:01:51,420 --> 00:01:55,619
aware of OpenMP at all it just sees

00:01:53,250 --> 00:01:58,079
sequential code which happens to have

00:01:55,619 --> 00:02:00,270
calls to runtime routines in it and some

00:01:58,079 --> 00:02:03,770
different addresses addressing

00:02:00,270 --> 00:02:07,590
operations that was started by AMD and

00:02:03,770 --> 00:02:08,539
continued by intel supporting early

00:02:07,590 --> 00:02:11,569
outlining

00:02:08,539 --> 00:02:13,010
and the openmp runtime library calls are

00:02:11,569 --> 00:02:15,530
generated right at the front of the

00:02:13,010 --> 00:02:17,510
whole process the result of that is that

00:02:15,530 --> 00:02:19,359
there are no changes to the llvm I are

00:02:17,510 --> 00:02:22,280
required which makes it a much easier

00:02:19,359 --> 00:02:24,650
sales proposition to the llvm community

00:02:22,280 --> 00:02:26,060
because it has many fewer implications

00:02:24,650 --> 00:02:29,989
on the way that the whole of the rest of

00:02:26,060 --> 00:02:31,519
the compiler chain works just to be

00:02:29,989 --> 00:02:35,540
clear that difference between the early

00:02:31,519 --> 00:02:36,950
and late outlining so you have to visit

00:02:35,540 --> 00:02:38,959
this example is really just showing

00:02:36,950 --> 00:02:41,090
outlining so what happens is you have

00:02:38,959 --> 00:02:43,459
this OpenMP code on the left which has a

00:02:41,090 --> 00:02:46,849
pragma on parallel for you can see that

00:02:43,459 --> 00:02:49,220
it's accessing these up level variables

00:02:46,849 --> 00:02:50,900
a XY and z they're all shared variables

00:02:49,220 --> 00:02:52,790
they're all in the outer scope that has

00:02:50,900 --> 00:02:54,069
to be converted into something much more

00:02:52,790 --> 00:02:56,959
like the code on the right hand side

00:02:54,069 --> 00:02:59,209
where firstly at the top there we have

00:02:56,959 --> 00:03:01,250
some cultists to a runtime routine or an

00:02:59,209 --> 00:03:02,959
abstraction of a runtime routine which

00:03:01,250 --> 00:03:05,900
is doing the work sharing for that loop

00:03:02,959 --> 00:03:08,900
and then you can see in red here the all

00:03:05,900 --> 00:03:13,549
of the addressing of this inner func of

00:03:08,900 --> 00:03:16,280
these variables AI a x and y and z has

00:03:13,549 --> 00:03:17,810
been replaced by effectively accessing

00:03:16,280 --> 00:03:19,879
them indirectly through this struct

00:03:17,810 --> 00:03:22,129
pointer r which is a pointer back into

00:03:19,879 --> 00:03:24,139
the stack frame of the of the of the

00:03:22,129 --> 00:03:25,790
non-parallel region so the whole of this

00:03:24,139 --> 00:03:28,549
parallel loop has been abstracted into

00:03:25,790 --> 00:03:30,319
this function for me and a pointer is

00:03:28,549 --> 00:03:32,870
passed in that allows you to access

00:03:30,319 --> 00:03:34,370
those shared variables and that can all

00:03:32,870 --> 00:03:35,510
obviously be done you can see here this

00:03:34,370 --> 00:03:37,729
is effectively a source to source

00:03:35,510 --> 00:03:40,579
translation that's done in the in the

00:03:37,729 --> 00:03:42,199
claim front end so that the intermediate

00:03:40,579 --> 00:03:43,819
representation that's generated and seen

00:03:42,199 --> 00:03:45,979
by the whole of the rest of that the

00:03:43,819 --> 00:03:47,269
compiler remains as far as it's

00:03:45,979 --> 00:03:50,120
concerned concerned effective in

00:03:47,269 --> 00:03:52,069
sequential so slight a quick comparison

00:03:50,120 --> 00:03:53,479
of the advantages of doing that early or

00:03:52,069 --> 00:03:55,639
late so early means you're doing it

00:03:53,479 --> 00:03:57,709
right up at the front in parser

00:03:55,639 --> 00:03:59,900
effectively late means doing it right

00:03:57,709 --> 00:04:01,939
down towards the end so that much more

00:03:59,900 --> 00:04:05,689
of the runtime much more if the compiler

00:04:01,939 --> 00:04:08,479
has to know about it the advantage of

00:04:05,689 --> 00:04:09,949
doing it early the major advantage is

00:04:08,479 --> 00:04:11,319
that you don't have to change the rest

00:04:09,949 --> 00:04:13,760
of the intermediate representation

00:04:11,319 --> 00:04:15,699
whereas with the late like you would

00:04:13,760 --> 00:04:19,370
to however there are some disadvantages

00:04:15,699 --> 00:04:21,290
which are that you have all of the

00:04:19,370 --> 00:04:23,419
optimizations that are based on the

00:04:21,290 --> 00:04:24,710
parallel ISM are still up right up at

00:04:23,419 --> 00:04:26,419
the front there they can't be shared

00:04:24,710 --> 00:04:28,040
with other languages there right in the

00:04:26,419 --> 00:04:30,320
in the language dependent part of the

00:04:28,040 --> 00:04:31,940
system similarly there are other

00:04:30,320 --> 00:04:34,639
optimizations like constant propagation

00:04:31,940 --> 00:04:37,370
which are much harder to do when you've

00:04:34,639 --> 00:04:41,240
already already converted this into a

00:04:37,370 --> 00:04:43,100
separate function and the issue of

00:04:41,240 --> 00:04:45,229
whether it affects Slater compilation

00:04:43,100 --> 00:04:47,090
phases is kind of similar to the weather

00:04:45,229 --> 00:04:49,400
the intermediate representation is

00:04:47,090 --> 00:04:51,830
unchanged again you that's not thought

00:04:49,400 --> 00:04:56,389
you don't get the benefits of that if

00:04:51,830 --> 00:04:58,370
you if you do early outlining so in some

00:04:56,389 --> 00:04:59,930
ways late outlining is a preferable

00:04:58,370 --> 00:05:01,789
implementation it preserves our stuff

00:04:59,930 --> 00:05:04,039
but it has many more implications inside

00:05:01,789 --> 00:05:05,960
the compiler infrastructure so it wasn't

00:05:04,039 --> 00:05:07,610
acceptable to the llvm architects

00:05:05,960 --> 00:05:09,320
therefore there's there's no real point

00:05:07,610 --> 00:05:12,710
in continuing the discussion we have to

00:05:09,320 --> 00:05:15,160
do what we have to do so a very small

00:05:12,710 --> 00:05:18,320
example that Larry Meadows kindly ran

00:05:15,160 --> 00:05:20,870
you could see here not going to dive

00:05:18,320 --> 00:05:22,789
into clanging to me representation other

00:05:20,870 --> 00:05:24,590
than just to point out that his this you

00:05:22,789 --> 00:05:27,050
know fragment of parallel for you

00:05:24,590 --> 00:05:28,820
compile it you can dump the ast and you

00:05:27,050 --> 00:05:30,680
can see the bitsy read that it's

00:05:28,820 --> 00:05:32,690
introduced this on parallel directive

00:05:30,680 --> 00:05:34,940
here that it's all so that's a way

00:05:32,690 --> 00:05:37,190
within the past three and it's worked

00:05:34,940 --> 00:05:40,250
out that it has to capture these a and

00:05:37,190 --> 00:05:45,169
and a up level references from the

00:05:40,250 --> 00:05:46,880
parallel region the clearly a compiler

00:05:45,169 --> 00:05:48,169
is very good but you can't run anything

00:05:46,880 --> 00:05:49,729
without a runtime there has to be

00:05:48,169 --> 00:05:52,340
something that actually causes threads

00:05:49,729 --> 00:05:56,780
to be created and is involved in all of

00:05:52,340 --> 00:05:59,599
that we the existing GCC implementation

00:05:56,780 --> 00:06:01,159
of OpenMP uses it has a run time so one

00:05:59,599 --> 00:06:02,479
might assume that you have an open

00:06:01,159 --> 00:06:06,710
source runtime and that's great

00:06:02,479 --> 00:06:09,500
unfortunately GCC runtime is licensed

00:06:06,710 --> 00:06:12,849
under GPL whereas all of the llvm

00:06:09,500 --> 00:06:15,650
licensing is a bsd actually ncsa

00:06:12,849 --> 00:06:17,539
University of Illinois ncsa open-source

00:06:15,650 --> 00:06:20,840
license which is much closer to a three

00:06:17,539 --> 00:06:23,190
claws bsd license and they were not

00:06:20,840 --> 00:06:27,130
happy to you

00:06:23,190 --> 00:06:31,270
the GPL code so what was required is a

00:06:27,130 --> 00:06:33,310
fully llvm compatible licensed runtime

00:06:31,270 --> 00:06:35,169
and we took the decision that it would

00:06:33,310 --> 00:06:36,970
make sense to open-source are on time

00:06:35,169 --> 00:06:40,449
the Intel run primers used in our

00:06:36,970 --> 00:06:43,060
production compilers for use by this

00:06:40,449 --> 00:06:44,650
project home many other uses one of

00:06:43,060 --> 00:06:47,830
which John will be talking about in a

00:06:44,650 --> 00:06:51,280
minute under that kind of a license so

00:06:47,830 --> 00:06:53,020
our runtime is now open sourced with an

00:06:51,280 --> 00:06:55,090
llvm compatible license which is

00:06:53,020 --> 00:06:56,680
effectively a bsd license accompanied by

00:06:55,090 --> 00:06:58,570
a patent grant so that you can be

00:06:56,680 --> 00:07:01,180
completely confident that unless you

00:06:58,570 --> 00:07:03,190
start trying to sew Intel you can use it

00:07:01,180 --> 00:07:05,770
for whatever you wish to do you can make

00:07:03,190 --> 00:07:10,479
modifications you can sell product based

00:07:05,770 --> 00:07:14,620
on it additional advantage is having an

00:07:10,479 --> 00:07:15,820
open source runtime mentioned just since

00:07:14,620 --> 00:07:17,500
we're talking about it is the ability

00:07:15,820 --> 00:07:19,090
for tools providers to instrument the

00:07:17,500 --> 00:07:21,220
runtime this is what John's going to be

00:07:19,090 --> 00:07:22,840
talking about for prototyping new

00:07:21,220 --> 00:07:25,300
language features it's useful to do that

00:07:22,840 --> 00:07:26,710
you can also port the runtime to two

00:07:25,300 --> 00:07:29,139
other architectures should you wish to

00:07:26,710 --> 00:07:31,780
and we're entirely amenable to receiving

00:07:29,139 --> 00:07:34,840
contributions for processes that Intel

00:07:31,780 --> 00:07:36,729
doesn't support we have accepted some

00:07:34,840 --> 00:07:39,159
contributions to the build system and

00:07:36,729 --> 00:07:40,659
the runtime that enable arm allow you to

00:07:39,159 --> 00:07:42,280
build it for arm they're not actually

00:07:40,659 --> 00:07:44,409
back out again because there's a slight

00:07:42,280 --> 00:07:47,229
turn around time but they will be out in

00:07:44,409 --> 00:07:49,150
the next release and you can add

00:07:47,229 --> 00:07:50,770
detailed instrumentation for instance if

00:07:49,150 --> 00:07:53,440
you're interested in doing hardware

00:07:50,770 --> 00:07:57,280
simulation that kind of thing the

00:07:53,440 --> 00:08:00,750
current status is that open mp3 dot one

00:07:57,280 --> 00:08:04,210
support is available in the klang patch

00:08:00,750 --> 00:08:06,460
hosted at that web address it's the

00:08:04,210 --> 00:08:08,110
targets the run type the ABI as we

00:08:06,460 --> 00:08:12,099
obviously see it should be obvious by

00:08:08,110 --> 00:08:15,070
now it can run spec OMP 2012 it passes

00:08:12,099 --> 00:08:16,750
all our internal OpenMP tests the up

00:08:15,070 --> 00:08:19,270
streaming of that the clang trunk is

00:08:16,750 --> 00:08:21,789
underway the main issue there is finding

00:08:19,270 --> 00:08:23,289
people with clan commit privileges who

00:08:21,789 --> 00:08:27,219
are prepared to spend the time reviewing

00:08:23,289 --> 00:08:28,780
the changes and so the more people in

00:08:27,219 --> 00:08:31,960
the community who want to get involved

00:08:28,780 --> 00:08:34,150
and help us move forward the better and

00:08:31,960 --> 00:08:34,700
the runtime library is available either

00:08:34,150 --> 00:08:36,830
at open

00:08:34,700 --> 00:08:40,550
Peter llvm the hall where there's a get

00:08:36,830 --> 00:08:41,960
mirror of it or at openmp rtl org and as

00:08:40,550 --> 00:08:47,270
we said that has an incompatible

00:08:41,960 --> 00:08:49,460
licenses the library nearby on 5 is

00:08:47,270 --> 00:08:52,730
already interoperable with GCC compiled

00:08:49,460 --> 00:08:55,850
code so you can potentially mix coat

00:08:52,730 --> 00:08:58,640
that's been compiled by clang by GCC and

00:08:55,850 --> 00:09:00,680
by icc all in the same executable link

00:08:58,640 --> 00:09:04,610
against the one OpenMP runtime library

00:09:00,680 --> 00:09:07,460
and have that work correctly there is no

00:09:04,610 --> 00:09:09,080
however because of the some of the

00:09:07,460 --> 00:09:11,890
issues we were discussing with the with

00:09:09,080 --> 00:09:15,080
the early and late outlining there's no

00:09:11,890 --> 00:09:17,450
simple solution for dragon egg which is

00:09:15,080 --> 00:09:23,120
the kind of gfortran bolted onto llvm

00:09:17,450 --> 00:09:25,130
front end so the gfortran generated

00:09:23,120 --> 00:09:26,930
objects if you just use do for tray and

00:09:25,130 --> 00:09:28,550
that's fine because of the link

00:09:26,930 --> 00:09:31,640
compatibility you can do that but there

00:09:28,550 --> 00:09:34,780
isn't a fortran through llvm system that

00:09:31,640 --> 00:09:37,040
supports openmp yet and of course it

00:09:34,780 --> 00:09:41,930
operator operability with our compiler

00:09:37,040 --> 00:09:44,750
is the same as ever so it's available

00:09:41,930 --> 00:09:47,840
now you can download it promotions

00:09:44,750 --> 00:09:49,430
happening you can get the runtime you

00:09:47,840 --> 00:09:53,090
can use it for whatever you want to do

00:09:49,430 --> 00:09:55,190
it's completely a free bsd license with

00:09:53,090 --> 00:09:57,350
patent grant open source contributions

00:09:55,190 --> 00:09:59,270
are welcomed and we're very happy to

00:09:57,350 --> 00:10:03,670
receive received oh man to receive

00:09:59,270 --> 00:10:03,670
feedback on the process hi

00:10:09,880 --> 00:10:14,830
that the issue is is not it's not my

00:10:12,460 --> 00:10:18,820
issue retail VMs issue they want bsd

00:10:14,830 --> 00:10:22,200
licensed stuff so so Jim I think this is

00:10:18,820 --> 00:10:27,640
great I really think it's a great thing

00:10:22,200 --> 00:10:31,120
released your runtime build community so

00:10:27,640 --> 00:10:32,920
me never there's obviously so so I don't

00:10:31,120 --> 00:10:34,390
know the status and implementation for

00:10:32,920 --> 00:10:35,920
Intel systems because you guys have

00:10:34,390 --> 00:10:37,630
about a lot level stuff that you've done

00:10:35,920 --> 00:10:39,760
I don't know if that's included in what

00:10:37,630 --> 00:10:42,900
was released okay that's all so

00:10:39,760 --> 00:10:46,300
wonderful it'll be interesting to see

00:10:42,900 --> 00:10:48,810
how we go about getting similar quality

00:10:46,300 --> 00:10:50,740
on other systems but that's clearly not

00:10:48,810 --> 00:10:54,970
intelligent that complaining about that

00:10:50,740 --> 00:10:56,650
the question i actually have is so I

00:10:54,970 --> 00:10:58,180
mean we've added a lot of stuff from 40

00:10:56,650 --> 00:10:59,560
and there's going to be a there there

00:10:58,180 --> 00:11:02,590
are a lot of implications for the

00:10:59,560 --> 00:11:05,530
runtime support how much that is there

00:11:02,590 --> 00:11:07,930
and what are the plans for onions so the

00:11:05,530 --> 00:11:12,280
status at the moment is that the

00:11:07,930 --> 00:11:16,270
architecture of our system does not put

00:11:12,280 --> 00:11:18,670
the offload functions into the openmp

00:11:16,270 --> 00:11:22,120
runtime that's partly historical because

00:11:18,670 --> 00:11:23,890
when we did them for the Intel offload

00:11:22,120 --> 00:11:27,220
they were Intel offload primers that

00:11:23,890 --> 00:11:28,660
were unrelated to OpenMP so we have a

00:11:27,220 --> 00:11:32,050
separate library called live offload

00:11:28,660 --> 00:11:34,300
which handles which sits on top of koi

00:11:32,050 --> 00:11:36,190
and the rest of that stuff and that has

00:11:34,300 --> 00:11:42,610
no implications you do none of that code

00:11:36,190 --> 00:11:46,240
is in a open MP runtime it's possible so

00:11:42,610 --> 00:11:48,880
so that's one issue that the

00:11:46,240 --> 00:11:50,290
availability of that code is whether we

00:11:48,880 --> 00:11:54,370
choose to open source that or not is

00:11:50,290 --> 00:11:56,320
under discussion and so keep keep

00:11:54,370 --> 00:12:01,060
looking here on the other set of issues

00:11:56,320 --> 00:12:04,120
though things like distribute well you

00:12:01,060 --> 00:12:06,310
know the parallel loops with the

00:12:04,120 --> 00:12:08,290
different teams all of that stuff the

00:12:06,310 --> 00:12:09,760
team's distribute stuff is all in me in

00:12:08,290 --> 00:12:12,200
the runtime it's all there it's already

00:12:09,760 --> 00:12:14,270
released excellent

00:12:12,200 --> 00:12:16,070
and I don't get a vote scientists

00:12:14,270 --> 00:12:19,970
encouraging it to go ahead and release

00:12:16,070 --> 00:12:22,040
it early ballots I think we will do the

00:12:19,970 --> 00:12:27,440
right thing but it is not plan of record

00:12:22,040 --> 00:12:31,220
yet so you should not rely on any any

00:12:27,440 --> 00:12:34,510
any other questions okay thank you very

00:12:31,220 --> 00:12:34,510

YouTube URL: https://www.youtube.com/watch?v=7TIOB-0xwek


