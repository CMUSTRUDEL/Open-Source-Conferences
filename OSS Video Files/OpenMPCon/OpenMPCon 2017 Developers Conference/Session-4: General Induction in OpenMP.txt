Title: Session-4: General Induction in OpenMP
Publication date: 2017-10-15
Playlist: OpenMPCon 2017 Developers Conference
Description: 
	Ernesto Su, Hideki Saito and Xinmin Tian
Slides at http://openmpcon.org/wp-content/uploads/openmpcon2017/Day1-Session2-Su.pdf
Captions: 
	00:00:01,740 --> 00:00:10,710
my name is Ernesto I work in the Intel

00:00:05,310 --> 00:00:11,580
from Kampala group and so a lot of this

00:00:10,710 --> 00:00:14,009
work is from

00:00:11,580 --> 00:00:17,640
on-air permanently so I'm going to talk

00:00:14,009 --> 00:00:21,960
about and proposed extension we'd like

00:00:17,640 --> 00:00:29,539
to for OpenMP to support general

00:00:21,960 --> 00:00:32,759
induction mandatory disclaimers okay so

00:00:29,539 --> 00:00:36,120
one of our customers presented to us

00:00:32,759 --> 00:00:37,950
this financial reputation that has a

00:00:36,120 --> 00:00:42,059
bunch of loops that have this pattern

00:00:37,950 --> 00:00:45,210
and seemingly just to be easy to

00:00:42,059 --> 00:00:48,719
implement or since the to paralyze or

00:00:45,210 --> 00:00:54,210
vectorize in this case vectorize if it

00:00:48,719 --> 00:00:58,980
were not for the type of X being none

00:00:54,210 --> 00:01:02,760
interval so the penalty is linear clause

00:00:58,980 --> 00:01:07,830
is limited to interpret types for the

00:01:02,760 --> 00:01:11,939
induction variable and E and the

00:01:07,830 --> 00:01:14,640
operation is limited to tradition so if

00:01:11,939 --> 00:01:19,500
you want to express other instructions

00:01:14,640 --> 00:01:21,530
in this case is we'll have X that the

00:01:19,500 --> 00:01:25,470
induction variable doesn't have to be

00:01:21,530 --> 00:01:28,350
integral if there is that phase or if

00:01:25,470 --> 00:01:32,090
user want other type of industrial

00:01:28,350 --> 00:01:37,439
operations then we will not be able to

00:01:32,090 --> 00:01:39,630
vectorize or paralyze the loop so we

00:01:37,439 --> 00:01:42,680
would like to be able to support these

00:01:39,630 --> 00:01:42,680
customers so

00:01:43,100 --> 00:01:51,200
we think that it will be a good idea if

00:01:48,170 --> 00:01:54,140
we can extend openmp to support more

00:01:51,200 --> 00:01:57,650
operators could be built-in operators or

00:01:54,140 --> 00:02:00,710
user-defined operators and to support

00:01:57,650 --> 00:02:03,200
more data type also the data type of the

00:02:00,710 --> 00:02:08,080
induction variable and a step expression

00:02:03,200 --> 00:02:10,070
could be other than interval including

00:02:08,080 --> 00:02:16,580
user-defined types like class type

00:02:10,070 --> 00:02:19,880
solutions so the rest of the

00:02:16,580 --> 00:02:22,580
presentation I will give an overview of

00:02:19,880 --> 00:02:28,459
what in the concept of integral

00:02:22,580 --> 00:02:32,090
induction and covered the proposed

00:02:28,459 --> 00:02:34,640
extensions one is a induction clause and

00:02:32,090 --> 00:02:37,760
the other one is the clear induction

00:02:34,640 --> 00:02:41,030
construct that will let the user express

00:02:37,760 --> 00:02:46,190
the user-defined induction operation and

00:02:41,030 --> 00:02:48,530
then now complete so the concepts in

00:02:46,190 --> 00:02:51,739
this slide is is a pretty basic and is

00:02:48,530 --> 00:02:55,970
probably familiar to most of us the main

00:02:51,739 --> 00:02:57,860
purpose of it here is to basically agree

00:02:55,970 --> 00:03:02,680
on some terminology that we'll use in

00:02:57,860 --> 00:03:06,049
the rest of the presentation so an

00:03:02,680 --> 00:03:11,450
induction has an induction variable X

00:03:06,049 --> 00:03:17,030
and we can represent it in a recursive

00:03:11,450 --> 00:03:19,549
form where the value of x the entry of

00:03:17,030 --> 00:03:24,140
every loop iteration can be computed

00:03:19,549 --> 00:03:27,019
based on the value of all based on its

00:03:24,140 --> 00:03:30,830
value in the previous iteration operated

00:03:27,019 --> 00:03:36,310
on with from a loop invariant expression

00:03:30,830 --> 00:03:40,190
S which we call the set so in this I

00:03:36,310 --> 00:03:42,650
represents the loop index in the stages

00:03:40,190 --> 00:03:44,209
we don't normalize so X naught is the

00:03:42,650 --> 00:03:48,239
initial value of

00:03:44,209 --> 00:03:56,099
upon entry of the loop and if we rewrite

00:03:48,239 --> 00:03:59,519
it in a non Rex panders so that the F I

00:03:56,099 --> 00:04:03,900
at every every at any loop iteration I

00:03:59,519 --> 00:04:08,459
is basically a function of the initial

00:04:03,900 --> 00:04:15,269
value and operated with step expression

00:04:08,459 --> 00:04:17,720
items and this operation which I denote

00:04:15,269 --> 00:04:20,070
here as a circle plus is it could be

00:04:17,720 --> 00:04:22,919
addition like in the original linear

00:04:20,070 --> 00:04:27,410
cross but it could be any induction

00:04:22,919 --> 00:04:32,910
operation that we want to represent so

00:04:27,410 --> 00:04:36,210
in cases that is this operation the is

00:04:32,910 --> 00:04:39,780
the induction operation can be really

00:04:36,210 --> 00:04:43,380
associated in a way that the essence

00:04:39,780 --> 00:04:47,220
that this the i-r-s terms can be

00:04:43,380 --> 00:04:48,210
collected into one expression that is

00:04:47,220 --> 00:04:52,470
non-intuitive

00:04:48,210 --> 00:04:54,419
then we can call that expression of that

00:04:52,470 --> 00:04:56,909
operation or in this case in order that

00:04:54,419 --> 00:05:02,039
the circle kind the collective operator

00:04:56,909 --> 00:05:05,550
and if that operation is possible then

00:05:02,039 --> 00:05:11,400
we can rewrite the induction in a close

00:05:05,550 --> 00:05:15,270
one so as you see in the last line it

00:05:11,400 --> 00:05:21,539
could be the step expression could be

00:05:15,270 --> 00:05:23,639
collected and then use that step as the

00:05:21,539 --> 00:05:29,030
only step that you use also again like I

00:05:23,639 --> 00:05:32,250
said is non literate so that is

00:05:29,030 --> 00:05:34,440
basically the technology that will use

00:05:32,250 --> 00:05:39,330
the inductive operator is a collective

00:05:34,440 --> 00:05:40,690
operator and so on okay so and this is

00:05:39,330 --> 00:05:43,850
just

00:05:40,690 --> 00:05:45,680
the basic operations with medical

00:05:43,850 --> 00:05:49,100
operations we can see that all of them

00:05:45,680 --> 00:05:53,180
can be collected so over all of them the

00:05:49,100 --> 00:05:55,700
closed room is available so for the plus

00:05:53,180 --> 00:05:58,970
and minus the collective operation will

00:05:55,700 --> 00:06:07,010
be the multiplication and for crimes and

00:05:58,970 --> 00:06:10,520
device is exponentiation okay so our

00:06:07,010 --> 00:06:16,520
first also a clause a neutral so

00:06:10,520 --> 00:06:19,670
induction and you have three seals ID

00:06:16,520 --> 00:06:22,610
that represents the induction operation

00:06:19,670 --> 00:06:26,540
it should be one of the built-in

00:06:22,610 --> 00:06:32,330
operations plus minus times divide or a

00:06:26,540 --> 00:06:34,640
user-defined operation and it is

00:06:32,330 --> 00:06:38,510
intended to be used with loop I

00:06:34,640 --> 00:06:45,560
constructs like own t4 or Cindy or

00:06:38,510 --> 00:06:49,640
distribute and it's the second field for

00:06:45,560 --> 00:06:52,670
for this will be a list of induction

00:06:49,640 --> 00:06:56,240
variables and then the last field is a

00:06:52,670 --> 00:07:01,430
step expression okay so here are some

00:06:56,240 --> 00:07:08,510
examples if you have the induction IDs

00:07:01,430 --> 00:07:13,070
using the plus and variables X Y and a

00:07:08,510 --> 00:07:17,810
set of one if XY is integer then is

00:07:13,070 --> 00:07:22,520
basically the same as linear X Y now if

00:07:17,810 --> 00:07:25,360
we use in the second example multiply

00:07:22,520 --> 00:07:27,550
out your induction operation then

00:07:25,360 --> 00:07:32,470
we're basically describing a nonlinear

00:07:27,550 --> 00:07:35,710
induction and certainly the user can

00:07:32,470 --> 00:07:40,599
specify from induction operation through

00:07:35,710 --> 00:07:44,080
that he or she defines himself using the

00:07:40,599 --> 00:07:49,810
next proposal that will describe so with

00:07:44,080 --> 00:07:54,939
that then you are allowed to use for the

00:07:49,810 --> 00:07:56,860
type of s and s it could be user-defined

00:07:54,939 --> 00:08:00,729
and like class types for example and

00:07:56,860 --> 00:08:03,870
they don't have to be the same okay so

00:08:00,729 --> 00:08:07,629
next I will present an example using

00:08:03,870 --> 00:08:11,520
basically the six image of the second

00:08:07,629 --> 00:08:11,520
example I'm going to

00:08:22,759 --> 00:08:31,129
we thought about it and the problem is

00:08:26,090 --> 00:08:32,659
because the operations can be different

00:08:31,129 --> 00:08:37,209
I couldn't find a default that really

00:08:32,659 --> 00:08:37,209
makes sense if for example

00:08:46,190 --> 00:08:49,289
[Music]

00:08:49,620 --> 00:09:00,330
well in terms of the syntax if you have

00:08:55,290 --> 00:09:01,680
both the the first field a something

00:09:00,330 --> 00:09:08,940
economist and the last years of

00:09:01,680 --> 00:09:10,950
economics then I don't know I acting to

00:09:08,940 --> 00:09:14,850
do that if you just leave a blank with a

00:09:10,950 --> 00:09:20,100
column otherwise because the the

00:09:14,850 --> 00:09:24,090
variables are a be the first feel to be

00:09:20,100 --> 00:09:25,950
a identifier for the operation you will

00:09:24,090 --> 00:09:30,090
be harder to parse for the compiler is

00:09:25,950 --> 00:09:33,030
that okay okay I see yeah if we leave

00:09:30,090 --> 00:09:36,060
the colander than that that is yeah I

00:09:33,030 --> 00:09:38,390
think that that is a it's not in this

00:09:36,060 --> 00:09:41,700
life but I think that's not be a

00:09:38,390 --> 00:09:44,850
possible idea yes if you leave a column

00:09:41,700 --> 00:09:47,360
there then that means it's apply the

00:09:44,850 --> 00:09:47,360
ductwork

00:09:49,589 --> 00:09:52,589
so

00:09:53,680 --> 00:10:03,339
definitely deprecating linear or college

00:10:00,740 --> 00:10:03,339
instead

00:10:04,490 --> 00:10:14,400
yeah we could

00:10:07,310 --> 00:10:18,360
yes the thing I mean the first intention

00:10:14,400 --> 00:10:20,400
we had was to reuse linear and not

00:10:18,360 --> 00:10:22,620
invent a new cloth but then these kind

00:10:20,400 --> 00:10:25,500
of self-contradictory that we're saying

00:10:22,620 --> 00:10:29,430
well it's not linear actually or it

00:10:25,500 --> 00:10:34,920
could be yeah so whether those are

00:10:29,430 --> 00:10:37,530
details that we can refine it further do

00:10:34,920 --> 00:10:39,920
we want to use we use linear or come up

00:10:37,530 --> 00:10:44,340
with a new name

00:10:39,920 --> 00:10:46,650
okay yeah rather probably but then we

00:10:44,340 --> 00:10:49,080
have to have this do based backward

00:10:46,650 --> 00:10:52,080
compatibility people who already have

00:10:49,080 --> 00:10:55,170
linear in their code then maybe for

00:10:52,080 --> 00:10:58,700
sometimes the compiler has to start to

00:10:55,170 --> 00:10:58,700
honor that cause for some time

00:11:02,720 --> 00:11:09,130
stasia deprecated and the NACA danger

00:11:07,680 --> 00:11:12,850
were in Africa

00:11:09,130 --> 00:11:16,050
I see okay so we need some time for

00:11:12,850 --> 00:11:22,290
people to transition that's a good idea

00:11:16,050 --> 00:11:25,120
okay so here's an example using

00:11:22,290 --> 00:11:27,940
induction in a nonlinear fashion so in

00:11:25,120 --> 00:11:32,130
this case in this example we're trying

00:11:27,940 --> 00:11:36,520
to evaluate a polynomial so for given

00:11:32,130 --> 00:11:39,610
value of the variable X we want to

00:11:36,520 --> 00:11:42,270
basically compute the constant term for

00:11:39,610 --> 00:11:47,140
a Cartesian times X plus a coefficient

00:11:42,270 --> 00:11:50,350
times x squared and so forth and so in

00:11:47,140 --> 00:11:54,210
this example the induction variable is

00:11:50,350 --> 00:11:56,860
actually the powers of X so X to the I

00:11:54,210 --> 00:12:00,700
so that is our induction variable and

00:11:56,860 --> 00:12:03,040
the step is basically the value that you

00:12:00,700 --> 00:12:07,900
assign to X at which the polynomial will

00:12:03,040 --> 00:12:10,420
be evaluated so and of course the actual

00:12:07,900 --> 00:12:12,430
value of the polynomial is accumulated

00:12:10,420 --> 00:12:15,280
through a reduction in the state into

00:12:12,430 --> 00:12:19,810
the reduction variable value and then at

00:12:15,280 --> 00:12:23,130
every iteration of this loop the the

00:12:19,810 --> 00:12:29,110
induction Clause will compute the

00:12:23,130 --> 00:12:35,440
express power of X first okay so this is

00:12:29,110 --> 00:12:38,710
just one I think is a nice small example

00:12:35,440 --> 00:12:42,160
that shows what other reduction

00:12:38,710 --> 00:12:44,730
operations we can be using in real

00:12:42,160 --> 00:12:44,730
application

00:12:45,940 --> 00:12:53,890
s is always looking variance in any

00:12:49,330 --> 00:13:01,590
induction so yes it is constables back

00:12:53,890 --> 00:13:01,590
to this issue funny

00:13:01,970 --> 00:13:15,830
I'm just trying to be intact

00:13:06,470 --> 00:13:15,830
sighs I started life

00:13:16,950 --> 00:13:28,709
of buying you meanies eggs

00:13:20,430 --> 00:13:36,600
oh Sh

00:13:28,709 --> 00:13:50,459
I found another one is that the muscle

00:13:36,600 --> 00:13:55,170
comment i start i prefer sandwich over

00:13:50,459 --> 00:13:59,510
us breakfast pirate references expressed

00:13:55,170 --> 00:13:59,510
in goodbye and instruction

00:14:07,390 --> 00:14:18,310
yeah I think basically alive deduction

00:14:13,120 --> 00:14:22,510
hours but you're always happy but you I

00:14:18,310 --> 00:14:25,269
mean certificate of production you're

00:14:22,510 --> 00:14:28,660
just saying enough in introduction so

00:14:25,269 --> 00:14:32,950
perform the operations on credit tab and

00:14:28,660 --> 00:14:35,670
here is here we have our with you seen

00:14:32,950 --> 00:14:43,120
have immigrated apartment yes

00:14:35,670 --> 00:14:45,279
the explained that via the for induction

00:14:43,120 --> 00:14:47,820
just like linear is also operate on

00:14:45,279 --> 00:14:47,820
private copy

00:14:53,850 --> 00:15:03,010
or well the linear the linear induction

00:15:00,820 --> 00:15:04,840
world or the linear variable does not

00:15:03,010 --> 00:15:09,340
have to be the loop variable right could

00:15:04,840 --> 00:15:13,150
be it could be another variable that the

00:15:09,340 --> 00:15:14,710
user within the loop does its own

00:15:13,150 --> 00:15:22,570
induction they learned for example you

00:15:14,710 --> 00:15:25,270
can say so actually it's probably I have

00:15:22,570 --> 00:15:27,460
an another example eventually with with

00:15:25,270 --> 00:15:30,480
some pseudocode of the Cochin that

00:15:27,460 --> 00:15:30,480
probably will give you

00:15:35,580 --> 00:15:45,839
okay so and if we want to go beyond this

00:15:42,540 --> 00:15:48,600
building types and operators and we

00:15:45,839 --> 00:15:52,800
would like to be able to express

00:15:48,600 --> 00:15:55,920
user-defined induction operations where

00:15:52,800 --> 00:15:58,350
the user will specify the type of the

00:15:55,920 --> 00:16:02,100
induction variable the type of respect

00:15:58,350 --> 00:16:04,709
step expression and express what the

00:16:02,100 --> 00:16:07,050
inductive operator and possibly what a

00:16:04,709 --> 00:16:11,100
collective operators are is a collective

00:16:07,050 --> 00:16:13,140
operator is specified and actually the

00:16:11,100 --> 00:16:17,010
comparison generator code because then

00:16:13,140 --> 00:16:19,920
you can you compute the initial value of

00:16:17,010 --> 00:16:22,680
the induction variables at the beginning

00:16:19,920 --> 00:16:25,769
of each thread or the beginning of the

00:16:22,680 --> 00:16:29,430
similans by using a prose form and

00:16:25,769 --> 00:16:33,690
computed in constant time and so the

00:16:29,430 --> 00:16:36,810
proposal to do this to describe this is

00:16:33,690 --> 00:16:40,470
similar to the existing the clear

00:16:36,810 --> 00:16:46,380
reduction construct in the impact so as

00:16:40,470 --> 00:16:48,959
a recap here's the syntax for declared

00:16:46,380 --> 00:16:52,500
reduction we can see there's a reduction

00:16:48,959 --> 00:16:54,600
ID in the field list of types for the

00:16:52,500 --> 00:16:57,149
reduction variables and an expression

00:16:54,600 --> 00:16:59,010
called a combiner that I will express

00:16:57,149 --> 00:17:01,110
how these partial results are combined

00:16:59,010 --> 00:17:04,740
and then to the specification the

00:17:01,110 --> 00:17:07,860
combiner uses special variables on te

00:17:04,740 --> 00:17:09,569
known PL to represent the reduction

00:17:07,860 --> 00:17:12,390
variable so we'll use a similar

00:17:09,569 --> 00:17:16,819
mechanism in our declared induction and

00:17:12,390 --> 00:17:21,270
then there's an optional initializer

00:17:16,819 --> 00:17:25,580
party in the liquor production facility

00:17:21,270 --> 00:17:29,780
in the the third induction brouhaha

00:17:25,580 --> 00:17:31,370
an optional part for collectors so

00:17:29,780 --> 00:17:35,600
here's what it looks like

00:17:31,370 --> 00:17:37,490
you have this in taxes for C but for

00:17:35,600 --> 00:17:41,920
Fortran is is the same is just change

00:17:37,490 --> 00:17:45,380
the own tea with bangle sign appointee

00:17:41,920 --> 00:17:50,660
okay so the first deal is an induction

00:17:45,380 --> 00:17:52,970
ID then type specifying the induction

00:17:50,660 --> 00:17:55,150
variables or type for the step

00:17:52,970 --> 00:17:58,850
expression and then the inductor

00:17:55,150 --> 00:18:02,540
expression that will show what this

00:17:58,850 --> 00:18:05,420
inductive operation is and the special

00:18:02,540 --> 00:18:07,250
variable will use is pointing out to

00:18:05,420 --> 00:18:13,450
represent the induction variable and

00:18:07,250 --> 00:18:16,670
only step to represent a step okay so in

00:18:13,450 --> 00:18:18,740
C++ design half an overloaded plus and

00:18:16,670 --> 00:18:21,380
then you just say all the articles on VR

00:18:18,740 --> 00:18:24,650
plus point except that that could be one

00:18:21,380 --> 00:18:26,420
way to express it in C of course your

00:18:24,650 --> 00:18:30,110
own house overloading so you can just

00:18:26,420 --> 00:18:36,560
have a function call there to to show

00:18:30,110 --> 00:18:39,830
how how this is done then is collective

00:18:36,560 --> 00:18:45,140
operation is possible for that inductive

00:18:39,830 --> 00:18:48,470
operation then you can express it using

00:18:45,140 --> 00:18:51,080
the special variable 20 step to

00:18:48,470 --> 00:18:53,360
represent a step expression and on the

00:18:51,080 --> 00:18:59,330
index row two percent that I the lobe

00:18:53,360 --> 00:19:02,330
iteration and again it will have the

00:18:59,330 --> 00:19:05,300
product that at the x over already in

00:19:02,330 --> 00:19:06,520
your class then you can say only set

00:19:05,300 --> 00:19:09,160
because on this test

00:19:06,520 --> 00:19:14,910
hands on the index and that would be

00:19:09,160 --> 00:19:21,010
your collective step so combining both

00:19:14,910 --> 00:19:23,830
then you have a toast one in use the

00:19:21,010 --> 00:19:25,690
collector to compute the collective step

00:19:23,830 --> 00:19:28,390
first and then use that as your step

00:19:25,690 --> 00:19:35,560
so combine that with a initial value of

00:19:28,390 --> 00:19:39,040
x using the inductive operator so here I

00:19:35,560 --> 00:19:43,870
have an example where this could be used

00:19:39,040 --> 00:19:47,200
in fertilization say a the class for my

00:19:43,870 --> 00:19:52,660
induction variable s is a calf or my

00:19:47,200 --> 00:19:55,270
step then the declare induction

00:19:52,660 --> 00:19:59,380
construct will look like the first field

00:19:55,270 --> 00:20:02,500
here so P is my ID I used for this

00:19:59,380 --> 00:20:09,280
operation and then the type specifiers

00:20:02,500 --> 00:20:12,550
ans and then the first field I have 20 L

00:20:09,280 --> 00:20:15,850
equals on the a plus 20 step where this

00:20:12,550 --> 00:20:21,790
plus is overloaded for a and f for this

00:20:15,850 --> 00:20:25,660
classic and assuming that this operation

00:20:21,790 --> 00:20:28,750
is a allowable collector then I can

00:20:25,660 --> 00:20:33,220
specify collector in this manner as well

00:20:28,750 --> 00:20:37,170
again the x here is overloaded for that

00:20:33,220 --> 00:20:39,250
the step type and the integral type

00:20:37,170 --> 00:20:42,940
according Dix

00:20:39,250 --> 00:20:45,250
and then so I can express my parallel

00:20:42,940 --> 00:20:48,670
for loop with an induction clause using

00:20:45,250 --> 00:20:51,640
Opie and then specify a little a and

00:20:48,670 --> 00:20:55,240
little SS my induction variable and the

00:20:51,640 --> 00:21:00,520
static session and expect the compiler

00:20:55,240 --> 00:21:03,250
to generate code for it by using since I

00:21:00,520 --> 00:21:06,460
specify the collector the compiler

00:21:03,250 --> 00:21:09,310
should be able to find the initial value

00:21:06,460 --> 00:21:13,930
of a for every thread using our close

00:21:09,310 --> 00:21:16,600
one so the first step is our front-end

00:21:13,930 --> 00:21:20,950
will generate the inductor and collector

00:21:16,600 --> 00:21:25,150
routines which will be involved from the

00:21:20,950 --> 00:21:28,150
back end and then only out ONP step when

00:21:25,150 --> 00:21:31,420
p70 index becomes formal parameters of

00:21:28,150 --> 00:21:33,850
these routines and then the front end

00:21:31,420 --> 00:21:37,780
will look at the class of a and s and

00:21:33,850 --> 00:21:40,590
then find what overloading the four with

00:21:37,780 --> 00:21:45,550
a plus and a multiplier and use that in

00:21:40,590 --> 00:21:49,270
this routine so once this is available

00:21:45,550 --> 00:21:51,790
then the compiler back-end will generate

00:21:49,270 --> 00:21:53,800
a thread a soap so the first thing of

00:21:51,790 --> 00:21:55,180
course is to call the runtime to obtain

00:21:53,800 --> 00:21:59,200
the lower bound upper bound for each

00:21:55,180 --> 00:22:05,080
further loop and then for each thread a

00:21:59,200 --> 00:22:08,620
loop the Google basically privatized the

00:22:05,080 --> 00:22:11,110
induction variable and we will create a

00:22:08,620 --> 00:22:13,780
variable for the sub expression as well

00:22:11,110 --> 00:22:15,520
so this will be basically is similar to

00:22:13,780 --> 00:22:19,350
the first 5s semantics right we'll

00:22:15,520 --> 00:22:19,350
privatize it and then copy constructor

00:22:19,500 --> 00:22:25,510
then he then would since the collector

00:22:23,500 --> 00:22:31,340
in dr. routines are already generated by

00:22:25,510 --> 00:22:35,000
a front-end the vacuum will use them and

00:22:31,340 --> 00:22:40,770
therefore science collector line will

00:22:35,000 --> 00:22:46,740
compute the the collective step back

00:22:40,770 --> 00:22:50,370
step step-in of that red using the lower

00:22:46,740 --> 00:22:52,710
bound of the frame so so basically is f

00:22:50,370 --> 00:22:54,330
x eyes where the eye is the lower one

00:22:52,710 --> 00:22:57,960
right so that that would be the initial

00:22:54,330 --> 00:22:59,750
one for each thread and then use that is

00:22:57,960 --> 00:23:03,630
in the inductor to combine with

00:22:59,750 --> 00:23:06,000
induction viable but at the induction

00:23:03,630 --> 00:23:08,670
bifocals either the initial value of a

00:23:06,000 --> 00:23:11,850
is coming in from the copper

00:23:08,670 --> 00:23:13,620
construction and then this F which is

00:23:11,850 --> 00:23:15,870
computed with the collector if you slept

00:23:13,620 --> 00:23:19,440
if s and then combined then you have the

00:23:15,870 --> 00:23:23,450
closed form so with that then the loop

00:23:19,440 --> 00:23:26,880
will proceed normally is so basically

00:23:23,450 --> 00:23:29,760
other than the privatization semantics

00:23:26,880 --> 00:23:32,040
were a is replaced and s is because the

00:23:29,760 --> 00:23:36,350
loop is is the body of the loop is

00:23:32,040 --> 00:23:40,200
unchanged versus other threaded work and

00:23:36,350 --> 00:23:44,630
after the loop and just like with linear

00:23:40,200 --> 00:23:48,030
with induction you have to copy out the

00:23:44,630 --> 00:23:51,080
last value of a so this is similar to

00:23:48,030 --> 00:23:51,080
the last 5s domestic

00:23:51,419 --> 00:24:00,239
so that is the cogent for Freud ization

00:23:55,019 --> 00:24:02,879
and for vectorization is basically in

00:24:00,239 --> 00:24:04,379
terms of specifying it is the same the

00:24:02,879 --> 00:24:07,079
declare induction this is the same as

00:24:04,379 --> 00:24:10,320
the previous right the only thing here

00:24:07,079 --> 00:24:13,379
is instead of 590 power 4 now it's our

00:24:10,320 --> 00:24:15,419
Mount Isa me rather than other the

00:24:13,379 --> 00:24:16,919
specification is the same and of course

00:24:15,419 --> 00:24:22,109
the cogeneration would be different

00:24:16,919 --> 00:24:28,919
because it is for vectorization so it's

00:24:22,109 --> 00:24:33,239
basically the vaporizer will generate a

00:24:28,919 --> 00:24:36,179
vector form of a + S and then propagate

00:24:33,239 --> 00:24:39,690
or populate it with a and s for all

00:24:36,179 --> 00:24:41,509
these vector elements and then so that

00:24:39,690 --> 00:24:46,200
is first step and the second step

00:24:41,509 --> 00:24:48,719
Google now compute the vector of a lead

00:24:46,200 --> 00:24:53,070
is for basically the initial value vary

00:24:48,719 --> 00:24:58,229
for each ceiling using the vector form

00:24:53,070 --> 00:25:00,959
of a collector and water and then we

00:24:58,229 --> 00:25:05,879
will have to also produce a vector form

00:25:00,959 --> 00:25:09,089
of the stat expression which is followed

00:25:05,879 --> 00:25:12,179
by the vector length so that is also

00:25:09,089 --> 00:25:18,659
computed this time using the the scalar

00:25:12,179 --> 00:25:22,289
collector and with that the unlike the

00:25:18,659 --> 00:25:25,639
blue body of that the thread I face the

00:25:22,289 --> 00:25:28,789
body here for the vectorized case to be

00:25:25,639 --> 00:25:34,289
just like in other vectorization

00:25:28,789 --> 00:25:35,500
examples they the scalars are converted

00:25:34,289 --> 00:25:39,040
to vector form

00:25:35,500 --> 00:25:45,130
and the function call is also vector

00:25:39,040 --> 00:25:48,430
form and then the copy out copying out

00:25:45,130 --> 00:25:56,280
the value of the last vector element to

00:25:48,430 --> 00:26:02,520
ace is similar so that would be how the

00:25:56,280 --> 00:26:07,230
vectorization will happen so currently

00:26:02,520 --> 00:26:11,070
we have implemented in the C compiler

00:26:07,230 --> 00:26:15,820
the front end is already prototype and

00:26:11,070 --> 00:26:18,480
so we have some results out of that the

00:26:15,820 --> 00:26:22,960
intermediate language representation for

00:26:18,480 --> 00:26:25,450
these classes are drawn the actual back

00:26:22,960 --> 00:26:27,550
end of implementations of paralyzer and

00:26:25,450 --> 00:26:33,940
the vector is a big lies are still in

00:26:27,550 --> 00:26:37,690
progress in Fortran the opponent they

00:26:33,940 --> 00:26:41,950
agree to do this at some point but they

00:26:37,690 --> 00:26:45,820
haven't given us a time so I can only

00:26:41,950 --> 00:26:49,060
put to be done here the packing is the

00:26:45,820 --> 00:26:53,850
same as the C C++ compilers back end so

00:26:49,060 --> 00:26:56,380
that that is a valid and there is no

00:26:53,850 --> 00:27:04,570
need to change at one time to support

00:26:56,380 --> 00:27:07,140
this new feature so so to summarize we

00:27:04,570 --> 00:27:11,350
have seen three applications that demand

00:27:07,140 --> 00:27:14,200
these extensions and we proposed

00:27:11,350 --> 00:27:16,840
extensions and we can support more

00:27:14,200 --> 00:27:19,260
operations and more data types in

00:27:16,840 --> 00:27:21,970
induction relations including

00:27:19,260 --> 00:27:25,950
user-defined operations and data types

00:27:21,970 --> 00:27:25,950
and we present at some exam

00:27:32,760 --> 00:27:51,080
Oh anyway right you could have done

00:27:47,580 --> 00:27:56,370
exactly where I am today

00:27:51,080 --> 00:27:57,679
so you paralyzed well you can do the

00:27:56,370 --> 00:28:02,090
back position

00:27:57,679 --> 00:28:02,090
this is just a check truck yet

00:28:02,270 --> 00:28:06,490
so Justin

00:28:09,110 --> 00:28:30,530
so oh let me see if I understand your

00:28:25,409 --> 00:28:30,530
question your sister you're asking is so

00:28:31,789 --> 00:28:43,080
of the introvert nothing that I can

00:28:38,520 --> 00:28:51,419
there is no the regulation if is the

00:28:43,080 --> 00:28:53,520
technical group home is there we can go

00:28:51,419 --> 00:29:01,710
back to the linear it even with a linear

00:28:53,520 --> 00:29:10,590
clause the various population between so

00:29:01,710 --> 00:29:16,200
we have many who hold near transcription

00:29:10,590 --> 00:29:19,350
because you are significantly any

00:29:16,200 --> 00:29:26,480
average an unstructured

00:29:19,350 --> 00:29:27,720
right replaced by the simple calculation

00:29:26,480 --> 00:29:33,480
upfront

00:29:27,720 --> 00:29:36,510
all right detector currently nearly do

00:29:33,480 --> 00:29:39,630
not fade in the lighting all the say the

00:29:36,510 --> 00:29:46,100
designers of linear variance and dimming

00:29:39,630 --> 00:29:50,520
of the iteration at that high so in fact

00:29:46,100 --> 00:29:55,590
shouldn't be operating to operations or

00:29:50,520 --> 00:30:02,610
discarded after generation - any of the

00:29:55,590 --> 00:30:05,549
linear clause is the linear the

00:30:02,610 --> 00:30:13,590
variables are known at the beginning of

00:30:05,549 --> 00:30:17,429
each loop but also you you can have

00:30:13,590 --> 00:30:21,870
because of its specification you know

00:30:17,429 --> 00:30:25,679
it's how to optimize it when the loop is

00:30:21,870 --> 00:30:30,000
say paralyzed or vectorize by knowing

00:30:25,679 --> 00:30:35,520
the value of that variable and every

00:30:30,000 --> 00:30:38,490
iteration and also linear implies that

00:30:35,520 --> 00:30:44,190
it is privatized so you can operate on

00:30:38,490 --> 00:30:48,999
it directly by his magic five attacks is

00:30:44,190 --> 00:30:51,539
versus a breed that led to the variable

00:30:48,999 --> 00:30:57,100
people a year are alive

00:30:51,539 --> 00:30:57,940
that you have equivalent to pasture no

00:30:57,100 --> 00:31:00,059
no no I

00:30:57,940 --> 00:31:18,489
there is mostly really equivalent

00:31:00,059 --> 00:31:25,109
necessarily right we're here to say if

00:31:18,489 --> 00:31:32,200
that is an LTV but not generated by

00:31:25,109 --> 00:31:38,229
salmon a when you hear this pepper say

00:31:32,200 --> 00:31:41,229
definitely give a reduction

00:31:38,229 --> 00:31:41,229
no-no-no

00:31:42,460 --> 00:31:54,580
I expecting that name well the

00:31:47,080 --> 00:32:03,549
likelihood know yet but we're conducting

00:31:54,580 --> 00:32:10,440
loop de loop variable in a worm and if

00:32:03,549 --> 00:32:14,710
you're saying you're making a Python we

00:32:10,440 --> 00:32:17,519
if I granted if you're telling you that

00:32:14,710 --> 00:32:22,720
if I provide and here you bringing them

00:32:17,519 --> 00:32:26,529
then you production Rominger go in the

00:32:22,720 --> 00:32:28,840
other line right but we change general

00:32:26,529 --> 00:32:31,869
lines by ndmp

00:32:28,840 --> 00:32:35,519
we up everything else be state this were

00:32:31,869 --> 00:32:37,929
dead I think of the social discussion

00:32:35,519 --> 00:32:41,080
while I'm here it actually has a

00:32:37,929 --> 00:32:42,660
negative time on to here even your

00:32:41,080 --> 00:32:46,320
abiding design

00:32:42,660 --> 00:32:57,440
doesn't matter how you get that is

00:32:46,320 --> 00:33:00,900
divider instead of two angles n0 + 3 9 I

00:32:57,440 --> 00:33:06,150
write a few generations I do some

00:33:00,900 --> 00:33:09,810
calculus that I have a a +3 well then um

00:33:06,150 --> 00:33:12,410
I'm in southern Africa and one of livers

00:33:09,810 --> 00:33:17,610
end up a that I should actually be get

00:33:12,410 --> 00:33:19,680
paid zero plus tripartite Isis for to

00:33:17,610 --> 00:33:24,090
the plaintiff demonstration kinds of

00:33:19,680 --> 00:33:26,580
assignments you can make - oh no I have

00:33:24,090 --> 00:33:32,660
to see whether you have item orbiting

00:33:26,580 --> 00:33:32,660
patent restrictions the first

00:33:34,190 --> 00:33:40,720
[Music]

00:33:42,170 --> 00:33:55,820
yes you're coming to the quad rubbing

00:33:48,390 --> 00:33:55,820
world I think what your sake

00:33:56,250 --> 00:33:59,369
[Music]

00:34:02,940 --> 00:34:10,709
[Music]

00:34:18,860 --> 00:34:22,010
[Music]

00:34:27,290 --> 00:34:41,190
we won

00:34:28,520 --> 00:34:44,460
[Music]

00:34:41,190 --> 00:34:47,730
if the the very first slide about the

00:34:44,460 --> 00:34:49,919
motivation that Daddy that is from pick

00:34:47,730 --> 00:34:52,319
up from our customers think that hey I

00:34:49,919 --> 00:34:55,049
cannot do this with OpenMP but this

00:34:52,319 --> 00:35:02,130
looks so simple why can't you just you

00:34:55,049 --> 00:35:04,349
don't do this for trans virtually yes

00:35:02,130 --> 00:35:06,720
but to actually verify verify we need to

00:35:04,349 --> 00:35:11,099
finish our compiler implementation right

00:35:06,720 --> 00:35:14,430
but but you you you could see like if

00:35:11,099 --> 00:35:16,829
you if you manually do this then you

00:35:14,430 --> 00:35:21,049
will be able to vectorize the soup or

00:35:16,829 --> 00:35:21,049
paralyze is is that it's a choice

00:35:21,940 --> 00:35:25,039
[Music]

00:35:28,289 --> 00:35:31,289
who

00:35:36,520 --> 00:36:12,310
yes those are two things out you don't

00:36:09,830 --> 00:36:19,180
need to have that defined in your class

00:36:12,310 --> 00:36:19,180
right because

00:36:21,170 --> 00:36:30,109
right the reason is you need to tell the

00:36:25,010 --> 00:36:43,549
compiler where which one to look at for

00:36:30,109 --> 00:36:48,490
example make crazy hand

00:36:43,549 --> 00:36:52,339
we never the slide where I had the

00:36:48,490 --> 00:37:00,890
declare induction the problem is at the

00:36:52,339 --> 00:37:04,390
actual use of your of your own induction

00:37:00,890 --> 00:37:07,510
trough how do you specify that operation

00:37:04,390 --> 00:37:07,510
[Music]

00:37:11,130 --> 00:37:14,209
[Music]

00:37:20,020 --> 00:37:23,090
[Music]

00:37:42,420 --> 00:37:51,730
and people type of operation actually

00:37:49,450 --> 00:37:56,290
let's go to the previous payment or even

00:37:51,730 --> 00:38:01,260
with overloaded operators the compiler

00:37:56,290 --> 00:38:04,830
can generate the vector version of those

00:38:01,260 --> 00:38:08,230
automatically when you when you declare

00:38:04,830 --> 00:38:14,080
these are within the other Cindy

00:38:08,230 --> 00:38:16,270
decreasingly the performance depends on

00:38:14,080 --> 00:38:20,050
how big a portion of that is within

00:38:16,270 --> 00:38:25,000
Unicode because every that will have

00:38:20,050 --> 00:38:27,010
overhead right but if that is not if

00:38:25,000 --> 00:38:29,380
you're Corazon dominated by that then by

00:38:27,010 --> 00:38:32,770
being able to vectorize or paralyze your

00:38:29,380 --> 00:38:35,290
loop you can still gain because you

00:38:32,770 --> 00:38:38,349
don't want to be dropped by not being

00:38:35,290 --> 00:38:41,050
able to do one thing if that is just one

00:38:38,349 --> 00:38:45,510
small thing of a big loop that has many

00:38:41,050 --> 00:38:45,510
other things that can be vectorized and

00:38:45,609 --> 00:38:51,369
payin overhead will still be beneficial

00:38:56,200 --> 00:39:02,650
pilot compiler work with another doesn t

00:39:00,910 --> 00:39:05,070
pretty obvious

00:39:02,650 --> 00:39:05,070
and

00:39:05,300 --> 00:39:18,710
that's right we got I was

00:39:21,290 --> 00:39:25,300
if I recall correctly

00:39:26,410 --> 00:39:29,530
[Music]

00:39:32,440 --> 00:39:39,410
what the overall impact with me in

00:39:36,140 --> 00:39:42,730
dungeons FP I was wondering if you took

00:39:39,410 --> 00:39:47,470
that line above the world

00:39:42,730 --> 00:39:50,360
and it reduces the inductive step by one

00:39:47,470 --> 00:39:52,910
with you each have an extra from

00:39:50,360 --> 00:39:54,800
counting here like we did with the

00:39:52,910 --> 00:40:02,390
programmer just be able to put that line

00:39:54,800 --> 00:40:05,300
up when you have to look for you would

00:40:02,390 --> 00:40:07,400
also automatically those stars into the

00:40:05,300 --> 00:40:09,590
partition to lose you are automatically

00:40:07,400 --> 00:40:18,080
know the students who started what the

00:40:09,590 --> 00:40:22,270
value of actually the actual placement

00:40:18,080 --> 00:40:25,940
of where you increment in the in the

00:40:22,270 --> 00:40:30,770
loop that is that is part of the user

00:40:25,940 --> 00:40:33,790
code so a fourth realization for example

00:40:30,770 --> 00:40:36,800
all the compiler does is the

00:40:33,790 --> 00:40:39,290
initializing of that variable at the

00:40:36,800 --> 00:40:41,360
beginning of every thread and then the

00:40:39,290 --> 00:40:44,270
copy up bodies in the body the

00:40:41,360 --> 00:40:47,120
competitors even touch in other words if

00:40:44,270 --> 00:40:49,340
you libel the compiler and say a equals

00:40:47,120 --> 00:40:52,670
a plus something else at each other step

00:40:49,340 --> 00:40:55,720
the compiler would just believe that and

00:40:52,670 --> 00:40:59,270
generate run code so the just similar to

00:40:55,720 --> 00:41:02,840
reduction if you don't put a real valid

00:40:59,270 --> 00:41:05,120
reduction a you know operation in there

00:41:02,840 --> 00:41:07,100
the compiler is going to still combine

00:41:05,120 --> 00:41:11,300
what if things are the pressure result

00:41:07,100 --> 00:41:13,430
but there is no no check for for the

00:41:11,300 --> 00:41:15,570
body so yeah basically the short answer

00:41:13,430 --> 00:41:18,709
is that you can put anything in the body

00:41:15,570 --> 00:41:18,709
[Music]

00:41:19,370 --> 00:41:22,450

YouTube URL: https://www.youtube.com/watch?v=OymQRsuRkzQ


