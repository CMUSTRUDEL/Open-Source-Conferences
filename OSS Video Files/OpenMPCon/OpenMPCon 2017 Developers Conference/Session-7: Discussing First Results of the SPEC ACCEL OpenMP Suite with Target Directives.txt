Title: Session-7: Discussing First Results of the SPEC ACCEL OpenMP Suite with Target Directives
Publication date: 2017-10-15
Playlist: OpenMPCon 2017 Developers Conference
Description: 
	Guido Juckeland, Robert Henschel, Sunita Chandrasekaran, Sandra Wienke, Junjie Li, Alexander Bobyr, William Brantley, Mathew Colgrove, Oscar Hernandez, Arpith Jacob, Kalyan Kumaran, Dave Raddatz, Veronica Vergara Larrea, Bo Wang, Brian Whitney, Matthias Mueller and Andrey Naraikin
Slides at http://openmpcon.org/wp-content/uploads/openmpcon2017/Day1-Session3-Hernandez.pdf
Captions: 
	00:00:00,030 --> 00:00:13,290
right so I'm the left hook and yes I am

00:00:08,010 --> 00:00:16,139
representing a theme here this effect

00:00:13,290 --> 00:00:19,980
xpg team who has been working very hard

00:00:16,139 --> 00:00:22,109
over the last year and a half or two

00:00:19,980 --> 00:00:29,789
years on coming up with our first

00:00:22,109 --> 00:00:34,079
official OpenMP 4.5 benchmark and for

00:00:29,789 --> 00:00:40,350
that we have an effort within the spec

00:00:34,079 --> 00:00:41,910
AFL effort in tech HPG that we just are

00:00:40,350 --> 00:00:44,340
very happy to announce that we just

00:00:41,910 --> 00:00:48,260
released this benchmark and the goal of

00:00:44,340 --> 00:00:52,170
this benchmark is to make sure that

00:00:48,260 --> 00:00:53,309
compilers and optimise openmp the best

00:00:52,170 --> 00:00:58,410
way possible

00:00:53,309 --> 00:01:02,430
while targeting a programming model that

00:00:58,410 --> 00:01:06,060
is performance portable the other end of

00:01:02,430 --> 00:01:08,369
my talk is going to pretty much be an

00:01:06,060 --> 00:01:13,860
overview of the airport that we have a

00:01:08,369 --> 00:01:15,650
spec HPG the benchmark philosophy I'm

00:01:13,860 --> 00:01:19,020
going to talk a little brief lis about

00:01:15,650 --> 00:01:22,439
aspect as well 1.2 benchmark which is

00:01:19,020 --> 00:01:26,250
the one that contains openmp 4.5 offload

00:01:22,439 --> 00:01:27,630
a support and we're going to have some

00:01:26,250 --> 00:01:30,060
I'm going to talk a little bit more

00:01:27,630 --> 00:01:32,700
about the experience that we have in The

00:01:30,060 --> 00:01:36,600
Libertines could using this benchmarked

00:01:32,700 --> 00:01:39,509
and this is and we're going to provide

00:01:36,600 --> 00:01:42,150
them our experience and feedback that we

00:01:39,509 --> 00:01:44,790
would like to tell to the community so

00:01:42,150 --> 00:01:47,430
that when they have like similar code

00:01:44,790 --> 00:01:50,220
they know what to do based on our

00:01:47,430 --> 00:01:52,520
experience and then some feedback that

00:01:50,220 --> 00:01:56,310
we would like to give to the openmp

00:01:52,520 --> 00:01:58,390
organization as a team to make things

00:01:56,310 --> 00:02:03,350
better

00:01:58,390 --> 00:02:06,380
yeah so spec SPG is part of a spec which

00:02:03,350 --> 00:02:08,959
is a nonprofit organization that was

00:02:06,380 --> 00:02:11,030
established to standardize a benchmarks

00:02:08,959 --> 00:02:11,900
and composed by many groups and one of

00:02:11,030 --> 00:02:17,150
the group's is the high performance

00:02:11,900 --> 00:02:19,160
group which Oakland is part of and we

00:02:17,150 --> 00:02:21,890
participate with many vendors and

00:02:19,160 --> 00:02:28,610
universities and National Lab in

00:02:21,890 --> 00:02:30,950
disappoint the ones that were a the

00:02:28,610 --> 00:02:34,910
people who develop this benchmark are

00:02:30,950 --> 00:02:37,190
the ones here in with the logos and I

00:02:34,910 --> 00:02:43,160
just want to mention that this is a very

00:02:37,190 --> 00:02:46,250
important a venue that it's a I find it

00:02:43,160 --> 00:02:48,739
like very very interesting because from

00:02:46,250 --> 00:02:52,430
the perspective of having my opening P

00:02:48,739 --> 00:02:54,400
hat I I can see that we have a lot of

00:02:52,430 --> 00:02:57,980
collaboration like these in terms of

00:02:54,400 --> 00:03:00,230
opening TRB but also having a

00:02:57,980 --> 00:03:02,360
collaboration like this to interpret and

00:03:00,230 --> 00:03:06,739
use the specification is very important

00:03:02,360 --> 00:03:10,459
so it's also a good idea for people to

00:03:06,739 --> 00:03:12,860
also get involved in the unit sort of

00:03:10,459 --> 00:03:15,920
effort because and we can learn from

00:03:12,860 --> 00:03:19,130
this process as well as help to

00:03:15,920 --> 00:03:21,980
co.design ideas a with opening the air B

00:03:19,130 --> 00:03:24,440
as well as develop a benchmarks that are

00:03:21,980 --> 00:03:30,440
going to be used by the vendors

00:03:24,440 --> 00:03:32,540
optimized that a on the platforms so

00:03:30,440 --> 00:03:36,200
there is always say we develop these

00:03:32,540 --> 00:03:39,760
benchmarks we developed a score and a

00:03:36,200 --> 00:03:42,200
and this score is kind of like relate a

00:03:39,760 --> 00:03:47,480
has a relation with a ratio with a

00:03:42,200 --> 00:03:50,299
reference machine and for example the

00:03:47,480 --> 00:03:53,750
spec as well a wanted to benchmark or

00:03:50,299 --> 00:03:56,600
the opening D benchmark is based on the

00:03:53,750 --> 00:04:00,800
reference machine which is an with

00:03:56,600 --> 00:04:07,010
di machine a and all the measurements

00:04:00,800 --> 00:04:09,020
that we present here is based on that so

00:04:07,010 --> 00:04:13,160
the the benchmarks are kind of like full

00:04:09,020 --> 00:04:17,630
application a we try to a you know to

00:04:13,160 --> 00:04:20,450
try to bring a lot of their a overhead

00:04:17,630 --> 00:04:22,580
from a including all the overhead from

00:04:20,450 --> 00:04:24,820
real applications and of likely you can

00:04:22,580 --> 00:04:27,740
think about them benchmarks or mini apps

00:04:24,820 --> 00:04:30,230
that we basically want to characterize

00:04:27,740 --> 00:04:32,480
as much as possible from the from the

00:04:30,230 --> 00:04:35,360
source application and then ensure that

00:04:32,480 --> 00:04:37,700
we do the correct results and and there

00:04:35,360 --> 00:04:39,800
are different rules on how we can run

00:04:37,700 --> 00:04:44,290
the benchmarks and validate the results

00:04:39,800 --> 00:04:49,460
as well as what are you know a

00:04:44,290 --> 00:04:51,980
acceptable a the inputs and conditions

00:04:49,460 --> 00:04:54,650
that we want to do when we run the day

00:04:51,980 --> 00:04:58,100
when we can people run these benchmarks

00:04:54,650 --> 00:05:00,590
on an architecture as well as rules on

00:04:58,100 --> 00:05:03,380
how we can report these results to the

00:05:00,590 --> 00:05:08,030
community and you know to have a valid

00:05:03,380 --> 00:05:13,390
run that can be verifiable and then

00:05:08,030 --> 00:05:16,360
they're like the benchmark as a

00:05:13,390 --> 00:05:20,510
hierarchy is designed where we have a

00:05:16,360 --> 00:05:26,360
suite called spec a cell and spec a cell

00:05:20,510 --> 00:05:28,130
contains a many a benchmarks within

00:05:26,360 --> 00:05:31,730
multiple programming models and one of

00:05:28,130 --> 00:05:34,040
them is open empty and then we have

00:05:31,730 --> 00:05:36,410
different data sizes so we can use for

00:05:34,040 --> 00:05:40,610
the benchmarks and components are the

00:05:36,410 --> 00:05:45,560
specific a benchmarks a numbers that we

00:05:40,610 --> 00:05:48,530
use and so in the context of spec of

00:05:45,560 --> 00:05:52,390
cells the opening p 4.5 benchmarks are

00:05:48,530 --> 00:05:55,660
the ones that are in the 500

00:05:52,390 --> 00:06:02,010
has a 500 numbering so when you see that

00:05:55,660 --> 00:06:02,010
you will know that that opening the 4.5

00:06:02,190 --> 00:06:08,740
so we basically have a two sets of a

00:06:06,490 --> 00:06:12,120
runs that we can run the benchmark one

00:06:08,740 --> 00:06:15,100
in the base run and then the pit run and

00:06:12,120 --> 00:06:19,570
on the base run we are very conservative

00:06:15,100 --> 00:06:22,210
on what flags and what that is the

00:06:19,570 --> 00:06:24,910
ordering of the constraints on what the

00:06:22,210 --> 00:06:28,480
compiler can use to run the benchmarks

00:06:24,910 --> 00:06:31,000
and then in the peak configuration we're

00:06:28,480 --> 00:06:35,260
more giving more freedom to the

00:06:31,000 --> 00:06:38,110
compilers to in terms of specifying

00:06:35,260 --> 00:06:39,520
compiler flags and configurations to be

00:06:38,110 --> 00:06:44,260
able to give us the best performance

00:06:39,520 --> 00:06:46,810
that they can on a given platform and we

00:06:44,260 --> 00:06:50,730
try to normalize the compiler switches

00:06:46,810 --> 00:06:54,630
for the benchmarks for the base run and

00:06:50,730 --> 00:06:59,470
and they are like only very minimal

00:06:54,630 --> 00:07:02,860
switches are allowed and a we call a

00:06:59,470 --> 00:07:06,810
possibility switches that may help the

00:07:02,860 --> 00:07:10,750
benchmark to run on different platforms

00:07:06,810 --> 00:07:13,450
in addition to that the base marks can

00:07:10,750 --> 00:07:16,720
also be a measure in the context of

00:07:13,450 --> 00:07:18,970
power and then note 11 and there is also

00:07:16,720 --> 00:07:24,190
a way to score them in terms of power

00:07:18,970 --> 00:07:27,430
constraints so so going back so what

00:07:24,190 --> 00:07:30,190
does what is a transmission is like this

00:07:27,430 --> 00:07:34,330
is a group effort a we also have Bolton

00:07:30,190 --> 00:07:36,970
and so on about how we reach consensus

00:07:34,330 --> 00:07:41,670
when we develop the benchmarks a and we

00:07:36,970 --> 00:07:46,080
have technicals and a

00:07:41,670 --> 00:07:54,310
these questions as well as a management

00:07:46,080 --> 00:07:55,960
discussions and and they're like

00:07:54,310 --> 00:08:00,400
different rules that we can do to do

00:07:55,960 --> 00:08:06,460
this so speaker sells was released in

00:08:00,400 --> 00:08:12,370
June 2017 and a 1.2 benchmarks and we

00:08:06,460 --> 00:08:14,800
have that benchmark that we can use in

00:08:12,370 --> 00:08:16,750
the context of the same basement being

00:08:14,800 --> 00:08:19,150
developed in OpenCL we have a benchmark

00:08:16,750 --> 00:08:22,450
in opening CC and Xbox one opening p4

00:08:19,150 --> 00:08:24,780
and the goal is to make it a portable

00:08:22,450 --> 00:08:29,680
across architectures and accelerators

00:08:24,780 --> 00:08:31,510
and and the rule is that the basement

00:08:29,680 --> 00:08:36,850
was passed with at least at least two

00:08:31,510 --> 00:08:38,800
compilers to be able to be a group and

00:08:36,850 --> 00:08:43,990
the benchmarks on the target one

00:08:38,800 --> 00:08:45,370
accelerator hit run and we use it to

00:08:43,990 --> 00:08:50,410
evaluate the performance or stability of

00:08:45,370 --> 00:08:52,000
the programming model so our experience

00:08:50,410 --> 00:08:55,450
and we started to develop this benchmark

00:08:52,000 --> 00:08:58,120
so we started as soon as we started to

00:08:55,450 --> 00:09:01,890
get like opening P 4.0 in compilers and

00:08:58,120 --> 00:09:04,180
at that time was everything was very new

00:09:01,890 --> 00:09:09,390
and we were starting to understand how

00:09:04,180 --> 00:09:13,660
we could program OpenMP and as people

00:09:09,390 --> 00:09:14,920
join the consortium we started to play

00:09:13,660 --> 00:09:17,170
around with the different programming

00:09:14,920 --> 00:09:21,220
styles and there were like programming

00:09:17,170 --> 00:09:23,680
styles that were SIMD centric where we

00:09:21,220 --> 00:09:26,260
could just basically express all the

00:09:23,680 --> 00:09:30,670
parallelism the context of target SIMD

00:09:26,260 --> 00:09:34,810
or we could develop other more like

00:09:30,670 --> 00:09:39,550
threaten a level a centric we're using a

00:09:34,810 --> 00:09:42,070
nested parallelism and or you know but

00:09:39,550 --> 00:09:44,200
at the end we all agree as the standard

00:09:42,070 --> 00:09:45,970
move forward that the best way to

00:09:44,200 --> 00:09:47,270
approach this was to use the combined

00:09:45,970 --> 00:09:51,590
directive

00:09:47,270 --> 00:09:56,840
that whenever possible with collapsing

00:09:51,590 --> 00:09:59,560
because that seems to be what a game was

00:09:56,840 --> 00:10:02,300
the most profitability in terms of a

00:09:59,560 --> 00:10:03,770
performance portability and give us a

00:10:02,300 --> 00:10:07,760
little bit more choice to the compilers

00:10:03,770 --> 00:10:10,010
to produce a collect call a so we

00:10:07,760 --> 00:10:14,270
developed a new assay we have so many

00:10:10,010 --> 00:10:16,100
discussions that with the vendors and

00:10:14,270 --> 00:10:21,920
the different people and we finally

00:10:16,100 --> 00:10:26,960
agree on a consensus and we did a for

00:10:21,920 --> 00:10:31,160
this benchmark with openmp 4.0 but then

00:10:26,960 --> 00:10:35,480
at that time opening p 4.5 bust out so

00:10:31,160 --> 00:10:38,690
we decided to keep 4.0 and just target

00:10:35,480 --> 00:10:40,910
directly 4.5 and then we related these

00:10:38,690 --> 00:10:42,890
benchmarks and in the context of 4.5

00:10:40,910 --> 00:10:45,230
because there were some semantic changes

00:10:42,890 --> 00:10:48,800
between those two specifications and

00:10:45,230 --> 00:10:50,690
then we continued the development

00:10:48,800 --> 00:10:53,870
this is the list of benchmarks that we

00:10:50,690 --> 00:10:56,090
are targeting most of them come from a

00:10:53,870 --> 00:10:58,070
well known other benchmarks our world

00:10:56,090 --> 00:11:03,380
unknown that has been ported to openmp

00:10:58,070 --> 00:11:10,130
4.5 as well as other ones from different

00:11:03,380 --> 00:11:18,860
from mini app and Rodinia one of the key

00:11:10,130 --> 00:11:23,450
things that that we wanted to talk about

00:11:18,860 --> 00:11:29,120
is that we started to develop the

00:11:23,450 --> 00:11:33,500
benchmarks and we wanted to to evaluate

00:11:29,120 --> 00:11:35,270
how the OpenMP accelerator we can

00:11:33,500 --> 00:11:40,040
believe as performance portable as

00:11:35,270 --> 00:11:41,780
possible and we rely on trying to push

00:11:40,040 --> 00:11:43,930
the limits on the compilers to be able

00:11:41,780 --> 00:11:46,460
to

00:11:43,930 --> 00:11:51,350
to write the code in a performance

00:11:46,460 --> 00:11:53,800
portable time and and what that meant

00:11:51,350 --> 00:11:56,630
well that will preach a parallel region

00:11:53,800 --> 00:12:00,650
within a specified number of teams or

00:11:56,630 --> 00:12:04,190
credit limit or number of threat or SIMD

00:12:00,650 --> 00:12:07,190
LEM or distribute or loop schedules with

00:12:04,190 --> 00:12:08,900
the idea that if we just write it in a

00:12:07,190 --> 00:12:10,700
style we can set up to multiple

00:12:08,900 --> 00:12:14,380
architectures and then we will be able

00:12:10,700 --> 00:12:17,590
to leave that to the compilers and then

00:12:14,380 --> 00:12:21,490
there will be become much smarter to

00:12:17,590 --> 00:12:24,610
help us to provide a good implementation

00:12:21,490 --> 00:12:27,260
values for different architectures

00:12:24,610 --> 00:12:29,630
although we understand that to turn this

00:12:27,260 --> 00:12:33,980
code we will have to specify some of

00:12:29,630 --> 00:12:36,800
these but but the goal here was to

00:12:33,980 --> 00:12:39,740
improve the compiler support or base the

00:12:36,800 --> 00:12:42,230
optimizations in in the compilers so we

00:12:39,740 --> 00:12:44,450
didn't expect fry them with the goal of

00:12:42,230 --> 00:12:47,960
you know actually being as much

00:12:44,450 --> 00:12:51,520
performance portability as possible so

00:12:47,960 --> 00:12:57,820
we use significantly they they combine a

00:12:51,520 --> 00:13:05,390
loop for whenever we needed and then

00:12:57,820 --> 00:13:10,280
they look that a we use the target team

00:13:05,390 --> 00:13:14,540
distribute a parallel for SIMD collapse

00:13:10,280 --> 00:13:17,600
and so we can so that will give us the

00:13:14,540 --> 00:13:20,300
flexibility of the compiler to pick

00:13:17,600 --> 00:13:23,420
different a schedule as a scheduler to

00:13:20,300 --> 00:13:26,450
the loop nest and for the loop that we

00:13:23,420 --> 00:13:28,520
could not call that we follow the

00:13:26,450 --> 00:13:31,430
strategy of putting outer loops with

00:13:28,520 --> 00:13:39,200
teams distributes and parallel for and

00:13:31,430 --> 00:13:43,370
the inner loop with SIMD and say so

00:13:39,200 --> 00:13:46,250
basically one of the ideas was that the

00:13:43,370 --> 00:13:48,560
way to specify this we were we like

00:13:46,250 --> 00:13:51,820
heavily for the loop nests that we could

00:13:48,560 --> 00:13:54,650
on the collapse close to 2 pi the

00:13:51,820 --> 00:13:58,850
potential or we can achieve on a given

00:13:54,650 --> 00:14:03,590
platform so one of the things from our

00:13:58,850 --> 00:14:06,860
experience was like reduction was a big

00:14:03,590 --> 00:14:11,450
issue when we move from 4.0 to 4.5

00:14:06,860 --> 00:14:16,580
because we needed to app to add a map to

00:14:11,450 --> 00:14:21,200
run from to the scalars that in 4.5

00:14:16,580 --> 00:14:22,520
scalars become first private so that was

00:14:21,200 --> 00:14:27,280
one of the things that we have to change

00:14:22,520 --> 00:14:29,330
extensively in the benchmark the other a

00:14:27,280 --> 00:14:34,220
experience that we have when using

00:14:29,330 --> 00:14:35,900
openmp 4.5 was that we tended within

00:14:34,220 --> 00:14:39,950
quite when we at the time we were using

00:14:35,900 --> 00:14:43,010
the term model we were to be safe many

00:14:39,950 --> 00:14:45,080
people or many members try to do a

00:14:43,010 --> 00:14:46,700
little bit of over privatization where

00:14:45,080 --> 00:14:48,740
they will travel ties variables at

00:14:46,700 --> 00:14:53,300
multiple levels when he was only needed

00:14:48,740 --> 00:14:57,950
that one level and that created more

00:14:53,300 --> 00:15:00,590
memory overheads and so on so that was

00:14:57,950 --> 00:15:02,090
kind of like a common mistake on when we

00:15:00,590 --> 00:15:05,690
develop the benchmark so we basically

00:15:02,090 --> 00:15:07,640
had to retool the benchmark so that we

00:15:05,690 --> 00:15:11,170
could call a specified correct levels of

00:15:07,640 --> 00:15:11,170
privatization that are efficient

00:15:11,680 --> 00:15:20,379
and then the other challenge in in what

00:15:15,889 --> 00:15:24,800
we do with opening p4 is they is that

00:15:20,379 --> 00:15:27,949
people when they're moving coats to two

00:15:24,800 --> 00:15:31,370
GPUs or the target teams they come from

00:15:27,949 --> 00:15:34,389
for example OpenMP 3.1 where there are

00:15:31,370 --> 00:15:37,759
like illicit barriers at the end of the

00:15:34,389 --> 00:15:40,279
24 but when they start to use things

00:15:37,759 --> 00:15:42,259
like teams this TV do things to do

00:15:40,279 --> 00:15:44,089
parallel pores or things like that

00:15:42,259 --> 00:15:46,339
that where the distributors who have the

00:15:44,089 --> 00:15:50,629
barrier at the end then it tends to be

00:15:46,339 --> 00:15:54,019
creating some mistakes and and we have

00:15:50,629 --> 00:15:58,339
to ensure that these that these look

00:15:54,019 --> 00:16:02,149
nice those who have dependences across

00:15:58,339 --> 00:16:05,420
them so that you know we can certify

00:16:02,149 --> 00:16:10,899
that and to do that the only way to

00:16:05,420 --> 00:16:15,290
synchronize across teams is basically

00:16:10,899 --> 00:16:16,970
you know the target construct because we

00:16:15,290 --> 00:16:20,170
know at the end of the target construct

00:16:16,970 --> 00:16:26,529
that all of the threats are complete

00:16:20,170 --> 00:16:29,360
their execution so if we want to merge a

00:16:26,529 --> 00:16:31,279
target team distribute parallel for a

00:16:29,360 --> 00:16:34,220
you know we can do that with only

00:16:31,279 --> 00:16:40,910
whenever it's safe to do and there were

00:16:34,220 --> 00:16:43,009
cases where we have this issue that we

00:16:40,910 --> 00:16:45,199
uncover like race conditions a

00:16:43,009 --> 00:16:47,059
throughout the benchmarks because we

00:16:45,199 --> 00:16:49,100
were not synchronizing this correctly so

00:16:47,059 --> 00:16:51,139
it's something for developers to be

00:16:49,100 --> 00:16:53,809
conscious about and we already know

00:16:51,139 --> 00:16:57,410
about this but sometimes it is not very

00:16:53,809 --> 00:17:01,070
obvious for some people when they move

00:16:57,410 --> 00:17:04,880
to open it be a 4.5

00:17:01,070 --> 00:17:09,380
a so the other challenge that we

00:17:04,880 --> 00:17:13,490
encounter was that when we tested these

00:17:09,380 --> 00:17:17,089
benchmarks we wrote them but we don't

00:17:13,490 --> 00:17:19,250
have a compiler that works on let's say

00:17:17,089 --> 00:17:22,940
all the platforms basically we have

00:17:19,250 --> 00:17:26,980
compiler that works on um fry or works

00:17:22,940 --> 00:17:29,660
and GPUs or it works on multi-core and

00:17:26,980 --> 00:17:32,750
and what happens is like opening these

00:17:29,660 --> 00:17:36,020
lower differently sometimes in or they

00:17:32,750 --> 00:17:39,500
pick different a implementation specific

00:17:36,020 --> 00:17:42,200
values just for example a one of the

00:17:39,500 --> 00:17:44,060
closest that they picked a specific

00:17:42,200 --> 00:17:47,360
values the number of teams if we don't

00:17:44,060 --> 00:17:49,400
specify any for example in the Intel

00:17:47,360 --> 00:17:52,910
Architecture the number of teams they

00:17:49,400 --> 00:17:58,760
become one and then all the parallelism

00:17:52,910 --> 00:18:02,240
comes from the parallel for SIMD and so

00:17:58,760 --> 00:18:04,640
when we tested things like that it kind

00:18:02,240 --> 00:18:06,500
of worked correctly on one platform but

00:18:04,640 --> 00:18:09,110
when we move it to things like GPUs

00:18:06,500 --> 00:18:11,450
where we have a bigger number of things

00:18:09,110 --> 00:18:14,540
we main we cover that the word of some

00:18:11,450 --> 00:18:18,320
great conditions across the team so when

00:18:14,540 --> 00:18:21,620
you write opening P 4.5 you have to be

00:18:18,320 --> 00:18:24,530
conscious of it on declare success if it

00:18:21,620 --> 00:18:28,130
works on only one platform you may want

00:18:24,530 --> 00:18:32,060
to test your code multiple platforms to

00:18:28,130 --> 00:18:34,190
make sure that you know you are

00:18:32,060 --> 00:18:36,830
satisfying all of the semantics of open

00:18:34,190 --> 00:18:39,320
MT because it's very easy to hide data

00:18:36,830 --> 00:18:40,910
races in one platform and that may not

00:18:39,320 --> 00:18:44,780
appear another one because the way

00:18:40,910 --> 00:18:47,750
compilers are dealing with the detect is

00:18:44,780 --> 00:18:54,650
a the lowering or the regimentation

00:18:47,750 --> 00:18:58,190
specific values C a and then the other

00:18:54,650 --> 00:19:00,200
challenge is like different compilers

00:18:58,190 --> 00:19:02,620
are different even within one platform

00:19:00,200 --> 00:19:04,970
their comparison have different

00:19:02,620 --> 00:19:06,470
strategies to lower some of the

00:19:04,970 --> 00:19:10,180
directives

00:19:06,470 --> 00:19:12,920
for example Crais may have a strategy

00:19:10,180 --> 00:19:18,580
the different strategy that compares to

00:19:12,920 --> 00:19:21,650
treat SIMD on GPUs for example and

00:19:18,580 --> 00:19:25,670
understanding those very well it is

00:19:21,650 --> 00:19:29,000
important because if we want to achieve

00:19:25,670 --> 00:19:30,380
performance portability a performance

00:19:29,000 --> 00:19:32,540
portability within the same platform

00:19:30,380 --> 00:19:36,400
across two different compilers is also

00:19:32,540 --> 00:19:39,050
important we need to focus on so that a

00:19:36,400 --> 00:19:41,690
so that when we write a code it performs

00:19:39,050 --> 00:19:44,180
well on the same one platform with

00:19:41,690 --> 00:19:45,560
multiple compilers that could be that

00:19:44,180 --> 00:19:50,090
that's something that is important that

00:19:45,560 --> 00:19:51,260
we have to do to achieve the during this

00:19:50,090 --> 00:19:53,150
case sometimes they are like different

00:19:51,260 --> 00:19:58,120
implementation strategies so we have to

00:19:53,150 --> 00:20:01,460
be careful about that and then a

00:19:58,120 --> 00:20:07,300
debugging makes it a little bit hard

00:20:01,460 --> 00:20:11,930
when you have different strategies for a

00:20:07,300 --> 00:20:14,060
lower in OpenMP and yes and this is and

00:20:11,930 --> 00:20:16,010
sometimes testing on multiple platforms

00:20:14,060 --> 00:20:17,480
different compilers you know main cover

00:20:16,010 --> 00:20:20,870
different correctness issues with the

00:20:17,480 --> 00:20:24,080
codes so at the end a we ported all the

00:20:20,870 --> 00:20:27,310
benchmarks and successfully we have a it

00:20:24,080 --> 00:20:31,760
all produced the correct results and

00:20:27,310 --> 00:20:33,260
spec as well they publish all of the

00:20:31,760 --> 00:20:37,640
results of the benchmarks and you can go

00:20:33,260 --> 00:20:41,990
to the web page where you can see the

00:20:37,640 --> 00:20:45,910
opening result and and you can see that

00:20:41,990 --> 00:20:48,230
all of them a benchmarks and

00:20:45,910 --> 00:20:50,090
implementations that are being tested

00:20:48,230 --> 00:20:54,830
with different compilers and different

00:20:50,090 --> 00:20:57,340
platforms and and you can see how this

00:20:54,830 --> 00:21:00,960
venture were compiled and contested and

00:20:57,340 --> 00:21:03,270
the base work contains C and Fortran and

00:21:00,960 --> 00:21:06,210
different testing centers you know

00:21:03,270 --> 00:21:08,490
provide information about that so one

00:21:06,210 --> 00:21:12,390
thing to notice is that to be able to

00:21:08,490 --> 00:21:14,880
publish results here all these 15

00:21:12,390 --> 00:21:20,280
ventures must pass on a compiler and a

00:21:14,880 --> 00:21:23,430
given architecture so there is so if

00:21:20,280 --> 00:21:28,380
that's not true then they will cannot be

00:21:23,430 --> 00:21:30,780
published be respect so that's why we're

00:21:28,380 --> 00:21:33,480
seeing a in the process of adding more

00:21:30,780 --> 00:21:35,640
results as compilers are starting to to

00:21:33,480 --> 00:21:40,530
tone for the benchmark as well as for

00:21:35,640 --> 00:21:43,110
correctness as well as performance you

00:21:40,530 --> 00:21:46,110
can see that for example one of the

00:21:43,110 --> 00:21:52,380
platform's first weapons that were is

00:21:46,110 --> 00:21:56,970
that we are reporting is this um try or

00:21:52,380 --> 00:22:01,380
the KML and and then you can see that

00:21:56,970 --> 00:22:04,820
you know we can get a speed-up across

00:22:01,380 --> 00:22:08,700
against the reference implementation and

00:22:04,820 --> 00:22:10,830
these are a you know very important for

00:22:08,700 --> 00:22:17,910
vendors to tune their compilers and

00:22:10,830 --> 00:22:19,920
compare implementation so what what we

00:22:17,910 --> 00:22:22,650
were going to say is like these ventures

00:22:19,920 --> 00:22:28,650
are very new especially they wanted to

00:22:22,650 --> 00:22:31,190
and right now a we only have 16

00:22:28,650 --> 00:22:33,480
reportable result as we said previously

00:22:31,190 --> 00:22:37,760
compared to hundreds that they are for

00:22:33,480 --> 00:22:40,980
other benchmarks and we still don't have

00:22:37,760 --> 00:22:47,430
official results for opening T 4.5

00:22:40,980 --> 00:22:51,900
offload on GPU we have compilers have

00:22:47,430 --> 00:22:54,120
support a open 84.5 of load on GPU just

00:22:51,900 --> 00:22:57,630
as to the day in the morning capturing

00:22:54,120 --> 00:23:00,270
O'Brien show you some resources some

00:22:57,630 --> 00:23:02,130
timings of some of these benchmarks run

00:23:00,270 --> 00:23:05,300
on GPU

00:23:02,130 --> 00:23:09,840
we're still working to getting the 15

00:23:05,300 --> 00:23:12,090
run correctly on the GTOs and we want to

00:23:09,840 --> 00:23:13,830
we think that by the end of this year we

00:23:12,090 --> 00:23:17,040
will hit the milestone of having a

00:23:13,830 --> 00:23:21,900
complete set of dangerous runs on GPUs

00:23:17,040 --> 00:23:25,440
and a part of the reason is like yeah

00:23:21,900 --> 00:23:30,120
just they compiled the evolution of the

00:23:25,440 --> 00:23:32,370
compiler as well as some vendors just

00:23:30,120 --> 00:23:34,170
got access of these benchmarks until

00:23:32,370 --> 00:23:37,350
recently because they were not spec

00:23:34,170 --> 00:23:43,080
members so it was very hard for them to

00:23:37,350 --> 00:23:44,429
do to get their hands on it and and but

00:23:43,080 --> 00:23:50,580
now they are already at recognize

00:23:44,429 --> 00:23:52,320
challenges so a so the goal of the

00:23:50,580 --> 00:23:54,120
benchmarks as I mentioned is to turn to

00:23:52,320 --> 00:23:56,640
the target architecture that's what we

00:23:54,120 --> 00:24:02,940
really want to do to force the compilers

00:23:56,640 --> 00:24:05,070
to be smart as possible and and then the

00:24:02,940 --> 00:24:07,380
comparative are developing things in

00:24:05,070 --> 00:24:08,670
different studies actually deciding what

00:24:07,380 --> 00:24:12,150
are the strategies for different

00:24:08,670 --> 00:24:13,830
architectures and so so code is signing

00:24:12,150 --> 00:24:16,230
something performance portable there are

00:24:13,830 --> 00:24:17,850
many variables going on from the poll to

00:24:16,230 --> 00:24:20,730
be the programming model but also the

00:24:17,850 --> 00:24:23,780
implementation as well as what is

00:24:20,730 --> 00:24:29,130
profitable in own on a given platform

00:24:23,780 --> 00:24:33,360
and so on you can obtain and install the

00:24:29,130 --> 00:24:35,580
benchmarks a perform your own run so

00:24:33,360 --> 00:24:37,410
supply a hardware description and then

00:24:35,580 --> 00:24:40,170
submit a report and it's going to be

00:24:37,410 --> 00:24:42,150
reviewed and then we can polish the

00:24:40,170 --> 00:24:45,390
result so that's kind of like the period

00:24:42,150 --> 00:24:47,280
if your Center is interested in in the

00:24:45,390 --> 00:24:50,400
evaluating them and getting results that

00:24:47,280 --> 00:24:53,910
we can compare with other compilers or

00:24:50,400 --> 00:24:55,040
platforms you can run and use this these

00:24:53,910 --> 00:25:02,310
ones

00:24:55,040 --> 00:25:03,600
and I want to mention that he respects

00:25:02,310 --> 00:25:05,940
my ideas well just released

00:25:03,600 --> 00:25:07,950
we cannot like looking at the next

00:25:05,940 --> 00:25:14,090
generation of benchmarks which is

00:25:07,950 --> 00:25:17,840
basically once to focus on base or

00:25:14,090 --> 00:25:26,130
hybrid programming in terms of MPI plus

00:25:17,840 --> 00:25:29,220
X and that X we think is OpenMP so we

00:25:26,130 --> 00:25:33,180
want to were looking for benchmarks that

00:25:29,220 --> 00:25:36,980
exploit multi node as well as at

00:25:33,180 --> 00:25:41,780
originating the node we're looking at

00:25:36,980 --> 00:25:46,940
the emerge that also supports a multiple

00:25:41,780 --> 00:25:49,440
accelerators for MPI tasks or rank and

00:25:46,940 --> 00:25:52,680
it's also that we can focus in terms of

00:25:49,440 --> 00:25:58,050
multiple accelerators as opposed to a

00:25:52,680 --> 00:26:00,900
single as a narrator benchmark we also

00:25:58,050 --> 00:26:05,430
are looking for benchmarks that are

00:26:00,900 --> 00:26:08,460
representative of the scientific field

00:26:05,430 --> 00:26:10,560
and that means a benchmarks will have a

00:26:08,460 --> 00:26:13,860
computational motifs that are relevant

00:26:10,560 --> 00:26:18,240
today and that we need vendors to

00:26:13,860 --> 00:26:19,770
optimize so what it means is like a lot

00:26:18,240 --> 00:26:22,140
of your efforts that you are doing in

00:26:19,770 --> 00:26:27,470
terms of mini apps experimenting with

00:26:22,140 --> 00:26:31,020
open 84.5 you know could be useful if

00:26:27,470 --> 00:26:32,940
some of them could donate some of these

00:26:31,020 --> 00:26:36,150
best parts to respect organization so

00:26:32,940 --> 00:26:39,150
that we can continue to display in

00:26:36,150 --> 00:26:42,870
genomics via compilers and code is

00:26:39,150 --> 00:26:47,280
innate with the platform submissions are

00:26:42,870 --> 00:26:51,500
also encouraged and there is also you

00:26:47,280 --> 00:26:54,030
know the spec offers a support for the

00:26:51,500 --> 00:26:56,850
some of them

00:26:54,030 --> 00:26:59,730
benchmark developers by you know

00:26:56,850 --> 00:27:02,760
providing some financial video financial

00:26:59,730 --> 00:27:05,280
support to help a demo in the process of

00:27:02,760 --> 00:27:08,130
preparing a benchmark and make it

00:27:05,280 --> 00:27:13,050
available for the suite there is a

00:27:08,130 --> 00:27:15,650
website for that and with that you have

00:27:13,050 --> 00:27:15,650
any questions

00:27:29,020 --> 00:27:32,230
[Music]

00:27:32,640 --> 00:27:35,000
ever

00:27:35,369 --> 00:27:42,179
on corrected I

00:27:45,610 --> 00:27:48,610
please

00:27:49,830 --> 00:27:58,140
or correctness yes absolutely absolutely

00:27:52,590 --> 00:27:59,430
so part of the benchmark at the end the

00:27:58,140 --> 00:28:02,040
basement has to be verifiable

00:27:59,430 --> 00:28:05,160
numerically so when they complete the

00:28:02,040 --> 00:28:08,070
benchmark the run you know the code is

00:28:05,160 --> 00:28:12,390
verified the results are verified

00:28:08,070 --> 00:28:14,660
numerically so so yes a that part of the

00:28:12,390 --> 00:28:17,660
process that a bench man has to be

00:28:14,660 --> 00:28:17,660
verifiable

00:28:18,910 --> 00:28:22,039
[Music]

00:28:25,170 --> 00:28:31,049
you like me

00:28:26,100 --> 00:28:34,840
[Music]

00:28:31,049 --> 00:28:39,070
these benchmarks we tend to focus it in

00:28:34,840 --> 00:28:41,020
terms of performance the openmp

00:28:39,070 --> 00:28:43,510
validations with effort that we're

00:28:41,020 --> 00:28:45,880
starting as well with a different

00:28:43,510 --> 00:28:48,730
project is related more in terms of

00:28:45,880 --> 00:28:52,330
functionality so ideally would be

00:28:48,730 --> 00:28:54,820
hand-in-hand you know one with these

00:28:52,330 --> 00:28:56,920
different levels of testing one

00:28:54,820 --> 00:29:01,020
functional organs have more

00:28:56,920 --> 00:29:02,260
performance-oriented yes but we should

00:29:01,020 --> 00:29:04,540
yeah

00:29:02,260 --> 00:29:06,990
the more we can provide to the community

00:29:04,540 --> 00:29:06,990
the better

00:29:09,510 --> 00:29:11,960
I think

00:29:18,340 --> 00:29:20,970
right

00:29:23,500 --> 00:29:25,650
you

00:29:27,010 --> 00:29:31,780
as where you choose

00:29:29,350 --> 00:29:34,940
the value for

00:29:31,780 --> 00:29:34,940
[Music]

00:29:36,370 --> 00:29:42,190
because that member

00:29:39,440 --> 00:29:42,190
me Holly

00:29:42,290 --> 00:29:46,789
err

00:29:44,580 --> 00:29:50,809
correct

00:29:46,789 --> 00:29:55,039
yeah so for the base a benchmarks no but

00:29:50,809 --> 00:29:57,549
for the peak benchmark a yet that is

00:29:55,039 --> 00:29:57,549
possible

00:30:00,410 --> 00:30:06,179
[Music]

00:30:01,850 --> 00:30:08,860
yeah wondering this is a question you

00:30:06,179 --> 00:30:13,970
have a lot more experience

00:30:08,860 --> 00:30:17,340
one thing that separates me like

00:30:13,970 --> 00:30:22,650
only the difference really between like

00:30:17,340 --> 00:30:23,740
parallel do or so if we have a combined

00:30:22,650 --> 00:30:26,920
common across work

00:30:23,740 --> 00:30:26,920
[Music]

00:30:29,430 --> 00:30:33,380
reveal

00:30:31,220 --> 00:30:34,929
really clear with what he meant

00:30:33,380 --> 00:30:37,269
[Music]

00:30:34,929 --> 00:30:38,940
like I just kind of always product it

00:30:37,269 --> 00:30:41,550
like GQ thread

00:30:38,940 --> 00:30:44,730
that are there like criminal

00:30:41,550 --> 00:30:44,730
we have a

00:30:46,680 --> 00:30:50,130
[Music]

00:30:52,950 --> 00:30:56,550
where's that me actually

00:30:56,610 --> 00:31:05,850
yeah so this is a beautifully exchange

00:31:00,149 --> 00:31:09,029
and a operated programming model can be

00:31:05,850 --> 00:31:12,510
satisfied many ways right so as I am the

00:31:09,029 --> 00:31:15,120
can be implemented different using

00:31:12,510 --> 00:31:17,700
different strategies like mapping them

00:31:15,120 --> 00:31:22,049
to either warps or things like

00:31:17,700 --> 00:31:24,809
cooperating threads and vendors are

00:31:22,049 --> 00:31:29,309
still deciding what is the best strategy

00:31:24,809 --> 00:31:32,090
for for that and part of the part of the

00:31:29,309 --> 00:31:34,500
reasons for why we still come and get a

00:31:32,090 --> 00:31:37,289
yes yet the GP result is because

00:31:34,500 --> 00:31:40,250
compilers are getting to the point where

00:31:37,289 --> 00:31:44,789
they're deciding what was the best a

00:31:40,250 --> 00:31:49,350
optimization strategy for those a type

00:31:44,789 --> 00:31:52,669
of encode constructor on GPU

00:31:49,350 --> 00:31:52,669
the lasting

00:31:53,510 --> 00:31:58,040
Claire the programmers name

00:31:59,029 --> 00:32:05,899
when my vicinity basically same

00:32:05,960 --> 00:32:11,080
in the back okay so you could actually

00:32:08,740 --> 00:32:14,080
be operating

00:32:11,080 --> 00:32:19,120
laughs okay what could be faulty to say

00:32:14,080 --> 00:32:22,120
would you say delivery is in box tonight

00:32:19,120 --> 00:32:25,450
Lord by private plane and it's all flat

00:32:22,120 --> 00:32:30,010
so there is a situation where the

00:32:25,450 --> 00:32:36,929
beggars collector could be something did

00:32:30,010 --> 00:32:36,929
indeed labor not me the last light

00:32:40,540 --> 00:32:43,380
I would think

00:32:43,550 --> 00:32:46,930
yeah the cloud

00:32:51,049 --> 00:32:55,330
we've done we haven't we

00:33:00,059 --> 00:33:07,740
yeah yes I'm in the index combined

00:33:04,990 --> 00:33:07,740
constructor yes

00:33:12,510 --> 00:33:15,690
we do

00:33:16,100 --> 00:33:21,410
I knew look at the compiler the things

00:33:18,540 --> 00:33:21,410
that they say that

00:33:22,739 --> 00:33:38,340
yes yeah Luka Madison County digital

00:33:34,239 --> 00:33:49,840
parallel or sibling and any of these

00:33:38,340 --> 00:33:51,489
annotations with yeah so part of the so

00:33:49,840 --> 00:33:55,570
it's kind of like an optimization

00:33:51,489 --> 00:33:57,249
problem so we the goal of the compiled

00:33:55,570 --> 00:34:02,830
directive is to give as much flexibility

00:33:57,249 --> 00:34:04,629
to the to the compiler to pick how to

00:34:02,830 --> 00:34:08,950
implement the parallelism or the

00:34:04,629 --> 00:34:13,770
schedules in the in the loop nest but

00:34:08,950 --> 00:34:15,879
what we are we're seeing is like that

00:34:13,770 --> 00:34:17,589
you know there is no why would this

00:34:15,879 --> 00:34:20,440
place not exist is because the days are

00:34:17,589 --> 00:34:22,659
gonna look at them and then a they're

00:34:20,440 --> 00:34:26,020
going to influence their implementations

00:34:22,659 --> 00:34:31,299
for performance so cray we're gonna look

00:34:26,020 --> 00:34:33,190
at this and we'll make it go fast so the

00:34:31,299 --> 00:34:36,129
goal is here is part of the reason is

00:34:33,190 --> 00:34:38,349
yes the specification is good it's

00:34:36,129 --> 00:34:40,889
already good enough it just right now is

00:34:38,349 --> 00:34:44,950
what are the best strategies for

00:34:40,889 --> 00:34:47,149
performance while being performance

00:34:44,950 --> 00:34:51,999
portable architectures

00:34:47,149 --> 00:34:55,700
I think it was our goal to try the best

00:34:51,999 --> 00:34:57,740
practice very vague was really very

00:34:55,700 --> 00:35:00,940
objective

00:34:57,740 --> 00:35:00,940
but the one thing

00:35:02,750 --> 00:35:06,450
class grade because all these women

00:35:05,700 --> 00:35:11,190
constantly

00:35:06,450 --> 00:35:13,080
whereas when father was treated up to

00:35:11,190 --> 00:35:17,660
my crest

00:35:13,080 --> 00:35:20,730
so I said we want to do it a program

00:35:17,660 --> 00:35:24,770
descriptive is what parables available

00:35:20,730 --> 00:35:24,770
and making the pages deal with

00:35:28,190 --> 00:35:35,880
he uses indeed in some but the finial

00:35:33,860 --> 00:35:38,820
instrument a connection

00:35:35,880 --> 00:35:40,170
the parallel

00:35:38,820 --> 00:35:42,020
[Music]

00:35:40,170 --> 00:35:49,940
so

00:35:42,020 --> 00:35:51,850
really much traveling but the program is

00:35:49,940 --> 00:35:55,150
attractive

00:35:51,850 --> 00:35:59,180
[Music]

00:35:55,150 --> 00:36:00,290
yeah but yeah so for the Foreman's

00:35:59,180 --> 00:36:04,250
portability yes

00:36:00,290 --> 00:36:07,450
but the user the nice thing about OpenMP

00:36:04,250 --> 00:36:10,690
is like you can specify you can pull em

00:36:07,450 --> 00:36:14,740
if you want to pursue more

00:36:10,690 --> 00:36:14,740
platform-specific depression

00:36:20,900 --> 00:36:32,000
Erol Aslam process of recording button

00:36:27,700 --> 00:36:38,440
five times I mean it might be either but

00:36:32,000 --> 00:36:45,070
said mm like there is some method with

00:36:38,440 --> 00:36:58,160
or probabilities by flag on my

00:36:45,070 --> 00:37:01,940
architecture different again so yeah so

00:36:58,160 --> 00:37:04,010
that this depends on a program like if

00:37:01,940 --> 00:37:06,860
you're in a spec member or not or a

00:37:04,010 --> 00:37:10,490
stack user right so in your case your

00:37:06,860 --> 00:37:15,530
mistake member the organization suspect

00:37:10,490 --> 00:37:19,010
member so easily a we basically send it

00:37:15,530 --> 00:37:21,050
through we discuss them through what the

00:37:19,010 --> 00:37:23,440
organization's are reporting as a story

00:37:21,050 --> 00:37:23,440
Matic

00:37:25,120 --> 00:37:30,600
[Music]

00:37:27,830 --> 00:37:32,280
 me

00:37:30,600 --> 00:37:42,460
[Music]

00:37:32,280 --> 00:37:45,040
yeah in duplication yeah yes because we

00:37:42,460 --> 00:37:50,490
imagine that as we test these benchmarks

00:37:45,040 --> 00:37:53,290
across in multiple platforms we may a

00:37:50,490 --> 00:37:55,780
you know there may be some data we don't

00:37:53,290 --> 00:37:58,440
know we so far we did our best we could

00:37:55,780 --> 00:37:58,440

YouTube URL: https://www.youtube.com/watch?v=64NuyW3m-9Q


