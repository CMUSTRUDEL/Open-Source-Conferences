Title: OpenMP 5.1 Features: The Assume Construct
Publication date: 2020-11-12
Playlist: SC20 OpenMP Booth Talks
Description: 
	This presentation, delivered by Johannes Doerfert from the OpenMP language committee, is part of the OpenMP Booth Talk series created for Supercomputing 2020. A PDF of this presentation as well as more videos from this series can be downloaded at link.openmp.org/sc20
Captions: 
	00:00:02,639 --> 00:00:05,440
hello everyone

00:00:03,600 --> 00:00:06,960
my name is johannes derfud i work at

00:00:05,440 --> 00:00:10,320
argon national lab on

00:00:06,960 --> 00:00:12,240
the llvm compiler as well as the openp

00:00:10,320 --> 00:00:14,000
standard and the openmp implementation

00:00:12,240 --> 00:00:15,679
inside of llvm

00:00:14,000 --> 00:00:18,080
today i'm going to talk to you about the

00:00:15,679 --> 00:00:20,080
pragma um assume

00:00:18,080 --> 00:00:22,240
which has various spellings as you can

00:00:20,080 --> 00:00:25,359
already see here on the title slide

00:00:22,240 --> 00:00:27,920
and program assume is really about how

00:00:25,359 --> 00:00:31,439
you can talk to your compilers

00:00:27,920 --> 00:00:33,920
and it's it's motivation

00:00:31,439 --> 00:00:35,360
comes from the fact that sometimes you

00:00:33,920 --> 00:00:38,480
want to

00:00:35,360 --> 00:00:40,160
give your compiler more information more

00:00:38,480 --> 00:00:41,440
information than the base language

00:00:40,160 --> 00:00:44,640
allows you to do

00:00:41,440 --> 00:00:45,360
with let's say types so you want to you

00:00:44,640 --> 00:00:47,440
want to

00:00:45,360 --> 00:00:49,120
convey information to the compiler such

00:00:47,440 --> 00:00:49,760
that a compiler can do a better job for

00:00:49,120 --> 00:00:51,600
you

00:00:49,760 --> 00:00:53,840
and give you better code better

00:00:51,600 --> 00:00:57,520
performance better error messages

00:00:53,840 --> 00:00:59,760
and so on now if you look at

00:00:57,520 --> 00:01:01,280
what is currently available compilers

00:00:59,760 --> 00:01:04,400
have non-portable

00:01:01,280 --> 00:01:06,000
built-in assumes now if we look through

00:01:04,400 --> 00:01:07,680
the list of compilers that is kind of

00:01:06,000 --> 00:01:10,320
widely

00:01:07,680 --> 00:01:10,880
used msvc has an underscore underscore

00:01:10,320 --> 00:01:13,040
soon

00:01:10,880 --> 00:01:14,080
which takes an expression and at that

00:01:13,040 --> 00:01:15,759
program point

00:01:14,080 --> 00:01:18,240
um the compiler will assume that

00:01:15,759 --> 00:01:20,799
expression is true

00:01:18,240 --> 00:01:22,400
um gcc has a built-in assume aligned

00:01:20,799 --> 00:01:24,159
which takes an expression and an

00:01:22,400 --> 00:01:26,159
alignment and some other stuff

00:01:24,159 --> 00:01:28,080
and it will at that program point assume

00:01:26,159 --> 00:01:29,520
that expression has the alignment that

00:01:28,080 --> 00:01:31,360
you gave

00:01:29,520 --> 00:01:32,799
now you already see that they don't

00:01:31,360 --> 00:01:33,520
match and they have like different

00:01:32,799 --> 00:01:35,840
assumes

00:01:33,520 --> 00:01:36,720
um one one more generic one for

00:01:35,840 --> 00:01:39,759
alignment

00:01:36,720 --> 00:01:42,000
and clang kind of um bridges the gap

00:01:39,759 --> 00:01:43,119
and provides and assume for both of them

00:01:42,000 --> 00:01:45,200
like an assumer line

00:01:43,119 --> 00:01:47,520
and a built-in assume which kind of

00:01:45,200 --> 00:01:48,640
matches the msvc version but with a

00:01:47,520 --> 00:01:50,399
different spelling

00:01:48,640 --> 00:01:52,079
so now you have three compilers and you

00:01:50,399 --> 00:01:53,360
have three different situations which is

00:01:52,079 --> 00:01:55,360
obviously bad

00:01:53,360 --> 00:01:57,280
if you want to write portable code that

00:01:55,360 --> 00:01:58,960
can run on all of them

00:01:57,280 --> 00:02:01,119
and in addition also on some vendor

00:01:58,960 --> 00:02:03,600
compilers

00:02:01,119 --> 00:02:05,439
now the solution here is as with a lot

00:02:03,600 --> 00:02:07,600
of things standardization

00:02:05,439 --> 00:02:09,039
so what we want to do is we want to

00:02:07,600 --> 00:02:11,920
provide an

00:02:09,039 --> 00:02:12,640
uh standardized assumed directive in

00:02:11,920 --> 00:02:16,000
openmp

00:02:12,640 --> 00:02:19,040
and we did so for openmp51

00:02:16,000 --> 00:02:20,080
if you look at it you will encounter

00:02:19,040 --> 00:02:23,360
that it actually

00:02:20,080 --> 00:02:24,480
um expresses different kinds of

00:02:23,360 --> 00:02:27,040
properties

00:02:24,480 --> 00:02:27,840
the first one are low level properties

00:02:27,040 --> 00:02:29,440
which are

00:02:27,840 --> 00:02:31,680
basically like the built-in assumes

00:02:29,440 --> 00:02:34,239
we've seen it says

00:02:31,680 --> 00:02:36,080
when you write pragma on presume holds

00:02:34,239 --> 00:02:38,720
you can provide an expression

00:02:36,080 --> 00:02:42,000
that at that program point or in to be

00:02:38,720 --> 00:02:44,879
more precise in the scope of the assumes

00:02:42,000 --> 00:02:46,560
can uh has to evaluate to true so the

00:02:44,879 --> 00:02:50,000
compiler can assume

00:02:46,560 --> 00:02:51,599
that expression evaluates to true so

00:02:50,000 --> 00:02:53,920
this in contrast to the ones that we've

00:02:51,599 --> 00:02:55,840
seen before is portable

00:02:53,920 --> 00:02:57,200
the second thing you can do with the

00:02:55,840 --> 00:03:00,239
assumed directive is

00:02:57,200 --> 00:03:02,239
high level assumptions so you can

00:03:00,239 --> 00:03:04,000
give the compiler information that

00:03:02,239 --> 00:03:06,959
doesn't translate to a boolean

00:03:04,000 --> 00:03:07,760
value at least not easily so for example

00:03:06,959 --> 00:03:11,200
you can say

00:03:07,760 --> 00:03:13,920
graph assume no openmp and

00:03:11,200 --> 00:03:15,280
appsend and then a list of directives so

00:03:13,920 --> 00:03:17,200
which tells the compiler

00:03:15,280 --> 00:03:18,800
in the scope of this assume you're not

00:03:17,200 --> 00:03:21,920
using openmp

00:03:18,800 --> 00:03:24,400
or the absent directive tells it that um

00:03:21,920 --> 00:03:26,400
you're not going to use the the list of

00:03:24,400 --> 00:03:29,599
or the directives that you list there

00:03:26,400 --> 00:03:31,440
in the scope of the assume both of which

00:03:29,599 --> 00:03:35,120
can be used by the compiler

00:03:31,440 --> 00:03:37,680
to for example use a less heavy runtime

00:03:35,120 --> 00:03:38,239
or to provide better code optimization

00:03:37,680 --> 00:03:41,280
or

00:03:38,239 --> 00:03:43,440
better diagnostics

00:03:41,280 --> 00:03:44,319
finally there is a portable hook for

00:03:43,440 --> 00:03:46,959
extensions

00:03:44,319 --> 00:03:47,760
such that implementations can give you a

00:03:46,959 --> 00:03:50,000
way

00:03:47,760 --> 00:03:51,760
to communicate with them to like so the

00:03:50,000 --> 00:03:52,400
implementation can give you feedback

00:03:51,760 --> 00:03:54,640
about

00:03:52,400 --> 00:03:55,680
what they try to do and what it why why

00:03:54,640 --> 00:03:58,799
it failed

00:03:55,680 --> 00:03:59,519
and can tell you to provide additional

00:03:58,799 --> 00:04:01,920
information

00:03:59,519 --> 00:04:02,799
through these extension hooks so if you

00:04:01,920 --> 00:04:05,519
look at

00:04:02,799 --> 00:04:06,000
the syntax here it is pragma ombre zoom

00:04:05,519 --> 00:04:08,159
x

00:04:06,000 --> 00:04:10,480
underscore and then whatever

00:04:08,159 --> 00:04:13,200
implementation defines string

00:04:10,480 --> 00:04:15,760
you will you want to add all

00:04:13,200 --> 00:04:18,079
implementations will accept these

00:04:15,760 --> 00:04:20,000
but only the ones that are aware of what

00:04:18,079 --> 00:04:23,600
it means will actually act on them

00:04:20,000 --> 00:04:26,639
for the others it is a no up

00:04:23,600 --> 00:04:28,800
now um looking a little bit further i

00:04:26,639 --> 00:04:29,680
mentioned before i said the openmp

00:04:28,800 --> 00:04:32,479
assume

00:04:29,680 --> 00:04:32,800
scope now there are several spellings

00:04:32,479 --> 00:04:35,040
that

00:04:32,800 --> 00:04:37,280
have different scopes but every time

00:04:35,040 --> 00:04:40,639
when i talk about the scope

00:04:37,280 --> 00:04:43,520
the the affected code is

00:04:40,639 --> 00:04:44,080
transitive so everything inside the

00:04:43,520 --> 00:04:47,280
scope

00:04:44,080 --> 00:04:49,680
and reached from the scope

00:04:47,280 --> 00:04:51,360
now the first spelling is probably the

00:04:49,680 --> 00:04:54,080
easiest which is global scope

00:04:51,360 --> 00:04:56,080
it affects everything if you want so if

00:04:54,080 --> 00:04:59,919
you're on a global scope in your file

00:04:56,080 --> 00:05:02,400
scope say pragma assumes clause

00:04:59,919 --> 00:05:04,000
it affects the entire translation unit

00:05:02,400 --> 00:05:05,680
and everything that is reached from the

00:05:04,000 --> 00:05:07,120
translation unit

00:05:05,680 --> 00:05:09,280
the second spelling is a is a

00:05:07,120 --> 00:05:11,199
range-based spelling where the begin

00:05:09,280 --> 00:05:12,800
end as we have it for other directives

00:05:11,199 --> 00:05:14,800
as well

00:05:12,800 --> 00:05:16,639
in here the scope is all the

00:05:14,800 --> 00:05:17,759
declarations that are in between the

00:05:16,639 --> 00:05:21,199
begin and end

00:05:17,759 --> 00:05:24,080
and everything that you reach from them

00:05:21,199 --> 00:05:26,479
the third spelling is is on inside of a

00:05:24,080 --> 00:05:28,479
function so not on on file scope

00:05:26,479 --> 00:05:30,240
but inside of our function you can say

00:05:28,479 --> 00:05:32,479
pragma omp assume

00:05:30,240 --> 00:05:34,720
note the difference in spelling here

00:05:32,479 --> 00:05:36,639
fragment assume

00:05:34,720 --> 00:05:38,639
which takes a structured block like a

00:05:36,639 --> 00:05:40,800
lot of other directives

00:05:38,639 --> 00:05:41,919
and the assumptions that you provide

00:05:40,800 --> 00:05:44,639
through the clauses

00:05:41,919 --> 00:05:46,560
hold for the structured block so you

00:05:44,639 --> 00:05:49,280
have these three choices if you want to

00:05:46,560 --> 00:05:49,280
write the zooms

00:05:50,080 --> 00:05:54,880
they all have like a different scope but

00:05:52,240 --> 00:05:56,639
otherwise behave the same

00:05:54,880 --> 00:05:58,800
now let's look at some use cases so i

00:05:56,639 --> 00:06:00,080
prepare three use cases that we can talk

00:05:58,800 --> 00:06:02,319
through here

00:06:00,080 --> 00:06:03,600
and then and then some conclusions so

00:06:02,319 --> 00:06:06,560
the first one is

00:06:03,600 --> 00:06:08,160
like the most portable obvious one so

00:06:06,560 --> 00:06:11,440
you have a loop that just

00:06:08,160 --> 00:06:12,880
adds uh to like um adds an array to

00:06:11,440 --> 00:06:14,960
another one

00:06:12,880 --> 00:06:17,039
and what you want you want to force or

00:06:14,960 --> 00:06:18,960
like indicate to the compiler to

00:06:17,039 --> 00:06:22,000
vectorize because it's legal

00:06:18,960 --> 00:06:23,919
maybe to make sure that a compiler is

00:06:22,000 --> 00:06:26,960
aware there are no aliasing issues

00:06:23,919 --> 00:06:28,560
so you can say pragma um simply so far

00:06:26,960 --> 00:06:29,680
so good this is kind of what we had all

00:06:28,560 --> 00:06:32,479
the time

00:06:29,680 --> 00:06:33,600
now in the second step you can now say

00:06:32,479 --> 00:06:36,720
program assume

00:06:33,600 --> 00:06:39,520
holes n is divisible by 8 and n

00:06:36,720 --> 00:06:42,560
is bigger than 0. this is actually

00:06:39,520 --> 00:06:46,000
helpful because now the compiler can

00:06:42,560 --> 00:06:47,680
omit the remainder loop if we assume a

00:06:46,000 --> 00:06:50,720
vector factor of 8 or

00:06:47,680 --> 00:06:54,720
or some

00:06:50,720 --> 00:06:56,960
some number that is that divides 8

00:06:54,720 --> 00:06:58,720
because otherwise to compiler would have

00:06:56,960 --> 00:07:02,319
to check if n is bigger than 0

00:06:58,720 --> 00:07:03,919
and if n is a multiple of 8 and if not

00:07:02,319 --> 00:07:05,360
generate some additional kind of

00:07:03,919 --> 00:07:08,240
remainder code

00:07:05,360 --> 00:07:10,240
that handles the leftover iterations

00:07:08,240 --> 00:07:12,240
after your vectorized loop

00:07:10,240 --> 00:07:14,000
so and with this assumption that you can

00:07:12,240 --> 00:07:15,759
now write in a portable way

00:07:14,000 --> 00:07:18,160
those remainder loops are not necessary

00:07:15,759 --> 00:07:18,160
anymore

00:07:18,639 --> 00:07:22,160
the second one is implementations like

00:07:20,560 --> 00:07:23,360
the seven use cases implementation

00:07:22,160 --> 00:07:26,000
specific

00:07:23,360 --> 00:07:27,199
um let's assume we have a target teams

00:07:26,000 --> 00:07:28,639
region

00:07:27,199 --> 00:07:30,800
and inside the target team's region

00:07:28,639 --> 00:07:34,080
there is some c plus plus code

00:07:30,800 --> 00:07:36,000
and cpl's plus code by default can

00:07:34,080 --> 00:07:38,160
like every function there can

00:07:36,000 --> 00:07:39,840
conceptually throw

00:07:38,160 --> 00:07:42,479
like the compiler has to assume that a

00:07:39,840 --> 00:07:45,680
simple plus function throws an exception

00:07:42,479 --> 00:07:46,160
now obviously that is not the case for

00:07:45,680 --> 00:07:49,199
everything

00:07:46,160 --> 00:07:52,160
plus function in a little bit um

00:07:49,199 --> 00:07:54,160
more on the open v target side most

00:07:52,160 --> 00:07:56,000
compilers don't really support throwing

00:07:54,160 --> 00:07:58,240
an exception inside a target region and

00:07:56,000 --> 00:08:00,080
even if they once they will it is

00:07:58,240 --> 00:08:01,599
probably not the most performant thing

00:08:00,080 --> 00:08:04,879
to do

00:08:01,599 --> 00:08:06,720
now that said a lot of codes should will

00:08:04,879 --> 00:08:09,520
probably write their gpu code

00:08:06,720 --> 00:08:10,639
or their target code without exceptions

00:08:09,520 --> 00:08:13,039
so

00:08:10,639 --> 00:08:14,240
it's but however the compiler can't know

00:08:13,039 --> 00:08:15,759
that by default

00:08:14,240 --> 00:08:17,599
so it has to assume there might be

00:08:15,759 --> 00:08:19,599
exceptions thrown and it potentially

00:08:17,599 --> 00:08:22,800
pessimizes the code generation

00:08:19,599 --> 00:08:25,199
and optimizations so what you can do

00:08:22,800 --> 00:08:26,479
is as an example which is not

00:08:25,199 --> 00:08:29,759
implemented is just for

00:08:26,479 --> 00:08:32,000
for for illustrative purposes here

00:08:29,759 --> 00:08:33,039
you can tell your compiler through and

00:08:32,000 --> 00:08:35,360
assume

00:08:33,039 --> 00:08:38,000
that the inside of a target code there

00:08:35,360 --> 00:08:40,240
will mean no exceptions

00:08:38,000 --> 00:08:42,320
so there are other ways to to tell a

00:08:40,240 --> 00:08:45,040
compiler there are no exceptions but

00:08:42,320 --> 00:08:46,160
these assumes allow you to be more

00:08:45,040 --> 00:08:49,760
specific

00:08:46,160 --> 00:08:52,480
to provide more fine-grained or

00:08:49,760 --> 00:08:54,480
high-level assumptions that are not

00:08:52,480 --> 00:08:56,880
exposed by let's say command line

00:08:54,480 --> 00:08:56,880
options

00:08:57,200 --> 00:09:01,200
again there is no need for the compiler

00:08:59,200 --> 00:09:02,160
or you for that matter to prove the

00:09:01,200 --> 00:09:04,560
assumption

00:09:02,160 --> 00:09:06,560
but if you violate the assumption the

00:09:04,560 --> 00:09:08,640
behavior is undefined

00:09:06,560 --> 00:09:10,959
so don't violate the assumption and

00:09:08,640 --> 00:09:15,600
everything will be okay

00:09:10,959 --> 00:09:17,680
now as a third example here

00:09:15,600 --> 00:09:18,800
um let's look at a little bit more

00:09:17,680 --> 00:09:21,440
complicated one

00:09:18,800 --> 00:09:22,640
at least at least on first sight but it

00:09:21,440 --> 00:09:24,800
actually is not

00:09:22,640 --> 00:09:26,640
so let's assume we have an apartment on

00:09:24,800 --> 00:09:28,080
target teams and inside we call a

00:09:26,640 --> 00:09:29,760
function foo

00:09:28,080 --> 00:09:31,279
inside of that function foo we have a

00:09:29,760 --> 00:09:34,560
parallel region

00:09:31,279 --> 00:09:36,000
now this is a situation where a lot of

00:09:34,560 --> 00:09:39,040
compilers already for

00:09:36,000 --> 00:09:39,920
for openmp will generate sub-optimal

00:09:39,040 --> 00:09:41,760
code

00:09:39,920 --> 00:09:44,320
because this situation the handling this

00:09:41,760 --> 00:09:46,320
situation is actually not trivial

00:09:44,320 --> 00:09:48,560
um the one of the problems is that foo

00:09:46,320 --> 00:09:50,399
could be called from the outside so not

00:09:48,560 --> 00:09:50,880
only from the target region that you see

00:09:50,399 --> 00:09:52,800
here

00:09:50,880 --> 00:09:54,480
but from somewhere else potentially a

00:09:52,800 --> 00:09:56,880
different translation unit

00:09:54,480 --> 00:09:58,320
and inside of a target region there and

00:09:56,880 --> 00:10:00,080
the compiler doesn't know that

00:09:58,320 --> 00:10:01,920
and that actually makes a a big

00:10:00,080 --> 00:10:04,800
difference when it comes to

00:10:01,920 --> 00:10:06,720
code generation here now you could argue

00:10:04,800 --> 00:10:09,279
the compiler could inline this

00:10:06,720 --> 00:10:11,600
which is which is probably true but the

00:10:09,279 --> 00:10:13,920
the problem still remains like there are

00:10:11,600 --> 00:10:15,839
the uncertainties during compilation

00:10:13,920 --> 00:10:17,040
especially of single translation units

00:10:15,839 --> 00:10:19,600
that can't be worked

00:10:17,040 --> 00:10:20,800
that we cannot work around but what we

00:10:19,600 --> 00:10:23,839
can do is we can

00:10:20,800 --> 00:10:25,519
let the compiler give us information

00:10:23,839 --> 00:10:28,640
about these uncertainties

00:10:25,519 --> 00:10:29,040
so if you run clang on a new version of

00:10:28,640 --> 00:10:32,720
clang

00:10:29,040 --> 00:10:34,640
11 or newer preferably newer with minus

00:10:32,720 --> 00:10:37,680
our pass openmp

00:10:34,640 --> 00:10:38,800
and then your your regular options clang

00:10:37,680 --> 00:10:41,839
will emit

00:10:38,800 --> 00:10:42,800
remarks about the openmp optimizations

00:10:41,839 --> 00:10:46,079
that were happening

00:10:42,800 --> 00:10:47,519
or couldn't happen now in this remark

00:10:46,079 --> 00:10:49,839
this is an example like

00:10:47,519 --> 00:10:51,760
decline will actually emit a remark

00:10:49,839 --> 00:10:53,519
which looks similar but not exactly like

00:10:51,760 --> 00:10:55,839
this

00:10:53,519 --> 00:10:57,279
and the the marcus says okay we have

00:10:55,839 --> 00:11:00,000
this parallel region which is

00:10:57,279 --> 00:11:01,920
called which could be called from an

00:11:00,000 --> 00:11:04,240
external target region

00:11:01,920 --> 00:11:05,839
and that prevents us to from rewriting

00:11:04,240 --> 00:11:09,360
the state machine use

00:11:05,839 --> 00:11:13,440
so please use either the static keyword

00:11:09,360 --> 00:11:15,600
for foo or at an assume

00:11:13,440 --> 00:11:17,200
that tells us there are no external

00:11:15,600 --> 00:11:18,160
target regions calling this function

00:11:17,200 --> 00:11:20,720
full

00:11:18,160 --> 00:11:22,160
either case will allow us to optimize

00:11:20,720 --> 00:11:23,839
the state machine use

00:11:22,160 --> 00:11:25,519
which will probably give you better

00:11:23,839 --> 00:11:30,800
performance through

00:11:25,519 --> 00:11:33,839
due to less register usage on your gpu

00:11:30,800 --> 00:11:35,120
so this is actually um came up in real

00:11:33,839 --> 00:11:37,600
applications

00:11:35,120 --> 00:11:39,279
um like something like this and it gives

00:11:37,600 --> 00:11:41,040
you real performance or it can give you

00:11:39,279 --> 00:11:43,120
real performance benefits

00:11:41,040 --> 00:11:44,399
again this is just an illustrative

00:11:43,120 --> 00:11:48,000
example clang

00:11:44,399 --> 00:11:49,360
emits a message like this and advises to

00:11:48,000 --> 00:11:51,040
use the static linkage

00:11:49,360 --> 00:11:53,279
but we haven't implemented to assume yet

00:11:51,040 --> 00:11:55,279
we're actually working on that right now

00:11:53,279 --> 00:11:58,480
so once the assume is implemented a

00:11:55,279 --> 00:12:01,279
message like that will actually show up

00:11:58,480 --> 00:12:02,800
now talking about implementation in llvm

00:12:01,279 --> 00:12:05,440
incline

00:12:02,800 --> 00:12:07,360
we will support assuming version 12

00:12:05,440 --> 00:12:08,959
which is due in a few months

00:12:07,360 --> 00:12:10,560
on development branch will have it

00:12:08,959 --> 00:12:12,560
earlier than that so

00:12:10,560 --> 00:12:14,720
once you see this recording you'll

00:12:12,560 --> 00:12:16,959
probably be able to download clang

00:12:14,720 --> 00:12:18,720
with assume support or partial assume

00:12:16,959 --> 00:12:20,399
support

00:12:18,720 --> 00:12:22,399
in addition to that you should you

00:12:20,399 --> 00:12:23,040
should take a look at the llvm openmp

00:12:22,399 --> 00:12:24,880
advisor

00:12:23,040 --> 00:12:26,160
that will be distributed as part of the

00:12:24,880 --> 00:12:30,800
llvm

00:12:26,160 --> 00:12:34,160
repository which will help you to

00:12:30,800 --> 00:12:36,800
guide you towards the use of a zone

00:12:34,160 --> 00:12:37,680
so over time we will add more and more

00:12:36,800 --> 00:12:41,279
analyses

00:12:37,680 --> 00:12:42,160
in in remarks that will be summarized by

00:12:41,279 --> 00:12:44,959
the advisor

00:12:42,160 --> 00:12:46,480
and and kind of given to you in a in a

00:12:44,959 --> 00:12:49,519
more

00:12:46,480 --> 00:12:51,920
um digestible format so

00:12:49,519 --> 00:12:53,279
while you can look at the remarks as we

00:12:51,920 --> 00:12:55,440
have as we've shown

00:12:53,279 --> 00:12:56,880
there are other use cases where remarks

00:12:55,440 --> 00:12:57,360
are not sufficient and that is where the

00:12:56,880 --> 00:13:00,560
other

00:12:57,360 --> 00:13:02,880
openmp advisor comes in it will also be

00:13:00,560 --> 00:13:03,920
allow you to kind of have a single

00:13:02,880 --> 00:13:07,200
interface

00:13:03,920 --> 00:13:09,040
to deal with all of this and really get

00:13:07,200 --> 00:13:11,360
information about your openmp code and

00:13:09,040 --> 00:13:14,320
how to improve it

00:13:11,360 --> 00:13:16,240
finally there is this new openmp

00:13:14,320 --> 00:13:18,079
documentation page for llvm

00:13:16,240 --> 00:13:19,839
which you should visit it's under

00:13:18,079 --> 00:13:21,920
construction right now but we're adding

00:13:19,839 --> 00:13:23,600
content as we speak

00:13:21,920 --> 00:13:25,040
there will be information about

00:13:23,600 --> 00:13:27,360
implementation status

00:13:25,040 --> 00:13:28,880
extensions for assume but also other

00:13:27,360 --> 00:13:32,240
extensions

00:13:28,880 --> 00:13:35,120
use cases remarks explanations for those

00:13:32,240 --> 00:13:36,959
and so on and so forth um so please

00:13:35,120 --> 00:13:38,880
visit the documentation page

00:13:36,959 --> 00:13:40,639
and as always if any of this sounded

00:13:38,880 --> 00:13:43,600
interesting if you want to know more

00:13:40,639 --> 00:13:45,680
collaborate feel free to reach out to me

00:13:43,600 --> 00:13:47,120
we are also available through the openmp

00:13:45,680 --> 00:13:50,160
dev list

00:13:47,120 --> 00:13:52,079
at the lfm mailing list

00:13:50,160 --> 00:13:54,320
directly to me through that list or

00:13:52,079 --> 00:13:56,639
through any other channel

00:13:54,320 --> 00:13:58,959
we're happy to get feedback we're happy

00:13:56,639 --> 00:14:00,720
to get collaborations up and running to

00:13:58,959 --> 00:14:02,800
look into different new optimizations

00:14:00,720 --> 00:14:17,120
and uses for assume

00:14:02,800 --> 00:14:19,199
and i hope you liked it thank you

00:14:17,120 --> 00:14:19,199

YouTube URL: https://www.youtube.com/watch?v=XZtPTSjPB6Q


