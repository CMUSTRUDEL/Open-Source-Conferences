Title: SOLLVE OpenMP Validation and Verification Effort
Publication date: 2020-10-29
Playlist: SC20 OpenMP Booth Talks
Description: 
	This presentation, delivered by Swaroop Pophale of Oak Ridge National Laboratory, is part of the OpenMP Booth Talk series created for Supercomputing 2020. 

A PDF of this presentation as well as more videos from this series can be downloaded at https://www.openmp.org/events/openmp-sc20/
Captions: 
	00:00:03,840 --> 00:00:07,919
welcome to the openmp

00:00:05,440 --> 00:00:09,040
uh sc boot talk series this talk is

00:00:07,919 --> 00:00:11,440
going to be about the

00:00:09,040 --> 00:00:12,240
solve openmp validation and verification

00:00:11,440 --> 00:00:14,880
suite

00:00:12,240 --> 00:00:16,160
i am svaruplay from oakridge national

00:00:14,880 --> 00:00:19,600
lab i'm a computer

00:00:16,160 --> 00:00:19,600
computational scientist here

00:00:20,880 --> 00:00:23,920
to introduce the team we are doing this

00:00:23,519 --> 00:00:25,840
work

00:00:23,920 --> 00:00:27,519
under the ecp solve project in

00:00:25,840 --> 00:00:28,320
collaboration with the university of

00:00:27,519 --> 00:00:30,000
delaware

00:00:28,320 --> 00:00:32,719
and our current team members on the

00:00:30,000 --> 00:00:35,120
oprah's side are uh david bernholt

00:00:32,719 --> 00:00:37,680
and myself and on the university of

00:00:35,120 --> 00:00:41,680
delaware we have josh davis thomas uber

00:00:37,680 --> 00:00:41,680
and their professor sunita chandrasekhar

00:00:42,000 --> 00:00:45,600
so uh the outline of my talk i'm going

00:00:44,640 --> 00:00:48,640
to introduce

00:00:45,600 --> 00:00:49,760
what the solve ecp project is about very

00:00:48,640 --> 00:00:51,920
briefly

00:00:49,760 --> 00:00:52,960
and the scope and the intent of this

00:00:51,920 --> 00:00:54,719
particular work

00:00:52,960 --> 00:00:56,079
of this validation and verification

00:00:54,719 --> 00:00:59,920
suite um

00:00:56,079 --> 00:01:02,640
then a little bit about how openmp has

00:00:59,920 --> 00:01:05,600
evolved to an offloading machine model

00:01:02,640 --> 00:01:07,600
and what are the new features in 5.0

00:01:05,600 --> 00:01:09,680
that are uh interesting the main

00:01:07,600 --> 00:01:11,760
features then we will look uh

00:01:09,680 --> 00:01:13,040
at the details of the validation

00:01:11,760 --> 00:01:16,000
verification suite

00:01:13,040 --> 00:01:16,799
the test design process a few examples

00:01:16,000 --> 00:01:17,840
that we

00:01:16,799 --> 00:01:20,400
thought were interesting while

00:01:17,840 --> 00:01:22,320
developing this suite and

00:01:20,400 --> 00:01:24,080
a little bit about the infrastructure

00:01:22,320 --> 00:01:26,560
design we have some

00:01:24,080 --> 00:01:29,119
sample results from our runs on ecp

00:01:26,560 --> 00:01:31,680
relevant platforms like summit and corey

00:01:29,119 --> 00:01:32,240
and some success stories to share and

00:01:31,680 --> 00:01:35,200
also

00:01:32,240 --> 00:01:37,520
uh we want to engage with vendors

00:01:35,200 --> 00:01:40,560
collaborators other universities

00:01:37,520 --> 00:01:43,840
and help them as well as make this a

00:01:40,560 --> 00:01:47,520
suite better so the

00:01:43,840 --> 00:01:48,560
solve ecp project is basically enhancing

00:01:47,520 --> 00:01:52,240
the llbm

00:01:48,560 --> 00:01:54,960
compiler the compiler the runtime

00:01:52,240 --> 00:01:57,280
as well as provide the latest and

00:01:54,960 --> 00:02:00,000
greatest features of openmp

00:01:57,280 --> 00:02:02,159
so we start at adding those features

00:02:00,000 --> 00:02:03,360
into the specification and following

00:02:02,159 --> 00:02:05,360
them up with high quality

00:02:03,360 --> 00:02:07,200
implementations as well as

00:02:05,360 --> 00:02:09,280
validating those implementations and

00:02:07,200 --> 00:02:11,280
today today's talk we're going to

00:02:09,280 --> 00:02:13,599
specifically focus on the validation

00:02:11,280 --> 00:02:13,599
part

00:02:14,319 --> 00:02:20,959
so what is the intent and

00:02:17,520 --> 00:02:23,200
why did we want to build this vnp

00:02:20,959 --> 00:02:25,520
firstly we want to verify the status of

00:02:23,200 --> 00:02:26,640
the openmp implementations across ecb

00:02:25,520 --> 00:02:30,560
platforms

00:02:26,640 --> 00:02:32,800
although uh the 4.5 and the 5.0 spec

00:02:30,560 --> 00:02:34,319
have been around for a while 5.0 came

00:02:32,800 --> 00:02:37,440
back in 2018

00:02:34,319 --> 00:02:40,239
till date we don't have complete uh

00:02:37,440 --> 00:02:42,480
implementations of the same so when

00:02:40,239 --> 00:02:43,440
application developers are trying to

00:02:42,480 --> 00:02:45,760
incorporate

00:02:43,440 --> 00:02:47,360
openmp specifically because it is

00:02:45,760 --> 00:02:50,560
portable and uh

00:02:47,360 --> 00:02:52,319
extremely widely available

00:02:50,560 --> 00:02:54,000
they want to know what features are

00:02:52,319 --> 00:02:57,440
available how they can

00:02:54,000 --> 00:02:59,440
change their applications to meet the

00:02:57,440 --> 00:03:00,560
changing hardware and the facilities

00:02:59,440 --> 00:03:03,440
available so

00:03:00,560 --> 00:03:04,000
this gives them a good idea of what is

00:03:03,440 --> 00:03:06,000
available

00:03:04,000 --> 00:03:07,680
on a particular platform or with a

00:03:06,000 --> 00:03:10,000
particular implementation

00:03:07,680 --> 00:03:11,120
we also want to evaluate the openmp

00:03:10,000 --> 00:03:12,959
functionality

00:03:11,120 --> 00:03:15,040
and performance and target architecture

00:03:12,959 --> 00:03:17,680
so a performance

00:03:15,040 --> 00:03:18,959
we don't focus so much in this talk

00:03:17,680 --> 00:03:21,280
because it's a completely

00:03:18,959 --> 00:03:22,400
it's kind of orthogonal to what we uh

00:03:21,280 --> 00:03:24,720
the vnb

00:03:22,400 --> 00:03:25,840
is focusing on but that is an aspect we

00:03:24,720 --> 00:03:28,480
are keeping in mind

00:03:25,840 --> 00:03:29,280
we want to see that uh firstly the

00:03:28,480 --> 00:03:31,120
functionality

00:03:29,280 --> 00:03:32,879
it gives the correct results if a

00:03:31,120 --> 00:03:34,400
directive is implemented a clause is

00:03:32,879 --> 00:03:36,560
implemented it is doing

00:03:34,400 --> 00:03:38,080
what it is supposed to do according to

00:03:36,560 --> 00:03:40,239
the specification

00:03:38,080 --> 00:03:41,760
we also want to check uh the

00:03:40,239 --> 00:03:44,799
implementations perform

00:03:41,760 --> 00:03:48,959
a conformance to the openmp standard and

00:03:44,799 --> 00:03:51,920
we want to help applications um

00:03:48,959 --> 00:03:53,120
test their particular motif or the way

00:03:51,920 --> 00:03:56,239
of using openmp

00:03:53,120 --> 00:03:58,560
before they deploy it on these big

00:03:56,239 --> 00:04:00,560
supercomputers so they can potentially

00:03:58,560 --> 00:04:00,879
test small parts of their applications

00:04:00,560 --> 00:04:04,080
through

00:04:00,879 --> 00:04:07,519
our tests and see how they perform or

00:04:04,080 --> 00:04:09,040
if they are supported so basically

00:04:07,519 --> 00:04:10,959
at the end of the day we want to verify

00:04:09,040 --> 00:04:13,439
the platforms are ready for the openmp

00:04:10,959 --> 00:04:16,880
applications

00:04:13,439 --> 00:04:20,160
so starting with the

00:04:16,880 --> 00:04:22,800
openmp 4.0 openmp moved

00:04:20,160 --> 00:04:23,759
to a more off-loading model when

00:04:22,800 --> 00:04:25,600
offloading

00:04:23,759 --> 00:04:26,880
when i say offloading it basically means

00:04:25,600 --> 00:04:29,759
that the computation

00:04:26,880 --> 00:04:30,720
is along with the data is backed up sent

00:04:29,759 --> 00:04:33,919
over the network

00:04:30,720 --> 00:04:36,160
to a device where it computes

00:04:33,919 --> 00:04:38,080
and then the result of the computation

00:04:36,160 --> 00:04:40,639
is copied back to the host

00:04:38,080 --> 00:04:44,240
now this was very very different from

00:04:40,639 --> 00:04:46,479
what we had before the 4.0 specification

00:04:44,240 --> 00:04:48,560
and this was mainly supported through a

00:04:46,479 --> 00:04:52,160
new directive called target

00:04:48,560 --> 00:04:54,479
and from there on were the support for

00:04:52,160 --> 00:04:58,240
different

00:04:54,479 --> 00:05:01,440
um different device constructs has been

00:04:58,240 --> 00:05:05,039
uh built into four point uh

00:05:01,440 --> 00:05:07,840
oh and beyond so and this is what we

00:05:05,039 --> 00:05:09,440
started with what is different in 4.5

00:05:07,840 --> 00:05:12,240
that we need to test

00:05:09,440 --> 00:05:13,039
to give the applications confidence that

00:05:12,240 --> 00:05:15,360
they can use

00:05:13,039 --> 00:05:17,919
a particular platform and implementation

00:05:15,360 --> 00:05:21,600
combination

00:05:17,919 --> 00:05:24,960
so now we are at 5.0

00:05:21,600 --> 00:05:26,880
and 5.1 will be released soon

00:05:24,960 --> 00:05:28,560
so what is so different so some of the

00:05:26,880 --> 00:05:29,680
important features that are different in

00:05:28,560 --> 00:05:31,759
5.0

00:05:29,680 --> 00:05:33,680
are the introduce introduction of

00:05:31,759 --> 00:05:37,199
context metadirectives

00:05:33,680 --> 00:05:39,520
and declare variants um additionally

00:05:37,199 --> 00:05:42,240
the requires directive this this this is

00:05:39,520 --> 00:05:45,440
a huge change coming from the 4.5

00:05:42,240 --> 00:05:46,720
way of doing things where uh there was

00:05:45,440 --> 00:05:49,759
no support for

00:05:46,720 --> 00:05:51,440
unified memory we one could not query

00:05:49,759 --> 00:05:52,960
or find out if they were working on a

00:05:51,440 --> 00:05:56,720
unified memory

00:05:52,960 --> 00:05:59,199
machine which basically means that if

00:05:56,720 --> 00:06:00,000
if you made in unified memory if you

00:05:59,199 --> 00:06:01,680
make change

00:06:00,000 --> 00:06:04,000
either on the host or the target it is

00:06:01,680 --> 00:06:06,639
to the same memory location

00:06:04,000 --> 00:06:07,600
and since uh there are specific

00:06:06,639 --> 00:06:10,880
semantics of

00:06:07,600 --> 00:06:11,840
moving data in uh 4.5 you could not

00:06:10,880 --> 00:06:14,880
really verify

00:06:11,840 --> 00:06:16,960
that uh if it is unified memory

00:06:14,880 --> 00:06:19,280
some part of the work is already done so

00:06:16,960 --> 00:06:21,440
you would not be wasting time

00:06:19,280 --> 00:06:22,800
trying to move data so this is very

00:06:21,440 --> 00:06:25,520
important

00:06:22,800 --> 00:06:26,160
uh in in for the performance aspect of

00:06:25,520 --> 00:06:28,240
things

00:06:26,160 --> 00:06:30,319
we have memory allocators and support

00:06:28,240 --> 00:06:33,199
for deep memory hierarchies

00:06:30,319 --> 00:06:34,160
uh deep copy in the sense a structure

00:06:33,199 --> 00:06:37,520
that contains

00:06:34,160 --> 00:06:39,520
different elements we did till 4.5 we

00:06:37,520 --> 00:06:41,919
did not have the ability of

00:06:39,520 --> 00:06:43,759
copying those when you just wanted to

00:06:41,919 --> 00:06:46,880
copy the structure you had to

00:06:43,759 --> 00:06:49,199
go in and manually do the

00:06:46,880 --> 00:06:51,599
movement of data now we have a

00:06:49,199 --> 00:06:51,840
descriptive loop constructs which which

00:06:51,599 --> 00:06:54,880
is

00:06:51,840 --> 00:06:56,319
semantic sugar but it makes the writing

00:06:54,880 --> 00:06:58,880
of a loop um

00:06:56,319 --> 00:06:59,520
that much more concise and precise and

00:06:58,880 --> 00:07:02,560
acquires

00:06:59,520 --> 00:07:03,599
uh release acquire semantics and uh the

00:07:02,560 --> 00:07:07,360
first ompt

00:07:03,599 --> 00:07:10,240
and third ompd uh

00:07:07,360 --> 00:07:12,639
third-party tool supports so there is

00:07:10,240 --> 00:07:16,080
completed support for fortran

00:07:12,639 --> 00:07:19,120
2003 and added support for fortran 2008

00:07:16,080 --> 00:07:22,479
c11 c c plus plus 11 and

00:07:19,120 --> 00:07:24,639
the 14 and the 17 variants so now

00:07:22,479 --> 00:07:26,240
looking at our uh validation and

00:07:24,639 --> 00:07:27,759
verification to stress

00:07:26,240 --> 00:07:29,440
test suite i would like to talk about

00:07:27,759 --> 00:07:32,319
the design process

00:07:29,440 --> 00:07:33,919
so if we go through the design process

00:07:32,319 --> 00:07:37,360
there are three possible

00:07:33,919 --> 00:07:39,440
positive outcomes uh first what we do is

00:07:37,360 --> 00:07:41,039
we are looking at the specification we

00:07:39,440 --> 00:07:44,319
are looking at analyzing the

00:07:41,039 --> 00:07:44,720
directive or an ecp application and from

00:07:44,319 --> 00:07:47,440
there

00:07:44,720 --> 00:07:49,599
we will write a test for the directive

00:07:47,440 --> 00:07:52,960
we try to make our functionality test

00:07:49,599 --> 00:07:56,479
as concise and precise as possible

00:07:52,960 --> 00:07:58,240
uh or try to extract the kernel from an

00:07:56,479 --> 00:08:00,080
ecb application

00:07:58,240 --> 00:08:01,840
for for that matter any application that

00:08:00,080 --> 00:08:05,759
uh comes to us

00:08:01,840 --> 00:08:09,520
so that we can uh show the critical

00:08:05,759 --> 00:08:12,879
openmp features that need to be tested

00:08:09,520 --> 00:08:14,639
then we have a in-house discussion about

00:08:12,879 --> 00:08:18,160
the validity of the test after we

00:08:14,639 --> 00:08:18,879
of make it sometimes we we discover that

00:08:18,160 --> 00:08:20,479
some

00:08:18,879 --> 00:08:22,000
in some obscure part of the

00:08:20,479 --> 00:08:24,639
specification there are some

00:08:22,000 --> 00:08:26,000
constraints that invalidate the test if

00:08:24,639 --> 00:08:28,800
then we go back and

00:08:26,000 --> 00:08:29,280
reiterate over the test if it is a valid

00:08:28,800 --> 00:08:31,440
test

00:08:29,280 --> 00:08:32,320
then we uh if there is an implementation

00:08:31,440 --> 00:08:34,800
available

00:08:32,320 --> 00:08:35,919
we go ahead and test it sometimes we

00:08:34,800 --> 00:08:38,320
have found out that

00:08:35,919 --> 00:08:39,039
our understanding of the specification

00:08:38,320 --> 00:08:41,680
has been

00:08:39,039 --> 00:08:43,279
uh flawed because of the wordings used

00:08:41,680 --> 00:08:46,000
or how it is phrased

00:08:43,279 --> 00:08:48,320
this is a positive outcome because we

00:08:46,000 --> 00:08:50,480
can take this issue to the specification

00:08:48,320 --> 00:08:53,920
uh bring it to the openmp specification

00:08:50,480 --> 00:08:54,800
discussion and get those corrections in

00:08:53,920 --> 00:08:56,560
if not

00:08:54,800 --> 00:08:58,480
our test is correct we have understood

00:08:56,560 --> 00:09:00,240
it correctly but the implementation is

00:08:58,480 --> 00:09:01,440
giving us wrong results that means it's

00:09:00,240 --> 00:09:04,560
an implementation bug

00:09:01,440 --> 00:09:08,080
and we file a report with the vendor

00:09:04,560 --> 00:09:11,120
and through this precise process

00:09:08,080 --> 00:09:14,160
many vendor bugs have been resolved

00:09:11,120 --> 00:09:15,920
so once we have a pass

00:09:14,160 --> 00:09:17,440
we open it up for review for the

00:09:15,920 --> 00:09:20,160
community um

00:09:17,440 --> 00:09:23,760
and then once the test is accepted we

00:09:20,160 --> 00:09:26,080
add it to our vmp suite

00:09:23,760 --> 00:09:27,519
so uh what are some of the examples that

00:09:26,080 --> 00:09:29,839
we have seen which have been interesting

00:09:27,519 --> 00:09:32,000
while developing this uh vnv

00:09:29,839 --> 00:09:33,920
so the first example is about

00:09:32,000 --> 00:09:36,240
understanding the specification

00:09:33,920 --> 00:09:38,560
now here is a code snippet the first box

00:09:36,240 --> 00:09:41,920
uh we are trying to map

00:09:38,560 --> 00:09:44,080
uh an array a the whole array and in the

00:09:41,920 --> 00:09:46,560
second example everything same

00:09:44,080 --> 00:09:47,920
but we are only trying to map half the

00:09:46,560 --> 00:09:51,680
array

00:09:47,920 --> 00:09:53,839
now these are nested pragmas and they

00:09:51,680 --> 00:09:55,040
both specify a data mapping over the

00:09:53,839 --> 00:09:57,839
array section

00:09:55,040 --> 00:09:59,760
the only difference being that the in

00:09:57,839 --> 00:10:00,720
the top part the entire array is mapped

00:09:59,760 --> 00:10:02,240
and the second

00:10:00,720 --> 00:10:05,279
only a portion of the area has been

00:10:02,240 --> 00:10:07,279
mapped what we found out was

00:10:05,279 --> 00:10:09,279
the first one works the second one does

00:10:07,279 --> 00:10:11,360
not

00:10:09,279 --> 00:10:13,519
why is that because the specification

00:10:11,360 --> 00:10:15,440
does not explicitly mention this

00:10:13,519 --> 00:10:18,880
requirement but it is an

00:10:15,440 --> 00:10:21,200
implicit uh assumption

00:10:18,880 --> 00:10:23,279
from the different interactions of the

00:10:21,200 --> 00:10:24,560
of different parts of the specification

00:10:23,279 --> 00:10:28,000
that there is

00:10:24,560 --> 00:10:31,519
already going to be a data map of the

00:10:28,000 --> 00:10:34,720
entire area and once you try to do a sub

00:10:31,519 --> 00:10:36,320
array it says that oh that's a problem

00:10:34,720 --> 00:10:39,120
because you're trying to map something

00:10:36,320 --> 00:10:40,399
um half of something that is already

00:10:39,120 --> 00:10:43,279
mapped

00:10:40,399 --> 00:10:45,600
so well and we found that there were

00:10:43,279 --> 00:10:48,720
different interpretations of this pack

00:10:45,600 --> 00:10:51,839
by uh different vendors so

00:10:48,720 --> 00:10:52,800
a simple fix is by adding a map analog

00:10:51,839 --> 00:10:57,279
to the inner

00:10:52,800 --> 00:10:59,920
distribute pragma uh this

00:10:57,279 --> 00:11:02,399
so the excel compiler we found out on

00:10:59,920 --> 00:11:04,240
the ibm excel compiler and summit

00:11:02,399 --> 00:11:06,560
runs this code there's no complaint but

00:11:04,240 --> 00:11:09,920
clang uh

00:11:06,560 --> 00:11:12,079
gives a compiling a time error right gcc

00:11:09,920 --> 00:11:14,640
gave us a runtime error so it's

00:11:12,079 --> 00:11:15,200
it's a mixed bag up there and to make

00:11:14,640 --> 00:11:18,240
things

00:11:15,200 --> 00:11:19,200
clear we interact with the vendors to uh

00:11:18,240 --> 00:11:23,279
get uniform

00:11:19,200 --> 00:11:25,120
behavior of omp so in the second example

00:11:23,279 --> 00:11:26,880
what we found out is the specification

00:11:25,120 --> 00:11:30,160
was not very clear

00:11:26,880 --> 00:11:32,480
so uh look at the

00:11:30,160 --> 00:11:33,440
two code examples there in the first one

00:11:32,480 --> 00:11:38,079
we have the

00:11:33,440 --> 00:11:42,000
variable share in in the shared clause

00:11:38,079 --> 00:11:44,800
and we try to map this to and from

00:11:42,000 --> 00:11:46,640
the device now these are two a very

00:11:44,800 --> 00:11:47,440
different concept mapping is the data

00:11:46,640 --> 00:11:50,320
movement

00:11:47,440 --> 00:11:50,880
and share shared is basically telling

00:11:50,320 --> 00:11:54,639
you

00:11:50,880 --> 00:11:57,279
how how the variable can be accessed

00:11:54,639 --> 00:11:58,399
but this is not allowed according to the

00:11:57,279 --> 00:12:01,360
specification

00:11:58,399 --> 00:12:02,800
so we had to find a different way of

00:12:01,360 --> 00:12:06,000
making this possible

00:12:02,800 --> 00:12:07,360
and one workaround that we found was to

00:12:06,000 --> 00:12:10,560
use default map

00:12:07,360 --> 00:12:11,040
and for scalars if you do to from that

00:12:10,560 --> 00:12:14,399
means

00:12:11,040 --> 00:12:16,959
share would be mapped to from and would

00:12:14,399 --> 00:12:18,880
also call uh can be used in the shared

00:12:16,959 --> 00:12:22,720
clause

00:12:18,880 --> 00:12:25,040
so these uh simple tricks uh and uh

00:12:22,720 --> 00:12:26,959
things we discover to make code work can

00:12:25,040 --> 00:12:29,600
be useful for people who are looking at

00:12:26,959 --> 00:12:34,160
the bnb just not for the validation part

00:12:29,600 --> 00:12:38,000
but to know how to use these clauses

00:12:34,160 --> 00:12:40,079
so a third test that we um

00:12:38,000 --> 00:12:42,240
took from an application the application

00:12:40,079 --> 00:12:45,040
is many many thousands of lines

00:12:42,240 --> 00:12:46,320
but uh this is a simple code snippet

00:12:45,040 --> 00:12:49,120
which basically

00:12:46,320 --> 00:12:50,560
checks for the uh if the no weight

00:12:49,120 --> 00:12:54,480
functionality

00:12:50,560 --> 00:12:58,480
on the implicit task

00:12:54,480 --> 00:13:01,519
works so in the first part uh

00:12:58,480 --> 00:13:04,639
the target map it's an implica

00:13:01,519 --> 00:13:06,720
creates an implicit task and

00:13:04,639 --> 00:13:08,800
the purpose of this test is to have the

00:13:06,720 --> 00:13:09,200
implicit task generated by target no

00:13:08,800 --> 00:13:13,200
weight

00:13:09,200 --> 00:13:16,959
go uh asynchronously first and then

00:13:13,200 --> 00:13:20,320
the explicit task would be differed

00:13:16,959 --> 00:13:23,920
until the um implicit task

00:13:20,320 --> 00:13:25,680
completes because of the depend clause

00:13:23,920 --> 00:13:28,639
on a

00:13:25,680 --> 00:13:30,079
now you have to be careful that at the

00:13:28,639 --> 00:13:32,639
end of these tasks

00:13:30,079 --> 00:13:34,800
since the first one can happen anytime

00:13:32,639 --> 00:13:37,839
but it has to happen before the second

00:13:34,800 --> 00:13:40,959
task um you have to use the pr

00:13:37,839 --> 00:13:44,480
pragma omp task weight and

00:13:40,959 --> 00:13:45,360
using this test we found out that one of

00:13:44,480 --> 00:13:47,920
the

00:13:45,360 --> 00:13:49,199
compilers was not had not implemented no

00:13:47,920 --> 00:13:50,959
weight correctly

00:13:49,199 --> 00:13:53,279
and these are small things that help the

00:13:50,959 --> 00:13:55,279
applications when they are going towards

00:13:53,279 --> 00:13:57,600
full scale runs

00:13:55,279 --> 00:13:59,360
now let's talk a little bit about the

00:13:57,600 --> 00:14:02,480
validation and verification suite

00:13:59,360 --> 00:14:05,839
infrastructure design so it's

00:14:02,480 --> 00:14:06,320
a it's very simple it's based on make

00:14:05,839 --> 00:14:10,399
file

00:14:06,320 --> 00:14:12,639
and scripts we have our own header file

00:14:10,399 --> 00:14:14,639
it's uh if anyone wanted to just write a

00:14:12,639 --> 00:14:17,040
test case it would be

00:14:14,639 --> 00:14:18,240
extremely simple just you have to add a

00:14:17,040 --> 00:14:21,440
header file in the

00:14:18,240 --> 00:14:24,160
at the top and uh we provide some macros

00:14:21,440 --> 00:14:26,639
that make reporting very very easy

00:14:24,160 --> 00:14:27,760
so the design parameters we have made it

00:14:26,639 --> 00:14:30,560
uh as

00:14:27,760 --> 00:14:31,920
portable it is portable and it can use

00:14:30,560 --> 00:14:32,800
different compilers and different

00:14:31,920 --> 00:14:36,240
systems

00:14:32,800 --> 00:14:36,240
we usually provide

00:14:37,120 --> 00:14:40,320
dev files for the different known

00:14:39,279 --> 00:14:42,240
systems

00:14:40,320 --> 00:14:43,440
and looking at one of the dev files you

00:14:42,240 --> 00:14:45,839
can easily create

00:14:43,440 --> 00:14:47,680
one for your own system so that the make

00:14:45,839 --> 00:14:49,120
script automatically picks it up and

00:14:47,680 --> 00:14:51,360
supports your system

00:14:49,120 --> 00:14:52,240
so this allows for fast addition of

00:14:51,360 --> 00:14:54,720
tests

00:14:52,240 --> 00:14:55,760
and uh giving different options to the

00:14:54,720 --> 00:14:57,839
make can divide

00:14:55,760 --> 00:14:59,920
divide your compilation and execution

00:14:57,839 --> 00:15:04,079
phases and once you set

00:14:59,920 --> 00:15:05,760
up verbose and uh if you want you can

00:15:04,079 --> 00:15:09,120
create log files as well

00:15:05,760 --> 00:15:12,639
for uh um you know looking at it or

00:15:09,120 --> 00:15:14,959
going through it at a later date

00:15:12,639 --> 00:15:16,240
now this is what the actual folder

00:15:14,959 --> 00:15:19,519
structure of the vnb

00:15:16,240 --> 00:15:19,920
looks like so we have the tests which

00:15:19,519 --> 00:15:22,000
are

00:15:19,920 --> 00:15:25,040
divided by the specification number the

00:15:22,000 --> 00:15:27,920
4.5 corresponds to the openmp 4.5

00:15:25,040 --> 00:15:30,480
specification and henceforth and all of

00:15:27,920 --> 00:15:31,519
them have a separate directory for each

00:15:30,480 --> 00:15:34,639
of the new

00:15:31,519 --> 00:15:37,680
uh directive and

00:15:34,639 --> 00:15:38,959
within there we will we will have test

00:15:37,680 --> 00:15:41,040
cases that cover

00:15:38,959 --> 00:15:42,000
most of the common usages application

00:15:41,040 --> 00:15:45,199
usages

00:15:42,000 --> 00:15:48,480
then we also have an application kernel

00:15:45,199 --> 00:15:51,759
um folder under each of these versions

00:15:48,480 --> 00:15:52,880
which target specific uh specification

00:15:51,759 --> 00:15:56,800
version

00:15:52,880 --> 00:15:59,759
and they have been distilled out from

00:15:56,800 --> 00:16:00,079
applications that are important for ecp

00:15:59,759 --> 00:16:03,920
or

00:16:00,079 --> 00:16:03,920
car projects

00:16:04,079 --> 00:16:09,920
now um for example now these are sample

00:16:06,880 --> 00:16:13,680
results uh taken a couple of months ago

00:16:09,920 --> 00:16:15,680
for summit if you want to just have a

00:16:13,680 --> 00:16:17,360
view of how the compilers are doing in

00:16:15,680 --> 00:16:20,000
terms of openmp support

00:16:17,360 --> 00:16:21,440
we run the vnv and we can see these

00:16:20,000 --> 00:16:24,399
statistics about

00:16:21,440 --> 00:16:25,440
how good the compiler is in supporting

00:16:24,399 --> 00:16:27,519
or

00:16:25,440 --> 00:16:30,079
giving correct results for the

00:16:27,519 --> 00:16:34,800
implementation similarly we did it for

00:16:30,079 --> 00:16:37,360
the corey a computer at nurse so

00:16:34,800 --> 00:16:39,759
our personal experience at this point is

00:16:37,360 --> 00:16:42,959
that uh ibm excel compilers

00:16:39,759 --> 00:16:46,320
are definitely ahead of the curve

00:16:42,959 --> 00:16:50,720
but there is a lot of other

00:16:46,320 --> 00:16:53,759
um gcc as well as cray

00:16:50,720 --> 00:16:55,519
are catching up so

00:16:53,759 --> 00:16:57,360
this is not the only thing we have a

00:16:55,519 --> 00:17:00,959
website where you can go

00:16:57,360 --> 00:17:03,120
and if you select the results tab here

00:17:00,959 --> 00:17:04,640
you can see the different combinations

00:17:03,120 --> 00:17:05,439
are known combinations available

00:17:04,640 --> 00:17:09,039
combinations

00:17:05,439 --> 00:17:11,039
of compilers and

00:17:09,039 --> 00:17:12,720
platforms and you can look at the

00:17:11,039 --> 00:17:15,679
results of how

00:17:12,720 --> 00:17:17,600
they are doing with respect to our tests

00:17:15,679 --> 00:17:18,160
remember this is an ongoing project we

00:17:17,600 --> 00:17:21,120
are still

00:17:18,160 --> 00:17:22,319
building tests for the 5.0 version and

00:17:21,120 --> 00:17:25,679
constantly adding

00:17:22,319 --> 00:17:28,480
new tests for the 4.5 that said we

00:17:25,679 --> 00:17:32,240
already have a number of success stories

00:17:28,480 --> 00:17:33,679
so we have vendors like cray and amd

00:17:32,240 --> 00:17:36,559
they are using sof

00:17:33,679 --> 00:17:38,400
vnb to verify the correctness and uh

00:17:36,559 --> 00:17:40,720
coverage for the new features

00:17:38,400 --> 00:17:42,240
that they are um adding to a for the

00:17:40,720 --> 00:17:45,600
frontier platform

00:17:42,240 --> 00:17:49,120
and we have vendors like gcc

00:17:45,600 --> 00:17:51,360
um am amd and cray

00:17:49,120 --> 00:17:53,919
uh constantly communicating over the

00:17:51,360 --> 00:17:56,000
github to improve the coverage uh

00:17:53,919 --> 00:17:57,679
and add some bug fixes things that we

00:17:56,000 --> 00:18:01,280
may have missed and

00:17:57,679 --> 00:18:04,480
um they found out which is great

00:18:01,280 --> 00:18:06,400
community engagement so uh we

00:18:04,480 --> 00:18:07,919
using our tests implementation bugs were

00:18:06,400 --> 00:18:10,559
identified in gcc

00:18:07,919 --> 00:18:12,640
ibm as well as create implementations

00:18:10,559 --> 00:18:13,840
which they were very responsive in

00:18:12,640 --> 00:18:16,400
fixing

00:18:13,840 --> 00:18:19,280
once we brought it to their attention uh

00:18:16,400 --> 00:18:22,480
the old cs which is at oakridge

00:18:19,280 --> 00:18:25,280
is using this validation verification

00:18:22,480 --> 00:18:27,360
suite as part of the acceptance test

00:18:25,280 --> 00:18:28,640
for frontier which means that all these

00:18:27,360 --> 00:18:30,720
tests have to pass

00:18:28,640 --> 00:18:33,120
in order for us to accept the openmp

00:18:30,720 --> 00:18:36,480
implementation that cray provides

00:18:33,120 --> 00:18:39,919
also nurse has integrated this

00:18:36,480 --> 00:18:44,240
vnp for testing their 4.5 and 5.4

00:18:39,919 --> 00:18:47,440
5.0 implementations which is um

00:18:44,240 --> 00:18:48,720
very interesting for us so what are the

00:18:47,440 --> 00:18:50,559
different ways

00:18:48,720 --> 00:18:53,679
we want the community to collaborate

00:18:50,559 --> 00:18:55,840
with us our main medium is github

00:18:53,679 --> 00:18:57,039
everything is open out there you can

00:18:55,840 --> 00:19:02,080
look at the tests

00:18:57,039 --> 00:19:04,000
you can um download them play with them

00:19:02,080 --> 00:19:06,000
you can even if you find some issues you

00:19:04,000 --> 00:19:09,120
can create pr

00:19:06,000 --> 00:19:12,240
solve it or just leave it

00:19:09,120 --> 00:19:13,440
a comment there for us to solve so on

00:19:12,240 --> 00:19:14,799
github

00:19:13,440 --> 00:19:17,120
if you need to check the behavior for

00:19:14,799 --> 00:19:19,039
your openmp application

00:19:17,120 --> 00:19:21,520
you can create an application kernel and

00:19:19,039 --> 00:19:24,559
give it to us or create a pr

00:19:21,520 --> 00:19:28,080
um and we can we will review it

00:19:24,559 --> 00:19:30,640
and integrate it into the um vnv

00:19:28,080 --> 00:19:31,600
if it is appropriate if you find some

00:19:30,640 --> 00:19:34,640
issues you find

00:19:31,600 --> 00:19:38,400
something is missing just again create

00:19:34,640 --> 00:19:40,080
and submit an issue or pr and we have a

00:19:38,400 --> 00:19:42,799
very responsive team and

00:19:40,080 --> 00:19:43,600
i can assure you that it will be looked

00:19:42,799 --> 00:19:46,960
at

00:19:43,600 --> 00:19:50,320
so if you have an uh

00:19:46,960 --> 00:19:52,799
if you have any ideas or where other

00:19:50,320 --> 00:19:54,240
if you just want to chat with us or if

00:19:52,799 --> 00:19:56,480
you have more questions

00:19:54,240 --> 00:19:57,440
feel free to reach out any of the team

00:19:56,480 --> 00:20:00,640
members

00:19:57,440 --> 00:20:04,240
and we will gladly answer any of your

00:20:00,640 --> 00:20:06,480
questions last but not least i would

00:20:04,240 --> 00:20:09,600
like to acknowledge our sponsor

00:20:06,480 --> 00:20:11,440
the doe exoskill computing project the

00:20:09,600 --> 00:20:12,240
u.s department of energy office of

00:20:11,440 --> 00:20:14,320
sciences

00:20:12,240 --> 00:20:16,880
as well as the national nuclear security

00:20:14,320 --> 00:20:21,840
administration

00:20:16,880 --> 00:20:21,840

YouTube URL: https://www.youtube.com/watch?v=rNGtTBqGU50


