Title: OpenMP 5.1 Overview
Publication date: 2020-11-12
Playlist: SC20 OpenMP Booth Talks
Description: 
	This presentation, delivered by Bronis de Supinski, Chair of the OpenMP language committee, is part of the OpenMP Booth Talk series created for Supercomputing 2020. A PDF of this presentation as well as more videos from this series can be downloaded at link.openmp.org/sc20
Captions: 
	00:00:00,960 --> 00:00:06,640
good day i am veronica sipinski

00:00:03,760 --> 00:00:08,160
i am the chair of the open mp language

00:00:06,640 --> 00:00:11,840
committee in addition to being

00:00:08,160 --> 00:00:13,440
the uh chief technology officer for

00:00:11,840 --> 00:00:15,679
livermore computing at lawrence

00:00:13,440 --> 00:00:18,480
livermore national laboratory

00:00:15,679 --> 00:00:20,880
today i'll be telling you about uh

00:00:18,480 --> 00:00:25,039
recent happenings on

00:00:20,880 --> 00:00:25,039
in the language committee

00:00:25,359 --> 00:00:30,160
in particular i'll be telling you about

00:00:27,760 --> 00:00:33,280
the newest version of the specification

00:00:30,160 --> 00:00:33,920
that that we have just released so this

00:00:33,280 --> 00:00:36,960
is

00:00:33,920 --> 00:00:39,920
hot off the presses news and in fact in

00:00:36,960 --> 00:00:42,640
the uh wonders of modern technology is

00:00:39,920 --> 00:00:45,280
actually anticipatory news

00:00:42,640 --> 00:00:47,440
in addition i'll be telling you some uh

00:00:45,280 --> 00:00:49,200
very very late breaking news it's a

00:00:47,440 --> 00:00:52,960
surprise i'll hold for

00:00:49,200 --> 00:00:55,920
uh near the end of the talk um

00:00:52,960 --> 00:00:57,440
so as i mentioned this is a little bit

00:00:55,920 --> 00:01:01,359
anticipatory because

00:00:57,440 --> 00:01:02,879
because uh this is uh we're anticipating

00:01:01,359 --> 00:01:05,040
that that it will be ratified in

00:01:02,879 --> 00:01:05,760
november 2020 i'll tell you more about

00:01:05,040 --> 00:01:08,000
the

00:01:05,760 --> 00:01:09,040
process but i'm very confident that it

00:01:08,000 --> 00:01:12,080
will be

00:01:09,040 --> 00:01:15,600
um so openmp 5.1 is the latest version

00:01:12,080 --> 00:01:18,080
of the openmp specification

00:01:15,600 --> 00:01:19,759
we several members of the language

00:01:18,080 --> 00:01:23,280
committee including myself

00:01:19,759 --> 00:01:25,840
published an article in the last year

00:01:23,280 --> 00:01:28,720
in the proceedings of the ieee on the

00:01:25,840 --> 00:01:30,960
ongoing evolution of openmp

00:01:28,720 --> 00:01:31,759
and in that we we laid out kind of the

00:01:30,960 --> 00:01:34,960
vision of

00:01:31,759 --> 00:01:36,479
of openmp as well as a a nice review of

00:01:34,960 --> 00:01:38,640
its history and

00:01:36,479 --> 00:01:41,280
how we got here so how how we got to

00:01:38,640 --> 00:01:44,640
where we are and where we're going

00:01:41,280 --> 00:01:46,560
and the the basic vision is that openmp

00:01:44,640 --> 00:01:49,439
will broadly support on node

00:01:46,560 --> 00:01:49,840
performance portable parallelism which

00:01:49,439 --> 00:01:55,119
um

00:01:49,840 --> 00:01:58,560
is consistent with its uh original goals

00:01:55,119 --> 00:01:59,520
it the goals have have evolved a bit

00:01:58,560 --> 00:02:04,719
over the years

00:01:59,520 --> 00:02:06,560
and the vision has has evolved with that

00:02:04,719 --> 00:02:08,000
but it's actually surprisingly

00:02:06,560 --> 00:02:11,599
consistent with where it started

00:02:08,000 --> 00:02:15,599
over 20 years ago so

00:02:11,599 --> 00:02:18,720
openmp 5.0 fits that vision with

00:02:15,599 --> 00:02:22,560
enhanced device support

00:02:18,720 --> 00:02:25,840
and additional new models of parallelism

00:02:22,560 --> 00:02:29,599
and several other extensions it really

00:02:25,840 --> 00:02:32,959
uh led towards that and i can

00:02:29,599 --> 00:02:34,879
ensure you that 6.0 will continue

00:02:32,959 --> 00:02:36,720
fitting within that vision and help us

00:02:34,879 --> 00:02:39,760
further realize

00:02:36,720 --> 00:02:41,440
openmp 5.1 our most recent version of

00:02:39,760 --> 00:02:46,560
the specification

00:02:41,440 --> 00:02:49,920
refines how 5.0 realizes the vision

00:02:46,560 --> 00:02:51,760
openmp 5.1 as is appropriate for a minor

00:02:49,920 --> 00:02:55,200
release does not break

00:02:51,760 --> 00:02:56,480
uh existing code i won't absolutely

00:02:55,200 --> 00:02:58,959
swear to that

00:02:56,480 --> 00:03:01,760
i will warn you that that we've

00:02:58,959 --> 00:03:05,519
deprecated several things

00:03:01,760 --> 00:03:08,000
that those things will still work in 5.1

00:03:05,519 --> 00:03:08,879
the promise that the openmp language

00:03:08,000 --> 00:03:11,760
committee

00:03:08,879 --> 00:03:13,120
and openmp organization in general makes

00:03:11,760 --> 00:03:15,200
is that when we deprecate

00:03:13,120 --> 00:03:17,120
something we will actually remove it in

00:03:15,200 --> 00:03:18,720
the next major version

00:03:17,120 --> 00:03:20,720
and while that doesn't say anything for

00:03:18,720 --> 00:03:24,319
what the implementers will do

00:03:20,720 --> 00:03:27,519
with those no longer existing features

00:03:24,319 --> 00:03:29,440
no longer existing keywords and symbols

00:03:27,519 --> 00:03:30,879
it does mean that you really should stop

00:03:29,440 --> 00:03:34,239
using them

00:03:30,879 --> 00:03:35,120
and uh the act of deprecating them is

00:03:34,239 --> 00:03:39,120
kind of a warning

00:03:35,120 --> 00:03:42,519
starts to stop using them starting now

00:03:39,120 --> 00:03:43,840
anyhow so openmp 5.1 includes many

00:03:42,519 --> 00:03:46,879
clarifications and

00:03:43,840 --> 00:03:49,920
and corrections and some

00:03:46,879 --> 00:03:50,879
significant enhancements uh and i'll be

00:03:49,920 --> 00:03:55,040
detailing those

00:03:50,879 --> 00:03:58,000
in a second it if you've seen the

00:03:55,040 --> 00:03:58,799
uh comment drafts pr8 released a year

00:03:58,000 --> 00:04:01,920
ago and

00:03:58,799 --> 00:04:03,599
tr 9 released earlier this summer

00:04:01,920 --> 00:04:05,840
you should have a pretty good idea of

00:04:03,599 --> 00:04:08,959
what's actually in 5.1

00:04:05,840 --> 00:04:13,200
because everything since by

00:04:08,959 --> 00:04:16,079
tr 9 has just been a result of

00:04:13,200 --> 00:04:17,040
making sure that everything is in good

00:04:16,079 --> 00:04:18,639
shape

00:04:17,040 --> 00:04:20,320
that we don't have any major errors in

00:04:18,639 --> 00:04:23,360
the specification

00:04:20,320 --> 00:04:25,919
and that um you know

00:04:23,360 --> 00:04:27,360
just that everything fits together

00:04:25,919 --> 00:04:30,000
appropriately

00:04:27,360 --> 00:04:32,080
in the process of adding all of the

00:04:30,000 --> 00:04:34,560
things we've added

00:04:32,080 --> 00:04:36,080
we didn't miss any significant

00:04:34,560 --> 00:04:40,240
interactions

00:04:36,080 --> 00:04:42,960
it involves 251 github issues which

00:04:40,240 --> 00:04:43,360
is more than i would have expected um

00:04:42,960 --> 00:04:45,120
and

00:04:43,360 --> 00:04:46,800
maybe more than some implementers would

00:04:45,120 --> 00:04:50,160
have liked um

00:04:46,800 --> 00:04:51,840
but i'll make no apologies to them and

00:04:50,160 --> 00:04:54,720
if you want to know why i'm happy to

00:04:51,840 --> 00:04:57,600
speak further on that sometime

00:04:54,720 --> 00:05:00,080
anyway the uh significant extensions

00:04:57,600 --> 00:05:03,759
that that we've added include the

00:05:00,080 --> 00:05:05,840
interop construct which um is something

00:05:03,759 --> 00:05:06,960
that that improves support for native

00:05:05,840 --> 00:05:09,919
device

00:05:06,960 --> 00:05:11,840
devices so uh so it allows you to be

00:05:09,919 --> 00:05:12,800
able to interact with things like cuda

00:05:11,840 --> 00:05:16,080
streams

00:05:12,800 --> 00:05:19,440
um the the format of of this uh

00:05:16,080 --> 00:05:21,440
construct actually supports um

00:05:19,440 --> 00:05:24,080
general interoperability so if you want

00:05:21,440 --> 00:05:26,479
to interoperate with things like

00:05:24,080 --> 00:05:28,160
threat billing blocks it will also

00:05:26,479 --> 00:05:32,000
support that

00:05:28,160 --> 00:05:35,280
basically what it does is provides a

00:05:32,000 --> 00:05:39,919
opaque type that

00:05:35,280 --> 00:05:42,240
can be populated with uh important

00:05:39,919 --> 00:05:43,120
information about the native device

00:05:42,240 --> 00:05:46,479
support

00:05:43,120 --> 00:05:48,880
and then you can use um various

00:05:46,479 --> 00:05:51,520
calls that are added runtime calls that

00:05:48,880 --> 00:05:54,000
are added to the

00:05:51,520 --> 00:05:55,199
to to get that information and be able

00:05:54,000 --> 00:05:57,199
to

00:05:55,199 --> 00:05:59,440
link together the use of the native

00:05:57,199 --> 00:06:04,400
device support with

00:05:59,440 --> 00:06:06,560
typical uh openmp device support

00:06:04,400 --> 00:06:08,479
we've also added something called the

00:06:06,560 --> 00:06:11,360
dispatch construct

00:06:08,479 --> 00:06:14,000
um and improved the declare variant

00:06:11,360 --> 00:06:17,120
directive so the dispatch construct

00:06:14,000 --> 00:06:20,000
uh works with declare variant

00:06:17,120 --> 00:06:21,440
it allows you to define variants for

00:06:20,000 --> 00:06:24,880
functions

00:06:21,440 --> 00:06:27,919
that you can then add

00:06:24,880 --> 00:06:31,680
device specific arguments to and

00:06:27,919 --> 00:06:34,720
including things that are derived from

00:06:31,680 --> 00:06:39,360
the interop construct support

00:06:34,720 --> 00:06:42,960
in addition we have added

00:06:39,360 --> 00:06:47,199
further declare variant support that

00:06:42,960 --> 00:06:51,759
allows you to mark regions of code that

00:06:47,199 --> 00:06:54,639
should be compiled for specific

00:06:51,759 --> 00:06:55,199
openmp contexts which will generally

00:06:54,639 --> 00:07:00,960
apply

00:06:55,199 --> 00:07:03,680
for a say a specific kind of device

00:07:00,960 --> 00:07:05,199
but blight is in any context that

00:07:03,680 --> 00:07:09,520
doesn't match

00:07:05,199 --> 00:07:11,599
that context um so both of these

00:07:09,520 --> 00:07:12,800
uh significant extensions are are the

00:07:11,599 --> 00:07:15,599
subject of uh

00:07:12,800 --> 00:07:18,000
other talks that will be available at

00:07:15,599 --> 00:07:20,800
the openmp booth

00:07:18,000 --> 00:07:21,919
the interop construct will be covered by

00:07:20,800 --> 00:07:23,840
tom skoglund

00:07:21,919 --> 00:07:25,360
from lawrence livermore national

00:07:23,840 --> 00:07:29,680
laboratory who's the

00:07:25,360 --> 00:07:32,479
co-chair of the accelerator subcommittee

00:07:29,680 --> 00:07:33,919
and the dispatch construct and the

00:07:32,479 --> 00:07:36,960
declare variant

00:07:33,919 --> 00:07:40,240
enhancements will be covered by uh

00:07:36,960 --> 00:07:44,560
ravi narayan swami

00:07:40,240 --> 00:07:49,039
from intel he's a important developer

00:07:44,560 --> 00:07:49,039
of their uh openmp support

00:07:50,160 --> 00:07:54,560
so um a couple more significant

00:07:53,360 --> 00:07:58,240
extensions

00:07:54,560 --> 00:08:02,400
included in openmp 5.1 the

00:07:58,240 --> 00:08:06,400
assume directive is a new directive that

00:08:02,400 --> 00:08:09,120
allows you to state

00:08:06,400 --> 00:08:10,000
things that the openmp implementation

00:08:09,120 --> 00:08:14,160
can assume

00:08:10,000 --> 00:08:14,160
for a specific and

00:08:14,960 --> 00:08:22,479
dynamic context dynamic scope

00:08:18,479 --> 00:08:25,199
so it it applies to a structured block

00:08:22,479 --> 00:08:27,520
it cannot it there's several different

00:08:25,199 --> 00:08:29,199
forms but basically it allows you to say

00:08:27,520 --> 00:08:31,919
that

00:08:29,199 --> 00:08:32,959
some invariants will hold and these

00:08:31,919 --> 00:08:35,120
invariants can

00:08:32,959 --> 00:08:37,680
include things such as the promise not

00:08:35,120 --> 00:08:37,680
to use

00:08:38,640 --> 00:08:44,880
sun openmp um

00:08:42,240 --> 00:08:46,240
constructs or even you know larger

00:08:44,880 --> 00:08:48,800
portions of openmp

00:08:46,240 --> 00:08:49,600
like you can say that you won't have any

00:08:48,800 --> 00:08:53,120
openmp

00:08:49,600 --> 00:08:56,560
parallelism in that context

00:08:53,120 --> 00:08:57,360
or that you won't use any openmp runtime

00:08:56,560 --> 00:08:59,440
functions

00:08:57,360 --> 00:09:01,279
we actually expect that some

00:08:59,440 --> 00:09:05,440
implementers will define

00:09:01,279 --> 00:09:08,000
we'll they'll be implementation defined

00:09:05,440 --> 00:09:08,720
assumptions that you can declare that

00:09:08,000 --> 00:09:12,480
actually

00:09:08,720 --> 00:09:15,600
say that you will conform to a subset

00:09:12,480 --> 00:09:18,320
of that they support and provide

00:09:15,600 --> 00:09:20,080
optimization for this is also the

00:09:18,320 --> 00:09:22,480
subject of a deep talk

00:09:20,080 --> 00:09:24,399
available at the openmp booth that will

00:09:22,480 --> 00:09:27,920
be provided by

00:09:24,399 --> 00:09:30,000
johannes dorfor from argonne national

00:09:27,920 --> 00:09:33,519
laboratory

00:09:30,000 --> 00:09:34,480
uh then finally for the significant

00:09:33,519 --> 00:09:37,600
extensions

00:09:34,480 --> 00:09:40,320
in 5.1 we have added

00:09:37,600 --> 00:09:42,640
loop transformation directives and so

00:09:40,320 --> 00:09:44,560
these are ways to specify

00:09:42,640 --> 00:09:46,399
what we would think of as traditional

00:09:44,560 --> 00:09:50,000
sequential optimizations for

00:09:46,399 --> 00:09:53,680
loops in openmp 5.1 we've

00:09:50,000 --> 00:09:56,720
added support for tiling and

00:09:53,680 --> 00:09:58,720
unrolling of loops and so these are in

00:09:56,720 --> 00:10:00,000
the form of the tile directive in the

00:09:58,720 --> 00:10:03,600
unrolled directive

00:10:00,000 --> 00:10:06,320
and you can control how

00:10:03,600 --> 00:10:08,000
many iterations are unrolled you can

00:10:06,320 --> 00:10:11,760
control the

00:10:08,000 --> 00:10:11,760
block sizes of the tiles

00:10:12,160 --> 00:10:17,040
in general this is a very important step

00:10:15,040 --> 00:10:20,160
for openmp

00:10:17,040 --> 00:10:22,959
the motivation for adding these

00:10:20,160 --> 00:10:23,920
new directives is that in this way you

00:10:22,959 --> 00:10:26,720
can handle

00:10:23,920 --> 00:10:29,040
you can control how these optimizations

00:10:26,720 --> 00:10:34,000
interact with the

00:10:29,040 --> 00:10:36,160
parallelization of your loops previously

00:10:34,000 --> 00:10:38,320
in fact openmp directives for

00:10:36,160 --> 00:10:41,920
parallelizing loops would often

00:10:38,320 --> 00:10:45,440
cause compilers to not apply

00:10:41,920 --> 00:10:47,680
these optimizations and

00:10:45,440 --> 00:10:50,079
whether they would be applied before or

00:10:47,680 --> 00:10:54,240
after the parallelization was done

00:10:50,079 --> 00:10:56,399
uh would vary as i said this is also a

00:10:54,240 --> 00:10:58,320
the subject of another deep dive talk

00:10:56,399 --> 00:11:00,720
available at the openmp booth

00:10:58,320 --> 00:11:01,839
and this one will be uh presented by

00:11:00,720 --> 00:11:03,600
michael cruz

00:11:01,839 --> 00:11:06,240
from also from argonne national

00:11:03,600 --> 00:11:06,240
laboratory

00:11:07,680 --> 00:11:11,440
all right well so so those i think are

00:11:10,000 --> 00:11:14,000
the most

00:11:11,440 --> 00:11:15,600
major extensions but we've added many

00:11:14,000 --> 00:11:19,040
other things

00:11:15,600 --> 00:11:21,519
which i think you'll find useful

00:11:19,040 --> 00:11:22,560
probably the the biggest next things

00:11:21,519 --> 00:11:25,410
that we've added

00:11:22,560 --> 00:11:27,440
is that we now support all

00:11:25,410 --> 00:11:30,480
[Music]

00:11:27,440 --> 00:11:33,760
versions of the

00:11:30,480 --> 00:11:37,120
base languages c c plus plus uh

00:11:33,760 --> 00:11:38,000
fortran and fortran so we added complete

00:11:37,120 --> 00:11:41,200
support

00:11:38,000 --> 00:11:41,839
for c11 c plus plus 11 c plus plus

00:11:41,200 --> 00:11:44,959
fourteen

00:11:41,839 --> 00:11:45,360
c plus plus seventeen and c plus plus

00:11:44,959 --> 00:11:47,360
twenty

00:11:45,360 --> 00:11:48,640
completed support for fortran two

00:11:47,360 --> 00:11:51,519
thousand eight

00:11:48,640 --> 00:11:52,560
uh the c plus plus twenty support it

00:11:51,519 --> 00:11:54,720
we're we're kind of

00:11:52,560 --> 00:11:56,240
particularly proud of that since uh c

00:11:54,720 --> 00:12:00,959
plus plus 20

00:11:56,240 --> 00:12:03,920
is also being uh finalized and released

00:12:00,959 --> 00:12:05,440
in in we expect it to be done in

00:12:03,920 --> 00:12:07,519
november but we have

00:12:05,440 --> 00:12:09,760
several members of the openmp language

00:12:07,519 --> 00:12:12,800
committee who also participate

00:12:09,760 --> 00:12:13,680
in the c plus committees and so we were

00:12:12,800 --> 00:12:17,120
able to have

00:12:13,680 --> 00:12:19,839
a good insight into

00:12:17,120 --> 00:12:21,040
what would what the feature set of c

00:12:19,839 --> 00:12:24,320
plus plus 20 would be

00:12:21,040 --> 00:12:24,959
and be able to provide full support for

00:12:24,320 --> 00:12:29,040
it

00:12:24,959 --> 00:12:31,240
immediately and in addition we've also

00:12:29,040 --> 00:12:32,720
added additional support for fortran

00:12:31,240 --> 00:12:34,959
00:12:32,720 --> 00:12:36,000
there are some caveats on that support

00:12:34,959 --> 00:12:38,720
so

00:12:36,000 --> 00:12:40,959
if you use some new features from

00:12:38,720 --> 00:12:43,920
fortran 2018

00:12:40,959 --> 00:12:46,240
uh with openmp the the behavior is not

00:12:43,920 --> 00:12:48,079
well defined yet

00:12:46,240 --> 00:12:50,160
we will be working on completing that

00:12:48,079 --> 00:12:51,519
which has been the general strategy that

00:12:50,160 --> 00:12:54,399
we've adopted for

00:12:51,519 --> 00:12:56,240
adding support for new base languages

00:12:54,399 --> 00:12:59,760
another major addition

00:12:56,240 --> 00:13:01,440
in many ways to openmp is that you can

00:12:59,760 --> 00:13:05,120
now specify

00:13:01,440 --> 00:13:07,279
directives for in c plus using

00:13:05,120 --> 00:13:09,279
attribute syntax using attribute

00:13:07,279 --> 00:13:12,399
specifiers

00:13:09,279 --> 00:13:15,120
right now this is largely

00:13:12,399 --> 00:13:17,040
syntactic sugar instead of using the

00:13:15,120 --> 00:13:20,639
pragma format you can

00:13:17,040 --> 00:13:23,839
add the directives on uh

00:13:20,639 --> 00:13:27,200
as attributes this allows you to um

00:13:23,839 --> 00:13:29,360
provide openmp directives in some

00:13:27,200 --> 00:13:31,279
context in c plus plus that there was no

00:13:29,360 --> 00:13:34,240
way to get at in the past

00:13:31,279 --> 00:13:35,040
we expect that in future versions of

00:13:34,240 --> 00:13:38,160
openmp

00:13:35,040 --> 00:13:39,600
that will have capabilities that are

00:13:38,160 --> 00:13:41,760
enabled because

00:13:39,600 --> 00:13:43,040
you're using attributes that would not

00:13:41,760 --> 00:13:47,199
be

00:13:43,040 --> 00:13:49,199
possible to support through pragmas

00:13:47,199 --> 00:13:50,240
another significant addition is the

00:13:49,199 --> 00:13:53,600
error directive

00:13:50,240 --> 00:13:57,360
and what this does is allows you um

00:13:53,600 --> 00:14:01,279
either at compile time or at run time to

00:13:57,360 --> 00:14:03,600
have the compiler emit a

00:14:01,279 --> 00:14:05,120
implementation defined message in

00:14:03,600 --> 00:14:08,480
addition to a

00:14:05,120 --> 00:14:09,040
message string of your that that you

00:14:08,480 --> 00:14:12,639
provide

00:14:09,040 --> 00:14:13,839
to the directive um and it also has the

00:14:12,639 --> 00:14:18,399
ability to either stop

00:14:13,839 --> 00:14:18,399
compilation or to

00:14:18,720 --> 00:14:27,839
cause execution to stop

00:14:22,880 --> 00:14:29,839
these warning the fatal behaviors

00:14:27,839 --> 00:14:31,120
are particularly useful when used with

00:14:29,839 --> 00:14:33,760
things like the

00:14:31,120 --> 00:14:34,480
metadirective so that if you encounter

00:14:33,760 --> 00:14:36,720
them

00:14:34,480 --> 00:14:38,079
in an openmp context that you didn't

00:14:36,720 --> 00:14:42,320
expect

00:14:38,079 --> 00:14:44,320
you will have the immediate

00:14:42,320 --> 00:14:46,959
effect of knowing that you need to

00:14:44,320 --> 00:14:49,120
change your code

00:14:46,959 --> 00:14:50,880
we've also added another construct

00:14:49,120 --> 00:14:54,160
called the scope construct which

00:14:50,880 --> 00:14:55,040
allows you say within a parallel region

00:14:54,160 --> 00:14:58,480
to define

00:14:55,040 --> 00:14:59,519
a scope upon which you can do things

00:14:58,480 --> 00:15:02,000
like

00:14:59,519 --> 00:15:03,680
defining reduction so you can get the

00:15:02,000 --> 00:15:06,959
result of a reduction without

00:15:03,680 --> 00:15:06,959
ending a parallel region

00:15:07,120 --> 00:15:10,880
another significant enhancement is that

00:15:09,680 --> 00:15:13,760
you can now map

00:15:10,880 --> 00:15:14,720
function pointers so you can now uh

00:15:13,760 --> 00:15:17,279
easily call

00:15:14,720 --> 00:15:20,480
function pointers on a device uh this

00:15:17,279 --> 00:15:23,519
improves support for things like

00:15:20,480 --> 00:15:24,000
c plus plus classes and then in general

00:15:23,519 --> 00:15:27,040
just

00:15:24,000 --> 00:15:30,399
makes it more easy to support

00:15:27,040 --> 00:15:31,199
common paradigms for the way people

00:15:30,399 --> 00:15:34,720
write

00:15:31,199 --> 00:15:37,839
code in c and c plus plus

00:15:34,720 --> 00:15:40,639
another thing is we've defined despite

00:15:37,839 --> 00:15:42,160
device specific environment variables

00:15:40,639 --> 00:15:45,360
and so now you can

00:15:42,160 --> 00:15:48,480
control default behaviors

00:15:45,360 --> 00:15:53,120
by setting the environment

00:15:48,480 --> 00:15:56,880
in which the your application starts

00:15:53,120 --> 00:16:00,480
um one that i i i'm proud of is we've

00:15:56,880 --> 00:16:03,600
added the um nothing directive which

00:16:00,480 --> 00:16:06,639
has an amusing uh

00:16:03,600 --> 00:16:10,240
name and what it does is well

00:16:06,639 --> 00:16:11,920
nothing uh it's useful um in particular

00:16:10,240 --> 00:16:14,959
with meta directives

00:16:11,920 --> 00:16:15,680
um so you can now specify that indeed

00:16:14,959 --> 00:16:18,880
you want

00:16:15,680 --> 00:16:22,320
nothing to happen in in certain contexts

00:16:18,880 --> 00:16:24,639
um so that enhances clarity

00:16:22,320 --> 00:16:25,839
it actually allows you to specify a

00:16:24,639 --> 00:16:29,440
default of nothing

00:16:25,839 --> 00:16:31,440
which um it wasn't really clear in 5-0

00:16:29,440 --> 00:16:33,040
if that your code would be correct if

00:16:31,440 --> 00:16:36,560
you didn't specify

00:16:33,040 --> 00:16:39,440
any directive variant and in addition it

00:16:36,560 --> 00:16:42,079
allows you to define

00:16:39,440 --> 00:16:43,279
no action as having a score that's

00:16:42,079 --> 00:16:46,959
higher than

00:16:43,279 --> 00:16:48,160
other actions if you have contacts which

00:16:46,959 --> 00:16:51,839
end up with the same

00:16:48,160 --> 00:16:51,839
overall score

00:16:52,079 --> 00:16:55,519
all right well so um we could argue that

00:16:54,720 --> 00:16:59,519
some of the

00:16:55,519 --> 00:17:02,720
those enhancements are

00:16:59,519 --> 00:17:05,520
refinements to existing functionality

00:17:02,720 --> 00:17:08,720
we've got a few others ways that we've

00:17:05,520 --> 00:17:11,760
enhanced refined existing functionality

00:17:08,720 --> 00:17:14,959
one in particular is the mask construct

00:17:11,760 --> 00:17:17,360
so this is a new construct in some ways

00:17:14,959 --> 00:17:18,079
what it really is is a new name for what

00:17:17,360 --> 00:17:20,319
you've known

00:17:18,079 --> 00:17:22,240
as the master construct which has been

00:17:20,319 --> 00:17:25,280
deprecated

00:17:22,240 --> 00:17:28,480
and the reason for that is

00:17:25,280 --> 00:17:31,600
well some people find the term master

00:17:28,480 --> 00:17:32,240
offensive whether you find it offensive

00:17:31,600 --> 00:17:35,280
or not

00:17:32,240 --> 00:17:39,039
there's no reason that the code and

00:17:35,280 --> 00:17:42,640
the specification needs to retain it

00:17:39,039 --> 00:17:45,120
so now the thread that starts a parallel

00:17:42,640 --> 00:17:48,400
team is called the primary thread

00:17:45,120 --> 00:17:52,080
if you use the mask construct with

00:17:48,400 --> 00:17:53,840
uh no clauses then you will get the

00:17:52,080 --> 00:17:56,240
same functionality as you would

00:17:53,840 --> 00:17:58,960
previously with the master construct

00:17:56,240 --> 00:18:00,160
and thread 0 will execute the region

00:17:58,960 --> 00:18:02,400
there'll be no

00:18:00,160 --> 00:18:04,320
device data there'll be no data

00:18:02,400 --> 00:18:06,400
environment created for it

00:18:04,320 --> 00:18:07,600
it's a very lightweight a lightweight

00:18:06,400 --> 00:18:11,039
way to limit

00:18:07,600 --> 00:18:14,160
execution to a single thread the mass

00:18:11,039 --> 00:18:15,600
construct adds the filter clause which

00:18:14,160 --> 00:18:17,760
if the

00:18:15,600 --> 00:18:20,720
parameter to it matches the thread

00:18:17,760 --> 00:18:20,720
number of the

00:18:21,760 --> 00:18:27,840
thread that encounters the construct

00:18:25,760 --> 00:18:28,880
then that thread will execute the

00:18:27,840 --> 00:18:32,000
structured block

00:18:28,880 --> 00:18:34,240
associated with the construct

00:18:32,000 --> 00:18:35,840
and so in this way you can actually have

00:18:34,240 --> 00:18:38,240
multiple threads

00:18:35,840 --> 00:18:39,919
uh execute the region but more

00:18:38,240 --> 00:18:42,240
importantly you can have

00:18:39,919 --> 00:18:46,080
some thread other than thread zero

00:18:42,240 --> 00:18:46,080
execute that structured block

00:18:47,039 --> 00:18:51,760
another significant enhancement is that

00:18:50,240 --> 00:18:55,280
we've

00:18:51,760 --> 00:18:58,320
extended the atomic construct to support

00:18:55,280 --> 00:19:01,280
compare and swap atomics

00:18:58,320 --> 00:19:02,320
and through the way we define the

00:19:01,280 --> 00:19:05,600
compare and swap

00:19:02,320 --> 00:19:08,880
support you can now specify

00:19:05,600 --> 00:19:11,520
min and max atomics and c and c

00:19:08,880 --> 00:19:12,960
plus plus they were already available in

00:19:11,520 --> 00:19:16,000
fortran

00:19:12,960 --> 00:19:16,720
because min and max are are intrinsic

00:19:16,000 --> 00:19:20,640
functions

00:19:16,720 --> 00:19:25,039
in that base language but they were not

00:19:20,640 --> 00:19:30,160
available operators for

00:19:25,039 --> 00:19:30,160
atomics in c and c plus plus previously

00:19:30,400 --> 00:19:37,039
um we've

00:19:34,000 --> 00:19:38,480
added many clauses including things as

00:19:37,039 --> 00:19:41,520
amusing as the no weight

00:19:38,480 --> 00:19:42,799
clause to the task weight construct that

00:19:41,520 --> 00:19:46,000
combines with

00:19:42,799 --> 00:19:49,120
the depend capability on tax weight to

00:19:46,000 --> 00:19:49,760
give you the ability some useful ability

00:19:49,120 --> 00:19:54,080
to

00:19:49,760 --> 00:19:57,679
to specify

00:19:54,080 --> 00:20:02,480
synchronization between regions without

00:19:57,679 --> 00:20:02,480
causing your code to block all tasks

00:20:02,720 --> 00:20:06,400
and we've also added the strict keyword

00:20:05,520 --> 00:20:09,520
to

00:20:06,400 --> 00:20:12,720
strict modifier to

00:20:09,520 --> 00:20:15,840
the grain size and num task

00:20:12,720 --> 00:20:17,760
clauses on task loop we've added many

00:20:15,840 --> 00:20:21,200
other things we've added several run

00:20:17,760 --> 00:20:23,240
time routines these runtime routines

00:20:21,200 --> 00:20:24,960
include ones that work with the

00:20:23,240 --> 00:20:28,240
interoperability construct

00:20:24,960 --> 00:20:29,120
support but they also add new memory

00:20:28,240 --> 00:20:34,000
allocations

00:20:29,120 --> 00:20:36,320
including omp re-alec uh

00:20:34,000 --> 00:20:38,159
i already mentioned the deprecations of

00:20:36,320 --> 00:20:40,320
the master construct we also had

00:20:38,159 --> 00:20:43,039
deprecated the master affinity

00:20:40,320 --> 00:20:44,799
policy that will now be the primary

00:20:43,039 --> 00:20:47,520
affinity policy

00:20:44,799 --> 00:20:48,799
and finally we deprecated cray pointers

00:20:47,520 --> 00:20:51,840
which

00:20:48,799 --> 00:20:55,840
our survey did not find any users

00:20:51,840 --> 00:20:58,080
openmp users who actually still use

00:20:55,840 --> 00:20:59,280
and so we've decided that the best thing

00:20:58,080 --> 00:21:02,480
to do was to

00:20:59,280 --> 00:21:03,679
deprecate that and any mention of create

00:21:02,480 --> 00:21:08,080
pointers will

00:21:03,679 --> 00:21:10,799
be gone as a openmp 6.0

00:21:08,080 --> 00:21:12,000
all right so the big uh additional news

00:21:10,799 --> 00:21:14,320
is that we've

00:21:12,000 --> 00:21:15,200
decided that we're going to have an

00:21:14,320 --> 00:21:18,320
openmp

00:21:15,200 --> 00:21:20,880
5.2 the plan is that

00:21:18,320 --> 00:21:22,559
5.2 will be released no later than a

00:21:20,880 --> 00:21:26,400
year from now we're hoping to get

00:21:22,559 --> 00:21:30,320
get it done sooner than that

00:21:26,400 --> 00:21:34,880
ideally by late spring or

00:21:30,320 --> 00:21:38,000
early summer of 2021.

00:21:34,880 --> 00:21:40,880
the decision to have this

00:21:38,000 --> 00:21:42,080
additional minor release came about late

00:21:40,880 --> 00:21:45,120
in the 5.1

00:21:42,080 --> 00:21:46,080
process the reason was because there

00:21:45,120 --> 00:21:48,240
were some

00:21:46,080 --> 00:21:50,159
things that came out of the adding of

00:21:48,240 --> 00:21:52,960
attribute specifiers that

00:21:50,159 --> 00:21:56,080
we felt could have been specified a

00:21:52,960 --> 00:21:56,080
little more cleanly

00:21:57,360 --> 00:22:05,919
if we could um consolidate the syntax

00:22:02,000 --> 00:22:09,120
definitions uh for all of the constructs

00:22:05,919 --> 00:22:12,159
however um we we decided that that

00:22:09,120 --> 00:22:15,679
would be a too significant a change

00:22:12,159 --> 00:22:19,200
the way things are are written

00:22:15,679 --> 00:22:21,039
for 5.1 without having to delay the

00:22:19,200 --> 00:22:24,880
release of 5.1

00:22:21,039 --> 00:22:28,000
um so the expectation is that in general

00:22:24,880 --> 00:22:30,000
5.2 will not add any new features or

00:22:28,000 --> 00:22:33,760
enhancements

00:22:30,000 --> 00:22:37,039
but it will significantly

00:22:33,760 --> 00:22:37,760
clarify things in particular we expect

00:22:37,039 --> 00:22:40,320
many

00:22:37,760 --> 00:22:40,960
restrictions on the use of clauses will

00:22:40,320 --> 00:22:43,760
be

00:22:40,960 --> 00:22:44,799
consolidated with the consolidated

00:22:43,760 --> 00:22:47,679
syntax

00:22:44,799 --> 00:22:50,280
which we also expect will probably

00:22:47,679 --> 00:22:53,440
uncover some

00:22:50,280 --> 00:22:56,559
inconsistencies and

00:22:53,440 --> 00:22:58,559
as a result we expect to make the um

00:22:56,559 --> 00:23:00,640
specification more consistent so there

00:22:58,559 --> 00:23:01,840
may be some small changes that emerge

00:23:00,640 --> 00:23:04,320
out of that

00:23:01,840 --> 00:23:06,880
we also will likely reduce some other

00:23:04,320 --> 00:23:10,240
redundancies that we found in particular

00:23:06,880 --> 00:23:13,600
in the specification

00:23:10,240 --> 00:23:16,559
of the tool interfaces and in particular

00:23:13,600 --> 00:23:18,960
the first party tool interface

00:23:16,559 --> 00:23:21,520
the one thing that may involve some

00:23:18,960 --> 00:23:24,799
changes to

00:23:21,520 --> 00:23:28,240
the actual functionality in openmp is um

00:23:24,799 --> 00:23:28,559
we will consider uh reducing the caveats

00:23:28,240 --> 00:23:31,760
to

00:23:28,559 --> 00:23:35,120
the fortran 2018 support but

00:23:31,760 --> 00:23:38,720
overall 5.2 should be viewed as an

00:23:35,120 --> 00:23:41,120
extended quality control pass

00:23:38,720 --> 00:23:42,880
and to give you an idea of why you

00:23:41,120 --> 00:23:44,480
should do it that way

00:23:42,880 --> 00:23:46,159
while we already have four issues

00:23:44,480 --> 00:23:48,880
created for it

00:23:46,159 --> 00:23:49,279
it will almost certainly not go beyond

00:23:48,880 --> 00:23:52,480
about

00:23:49,279 --> 00:23:54,240
50 issues total and be nowhere near the

00:23:52,480 --> 00:23:59,520
250 some

00:23:54,240 --> 00:23:59,520
that we have for 5.1

00:24:00,000 --> 00:24:04,320
so finally openmp 6.0 is not being

00:24:03,600 --> 00:24:06,240
delayed

00:24:04,320 --> 00:24:09,120
as a result of the decision to to

00:24:06,240 --> 00:24:10,520
release 5.2 so it will still be released

00:24:09,120 --> 00:24:13,760
in

00:24:10,520 --> 00:24:17,520
2023 we expect

00:24:13,760 --> 00:24:19,679
many significant enhancements for it

00:24:17,520 --> 00:24:21,520
we've got many things that we've already

00:24:19,679 --> 00:24:24,159
been discussing and that we deferred

00:24:21,520 --> 00:24:27,279
from 5.1 as being

00:24:24,159 --> 00:24:31,760
too significant for a minor release this

00:24:27,279 --> 00:24:35,600
includes things like deeper control

00:24:31,760 --> 00:24:35,600
exactly how prescriptive

00:24:35,679 --> 00:24:42,480
specific clauses or constructs are

00:24:39,600 --> 00:24:43,520
for example we may provide a way to

00:24:42,480 --> 00:24:46,159
cause

00:24:43,520 --> 00:24:46,799
your execution of a parallel region to

00:24:46,159 --> 00:24:50,799
generate

00:24:46,799 --> 00:24:53,360
exactly some number of threads

00:24:50,799 --> 00:24:54,880
we expect to have more support for

00:24:53,360 --> 00:24:58,080
memory effectivity

00:24:54,880 --> 00:25:00,480
and complex memory hierarchies we're

00:24:58,080 --> 00:25:04,000
looking at ways to support

00:25:00,480 --> 00:25:06,000
pipelining and also

00:25:04,000 --> 00:25:08,159
event driven parallelism so these would

00:25:06,000 --> 00:25:08,159
be

00:25:08,240 --> 00:25:15,039
better support for essentially new

00:25:12,559 --> 00:25:17,039
parallelism models for openmt with these

00:25:15,039 --> 00:25:19,440
we would

00:25:17,039 --> 00:25:20,559
pretty well cover the full range of

00:25:19,440 --> 00:25:23,679
available

00:25:20,559 --> 00:25:25,840
parallel programming patterns

00:25:23,679 --> 00:25:26,960
we will definitely continue to improve

00:25:25,840 --> 00:25:30,880
device support

00:25:26,960 --> 00:25:34,320
and support for heterogeneous

00:25:30,880 --> 00:25:37,600
node architectures we are looking

00:25:34,320 --> 00:25:40,559
at extensions for example of to the deep

00:25:37,600 --> 00:25:45,039
copy support that's provided by

00:25:40,559 --> 00:25:46,960
the declare mapper directive

00:25:45,039 --> 00:25:48,960
uh through allowing things like the

00:25:46,960 --> 00:25:51,279
specification of serialized and

00:25:48,960 --> 00:25:53,600
deserialized functions

00:25:51,279 --> 00:25:55,120
we uh one thing that as i sort of

00:25:53,600 --> 00:25:57,279
already mentioned

00:25:55,120 --> 00:25:59,200
when we decided that we would start

00:25:57,279 --> 00:26:02,240
deprecating things

00:25:59,200 --> 00:26:02,720
in 5.0 we also made a firm commitment

00:26:02,240 --> 00:26:05,679
that

00:26:02,720 --> 00:26:07,360
the next major release would remove any

00:26:05,679 --> 00:26:09,919
deprecated features

00:26:07,360 --> 00:26:10,960
and so the the list of deprecated

00:26:09,919 --> 00:26:13,760
features

00:26:10,960 --> 00:26:15,039
in 5.1 all of those features whether

00:26:13,760 --> 00:26:18,720
they were deprecated in

00:26:15,039 --> 00:26:22,960
5 1 or 5 0 will be removed

00:26:18,720 --> 00:26:26,880
in 6.0 overall we already have

00:26:22,960 --> 00:26:30,080
78 issues that are being considered for

00:26:26,880 --> 00:26:34,400
6.0 i expect that number to be

00:26:30,080 --> 00:26:34,400
very much higher by the time we are done

00:26:35,039 --> 00:26:42,000
and with that i am now

00:26:39,279 --> 00:26:50,799
done and i thank you for your attention

00:26:42,000 --> 00:26:50,799

YouTube URL: https://www.youtube.com/watch?v=JEDlPw-FydA


