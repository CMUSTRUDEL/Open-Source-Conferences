Title: OpenMP 5.1 Features: The Interop Construct
Publication date: 2020-11-12
Playlist: SC20 OpenMP Booth Talks
Description: 
	This presentation, delivered by Tom Scogland from the OpenMP language committee, is part of the OpenMP Booth Talk series created for Supercomputing 2020. A PDF of this presentation as well as more videos from this series can be downloaded at link.openmp.org/sc20
Captions: 
	00:00:02,240 --> 00:00:06,799
hello everybody this is tom skodlund

00:00:04,640 --> 00:00:08,320
i'm going to give you a little overview

00:00:06,799 --> 00:00:09,840
of one of the new features we have an

00:00:08,320 --> 00:00:13,040
openmp 5.1

00:00:09,840 --> 00:00:16,240
interop construct this

00:00:13,040 --> 00:00:19,439
is really a new

00:00:16,240 --> 00:00:20,880
attempt at adding greater

00:00:19,439 --> 00:00:23,519
interoperability between

00:00:20,880 --> 00:00:25,920
openmp and other parallel and

00:00:23,519 --> 00:00:28,080
heterogeneous computing frameworks

00:00:25,920 --> 00:00:29,199
and it's a new construct that enables

00:00:28,080 --> 00:00:33,440
that

00:00:29,199 --> 00:00:36,079
attempt as well the construct

00:00:33,440 --> 00:00:39,840
provides a mechanism to request low

00:00:36,079 --> 00:00:42,879
level information from openmp runtimes

00:00:39,840 --> 00:00:44,879
to write portable fully asynchronous

00:00:42,879 --> 00:00:46,879
code that uses both openmp and native

00:00:44,879 --> 00:00:51,440
functionality together

00:00:46,879 --> 00:00:54,480
and provides us with a place to build

00:00:51,440 --> 00:00:57,600
new interoperability features

00:00:54,480 --> 00:01:00,079
as we go forward and

00:00:57,600 --> 00:01:04,239
this all sounds kind of vague some of

00:01:00,079 --> 00:01:06,799
the concrete uses we have already in 5.1

00:01:04,239 --> 00:01:08,799
are the interop types target sync which

00:01:06,799 --> 00:01:09,360
is a way to access a synchronization

00:01:08,799 --> 00:01:12,960
object

00:01:09,360 --> 00:01:13,840
from the foreign time system and connect

00:01:12,960 --> 00:01:17,600
the openmp

00:01:13,840 --> 00:01:19,600
task graph with the task graph of the

00:01:17,600 --> 00:01:22,240
foreign runtime system

00:01:19,600 --> 00:01:23,600
a concrete example of this would be if

00:01:22,240 --> 00:01:27,360
you're mixing

00:01:23,600 --> 00:01:30,799
say sickle and openmp or cuda and openmp

00:01:27,360 --> 00:01:33,759
and you need a queue or a stream

00:01:30,799 --> 00:01:35,439
to be able to do asynchronous compute in

00:01:33,759 --> 00:01:38,079
the foreign system

00:01:35,439 --> 00:01:41,520
you can get that out of openmp you can

00:01:38,079 --> 00:01:44,720
have asynchronous openmp target regions

00:01:41,520 --> 00:01:47,920
and asynchronous cuda or sickle code

00:01:44,720 --> 00:01:50,720
and interconnect them correctly for

00:01:47,920 --> 00:01:51,600
with dependencies without having to

00:01:50,720 --> 00:01:55,360
block

00:01:51,600 --> 00:01:57,360
your waiting on the host and put

00:01:55,360 --> 00:01:59,840
bubbles here asynchronous compute

00:01:57,360 --> 00:01:59,840
pipeline

00:02:00,159 --> 00:02:06,479
target is a way to get native

00:02:03,920 --> 00:02:08,720
handles or foreign runtime handles to

00:02:06,479 --> 00:02:11,440
resources associated with the device

00:02:08,720 --> 00:02:11,920
so sometimes if you're doing especially

00:02:11,440 --> 00:02:15,920
lower

00:02:11,920 --> 00:02:18,080
level stuff with

00:02:15,920 --> 00:02:20,400
a foreign runtime system you may need

00:02:18,080 --> 00:02:23,440
access to

00:02:20,400 --> 00:02:26,160
a device handle a context handle a

00:02:23,440 --> 00:02:28,640
platform handle things like that

00:02:26,160 --> 00:02:29,840
and this is a way that you can get some

00:02:28,640 --> 00:02:32,959
of that information

00:02:29,840 --> 00:02:37,440
so that you can query properties or

00:02:32,959 --> 00:02:41,040
set things on your device

00:02:37,440 --> 00:02:44,480
so as a quick example

00:02:41,040 --> 00:02:44,480
this is a

00:02:45,040 --> 00:02:48,400
for kind of hello world example for

00:02:47,360 --> 00:02:52,720
getting a stream

00:02:48,400 --> 00:02:55,680
with the target sync interrupt type

00:02:52,720 --> 00:02:58,319
now clearly this is not a tiny amount of

00:02:55,680 --> 00:03:01,120
code this is not something that you just

00:02:58,319 --> 00:03:02,640
strike out in one line and it's done it

00:03:01,120 --> 00:03:05,040
is

00:03:02,640 --> 00:03:06,159
relatively complicated and it's pretty

00:03:05,040 --> 00:03:09,440
verbose

00:03:06,159 --> 00:03:12,959
but the reason for this is the openmp

00:03:09,440 --> 00:03:15,519
tasking model allows you to mix device

00:03:12,959 --> 00:03:17,840
and host code arbitrarily

00:03:15,519 --> 00:03:19,599
you can have a host test depending on a

00:03:17,840 --> 00:03:21,680
device task and vice versa

00:03:19,599 --> 00:03:23,040
arbitrarily you don't have to think

00:03:21,680 --> 00:03:25,840
about it

00:03:23,040 --> 00:03:27,200
now that's great for openmp code but it

00:03:25,840 --> 00:03:29,200
means that whenever we want to

00:03:27,200 --> 00:03:31,599
interact with the outside world in this

00:03:29,200 --> 00:03:35,280
case a foreign runtime

00:03:31,599 --> 00:03:38,959
cuda in this example we have to do

00:03:35,280 --> 00:03:39,440
some special pretty careful work to make

00:03:38,959 --> 00:03:42,319
sure

00:03:39,440 --> 00:03:44,000
that that task graph gets treated

00:03:42,319 --> 00:03:45,680
correctly and we interconnect everything

00:03:44,000 --> 00:03:48,640
the way we need to

00:03:45,680 --> 00:03:49,920
now the way that this is going to work

00:03:48,640 --> 00:03:53,760
is

00:03:49,920 --> 00:03:57,599
we have a declared interop

00:03:53,760 --> 00:03:59,439
object we initialize it with the interop

00:03:57,599 --> 00:04:01,760
in it target sync we give it a

00:03:59,439 --> 00:04:05,360
dependency

00:04:01,760 --> 00:04:07,439
and this tells the system that we need

00:04:05,360 --> 00:04:09,519
a target sync object for whatever kind

00:04:07,439 --> 00:04:11,680
of form runtime system exists on this

00:04:09,519 --> 00:04:14,319
device

00:04:11,680 --> 00:04:16,639
it should be a reference to it should be

00:04:14,319 --> 00:04:19,680
placed into our interop object

00:04:16,639 --> 00:04:20,560
and this dependence needs to be enforced

00:04:19,680 --> 00:04:23,600
but this is a

00:04:20,560 --> 00:04:27,520
very special kind of dependence

00:04:23,600 --> 00:04:30,240
right so in this case it will block here

00:04:27,520 --> 00:04:32,320
until anything waiting on that this

00:04:30,240 --> 00:04:35,759
dependence depends on

00:04:32,320 --> 00:04:36,960
is complete then you can get the interop

00:04:35,759 --> 00:04:38,720
property out

00:04:36,960 --> 00:04:41,759
in this case you're getting the foreign

00:04:38,720 --> 00:04:44,880
runtime id you make sure that it's cuda

00:04:41,759 --> 00:04:47,120
you get the interop property that is the

00:04:44,880 --> 00:04:50,320
target sync object which in this case

00:04:47,120 --> 00:04:53,120
we're casting off to a cuda stream

00:04:50,320 --> 00:04:53,440
set the stream into kublas say and then

00:04:53,120 --> 00:04:56,240
go

00:04:53,440 --> 00:04:58,000
do some asynchronous work in kublas

00:04:56,240 --> 00:05:01,360
destroy the interop object

00:04:58,000 --> 00:05:04,960
and then this waits

00:05:01,360 --> 00:05:06,639
on the kuda stream

00:05:04,960 --> 00:05:08,479
that is referenced in the target sync

00:05:06,639 --> 00:05:12,320
object

00:05:08,479 --> 00:05:15,600
so that dependencies on

00:05:12,320 --> 00:05:20,720
r respect that dependence

00:05:15,600 --> 00:05:22,400
on the cuda code now

00:05:20,720 --> 00:05:24,000
there are only a few things you can do

00:05:22,400 --> 00:05:26,080
with this right now you can get the

00:05:24,000 --> 00:05:27,520
foreign runtime id or name these are

00:05:26,080 --> 00:05:29,919
ways that you can tell what kind of

00:05:27,520 --> 00:05:31,840
foreign runtime system you're talking to

00:05:29,919 --> 00:05:33,919
you can get the vendor id your name

00:05:31,840 --> 00:05:36,000
again it's a way to tell

00:05:33,919 --> 00:05:39,039
what it is you're working with you might

00:05:36,000 --> 00:05:43,039
have a compiler or runtime system

00:05:39,039 --> 00:05:46,080
written by say ibm for

00:05:43,039 --> 00:05:48,800
a system backed by cuda

00:05:46,080 --> 00:05:49,520
the device number lets you just track

00:05:48,800 --> 00:05:53,039
what device

00:05:49,520 --> 00:05:55,919
thing came from platform device device

00:05:53,039 --> 00:05:56,960
context are all foreign runtime

00:05:55,919 --> 00:05:58,880
properties that

00:05:56,960 --> 00:06:01,039
give you access to lower level

00:05:58,880 --> 00:06:02,080
information about that foreign runtime

00:06:01,039 --> 00:06:04,880
system

00:06:02,080 --> 00:06:06,639
chances are if you don't know what these

00:06:04,880 --> 00:06:08,720
are in your foreign runtime system you

00:06:06,639 --> 00:06:13,120
probably don't need them

00:06:08,720 --> 00:06:15,280
but they're available for the times when

00:06:13,120 --> 00:06:18,319
you absolutely need to know something

00:06:15,280 --> 00:06:18,319
like you may want to

00:06:18,840 --> 00:06:23,120
query

00:06:20,800 --> 00:06:24,240
runtime system available information

00:06:23,120 --> 00:06:28,240
like the number

00:06:24,240 --> 00:06:29,440
of compute units on a device for example

00:06:28,240 --> 00:06:31,360
or to be able to use some of the

00:06:29,440 --> 00:06:33,440
allocation routines in some of the

00:06:31,360 --> 00:06:35,600
foreign runtime systems you might have

00:06:33,440 --> 00:06:37,360
you may need one of these

00:06:35,600 --> 00:06:39,120
last is the target sync object we

00:06:37,360 --> 00:06:40,240
already saw an example for this that is

00:06:39,120 --> 00:06:43,440
a stream or a

00:06:40,240 --> 00:06:46,639
queue or maybe even a tbb

00:06:43,440 --> 00:06:48,639
group it's some kind of synchronization

00:06:46,639 --> 00:06:52,720
object that you can use

00:06:48,639 --> 00:06:55,039
to access that native system

00:06:52,720 --> 00:06:58,240
and interact with it and have it work

00:06:55,039 --> 00:07:01,199
correctly with your openmp task graph

00:06:58,240 --> 00:07:03,120
now i mentioned earlier that you can get

00:07:01,199 --> 00:07:03,520
fully asynchronous dependencies and

00:07:03,120 --> 00:07:06,560
that's

00:07:03,520 --> 00:07:08,400
really how we got started on

00:07:06,560 --> 00:07:10,560
this feature in the first place is we

00:07:08,400 --> 00:07:12,000
had people coming to us and saying

00:07:10,560 --> 00:07:13,680
we want to be able to do things

00:07:12,000 --> 00:07:16,479
asynchronously well

00:07:13,680 --> 00:07:17,120
you can do that entirely within openmp

00:07:16,479 --> 00:07:20,319
with

00:07:17,120 --> 00:07:21,599
target no way and tasks and it just

00:07:20,319 --> 00:07:23,440
works

00:07:21,599 --> 00:07:25,280
but as soon as you need to go out of

00:07:23,440 --> 00:07:27,919
openmp

00:07:25,280 --> 00:07:29,680
and touch cuda or hip or sickle or what

00:07:27,919 --> 00:07:32,160
have you

00:07:29,680 --> 00:07:33,360
all of a sudden the only way to get this

00:07:32,160 --> 00:07:37,280
done was to

00:07:33,360 --> 00:07:38,319
completely block one side before

00:07:37,280 --> 00:07:41,360
starting the other

00:07:38,319 --> 00:07:43,840
and vice versa so

00:07:41,360 --> 00:07:44,960
when we designed interop we made it so

00:07:43,840 --> 00:07:48,160
that

00:07:44,960 --> 00:07:50,560
if you do no weight

00:07:48,160 --> 00:07:51,199
on say a target region then you have

00:07:50,560 --> 00:07:53,039
interop

00:07:51,199 --> 00:07:54,639
in it and you put no weight on the

00:07:53,039 --> 00:07:59,199
interop

00:07:54,639 --> 00:08:02,240
this has a special meaning it means that

00:07:59,199 --> 00:08:05,919
the target sync property

00:08:02,240 --> 00:08:08,080
inside this interop object if you

00:08:05,919 --> 00:08:10,240
ensure that your foreign runtime system

00:08:08,080 --> 00:08:12,000
depends on

00:08:10,240 --> 00:08:14,639
the work that has been enqueued in this

00:08:12,000 --> 00:08:17,039
thing it will respect

00:08:14,639 --> 00:08:19,440
this dependency that you have placed on

00:08:17,039 --> 00:08:23,440
the construct

00:08:19,440 --> 00:08:26,000
and then you can use that

00:08:23,440 --> 00:08:27,440
you go on you destroy it again with a no

00:08:26,000 --> 00:08:30,479
weight and then you have a target

00:08:27,440 --> 00:08:32,000
also with a no weight this means the

00:08:30,479 --> 00:08:34,640
encountering thread the thread that's

00:08:32,000 --> 00:08:37,919
going through and cueing all this stuff

00:08:34,640 --> 00:08:39,440
never blocks either side

00:08:37,919 --> 00:08:41,680
at least as far as the model is

00:08:39,440 --> 00:08:43,760
concerned an implementation may still

00:08:41,680 --> 00:08:46,399
decide to block it and interrupt

00:08:43,760 --> 00:08:48,320
in some cases if it has to for

00:08:46,399 --> 00:08:51,360
correctness

00:08:48,320 --> 00:08:53,279
but if you're in queueing only work that

00:08:51,360 --> 00:08:54,000
ends up on the forum runtime system and

00:08:53,279 --> 00:08:56,880
that system

00:08:54,000 --> 00:08:58,880
has a way to asynchronously handle

00:08:56,880 --> 00:09:01,920
dependencies

00:08:58,880 --> 00:09:04,880
this will stay completely asynchronous

00:09:01,920 --> 00:09:04,880
all the way through

00:09:05,040 --> 00:09:08,640
now going forward we're hoping that

00:09:08,080 --> 00:09:11,920
interop

00:09:08,640 --> 00:09:15,120
will give us a way to expose

00:09:11,920 --> 00:09:17,200
more things that will let you do more

00:09:15,120 --> 00:09:18,959
with a native system so that when you

00:09:17,200 --> 00:09:22,240
have to optimize and reach

00:09:18,959 --> 00:09:23,760
through openmp or you have some library

00:09:22,240 --> 00:09:26,640
that you need to use

00:09:23,760 --> 00:09:28,000
that can't work through openmp for

00:09:26,640 --> 00:09:29,760
whatever reason

00:09:28,000 --> 00:09:31,120
that you can do that and some of the

00:09:29,760 --> 00:09:33,760
things that we've been discussing

00:09:31,120 --> 00:09:34,720
in that direction are the ability to get

00:09:33,760 --> 00:09:38,399
information about

00:09:34,720 --> 00:09:40,160
threads say a posix thread t or a stood

00:09:38,399 --> 00:09:43,279
thread object so you can actually

00:09:40,160 --> 00:09:45,040
look at your thread ids or

00:09:43,279 --> 00:09:47,760
things like that as far as the native

00:09:45,040 --> 00:09:51,200
system is concerned

00:09:47,760 --> 00:09:55,519
a way to access similar things for

00:09:51,200 --> 00:09:57,920
locks you could actually pull out the

00:09:55,519 --> 00:09:59,360
implementation of a lock and manipulate

00:09:57,920 --> 00:10:02,800
it directly that one's much more

00:09:59,360 --> 00:10:06,880
complicated we're still working on it

00:10:02,800 --> 00:10:06,880
and one that very recently came up

00:10:07,680 --> 00:10:15,760
is a way to query how the system

00:10:12,640 --> 00:10:16,399
maps concepts from the forum runtime

00:10:15,760 --> 00:10:20,240
system

00:10:16,399 --> 00:10:22,880
to openmp's semantics for example

00:10:20,240 --> 00:10:25,040
in some cases when you do an allocation

00:10:22,880 --> 00:10:26,560
for a target you may be getting a handle

00:10:25,040 --> 00:10:28,320
rather than an actual pointer on the

00:10:26,560 --> 00:10:31,600
host if you're using the openmp

00:10:28,320 --> 00:10:32,880
device and we're considering having a

00:10:31,600 --> 00:10:36,560
way to

00:10:32,880 --> 00:10:39,040
request through interrupt

00:10:36,560 --> 00:10:39,920
what kind of handle it is that you get

00:10:39,040 --> 00:10:41,760
when you do that

00:10:39,920 --> 00:10:43,839
if it's actually a pointer if it's

00:10:41,760 --> 00:10:47,200
pinned memory if it's

00:10:43,839 --> 00:10:50,560
device memory or if it's say a cl

00:10:47,200 --> 00:10:53,040
mem or a sickle buffer object

00:10:50,560 --> 00:10:54,720
any of these are potentially valid

00:10:53,040 --> 00:10:56,959
depending on how things are set up

00:10:54,720 --> 00:10:58,640
so having some way to inquire about that

00:10:56,959 --> 00:11:01,120
seems useful

00:10:58,640 --> 00:11:02,800
but hopefully you're excited about this

00:11:01,120 --> 00:11:03,440
new feature and what we may be able to

00:11:02,800 --> 00:11:05,920
do with it

00:11:03,440 --> 00:11:07,519
if you're interested or have ideas for

00:11:05,920 --> 00:11:09,440
what we might do

00:11:07,519 --> 00:11:11,760
maybe take some time and get in contact

00:11:09,440 --> 00:11:15,360
with us we always love to hear from you

00:11:11,760 --> 00:11:15,360

YouTube URL: https://www.youtube.com/watch?v=qjkTL2CT37w


