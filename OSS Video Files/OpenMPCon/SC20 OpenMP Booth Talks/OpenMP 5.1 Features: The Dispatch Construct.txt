Title: OpenMP 5.1 Features: The Dispatch Construct
Publication date: 2020-11-12
Playlist: SC20 OpenMP Booth Talks
Description: 
	This presentation, delivered by Ravi Narayanaswamy from the OpenMP language committee, is part of the OpenMP Booth Talk series created for Supercomputing 2020. A PDF of this presentation as well as more videos from this series can be downloaded at link.openmp.org/sc20
Captions: 
	00:00:01,120 --> 00:00:05,040
hi my name is ravi narenswami and i work

00:00:03,760 --> 00:00:06,720
at intel

00:00:05,040 --> 00:00:08,800
uh i've been participating in the

00:00:06,720 --> 00:00:10,080
definition of openmp since they started

00:00:08,800 --> 00:00:11,759
introducing

00:00:10,080 --> 00:00:13,679
accelerator and device support into the

00:00:11,759 --> 00:00:17,119
openmp spec

00:00:13,679 --> 00:00:17,920
uh just one note uh all everything i'm

00:00:17,119 --> 00:00:19,920
expressing here

00:00:17,920 --> 00:00:22,160
in this tutorial in this presentation

00:00:19,920 --> 00:00:24,480
are my one and i'm not speaking for my

00:00:22,160 --> 00:00:27,199
employer

00:00:24,480 --> 00:00:30,400
okay let's move on to the agenda so i'm

00:00:27,199 --> 00:00:33,040
going to start off with the motivation

00:00:30,400 --> 00:00:35,040
and then i'm going to talk about the

00:00:33,040 --> 00:00:35,280
main topic which is the declare variant

00:00:35,040 --> 00:00:39,280
and

00:00:35,280 --> 00:00:41,520
dispatch the theme of this presentation

00:00:39,280 --> 00:00:43,280
and i'm going to conclude with the

00:00:41,520 --> 00:00:46,800
example

00:00:43,280 --> 00:00:49,440
so to any so the motivation is

00:00:46,800 --> 00:00:50,719
basically we won't have interop

00:00:49,440 --> 00:00:53,520
interoperability with the

00:00:50,719 --> 00:00:54,559
libraries so we want users to be able to

00:00:53,520 --> 00:00:57,520
use openmp

00:00:54,559 --> 00:00:58,879
uh constructs in the application but we

00:00:57,520 --> 00:01:01,760
have the ability to

00:00:58,879 --> 00:01:02,800
call specific libraries optimized

00:01:01,760 --> 00:01:04,799
libraries

00:01:02,800 --> 00:01:06,240
which may or may not use openmp

00:01:04,799 --> 00:01:08,159
offloading

00:01:06,240 --> 00:01:10,240
and so you want to be able to interrupt

00:01:08,159 --> 00:01:11,840
and share their data you want to use

00:01:10,240 --> 00:01:13,920
the user might send some data to the

00:01:11,840 --> 00:01:15,680
device and then you want the libraries

00:01:13,920 --> 00:01:18,320
to work on that data

00:01:15,680 --> 00:01:19,439
and then you return back to the user and

00:01:18,320 --> 00:01:21,520
then you want to bring it back

00:01:19,439 --> 00:01:22,880
so you want to have the ability to share

00:01:21,520 --> 00:01:26,000
this data with the thing

00:01:22,880 --> 00:01:29,280
open uh openmp

00:01:26,000 --> 00:01:32,560
and so for that we have uh introduced uh

00:01:29,280 --> 00:01:34,159
two new features uh uh one is

00:01:32,560 --> 00:01:36,479
declare variant which is already

00:01:34,159 --> 00:01:39,840
existing but we have enhanced it

00:01:36,479 --> 00:01:42,560
with some additional flaws and

00:01:39,840 --> 00:01:42,960
in fight auto we had the declare variant

00:01:42,560 --> 00:01:46,159
and

00:01:42,960 --> 00:01:46,720
the declare variant ad single form which

00:01:46,159 --> 00:01:49,439
was

00:01:46,720 --> 00:01:51,200
i think the sequence of declare variant

00:01:49,439 --> 00:01:53,759
with just a match clause

00:01:51,200 --> 00:01:54,720
now we have added additional argument of

00:01:53,759 --> 00:01:56,719
clauses

00:01:54,720 --> 00:01:58,240
which is the adjust argument up and down

00:01:56,719 --> 00:02:01,600
i'll talk about more of these

00:01:58,240 --> 00:02:04,320
two arguments of two clauses

00:02:01,600 --> 00:02:05,119
and so the way it works is uh just as a

00:02:04,320 --> 00:02:06,719
overview

00:02:05,119 --> 00:02:08,319
you have declare variant the sequence of

00:02:06,719 --> 00:02:10,160
declare variant and

00:02:08,319 --> 00:02:12,239
each of them will have a match clause so

00:02:10,160 --> 00:02:13,599
the match specifies under what condition

00:02:12,239 --> 00:02:17,280
you would replace

00:02:13,599 --> 00:02:19,440
the function which is following this

00:02:17,280 --> 00:02:20,400
declare variance which i call the base

00:02:19,440 --> 00:02:22,800
function

00:02:20,400 --> 00:02:24,879
what function replace the base function

00:02:22,800 --> 00:02:27,440
under what condition

00:02:24,879 --> 00:02:29,120
and the two new clauses will give you

00:02:27,440 --> 00:02:32,560
the ability to do some

00:02:29,120 --> 00:02:32,560
manipulation of the arguments

00:02:32,640 --> 00:02:36,560
so the other new one we have introduced

00:02:34,879 --> 00:02:40,720
is the begin and end

00:02:36,560 --> 00:02:43,200
declare variant so all the functions

00:02:40,720 --> 00:02:44,000
in this declare variant provide an

00:02:43,200 --> 00:02:46,000
alternate

00:02:44,000 --> 00:02:47,040
to a base function which is defined

00:02:46,000 --> 00:02:48,560
somewhere else

00:02:47,040 --> 00:02:50,720
and there's a naming scheme where you

00:02:48,560 --> 00:02:53,440
can name these functions

00:02:50,720 --> 00:02:54,800
as a replacement instead of using the

00:02:53,440 --> 00:02:57,040
base function

00:02:54,800 --> 00:02:58,159
and they are basically based on the

00:02:57,040 --> 00:03:01,599
context selector

00:02:58,159 --> 00:03:02,640
the naming of that so moving on to the

00:03:01,599 --> 00:03:04,640
clauses so we

00:03:02,640 --> 00:03:06,800
as i said there was initially uh in

00:03:04,640 --> 00:03:08,959
fighter to the match clause

00:03:06,800 --> 00:03:10,640
now we introduced the adjustar and the

00:03:08,959 --> 00:03:13,760
appender

00:03:10,640 --> 00:03:16,879
i'll explain more of these uh so

00:03:13,760 --> 00:03:18,879
basically whether i just think of

00:03:16,879 --> 00:03:20,480
i opposite either you can have nothing

00:03:18,879 --> 00:03:22,480
or need device pointer

00:03:20,480 --> 00:03:23,760
so these are the two currently provided

00:03:22,480 --> 00:03:25,440
ones

00:03:23,760 --> 00:03:27,200
and the append arg is where you can

00:03:25,440 --> 00:03:29,040
append an argument like an interrupt

00:03:27,200 --> 00:03:32,560
argument

00:03:29,040 --> 00:03:35,599
and the variant function which is uh

00:03:32,560 --> 00:03:36,319
defined in the match in this variant

00:03:35,599 --> 00:03:39,440
function

00:03:36,319 --> 00:03:40,720
is the specialized function uh or what

00:03:39,440 --> 00:03:42,720
we call the variant function

00:03:40,720 --> 00:03:45,040
which will be used instead of the base

00:03:42,720 --> 00:03:49,120
function basa

00:03:45,040 --> 00:03:50,640
function name so similarly in fortran

00:03:49,120 --> 00:03:53,680
you have the declare variant

00:03:50,640 --> 00:03:55,120
but one thing you notice is as in photon

00:03:53,680 --> 00:03:57,360
language you cannot have anything in the

00:03:55,120 --> 00:03:59,280
global scope you cannot have any pragmas

00:03:57,360 --> 00:04:00,959
in the global scope so you don't see

00:03:59,280 --> 00:04:04,480
that begin and end variant

00:04:00,959 --> 00:04:07,280
versions of the thing in fortran

00:04:04,480 --> 00:04:10,159
you just have just the declare variant

00:04:07,280 --> 00:04:11,840
which can be used inside a function

00:04:10,159 --> 00:04:15,040
and that's because of the restriction

00:04:11,840 --> 00:04:17,359
the way the language is

00:04:15,040 --> 00:04:19,440
so next moving on to the match clause so

00:04:17,359 --> 00:04:19,840
match clause gives you the ability to

00:04:19,440 --> 00:04:21,440
sell

00:04:19,840 --> 00:04:23,680
selectively replace the original

00:04:21,440 --> 00:04:26,080
function with the variant

00:04:23,680 --> 00:04:26,880
the other key function is that you can

00:04:26,080 --> 00:04:29,680
write code

00:04:26,880 --> 00:04:30,080
which only your compiler can recognize

00:04:29,680 --> 00:04:31,840
and

00:04:30,080 --> 00:04:33,440
will be also will be skipped by other

00:04:31,840 --> 00:04:33,919
compilers which don't recognize that

00:04:33,440 --> 00:04:36,080
code

00:04:33,919 --> 00:04:38,720
so say let's say you want to use some

00:04:36,080 --> 00:04:41,120
customized inline sm or intrinsic

00:04:38,720 --> 00:04:42,400
and your compiler supports it but other

00:04:41,120 --> 00:04:44,960
compilers don't

00:04:42,400 --> 00:04:46,400
support it but you want this compiler uh

00:04:44,960 --> 00:04:49,440
this code to be portable

00:04:46,400 --> 00:04:53,280
so you can use these uh match clauses

00:04:49,440 --> 00:04:54,880
to selectively align this code

00:04:53,280 --> 00:04:57,759
by other compilers but only your

00:04:54,880 --> 00:04:59,759
compiler can think recognize it

00:04:57,759 --> 00:05:00,960
so here are some examples of the match

00:04:59,759 --> 00:05:03,039
clause

00:05:00,960 --> 00:05:04,160
so the first one you have a match and

00:05:03,039 --> 00:05:06,960
you have a context

00:05:04,160 --> 00:05:08,080
dispatch so basically this is saying

00:05:06,960 --> 00:05:11,280
anytime i

00:05:08,080 --> 00:05:12,880
encounter a dispatch construct replace

00:05:11,280 --> 00:05:16,560
the call in that construct

00:05:12,880 --> 00:05:19,759
with this variant so the next

00:05:16,560 --> 00:05:20,080
uh example is where you want to say oh

00:05:19,759 --> 00:05:21,520
for

00:05:20,080 --> 00:05:23,280
when you're compiling for this

00:05:21,520 --> 00:05:25,440
architecture gen

00:05:23,280 --> 00:05:27,120
then compile this code and skip this

00:05:25,440 --> 00:05:30,000
code so this is where you could

00:05:27,120 --> 00:05:31,600
use uh gen specific optimizations or

00:05:30,000 --> 00:05:33,759
assembly or intrinsic

00:05:31,600 --> 00:05:36,840
and other compilers can skip that code

00:05:33,759 --> 00:05:38,880
without having any syntax

00:05:36,840 --> 00:05:40,960
errors and then the

00:05:38,880 --> 00:05:42,160
other one is where you you can use a

00:05:40,960 --> 00:05:44,000
kind no host

00:05:42,160 --> 00:05:46,400
so basically you you want to have

00:05:44,000 --> 00:05:49,039
special specialized code for host or

00:05:46,400 --> 00:05:50,000
for the device so when you specify no

00:05:49,039 --> 00:05:52,800
host

00:05:50,000 --> 00:05:54,320
basically that code will be enabled or

00:05:52,800 --> 00:05:56,319
that variant will be enabled

00:05:54,320 --> 00:05:57,680
only when you're compiling for the

00:05:56,319 --> 00:06:00,000
device

00:05:57,680 --> 00:06:00,800
and when you're compiling for the host

00:06:00,000 --> 00:06:04,479
that code will be

00:06:00,800 --> 00:06:05,360
skipped and similarly when you specify a

00:06:04,479 --> 00:06:06,880
kind host

00:06:05,360 --> 00:06:08,880
the code which you use here will be

00:06:06,880 --> 00:06:10,639
skipped and only

00:06:08,880 --> 00:06:13,840
for the will be skipped for the device

00:06:10,639 --> 00:06:13,840
but it will be used for the host

00:06:14,720 --> 00:06:17,840
so next i mean so don't know the clauses

00:06:16,960 --> 00:06:19,120
i'm going to go

00:06:17,840 --> 00:06:21,360
dive a little more into the i think

00:06:19,120 --> 00:06:24,080
clause so the append clause

00:06:21,360 --> 00:06:24,479
so open clause provides you the ability

00:06:24,080 --> 00:06:28,240
to

00:06:24,479 --> 00:06:30,880
add additional arguments so

00:06:28,240 --> 00:06:31,440
the first i mean currently we so we only

00:06:30,880 --> 00:06:33,759
allow

00:06:31,440 --> 00:06:35,600
the interrupt operation construct to

00:06:33,759 --> 00:06:39,039
provide an interrupt type

00:06:35,600 --> 00:06:40,000
add an interrupt type and i'm not going

00:06:39,039 --> 00:06:42,400
to go

00:06:40,000 --> 00:06:43,039
too much into details on this interrupt

00:06:42,400 --> 00:06:46,319
object

00:06:43,039 --> 00:06:50,160
i would recommend you to watch the

00:06:46,319 --> 00:06:51,919
talk by tomskland on the interrupt

00:06:50,160 --> 00:06:55,199
construct which will also be available

00:06:51,919 --> 00:06:57,440
on the openmp website

00:06:55,199 --> 00:07:00,000
so the way it works is the argument is

00:06:57,440 --> 00:07:02,000
constructed as if an interrupt object

00:07:00,000 --> 00:07:03,919
interrupt construct was encountered with

00:07:02,000 --> 00:07:05,840
an init clause

00:07:03,919 --> 00:07:07,360
and the arguments are passed in the same

00:07:05,840 --> 00:07:08,160
order as they are specified in the

00:07:07,360 --> 00:07:11,840
variant

00:07:08,160 --> 00:07:12,800
function and once this construct for the

00:07:11,840 --> 00:07:16,800
variant is

00:07:12,800 --> 00:07:18,720
completed this object is destroyed

00:07:16,800 --> 00:07:20,000
so these are the simple rules but a lot

00:07:18,720 --> 00:07:22,400
more details you can

00:07:20,000 --> 00:07:23,280
uh attend the other watch the other

00:07:22,400 --> 00:07:25,360
presentation

00:07:23,280 --> 00:07:27,120
where tom will go into much deeper

00:07:25,360 --> 00:07:32,160
details of how the interrupt

00:07:27,120 --> 00:07:35,520
object works uh next is adjust argument

00:07:32,160 --> 00:07:38,080
so the way you want to do is suppose you

00:07:35,520 --> 00:07:39,120
transfer some data onto the device and

00:07:38,080 --> 00:07:43,039
now you want to

00:07:39,120 --> 00:07:44,960
pass that device pointer to your library

00:07:43,039 --> 00:07:46,479
so you can you have the ability to say

00:07:44,960 --> 00:07:48,479
adjust the argument and say that

00:07:46,479 --> 00:07:50,639
this argument i need to be a device

00:07:48,479 --> 00:07:52,960
pointer

00:07:50,639 --> 00:07:54,960
so the way it works is if the argument

00:07:52,960 --> 00:07:57,440
provided as a host pointer

00:07:54,960 --> 00:07:58,560
we would translate it using the use

00:07:57,440 --> 00:08:00,720
device pointer and

00:07:58,560 --> 00:08:02,639
look up and find the device pointer so

00:08:00,720 --> 00:08:04,800
the device point will be passed

00:08:02,639 --> 00:08:06,080
if the argument is already a device

00:08:04,800 --> 00:08:08,400
pointer

00:08:06,080 --> 00:08:09,599
then it is not modified it's just passed

00:08:08,400 --> 00:08:11,680
as is

00:08:09,599 --> 00:08:13,280
and in case you cannot modify it because

00:08:11,680 --> 00:08:15,120
the device pointer does not the

00:08:13,280 --> 00:08:16,160
corresponding device point on the device

00:08:15,120 --> 00:08:18,400
does not exist

00:08:16,160 --> 00:08:20,240
then you would be passing a null value

00:08:18,400 --> 00:08:21,919
where the

00:08:20,240 --> 00:08:23,360
variant function can check if it's a

00:08:21,919 --> 00:08:24,319
null value then there's something wrong

00:08:23,360 --> 00:08:27,199
with the

00:08:24,319 --> 00:08:28,160
conversion to a device pointer the user

00:08:27,199 --> 00:08:31,759
can also say

00:08:28,160 --> 00:08:33,839
uh i think the adjust modifies nothing

00:08:31,759 --> 00:08:37,839
so basically this implies don't modify

00:08:33,839 --> 00:08:37,839
the argument pass it pass it as is

00:08:38,560 --> 00:08:42,719
okay the next key feature which was

00:08:40,399 --> 00:08:44,320
added to enable this is the dispatch

00:08:42,719 --> 00:08:47,839
variant

00:08:44,320 --> 00:08:49,360
so the syntax for this in c plus plus is

00:08:47,839 --> 00:08:52,640
you have a omp

00:08:49,360 --> 00:08:54,320
uh dispatch construct uh followed by an

00:08:52,640 --> 00:08:56,160
expression statement

00:08:54,320 --> 00:08:57,600
and the expression statement is

00:08:56,160 --> 00:09:01,600
essentially a

00:08:57,600 --> 00:09:06,160
assignment of a call to some expression

00:09:01,600 --> 00:09:08,080
on a call and the clauses

00:09:06,160 --> 00:09:09,360
you can specify for this construct is

00:09:08,080 --> 00:09:12,959
the device

00:09:09,360 --> 00:09:15,279
depend no weight no variant

00:09:12,959 --> 00:09:16,320
uh no context and device is device

00:09:15,279 --> 00:09:18,959
pointer

00:09:16,320 --> 00:09:20,720
so the device depends on it and is

00:09:18,959 --> 00:09:24,000
device pointer already existed

00:09:20,720 --> 00:09:26,080
of 5.2 on a target construct uh

00:09:24,000 --> 00:09:28,560
the new two new ones are the no variant

00:09:26,080 --> 00:09:30,720
and no context

00:09:28,560 --> 00:09:32,399
so device is essentially saying you want

00:09:30,720 --> 00:09:36,880
to you want

00:09:32,399 --> 00:09:39,040
the you want whatever the memory

00:09:36,880 --> 00:09:40,399
when you say use device pointer you want

00:09:39,040 --> 00:09:44,080
that device

00:09:40,399 --> 00:09:47,519
pointer for that thing uh to translate

00:09:44,080 --> 00:09:49,120
that memory argument so similarly in

00:09:47,519 --> 00:09:52,320
fortran you have the ompr

00:09:49,120 --> 00:09:52,720
dispatch and same as c you have all

00:09:52,320 --> 00:09:55,680
these

00:09:52,720 --> 00:09:56,320
things but except it's more it's like a

00:09:55,680 --> 00:10:00,959
call

00:09:56,320 --> 00:10:05,200
uh target call with arguments in fortran

00:10:00,959 --> 00:10:08,000
and okay so the dispatch clause

00:10:05,200 --> 00:10:11,120
so the way it works is if that if no

00:10:08,000 --> 00:10:14,000
variant clause is present

00:10:11,120 --> 00:10:14,320
and it evaluates to true that means you

00:10:14,000 --> 00:10:16,079
do

00:10:14,320 --> 00:10:18,880
you would not substitute the call

00:10:16,079 --> 00:10:20,720
following this dispatch construct

00:10:18,880 --> 00:10:22,240
so you'll be just calling the base

00:10:20,720 --> 00:10:24,880
function

00:10:22,240 --> 00:10:26,959
if the no context clause is present and

00:10:24,880 --> 00:10:29,279
evaluates to true

00:10:26,959 --> 00:10:31,200
the dispersed the dispatch construct is

00:10:29,279 --> 00:10:34,079
not added to the construct set of the

00:10:31,200 --> 00:10:37,360
openmp context

00:10:34,079 --> 00:10:39,360
and this device pointer indicates that

00:10:37,360 --> 00:10:40,720
it's it's already a device pointer so

00:10:39,360 --> 00:10:42,959
you just pass it as

00:10:40,720 --> 00:10:44,000
is if the user is requested in the

00:10:42,959 --> 00:10:46,959
variant function

00:10:44,000 --> 00:10:47,680
that he needs a device pointer and the

00:10:46,959 --> 00:10:50,880
no

00:10:47,680 --> 00:10:53,120
no wait allows you to execute this

00:10:50,880 --> 00:10:54,320
construct asynchronously by adding it to

00:10:53,120 --> 00:10:58,560
the interrupt

00:10:54,320 --> 00:11:01,200
requirement set and the depend clause

00:10:58,560 --> 00:11:02,000
enables you to have dependence between

00:11:01,200 --> 00:11:05,200
other

00:11:02,000 --> 00:11:05,760
uh tasks and so you think you can be

00:11:05,200 --> 00:11:06,959
added

00:11:05,760 --> 00:11:09,839
it will be added to the interrupt

00:11:06,959 --> 00:11:09,839
requirements sets

00:11:10,800 --> 00:11:14,240
okay so now let's go on to the examples

00:11:13,040 --> 00:11:17,120
or would you i mean

00:11:14,240 --> 00:11:18,160
earlier before without these new

00:11:17,120 --> 00:11:21,519
features

00:11:18,160 --> 00:11:24,480
you would probably uh do selective

00:11:21,519 --> 00:11:25,760
coding using if devs so you would have

00:11:24,480 --> 00:11:27,680
an if dev host

00:11:25,760 --> 00:11:30,000
and so essentially saying if when you're

00:11:27,680 --> 00:11:32,399
compiling for host use this routine

00:11:30,000 --> 00:11:34,079
as you're compiling for something else

00:11:32,399 --> 00:11:36,320
use this

00:11:34,079 --> 00:11:37,920
thing function they have different

00:11:36,320 --> 00:11:39,600
behaviors

00:11:37,920 --> 00:11:41,279
now the problem with this is that you

00:11:39,600 --> 00:11:43,519
need to standardize what the defined

00:11:41,279 --> 00:11:46,560
macro is all the compilers need to know

00:11:43,519 --> 00:11:49,600
or host means this

00:11:46,560 --> 00:11:49,839
host function or cpu and else part will

00:11:49,600 --> 00:11:53,680
be

00:11:49,839 --> 00:11:55,440
other devices and then you could i mean

00:11:53,680 --> 00:11:56,720
you would want to also customize for

00:11:55,440 --> 00:11:59,680
different architectures

00:11:56,720 --> 00:12:02,000
but this doesn't provide it uh it in a

00:11:59,680 --> 00:12:05,279
sense it can provide it by using if dev

00:12:02,000 --> 00:12:05,279
host or architecture

00:12:06,000 --> 00:12:09,040
vendor something else so you could have

00:12:08,000 --> 00:12:11,920
a bunch of

00:12:09,040 --> 00:12:13,920
things if there's macros but then again

00:12:11,920 --> 00:12:17,680
you have to standardize all that

00:12:13,920 --> 00:12:19,360
so you would need uh you would need to

00:12:17,680 --> 00:12:20,959
coordinate with all the other compiler

00:12:19,360 --> 00:12:22,880
developers i have some sort of standard

00:12:20,959 --> 00:12:25,519
to be able to find this

00:12:22,880 --> 00:12:26,320
the other thing is that in with this if

00:12:25,519 --> 00:12:29,440
def

00:12:26,320 --> 00:12:30,240
any call which is uh calling this

00:12:29,440 --> 00:12:32,800
routine

00:12:30,240 --> 00:12:33,839
will get replaced in the code you cannot

00:12:32,800 --> 00:12:35,519
selectively say

00:12:33,839 --> 00:12:37,360
only in this section of the code i want

00:12:35,519 --> 00:12:39,200
it to be replaced and not replaced in

00:12:37,360 --> 00:12:41,279
other calls

00:12:39,200 --> 00:12:43,040
and so an example would be when you're

00:12:41,279 --> 00:12:44,160
compiling for the host and any host

00:12:43,040 --> 00:12:45,920
calls you want to do

00:12:44,160 --> 00:12:47,600
you don't want to do a replacement but

00:12:45,920 --> 00:12:49,120
when you're compiling for a target

00:12:47,600 --> 00:12:50,800
all the target calls you want to do a

00:12:49,120 --> 00:12:52,880
replacement so

00:12:50,800 --> 00:12:55,440
it doesn't provide you the that

00:12:52,880 --> 00:12:58,800
capability with the if devs

00:12:55,440 --> 00:12:59,440
so you can basically use the omp declare

00:12:58,800 --> 00:13:02,880
variant

00:12:59,440 --> 00:13:05,519
construct to get this functionality

00:13:02,880 --> 00:13:06,000
so here you you have a declare variant

00:13:05,519 --> 00:13:09,279
and i say

00:13:06,000 --> 00:13:10,800
when batch devices host right then use

00:13:09,279 --> 00:13:12,800
this function

00:13:10,800 --> 00:13:13,920
and then i have another declare variant

00:13:12,800 --> 00:13:16,959
when the device is

00:13:13,920 --> 00:13:19,440
no host then use this so all

00:13:16,959 --> 00:13:20,560
openmp compatible compilers will be able

00:13:19,440 --> 00:13:22,720
to handle this

00:13:20,560 --> 00:13:24,639
construct so we don't it's already sort

00:13:22,720 --> 00:13:25,360
of like a standard now so you don't need

00:13:24,639 --> 00:13:27,680
to go about

00:13:25,360 --> 00:13:28,959
trying to define macros to standardize

00:13:27,680 --> 00:13:32,480
that

00:13:28,959 --> 00:13:34,000
and the thing is that when you're

00:13:32,480 --> 00:13:36,000
compiling for the host

00:13:34,000 --> 00:13:38,079
this code is selected and this code is

00:13:36,000 --> 00:13:38,720
skipped it you completely ignore this

00:13:38,079 --> 00:13:41,120
code

00:13:38,720 --> 00:13:42,000
and when you're compiling for the device

00:13:41,120 --> 00:13:43,839
you just

00:13:42,000 --> 00:13:45,360
consider the code which has a kind no

00:13:43,839 --> 00:13:49,120
host and you skip this

00:13:45,360 --> 00:13:50,800
code which has the host so now here's an

00:13:49,120 --> 00:13:51,360
example of how you would use all these

00:13:50,800 --> 00:13:53,839
uh

00:13:51,360 --> 00:13:55,440
variant dispatch function so let's

00:13:53,839 --> 00:13:58,240
assume you have a math library

00:13:55,440 --> 00:13:59,600
by match library and you have sgm which

00:13:58,240 --> 00:14:03,760
is a customized

00:13:59,600 --> 00:14:05,519
gpu routine so you have a

00:14:03,760 --> 00:14:07,839
your regular arguments and then i have

00:14:05,519 --> 00:14:11,440
an additional argument interrupt object

00:14:07,839 --> 00:14:14,880
yeah so i want to replace

00:14:11,440 --> 00:14:17,120
all calls all the calls of s gem

00:14:14,880 --> 00:14:17,120
with

00:14:18,320 --> 00:14:21,680
and i want i want to do it selectively i

00:14:20,639 --> 00:14:24,160
don't want to replace

00:14:21,680 --> 00:14:25,040
every every call but i want to say when

00:14:24,160 --> 00:14:27,519
you match

00:14:25,040 --> 00:14:28,320
when you when the matches when the

00:14:27,519 --> 00:14:31,360
function is under

00:14:28,320 --> 00:14:34,480
this dispatch construct and

00:14:31,360 --> 00:14:38,880
your offload device is gen

00:14:34,480 --> 00:14:41,279
and you you you do the replacement

00:14:38,880 --> 00:14:42,720
and once you select for replacement now

00:14:41,279 --> 00:14:45,600
i want you to give me

00:14:42,720 --> 00:14:46,959
the device pointers for abc so the first

00:14:45,600 --> 00:14:47,760
three arguments i want the device

00:14:46,959 --> 00:14:49,120
pointer

00:14:47,760 --> 00:14:50,959
and then i want you to append the

00:14:49,120 --> 00:14:54,639
interrupt object

00:14:50,959 --> 00:14:57,199
so when when this function is used under

00:14:54,639 --> 00:14:57,680
dispatch construct and you're compiling

00:14:57,199 --> 00:15:00,720
for

00:14:57,680 --> 00:15:02,959
architecture which is gen then you would

00:15:00,720 --> 00:15:04,639
replace the arguments abc with the

00:15:02,959 --> 00:15:08,000
device pointer

00:15:04,639 --> 00:15:13,040
and append an interrupt object

00:15:08,000 --> 00:15:15,279
and call this function as gem gpu

00:15:13,040 --> 00:15:16,880
so now let's see how it works in the

00:15:15,279 --> 00:15:19,600
user code

00:15:16,880 --> 00:15:21,199
so here's a program in the user code you

00:15:19,600 --> 00:15:22,320
would include your math dot edge which

00:15:21,199 --> 00:15:25,600
has that

00:15:22,320 --> 00:15:27,600
declare variant function so you have uh

00:15:25,600 --> 00:15:29,279
three or four variables and then you

00:15:27,600 --> 00:15:32,959
would initialize these

00:15:29,279 --> 00:15:35,120
and then you would call as gem abc this

00:15:32,959 --> 00:15:36,959
this is now the you ma this doesn't

00:15:35,120 --> 00:15:40,079
match the variant because this is not

00:15:36,959 --> 00:15:41,519
under a dispatch construct so this does

00:15:40,079 --> 00:15:43,440
not get replaced

00:15:41,519 --> 00:15:45,040
so here you'll be calling only the host

00:15:43,440 --> 00:15:48,240
version

00:15:45,040 --> 00:15:48,560
next you enter the target data and then

00:15:48,240 --> 00:15:50,560
you

00:15:48,560 --> 00:15:51,759
map all these three variables onto the

00:15:50,560 --> 00:15:55,360
device

00:15:51,759 --> 00:15:57,440
on a device my device id is something

00:15:55,360 --> 00:15:59,199
and then you would have you know you

00:15:57,440 --> 00:16:00,160
want to replace all the

00:15:59,199 --> 00:16:02,160
let's say you want to call the

00:16:00,160 --> 00:16:04,480
specialized version so you would say

00:16:02,160 --> 00:16:07,759
pragma omp dispatch device

00:16:04,480 --> 00:16:10,079
and put in the device id and then you

00:16:07,759 --> 00:16:11,920
provide this function so now that

00:16:10,079 --> 00:16:15,440
variant automatically kicks in

00:16:11,920 --> 00:16:16,079
and replaces this and uses the device

00:16:15,440 --> 00:16:18,399
pointers

00:16:16,079 --> 00:16:20,079
so the device these were already mapped

00:16:18,399 --> 00:16:22,720
and sent onto the device

00:16:20,079 --> 00:16:23,920
so you you would query and get the

00:16:22,720 --> 00:16:25,680
device pointers

00:16:23,920 --> 00:16:27,440
and you you would call the specialized

00:16:25,680 --> 00:16:28,399
device version you'll call the gp

00:16:27,440 --> 00:16:30,399
version

00:16:28,399 --> 00:16:31,440
and similarly you can repeat that again

00:16:30,399 --> 00:16:33,759
but

00:16:31,440 --> 00:16:37,440
uh buy something different call the

00:16:33,759 --> 00:16:41,680
device version

00:16:37,440 --> 00:16:43,440
and so that concludes my talk and just

00:16:41,680 --> 00:16:45,120
want to mention that all the recording

00:16:43,440 --> 00:16:48,639
and the slides will be available

00:16:45,120 --> 00:16:51,839
on the openmp website

00:16:48,639 --> 00:16:51,839

YouTube URL: https://www.youtube.com/watch?v=ruugaX95gIs


