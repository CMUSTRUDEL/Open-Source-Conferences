Title: Where Did My Performance Go?
Publication date: 2015-12-13
Playlist: OpenMPCon 2015 Developers Conference
Description: 
	Mark Bull, EPCC, University of Edinburgh
OpenMP Con 2015 - Aachen, Germany - September 2015
Slides at http://openmpcon.org/wp-content/uploads/openmpcon2015-mark-bull-performance.pdf

Understanding how and why OpenMP programs lose performance is difficult! In this talk I will attempt to enumerate all the possible ways that OpenMP programs can deliver less than ideal speedup, divided into six main categories: lack of parallelism, load imbalance, synchronisation, communication, hardware contention and compiler non-optimisation. For each category, I will explain why it happens, and offer some possible solutions.
Captions: 
	00:00:03,750 --> 00:00:12,820
and there are quite a few people in the

00:00:08,020 --> 00:00:21,310
audience who are very experienced OpenMP

00:00:12,820 --> 00:00:23,080
programmers or educators and so perhaps

00:00:21,310 --> 00:00:24,519
you might think of this I'm listen

00:00:23,080 --> 00:00:28,029
something you might just know this stuff

00:00:24,519 --> 00:00:29,470
already okay so that's fine but maybe

00:00:28,029 --> 00:00:32,439
you want to think about as we go along

00:00:29,470 --> 00:00:34,840
is you know why are these why do these

00:00:32,439 --> 00:00:37,420
some of these things trip users up why

00:00:34,840 --> 00:00:39,930
don't users know these things and what

00:00:37,420 --> 00:00:44,400
can we do to make life better for them

00:00:39,930 --> 00:00:48,130
okay so a little bit about Gunnar at me

00:00:44,400 --> 00:00:51,850
so i've been i've been teaching OpenMP

00:00:48,130 --> 00:00:54,130
for over 15 years now thanks sir from

00:00:51,850 --> 00:01:00,400
vary from the very early days of OpenMP

00:00:54,130 --> 00:01:01,990
to students and to anti scientists I was

00:01:00,400 --> 00:01:03,520
I had the privilege of being the chair

00:01:01,990 --> 00:01:07,330
of the openmp language committee for

00:01:03,520 --> 00:01:09,610
about five years or so and currently I I

00:01:07,330 --> 00:01:13,450
answer I asked to answer questions on

00:01:09,610 --> 00:01:18,040
the openmp forum so that's just that's a

00:01:13,450 --> 00:01:20,470
open forum where anybody can just get an

00:01:18,040 --> 00:01:23,410
account and ask a question about openmp

00:01:20,470 --> 00:01:26,020
and I kind of take it upon myself to try

00:01:23,410 --> 00:01:30,310
and as best i can to to answer those

00:01:26,020 --> 00:01:31,870
questions that's very welcome i enjoy i

00:01:30,310 --> 00:01:34,990
really enjoy doing it it's a lot of fun

00:01:31,870 --> 00:01:36,520
i learned stuff I don't you know I I go

00:01:34,990 --> 00:01:38,350
I have to go grubbing around in the

00:01:36,520 --> 00:01:41,110
deity corners of the standard sometimes

00:01:38,350 --> 00:01:43,720
sitting there and and I learn stuff I

00:01:41,110 --> 00:01:45,280
know stuff to from doing okay so this is

00:01:43,720 --> 00:01:48,310
kind of a collective some accumulated

00:01:45,280 --> 00:01:49,570
wisdom and so in particularly so it's

00:01:48,310 --> 00:01:52,300
the kind of thing that you maybe don't

00:01:49,570 --> 00:01:54,120
find in some of the tutorials okay it's

00:01:52,300 --> 00:01:57,280
the kind of thing we tend to leave out

00:01:54,120 --> 00:01:59,409
and not to talk about so i hope you

00:01:57,280 --> 00:02:01,590
might find it useful if you're in a you

00:01:59,409 --> 00:02:06,159
know if you're a relative newcomer to

00:02:01,590 --> 00:02:07,960
openmp if it's a if you're not let's

00:02:06,159 --> 00:02:09,789
have a think about why these things are

00:02:07,960 --> 00:02:12,390
you know why these things trip uses up

00:02:09,789 --> 00:02:15,500
or why don't users know this stuff

00:02:12,390 --> 00:02:18,569
and what could we do to make that better

00:02:15,500 --> 00:02:21,660
okay so it really is just a rag bag

00:02:18,569 --> 00:02:24,650
collection in no particular order so

00:02:21,660 --> 00:02:28,380
let's stuff off of the beginning okay

00:02:24,650 --> 00:02:30,570
typing in directives okay what happens

00:02:28,380 --> 00:02:34,680
if i mistyped the Sentinel in an

00:02:30,570 --> 00:02:36,990
open-air p directive okay well typically

00:02:34,680 --> 00:02:40,050
the compiler just swallows it and

00:02:36,990 --> 00:02:43,670
ignores it okay so you know if I

00:02:40,050 --> 00:02:46,370
unfortunate if i type ! dollar or mp4

00:02:43,670 --> 00:02:49,739
chunka pilot says that's a comment I

00:02:46,370 --> 00:02:52,170
leaking all that for you or in see if I

00:02:49,739 --> 00:02:55,860
say hatch pragma OPM or hatch pragma

00:02:52,170 --> 00:02:57,390
openmp Kabbalah says put that's a pragma

00:02:55,860 --> 00:03:00,030
well I don't know anything about that

00:02:57,390 --> 00:03:01,470
i'll just ignore it for you okay so it

00:03:00,030 --> 00:03:03,480
doesn't you don't get any error message

00:03:01,470 --> 00:03:06,720
for doing that so you need to be really

00:03:03,480 --> 00:03:08,010
careful and then okay sometimes you

00:03:06,720 --> 00:03:10,860
might miss out on a bit of performance

00:03:08,010 --> 00:03:12,720
by failing to put in a a parallel live

00:03:10,860 --> 00:03:15,180
directive but sometimes it can be really

00:03:12,720 --> 00:03:19,799
serious right if I if I say hash program

00:03:15,180 --> 00:03:21,870
at OPM atomic the compiler will happily

00:03:19,799 --> 00:03:25,709
ignore that now I have a race condition

00:03:21,870 --> 00:03:27,480
great okay fantastic okay so what can I

00:03:25,709 --> 00:03:29,220
do about that well one thing you can

00:03:27,480 --> 00:03:31,489
possibly do is especially if you know

00:03:29,220 --> 00:03:35,400
you've got a particular typing habit

00:03:31,489 --> 00:03:37,079
okay and you know I mean I'm on those

00:03:35,400 --> 00:03:40,110
people who cannot for the life of me

00:03:37,079 --> 00:03:42,840
type the word parallel I don't know why

00:03:40,110 --> 00:03:44,310
okay but it's just one of my comment

00:03:42,840 --> 00:03:47,040
might influence it's something I make a

00:03:44,310 --> 00:03:49,200
typo foot for everything all the time if

00:03:47,040 --> 00:03:51,570
you know what your common typos are

00:03:49,200 --> 00:03:55,470
write yourself a script to scrape your

00:03:51,570 --> 00:03:57,780
code for that that's it okay could

00:03:55,470 --> 00:04:01,950
compilers do a better job for us yeah

00:03:57,780 --> 00:04:04,140
maybe it's kind of hard right but yeah

00:04:01,950 --> 00:04:06,209
could you could you figure out what the

00:04:04,140 --> 00:04:07,860
common ones are into and embrace

00:04:06,209 --> 00:04:10,739
warnings and saying did you really mean

00:04:07,860 --> 00:04:12,829
that you know no i don't know maybe you

00:04:10,739 --> 00:04:12,829
could

00:04:14,829 --> 00:04:28,280
Thank maybe okay so something that's you

00:04:26,150 --> 00:04:29,870
know it's a feature not well appreciated

00:04:28,280 --> 00:04:32,720
you know how do you write code that

00:04:29,870 --> 00:04:35,840
works without open open NP as well okay

00:04:32,720 --> 00:04:38,419
so there is this macro that's defined if

00:04:35,840 --> 00:04:39,650
if code is compiled with open and peace

00:04:38,419 --> 00:04:42,169
which so you can use that to do

00:04:39,650 --> 00:04:45,380
conditional compilation very big I don't

00:04:42,169 --> 00:04:47,240
think you tend to make much of that and

00:04:45,380 --> 00:04:49,310
as those dummy library routines that you

00:04:47,240 --> 00:04:51,020
can use if you want to if you want to

00:04:49,310 --> 00:04:53,620
link a dummy version I don't think many

00:04:51,020 --> 00:04:57,400
people make much use of that either

00:04:53,620 --> 00:05:03,889
maybe they don't need to I don't know

00:04:57,400 --> 00:05:05,870
okay the parallel regions okay so one

00:05:03,889 --> 00:05:09,949
common thing that I see especially on

00:05:05,870 --> 00:05:12,039
the forum posts is ok so I wrote this I

00:05:09,949 --> 00:05:16,160
wrote my little bit of an MP test code

00:05:12,039 --> 00:05:18,470
and it flowed down okay and I'm

00:05:16,160 --> 00:05:22,340
disciplina I'm disappointed what did I

00:05:18,470 --> 00:05:24,199
do wrong well most likely what what what

00:05:22,340 --> 00:05:26,360
users tend to do wrong the first time is

00:05:24,199 --> 00:05:28,180
that they try to power lay something

00:05:26,360 --> 00:05:30,770
that takes a very short amount of time

00:05:28,180 --> 00:05:32,599
ok so the overhead of executing parallel

00:05:30,770 --> 00:05:34,610
region is typically in the kind of tens

00:05:32,599 --> 00:05:36,229
of microseconds range now obviously that

00:05:34,610 --> 00:05:38,000
depends on the hardware and the compiler

00:05:36,229 --> 00:05:39,919
and the number of threads but it's you

00:05:38,000 --> 00:05:43,550
know it's it's it's around there

00:05:39,919 --> 00:05:45,889
somewhere ok so obviously the sequential

00:05:43,550 --> 00:05:47,780
execution time has to be several times

00:05:45,889 --> 00:05:54,620
more than that to make it worth power

00:05:47,780 --> 00:05:57,349
right so if you don't know that there's

00:05:54,620 --> 00:05:59,449
an if clause there you can use to say ok

00:05:57,349 --> 00:06:04,370
now if I think if there's enough work

00:05:59,449 --> 00:06:06,139
here go parallel else don't ok because

00:06:04,370 --> 00:06:07,849
actually go you know that's ok the

00:06:06,139 --> 00:06:11,500
overhead on one thread is typically

00:06:07,849 --> 00:06:14,389
really really really much smaller ok and

00:06:11,500 --> 00:06:17,840
so you know a lot less than a micro

00:06:14,389 --> 00:06:20,360
second typically ok so it's ok to leave

00:06:17,840 --> 00:06:22,130
parallel regions in there and have them

00:06:20,360 --> 00:06:27,050
and have them run on one thread that's

00:06:22,130 --> 00:06:29,060
ok I wrote these benchmarks using years

00:06:27,050 --> 00:06:31,099
ago they're still alive vendors still

00:06:29,060 --> 00:06:33,349
use them some people find them really

00:06:31,099 --> 00:06:36,260
interesting too if you want to know what

00:06:33,349 --> 00:06:38,710
the overheads are of various OpenMP

00:06:36,260 --> 00:06:43,630
directives on your particular system

00:06:38,710 --> 00:06:43,630
then please please use them

00:06:45,470 --> 00:06:48,470
ok

00:06:48,650 --> 00:06:54,979
another common problem that early

00:06:51,380 --> 00:06:57,560
adopters have is ok I do I get this

00:06:54,979 --> 00:06:59,570
thing about parallel loops right I have

00:06:57,560 --> 00:07:02,780
to make sure that my loop iterations are

00:06:59,570 --> 00:07:07,100
independent how do I have my figure that

00:07:02,780 --> 00:07:10,160
out ok well is it is a dirty little

00:07:07,100 --> 00:07:13,789
trick hey take my loop and run it

00:07:10,160 --> 00:07:17,240
backwards ok and did I get the right

00:07:13,789 --> 00:07:19,240
answer if the answer is yes then most

00:07:17,240 --> 00:07:21,860
likely the iterations were independent

00:07:19,240 --> 00:07:27,169
ok it's not infallible but it's actually

00:07:21,860 --> 00:07:30,919
quite hard to construct a counter exists

00:07:27,169 --> 00:07:32,810
quick and quick and dirty thing of

00:07:30,919 --> 00:07:35,090
course you know maybe we'd like to have

00:07:32,810 --> 00:07:38,300
Auto paralyzing technology in all our

00:07:35,090 --> 00:07:41,419
compilers but maybe that's just never

00:07:38,300 --> 00:07:43,729
going to happen so I'm quite interested

00:07:41,419 --> 00:07:45,979
to hear all this discussion about open

00:07:43,729 --> 00:07:49,550
ACC and the different philosophy between

00:07:45,979 --> 00:07:52,849
now should we rely on order parallelism

00:07:49,550 --> 00:07:55,430
or should we not no no openmp is always

00:07:52,849 --> 00:07:57,289
taken this point of view that we do not

00:07:55,430 --> 00:08:01,250
rely on compilers having Otto Otto

00:07:57,289 --> 00:08:02,660
paralyzing technology but there's a lot

00:08:01,250 --> 00:08:05,479
of smart people out there there's a lot

00:08:02,660 --> 00:08:08,690
of smart compilers out there it seems a

00:08:05,479 --> 00:08:12,470
shame to me that you know ok so I I know

00:08:08,690 --> 00:08:14,840
that people like Oracle have done the

00:08:12,470 --> 00:08:17,419
auto scoping type staff and there are

00:08:14,840 --> 00:08:20,659
tools out there but it seems a shame to

00:08:17,419 --> 00:08:23,630
me that there isn't a good way to

00:08:20,659 --> 00:08:26,320
leverage that auto paralyzation

00:08:23,630 --> 00:08:31,849
technology when it where it does exist

00:08:26,320 --> 00:08:33,979
into openmp programs that seems that

00:08:31,849 --> 00:08:36,709
seems a shame ok so I understand

00:08:33,979 --> 00:08:39,770
perfectly why OpenMP takes this point of

00:08:36,709 --> 00:08:41,510
view I think it's good and I think it's

00:08:39,770 --> 00:08:44,450
a whole you know it's an important

00:08:41,510 --> 00:08:46,339
reason why OpenMP is everywhere is that

00:08:44,450 --> 00:08:48,770
we don't have to it doesn't need this

00:08:46,339 --> 00:08:52,420
technology and it's actually relatively

00:08:48,770 --> 00:08:55,060
simple to implement ok so you can get a

00:08:52,420 --> 00:08:57,670
half-decent OpenMP implementation

00:08:55,060 --> 00:09:01,660
without huge amounts of effort and

00:08:57,670 --> 00:09:03,730
investment in your compiler but where

00:09:01,660 --> 00:09:07,210
those compilers do exist with that

00:09:03,730 --> 00:09:09,310
cleverness in it you can't use them okay

00:09:07,210 --> 00:09:11,380
we can't make use of that technology to

00:09:09,310 --> 00:09:17,500
make our lives easier as OpenMP programs

00:09:11,380 --> 00:09:18,850
very easy very easily so maybe maybe

00:09:17,500 --> 00:09:27,910
that's something we should think about

00:09:18,850 --> 00:09:29,380
more okay this is another one this this

00:09:27,910 --> 00:09:31,150
is something that we discussed about in

00:09:29,380 --> 00:09:34,390
the in the those of you might remember

00:09:31,150 --> 00:09:37,830
this this this was long discussions in

00:09:34,390 --> 00:09:41,800
the language committee at what point is

00:09:37,830 --> 00:09:44,430
this safe if I do this okay so if I say

00:09:41,800 --> 00:09:48,640
I went before schedule static no wait

00:09:44,430 --> 00:09:50,650
okay and I write some array a and then

00:09:48,640 --> 00:09:52,930
some sometime later I say o people or

00:09:50,650 --> 00:09:55,529
schedule static and I read those values

00:09:52,930 --> 00:09:59,650
is that safe is that a race crew program

00:09:55,529 --> 00:10:01,300
okay and the answer is e is okay we've

00:09:59,650 --> 00:10:05,320
made this clear in the in the spec yes

00:10:01,300 --> 00:10:08,260
it is ok that is that is ok you are

00:10:05,320 --> 00:10:11,410
guaranteed in this circumstances that

00:10:08,260 --> 00:10:12,970
the the thread that executed a

00:10:11,410 --> 00:10:15,520
particular iteration in the first of

00:10:12,970 --> 00:10:18,310
those loops will also execute that same

00:10:15,520 --> 00:10:22,180
iteration in the second loop so there is

00:10:18,310 --> 00:10:25,750
no cross thread data dependency there ok

00:10:22,180 --> 00:10:30,700
hmm you thought you you hate that right

00:10:25,750 --> 00:10:35,720
so yeah ok it's in right so then yes all

00:10:30,700 --> 00:10:39,720
right that does work ok and so

00:10:35,720 --> 00:10:41,460
okay all right so I say we just had a

00:10:39,720 --> 00:10:47,010
debate in the language committee about

00:10:41,460 --> 00:10:48,660
what is dynamic shared with me I can't

00:10:47,010 --> 00:10:55,760
believe that right surely we know that

00:10:48,660 --> 00:10:55,760
they're okay so yeah okay good

00:10:59,550 --> 00:11:05,190
nobody knows this okay everybody makes a

00:11:03,300 --> 00:11:07,230
wrong assumption here the default

00:11:05,190 --> 00:11:10,470
schedule for loops with no schedule

00:11:07,230 --> 00:11:16,490
applause it specified is implementation

00:11:10,470 --> 00:11:19,019
defined okay it is not static okay and

00:11:16,490 --> 00:11:30,540
practice I think in all implementations

00:11:19,019 --> 00:11:34,019
I know of it is static right yes it has

00:11:30,540 --> 00:11:35,640
to be one of them so it has to beat you

00:11:34,019 --> 00:11:38,430
know it has to be a choice from the

00:11:35,640 --> 00:11:41,579
openmp schedule list but that could be

00:11:38,430 --> 00:11:44,579
auto right so that I could be auto so in

00:11:41,579 --> 00:11:46,320
fact all bets are off right so so an

00:11:44,579 --> 00:11:49,649
implementation could say the default

00:11:46,320 --> 00:11:51,089
said my default schedule is auto right

00:11:49,649 --> 00:11:52,589
and which allows it to do anything it

00:11:51,089 --> 00:11:56,820
likes in terms of that very rapid

00:11:52,589 --> 00:12:00,149
iterations to threats okay nevertheless

00:11:56,820 --> 00:12:03,240
I think it's you know huge numbers of

00:12:00,149 --> 00:12:08,610
openmp codes out there do actually rely

00:12:03,240 --> 00:12:10,800
on this okay they just don't put a

00:12:08,610 --> 00:12:15,329
schedule clause and they assume it's

00:12:10,800 --> 00:12:19,560
going to be static and I hope that never

00:12:15,329 --> 00:12:22,649
comes back and bites people it does mean

00:12:19,560 --> 00:12:25,470
it does really mean that and effectively

00:12:22,649 --> 00:12:28,410
every implementer has to put static in

00:12:25,470 --> 00:12:34,490
there otherwise you tend to tend to

00:12:28,410 --> 00:12:34,490
disappoint customers so

00:12:37,080 --> 00:12:47,250
Yeah right yeah it should be right

00:12:43,830 --> 00:12:49,200
because the it can't break the program

00:12:47,250 --> 00:12:52,320
that your choice of your choice of

00:12:49,200 --> 00:12:54,480
mapping shouldn't break the program but

00:12:52,320 --> 00:12:59,670
but the performance will will suffer for

00:12:54,480 --> 00:13:01,800
sure yeah and you know I think there are

00:12:59,670 --> 00:13:02,880
I think this is this is unfortunate

00:13:01,800 --> 00:13:05,760
because I think it would you know I

00:13:02,880 --> 00:13:08,790
think you know some there are cases

00:13:05,760 --> 00:13:11,700
where it would be nice that the you know

00:13:08,790 --> 00:13:14,070
the vendor could make the choice here

00:13:11,700 --> 00:13:15,630
made but in fact they've got their hands

00:13:14,070 --> 00:13:17,160
type they've got ourselves into a

00:13:15,630 --> 00:13:22,130
situation where their hands are tied

00:13:17,160 --> 00:13:24,180
they can't do anything but okay right

00:13:22,130 --> 00:13:26,280
the other thing that people don't really

00:13:24,180 --> 00:13:28,140
also don't realize necessarily is that

00:13:26,280 --> 00:13:30,390
schedule static is not a complete

00:13:28,140 --> 00:13:31,950
specification it doesn't tell you how

00:13:30,390 --> 00:13:33,990
the hell you should devote how you

00:13:31,950 --> 00:13:36,480
should deal with the remainder when

00:13:33,990 --> 00:13:37,980
where if the number of iteration is just

00:13:36,480 --> 00:13:40,340
not divided exactly by the number of

00:13:37,980 --> 00:13:40,340
threads

00:13:48,169 --> 00:13:53,989
no it doesn't doesn't say that yeah

00:13:57,960 --> 00:14:01,730
Wade one okay

00:14:03,040 --> 00:14:09,579
so okay so one of the new things you

00:14:06,100 --> 00:14:11,259
have to do sometimes is if you've got if

00:14:09,579 --> 00:14:13,350
you decide you want to use static with a

00:14:11,259 --> 00:14:15,370
chunk size or dynamic with a chunk size

00:14:13,350 --> 00:14:19,750
somehow you've got to figure out what

00:14:15,370 --> 00:14:22,690
the right chunk size it okay now in my

00:14:19,750 --> 00:14:26,079
experience suing the chunk size is

00:14:22,690 --> 00:14:28,540
tricky and the reason it reason it's

00:14:26,079 --> 00:14:31,269
reason it's awkward is that the optimal

00:14:28,540 --> 00:14:35,380
chunk size can depend point strongly on

00:14:31,269 --> 00:14:37,600
the number of threads and you don't know

00:14:35,380 --> 00:14:39,610
how many threads you getting is okay so

00:14:37,600 --> 00:14:42,670
I've got a ship some code I've got to

00:14:39,610 --> 00:14:44,440
fix the chunk size somehow I'm going to

00:14:42,670 --> 00:14:46,990
but I don't know how many threads the

00:14:44,440 --> 00:14:49,000
users gonna tease okay so actually you

00:14:46,990 --> 00:14:51,459
know it's actually often a lot more

00:14:49,000 --> 00:14:53,980
robust is the thing you actually tune is

00:14:51,459 --> 00:14:58,690
not the chunk size but you tune the

00:14:53,980 --> 00:15:01,089
number of chunks per thread okay and

00:14:58,690 --> 00:15:03,100
then you derive the chunk size from that

00:15:01,089 --> 00:15:05,170
because chunk size expression doesn't

00:15:03,100 --> 00:15:08,350
have to be a compile time constants it

00:15:05,170 --> 00:15:10,240
can be a variable so tuning tuning the

00:15:08,350 --> 00:15:13,120
number of chunks that each thread gets

00:15:10,240 --> 00:15:16,829
tends to be a lot more robust against

00:15:13,120 --> 00:15:16,829
changing the number of threads than

00:15:17,850 --> 00:15:21,990
tuning the chunk size directly

00:15:25,190 --> 00:15:30,800
the openmp blatt it has these two ways

00:15:27,830 --> 00:15:34,700
of doing saying inside a parallel region

00:15:30,800 --> 00:15:39,140
I'd like one thread to execute this

00:15:34,700 --> 00:15:42,260
piece of code okay you know single we

00:15:39,140 --> 00:15:47,690
got master okay so they do something

00:15:42,260 --> 00:15:53,450
similar but different so which one

00:15:47,690 --> 00:15:56,510
should you use well in principle masters

00:15:53,450 --> 00:16:00,290
should have lower overheads okay so

00:15:56,510 --> 00:16:05,360
master simply translates to if my thread

00:16:00,290 --> 00:16:08,930
ID equals 0 else yeah no synchronization

00:16:05,360 --> 00:16:12,110
required it's a very very lightweight

00:16:08,930 --> 00:16:14,000
implementation single requires some

00:16:12,110 --> 00:16:18,020
synchronization because single says the

00:16:14,000 --> 00:16:20,480
first thread that gets here execute and

00:16:18,020 --> 00:16:23,180
all the others have to have to go and

00:16:20,480 --> 00:16:24,770
skip and sit in the bharatiya ok so the

00:16:23,180 --> 00:16:27,280
first thread that gets there has to set

00:16:24,770 --> 00:16:30,320
some flag which says I got here first

00:16:27,280 --> 00:16:32,750
was the other threads and then look at

00:16:30,320 --> 00:16:38,530
to say Oh some other thread got got that

00:16:32,750 --> 00:16:38,530
first get over it ok yes rude

00:16:45,649 --> 00:16:49,360
you can just think oh no way yeah

00:16:59,180 --> 00:17:03,110
so what's the master doing

00:17:11,920 --> 00:17:15,650
is it

00:17:13,790 --> 00:17:18,110
okay I thought it was kind of just

00:17:15,650 --> 00:17:19,640
distributed there but maybe not maybe

00:17:18,110 --> 00:17:24,260
I'm wrong

00:17:19,640 --> 00:17:25,880
yeah yeah it's handing off this is

00:17:24,260 --> 00:17:27,380
already doing stuff in the background

00:17:25,880 --> 00:17:31,610
that's interesting i don't really

00:17:27,380 --> 00:17:34,250
thought about that so this is a weird

00:17:31,610 --> 00:17:36,230
design decision so it's taken right at

00:17:34,250 --> 00:17:38,630
the very beginning of OpenMP to have

00:17:36,230 --> 00:17:41,780
this asymmetry between master and single

00:17:38,630 --> 00:17:43,990
okay single has a barrier by default

00:17:41,780 --> 00:17:47,510
which you can get rid of with no wait

00:17:43,990 --> 00:17:51,830
master has no barrier but you can add an

00:17:47,510 --> 00:17:57,380
explicit barrier no so why I've never

00:17:51,830 --> 00:17:59,890
understood that that was just weird no

00:17:57,380 --> 00:17:59,890
why whoa

00:18:14,350 --> 00:18:34,520
yeah I don't remember hmm sure yeah I

00:18:31,970 --> 00:18:42,320
mean yeah why doesn't have a barrier

00:18:34,520 --> 00:18:50,720
what so you can do must in their way

00:18:42,320 --> 00:18:53,680
that's what's the problem that's right

00:18:50,720 --> 00:18:53,680
yeah

00:18:58,440 --> 00:19:04,900
it's a bit weird okay something that

00:19:03,340 --> 00:19:06,970
nobody else nobody teaches is the

00:19:04,900 --> 00:19:11,230
fortran 90 array syntax and work share

00:19:06,970 --> 00:19:14,890
okay so this just to make just wake you

00:19:11,230 --> 00:19:16,690
if you don't know this exists and so the

00:19:14,890 --> 00:19:20,020
problem is if you have fortran 90

00:19:16,690 --> 00:19:23,050
erasing texts you don't have an explicit

00:19:20,020 --> 00:19:25,210
loop to paralyze and if you don't use

00:19:23,050 --> 00:19:28,210
work share then you have to refactor

00:19:25,210 --> 00:19:41,800
your code to to to expose explicit loops

00:19:28,210 --> 00:19:44,130
and so on no but yeah it's a shame I

00:19:41,800 --> 00:19:44,130
think

00:19:47,779 --> 00:19:53,239
no we don't deprecated we've never

00:19:51,559 --> 00:20:00,799
deprecated we've never really talked

00:19:53,239 --> 00:20:03,080
about deprecation so do it so don't

00:20:00,799 --> 00:20:05,210
bother just just just rewrite your home

00:20:03,080 --> 00:20:13,129
just write me write all your rape or it

00:20:05,210 --> 00:20:15,769
coders loops anyway oh such a common

00:20:13,129 --> 00:20:20,570
source of bugs okay uninitialized

00:20:15,769 --> 00:20:25,489
private variables can we not warn people

00:20:20,570 --> 00:20:28,059
about this right most of it is most of

00:20:25,489 --> 00:20:30,529
them are lexically in the construct

00:20:28,059 --> 00:20:33,080
because that's where you use private

00:20:30,529 --> 00:20:36,409
variables you know if I didn't assign

00:20:33,080 --> 00:20:39,279
you know if I see a use before declare

00:20:36,409 --> 00:20:42,320
something private see you use before

00:20:39,279 --> 00:20:45,200
before an assignment can we not can you

00:20:42,320 --> 00:20:47,059
not catch that in compilers first

00:20:45,200 --> 00:20:50,779
private is useful for tasks yes

00:20:47,059 --> 00:20:55,039
absolutely ok 44 regular for parallel

00:20:50,779 --> 00:20:56,839
regions and I thought and so on you can

00:20:55,039 --> 00:21:00,080
you of course you can use first private

00:20:56,839 --> 00:21:04,789
but it's more likely just to be in error

00:21:00,080 --> 00:21:10,609
ok so the use cases for first private

00:21:04,789 --> 00:21:14,239
are surprisingly rare ok especially with

00:21:10,609 --> 00:21:15,379
loops right so it's usually something

00:21:14,239 --> 00:21:17,119
you're good with you know there's going

00:21:15,379 --> 00:21:19,429
to be private to a limp iteration you're

00:21:17,119 --> 00:21:21,169
going to assign it and then use it so

00:21:19,429 --> 00:21:24,710
why do you want why do you want some

00:21:21,169 --> 00:21:26,989
initial value in there and so if every

00:21:24,710 --> 00:21:28,639
time you tell people if you think you

00:21:26,989 --> 00:21:31,940
want to use first private than you

00:21:28,639 --> 00:21:34,489
probably didn't ok you are there a

00:21:31,940 --> 00:21:35,869
mistake you either have an error or it's

00:21:34,489 --> 00:21:37,460
a read only thing then you should just

00:21:35,869 --> 00:21:38,869
make it shared anyway because you

00:21:37,460 --> 00:21:44,479
otherwise you're just making pointless

00:21:38,869 --> 00:21:50,330
copies that would be nice yeah ok so you

00:21:44,479 --> 00:21:54,979
can you can at least cash cash this ok

00:21:50,330 --> 00:21:58,220
right default none okay I believe you

00:21:54,979 --> 00:22:03,859
know I believe this was the worst single

00:21:58,220 --> 00:22:07,039
design decision in OpenMP no not making

00:22:03,859 --> 00:22:10,789
default none the default behavior ok

00:22:07,039 --> 00:22:12,589
right default behavior for parallel

00:22:10,789 --> 00:22:15,649
regions and work Canary constructs is

00:22:12,589 --> 00:22:19,070
default change ok this wasn't this is

00:22:15,649 --> 00:22:21,019
madness ok I don't know why that I don't

00:22:19,070 --> 00:22:22,849
again I wasn't there at the beginning I

00:22:21,019 --> 00:22:28,970
have no idea why this was done why this

00:22:22,849 --> 00:22:31,369
was thought to be a good idea no no no

00:22:28,970 --> 00:22:35,690
yes you have to don't the lots of stuff

00:22:31,369 --> 00:22:38,899
ok good right why why you know why the

00:22:35,690 --> 00:22:42,289
problem ok it's this is yeah it's just

00:22:38,899 --> 00:22:44,599
dangerous right it's just dangerous it

00:22:42,289 --> 00:22:48,080
just results in you see oh you know I

00:22:44,599 --> 00:22:50,839
see so many race condition bugs in

00:22:48,080 --> 00:22:57,440
peoples OpenMP programs because of this

00:22:50,839 --> 00:23:00,169
right all the time ok so yes or if you

00:22:57,440 --> 00:23:01,669
support auto scoping great ok you get

00:23:00,169 --> 00:23:03,559
round all this house you just do it for

00:23:01,669 --> 00:23:06,229
them ok have tools that do it for you

00:23:03,559 --> 00:23:10,299
that would be fantastic ok so what I

00:23:06,229 --> 00:23:14,809
recommend to two people that I teach is

00:23:10,299 --> 00:23:16,009
just use it ok yes it's painful but it's

00:23:14,809 --> 00:23:17,570
going to save you you know you think

00:23:16,009 --> 00:23:20,089
might think you're doing a lot of extra

00:23:17,570 --> 00:23:21,950
typing with in the long run you're going

00:23:20,089 --> 00:23:23,180
to catch a lot of bugs like this and it

00:23:21,950 --> 00:23:27,350
will stop you shipping

00:23:23,180 --> 00:23:29,750
buggy code okay just use default none

00:23:27,350 --> 00:23:35,870
and I say you know really really a

00:23:29,750 --> 00:23:38,780
minute okay yes okay so that would be

00:23:35,870 --> 00:23:43,190
nice but again there is not an

00:23:38,780 --> 00:23:46,730
unaccepted okay my observation is that

00:23:43,190 --> 00:23:50,090
the reason you think this is you think

00:23:46,730 --> 00:23:53,720
okay surely you can look at 10 lines of

00:23:50,090 --> 00:24:02,630
code and and list all the variables in

00:23:53,720 --> 00:24:04,520
there okay all right go on do it what's

00:24:02,630 --> 00:24:07,720
that share by default because it's just

00:24:04,520 --> 00:24:07,720
a regular old variable right

00:24:10,820 --> 00:24:13,809
it's not for see

00:24:14,130 --> 00:24:21,300
well photograph I mean the problem is

00:24:18,720 --> 00:24:23,580
that the fork on the for constructing

00:24:21,300 --> 00:24:25,920
see is really a general thing okay it's

00:24:23,580 --> 00:24:32,070
just a general while loop so you can

00:24:25,920 --> 00:24:33,540
write anything you like in there hmm why

00:24:32,070 --> 00:24:36,360
is it the private in the first one okay

00:24:33,540 --> 00:24:38,940
because because that's right it would be

00:24:36,360 --> 00:24:40,770
crazy not to be right there's no

00:24:38,940 --> 00:24:44,970
conceivable use there's no conceivable

00:24:40,770 --> 00:24:47,040
use case of that right but don't you

00:24:44,970 --> 00:24:50,460
know so what do you work the trouble is

00:24:47,040 --> 00:24:53,190
you see does not distinguish that C

00:24:50,460 --> 00:24:55,080
language does not distinguish j is

00:24:53,190 --> 00:25:00,710
anything special it's you know there's

00:24:55,080 --> 00:25:00,710
no concept of a loop iterator in c okay

00:25:01,160 --> 00:25:09,510
so you know so some that kind of thing

00:25:05,970 --> 00:25:11,550
is a really common bug okay because

00:25:09,510 --> 00:25:16,320
people look at anything I don't you know

00:25:11,550 --> 00:25:19,200
just dismiss it out okay so you know a

00:25:16,320 --> 00:25:21,480
lot of Walmart you know some um if you

00:25:19,200 --> 00:25:23,490
spoke your variables correctly okay or

00:25:21,480 --> 00:25:26,700
or in a more modern way so if you write

00:25:23,490 --> 00:25:28,610
for in Thai and four inch J then you

00:25:26,700 --> 00:25:32,220
don't run into this kind of thing and

00:25:28,610 --> 00:25:36,870
but nevertheless you know my experience

00:25:32,220 --> 00:25:40,440
is that this kind of Misenum relying on

00:25:36,870 --> 00:25:42,330
the default and relying on you looking

00:25:40,440 --> 00:25:46,590
at your program and convincing yourself

00:25:42,330 --> 00:25:50,550
that you actually did think about every

00:25:46,590 --> 00:25:53,720
single variable is highly dangerous okay

00:25:50,550 --> 00:25:56,700
so programmers are really bad at this

00:25:53,720 --> 00:25:58,290
and this is doubling that this is this

00:25:56,700 --> 00:26:00,080
kind of things especially nasty with

00:25:58,290 --> 00:26:03,560
luis and loop temporary things like this

00:26:00,080 --> 00:26:08,910
if you have enough compiler optimization

00:26:03,560 --> 00:26:10,680
you will never see the bug okay pilot

00:26:08,910 --> 00:26:13,670
will put j in rate you know essentially

00:26:10,680 --> 00:26:17,220
just use a register and decrement it

00:26:13,670 --> 00:26:19,350
okay so JJ will never actually be stored

00:26:17,220 --> 00:26:22,650
in memory so no trace ever actually

00:26:19,350 --> 00:26:24,750
happens until you know three years later

00:26:22,650 --> 00:26:25,570
somebody comes along and recompile your

00:26:24,750 --> 00:26:30,550
code with mine

00:26:25,570 --> 00:26:33,630
zero and it explodes in their face so

00:26:30,550 --> 00:26:37,210
yeah okay enough preaching about that

00:26:33,630 --> 00:26:46,030
what could we do compiler switch that

00:26:37,210 --> 00:26:47,860
that made default none the default be

00:26:46,030 --> 00:26:49,840
nice or an environment variable or

00:26:47,860 --> 00:26:55,600
something that you know that you do to

00:26:49,840 --> 00:26:56,860
to just turn that behavior all yeah but

00:26:55,600 --> 00:26:58,840
the environment variable is going to

00:26:56,860 --> 00:27:01,270
compile time things it's a compile-time

00:26:58,840 --> 00:27:03,850
thing yeah so a compiler switch right

00:27:01,270 --> 00:27:12,370
why not have a 1-over compiler switch to

00:27:03,850 --> 00:27:15,100
make to make doing this easy this one

00:27:12,370 --> 00:27:17,200
came this one actually came up in the

00:27:15,100 --> 00:27:21,670
forum last week I've seen it several

00:27:17,200 --> 00:27:24,390
times as well is you know access to

00:27:21,670 --> 00:27:27,400
access to private variables from from

00:27:24,390 --> 00:27:30,670
outside of the outside of the construct

00:27:27,400 --> 00:27:32,680
itself so suppose I have a parallel

00:27:30,670 --> 00:27:35,920
region and I make through a private

00:27:32,680 --> 00:27:39,820
variable okay and then inside that pier

00:27:35,920 --> 00:27:42,580
and who is through as a file scope thing

00:27:39,820 --> 00:27:46,150
or it's you in Fortran it's a module

00:27:42,580 --> 00:27:48,700
variable or something like that and I

00:27:46,150 --> 00:27:50,770
call some funk some function and some

00:27:48,700 --> 00:27:55,620
function in case that it says okay I

00:27:50,770 --> 00:28:01,030
want to use foo so okay what happens

00:27:55,620 --> 00:28:02,980
okay yeah this is weird okay one of two

00:28:01,030 --> 00:28:07,870
things inspect says one of two things

00:28:02,980 --> 00:28:11,860
can happen right this foo either refers

00:28:07,870 --> 00:28:14,530
to the original global storage or it

00:28:11,860 --> 00:28:19,120
refers to that private copy but I'm not

00:28:14,530 --> 00:28:21,820
going to tell you which okay so it's

00:28:19,120 --> 00:28:25,360
completely unusable hey you can't you

00:28:21,820 --> 00:28:26,530
can't do that right so because if you

00:28:25,360 --> 00:28:28,120
don't know which is going to have which

00:28:26,530 --> 00:28:29,500
which things is going to refer to are

00:28:28,120 --> 00:28:32,670
different I'm different with different

00:28:29,500 --> 00:28:32,670
compilers that

00:28:33,659 --> 00:28:40,330
no it says yeah it says it's it's just

00:28:36,999 --> 00:28:41,559
unspecified which one you get right it

00:28:40,330 --> 00:28:45,519
tells me you going to get one or the

00:28:41,559 --> 00:28:55,990
other but not which one this is what you

00:28:45,519 --> 00:28:57,610
want to earth had uses that maybe yeah

00:28:55,990 --> 00:29:02,970
maybe that's maybe should just be

00:28:57,610 --> 00:29:02,970
undefined you think it's under fine

00:29:08,820 --> 00:29:22,549
oh yeah maybe maybe I should maybe I

00:29:19,950 --> 00:29:27,259
should go back and check okay I'm not

00:29:22,549 --> 00:29:27,259
I'm not a hundred percent confident

00:29:31,230 --> 00:29:37,260
right but anything at least it says it's

00:29:34,420 --> 00:29:37,260
an error right

00:29:41,090 --> 00:29:47,460
Chris yeah

00:29:43,710 --> 00:29:49,600
so you just can't do that he's it's just

00:29:47,460 --> 00:29:52,030
wrong

00:29:49,600 --> 00:29:53,799
I don't think that the trouble is

00:29:52,030 --> 00:29:56,410
there's no good way for compilers to

00:29:53,799 --> 00:29:58,630
catch that kind of thing right because

00:29:56,410 --> 00:30:07,630
that could be an that could be compiled

00:29:58,630 --> 00:30:09,549
completely separately so no I mean most

00:30:07,630 --> 00:30:14,440
of the problems occur because of

00:30:09,549 --> 00:30:16,600
inlining right so in that case if the

00:30:14,440 --> 00:30:24,970
compiler does in line then it probably

00:30:16,600 --> 00:30:28,030
might be able to to pick that up said I

00:30:24,970 --> 00:30:29,350
in line something okay so I see that

00:30:28,030 --> 00:30:31,720
through there i'm going to make it the

00:30:29,350 --> 00:30:36,809
same as flew there and they're 40 but

00:30:31,720 --> 00:30:39,250
fools private to prove it here whoops

00:30:36,809 --> 00:30:42,090
but can it tell that you didn't didn't

00:30:39,250 --> 00:30:45,130
pass a appointed to it some other way

00:30:42,090 --> 00:30:47,730
legitimately you know maybe not if you

00:30:45,130 --> 00:30:47,730
just can't do it

00:30:49,180 --> 00:31:00,680
after the directives yeah I think that's

00:30:52,160 --> 00:31:02,450
the trouble here right okay what we do

00:31:00,680 --> 00:31:05,570
with this situation okay there's also do

00:31:02,450 --> 00:31:06,770
data scoping okay so unfortunately

00:31:05,570 --> 00:31:09,980
there's a lot of fortune out there in

00:31:06,770 --> 00:31:12,530
the world that looks like this okay i

00:31:09,980 --> 00:31:15,950
equals 1 to N and then you get literally

00:31:12,530 --> 00:31:19,640
several pages of inline code okay which

00:31:15,950 --> 00:31:22,340
reference hundreds of variables you know

00:31:19,640 --> 00:31:25,880
I have to try and determine the correct

00:31:22,340 --> 00:31:30,770
scope for all that's done okay so if i'm

00:31:25,880 --> 00:31:33,620
lucky i have an auto scoping tool okay

00:31:30,770 --> 00:31:37,700
if I don't then I'm that I'm still a bit

00:31:33,620 --> 00:31:43,040
stuck okay because then the chances of

00:31:37,700 --> 00:31:45,140
me getting it right up are hard but so

00:31:43,040 --> 00:31:47,120
what i only recommend people to do in

00:31:45,140 --> 00:31:49,520
this situation is sa to go away and

00:31:47,120 --> 00:31:53,150
refactor your sequential code until it

00:31:49,520 --> 00:31:55,340
looks like this okay all the loop

00:31:53,150 --> 00:32:00,100
temporary variables make declare them

00:31:55,340 --> 00:32:02,540
locally inside that subroutine and

00:32:00,100 --> 00:32:05,540
everything that everything else pass it

00:32:02,540 --> 00:32:08,180
through the argument list and that's

00:32:05,540 --> 00:32:13,330
much easier ok that's a sequential

00:32:08,180 --> 00:32:16,490
refactoring which you can test sensibly

00:32:13,330 --> 00:32:19,190
and then then you can paralyze that and

00:32:16,490 --> 00:32:21,860
you've got rid of all your private very

00:32:19,190 --> 00:32:24,980
you've made the decision ok everything

00:32:21,860 --> 00:32:26,480
that should be private is locally

00:32:24,980 --> 00:32:28,250
declared and therefore implicitly

00:32:26,480 --> 00:32:30,680
private inside that inside that

00:32:28,250 --> 00:32:33,380
subroutine everything that's everything

00:32:30,680 --> 00:32:34,790
it's United passing probably needed to

00:32:33,380 --> 00:32:36,590
be shared but at least you've probably

00:32:34,790 --> 00:32:41,680
reduced the number of variables you have

00:32:36,590 --> 00:32:41,680
to make decisions about by a lot ok

00:32:42,830 --> 00:32:51,510
so if you're if we don't tend to see

00:32:46,920 --> 00:32:53,520
this so much in CC programs just because

00:32:51,510 --> 00:32:55,890
of the sort of the background of where

00:32:53,520 --> 00:32:57,750
people come from but you can declare you

00:32:55,890 --> 00:33:00,150
know you can declare them in the scope

00:32:57,750 --> 00:33:04,260
of the new body and make them make them

00:33:00,150 --> 00:33:05,910
private implicitly without having to you

00:33:04,260 --> 00:33:11,400
know without having to listen explicitly

00:33:05,910 --> 00:33:14,250
and again that's it is to be able to do

00:33:11,400 --> 00:33:15,720
this yeah we probably it probably is

00:33:14,250 --> 00:33:17,220
it's probably part of the recent photo

00:33:15,720 --> 00:33:19,890
and standard that nobody will implement

00:33:17,220 --> 00:33:21,660
for another X years and nobody and

00:33:19,890 --> 00:33:30,380
openmp will not support for another

00:33:21,660 --> 00:33:33,930
white years okay so yes but now is that

00:33:30,380 --> 00:33:36,680
2008 is it all the more reason or these

00:33:33,930 --> 00:33:36,680
yeah

00:33:41,250 --> 00:33:48,900
nasty 1 i've seen by seen bite a few

00:33:43,560 --> 00:33:54,140
people have a parallel region and then i

00:33:48,900 --> 00:33:54,140
have a for loop with a reduction on

00:33:57,460 --> 00:34:06,299
so we need to initialize the value of

00:34:00,399 --> 00:34:06,299
Sam somewhere where's that broken

00:34:08,450 --> 00:34:15,500
it's broken because okay all threads do

00:34:12,379 --> 00:34:19,250
that initialization so it's wrong right

00:34:15,500 --> 00:34:20,629
it's a race condition okay it looks like

00:34:19,250 --> 00:34:23,690
one of these really harmless race

00:34:20,629 --> 00:34:25,399
conditions but in fact those those

00:34:23,690 --> 00:34:27,280
things are not just racing with with

00:34:25,399 --> 00:34:31,480
with other threads executing that

00:34:27,280 --> 00:34:34,879
they're also racing with the implied

00:34:31,480 --> 00:34:36,500
assignment to some at the end of the

00:34:34,879 --> 00:34:39,970
edge of it at the end of the parallel

00:34:36,500 --> 00:34:43,700
region so it's possible that a thread

00:34:39,970 --> 00:34:47,450
gets in here and gets right down to here

00:34:43,700 --> 00:34:50,359
and its local copy of some into the

00:34:47,450 --> 00:34:57,829
original storage and then another thread

00:34:50,359 --> 00:35:04,810
arrives and sets it to 0 sure it would

00:34:57,829 --> 00:35:06,980
yeah yeah yeah sure but then you know

00:35:04,810 --> 00:35:08,089
you know it's like any race couldn't

00:35:06,980 --> 00:35:13,609
it's like a lot of race conditions

00:35:08,089 --> 00:35:16,970
they're rare events which is a problem

00:35:13,609 --> 00:35:18,260
yeah it's what happens very often it's

00:35:16,970 --> 00:35:20,480
one of those it's you know you run your

00:35:18,260 --> 00:35:22,040
code 999 times and nothing nothing

00:35:20,480 --> 00:35:24,460
breaks and then the thousandth time it

00:35:22,040 --> 00:35:24,460
goes poof

00:35:28,930 --> 00:35:32,800
you really need to put the

00:35:30,819 --> 00:35:34,300
initialization in a single and have up

00:35:32,800 --> 00:35:40,990
and make sure there's a barrier there

00:35:34,300 --> 00:35:43,410
yeah oba or or master plus barrier if

00:35:40,990 --> 00:35:43,410
you wish

00:35:47,900 --> 00:35:53,599
yeah sure it's a race hey yes yeah but

00:35:51,589 --> 00:35:55,700
it looks it kind of it looks like it

00:35:53,599 --> 00:35:58,670
ought to be harmless race but it isn't

00:35:55,700 --> 00:36:01,069
okay you can really really can get the

00:35:58,670 --> 00:36:03,500
wrong answer from that okay as opposed

00:36:01,069 --> 00:36:06,099
to just being well okay we've rethread

00:36:03,500 --> 00:36:09,579
assigned the same thing to some variable

00:36:06,099 --> 00:36:09,579
number uncle

00:36:15,780 --> 00:36:22,900
no there's nothing to specify that okay

00:36:19,210 --> 00:36:26,440
the a thread can can it can add its

00:36:22,900 --> 00:36:29,349
local contribution into the original

00:36:26,440 --> 00:36:36,760
storage before other threads arrived at

00:36:29,349 --> 00:36:41,700
the barrier you're using a no 8 Clause

00:36:36,760 --> 00:36:41,700
then you just push the problem later on

00:36:51,510 --> 00:36:58,020
so yeah yeah that's correct if you'd if

00:36:55,710 --> 00:37:01,110
I'm a reduction with a no wet with a no

00:36:58,020 --> 00:37:03,210
wait then I don't get the result of the

00:37:01,110 --> 00:37:19,680
reduction result is not available until

00:37:03,210 --> 00:37:22,400
the subsequent barrier yeah that's legal

00:37:19,680 --> 00:37:24,840
okay so now some implementations may

00:37:22,400 --> 00:37:28,140
because they felt you know some

00:37:24,840 --> 00:37:30,180
implementations may fold the reduction

00:37:28,140 --> 00:37:32,940
in to the barrier in a such a way that

00:37:30,180 --> 00:37:36,530
this doesn't happen but you but you

00:37:32,940 --> 00:37:36,530
cannot rely on that

00:37:42,119 --> 00:37:47,700
us is a good one yeah so lets you

00:37:45,480 --> 00:37:51,089
occasionally see see users and their

00:37:47,700 --> 00:37:53,009
first experience of OpenMP is okay I've

00:37:51,089 --> 00:37:56,609
got my sequential code I know I'd like

00:37:53,009 --> 00:37:58,859
to use OpenMP first thing I'll do I need

00:37:56,609 --> 00:38:04,079
to do is figure out what the compiler

00:37:58,859 --> 00:38:07,049
flag is to to use OpenMP okay and I

00:38:04,079 --> 00:38:10,910
think ah ok I'll just add that and I'll

00:38:07,049 --> 00:38:14,880
just recompile my sequential program OOP

00:38:10,910 --> 00:38:16,799
it crashes okay well it's couple of

00:38:14,880 --> 00:38:22,289
reasons for that okay sometimes it's a

00:38:16,799 --> 00:38:24,930
code bug okay it's it's it's a missing

00:38:22,289 --> 00:38:28,529
same missing save or static okay

00:38:24,930 --> 00:38:31,440
depending on your language because what

00:38:28,529 --> 00:38:34,160
compiling with openmp flag done does to

00:38:31,440 --> 00:38:38,990
a sequential program this force all

00:38:34,160 --> 00:38:38,990
local variables to be stack allocated

00:38:39,799 --> 00:38:46,529
yes okay they must be private to a

00:38:43,289 --> 00:38:49,220
thread so the only sensible place to put

00:38:46,529 --> 00:38:49,220
them is on the stack

00:38:49,809 --> 00:38:54,799
and if I don't have a parallel region

00:38:52,839 --> 00:39:00,250
variables which are local to a

00:38:54,799 --> 00:39:00,250
subroutine have to get stuck allocated

00:39:00,519 --> 00:39:05,660
because I don't know where you know I

00:39:03,109 --> 00:39:08,750
could live so the compiler is concerned

00:39:05,660 --> 00:39:11,150
is because open PFLAG is there this

00:39:08,750 --> 00:39:15,260
routine could be called from a parallel

00:39:11,150 --> 00:39:16,819
region so I better treat the local

00:39:15,260 --> 00:39:19,039
variables in such a way that they're

00:39:16,819 --> 00:39:21,609
going to be private to a thread because

00:39:19,039 --> 00:39:21,609
that's the rule

00:39:24,460 --> 00:39:28,309
no especially not if they're especially

00:39:26,720 --> 00:39:32,390
not if they're arrays of any very

00:39:28,309 --> 00:39:35,269
reasonable size okay so fair scalars en

00:39:32,390 --> 00:39:36,710
yes probably okay if they you know if

00:39:35,269 --> 00:39:39,799
they know if it sees its in it knows

00:39:36,710 --> 00:39:42,019
it's a big array then it has the choice

00:39:39,799 --> 00:39:47,089
right it can heap allocate them and a

00:39:42,019 --> 00:39:49,400
lot of compilers do so like that can

00:39:47,089 --> 00:39:50,779
that can happen okay the other reason

00:39:49,400 --> 00:39:52,670
why you might your code might have blown

00:39:50,779 --> 00:39:54,680
up in this circumstance as big is is

00:39:52,670 --> 00:39:56,059
because okay you did have some big

00:39:54,680 --> 00:39:59,059
arrays and you and you just blew your

00:39:56,059 --> 00:40:01,220
stack away it increases the stat

00:39:59,059 --> 00:40:03,079
requirements and suddenly it goes over

00:40:01,220 --> 00:40:10,190
the stack there's this tax base limiting

00:40:03,079 --> 00:40:14,869
you die it I cannot get my head round

00:40:10,190 --> 00:40:18,109
the fact that we modern languages are so

00:40:14,869 --> 00:40:21,309
sophisticated etc etc etc but still

00:40:18,109 --> 00:40:28,309
stack overflow results in seg faults

00:40:21,309 --> 00:40:31,339
well why can't you catch that can't you

00:40:28,309 --> 00:40:33,079
can't can't run can't language runtimes

00:40:31,339 --> 00:40:39,109
do it still sends to do something

00:40:33,079 --> 00:40:44,220
sensible you've to topic unbelievable

00:40:39,109 --> 00:40:47,970
right we've seen amazing to me okay

00:40:44,220 --> 00:40:51,240
and so if it is a case that you you did

00:40:47,970 --> 00:40:53,550
really need sable static then you know

00:40:51,240 --> 00:40:55,410
those things are shared by default and

00:40:53,550 --> 00:40:58,890
you may need need to make them very

00:40:55,410 --> 00:41:00,630
private and the problem comes with a lot

00:40:58,890 --> 00:41:04,080
of the use of those things is for first

00:41:00,630 --> 00:41:07,140
time through code and you need to think

00:41:04,080 --> 00:41:09,960
about that really quite carefully as to

00:41:07,140 --> 00:41:12,330
how you refactor that doesn't there's

00:41:09,960 --> 00:41:15,869
been an awkward thing to deal with throw

00:41:12,330 --> 00:41:18,090
up for applications I have closure if

00:41:15,869 --> 00:41:20,880
this is the first time i got called then

00:41:18,090 --> 00:41:25,349
do something and then set this flag so

00:41:20,880 --> 00:41:28,650
that it never happens again probably bad

00:41:25,349 --> 00:41:29,970
programming practice really ok but if

00:41:28,650 --> 00:41:31,440
you then want that thing to be called in

00:41:29,970 --> 00:41:33,090
parallel then or what does that mean ok

00:41:31,440 --> 00:41:34,650
I'm a bunch of threads we're all going

00:41:33,090 --> 00:41:41,599
to try and execute it at the same time

00:41:34,650 --> 00:41:41,599
what do you want to happen sorry hon

00:41:43,589 --> 00:41:52,619
that's fine yeah that's fine yeah okay

00:41:51,150 --> 00:41:56,069
yeah so it's running if you run out of

00:41:52,619 --> 00:41:58,469
sac space okay but you've got to control

00:41:56,069 --> 00:42:00,119
stack space in two ways okay you could

00:41:58,469 --> 00:42:02,219
have you've got a set you've got to

00:42:00,119 --> 00:42:04,229
you've got to set the you've got to deal

00:42:02,219 --> 00:42:07,019
with the master thread stack in whatever

00:42:04,229 --> 00:42:10,769
way you would normally deal with it for

00:42:07,019 --> 00:42:12,809
a sequential program so you limit on or

00:42:10,769 --> 00:42:16,319
you set up to set the right set of

00:42:12,809 --> 00:42:18,390
compiler flag or whatever ok because OMP

00:42:16,319 --> 00:42:21,690
stack size only affects all the other

00:42:18,390 --> 00:42:28,920
threads you've got to do this whole

00:42:21,690 --> 00:42:32,219
thing got to is critical atomic don't

00:42:28,920 --> 00:42:33,509
mutually exclude okay if I do this if I

00:42:32,219 --> 00:42:35,609
protect the same trying to plate the

00:42:33,509 --> 00:42:37,319
same same variable the critical anatomic

00:42:35,609 --> 00:42:40,279
and one thread can be doing this in

00:42:37,319 --> 00:42:40,279
military community that

00:42:44,869 --> 00:42:50,690
nobody seems to know about people though

00:42:47,869 --> 00:42:52,190
be seated I try to teach it but people

00:42:50,690 --> 00:42:56,359
don't seem to ever know about Olympia

00:42:52,190 --> 00:42:58,130
get max threads okay and the use why do

00:42:56,359 --> 00:42:59,390
you want to avoid you want to use a pic

00:42:58,130 --> 00:43:01,700
get max Reds that's because you want to

00:42:59,390 --> 00:43:03,769
allocate some storage based on the

00:43:01,700 --> 00:43:05,509
number of threads ahead of the time for

00:43:03,769 --> 00:43:07,819
the next parallel to use in the next

00:43:05,509 --> 00:43:11,690
parallel region okay and that that's the

00:43:07,819 --> 00:43:13,940
nice way to do it okay again so this is

00:43:11,690 --> 00:43:17,599
unfortunate decision early stage of a

00:43:13,940 --> 00:43:25,339
P&P so we didn't have the concept of I

00:43:17,599 --> 00:43:27,619
CVS so the the names of the runtime

00:43:25,339 --> 00:43:29,650
those runtime libraries are not yet are

00:43:27,619 --> 00:43:31,999
not get as and setters properly ok

00:43:29,650 --> 00:43:36,230
Olympia get num threads is not a getter

00:43:31,999 --> 00:43:41,930
for the icv ok i only get max thread is

00:43:36,230 --> 00:43:43,099
the getter ok but yeah it's just be

00:43:41,930 --> 00:43:44,630
aware of always that you know the

00:43:43,099 --> 00:43:46,190
implementations can always give you less

00:43:44,630 --> 00:43:51,499
threads than what you thought and you

00:43:46,190 --> 00:43:54,109
should always check if you care ok using

00:43:51,499 --> 00:43:57,519
task tusks a lovely data attributes

00:43:54,109 --> 00:44:02,239
coping for tasks is horrible difficult

00:43:57,519 --> 00:44:04,489
so as usual to use default none right

00:44:02,239 --> 00:44:06,109
don't rely on the defaults think of you

00:44:04,489 --> 00:44:07,400
because you really need to really really

00:44:06,109 --> 00:44:12,140
do need to think about things carefully

00:44:07,400 --> 00:44:14,450
with tasks don't use tasks for things to

00:44:12,140 --> 00:44:18,140
do loops to do normal loops because you

00:44:14,450 --> 00:44:20,989
just got bigger overheads and don't

00:44:18,140 --> 00:44:23,720
expect run time to do miracles ok so

00:44:20,989 --> 00:44:26,089
usually you need to have take take some

00:44:23,720 --> 00:44:28,249
control over the number and the

00:44:26,089 --> 00:44:31,339
granularity of tax that you're going to

00:44:28,249 --> 00:44:33,410
generate generating generating billions

00:44:31,339 --> 00:44:36,130
of billions of tiny tasks is business

00:44:33,410 --> 00:44:36,130
never going to work

00:44:39,060 --> 00:44:42,060
ok

00:44:43,920 --> 00:44:49,020
the performance okay so if I really want

00:44:47,309 --> 00:44:51,480
to if I really want my very what my

00:44:49,020 --> 00:44:54,000
openmp program to run and being very

00:44:51,480 --> 00:44:57,299
aggressive and not be nice to any other

00:44:54,000 --> 00:44:59,490
user then I need to set there's three

00:44:57,299 --> 00:45:02,520
things I need to set okay the only

00:44:59,490 --> 00:45:05,609
weight policy is active to get my idol

00:45:02,520 --> 00:45:08,190
spreads to spin instead of to sleep so

00:45:05,609 --> 00:45:10,260
OMP dynamic equals false so don't let

00:45:08,190 --> 00:45:12,839
the runtime give me or at least give us

00:45:10,260 --> 00:45:16,160
strong him to the runtime not to give me

00:45:12,839 --> 00:45:16,160
fewer threads than what I asked for

00:45:23,860 --> 00:45:30,610
right against it can still give you less

00:45:27,580 --> 00:45:34,940
right but it's but it's much less likely

00:45:30,610 --> 00:45:38,570
okay yeah it's much less likely yes yes

00:45:34,940 --> 00:45:40,250
okay that is to let it yes yeah okay no

00:45:38,570 --> 00:45:42,560
you're right okay that's too strongly

00:45:40,250 --> 00:45:44,270
statement it's a strong hint saying

00:45:42,560 --> 00:45:48,650
please give me the number of threads I

00:45:44,270 --> 00:45:51,730
asked for and and bind them okay don't

00:45:48,650 --> 00:45:54,050
don't stop don't moving around okay

00:45:51,730 --> 00:45:56,240
unfortunately these are you these are

00:45:54,050 --> 00:45:58,250
often not the default because vendors

00:45:56,240 --> 00:45:59,810
seem to think that they said that the

00:45:58,250 --> 00:46:01,910
all programs should be all appropriate

00:45:59,810 --> 00:46:03,380
programs are run in shared environments

00:46:01,910 --> 00:46:07,310
and everybody should be nice through

00:46:03,380 --> 00:46:09,590
normal body okay so even on super

00:46:07,310 --> 00:46:13,760
computers where you are guaranteed to

00:46:09,590 --> 00:46:15,770
get ahold no to yourself anyway then yes

00:46:13,760 --> 00:46:19,970
you still need to set those on something

00:46:15,770 --> 00:46:22,370
in some cases now now they're all

00:46:19,970 --> 00:46:23,960
implementation to find the parts yeah

00:46:22,370 --> 00:46:25,910
yes the implementation can do what it

00:46:23,960 --> 00:46:28,430
can can set those how it likes and

00:46:25,910 --> 00:46:30,380
usually most implementations are gone

00:46:28,430 --> 00:46:34,940
this sort of nice friendly cautious side

00:46:30,380 --> 00:46:38,480
with their defaults okay debuggers yeah

00:46:34,940 --> 00:46:40,220
debuggers are pretty exist they're great

00:46:38,480 --> 00:46:42,230
but they don't they don't track down

00:46:40,220 --> 00:46:45,160
race conditions for you you need to use

00:46:42,230 --> 00:46:47,650
you know tools like tools like these

00:46:45,160 --> 00:46:49,720
inspecting the info inspector or

00:46:47,650 --> 00:46:54,220
better analyzer to to get race

00:46:49,720 --> 00:46:57,790
conditions it's great okay and last but

00:46:54,220 --> 00:46:59,800
not least I'd be glad to know okay for

00:46:57,790 --> 00:47:01,570
using timers make sure the time that you

00:46:59,800 --> 00:47:05,680
use actually does measure wall clock

00:47:01,570 --> 00:47:08,260
time okay if that's what you wanted so

00:47:05,680 --> 00:47:10,720
do you hope you get W time it's you know

00:47:08,260 --> 00:47:13,090
it's an extremely convenient timer it's

00:47:10,720 --> 00:47:14,800
defined precisely the right way returns

00:47:13,090 --> 00:47:16,510
exactly what you want it returns you a

00:47:14,800 --> 00:47:18,430
double-precision value in seconds you

00:47:16,510 --> 00:47:19,930
don't have to convert it to anything you

00:47:18,430 --> 00:47:21,700
can just print it out directly you can

00:47:19,930 --> 00:47:26,950
subtract it won't have to mess with it

00:47:21,700 --> 00:47:29,590
okay don't for example use clock okay so

00:47:26,950 --> 00:47:32,170
this C clock function okay that measures

00:47:29,590 --> 00:47:35,290
CPU time accumulated across all friends

00:47:32,170 --> 00:47:40,570
okay so if you use that then the one you

00:47:35,290 --> 00:47:42,790
don't see any speed up right I've seen

00:47:40,570 --> 00:47:45,790
any number of any number of people do

00:47:42,790 --> 00:47:47,920
this okay it's really common it even

00:47:45,790 --> 00:47:50,560
happened to one of my colleagues who

00:47:47,920 --> 00:47:53,290
will remain nameless for because I don't

00:47:50,560 --> 00:47:55,090
want to embarrass him okay but it came

00:47:53,290 --> 00:47:56,650
to me and said it's really weird by

00:47:55,090 --> 00:47:59,950
OpenMP I'm getting no speed up and I

00:47:56,650 --> 00:48:02,020
openmp thanks they got to bottle it what

00:47:59,950 --> 00:48:06,640
are you timing it with o clock that's

00:48:02,020 --> 00:48:08,680
right if you saw no speed up then that

00:48:06,640 --> 00:48:11,140
meant you know if you saw no no increase

00:48:08,680 --> 00:48:15,730
in CPU time you're getting perfect speed

00:48:11,140 --> 00:48:18,900
up relax don't worry about it okay I'm

00:48:15,730 --> 00:48:18,900
done thank you

00:48:31,820 --> 00:48:37,930
holy the club called us the one that

00:48:33,890 --> 00:48:37,930
makes it open a piece

00:48:42,609 --> 00:48:46,989
yeah yeah

00:48:57,870 --> 00:49:01,980
no I don't have to solve it either

00:49:13,860 --> 00:49:24,870
unless you unless you really tell it not

00:49:16,150 --> 00:49:24,870
to write you didn't mean that

00:49:39,720 --> 00:49:41,750
Oh

00:50:07,640 --> 00:50:14,819
compiler

00:50:09,660 --> 00:50:18,500
compiler should not razor yeah that's

00:50:14,819 --> 00:50:18,500
the kampala shouldn't do that I guess

00:50:20,849 --> 00:50:26,630
it's all right that makes sense well

00:50:23,640 --> 00:50:26,630
follow Hastur

00:50:41,230 --> 00:50:45,460
right this is the reason this is the

00:50:43,450 --> 00:50:47,050
reason that you can't do default private

00:50:45,460 --> 00:50:49,590
you see right now is because of these

00:50:47,050 --> 00:50:49,590
built-ins

00:51:00,710 --> 00:51:03,710
because

00:51:09,920 --> 00:51:15,290
is that in the standard library

00:51:15,770 --> 00:51:23,840
there that look like material and might

00:51:19,310 --> 00:51:30,100
be very costly habit there's no portable

00:51:23,840 --> 00:51:30,100
way to say we're there for small private

00:51:34,650 --> 00:51:38,240
but really irritating

00:51:38,410 --> 00:51:42,980
I've never understood it because surely

00:51:41,210 --> 00:51:48,800
the component knows which knows about

00:51:42,980 --> 00:51:54,620
those things yeah they probably are now

00:51:48,800 --> 00:51:56,840
you have to trust them so I mean you can

00:51:54,620 --> 00:52:01,190
still use default none to debug your

00:51:56,840 --> 00:52:05,680
code okay you can still use it to catch

00:52:01,190 --> 00:52:05,680
things and then right

00:52:07,650 --> 00:52:21,680
yeah yeah yeah so you can still use yeah

00:52:19,170 --> 00:52:21,680
yeah

00:52:30,010 --> 00:52:34,450
but you can still use default none to

00:52:32,860 --> 00:52:36,310
get the compiler to tell you all the

00:52:34,450 --> 00:52:37,930
things you didn't list right and then

00:52:36,310 --> 00:52:39,730
maybe you can't leave it in the coat and

00:52:37,930 --> 00:52:41,080
maybe you don't maybe you don't want to

00:52:39,730 --> 00:52:42,610
leave it in the final version of the

00:52:41,080 --> 00:52:44,650
curb because you end up with these long

00:52:42,610 --> 00:52:45,820
lists of variables okay so if you you

00:52:44,650 --> 00:52:47,770
know if you figure out that actually

00:52:45,820 --> 00:52:49,270
I've got this long the huge long list of

00:52:47,770 --> 00:52:51,010
variables but once you've convinced

00:52:49,270 --> 00:52:53,200
yourself you thought about it correctly

00:52:51,010 --> 00:52:55,990
I don't mind if you end up writing

00:52:53,200 --> 00:52:58,210
default shared in the final version okay

00:52:55,990 --> 00:53:00,640
but but not as no not until you've

00:52:58,210 --> 00:53:04,110
convinced yourself you've thought about

00:53:00,640 --> 00:53:04,110
everything ya know

00:53:11,620 --> 00:53:13,950

YouTube URL: https://www.youtube.com/watch?v=4wOhkihjXuE


