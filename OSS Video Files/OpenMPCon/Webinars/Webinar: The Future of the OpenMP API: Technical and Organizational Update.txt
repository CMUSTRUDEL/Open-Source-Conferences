Title: Webinar: The Future of the OpenMP API: Technical and Organizational Update
Publication date: 2021-05-06
Playlist: Webinars
Description: 
	This webinar will detail progress on versions 5.2 and 6.0 of the OpenMP API, which we will position within the general philosophy for the evolution of the language. We will also provide a brief overview of the structure of the OpenMP Architecture Review Board (ARB), membership opportunities, and plans for post-pandemic activities including IWOMP and OpenMPCon 2021.
Captions: 
	00:00:11,519 --> 00:00:13,679
hello

00:00:12,320 --> 00:00:15,759
thank you everyone for joining our

00:00:13,679 --> 00:00:17,920
webinar today's session will take

00:00:15,759 --> 00:00:19,279
approximately one hour

00:00:17,920 --> 00:00:21,600
if you have any questions during the

00:00:19,279 --> 00:00:23,680
presentation please ask them using the q

00:00:21,600 --> 00:00:25,599
a feature located on your zoom toolbar

00:00:23,680 --> 00:00:27,279
at the bottom of your screen

00:00:25,599 --> 00:00:29,039
you will be able to see questions from

00:00:27,279 --> 00:00:30,640
other attendees so please

00:00:29,039 --> 00:00:32,880
upvote or like the questions that

00:00:30,640 --> 00:00:34,239
interest you this will help us determine

00:00:32,880 --> 00:00:37,440
which questions to address

00:00:34,239 --> 00:00:39,280
live at the end of the session please

00:00:37,440 --> 00:00:40,960
watch for an email tomorrow with further

00:00:39,280 --> 00:00:42,480
information and a link to the recorded

00:00:40,960 --> 00:00:44,000
presentation

00:00:42,480 --> 00:00:45,840
and now i'd like to introduce our

00:00:44,000 --> 00:00:49,360
presenters michael clem

00:00:45,840 --> 00:00:49,360
and bronista sipinsky

00:00:50,079 --> 00:00:55,199
hello everyone i'm michael clem i'm the

00:00:52,960 --> 00:00:57,280
chief executive officer of the openmp

00:00:55,199 --> 00:01:01,359
architecture review board

00:00:57,280 --> 00:01:05,600
and um i have with me bronis

00:01:01,359 --> 00:01:05,600
who's gonna introduce himself now

00:01:06,400 --> 00:01:10,880
hello good morning good afternoon good

00:01:08,960 --> 00:01:11,680
evening or whatever it is wherever you

00:01:10,880 --> 00:01:14,080
are

00:01:11,680 --> 00:01:14,960
i'm briana suspinsky i'm the chair of

00:01:14,080 --> 00:01:17,840
the openmp

00:01:14,960 --> 00:01:19,280
language committee and it's a pleasure

00:01:17,840 --> 00:01:20,720
to have this opportunity to tell you

00:01:19,280 --> 00:01:21,759
about what's going on in the language

00:01:20,720 --> 00:01:26,000
committee

00:01:21,759 --> 00:01:27,600
i'm also the general chair for sc21

00:01:26,000 --> 00:01:30,159
so i just want not going to talk about

00:01:27,600 --> 00:01:32,799
that other than i just want to say that

00:01:30,159 --> 00:01:33,920
i hope that most of you will be able to

00:01:32,799 --> 00:01:37,759
join me there

00:01:33,920 --> 00:01:37,759
in november in st louis

00:01:39,520 --> 00:01:44,799
all right thank you so let me quickly um

00:01:42,560 --> 00:01:46,880
start off by introducing the openmp

00:01:44,799 --> 00:01:49,920
architecture review board

00:01:46,880 --> 00:01:53,119
so um we are the

00:01:49,920 --> 00:01:56,320
standards body behind the openmp api

00:01:53,119 --> 00:01:59,920
so the application programming interface

00:01:56,320 --> 00:02:04,880
and our mission is to standardize

00:01:59,920 --> 00:02:07,360
openmp as a directive based language

00:02:04,880 --> 00:02:08,399
that supports multiple base languages so

00:02:07,360 --> 00:02:11,840
in this case

00:02:08,399 --> 00:02:13,520
cc plus and fortran and

00:02:11,840 --> 00:02:15,680
that provides to our users and

00:02:13,520 --> 00:02:19,200
programmers

00:02:15,680 --> 00:02:23,040
high level parallelism that we

00:02:19,200 --> 00:02:24,959
do hope is performant so gives

00:02:23,040 --> 00:02:26,480
the best possible performance for your

00:02:24,959 --> 00:02:29,840
application code

00:02:26,480 --> 00:02:31,760
that is productive so makes parallelism

00:02:29,840 --> 00:02:34,879
in the application code

00:02:31,760 --> 00:02:38,239
as accessible as possible and

00:02:34,879 --> 00:02:40,319
portable so that you can

00:02:38,239 --> 00:02:42,480
move between systems of different

00:02:40,319 --> 00:02:45,760
vendors different software

00:02:42,480 --> 00:02:48,519
stacks uh openmp implementations

00:02:45,760 --> 00:02:49,920
and be portable the thing that is

00:02:48,519 --> 00:02:52,959
important

00:02:49,920 --> 00:02:56,000
to note here is that the openmp api

00:02:52,959 --> 00:02:59,040
moves common approaches

00:02:56,000 --> 00:03:01,040
of the domain that we're looking at so

00:02:59,040 --> 00:03:03,760
hpc and other parallel

00:03:01,040 --> 00:03:04,159
domains into an industry standard we are

00:03:03,760 --> 00:03:06,080
not

00:03:04,159 --> 00:03:07,599
conducting bleeding edge and

00:03:06,080 --> 00:03:10,239
standardizing that

00:03:07,599 --> 00:03:12,560
we are basically taking the approaches

00:03:10,239 --> 00:03:15,440
that the community already takes

00:03:12,560 --> 00:03:16,000
and move them into a standard to make

00:03:15,440 --> 00:03:18,400
them

00:03:16,000 --> 00:03:19,680
as already said portable on the

00:03:18,400 --> 00:03:21,920
right-hand side you already

00:03:19,680 --> 00:03:22,959
get a glimpse of the members that we

00:03:21,920 --> 00:03:26,239
have in

00:03:22,959 --> 00:03:28,959
our architecture review board we will

00:03:26,239 --> 00:03:31,120
come back to that in more detail um

00:03:28,959 --> 00:03:34,480
after we covered some of the tactical

00:03:31,120 --> 00:03:38,560
aspects the openmp

00:03:34,480 --> 00:03:42,720
arb has a specific

00:03:38,560 --> 00:03:44,239
roadmap we are on a five-year cadence

00:03:42,720 --> 00:03:46,959
for major releases

00:03:44,239 --> 00:03:47,760
and bronies was going to share um more

00:03:46,959 --> 00:03:49,680
about

00:03:47,760 --> 00:03:52,959
this cadence and the release process

00:03:49,680 --> 00:03:56,480
that we're having now

00:03:52,959 --> 00:03:58,400
yeah so first of all um

00:03:56,480 --> 00:04:00,799
not too long ago i took a look at this

00:03:58,400 --> 00:04:02,640
and i've been

00:04:00,799 --> 00:04:04,239
the chair of the language committee

00:04:02,640 --> 00:04:07,680
since 2009

00:04:04,239 --> 00:04:10,319
so about 12 years now um

00:04:07,680 --> 00:04:12,000
but it turns out when we looked in when

00:04:10,319 --> 00:04:12,720
i looked at it more closely we've

00:04:12,000 --> 00:04:15,439
actually

00:04:12,720 --> 00:04:16,239
since the beginning of the history of

00:04:15,439 --> 00:04:20,079
openmp

00:04:16,239 --> 00:04:22,160
really managed uh have maintained this

00:04:20,079 --> 00:04:23,759
five-year cadence of every five years

00:04:22,160 --> 00:04:27,280
coming out with a new

00:04:23,759 --> 00:04:32,000
uh major version of the specification

00:04:27,280 --> 00:04:35,520
and so in november of 2018

00:04:32,000 --> 00:04:40,240
we came out with

00:04:35,520 --> 00:04:40,240
openmp 5.0 down michael

00:04:40,840 --> 00:04:43,840
yes

00:04:44,960 --> 00:04:49,600
maybe it's just taking a while there and

00:04:47,680 --> 00:04:52,960
uh

00:04:49,600 --> 00:04:56,479
just last november we we uh came out

00:04:52,960 --> 00:04:57,360
so we we do a in general we do one minor

00:04:56,479 --> 00:05:00,479
release

00:04:57,360 --> 00:05:03,120
in in between the major releases so and

00:05:00,479 --> 00:05:04,320
typically we target two years after the

00:05:03,120 --> 00:05:06,400
major release

00:05:04,320 --> 00:05:07,600
with the idea being that that gives us

00:05:06,400 --> 00:05:11,120
time to

00:05:07,600 --> 00:05:14,479
um assess uh

00:05:11,120 --> 00:05:16,800
where we might make important but

00:05:14,479 --> 00:05:17,680
minor enhancements to the major release

00:05:16,800 --> 00:05:20,880
and also

00:05:17,680 --> 00:05:24,240
identify any errors

00:05:20,880 --> 00:05:24,960
and such so last november we came out

00:05:24,240 --> 00:05:29,280
with openmp

00:05:24,960 --> 00:05:30,320
5.1 um in in this five year cycle we're

00:05:29,280 --> 00:05:32,720
actually

00:05:30,320 --> 00:05:34,160
adding a second minor release and that

00:05:32,720 --> 00:05:37,280
it will be openmp

00:05:34,160 --> 00:05:40,560
5.2 um i'll tell you more about that

00:05:37,280 --> 00:05:43,680
in a little while but the

00:05:40,560 --> 00:05:48,080
intent is for that to be available in

00:05:43,680 --> 00:05:51,360
november of 21 and so in fact we'll be

00:05:48,080 --> 00:05:55,199
releasing it in time for sc 21.

00:05:51,360 --> 00:05:58,319
um the

00:05:55,199 --> 00:05:59,919
next major version will be openmp 6.0

00:05:58,319 --> 00:06:03,360
and will also tell you more about

00:05:59,919 --> 00:06:06,160
what we're thinking about for 6.0

00:06:03,360 --> 00:06:07,280
later in the talk typically we would

00:06:06,160 --> 00:06:11,280
come out with at least

00:06:07,280 --> 00:06:13,039
one tr in between so we had um

00:06:11,280 --> 00:06:14,720
a tr so i guess we want to click down

00:06:13,039 --> 00:06:17,840
again tr8

00:06:14,720 --> 00:06:20,240
in november of 19 we then had tr9 so

00:06:17,840 --> 00:06:23,520
usually what we do is we release a

00:06:20,240 --> 00:06:26,639
a comment draft

00:06:23,520 --> 00:06:29,759
that gives people an opportunity we

00:06:26,639 --> 00:06:31,039
have a feature freeze and release a

00:06:29,759 --> 00:06:33,280
comment draft and after

00:06:31,039 --> 00:06:34,639
after that we're only going to just look

00:06:33,280 --> 00:06:38,000
to find errors

00:06:34,639 --> 00:06:39,600
in in what we've in the draft for the

00:06:38,000 --> 00:06:42,000
for the release whether it's a major

00:06:39,600 --> 00:06:44,160
release or a minor release

00:06:42,000 --> 00:06:45,039
we're actually pretty far along in the

00:06:44,160 --> 00:06:48,160
5.2

00:06:45,039 --> 00:06:48,880
process and expect to have the feature

00:06:48,160 --> 00:06:52,560
freeze

00:06:48,880 --> 00:06:54,560
um following a a

00:06:52,560 --> 00:06:55,919
week-long meeting of the language

00:06:54,560 --> 00:06:57,520
committee that we'll have at the end of

00:06:55,919 --> 00:07:00,639
this month

00:06:57,520 --> 00:07:03,919
so sometime next month

00:07:00,639 --> 00:07:07,520
we we should be releasing uh tr10 which

00:07:03,919 --> 00:07:11,520
will be the comet draft for 5.2

00:07:07,520 --> 00:07:14,800
um and then the intent will be to

00:07:11,520 --> 00:07:17,840
release tr 11 in november of 22

00:07:14,800 --> 00:07:20,080
which will be a um you know

00:07:17,840 --> 00:07:21,840
the the main preview of what we're going

00:07:20,080 --> 00:07:24,800
to do in 6.0

00:07:21,840 --> 00:07:27,680
and then release another tr that's the

00:07:24,800 --> 00:07:31,720
final comment draft

00:07:27,680 --> 00:07:36,880
in the july or august time frame of

00:07:31,720 --> 00:07:44,160
2023 and we expect to keep going on this

00:07:36,880 --> 00:07:47,360
cycle well beyond 2023.

00:07:44,160 --> 00:07:50,240
all right so in developing the spec

00:07:47,360 --> 00:07:52,800
on you know this this is our process um

00:07:50,240 --> 00:07:54,240
we've refined it a lot over the years

00:07:52,800 --> 00:07:56,000
i don't want to bore you too much with

00:07:54,240 --> 00:07:59,599
it but basically what happens is

00:07:56,000 --> 00:08:01,120
somebody says i think

00:07:59,599 --> 00:08:03,280
it would be really good if you added

00:08:01,120 --> 00:08:05,120
this to this to the specification

00:08:03,280 --> 00:08:08,400
whether it's a new feature

00:08:05,120 --> 00:08:09,759
or um an enhancement to an existing

00:08:08,400 --> 00:08:12,400
feature or even just a

00:08:09,759 --> 00:08:14,160
a clarification or correction to what's

00:08:12,400 --> 00:08:18,720
already there

00:08:14,160 --> 00:08:21,680
we then implement that in in latex

00:08:18,720 --> 00:08:23,199
discuss it and following discussion we

00:08:21,680 --> 00:08:26,639
hold a first vote on it

00:08:23,199 --> 00:08:29,680
and then a second vote on it

00:08:26,639 --> 00:08:33,200
at which point the

00:08:29,680 --> 00:08:36,560
change is passed and we

00:08:33,200 --> 00:08:38,719
have a final verification process

00:08:36,560 --> 00:08:40,719
to make sure there's no errors in it and

00:08:38,719 --> 00:08:44,159
then we merge it into the

00:08:40,719 --> 00:08:46,480
main uh branch of the specification

00:08:44,159 --> 00:08:48,399
all of which is actually met managed in

00:08:46,480 --> 00:08:51,920
a

00:08:48,399 --> 00:08:51,920
private repo on github

00:08:52,640 --> 00:08:57,440
all right um so next

00:08:58,320 --> 00:09:01,519
here's the how the actual release

00:09:00,080 --> 00:09:04,320
process goes so

00:09:01,519 --> 00:09:05,440
and i kind of hinted at this already we

00:09:04,320 --> 00:09:08,640
through this

00:09:05,440 --> 00:09:11,920
process of

00:09:08,640 --> 00:09:15,040
um having proposals and

00:09:11,920 --> 00:09:19,200
voting them in and merging them into the

00:09:15,040 --> 00:09:20,240
main uh branch in github we develop a

00:09:19,200 --> 00:09:23,920
draft

00:09:20,240 --> 00:09:26,959
we continue editing that and eventually

00:09:23,920 --> 00:09:29,519
uh release a comment draft

00:09:26,959 --> 00:09:31,120
all right at which point we go into a

00:09:29,519 --> 00:09:33,839
quality control phase

00:09:31,120 --> 00:09:34,959
we take feedback from the community at

00:09:33,839 --> 00:09:38,000
that point

00:09:34,959 --> 00:09:40,800
we actually accept feedback throughout

00:09:38,000 --> 00:09:41,839
but the intent of releasing the comment

00:09:40,800 --> 00:09:45,279
draft is to

00:09:41,839 --> 00:09:46,720
formally give the community a one last

00:09:45,279 --> 00:09:50,160
opportunity to

00:09:46,720 --> 00:09:53,680
comment on what we're planning to adopt

00:09:50,160 --> 00:09:57,200
but in addition the committee uh

00:09:53,680 --> 00:10:00,240
spends uh a significant amount of effort

00:09:57,200 --> 00:10:03,440
uh reviewing every page of the document

00:10:00,240 --> 00:10:05,760
and making sure that um to the greatest

00:10:03,440 --> 00:10:06,800
extent possible that we catch any errors

00:10:05,760 --> 00:10:10,240
whether they're

00:10:06,800 --> 00:10:12,720
grammatical errors typos wording errors

00:10:10,240 --> 00:10:13,440
or something more significant where it's

00:10:12,720 --> 00:10:17,040
like

00:10:13,440 --> 00:10:20,480
we realize that um there's inconsistency

00:10:17,040 --> 00:10:22,160
between different

00:10:20,480 --> 00:10:24,000
proposals that we've adopted or

00:10:22,160 --> 00:10:26,079
something like that hopefully

00:10:24,000 --> 00:10:29,440
we catch those in the verification

00:10:26,079 --> 00:10:32,720
process of the individual proposals but

00:10:29,440 --> 00:10:36,320
just to be sure nothing

00:10:32,720 --> 00:10:38,240
major is wrong we go through this

00:10:36,320 --> 00:10:41,120
quality control process

00:10:38,240 --> 00:10:41,440
have a final draft that is basically the

00:10:41,120 --> 00:10:42,959
end

00:10:41,440 --> 00:10:45,440
product of the language committee

00:10:42,959 --> 00:10:47,519
process at which point the

00:10:45,440 --> 00:10:49,760
draft is delivered to the arb for

00:10:47,519 --> 00:10:54,480
approval and formal adoption

00:10:49,760 --> 00:10:54,480
and releases the next official version

00:10:54,959 --> 00:10:57,279
all right

00:10:58,079 --> 00:11:01,920
and now i'll hand it back to michael all

00:11:00,640 --> 00:11:05,200
right thank you

00:11:01,920 --> 00:11:07,839
so just as a recap to prepare the stage

00:11:05,200 --> 00:11:09,440
for openmp52 and what we're planning for

00:11:07,839 --> 00:11:11,920
openmp6

00:11:09,440 --> 00:11:15,360
um i want to quickly build up a slide

00:11:11,920 --> 00:11:17,040
that shows what we did with openmp50

00:11:15,360 --> 00:11:19,120
and from the from the list that is

00:11:17,040 --> 00:11:20,079
building up now you can pretty much see

00:11:19,120 --> 00:11:23,120
that

00:11:20,079 --> 00:11:24,720
uh openmp5 probably is the biggest

00:11:23,120 --> 00:11:29,920
release that we ever made

00:11:24,720 --> 00:11:32,160
since openmp was created in 97

00:11:29,920 --> 00:11:34,079
and i we can't really go through all of

00:11:32,160 --> 00:11:36,079
those details the the thing i want to

00:11:34,079 --> 00:11:38,160
mention here is that we are

00:11:36,079 --> 00:11:39,519
certainly planning on having future

00:11:38,160 --> 00:11:42,959
webinars

00:11:39,519 --> 00:11:44,640
on select topics that i'm showing here

00:11:42,959 --> 00:11:47,360
the other thing that i would like to say

00:11:44,640 --> 00:11:50,079
is that there is a constant stream of

00:11:47,360 --> 00:11:51,120
of webinars from from other community

00:11:50,079 --> 00:11:54,079
members as well

00:11:51,120 --> 00:11:56,320
on these topics and let me just

00:11:54,079 --> 00:11:59,120
highlight a few

00:11:56,320 --> 00:12:01,200
features that we introduced so one

00:11:59,120 --> 00:12:03,440
notable thing that we did is we moved

00:12:01,200 --> 00:12:07,600
the base language support to be

00:12:03,440 --> 00:12:10,560
latest uh c plus 14 and 17 support

00:12:07,600 --> 00:12:11,440
for openmp5 remember that is like uh

00:12:10,560 --> 00:12:15,279
three years ago

00:12:11,440 --> 00:12:18,399
already we also moved uh fortran support

00:12:15,279 --> 00:12:21,600
up to 2008

00:12:18,399 --> 00:12:23,519
in terms of gpu programming we

00:12:21,600 --> 00:12:24,399
introduced support for unified shared

00:12:23,519 --> 00:12:27,440
memory

00:12:24,399 --> 00:12:31,040
so gpus that share or

00:12:27,440 --> 00:12:34,720
can natively access host memory without

00:12:31,040 --> 00:12:36,959
data copies we introduced

00:12:34,720 --> 00:12:39,040
the collapsing of non-rectangular loops

00:12:36,959 --> 00:12:41,279
so if you have an algorithm

00:12:39,040 --> 00:12:43,519
that you want to parallelize that is

00:12:41,279 --> 00:12:45,360
that has a triangular loop nest

00:12:43,519 --> 00:12:47,839
uh one particular example is the back

00:12:45,360 --> 00:12:49,760
substitution in a linear solver

00:12:47,839 --> 00:12:51,360
you can now collapse those non-rank

00:12:49,760 --> 00:12:53,519
tango loops and then

00:12:51,360 --> 00:12:55,120
use work sharing constructs on top of

00:12:53,519 --> 00:12:58,320
that collapsing

00:12:55,120 --> 00:12:59,360
to parallelize those loops we introduced

00:12:58,320 --> 00:13:02,720
meta directives

00:12:59,360 --> 00:13:06,160
so we can now do meta programming

00:13:02,720 --> 00:13:07,760
in openmp where you can test for certain

00:13:06,160 --> 00:13:12,160
capabilities

00:13:07,760 --> 00:13:15,040
of the implementation and then

00:13:12,160 --> 00:13:16,560
specialize your openmp directives

00:13:15,040 --> 00:13:20,160
according to those

00:13:16,560 --> 00:13:22,880
conditions we introduced parallel scan

00:13:20,160 --> 00:13:23,839
where you can parallelize loops that

00:13:22,880 --> 00:13:27,040
implement

00:13:23,839 --> 00:13:29,760
parallel scan uh prefix and postfix

00:13:27,040 --> 00:13:30,560
we introduced the loop construct to move

00:13:29,760 --> 00:13:33,040
openmp

00:13:30,560 --> 00:13:36,000
a little more into the domain of

00:13:33,040 --> 00:13:40,160
descriptive languages

00:13:36,000 --> 00:13:44,160
we introduced affinity support

00:13:40,160 --> 00:13:47,360
for both

00:13:44,160 --> 00:13:48,800
openmp threads but also openmp tasks and

00:13:47,360 --> 00:13:52,079
we also

00:13:48,800 --> 00:13:54,880
recognized the the trend in the industry

00:13:52,079 --> 00:13:57,920
to have a deeper and more complex memory

00:13:54,880 --> 00:14:01,279
hierarchy and so we now have support

00:13:57,920 --> 00:14:04,720
for memory allocators in openmp

00:14:01,279 --> 00:14:07,040
and then on top of that opening p51

00:14:04,720 --> 00:14:08,959
went ahead and refined several of those

00:14:07,040 --> 00:14:11,920
features

00:14:08,959 --> 00:14:13,680
and you know make them more useful and

00:14:11,920 --> 00:14:17,360
more succinct

00:14:13,680 --> 00:14:19,600
and on top of that refinement we also

00:14:17,360 --> 00:14:20,880
introduced a new directive so for

00:14:19,600 --> 00:14:22,959
instance the loop transformation

00:14:20,880 --> 00:14:26,079
directive where you can now talk about

00:14:22,959 --> 00:14:27,839
tiling and unrolling we added c plus

00:14:26,079 --> 00:14:30,639
plus 20 support

00:14:27,839 --> 00:14:31,839
we actually prefetched c plus 20 support

00:14:30,639 --> 00:14:34,800
before

00:14:31,839 --> 00:14:36,800
iso c plus plus the working group

00:14:34,800 --> 00:14:39,839
actually released the standard

00:14:36,800 --> 00:14:40,399
and for the c plus plus programmers the

00:14:39,839 --> 00:14:43,920
probably

00:14:40,399 --> 00:14:45,519
most notable difference in open mp51 is

00:14:43,920 --> 00:14:48,560
that we now support

00:14:45,519 --> 00:14:50,959
uh c plus plus attribute syntax so

00:14:48,560 --> 00:14:52,240
if you have a c plus plus compiler with

00:14:50,959 --> 00:14:54,800
openmp support

00:14:52,240 --> 00:14:55,760
you can now specify directives in the

00:14:54,800 --> 00:14:58,079
syntax of c

00:14:55,760 --> 00:15:00,079
plus attributes and you don't have to

00:14:58,079 --> 00:15:03,360
use

00:15:00,079 --> 00:15:05,040
pragmas anymore all right

00:15:03,360 --> 00:15:08,560
and now brownies we're going to talk

00:15:05,040 --> 00:15:10,959
about openmp52

00:15:08,560 --> 00:15:12,079
um before before we go on to that let me

00:15:10,959 --> 00:15:15,279
just go back to

00:15:12,079 --> 00:15:19,360
5.1 for just a second so

00:15:15,279 --> 00:15:21,920
i i think michael was correct that um

00:15:19,360 --> 00:15:23,760
the attribute syntax is probably the

00:15:21,920 --> 00:15:27,600
most significant addition

00:15:23,760 --> 00:15:31,279
although for now it is largely

00:15:27,600 --> 00:15:36,240
syntactic sugar for the existing

00:15:31,279 --> 00:15:36,240
syntax for the existing features

00:15:36,480 --> 00:15:40,240
some of the other features in there that

00:15:38,560 --> 00:15:41,839
are also fairly significant

00:15:40,240 --> 00:15:45,120
the assumed directive is one that i

00:15:41,839 --> 00:15:48,880
think will prove very useful

00:15:45,120 --> 00:15:52,160
for allowing compilers to

00:15:48,880 --> 00:15:56,079
to implement much more efficient code

00:15:52,160 --> 00:15:59,040
and i i've gotten feedback from

00:15:56,079 --> 00:16:00,800
from livermore users uh i work at

00:15:59,040 --> 00:16:02,480
lawrence livermore national lab i guess

00:16:00,800 --> 00:16:06,639
i didn't mention that earlier

00:16:02,480 --> 00:16:08,160
um the error directive is also one that

00:16:06,639 --> 00:16:09,440
they mentioned as being particularly

00:16:08,160 --> 00:16:11,680
important

00:16:09,440 --> 00:16:12,480
it's a small feature but it's it can be

00:16:11,680 --> 00:16:16,000
uh

00:16:12,480 --> 00:16:19,600
very useful um

00:16:16,000 --> 00:16:20,399
all right so openmp 5.2 what's it going

00:16:19,600 --> 00:16:23,600
to be

00:16:20,399 --> 00:16:24,639
well so the attribute syntax actually

00:16:23,600 --> 00:16:27,839
motivated us

00:16:24,639 --> 00:16:31,279
to um decide to to do

00:16:27,839 --> 00:16:34,320
5.2 and um but what

00:16:31,279 --> 00:16:36,480
the way we wrote uh adopted the

00:16:34,320 --> 00:16:39,360
attribute syntax

00:16:36,480 --> 00:16:40,560
in 5.1 was basically we said what the

00:16:39,360 --> 00:16:43,920
the

00:16:40,560 --> 00:16:44,720
the mechanism was we defined how it

00:16:43,920 --> 00:16:48,240
works

00:16:44,720 --> 00:16:51,040
but we didn't update all of the syntax

00:16:48,240 --> 00:16:52,959
boxes throughout the specification to

00:16:51,040 --> 00:16:54,639
reflect that there's attribute syntax

00:16:52,959 --> 00:16:56,959
instead we just said oh you can also use

00:16:54,639 --> 00:16:59,040
accuracy

00:16:56,959 --> 00:17:00,480
and we made some other small changes to

00:16:59,040 --> 00:17:02,000
make it so that it would be more

00:17:00,480 --> 00:17:04,240
consistent with the way

00:17:02,000 --> 00:17:05,839
attributes work in c plus plus but there

00:17:04,240 --> 00:17:09,120
there were some other things that

00:17:05,839 --> 00:17:11,679
that you know basically um

00:17:09,120 --> 00:17:12,240
we felt could be stated more clearly and

00:17:11,679 --> 00:17:15,280
would

00:17:12,240 --> 00:17:18,559
support us being able to in

00:17:15,280 --> 00:17:21,919
in 6.0 and in the future better

00:17:18,559 --> 00:17:22,400
able to exploit the um benefits that

00:17:21,919 --> 00:17:25,839
have

00:17:22,400 --> 00:17:29,120
having attribute syntax could provide

00:17:25,839 --> 00:17:32,320
so we decided to basically redo how we

00:17:29,120 --> 00:17:35,760
specified the syntax in openmp

00:17:32,320 --> 00:17:37,120
um and as part of looking at that we

00:17:35,760 --> 00:17:42,320
realized that

00:17:37,120 --> 00:17:45,280
um we also often had inconsistencies

00:17:42,320 --> 00:17:47,200
between what we specify for different

00:17:45,280 --> 00:17:50,240
directives and causes

00:17:47,200 --> 00:17:53,440
um we often

00:17:50,240 --> 00:17:56,400
hid restrictions in the

00:17:53,440 --> 00:17:57,760
syntax box basically like well here

00:17:56,400 --> 00:18:00,640
here's a clause

00:17:57,760 --> 00:18:02,880
it has a modifier but oh we didn't list

00:18:00,640 --> 00:18:06,880
the modifier in the

00:18:02,880 --> 00:18:10,240
syntax box for that directive

00:18:06,880 --> 00:18:11,919
um and so therefore you can't use that

00:18:10,240 --> 00:18:13,840
modifier

00:18:11,919 --> 00:18:15,440
sometimes that was intentional and

00:18:13,840 --> 00:18:19,360
sometimes it was

00:18:15,440 --> 00:18:23,039
more than likely an artifact of we

00:18:19,360 --> 00:18:25,840
adopted a a

00:18:23,039 --> 00:18:26,720
a directive at the same time we were

00:18:25,840 --> 00:18:29,760
enhancing

00:18:26,720 --> 00:18:32,960
the way the clause worked and so the

00:18:29,760 --> 00:18:36,320
directive got the syntax of

00:18:32,960 --> 00:18:39,520
of the old clause syntax

00:18:36,320 --> 00:18:42,960
and the new clause syntax didn't make it

00:18:39,520 --> 00:18:47,280
into the directive um so

00:18:42,960 --> 00:18:50,799
basically we're completely

00:18:47,280 --> 00:18:51,280
uh we're specifying the syntax at a much

00:18:50,799 --> 00:18:53,600
higher

00:18:51,280 --> 00:18:55,440
level so that now you can basically say

00:18:53,600 --> 00:18:58,559
well here's a directed name

00:18:55,440 --> 00:19:01,520
and here's the way it works uh you know

00:18:58,559 --> 00:19:02,480
you always if it had it can adorn this

00:19:01,520 --> 00:19:05,840
type of

00:19:02,480 --> 00:19:08,799
base language code and

00:19:05,840 --> 00:19:09,679
clauses look like this on any directive

00:19:08,799 --> 00:19:11,760
all right

00:19:09,679 --> 00:19:14,400
and so that way the clauses are now

00:19:11,760 --> 00:19:16,240
specified fully separately from

00:19:14,400 --> 00:19:17,919
the actual directives all that's

00:19:16,240 --> 00:19:20,559
specified with the directives

00:19:17,919 --> 00:19:21,440
is that you can use that clause on that

00:19:20,559 --> 00:19:25,840
directive

00:19:21,440 --> 00:19:29,280
so now um if there are restrictions

00:19:25,840 --> 00:19:31,760
on what you can use on the the

00:19:29,280 --> 00:19:33,440
on some aspects of the causes related to

00:19:31,760 --> 00:19:36,240
that directive they have to be

00:19:33,440 --> 00:19:38,160
explicitly stated in the restrictions on

00:19:36,240 --> 00:19:41,520
the directive

00:19:38,160 --> 00:19:43,360
all right um another thing is that um

00:19:41,520 --> 00:19:46,240
we sometimes thought we were being

00:19:43,360 --> 00:19:46,240
clever and

00:19:46,960 --> 00:19:52,640
adopted overloading of claws names or

00:19:50,080 --> 00:19:56,559
things like that

00:19:52,640 --> 00:20:02,080
and we found that it one made

00:19:56,559 --> 00:20:02,080
parsing for openmp much more complex

00:20:02,480 --> 00:20:05,280
but it also

00:20:05,679 --> 00:20:10,799
could lead to uh issues where we needed

00:20:08,720 --> 00:20:13,280
to have a lot more restrictions

00:20:10,799 --> 00:20:14,159
on the use of the clauses so we're

00:20:13,280 --> 00:20:18,000
actually

00:20:14,159 --> 00:20:21,360
deprecating a lot of the

00:20:18,000 --> 00:20:22,400
overloading of clause syntax or even in

00:20:21,360 --> 00:20:25,520
one case of

00:20:22,400 --> 00:20:27,919
um directive syntax so

00:20:25,520 --> 00:20:29,360
um for directives we have an allocate

00:20:27,919 --> 00:20:32,799
directive that

00:20:29,360 --> 00:20:36,400
that is normally a declarative directive

00:20:32,799 --> 00:20:39,280
but can also adorn and

00:20:36,400 --> 00:20:39,280
annotate a

00:20:42,000 --> 00:20:45,440
fortran allocate statement and the way

00:20:44,960 --> 00:20:49,360
that

00:20:45,440 --> 00:20:53,600
that allocate construct works

00:20:49,360 --> 00:20:56,240
was unusual

00:20:53,600 --> 00:20:58,240
in itself and actually because we need

00:20:56,240 --> 00:21:01,919
to be able to disambiguate

00:20:58,240 --> 00:21:02,799
the allocate construct from it being a

00:21:01,919 --> 00:21:05,280
declarative

00:21:02,799 --> 00:21:07,280
directive it then brought in

00:21:05,280 --> 00:21:07,600
restrictions on where you could place it

00:21:07,280 --> 00:21:09,120
that

00:21:07,600 --> 00:21:10,640
that weren't very useful so we're going

00:21:09,120 --> 00:21:13,440
to change that to

00:21:10,640 --> 00:21:15,120
the the allocators directive the

00:21:13,440 --> 00:21:16,159
allocate directive will still be

00:21:15,120 --> 00:21:17,919
available

00:21:16,159 --> 00:21:19,840
i mean the allocate construct will still

00:21:17,919 --> 00:21:23,760
be available in 5.2

00:21:19,840 --> 00:21:25,200
but we'll be removing it in 6.0

00:21:23,760 --> 00:21:27,200
so what are some of the other things

00:21:25,200 --> 00:21:29,280
that we've deprecated well one thing

00:21:27,200 --> 00:21:32,559
that we deprecated

00:21:29,280 --> 00:21:35,600
that wasn't because of

00:21:32,559 --> 00:21:37,440
syntax issues was the minus reduction we

00:21:35,600 --> 00:21:40,640
we looked at that towards the end of the

00:21:37,440 --> 00:21:42,720
5.1 process and realized that

00:21:40,640 --> 00:21:44,000
nobody could could understand what even

00:21:42,720 --> 00:21:46,000
on the language committee could

00:21:44,000 --> 00:21:46,960
understand why it was defined the way it

00:21:46,000 --> 00:21:50,240
is

00:21:46,960 --> 00:21:52,799
and the result that it provided was

00:21:50,240 --> 00:21:54,559
very strange basically it was called the

00:21:52,799 --> 00:21:56,840
minus reduction but you got a sum

00:21:54,559 --> 00:21:59,840
reduction

00:21:56,840 --> 00:21:59,840
um

00:21:59,919 --> 00:22:03,360
we decided that that should just be

00:22:01,840 --> 00:22:05,760
removed so

00:22:03,360 --> 00:22:08,000
um it will be deprecated in 5 2 and

00:22:05,760 --> 00:22:11,679
removed in 6.0

00:22:08,000 --> 00:22:16,400
we also have deprecated some aspects

00:22:11,679 --> 00:22:19,520
of the syntax of the linear clause

00:22:16,400 --> 00:22:23,440
because it was

00:22:19,520 --> 00:22:26,559
a complete one-off the reasons for

00:22:23,440 --> 00:22:29,200
kind of down in the weeds but um it will

00:22:26,559 --> 00:22:30,320
now be much more consistent with the way

00:22:29,200 --> 00:22:34,240
other causes are

00:22:30,320 --> 00:22:36,320
are the syntax of other causes

00:22:34,240 --> 00:22:38,240
another one that we're changing the

00:22:36,320 --> 00:22:41,679
syntax for is the uses

00:22:38,240 --> 00:22:47,280
allocators clause on the target

00:22:41,679 --> 00:22:50,559
construct that was extremely strange

00:22:47,280 --> 00:22:54,000
complete one-off on its and

00:22:50,559 --> 00:22:56,080
a poll of implementers led us to believe

00:22:54,000 --> 00:22:57,679
that not nobody had yet implemented it

00:22:56,080 --> 00:22:59,360
and would have and they would have

00:22:57,679 --> 00:23:02,000
everyone would have found it difficult

00:22:59,360 --> 00:23:04,240
to implement as it had been specified

00:23:02,000 --> 00:23:05,679
so we we made it again much more

00:23:04,240 --> 00:23:09,600
consistent with

00:23:05,679 --> 00:23:11,919
um how uh other causes

00:23:09,600 --> 00:23:13,760
the syntax of other causes and we we

00:23:11,919 --> 00:23:15,679
believe it'll actually be easier for

00:23:13,760 --> 00:23:20,000
users to understand what it's doing

00:23:15,679 --> 00:23:20,000
as well um

00:23:20,400 --> 00:23:27,200
let's see um so we're deprecating the

00:23:25,039 --> 00:23:28,240
limited form of the declare target

00:23:27,200 --> 00:23:31,760
directive

00:23:28,240 --> 00:23:34,320
we had a few uh versions ago

00:23:31,760 --> 00:23:35,039
adopted the begin declared target

00:23:34,320 --> 00:23:36,799
directive

00:23:35,039 --> 00:23:38,799
which basically replaced the declare

00:23:36,799 --> 00:23:42,159
target directive but we just

00:23:38,799 --> 00:23:44,559
failed to deprecate that form of the

00:23:42,159 --> 00:23:46,880
declare target directive at the time

00:23:44,559 --> 00:23:49,200
um and so we're doing that now because

00:23:46,880 --> 00:23:51,120
again it makes

00:23:49,200 --> 00:23:54,080
it removes a bunch of ambiguities in the

00:23:51,120 --> 00:23:56,720
way the specification works

00:23:54,080 --> 00:23:58,559
um one of the biggest ones that we're

00:23:56,720 --> 00:24:01,279
changing is actually the depend

00:23:58,559 --> 00:24:02,080
clause um i wonder how many people are

00:24:01,279 --> 00:24:05,440
aware that

00:24:02,080 --> 00:24:08,640
openmp supports uh due across

00:24:05,440 --> 00:24:12,159
parallelism uh we we adopted that

00:24:08,640 --> 00:24:15,360
some time ago i think it was in three

00:24:12,159 --> 00:24:17,200
one openmp 3-1 i believe i'd have to go

00:24:15,360 --> 00:24:19,679
back and look but it was

00:24:17,200 --> 00:24:21,919
many years ago that we adopted uh

00:24:19,679 --> 00:24:24,159
support for do across parallelism

00:24:21,919 --> 00:24:26,320
uh personally i i've been disappointed

00:24:24,159 --> 00:24:30,559
in the quality of the implementations

00:24:26,320 --> 00:24:32,480
of it in most cases the best

00:24:30,559 --> 00:24:33,600
the best implementation would involve

00:24:32,480 --> 00:24:37,760
loop skewing

00:24:33,600 --> 00:24:40,799
uh and and the directive the the

00:24:37,760 --> 00:24:42,799
the clause and and the order directive

00:24:40,799 --> 00:24:46,000
that it use works with

00:24:42,799 --> 00:24:47,919
were formulated in such a way

00:24:46,000 --> 00:24:49,520
to provide all the information that an

00:24:47,919 --> 00:24:51,440
implementation needs to

00:24:49,520 --> 00:24:53,600
to know to do the appropriate loop

00:24:51,440 --> 00:24:56,480
skewing

00:24:53,600 --> 00:24:57,120
we're changing that so that now when you

00:24:56,480 --> 00:25:00,240
want to

00:24:57,120 --> 00:25:01,600
specify these do a cross cross iteration

00:25:00,240 --> 00:25:04,799
dependencies you'll use

00:25:01,600 --> 00:25:07,279
a do a cross clause the rest of the

00:25:04,799 --> 00:25:10,960
syntax is basically the same

00:25:07,279 --> 00:25:13,120
but now you're formally saying i want to

00:25:10,960 --> 00:25:15,360
do across parallelism

00:25:13,120 --> 00:25:19,520
and we're hopeful that this will

00:25:15,360 --> 00:25:19,520
motivate uh better implementations

00:25:20,799 --> 00:25:24,960
all right so um the rest of the changes

00:25:23,840 --> 00:25:27,360
are kind of

00:25:24,960 --> 00:25:28,559
down in the weeds of how how we maintain

00:25:27,360 --> 00:25:31,039
the specification

00:25:28,559 --> 00:25:33,279
we're going to be generating a lot of

00:25:31,039 --> 00:25:37,279
the specification automatically

00:25:33,279 --> 00:25:39,520
our our intent is that this will um

00:25:37,279 --> 00:25:41,120
improve the consistency of what we

00:25:39,520 --> 00:25:44,480
specify

00:25:41,120 --> 00:25:45,440
and therefore make the the um language

00:25:44,480 --> 00:25:48,480
itself

00:25:45,440 --> 00:25:50,400
uh better because either um

00:25:48,480 --> 00:25:52,159
implementers would say would end up

00:25:50,400 --> 00:25:52,480
saying well we know what the intent was

00:25:52,159 --> 00:25:54,559
so

00:25:52,480 --> 00:25:56,159
we'll implement that or else they'd have

00:25:54,559 --> 00:25:56,480
to implement something that was a little

00:25:56,159 --> 00:25:58,720
bit

00:25:56,480 --> 00:25:59,840
one-off because well we didn't remember

00:25:58,720 --> 00:26:03,279
to repeat it

00:25:59,840 --> 00:26:06,640
a a restriction in this section we

00:26:03,279 --> 00:26:08,480
the labels aren't the same so

00:26:06,640 --> 00:26:10,880
you don't get all the cross-references

00:26:08,480 --> 00:26:12,559
quite right the index interest

00:26:10,880 --> 00:26:14,159
entries aren't right we're trying to

00:26:12,559 --> 00:26:18,799
generally just further

00:26:14,159 --> 00:26:22,559
improve the quality of the specification

00:26:18,799 --> 00:26:27,120
in a way 5.2 could be viewed as

00:26:22,559 --> 00:26:27,120
one very large quality control pass

00:26:27,440 --> 00:26:32,080
all right so uh as i said in this last

00:26:31,520 --> 00:26:34,960
bullet

00:26:32,080 --> 00:26:35,840
we actually expect to then eventually

00:26:34,960 --> 00:26:38,080
hopefully for

00:26:35,840 --> 00:26:39,760
for 5.2 for the quick reference guys

00:26:38,080 --> 00:26:43,039
we'll see if that works out

00:26:39,760 --> 00:26:45,600
uh actually support automatic generation

00:26:43,039 --> 00:26:46,559
from what's used in the in the spec

00:26:45,600 --> 00:26:49,840
itself

00:26:46,559 --> 00:26:52,159
to generate the quick reference guide

00:26:49,840 --> 00:26:54,720
for the 6-0 time frame we're looking at

00:26:52,159 --> 00:26:55,760
at generating a grammar automatically

00:26:54,720 --> 00:26:58,320
that can be

00:26:55,760 --> 00:26:59,520
used by implementers to be sure that

00:26:58,320 --> 00:27:02,640
they're getting the correct

00:26:59,520 --> 00:27:04,880
parser on to the next slide michael

00:27:02,640 --> 00:27:04,880
please

00:27:05,600 --> 00:27:08,960
all right so so what are we looking at

00:27:07,679 --> 00:27:12,000
for for openmp

00:27:08,960 --> 00:27:14,559
uh 6.0 um so

00:27:12,000 --> 00:27:16,880
i've already hinted at this we started

00:27:14,559 --> 00:27:18,320
deprecating features in 5.0

00:27:16,880 --> 00:27:20,240
you know something that was probably a

00:27:18,320 --> 00:27:23,600
long time coming but we just

00:27:20,240 --> 00:27:25,600
hadn't convinced ourselves that it was

00:27:23,600 --> 00:27:27,120
the right thing to do for anything so we

00:27:25,600 --> 00:27:30,399
were kind of

00:27:27,120 --> 00:27:32,240
um slowly accreting

00:27:30,399 --> 00:27:33,760
things that we felt were broken and we

00:27:32,240 --> 00:27:35,279
would tell people don't use that it's

00:27:33,760 --> 00:27:37,360
not the right way to do it do it this

00:27:35,279 --> 00:27:39,279
way instead

00:27:37,360 --> 00:27:40,960
but the the specs still said you could

00:27:39,279 --> 00:27:43,600
do it the other way

00:27:40,960 --> 00:27:45,840
and the reason was well we need to

00:27:43,600 --> 00:27:49,440
maintain that for backward compatibility

00:27:45,840 --> 00:27:52,480
which um

00:27:49,440 --> 00:27:54,480
you know there's there's

00:27:52,480 --> 00:27:55,679
value in backwards compatibility but

00:27:54,480 --> 00:27:59,200
when it makes people

00:27:55,679 --> 00:28:03,600
uh use features that are not the

00:27:59,200 --> 00:28:06,960
the best designed ones um it's maybe not

00:28:03,600 --> 00:28:09,200
not the uh end-all um our

00:28:06,960 --> 00:28:09,200
our

00:28:10,240 --> 00:28:14,000
the implementers have generally all told

00:28:12,159 --> 00:28:15,760
us that um

00:28:14,000 --> 00:28:17,440
even if we remove features they'll

00:28:15,760 --> 00:28:20,559
continue to support them

00:28:17,440 --> 00:28:23,520
our hope is that by removing them and

00:28:20,559 --> 00:28:24,960
uh making them so we can say that that's

00:28:23,520 --> 00:28:26,880
not something you should

00:28:24,960 --> 00:28:28,960
it's really not something that exists

00:28:26,880 --> 00:28:31,600
yeah you can go and still use it because

00:28:28,960 --> 00:28:35,120
implementation support

00:28:31,600 --> 00:28:37,600
you you won't get updates to um

00:28:35,120 --> 00:28:38,399
the capabilities that way because we're

00:28:37,600 --> 00:28:41,760
not going to

00:28:38,399 --> 00:28:45,279
update them and you'll be dependent on

00:28:41,760 --> 00:28:47,360
implementation defined behaviors for

00:28:45,279 --> 00:28:49,520
things related to new features at that

00:28:47,360 --> 00:28:52,960
point

00:28:49,520 --> 00:28:56,399
anyway so um a big thing i think that

00:28:52,960 --> 00:28:59,039
that's increased

00:28:56,399 --> 00:29:01,520
adoption of openmp has been it's the

00:28:59,039 --> 00:29:03,279
device support that was first adopted in

00:29:01,520 --> 00:29:06,399
openmp 4.0

00:29:03,279 --> 00:29:09,120
and we've improved significantly in

00:29:06,399 --> 00:29:11,200
each of the subsequent releases of

00:29:09,120 --> 00:29:14,720
openmp 4.5

00:29:11,200 --> 00:29:18,159
openmp 5.0 and openmp 5.1

00:29:14,720 --> 00:29:21,520
i think many have felt that 5.0 is where

00:29:18,159 --> 00:29:24,880
the device support really reached

00:29:21,520 --> 00:29:27,919
a sufficiently uh integrated level

00:29:24,880 --> 00:29:31,120
with the rest of the specification to be

00:29:27,919 --> 00:29:33,760
um really quite compelling to use

00:29:31,120 --> 00:29:34,480
um things that that one thing that we

00:29:33,760 --> 00:29:36,799
haven't

00:29:34,480 --> 00:29:38,320
done is provide true support for using

00:29:36,799 --> 00:29:41,039
multiple devices

00:29:38,320 --> 00:29:41,600
right now you can use multiple devices

00:29:41,039 --> 00:29:44,640
by

00:29:41,600 --> 00:29:49,279
specifying a device number but

00:29:44,640 --> 00:29:49,279
you can't do things like easily

00:29:49,440 --> 00:29:56,000
update uh memory

00:29:52,840 --> 00:29:59,360
across uh different

00:29:56,000 --> 00:30:03,600
target devices you can't uh

00:29:59,360 --> 00:30:08,240
multicast um a

00:30:03,600 --> 00:30:13,360
uh data from the host to those

00:30:08,240 --> 00:30:16,640
multiple target devices you can't share

00:30:13,360 --> 00:30:20,840
you can't work share

00:30:16,640 --> 00:30:23,600
regions across multiple devices

00:30:20,840 --> 00:30:25,679
basically anything you want to do using

00:30:23,600 --> 00:30:28,559
multiple devices you have to do

00:30:25,679 --> 00:30:31,679
in singular fashion so you don't get

00:30:28,559 --> 00:30:35,200
bulk launch across multiple devices

00:30:31,679 --> 00:30:38,640
and you then have to hand implement

00:30:35,200 --> 00:30:42,559
any kind of sharing

00:30:38,640 --> 00:30:45,679
of different of sharing

00:30:42,559 --> 00:30:48,480
one unified workload

00:30:45,679 --> 00:30:50,480
so if you wanted to distribute a single

00:30:48,480 --> 00:30:51,279
loop across multiple devices you have to

00:30:50,480 --> 00:30:54,720
actually

00:30:51,279 --> 00:30:57,120
do that all by hand um

00:30:54,720 --> 00:30:59,120
we're definitely also looking at at

00:30:57,120 --> 00:31:01,760
improvements for single device

00:30:59,120 --> 00:31:03,039
support a big one that we're considering

00:31:01,760 --> 00:31:05,279
is is deep

00:31:03,039 --> 00:31:06,399
in further enhancements to deep copy

00:31:05,279 --> 00:31:08,799
support we

00:31:06,399 --> 00:31:10,799
we added initial deep copy support with

00:31:08,799 --> 00:31:13,840
user-defined mappers

00:31:10,799 --> 00:31:17,679
um with the

00:31:13,840 --> 00:31:20,000
more intricate

00:31:17,679 --> 00:31:22,640
deep copy support where you can specify

00:31:20,000 --> 00:31:24,080
serialize and deserialize functions

00:31:22,640 --> 00:31:26,399
uh you would have much greater

00:31:24,080 --> 00:31:29,279
capability and in fact

00:31:26,399 --> 00:31:31,840
it would actually allow you to map from

00:31:29,279 --> 00:31:34,960
one type to another uh

00:31:31,840 --> 00:31:36,559
from the enclosing region to what you're

00:31:34,960 --> 00:31:38,960
actually executing

00:31:36,559 --> 00:31:40,640
on the device this could allow you to do

00:31:38,960 --> 00:31:43,840
things like

00:31:40,640 --> 00:31:47,600
use a dense structure on on

00:31:43,840 --> 00:31:50,480
in your offload region for

00:31:47,600 --> 00:31:51,600
a sparse structure in in the rest of

00:31:50,480 --> 00:31:54,080
your code

00:31:51,600 --> 00:31:56,480
as long as you're copying data from from

00:31:54,080 --> 00:31:57,519
the host memory to the device memory why

00:31:56,480 --> 00:32:01,120
not

00:31:57,519 --> 00:32:03,360
do it compactly would be the idea

00:32:01,120 --> 00:32:05,120
we're also considering other ways to

00:32:03,360 --> 00:32:07,679
support memory higher

00:32:05,120 --> 00:32:09,200
memory affinity and complex memory

00:32:07,679 --> 00:32:12,480
hierarchies that are becoming more and

00:32:09,200 --> 00:32:14,000
more prevalent in today's architectures

00:32:12,480 --> 00:32:15,679
another thing that we've talked about

00:32:14,000 --> 00:32:19,120
for a long time is

00:32:15,679 --> 00:32:20,000
uh improvements to tasks tasking support

00:32:19,120 --> 00:32:23,440
so

00:32:20,000 --> 00:32:25,360
um with cast only or

00:32:23,440 --> 00:32:27,200
free agent threads this means that you

00:32:25,360 --> 00:32:28,000
wouldn't have to create a parallel

00:32:27,200 --> 00:32:31,039
region

00:32:28,000 --> 00:32:34,480
in order to get parallelism with your

00:32:31,039 --> 00:32:35,679
openmp task another thing that we're

00:32:34,480 --> 00:32:38,720
looking to be able to do

00:32:35,679 --> 00:32:41,679
is for one

00:32:38,720 --> 00:32:43,200
team to spawn a task that's executed by

00:32:41,679 --> 00:32:47,039
a different team

00:32:43,200 --> 00:32:49,840
this provides a lot of

00:32:47,039 --> 00:32:51,440
different possibilities that that you

00:32:49,840 --> 00:32:53,679
can support with the openmp

00:32:51,440 --> 00:32:54,960
tasking model one thing that it

00:32:53,679 --> 00:32:56,799
particularly would support

00:32:54,960 --> 00:32:59,039
is event driven parallelism so you could

00:32:56,799 --> 00:33:02,640
have um

00:32:59,039 --> 00:33:05,200
kind of a a loop that is your event loop

00:33:02,640 --> 00:33:06,000
and when an event happens either from

00:33:05,200 --> 00:33:09,200
mousing

00:33:06,000 --> 00:33:11,840
or network track

00:33:09,200 --> 00:33:12,480
network messages or whatever the events

00:33:11,840 --> 00:33:14,399
are

00:33:12,480 --> 00:33:15,600
you can then spawn a task that's

00:33:14,399 --> 00:33:18,159
executed by

00:33:15,600 --> 00:33:19,600
a different um team of threads which

00:33:18,159 --> 00:33:23,360
would mean that you could

00:33:19,600 --> 00:33:24,240
isolate the the work from for processing

00:33:23,360 --> 00:33:26,880
the event

00:33:24,240 --> 00:33:28,399
from the event loop itself ensuring that

00:33:26,880 --> 00:33:30,399
the event loop will continue to be

00:33:28,399 --> 00:33:34,320
responsive

00:33:30,399 --> 00:33:34,880
um we'll be looking at at ways to

00:33:34,320 --> 00:33:38,960
provide

00:33:34,880 --> 00:33:42,000
better support for being descriptive

00:33:38,960 --> 00:33:42,480
in saying well here's what i know about

00:33:42,000 --> 00:33:45,279
my

00:33:42,480 --> 00:33:45,840
the semantics of my code compiler take

00:33:45,279 --> 00:33:50,559
that

00:33:45,840 --> 00:33:50,559
and and use that to give me better uh

00:33:50,799 --> 00:33:54,080
code without me having to tell you

00:33:52,559 --> 00:33:56,080
exactly what to do

00:33:54,080 --> 00:33:58,399
um on the other hand we're looking to

00:33:56,080 --> 00:33:58,960
provide more prescriptive control as

00:33:58,399 --> 00:34:00,960
well

00:33:58,960 --> 00:34:03,440
ways to say look i really want to do

00:34:00,960 --> 00:34:04,080
this so one thing that i i'm hoping we

00:34:03,440 --> 00:34:07,360
might do

00:34:04,080 --> 00:34:11,200
is is provide a way that you can say

00:34:07,360 --> 00:34:13,919
compiler i want you to syndize this

00:34:11,200 --> 00:34:14,240
region and no i don't care what you

00:34:13,919 --> 00:34:18,720
think

00:34:14,240 --> 00:34:22,000
is best another thing that that we've

00:34:18,720 --> 00:34:25,440
begun considering as we see a lot number

00:34:22,000 --> 00:34:28,240
of data flow architectures and cgras

00:34:25,440 --> 00:34:30,079
becoming popular is support for

00:34:28,240 --> 00:34:34,240
pipelining and other

00:34:30,079 --> 00:34:35,919
types of parallelism

00:34:34,240 --> 00:34:38,560
anyway so so with that i'm going to hand

00:34:35,919 --> 00:34:40,800
it back to michael

00:34:38,560 --> 00:34:42,000
all right so i'm going to inject a quick

00:34:40,800 --> 00:34:45,280
commercial break

00:34:42,000 --> 00:34:47,760
if you will um so if you want to have

00:34:45,280 --> 00:34:50,960
access to the openmp specification

00:34:47,760 --> 00:34:53,839
we've been publishing it for

00:34:50,960 --> 00:34:54,480
pretty much the beginning of time as a

00:34:53,839 --> 00:34:58,240
pdf

00:34:54,480 --> 00:35:02,079
through openmp.org and with

00:34:58,240 --> 00:35:05,280
i think it was openmp4 we also started

00:35:02,079 --> 00:35:07,200
publishing the openmp specification as

00:35:05,280 --> 00:35:09,520
an html document

00:35:07,200 --> 00:35:11,520
which greatly simplifies you know

00:35:09,520 --> 00:35:14,720
referring to it from

00:35:11,520 --> 00:35:17,680
from the internet um

00:35:14,720 --> 00:35:19,599
and um so you know the pdf is still kind

00:35:17,680 --> 00:35:22,960
of the the ground truth of opening

00:35:19,599 --> 00:35:25,520
of the openmp specification but the html

00:35:22,960 --> 00:35:26,000
uh makes it more accessible and then

00:35:25,520 --> 00:35:27,760
about

00:35:26,000 --> 00:35:29,440
five years ago we also started

00:35:27,760 --> 00:35:33,440
publishing the open

00:35:29,440 --> 00:35:35,760
vacation as a book so if you

00:35:33,440 --> 00:35:36,720
like the look and feel of a real book on

00:35:35,760 --> 00:35:40,560
your desk

00:35:36,720 --> 00:35:42,640
you can now get that through amazon

00:35:40,560 --> 00:35:44,400
we pretty much stale that at near

00:35:42,640 --> 00:35:45,040
wholesale price so pretty much at the

00:35:44,400 --> 00:35:47,760
cost

00:35:45,040 --> 00:35:48,560
that we incur uh for the on-demand

00:35:47,760 --> 00:35:51,440
publishing

00:35:48,560 --> 00:35:52,000
of the book and that's you know a great

00:35:51,440 --> 00:35:54,880
um

00:35:52,000 --> 00:35:56,720
way to show your open peep right in your

00:35:54,880 --> 00:36:00,160
bookshelf

00:35:56,720 --> 00:36:01,040
and as promised earlier um i wanted to

00:36:00,160 --> 00:36:03,040
come back to

00:36:01,040 --> 00:36:04,400
our members and you know one of the

00:36:03,040 --> 00:36:08,160
things that

00:36:04,400 --> 00:36:11,200
um the air b is is um

00:36:08,160 --> 00:36:13,119
having as a invaluable resource is the

00:36:11,200 --> 00:36:14,400
the members that support us that

00:36:13,119 --> 00:36:17,599
contribute

00:36:14,400 --> 00:36:21,119
uh to the openmp specification that had

00:36:17,599 --> 00:36:23,680
in proposals and that put in all sorts

00:36:21,119 --> 00:36:28,000
of resources

00:36:23,680 --> 00:36:30,480
to help us develop the openmp language

00:36:28,000 --> 00:36:31,119
this is just logos if you read through

00:36:30,480 --> 00:36:35,040
it it's

00:36:31,119 --> 00:36:39,520
um the who's who of hpc there's

00:36:35,040 --> 00:36:42,960
almost all major hpc vendors are on it

00:36:39,520 --> 00:36:44,560
all major users of openmp are on that

00:36:42,960 --> 00:36:46,400
so especially from the from the

00:36:44,560 --> 00:36:47,359
department of energy the national labs

00:36:46,400 --> 00:36:49,760
in the u.s

00:36:47,359 --> 00:36:50,480
but also some tier zero centers from

00:36:49,760 --> 00:36:54,000
europe

00:36:50,480 --> 00:36:57,200
are there and other companies who have

00:36:54,000 --> 00:37:00,240
a vested interest in developing um

00:36:57,200 --> 00:37:03,599
implementations of openmp or

00:37:00,240 --> 00:37:06,240
are openmp users and

00:37:03,599 --> 00:37:08,000
you can consider this webinar as kind of

00:37:06,240 --> 00:37:11,359
a call for participation so

00:37:08,000 --> 00:37:12,160
if you are interested in joining the

00:37:11,359 --> 00:37:14,800
openmp

00:37:12,160 --> 00:37:15,520
arb one thing that we did in the past

00:37:14,800 --> 00:37:18,960
years was

00:37:15,520 --> 00:37:22,160
make it easier to become a member

00:37:18,960 --> 00:37:25,440
and what we did is we introduced three

00:37:22,160 --> 00:37:27,119
membership classes with different price

00:37:25,440 --> 00:37:29,760
tags

00:37:27,119 --> 00:37:31,040
so that you can you can pick and choose

00:37:29,760 --> 00:37:33,280
what is the best for

00:37:31,040 --> 00:37:34,640
for your organization and the level of

00:37:33,280 --> 00:37:35,920
contributions that you would like to

00:37:34,640 --> 00:37:37,920
make

00:37:35,920 --> 00:37:39,520
i don't want to go too deep in this in

00:37:37,920 --> 00:37:43,200
this but pretty much

00:37:39,520 --> 00:37:45,119
you know you can start at arb

00:37:43,200 --> 00:37:47,680
contributor if you just have an interest

00:37:45,119 --> 00:37:49,440
if you want to get access to

00:37:47,680 --> 00:37:51,200
you know the technical information and

00:37:49,440 --> 00:37:54,560
the drafts that we're working on

00:37:51,200 --> 00:37:56,800
and you will get some

00:37:54,560 --> 00:37:59,680
initial voting rights and then arb

00:37:56,800 --> 00:38:02,400
advisor that's kind of the next level

00:37:59,680 --> 00:38:04,079
where you have more ways to contribute

00:38:02,400 --> 00:38:04,560
and then the highest membership class is

00:38:04,079 --> 00:38:07,599
a or b

00:38:04,560 --> 00:38:10,800
member where you also get to vote

00:38:07,599 --> 00:38:12,400
on organizational topics uh in addition

00:38:10,800 --> 00:38:14,800
to the technical topics so you

00:38:12,400 --> 00:38:16,839
pretty much then have a say in the

00:38:14,800 --> 00:38:18,720
strategy and the direction of the arb

00:38:16,839 --> 00:38:23,440
itself

00:38:18,720 --> 00:38:26,960
the way we interact with the community

00:38:23,440 --> 00:38:28,560
is through several events again if you

00:38:26,960 --> 00:38:32,079
want to know more about this

00:38:28,560 --> 00:38:33,839
visit openmp.org there's the openmp con

00:38:32,079 --> 00:38:37,760
users conference

00:38:33,839 --> 00:38:39,200
that is a gathering of our community to

00:38:37,760 --> 00:38:40,480
just discuss what they're doing with

00:38:39,200 --> 00:38:44,000
openmp

00:38:40,480 --> 00:38:45,040
um raise questions and interact with the

00:38:44,000 --> 00:38:47,200
arb

00:38:45,040 --> 00:38:48,480
then there's the international workshop

00:38:47,200 --> 00:38:52,400
on openmp

00:38:48,480 --> 00:38:55,680
or iwamp that is the research venue

00:38:52,400 --> 00:38:58,720
of the openmp airbn and the community

00:38:55,680 --> 00:39:00,640
where you know people can publish

00:38:58,720 --> 00:39:03,119
latest and greatest research that

00:39:00,640 --> 00:39:06,240
involves openmp

00:39:03,119 --> 00:39:08,000
and parallelism in form of new openmp

00:39:06,240 --> 00:39:11,680
proposals

00:39:08,000 --> 00:39:13,040
but also how openmp is used in hpc

00:39:11,680 --> 00:39:16,160
applications or

00:39:13,040 --> 00:39:17,200
beyond hpc and other domains as well and

00:39:16,160 --> 00:39:20,640
how openmp

00:39:17,200 --> 00:39:23,920
is used in reality and these two events

00:39:20,640 --> 00:39:27,760
are kind of the prime venues for

00:39:23,920 --> 00:39:30,240
us the arb to engage with our community

00:39:27,760 --> 00:39:31,599
and talk to them get their feedback and

00:39:30,240 --> 00:39:34,079
also

00:39:31,599 --> 00:39:36,160
draw proposals from it then there's a

00:39:34,079 --> 00:39:39,440
special event in the uk

00:39:36,160 --> 00:39:43,119
the openmp users group there runs

00:39:39,440 --> 00:39:45,359
a yearly meeting this year's actually

00:39:43,119 --> 00:39:48,800
a joint meeting between openmp con and

00:39:45,359 --> 00:39:51,119
the openmp users group of uk

00:39:48,800 --> 00:39:52,079
that's another event where there's a

00:39:51,119 --> 00:39:55,359
good share of

00:39:52,079 --> 00:39:56,400
openmp arb members available to discuss

00:39:55,359 --> 00:39:59,520
proposals

00:39:56,400 --> 00:40:03,040
give feedback on openmp and um

00:39:59,520 --> 00:40:05,119
for us to interact with the community

00:40:03,040 --> 00:40:07,040
and naturally you know supercomputing

00:40:05,119 --> 00:40:10,560
and international supercomputing

00:40:07,040 --> 00:40:13,599
these are the two major conferences

00:40:10,560 --> 00:40:17,119
in the hpc and supercomputing space and

00:40:13,599 --> 00:40:18,400
we usually have a lineup of several

00:40:17,119 --> 00:40:21,680
tutorials

00:40:18,400 --> 00:40:23,280
that teach different aspects of openmp

00:40:21,680 --> 00:40:26,960
to our community

00:40:23,280 --> 00:40:30,880
so for this year's isc we do have

00:40:26,960 --> 00:40:33,200
a a tutorial called the common core

00:40:30,880 --> 00:40:33,200
where

00:40:33,920 --> 00:40:37,680
the community gets to learn how to you

00:40:36,640 --> 00:40:40,400
know

00:40:37,680 --> 00:40:42,960
be introduced to openmp and then there's

00:40:40,400 --> 00:40:45,760
mastering tasking with openmp

00:40:42,960 --> 00:40:47,440
where people can learn about modern

00:40:45,760 --> 00:40:49,680
openmp tasking

00:40:47,440 --> 00:40:51,440
and for this year's supercomputing we're

00:40:49,680 --> 00:40:53,440
also submitting

00:40:51,440 --> 00:40:54,480
i believe on the order of five or six

00:40:53,440 --> 00:40:57,520
proposals

00:40:54,480 --> 00:40:58,240
for tutorials to also teach the

00:40:57,520 --> 00:41:01,359
community

00:40:58,240 --> 00:41:03,839
how to how to do openmp programming

00:41:01,359 --> 00:41:06,079
if you want to learn more just visit our

00:41:03,839 --> 00:41:08,000
website openmp.org

00:41:06,079 --> 00:41:09,520
there you can find the specification

00:41:08,000 --> 00:41:13,119
links to webinar videos

00:41:09,520 --> 00:41:16,160
training videos recorded tutorials

00:41:13,119 --> 00:41:19,200
blogs upcoming events

00:41:16,160 --> 00:41:22,560
so pretty much this is the one stop shop

00:41:19,200 --> 00:41:25,680
for you if you're interested in um

00:41:22,560 --> 00:41:29,040
in openmp

00:41:25,680 --> 00:41:32,880
all right and there is a question

00:41:29,040 --> 00:41:36,160
what's the status of openmp of compunity

00:41:32,880 --> 00:41:39,920
and its role in the air b so compunity

00:41:36,160 --> 00:41:41,599
initially was um i would call it a meter

00:41:39,920 --> 00:41:44,720
member

00:41:41,599 --> 00:41:48,400
where one when we didn't have the

00:41:44,720 --> 00:41:51,280
refined membership structure

00:41:48,400 --> 00:41:52,640
to make the air be more accessible for

00:41:51,280 --> 00:41:57,040
new members

00:41:52,640 --> 00:42:00,560
compunity was a way for people who

00:41:57,040 --> 00:42:04,319
published at iwomp to

00:42:00,560 --> 00:42:05,599
go into the arb as part of the community

00:42:04,319 --> 00:42:08,800
membership

00:42:05,599 --> 00:42:11,920
um i would like to

00:42:08,800 --> 00:42:15,200
move compunity to be more of

00:42:11,920 --> 00:42:18,960
a user group in the future so

00:42:15,200 --> 00:42:20,960
to take care of the community and be the

00:42:18,960 --> 00:42:22,079
central place for the community to

00:42:20,960 --> 00:42:25,280
interact

00:42:22,079 --> 00:42:27,280
um and you know organize events

00:42:25,280 --> 00:42:28,960
and that kind of stuff so they're still

00:42:27,280 --> 00:42:32,160
a member in the arab

00:42:28,960 --> 00:42:35,680
but i would like to take them to be more

00:42:32,160 --> 00:42:39,359
active in the community as as kind of

00:42:35,680 --> 00:42:39,359
the air beast community branch

00:42:40,000 --> 00:42:44,079
all right um so michael would you say

00:42:43,119 --> 00:42:47,520
it's fair that

00:42:44,079 --> 00:42:48,400
um community membership can serve as

00:42:47,520 --> 00:42:52,079
kind of a

00:42:48,400 --> 00:42:54,800
a way to get an introduction to the

00:42:52,079 --> 00:42:56,560
workings of the language committee and

00:42:54,800 --> 00:42:59,839
and the technical aspects

00:42:56,560 --> 00:43:03,119
of the openmp community

00:42:59,839 --> 00:43:05,760
the openmp arb but um you know

00:43:03,119 --> 00:43:07,200
as you become more and more you know if

00:43:05,760 --> 00:43:08,640
you if you find that you're deeply

00:43:07,200 --> 00:43:10,319
involved in it then we would probably

00:43:08,640 --> 00:43:13,440
encourage you to

00:43:10,319 --> 00:43:14,560
to become you know particularly if your

00:43:13,440 --> 00:43:16,560
organization has

00:43:14,560 --> 00:43:17,920
many people participating we would

00:43:16,560 --> 00:43:21,200
encourage you to

00:43:17,920 --> 00:43:21,200
have your organization john

00:43:22,160 --> 00:43:28,800
that's right okay

00:43:25,440 --> 00:43:30,400
let me close um so

00:43:28,800 --> 00:43:31,920
to summarize what you what you heard

00:43:30,400 --> 00:43:35,760
from us today

00:43:31,920 --> 00:43:38,160
um so five one um and five zero

00:43:35,760 --> 00:43:39,359
we're a major leap forward for openmp

00:43:38,160 --> 00:43:45,200
where

00:43:39,359 --> 00:43:45,200
as bronze and i explained we introduced

00:43:45,280 --> 00:43:51,359
big features to openmp that made

00:43:48,720 --> 00:43:52,720
openmp useful in this heterogeneous

00:43:51,359 --> 00:43:54,160
system

00:43:52,720 --> 00:43:55,920
architecture that we're seeing in the

00:43:54,160 --> 00:43:59,520
community today

00:43:55,920 --> 00:44:01,680
um we also explained that openmp52

00:43:59,520 --> 00:44:03,359
will improve the quality of the

00:44:01,680 --> 00:44:05,280
specification we will clean up

00:44:03,359 --> 00:44:06,640
a bit of baggage that we that we

00:44:05,280 --> 00:44:10,480
accumulated in the past

00:44:06,640 --> 00:44:13,520
two decades and bring openmp

00:44:10,480 --> 00:44:16,640
in shape for the exoscope era and then

00:44:13,520 --> 00:44:20,240
openmp version 6 will then

00:44:16,640 --> 00:44:22,400
add new significant features

00:44:20,240 --> 00:44:23,760
that braun is already kind of mentioned

00:44:22,400 --> 00:44:27,040
uh and if you

00:44:23,760 --> 00:44:29,040
if you have particular feedback on which

00:44:27,040 --> 00:44:31,119
directions we should be going

00:44:29,040 --> 00:44:33,599
uh then we would be happy to hear that

00:44:31,119 --> 00:44:37,200
either in the q a session coming up

00:44:33,599 --> 00:44:40,319
or um offline via email or any other

00:44:37,200 --> 00:44:43,839
mechanism how you can interact with us

00:44:40,319 --> 00:44:44,800
and then hopefully you can you can now

00:44:43,839 --> 00:44:47,920
see that

00:44:44,800 --> 00:44:49,280
openmp is a modern programming model we

00:44:47,920 --> 00:44:51,280
adopted

00:44:49,280 --> 00:44:52,960
the best practices of the of the

00:44:51,280 --> 00:44:54,720
community

00:44:52,960 --> 00:44:56,720
so we now have this multi-level

00:44:54,720 --> 00:44:59,440
parallelism supported consisting of

00:44:56,720 --> 00:45:01,920
co-processors or gpus if you will

00:44:59,440 --> 00:45:05,280
threats and 70

00:45:01,920 --> 00:45:06,880
we have a very modern and expressive

00:45:05,280 --> 00:45:08,400
task-based programming model with

00:45:06,880 --> 00:45:11,520
dependencies

00:45:08,400 --> 00:45:15,359
and built in interaction with

00:45:11,520 --> 00:45:17,200
the offloading to gpus and co-processors

00:45:15,359 --> 00:45:18,480
we do believe that we have a powerful

00:45:17,200 --> 00:45:22,240
language

00:45:18,480 --> 00:45:25,760
that lets you express complex algorithms

00:45:22,240 --> 00:45:26,560
and we still have this span from high

00:45:25,760 --> 00:45:29,119
level

00:45:26,560 --> 00:45:30,560
access to parallelism but we also

00:45:29,119 --> 00:45:33,599
provide

00:45:30,560 --> 00:45:36,000
a forward to high efficient programming

00:45:33,599 --> 00:45:37,280
uh through the prescriptive mechanisms

00:45:36,000 --> 00:45:40,800
that we have

00:45:37,280 --> 00:45:46,000
in openmp and with that um

00:45:40,800 --> 00:45:48,240
i'm done brony's final word

00:45:46,000 --> 00:45:48,240
uh

00:45:49,119 --> 00:45:54,560
uh you caught me by surprise there i'm

00:45:52,319 --> 00:45:56,960
i'm ready to answer questions

00:45:54,560 --> 00:45:58,560
uh stick it through we have a couple

00:45:56,960 --> 00:46:00,079
questions and then hopefully we'll get

00:45:58,560 --> 00:46:03,760
some others

00:46:00,079 --> 00:46:07,200
um we also had a poll after conducting

00:46:03,760 --> 00:46:07,200
all right yes um

00:46:08,880 --> 00:46:15,839
to lazy for the poll yes lucy you're up

00:46:25,119 --> 00:46:29,839
you should all see the res the poll

00:46:26,880 --> 00:46:29,839
results right now

00:46:32,800 --> 00:46:38,400
shockingly i'm surprised it's

00:46:36,720 --> 00:46:43,839
less than half find all of the

00:46:38,400 --> 00:46:43,839
restrictions confusing

00:46:45,920 --> 00:46:50,720
i'm not surprised most people have no

00:46:48,000 --> 00:46:52,240
idea what composite constructs are

00:46:50,720 --> 00:46:54,880
all right well we'll come back to the

00:46:52,240 --> 00:46:58,160
poll results in a second

00:46:54,880 --> 00:47:01,440
first let me handle uh

00:46:58,160 --> 00:47:03,839
start and answer for uh

00:47:01,440 --> 00:47:05,839
jose's question are you aware of

00:47:03,839 --> 00:47:09,040
compilers that will fully implement

00:47:05,839 --> 00:47:09,760
5.1 given that 5.2 is coming up this

00:47:09,040 --> 00:47:13,200
year

00:47:09,760 --> 00:47:14,960
are users encouraged to ignore scary

00:47:13,200 --> 00:47:18,560
quotes 5.1

00:47:14,960 --> 00:47:21,280
once 5.2 is released um

00:47:18,560 --> 00:47:23,599
so i'm not an implementer i i did notice

00:47:21,280 --> 00:47:26,640
that we have a couple implementers on

00:47:23,599 --> 00:47:30,160
on the participating

00:47:26,640 --> 00:47:35,599
um so i see jeff sandoval i see

00:47:30,160 --> 00:47:35,599
jenny george i see johannes dorfford

00:47:36,839 --> 00:47:41,599
so um

00:47:39,359 --> 00:47:43,680
so so take anything i say about what

00:47:41,599 --> 00:47:44,720
implementations will do with a grain of

00:47:43,680 --> 00:47:48,000
salt

00:47:44,720 --> 00:47:50,400
um i i know that many of

00:47:48,000 --> 00:47:51,760
our many of the implementations are very

00:47:50,400 --> 00:47:55,359
actively

00:47:51,760 --> 00:47:55,359
working on uh

00:47:56,010 --> 00:47:59,099
[Music]

00:48:00,960 --> 00:48:05,760
implementing 5-0 and are getting close

00:48:04,000 --> 00:48:09,599
to having

00:48:05,760 --> 00:48:12,160
fully supported um i'm paying i i

00:48:09,599 --> 00:48:15,920
personally am paying particularly

00:48:12,160 --> 00:48:18,400
close attention to the hpe and amd

00:48:15,920 --> 00:48:19,839
implementations these days because i'm

00:48:18,400 --> 00:48:20,480
worrying about what we're going to end

00:48:19,839 --> 00:48:24,000
up

00:48:20,480 --> 00:48:25,200
uh citing when we cite the el capitan

00:48:24,000 --> 00:48:27,200
system that we're in the middle of

00:48:25,200 --> 00:48:30,720
return from hpe

00:48:27,200 --> 00:48:33,599
and i know that um hpe

00:48:30,720 --> 00:48:34,319
has made a lot of progress on 5.0 i know

00:48:33,599 --> 00:48:36,400
they've

00:48:34,319 --> 00:48:37,839
already we've already begun working with

00:48:36,400 --> 00:48:40,400
them on assessing

00:48:37,839 --> 00:48:42,000
priorities for 5.1 i think they've even

00:48:40,400 --> 00:48:44,160
begun a little bit of work on

00:48:42,000 --> 00:48:48,160
implementing 5.1

00:48:44,160 --> 00:48:51,920
if i were to guess it will vary by

00:48:48,160 --> 00:48:55,040
implementation and some will will

00:48:51,920 --> 00:48:56,480
be more sequential about it um for

00:48:55,040 --> 00:48:58,160
whatever reasons whether they're

00:48:56,480 --> 00:49:00,640
contractual or just that

00:48:58,160 --> 00:49:01,440
already started on five one it's easier

00:49:00,640 --> 00:49:04,720
to finish

00:49:01,440 --> 00:49:08,079
than that it's just uh

00:49:04,720 --> 00:49:11,599
change horses in midstream but um

00:49:08,079 --> 00:49:14,480
in general my my encouragement to users

00:49:11,599 --> 00:49:17,680
is to look at the latest version of the

00:49:14,480 --> 00:49:18,960
specification and tell implementers

00:49:17,680 --> 00:49:20,240
if they don't support if there's

00:49:18,960 --> 00:49:21,920
something in that that they don't

00:49:20,240 --> 00:49:22,960
support that would be useful to them

00:49:21,920 --> 00:49:25,280
tell them it would be

00:49:22,960 --> 00:49:27,599
useful and and get them to support it as

00:49:25,280 --> 00:49:29,280
soon as it's useful

00:49:27,599 --> 00:49:33,359
i think the latest version of the

00:49:29,280 --> 00:49:33,359
specification is always the best version

00:49:40,960 --> 00:49:44,640
okay there's another question that i

00:49:42,960 --> 00:49:46,400
would like to take

00:49:44,640 --> 00:49:48,559
can you tell a little bit more about

00:49:46,400 --> 00:49:52,160
tasking support improvements

00:49:48,559 --> 00:49:56,319
in openmp six zero so

00:49:52,160 --> 00:49:59,119
um with openmp40 i believe it was

00:49:56,319 --> 00:50:01,280
we introduced task dependencies uh then

00:49:59,119 --> 00:50:04,240
with openmp45 we

00:50:01,280 --> 00:50:05,440
started introducing uh the task loop

00:50:04,240 --> 00:50:08,000
construct

00:50:05,440 --> 00:50:08,640
and we kept refining it and so one of

00:50:08,000 --> 00:50:10,160
the big

00:50:08,640 --> 00:50:13,280
improvements that we're planning for

00:50:10,160 --> 00:50:15,599
openmp6 is to unify

00:50:13,280 --> 00:50:17,520
all tasking features to support

00:50:15,599 --> 00:50:19,599
dependencies so that you can

00:50:17,520 --> 00:50:20,800
synchronize tasks that are coming from a

00:50:19,599 --> 00:50:24,079
task loop

00:50:20,800 --> 00:50:25,599
irregular tasks and offload tasks using

00:50:24,079 --> 00:50:29,040
that

00:50:25,599 --> 00:50:32,400
single model and then braun has already

00:50:29,040 --> 00:50:35,440
alluded to it about free agent

00:50:32,400 --> 00:50:35,440
threats or

00:50:35,680 --> 00:50:39,920
i think one one working title was

00:50:37,920 --> 00:50:43,280
unshackled threats

00:50:39,920 --> 00:50:46,640
where you could pick you know threats

00:50:43,280 --> 00:50:50,400
out of your available threats

00:50:46,640 --> 00:50:53,119
and use them to execute tasks

00:50:50,400 --> 00:50:53,520
outside the regular work sharing so that

00:50:53,119 --> 00:50:56,720
should

00:50:53,520 --> 00:50:57,599
give us a way to um you know make it

00:50:56,720 --> 00:51:01,119
easier

00:50:57,599 --> 00:51:03,680
um to get parallelism with tasking and

00:51:01,119 --> 00:51:04,400
um you know refine the way taskings a

00:51:03,680 --> 00:51:08,640
task

00:51:04,400 --> 00:51:11,040
execution is happening um in the system

00:51:08,640 --> 00:51:12,000
i'll just note that with deprecation of

00:51:11,040 --> 00:51:15,359
the uh

00:51:12,000 --> 00:51:19,119
master construct in 5.1 the term

00:51:15,359 --> 00:51:23,520
uh unshackled threads is is no longer

00:51:19,119 --> 00:51:26,960
appropriate okay

00:51:23,520 --> 00:51:27,680
uh all right so we have one more

00:51:26,960 --> 00:51:29,920
question

00:51:27,680 --> 00:51:31,520
and i will try and answer that what is

00:51:29,920 --> 00:51:34,079
and will be the major differences

00:51:31,520 --> 00:51:37,680
between openmp and openacc

00:51:34,079 --> 00:51:40,800
well you're you're asking somebody who's

00:51:37,680 --> 00:51:42,640
biased on this question so

00:51:40,800 --> 00:51:44,000
you can take what i say with a grain of

00:51:42,640 --> 00:51:47,040
salt i know what the

00:51:44,000 --> 00:51:50,240
open aacc proponents claim

00:51:47,040 --> 00:51:53,280
um most of which i think is frankly

00:51:50,240 --> 00:51:55,359
hui you can you can

00:51:53,280 --> 00:51:56,640
do what you want with that um the

00:51:55,359 --> 00:52:00,559
reality is

00:51:56,640 --> 00:52:04,880
openmp is a complete specification

00:52:00,559 --> 00:52:08,000
it provides features that are

00:52:04,880 --> 00:52:08,960
appropriate regardless of the type of

00:52:08,000 --> 00:52:12,160
system that

00:52:08,960 --> 00:52:13,760
you're using and it provides

00:52:12,160 --> 00:52:16,960
capabilities to

00:52:13,760 --> 00:52:18,880
let the compiler know that you're

00:52:16,960 --> 00:52:21,440
using that you're restricting what

00:52:18,880 --> 00:52:24,400
you're using in such a way that

00:52:21,440 --> 00:52:26,000
it can make optimizations for a given

00:52:24,400 --> 00:52:29,200
type of device

00:52:26,000 --> 00:52:33,040
whereas openacc really only supports

00:52:29,200 --> 00:52:36,480
gpus and when you try and use it

00:52:33,040 --> 00:52:40,480
on the host it is

00:52:36,480 --> 00:52:43,200
not uh it does not have a sufficient

00:52:40,480 --> 00:52:44,000
feature set in order to allow you to

00:52:43,200 --> 00:52:46,400
parallelize

00:52:44,000 --> 00:52:47,839
a large amount of code that can be

00:52:46,400 --> 00:52:51,760
parallelized

00:52:47,839 --> 00:52:51,760
efficiently with openmp

00:52:52,000 --> 00:52:58,480
so early in openacc's lifetime we had

00:52:56,319 --> 00:53:00,960
the openacc

00:52:58,480 --> 00:53:02,480
proponents telling openmp that we needed

00:53:00,960 --> 00:53:05,319
to provide

00:53:02,480 --> 00:53:07,760
ways to provide support for

00:53:05,319 --> 00:53:09,359
interoperability with openhcc which was

00:53:07,760 --> 00:53:11,359
just ridiculous since

00:53:09,359 --> 00:53:13,520
given at the time they were making their

00:53:11,359 --> 00:53:14,720
statement we already had support for

00:53:13,520 --> 00:53:17,680
devices

00:53:14,720 --> 00:53:19,839
it had nothing in open acc that you

00:53:17,680 --> 00:53:21,920
couldn't do in openmp

00:53:19,839 --> 00:53:23,920
um and so that's that's the difference

00:53:21,920 --> 00:53:29,839
you can do a lot more with openmp than

00:53:23,920 --> 00:53:29,839
you can with opening cc

00:53:33,280 --> 00:53:39,119
um let's see openmp

00:53:36,880 --> 00:53:40,800
affinity and binding is rich and well

00:53:39,119 --> 00:53:43,119
defined but does mpi

00:53:40,800 --> 00:53:44,960
have any now standard binding option to

00:53:43,119 --> 00:53:47,520
make

00:53:44,960 --> 00:53:49,520
we know who is driving the bus this is a

00:53:47,520 --> 00:53:51,760
continuing source of confusion and

00:53:49,520 --> 00:53:55,440
complexity

00:53:51,760 --> 00:53:55,440
um well so

00:53:55,680 --> 00:54:00,160
i i'm sorry if the interoperation

00:53:58,640 --> 00:54:02,960
between the two

00:54:00,160 --> 00:54:03,760
between openmp and open8 and between

00:54:02,960 --> 00:54:07,760
openmp

00:54:03,760 --> 00:54:10,480
and mpi is sometimes confusing uh

00:54:07,760 --> 00:54:11,520
while we have many people who

00:54:10,480 --> 00:54:15,040
participate

00:54:11,520 --> 00:54:18,240
in both the mpi forum and

00:54:15,040 --> 00:54:21,599
the openmp language committee they are

00:54:18,240 --> 00:54:23,040
distinct uh specifications so what we

00:54:21,599 --> 00:54:25,680
try and do is define

00:54:23,040 --> 00:54:27,599
mechanisms that that support

00:54:25,680 --> 00:54:31,520
interoperability between them

00:54:27,599 --> 00:54:31,520
but not but we can't um

00:54:31,599 --> 00:54:38,319
require anything of mpi

00:54:35,280 --> 00:54:40,720
by by openmp we can't tell npi you will

00:54:38,319 --> 00:54:43,520
do this

00:54:40,720 --> 00:54:45,440
we think that with with good resource

00:54:43,520 --> 00:54:47,520
management support you should actually

00:54:45,440 --> 00:54:51,760
get

00:54:47,520 --> 00:54:53,680
good work on binding options

00:54:51,760 --> 00:54:54,799
all right but basically a good resource

00:54:53,680 --> 00:54:58,160
manager will

00:54:54,799 --> 00:55:00,240
limit your mpi process

00:54:58,160 --> 00:55:01,760
in which your openmp threads are running

00:55:00,240 --> 00:55:07,839
to a subset

00:55:01,760 --> 00:55:07,839
of the resources on the node

00:55:08,960 --> 00:55:12,480
um i see johannes has asked a question

00:55:11,200 --> 00:55:14,720
but i wanted to kind of

00:55:12,480 --> 00:55:15,920
quickly take a look at the poll results

00:55:14,720 --> 00:55:19,200
so

00:55:15,920 --> 00:55:20,000
um i i the first question was we asked

00:55:19,200 --> 00:55:23,040
that because

00:55:20,000 --> 00:55:25,440
frankly we think that the

00:55:23,040 --> 00:55:26,960
5-2 will improve the way restrictions

00:55:25,440 --> 00:55:30,799
are specified

00:55:26,960 --> 00:55:32,559
um i'm surprised that a large number

00:55:30,799 --> 00:55:34,160
a smaller number of people find the way

00:55:32,559 --> 00:55:36,160
they're currently specified to be

00:55:34,160 --> 00:55:38,160
confusing

00:55:36,160 --> 00:55:40,559
i asked about combined and composite

00:55:38,160 --> 00:55:42,319
constructs composite constructs

00:55:40,559 --> 00:55:44,319
you probably think are combined

00:55:42,319 --> 00:55:47,119
constructs except that

00:55:44,319 --> 00:55:49,599
you can't actually specify one the one

00:55:47,119 --> 00:55:53,119
construct nested inside of the other

00:55:49,599 --> 00:55:55,440
so or it's really

00:55:53,119 --> 00:55:56,799
it what we found is that all the

00:55:55,440 --> 00:56:02,880
composite constructs

00:55:56,799 --> 00:56:06,880
are loop associated constructs that

00:56:02,880 --> 00:56:09,920
end up associating a single loop nest

00:56:06,880 --> 00:56:10,880
with multiple loop associated constructs

00:56:09,920 --> 00:56:15,119
so

00:56:10,880 --> 00:56:18,799
distribute parallel four for example

00:56:15,119 --> 00:56:22,079
all right and they actually then end up

00:56:18,799 --> 00:56:24,480
uh specifying that you first apply the

00:56:22,079 --> 00:56:28,559
distribute semantics and then the

00:56:24,480 --> 00:56:31,440
uh work sharing loop semantics all right

00:56:28,559 --> 00:56:32,559
um the way they're specified in 5.1 and

00:56:31,440 --> 00:56:35,040
before that

00:56:32,559 --> 00:56:35,599
is just basically we list here here's

00:56:35,040 --> 00:56:37,680
the

00:56:35,599 --> 00:56:40,400
the concatenation of those names and it

00:56:37,680 --> 00:56:43,599
means just what you would think

00:56:40,400 --> 00:56:46,079
all right uh in five 2 we're going to

00:56:43,599 --> 00:56:47,119
specify the rules for concatenating

00:56:46,079 --> 00:56:49,520
names

00:56:47,119 --> 00:56:50,240
in 6-0 i hope that we will make the

00:56:49,520 --> 00:56:52,319
algorithm

00:56:50,240 --> 00:56:54,400
for determining what names you can

00:56:52,319 --> 00:56:56,240
concatenate much simpler because right

00:56:54,400 --> 00:56:57,359
now it's basically just a big switch

00:56:56,240 --> 00:57:01,040
statement

00:56:57,359 --> 00:57:04,079
and 6 0 the x

00:57:01,040 --> 00:57:04,559
the hope is to make it if you can nest

00:57:04,079 --> 00:57:07,359
them

00:57:04,559 --> 00:57:07,359
you can combine

00:57:11,359 --> 00:57:16,400
um all right so now

00:57:14,799 --> 00:57:19,359
michael do you want to handle any of the

00:57:16,400 --> 00:57:21,359
questions that we have out there

00:57:19,359 --> 00:57:24,839
um i guess you had already handled the

00:57:21,359 --> 00:57:28,799
composite versus combined constructs

00:57:24,839 --> 00:57:32,160
um johannes is asking about

00:57:28,799 --> 00:57:34,400
llvm allows to do off-remote offloading

00:57:32,160 --> 00:57:35,839
so use your neighboring gpu but there's

00:57:34,400 --> 00:57:37,920
a lot of features missing in the

00:57:35,839 --> 00:57:40,559
standard for distributed computing

00:57:37,920 --> 00:57:41,040
will we see more of that in the future

00:57:40,559 --> 00:57:43,920
and

00:57:41,040 --> 00:57:44,960
the way i would like to answer that is

00:57:43,920 --> 00:57:47,839
that

00:57:44,960 --> 00:57:48,559
bronies and i um kind of already said

00:57:47,839 --> 00:57:51,760
that

00:57:48,559 --> 00:57:54,079
there will be more of

00:57:51,760 --> 00:57:54,799
this coming in the sense that you that

00:57:54,079 --> 00:57:58,000
we will have

00:57:54,799 --> 00:57:59,200
more features um how you can deal with

00:57:58,000 --> 00:58:02,559
multiple gpus

00:57:59,200 --> 00:58:04,079
in your system so that is kind of basic

00:58:02,559 --> 00:58:08,000
support for that

00:58:04,079 --> 00:58:11,280
but we don't have um a direction

00:58:08,000 --> 00:58:14,559
where we want to be doing

00:58:11,280 --> 00:58:17,119
offloading out of the node and

00:58:14,559 --> 00:58:20,240
pretty much replaced the capabilities of

00:58:17,119 --> 00:58:24,319
mpi with openmp that's

00:58:20,240 --> 00:58:24,319
not nothing that we have on our roadmap

00:58:26,480 --> 00:58:28,640
so

00:58:30,000 --> 00:58:36,319
um i i would throw something in a little

00:58:34,079 --> 00:58:39,440
bit different there

00:58:36,319 --> 00:58:42,960
i see that the number one priority

00:58:39,440 --> 00:58:46,319
for in terms of responses

00:58:42,960 --> 00:58:48,839
is two-thirds of you

00:58:46,319 --> 00:58:50,400
selected enhancements for using multiple

00:58:48,839 --> 00:58:51,920
devices

00:58:50,400 --> 00:58:53,440
and i would suggest that the

00:58:51,920 --> 00:58:55,760
enhancements for multiple

00:58:53,440 --> 00:58:58,079
devices would go in the direction that

00:58:55,760 --> 00:58:59,680
johannes is asking about because it

00:58:58,079 --> 00:59:03,119
would do things like

00:58:59,680 --> 00:59:03,119
providing the ability to

00:59:03,200 --> 00:59:09,200
do broadcast across multiple devices uh

00:59:06,559 --> 00:59:11,040
i expect that we would add support for

00:59:09,200 --> 00:59:13,920
if you wanted to use

00:59:11,040 --> 00:59:15,119
openmp more like mpi the first thing

00:59:13,920 --> 00:59:17,119
that you would need to do

00:59:15,119 --> 00:59:18,799
in order for it to be a scalable

00:59:17,119 --> 00:59:22,079
solution is have

00:59:18,799 --> 00:59:26,880
uh support for what i call ball

00:59:22,079 --> 00:59:26,880
bulk launch all right so being able to

00:59:29,440 --> 00:59:36,480
engage a multiple nodes

00:59:33,920 --> 00:59:37,520
with a single command right with a

00:59:36,480 --> 00:59:40,079
single

00:59:37,520 --> 00:59:40,799
directive all right right now if you

00:59:40,079 --> 00:59:43,040
want to

00:59:40,799 --> 00:59:46,640
offload to multiple devices you have to

00:59:43,040 --> 00:59:48,559
do a loop over the device numbers

00:59:46,640 --> 00:59:51,119
enhancements for using multiple devices

00:59:48,559 --> 00:59:54,480
would provide you a way to

00:59:51,119 --> 00:59:54,880
offload to all of the devices what you

00:59:54,480 --> 00:59:58,079
do

00:59:54,880 --> 01:00:00,960
in there will depend on what we add you

00:59:58,079 --> 01:00:02,480
you could just have launch this target

01:00:00,960 --> 01:00:05,599
region

01:00:02,480 --> 01:00:07,040
on this set of devices and then based on

01:00:05,599 --> 01:00:09,839
the device number you might

01:00:07,040 --> 01:00:10,640
choose to do something that's kind of

01:00:09,839 --> 01:00:13,520
like the most

01:00:10,640 --> 01:00:15,440
basic support for npmd kind of

01:00:13,520 --> 01:00:19,520
programming

01:00:15,440 --> 01:00:19,520
but we'll probably also have ability to

01:00:19,920 --> 01:00:25,119
partition loops across multiple devices

01:00:22,559 --> 01:00:25,119
for example

01:00:27,280 --> 01:00:30,480
all right well we're at the bottom of

01:00:29,119 --> 01:00:33,200
the hour um

01:00:30,480 --> 01:00:34,960
i think we've answered all the questions

01:00:33,200 --> 01:00:38,079
we can be available a little longer

01:00:34,960 --> 01:00:38,079
people would like or

01:00:39,280 --> 01:00:42,400
you know type in another question if you

01:00:41,280 --> 01:00:43,599
want if there's something else you'd

01:00:42,400 --> 01:00:47,040
like us to

01:00:43,599 --> 01:00:48,880
discuss all right

01:00:47,040 --> 01:00:50,799
well thank you michael brones for that

01:00:48,880 --> 01:00:52,160
excellent update on openmp

01:00:50,799 --> 01:00:53,920
and it sounds like there's exciting

01:00:52,160 --> 01:00:55,920
things ahead

01:00:53,920 --> 01:00:57,280
thank you all for your time today we

01:00:55,920 --> 01:00:59,200
hope you enjoyed the webinar

01:00:57,280 --> 01:01:01,119
a recording of this presentation along

01:00:59,200 --> 01:01:03,839
with the slides will be available

01:01:01,119 --> 01:01:06,319
on the openmp website a direct link will

01:01:03,839 --> 01:01:08,079
be sent to you in a follow-up email

01:01:06,319 --> 01:01:09,440
also as you leave the webinar please

01:01:08,079 --> 01:01:10,000
take a moment to fill out the survey

01:01:09,440 --> 01:01:13,200
that pops

01:01:10,000 --> 01:01:13,440
up your feedback is important to to help

01:01:13,200 --> 01:01:15,599
us

01:01:13,440 --> 01:01:17,200
improve these presentations so please

01:01:15,599 --> 01:01:19,760
let us know if there are other openmp

01:01:17,200 --> 01:01:21,760
related topics you may be interested in

01:01:19,760 --> 01:01:23,359
feel free to keep adding questions if

01:01:21,760 --> 01:01:25,839
you'd like otherwise we hope you have a

01:01:23,359 --> 01:01:25,839
great day

01:01:26,640 --> 01:01:38,240

YouTube URL: https://www.youtube.com/watch?v=OfN57DNtcfE


