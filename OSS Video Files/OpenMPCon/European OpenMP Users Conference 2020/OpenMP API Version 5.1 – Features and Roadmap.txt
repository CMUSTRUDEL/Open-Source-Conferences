Title: OpenMP API Version 5.1 â€“ Features and Roadmap
Publication date: 2020-12-21
Playlist: European OpenMP Users Conference 2020
Description: 
	This talk was presented at the 3rd European OpenMP Users Conference in 2020

Presented by : Michael Klemm, CEO OpenMP ARB

Conference Website: https://openmpusers.org
Follow us: https://twitter.com/openmp_users
Captions: 
	00:00:05,759 --> 00:00:10,480
okay we come to the

00:00:06,960 --> 00:00:12,320
final talk of uh this afternoon um so

00:00:10,480 --> 00:00:14,000
it's great to be able to introduce uh

00:00:12,320 --> 00:00:16,960
michael clem uh

00:00:14,000 --> 00:00:18,480
michael is the ceo of the openmp

00:00:16,960 --> 00:00:21,439
architecture review board

00:00:18,480 --> 00:00:22,240
and so he's in charge of openmp and

00:00:21,439 --> 00:00:24,240
ensuring that

00:00:22,240 --> 00:00:25,279
um it goes along and everyone's

00:00:24,240 --> 00:00:28,000
collaborating together

00:00:25,279 --> 00:00:29,039
on this open standard um so over to you

00:00:28,000 --> 00:00:32,160
michael to

00:00:29,039 --> 00:00:35,040
tell us all about openmp 5.1

00:00:32,160 --> 00:00:37,040
all right um thank you um so one of one

00:00:35,040 --> 00:00:37,920
disclaimer i need to add is that i won't

00:00:37,040 --> 00:00:40,239
be able to tell

00:00:37,920 --> 00:00:42,160
everything about openmp51 because it

00:00:40,239 --> 00:00:44,559
became a much bigger release than we

00:00:42,160 --> 00:00:45,360
initially anticipated but anyways i'll

00:00:44,559 --> 00:00:48,960
try to give

00:00:45,360 --> 00:00:49,920
a small glimpse at what openmp51 is and

00:00:48,960 --> 00:00:52,719
what to expect

00:00:49,920 --> 00:00:54,000
in the future of openmp all right just a

00:00:52,719 --> 00:00:58,320
few words about the

00:00:54,000 --> 00:01:01,359
architectural review board so as you all

00:00:58,320 --> 00:01:04,479
should know the openmp arb is the body

00:01:01,359 --> 00:01:07,280
that owns openmp as a trademark and also

00:01:04,479 --> 00:01:08,560
owns the openmp specification and the

00:01:07,280 --> 00:01:10,799
mission really is

00:01:08,560 --> 00:01:12,000
to standardize this directive based

00:01:10,799 --> 00:01:15,040
multi-language programming

00:01:12,000 --> 00:01:16,640
model we strive to have high-level

00:01:15,040 --> 00:01:18,000
parallelism you've seen a couple of

00:01:16,640 --> 00:01:21,360
examples

00:01:18,000 --> 00:01:24,320
earlier today about this

00:01:21,360 --> 00:01:26,320
going from very high level parallel 4

00:01:24,320 --> 00:01:29,759
type of programming down to very machine

00:01:26,320 --> 00:01:32,479
oriented programming and we aim to be

00:01:29,759 --> 00:01:33,200
performance oriented and productive as

00:01:32,479 --> 00:01:36,799
well as

00:01:33,200 --> 00:01:39,680
portable and portable in the sense of

00:01:36,799 --> 00:01:40,880
functionality not performance portable

00:01:39,680 --> 00:01:44,159
of course

00:01:40,880 --> 00:01:45,759
um one thing i wanted to note is that

00:01:44,159 --> 00:01:49,360
the openmp api

00:01:45,759 --> 00:01:53,360
is usually not doing bleeding edge

00:01:49,360 --> 00:01:55,840
research standardization but rather

00:01:53,360 --> 00:01:57,280
we consider common approaches to

00:01:55,840 --> 00:01:58,000
state-of-the-art or the state of

00:01:57,280 --> 00:02:01,119
practice as

00:01:58,000 --> 00:02:03,600
uh jonas was calling it earlier today

00:02:01,119 --> 00:02:05,280
so we standardized the common practice

00:02:03,600 --> 00:02:07,840
in the industry

00:02:05,280 --> 00:02:09,280
as an industry standard and on the right

00:02:07,840 --> 00:02:11,039
hand side of this slide you see a couple

00:02:09,280 --> 00:02:13,680
of the logos

00:02:11,039 --> 00:02:14,160
of our members so it kind of reads as to

00:02:13,680 --> 00:02:18,239
who's

00:02:14,160 --> 00:02:21,360
like the who is who of the hpc community

00:02:18,239 --> 00:02:23,840
all right in terms of roadmap so as

00:02:21,360 --> 00:02:26,879
already has been mentioned today um we

00:02:23,840 --> 00:02:29,200
just released openmp51

00:02:26,879 --> 00:02:30,000
uh earlier around supercomputing time

00:02:29,200 --> 00:02:32,319
frame about

00:02:30,000 --> 00:02:33,120
three weeks ago i think it was um so

00:02:32,319 --> 00:02:35,840
this is our

00:02:33,120 --> 00:02:37,920
it's a minor release um but as i said it

00:02:35,840 --> 00:02:38,879
became a little bigger than we initially

00:02:37,920 --> 00:02:41,599
thought

00:02:38,879 --> 00:02:43,840
uh in november 21 we are aiming for an

00:02:41,599 --> 00:02:46,400
openmp 5.2 release

00:02:43,840 --> 00:02:46,879
um the reason for this release is going

00:02:46,400 --> 00:02:49,200
to be

00:02:46,879 --> 00:02:50,959
more structural changes than actual

00:02:49,200 --> 00:02:54,800
feature changes

00:02:50,959 --> 00:02:57,280
we may add a few minor things

00:02:54,800 --> 00:03:00,080
or iron out a couple of bucks that may

00:02:57,280 --> 00:03:03,040
have that we may have left in five one

00:03:00,080 --> 00:03:05,040
but still the idea is to just

00:03:03,040 --> 00:03:06,720
restructure the specifications so that

00:03:05,040 --> 00:03:08,640
it becomes a bit more

00:03:06,720 --> 00:03:10,159
manageable and readable and then in

00:03:08,640 --> 00:03:13,400
november 23 that's

00:03:10,159 --> 00:03:15,280
our usual five-year cadence we will have

00:03:13,400 --> 00:03:17,840
openmp6

00:03:15,280 --> 00:03:18,879
and in the meantime we will show signs

00:03:17,840 --> 00:03:21,440
of life

00:03:18,879 --> 00:03:22,720
through what we call technical reports

00:03:21,440 --> 00:03:25,200
so every year

00:03:22,720 --> 00:03:27,120
also at around november time frame we

00:03:25,200 --> 00:03:27,920
release a technical report which is kind

00:03:27,120 --> 00:03:31,280
of the current

00:03:27,920 --> 00:03:33,360
preview release of what will be coming

00:03:31,280 --> 00:03:35,120
what we are talking about in the openmp

00:03:33,360 --> 00:03:37,200
language committee

00:03:35,120 --> 00:03:39,040
so that the community can interact with

00:03:37,200 --> 00:03:40,560
us and tell us what they like and what

00:03:39,040 --> 00:03:45,040
they dislike

00:03:40,560 --> 00:03:48,720
in in this in these technical reports

00:03:45,040 --> 00:03:49,920
uh as i said um openmp51 has has been

00:03:48,720 --> 00:03:52,319
released so

00:03:49,920 --> 00:03:54,640
you can download a pdf uh from

00:03:52,319 --> 00:03:58,080
openmp.org that's our website

00:03:54,640 --> 00:03:59,280
uh you can also browse an html version

00:03:58,080 --> 00:04:01,599
there

00:03:59,280 --> 00:04:03,840
which is quite nice if you want to link

00:04:01,599 --> 00:04:06,239
to a particular openmp feature or if you

00:04:03,840 --> 00:04:09,519
don't want to browse through an openmp

00:04:06,239 --> 00:04:13,040
pdf and the other thing that we did is

00:04:09,519 --> 00:04:15,599
starting with 500 i believe

00:04:13,040 --> 00:04:17,759
we also started to publish the openmp

00:04:15,599 --> 00:04:21,040
specification as a printed book

00:04:17,759 --> 00:04:23,440
um for those old-fashioned guys like i'm

00:04:21,040 --> 00:04:25,040
one i i like to read and paper

00:04:23,440 --> 00:04:26,840
um so you don't have to print it

00:04:25,040 --> 00:04:28,160
yourself you can just order it off

00:04:26,840 --> 00:04:30,800
amazon

00:04:28,160 --> 00:04:31,520
it's basically a wholesale price so i

00:04:30,800 --> 00:04:34,639
believe

00:04:31,520 --> 00:04:35,440
the u.s price for this book is like 16

00:04:34,639 --> 00:04:39,360
bucks

00:04:35,440 --> 00:04:41,600
i think it's 17 in europe um

00:04:39,360 --> 00:04:43,280
it's the same the same basically the

00:04:41,600 --> 00:04:46,840
same pdf just

00:04:43,280 --> 00:04:49,840
printed all right so

00:04:46,840 --> 00:04:52,479
openmp51 just a kind of historic recap

00:04:49,840 --> 00:04:56,639
what happened in 2018

00:04:52,479 --> 00:04:58,800
so openmp was potentially uh the biggest

00:04:56,639 --> 00:05:00,560
release that openmp has ever made

00:04:58,800 --> 00:05:01,840
uh apart from of of course the

00:05:00,560 --> 00:05:04,479
inaugurational

00:05:01,840 --> 00:05:05,600
release in 97 and so there's a whole

00:05:04,479 --> 00:05:08,479
bunch of features

00:05:05,600 --> 00:05:09,120
uh some of which have been discussed um

00:05:08,479 --> 00:05:11,840
already

00:05:09,120 --> 00:05:13,520
and and presented today um but it was a

00:05:11,840 --> 00:05:16,080
pretty big release and so

00:05:13,520 --> 00:05:18,160
our tools vendors and compiler vendors

00:05:16,080 --> 00:05:20,199
uh they really need a little bit of time

00:05:18,160 --> 00:05:23,120
to breathe and so we tried to keep

00:05:20,199 --> 00:05:26,240
openmp51 a little smaller

00:05:23,120 --> 00:05:28,720
than we usually do regardless

00:05:26,240 --> 00:05:30,720
we thought that we would add a couple of

00:05:28,720 --> 00:05:34,160
nice things

00:05:30,720 --> 00:05:37,280
to openmp51 to make it more programmable

00:05:34,160 --> 00:05:39,120
and more useful to programmers and so

00:05:37,280 --> 00:05:40,160
there's a bunch of things and i'll pick

00:05:39,120 --> 00:05:44,240
some of them

00:05:40,160 --> 00:05:47,120
today um so for instance there is

00:05:44,240 --> 00:05:49,520
uh c plus plus 20 support even though c

00:05:47,120 --> 00:05:52,160
plus plus 20 hasn't been released yet

00:05:49,520 --> 00:05:54,240
we already anticipate that release which

00:05:52,160 --> 00:05:56,800
is hopefully happening right now

00:05:54,240 --> 00:05:59,280
um and so we kind of prefetched that

00:05:56,800 --> 00:06:02,560
into openmp51 so that

00:05:59,280 --> 00:06:06,000
a good share of open of openmp supports

00:06:02,560 --> 00:06:08,560
c 20 features all right

00:06:06,000 --> 00:06:09,520
um let me give you a couple of of new

00:06:08,560 --> 00:06:11,600
features

00:06:09,520 --> 00:06:12,960
um certainly i won't be able to cover

00:06:11,600 --> 00:06:15,280
everything that we did

00:06:12,960 --> 00:06:16,000
um and so this is kind of an arbitrary

00:06:15,280 --> 00:06:18,960
subset

00:06:16,000 --> 00:06:21,840
of uh things where i thought i'll just

00:06:18,960 --> 00:06:24,319
show what we did

00:06:21,840 --> 00:06:25,199
all right so jeff larkin already

00:06:24,319 --> 00:06:28,400
mentioned that

00:06:25,199 --> 00:06:31,520
in his presentation uh the interaction

00:06:28,400 --> 00:06:34,000
with low-level libraries like cuda like

00:06:31,520 --> 00:06:37,360
opencl or level zero in intel's

00:06:34,000 --> 00:06:41,440
case has been improved

00:06:37,360 --> 00:06:43,840
uh with openmp five we actually did um

00:06:41,440 --> 00:06:44,880
we we introduced interoperability in

00:06:43,840 --> 00:06:48,080
terms of

00:06:44,880 --> 00:06:50,800
what jeff was showing that you could get

00:06:48,080 --> 00:06:53,680
the buffer that is associated with some

00:06:50,800 --> 00:06:57,039
data management directive in openmp

00:06:53,680 --> 00:06:58,319
uh get the low-level buffer object like

00:06:57,039 --> 00:07:00,560
a cuda buffer object

00:06:58,319 --> 00:07:02,000
out of the openmp implementation and

00:07:00,560 --> 00:07:05,360
feed that into something like

00:07:02,000 --> 00:07:08,319
kuplas and with the interrupt

00:07:05,360 --> 00:07:09,360
feature what we did is you can now query

00:07:08,319 --> 00:07:11,280
additional

00:07:09,360 --> 00:07:12,960
information from the low-level

00:07:11,280 --> 00:07:14,800
implementation and so one particular

00:07:12,960 --> 00:07:18,720
example where this is useful

00:07:14,800 --> 00:07:21,759
is now you can actually ask the openmp

00:07:18,720 --> 00:07:22,800
implementation to get out or give out

00:07:21,759 --> 00:07:25,520
the

00:07:22,800 --> 00:07:27,360
stream that is used to do the target

00:07:25,520 --> 00:07:29,919
offloading

00:07:27,360 --> 00:07:30,400
of the of the offload regions that you

00:07:29,919 --> 00:07:33,039
that you

00:07:30,400 --> 00:07:35,280
um that you have in your code and then

00:07:33,039 --> 00:07:37,360
you can use that stream object

00:07:35,280 --> 00:07:38,720
as part of the of something like a

00:07:37,360 --> 00:07:42,080
kublas call

00:07:38,720 --> 00:07:43,199
um to use that as the stream where the

00:07:42,080 --> 00:07:46,639
library should also

00:07:43,199 --> 00:07:47,199
send your request to and you can use

00:07:46,639 --> 00:07:49,840
that to

00:07:47,199 --> 00:07:51,680
implement additional more more low-level

00:07:49,840 --> 00:07:54,080
synchronization mechanisms

00:07:51,680 --> 00:07:55,440
or use astronomy as offloading in those

00:07:54,080 --> 00:07:57,360
libraries

00:07:55,440 --> 00:07:59,440
um or whatever you you're after or get

00:07:57,360 --> 00:08:02,240
the get the events out of the streams

00:07:59,440 --> 00:08:04,160
whatever so this is one thing certainly

00:08:02,240 --> 00:08:07,680
you will be less portable when you do

00:08:04,160 --> 00:08:11,120
use these kind of

00:08:07,680 --> 00:08:13,680
things but you know

00:08:11,120 --> 00:08:16,000
at least you can now from openmp

00:08:13,680 --> 00:08:19,199
interact with these low-level libraries

00:08:16,000 --> 00:08:19,680
um if you wish so one minor thing that

00:08:19,199 --> 00:08:23,440
we did

00:08:19,680 --> 00:08:26,879
is um openmp51 deprecated

00:08:23,440 --> 00:08:28,800
uh the master construct and we replaced

00:08:26,879 --> 00:08:29,840
it with a more versatile and flexible

00:08:28,800 --> 00:08:33,039
construct

00:08:29,840 --> 00:08:35,839
so instead of master which basically

00:08:33,039 --> 00:08:37,200
just was a syntactic sugar for you know

00:08:35,839 --> 00:08:40,399
run this code on

00:08:37,200 --> 00:08:42,880
thread id 0 so the the main thread

00:08:40,399 --> 00:08:43,680
of your parallel region you can now

00:08:42,880 --> 00:08:46,080
either

00:08:43,680 --> 00:08:47,360
get the same behavior by just using

00:08:46,080 --> 00:08:51,279
onpass

00:08:47,360 --> 00:08:54,160
or you can use the filter clause to give

00:08:51,279 --> 00:08:56,080
the mass construct a a thread id and

00:08:54,160 --> 00:08:58,320
then the code that is associated with

00:08:56,080 --> 00:09:00,560
that construct here

00:08:58,320 --> 00:09:02,080
will run on that particular thread id

00:09:00,560 --> 00:09:04,560
and in the future

00:09:02,080 --> 00:09:05,279
likely in open mp6 we will extend the

00:09:04,560 --> 00:09:07,920
feature

00:09:05,279 --> 00:09:08,720
the filter clause to allow more

00:09:07,920 --> 00:09:11,760
subsetting

00:09:08,720 --> 00:09:14,560
of of threat

00:09:11,760 --> 00:09:16,080
teams like every odd thread or every

00:09:14,560 --> 00:09:19,200
even number thread

00:09:16,080 --> 00:09:21,200
or every thread that has a prime number

00:09:19,200 --> 00:09:23,040
as a thread id

00:09:21,200 --> 00:09:24,560
or you can particularly construct a

00:09:23,040 --> 00:09:27,040
threat subset

00:09:24,560 --> 00:09:29,200
that you would like to have that code

00:09:27,040 --> 00:09:31,839
executed on so this is something

00:09:29,200 --> 00:09:33,760
that has been long long been asked for

00:09:31,839 --> 00:09:36,240
and we finally found the time

00:09:33,760 --> 00:09:38,000
um to do this and implement such a more

00:09:36,240 --> 00:09:40,320
versatile construct and replacement for

00:09:38,000 --> 00:09:43,360
master

00:09:40,320 --> 00:09:45,200
the code straw construct is um a

00:09:43,360 --> 00:09:47,760
construct that you can use

00:09:45,200 --> 00:09:48,959
inside a parallel region to create

00:09:47,760 --> 00:09:51,600
additional

00:09:48,959 --> 00:09:53,680
sub scopes inside that parallel region

00:09:51,600 --> 00:09:54,560
so what i'm doing here on that slide is

00:09:53,680 --> 00:09:57,519
i'm using the

00:09:54,560 --> 00:09:59,360
scope construct to implement a reduction

00:09:57,519 --> 00:10:02,480
across

00:09:59,360 --> 00:10:03,760
the parallel team which pretty much was

00:10:02,480 --> 00:10:06,800
impossible

00:10:03,760 --> 00:10:10,640
in openmp until 5-0

00:10:06,800 --> 00:10:12,320
um and you had you know you use

00:10:10,640 --> 00:10:13,760
pragmatic patterns like this where you

00:10:12,320 --> 00:10:16,320
had to inject like

00:10:13,760 --> 00:10:17,360
a dummy for loop so that you get you you

00:10:16,320 --> 00:10:19,360
could have in

00:10:17,360 --> 00:10:20,720
reduction clause inside a parallel

00:10:19,360 --> 00:10:22,000
region um

00:10:20,720 --> 00:10:24,480
and then you know you would iterate

00:10:22,000 --> 00:10:26,959
across the the thread ids of your team

00:10:24,480 --> 00:10:28,000
basically doing nothing and so the scope

00:10:26,959 --> 00:10:30,160
construct

00:10:28,000 --> 00:10:32,000
is kind of a replacement and syntactic

00:10:30,160 --> 00:10:32,720
sugar for that pragmatic pattern and in

00:10:32,000 --> 00:10:34,800
future

00:10:32,720 --> 00:10:37,279
this will also be extended to have more

00:10:34,800 --> 00:10:40,399
useful applications

00:10:37,279 --> 00:10:40,959
inside openmp the other thing that we

00:10:40,399 --> 00:10:44,240
did

00:10:40,959 --> 00:10:45,760
with openmp51 is we introduced the

00:10:44,240 --> 00:10:48,320
assumes directive

00:10:45,760 --> 00:10:50,320
so in openmp50 we already introduced a

00:10:48,320 --> 00:10:53,279
requires directive that

00:10:50,320 --> 00:10:55,279
jeff mentioned briefly where you can do

00:10:53,279 --> 00:10:56,560
things like requiring shared memory

00:10:55,279 --> 00:10:59,760
support between

00:10:56,560 --> 00:11:01,519
host and accelerated devices and the

00:10:59,760 --> 00:11:04,640
assumes class now

00:11:01,519 --> 00:11:06,480
uh gives a way to the programmer to tell

00:11:04,640 --> 00:11:09,360
the implementation that it may

00:11:06,480 --> 00:11:10,399
assume a certain program behavior even

00:11:09,360 --> 00:11:12,079
though

00:11:10,399 --> 00:11:13,760
the openmp features hasn't been

00:11:12,079 --> 00:11:17,680
subsetted like it was

00:11:13,760 --> 00:11:19,360
it is done with the requires clause so

00:11:17,680 --> 00:11:21,120
one thing that you can particularly do

00:11:19,360 --> 00:11:23,200
is you can you know

00:11:21,120 --> 00:11:24,240
restrict the code or tell the compiler

00:11:23,200 --> 00:11:28,320
that the code will not

00:11:24,240 --> 00:11:32,000
encounter certain openmp constructs

00:11:28,320 --> 00:11:35,440
or that it will contain certain

00:11:32,000 --> 00:11:37,040
constructs you can give conditions like

00:11:35,440 --> 00:11:38,079
invariants where you can say you know

00:11:37,040 --> 00:11:40,800
assume

00:11:38,079 --> 00:11:42,000
that this condition holds like you know

00:11:40,800 --> 00:11:45,600
this number is always

00:11:42,000 --> 00:11:46,480
even or that no openmp code will be

00:11:45,600 --> 00:11:49,680
executed

00:11:46,480 --> 00:11:50,560
or that nobody calls an openmp api

00:11:49,680 --> 00:11:53,760
routine

00:11:50,560 --> 00:11:55,519
or that no parallelism is created so no

00:11:53,760 --> 00:11:57,600
openmp tasks

00:11:55,519 --> 00:11:58,560
and no simply execution is part of that

00:11:57,600 --> 00:12:02,240
code path

00:11:58,560 --> 00:12:05,920
where this assumes directive is is

00:12:02,240 --> 00:12:09,279
is valid for here's an example

00:12:05,920 --> 00:12:11,040
so you know if you have a function

00:12:09,279 --> 00:12:12,480
where you have a parallel region where

00:12:11,040 --> 00:12:14,959
there's guaranteed no

00:12:12,480 --> 00:12:16,560
tasking you can tell the implementation

00:12:14,959 --> 00:12:18,880
that it may assume

00:12:16,560 --> 00:12:20,639
that their the task and task rate

00:12:18,880 --> 00:12:23,200
constructs are absent from

00:12:20,639 --> 00:12:24,880
the code and then inside that parallel

00:12:23,200 --> 00:12:27,040
region the compiler can make

00:12:24,880 --> 00:12:28,720
can take these assumptions and for

00:12:27,040 --> 00:12:30,240
instance optimize the barrier and

00:12:28,720 --> 00:12:31,519
replace it with an implementation that

00:12:30,240 --> 00:12:34,399
does not support

00:12:31,519 --> 00:12:36,560
task completion versus the traditional

00:12:34,399 --> 00:12:38,560
regular barrier that has to support that

00:12:36,560 --> 00:12:39,920
and so you can get a little bit better

00:12:38,560 --> 00:12:41,200
and and more efficient barrier

00:12:39,920 --> 00:12:44,079
implementation

00:12:41,200 --> 00:12:44,880
uh than without this assumes and so now

00:12:44,079 --> 00:12:48,000
the compiler

00:12:44,880 --> 00:12:49,120
could be um able to take that into

00:12:48,000 --> 00:12:52,399
account and you know

00:12:49,120 --> 00:12:55,760
optimize the code accordingly

00:12:52,399 --> 00:12:59,360
the other thing long discussed

00:12:55,760 --> 00:13:01,519
and finally been done

00:12:59,360 --> 00:13:03,680
we have we now support c plus plus

00:13:01,519 --> 00:13:05,920
attribute syntax in openmp

00:13:03,680 --> 00:13:08,959
uh it's actually a bigger feature than

00:13:05,920 --> 00:13:11,760
than than you would expect for openmp51

00:13:08,959 --> 00:13:12,880
but it wasn't ready in time for 5.0 so

00:13:11,760 --> 00:13:16,000
when you look at

00:13:12,880 --> 00:13:18,240
uh the c plus plus 11 proposal force

00:13:16,000 --> 00:13:20,320
for attributes they actually had an

00:13:18,240 --> 00:13:23,360
openmp example in there

00:13:20,320 --> 00:13:24,880
um and so you know we we are kind of

00:13:23,360 --> 00:13:27,200
good citizens by following their

00:13:24,880 --> 00:13:30,320
suggestion and implementing it

00:13:27,200 --> 00:13:33,839
um so instead of using you know uh

00:13:30,320 --> 00:13:34,800
old style pragma openmp4 center or open

00:13:33,839 --> 00:13:37,680
and p syntax

00:13:34,800 --> 00:13:38,000
you can now use these attributes um to

00:13:37,680 --> 00:13:41,040
get

00:13:38,000 --> 00:13:43,839
a more c plus plus look of your code

00:13:41,040 --> 00:13:46,160
plus c plus plus attributes are subject

00:13:43,839 --> 00:13:47,279
to template programming so you can now

00:13:46,160 --> 00:13:50,399
use those

00:13:47,279 --> 00:13:51,519
within c plus templates which is not

00:13:50,399 --> 00:13:54,639
possible

00:13:51,519 --> 00:13:56,639
with traditional pragmas and directives

00:13:54,639 --> 00:13:58,560
and you know there's a particular

00:13:56,639 --> 00:13:59,360
twitter reaction i wanted to share with

00:13:58,560 --> 00:14:01,920
you

00:13:59,360 --> 00:14:03,120
uh so someone on on twitter really

00:14:01,920 --> 00:14:06,160
freaked out

00:14:03,120 --> 00:14:07,680
uh because you know finally um we made

00:14:06,160 --> 00:14:09,360
this available and he's really happy

00:14:07,680 --> 00:14:11,440
about this and he's writing like oh my

00:14:09,360 --> 00:14:13,519
god oh my god instead of pragma

00:14:11,440 --> 00:14:14,839
c plus plus attribute syntax can now be

00:14:13,519 --> 00:14:17,680
used

00:14:14,839 --> 00:14:19,600
so uh that is that is something that

00:14:17,680 --> 00:14:21,360
that makes openmp a little more

00:14:19,600 --> 00:14:25,120
accessible for for c plus

00:14:21,360 --> 00:14:28,560
programmers all right in summary so

00:14:25,120 --> 00:14:30,800
five one um and also five zero

00:14:28,560 --> 00:14:31,839
uh a big and major leap forward for

00:14:30,800 --> 00:14:33,920
openmp

00:14:31,839 --> 00:14:35,920
uh probably these two releases are the

00:14:33,920 --> 00:14:37,839
biggest uh series of releases ever in

00:14:35,920 --> 00:14:40,880
the history of openmp

00:14:37,839 --> 00:14:42,959
um and so you know they really

00:14:40,880 --> 00:14:45,760
introduced new ways to express

00:14:42,959 --> 00:14:48,959
parallelism and we also improve the

00:14:45,760 --> 00:14:51,120
usage of existing features naturally

00:14:48,959 --> 00:14:53,040
and hopefully you'll take away from what

00:14:51,120 --> 00:14:56,240
i just said is that openmp

00:14:53,040 --> 00:14:58,560
despite that it can still use directive

00:14:56,240 --> 00:15:01,519
and practice syntax is a modern

00:14:58,560 --> 00:15:02,320
programming model with a lot of

00:15:01,519 --> 00:15:05,519
different

00:15:02,320 --> 00:15:08,399
ways to approach parallelism so you can

00:15:05,519 --> 00:15:11,839
use co-processors accelerators gpus

00:15:08,399 --> 00:15:13,920
fpgas we do have regular multi-threading

00:15:11,839 --> 00:15:16,560
support as well as cindy

00:15:13,920 --> 00:15:17,920
uh task-based programming model uh it

00:15:16,560 --> 00:15:20,560
already has been set

00:15:17,920 --> 00:15:22,240
earlier today is kind of the modern

00:15:20,560 --> 00:15:25,279
approach to parallelism

00:15:22,240 --> 00:15:27,279
uh to fight andold's law on a in a way

00:15:25,279 --> 00:15:29,920
different way

00:15:27,279 --> 00:15:31,759
we have powerful language features to to

00:15:29,920 --> 00:15:33,600
support complex algorithms especially

00:15:31,759 --> 00:15:37,120
test dependencies

00:15:33,600 --> 00:15:39,759
allow you to to do a lot of things

00:15:37,120 --> 00:15:41,759
around you know modeling complex

00:15:39,759 --> 00:15:42,959
algorithms in in terms of task parallel

00:15:41,759 --> 00:15:45,199
execution

00:15:42,959 --> 00:15:46,000
and then you know the other thing you

00:15:45,199 --> 00:15:48,240
can start

00:15:46,000 --> 00:15:50,000
easy with parallel four and then you

00:15:48,240 --> 00:15:51,759
have a path forward

00:15:50,000 --> 00:15:53,839
to highly efficient programming where

00:15:51,759 --> 00:15:57,120
you can control

00:15:53,839 --> 00:15:57,519
almost every bit of execution and how

00:15:57,120 --> 00:15:59,839
the

00:15:57,519 --> 00:16:00,560
implementation transforms your code and

00:15:59,839 --> 00:16:03,120
with that

00:16:00,560 --> 00:16:04,240
i'm done if you want to know more please

00:16:03,120 --> 00:16:07,040
visit our website

00:16:04,240 --> 00:16:08,320
openmp.org there's a ton of information

00:16:07,040 --> 00:16:11,360
links to tutorials

00:16:08,320 --> 00:16:13,839
links to collateral links to tutorials

00:16:11,360 --> 00:16:14,800
links to the specification naturally uh

00:16:13,839 --> 00:16:16,720
and as well

00:16:14,800 --> 00:16:18,079
also use cases so it's it's a good

00:16:16,720 --> 00:16:20,000
resource if you're really interested in

00:16:18,079 --> 00:16:23,279
what's going on with openmp these days

00:16:20,000 --> 00:16:25,279
thank you thanks a lot michael that was

00:16:23,279 --> 00:16:26,959
uh a bit of a whistle-stop tour of of

00:16:25,279 --> 00:16:29,360
openmp 5.1

00:16:26,959 --> 00:16:30,800
um it's really great to see that um i

00:16:29,360 --> 00:16:32,000
think we'll move straight into the panel

00:16:30,800 --> 00:16:34,639
session now and

00:16:32,000 --> 00:16:35,839
um anyone who has any questions for for

00:16:34,639 --> 00:16:36,639
michael michael's going to be part of

00:16:35,839 --> 00:16:40,800
the panel so you

00:16:36,639 --> 00:16:45,040
can direct the questions

00:16:40,800 --> 00:16:45,040

YouTube URL: https://www.youtube.com/watch?v=mYvtocfdcAE


