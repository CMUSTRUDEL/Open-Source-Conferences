Title: OpenMP Panel Discussion and Q&A Session
Publication date: 2020-12-21
Playlist: European OpenMP Users Conference 2020
Description: 
	This talk was presented at the 3rd European OpenMP Users Conference in 2020

Presented by : Jim Cownie

Conference Website: https://openmpusers.org
Follow us: https://twitter.com/openmp_users

Presentation Abstract :
Members from our panel of experts will share their views on the key challenges facing HPC developers using OpenMP and will then answer questions from those attending and the chair.
Captions: 
	00:00:03,840 --> 00:00:06,960
so yeah as i said we're now

00:00:05,200 --> 00:00:08,639
into the into the panel discussion and

00:00:06,960 --> 00:00:11,519
this is going to be uh chaired

00:00:08,639 --> 00:00:12,960
by uh jim county um so we'll introduce

00:00:11,519 --> 00:00:13,280
him but before we do that we're just

00:00:12,960 --> 00:00:15,920
gonna

00:00:13,280 --> 00:00:16,400
um load up our first poll hopefully this

00:00:15,920 --> 00:00:18,560
will

00:00:16,400 --> 00:00:20,160
uh give some of the panelists some some

00:00:18,560 --> 00:00:24,240
things to talk about

00:00:20,160 --> 00:00:25,599
um so um there we are tim's put that up

00:00:24,240 --> 00:00:27,840
for you if you could all answer that

00:00:25,599 --> 00:00:29,679
poll with some some questions that'd be

00:00:27,840 --> 00:00:31,039
brilliant to see what happens and and

00:00:29,679 --> 00:00:33,679
i'll hand over to jim now

00:00:31,039 --> 00:00:33,679
welcome jim

00:00:34,399 --> 00:00:41,680
hi um hope everyone can see me

00:00:37,760 --> 00:00:44,559
um the no one's sent

00:00:41,680 --> 00:00:45,760
any questions yet um and i hope all our

00:00:44,559 --> 00:00:49,120
attendees uh

00:00:45,760 --> 00:00:51,680
speakers are already are still here

00:00:49,120 --> 00:00:53,120
uh because otherwise uh we're gonna be

00:00:51,680 --> 00:00:56,160
done very quickly

00:00:53,120 --> 00:00:58,320
um i uh

00:00:56,160 --> 00:00:59,199
i have some history in openmp i'll just

00:00:58,320 --> 00:01:02,160
say who i am

00:00:59,199 --> 00:01:04,080
um i have some history in openmp i was

00:01:02,160 --> 00:01:07,200
the um

00:01:04,080 --> 00:01:08,960
was at intel for for 10 years or maybe

00:01:07,200 --> 00:01:10,240
longer than 10 years and i worked on the

00:01:08,960 --> 00:01:13,520
openmp runtime

00:01:10,240 --> 00:01:15,600
there which became the lrvm runtime so i

00:01:13,520 --> 00:01:18,880
was actually responsible the code owner

00:01:15,600 --> 00:01:21,439
for the runtime in llvm

00:01:18,880 --> 00:01:24,080
which i guess is being used by a lot of

00:01:21,439 --> 00:01:27,759
people now which is good

00:01:24,080 --> 00:01:30,240
so i have sort of a runtime bias um

00:01:27,759 --> 00:01:30,799
but know quite a lot about openmp and

00:01:30,240 --> 00:01:32,720
you can

00:01:30,799 --> 00:01:34,560
blame me for a few things that got into

00:01:32,720 --> 00:01:38,240
the standard um

00:01:34,560 --> 00:01:41,439
like the um like the speculative

00:01:38,240 --> 00:01:43,119
locks which we managed to

00:01:41,439 --> 00:01:44,560
suggest should go in because it's a

00:01:43,119 --> 00:01:46,000
hardware feature that wasn't

00:01:44,560 --> 00:01:48,159
that that's available in multiple

00:01:46,000 --> 00:01:52,399
processes in particular those from

00:01:48,159 --> 00:01:54,880
ibm and intel and soon arm and

00:01:52,399 --> 00:01:55,600
wasn't accessible from openmp we found a

00:01:54,880 --> 00:01:58,320
way to make that

00:01:55,600 --> 00:01:58,799
relatively easy to use from openmp and

00:01:58,320 --> 00:02:02,479
also

00:01:58,799 --> 00:02:03,520
that the i pulled out the distinction

00:02:02,479 --> 00:02:05,439
between

00:02:03,520 --> 00:02:07,439
monotonic and non-monotonic dynamic

00:02:05,439 --> 00:02:08,000
schedules and we had some interesting

00:02:07,439 --> 00:02:09,920
discussions

00:02:08,000 --> 00:02:12,480
in the standards body about those before

00:02:09,920 --> 00:02:15,680
finally deciding that um

00:02:12,480 --> 00:02:18,959
at least from openmp 5.1

00:02:15,680 --> 00:02:20,959
uh maybe even from 5.0 that um

00:02:18,959 --> 00:02:22,720
that dynamic schedules are non-monotonic

00:02:20,959 --> 00:02:25,680
by default

00:02:22,720 --> 00:02:28,080
so i see there's at least one question

00:02:25,680 --> 00:02:28,080
coming

00:02:28,239 --> 00:02:36,400
what's that so the question

00:02:32,720 --> 00:02:38,480
from mark i guess for everyone is uh

00:02:36,400 --> 00:02:40,800
would you write a new c plus program

00:02:38,480 --> 00:02:44,720
that aims performance portability with

00:02:40,800 --> 00:02:46,319
openmp or would you rather have sickle

00:02:44,720 --> 00:02:51,840
who would who would who on the panel

00:02:46,319 --> 00:02:51,840
would like to take that one

00:02:52,720 --> 00:02:56,720
i can i can probably say something about

00:02:54,560 --> 00:02:58,080
it um so you know being biased towards

00:02:56,720 --> 00:03:01,280
openmp

00:02:58,080 --> 00:03:04,319
um certainly the answer is openmp

00:03:01,280 --> 00:03:05,440
uh the more technical answer is there

00:03:04,319 --> 00:03:08,800
there is actually

00:03:05,440 --> 00:03:11,280
to my knowledge or in my belief there

00:03:08,800 --> 00:03:13,840
shouldn't be a performance difference

00:03:11,280 --> 00:03:16,959
or a way or a difference in the way that

00:03:13,840 --> 00:03:19,680
the sql compiler and the openmp compiler

00:03:16,959 --> 00:03:21,760
would handle the code as long as the

00:03:19,680 --> 00:03:23,440
code is very similar and so

00:03:21,760 --> 00:03:25,840
you should see the same performance in

00:03:23,440 --> 00:03:28,080
circle and openmp

00:03:25,840 --> 00:03:29,840
the the benefits that you will get from

00:03:28,080 --> 00:03:33,280
openmp is less

00:03:29,840 --> 00:03:35,519
code to handle buffers and

00:03:33,280 --> 00:03:37,360
uh you know glue glue code or

00:03:35,519 --> 00:03:40,159
boilerplate code that you need

00:03:37,360 --> 00:03:41,360
um to construct circles buffer objects

00:03:40,159 --> 00:03:44,720
and and get that

00:03:41,360 --> 00:03:46,239
things fed into the kernel so openmp

00:03:44,720 --> 00:03:48,959
will save you a little bit of of

00:03:46,239 --> 00:03:50,159
writing um and should give you the same

00:03:48,959 --> 00:03:53,280
performance as sickle

00:03:50,159 --> 00:03:53,280
at least that's my perspective

00:03:54,640 --> 00:03:58,720
so so i'm going to answer a little

00:03:57,360 --> 00:04:01,439
differently if that's all right

00:03:58,720 --> 00:04:03,040
that i would uh i would choose to write

00:04:01,439 --> 00:04:04,400
using the the standard c plus plus

00:04:03,040 --> 00:04:07,920
parallel algorithms as this

00:04:04,400 --> 00:04:10,319
as the starting point um i think

00:04:07,920 --> 00:04:11,599
in my opinion sickle is a little late to

00:04:10,319 --> 00:04:14,959
the game in that um

00:04:11,599 --> 00:04:16,720
c plus has largely adopted the um

00:04:14,959 --> 00:04:18,239
the parallelism features that are needed

00:04:16,720 --> 00:04:20,560
there's there are some gaps there

00:04:18,239 --> 00:04:22,800
and they're being developed into uh you

00:04:20,560 --> 00:04:23,520
know what is it 24 i think is the next

00:04:22,800 --> 00:04:26,880
one but

00:04:23,520 --> 00:04:28,880
as a whole i think um c plus

00:04:26,880 --> 00:04:30,720
is uh beginning to provide the things

00:04:28,880 --> 00:04:33,280
that that are needed

00:04:30,720 --> 00:04:33,280
that are needed

00:04:35,520 --> 00:04:42,240
on some of the data movement issues

00:04:39,120 --> 00:04:43,840
still an issue with c plus

00:04:42,240 --> 00:04:45,680
sure there's a data movement it's one

00:04:43,840 --> 00:04:49,199
thing that's uh not yet addressed

00:04:45,680 --> 00:04:51,360
um and for that um you know i think

00:04:49,199 --> 00:04:53,600
i i presented nvidia's vision which is

00:04:51,360 --> 00:04:55,360
that we would use uh the directives as

00:04:53,600 --> 00:04:56,639
a stop gap for that while that's being

00:04:55,360 --> 00:05:00,000
solved in the

00:04:56,639 --> 00:05:02,560
base languages and i would also point to

00:05:00,000 --> 00:05:03,840
all of the major um hardware

00:05:02,560 --> 00:05:06,320
architectures out there

00:05:03,840 --> 00:05:07,440
um do have support for uh for unified

00:05:06,320 --> 00:05:09,919
memory now they get you

00:05:07,440 --> 00:05:12,160
pretty pretty uh pretty far along the

00:05:09,919 --> 00:05:12,160
path

00:05:14,880 --> 00:05:20,639
i i wonder if the uh if the jamil and uh

00:05:18,320 --> 00:05:22,000
and uh people like that who are actually

00:05:20,639 --> 00:05:24,960
writing code could

00:05:22,000 --> 00:05:26,720
good up could kick in here um we we're

00:05:24,960 --> 00:05:29,280
all on the implementing side

00:05:26,720 --> 00:05:32,240
and so we're not really the right people

00:05:29,280 --> 00:05:34,400
to answer this question

00:05:32,240 --> 00:05:36,320
yeah this is christmas from the met

00:05:34,400 --> 00:05:38,639
office so

00:05:36,320 --> 00:05:40,560
one of the reasons we're taking right

00:05:38,639 --> 00:05:41,600
we're generating our own parallel code

00:05:40,560 --> 00:05:43,840
is because

00:05:41,600 --> 00:05:45,440
not only is the hardware changing very

00:05:43,840 --> 00:05:47,120
rapidly the programming models are

00:05:45,440 --> 00:05:49,039
evolving very rapidly

00:05:47,120 --> 00:05:52,560
and they're changing and evolving faster

00:05:49,039 --> 00:05:55,199
than we're developing a science model

00:05:52,560 --> 00:05:56,560
and so what we decided to do today may

00:05:55,199 --> 00:05:59,600
turn out

00:05:56,560 --> 00:06:02,720
you know when we started writing

00:05:59,600 --> 00:06:08,880
um the new model for the met office say

00:06:02,720 --> 00:06:12,080
in 2013 maybe 2014 sickle didn't exist

00:06:08,880 --> 00:06:14,880
um but with our

00:06:12,080 --> 00:06:17,039
using this approach we can sort of have

00:06:14,880 --> 00:06:18,400
a sickle implementation if we wanted one

00:06:17,039 --> 00:06:20,000
i mean it would be some work and we

00:06:18,400 --> 00:06:21,600
certainly can't do that yet

00:06:20,000 --> 00:06:23,199
but we could choose to have a signal

00:06:21,600 --> 00:06:24,080
implementation without having to choose

00:06:23,199 --> 00:06:27,280
our science code

00:06:24,080 --> 00:06:29,440
change our science code in principle

00:06:27,280 --> 00:06:30,560
and it's the same with openmp openmp is

00:06:29,440 --> 00:06:32,639
changing and evolving

00:06:30,560 --> 00:06:35,280
to take account of new changes in

00:06:32,639 --> 00:06:38,080
hardware and some of those constructs

00:06:35,280 --> 00:06:38,880
when we started didn't exist because the

00:06:38,080 --> 00:06:40,240
hardware was

00:06:38,880 --> 00:06:43,680
very very new and there wasn't any

00:06:40,240 --> 00:06:43,680
programming model for doing it so

00:06:45,280 --> 00:06:48,319
we're kind of building our own

00:06:46,479 --> 00:06:50,080
abstraction where we don't see sickle

00:06:48,319 --> 00:06:52,319
and we don't see openmp

00:06:50,080 --> 00:06:54,080
we capture the parallels that we need to

00:06:52,319 --> 00:06:55,840
do and then generate that code

00:06:54,080 --> 00:06:57,599
so that we can choose whatever we think

00:06:55,840 --> 00:06:59,759
is most appropriate at the time

00:06:57,599 --> 00:07:01,520
so the approach we've taken is not to

00:06:59,759 --> 00:07:02,000
choose a specific programming model

00:07:01,520 --> 00:07:04,960
deliberately

00:07:02,000 --> 00:07:05,360
so we're abstracting that away and doing

00:07:04,960 --> 00:07:08,160
that

00:07:05,360 --> 00:07:08,160
doing that later

00:07:10,479 --> 00:07:14,080
does it worry you chris that by moving

00:07:13,599 --> 00:07:17,120
to your

00:07:14,080 --> 00:07:20,240
domain specific language which is

00:07:17,120 --> 00:07:22,960
non-standard and pretty much

00:07:20,240 --> 00:07:23,919
belongs to you that you're restricting

00:07:22,960 --> 00:07:26,160
the number of people

00:07:23,919 --> 00:07:27,520
and that there's a who who who can work

00:07:26,160 --> 00:07:30,639
on the code and

00:07:27,520 --> 00:07:31,360
whom you can bring in and rapidly have

00:07:30,639 --> 00:07:33,840
or

00:07:31,360 --> 00:07:35,680
do you think that it's your scientist

00:07:33,840 --> 00:07:37,440
doing it and it's also obvious to a

00:07:35,680 --> 00:07:39,680
domain scientist that that's not an

00:07:37,440 --> 00:07:41,840
issue

00:07:39,680 --> 00:07:43,039
yeah i mean that's a good question so

00:07:41,840 --> 00:07:45,120
that

00:07:43,039 --> 00:07:46,960
hopefully the api we've we've

00:07:45,120 --> 00:07:48,479
constructed in conjunction with

00:07:46,960 --> 00:07:49,840
our domain scientists means that what

00:07:48,479 --> 00:07:50,879
they're doing is obvious but we do need

00:07:49,840 --> 00:07:53,360
technical

00:07:50,879 --> 00:07:54,080
uh hpc programmers and experts to

00:07:53,360 --> 00:07:56,240
develop

00:07:54,080 --> 00:07:57,680
the develop the parallel code and the

00:07:56,240 --> 00:07:59,680
code generation for that

00:07:57,680 --> 00:08:01,520
and that's kind of not what our domain

00:07:59,680 --> 00:08:03,919
scientists are doing so

00:08:01,520 --> 00:08:05,680
one of the issues of doing of having

00:08:03,919 --> 00:08:06,720
this is you know you can have to

00:08:05,680 --> 00:08:08,000
you know the framework that we're

00:08:06,720 --> 00:08:09,840
building is going to have to be around

00:08:08,000 --> 00:08:10,400
for a while and we have to support it so

00:08:09,840 --> 00:08:14,160
that is

00:08:10,400 --> 00:08:17,360
that is that is an overhead for us um

00:08:14,160 --> 00:08:18,000
having said that compared to having to

00:08:17,360 --> 00:08:20,000
debug

00:08:18,000 --> 00:08:21,199
lots of code parallel code written with

00:08:20,000 --> 00:08:24,319
bugs in from our

00:08:21,199 --> 00:08:27,680
um domain scientists um or

00:08:24,319 --> 00:08:29,759
or even from ourselves

00:08:27,680 --> 00:08:30,879
is is also a big overhead so doing it

00:08:29,759 --> 00:08:34,560
this way we get

00:08:30,879 --> 00:08:34,560
a different overhead if that makes sense

00:08:37,120 --> 00:08:43,200
makes sense anyone else got things to

00:08:40,640 --> 00:08:43,200
say on this

00:08:45,360 --> 00:08:48,480
jamil are you still here

00:08:51,760 --> 00:08:56,560
maybe he's not or maybe he's muted

00:09:00,240 --> 00:09:04,080
anyone else got questions come on what

00:09:02,080 --> 00:09:09,839
else do we want do you want to find out

00:09:04,080 --> 00:09:09,839
about people

00:09:10,560 --> 00:09:14,160
got all these people here and anyone on

00:09:12,880 --> 00:09:17,440
the panel what would you

00:09:14,160 --> 00:09:17,440
ask the other people on the panel

00:09:19,920 --> 00:09:25,040
okay well i'll ask i'll ask someone then

00:09:22,640 --> 00:09:28,320
a lot of the discussion of compilers

00:09:25,040 --> 00:09:30,320
um didn't didn't explicitly mention llvm

00:09:28,320 --> 00:09:32,720
and the comparisons of performance that

00:09:30,320 --> 00:09:36,480
uh phil was making for instance didn't

00:09:32,720 --> 00:09:39,519
include llvm is that because

00:09:36,480 --> 00:09:40,000
actually the arm compiler is llvm plus

00:09:39,519 --> 00:09:43,440
plus

00:09:40,000 --> 00:09:47,040
and therefore it's implicitly there

00:09:43,440 --> 00:09:49,839
or is it that uh llvm is not viewed as

00:09:47,040 --> 00:09:50,959
as being competitive with gcc which

00:09:49,839 --> 00:09:54,160
would surprise me

00:09:50,959 --> 00:09:57,600
i have to say um

00:09:54,160 --> 00:10:00,959
that's a good question jim yeah um so

00:09:57,600 --> 00:10:02,959
on that um i didn't mention you know the

00:10:00,959 --> 00:10:06,320
two different tool chains

00:10:02,959 --> 00:10:09,279
just off hand really um but

00:10:06,320 --> 00:10:10,480
it's certainly not the case i mean in

00:10:09,279 --> 00:10:13,680
terms of gcc

00:10:10,480 --> 00:10:14,640
development we do at arm we do a lot of

00:10:13,680 --> 00:10:17,760
development

00:10:14,640 --> 00:10:20,959
for that because um you know

00:10:17,760 --> 00:10:22,320
there are there are areas outside of hpc

00:10:20,959 --> 00:10:25,680
which obviously use

00:10:22,320 --> 00:10:28,399
the gcc tool chain quite heavily um

00:10:25,680 --> 00:10:29,600
but we also support the llbm chain as

00:10:28,399 --> 00:10:33,200
well

00:10:29,600 --> 00:10:36,240
and um there's certainly no

00:10:33,200 --> 00:10:39,839
no reason why we we we're not you know

00:10:36,240 --> 00:10:41,920
doing both um we're actively developing

00:10:39,839 --> 00:10:45,680
for llvm

00:10:41,920 --> 00:10:48,880
um and in terms of performance um

00:10:45,680 --> 00:10:53,519
so gcc 11

00:10:48,880 --> 00:10:56,560
has recently introduced some um

00:10:53,519 --> 00:11:00,160
uh code in the runtime to

00:10:56,560 --> 00:11:04,000
handle um i think it's locks better

00:11:00,160 --> 00:11:08,000
um on on our architectures um

00:11:04,000 --> 00:11:11,760
and in llvm there's been something

00:11:08,000 --> 00:11:13,040
like that for a while now um so gcc i

00:11:11,760 --> 00:11:17,680
guess is catching up

00:11:13,040 --> 00:11:20,160
in terms of the the run time um

00:11:17,680 --> 00:11:22,560
and that that's about it really um i

00:11:20,160 --> 00:11:24,560
think you know as we see more calls

00:11:22,560 --> 00:11:26,399
um over the certainly on arm

00:11:24,560 --> 00:11:28,160
architectures like other architectures

00:11:26,399 --> 00:11:29,360
we'll be seeing more calls over the next

00:11:28,160 --> 00:11:32,240
few years

00:11:29,360 --> 00:11:33,440
um these openmp runtimes both you know

00:11:32,240 --> 00:11:36,240
from llvm

00:11:33,440 --> 00:11:36,800
gcc they'll need to keep up with that in

00:11:36,240 --> 00:11:39,920
terms of

00:11:36,800 --> 00:11:42,959
how they can handle um you know

00:11:39,920 --> 00:11:46,560
memory accesses shared memory type

00:11:42,959 --> 00:11:49,519
data transfers and you know locks and

00:11:46,560 --> 00:11:49,519
that kind of thing

00:11:52,800 --> 00:11:56,079
it's something i've noticed over the

00:11:54,880 --> 00:11:58,240
past uh

00:11:56,079 --> 00:11:59,440
several years is just the incredible

00:11:58,240 --> 00:12:01,440
velocity that

00:11:59,440 --> 00:12:03,040
the lvm toolchain has made in with

00:12:01,440 --> 00:12:04,720
regards to to openmp

00:12:03,040 --> 00:12:08,000
and i think that comes down to it's got

00:12:04,720 --> 00:12:11,200
a a friendly license that has enabled

00:12:08,000 --> 00:12:12,079
vendors like intel like nvidia like amd

00:12:11,200 --> 00:12:14,800
like ibm

00:12:12,079 --> 00:12:16,480
like arm to jump in and and work

00:12:14,800 --> 00:12:17,519
together and collaborate and so i think

00:12:16,480 --> 00:12:20,399
the openmp

00:12:17,519 --> 00:12:21,120
collaboration has expanded out to

00:12:20,399 --> 00:12:23,120
include

00:12:21,120 --> 00:12:24,720
lvm in some ways because of its friendly

00:12:23,120 --> 00:12:27,440
license it also has

00:12:24,720 --> 00:12:28,079
meant there's been times where features

00:12:27,440 --> 00:12:29,920
have been

00:12:28,079 --> 00:12:31,279
able to be prototyped in ways they

00:12:29,920 --> 00:12:32,639
couldn't have previously because now

00:12:31,279 --> 00:12:35,839
there is a

00:12:32,639 --> 00:12:38,079
relatively mature compiler uh that

00:12:35,839 --> 00:12:39,440
that that people can touch and can work

00:12:38,079 --> 00:12:42,240
in and so i think

00:12:39,440 --> 00:12:43,360
um you know i've i don't work in the

00:12:42,240 --> 00:12:45,120
compiler portion i work in the

00:12:43,360 --> 00:12:46,079
applications portion but just seeing the

00:12:45,120 --> 00:12:47,600
velocity that

00:12:46,079 --> 00:12:49,600
that lvm has taken in the last several

00:12:47,600 --> 00:12:51,279
years has been impressive and

00:12:49,600 --> 00:12:53,040
i'm personally getting asked a lot more

00:12:51,279 --> 00:12:55,120
often by people about

00:12:53,040 --> 00:12:56,639
you know using using clang in their code

00:12:55,120 --> 00:12:59,600
or using flang as it's

00:12:56,639 --> 00:13:01,279
maturing and that that question wasn't

00:12:59,600 --> 00:13:03,519
asked me three years ago

00:13:01,279 --> 00:13:05,040
yeah flang is flang is slightly a

00:13:03,519 --> 00:13:07,360
concern of course but

00:13:05,040 --> 00:13:08,320
i quite agree that the dyson has been

00:13:07,360 --> 00:13:10,800
critical there

00:13:08,320 --> 00:13:12,160
and has has led to exactly the thing

00:13:10,800 --> 00:13:13,920
you're talking about that it's a good

00:13:12,160 --> 00:13:15,279
environment for people to do research as

00:13:13,920 --> 00:13:18,560
we saw earlier

00:13:15,279 --> 00:13:19,920
um yes not people are

00:13:18,560 --> 00:13:22,320
are we doing research in that

00:13:19,920 --> 00:13:24,320
environment and also the contributions

00:13:22,320 --> 00:13:25,920
from argonne should not be um

00:13:24,320 --> 00:13:29,040
discounted there they've been doing a

00:13:25,920 --> 00:13:33,040
lot of work in improving openmp

00:13:29,040 --> 00:13:36,160
uh optimizations within llvm

00:13:33,040 --> 00:13:36,560
yes uh i i would like to add just uh

00:13:36,160 --> 00:13:38,480
what

00:13:36,560 --> 00:13:39,839
jeff said is more or less what happened

00:13:38,480 --> 00:13:43,360
to us also in

00:13:39,839 --> 00:13:47,519
the university of boston that our first

00:13:43,360 --> 00:13:48,560
work was using gcc uh but we migrated to

00:13:47,519 --> 00:13:52,160
llvm uh

00:13:48,560 --> 00:13:54,880
also not only because of

00:13:52,160 --> 00:13:55,920
the license things but also because the

00:13:54,880 --> 00:13:58,880
code was

00:13:55,920 --> 00:14:01,440
slightly more accessible or how can i

00:13:58,880 --> 00:14:04,880
say maybe easier to follow

00:14:01,440 --> 00:14:05,279
and the only problem we had is that some

00:14:04,880 --> 00:14:09,680
of

00:14:05,279 --> 00:14:11,839
uh i i don't really know how it is

00:14:09,680 --> 00:14:13,839
right now but at the time we started

00:14:11,839 --> 00:14:17,519
developing the techniques and

00:14:13,839 --> 00:14:20,399
some features we had to compile the

00:14:17,519 --> 00:14:21,519
llvm runtime with the intel compiler

00:14:20,399 --> 00:14:24,720
since clang

00:14:21,519 --> 00:14:26,639
didn't have some of the functions or i

00:14:24,720 --> 00:14:31,839
don't remember exactly what it was but

00:14:26,639 --> 00:14:31,839
clang had some problems

00:14:32,720 --> 00:14:37,279
so there's there's uh one related

00:14:35,040 --> 00:14:38,000
question also in the in the q a box uh

00:14:37,279 --> 00:14:41,199
so

00:14:38,000 --> 00:14:44,320
uh there's actually um a meeting between

00:14:41,199 --> 00:14:46,079
all the major compiler vendors in the

00:14:44,320 --> 00:14:49,199
openmp arb

00:14:46,079 --> 00:14:51,600
to collaborate on the different openmp

00:14:49,199 --> 00:14:52,959
features that have to be implemented who

00:14:51,600 --> 00:14:56,079
does what how they are

00:14:52,959 --> 00:14:58,720
implemented so there's a tight

00:14:56,079 --> 00:14:59,519
cross vendor collaboration to bring

00:14:58,720 --> 00:15:02,399
clang

00:14:59,519 --> 00:15:03,839
as the main clang up to speed with

00:15:02,399 --> 00:15:06,480
openmp support

00:15:03,839 --> 00:15:07,279
but also then to downstream um those

00:15:06,480 --> 00:15:09,680
changes

00:15:07,279 --> 00:15:11,199
back in the individual commercial

00:15:09,680 --> 00:15:13,600
compilers

00:15:11,199 --> 00:15:16,880
that are then produced as part of the

00:15:13,600 --> 00:15:16,880
vendor-specific offerings

00:15:20,560 --> 00:15:24,959
there's also a for instance i can only

00:15:23,199 --> 00:15:25,600
speak for another vm but there's a

00:15:24,959 --> 00:15:27,519
there's a

00:15:25,600 --> 00:15:29,519
inter company meeting that happens once

00:15:27,519 --> 00:15:32,079
a week or once a fortnight of clanged

00:15:29,519 --> 00:15:33,519
clang open mp developers who would who

00:15:32,079 --> 00:15:35,199
who uh

00:15:33,519 --> 00:15:37,680
divvying out some of the work between

00:15:35,199 --> 00:15:39,199
them you know particularly

00:15:37,680 --> 00:15:41,199
uh we want we're going to do a lot of

00:15:39,199 --> 00:15:43,759
work on the on the

00:15:41,199 --> 00:15:44,800
on something for gpus okay well we will

00:15:43,759 --> 00:15:46,560
do something in

00:15:44,800 --> 00:15:48,399
slightly different area and making sure

00:15:46,560 --> 00:15:51,440
that it does indeed all

00:15:48,399 --> 00:15:52,720
get get up i mean every obviously

00:15:51,440 --> 00:15:54,079
all of these things have to meet the

00:15:52,720 --> 00:15:55,360
license requirements they have to have

00:15:54,079 --> 00:15:57,600
tests they have to be properly

00:15:55,360 --> 00:15:59,120
documented in all of this so it's

00:15:57,600 --> 00:16:00,639
you want quality code in there and

00:15:59,120 --> 00:16:02,480
that's that's entirely reasonable but

00:16:00,639 --> 00:16:03,519
there is certainly cooperation within

00:16:02,480 --> 00:16:06,399
within

00:16:03,519 --> 00:16:07,920
the llvm environment in that and that's

00:16:06,399 --> 00:16:08,800
an open meeting so if people want to

00:16:07,920 --> 00:16:10,480
join it they should

00:16:08,800 --> 00:16:13,440
find out about it and they're a mail

00:16:10,480 --> 00:16:17,040
list and so on and you can just join

00:16:13,440 --> 00:16:20,880
um should we move on a little

00:16:17,040 --> 00:16:23,839
what else have we got here um mark bull

00:16:20,880 --> 00:16:24,800
wants us to work out how do we get that

00:16:23,839 --> 00:16:28,000
the specs are

00:16:24,800 --> 00:16:31,680
impenetrable well

00:16:28,000 --> 00:16:35,040
that maybe that is slightly reasonable

00:16:31,680 --> 00:16:36,880
um we do tend to talk about things like

00:16:35,040 --> 00:16:38,959
contention groups

00:16:36,880 --> 00:16:40,399
which came up in in some of the

00:16:38,959 --> 00:16:41,519
discussion earlier jeff mentioned

00:16:40,399 --> 00:16:43,360
contention groups

00:16:41,519 --> 00:16:44,639
and if you haven't heard that term

00:16:43,360 --> 00:16:48,000
before it's not

00:16:44,639 --> 00:16:50,480
utterly obvious what it means

00:16:48,000 --> 00:16:51,519
i think most would agree so mark is

00:16:50,480 --> 00:16:53,440
saying how do we

00:16:51,519 --> 00:16:55,360
get the word out about all the new

00:16:53,440 --> 00:16:57,680
things

00:16:55,360 --> 00:16:58,959
anyone anyone have any views on that i

00:16:57,680 --> 00:17:00,240
mean we're trying to do it that's what

00:16:58,959 --> 00:17:04,079
we're here doing

00:17:00,240 --> 00:17:06,559
um but but i'm not sure how you

00:17:04,079 --> 00:17:07,439
how we go further anyone have any

00:17:06,559 --> 00:17:09,199
opinions

00:17:07,439 --> 00:17:10,799
there's a little bit of a chicken and

00:17:09,199 --> 00:17:12,400
egg problem there right we we get the

00:17:10,799 --> 00:17:13,360
word out that here are some great new

00:17:12,400 --> 00:17:15,760
features but

00:17:13,360 --> 00:17:17,199
then uh if the compilers aren't ready

00:17:15,760 --> 00:17:19,600
for see people to try it

00:17:17,199 --> 00:17:20,400
then you know it's hard for them to get

00:17:19,600 --> 00:17:21,760
excited

00:17:20,400 --> 00:17:23,439
and on the flip side it's hard to get a

00:17:21,760 --> 00:17:25,919
compiler writer

00:17:23,439 --> 00:17:27,679
excited about a feature uh if there's

00:17:25,919 --> 00:17:31,280
nobody ready to use it so i

00:17:27,679 --> 00:17:33,039
it's it's um it's been a

00:17:31,280 --> 00:17:34,400
pretty significant challenge i think uh

00:17:33,039 --> 00:17:36,960
you know loop is the

00:17:34,400 --> 00:17:37,840
one example that that i've uh been uh

00:17:36,960 --> 00:17:41,039
connected with

00:17:37,840 --> 00:17:43,600
you know it's uh you know here we are

00:17:41,039 --> 00:17:45,440
two years beyond when 5.0 came out and

00:17:43,600 --> 00:17:48,880
we're just now starting to see

00:17:45,440 --> 00:17:50,160
you know usable implementations of loop

00:17:48,880 --> 00:17:52,480
um you have things like the meta

00:17:50,160 --> 00:17:55,520
directive that are you know huge

00:17:52,480 --> 00:17:56,240
enormous they're hard to understand um i

00:17:55,520 --> 00:17:58,480
think

00:17:56,240 --> 00:18:00,000
you know openmp puts out the examples

00:17:58,480 --> 00:18:01,600
document and i think

00:18:00,000 --> 00:18:03,039
there's a lot of hard work goes into

00:18:01,600 --> 00:18:04,880
that but

00:18:03,039 --> 00:18:06,720
but i think what mark's saying here is

00:18:04,880 --> 00:18:09,760
perhaps we need to do better

00:18:06,720 --> 00:18:12,960
and and make more complete

00:18:09,760 --> 00:18:12,960
examples perhaps

00:18:13,440 --> 00:18:16,880
and i think um that's uh maybe a

00:18:15,760 --> 00:18:19,440
challenge to us

00:18:16,880 --> 00:18:21,039
on the on the committee to to take that

00:18:19,440 --> 00:18:22,240
to heart and come up with more complete

00:18:21,039 --> 00:18:24,720
examples there's

00:18:22,240 --> 00:18:25,360
there has been a push from some members

00:18:24,720 --> 00:18:27,679
to

00:18:25,360 --> 00:18:28,559
not accept a uh a feature until an

00:18:27,679 --> 00:18:30,960
example

00:18:28,559 --> 00:18:32,160
exists and maybe that's one possible

00:18:30,960 --> 00:18:35,440
solution but uh

00:18:32,160 --> 00:18:38,640
he's right it's a challenge um

00:18:35,440 --> 00:18:38,640
it's it's complex

00:18:39,120 --> 00:18:43,760
so apart from the from the examples

00:18:41,520 --> 00:18:47,679
document that jeff was mentioning

00:18:43,760 --> 00:18:48,240
uh we obviously have openmp tutorials

00:18:47,679 --> 00:18:51,039
that are

00:18:48,240 --> 00:18:52,400
being recorded and at least try to

00:18:51,039 --> 00:18:54,480
explain

00:18:52,400 --> 00:18:56,400
several of the most important features

00:18:54,480 --> 00:18:58,400
of openmp these are all on the

00:18:56,400 --> 00:19:00,799
youtube channel of the openmp erp so

00:18:58,400 --> 00:19:03,440
they should be easy to find

00:19:00,799 --> 00:19:05,000
then there are at least books that are

00:19:03,440 --> 00:19:08,400
covering openmp up to

00:19:05,000 --> 00:19:11,039
openmp45 i believe so

00:19:08,400 --> 00:19:12,000
one of the incentives is if you if you

00:19:11,039 --> 00:19:14,720
buy those books

00:19:12,000 --> 00:19:16,799
um the authors have more incentives to

00:19:14,720 --> 00:19:18,640
write the openmp51 book

00:19:16,799 --> 00:19:20,160
um to you know to explain the

00:19:18,640 --> 00:19:22,240
specification

00:19:20,160 --> 00:19:24,320
um but yes we we need to do better on

00:19:22,240 --> 00:19:25,440
that um and so if you have suggestions

00:19:24,320 --> 00:19:28,320
how we can

00:19:25,440 --> 00:19:29,840
how we can you know improve the

00:19:28,320 --> 00:19:32,960
spreading the word

00:19:29,840 --> 00:19:39,840
i'm i'll be happy to hear that and happy

00:19:32,960 --> 00:19:39,840
to support that

00:19:39,919 --> 00:19:43,440
uh yes it is slightly frightening that

00:19:42,640 --> 00:19:47,760
that even

00:19:43,440 --> 00:19:50,720
i see this this year one of the posters

00:19:47,760 --> 00:19:52,320
was supposed to won't say too much

00:19:50,720 --> 00:19:55,200
because it would be a bit mean

00:19:52,320 --> 00:19:56,880
but it it managed to compare features of

00:19:55,200 --> 00:20:00,480
openmp

00:19:56,880 --> 00:20:03,039
with uh with other uh programming models

00:20:00,480 --> 00:20:07,039
and used openmp 2.0

00:20:03,039 --> 00:20:09,679
as its openmp reference

00:20:07,039 --> 00:20:10,559
and it's slightly concerning that that

00:20:09,679 --> 00:20:12,880
got through

00:20:10,559 --> 00:20:13,760
through the reviewers and everyone and

00:20:12,880 --> 00:20:17,520
got it onto

00:20:13,760 --> 00:20:20,080
into the poster it suggests that

00:20:17,520 --> 00:20:21,760
we're slightly not publicizing things

00:20:20,080 --> 00:20:25,919
widely enough

00:20:21,760 --> 00:20:29,039
maybe in academia and in and in and in

00:20:25,919 --> 00:20:31,440
in education if if people are unaware

00:20:29,039 --> 00:20:32,960
that openmp has changed in the last 20

00:20:31,440 --> 00:20:35,679
years

00:20:32,960 --> 00:20:36,320
um i i don't know how we overcome that

00:20:35,679 --> 00:20:39,200
but it is

00:20:36,320 --> 00:20:39,200
slightly worrying

00:20:40,320 --> 00:20:47,039
should we move on to something else

00:20:43,679 --> 00:20:48,799
there are some questions here

00:20:47,039 --> 00:20:50,240
uh konstantinos do you want to be

00:20:48,799 --> 00:20:52,559
unmuted so you can

00:20:50,240 --> 00:20:54,720
ask your questions or shall we read them

00:20:52,559 --> 00:20:54,720
out

00:20:55,919 --> 00:21:01,760
okay let's let's go for those uh so

00:20:58,960 --> 00:21:03,200
he's constantinos is asking for gpu

00:21:01,760 --> 00:21:05,600
offload

00:21:03,200 --> 00:21:07,440
the choice of compiler has a big effect

00:21:05,600 --> 00:21:09,600
on which parallel constructs

00:21:07,440 --> 00:21:11,360
you need to use especially when it comes

00:21:09,600 --> 00:21:13,200
to the simdi directive

00:21:11,360 --> 00:21:15,039
so you end up with multiple versions of

00:21:13,200 --> 00:21:16,640
the code

00:21:15,039 --> 00:21:18,080
depending on the platform and the

00:21:16,640 --> 00:21:20,400
compiler

00:21:18,080 --> 00:21:22,080
either with ifs or using the other

00:21:20,400 --> 00:21:23,280
features that you can use within openmp

00:21:22,080 --> 00:21:25,760
to achieve that

00:21:23,280 --> 00:21:28,640
and that's messy and unpleasant and very

00:21:25,760 --> 00:21:32,559
reasonably doesn't want to do it

00:21:28,640 --> 00:21:35,600
is it unavoidable or is there magic

00:21:32,559 --> 00:21:35,919
um did the do the directives that jeff

00:21:35,600 --> 00:21:38,400
was

00:21:35,919 --> 00:21:39,520
jeff was suggesting are they sufficient

00:21:38,400 --> 00:21:44,799
um

00:21:39,520 --> 00:21:48,000
do we have opinions people

00:21:44,799 --> 00:21:48,960
well my opinion it's always going to be

00:21:48,000 --> 00:21:52,080
the same one

00:21:48,960 --> 00:21:52,720
and this is precisely why we're trying

00:21:52,080 --> 00:21:56,240
to control

00:21:52,720 --> 00:21:57,919
what what parallelism we produce because

00:21:56,240 --> 00:21:59,280
we won't be able to have single science

00:21:57,919 --> 00:22:02,320
source code and

00:21:59,280 --> 00:22:04,320
there's lots of new things in openmp uh

00:22:02,320 --> 00:22:05,360
in in in the newer versions of the

00:22:04,320 --> 00:22:08,960
standards that go

00:22:05,360 --> 00:22:12,720
a lot further beyond um

00:22:08,960 --> 00:22:14,400
uh openmp2 openmp2 is relatively simple

00:22:12,720 --> 00:22:16,000
to use and quite effective and beyond

00:22:14,400 --> 00:22:17,679
that there's a whole load of different

00:22:16,000 --> 00:22:19,600
things you could do and what you

00:22:17,679 --> 00:22:21,360
can do depending on what you should do

00:22:19,600 --> 00:22:23,039
depends on the architecture depends on

00:22:21,360 --> 00:22:24,400
the compiler and depends on what problem

00:22:23,039 --> 00:22:25,840
you're trying to solve

00:22:24,400 --> 00:22:27,679
and the problem is some of those things

00:22:25,840 --> 00:22:28,960
are not you know the problem you're

00:22:27,679 --> 00:22:30,400
trying to solve might stay the same but

00:22:28,960 --> 00:22:32,000
the architecture the implementation is

00:22:30,400 --> 00:22:34,159
gonna it might well change

00:22:32,000 --> 00:22:36,159
and then that does that mean you can

00:22:34,159 --> 00:22:39,280
still have the single science source

00:22:36,159 --> 00:22:41,919
and from our point of view as a

00:22:39,280 --> 00:22:42,400
application it looks like that we can't

00:22:41,919 --> 00:22:43,679
so

00:22:42,400 --> 00:22:45,600
that's why we're going to end up having

00:22:43,679 --> 00:22:46,960
to control that and generate our code

00:22:45,600 --> 00:22:48,640
and then we can make use of the

00:22:46,960 --> 00:22:55,840
appropriate features that are in

00:22:48,640 --> 00:22:55,840
the newest standards of openmp

00:22:57,520 --> 00:23:02,640
yeah i mean it's we've seen it at

00:23:00,799 --> 00:23:03,039
various workshops like this where people

00:23:02,640 --> 00:23:06,159
will

00:23:03,039 --> 00:23:07,200
come with code and they'll run it

00:23:06,159 --> 00:23:09,039
through

00:23:07,200 --> 00:23:10,559
three different compilers on the same

00:23:09,039 --> 00:23:12,640
platform and get

00:23:10,559 --> 00:23:15,520
wildly different results because

00:23:12,640 --> 00:23:18,880
platforms have gotten a lot more complex

00:23:15,520 --> 00:23:20,480
when openmp was designed initially

00:23:18,880 --> 00:23:22,320
you know a single flat level of

00:23:20,480 --> 00:23:23,679
parallelism was a reasonable assumption

00:23:22,320 --> 00:23:26,159
that worked really well

00:23:23,679 --> 00:23:28,000
because that was what was available in

00:23:26,159 --> 00:23:29,760
the market and now

00:23:28,000 --> 00:23:32,080
uh the market has changed dramatically

00:23:29,760 --> 00:23:36,880
and openmp has changed along with it

00:23:32,080 --> 00:23:39,280
and um it's you know how do you

00:23:36,880 --> 00:23:40,000
um how do you write code that uh there

00:23:39,280 --> 00:23:44,240
that runs

00:23:40,000 --> 00:23:47,600
from on a cpu and a gpu and a dsp

00:23:44,240 --> 00:23:48,240
and expected is it realistic to expect a

00:23:47,600 --> 00:23:50,880
single

00:23:48,240 --> 00:23:52,960
directive to to work across all of them

00:23:50,880 --> 00:23:55,520
in some ways perhaps not

00:23:52,960 --> 00:23:57,279
you can minimize a minute ago you were

00:23:55,520 --> 00:23:58,240
telling us that the answer was just to

00:23:57,279 --> 00:24:00,640
write standard c

00:23:58,240 --> 00:24:02,080
plus plus with the with the with the

00:24:00,640 --> 00:24:03,760
algorithms and so on

00:24:02,080 --> 00:24:05,760
and now you're telling us that the added

00:24:03,760 --> 00:24:06,799
complexity of openmp is still not

00:24:05,760 --> 00:24:10,400
sufficient

00:24:06,799 --> 00:24:13,360
it seems slightly inconsistent

00:24:10,400 --> 00:24:14,000
i i don't think it is we um because what

00:24:13,360 --> 00:24:15,919
what i

00:24:14,000 --> 00:24:17,760
was moving towards before he jumped in

00:24:15,919 --> 00:24:20,960
there is that um

00:24:17,760 --> 00:24:24,880
for for a lot of data parallel code

00:24:20,960 --> 00:24:28,480
if you can um expose the the parallelism

00:24:24,880 --> 00:24:29,200
you can make a first attempt using

00:24:28,480 --> 00:24:30,880
something like

00:24:29,200 --> 00:24:32,320
lube something like parallel algorithms

00:24:30,880 --> 00:24:35,600
to get uh

00:24:32,320 --> 00:24:37,919
to get good enough performance to start

00:24:35,600 --> 00:24:38,960
and then you start to specialize and so

00:24:37,919 --> 00:24:41,120
um

00:24:38,960 --> 00:24:42,480
the meta directive is an example i'm

00:24:41,120 --> 00:24:44,240
personally not a huge fan of the meta

00:24:42,480 --> 00:24:44,960
director because of the complexity of it

00:24:44,240 --> 00:24:48,159
and i

00:24:44,960 --> 00:24:49,279
when i look at at a presentation i spoke

00:24:48,159 --> 00:24:51,679
to someone at

00:24:49,279 --> 00:24:53,279
a conference and they they ran they had

00:24:51,679 --> 00:24:55,200
one column for openmp

00:24:53,279 --> 00:24:56,559
for gpus and cpus they had two different

00:24:55,200 --> 00:24:57,200
directives and they said well the meta

00:24:56,559 --> 00:24:58,960
directive

00:24:57,200 --> 00:25:00,960
well the meta director still involves

00:24:58,960 --> 00:25:01,279
writing two different directives it's

00:25:00,960 --> 00:25:04,960
just

00:25:01,279 --> 00:25:08,400
resolved by the by the compiler um

00:25:04,960 --> 00:25:11,200
you know i am have long been a believer

00:25:08,400 --> 00:25:12,640
of something like loop that that where

00:25:11,200 --> 00:25:14,559
and something like the parallelograms

00:25:12,640 --> 00:25:16,640
where you expose where there is

00:25:14,559 --> 00:25:19,919
parallelism and you have a

00:25:16,640 --> 00:25:20,880
uh a you know fairly advanced compiler

00:25:19,919 --> 00:25:23,440
and runtime to

00:25:20,880 --> 00:25:25,039
to make a best effort of getting you

00:25:23,440 --> 00:25:25,440
good enough performance and when good

00:25:25,039 --> 00:25:27,600
enough

00:25:25,440 --> 00:25:28,799
isn't good enough well then you're gonna

00:25:27,600 --> 00:25:30,960
have to specialize

00:25:28,799 --> 00:25:32,240
and that does mean writing you know

00:25:30,960 --> 00:25:34,559
non-portable

00:25:32,240 --> 00:25:36,000
uh directives for the places where it

00:25:34,559 --> 00:25:37,919
really really counts

00:25:36,000 --> 00:25:39,039
you can get a lot of your code running

00:25:37,919 --> 00:25:41,840
with a

00:25:39,039 --> 00:25:43,120
fairly generic parallel you know teams

00:25:41,840 --> 00:25:45,840
distribute parallel four

00:25:43,120 --> 00:25:47,679
collapse and then the really performance

00:25:45,840 --> 00:25:49,360
critical parts you may have to write

00:25:47,679 --> 00:25:53,039
more specialized code

00:25:49,360 --> 00:25:55,440
um and you know openmp is

00:25:53,039 --> 00:25:57,840
is an abstraction that enables you to do

00:25:55,440 --> 00:25:57,840
that

00:25:59,919 --> 00:26:03,200
okay so that does make reasonable sense

00:26:02,799 --> 00:26:06,080
and

00:26:03,200 --> 00:26:07,440
i guess the so this is actually a

00:26:06,080 --> 00:26:09,360
question that came up in

00:26:07,440 --> 00:26:10,480
i think it's slightly more or less

00:26:09,360 --> 00:26:12,880
relevant here and since

00:26:10,480 --> 00:26:13,760
since you're talking it came up

00:26:12,880 --> 00:26:16,880
yesterday in

00:26:13,760 --> 00:26:18,960
in tom's

00:26:16,880 --> 00:26:20,720
tutorial where we were generating code

00:26:18,960 --> 00:26:22,480
and offloading it to gpus and someone

00:26:20,720 --> 00:26:23,200
was saying well how am i going to use

00:26:22,480 --> 00:26:25,679
the

00:26:23,200 --> 00:26:26,320
matrix engines that everyone's putting

00:26:25,679 --> 00:26:30,080
in from

00:26:26,320 --> 00:26:33,279
openmp and my

00:26:30,080 --> 00:26:35,520
hope and expectation is that those will

00:26:33,279 --> 00:26:38,720
end up looking like blast functions

00:26:35,520 --> 00:26:40,320
in cuda or whatever at some level and

00:26:38,720 --> 00:26:41,520
i'll just be able to call them from the

00:26:40,320 --> 00:26:43,440
openmp

00:26:41,520 --> 00:26:45,440
code that i already am using and

00:26:43,440 --> 00:26:46,640
offloading but maybe you can

00:26:45,440 --> 00:26:48,640
tell us whether that's a reasonable

00:26:46,640 --> 00:26:51,120
expectation i have

00:26:48,640 --> 00:26:52,880
two answers one is libraries um there

00:26:51,120 --> 00:26:54,640
are things like blahs that while not

00:26:52,880 --> 00:26:56,240
standard they are

00:26:54,640 --> 00:26:58,000
fairly standard they're standard enough

00:26:56,240 --> 00:27:00,400
that everybody supports them

00:26:58,000 --> 00:27:01,520
and you know what c plus plus has is

00:27:00,400 --> 00:27:04,559
adopting

00:27:01,520 --> 00:27:07,200
um a math language interface that's

00:27:04,559 --> 00:27:08,480
blas like i think it's coming in i don't

00:27:07,200 --> 00:27:10,400
think it's in 20

00:27:08,480 --> 00:27:11,600
and 20 i think it's a 23 or four

00:27:10,400 --> 00:27:14,320
whatever that is

00:27:11,600 --> 00:27:16,159
and uh fortran has matt mull um our

00:27:14,320 --> 00:27:17,600
compiler chain will recognize a matte

00:27:16,159 --> 00:27:19,360
mole

00:27:17,600 --> 00:27:21,279
and pass it all the way down to our

00:27:19,360 --> 00:27:23,919
tensor cores for you

00:27:21,279 --> 00:27:26,240
um including potentially changing the

00:27:23,919 --> 00:27:29,760
data type if it's if it's appropriate so

00:27:26,240 --> 00:27:30,799
um you know i think um is it up to

00:27:29,760 --> 00:27:32,640
openmp to

00:27:30,799 --> 00:27:34,559
define those things well i think the the

00:27:32,640 --> 00:27:37,600
languages and the and the libraries are

00:27:34,559 --> 00:27:37,600
already doing that pretty well

00:27:38,320 --> 00:27:42,159
great so libraries is the answer

00:27:40,000 --> 00:27:45,120
basically libraries

00:27:42,159 --> 00:27:46,559
good good i'm glad that's that's good

00:27:45,120 --> 00:27:48,799
that's a good answer from my point of

00:27:46,559 --> 00:27:48,799
view

00:27:49,720 --> 00:27:52,720
constantinos has another one here that

00:27:51,840 --> 00:27:55,760
we'll just do

00:27:52,720 --> 00:28:00,080
quickly i think because

00:27:55,760 --> 00:28:02,880
he's asking specifically about latest

00:28:00,080 --> 00:28:07,200
new feature supporting compilers pgi

00:28:02,880 --> 00:28:08,880
plans for openmp support for offload

00:28:07,200 --> 00:28:10,559
um do you want to say anything about

00:28:08,880 --> 00:28:11,120
that jeff or can we move on to something

00:28:10,559 --> 00:28:13,200
else

00:28:11,120 --> 00:28:14,559
well no you so you know he points out

00:28:13,200 --> 00:28:16,559
that at sc

00:28:14,559 --> 00:28:17,840
19 there was a huge discussion at the

00:28:16,559 --> 00:28:20,399
buff about

00:28:17,840 --> 00:28:21,200
the fact that the nvidia compiler chain

00:28:20,399 --> 00:28:23,520
was being upfront

00:28:21,200 --> 00:28:24,399
saying there are things that our initial

00:28:23,520 --> 00:28:26,480
implementation

00:28:24,399 --> 00:28:27,600
will not support on the gpu because

00:28:26,480 --> 00:28:30,480
either it's uh

00:28:27,600 --> 00:28:31,919
not not scalable enough it or it's not

00:28:30,480 --> 00:28:33,279
something we believe

00:28:31,919 --> 00:28:35,120
needs the engineering effort for our

00:28:33,279 --> 00:28:36,080
first implementation does that mean it's

00:28:35,120 --> 00:28:39,120
never going to be there

00:28:36,080 --> 00:28:39,679
no um and does that and are we unique in

00:28:39,120 --> 00:28:42,320
that no

00:28:39,679 --> 00:28:44,159
intel at the exact same uh event at

00:28:42,320 --> 00:28:45,279
super computing at the openmp booth

00:28:44,159 --> 00:28:48,000
presented that they were also

00:28:45,279 --> 00:28:50,559
implementing a subset for the gpus

00:28:48,000 --> 00:28:51,679
for their initial implementation um and

00:28:50,559 --> 00:28:54,159
so

00:28:51,679 --> 00:28:55,120
you know right now as far as i'm aware

00:28:54,159 --> 00:28:58,080
there are no

00:28:55,120 --> 00:29:00,080
complete openmp 4.5 compilers there are

00:28:58,080 --> 00:29:02,320
no complete 5.0 compilers there are no

00:29:00,080 --> 00:29:05,520
5.1 compilers

00:29:02,320 --> 00:29:07,279
you know we as vendors need to hear from

00:29:05,520 --> 00:29:08,640
the users here's how to prioritize the

00:29:07,279 --> 00:29:10,000
features because it takes engineering

00:29:08,640 --> 00:29:12,640
effort

00:29:10,000 --> 00:29:14,080
not all features make uh perfect sense

00:29:12,640 --> 00:29:16,320
on our gpus

00:29:14,080 --> 00:29:18,320
so we're gonna prioritize them lower

00:29:16,320 --> 00:29:20,880
than the ones that we view as

00:29:18,320 --> 00:29:22,720
uh things we want our developers using

00:29:20,880 --> 00:29:23,760
and uh to get the best use out of our

00:29:22,720 --> 00:29:27,120
gpus and i think

00:29:23,760 --> 00:29:29,120
all of the vendors share that um and

00:29:27,120 --> 00:29:31,440
um you know do we need a gentleman's

00:29:29,120 --> 00:29:32,559
agreement on what that subset is some

00:29:31,440 --> 00:29:34,399
people think we do

00:29:32,559 --> 00:29:36,000
um some people would say isn't that what

00:29:34,399 --> 00:29:36,720
the specifications for in the first

00:29:36,000 --> 00:29:40,960
place

00:29:36,720 --> 00:29:43,279
i don't know the answer to that but

00:29:40,960 --> 00:29:45,039
can i make two comments on that uh so

00:29:43,279 --> 00:29:47,679
the first one is actually about the

00:29:45,039 --> 00:29:48,080
last sentence that jeff just said so i'm

00:29:47,679 --> 00:29:50,320
i'm

00:29:48,080 --> 00:29:52,240
mildly worried that you know the the

00:29:50,320 --> 00:29:56,080
subset that intel

00:29:52,240 --> 00:29:58,960
uh ibm arm whoever implements for

00:29:56,080 --> 00:29:59,520
for accelerators is slightly different

00:29:58,960 --> 00:30:01,520
enough

00:29:59,520 --> 00:30:03,520
so that you know in reality you get

00:30:01,520 --> 00:30:07,039
non-portable code so you know

00:30:03,520 --> 00:30:08,880
that's where the air b also strives to

00:30:07,039 --> 00:30:10,480
you know bring the vendors together and

00:30:08,880 --> 00:30:11,600
and make them talk to each other so that

00:30:10,480 --> 00:30:14,320
that subset is

00:30:11,600 --> 00:30:15,279
as compatible as possible and the other

00:30:14,320 --> 00:30:18,000
thing is

00:30:15,279 --> 00:30:20,159
coming back to the original question uh

00:30:18,000 --> 00:30:23,200
this is not so much an openmp

00:30:20,159 --> 00:30:26,159
issue this also relates to

00:30:23,200 --> 00:30:27,279
the base language right so there's only

00:30:26,159 --> 00:30:30,080
so much of an

00:30:27,279 --> 00:30:31,039
uh fortran subset that makes sense to be

00:30:30,080 --> 00:30:34,240
offloaded to

00:30:31,039 --> 00:30:35,360
some device like a gpu so you wouldn't

00:30:34,240 --> 00:30:39,840
expect that you could do

00:30:35,360 --> 00:30:41,919
like full hdf5 file export

00:30:39,840 --> 00:30:43,679
from a gpu so there are already kind of

00:30:41,919 --> 00:30:45,440
restrictions coming in

00:30:43,679 --> 00:30:46,799
from the base language in terms of what

00:30:45,440 --> 00:30:49,840
makes sense

00:30:46,799 --> 00:30:51,360
on a gpu and so openmp is no different

00:30:49,840 --> 00:30:53,279
in that regard that there's also

00:30:51,360 --> 00:30:54,559
only a sensible subset that makes sense

00:30:53,279 --> 00:30:57,519
for a particular

00:30:54,559 --> 00:31:05,840
uh target platform like a gpu like an

00:30:57,519 --> 00:31:05,840
fpga or a tsp

00:31:06,640 --> 00:31:09,919
okay thank you um we have one more

00:31:08,799 --> 00:31:12,960
question then there's

00:31:09,919 --> 00:31:14,880
a another um little survey and then tom

00:31:12,960 --> 00:31:16,840
wants to wind up so the other question

00:31:14,880 --> 00:31:18,080
from someone who wants to remain

00:31:16,840 --> 00:31:20,159
anonymous

00:31:18,080 --> 00:31:22,320
so that they're trying to wind us up is

00:31:20,159 --> 00:31:23,279
um what's our opinion of fortran

00:31:22,320 --> 00:31:26,640
co-arrays

00:31:23,279 --> 00:31:29,679
versus using openmp

00:31:26,640 --> 00:31:31,840
and i would say that they're actually

00:31:29,679 --> 00:31:33,840
slightly different because co-arrays are

00:31:31,840 --> 00:31:36,880
a distributed memory model and

00:31:33,840 --> 00:31:39,360
openmp is not however um

00:31:36,880 --> 00:31:41,919
i'll let everyone else throw in their

00:31:39,360 --> 00:31:41,919
two cents

00:31:42,000 --> 00:31:45,760
uh so maybe maybe give me let me give

00:31:44,240 --> 00:31:47,600
you a short answer so this is

00:31:45,760 --> 00:31:49,919
this is the same question as when will

00:31:47,600 --> 00:31:53,440
openmp replace mpi

00:31:49,919 --> 00:31:56,080
um so as as jim rightfully pointed out

00:31:53,440 --> 00:31:57,120
uh fortran co-arrays are a distributed

00:31:56,080 --> 00:31:59,360
model like

00:31:57,120 --> 00:32:00,480
partitioned global address space kind of

00:31:59,360 --> 00:32:03,679
thing

00:32:00,480 --> 00:32:04,240
whereas openmp is an in node shared

00:32:03,679 --> 00:32:06,159
memory

00:32:04,240 --> 00:32:08,240
and heterogeneous programming model so

00:32:06,159 --> 00:32:11,120
it's it has a different

00:32:08,240 --> 00:32:11,600
different mode of operation and so i do

00:32:11,120 --> 00:32:14,240
see

00:32:11,600 --> 00:32:14,640
if you really in co-arrays i would see

00:32:14,240 --> 00:32:18,480
them

00:32:14,640 --> 00:32:20,240
both um implementing different concerns

00:32:18,480 --> 00:32:22,000
you can have co-arrays

00:32:20,240 --> 00:32:23,679
on the outer level of your parallelism

00:32:22,000 --> 00:32:26,000
going across your cluster

00:32:23,679 --> 00:32:28,399
and then use openmp within your

00:32:26,000 --> 00:32:30,640
individual co-array image

00:32:28,399 --> 00:32:31,840
to do multi-threading on the on the data

00:32:30,640 --> 00:32:34,080
that is hosted on that

00:32:31,840 --> 00:32:36,080
on that particular node so they kind of

00:32:34,080 --> 00:32:40,240
in my mind complement each other like

00:32:36,080 --> 00:32:40,240
mpi and openmp complement each other as

00:32:40,840 --> 00:32:43,840
well

00:32:44,640 --> 00:32:48,320
anyone else want to say anything on that

00:32:46,320 --> 00:32:49,919
or should we wind down

00:32:48,320 --> 00:32:52,080
i i think they're complimentary as well

00:32:49,919 --> 00:32:54,320
i think it's um

00:32:52,080 --> 00:32:55,279
um i've had discussions with people

00:32:54,320 --> 00:32:57,519
before you are co

00:32:55,279 --> 00:32:58,880
is co-arrays a competitor for mpi is it

00:32:57,519 --> 00:33:01,519
competitor for openmp is it

00:32:58,880 --> 00:33:02,880
it's no it's it's it's a choice you can

00:33:01,519 --> 00:33:06,240
make it is an option

00:33:02,880 --> 00:33:09,360
and um i think what what we as

00:33:06,240 --> 00:33:12,080
openmp implementers and and

00:33:09,360 --> 00:33:14,399
and specification writers what we need

00:33:12,080 --> 00:33:16,240
to do is ensure that it's well defined

00:33:14,399 --> 00:33:17,600
what our interaction is with them and

00:33:16,240 --> 00:33:19,279
then it's

00:33:17,600 --> 00:33:20,720
you know up to the user of what meets

00:33:19,279 --> 00:33:22,399
their needs better if

00:33:20,720 --> 00:33:25,840
one thing needs better than the other

00:33:22,399 --> 00:33:25,840
then great use that

00:33:29,120 --> 00:33:32,159
yeah i'd just like to add pretty much

00:33:30,720 --> 00:33:35,200
the same um

00:33:32,159 --> 00:33:36,559
if we as compiler compiler vendors hear

00:33:35,200 --> 00:33:38,720
enough

00:33:36,559 --> 00:33:40,559
feedback from the community then color

00:33:38,720 --> 00:33:43,120
raises one feature that

00:33:40,559 --> 00:33:45,519
may be added to to the compilers but at

00:33:43,120 --> 00:33:48,640
the moment as you probably know it's not

00:33:45,519 --> 00:33:50,720
supported in every compiler um with

00:33:48,640 --> 00:33:52,720
co-arrays we've got the edition as well

00:33:50,720 --> 00:33:56,399
because it's um

00:33:52,720 --> 00:33:57,200
internode and possibly uh tuning for

00:33:56,399 --> 00:33:59,840
particular

00:33:57,200 --> 00:34:01,679
interconnects may come into the um

00:33:59,840 --> 00:34:03,279
development as well so it gets more

00:34:01,679 --> 00:34:06,720
complicated than

00:34:03,279 --> 00:34:08,159
just looking at openmp optimizations and

00:34:06,720 --> 00:34:10,399
runtimes

00:34:08,159 --> 00:34:11,440
but it would be great to hear back from

00:34:10,399 --> 00:34:16,960
the community if

00:34:11,440 --> 00:34:16,960
there is a particular need for co-arrays

00:34:17,839 --> 00:34:22,399
okay i think we're out of time because

00:34:20,639 --> 00:34:23,040
there's one more question for you to

00:34:22,399 --> 00:34:26,399
answer

00:34:23,040 --> 00:34:29,520
and tom also wants to wind up the whole

00:34:26,399 --> 00:34:30,240
session so i'll just say thank you to

00:34:29,520 --> 00:34:32,960
the

00:34:30,240 --> 00:34:35,760
panelists for contributing and thank you

00:34:32,960 --> 00:34:39,679
to the audience for your questions

00:34:35,760 --> 00:34:41,679
tom over to you thanks jim thanks for a

00:34:39,679 --> 00:34:44,000
really lively and an interesting

00:34:41,679 --> 00:34:45,679
uh panel discussion um it's nice to be

00:34:44,000 --> 00:34:46,320
able to have panel discussions at these

00:34:45,679 --> 00:34:47,839
events so

00:34:46,320 --> 00:34:49,839
it's good that we're able to to bring

00:34:47,839 --> 00:34:52,000
that to this uh to zoom

00:34:49,839 --> 00:34:53,040
the zoom platform as well um i'll just

00:34:52,000 --> 00:34:55,040
leave the um

00:34:53,040 --> 00:34:57,040
the poll up just for a few more moments

00:34:55,040 --> 00:34:58,640
just for for people to

00:34:57,040 --> 00:35:01,280
finish answering it's nice to see what

00:34:58,640 --> 00:35:02,560
the community is is basing themselves

00:35:01,280 --> 00:35:04,720
around i thought it was very interesting

00:35:02,560 --> 00:35:06,960
the first poll about the the tasks most

00:35:04,720 --> 00:35:08,960
people aren't really exploring tasks yet

00:35:06,960 --> 00:35:09,440
but as jeff pointed out in his talk and

00:35:08,960 --> 00:35:12,000
and

00:35:09,440 --> 00:35:13,280
the questions maybe tasking is gonna be

00:35:12,000 --> 00:35:14,560
a critical part of

00:35:13,280 --> 00:35:17,680
of getting the most out of these

00:35:14,560 --> 00:35:20,320
heterogeneous nodes that we're seeing

00:35:17,680 --> 00:35:21,040
um so i'll end this part it's uh

00:35:20,320 --> 00:35:23,040
interesting

00:35:21,040 --> 00:35:25,440
um it seems most people are writing

00:35:23,040 --> 00:35:26,560
openmp 4.5 codes at the moment which is

00:35:25,440 --> 00:35:28,960
which is really good to see

00:35:26,560 --> 00:35:30,480
it seems like most people are are

00:35:28,960 --> 00:35:33,280
keeping up with

00:35:30,480 --> 00:35:34,880
where the current compilers are and are

00:35:33,280 --> 00:35:36,560
tromping at the bit to get the latest

00:35:34,880 --> 00:35:38,800
compilers and the latest support for

00:35:36,560 --> 00:35:41,280
openmp into their compiler suite so

00:35:38,800 --> 00:35:43,599
so hopefully that means that um we'll

00:35:41,280 --> 00:35:46,240
see 5.0 and 5.1 support

00:35:43,599 --> 00:35:46,240
very soon

00:35:48,640 --> 00:35:51,760
let me turn this spec

00:35:53,760 --> 00:35:57,599
uh so thanks to everybody for coming

00:35:55,839 --> 00:35:59,200
today and thanks to all our speakers

00:35:57,599 --> 00:36:01,359
there's lots of people that i need to

00:35:59,200 --> 00:36:03,200
thank so first of all to tim lewis the

00:36:01,359 --> 00:36:05,200
the conference organizer today

00:36:03,200 --> 00:36:06,240
uh he's been fantastic at getting

00:36:05,200 --> 00:36:07,920
everything going and

00:36:06,240 --> 00:36:09,760
looks after us as a community

00:36:07,920 --> 00:36:11,520
fantastically then there's their

00:36:09,760 --> 00:36:13,920
conference chair simon mcintosh smith

00:36:11,520 --> 00:36:15,680
and the program co-chairs mark bull and

00:36:13,920 --> 00:36:17,359
and james county who's uh was leading

00:36:15,680 --> 00:36:17,839
that panel session just now thanks of

00:36:17,359 --> 00:36:20,880
course

00:36:17,839 --> 00:36:22,560
um to you all also i'd like to uh

00:36:20,880 --> 00:36:24,480
thank the science and technology

00:36:22,560 --> 00:36:25,040
facilities council for including this

00:36:24,480 --> 00:36:27,119
event

00:36:25,040 --> 00:36:28,400
today the the openmp user group as as

00:36:27,119 --> 00:36:30,880
part of their

00:36:28,400 --> 00:36:32,960
computing insights 2020 extended program

00:36:30,880 --> 00:36:34,160
and in particular to damien jones for

00:36:32,960 --> 00:36:37,520
promoting this event

00:36:34,160 --> 00:36:40,079
within the hpc community obviously um

00:36:37,520 --> 00:36:41,839
as support from all the sponsors which

00:36:40,079 --> 00:36:44,000
i've put at the bottom of this slide

00:36:41,839 --> 00:36:45,440
um is we're very thankful for that and

00:36:44,000 --> 00:36:47,200
obviously all the speakers today so

00:36:45,440 --> 00:36:49,520
chris jonas jamil

00:36:47,200 --> 00:36:51,280
phil jeff and michael and of course jim

00:36:49,520 --> 00:36:51,920
for leading the panel session thanks um

00:36:51,280 --> 00:36:54,000
thanks

00:36:51,920 --> 00:36:56,000
uh thanks for your time and for your

00:36:54,000 --> 00:36:57,599
really interesting talks

00:36:56,000 --> 00:36:59,359
and obviously thanks to everybody for

00:36:57,599 --> 00:37:00,880
for joining us today and hopefully you

00:36:59,359 --> 00:37:02,400
found it really interesting i've had a

00:37:00,880 --> 00:37:04,240
brilliant afternoon

00:37:02,400 --> 00:37:05,680
and it's been great to hear um all the

00:37:04,240 --> 00:37:07,839
talks um

00:37:05,680 --> 00:37:09,520
keep in touch use the use twitter and

00:37:07,839 --> 00:37:11,599
use the website for for

00:37:09,520 --> 00:37:13,200
taking part in this community and most

00:37:11,599 --> 00:37:15,200
of the links are also available on the

00:37:13,200 --> 00:37:15,760
openmp website and there's links to

00:37:15,200 --> 00:37:18,400
forums

00:37:15,760 --> 00:37:19,040
and and other ways to interact with the

00:37:18,400 --> 00:37:22,960
openmk

00:37:19,040 --> 00:37:24,240
openmp community there

00:37:22,960 --> 00:37:26,000
just a couple of housekeeping things

00:37:24,240 --> 00:37:27,599
before we finish um

00:37:26,000 --> 00:37:29,599
recordings are going to be made

00:37:27,599 --> 00:37:31,599
available to all the attendees soon

00:37:29,599 --> 00:37:33,200
and look out for those next week for

00:37:31,599 --> 00:37:35,119
those of you that attended the tutorial

00:37:33,200 --> 00:37:35,839
yesterday or couldn't all the materials

00:37:35,119 --> 00:37:38,880
are available

00:37:35,839 --> 00:37:41,839
online and we covered a lot of openmp

00:37:38,880 --> 00:37:43,280
4.5 and some of five yesterday so if

00:37:41,839 --> 00:37:44,560
you're interested in looking at that

00:37:43,280 --> 00:37:46,560
that's available there

00:37:44,560 --> 00:37:48,320
and watch out in your emails as well for

00:37:46,560 --> 00:37:48,960
a feedback survey be really lovely to

00:37:48,320 --> 00:37:51,280
hear what

00:37:48,960 --> 00:37:53,680
what you all thought so thanks everybody

00:37:51,280 --> 00:37:55,839
for coming i'll i'll close the afternoon

00:37:53,680 --> 00:37:57,119
uh there we'll leave the zoom running

00:37:55,839 --> 00:37:59,040
for just a few more moments

00:37:57,119 --> 00:38:00,640
um but thanks everybody for joining and

00:37:59,040 --> 00:38:03,359
hopefully we'll we'll see you all

00:38:00,640 --> 00:38:04,400
at the next event which is going to be

00:38:03,359 --> 00:38:07,440
in bristol

00:38:04,400 --> 00:38:12,079
around september time in 2021

00:38:07,440 --> 00:38:12,079

YouTube URL: https://www.youtube.com/watch?v=pzY_c1Lm1oE


