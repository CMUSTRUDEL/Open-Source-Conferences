Title: OpenMP 4.0 -- Paradigm Shift in Parallel Computing - SC14
Publication date: 2014-12-13
Playlist: SC14 OpenMP BOF and Booth Talks
Description: 
	Michael Wong (IBM Canada and CEO of OpenMP ARB), presented at Supercomputing 14, November 2014.
Captions: 
	00:00:00,000 --> 00:00:04,200
is not hear my name is Michael Wong I'm

00:00:01,589 --> 00:00:06,029
the CEO of OpenMP so some of you guys

00:00:04,200 --> 00:00:08,179
may may not know me I've given talks on

00:00:06,029 --> 00:00:10,469
this subject before i'm going to have

00:00:08,179 --> 00:00:12,150
Jim County come in and talk with me

00:00:10,469 --> 00:00:14,700
about this because what I want to talk

00:00:12,150 --> 00:00:16,740
about today is the vector programming

00:00:14,700 --> 00:00:19,949
the vector programming model from in

00:00:16,740 --> 00:00:21,750
OpenMP so for that I'm going to skip

00:00:19,949 --> 00:00:23,880
past much of this talk because much of

00:00:21,750 --> 00:00:27,930
this talk with you've been at ACC you in

00:00:23,880 --> 00:00:29,990
bristol ok so

00:00:27,930 --> 00:00:36,870
and get to the part that talks about

00:00:29,990 --> 00:00:39,030
vector vector programming all right it's

00:00:36,870 --> 00:00:40,200
probably available on a cc you actually

00:00:39,030 --> 00:00:42,480
it talks about a lot of different things

00:00:40,200 --> 00:00:44,790
about accelerators as well as the

00:00:42,480 --> 00:00:47,309
affinity models and things like that so

00:00:44,790 --> 00:01:00,239
I wanted to focus for now on the vector

00:00:47,309 --> 00:01:03,470
model thank you alright alright so now

00:01:00,239 --> 00:01:03,470
we're stepping through the affinities

00:01:03,649 --> 00:01:10,380
all rights mdl language extensions all

00:01:06,600 --> 00:01:12,880
right I don't know what was done for

00:01:10,380 --> 00:01:15,490
yesterday okay

00:01:12,880 --> 00:01:17,079
alright so so let me just start right

00:01:15,490 --> 00:01:19,899
away until in terms of the committee

00:01:17,079 --> 00:01:21,310
it's led by shin min who we were trying

00:01:19,899 --> 00:01:22,869
to get here their whole bunch of other

00:01:21,310 --> 00:01:25,570
people involved from various different

00:01:22,869 --> 00:01:28,659
company much of a vector proposal came

00:01:25,570 --> 00:01:30,700
from the Intel the Intel what entire

00:01:28,659 --> 00:01:32,740
even have had in their compiler for

00:01:30,700 --> 00:01:33,939
quite some time now but other people

00:01:32,740 --> 00:01:35,710
that's been involved as you can see the

00:01:33,939 --> 00:01:40,329
broad base of different companies which

00:01:35,710 --> 00:01:41,560
in Oracle IBM BSC and okay so i just

00:01:40,329 --> 00:01:42,880
wanted to share that just to make sure

00:01:41,560 --> 00:01:44,590
that I give credit for these slides

00:01:42,880 --> 00:01:46,840
because they're not actually my slides

00:01:44,590 --> 00:01:51,729
so one of the thing that you're going to

00:01:46,840 --> 00:01:55,509
find is what's the problem with simdi

00:01:51,729 --> 00:01:58,270
language extensions okay it seems pretty

00:01:55,509 --> 00:02:00,369
clear that simdi registers with has been

00:01:58,270 --> 00:02:03,580
steadily increasing and in fact they're

00:02:00,369 --> 00:02:04,899
verging on 1024 fairly soon the

00:02:03,580 --> 00:02:07,420
instructions are getting certainly more

00:02:04,899 --> 00:02:09,009
powerful and more complex it's harder

00:02:07,420 --> 00:02:10,239
it's becoming much more difficult for

00:02:09,009 --> 00:02:13,030
compiler to select the right

00:02:10,239 --> 00:02:15,150
instructions and the co pattern that has

00:02:13,030 --> 00:02:17,109
to be recognized by the compiler is

00:02:15,150 --> 00:02:19,569
increasingly becoming more difficult to

00:02:17,109 --> 00:02:22,900
precision requirements are essentially

00:02:19,569 --> 00:02:26,200
inhibit simdi cogeneration ultimately

00:02:22,900 --> 00:02:29,799
what I'm what I'm noticing is this and I

00:02:26,200 --> 00:02:33,400
work in them sorry I'm just trying to

00:02:29,799 --> 00:02:35,889
remember okay and I work in compiler

00:02:33,400 --> 00:02:37,810
compilers wonder the great hope of

00:02:35,889 --> 00:02:41,010
compiler churko generation of course is

00:02:37,810 --> 00:02:44,730
auto vectorization that great hope is

00:02:41,010 --> 00:02:44,730
almost is nearly

00:02:48,050 --> 00:02:52,490
is nearly over because it's we're

00:02:50,570 --> 00:02:55,190
finding that it's very difficult for

00:02:52,490 --> 00:02:57,760
most code bases to auto vectorize I

00:02:55,190 --> 00:03:00,230
remember when I used to work on the cell

00:02:57,760 --> 00:03:02,330
seventy percent of the time we spend was

00:03:00,230 --> 00:03:03,860
actually of it was and that was the

00:03:02,330 --> 00:03:07,130
previous generation of accelerated

00:03:03,860 --> 00:03:09,340
processor to actually back to write the

00:03:07,130 --> 00:03:09,340
instructions

00:03:10,840 --> 00:03:14,019
and certainly these are some of the

00:03:12,550 --> 00:03:15,400
reasons as to why we think auto

00:03:14,019 --> 00:03:18,069
vectorization is going to have

00:03:15,400 --> 00:03:20,019
difficulty all of this essentially and

00:03:18,069 --> 00:03:21,310
then there are other difficulties what

00:03:20,019 --> 00:03:22,930
so that what sort of loops can be

00:03:21,310 --> 00:03:25,000
vectorized it turns out it's actually

00:03:22,930 --> 00:03:27,220
fairly complex these loops has to be

00:03:25,000 --> 00:03:30,040
countable they have to be single exit

00:03:27,220 --> 00:03:31,799
single entry straight line code I mean

00:03:30,040 --> 00:03:34,239
any even if statements in there is

00:03:31,799 --> 00:03:36,340
problematic everything else they call

00:03:34,239 --> 00:03:38,890
have to be vectorize about potentially

00:03:36,340 --> 00:03:41,410
you know there's certain it can only

00:03:38,890 --> 00:03:43,750
address to non contiguous memory

00:03:41,410 --> 00:03:45,459
addresses alignment difficulties and

00:03:43,750 --> 00:03:47,380
things like that this is just listening

00:03:45,459 --> 00:03:49,720
some of the fundamental difficulty of

00:03:47,380 --> 00:03:52,030
auto vectorization never never mind you

00:03:49,720 --> 00:03:54,459
trying to vectorize it so i think all of

00:03:52,030 --> 00:03:56,670
these is what's essentially driving the

00:03:54,459 --> 00:04:00,849
need for the industry to call for a

00:03:56,670 --> 00:04:03,519
better language support for simdi

00:04:00,849 --> 00:04:06,190
support and this is where we wanted to

00:04:03,519 --> 00:04:08,349
standardize a much of a high level way

00:04:06,190 --> 00:04:10,239
of describing Cindy instead you having

00:04:08,349 --> 00:04:11,799
to always converted depending on what a

00:04:10,239 --> 00:04:14,230
local platform happens to be whether

00:04:11,799 --> 00:04:16,989
it's it's SS you know whether it's SSE

00:04:14,230 --> 00:04:19,930
whether it's a you know IBM's version is

00:04:16,989 --> 00:04:21,940
vm x v QX and the 20 possible variants

00:04:19,930 --> 00:04:23,979
that they've has a high level language

00:04:21,940 --> 00:04:26,320
support gives you that ability gives the

00:04:23,979 --> 00:04:30,340
compiler better opportunity to optimize

00:04:26,320 --> 00:04:31,690
it ok so that's why openmp has taken the

00:04:30,340 --> 00:04:34,450
lead and probably one of the probably

00:04:31,690 --> 00:04:38,470
the industry's first high-level sector

00:04:34,450 --> 00:04:40,030
language support ok and this is what I'm

00:04:38,470 --> 00:04:42,610
just show you quickly a little bit of

00:04:40,030 --> 00:04:47,440
syntax here you familiar with most of

00:04:42,610 --> 00:04:51,370
this right ok ok sorry I'm gonna have

00:04:47,440 --> 00:04:54,789
Jim come in my name is first ok you have

00:04:51,370 --> 00:04:58,979
a mic oh I can just shout but you'll

00:04:54,789 --> 00:05:02,880
record it so as long as you don't ever

00:04:58,979 --> 00:05:02,880
give why Kate somewhere

00:05:03,360 --> 00:05:10,620
that's it that's okay okay so a few

00:05:08,909 --> 00:05:13,889
disclaimers up front I haven't seen

00:05:10,620 --> 00:05:16,439
these slides I'm normally responsible

00:05:13,889 --> 00:05:18,689
for the runtime part of openmp so I'm

00:05:16,439 --> 00:05:22,469
the architect for our four hour runtime

00:05:18,689 --> 00:05:24,840
which is also now the llvm run time so

00:05:22,469 --> 00:05:28,469
it's open sourced under bsd license you

00:05:24,840 --> 00:05:30,960
can get it so mostly I ignore the simdi

00:05:28,469 --> 00:05:34,229
stuff because the compiler does all that

00:05:30,960 --> 00:05:36,090
and I don't have to worry however since

00:05:34,229 --> 00:05:40,020
i'm here in the presenter it wasn't here

00:05:36,090 --> 00:05:42,270
who knows me at least one beer and he's

00:05:40,020 --> 00:05:46,860
from Intel too I will attempt to give

00:05:42,270 --> 00:05:48,659
these slides so as Michael said we have

00:05:46,860 --> 00:05:51,270
a big problem which is that all of these

00:05:48,659 --> 00:05:54,840
machines have these vector operations

00:05:51,270 --> 00:05:57,210
and the compilers aren't smart enough to

00:05:54,840 --> 00:06:01,229
well sorry I get told off by the

00:05:57,210 --> 00:06:03,750
compiler guys when I say that it is in

00:06:01,229 --> 00:06:06,750
many cases impossible for the compiler

00:06:03,750 --> 00:06:09,089
to deduce that it can vectorize a

00:06:06,750 --> 00:06:11,159
particular loop without being given a

00:06:09,089 --> 00:06:14,849
lot more information from the user about

00:06:11,159 --> 00:06:17,520
how the code is really being used so in

00:06:14,849 --> 00:06:19,589
see the classic examples are where you

00:06:17,520 --> 00:06:22,110
have two pointer arguments into a

00:06:19,589 --> 00:06:23,909
function and they may alias within the

00:06:22,110 --> 00:06:26,069
within the function the compiler has to

00:06:23,909 --> 00:06:27,690
assume that that function would be

00:06:26,069 --> 00:06:30,930
called in a way where they could alias

00:06:27,690 --> 00:06:32,909
unless you as the author of the code

00:06:30,930 --> 00:06:35,400
have told them more by putting restrict

00:06:32,909 --> 00:06:38,099
on the on on the front on the pointer

00:06:35,400 --> 00:06:40,080
arguments there are other cases where

00:06:38,099 --> 00:06:44,610
the compiler needs similar information

00:06:40,080 --> 00:06:48,050
and that's what these these directives

00:06:44,610 --> 00:06:50,610
are they are statements to the compiler

00:06:48,050 --> 00:06:53,219
too so that you give it much more

00:06:50,610 --> 00:06:55,409
information which you knew but the

00:06:53,219 --> 00:06:59,189
compiler can't deduce and which it needs

00:06:55,409 --> 00:07:03,229
to ensure that it can vectorize the

00:06:59,189 --> 00:07:08,009
operation they're also quite strong

00:07:03,229 --> 00:07:10,439
statements in as much as often the

00:07:08,009 --> 00:07:12,779
compiler even if it can deduce that it

00:07:10,439 --> 00:07:14,250
could vectorize something may not have

00:07:12,779 --> 00:07:16,620
enough knowledge to know whether that

00:07:14,250 --> 00:07:17,129
was actually worthwhile so it may have

00:07:16,620 --> 00:07:19,860
to general

00:07:17,129 --> 00:07:22,349
so for instance you have a function with

00:07:19,860 --> 00:07:24,029
a vector and a length if the compiler

00:07:22,349 --> 00:07:27,300
doesn't know that the length is always

00:07:24,029 --> 00:07:29,309
greater than a milli a thousand say it

00:07:27,300 --> 00:07:31,559
may decide that it's easier just to

00:07:29,309 --> 00:07:33,409
generate scalar code because the cost of

00:07:31,559 --> 00:07:35,550
setting up the vectors and in particular

00:07:33,409 --> 00:07:37,169
getting short making sure that their

00:07:35,550 --> 00:07:39,209
things are correctly aligned because

00:07:37,169 --> 00:07:42,059
many of these vector instructions only

00:07:39,209 --> 00:07:44,759
work on a line data there's a large cost

00:07:42,059 --> 00:07:46,199
in entering a vector loop before you get

00:07:44,759 --> 00:07:48,149
to the point where you actually get the

00:07:46,199 --> 00:07:50,939
benefit of the vector operations and

00:07:48,149 --> 00:07:53,819
therefore passing more information into

00:07:50,939 --> 00:07:56,039
the into the subroutines to say this

00:07:53,819 --> 00:07:57,779
this this isn't going to be a nice long

00:07:56,039 --> 00:07:59,939
vector or these arguments are well

00:07:57,779 --> 00:08:05,369
aligned gives the compiler much more

00:07:59,939 --> 00:08:07,740
information so what these simdi things

00:08:05,369 --> 00:08:10,259
do is they partially override some of

00:08:07,740 --> 00:08:12,360
the compilers sanity checks where it

00:08:10,259 --> 00:08:13,829
might have decided well I could

00:08:12,360 --> 00:08:16,379
vectorize this but I really don't think

00:08:13,829 --> 00:08:19,169
it's worthwhile when you put on simdi on

00:08:16,379 --> 00:08:20,699
it you're saying hey actually believe me

00:08:19,169 --> 00:08:24,419
I wrote this code this is going to be

00:08:20,699 --> 00:08:26,639
worthwhile or at least let me try this

00:08:24,419 --> 00:08:28,409
to see if it's worthwhile and don't stop

00:08:26,639 --> 00:08:30,959
me trying it because you don't think

00:08:28,409 --> 00:08:34,019
it's worthwhile so they're they're quite

00:08:30,959 --> 00:08:35,579
strong they're not just they're not just

00:08:34,019 --> 00:08:37,139
hints they're saying do this I'm

00:08:35,579 --> 00:08:40,229
asserting the correctness of your

00:08:37,139 --> 00:08:42,630
ability to do this therefore they can

00:08:40,229 --> 00:08:45,329
break your code if you put these in and

00:08:42,630 --> 00:08:46,709
the code doesn't obey the the statements

00:08:45,329 --> 00:08:48,389
that you've made about it so for

00:08:46,709 --> 00:08:50,970
instance you say on one of the arguments

00:08:48,389 --> 00:08:52,889
it's aligned and then it turns out that

00:08:50,970 --> 00:08:55,110
it wasn't you'll get a segmentation

00:08:52,889 --> 00:08:58,860
violation when you run the code well

00:08:55,110 --> 00:09:00,360
fine you know we're doing this in NC see

00:08:58,860 --> 00:09:02,790
is a language where you shoot your foot

00:09:00,360 --> 00:09:08,850
off it's that's what it's for that the

00:09:02,790 --> 00:09:12,060
safety catches are off so a lot of

00:09:08,850 --> 00:09:15,110
operations that describe a lot of causes

00:09:12,060 --> 00:09:17,850
that describe how data is is is shared

00:09:15,110 --> 00:09:19,170
how to bring it into the conceptual

00:09:17,850 --> 00:09:23,519
vector lanes that are going to be

00:09:19,170 --> 00:09:26,100
operating on the loop as i said i'm not

00:09:23,519 --> 00:09:29,730
an expert on all of these but here we

00:09:26,100 --> 00:09:30,720
can see the aligned the linear the safe

00:09:29,730 --> 00:09:34,829
line that says

00:09:30,720 --> 00:09:36,389
I because we're vectorizing it there are

00:09:34,829 --> 00:09:38,370
there's a bit more restrictions that we

00:09:36,389 --> 00:09:40,259
can now in the parallel ISM if we say

00:09:38,370 --> 00:09:42,480
that a loop is parallel we're allowing

00:09:40,259 --> 00:09:46,620
any possible sequence of iterations to

00:09:42,480 --> 00:09:48,209
be two to occur so it could execute all

00:09:46,620 --> 00:09:50,220
of the even ones then all of the odd

00:09:48,209 --> 00:09:52,290
ones or could execute from the far end

00:09:50,220 --> 00:09:55,680
or it could do anything with the

00:09:52,290 --> 00:09:58,439
vectorization they were saying that

00:09:55,680 --> 00:10:01,170
there are some cases where they can be a

00:09:58,439 --> 00:10:03,839
feedback and we're moving up the thing

00:10:01,170 --> 00:10:05,819
but the feedback is is is it a

00:10:03,839 --> 00:10:07,230
sufficient length that we know that we

00:10:05,819 --> 00:10:09,209
can vectorize up to this length whereas

00:10:07,230 --> 00:10:10,829
if we went further then we would be

00:10:09,209 --> 00:10:16,670
loading data that we should have up Red

00:10:10,829 --> 00:10:16,670
Alert an updated version of we can

00:10:16,790 --> 00:10:24,839
parallel eyes and we so here we're all

00:10:22,110 --> 00:10:26,519
right so this is a case oh this is just

00:10:24,839 --> 00:10:28,740
a sindhi loop you're right so this is a

00:10:26,519 --> 00:10:30,420
sindhi loop oh this is parallelize ain't

00:10:28,740 --> 00:10:31,800
vectorize yeah okay so in the one

00:10:30,420 --> 00:10:33,750
directive if we can say this is a

00:10:31,800 --> 00:10:37,139
parallel loop and it's also a sindhi

00:10:33,750 --> 00:10:39,689
loop so we want to chunk it into into

00:10:37,139 --> 00:10:42,750
into simdi width pieces and then chunk

00:10:39,689 --> 00:10:45,569
goes out in parallel other similes

00:10:42,750 --> 00:10:48,170
similes now how it was paralyzing across

00:10:45,569 --> 00:10:48,170
different threats

00:10:48,209 --> 00:10:52,029
across different threads and then it

00:10:50,559 --> 00:10:56,649
divides a vector and then gives you the

00:10:52,029 --> 00:10:57,939
vectorization after that okay ah and

00:10:56,649 --> 00:10:59,410
then now we have to send e function

00:10:57,939 --> 00:11:01,420
there are certain functions you might

00:10:59,410 --> 00:11:05,860
actually want to actually generate

00:11:01,420 --> 00:11:07,660
vector code for right so that so the

00:11:05,860 --> 00:11:09,610
point here is that normally if you could

00:11:07,660 --> 00:11:12,040
if you make a function call inside your

00:11:09,610 --> 00:11:15,819
subroutine inside your vector loop sorry

00:11:12,040 --> 00:11:18,189
then because of this standard unless you

00:11:15,819 --> 00:11:20,199
can inline it because of the standard

00:11:18,189 --> 00:11:22,209
calling conventions the compiler has to

00:11:20,199 --> 00:11:24,040
it's got all this nice data sitting in a

00:11:22,209 --> 00:11:26,019
simply vector register but it has to

00:11:24,040 --> 00:11:28,929
push it out into store so that then it

00:11:26,019 --> 00:11:30,100
can pass it or even work inter store and

00:11:28,929 --> 00:11:32,110
then move it into integer registers

00:11:30,100 --> 00:11:34,779
because that's how the function calling

00:11:32,110 --> 00:11:37,689
convention works that's clearly very

00:11:34,779 --> 00:11:40,689
costly and so instead of back to allow

00:11:37,689 --> 00:11:42,220
allow the compiler to in effect cheat on

00:11:40,689 --> 00:11:43,989
the vector on the calling conventions

00:11:42,220 --> 00:11:45,879
there are some new vector calling

00:11:43,989 --> 00:11:47,709
conventions that allow the compiler to

00:11:45,879 --> 00:11:50,290
pass arguments into the subroutine in

00:11:47,709 --> 00:11:52,629
vector registers so it doesn't have to

00:11:50,290 --> 00:11:53,920
spill them out to store and pass them

00:11:52,629 --> 00:11:56,589
through integer registers or pass

00:11:53,920 --> 00:11:58,740
pointers to them and that's what this

00:11:56,589 --> 00:12:01,660
declares cindy on the on the function

00:11:58,740 --> 00:12:04,240
says this is a this is a function that I

00:12:01,660 --> 00:12:05,740
want you to generate a version so we're

00:12:04,240 --> 00:12:07,509
going to generate multiple versions of

00:12:05,740 --> 00:12:09,189
this we're going to generate a version

00:12:07,509 --> 00:12:11,319
that takes vector arguments so they can

00:12:09,189 --> 00:12:16,839
be in simdi registers and therefore

00:12:11,319 --> 00:12:21,149
improve the performance these are

00:12:16,839 --> 00:12:21,149
similar or they not Michael yes right

00:12:21,920 --> 00:12:26,269
it's not in lining if it in line then it

00:12:24,620 --> 00:12:27,800
would be fine already because it doesn't

00:12:26,269 --> 00:12:29,480
need to it doesn't need to know this

00:12:27,800 --> 00:12:31,339
this could be a function there had been

00:12:29,480 --> 00:12:33,440
compiled in a separately loaded library

00:12:31,339 --> 00:12:35,690
right even so you didn't even know

00:12:33,440 --> 00:12:37,730
anything about it but the normal calling

00:12:35,690 --> 00:12:39,230
conventions the standard ABI application

00:12:37,730 --> 00:12:42,560
binary interface calling conventions for

00:12:39,230 --> 00:12:44,660
all of these machines don't allow you to

00:12:42,560 --> 00:12:47,540
pass registers in arguments in simdi

00:12:44,660 --> 00:12:49,070
registers right so if you had data in a

00:12:47,540 --> 00:12:50,899
simply register that you want to pass to

00:12:49,070 --> 00:12:53,899
a subroutine through the standard ABI

00:12:50,899 --> 00:12:55,699
you have to store it into memory right

00:12:53,899 --> 00:12:57,889
admittedly it'll end up in the cache but

00:12:55,699 --> 00:12:59,540
goes into memory and then either you

00:12:57,889 --> 00:13:01,220
pass a pointer to it in the subroutine

00:12:59,540 --> 00:13:02,779
or you load it even in some cases into

00:13:01,220 --> 00:13:05,149
integer registers to pass it to the

00:13:02,779 --> 00:13:06,920
subroutine going to x87 floating

00:13:05,149 --> 00:13:11,360
registers or some not on michael's

00:13:06,920 --> 00:13:13,250
machines ah some horrible way so you had

00:13:11,360 --> 00:13:14,810
data right up near the process of

00:13:13,250 --> 00:13:17,149
innovative registers you just wanted to

00:13:14,810 --> 00:13:19,070
do some small number of operations on it

00:13:17,149 --> 00:13:20,540
you don't know what they are at the time

00:13:19,070 --> 00:13:22,160
you're generating the outer vector loop

00:13:20,540 --> 00:13:24,410
though they're in a subroutine that you

00:13:22,160 --> 00:13:26,360
may not have seen the content of so this

00:13:24,410 --> 00:13:29,300
allows you to use a different set of

00:13:26,360 --> 00:13:30,800
calling conventions that that so it's

00:13:29,300 --> 00:13:32,300
not in lining because in lining there

00:13:30,800 --> 00:13:33,620
wouldn't be a call at all there wouldn't

00:13:32,300 --> 00:13:35,750
be a new stack frame he wouldn't have

00:13:33,620 --> 00:13:37,459
branched off to to the other library

00:13:35,750 --> 00:13:39,550
wherever it happens to be in store the

00:13:37,459 --> 00:13:44,079
compiler would have done the whole thing

00:13:39,550 --> 00:13:44,079
so it is different yeah

00:13:49,470 --> 00:13:54,830
ok so this I'm really not familiar with

00:13:52,890 --> 00:13:57,830
but I guess that it's to do with masking

00:13:54,830 --> 00:13:57,830
ok

00:13:58,710 --> 00:14:02,600
that's basically it covers all the

00:14:04,810 --> 00:14:07,830
any questions

00:14:08,189 --> 00:14:11,879
hardware guy have the news

00:14:16,920 --> 00:14:24,610
well what would hardware guys need to do

00:14:19,780 --> 00:14:26,800
to you know kind of support this on the

00:14:24,610 --> 00:14:28,210
hardware level so the question is what

00:14:26,800 --> 00:14:31,000
would hardware guys have to do to

00:14:28,210 --> 00:14:32,710
support this on the hardware I don't

00:14:31,000 --> 00:14:34,150
think that the hardware guys need to do

00:14:32,710 --> 00:14:36,790
anything more than they've already done

00:14:34,150 --> 00:14:39,780
they've given us this some interesting

00:14:36,790 --> 00:14:42,580
instruction set with wide vectors and

00:14:39,780 --> 00:14:44,500
this is in the sense of that was someone

00:14:42,580 --> 00:14:47,850
asked you how was your dessert and you

00:14:44,500 --> 00:14:52,780
answer well it was very interesting

00:14:47,850 --> 00:14:55,690
which means I don't didn't like it much

00:14:52,780 --> 00:14:57,400
but I'm not prepared to say so like we

00:14:55,690 --> 00:15:01,300
have these interesting instruction sets

00:14:57,400 --> 00:15:04,840
and we now are trying to generate a

00:15:01,300 --> 00:15:08,290
language that can program them if you

00:15:04,840 --> 00:15:10,270
look it's a it only realized this

00:15:08,290 --> 00:15:11,800
recently and it once I realized that it

00:15:10,270 --> 00:15:13,810
wasn't at all surprising and I should

00:15:11,800 --> 00:15:16,600
have realized it long ago but we write

00:15:13,810 --> 00:15:20,320
languages that target the machines we

00:15:16,600 --> 00:15:22,810
have right certainly in hpc we're not

00:15:20,320 --> 00:15:24,990
being very abstract we don't go off and

00:15:22,810 --> 00:15:27,730
say hi you know I really like

00:15:24,990 --> 00:15:31,750
applicative languages pure languages

00:15:27,730 --> 00:15:33,970
whatever we go what hardware did you

00:15:31,750 --> 00:15:37,210
give me well I better make it possible

00:15:33,970 --> 00:15:40,480
to for people to use that right so you

00:15:37,210 --> 00:15:42,190
know we have MPI because we ran out of

00:15:40,480 --> 00:15:44,080
being able to build faster processors

00:15:42,190 --> 00:15:47,470
faster nodes and it's sort of obvious

00:15:44,080 --> 00:15:49,210
that you run out of you know you run out

00:15:47,470 --> 00:15:51,100
of time before you run out of money so

00:15:49,210 --> 00:15:52,960
it's if you're going to build the

00:15:51,100 --> 00:15:54,970
fastest computer in the world you spend

00:15:52,960 --> 00:15:56,830
a load of money on the fastest node you

00:15:54,970 --> 00:15:58,240
can but you still got money left so you

00:15:56,830 --> 00:15:59,800
buy two or three of them or four of them

00:15:58,240 --> 00:16:01,990
a thousand of them a hundred thousand of

00:15:59,800 --> 00:16:03,550
them you connect them together and then

00:16:01,990 --> 00:16:06,850
you need to program that and we have MPI

00:16:03,550 --> 00:16:08,200
to do that but mpi arose because those

00:16:06,850 --> 00:16:10,510
were the machines that were being built

00:16:08,200 --> 00:16:13,030
it was in the case of we sat down and

00:16:10,510 --> 00:16:14,950
did MPI i was on the MPI one standard

00:16:13,030 --> 00:16:16,540
committee we didn't sit down and do MPI

00:16:14,950 --> 00:16:18,850
because we thought that's a great

00:16:16,540 --> 00:16:20,770
programming model we did it because

00:16:18,850 --> 00:16:23,230
that's what the machines are like and

00:16:20,770 --> 00:16:25,420
similarly here we're catching up with

00:16:23,230 --> 00:16:27,279
the way that the hard way already is so

00:16:25,420 --> 00:16:29,319
it's another case of wanting different

00:16:27,279 --> 00:16:31,149
hardware it's a case of catching up

00:16:29,319 --> 00:16:34,360
letting you program the hard way you

00:16:31,149 --> 00:16:35,709
already bought that okay so another way

00:16:34,360 --> 00:16:37,540
to think about it is I think the

00:16:35,709 --> 00:16:38,680
compiler to compile oh whatever

00:16:37,540 --> 00:16:40,749
particular Harbor is going to generate

00:16:38,680 --> 00:16:41,880
specific instructions as can be ideal

00:16:40,749 --> 00:16:43,990
for that

00:16:41,880 --> 00:16:46,410
for that particle at home

00:16:43,990 --> 00:16:50,170
my question

00:16:46,410 --> 00:16:52,270
you hundreds of impressions the

00:16:50,170 --> 00:16:54,970
comparability look I might be able to

00:16:52,270 --> 00:16:57,130
use though yeah so okay so I'll answer

00:16:54,970 --> 00:17:00,220
that because you are stay VX so the

00:16:57,130 --> 00:17:02,770
question was AV ax has a very large

00:17:00,220 --> 00:17:05,770
number of instructions can the compiler

00:17:02,770 --> 00:17:07,390
actually use them all and my answer to

00:17:05,770 --> 00:17:09,910
that is that one of the reasons that a

00:17:07,390 --> 00:17:13,060
VX has so many instructions is precisely

00:17:09,910 --> 00:17:15,730
to enable the compiler to work the thing

00:17:13,060 --> 00:17:17,500
that compilers find really hard is where

00:17:15,730 --> 00:17:19,990
you have something that you would expect

00:17:17,500 --> 00:17:22,390
to be a full matrix you know this

00:17:19,990 --> 00:17:24,880
operand that operand filled in nicely

00:17:22,390 --> 00:17:26,470
then it's easy right register memory

00:17:24,880 --> 00:17:29,170
whatever register register register

00:17:26,470 --> 00:17:30,760
that's easy if it's filled in the cases

00:17:29,170 --> 00:17:32,860
that are hard for the compiler or where

00:17:30,760 --> 00:17:34,030
there are some bits missing right so you

00:17:32,860 --> 00:17:35,500
start trying to generate that

00:17:34,030 --> 00:17:37,450
instruction you suddenly find that one

00:17:35,500 --> 00:17:39,610
of the operands is in a register when

00:17:37,450 --> 00:17:41,080
you needed it in memory and now you have

00:17:39,610 --> 00:17:43,840
to generate some different instruction

00:17:41,080 --> 00:17:46,390
so I admit I was shocked I went when

00:17:43,840 --> 00:17:48,310
they when some of the fused multiply had

00:17:46,390 --> 00:17:50,320
instructions were announced and I rent a

00:17:48,310 --> 00:17:52,030
microprocessor report thing this shows

00:17:50,320 --> 00:17:53,500
you how Intel works I found out more

00:17:52,030 --> 00:17:55,690
about our new instruction set from

00:17:53,500 --> 00:17:57,820
microprocessor report then I'd known

00:17:55,690 --> 00:18:01,240
beforehand and it says you know there

00:17:57,820 --> 00:18:04,510
are 327 new instructions for something

00:18:01,240 --> 00:18:06,250
and then there are 249 different views

00:18:04,510 --> 00:18:09,400
multiply out instructions whatever it

00:18:06,250 --> 00:18:12,040
was and you think why do you need 249

00:18:09,400 --> 00:18:14,260
fees I'm sure 249 s wrong but yeah and

00:18:12,040 --> 00:18:16,000
then you think well ok so if you

00:18:14,260 --> 00:18:17,620
multiply out is really a for operand

00:18:16,000 --> 00:18:20,290
instruction to accept our instruction

00:18:17,620 --> 00:18:23,050
set encodes 3 operand instructions so

00:18:20,290 --> 00:18:24,940
that gives you an issue of you know

00:18:23,050 --> 00:18:28,050
which which of the operands is destroyed

00:18:24,940 --> 00:18:30,850
right then you've got add and subtract

00:18:28,050 --> 00:18:32,500
right and you multiply out all of these

00:18:30,850 --> 00:18:33,910
possibilities along with addressing

00:18:32,500 --> 00:18:36,010
modes and so on and you get this huge

00:18:33,910 --> 00:18:38,950
number of instructions but really

00:18:36,010 --> 00:18:42,940
conceptually it's just fuse multiply add

00:18:38,950 --> 00:18:46,060
or subtract on every possibility of

00:18:42,940 --> 00:18:47,770
where things are living and so on so the

00:18:46,060 --> 00:18:49,690
mug the huge numbers of instructions

00:18:47,770 --> 00:18:51,580
aren't the complexity for the compiler

00:18:49,690 --> 00:18:52,990
its way you have a huge number of

00:18:51,580 --> 00:18:54,610
instructions but I'm missing a few

00:18:52,990 --> 00:18:57,330
critical ones that cause the compiler

00:18:54,610 --> 00:18:57,330

YouTube URL: https://www.youtube.com/watch?v=MWdhdE7phzQ


