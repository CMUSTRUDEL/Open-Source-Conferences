Title: Integrating OpenMP into Clang on the IBM BG Q â€“ SC14
Publication date: 2014-12-13
Playlist: SC14 OpenMP BOF and Booth Talks
Description: 
	Presented by Hal Finkel, ANL at SC14, November 18, 2014.
Captions: 
	00:00:00,000 --> 00:00:04,830
alright so thank you very much for

00:00:02,639 --> 00:00:06,440
coming though I name is he'll think oh

00:00:04,830 --> 00:00:08,429
I'm from Argonne National Laboratory and

00:00:06,440 --> 00:00:12,480
I'm going to talk to you for a few

00:00:08,429 --> 00:00:15,750
minutes about our integration of OpenMP

00:00:12,480 --> 00:00:18,270
into lv m and clang for the IBM blue

00:00:15,750 --> 00:00:22,650
jean q supercomputer that we have as at

00:00:18,270 --> 00:00:27,930
Argonne it's packaged into a product

00:00:22,650 --> 00:00:32,599
that we call BG clang and so say a

00:00:27,930 --> 00:00:32,599
little bit about that the others work

00:00:33,190 --> 00:00:41,180
okay well we scroll good and all right

00:00:40,100 --> 00:00:43,040
so I'm just going to say a little bit

00:00:41,180 --> 00:00:46,790
how this how this fits in and what it

00:00:43,040 --> 00:00:48,260
involves so this is this is our BG

00:00:46,790 --> 00:00:50,090
client distribution which is how we

00:00:48,260 --> 00:00:53,270
package lvm and clang on the blue jean

00:00:50,090 --> 00:00:55,129
it it consists of not only lvm and

00:00:53,270 --> 00:00:57,830
clanging itself but also a bunch of

00:00:55,129 --> 00:00:59,780
other pieces you know sanitizers and C++

00:00:57,830 --> 00:01:02,360
standard libraries and vector math

00:00:59,780 --> 00:01:05,270
libraries all of which are open source

00:01:02,360 --> 00:01:09,100
and and specifically of course it

00:01:05,270 --> 00:01:11,479
includes an open MP runtime library

00:01:09,100 --> 00:01:14,330
which is Intel's library that we've

00:01:11,479 --> 00:01:17,690
poured into the blue jean queue and the

00:01:14,330 --> 00:01:20,920
openmp patch set for clang again we

00:01:17,690 --> 00:01:20,920
forded that to the Blue Train cube

00:01:24,170 --> 00:01:29,420
alright

00:01:26,390 --> 00:01:31,070
and so what does this give us well it

00:01:29,420 --> 00:01:33,710
means that if you run BG client with

00:01:31,070 --> 00:01:36,920
Jeff openmp just like on GCC you get

00:01:33,710 --> 00:01:39,500
OpenMP support it comes with essentially

00:01:36,920 --> 00:01:43,300
full support for openmp 3.1 with a lot

00:01:39,500 --> 00:01:45,950
of pieces remote from OpenMP for the

00:01:43,300 --> 00:01:48,050
nearest and dearest to my heart is the

00:01:45,950 --> 00:01:51,470
fact that we get OpenAPI simdi support

00:01:48,050 --> 00:01:53,690
so Nvidia client you can say pragma one

00:01:51,470 --> 00:01:57,500
piece md and it will vectorize this loop

00:01:53,690 --> 00:01:59,390
for you it gives the optimizer and the

00:01:57,500 --> 00:02:01,640
backends necessary hints to know that

00:01:59,390 --> 00:02:03,350
the loop is safe to optima safe to

00:02:01,640 --> 00:02:07,630
vectorize even if it can't otherwise

00:02:03,350 --> 00:02:10,970
prove that from dependency analysis and

00:02:07,630 --> 00:02:13,700
and again that that's coupled with a

00:02:10,970 --> 00:02:15,260
runtime library which is 40 version of

00:02:13,700 --> 00:02:18,500
intel's runtime library that they have

00:02:15,260 --> 00:02:21,890
open sourced and the client on p patches

00:02:18,500 --> 00:02:23,390
that intel has developed the the runtime

00:02:21,890 --> 00:02:26,410
library however has not been optimized

00:02:23,390 --> 00:02:26,410
but it does work

00:02:30,130 --> 00:02:37,640
okay so this is my slide on so you said

00:02:36,020 --> 00:02:39,320
you poured Intel's runtime library to

00:02:37,640 --> 00:02:41,540
the patio to blue jean q well that's a

00:02:39,320 --> 00:02:43,370
PowerPC system the big-endian system got

00:02:41,540 --> 00:02:45,650
a little endian system how does that

00:02:43,370 --> 00:02:50,330
work well it turns out it wasn't that

00:02:45,650 --> 00:02:51,320
hard so Intel's runtime library for for

00:02:50,330 --> 00:02:54,710
their own internal use and

00:02:51,320 --> 00:02:57,170
experimentation and other things already

00:02:54,710 --> 00:02:59,260
had macros in it for the necessary

00:02:57,170 --> 00:03:02,300
memory barriers for non strictly ordered

00:02:59,260 --> 00:03:04,070
architectures but in the version they

00:03:02,300 --> 00:03:07,130
ship the memory barriers are just

00:03:04,070 --> 00:03:08,570
defined to nothing so we were able to

00:03:07,130 --> 00:03:10,490
just go in and put in some memory

00:03:08,570 --> 00:03:12,620
barriers but for these macros and turn

00:03:10,490 --> 00:03:14,510
them on for powerpc and we were able to

00:03:12,620 --> 00:03:17,180
get the correct semantics for the most

00:03:14,510 --> 00:03:18,890
part there are still some little Indian

00:03:17,180 --> 00:03:22,160
dependencies in the processor affinity

00:03:18,890 --> 00:03:24,050
code but that could be disabled and most

00:03:22,160 --> 00:03:26,180
of the code just uses POSIX and P

00:03:24,050 --> 00:03:28,190
threads and so it was fairly

00:03:26,180 --> 00:03:29,570
straightforward to support that there's

00:03:28,190 --> 00:03:31,070
a little bit of assembly that we had to

00:03:29,570 --> 00:03:33,560
replace in the microcast dispatch

00:03:31,070 --> 00:03:35,270
routines but again that wasn't that hard

00:03:33,560 --> 00:03:39,410
to do based on the way client uses the

00:03:35,270 --> 00:03:41,560
runtime so an all you got something that

00:03:39,410 --> 00:03:41,560
works

00:03:42,239 --> 00:03:49,930
so again I we took these these things

00:03:47,379 --> 00:03:52,000
from from from Intel we actually

00:03:49,930 --> 00:03:53,530
maintain the trunk based patches so in

00:03:52,000 --> 00:03:56,470
Intel produces patches for the latest

00:03:53,530 --> 00:03:58,329
lvm exciting release we maintain the

00:03:56,470 --> 00:04:01,000
patches upgraded to the current trunk we

00:03:58,329 --> 00:04:02,230
do this nightly just about so you can

00:04:01,000 --> 00:04:03,940
always get the sort of current version

00:04:02,230 --> 00:04:07,720
and then we take off of that when we

00:04:03,940 --> 00:04:11,280
when we pull release and and we've been

00:04:07,720 --> 00:04:15,310
heavily involved in assisting Intel with

00:04:11,280 --> 00:04:16,959
getting there openmp patches upstream so

00:04:15,310 --> 00:04:20,350
we can have OpenMP support in the

00:04:16,959 --> 00:04:21,820
upstream lvm and clang I will call this

00:04:20,350 --> 00:04:23,350
emerging process it's not really a

00:04:21,820 --> 00:04:25,900
merging process it's actually a

00:04:23,350 --> 00:04:27,419
piecewise rewrite of the entire patch

00:04:25,900 --> 00:04:30,400
set which is why it takes a long time

00:04:27,419 --> 00:04:32,560
but nevertheless the quality is really

00:04:30,400 --> 00:04:35,289
high and we're very happy about the way

00:04:32,560 --> 00:04:38,199
it's going on obviously everyone like it

00:04:35,289 --> 00:04:40,780
to be faster but but the the end product

00:04:38,199 --> 00:04:42,490
is really is really quite good and and a

00:04:40,780 --> 00:04:45,870
lot of companies including IBM and

00:04:42,490 --> 00:04:45,870
others are interested in using it

00:04:48,909 --> 00:04:52,939
alright so the moral the story as well

00:04:51,199 --> 00:04:56,479
does that all work the answer is yes it

00:04:52,939 --> 00:04:58,900
works I ve offered for the most part i

00:04:56,479 --> 00:05:02,509
have actually have not received any

00:04:58,900 --> 00:05:09,169
correctness bug reports off of this in a

00:05:02,509 --> 00:05:11,719
very long time and the so i've just

00:05:09,169 --> 00:05:13,789
compiled a simple table here for for an

00:05:11,719 --> 00:05:15,319
example i took the the unofficial see

00:05:13,789 --> 00:05:17,689
version of the nest parallel benchmarks

00:05:15,319 --> 00:05:22,460
with open and p and i compiled them both

00:05:17,689 --> 00:05:25,520
with with BG clang and also with ibm's

00:05:22,460 --> 00:05:26,900
compiler for the Blue Gene and I've just

00:05:25,520 --> 00:05:31,189
given some timings here for the class

00:05:26,900 --> 00:05:33,169
the problems that sets as you can see

00:05:31,189 --> 00:05:34,810
well with the exception of this one we r

00:05:33,169 --> 00:05:39,139
VG klein get slightly faster than XL

00:05:34,810 --> 00:05:40,969
normally it's slower and and these these

00:05:39,139 --> 00:05:41,870
benchmarks are only slightly represented

00:05:40,969 --> 00:05:43,879
of real code because they actually

00:05:41,870 --> 00:05:46,789
hammer quite a bit on the openmp runtime

00:05:43,879 --> 00:05:49,879
which has not been tuned for the for the

00:05:46,789 --> 00:05:52,219
blue jean and may never be but but

00:05:49,879 --> 00:05:54,620
realistically speaking for for a lot of

00:05:52,219 --> 00:05:56,719
the real science codes that i work with

00:05:54,620 --> 00:05:57,949
it works just fine because for both

00:05:56,719 --> 00:06:00,620
science codes they do a lot of work

00:05:57,949 --> 00:06:02,629
inside their peril loops and the

00:06:00,620 --> 00:06:06,439
overhead of the runtime is more or less

00:06:02,629 --> 00:06:08,120
irrelevant so for those codes it works

00:06:06,439 --> 00:06:11,210
quite well and and we're very happy with

00:06:08,120 --> 00:06:12,560
it and and using lvm inclined with the

00:06:11,210 --> 00:06:15,770
associated patch sets and everything

00:06:12,560 --> 00:06:17,509
else we've been able to deliver a tool

00:06:15,770 --> 00:06:21,110
chain that has full supercilious 11

00:06:17,509 --> 00:06:22,099
support and full OpenMP support on on an

00:06:21,110 --> 00:06:27,500
architecture that wouldn't otherwise

00:06:22,099 --> 00:06:29,830
have that capability so with that anyway

00:06:27,500 --> 00:06:29,830
yes

00:06:34,650 --> 00:06:37,650
ready

00:06:44,670 --> 00:06:52,440
um a bi oh I should repeat the question

00:06:48,690 --> 00:06:53,820
okay thank you a question was he said

00:06:52,440 --> 00:06:55,380
he's looked at some of the pipe shots

00:06:53,820 --> 00:06:59,780
for OpenMP wonder if there's anything

00:06:55,380 --> 00:07:03,240
going to do for a bi support for ppc64

00:06:59,780 --> 00:07:05,700
for the most part no there are there are

00:07:03,240 --> 00:07:07,620
a couple of architecture specific pieces

00:07:05,700 --> 00:07:10,410
so for example in the front end patches

00:07:07,620 --> 00:07:12,210
I there are architecture specific

00:07:10,410 --> 00:07:14,430
callback for things like in open and

00:07:12,210 --> 00:07:16,350
before when you have simdi and you say

00:07:14,430 --> 00:07:18,330
your arrays are aligned but don't

00:07:16,350 --> 00:07:20,820
provide an alignment that's an

00:07:18,330 --> 00:07:23,000
architecture specific default and it's a

00:07:20,820 --> 00:07:26,040
special callbacks to say what that is

00:07:23,000 --> 00:07:28,230
that's not a big deal in terms of the

00:07:26,040 --> 00:07:30,630
library interface our library interfaces

00:07:28,230 --> 00:07:32,400
themselves the interface functions are

00:07:30,630 --> 00:07:34,650
programmed in c and client letter

00:07:32,400 --> 00:07:36,660
generate calls to see using the default

00:07:34,650 --> 00:07:38,130
ABI which is what the open runtime was

00:07:36,660 --> 00:07:42,930
compiled with anyway so that's not a

00:07:38,130 --> 00:07:46,260
problem I the Intel's runtime normally

00:07:42,930 --> 00:07:48,600
uses a hand coded assembly routine for

00:07:46,260 --> 00:07:51,030
doing dispatch it turns out you don't

00:07:48,600 --> 00:07:55,200
need that and the reason you don't need

00:07:51,030 --> 00:07:57,570
that is because clients micro tasks with

00:07:55,200 --> 00:07:58,560
up to four arguments or something like

00:07:57,570 --> 00:08:02,610
that because it actually packed

00:07:58,560 --> 00:08:04,620
everything in the structures the older

00:08:02,610 --> 00:08:07,320
Intel compilers used to generate these

00:08:04,620 --> 00:08:09,120
like dynamically size variable argument

00:08:07,320 --> 00:08:11,580
arrays and that's why they need the

00:08:09,120 --> 00:08:12,930
assembly bit but it turns out that

00:08:11,580 --> 00:08:15,990
they're kind of moving away from that

00:08:12,930 --> 00:08:18,480
anyway so so we didn't I was able to

00:08:15,990 --> 00:08:20,910
replace that assembly dispatch code with

00:08:18,480 --> 00:08:26,250
just some C code and and it worked just

00:08:20,910 --> 00:08:28,140
fine so yeah I mean that was essentially

00:08:26,250 --> 00:08:29,340
it in terms of ABI I mean the the

00:08:28,140 --> 00:08:31,650
largest change is actually where the

00:08:29,340 --> 00:08:34,380
where the memory model changes adding

00:08:31,650 --> 00:08:35,940
barriers where they were needed it turns

00:08:34,380 --> 00:08:39,210
out that the the Intel runs I made some

00:08:35,940 --> 00:08:42,510
assumptions about wait places where you

00:08:39,210 --> 00:08:43,470
could spin for do to do waiting and some

00:08:42,510 --> 00:08:46,110
of those had to be backed off a little

00:08:43,470 --> 00:08:47,520
bit because on the on the blue jean blue

00:08:46,110 --> 00:08:49,560
jean each core can run with well

00:08:47,520 --> 00:08:51,690
Hardware threads but if all the hardware

00:08:49,560 --> 00:08:53,100
threads are spinning like hard spinning

00:08:51,690 --> 00:08:55,620
then they can starve out the other

00:08:53,100 --> 00:08:57,450
threads and so needed some adjustment

00:08:55,620 --> 00:08:58,560
there but it was just it was just some

00:08:57,450 --> 00:09:01,380
little things like that that

00:08:58,560 --> 00:09:03,560
is that a fairly generic there we had to

00:09:01,380 --> 00:09:03,560

YouTube URL: https://www.youtube.com/watch?v=08m1Mrp3-T8


