Title: OpenMP 4.0 SIMD Features SC 14
Publication date: 2014-12-13
Playlist: SC14 OpenMP BOF and Booth Talks
Description: 
	Explicit Vector Programming with OpenMP 4.0 SIMD Extensions. Presented by Michael Wong (IBM) and Jim Cownie (Intel) at SC 14, November 18, 2014.
Captions: 
	00:00:00,000 --> 00:00:03,389
okay hi guys my apologies the main

00:00:01,860 --> 00:00:06,180
speaker is not hear my name is Michael

00:00:03,389 --> 00:00:07,740
Wong i'm the CEO of OpenMP so some of

00:00:06,180 --> 00:00:09,929
you guys may may not know me I've given

00:00:07,740 --> 00:00:12,360
talks on this subject before i'm going

00:00:09,929 --> 00:00:14,190
to have Jim County come in and talk with

00:00:12,360 --> 00:00:16,170
me about this because what I want to

00:00:14,190 --> 00:00:18,150
talk about today is the vector

00:00:16,170 --> 00:00:21,930
programming the vector programming model

00:00:18,150 --> 00:00:23,880
from in OpenMP so well that I'm going to

00:00:21,930 --> 00:00:25,560
skip past much of this talk because much

00:00:23,880 --> 00:00:30,080
of this talk with you've been at ACC you

00:00:25,560 --> 00:00:32,140
in Bristol okay so

00:00:30,080 --> 00:00:39,020
and get to the part that talks about

00:00:32,140 --> 00:00:41,210
vector vector programming all right it's

00:00:39,020 --> 00:00:42,350
probably available on a cc you actually

00:00:41,210 --> 00:00:44,660
it talks about a lot of different things

00:00:42,350 --> 00:00:47,270
about accelerators as well as the

00:00:44,660 --> 00:00:49,400
affinity models things like that so I

00:00:47,270 --> 00:00:51,670
wanted to focus for now on the vector

00:00:49,400 --> 00:00:51,670
model

00:00:52,829 --> 00:01:01,380
Michael

00:00:54,510 --> 00:01:03,100
sure thank you all right all right so

00:01:01,380 --> 00:01:07,900
now we're stepping through the

00:01:03,100 --> 00:01:11,950
affinities all rights mdl language

00:01:07,900 --> 00:01:15,040
extensions all right I don't know what

00:01:11,950 --> 00:01:17,650
was done for yesterday okay

00:01:15,040 --> 00:01:19,240
alright so so let me just start right

00:01:17,650 --> 00:01:22,060
away until in terms of the committee

00:01:19,240 --> 00:01:23,350
it's led by shinmin who we were trying

00:01:22,060 --> 00:01:24,850
to get here there are a whole bunch of

00:01:23,350 --> 00:01:26,890
other people involved from various

00:01:24,850 --> 00:01:29,470
different company much of the vector

00:01:26,890 --> 00:01:32,200
proposal came from the Intel the Intel

00:01:29,470 --> 00:01:33,940
what intolerant have had in their

00:01:32,200 --> 00:01:35,740
compiler for quite some time now but

00:01:33,940 --> 00:01:37,270
other people that's been involved as you

00:01:35,740 --> 00:01:40,479
can see the broad base of different

00:01:37,270 --> 00:01:43,450
companies which in Oracle IBM BSC and

00:01:40,479 --> 00:01:44,530
okay so i just wanted to share that just

00:01:43,450 --> 00:01:45,880
to make sure that I give credit for

00:01:44,530 --> 00:01:48,430
these slides because they're not

00:01:45,880 --> 00:01:52,840
actually my slides so one other thing

00:01:48,430 --> 00:01:54,670
that you're going to find is what's the

00:01:52,840 --> 00:01:58,570
problem with simdi language extensions

00:01:54,670 --> 00:02:00,729
okay it seems pretty clear that simdi

00:01:58,570 --> 00:02:02,860
registers with has been steadily

00:02:00,729 --> 00:02:06,340
increasing and in fact they're verging

00:02:02,860 --> 00:02:08,020
on 1024 fairly soon the instructions are

00:02:06,340 --> 00:02:10,450
getting certainly more powerful and more

00:02:08,020 --> 00:02:12,130
complex it's harder it's becoming much

00:02:10,450 --> 00:02:14,380
more difficult for compiling to select

00:02:12,130 --> 00:02:16,209
the right instructions and the co

00:02:14,380 --> 00:02:18,790
pattern that has to be recognized by the

00:02:16,209 --> 00:02:20,440
compiler is increasingly becoming more

00:02:18,790 --> 00:02:23,230
difficult to precision requirements

00:02:20,440 --> 00:02:25,810
often essentially inhibit simdi code

00:02:23,230 --> 00:02:30,390
generations ultimately what I'm what I'm

00:02:25,810 --> 00:02:33,810
noticing is this and I work in them

00:02:30,390 --> 00:02:37,390
sorry I'm just trying to remember okay

00:02:33,810 --> 00:02:38,890
and I work in compiler compilers wonder

00:02:37,390 --> 00:02:40,180
the great hope of compiler jerko

00:02:38,890 --> 00:02:44,170
generation of course is auto

00:02:40,180 --> 00:02:46,860
vectorization that great hope is almost

00:02:44,170 --> 00:02:46,860
is nearly

00:02:50,150 --> 00:02:54,650
is nearly over because it's we're

00:02:52,730 --> 00:02:57,319
finding that it's very difficult for

00:02:54,650 --> 00:02:59,920
most code bases to auto vectorize I

00:02:57,319 --> 00:03:02,390
remember when I used to work on the cell

00:02:59,920 --> 00:03:04,489
seventy percent of the time we spend was

00:03:02,390 --> 00:03:06,019
actually of it was and that was the

00:03:04,489 --> 00:03:09,290
previous generation of accelerated

00:03:06,019 --> 00:03:11,470
processor to actually back to write the

00:03:09,290 --> 00:03:11,470
instructions

00:03:13,000 --> 00:03:16,180
and certainly these were some of the

00:03:14,740 --> 00:03:17,560
reasons as to why we think auto

00:03:16,180 --> 00:03:20,230
vectorization is going to have

00:03:17,560 --> 00:03:22,180
difficulty all of this essentially and

00:03:20,230 --> 00:03:23,470
then there are other difficulties what

00:03:22,180 --> 00:03:25,090
so that what sort of loops can be

00:03:23,470 --> 00:03:27,160
vectorized it turns out it's actually

00:03:25,090 --> 00:03:29,380
fairly complex these loops has to be

00:03:27,160 --> 00:03:32,200
countable they have to be single exit

00:03:29,380 --> 00:03:33,959
single entry straight line code I mean

00:03:32,200 --> 00:03:36,880
any even if statements in there is

00:03:33,959 --> 00:03:39,070
problematic everything they call have to

00:03:36,880 --> 00:03:42,130
be vectorized about potentially you know

00:03:39,070 --> 00:03:44,350
there's certain it can only address to

00:03:42,130 --> 00:03:46,180
non contiguous memory addresses

00:03:44,350 --> 00:03:48,100
alignment difficulties and things like

00:03:46,180 --> 00:03:50,140
that this is just listening some of the

00:03:48,100 --> 00:03:51,880
fundamental difficulty of auto

00:03:50,140 --> 00:03:54,190
vectorization never never mind you

00:03:51,880 --> 00:03:56,620
trying to vectorize it so i think all of

00:03:54,190 --> 00:03:58,830
these is what's essentially driving the

00:03:56,620 --> 00:04:03,010
need for the industry to call for a

00:03:58,830 --> 00:04:05,650
better language support for simdi

00:04:03,010 --> 00:04:08,350
support and this is where we wanted to

00:04:05,650 --> 00:04:10,480
standardize a much of a high level way

00:04:08,350 --> 00:04:12,370
of describing cindy instead you have you

00:04:10,480 --> 00:04:13,930
always converted depending on what a

00:04:12,370 --> 00:04:16,390
local platform happens to be whether

00:04:13,930 --> 00:04:19,150
it's it's SS you know whether it's ssee

00:04:16,390 --> 00:04:22,090
whether it's a you know ibm's version is

00:04:19,150 --> 00:04:24,100
vm x v QX and the 20 possible variants

00:04:22,090 --> 00:04:26,140
that it has a high level language

00:04:24,100 --> 00:04:28,479
support gives you that ability gives the

00:04:26,140 --> 00:04:32,500
compiler better opportunity to optimize

00:04:28,479 --> 00:04:34,210
it ok so that's why openmp has taken the

00:04:32,500 --> 00:04:36,610
lead and probably wanted it probably the

00:04:34,210 --> 00:04:40,600
industry's first high-level vector

00:04:36,610 --> 00:04:42,190
language support ok and this is what I'm

00:04:40,600 --> 00:04:44,770
just show you quickly a little bit of

00:04:42,190 --> 00:04:50,050
syntax here you familiar with most of

00:04:44,770 --> 00:04:54,520
this right ok ok I'm gonna have Jim come

00:04:50,050 --> 00:04:58,830
in my name is first ok you have a mic I

00:04:54,520 --> 00:05:02,590
can just shout but you'll record it so

00:04:58,830 --> 00:05:05,040
as long as you don't ever you wipe it

00:05:02,590 --> 00:05:05,040
somewhere

00:05:05,490 --> 00:05:12,789
that's it that's okay okay so a few

00:05:11,080 --> 00:05:16,030
disclaimers up front I haven't seen

00:05:12,789 --> 00:05:18,580
these slides I'm normally responsible

00:05:16,030 --> 00:05:20,830
for the runtime part of OpenMP so I'm

00:05:18,580 --> 00:05:24,610
the architect for our four hour runtime

00:05:20,830 --> 00:05:26,979
which is also now the llvm run time so

00:05:24,610 --> 00:05:30,639
it's open source under bsd license you

00:05:26,979 --> 00:05:33,099
can get it so mostly I ignore the simdi

00:05:30,639 --> 00:05:36,340
stuff because the compiler does all that

00:05:33,099 --> 00:05:38,080
and I don't have to worry however since

00:05:36,340 --> 00:05:40,289
i'm here in the presenter who wasn't

00:05:38,080 --> 00:05:44,110
here who now owes me at least one beer

00:05:40,289 --> 00:05:47,789
and he's from Intel too I will attempt

00:05:44,110 --> 00:05:50,530
to give these slides so as Michael said

00:05:47,789 --> 00:05:52,840
we have a big problem which is that all

00:05:50,530 --> 00:05:55,690
of these machines have these vector

00:05:52,840 --> 00:05:58,960
operations and the compilers aren't

00:05:55,690 --> 00:06:00,699
smart enough to well sorry I get told

00:05:58,960 --> 00:06:05,470
off by the compiler guys when I say that

00:06:00,699 --> 00:06:08,169
it is in many cases impossible for the

00:06:05,470 --> 00:06:11,229
compiler to deduce that it can vectorize

00:06:08,169 --> 00:06:13,840
a particular loop without being given a

00:06:11,229 --> 00:06:16,990
lot more information from the user about

00:06:13,840 --> 00:06:19,690
how the code is really being used so in

00:06:16,990 --> 00:06:21,759
see the classic examples are where you

00:06:19,690 --> 00:06:24,250
have two pointer arguments into a

00:06:21,759 --> 00:06:26,080
function and they may alias within the

00:06:24,250 --> 00:06:28,330
within the function the compiler has to

00:06:26,080 --> 00:06:29,860
assume that that function would be

00:06:28,330 --> 00:06:33,070
called in a way where they could alias

00:06:29,860 --> 00:06:35,050
unless you as the author of the code

00:06:33,070 --> 00:06:37,570
have told them more by putting restrict

00:06:35,050 --> 00:06:40,270
on the on on the front on the pointer

00:06:37,570 --> 00:06:42,219
arguments there are other cases where

00:06:40,270 --> 00:06:45,820
the compiler needs similar information

00:06:42,219 --> 00:06:49,419
and that's what these these these

00:06:45,820 --> 00:06:52,210
directives are they are statements to

00:06:49,419 --> 00:06:55,210
the compiler too so that you give it

00:06:52,210 --> 00:06:57,310
much more information which you knew but

00:06:55,210 --> 00:07:00,639
the compiler can't deduce and which it

00:06:57,310 --> 00:07:03,930
needs to ensure that it can vectorize

00:07:00,639 --> 00:07:10,000
the the operation they're also quite

00:07:03,930 --> 00:07:11,889
strong statements in as much as often

00:07:10,000 --> 00:07:14,770
the compiler even if it can deduce that

00:07:11,889 --> 00:07:16,150
it could vectorize something may not

00:07:14,770 --> 00:07:18,550
have enough knowledge to know whether

00:07:16,150 --> 00:07:19,000
that was actually worthwhile so it may

00:07:18,550 --> 00:07:21,220
have to

00:07:19,000 --> 00:07:24,010
generate so for instance you have a

00:07:21,220 --> 00:07:25,510
function with a vector and a length if

00:07:24,010 --> 00:07:27,820
the compiler doesn't know that the

00:07:25,510 --> 00:07:30,760
length is always greater than a milli a

00:07:27,820 --> 00:07:32,500
thousand say it may decide that it's

00:07:30,760 --> 00:07:34,270
easier just to generate scalar code

00:07:32,500 --> 00:07:36,820
because the cost of setting up the

00:07:34,270 --> 00:07:38,050
vectors and in particular getting short

00:07:36,820 --> 00:07:39,820
making sure that the things are

00:07:38,050 --> 00:07:42,130
correctly aligned because many of these

00:07:39,820 --> 00:07:45,010
vector instructions only work on a line

00:07:42,130 --> 00:07:47,350
data there's a large cost in entering a

00:07:45,010 --> 00:07:48,880
vector loop before you get to the point

00:07:47,350 --> 00:07:51,100
where you actually get the benefit of

00:07:48,880 --> 00:07:54,070
the vector operations and therefore

00:07:51,100 --> 00:07:56,980
parsing more information into the into

00:07:54,070 --> 00:07:58,780
the subroutines to say this this this

00:07:56,980 --> 00:08:01,180
isn't going to be a nice long vector or

00:07:58,780 --> 00:08:04,560
these arguments are well aligned gives

00:08:01,180 --> 00:08:08,440
the compiler much more information so

00:08:04,560 --> 00:08:10,620
what these Xindi things do is they

00:08:08,440 --> 00:08:12,790
partially override some of the compilers

00:08:10,620 --> 00:08:15,340
sanity checks where it might have

00:08:12,790 --> 00:08:16,540
decided well I could vectorize this but

00:08:15,340 --> 00:08:18,790
I really don't think it's worthwhile

00:08:16,540 --> 00:08:21,700
when you put on simdi on it you're

00:08:18,790 --> 00:08:23,050
saying hey actually believe me I wrote

00:08:21,700 --> 00:08:27,370
this code this is going to be worthwhile

00:08:23,050 --> 00:08:29,320
or at least let me try this to see if

00:08:27,370 --> 00:08:30,760
it's worthwhile and don't stop me trying

00:08:29,320 --> 00:08:33,130
it because you don't think it's

00:08:30,760 --> 00:08:36,190
worthwhile so they're they're quite

00:08:33,130 --> 00:08:37,719
strong they're not just they're not just

00:08:36,190 --> 00:08:39,310
hints they're saying do this I'm

00:08:37,719 --> 00:08:42,370
asserting the correctness of your

00:08:39,310 --> 00:08:44,800
ability to do this therefore they can

00:08:42,370 --> 00:08:47,020
break your code if you put these in and

00:08:44,800 --> 00:08:48,700
the code doesn't obey the the the

00:08:47,020 --> 00:08:50,260
statements that you've made about it so

00:08:48,700 --> 00:08:52,870
for instance you say on one of the

00:08:50,260 --> 00:08:54,520
arguments it's aligned and then it turns

00:08:52,870 --> 00:08:56,260
out that it wasn't you'll get a

00:08:54,520 --> 00:08:58,930
segmentation violation when you run the

00:08:56,260 --> 00:09:02,140
code well fine you know we're doing this

00:08:58,930 --> 00:09:04,240
in NC see is a language where you shoot

00:09:02,140 --> 00:09:10,990
your foot off but that's what it's for

00:09:04,240 --> 00:09:13,210
that the safety catches are off so a lot

00:09:10,990 --> 00:09:16,570
of operations that describe a lot of

00:09:13,210 --> 00:09:19,450
causes that describe how data is is

00:09:16,570 --> 00:09:21,070
shared how to bring it into the

00:09:19,450 --> 00:09:24,760
conceptual vector lanes that are going

00:09:21,070 --> 00:09:27,910
to be operating on the loop as i said

00:09:24,760 --> 00:09:31,300
i'm not an expert on all of these but

00:09:27,910 --> 00:09:32,710
here we can see the aligned the linear

00:09:31,300 --> 00:09:36,820
the safe len that's

00:09:32,710 --> 00:09:38,410
is I because we're vectorizing it there

00:09:36,820 --> 00:09:40,540
are there's a bit more restrictions that

00:09:38,410 --> 00:09:42,430
we can now in the parallel ISM if we say

00:09:40,540 --> 00:09:44,650
that a loop is parallel we're allowing

00:09:42,430 --> 00:09:48,970
any possible sequence of iterations to

00:09:44,650 --> 00:09:50,650
be to occur so it could execute all of

00:09:48,970 --> 00:09:52,780
the even ones then all of the odd ones

00:09:50,650 --> 00:09:55,740
or could execute from the far end or it

00:09:52,780 --> 00:09:58,780
could do anything with the vectorization

00:09:55,740 --> 00:10:01,480
they were saying that there are some

00:09:58,780 --> 00:10:04,510
cases where there can be a feedback and

00:10:01,480 --> 00:10:06,880
we're moving up the thing but the

00:10:04,510 --> 00:10:08,770
feedback is is is it a sufficient length

00:10:06,880 --> 00:10:09,970
that we know that we can vectorize up to

00:10:08,770 --> 00:10:12,310
this length whereas if we went further

00:10:09,970 --> 00:10:13,870
then we would be loading data that we

00:10:12,310 --> 00:10:20,980
should have read a lot an updated

00:10:13,870 --> 00:10:25,170
version of we can parallel eyes and we

00:10:20,980 --> 00:10:28,030
so here we're all right so this is a

00:10:25,170 --> 00:10:30,040
case oh this is just a sindhi loop all

00:10:28,030 --> 00:10:31,660
right so this is the simdi loop oh this

00:10:30,040 --> 00:10:33,550
is parallelize ain't vectorize yeah okay

00:10:31,660 --> 00:10:35,500
so in the one directive if we can say

00:10:33,550 --> 00:10:38,920
this is a parallel loop and it's also a

00:10:35,500 --> 00:10:41,170
simdi loop so we want to chunk it into

00:10:38,920 --> 00:10:44,350
into into simdi width pieces and then

00:10:41,170 --> 00:10:46,930
chunk those out in parallel other

00:10:44,350 --> 00:10:50,340
similes assimilation as a how it was all

00:10:46,930 --> 00:10:50,340
lies in across different threats

00:10:50,359 --> 00:10:54,209
across different threads and then it

00:10:52,709 --> 00:10:58,799
divides a vector and then gives you the

00:10:54,209 --> 00:11:00,089
vectorization after that okay ah and

00:10:58,799 --> 00:11:01,559
then now we have to send e function

00:11:00,089 --> 00:11:03,569
there are certain functions you might

00:11:01,559 --> 00:11:08,339
actually want to actually generate

00:11:03,569 --> 00:11:10,199
vector code for right so the point here

00:11:08,339 --> 00:11:12,389
is that normally if you cook if you make

00:11:10,199 --> 00:11:15,589
a function call inside your subroutine

00:11:12,389 --> 00:11:18,149
inside your vector loop sorry then

00:11:15,589 --> 00:11:20,369
because of this standard unless you can

00:11:18,149 --> 00:11:22,350
inline it because of the standard

00:11:20,369 --> 00:11:24,359
calling conventions the compiler has to

00:11:22,350 --> 00:11:26,189
it's got all this nice data sitting in a

00:11:24,359 --> 00:11:28,169
simply vector register but it has to

00:11:26,189 --> 00:11:30,929
push it out into store so that then it

00:11:28,169 --> 00:11:32,249
can pass it or even work or inter store

00:11:30,929 --> 00:11:34,259
and then move it into integer registers

00:11:32,249 --> 00:11:36,929
because that's how the function calling

00:11:34,259 --> 00:11:39,869
convention works that's clearly very

00:11:36,929 --> 00:11:42,839
costly and so instead of that to allow

00:11:39,869 --> 00:11:44,369
allow the compiler to in effect cheat on

00:11:42,839 --> 00:11:46,139
the vector on the calling conventions

00:11:44,369 --> 00:11:48,029
there are some new vector calling

00:11:46,139 --> 00:11:49,859
conventions that allow the compiler to

00:11:48,029 --> 00:11:52,439
pass arguments into the subroutine in

00:11:49,859 --> 00:11:54,779
vector registers so it doesn't have to

00:11:52,439 --> 00:11:56,069
spill them out to store and pass them

00:11:54,779 --> 00:11:58,769
through integer registers or pass

00:11:56,069 --> 00:12:00,889
pointers to them and that's what this

00:11:58,769 --> 00:12:03,809
declares cindy on the on the function

00:12:00,889 --> 00:12:06,389
says this is a this is a function that I

00:12:03,809 --> 00:12:07,889
want you to generate a version so we're

00:12:06,389 --> 00:12:09,660
going to generate multiple versions of

00:12:07,889 --> 00:12:11,339
this we're going to generate a version

00:12:09,660 --> 00:12:13,470
that takes vector arguments so they can

00:12:11,339 --> 00:12:18,989
be in simdi registers and therefore

00:12:13,470 --> 00:12:23,329
improve the performance these are

00:12:18,989 --> 00:12:23,329
similar or they not Michael yes right

00:12:23,749 --> 00:12:28,410
it's not in lining if it in line then it

00:12:26,759 --> 00:12:29,970
would be fine already because it doesn't

00:12:28,410 --> 00:12:31,649
need to it doesn't need to know this

00:12:29,970 --> 00:12:33,480
this could be a function that had been

00:12:31,649 --> 00:12:35,610
compiled in a separately loaded library

00:12:33,480 --> 00:12:37,829
right even so you didn't even know

00:12:35,610 --> 00:12:39,869
anything about it but the normal calling

00:12:37,829 --> 00:12:41,399
conventions the standard ABI application

00:12:39,869 --> 00:12:44,730
binary interface calling conventions for

00:12:41,399 --> 00:12:46,829
all of these machines don't allow you to

00:12:44,730 --> 00:12:49,709
pass registers in arguments in simdi

00:12:46,829 --> 00:12:51,209
registers right so if you had data in a

00:12:49,709 --> 00:12:53,069
sim deregister that you want to pass to

00:12:51,209 --> 00:12:56,069
a subroutine through the standard ABI

00:12:53,069 --> 00:12:57,569
you have to store it into memory right

00:12:56,069 --> 00:13:00,029
admittedly it will end up in the cache

00:12:57,569 --> 00:13:01,709
but goes into memory and then either you

00:13:00,029 --> 00:13:03,360
pass a pointer to it in the subroutine

00:13:01,709 --> 00:13:03,630
or you load it even in some cases into

00:13:03,360 --> 00:13:05,400
into

00:13:03,630 --> 00:13:07,290
registers to pass it to the subroutine

00:13:05,400 --> 00:13:09,090
or incorrect safety seven floating

00:13:07,290 --> 00:13:13,530
registers or some not on Michaels

00:13:09,090 --> 00:13:15,690
machines some horrible way so you had

00:13:13,530 --> 00:13:17,190
data right up near the processor in the

00:13:15,690 --> 00:13:19,320
vector registers you just wanted to do

00:13:17,190 --> 00:13:21,210
some small number of operations on it

00:13:19,320 --> 00:13:22,680
you don't know what they are at the time

00:13:21,210 --> 00:13:24,330
you're generating the outer vector loop

00:13:22,680 --> 00:13:26,550
though they're in a subroutine that you

00:13:24,330 --> 00:13:28,500
may not have seen the content of so this

00:13:26,550 --> 00:13:31,470
allows you to use a different set of

00:13:28,500 --> 00:13:32,970
calling conventions that that so it's

00:13:31,470 --> 00:13:34,440
not in lining because in lining there

00:13:32,970 --> 00:13:35,760
wouldn't be a call at all there wouldn't

00:13:34,440 --> 00:13:37,920
be a new stack frame he wouldn't have

00:13:35,760 --> 00:13:39,630
branched off to to the other library

00:13:37,920 --> 00:13:41,690
wherever it happens to be in store the

00:13:39,630 --> 00:13:46,220
compiler would have done the whole thing

00:13:41,690 --> 00:13:46,220
so it is different yeah

00:13:51,640 --> 00:13:57,000
ok so this I'm really not familiar with

00:13:55,060 --> 00:14:00,000
but I guess that it's to do with masking

00:13:57,000 --> 00:14:00,000
ok

00:14:06,940 --> 00:14:09,990
any questions

00:14:10,300 --> 00:14:14,050
Hardenberg i have a beard

00:14:19,089 --> 00:14:26,749
well what would hardware guys need to do

00:14:21,920 --> 00:14:28,939
to you know kind of support this on the

00:14:26,749 --> 00:14:30,379
hardware level so the question is what

00:14:28,939 --> 00:14:33,139
would hardware guys have to do to

00:14:30,379 --> 00:14:34,879
support this on the hardware I don't

00:14:33,139 --> 00:14:36,319
think that the hardware guys need to do

00:14:34,879 --> 00:14:38,930
anything more than they've already done

00:14:36,319 --> 00:14:41,920
they've given us this some interesting

00:14:38,930 --> 00:14:44,720
instruction set with wide vectors and

00:14:41,920 --> 00:14:46,639
this is in the sense of that was someone

00:14:44,720 --> 00:14:49,990
asked you how was your dessert and you

00:14:46,639 --> 00:14:54,949
answer well it was very interesting

00:14:49,990 --> 00:14:57,860
which means I don't didn't like it much

00:14:54,949 --> 00:14:59,540
but I'm not prepared to say so they we

00:14:57,860 --> 00:15:03,439
have these interesting instruction sets

00:14:59,540 --> 00:15:07,009
and we now are trying to generate a

00:15:03,439 --> 00:15:10,459
language that can program them if you

00:15:07,009 --> 00:15:12,410
look it's a it only realised this

00:15:10,459 --> 00:15:13,939
recently and once I realized that it

00:15:12,410 --> 00:15:15,980
wasn't at all surprising and I should

00:15:13,939 --> 00:15:18,769
have realized it long ago but we write

00:15:15,980 --> 00:15:22,490
languages that target the machines we

00:15:18,769 --> 00:15:24,949
have right certainly in hpc we're not

00:15:22,490 --> 00:15:27,129
being very abstract we don't go off and

00:15:24,949 --> 00:15:29,870
say hi you know I really like

00:15:27,129 --> 00:15:33,920
applicative languages pure languages

00:15:29,870 --> 00:15:36,139
whatever we go what hardware did you

00:15:33,920 --> 00:15:39,379
give me well I better make it possible

00:15:36,139 --> 00:15:42,620
to for people to use that right so you

00:15:39,379 --> 00:15:44,329
know we have MPI because we ran out of

00:15:42,620 --> 00:15:46,220
being able to build faster processors

00:15:44,329 --> 00:15:49,639
faster nodes and it's sort of obvious

00:15:46,220 --> 00:15:51,350
that you run out of you know you run out

00:15:49,639 --> 00:15:53,240
of time before you run out of money so

00:15:51,350 --> 00:15:55,100
it's if you're going to build the

00:15:53,240 --> 00:15:57,110
fastest computer in the world you spend

00:15:55,100 --> 00:15:58,970
a load of money on the fastest node you

00:15:57,110 --> 00:16:00,379
can but you still got money left so you

00:15:58,970 --> 00:16:02,449
buy two or three of them or four of them

00:16:00,379 --> 00:16:04,399
a thousand of the 100,000 of them you

00:16:02,449 --> 00:16:06,050
connect them together and then you need

00:16:04,399 --> 00:16:09,170
to program that and we have MPI to do

00:16:06,050 --> 00:16:11,000
that but NP i arose because those were

00:16:09,170 --> 00:16:13,040
the machines that were being built it

00:16:11,000 --> 00:16:15,170
wasn't the case of we sat down and did

00:16:13,040 --> 00:16:17,120
MPI i was on the MPI one standard

00:16:15,170 --> 00:16:18,709
committee we didn't sit down and do MPI

00:16:17,120 --> 00:16:21,170
because we thought that's a great

00:16:18,709 --> 00:16:22,939
programming model we did it because

00:16:21,170 --> 00:16:25,370
that's what the machines are like and

00:16:22,939 --> 00:16:27,559
similarly here we're catching up with

00:16:25,370 --> 00:16:29,420
the way that the hardware already is so

00:16:27,559 --> 00:16:31,460
it's another case of wanting different

00:16:29,420 --> 00:16:33,320
hardware it's a case of catching up

00:16:31,460 --> 00:16:36,500
letting you program the hard way you

00:16:33,320 --> 00:16:37,850
already bought that okay so another way

00:16:36,500 --> 00:16:39,920
to think about it is I think the

00:16:37,850 --> 00:16:41,300
compiler to compile oh whatever people

00:16:39,920 --> 00:16:43,490
are always going to generate specific

00:16:41,300 --> 00:16:46,840
instructions can get

00:16:43,490 --> 00:16:48,930
that part 1

00:16:46,840 --> 00:16:52,330
what

00:16:48,930 --> 00:16:54,580
 hungry some pro shops the

00:16:52,330 --> 00:16:57,280
comparability look at my be able to use

00:16:54,580 --> 00:16:59,650
though yeah so okay so I'll answer that

00:16:57,280 --> 00:17:02,860
because you asked AVX so the question

00:16:59,650 --> 00:17:05,170
was AV axe has a very large number of

00:17:02,860 --> 00:17:08,199
instructions can the compiler actually

00:17:05,170 --> 00:17:10,150
use them all and my answer to that is

00:17:08,199 --> 00:17:12,400
that one of the reasons that AV axe has

00:17:10,150 --> 00:17:15,220
so many instructions is precisely to

00:17:12,400 --> 00:17:17,890
enable the compiler to work the thing

00:17:15,220 --> 00:17:19,660
that compilers find really hard is where

00:17:17,890 --> 00:17:22,150
you have something that you would expect

00:17:19,660 --> 00:17:24,550
to be a full matrix you know this

00:17:22,150 --> 00:17:27,040
operand that operand filled in nicely

00:17:24,550 --> 00:17:28,630
then it's easy right register memory

00:17:27,040 --> 00:17:31,330
whatever register register register

00:17:28,630 --> 00:17:32,890
that's easy if it's filled in the cases

00:17:31,330 --> 00:17:35,020
that are hard for the compiler or where

00:17:32,890 --> 00:17:36,190
there are some bits missing right so you

00:17:35,020 --> 00:17:37,480
start trying to generate that

00:17:36,190 --> 00:17:39,070
instruction and you suddenly find that

00:17:37,480 --> 00:17:41,500
one of the operands is in a register

00:17:39,070 --> 00:17:42,730
when you needed it in memory and now you

00:17:41,500 --> 00:17:45,280
have to generate some different

00:17:42,730 --> 00:17:48,370
instruction so I admit I was shocked i

00:17:45,280 --> 00:17:50,230
went when when some of the fuse multiply

00:17:48,370 --> 00:17:52,240
had instructions were announced and I

00:17:50,230 --> 00:17:54,040
rent a microprocessor report thing this

00:17:52,240 --> 00:17:55,630
shows you how Intel works I found out

00:17:54,040 --> 00:17:57,850
more about our new instruction set from

00:17:55,630 --> 00:17:59,980
microprocessor report than I'd known

00:17:57,850 --> 00:18:03,400
beforehand and it says you know there

00:17:59,980 --> 00:18:06,670
are 327 new instructions for something

00:18:03,400 --> 00:18:08,410
and then there are 249 different views

00:18:06,670 --> 00:18:11,560
multiply had instructions whatever it

00:18:08,410 --> 00:18:14,170
was and you think why do you need 249

00:18:11,560 --> 00:18:16,390
fuse I'm sure 249 s wrong but yeah and

00:18:14,170 --> 00:18:18,160
then you think well okay so if you

00:18:16,390 --> 00:18:19,780
multiply that is really a for operand

00:18:18,160 --> 00:18:21,550
instruction to accept our instruction

00:18:19,780 --> 00:18:25,210
set encodes three operand instructions

00:18:21,550 --> 00:18:27,070
so that gives you an issue of you know

00:18:25,210 --> 00:18:30,210
which which of the operands is destroyed

00:18:27,070 --> 00:18:33,010
right then you've got add and subtract

00:18:30,210 --> 00:18:34,780
right and you multiply out all of these

00:18:33,010 --> 00:18:36,340
possibilities along with addressing mode

00:18:34,780 --> 00:18:38,740
and so on and you get this huge number

00:18:36,340 --> 00:18:42,000
of instructions but really conceptually

00:18:38,740 --> 00:18:45,760
it's just fuse multiply add or subtract

00:18:42,000 --> 00:18:48,910
on every possibility of where things are

00:18:45,760 --> 00:18:50,590
living and so on so the mug the huge

00:18:48,910 --> 00:18:52,360
numbers of instructions aren't the

00:18:50,590 --> 00:18:54,520
complexity for the compiler its way you

00:18:52,360 --> 00:18:56,050
have a huge number of instructions but

00:18:54,520 --> 00:18:59,299
I'm missing a few critical ones that

00:18:56,050 --> 00:19:01,929
cause the compiler people real grief

00:18:59,299 --> 00:19:01,929

YouTube URL: https://www.youtube.com/watch?v=fAq-GZHMP7M


