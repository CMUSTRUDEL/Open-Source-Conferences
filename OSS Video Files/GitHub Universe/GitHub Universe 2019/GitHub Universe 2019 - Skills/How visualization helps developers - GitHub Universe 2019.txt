Title: How visualization helps developers - GitHub Universe 2019
Publication date: 2019-12-13
Playlist: GitHub Universe 2019 - Skills
Description: 
	The rising complexity of modern software is pushing the limits of human understanding. Fortunately, visualization is here to help, allowing us to see surprising patterns in data at a glance!

In this session, you will learn how visualization can help us understand both the static structure and runtime behavior of software. Through visualization, you will gain a deeper understanding of your code, make better-informed design decisions, and have new tools for sharing insights with your team.

About GitHub Universe:
GitHub Universe is a two-day conference dedicated to the creativity and curiosity of the largest software community in the world. Sessions cover topics from team culture to open source software across industries and technologies.

For more information on GitHub Universe, check the website:
https://githubuniverse.com
Captions: 
	00:00:00,680 --> 00:00:18,929
[Music]

00:00:19,130 --> 00:00:27,210
hi thanks so much for coming my name is

00:00:24,689 --> 00:00:29,880
melody and I lead a company called

00:00:27,210 --> 00:00:32,940
observable with my co-founder and friend

00:00:29,880 --> 00:00:35,910
Mike Bostock you may know Mike he

00:00:32,940 --> 00:00:38,460
created d3 which is an open-source data

00:00:35,910 --> 00:00:40,710
visualization framework and I'm super

00:00:38,460 --> 00:00:43,710
grateful to work with everyone at on the

00:00:40,710 --> 00:00:46,140
observable team so I've been in software

00:00:43,710 --> 00:00:48,210
all my career developing at startups and

00:00:46,140 --> 00:00:50,730
enterprise companies I was at Google for

00:00:48,210 --> 00:00:53,280
quite a bit of time and the thing that I

00:00:50,730 --> 00:00:55,829
was really passionate about this point

00:00:53,280 --> 00:00:58,200
in my career is how we help developers

00:00:55,829 --> 00:00:59,370
become happy and productive so I was

00:00:58,200 --> 00:01:01,320
working on a bunch of developer tools

00:00:59,370 --> 00:01:04,680
you know billions of lines of code

00:01:01,320 --> 00:01:06,300
builds and tests how you run services at

00:01:04,680 --> 00:01:09,509
scale and understand what's happening

00:01:06,300 --> 00:01:12,210
with the software observable is a magic

00:01:09,509 --> 00:01:14,520
notebook for exploring data and thinking

00:01:12,210 --> 00:01:17,250
with code and most of our users are

00:01:14,520 --> 00:01:19,380
developers so I'm super passionate about

00:01:17,250 --> 00:01:22,110
how visualization can help us as

00:01:19,380 --> 00:01:23,520
developers be smarter and move faster

00:01:22,110 --> 00:01:27,000
and have a greater understanding about

00:01:23,520 --> 00:01:29,729
the code that we're writing so today I'm

00:01:27,000 --> 00:01:32,520
gonna make a case that visualization of

00:01:29,729 --> 00:01:35,340
software is an essential tool for us as

00:01:32,520 --> 00:01:38,039
developers and many of the examples that

00:01:35,340 --> 00:01:39,630
I'll show you today come from community

00:01:38,039 --> 00:01:41,009
members in observable so other

00:01:39,630 --> 00:01:43,740
developers that are trying to use

00:01:41,009 --> 00:01:46,110
visualization for software and I hope

00:01:43,740 --> 00:01:48,390
that you walk away with the basic

00:01:46,110 --> 00:01:50,250
knowledge of a few powerful code

00:01:48,390 --> 00:01:52,800
visualization tools maybe some things

00:01:50,250 --> 00:01:58,709
you haven't seen before that you can use

00:01:52,800 --> 00:02:01,530
immediately sound good yeah okay survey

00:01:58,709 --> 00:02:02,429
time how many people here write code the

00:02:01,530 --> 00:02:06,989
majority of your day

00:02:02,429 --> 00:02:09,899
raise your hand nice how many people

00:02:06,989 --> 00:02:11,760
like worried about managing people that

00:02:09,899 --> 00:02:13,739
are writing software and maybe making

00:02:11,760 --> 00:02:16,860
cases for better software development

00:02:13,739 --> 00:02:20,250
raise your hand awesome how many people

00:02:16,860 --> 00:02:23,819
have created visualizations before nice

00:02:20,250 --> 00:02:26,310
all right the challenge is ahead I need

00:02:23,819 --> 00:02:29,780
to show you some new stuff okay well I

00:02:26,310 --> 00:02:31,810
hope to share a bit for everyone here

00:02:29,780 --> 00:02:33,970
every business is

00:02:31,810 --> 00:02:35,500
our business and there's some CEOs that

00:02:33,970 --> 00:02:37,540
kind of adapt and play around with this

00:02:35,500 --> 00:02:40,420
quote but I think it summarizes how

00:02:37,540 --> 00:02:42,220
successful software has been right

00:02:40,420 --> 00:02:44,860
software is transforming or in the

00:02:42,220 --> 00:02:49,690
process of transforming every industry

00:02:44,860 --> 00:02:51,970
every domain every business so why does

00:02:49,690 --> 00:02:55,209
this matter for us I present this

00:02:51,970 --> 00:02:58,000
formula for your consideration more

00:02:55,209 --> 00:03:01,690
developers means more collaboration

00:02:58,000 --> 00:03:03,790
which can equal complexity so we as

00:03:01,690 --> 00:03:05,739
developers can't underestimate the

00:03:03,790 --> 00:03:10,060
impact that our community has on

00:03:05,739 --> 00:03:12,959
software complexity so it's no surprise

00:03:10,060 --> 00:03:16,060
that complexity is increasing right and

00:03:12,959 --> 00:03:19,569
complexity has a real cost rust both in

00:03:16,060 --> 00:03:21,670
terms of correctness and speed so

00:03:19,569 --> 00:03:24,459
complexity challenges correctness in

00:03:21,670 --> 00:03:26,620
that the software may not be doing what

00:03:24,459 --> 00:03:30,880
we actually think it should do or expect

00:03:26,620 --> 00:03:33,670
it to do it's often unstable or buggy or

00:03:30,880 --> 00:03:35,739
insecure and there's a lot of examples

00:03:33,670 --> 00:03:38,470
but we can think of some big ones right

00:03:35,739 --> 00:03:41,440
like event stream or heartbleed or the

00:03:38,470 --> 00:03:44,410
737 max you know there's plenty of

00:03:41,440 --> 00:03:46,000
evidence that shows we don't understand

00:03:44,410 --> 00:03:49,269
what our software is doing it can cause

00:03:46,000 --> 00:03:51,070
real damage the second part which we

00:03:49,269 --> 00:03:54,820
probably all really care about is that

00:03:51,070 --> 00:03:57,760
complexity can slow us down we have more

00:03:54,820 --> 00:04:01,150
dependency big you know software

00:03:57,760 --> 00:04:02,140
projects they they grow quickly and they

00:04:01,150 --> 00:04:04,510
become unwieldy

00:04:02,140 --> 00:04:07,600
and that means we can't move fast to

00:04:04,510 --> 00:04:11,560
ship features so complexity it's painful

00:04:07,600 --> 00:04:14,350
right it hurts these are some words of

00:04:11,560 --> 00:04:16,180
wisdom from Nancy Levinson we are

00:04:14,350 --> 00:04:18,729
attempting to build systems that are

00:04:16,180 --> 00:04:22,210
beyond our ability to intellectually

00:04:18,729 --> 00:04:24,580
manage so if we don't do something to

00:04:22,210 --> 00:04:26,800
improve how we develop and understand

00:04:24,580 --> 00:04:29,160
software the complexity is going to

00:04:26,800 --> 00:04:31,840
overwhelm us if it hasn't already and

00:04:29,160 --> 00:04:34,750
that cost that I was just talking about

00:04:31,840 --> 00:04:37,060
it doesn't occur all at once right it it

00:04:34,750 --> 00:04:41,430
takes time it like creeps up on us

00:04:37,060 --> 00:04:41,430
slowly over and over it's insidious

00:04:41,970 --> 00:04:50,710
any Brett Victor fans in the audience

00:04:45,550 --> 00:04:52,960
anyone oh thanks I'm a big fan okay the

00:04:50,710 --> 00:04:55,030
power to understand and predict the

00:04:52,960 --> 00:04:56,919
quantities of the world should not be

00:04:55,030 --> 00:05:01,470
restricted to those with a freakish

00:04:56,919 --> 00:05:03,940
knack for manipulating abstract symbols

00:05:01,470 --> 00:05:06,460
manipulating abstract symbols isn't that

00:05:03,940 --> 00:05:09,759
what it means to write code it's kind of

00:05:06,460 --> 00:05:11,379
crazy to think about but by symbols he

00:05:09,759 --> 00:05:14,259
doesn't mean that we're manipulating the

00:05:11,379 --> 00:05:16,090
outputs of our program directly but

00:05:14,259 --> 00:05:18,310
instead we're working in abstractions

00:05:16,090 --> 00:05:20,259
and these abstractions are really

00:05:18,310 --> 00:05:21,280
powerful but sometimes they're difficult

00:05:20,259 --> 00:05:24,270
to grasp

00:05:21,280 --> 00:05:27,669
so bring together like an ever-growing

00:05:24,270 --> 00:05:29,830
set of complex abstractions and we as

00:05:27,669 --> 00:05:31,780
developers we need super powers as

00:05:29,830 --> 00:05:36,639
opposed to just this freakish knack that

00:05:31,780 --> 00:05:38,229
we may have to write code okay so I'm

00:05:36,639 --> 00:05:40,719
gonna go back to that formula developers

00:05:38,229 --> 00:05:42,759
collaboration complexity okay so let's

00:05:40,719 --> 00:05:45,509
talk about the humans right we heard

00:05:42,759 --> 00:05:48,430
from October's 40 million developers

00:05:45,509 --> 00:05:50,650
more developers many more people writing

00:05:48,430 --> 00:05:53,199
software right it's just not a couple

00:05:50,650 --> 00:05:56,650
more or a few and with every industry

00:05:53,199 --> 00:05:59,020
investing we can expect that population

00:05:56,650 --> 00:06:00,880
of developers to continue to grow so

00:05:59,020 --> 00:06:03,940
it's not a coincidence that software

00:06:00,880 --> 00:06:07,960
developer was named the number best job

00:06:03,940 --> 00:06:09,610
of 2019 by USNews or predicted by many

00:06:07,960 --> 00:06:12,340
industry analysts to be the number one

00:06:09,610 --> 00:06:16,120
job across all vertical markets by 2030

00:06:12,340 --> 00:06:18,880
and we're at github universe right think

00:06:16,120 --> 00:06:21,940
about open source open source is one in

00:06:18,880 --> 00:06:23,710
the past five to ten years over 50% of

00:06:21,940 --> 00:06:27,130
enterprise say they're using some sort

00:06:23,710 --> 00:06:29,229
of open source software today is

00:06:27,130 --> 00:06:31,930
software it's either open source or it's

00:06:29,229 --> 00:06:34,090
built on it extensively and this means

00:06:31,930 --> 00:06:36,880
that we as developers are more dependent

00:06:34,090 --> 00:06:38,680
on code written by other people or we're

00:06:36,880 --> 00:06:42,699
more likely to share the code that we've

00:06:38,680 --> 00:06:45,340
written so many more humans writing code

00:06:42,699 --> 00:06:47,740
there's more ramp up for all of us maybe

00:06:45,340 --> 00:06:52,509
bigger teams larger software projects

00:06:47,740 --> 00:06:56,639
and distributed teams so let's go back

00:06:52,509 --> 00:06:59,199
to the beginning hello world right

00:06:56,639 --> 00:07:02,050
simple software that we write

00:06:59,199 --> 00:07:04,090
my point here is that soft developing

00:07:02,050 --> 00:07:06,340
software it's creative and it's

00:07:04,090 --> 00:07:09,189
iterative right it can start simple and

00:07:06,340 --> 00:07:11,499
grow quickly to be complex we have an

00:07:09,189 --> 00:07:14,289
idea as a developer we iterate and that

00:07:11,499 --> 00:07:15,909
guides our creation and sometimes we

00:07:14,289 --> 00:07:18,099
don't know exactly what we're doing we

00:07:15,909 --> 00:07:20,979
don't know what we should do we make it

00:07:18,099 --> 00:07:22,840
up as we go along great we tinker reduce

00:07:20,979 --> 00:07:26,169
trial and error we test our hypothesis

00:07:22,840 --> 00:07:28,060
and the more creation that we do in

00:07:26,169 --> 00:07:32,729
software the more change there is so

00:07:28,060 --> 00:07:35,680
hello world quickly becomes hello churn

00:07:32,729 --> 00:07:38,319
more developers more collaboration on

00:07:35,680 --> 00:07:40,599
software more complexity you know

00:07:38,319 --> 00:07:42,490
there's significant duplication and

00:07:40,599 --> 00:07:44,919
fragmentation in the ecosystem that we

00:07:42,490 --> 00:07:46,930
have to search for tools and different

00:07:44,919 --> 00:07:48,990
frameworks and different libraries and

00:07:46,930 --> 00:07:51,249
so we often don't know what to use when

00:07:48,990 --> 00:07:53,199
the tools that we're dependent upon are

00:07:51,249 --> 00:07:54,939
released frequently so we have to spend

00:07:53,199 --> 00:07:57,310
more time learning how to use other

00:07:54,939 --> 00:08:00,099
people's code our teaching them to use

00:07:57,310 --> 00:08:04,419
ours so there's more churn in who and

00:08:00,099 --> 00:08:06,819
how much software is being written but

00:08:04,419 --> 00:08:08,169
we don't write software alone right we

00:08:06,819 --> 00:08:10,240
don't write it for ourselves

00:08:08,169 --> 00:08:12,909
so our programming should favor

00:08:10,240 --> 00:08:14,919
collaboration and we need to have

00:08:12,909 --> 00:08:19,270
different ways to collaborate we need to

00:08:14,919 --> 00:08:21,279
move beyond just static text files okay

00:08:19,270 --> 00:08:26,560
but let's remember some other important

00:08:21,279 --> 00:08:31,499
factors to our brains right time it's

00:08:26,560 --> 00:08:31,499
finite we want to make best use of both

00:08:31,829 --> 00:08:37,930
so Don Norman I'm familiar with Don

00:08:36,190 --> 00:08:40,630
Norman it's the father of cognitive

00:08:37,930 --> 00:08:43,779
design he has this quote which I love

00:08:40,630 --> 00:08:46,930
the power of the unaided mind is greatly

00:08:43,779 --> 00:08:51,339
exaggerated it is things that make us

00:08:46,930 --> 00:08:54,279
smart ok so if our minds need aids or

00:08:51,339 --> 00:08:56,620
tools what does that mean I mean we

00:08:54,279 --> 00:08:59,319
don't design new aids or tools to

00:08:56,620 --> 00:09:01,589
perform mundane tasks right or automate

00:08:59,319 --> 00:09:03,970
away our toll I mean we do do that but

00:09:01,589 --> 00:09:06,399
we also want to build tools that

00:09:03,970 --> 00:09:08,649
actually have the capacity to make us

00:09:06,399 --> 00:09:11,140
smarter so what is he talking about

00:09:08,649 --> 00:09:12,019
things here well you can look to writing

00:09:11,140 --> 00:09:14,720
as

00:09:12,019 --> 00:09:17,809
of the most successful cognitive tools

00:09:14,720 --> 00:09:20,540
or things and that's why we write source

00:09:17,809 --> 00:09:22,309
code to produce programs so this is my

00:09:20,540 --> 00:09:26,089
case for why we as developers need

00:09:22,309 --> 00:09:28,149
better cognitive tools okay so let's

00:09:26,089 --> 00:09:30,259
start talking about visualization

00:09:28,149 --> 00:09:32,360
visualization and graphics more

00:09:30,259 --> 00:09:34,639
generally are powerful tools for

00:09:32,360 --> 00:09:36,139
thinking we should have them directly

00:09:34,639 --> 00:09:37,999
available to us in our programming

00:09:36,139 --> 00:09:39,439
environment understand our software to

00:09:37,999 --> 00:09:42,499
review it to explain it and

00:09:39,439 --> 00:09:44,749
visualization it's it's a means to an

00:09:42,499 --> 00:09:47,749
end and that means that means is to

00:09:44,749 --> 00:09:49,879
insight for us as developers we generate

00:09:47,749 --> 00:09:52,610
ideas to prove to improve our research

00:09:49,879 --> 00:09:55,879
and our software creation we gain

00:09:52,610 --> 00:09:58,009
insights to make better decisions and we

00:09:55,879 --> 00:10:02,089
explain things to support learning and

00:09:58,009 --> 00:10:03,529
teaching so before I show you some

00:10:02,089 --> 00:10:05,389
examples from the community I just

00:10:03,529 --> 00:10:08,179
wanted to show you the notebook that I

00:10:05,389 --> 00:10:11,600
mentioned we're using Java Script right

00:10:08,179 --> 00:10:13,279
very popular language the code is

00:10:11,600 --> 00:10:16,129
running automatically so you get instant

00:10:13,279 --> 00:10:18,290
feedback you can add interaction to

00:10:16,129 --> 00:10:20,449
explore the diagram and you can have

00:10:18,290 --> 00:10:22,819
access to your you know libraries and

00:10:20,449 --> 00:10:24,559
favorite web technologies so this is

00:10:22,819 --> 00:10:27,170
it's gonna run fast but this is an

00:10:24,559 --> 00:10:29,779
example of creating a world map using d3

00:10:27,170 --> 00:10:31,069
so you can modify the code you can add

00:10:29,779 --> 00:10:33,410
components to interact with the

00:10:31,069 --> 00:10:35,449
visualization and this is the interface

00:10:33,410 --> 00:10:37,279
behind many of the visualizations I'm

00:10:35,449 --> 00:10:40,220
going to show you today again created by

00:10:37,279 --> 00:10:41,689
members of the community and you can see

00:10:40,220 --> 00:10:44,240
here you know the code kind of ran

00:10:41,689 --> 00:10:46,819
quickly but we have ways to interact and

00:10:44,240 --> 00:10:52,129
change the visualization as its as it's

00:10:46,819 --> 00:10:54,379
being created so my invitation to all of

00:10:52,129 --> 00:10:56,899
us today we have half an hour more of

00:10:54,379 --> 00:11:00,079
your time is let's be smarter developers

00:10:56,899 --> 00:11:03,619
together visualization it leverages our

00:11:00,079 --> 00:11:05,419
human visual system to help us think but

00:11:03,619 --> 00:11:07,579
what does it mean to be smarter you know

00:11:05,419 --> 00:11:10,879
as a developer as an individual as a

00:11:07,579 --> 00:11:13,009
member of a team visualization helps us

00:11:10,879 --> 00:11:15,860
be smarter by under exposing the

00:11:13,009 --> 00:11:18,649
underlying data and code to allow us to

00:11:15,860 --> 00:11:21,860
question to explore and to derive new

00:11:18,649 --> 00:11:23,769
insights in our software and we can use

00:11:21,860 --> 00:11:25,929
it to better understand

00:11:23,769 --> 00:11:27,970
those you know abstract symbols right

00:11:25,929 --> 00:11:29,739
our processes and maybe some other

00:11:27,970 --> 00:11:31,239
important things too like how we can

00:11:29,739 --> 00:11:33,879
communicate more effectively with each

00:11:31,239 --> 00:11:35,679
other so I'm going to talk through a

00:11:33,879 --> 00:11:38,319
bunch of examples now to show you some

00:11:35,679 --> 00:11:40,509
visual tools and there's two categories

00:11:38,319 --> 00:11:42,790
of these the first one is kind of the

00:11:40,509 --> 00:11:45,189
landscape or the overview how do we

00:11:42,790 --> 00:11:47,319
understand structure and flow and

00:11:45,189 --> 00:11:50,049
invocations and relationships with the

00:11:47,319 --> 00:11:52,600
intent of making our code better it

00:11:50,049 --> 00:11:54,279
could be to refactor to maintain it to

00:11:52,600 --> 00:11:57,220
develop new features but just to create

00:11:54,279 --> 00:11:59,230
positive change in our software and the

00:11:57,220 --> 00:12:01,389
second category really has to do with

00:11:59,230 --> 00:12:03,610
getting into the weeds and the details

00:12:01,389 --> 00:12:06,850
of things like decisions we make around

00:12:03,610 --> 00:12:08,410
algorithms or particular you know

00:12:06,850 --> 00:12:11,069
formulas we need to model in our

00:12:08,410 --> 00:12:16,989
software you ready

00:12:11,069 --> 00:12:18,819
yeah okay so the first one we may not

00:12:16,989 --> 00:12:20,470
think about it while we're writing code

00:12:18,819 --> 00:12:23,439
but it's really important to understand

00:12:20,470 --> 00:12:24,970
structures and flows with the intent

00:12:23,439 --> 00:12:26,739
that we're always having to learn as

00:12:24,970 --> 00:12:30,339
we're writing software and we want to

00:12:26,739 --> 00:12:32,910
act on what we learn so anyone ever

00:12:30,339 --> 00:12:34,959
struggle with understanding packages

00:12:32,910 --> 00:12:36,549
someone has to raise their hand no

00:12:34,959 --> 00:12:38,679
dependencies you don't struggle with

00:12:36,549 --> 00:12:42,009
dependencies oh my gosh

00:12:38,679 --> 00:12:45,369
maybe I'm just strange well hello

00:12:42,009 --> 00:12:47,709
dependency graph this is d3 s dependency

00:12:45,369 --> 00:12:49,569
graphed and this was made using graph is

00:12:47,709 --> 00:12:50,709
and observable and this is pretty much

00:12:49,569 --> 00:12:52,660
as simple as it gets

00:12:50,709 --> 00:12:54,759
d3 doesn't have any external

00:12:52,660 --> 00:12:56,559
dependencies and it has just a few

00:12:54,759 --> 00:12:59,649
development dependencies which have to

00:12:56,559 --> 00:13:01,179
do with bundling and testing some of the

00:12:59,649 --> 00:13:04,209
complexity comes in because there's like

00:13:01,179 --> 00:13:06,220
a handful of helper tools but you can

00:13:04,209 --> 00:13:10,029
see that top-level dependency to the far

00:13:06,220 --> 00:13:12,519
left it quickly turns into spaghetti so

00:13:10,029 --> 00:13:16,480
say you're trying to decide what library

00:13:12,519 --> 00:13:18,490
T is how do you how do you decide how do

00:13:16,480 --> 00:13:20,399
you assess what to use I mean of course

00:13:18,490 --> 00:13:23,290
we think about the features that we need

00:13:20,399 --> 00:13:24,759
but do you think about the types of

00:13:23,290 --> 00:13:25,929
dependencies that you're taking when you

00:13:24,759 --> 00:13:27,309
use something and what those

00:13:25,929 --> 00:13:29,369
dependencies are of the thing that

00:13:27,309 --> 00:13:31,869
you're taking the dependency upon

00:13:29,369 --> 00:13:33,490
dependency graphs pretty simple but an

00:13:31,869 --> 00:13:37,049
easy way for you to understand more

00:13:33,490 --> 00:13:37,049
dependencies in what you're using

00:13:37,050 --> 00:13:41,960
but what about understanding runtime

00:13:38,850 --> 00:13:45,840
behavior or data flow of your code

00:13:41,960 --> 00:13:48,030
hello data flow diagram so this is an

00:13:45,840 --> 00:13:50,940
example of a diagram modeling how data

00:13:48,030 --> 00:13:53,640
flows through code each arrow indicates

00:13:50,940 --> 00:13:55,650
a dependency between two cells so that

00:13:53,640 --> 00:13:58,290
d3 cell that I showed you before you can

00:13:55,650 --> 00:14:00,660
see it there on the left it represents

00:13:58,290 --> 00:14:03,960
the d3 library and it's referenced by

00:14:00,660 --> 00:14:06,000
many cells makes sense so this graph is

00:14:03,960 --> 00:14:08,280
computed automatically using static

00:14:06,000 --> 00:14:09,960
analysis of the code but I think the

00:14:08,280 --> 00:14:11,220
thing that I look at here is when we're

00:14:09,960 --> 00:14:13,890
writing code and we're developing

00:14:11,220 --> 00:14:15,660
software we may sort of think about it

00:14:13,890 --> 00:14:18,060
in the beginning but how often do we go

00:14:15,660 --> 00:14:20,670
back and assess like how complexity has

00:14:18,060 --> 00:14:22,620
built up over time and these graphs are

00:14:20,670 --> 00:14:25,260
a really good way for us to visually see

00:14:22,620 --> 00:14:27,510
and come back to how's the code changing

00:14:25,260 --> 00:14:28,740
and how's the flow change as maybe many

00:14:27,510 --> 00:14:32,700
more of our teammates have been

00:14:28,740 --> 00:14:34,590
modifying the code and here's another

00:14:32,700 --> 00:14:37,230
interesting way to look at it which is

00:14:34,590 --> 00:14:39,540
actually animating the flow of data

00:14:37,230 --> 00:14:41,390
through the graph so this is a video of

00:14:39,540 --> 00:14:43,830
code that's running on live data flow

00:14:41,390 --> 00:14:46,260
you can see the order in which the cells

00:14:43,830 --> 00:14:49,800
run it runs in topological order rather

00:14:46,260 --> 00:14:52,170
than top down we can automatically rerun

00:14:49,800 --> 00:14:53,790
cells when code or state changes and

00:14:52,170 --> 00:14:55,740
we're kind of stepping through the

00:14:53,790 --> 00:14:58,350
evaluation of this notebook and able to

00:14:55,740 --> 00:14:59,940
visually see what's happening so the

00:14:58,350 --> 00:15:01,740
previous one you can visualize

00:14:59,940 --> 00:15:04,260
statically but you can also add

00:15:01,740 --> 00:15:08,310
animations so you can learn the flow of

00:15:04,260 --> 00:15:12,060
what's happening in your software what

00:15:08,310 --> 00:15:13,500
about state management all right we're

00:15:12,060 --> 00:15:18,600
thinking about the software that we're

00:15:13,500 --> 00:15:20,520
writing well hello graph this graph is

00:15:18,600 --> 00:15:23,640
is super easy and great for

00:15:20,520 --> 00:15:26,190
understanding state machines parsers

00:15:23,640 --> 00:15:28,800
protocols and data structures like

00:15:26,190 --> 00:15:31,140
linked lists so what you're seeing on

00:15:28,800 --> 00:15:33,060
the bottom is code actually producing

00:15:31,140 --> 00:15:35,360
the diagram above so this is a toy

00:15:33,060 --> 00:15:37,530
example you have to use your imagination

00:15:35,360 --> 00:15:39,060
for a problem that you may want to solve

00:15:37,530 --> 00:15:42,210
in your own work but each node

00:15:39,060 --> 00:15:43,350
corresponds to a different state you

00:15:42,210 --> 00:15:45,960
know there's many different ways that we

00:15:43,350 --> 00:15:47,700
can create diagrams by hand on paper at

00:15:45,960 --> 00:15:50,220
the whiteboard or piping data through

00:15:47,700 --> 00:15:50,700
them but graph is a really easy way to

00:15:50,220 --> 00:15:52,380
start

00:15:50,700 --> 00:15:55,110
hankering you don't have to think about

00:15:52,380 --> 00:15:57,150
the layout and you can see right we're

00:15:55,110 --> 00:15:59,910
assigning labels to the diagram and the

00:15:57,150 --> 00:16:02,460
code we're gonna add some formatting

00:15:59,910 --> 00:16:05,070
here to sort of indicate the state

00:16:02,460 --> 00:16:09,720
through different shapes and then we're

00:16:05,070 --> 00:16:13,380
actually going to be able to see how the

00:16:09,720 --> 00:16:14,940
state flows and and essentially using

00:16:13,380 --> 00:16:16,470
visual modeling like this can make it

00:16:14,940 --> 00:16:18,570
easier when we actually sit down to

00:16:16,470 --> 00:16:20,040
write code you could come back and

00:16:18,570 --> 00:16:25,110
tinker I mean I think that took us like

00:16:20,040 --> 00:16:27,690
20 seconds to do okay so lots around

00:16:25,110 --> 00:16:29,220
dependencies and being able to visually

00:16:27,690 --> 00:16:30,810
see things what about when we want to

00:16:29,220 --> 00:16:34,040
understand different types of structures

00:16:30,810 --> 00:16:37,440
like file systems files and folders

00:16:34,040 --> 00:16:40,500
hello zoomable sunburst I love this one

00:16:37,440 --> 00:16:42,390
so this gives you a macro view and then

00:16:40,500 --> 00:16:44,430
the micro view of individual details so

00:16:42,390 --> 00:16:46,980
what you're seeing is spatial they files

00:16:44,430 --> 00:16:49,800
and folders with relative size you can

00:16:46,980 --> 00:16:51,390
visually see drill down and explore and

00:16:49,800 --> 00:16:53,100
get a sense of the complexity and size

00:16:51,390 --> 00:16:54,990
of the software that you're writing or

00:16:53,100 --> 00:16:56,940
you're accessing and some of these

00:16:54,990 --> 00:16:59,520
examples you can just easily fork add

00:16:56,940 --> 00:17:01,170
your own data and make it your own but

00:16:59,520 --> 00:17:03,000
it's pretty cool to visually be able to

00:17:01,170 --> 00:17:04,650
see those relative sizes as you're

00:17:03,000 --> 00:17:07,860
looking at as you're looking at the

00:17:04,650 --> 00:17:09,480
structure but what about if you're

00:17:07,860 --> 00:17:11,459
trying to understand the structure of

00:17:09,480 --> 00:17:12,470
your code what can you use to help you

00:17:11,459 --> 00:17:15,810
do that

00:17:12,470 --> 00:17:18,000
hello radial tidy tree this

00:17:15,810 --> 00:17:20,790
visualization creates a hierarchal node

00:17:18,000 --> 00:17:22,320
link diagram this is the code hierarchy

00:17:20,790 --> 00:17:25,020
for flair which is a visualization

00:17:22,320 --> 00:17:27,690
framework so it's modeling the leaves

00:17:25,020 --> 00:17:29,040
and nodes and code and I think by

00:17:27,690 --> 00:17:31,290
looking at it's kind of easily

00:17:29,040 --> 00:17:32,670
understandable right you can kind of

00:17:31,290 --> 00:17:35,400
immediately start to grok what's

00:17:32,670 --> 00:17:38,100
happening in this code versus moving in

00:17:35,400 --> 00:17:40,440
and out of directories if you care about

00:17:38,100 --> 00:17:41,730
the number of files you use this write

00:17:40,440 --> 00:17:43,650
or the types of code that you want to

00:17:41,730 --> 00:17:45,270
look at it emphasizes the structure but

00:17:43,650 --> 00:17:47,100
if you care about size right you can go

00:17:45,270 --> 00:17:50,790
back and use that zoomable sunburst as

00:17:47,100 --> 00:17:52,620
an example okay so what about

00:17:50,790 --> 00:17:56,550
understanding the relationships in the

00:17:52,620 --> 00:17:58,560
code that we're working with I think

00:17:56,550 --> 00:17:59,910
visualizations one of the many ways that

00:17:58,560 --> 00:18:02,990
they're really helpful is they can help

00:17:59,910 --> 00:18:04,080
us spot find hotspots in our code to

00:18:02,990 --> 00:18:05,820
sort

00:18:04,080 --> 00:18:07,919
like start to detangle the hair ball

00:18:05,820 --> 00:18:09,480
when complexity builds up and this

00:18:07,919 --> 00:18:12,710
provides us with opportunities to

00:18:09,480 --> 00:18:16,740
improve restructure refactor our code

00:18:12,710 --> 00:18:19,350
hello hierarchical edge bundling love it

00:18:16,740 --> 00:18:22,049
so beautiful this chart shows the

00:18:19,350 --> 00:18:25,110
relationship among classes in a software

00:18:22,049 --> 00:18:27,240
hierarchy each directed edge going from

00:18:25,110 --> 00:18:29,760
source to target corresponds with an

00:18:27,240 --> 00:18:32,580
import so let's look at some details so

00:18:29,760 --> 00:18:34,500
the links go from blue to red so

00:18:32,580 --> 00:18:36,330
packages with more blue links have more

00:18:34,500 --> 00:18:39,659
outgoing edges they depend on other

00:18:36,330 --> 00:18:41,730
packages whereas the packages with more

00:18:39,659 --> 00:18:43,799
red links they have more incoming edges

00:18:41,730 --> 00:18:46,289
they're dependent upon by other packages

00:18:43,799 --> 00:18:48,360
and the packages with both the blue and

00:18:46,289 --> 00:18:50,340
the red links have both incoming and

00:18:48,360 --> 00:18:54,570
outgoing edges they're really central

00:18:50,340 --> 00:18:56,460
and tightly coupled but you could also

00:18:54,570 --> 00:18:58,139
see where there a bunch of just only

00:18:56,460 --> 00:18:59,730
local dependencies it's pretty self

00:18:58,139 --> 00:19:01,169
contained in the code maybe maybe that's

00:18:59,730 --> 00:19:04,230
fine you don't need to worry about that

00:19:01,169 --> 00:19:06,690
code but here's an example of data

00:19:04,230 --> 00:19:08,850
sprite it has 24 incoming dependencies

00:19:06,690 --> 00:19:10,830
so that data package it's pretty central

00:19:08,850 --> 00:19:12,779
I think the thing for us to think about

00:19:10,830 --> 00:19:14,850
is like okay so say we're gonna go in

00:19:12,779 --> 00:19:17,429
and modify that code or access that code

00:19:14,850 --> 00:19:19,500
like understanding its dependencies and

00:19:17,429 --> 00:19:21,149
visually being able to explore that can

00:19:19,500 --> 00:19:24,299
really help us with our understanding

00:19:21,149 --> 00:19:27,179
and what we do next in the code here's

00:19:24,299 --> 00:19:29,899
another example of seeing relationships

00:19:27,179 --> 00:19:33,269
between core data code

00:19:29,899 --> 00:19:35,190
so this guides us sorry I have to go

00:19:33,269 --> 00:19:38,429
back it guides us to look for places to

00:19:35,190 --> 00:19:40,649
understand the relationships decide you

00:19:38,429 --> 00:19:43,049
know do we want to refactor do we want

00:19:40,649 --> 00:19:45,059
to make some coding changes and I think

00:19:43,049 --> 00:19:46,380
that the interesting thing about using a

00:19:45,059 --> 00:19:48,450
visualization is sometimes you can be

00:19:46,380 --> 00:19:51,750
surprised right you can find things you

00:19:48,450 --> 00:19:53,760
didn't know we're there and you can use

00:19:51,750 --> 00:19:55,919
the visualization to really help

00:19:53,760 --> 00:19:58,500
yourself understand the relationships

00:19:55,919 --> 00:20:00,450
between those code and potentially you

00:19:58,500 --> 00:20:02,389
know reduce or minimize those

00:20:00,450 --> 00:20:04,769
relationships if that makes sense

00:20:02,389 --> 00:20:08,940
you already saw this but it does come in

00:20:04,769 --> 00:20:10,470
rainbow which I really like okay so we

00:20:08,940 --> 00:20:14,580
talked about structures and

00:20:10,470 --> 00:20:16,160
relationships and how to you data flow

00:20:14,580 --> 00:20:17,930
through our code

00:20:16,160 --> 00:20:20,060
what about the humans right what about

00:20:17,930 --> 00:20:21,470
the developers so what if we want to

00:20:20,060 --> 00:20:24,320
learn more about authors and

00:20:21,470 --> 00:20:26,720
contributors think about open source

00:20:24,320 --> 00:20:29,270
contributions so what if you want to

00:20:26,720 --> 00:20:30,680
understand more about what's happened

00:20:29,270 --> 00:20:33,440
with a particular library that you're

00:20:30,680 --> 00:20:36,230
interested in contributing to ok so

00:20:33,440 --> 00:20:39,680
hello edit visualization now this is an

00:20:36,230 --> 00:20:43,280
old visualization it's an example of

00:20:39,680 --> 00:20:45,710
edits in Wikipedia so each color

00:20:43,280 --> 00:20:47,360
corresponds to a different author and we

00:20:45,710 --> 00:20:50,540
can see the first version on the far

00:20:47,360 --> 00:20:52,550
left you can see content being inserted

00:20:50,540 --> 00:20:55,010
and removed the black squares and you

00:20:52,550 --> 00:20:57,110
can observe how the content grows over

00:20:55,010 --> 00:20:59,110
time and how it was added in but do you

00:20:57,110 --> 00:21:02,510
see that zigzag up there

00:20:59,110 --> 00:21:04,790
that's an edit war or maybe we should

00:21:02,510 --> 00:21:08,660
call it like an edit dialog and

00:21:04,790 --> 00:21:10,040
discussion right so these are authors

00:21:08,660 --> 00:21:12,260
that keep reverting each other's changes

00:21:10,040 --> 00:21:14,450
but it's sort of fascinating to be able

00:21:12,260 --> 00:21:16,430
to see this and to be able to understand

00:21:14,450 --> 00:21:19,940
what the humans are doing when they're

00:21:16,430 --> 00:21:21,560
modifying the content what about this

00:21:19,940 --> 00:21:23,810
example you know

00:21:21,560 --> 00:21:26,480
hello code def probably all seen various

00:21:23,810 --> 00:21:28,400
flavors of this right examples of using

00:21:26,480 --> 00:21:31,400
visual design to improve the readability

00:21:28,400 --> 00:21:33,110
of get blame for a file and react so you

00:21:31,400 --> 00:21:35,210
can see which parts of the file have

00:21:33,110 --> 00:21:37,040
changed more recently and who the

00:21:35,210 --> 00:21:39,230
frequent authors are Street super

00:21:37,040 --> 00:21:44,330
helpful context for us as we're writing

00:21:39,230 --> 00:21:46,460
software or hello bar chart race so this

00:21:44,330 --> 00:21:48,680
is a way to view data over time so this

00:21:46,460 --> 00:21:53,170
is 7 years of react development in 30

00:21:48,680 --> 00:21:55,670
seconds it's like mesmerizing ok so

00:21:53,170 --> 00:21:58,760
admittedly this is only looking at

00:21:55,670 --> 00:22:01,250
inserted and deleted lines which is not

00:21:58,760 --> 00:22:03,020
a good proxy for value but you can see

00:22:01,250 --> 00:22:05,780
the activity of the contributors over

00:22:03,020 --> 00:22:07,580
time and it really you know you can kind

00:22:05,780 --> 00:22:09,470
of have some insight into what's what's

00:22:07,580 --> 00:22:11,660
happening with this code who's involved

00:22:09,470 --> 00:22:17,150
who's contributing to it that's

00:22:11,660 --> 00:22:19,310
fascinating to watch is it done ok so

00:22:17,150 --> 00:22:21,350
that was a bit about the high level

00:22:19,310 --> 00:22:23,780
structure and flow and invitations where

00:22:21,350 --> 00:22:25,880
we understand visually and then we're

00:22:23,780 --> 00:22:27,650
able to make changes positive changes in

00:22:25,880 --> 00:22:28,460
the software so now I'm going to drill

00:22:27,650 --> 00:22:32,299
into some deets

00:22:28,460 --> 00:22:34,190
like really go into the weeds and there

00:22:32,299 --> 00:22:36,320
are times right when we need to interact

00:22:34,190 --> 00:22:39,409
and explore when we're making design and

00:22:36,320 --> 00:22:41,299
implementation decisions so for example

00:22:39,409 --> 00:22:42,950
how do we understand algorithms how do

00:22:41,299 --> 00:22:45,649
we make decisions around the algorithms

00:22:42,950 --> 00:22:47,830
to use how do we know it's running what

00:22:45,649 --> 00:22:49,129
do we or do we understand when it's done

00:22:47,830 --> 00:22:51,860
so

00:22:49,129 --> 00:22:53,240
hello algorithm visualizations so I'm

00:22:51,860 --> 00:22:54,019
gonna walk through a couple of examples

00:22:53,240 --> 00:22:56,659
of these just to demonstrate

00:22:54,019 --> 00:22:59,299
alternatives but consider the simple

00:22:56,659 --> 00:23:00,340
problem of generating you know random

00:22:59,299 --> 00:23:02,629
dots on a screen

00:23:00,340 --> 00:23:04,879
maybe you're sampling an image or

00:23:02,629 --> 00:23:07,820
retracing an image so one way is just to

00:23:04,879 --> 00:23:10,369
pick points with uniform random Innis

00:23:07,820 --> 00:23:13,279
just like math got random over and over

00:23:10,369 --> 00:23:18,139
and over again but does this look random

00:23:13,279 --> 00:23:22,429
to you anyone it's really hard to tell

00:23:18,139 --> 00:23:24,289
right okay so what if we care about the

00:23:22,429 --> 00:23:26,059
points being evenly distributed right

00:23:24,289 --> 00:23:27,519
it's not great you've got these points

00:23:26,059 --> 00:23:30,950
where it's too sparse

00:23:27,519 --> 00:23:32,869
there's no dots or too dense there's you

00:23:30,950 --> 00:23:35,840
know too many so how do we get more even

00:23:32,869 --> 00:23:38,330
coverage so this is a visualization

00:23:35,840 --> 00:23:40,190
that's built modeling the algorithm in

00:23:38,330 --> 00:23:42,399
code and then playing that algorithm

00:23:40,190 --> 00:23:45,049
over so this is a different approach

00:23:42,399 --> 00:23:47,330
each point we generate ten random

00:23:45,049 --> 00:23:49,129
candidate samples in gray and then we

00:23:47,330 --> 00:23:51,259
pick the candidate that's the farthest

00:23:49,129 --> 00:23:53,059
in red from the existing sample in black

00:23:51,259 --> 00:23:53,779
and then we just repeat this over and

00:23:53,059 --> 00:23:56,059
over again

00:23:53,779 --> 00:23:58,610
so we're visually seeing the algorithm

00:23:56,059 --> 00:24:01,850
play out and pick the points for the

00:23:58,610 --> 00:24:02,539
sampling so here's what it looks like

00:24:01,850 --> 00:24:04,100
when it's running

00:24:02,539 --> 00:24:06,649
this is Mitchell's best candidate

00:24:04,100 --> 00:24:10,009
algorithm the result is more even

00:24:06,649 --> 00:24:13,730
coverage less clumping look better yeah

00:24:10,009 --> 00:24:15,320
maybe not sure okay here's another

00:24:13,730 --> 00:24:17,539
algorithm that's even better for the

00:24:15,320 --> 00:24:19,549
task this is Britain's algorithm and it

00:24:17,539 --> 00:24:21,470
uses a grid to tell when a candidate

00:24:19,549 --> 00:24:23,779
samples are too close it makes it more

00:24:21,470 --> 00:24:25,070
efficient than Mitchell's algorithm so

00:24:23,779 --> 00:24:26,899
I'm not gonna go into a lot of detail

00:24:25,070 --> 00:24:28,190
here but hopefully you can see it just

00:24:26,899 --> 00:24:31,480
kind of get a sense of how the

00:24:28,190 --> 00:24:33,679
algorithms running on the grid and

00:24:31,480 --> 00:24:35,809
here's what Britain's looks like when

00:24:33,679 --> 00:24:38,509
it's running it expands progressively

00:24:35,809 --> 00:24:40,460
out from the middle and you know

00:24:38,509 --> 00:24:42,230
hopefully you can see the difference

00:24:40,460 --> 00:24:44,690
usually when I run through both of these

00:24:42,230 --> 00:24:46,130
of how the algorithms are different so

00:24:44,690 --> 00:24:48,650
based on what the problem you're trying

00:24:46,130 --> 00:24:50,210
to solve you may decide that one

00:24:48,650 --> 00:24:52,010
algorithm is better than the other and

00:24:50,210 --> 00:24:54,670
visualization can help you do that it

00:24:52,010 --> 00:24:57,130
can help you explore the algorithm and

00:24:54,670 --> 00:24:59,420
here's just a slightly different view

00:24:57,130 --> 00:25:01,010
where you can see the relationship of

00:24:59,420 --> 00:25:05,690
the existing samples and the neighboring

00:25:01,010 --> 00:25:07,910
samples as they spawn out and this is a

00:25:05,690 --> 00:25:09,950
variation of Britten's where it picks

00:25:07,910 --> 00:25:11,720
the most recent sample and to expand

00:25:09,950 --> 00:25:13,910
from rather than a random sample and

00:25:11,720 --> 00:25:16,250
just kind of goes like wildly picking

00:25:13,910 --> 00:25:18,320
the points I think the fun thing about

00:25:16,250 --> 00:25:20,390
developing visualizations is that you

00:25:18,320 --> 00:25:23,660
can kind of tweak the code and see the

00:25:20,390 --> 00:25:25,430
effect in the visualization so I can see

00:25:23,660 --> 00:25:28,220
how things are working and I can write

00:25:25,430 --> 00:25:30,050
better code visualization it really

00:25:28,220 --> 00:25:31,870
reinforces our understanding as we're

00:25:30,050 --> 00:25:34,880
building and if we incorporate

00:25:31,870 --> 00:25:39,200
visualization into our process we can

00:25:34,880 --> 00:25:41,270
learn and move faster so a couple more

00:25:39,200 --> 00:25:43,130
examples this is one from a developer

00:25:41,270 --> 00:25:46,430
who's trying to understand and modern

00:25:43,130 --> 00:25:49,700
model and algorithm they're using so

00:25:46,430 --> 00:25:51,890
this is Hello terrain visualization this

00:25:49,700 --> 00:25:54,980
is reconstructing a mesh or height map

00:25:51,890 --> 00:25:56,930
of terrain of Mount Fuji so it's a

00:25:54,980 --> 00:25:58,940
visualization of mesh retrieval for a

00:25:56,930 --> 00:26:00,980
hierarchical data structure that's

00:25:58,940 --> 00:26:03,290
called right triangulated irregular

00:26:00,980 --> 00:26:05,360
network it's a mouthful you have these

00:26:03,290 --> 00:26:08,420
two big triangles and they recursively

00:26:05,360 --> 00:26:11,030
subdivide when they don't approximate

00:26:08,420 --> 00:26:12,350
the underlying surface well enough so

00:26:11,030 --> 00:26:14,360
this is an algorithm where we can

00:26:12,350 --> 00:26:17,120
control the level of detail either less

00:26:14,360 --> 00:26:19,760
detail or more detail and then construct

00:26:17,120 --> 00:26:21,950
the mesh at the right level this is an

00:26:19,760 --> 00:26:23,330
example of using visualization to

00:26:21,950 --> 00:26:25,160
understand different thresholds and

00:26:23,330 --> 00:26:27,200
algorithms see where it works and see

00:26:25,160 --> 00:26:28,820
where it doesn't and we don't have to

00:26:27,200 --> 00:26:30,920
just read the code the code that

00:26:28,820 --> 00:26:35,210
Vladimir wrote we can see and actually

00:26:30,920 --> 00:26:37,580
working on real data we know al

00:26:35,210 --> 00:26:40,940
algorithms are configurable right they

00:26:37,580 --> 00:26:42,560
take different parameters as input so by

00:26:40,940 --> 00:26:44,810
interacting and exploring through

00:26:42,560 --> 00:26:47,050
visualization it helps us understand the

00:26:44,810 --> 00:26:50,180
effects that those parameters can have

00:26:47,050 --> 00:26:52,400
so this is an example of an explorable

00:26:50,180 --> 00:26:53,700
calculator for placing curve labels on

00:26:52,400 --> 00:26:57,059
weird shapes

00:26:53,700 --> 00:26:58,710
you know for California the name

00:26:57,059 --> 00:27:00,330
California on the map of California so

00:26:58,710 --> 00:27:02,399
you can see at the top we're using

00:27:00,330 --> 00:27:04,649
sliders to estimate how large we can

00:27:02,399 --> 00:27:07,710
make the text without over running the

00:27:04,649 --> 00:27:09,750
shapes borders and it just walks the

00:27:07,710 --> 00:27:12,809
centerline measuring the distance from

00:27:09,750 --> 00:27:14,490
the center and this was an example that

00:27:12,809 --> 00:27:17,130
a developer put together it's like six

00:27:14,490 --> 00:27:18,899
steps with code you can copy it you can

00:27:17,130 --> 00:27:20,760
you know add your own shape and put a

00:27:18,899 --> 00:27:22,440
label on it pretty easily but I think it

00:27:20,760 --> 00:27:28,500
kind of highlights how you can interact

00:27:22,440 --> 00:27:29,880
to learn as you're working in code maybe

00:27:28,500 --> 00:27:31,830
you want to help people understand

00:27:29,880 --> 00:27:34,049
dinette the behavior of dynamic systems

00:27:31,830 --> 00:27:36,570
so we have a pair of differential

00:27:34,049 --> 00:27:40,409
equations describing population mice

00:27:36,570 --> 00:27:43,860
prey and cats predators no offense to

00:27:40,409 --> 00:27:45,600
cat owners or mice owners but if we

00:27:43,860 --> 00:27:47,639
change the starting population of the

00:27:45,600 --> 00:27:49,380
cats or the mice right we can see how

00:27:47,639 --> 00:27:52,019
this affects the population over time

00:27:49,380 --> 00:27:53,669
the populations are cyclical right as

00:27:52,019 --> 00:27:55,620
the number of mice increases the number

00:27:53,669 --> 00:27:57,510
of cats increases because there's more

00:27:55,620 --> 00:27:59,880
food and eventually there are too many

00:27:57,510 --> 00:28:01,440
cats and the mice population declines

00:27:59,880 --> 00:28:04,019
and so do the cats and then it repeats

00:28:01,440 --> 00:28:06,929
right and so while this may be kind of a

00:28:04,019 --> 00:28:09,570
odd example I'm sure there are times

00:28:06,929 --> 00:28:11,039
when you're having to model formulas or

00:28:09,570 --> 00:28:12,840
write code that talks about the

00:28:11,039 --> 00:28:15,120
relationships between certain things and

00:28:12,840 --> 00:28:18,750
if you can visualize those first it may

00:28:15,120 --> 00:28:22,049
actually help you write your software so

00:28:18,750 --> 00:28:23,730
you saw a bunch of examples top level

00:28:22,049 --> 00:28:26,039
structure and flow to help make

00:28:23,730 --> 00:28:27,750
improvements in your software and then

00:28:26,039 --> 00:28:30,600
digging into the details to make better

00:28:27,750 --> 00:28:34,080
decisions but there's a final point I

00:28:30,600 --> 00:28:36,269
want to raise and that is we collaborate

00:28:34,080 --> 00:28:38,309
around software right it's a team sport

00:28:36,269 --> 00:28:41,419
and so sometimes visualizations are

00:28:38,309 --> 00:28:43,260
helpful to share with others right

00:28:41,419 --> 00:28:45,120
visualization isn't something we do for

00:28:43,260 --> 00:28:49,710
ourselves we want to share insights with

00:28:45,120 --> 00:28:51,269
other people so maybe you need to

00:28:49,710 --> 00:28:53,850
convince your co-workers that your code

00:28:51,269 --> 00:28:56,880
needs to be reformed into a gigantic

00:28:53,850 --> 00:28:58,950
ball of mud you can use visualization to

00:28:56,880 --> 00:29:01,289
strengthen your argument so this chart

00:28:58,950 --> 00:29:04,169
shows the number of lines of code of a

00:29:01,289 --> 00:29:06,840
set of react components in observable my

00:29:04,169 --> 00:29:07,200
company's code base so that big one

00:29:06,840 --> 00:29:09,120
there

00:29:07,200 --> 00:29:12,120
is the notebook component and it needed

00:29:09,120 --> 00:29:14,970
to be refactored as the application grew

00:29:12,120 --> 00:29:17,580
a while ago but the developer put this

00:29:14,970 --> 00:29:19,320
together on the team and two weeks ago

00:29:17,580 --> 00:29:21,090
we kicked off a project to refactor it

00:29:19,320 --> 00:29:22,320
because we just like we knew was getting

00:29:21,090 --> 00:29:24,240
bad but we just didn't know how bad it

00:29:22,320 --> 00:29:26,250
was so here's a way that you can

00:29:24,240 --> 00:29:30,030
actually motivate toward positive change

00:29:26,250 --> 00:29:31,710
in your in your code or maybe you just

00:29:30,030 --> 00:29:33,900
want to help people understand a

00:29:31,710 --> 00:29:36,000
programming language or concepts right

00:29:33,900 --> 00:29:38,400
here's an example from Julia Evans of

00:29:36,000 --> 00:29:39,960
the anatomy of a sequel query new

00:29:38,400 --> 00:29:42,060
visualizations don't have to be

00:29:39,960 --> 00:29:44,550
traditional charts they can be diagrams

00:29:42,060 --> 00:29:49,590
that have pictures and concepts using

00:29:44,550 --> 00:29:52,770
color using text so I hope you've

00:29:49,590 --> 00:29:54,780
learned several new powerful

00:29:52,770 --> 00:29:56,880
visualization tools and some examples

00:29:54,780 --> 00:29:58,320
that you can walk away and try but I

00:29:56,880 --> 00:30:00,870
just want to come back to how

00:29:58,320 --> 00:30:03,930
visualization benefits us as developers

00:30:00,870 --> 00:30:07,050
I think it's fun

00:30:03,930 --> 00:30:09,540
I mean you can watch and interact with

00:30:07,050 --> 00:30:11,070
code and algorithms it's fascinating

00:30:09,540 --> 00:30:13,790
right it's much more fun than

00:30:11,070 --> 00:30:15,690
interacting with a static text file and

00:30:13,790 --> 00:30:17,850
visualization helps us see and

00:30:15,690 --> 00:30:20,250
understand at a deeper level and maybe

00:30:17,850 --> 00:30:23,640
we have more appreciation for the code

00:30:20,250 --> 00:30:26,160
or algorithm that we're using what helps

00:30:23,640 --> 00:30:28,890
us learn by visualizing the output of

00:30:26,160 --> 00:30:33,900
our code our understanding of software

00:30:28,890 --> 00:30:35,430
is more intuitive and accessible so like

00:30:33,900 --> 00:30:37,950
a couple more broad Victor quotes so

00:30:35,430 --> 00:30:41,280
bear with me but I love this one

00:30:37,950 --> 00:30:44,070
programming is a way of thinking not a

00:30:41,280 --> 00:30:46,950
rote skill learning about for loops is

00:30:44,070 --> 00:30:48,870
not learning to program any more than

00:30:46,950 --> 00:30:51,420
learning about pencils is learning to

00:30:48,870 --> 00:30:53,760
draw and how true is that

00:30:51,420 --> 00:30:59,940
we as software developers are always

00:30:53,760 --> 00:31:01,860
learning always teaching is the other

00:30:59,940 --> 00:31:03,540
side of learning right teaching is the

00:31:01,860 --> 00:31:05,280
most one of the most effective ways of

00:31:03,540 --> 00:31:06,870
learning and implementing a

00:31:05,280 --> 00:31:10,020
visualization it's like teaching

00:31:06,870 --> 00:31:12,720
yourself you're placing a stronger focus

00:31:10,020 --> 00:31:14,550
on intuitive learning rather than that

00:31:12,720 --> 00:31:17,070
rote learning that Brett Victor was

00:31:14,550 --> 00:31:19,020
talking about so it can be easier to

00:31:17,070 --> 00:31:20,610
internalize and remember having

00:31:19,020 --> 00:31:22,230
interacted with the code rather

00:31:20,610 --> 00:31:23,610
than just memorizing it or trying to

00:31:22,230 --> 00:31:27,540
remember where you were when you were

00:31:23,610 --> 00:31:30,690
writing what finally it helps us get our

00:31:27,540 --> 00:31:33,540
work done by being able to observe our

00:31:30,690 --> 00:31:35,160
code it helps our productivity through

00:31:33,540 --> 00:31:37,320
visualizations we can discover new

00:31:35,160 --> 00:31:39,179
things write unexpected behavior

00:31:37,320 --> 00:31:42,240
surprises that we can then take action

00:31:39,179 --> 00:31:44,730
on and visualization can help you get

00:31:42,240 --> 00:31:47,370
the code right at the beginning you can

00:31:44,730 --> 00:31:49,170
see it rather than just maybe guessing

00:31:47,370 --> 00:31:51,330
about tasks now I mean we still have to

00:31:49,170 --> 00:31:53,160
write tasks but visualization can be

00:31:51,330 --> 00:31:56,700
really helpful when you're iterating in

00:31:53,160 --> 00:32:00,299
the early stages faster iteration more

00:31:56,700 --> 00:32:03,240
insight and the work that we do coding

00:32:00,299 --> 00:32:05,640
is a way of thinking visualization it

00:32:03,240 --> 00:32:08,460
helps us improve our way of thinking as

00:32:05,640 --> 00:32:11,190
we code we can see it we learn through

00:32:08,460 --> 00:32:14,250
interaction and if we can help humans

00:32:11,190 --> 00:32:16,710
ourselves better understand computation

00:32:14,250 --> 00:32:19,140
we'll design better software and do it

00:32:16,710 --> 00:32:21,030
more efficiently ship faster make our

00:32:19,140 --> 00:32:24,419
users happier and hopefully we're a

00:32:21,030 --> 00:32:26,160
little bit happier and productive I mean

00:32:24,419 --> 00:32:28,710
it's not easy I can show you a bunch of

00:32:26,160 --> 00:32:30,210
examples the right data is and

00:32:28,710 --> 00:32:32,610
information you have to transform the

00:32:30,210 --> 00:32:34,620
data in code to make it meaningful like

00:32:32,610 --> 00:32:37,260
some visual channels are less effective

00:32:34,620 --> 00:32:39,480
than others not all colors are perceived

00:32:37,260 --> 00:32:41,580
equally so you need to think about what

00:32:39,480 --> 00:32:44,520
colors you're choosing and you can't

00:32:41,580 --> 00:32:46,950
just like wave a magic wand for

00:32:44,520 --> 00:32:49,799
visualization it takes time to do it

00:32:46,950 --> 00:32:52,309
right you need to think it through also

00:32:49,799 --> 00:32:54,630
think about the tools that you need in

00:32:52,309 --> 00:32:57,059
visualization and I really hope you're

00:32:54,630 --> 00:32:59,850
walking away today with many more tools

00:32:57,059 --> 00:33:02,730
in your tool set my last breath Victor

00:32:59,850 --> 00:33:05,520
quote I swear people understand what

00:33:02,730 --> 00:33:07,950
they can see if a programmer cannot see

00:33:05,520 --> 00:33:09,380
what a program is doing she can't

00:33:07,950 --> 00:33:12,270
understand it

00:33:09,380 --> 00:33:15,240
visualization it leverages our human

00:33:12,270 --> 00:33:18,390
visual system to help us think remember

00:33:15,240 --> 00:33:20,880
brain's finite time we want to make the

00:33:18,390 --> 00:33:24,210
best use of both so scene is

00:33:20,880 --> 00:33:27,210
understanding you know we're here at

00:33:24,210 --> 00:33:29,370
github universe you know github has been

00:33:27,210 --> 00:33:30,690
driving open source software and

00:33:29,370 --> 00:33:33,870
collaboration in the developer community

00:33:30,690 --> 00:33:35,970
it's pretty inspiring but if

00:33:33,870 --> 00:33:38,070
get the right tools to visualize we can

00:33:35,970 --> 00:33:39,720
make our software better we can better

00:33:38,070 --> 00:33:42,750
understand both the structure and flow

00:33:39,720 --> 00:33:44,640
and the details I really hope you

00:33:42,750 --> 00:33:47,250
consider how you bring visualization

00:33:44,640 --> 00:33:49,890
into your own software development so

00:33:47,250 --> 00:33:52,680
much hasn't been visualized really let's

00:33:49,890 --> 00:33:55,410
make visualization a core part of how we

00:33:52,680 --> 00:33:58,380
build modern software let's visualize

00:33:55,410 --> 00:33:59,520
software together thanks so much thanks

00:33:58,380 --> 00:34:00,550
for coming I hope you have a great

00:33:59,520 --> 00:34:03,560
conference

00:34:00,550 --> 00:34:34,579
[Applause]

00:34:03,560 --> 00:34:34,579

YouTube URL: https://www.youtube.com/watch?v=yN2etNsLUfw


