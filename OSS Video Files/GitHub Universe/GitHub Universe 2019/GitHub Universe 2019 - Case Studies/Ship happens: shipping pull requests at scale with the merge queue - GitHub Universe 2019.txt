Title: Ship happens: shipping pull requests at scale with the merge queue - GitHub Universe 2019
Publication date: 2019-12-14
Playlist: GitHub Universe 2019 - Case Studies
Description: 
	Presented by Jack Li, Production Engineer at Shopify

At Shopify, developers merge and deploy over 400 pull requests each day to Shopify master. Two years ago, we built the merge queue as part of Shipit, an open source project, to control the thundering herd of merges and ensure ships happen quickly and safely. In this talk, Shopify will explore the design of the first iteration of the merge queue, what they've learned from that experience, and how they're evolving the merge queue to continuously scale developer productivity.

About GitHub Universe:
GitHub Universe is a two-day conference dedicated to the creativity and curiosity of the largest software community in the world. Sessions cover topics from team culture to open source software across industries and technologies.

For more information on GitHub Universe, check the website:
https://githubuniverse.com
Captions: 
	00:00:00,550 --> 00:00:14,140
[Music]

00:00:17,039 --> 00:00:23,110
good afternoon everybody welcome to ship

00:00:20,740 --> 00:00:27,430
happens shipping PRS at scale with the

00:00:23,110 --> 00:00:29,860
merge queue my name is Jack Lee and I am

00:00:27,430 --> 00:00:32,710
a production engineer at Shopify on the

00:00:29,860 --> 00:00:34,960
developer acceleration team so broadly

00:00:32,710 --> 00:00:36,580
we commit our time to helping our

00:00:34,960 --> 00:00:38,980
developers to be productive and build

00:00:36,580 --> 00:00:43,660
the tools and infrastructure to help

00:00:38,980 --> 00:00:46,690
keep them happy so in case you've never

00:00:43,660 --> 00:00:49,059
heard of Shopify Shopify is the leading

00:00:46,690 --> 00:00:50,800
multi-channel commerce platform that

00:00:49,059 --> 00:00:54,210
powers more than 1 million merchants

00:00:50,800 --> 00:00:57,610
globally some of our merchants include

00:00:54,210 --> 00:01:00,210
the get up store the get up shop out

00:00:57,610 --> 00:01:04,479
front is actually using our POS system

00:01:00,210 --> 00:01:07,750
also fashion OVA and Kylie cosmetics

00:01:04,479 --> 00:01:10,509
just to name a few as you can imagine

00:01:07,750 --> 00:01:15,640
next week's Black Friday it's gonna be a

00:01:10,509 --> 00:01:18,310
fun time for us so the core of Shopify

00:01:15,640 --> 00:01:22,180
is built on a large majestic Ruby on

00:01:18,310 --> 00:01:28,470
Rails monolith there are 21,000 files

00:01:22,180 --> 00:01:32,650
and we run 140 tests every time in CI

00:01:28,470 --> 00:01:35,320
you can say we're pretty big we also

00:01:32,650 --> 00:01:37,180
follow a trunk based workflow using

00:01:35,320 --> 00:01:41,170
polar quests arts as our unit of work

00:01:37,180 --> 00:01:43,770
and we call our trunk branch master that

00:01:41,170 --> 00:01:45,880
might sound familiar to some of you

00:01:43,770 --> 00:01:48,369
hundreds of developers work on this

00:01:45,880 --> 00:01:50,920
monolith daily and so keeping things

00:01:48,369 --> 00:01:56,110
productive and moving fast becomes very

00:01:50,920 --> 00:01:58,180
hard so today I'll be talking about the

00:01:56,110 --> 00:02:00,100
merge queue which is a tool that we

00:01:58,180 --> 00:02:03,159
created to maintain high velocity of

00:02:00,100 --> 00:02:05,259
shipping at scale I also want to share

00:02:03,159 --> 00:02:09,130
our release philosophy and how that

00:02:05,259 --> 00:02:11,200
shaped the tooling that we build so I

00:02:09,130 --> 00:02:12,430
don't have a fun github action for you

00:02:11,200 --> 00:02:14,829
guys to take home today and immediately

00:02:12,430 --> 00:02:16,420
take advantage of all of our work and I

00:02:14,829 --> 00:02:17,860
don't even expect most of you two people

00:02:16,420 --> 00:02:22,780
to go home and just implement everything

00:02:17,860 --> 00:02:24,669
I talked about tonight but I do want you

00:02:22,780 --> 00:02:26,859
to take away the ideas and philosophies

00:02:24,669 --> 00:02:28,630
behind how we build our tools and

00:02:26,859 --> 00:02:30,820
challenge us on the parts that don't

00:02:28,630 --> 00:02:33,230
make any sense

00:02:30,820 --> 00:02:37,310
so let's talk about everyone's favorite

00:02:33,230 --> 00:02:41,390
thing numbers we emerge 400 commits

00:02:37,310 --> 00:02:43,910
every day to master that is a lot of

00:02:41,390 --> 00:02:45,830
commits but if you think about it it's

00:02:43,910 --> 00:02:47,420
not really that interesting maybe we

00:02:45,830 --> 00:02:49,100
just have a lot of developers right they

00:02:47,420 --> 00:02:52,520
do a lot of work and so with a lot of

00:02:49,100 --> 00:02:54,980
commits but what is interesting is that

00:02:52,520 --> 00:02:58,850
we deploy our monolith to production 40

00:02:54,980 --> 00:03:02,180
times a day that means that more than

00:02:58,850 --> 00:03:05,230
once an hour we deploy our entire stack

00:03:02,180 --> 00:03:07,940
to over 1 million global merchants and

00:03:05,230 --> 00:03:09,770
most of this happens during the 9 a.m.

00:03:07,940 --> 00:03:16,489
to the 5:00 p.m. Eastern time zone

00:03:09,770 --> 00:03:18,560
workday so at Shopify we approach

00:03:16,489 --> 00:03:21,920
shipping a little bit differently than a

00:03:18,560 --> 00:03:24,440
lot of other companies specifically our

00:03:21,920 --> 00:03:26,780
most important attribute is throughput

00:03:24,440 --> 00:03:29,060
and we need to make sure that we can

00:03:26,780 --> 00:03:32,570
ship as many pour quests as we can as

00:03:29,060 --> 00:03:35,660
fast as we can but not at the expense of

00:03:32,570 --> 00:03:37,280
safety and we can simplify our

00:03:35,660 --> 00:03:40,519
philosophy to three main rules that

00:03:37,280 --> 00:03:44,090
guide our shipping principles the first

00:03:40,519 --> 00:03:45,950
rule is a master must always be green so

00:03:44,090 --> 00:03:48,470
we want to be able to deploy the master

00:03:45,950 --> 00:03:50,870
at all times and if master is in green

00:03:48,470 --> 00:03:56,150
then we have to get it back to green as

00:03:50,870 --> 00:03:59,480
fast as we can master should be close to

00:03:56,150 --> 00:04:01,100
what we run in production so we believe

00:03:59,480 --> 00:04:03,950
that no matter how much testing you do

00:04:01,100 --> 00:04:06,140
the ultimate test is to see how the

00:04:03,950 --> 00:04:09,290
changes behave with production traffic

00:04:06,140 --> 00:04:11,209
and production data so when we leave

00:04:09,290 --> 00:04:14,450
things on deploy the master this

00:04:11,209 --> 00:04:16,729
increases the risk the next deploy every

00:04:14,450 --> 00:04:25,340
change becomes another thing that can go

00:04:16,729 --> 00:04:27,320
wrong emergency fixes must be fast when

00:04:25,340 --> 00:04:29,770
incidents happen sometimes we have to

00:04:27,320 --> 00:04:32,270
ship something immediately to resolve it

00:04:29,770 --> 00:04:34,280
over a million merchants depend on us to

00:04:32,270 --> 00:04:36,320
keep their stores open and so when

00:04:34,280 --> 00:04:38,930
things break we owe it to our merchants

00:04:36,320 --> 00:04:41,140
to make the recovery as fast and safe as

00:04:38,930 --> 00:04:41,140
possible

00:04:42,430 --> 00:04:49,279
so let's go back to Shopify 2016 and

00:04:46,539 --> 00:04:51,590
this was a time where we were starting

00:04:49,279 --> 00:04:54,860
to get a little big but things were a

00:04:51,590 --> 00:04:58,610
bit of the Wild West and that's

00:04:54,860 --> 00:05:02,080
perfectly okay our developer workflow

00:04:58,610 --> 00:05:04,999
looked a little bit something like this

00:05:02,080 --> 00:05:07,460
so developer go ahead and create a new

00:05:04,999 --> 00:05:11,539
poll request increases dog bites by 200%

00:05:07,460 --> 00:05:13,849
would that be nice and then we will wait

00:05:11,539 --> 00:05:14,930
for branch CI and this is SIA that just

00:05:13,849 --> 00:05:18,139
runs on whatever the state of the

00:05:14,930 --> 00:05:22,580
branches in 2016 this took about 15

00:05:18,139 --> 00:05:25,819
minutes to run and eventually it passes

00:05:22,580 --> 00:05:27,409
sweet we can now merge a master by

00:05:25,819 --> 00:05:31,129
pressing our favorite button the merge

00:05:27,409 --> 00:05:32,479
pull request button once this is done we

00:05:31,129 --> 00:05:34,210
can deploy to production right nice and

00:05:32,479 --> 00:05:37,550
easy

00:05:34,210 --> 00:05:39,169
not exactly so at this point we were

00:05:37,550 --> 00:05:40,249
starting to get a little big and we had

00:05:39,169 --> 00:05:43,039
lots of developers shipping lots of

00:05:40,249 --> 00:05:45,589
changes so while we were waiting for our

00:05:43,039 --> 00:05:49,430
CI many others were waiting for theirs

00:05:45,589 --> 00:05:52,520
as well and after we merged they came

00:05:49,430 --> 00:05:54,409
into master right after us now while

00:05:52,520 --> 00:05:56,899
each of these poor requests have passed

00:05:54,409 --> 00:05:58,849
CI individually on their branches they

00:05:56,899 --> 00:06:02,960
aren't guaranteed to pass once we

00:05:58,849 --> 00:06:04,909
actually put them together but not a

00:06:02,960 --> 00:06:07,189
problem to ensure that we can integrate

00:06:04,909 --> 00:06:09,649
these changes together properly we can

00:06:07,189 --> 00:06:11,899
run CI again for each merge commit that

00:06:09,649 --> 00:06:15,279
ended up in master and each of those

00:06:11,899 --> 00:06:17,749
will have their own CI status and

00:06:15,279 --> 00:06:21,770
eventually we're gonna get some backs we

00:06:17,749 --> 00:06:27,080
get a green over at the top and another

00:06:21,770 --> 00:06:30,789
one and another so awesome

00:06:27,080 --> 00:06:33,740
we just got three green builds in a row

00:06:30,789 --> 00:06:35,689
now at this point we have a continuous

00:06:33,740 --> 00:06:37,189
delivery tool called ship it which is an

00:06:35,689 --> 00:06:39,860
open source tool that we created here at

00:06:37,189 --> 00:06:42,020
Shopify and the way that ship it works

00:06:39,860 --> 00:06:44,569
is that it automatically goes ahead and

00:06:42,020 --> 00:06:48,050
deploys batches of past pour quests out

00:06:44,569 --> 00:06:50,089
to production so in this case here it

00:06:48,050 --> 00:06:52,250
would see the green statuses and it

00:06:50,089 --> 00:06:54,199
would automatically craft a batch of all

00:06:52,250 --> 00:06:56,210
of the undeployed commits up to the last

00:06:54,199 --> 00:06:59,210
green and it will go ahead

00:06:56,210 --> 00:07:01,250
and deploy them to production we do

00:06:59,210 --> 00:07:02,720
perform canary deploys and multiple

00:07:01,250 --> 00:07:05,150
deploy steps by for sake of simplicity

00:07:02,720 --> 00:07:09,770
I'm just gonna group the whole thing as

00:07:05,150 --> 00:07:12,650
production and then after the first

00:07:09,770 --> 00:07:15,440
deploy we send out we get the next to

00:07:12,650 --> 00:07:17,750
poor requests to pass as well no problem

00:07:15,440 --> 00:07:19,220
ship is gonna go ahead package those up

00:07:17,750 --> 00:07:22,460
and deploy those out to production as

00:07:19,220 --> 00:07:24,199
well and this helps make it that we

00:07:22,460 --> 00:07:26,090
don't need to coordinate deploys and

00:07:24,199 --> 00:07:28,820
instead all of this stuff happens

00:07:26,090 --> 00:07:30,620
automatically every developer is

00:07:28,820 --> 00:07:33,110
responsible for monitoring their deploy

00:07:30,620 --> 00:07:34,940
that contains the PO requests and

00:07:33,110 --> 00:07:39,229
ensuring that a deploys and works

00:07:34,940 --> 00:07:43,389
properly and then once everything's

00:07:39,229 --> 00:07:45,979
deployed we're done nice and easy

00:07:43,389 --> 00:07:50,090
unfortunately though things don't always

00:07:45,979 --> 00:07:52,639
go this smoothly the first problem we

00:07:50,090 --> 00:07:54,319
have is with conflicts and I'm not

00:07:52,639 --> 00:07:55,550
talking about hard conflicts where

00:07:54,319 --> 00:07:57,590
you're you and someone else our team the

00:07:55,550 --> 00:07:59,509
same line of code but I'm talking about

00:07:57,590 --> 00:08:03,289
soft conflicts which are much harder to

00:07:59,509 --> 00:08:05,960
detect these are changes that might pass

00:08:03,289 --> 00:08:09,770
CI independently but they'll fail once

00:08:05,960 --> 00:08:12,199
they're put together so let's go back to

00:08:09,770 --> 00:08:13,699
the previous example over here and we

00:08:12,199 --> 00:08:15,380
have to pull requests that have passed

00:08:13,699 --> 00:08:17,560
at this point and two more that are

00:08:15,380 --> 00:08:20,870
still pending

00:08:17,560 --> 00:08:26,810
let's assume that the next GI status

00:08:20,870 --> 00:08:29,810
comes back as failed uh-oh

00:08:26,810 --> 00:08:33,529
but how can this happen if it already

00:08:29,810 --> 00:08:35,120
passed the branch CI so the first answer

00:08:33,529 --> 00:08:37,130
is maybe it wasn't rebased properly

00:08:35,120 --> 00:08:38,500
maybe the branch was based off of was

00:08:37,130 --> 00:08:42,320
master from last week

00:08:38,500 --> 00:08:44,450
that could've caused it or maybe this

00:08:42,320 --> 00:08:46,190
can happen because of saw conflicts so

00:08:44,450 --> 00:08:48,140
maybe four and four or four one five

00:08:46,190 --> 00:08:50,209
over there introduced some change that

00:08:48,140 --> 00:08:52,520
conflicted logically with four one six

00:08:50,209 --> 00:08:58,370
causing it not to pass one and still

00:08:52,520 --> 00:09:00,380
together and because four one six is

00:08:58,370 --> 00:09:03,130
broken the build everything else after

00:09:00,380 --> 00:09:03,130
it would fail as well

00:09:05,540 --> 00:09:10,610
now this is not the end of the world we

00:09:08,060 --> 00:09:12,770
can still make some progress so this

00:09:10,610 --> 00:09:16,640
point ship is gonna go long and see okay

00:09:12,770 --> 00:09:19,700
so I have some passes sorry and so we

00:09:16,640 --> 00:09:21,710
can still deploy the first batch but

00:09:19,700 --> 00:09:26,540
after we do that unfortunately we get

00:09:21,710 --> 00:09:28,730
stuck and to make matters worse other

00:09:26,540 --> 00:09:30,230
people might not realize the master is

00:09:28,730 --> 00:09:33,200
broken right now and they're gonna

00:09:30,230 --> 00:09:34,520
continue merging so at this point we

00:09:33,200 --> 00:09:37,280
don't just have one or two failed pull

00:09:34,520 --> 00:09:39,310
requests but we now have a train of 10

00:09:37,280 --> 00:09:43,100
failed Pro class that we can't deploy

00:09:39,310 --> 00:09:45,230
and eventually you know the author is

00:09:43,100 --> 00:09:47,510
responsible and they notice that their

00:09:45,230 --> 00:09:50,060
change has broken master and they're

00:09:47,510 --> 00:09:54,100
gonna go ahead and merge a revert that

00:09:50,060 --> 00:09:57,500
goes on top of the stack which passes

00:09:54,100 --> 00:10:01,150
but we can't deploy any commits between

00:09:57,500 --> 00:10:04,640
four one five over there and the revert

00:10:01,150 --> 00:10:06,920
so when we do go ahead and deploy we end

00:10:04,640 --> 00:10:09,890
up the points gigantic batch of 11pro

00:10:06,920 --> 00:10:13,100
requests out to production that's not

00:10:09,890 --> 00:10:16,190
very nice and this brings us to our

00:10:13,100 --> 00:10:20,150
second problem which is master drifting

00:10:16,190 --> 00:10:22,460
from production so every time the

00:10:20,150 --> 00:10:25,010
conflict shows up master ends up further

00:10:22,460 --> 00:10:27,410
and further ahead of what is running in

00:10:25,010 --> 00:10:30,560
production right now and we call this

00:10:27,410 --> 00:10:31,910
phenomenon drift and it substantially

00:10:30,560 --> 00:10:35,540
increases the risk of the next

00:10:31,910 --> 00:10:37,820
deployment if this last batch deploys

00:10:35,540 --> 00:10:39,380
and something goes wrong we now have

00:10:37,820 --> 00:10:41,770
eleven potential pull requests that

00:10:39,380 --> 00:10:45,170
could have caused the problem in

00:10:41,770 --> 00:10:47,210
practice this number is even larger due

00:10:45,170 --> 00:10:49,700
to how fast our proquest our developers

00:10:47,210 --> 00:10:51,530
ship their pull requests so to an in

00:10:49,700 --> 00:10:54,650
order to ensure that we can deploy

00:10:51,530 --> 00:10:56,360
safely we have to control this drift to

00:10:54,650 --> 00:10:59,650
make sure the master is never too far

00:10:56,360 --> 00:10:59,650
ahead of production

00:11:02,210 --> 00:11:10,010
but really this is the problem even if

00:11:05,120 --> 00:11:13,070
all of our bills pass this is because we

00:11:10,010 --> 00:11:15,350
deploy everything in batches but what

00:11:13,070 --> 00:11:17,300
happens if something breaks and we need

00:11:15,350 --> 00:11:21,950
to ship something to production right

00:11:17,300 --> 00:11:25,399
now we can go ahead and merge our

00:11:21,950 --> 00:11:28,310
emergency fix but again it ends up at

00:11:25,399 --> 00:11:31,910
the top of master and we run to the same

00:11:28,310 --> 00:11:34,459
problem we can't deploy fast enough and

00:11:31,910 --> 00:11:37,459
now we have to go ahead and deploy a

00:11:34,459 --> 00:11:39,820
large batch of changes to go out just so

00:11:37,459 --> 00:11:42,440
the emergency fix can make its way out

00:11:39,820 --> 00:11:46,160
now we've just introduced a lot of risk

00:11:42,440 --> 00:11:47,540
and after an emergency fix it's possible

00:11:46,160 --> 00:11:48,589
that one of the other ten pull requests

00:11:47,540 --> 00:11:51,320
might have introduced a different

00:11:48,589 --> 00:11:59,690
problem and now we are in a cycle or

00:11:51,320 --> 00:12:02,630
we're constantly fixing new failures so

00:11:59,690 --> 00:12:04,160
a fun bit of history about Shopify every

00:12:02,630 --> 00:12:06,020
year we do something called call code

00:12:04,160 --> 00:12:08,510
freeze in the week leading up to Black

00:12:06,020 --> 00:12:10,640
Friday this is to ensure that our

00:12:08,510 --> 00:12:12,410
systems are stable then the busiest time

00:12:10,640 --> 00:12:14,860
of the year and merchants don't have

00:12:12,410 --> 00:12:19,880
their tools changing out from under them

00:12:14,860 --> 00:12:22,459
but on the next Tuesday we have to merge

00:12:19,880 --> 00:12:23,810
all of the changes that developers have

00:12:22,459 --> 00:12:27,680
been working on during the code freeze

00:12:23,810 --> 00:12:29,860
and in order to coordinate this without

00:12:27,680 --> 00:12:32,450
flooding master again to prevent drift

00:12:29,860 --> 00:12:35,540
we asked developers to add their poor

00:12:32,450 --> 00:12:37,790
request to a milestone and then we will

00:12:35,540 --> 00:12:39,529
go ahead and we will slowly merge a pro

00:12:37,790 --> 00:12:40,959
request and make sure they come out and

00:12:39,529 --> 00:12:46,400
save batches

00:12:40,959 --> 00:12:47,990
this was 2016 so the next year we did

00:12:46,400 --> 00:12:50,959
not want to do that again

00:12:47,990 --> 00:12:53,120
and our solution was to build the first

00:12:50,959 --> 00:12:57,110
iteration of what we called the merge

00:12:53,120 --> 00:12:58,910
queue so the first thing that changes

00:12:57,110 --> 00:13:00,800
with this approach is that now

00:12:58,910 --> 00:13:03,800
developers add their paw request to a

00:13:00,800 --> 00:13:07,459
queue rather than going directly into

00:13:03,800 --> 00:13:09,440
master we created a Chrome extension

00:13:07,459 --> 00:13:12,380
that adds this add to merge queue button

00:13:09,440 --> 00:13:14,480
to every single pull request so that the

00:13:12,380 --> 00:13:16,760
experience fill feels familiar to the

00:13:14,480 --> 00:13:21,660
github experience

00:13:16,760 --> 00:13:23,280
and when that button is pressed the PR

00:13:21,660 --> 00:13:26,430
gets added to a queue in a system that

00:13:23,280 --> 00:13:28,650
we maintain and just like in the

00:13:26,430 --> 00:13:30,420
previous case everyone else can merge

00:13:28,650 --> 00:13:35,130
the proto class as well and they'll end

00:13:30,420 --> 00:13:37,440
up in the same queue now once we have

00:13:35,130 --> 00:13:39,540
some items in the queue we will go ahead

00:13:37,440 --> 00:13:44,090
and slowly merge everything to master

00:13:39,540 --> 00:13:46,350
using the github API the benefit of this

00:13:44,090 --> 00:13:48,690
immediate queue though is that we're

00:13:46,350 --> 00:13:53,460
able to now programmatically control the

00:13:48,690 --> 00:13:55,080
flow of merges going into master so the

00:13:53,460 --> 00:13:57,960
control looks at master in production

00:13:55,080 --> 00:14:01,370
and if master starts to get too far

00:13:57,960 --> 00:14:04,380
ahead it will actually pause the merging

00:14:01,370 --> 00:14:07,080
so let's say that we have a queue and we

00:14:04,380 --> 00:14:08,730
want a maximum drift of 3 which means

00:14:07,080 --> 00:14:10,470
that we don't ever want to have more

00:14:08,730 --> 00:14:13,500
than 3 undeployed pull request

00:14:10,470 --> 00:14:15,450
sitting and master the merge queue here

00:14:13,500 --> 00:14:18,120
is going to merge three of the poor

00:14:15,450 --> 00:14:22,980
quest to master and that the other to

00:14:18,120 --> 00:14:24,780
sit in the queue and once the pork ass

00:14:22,980 --> 00:14:28,200
get merged that is when we start to

00:14:24,780 --> 00:14:31,110
master CI so this part uses the same

00:14:28,200 --> 00:14:33,120
logic as a previous solution where we go

00:14:31,110 --> 00:14:34,890
ahead and run CI once it's emerged and

00:14:33,120 --> 00:14:40,680
things will start deploying to

00:14:34,890 --> 00:14:42,720
production once this CI succeeds now one

00:14:40,680 --> 00:14:45,540
very useful feature of this merge queue

00:14:42,720 --> 00:14:49,800
is the ability to lock or pause merges

00:14:45,540 --> 00:14:52,410
temporarily so a thing back to the

00:14:49,800 --> 00:14:54,960
emergency case if an emergency poor

00:14:52,410 --> 00:14:56,430
request needs to go out right now we can

00:14:54,960 --> 00:14:58,710
make sure that it can go out in

00:14:56,430 --> 00:15:02,089
isolation or with very little other

00:14:58,710 --> 00:15:04,920
changes in this helps mitigate risk and

00:15:02,089 --> 00:15:06,600
this very simple mechanism worked very

00:15:04,920 --> 00:15:08,880
well and they gave us a lot of control

00:15:06,600 --> 00:15:12,240
over the rate in which we were merging

00:15:08,880 --> 00:15:16,280
to master unfortunately it wasn't

00:15:12,240 --> 00:15:16,280
perfect and it did have some drawbacks

00:15:16,370 --> 00:15:22,940
the first drawback was it was just

00:15:19,800 --> 00:15:22,940
really slow

00:15:24,420 --> 00:15:28,290
so let's go back to the previous example

00:15:26,280 --> 00:15:33,210
for a second where we had just merged

00:15:28,290 --> 00:15:35,550
three reporter class to master now while

00:15:33,210 --> 00:15:37,590
we wait for master CI on the 3 protists

00:15:35,550 --> 00:15:39,570
that we merged the other paw requests

00:15:37,590 --> 00:15:42,780
are sitting in the queue basically in

00:15:39,570 --> 00:15:46,080
limbo and if we assume that our CI takes

00:15:42,780 --> 00:15:48,240
30 minutes to run this means that the

00:15:46,080 --> 00:15:51,360
authors of 4 1 7 and 4 1 8 over there

00:15:48,240 --> 00:15:55,080
have to wait 30 minutes before CI even

00:15:51,360 --> 00:15:56,970
starts on their pour requests there's

00:15:55,080 --> 00:15:58,410
also no guarantee that after they weigh

00:15:56,970 --> 00:16:00,980
those 30 minutes and they merge to

00:15:58,410 --> 00:16:03,660
master that see I would pass after that

00:16:00,980 --> 00:16:06,090
so it could take up to an hour in this

00:16:03,660 --> 00:16:09,450
case just for them to find out that they

00:16:06,090 --> 00:16:10,740
had an issue and if you were later down

00:16:09,450 --> 00:16:13,100
in the queue there's more per class in

00:16:10,740 --> 00:16:15,350
there you would have to wait even longer

00:16:13,100 --> 00:16:20,310
hour and a half two hours three hours

00:16:15,350 --> 00:16:22,470
you never know and the second problem

00:16:20,310 --> 00:16:28,080
was that we had this browser extension

00:16:22,470 --> 00:16:29,670
now that we had to maintain so while the

00:16:28,080 --> 00:16:32,340
browser extension gave us a nice way to

00:16:29,670 --> 00:16:35,790
hook into the get WI it did come with a

00:16:32,340 --> 00:16:37,890
bag of his own issues new developers who

00:16:35,790 --> 00:16:40,440
don't have the extension installed would

00:16:37,890 --> 00:16:44,250
end up merging two master directly by

00:16:40,440 --> 00:16:46,350
accident skipping the line now in theory

00:16:44,250 --> 00:16:48,660
we could have disabled the ability to

00:16:46,350 --> 00:16:50,460
press the merge button at all but at the

00:16:48,660 --> 00:16:54,750
same time we want to keep that option

00:16:50,460 --> 00:16:55,890
available for emergencies the UI here

00:16:54,750 --> 00:16:58,380
was also a little bit difficult to

00:16:55,890 --> 00:17:00,930
extend and adding new features was

00:16:58,380 --> 00:17:05,250
non-trivial and that made it hard to be

00:17:00,930 --> 00:17:07,740
on top of an example is we would have no

00:17:05,250 --> 00:17:12,240
way of adding it to the github app that

00:17:07,740 --> 00:17:14,910
we just announced yesterday so this year

00:17:12,240 --> 00:17:16,650
we went back to the drawing board and we

00:17:14,910 --> 00:17:18,600
shipped the second iteration of the

00:17:16,650 --> 00:17:21,120
merge queue to address the shortcomings

00:17:18,600 --> 00:17:27,120
of the first version we call this one

00:17:21,120 --> 00:17:28,950
the v2 the first thing we did was we

00:17:27,120 --> 00:17:33,480
moved to a new way of interaction with

00:17:28,950 --> 00:17:35,670
the queue using comments so in every

00:17:33,480 --> 00:17:37,800
pull request developers are greeted by a

00:17:35,670 --> 00:17:39,000
message from our bot

00:17:37,800 --> 00:17:43,320
and I could give some simple

00:17:39,000 --> 00:17:45,090
instructions on how to use the Q and

00:17:43,320 --> 00:17:47,520
when developers are ready to share their

00:17:45,090 --> 00:17:50,730
pull requests they can issue the slash

00:17:47,520 --> 00:17:53,370
shipit comment to the poor request we'll

00:17:50,730 --> 00:17:55,410
go ahead receive the webhook and we'll

00:17:53,370 --> 00:17:57,720
run a few basic checks we want to make

00:17:55,410 --> 00:17:59,340
sure that branch CI has passed and that

00:17:57,720 --> 00:18:03,330
reviewers have approved the pull request

00:17:59,340 --> 00:18:06,060
and at the checks pass we go ahead and

00:18:03,330 --> 00:18:07,770
add the poor class to Q and we throw in

00:18:06,060 --> 00:18:11,910
little thumbs up emoji to get some

00:18:07,770 --> 00:18:13,470
feedback if the checks fail we will go

00:18:11,910 --> 00:18:19,440
ahead and add a comment to the pull

00:18:13,470 --> 00:18:21,600
request explaining the problem so our

00:18:19,440 --> 00:18:25,830
new pipeline now looks a little bit like

00:18:21,600 --> 00:18:29,640
this / if it on a poor requests now adds

00:18:25,830 --> 00:18:31,200
it to our new merge queue but at the

00:18:29,640 --> 00:18:32,820
same time we're not doing something

00:18:31,200 --> 00:18:35,370
smart with the internals of the queue as

00:18:32,820 --> 00:18:40,110
well so let's zoom in on that a little

00:18:35,370 --> 00:18:43,740
bit so here I have the inside of the

00:18:40,110 --> 00:18:45,810
second merge queue inside of this queue

00:18:43,740 --> 00:18:48,450
we've created something called a

00:18:45,810 --> 00:18:51,060
predictive branch which is kind of a

00:18:48,450 --> 00:18:53,670
fancy way of saying that we now have a

00:18:51,060 --> 00:18:56,730
sort of virtual candidate for what

00:18:53,670 --> 00:18:59,310
master could be and we base this off of

00:18:56,730 --> 00:19:01,220
the current master and we let's go ahead

00:18:59,310 --> 00:19:03,510
and save it and github as a branch so

00:19:01,220 --> 00:19:06,540
let's assume that master right now is

00:19:03,510 --> 00:19:11,730
pointed to a commit with sha 0 0 0 0

00:19:06,540 --> 00:19:14,190
just for simplicity and as poor class

00:19:11,730 --> 00:19:15,930
get added to the queue we go ahead and

00:19:14,190 --> 00:19:18,300
we create merge commits on this

00:19:15,930 --> 00:19:20,070
predictive branch using the merge branch

00:19:18,300 --> 00:19:23,820
graph gamma mutation for those poor

00:19:20,070 --> 00:19:25,620
requests and by creating this we

00:19:23,820 --> 00:19:30,420
actually are able to now have a branch

00:19:25,620 --> 00:19:32,610
that we can use to run CI so as more

00:19:30,420 --> 00:19:34,380
things get added to the queue we can

00:19:32,610 --> 00:19:37,350
cream merge commits for each of those

00:19:34,380 --> 00:19:39,600
poor requests as well and each of those

00:19:37,350 --> 00:19:44,250
in the queue would have their own CI

00:19:39,600 --> 00:19:46,710
status so what this does for us is that

00:19:44,250 --> 00:19:48,660
it allows us to run master CI inside of

00:19:46,710 --> 00:19:51,200
the merge queue rather than waiting for

00:19:48,660 --> 00:19:55,799
it to be merged to master first

00:19:51,200 --> 00:19:58,110
the predictive branch helps us serve as

00:19:55,799 --> 00:20:00,240
a possibility of what master could be

00:19:58,110 --> 00:20:02,220
but it still allows us the flexibility

00:20:00,240 --> 00:20:04,200
to continue to make changes to the

00:20:02,220 --> 00:20:09,539
branch such as removing something from

00:20:04,200 --> 00:20:10,919
the queue or changing the order so if we

00:20:09,539 --> 00:20:12,720
take a step out of the Murphy for a

00:20:10,919 --> 00:20:13,940
second the end product looks something

00:20:12,720 --> 00:20:16,110
like this

00:20:13,940 --> 00:20:18,450
plural class got added to the queue and

00:20:16,110 --> 00:20:21,570
now each of the poro class in the queue

00:20:18,450 --> 00:20:27,419
have a CI status before they even hit

00:20:21,570 --> 00:20:30,240
master now let's assume that we get some

00:20:27,419 --> 00:20:34,100
passing builds sweet we all like to see

00:20:30,240 --> 00:20:34,100
that oops sorry

00:20:38,149 --> 00:20:45,509
so how do we get this stuff onto master

00:20:42,049 --> 00:20:47,509
so this time instead of going ahead and

00:20:45,509 --> 00:20:50,070
merged in branches and stuff into master

00:20:47,509 --> 00:20:53,549
we're gonna instead fast forward our

00:20:50,070 --> 00:20:56,970
master branch to point to the last green

00:20:53,549 --> 00:20:59,009
merge commit so notice over here master

00:20:56,970 --> 00:21:01,409
one from zero zero zero and pointed

00:20:59,009 --> 00:21:03,870
directly to the Shah of the last passing

00:21:01,409 --> 00:21:07,950
for requests burst commit which is

00:21:03,870 --> 00:21:09,659
bbbbbb and this allows us to preserve

00:21:07,950 --> 00:21:11,220
the predictor branch ensuring that we

00:21:09,659 --> 00:21:14,399
don't throw away any of the in progress

00:21:11,220 --> 00:21:16,679
CI builds and also gives us a way to

00:21:14,399 --> 00:21:18,179
preserve all the statuses that were set

00:21:16,679 --> 00:21:23,100
on those merge commits that we created

00:21:18,179 --> 00:21:25,889
earlier and just like in the previous

00:21:23,100 --> 00:21:31,830
merge queue we're still able to control

00:21:25,889 --> 00:21:33,299
the flow of changes to master the new

00:21:31,830 --> 00:21:34,769
merge key works very well

00:21:33,299 --> 00:21:37,860
when we need to lock the queue during

00:21:34,769 --> 00:21:40,200
incidents so in these cases we can't

00:21:37,860 --> 00:21:45,570
merge things to master but we can still

00:21:40,200 --> 00:21:47,580
make progress on CI so in this case the

00:21:45,570 --> 00:21:50,460
queue is locked but the icons back green

00:21:47,580 --> 00:21:52,679
for our commits the queue is still

00:21:50,460 --> 00:21:54,539
locked so we can't merge anything but

00:21:52,679 --> 00:21:56,940
that's okay because once things get

00:21:54,539 --> 00:22:01,860
unlocked we can go ahead and ship those

00:21:56,940 --> 00:22:04,120
changes immediately so problem gets

00:22:01,860 --> 00:22:06,370
fixed the lock is green

00:22:04,120 --> 00:22:08,320
and we can go ahead and immediately

00:22:06,370 --> 00:22:13,720
fast-forward those commits into master

00:22:08,320 --> 00:22:15,850
and have them start deploying here's a

00:22:13,720 --> 00:22:18,190
graph of the mercy size after we

00:22:15,850 --> 00:22:20,590
launched the new merge queue so the

00:22:18,190 --> 00:22:23,500
first vertical line you see is when the

00:22:20,590 --> 00:22:25,390
queue got locked for an incident you can

00:22:23,500 --> 00:22:27,880
kind of see after the log happened the

00:22:25,390 --> 00:22:29,080
queue starts growing because of the pull

00:22:27,880 --> 00:22:32,530
requests that our developers have been

00:22:29,080 --> 00:22:34,800
adding to the merge queue at the second

00:22:32,530 --> 00:22:37,810
red line the queue gets unlocked and

00:22:34,800 --> 00:22:40,570
immediately we can go ahead drain and

00:22:37,810 --> 00:22:41,860
merge all of those poor quests into

00:22:40,570 --> 00:22:48,160
master and have them start deploying

00:22:41,860 --> 00:22:51,670
right away now what happens when CI

00:22:48,160 --> 00:22:53,230
fails so obviously we want to make sure

00:22:51,670 --> 00:22:55,390
that we can always have green commits it

00:22:53,230 --> 00:22:56,860
has four or two which means that we also

00:22:55,390 --> 00:23:02,050
have to get rid of the failures that we

00:22:56,860 --> 00:23:04,300
see so we got some bills here and let's

00:23:02,050 --> 00:23:08,310
assume that we have two passing bills

00:23:04,300 --> 00:23:13,300
which is nice but four one six here

00:23:08,310 --> 00:23:15,460
that was its fills at CI so since we

00:23:13,300 --> 00:23:17,230
have a failing built here we should

00:23:15,460 --> 00:23:19,000
probably remove four one six from the

00:23:17,230 --> 00:23:21,630
queue because we don't want anything

00:23:19,000 --> 00:23:27,730
else after two start failing as well

00:23:21,630 --> 00:23:30,400
unfortunately it's not so simple in our

00:23:27,730 --> 00:23:32,920
case here removals become very expensive

00:23:30,400 --> 00:23:35,140
because if we remove a pull request from

00:23:32,920 --> 00:23:38,290
the queue and means that the structure

00:23:35,140 --> 00:23:40,270
of the entire branch changes and so we

00:23:38,290 --> 00:23:44,850
actually have to throw away all of the

00:23:40,270 --> 00:23:48,490
work for all of the protests behind it

00:23:44,850 --> 00:23:51,180
also a single CI failure could be a very

00:23:48,490 --> 00:23:53,650
bad signal it's possible to have

00:23:51,180 --> 00:23:58,690
infrastructure issues with CI we've all

00:23:53,650 --> 00:24:03,790
seen those maybe flaky tests so it's not

00:23:58,690 --> 00:24:05,350
guaranteed sorry oh yeah so in this case

00:24:03,790 --> 00:24:08,560
over here we we don't know for sure if

00:24:05,350 --> 00:24:09,880
this is even breaking anything we're

00:24:08,560 --> 00:24:13,170
also gonna guarantee that it's gonna

00:24:09,880 --> 00:24:13,170
block later bills from passing

00:24:14,070 --> 00:24:18,159
so the simple solution that we went with

00:24:16,240 --> 00:24:21,279
which introduced a concept called the

00:24:18,159 --> 00:24:25,299
failure turns and this is a configurable

00:24:21,279 --> 00:24:27,190
per repo value that basically says how

00:24:25,299 --> 00:24:28,779
many successive failures do you need

00:24:27,190 --> 00:24:33,070
before you kick something out from the

00:24:28,779 --> 00:24:35,529
queue in our example here we can assume

00:24:33,070 --> 00:24:39,370
a failure tolerance of two which we can

00:24:35,529 --> 00:24:41,590
show using the red line this means that

00:24:39,370 --> 00:24:43,510
we can tolerate two failures but on the

00:24:41,590 --> 00:24:47,200
third failure we're gonna go ahead and

00:24:43,510 --> 00:24:49,440
eject for 1/6 from the queue so let's

00:24:47,200 --> 00:24:51,340
see what happens we got a second failure

00:24:49,440 --> 00:24:54,669
starting to get a little close but we're

00:24:51,340 --> 00:24:56,889
still okay but now we see a third

00:24:54,669 --> 00:24:59,470
failure so because from one six has now

00:24:56,889 --> 00:25:01,090
exceeded that failure tolerance we're

00:24:59,470 --> 00:25:04,690
gonna go ahead and remove it from the

00:25:01,090 --> 00:25:06,399
queue and in this case here because we

00:25:04,690 --> 00:25:08,139
remove something from the queue we now

00:25:06,399 --> 00:25:11,320
reset the CI status for everything

00:25:08,139 --> 00:25:13,330
behind it and you'll notice that the sha

00:25:11,320 --> 00:25:15,240
has changed as well because we have to

00:25:13,330 --> 00:25:21,130
go ahead and create new merge commits

00:25:15,240 --> 00:25:23,470
for those four requests in this case the

00:25:21,130 --> 00:25:28,990
third bill passed instead of failing we

00:25:23,470 --> 00:25:31,090
would have kept the tree as is so

00:25:28,990 --> 00:25:34,029
emergency merges so sometimes just

00:25:31,090 --> 00:25:37,139
second before we have an incident and we

00:25:34,029 --> 00:25:37,139
need to ship something out immediately

00:25:37,440 --> 00:25:43,169
to do this we created a special command

00:25:40,090 --> 00:25:45,880
called slash shipit - - emergency and

00:25:43,169 --> 00:25:49,029
this functions just like the default

00:25:45,880 --> 00:25:50,350
merge pull request button by issuing

00:25:49,029 --> 00:25:52,659
this command we're going to go ahead and

00:25:50,350 --> 00:25:55,389
merge that pull request directly into

00:25:52,659 --> 00:25:57,519
master and once that Perkis lands on

00:25:55,389 --> 00:26:00,519
master it's gonna go ahead and start its

00:25:57,519 --> 00:26:02,529
own CI at this point developers can whit

00:26:00,519 --> 00:26:04,480
can decide if they want to wait flat CI

00:26:02,529 --> 00:26:07,960
to finish or if they want to just go

00:26:04,480 --> 00:26:10,389
ahead and deploy immediately this

00:26:07,960 --> 00:26:12,909
command helps codify the cases from

00:26:10,389 --> 00:26:15,549
merging directly as being reserved for

00:26:12,909 --> 00:26:17,710
emergencies only and it also lets us

00:26:15,549 --> 00:26:20,190
audit how often this command gets used

00:26:17,710 --> 00:26:20,190
and why

00:26:22,050 --> 00:26:25,990
so as an example let's assume that our

00:26:24,280 --> 00:26:30,280
tree looks like this again to second the

00:26:25,990 --> 00:26:32,740
previous example and this time uh-oh we

00:26:30,280 --> 00:26:34,710
got a problem so something has broken

00:26:32,740 --> 00:26:38,980
production and now there's exceptions

00:26:34,710 --> 00:26:42,850
everywhere but don't worry this is fine

00:26:38,980 --> 00:26:45,940
a fix is created for the production

00:26:42,850 --> 00:26:48,490
problem and we can go ahead and slash

00:26:45,940 --> 00:26:52,450
ship it - - emergency to land it

00:26:48,490 --> 00:26:54,850
directly into master so we're here the

00:26:52,450 --> 00:26:59,920
master shop changes and CI starts for

00:26:54,850 --> 00:27:01,920
the commit we just merged in and now

00:26:59,920 --> 00:27:04,390
because master has changed our

00:27:01,920 --> 00:27:06,310
predictive branch has now diverged and

00:27:04,390 --> 00:27:08,950
is no longer compatible with the current

00:27:06,310 --> 00:27:11,080
master so what this means is we have to

00:27:08,950 --> 00:27:14,740
go ahead and create a new one and reset

00:27:11,080 --> 00:27:16,660
CI for everything in the queue so even

00:27:14,740 --> 00:27:19,090
though it's possible to ship things

00:27:16,660 --> 00:27:25,030
during emergencies and now it becomes a

00:27:19,090 --> 00:27:26,530
very disruptive process so we have a lot

00:27:25,030 --> 00:27:28,960
of things happening now under the hood

00:27:26,530 --> 00:27:31,540
of the numerous queue we have emergency

00:27:28,960 --> 00:27:33,880
fixes we have removals of failing PRS

00:27:31,540 --> 00:27:36,700
and there's a lot of things that can

00:27:33,880 --> 00:27:38,500
affect others so how do developers

00:27:36,700 --> 00:27:42,070
actually know what's going on with the

00:27:38,500 --> 00:27:43,300
state of their poor request so

00:27:42,070 --> 00:27:45,190
throughout the whole process we

00:27:43,300 --> 00:27:47,920
communicate everything through github

00:27:45,190 --> 00:27:49,930
checks so there's a status set on every

00:27:47,920 --> 00:27:52,570
poor request and clicking into the

00:27:49,930 --> 00:27:54,300
details page will give feedback on the

00:27:52,570 --> 00:27:57,490
state of their changes in the queue

00:27:54,300 --> 00:27:59,440
there CI statuses as well as a history

00:27:57,490 --> 00:28:05,110
of what happened to this for request as

00:27:59,440 --> 00:28:08,350
it's been going through the queue so to

00:28:05,110 --> 00:28:09,730
summarize we can take a look at some of

00:28:08,350 --> 00:28:13,300
the winds that the second merge queue

00:28:09,730 --> 00:28:15,460
gave us as well as some trade offs the

00:28:13,300 --> 00:28:18,700
first win is controlled updates to

00:28:15,460 --> 00:28:19,840
master so we're able to now prevent

00:28:18,700 --> 00:28:21,580
master from drifting too far from

00:28:19,840 --> 00:28:23,680
production because we can continue to

00:28:21,580 --> 00:28:29,230
limit the rate in which we merge our PO

00:28:23,680 --> 00:28:31,179
requests evergreen master so since we

00:28:29,230 --> 00:28:34,120
are only forwarding to commits with

00:28:31,179 --> 00:28:35,840
passing builds master will only ever go

00:28:34,120 --> 00:28:39,080
from passing state

00:28:35,840 --> 00:28:41,060
to passing state this helps local

00:28:39,080 --> 00:28:43,460
development so developers will never

00:28:41,060 --> 00:28:44,900
pull a failing master and will never

00:28:43,460 --> 00:28:47,560
have to coordinate fixing the master

00:28:44,900 --> 00:28:47,560
build ever again

00:28:48,100 --> 00:28:54,470
ci before merge so because we now build

00:28:52,010 --> 00:28:55,010
CI in the queue we can continue making

00:28:54,470 --> 00:28:57,110
progress

00:28:55,010 --> 00:28:59,750
even without things explicitly landing

00:28:57,110 --> 00:29:01,010
and master and this gives us higher

00:28:59,750 --> 00:29:03,110
throughput in times when the queue is

00:29:01,010 --> 00:29:07,760
locked or one master is getting too far

00:29:03,110 --> 00:29:10,760
ahead automatic removal of failed PRS in

00:29:07,760 --> 00:29:13,010
the queue so now we don't need humans to

00:29:10,760 --> 00:29:15,350
notice our problems and instead we can

00:29:13,010 --> 00:29:18,530
go ahead and message offending authors

00:29:15,350 --> 00:29:20,240
directly using robots this means less

00:29:18,530 --> 00:29:21,980
work for developers as a whole and

00:29:20,240 --> 00:29:26,840
there's also no more stress that the

00:29:21,980 --> 00:29:28,550
author is holding everyone up here some

00:29:26,840 --> 00:29:31,100
trade-offs removing a pair from the

00:29:28,550 --> 00:29:32,660
queue now resets the AI statuses so we

00:29:31,100 --> 00:29:35,360
talked a little about that removing is

00:29:32,660 --> 00:29:35,990
now very disruptive for now we're okay

00:29:35,360 --> 00:29:37,880
with this trade-off

00:29:35,990 --> 00:29:40,460
since breakages are still fairly

00:29:37,880 --> 00:29:41,930
uncommon but if too many rules happen

00:29:40,460 --> 00:29:43,160
this the queue will start on

00:29:41,930 --> 00:29:47,540
dramatically and we have to revisit this

00:29:43,160 --> 00:29:50,030
problem and skipping the queue resets

00:29:47,540 --> 00:29:52,310
our CI statuses the same problem as the

00:29:50,030 --> 00:29:54,890
previous trade-off the main case here is

00:29:52,310 --> 00:29:56,870
emergency merges and they are very

00:29:54,890 --> 00:30:02,270
disruptive because they reset CI for

00:29:56,870 --> 00:30:03,530
everyone so what's next so obviously we

00:30:02,270 --> 00:30:05,930
don't address on the trade-offs that are

00:30:03,530 --> 00:30:07,670
current solution has and one of the

00:30:05,930 --> 00:30:11,870
things we're thinking about is this idea

00:30:07,670 --> 00:30:14,060
called parallel trees so right now the

00:30:11,870 --> 00:30:16,070
reason why we have lots of shortcomings

00:30:14,060 --> 00:30:18,460
that we have is because we have a single

00:30:16,070 --> 00:30:20,990
predictive branch at any given time but

00:30:18,460 --> 00:30:23,210
what if we implement a parallel tree

00:30:20,990 --> 00:30:27,290
approach where we build multiple

00:30:23,210 --> 00:30:30,530
realities of what master could be so in

00:30:27,290 --> 00:30:32,410
this example here we had the 5 Pro

00:30:30,530 --> 00:30:35,390
requests we're talking about earlier and

00:30:32,410 --> 00:30:39,260
we have one tree that includes all 5 of

00:30:35,390 --> 00:30:41,150
them and then we build 5 additional

00:30:39,260 --> 00:30:43,640
trees where each of those additional

00:30:41,150 --> 00:30:47,990
trees is missing one of the poor

00:30:43,640 --> 00:30:49,540
requests out of the first 5 so we call

00:30:47,990 --> 00:30:52,330
this the one level

00:30:49,540 --> 00:30:54,910
of exclusion where basically we're

00:30:52,330 --> 00:30:58,000
saying that and most only one PR will be

00:30:54,910 --> 00:31:00,370
broken at a time in the most ideal world

00:30:58,000 --> 00:31:02,650
we would actually build one tree for

00:31:00,370 --> 00:31:05,830
every permutation of poor class in our

00:31:02,650 --> 00:31:07,690
queue but as you can imagine this

00:31:05,830 --> 00:31:11,860
carnality skyrockets and it's kind of

00:31:07,690 --> 00:31:14,559
hard to fit onto a slide so in this

00:31:11,860 --> 00:31:17,309
example over here if we assume that poor

00:31:14,559 --> 00:31:19,750
request for 1/4 introduces a breakage

00:31:17,309 --> 00:31:22,150
then we're gonna be ok because we have a

00:31:19,750 --> 00:31:24,340
tree here that didn't include for 1/4

00:31:22,150 --> 00:31:28,780
and so it will be successful when every

00:31:24,340 --> 00:31:31,299
other tree fails this makes it so that

00:31:28,780 --> 00:31:34,720
if there is a problem we can still make

00:31:31,299 --> 00:31:37,090
progress now we did try running this

00:31:34,720 --> 00:31:40,120
model in production for about a few days

00:31:37,090 --> 00:31:42,760
and we realized that even with this only

00:31:40,120 --> 00:31:48,040
one level of exclusion we were incurring

00:31:42,760 --> 00:31:49,299
too much load so going to the next year

00:31:48,040 --> 00:31:54,760
we want to find a way to do this that's

00:31:49,299 --> 00:31:56,500
smart and cheaper for us to run faster

00:31:54,760 --> 00:31:59,140
CI so we're also thinking about making

00:31:56,500 --> 00:32:01,530
CI faster because well that's kind of

00:31:59,140 --> 00:32:04,570
the part that's bounding us right now if

00:32:01,530 --> 00:32:06,640
we can make CI faster then the worst

00:32:04,570 --> 00:32:10,240
cases in our system won't be as bad and

00:32:06,640 --> 00:32:12,160
everything becomes faster as a whole so

00:32:10,240 --> 00:32:15,070
spoiler we do have a team working

00:32:12,160 --> 00:32:16,330
internally on this problem specifically

00:32:15,070 --> 00:32:18,010
they're looking and running a subset of

00:32:16,330 --> 00:32:20,320
our test suite each time I said the

00:32:18,010 --> 00:32:22,660
whole thing but we're still pretty early

00:32:20,320 --> 00:32:24,070
into this and so we don't have anything

00:32:22,660 --> 00:32:28,780
yet but we will share our findings when

00:32:24,070 --> 00:32:30,490
we can so earlier today we did release a

00:32:28,780 --> 00:32:32,530
more technical blog post to our

00:32:30,490 --> 00:32:35,350
engineering blog about the design of the

00:32:32,530 --> 00:32:39,220
actual key we built and if you want to

00:32:35,350 --> 00:32:41,260
learn more about what we're doing what

00:32:39,220 --> 00:32:43,320
we have done check out our engineering

00:32:41,260 --> 00:32:48,040
blog at engineering da choppah 5 calm

00:32:43,320 --> 00:32:49,600
and to be honest it's been hard for us

00:32:48,040 --> 00:32:52,090
to find other solving problems in this

00:32:49,600 --> 00:32:52,480
space and scale but if that does sound

00:32:52,090 --> 00:32:55,840
like you

00:32:52,480 --> 00:33:00,210
let's talk so me and my colleagues

00:32:55,840 --> 00:33:03,430
darren and willem over there are here

00:33:00,210 --> 00:33:04,780
all day and so please come find out

00:33:03,430 --> 00:33:08,590
and we love the chat and compare notes

00:33:04,780 --> 00:33:10,630
with you other than that thank you for

00:33:08,590 --> 00:33:12,280
the privilege of your time and enjoy the

00:33:10,630 --> 00:33:15,560
rest of the conference thank you

00:33:12,280 --> 00:33:43,940
[Applause]

00:33:15,560 --> 00:33:43,940

YouTube URL: https://www.youtube.com/watch?v=04TTRJArpVw


