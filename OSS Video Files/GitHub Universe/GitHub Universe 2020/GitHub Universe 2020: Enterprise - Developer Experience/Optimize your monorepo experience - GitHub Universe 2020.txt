Title: Optimize your monorepo experience - GitHub Universe 2020
Publication date: 2020-12-11
Playlist: GitHub Universe 2020: Enterprise - Developer Experience
Description: 
	Presented by Derrick Stolee, Staff Software Engineer, GitHub

Stolee is a core Git contributor and a member of the Git Client team at GitHub. This team supports Git at the largest scales by maintaining Git for Windows, Git Credential Manager Core, Scalar, and VFS for Git. These tools are critical pieces of the Git strategy for the Microsoft Windows and Microsoft Office monorepos.

For more from GitHub Universe 2020, visit https://githubuniverse.com

As always, feel free to leave us a comment below and don't forget to subscribe: http://bit.ly/subgithub

Thanks!

Connect with us.
Facebook: http://fb.com/github
Twitter: http://twitter.com/github
LinkedIn: http://linkedin.com/company/github

About GitHub
GitHub is the best place to share code with friends, co-workers, classmates, and complete strangers. Millions of people use GitHub to build amazing things together. For more info, go to http://github.com
Captions: 
	00:00:01,810 --> 00:00:11,890
[Music]

00:00:12,080 --> 00:00:16,720
thank you so much for that introduction

00:00:14,080 --> 00:00:18,720
and hello universe i'm excited to talk

00:00:16,720 --> 00:00:21,760
to you about how to optimize

00:00:18,720 --> 00:00:22,240
your monorepo experience i have a bunch

00:00:21,760 --> 00:00:24,080
of git

00:00:22,240 --> 00:00:25,840
tips that will help you structure your

00:00:24,080 --> 00:00:27,519
repositories

00:00:25,840 --> 00:00:29,119
these will be especially valuable if

00:00:27,519 --> 00:00:30,720
you're a system architect

00:00:29,119 --> 00:00:33,040
or otherwise running your engineering

00:00:30,720 --> 00:00:34,000
system and are already focused on making

00:00:33,040 --> 00:00:37,680
your developers

00:00:34,000 --> 00:00:39,600
and ci process more efficient

00:00:37,680 --> 00:00:41,600
before i get too far into the technical

00:00:39,600 --> 00:00:43,200
details i want to acknowledge that

00:00:41,600 --> 00:00:45,840
everything i talk about today

00:00:43,200 --> 00:00:47,680
is a community effort myself i'm a part

00:00:45,840 --> 00:00:49,360
of the get client team at github

00:00:47,680 --> 00:00:51,440
where we work to scale git to the

00:00:49,360 --> 00:00:52,879
largest repositories ever

00:00:51,440 --> 00:00:55,199
there are also contributions from the

00:00:52,879 --> 00:00:56,960
git contrib and git systems teams

00:00:55,199 --> 00:00:59,840
and contributions from the wider open

00:00:56,960 --> 00:00:59,840
source git community

00:01:00,000 --> 00:01:03,520
let's start by talking about your

00:01:01,359 --> 00:01:05,199
development ecosystem

00:01:03,520 --> 00:01:07,040
typically we think about developers

00:01:05,199 --> 00:01:08,400
producing and consuming source code as

00:01:07,040 --> 00:01:11,360
the primary actors

00:01:08,400 --> 00:01:13,360
in the development process however we

00:01:11,360 --> 00:01:14,640
need to think about how that code is

00:01:13,360 --> 00:01:17,280
delivered to the build and test

00:01:14,640 --> 00:01:20,560
infrastructure as well as to production

00:01:17,280 --> 00:01:22,000
or to customers via releases also keep

00:01:20,560 --> 00:01:22,880
in mind that leadership and other

00:01:22,000 --> 00:01:24,640
stakeholders

00:01:22,880 --> 00:01:26,720
are involved in planning and measuring

00:01:24,640 --> 00:01:28,799
developer outcomes

00:01:26,720 --> 00:01:30,720
all these different actors are connected

00:01:28,799 --> 00:01:32,560
via your git repository

00:01:30,720 --> 00:01:33,759
this includes your local clients your

00:01:32,560 --> 00:01:35,680
hosting solution

00:01:33,759 --> 00:01:37,759
and the protocol to communicate between

00:01:35,680 --> 00:01:39,119
them

00:01:37,759 --> 00:01:41,439
it's important to note that no one

00:01:39,119 --> 00:01:43,920
starts with millions of lines of code

00:01:41,439 --> 00:01:45,520
everything starts small it's as your

00:01:43,920 --> 00:01:48,000
repository evolves

00:01:45,520 --> 00:01:49,439
that it grows and continues growing at a

00:01:48,000 --> 00:01:52,479
faster and faster rate

00:01:49,439 --> 00:01:54,479
as your team grows

00:01:52,479 --> 00:01:56,159
if you started your project in git then

00:01:54,479 --> 00:01:59,119
you likely started small enough that you

00:01:56,159 --> 00:02:00,880
had no growing pains

00:01:59,119 --> 00:02:03,200
you could grow quickly without noticing

00:02:00,880 --> 00:02:05,200
any changes

00:02:03,200 --> 00:02:07,280
however as you grow large you start to

00:02:05,200 --> 00:02:09,759
push the boundaries of what git can do

00:02:07,280 --> 00:02:11,520
or grow in ways git is not designed for

00:02:09,759 --> 00:02:14,400
you start to feel some pushback in terms

00:02:11,520 --> 00:02:14,400
of slow commands

00:02:14,480 --> 00:02:18,000
then what happens if you continue

00:02:16,000 --> 00:02:20,400
growing without control you'll burst the

00:02:18,000 --> 00:02:22,319
limits of what git is capable of doing

00:02:20,400 --> 00:02:24,080
now my team's role is to grow what it

00:02:22,319 --> 00:02:25,840
can handle and we've already done a

00:02:24,080 --> 00:02:26,560
decent job of handling many scale

00:02:25,840 --> 00:02:29,040
factors

00:02:26,560 --> 00:02:30,400
that have historically been blockers

00:02:29,040 --> 00:02:31,920
there are still some remaining pain

00:02:30,400 --> 00:02:33,440
points that we want to address

00:02:31,920 --> 00:02:35,280
but we can only do so much when

00:02:33,440 --> 00:02:37,680
repositories grow too large in some

00:02:35,280 --> 00:02:39,120
dimensions

00:02:37,680 --> 00:02:40,879
let's also keep in mind that if your

00:02:39,120 --> 00:02:42,000
repository grew in a different version

00:02:40,879 --> 00:02:43,680
control system

00:02:42,000 --> 00:02:45,360
then perhaps your repository grew in

00:02:43,680 --> 00:02:46,800
ways that fit that container

00:02:45,360 --> 00:02:49,440
but do not fit well into a git

00:02:46,800 --> 00:02:51,200
repository it's important to recognize

00:02:49,440 --> 00:02:53,040
why you want to migrate to git

00:02:51,200 --> 00:02:57,360
but also which parts of your old version

00:02:53,040 --> 00:02:58,560
control system are not equivalent in git

00:02:57,360 --> 00:03:00,400
the most important thing i want to

00:02:58,560 --> 00:03:03,360
communicate today is that your

00:03:00,400 --> 00:03:05,120
choices matter you have agency in how

00:03:03,360 --> 00:03:08,000
your repository is structured

00:03:05,120 --> 00:03:08,000
and how it grows

00:03:08,159 --> 00:03:11,920
let me drop some universal advice for

00:03:10,080 --> 00:03:14,560
optimizing your code

00:03:11,920 --> 00:03:16,159
code never gets faster it can only do

00:03:14,560 --> 00:03:17,840
fewer things

00:03:16,159 --> 00:03:20,159
whether you're talking about taking an

00:03:17,840 --> 00:03:20,879
algorithm from order n squared to order

00:03:20,159 --> 00:03:23,280
n

00:03:20,879 --> 00:03:25,040
or just reducing that value of n

00:03:23,280 --> 00:03:25,840
everything is about executing fewer

00:03:25,040 --> 00:03:28,799
instructions

00:03:25,840 --> 00:03:30,480
or transferring less data it'll be a

00:03:28,799 --> 00:03:32,159
reoccurring theme in this talk that i

00:03:30,480 --> 00:03:33,680
will ask you to reduce the size of your

00:03:32,159 --> 00:03:36,000
git repositories

00:03:33,680 --> 00:03:37,920
or reduce what you're expecting your git

00:03:36,000 --> 00:03:39,200
repositories to do

00:03:37,920 --> 00:03:41,760
first you need to learn more about what

00:03:39,200 --> 00:03:43,760
git is doing in the first place

00:03:41,760 --> 00:03:44,959
in order to help you on your journey i'd

00:03:43,760 --> 00:03:46,879
like to dig into some git

00:03:44,959 --> 00:03:49,920
internals that will help us understand

00:03:46,879 --> 00:03:51,519
some advanced get features

00:03:49,920 --> 00:03:53,120
first let's talk about git's object

00:03:51,519 --> 00:03:55,760
model that is how does git

00:03:53,120 --> 00:03:56,640
store your data first you have object

00:03:55,760 --> 00:03:59,760
called commits

00:03:56,640 --> 00:04:02,560
which i will denote with circles

00:03:59,760 --> 00:04:03,680
represent snapshots and time as time

00:04:02,560 --> 00:04:06,480
moves forward

00:04:03,680 --> 00:04:07,680
left to right commits are added and they

00:04:06,480 --> 00:04:10,879
point back in time

00:04:07,680 --> 00:04:13,439
to previous snapshots

00:04:10,879 --> 00:04:14,959
each commit has a single root tree which

00:04:13,439 --> 00:04:16,720
is a snapshot of the files and

00:04:14,959 --> 00:04:18,000
directories directly within the root of

00:04:16,720 --> 00:04:22,479
your working directory

00:04:18,000 --> 00:04:24,400
i will use triangles to represent trees

00:04:22,479 --> 00:04:26,320
that root tree contains pointers to

00:04:24,400 --> 00:04:27,360
other objects which are trees for the

00:04:26,320 --> 00:04:30,479
subdirectories

00:04:27,360 --> 00:04:31,919
and blobs for the files i will use boxes

00:04:30,479 --> 00:04:34,080
to represent blobs

00:04:31,919 --> 00:04:35,040
notice the alliteration circles for

00:04:34,080 --> 00:04:39,199
commits

00:04:35,040 --> 00:04:41,120
triangles for trees and boxes for blobs

00:04:39,199 --> 00:04:43,120
as we recurse down subdirectories we

00:04:41,120 --> 00:04:45,840
expand more trees which point to other

00:04:43,120 --> 00:04:47,520
trees and blobs

00:04:45,840 --> 00:04:48,800
finally we have enough objects to

00:04:47,520 --> 00:04:52,560
completely describe the working

00:04:48,800 --> 00:04:55,120
directory expected at this commit

00:04:52,560 --> 00:04:56,080
as we walk back in time we can see other

00:04:55,120 --> 00:04:57,440
snapshots

00:04:56,080 --> 00:05:00,400
share some objects with this first

00:04:57,440 --> 00:05:02,400
snapshot these shared objects correspond

00:05:00,400 --> 00:05:05,199
to paths that have the same content

00:05:02,400 --> 00:05:06,320
between the two versions this allows git

00:05:05,199 --> 00:05:08,400
to efficiently store

00:05:06,320 --> 00:05:10,000
all of the snapshots without repeating

00:05:08,400 --> 00:05:11,440
identical content

00:05:10,000 --> 00:05:13,360
this is called a merkle tree

00:05:11,440 --> 00:05:15,840
representation for all of you blockchain

00:05:13,360 --> 00:05:18,160
nerds out there

00:05:15,840 --> 00:05:20,000
as we continue walking back in history

00:05:18,160 --> 00:05:21,919
we can see that every commit has a root

00:05:20,000 --> 00:05:23,280
tree and these trees form an interesting

00:05:21,919 --> 00:05:24,960
directed graph

00:05:23,280 --> 00:05:26,800
i will come back to this picture a few

00:05:24,960 --> 00:05:28,880
times so let's recall

00:05:26,800 --> 00:05:30,320
that circles represent commits these are

00:05:28,880 --> 00:05:32,639
points in time

00:05:30,320 --> 00:05:33,680
triangles represent trees these are

00:05:32,639 --> 00:05:36,840
directories

00:05:33,680 --> 00:05:39,840
and boxes represent blobs these are file

00:05:36,840 --> 00:05:39,840
contents

00:05:41,600 --> 00:05:44,800
when we examine a typical git repository

00:05:43,759 --> 00:05:47,039
by object type

00:05:44,800 --> 00:05:48,560
we see on the left a typical split by

00:05:47,039 --> 00:05:50,479
object count

00:05:48,560 --> 00:05:52,720
we typically see more trees than any

00:05:50,479 --> 00:05:54,000
other type and more blobs than commits

00:05:52,720 --> 00:05:56,800
because on average

00:05:54,000 --> 00:05:58,080
more than one file is changed per commit

00:05:56,800 --> 00:06:00,000
in the middle we have rectangles

00:05:58,080 --> 00:06:01,360
representing a good distribution of the

00:06:00,000 --> 00:06:04,000
size these objects take

00:06:01,360 --> 00:06:06,000
within the repository i used the linux

00:06:04,000 --> 00:06:07,680
kernel repository as a good example

00:06:06,000 --> 00:06:09,360
because git is designed for the kinds of

00:06:07,680 --> 00:06:11,120
changes done in the kernel

00:06:09,360 --> 00:06:13,520
we say that blobs take up a little bit

00:06:11,120 --> 00:06:15,919
more by proportion than their count

00:06:13,520 --> 00:06:17,360
this really relies on most files being

00:06:15,919 --> 00:06:20,400
plain text source code

00:06:17,360 --> 00:06:22,240
that change only a few lines at a time

00:06:20,400 --> 00:06:24,560
that allows git to delta compress the

00:06:22,240 --> 00:06:25,840
blobs very efficiently

00:06:24,560 --> 00:06:27,919
on the right i have what is

00:06:25,840 --> 00:06:29,360
unfortunately very typical when blobs

00:06:27,919 --> 00:06:31,440
contain binary assets

00:06:29,360 --> 00:06:32,800
or generally have large diffs and do not

00:06:31,440 --> 00:06:34,880
compress well

00:06:32,800 --> 00:06:36,400
in fact this ratio is not even as skewed

00:06:34,880 --> 00:06:39,600
as would happen if you regularly check

00:06:36,400 --> 00:06:39,600
in a binary executable

00:06:39,919 --> 00:06:43,039
to find out more about how large your

00:06:41,759 --> 00:06:45,600
repository may be

00:06:43,039 --> 00:06:47,039
check out the command line tool getsizer

00:06:45,600 --> 00:06:49,199
this tool will measure many different

00:06:47,039 --> 00:06:51,280
dimensions of size in your repository

00:06:49,199 --> 00:06:54,000
and also will give an opinion on how

00:06:51,280 --> 00:06:55,759
problematic that dimension may be

00:06:54,000 --> 00:06:57,599
give it a try today to see if you can

00:06:55,759 --> 00:07:00,400
quickly identify what's wrong with your

00:06:57,599 --> 00:07:00,400
repository

00:07:00,639 --> 00:07:03,919
looking back at this object model

00:07:02,080 --> 00:07:05,440
diagram it's important to notice that

00:07:03,919 --> 00:07:06,319
there are arrows from your recent

00:07:05,440 --> 00:07:08,479
commits

00:07:06,319 --> 00:07:09,680
following through your older commits and

00:07:08,479 --> 00:07:12,400
their trees

00:07:09,680 --> 00:07:14,080
to all of the blobs in your history this

00:07:12,400 --> 00:07:17,840
means that those old blobs

00:07:14,080 --> 00:07:17,840
are still causing you pain today

00:07:18,000 --> 00:07:21,840
think of sisyphus pushing the rock up

00:07:19,759 --> 00:07:22,560
the hill except occasionally he gets a

00:07:21,840 --> 00:07:24,160
new rock

00:07:22,560 --> 00:07:26,560
but all the older rocks are connected by

00:07:24,160 --> 00:07:28,479
a long chain he has to pull them all up

00:07:26,560 --> 00:07:30,800
the hill making progress even harder as

00:07:28,479 --> 00:07:32,240
he goes this is kind of what happens

00:07:30,800 --> 00:07:35,759
when you regularly check in large

00:07:32,240 --> 00:07:37,599
binaries into your repository

00:07:35,759 --> 00:07:39,120
so naturally my first recommendation is

00:07:37,599 --> 00:07:40,560
to remove large blobs from your

00:07:39,120 --> 00:07:42,960
repository

00:07:40,560 --> 00:07:44,000
one way to do this is with git lfs

00:07:42,960 --> 00:07:46,080
stands for large file

00:07:44,000 --> 00:07:47,360
storage which removes the large blobs

00:07:46,080 --> 00:07:49,360
from your git repository

00:07:47,360 --> 00:07:51,360
and places them in a secondary storage

00:07:49,360 --> 00:07:53,280
layer this allows your git object

00:07:51,360 --> 00:07:54,720
database to be more efficient

00:07:53,280 --> 00:07:56,720
but you still need to download those

00:07:54,720 --> 00:07:58,319
large blobs when you do a git checkout

00:07:56,720 --> 00:08:00,160
this means you have hidden the problem

00:07:58,319 --> 00:08:01,280
somewhat but is still there causing you

00:08:00,160 --> 00:08:02,879
pain

00:08:01,280 --> 00:08:04,800
the other way is to take any large

00:08:02,879 --> 00:08:06,240
binary dependencies and put them into a

00:08:04,800 --> 00:08:08,800
package management system

00:08:06,240 --> 00:08:11,120
such as ghetto packages if you need a

00:08:08,800 --> 00:08:12,879
binary to build or test your software

00:08:11,120 --> 00:08:14,720
then only download that binary when that

00:08:12,879 --> 00:08:16,720
build actually needs it

00:08:14,720 --> 00:08:18,639
cache these binaries locally but also in

00:08:16,720 --> 00:08:21,840
a way that a user can easily remove

00:08:18,639 --> 00:08:23,759
old packages when not needed generally

00:08:21,840 --> 00:08:27,120
my advice is to use package management

00:08:23,759 --> 00:08:29,440
whenever possible

00:08:27,120 --> 00:08:30,560
however that might be a difficult ask so

00:08:29,440 --> 00:08:33,599
that leads to my next

00:08:30,560 --> 00:08:35,039
hot take if you can't review it then

00:08:33,599 --> 00:08:36,800
delete it

00:08:35,039 --> 00:08:39,279
i mean that if you cannot review the

00:08:36,800 --> 00:08:40,800
changes to a file within a pull request

00:08:39,279 --> 00:08:43,760
then that file does not belong in your

00:08:40,800 --> 00:08:46,160
git repository it can go somewhere else

00:08:43,760 --> 00:08:47,920
remember git is designed to hold source

00:08:46,160 --> 00:08:49,839
code that means it's really good at

00:08:47,920 --> 00:08:51,279
plain text documents that change a few

00:08:49,839 --> 00:08:52,959
lines at a time

00:08:51,279 --> 00:08:54,720
you will never be able to review the

00:08:52,959 --> 00:08:56,720
change in a test data stream

00:08:54,720 --> 00:08:59,120
or in a binary executable needed for

00:08:56,720 --> 00:09:00,720
your build

00:08:59,120 --> 00:09:03,279
so let's think again about our friend

00:09:00,720 --> 00:09:06,880
sisyphus we want to lighten the load so

00:09:03,279 --> 00:09:09,120
pushing these rocks isn't so hard

00:09:06,880 --> 00:09:10,240
if we manage to remove the large blobs

00:09:09,120 --> 00:09:12,080
at the tip commit

00:09:10,240 --> 00:09:13,839
then sisyphus can pick up the rock and

00:09:12,080 --> 00:09:16,240
carry it more easily

00:09:13,839 --> 00:09:19,839
however the git history still has all

00:09:16,240 --> 00:09:19,839
those big blobs slowing them down

00:09:20,800 --> 00:09:24,160
a natural thing to consider is to

00:09:22,320 --> 00:09:26,080
rewrite the git commit history to not

00:09:24,160 --> 00:09:28,959
have any of those large blobs anymore

00:09:26,080 --> 00:09:30,560
this makes the history much lighter

00:09:28,959 --> 00:09:32,080
while this is the best option for

00:09:30,560 --> 00:09:33,839
optimizing your git data

00:09:32,080 --> 00:09:35,600
it is not always feasible because you

00:09:33,839 --> 00:09:36,000
will need to transfer all ongoing work

00:09:35,600 --> 00:09:38,240
to the new

00:09:36,000 --> 00:09:40,240
history and your rewritten commits in

00:09:38,240 --> 00:09:42,000
the new history will probably not build

00:09:40,240 --> 00:09:44,399
since they depend on those large binary

00:09:42,000 --> 00:09:44,399
assets

00:09:44,640 --> 00:09:48,080
what if we could lighten the weight by

00:09:46,240 --> 00:09:48,640
keeping the connections to those large

00:09:48,080 --> 00:09:50,320
blobs

00:09:48,640 --> 00:09:52,720
but not downloading those large blobs

00:09:50,320 --> 00:09:54,560
right away this is kind of a halfway

00:09:52,720 --> 00:09:57,920
point between rewriting history

00:09:54,560 --> 00:09:59,600
and keeping the large files forever

00:09:57,920 --> 00:10:01,680
the way to do this in the core git

00:09:59,600 --> 00:10:03,920
client is partial clone

00:10:01,680 --> 00:10:05,360
by adding the flag dash filter equals

00:10:03,920 --> 00:10:07,600
blob colon none

00:10:05,360 --> 00:10:09,279
into your git clone command you enable

00:10:07,600 --> 00:10:11,040
partial clone

00:10:09,279 --> 00:10:12,640
the remote may not understand partial

00:10:11,040 --> 00:10:13,600
clone and it might default to a full

00:10:12,640 --> 00:10:15,440
clone

00:10:13,600 --> 00:10:18,000
but the good news is partial clone is

00:10:15,440 --> 00:10:19,440
enabled on every github repository and

00:10:18,000 --> 00:10:22,399
in github enterprise server

00:10:19,440 --> 00:10:25,839
2.22 and later so go give it a try on

00:10:22,399 --> 00:10:25,839
your favorite repositories

00:10:26,480 --> 00:10:31,040
let's recall our object model graph in a

00:10:29,200 --> 00:10:33,040
full clone we need every reachable

00:10:31,040 --> 00:10:34,640
object that is if there's an arrow from

00:10:33,040 --> 00:10:38,399
a needed object to another

00:10:34,640 --> 00:10:38,399
then we also need that second object

00:10:38,560 --> 00:10:42,320
partial clone says don't give me any

00:10:40,800 --> 00:10:43,920
blobs i don't need

00:10:42,320 --> 00:10:45,680
so the initial clone downloads all

00:10:43,920 --> 00:10:48,399
reachable commits and trees

00:10:45,680 --> 00:10:50,160
but skips blobs that are not necessary

00:10:48,399 --> 00:10:52,000
when checking out the tip commit

00:10:50,160 --> 00:10:54,480
git makes a second request to find the

00:10:52,000 --> 00:10:56,320
blobs it needs for that checkout

00:10:54,480 --> 00:10:57,600
in the case where blobs make up a huge

00:10:56,320 --> 00:10:59,920
portion of the git data

00:10:57,600 --> 00:11:02,399
this can reduce your clone size by 10x

00:10:59,920 --> 00:11:02,399
or more

00:11:03,440 --> 00:11:08,000
i would be remiss if i didn't mention an

00:11:05,519 --> 00:11:09,760
older clone option called shallow clone

00:11:08,000 --> 00:11:11,120
here not all reachable commits are

00:11:09,760 --> 00:11:13,360
downloaded instead

00:11:11,120 --> 00:11:15,120
only the commit at tip and the trees and

00:11:13,360 --> 00:11:18,160
blobs reachable from the root tree

00:11:15,120 --> 00:11:20,480
are downloaded now this is less data

00:11:18,160 --> 00:11:21,920
than a partial clone but there's a catch

00:11:20,480 --> 00:11:23,760
you don't have access to the commit

00:11:21,920 --> 00:11:26,160
history so you'll have trouble

00:11:23,760 --> 00:11:28,160
using things like git log or git merge

00:11:26,160 --> 00:11:29,920
in fact even commands like get fetch

00:11:28,160 --> 00:11:32,480
will become much slower when run from a

00:11:29,920 --> 00:11:34,880
shallow clone

00:11:32,480 --> 00:11:35,920
this leads me to another hot take

00:11:34,880 --> 00:11:39,040
shallow clones

00:11:35,920 --> 00:11:40,640
should be thrown away

00:11:39,040 --> 00:11:42,959
i'm not saying that shallow clones don't

00:11:40,640 --> 00:11:43,920
have a purpose only that shallow clone

00:11:42,959 --> 00:11:46,640
should exist

00:11:43,920 --> 00:11:48,240
only for ephemeral builds for example if

00:11:46,640 --> 00:11:49,040
you're using a github actions public

00:11:48,240 --> 00:11:51,279
runner

00:11:49,040 --> 00:11:52,480
then you can't keep a repository across

00:11:51,279 --> 00:11:53,760
multiple builds

00:11:52,480 --> 00:11:56,079
instead you're going to throw that way

00:11:53,760 --> 00:11:58,160
that data anyway so you might as well

00:11:56,079 --> 00:12:00,000
use a shallow clone

00:11:58,160 --> 00:12:01,920
if you do have your own build machines

00:12:00,000 --> 00:12:02,560
that keep a repository across multiple

00:12:01,920 --> 00:12:04,160
builds

00:12:02,560 --> 00:12:06,240
then partial clone is an excellent

00:12:04,160 --> 00:12:10,720
option to optimize your build times in

00:12:06,240 --> 00:12:12,160
terms of the data they download

00:12:10,720 --> 00:12:14,000
after we focused on reducing the

00:12:12,160 --> 00:12:16,079
necessary data transferred due to your

00:12:14,000 --> 00:12:17,200
git history let's be mindful of the

00:12:16,079 --> 00:12:18,959
present

00:12:17,200 --> 00:12:20,800
let's focus on the working directory at

00:12:18,959 --> 00:12:22,800
your tip commit

00:12:20,800 --> 00:12:24,800
before a build your working directory

00:12:22,800 --> 00:12:26,079
matches exactly what your commit says it

00:12:24,800 --> 00:12:27,519
should contain

00:12:26,079 --> 00:12:31,600
the file contents in your working

00:12:27,519 --> 00:12:33,600
directory match the blobs it knows about

00:12:31,600 --> 00:12:35,440
but after you build you might have many

00:12:33,600 --> 00:12:36,560
new files appear that were generated by

00:12:35,440 --> 00:12:38,480
the build

00:12:36,560 --> 00:12:40,880
if these are located inside your working

00:12:38,480 --> 00:12:42,480
directory then git needs to inspect them

00:12:40,880 --> 00:12:43,440
and determine that they are not actually

00:12:42,480 --> 00:12:45,200
interesting

00:12:43,440 --> 00:12:47,920
this is typically done via dot get

00:12:45,200 --> 00:12:47,920
ignore files

00:12:48,000 --> 00:12:51,440
the more files your build generates the

00:12:49,760 --> 00:12:55,040
more work git needs to do in order to

00:12:51,440 --> 00:12:56,720
run git status or get add

00:12:55,040 --> 00:12:58,480
git needs to start walking directories

00:12:56,720 --> 00:13:00,639
to discover which files are new or

00:12:58,480 --> 00:13:02,480
modified

00:13:00,639 --> 00:13:04,079
as it walks it discovers all of these

00:13:02,480 --> 00:13:06,720
build files and compares them against

00:13:04,079 --> 00:13:08,480
the docket ignore patterns

00:13:06,720 --> 00:13:10,959
this leads to a lot of extra work that

00:13:08,480 --> 00:13:13,600
git needs to do even to report a clean

00:13:10,959 --> 00:13:15,680
git status

00:13:13,600 --> 00:13:16,639
this leads to my next hot take get

00:13:15,680 --> 00:13:19,360
ignore files

00:13:16,639 --> 00:13:21,279
should be tiny the get ignore feature

00:13:19,360 --> 00:13:22,480
uses an extremely flexible pattern

00:13:21,279 --> 00:13:24,399
recognition format

00:13:22,480 --> 00:13:26,160
and the issue here is that the paths

00:13:24,399 --> 00:13:29,120
must be checked against these patterns

00:13:26,160 --> 00:13:30,399
one by one in order this can lead to

00:13:29,120 --> 00:13:34,160
quadratic growth

00:13:30,399 --> 00:13:36,160
in the pattern recognition algorithm

00:13:34,160 --> 00:13:37,839
we recommend that to improve the

00:13:36,160 --> 00:13:38,880
situation you should push all of your

00:13:37,839 --> 00:13:41,279
build time outputs

00:13:38,880 --> 00:13:43,600
out of your working directory my

00:13:41,279 --> 00:13:47,519
projects typically clone into a repo

00:13:43,600 --> 00:13:48,800
src directory the src directory contains

00:13:47,519 --> 00:13:50,720
the dot get directory

00:13:48,800 --> 00:13:52,160
which indicates it is the root of my git

00:13:50,720 --> 00:13:54,000
repository

00:13:52,160 --> 00:13:56,000
anything outside this directory is not

00:13:54,000 --> 00:13:57,360
considered by git to be part of the repo

00:13:56,000 --> 00:13:59,279
so they don't need to be part of the

00:13:57,360 --> 00:14:01,120
getting nor files

00:13:59,279 --> 00:14:03,040
your build system might have an out

00:14:01,120 --> 00:14:04,480
directory for files it generates

00:14:03,040 --> 00:14:06,079
while a different directory contains

00:14:04,480 --> 00:14:06,800
packages downloaded from external

00:14:06,079 --> 00:14:10,320
sources

00:14:06,800 --> 00:14:10,320
such as npm or nuget

00:14:11,440 --> 00:14:16,560
speaking of builds having developers

00:14:13,760 --> 00:14:18,639
wait on builds is an age age-old problem

00:14:16,560 --> 00:14:20,560
you really want developers to be able to

00:14:18,639 --> 00:14:24,240
stay focused and not get distracted

00:14:20,560 --> 00:14:24,240
while waiting for an automated task

00:14:24,399 --> 00:14:28,000
for really large repositories it is

00:14:26,320 --> 00:14:29,440
critical to have a way for a developer

00:14:28,000 --> 00:14:30,560
working on a small slice of the

00:14:29,440 --> 00:14:33,760
repository

00:14:30,560 --> 00:14:35,600
to not need to build the entire cone one

00:14:33,760 --> 00:14:37,839
pattern i've seen and recommend

00:14:35,600 --> 00:14:39,600
is to use a flywheel pattern where

00:14:37,839 --> 00:14:40,480
multiple modules or services within your

00:14:39,600 --> 00:14:42,720
monorepo

00:14:40,480 --> 00:14:44,639
depend on some common code but don't

00:14:42,720 --> 00:14:46,240
need each other to build

00:14:44,639 --> 00:14:49,680
a way to make this possible is to have

00:14:46,240 --> 00:14:51,440
clear implementation contract boundaries

00:14:49,680 --> 00:14:53,360
to build each service we only need to

00:14:51,440 --> 00:14:54,560
know the contract that the other

00:14:53,360 --> 00:14:56,480
services provide

00:14:54,560 --> 00:14:57,760
not their implementation this can

00:14:56,480 --> 00:14:59,040
drastically speed up builds for

00:14:57,760 --> 00:15:00,720
individual developers

00:14:59,040 --> 00:15:02,079
while allowing build machines to handle

00:15:00,720 --> 00:15:05,519
the integration scenario

00:15:02,079 --> 00:15:05,519
in ci and pr builds

00:15:05,680 --> 00:15:09,600
so if you have such a structure to your

00:15:07,680 --> 00:15:12,959
build system then why would a developer

00:15:09,600 --> 00:15:14,880
need this full working directory

00:15:12,959 --> 00:15:16,720
instead a developer could focus their

00:15:14,880 --> 00:15:17,360
get repository on only the files they

00:15:16,720 --> 00:15:19,519
need

00:15:17,360 --> 00:15:20,959
in order to do their own work and their

00:15:19,519 --> 00:15:23,360
own builds

00:15:20,959 --> 00:15:25,120
in sparse checkout the get sparse

00:15:23,360 --> 00:15:26,160
checkout feature allows us to focus the

00:15:25,120 --> 00:15:28,000
working directory

00:15:26,160 --> 00:15:31,680
only to the files necessary for each

00:15:28,000 --> 00:15:33,040
role in your engineering team

00:15:31,680 --> 00:15:34,880
just some quick pointers to using the

00:15:33,040 --> 00:15:36,399
sparse checkout feature you can

00:15:34,880 --> 00:15:38,160
initialize a sparse checkout in an

00:15:36,399 --> 00:15:39,440
existing repository with git sparse

00:15:38,160 --> 00:15:41,759
checkout init dash

00:15:39,440 --> 00:15:43,920
cone you can set the sparse checkout

00:15:41,759 --> 00:15:45,440
definition using git sparse checkout set

00:15:43,920 --> 00:15:47,920
and listing the directories you care

00:15:45,440 --> 00:15:48,959
about you can also add directories in

00:15:47,920 --> 00:15:50,399
batches

00:15:48,959 --> 00:15:52,000
and you can disable sparse checkout

00:15:50,399 --> 00:15:53,040
quickly to get back to a full working

00:15:52,000 --> 00:15:54,959
directory

00:15:53,040 --> 00:15:58,480
for more information i recommend my blog

00:15:54,959 --> 00:15:58,480
post about the sparse checkout feature

00:15:59,040 --> 00:16:02,240
now let's combine our earlier

00:16:00,480 --> 00:16:03,920
recommendation of partial clones with a

00:16:02,240 --> 00:16:05,600
sparse checkout

00:16:03,920 --> 00:16:07,680
if we run the clone command here at the

00:16:05,600 --> 00:16:08,480
bottom it contains the partial clone

00:16:07,680 --> 00:16:10,800
flag

00:16:08,480 --> 00:16:12,399
the sparse flag and we'll clone into an

00:16:10,800 --> 00:16:14,079
src directory

00:16:12,399 --> 00:16:15,839
the end result is we get this object

00:16:14,079 --> 00:16:16,959
database where we have all reachable

00:16:15,839 --> 00:16:18,720
commits and trees

00:16:16,959 --> 00:16:22,560
and the only blobs are those immediately

00:16:18,720 --> 00:16:24,800
in the root of the working directory

00:16:22,560 --> 00:16:26,399
by adding a subdirectory we care about

00:16:24,800 --> 00:16:28,240
to the sparse checkout definition

00:16:26,399 --> 00:16:29,759
we see that git adds those blobs within

00:16:28,240 --> 00:16:31,360
those directories but not the

00:16:29,759 --> 00:16:33,199
directories outside

00:16:31,360 --> 00:16:34,839
this allows users to have a much smaller

00:16:33,199 --> 00:16:37,839
footprint when working with their

00:16:34,839 --> 00:16:37,839
repositories

00:16:37,920 --> 00:16:42,639
however i must now lean upon you we

00:16:41,040 --> 00:16:44,639
built the sparse checkout feature to

00:16:42,639 --> 00:16:46,000
help users who are in this situation

00:16:44,639 --> 00:16:48,480
of not needing the full working

00:16:46,000 --> 00:16:49,600
directory if they have it set up to do

00:16:48,480 --> 00:16:51,839
so

00:16:49,600 --> 00:16:53,519
someone needs to tell git which

00:16:51,839 --> 00:16:54,800
directories are important

00:16:53,519 --> 00:16:56,560
this means that there's a connection

00:16:54,800 --> 00:16:59,120
missing between your build system

00:16:56,560 --> 00:17:00,800
and sparse checkout how can we integrate

00:16:59,120 --> 00:17:01,759
sparse checkout into existing build

00:17:00,800 --> 00:17:03,600
systems

00:17:01,759 --> 00:17:07,280
i'm calling on you to build this and

00:17:03,600 --> 00:17:07,280
contribute it to your community

00:17:08,000 --> 00:17:11,360
hopefully you've learned a trick or two

00:17:09,520 --> 00:17:12,880
about get today and recognize how

00:17:11,360 --> 00:17:14,079
problems you are already solving to

00:17:12,880 --> 00:17:15,839
speed up your builds

00:17:14,079 --> 00:17:17,360
have parallels to speed up your get

00:17:15,839 --> 00:17:19,679
operations

00:17:17,360 --> 00:17:21,679
if you use all of these features then

00:17:19,679 --> 00:17:25,520
you are truly at the forefront of git

00:17:21,679 --> 00:17:25,520
at scale you are leading the way

00:17:26,000 --> 00:17:29,200
as you lead the way you will be well

00:17:27,679 --> 00:17:31,120
poised to take advantage of new git

00:17:29,200 --> 00:17:32,960
features as they come out

00:17:31,120 --> 00:17:34,640
keep up to date with the latest by

00:17:32,960 --> 00:17:36,559
following the github blog

00:17:34,640 --> 00:17:38,160
we regularly update the community on new

00:17:36,559 --> 00:17:39,039
git features that come out with every

00:17:38,160 --> 00:17:41,280
release

00:17:39,039 --> 00:17:44,840
we do deep dives on important features

00:17:41,280 --> 00:17:46,080
and have some other important content as

00:17:44,840 --> 00:17:47,600
well

00:17:46,080 --> 00:17:49,280
example i wanted to leave you with a

00:17:47,600 --> 00:17:51,679
teaser of an upcoming get feature

00:17:49,280 --> 00:17:52,880
background maintenance we are working to

00:17:51,679 --> 00:17:54,480
deliver the ability

00:17:52,880 --> 00:17:56,799
to easily schedule maintenance on your

00:17:54,480 --> 00:17:58,799
git repositories in the background

00:17:56,799 --> 00:18:00,240
so you never get blocked on a git gc

00:17:58,799 --> 00:18:01,919
auto again

00:18:00,240 --> 00:18:03,919
this will keep your repositories running

00:18:01,919 --> 00:18:05,039
smoothly without blocking user facing

00:18:03,919 --> 00:18:08,640
commands

00:18:05,039 --> 00:18:08,640
so look forward to this coming soon

00:18:08,880 --> 00:18:12,960
and now you might be thinking that was a

00:18:10,799 --> 00:18:14,960
lot of new information

00:18:12,960 --> 00:18:17,200
well i personally think everyone who

00:18:14,960 --> 00:18:19,520
takes the time to become a get expert

00:18:17,200 --> 00:18:21,120
will reap rewards in their productivity

00:18:19,520 --> 00:18:22,640
there's not always enough time

00:18:21,120 --> 00:18:24,240
in the day to learn all the things you

00:18:22,640 --> 00:18:25,919
want to learn

00:18:24,240 --> 00:18:27,280
add on top the burden of trying to keep

00:18:25,919 --> 00:18:28,799
up the latest get features and

00:18:27,280 --> 00:18:32,080
evaluating them for yourself

00:18:28,799 --> 00:18:35,280
and there's even less time what if there

00:18:32,080 --> 00:18:35,280
was an easier way

00:18:35,440 --> 00:18:39,280
well the good news is that the scalar

00:18:37,120 --> 00:18:41,679
project might be able to help

00:18:39,280 --> 00:18:43,520
scaler is a thin wrapper around git that

00:18:41,679 --> 00:18:44,559
helps you set up repositories that have

00:18:43,520 --> 00:18:46,880
already opted in

00:18:44,559 --> 00:18:48,400
to the latest and greatest features you

00:18:46,880 --> 00:18:50,000
can go to the github page to see the

00:18:48,400 --> 00:18:54,840
source code and installation

00:18:50,000 --> 00:18:56,240
instructions for windows mac os and now

00:18:54,840 --> 00:18:58,160
linux

00:18:56,240 --> 00:18:59,760
most users would be interested in using

00:18:58,160 --> 00:19:02,160
the scalar clone command

00:18:59,760 --> 00:19:04,160
which creates your repo in a dedicated

00:19:02,160 --> 00:19:05,760
src directory

00:19:04,160 --> 00:19:06,880
it defaults to partial clones so you

00:19:05,760 --> 00:19:08,880
don't have to remember the special

00:19:06,880 --> 00:19:11,039
syntax

00:19:08,880 --> 00:19:12,559
it defaults to a sparse checkout so you

00:19:11,039 --> 00:19:14,160
keep your initial download as small as

00:19:12,559 --> 00:19:15,760
possible

00:19:14,160 --> 00:19:18,640
and it sets up background maintenance

00:19:15,760 --> 00:19:20,160
for you it already has that feature

00:19:18,640 --> 00:19:22,880
finally it initializes some other

00:19:20,160 --> 00:19:25,840
recommended advanced git config settings

00:19:22,880 --> 00:19:27,600
some of these are really deep cuts

00:19:25,840 --> 00:19:28,080
further as the new versions of git come

00:19:27,600 --> 00:19:30,160
out

00:19:28,080 --> 00:19:31,520
we update scalar to take advantage of

00:19:30,160 --> 00:19:33,039
the latest get features

00:19:31,520 --> 00:19:35,440
and update your repositories

00:19:33,039 --> 00:19:39,280
automatically with that upgrade

00:19:35,440 --> 00:19:41,679
so go and give it a try today

00:19:39,280 --> 00:19:42,320
thank you so much for your time now get

00:19:41,679 --> 00:19:46,799
out there

00:19:42,320 --> 00:19:46,799

YouTube URL: https://www.youtube.com/watch?v=RcqLV1lU408


