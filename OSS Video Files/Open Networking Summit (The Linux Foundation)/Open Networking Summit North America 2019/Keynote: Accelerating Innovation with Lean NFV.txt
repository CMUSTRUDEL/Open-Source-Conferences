Title: Keynote: Accelerating Innovation with Lean NFV
Publication date: 2019-04-18
Playlist: Open Networking Summit North America 2019
Description: 
	Keynote: Accelerating Innovation with Lean NFV - Scott Shenker, Professor of Computer Science, UC Berkeley; Sylvia Ratnasamy, Associate Professor of Computer Science, UC Berkeley & CTO, Nefeli Networks; Constantine Polychronopoulos, VP & CTO, VMware

Network Function Virtualization (NFV) technology has the potential to revolutionize the networking industry, yet the promise of NFV remains largely unfulfilled. Many NFV efforts today are plagued with complexity across deployment, automation and operation. At the same time, on-boarding virtualized network functions (VNFs) continues to be time-consuming and frustrating. LeanNFV is an open architecture that takes a minimalist approach to integration, enabling superior time-to-market, efficiency and automation. In this keynote, we will describe the impetus behind LeanNFV, what LeanNFV is and how to get involved.

Speakers

Scott Shenker
Professor of Computer Science, UC Berkeley

Sylvia Ratnasamy
Associate Professor of Computer Science & CTO, UC Berkeley & Nefeli Networks

Constantine Polychronopoulos
VP & CTO, TelcoBU, VMware
Captions: 
	00:00:04,610 --> 00:00:07,690
thank you very much

00:00:09,850 --> 00:00:15,050
so thank you very much and good

00:00:11,900 --> 00:00:17,720
afternoon so here we are six years after

00:00:15,050 --> 00:00:20,840
the nfe white paper and we've definitely

00:00:17,720 --> 00:00:23,510
had made some progress in terms of an

00:00:20,840 --> 00:00:25,520
architecture and code bases but we have

00:00:23,510 --> 00:00:28,369
to admit that we have very serious

00:00:25,520 --> 00:00:30,529
problems that the rate of adoption in

00:00:28,369 --> 00:00:32,510
the rate of innovation is much slower

00:00:30,529 --> 00:00:33,290
than anybody who would have thought six

00:00:32,510 --> 00:00:37,730
years ago

00:00:33,290 --> 00:00:41,120
and this poses a paradox which is why is

00:00:37,730 --> 00:00:43,970
this been so hard this is a paradox

00:00:41,120 --> 00:00:46,190
because nfe involves three basic

00:00:43,970 --> 00:00:48,680
components there's an infrastructure

00:00:46,190 --> 00:00:52,340
manager that oversees the computational

00:00:48,680 --> 00:00:53,750
infrastructure there are vnf that are

00:00:52,340 --> 00:00:55,700
largely based on existing

00:00:53,750 --> 00:00:57,950
implementations so we know how to do

00:00:55,700 --> 00:01:00,860
these things these aren't new then

00:00:57,950 --> 00:01:04,039
there's a third piece which is the nfe

00:01:00,860 --> 00:01:06,740
manager which oversees lifecycle for

00:01:04,039 --> 00:01:09,770
both the NFS and service chains this is

00:01:06,740 --> 00:01:12,830
new it's not a trivial problem but it's

00:01:09,770 --> 00:01:15,830
not a six year hard problem so what has

00:01:12,830 --> 00:01:18,350
been so hard for us and the answer is

00:01:15,830 --> 00:01:20,209
integration is the hard problem these

00:01:18,350 --> 00:01:22,130
individual components these three

00:01:20,209 --> 00:01:24,319
components by themselves are not that

00:01:22,130 --> 00:01:27,470
hard but we've connected these

00:01:24,319 --> 00:01:30,619
components in complicated ways and we've

00:01:27,470 --> 00:01:33,020
made two fundamental errors first we

00:01:30,619 --> 00:01:35,720
embed identity management in the compute

00:01:33,020 --> 00:01:38,539
infrastructure and second we made it so

00:01:35,720 --> 00:01:41,810
that new features often require changes

00:01:38,539 --> 00:01:45,050
in the pairwise API so this set of

00:01:41,810 --> 00:01:46,759
decisions makes deployment hard because

00:01:45,050 --> 00:01:49,280
you have to change your infrastructure

00:01:46,759 --> 00:01:52,310
it makes onboarding even harder because

00:01:49,280 --> 00:01:54,619
how can you build a vnf that integrates

00:01:52,310 --> 00:01:57,259
smoothly into such an infrastructure and

00:01:54,619 --> 00:01:59,000
it makes innovation almost impossible

00:01:57,259 --> 00:02:01,489
because these three components are now

00:01:59,000 --> 00:02:06,099
so tightly woven together that it's hard

00:02:01,489 --> 00:02:09,920
to innovate so how do we fix this

00:02:06,099 --> 00:02:12,470
so the answer is to look first at

00:02:09,920 --> 00:02:14,480
integration solve that problem first

00:02:12,470 --> 00:02:17,239
before we worry about the components and

00:02:14,480 --> 00:02:20,629
to solve integration we do it in three

00:02:17,239 --> 00:02:22,970
steps first as we will describe later we

00:02:20,629 --> 00:02:25,910
provide a universal integration back

00:02:22,970 --> 00:02:28,940
which is a key value store the second is

00:02:25,910 --> 00:02:31,400
we do not require nfe specific features

00:02:28,940 --> 00:02:33,830
in the vin and the third and the most

00:02:31,400 --> 00:02:38,150
important step is we knew when to stop

00:02:33,830 --> 00:02:40,490
that's all we need to do if we do these

00:02:38,150 --> 00:02:41,180
free things we leave the rest of the

00:02:40,490 --> 00:02:44,090
design

00:02:41,180 --> 00:02:46,730
open for innovation the components can

00:02:44,090 --> 00:02:49,760
evolve independently deployment barriers

00:02:46,730 --> 00:02:51,800
are greatly reduced and this creates a

00:02:49,760 --> 00:02:54,560
lien that is no additional and

00:02:51,800 --> 00:02:56,240
unnecessary complication and extensible

00:02:54,560 --> 00:02:58,610
you can add new features without

00:02:56,240 --> 00:03:01,040
breaking anything and multi-vendor if

00:02:58,610 --> 00:03:03,380
you have solved the integration problem

00:03:01,040 --> 00:03:06,770
then your components can come from

00:03:03,380 --> 00:03:08,240
different vendors so I'm not going to

00:03:06,770 --> 00:03:09,650
tell you how this actually works in

00:03:08,240 --> 00:03:13,300
practice I'm going to leave this for my

00:03:09,650 --> 00:03:13,300
colleague Silvia and Asami

00:03:14,260 --> 00:03:20,190
[Applause]

00:03:17,450 --> 00:03:22,920
thanks doc so I'm going to pick up

00:03:20,190 --> 00:03:24,180
exactly where Scott left off so Scott

00:03:22,920 --> 00:03:27,060
talked about we have three basic

00:03:24,180 --> 00:03:29,190
components and he pointed at integration

00:03:27,060 --> 00:03:31,590
and in particular simplifying

00:03:29,190 --> 00:03:33,840
integration as the problem we should

00:03:31,590 --> 00:03:35,790
focus on so I'm going to take my time to

00:03:33,840 --> 00:03:37,920
talk a little bit about the proposal at

00:03:35,790 --> 00:03:40,530
a pretty high level what our proposal is

00:03:37,920 --> 00:03:42,270
for how we do the simplification and to

00:03:40,530 --> 00:03:44,760
get straight to the point what we're

00:03:42,270 --> 00:03:47,190
proposing is add one component to this

00:03:44,760 --> 00:03:49,290
picture and that's a key value store and

00:03:47,190 --> 00:03:51,660
that key value store is going to act as

00:03:49,290 --> 00:03:55,140
a single universal point of integration

00:03:51,660 --> 00:03:57,360
for all components so before I go ahead

00:03:55,140 --> 00:03:59,220
let me just a quick refresher a key

00:03:57,360 --> 00:04:01,860
value store is exactly what it sounds

00:03:59,220 --> 00:04:04,140
like it's a data store that stores keys

00:04:01,860 --> 00:04:07,020
with their Associated values and you

00:04:04,140 --> 00:04:10,080
have api's to add keys to look up keys

00:04:07,020 --> 00:04:12,300
to watch for changes to keys there many

00:04:10,080 --> 00:04:13,860
open-source implementations of these key

00:04:12,300 --> 00:04:15,720
value systems they've been widely

00:04:13,860 --> 00:04:18,000
deployed over the years and production

00:04:15,720 --> 00:04:20,640
perhaps the best-known the most famous

00:04:18,000 --> 00:04:22,020
is the system called Etsy D which is the

00:04:20,640 --> 00:04:24,210
key value store that's used in

00:04:22,020 --> 00:04:27,390
kubernetes deployed at Google Salesforce

00:04:24,210 --> 00:04:30,210
etc and so with that the natural

00:04:27,390 --> 00:04:32,310
question why a key value store and the

00:04:30,210 --> 00:04:34,590
reason is because you know if you cut to

00:04:32,310 --> 00:04:36,960
all of the api's message syntax

00:04:34,590 --> 00:04:39,060
protocols and so on the essence of

00:04:36,960 --> 00:04:41,610
integration is really allowing different

00:04:39,060 --> 00:04:44,610
components to discover and to exchange

00:04:41,610 --> 00:04:46,350
State and so in our context it state

00:04:44,610 --> 00:04:48,990
like what is the configuration of the

00:04:46,350 --> 00:04:51,570
vnf what resources are available at a

00:04:48,990 --> 00:04:55,410
node what is the load on the V switch on

00:04:51,570 --> 00:04:57,630
server number 15 and so on a key value

00:04:55,410 --> 00:05:00,150
store allows us to do this discovery in

00:04:57,630 --> 00:05:02,370
exchange but importantly it allows us to

00:05:00,150 --> 00:05:05,070
do it in a manner that's lean and

00:05:02,370 --> 00:05:06,960
extensible it's one single mechanism

00:05:05,070 --> 00:05:09,750
that we're going to reuse for all

00:05:06,960 --> 00:05:11,520
components and for all state and because

00:05:09,750 --> 00:05:13,470
the key value stores agnostic to the

00:05:11,520 --> 00:05:15,390
particular keys and values and

00:05:13,470 --> 00:05:18,270
components you can change those over

00:05:15,390 --> 00:05:20,520
time and perhaps more importantly it's

00:05:18,270 --> 00:05:23,040
lean in the sense that the only thing it

00:05:20,520 --> 00:05:25,650
specifies is where you go to discover

00:05:23,040 --> 00:05:26,580
state everything else in the system is

00:05:25,650 --> 00:05:28,800
open to innovation

00:05:26,580 --> 00:05:30,330
so component that's generating a reading

00:05:28,800 --> 00:05:32,430
state it can be a VM

00:05:30,330 --> 00:05:34,620
your container can be any of them it can

00:05:32,430 --> 00:05:36,569
come from vendor a open to be the

00:05:34,620 --> 00:05:38,969
integration doesn't care and hence

00:05:36,569 --> 00:05:41,310
everything else that integrates doesn't

00:05:38,969 --> 00:05:43,590
care and that's our proposal really in a

00:05:41,310 --> 00:05:45,330
nutshell the remaining slides I have are

00:05:43,590 --> 00:05:47,849
really just expanding on how this

00:05:45,330 --> 00:05:49,740
integration would work so let me go

00:05:47,849 --> 00:05:52,800
there let me start with the NF lean

00:05:49,740 --> 00:05:54,240
manager in general in the NF e community

00:05:52,800 --> 00:05:55,889
when we talk about man oh we put up

00:05:54,240 --> 00:05:58,889
these two big boxes and every

00:05:55,889 --> 00:06:01,319
Orchestrator and vnf manager and this is

00:05:58,889 --> 00:06:03,569
where you come to do integration what

00:06:01,319 --> 00:06:06,180
we're proposing instead is let's go step

00:06:03,569 --> 00:06:08,009
further and decompose those boxes based

00:06:06,180 --> 00:06:10,110
on the concrete functionality that's

00:06:08,009 --> 00:06:12,690
needed for management things like

00:06:10,110 --> 00:06:15,750
placement launching configuration auto

00:06:12,690 --> 00:06:18,449
scaling monitoring and so on let's

00:06:15,750 --> 00:06:20,639
implement these functions as independent

00:06:18,449 --> 00:06:23,099
entities we call them micro controllers

00:06:20,639 --> 00:06:25,979
and here are crucially let's have each

00:06:23,099 --> 00:06:28,379
micro controller integrate only with the

00:06:25,979 --> 00:06:30,569
key value store independent of all the

00:06:28,379 --> 00:06:32,279
other micro controllers you can then

00:06:30,569 --> 00:06:34,259
start composing automation and

00:06:32,279 --> 00:06:36,810
management by composing these functions

00:06:34,259 --> 00:06:38,460
through the key value store here's a

00:06:36,810 --> 00:06:40,139
very simple example let's say I have the

00:06:38,460 --> 00:06:42,300
monitoring micro controller that's

00:06:40,139 --> 00:06:44,819
recording in the key value store what

00:06:42,300 --> 00:06:47,279
the load is on a vnf your scaling

00:06:44,819 --> 00:06:49,830
microcontroller is reading that value in

00:06:47,279 --> 00:06:52,440
deciding accordingly how many instances

00:06:49,830 --> 00:06:55,409
of each BNF are needed you're launching

00:06:52,440 --> 00:06:56,849
micro controller in turn is looking at

00:06:55,409 --> 00:06:59,909
that value and maybe launching or

00:06:56,849 --> 00:07:01,680
tearing down VMs right and this is just

00:06:59,909 --> 00:07:04,020
one simple example you can imagine

00:07:01,680 --> 00:07:06,599
extending exactly this pattern to have

00:07:04,020 --> 00:07:08,550
far more sophisticated control loops and

00:07:06,599 --> 00:07:10,469
notice I haven't said anything about

00:07:08,550 --> 00:07:12,389
where you implement any one of these

00:07:10,469 --> 00:07:14,250
micro controllers it could be in your

00:07:12,389 --> 00:07:16,529
room could be in your Sdn controller

00:07:14,250 --> 00:07:18,900
could be a standalone micro service all

00:07:16,529 --> 00:07:21,839
of that works because it doesn't change

00:07:18,900 --> 00:07:23,729
how you're doing integration and so in a

00:07:21,839 --> 00:07:24,750
nutshell doing this kind of key value

00:07:23,729 --> 00:07:28,229
based integration

00:07:24,750 --> 00:07:30,900
it makes nfe mano lean so let's say you

00:07:28,229 --> 00:07:33,120
have a UC PE you don't need probably

00:07:30,900 --> 00:07:35,069
half of these functions or UCP device

00:07:33,120 --> 00:07:37,020
orchestration so you could have a very

00:07:35,069 --> 00:07:39,899
lightweight Orchestrator with the same

00:07:37,020 --> 00:07:41,580
architecture it's extensible let's say

00:07:39,899 --> 00:07:42,569
that you have specialized hardware in

00:07:41,580 --> 00:07:44,550
your data center

00:07:42,569 --> 00:07:46,649
that needs to be taken into account when

00:07:44,550 --> 00:07:48,659
you do scheduling you can go in and

00:07:46,649 --> 00:07:50,879
change write your own placement

00:07:48,659 --> 00:07:53,999
microcontroller the rest of your system

00:07:50,879 --> 00:07:56,039
stays completely unchanged and perhaps

00:07:53,999 --> 00:07:58,229
most importantly it's multi-vendor

00:07:56,039 --> 00:07:59,550
each of these microcontrollers could

00:07:58,229 --> 00:08:02,039
come from a different vendor you could

00:07:59,550 --> 00:08:04,409
have a marketplace of microcontroller

00:08:02,039 --> 00:08:06,899
functions we talked a lot about avoiding

00:08:04,409 --> 00:08:08,939
lock in on the vnf side it's equally

00:08:06,899 --> 00:08:12,139
important that we avoid locking on the

00:08:08,939 --> 00:08:15,509
management side and this gets us there

00:08:12,139 --> 00:08:18,149
so let me move on now to in creation

00:08:15,509 --> 00:08:19,919
with the vnfs the challenge we see with

00:08:18,149 --> 00:08:22,289
via Neffs the biggest challenge I would

00:08:19,919 --> 00:08:24,240
say is bridging the gap between where we

00:08:22,289 --> 00:08:26,399
would like to go as a community in terms

00:08:24,240 --> 00:08:27,959
of what we NS should look like we've

00:08:26,399 --> 00:08:31,349
discussed this at length they should be

00:08:27,959 --> 00:08:33,449
disaggregated stateless free up an EMF

00:08:31,349 --> 00:08:36,329
cloud native containerized because

00:08:33,449 --> 00:08:38,370
service is so on those are great but the

00:08:36,329 --> 00:08:40,560
reality of what we NFS in production

00:08:38,370 --> 00:08:43,529
look like today are buying large-scale

00:08:40,560 --> 00:08:46,380
VMs that are managed by the vendors EMS

00:08:43,529 --> 00:08:49,170
and so what we need is really most

00:08:46,380 --> 00:08:51,149
importantly a path to incremental e

00:08:49,170 --> 00:08:53,699
transition from what we have today to

00:08:51,149 --> 00:08:55,589
where we'd like to go and again a key

00:08:53,699 --> 00:08:58,019
value store gets us there so let me

00:08:55,589 --> 00:09:01,560
start with a very simple vnf it's a VM

00:08:58,019 --> 00:09:03,630
it's managed by the vendor CMS very

00:09:01,560 --> 00:09:06,779
simple change we could make is have the

00:09:03,630 --> 00:09:10,139
EMS discover what VMs it should manage

00:09:06,779 --> 00:09:11,160
from the key values to the very simple

00:09:10,139 --> 00:09:12,810
change opens the door to

00:09:11,160 --> 00:09:14,519
microcontrollers coming in and doing

00:09:12,810 --> 00:09:17,759
things like auto scaling healing

00:09:14,519 --> 00:09:19,529
placement and so on once it knows what

00:09:17,759 --> 00:09:21,420
VMs it has to manage we can just have

00:09:19,529 --> 00:09:23,939
the EMS talk to the vnf the way it

00:09:21,420 --> 00:09:26,100
always has let's go a step further

00:09:23,939 --> 00:09:28,019
the vnf could actually read the

00:09:26,100 --> 00:09:30,689
configuration form the key value store

00:09:28,019 --> 00:09:32,610
the minute it does this doesn't really

00:09:30,689 --> 00:09:34,589
matter so much whether the configuration

00:09:32,610 --> 00:09:37,079
comes from the EMS or whether it comes

00:09:34,589 --> 00:09:39,630
from a different microcontroller and so

00:09:37,079 --> 00:09:42,569
if it's the right thing to do you can

00:09:39,630 --> 00:09:45,089
gradually phase out the EMS for that VM

00:09:42,569 --> 00:09:47,759
and move to a world where these general

00:09:45,089 --> 00:09:51,240
manual solutions are managing all via

00:09:47,759 --> 00:09:53,069
Neffs you could likewise at the same

00:09:51,240 --> 00:09:55,290
time be supporting the NFS that are

00:09:53,069 --> 00:09:55,890
these highly desire gated components

00:09:55,290 --> 00:09:58,290
from different

00:09:55,890 --> 00:10:01,140
that again are coordinating through the

00:09:58,290 --> 00:10:02,670
key value store in the same way and the

00:10:01,140 --> 00:10:04,800
point is that you don't have to pick and

00:10:02,670 --> 00:10:06,840
choose you can add all of these vendors

00:10:04,800 --> 00:10:08,970
can choose to put in the resources to

00:10:06,840 --> 00:10:12,480
evolve as the market proves itself and

00:10:08,970 --> 00:10:14,160
all of this can coexist and so take away

00:10:12,480 --> 00:10:16,440
our here again key value based

00:10:14,160 --> 00:10:18,780
integration allows vendors to evolve in

00:10:16,440 --> 00:10:22,740
a way that's incremental and independent

00:10:18,780 --> 00:10:24,240
of each other so the final component and

00:10:22,740 --> 00:10:26,640
point of integration is the

00:10:24,240 --> 00:10:28,170
infrastructure manager or the vim again

00:10:26,640 --> 00:10:29,640
in this community there's been a lot of

00:10:28,170 --> 00:10:32,760
discussion over the years around

00:10:29,640 --> 00:10:35,250
specializing the vim for NFV adding

00:10:32,760 --> 00:10:38,040
extensions to OpenStack new plugins to

00:10:35,250 --> 00:10:40,080
Sdn controllers and so on the challenge

00:10:38,040 --> 00:10:42,420
we see with this one it's slow because

00:10:40,080 --> 00:10:45,030
whimper faces are inherently large and

00:10:42,420 --> 00:10:47,100
complex so it's hard to move them but

00:10:45,030 --> 00:10:48,630
the second as it leads to a new form of

00:10:47,100 --> 00:10:51,300
lock-in and what I'm going to call

00:10:48,630 --> 00:10:52,980
infrastructure locking where you as a

00:10:51,300 --> 00:10:55,500
carrier you've deployed your nfe

00:10:52,980 --> 00:10:57,390
solution it's based on OpenStack and now

00:10:55,500 --> 00:10:58,740
you think I would like to move to VMware

00:10:57,390 --> 00:11:00,450
or Nutanix

00:10:58,740 --> 00:11:03,660
or kubernetes it really doesn't matter

00:11:00,450 --> 00:11:06,090
and you cannot because your OpenStack

00:11:03,660 --> 00:11:07,920
solution had the NFB solution built into

00:11:06,090 --> 00:11:09,150
it if you take out OpenStack you're

00:11:07,920 --> 00:11:12,510
going to break here in a free solution

00:11:09,150 --> 00:11:15,030
and so that's the situation we want to

00:11:12,510 --> 00:11:16,920
avoid our recommendation here is do not

00:11:15,030 --> 00:11:20,190
specialize to them do not rely on or

00:11:16,920 --> 00:11:22,890
specialized with any NFV specific logic

00:11:20,190 --> 00:11:25,410
should be up in the nfe manager and make

00:11:22,890 --> 00:11:26,690
use of common api's that are common

00:11:25,410 --> 00:11:29,400
across all VIMS

00:11:26,690 --> 00:11:31,380
so here's one example is that you could

00:11:29,400 --> 00:11:32,880
go into your infrastructure manager

00:11:31,380 --> 00:11:34,860
whether it's OpenStack or something else

00:11:32,880 --> 00:11:37,170
and say give me a set of nodes

00:11:34,860 --> 00:11:39,750
maybe bare metal on which I'm going to

00:11:37,170 --> 00:11:42,120
run NFV go to your Sdn controller and

00:11:39,750 --> 00:11:44,370
say connect those nodes and that's all

00:11:42,120 --> 00:11:46,920
you need to ask them form everything

00:11:44,370 --> 00:11:50,160
from that point to I can run on this set

00:11:46,920 --> 00:11:52,020
of subsets of nodes so effectively what

00:11:50,160 --> 00:11:54,150
we've done at this point is made nf we

00:11:52,020 --> 00:11:56,070
look like just any other workload that's

00:11:54,150 --> 00:11:58,470
running in your data center alongside

00:11:56,070 --> 00:12:01,590
maybe your AI apps tensorflow

00:11:58,470 --> 00:12:03,120
your spark spark analytics jobs they all

00:12:01,590 --> 00:12:05,880
look the same from the point of view of

00:12:03,120 --> 00:12:07,770
the infrastructure the key once you've

00:12:05,880 --> 00:12:08,640
done this is one of your other apps

00:12:07,770 --> 00:12:10,019
could be

00:12:08,640 --> 00:12:11,730
different and every workload that's

00:12:10,019 --> 00:12:14,310
based on a different implementation a

00:12:11,730 --> 00:12:17,010
different architecture and that is the

00:12:14,310 --> 00:12:19,050
surest path to enabling innovation and

00:12:17,010 --> 00:12:21,390
avoiding blockin the point at which you

00:12:19,050 --> 00:12:22,980
can run parallel and every services with

00:12:21,390 --> 00:12:24,779
completely different architectures and

00:12:22,980 --> 00:12:27,959
implementations you don't have to worry

00:12:24,779 --> 00:12:30,209
about being locked into one and so the

00:12:27,959 --> 00:12:32,940
punchline here again is that key value

00:12:30,209 --> 00:12:36,149
based integration approach is feasible

00:12:32,940 --> 00:12:38,519
with existing them layers does not

00:12:36,149 --> 00:12:40,890
require specialization and doing so

00:12:38,519 --> 00:12:43,890
allows you to treat an Fe as just any

00:12:40,890 --> 00:12:53,579
other workload and with that let me hand

00:12:43,890 --> 00:12:56,220
off to constantly everybody i'm

00:12:53,579 --> 00:12:59,339
konstantine paulo kanopolis with vmware

00:12:56,220 --> 00:13:01,290
and I'm going to take it from here for

00:12:59,339 --> 00:13:04,290
all the five minutes that I have and by

00:13:01,290 --> 00:13:06,269
the way I just logged a complaint with

00:13:04,290 --> 00:13:09,630
the Linux Foundation because my friend

00:13:06,269 --> 00:13:17,820
our people refused to twist his tongue

00:13:09,630 --> 00:13:19,709
and pronounce my last name so you know

00:13:17,820 --> 00:13:23,459
there is a lot to be said about lean and

00:13:19,709 --> 00:13:26,250
Fe and how it addresses some of the key

00:13:23,459 --> 00:13:30,329
challenges we face today and both Scott

00:13:26,250 --> 00:13:33,240
and Sylvia elaborate on those primarily

00:13:30,329 --> 00:13:38,339
the complexity are around onboarding

00:13:33,240 --> 00:13:41,220
vienna's in existing NFV environment but

00:13:38,339 --> 00:13:44,100
I want to and so the argument goes for

00:13:41,220 --> 00:13:48,600
you know previous generations networks

00:13:44,100 --> 00:13:49,980
LTE 4G etc I want to stay for a minute

00:13:48,600 --> 00:13:53,430
or 5g

00:13:49,980 --> 00:13:56,640
it's not here yet at least not in a pure

00:13:53,430 --> 00:13:59,910
and - and 5t implementation we have of

00:13:56,640 --> 00:14:03,800
course the early days of the so called

00:13:59,910 --> 00:14:08,130
non stand-alone 5g it's rides on top of

00:14:03,800 --> 00:14:10,589
LT core but if we really consider the

00:14:08,130 --> 00:14:12,930
reference architecture of 5g we have a

00:14:10,589 --> 00:14:15,000
couple of fundamental design principles

00:14:12,930 --> 00:14:19,980
one of them is service based

00:14:15,000 --> 00:14:21,600
architecture right think about subscribe

00:14:19,980 --> 00:14:26,040
notify

00:14:21,600 --> 00:14:28,220
and how that fits perfectly with villain

00:14:26,040 --> 00:14:32,370
nfe design principles

00:14:28,220 --> 00:14:36,120
how about cups control and user plain

00:14:32,370 --> 00:14:38,190
separation and the separation of vnf

00:14:36,120 --> 00:14:40,800
where the value is for the operator and

00:14:38,190 --> 00:14:43,079
where innovation really happens for the

00:14:40,800 --> 00:14:47,970
vendor from the management component

00:14:43,079 --> 00:14:50,699
within a big part is there to assure

00:14:47,970 --> 00:14:53,730
integration and interoperability right

00:14:50,699 --> 00:14:57,000
there is a lot to be said also about the

00:14:53,730 --> 00:14:59,790
natural fit between cloud native and

00:14:57,000 --> 00:15:04,829
continuous integration environments in

00:14:59,790 --> 00:15:09,230
5g another aspiration of 5g with the

00:15:04,829 --> 00:15:09,230
design principles of lean and Fe

00:15:09,949 --> 00:15:15,389
specifically when we talk about 5g the

00:15:13,259 --> 00:15:17,339
mind goes to highly distributed network

00:15:15,389 --> 00:15:19,589
infrastructure right all the operators

00:15:17,339 --> 00:15:22,259
everybody here knows about cold and

00:15:19,589 --> 00:15:26,759
marek etc and operators have this

00:15:22,259 --> 00:15:28,769
immense install base of you know

00:15:26,759 --> 00:15:32,480
appliance primarily appliance based gear

00:15:28,769 --> 00:15:35,610
in the central offices the promise of

00:15:32,480 --> 00:15:37,920
integrated access and providing

00:15:35,610 --> 00:15:39,990
essentially the same services regardless

00:15:37,920 --> 00:15:43,350
of the access whether it's wireless 5g

00:15:39,990 --> 00:15:45,449
or optical or broadband etc so

00:15:43,350 --> 00:15:47,850
leveraging that footprint that already

00:15:45,449 --> 00:15:51,620
exists to push the cloud very close to

00:15:47,850 --> 00:15:55,290
where it's consumed right a great goal

00:15:51,620 --> 00:15:58,500
and how again a linear we can facilitate

00:15:55,290 --> 00:16:02,040
and accelerate the tradition because you

00:15:58,500 --> 00:16:04,319
have now the opportunity to build all

00:16:02,040 --> 00:16:07,649
all sorts of cool applications around

00:16:04,319 --> 00:16:10,110
the kv store right and i start thinking

00:16:07,649 --> 00:16:11,759
about this when scott you know first

00:16:10,110 --> 00:16:13,500
called me with simpie and said you know

00:16:11,759 --> 00:16:15,290
let's break them about this and i

00:16:13,500 --> 00:16:18,300
thought this is a cool idea right

00:16:15,290 --> 00:16:21,209
because you can build all sorts of value

00:16:18,300 --> 00:16:22,860
out capabilities in a kv store things

00:16:21,209 --> 00:16:24,959
like i started thinking about

00:16:22,860 --> 00:16:28,459
continuations and how i can use a

00:16:24,959 --> 00:16:30,600
callback mechanism to totally decouple

00:16:28,459 --> 00:16:32,430
synchronization of the you know all the

00:16:30,600 --> 00:16:35,160
new applications and vnfs

00:16:32,430 --> 00:16:35,580
i can request the value the value is not

00:16:35,160 --> 00:16:38,250
you

00:16:35,580 --> 00:16:41,130
not there I will invoke the vnf that is

00:16:38,250 --> 00:16:43,080
supposed to produce a value or the set

00:16:41,130 --> 00:16:45,050
of values and I don't have to worry

00:16:43,080 --> 00:16:48,290
about you know fine-tuning

00:16:45,050 --> 00:16:52,860
interoperability between my Vienna's

00:16:48,290 --> 00:16:55,260
greatly again are simplifying onboarding

00:16:52,860 --> 00:16:57,630
and allowing the up you know the vendors

00:16:55,260 --> 00:17:00,090
to focus on innovation we're really

00:16:57,630 --> 00:17:01,110
innovation matters to the operator and

00:17:00,090 --> 00:17:03,560
to the rest of the committee of the

00:17:01,110 --> 00:17:03,560
community

00:17:04,080 --> 00:17:13,470
another very attractive aspect of linear

00:17:09,030 --> 00:17:16,110
Fe is that an NK v store is that it

00:17:13,470 --> 00:17:18,270
renders itself beautifully to highly

00:17:16,110 --> 00:17:21,450
distribute infrastructure where I can

00:17:18,270 --> 00:17:25,970
have basically a caching mechanism that

00:17:21,450 --> 00:17:28,830
would allow all of my exchange

00:17:25,970 --> 00:17:31,140
information to be localized and

00:17:28,830 --> 00:17:33,900
therefore create the notion of

00:17:31,140 --> 00:17:37,410
autonomously operating cloudlets in my

00:17:33,900 --> 00:17:40,190
environment only the information that

00:17:37,410 --> 00:17:43,560
needs to be propagated up the hierarchy

00:17:40,190 --> 00:17:46,710
will be relevant to a centralized you

00:17:43,560 --> 00:17:49,320
know controller or orchestrate or etc so

00:17:46,710 --> 00:17:51,390
again the coupling management

00:17:49,320 --> 00:17:53,940
orchestration from the value of the vnf

00:17:51,390 --> 00:17:57,620
and enabling through the kv a

00:17:53,940 --> 00:18:02,010
distributed Cavey store to seamlessly

00:17:57,620 --> 00:18:04,950
migrate workloads where the uses without

00:18:02,010 --> 00:18:09,830
having to resort to complex

00:18:04,950 --> 00:18:12,630
orchestration solutions is another

00:18:09,830 --> 00:18:17,660
benefit that addresses key design

00:18:12,630 --> 00:18:21,390
requirements of 5g one of my favorites

00:18:17,660 --> 00:18:23,820
is network slicing and again you know

00:18:21,390 --> 00:18:25,710
there is a lot of work to be done nobody

00:18:23,820 --> 00:18:27,930
claims that we have solved all the

00:18:25,710 --> 00:18:30,810
problems right what we're presenting

00:18:27,930 --> 00:18:34,410
today is a concept that has strong

00:18:30,810 --> 00:18:37,230
technical merits and it will involve and

00:18:34,410 --> 00:18:39,960
require heavy participation from the

00:18:37,230 --> 00:18:42,840
community but one of the ideas here as

00:18:39,960 --> 00:18:45,330
you know the notion of network you know

00:18:42,840 --> 00:18:48,690
slicing is again fundamental requirement

00:18:45,330 --> 00:18:49,230
of 5g where the three you know key

00:18:48,690 --> 00:18:53,250
people

00:18:49,230 --> 00:18:57,269
so 5t included very disparate huge cases

00:18:53,250 --> 00:18:59,940
like hands mobile broadband and massive

00:18:57,269 --> 00:19:03,539
machine type communications or ultra

00:18:59,940 --> 00:19:06,029
reliable high reliability and low

00:19:03,539 --> 00:19:09,269
latency communications very different

00:19:06,029 --> 00:19:12,539
use cases how do you implement all three

00:19:09,269 --> 00:19:15,059
of them that are so different onto the

00:19:12,539 --> 00:19:17,460
same infrastructure right well network

00:19:15,059 --> 00:19:18,059
slick network splicing comes to the

00:19:17,460 --> 00:19:22,159
rescue

00:19:18,059 --> 00:19:24,510
but nano slicing requires of course

00:19:22,159 --> 00:19:27,210
having multiple overlays on the same

00:19:24,510 --> 00:19:30,840
physical infrastructure imagine a case

00:19:27,210 --> 00:19:34,169
where I can have enhanced segmentation

00:19:30,840 --> 00:19:37,820
of the data to its slice through a cave

00:19:34,169 --> 00:19:40,710
restore right but they see you know

00:19:37,820 --> 00:19:45,510
security is one requirement of course

00:19:40,710 --> 00:19:47,460
but segmentation an actual locality of

00:19:45,510 --> 00:19:49,110
the data to its slice which may be

00:19:47,460 --> 00:19:54,330
operated by a different operator

00:19:49,110 --> 00:19:56,789
different entity is makes the security

00:19:54,330 --> 00:20:04,380
and privacy round natural slicing even

00:19:56,789 --> 00:20:07,320
more important and a great solution so

00:20:04,380 --> 00:20:10,200
without let me address the last point

00:20:07,320 --> 00:20:12,450
here which is okay we recognize that

00:20:10,200 --> 00:20:15,990
there is a significant install base of

00:20:12,450 --> 00:20:19,230
anything question is an FBI

00:20:15,990 --> 00:20:22,730
how does linen Fe fit into this the

00:20:19,230 --> 00:20:26,940
answer is we believe that it can exist

00:20:22,730 --> 00:20:29,840
in another of ways in a transitional our

00:20:26,940 --> 00:20:33,720
hybrid environment where a Cavey store

00:20:29,840 --> 00:20:39,049
can be part of the Etsy reference

00:20:33,720 --> 00:20:41,429
architecture we can have a linear Fe

00:20:39,049 --> 00:20:44,159
micro services based architecture

00:20:41,429 --> 00:20:46,440
coexist harmoniously with additional VMs

00:20:44,159 --> 00:20:48,179
there are many ways of doing so one of

00:20:46,440 --> 00:20:51,179
them for example is to have the

00:20:48,179 --> 00:20:53,580
open-source community contribute

00:20:51,179 --> 00:20:56,250
translators that passively integrate

00:20:53,580 --> 00:21:01,230
existing via net into a Cavey store

00:20:56,250 --> 00:21:03,040
environment another way would be to have

00:21:01,230 --> 00:21:05,710
vnf manufacturers

00:21:03,040 --> 00:21:08,080
built hooks into the air masses and the

00:21:05,710 --> 00:21:12,400
vnf management systems that integrate

00:21:08,080 --> 00:21:14,920
again seamlessly with an AKB based store

00:21:12,400 --> 00:21:16,480
there are many ways here to address the

00:21:14,920 --> 00:21:19,660
you know interoperability between

00:21:16,480 --> 00:21:24,370
existing install base and the new world

00:21:19,660 --> 00:21:26,370
that is linear fit focused and happy to

00:21:24,370 --> 00:21:29,170
address you know specific questions

00:21:26,370 --> 00:21:32,020
after the presentation but let me pass

00:21:29,170 --> 00:21:35,290
it again to Scott who is going to give

00:21:32,020 --> 00:21:42,580
the summary of the queue objectives here

00:21:35,290 --> 00:21:45,880
thank you thank you Constantine so in my

00:21:42,580 --> 00:21:49,690
minus two minutes left I want to briefly

00:21:45,880 --> 00:21:52,330
summarize leand nfe technically the main

00:21:49,690 --> 00:21:54,550
technical points are simple use a D

00:21:52,330 --> 00:21:56,920
value store is the universal point of

00:21:54,550 --> 00:22:00,520
integration and remove the need for

00:21:56,920 --> 00:22:03,760
specialized VIMS that's it but more

00:22:00,520 --> 00:22:04,360
generally Lina nfe is not a single

00:22:03,760 --> 00:22:07,630
codebase

00:22:04,360 --> 00:22:09,730
it is not just one instantiation it is

00:22:07,630 --> 00:22:11,440
an open architecture an open

00:22:09,730 --> 00:22:14,020
architecture that is designed to create

00:22:11,440 --> 00:22:18,280
a lean extensible and multi vendor

00:22:14,020 --> 00:22:20,620
ecosystem for NFV now we expect many

00:22:18,280 --> 00:22:22,600
realization to this architecture some of

00:22:20,620 --> 00:22:24,820
them purely commercial some of them

00:22:22,600 --> 00:22:27,580
purely open-source and probably most

00:22:24,820 --> 00:22:31,840
will be a hybrid of the two what are the

00:22:27,580 --> 00:22:35,110
advantages of this approach lean nfe is

00:22:31,840 --> 00:22:38,620
the minimal design that allows easy

00:22:35,110 --> 00:22:42,580
integration and leaves everything else

00:22:38,620 --> 00:22:44,920
open for innovation so the fact that it

00:22:42,580 --> 00:22:47,560
solves integration means that we can

00:22:44,920 --> 00:22:49,390
solve the problems of today in a way

00:22:47,560 --> 00:22:52,210
that's complementary to our current code

00:22:49,390 --> 00:22:54,520
bases and vnfs the fact that the rest is

00:22:52,210 --> 00:22:55,840
left open for innovation means that we

00:22:54,520 --> 00:22:58,570
can solve the problems of tomorrow

00:22:55,840 --> 00:23:00,160
things like cloud native 5g and beyond

00:22:58,570 --> 00:23:03,040
that we are soon going to have to deal

00:23:00,160 --> 00:23:06,520
with so for those of us who have taken

00:23:03,040 --> 00:23:08,440
the long and winding road of nfe this is

00:23:06,520 --> 00:23:14,690
the path to increasing adoption and

00:23:08,440 --> 00:23:17,280
innovation now in terms of next steps

00:23:14,690 --> 00:23:19,290
we hope that you will learn the basics

00:23:17,280 --> 00:23:21,780
we have a white paper up on our website

00:23:19,290 --> 00:23:24,420
there are hard copies available this is

00:23:21,780 --> 00:23:26,180
not just something that three of us

00:23:24,420 --> 00:23:29,220
believe in that gave this presentation

00:23:26,180 --> 00:23:30,840
this white paper signed by ten people

00:23:29,220 --> 00:23:32,400
who are all industry veterans who know

00:23:30,840 --> 00:23:34,950
nfe inside and out

00:23:32,400 --> 00:23:36,720
some of them come from carriers some of

00:23:34,950 --> 00:23:37,980
them come from vnf vendors some of them

00:23:36,720 --> 00:23:40,530
come from other instrument

00:23:37,980 --> 00:23:43,710
infrastructure providers they all think

00:23:40,530 --> 00:23:48,150
this is our way forward visit our demo

00:23:43,710 --> 00:23:50,430
in booth 605 longer term explore if you

00:23:48,150 --> 00:23:53,010
want to explore more deeply read the

00:23:50,430 --> 00:23:55,020
forthcoming technical documents we will

00:23:53,010 --> 00:23:56,160
be providing some demonstration code so

00:23:55,020 --> 00:23:58,800
you can see how this works in practice

00:23:56,160 --> 00:24:00,480
and attend future workshops or we can

00:23:58,800 --> 00:24:03,480
talk about both the technical issues and

00:24:00,480 --> 00:24:07,380
how we can move the ecosystem further

00:24:03,480 --> 00:24:09,510
and on that note what I on behalf of my

00:24:07,380 --> 00:24:11,640
co-presenters I would like to thank you

00:24:09,510 --> 00:24:15,110
for your attention and ask for your

00:24:11,640 --> 00:24:15,110

YouTube URL: https://www.youtube.com/watch?v=y9xrcp-Ny04


