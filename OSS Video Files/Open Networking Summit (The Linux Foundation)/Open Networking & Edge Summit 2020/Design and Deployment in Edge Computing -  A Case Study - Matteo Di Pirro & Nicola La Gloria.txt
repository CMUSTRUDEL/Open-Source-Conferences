Title: Design and Deployment in Edge Computing -  A Case Study - Matteo Di Pirro & Nicola La Gloria
Publication date: 2020-10-28
Playlist: Open Networking & Edge Summit 2020
Description: 
	Design and Deployment in Edge Computing -  A Case Study - Matteo Di Pirro & Nicola La Gloria, Kynetics LLC
Captions: 
	00:00:02,320 --> 00:00:05,359
hello

00:00:03,280 --> 00:00:07,279
and welcome to this presentation about

00:00:05,359 --> 00:00:09,280
the design and deployment

00:00:07,279 --> 00:00:10,480
of embedded applications in the era of

00:00:09,280 --> 00:00:12,480
edge computing

00:00:10,480 --> 00:00:14,160
i'm mathero i'm a software engineer at

00:00:12,480 --> 00:00:17,279
kinetics and as such

00:00:14,160 --> 00:00:18,080
i design develop and deploy embedded and

00:00:17,279 --> 00:00:20,800
distributed

00:00:18,080 --> 00:00:21,520
applications in today's talk we're going

00:00:20,800 --> 00:00:23,199
to see

00:00:21,520 --> 00:00:24,800
and we're going to go through some of

00:00:23,199 --> 00:00:26,720
the main lessons

00:00:24,800 --> 00:00:29,599
we learned and some of the main issues

00:00:26,720 --> 00:00:32,160
we faced while working on a distributed

00:00:29,599 --> 00:00:32,719
embedded application for a cluster of

00:00:32,160 --> 00:00:36,000
arm

00:00:32,719 --> 00:00:36,559
devices we'll be doing this by first

00:00:36,000 --> 00:00:38,879
looking

00:00:36,559 --> 00:00:41,200
at the main use case so what the main

00:00:38,879 --> 00:00:43,200
purpose of this system is

00:00:41,200 --> 00:00:44,960
we'll then look at the main components

00:00:43,200 --> 00:00:47,840
and at the road they play

00:00:44,960 --> 00:00:48,800
inside this cluster we'll then move to

00:00:47,840 --> 00:00:51,520
the main part

00:00:48,800 --> 00:00:53,039
of this presentation which is about as i

00:00:51,520 --> 00:00:55,840
said the most remarkable

00:00:53,039 --> 00:00:56,960
issues we faced while working on this

00:00:55,840 --> 00:00:59,600
project

00:00:56,960 --> 00:01:00,239
as you'll see all these issues strongly

00:00:59,600 --> 00:01:02,480
depend

00:01:00,239 --> 00:01:03,440
on the system being a cluster and on the

00:01:02,480 --> 00:01:06,799
system being

00:01:03,440 --> 00:01:09,439
an example of edge computing

00:01:06,799 --> 00:01:12,159
but before diving into this analysis let

00:01:09,439 --> 00:01:14,560
me introduce you the system first

00:01:12,159 --> 00:01:15,680
so the main purpose of this cluster and

00:01:14,560 --> 00:01:18,720
of this application

00:01:15,680 --> 00:01:21,439
is to stream audio samples over

00:01:18,720 --> 00:01:23,119
a bluetooth connection in a cluster of

00:01:21,439 --> 00:01:25,280
arm devices

00:01:23,119 --> 00:01:26,240
we'll have some smartphones and we'll be

00:01:25,280 --> 00:01:28,560
playing

00:01:26,240 --> 00:01:29,680
some audio samples on these microphones

00:01:28,560 --> 00:01:31,840
and record

00:01:29,680 --> 00:01:33,680
the audio being played on these

00:01:31,840 --> 00:01:36,159
microphones

00:01:33,680 --> 00:01:39,040
and the second main goal we had was the

00:01:36,159 --> 00:01:41,360
ability to have a fine grain control

00:01:39,040 --> 00:01:43,520
over the update over the deployment

00:01:41,360 --> 00:01:46,720
model inside the cluster

00:01:43,520 --> 00:01:49,360
so we wanted to be able to release

00:01:46,720 --> 00:01:50,560
application only updates and operating

00:01:49,360 --> 00:01:52,880
system updates

00:01:50,560 --> 00:01:54,079
separately as much as it happens in

00:01:52,880 --> 00:01:56,399
normal laptops

00:01:54,079 --> 00:01:57,200
and computers we update our operating

00:01:56,399 --> 00:01:59,680
system

00:01:57,200 --> 00:02:02,159
but update much more frequently our

00:01:59,680 --> 00:02:04,719
applications

00:02:02,159 --> 00:02:07,119
so the system as i said it is a cluster

00:02:04,719 --> 00:02:10,800
and in this cluster we can identify

00:02:07,119 --> 00:02:12,319
two main classes of nodes the first one

00:02:10,800 --> 00:02:15,040
is the coordinator

00:02:12,319 --> 00:02:16,720
a coordinator is a single board acting

00:02:15,040 --> 00:02:19,280
as an interface between

00:02:16,720 --> 00:02:20,480
the rest of the word the end users and

00:02:19,280 --> 00:02:22,959
the rest of the cluster

00:02:20,480 --> 00:02:25,440
the internal nodes you will receive

00:02:22,959 --> 00:02:27,920
commands from the end users

00:02:25,440 --> 00:02:30,160
and it will forward these commands to

00:02:27,920 --> 00:02:32,800
the other nodes in the cluster

00:02:30,160 --> 00:02:33,680
those nodes are called workers and they

00:02:32,800 --> 00:02:36,080
will perform

00:02:33,680 --> 00:02:37,440
the actual tasks the cluster is asked to

00:02:36,080 --> 00:02:40,879
perform

00:02:37,440 --> 00:02:41,599
and as we saw before these nodes will

00:02:40,879 --> 00:02:44,000
also be

00:02:41,599 --> 00:02:45,280
communicating with some smartphones in

00:02:44,000 --> 00:02:48,000
order to play

00:02:45,280 --> 00:02:49,200
audio samples and to record the audio

00:02:48,000 --> 00:02:52,080
being played

00:02:49,200 --> 00:02:53,360
on the smartphones themselves an

00:02:52,080 --> 00:02:56,560
important thing

00:02:53,360 --> 00:02:57,840
to notice in this system is that the

00:02:56,560 --> 00:03:00,640
entire cluster is

00:02:57,840 --> 00:03:03,280
physically inaccessible by the end users

00:03:00,640 --> 00:03:06,959
so end users won't have any physical

00:03:03,280 --> 00:03:09,040
access to the boards also the workers

00:03:06,959 --> 00:03:11,120
are completely isolated

00:03:09,040 --> 00:03:12,080
within an internal network and so they

00:03:11,120 --> 00:03:14,640
won't have

00:03:12,080 --> 00:03:16,400
any internet connection remember this

00:03:14,640 --> 00:03:18,959
point because this is important and it

00:03:16,400 --> 00:03:22,080
will be important when we'll talk about

00:03:18,959 --> 00:03:24,799
the deployment model so the only

00:03:22,080 --> 00:03:25,760
means of interaction of this system with

00:03:24,799 --> 00:03:29,040
the end users

00:03:25,760 --> 00:03:32,239
is a set of api exposed through

00:03:29,040 --> 00:03:33,040
an http interface so users will be

00:03:32,239 --> 00:03:36,080
invoking

00:03:33,040 --> 00:03:38,000
i will be calling http and points on the

00:03:36,080 --> 00:03:38,879
coordinator and the coordinator will

00:03:38,000 --> 00:03:42,159
then

00:03:38,879 --> 00:03:43,599
forward the commands to the workers

00:03:42,159 --> 00:03:45,519
and of course also the workers

00:03:43,599 --> 00:03:48,080
communicate with external word

00:03:45,519 --> 00:03:48,879
using the bluetooth technology as i said

00:03:48,080 --> 00:03:52,159
at the beginning

00:03:48,879 --> 00:03:54,159
of this presentation so from this

00:03:52,159 --> 00:03:55,280
simple description from this high level

00:03:54,159 --> 00:03:57,840
description

00:03:55,280 --> 00:03:58,480
the system is fairly complex because we

00:03:57,840 --> 00:04:01,920
have

00:03:58,480 --> 00:04:03,920
two different classes of nodes which you

00:04:01,920 --> 00:04:05,120
are different responsibilities with

00:04:03,920 --> 00:04:07,519
different

00:04:05,120 --> 00:04:08,720
tasks to perform and requirements to

00:04:07,519 --> 00:04:11,200
fulfill

00:04:08,720 --> 00:04:11,920
and also the software running on these

00:04:11,200 --> 00:04:15,280
systems

00:04:11,920 --> 00:04:17,440
will be different additionally

00:04:15,280 --> 00:04:18,639
the system is an example of edge

00:04:17,440 --> 00:04:21,600
computing because

00:04:18,639 --> 00:04:23,759
all the computation on the data the

00:04:21,600 --> 00:04:26,720
workers gathered and produced

00:04:23,759 --> 00:04:27,440
is performed within the cluster so we

00:04:26,720 --> 00:04:29,759
won't have

00:04:27,440 --> 00:04:30,800
any centralized data center or

00:04:29,759 --> 00:04:32,880
supercomputer

00:04:30,800 --> 00:04:34,720
performing any computation all the

00:04:32,880 --> 00:04:38,080
manipulation of the state

00:04:34,720 --> 00:04:39,840
will be done inside the cluster

00:04:38,080 --> 00:04:42,080
and of course with this increased

00:04:39,840 --> 00:04:45,120
complexity in the use cases

00:04:42,080 --> 00:04:45,120
and in the requirements

00:04:47,600 --> 00:04:52,880
also the software running in this system

00:04:50,880 --> 00:04:55,120
is more complex than for example a

00:04:52,880 --> 00:04:56,800
normal iit application based on cloud

00:04:55,120 --> 00:04:58,479
computing

00:04:56,800 --> 00:05:00,800
and this increased complexity of the

00:04:58,479 --> 00:05:03,520
software also means

00:05:00,800 --> 00:05:05,520
uh that many new issues happen and have

00:05:03,520 --> 00:05:07,440
to be taken care of

00:05:05,520 --> 00:05:08,720
the first issue we're going to talk

00:05:07,440 --> 00:05:12,160
about is

00:05:08,720 --> 00:05:15,759
the internal communication so we saw

00:05:12,160 --> 00:05:18,720
that um external users will communicate

00:05:15,759 --> 00:05:19,759
with the cluster by sending http

00:05:18,720 --> 00:05:22,639
requests

00:05:19,759 --> 00:05:23,360
but how does the coordinator forward the

00:05:22,639 --> 00:05:25,280
commands

00:05:23,360 --> 00:05:27,039
are within the cluster and how do the

00:05:25,280 --> 00:05:30,240
workers respond

00:05:27,039 --> 00:05:34,400
to these commands well this is done

00:05:30,240 --> 00:05:37,840
using a mix of mqtt and http

00:05:34,400 --> 00:05:38,560
why is that well mqtt is a very

00:05:37,840 --> 00:05:41,039
lightweight

00:05:38,560 --> 00:05:42,960
protocol publish subscribe protocol

00:05:41,039 --> 00:05:45,520
based on tcpap

00:05:42,960 --> 00:05:47,600
very well suited for systems for

00:05:45,520 --> 00:05:49,680
clusters and for applications

00:05:47,600 --> 00:05:50,880
with low bandwidth requirements and four

00:05:49,680 --> 00:05:54,240
devices

00:05:50,880 --> 00:05:55,440
with limited resources and computational

00:05:54,240 --> 00:05:58,240
power

00:05:55,440 --> 00:06:00,080
but of course in order for mqtt to be

00:05:58,240 --> 00:06:02,560
usable

00:06:00,080 --> 00:06:04,000
the messages the mqtt messages are going

00:06:02,560 --> 00:06:05,680
to be transmitted

00:06:04,000 --> 00:06:07,039
they have to be as lightweight as

00:06:05,680 --> 00:06:10,240
possible because

00:06:07,039 --> 00:06:10,880
otherwise encoding a large message will

00:06:10,240 --> 00:06:12,880
require

00:06:10,880 --> 00:06:14,960
a lot of computational power and

00:06:12,880 --> 00:06:15,919
transmitting that message will risk to

00:06:14,960 --> 00:06:19,120
overfill

00:06:15,919 --> 00:06:19,120
the available bandwidth

00:06:19,440 --> 00:06:24,960
so luckily for us the vast majority of

00:06:22,319 --> 00:06:27,440
our messages can indeed be encoding

00:06:24,960 --> 00:06:29,120
encoded just using a few bytes

00:06:27,440 --> 00:06:31,360
customizers cannot

00:06:29,120 --> 00:06:33,440
for example we'll see in a few minutes

00:06:31,360 --> 00:06:36,240
toward the end of this presentation

00:06:33,440 --> 00:06:37,120
that the use case of the update of the

00:06:36,240 --> 00:06:40,000
workers

00:06:37,120 --> 00:06:41,440
requires the messages to piggyback the

00:06:40,000 --> 00:06:44,000
update file

00:06:41,440 --> 00:06:46,160
but of course if we were to piggyback

00:06:44,000 --> 00:06:47,280
several hundreds of megabytes of an

00:06:46,160 --> 00:06:49,599
update file

00:06:47,280 --> 00:06:50,720
within an mqtt message that would be

00:06:49,599 --> 00:06:53,360
just wrong

00:06:50,720 --> 00:06:55,919
that message would be wouldn't be

00:06:53,360 --> 00:06:55,919
lightweight

00:07:00,840 --> 00:07:03,840
anymore

00:07:26,960 --> 00:07:31,199
so for these use cases and only for them

00:07:29,840 --> 00:07:34,319
we decided to use

00:07:31,199 --> 00:07:36,639
a mix of mqtt and http

00:07:34,319 --> 00:07:37,840
because now instead of piggybacking the

00:07:36,639 --> 00:07:40,960
entire file

00:07:37,840 --> 00:07:42,080
we'll be just including a link pointing

00:07:40,960 --> 00:07:44,479
to that file

00:07:42,080 --> 00:07:46,080
which will be made temporarily available

00:07:44,479 --> 00:07:48,240
within the internal network

00:07:46,080 --> 00:07:50,479
so when a board receives a message with

00:07:48,240 --> 00:07:51,599
a link no matter if the coordinator or

00:07:50,479 --> 00:07:53,759
the workers

00:07:51,599 --> 00:07:55,520
it will just follow the link download

00:07:53,759 --> 00:07:58,400
the file and then perform

00:07:55,520 --> 00:07:59,599
any computation it has to perform based

00:07:58,400 --> 00:08:02,560
on that file or

00:07:59,599 --> 00:08:04,560
on that file so using this mix of

00:08:02,560 --> 00:08:07,680
protocols we can

00:08:04,560 --> 00:08:10,080
design a tailored communication paradigm

00:08:07,680 --> 00:08:11,840
that is still as lightweight as possible

00:08:10,080 --> 00:08:14,560
and it can still be used

00:08:11,840 --> 00:08:17,599
in a system with limited resources and

00:08:14,560 --> 00:08:17,599
limited bandwidth

00:08:17,919 --> 00:08:22,080
now the second issue we are going to

00:08:20,319 --> 00:08:25,360
address in this presentation

00:08:22,080 --> 00:08:26,080
is a common problem in stateful

00:08:25,360 --> 00:08:29,120
distributed

00:08:26,080 --> 00:08:31,919
systems and that is how to keep

00:08:29,120 --> 00:08:32,880
the state consistent so how can we

00:08:31,919 --> 00:08:35,200
ensure

00:08:32,880 --> 00:08:36,479
the consistency of the state both at a

00:08:35,200 --> 00:08:39,200
local level

00:08:36,479 --> 00:08:40,000
inside each application each board and

00:08:39,200 --> 00:08:42,959
at a global

00:08:40,000 --> 00:08:45,279
level so the view the coordinator has of

00:08:42,959 --> 00:08:47,040
the entire system

00:08:45,279 --> 00:08:50,240
well this wasn't much of a problem

00:08:47,040 --> 00:08:51,839
before because ift applications based on

00:08:50,240 --> 00:08:55,279
cloud computing

00:08:51,839 --> 00:08:58,320
normally do have state but that state

00:08:55,279 --> 00:09:00,880
is normally read-only so the things

00:08:58,320 --> 00:09:02,880
used to produce the data but then that

00:09:00,880 --> 00:09:04,880
data was just transmitted to a

00:09:02,880 --> 00:09:07,760
centralized data center to be

00:09:04,880 --> 00:09:10,080
manipulated and to be computed on

00:09:07,760 --> 00:09:11,040
in edge computing and in this cluster we

00:09:10,080 --> 00:09:15,040
are pushing

00:09:11,040 --> 00:09:17,440
the computation away from the um

00:09:15,040 --> 00:09:19,600
centralized data centers to the edge of

00:09:17,440 --> 00:09:22,640
the network to cluster like this one

00:09:19,600 --> 00:09:25,040
so the state in this system is immutable

00:09:22,640 --> 00:09:27,680
it can change over time

00:09:25,040 --> 00:09:29,600
and the problem of keeping it consistent

00:09:27,680 --> 00:09:32,000
is made even more difficult

00:09:29,600 --> 00:09:33,040
by the asynchronous nature of this

00:09:32,000 --> 00:09:36,080
cluster

00:09:33,040 --> 00:09:39,360
so for example the coordinator has

00:09:36,080 --> 00:09:41,360
to react to asynchronous events http

00:09:39,360 --> 00:09:44,959
calls coming from the end users

00:09:41,360 --> 00:09:48,000
and mqtt messages coming from

00:09:44,959 --> 00:09:50,720
the other workers similarly the workers

00:09:48,000 --> 00:09:52,080
have to react to mqtt messages coming

00:09:50,720 --> 00:09:54,640
from the coordinator

00:09:52,080 --> 00:09:56,720
and also to bluetooth events are

00:09:54,640 --> 00:09:59,680
triggered by a connecting phone

00:09:56,720 --> 00:10:00,959
or for example a pairing phone so in

00:09:59,680 --> 00:10:03,200
those cases

00:10:00,959 --> 00:10:05,440
the worker has to detect a new

00:10:03,200 --> 00:10:07,120
connection modify its state and

00:10:05,440 --> 00:10:10,640
communicate the change

00:10:07,120 --> 00:10:13,360
of state to the coordinator

00:10:10,640 --> 00:10:14,320
so the solution to this problem is yes

00:10:13,360 --> 00:10:16,880
we do have

00:10:14,320 --> 00:10:18,320
mutable state and yes we do have a

00:10:16,880 --> 00:10:21,040
synchronous events

00:10:18,320 --> 00:10:21,760
but those events are going to be worked

00:10:21,040 --> 00:10:25,920
through

00:10:21,760 --> 00:10:28,720
one at a time and oh sorry

00:10:25,920 --> 00:10:28,720
i missed

00:10:31,760 --> 00:10:37,279
no okay i'm here um and the key point is

00:10:35,440 --> 00:10:39,200
that we're going to work through

00:10:37,279 --> 00:10:41,360
um those events twice at a time as i

00:10:39,200 --> 00:10:43,920
said i apologize for the interruption

00:10:41,360 --> 00:10:44,959
and there is a nice concurrency model

00:10:43,920 --> 00:10:47,440
that does just that

00:10:44,959 --> 00:10:50,480
it is known as the actress model and it

00:10:47,440 --> 00:10:52,800
was firstly theorized in 1973

00:10:50,480 --> 00:10:54,160
by curry ewit with a purpose with the

00:10:52,800 --> 00:10:56,959
goal of having

00:10:54,160 --> 00:10:57,440
thousands of microprocessors of units of

00:10:56,959 --> 00:11:00,480
work

00:10:57,440 --> 00:11:02,079
of actors uh each of which with a local

00:11:00,480 --> 00:11:05,600
storage space

00:11:02,079 --> 00:11:08,399
all working together concurrently

00:11:05,600 --> 00:11:10,720
and the key point in the actress model

00:11:08,399 --> 00:11:13,440
is actually two-fold

00:11:10,720 --> 00:11:14,800
we never share any state so the state

00:11:13,440 --> 00:11:18,560
will be kept private

00:11:14,800 --> 00:11:20,880
and internal to each actor and secondly

00:11:18,560 --> 00:11:23,440
all the communication between actors

00:11:20,880 --> 00:11:25,680
will happen through messages

00:11:23,440 --> 00:11:27,040
these messages will have four main

00:11:25,680 --> 00:11:28,959
characteristics

00:11:27,040 --> 00:11:31,600
there will be a synchronous so senders

00:11:28,959 --> 00:11:34,880
won't block waiting for receivers

00:11:31,600 --> 00:11:35,839
to acknowledge or to respond to a

00:11:34,880 --> 00:11:38,079
message

00:11:35,839 --> 00:11:39,279
they will be immutable so once the

00:11:38,079 --> 00:11:42,320
message is sent

00:11:39,279 --> 00:11:44,959
it may never be modified again

00:11:42,320 --> 00:11:46,959
thirdly they are deposited into a

00:11:44,959 --> 00:11:48,079
mailbox which is essentially just a

00:11:46,959 --> 00:11:50,480
queue

00:11:48,079 --> 00:11:51,360
internal and private to each actor and

00:11:50,480 --> 00:11:53,440
finally

00:11:51,360 --> 00:11:55,040
they will be worked through one at a

00:11:53,440 --> 00:11:57,519
time

00:11:55,040 --> 00:12:00,240
so if an actor wants to know the state

00:11:57,519 --> 00:12:02,320
of another actor it will send a message

00:12:00,240 --> 00:12:03,839
and if an actor wants to modify the

00:12:02,320 --> 00:12:06,720
state of another actor

00:12:03,839 --> 00:12:08,480
then again it will send a message and

00:12:06,720 --> 00:12:11,760
these messages they have

00:12:08,480 --> 00:12:12,320
four main characteristics and as we saw

00:12:11,760 --> 00:12:15,920
they are

00:12:12,320 --> 00:12:18,079
described by um the model itself

00:12:15,920 --> 00:12:19,920
but the mean the main point is that by

00:12:18,079 --> 00:12:22,240
following these principles

00:12:19,920 --> 00:12:23,360
we can ensure that we'll never have race

00:12:22,240 --> 00:12:25,600
conditions

00:12:23,360 --> 00:12:27,920
because we'll never have more than one

00:12:25,600 --> 00:12:30,639
actor concurrently trying

00:12:27,920 --> 00:12:30,959
to access the same portion of the state

00:12:30,639 --> 00:12:33,680
to

00:12:30,959 --> 00:12:35,200
read or modify the same portion of the

00:12:33,680 --> 00:12:37,839
state

00:12:35,200 --> 00:12:39,200
but how can we ensure the same thing at

00:12:37,839 --> 00:12:41,440
the global level so

00:12:39,200 --> 00:12:43,120
how can we ensure that the view the

00:12:41,440 --> 00:12:47,040
coordinator has of the system

00:12:43,120 --> 00:12:49,760
is indeed consistent or we can do that

00:12:47,040 --> 00:12:51,760
just by generalizing this model and by

00:12:49,760 --> 00:12:54,480
thinking of the entire cluster

00:12:51,760 --> 00:12:55,760
as made up of actors and by thinking of

00:12:54,480 --> 00:12:58,160
all the communication

00:12:55,760 --> 00:13:00,399
happening within the cluster and from

00:12:58,160 --> 00:13:06,079
the external world to the internal

00:13:00,399 --> 00:13:07,680
as serialized into messages

00:13:06,079 --> 00:13:09,680
for example if you take a look at this

00:13:07,680 --> 00:13:12,480
slide you'll see that we have a

00:13:09,680 --> 00:13:14,480
coordinator which is this goddamn bird

00:13:12,480 --> 00:13:15,920
at the top of the slide and the

00:13:14,480 --> 00:13:18,959
coordinator every n

00:13:15,920 --> 00:13:20,399
seconds is pinging all the workers to

00:13:18,959 --> 00:13:23,839
make sure they are still

00:13:20,399 --> 00:13:25,120
alive and available so this is a

00:13:23,839 --> 00:13:27,360
periodical task

00:13:25,120 --> 00:13:29,279
and suppose that at a given point in

00:13:27,360 --> 00:13:32,800
time a new

00:13:29,279 --> 00:13:36,079
http request arrives asking for example

00:13:32,800 --> 00:13:37,519
a worker to stream some audio samples

00:13:36,079 --> 00:13:39,040
over a bluetooth connection to a

00:13:37,519 --> 00:13:40,079
smartphone this is the meaning of

00:13:39,040 --> 00:13:43,279
display

00:13:40,079 --> 00:13:45,279
uh message over there so at this point

00:13:43,279 --> 00:13:48,720
the coordinator will create

00:13:45,279 --> 00:13:51,040
an actor which is his garden circle

00:13:48,720 --> 00:13:52,880
and the actor will be responsible of

00:13:51,040 --> 00:13:55,440
communicating with the worker

00:13:52,880 --> 00:13:57,680
so it will serialize uh it will create

00:13:55,440 --> 00:13:59,440
an mqtt message it will publish the

00:13:57,680 --> 00:14:01,920
message so that the worker

00:13:59,440 --> 00:14:03,839
can receive it and when the worker does

00:14:01,920 --> 00:14:06,959
receive the message it will start

00:14:03,839 --> 00:14:08,560
um reproducing playing an audio sample

00:14:06,959 --> 00:14:11,440
over a bluetooth connection

00:14:08,560 --> 00:14:12,959
but in the meanwhile the actor will be

00:14:11,440 --> 00:14:15,519
just waiting

00:14:12,959 --> 00:14:16,399
but here waiting doesn't mean the actor

00:14:15,519 --> 00:14:19,680
is holding

00:14:16,399 --> 00:14:21,920
any resources it had in fact

00:14:19,680 --> 00:14:23,279
it had released all the resources the

00:14:21,920 --> 00:14:26,639
trade included

00:14:23,279 --> 00:14:28,639
so that the ping actor can go on and can

00:14:26,639 --> 00:14:30,560
keep pinging the workers and that the

00:14:28,639 --> 00:14:34,160
coordinator can serve

00:14:30,560 --> 00:14:36,240
other incoming http requests

00:14:34,160 --> 00:14:38,320
and as a matter of fact suppose a new

00:14:36,240 --> 00:14:40,880
http request arrives

00:14:38,320 --> 00:14:43,120
asking the coordinator to update a

00:14:40,880 --> 00:14:45,279
couple of workers for example

00:14:43,120 --> 00:14:46,320
at this point a new actor will be

00:14:45,279 --> 00:14:48,320
created

00:14:46,320 --> 00:14:49,360
this other golden circle at the top of

00:14:48,320 --> 00:14:52,000
the slide

00:14:49,360 --> 00:14:55,040
and that actor will be again responsible

00:14:52,000 --> 00:14:57,680
of communicating with the target workers

00:14:55,040 --> 00:14:58,399
but the key point here is that all these

00:14:57,680 --> 00:15:02,079
actors

00:14:58,399 --> 00:15:04,639
the playing actor the ping actor and the

00:15:02,079 --> 00:15:07,040
update actor can run concurrently

00:15:04,639 --> 00:15:08,959
without any risk of race conditions

00:15:07,040 --> 00:15:10,399
because again their internal state is

00:15:08,959 --> 00:15:13,519
kept private and then

00:15:10,399 --> 00:15:15,839
they only communicate through messages

00:15:13,519 --> 00:15:18,000
and as a matter of fact suppose that the

00:15:15,839 --> 00:15:20,000
playing actor has been awakened

00:15:18,000 --> 00:15:21,040
because for example the worker had

00:15:20,000 --> 00:15:23,120
responded with

00:15:21,040 --> 00:15:24,959
a successful response so they're

00:15:23,120 --> 00:15:27,440
actually running together

00:15:24,959 --> 00:15:29,600
without race conditions and then at this

00:15:27,440 --> 00:15:31,519
point the playing capture is destroyed

00:15:29,600 --> 00:15:34,079
because it has service purpose

00:15:31,519 --> 00:15:35,600
and the update actor can go ahead with

00:15:34,079 --> 00:15:38,480
any computation

00:15:35,600 --> 00:15:41,759
and for example reaching out to the

00:15:38,480 --> 00:15:44,160
workers that have to be updated

00:15:41,759 --> 00:15:46,000
so from this example we saw that just by

00:15:44,160 --> 00:15:47,839
generalizing the actors model by

00:15:46,000 --> 00:15:49,120
applying the same principles to the

00:15:47,839 --> 00:15:51,440
entire cluster

00:15:49,120 --> 00:15:52,959
we can make sure that the state is

00:15:51,440 --> 00:15:55,759
always kept private

00:15:52,959 --> 00:15:58,399
and that the view the coordinator has of

00:15:55,759 --> 00:16:01,440
the entire system is always eventually

00:15:58,399 --> 00:16:03,839
consistent now

00:16:01,440 --> 00:16:05,519
the last issue and the third one we are

00:16:03,839 --> 00:16:08,160
talking about today

00:16:05,519 --> 00:16:08,639
is the deployment model so how we roll

00:16:08,160 --> 00:16:12,240
out

00:16:08,639 --> 00:16:13,040
our updates remember that we want to

00:16:12,240 --> 00:16:15,600
update

00:16:13,040 --> 00:16:17,279
the application and the operating system

00:16:15,600 --> 00:16:19,680
separately

00:16:17,279 --> 00:16:21,279
so to do that we decided to rely on

00:16:19,680 --> 00:16:24,320
software update which is

00:16:21,279 --> 00:16:27,920
a framework tailored for the update of

00:16:24,320 --> 00:16:29,360
embedded systems and with software

00:16:27,920 --> 00:16:31,680
update we can

00:16:29,360 --> 00:16:33,600
build fully automated continuous

00:16:31,680 --> 00:16:34,560
delivery and continuous integration

00:16:33,600 --> 00:16:37,279
pipelines

00:16:34,560 --> 00:16:38,000
because this framework defines uh update

00:16:37,279 --> 00:16:41,120
files

00:16:38,000 --> 00:16:42,800
with the swu extension and those swu

00:16:41,120 --> 00:16:44,800
files can be built

00:16:42,800 --> 00:16:46,240
automatically so from software from a

00:16:44,800 --> 00:16:48,160
pipeline

00:16:46,240 --> 00:16:50,399
and similarly the update will be

00:16:48,160 --> 00:16:52,399
triggered by the application

00:16:50,399 --> 00:16:54,480
so the application will as we saw

00:16:52,399 --> 00:16:57,360
download the update file

00:16:54,480 --> 00:16:59,519
may be performing some uh integrity or

00:16:57,360 --> 00:17:00,800
sanity checks on it for example checking

00:16:59,519 --> 00:17:03,120
that the checksum

00:17:00,800 --> 00:17:04,559
is the expected one and then it will

00:17:03,120 --> 00:17:07,280
trigger the update

00:17:04,559 --> 00:17:09,120
just by running a shell command so that

00:17:07,280 --> 00:17:11,199
shell command will set some environment

00:17:09,120 --> 00:17:13,439
variables at the bootloader level

00:17:11,199 --> 00:17:15,360
so that when the board reboots because

00:17:13,439 --> 00:17:16,319
software update requires the board to

00:17:15,360 --> 00:17:18,400
reboot

00:17:16,319 --> 00:17:20,640
software update will kick in applying

00:17:18,400 --> 00:17:21,360
the update eventually restarting both

00:17:20,640 --> 00:17:24,640
the boot

00:17:21,360 --> 00:17:26,640
uh the board and the application

00:17:24,640 --> 00:17:28,240
so at that point the application can

00:17:26,640 --> 00:17:30,160
just check the outcome

00:17:28,240 --> 00:17:32,480
of the update by looking at some

00:17:30,160 --> 00:17:35,120
environment variables

00:17:32,480 --> 00:17:35,520
so what can can we use this knowledge to

00:17:35,120 --> 00:17:38,880
build

00:17:35,520 --> 00:17:40,559
fully automated pipelines well we can do

00:17:38,880 --> 00:17:42,799
that supposing we have

00:17:40,559 --> 00:17:44,559
a two repositories one for the

00:17:42,799 --> 00:17:45,360
application and one for the operating

00:17:44,559 --> 00:17:48,400
system

00:17:45,360 --> 00:17:49,600
and suppose we have uh that each push on

00:17:48,400 --> 00:17:52,080
the master branch

00:17:49,600 --> 00:17:53,520
triggers the pipeline so the first step

00:17:52,080 --> 00:17:56,960
the pipeline will build

00:17:53,520 --> 00:17:59,440
the swu file from the latest commit

00:17:56,960 --> 00:18:01,520
and it will then um trigger the end

00:17:59,440 --> 00:18:02,240
point of the coordinator corresponding

00:18:01,520 --> 00:18:05,280
to

00:18:02,240 --> 00:18:06,559
update all the workers at this point as

00:18:05,280 --> 00:18:08,559
we saw the worker

00:18:06,559 --> 00:18:10,559
receives that the coordinator receives

00:18:08,559 --> 00:18:13,600
the http request

00:18:10,559 --> 00:18:15,600
it creates a new mqtt message that is

00:18:13,600 --> 00:18:17,120
then published so that all the workers

00:18:15,600 --> 00:18:19,039
can receive it

00:18:17,120 --> 00:18:21,760
the workers receive the message they

00:18:19,039 --> 00:18:23,760
download the swu file

00:18:21,760 --> 00:18:25,280
and then they go ahead they perform the

00:18:23,760 --> 00:18:26,400
integration the integrity checks the

00:18:25,280 --> 00:18:28,960
sanity checks

00:18:26,400 --> 00:18:30,240
and kick off the update and when update

00:18:28,960 --> 00:18:32,799
is completed

00:18:30,240 --> 00:18:34,880
they can just look at the outcome and

00:18:32,799 --> 00:18:35,600
start responding to the ping messages

00:18:34,880 --> 00:18:37,679
again

00:18:35,600 --> 00:18:38,880
so that the work the coordinator knows

00:18:37,679 --> 00:18:42,640
they're still alive

00:18:38,880 --> 00:18:45,200
and available but at this point

00:18:42,640 --> 00:18:46,240
you may be wondering okay but over the

00:18:45,200 --> 00:18:48,080
last few years

00:18:46,240 --> 00:18:49,360
another technology has become

00:18:48,080 --> 00:18:51,440
increasingly

00:18:49,360 --> 00:18:52,799
important and popular for these kind of

00:18:51,440 --> 00:18:55,679
use cases

00:18:52,799 --> 00:18:56,000
i'm talking about docker so the question

00:18:55,679 --> 00:18:58,640
you

00:18:56,000 --> 00:18:59,600
may be asking to yourself is could we

00:18:58,640 --> 00:19:02,640
use docker

00:18:59,600 --> 00:19:05,440
instead of software update and if so are

00:19:02,640 --> 00:19:09,440
there any advantages or disadvantages

00:19:05,440 --> 00:19:12,720
to this technology well the answer is

00:19:09,440 --> 00:19:15,440
yes and no yes because we can use docker

00:19:12,720 --> 00:19:16,799
to reach the same purpose to serve the

00:19:15,440 --> 00:19:18,799
same purpose

00:19:16,799 --> 00:19:20,559
but that would require an additional

00:19:18,799 --> 00:19:22,720
effort

00:19:20,559 --> 00:19:25,039
under some points of view docker and

00:19:22,720 --> 00:19:27,679
software update are roughly equivalent

00:19:25,039 --> 00:19:29,440
for example we can distribute docker

00:19:27,679 --> 00:19:32,480
images just using

00:19:29,440 --> 00:19:34,559
tar archives so the distribution works

00:19:32,480 --> 00:19:36,160
similarly to the way it works for

00:19:34,559 --> 00:19:38,799
software update files

00:19:36,160 --> 00:19:41,600
without the need of setting up a docker

00:19:38,799 --> 00:19:44,799
registry somewhere

00:19:41,600 --> 00:19:46,559
and second docker can be also be safer

00:19:44,799 --> 00:19:48,160
than software updates in some cases

00:19:46,559 --> 00:19:50,640
because if we

00:19:48,160 --> 00:19:51,520
set up some monitoring system for

00:19:50,640 --> 00:19:54,320
example

00:19:51,520 --> 00:19:56,320
we could make sure that if the latest

00:19:54,320 --> 00:19:57,840
image doesn't work properly

00:19:56,320 --> 00:20:00,640
we could always fall back to the

00:19:57,840 --> 00:20:03,039
previous one of course this

00:20:00,640 --> 00:20:04,400
monitoring system would require an

00:20:03,039 --> 00:20:07,760
additional effort

00:20:04,400 --> 00:20:10,559
but at least there wouldn't be the risk

00:20:07,760 --> 00:20:12,080
of breaking the board because if we mess

00:20:10,559 --> 00:20:14,320
up with the date file

00:20:12,080 --> 00:20:16,240
and the board gets broken it may be

00:20:14,320 --> 00:20:19,520
required to manually go there

00:20:16,240 --> 00:20:22,000
re-flash the board or see what's wrong

00:20:19,520 --> 00:20:24,000
of course we could also solve this issue

00:20:22,000 --> 00:20:25,679
with software update by using a double

00:20:24,000 --> 00:20:28,159
copy approach so instead of

00:20:25,679 --> 00:20:30,240
writing always on the same partition we

00:20:28,159 --> 00:20:32,480
could be writing on a different one

00:20:30,240 --> 00:20:34,080
so under these points of view docker and

00:20:32,480 --> 00:20:37,520
software update are more or less

00:20:34,080 --> 00:20:40,559
equivalent however

00:20:37,520 --> 00:20:44,080
dockers has some disadvantages

00:20:40,559 --> 00:20:47,039
for example the update

00:20:44,080 --> 00:20:48,880
now would require a higher level of

00:20:47,039 --> 00:20:51,520
interaction between

00:20:48,880 --> 00:20:53,440
the application and the operating system

00:20:51,520 --> 00:20:54,159
because the application would download

00:20:53,440 --> 00:20:57,200
the file

00:20:54,159 --> 00:20:58,559
the image and still perform some sanity

00:20:57,200 --> 00:21:00,240
checks on it

00:20:58,559 --> 00:21:02,799
but then the operating system will need

00:21:00,240 --> 00:21:04,960
to kick in stopping the container

00:21:02,799 --> 00:21:06,320
uh loading the new image inside of the

00:21:04,960 --> 00:21:08,799
docker daemon

00:21:06,320 --> 00:21:09,919
uh possibly removing the older one and

00:21:08,799 --> 00:21:12,000
then starting

00:21:09,919 --> 00:21:14,799
uh the new container from the newer

00:21:12,000 --> 00:21:16,159
image so this i as i said this requires

00:21:14,799 --> 00:21:18,640
an additional level

00:21:16,159 --> 00:21:20,159
a higher level of interaction between

00:21:18,640 --> 00:21:22,240
the operating system

00:21:20,159 --> 00:21:23,840
and the application and it's more

00:21:22,240 --> 00:21:27,600
costful than just having

00:21:23,840 --> 00:21:30,720
software update doing all the work

00:21:27,600 --> 00:21:31,440
second with docker application only

00:21:30,720 --> 00:21:33,919
updates

00:21:31,440 --> 00:21:35,120
and operating system updates would kind

00:21:33,919 --> 00:21:37,919
of overlap

00:21:35,120 --> 00:21:38,559
because as you know docker images don't

00:21:37,919 --> 00:21:41,200
contain

00:21:38,559 --> 00:21:42,400
just the binaries of an application but

00:21:41,200 --> 00:21:46,000
they also contain

00:21:42,400 --> 00:21:49,440
all the packages

00:21:46,000 --> 00:21:51,760
libraries and files needed by those

00:21:49,440 --> 00:21:52,720
applications to run by those binaries to

00:21:51,760 --> 00:21:55,760
run

00:21:52,720 --> 00:21:58,080
and of course if for each bug

00:21:55,760 --> 00:21:59,200
fix or application only update we have

00:21:58,080 --> 00:22:01,440
to

00:21:59,200 --> 00:22:02,720
release a substantial portion of the

00:22:01,440 --> 00:22:05,600
operating system

00:22:02,720 --> 00:22:07,679
our updates files will be larger and the

00:22:05,600 --> 00:22:09,280
date time will be slower because

00:22:07,679 --> 00:22:10,640
downloads will be slower

00:22:09,280 --> 00:22:12,640
and also applying that they will be

00:22:10,640 --> 00:22:16,080
slower as well

00:22:12,640 --> 00:22:18,799
so um for this um

00:22:16,080 --> 00:22:20,880
two reasons dockers provides us with a

00:22:18,799 --> 00:22:22,000
lower flexibility and with a coarser

00:22:20,880 --> 00:22:24,320
grain

00:22:22,000 --> 00:22:25,679
control over the deployment model but

00:22:24,320 --> 00:22:28,000
there is a third issue

00:22:25,679 --> 00:22:29,120
which is linked to the increased

00:22:28,000 --> 00:22:32,320
complexity

00:22:29,120 --> 00:22:34,000
we see in edge computing as a matter of

00:22:32,320 --> 00:22:37,200
fact in the era of edge computing

00:22:34,000 --> 00:22:40,080
our boards also have to interact with

00:22:37,200 --> 00:22:43,200
some external low-level services

00:22:40,080 --> 00:22:44,720
such as for example uh audio modules or

00:22:43,200 --> 00:22:46,880
the bluetooth stack

00:22:44,720 --> 00:22:48,240
and doing that from within a docker

00:22:46,880 --> 00:22:51,039
container

00:22:48,240 --> 00:22:53,039
requires an additional effort it's more

00:22:51,039 --> 00:22:54,720
difficult than just doing that

00:22:53,039 --> 00:22:56,720
from the from the normal operating

00:22:54,720 --> 00:22:59,200
system interacting with those

00:22:56,720 --> 00:23:01,760
services using for example debus or

00:22:59,200 --> 00:23:04,159
another communication mechanism

00:23:01,760 --> 00:23:05,280
so for these reasons we decided to use

00:23:04,159 --> 00:23:07,679
software update

00:23:05,280 --> 00:23:08,640
instead of docker because it provided us

00:23:07,679 --> 00:23:10,640
with

00:23:08,640 --> 00:23:12,000
greater flexibility a higher degree of

00:23:10,640 --> 00:23:14,320
flexibility

00:23:12,000 --> 00:23:17,760
and it was also cheaper to implement and

00:23:14,320 --> 00:23:20,880
to maintain as a solution

00:23:17,760 --> 00:23:23,919
so in conclusion in this presentation

00:23:20,880 --> 00:23:27,600
we saw that with the ongoing shift

00:23:23,919 --> 00:23:30,720
from iot to um and cloud computing to

00:23:27,600 --> 00:23:33,520
edge computing many new issues

00:23:30,720 --> 00:23:34,720
are are happening and they are there to

00:23:33,520 --> 00:23:37,520
be taken care of

00:23:34,720 --> 00:23:38,559
for example i didn't mention them but

00:23:37,520 --> 00:23:41,200
network issue

00:23:38,559 --> 00:23:42,480
privacy issues reliability or

00:23:41,200 --> 00:23:45,360
scalability

00:23:42,480 --> 00:23:45,679
performance resource consumption issues

00:23:45,360 --> 00:23:48,640
they

00:23:45,679 --> 00:23:51,279
all have to be taken care of because now

00:23:48,640 --> 00:23:54,400
we are pushing competition

00:23:51,279 --> 00:23:56,640
away from a centralized data center to

00:23:54,400 --> 00:23:57,919
clusters of devices with limited

00:23:56,640 --> 00:24:01,919
resources

00:23:57,919 --> 00:24:04,320
so the software running on these systems

00:24:01,919 --> 00:24:07,360
on these clusters and these boards has

00:24:04,320 --> 00:24:09,760
to be carefully designed and implemented

00:24:07,360 --> 00:24:10,880
to make sure we can still use all the

00:24:09,760 --> 00:24:13,679
knowledge we have

00:24:10,880 --> 00:24:14,159
and all the protocols and solutions we

00:24:13,679 --> 00:24:16,159
have

00:24:14,159 --> 00:24:19,039
in others areas perhaps of computer

00:24:16,159 --> 00:24:21,840
science to implement new protocols

00:24:19,039 --> 00:24:23,520
or tailored solutions for our systems

00:24:21,840 --> 00:24:24,480
that are still as lightweight as

00:24:23,520 --> 00:24:27,120
possible

00:24:24,480 --> 00:24:28,240
and can still be used in systems with

00:24:27,120 --> 00:24:32,320
low bandwidth

00:24:28,240 --> 00:24:34,080
and low computational power

00:24:32,320 --> 00:24:35,840
so thank you for your attention and

00:24:34,080 --> 00:24:37,840
thank you again for having me

00:24:35,840 --> 00:24:39,919
uh if you have any questions please you

00:24:37,840 --> 00:24:41,360
can just reach out to me you have my

00:24:39,919 --> 00:24:43,520
email address there

00:24:41,360 --> 00:24:45,760
or you can type the question in the qa

00:24:43,520 --> 00:24:46,159
box i guess we have some more minutes to

00:24:45,760 --> 00:25:01,840
answer

00:24:46,159 --> 00:25:01,840
them so thank you again and bye bye

00:25:54,840 --> 00:25:57,840
um

00:26:08,840 --> 00:26:11,840
uh

00:26:28,400 --> 00:26:39,840
oh there we are

00:26:43,039 --> 00:26:49,440
hello everyone can you hear me mattel

00:26:46,240 --> 00:26:52,320
yes i can alright

00:26:49,440 --> 00:26:54,559
so i guess that if anyone has any

00:26:52,320 --> 00:26:58,000
question we are here to

00:26:54,559 --> 00:27:01,360
answer live otherwise

00:26:58,000 --> 00:27:04,960
you left your email address and

00:27:01,360 --> 00:27:08,720
people can reach us to for questions

00:27:04,960 --> 00:27:10,159
offline too yeah so i got a question

00:27:08,720 --> 00:27:10,799
about these lights i don't know if it's

00:27:10,159 --> 00:27:13,840
visible

00:27:10,799 --> 00:27:15,440
uh to everyone i'm going to publish uh

00:27:13,840 --> 00:27:18,799
the slides representation

00:27:15,440 --> 00:27:22,080
on the session page on sched

00:27:18,799 --> 00:27:23,200
after after this session this evening so

00:27:22,080 --> 00:27:35,840
that you can

00:27:23,200 --> 00:27:35,840
download it and watch it offline

00:27:46,840 --> 00:27:49,840
so

00:28:28,559 --> 00:28:31,840
all right

00:28:38,000 --> 00:28:48,640
is there anyone of the moderator online

00:28:45,200 --> 00:28:48,640
or anyone from the conference

00:28:52,399 --> 00:28:55,840
i don't know probably not just by

00:28:56,840 --> 00:28:59,840
yourself

00:29:00,960 --> 00:29:04,000
yeah just let's let's wait for a couple

00:29:02,799 --> 00:29:08,080
of minutes more

00:29:04,000 --> 00:29:11,120
if anyone can do it

00:29:08,080 --> 00:29:13,520
that's what i just don't component

00:29:11,120 --> 00:29:15,200
oh that's an interesting question um

00:29:13,520 --> 00:29:16,720
either way you want to answer matteo or

00:29:15,200 --> 00:29:19,360
i do

00:29:16,720 --> 00:29:21,039
well you can go ahead i don't see it

00:29:19,360 --> 00:29:24,640
actually so

00:29:21,039 --> 00:29:25,760
so right now right so um right now we do

00:29:24,640 --> 00:29:28,640
the entire os

00:29:25,760 --> 00:29:31,120
of course you can manage with software

00:29:28,640 --> 00:29:34,799
update also incremental os updates

00:29:31,120 --> 00:29:38,480
um it's just a matter of how good you

00:29:34,799 --> 00:29:41,679
are for tracking which device

00:29:38,480 --> 00:29:43,279
is at which version so to keep

00:29:41,679 --> 00:29:45,679
everything consistent is

00:29:43,279 --> 00:29:46,320
you know more it's easier to manage the

00:29:45,679 --> 00:29:49,279
entire

00:29:46,320 --> 00:29:51,120
os with a single image but again

00:29:49,279 --> 00:29:54,000
software updates also manages

00:29:51,120 --> 00:29:56,159
uh the incremental updates right now we

00:29:54,000 --> 00:29:57,360
don't have any bandwidth limitations so

00:29:56,159 --> 00:30:00,640
it's better for us to

00:29:57,360 --> 00:30:03,200
just provide the entire less image

00:30:00,640 --> 00:30:03,679
and so it's like safer but again you

00:30:03,200 --> 00:30:06,799
know

00:30:03,679 --> 00:30:07,919
both options are available and by the

00:30:06,799 --> 00:30:10,880
way a software update

00:30:07,919 --> 00:30:12,080
is is um it's an open source project uh

00:30:10,880 --> 00:30:15,840
developed by

00:30:12,080 --> 00:30:18,240
stefano babich from denks and is really

00:30:15,840 --> 00:30:20,240
recommended for for you guys if you

00:30:18,240 --> 00:30:22,720
never had the chance to look at that

00:30:20,240 --> 00:30:25,440
to just read the documentation because

00:30:22,720 --> 00:30:25,440
it's pretty awesome

00:30:26,000 --> 00:30:37,840
very low footprint and very extensible

00:30:38,480 --> 00:30:41,279
you're welcome tom

00:30:46,880 --> 00:30:50,799
um yeah let's let me add a couple of uh

00:30:49,679 --> 00:30:54,480
comments on the

00:30:50,799 --> 00:30:57,519
uh last topic that matteo presented

00:30:54,480 --> 00:30:58,880
the approach of using docker so docker

00:30:57,519 --> 00:31:01,200
is really

00:30:58,880 --> 00:31:02,799
it's really important on edge computing

00:31:01,200 --> 00:31:06,080
as a deployment model

00:31:02,799 --> 00:31:09,760
and also for handling like different

00:31:06,080 --> 00:31:12,880
um and more complicated uh dependencies

00:31:09,760 --> 00:31:15,919
into uh you know in a framework and

00:31:12,880 --> 00:31:17,679
uh the the the

00:31:15,919 --> 00:31:19,120
limit we had in this application in

00:31:17,679 --> 00:31:22,240
particular was

00:31:19,120 --> 00:31:24,320
that we need access to the uh

00:31:22,240 --> 00:31:25,279
bluetooth stack and the bluetooth stack

00:31:24,320 --> 00:31:28,320
is actually available

00:31:25,279 --> 00:31:31,120
on what we call the core os so it's very

00:31:28,320 --> 00:31:34,159
difficult for an application to

00:31:31,120 --> 00:31:36,960
handle the

00:31:34,159 --> 00:31:37,360
connection with like a core stack like

00:31:36,960 --> 00:31:39,679
the

00:31:37,360 --> 00:31:41,440
the bluetooth stack through an edge

00:31:39,679 --> 00:31:42,159
container sorry through a docking

00:31:41,440 --> 00:31:44,240
container

00:31:42,159 --> 00:31:47,039
you can do that with some privileged

00:31:44,240 --> 00:31:49,919
mode in order for the container to have

00:31:47,039 --> 00:31:51,120
access to the core os devices in terms

00:31:49,919 --> 00:31:53,919
of kernel

00:31:51,120 --> 00:31:54,799
it's not really safe so it's not really

00:31:53,919 --> 00:31:58,159
something that

00:31:54,799 --> 00:31:59,679
you know was an option for us this is

00:31:58,159 --> 00:32:02,720
why we didn't uh

00:31:59,679 --> 00:32:04,159
we didn't in this case um implemented

00:32:02,720 --> 00:32:06,480
our application inside the docker

00:32:04,159 --> 00:32:09,679
container and so just

00:32:06,480 --> 00:32:12,720
updating the docker container um was

00:32:09,679 --> 00:32:15,679
the was the the second option for

00:32:12,720 --> 00:32:16,480
for updating a piece of the system but

00:32:15,679 --> 00:32:19,840
again

00:32:16,480 --> 00:32:23,039
we needed the application to uh

00:32:19,840 --> 00:32:23,600
to deal with the low level stack of the

00:32:23,039 --> 00:32:25,440
os

00:32:23,600 --> 00:32:27,200
in particular the bluetooth stack and

00:32:25,440 --> 00:32:31,440
there was no easy way

00:32:27,200 --> 00:32:31,440
other than privileged kernel privileged

00:32:31,519 --> 00:32:43,840
modes for accessing that from

00:32:34,559 --> 00:32:43,840
from from the application in a container

00:32:55,919 --> 00:33:02,880
if there is any other question please

00:32:59,279 --> 00:33:03,840
that's the that's the time we i think we

00:33:02,880 --> 00:33:11,840
have like um

00:33:03,840 --> 00:33:11,840
probably a couple of minutes more

00:33:23,760 --> 00:33:25,840
you

00:33:40,080 --> 00:33:47,360
oh the and out tab actually i

00:33:43,120 --> 00:33:47,360
i don't know what is the handout tab

00:33:50,000 --> 00:33:54,640
is there any handout tab that you you

00:33:52,720 --> 00:33:57,919
see

00:33:54,640 --> 00:34:00,399
i don't

00:33:57,919 --> 00:34:02,799
okay now i see an end out tab but it's

00:34:00,399 --> 00:34:02,799
empty

00:34:04,559 --> 00:34:09,280
let's try to upload that on the because

00:34:07,120 --> 00:34:13,119
i don't see the end out

00:34:09,280 --> 00:34:13,119
it's in the green buttons below

00:34:17,200 --> 00:34:23,679
right but i'm not sure how i cannot

00:34:20,320 --> 00:34:23,679
upload something here

00:34:28,889 --> 00:34:32,019
[Music]

00:34:32,399 --> 00:34:39,119
all right so

00:34:35,440 --> 00:34:40,720
i guess that the the support here is

00:34:39,119 --> 00:34:45,040
saying

00:34:40,720 --> 00:34:48,159
to mr johnson yeah we will be

00:34:45,040 --> 00:34:50,159
we will we will be updating or uploading

00:34:48,159 --> 00:34:52,480
the the slides right away so it's just a

00:34:50,159 --> 00:34:54,720
matter of minutes right

00:34:52,480 --> 00:34:57,200
probably we can do that right now yeah

00:34:54,720 --> 00:35:00,480
i'm not doing that now right now

00:34:57,200 --> 00:35:03,839
okay so guys you will find these lights

00:35:00,480 --> 00:35:03,839
in a few minutes

00:35:06,000 --> 00:35:09,200
okay so

00:35:12,880 --> 00:35:16,000
something that we can add in the

00:35:14,240 --> 00:35:20,079
meantime as another comment

00:35:16,000 --> 00:35:22,800
in this application we really took

00:35:20,079 --> 00:35:24,640
the akka framework that is typically for

00:35:22,800 --> 00:35:26,640
distributed application on the cloud

00:35:24,640 --> 00:35:28,240
and we use the same paradigm on an

00:35:26,640 --> 00:35:31,680
embedded cluster of computers

00:35:28,240 --> 00:35:34,560
that is i guess the absolutely what

00:35:31,680 --> 00:35:35,680
the edge computing is is is doing today

00:35:34,560 --> 00:35:39,359
right so taking

00:35:35,680 --> 00:35:42,000
the data center down to the

00:35:39,359 --> 00:35:43,520
to the edge and so having used those

00:35:42,000 --> 00:35:44,160
same frameworks that we are using on the

00:35:43,520 --> 00:35:47,599
back end

00:35:44,160 --> 00:35:51,040
of complex system asynchronous system

00:35:47,599 --> 00:35:53,760
uh down to the edge down to arm

00:35:51,040 --> 00:35:54,800
on arm cluster of computers was another

00:35:53,760 --> 00:35:56,960
achievement that

00:35:54,800 --> 00:35:58,079
actually is one of the paradigm of edge

00:35:56,960 --> 00:36:00,320
computing today

00:35:58,079 --> 00:36:01,440
so i hope that you agree on that so

00:36:00,320 --> 00:36:05,440
again

00:36:01,440 --> 00:36:07,119
this is another proof on how we can take

00:36:05,440 --> 00:36:08,800
the same architecture that has been

00:36:07,119 --> 00:36:12,079
deployed in the back end

00:36:08,800 --> 00:36:16,000
down to the edge um with the

00:36:12,079 --> 00:36:18,800
same with the same level of

00:36:16,000 --> 00:36:18,800
usability

00:36:24,640 --> 00:36:31,920
okay so i uploaded these lights on the

00:36:29,599 --> 00:36:34,160
session page should be able to see them

00:36:31,920 --> 00:36:34,160
now

00:36:34,400 --> 00:36:39,920
as for the records of this session i

00:36:37,599 --> 00:36:40,800
if i'm not mistaken that will be put on

00:36:39,920 --> 00:36:44,160
youtube

00:36:40,800 --> 00:36:47,359
uh in a couple of months as i

00:36:44,160 --> 00:36:50,720
saw and ride in the slack channel

00:36:47,359 --> 00:36:53,520
but maybe the moderator or the

00:36:50,720 --> 00:36:55,839
engineers of the platform can provide

00:36:53,520 --> 00:36:58,640
you with a more detailed answer

00:36:55,839 --> 00:36:58,640
to this question

00:37:02,160 --> 00:37:05,680
again in the presentation mattel there

00:37:03,920 --> 00:37:07,119
is material email

00:37:05,680 --> 00:37:08,560
if you have any other offline question

00:37:07,119 --> 00:37:09,280
or you know you want to know more

00:37:08,560 --> 00:37:12,079
details

00:37:09,280 --> 00:37:13,280
you can reach us out directly by email

00:37:12,079 --> 00:37:23,839
that would be also

00:37:13,280 --> 00:37:23,839
an option

00:37:37,280 --> 00:37:39,359

YouTube URL: https://www.youtube.com/watch?v=gG4-NgxDZFo


