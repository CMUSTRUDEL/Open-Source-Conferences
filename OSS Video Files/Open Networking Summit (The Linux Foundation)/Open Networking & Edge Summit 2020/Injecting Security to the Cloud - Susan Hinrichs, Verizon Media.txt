Title: Injecting Security to the Cloud - Susan Hinrichs, Verizon Media
Publication date: 2020-10-28
Playlist: Open Networking & Edge Summit 2020
Description: 
	Injecting Security to the Cloud - Susan Hinrichs, Verizon Media
Captions: 
	00:00:03,199 --> 00:00:05,920
thank you for

00:00:04,080 --> 00:00:07,759
joining my session today we're going to

00:00:05,920 --> 00:00:08,720
be talking about injecting security to

00:00:07,759 --> 00:00:12,160
the cloud

00:00:08,720 --> 00:00:15,280
my name is susan henrichs and i am

00:00:12,160 --> 00:00:17,039
from verizon media formerly yahoo

00:00:15,280 --> 00:00:18,560
i work with the edge team at verizon

00:00:17,039 --> 00:00:21,359
media been there

00:00:18,560 --> 00:00:22,480
six to seven years we work on i work on

00:00:21,359 --> 00:00:24,960
web proxies

00:00:22,480 --> 00:00:27,119
routing and some networking tools i'm a

00:00:24,960 --> 00:00:28,240
committer on the apache traffic server

00:00:27,119 --> 00:00:30,480
project

00:00:28,240 --> 00:00:31,599
and in my copious spare time i practice

00:00:30,480 --> 00:00:33,360
and teach yoga

00:00:31,599 --> 00:00:36,719
and you can see my contact information

00:00:33,360 --> 00:00:36,719
if you want to reach out to me later

00:00:37,120 --> 00:00:42,559
the goal of this talk is to present to

00:00:40,480 --> 00:00:43,760
you some of the tls scenarios that we

00:00:42,559 --> 00:00:45,600
encountered as we were moving our

00:00:43,760 --> 00:00:46,960
applications into a hybrid cloud

00:00:45,600 --> 00:00:48,480
environment

00:00:46,960 --> 00:00:50,399
specifically we're going to talk i'm

00:00:48,480 --> 00:00:52,960
going to talk about how we use two open

00:00:50,399 --> 00:00:55,920
source projects to help that transition

00:00:52,960 --> 00:00:57,199
a proxy apache traffic server and an

00:00:55,920 --> 00:01:00,239
access control system

00:00:57,199 --> 00:01:01,039
athens uh to to do this and we're

00:01:00,239 --> 00:01:02,800
supporting

00:01:01,039 --> 00:01:04,720
our proxy and kind of an application

00:01:02,800 --> 00:01:07,119
delivery network environment

00:01:04,720 --> 00:01:09,200
and as with any significant project this

00:01:07,119 --> 00:01:11,040
is not my work alone i've worked with a

00:01:09,200 --> 00:01:12,400
lot of my colleagues at verizon media

00:01:11,040 --> 00:01:13,600
and other members of the open source

00:01:12,400 --> 00:01:16,720
community for this work

00:01:13,600 --> 00:01:16,720
some of them are listed below

00:01:17,360 --> 00:01:21,600
let me start by saying a few words about

00:01:19,520 --> 00:01:24,240
these two open source projects

00:01:21,600 --> 00:01:24,799
first apache traffic server i mentioned

00:01:24,240 --> 00:01:26,960
is a web

00:01:24,799 --> 00:01:28,320
caching and proxying tool and it's been

00:01:26,960 --> 00:01:30,240
out in the world for quite

00:01:28,320 --> 00:01:31,759
a while it's been an open source project

00:01:30,240 --> 00:01:34,880
for over 10 years

00:01:31,759 --> 00:01:37,680
and it was used in a proprietary form by

00:01:34,880 --> 00:01:39,600
yahoo and inktomy before that

00:01:37,680 --> 00:01:41,439
the unique thing about apache serv

00:01:39,600 --> 00:01:42,159
traffic server is that it allows the

00:01:41,439 --> 00:01:44,560
injection

00:01:42,159 --> 00:01:45,360
of business specific logic via plugins

00:01:44,560 --> 00:01:47,680
so

00:01:45,360 --> 00:01:48,720
separately written dynamically loadable

00:01:47,680 --> 00:01:52,079
libraries

00:01:48,720 --> 00:01:54,159
that trigger code on specific keep hook

00:01:52,079 --> 00:01:55,920
points in the life cycle of an http

00:01:54,159 --> 00:01:59,360
transaction or session

00:01:55,920 --> 00:02:02,880
this enables the developers to create

00:01:59,360 --> 00:02:03,520
and specialize uh how we handle web

00:02:02,880 --> 00:02:06,880
traffic

00:02:03,520 --> 00:02:08,399
for our company environments i've worked

00:02:06,880 --> 00:02:10,879
in the area of tls

00:02:08,399 --> 00:02:12,400
for ats since i've started and

00:02:10,879 --> 00:02:13,920
specifically in the last three to four

00:02:12,400 --> 00:02:15,200
years we've spent a lot of our effort in

00:02:13,920 --> 00:02:18,800
the tls area

00:02:15,200 --> 00:02:21,440
enhancing our support for mutual tls uh

00:02:18,800 --> 00:02:24,319
with the goal of supporting our hybrid

00:02:21,440 --> 00:02:24,319
cloud environments

00:02:25,280 --> 00:02:29,120
the other project that we have leveraged

00:02:27,280 --> 00:02:30,160
is athens which is a role-based access

00:02:29,120 --> 00:02:32,959
control system

00:02:30,160 --> 00:02:34,239
and it leverages mutual tls

00:02:32,959 --> 00:02:35,920
authentication

00:02:34,239 --> 00:02:38,239
to perform the authentication part of

00:02:35,920 --> 00:02:38,720
that it was contributed to open source

00:02:38,239 --> 00:02:41,440
by

00:02:38,720 --> 00:02:42,239
yahoo verizon media and it's been the

00:02:41,440 --> 00:02:45,360
basis for

00:02:42,239 --> 00:02:47,200
most of our verizon media authentication

00:02:45,360 --> 00:02:48,640
and authorization work

00:02:47,200 --> 00:02:50,319
and as i go through this talk we'll talk

00:02:48,640 --> 00:02:51,920
a little bit more about these projects

00:02:50,319 --> 00:02:53,040
but it's kind of the high level of what

00:02:51,920 --> 00:02:54,959
they are

00:02:53,040 --> 00:02:56,239
so motivation why are we going through

00:02:54,959 --> 00:02:58,319
this effort

00:02:56,239 --> 00:02:59,680
so in the good old days we had corporate

00:02:58,319 --> 00:03:01,280
data centers

00:02:59,680 --> 00:03:02,720
an organization would have one data

00:03:01,280 --> 00:03:05,280
center maybe a couple data

00:03:02,720 --> 00:03:06,720
data centers where all of their servers

00:03:05,280 --> 00:03:07,440
running their front end their back end

00:03:06,720 --> 00:03:09,519
and their middle

00:03:07,440 --> 00:03:11,280
where would all be in the same physical

00:03:09,519 --> 00:03:13,280
location so we could be kind of

00:03:11,280 --> 00:03:14,959
loosey-goosey in terms of authentication

00:03:13,280 --> 00:03:17,280
and in terms of encryption

00:03:14,959 --> 00:03:18,720
we could just maybe rely on ip addresses

00:03:17,280 --> 00:03:19,200
to verify that the client was coming

00:03:18,720 --> 00:03:21,120
from

00:03:19,200 --> 00:03:22,239
within the data center might not have

00:03:21,120 --> 00:03:24,480
been a great idea

00:03:22,239 --> 00:03:26,799
but in fact that's what folks would do

00:03:24,480 --> 00:03:30,239
and encryption within the data center

00:03:26,799 --> 00:03:30,239
was a huge concern

00:03:30,319 --> 00:03:35,840
but more recently we've had public

00:03:32,799 --> 00:03:37,760
public clouds come out into the world

00:03:35,840 --> 00:03:39,200
in that case an organization instead of

00:03:37,760 --> 00:03:40,640
building their own data centers and

00:03:39,200 --> 00:03:42,319
hiring their employees for the care and

00:03:40,640 --> 00:03:44,840
feeding of those machines

00:03:42,319 --> 00:03:46,000
would rent virtual resources from third

00:03:44,840 --> 00:03:49,440
parties

00:03:46,000 --> 00:03:52,159
and in this saves money and time then

00:03:49,440 --> 00:03:52,879
uh makes it very easy to dynamically

00:03:52,159 --> 00:03:55,200
bring up

00:03:52,879 --> 00:03:57,120
an application and maybe if that doesn't

00:03:55,200 --> 00:03:59,360
work bring it back down

00:03:57,120 --> 00:04:01,120
so it's very good for startups and even

00:03:59,360 --> 00:04:03,840
for larger companies who are

00:04:01,120 --> 00:04:05,519
launching speculative applications but

00:04:03,840 --> 00:04:07,840
if you have a large

00:04:05,519 --> 00:04:09,360
well-known dedicated application say

00:04:07,840 --> 00:04:11,680
like yahoo mail

00:04:09,360 --> 00:04:13,360
deploying that in a public cloud can be

00:04:11,680 --> 00:04:15,840
a very expensive

00:04:13,360 --> 00:04:15,840
proposition

00:04:16,560 --> 00:04:19,600
so of course we mix the best of both

00:04:18,639 --> 00:04:21,919
worlds and we have

00:04:19,600 --> 00:04:23,759
now the hybrid cloud so in that case

00:04:21,919 --> 00:04:26,000
you're going to have

00:04:23,759 --> 00:04:27,520
dedicated company data centers or

00:04:26,000 --> 00:04:29,680
on-prem resources

00:04:27,520 --> 00:04:30,880
you're going to have one or more public

00:04:29,680 --> 00:04:34,479
clouds so maybe

00:04:30,880 --> 00:04:36,240
an aws cloud and a google cloud or an

00:04:34,479 --> 00:04:39,360
azure cloud

00:04:36,240 --> 00:04:41,680
and depending on what stage

00:04:39,360 --> 00:04:43,360
of life the lifecycle and application is

00:04:41,680 --> 00:04:46,400
it may run on-prem

00:04:43,360 --> 00:04:48,639
it may run in a cloud it may move over

00:04:46,400 --> 00:04:50,080
time from on-prem to the cloud and maybe

00:04:48,639 --> 00:04:51,840
back again

00:04:50,080 --> 00:04:53,440
so in this kind of environment we have

00:04:51,840 --> 00:04:54,560
very dynamic and complex test

00:04:53,440 --> 00:04:56,639
relationships

00:04:54,560 --> 00:04:58,160
so a user agent may come and enter your

00:04:56,639 --> 00:05:01,120
application from an on-prem

00:04:58,160 --> 00:05:01,840
system or from a third-party cloud

00:05:01,120 --> 00:05:04,320
within

00:05:01,840 --> 00:05:05,440
the backend within a data center maybe

00:05:04,320 --> 00:05:07,199
on-prem is going to

00:05:05,440 --> 00:05:09,440
access some service that's running in a

00:05:07,199 --> 00:05:11,759
cloud and vice versa

00:05:09,440 --> 00:05:13,280
so we can't get away with just like

00:05:11,759 --> 00:05:14,880
checking the ip address to make sure

00:05:13,280 --> 00:05:17,360
that our requester is in

00:05:14,880 --> 00:05:18,880
our corporate data center and we have to

00:05:17,360 --> 00:05:21,600
be very aware

00:05:18,880 --> 00:05:23,520
of encrypting things over the internet

00:05:21,600 --> 00:05:24,720
protecting our data as it's transiting

00:05:23,520 --> 00:05:27,520
unsecured

00:05:24,720 --> 00:05:27,520
networking space

00:05:30,080 --> 00:05:35,840
so we've done that by taking advantage

00:05:32,720 --> 00:05:37,360
of tls authentication

00:05:35,840 --> 00:05:39,120
and let me take a little bit of time

00:05:37,360 --> 00:05:41,520
just to quickly review kind of the

00:05:39,120 --> 00:05:42,560
classic tls authentication models

00:05:41,520 --> 00:05:44,240
and the kind of the classic

00:05:42,560 --> 00:05:45,360
configuration it's only the server is

00:05:44,240 --> 00:05:47,759
proving its identity

00:05:45,360 --> 00:05:49,840
and in my little diagram i'm showing a

00:05:47,759 --> 00:05:51,520
client is talking to a server

00:05:49,840 --> 00:05:53,520
it sends a client a loan message the

00:05:51,520 --> 00:05:54,320
server sees that sends back a server

00:05:53,520 --> 00:05:56,240
cert

00:05:54,320 --> 00:05:58,080
the client will verify the signature on

00:05:56,240 --> 00:05:59,520
the servicer make sure it's signed by an

00:05:58,080 --> 00:06:00,800
entity at trusts

00:05:59,520 --> 00:06:02,960
and then through the rest of the key

00:06:00,800 --> 00:06:04,000
exchange the server is going to prove to

00:06:02,960 --> 00:06:05,759
the client that it owns the

00:06:04,000 --> 00:06:07,680
corresponding private key

00:06:05,759 --> 00:06:09,360
if the client is authenticating itself

00:06:07,680 --> 00:06:11,280
to the server if that's needed that's

00:06:09,360 --> 00:06:11,600
done at a different level via password

00:06:11,280 --> 00:06:14,880
or

00:06:11,600 --> 00:06:17,840
two-factor authentication but

00:06:14,880 --> 00:06:18,639
tls also provides mutual authentication

00:06:17,840 --> 00:06:21,440
so in that case

00:06:18,639 --> 00:06:22,800
both the client and the server exchange

00:06:21,440 --> 00:06:25,280
exchange certificates

00:06:22,800 --> 00:06:26,639
so again in our scenario the client will

00:06:25,280 --> 00:06:28,800
send a hello

00:06:26,639 --> 00:06:30,720
the server will send its server cert and

00:06:28,800 --> 00:06:32,240
then it also sends a message saying hey

00:06:30,720 --> 00:06:34,240
give me your cert

00:06:32,240 --> 00:06:35,520
and the client will send its cert over

00:06:34,240 --> 00:06:37,120
it will check the server search

00:06:35,520 --> 00:06:39,360
signature the server will set

00:06:37,120 --> 00:06:40,639
check this client search signature and

00:06:39,360 --> 00:06:41,199
then through the rest of the key

00:06:40,639 --> 00:06:43,039
exchange

00:06:41,199 --> 00:06:46,160
each will prove to the other side that

00:06:43,039 --> 00:06:48,960
they own the corresponding private key

00:06:46,160 --> 00:06:50,080
so this mutual tls authentication mode

00:06:48,960 --> 00:06:52,240
this client serp mode

00:06:50,080 --> 00:06:53,120
isn't great for humans but it is pretty

00:06:52,240 --> 00:06:55,280
decent model

00:06:53,120 --> 00:06:58,080
if your client is another program

00:06:55,280 --> 00:06:58,080
another service

00:06:59,039 --> 00:07:04,160
so that's how our athens works for the

00:07:02,080 --> 00:07:05,680
authentication mode we have ath inserts

00:07:04,160 --> 00:07:08,800
that are provided

00:07:05,680 --> 00:07:10,240
and that proves their identity to the

00:07:08,800 --> 00:07:12,639
other side

00:07:10,240 --> 00:07:14,000
but when we started most of our clients

00:07:12,639 --> 00:07:15,680
most of our servers didn't

00:07:14,000 --> 00:07:17,039
support mutual tls this was a new

00:07:15,680 --> 00:07:19,199
concept for them

00:07:17,039 --> 00:07:20,720
so we could have waited and rewritten

00:07:19,199 --> 00:07:23,360
all of our servers and clients

00:07:20,720 --> 00:07:25,039
to perform mutual tls and we would

00:07:23,360 --> 00:07:27,039
probably still be waiting

00:07:25,039 --> 00:07:28,319
but instead you could put a proxy and

00:07:27,039 --> 00:07:30,319
use that to help

00:07:28,319 --> 00:07:32,240
retrofit your clients and servers to

00:07:30,319 --> 00:07:34,080
support mutual tls

00:07:32,240 --> 00:07:36,160
and in the case of retrofitting a client

00:07:34,080 --> 00:07:39,039
we could stick a proxy like ats

00:07:36,160 --> 00:07:41,599
in front of the client and four years

00:07:39,039 --> 00:07:43,280
ago you could configure ats to always

00:07:41,599 --> 00:07:45,360
provide the same clients or when

00:07:43,280 --> 00:07:46,720
requested so in that case the client

00:07:45,360 --> 00:07:47,520
would talk through the proxy to the

00:07:46,720 --> 00:07:49,440
origin

00:07:47,520 --> 00:07:50,479
the origin would act ask for cert it

00:07:49,440 --> 00:07:51,599
would always provide the same

00:07:50,479 --> 00:07:53,360
certificate

00:07:51,599 --> 00:07:54,879
and that would work but in a lot of

00:07:53,360 --> 00:07:56,319
cases your client is going to need to

00:07:54,879 --> 00:07:57,599
provide different client certs to

00:07:56,319 --> 00:07:59,919
different origins depending on what

00:07:57,599 --> 00:08:04,240
they're asking for

00:07:59,919 --> 00:08:06,879
so we added within ats the ability to do

00:08:04,240 --> 00:08:08,639
fine grain client certificate selection

00:08:06,879 --> 00:08:10,560
we added logic within

00:08:08,639 --> 00:08:12,000
our main routing configuration line that

00:08:10,560 --> 00:08:14,800
will specify for

00:08:12,000 --> 00:08:15,919
this particular transition use this cert

00:08:14,800 --> 00:08:17,479
so here we're showing

00:08:15,919 --> 00:08:18,960
if a client comes in requesting

00:08:17,479 --> 00:08:22,720
bank.yahoo.com

00:08:18,960 --> 00:08:25,039
pci we'll map it to pci.server.com

00:08:22,720 --> 00:08:27,280
and we will use the client cert that's

00:08:25,039 --> 00:08:30,080
in the file pci.pem

00:08:27,280 --> 00:08:31,199
but if the client comes in to yahoo.com

00:08:30,080 --> 00:08:34,680
datastore

00:08:31,199 --> 00:08:36,080
we'll send that request onto

00:08:34,680 --> 00:08:37,839
datastar.datastore.server.com

00:08:36,080 --> 00:08:41,839
and we'll provide the client cert that

00:08:37,839 --> 00:08:43,519
is in datastore.com

00:08:41,839 --> 00:08:45,440
so similarly we have issues with a

00:08:43,519 --> 00:08:49,680
server and we can use our proxy to

00:08:45,440 --> 00:08:51,600
retrofit a server to support mutual tls

00:08:49,680 --> 00:08:53,360
in that case we put a proxy in front of

00:08:51,600 --> 00:08:55,680
the server the origin

00:08:53,360 --> 00:08:57,680
and again when we started four years ago

00:08:55,680 --> 00:09:00,640
we could configure that proxy

00:08:57,680 --> 00:09:01,360
our ats box to always request a client

00:09:00,640 --> 00:09:05,040
certificate

00:09:01,360 --> 00:09:07,279
and that would work but uh in some cases

00:09:05,040 --> 00:09:08,399
in a more complex server environment

00:09:07,279 --> 00:09:11,279
you'd want to only

00:09:08,399 --> 00:09:13,120
ask for a client cert in certain

00:09:11,279 --> 00:09:14,880
situations

00:09:13,120 --> 00:09:16,320
now it's a little harder in this server

00:09:14,880 --> 00:09:17,839
scenario because this is at the very

00:09:16,320 --> 00:09:20,959
beginning of the handshake

00:09:17,839 --> 00:09:23,120
right all we know at this point is

00:09:20,959 --> 00:09:25,680
the client's ip address and what's ever

00:09:23,120 --> 00:09:27,040
in the client hello message

00:09:25,680 --> 00:09:28,800
one of the things that is in the client

00:09:27,040 --> 00:09:30,000
alone message is a server name

00:09:28,800 --> 00:09:33,120
indication or an s

00:09:30,000 --> 00:09:33,920
i and that gives a domain name that the

00:09:33,120 --> 00:09:36,480
service

00:09:33,920 --> 00:09:38,640
is indicating that he wants to talk to

00:09:36,480 --> 00:09:41,839
and all the modern clients do do this

00:09:38,640 --> 00:09:43,120
do provide this tls extension so we can

00:09:41,839 --> 00:09:45,360
take advantage of that and

00:09:43,120 --> 00:09:47,600
we've augmented aats to have a

00:09:45,360 --> 00:09:49,040
configuration where based on the sni

00:09:47,600 --> 00:09:50,800
name provided by the client

00:09:49,040 --> 00:09:52,800
we can do certain things like we can

00:09:50,800 --> 00:09:53,600
adjust what http protocols we're going

00:09:52,800 --> 00:09:56,080
to offer

00:09:53,600 --> 00:09:57,839
maybe we'll offer http 2 or not which

00:09:56,080 --> 00:10:00,480
tls protocols we're going to allow are

00:09:57,839 --> 00:10:01,200
we going to allow tls 1.0 or only tls

00:10:00,480 --> 00:10:03,680
1.2

00:10:01,200 --> 00:10:05,279
1.3 what ciphers we're going to offer

00:10:03,680 --> 00:10:09,120
and then in particular for this case are

00:10:05,279 --> 00:10:09,120
we going to require a client certificate

00:10:09,600 --> 00:10:14,480
so that works however sni

00:10:12,720 --> 00:10:16,000
is not really a security thing the

00:10:14,480 --> 00:10:16,480
client can put whatever they want in for

00:10:16,000 --> 00:10:19,920
the s

00:10:16,480 --> 00:10:21,279
i so we're taking this user provided

00:10:19,920 --> 00:10:23,519
input and we're using it

00:10:21,279 --> 00:10:24,560
for a security decision so that's a bit

00:10:23,519 --> 00:10:26,399
sketchy

00:10:24,560 --> 00:10:28,000
so what happens if we have a user agent

00:10:26,399 --> 00:10:29,839
that doesn't play by the rules

00:10:28,000 --> 00:10:31,519
and here we're showing a malicious user

00:10:29,839 --> 00:10:33,600
talking to a server

00:10:31,519 --> 00:10:35,440
so say and our server is configured to

00:10:33,600 --> 00:10:37,519
require a client certificate for

00:10:35,440 --> 00:10:39,760
accesses to secure.com

00:10:37,519 --> 00:10:42,320
but not for insecure.com so our

00:10:39,760 --> 00:10:44,880
malicious user will send an sni

00:10:42,320 --> 00:10:46,399
in its client hello saying uh

00:10:44,880 --> 00:10:47,920
insecure.com

00:10:46,399 --> 00:10:49,680
the server will see that we'll look

00:10:47,920 --> 00:10:50,160
through its polling cc and say i don't

00:10:49,680 --> 00:10:51,920
need to

00:10:50,160 --> 00:10:53,440
have a client search for that we'll

00:10:51,920 --> 00:10:55,040
complete the handshake

00:10:53,440 --> 00:10:57,279
and then the malicious user later on

00:10:55,040 --> 00:10:58,320
that connection sends a get request with

00:10:57,279 --> 00:11:01,680
a host header

00:10:58,320 --> 00:11:03,279
set to secure.com

00:11:01,680 --> 00:11:05,120
again our server has already set up the

00:11:03,279 --> 00:11:06,160
connection so it merely sends that

00:11:05,120 --> 00:11:08,399
request off to

00:11:06,160 --> 00:11:09,360
secure.com and sends back the sensitive

00:11:08,399 --> 00:11:12,320
response

00:11:09,360 --> 00:11:13,600
from secure.com so we've made this

00:11:12,320 --> 00:11:15,200
assumption that the sni

00:11:13,600 --> 00:11:17,440
corresponds to the host name but we're

00:11:15,200 --> 00:11:19,839
not checking that which is dangerous

00:11:17,440 --> 00:11:21,839
and this is not a super tricky hacker

00:11:19,839 --> 00:11:22,240
kind of thing there is the curl command

00:11:21,839 --> 00:11:25,760
to do

00:11:22,240 --> 00:11:25,760
exactly what i've specified there

00:11:26,399 --> 00:11:31,839
so uh we can't solely rely on the sni

00:11:29,519 --> 00:11:33,440
for our security policy decisions so we

00:11:31,839 --> 00:11:35,040
have several options

00:11:33,440 --> 00:11:37,279
option one we could just back off and

00:11:35,040 --> 00:11:37,839
say ah this s i think that was a bad

00:11:37,279 --> 00:11:40,320
decision

00:11:37,839 --> 00:11:42,079
to be truly secure we should always

00:11:40,320 --> 00:11:44,720
require a client search or not and have

00:11:42,079 --> 00:11:46,560
a dedicated proxy for that

00:11:44,720 --> 00:11:48,560
you could do that again that's a pretty

00:11:46,560 --> 00:11:49,040
tedious kind of thing and there may be

00:11:48,560 --> 00:11:50,160
other s

00:11:49,040 --> 00:11:52,240
i based actions that you want to

00:11:50,160 --> 00:11:54,320
distinguish on so

00:11:52,240 --> 00:11:55,360
we couldn't really do that but option

00:11:54,320 --> 00:11:57,279
two we could

00:11:55,360 --> 00:11:59,200
always check that the s and i and the

00:11:57,279 --> 00:12:00,959
host name and the request match

00:11:59,200 --> 00:12:02,959
but that's probably a bit too much bit

00:12:00,959 --> 00:12:05,920
overkill on the other side

00:12:02,959 --> 00:12:07,360
if the s i name isn't used for a policy

00:12:05,920 --> 00:12:09,040
it doesn't really matter

00:12:07,360 --> 00:12:10,800
and with connection we use some browsers

00:12:09,040 --> 00:12:11,279
it's pretty off frequently you're going

00:12:10,800 --> 00:12:15,360
to have

00:12:11,279 --> 00:12:16,959
a mixture of requests on a connection

00:12:15,360 --> 00:12:19,040
that will have different host names and

00:12:16,959 --> 00:12:20,560
so those would fail so as i show here in

00:12:19,040 --> 00:12:24,240
the diagram the browser

00:12:20,560 --> 00:12:25,920
will negotiate with an snifu.com

00:12:24,240 --> 00:12:27,680
there's no policy associated with that

00:12:25,920 --> 00:12:29,120
so we just do the handshake

00:12:27,680 --> 00:12:31,200
makes a request with a host

00:12:29,120 --> 00:12:33,519
federalfood.com that's great we make the

00:12:31,200 --> 00:12:35,279
check they match we send the response

00:12:33,519 --> 00:12:37,040
makes another request with the host

00:12:35,279 --> 00:12:38,959
header of bar.com

00:12:37,040 --> 00:12:41,120
we make the check the server does that

00:12:38,959 --> 00:12:43,600
bar.com is not equal tofu.com

00:12:41,120 --> 00:12:44,480
so it rejects it and that's probably not

00:12:43,600 --> 00:12:47,120
necessary

00:12:44,480 --> 00:12:48,160
because again in this case the s i

00:12:47,120 --> 00:12:53,040
values weren't

00:12:48,160 --> 00:12:54,959
triggering any security sensitive policy

00:12:53,040 --> 00:12:56,320
so with ats we've took this middle

00:12:54,959 --> 00:12:58,800
ground of saying

00:12:56,320 --> 00:13:00,399
only check the host header and the s i

00:12:58,800 --> 00:13:02,560
if the host header value

00:13:00,399 --> 00:13:05,760
would have triggered a security

00:13:02,560 --> 00:13:08,000
sensitive sni policy

00:13:05,760 --> 00:13:09,519
so in our malicious user case they come

00:13:08,000 --> 00:13:11,600
in with insecure.com

00:13:09,519 --> 00:13:13,760
we handshake without a client cert they

00:13:11,600 --> 00:13:16,160
make a request for secure.com

00:13:13,760 --> 00:13:17,440
our ats is going to check and see that

00:13:16,160 --> 00:13:19,120
the secure.com

00:13:17,440 --> 00:13:20,800
would have triggered an sni policy that

00:13:19,120 --> 00:13:22,800
requires a client cert

00:13:20,800 --> 00:13:23,920
it's going to check to see if the host

00:13:22,800 --> 00:13:26,639
header value

00:13:23,920 --> 00:13:27,920
matches the s i value and they don't so

00:13:26,639 --> 00:13:29,760
it's going to fail the request it's

00:13:27,920 --> 00:13:31,120
going to turn a 403

00:13:29,760 --> 00:13:33,920
and this solution has worked out pretty

00:13:31,120 --> 00:13:36,720
well for us we haven't it catches

00:13:33,920 --> 00:13:40,079
problems and we haven't had very many

00:13:36,720 --> 00:13:40,079
false failures

00:13:40,240 --> 00:13:43,600
in the community there's been uh

00:13:41,600 --> 00:13:45,600
proposals for other solutions to address

00:13:43,600 --> 00:13:48,000
this specifically in the h22 bis

00:13:45,600 --> 00:13:49,839
working group there has been a straft

00:13:48,000 --> 00:13:51,440
rfc floating around for secondary

00:13:49,839 --> 00:13:53,199
certificate authentic authentication and

00:13:51,440 --> 00:13:55,760
hdb2

00:13:53,199 --> 00:13:58,079
and what they propose is dynamically

00:13:55,760 --> 00:14:00,320
renegotiating for clancerts

00:13:58,079 --> 00:14:02,959
and this works out and could be

00:14:00,320 --> 00:14:05,760
implemented today with http 1

00:14:02,959 --> 00:14:07,199
because the underlying tls does support

00:14:05,760 --> 00:14:10,560
renegotiating

00:14:07,199 --> 00:14:13,600
client security certificates for

00:14:10,560 --> 00:14:14,800
both tls 1.3 and earlier so in that

00:14:13,600 --> 00:14:16,160
scenario the diagram

00:14:14,800 --> 00:14:18,399
shows we would get our sni for

00:14:16,160 --> 00:14:19,920
insecure.com we'd do the handshake we'd

00:14:18,399 --> 00:14:21,040
get a request for the host header of

00:14:19,920 --> 00:14:22,720
secure.com

00:14:21,040 --> 00:14:24,240
the server would recognize that it needs

00:14:22,720 --> 00:14:26,000
a client search for that

00:14:24,240 --> 00:14:27,680
it would renegotiate the connection

00:14:26,000 --> 00:14:29,440
requesting a client cert

00:14:27,680 --> 00:14:32,240
the browser would send the client cert

00:14:29,440 --> 00:14:35,279
it'd validate and we'd all be great

00:14:32,240 --> 00:14:37,040
in http one requests are made in series

00:14:35,279 --> 00:14:38,880
one after another so there's always a

00:14:37,040 --> 00:14:40,000
sense of what's the current transaction

00:14:38,880 --> 00:14:42,079
on the connection

00:14:40,000 --> 00:14:43,519
so we can kind of leverage that lower

00:14:42,079 --> 00:14:46,240
level tls

00:14:43,519 --> 00:14:48,160
to bootstrap us up and get newer client

00:14:46,240 --> 00:14:49,120
certs to match the transactions as they

00:14:48,160 --> 00:14:51,920
come

00:14:49,120 --> 00:14:54,160
but in http 2 there can be multiple

00:14:51,920 --> 00:14:57,680
parallel active connections there's no

00:14:54,160 --> 00:15:00,160
sense of just one current transaction

00:14:57,680 --> 00:15:01,839
so leveraging the current client

00:15:00,160 --> 00:15:04,160
certificate for the underlying tls

00:15:01,839 --> 00:15:07,440
connection just doesn't make any sense

00:15:04,160 --> 00:15:09,839
and the rfc recognizes that and proposes

00:15:07,440 --> 00:15:11,199
additional logic at the http 2 level to

00:15:09,839 --> 00:15:12,560
track all of this

00:15:11,199 --> 00:15:13,839
and once that gets approved and

00:15:12,560 --> 00:15:15,920
implemented that would be a good

00:15:13,839 --> 00:15:17,600
approach and we'll reconsider that

00:15:15,920 --> 00:15:18,959
but at this point our current approach

00:15:17,600 --> 00:15:21,360
supports both hdb

00:15:18,959 --> 00:15:23,839
one and two and so we're continuing on

00:15:21,360 --> 00:15:23,839
with that

00:15:24,800 --> 00:15:28,399
so with this technology we've

00:15:27,279 --> 00:15:32,079
implemented

00:15:28,399 --> 00:15:34,240
a secure edge to proxy tls

00:15:32,079 --> 00:15:37,120
as traffic is entering and leaving our

00:15:34,240 --> 00:15:37,120
various clouds

00:15:37,519 --> 00:15:41,199
so it's a lot like retrofitting the tls

00:15:40,079 --> 00:15:43,600
server

00:15:41,199 --> 00:15:46,959
so a server in a cloud we may not want

00:15:43,600 --> 00:15:49,040
to directly expose to the outside world

00:15:46,959 --> 00:15:52,320
so we have this edge that's proxying

00:15:49,040 --> 00:15:55,680
requests towards the servers

00:15:52,320 --> 00:15:57,120
we don't want to expose those cloud

00:15:55,680 --> 00:15:59,519
servers directly because we may not

00:15:57,120 --> 00:16:02,480
trust the implementation completely

00:15:59,519 --> 00:16:03,440
and also our security team finds it

00:16:02,480 --> 00:16:05,440
easier and

00:16:03,440 --> 00:16:07,199
more direct to be able to concentrate on

00:16:05,440 --> 00:16:09,120
one implementation to ensure that the

00:16:07,199 --> 00:16:11,680
security policy isn't consistently

00:16:09,120 --> 00:16:13,600
enforced

00:16:11,680 --> 00:16:15,040
so we have three options or i'll talk

00:16:13,600 --> 00:16:16,480
about three options about how we're

00:16:15,040 --> 00:16:19,920
proxying tls through

00:16:16,480 --> 00:16:23,360
our secure edge tls delegation

00:16:19,920 --> 00:16:25,360
tunneling and bridging before i go into

00:16:23,360 --> 00:16:27,440
tls delegation though let me say a few

00:16:25,360 --> 00:16:29,360
more words about how athens implements

00:16:27,440 --> 00:16:31,680
authentication and authorization

00:16:29,360 --> 00:16:32,639
so as i said earlier athens builds on

00:16:31,680 --> 00:16:35,440
top of

00:16:32,639 --> 00:16:38,160
mutual tls authentication so the client

00:16:35,440 --> 00:16:38,720
provides an x 509 athens client cert

00:16:38,160 --> 00:16:42,480
that's

00:16:38,720 --> 00:16:43,279
signed by our athens ca and inside the

00:16:42,480 --> 00:16:45,680
cert

00:16:43,279 --> 00:16:47,600
uh there is uh one of the common names

00:16:45,680 --> 00:16:49,680
identifies the athens principal or the

00:16:47,600 --> 00:16:52,560
athens user

00:16:49,680 --> 00:16:54,959
then later requests over that connection

00:16:52,560 --> 00:16:57,120
will include an athens token

00:16:54,959 --> 00:16:59,759
in the header of the client request and

00:16:57,120 --> 00:17:02,480
that athens token is an oauth 2

00:16:59,759 --> 00:17:04,079
token it defines the principle and the

00:17:02,480 --> 00:17:07,919
rules that that principle

00:17:04,079 --> 00:17:10,240
are is authorized for so based on that

00:17:07,919 --> 00:17:12,400
token the server can verify that the

00:17:10,240 --> 00:17:15,600
request that that principal is making

00:17:12,400 --> 00:17:18,240
is allowed based on the rules the

00:17:15,600 --> 00:17:20,319
token itself has a limited lifetime and

00:17:18,240 --> 00:17:23,360
it's signed

00:17:20,319 --> 00:17:26,160
so with that kind of background

00:17:23,360 --> 00:17:28,000
here is how we are supporting tls

00:17:26,160 --> 00:17:29,600
delegation for athens

00:17:28,000 --> 00:17:31,520
so in this case we have a client we have

00:17:29,600 --> 00:17:33,360
a proxy and

00:17:31,520 --> 00:17:35,840
and the proxy is a member of our secure

00:17:33,360 --> 00:17:38,400
edge running ats

00:17:35,840 --> 00:17:40,559
the client will come in and make a

00:17:38,400 --> 00:17:41,039
connection to the proxy it will provide

00:17:40,559 --> 00:17:43,520
its

00:17:41,039 --> 00:17:45,120
athens client search to the proxy and

00:17:43,520 --> 00:17:48,400
the proxy will perform an

00:17:45,120 --> 00:17:50,960
f1 function to verify the client cert

00:17:48,400 --> 00:17:53,600
mostly verifying that it is signed by

00:17:50,960 --> 00:17:57,360
the fnca

00:17:53,600 --> 00:17:58,320
then the proxy will later make a request

00:17:57,360 --> 00:18:00,480
on that connection

00:17:58,320 --> 00:18:02,320
and that request will include an athens

00:18:00,480 --> 00:18:04,960
token in the header

00:18:02,320 --> 00:18:06,160
so an f2 function will be performed by

00:18:04,960 --> 00:18:08,400
the proxy

00:18:06,160 --> 00:18:10,080
uh in this case it's implemented in a

00:18:08,400 --> 00:18:12,559
plug-in off the

00:18:10,080 --> 00:18:13,120
read request header hook and that

00:18:12,559 --> 00:18:15,520
function

00:18:13,120 --> 00:18:16,960
will take the client cert and the

00:18:15,520 --> 00:18:19,120
authorization header

00:18:16,960 --> 00:18:20,720
and it's going to make sure that the

00:18:19,120 --> 00:18:23,360
authorization

00:18:20,720 --> 00:18:24,799
header so the access token is bound to

00:18:23,360 --> 00:18:26,160
the client search so that the principal

00:18:24,799 --> 00:18:28,240
names match

00:18:26,160 --> 00:18:30,160
it will also verify that the access

00:18:28,240 --> 00:18:31,760
token is otherwise well-formed

00:18:30,160 --> 00:18:33,280
and assuming that all checks out it's

00:18:31,760 --> 00:18:34,320
going to add a verification header to

00:18:33,280 --> 00:18:36,480
the request

00:18:34,320 --> 00:18:38,880
and it's going to turn around and make

00:18:36,480 --> 00:18:41,039
the connection to the server

00:18:38,880 --> 00:18:42,559
it cannot reuse the client-cert because

00:18:41,039 --> 00:18:43,679
it doesn't have access to the client

00:18:42,559 --> 00:18:45,280
cert key

00:18:43,679 --> 00:18:48,559
but instead it's going to provide a

00:18:45,280 --> 00:18:51,919
proxy app insert to the server

00:18:48,559 --> 00:18:54,960
the server will verify the goodness

00:18:51,919 --> 00:18:55,520
of the proxy cert and then assuming that

00:18:54,960 --> 00:18:58,000
works out

00:18:55,520 --> 00:18:59,520
complete the connection and the proxy

00:18:58,000 --> 00:19:00,559
will forward on the request to the

00:18:59,520 --> 00:19:03,760
server

00:19:00,559 --> 00:19:06,480
with the original access token a

00:19:03,760 --> 00:19:08,160
and its validation header v then the

00:19:06,480 --> 00:19:09,679
server is going to perform its own

00:19:08,160 --> 00:19:12,160
validation step

00:19:09,679 --> 00:19:12,960
ensuring that the validation header is

00:19:12,160 --> 00:19:15,200
present

00:19:12,960 --> 00:19:16,640
and that the access token is well-formed

00:19:15,200 --> 00:19:18,320
so it's going to take

00:19:16,640 --> 00:19:20,799
the proxy's word for it that that

00:19:18,320 --> 00:19:23,840
request came from a client that had

00:19:20,799 --> 00:19:25,039
an access token bound to that uh sorry a

00:19:23,840 --> 00:19:26,240
client cert that was bound to that

00:19:25,039 --> 00:19:28,320
access token

00:19:26,240 --> 00:19:29,919
assuming that all checks out it'll send

00:19:28,320 --> 00:19:31,919
a response to the proxy the proxy will

00:19:29,919 --> 00:19:34,160
stand a response back to the client and

00:19:31,919 --> 00:19:37,679
all is good

00:19:34,160 --> 00:19:39,919
so this works out well uh the logic

00:19:37,679 --> 00:19:41,679
the tls connection is terminated on the

00:19:39,919 --> 00:19:43,760
proxy

00:19:41,679 --> 00:19:45,520
but now we've added another step so as

00:19:43,760 --> 00:19:46,240
an attacker this is another point where

00:19:45,520 --> 00:19:49,919
we could go

00:19:46,240 --> 00:19:52,240
and try to attack and a malicious user

00:19:49,919 --> 00:19:54,880
could try to bypass the proxy completely

00:19:52,240 --> 00:19:56,960
and try to pretend to be its own proxy

00:19:54,880 --> 00:19:58,640
and try to connect up to the server

00:19:56,960 --> 00:20:00,480
since the malicious user

00:19:58,640 --> 00:20:02,400
if it's acting as a proxy doesn't have

00:20:00,480 --> 00:20:03,760
to have a client cert that matches the

00:20:02,400 --> 00:20:06,880
access token

00:20:03,760 --> 00:20:08,480
it maybe makes it a little easier so the

00:20:06,880 --> 00:20:10,799
malicious user would make a connection

00:20:08,480 --> 00:20:14,000
to the server assuming that it could

00:20:10,799 --> 00:20:15,120
uh and it will provide its own version

00:20:14,000 --> 00:20:17,760
of a client cert

00:20:15,120 --> 00:20:18,880
and if that client cert that m cert

00:20:17,760 --> 00:20:21,679
checks out

00:20:18,880 --> 00:20:23,760
the handshake will complete and it can

00:20:21,679 --> 00:20:26,640
make a request with an access token

00:20:23,760 --> 00:20:27,919
and a verification header the access

00:20:26,640 --> 00:20:29,919
token is signed

00:20:27,919 --> 00:20:32,880
so presumably our malicious user has

00:20:29,919 --> 00:20:34,400
stolen an access token from someplace

00:20:32,880 --> 00:20:36,320
assuming that all checks out then it

00:20:34,400 --> 00:20:37,840
could get the response from the server

00:20:36,320 --> 00:20:39,840
so there's a couple levels of protection

00:20:37,840 --> 00:20:41,520
here the malicious user will have to

00:20:39,840 --> 00:20:44,240
find someplace assign

00:20:41,520 --> 00:20:45,919
a signed access token and then

00:20:44,240 --> 00:20:46,799
secondarily it's going to have to create

00:20:45,919 --> 00:20:51,120
or steal

00:20:46,799 --> 00:20:52,960
a client cert so this is the area where

00:20:51,120 --> 00:20:55,679
we need to be careful on the client cert

00:20:52,960 --> 00:20:57,360
what work what makes a good client cert

00:20:55,679 --> 00:20:58,880
so in our case it has to be signed by

00:20:57,360 --> 00:20:59,679
the authentica so that's a bit more

00:20:58,880 --> 00:21:01,360
difficult

00:20:59,679 --> 00:21:03,520
but if you're setting up your server so

00:21:01,360 --> 00:21:06,559
any kind of well

00:21:03,520 --> 00:21:09,039
any cert signed by a common ca

00:21:06,559 --> 00:21:10,799
like digicert works then all our

00:21:09,039 --> 00:21:11,600
malicious user would have to do is go to

00:21:10,799 --> 00:21:13,440
digicert

00:21:11,600 --> 00:21:15,679
pay a little bit of money and get a

00:21:13,440 --> 00:21:16,159
valid cert so that's one of the areas

00:21:15,679 --> 00:21:17,280
that

00:21:16,159 --> 00:21:20,559
as you're designing these kind of

00:21:17,280 --> 00:21:20,559
systems you need to be careful

00:21:20,720 --> 00:21:26,320
moving on another option is

00:21:24,000 --> 00:21:27,679
tls tunneling so as i mentioned in tls

00:21:26,320 --> 00:21:29,840
delegation we are

00:21:27,679 --> 00:21:31,600
breaking the we're terminating the tls

00:21:29,840 --> 00:21:34,559
tunnel at the proxy so

00:21:31,600 --> 00:21:36,640
clear text is sitting at the proxy for

00:21:34,559 --> 00:21:38,080
some traffic that is unacceptable

00:21:36,640 --> 00:21:40,159
uh particularly for things that have

00:21:38,080 --> 00:21:42,400
compliance issues like pci and payment

00:21:40,159 --> 00:21:44,000
systems we just cannot terminate on the

00:21:42,400 --> 00:21:47,600
edge tunnel we need to

00:21:44,000 --> 00:21:50,320
limit the exposure of that data so

00:21:47,600 --> 00:21:52,320
in that case we can provide a tls tunnel

00:21:50,320 --> 00:21:53,679
so in that case the tls is end to end it

00:21:52,320 --> 00:21:56,159
goes from the server

00:21:53,679 --> 00:21:58,240
sorry from the client to the server and

00:21:56,159 --> 00:21:58,960
we have a policy that based on the sni

00:21:58,240 --> 00:22:00,720
name

00:21:58,960 --> 00:22:02,880
we're going to see oh instead of

00:22:00,720 --> 00:22:05,280
terminating it we should send it on to

00:22:02,880 --> 00:22:08,159
this other

00:22:05,280 --> 00:22:10,000
destination so here we have fqdn of

00:22:08,159 --> 00:22:12,400
supersensitive example.com

00:22:10,000 --> 00:22:13,200
if we see that as the s i we are going

00:22:12,400 --> 00:22:15,440
to forward

00:22:13,200 --> 00:22:17,400
that clientele and all the other traffic

00:22:15,440 --> 00:22:18,880
directly to

00:22:17,400 --> 00:22:20,640
supersensitiveorigin.example.com

00:22:18,880 --> 00:22:23,200
and then all other traffic is just going

00:22:20,640 --> 00:22:26,400
to be blindly passed back and forth

00:22:23,200 --> 00:22:28,559
through the proxy so that works it

00:22:26,400 --> 00:22:30,159
uh we don't terminate the connection but

00:22:28,559 --> 00:22:32,159
we don't really have any

00:22:30,159 --> 00:22:33,760
control or understanding at the proxy

00:22:32,159 --> 00:22:37,280
level of the strength

00:22:33,760 --> 00:22:39,600
of the tls are they doing mutual tls

00:22:37,280 --> 00:22:40,640
um what protocol version are they using

00:22:39,600 --> 00:22:43,360
we just don't know

00:22:40,640 --> 00:22:46,799
and you have to go back to and audit the

00:22:43,360 --> 00:22:46,799
client and the server to do that

00:22:47,360 --> 00:22:51,200
bridging also avoids that decryption on

00:22:50,320 --> 00:22:53,520
the proxy

00:22:51,200 --> 00:22:56,000
but it allows us to make some guarantees

00:22:53,520 --> 00:22:58,000
on the strength of our tls connection

00:22:56,000 --> 00:22:59,520
independent of the user agent or the

00:22:58,000 --> 00:23:01,039
server stack

00:22:59,520 --> 00:23:02,559
so in that case we're going to build a

00:23:01,039 --> 00:23:04,960
separate tunnel between

00:23:02,559 --> 00:23:07,679
two gateways two ats boxes and

00:23:04,960 --> 00:23:10,720
potentially double tunnel the traffic

00:23:07,679 --> 00:23:13,679
so here's a diagram of how that sets up

00:23:10,720 --> 00:23:16,480
in this case our client is going to be

00:23:13,679 --> 00:23:18,720
proxying against the ingress ats

00:23:16,480 --> 00:23:20,159
it's going to send a connect request for

00:23:18,720 --> 00:23:21,120
service but that's going to get

00:23:20,159 --> 00:23:23,760
intercepted

00:23:21,120 --> 00:23:25,600
delivered to the ingress ats and that's

00:23:23,760 --> 00:23:26,880
going to get intercepted by our tls

00:23:25,600 --> 00:23:28,880
bridge plugin which is going to be

00:23:26,880 --> 00:23:30,240
configured to say oh any connect request

00:23:28,880 --> 00:23:32,880
is going to service

00:23:30,240 --> 00:23:34,159
i instead want to send through a tls

00:23:32,880 --> 00:23:35,760
tunnel that i'm going to set up with

00:23:34,159 --> 00:23:38,799
pure ats

00:23:35,760 --> 00:23:39,280
so it sees the connect to service it

00:23:38,799 --> 00:23:41,360
starts

00:23:39,280 --> 00:23:43,440
uh setting up and negotiating a tls

00:23:41,360 --> 00:23:45,360
tunnel with the pure ats which we have

00:23:43,440 --> 00:23:46,799
complete control over

00:23:45,360 --> 00:23:48,480
once that's set up then it's going to

00:23:46,799 --> 00:23:49,039
blindly tunnel everything it gets from

00:23:48,480 --> 00:23:50,880
the client

00:23:49,039 --> 00:23:52,240
into the tunnel to the pure ats where

00:23:50,880 --> 00:23:54,000
it's going to come out of the tunnel

00:23:52,240 --> 00:23:55,840
and go to the service and then return

00:23:54,000 --> 00:23:59,360
traffic similarly we'll go

00:23:55,840 --> 00:24:01,760
to the pure ats into the tunnel into the

00:23:59,360 --> 00:24:03,279
into the ingress ats out of the tunnel

00:24:01,760 --> 00:24:05,679
back to the client

00:24:03,279 --> 00:24:06,400
so here again our traffic from client to

00:24:05,679 --> 00:24:08,480
server

00:24:06,400 --> 00:24:09,600
is not decrypted on either of our ats

00:24:08,480 --> 00:24:13,039
boxes

00:24:09,600 --> 00:24:14,799
but between our two ats boxes going over

00:24:13,039 --> 00:24:17,279
our untrusted network

00:24:14,799 --> 00:24:18,000
we have control over the strength of

00:24:17,279 --> 00:24:19,919
that tls

00:24:18,000 --> 00:24:22,080
connection so we can enforce our mutual

00:24:19,919 --> 00:24:25,840
tls what proxies were

00:24:22,080 --> 00:24:25,840
protocols we're providing etc

00:24:28,480 --> 00:24:33,039
and here's another diagram showing

00:24:31,200 --> 00:24:37,360
basically what i talked about

00:24:33,039 --> 00:24:37,360
another way of looking at that flow

00:24:39,360 --> 00:24:44,240
so wrapping it up the secure edge

00:24:42,799 --> 00:24:46,640
approach has been very

00:24:44,240 --> 00:24:48,159
instrumental for verizon media to be

00:24:46,640 --> 00:24:50,000
able to move our applications to the

00:24:48,159 --> 00:24:52,320
hybrid cloud

00:24:50,000 --> 00:24:53,120
the proxy layer that secure edge layer

00:24:52,320 --> 00:24:56,000
provides one

00:24:53,120 --> 00:24:58,240
place to ensure that security policy is

00:24:56,000 --> 00:25:01,760
applied consistently

00:24:58,240 --> 00:25:03,840
it also enables enables us to leverage

00:25:01,760 --> 00:25:06,080
our knowledge all teams do not have to

00:25:03,840 --> 00:25:08,320
become mutual tls experts

00:25:06,080 --> 00:25:10,720
uh we provide support for teams as

00:25:08,320 --> 00:25:13,840
they're onboarding to the secure edge

00:25:10,720 --> 00:25:15,440
and also it has the possibility so our

00:25:13,840 --> 00:25:17,279
clients and servers for different

00:25:15,440 --> 00:25:18,400
applications can move between clouds

00:25:17,279 --> 00:25:20,559
over time

00:25:18,400 --> 00:25:22,400
and it doesn't dramatically affect the

00:25:20,559 --> 00:25:24,000
security policy right we're still going

00:25:22,400 --> 00:25:25,760
to authenticate via athens

00:25:24,000 --> 00:25:27,520
regardless of whether the client comes

00:25:25,760 --> 00:25:28,960
in from an on-premise cloud or

00:25:27,520 --> 00:25:30,720
third-party cloud

00:25:28,960 --> 00:25:33,360
and similarly with the servers the

00:25:30,720 --> 00:25:35,600
servers will still require client certs

00:25:33,360 --> 00:25:38,000
client ath inserts regardless of which

00:25:35,600 --> 00:25:41,039
cloud they're sitting in

00:25:38,000 --> 00:25:43,279
so this and leveraging

00:25:41,039 --> 00:25:45,120
open source technology has really

00:25:43,279 --> 00:25:46,799
enabled us to nimbly move into the

00:25:45,120 --> 00:25:48,799
hybrid cloud and provide us a very

00:25:46,799 --> 00:25:51,200
secure stance

00:25:48,799 --> 00:25:52,320
and with that if there are any questions

00:25:51,200 --> 00:25:54,840
i have a few

00:25:52,320 --> 00:25:57,840
minutes we'd be happy to answer any

00:25:54,840 --> 00:25:57,840
questions

00:30:47,919 --> 00:30:50,000

YouTube URL: https://www.youtube.com/watch?v=KuioxbDhhj4


