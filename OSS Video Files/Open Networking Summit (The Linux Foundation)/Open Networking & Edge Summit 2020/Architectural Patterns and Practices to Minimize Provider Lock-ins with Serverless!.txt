Title: Architectural Patterns and Practices to Minimize Provider Lock-ins with Serverless!
Publication date: 2020-10-28
Playlist: Open Networking & Edge Summit 2020
Description: 
	Architectural Patterns and Practices to Minimize Provider Lock-ins with Serverless! - Murali Kaundinya
Captions: 
	00:00:01,599 --> 00:00:05,279
greetings to viewers

00:00:03,280 --> 00:00:07,359
and welcome to this virtual presentation

00:00:05,279 --> 00:00:09,440
on patterns and practices

00:00:07,359 --> 00:00:10,880
to minimize provider lock-ins with

00:00:09,440 --> 00:00:12,559
serverless

00:00:10,880 --> 00:00:14,480
this has been an extraordinary year and

00:00:12,559 --> 00:00:16,960
i want to begin with my profound thanks

00:00:14,480 --> 00:00:19,920
to the organizers of this conference

00:00:16,960 --> 00:00:21,199
uh it wouldn't have really been easy so

00:00:19,920 --> 00:00:23,840
heartfelt thanks for

00:00:21,199 --> 00:00:24,880
all the hard work here when i submitted

00:00:23,840 --> 00:00:27,920
this abstract

00:00:24,880 --> 00:00:29,840
for this talk back in february 2020

00:00:27,920 --> 00:00:30,960
none of us could have imagined how the

00:00:29,840 --> 00:00:34,079
rest of the year would

00:00:30,960 --> 00:00:36,160
unfold in that same vein

00:00:34,079 --> 00:00:38,559
none of us could have imagined the

00:00:36,160 --> 00:00:41,520
amazing progress that has been happening

00:00:38,559 --> 00:00:42,960
in the world of serverless particularly

00:00:41,520 --> 00:00:46,160
there is a cloud native

00:00:42,960 --> 00:00:48,640
computing foundation that is associated

00:00:46,160 --> 00:00:51,199
with the linux foundation

00:00:48,640 --> 00:00:52,160
there is a working group that is curated

00:00:51,199 --> 00:00:55,680
so much

00:00:52,160 --> 00:00:58,879
about events and functions my goal

00:00:55,680 --> 00:01:00,719
in this talk is to share the work of the

00:00:58,879 --> 00:01:01,760
cloud native computing foundation

00:01:00,719 --> 00:01:03,840
working group

00:01:01,760 --> 00:01:06,000
and acquaint you with the emerging

00:01:03,840 --> 00:01:07,840
trends standards

00:01:06,000 --> 00:01:09,439
patterns and practices that could be

00:01:07,840 --> 00:01:12,880
helpful so

00:01:09,439 --> 00:01:16,080
let's dive in

00:01:12,880 --> 00:01:18,240
it can be a bit confusing

00:01:16,080 --> 00:01:19,439
to use the word serverless because

00:01:18,240 --> 00:01:21,600
clearly there are

00:01:19,439 --> 00:01:22,799
servers being managed somewhere by

00:01:21,600 --> 00:01:24,640
somebody

00:01:22,799 --> 00:01:26,880
but somehow its significance to the

00:01:24,640 --> 00:01:28,640
architecture is a bit diminished in the

00:01:26,880 --> 00:01:31,680
current scheme of things

00:01:28,640 --> 00:01:32,880
it's better to think of events event

00:01:31,680 --> 00:01:35,520
sources

00:01:32,880 --> 00:01:36,560
and how they are invoking functions

00:01:35,520 --> 00:01:39,600
synchronously

00:01:36,560 --> 00:01:40,799
or asynchronously through an enabling

00:01:39,600 --> 00:01:42,880
platform

00:01:40,799 --> 00:01:44,320
which in turn manages the many

00:01:42,880 --> 00:01:47,759
prerequisites

00:01:44,320 --> 00:01:50,880
uh you know such as identity uh

00:01:47,759 --> 00:01:53,280
you know the data and the access

00:01:50,880 --> 00:01:54,960
you know to the various functions in the

00:01:53,280 --> 00:01:58,240
back end right

00:01:54,960 --> 00:02:01,040
we've actually seen papers written

00:01:58,240 --> 00:02:01,759
about you know motivating the serverless

00:02:01,040 --> 00:02:04,399
architecture

00:02:01,759 --> 00:02:05,840
to think about the binding of you know

00:02:04,399 --> 00:02:07,840
function as a service

00:02:05,840 --> 00:02:09,440
which in turn you know ties to a back

00:02:07,840 --> 00:02:12,800
end as a service construct

00:02:09,440 --> 00:02:15,920
right i wanted to you know

00:02:12,800 --> 00:02:18,640
talk about what are all the choices

00:02:15,920 --> 00:02:20,560
that you have to think about in order to

00:02:18,640 --> 00:02:22,400
make sure that you minimize

00:02:20,560 --> 00:02:23,680
the lock-in that you may otherwise

00:02:22,400 --> 00:02:26,400
suffer from a vendor

00:02:23,680 --> 00:02:28,640
clearly the platform that you choose you

00:02:26,400 --> 00:02:31,280
have to carefully think about that

00:02:28,640 --> 00:02:32,000
how do you go about developing the

00:02:31,280 --> 00:02:33,680
events

00:02:32,000 --> 00:02:35,680
where do they originate from whether

00:02:33,680 --> 00:02:39,280
they come from a programmer's

00:02:35,680 --> 00:02:42,080
ide or a service or an iot device

00:02:39,280 --> 00:02:43,200
how exactly do you bind that to a an

00:02:42,080 --> 00:02:46,000
endpoint

00:02:43,200 --> 00:02:46,800
and how do you really manage the ongoing

00:02:46,000 --> 00:02:49,360
life cycle

00:02:46,800 --> 00:02:50,239
of all of these changes is the crux of

00:02:49,360 --> 00:02:52,800
this talk

00:02:50,239 --> 00:02:54,160
okay i wanted to take a moment to

00:02:52,800 --> 00:02:57,200
introduce myself

00:02:54,160 --> 00:02:59,599
uh my name is marlee kondinia i work

00:02:57,200 --> 00:03:02,159
with a very large financial institution

00:02:59,599 --> 00:03:03,680
uh focusing primarily around enterprise

00:03:02,159 --> 00:03:06,879
platforms

00:03:03,680 --> 00:03:10,400
you know i do a lot of cloud native work

00:03:06,879 --> 00:03:11,680
on the ci cd middleware and sre but my

00:03:10,400 --> 00:03:14,480
fundamental passion

00:03:11,680 --> 00:03:16,879
is around developer productivity

00:03:14,480 --> 00:03:18,959
developing patterns and practices

00:03:16,879 --> 00:03:19,920
helping developers make the right

00:03:18,959 --> 00:03:23,840
choices

00:03:19,920 --> 00:03:27,440
so they are by default the easy choice

00:03:23,840 --> 00:03:29,519
so let's dive in right um

00:03:27,440 --> 00:03:31,519
when you think about serverless it might

00:03:29,519 --> 00:03:34,799
really be helpful to start with a set of

00:03:31,519 --> 00:03:37,440
technical use cases right

00:03:34,799 --> 00:03:38,000
serverless architectures or events or

00:03:37,440 --> 00:03:40,000
functions

00:03:38,000 --> 00:03:41,040
depending on how we think about it they

00:03:40,000 --> 00:03:44,159
are nothing but

00:03:41,040 --> 00:03:44,799
loosely coupled asynchronous in a

00:03:44,159 --> 00:03:47,680
concurrent

00:03:44,799 --> 00:03:49,280
parallelizable systems they have the

00:03:47,680 --> 00:03:52,400
means to scale up and down

00:03:49,280 --> 00:03:54,000
with unpredictable workloads uh you know

00:03:52,400 --> 00:03:57,280
they obviously are stateless

00:03:54,000 --> 00:03:58,000
and short-lived so they are highly

00:03:57,280 --> 00:04:00,560
dynamic

00:03:58,000 --> 00:04:01,439
you know supporting change velocity and

00:04:00,560 --> 00:04:03,439
when you think about

00:04:01,439 --> 00:04:04,879
you know the classical applications that

00:04:03,439 --> 00:04:06,400
tend to benefit from it

00:04:04,879 --> 00:04:09,280
if you're really sending a lot of

00:04:06,400 --> 00:04:11,280
triggers and doing a lot of analytics

00:04:09,280 --> 00:04:13,200
you're doing some stream processing or

00:04:11,280 --> 00:04:16,160
doing etl

00:04:13,200 --> 00:04:16,479
or even ci cd for that matter these are

00:04:16,160 --> 00:04:18,880
all

00:04:16,479 --> 00:04:19,919
prime candidates you know for you to

00:04:18,880 --> 00:04:22,400
consider

00:04:19,919 --> 00:04:24,240
the event-driven architecture with a

00:04:22,400 --> 00:04:26,479
function as a service back-end

00:04:24,240 --> 00:04:28,800
right so let's also talk a little bit

00:04:26,479 --> 00:04:29,120
about the business use cases because we

00:04:28,800 --> 00:04:32,320
all

00:04:29,120 --> 00:04:33,120
work for enterprises in some form or

00:04:32,320 --> 00:04:35,840
shape

00:04:33,120 --> 00:04:37,120
so when you think about the integrated

00:04:35,840 --> 00:04:39,199
you know account view

00:04:37,120 --> 00:04:40,800
of how end users are really interacting

00:04:39,199 --> 00:04:44,160
with the platform

00:04:40,800 --> 00:04:47,600
they are you know traversing multiple

00:04:44,160 --> 00:04:48,639
you know services that are exposed to

00:04:47,600 --> 00:04:51,440
the web

00:04:48,639 --> 00:04:52,560
and these transactions that you are

00:04:51,440 --> 00:04:55,040
really supporting

00:04:52,560 --> 00:04:57,759
with end users have to be managed

00:04:55,040 --> 00:05:00,160
seamlessly across a multitude of devices

00:04:57,759 --> 00:05:01,520
and channels you really need to have a

00:05:00,160 --> 00:05:03,440
360 degree view

00:05:01,520 --> 00:05:05,440
and a real-time understanding of what is

00:05:03,440 --> 00:05:07,600
really going on with the customer

00:05:05,440 --> 00:05:08,800
so you can really provide a unified

00:05:07,600 --> 00:05:10,800
experience

00:05:08,800 --> 00:05:11,840
now think about all the things that

00:05:10,800 --> 00:05:14,160
you've really seen

00:05:11,840 --> 00:05:14,960
in the world of uber in the world of

00:05:14,160 --> 00:05:19,360
airbnb

00:05:14,960 --> 00:05:21,759
and so on where disruption is happening

00:05:19,360 --> 00:05:23,120
without you having to commit a whole lot

00:05:21,759 --> 00:05:24,880
of capital

00:05:23,120 --> 00:05:26,560
to build all of these enterprise

00:05:24,880 --> 00:05:29,039
services

00:05:26,560 --> 00:05:29,840
you typically have uh you know the means

00:05:29,039 --> 00:05:32,800
to federate

00:05:29,840 --> 00:05:33,759
many of these sources and you can you

00:05:32,800 --> 00:05:35,919
know appreciate

00:05:33,759 --> 00:05:38,000
the loosely coupled nature of how you're

00:05:35,919 --> 00:05:38,400
really integrating all these things to

00:05:38,000 --> 00:05:41,280
create

00:05:38,400 --> 00:05:42,639
value for end users depending on whether

00:05:41,280 --> 00:05:45,919
you're working for a bank

00:05:42,639 --> 00:05:46,960
or for any services sector you can

00:05:45,919 --> 00:05:49,199
appreciate

00:05:46,960 --> 00:05:50,000
that you're going to reuse services

00:05:49,199 --> 00:05:52,560
available

00:05:50,000 --> 00:05:55,199
in the world outside and create

00:05:52,560 --> 00:05:59,039
additional value for the end user

00:05:55,199 --> 00:06:01,600
so now with that background

00:05:59,039 --> 00:06:03,360
what exactly are the choices for you

00:06:01,600 --> 00:06:05,840
right i mean typically when you look at

00:06:03,360 --> 00:06:08,720
the options for you to deploy

00:06:05,840 --> 00:06:10,800
serverless architecture systems you

00:06:08,720 --> 00:06:14,479
either have the option

00:06:10,800 --> 00:06:18,080
of deploying the platform in your

00:06:14,479 --> 00:06:21,600
premises what we call as on-prem or

00:06:18,080 --> 00:06:24,960
you could choose to deploy your systems

00:06:21,600 --> 00:06:26,560
on the public cloud now i wanted to

00:06:24,960 --> 00:06:30,080
quickly share

00:06:26,560 --> 00:06:33,440
the major installable platforms

00:06:30,080 --> 00:06:34,240
that are installable on-prem as well as

00:06:33,440 --> 00:06:36,720
the major

00:06:34,240 --> 00:06:38,240
providers in the public cloud who offer

00:06:36,720 --> 00:06:40,479
this as a service

00:06:38,240 --> 00:06:42,960
it pretty much comes down to you know

00:06:40,479 --> 00:06:45,039
amongst the installable platforms

00:06:42,960 --> 00:06:46,479
it's a matter of you know what flavor of

00:06:45,039 --> 00:06:50,240
kubernetes that you really

00:06:46,479 --> 00:06:54,080
install this on but predominantly

00:06:50,240 --> 00:06:57,039
you know the uh options you know

00:06:54,080 --> 00:06:57,680
vary from choosing k native which is

00:06:57,039 --> 00:07:00,240
from

00:06:57,680 --> 00:07:01,520
the google community which is an open

00:07:00,240 --> 00:07:04,479
source platform

00:07:01,520 --> 00:07:05,280
and it basically you know deploys on to

00:07:04,479 --> 00:07:07,599
kubernetes

00:07:05,280 --> 00:07:09,440
and you can actually take all of the

00:07:07,599 --> 00:07:10,000
other you know products that are listed

00:07:09,440 --> 00:07:12,160
here

00:07:10,000 --> 00:07:14,240
you can also deploy them either on

00:07:12,160 --> 00:07:17,280
kubernetes or openshift

00:07:14,240 --> 00:07:20,160
so the conversation predominantly is

00:07:17,280 --> 00:07:21,759
um the pros and cons of how these

00:07:20,160 --> 00:07:25,199
installable platforms

00:07:21,759 --> 00:07:27,599
are easy to operate and run

00:07:25,199 --> 00:07:28,240
your business on and how you could

00:07:27,599 --> 00:07:31,360
possibly

00:07:28,240 --> 00:07:32,880
take those very same options and work

00:07:31,360 --> 00:07:35,120
with the cloud providers

00:07:32,880 --> 00:07:36,160
so they in turn can actually be deployed

00:07:35,120 --> 00:07:38,720
on the cloud

00:07:36,160 --> 00:07:39,759
so you really have the flexibility to

00:07:38,720 --> 00:07:41,759
you know manage

00:07:39,759 --> 00:07:44,080
the whole life cycle of how you go about

00:07:41,759 --> 00:07:47,680
developing it right we'll dive into that

00:07:44,080 --> 00:07:51,599
in a minute so what i wanted to share

00:07:47,680 --> 00:07:54,560
as i said early on is the working group

00:07:51,599 --> 00:07:55,199
that has been uh busy within the cloud

00:07:54,560 --> 00:07:57,759
native

00:07:55,199 --> 00:07:58,560
computing foundation which has been

00:07:57,759 --> 00:08:02,560
focusing

00:07:58,560 --> 00:08:04,240
on getting all of these communities that

00:08:02,560 --> 00:08:06,720
have been hard at work

00:08:04,240 --> 00:08:07,680
developing tools and security

00:08:06,720 --> 00:08:10,160
capabilities

00:08:07,680 --> 00:08:12,400
frameworks hosted platforms and

00:08:10,160 --> 00:08:15,680
installable platforms and they've

00:08:12,400 --> 00:08:17,759
nicely curated this into a taxonomy

00:08:15,680 --> 00:08:19,440
and i wanted to share this graphic

00:08:17,759 --> 00:08:21,759
because this might really be useful

00:08:19,440 --> 00:08:22,960
because what i showed in the earlier

00:08:21,759 --> 00:08:26,000
slide was a small

00:08:22,960 --> 00:08:29,039
sampling of the you know major

00:08:26,000 --> 00:08:31,360
tools but there is a thriving ecosystem

00:08:29,039 --> 00:08:33,519
of uh you know vendors who are really

00:08:31,360 --> 00:08:35,279
creating amazing innovation

00:08:33,519 --> 00:08:36,959
some of these are open source some of

00:08:35,279 --> 00:08:39,039
them are not but

00:08:36,959 --> 00:08:40,479
you can clearly leverage the good work

00:08:39,039 --> 00:08:42,719
of this working group

00:08:40,479 --> 00:08:43,680
to see what the community is up to and

00:08:42,719 --> 00:08:46,160
how many of them

00:08:43,680 --> 00:08:48,640
are collaborating with the cloud native

00:08:46,160 --> 00:08:51,839
computing foundation

00:08:48,640 --> 00:08:55,360
so when you think about functions and

00:08:51,839 --> 00:08:56,399
you know the services uh i made a brief

00:08:55,360 --> 00:08:59,839
reference to

00:08:56,399 --> 00:09:03,279
the various personas right you have a

00:08:59,839 --> 00:09:04,240
developer persona who is really focused

00:09:03,279 --> 00:09:06,880
on

00:09:04,240 --> 00:09:09,600
developing the functions right they are

00:09:06,880 --> 00:09:11,760
focused on identifying the events

00:09:09,600 --> 00:09:13,120
identifying the functions they are

00:09:11,760 --> 00:09:15,760
developing small

00:09:13,120 --> 00:09:17,680
units of code when you really talk to

00:09:15,760 --> 00:09:20,160
the provider side

00:09:17,680 --> 00:09:21,200
these are you know individuals you can

00:09:20,160 --> 00:09:24,320
think of them as

00:09:21,200 --> 00:09:26,240
operators they are building apis and

00:09:24,320 --> 00:09:28,399
subsets of functionality

00:09:26,240 --> 00:09:29,680
and they make sure that those

00:09:28,399 --> 00:09:32,320
functionalities

00:09:29,680 --> 00:09:34,160
automatically scale they go up and down

00:09:32,320 --> 00:09:36,480
they have a very efficient cost

00:09:34,160 --> 00:09:37,200
model and they don't really charge you

00:09:36,480 --> 00:09:39,760
when it is

00:09:37,200 --> 00:09:40,399
and those resources are idle so when you

00:09:39,760 --> 00:09:43,440
think about

00:09:40,399 --> 00:09:44,959
events and functions it is about these

00:09:43,440 --> 00:09:47,920
two personas

00:09:44,959 --> 00:09:48,240
focusing on the business logic leading

00:09:47,920 --> 00:09:51,279
to

00:09:48,240 --> 00:09:51,680
economic transactions and they want to

00:09:51,279 --> 00:09:53,839
have

00:09:51,680 --> 00:09:55,200
the optimal combination of speed with

00:09:53,839 --> 00:09:57,760
stability right

00:09:55,200 --> 00:09:58,399
the developer rapidly iterates on the

00:09:57,760 --> 00:10:00,959
function

00:09:58,399 --> 00:10:02,880
integrates with their ci process and

00:10:00,959 --> 00:10:04,480
they want to be able to test locally

00:10:02,880 --> 00:10:06,160
that is a very key point then we

00:10:04,480 --> 00:10:06,640
identify patterns we will touch upon

00:10:06,160 --> 00:10:08,800
that

00:10:06,640 --> 00:10:11,040
and they want to be able to upload their

00:10:08,800 --> 00:10:12,800
functions to the servers platform

00:10:11,040 --> 00:10:14,399
and the provider likewise wants to

00:10:12,800 --> 00:10:16,399
abstract the runtime

00:10:14,399 --> 00:10:17,839
they want to optimize on the middleware

00:10:16,399 --> 00:10:18,720
and they want to do the metering and

00:10:17,839 --> 00:10:22,000
monitoring

00:10:18,720 --> 00:10:25,360
so we get the best of both worlds right

00:10:22,000 --> 00:10:27,600
so when it comes to evaluating

00:10:25,360 --> 00:10:30,480
platforms these are all the features

00:10:27,600 --> 00:10:32,959
that one really needs to keep in mind

00:10:30,480 --> 00:10:34,480
in terms of their selection choices

00:10:32,959 --> 00:10:37,120
first and foremost

00:10:34,480 --> 00:10:38,320
the business model right are your

00:10:37,120 --> 00:10:40,800
applications

00:10:38,320 --> 00:10:42,640
really open to this loose federation

00:10:40,800 --> 00:10:45,680
that they alluded to before

00:10:42,640 --> 00:10:47,760
or are you really going to be stifled

00:10:45,680 --> 00:10:49,519
in terms of not being able to federate

00:10:47,760 --> 00:10:50,240
and therefore you really need to have

00:10:49,519 --> 00:10:52,959
them

00:10:50,240 --> 00:10:53,920
coexisting within your same enterprise

00:10:52,959 --> 00:10:56,560
the second part

00:10:53,920 --> 00:10:58,800
is the technical suitability what

00:10:56,560 --> 00:11:00,480
programming languages do you develop on

00:10:58,800 --> 00:11:02,800
what are all the run times that are

00:11:00,480 --> 00:11:04,720
important what are all the libraries

00:11:02,800 --> 00:11:05,600
that are going to be dependent on how do

00:11:04,720 --> 00:11:08,079
you want to do

00:11:05,600 --> 00:11:09,040
versioning what are all the frameworks

00:11:08,079 --> 00:11:11,040
that your team

00:11:09,040 --> 00:11:12,959
is comfortable with what is your

00:11:11,040 --> 00:11:14,399
development style and deployment

00:11:12,959 --> 00:11:16,399
workflow look like

00:11:14,399 --> 00:11:17,680
how portable do you want your

00:11:16,399 --> 00:11:20,560
implementation to be

00:11:17,680 --> 00:11:21,200
i'm just really giving a sampling of the

00:11:20,560 --> 00:11:23,920
you know

00:11:21,200 --> 00:11:24,800
suitability attributes that you want to

00:11:23,920 --> 00:11:26,800
evaluate

00:11:24,800 --> 00:11:28,000
because when you choose a platform or a

00:11:26,800 --> 00:11:30,160
cloud provider

00:11:28,000 --> 00:11:32,560
they really have a significant batting

00:11:30,160 --> 00:11:34,800
and then on the operational control

00:11:32,560 --> 00:11:35,680
regardless of whether you are deploying

00:11:34,800 --> 00:11:38,399
it on-prem

00:11:35,680 --> 00:11:40,160
or on the cloud these are all the

00:11:38,399 --> 00:11:40,880
attributes that you need to be thinking

00:11:40,160 --> 00:11:43,120
about

00:11:40,880 --> 00:11:45,200
what does your environment really look

00:11:43,120 --> 00:11:46,240
like do you really have the means to

00:11:45,200 --> 00:11:49,360
make sure

00:11:46,240 --> 00:11:52,800
that in a multi-tenancy model you can

00:11:49,360 --> 00:11:55,920
have the resources dedicated for your

00:11:52,800 --> 00:11:58,079
you know consumption model so that you

00:11:55,920 --> 00:12:00,320
are not really getting penalized for

00:11:58,079 --> 00:12:01,600
your corten and you know consuming a lot

00:12:00,320 --> 00:12:04,079
of resources

00:12:01,600 --> 00:12:06,720
how do you really make sure that you

00:12:04,079 --> 00:12:08,959
don't suffer any kind of interruption

00:12:06,720 --> 00:12:10,160
when there are updates to the data

00:12:08,959 --> 00:12:11,760
center or

00:12:10,160 --> 00:12:13,360
you know you're really dealing with some

00:12:11,760 --> 00:12:16,079
resiliency issues

00:12:13,360 --> 00:12:17,680
or in having some scalability challenges

00:12:16,079 --> 00:12:20,079
what kind of a control

00:12:17,680 --> 00:12:21,200
do you have so that your business

00:12:20,079 --> 00:12:23,920
application is not

00:12:21,200 --> 00:12:25,839
adversely affected by the you know

00:12:23,920 --> 00:12:26,320
happenings within the cloud provider

00:12:25,839 --> 00:12:28,720
space

00:12:26,320 --> 00:12:29,680
now regardless of whether you deploy

00:12:28,720 --> 00:12:31,920
this on-prem

00:12:29,680 --> 00:12:33,360
or on the cloud these are all things

00:12:31,920 --> 00:12:35,040
that you really need to

00:12:33,360 --> 00:12:36,480
keep in mind because you want to make

00:12:35,040 --> 00:12:37,279
sure that the end users are not

00:12:36,480 --> 00:12:41,040
adversely

00:12:37,279 --> 00:12:43,600
impacted by these invariants okay

00:12:41,040 --> 00:12:45,279
so let's take a talk about the life

00:12:43,600 --> 00:12:47,440
cycle of how functions

00:12:45,279 --> 00:12:48,880
you know come into being again i'm

00:12:47,440 --> 00:12:51,040
generously

00:12:48,880 --> 00:12:52,800
attributing all of this credit to the

00:12:51,040 --> 00:12:53,839
good work of the cloud native compute

00:12:52,800 --> 00:12:56,160
foundation

00:12:53,839 --> 00:12:58,399
with where they have documented you know

00:12:56,160 --> 00:13:00,399
the whole life cycle of how

00:12:58,399 --> 00:13:02,000
a function comes into being you start

00:13:00,399 --> 00:13:04,639
with a specification

00:13:02,000 --> 00:13:06,079
and you start developing the code no

00:13:04,639 --> 00:13:08,399
differently than any other

00:13:06,079 --> 00:13:10,160
enterprise application but you

00:13:08,399 --> 00:13:10,880
essentially make sure that you do the

00:13:10,160 --> 00:13:13,360
build

00:13:10,880 --> 00:13:13,920
you do the necessary test and then you

00:13:13,360 --> 00:13:16,639
create

00:13:13,920 --> 00:13:17,760
the artifact that you want to deploy in

00:13:16,639 --> 00:13:19,920
this case

00:13:17,760 --> 00:13:20,800
there are small units of core there are

00:13:19,920 --> 00:13:23,040
called functions

00:13:20,800 --> 00:13:25,040
they basically get deployed and once

00:13:23,040 --> 00:13:26,959
they're deployed onto your platform

00:13:25,040 --> 00:13:28,160
you want to be able to monitor and be

00:13:26,959 --> 00:13:30,480
able to scale it

00:13:28,160 --> 00:13:31,680
but the key thing here is rather than

00:13:30,480 --> 00:13:34,800
really do it

00:13:31,680 --> 00:13:37,120
you know based on the idiosyncrasies of

00:13:34,800 --> 00:13:39,199
the cloud provider

00:13:37,120 --> 00:13:40,480
what the foundation has done is they

00:13:39,199 --> 00:13:43,120
have created

00:13:40,480 --> 00:13:44,720
very clear steps in terms of defining

00:13:43,120 --> 00:13:46,959
the various life cycle

00:13:44,720 --> 00:13:48,800
create publish you know updating the

00:13:46,959 --> 00:13:51,839
label execute

00:13:48,800 --> 00:13:52,720
the event source association etc etc you

00:13:51,839 --> 00:13:56,079
get a feel

00:13:52,720 --> 00:13:57,680
as to how the whole life cycle follows

00:13:56,079 --> 00:13:58,399
the traditional software development

00:13:57,680 --> 00:14:00,160
model

00:13:58,399 --> 00:14:02,639
so that when you are really developing

00:14:00,160 --> 00:14:04,720
functions it benefits from the same

00:14:02,639 --> 00:14:06,720
structured thinking in terms of the life

00:14:04,720 --> 00:14:08,959
cycle that is really important

00:14:06,720 --> 00:14:10,399
to keep in mind and not really be

00:14:08,959 --> 00:14:12,560
completely locked in

00:14:10,399 --> 00:14:14,000
to how the provider treats the life

00:14:12,560 --> 00:14:17,440
cycle activities

00:14:14,000 --> 00:14:20,079
the next thing here is in reality

00:14:17,440 --> 00:14:21,440
as you develop your functions and they

00:14:20,079 --> 00:14:23,600
keep hydrating

00:14:21,440 --> 00:14:24,800
they will keep evolving so when you

00:14:23,600 --> 00:14:27,040
start with

00:14:24,800 --> 00:14:27,839
uh you know at the very beginning you

00:14:27,040 --> 00:14:30,720
will start

00:14:27,839 --> 00:14:31,519
by creating a function once you publish

00:14:30,720 --> 00:14:34,240
it you will

00:14:31,519 --> 00:14:34,720
rapidly i trade you will want to create

00:14:34,240 --> 00:14:37,120
the next

00:14:34,720 --> 00:14:38,000
version of the function and you want to

00:14:37,120 --> 00:14:41,040
be able to

00:14:38,000 --> 00:14:42,399
do this in a thoughtful way so that you

00:14:41,040 --> 00:14:45,199
can really learn from

00:14:42,399 --> 00:14:46,399
all the you know iterations that you've

00:14:45,199 --> 00:14:49,199
taken in the past

00:14:46,399 --> 00:14:49,839
so you know subsequent versions may

00:14:49,199 --> 00:14:52,000
choose to

00:14:49,839 --> 00:14:53,360
go back to a prior version you want to

00:14:52,000 --> 00:14:56,160
be able to do that

00:14:53,360 --> 00:14:58,160
and keep track of the history of how

00:14:56,160 --> 00:15:00,079
these functions came into being

00:14:58,160 --> 00:15:02,800
so you really have the means to assemble

00:15:00,079 --> 00:15:06,240
them in a the right way

00:15:02,800 --> 00:15:08,079
the other pattern again that has been

00:15:06,240 --> 00:15:11,279
published by the cloud native account

00:15:08,079 --> 00:15:13,839
compute foundation is the various

00:15:11,279 --> 00:15:14,560
patterns of computing right when you

00:15:13,839 --> 00:15:17,839
think about

00:15:14,560 --> 00:15:20,959
the synchronous model where the web

00:15:17,839 --> 00:15:24,639
is generating a call into a gateway

00:15:20,959 --> 00:15:28,399
which in turn replicates that request to

00:15:24,639 --> 00:15:31,040
one or more functions and then the

00:15:28,399 --> 00:15:33,519
you know messaging model is a message

00:15:31,040 --> 00:15:34,560
arrives asynchronously into some sort of

00:15:33,519 --> 00:15:36,880
an exchange

00:15:34,560 --> 00:15:39,040
and it gets queued up and then the queue

00:15:36,880 --> 00:15:40,959
in turn gets drained into one or more

00:15:39,040 --> 00:15:42,880
functions we have seen these

00:15:40,959 --> 00:15:44,320
patterns in the enterprise computing

00:15:42,880 --> 00:15:47,120
space they will

00:15:44,320 --> 00:15:47,680
apply to the serverless model as well

00:15:47,120 --> 00:15:50,399
and then

00:15:47,680 --> 00:15:50,880
the streaming model where whether

00:15:50,399 --> 00:15:53,360
through

00:15:50,880 --> 00:15:55,360
you know kinesis or you know one of

00:15:53,360 --> 00:15:58,000
those similar technologies

00:15:55,360 --> 00:15:59,440
messages basically get routed into one

00:15:58,000 --> 00:16:01,519
or more partitions

00:15:59,440 --> 00:16:02,639
they in turn really get picked up by one

00:16:01,519 --> 00:16:05,199
or more functions

00:16:02,639 --> 00:16:05,680
they drain all of these partitions and

00:16:05,199 --> 00:16:08,240
finish

00:16:05,680 --> 00:16:08,800
the back end part of the computing and

00:16:08,240 --> 00:16:12,480
then the

00:16:08,800 --> 00:16:15,920
in the third part is the notion around

00:16:12,480 --> 00:16:18,000
a master list of you know tasks that

00:16:15,920 --> 00:16:21,519
comes into a priority queue

00:16:18,000 --> 00:16:24,160
the uh the master dispatches the

00:16:21,519 --> 00:16:25,360
task to one or more of these workers who

00:16:24,160 --> 00:16:27,680
in turn

00:16:25,360 --> 00:16:29,199
execute on those functions and then

00:16:27,680 --> 00:16:31,600
return the logic

00:16:29,199 --> 00:16:33,279
back into functions there have been a

00:16:31,600 --> 00:16:34,160
number of patterns that have been

00:16:33,279 --> 00:16:36,720
published

00:16:34,160 --> 00:16:38,639
building upon these basic promises and

00:16:36,720 --> 00:16:39,519
i'll share the references in just about

00:16:38,639 --> 00:16:42,079
a minute

00:16:39,519 --> 00:16:42,880
but one of the things that i wanted to

00:16:42,079 --> 00:16:45,279
say

00:16:42,880 --> 00:16:46,720
which is really important again this is

00:16:45,279 --> 00:16:48,639
work that's been done by the cloud

00:16:46,720 --> 00:16:51,120
native county foundation is

00:16:48,639 --> 00:16:54,560
when you think about defining an event

00:16:51,120 --> 00:16:58,079
or you think about defining a function

00:16:54,560 --> 00:17:00,079
the metadata associated to that event

00:16:58,079 --> 00:17:01,680
and the function is really important

00:17:00,079 --> 00:17:03,360
so when you think about an event you

00:17:01,680 --> 00:17:06,400
want to say what kind of a

00:17:03,360 --> 00:17:07,280
you know uh event class it is what type

00:17:06,400 --> 00:17:09,919
it is

00:17:07,280 --> 00:17:11,839
what is the version of the event what is

00:17:09,919 --> 00:17:13,520
the identifier view and

00:17:11,839 --> 00:17:15,199
what are the sources what is the

00:17:13,520 --> 00:17:17,360
identity etc

00:17:15,199 --> 00:17:19,280
as you can imagine this is really

00:17:17,360 --> 00:17:20,880
important because if you are using any

00:17:19,280 --> 00:17:23,679
kind of a framework

00:17:20,880 --> 00:17:26,000
that takes the event and binds it to the

00:17:23,679 --> 00:17:28,960
corresponding function that is

00:17:26,000 --> 00:17:30,720
going to be executing to that request

00:17:28,960 --> 00:17:32,000
you really need to have the means to

00:17:30,720 --> 00:17:35,280
bind the two together

00:17:32,000 --> 00:17:38,480
right so obviously the event

00:17:35,280 --> 00:17:39,039
will really be tied to the source the

00:17:38,480 --> 00:17:41,600
function

00:17:39,039 --> 00:17:43,520
will really be tied to the you know the

00:17:41,600 --> 00:17:45,679
function as a service model

00:17:43,520 --> 00:17:48,000
and when you are developing a framework

00:17:45,679 --> 00:17:51,120
you want to be able to say

00:17:48,000 --> 00:17:52,720
how did you really associate which event

00:17:51,120 --> 00:17:56,400
to which function

00:17:52,720 --> 00:17:58,960
and having all of this data and metadata

00:17:56,400 --> 00:18:00,480
is going to be important because you are

00:17:58,960 --> 00:18:04,240
now dictating

00:18:00,480 --> 00:18:06,080
the behavior of these functions based on

00:18:04,240 --> 00:18:07,360
things that might really be happening so

00:18:06,080 --> 00:18:09,440
as you can see

00:18:07,360 --> 00:18:11,039
in the various definitions of the

00:18:09,440 --> 00:18:14,160
function

00:18:11,039 --> 00:18:15,280
it in turn tells you you know who is the

00:18:14,160 --> 00:18:17,120
function handler

00:18:15,280 --> 00:18:18,880
right so when the event arrives the

00:18:17,120 --> 00:18:21,039
function handler is the one

00:18:18,880 --> 00:18:22,720
that is you know processing the event

00:18:21,039 --> 00:18:23,600
and routing it to the appropriate

00:18:22,720 --> 00:18:26,720
function

00:18:23,600 --> 00:18:29,200
it in turn is going to have a bearing on

00:18:26,720 --> 00:18:31,120
what run time the language you know you

00:18:29,200 --> 00:18:32,960
know is dependent on

00:18:31,120 --> 00:18:34,960
what code and dependencies does it

00:18:32,960 --> 00:18:37,520
depend on the environment

00:18:34,960 --> 00:18:38,320
the runtime behavior etc as you can

00:18:37,520 --> 00:18:40,720
imagine

00:18:38,320 --> 00:18:42,000
when you want to externalize the

00:18:40,720 --> 00:18:45,440
behavior of all these

00:18:42,000 --> 00:18:47,360
functions having this in a well-defined

00:18:45,440 --> 00:18:49,440
attribute class is going to be very

00:18:47,360 --> 00:18:50,400
helpful because it really allows the

00:18:49,440 --> 00:18:53,039
developer

00:18:50,400 --> 00:18:55,840
and the operator to bind these two

00:18:53,039 --> 00:18:59,120
constructs together

00:18:55,840 --> 00:19:00,400
so now we've talked about the basics of

00:18:59,120 --> 00:19:03,120
how the events

00:19:00,400 --> 00:19:03,679
and the functions come together the

00:19:03,120 --> 00:19:07,120
question

00:19:03,679 --> 00:19:09,679
that begs to be answered is how exactly

00:19:07,120 --> 00:19:10,640
are we orchestrating the functions at

00:19:09,679 --> 00:19:13,520
the back end

00:19:10,640 --> 00:19:14,240
because as you can imagine a simple

00:19:13,520 --> 00:19:17,679
event

00:19:14,240 --> 00:19:19,679
could trigger one if one function or

00:19:17,679 --> 00:19:21,039
it could really you know trigger a

00:19:19,679 --> 00:19:23,919
combination of

00:19:21,039 --> 00:19:24,960
you know multiple functions right an

00:19:23,919 --> 00:19:28,080
event could

00:19:24,960 --> 00:19:29,679
basically be executing multiple

00:19:28,080 --> 00:19:33,039
functions in sequence

00:19:29,679 --> 00:19:36,240
or it could do it in parallel both are

00:19:33,039 --> 00:19:38,720
perfectly valid right so you can also

00:19:36,240 --> 00:19:41,280
see the daisy chaining effect where

00:19:38,720 --> 00:19:42,160
the result of a function could in turn

00:19:41,280 --> 00:19:44,080
trigger

00:19:42,160 --> 00:19:45,440
another function and you really need to

00:19:44,080 --> 00:19:48,160
be able to

00:19:45,440 --> 00:19:48,720
manage the daisy chaining at the back

00:19:48,160 --> 00:19:51,200
end

00:19:48,720 --> 00:19:52,240
so you can really manage all of those

00:19:51,200 --> 00:19:56,400
functions and

00:19:52,240 --> 00:20:00,160
events one after the other and again

00:19:56,400 --> 00:20:02,720
the url that i list here below

00:20:00,160 --> 00:20:04,880
teases out the many patterns that are

00:20:02,720 --> 00:20:08,240
being documented

00:20:04,880 --> 00:20:09,039
that addressed the finer grain details

00:20:08,240 --> 00:20:11,840
about

00:20:09,039 --> 00:20:13,039
how to build sophisticated enterprise

00:20:11,840 --> 00:20:15,760
applications

00:20:13,039 --> 00:20:17,280
that can really benefit from all of that

00:20:15,760 --> 00:20:20,480
thinking there

00:20:17,280 --> 00:20:23,919
uh the key takeaway from this slide is

00:20:20,480 --> 00:20:26,720
if you basically have you know n events

00:20:23,919 --> 00:20:29,679
and you have m functions you clearly

00:20:26,720 --> 00:20:32,480
have the cardinality of like n to m

00:20:29,679 --> 00:20:33,120
and you want the programming model to

00:20:32,480 --> 00:20:36,240
help you

00:20:33,120 --> 00:20:39,760
bind the two together okay

00:20:36,240 --> 00:20:43,200
now the key here is that

00:20:39,760 --> 00:20:46,559
you know if you look at the

00:20:43,200 --> 00:20:49,600
many providers they all provide

00:20:46,559 --> 00:20:50,400
tool kits that will help development

00:20:49,600 --> 00:20:53,520
teams

00:20:50,400 --> 00:20:54,799
go about developing and deploying to

00:20:53,520 --> 00:20:57,919
this framework

00:20:54,799 --> 00:21:01,120
what i'm showing in this chart is the

00:20:57,919 --> 00:21:04,240
various cloud providers who in turn

00:21:01,120 --> 00:21:07,280
have really been partnering with

00:21:04,240 --> 00:21:10,480
this company called serverless

00:21:07,280 --> 00:21:13,440
they have both an open source framework

00:21:10,480 --> 00:21:14,400
as well as a commercial framework that

00:21:13,440 --> 00:21:17,400
allows you

00:21:14,400 --> 00:21:19,840
to abstract away all of the

00:21:17,400 --> 00:21:20,960
idiosyncrasies of the cloud provider so

00:21:19,840 --> 00:21:24,400
when you

00:21:20,960 --> 00:21:27,360
program on serverless you in turn

00:21:24,400 --> 00:21:28,480
are assured that you can deploy to one

00:21:27,360 --> 00:21:30,480
of the many

00:21:28,480 --> 00:21:32,240
you know cloud providers that they have

00:21:30,480 --> 00:21:35,679
already worked a lot with

00:21:32,240 --> 00:21:38,720
so for example if you are

00:21:35,679 --> 00:21:40,960
currently on aws

00:21:38,720 --> 00:21:42,000
you could choose to use the aws

00:21:40,960 --> 00:21:44,080
framework

00:21:42,000 --> 00:21:46,159
which is available it's called the

00:21:44,080 --> 00:21:48,559
serverless application model

00:21:46,159 --> 00:21:49,360
or you could choose the serverless

00:21:48,559 --> 00:21:52,400
framework

00:21:49,360 --> 00:21:54,880
available from this company serverless

00:21:52,400 --> 00:21:55,840
what they've essentially done is they

00:21:54,880 --> 00:21:58,880
have taken

00:21:55,840 --> 00:22:00,400
the sequence of activities that you

00:21:58,880 --> 00:22:03,679
would have to do

00:22:00,400 --> 00:22:05,840
interacting with aws and codified this

00:22:03,679 --> 00:22:06,799
into the framework so what you

00:22:05,840 --> 00:22:10,799
essentially get

00:22:06,799 --> 00:22:13,039
is if you are developing applications

00:22:10,799 --> 00:22:14,880
or products that are going to be

00:22:13,039 --> 00:22:16,880
deployed to multiple cloud

00:22:14,880 --> 00:22:18,159
for example that is the perfectly valid

00:22:16,880 --> 00:22:20,400
business model

00:22:18,159 --> 00:22:21,280
what this really gives you is the ease

00:22:20,400 --> 00:22:22,799
of development

00:22:21,280 --> 00:22:24,640
because once you've trained your

00:22:22,799 --> 00:22:25,679
developers to use the serverless

00:22:24,640 --> 00:22:28,000
framework

00:22:25,679 --> 00:22:29,919
that in turn abstracts away all the

00:22:28,000 --> 00:22:30,559
complexity associated to the cloud

00:22:29,919 --> 00:22:33,440
provider

00:22:30,559 --> 00:22:34,559
now i would love to see more of these

00:22:33,440 --> 00:22:38,400
because

00:22:34,559 --> 00:22:41,280
that is definitely good for productivity

00:22:38,400 --> 00:22:42,159
there are pros and cons of this now when

00:22:41,280 --> 00:22:44,320
you really have

00:22:42,159 --> 00:22:45,600
a foundation like cloud native compute

00:22:44,320 --> 00:22:47,919
foundation

00:22:45,600 --> 00:22:49,760
taking all of the foundational

00:22:47,919 --> 00:22:52,080
architectural attributes

00:22:49,760 --> 00:22:53,679
and addressing them so that you know you

00:22:52,080 --> 00:22:56,000
can really build upon it

00:22:53,679 --> 00:22:58,000
we would love to see frameworks like

00:22:56,000 --> 00:22:59,679
serverless frameworks support

00:22:58,000 --> 00:23:01,360
cloud native account from computing

00:22:59,679 --> 00:23:03,280
foundations work

00:23:01,360 --> 00:23:05,360
so we can benefit from that

00:23:03,280 --> 00:23:08,000
standardization

00:23:05,360 --> 00:23:08,559
so there is a another implementation

00:23:08,000 --> 00:23:12,159
that

00:23:08,559 --> 00:23:15,280
i'm somewhat biased towards which is

00:23:12,159 --> 00:23:18,480
the model called k-native k-native

00:23:15,280 --> 00:23:21,679
is the serverless implementation

00:23:18,480 --> 00:23:24,240
from kubernetes community so

00:23:21,679 --> 00:23:25,280
what you see here is the various

00:23:24,240 --> 00:23:28,400
personas

00:23:25,280 --> 00:23:29,280
interacting with k native and kubernetes

00:23:28,400 --> 00:23:31,360
the reason i

00:23:29,280 --> 00:23:32,960
you know tend to favor this is all of

00:23:31,360 --> 00:23:36,480
this is open source

00:23:32,960 --> 00:23:39,200
and uh kubernetes is

00:23:36,480 --> 00:23:39,919
widely accepted if not becoming the

00:23:39,200 --> 00:23:41,360
standard

00:23:39,919 --> 00:23:43,039
you know for all of the cloud

00:23:41,360 --> 00:23:45,279
orchestration so

00:23:43,039 --> 00:23:47,120
what this basically shows is if you are

00:23:45,279 --> 00:23:49,360
dealing with the developer persona who

00:23:47,120 --> 00:23:51,600
wants to build and deploy

00:23:49,360 --> 00:23:53,440
they can develop all of those

00:23:51,600 --> 00:23:57,360
capabilities using

00:23:53,440 --> 00:24:00,720
standardized apis right and k native

00:23:57,360 --> 00:24:04,159
has the means to build and

00:24:00,720 --> 00:24:06,720
deploy your functions onto

00:24:04,159 --> 00:24:08,240
the kubernetes framework so you can

00:24:06,720 --> 00:24:10,000
either

00:24:08,240 --> 00:24:11,840
you know leverage an existing

00:24:10,000 --> 00:24:12,880
application that might be deployed as a

00:24:11,840 --> 00:24:16,559
container

00:24:12,880 --> 00:24:18,960
or you know you can choose to do this

00:24:16,559 --> 00:24:19,760
like the you know functions that you see

00:24:18,960 --> 00:24:22,400
from

00:24:19,760 --> 00:24:23,760
uh the other non-kubernetes

00:24:22,400 --> 00:24:25,440
implementations

00:24:23,760 --> 00:24:26,880
what this really gives you is the best

00:24:25,440 --> 00:24:29,360
of both worlds

00:24:26,880 --> 00:24:29,919
you have the operators who really take

00:24:29,360 --> 00:24:32,159
care of

00:24:29,919 --> 00:24:33,120
all of the deployment and the management

00:24:32,159 --> 00:24:36,880
so there are

00:24:33,120 --> 00:24:39,679
two constructs for inventing and serving

00:24:36,880 --> 00:24:40,400
the serving basically takes care of all

00:24:39,679 --> 00:24:43,279
the

00:24:40,400 --> 00:24:45,200
aspects of exposing the functions to

00:24:43,279 --> 00:24:49,360
your end users at the top

00:24:45,200 --> 00:24:52,000
and the eventing component takes care of

00:24:49,360 --> 00:24:52,400
all of the plumbing that you need to do

00:24:52,000 --> 00:24:54,559
with

00:24:52,400 --> 00:24:57,279
all of the providers all the sources of

00:24:54,559 --> 00:24:58,320
events so it's a pretty extensible

00:24:57,279 --> 00:25:01,840
framework

00:24:58,320 --> 00:25:04,960
that brings the developer persona the

00:25:01,840 --> 00:25:07,039
operator persona the end user persona as

00:25:04,960 --> 00:25:08,559
well as the contributions from the

00:25:07,039 --> 00:25:10,559
community at large

00:25:08,559 --> 00:25:13,520
that is continuously developing and

00:25:10,559 --> 00:25:16,000
improvising on top of this framework

00:25:13,520 --> 00:25:17,279
by building everything on top of an open

00:25:16,000 --> 00:25:21,200
source platform

00:25:17,279 --> 00:25:22,159
now the advantage of such a framework

00:25:21,200 --> 00:25:24,080
here is

00:25:22,159 --> 00:25:26,320
it really gives you tremendous

00:25:24,080 --> 00:25:27,520
flexibility to have this deployed

00:25:26,320 --> 00:25:30,080
on-prem

00:25:27,520 --> 00:25:31,679
or on the cloud or for that matter any

00:25:30,080 --> 00:25:34,000
cloud vendor because

00:25:31,679 --> 00:25:35,120
every cloud provider is supporting

00:25:34,000 --> 00:25:39,279
communities

00:25:35,120 --> 00:25:42,559
so by having your applications runtime

00:25:39,279 --> 00:25:45,360
basically be mapping to kubernetes you

00:25:42,559 --> 00:25:47,279
benefit from you know the support of

00:25:45,360 --> 00:25:48,320
every cloud provider who is committed to

00:25:47,279 --> 00:25:51,039
kubernetes

00:25:48,320 --> 00:25:52,559
so it gives you extensive portability

00:25:51,039 --> 00:25:56,559
that you all want

00:25:52,559 --> 00:25:59,600
so i would love to say that

00:25:56,559 --> 00:26:00,000
this is a thriving space that you can

00:25:59,600 --> 00:26:02,960
see

00:26:00,000 --> 00:26:03,200
a lot more innovation just as i like the

00:26:02,960 --> 00:26:06,240
k

00:26:03,200 --> 00:26:09,039
native implementation you can also see

00:26:06,240 --> 00:26:10,799
uh implementations from you know

00:26:09,039 --> 00:26:12,480
frameworks like spring

00:26:10,799 --> 00:26:14,960
which is developed spring cloud

00:26:12,480 --> 00:26:16,000
functions which can actually be built

00:26:14,960 --> 00:26:19,520
and deployed

00:26:16,000 --> 00:26:20,080
on to communities as well so whether you

00:26:19,520 --> 00:26:23,840
are

00:26:20,080 --> 00:26:24,400
you know a java shop or a node.js shop

00:26:23,840 --> 00:26:27,440
or

00:26:24,400 --> 00:26:30,799
you know doing things with python

00:26:27,440 --> 00:26:34,320
there are extensive support available

00:26:30,799 --> 00:26:36,080
uh to develop and deploy your events and

00:26:34,320 --> 00:26:37,440
you know function as a service onto this

00:26:36,080 --> 00:26:40,159
platform

00:26:37,440 --> 00:26:40,480
by working closely with a standard group

00:26:40,159 --> 00:26:43,200
like

00:26:40,480 --> 00:26:45,039
cloud native compute foundation i would

00:26:43,200 --> 00:26:47,840
really expect to see

00:26:45,039 --> 00:26:48,960
the community standardized on these

00:26:47,840 --> 00:26:52,640
technologies

00:26:48,960 --> 00:26:55,840
in the coming months so with that

00:26:52,640 --> 00:27:07,679
i'd like to thank you for listening

00:26:55,840 --> 00:27:07,679

YouTube URL: https://www.youtube.com/watch?v=JxNc5tyw9uw


