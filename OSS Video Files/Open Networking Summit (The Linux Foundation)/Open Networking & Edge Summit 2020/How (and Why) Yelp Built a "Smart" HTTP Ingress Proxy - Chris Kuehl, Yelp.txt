Title: How (and Why) Yelp Built a "Smart" HTTP Ingress Proxy - Chris Kuehl, Yelp
Publication date: 2020-10-28
Playlist: Open Networking & Edge Summit 2020
Description: 
	How (and Why) Yelp Built a "Smart" HTTP Ingress Proxy - Chris Kuehl, Yelp
Captions: 
	00:00:01,680 --> 00:00:03,919
hi everyone thanks so much for coming to

00:00:03,280 --> 00:00:05,120
this talk

00:00:03,919 --> 00:00:07,359
i'm going to be talking a little about

00:00:05,120 --> 00:00:08,960
how and why you'll build a smart http in

00:00:07,359 --> 00:00:10,320
gross proxy

00:00:08,960 --> 00:00:12,160
before we start the talk i just wanted

00:00:10,320 --> 00:00:13,759
to introduce myself real quickly

00:00:12,160 --> 00:00:15,679
my name is chris kiel i am a software

00:00:13,759 --> 00:00:17,039
engineer at yelp my main focus is on

00:00:15,679 --> 00:00:19,039
using infrastructure to try to make the

00:00:17,039 --> 00:00:20,240
lives of our full stack engineers easier

00:00:19,039 --> 00:00:23,439
and today i'm going to talk about one of

00:00:20,240 --> 00:00:25,039
our most recent projects to do just that

00:00:23,439 --> 00:00:26,320
before we get into it just a quick

00:00:25,039 --> 00:00:28,000
introduction to what yelp is in case

00:00:26,320 --> 00:00:29,439
you're not familiar with it

00:00:28,000 --> 00:00:31,359
yelp is all about helping connect our

00:00:29,439 --> 00:00:32,719
users with great local businesses

00:00:31,359 --> 00:00:35,200
whether that's restaurants

00:00:32,719 --> 00:00:36,559
delivery home services or more this is

00:00:35,200 --> 00:00:37,680
what the yelp home page looks like right

00:00:36,559 --> 00:00:39,200
now

00:00:37,680 --> 00:00:40,559
we're probably most widely known for our

00:00:39,200 --> 00:00:42,719
business listings where you can rate and

00:00:40,559 --> 00:00:43,840
review restaurants and other businesses

00:00:42,719 --> 00:00:45,600
but i'm not really here to talk about

00:00:43,840 --> 00:00:47,039
yelp the product but instead how we use

00:00:45,600 --> 00:00:49,440
our infrastructure to support the people

00:00:47,039 --> 00:00:51,199
building the product

00:00:49,440 --> 00:00:53,440
the title of this talk is how and why

00:00:51,199 --> 00:00:54,480
y'all built a smart http proxy

00:00:53,440 --> 00:00:56,879
and that's ultimately what i'm going to

00:00:54,480 --> 00:00:58,239
focus on but before we jump into that uh

00:00:56,879 --> 00:00:59,600
just a quick overview of what you can

00:00:58,239 --> 00:01:00,960
expect from this talk

00:00:59,600 --> 00:01:02,640
to start with i'm going to briefly

00:01:00,960 --> 00:01:04,239
discuss what yelp's back-end looks like

00:01:02,640 --> 00:01:06,640
and how we've adopted a service oriented

00:01:04,239 --> 00:01:08,159
architecture over the past few years

00:01:06,640 --> 00:01:09,439
as part of that discussion i'll discuss

00:01:08,159 --> 00:01:10,880
some of the challenges we've had with

00:01:09,439 --> 00:01:13,119
scaling to handle the large number of

00:01:10,880 --> 00:01:14,640
services and finally we'll go over how

00:01:13,119 --> 00:01:16,960
those challenges led to implementing a

00:01:14,640 --> 00:01:18,560
new http proxy for all of our incoming

00:01:16,960 --> 00:01:20,000
web requests that we call the routing

00:01:18,560 --> 00:01:21,360
service

00:01:20,000 --> 00:01:23,119
we'll talk a lot about how we came up

00:01:21,360 --> 00:01:26,240
with the architecture for this proxy and

00:01:23,119 --> 00:01:27,439
a little bit about its implementation

00:01:26,240 --> 00:01:28,880
to start with let's go through the

00:01:27,439 --> 00:01:30,640
exercise of what happens when you type

00:01:28,880 --> 00:01:31,520
yelp.com into your browser and you hit

00:01:30,640 --> 00:01:32,799
enter

00:01:31,520 --> 00:01:34,159
so we're going to start on the left here

00:01:32,799 --> 00:01:35,759
with one of our users at their laptop

00:01:34,159 --> 00:01:36,960
they're just typing up.com and hitting

00:01:35,759 --> 00:01:38,320
enter

00:01:36,960 --> 00:01:39,920
the first piece of infrastructure that

00:01:38,320 --> 00:01:41,520
will see this request is our third-party

00:01:39,920 --> 00:01:43,759
cdns who have points of presence around

00:01:41,520 --> 00:01:45,280
the world

00:01:43,759 --> 00:01:46,880
after that the cdns will route the

00:01:45,280 --> 00:01:47,840
traffic to yelp load balancers

00:01:46,880 --> 00:01:48,799
this is the first piece of

00:01:47,840 --> 00:01:50,880
infrastructure that's actually

00:01:48,799 --> 00:01:52,399
controlled by yelp

00:01:50,880 --> 00:01:53,680
and then finally those load balancers

00:01:52,399 --> 00:01:54,000
will route their request to our python

00:01:53,680 --> 00:01:55,759
web

00:01:54,000 --> 00:01:57,119
application which generates the response

00:01:55,759 --> 00:01:59,920
that we send back to the user

00:01:57,119 --> 00:02:01,119
it's simple right and this is this is

00:01:59,920 --> 00:02:02,000
actually what it looked like about five

00:02:01,119 --> 00:02:03,680
years ago

00:02:02,000 --> 00:02:05,280
and it turned out that as we grew this

00:02:03,680 --> 00:02:06,960
this one monolithic python web

00:02:05,280 --> 00:02:07,759
application was starting to get much too

00:02:06,960 --> 00:02:09,039
large

00:02:07,759 --> 00:02:11,440
with the large number of engineers

00:02:09,039 --> 00:02:12,959
working in it the code size it became

00:02:11,440 --> 00:02:14,319
very difficult to actually work on and

00:02:12,959 --> 00:02:16,000
deploy this service

00:02:14,319 --> 00:02:17,440
it's too difficult to upgrade things we

00:02:16,000 --> 00:02:18,319
have flaky tests that are difficult to

00:02:17,440 --> 00:02:21,360
work around

00:02:18,319 --> 00:02:22,800
lots of different scaling challenges

00:02:21,360 --> 00:02:24,800
instead what we do now is we actually

00:02:22,800 --> 00:02:26,000
have many different web applications

00:02:24,800 --> 00:02:27,599
all of which are responsible for

00:02:26,000 --> 00:02:29,040
different parts of the site so for

00:02:27,599 --> 00:02:30,560
example we might have the home page

00:02:29,040 --> 00:02:31,519
service which is responsible for serving

00:02:30,560 --> 00:02:33,040
the home page

00:02:31,519 --> 00:02:34,720
we might have the biz page service that

00:02:33,040 --> 00:02:35,200
serves biz page the search page for

00:02:34,720 --> 00:02:37,599
search

00:02:35,200 --> 00:02:39,200
etc the way this works is that our load

00:02:37,599 --> 00:02:40,160
balancer will look at the request that

00:02:39,200 --> 00:02:41,680
it sees

00:02:40,160 --> 00:02:43,280
and it will decide which service is the

00:02:41,680 --> 00:02:44,720
appropriate one to serve this page and

00:02:43,280 --> 00:02:47,040
it'll send it to the correct one based

00:02:44,720 --> 00:02:48,400
on that

00:02:47,040 --> 00:02:49,599
because each of these services is

00:02:48,400 --> 00:02:50,400
serving traffic directly from the

00:02:49,599 --> 00:02:52,080
internet now

00:02:50,400 --> 00:02:54,400
they have a lot of new responsibilities

00:02:52,080 --> 00:02:56,000
so for example uh bot detection and rate

00:02:54,400 --> 00:02:57,680
limiting user authentication where we

00:02:56,000 --> 00:02:58,159
figure out which user a request belongs

00:02:57,680 --> 00:02:59,680
to

00:02:58,159 --> 00:03:01,280
reporting metrics both our business

00:02:59,680 --> 00:03:02,720
metrics and also metrics like the

00:03:01,280 --> 00:03:05,280
timings for requests and whether any

00:03:02,720 --> 00:03:06,959
errors are occurring and lots more

00:03:05,280 --> 00:03:08,640
this leads to some problems though the

00:03:06,959 --> 00:03:10,720
first of which is that our micro

00:03:08,640 --> 00:03:12,080
services aren't very micro anymore

00:03:10,720 --> 00:03:13,360
and it's starting to become a big

00:03:12,080 --> 00:03:14,159
maintenance burden on our future

00:03:13,360 --> 00:03:15,840
developers

00:03:14,159 --> 00:03:17,840
ideally we want our future developers to

00:03:15,840 --> 00:03:18,800
be focused on focusing on building this

00:03:17,840 --> 00:03:20,159
product

00:03:18,800 --> 00:03:21,840
and not spending their time on this kind

00:03:20,159 --> 00:03:23,360
of this boilerplate code that we need

00:03:21,840 --> 00:03:25,360
everywhere

00:03:23,360 --> 00:03:26,879
additionally keeping those behaviors up

00:03:25,360 --> 00:03:29,040
to date across services is starting to

00:03:26,879 --> 00:03:31,760
become really hard due to code drift

00:03:29,040 --> 00:03:32,480
so if we have 20 different services it's

00:03:31,760 --> 00:03:34,080
very difficult

00:03:32,480 --> 00:03:36,080
to upgrade one of these features because

00:03:34,080 --> 00:03:37,440
you now need to go update 20 services

00:03:36,080 --> 00:03:39,120
and roll out these changes and keep

00:03:37,440 --> 00:03:40,400
everything in sync

00:03:39,120 --> 00:03:41,840
so we started looking at what we could

00:03:40,400 --> 00:03:43,280
do about all these shared behaviors and

00:03:41,840 --> 00:03:45,360
whether there's a way we could simplify

00:03:43,280 --> 00:03:46,959
it

00:03:45,360 --> 00:03:47,840
we basically had two main strategies for

00:03:46,959 --> 00:03:48,959
what we could do with the shared

00:03:47,840 --> 00:03:50,239
features

00:03:48,959 --> 00:03:52,159
the first one was see whether we can

00:03:50,239 --> 00:03:53,439
move these to an earlier layer so from

00:03:52,159 --> 00:03:55,840
the diagram before that would be the

00:03:53,439 --> 00:03:57,120
cdns or the load balancers

00:03:55,840 --> 00:03:58,720
and that works for some things for

00:03:57,120 --> 00:04:00,080
example our request blocking where we

00:03:58,720 --> 00:04:01,519
just have a list of ip addresses we

00:04:00,080 --> 00:04:03,120
don't want to serve traffic to

00:04:01,519 --> 00:04:04,799
that's something that's easy to move up

00:04:03,120 --> 00:04:06,560
a layer

00:04:04,799 --> 00:04:07,680
but some things don't don't really fit

00:04:06,560 --> 00:04:09,120
in those layers and so we have to

00:04:07,680 --> 00:04:10,720
package those up and use those in every

00:04:09,120 --> 00:04:12,959
service instead

00:04:10,720 --> 00:04:14,319
that is an improvement it makes it

00:04:12,959 --> 00:04:16,639
easier to share this code you don't have

00:04:14,319 --> 00:04:17,840
to copy paste it around

00:04:16,639 --> 00:04:19,359
but it does still mean you have this

00:04:17,840 --> 00:04:22,239
code drift problem and it's difficult to

00:04:19,359 --> 00:04:22,239
keep things in sync

00:04:22,320 --> 00:04:25,440
and this still isn't great because these

00:04:24,160 --> 00:04:26,560
strategies don't really work for all of

00:04:25,440 --> 00:04:27,759
our features

00:04:26,560 --> 00:04:29,360
a lot of the times you really want to

00:04:27,759 --> 00:04:30,400
have exactly one implementation of

00:04:29,360 --> 00:04:31,840
something

00:04:30,400 --> 00:04:33,919
so a common example is something like

00:04:31,840 --> 00:04:35,680
our business metrics we really want to

00:04:33,919 --> 00:04:38,080
be able to trust that those metrics

00:04:35,680 --> 00:04:39,280
are accurate and so if we have 20

00:04:38,080 --> 00:04:40,400
different services that are writing

00:04:39,280 --> 00:04:41,520
business metrics

00:04:40,400 --> 00:04:43,280
it's really hard for us to know that

00:04:41,520 --> 00:04:45,120
there's not one out of those 20 services

00:04:43,280 --> 00:04:47,600
that's doing some kind of mistake

00:04:45,120 --> 00:04:48,880
and messing up our metrics for everyone

00:04:47,600 --> 00:04:49,680
sometimes you have things you want to do

00:04:48,880 --> 00:04:51,199
at the edge

00:04:49,680 --> 00:04:53,040
for example both detection and rate

00:04:51,199 --> 00:04:54,080
limiting ideally we want to block

00:04:53,040 --> 00:04:55,440
requests

00:04:54,080 --> 00:04:56,639
as soon as they come in as early on as

00:04:55,440 --> 00:04:57,840
possible if we know we're going to end

00:04:56,639 --> 00:04:58,880
up blocking them anyway

00:04:57,840 --> 00:05:01,440
we don't want to spend a lot of time

00:04:58,880 --> 00:05:03,199
processing these requests

00:05:01,440 --> 00:05:04,560
additionally sometimes it's difficult to

00:05:03,199 --> 00:05:05,759
error prone to implement things in every

00:05:04,560 --> 00:05:07,199
service so if you think of something

00:05:05,759 --> 00:05:08,639
like a captcha which we use when we're

00:05:07,199 --> 00:05:10,160
rate limiting someone we think might be

00:05:08,639 --> 00:05:11,440
a bot

00:05:10,160 --> 00:05:12,880
we don't really want to do this in every

00:05:11,440 --> 00:05:14,240
service that requires rendering this

00:05:12,880 --> 00:05:16,080
template page

00:05:14,240 --> 00:05:18,000
looking at the response validating it

00:05:16,080 --> 00:05:19,039
and finally kind of recording the the

00:05:18,000 --> 00:05:20,400
successor failure so

00:05:19,039 --> 00:05:22,400
that's pretty heavy weight to ask every

00:05:20,400 --> 00:05:23,600
service to actually do

00:05:22,400 --> 00:05:25,199
and on top of that we still have these

00:05:23,600 --> 00:05:26,800
very heavyweight services that we we

00:05:25,199 --> 00:05:28,320
don't like

00:05:26,800 --> 00:05:29,840
so we want one place to implement these

00:05:28,320 --> 00:05:31,919
things but it has to be pretty early on

00:05:29,840 --> 00:05:33,120
and it has to be fairly smart

00:05:31,919 --> 00:05:34,720
that's where we started thinking about

00:05:33,120 --> 00:05:36,160
whether we could introduce a new service

00:05:34,720 --> 00:05:38,000
which we called the routing service in

00:05:36,160 --> 00:05:39,120
the middle of the request flow

00:05:38,000 --> 00:05:41,039
uh so we'd have to have the routing

00:05:39,120 --> 00:05:42,320
service in the middle uh doing some kind

00:05:41,039 --> 00:05:42,800
of magic for all those features we

00:05:42,320 --> 00:05:44,800
wanted

00:05:42,800 --> 00:05:45,919
before proxying a request onto the

00:05:44,800 --> 00:05:47,520
service

00:05:45,919 --> 00:05:50,320
essentially you can think of it as as

00:05:47,520 --> 00:05:53,840
one more layer of http load balancers

00:05:50,320 --> 00:05:55,199
uh but but a smarter one

00:05:53,840 --> 00:05:56,720
so we brainstormed a little about the

00:05:55,199 --> 00:05:58,479
features that could fit and there were a

00:05:56,720 --> 00:06:00,080
lot of ideas so for example uh boss

00:05:58,479 --> 00:06:00,639
detection rate limiting metrics and

00:06:00,080 --> 00:06:02,880
logging

00:06:00,639 --> 00:06:03,919
advanced request routing uh we have all

00:06:02,880 --> 00:06:05,919
these great ideas for

00:06:03,919 --> 00:06:07,440
what could potentially go in there but

00:06:05,919 --> 00:06:09,039
we don't really know whether this is a

00:06:07,440 --> 00:06:10,800
good idea yet so it's just something

00:06:09,039 --> 00:06:12,160
worth exploring

00:06:10,800 --> 00:06:13,520
uh and i wanted to stop the talk right

00:06:12,160 --> 00:06:15,039
there because i imagine a lot of people

00:06:13,520 --> 00:06:16,960
are kind of thinking you know why why

00:06:15,039 --> 00:06:18,479
would a load balancer be doing this

00:06:16,960 --> 00:06:20,240
isn't that a big violation of

00:06:18,479 --> 00:06:21,919
responsibilities these are these are

00:06:20,240 --> 00:06:23,039
application concerns these are business

00:06:21,919 --> 00:06:24,160
concerns

00:06:23,039 --> 00:06:26,639
these don't really have anything to do

00:06:24,160 --> 00:06:28,000
with balancing traffic at all

00:06:26,639 --> 00:06:29,360
and i think that's a really important

00:06:28,000 --> 00:06:30,880
question and it's one i struggled with a

00:06:29,360 --> 00:06:32,479
lot myself to kind of like

00:06:30,880 --> 00:06:34,160
come to terms with but also in talking

00:06:32,479 --> 00:06:35,360
with others and seeing their concerns on

00:06:34,160 --> 00:06:37,120
it

00:06:35,360 --> 00:06:38,479
uh and ultimately i had to kind of step

00:06:37,120 --> 00:06:40,000
back and think about what the

00:06:38,479 --> 00:06:41,759
the purpose of infrastructure actually

00:06:40,000 --> 00:06:43,680
is in the the context of a large company

00:06:41,759 --> 00:06:45,360
trying to serve a product

00:06:43,680 --> 00:06:47,199
and the the truth is that no one really

00:06:45,360 --> 00:06:48,479
cares how cool or how great yelp's

00:06:47,199 --> 00:06:50,160
infrastructure is if the company's

00:06:48,479 --> 00:06:50,960
losing money or if our users hate our

00:06:50,160 --> 00:06:52,639
product

00:06:50,960 --> 00:06:54,240
uh the info for us is really just a

00:06:52,639 --> 00:06:55,680
means to an end

00:06:54,240 --> 00:06:57,280
and i don't say that to to downplay the

00:06:55,680 --> 00:06:58,880
importance of infrastructure it's it's

00:06:57,280 --> 00:07:00,800
something i'm very passionate about and

00:06:58,880 --> 00:07:02,160
i know is is super critical

00:07:00,800 --> 00:07:03,360
uh but i say that to emphasize that

00:07:02,160 --> 00:07:04,560
sometimes we can blur the layers a

00:07:03,360 --> 00:07:05,360
little in the interest of the big

00:07:04,560 --> 00:07:06,720
picture

00:07:05,360 --> 00:07:08,800
so we're not trying to build the next

00:07:06,720 --> 00:07:10,639
big popular generic uh

00:07:08,800 --> 00:07:12,400
http proxy and then convince you all to

00:07:10,639 --> 00:07:14,560
use it we're essentially trying to solve

00:07:12,400 --> 00:07:16,639
our own problems here

00:07:14,560 --> 00:07:18,639
this also it isn't an excuse for rapport

00:07:16,639 --> 00:07:20,240
architecture or for sloppy design

00:07:18,639 --> 00:07:21,680
uh it's more of a guiding principle for

00:07:20,240 --> 00:07:23,199
what kind of things we can build

00:07:21,680 --> 00:07:25,280
and in particular something we believe

00:07:23,199 --> 00:07:26,800
pretty strongly in uh is that we can

00:07:25,280 --> 00:07:27,919
kind of move some of the smarts and some

00:07:26,800 --> 00:07:28,800
of the complexity into the

00:07:27,919 --> 00:07:30,400
infrastructure

00:07:28,800 --> 00:07:31,680
so that we can make the jobs easier for

00:07:30,400 --> 00:07:32,560
the people who are actually building the

00:07:31,680 --> 00:07:34,240
product

00:07:32,560 --> 00:07:35,520
by handling some of that complexity for

00:07:34,240 --> 00:07:37,599
them so they don't have to worry about

00:07:35,520 --> 00:07:37,599
it

00:07:37,840 --> 00:07:41,440
so let's talk about architecture at this

00:07:39,919 --> 00:07:42,560
point we're thinking the routing service

00:07:41,440 --> 00:07:43,440
might be worth doing but we're not

00:07:42,560 --> 00:07:45,680
really convinced

00:07:43,440 --> 00:07:47,440
we're still kind of debating it and we

00:07:45,680 --> 00:07:48,879
still think of it as this this magic box

00:07:47,440 --> 00:07:51,120
in the middle of our request flow with

00:07:48,879 --> 00:07:52,400
no idea how it would actually work

00:07:51,120 --> 00:07:54,080
so this is where we start thinking about

00:07:52,400 --> 00:07:55,360
how we would architect it and we did

00:07:54,080 --> 00:07:57,120
this by looking at a few of the main

00:07:55,360 --> 00:07:58,879
problems we anticipated needing to solve

00:07:57,120 --> 00:08:01,440
and coming up with some designs to to

00:07:58,879 --> 00:08:01,440
address those

00:08:01,599 --> 00:08:04,639
the first challenge we looked at is that

00:08:02,960 --> 00:08:05,759
we have a lot of different type of types

00:08:04,639 --> 00:08:07,360
of web requests

00:08:05,759 --> 00:08:09,840
including our desktop main site at

00:08:07,360 --> 00:08:11,520
yelp.com we have the mobile site

00:08:09,840 --> 00:08:13,440
we have a bunch of different apis both

00:08:11,520 --> 00:08:15,280
both internal like for our mobile apps

00:08:13,440 --> 00:08:16,400
and also public apis

00:08:15,280 --> 00:08:18,080
and then we have a bunch of different

00:08:16,400 --> 00:08:20,240
micro sites like company blogs that are

00:08:18,080 --> 00:08:21,680
that are sort of one offs

00:08:20,240 --> 00:08:23,120
and all of these all of these requests

00:08:21,680 --> 00:08:24,879
need different combinations of features

00:08:23,120 --> 00:08:25,599
and behaviors so to give you a concrete

00:08:24,879 --> 00:08:27,360
example

00:08:25,599 --> 00:08:29,199
we couldn't show captchas on our api

00:08:27,360 --> 00:08:30,800
site because our api site the the

00:08:29,199 --> 00:08:32,240
clients are expecting to get a json

00:08:30,800 --> 00:08:33,680
response with the data

00:08:32,240 --> 00:08:35,519
and if we start sending them this full

00:08:33,680 --> 00:08:36,719
html response with a caption it they're

00:08:35,519 --> 00:08:39,039
not going to have any idea what to do

00:08:36,719 --> 00:08:40,719
with that response

00:08:39,039 --> 00:08:42,159
to add to the challenge here for legacy

00:08:40,719 --> 00:08:44,480
reasons because the stuff

00:08:42,159 --> 00:08:45,760
kind of grew organically over many years

00:08:44,480 --> 00:08:46,720
there isn't always a clear divide

00:08:45,760 --> 00:08:47,440
between these different types of

00:08:46,720 --> 00:08:49,120
requests

00:08:47,440 --> 00:08:51,200
so they can share the same domain names

00:08:49,120 --> 00:08:53,519
they can have the same path prefixes

00:08:51,200 --> 00:08:56,480
and the logic for differentiating them

00:08:53,519 --> 00:08:56,480
can be pretty complex

00:08:56,720 --> 00:08:59,920
to address this the first abstraction we

00:08:58,320 --> 00:09:03,200
came up with was that each request would

00:08:59,920 --> 00:09:04,720
be categorized into exactly one site

00:09:03,200 --> 00:09:06,240
so in the updated diagram here you can

00:09:04,720 --> 00:09:07,760
see a request coming in on the left and

00:09:06,240 --> 00:09:10,160
the very first thing we do with it is we

00:09:07,760 --> 00:09:12,320
run this determine site function

00:09:10,160 --> 00:09:14,000
after we've done that we split off into

00:09:12,320 --> 00:09:14,480
two different parallel chains for each

00:09:14,000 --> 00:09:18,080
site

00:09:14,480 --> 00:09:20,160
or many different ones and each site

00:09:18,080 --> 00:09:21,680
chain is where we do the real processing

00:09:20,160 --> 00:09:23,360
so the key here is that each site will

00:09:21,680 --> 00:09:26,320
be handled independently from this point

00:09:23,360 --> 00:09:28,160
on as entirely parallel change

00:09:26,320 --> 00:09:29,760
a site is kind of like a virtual host in

00:09:28,160 --> 00:09:31,040
something like apache or nginx

00:09:29,760 --> 00:09:32,959
but it's not really restricted to a

00:09:31,040 --> 00:09:34,880
specific set of domains so instead the

00:09:32,959 --> 00:09:36,320
selection logic can be written in code

00:09:34,880 --> 00:09:39,680
and it may be more complicated for our

00:09:36,320 --> 00:09:39,680
legacy sites if it needs to be

00:09:40,000 --> 00:09:43,760
the second challenge that we we looked

00:09:41,680 --> 00:09:45,200
at is now that we know our requests are

00:09:43,760 --> 00:09:46,720
going to be separated into sites

00:09:45,200 --> 00:09:49,279
how do we choose which behaviors to

00:09:46,720 --> 00:09:50,640
apply on a per site basis

00:09:49,279 --> 00:09:51,839
so we know that the different sites will

00:09:50,640 --> 00:09:53,279
need different features and we won't

00:09:51,839 --> 00:09:53,839
find a way that lets us declare which

00:09:53,279 --> 00:09:55,680
features

00:09:53,839 --> 00:09:58,000
apply to a given site in a sustainable

00:09:55,680 --> 00:09:59,600
way it's easy to imagine that if we just

00:09:58,000 --> 00:10:01,040
kind of jumped in and started writing

00:09:59,600 --> 00:10:02,800
code that we might end up with this this

00:10:01,040 --> 00:10:05,200
giant function that's something like

00:10:02,800 --> 00:10:06,160
if the request is on site a or site d

00:10:05,200 --> 00:10:08,800
then do this

00:10:06,160 --> 00:10:09,920
else if it's on site c then do this and

00:10:08,800 --> 00:10:11,600
something like that would make it very

00:10:09,920 --> 00:10:12,880
hard for us to trace the request flow

00:10:11,600 --> 00:10:14,079
through the service and understand

00:10:12,880 --> 00:10:16,079
what's actually happening to that

00:10:14,079 --> 00:10:17,680
request

00:10:16,079 --> 00:10:19,200
ideally we want our behaviors to have a

00:10:17,680 --> 00:10:20,800
clear modular separation

00:10:19,200 --> 00:10:24,079
and to be configured in a way that's

00:10:20,800 --> 00:10:26,240
easy to understand and easy to follow

00:10:24,079 --> 00:10:28,079
the abstraction we adopted here was to

00:10:26,240 --> 00:10:28,959
adopt the the middleware pattern for our

00:10:28,079 --> 00:10:30,399
features

00:10:28,959 --> 00:10:32,160
so what this means is that each site

00:10:30,399 --> 00:10:34,560
will consist of a chain of middlewares

00:10:32,160 --> 00:10:36,399
declared in a specific defined order

00:10:34,560 --> 00:10:38,959
and the request will go from one feature

00:10:36,399 --> 00:10:40,320
to the next with an explicit ordering

00:10:38,959 --> 00:10:41,760
this makes it easy to change which

00:10:40,320 --> 00:10:43,839
features are enabled on each site it

00:10:41,760 --> 00:10:45,360
makes it easy to reorder the features

00:10:43,839 --> 00:10:48,399
and just kind of reuse them without

00:10:45,360 --> 00:10:49,920
having this this spaghetti code

00:10:48,399 --> 00:10:51,680
each middleware will see the request

00:10:49,920 --> 00:10:53,360
both at the ingress and then again in

00:10:51,680 --> 00:10:54,800
reverse at the egress

00:10:53,360 --> 00:10:56,480
so that allows you to do things like

00:10:54,800 --> 00:10:57,760
block the requested ingress

00:10:56,480 --> 00:10:59,920
the way that's implemented is you just

00:10:57,760 --> 00:11:01,279
don't forward it down the chain or at

00:10:59,920 --> 00:11:02,720
egress you can do things like change the

00:11:01,279 --> 00:11:04,320
response you can manipulate the

00:11:02,720 --> 00:11:06,160
the body or you can add a response

00:11:04,320 --> 00:11:07,600
header

00:11:06,160 --> 00:11:10,000
i want to talk a little about why this

00:11:07,600 --> 00:11:11,680
middleware pattern works so well for us

00:11:10,000 --> 00:11:13,040
and the main reason i like it is that it

00:11:11,680 --> 00:11:14,000
helps avoid that spaghetti code we

00:11:13,040 --> 00:11:15,760
talked about

00:11:14,000 --> 00:11:17,600
we don't have complicated logic to apply

00:11:15,760 --> 00:11:18,800
features and it's very easy to

00:11:17,600 --> 00:11:20,320
understand what's happening

00:11:18,800 --> 00:11:22,880
as as the request flows through the

00:11:20,320 --> 00:11:23,519
service another big thing is that it's

00:11:22,880 --> 00:11:25,600
easy to

00:11:23,519 --> 00:11:27,120
reuse these features across sites each

00:11:25,600 --> 00:11:28,480
site can just declare an ordered list of

00:11:27,120 --> 00:11:30,640
middlewares at once and any special

00:11:28,480 --> 00:11:31,839
config needed for each feature

00:11:30,640 --> 00:11:33,839
and then also the fact that we have

00:11:31,839 --> 00:11:35,760
clear code boundaries we have a very

00:11:33,839 --> 00:11:36,560
explicit entry point and exit point for

00:11:35,760 --> 00:11:38,079
each feature

00:11:36,560 --> 00:11:39,920
and that makes it easy to isolate things

00:11:38,079 --> 00:11:41,519
like timings and errors so we can see

00:11:39,920 --> 00:11:42,959
exactly how long a feature is taking and

00:11:41,519 --> 00:11:44,480
whether any errors are coming from that

00:11:42,959 --> 00:11:46,000
feature

00:11:44,480 --> 00:11:48,079
but it also means we can assign clear

00:11:46,000 --> 00:11:49,200
code ownership for a feature

00:11:48,079 --> 00:11:51,200
because we have lots of different

00:11:49,200 --> 00:11:52,399
responsibilities we may have experts

00:11:51,200 --> 00:11:53,680
spread across our teams for the

00:11:52,399 --> 00:11:54,560
different features in the routing

00:11:53,680 --> 00:11:56,880
service

00:11:54,560 --> 00:11:59,360
and being able to design assign a clear

00:11:56,880 --> 00:12:00,639
code ownership is a big benefit for us

00:11:59,360 --> 00:12:01,760
um just to give you an example at the

00:12:00,639 --> 00:12:03,440
bottom here i went to our metrics

00:12:01,760 --> 00:12:05,200
dashboard a few days ago

00:12:03,440 --> 00:12:07,200
and just pulled this this timing for one

00:12:05,200 --> 00:12:08,720
of our features in the routing service

00:12:07,200 --> 00:12:10,639
and you can see that this pattern makes

00:12:08,720 --> 00:12:11,279
it really easy to see here our zip can

00:12:10,639 --> 00:12:13,600
feature

00:12:11,279 --> 00:12:16,000
and how much time it's taking uh on

00:12:13,600 --> 00:12:16,000
average

00:12:16,639 --> 00:12:19,519
so at this point we've got the majority

00:12:18,000 --> 00:12:21,120
of our service architecture and we just

00:12:19,519 --> 00:12:22,480
have this one bit of magic left at the

00:12:21,120 --> 00:12:25,120
end where we choose which service to

00:12:22,480 --> 00:12:26,480
route to

00:12:25,120 --> 00:12:28,399
and that's our third challenge which is

00:12:26,480 --> 00:12:29,680
traffic routing and traffic routing is

00:12:28,399 --> 00:12:30,399
this really complex problem because

00:12:29,680 --> 00:12:31,519
there are a lot of different

00:12:30,399 --> 00:12:33,040
requirements

00:12:31,519 --> 00:12:34,800
in our case at yelp our service mesh

00:12:33,040 --> 00:12:37,120
takes care of the actual

00:12:34,800 --> 00:12:38,880
proxy of one request from one service to

00:12:37,120 --> 00:12:40,160
another but it's going to be the job of

00:12:38,880 --> 00:12:43,200
our new routing service to determine

00:12:40,160 --> 00:12:44,720
which service we even want to talk to

00:12:43,200 --> 00:12:46,639
so we have both logical requirements

00:12:44,720 --> 00:12:48,160
here so if you think of the example i

00:12:46,639 --> 00:12:49,920
gave before where we might have a search

00:12:48,160 --> 00:12:52,160
service serving the search page and it

00:12:49,920 --> 00:12:52,639
is service serving the biz page we might

00:12:52,160 --> 00:12:54,079
need

00:12:52,639 --> 00:12:55,760
to actually look at the request and

00:12:54,079 --> 00:12:57,360
figure out which service it actually

00:12:55,760 --> 00:12:58,959
belongs to based on the path

00:12:57,360 --> 00:13:00,560
but we also have a lot of operational

00:12:58,959 --> 00:13:01,680
requirements so for example

00:13:00,560 --> 00:13:03,760
you might want to route to different

00:13:01,680 --> 00:13:05,120
versions during code deploys

00:13:03,760 --> 00:13:06,399
we might want to be able to route to a

00:13:05,120 --> 00:13:07,760
different data center based on things

00:13:06,399 --> 00:13:09,040
like whether this is a read-only or

00:13:07,760 --> 00:13:10,160
read-write request

00:13:09,040 --> 00:13:11,600
and we also might want to be able to

00:13:10,160 --> 00:13:14,880
send a certain percent of traffic one

00:13:11,600 --> 00:13:14,880
place and the rest somewhere else

00:13:15,200 --> 00:13:18,320
to be honest with you here we kind of

00:13:16,639 --> 00:13:21,519
cheated on this abstraction

00:13:18,320 --> 00:13:22,800
i don't really have a great solution

00:13:21,519 --> 00:13:24,399
here because there's just too many

00:13:22,800 --> 00:13:26,480
potential requirements and constraints

00:13:24,399 --> 00:13:28,000
to have a very generic reusable piece of

00:13:26,480 --> 00:13:29,440
infrastructure

00:13:28,000 --> 00:13:31,839
instead what we decided to do was we

00:13:29,440 --> 00:13:33,600
simply settled on a function interface

00:13:31,839 --> 00:13:35,200
so each site will be responsible for

00:13:33,600 --> 00:13:36,880
declaring this simple

00:13:35,200 --> 00:13:38,880
interface service for request is the

00:13:36,880 --> 00:13:40,320
function it takes in a request object

00:13:38,880 --> 00:13:42,560
and it returns the name of the service

00:13:40,320 --> 00:13:44,959
it wants to talk to

00:13:42,560 --> 00:13:46,320
and while this is a bit of a cop-out we

00:13:44,959 --> 00:13:47,519
have pre-built functionality that

00:13:46,320 --> 00:13:48,000
essentially handles the the vast

00:13:47,519 --> 00:13:50,079
majority

00:13:48,000 --> 00:13:52,399
of our common use cases so if you're

00:13:50,079 --> 00:13:54,240
doing something like path-based routing

00:13:52,399 --> 00:13:55,839
routing to services based on the version

00:13:54,240 --> 00:13:57,680
or or data center routing

00:13:55,839 --> 00:13:59,120
that's something we've already built in

00:13:57,680 --> 00:13:59,440
so it's really only the sites that need

00:13:59,120 --> 00:14:01,040
this

00:13:59,440 --> 00:14:02,160
this complex behavior that are going to

00:14:01,040 --> 00:14:03,519
need to actually go out of their way to

00:14:02,160 --> 00:14:04,800
implement this

00:14:03,519 --> 00:14:06,320
and the nice thing here is that even

00:14:04,800 --> 00:14:07,920
though the complicated sites are going

00:14:06,320 --> 00:14:09,680
to need to implement their own logic

00:14:07,920 --> 00:14:11,279
at least it slots into our architecture

00:14:09,680 --> 00:14:12,160
in a way that's consistent and easy to

00:14:11,279 --> 00:14:13,440
understand

00:14:12,160 --> 00:14:16,959
and we don't really have any any

00:14:13,440 --> 00:14:18,320
snowflake sites

00:14:16,959 --> 00:14:19,839
so this point where we're pretty happy

00:14:18,320 --> 00:14:21,120
with the architecture we've come up with

00:14:19,839 --> 00:14:22,560
and we started thinking about how we

00:14:21,120 --> 00:14:24,240
would actually implement this

00:14:22,560 --> 00:14:25,519
this is the next big point on deciding

00:14:24,240 --> 00:14:27,760
if this is really something we think is

00:14:25,519 --> 00:14:29,440
worth doing

00:14:27,760 --> 00:14:31,920
so the first option we considered was

00:14:29,440 --> 00:14:33,600
writing a new http proxy from scratch in

00:14:31,920 --> 00:14:34,880
python or java

00:14:33,600 --> 00:14:36,240
i think the the reason this is so

00:14:34,880 --> 00:14:37,440
appealing to us is because we already

00:14:36,240 --> 00:14:39,040
have a lot of expertise in these

00:14:37,440 --> 00:14:40,079
languages and also we have a lot of code

00:14:39,040 --> 00:14:41,600
written in them

00:14:40,079 --> 00:14:43,120
and so it would be nice if we can reuse

00:14:41,600 --> 00:14:44,000
our existing code libraries and not have

00:14:43,120 --> 00:14:47,440
to re-implement those

00:14:44,000 --> 00:14:50,240
in some new language kind of the problem

00:14:47,440 --> 00:14:51,839
here is performance of these languages

00:14:50,240 --> 00:14:53,839
even with java which is a very fast

00:14:51,839 --> 00:14:56,000
language it's going to be really hard to

00:14:53,839 --> 00:14:57,360
match the performance of these top http

00:14:56,000 --> 00:14:58,399
proxies if you think of something like

00:14:57,360 --> 00:14:59,600
nginx

00:14:58,399 --> 00:15:01,279
which have years and years of

00:14:59,600 --> 00:15:03,600
optimizations built into them that we

00:15:01,279 --> 00:15:05,120
would have to try to compete with

00:15:03,600 --> 00:15:06,720
additionally we're worried about all the

00:15:05,120 --> 00:15:08,000
edge cases involved in handling what's

00:15:06,720 --> 00:15:09,040
essentially raw traffic from the

00:15:08,000 --> 00:15:10,639
internet

00:15:09,040 --> 00:15:12,800
we get a lot of this this what we call

00:15:10,639 --> 00:15:14,800
junk traffic uh from kind of poorly

00:15:12,800 --> 00:15:16,720
written user agents or bots

00:15:14,800 --> 00:15:17,920
um they don't necessarily follow all the

00:15:16,720 --> 00:15:20,000
rfcs

00:15:17,920 --> 00:15:21,519
um and something like nginx already

00:15:20,000 --> 00:15:22,560
pretty much knows how to deal with with

00:15:21,519 --> 00:15:24,720
this random not

00:15:22,560 --> 00:15:25,760
really following the spec traffic and we

00:15:24,720 --> 00:15:28,639
don't really want to spend our time

00:15:25,760 --> 00:15:28,639
reinventing that

00:15:29,120 --> 00:15:33,600
the second option we considered was

00:15:30,399 --> 00:15:35,759
using onboard envoy is this new uh

00:15:33,600 --> 00:15:38,160
service proxy it handles both service

00:15:35,759 --> 00:15:39,440
mesh and also edge proxies

00:15:38,160 --> 00:15:41,279
and the way it works is you basically

00:15:39,440 --> 00:15:42,000
implement your features as either c plus

00:15:41,279 --> 00:15:44,800
filters

00:15:42,000 --> 00:15:45,759
or potentially lua filters uh this is a

00:15:44,800 --> 00:15:47,440
really cool option

00:15:45,759 --> 00:15:49,120
um because of the performance and

00:15:47,440 --> 00:15:50,800
because this is a very modern

00:15:49,120 --> 00:15:53,120
uh proxy and the flexibility you get

00:15:50,800 --> 00:15:53,839
from that i think the the main problems

00:15:53,120 --> 00:15:55,440
for us

00:15:53,839 --> 00:15:57,600
one is a limited language choice it's

00:15:55,440 --> 00:15:58,959
pretty much just c plus or lua

00:15:57,600 --> 00:16:01,120
although that has a lot of restrictions

00:15:58,959 --> 00:16:03,120
on it that means we won't be able to

00:16:01,120 --> 00:16:04,639
reuse our existing code

00:16:03,120 --> 00:16:06,480
but i think the the bigger thing for us

00:16:04,639 --> 00:16:08,320
is that especially at the time it wasn't

00:16:06,480 --> 00:16:10,079
a super mature project it hadn't been

00:16:08,320 --> 00:16:11,839
adopted very widely

00:16:10,079 --> 00:16:13,040
and we were pretty concerned about that

00:16:11,839 --> 00:16:13,600
for something we were going to bail out

00:16:13,040 --> 00:16:16,160
as such a

00:16:13,600 --> 00:16:18,720
important piece of our infrastructure i

00:16:16,160 --> 00:16:20,000
will say envoy is much more mature today

00:16:18,720 --> 00:16:22,240
in fact we're using it internally for

00:16:20,000 --> 00:16:23,519
our service mesh now

00:16:22,240 --> 00:16:25,600
and it actually follows some of the

00:16:23,519 --> 00:16:27,199
similar design principles so for example

00:16:25,600 --> 00:16:29,279
it's it's filters follow the

00:16:27,199 --> 00:16:30,720
middleware pattern so i think if we were

00:16:29,279 --> 00:16:32,160
redoing this today i don't think the

00:16:30,720 --> 00:16:32,720
maturity would be a concern for us i

00:16:32,160 --> 00:16:34,839
think onward

00:16:32,720 --> 00:16:36,720
would definitely be a top candidate to

00:16:34,839 --> 00:16:38,079
consider

00:16:36,720 --> 00:16:39,839
another interesting option is to use

00:16:38,079 --> 00:16:41,519
something called edge computing

00:16:39,839 --> 00:16:44,000
edge computing is this feature offered

00:16:41,519 --> 00:16:45,680
by a lot of modern cdns

00:16:44,000 --> 00:16:47,120
for example cloudflare workers is an

00:16:45,680 --> 00:16:48,720
example of this but if you look at i

00:16:47,120 --> 00:16:51,279
know fastly i know cloudfront

00:16:48,720 --> 00:16:52,639
all have their own examples of this the

00:16:51,279 --> 00:16:53,759
way it works is you essentially upload a

00:16:52,639 --> 00:16:55,440
code bundle to them

00:16:53,759 --> 00:16:58,399
and they will run that code on their own

00:16:55,440 --> 00:17:00,399
machines on the request for you

00:16:58,399 --> 00:17:02,079
as they're serving traffic you can do

00:17:00,399 --> 00:17:03,360
arbitrary manipulations on the request

00:17:02,079 --> 00:17:04,559
you can interact with routing you can

00:17:03,360 --> 00:17:06,959
implement a lot of the features we

00:17:04,559 --> 00:17:08,799
talked about

00:17:06,959 --> 00:17:10,480
i think one of the the big problems here

00:17:08,799 --> 00:17:11,919
was again especially at the time these

00:17:10,480 --> 00:17:13,280
were relatively immature

00:17:11,919 --> 00:17:14,880
there wasn't a lot of prior art we

00:17:13,280 --> 00:17:16,240
weren't doing anything like this

00:17:14,880 --> 00:17:18,079
internally and so there were a lot of

00:17:16,240 --> 00:17:20,000
unknowns on how dependable and how

00:17:18,079 --> 00:17:21,360
reliable this would be

00:17:20,000 --> 00:17:22,959
another issue is that this pretty

00:17:21,360 --> 00:17:24,000
strongly ties us to a single cdn

00:17:22,959 --> 00:17:25,199
provider

00:17:24,000 --> 00:17:26,959
that's something we're not crazy about

00:17:25,199 --> 00:17:28,480
we actually run our site with two two

00:17:26,959 --> 00:17:29,760
independent cdns

00:17:28,480 --> 00:17:31,919
that we can swap between during

00:17:29,760 --> 00:17:33,919
incidents if we have to i think that the

00:17:31,919 --> 00:17:35,200
portability of of this edge computing is

00:17:33,919 --> 00:17:37,039
still kind of being developed

00:17:35,200 --> 00:17:39,919
it's not really there yet so that was

00:17:37,039 --> 00:17:39,919
another concern for us

00:17:40,080 --> 00:17:43,200
the final option we considered uh was a

00:17:41,919 --> 00:17:45,280
project called openresty

00:17:43,200 --> 00:17:47,919
openresty is a distribution of nginx

00:17:45,280 --> 00:17:49,200
plus lua plus some other modules

00:17:47,919 --> 00:17:51,760
essentially what you're doing is you're

00:17:49,200 --> 00:17:53,520
deploying nginx itself which is this

00:17:51,760 --> 00:17:55,039
dependable well-understood proxy

00:17:53,520 --> 00:17:57,120
but then you're embedding custom lua

00:17:55,039 --> 00:17:58,480
code that you've written um you get the

00:17:57,120 --> 00:18:00,559
the performance of nginx and the

00:17:58,480 --> 00:18:01,840
dependability of nginx

00:18:00,559 --> 00:18:04,080
but you get to actually embed your own

00:18:01,840 --> 00:18:05,760
code again the main downside here is the

00:18:04,080 --> 00:18:07,520
restricted language um

00:18:05,760 --> 00:18:08,720
you know lua is a fine language but but

00:18:07,520 --> 00:18:12,080
we don't have our code in it so we're

00:18:08,720 --> 00:18:14,000
going to have to rewrite a lot of stuff

00:18:12,080 --> 00:18:15,919
to give you a more concrete example of

00:18:14,000 --> 00:18:18,559
what open resty actually looks like i

00:18:15,919 --> 00:18:20,720
put just a simple hello world out here

00:18:18,559 --> 00:18:21,679
so at the top is a pretty standard nginx

00:18:20,720 --> 00:18:23,360
config file

00:18:21,679 --> 00:18:24,880
uh except in that location block where

00:18:23,360 --> 00:18:26,480
you would normally specify

00:18:24,880 --> 00:18:28,080
what you're going to proxy to or a

00:18:26,480 --> 00:18:29,360
directory to serve files from

00:18:28,080 --> 00:18:32,080
we have this new directive called

00:18:29,360 --> 00:18:34,240
content by lua file that just points to

00:18:32,080 --> 00:18:36,480
a the path to a lua file at the bottom

00:18:34,240 --> 00:18:38,080
i've got an example of that

00:18:36,480 --> 00:18:39,520
it runs this script which actually

00:18:38,080 --> 00:18:41,280
generates the response that's sent to

00:18:39,520 --> 00:18:44,559
the user so this is just sending 200

00:18:41,280 --> 00:18:46,000
okay and then hello world

00:18:44,559 --> 00:18:47,600
this is a very simple example but it can

00:18:46,000 --> 00:18:48,880
be much more complex you can import

00:18:47,600 --> 00:18:50,880
other lua files here

00:18:48,880 --> 00:18:52,320
you can make network calls you can do

00:18:50,880 --> 00:18:56,240
all kinds of stuff here you can do from

00:18:52,320 --> 00:18:58,320
from pretty much any other language

00:18:56,240 --> 00:18:59,520
so we ended up making a table comparing

00:18:58,320 --> 00:19:00,240
our options that looked something like

00:18:59,520 --> 00:19:01,679
this

00:19:00,240 --> 00:19:03,679
uh we implemented prototypes for our

00:19:01,679 --> 00:19:05,200
most promising options to get some idea

00:19:03,679 --> 00:19:06,799
for for how they would work and look in

00:19:05,200 --> 00:19:08,640
practice and what the performance would

00:19:06,799 --> 00:19:10,559
be like

00:19:08,640 --> 00:19:12,160
no option really satisfied everything we

00:19:10,559 --> 00:19:13,679
wanted um

00:19:12,160 --> 00:19:16,080
but we kind of decided we really wanted

00:19:13,679 --> 00:19:18,720
to prioritize the the matureness and the

00:19:16,080 --> 00:19:20,320
the battle testedness of the solution

00:19:18,720 --> 00:19:21,360
um especially because it's going to be

00:19:20,320 --> 00:19:22,880
such a critical part of our

00:19:21,360 --> 00:19:24,799
infrastructure that was kind of our top

00:19:22,880 --> 00:19:26,880
priority so for that reason

00:19:24,799 --> 00:19:28,480
we ended up going with openresty we

00:19:26,880 --> 00:19:30,080
really like that it's based on nginx

00:19:28,480 --> 00:19:31,440
which this which is this proxy that we

00:19:30,080 --> 00:19:32,960
have so much experience with and we

00:19:31,440 --> 00:19:34,320
really trust

00:19:32,960 --> 00:19:38,000
and we knew this would have would give

00:19:34,320 --> 00:19:40,640
us a lot of confidence going forward

00:19:38,000 --> 00:19:41,039
so uh we did it um we put a few people

00:19:40,640 --> 00:19:42,799
on

00:19:41,039 --> 00:19:44,559
this project to develop a first version

00:19:42,799 --> 00:19:46,400
of our routing service

00:19:44,559 --> 00:19:47,600
uh and we wrote the first version in

00:19:46,400 --> 00:19:48,880
just a few weeks um

00:19:47,600 --> 00:19:50,720
initially it was just a couple hundred

00:19:48,880 --> 00:19:52,080
lines of lua and all it did was serve as

00:19:50,720 --> 00:19:54,400
a pretty much transparent

00:19:52,080 --> 00:19:56,320
proxy it would just add this response

00:19:54,400 --> 00:19:58,000
header when a request flowed through it

00:19:56,320 --> 00:19:59,919
and we then rolled it out in front of

00:19:58,000 --> 00:20:01,280
all of our traffic slowly

00:19:59,919 --> 00:20:02,880
this was really nice because it meant

00:20:01,280 --> 00:20:04,240
that if we discovered any issues we

00:20:02,880 --> 00:20:05,760
could easily take it out of the request

00:20:04,240 --> 00:20:07,039
flow and just kind of roll back in that

00:20:05,760 --> 00:20:08,720
way

00:20:07,039 --> 00:20:10,000
which is something we can't do now now

00:20:08,720 --> 00:20:11,600
that we put all these critical features

00:20:10,000 --> 00:20:13,440
into it we can't actually serve our site

00:20:11,600 --> 00:20:15,039
without it

00:20:13,440 --> 00:20:17,039
since then we've moved a lot of features

00:20:15,039 --> 00:20:19,600
into it and it's proven to be

00:20:17,039 --> 00:20:20,960
super stable it's incredibly efficient

00:20:19,600 --> 00:20:22,960
we spend almost no money

00:20:20,960 --> 00:20:25,360
um hosting the routing service even

00:20:22,960 --> 00:20:26,320
though it's serving all of our traffic

00:20:25,360 --> 00:20:28,080
and you can actually check it out

00:20:26,320 --> 00:20:29,440
yourself if you go to pretty much any

00:20:28,080 --> 00:20:30,320
yelp website and look at the response

00:20:29,440 --> 00:20:31,919
headers

00:20:30,320 --> 00:20:33,200
you'll still see this x routing service

00:20:31,919 --> 00:20:34,000
response header with a little bit of

00:20:33,200 --> 00:20:35,760
debug information

00:20:34,000 --> 00:20:37,200
in it that dates all the way back to

00:20:35,760 --> 00:20:40,400
when we were just testing it out at the

00:20:37,200 --> 00:20:42,880
start as a transparent proxy

00:20:40,400 --> 00:20:43,919
uh just some specific reflections on

00:20:42,880 --> 00:20:44,720
kind of what we learned from

00:20:43,919 --> 00:20:46,240
implementing

00:20:44,720 --> 00:20:48,240
this new critical infrastructure in a

00:20:46,240 --> 00:20:49,520
new technology stack

00:20:48,240 --> 00:20:51,360
one thing is we definitely spent more

00:20:49,520 --> 00:20:52,720
time during the initial development

00:20:51,360 --> 00:20:54,159
uh we really wanted to make sure we were

00:20:52,720 --> 00:20:55,440
treating this like it was a first-class

00:20:54,159 --> 00:20:56,960
piece of infrastructure

00:20:55,440 --> 00:20:58,400
and so that meant we spent some time on

00:20:56,960 --> 00:21:00,080
things like metrics logging

00:20:58,400 --> 00:21:01,520
experimentation

00:21:00,080 --> 00:21:03,760
these are things we already have good

00:21:01,520 --> 00:21:05,039
implementations for outside of the the

00:21:03,760 --> 00:21:06,240
lua ecosystem

00:21:05,039 --> 00:21:07,760
uh but because we're using a new

00:21:06,240 --> 00:21:10,320
language we kind of had some to spend

00:21:07,760 --> 00:21:12,880
some time implementing these

00:21:10,320 --> 00:21:13,919
uh the nice thing was that because uh a

00:21:12,880 --> 00:21:15,440
lot of the time

00:21:13,919 --> 00:21:16,960
even when we had to re-implement stuff

00:21:15,440 --> 00:21:18,000
we were able to consolidate it into the

00:21:16,960 --> 00:21:19,520
routing service

00:21:18,000 --> 00:21:20,880
we didn't necessarily have to end up

00:21:19,520 --> 00:21:21,679
maintaining two versions of things

00:21:20,880 --> 00:21:23,120
forever

00:21:21,679 --> 00:21:24,559
uh once we move things into the routing

00:21:23,120 --> 00:21:26,320
service a lot of times we are able to

00:21:24,559 --> 00:21:29,440
retire the old implementation and not

00:21:26,320 --> 00:21:30,880
have to worry about that going forward

00:21:29,440 --> 00:21:32,880
and a few thoughts on on luis

00:21:30,880 --> 00:21:34,480
specifically as a language

00:21:32,880 --> 00:21:36,159
uh first of all it's it's a very simple

00:21:34,480 --> 00:21:37,280
and easy to pick up language uh none of

00:21:36,159 --> 00:21:38,799
us had really worked with it in a

00:21:37,280 --> 00:21:40,720
serious way before

00:21:38,799 --> 00:21:42,240
and just within a couple days we were

00:21:40,720 --> 00:21:44,880
writing it uh very easily

00:21:42,240 --> 00:21:46,400
uh it's super easy to pick up you do

00:21:44,880 --> 00:21:47,360
need to watch out for some sharp edges

00:21:46,400 --> 00:21:48,799
with lua

00:21:47,360 --> 00:21:50,400
for example everything is global by

00:21:48,799 --> 00:21:51,360
default if you don't declare it

00:21:50,400 --> 00:21:53,120
otherwise

00:21:51,360 --> 00:21:54,320
a lot of operations will fail silently

00:21:53,120 --> 00:21:56,320
it doesn't really have good error

00:21:54,320 --> 00:21:57,760
handling or exception handling

00:21:56,320 --> 00:21:59,679
and a lot of functions in the standard

00:21:57,760 --> 00:22:00,960
library have some caveats that you won't

00:21:59,679 --> 00:22:03,840
necessarily expect unless you've read

00:22:00,960 --> 00:22:05,200
about it in the documentation

00:22:03,840 --> 00:22:07,360
one way you can kind of work around this

00:22:05,200 --> 00:22:09,360
is by investing in code quality tooling

00:22:07,360 --> 00:22:10,480
the linters in particular lua check is

00:22:09,360 --> 00:22:12,159
something we used a lot

00:22:10,480 --> 00:22:14,880
go a long way to protecting against some

00:22:12,159 --> 00:22:16,559
of those those sharp edges

00:22:14,880 --> 00:22:18,320
in particular they'll catch things like

00:22:16,559 --> 00:22:19,919
like having globals by accident very

00:22:18,320 --> 00:22:21,520
very well

00:22:19,919 --> 00:22:23,039
i strongly recommend that you you treat

00:22:21,520 --> 00:22:25,039
it as serious code

00:22:23,039 --> 00:22:26,880
blue is often used as this embedded

00:22:25,039 --> 00:22:28,400
language and where you're only writing a

00:22:26,880 --> 00:22:29,919
few lines at a time

00:22:28,400 --> 00:22:31,280
but for us we spent a lot of time on the

00:22:29,919 --> 00:22:32,960
architecture here we didn't just treat

00:22:31,280 --> 00:22:34,799
it as a scripting language that we could

00:22:32,960 --> 00:22:36,080
kind of wing it as we're going

00:22:34,799 --> 00:22:38,159
we designed it with being able to write

00:22:36,080 --> 00:22:39,600
effective tests in mind for example

00:22:38,159 --> 00:22:41,360
and that really went a long way to

00:22:39,600 --> 00:22:42,640
making sure this service is designed and

00:22:41,360 --> 00:22:45,600
implemented in a way that's going to be

00:22:42,640 --> 00:22:47,039
sustainable going forward

00:22:45,600 --> 00:22:48,799
and then finally one thing we definitely

00:22:47,039 --> 00:22:50,080
learned a lot the hard way is that lua

00:22:48,799 --> 00:22:52,559
is definitely not a

00:22:50,080 --> 00:22:54,080
batteries included language its standard

00:22:52,559 --> 00:22:55,440
library is very minimal

00:22:54,080 --> 00:22:56,960
it doesn't have a lot of things you

00:22:55,440 --> 00:22:58,480
would expect from a language like python

00:22:56,960 --> 00:23:00,159
or java

00:22:58,480 --> 00:23:01,760
and so you'll find yourself kind of copy

00:23:00,159 --> 00:23:04,000
and pasting stuff from stack overflow

00:23:01,760 --> 00:23:06,159
constantly like merging two tables

00:23:04,000 --> 00:23:07,280
or splitting a string and you'll find

00:23:06,159 --> 00:23:08,720
that you have like five different

00:23:07,280 --> 00:23:09,280
implementations copied from five

00:23:08,720 --> 00:23:11,039
different

00:23:09,280 --> 00:23:12,720
stack overflow answers across your code

00:23:11,039 --> 00:23:14,960
base that all have different interfaces

00:23:12,720 --> 00:23:17,200
and different caveats

00:23:14,960 --> 00:23:18,559
i definitely recommend don't do that

00:23:17,200 --> 00:23:20,159
instead what you can do

00:23:18,559 --> 00:23:21,919
there are libraries for lua that are

00:23:20,159 --> 00:23:23,280
essentially supplemental standard

00:23:21,919 --> 00:23:24,720
libraries and they just provide these

00:23:23,280 --> 00:23:27,360
common functions for things like working

00:23:24,720 --> 00:23:28,799
with strings or working with tables

00:23:27,360 --> 00:23:30,799
i definitely recommend picking one of

00:23:28,799 --> 00:23:32,240
those up from the start of your project

00:23:30,799 --> 00:23:33,760
just just adopt that as your one

00:23:32,240 --> 00:23:35,120
standard way to do these things and then

00:23:33,760 --> 00:23:37,840
you can use that consistently across

00:23:35,120 --> 00:23:37,840
your code base

00:23:38,240 --> 00:23:41,039
a couple things just finally on

00:23:39,840 --> 00:23:42,320
reflections on the development and

00:23:41,039 --> 00:23:43,840
rollout

00:23:42,320 --> 00:23:45,600
starting with the architecture rather

00:23:43,840 --> 00:23:46,960
than just jumping and writing code was

00:23:45,600 --> 00:23:48,000
was really helpful for us because it

00:23:46,960 --> 00:23:49,120
helped us during our planning and

00:23:48,000 --> 00:23:50,400
prototyping

00:23:49,120 --> 00:23:53,440
we didn't need to reinvent the project

00:23:50,400 --> 00:23:54,960
halfway through as things got thorny

00:23:53,440 --> 00:23:56,240
bad on openresty i think this is a

00:23:54,960 --> 00:23:57,039
really great project i think it's got a

00:23:56,240 --> 00:23:59,840
great future

00:23:57,039 --> 00:24:01,679
it worked super reliably for us

00:23:59,840 --> 00:24:02,799
launching as a transparent proxy first i

00:24:01,679 --> 00:24:04,320
think

00:24:02,799 --> 00:24:06,240
that really enabled us to solve all the

00:24:04,320 --> 00:24:08,159
problems with just the proxy itself

00:24:06,240 --> 00:24:09,520
in particular uh one of the things we

00:24:08,159 --> 00:24:11,120
did is we deployed this as a regular

00:24:09,520 --> 00:24:12,799
service on our service mesh

00:24:11,120 --> 00:24:14,080
and we discovered a couple edge cases

00:24:12,799 --> 00:24:15,440
that we didn't really notice with other

00:24:14,080 --> 00:24:17,600
services

00:24:15,440 --> 00:24:19,279
because this service was so high in

00:24:17,600 --> 00:24:20,640
terms of requests per second

00:24:19,279 --> 00:24:21,919
that others hadn't really noticed these

00:24:20,640 --> 00:24:23,679
problems and it took us a little extra

00:24:21,919 --> 00:24:25,039
time to fix those

00:24:23,679 --> 00:24:27,039
and finally spending extra time on

00:24:25,039 --> 00:24:28,240
experimentation was a big deal for us

00:24:27,039 --> 00:24:30,240
we have the ability to launch new

00:24:28,240 --> 00:24:31,840
features very carefully we can do things

00:24:30,240 --> 00:24:33,360
like launch first to internal traffic or

00:24:31,840 --> 00:24:33,919
launch to consistent percentages of

00:24:33,360 --> 00:24:35,520
traffic

00:24:33,919 --> 00:24:36,720
we can also target specific countries

00:24:35,520 --> 00:24:37,679
which makes for a very nice way to

00:24:36,720 --> 00:24:39,200
compare

00:24:37,679 --> 00:24:40,720
the timings and errors for example from

00:24:39,200 --> 00:24:41,600
country a and country b

00:24:40,720 --> 00:24:44,240
and make sure we're launching new

00:24:41,600 --> 00:24:46,400
features safely

00:24:44,240 --> 00:24:47,600
uh that's all i've got um i'm recording

00:24:46,400 --> 00:24:49,039
this about two weeks from when you're

00:24:47,600 --> 00:24:50,320
seeing it but if everything's gone right

00:24:49,039 --> 00:24:51,440
we should have about five minutes left

00:24:50,320 --> 00:24:52,960
for questions

00:24:51,440 --> 00:24:54,640
uh before i answer those i know we're

00:24:52,960 --> 00:24:55,840
short on time and and we have limited

00:24:54,640 --> 00:24:56,960
opportunities for talking at this

00:24:55,840 --> 00:24:58,159
virtual conference

00:24:56,960 --> 00:25:00,000
uh but i'd still really love to hear

00:24:58,159 --> 00:25:03,279
from you please reach out via

00:25:00,000 --> 00:25:04,480
email see kio at yelp.com or on twitter

00:25:03,279 --> 00:25:05,919
at imc kio

00:25:04,480 --> 00:25:15,840
i'd really love to discuss any of this

00:25:05,919 --> 00:25:15,840
with you thank you so much for attending

00:25:24,240 --> 00:25:28,320
all right hi everyone uh thank you so

00:25:26,159 --> 00:25:30,000
much for attending and wanting to talk

00:25:28,320 --> 00:25:32,080
i was super excited to be able to give

00:25:30,000 --> 00:25:33,679
that uh and and looking forward to

00:25:32,080 --> 00:25:36,080
hearing from you all um if you do have

00:25:33,679 --> 00:25:36,640
questions uh please feel free to enter

00:25:36,080 --> 00:25:38,080
those in

00:25:36,640 --> 00:25:40,000
uh i don't see any yet but i'll i'm

00:25:38,080 --> 00:25:43,840
happy to answer those and also to chat

00:25:40,000 --> 00:25:43,840
over

00:25:58,400 --> 00:26:11,840
works out

00:26:41,520 --> 00:26:45,440
i had a couple couple people say uh not

00:26:43,760 --> 00:26:47,279
questions but thanks for the talk so

00:26:45,440 --> 00:26:49,760
thanks for the comment i appreciate that

00:26:47,279 --> 00:26:51,279
um uh pamela asked you mention

00:26:49,760 --> 00:26:53,520
architecture before code do you have any

00:26:51,279 --> 00:26:55,200
tool recommendations for doing so

00:26:53,520 --> 00:26:57,440
i'm not totally sure if i understand the

00:26:55,200 --> 00:26:57,840
question um but i think the the thing

00:26:57,440 --> 00:27:00,799
for us

00:26:57,840 --> 00:27:02,000
was um basically this was like a big

00:27:00,799 --> 00:27:03,600
unknown for us

00:27:02,000 --> 00:27:05,120
we weren't entirely sure if we wanted to

00:27:03,600 --> 00:27:07,360
to commit to building this

00:27:05,120 --> 00:27:08,880
especially because the kind of the the

00:27:07,360 --> 00:27:10,240
back end infrastructure people were very

00:27:08,880 --> 00:27:11,200
nervous when i started talking about

00:27:10,240 --> 00:27:14,480
this

00:27:11,200 --> 00:27:15,679
um so you know we really needed to make

00:27:14,480 --> 00:27:16,799
sure we were convincing them that this

00:27:15,679 --> 00:27:18,559
is a good idea

00:27:16,799 --> 00:27:20,320
um and so in particular what we did is

00:27:18,559 --> 00:27:22,480
we did a lot of kind of talking with

00:27:20,320 --> 00:27:23,440
them and understanding their concerns

00:27:22,480 --> 00:27:25,279
and figuring out how we're going to

00:27:23,440 --> 00:27:26,799
build this and planning that out in a in

00:27:25,279 --> 00:27:28,320
a document and getting sign off from all

00:27:26,799 --> 00:27:31,279
the stakeholders

00:27:28,320 --> 00:27:31,760
and then kind of kind of thinking about

00:27:31,279 --> 00:27:33,520
what the

00:27:31,760 --> 00:27:35,039
the challenges we anticipated were and

00:27:33,520 --> 00:27:36,640
how we would address those

00:27:35,039 --> 00:27:38,000
uh and and how we would actually design

00:27:36,640 --> 00:27:39,600
this service before we started writing

00:27:38,000 --> 00:27:40,960
any code

00:27:39,600 --> 00:27:42,559
so i don't have a specific tool

00:27:40,960 --> 00:27:44,480
recommendation because it was more of a

00:27:42,559 --> 00:27:47,440
i think it was more of like a process

00:27:44,480 --> 00:27:48,960
that we followed um but yeah we were

00:27:47,440 --> 00:27:50,720
just very thorough with the the planning

00:27:48,960 --> 00:27:53,120
on this project more so than

00:27:50,720 --> 00:27:54,799
more so maybe than was necessary but uh

00:27:53,120 --> 00:27:56,000
that kind of enabled us to sell this to

00:27:54,799 --> 00:27:58,159
everyone because it was a

00:27:56,000 --> 00:28:03,840
kind of a controversial idea at the time

00:27:58,159 --> 00:28:03,840
thank you for the question

00:28:51,600 --> 00:28:54,960
yeah pamela says has faced some of the

00:28:53,679 --> 00:28:56,480
similar

00:28:54,960 --> 00:28:58,480
challenges with getting a good design

00:28:56,480 --> 00:29:00,720
first um yeah i can definitely

00:28:58,480 --> 00:29:01,679
can definitely kind of communicate with

00:29:00,720 --> 00:29:02,960
that um

00:29:01,679 --> 00:29:04,640
that's something we we've definitely

00:29:02,960 --> 00:29:05,520
like kind of had to build up in our

00:29:04,640 --> 00:29:07,600
organization

00:29:05,520 --> 00:29:08,880
um and yeah i think just like going with

00:29:07,600 --> 00:29:10,480
the planning especially for something

00:29:08,880 --> 00:29:13,279
like this that's going to be such a

00:29:10,480 --> 00:29:14,399
a critical piece of infrastructure is

00:29:13,279 --> 00:29:15,760
super important i don't think you'll

00:29:14,399 --> 00:29:27,840
regret spending time on the planning

00:29:15,760 --> 00:29:27,840
before you jump into implementation

00:29:44,000 --> 00:29:47,039
awesome i believe we're coming up on

00:29:46,320 --> 00:29:50,480
time here

00:29:47,039 --> 00:29:52,240
um but um yeah uh

00:29:50,480 --> 00:29:54,240
they're gonna post i believe a message

00:29:52,240 --> 00:29:56,399
in the in the uh

00:29:54,240 --> 00:29:57,919
uh conference um letting you know what

00:29:56,399 --> 00:29:59,120
slack channel we're moving to uh so

00:29:57,919 --> 00:30:00,799
please feel free to jump over there and

00:29:59,120 --> 00:30:01,120
ask any questions or just just ping me

00:30:00,799 --> 00:30:03,120
on

00:30:01,120 --> 00:30:06,240
on flight directly i'd love to talk to

00:30:03,120 --> 00:30:06,240
y'all there thanks so much for

00:30:06,840 --> 00:30:09,840
attending

00:30:25,600 --> 00:30:27,679

YouTube URL: https://www.youtube.com/watch?v=Oz3ZAIs6L7c


