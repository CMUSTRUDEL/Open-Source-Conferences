Title: Traits and You: A Deep Dive — Nell Shamrell-Harrington
Publication date: 2018-01-06
Playlist: Rust Belt Rust 2017
Description: 
	Traits are one of the most powerful, but also most difficult parts of Rust to master. Come to this talk for a visual exploration of how traits work - from the most basic to the advanced. It is only through deep understanding of a concept like traits that you can fully harness their power in your every day code. You will walk away with a deep understanding of how traits work, why they work the way they do, and the how and why of using them.
Captions: 
	00:00:03,910 --> 00:00:09,110
well good afternoon everyone I want to

00:00:06,859 --> 00:00:11,150
start off by making sure to say thank

00:00:09,110 --> 00:00:13,669
you for staying for the last talk of the

00:00:11,150 --> 00:00:16,070
conference I know it's been a long day

00:00:13,669 --> 00:00:17,539
full of fantastic content and it can be

00:00:16,070 --> 00:00:20,480
draining so thank you for still being

00:00:17,539 --> 00:00:22,910
here I want to start off by saying that

00:00:20,480 --> 00:00:24,860
traits are awesome they are one of my

00:00:22,910 --> 00:00:27,500
favorite things about the Russ language

00:00:24,860 --> 00:00:30,770
but that said when I was getting started

00:00:27,500 --> 00:00:33,410
with rust traits were hard to grasp at

00:00:30,770 --> 00:00:35,780
first did anyone else find traits a

00:00:33,410 --> 00:00:37,999
little hard to grasp at first alright we

00:00:35,780 --> 00:00:39,199
got a few hands up here that's good I I

00:00:37,999 --> 00:00:41,149
think this was particularly because I

00:00:39,199 --> 00:00:42,710
came from a traditional object-oriented

00:00:41,149 --> 00:00:46,339
language which I'll talk a little bit a

00:00:42,710 --> 00:00:48,829
little more about a bit later but I have

00:00:46,339 --> 00:00:50,839
good news for you today and that is that

00:00:48,829 --> 00:00:53,390
despite them being a bit hard to get my

00:00:50,839 --> 00:00:56,390
head around at first I have learned to

00:00:53,390 --> 00:01:01,010
harness the power of traits and so can

00:00:56,390 --> 00:01:03,920
you now before we dive into traits let's

00:01:01,010 --> 00:01:05,840
briefly cover Who I am I'm Mel Shamrock

00:01:03,920 --> 00:01:08,240
Harrington I'm a core maintainer of

00:01:05,840 --> 00:01:10,880
habitat which is written in rust I'm a

00:01:08,240 --> 00:01:12,770
senior engineer at chef I come from

00:01:10,880 --> 00:01:15,500
Seattle Washington do you have any other

00:01:12,770 --> 00:01:17,210
Pacific Northwest earners here alright

00:01:15,500 --> 00:01:20,390
we got a couple of us good good that the

00:01:17,210 --> 00:01:22,430
long the long flight crew you can tweet

00:01:20,390 --> 00:01:24,380
at me at at Nell sham rel or feel free

00:01:22,430 --> 00:01:27,229
to email me at end sham rail at Chef dot

00:01:24,380 --> 00:01:28,430
IO and I will put these details back up

00:01:27,229 --> 00:01:31,579
at the end of this talk

00:01:28,430 --> 00:01:35,240
now I've divided our journey today into

00:01:31,579 --> 00:01:37,609
three stages the first is traits 101

00:01:35,240 --> 00:01:40,490
that's will cover the basics of them how

00:01:37,609 --> 00:01:42,979
you make them how you use them and then

00:01:40,490 --> 00:01:45,289
we'll come traits 201 where we will

00:01:42,979 --> 00:01:48,079
discuss trait bounds and what that

00:01:45,289 --> 00:01:50,929
allows you to do and then finally traits

00:01:48,079 --> 00:01:53,299
301 will cover the world of trait

00:01:50,929 --> 00:01:56,420
objects and how they allow you to take

00:01:53,299 --> 00:01:58,909
your Rusco to new heights so no matter

00:01:56,420 --> 00:02:01,640
where you are in your rust journey I

00:01:58,909 --> 00:02:03,829
think you'll get at least something out

00:02:01,640 --> 00:02:06,619
of each one of these out of one of these

00:02:03,829 --> 00:02:10,840
stages if not all of them and without

00:02:06,619 --> 00:02:13,129
further ado let's dive into traits 101

00:02:10,840 --> 00:02:15,019
now one of my favorite analogies for

00:02:13,129 --> 00:02:15,770
programming is the game Dungeons &

00:02:15,019 --> 00:02:18,080
Dragons

00:02:15,770 --> 00:02:20,840
it's a great model of a system that is

00:02:18,080 --> 00:02:23,480
defined by math with very clear rules

00:02:20,840 --> 00:02:25,270
but there are infinite possibilities for

00:02:23,480 --> 00:02:27,170
creating adventures and experiences

00:02:25,270 --> 00:02:29,090
within these rules

00:02:27,170 --> 00:02:31,910
now speaking of Dungeons and Dragons

00:02:29,090 --> 00:02:34,730
rules there is one thing I want to make

00:02:31,910 --> 00:02:38,930
clear up front and that is red if my

00:02:34,730 --> 00:02:40,940
fellow gamers in the audience yes I have

00:02:38,930 --> 00:02:43,970
simplified the rules of Dungeons and

00:02:40,940 --> 00:02:45,680
Dragons for this presentation now I put

00:02:43,970 --> 00:02:47,660
this in because when I started writing

00:02:45,680 --> 00:02:49,220
this talk I mentioned to some co-workers

00:02:47,660 --> 00:02:52,070
I'm thinking about using Dungeons and

00:02:49,220 --> 00:02:53,990
Dragons as an analogy for traits which

00:02:52,070 --> 00:02:56,030
led into this very long conversation

00:02:53,990 --> 00:02:57,680
about well what part of D&D would be the

00:02:56,030 --> 00:02:59,750
best one for it and then someone piped

00:02:57,680 --> 00:03:01,400
in with na Dungeons & Dragons isn't the

00:02:59,750 --> 00:03:03,770
right system we need to talk about gurps

00:03:01,400 --> 00:03:07,640
or the magic system when we're talking

00:03:03,770 --> 00:03:10,220
about metaphors for rust so while that

00:03:07,640 --> 00:03:12,980
was a fun conversation the focus on this

00:03:10,220 --> 00:03:15,680
talk is traits with Dungeons & Dragons

00:03:12,980 --> 00:03:17,690
used as a metaphor it's not meant to be

00:03:15,680 --> 00:03:20,090
a literal interpretation of the rules of

00:03:17,690 --> 00:03:21,650
dodges and Dragons fifth edition now

00:03:20,090 --> 00:03:25,010
with that on though out of the way let's

00:03:21,650 --> 00:03:27,709
go ahead and begin in Dungeons & Dragons

00:03:25,010 --> 00:03:29,840
you start a game by creating a character

00:03:27,709 --> 00:03:31,519
and the first thing you select about

00:03:29,840 --> 00:03:33,980
that character is its race there are

00:03:31,519 --> 00:03:36,980
nine to choose from but in this talk

00:03:33,980 --> 00:03:37,880
let's first focus on these four a dwarf

00:03:36,980 --> 00:03:40,640
and elf

00:03:37,880 --> 00:03:43,370
a half-orc and a human so let's

00:03:40,640 --> 00:03:45,980
represent these by creating strips in

00:03:43,370 --> 00:03:48,230
rust trucks are fantastic way to name

00:03:45,980 --> 00:03:50,780
and package together different values

00:03:48,230 --> 00:03:52,610
into a meaningful group so we create a

00:03:50,780 --> 00:03:54,500
structure for a dwarf we create one for

00:03:52,610 --> 00:03:55,790
an elf right now the only feel we're

00:03:54,500 --> 00:03:58,459
going to worry about is the name of the

00:03:55,790 --> 00:04:00,739
character and then let's add in one for

00:03:58,459 --> 00:04:03,350
a half hour and another struct for a

00:04:00,739 --> 00:04:05,870
human so we've defined the racism

00:04:03,350 --> 00:04:08,630
Dungeons & Dragons s trucks now when I

00:04:05,870 --> 00:04:11,180
want to make a character I can create an

00:04:08,630 --> 00:04:12,980
instance of one of these trucks so if I

00:04:11,180 --> 00:04:15,860
want to create a dwarf I create an

00:04:12,980 --> 00:04:18,470
instance of the dwarf struct and for now

00:04:15,860 --> 00:04:20,690
we'll name it Nell dwarf so now that we

00:04:18,470 --> 00:04:24,140
have a basic character we need to add

00:04:20,690 --> 00:04:27,380
certain traits to it and every D&D

00:04:24,140 --> 00:04:28,150
character has six core traits strengths

00:04:27,380 --> 00:04:31,030
that

00:04:28,150 --> 00:04:34,090
steady Constitution intelligence wisdom

00:04:31,030 --> 00:04:37,150
and charisma now for now let's just

00:04:34,090 --> 00:04:38,830
focus on Constitution we have our dwarf

00:04:37,150 --> 00:04:42,250
character now now we need a way of

00:04:38,830 --> 00:04:43,630
giving it a constitution so to do that

00:04:42,250 --> 00:04:46,060
let's make it Freight let's make a

00:04:43,630 --> 00:04:50,070
public tray or call it constitution and

00:04:46,060 --> 00:04:53,169
in this trait we define one function

00:04:50,070 --> 00:04:55,539
Constitution bonus notice that we don't

00:04:53,169 --> 00:04:57,699
define how this function is carried out

00:04:55,539 --> 00:04:59,470
we just define the name of it what we

00:04:57,699 --> 00:05:02,289
expect pass to it and the expected

00:04:59,470 --> 00:05:05,680
output which in this case is a u8 number

00:05:02,289 --> 00:05:07,750
so now that we have the trait defined we

00:05:05,680 --> 00:05:10,240
need to implement this constitution

00:05:07,750 --> 00:05:12,190
trait on our dwarf struct it should have

00:05:10,240 --> 00:05:14,380
all the functionality of this trait but

00:05:12,190 --> 00:05:15,030
be able to override parts of it as

00:05:14,380 --> 00:05:17,229
needed

00:05:15,030 --> 00:05:19,030
so this is how we implement the

00:05:17,229 --> 00:05:21,729
Constitution trait for our dwarf struct

00:05:19,030 --> 00:05:24,699
now along with implementing this basic

00:05:21,729 --> 00:05:27,400
trait on it we also need to define how

00:05:24,699 --> 00:05:30,580
this constitution bonus function works

00:05:27,400 --> 00:05:33,130
and we remember when we made this trait

00:05:30,580 --> 00:05:35,919
we left exactly how this function works

00:05:33,130 --> 00:05:38,889
up to whatever struct implements this

00:05:35,919 --> 00:05:40,990
trait so to implement this we need to

00:05:38,889 --> 00:05:43,870
understand that the Constitution bonus

00:05:40,990 --> 00:05:46,449
for a dwarf is two that is common to any

00:05:43,870 --> 00:05:47,710
character that happens to be a dwarf so

00:05:46,449 --> 00:05:49,599
that means if you're doing some sort of

00:05:47,710 --> 00:05:51,880
action where you need to roll the dice

00:05:49,599 --> 00:05:54,099
and score a certain Constitution score

00:05:51,880 --> 00:05:56,110
if you have a dwarf you can always add

00:05:54,099 --> 00:05:59,380
two to it just by virtue of being at

00:05:56,110 --> 00:06:01,659
that race so let's add this in and let's

00:05:59,380 --> 00:06:04,510
implement Constitution bonus for our

00:06:01,659 --> 00:06:07,599
dwarf and we're gonna say it's going to

00:06:04,510 --> 00:06:09,490
return two whenever Constitution bonus

00:06:07,599 --> 00:06:13,060
is called on an instance of the dwarf

00:06:09,490 --> 00:06:14,919
struct so let's see this in action here

00:06:13,060 --> 00:06:17,349
I've got my character it's a dwarf with

00:06:14,919 --> 00:06:19,990
the name of Nell dwarf and when I call

00:06:17,349 --> 00:06:23,370
Constitution bonus on this character it

00:06:19,990 --> 00:06:25,630
will return two so I could create more

00:06:23,370 --> 00:06:27,849
implementations of the struct more dwarf

00:06:25,630 --> 00:06:31,000
characters and each one of them will

00:06:27,849 --> 00:06:34,360
return two whenever I call Constitution

00:06:31,000 --> 00:06:36,190
bonus on them now that covers one of our

00:06:34,360 --> 00:06:37,900
socks let's take a look at one that

00:06:36,190 --> 00:06:39,990
might have a different Constitution

00:06:37,900 --> 00:06:42,200
bonus and that is the

00:06:39,990 --> 00:06:44,730
half-orc when i want to add a

00:06:42,200 --> 00:06:47,880
constitution to the half-orc struct i

00:06:44,730 --> 00:06:50,430
first implement it and then remember I

00:06:47,880 --> 00:06:52,740
also need to define the Constitution

00:06:50,430 --> 00:06:54,630
bonus for that 1/2 or extract which is

00:06:52,740 --> 00:06:57,420
different from a Dwarfs Constitution

00:06:54,630 --> 00:07:00,180
bonus the Constitution bonus for a

00:06:57,420 --> 00:07:01,740
half-orc is 1 that means anytime you do

00:07:00,180 --> 00:07:03,900
a dice roll and you need to score a

00:07:01,740 --> 00:07:06,660
certain Constitution you can always add

00:07:03,900 --> 00:07:08,790
1 if your character is a half-orc so

00:07:06,660 --> 00:07:11,400
they have this base Constitution bonus

00:07:08,790 --> 00:07:13,590
and I go ahead and implement that on my

00:07:11,400 --> 00:07:17,670
implementation this traits for half-orcs

00:07:13,590 --> 00:07:18,930
and this time it will return 1 now let's

00:07:17,670 --> 00:07:22,230
see this in action let's create a

00:07:18,930 --> 00:07:24,900
half-orc called nell ork and let's call

00:07:22,230 --> 00:07:27,120
constitution bonus on it so when I call

00:07:24,900 --> 00:07:31,170
Constitution bonus on any instance of

00:07:27,120 --> 00:07:33,150
the half-orc struct it will return 1 now

00:07:31,170 --> 00:07:35,430
there's two more races we need to

00:07:33,150 --> 00:07:38,040
implement a constitution for the elf

00:07:35,430 --> 00:07:40,230
struct and the human struct and these

00:07:38,040 --> 00:07:43,260
two actually have the same Constitution

00:07:40,230 --> 00:07:45,630
bonus if you're playing 1/2 if you're

00:07:43,260 --> 00:07:48,660
playing a human or a half elf or an elf

00:07:45,630 --> 00:07:51,150
your Constitution bonus will always be 0

00:07:48,660 --> 00:07:53,480
so let's go ahead and implement this we

00:07:51,150 --> 00:07:56,160
implement Constitution for the elf and

00:07:53,480 --> 00:07:58,260
implement Constitution for human now we

00:07:56,160 --> 00:08:00,510
could do it like this defining the

00:07:58,260 --> 00:08:03,270
Constitution bonus for both of them as 0

00:08:00,510 --> 00:08:04,920
but this is pretty darn repetitive and

00:08:03,270 --> 00:08:07,170
it's not not really what I like to see

00:08:04,920 --> 00:08:10,020
in my programming something to know is

00:08:07,170 --> 00:08:12,840
that most races have a Constitution

00:08:10,020 --> 00:08:15,090
bonus of 0 it's an exception when

00:08:12,840 --> 00:08:18,270
something has a Constitution bonus other

00:08:15,090 --> 00:08:21,210
than 0 in Dungeons and Dragons so let's

00:08:18,270 --> 00:08:24,330
go ahead and implement 0 as the default

00:08:21,210 --> 00:08:26,250
for a Constitution bonus and we do that

00:08:24,330 --> 00:08:28,320
by going back to where we defined our

00:08:26,250 --> 00:08:32,400
traits and that Constitution bonus

00:08:28,320 --> 00:08:35,010
function and we say it will return 0 so

00:08:32,400 --> 00:08:37,590
unless a struct that implements this

00:08:35,010 --> 00:08:41,310
trait overrides the Constitution bonus

00:08:37,590 --> 00:08:43,140
it will always return 0 so let's see

00:08:41,310 --> 00:08:47,340
this in action and let's implement this

00:08:43,140 --> 00:08:49,560
on our elf and our human struct and I'm

00:08:47,340 --> 00:08:51,750
going to need to implement the traits I

00:08:49,560 --> 00:08:53,020
don't need to define how Constitution

00:08:51,750 --> 00:08:54,130
bonus works be

00:08:53,020 --> 00:08:56,380
cause I'm using the default

00:08:54,130 --> 00:08:58,300
functionality of it but I do still have

00:08:56,380 --> 00:09:01,240
to implement this trait on each of my

00:08:58,300 --> 00:09:03,940
structs so let's create an elf I'm going

00:09:01,240 --> 00:09:05,740
to call this nell elf and let's call it

00:09:03,940 --> 00:09:08,710
constitution bonus on that and that

00:09:05,740 --> 00:09:11,110
returns zero now let's create a human

00:09:08,710 --> 00:09:13,180
and the human I'm just gonna call Nell

00:09:11,110 --> 00:09:14,830
because although if you can tell I play

00:09:13,180 --> 00:09:18,070
Dungeons and Dragons whether I was human

00:09:14,830 --> 00:09:19,660
was up for debate in middle school I am

00:09:18,070 --> 00:09:22,030
I pretty sure I'm a human so I'm just

00:09:19,660 --> 00:09:24,550
gonna call my human Nell and then I call

00:09:22,030 --> 00:09:27,640
Constitution bonus on it and it returns

00:09:24,550 --> 00:09:29,650
zero so at this point

00:09:27,640 --> 00:09:32,170
yay we have a trait and we have a

00:09:29,650 --> 00:09:34,180
default functionality for that trait for

00:09:32,170 --> 00:09:37,720
the Constitution bonus function but we

00:09:34,180 --> 00:09:40,120
can always override it if we need to now

00:09:37,720 --> 00:09:43,390
that brings us to the end of traits 101

00:09:40,120 --> 00:09:46,960
so let's dive right into traits 201

00:09:43,390 --> 00:09:49,420
trait bounds and again we're using our

00:09:46,960 --> 00:09:52,180
Dungeons & Dragons metaphor and this

00:09:49,420 --> 00:09:54,910
time I'm going to add another race we've

00:09:52,180 --> 00:09:58,840
got our four core races right now let's

00:09:54,910 --> 00:10:00,400
add in a half elf now as you can see the

00:09:58,840 --> 00:10:02,050
world of Dungeons and Dragons it's a

00:10:00,400 --> 00:10:03,460
pretty diverse world there's people with

00:10:02,050 --> 00:10:05,800
lots of different backgrounds and

00:10:03,460 --> 00:10:09,100
different races they need a way to

00:10:05,800 --> 00:10:11,830
communicate and part of creating your

00:10:09,100 --> 00:10:14,010
character is defining how that character

00:10:11,830 --> 00:10:17,290
can communicate with the outside world

00:10:14,010 --> 00:10:20,050
so every race comes with some core

00:10:17,290 --> 00:10:22,720
languages that it already speaks dwarfs

00:10:20,050 --> 00:10:25,600
be common and dwarvish elves be common

00:10:22,720 --> 00:10:29,140
in elvish and half elfs also speak

00:10:25,600 --> 00:10:31,270
common and elvish so let's focus on the

00:10:29,140 --> 00:10:33,970
elvish language for right now and let's

00:10:31,270 --> 00:10:37,740
make that a trait we can implement on

00:10:33,970 --> 00:10:40,420
our structs so I create my elvish traits

00:10:37,740 --> 00:10:43,420
then I implement it on both my elf

00:10:40,420 --> 00:10:46,900
struct and my half elf struct both of

00:10:43,420 --> 00:10:49,980
these races speak elvish now let's make

00:10:46,900 --> 00:10:52,330
a function separate from our traits for

00:10:49,980 --> 00:10:55,050
allowing our for allowing a character to

00:10:52,330 --> 00:10:57,760
take the action of speaking elvish and

00:10:55,050 --> 00:10:59,530
let's define a function called speak

00:10:57,760 --> 00:11:02,290
elvish and we say it will return a

00:10:59,530 --> 00:11:05,650
string and let's say it returns the

00:11:02,290 --> 00:11:07,030
string yes so right now this function

00:11:05,650 --> 00:11:09,160
can be called on any

00:11:07,030 --> 00:11:12,160
with no arguments so let's narrow it

00:11:09,160 --> 00:11:14,620
down a bit and let's say that we accept

00:11:12,160 --> 00:11:16,510
an argument called character but that

00:11:14,620 --> 00:11:19,720
character does not need to be a specific

00:11:16,510 --> 00:11:21,700
type it can be any kind of it can be any

00:11:19,720 --> 00:11:23,890
of our struct that we've already created

00:11:21,700 --> 00:11:27,160
so we have a generic type that we accept

00:11:23,890 --> 00:11:29,140
as an argument to this function but we

00:11:27,160 --> 00:11:33,520
will only accept those types that

00:11:29,140 --> 00:11:36,790
implement the elvish traits so if I run

00:11:33,520 --> 00:11:39,100
this method I have my elf and I run the

00:11:36,790 --> 00:11:42,760
method the method speak elvish passing

00:11:39,100 --> 00:11:45,730
it in my elf as an argument member my

00:11:42,760 --> 00:11:49,120
elf implements the elvish trait so it

00:11:45,730 --> 00:11:51,460
will return yes now let's see this on

00:11:49,120 --> 00:11:53,740
the half elf pretty much the same I

00:11:51,460 --> 00:11:56,050
create my half elf and then I call my

00:11:53,740 --> 00:11:59,260
speak elvish function and pass it in

00:11:56,050 --> 00:12:02,230
that half elf as a argument and because

00:11:59,260 --> 00:12:05,800
my half elf does implement elvish it

00:12:02,230 --> 00:12:08,140
returns yes now what if I pass it a

00:12:05,800 --> 00:12:11,980
different type of character let's say I

00:12:08,140 --> 00:12:14,470
create a half-orc and then I call my

00:12:11,980 --> 00:12:18,520
speak elvish function and I pass it in

00:12:14,470 --> 00:12:21,100
my half orc as an arguments well as we

00:12:18,520 --> 00:12:23,770
can see the elvish trait is decidedly

00:12:21,100 --> 00:12:26,830
not implemented for a half or CAF orcs

00:12:23,770 --> 00:12:29,680
do not speak elvish by default so in

00:12:26,830 --> 00:12:31,960
this case when I try to compile my code

00:12:29,680 --> 00:12:33,970
it will return an error on compile

00:12:31,960 --> 00:12:36,910
letting me know that the trait elvish is

00:12:33,970 --> 00:12:38,530
not implemented for a half-orc now one

00:12:36,910 --> 00:12:40,600
of the things I like about rust is that

00:12:38,530 --> 00:12:42,880
so many errors like this return on

00:12:40,600 --> 00:12:44,650
compile it doesn't give me a chance to

00:12:42,880 --> 00:12:47,950
try to run my code like this and

00:12:44,650 --> 00:12:50,020
possibly have a catastrophic error so

00:12:47,950 --> 00:12:52,060
the thing to remember about trait bounds

00:12:50,020 --> 00:12:54,400
is that they allow a function to only

00:12:52,060 --> 00:12:56,950
accepts types that implement a certain

00:12:54,400 --> 00:12:58,870
trait or that implement a certain

00:12:56,950 --> 00:13:02,710
combination of traits you can have

00:12:58,870 --> 00:13:06,610
multiple you can have multiple traits

00:13:02,710 --> 00:13:09,430
that you can I keep as criteria for a

00:13:06,610 --> 00:13:11,770
function accepting so let bring that's

00:13:09,430 --> 00:13:15,430
the end of traits 201 now let's move

00:13:11,770 --> 00:13:18,040
into traits 301 a trait objects and this

00:13:15,430 --> 00:13:20,470
is the really cool stuff so this took me

00:13:18,040 --> 00:13:23,990
the longest to get my head around

00:13:20,470 --> 00:13:27,110
now in traditional object-oriented

00:13:23,990 --> 00:13:28,639
languages I came to rust from Ruby those

00:13:27,110 --> 00:13:30,110
of us who came from object-oriented

00:13:28,639 --> 00:13:33,139
languages are probably familiar with

00:13:30,110 --> 00:13:35,930
this concept of an object an object

00:13:33,139 --> 00:13:39,350
holds both the data the characteristics

00:13:35,930 --> 00:13:41,660
of an object and the behavior the

00:13:39,350 --> 00:13:45,079
methods you can call and that object to

00:13:41,660 --> 00:13:48,709
manipulate and use it now rust does this

00:13:45,079 --> 00:13:51,199
a little differently in rust we usually

00:13:48,709 --> 00:13:54,620
keep the data about something in an enum

00:13:51,199 --> 00:13:57,560
or struct and we keep the behavior in a

00:13:54,620 --> 00:13:59,839
traits so the data and behavior are kept

00:13:57,560 --> 00:14:01,930
separately now that's one of the powers

00:13:59,839 --> 00:14:05,720
of rust we can kind of mix and match

00:14:01,930 --> 00:14:07,279
behavior as we need it in our code but

00:14:05,720 --> 00:14:11,089
trait objects are also a little

00:14:07,279 --> 00:14:13,790
different trait objects behave more like

00:14:11,089 --> 00:14:16,790
traditional objects in that they contain

00:14:13,790 --> 00:14:17,990
both data and behavior but it's still a

00:14:16,790 --> 00:14:21,980
little different from a traditional

00:14:17,990 --> 00:14:24,949
object the way a trait object works is

00:14:21,980 --> 00:14:28,189
entry object consists of a pointer to a

00:14:24,949 --> 00:14:30,680
value on the heap the advantage of

00:14:28,189 --> 00:14:32,720
storing the value itself the data on the

00:14:30,680 --> 00:14:34,790
heap while keeping a pointer to it in

00:14:32,720 --> 00:14:37,699
the trait object is that even if the

00:14:34,790 --> 00:14:39,980
size the value on the heap varies the

00:14:37,699 --> 00:14:42,379
size of that pointer will always be the

00:14:39,980 --> 00:14:44,439
same it makes it much more predictable

00:14:42,379 --> 00:14:48,139
for using this and dealing with memory

00:14:44,439 --> 00:14:50,329
so that's the data of a trait object the

00:14:48,139 --> 00:14:52,910
behavior of a trait object how you can

00:14:50,329 --> 00:14:54,009
use it and manipulate it comes from a

00:14:52,910 --> 00:14:57,439
traditional traits

00:14:54,009 --> 00:14:59,809
now although a trait object does point

00:14:57,439 --> 00:15:01,459
to data on the heap one thing is

00:14:59,809 --> 00:15:05,120
critical to understand is that you

00:15:01,459 --> 00:15:07,100
cannot add data to a trait object this

00:15:05,120 --> 00:15:08,990
is the key to understanding the purpose

00:15:07,100 --> 00:15:11,240
of trait objects and how to use them

00:15:08,990 --> 00:15:13,819
we're pointing to the data at one

00:15:11,240 --> 00:15:16,279
specific point in time now let's go

00:15:13,819 --> 00:15:19,100
ahead and make some so going back to our

00:15:16,279 --> 00:15:21,709
Dungeons & Dragons analogy if you are

00:15:19,100 --> 00:15:24,379
playing a magic class let's say a wizard

00:15:21,709 --> 00:15:26,449
they can cast spells and there are

00:15:24,379 --> 00:15:29,410
several different types of spells you

00:15:26,449 --> 00:15:31,779
can cast these include can trips

00:15:29,410 --> 00:15:33,290
transmutations enchantments and

00:15:31,779 --> 00:15:35,180
necromancy

00:15:33,290 --> 00:15:37,790
now there are more but let's focus on

00:15:35,180 --> 00:15:39,500
these four for now and let's create a

00:15:37,790 --> 00:15:42,410
camp trips truck to transportation

00:15:39,500 --> 00:15:45,290
struct and Chapman struct and necromancy

00:15:42,410 --> 00:15:47,480
structs that I can add behavior to now

00:15:45,290 --> 00:15:50,420
although these are different types of

00:15:47,480 --> 00:15:53,420
spells the thing they have in common is

00:15:50,420 --> 00:15:56,000
that they all need to be cast even if

00:15:53,420 --> 00:15:57,980
the specific way they are cast may

00:15:56,000 --> 00:16:01,130
differ from type of spell to type of

00:15:57,980 --> 00:16:04,370
spell so let's make a trait we're gonna

00:16:01,130 --> 00:16:07,190
call it our cast trait and let's add in

00:16:04,370 --> 00:16:10,100
this cast function and for now we're not

00:16:07,190 --> 00:16:11,959
going to define a default behavior we'll

00:16:10,100 --> 00:16:14,360
say any struct that implements this

00:16:11,959 --> 00:16:17,480
trait needs to define the behavior for

00:16:14,360 --> 00:16:20,240
the cast function so I implement this

00:16:17,480 --> 00:16:22,850
cast form I can't reach can't rip struct

00:16:20,240 --> 00:16:24,740
and I override the cast function with

00:16:22,850 --> 00:16:27,350
whatever specific details are needed

00:16:24,740 --> 00:16:30,110
specifically for implement a sting a

00:16:27,350 --> 00:16:31,880
can't trip spell and then I do the same

00:16:30,110 --> 00:16:34,160
with my transmutation struct if I'm

00:16:31,880 --> 00:16:36,769
running cast on it then define whatever

00:16:34,160 --> 00:16:38,959
you need to do to cast a transmutation

00:16:36,769 --> 00:16:41,360
that might be different from casting a

00:16:38,959 --> 00:16:43,610
can trip and then finally I do the same

00:16:41,360 --> 00:16:45,829
thing for enchantment I implement it in

00:16:43,610 --> 00:16:47,930
detail how enchantments are cast and

00:16:45,829 --> 00:16:50,690
then I do the same thing for the

00:16:47,930 --> 00:16:53,930
necromancy struct so now each of these

00:16:50,690 --> 00:16:56,540
types of spells can be cast but they are

00:16:53,930 --> 00:16:58,819
left to define anything specific about

00:16:56,540 --> 00:17:02,569
them that is required to cast that

00:16:58,819 --> 00:17:05,000
specific type of spell so it's common in

00:17:02,569 --> 00:17:08,059
D&D to acquire a whole bunch of spells

00:17:05,000 --> 00:17:10,400
as you level up and it's likely that my

00:17:08,059 --> 00:17:12,860
wizard or sorcerer will need a place to

00:17:10,400 --> 00:17:14,630
keep them to kind of store them as we

00:17:12,860 --> 00:17:18,169
continue on our journey throughout

00:17:14,630 --> 00:17:21,290
whatever magical world were exploring so

00:17:18,169 --> 00:17:24,409
where do we keep spells in a spell book

00:17:21,290 --> 00:17:26,780
of course where we can easily find them

00:17:24,409 --> 00:17:29,299
and work with them so let's represent

00:17:26,780 --> 00:17:32,299
this spell book as a struct let's create

00:17:29,299 --> 00:17:35,210
my spell book struct and then I'm going

00:17:32,299 --> 00:17:37,190
to define a spells field for my spell

00:17:35,210 --> 00:17:39,799
book structure so every spell book will

00:17:37,190 --> 00:17:42,890
have spells now the type of this field

00:17:39,799 --> 00:17:46,350
looks a little weird in the beginning so

00:17:42,890 --> 00:17:48,990
let's go ahead and break it down

00:17:46,350 --> 00:17:52,080
bells feel the spells field is a vector

00:17:48,990 --> 00:17:54,480
and vectors are ways to group objects of

00:17:52,080 --> 00:17:56,490
a certain type and the type we're

00:17:54,480 --> 00:18:01,650
grouping in our vector for spells is a

00:17:56,490 --> 00:18:04,200
box and a box and rust is a pointer to a

00:18:01,650 --> 00:18:07,950
value on the heap does this look

00:18:04,200 --> 00:18:10,230
familiar the beautiful thing about about

00:18:07,950 --> 00:18:11,910
using a box that contains that that

00:18:10,230 --> 00:18:14,520
pointer to the value on the heap is

00:18:11,910 --> 00:18:16,890
again the boxes size is consistent in

00:18:14,520 --> 00:18:20,610
memory no matter what the size of the

00:18:16,890 --> 00:18:24,000
value on the heap is now we also four

00:18:20,610 --> 00:18:26,940
boxes we usually only contain values of

00:18:24,000 --> 00:18:29,220
a certain type and in our case we say

00:18:26,940 --> 00:18:32,520
that we can contain any type that

00:18:29,220 --> 00:18:34,830
implements the caste trait it doesn't

00:18:32,520 --> 00:18:36,900
matter what type it is as long as it

00:18:34,830 --> 00:18:39,510
implements that particular trait we can

00:18:36,900 --> 00:18:42,480
work with it if it does so again just to

00:18:39,510 --> 00:18:46,890
review the spells field is a vector that

00:18:42,480 --> 00:18:49,380
vector contains boxes in those box that

00:18:46,890 --> 00:18:53,130
bought box those boxes point two values

00:18:49,380 --> 00:18:55,020
that implement the cast traits so let's

00:18:53,130 --> 00:18:57,179
take this a little further and we're

00:18:55,020 --> 00:18:59,250
gonna veer a bit from the Dungeons and

00:18:57,179 --> 00:19:01,169
Dragons cannon here and let's say we

00:18:59,250 --> 00:19:03,570
want to cast all the spells in our spell

00:19:01,169 --> 00:19:06,030
book one after the other we want to have

00:19:03,570 --> 00:19:09,299
a rapid fire way to fire off all these

00:19:06,030 --> 00:19:12,090
spells as a collection well we can do

00:19:09,299 --> 00:19:14,370
this in rust by defining some behavior

00:19:12,090 --> 00:19:16,559
for our spell book structs through this

00:19:14,370 --> 00:19:18,990
implementation block and what we're

00:19:16,559 --> 00:19:22,080
going to do is let's implement a

00:19:18,990 --> 00:19:25,470
function called run and this function

00:19:22,080 --> 00:19:28,799
will take every spell in a spell book

00:19:25,470 --> 00:19:31,380
and iterate over it and cast though each

00:19:28,799 --> 00:19:31,890
individual spell one right after the

00:19:31,380 --> 00:19:34,710
other

00:19:31,890 --> 00:19:36,929
remember the types of spells themselves

00:19:34,710 --> 00:19:38,940
will define how they are cast but the

00:19:36,929 --> 00:19:41,039
thing they all have in common is that

00:19:38,940 --> 00:19:44,340
they implement this cast trait and

00:19:41,039 --> 00:19:46,919
define that cast function so let's look

00:19:44,340 --> 00:19:49,140
at a visual representation of this we've

00:19:46,919 --> 00:19:51,690
got our wizard or sorcerer or whatever

00:19:49,140 --> 00:19:54,600
magical class you prefer and he's going

00:19:51,690 --> 00:19:56,970
to call run on his spell book and that's

00:19:54,600 --> 00:19:59,290
gonna cast every spell in that spell

00:19:56,970 --> 00:20:01,840
book no matter what type it is

00:19:59,290 --> 00:20:05,470
right after the other so we've seen a

00:20:01,840 --> 00:20:07,630
visual now let's see this in code let's

00:20:05,470 --> 00:20:10,270
create a new instance of our spellbook

00:20:07,630 --> 00:20:12,550
struct and let's define the spells

00:20:10,270 --> 00:20:16,120
remember the spells field is a vector

00:20:12,550 --> 00:20:18,760
and that vector contains boxes that

00:20:16,120 --> 00:20:20,590
contain different types of spells again

00:20:18,760 --> 00:20:22,390
it doesn't matter what type of spell it

00:20:20,590 --> 00:20:26,530
is as long as it implements that

00:20:22,390 --> 00:20:28,300
particular cast trait so when I want to

00:20:26,530 --> 00:20:30,400
cast all of these one after the other I

00:20:28,300 --> 00:20:32,080
can call the run method on my instance

00:20:30,400 --> 00:20:34,330
of the spell book struct and they will

00:20:32,080 --> 00:20:36,760
all be cast from this one function in

00:20:34,330 --> 00:20:39,430
whatever way is required for that type

00:20:36,760 --> 00:20:41,770
of spell to be cast so what this

00:20:39,430 --> 00:20:44,650
highlights is that trait objects are

00:20:41,770 --> 00:20:46,660
great for heterogeneous collections

00:20:44,650 --> 00:20:48,880
where we want to be able to have objects

00:20:46,660 --> 00:20:52,840
of different types stored in the same

00:20:48,880 --> 00:20:55,080
place it doesn't matter what type those

00:20:52,840 --> 00:20:58,060
objects are as long as they all

00:20:55,080 --> 00:21:01,150
implement a certain trait this gives you

00:20:58,060 --> 00:21:03,100
a lot of flexibility in your rust code

00:21:01,150 --> 00:21:03,460
and allows you to be really dynamic with

00:21:03,100 --> 00:21:06,970
it

00:21:03,460 --> 00:21:09,970
so that's Russ 301 defining and working

00:21:06,970 --> 00:21:12,040
with trait objects and as we wrap up

00:21:09,970 --> 00:21:14,980
there are a few things I want you to

00:21:12,040 --> 00:21:18,220
take with you and the first is that yes

00:21:14,980 --> 00:21:21,070
traits are hard at first but they are

00:21:18,220 --> 00:21:23,830
massively powerful and awesome once you

00:21:21,070 --> 00:21:25,420
get your head around them now if you'd

00:21:23,830 --> 00:21:28,030
like to find out more about traits and I

00:21:25,420 --> 00:21:29,710
hope you do I use the Russ programming

00:21:28,030 --> 00:21:31,480
language book the second edition as my

00:21:29,710 --> 00:21:33,910
primary source for this project

00:21:31,480 --> 00:21:35,320
now there are a lot of other really cool

00:21:33,910 --> 00:21:37,240
things you can do with traits that I

00:21:35,320 --> 00:21:39,580
didn't include in this talk for the sake

00:21:37,240 --> 00:21:42,070
of time I highly encourage you to check

00:21:39,580 --> 00:21:45,670
out in particular chapters 10.2 and

00:21:42,070 --> 00:21:47,740
chapter 7 15.2 to see all the really

00:21:45,670 --> 00:21:49,960
cool things you can do with traits and

00:21:47,740 --> 00:21:54,790
prevent any pitfalls that might come

00:21:49,960 --> 00:21:56,470
from using traits so remember if I could

00:21:54,790 --> 00:21:58,590
learn to harness the power of traits

00:21:56,470 --> 00:22:00,580
then so can you

00:21:58,590 --> 00:22:02,029
thank you

00:22:00,580 --> 00:22:04,090
[Applause]

00:22:02,029 --> 00:22:04,090

YouTube URL: https://www.youtube.com/watch?v=grU-4u0Okto


