Title: Lightning Talk - Quantum BogoSort â€” Jason Orendorff
Publication date: 2018-01-06
Playlist: Rust Belt Rust 2017
Description: 
	
Captions: 
	00:00:04,000 --> 00:00:08,120
so I wrote a scheme and Russ I've never

00:00:06,770 --> 00:00:09,410
done a lightning talk with live coding

00:00:08,120 --> 00:00:11,240
in it before so I'm just gonna dive

00:00:09,410 --> 00:00:12,290
right into it this is this is scheme

00:00:11,240 --> 00:00:15,889
it's a language and has lots of

00:00:12,290 --> 00:00:18,470
parentheses in it and I have this file

00:00:15,889 --> 00:00:21,470
Amba dot scheme which is like ten lines

00:00:18,470 --> 00:00:24,560
of scheme and you call this function amp

00:00:21,470 --> 00:00:27,160
and it's cut off so you can't see what

00:00:24,560 --> 00:00:35,320
that is doing

00:00:27,160 --> 00:00:40,460
oops no there we go yeah so you call em

00:00:35,320 --> 00:00:41,600
and give it some arguments and as you

00:00:40,460 --> 00:00:44,480
can see it just returns the first

00:00:41,600 --> 00:00:47,030
argument right so if I define a variable

00:00:44,480 --> 00:00:48,800
and call it with a bunch of arguments

00:00:47,030 --> 00:00:50,960
then the value of the variable is

00:00:48,800 --> 00:00:52,339
whatever and then if there's another

00:00:50,960 --> 00:00:54,530
there's another function in this in this

00:00:52,339 --> 00:00:58,850
library called require so if we require

00:00:54,530 --> 00:01:07,400
X to be greater than 2 then the value of

00:00:58,850 --> 00:01:08,479
x is 3 got it ok what yeah okay so I do

00:01:07,400 --> 00:01:10,280
one more example just to like make sure

00:01:08,479 --> 00:01:12,979
everybody's got this concept right if I

00:01:10,280 --> 00:01:14,450
define a function called digit like you

00:01:12,979 --> 00:01:20,149
call it with no arguments and it returns

00:01:14,450 --> 00:01:22,430
a digit which is like this alright then

00:01:20,149 --> 00:01:26,719
I could say all right make exit digit

00:01:22,430 --> 00:01:29,149
and make Y be a digit and then we've got

00:01:26,719 --> 00:01:33,200
these two numbers right and then if I

00:01:29,149 --> 00:01:38,210
require that the product of x and y be

00:01:33,200 --> 00:01:41,420
equal to like 24 then that happens right

00:01:38,210 --> 00:01:45,590
and then if I require X to be greater

00:01:41,420 --> 00:01:52,520
than Y then that happens right you get

00:01:45,590 --> 00:01:53,899
the idea okay cool so so to explain how

00:01:52,520 --> 00:01:57,409
this works I need to talk a little bit

00:01:53,899 --> 00:01:58,880
about quantum bogus or it which is this

00:01:57,409 --> 00:02:01,490
algorithm it's not an algorithm you

00:01:58,880 --> 00:02:02,899
would run on a quantum computer instead

00:02:01,490 --> 00:02:04,939
it like uses the many-worlds

00:02:02,899 --> 00:02:07,039
interpretation of quantum mechanics to

00:02:04,939 --> 00:02:08,990
like make a better sorting algorithm one

00:02:07,039 --> 00:02:10,369
you take the list of values that you

00:02:08,990 --> 00:02:13,190
want to sort and you just like shuffle

00:02:10,369 --> 00:02:15,950
them randomly which divides the universe

00:02:13,190 --> 00:02:17,569
into of in factorial universes that's

00:02:15,950 --> 00:02:19,549
just a thing to happen

00:02:17,569 --> 00:02:27,439
and then if the list is not sorted you

00:02:19,549 --> 00:02:33,650
destroy the universe and then if you

00:02:27,439 --> 00:02:35,060
survive then your list is sorted okay so

00:02:33,650 --> 00:02:36,769
so the other thing you need to

00:02:35,060 --> 00:02:38,209
understand is continuations I think I

00:02:36,769 --> 00:02:44,180
have like two minutes left the

00:02:38,209 --> 00:02:46,310
continuation is it's so scheme alright

00:02:44,180 --> 00:02:47,900
so when you capture the continuation of

00:02:46,310 --> 00:02:49,609
your program it's like taking a snapshot

00:02:47,900 --> 00:02:51,500
of your stack alright so you think of

00:02:49,609 --> 00:02:54,470
the stack is the call chain like how did

00:02:51,500 --> 00:02:56,810
we get here but what the stack really is

00:02:54,470 --> 00:02:59,180
is it's the future of your program it's

00:02:56,810 --> 00:03:01,220
what happens after the current function

00:02:59,180 --> 00:03:02,959
returns where is it going next right and

00:03:01,220 --> 00:03:05,090
then after that and after that the

00:03:02,959 --> 00:03:06,980
continuation of your program right so

00:03:05,090 --> 00:03:08,780
the stack or the future that's what a

00:03:06,980 --> 00:03:10,489
continuation isn't scheme and scheme

00:03:08,780 --> 00:03:13,730
just has a just a built-in function that

00:03:10,489 --> 00:03:16,840
grabs that um and it's useful for things

00:03:13,730 --> 00:03:19,340
like breaking out of a loop or

00:03:16,840 --> 00:03:21,129
implementing exceptions because in you

00:03:19,340 --> 00:03:24,139
know in a language it doesn't have

00:03:21,129 --> 00:03:26,180
syntax or like keywords right and that's

00:03:24,139 --> 00:03:27,379
a that's an you have to do that somehow

00:03:26,180 --> 00:03:29,239
and you they do it they can you can do

00:03:27,379 --> 00:03:30,650
it with continuations this is too

00:03:29,239 --> 00:03:32,680
powerful to actually be useful in

00:03:30,650 --> 00:03:35,989
practice because it's just like too

00:03:32,680 --> 00:03:37,819
mind-bending to use correctly but it

00:03:35,989 --> 00:03:40,430
coupled with the ability to destroy the

00:03:37,819 --> 00:03:41,870
universe it is a lot of fun so now I

00:03:40,430 --> 00:03:44,840
have to explain in one minute how this

00:03:41,870 --> 00:03:48,409
actually works without speaker nuts so

00:03:44,840 --> 00:03:50,449
basically the amp function splits the

00:03:48,409 --> 00:03:52,099
universe into many universes it creates

00:03:50,449 --> 00:03:53,720
one universe for each argument that you

00:03:52,099 --> 00:03:55,819
pass to it and then the require function

00:03:53,720 --> 00:03:57,919
it just takes a boolean right any

00:03:55,819 --> 00:04:00,470
boolean value right and if that boolean

00:03:57,919 --> 00:04:04,489
is false destroys the universe and it

00:04:00,470 --> 00:04:07,359
does that right by invoking a previously

00:04:04,489 --> 00:04:10,819
captured continuation right which which

00:04:07,359 --> 00:04:12,169
which basically just like clobbers the

00:04:10,819 --> 00:04:14,150
current state of the program and

00:04:12,169 --> 00:04:15,409
replaces it with the previously captured

00:04:14,150 --> 00:04:17,209
continue if you like to jump back in

00:04:15,409 --> 00:04:21,460
time and you redo it and then the rest

00:04:17,209 --> 00:04:25,039
of it is just this like crazily hairy

00:04:21,460 --> 00:04:27,650
custom hand coded repple that uses

00:04:25,039 --> 00:04:28,590
stupid vt100 escape sequences to like go

00:04:27,650 --> 00:04:35,310
back and erase every

00:04:28,590 --> 00:04:37,320
you didn't mean time so if you have a

00:04:35,310 --> 00:04:39,510
terribly important and practical use for

00:04:37,320 --> 00:04:41,130
this please be careful because if

00:04:39,510 --> 00:04:42,390
there's a bug and there are actually no

00:04:41,130 --> 00:04:44,430
solutions to your problem you will

00:04:42,390 --> 00:04:48,230
destroy all the universes we don't want

00:04:44,430 --> 00:04:51,180
that but here's where you can find the

00:04:48,230 --> 00:04:52,710
source code and if you wanna know more

00:04:51,180 --> 00:04:54,960
about am but or more about schema

00:04:52,710 --> 00:04:57,180
general this is the book to grab it gets

00:04:54,960 --> 00:04:58,980
like kind of philosophical is nice that

00:04:57,180 --> 00:05:00,600
way and it's got a lot of beautiful

00:04:58,980 --> 00:05:03,380
stuff in it that I'd had forgotten was

00:05:00,600 --> 00:05:03,380

YouTube URL: https://www.youtube.com/watch?v=iOJD7nd7cyY


