Title: Core Team Keynote — Aaron Turon, Carol Nichols, Niko Matsakis
Publication date: 2018-01-06
Playlist: Rust Belt Rust 2017
Description: 
	Aaron, Carol, and Niko will deliver an update on the state of all things Rust. You don’t want to miss it!
Captions: 
	00:00:03,550 --> 00:00:09,100
so I want to start off just by asking

00:00:06,069 --> 00:00:13,350
how many people are here for the first

00:00:09,100 --> 00:00:15,000
time at any rest conference holy cow

00:00:13,350 --> 00:00:18,220
that's awesome

00:00:15,000 --> 00:00:20,440
welcome so we're gonna be talking a

00:00:18,220 --> 00:00:22,900
bunch about community throughout but I

00:00:20,440 --> 00:00:26,020
think for me the greatest source of joy

00:00:22,900 --> 00:00:28,120
in rust is its community so I'm really

00:00:26,020 --> 00:00:29,590
glad you're here and I hope you know you

00:00:28,120 --> 00:00:31,900
get to meet some of the existing Russ

00:00:29,590 --> 00:00:35,860
community and sort of feed off of the

00:00:31,900 --> 00:00:38,350
the joy and excitement that is rust okay

00:00:35,860 --> 00:00:43,000
so that said let's get started on the

00:00:38,350 --> 00:00:46,060
keynote so the this keynote is going to

00:00:43,000 --> 00:00:51,520
sort of give a view of where we are in

00:00:46,060 --> 00:00:54,000
the 2017 cycle of rust development so as

00:00:51,520 --> 00:00:56,860
you may or may not know the way that

00:00:54,000 --> 00:00:59,110
sort of rust development is set out

00:00:56,860 --> 00:01:03,309
these days is at the beginning of each

00:00:59,110 --> 00:01:05,199
year we put together a road map of what

00:01:03,309 --> 00:01:07,390
we hope to accomplish that year that's

00:01:05,199 --> 00:01:09,789
done through a community driven RFC

00:01:07,390 --> 00:01:11,799
process we all talked about that roadmap

00:01:09,789 --> 00:01:14,560
for a month or so before you know

00:01:11,799 --> 00:01:16,209
finalizing it and then that serves as a

00:01:14,560 --> 00:01:18,909
sort of mission for the year that we

00:01:16,209 --> 00:01:24,789
continue to check up on as time goes by

00:01:18,909 --> 00:01:28,029
so the mission we set out for 2017 has

00:01:24,789 --> 00:01:31,329
it's sort of most concise summary making

00:01:28,029 --> 00:01:33,609
productivity a core value of rust so

00:01:31,329 --> 00:01:36,009
that is you know as you may know rust

00:01:33,609 --> 00:01:39,099
gives you performance it gives you

00:01:36,009 --> 00:01:41,079
reliability but if it has one weakness

00:01:39,099 --> 00:01:44,380
it's probably in the productivity front

00:01:41,079 --> 00:01:46,719
how easy it is to learn how easy it is

00:01:44,380 --> 00:01:49,419
to find quality libraries that do it you

00:01:46,719 --> 00:01:52,840
know what you need and so on so we laid

00:01:49,419 --> 00:01:55,929
out a whole bunch of you know sort of

00:01:52,840 --> 00:01:57,729
sub items under this heading for how to

00:01:55,929 --> 00:01:59,109
make rust a more productive language

00:01:57,729 --> 00:02:00,999
from from a bunch of different angles

00:01:59,109 --> 00:02:02,560
and I'm not going to go through all of

00:02:00,999 --> 00:02:04,989
these right now the rest of the talk is

00:02:02,560 --> 00:02:06,759
is going to basically delve into each of

00:02:04,989 --> 00:02:14,040
these angles and where we are what we're

00:02:06,759 --> 00:02:16,780
doing so that said we are you know

00:02:14,040 --> 00:02:24,490
several months

00:02:16,780 --> 00:02:26,950
to the year and so you know those of you

00:02:24,490 --> 00:02:28,030
who have been following you know might

00:02:26,950 --> 00:02:29,950
like to know how are we actually

00:02:28,030 --> 00:02:31,300
progressing toward these this these

00:02:29,950 --> 00:02:35,290
goals and what is how is the sort of

00:02:31,300 --> 00:02:37,930
flow of the Year gone overall so I wanna

00:02:35,290 --> 00:02:40,270
before we get into the specifics I want

00:02:37,930 --> 00:02:43,090
to give you another piece of the overall

00:02:40,270 --> 00:02:43,480
structure of how we've approached the

00:02:43,090 --> 00:02:47,350
year

00:02:43,480 --> 00:02:50,350
so in particular we a lot of the things

00:02:47,350 --> 00:02:53,800
we wanted to do this year involved deep

00:02:50,350 --> 00:02:56,050
design word so we wanted to find ways to

00:02:53,800 --> 00:02:57,550
make the language easier to learn by

00:02:56,050 --> 00:02:59,680
actually changing the language and

00:02:57,550 --> 00:03:01,750
that's very hard and it requires chain

00:02:59,680 --> 00:03:03,220
and change to existing things is

00:03:01,750 --> 00:03:06,310
something that is often very contentious

00:03:03,220 --> 00:03:08,200
and so we had a long you know design

00:03:06,310 --> 00:03:12,970
focused period on at least some parts of

00:03:08,200 --> 00:03:15,459
the roadmap but we're now in what we

00:03:12,970 --> 00:03:18,280
were calling the imple period which is

00:03:15,459 --> 00:03:20,110
you know basically no new design we're

00:03:18,280 --> 00:03:21,160
focused on just executing on our plans

00:03:20,110 --> 00:03:26,230
and we're about a third of the way

00:03:21,160 --> 00:03:29,920
through the simple period so let's see

00:03:26,230 --> 00:03:32,049
so I see I should have done these slides

00:03:29,920 --> 00:03:33,519
there okay so the idea is yet throughout

00:03:32,049 --> 00:03:35,470
the year we've been doing sort of a mix

00:03:33,519 --> 00:03:37,750
of design and implementation now we're

00:03:35,470 --> 00:03:39,489
totally implementation focus so one of

00:03:37,750 --> 00:03:42,640
the really cool things about how we've

00:03:39,489 --> 00:03:45,970
set up this imple period is it's been

00:03:42,640 --> 00:03:48,700
very geared toward sort of community

00:03:45,970 --> 00:03:51,700
participation at all levels so once we

00:03:48,700 --> 00:03:54,040
had a clear picture of you know what we

00:03:51,700 --> 00:03:57,160
were trying to do we organized that into

00:03:54,040 --> 00:04:00,220
35 working groups and this seems like

00:03:57,160 --> 00:04:02,590
this is an incredible number of groups

00:04:00,220 --> 00:04:05,140
doing things but actually relatively few

00:04:02,590 --> 00:04:07,870
of these are led by the same person so

00:04:05,140 --> 00:04:09,730
this is just gives you a sense of how

00:04:07,870 --> 00:04:11,620
much activity there is in the RUS

00:04:09,730 --> 00:04:15,070
community actually attacking this

00:04:11,620 --> 00:04:17,079
roadmap so each of these working groups

00:04:15,070 --> 00:04:21,640
you know has a designated leader it has

00:04:17,079 --> 00:04:24,039
a dedicated chat channel on on Gitter

00:04:21,640 --> 00:04:27,010
and the leaders have put a lot of work

00:04:24,039 --> 00:04:29,710
into making these groups accessible so

00:04:27,010 --> 00:04:30,430
even if you are brand-new to rust

00:04:29,710 --> 00:04:32,620
the

00:04:30,430 --> 00:04:36,370
there's a place for you here you have

00:04:32,620 --> 00:04:38,140
skills that rust needs and so I really

00:04:36,370 --> 00:04:40,000
encourage you to get involved in the

00:04:38,140 --> 00:04:41,920
info period it's been a lot of fun and

00:04:40,000 --> 00:04:46,450
will will again be seeing some of the

00:04:41,920 --> 00:04:48,930
results of it later in the talk so one

00:04:46,450 --> 00:04:52,360
other thing about sort of the overall

00:04:48,930 --> 00:04:54,850
structure of the year and our plans so

00:04:52,360 --> 00:04:58,930
you may have heard about this idea of

00:04:54,850 --> 00:05:02,200
epochs and I just want to sort of give

00:04:58,930 --> 00:05:05,530
the core teams perspective on on what

00:05:02,200 --> 00:05:07,030
epochs are so let me let me start by

00:05:05,530 --> 00:05:09,910
saying you know you probably know that

00:05:07,030 --> 00:05:12,370
rust has a rapid release cycle so every

00:05:09,910 --> 00:05:15,790
six weeks we put out a new version of

00:05:12,370 --> 00:05:18,700
rust which is backwards compatible with

00:05:15,790 --> 00:05:20,020
all existing versions of rust and I

00:05:18,700 --> 00:05:21,460
think this release cycle has served us

00:05:20,020 --> 00:05:23,410
really well it means we're sort of

00:05:21,460 --> 00:05:26,020
always incrementally improving the

00:05:23,410 --> 00:05:30,910
language we don't have these big jumps

00:05:26,020 --> 00:05:32,860
or high-stakes releases but there is

00:05:30,910 --> 00:05:35,470
there are some downsides to that

00:05:32,860 --> 00:05:37,870
approach because if you're not following

00:05:35,470 --> 00:05:40,810
rust super closely it can be hard to

00:05:37,870 --> 00:05:43,000
understand what this evolution is about

00:05:40,810 --> 00:05:46,060
right you're seeing all these like from

00:05:43,000 --> 00:05:47,800
it from a distance you see okay ten new

00:05:46,060 --> 00:05:49,180
versions of rust have happened like how

00:05:47,800 --> 00:05:52,870
do I understand that what does that mean

00:05:49,180 --> 00:05:55,000
to me what version should I be using so

00:05:52,870 --> 00:05:59,500
what we're trying to do with epochs is

00:05:55,000 --> 00:06:03,040
to sort of layer a story on top of those

00:05:59,500 --> 00:06:06,340
rapid releases and so so that every two

00:06:03,040 --> 00:06:09,130
to three years we have epoch release

00:06:06,340 --> 00:06:12,030
which basically says okay we've done a

00:06:09,130 --> 00:06:14,290
ton of work and now we're we're sort of

00:06:12,030 --> 00:06:15,880
choosing a synchronization point where

00:06:14,290 --> 00:06:18,310
everything's going to come together all

00:06:15,880 --> 00:06:19,990
the documentation is going to reflect

00:06:18,310 --> 00:06:21,250
all of the changes we've been making all

00:06:19,990 --> 00:06:24,070
of the tooling is going to work in a

00:06:21,250 --> 00:06:27,190
high-quality way and here is the story

00:06:24,070 --> 00:06:30,010
of what this epoch is about and so it's

00:06:27,190 --> 00:06:31,930
sort of a periodic way of actually

00:06:30,010 --> 00:06:38,050
putting together a polished coherent

00:06:31,930 --> 00:06:40,690
story for rusts evolution so our plan

00:06:38,050 --> 00:06:43,060
you know this isn't completely set in

00:06:40,690 --> 00:06:43,970
stone but we're we're imagining next

00:06:43,060 --> 00:06:48,980
year

00:06:43,970 --> 00:06:51,080
releasing rust model 2019 probably

00:06:48,980 --> 00:06:52,220
toward the end of the year and you know

00:06:51,080 --> 00:06:54,080
if you think about all these changes

00:06:52,220 --> 00:06:56,420
we'll be talking about to the language

00:06:54,080 --> 00:06:58,640
and so on this is an opportunity to put

00:06:56,420 --> 00:07:00,920
all that together and again synchronize

00:06:58,640 --> 00:07:05,720
it make it coherent and ship it to the

00:07:00,920 --> 00:07:08,080
world and you know as part of this we we

00:07:05,720 --> 00:07:12,380
will also have the ability to make some

00:07:08,080 --> 00:07:15,470
some tweaks that you know involve

00:07:12,380 --> 00:07:16,790
changes to existing code so like if we

00:07:15,470 --> 00:07:18,560
want to introduce a new key word you

00:07:16,790 --> 00:07:21,740
might have been using that key word as

00:07:18,560 --> 00:07:23,240
an identifier in previous code but we

00:07:21,740 --> 00:07:26,750
are very committed to making the upgrade

00:07:23,240 --> 00:07:28,640
process as smooth as possible so this is

00:07:26,750 --> 00:07:30,710
an entirely opt-in thing and it's done

00:07:28,640 --> 00:07:33,590
crate by crate so it's not going to be

00:07:30,710 --> 00:07:36,200
like you know a Python 2 versus Python 3

00:07:33,590 --> 00:07:38,350
style split and we put a lot of thought

00:07:36,200 --> 00:07:41,990
into how to make this as smooth as our

00:07:38,350 --> 00:07:43,910
incremental really cycle has been okay

00:07:41,990 --> 00:07:44,960
so with that I'm gonna hand it over to

00:07:43,910 --> 00:07:50,450
Nico just start talking about the

00:07:44,960 --> 00:07:54,500
specifics hi everybody

00:07:50,450 --> 00:07:56,390
so I want to talk about a lot of the

00:07:54,500 --> 00:07:59,030
language changes that we have been

00:07:56,390 --> 00:08:00,650
making or planning to make and the work

00:07:59,030 --> 00:08:02,270
we've been doing in the compiler to

00:08:00,650 --> 00:08:04,760
support those and also just to make the

00:08:02,270 --> 00:08:07,160
compiler nicer to use and one of the

00:08:04,760 --> 00:08:09,500
first and if you go back to our roadmap

00:08:07,160 --> 00:08:11,840
goals the one we're trying to attack

00:08:09,500 --> 00:08:15,620
here primarily is lowering rusts

00:08:11,840 --> 00:08:18,530
learning curve but the way we decided to

00:08:15,620 --> 00:08:20,870
do that was not by we didn't want to do

00:08:18,530 --> 00:08:22,550
things that would solely be targeted at

00:08:20,870 --> 00:08:24,830
new users because sometimes there's this

00:08:22,550 --> 00:08:26,150
this tendency to think that there's kind

00:08:24,830 --> 00:08:28,910
of a trade-off where you can make the

00:08:26,150 --> 00:08:31,100
language easy for new users or you can

00:08:28,910 --> 00:08:32,870
make it kind of good for experienced

00:08:31,100 --> 00:08:34,430
users who know what they're doing but if

00:08:32,870 --> 00:08:35,810
you increase one group you hurt the

00:08:34,430 --> 00:08:37,400
other but what we noticed is in fact

00:08:35,810 --> 00:08:38,990
that the things that new users hit and

00:08:37,400 --> 00:08:40,370
find hardest to learn are also the

00:08:38,990 --> 00:08:42,320
things that experienced users are

00:08:40,370 --> 00:08:43,550
hitting they just learned how to deal

00:08:42,320 --> 00:08:46,220
with it and they can solve it but it's

00:08:43,550 --> 00:08:47,630
still the same annoyances arising in

00:08:46,220 --> 00:08:50,240
both cases right and so what we're

00:08:47,630 --> 00:08:51,590
shooting for is this basically changes

00:08:50,240 --> 00:08:53,690
that improve the ergonomics of the

00:08:51,590 --> 00:08:55,100
language that make it as an experienced

00:08:53,690 --> 00:08:56,450
user just reduce the friction you

00:08:55,100 --> 00:08:56,920
experience the number of times you have

00:08:56,450 --> 00:08:58,540
to hit

00:08:56,920 --> 00:09:00,790
compiled because of small nitpicky

00:08:58,540 --> 00:09:02,920
errors or other things the chance that

00:09:00,790 --> 00:09:04,120
the code you write will work good the

00:09:02,920 --> 00:09:07,360
first time you write it will compile

00:09:04,120 --> 00:09:08,740
well and for but that's that same thing

00:09:07,360 --> 00:09:11,769
same changes really like

00:09:08,740 --> 00:09:13,240
disproportionately benefit new users as

00:09:11,769 --> 00:09:15,430
well so let me walk you through some of

00:09:13,240 --> 00:09:17,680
them and we're starting to see them land

00:09:15,430 --> 00:09:20,680
on nightly now so when we first gave

00:09:17,680 --> 00:09:22,930
this talk or a version of this talk this

00:09:20,680 --> 00:09:24,430
was all these slides were saying well we

00:09:22,930 --> 00:09:26,260
kind of have a design you can give input

00:09:24,430 --> 00:09:28,630
on the design but but now we get to see

00:09:26,260 --> 00:09:30,910
some progress right so so one example in

00:09:28,630 --> 00:09:32,290
working with matches so matches are one

00:09:30,910 --> 00:09:34,810
of the best features of rust you can

00:09:32,290 --> 00:09:36,130
deconstruct enums and find it and make

00:09:34,810 --> 00:09:37,959
sure you handle all the cases you need

00:09:36,130 --> 00:09:40,389
to handle but if you're working with

00:09:37,959 --> 00:09:42,940
matches over borrowed data there's a lot

00:09:40,389 --> 00:09:44,769
of kind of small changes you have to

00:09:42,940 --> 00:09:46,290
make to make everything line up so for

00:09:44,769 --> 00:09:49,930
example if I match on a borrowed

00:09:46,290 --> 00:09:52,389
optional string I have to put a star in

00:09:49,930 --> 00:09:54,250
front or that's one way to do it anyway

00:09:52,389 --> 00:09:55,690
so that I'm now kind of dereferencing

00:09:54,250 --> 00:09:57,550
the reference and I'm matching on an

00:09:55,690 --> 00:09:59,560
option of string and then I put a ref to

00:09:57,550 --> 00:10:02,199
say oh and I'm borrowing the string

00:09:59,560 --> 00:10:03,579
outside of the option and this is

00:10:02,199 --> 00:10:05,560
something a lot of people especially in

00:10:03,579 --> 00:10:07,860
the beginning but even later on find

00:10:05,560 --> 00:10:10,300
difficult to get right and so what we've

00:10:07,860 --> 00:10:12,190
instead set up now is the system called

00:10:10,300 --> 00:10:14,260
default binding modes where when you're

00:10:12,190 --> 00:10:16,000
matching on a reference you don't have

00:10:14,260 --> 00:10:17,500
to write the star we'll just go through

00:10:16,000 --> 00:10:18,730
the reference for you and when we go

00:10:17,500 --> 00:10:20,380
through a reference we know that you

00:10:18,730 --> 00:10:22,120
must be borrowing the content inside

00:10:20,380 --> 00:10:22,750
right so you get to write this snippet

00:10:22,120 --> 00:10:25,000
on the right

00:10:22,750 --> 00:10:26,680
this lets you think more about the types

00:10:25,000 --> 00:10:27,970
you just sort of know what the main

00:10:26,680 --> 00:10:29,680
types you have and that it's borrowed

00:10:27,970 --> 00:10:31,120
and less about exactly how is the

00:10:29,680 --> 00:10:33,310
compiler reasoning at this particular

00:10:31,120 --> 00:10:35,019
place and makes the overall experience

00:10:33,310 --> 00:10:37,660
smoother and this is actually available

00:10:35,019 --> 00:10:39,279
on nightly now if you go and enable you

00:10:37,660 --> 00:10:41,290
have to enable the feature gate but I've

00:10:39,279 --> 00:10:43,480
been using it it's very cool

00:10:41,290 --> 00:10:45,240
that's thanks to a contributor by the

00:10:43,480 --> 00:10:50,500
way to be a shot Dorf who implemented it

00:10:45,240 --> 00:10:52,800
and another similar version or similar

00:10:50,500 --> 00:10:55,600
in some sense in the sense of reducing

00:10:52,800 --> 00:10:58,060
repetitive content is we've been working

00:10:55,600 --> 00:10:59,079
on this notion of implied bounds so one

00:10:58,060 --> 00:11:00,760
thing you may have noticed if you've

00:10:59,079 --> 00:11:02,920
implemented generic types in rust is

00:11:00,760 --> 00:11:05,230
that you often have a kind of core set

00:11:02,920 --> 00:11:06,790
of bounds that apply to your generic

00:11:05,230 --> 00:11:09,040
type so you might say I'm defining a set

00:11:06,790 --> 00:11:10,490
and the things in the set can be any

00:11:09,040 --> 00:11:12,770
type T but they have to be

00:11:10,490 --> 00:11:14,540
a double and hashable like a hash set

00:11:12,770 --> 00:11:16,370
and you put these bounds maybe on your

00:11:14,540 --> 00:11:18,529
type and then you have to repeat them

00:11:16,370 --> 00:11:20,420
everywhere else which is kind of

00:11:18,529 --> 00:11:21,860
annoying right so I usually just go and

00:11:20,420 --> 00:11:23,779
literally copy and paste it from place

00:11:21,860 --> 00:11:25,279
to place and then make sure I format it

00:11:23,779 --> 00:11:27,950
exactly the same so I can easily do that

00:11:25,279 --> 00:11:29,360
again when it changes so we've been

00:11:27,950 --> 00:11:31,459
working on improving the compilers

00:11:29,360 --> 00:11:33,140
reasoning system so that you just say

00:11:31,459 --> 00:11:34,640
the bounds once when you define the type

00:11:33,140 --> 00:11:36,709
and then everywhere that you use it

00:11:34,640 --> 00:11:38,360
they're implied by the fact that the

00:11:36,709 --> 00:11:40,550
types already said that they have to be

00:11:38,360 --> 00:11:43,700
there right so this one has been

00:11:40,550 --> 00:11:45,170
accepted not yet implemented um turns

00:11:43,700 --> 00:11:49,640
out to be a little tricky that's okay

00:11:45,170 --> 00:11:51,709
we'll figure it out so another example a

00:11:49,640 --> 00:11:53,029
kind of hotly anticipated feature for

00:11:51,709 --> 00:11:55,430
some time now is something called non

00:11:53,029 --> 00:11:57,980
lexical lifetimes which is a kind of

00:11:55,430 --> 00:12:01,430
opaque name but what it basically means

00:11:57,980 --> 00:12:03,680
is you it makes the the borrowing system

00:12:01,430 --> 00:12:07,970
in rust understand your control flow

00:12:03,680 --> 00:12:10,010
much better so right now let's say I'm a

00:12:07,970 --> 00:12:11,600
map like I'm looking up in a hash map

00:12:10,010 --> 00:12:14,690
and entry for a given key and I'm

00:12:11,600 --> 00:12:16,579
borrowing the result what will happen if

00:12:14,690 --> 00:12:18,410
I store the result of that borrow into a

00:12:16,579 --> 00:12:20,660
variable like I did here I said let

00:12:18,410 --> 00:12:22,399
value equals this variable the borrow

00:12:20,660 --> 00:12:27,050
lasts until the end of the enclosing

00:12:22,399 --> 00:12:28,070
block usually as a result you know you

00:12:27,050 --> 00:12:30,320
often have to sort of introduce

00:12:28,070 --> 00:12:32,300
artificial blocks so that you can end

00:12:30,320 --> 00:12:33,920
the borrow when you wanted it to end

00:12:32,300 --> 00:12:36,230
right so if you're just gonna use the

00:12:33,920 --> 00:12:37,880
value in the next line for example here

00:12:36,230 --> 00:12:39,500
I just used it in the if and don't use

00:12:37,880 --> 00:12:41,270
it or in one branch of the if and I

00:12:39,500 --> 00:12:42,680
don't use it again that's not enough I

00:12:41,270 --> 00:12:45,680
have to actually pull code out and

00:12:42,680 --> 00:12:47,180
insert blocks and then I can make it

00:12:45,680 --> 00:12:49,190
compile on these sort of contortions

00:12:47,180 --> 00:12:50,600
this is a good example of something that

00:12:49,190 --> 00:12:51,980
becomes second nature when you're more

00:12:50,600 --> 00:12:53,899
experienced with rust but it's really

00:12:51,980 --> 00:12:55,790
not obvious if you're a newcomer right

00:12:53,899 --> 00:12:57,680
but nobody really wants to do it in the

00:12:55,790 --> 00:12:59,480
first place so what we're doing in the

00:12:57,680 --> 00:13:00,800
new system is having the compiler

00:12:59,480 --> 00:13:02,560
understand control flow much better

00:13:00,800 --> 00:13:05,060
which means you can actually just write

00:13:02,560 --> 00:13:07,610
code like this which can look up the key

00:13:05,060 --> 00:13:09,620
in the map use the value and after the

00:13:07,610 --> 00:13:11,660
last use when you stop using the thing

00:13:09,620 --> 00:13:13,579
that you took out of the map it it'll be

00:13:11,660 --> 00:13:16,520
free from mutation the borrow is

00:13:13,579 --> 00:13:18,320
considered to end so this is something

00:13:16,520 --> 00:13:19,370
that's underway actually Santiago who's

00:13:18,320 --> 00:13:21,480
here in the audience has been working

00:13:19,370 --> 00:13:22,920
with me and also Paul

00:13:21,480 --> 00:13:25,860
I'm not sure of his last name actually

00:13:22,920 --> 00:13:29,250
machinist 88 I know people by their IRC

00:13:25,860 --> 00:13:30,570
and get our nicknames usually but and

00:13:29,250 --> 00:13:32,250
we've been implementing it and it's kind

00:13:30,570 --> 00:13:33,960
of working you can't actually use it yet

00:13:32,250 --> 00:13:35,550
but there are tests starting to pass so

00:13:33,960 --> 00:13:37,530
this is on its way as well

00:13:35,550 --> 00:13:40,410
there's also a much bigger effort I

00:13:37,530 --> 00:13:44,040
should add around supporting this a lot

00:13:40,410 --> 00:13:47,480
of people are involved and another

00:13:44,040 --> 00:13:51,600
similar thing in the sense of a a

00:13:47,480 --> 00:13:53,340
feature that enables even enables and

00:13:51,600 --> 00:13:54,930
eliminates roadblocks that everyone

00:13:53,340 --> 00:13:56,460
experienced and new users of light find

00:13:54,930 --> 00:13:58,140
extremely difficult to work around is

00:13:56,460 --> 00:14:00,330
something called infiltrate that lets

00:13:58,140 --> 00:14:02,280
you handle returning things like if

00:14:00,330 --> 00:14:03,840
you'd like to return an iterator out of

00:14:02,280 --> 00:14:05,040
a function that can be a little bit

00:14:03,840 --> 00:14:06,930
difficult right now because you have to

00:14:05,040 --> 00:14:09,480
specify the entire type of the iterator

00:14:06,930 --> 00:14:12,330
which might be very long or if it

00:14:09,480 --> 00:14:15,750
includes a closure not even something

00:14:12,330 --> 00:14:17,220
you can type and so what we do now a

00:14:15,750 --> 00:14:18,960
support in the compiler is the ability

00:14:17,220 --> 00:14:21,060
to say I'm returning some type that

00:14:18,960 --> 00:14:22,880
implements iterator in this case an

00:14:21,060 --> 00:14:27,060
iterator that yields up I 32

00:14:22,880 --> 00:14:28,560
I'm sorry you 32 and that means that

00:14:27,060 --> 00:14:30,150
even if it has closure types and so on

00:14:28,560 --> 00:14:31,620
you don't have to actually tell what the

00:14:30,150 --> 00:14:33,660
type is the compiler will figure it out

00:14:31,620 --> 00:14:34,920
for you so we have a preliminary version

00:14:33,660 --> 00:14:36,660
implemented we're making a lot of

00:14:34,920 --> 00:14:38,520
improvements though right now you can

00:14:36,660 --> 00:14:40,320
only use it in return position in the

00:14:38,520 --> 00:14:42,060
current version of the compiler but

00:14:40,320 --> 00:14:43,350
under the expanded and intended plans

00:14:42,060 --> 00:14:45,150
we're going to be able to use it also in

00:14:43,350 --> 00:14:47,730
argument positions and other places to

00:14:45,150 --> 00:14:50,130
say like I'm taking some type that is an

00:14:47,730 --> 00:14:51,450
iterator without having to introduce a

00:14:50,130 --> 00:14:56,040
generic argument and do these other

00:14:51,450 --> 00:14:57,210
things and async/await is another kind

00:14:56,040 --> 00:14:58,680
of feature like this you may know it

00:14:57,210 --> 00:15:00,930
from languages like JavaScript ocean

00:14:58,680 --> 00:15:02,580
sharp so if you're writing server-side

00:15:00,930 --> 00:15:06,090
code you'd like to be able to do

00:15:02,580 --> 00:15:07,260
blocking i/o operations but you or you

00:15:06,090 --> 00:15:08,250
like to mail the write code that looks

00:15:07,260 --> 00:15:10,380
like you're doing blocking i/o

00:15:08,250 --> 00:15:11,580
operations I should say but actually

00:15:10,380 --> 00:15:13,350
when those i/o operations are happening

00:15:11,580 --> 00:15:15,000
your function returns and waits for the

00:15:13,350 --> 00:15:17,250
results and then starts over again and

00:15:15,000 --> 00:15:19,350
you can do this by hand today or you can

00:15:17,250 --> 00:15:21,360
use future Combinator's to do it which

00:15:19,350 --> 00:15:22,860
sometimes works nicely but a lot of

00:15:21,360 --> 00:15:24,540
times if the control flow is complicated

00:15:22,860 --> 00:15:27,960
those solutions are kind of problematic

00:15:24,540 --> 00:15:29,940
so we've been working on enabling using

00:15:27,960 --> 00:15:31,800
kind of combination of compiler plugins

00:15:29,940 --> 00:15:34,230
and some built-in features the ability

00:15:31,800 --> 00:15:34,889
to tag functions as a sync and then say

00:15:34,230 --> 00:15:36,779
okay I'd like

00:15:34,889 --> 00:15:39,509
to wait for the result of this i/o

00:15:36,779 --> 00:15:41,339
operation and and the compiler will

00:15:39,509 --> 00:15:43,199
transparently introduce all the plumbing

00:15:41,339 --> 00:15:44,850
that you need for you right and that's

00:15:43,199 --> 00:15:47,279
actually implemented and usable today if

00:15:44,850 --> 00:15:48,600
you download the right extensions you

00:15:47,279 --> 00:15:49,889
should talk to Alex Brightman about it

00:15:48,600 --> 00:15:54,029
because I'm not sure what you have to

00:15:49,889 --> 00:15:55,799
setup exactly but so when you put it all

00:15:54,029 --> 00:15:57,600
together I think you can start to get

00:15:55,799 --> 00:15:58,859
the feeling that Russ 2019 is going to

00:15:57,600 --> 00:16:00,569
feel like a pretty different language

00:15:58,859 --> 00:16:02,459
right and so I only talked about a few

00:16:00,569 --> 00:16:03,989
things these are some of the proposals I

00:16:02,459 --> 00:16:05,879
talked about the checks are the ones

00:16:03,989 --> 00:16:08,639
that are implemented at least in some

00:16:05,879 --> 00:16:10,619
form but there's a lot of other stuff

00:16:08,639 --> 00:16:12,540
and this isn't even a complete list that

00:16:10,619 --> 00:16:15,209
has been that we've been planning to do

00:16:12,540 --> 00:16:16,949
most of which is in some form of is in

00:16:15,209 --> 00:16:18,329
some way a part way through the

00:16:16,949 --> 00:16:20,549
implementation process someone is

00:16:18,329 --> 00:16:22,259
working on it some of the ideas that we

00:16:20,549 --> 00:16:24,269
had didn't work out you can see we've

00:16:22,259 --> 00:16:25,829
crossed a few out they didn't they were

00:16:24,269 --> 00:16:28,829
too complicated to or had other

00:16:25,829 --> 00:16:31,139
downsides but overall I'm really excited

00:16:28,829 --> 00:16:32,279
to see what Russ 2019 is going to feel

00:16:31,139 --> 00:16:34,949
like and I think you should be excited

00:16:32,279 --> 00:16:36,059
too and if you want to help us even

00:16:34,949 --> 00:16:37,679
though I said you can see there's

00:16:36,059 --> 00:16:39,239
progress there there's still lots to do

00:16:37,679 --> 00:16:41,429
so feel free to reach out to me on

00:16:39,239 --> 00:16:42,059
getter I will find you something I will

00:16:41,429 --> 00:16:48,509
put you to work

00:16:42,059 --> 00:16:49,949
don't worry speaking of that so that was

00:16:48,509 --> 00:16:51,629
all all I've been talking about as the

00:16:49,949 --> 00:16:53,369
language but to make all these features

00:16:51,629 --> 00:16:55,110
happen they have to be supported in the

00:16:53,369 --> 00:16:56,610
compiler so we've been doing a lot of

00:16:55,110 --> 00:16:59,220
work on the compiler over the last year

00:16:56,610 --> 00:17:00,600
and some of it especially in the last

00:16:59,220 --> 00:17:03,209
few months has been this feature work

00:17:00,600 --> 00:17:05,069
but before that there was a lot of more

00:17:03,209 --> 00:17:07,380
foundational work and refactoring that

00:17:05,069 --> 00:17:08,699
was intended to bring some really

00:17:07,380 --> 00:17:11,610
advanced features that have been in the

00:17:08,699 --> 00:17:13,019
pipeline for a long time to reality and

00:17:11,610 --> 00:17:14,579
so one of them too I'll go into in a

00:17:13,019 --> 00:17:16,159
little more detail in a second is

00:17:14,579 --> 00:17:18,659
incremental compilation which means

00:17:16,159 --> 00:17:19,860
until now whenever you build a Russ

00:17:18,659 --> 00:17:21,569
project it always starts from scratch

00:17:19,860 --> 00:17:24,240
and in the beginning that's okay because

00:17:21,569 --> 00:17:25,949
your project is like ten lines but as it

00:17:24,240 --> 00:17:27,389
gets bigger it can get a little tedious

00:17:25,949 --> 00:17:28,889
to the point where when you're building

00:17:27,389 --> 00:17:32,850
the compiler sometimes you you know go

00:17:28,889 --> 00:17:34,200
out for coffee and we would like to

00:17:32,850 --> 00:17:36,090
change that right we want it to be just

00:17:34,200 --> 00:17:37,799
you make a small change it's ready for

00:17:36,090 --> 00:17:39,000
you right away and we've been working

00:17:37,799 --> 00:17:41,279
really hard on instrumenting the

00:17:39,000 --> 00:17:42,710
compiler to make that happen but we're

00:17:41,279 --> 00:17:44,639
also trying to support things like

00:17:42,710 --> 00:17:46,529
constant Eric's which means you can have

00:17:44,639 --> 00:17:47,720
a function that's parameterised over a

00:17:46,529 --> 00:17:50,000
value not just the

00:17:47,720 --> 00:17:51,860
so you might say make a different copy

00:17:50,000 --> 00:17:54,529
of this function for every value of the

00:17:51,860 --> 00:17:56,179
parameter n so when n is 1 I want to

00:17:54,529 --> 00:17:58,100
copy specialize to that and when n is 2

00:17:56,179 --> 00:17:59,330
and 4 and 8 and that can be really

00:17:58,100 --> 00:18:03,139
useful for high-performance

00:17:59,330 --> 00:18:04,909
cases and procedural macros which let

00:18:03,139 --> 00:18:06,830
you not only use the built-in macro

00:18:04,909 --> 00:18:09,379
system of Rus but actually write macros

00:18:06,830 --> 00:18:10,970
in rust that the compiler will execute

00:18:09,379 --> 00:18:12,409
it sort of like plugins and actually

00:18:10,970 --> 00:18:13,549
that's how async/await is implemented

00:18:12,409 --> 00:18:15,590
today so you may have saw that

00:18:13,549 --> 00:18:17,389
async/await used macro notation and

00:18:15,590 --> 00:18:19,100
stuff on the other slide that was using

00:18:17,389 --> 00:18:20,840
a prototype of the procedural macro

00:18:19,100 --> 00:18:22,759
system so the code is written to do the

00:18:20,840 --> 00:18:24,259
transformation is fairly complex it's

00:18:22,759 --> 00:18:28,549
written in rust but a single weight

00:18:24,259 --> 00:18:30,259
layers on top so let me talk a bit about

00:18:28,549 --> 00:18:32,539
incremental compilation this has been

00:18:30,259 --> 00:18:33,649
something we've been in like Nam Mexico

00:18:32,539 --> 00:18:35,840
lifetimes I would say a long time

00:18:33,649 --> 00:18:39,710
planned and coming but turned out to be

00:18:35,840 --> 00:18:41,059
quite challenging so the saga begins I

00:18:39,710 --> 00:18:42,889
don't remember when it was but at least

00:18:41,059 --> 00:18:43,549
a year probably two years ago with RSC

00:18:42,889 --> 00:18:45,679
00:18:43,549 --> 00:18:47,480
this basically laid out a plan for how

00:18:45,679 --> 00:18:48,980
to do incremental compilation and then

00:18:47,480 --> 00:18:52,100
we went ahead and we we implemented that

00:18:48,980 --> 00:18:54,470
plan we made a beta release a little

00:18:52,100 --> 00:18:58,190
while back and you know it worked pretty

00:18:54,470 --> 00:18:59,720
well so if you look these are some

00:18:58,190 --> 00:19:01,340
graphs the details aren't that important

00:18:59,720 --> 00:19:04,129
just have to look at these big red lines

00:19:01,340 --> 00:19:05,409
basically the far red far red line

00:19:04,129 --> 00:19:09,230
that's how long it takes from scratch

00:19:05,409 --> 00:19:11,240
always the same but each of these rows

00:19:09,230 --> 00:19:12,769
these are if I make some change like I

00:19:11,240 --> 00:19:14,509
modify a particular method and then I

00:19:12,769 --> 00:19:16,220
recompile right so when it always does

00:19:14,509 --> 00:19:17,509
everything it takes the same time but

00:19:16,220 --> 00:19:19,759
with incremental mode you can see we've

00:19:17,509 --> 00:19:22,460
shaved off a lot of time for each of

00:19:19,759 --> 00:19:23,840
those the different changes however this

00:19:22,460 --> 00:19:26,929
graphs a little deceiving because what

00:19:23,840 --> 00:19:28,190
we found was that this although it was

00:19:26,929 --> 00:19:30,259
working pretty well when it worked there

00:19:28,190 --> 00:19:33,350
were a lot of cases where the system has

00:19:30,259 --> 00:19:34,610
planned wasn't expressive enough and we

00:19:33,350 --> 00:19:36,529
weren't able to get much better than

00:19:34,610 --> 00:19:38,149
this and we wanted to get significantly

00:19:36,529 --> 00:19:40,940
better if we want these bars to be you

00:19:38,149 --> 00:19:43,700
know all the way look like zero not look

00:19:40,940 --> 00:19:45,860
like 25% of the time and so for that we

00:19:43,700 --> 00:19:48,250
started a kind of new design that we've

00:19:45,860 --> 00:19:51,320
been working on and where it's actually

00:19:48,250 --> 00:19:52,220
maybe a month ago maybe just a few weeks

00:19:51,320 --> 00:19:54,440
I lose track of time

00:19:52,220 --> 00:19:56,149
things go so fast but relatively

00:19:54,440 --> 00:19:58,429
recently actually started to work now

00:19:56,149 --> 00:19:59,570
and we call this red-green I can go into

00:19:58,429 --> 00:20:00,610
the details another time if you're

00:19:59,570 --> 00:20:03,400
interested come find me

00:20:00,610 --> 00:20:05,110
it enables the compiler to reuse results

00:20:03,400 --> 00:20:07,240
even when parts of the input have

00:20:05,110 --> 00:20:08,620
changed if we can see that it's still

00:20:07,240 --> 00:20:10,510
going to be the the end result will

00:20:08,620 --> 00:20:11,920
still be the same and it lets us do a

00:20:10,510 --> 00:20:13,450
lot better and so we're looking forward

00:20:11,920 --> 00:20:15,100
to kind of around the end of the year

00:20:13,450 --> 00:20:19,900
having significantly more powerful

00:20:15,100 --> 00:20:29,110
system here so with that I'll turn it

00:20:19,900 --> 00:20:30,460
over to Carol thank you hi everyone so

00:20:29,110 --> 00:20:35,049
as Erin mentioned at the beginning one

00:20:30,460 --> 00:20:44,110
of our goals for for 2017 is to lower

00:20:35,049 --> 00:20:46,030
the learning curve we did it yay okay so

00:20:44,110 --> 00:20:46,900
what we're really working on is a lot of

00:20:46,030 --> 00:20:48,820
different things including the

00:20:46,900 --> 00:20:50,380
ergonomics like initiative and one of

00:20:48,820 --> 00:20:53,020
the projects that I've been working on a

00:20:50,380 --> 00:20:58,660
lot is the Russ programming language

00:20:53,020 --> 00:21:01,990
book with Steve Steve wave there Steve

00:20:58,660 --> 00:21:05,440
so no starch is working with us to get

00:21:01,990 --> 00:21:09,820
this into print and I am sorry to say

00:21:05,440 --> 00:21:15,370
that our date has slipped to be May so

00:21:09,820 --> 00:21:18,280
it's a great Mother's Day present but it

00:21:15,370 --> 00:21:20,669
is coming will happen someday believe me

00:21:18,280 --> 00:21:23,140
I am excited as you to see this in print

00:21:20,669 --> 00:21:25,809
you can read it online give us feedback

00:21:23,140 --> 00:21:29,290
especially on the later chapters at this

00:21:25,809 --> 00:21:33,040
github link another effort we've been

00:21:29,290 --> 00:21:36,220
working on is having mentoring available

00:21:33,040 --> 00:21:38,860
at all levels so the the working group

00:21:36,220 --> 00:21:41,500
said the info period are a huge source

00:21:38,860 --> 00:21:44,140
of mentoring and as Nico said there's

00:21:41,500 --> 00:21:47,679
there's room for everyone here and we

00:21:44,140 --> 00:21:51,070
will find something for you to do but we

00:21:47,679 --> 00:21:53,910
also wanted we want to grow Russ PI we

00:21:51,070 --> 00:22:00,070
want to bring more people into rusts and

00:21:53,910 --> 00:22:02,880
have people who are new to rusts new new

00:22:00,070 --> 00:22:05,500
to programming but also new to rust or

00:22:02,880 --> 00:22:07,630
not new to programming but new to rust

00:22:05,500 --> 00:22:09,669
and people who are experienced at rust

00:22:07,630 --> 00:22:13,480
to get involved with the language itself

00:22:09,669 --> 00:22:14,450
and we especially want to bring in folks

00:22:13,480 --> 00:22:17,300
who are underrepresented

00:22:14,450 --> 00:22:20,330
attack women people of color LGBTQ folks

00:22:17,300 --> 00:22:22,070
people with disabilities who and these

00:22:20,330 --> 00:22:24,530
are folks who also tend to be especially

00:22:22,070 --> 00:22:28,040
underrepresented in systems programming

00:22:24,530 --> 00:22:31,070
I think and a lot of us think that Russ

00:22:28,040 --> 00:22:32,780
is an enabling technology that lets more

00:22:31,070 --> 00:22:35,300
people participate in systems

00:22:32,780 --> 00:22:39,440
programming and we want to grow Russ PI

00:22:35,300 --> 00:22:41,630
by bringing in everyone another effort

00:22:39,440 --> 00:22:44,510
we've been doing is the Russ bridge

00:22:41,630 --> 00:22:46,640
workshops this comes out of the there

00:22:44,510 --> 00:22:48,200
was rails bridge and there are many

00:22:46,640 --> 00:22:49,370
other bridge workshops in other

00:22:48,200 --> 00:22:51,950
languages

00:22:49,370 --> 00:22:53,780
these are try Gurda towards under

00:22:51,950 --> 00:22:54,470
representing folks in tech we had one

00:22:53,780 --> 00:22:56,030
yesterday

00:22:54,470 --> 00:23:01,220
run by Ashley Ashley would you like to

00:22:56,030 --> 00:23:08,600
wave and if anyone who was at that

00:23:01,220 --> 00:23:11,450
workshop yesterday would like to wave so

00:23:08,600 --> 00:23:13,190
in this workshop everyone builds a web

00:23:11,450 --> 00:23:18,350
app that gives you emergency rust

00:23:13,190 --> 00:23:22,370
compliments and and we hope to we hope

00:23:18,350 --> 00:23:24,860
to help people run more of these in

00:23:22,370 --> 00:23:28,220
about January Ashley and I are probably

00:23:24,860 --> 00:23:31,010
going to hold an on line rust bridge

00:23:28,220 --> 00:23:32,540
teacher training to help people feel

00:23:31,010 --> 00:23:35,120
confident about running one of these in

00:23:32,540 --> 00:23:39,860
your own community so keep your eye out

00:23:35,120 --> 00:23:41,000
for that and the bridge events to be

00:23:39,860 --> 00:23:42,680
called a bridge red you have to be

00:23:41,000 --> 00:23:44,780
targeted towards underrepresented folks

00:23:42,680 --> 00:23:47,060
but the curriculum is online and free to

00:23:44,780 --> 00:23:51,380
use for anyone you just can't call it a

00:23:47,060 --> 00:23:54,200
bridge event if it's not targeted so

00:23:51,380 --> 00:23:54,920
this is an example of making thing when

00:23:54,200 --> 00:23:56,630
you make things better for

00:23:54,920 --> 00:23:59,180
underrepresented folks you're also

00:23:56,630 --> 00:24:00,950
making it better for everyone another

00:23:59,180 --> 00:24:04,040
effort we've been working on is the

00:24:00,950 --> 00:24:05,840
increasing rusts reach program where we

00:24:04,040 --> 00:24:09,590
brought in folks that have experiences

00:24:05,840 --> 00:24:13,670
and insights in other other fields like

00:24:09,590 --> 00:24:16,210
teaching and other languages that can

00:24:13,670 --> 00:24:18,110
help us that are things that we lack

00:24:16,210 --> 00:24:20,360
experiences we lack in the Russ

00:24:18,110 --> 00:24:23,600
community and bringing them in to help

00:24:20,360 --> 00:24:26,060
us make rusts better and this has been

00:24:23,600 --> 00:24:27,350
going on there are a few folks here that

00:24:26,060 --> 00:24:28,350
our person is doing the program if you

00:24:27,350 --> 00:24:36,330
would like to wave

00:24:28,350 --> 00:24:38,880
you be a wave where we're going to be

00:24:36,330 --> 00:24:40,350
putting out this is going to be

00:24:38,880 --> 00:24:42,270
finishing up soon and you should hear

00:24:40,350 --> 00:24:44,669
more about how those projects went soon

00:24:42,270 --> 00:24:46,500
but it's been a lot of fun and people

00:24:44,669 --> 00:24:48,179
have been enjoying working on these

00:24:46,500 --> 00:24:51,600
projects

00:24:48,179 --> 00:24:53,640
another project we've done is the

00:24:51,600 --> 00:24:55,590
request for explanation podcast there

00:24:53,640 --> 00:24:58,530
have been a lot of RFC's and they're not

00:24:55,590 --> 00:25:00,210
always easy to keep up with easy to read

00:24:58,530 --> 00:25:03,240
easy to understand how it will impact

00:25:00,210 --> 00:25:05,520
you so Manisha in the back if you would

00:25:03,240 --> 00:25:08,850
like to with Manish has helped with this

00:25:05,520 --> 00:25:11,520
effort to make little digestible

00:25:08,850 --> 00:25:13,110
discussions of RFC's to help everyone

00:25:11,520 --> 00:25:15,750
keep up with how the language is

00:25:13,110 --> 00:25:18,030
changing so if you have any rfcs that

00:25:15,750 --> 00:25:22,770
you'd like us to talk about let us know

00:25:18,030 --> 00:25:25,760
I had our repository and we'll we'll get

00:25:22,770 --> 00:25:28,140
to those and talk about them soon

00:25:25,760 --> 00:25:31,409
another effort that we've been working

00:25:28,140 --> 00:25:34,620
on is making high quality libraries

00:25:31,409 --> 00:25:38,669
available and easy to find so we've been

00:25:34,620 --> 00:25:40,830
in order to do that we did some research

00:25:38,669 --> 00:25:46,049
into how people decide what crates to

00:25:40,830 --> 00:25:47,820
use and we found that the the most

00:25:46,049 --> 00:25:50,820
important thing that people look for is

00:25:47,820 --> 00:25:52,530
good documentation and I think this is

00:25:50,820 --> 00:25:55,590
probably something in hover bears

00:25:52,530 --> 00:25:58,169
workshop yesterday that that was

00:25:55,590 --> 00:26:00,750
reinforced that good documentation is

00:25:58,169 --> 00:26:02,700
like the first interaction people have

00:26:00,750 --> 00:26:03,929
with your library so if you are a

00:26:02,700 --> 00:26:05,640
library author I would highly recommend

00:26:03,929 --> 00:26:09,360
spending some more time on your Docs but

00:26:05,640 --> 00:26:10,740
you could all use fedorov and there are

00:26:09,360 --> 00:26:12,179
a lot of other things that people look

00:26:10,740 --> 00:26:14,820
for when they're looking for a crate and

00:26:12,179 --> 00:26:16,980
we took these into account and made some

00:26:14,820 --> 00:26:18,990
improvements to crates i/o this year

00:26:16,980 --> 00:26:21,090
we've added categories so that you can

00:26:18,990 --> 00:26:23,789
be like I want a crate that does this

00:26:21,090 --> 00:26:26,909
and you can go to the this category and

00:26:23,789 --> 00:26:29,669
find the crates that do that we've

00:26:26,909 --> 00:26:31,409
changed the sorting to be recent

00:26:29,669 --> 00:26:34,350
downloads within the categories and the

00:26:31,409 --> 00:26:36,150
keywords we've added some badges so you

00:26:34,350 --> 00:26:38,220
can see if the crate is currently

00:26:36,150 --> 00:26:39,130
passing on various CI things on Windows

00:26:38,220 --> 00:26:42,370
and on Linux

00:26:39,130 --> 00:26:44,110
and you can see all the crates that a

00:26:42,370 --> 00:26:46,450
particular user or a particular team

00:26:44,110 --> 00:26:50,260
owned so you can see which crates works

00:26:46,450 --> 00:26:53,799
together well for example this is the

00:26:50,260 --> 00:26:55,809
rustling nursery libs team so you can

00:26:53,799 --> 00:26:58,870
see all the crates that that team is

00:26:55,809 --> 00:27:00,309
working on if you like this team's work

00:26:58,870 --> 00:27:02,530
you can see what other things they've

00:27:00,309 --> 00:27:05,130
made we've also got a badge on here

00:27:02,530 --> 00:27:09,220
showing that bit Flags is passing on CI

00:27:05,130 --> 00:27:11,260
and we another improvement that we

00:27:09,220 --> 00:27:13,450
shipped recently is that we're rendering

00:27:11,260 --> 00:27:20,380
read Me's on the crate page which is

00:27:13,450 --> 00:27:21,760
really exciting so this is this is what

00:27:20,380 --> 00:27:24,250
it looks like if you haven't happened to

00:27:21,760 --> 00:27:28,000
see this lately this is a great place to

00:27:24,250 --> 00:27:30,970
put that example of how to get started

00:27:28,000 --> 00:27:33,490
using a library to see what it's like to

00:27:30,970 --> 00:27:34,929
use the library before you go ahead and

00:27:33,490 --> 00:27:38,320
add it to your project you download it

00:27:34,929 --> 00:27:41,440
so this is a great place to put that

00:27:38,320 --> 00:27:43,900
intro documentation to help people use

00:27:41,440 --> 00:27:45,789
your crate we might be working on a

00:27:43,900 --> 00:27:47,559
redesigned to in order to now that we've

00:27:45,789 --> 00:27:49,780
added all these extra extra of

00:27:47,559 --> 00:27:51,280
information for people it's it's getting

00:27:49,780 --> 00:27:57,220
a little crowded so we might be doing a

00:27:51,280 --> 00:28:01,049
redesign and that's all I have about

00:27:57,220 --> 00:28:01,049
crates out and now it's back to Erin

00:28:02,280 --> 00:28:05,470
[Music]

00:28:05,840 --> 00:28:14,760
so let's talk about build systems one of

00:28:09,570 --> 00:28:17,580
the most specific goals we had in 2017

00:28:14,760 --> 00:28:19,520
on our roadmap was to improve the story

00:28:17,580 --> 00:28:23,520
for build system integration in Rus and

00:28:19,520 --> 00:28:26,210
this is particularly important for you

00:28:23,520 --> 00:28:28,740
know larger companies who have their own

00:28:26,210 --> 00:28:30,870
take on how they want builds to work

00:28:28,740 --> 00:28:34,500
they're often using big build systems

00:28:30,870 --> 00:28:36,179
like basil to do all of the building

00:28:34,500 --> 00:28:39,840
across all of the languages in product

00:28:36,179 --> 00:28:41,100
projects at the company and they're you

00:28:39,840 --> 00:28:43,470
know have been various points of

00:28:41,100 --> 00:28:44,039
friction integrating rust into that

00:28:43,470 --> 00:28:46,529
story

00:28:44,039 --> 00:28:48,870
it's like unclear what role cargo should

00:28:46,529 --> 00:28:51,779
play and how to plug cargo into these

00:28:48,870 --> 00:28:54,720
kinds of build systems so we've been

00:28:51,779 --> 00:28:57,270
putting a lot of thought into how to

00:28:54,720 --> 00:29:00,600
make this process friction-free

00:28:57,270 --> 00:29:03,450
so that adopting rust in companies large

00:29:00,600 --> 00:29:05,370
and small is a lot easier so I don't

00:29:03,450 --> 00:29:10,049
have time to go through all the details

00:29:05,370 --> 00:29:12,690
but I think probably the most important

00:29:10,049 --> 00:29:16,350
insight that's come out of this process

00:29:12,690 --> 00:29:18,450
is trying to understand cargo not as a

00:29:16,350 --> 00:29:21,600
single monolithic thing but actually

00:29:18,450 --> 00:29:23,990
really a bunch of different tools like a

00:29:21,600 --> 00:29:26,940
pipeline of tools that work together and

00:29:23,990 --> 00:29:29,909
when you are working in a pure rust

00:29:26,940 --> 00:29:32,190
ecosystem you generally use the whole

00:29:29,909 --> 00:29:34,350
tool chain together and you don't really

00:29:32,190 --> 00:29:37,140
care about these distinctions but when

00:29:34,350 --> 00:29:39,059
you want to bring cargo into your build

00:29:37,140 --> 00:29:41,640
system or customize something that it's

00:29:39,059 --> 00:29:43,380
doing being able to sort of peel it

00:29:41,640 --> 00:29:46,020
apart and replace some of the layers and

00:29:43,380 --> 00:29:47,940
keep others is really helpful so I'm

00:29:46,020 --> 00:29:50,490
just gonna walk through real quick what

00:29:47,940 --> 00:29:53,159
this this layering is and if you have

00:29:50,490 --> 00:29:55,200
build system issues I would love to talk

00:29:53,159 --> 00:29:58,529
to you I'm always looking for for more

00:29:55,200 --> 00:30:01,620
use cases so the the first thing that

00:29:58,529 --> 00:30:04,620
cargo does is dependency resolution this

00:30:01,620 --> 00:30:07,740
is probably the single most opinionated

00:30:04,620 --> 00:30:08,909
aspect of cargo where you know we're

00:30:07,740 --> 00:30:12,670
baking in the way we think about

00:30:08,909 --> 00:30:14,680
semantic versioning and so on and

00:30:12,670 --> 00:30:16,210
after the pensive the resolution is

00:30:14,680 --> 00:30:18,580
complete you get a lock file right this

00:30:16,210 --> 00:30:21,580
is hopefully familiar to many of you if

00:30:18,580 --> 00:30:23,830
you use cargo much but the the steps

00:30:21,580 --> 00:30:26,800
after this you may not have thought

00:30:23,830 --> 00:30:29,110
about so once you've got this dependency

00:30:26,800 --> 00:30:32,380
graph there's still a bunch of steps

00:30:29,110 --> 00:30:36,520
left to actually do a build the first

00:30:32,380 --> 00:30:39,280
one is actually figuring out for each

00:30:36,520 --> 00:30:41,530
crate how do you want to build that

00:30:39,280 --> 00:30:44,440
crate what what kinds of knobs have you

00:30:41,530 --> 00:30:47,170
tweaked and these these knobs are at the

00:30:44,440 --> 00:30:50,920
sort of cargo tamil level of abstraction

00:30:47,170 --> 00:30:53,170
so things like profiles or create

00:30:50,920 --> 00:30:55,030
features or you know configuring

00:30:53,170 --> 00:30:57,460
particular targets so on and so forth so

00:30:55,030 --> 00:30:59,980
this is still at the level of you know

00:30:57,460 --> 00:31:03,160
what you as a rust programmer are used

00:30:59,980 --> 00:31:06,240
to specifying and you know there's a

00:31:03,160 --> 00:31:08,200
step where basically with the the

00:31:06,240 --> 00:31:10,270
dependency graph we go and figure out

00:31:08,200 --> 00:31:13,660
how each crate should be configured on

00:31:10,270 --> 00:31:17,260
these lines then we go create by crate

00:31:13,660 --> 00:31:20,860
and turn that high-level configuration

00:31:17,260 --> 00:31:23,710
into a really granular series of build

00:31:20,860 --> 00:31:25,630
steps which might involve running Russy

00:31:23,710 --> 00:31:27,700
multiple times if you have you know a

00:31:25,630 --> 00:31:30,340
build script for example it might

00:31:27,700 --> 00:31:32,200
involve running other binaries and we

00:31:30,340 --> 00:31:35,200
have to convert all those configuration

00:31:32,200 --> 00:31:39,130
settings down to flags to actually pass

00:31:35,200 --> 00:31:40,870
rust C and then finally we go and

00:31:39,130 --> 00:31:43,210
execute those granular steps

00:31:40,870 --> 00:31:44,830
alright so each of these pieces is

00:31:43,210 --> 00:31:46,510
something that's useful in different

00:31:44,830 --> 00:31:49,120
settings and the hope is that for

00:31:46,510 --> 00:31:51,310
example if you're using basil and you

00:31:49,120 --> 00:31:53,620
maybe you don't want dependency

00:31:51,310 --> 00:31:55,720
resolution or build configuration but

00:31:53,620 --> 00:31:58,630
you can use build lowering so that you

00:31:55,720 --> 00:32:00,340
don't have to fully grok the rust see

00:31:58,630 --> 00:32:01,870
command-line interface you can still

00:32:00,340 --> 00:32:04,060
work at a cargo level of abstraction

00:32:01,870 --> 00:32:06,400
just as one example so I think this is a

00:32:04,060 --> 00:32:07,990
really interesting area it's still very

00:32:06,400 --> 00:32:09,790
much in development and like I said I

00:32:07,990 --> 00:32:12,220
would love to hear from you if you've

00:32:09,790 --> 00:32:16,120
encountered friction with cargo in a

00:32:12,220 --> 00:32:21,100
larger build system setting so switching

00:32:16,120 --> 00:32:24,220
gears one of the things we saw when we

00:32:21,100 --> 00:32:26,220
conducted the rust survey in 2016 that I

00:32:24,220 --> 00:32:28,020
think surprised a lot of

00:32:26,220 --> 00:32:31,560
you know the people in the rest core

00:32:28,020 --> 00:32:34,920
team was the importance of ID es it was

00:32:31,560 --> 00:32:36,510
probably the single most requested piece

00:32:34,920 --> 00:32:40,620
of tooling and for many people blocker

00:32:36,510 --> 00:32:43,530
to using rust effectively so you know in

00:32:40,620 --> 00:32:45,510
in the last year and a half we've really

00:32:43,530 --> 00:32:49,920
put a lot of effort into the IDE story

00:32:45,510 --> 00:32:52,620
and there are now multiple IDs that are

00:32:49,920 --> 00:32:55,020
quite good for working with Russ code so

00:32:52,620 --> 00:32:58,500
one of them is IntelliJ which a few

00:32:55,020 --> 00:33:01,110
months ago actually the community plugin

00:32:58,500 --> 00:33:03,450
around IntelliJ for us became an

00:33:01,110 --> 00:33:05,430
officially supported part of the

00:33:03,450 --> 00:33:06,630
IntelliJ platform so there are now

00:33:05,430 --> 00:33:09,900
actually multiple people working

00:33:06,630 --> 00:33:12,900
full-time IntelliJ on this russ plugin

00:33:09,900 --> 00:33:15,180
and so the this idea is really great and

00:33:12,900 --> 00:33:16,620
it's it's making a lot of progress it's

00:33:15,180 --> 00:33:20,490
also part of the Imperial if you want to

00:33:16,620 --> 00:33:23,520
act on it but so the IntelliJ approach

00:33:20,490 --> 00:33:25,170
is to sort of that you know they support

00:33:23,520 --> 00:33:27,600
a huge range of languages they have a

00:33:25,170 --> 00:33:29,040
lot of infrastructure and they kind of

00:33:27,600 --> 00:33:32,670
have their own way of doing things

00:33:29,040 --> 00:33:34,800
they're not leveraging the rust compiler

00:33:32,670 --> 00:33:37,380
itself that's not sort of their approach

00:33:34,800 --> 00:33:39,090
so the other main track that we've been

00:33:37,380 --> 00:33:41,940
exploring is something called the Russ

00:33:39,090 --> 00:33:47,600
language service which speaks a protocol

00:33:41,940 --> 00:33:49,980
that's used in vs code and several other

00:33:47,600 --> 00:33:51,360
II's it was developed jointly between

00:33:49,980 --> 00:33:54,510
Microsoft Red Hat and some other

00:33:51,360 --> 00:33:58,200
important stakeholders and so basically

00:33:54,510 --> 00:34:00,120
the RLS hooks the rust compiler up to

00:33:58,200 --> 00:34:02,700
this protocol it's sort of teaches the

00:34:00,120 --> 00:34:05,130
rest compiler to speak the the language

00:34:02,700 --> 00:34:07,980
that these IDs want to use and so as a

00:34:05,130 --> 00:34:10,610
result we have a vs code plugin for Russ

00:34:07,980 --> 00:34:14,010
which is also making really good strides

00:34:10,610 --> 00:34:15,780
it recently became available actually as

00:34:14,010 --> 00:34:18,180
part of rust up so the set up is a lot

00:34:15,780 --> 00:34:20,760
easier and we expect a one point out

00:34:18,180 --> 00:34:22,890
release fairly soon and then there are

00:34:20,760 --> 00:34:25,440
lots of other things like I won't go

00:34:22,890 --> 00:34:27,510
into a lot of detail but now that we

00:34:25,440 --> 00:34:29,400
have this RLS component there are lots

00:34:27,510 --> 00:34:31,470
of other consumers of this kind of

00:34:29,400 --> 00:34:34,230
information that we can explore very

00:34:31,470 --> 00:34:36,690
easily without having to like you know

00:34:34,230 --> 00:34:39,650
dig into the guts of the compiler so

00:34:36,690 --> 00:34:39,650
this is this is super exciting

00:34:40,260 --> 00:34:44,970
so now to go back to you know what Carol

00:34:42,839 --> 00:34:48,869
is talking about with making high

00:34:44,970 --> 00:34:53,010
quality libraries available and easy to

00:34:48,869 --> 00:34:55,649
find one of the things the library team

00:34:53,010 --> 00:34:57,480
has been working on is the available

00:34:55,649 --> 00:34:59,780
part and the high quality part right

00:34:57,480 --> 00:35:02,069
complementing Carol's easy to find part

00:34:59,780 --> 00:35:05,220
and so we've been doing this through a

00:35:02,069 --> 00:35:07,260
program called the libs blitz and as the

00:35:05,220 --> 00:35:09,900
name suggests the idea is we're going to

00:35:07,260 --> 00:35:12,690
you know fairly quickly go through a lot

00:35:09,900 --> 00:35:13,619
of different libraries there there are a

00:35:12,690 --> 00:35:15,930
lot of great libraries in the

00:35:13,619 --> 00:35:19,170
open-source rust ecosystem many of which

00:35:15,930 --> 00:35:22,339
are not officially in a sort of 1.0

00:35:19,170 --> 00:35:26,280
state but there are morally pretty close

00:35:22,339 --> 00:35:28,500
and so are basically this initiative was

00:35:26,280 --> 00:35:32,550
to try to push them over the finish line

00:35:28,500 --> 00:35:35,400
and actually vet them according to a set

00:35:32,550 --> 00:35:38,819
of guidelines so we we picked 18

00:35:35,400 --> 00:35:40,650
libraries to start that we're all in the

00:35:38,819 --> 00:35:43,410
state like pretty close these are not

00:35:40,650 --> 00:35:45,329
really changing that much we think it's

00:35:43,410 --> 00:35:48,869
feasible to try to get these to a really

00:35:45,329 --> 00:35:50,970
solid 1.0 and these are also relatively

00:35:48,869 --> 00:35:54,359
foundational crates that a lot of other

00:35:50,970 --> 00:35:56,790
crates depend on and so then we set up a

00:35:54,359 --> 00:36:00,059
cadence every two weeks we would target

00:35:56,790 --> 00:36:02,540
another one of these libraries and we

00:36:00,059 --> 00:36:05,520
would go through a public discussion

00:36:02,540 --> 00:36:07,680
during those two weeks where people

00:36:05,520 --> 00:36:09,299
could talk about their experiences with

00:36:07,680 --> 00:36:12,000
the libraries shortcomings that they saw

00:36:09,299 --> 00:36:15,720
questions they had but then also we have

00:36:12,000 --> 00:36:17,819
a sort of official check checklist

00:36:15,720 --> 00:36:19,290
that's generic across all libraries that

00:36:17,819 --> 00:36:20,940
just sees whether they're following

00:36:19,290 --> 00:36:24,030
conventions whether their documentation

00:36:20,940 --> 00:36:27,740
is good and so on and so forth so then

00:36:24,030 --> 00:36:30,690
at the end of that two-week period the

00:36:27,740 --> 00:36:34,470
official libs team would meet with the

00:36:30,690 --> 00:36:36,210
library author and usually some guests

00:36:34,470 --> 00:36:38,309
and talk about everything that came up

00:36:36,210 --> 00:36:40,680
in the discussion turn that into a whole

00:36:38,309 --> 00:36:43,470
bunch of to-do items tracking issues and

00:36:40,680 --> 00:36:45,359
so on and then we would send that out to

00:36:43,470 --> 00:36:47,309
the amazing rest community and they

00:36:45,359 --> 00:36:50,250
would all immediately be picked off it

00:36:47,309 --> 00:36:51,960
was it's been incredible so we've been

00:36:50,250 --> 00:36:54,330
making really really great

00:36:51,960 --> 00:36:56,220
rasaan these libraries and you know I

00:36:54,330 --> 00:36:59,099
think almost all of them will in fact

00:36:56,220 --> 00:37:02,970
hit effectively 1.0 status by the end of

00:36:59,099 --> 00:37:04,410
the year but that's not all one of the

00:37:02,970 --> 00:37:08,250
things I find most exciting about this

00:37:04,410 --> 00:37:09,780
is we've structured it in a way that by

00:37:08,250 --> 00:37:11,760
the end of the year not only do we get

00:37:09,780 --> 00:37:15,089
all of these libraries to a good place

00:37:11,760 --> 00:37:19,349
but we have this byproduct of two books

00:37:15,089 --> 00:37:23,010
that sort of come out of this process so

00:37:19,349 --> 00:37:25,740
the first one is the rust API guidelines

00:37:23,010 --> 00:37:27,930
which David Tomei is heading up these

00:37:25,740 --> 00:37:29,490
days if you're interested in this you

00:37:27,930 --> 00:37:31,320
should definitely talk to him and so

00:37:29,490 --> 00:37:35,550
this is this is the sort of fully

00:37:31,320 --> 00:37:37,550
elaborated form of our current best

00:37:35,550 --> 00:37:40,710
practices around rust api's

00:37:37,550 --> 00:37:42,510
documentation platform support all the

00:37:40,710 --> 00:37:45,480
things you as a serious library author

00:37:42,510 --> 00:37:47,730
should be thinking about so so this is

00:37:45,480 --> 00:37:51,450
going to be a great resource for library

00:37:47,730 --> 00:37:54,330
authors to come and then something that

00:37:51,450 --> 00:37:58,859
so I'm personally helping lead right now

00:37:54,330 --> 00:38:00,780
is the the rust cookbook which basically

00:37:58,859 --> 00:38:02,910
if you look at all these libraries we've

00:38:00,780 --> 00:38:05,990
been going through part of the process

00:38:02,910 --> 00:38:08,880
is we try to pull out a handful of

00:38:05,990 --> 00:38:11,760
really compelling copy pasted able

00:38:08,880 --> 00:38:14,310
examples like what problems does this

00:38:11,760 --> 00:38:16,530
library solve and you know is there an

00:38:14,310 --> 00:38:18,480
easy way to just copy paste that into

00:38:16,530 --> 00:38:19,770
your code to get going right I don't

00:38:18,480 --> 00:38:21,599
know about you but this is the most

00:38:19,770 --> 00:38:23,640
common way I first interact with the

00:38:21,599 --> 00:38:25,020
library is like I know oh I need to do

00:38:23,640 --> 00:38:26,339
something with regular expressions let

00:38:25,020 --> 00:38:28,890
me find an example that looks about like

00:38:26,339 --> 00:38:30,930
what I want and copy that in so this is

00:38:28,890 --> 00:38:33,270
going to be I think a really vital

00:38:30,930 --> 00:38:35,730
resource for discoverability in

00:38:33,270 --> 00:38:39,960
ecosystem and we've tied it nicely to

00:38:35,730 --> 00:38:43,710
the Blitz yeah so I've already talked

00:38:39,960 --> 00:38:45,720
about the sort of 1.0 status but it

00:38:43,710 --> 00:38:47,550
feels great to have been been vetting

00:38:45,720 --> 00:38:51,180
all of these crates and I think by and

00:38:47,550 --> 00:38:53,490
large they are looking really good as

00:38:51,180 --> 00:38:57,119
part of the 2017 plan we also had some

00:38:53,490 --> 00:39:00,660
specific library goals in particular

00:38:57,119 --> 00:39:02,609
around the server networking ecosystem

00:39:00,660 --> 00:39:04,260
which is one of the places that rust has

00:39:02,609 --> 00:39:11,220
gotten the most production use

00:39:04,260 --> 00:39:15,480
so far so in so at the beginning of 2017

00:39:11,220 --> 00:39:19,170
the Tokyo project was publicly launched

00:39:15,480 --> 00:39:22,710
this project provides a sort of

00:39:19,170 --> 00:39:24,930
higher-level async IO story for rust

00:39:22,710 --> 00:39:28,140
using futures as Nico was talking about

00:39:24,930 --> 00:39:30,240
before and it is being used in in

00:39:28,140 --> 00:39:32,250
production today I think you know an

00:39:30,240 --> 00:39:34,230
ecosystem has grown up around it this is

00:39:32,250 --> 00:39:37,050
the first part of the story we wanted to

00:39:34,230 --> 00:39:40,950
tell here but there's there's a lot to

00:39:37,050 --> 00:39:42,450
do still so one thing we've gotten a lot

00:39:40,950 --> 00:39:47,300
of feedback on over the course of the

00:39:42,450 --> 00:39:49,590
year is that Tokyo is difficult to learn

00:39:47,300 --> 00:39:52,590
you know it's doing it's doing a lot of

00:39:49,590 --> 00:39:55,290
very interesting things but you know

00:39:52,590 --> 00:39:57,210
there's not as smooth of an entryway as

00:39:55,290 --> 00:39:59,160
we'd like so sort of similar to the

00:39:57,210 --> 00:40:01,140
themes with the language we've been

00:39:59,160 --> 00:40:03,450
working to lower the learning curve and

00:40:01,140 --> 00:40:05,970
give you a simpler entry point so

00:40:03,450 --> 00:40:08,370
there's an RFC for that and Alex

00:40:05,970 --> 00:40:11,100
Creighton has been doing a lot of great

00:40:08,370 --> 00:40:13,230
implementation work there but we we've

00:40:11,100 --> 00:40:14,160
got so much more in the pipeline so

00:40:13,230 --> 00:40:15,990
there's async/await

00:40:14,160 --> 00:40:19,650
which was mentioned before and we're

00:40:15,990 --> 00:40:22,020
building up our HTTP stack HTTP to

00:40:19,650 --> 00:40:25,350
support is on the way and perhaps most

00:40:22,020 --> 00:40:27,240
excitingly there's a company a startup

00:40:25,350 --> 00:40:31,710
you may have heard of called buoyant

00:40:27,240 --> 00:40:34,050
doing sort of very sophisticated proxy

00:40:31,710 --> 00:40:35,700
servers and they are betting very

00:40:34,050 --> 00:40:40,050
heavily on rust so they're they're now

00:40:35,700 --> 00:40:42,000
funding like three I think full-time

00:40:40,050 --> 00:40:44,910
people working on the rust open source

00:40:42,000 --> 00:40:47,490
stack here so this is this is fantastic

00:40:44,910 --> 00:40:50,790
and I think you know we're gonna see

00:40:47,490 --> 00:40:53,880
great things by the end of the year okay

00:40:50,790 --> 00:40:57,210
so so one final thing for me that's

00:40:53,880 --> 00:41:01,410
probably closest to my heart is growing

00:40:57,210 --> 00:41:05,280
Russ leadership I think you know for me

00:41:01,410 --> 00:41:07,050
personally it it's you know if you go

00:41:05,280 --> 00:41:08,820
back and look at that slide with the 35

00:41:07,050 --> 00:41:11,520
working groups like getting my head

00:41:08,820 --> 00:41:13,980
around just how big rust is and how much

00:41:11,520 --> 00:41:16,620
leadership that requires that's been a

00:41:13,980 --> 00:41:18,050
big lesson of this year and so I think

00:41:16,620 --> 00:41:20,980
we've really

00:41:18,050 --> 00:41:23,960
up our mentoring at the highest levels

00:41:20,980 --> 00:41:27,590
where you know we find people who have

00:41:23,960 --> 00:41:29,560
been doing great work and create a space

00:41:27,590 --> 00:41:31,130
for them to take on even more

00:41:29,560 --> 00:41:33,410
responsibilities and to take on

00:41:31,130 --> 00:41:36,080
leadership roles so part of that is we

00:41:33,410 --> 00:41:38,240
have actually added brand new sub teams

00:41:36,080 --> 00:41:40,490
or you know in many cases broken up a

00:41:38,240 --> 00:41:42,380
team into multiple sub teams that are

00:41:40,490 --> 00:41:45,860
more focused I think we'll be doing more

00:41:42,380 --> 00:41:48,830
of that and overall things have been

00:41:45,860 --> 00:41:51,650
growing like like gangbusters so so this

00:41:48,830 --> 00:41:54,410
has been super encouraging and I hope we

00:41:51,650 --> 00:41:57,500
continue in future years and you know it

00:41:54,410 --> 00:41:59,980
is interesting to note that this growth

00:41:57,500 --> 00:42:03,500
is largely coming outside of Mozilla and

00:41:59,980 --> 00:42:04,940
you know the amount of involvement of

00:42:03,500 --> 00:42:08,060
course for each of these people is

00:42:04,940 --> 00:42:10,550
different but I think the the message is

00:42:08,060 --> 00:42:12,110
that you know rust is not owned and

00:42:10,550 --> 00:42:14,060
operated by Mozilla it's owned and

00:42:12,110 --> 00:42:26,000
operated by its community which is where

00:42:14,060 --> 00:42:28,700
we want it to be all right so ultimately

00:42:26,000 --> 00:42:30,890
all of this work is to hopefully

00:42:28,700 --> 00:42:32,570
increase the usage of rust because I

00:42:30,890 --> 00:42:35,720
think that would make software better

00:42:32,570 --> 00:42:38,240
overall and I'm happy to say that we are

00:42:35,720 --> 00:42:42,110
seeing some increases this is a graph of

00:42:38,240 --> 00:42:45,140
the production rust users as shown on

00:42:42,110 --> 00:42:46,940
the rust friends page which if you your

00:42:45,140 --> 00:42:48,980
company is using rust in production and

00:42:46,940 --> 00:42:52,730
you would like to be on that page you

00:42:48,980 --> 00:42:54,710
can send in a pull request this is since

00:42:52,730 --> 00:42:58,490
we started that page and we're now at

00:42:54,710 --> 00:43:00,680
about 88 companies and one of the

00:42:58,490 --> 00:43:02,990
biggest companies even though Russ is

00:43:00,680 --> 00:43:05,330
not Mozilla Mozilla is a big production

00:43:02,990 --> 00:43:07,070
user this we're going to be hearing more

00:43:05,330 --> 00:43:11,200
about the stylo project from Josh

00:43:07,070 --> 00:43:13,760
Mathews later today but silo is the

00:43:11,200 --> 00:43:15,770
service style system service the

00:43:13,760 --> 00:43:18,920
experimental browser that Mozilla has

00:43:15,770 --> 00:43:21,290
been making that is all in rust and the

00:43:18,920 --> 00:43:24,050
style system has been pulled into

00:43:21,290 --> 00:43:26,570
Firefox from servo and you can try it

00:43:24,050 --> 00:43:29,760
out on Firefox nightly and the Firefox

00:43:26,570 --> 00:43:33,330
developer version and beta and it's

00:43:29,760 --> 00:43:34,860
faster everything's parallelized and red

00:43:33,330 --> 00:43:38,730
nurse really quickly so this is very

00:43:34,860 --> 00:43:40,770
exciting it's going to be shipping in a

00:43:38,730 --> 00:43:44,370
future version of Firefox in production

00:43:40,770 --> 00:43:47,190
so we're all really excited for that the

00:43:44,370 --> 00:43:49,170
number of crates available in the

00:43:47,190 --> 00:43:51,740
ecosystem has been growing as well we

00:43:49,170 --> 00:43:55,260
have over 10,000 crates available and

00:43:51,740 --> 00:43:59,280
are these crates being used yes they are

00:43:55,260 --> 00:44:02,400
in July we had over 15 million downloads

00:43:59,280 --> 00:44:05,430
of crates so yeah this is great

00:44:02,400 --> 00:44:09,110
we're going up into the right rust is

00:44:05,430 --> 00:44:09,110
blowing up this is so awesome

00:44:09,740 --> 00:44:15,870
let's let's put these big numbers in a

00:44:12,330 --> 00:44:18,870
little bit of context here you NPM is

00:44:15,870 --> 00:44:21,870
nodes package registry which is like

00:44:18,870 --> 00:44:25,890
crates i/o and they have their graph of

00:44:21,870 --> 00:44:32,730
downloads and let's see where where is

00:44:25,890 --> 00:44:36,150
that 15 oh yeah ok all right so we're

00:44:32,730 --> 00:44:38,640
not in the big leagues yet but this this

00:44:36,150 --> 00:44:41,100
is actually exciting to me because we

00:44:38,640 --> 00:44:44,370
here are all still in on the ground

00:44:41,100 --> 00:44:46,590
floor rust it is growing and we've got a

00:44:44,370 --> 00:44:48,690
lot of room to grow and room to make

00:44:46,590 --> 00:44:52,820
Chris IO butter before we get set p.m.

00:44:48,690 --> 00:44:57,330
scale but we're gonna get there someday

00:44:52,820 --> 00:44:58,290
but so the answer to to the question of

00:44:57,330 --> 00:45:02,760
are we there yet

00:44:58,290 --> 00:45:05,250
is a resounding no but we can get there

00:45:02,760 --> 00:45:07,740
with your help if you're thinking about

00:45:05,250 --> 00:45:09,900
getting involved now is a really great

00:45:07,740 --> 00:45:12,000
time with all the working groups and I

00:45:09,900 --> 00:45:14,640
we have a lot of contribution

00:45:12,000 --> 00:45:16,650
opportunities set up and people ready to

00:45:14,640 --> 00:45:20,570
help you contribute and we'd love to

00:45:16,650 --> 00:45:20,570

YouTube URL: https://www.youtube.com/watch?v=l1csV8WiDRQ


