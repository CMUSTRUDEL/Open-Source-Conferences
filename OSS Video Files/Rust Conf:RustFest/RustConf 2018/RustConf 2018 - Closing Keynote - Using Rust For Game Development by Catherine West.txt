Title: RustConf 2018 - Closing Keynote - Using Rust For Game Development by Catherine West
Publication date: 2018-09-06
Playlist: RustConf 2018
Description: 
	RustConf 2018 - Closing Keynote by Catherine West

When you’re just starting out in Rust, you start by building small programs. As we all know though, medium and large projects can have very different, unique kinds of problems that smaller projects never encounter. As our projects grow in size, we need to be increasingly concerned about code organization, separation of concerns, implementation hiding, and other techniques to manage growing complexity.

Most languages have tools and patterns to deal with this, and Rust is no exception. However, the patterns that we learned from other languages, especially in mainstream OO languages, are often unhelpful when applied to Rust, and this can lead to a roadblock when trying to transition to building moderate or large Rust programs.

This talk will cover a case study of a moderate sized game engine written in Rust and Lua, and show strategies for implementing things in Rust where common implementations in other mainstream languages are a poor fit. I’ll also discuss some examples of problems unique to Rust that ended up with very nice —but sometimes not obvious— solutions.

Along the way, I’d also like to discuss working with Rust in game development generally, and what it’s like getting Rust to run on mainstream game consoles.


Slides at https://kyren.github.io/rustconf_2018_slides/index.html

The blog post mentioned in this talk is at https://kyren.github.io/2018/09/14/rustconf-talk.html
Captions: 
	00:00:00,410 --> 00:00:20,510
[Music]

00:00:14,470 --> 00:00:22,250
hello I don't have a routine I feel I

00:00:20,510 --> 00:00:24,830
feel pressured now this might be the

00:00:22,250 --> 00:00:26,480
most boring talk I hope it's not but at

00:00:24,830 --> 00:00:28,460
least don't have a routine I also don't

00:00:26,480 --> 00:00:33,290
have any entertaining gifts

00:00:28,460 --> 00:00:36,559
unfortunately thank you

00:00:33,290 --> 00:00:38,809
so thank you for the introduction my

00:00:36,559 --> 00:00:40,670
name is Katherine West my talk is called

00:00:38,809 --> 00:00:42,739
using Russ for game development and

00:00:40,670 --> 00:00:44,870
since you know probably a lot of you

00:00:42,739 --> 00:00:46,309
here aren't game developers it's what

00:00:44,870 --> 00:00:49,880
you can learn from it even if you're not

00:00:46,309 --> 00:00:51,079
a game developer so the genesis of this

00:00:49,880 --> 00:00:53,329
talk is that

00:00:51,079 --> 00:00:55,969
you know on IRC or discord I keep

00:00:53,329 --> 00:00:58,190
getting these questions you know like

00:00:55,969 --> 00:01:01,370
how do you make a game from scratch and

00:00:58,190 --> 00:01:04,369
rust I've tried and maybe I run too

00:01:01,370 --> 00:01:06,710
you know the Barger complaining or I try

00:01:04,369 --> 00:01:10,550
to make a game and I need internal

00:01:06,710 --> 00:01:13,399
mutability or maybe it's just like

00:01:10,550 --> 00:01:14,750
they've tried this and they seem

00:01:13,399 --> 00:01:18,950
skeptical because they think that the

00:01:14,750 --> 00:01:20,810
broad tracker is very limiting and I

00:01:18,950 --> 00:01:21,920
think that these are all kind of these

00:01:20,810 --> 00:01:25,070
three questions are kind of the same

00:01:21,920 --> 00:01:27,409
this is like beginner fighting the burro

00:01:25,070 --> 00:01:29,810
checker this is intermediate fighting to

00:01:27,409 --> 00:01:34,790
protect her and this is advanced

00:01:29,810 --> 00:01:36,650
fighting the virus checker but you know

00:01:34,790 --> 00:01:38,479
obviously in case it's not clear because

00:01:36,650 --> 00:01:40,430
I'm here at Russ conference Russ comp

00:01:38,479 --> 00:01:43,280
talking about game development I don't

00:01:40,430 --> 00:01:47,090
necessarily agree with these um so but

00:01:43,280 --> 00:01:48,290
the the trick is is that you know you

00:01:47,090 --> 00:01:50,420
want to give an answer to these kinds of

00:01:48,290 --> 00:01:54,110
questions these kinds of questions and

00:01:50,420 --> 00:01:56,180
you know sometimes a small answer is not

00:01:54,110 --> 00:01:59,000
appropriate for a question that's about

00:01:56,180 --> 00:02:04,310
what happens when you grow something

00:01:59,000 --> 00:02:08,299
beyond the small so this is my medium

00:02:04,310 --> 00:02:10,729
sized oops I've already messed up this

00:02:08,299 --> 00:02:15,260
is my medium sized answer to this

00:02:10,729 --> 00:02:17,930
question so before I go any further I'm

00:02:15,260 --> 00:02:20,329
gonna have a lot of code in these slides

00:02:17,930 --> 00:02:21,680
and I really am sorry if people in the

00:02:20,329 --> 00:02:23,750
back can't see all these slides will be

00:02:21,680 --> 00:02:25,040
available online but even better than

00:02:23,750 --> 00:02:27,530
that

00:02:25,040 --> 00:02:29,540
I actually didn't write this talk for us

00:02:27,530 --> 00:02:32,060
Bres Kampf I I actually wrote a

00:02:29,540 --> 00:02:34,720
long-form blog post of this this is way

00:02:32,060 --> 00:02:37,340
longer and probably way more interesting

00:02:34,720 --> 00:02:39,440
so I'm gonna make that blog post public

00:02:37,340 --> 00:02:41,960
at some point in the next week so if you

00:02:39,440 --> 00:02:45,110
don't like my talk you maybe will like

00:02:41,960 --> 00:02:50,300
my blog post and if you can't see then

00:02:45,110 --> 00:02:52,640
the blog post will be there so I think

00:02:50,300 --> 00:02:55,340
the real reason that I get a lot of

00:02:52,640 --> 00:02:58,100
these questions is that rust makes rust

00:02:55,340 --> 00:03:01,400
does make certain patterns more painful

00:02:58,100 --> 00:03:03,500
than others this is a great thing this

00:03:01,400 --> 00:03:06,200
is probably my favorite feature of rust

00:03:03,500 --> 00:03:11,180
is that it gives me this pressure not to

00:03:06,200 --> 00:03:13,340
do the easy bad thing you know and and

00:03:11,180 --> 00:03:15,560
what I found is is that these these

00:03:13,340 --> 00:03:19,160
things that rust kind of guides me to do

00:03:15,560 --> 00:03:21,050
are oftentimes the easiest generally

00:03:19,160 --> 00:03:23,930
whether or not I was written in rust and

00:03:21,050 --> 00:03:28,430
the reason I know this is because I had

00:03:23,930 --> 00:03:31,400
to learn it the hard way and I didn't

00:03:28,430 --> 00:03:33,020
have rust help I'm gonna talk a little

00:03:31,400 --> 00:03:34,370
bit about the game I worked on a

00:03:33,020 --> 00:03:37,670
charcoal fish called Starbound

00:03:34,370 --> 00:03:39,350
I'm gonna pick on myself a lot I made a

00:03:37,670 --> 00:03:40,640
bunch of mistakes and I'm gonna talk

00:03:39,350 --> 00:03:44,720
about him they're all my faults I can

00:03:40,640 --> 00:03:45,770
seems for me to pick on myself and what

00:03:44,720 --> 00:03:46,940
I should have done like one of the

00:03:45,770 --> 00:03:49,730
things I should have done is I should

00:03:46,940 --> 00:03:51,230
have used something like ECS design and

00:03:49,730 --> 00:03:55,850
maybe if I'd use rust it would have

00:03:51,230 --> 00:03:59,020
given me the right guidance and pain to

00:03:55,850 --> 00:04:02,510
maybe pick these better designs faster

00:03:59,020 --> 00:04:05,950
so if you don't know what ECS is don't

00:04:02,510 --> 00:04:08,900
worry because they're gonna build one so

00:04:05,950 --> 00:04:11,930
the this talk is going to be working

00:04:08,900 --> 00:04:14,870
through a game engine from the

00:04:11,930 --> 00:04:15,920
simplistic impossible possibly be to

00:04:14,870 --> 00:04:18,680
something that I think is appropriate

00:04:15,920 --> 00:04:23,360
for like a midsize project and it's

00:04:18,680 --> 00:04:24,680
gonna have these any CS in it and the

00:04:23,360 --> 00:04:26,840
reason that this works so well with rust

00:04:24,680 --> 00:04:30,590
is that rust tends to reward data

00:04:26,840 --> 00:04:31,880
oriented design and I might be using

00:04:30,590 --> 00:04:33,260
this term a little bit different than a

00:04:31,880 --> 00:04:34,580
lot of people use it a lot of you know

00:04:33,260 --> 00:04:37,130
if you go look upon the weak upda page

00:04:34,580 --> 00:04:39,830
for data oriented design you'll see a

00:04:37,130 --> 00:04:40,729
lot of things about like cache locality

00:04:39,830 --> 00:04:42,110
and cache behavior

00:04:40,729 --> 00:04:43,279
performance and things like that but I

00:04:42,110 --> 00:04:47,449
don't actually think that that's like

00:04:43,279 --> 00:04:49,789
the most important part of it and I

00:04:47,449 --> 00:04:52,490
think it has a lot more meaning for

00:04:49,789 --> 00:04:53,569
language like rust and but I also think

00:04:52,490 --> 00:04:58,539
that these are kind of two sides of the

00:04:53,569 --> 00:05:01,309
same coin but we'll get into that so

00:04:58,539 --> 00:05:04,969
what is the game what is a video game

00:05:01,309 --> 00:05:08,029
its simplest possible form you make a

00:05:04,969 --> 00:05:10,460
game state so this is obviously very

00:05:08,029 --> 00:05:13,159
this would be very complicated and large

00:05:10,460 --> 00:05:14,960
and you know your entire game fits in

00:05:13,159 --> 00:05:17,270
this one structure right so players

00:05:14,960 --> 00:05:19,909
entities monsters whatever it goes in

00:05:17,270 --> 00:05:25,219
this one structure and then you go into

00:05:19,909 --> 00:05:29,689
a loop so a video game you you you take

00:05:25,219 --> 00:05:32,330
input right like from a controller you

00:05:29,689 --> 00:05:34,999
take input and then you run a bunch of

00:05:32,330 --> 00:05:36,860
code to update your game state based on

00:05:34,999 --> 00:05:38,689
the input you you got so if you're

00:05:36,860 --> 00:05:41,499
jumping you press the spacebar or jump

00:05:38,689 --> 00:05:46,099
button and your player starts jumping

00:05:41,499 --> 00:05:51,399
then you render what you got and you

00:05:46,099 --> 00:05:55,449
wait for the next frame repeat shoot

00:05:51,399 --> 00:06:00,860
sorry okay I need to stop clicking that

00:05:55,449 --> 00:06:04,520
so then you repeat so what like this is

00:06:00,860 --> 00:06:06,229
the simplest possible game you won't you

00:06:04,520 --> 00:06:08,089
can't even call it an engine you make a

00:06:06,229 --> 00:06:12,169
game state you run a bunch of code over

00:06:08,089 --> 00:06:16,339
it repeat so what can we learn from this

00:06:12,169 --> 00:06:17,839
ultra simplistic example one I don't

00:06:16,339 --> 00:06:20,449
recommend I don't necessarily recommend

00:06:17,839 --> 00:06:23,089
you make a game this way but you could

00:06:20,449 --> 00:06:24,319
make a game this way I promise you can

00:06:23,089 --> 00:06:26,649
make a game this way because I've seen

00:06:24,319 --> 00:06:28,520
them I've seen these source code to

00:06:26,649 --> 00:06:32,330
unreleased games that are written this

00:06:28,520 --> 00:06:34,339
way with procedural ball of mud 12,000

00:06:32,330 --> 00:06:38,330
line world generation method I won't

00:06:34,339 --> 00:06:38,809
name names but I've seen them and if you

00:06:38,330 --> 00:06:40,249
did it

00:06:38,809 --> 00:06:42,110
you'd have minimal problems with the

00:06:40,249 --> 00:06:43,659
Perot checker and a little bit of

00:06:42,110 --> 00:06:46,159
thought will tell you why

00:06:43,659 --> 00:06:48,289
every one of these procedures that you

00:06:46,159 --> 00:06:51,620
run over your game gets complete and

00:06:48,289 --> 00:06:54,140
total mutable access to the entire game

00:06:51,620 --> 00:06:56,690
state so if you have complete

00:06:54,140 --> 00:06:57,560
total mutable access you probably are

00:06:56,690 --> 00:06:58,430
gonna run in some problems with the

00:06:57,560 --> 00:07:03,950
borrowed checker because you've borrowed

00:06:58,430 --> 00:07:05,120
everything and you can was one of the

00:07:03,950 --> 00:07:06,260
things that things that the rest

00:07:05,120 --> 00:07:08,480
compiler will do for you is it allow you

00:07:06,260 --> 00:07:10,160
to split Barb's save it if you have a

00:07:08,480 --> 00:07:12,320
structure with a bunch of fields you can

00:07:10,160 --> 00:07:13,340
borrow one field and then immutably and

00:07:12,320 --> 00:07:14,630
then borrow another field meter billy

00:07:13,340 --> 00:07:16,540
and as long as it's a public structure

00:07:14,630 --> 00:07:19,700
rust understands how to deal with that

00:07:16,540 --> 00:07:23,060
but it has some downsides namely that

00:07:19,700 --> 00:07:27,280
everything is in one shine it morley

00:07:23,060 --> 00:07:29,870
global mutable mega seat right

00:07:27,280 --> 00:07:31,700
everything news procedural you could

00:07:29,870 --> 00:07:33,470
very end up very easily end up with a

00:07:31,700 --> 00:07:34,820
procedural ball of mode where you know

00:07:33,470 --> 00:07:36,440
your input system and this is supposed

00:07:34,820 --> 00:07:38,990
to make the player jump but I could just

00:07:36,440 --> 00:07:40,970
lean over here and just mutate the

00:07:38,990 --> 00:07:42,410
physic state because nothing is stopping

00:07:40,970 --> 00:07:42,860
you since you have everything borrowed

00:07:42,410 --> 00:07:45,110
at once

00:07:42,860 --> 00:07:46,850
so there are some downsides but it's

00:07:45,110 --> 00:07:48,980
important to keep this in mind because

00:07:46,850 --> 00:07:51,380
we're gonna try and prove this but we

00:07:48,980 --> 00:07:54,530
know this could theoretically work and

00:07:51,380 --> 00:07:56,570
we're gonna improve on it we're an

00:07:54,530 --> 00:08:00,230
improvement first we're gonna improve on

00:07:56,570 --> 00:08:03,170
it in the wrong way and we're gonna do

00:08:00,230 --> 00:08:06,650
it with the example of Starbound because

00:08:03,170 --> 00:08:08,540
I did it so we're gonna try

00:08:06,650 --> 00:08:11,000
object-oriented design in order to

00:08:08,540 --> 00:08:12,170
improve our game engine so what are the

00:08:11,000 --> 00:08:14,690
principles of object-oriented design

00:08:12,170 --> 00:08:18,020
there's the single responsibility

00:08:14,690 --> 00:08:19,730
principle which says you know okay you

00:08:18,020 --> 00:08:21,620
should take your data and you should

00:08:19,730 --> 00:08:23,420
bundle your data up into logical

00:08:21,620 --> 00:08:24,650
components and then you should take the

00:08:23,420 --> 00:08:26,570
functions that operate on those

00:08:24,650 --> 00:08:29,270
components and call the methods and

00:08:26,570 --> 00:08:32,990
bundle them together and it's called a

00:08:29,270 --> 00:08:35,030
class encapsulation says that the data

00:08:32,990 --> 00:08:36,890
that you bundle into a class should be

00:08:35,030 --> 00:08:39,050
private by default or and you should

00:08:36,890 --> 00:08:41,260
lean towards privacy because you know

00:08:39,050 --> 00:08:45,560
somebody else might mess with your data

00:08:41,260 --> 00:08:48,950
and it they might you might have to like

00:08:45,560 --> 00:08:50,990
it mess up invariance or and then that

00:08:48,950 --> 00:08:53,570
you should lean towards accessing that

00:08:50,990 --> 00:08:56,150
data through members the abstraction

00:08:53,570 --> 00:08:58,160
principle says that it's rather than

00:08:56,150 --> 00:08:58,670
depending on like having one class one

00:08:58,160 --> 00:09:01,100
on another

00:08:58,670 --> 00:09:03,020
you should lean towards depending on

00:09:01,100 --> 00:09:04,520
some kind of abstract interface or like

00:09:03,020 --> 00:09:06,950
in C++ it would be like a pure virtual

00:09:04,520 --> 00:09:07,920
interface and this is related to the

00:09:06,950 --> 00:09:12,749
last point

00:09:07,920 --> 00:09:14,759
coupling which says that you you know if

00:09:12,749 --> 00:09:16,589
you you shouldn't couple the design of

00:09:14,759 --> 00:09:20,369
one class to the design of another and

00:09:16,589 --> 00:09:23,670
instead interact through these pure

00:09:20,369 --> 00:09:25,139
abstract interfaces so let's try this

00:09:23,670 --> 00:09:26,850
let's see how it works

00:09:25,139 --> 00:09:29,669
spoiler it it doesn't really work that

00:09:26,850 --> 00:09:32,369
well but we'll get there so this is kind

00:09:29,669 --> 00:09:33,809
of a sorry if it's hard to see back

00:09:32,369 --> 00:09:36,569
there again all these slides will be

00:09:33,809 --> 00:09:39,329
available this is kind of like the the

00:09:36,569 --> 00:09:42,660
smallest possible Starbound

00:09:39,329 --> 00:09:44,369
game state so you have three entities

00:09:42,660 --> 00:09:46,679
and if you don't know NC is because we

00:09:44,369 --> 00:09:50,069
using all this game type jargon I think

00:09:46,679 --> 00:09:51,419
if you have give a world everything that

00:09:50,069 --> 00:09:52,470
static and doesn't move you can't

00:09:51,419 --> 00:09:54,059
interact so they can't do anything with

00:09:52,470 --> 00:09:55,619
it but you can maybe stand on it that's

00:09:54,059 --> 00:09:57,480
you know your static data and then

00:09:55,619 --> 00:10:01,139
anything you can interact with in games

00:09:57,480 --> 00:10:02,759
is usually they're all entities so in

00:10:01,139 --> 00:10:05,609
this case our entities are the player

00:10:02,759 --> 00:10:07,439
for thing you control monster may be

00:10:05,609 --> 00:10:08,459
like a little critter going around that

00:10:07,439 --> 00:10:11,249
you shouldn't touch because it'll damage

00:10:08,459 --> 00:10:14,850
you and then maybe some NPCs that you

00:10:11,249 --> 00:10:17,579
can talk to you and then we have our

00:10:14,850 --> 00:10:18,989
game state which is the you know the

00:10:17,579 --> 00:10:21,869
struct that we made that's going to

00:10:18,989 --> 00:10:23,999
contain the entire state of our game one

00:10:21,869 --> 00:10:27,360
thing to note here is that our game

00:10:23,999 --> 00:10:29,759
state is like a list of all the the non

00:10:27,360 --> 00:10:32,249
entity data that I talked about and then

00:10:29,759 --> 00:10:34,949
this this this list of entities and we

00:10:32,249 --> 00:10:37,290
got this if you don't know C++ I'm sorry

00:10:34,949 --> 00:10:38,939
but hopefully it's not too distracting

00:10:37,290 --> 00:10:40,919
we have the shared pointer to void

00:10:38,939 --> 00:10:45,149
because we don't know what to put there

00:10:40,919 --> 00:10:48,419
yet so you know we have entities as an

00:10:45,149 --> 00:10:50,429
NPC a monster and a player so the type

00:10:48,419 --> 00:10:53,999
system is kind of in our way so we have

00:10:50,429 --> 00:10:55,949
a shared pointer to void and we're gonna

00:10:53,999 --> 00:10:58,499
improve this in a second another thing

00:10:55,949 --> 00:11:01,470
to note from this example is that one of

00:10:58,499 --> 00:11:02,970
our internal states I have this I'm

00:11:01,470 --> 00:11:04,169
gonna use this a lot and this is gonna

00:11:02,970 --> 00:11:07,439
end up being important but there's this

00:11:04,169 --> 00:11:08,669
entity index type and this is actually

00:11:07,439 --> 00:11:11,369
really interesting because this is super

00:11:08,669 --> 00:11:13,859
common in in C++ game engines in fact

00:11:11,369 --> 00:11:15,569
I've never seen a systems programming

00:11:13,859 --> 00:11:18,209
language kind of game engine that

00:11:15,569 --> 00:11:20,519
doesn't have these and you know this is

00:11:18,209 --> 00:11:21,440
this is a C++ example so you might think

00:11:20,519 --> 00:11:23,840
like okay well

00:11:21,440 --> 00:11:25,520
field is player IDs so like you know

00:11:23,840 --> 00:11:26,810
serve as a multiplayer game you need to

00:11:25,520 --> 00:11:29,180
keep a list of all the entities that are

00:11:26,810 --> 00:11:32,360
our player but you know why don't you

00:11:29,180 --> 00:11:33,850
use a pointer it's C++ you know the we

00:11:32,360 --> 00:11:37,490
live dangerously let's keep a pointer

00:11:33,850 --> 00:11:40,430
and the thing is is that nobody does

00:11:37,490 --> 00:11:42,290
this because it's wildly unsafe if you

00:11:40,430 --> 00:11:44,570
keep internal pointers they will become

00:11:42,290 --> 00:11:47,560
invalidated and your game will crash so

00:11:44,570 --> 00:11:50,510
nobody in the system's game development

00:11:47,560 --> 00:11:53,630
environment like that I all game engines

00:11:50,510 --> 00:11:55,490
have this it's either an ID or some kind

00:11:53,630 --> 00:11:57,410
of index or something to identify

00:11:55,490 --> 00:11:59,420
entities and this is important because

00:11:57,410 --> 00:12:02,960
we have to do this in a lot of places in

00:11:59,420 --> 00:12:04,700
rust but it's the best idea and it has

00:12:02,960 --> 00:12:06,350
other benefits like you know for Network

00:12:04,700 --> 00:12:09,320
serialization and fellas it's hard to

00:12:06,350 --> 00:12:11,270
serial as a pointer right but you know

00:12:09,320 --> 00:12:13,220
this is very common in all game engines

00:12:11,270 --> 00:12:17,690
this is kind of an important thing so

00:12:13,220 --> 00:12:19,040
okay so we we had this sure pointed a

00:12:17,690 --> 00:12:20,300
void and it really sucks because we

00:12:19,040 --> 00:12:23,210
can't do anything with shared pointer to

00:12:20,300 --> 00:12:25,370
void so let's make this we're

00:12:23,210 --> 00:12:26,810
programming an object Orion we're we're

00:12:25,370 --> 00:12:28,450
doing object-oriented design right so

00:12:26,810 --> 00:12:31,070
let's make this interface called entity

00:12:28,450 --> 00:12:32,840
so let's very quickly think of all the

00:12:31,070 --> 00:12:38,420
things that will be common to every

00:12:32,840 --> 00:12:39,490
single entity position I'm done I can't

00:12:38,420 --> 00:12:42,530
think of anything else

00:12:39,490 --> 00:12:44,330
you know you might in our example all of

00:12:42,530 --> 00:12:46,250
the the player of the monster in the NPC

00:12:44,330 --> 00:12:48,110
how all have velocity they all have

00:12:46,250 --> 00:12:52,010
physics but maybe have a stationary

00:12:48,110 --> 00:12:53,600
entity it turns out that yeah sorry

00:12:52,010 --> 00:12:56,350
maybe it was stationary entity it turns

00:12:53,600 --> 00:12:59,570
out that there's not very much in common

00:12:56,350 --> 00:13:01,730
almost at all so you start one actually

00:12:59,570 --> 00:13:03,050
has an entity interface like this and

00:13:01,730 --> 00:13:05,060
it's filled with a bunch of methods that

00:13:03,050 --> 00:13:07,730
all returned like basically option

00:13:05,060 --> 00:13:10,040
because some entities don't have them

00:13:07,730 --> 00:13:11,060
and then like you're kind of defeating

00:13:10,040 --> 00:13:14,600
the purpose of having an entity

00:13:11,060 --> 00:13:16,670
interface but anyway so so but one thing

00:13:14,600 --> 00:13:18,350
we can do is we can treat we can give

00:13:16,670 --> 00:13:20,270
them methods so we're trying to do

00:13:18,350 --> 00:13:23,150
object-oriented design so let's say that

00:13:20,270 --> 00:13:24,650
every entity can handle input state so

00:13:23,150 --> 00:13:27,350
like a player might start a jump a hit

00:13:24,650 --> 00:13:30,320
space and then every entity has to

00:13:27,350 --> 00:13:32,660
update themselves and they have to take

00:13:30,320 --> 00:13:33,560
in the rest of the game state so like if

00:13:32,660 --> 00:13:34,700
you're a monster and you're talking a

00:13:33,560 --> 00:13:36,620
player you have to know where

00:13:34,700 --> 00:13:37,940
because you know so you and you have to

00:13:36,620 --> 00:13:40,160
maybe know where other monsters are so

00:13:37,940 --> 00:13:41,780
you need the rest of the game state and

00:13:40,160 --> 00:13:43,270
then they can render themselves somehow

00:13:41,780 --> 00:13:46,520
we're not really gonna talk about that

00:13:43,270 --> 00:13:48,410
so then the player you know implements

00:13:46,520 --> 00:13:51,680
this interface player has a position the

00:13:48,410 --> 00:13:53,390
handles input monster and a PC are

00:13:51,680 --> 00:13:55,460
exactly the same and now we can keep a

00:13:53,390 --> 00:14:00,050
shared pointer to entity instead of a

00:13:55,460 --> 00:14:03,920
shared pointer to void okay this seems

00:14:00,050 --> 00:14:06,350
like it could work new requirement start

00:14:03,920 --> 00:14:07,640
coming in so you make a video game

00:14:06,350 --> 00:14:09,550
your constant gonna be experimenting

00:14:07,640 --> 00:14:11,690
cost I can have new requirements

00:14:09,550 --> 00:14:13,310
monsters can track players because they

00:14:11,690 --> 00:14:14,600
know the players position but they

00:14:13,310 --> 00:14:15,770
should track because it's a multiplayer

00:14:14,600 --> 00:14:18,410
game they should track the player that

00:14:15,770 --> 00:14:21,500
has the lowest health all right well

00:14:18,410 --> 00:14:23,480
health is private to you player because

00:14:21,500 --> 00:14:24,410
we were practicing encapsulation so

00:14:23,480 --> 00:14:26,240
that's okay

00:14:24,410 --> 00:14:27,830
we'll make an accessor it's not a big

00:14:26,240 --> 00:14:31,220
deal

00:14:27,830 --> 00:14:33,650
what requirement start coming in the

00:14:31,220 --> 00:14:37,010
monster should not go after players who

00:14:33,650 --> 00:14:38,180
are marked as admins so start buying

00:14:37,010 --> 00:14:39,860
some of the player gaming kept this

00:14:38,180 --> 00:14:42,410
concept of admin it's not super

00:14:39,860 --> 00:14:44,300
important but so okay we can make more

00:14:42,410 --> 00:14:49,700
accessors not a big deal

00:14:44,300 --> 00:14:51,320
well add is admin no problem okay well

00:14:49,700 --> 00:14:55,700
we have to continue on with development

00:14:51,320 --> 00:14:57,380
so let's let's we need monsters to start

00:14:55,700 --> 00:14:59,690
damaging players so if a player gets too

00:14:57,380 --> 00:15:01,100
close to a monster you know that you

00:14:59,690 --> 00:15:01,460
know he has some kind of geometry around

00:15:01,100 --> 00:15:02,930
it

00:15:01,460 --> 00:15:04,370
amp the players geometry overlap so the

00:15:02,930 --> 00:15:07,900
monster geometry the player should be

00:15:04,370 --> 00:15:11,720
hurt well okay so let's think about this

00:15:07,900 --> 00:15:12,980
where do we put it we're doing

00:15:11,720 --> 00:15:16,220
object-oriented programming so we should

00:15:12,980 --> 00:15:17,570
take our methods and apply it to the to

00:15:16,220 --> 00:15:19,460
the to the place that it makes the most

00:15:17,570 --> 00:15:23,000
sense to go so I guess the players

00:15:19,460 --> 00:15:26,240
damage themselves but you could also say

00:15:23,000 --> 00:15:29,150
that monsters do the damage they're the

00:15:26,240 --> 00:15:32,810
thing that does it there's not actually

00:15:29,150 --> 00:15:35,150
a great place to put it so we can pick

00:15:32,810 --> 00:15:37,160
one we'll just pick player players

00:15:35,150 --> 00:15:39,170
damage to themselves the player will

00:15:37,160 --> 00:15:42,020
check its own bounding box with that of

00:15:39,170 --> 00:15:43,520
the monster and we'll increment its own

00:15:42,020 --> 00:15:45,260
health if we did it the other way then

00:15:43,520 --> 00:15:47,210
monsters that have to exit have access

00:15:45,260 --> 00:15:48,150
to player's health which like mutable

00:15:47,210 --> 00:15:51,060
access it

00:15:48,150 --> 00:15:52,770
either so we'll do it this way and we

00:15:51,060 --> 00:15:55,410
need more accessors because you know now

00:15:52,770 --> 00:15:57,510
the monster has this damaged region and

00:15:55,410 --> 00:16:01,320
the clearest to check it so one more

00:15:57,510 --> 00:16:04,470
access er it's not a big deal so okay so

00:16:01,320 --> 00:16:06,390
you're making a stealth game and if you

00:16:04,470 --> 00:16:08,730
if the player walks next to a monster

00:16:06,390 --> 00:16:10,920
and they're on the ground the monster

00:16:08,730 --> 00:16:12,510
might react in some way that's an a

00:16:10,920 --> 00:16:15,630
problem well at an on-ground access er

00:16:12,510 --> 00:16:17,670
to player except we've been practicing

00:16:15,630 --> 00:16:20,040
good object-oriented design and our

00:16:17,670 --> 00:16:21,390
player has the sub object right you know

00:16:20,040 --> 00:16:23,520
we know that we shouldn't use

00:16:21,390 --> 00:16:25,050
inheritance we've been told that a lot

00:16:23,520 --> 00:16:27,570
you know inheritance if I wish use

00:16:25,050 --> 00:16:31,280
composition so we've composed our

00:16:27,570 --> 00:16:33,840
entities with this physics object and

00:16:31,280 --> 00:16:35,970
only the physics system knows whether

00:16:33,840 --> 00:16:39,330
you're hit on the ground not a problem

00:16:35,970 --> 00:16:40,890
well add accessors to physics and we'll

00:16:39,330 --> 00:16:42,830
add an access to the player that just

00:16:40,890 --> 00:16:46,110
passes on to the access to the physics

00:16:42,830 --> 00:16:48,000
and as you can see that you kind of need

00:16:46,110 --> 00:16:50,400
more and more of these and then the more

00:16:48,000 --> 00:16:53,090
you do these these patterns like

00:16:50,400 --> 00:16:57,290
composition the more accesses you need

00:16:53,090 --> 00:17:04,520
how many could you possibly need really

00:16:57,290 --> 00:17:07,380
well this is the for real actual

00:17:04,520 --> 00:17:08,820
Starbound player class copied from the

00:17:07,380 --> 00:17:11,070
Starbound source code as of the latest

00:17:08,820 --> 00:17:12,120
version you can tell that we've been

00:17:11,070 --> 00:17:13,860
following good object our new

00:17:12,120 --> 00:17:17,790
programming and we've been using a whole

00:17:13,860 --> 00:17:18,959
bunch of these your virtual interfaces

00:17:17,790 --> 00:17:20,070
because you know you shouldn't you

00:17:18,959 --> 00:17:21,420
shouldn't have something depend on the

00:17:20,070 --> 00:17:27,030
player necessarily you might have

00:17:21,420 --> 00:17:29,310
something else that can emot-- so you

00:17:27,030 --> 00:17:30,810
know we we I think there's eight or nine

00:17:29,310 --> 00:17:33,060
of these there's actually a little more

00:17:30,810 --> 00:17:36,810
like thirty five of these interfaces

00:17:33,060 --> 00:17:38,400
inside Starbound there's a bunch of them

00:17:36,810 --> 00:17:40,230
so let's let's just quickly go through

00:17:38,400 --> 00:17:43,190
all the accessors in this class and is

00:17:40,230 --> 00:17:43,190
so so

00:17:47,150 --> 00:17:51,540
yeah you got it you got to know how much

00:17:49,920 --> 00:17:53,520
energy the player has gotta know how

00:17:51,540 --> 00:17:56,850
much breath they have their protection

00:17:53,520 --> 00:18:01,320
whether they're forced nude what kind of

00:17:56,850 --> 00:18:02,820
game that I make okay that's that's for

00:18:01,320 --> 00:18:05,460
something I know it's for Sates foot

00:18:02,820 --> 00:18:08,070
it's for like the the player creator or

00:18:05,460 --> 00:18:12,270
something like that and if you're new

00:18:08,070 --> 00:18:15,680
you know you just want to be new keeps

00:18:12,270 --> 00:18:18,690
going and going and going oh

00:18:15,680 --> 00:18:19,890
whether they're an admin or not it was

00:18:18,690 --> 00:18:22,860
up there somewhere I don't remember

00:18:19,890 --> 00:18:26,600
where it is admin yeah oh whether

00:18:22,860 --> 00:18:31,820
they're dead that sounds important oh

00:18:26,600 --> 00:18:31,820
okay okay there's like 400 lines apiece

00:18:33,950 --> 00:18:42,690
the this is Lara the number of methods

00:18:39,540 --> 00:18:44,760
to the player class is like 200 lines

00:18:42,690 --> 00:18:48,000
longer than the number of members in the

00:18:44,760 --> 00:18:50,820
player class somehow I don't know this

00:18:48,000 --> 00:18:54,390
one's great because this is some like

00:18:50,820 --> 00:18:58,050
sub-object for for like the ship's AI

00:18:54,390 --> 00:18:59,910
and we just gave up and now like oh you

00:18:58,050 --> 00:19:01,860
can get it you know it muta bleep it's

00:18:59,910 --> 00:19:03,150
an access er and also we need to mutate

00:19:01,860 --> 00:19:05,130
it and I'm tired of writing I try to

00:19:03,150 --> 00:19:06,630
tired of writing methods so we just we

00:19:05,130 --> 00:19:08,400
just like there is literally no

00:19:06,630 --> 00:19:14,400
difference between this and just a

00:19:08,400 --> 00:19:16,680
public number so this is don't do that

00:19:14,400 --> 00:19:18,900
total maintains that way but we're gonna

00:19:16,680 --> 00:19:20,400
try this and rust it anyway and we're

00:19:18,900 --> 00:19:22,650
gonna see what we can learn from it and

00:19:20,400 --> 00:19:27,000
what you're gonna find is that this kind

00:19:22,650 --> 00:19:29,520
of design fails quicker and there's a

00:19:27,000 --> 00:19:31,490
reason for this okay so we start with

00:19:29,520 --> 00:19:35,550
the simplest object or name C++ version

00:19:31,490 --> 00:19:36,930
we have an entity interface and you know

00:19:35,550 --> 00:19:39,390
we have our game state list of entities

00:19:36,930 --> 00:19:43,020
we're gonna translate it to rust we now

00:19:39,390 --> 00:19:46,140
we have an entity trait whoo and a list

00:19:43,020 --> 00:19:48,570
of entities very quickly this this

00:19:46,140 --> 00:19:50,370
vector of option you know we have a box

00:19:48,570 --> 00:19:52,230
entity because it's it's a trait so we

00:19:50,370 --> 00:19:53,850
can't keep a direct copy of it but also

00:19:52,230 --> 00:19:56,010
just just so you know like this there's

00:19:53,850 --> 00:19:56,690
this option here because keeping a

00:19:56,010 --> 00:19:58,310
vector

00:19:56,690 --> 00:19:59,930
entities so you know you might remove an

00:19:58,310 --> 00:20:01,280
entity in the option becomes none then

00:19:59,930 --> 00:20:04,580
you allocate a new entity you have to go

00:20:01,280 --> 00:20:07,760
find a nun to put it in and then the

00:20:04,580 --> 00:20:09,770
rest are going to so okay right away

00:20:07,760 --> 00:20:13,310
this is already wrong this is already

00:20:09,770 --> 00:20:15,500
broken so an entity rise to update

00:20:13,310 --> 00:20:18,260
itself right it gets a mutable reference

00:20:15,500 --> 00:20:20,180
to self and a mutable reference to game

00:20:18,260 --> 00:20:21,290
state even if it got an immutable

00:20:20,180 --> 00:20:24,050
reference this would still be a problem

00:20:21,290 --> 00:20:26,870
because an entity gets a mutable

00:20:24,050 --> 00:20:28,820
reference to self and it's also inside

00:20:26,870 --> 00:20:30,530
the game state all of our data and the

00:20:28,820 --> 00:20:33,770
whole game is in this game state that's

00:20:30,530 --> 00:20:36,320
mutable aliasing you can't do that so

00:20:33,770 --> 00:20:38,240
right away we try to make a method and

00:20:36,320 --> 00:20:39,770
it doesn't work so there's a bunch of

00:20:38,240 --> 00:20:44,210
ways you can solve this and most of them

00:20:39,770 --> 00:20:46,460
are really bad you could do things like

00:20:44,210 --> 00:20:49,280
remove the entity and then call update

00:20:46,460 --> 00:20:51,830
and then put the entity back it doesn't

00:20:49,280 --> 00:20:56,600
work the best thing you can do which is

00:20:51,830 --> 00:20:58,850
bad is to try interior mutability so we

00:20:56,600 --> 00:21:02,140
have rough cell now all of our methods

00:20:58,850 --> 00:21:05,330
take immutable references to self and

00:21:02,140 --> 00:21:07,970
this sucks if you try to do this you go

00:21:05,330 --> 00:21:10,790
on IRC and you say I need why do I need

00:21:07,970 --> 00:21:13,250
this Russ sucks I need I need rough cell

00:21:10,790 --> 00:21:15,170
you're fighting the borrow checker it's

00:21:13,250 --> 00:21:17,090
helpful but you know not necessarily

00:21:15,170 --> 00:21:20,290
helpful if you've ever found yourself in

00:21:17,090 --> 00:21:25,160
that situation this talk is for you so

00:21:20,290 --> 00:21:26,510
it gets worse say you know you you you

00:21:25,160 --> 00:21:28,490
have this this entity trait that's

00:21:26,510 --> 00:21:29,720
pretty sparse this is something it

00:21:28,490 --> 00:21:31,720
actually shows up in Starbound you have

00:21:29,720 --> 00:21:34,520
these like we have like a tag system

00:21:31,720 --> 00:21:36,470
everything is turnout we have this tag

00:21:34,520 --> 00:21:38,990
system where you can you get a list like

00:21:36,470 --> 00:21:42,260
maybe and Starbound it's like a list of

00:21:38,990 --> 00:21:43,820
strings you know this tag method on the

00:21:42,260 --> 00:21:46,460
light of the lifetime so it's clear but

00:21:43,820 --> 00:21:49,790
this borrows the whole entity no matter

00:21:46,460 --> 00:21:51,740
what and returns a reference to tags so

00:21:49,790 --> 00:21:54,680
you know Artie this is a problem that's

00:21:51,740 --> 00:21:57,230
a lot of borrowing and maybe you know if

00:21:54,680 --> 00:21:59,180
you want to get the get the the tags

00:21:57,230 --> 00:22:00,760
from entity and then do some operation

00:21:59,180 --> 00:22:03,170
that involves like mutating the world

00:22:00,760 --> 00:22:05,270
you know maybe that's a problem and it's

00:22:03,170 --> 00:22:07,190
even worse because if you need internal

00:22:05,270 --> 00:22:09,789
mutability you can't return a reference

00:22:07,190 --> 00:22:14,799
you have to return ref cell

00:22:09,789 --> 00:22:17,259
type right this is really hard it gets

00:22:14,799 --> 00:22:19,509
worse the larger your game state the

00:22:17,259 --> 00:22:22,029
more you borrow so you know we have this

00:22:19,509 --> 00:22:24,039
game state and Starbound it's like a TD

00:22:22,029 --> 00:22:25,869
Bach Base building game right so you

00:22:24,039 --> 00:22:27,489
know we have a method like this in our

00:22:25,869 --> 00:22:29,830
in our version of this where you get a

00:22:27,489 --> 00:22:32,529
block based on some like integral index

00:22:29,830 --> 00:22:36,970
it returns a block well unlighted this

00:22:32,529 --> 00:22:39,309
borrows the entire game state this is a

00:22:36,970 --> 00:22:40,570
problem you you you don't want to have

00:22:39,309 --> 00:22:42,639
to call clone you don't want to borrow

00:22:40,570 --> 00:22:44,950
that much but the fact that everything

00:22:42,639 --> 00:22:48,489
is private is getting in your way and

00:22:44,950 --> 00:22:49,809
this is worse with traits so I've

00:22:48,489 --> 00:22:52,629
mentioned this because Star Vaughn has

00:22:49,809 --> 00:22:55,479
this as well we have our world class

00:22:52,629 --> 00:22:57,460
which has a million methods in it and

00:22:55,479 --> 00:22:59,019
there's a world server and a world

00:22:57,460 --> 00:23:00,279
client so if you're the server you talk

00:22:59,019 --> 00:23:02,229
to a world so ever the constructor lore

00:23:00,279 --> 00:23:04,389
client and I both implement this this

00:23:02,229 --> 00:23:05,739
interface and I tried to make I'm trying

00:23:04,389 --> 00:23:08,979
to improve the performance of Starbound

00:23:05,739 --> 00:23:10,869
I've been doing a lot of perf work you

00:23:08,979 --> 00:23:13,590
know it I need the world's return of

00:23:10,869 --> 00:23:17,769
reference everything is terrifying in

00:23:13,590 --> 00:23:19,960
C++ this is use after free in rust you

00:23:17,769 --> 00:23:21,429
know it borrows absolutely the entire

00:23:19,960 --> 00:23:22,840
game say and you can't do anything in

00:23:21,429 --> 00:23:26,109
you're forced to clone it so it's not

00:23:22,840 --> 00:23:28,869
very helpful so what are the takeaways

00:23:26,109 --> 00:23:30,519
for this this is kind of common

00:23:28,869 --> 00:23:32,309
knowledge in the games industry actually

00:23:30,519 --> 00:23:33,940
but in case you haven't heard

00:23:32,309 --> 00:23:37,720
object-oriented programming kind of

00:23:33,940 --> 00:23:40,269
hurts more than it helps and this is

00:23:37,720 --> 00:23:41,739
kind of insidious because in a game you

00:23:40,269 --> 00:23:42,460
have these objects and it calls out to

00:23:41,739 --> 00:23:44,440
you right

00:23:42,460 --> 00:23:47,619
what's an object will player that's like

00:23:44,440 --> 00:23:48,879
a physical object monster block right

00:23:47,619 --> 00:23:50,859
and these sounds super fishy

00:23:48,879 --> 00:23:54,940
superficially appealing but if you keep

00:23:50,859 --> 00:23:56,320
going it's actually quite harmful most

00:23:54,940 --> 00:23:58,029
of your concerns and of being

00:23:56,320 --> 00:24:00,879
cross-cutting concerns things like

00:23:58,029 --> 00:24:02,499
damage or collision right multiple

00:24:00,879 --> 00:24:03,639
entities collide with each other it

00:24:02,499 --> 00:24:09,070
doesn't make sense to have a collide

00:24:03,639 --> 00:24:11,499
method and these this bad design that

00:24:09,070 --> 00:24:14,440
we've talked about fails quickly in rust

00:24:11,499 --> 00:24:16,389
you start getting pain points it starts

00:24:14,440 --> 00:24:18,119
it's like the rest compiler is telling

00:24:16,389 --> 00:24:22,770
you that maybe this is not a good idea

00:24:18,119 --> 00:24:26,940
and one of the takeaways is that I

00:24:22,770 --> 00:24:30,240
find it helpful to force myself to think

00:24:26,940 --> 00:24:32,970
about things as just data like to think

00:24:30,240 --> 00:24:35,190
in a data oriented fashion and by that I

00:24:32,970 --> 00:24:37,070
mean just like just concentrate on the

00:24:35,190 --> 00:24:40,350
representation of my game state and

00:24:37,070 --> 00:24:42,480
don't conflate the methods that operate

00:24:40,350 --> 00:24:44,610
on the data with the representation of

00:24:42,480 --> 00:24:48,540
the game state or this data whatever

00:24:44,610 --> 00:24:52,680
you're doing okay so this is a bust in

00:24:48,540 --> 00:24:54,750
rust let's go back to the beginning so

00:24:52,680 --> 00:24:57,270
this is kind of a rust version of our

00:24:54,750 --> 00:24:59,250
first our first data model for Starbound

00:24:57,270 --> 00:25:01,590
you have a player at Steve you have a

00:24:59,250 --> 00:25:07,920
monster at Stevie of an NPC entity they

00:25:01,590 --> 00:25:09,300
all have some physics so like we're not

00:25:07,920 --> 00:25:10,890
gonna do the shared pointer to an

00:25:09,300 --> 00:25:14,250
interface thing we're not gonna do Doc's

00:25:10,890 --> 00:25:17,100
entity let's instead use an enum so this

00:25:14,250 --> 00:25:19,530
is all the kinds of entities we have and

00:25:17,100 --> 00:25:22,740
then in our game state we just keep a

00:25:19,530 --> 00:25:24,870
vector of these entities which are

00:25:22,740 --> 00:25:27,210
either a player a monster or NPC and

00:25:24,870 --> 00:25:32,100
then we have this this basic update

00:25:27,210 --> 00:25:35,160
structure that we had before so cards on

00:25:32,100 --> 00:25:37,650
the table this is fine if you're making

00:25:35,160 --> 00:25:39,330
a game jam game probably stop here you

00:25:37,650 --> 00:25:42,000
know if you want to use an e CS that's

00:25:39,330 --> 00:25:43,800
fine but this is not so bad like

00:25:42,000 --> 00:25:46,020
especially for small things right like

00:25:43,800 --> 00:25:48,810
yeah your entire game say is is

00:25:46,020 --> 00:25:50,940
available to everything but it's

00:25:48,810 --> 00:25:52,650
actually fine so I wanted to mention

00:25:50,940 --> 00:25:54,600
this because I'm gonna explain a couple

00:25:52,650 --> 00:25:56,220
of steps beyond this and each one of

00:25:54,600 --> 00:25:57,720
them might be a stopping point if you

00:25:56,220 --> 00:26:00,390
wanted to make a game engine from

00:25:57,720 --> 00:26:01,950
scratch so so one thing I wanted to

00:26:00,390 --> 00:26:04,260
point out though is it see this physics

00:26:01,950 --> 00:26:06,240
system so the physics system needs to go

00:26:04,260 --> 00:26:10,470
up go through every entity that has a

00:26:06,240 --> 00:26:13,410
physics member so but here this is that

00:26:10,470 --> 00:26:14,580
there's this enum here so all entities

00:26:13,410 --> 00:26:15,810
have physics or maybe even most

00:26:14,580 --> 00:26:19,230
densities have physics we add more

00:26:15,810 --> 00:26:20,760
entity types so but it needs to undies

00:26:19,230 --> 00:26:22,680
to understand every single entity type

00:26:20,760 --> 00:26:24,480
it needs to match on the enum and then

00:26:22,680 --> 00:26:26,730
see you know it needs to know which of

00:26:24,480 --> 00:26:29,670
them do have a physics i pair it won't

00:26:26,730 --> 00:26:33,150
compile and you have this like you it's

00:26:29,670 --> 00:26:35,310
it's less it's it's not that easy to to

00:26:33,150 --> 00:26:35,789
like deal with a subset of entities that

00:26:35,310 --> 00:26:39,559
have

00:26:35,789 --> 00:26:42,059
same state we can fix this though we can

00:26:39,559 --> 00:26:44,279
unify our entity type so instead of

00:26:42,059 --> 00:26:48,869
having an entity be an enum we can take

00:26:44,279 --> 00:26:50,190
every state that an entity has and we'll

00:26:48,869 --> 00:26:54,509
just shove them all in one base

00:26:50,190 --> 00:26:56,909
structure so you know most entities will

00:26:54,509 --> 00:26:58,830
have physics but you know this isn't you

00:26:56,909 --> 00:27:01,169
know option physics and then entities

00:26:58,830 --> 00:27:05,549
might have health and then we have all

00:27:01,169 --> 00:27:07,379
these these like player monster NPC like

00:27:05,549 --> 00:27:09,269
types that were that were there before

00:27:07,379 --> 00:27:11,009
but we're just like if you're a player

00:27:09,269 --> 00:27:16,249
you have the set if you ever monster egg

00:27:11,009 --> 00:27:20,129
with this set so this is this is useful

00:27:16,249 --> 00:27:23,849
but what's even more useful is if you

00:27:20,129 --> 00:27:26,190
generalize this a bit so before you

00:27:23,849 --> 00:27:28,950
don't monster had a current target right

00:27:26,190 --> 00:27:30,629
like in this in this slide you know a

00:27:28,950 --> 00:27:32,549
monster can be aggressive towards the

00:27:30,629 --> 00:27:35,700
current towards so I'm gonna player well

00:27:32,549 --> 00:27:39,599
here we take this out we make it its own

00:27:35,700 --> 00:27:41,669
little stick so we've just kind of

00:27:39,599 --> 00:27:43,109
generalized our fields a little bit and

00:27:41,669 --> 00:27:44,820
sometimes you can't do that because you

00:27:43,109 --> 00:27:46,710
know we saw stuff that only makes sense

00:27:44,820 --> 00:27:48,989
for a player but but this is kind of

00:27:46,710 --> 00:27:51,359
interesting to think about because it's

00:27:48,989 --> 00:27:53,399
a give-and-take but this allows you to

00:27:51,359 --> 00:27:57,059
express more states than the previous

00:27:53,399 --> 00:27:59,700
one and this you can express a an

00:27:57,059 --> 00:28:01,919
aggressive NPC I mean that's good maybe

00:27:59,700 --> 00:28:06,419
you would you would want that but you

00:28:01,919 --> 00:28:09,299
can also express an aggressive player by

00:28:06,419 --> 00:28:12,149
setting it pulled the the the player to

00:28:09,299 --> 00:28:13,409
the play setting that this field and

00:28:12,149 --> 00:28:14,849
then also setting the aggression field

00:28:13,409 --> 00:28:15,779
and maybe your engine just doesn't know

00:28:14,849 --> 00:28:16,320
how to handle that maybe that doesn't

00:28:15,779 --> 00:28:17,999
make any sense

00:28:16,320 --> 00:28:19,379
maybe aggression only makes sense like

00:28:17,999 --> 00:28:21,539
if you have an AI system and the players

00:28:19,379 --> 00:28:23,099
not run by AI so it's important to

00:28:21,539 --> 00:28:24,989
remember that this is this is powerful

00:28:23,099 --> 00:28:30,590
and you can do this but it's a

00:28:24,989 --> 00:28:34,499
give-and-take so you can go further and

00:28:30,590 --> 00:28:36,389
this is usually the part where if you're

00:28:34,499 --> 00:28:38,999
reading an explanation of what a nice es

00:28:36,389 --> 00:28:42,359
system is they focus on because they

00:28:38,999 --> 00:28:45,090
they look at this as purely from the

00:28:42,359 --> 00:28:46,890
lens of performance so this is kind of

00:28:45,090 --> 00:28:49,110
confusing so let's go back you know we

00:28:46,890 --> 00:28:51,060
have this entity structure with all

00:28:49,110 --> 00:28:53,730
these optional fields and then we have

00:28:51,060 --> 00:28:56,400
this vector of these entity structure

00:28:53,730 --> 00:29:00,120
we're taking it and we're saying that

00:28:56,400 --> 00:29:01,860
instead of having a vector of structs

00:29:00,120 --> 00:29:05,400
we're just gonna have all of the vectors

00:29:01,860 --> 00:29:06,990
for each of those parts in one top-level

00:29:05,400 --> 00:29:09,020
structure this is kind of called the

00:29:06,990 --> 00:29:11,280
array of structs to struct of arrays

00:29:09,020 --> 00:29:14,670
transform if you're if you're into data

00:29:11,280 --> 00:29:16,620
oriented programming and we're gonna do

00:29:14,670 --> 00:29:18,690
this transform and we're gonna do one

00:29:16,620 --> 00:29:20,580
more thing where we give all these parts

00:29:18,690 --> 00:29:21,450
a more informative name we're going to

00:29:20,580 --> 00:29:23,190
call them what they are which is

00:29:21,450 --> 00:29:23,760
components so if you've been paying

00:29:23,190 --> 00:29:26,070
attention

00:29:23,760 --> 00:29:29,220
we now have entities and components and

00:29:26,070 --> 00:29:31,170
our systems are just these procedures

00:29:29,220 --> 00:29:36,800
that operate on a game state so so we're

00:29:31,170 --> 00:29:39,650
getting we're getting close right so

00:29:36,800 --> 00:29:42,810
let's see what do they take away so far

00:29:39,650 --> 00:29:45,720
thinking about the structure of your

00:29:42,810 --> 00:29:48,570
state is really powerful and not

00:29:45,720 --> 00:29:50,430
thinking necessarily always about the

00:29:48,570 --> 00:29:53,730
methods you've decided to apply to that

00:29:50,430 --> 00:29:56,750
state another takeaway is that you can

00:29:53,730 --> 00:30:00,300
do a lot with mechs and indexes into hex

00:29:56,750 --> 00:30:03,000
the reason I mention this is because I

00:30:00,300 --> 00:30:06,840
see this a lot actually not just in game

00:30:03,000 --> 00:30:08,400
programming but but you know you you

00:30:06,840 --> 00:30:10,140
need like to make a grass structure or

00:30:08,400 --> 00:30:11,820
something and you need to update it and

00:30:10,140 --> 00:30:13,950
you go online people give you advice

00:30:11,820 --> 00:30:16,530
about like using arena allocators or

00:30:13,950 --> 00:30:17,970
like RC and internal mutability and

00:30:16,530 --> 00:30:19,920
those are great and those tools have

00:30:17,970 --> 00:30:22,530
their place but seriously seriously

00:30:19,920 --> 00:30:25,470
seriously just put your nodes in a

00:30:22,530 --> 00:30:28,280
vacuum use indexes it is so easy that

00:30:25,470 --> 00:30:32,400
should be the first tool you reach for

00:30:28,280 --> 00:30:35,820
however it still has some problems so if

00:30:32,400 --> 00:30:38,780
you do that and I do that when you get

00:30:35,820 --> 00:30:41,670
an index to something in your vac of

00:30:38,780 --> 00:30:45,270
members or your vac of nodes or whatever

00:30:41,670 --> 00:30:47,850
if it's a graph and you delete one that

00:30:45,270 --> 00:30:50,760
index is still valid and if you think

00:30:47,850 --> 00:30:52,650
about this this is kind of like you

00:30:50,760 --> 00:30:54,540
softer free like if you can think of

00:30:52,650 --> 00:30:58,530
your index as a site kind of like pseudo

00:30:54,540 --> 00:31:00,600
pointers if you if you free a node like

00:30:58,530 --> 00:31:02,880
if we freed an entity and then use an

00:31:00,600 --> 00:31:04,410
entity index to get that you know to get

00:31:02,880 --> 00:31:06,360
that entity we hopefully we would know

00:31:04,410 --> 00:31:08,220
notice that it was gone but if we

00:31:06,360 --> 00:31:10,950
allocated an entity right afterwards

00:31:08,220 --> 00:31:12,840
then you know we might not notice that

00:31:10,950 --> 00:31:15,510
it's gone we might get a random this

00:31:12,840 --> 00:31:20,010
other entity and that that's it's safe

00:31:15,510 --> 00:31:21,990
but it's not great we can solve it

00:31:20,010 --> 00:31:23,400
so this is a pattern that is super

00:31:21,990 --> 00:31:25,560
common in the game deaf community and I

00:31:23,400 --> 00:31:27,690
don't think enough rotations know about

00:31:25,560 --> 00:31:29,820
so I included it in my talk we're gonna

00:31:27,690 --> 00:31:32,130
talk about generational indexes and a

00:31:29,820 --> 00:31:33,450
generational index is just as indexed we

00:31:32,130 --> 00:31:35,370
were talking about like entity index

00:31:33,450 --> 00:31:38,670
with one extra field which is called a

00:31:35,370 --> 00:31:39,720
generation so if we had an allocator for

00:31:38,670 --> 00:31:42,990
such a thing

00:31:39,720 --> 00:31:44,820
we might allocate generational index and

00:31:42,990 --> 00:31:46,620
it would give back like a zero with a

00:31:44,820 --> 00:31:48,450
generation of zero allocate another one

00:31:46,620 --> 00:31:50,880
it gives back one with a generation of

00:31:48,450 --> 00:31:54,360
zero allocate and deallocate

00:31:50,880 --> 00:31:56,640
the 0th index allocate another one we

00:31:54,360 --> 00:31:58,920
get back in an index of zero so still

00:31:56,640 --> 00:32:01,740
over all of our indexes are small and we

00:31:58,920 --> 00:32:04,290
can serve them in a Veck but we never

00:32:01,740 --> 00:32:05,850
repeat are invariant here is that our

00:32:04,290 --> 00:32:08,460
generational index allocator will never

00:32:05,850 --> 00:32:10,740
return an index that is ever equal to a

00:32:08,460 --> 00:32:12,960
previous one i mean unless unless you

00:32:10,740 --> 00:32:15,480
make this generation overflow 64-bit

00:32:12,960 --> 00:32:16,980
ends but if you if you can do that your

00:32:15,480 --> 00:32:19,410
game technology probably has cloud in

00:32:16,980 --> 00:32:20,550
the name so who you probably have bigger

00:32:19,410 --> 00:32:22,410
problems

00:32:20,550 --> 00:32:25,890
but these are these are useful because

00:32:22,410 --> 00:32:28,950
they solve this this use after free

00:32:25,890 --> 00:32:30,720
problem of indexing and to go a little

00:32:28,950 --> 00:32:32,820
bit further we just need one more thing

00:32:30,720 --> 00:32:34,830
which is this generational index array

00:32:32,820 --> 00:32:36,300
which is just like an associative array

00:32:34,830 --> 00:32:38,100
of these indexes so instead of a Beck

00:32:36,300 --> 00:32:40,920
it's it's just like an easier version to

00:32:38,100 --> 00:32:43,290
deal with the backup option of tea you

00:32:40,920 --> 00:32:44,880
know you can set and you can set values

00:32:43,290 --> 00:32:48,570
based on a generational index and if you

00:32:44,880 --> 00:32:50,430
get them out crucially if the generation

00:32:48,570 --> 00:32:54,230
must be up to date so if you have an

00:32:50,430 --> 00:32:58,170
older generation you get back and done

00:32:54,230 --> 00:32:59,820
so putting it all together instead of

00:32:58,170 --> 00:33:02,430
having these Beck of options we're gonna

00:32:59,820 --> 00:33:03,960
have this entity map which is just a

00:33:02,430 --> 00:33:06,120
type def of this generational index

00:33:03,960 --> 00:33:06,460
array and then we're gonna rename entity

00:33:06,120 --> 00:33:08,800
in deck

00:33:06,460 --> 00:33:10,030
to entity because it's no longer we

00:33:08,800 --> 00:33:11,350
don't have to worry about it anymore

00:33:10,030 --> 00:33:14,260
there is no such thing as an entity

00:33:11,350 --> 00:33:16,570
anymore so entity index entity ID we're

00:33:14,260 --> 00:33:18,190
gonna call this index entity we're gonna

00:33:16,570 --> 00:33:22,320
keep all these entity maps of all of our

00:33:18,190 --> 00:33:22,320
components this is a nice es system

00:33:23,610 --> 00:33:27,960
takeaways generational indexes are

00:33:26,110 --> 00:33:30,280
awesome if you don't know about them

00:33:27,960 --> 00:33:31,870
they solve a whole lot of the problems

00:33:30,280 --> 00:33:34,090
of regular indexing for doing these

00:33:31,870 --> 00:33:34,480
internal mutability there's a crate for

00:33:34,090 --> 00:33:37,210
it

00:33:34,480 --> 00:33:38,320
it's called slot map and I couldn't use

00:33:37,210 --> 00:33:40,270
it in the talk even though I really

00:33:38,320 --> 00:33:43,090
really wanted to because it's missing a

00:33:40,270 --> 00:33:44,830
key feature you can't in slot map

00:33:43,090 --> 00:33:46,300
allocate these indexes separately from

00:33:44,830 --> 00:33:47,950
using them you have to bundle them all

00:33:46,300 --> 00:33:49,570
up and it gives you kind of a structure

00:33:47,950 --> 00:33:51,820
but you can't allocate the indexes

00:33:49,570 --> 00:33:54,340
separately if you're the author this is

00:33:51,820 --> 00:33:58,810
great and you're at Ross comp I am super

00:33:54,340 --> 00:34:01,510
sorry for calling you out on stage but

00:33:58,810 --> 00:34:03,430
you know I have I have another version

00:34:01,510 --> 00:34:05,050
of this all I can release that as a

00:34:03,430 --> 00:34:06,370
Creek it sounds like a threat if you

00:34:05,050 --> 00:34:08,080
don't make this change I'm gonna release

00:34:06,370 --> 00:34:12,670
a competing version I didn't need to

00:34:08,080 --> 00:34:15,010
selling a threat so so okay one more one

00:34:12,670 --> 00:34:17,610
more transformation set of

00:34:15,010 --> 00:34:22,080
transformations and we're we're done so

00:34:17,610 --> 00:34:25,330
dynamic typing Ruby loves dynamic typing

00:34:22,080 --> 00:34:30,190
you know it's great in very tiny

00:34:25,330 --> 00:34:32,260
quantities but first we need a type we

00:34:30,190 --> 00:34:33,580
need this structure called any map which

00:34:32,260 --> 00:34:35,170
is great because there's a crate for it

00:34:33,580 --> 00:34:36,960
and it's not missing any features and I

00:34:35,170 --> 00:34:41,290
don't have to call anybody out on stage

00:34:36,960 --> 00:34:44,470
so an any map very briefly is is a map

00:34:41,290 --> 00:34:47,290
like it's like a set of types where you

00:34:44,470 --> 00:34:49,840
can store exactly one of any type so you

00:34:47,290 --> 00:34:51,100
can put a tee in and then if you put it

00:34:49,840 --> 00:34:53,400
to you in before you can get it back out

00:34:51,100 --> 00:34:57,910
it's just that simple

00:34:53,400 --> 00:34:59,290
so this is where we were before and we

00:34:57,910 --> 00:35:02,500
can see like you know every time we add

00:34:59,290 --> 00:35:04,120
a component this list is gonna grow and

00:35:02,500 --> 00:35:06,070
and what actually owned up happening is

00:35:04,120 --> 00:35:07,810
we're gonna list all of our types a

00:35:06,070 --> 00:35:09,730
whole lot and we're gonna find a pattern

00:35:07,810 --> 00:35:12,300
to get to deal with that but but just in

00:35:09,730 --> 00:35:15,340
this is one one instance all of these

00:35:12,300 --> 00:35:18,750
components like adding to this list can

00:35:15,340 --> 00:35:22,350
get tedious and and every time we add we

00:35:18,750 --> 00:35:23,640
are potentially you know touching we're

00:35:22,350 --> 00:35:27,540
touching independency of every single

00:35:23,640 --> 00:35:31,530
system that we have so let's give them

00:35:27,540 --> 00:35:33,180
in an any map so you know the types of

00:35:31,530 --> 00:35:35,970
some stuffs being helpful when you use

00:35:33,180 --> 00:35:37,380
dynamic typing so you know we're gonna

00:35:35,970 --> 00:35:39,240
have these anything components but

00:35:37,380 --> 00:35:42,440
they're just the these colonies

00:35:39,240 --> 00:35:46,970
collection of its any sorry entity maps

00:35:42,440 --> 00:35:49,590
of type T and let's go even further and

00:35:46,970 --> 00:35:50,550
we'll keep all of our nonentity data in

00:35:49,590 --> 00:35:54,300
an any map as well

00:35:50,550 --> 00:35:55,740
and we'll call those resources and we'll

00:35:54,300 --> 00:35:57,540
change our name from game state to

00:35:55,740 --> 00:35:59,400
something more informative world this

00:35:57,540 --> 00:36:03,000
call it what it is which is a nice es

00:35:59,400 --> 00:36:05,100
system we have these any Maps the type

00:36:03,000 --> 00:36:06,840
system such being helpful so you know

00:36:05,100 --> 00:36:08,730
you might have an interface like this so

00:36:06,840 --> 00:36:11,250
you can get our component out based on

00:36:08,730 --> 00:36:13,440
some type T you can get a resource out

00:36:11,250 --> 00:36:15,330
based on some type T and we've added

00:36:13,440 --> 00:36:17,450
this companies component and resource

00:36:15,330 --> 00:36:24,150
traits which I'll talk about in a second

00:36:17,450 --> 00:36:25,950
but this this is an e CS system so you

00:36:24,150 --> 00:36:28,290
might baulk at this like sudden

00:36:25,950 --> 00:36:30,690
introduction of dynamics I think and you

00:36:28,290 --> 00:36:32,990
would have a point kind of this is not

00:36:30,690 --> 00:36:36,450
vastly better than what came before

00:36:32,990 --> 00:36:38,550
until we add one more pattern and I

00:36:36,450 --> 00:36:39,450
don't this is common like outside of R

00:36:38,550 --> 00:36:40,650
Us but I actually don't know what to

00:36:39,450 --> 00:36:43,260
call it inside rust so I'm just gonna

00:36:40,650 --> 00:36:45,600
call it the registry pattern so we're

00:36:43,260 --> 00:36:47,490
gonna make a registry for all of our

00:36:45,600 --> 00:36:49,010
components so we're gonna have this this

00:36:47,490 --> 00:36:52,260
structure called a component registry

00:36:49,010 --> 00:36:54,330
and we're gonna call register component

00:36:52,260 --> 00:36:56,640
for every single component that we have

00:36:54,330 --> 00:36:59,430
in our whole game we're gonna do the

00:36:56,640 --> 00:37:01,080
same for resources and you know this we

00:36:59,430 --> 00:37:03,120
have to keep a bunch of stuff in here

00:37:01,080 --> 00:37:05,040
like like you know box functions I think

00:37:03,120 --> 00:37:07,470
gets kind of gnarly but if your

00:37:05,040 --> 00:37:09,270
component has met if this component

00:37:07,470 --> 00:37:13,200
trait has methods on it that allow you

00:37:09,270 --> 00:37:14,850
to like load from a file what you end up

00:37:13,200 --> 00:37:16,080
being able to do is you end up being

00:37:14,850 --> 00:37:18,870
able to have these methods on your

00:37:16,080 --> 00:37:21,330
registry that says hey go take an easy s

00:37:18,870 --> 00:37:24,030
and put every component that we know

00:37:21,330 --> 00:37:25,740
about in our game in the ACS and then

00:37:24,030 --> 00:37:27,480
you can also do this where this like

00:37:25,740 --> 00:37:29,640
load entity say your component trait

00:37:27,480 --> 00:37:30,690
knows how to load from a JSON blob you

00:37:29,640 --> 00:37:33,510
can say hey

00:37:30,690 --> 00:37:36,450
go load an entity into my ECS based on

00:37:33,510 --> 00:37:38,370
this config file so this this might be

00:37:36,450 --> 00:37:39,960
like some kind of array of all of the

00:37:38,370 --> 00:37:42,060
components and then it gives back the

00:37:39,960 --> 00:37:43,950
entity after adding them all and you do

00:37:42,060 --> 00:37:45,780
the same exact thing for resources where

00:37:43,950 --> 00:37:47,220
you you know you set up all your

00:37:45,780 --> 00:37:52,140
resources and then you can load any

00:37:47,220 --> 00:37:55,050
given resource so then because every

00:37:52,140 --> 00:37:57,570
loves Global's where you can take all of

00:37:55,050 --> 00:37:59,820
our registries and put them in a big

00:37:57,570 --> 00:38:02,160
top-level registry this is I'm joking

00:37:59,820 --> 00:38:03,540
but this is actually fine because I mean

00:38:02,160 --> 00:38:07,020
this is this is kind of like Enterprise

00:38:03,540 --> 00:38:08,310
II but you know you might have seen

00:38:07,020 --> 00:38:10,770
something like this even in like Java

00:38:08,310 --> 00:38:13,080
brave like a list of all your types but

00:38:10,770 --> 00:38:14,850
this is actually super useful to be able

00:38:13,080 --> 00:38:16,740
to say at any at any moment like you

00:38:14,850 --> 00:38:19,020
have this global registry that knows

00:38:16,740 --> 00:38:20,940
about all the types in your game and

00:38:19,020 --> 00:38:22,620
then you can have these these these

00:38:20,940 --> 00:38:24,870
functions here like load component

00:38:22,620 --> 00:38:27,240
registry and and and load resource

00:38:24,870 --> 00:38:29,820
registry you can put those in like if

00:38:27,240 --> 00:38:31,560
you have a component /lib dot RS that

00:38:29,820 --> 00:38:33,090
lists all your components but the

00:38:31,560 --> 00:38:34,530
component registry right below it and

00:38:33,090 --> 00:38:40,040
you can list all your components right

00:38:34,530 --> 00:38:42,930
so by so this is a super useful pattern

00:38:40,040 --> 00:38:44,280
so what does it take aways here today

00:38:42,930 --> 00:38:46,080
I'm exciting it's powerful and useful

00:38:44,280 --> 00:38:49,560
but obviously you need to be careful

00:38:46,080 --> 00:38:52,650
when you use it but if you can use it in

00:38:49,560 --> 00:38:55,140
just the right place you'll notice that

00:38:52,650 --> 00:38:57,630
this is kind of solved the last problem

00:38:55,140 --> 00:38:59,820
that we had with our super simple game

00:38:57,630 --> 00:39:02,430
design right so you have you declare all

00:38:59,820 --> 00:39:03,510
these systems right and they they you

00:39:02,430 --> 00:39:06,770
know we had this problem where every

00:39:03,510 --> 00:39:11,100
time we added something to our ECS state

00:39:06,770 --> 00:39:12,840
we would immediately be messing with the

00:39:11,100 --> 00:39:15,540
dependencies of every single system but

00:39:12,840 --> 00:39:16,770
now a system can only know about a part

00:39:15,540 --> 00:39:18,990
of our game state if they know about

00:39:16,770 --> 00:39:21,060
that type so you can just look at the

00:39:18,990 --> 00:39:22,860
import list for any given system and see

00:39:21,060 --> 00:39:24,840
whether it depends on something and it

00:39:22,860 --> 00:39:28,710
breaks up this everything is depending

00:39:24,840 --> 00:39:30,270
on everything else not if you need to

00:39:28,710 --> 00:39:32,010
dynamic typing like this usually you'll

00:39:30,270 --> 00:39:35,250
have something like a type register you

00:39:32,010 --> 00:39:37,200
have to go along with it this pattern is

00:39:35,250 --> 00:39:38,370
super common in object-oriented

00:39:37,200 --> 00:39:40,230
programming you might call this a

00:39:38,370 --> 00:39:42,000
component factory but if I think if I

00:39:40,230 --> 00:39:44,510
said I component in component factory I

00:39:42,000 --> 00:39:47,160
would rightfully be left ahead

00:39:44,510 --> 00:39:48,480
but oftentimes these patterns an object

00:39:47,160 --> 00:39:51,869
during a programming are really complex

00:39:48,480 --> 00:39:54,150
and any map kind of simplifies this you

00:39:51,869 --> 00:39:56,700
know if you're gonna have dynamic typing

00:39:54,150 --> 00:39:59,790
and downcast just kind of own it just

00:39:56,700 --> 00:40:05,670
put everything in in any map and any map

00:39:59,790 --> 00:40:07,170
is awesome so like let's just to wrap up

00:40:05,670 --> 00:40:09,930
here really fast see what time it is a

00:40:07,170 --> 00:40:11,310
little over you know I didn't talk much

00:40:09,930 --> 00:40:13,590
about the performance implication in

00:40:11,310 --> 00:40:15,119
implications of things like ECS systems

00:40:13,590 --> 00:40:17,880
and I kind of did some purpose because

00:40:15,119 --> 00:40:20,490
I've read a lot of really confusing ECS

00:40:17,880 --> 00:40:21,990
explanations and I think that the they

00:40:20,490 --> 00:40:24,690
can kind of lose the larger point which

00:40:21,990 --> 00:40:27,240
is that like it's it's very useful and

00:40:24,690 --> 00:40:32,010
powerful to just stop thinking about

00:40:27,240 --> 00:40:34,380
objects sometimes I also think that you

00:40:32,010 --> 00:40:36,270
know you you have things like data

00:40:34,380 --> 00:40:38,760
oriented programming which are

00:40:36,270 --> 00:40:40,590
classically just thought about just for

00:40:38,760 --> 00:40:42,330
the reasons of performance that that

00:40:40,590 --> 00:40:45,660
this is actually kind of more important

00:40:42,330 --> 00:40:48,570
for rust because rust has this focus on

00:40:45,660 --> 00:40:51,510
like ownership and borrowing and then

00:40:48,570 --> 00:40:53,790
the the data oriented design can can

00:40:51,510 --> 00:40:57,600
both make for better performance and

00:40:53,790 --> 00:41:00,060
also for easier an easier time with the

00:40:57,600 --> 00:41:04,580
borrow checker and critically these are

00:41:00,060 --> 00:41:06,930
kind of two sides of the same coin I

00:41:04,580 --> 00:41:08,760
apologize if you've heard a lot of this

00:41:06,930 --> 00:41:10,560
before I feel like I'm kind of rewriting

00:41:08,760 --> 00:41:12,119
old ground like especially in the game

00:41:10,560 --> 00:41:13,770
deaf community if you if you hang out

00:41:12,119 --> 00:41:15,180
there or interested you know a lot of

00:41:13,770 --> 00:41:16,920
these things are kind of considered

00:41:15,180 --> 00:41:18,630
common knowledge like ECS design and

00:41:16,920 --> 00:41:21,570
object view the fact that object or any

00:41:18,630 --> 00:41:23,400
programming is overrated if you have

00:41:21,570 --> 00:41:24,869
heard them I hope that this is maybe a

00:41:23,400 --> 00:41:29,190
simpler explanation that you've gotten

00:41:24,869 --> 00:41:31,859
in the past and I hope you've if you

00:41:29,190 --> 00:41:33,540
know if the very least found some good

00:41:31,859 --> 00:41:35,850
design ideas or some good features that

00:41:33,540 --> 00:41:38,609
you may not have known about or may not

00:41:35,850 --> 00:41:40,980
have thought about otherwise and also

00:41:38,609 --> 00:41:43,109
just to finish up there's a lot I didn't

00:41:40,980 --> 00:41:44,400
talk about I didn't talk about all the

00:41:43,109 --> 00:41:45,810
great crates if you actually want to

00:41:44,400 --> 00:41:47,190
make a game in rust you know you know

00:41:45,810 --> 00:41:49,080
don't write your own ECS system go you

00:41:47,190 --> 00:41:51,270
specs right specs will do all this and

00:41:49,080 --> 00:41:52,530
it'll schedule your your systems and

00:41:51,270 --> 00:41:54,589
it'll have great performance and you

00:41:52,530 --> 00:41:57,079
know don't make your own ECS system I

00:41:54,589 --> 00:41:58,249
wanted to explain it but also there's

00:41:57,079 --> 00:42:00,200
other ways to make games you don't have

00:41:58,249 --> 00:42:01,489
to use an EC s system you can use the

00:42:00,200 --> 00:42:04,369
actor model there's lots of great ways

00:42:01,489 --> 00:42:06,710
to make games I was not able to talk

00:42:04,369 --> 00:42:07,100
about all of them and that's it thank

00:42:06,710 --> 00:42:14,030
you very much

00:42:07,100 --> 00:42:23,170
[Applause]

00:42:14,030 --> 00:42:24,100
[Music]

00:42:23,170 --> 00:42:30,239
you

00:42:24,100 --> 00:42:30,239

YouTube URL: https://www.youtube.com/watch?v=aKLntZcp27M


