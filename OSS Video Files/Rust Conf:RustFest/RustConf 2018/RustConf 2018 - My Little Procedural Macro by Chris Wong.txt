Title: RustConf 2018 - My Little Procedural Macro by Chris Wong
Publication date: 2018-09-06
Playlist: RustConf 2018
Description: 
	RustConf 2018 - My Little Procedural Macro by Chris Wong

What if Handlebars was a macro?

Three years, 376 commits, and countless breaking changes later, I may have an answer to that.

Maud is a macro for writing HTML web pages. It's like format!(), but for markup instead of text. This design lets it catch typos at compile-time, as well as run blazingly fast.

This talk will cover lessons I learned while working on Maud, including: tips on designing a macro's syntax, some common pitfalls with the procedural macro system, and dealing with Nightly Rust. There will also be a pony.
Captions: 
	00:00:15,120 --> 00:00:17,120
So hi everyone, I'm Chris

00:00:17,820 --> 00:00:22,130
I'm super excited it about procedural matters is you may have noticed by now

00:00:22,890 --> 00:00:28,220
And I'm going to talk about a particular procedural matter. I've been working on

00:00:28,859 --> 00:00:30,889
what lessons I've learned from it and

00:00:31,680 --> 00:00:37,040
Hopefully give you some advice that you can apply when you write your own procedural, Medeco

00:00:39,720 --> 00:00:44,689
So first off what is a procedural macro exactly. Oh

00:00:46,500 --> 00:00:51,169
And the single sentence I could say that a procedural macro

00:00:51,989 --> 00:00:53,989
extends the syntax of rust

00:00:54,570 --> 00:00:56,689
Let's unpack that sentence robin

00:00:58,649 --> 00:01:03,949
So when you tell the rusts compiler or cargo to compile your code

00:01:04,770 --> 00:01:07,129
you start with the source code and

00:01:09,149 --> 00:01:15,409
The first place it goes is into the parser which takes your source code and

00:01:16,380 --> 00:01:17,820
Converts it

00:01:17,820 --> 00:01:23,659
Or parses it into a form that's easier for the rest of the compiler to understand

00:01:27,330 --> 00:01:31,999
Magic happens after that which we won't go into for this talk and

00:01:32,580 --> 00:01:38,029
After all that we get the finished binary either an executable or a library crate

00:01:39,720 --> 00:01:42,499
Where a procedural macro fits in then is

00:01:44,729 --> 00:01:46,729
Inside the Pazza

00:01:47,220 --> 00:01:52,129
You can see the bagel there. It's a bagel by the way, not a doughnut a bagel

00:01:53,820 --> 00:01:55,820
And

00:01:55,950 --> 00:01:58,040
What the procedural macro does is

00:01:58,740 --> 00:02:02,780
Whenever the parser sees a call to this macro

00:02:03,600 --> 00:02:06,860
it takes whatever is within that macro call and

00:02:07,500 --> 00:02:14,269
Hands it over verbatim to your procedural macro. Your macro will take this input

00:02:16,170 --> 00:02:20,750
Processor process it in its own way and then hand back

00:02:21,390 --> 00:02:24,349
generated rust code to the pawza

00:02:25,049 --> 00:02:27,379
Which will understand it as normal rust

00:02:29,010 --> 00:02:35,390
In that sense a procedural macro Maps a custom syntax into rust code

00:02:37,620 --> 00:02:40,399
Thereby extending the syntax of the language

00:02:43,980 --> 00:02:48,649
This might seem a bit abstract, but in fact procedural macros are everywhere

00:02:51,239 --> 00:02:54,499
You've probably heard about 34 serialization

00:02:56,400 --> 00:03:00,950
Diesel for databases or the rocket web framework

00:03:03,720 --> 00:03:11,419
But in this talk, I'm not going to discuss any of these libraries instead I'm going to talk about something called mod

00:03:14,609 --> 00:03:18,019
What is mod good question

00:03:22,920 --> 00:03:27,019
Um put simply mod is a macro a

00:03:27,750 --> 00:03:34,970
Procedural macro that enables you to write HTML in line with in your rust programs. And yes

00:03:34,970 --> 00:03:39,529
It is named after the My Little Pony character. It was it was a while ago at least no judge

00:03:42,660 --> 00:03:44,660
Moving on

00:03:44,879 --> 00:03:50,719
To help understand how Lord works let's take a look at this example this

00:03:52,260 --> 00:03:56,060
Program generates a bunch of HTML and prints it to standard output

00:03:57,090 --> 00:03:59,090
And as you can see here

00:03:59,370 --> 00:04:07,190
It calls a macro called HTML and inside of that macro call is completely custom syntax

00:04:07,680 --> 00:04:11,090
the rust compiler itself doesn't know what

00:04:11,639 --> 00:04:14,869
This particular syntax means the thing in purple

00:04:16,260 --> 00:04:18,679
But what mod will do is it will take?

00:04:20,519 --> 00:04:24,019
This piece of syntax that's given by the compiler and

00:04:24,930 --> 00:04:26,699
convert it into

00:04:26,699 --> 00:04:30,589
Normal rust code that the rest of the compiler will understand

00:04:34,450 --> 00:04:41,170
And this is what you see when you run that program by the way the string hello Pinkie Pie within paragraph tags

00:04:44,480 --> 00:04:51,460
Now if you were to run something like cargo expand to view the code that more generates

00:04:51,860 --> 00:04:54,039
You would see something similar to this

00:04:54,590 --> 00:05:01,449
The real code is a bit more complicated for various reasons, but this is pretty much the gist of it

00:05:02,510 --> 00:05:06,849
As you can see there all it does is create a new string object

00:05:07,550 --> 00:05:12,759
Push a bunch of literals to it and this render to method does HTML escaping

00:05:13,520 --> 00:05:17,620
But other than that, there's not much to that code

00:05:18,350 --> 00:05:22,600
If you were to try to write an HTML template by hand

00:05:23,270 --> 00:05:27,520
You would be hard-pressed to write something that's simpler or more efficient than that

00:05:28,880 --> 00:05:35,650
And that's one of the biggest advantages of using mod or any other procedural macro solution

00:05:36,860 --> 00:05:39,340
The really low runtime overhead

00:05:43,040 --> 00:05:47,020
We can see this in the numbers as well a while ago

00:05:47,020 --> 00:05:53,469
I wrote a bunch of benchmarks comparing different templating engines just to get a feel for it and

00:05:54,350 --> 00:05:59,050
As you can see here Ward is by far the fastest one

00:05:59,870 --> 00:06:01,870
I

00:06:02,000 --> 00:06:04,000
Was expecting some applause here

00:06:09,790 --> 00:06:11,790
Oh

00:06:12,980 --> 00:06:14,480
But

00:06:14,480 --> 00:06:20,830
also, if you look at the label on the bottom, it says render time in

00:06:21,500 --> 00:06:22,760
nanoseconds

00:06:22,760 --> 00:06:26,529
Like if you've done much web development before you'd know that

00:06:29,150 --> 00:06:35,289
An average web request takes around a hundred milliseconds, which is about

00:06:37,040 --> 00:06:40,480
Thousands of times bigger than even the biggest bar on this graph

00:06:41,120 --> 00:06:45,010
So in the real world most of the time

00:06:46,070 --> 00:06:51,909
the speed of your template engine doesn't matter that much, but I think it's still cool that

00:06:52,430 --> 00:06:55,660
We can create something that is that efficient

00:07:00,590 --> 00:07:02,950
Now another advantage of maud

00:07:04,600 --> 00:07:10,440
Would be static type checking and in fact, I think this is the more important advantage

00:07:13,700 --> 00:07:21,680
If we were to take that first example, we had and replace that Y with an e so it's his best "pone" instead

00:07:21,680 --> 00:07:23,480
the compiler wouldn't let us run then and

00:07:24,590 --> 00:07:25,630
in fact

00:07:25,630 --> 00:07:26,390
this is the

00:07:26,390 --> 00:07:32,439
exact same error that you would have gotten if you had made that typo anywhere else because at the end of the day

00:07:32,440 --> 00:07:34,660
We're just generating normal rust, right?

00:07:35,360 --> 00:07:36,590
and

00:07:36,620 --> 00:07:43,180
That is in comparison to other templating engines which might parse and run the templates

00:07:44,800 --> 00:07:46,280
at runtime

00:07:46,420 --> 00:07:51,900
Such that you wouldn't know about any typos until you try to run your app and everything falls down

00:07:55,480 --> 00:07:59,800
Now I've hopefully convinced you all that Maud is amazing and you should all use it

00:08:00,530 --> 00:08:04,960
But how do they come up with this idea for this library? How did it all start?

00:08:08,960 --> 00:08:14,829
Well, it started like many things by reading the official documentation

00:08:16,619 --> 00:08:23,009
This is an excerpt from from the old rust book it has since been rewritten by thus the old one and

00:08:23,829 --> 00:08:31,259
One of the sections in that book is about macros and in that section is an example of another macro

00:08:31,599 --> 00:08:33,599
That generates HTML

00:08:33,909 --> 00:08:35,909
and when I saw that I

00:08:36,370 --> 00:08:38,370
Thought why don't I...

00:08:40,120 --> 00:08:44,969
...Take this concept and develop it into a real-world practical library

00:08:48,730 --> 00:08:53,039
Now this isn't the first place that I saw this idea

00:08:53,040 --> 00:09:00,089
I had already known about this general concept from other languages like Hamlet and Haskell

00:09:00,430 --> 00:09:02,969
slim and Ruby and Razor and c-sharp

00:09:04,389 --> 00:09:11,219
In that sense Maud isn't really original except for the fact that it's written in rust

00:09:14,290 --> 00:09:18,599
And I don't think that's a bad thing at all

00:09:22,000 --> 00:09:28,529
In fact, it's a good thing because you already know that the idea has been proven elsewhere and

00:09:29,589 --> 00:09:36,058
The nice thing about rust is even though there are existing libraries which are really high-quality

00:09:38,769 --> 00:09:41,878
Just because rust is so young as a language

00:09:42,610 --> 00:09:44,610
There are still a lot of places

00:09:44,889 --> 00:09:48,359
Where the library support isn't that good there

00:09:48,360 --> 00:09:53,699
there's still a lot of low-hanging fruit around and so if you have a concept

00:09:54,370 --> 00:09:58,979
That you're really passionate about but can only be found in another language

00:09:59,079 --> 00:10:05,339
I think it's a really good idea to take that idea and try to port it to rust

00:10:06,069 --> 00:10:09,628
You could make a really good contribution to the community that way

00:10:16,750 --> 00:10:18,519
So I

00:10:18,519 --> 00:10:22,078
got started developing the library but early on I

00:10:22,750 --> 00:10:24,610
ran into issues

00:10:24,610 --> 00:10:26,610
developing on rust nightly

00:10:29,800 --> 00:10:35,609
Because the thing is even now most of the procedural macro API is still unstable

00:10:36,100 --> 00:10:43,980
there has been a big effort to stabilize much of the API lately, but the stuff I use is still nightly only and

00:10:44,620 --> 00:10:47,489
the funny thing is if you look at the history of

00:10:48,279 --> 00:10:53,698
Maud, you'd notice that its first release was in the beginning of 2015

00:10:54,550 --> 00:10:59,069
but rust 1.0 was released in the middle of 2015 and

00:11:00,279 --> 00:11:06,599
The keen-eyed among you would notice that I started working on. This thing before rust was officially released

00:11:08,019 --> 00:11:14,789
and in a sense that led to a sort of trial by fire, I guess I

00:11:17,259 --> 00:11:19,589
Didn't really have a choice to

00:11:20,380 --> 00:11:23,880
Figure out how to work on nightly. Uhm I had to

00:11:24,399 --> 00:11:25,350
learn well

00:11:25,350 --> 00:11:26,860
I was forced to learn

00:11:26,860 --> 00:11:34,229
to deal with these breaking changes coming in all the time and that gave me some really valuable skills for working with

00:11:34,480 --> 00:11:36,480
procedural macros

00:11:40,810 --> 00:11:45,239
Here are some of the strategies are used to manage all of these breaking changes

00:11:46,270 --> 00:11:50,189
Most importantly. I scheduled a daily build using Travis CI

00:11:51,190 --> 00:11:58,649
The exact kind of continuous integration doesn't matter that much. The important thing was it was a daily build

00:11:59,200 --> 00:12:03,270
Because the thing about Rust nightly is that it happens every night, right? I

00:12:05,170 --> 00:12:07,409
Know I'm putting out the obvious here, but

00:12:09,460 --> 00:12:14,219
That means that if you have a daily build and you notice your build breaks

00:12:15,040 --> 00:12:17,880
Then you know with relative certainty

00:12:18,880 --> 00:12:23,609
What exact change broke your build and that..

00:12:24,280 --> 00:12:26,490
Narrows down your search quite a bit

00:12:28,090 --> 00:12:30,750
Research Rust commit history blame and pr's

00:12:31,270 --> 00:12:35,819
The nice thing about the Rust development process is that it's really open

00:12:35,820 --> 00:12:39,599
I think that was a major theme in the keynote this morning and

00:12:40,210 --> 00:12:43,259
So if you find something that breaks

00:12:44,560 --> 00:12:49,080
it it's just a matter of a few minutes of poking around and you'll probably

00:12:49,570 --> 00:12:54,899
Find out what changed and why it changed and what you can do to fix it

00:12:56,560 --> 00:12:59,460
And finally subscribe to relevant tracking issues

00:13:01,020 --> 00:13:06,000
This this builds on that all rust being really open thing

00:13:07,420 --> 00:13:11,760
all unstable features including the procedural macro API

00:13:12,340 --> 00:13:13,840
have a

00:13:13,840 --> 00:13:18,299
Github issue that tracks all of the work that is done on

00:13:19,090 --> 00:13:21,090
that feature

00:13:23,290 --> 00:13:28,170
So it's a generally a good idea to subscribe to that particular tracking issue

00:13:33,260 --> 00:13:35,260
Now one other

00:13:35,300 --> 00:13:37,599
Problem I had with developing Maud

00:13:38,000 --> 00:13:43,569
Was keeping the library simple and well scoped because it was largely a one-man job

00:13:49,070 --> 00:13:54,700
One way I managed this complexity was in keeping this syntax really simple

00:13:55,580 --> 00:14:02,350
In particular I put distinguishing markers at the beginning of every expression within their syntax

00:14:03,200 --> 00:14:06,910
One example of this is in the "let" statement in rust

00:14:08,120 --> 00:14:14,859
if you've done any work with rust before, you know that the "let" statement starts with the keyword lit and

00:14:16,160 --> 00:14:19,180
Yeah, I know I'm saying a lot of obvious things here.

00:14:22,010 --> 00:14:26,800
And the nice thing about that is from a parsing point of view is that

00:14:27,350 --> 00:14:29,379
once you see the "let" keyword

00:14:29,630 --> 00:14:34,660
You know that the rest of that statement is going to be a "let" statement no matter what

00:14:35,090 --> 00:14:39,940
There's no way that you can go half way along that statement and suddenly realize

00:14:39,940 --> 00:14:43,329
oh, no, this is actually a while loop instead, right and

00:14:44,420 --> 00:14:49,089
That means a parser can avoid backtracking that's what it's called

00:14:49,090 --> 00:14:53,050
I'm having to go back and parse everything again

00:14:55,070 --> 00:14:59,469
Use the limiters parentheses square brackets and braces as much as possible

00:15:00,080 --> 00:15:06,910
One of the few things that the macro API gives you is that it groups these delimiters

00:15:07,250 --> 00:15:12,279
Automatically and so if you build your syntax around these particular delimiters

00:15:12,650 --> 00:15:16,209
Then not only will it look more consistent with the rest of rust...

00:15:16,520 --> 00:15:20,889
It will also make your job much easier because you don't have to match these up yourself

00:15:24,380 --> 00:15:30,490
One example of where these two principles apply is in the syntax for

00:15:31,520 --> 00:15:33,520
substituting-in dynamic content

00:15:33,950 --> 00:15:40,629
so if you've used the templating language, like handlebars or moustache before you'd know that to

00:15:41,600 --> 00:15:47,679
Include the value of some arbitrary expression at one time. You would do something like

00:15:48,379 --> 00:15:52,599
The example in the middle you would wrap an expression in braces

00:15:52,910 --> 00:15:56,559
And I had to come up with a similar syntax for Maud as well

00:15:58,339 --> 00:16:02,109
The first sentence I came up with was the one on the top

00:16:03,139 --> 00:16:09,818
Starting everything with a leading carret and while that followed the first principle of having a leading marker on it

00:16:10,610 --> 00:16:12,729
it didn't follow the second and

00:16:14,629 --> 00:16:20,859
The problem with that was well imagine there's more stuff around this particular expression

00:16:21,589 --> 00:16:26,349
For example suppose there is a pair of parentheses after

00:16:28,339 --> 00:16:30,339
The caret thing

00:16:33,019 --> 00:16:36,578
When the parser see that, how do we know that...

00:16:37,819 --> 00:16:40,449
the particular expression ends there and

00:16:41,149 --> 00:16:43,419
Not somewhere after

00:16:44,029 --> 00:16:51,039
that pair of parentheses like this could be a method call right or if there were square brackets there this

00:16:51,290 --> 00:16:57,699
Best could have been an array and we could have been trying to index it and so I ended up coming up with

00:16:59,779 --> 00:17:05,229
Really arbitrary rules around where a particular expression is supposed to end

00:17:06,020 --> 00:17:09,249
these days we have libraries like sign which let you

00:17:10,069 --> 00:17:14,619
Factor out this sort of parsing but it still makes life a bit difficult

00:17:16,909 --> 00:17:21,099
What I eventually settled on was the syntax on the bottom

00:17:21,649 --> 00:17:27,639
Wrapping everything in parentheses, and now this follows both principles, and it's really easy to parse

00:17:27,890 --> 00:17:30,609
That's what I still go with today

00:17:35,029 --> 00:17:37,029
Another issue I had was

00:17:39,140 --> 00:17:41,890
Well, I guess a piece of advice would be

00:17:42,620 --> 00:17:44,620
Don't fear the heap

00:17:44,929 --> 00:17:46,929
by the heap I mean

00:17:47,179 --> 00:17:51,459
structures like box, string and Vec, which that you choose

00:17:52,690 --> 00:17:58,210
and an arbitrary size for a particular data structure at runtime and

00:17:58,970 --> 00:18:05,110
the nice thing about rust is lets you avoid heap allocations altogether if you want to

00:18:05,780 --> 00:18:08,860
But that doesn't mean you have to do that

00:18:09,500 --> 00:18:17,079
and in fact zero allocation code can be much harder to read than the equivalent code that does allocate and

00:18:17,870 --> 00:18:24,159
Without benchmarking, it's hard to tell whether avoiding allocations actually makes your code faster

00:18:24,160 --> 00:18:27,100
I think sometimes it makes it slower. I'm not quite sure

00:18:31,130 --> 00:18:36,069
If you can imagine early versions of Maud did not follow this advice and

00:18:36,560 --> 00:18:41,740
I try to write a version of the library which didn't do any heap allocations

00:18:43,190 --> 00:18:46,510
Problem is when you're generating an HTML string

00:18:47,240 --> 00:18:50,469
You have to put all that data somewhere, right?

00:18:51,110 --> 00:18:54,339
If you're not allocating a new string to hold all of that

00:18:54,740 --> 00:19:00,219
you have to end up writing all of that data to an existing buffer and

00:19:00,920 --> 00:19:02,920
to support that I

00:19:02,960 --> 00:19:10,240
Had the macro instead generate a closure which took in an existing buffer and brought to that instead

00:19:11,690 --> 00:19:13,690
if you know about

00:19:14,150 --> 00:19:19,570
returning closures in rust you you would have heard of impot Traits and

00:19:20,480 --> 00:19:23,230
Not being able to name the type, you know

00:19:23,360 --> 00:19:26,860
there are a lot of issues around that and in particular if

00:19:27,050 --> 00:19:32,380
Your closure ends up referring to anything in your list of arguments

00:19:33,740 --> 00:19:38,079
That means that you have to annotate the lifetime of those particular parameters

00:19:38,900 --> 00:19:42,220
explicitly and that's the apostrophe our thing there and

00:19:43,010 --> 00:19:44,230
When I saw this

00:19:44,230 --> 00:19:51,519
I thought this is way too much effort just to generate a bunch of HTML and I came to my senses and ditched the idea

00:19:55,090 --> 00:19:57,090
Now so far I've

00:19:57,430 --> 00:19:59,170
covered

00:19:59,170 --> 00:20:04,739
more user-facing aspects of more like the kind of things that you as a user would see

00:20:06,190 --> 00:20:08,549
For the rest of this talk. I'm going to go more into

00:20:09,310 --> 00:20:11,310
implementation details

00:20:11,740 --> 00:20:13,660
things that

00:20:13,660 --> 00:20:17,910
You might not see as a user but still help you

00:20:19,330 --> 00:20:22,409
Help you structure your procedural macro internally

00:20:26,320 --> 00:20:30,059
First off using an abstract syntax tree or an AST

00:20:30,700 --> 00:20:38,039
By that I mean rather than taking the input to your macro and directly mapping it to the generated frost code

00:20:38,680 --> 00:20:41,519
you should instead take that input and

00:20:42,910 --> 00:20:47,339
Rearrange it into a sort of tree a more

00:20:48,160 --> 00:20:50,020
explicit or

00:20:50,020 --> 00:20:56,790
Simpler or more abstract form that is easier for the rest of your library to work with

00:20:59,350 --> 00:21:03,240
Early versions of Maud didn't do this. You might be setting a theme here and

00:21:04,540 --> 00:21:06,540
I

00:21:06,760 --> 00:21:10,320
Actually, I thought that was really cool at first because

00:21:11,320 --> 00:21:13,830
Well, everything is done in what a single pass

00:21:14,560 --> 00:21:19,859
But the problem was the moment I try to do any sort of analysis or optimization

00:21:20,770 --> 00:21:25,050
Everything just fell down and I ended up rewriting it to use an AST anyway

00:21:25,900 --> 00:21:28,979
So even if you don't think you need it now

00:21:29,890 --> 00:21:34,560
Please use some sort of syntax tree because you'll thank yourself later

00:21:38,590 --> 00:21:40,830
Another thing is keep the spans

00:21:41,590 --> 00:21:48,300
a span is a particular procedural macro thing that tells the compiler where a particular

00:21:48,670 --> 00:21:50,670
piece of code came from

00:21:51,460 --> 00:21:53,910
By that I mean the source file

00:21:54,670 --> 00:21:57,089
the line number the column number and

00:21:57,760 --> 00:21:59,760
various stuff about hygiene and

00:22:00,580 --> 00:22:07,919
The nice thing about well, the reason why you should keep the spans all the way through is that it improves compiler errors

00:22:09,279 --> 00:22:15,898
Imagine you generate some code and that generated code has a type error in it

00:22:17,110 --> 00:22:24,959
If you follow this advice and keep the spans all the way through to the output then when the compiler encounters this type error

00:22:25,360 --> 00:22:26,379
it'll

00:22:26,379 --> 00:22:28,409
understands that this generated code

00:22:28,690 --> 00:22:31,110
Originally came from this exact location

00:22:31,269 --> 00:22:38,039
In the user's code and that would Express this error in terms of what the user originally wrote

00:22:39,129 --> 00:22:43,319
whereas if you didn't keep the Spence the compiler would just drop its hands and say

00:22:43,389 --> 00:22:48,119
Well, the type error is somewhere within this file. Good luck figuring it out and

00:22:48,879 --> 00:22:54,059
It also avoids weird scoping issues. Like if you've heard about hygiene, this is probably it

00:22:54,059 --> 00:22:59,339
I can't claim to understand it. But if you keep the spans, that should all just work

00:23:02,470 --> 00:23:05,939
One example of we are using an ast and keeping the spans

00:23:07,450 --> 00:23:12,299
Was really nice is in a particular error message that Maud gives

00:23:14,320 --> 00:23:16,500
As you may know an HTML

00:23:17,110 --> 00:23:19,860
elements can have attributes attached to them and

00:23:20,350 --> 00:23:26,669
one of the rules around attributes is that you can't define the same attribute twice on the same element as

00:23:27,250 --> 00:23:31,559
Maud there's an HTML template language. We have to enforce this rule as well

00:23:32,259 --> 00:23:34,240
and

00:23:34,240 --> 00:23:36,689
If you have a closer look at this error message

00:23:37,809 --> 00:23:39,789
You'll see that

00:23:39,789 --> 00:23:44,638
It explicitly marks out the parts of the original code

00:23:45,490 --> 00:23:48,959
that are relevant to this issue like exactly and

00:23:49,840 --> 00:23:54,509
This wouldn't have been possible if we didn't keep an explicit structure that represents

00:23:55,120 --> 00:24:01,919
The user's input and it wouldn't be possible if we didn't keep track of the locations of every single

00:24:02,980 --> 00:24:04,980
Syntax node in there

00:24:09,020 --> 00:24:15,099
To cap off this talk I'm gonna touch on where Maud is going to next

00:24:16,640 --> 00:24:17,720
General

00:24:17,720 --> 00:24:20,800
Generally right now Maud is pretty much ready

00:24:20,810 --> 00:24:25,749
it's usable people are using it in production for some strange reason, but

00:24:26,960 --> 00:24:28,960
It's pretty much. Okay now

00:24:30,740 --> 00:24:33,609
So most of the work at this stage is polish

00:24:34,490 --> 00:24:39,010
In particular, I want more diagnostics more error messages and warnings

00:24:40,280 --> 00:24:42,280
in particular Maud

00:24:42,650 --> 00:24:46,900
Doesn't warn about invalid HTML elements in attributes right now

00:24:47,540 --> 00:24:54,700
and I would like to warn in the future and also rel="noopener" hands up if you

00:24:55,400 --> 00:24:59,619
Didn't know about well, no opener before I mentioned it

00:25:00,800 --> 00:25:07,539
Wow, that's a lot of people. Well everyone who raised their hand just then will benefit from this particular thing

00:25:08,180 --> 00:25:10,160
Yes

00:25:10,160 --> 00:25:16,989
And working on stable rust. This isn't a really high priority right now, but

00:25:18,800 --> 00:25:26,649
As more of the procedural macro API stabilizes somewhere along the line it'll tip the scales and it'll be worth pursuing

00:25:30,140 --> 00:25:37,599
So that's all I have for today thanks for listening and we'll enjoy the closing keynote

00:25:55,580 --> 00:25:57,580

YouTube URL: https://www.youtube.com/watch?v=11Bme1xw0ag


