Title: RustConf 2018: Integrating Rust into Tor: Successes and Challenges by Isis Lovecruft & Chelsea Komlo
Publication date: 2018-09-06
Playlist: RustConf 2018
Description: 
	RustConf 2018 - Integrating Rust into Tor: Successes and Challenges by Isis Lovecruft & Chelsea Komlo

In 2016, The Tor Project's network team decided to experiment with writing existing and new functionality in Rust. Since then, this experiment has turned into a team initiative, with multiple team members adding infrastructure and new functionality with the goal of integrating Rust components directly into the core Tor code base. By 2019, we will have several features tha will be only supported in Rust.

With this effort has come many challenges and questions, some which have remained unresolved. In this talk, we propose walking through this timeline, and sharing what we have learned, what was good, and what was challenging about integrating Rust into a 10+ year old security-critical C codebase. We will also offer ideas about what could make this easier going forward, and what we are excited and hoping to see in future Rust versions. Overall, we at The Tor Project are big fans of Rust. We are looking forward to sharing what we have learned and accomplished over the last two years.
Captions: 
	00:00:00,410 --> 00:00:17,570
[Music]

00:00:14,320 --> 00:00:20,960
hi you can hear us

00:00:17,570 --> 00:00:23,720
okay okay excellent step 1

00:00:20,960 --> 00:00:26,570
okay cool thank you for coming today I'm

00:00:23,720 --> 00:00:28,279
Chelsea and this is Isis colleague and

00:00:26,570 --> 00:00:30,440
friend and today we're gonna be talking

00:00:28,279 --> 00:00:32,119
to you about integrating rust into tor

00:00:30,440 --> 00:00:34,580
and we're gonna be talking to you about

00:00:32,119 --> 00:00:37,629
some of the successes we had and also

00:00:34,580 --> 00:00:40,879
challenges and things that we learned

00:00:37,629 --> 00:00:43,460
hi I'm Isis I do crypto graphic design

00:00:40,879 --> 00:00:45,350
and implementations often in rust and I

00:00:43,460 --> 00:00:46,130
also do security and privacy privacy

00:00:45,350 --> 00:00:50,120
engineering

00:00:46,130 --> 00:00:54,890
and I worked for the Tor project from

00:00:50,120 --> 00:00:57,500
2010 to last month in July 2018 and I

00:00:54,890 --> 00:00:58,760
very proudly no longer work there and if

00:00:57,500 --> 00:01:03,440
you want to know more about that you can

00:00:58,760 --> 00:01:05,000
talk to me after and I'm Chelsea I have

00:01:03,440 --> 00:01:07,880
worked on distributed systems and

00:01:05,000 --> 00:01:10,670
applied cryptography and I do research

00:01:07,880 --> 00:01:12,440
design and implementation on the

00:01:10,670 --> 00:01:17,149
intersection between distributed systems

00:01:12,440 --> 00:01:18,799
and cryptography we wanted to start off

00:01:17,149 --> 00:01:21,799
this talk by thinking the people who

00:01:18,799 --> 00:01:24,110
helped us get to where we are with this

00:01:21,799 --> 00:01:25,510
talk with the material and both the

00:01:24,110 --> 00:01:28,430
implementations that we've done as well

00:01:25,510 --> 00:01:30,049
so first I wanted to thank the members

00:01:28,430 --> 00:01:31,700
of the Tor network team who provided

00:01:30,049 --> 00:01:34,880
feedback about these issues and

00:01:31,700 --> 00:01:36,470
contributed to this effort as well so

00:01:34,880 --> 00:01:38,420
the people on the Tor network team that

00:01:36,470 --> 00:01:41,210
worked with us on those are Tim Wilson

00:01:38,420 --> 00:01:46,540
Brown Nick Mathewson Taylor you David

00:01:41,210 --> 00:01:46,540
GUI George caddy and nachus Alexander

00:01:46,810 --> 00:01:51,380
and Mike Perry and we also wanted to

00:01:50,090 --> 00:01:52,790
thank a whole bunch of rest people who

00:01:51,380 --> 00:01:54,140
worked with us and getting through

00:01:52,790 --> 00:01:56,240
challenges and answering all our

00:01:54,140 --> 00:01:58,490
questions and we're in general super

00:01:56,240 --> 00:02:01,490
helpful and kind and including Alex

00:01:58,490 --> 00:02:04,040
Payton Nishikori work are Nikolas

00:02:01,490 --> 00:02:06,350
Nikolas L without boats Steve clab Nick

00:02:04,040 --> 00:02:11,840
Alexia and Gessner Patrick Walton and

00:02:06,350 --> 00:02:14,450
many others okay so this is what we'll

00:02:11,840 --> 00:02:16,910
be talking about today um we'll just do

00:02:14,450 --> 00:02:19,070
a quick introduction about what tor is

00:02:16,910 --> 00:02:21,550
and then we'll talk about how we started

00:02:19,070 --> 00:02:24,319
on this effort where we are currently

00:02:21,550 --> 00:02:25,240
where we are going and overall what

00:02:24,319 --> 00:02:27,520
we've learned

00:02:25,240 --> 00:02:31,630
all of this work and then finally what

00:02:27,520 --> 00:02:36,220
we hope to see as well so very brief

00:02:31,630 --> 00:02:39,400
introduction to what is tor so tor is an

00:02:36,220 --> 00:02:42,820
anonymity tool and it allows people to

00:02:39,400 --> 00:02:44,830
use the Internet anonymously so tor will

00:02:42,820 --> 00:02:49,390
run on a client machine and there's also

00:02:44,830 --> 00:02:50,890
a network of what we call relays that

00:02:49,390 --> 00:02:54,190
make up the the Tor network and

00:02:50,890 --> 00:02:56,170
essentially client traffic is routed

00:02:54,190 --> 00:02:59,500
through the Tor network and it provides

00:02:56,170 --> 00:03:03,070
anonymity for that request to the end

00:02:59,500 --> 00:03:05,290
server it can also provide anonymity to

00:03:03,070 --> 00:03:07,960
the end server as well but essentially

00:03:05,290 --> 00:03:09,910
the tor is both the client and server

00:03:07,960 --> 00:03:15,640
software and then all of the relays that

00:03:09,910 --> 00:03:18,010
make up the intermediate network so with

00:03:15,640 --> 00:03:20,350
that said um little T tor is something

00:03:18,010 --> 00:03:24,790
that we distinguish so little T tor is

00:03:20,350 --> 00:03:27,900
actually the core code base that that we

00:03:24,790 --> 00:03:30,730
use for for this anonymity software and

00:03:27,900 --> 00:03:34,150
it's important to note that little T

00:03:30,730 --> 00:03:37,750
tour has been around since 2002 so it's

00:03:34,150 --> 00:03:39,700
a very old codebase and as you can see

00:03:37,750 --> 00:03:42,760
here there's about three hundred three

00:03:39,700 --> 00:03:45,100
hundred thousand lines of C so there's a

00:03:42,760 --> 00:03:47,800
lot of C code it's gone through a lot of

00:03:45,100 --> 00:03:49,090
evolution so kind of all the challenges

00:03:47,800 --> 00:03:51,730
that you might expect with something

00:03:49,090 --> 00:03:53,590
like that but it's interesting to see

00:03:51,730 --> 00:03:55,810
now that rust is actually the second

00:03:53,590 --> 00:03:58,630
most language that is being used in tor

00:03:55,810 --> 00:04:04,060
and all of this has come about really in

00:03:58,630 --> 00:04:05,710
the last year ok so just very brief

00:04:04,060 --> 00:04:09,430
introduction now we're going to talk

00:04:05,710 --> 00:04:11,560
about how we started with rust so I

00:04:09,430 --> 00:04:13,660
think it's interesting that we actually

00:04:11,560 --> 00:04:17,739
didn't start out saying we're gonna go

00:04:13,660 --> 00:04:20,890
to rust um this was rust was actually

00:04:17,739 --> 00:04:24,100
the end of a long conversation and this

00:04:20,890 --> 00:04:26,200
long conversation was how do we start to

00:04:24,100 --> 00:04:30,370
use languages which are memory safe in

00:04:26,200 --> 00:04:35,350
tor so we really want to protect end

00:04:30,370 --> 00:04:37,120
users C is very challenging very

00:04:35,350 --> 00:04:39,220
delicate and fragile and so

00:04:37,120 --> 00:04:41,199
as much as we can we wanted to do things

00:04:39,220 --> 00:04:44,260
that would protect end-users and help

00:04:41,199 --> 00:04:47,199
prevent bugs so the way that we actually

00:04:44,260 --> 00:04:49,449
started this is we had a meeting at one

00:04:47,199 --> 00:04:52,210
of our semiannual developer conferences

00:04:49,449 --> 00:04:54,130
and this meeting was about how do we

00:04:52,210 --> 00:04:56,620
start to move to memory safe languages

00:04:54,130 --> 00:04:59,139
and so when we were talking about this

00:04:56,620 --> 00:05:01,479
we identified some goals some of the

00:04:59,139 --> 00:05:02,860
goals were to do no harm so the code

00:05:01,479 --> 00:05:05,139
that we deployed we didn't want to be a

00:05:02,860 --> 00:05:07,660
liability to the user we wanted to have

00:05:05,139 --> 00:05:09,070
confidence in what we deployed other

00:05:07,660 --> 00:05:11,050
things were like developer friendliness

00:05:09,070 --> 00:05:12,910
and productivity so we wanted to make

00:05:11,050 --> 00:05:15,010
sure that you know he didn't take us a

00:05:12,910 --> 00:05:16,210
year a really long time to deploy some

00:05:15,010 --> 00:05:18,250
of these things we wanted to get up and

00:05:16,210 --> 00:05:20,919
running quickly across the platform

00:05:18,250 --> 00:05:23,620
compatibility so these were some of the

00:05:20,919 --> 00:05:25,600
things that we talked about and I think

00:05:23,620 --> 00:05:27,220
it's amazing I don't know if you've ever

00:05:25,600 --> 00:05:29,620
been in a group of developers who are

00:05:27,220 --> 00:05:35,650
talking about what is the best language

00:05:29,620 --> 00:05:38,650
to pick consensus is usually never

00:05:35,650 --> 00:05:41,830
achieved there's a lot of really strong

00:05:38,650 --> 00:05:43,870
differing opinions but I think what was

00:05:41,830 --> 00:05:46,539
amazing is after we did this rust

00:05:43,870 --> 00:05:48,490
actually emerged as pretty much the

00:05:46,539 --> 00:05:51,220
language that everyone said that we

00:05:48,490 --> 00:05:54,039
should experiment and and prototype so

00:05:51,220 --> 00:05:55,599
this was amazing at the end we're all

00:05:54,039 --> 00:05:57,510
looking each other like are we all

00:05:55,599 --> 00:06:00,580
agreeing is this really happening

00:05:57,510 --> 00:06:02,260
we all agreed never to say the name of

00:06:00,580 --> 00:06:03,849
any language during this discussion at

00:06:02,260 --> 00:06:05,770
the beginning and then someone said rust

00:06:03,849 --> 00:06:06,789
and then someone else said rust and then

00:06:05,770 --> 00:06:13,900
everyone was like wait are we just

00:06:06,789 --> 00:06:15,789
saying rust we saw this is a very good

00:06:13,900 --> 00:06:17,770
sign and we're like let's try this out

00:06:15,789 --> 00:06:22,300
as quickly as possible before we like

00:06:17,770 --> 00:06:25,449
scattered so it was a really special

00:06:22,300 --> 00:06:27,099
moment I think with that said there was

00:06:25,449 --> 00:06:28,990
a lot of questions that we had so this

00:06:27,099 --> 00:06:30,190
is a new language for a lot of us Isis

00:06:28,990 --> 00:06:32,800
had done quite a bit of rest before

00:06:30,190 --> 00:06:35,560
outside of tour but a lot of us hadn't

00:06:32,800 --> 00:06:38,110
and so what we did is we identified

00:06:35,560 --> 00:06:39,490
where we were at that moment and the

00:06:38,110 --> 00:06:42,190
kinds of things that we needed to

00:06:39,490 --> 00:06:44,020
identify to say yes like tor is a

00:06:42,190 --> 00:06:46,300
first-class supported language or sorry

00:06:44,020 --> 00:06:47,940
rest is a first-class supported language

00:06:46,300 --> 00:06:50,370
or no this is

00:06:47,940 --> 00:06:51,570
gonna work for us so essentially we went

00:06:50,370 --> 00:06:53,910
through and sort of laid out this

00:06:51,570 --> 00:06:55,350
timeline and start just and think about

00:06:53,910 --> 00:06:57,570
all the things that we needed to know

00:06:55,350 --> 00:06:59,970
and identify and try before we were like

00:06:57,570 --> 00:07:03,930
okay this is this is a good idea let's

00:06:59,970 --> 00:07:05,670
let's go for it and so we had some

00:07:03,930 --> 00:07:08,010
critical questions that we didn't know

00:07:05,670 --> 00:07:09,480
the answers to at that time so one

00:07:08,010 --> 00:07:11,490
critical question is how could we

00:07:09,480 --> 00:07:14,220
integrate rust into the tour build

00:07:11,490 --> 00:07:16,560
system right so this code base has been

00:07:14,220 --> 00:07:19,590
around since the 2002 there's a lot of

00:07:16,560 --> 00:07:21,360
old tooling a lot of complexity and so

00:07:19,590 --> 00:07:23,220
we didn't want to have to rewrite our

00:07:21,360 --> 00:07:24,690
entire build system so one thing we

00:07:23,220 --> 00:07:26,910
wanted to know is how do we just sort of

00:07:24,690 --> 00:07:29,760
do it do a drop-in and start to

00:07:26,910 --> 00:07:31,170
integrate rust right away another

00:07:29,760 --> 00:07:33,180
question we had is what is the overhead

00:07:31,170 --> 00:07:35,460
to implement existing or new sub modules

00:07:33,180 --> 00:07:37,740
and rust we didn't want to do a rewrite

00:07:35,460 --> 00:07:40,050
the world approach we really couldn't do

00:07:37,740 --> 00:07:41,970
that and so we were thinking like you

00:07:40,050 --> 00:07:43,460
know how much work is it going to be to

00:07:41,970 --> 00:07:45,480
do this do we have to sort of

00:07:43,460 --> 00:07:48,050
re-implement everything or is this going

00:07:45,480 --> 00:07:48,050
to be really hard

00:07:48,600 --> 00:07:52,800
one other question we had is is rust

00:07:51,180 --> 00:07:55,620
supported on the platforms that tor

00:07:52,800 --> 00:07:57,360
supports so diversity is a good thing

00:07:55,620 --> 00:07:59,669
and the Tor network we don't want a

00:07:57,360 --> 00:08:01,590
single bug on one operating system to

00:07:59,669 --> 00:08:02,760
take out the entire network so we wanted

00:08:01,590 --> 00:08:05,340
to make sure that we could continue to

00:08:02,760 --> 00:08:09,870
sort of support this ecosystem diversity

00:08:05,340 --> 00:08:11,520
and then finally another question we had

00:08:09,870 --> 00:08:13,530
is can we reproducibly build tour with

00:08:11,520 --> 00:08:16,290
rust enabled this is something we still

00:08:13,530 --> 00:08:18,750
need to investigate but reproducibility

00:08:16,290 --> 00:08:21,870
for us is really important both for user

00:08:18,750 --> 00:08:24,090
confidence in the binary that's being

00:08:21,870 --> 00:08:28,640
distributed and also for us in order to

00:08:24,090 --> 00:08:28,640
reproduce bugs that have been reported

00:08:29,750 --> 00:08:33,990
okay so that was sort of how we started

00:08:32,010 --> 00:08:36,030
in the questions that we had at the time

00:08:33,990 --> 00:08:38,280
now we're going to talk about where we

00:08:36,030 --> 00:08:43,140
are with this effort in some of the work

00:08:38,280 --> 00:08:45,390
that has been going on so the first one

00:08:43,140 --> 00:08:46,650
well not the first thing but one of the

00:08:45,390 --> 00:08:49,530
first things we started with was an

00:08:46,650 --> 00:08:51,510
experimental sub-module rewrite so we

00:08:49,530 --> 00:08:53,820
wanted the question we wanted to answer

00:08:51,510 --> 00:08:56,940
is can we rewrite an existing sub module

00:08:53,820 --> 00:08:58,200
with little overhead or code changing so

00:08:56,940 --> 00:08:58,630
basically can we take something that's

00:08:58,200 --> 00:09:00,550
already

00:08:58,630 --> 00:09:04,510
their import it to rust and and what

00:09:00,550 --> 00:09:07,450
happens with that so what we did is we

00:09:04,510 --> 00:09:09,790
chose one Saba sub module with limited

00:09:07,450 --> 00:09:13,570
dependencies in a simple interface and

00:09:09,790 --> 00:09:15,340
Isis is going to talk more about sort of

00:09:13,570 --> 00:09:16,720
the consequences after we did this and

00:09:15,340 --> 00:09:18,790
stabilizing it and bringing this to

00:09:16,720 --> 00:09:20,740
production but the reason why we chose

00:09:18,790 --> 00:09:22,720
what we did at the time is so that you

00:09:20,740 --> 00:09:25,330
know it was kind of minimal impact and

00:09:22,720 --> 00:09:29,310
we thought with a simpler dependency

00:09:25,330 --> 00:09:33,430
graph we could sort of do this right and

00:09:29,310 --> 00:09:34,660
um we were successful I think we didn't

00:09:33,430 --> 00:09:36,970
actually have to change any of the

00:09:34,660 --> 00:09:38,950
calling C code when we did this so it

00:09:36,970 --> 00:09:40,870
was nice to say it was a nice validation

00:09:38,950 --> 00:09:43,300
to say like with what we have here we

00:09:40,870 --> 00:09:44,740
can actually slot something else in the

00:09:43,300 --> 00:09:46,510
overall takeaway that we had from this

00:09:44,740 --> 00:09:48,970
though is refactoring would have

00:09:46,510 --> 00:09:53,890
actually been really helpful to this

00:09:48,970 --> 00:09:56,380
sort of porting exercise so the

00:09:53,890 --> 00:09:58,240
experiment was useful we did get

00:09:56,380 --> 00:10:01,090
something in but in the future we really

00:09:58,240 --> 00:10:04,390
want to refactor our C code and make

00:10:01,090 --> 00:10:05,950
things as simple and less complex before

00:10:04,390 --> 00:10:10,600
we actually start to put more things to

00:10:05,950 --> 00:10:14,260
rest and so one thing that we are doing

00:10:10,600 --> 00:10:16,660
right now is a modulation effort so this

00:10:14,260 --> 00:10:18,520
is all on the sea side but we feel our

00:10:16,660 --> 00:10:22,630
marginalization effort will actually

00:10:18,520 --> 00:10:25,840
enable moving more functionality to rest

00:10:22,630 --> 00:10:28,330
in the future with less challenges of

00:10:25,840 --> 00:10:35,410
managing complexity on both sides which

00:10:28,330 --> 00:10:37,690
we'll go into more as well so one of the

00:10:35,410 --> 00:10:40,150
issues we ran into once we integrated

00:10:37,690 --> 00:10:43,060
and once we redid one of our modules in

00:10:40,150 --> 00:10:46,660
rust it was that we ran into linking

00:10:43,060 --> 00:10:48,880
issues with tests so the problem is that

00:10:46,660 --> 00:10:51,160
building C code and rust code of static

00:10:48,880 --> 00:10:53,500
libraries using the same sanitizer for

00:10:51,160 --> 00:10:55,510
example goobies on or ace on doesn't

00:10:53,500 --> 00:10:57,760
currently have a configurable way to

00:10:55,510 --> 00:10:59,620
pass the same sanitizer options to the

00:10:57,760 --> 00:11:00,910
linker which causes problems for unit

00:10:59,620 --> 00:11:04,060
tests code where the rust code is

00:11:00,910 --> 00:11:05,620
actually calling the C code for doc

00:11:04,060 --> 00:11:07,720
tests mean a similar way to pass

00:11:05,620 --> 00:11:09,910
arguments the C linker when the the rust

00:11:07,720 --> 00:11:10,350
code in a doc test is actually wrapping

00:11:09,910 --> 00:11:13,080
some

00:11:10,350 --> 00:11:15,360
see somewhere originally I thought this

00:11:13,080 --> 00:11:16,770
was that we would need a multi-stage

00:11:15,360 --> 00:11:19,110
build process because we had rust

00:11:16,770 --> 00:11:21,210
calling C and C calling rust and back

00:11:19,110 --> 00:11:22,680
and forth maybe if we like refactor to

00:11:21,210 --> 00:11:23,940
everything into smaller static libraries

00:11:22,680 --> 00:11:26,070
and then linked them together in the end

00:11:23,940 --> 00:11:30,090
that it would be okay but that still

00:11:26,070 --> 00:11:32,790
didn't fix the issue with AIDS on this

00:11:30,090 --> 00:11:34,710
has resulted in us stubbing out test

00:11:32,790 --> 00:11:36,300
versions of rust code which are in pure

00:11:34,710 --> 00:11:38,790
rust and they're essentially re

00:11:36,300 --> 00:11:41,490
implementations of code which is

00:11:38,790 --> 00:11:45,030
wrapping C code so for example I wrapped

00:11:41,490 --> 00:11:47,280
our usage of OpenSSL x' PRNG and hash

00:11:45,030 --> 00:11:50,790
digests with code to implement R and RNG

00:11:47,280 --> 00:11:52,560
and digest digest traits but we then had

00:11:50,790 --> 00:11:54,420
to substitute pure rust implementations

00:11:52,560 --> 00:11:57,090
during the testing to avoid the linker

00:11:54,420 --> 00:11:58,680
errors because if you look at higher

00:11:57,090 --> 00:12:00,570
level cryptographic implementations like

00:11:58,680 --> 00:12:03,480
signatures which need to get a hash or

00:12:00,570 --> 00:12:04,860
need to get randomness from the RNG they

00:12:03,480 --> 00:12:07,320
were calling this code that was wrapping

00:12:04,860 --> 00:12:09,720
up in SSL and then the linker issues

00:12:07,320 --> 00:12:11,850
were coming back again so this is one of

00:12:09,720 --> 00:12:15,890
the sort of hard problems that we've hit

00:12:11,850 --> 00:12:15,890
and we're not quite sure what to do yet

00:12:19,400 --> 00:12:26,700
so seeing as that was like a wonderful

00:12:23,930 --> 00:12:28,380
thing to go through we thought that you

00:12:26,700 --> 00:12:30,810
know we would go further and like

00:12:28,380 --> 00:12:33,600
Chelsey mentioned rewriting this module

00:12:30,810 --> 00:12:36,980
and so not just wrapping the C code but

00:12:33,600 --> 00:12:39,690
maintaining two implementations of a

00:12:36,980 --> 00:12:41,850
bitwise and behavioral identical

00:12:39,690 --> 00:12:44,340
behaviorally identical binary parser in

00:12:41,850 --> 00:12:46,890
both C and rust at the same time and

00:12:44,340 --> 00:12:49,770
this is more largely because we weren't

00:12:46,890 --> 00:12:52,350
quite ready to say we're doing rust and

00:12:49,770 --> 00:12:53,970
we can write rust and ditch the C so we

00:12:52,350 --> 00:12:55,470
wanted to do rust but then just have it

00:12:53,970 --> 00:12:58,800
side by side so that you could compile

00:12:55,470 --> 00:13:02,630
with either one this turns out to be a

00:12:58,800 --> 00:13:07,230
really really bad idea a very bad idea

00:13:02,630 --> 00:13:10,950
don't do this really don't do this in

00:13:07,230 --> 00:13:13,230
maintaining this behaviorally identical

00:13:10,950 --> 00:13:16,200
binary parser we found bugs in both

00:13:13,230 --> 00:13:17,790
implementations lots of bugs and some of

00:13:16,200 --> 00:13:21,819
the bugs got CVE numbers assigned to

00:13:17,790 --> 00:13:27,709
them bugs bugs

00:13:21,819 --> 00:13:29,389
Unicode bugs it's also a really good way

00:13:27,709 --> 00:13:32,149
to drive your developers right up the

00:13:29,389 --> 00:13:33,769
wall as they basically manually fuzz for

00:13:32,149 --> 00:13:35,779
edge cases which produce different

00:13:33,769 --> 00:13:37,370
behaviors which in the context of an

00:13:35,779 --> 00:13:39,319
anonymity system it's really important

00:13:37,370 --> 00:13:41,449
that if someone had compiled with rust

00:13:39,319 --> 00:13:43,009
or if someone compiled and they see that

00:13:41,449 --> 00:13:44,660
their behaviors aren't different and

00:13:43,009 --> 00:13:47,509
this actually goes down to a really low

00:13:44,660 --> 00:13:49,399
level like for example if in the rest

00:13:47,509 --> 00:13:51,470
version we're doing more allocations you

00:13:49,399 --> 00:13:57,319
may be able to if you can give them a

00:13:51,470 --> 00:13:59,269
string for this parser to parse this

00:13:57,319 --> 00:14:00,769
might result in it expanding and taking

00:13:59,269 --> 00:14:02,149
up more memory than it would in the C

00:14:00,769 --> 00:14:03,550
version so you might be able to learn

00:14:02,149 --> 00:14:05,600
things about what kind of machine

00:14:03,550 --> 00:14:07,129
someone is running it on or what code

00:14:05,600 --> 00:14:10,490
they're running and thus tell the

00:14:07,129 --> 00:14:11,839
difference between clients we found some

00:14:10,490 --> 00:14:12,319
of the bugs we found a memory exhaustion

00:14:11,839 --> 00:14:14,389
attack

00:14:12,319 --> 00:14:16,699
we found two different remote crashes

00:14:14,389 --> 00:14:20,269
due to new null pointer to reference and

00:14:16,699 --> 00:14:24,500
a DOS attack due to triggered by an

00:14:20,269 --> 00:14:27,050
infinite loop so that was all great that

00:14:24,500 --> 00:14:29,029
worked really well it was lots of fun to

00:14:27,050 --> 00:14:30,889
write hundreds of unit tests and so we

00:14:29,029 --> 00:14:33,949
decided we do it with cryptic encrypted

00:14:30,889 --> 00:14:37,880
graphic implementations and this

00:14:33,949 --> 00:14:39,079
actually turned out to be okay we

00:14:37,880 --> 00:14:40,880
already had support for several

00:14:39,079 --> 00:14:42,860
different implementations of the edge

00:14:40,880 --> 00:14:45,649
two five five one nine signature scheme

00:14:42,860 --> 00:14:48,380
and the way we did that was registering

00:14:45,649 --> 00:14:51,230
the external code via Struck's cancan

00:14:48,380 --> 00:14:53,779
containing function pointers so to

00:14:51,230 --> 00:14:56,060
integrate ed 255 one night dalek which

00:14:53,779 --> 00:14:58,069
is a pure rust implementation of the

00:14:56,060 --> 00:15:00,620
signature scheme and its underlying

00:14:58,069 --> 00:15:02,569
curve library curve to 509 dalek all we

00:15:00,620 --> 00:15:05,059
had to do was create fi which presented

00:15:02,569 --> 00:15:08,240
the same interfaces as those defined in

00:15:05,059 --> 00:15:10,430
the function pointers this is a lot

00:15:08,240 --> 00:15:12,079
easier to implement and test and it

00:15:10,430 --> 00:15:13,730
should prove easier to maintain in the

00:15:12,079 --> 00:15:16,160
future and this is probably largely due

00:15:13,730 --> 00:15:18,019
to if you're writing cryptographic

00:15:16,160 --> 00:15:19,250
implementations you have to match test

00:15:18,019 --> 00:15:22,269
vectors and if you don't something's

00:15:19,250 --> 00:15:26,899
horribly horribly wrong with your math

00:15:22,269 --> 00:15:29,930
so moving up the stack from bad ideas to

00:15:26,899 --> 00:15:33,680
better ideas we then decided it would be

00:15:29,930 --> 00:15:35,690
OK to design a new feature in tor and to

00:15:33,680 --> 00:15:38,450
only do it in rust

00:15:35,690 --> 00:15:40,550
and so this work was done by her

00:15:38,450 --> 00:15:42,500
colleagues Tim Wilson Brown and Nick

00:15:40,550 --> 00:15:44,330
Mathewson it was based upon our other

00:15:42,500 --> 00:15:46,730
colleagues work rob janson and Erin

00:15:44,330 --> 00:15:48,890
Johnson and as I said it's the first

00:15:46,730 --> 00:15:52,760
time that we integrated something into

00:15:48,890 --> 00:15:54,110
tour that was rust only so in

00:15:52,760 --> 00:15:58,370
cryptography a differential privacy

00:15:54,110 --> 00:16:01,280
system is it aims to provide a way to

00:15:58,370 --> 00:16:03,530
maximize the accuracy of queries to a

00:16:01,280 --> 00:16:05,450
statistical database while minimizing

00:16:03,530 --> 00:16:08,240
the chances of identifying specific

00:16:05,450 --> 00:16:09,890
records and so in TOR precount

00:16:08,240 --> 00:16:12,380
is doing this and it's aimed at safely

00:16:09,890 --> 00:16:13,880
gathering anonymized metrics on servers

00:16:12,380 --> 00:16:15,680
in a manner that is resistant to the

00:16:13,880 --> 00:16:17,780
servers colluding with each other to

00:16:15,680 --> 00:16:19,340
influence the results or to learn things

00:16:17,780 --> 00:16:22,010
about the metrics that are being

00:16:19,340 --> 00:16:23,480
gathered and so they're doing this by

00:16:22,010 --> 00:16:25,430
adding a bit of noise to the metrics

00:16:23,480 --> 00:16:28,250
that they're gathering and they're using

00:16:25,430 --> 00:16:30,350
a homomorphism when everything's put

00:16:28,250 --> 00:16:33,530
back together to remove the blinding

00:16:30,350 --> 00:16:34,910
factor and retrieve like metrics over

00:16:33,530 --> 00:16:38,330
the whole system and not about any

00:16:34,910 --> 00:16:40,430
particular user server and this is using

00:16:38,330 --> 00:16:43,190
a Shamir secret sharing for robustness

00:16:40,430 --> 00:16:46,490
with the prereqs algorithm developed by

00:16:43,190 --> 00:16:52,340
our colleagues fellow researchers tarik

00:16:46,490 --> 00:16:55,010
allahi Georg Genesis and Ian Goldberg so

00:16:52,340 --> 00:16:56,990
we're gonna talk a bit about where we're

00:16:55,010 --> 00:17:02,060
going in the future and more about what

00:16:56,990 --> 00:17:04,760
we've learned yeah so I think it's

00:17:02,060 --> 00:17:06,530
important to note that rust is a really

00:17:04,760 --> 00:17:08,810
great language and we really like it

00:17:06,530 --> 00:17:11,900
especially for the safety that it

00:17:08,810 --> 00:17:13,939
provides when you are using rust across

00:17:11,900 --> 00:17:17,510
an MFI boundary this is where there's a

00:17:13,939 --> 00:17:20,780
lot of complexity and things that we

00:17:17,510 --> 00:17:23,329
found to be challenging so one thing

00:17:20,780 --> 00:17:25,610
that we are excited to see is in the

00:17:23,329 --> 00:17:27,980
recent release of rust is the ability to

00:17:25,610 --> 00:17:29,240
use a global allocator so before this

00:17:27,980 --> 00:17:31,580
what we were doing is we were managing

00:17:29,240 --> 00:17:34,250
memory on sort of both sides of the

00:17:31,580 --> 00:17:36,200
language boundary and we were trying to

00:17:34,250 --> 00:17:39,410
do this in such a way that it was you

00:17:36,200 --> 00:17:41,540
know less prone to errors by developers

00:17:39,410 --> 00:17:43,100
but it was it was pretty challenging and

00:17:41,540 --> 00:17:44,600
we had a lot of discussions about you

00:17:43,100 --> 00:17:46,490
know would you allocate on C and free on

00:17:44,600 --> 00:17:47,049
rust and you know when do you do this

00:17:46,490 --> 00:17:50,259
and how do you

00:17:47,049 --> 00:17:51,669
do this safely so this is something

00:17:50,259 --> 00:17:54,129
we're going to be moving to and we're

00:17:51,669 --> 00:18:04,480
really glad to see this feature being

00:17:54,129 --> 00:18:07,179
released that button okay so another

00:18:04,480 --> 00:18:09,009
thing we're excited or sorry another

00:18:07,179 --> 00:18:10,360
thing that we want to do in the future

00:18:09,009 --> 00:18:12,999
is have some kind of automated mechanism

00:18:10,360 --> 00:18:16,330
to keep Si and rust shared types and

00:18:12,999 --> 00:18:18,279
sync so Isis is gonna talk more about

00:18:16,330 --> 00:18:22,299
this in a bit but we really tried to

00:18:18,279 --> 00:18:24,549
keep our rust interfaces pure rust and

00:18:22,299 --> 00:18:26,259
RC interfaces pure C and we sort of have

00:18:24,549 --> 00:18:29,200
this translation layer in between and we

00:18:26,259 --> 00:18:30,789
do this largely for safety but what this

00:18:29,200 --> 00:18:33,820
means is then we have duplicated types

00:18:30,789 --> 00:18:35,259
across the language boundary and keeping

00:18:33,820 --> 00:18:36,850
those in sync has proven to be

00:18:35,259 --> 00:18:39,179
challenging and we're kind of worried

00:18:36,850 --> 00:18:41,379
about bugs that are in the future so

00:18:39,179 --> 00:18:42,999
we're we've been looking at how do we

00:18:41,379 --> 00:18:47,440
have some kind of automated mechanism to

00:18:42,999 --> 00:18:48,970
keep these in sync okay so that's sort

00:18:47,440 --> 00:18:50,980
of where we started where we're going

00:18:48,970 --> 00:18:54,840
and now we're gonna talk about a lot of

00:18:50,980 --> 00:18:54,840
lessons that we've learned along the way

00:18:54,899 --> 00:19:00,070
so right so as I was just mentioning

00:18:57,519 --> 00:19:04,330
complex objects across fo5 boundaries

00:19:00,070 --> 00:19:06,399
are difficult yeah we're doing this

00:19:04,330 --> 00:19:09,129
manually if you look in our code base

00:19:06,399 --> 00:19:11,190
there's comments where we say this this

00:19:09,129 --> 00:19:14,559
is coupled across the language boundary

00:19:11,190 --> 00:19:16,989
and really it's just mental overhead to

00:19:14,559 --> 00:19:19,809
keep track of what is on both sides and

00:19:16,989 --> 00:19:23,859
this can be constants structs we do this

00:19:19,809 --> 00:19:25,570
with enums we do this so that in rust we

00:19:23,859 --> 00:19:29,470
don't have to have unsafe like c

00:19:25,570 --> 00:19:31,600
handling code everywhere but it does

00:19:29,470 --> 00:19:35,499
introduce duplication and complexity

00:19:31,600 --> 00:19:37,090
across the boundary yeah and so any

00:19:35,499 --> 00:19:39,460
anywhere you have sort of duplication

00:19:37,090 --> 00:19:42,730
without static checking is is something

00:19:39,460 --> 00:19:44,739
to be worried about and we also have

00:19:42,730 --> 00:19:49,239
extra copies when we convert types

00:19:44,739 --> 00:19:51,759
across the boundary so in towards C code

00:19:49,239 --> 00:19:53,470
there's a concept of a smart list so

00:19:51,759 --> 00:19:55,690
it's essentially a deck of arbitrary

00:19:53,470 --> 00:19:57,549
types and so when we pass this across

00:19:55,690 --> 00:19:59,620
the language boundary we convert this

00:19:57,549 --> 00:20:02,050
into pure rust

00:19:59,620 --> 00:20:04,960
vector we do this with strings right now

00:20:02,050 --> 00:20:06,580
and it does introduce extra copies and

00:20:04,960 --> 00:20:09,370
when we start to do this with structs or

00:20:06,580 --> 00:20:13,150
other other types we haven't done this

00:20:09,370 --> 00:20:16,630
yet but we do extra copies to ensure

00:20:13,150 --> 00:20:21,820
safety but it does have some overhead to

00:20:16,630 --> 00:20:24,460
it and just as a fine example of how we

00:20:21,820 --> 00:20:26,440
do this right now essentially we have an

00:20:24,460 --> 00:20:29,590
enum on both sides of the language

00:20:26,440 --> 00:20:31,780
boundary and as enums are ordered are

00:20:29,590 --> 00:20:33,550
represented as ordered integers we can

00:20:31,780 --> 00:20:34,750
sort of pass this through and then on

00:20:33,550 --> 00:20:36,250
the rest side do some kind of

00:20:34,750 --> 00:20:38,200
translation based on this ordered

00:20:36,250 --> 00:20:43,090
integer and translate it into a rusty

00:20:38,200 --> 00:20:44,830
numb don't do this this is bad but it

00:20:43,090 --> 00:20:46,870
would be nice we've been thinking about

00:20:44,830 --> 00:20:49,270
how can we do this in a way that's safe

00:20:46,870 --> 00:20:51,220
and we you know any suggestions or

00:20:49,270 --> 00:20:53,620
lessons learned please let us know but

00:20:51,220 --> 00:20:55,540
this is sort of our our early attempts

00:20:53,620 --> 00:20:58,840
at doing translation where we could keep

00:20:55,540 --> 00:21:00,309
rust pure but still be able to pass

00:20:58,840 --> 00:21:04,870
complex types across the language

00:21:00,309 --> 00:21:07,210
boundary all right

00:21:04,870 --> 00:21:09,190
so another lesson we learned was it was

00:21:07,210 --> 00:21:13,600
really important to keep a very rusty

00:21:09,190 --> 00:21:14,110
API separate from the FFI and we didn't

00:21:13,600 --> 00:21:16,030
do this

00:21:14,110 --> 00:21:19,630
at first we wrote a lot of very

00:21:16,030 --> 00:21:22,390
suspiciously see looking rust code we

00:21:19,630 --> 00:21:24,160
had basically like implementing the same

00:21:22,390 --> 00:21:25,960
behavior in this in this binary parser

00:21:24,160 --> 00:21:28,000
again implementing the same behavior but

00:21:25,960 --> 00:21:30,970
then sort of exporting the same

00:21:28,000 --> 00:21:32,320
interface as the C so this very C like

00:21:30,970 --> 00:21:35,290
thing that you do where you pass a

00:21:32,320 --> 00:21:36,670
pointer to just a buffer as like the

00:21:35,290 --> 00:21:37,870
first argument and then that's actually

00:21:36,670 --> 00:21:40,720
your return because you don't actually

00:21:37,870 --> 00:21:42,580
have a return type or yeah it's just bad

00:21:40,720 --> 00:21:44,920
it looked really bad and we've slowly

00:21:42,580 --> 00:21:48,100
rewritten it a bunch of times and now

00:21:44,920 --> 00:21:49,960
the rest api's are really good we ended

00:21:48,100 --> 00:21:51,550
up defining coding standards which said

00:21:49,960 --> 00:21:54,070
that the pure rust implementations

00:21:51,550 --> 00:21:56,320
needed to present intuitive easy to use

00:21:54,070 --> 00:21:58,600
rusty api's and that the code for FFI

00:21:56,320 --> 00:22:00,700
and interfacing with c needed to live

00:21:58,600 --> 00:22:04,270
elsewhere in a separate module so we

00:22:00,700 --> 00:22:07,090
have crates for each c module that we've

00:22:04,270 --> 00:22:08,120
written so far and each one is supposed

00:22:07,090 --> 00:22:10,430
to have

00:22:08,120 --> 00:22:12,620
it's code in its own module and then

00:22:10,430 --> 00:22:15,680
another epified ors module so that the

00:22:12,620 --> 00:22:20,360
FFO i code is very distinct from the

00:22:15,680 --> 00:22:22,280
rest api this should work better moving

00:22:20,360 --> 00:22:23,870
forward once we have more rust code

00:22:22,280 --> 00:22:25,750
calling more rust code because then we

00:22:23,870 --> 00:22:29,180
can have types which nicely and

00:22:25,750 --> 00:22:32,120
implement the traits to make them work

00:22:29,180 --> 00:22:34,010
better together but it does seem to be

00:22:32,120 --> 00:22:37,160
slightly confusing to new contributors

00:22:34,010 --> 00:22:39,440
in the meantime our rest coding

00:22:37,160 --> 00:22:42,500
standards also require that rust to CF

00:22:39,440 --> 00:22:45,380
of AI be kept separate to see to rust FF

00:22:42,500 --> 00:22:47,870
I and that our rest to see FF I all live

00:22:45,380 --> 00:22:49,600
in one big crate very far away from the

00:22:47,870 --> 00:22:52,670
other crates to avoid code duplication

00:22:49,600 --> 00:22:55,610
so if I'm writing Russ code which is

00:22:52,670 --> 00:22:58,820
calling see you don't want someone to

00:22:55,610 --> 00:23:00,470
have that FF I defined eight times in

00:22:58,820 --> 00:23:02,390
like eight different crates and someone

00:23:00,470 --> 00:23:06,860
makes a mistake and a type somewhere or

00:23:02,390 --> 00:23:09,050
it calls the wrong function so another

00:23:06,860 --> 00:23:11,120
thing we learned was that it was better

00:23:09,050 --> 00:23:14,600
to write new features and rust while

00:23:11,120 --> 00:23:16,790
also rewriting things in rust and if we

00:23:14,600 --> 00:23:18,770
had to do this again we'd up for writing

00:23:16,790 --> 00:23:20,870
new features while rewriting the old

00:23:18,770 --> 00:23:23,390
code and by rewrite it and rust here we

00:23:20,870 --> 00:23:25,040
mean replacing don't maintain two

00:23:23,390 --> 00:23:26,930
separate implementations of something

00:23:25,040 --> 00:23:28,430
don't do that if you have to do that

00:23:26,930 --> 00:23:31,850
don't do it for any substantial amount

00:23:28,430 --> 00:23:33,470
of time more specifically maintaining

00:23:31,850 --> 00:23:36,200
these two bitwise and behaviorally

00:23:33,470 --> 00:23:39,440
identical binary parsers was bad and it

00:23:36,200 --> 00:23:41,270
led to badness and sadness talking new

00:23:39,440 --> 00:23:43,070
features in rust only as well as

00:23:41,270 --> 00:23:45,290
rewriting things was awesome and great

00:23:43,070 --> 00:23:47,810
especially rewriting making new features

00:23:45,290 --> 00:23:50,120
in rust and you should toss all your old

00:23:47,810 --> 00:23:54,170
C and technical debt out the window for

00:23:50,120 --> 00:23:56,120
faces sake so another thing we found

00:23:54,170 --> 00:23:57,590
helpful and thankfully we did do this

00:23:56,120 --> 00:24:00,110
from the very beginning because as

00:23:57,590 --> 00:24:01,880
Chelsea mentioned I was somewhat

00:24:00,110 --> 00:24:04,160
familiar with rust and some of my team

00:24:01,880 --> 00:24:06,880
was not is that we started a running

00:24:04,160 --> 00:24:09,410
code standards guide which included

00:24:06,880 --> 00:24:11,750
helping developers find the

00:24:09,410 --> 00:24:13,430
documentation and find you know here's

00:24:11,750 --> 00:24:15,110
the instructions on how to use rest up

00:24:13,430 --> 00:24:18,080
here's like the rust programming

00:24:15,110 --> 00:24:21,049
language book here's the nomicon

00:24:18,080 --> 00:24:22,429
and walking them through the standards

00:24:21,049 --> 00:24:24,559
from the outset and pointing to them

00:24:22,429 --> 00:24:27,169
often when people were confused and

00:24:24,559 --> 00:24:30,140
revising them as people were confused in

00:24:27,169 --> 00:24:32,929
new ways we found that it was important

00:24:30,140 --> 00:24:35,149
to give developers very clear concise

00:24:32,929 --> 00:24:35,779
explanations of both what to do and what

00:24:35,149 --> 00:24:39,110
not to do

00:24:35,779 --> 00:24:40,610
along with code snippets explaining and

00:24:39,110 --> 00:24:47,899
explaining like the reasons for why

00:24:40,610 --> 00:24:50,929
we've made these choices so part of our

00:24:47,899 --> 00:24:52,820
code standards for safety has a bunch of

00:24:50,929 --> 00:24:54,919
examples and there's a link in a second

00:24:52,820 --> 00:24:56,899
that I'll show you but it seeks to

00:24:54,919 --> 00:24:58,730
educate developers on like what is

00:24:56,899 --> 00:25:00,679
undefined behavior and rust and that it

00:24:58,730 --> 00:25:02,360
still exists because some people didn't

00:25:00,679 --> 00:25:05,929
realize this switching from C from the

00:25:02,360 --> 00:25:08,870
outset avoiding unwinding across the FFI

00:25:05,929 --> 00:25:11,269
boundary avoiding panics maintaining

00:25:08,870 --> 00:25:13,070
type safety avoiding unsafe and

00:25:11,269 --> 00:25:15,820
unwrapped we're in whenever you can and

00:25:13,070 --> 00:25:18,679
when you can't you have to document it

00:25:15,820 --> 00:25:20,690
White was saying the only only C API

00:25:18,679 --> 00:25:23,029
compatible types for crossing the FFI

00:25:20,690 --> 00:25:26,000
boundary which that enum one back there

00:25:23,029 --> 00:25:27,470
was I think that's not okay according to

00:25:26,000 --> 00:25:29,049
our standards but it still exists in

00:25:27,470 --> 00:25:31,820
there anyway

00:25:29,049 --> 00:25:33,320
no abusing unsafe to muck around with

00:25:31,820 --> 00:25:35,600
lifetimes

00:25:33,320 --> 00:25:38,000
how to avoid memory leaks and C string

00:25:35,600 --> 00:25:39,830
usage performing allocations to copy

00:25:38,000 --> 00:25:42,889
buffers across the FFI boundary as

00:25:39,830 --> 00:25:45,169
Chelsey mentioned avoid enums if you can

00:25:42,889 --> 00:25:48,350
and don't do anything weird with floats

00:25:45,169 --> 00:25:50,630
and a bunch of more do's and don'ts in

00:25:48,350 --> 00:25:52,909
there so if you want to look at these

00:25:50,630 --> 00:25:55,490
guides if they are useful for your

00:25:52,909 --> 00:25:57,649
project feel free to take them if you

00:25:55,490 --> 00:25:59,539
have more guidelines that you'd like to

00:25:57,649 --> 00:26:05,539
contribute we'd be happy to take pull

00:25:59,539 --> 00:26:08,000
requests and so with that said there are

00:26:05,539 --> 00:26:11,990
a few things that we would hope to see

00:26:08,000 --> 00:26:15,799
from rust in the future one of them was

00:26:11,990 --> 00:26:17,570
that with this binary parser Chelsea and

00:26:15,799 --> 00:26:19,460
I essentially sat there writing hundreds

00:26:17,570 --> 00:26:21,080
and hundreds of unit tests trying to

00:26:19,460 --> 00:26:23,899
find all the edge cases like if you put

00:26:21,080 --> 00:26:25,190
two commas in a row what happens does a

00:26:23,899 --> 00:26:27,230
different thing happen and see does a

00:26:25,190 --> 00:26:29,779
different thing happen in rust if I say

00:26:27,230 --> 00:26:32,029
that I support version 5 - 5

00:26:29,779 --> 00:26:33,349
, six does that do a different thing in

00:26:32,029 --> 00:26:35,090
rust and a different thing and see and

00:26:33,349 --> 00:26:36,799
we had to write all of these edge cases

00:26:35,090 --> 00:26:38,929
by hand and we were sitting there like

00:26:36,799 --> 00:26:41,119
this is what fsor is for why are we

00:26:38,929 --> 00:26:43,940
doing this but we didn't really have an

00:26:41,119 --> 00:26:45,799
easy go-to way to hook up like a FL or

00:26:43,940 --> 00:26:48,529
anything through cargo fuzz or another

00:26:45,799 --> 00:26:50,899
similar project and say hey please like

00:26:48,529 --> 00:26:52,609
take the same buzzing input and give it

00:26:50,899 --> 00:26:54,619
to both the C function and the stress

00:26:52,609 --> 00:27:00,409
function and then test that the output

00:26:54,619 --> 00:27:03,080
is exactly the same one thing I also

00:27:00,409 --> 00:27:05,899
wanted to note that we experienced as we

00:27:03,080 --> 00:27:08,269
were going throughout this work is the

00:27:05,899 --> 00:27:10,549
work of bringing along an entire team in

00:27:08,269 --> 00:27:11,869
this effort so just to bring back to

00:27:10,549 --> 00:27:14,479
what Isis was talking about with our

00:27:11,869 --> 00:27:16,159
coding standards I think you know one

00:27:14,479 --> 00:27:17,809
thing we worked on a lot it was like

00:27:16,159 --> 00:27:19,519
working with our team and sort of

00:27:17,809 --> 00:27:24,019
bringing people along as we were doing

00:27:19,519 --> 00:27:26,589
this effort just as like a side note but

00:27:24,019 --> 00:27:29,419
I think one thing we're hoping to see

00:27:26,589 --> 00:27:32,659
out of rust as well as sort of better

00:27:29,419 --> 00:27:34,639
GFI documentation so a lot of the coding

00:27:32,659 --> 00:27:36,710
standards that Isis was just talking

00:27:34,639 --> 00:27:38,239
about were things that as we are going

00:27:36,710 --> 00:27:41,179
along and doing code review we're like

00:27:38,239 --> 00:27:44,239
oh this is like really unsafe across an

00:27:41,179 --> 00:27:46,909
MFI boundary but I think one thing that

00:27:44,239 --> 00:27:48,799
wasn't immediately clear is you know

00:27:46,909 --> 00:27:49,729
when you go and learn how to write pure

00:27:48,799 --> 00:27:51,320
rust how does that actually

00:27:49,729 --> 00:27:53,719
differentiate from writing rust that'll

00:27:51,320 --> 00:27:55,729
be called across that's a 5-pound Rianne

00:27:53,719 --> 00:27:56,929
what what types of safety guarantees do

00:27:55,729 --> 00:28:00,019
you have when you're writing pure rust

00:27:56,929 --> 00:28:03,070
versus something that's called from C so

00:28:00,019 --> 00:28:05,479
we've done a lot of documentation in our

00:28:03,070 --> 00:28:07,339
coding standards about that type of

00:28:05,479 --> 00:28:09,589
thing but I think sort of

00:28:07,339 --> 00:28:12,950
differentiating the different worlds of

00:28:09,589 --> 00:28:14,179
pure rust versus not would be helpful to

00:28:12,950 --> 00:28:19,700
people who are just getting into this

00:28:14,179 --> 00:28:22,099
work in the future so another thing we

00:28:19,700 --> 00:28:24,889
ran into is that we tried to use bind

00:28:22,099 --> 00:28:27,919
gen in some cases and partly because our

00:28:24,889 --> 00:28:30,049
code it was kind of a tangled mess like

00:28:27,919 --> 00:28:31,639
for example we have this one header we

00:28:30,049 --> 00:28:34,339
don't have it anymore but it was called

00:28:31,639 --> 00:28:36,649
orh and it was roughly 30,000 lines of

00:28:34,339 --> 00:28:38,599
code and essentially contained every

00:28:36,649 --> 00:28:39,030
struct you might ever use anywhere in

00:28:38,599 --> 00:28:42,000
this and

00:28:39,030 --> 00:28:44,400
codebase it was bad we got rid of it but

00:28:42,000 --> 00:28:48,300
when we ran bind Jen with that bind Jen

00:28:44,400 --> 00:28:50,490
was like I will generate everything this

00:28:48,300 --> 00:28:52,770
whole 30,000 light and we're like no no

00:28:50,490 --> 00:28:56,340
I just I I know that file is sourced

00:28:52,770 --> 00:28:59,400
there I just wanted just the thing just

00:28:56,340 --> 00:29:01,350
the one module not the whole world and

00:28:59,400 --> 00:29:03,480
it was really hard to figure out how to

00:29:01,350 --> 00:29:06,090
try to configure by Jen to not do this

00:29:03,480 --> 00:29:08,880
and we ended up looking at the ways that

00:29:06,090 --> 00:29:11,370
Firefox was using by Jen and the point

00:29:08,880 --> 00:29:13,200
that you're looking at your browser code

00:29:11,370 --> 00:29:14,700
to try to figure out how to call it

00:29:13,200 --> 00:29:16,950
tools so that you could call it in a

00:29:14,700 --> 00:29:18,540
different way in your code was like very

00:29:16,950 --> 00:29:20,040
confusing and hard so we haven't been

00:29:18,540 --> 00:29:22,110
able to use find Jen that much and it

00:29:20,040 --> 00:29:25,140
would be great to have like better

00:29:22,110 --> 00:29:30,470
documentation on like how to use that it

00:29:25,140 --> 00:29:42,519
four different cases Thanks

00:29:30,470 --> 00:29:42,519
[Applause]

00:29:43,200 --> 00:29:50,840
[Music]

00:29:48,780 --> 00:29:50,840

YouTube URL: https://www.youtube.com/watch?v=WI4ApeHH9QE


