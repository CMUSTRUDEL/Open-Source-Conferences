Title: RustConf 2018 - Getting Something for Nothing by James Munns
Publication date: 2018-09-06
Playlist: RustConf 2018
Description: 
	RustConf 2018 - Getting Something for Nothing by James Munns

This talk explores how to use the Rust Type System and Borrow Checker to write safe abstractions of hardware, even when using direct control of memory mapped peripherals with unsafe blocks. Because these techniques move all (or most) of the checking to compile time, these techniques are perfect for systems where high performance or resource constraints are a requirement.

This talk will explain and explore how these techniques are used on Microcontroller systems as a critical part of the embedded-hal ecosystem.
Captions: 
	00:00:00,410 --> 00:00:16,550
[Music]

00:00:14,500 --> 00:00:18,590
okay so we're going without speaker

00:00:16,550 --> 00:00:21,020
notes here so if I stumble for a second

00:00:18,590 --> 00:00:23,000
than a bear with me but this is getting

00:00:21,020 --> 00:00:24,740
something for nothing

00:00:23,000 --> 00:00:25,939
so I'll put this up here while I'm

00:00:24,740 --> 00:00:28,310
talking so if you want to take a picture

00:00:25,939 --> 00:00:30,770
I'm James Muntz I'm an embedded systems

00:00:28,310 --> 00:00:33,710
developer my background is in developing

00:00:30,770 --> 00:00:36,140
everything from avionics IOT connected

00:00:33,710 --> 00:00:37,940
devices on bit should mapped on Twitter

00:00:36,140 --> 00:00:39,379
and here's my email so if anyone wants

00:00:37,940 --> 00:00:41,920
to take a picture of that and come talk

00:00:39,379 --> 00:00:44,930
to me I would love to hear from you all

00:00:41,920 --> 00:00:47,300
so this talk is sort of about embedded

00:00:44,930 --> 00:00:49,309
systems but what this talk is really

00:00:47,300 --> 00:00:51,920
about is how we can teach the rust

00:00:49,309 --> 00:00:54,050
compiler about what we're trying to do

00:00:51,920 --> 00:00:56,899
with embedded systems to get it to

00:00:54,050 --> 00:00:58,520
enforce what we want it to enforce so

00:00:56,899 --> 00:01:02,210
that we're not manually checking this

00:00:58,520 --> 00:01:03,980
out the concept of getting something for

00:01:02,210 --> 00:01:07,640
nothing or as it's more commonly called

00:01:03,980 --> 00:01:10,970
zero cost abstractions is not super new

00:01:07,640 --> 00:01:12,979
to the rest compiler in fact if you look

00:01:10,970 --> 00:01:15,830
at the website it's literally the first

00:01:12,979 --> 00:01:17,479
feature that they put on the website so

00:01:15,830 --> 00:01:19,610
zero cost since abstractions are

00:01:17,479 --> 00:01:24,950
something that's really really intrinsic

00:01:19,610 --> 00:01:26,840
to the rust language itself also if you

00:01:24,950 --> 00:01:28,159
haven't so how many embedded developers

00:01:26,840 --> 00:01:31,340
do we have here who's worked on a

00:01:28,159 --> 00:01:35,180
microcontroller or a Raspberry Pi okay

00:01:31,340 --> 00:01:39,590
awesome so the use of rust for embedded

00:01:35,180 --> 00:01:41,540
systems isn't super new back in 2014 the

00:01:39,590 --> 00:01:43,520
crew from pebble liked the SmartWatch

00:01:41,540 --> 00:01:45,560
that was on Kickstarter actually had a

00:01:43,520 --> 00:01:48,170
user space application written in rust

00:01:45,560 --> 00:01:52,369
so this is an August of 2014 so this

00:01:48,170 --> 00:01:56,060
worked with rust 0.12 so not super new

00:01:52,369 --> 00:02:00,290
but we've come a long way since then so

00:01:56,060 --> 00:02:03,229
rust in 2018 especially for the 2018

00:02:00,290 --> 00:02:04,490
Aero release has a lot of stuff in the

00:02:03,229 --> 00:02:06,259
keynote this morning they talked about

00:02:04,490 --> 00:02:08,360
all the stuff that's stabilizing this

00:02:06,259 --> 00:02:09,979
year and some of thats things that you

00:02:08,360 --> 00:02:12,860
notice when you're developing rust on

00:02:09,979 --> 00:02:14,600
any platform but there's also been a lot

00:02:12,860 --> 00:02:16,910
of things that have been stabilizing for

00:02:14,600 --> 00:02:18,820
embedded systems and a lot of it has to

00:02:16,910 --> 00:02:21,709
do with the weirdness of running code

00:02:18,820 --> 00:02:23,629
outside of an operating system what do

00:02:21,709 --> 00:02:24,920
you do if your code panics and you have

00:02:23,629 --> 00:02:26,020
no operating system to crash your

00:02:24,920 --> 00:02:28,030
program what

00:02:26,020 --> 00:02:30,340
the first thing you do after you power

00:02:28,030 --> 00:02:32,440
up what starts your application how do

00:02:30,340 --> 00:02:33,640
you tell the rust compiler to say no

00:02:32,440 --> 00:02:35,140
really just start running this

00:02:33,640 --> 00:02:40,930
application there's nothing else here to

00:02:35,140 --> 00:02:42,940
do luckily rust has the backing of LVM

00:02:40,930 --> 00:02:46,180
so we're using LVM as a compiler

00:02:42,940 --> 00:02:48,910
back-end and LOV M has already been used

00:02:46,180 --> 00:02:51,130
for C and C++ to target these embedded

00:02:48,910 --> 00:02:52,960
microcontrollers so kind of the really

00:02:51,130 --> 00:02:54,190
low-level plumbing has already been done

00:02:52,960 --> 00:02:56,740
in LOV M

00:02:54,190 --> 00:02:59,230
so getting rust to support things that

00:02:56,740 --> 00:03:00,730
already exist in LLVM is a much more

00:02:59,230 --> 00:03:02,650
straightforward process than if we were

00:03:00,730 --> 00:03:04,570
trying to bring all of rusts to a

00:03:02,650 --> 00:03:09,100
microcontroller that it had never had a

00:03:04,570 --> 00:03:11,050
concept of before also when we're

00:03:09,100 --> 00:03:13,540
working on these embedded systems you

00:03:11,050 --> 00:03:16,570
typically don't have an operating system

00:03:13,540 --> 00:03:17,830
and the standard library takes for

00:03:16,570 --> 00:03:19,540
granted a lot of things that an

00:03:17,830 --> 00:03:22,210
operating system provides the ability to

00:03:19,540 --> 00:03:23,920
open files and sockets and dynamically

00:03:22,210 --> 00:03:26,020
allocate memory and that's not

00:03:23,920 --> 00:03:29,020
necessarily guaranteed to exist on this

00:03:26,020 --> 00:03:30,850
embedded system but luckily we can throw

00:03:29,020 --> 00:03:32,620
it all away by marking whatever we're

00:03:30,850 --> 00:03:34,630
building is no standard and then if we

00:03:32,620 --> 00:03:37,720
want we can progressively add these

00:03:34,630 --> 00:03:43,510
features that we do want to support back

00:03:37,720 --> 00:03:45,850
into what we're building and with all

00:03:43,510 --> 00:03:48,610
the things that are stabilizing in 2018

00:03:45,850 --> 00:03:50,350
it's our goal and I say are the embedded

00:03:48,610 --> 00:03:52,720
working group who's working in getting

00:03:50,350 --> 00:03:56,560
rust working or embedded working with

00:03:52,720 --> 00:03:59,110
rust is that you can just install the

00:03:56,560 --> 00:04:01,150
stable version of rust do cargo build

00:03:59,110 --> 00:04:03,790
for one of these microcontroller targets

00:04:01,150 --> 00:04:06,400
and you get a working microcontroller

00:04:03,790 --> 00:04:08,620
binary building firmware doesn't have to

00:04:06,400 --> 00:04:10,570
be complex and the batteries are still

00:04:08,620 --> 00:04:13,480
included you still have all the great

00:04:10,570 --> 00:04:15,210
things that come come with rust and all

00:04:13,480 --> 00:04:17,859
you had to do was install Russ No

00:04:15,210 --> 00:04:19,120
downloading tons of dependencies and

00:04:17,859 --> 00:04:21,370
making sure you had the right version of

00:04:19,120 --> 00:04:23,770
GCC and getting all yeah none of that

00:04:21,370 --> 00:04:28,930
the idea is just like you build a rust

00:04:23,770 --> 00:04:30,280
application so I've been talking a lot

00:04:28,930 --> 00:04:31,450
about embedded systems but I haven't

00:04:30,280 --> 00:04:33,370
done a good job of defining what

00:04:31,450 --> 00:04:35,500
embedded systems are so my

00:04:33,370 --> 00:04:37,930
tongue-in-cheek description is computers

00:04:35,500 --> 00:04:40,030
you don't sit in front of and

00:04:37,930 --> 00:04:42,190
could be anything from the TV remote

00:04:40,030 --> 00:04:45,009
sitting on the coffee table at home to

00:04:42,190 --> 00:04:46,870
the engine control system for a rocket

00:04:45,009 --> 00:04:50,259
it could be satellites it could be

00:04:46,870 --> 00:04:52,539
electronics and airplanes all of this

00:04:50,259 --> 00:04:54,160
are combinations of hardware and

00:04:52,539 --> 00:04:56,710
software that we're designed to do one

00:04:54,160 --> 00:04:58,840
thing and do it really well not like a

00:04:56,710 --> 00:05:01,840
general-purpose computer but very

00:04:58,840 --> 00:05:03,850
purpose-built system so this definition

00:05:01,840 --> 00:05:05,740
covers a huge range like I said

00:05:03,850 --> 00:05:09,100
everything from your TV remote to a

00:05:05,740 --> 00:05:10,570
Tesla would be an embedded system but

00:05:09,100 --> 00:05:13,060
we're gonna focus at least for today's

00:05:10,570 --> 00:05:15,849
talk way down on the smaller side of

00:05:13,060 --> 00:05:18,820
this so microcontroller systems this is

00:05:15,849 --> 00:05:20,919
way closer to an Arduino than something

00:05:18,820 --> 00:05:22,060
like a Tegra dev kit that can do machine

00:05:20,919 --> 00:05:23,530
vision

00:05:22,060 --> 00:05:25,720
so these microcontrollers have a

00:05:23,530 --> 00:05:28,990
phenomenal amount of hardware powers

00:05:25,720 --> 00:05:33,160
ability to react to the real world while

00:05:28,990 --> 00:05:34,660
being really a TBD tiny so specifically

00:05:33,160 --> 00:05:37,780
this is an example of a microcontroller

00:05:34,660 --> 00:05:39,610
this is a Nordic and RF 52 Bluetooth

00:05:37,780 --> 00:05:41,680
chip and if you have some bluetooth

00:05:39,610 --> 00:05:43,780
devices in your home chances are this is

00:05:41,680 --> 00:05:45,159
what's powering at least some of them so

00:05:43,780 --> 00:05:47,260
I actually have this board so this is a

00:05:45,159 --> 00:05:50,080
really big picture but this is the board

00:05:47,260 --> 00:05:50,380
that I'm talking about all that's upside

00:05:50,080 --> 00:05:52,360
down

00:05:50,380 --> 00:05:54,400
but this is a whole development kit the

00:05:52,360 --> 00:05:56,530
actual embedded system is in this while

00:05:54,400 --> 00:05:59,050
it's Red Square up there but this tiny

00:05:56,530 --> 00:06:00,940
white square here which is a little

00:05:59,050 --> 00:06:04,060
smaller than a postage stamp so an

00:06:00,940 --> 00:06:05,770
entire running computer system fits way

00:06:04,060 --> 00:06:07,479
smaller than a postage stamp and they

00:06:05,770 --> 00:06:11,860
actually get way smaller than this this

00:06:07,479 --> 00:06:14,620
is like a medium sized one so these

00:06:11,860 --> 00:06:17,199
little micro controllers have CPU and

00:06:14,620 --> 00:06:20,380
RAM and I say Ram I mean like 20 or 64

00:06:17,199 --> 00:06:23,380
kilobytes of RAM and a tens or hundreds

00:06:20,380 --> 00:06:24,729
of megahertz of CPU but that's not all

00:06:23,380 --> 00:06:27,699
they have they have this hidden

00:06:24,729 --> 00:06:30,460
superpower called peripherals which are

00:06:27,699 --> 00:06:33,340
a way of interacting with the real

00:06:30,460 --> 00:06:36,159
physical world or electronics that help

00:06:33,340 --> 00:06:37,690
you interact with the physical world the

00:06:36,159 --> 00:06:40,449
cool thing about these peripherals is

00:06:37,690 --> 00:06:42,310
they can go off and do stuff while your

00:06:40,449 --> 00:06:44,199
CPU is off doing something more

00:06:42,310 --> 00:06:48,340
important kind of like offloading

00:06:44,199 --> 00:06:50,620
computation to a GPU but for a lot of

00:06:48,340 --> 00:06:51,520
really domain-specific interesting

00:06:50,620 --> 00:06:52,900
things and then

00:06:51,520 --> 00:06:55,419
nice thing about being able to offload

00:06:52,900 --> 00:06:56,919
this is that your CPU can go off and do

00:06:55,419 --> 00:06:59,379
something better while this is going on

00:06:56,919 --> 00:07:02,169
instead of busy waiting around or it can

00:06:59,379 --> 00:07:06,970
do nothing and save power by going to

00:07:02,169 --> 00:07:10,720
sleep but unlike your GPU which has a

00:07:06,970 --> 00:07:12,580
software API like Vulcan or OpenGL where

00:07:10,720 --> 00:07:15,669
you've got a real software library for

00:07:12,580 --> 00:07:18,819
dealing with this hardware they don't

00:07:15,669 --> 00:07:21,789
have that they have a hardware API so

00:07:18,819 --> 00:07:23,530
they have a way where your CPU can shove

00:07:21,789 --> 00:07:25,840
some bits and bytes in certain places

00:07:23,530 --> 00:07:28,900
and that gets your peripheral doing the

00:07:25,840 --> 00:07:30,550
things that you want it to do so these

00:07:28,900 --> 00:07:32,050
are called memory map peripherals

00:07:30,550 --> 00:07:35,949
because the way they're exposed to your

00:07:32,050 --> 00:07:37,960
CPU is there's a chunk of memory at an

00:07:35,949 --> 00:07:39,639
arbitrary location and you have to know

00:07:37,960 --> 00:07:41,289
if I write a bit here it will do

00:07:39,639 --> 00:07:42,460
something if I write a whole byte here

00:07:41,289 --> 00:07:44,680
it will do something else

00:07:42,460 --> 00:07:47,229
these microcontrollers have a real and

00:07:44,680 --> 00:07:49,150
linear 32-bit addressing space so these

00:07:47,229 --> 00:07:52,659
are 32-bit microcontrollers which means

00:07:49,150 --> 00:07:55,120
everything from 0 0 0 0 to F F F F F is

00:07:52,659 --> 00:07:58,449
a real location and you can write stuff

00:07:55,120 --> 00:07:59,919
to it so these are real places and

00:07:58,449 --> 00:08:02,440
there's nothing like an MMU that's gonna

00:07:59,919 --> 00:08:03,940
protect you of virtualizing the memory

00:08:02,440 --> 00:08:07,539
or making sure that you have access to

00:08:03,940 --> 00:08:09,219
certain tables and because these

00:08:07,539 --> 00:08:11,380
microcontrollers only have tens or

00:08:09,219 --> 00:08:13,389
hundreds of kilobytes of RAM there's a

00:08:11,380 --> 00:08:15,449
lot of extra room this is for gigabyte

00:08:13,389 --> 00:08:18,520
or for word what is it 4 gigabytes of

00:08:15,449 --> 00:08:21,039
address space you know it's a lot of

00:08:18,520 --> 00:08:22,569
room so the developers of these marek

00:08:21,039 --> 00:08:25,270
controller said well we're only using

00:08:22,569 --> 00:08:27,430
like 64 kilobytes of it for memory so

00:08:25,270 --> 00:08:29,759
what can we do with all of that extra

00:08:27,430 --> 00:08:29,759
space

00:08:31,740 --> 00:08:35,770
so what they do is they design a system

00:08:34,240 --> 00:08:38,140
that looks kind of like this and this is

00:08:35,770 --> 00:08:40,570
a really dense diagram from a data sheet

00:08:38,140 --> 00:08:41,680
but this shows you everything from zero

00:08:40,570 --> 00:08:43,810
like that's where your Flash

00:08:41,680 --> 00:08:45,700
non-volatile storage lives all the way

00:08:43,810 --> 00:08:46,870
up to F which might be a ROM table or

00:08:45,700 --> 00:08:49,810
something like that so this is the

00:08:46,870 --> 00:08:51,790
memory map of this specific processor

00:08:49,810 --> 00:08:53,650
and you see over on the right there are

00:08:51,790 --> 00:08:57,190
some peripherals up there and these are

00:08:53,650 --> 00:09:01,300
the that magic stuff that allows you to

00:08:57,190 --> 00:09:03,400
interact with the real world and one of

00:09:01,300 --> 00:09:06,400
these registers so this one 32 bit

00:09:03,400 --> 00:09:09,250
register is the SPI peripheral frequency

00:09:06,400 --> 00:09:11,620
configuration register for the NRF 52

00:09:09,250 --> 00:09:13,450
and there's also a lot on here but the

00:09:11,620 --> 00:09:16,090
important part is is it shows you the

00:09:13,450 --> 00:09:18,520
different values so if you write eight

00:09:16,090 --> 00:09:20,470
zero zero zero zero to this register

00:09:18,520 --> 00:09:22,840
this serial port will now begin sending

00:09:20,470 --> 00:09:24,100
at 8 megabit per second and all the

00:09:22,840 --> 00:09:26,140
registers work like this there's

00:09:24,100 --> 00:09:27,460
arbitrary stuff at arbitrary locations

00:09:26,140 --> 00:09:29,350
you've got to read these huge data

00:09:27,460 --> 00:09:30,520
sheets and figure out where you're

00:09:29,350 --> 00:09:32,110
hurting your bits from where to where

00:09:30,520 --> 00:09:33,310
and put them in the right place and

00:09:32,110 --> 00:09:34,930
stuff like that this is a

00:09:33,310 --> 00:09:38,140
microcontroller development at a very

00:09:34,930 --> 00:09:40,620
low level so great we have a language

00:09:38,140 --> 00:09:42,820
that works with microcontrollers and

00:09:40,620 --> 00:09:45,760
we've got a great way of working with

00:09:42,820 --> 00:09:47,110
them so now what we do we we write code

00:09:45,760 --> 00:09:50,170
that's obviously the first thing you do

00:09:47,110 --> 00:09:51,340
before planning so you might write some

00:09:50,170 --> 00:09:53,890
code that looks like this you go I've

00:09:51,340 --> 00:09:56,320
got this serial port at this memory

00:09:53,890 --> 00:10:00,010
location so it's a mutable reference to

00:09:56,320 --> 00:10:01,720
a 32-bit word so this is my pointer so I

00:10:00,010 --> 00:10:04,330
want might want to make a function that

00:10:01,720 --> 00:10:05,890
reads and because of this Hardware is

00:10:04,330 --> 00:10:07,180
interacting with the real world this

00:10:05,890 --> 00:10:09,040
memory can change out from underneath

00:10:07,180 --> 00:10:11,230
you so it's a volatile read or a

00:10:09,040 --> 00:10:13,180
volatile write so you write this you

00:10:11,230 --> 00:10:15,310
wrap the function and unsafe so that

00:10:13,180 --> 00:10:18,070
your user doesn't have to call unsafe

00:10:15,310 --> 00:10:20,890
every time you call it and this is kind

00:10:18,070 --> 00:10:23,020
of gross to look at but it does work and

00:10:20,890 --> 00:10:26,410
you can read this serial port speed and

00:10:23,020 --> 00:10:28,240
you can write this serial port speed but

00:10:26,410 --> 00:10:30,550
it's it's not so great and if you're

00:10:28,240 --> 00:10:32,650
coming from a rust background you might

00:10:30,550 --> 00:10:34,480
go this isn't really what rust library

00:10:32,650 --> 00:10:37,840
code looks like right I want something

00:10:34,480 --> 00:10:39,970
more rusty so you might break it up into

00:10:37,840 --> 00:10:42,010
a struct you might call a serial port

00:10:39,970 --> 00:10:43,630
struct where you organized this and now

00:10:42,010 --> 00:10:45,310
you've nicely hidden this point

00:10:43,630 --> 00:10:47,560
in the arbitrary values inside of the

00:10:45,310 --> 00:10:49,510
struct as constant values so you can use

00:10:47,560 --> 00:10:51,880
them and you've given yourself a way to

00:10:49,510 --> 00:10:53,200
create this new serial port and then you

00:10:51,880 --> 00:10:54,460
might give it like member functions

00:10:53,200 --> 00:10:57,550
where you can do this so now you can go

00:10:54,460 --> 00:10:59,620
serial port dot read speed great this

00:10:57,550 --> 00:11:02,920
actually works so you can in your

00:10:59,620 --> 00:11:04,990
function do something you get one of

00:11:02,920 --> 00:11:06,760
these serial port handles you read the

00:11:04,990 --> 00:11:07,780
speed and then maybe you do some work

00:11:06,760 --> 00:11:10,000
and then you're like now I want to go

00:11:07,780 --> 00:11:13,090
high speed and you change the speed and

00:11:10,000 --> 00:11:14,950
this kind of thing would work but the

00:11:13,090 --> 00:11:16,630
problem with this is if you notice I

00:11:14,950 --> 00:11:18,340
just kind of conjured the serial port

00:11:16,630 --> 00:11:20,800
out of nowhere and the problem is if you

00:11:18,340 --> 00:11:22,720
can do it once you can do whatever

00:11:20,800 --> 00:11:24,430
wherever you want so if you have a

00:11:22,720 --> 00:11:26,560
slightly bigger example where you're

00:11:24,430 --> 00:11:28,360
setting up the serial port making sure

00:11:26,560 --> 00:11:30,160
it's the right speed and then you call

00:11:28,360 --> 00:11:32,140
some other something else function that

00:11:30,160 --> 00:11:33,730
you worked on a couple days ago and okay

00:11:32,140 --> 00:11:36,010
now we can get started but the problem

00:11:33,730 --> 00:11:37,690
is in that other function you also have

00:11:36,010 --> 00:11:40,150
one of these and this is changing the

00:11:37,690 --> 00:11:42,910
speed out from under you and this is not

00:11:40,150 --> 00:11:44,710
a great thing because if you wrote those

00:11:42,910 --> 00:11:46,410
code on different days or with two

00:11:44,710 --> 00:11:48,340
different developers or months apart

00:11:46,410 --> 00:11:50,860
you're gonna forget that these things

00:11:48,340 --> 00:11:53,140
are related and now you've got mutable

00:11:50,860 --> 00:11:54,460
aliasing pointers which is kind of a

00:11:53,140 --> 00:11:56,080
whole reason we wanted to switch to

00:11:54,460 --> 00:11:59,500
realist was to avoid these kind of

00:11:56,080 --> 00:12:01,840
problems so this is smelling like

00:11:59,500 --> 00:12:03,580
mutable global state and unfortunately

00:12:01,840 --> 00:12:06,250
hardware is nothing but a big collection

00:12:03,580 --> 00:12:07,960
of mutable global State which is painful

00:12:06,250 --> 00:12:11,140
if you're coming from a rust background

00:12:07,960 --> 00:12:13,240
so if we wanted to fix this if we were

00:12:11,140 --> 00:12:14,860
to set some rules how do we avoid global

00:12:13,240 --> 00:12:16,300
mutable state well let's come up with

00:12:14,860 --> 00:12:19,330
some rules the first one you might come

00:12:16,300 --> 00:12:21,640
up with is yeah what are our rules

00:12:19,330 --> 00:12:23,320
if everyone just has read access to

00:12:21,640 --> 00:12:24,400
everything we should probably let

00:12:23,320 --> 00:12:26,320
everyone have it because you're not

00:12:24,400 --> 00:12:28,440
touching anything you know everyone can

00:12:26,320 --> 00:12:31,420
look and that's not going to hurt anyone

00:12:28,440 --> 00:12:33,850
but if someone has readwrite access to

00:12:31,420 --> 00:12:36,280
these it should be the only one because

00:12:33,850 --> 00:12:37,570
otherwise all the other places are going

00:12:36,280 --> 00:12:39,520
to be confused because they thought that

00:12:37,570 --> 00:12:41,230
they had a read-only handle to something

00:12:39,520 --> 00:12:44,350
now if you're paying attention these

00:12:41,230 --> 00:12:45,940
rules sound really familiar and it turns

00:12:44,350 --> 00:12:50,080
out these are exactly the rules for the

00:12:45,940 --> 00:12:51,850
borrow checker so how can we use the

00:12:50,080 --> 00:12:53,440
borrow checker to enforce these

00:12:51,850 --> 00:12:54,910
ownerships and borrowing of these

00:12:53,440 --> 00:12:56,089
peripherals so we can get the kind of

00:12:54,910 --> 00:12:59,059
really rusty

00:12:56,089 --> 00:13:02,120
a viewer from a library that we want but

00:12:59,059 --> 00:13:03,470
it also works on real hardware well the

00:13:02,120 --> 00:13:05,180
important part with the bio checker is

00:13:03,470 --> 00:13:07,100
it has to track this ownership and

00:13:05,180 --> 00:13:08,839
moving around so we can't just conjure

00:13:07,100 --> 00:13:11,600
these out of nowhere we have to have the

00:13:08,839 --> 00:13:12,980
one serial port that we're tracking it

00:13:11,600 --> 00:13:16,069
as it's moving around and we give away

00:13:12,980 --> 00:13:18,769
references to it and things like that so

00:13:16,069 --> 00:13:20,509
this pattern in CS is not new to rust

00:13:18,769 --> 00:13:23,660
they're called Singleton's it means that

00:13:20,509 --> 00:13:25,490
you can only instantiate a class once so

00:13:23,660 --> 00:13:27,259
there there can be only one I couldn't

00:13:25,490 --> 00:13:28,819
find a good Highlander gift to put here

00:13:27,259 --> 00:13:30,410
so if anyone wants to send me a good

00:13:28,819 --> 00:13:33,860
Highlander gift and I'll add it to this

00:13:30,410 --> 00:13:36,589
presentation so you might say ok I need

00:13:33,860 --> 00:13:38,720
one so great I'll make it a I'll make it

00:13:36,589 --> 00:13:40,160
a global mutable variable so that way

00:13:38,720 --> 00:13:42,259
there's only one wall these just be

00:13:40,160 --> 00:13:44,209
talking about this one and it kind of

00:13:42,259 --> 00:13:45,499
works but the problem is in rust when

00:13:44,209 --> 00:13:47,300
you have a mutable global variable

00:13:45,499 --> 00:13:49,100
everything you do with it has to be

00:13:47,300 --> 00:13:52,309
unsafe so it's never going to be very

00:13:49,100 --> 00:13:53,839
convenient to use and the problem is

00:13:52,309 --> 00:13:56,240
this actually doesn't help us get to the

00:13:53,839 --> 00:13:58,459
borrowed checker because this giant

00:13:56,240 --> 00:14:00,620
global mutable variable is accessible

00:13:58,459 --> 00:14:02,360
everywhere and we're not tracking it

00:14:00,620 --> 00:14:05,809
moving around different places it just

00:14:02,360 --> 00:14:08,720
is so this would work but this isn't

00:14:05,809 --> 00:14:10,639
really what we want to be doing instead

00:14:08,720 --> 00:14:12,199
we could write something like this we

00:14:10,639 --> 00:14:14,540
could write a struct called peripherals

00:14:12,199 --> 00:14:16,279
which has our serial port as an option

00:14:14,540 --> 00:14:18,620
inside of it and it has a function

00:14:16,279 --> 00:14:21,740
called take serial where the first time

00:14:18,620 --> 00:14:22,879
you go to it it unwraps an option and it

00:14:21,740 --> 00:14:24,829
gives you back the thing that was in

00:14:22,879 --> 00:14:27,019
that option and then it replaces that

00:14:24,829 --> 00:14:29,179
slot with a nun which means the next

00:14:27,019 --> 00:14:31,850
time that you call it it's gonna panic

00:14:29,179 --> 00:14:34,249
because you're unwrapping a nun so this

00:14:31,850 --> 00:14:38,240
allows us to take what you need but only

00:14:34,249 --> 00:14:39,800
once and this comes with a little bit of

00:14:38,240 --> 00:14:42,259
runtime overhead you have to have an

00:14:39,800 --> 00:14:44,509
option type you have to actually take it

00:14:42,259 --> 00:14:45,889
out of the field and give it away but

00:14:44,509 --> 00:14:47,389
this is only a little bit of memory and

00:14:45,889 --> 00:14:49,839
a little bit of CPU and you do it all

00:14:47,389 --> 00:14:53,749
upfront at the front of your program and

00:14:49,839 --> 00:14:55,850
it unlocks this huge ability to use the

00:14:53,749 --> 00:14:57,679
borrow checker to move stuff around and

00:14:55,850 --> 00:14:59,209
verify that you are moving it around and

00:14:57,679 --> 00:15:01,550
lending it out the way that it's

00:14:59,209 --> 00:15:04,160
supposed to be moved around and lent out

00:15:01,550 --> 00:15:05,959
so this is a small runtime overhead with

00:15:04,160 --> 00:15:09,170
a huge impact for what we want to be

00:15:05,959 --> 00:15:10,339
doing and I wrote my own but this is

00:15:09,170 --> 00:15:12,050
rust you don't have to rewrite

00:15:10,339 --> 00:15:14,029
that someone else has written in the

00:15:12,050 --> 00:15:16,249
cortex-m crate there's a singleton macro

00:15:14,029 --> 00:15:18,499
that does this for you and I've used

00:15:16,249 --> 00:15:20,029
RTFM which is kind of like a really

00:15:18,499 --> 00:15:21,889
lightweight operating system for these

00:15:20,029 --> 00:15:23,720
embedded devices it actually even

00:15:21,889 --> 00:15:24,470
handles it all for you in macro so you

00:15:23,720 --> 00:15:26,449
don't even have to think about

00:15:24,470 --> 00:15:28,129
unwrapping it or taking it just on the

00:15:26,449 --> 00:15:29,899
initialization it goes here are all of

00:15:28,129 --> 00:15:32,720
the peripherals and now you have all of

00:15:29,899 --> 00:15:35,660
them and do with what do with them what

00:15:32,720 --> 00:15:37,430
you want so again you don't have to

00:15:35,660 --> 00:15:38,930
rewrite this from scratch there's

00:15:37,430 --> 00:15:40,850
there's stuff out there but I wanted to

00:15:38,930 --> 00:15:44,180
show you kind of how it worked under the

00:15:40,850 --> 00:15:46,069
hood excuse me but why so now we have

00:15:44,180 --> 00:15:48,649
Singleton's and they're related to

00:15:46,069 --> 00:15:50,870
peripherals and we have this but ok wait

00:15:48,649 --> 00:15:53,600
why is this useful again how does a

00:15:50,870 --> 00:15:55,879
singleton make a difference well it

00:15:53,600 --> 00:15:59,569
turns out that the most important part

00:15:55,879 --> 00:16:01,759
is that reference to self because when

00:15:59,569 --> 00:16:04,850
you have these structures and you're

00:16:01,759 --> 00:16:06,769
required to have a reference to self to

00:16:04,850 --> 00:16:09,470
use this structure and there's only one

00:16:06,769 --> 00:16:11,959
place that you can get this structure it

00:16:09,470 --> 00:16:15,709
forces you to pass this ownership and

00:16:11,959 --> 00:16:17,329
borrowing around so you have to take the

00:16:15,709 --> 00:16:19,069
serial and before you can ever even

00:16:17,329 --> 00:16:20,899
think about reading the speed of that

00:16:19,069 --> 00:16:22,939
peripheral you had to have gotten it

00:16:20,899 --> 00:16:24,769
from somewhere and if rust is able to

00:16:22,939 --> 00:16:27,949
help you track where it's going and

00:16:24,769 --> 00:16:29,629
where it's coming from now you can't do

00:16:27,949 --> 00:16:33,040
it unless you've made the borrow checker

00:16:29,629 --> 00:16:36,709
happy which is really cool

00:16:33,040 --> 00:16:38,389
so it also gives you the ability to to

00:16:36,709 --> 00:16:40,220
understand the software you write a

00:16:38,389 --> 00:16:42,679
little bit better if you have a function

00:16:40,220 --> 00:16:45,649
of their called setup SPI port and it

00:16:42,679 --> 00:16:47,870
takes a mutable reference to an SPI port

00:16:45,649 --> 00:16:50,179
which is a serial port and a GPIO pin

00:16:47,870 --> 00:16:51,620
and if it's mutable reference you're

00:16:50,179 --> 00:16:53,389
like ok this can probably change my

00:16:51,620 --> 00:16:55,279
hardware this is this could if it wanted

00:16:53,389 --> 00:16:57,319
to change some stuff out from underneath

00:16:55,279 --> 00:16:58,819
me but the second one that just reads a

00:16:57,319 --> 00:17:00,980
button that only takes an immutable

00:16:58,819 --> 00:17:02,540
reference you go ok well this probably

00:17:00,980 --> 00:17:04,880
isn't going to change anything so this

00:17:02,540 --> 00:17:06,740
is again getting you thinking in

00:17:04,880 --> 00:17:09,049
embedded systems the same way that you

00:17:06,740 --> 00:17:11,600
work in application development in rust

00:17:09,049 --> 00:17:13,370
this struct starts acting like a normal

00:17:11,600 --> 00:17:14,929
struct even though under the hood it's

00:17:13,370 --> 00:17:19,159
this really cool Hardware mapped

00:17:14,929 --> 00:17:20,659
peripheral this allows us to enforce

00:17:19,159 --> 00:17:24,110
weather code should or shouldn't make

00:17:20,659 --> 00:17:26,059
changes to Hardware entirely at compile

00:17:24,110 --> 00:17:27,770
time there is no runtime checking in

00:17:26,059 --> 00:17:30,710
this the compiler is making sure this

00:17:27,770 --> 00:17:32,360
for you not your runtime so there's a

00:17:30,710 --> 00:17:34,250
little asterisks there the little

00:17:32,360 --> 00:17:35,600
Asterix is this only works across one

00:17:34,250 --> 00:17:37,280
application because Russ only has a

00:17:35,600 --> 00:17:39,260
concept of tracking these borrows and

00:17:37,280 --> 00:17:41,090
ownerships with one application

00:17:39,260 --> 00:17:43,340
but for these microcontroller systems

00:17:41,090 --> 00:17:45,530
there is no OS running multiple

00:17:43,340 --> 00:17:46,850
applications there is the application

00:17:45,530 --> 00:17:49,280
that you are running on your

00:17:46,850 --> 00:17:52,910
microcontroller so this is a problem but

00:17:49,280 --> 00:17:54,500
not for us before you worry all that

00:17:52,910 --> 00:17:56,570
stuff about writing registers and stuff

00:17:54,500 --> 00:17:58,100
like that that looked like a lot of code

00:17:56,570 --> 00:17:59,750
especially when you have to do every

00:17:58,100 --> 00:18:01,610
feature the microcontroller but don't

00:17:59,750 --> 00:18:02,299
worry this is Russ and it's 2018 there's

00:18:01,610 --> 00:18:06,020
a tool for that

00:18:02,299 --> 00:18:07,070
it's called SVD to rust and it takes XML

00:18:06,020 --> 00:18:09,260
files that are provided by the

00:18:07,070 --> 00:18:11,840
manufacturer that have every register

00:18:09,260 --> 00:18:13,970
every value everything like that and it

00:18:11,840 --> 00:18:15,919
vomits out tens or hundreds of thousands

00:18:13,970 --> 00:18:18,760
of lines of usable rust code with

00:18:15,919 --> 00:18:21,650
comments with modules nicely laid out

00:18:18,760 --> 00:18:25,910
it's kind of like bind gen but for

00:18:21,650 --> 00:18:27,830
hardware so now that peripherals are

00:18:25,910 --> 00:18:29,720
structs what else can we do with rust

00:18:27,830 --> 00:18:33,890
we've we've figured out a way to map

00:18:29,720 --> 00:18:35,030
these what but what can we do well we've

00:18:33,890 --> 00:18:37,490
got the type system we haven't touched

00:18:35,030 --> 00:18:41,419
on that yet we can put these strong

00:18:37,490 --> 00:18:44,660
types to work so scaling back a little

00:18:41,419 --> 00:18:46,040
bit microcontrollers the smallest most

00:18:44,660 --> 00:18:48,169
simplest thing you can do with them or

00:18:46,040 --> 00:18:50,929
use their GPIO s or general purpose

00:18:48,169 --> 00:18:52,580
input outputs this is like a single pin

00:18:50,929 --> 00:18:55,490
if you've used Arduino it's like digital

00:18:52,580 --> 00:18:58,280
input digital output they really read

00:18:55,490 --> 00:19:02,059
one bit of the world at a time low

00:18:58,280 --> 00:19:03,860
voltage high voltage so if you were

00:19:02,059 --> 00:19:06,049
writing one of these in rust you might

00:19:03,860 --> 00:19:08,270
have a GPIO pin and it starts maybe

00:19:06,049 --> 00:19:11,600
unconfigured and so you also need an

00:19:08,270 --> 00:19:14,240
input GPIO and an output GPIO so I've

00:19:11,600 --> 00:19:16,250
made these Struck's here and when we've

00:19:14,240 --> 00:19:17,870
got our initial GPIO pin it's not

00:19:16,250 --> 00:19:20,450
configured if we want to read a button

00:19:17,870 --> 00:19:22,100
we've got to put it into input mode so

00:19:20,450 --> 00:19:25,309
what we might do with the type system

00:19:22,100 --> 00:19:28,760
here is take a function or give a

00:19:25,309 --> 00:19:31,429
function to GPIO that takes ownership of

00:19:28,760 --> 00:19:34,490
a GPIO pin and the return type is an

00:19:31,429 --> 00:19:36,740
input GPIO type so it consumes the

00:19:34,490 --> 00:19:37,950
original GPIO pin which is an

00:19:36,740 --> 00:19:39,690
unconformity

00:19:37,950 --> 00:19:42,330
configures it the way you want it and

00:19:39,690 --> 00:19:44,610
gives you back something that is an

00:19:42,330 --> 00:19:47,879
input pin so you're kind of making these

00:19:44,610 --> 00:19:50,190
state transitions using the type system

00:19:47,879 --> 00:19:53,850
so let's look like what we could do with

00:19:50,190 --> 00:19:55,350
one of these output GPIO types we might

00:19:53,850 --> 00:19:57,090
want to come up with a driver for an LED

00:19:55,350 --> 00:19:59,220
so the LEDs are the little blinky lights

00:19:57,090 --> 00:20:00,809
on these embedded systems and blinking a

00:19:59,220 --> 00:20:02,970
light for embedded systems is like hello

00:20:00,809 --> 00:20:04,080
world you don't have a screen so how are

00:20:02,970 --> 00:20:07,529
you going to say hello you're gonna

00:20:04,080 --> 00:20:09,659
blink a light so our LED driver we might

00:20:07,529 --> 00:20:12,149
want to be able to create a new instance

00:20:09,659 --> 00:20:13,649
of this LED driver and we say well to

00:20:12,149 --> 00:20:15,629
make an LED driver you have to tell me

00:20:13,649 --> 00:20:18,480
which output pin you're gonna use so it

00:20:15,629 --> 00:20:21,750
needs to consume this output pin and

00:20:18,480 --> 00:20:24,379
give you back an LED pin and then once

00:20:21,750 --> 00:20:27,509
you have this LED pin the LED pin has a

00:20:24,379 --> 00:20:30,029
function called toggle which requires a

00:20:27,509 --> 00:20:32,250
mutable reference to self so if you want

00:20:30,029 --> 00:20:34,620
to toggle an LED you have to go through

00:20:32,250 --> 00:20:37,830
the motions of taking an uninitialized

00:20:34,620 --> 00:20:39,809
GPIO pin turn it into an output and then

00:20:37,830 --> 00:20:42,419
turn that output into specifically an

00:20:39,809 --> 00:20:46,289
LED driver and if you don't go through

00:20:42,419 --> 00:20:47,879
this transition then the types this

00:20:46,289 --> 00:20:50,759
isn't isn't gonna let you do it it goes

00:20:47,879 --> 00:20:52,350
GPIO pin has no toggle method on it what

00:20:50,759 --> 00:20:53,789
am I supposed to do here you need to go

00:20:52,350 --> 00:20:55,470
through and this shouldn't start to

00:20:53,789 --> 00:20:58,110
sound a little familiar if you use the

00:20:55,470 --> 00:20:59,700
Builder pattern in rust before it's

00:20:58,110 --> 00:21:01,620
forcing you to go through these

00:20:59,700 --> 00:21:04,559
transitions to get the structure that

00:21:01,620 --> 00:21:06,440
you want that has the interface that you

00:21:04,559 --> 00:21:08,789
want on it

00:21:06,440 --> 00:21:11,850
this allows you to enforce design

00:21:08,789 --> 00:21:13,950
contracts entirely at compile time again

00:21:11,850 --> 00:21:17,250
with no runtime cost and no room for

00:21:13,950 --> 00:21:19,080
human error all of this exists only at

00:21:17,250 --> 00:21:21,360
compile time you only get access to it

00:21:19,080 --> 00:21:24,509
if you've made the compiler happy now

00:21:21,360 --> 00:21:26,129
what do I mean by no run time cost so

00:21:24,509 --> 00:21:28,320
all of these struck that I've shown you

00:21:26,129 --> 00:21:30,389
the GPIO pin the input pin the output

00:21:28,320 --> 00:21:32,850
pin there's nothing in them there's no

00:21:30,389 --> 00:21:35,779
memory to take up why would we allocate

00:21:32,850 --> 00:21:38,250
space at run time if nothing exists

00:21:35,779 --> 00:21:40,230
these are exactly the same sizes like

00:21:38,250 --> 00:21:42,779
the tuple type if you've ever seen or an

00:21:40,230 --> 00:21:45,210
empty tuple type in rust and what that

00:21:42,779 --> 00:21:47,159
means is that at compile time rust

00:21:45,210 --> 00:21:48,480
treats these like real objects and moves

00:21:47,159 --> 00:21:50,909
them around and make sure you have Baro

00:21:48,480 --> 00:21:52,229
and you can take references to them

00:21:50,909 --> 00:21:53,879
but then it goes but wait a minute we're

00:21:52,229 --> 00:21:56,549
not talking about anything here so at

00:21:53,879 --> 00:21:58,289
compile time this all evaporates off so

00:21:56,549 --> 00:22:01,109
you've done all of this checking at

00:21:58,289 --> 00:22:02,970
compile time and this doesn't even exist

00:22:01,109 --> 00:22:05,369
there's no code that checks this at run

00:22:02,970 --> 00:22:09,059
time it's not even in a no op it just

00:22:05,369 --> 00:22:11,609
doesn't exist in the final binary these

00:22:09,059 --> 00:22:13,679
are all zero size types they act as real

00:22:11,609 --> 00:22:15,539
time real types at compile time but they

00:22:13,679 --> 00:22:17,190
don't exist in the binary they don't

00:22:15,539 --> 00:22:19,139
take up your RAM they don't take up your

00:22:17,190 --> 00:22:21,599
CPU time they don't take up your space

00:22:19,139 --> 00:22:23,460
they take up your compilers RAM and CPU

00:22:21,599 --> 00:22:24,720
time but not your microcontrollers and

00:22:23,460 --> 00:22:27,090
that's nice because we might have like

00:22:24,720 --> 00:22:29,489
an eight-core build machine building

00:22:27,090 --> 00:22:31,169
this binary and a single core 16

00:22:29,489 --> 00:22:32,639
megahertz processor running that so we

00:22:31,169 --> 00:22:36,809
want to offload all the hard stuff to

00:22:32,639 --> 00:22:40,970
the big powerful machine can we do more

00:22:36,809 --> 00:22:43,320
with types yeah we can do more types so

00:22:40,970 --> 00:22:44,729
what if our output GPIO has multiple

00:22:43,320 --> 00:22:46,349
modes and it does because these

00:22:44,729 --> 00:22:47,909
microcontrollers have a million

00:22:46,349 --> 00:22:48,960
different specialized features because

00:22:47,909 --> 00:22:50,309
they want you to be able to interact

00:22:48,960 --> 00:22:52,649
with all the stuff in the real world

00:22:50,309 --> 00:22:55,379
that you really want so we might have

00:22:52,649 --> 00:22:56,369
this output GPIO might have push-pull

00:22:55,379 --> 00:22:58,619
mode which is kind of like a

00:22:56,369 --> 00:23:00,299
general-purpose turnin LED on do

00:22:58,619 --> 00:23:02,070
something a little bit here and there or

00:23:00,299 --> 00:23:03,840
it might have an open drain mode which

00:23:02,070 --> 00:23:06,109
is really good for like driving a motor

00:23:03,840 --> 00:23:07,679
or an LED that requires a lot of power

00:23:06,109 --> 00:23:10,139
and they might have different

00:23:07,679 --> 00:23:11,279
characteristics so we could make our

00:23:10,139 --> 00:23:14,279
output GPIO

00:23:11,279 --> 00:23:15,960
generic over these different kinds so

00:23:14,279 --> 00:23:17,669
maybe by default when you just create

00:23:15,960 --> 00:23:19,739
one of these the hardware is by default

00:23:17,669 --> 00:23:22,769
and open drain so when we have our

00:23:19,739 --> 00:23:25,529
default you'll get back an output GPIO

00:23:22,769 --> 00:23:26,729
that's in open drain mode and again the

00:23:25,529 --> 00:23:28,440
same way that we did those state

00:23:26,729 --> 00:23:31,109
transitions before we can do the same

00:23:28,440 --> 00:23:32,609
thing with generic types so you can turn

00:23:31,109 --> 00:23:34,979
it into a push-pull and you'll get back

00:23:32,609 --> 00:23:37,080
a flavor of that structure like that

00:23:34,979 --> 00:23:39,359
using generics or you could put it into

00:23:37,080 --> 00:23:41,700
an opening drain again and it will give

00:23:39,359 --> 00:23:45,029
you back a flavor of this now the cool

00:23:41,700 --> 00:23:47,639
part here is if push pull and open drain

00:23:45,029 --> 00:23:49,619
are zero size types and we put a zero

00:23:47,639 --> 00:23:51,830
size type inside of another zero size

00:23:49,619 --> 00:23:53,489
type how big do you think that type is

00:23:51,830 --> 00:23:56,039
it's still zero

00:23:53,489 --> 00:23:57,720
you can go infinitely deep and have as

00:23:56,039 --> 00:24:00,419
many of these abstractions as you want

00:23:57,720 --> 00:24:02,249
and if they're all zero size type you

00:24:00,419 --> 00:24:03,930
could go 30 layers deep and it still

00:24:02,249 --> 00:24:08,430
evaporates away at

00:24:03,930 --> 00:24:10,860
time so you could have a driver that's

00:24:08,430 --> 00:24:12,930
specified to only work with this so you

00:24:10,860 --> 00:24:16,140
can even though it's a generic you say I

00:24:12,930 --> 00:24:18,210
only take the opened rain flavor of this

00:24:16,140 --> 00:24:19,590
or if you have something that's kind of

00:24:18,210 --> 00:24:21,420
a little more general purpose you could

00:24:19,590 --> 00:24:23,490
say I don't even care what kind of mode

00:24:21,420 --> 00:24:25,050
as long as it's now put pin I can work

00:24:23,490 --> 00:24:27,570
with that so you could either have one

00:24:25,050 --> 00:24:28,920
that's very specifically tied to some

00:24:27,570 --> 00:24:31,110
flavor or you could have one that just

00:24:28,920 --> 00:24:32,550
says it all works the same anyway set it

00:24:31,110 --> 00:24:35,780
up however you want and then just give

00:24:32,550 --> 00:24:38,160
me give it to me and I'll work with it

00:24:35,780 --> 00:24:40,590
so that was the borrowed checker in the

00:24:38,160 --> 00:24:43,470
type system what about the trade system

00:24:40,590 --> 00:24:44,520
Russ gives us that - well this is really

00:24:43,470 --> 00:24:47,940
useful when you're building something

00:24:44,520 --> 00:24:50,100
bigger if you are like 10 writing 10

00:24:47,940 --> 00:24:51,600
lines of code to blink an LED yeah you

00:24:50,100 --> 00:24:54,720
probably don't need anything like this

00:24:51,600 --> 00:24:56,870
but if you are building code that's

00:24:54,720 --> 00:24:59,910
meant to be reused in many many places

00:24:56,870 --> 00:25:02,220
or drivers that work for multiple kinds

00:24:59,910 --> 00:25:05,100
of chips you need a way to abstract over

00:25:02,220 --> 00:25:07,140
that so I'll get into what each of these

00:25:05,100 --> 00:25:09,000
different parts are but the ecosystem in

00:25:07,140 --> 00:25:10,260
rust looking like that is looking a

00:25:09,000 --> 00:25:12,390
little something like this that blue

00:25:10,260 --> 00:25:14,340
over there is a this blue board and

00:25:12,390 --> 00:25:15,840
you've got the actual hardware you've

00:25:14,340 --> 00:25:18,150
got your low-level peripheral drivers

00:25:15,840 --> 00:25:20,040
like your NRF 52 crate and you've got

00:25:18,150 --> 00:25:22,050
your higher like human readable

00:25:20,040 --> 00:25:23,820
interface that says like I want to send

00:25:22,050 --> 00:25:25,410
eight over a serial port not like shove

00:25:23,820 --> 00:25:27,870
this data at this register I just want

00:25:25,410 --> 00:25:29,160
to send bytes but while you're writing

00:25:27,870 --> 00:25:31,710
that you could say well there's these

00:25:29,160 --> 00:25:33,570
traits called embedded Hal that are a

00:25:31,710 --> 00:25:36,300
generic way of looking at a serial port

00:25:33,570 --> 00:25:38,070
it might look something like this like

00:25:36,300 --> 00:25:39,990
an output pin what can you do with an

00:25:38,070 --> 00:25:41,640
output pin you can you can set it low

00:25:39,990 --> 00:25:43,620
and you can set it high that's all I can

00:25:41,640 --> 00:25:45,810
do so this is kind of the interface or

00:25:43,620 --> 00:25:47,190
the trait that goes with that so this is

00:25:45,810 --> 00:25:49,140
kind of really generic and this doesn't

00:25:47,190 --> 00:25:52,380
have anything to do with an NRF 52 this

00:25:49,140 --> 00:25:53,430
is just how the hardware works so when

00:25:52,380 --> 00:25:54,870
you're writing your crate you're like

00:25:53,430 --> 00:25:56,340
well I already wrote a set pin low

00:25:54,870 --> 00:25:58,860
function and I already wrote a set pin

00:25:56,340 --> 00:26:00,690
high so let's just like build these into

00:25:58,860 --> 00:26:02,490
the traits so that if someone else using

00:26:00,690 --> 00:26:05,400
that trait can just use it with my

00:26:02,490 --> 00:26:07,140
hardware and then this is a lot of code

00:26:05,400 --> 00:26:09,000
but this would be something like a

00:26:07,140 --> 00:26:11,490
driver that says hey I've written this

00:26:09,000 --> 00:26:13,590
driver for this sensor but I've written

00:26:11,490 --> 00:26:16,290
it not using any knowledge of hardware

00:26:13,590 --> 00:26:17,260
just these embedded hal traits which

00:26:16,290 --> 00:26:18,610
means any

00:26:17,260 --> 00:26:21,580
hardware that implements these embedded

00:26:18,610 --> 00:26:24,820
hal traits can just drop this driver in

00:26:21,580 --> 00:26:26,920
there in their package and it just works

00:26:24,820 --> 00:26:28,510
because you've implemented the interface

00:26:26,920 --> 00:26:32,440
and you have a good layer of abstraction

00:26:28,510 --> 00:26:35,320
and this is really cool for us because

00:26:32,440 --> 00:26:37,960
when you have n chips microcontrollers

00:26:35,320 --> 00:26:39,880
or whatever and M sensors and motor

00:26:37,960 --> 00:26:41,410
controllers and all this instead of to

00:26:39,880 --> 00:26:43,090
get all of these combinations instead of

00:26:41,410 --> 00:26:44,860
multiplying these together to get all

00:26:43,090 --> 00:26:46,660
the possible combinations that are ever

00:26:44,860 --> 00:26:48,220
so slightly different and never work the

00:26:46,660 --> 00:26:50,380
way that you want them to instead it's

00:26:48,220 --> 00:26:52,090
just n plus M which means you have to

00:26:50,380 --> 00:26:55,270
implement your chips and you have to

00:26:52,090 --> 00:26:57,400
implement your drivers but the longer we

00:26:55,270 --> 00:26:59,710
go the bigger this difference ends up

00:26:57,400 --> 00:27:04,260
being and this makes things actually

00:26:59,710 --> 00:27:04,260
reasonable to do at scale so

00:27:05,070 --> 00:27:08,740
unfortunately all good things must end

00:27:07,210 --> 00:27:10,510
so I wanted to recap what we've gone

00:27:08,740 --> 00:27:13,360
over today to kind of like solidify the

00:27:10,510 --> 00:27:15,640
concepts in your head so we talked about

00:27:13,360 --> 00:27:17,170
how ownership and borrowing can help us

00:27:15,640 --> 00:27:18,940
as embedded developers we can treat

00:27:17,170 --> 00:27:21,130
hardware resources the same way you

00:27:18,940 --> 00:27:23,440
treat any other data type in rust and

00:27:21,130 --> 00:27:25,390
let the compiler manage who has access

00:27:23,440 --> 00:27:28,810
to what and what they should be able to

00:27:25,390 --> 00:27:31,150
do with it we use the type system to

00:27:28,810 --> 00:27:33,160
enforce state transitions preconditions

00:27:31,150 --> 00:27:34,450
and postconditions this means we know

00:27:33,160 --> 00:27:36,580
that if we've gotten one of these

00:27:34,450 --> 00:27:38,860
strokes it's set up the way it's

00:27:36,580 --> 00:27:40,330
supposed to be and when we leave it gets

00:27:38,860 --> 00:27:43,090
torn down the way it's supposed to be

00:27:40,330 --> 00:27:44,410
this is a concept called functional

00:27:43,090 --> 00:27:46,030
safety and embedded systems if

00:27:44,410 --> 00:27:49,030
everyone's worked in the safety critical

00:27:46,030 --> 00:27:50,890
field you can stop trying to keep all of

00:27:49,030 --> 00:27:52,990
that in your head or in the comments or

00:27:50,890 --> 00:27:54,730
like remembering a day to day if a

00:27:52,990 --> 00:27:55,990
computer can check it let the computer

00:27:54,730 --> 00:27:57,880
check it they're way better at checking

00:27:55,990 --> 00:27:59,590
normal stuff than or add like stuff

00:27:57,880 --> 00:28:01,000
that's done over and over and over then

00:27:59,590 --> 00:28:04,150
then humans are because everyone has a

00:28:01,000 --> 00:28:06,280
bad day as a developer and the trade

00:28:04,150 --> 00:28:08,500
system lets us enable code reuse for

00:28:06,280 --> 00:28:10,570
your embedded projects no more copy and

00:28:08,500 --> 00:28:12,250
pasting from like the Adafruit library

00:28:10,570 --> 00:28:14,260
for this and then tweaking it to work

00:28:12,250 --> 00:28:16,180
with my controller and I forgot to

00:28:14,260 --> 00:28:18,430
change a variable name and now all of a

00:28:16,180 --> 00:28:20,140
sudden it doesn't work at all you can

00:28:18,430 --> 00:28:24,610
just write things for interfaces that

00:28:20,140 --> 00:28:26,860
really work and for me I'm a big fan of

00:28:24,610 --> 00:28:28,659
Rost cargo in the community so anything

00:28:26,860 --> 00:28:30,609
I can do to stay

00:28:28,659 --> 00:28:32,679
in this field while taking advantage of

00:28:30,609 --> 00:28:34,929
modern language features enumerated

00:28:32,679 --> 00:28:37,809
types match statements all of that still

00:28:34,929 --> 00:28:40,090
exists in no standard so why lose access

00:28:37,809 --> 00:28:41,349
to it and package management which is

00:28:40,090 --> 00:28:43,599
not really a thing in embedded systems

00:28:41,349 --> 00:28:45,639
except for a couple little little cases

00:28:43,599 --> 00:28:49,659
and a group of people who are willing to

00:28:45,639 --> 00:28:51,549
work with you to solve problems and a

00:28:49,659 --> 00:28:53,559
reminder all the stuff I showed you

00:28:51,549 --> 00:28:55,389
today is optional you can go and write a

00:28:53,559 --> 00:28:56,799
giant unsafe block and if all you're

00:28:55,389 --> 00:28:58,629
doing is writing ten lines of blinking

00:28:56,799 --> 00:29:00,159
LED that's probably the fastest way and

00:28:58,629 --> 00:29:02,169
if it all fits on your screen you can

00:29:00,159 --> 00:29:03,879
verify all that stuff in your head but

00:29:02,169 --> 00:29:05,529
as these projects scale or you're

00:29:03,879 --> 00:29:07,299
writing reusable libraries that are

00:29:05,529 --> 00:29:09,549
meant to be used by very many people who

00:29:07,299 --> 00:29:10,840
are not familiar with that hardware you

00:29:09,549 --> 00:29:12,460
should give them all the tools you

00:29:10,840 --> 00:29:14,019
possibly can to make sure that they get

00:29:12,460 --> 00:29:17,169
things right the first time

00:29:14,019 --> 00:29:21,159
and they don't have to figure things out

00:29:17,169 --> 00:29:24,039
the hard way so thank you very much I

00:29:21,159 --> 00:29:25,869
hope you for those of you who are

00:29:24,039 --> 00:29:27,489
embedded systems developers I hope

00:29:25,869 --> 00:29:29,049
you're really excited to write Ross now

00:29:27,489 --> 00:29:30,999
and for those of you who have never

00:29:29,049 --> 00:29:33,639
worked with embedded systems I hope this

00:29:30,999 --> 00:29:35,379
is feeling way more accessible and

00:29:33,639 --> 00:29:39,009
hopefully all of you can get started so

00:29:35,379 --> 00:29:40,539
thank you all for listening I have a

00:29:39,009 --> 00:29:41,710
couple plugs before I don't have my

00:29:40,539 --> 00:29:43,869
timer because I don't have things so

00:29:41,710 --> 00:29:45,909
I'll go really quickly I'm a part of the

00:29:43,869 --> 00:29:47,559
embedded working group we're a part of

00:29:45,909 --> 00:29:49,539
the RUS team and we're Matt doesn't

00:29:47,559 --> 00:29:51,129
quite fit but part of the embedded

00:29:49,539 --> 00:29:53,109
working group we're trying to make

00:29:51,129 --> 00:29:55,450
things as usable and scalable as

00:29:53,109 --> 00:29:56,739
possible for embedded systems so come

00:29:55,450 --> 00:29:58,419
check us out on github that's our

00:29:56,739 --> 00:30:00,879
coordination repository we would love to

00:29:58,419 --> 00:30:04,570
have your help and we're expanding now

00:30:00,879 --> 00:30:05,679
so now's a great time to join I also am

00:30:04,570 --> 00:30:07,570
founding a company with some of the

00:30:05,679 --> 00:30:09,759
other people in the rust community

00:30:07,570 --> 00:30:12,009
including Caterina who's speaking later

00:30:09,759 --> 00:30:14,320
today and we're focusing on low-level

00:30:12,009 --> 00:30:15,999
and embedded problems in Ross so if

00:30:14,320 --> 00:30:17,590
you're a company that has the level and

00:30:15,999 --> 00:30:19,179
embedded problems or systems level

00:30:17,590 --> 00:30:21,999
problems and Ross come talk to us we

00:30:19,179 --> 00:30:22,570
would love to chat with you so thank you

00:30:21,999 --> 00:30:23,799
very much

00:30:22,570 --> 00:30:25,150
I'm James Monza this is getting

00:30:23,799 --> 00:30:35,170
something for nothing

00:30:25,150 --> 00:30:35,170
[Applause]

00:30:35,850 --> 00:30:39,470
[Music]

00:30:38,110 --> 00:30:44,440
you

00:30:39,470 --> 00:30:44,440

YouTube URL: https://www.youtube.com/watch?v=t99L3JHhLc0


