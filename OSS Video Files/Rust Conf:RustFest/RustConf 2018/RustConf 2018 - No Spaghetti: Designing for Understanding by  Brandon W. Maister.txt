Title: RustConf 2018 - No Spaghetti: Designing for Understanding by  Brandon W. Maister
Publication date: 2018-09-06
Playlist: RustConf 2018
Description: 
	RustConf 2018 - The Opposite of Spaghetti Code: Building for Understanding by  Brandon W. Maister

Every moderately sized project is both a library and a consumer. Rust has an almost dizzying array of features that can be used to add structure and hide information.

In this talk we'll discuss using types, traits, modules and crates as the tools of encapsulation. To show how they work together to effectively superseed similar information-hiding tools in procedural and OO languages we'll grow a simple type into a collection of language objects. We'll discuss the thought processes that go into deciding to add a layer of abstraction, and how to use each layer to maximum effect.
Captions: 
	00:00:00,410 --> 00:00:18,930
[Music]

00:00:15,450 --> 00:00:20,880
yeah like Steve said I'm Brandon I am

00:00:18,930 --> 00:00:23,100
going to talk about translating

00:00:20,880 --> 00:00:26,520
everything that the software industry

00:00:23,100 --> 00:00:29,160
has learned over the last 80 years into

00:00:26,520 --> 00:00:33,809
rust so this is sort of design and

00:00:29,160 --> 00:00:34,680
architecture and rust we're all very

00:00:33,809 --> 00:00:36,840
professional people

00:00:34,680 --> 00:00:43,410
I assume none of us liked writing

00:00:36,840 --> 00:00:45,750
spaghetti code so so this is good so

00:00:43,410 --> 00:00:50,670
yeah I wrote a demo and I called it

00:00:45,750 --> 00:00:54,420
lasagna lasagna is I think a really good

00:00:50,670 --> 00:00:55,409
metaphor for good code when you think

00:00:54,420 --> 00:00:57,210
about the kinds of things we try to

00:00:55,409 --> 00:00:59,430
avoid in spaghetti code we don't like

00:00:57,210 --> 00:01:02,400
untraceable paths we don't like a lack

00:00:59,430 --> 00:01:04,470
of separation we don't like like the

00:01:02,400 --> 00:01:05,790
core architecture getting just smushed

00:01:04,470 --> 00:01:10,490
up with everything

00:01:05,790 --> 00:01:13,650
contrariwise lasagna is awesome it has

00:01:10,490 --> 00:01:16,380
layers that are big and flat and easy to

00:01:13,650 --> 00:01:19,560
see there are tools in place ie lasagna

00:01:16,380 --> 00:01:20,700
pasta to keep the layer separate and the

00:01:19,560 --> 00:01:23,990
layers still end up interacting

00:01:20,700 --> 00:01:26,580
otherwise it would be just boring food

00:01:23,990 --> 00:01:29,160
interestingly as I was writing this talk

00:01:26,580 --> 00:01:31,200
this slide in particular I discovered

00:01:29,160 --> 00:01:34,260
that lasagna code is a term of art which

00:01:31,200 --> 00:01:35,490
means code that is so poorly separated

00:01:34,260 --> 00:01:38,640
and it's layers that you can't change

00:01:35,490 --> 00:01:41,460
any anything without changing everything

00:01:38,640 --> 00:01:43,020
but by that point I had integrated the

00:01:41,460 --> 00:01:47,850
metaphor into my talk so thoroughly that

00:01:43,020 --> 00:01:53,190
I couldn't change it so what am I gonna

00:01:47,850 --> 00:01:56,250
talk about I'm gonna talk about leaning

00:01:53,190 --> 00:02:00,450
into strictness how the fact that rust

00:01:56,250 --> 00:02:02,100
is difficult everybody knows but having

00:02:00,450 --> 00:02:04,050
to think about our api's actually gives

00:02:02,100 --> 00:02:07,590
us the ability to really clarify our

00:02:04,050 --> 00:02:10,800
thought I'm going to talk about using

00:02:07,590 --> 00:02:13,530
modules and privacy to keep our code

00:02:10,800 --> 00:02:16,500
simple and to keep our API simple I'm

00:02:13,530 --> 00:02:18,269
going to talk about using encapsulation

00:02:16,500 --> 00:02:20,129
ergonomics and that's separate to

00:02:18,269 --> 00:02:24,140
modules and privacy I'm going to talk

00:02:20,129 --> 00:02:27,960
about abstraction and dynamism because

00:02:24,140 --> 00:02:30,420
abstraction is the last rung of the like

00:02:27,960 --> 00:02:34,860
totem pole ik you're very senior when

00:02:30,420 --> 00:02:36,840
you're being very abstract yeah that's

00:02:34,860 --> 00:02:39,600
what it is to start I'm going to

00:02:36,840 --> 00:02:42,930
introduce you to my dominant metaphor it

00:02:39,600 --> 00:02:44,430
is an onion just like this talk we can't

00:02:42,930 --> 00:02:48,990
actually you don't you don't know what's

00:02:44,430 --> 00:02:51,180
in the onion yet here's the code I'm

00:02:48,990 --> 00:02:54,030
starting with a lot of code when you

00:02:51,180 --> 00:02:56,250
were when you Oh actually a very

00:02:54,030 --> 00:02:57,390
important part of this is that my fool

00:02:56,250 --> 00:02:59,010
eye metaphor in addition to being an

00:02:57,390 --> 00:03:02,250
onion is a cache

00:02:59,010 --> 00:03:03,510
I love caches they are super simple to

00:03:02,250 --> 00:03:06,390
start with every time you start

00:03:03,510 --> 00:03:10,290
implementing a cache you realize that

00:03:06,390 --> 00:03:11,850
you have contrasting requirements you

00:03:10,290 --> 00:03:14,460
have people who want to be fast you want

00:03:11,850 --> 00:03:19,560
to have people who want to be like

00:03:14,460 --> 00:03:21,630
correct for some reason and so you

00:03:19,560 --> 00:03:22,890
always like there's a lot of things that

00:03:21,630 --> 00:03:24,840
need to happen but it's a very simple

00:03:22,890 --> 00:03:26,430
metaphor to keep going through with so

00:03:24,840 --> 00:03:27,690
we're gonna implement a cache and what's

00:03:26,430 --> 00:03:30,090
the first thing that you do when you

00:03:27,690 --> 00:03:34,290
implement a cache you just stick stuff

00:03:30,090 --> 00:03:35,670
in a map and that's like in rust this

00:03:34,290 --> 00:03:36,720
looks pretty similar to the way it does

00:03:35,670 --> 00:03:40,130
in every other language you've got a

00:03:36,720 --> 00:03:40,130
bunch of code you stick stuff in a map

00:03:40,550 --> 00:03:45,660
the downside to just doing this is that

00:03:43,800 --> 00:03:47,760
there is absolutely no encapsulation if

00:03:45,660 --> 00:03:49,650
you want to change cache mechanics then

00:03:47,760 --> 00:03:53,580
you are changing the code that is using

00:03:49,650 --> 00:03:55,860
the cache in this case like we want to

00:03:53,580 --> 00:03:57,360
do something if we want to change how

00:03:55,860 --> 00:03:58,830
efficiently we do something we've got to

00:03:57,360 --> 00:04:00,180
modify our cache code if we have a lot

00:03:58,830 --> 00:04:01,590
of different things that uses that

00:04:00,180 --> 00:04:04,590
operate on the same data then we've

00:04:01,590 --> 00:04:07,350
gotta change the code everywhere that's

00:04:04,590 --> 00:04:09,180
rough so we are just like blending our

00:04:07,350 --> 00:04:12,450
business policy throughout our code if

00:04:09,180 --> 00:04:16,470
we do it this way ideally we would avoid

00:04:12,450 --> 00:04:18,959
that even here though we have rust

00:04:16,470 --> 00:04:21,359
guarantees telling us something this the

00:04:18,959 --> 00:04:22,980
ref mute here is saying hey this

00:04:21,359 --> 00:04:27,210
function might be modifying our cache

00:04:22,980 --> 00:04:31,410
it's not just accessing it so even in

00:04:27,210 --> 00:04:32,820
the simplest possible API you should be

00:04:31,410 --> 00:04:36,240
thinking about is this telling me

00:04:32,820 --> 00:04:40,440
something about the way that I mean

00:04:36,240 --> 00:04:42,690
and maybe actually Russ is getting us a

00:04:40,440 --> 00:04:43,950
little bit more defined maybe it's a

00:04:42,690 --> 00:04:45,570
little bit more like this it's not so

00:04:43,950 --> 00:04:47,490
blurry it's a bit blurry it's you know

00:04:45,570 --> 00:04:51,600
you know our business policy it has a

00:04:47,490 --> 00:04:53,820
clear boundary but how do we take it to

00:04:51,600 --> 00:05:00,240
the next level this is lasagna inside of

00:04:53,820 --> 00:05:04,650
a tray we use functions right separate

00:05:00,240 --> 00:05:07,830
separate functions and this code uses a

00:05:04,650 --> 00:05:10,950
few more features to sort of climb the

00:05:07,830 --> 00:05:14,630
pillars of abstraction everyone knows

00:05:10,950 --> 00:05:17,670
what a module is probably modules are

00:05:14,630 --> 00:05:21,030
rusts smallest unit of privacy they are

00:05:17,670 --> 00:05:23,190
the thing that you use to keep your code

00:05:21,030 --> 00:05:25,380
private in that sense they say the same

00:05:23,190 --> 00:05:28,380
they serve the same purpose as files and

00:05:25,380 --> 00:05:33,360
C classes in Java capitalization and go

00:05:28,380 --> 00:05:34,860
and underscores in Python module is also

00:05:33,360 --> 00:05:36,870
the smallest unit that can be broken out

00:05:34,860 --> 00:05:39,810
into their own file you just extract the

00:05:36,870 --> 00:05:42,240
curly braces into their own file name it

00:05:39,810 --> 00:05:44,550
calf RS and but replace the whole block

00:05:42,240 --> 00:05:46,440
with a semicolon that's awesome

00:05:44,550 --> 00:05:48,060
I often realize that something that I'm

00:05:46,440 --> 00:05:50,130
doing should actually have a stronger

00:05:48,060 --> 00:05:53,310
privacy barrier just start writing

00:05:50,130 --> 00:05:55,110
module in my current file and that makes

00:05:53,310 --> 00:05:57,000
it sort of trivial to copy paste code

00:05:55,110 --> 00:06:01,470
around and revert stuff without without

00:05:57,000 --> 00:06:02,940
it being super complicated pub crate

00:06:01,470 --> 00:06:05,250
means that anything inside of the

00:06:02,940 --> 00:06:10,710
current crate can see this crate public

00:06:05,250 --> 00:06:12,330
item this is a feature that's fairly

00:06:10,710 --> 00:06:15,170
unique to rust there aren't very many

00:06:12,330 --> 00:06:21,420
other languages that provide a like

00:06:15,170 --> 00:06:24,420
compilation unit privacy barrier so

00:06:21,420 --> 00:06:25,950
we've established a module that's the

00:06:24,420 --> 00:06:28,830
bright orange part in the middle it now

00:06:25,950 --> 00:06:30,090
has a boundary that is the privacy it

00:06:28,830 --> 00:06:33,090
has something inside of it and something

00:06:30,090 --> 00:06:36,120
outside of it and the pub crate is the

00:06:33,090 --> 00:06:37,380
tiny little hole inside of it there are

00:06:36,120 --> 00:06:39,750
though problems with the implementation

00:06:37,380 --> 00:06:42,750
that we've got so far

00:06:39,750 --> 00:06:45,700
ownership of the hash map is sort of

00:06:42,750 --> 00:06:51,610
spread throughout this code is

00:06:45,700 --> 00:06:53,080
circular it doesn't the cache itself

00:06:51,610 --> 00:06:56,290
doesn't have full control over its own

00:06:53,080 --> 00:06:58,060
destiny specifically because do

00:06:56,290 --> 00:07:03,400
something knows about the implementation

00:06:58,060 --> 00:07:08,950
details so what can we do or what's

00:07:03,400 --> 00:07:11,650
what's actually still good about this we

00:07:08,950 --> 00:07:16,330
do have a little abstraction boundary in

00:07:11,650 --> 00:07:18,640
the form of generics so I'd know 1977 is

00:07:16,330 --> 00:07:20,680
the earliest time I can find of like

00:07:18,640 --> 00:07:24,370
static polymorphism coming around in a

00:07:20,680 --> 00:07:27,370
de K and V here are just generic

00:07:24,370 --> 00:07:31,200
generics they are similar to but better

00:07:27,370 --> 00:07:33,130
than C++ templates or Java generics

00:07:31,200 --> 00:07:36,280
they're not they're not always better

00:07:33,130 --> 00:07:39,700
than C++ templates depending on what

00:07:36,280 --> 00:07:42,010
you're trying to do the where clause aka

00:07:39,700 --> 00:07:47,010
trace constraint is what distinguishes

00:07:42,010 --> 00:07:49,870
rust generics from C++ templates or Java

00:07:47,010 --> 00:07:55,620
this particular use case here this where

00:07:49,870 --> 00:07:55,620
K equals hash plus X plus clone is a

00:07:56,010 --> 00:08:00,010
demonstration of the composition over

00:07:58,210 --> 00:08:02,650
inheritance philosophy that runs through

00:08:00,010 --> 00:08:05,590
rust instead of being required to create

00:08:02,650 --> 00:08:08,230
a cache into a hash map can insert into

00:08:05,590 --> 00:08:12,100
hash map it or interface like it would

00:08:08,230 --> 00:08:13,960
in Java we just say that things that go

00:08:12,100 --> 00:08:15,550
into hashmaps require hash plus X so you

00:08:13,960 --> 00:08:20,730
can sort of generate your own folks on

00:08:15,550 --> 00:08:24,220
ax me of small composable parts

00:08:20,730 --> 00:08:25,990
additionally traits act as a type level

00:08:24,220 --> 00:08:30,370
privacy barrier the same way that module

00:08:25,990 --> 00:08:32,170
privacy acts as a code level privacy

00:08:30,370 --> 00:08:34,660
barrier types prevent you from knowing

00:08:32,170 --> 00:08:38,229
what's go traits prevent you from

00:08:34,660 --> 00:08:42,690
knowing the actual type that's going

00:08:38,229 --> 00:08:42,690
into your code or being operated upon

00:08:44,730 --> 00:08:48,190
modules give us the ability to hide

00:08:46,750 --> 00:08:50,620
items because they're not important to

00:08:48,190 --> 00:08:53,260
users for example I've got this pretty

00:08:50,620 --> 00:08:56,230
nifty syntax of just using dots instead

00:08:53,260 --> 00:08:59,280
of types that's not legal I just didn't

00:08:56,230 --> 00:08:59,280
fit everything on this slide

00:09:00,910 --> 00:09:04,850
sticking an item inside of a module I'm

00:09:03,500 --> 00:09:06,340
not marking public means that we can

00:09:04,850 --> 00:09:10,160
depend on any invariance being

00:09:06,340 --> 00:09:12,890
guaranteed by a public API that's just

00:09:10,160 --> 00:09:14,840
basic privacy in this case that means

00:09:12,890 --> 00:09:16,400
that get or insert know is in

00:09:14,840 --> 00:09:18,140
significantly more control over its

00:09:16,400 --> 00:09:23,660
destiny that would be if ensure exists

00:09:18,140 --> 00:09:26,620
was public so why would we not just use

00:09:23,660 --> 00:09:28,910
pub for everything

00:09:26,620 --> 00:09:32,000
the only thing that is keeping you from

00:09:28,910 --> 00:09:33,920
making the mistake of interpreting of

00:09:32,000 --> 00:09:35,930
just providing the internal access to

00:09:33,920 --> 00:09:37,460
everything that you do is speed bumps

00:09:35,930 --> 00:09:40,190
that you place for yourself discipline

00:09:37,460 --> 00:09:43,910
is hard and making a conscious decision

00:09:40,190 --> 00:09:46,820
to publicize your internals is very

00:09:43,910 --> 00:09:48,650
important the smaller the holes in your

00:09:46,820 --> 00:09:53,840
API the easier it is to think through

00:09:48,650 --> 00:09:57,470
adding another one additionally modules

00:09:53,840 --> 00:09:59,720
are items too so a module even though it

00:09:57,470 --> 00:10:01,310
is accessible even if a private module

00:09:59,720 --> 00:10:04,940
is accessible from inside module and

00:10:01,310 --> 00:10:07,220
which it is defined but items inside of

00:10:04,940 --> 00:10:09,860
it are not public so here we have

00:10:07,220 --> 00:10:11,960
defined this ensure exists as a public

00:10:09,860 --> 00:10:14,480
item but because it is not Reax ported

00:10:11,960 --> 00:10:16,880
from its internal module it's still

00:10:14,480 --> 00:10:20,560
private to that module so if we hadn't

00:10:16,880 --> 00:10:22,580
marked ensure exists here as public then

00:10:20,560 --> 00:10:25,730
get or insert would not be able to

00:10:22,580 --> 00:10:27,740
access to it but because we've made mod

00:10:25,730 --> 00:10:29,900
internal private we haven't marked it as

00:10:27,740 --> 00:10:33,680
public it's not accessible to the

00:10:29,900 --> 00:10:36,830
outside world if we wanted to mark it

00:10:33,680 --> 00:10:38,839
accessible to the outside world we would

00:10:36,830 --> 00:10:42,050
have to re export it some way this is a

00:10:38,839 --> 00:10:43,610
super common pattern in rust it is I

00:10:42,050 --> 00:10:47,000
believe called the facade pattern or

00:10:43,610 --> 00:10:49,420
just a sodding stuff it makes it easy

00:10:47,000 --> 00:10:51,589
for you to organize your code as

00:10:49,420 --> 00:10:55,190
complicatedly as you would like make

00:10:51,589 --> 00:10:57,620
yourself feel very very very mature and

00:10:55,190 --> 00:11:03,170
still expose a simple and easy to

00:10:57,620 --> 00:11:07,459
understand API so this is what we just

00:11:03,170 --> 00:11:08,300
wrote it's a ton of syntax and important

00:11:07,459 --> 00:11:09,260
the thing that I'm really trying to

00:11:08,300 --> 00:11:10,579
emphasize is that even when you're

00:11:09,260 --> 00:11:12,559
writing the same

00:11:10,579 --> 00:11:15,459
possible thing Russ really wants you to

00:11:12,559 --> 00:11:18,649
be explicit about what it requires

00:11:15,459 --> 00:11:23,329
what's the next step another layer of

00:11:18,649 --> 00:11:25,189
encapsulation in this case we are it's

00:11:23,329 --> 00:11:28,040
very similar code there's a little bit

00:11:25,189 --> 00:11:34,910
new here there's a struct we now have an

00:11:28,040 --> 00:11:37,790
object what else is going on here we are

00:11:34,910 --> 00:11:39,259
implementing stuff on this struct in

00:11:37,790 --> 00:11:42,189
poles are the way that you write you

00:11:39,259 --> 00:11:44,929
access method call syntax they are not

00:11:42,189 --> 00:11:46,220
fundamentally different except methods

00:11:44,929 --> 00:11:48,589
aren't different from functions except

00:11:46,220 --> 00:11:53,509
that they're more creative economic to

00:11:48,589 --> 00:11:55,429
use this is an actual design decision

00:11:53,509 --> 00:11:58,100
though this the internal properties of

00:11:55,429 --> 00:12:00,290
the struct are public that means that

00:11:58,100 --> 00:12:03,110
anyone inside of the inside of your

00:12:00,290 --> 00:12:06,019
crate has I can use this cash in any way

00:12:03,110 --> 00:12:08,420
that they would like up to and including

00:12:06,019 --> 00:12:10,100
initializing it separately or accessing

00:12:08,420 --> 00:12:12,470
its individual its internal items after

00:12:10,100 --> 00:12:14,239
it's been created I would argue that

00:12:12,470 --> 00:12:16,459
this is a completely reasonable choice

00:12:14,239 --> 00:12:21,110
for an internal or otherwise unimportant

00:12:16,459 --> 00:12:25,100
object if you expose the public parts of

00:12:21,110 --> 00:12:26,239
your objects to things that you trust

00:12:25,100 --> 00:12:30,019
that means that there's a whole lot of

00:12:26,239 --> 00:12:31,189
code that you don't need to write and

00:12:30,019 --> 00:12:33,559
that means that you can have a more

00:12:31,189 --> 00:12:37,669
ergonomic API for your users if you can

00:12:33,559 --> 00:12:39,589
trust them any something else that's new

00:12:37,669 --> 00:12:42,709
here is that we've moved the trait

00:12:39,589 --> 00:12:48,739
constraints onto the object itself that

00:12:42,709 --> 00:12:51,589
allows you to move even though it's

00:12:48,739 --> 00:12:53,059
possible for you to add trait

00:12:51,589 --> 00:12:56,749
constraints onto functions inside of an

00:12:53,059 --> 00:12:58,819
poles putting pushing the requirements

00:12:56,749 --> 00:13:00,199
up to the object itself makes it it

00:12:58,819 --> 00:13:02,779
makes for better error messages and it

00:13:00,199 --> 00:13:04,269
means that your objects are just sort of

00:13:02,779 --> 00:13:07,220
more straightforward to use and you can

00:13:04,269 --> 00:13:08,809
describe what is actually important

00:13:07,220 --> 00:13:16,279
about the objects that you're describing

00:13:08,809 --> 00:13:18,110
defining a subtle but awesome part of

00:13:16,279 --> 00:13:20,480
rust simple blocks is that it's actually

00:13:18,110 --> 00:13:23,160
possible to define require different

00:13:20,480 --> 00:13:27,839
constraints on in implementation than on

00:13:23,160 --> 00:13:30,959
the object itself in this case the cash

00:13:27,839 --> 00:13:35,910
that is being implemented requires that

00:13:30,959 --> 00:13:39,860
the case be hash and ech but the

00:13:35,910 --> 00:13:42,569
specific implementation of the cash is

00:13:39,860 --> 00:13:47,189
requires that the objects be cloned so

00:13:42,569 --> 00:13:48,810
I'm just moving it there let's talk

00:13:47,189 --> 00:13:52,800
about the error messages that I just

00:13:48,810 --> 00:13:55,230
described here I'm defining a wrapper

00:13:52,800 --> 00:13:57,420
type that does everything necessary to

00:13:55,230 --> 00:13:59,819
be inserted into a hash map but does not

00:13:57,420 --> 00:14:03,329
implement cache clone which is required

00:13:59,819 --> 00:14:05,730
for the cache to work so if I try to

00:14:03,329 --> 00:14:08,490
insert it I get an error message step

00:14:05,730 --> 00:14:11,509
state trade center clone clone is not

00:14:08,490 --> 00:14:15,240
implemented for wrapper this is

00:14:11,509 --> 00:14:17,009
interesting because like in most other

00:14:15,240 --> 00:14:20,610
languages the error would actually come

00:14:17,009 --> 00:14:22,319
on a lot the instantiation line because

00:14:20,610 --> 00:14:24,329
you would be impossible to construct a

00:14:22,319 --> 00:14:25,910
cache of what you want here the error is

00:14:24,329 --> 00:14:28,110
at actually trying to call a method

00:14:25,910 --> 00:14:32,009
there are lots of times where what you

00:14:28,110 --> 00:14:33,420
want to do where you have either a more

00:14:32,009 --> 00:14:35,430
ergonomic or more efficient

00:14:33,420 --> 00:14:37,709
implementation that you can provide for

00:14:35,430 --> 00:14:40,850
a specific operation but it only holds

00:14:37,709 --> 00:14:43,290
if some specific trait constraints apply

00:14:40,850 --> 00:14:44,790
that's pretty much the only time you

00:14:43,290 --> 00:14:47,490
would want to do this every other time

00:14:44,790 --> 00:14:49,740
if you can move trait constraints up to

00:14:47,490 --> 00:14:51,600
the object the you will end up with a

00:14:49,740 --> 00:14:52,680
sort of more pleasant API because you

00:14:51,600 --> 00:14:56,670
don't want people to be using your

00:14:52,680 --> 00:14:58,439
object for months or years as long as

00:14:56,670 --> 00:15:00,899
rust has been around before they realize

00:14:58,439 --> 00:15:03,800
that they can't actually call the method

00:15:00,899 --> 00:15:06,360
that they expect it to be able to call

00:15:03,800 --> 00:15:09,620
only one more thing that I wanted to

00:15:06,360 --> 00:15:12,360
talk about at this level of abstraction

00:15:09,620 --> 00:15:16,380
even here the module is still the only

00:15:12,360 --> 00:15:19,350
unit of privacy the getter insert is

00:15:16,380 --> 00:15:22,500
implemented on the cache object but the

00:15:19,350 --> 00:15:25,800
it still can refer to other methods and

00:15:22,500 --> 00:15:28,019
internally so this is a like it's a

00:15:25,800 --> 00:15:30,809
simple rule modules or board privacy as

00:15:28,019 --> 00:15:33,439
implementations or never don't affect

00:15:30,809 --> 00:15:33,439
privacy rules

00:15:34,760 --> 00:15:41,250
another point though is that even though

00:15:38,220 --> 00:15:44,160
the hashmap itself is now and working at

00:15:41,250 --> 00:15:45,959
floating around out in Maine we've sort

00:15:44,160 --> 00:15:48,209
of tied this down a little bit there

00:15:45,959 --> 00:15:50,640
it's a little bit less of a loop

00:15:48,209 --> 00:15:51,990
structure there's a little the cash is

00:15:50,640 --> 00:15:55,070
in much more control over its own

00:15:51,990 --> 00:15:59,490
destiny and knows what's going on and

00:15:55,070 --> 00:16:01,500
we've improved things a bit so

00:15:59,490 --> 00:16:03,390
everything so far has had the caveat of

00:16:01,500 --> 00:16:08,730
you have to trust your users which is

00:16:03,390 --> 00:16:10,980
obviously crazy so let's let's add an

00:16:08,730 --> 00:16:13,529
invariant that we need to maintain in

00:16:10,980 --> 00:16:17,940
order for us to sort of demonstrate some

00:16:13,529 --> 00:16:21,149
some more features in this case it's a

00:16:17,940 --> 00:16:24,480
cash statistics obviously in order for

00:16:21,149 --> 00:16:26,430
our cash to be accepted by our CEO the

00:16:24,480 --> 00:16:28,800
hits and misses need to be correct we

00:16:26,430 --> 00:16:32,370
can't trust other developers so we mark

00:16:28,800 --> 00:16:34,620
you don't mark them public that means

00:16:32,370 --> 00:16:37,920
that we know that we are the only people

00:16:34,620 --> 00:16:39,089
who can modify these attributes but it

00:16:37,920 --> 00:16:41,399
also means that we need to implement a

00:16:39,089 --> 00:16:42,540
ton more functionality an example here

00:16:41,399 --> 00:16:50,450
is that before we didn't need to

00:16:42,540 --> 00:16:50,450
implement a new method but now now we do

00:16:51,470 --> 00:16:56,130
so since we've discovered that there was

00:16:53,550 --> 00:16:58,890
one method that we weren't implementing

00:16:56,130 --> 00:17:03,360
before to make sure that we are catching

00:16:58,890 --> 00:17:05,160
every possible method dead-like would

00:17:03,360 --> 00:17:07,860
allow for our cash to be correctly

00:17:05,160 --> 00:17:10,040
usable or like pleasant to use let's say

00:17:07,860 --> 00:17:12,589
let's clean up some of this API

00:17:10,040 --> 00:17:16,319
fundamentally I was talking about how

00:17:12,589 --> 00:17:20,429
cash is like we're tying business logic

00:17:16,319 --> 00:17:23,569
to itself hits and misses don't actually

00:17:20,429 --> 00:17:25,350
have anything to do with cashing we if

00:17:23,569 --> 00:17:28,350
metrics are sort of an orthogonal

00:17:25,350 --> 00:17:30,870
concern we want to change if we want to

00:17:28,350 --> 00:17:31,950
change which metrics we capture or the

00:17:30,870 --> 00:17:33,480
reason that we capture them is going to

00:17:31,950 --> 00:17:35,490
be different to changing the cash

00:17:33,480 --> 00:17:40,350
implementation so let's move the hash

00:17:35,490 --> 00:17:41,940
map out here is a we've just separated

00:17:40,350 --> 00:17:44,690
we're using two separate modules next to

00:17:41,940 --> 00:17:44,690
each other in this case

00:17:47,900 --> 00:17:53,490
okay that gives us a fairly clean

00:17:50,760 --> 00:17:56,130
separation of concerns cash module is

00:17:53,490 --> 00:17:57,900
going to be changing because we're

00:17:56,130 --> 00:17:59,159
changing our cash implementation when

00:17:57,900 --> 00:18:01,260
you're doing code reviews when you're

00:17:59,159 --> 00:18:03,210
handling stuff it it will you're much

00:18:01,260 --> 00:18:04,980
less likely to make a mistake if every

00:18:03,210 --> 00:18:11,070
object is responsible only for its own

00:18:04,980 --> 00:18:14,190
things the this also actually

00:18:11,070 --> 00:18:15,990
demonstrates fame rusts famous

00:18:14,190 --> 00:18:19,559
commitment to like pay for what you need

00:18:15,990 --> 00:18:22,080
and hopefully zero cost abstractions in

00:18:19,559 --> 00:18:23,940
this case because of the zero cost

00:18:22,080 --> 00:18:25,860
abstraction is this hashmap in this

00:18:23,940 --> 00:18:27,809
implementation is likely to be inlined

00:18:25,860 --> 00:18:28,799
and functions are going to be inlined

00:18:27,809 --> 00:18:31,380
and you're not actually going to have

00:18:28,799 --> 00:18:33,510
any kind of runtime cost for splitting

00:18:31,380 --> 00:18:43,010
things out this way unlike in most other

00:18:33,510 --> 00:18:43,010
languages or yeah it is also yeah

00:18:43,049 --> 00:18:46,830
so because we split the logic up into

00:18:45,480 --> 00:18:48,659
their own smaller units we were going to

00:18:46,830 --> 00:18:51,000
have we have like this notion of a core

00:18:48,659 --> 00:18:52,890
caching policy section inside of which

00:18:51,000 --> 00:18:55,080
are we have our own privacy barriers

00:18:52,890 --> 00:18:56,730
this is starting to look a little bit

00:18:55,080 --> 00:18:59,970
more like a shallot than an onion but

00:18:56,730 --> 00:19:01,350
you do it you can we're still

00:18:59,970 --> 00:19:03,780
controlling access we still have these

00:19:01,350 --> 00:19:07,020
small holes in the public API which

00:19:03,780 --> 00:19:08,850
means that we have a clear public API no

00:19:07,020 --> 00:19:14,010
matter how complex the implementation

00:19:08,850 --> 00:19:19,880
gets speaking of public API so what is

00:19:14,010 --> 00:19:21,900
this answer thing that we've imported we

00:19:19,880 --> 00:19:26,130
inside of the cache module we've created

00:19:21,900 --> 00:19:28,140
me insert enum it the name is a little

00:19:26,130 --> 00:19:31,039
bit the fields are a little bit

00:19:28,140 --> 00:19:35,100
suggestive of use where's it being used

00:19:31,039 --> 00:19:40,110
it's in insert if missing so okay so

00:19:35,100 --> 00:19:41,970
that that's you doing it instead of

00:19:40,110 --> 00:19:43,890
missing has been around since basically

00:19:41,970 --> 00:19:47,909
the beginning but all of a sudden now

00:19:43,890 --> 00:19:49,559
it's public and previously it returned

00:19:47,909 --> 00:19:55,200
nothing and now it's returning and set

00:19:49,559 --> 00:19:57,390
insert get or insert though hasn't

00:19:55,200 --> 00:19:58,860
changed at all why did we change and

00:19:57,390 --> 00:20:01,620
sort of missing

00:19:58,860 --> 00:20:05,520
it's a mystery what happened it's a bad

00:20:01,620 --> 00:20:07,140
mystery cache metrics obviously needs to

00:20:05,520 --> 00:20:09,210
be able to determine whether or not the

00:20:07,140 --> 00:20:12,210
item it's interacting with has already

00:20:09,210 --> 00:20:16,380
contains the item or if it's a fresh

00:20:12,210 --> 00:20:18,840
insert so we're using the needs of

00:20:16,380 --> 00:20:21,150
consumers of the API to define what the

00:20:18,840 --> 00:20:23,040
API is this is sort of in contradiction

00:20:21,150 --> 00:20:24,960
to what I said before where I suggested

00:20:23,040 --> 00:20:28,470
that you really want separation and you

00:20:24,960 --> 00:20:33,000
want items to not change unless their

00:20:28,470 --> 00:20:35,250
business policy changes but this

00:20:33,000 --> 00:20:40,260
actually makes a lot of sense

00:20:35,250 --> 00:20:41,910
and is required the infrastructural Co

00:20:40,260 --> 00:20:43,350
which actually is responsible for

00:20:41,910 --> 00:20:47,820
interacting with the real world is going

00:20:43,350 --> 00:20:50,160
to have needs and as long as it as long

00:20:47,820 --> 00:20:52,860
as the API pressures are always going

00:20:50,160 --> 00:20:54,750
from the like from the real world from

00:20:52,860 --> 00:20:56,580
like the things that change volatility

00:20:54,750 --> 00:20:59,670
in words to things that don't change

00:20:56,580 --> 00:21:01,170
that often so we're the implementation

00:20:59,670 --> 00:21:03,060
is going to change much faster than the

00:21:01,170 --> 00:21:06,000
definition then you're in a pretty good

00:21:03,060 --> 00:21:08,430
state if we had if the cash was

00:21:06,000 --> 00:21:10,020
requiring changes on the cash metrics

00:21:08,430 --> 00:21:12,210
and the cash metrics were change we're

00:21:10,020 --> 00:21:13,890
client changes from the cash then you're

00:21:12,210 --> 00:21:17,250
in a situation where your code is in

00:21:13,890 --> 00:21:18,780
spaghetti and it's time to like evaluate

00:21:17,250 --> 00:21:22,590
whether or not you're you've defined

00:21:18,780 --> 00:21:25,080
though your layers correctly once again

00:21:22,590 --> 00:21:26,310
coming back to this design we just want

00:21:25,080 --> 00:21:27,450
the use arrows to only be pointing in

00:21:26,310 --> 00:21:30,390
one direction as soon as you've got a

00:21:27,450 --> 00:21:35,070
loop you've got a problem and things get

00:21:30,390 --> 00:21:37,440
more complex okay so at this point we've

00:21:35,070 --> 00:21:38,670
done enough work that we know the wrong

00:21:37,440 --> 00:21:42,960
ingredients that will allow us to create

00:21:38,670 --> 00:21:44,310
a nice cash at this point and usually

00:21:42,960 --> 00:21:46,680
only when this motivation is when I

00:21:44,310 --> 00:21:51,750
start thinking about defining traits for

00:21:46,680 --> 00:21:52,890
my objects one common motivation that

00:21:51,750 --> 00:21:55,590
would actually get me to define traits

00:21:52,890 --> 00:21:58,230
before I start thinking about reuse or

00:21:55,590 --> 00:22:01,530
common like ecosystem concerns is

00:21:58,230 --> 00:22:03,870
testing traits are the best way to

00:22:01,530 --> 00:22:05,940
create mocks and rust and in general I

00:22:03,870 --> 00:22:09,270
just try to stick to the philosophy of

00:22:05,940 --> 00:22:12,010
use traits as as early as necessary but

00:22:09,270 --> 00:22:13,720
no earlier unlike some ecosystem

00:22:12,010 --> 00:22:15,430
where you really want to create an

00:22:13,720 --> 00:22:18,510
interface before you even have an idea

00:22:15,430 --> 00:22:18,510
of what the code is gonna look like

00:22:19,470 --> 00:22:23,560
coming to us from pretty much any

00:22:21,580 --> 00:22:26,110
language defining trace looks a lot like

00:22:23,560 --> 00:22:30,070
defining abstract base classes you've

00:22:26,110 --> 00:22:32,290
got a function and you've got other

00:22:30,070 --> 00:22:34,540
functions that can defend on depend upon

00:22:32,290 --> 00:22:35,650
those functions that's pretty

00:22:34,540 --> 00:22:39,190
straightforward but there are a couple

00:22:35,650 --> 00:22:41,110
more interesting properties and this

00:22:39,190 --> 00:22:44,170
woman there are no constraints placed

00:22:41,110 --> 00:22:48,430
upon care V at the top level but we are

00:22:44,170 --> 00:22:52,320
saying requiring having placing trate

00:22:48,430 --> 00:22:55,570
trate constraints on a couple of methods

00:22:52,320 --> 00:22:57,010
in this particular case there's

00:22:55,570 --> 00:23:00,160
absolutely no reason to do that it's a

00:22:57,010 --> 00:23:03,190
bad idea when I extracted this crate

00:23:00,160 --> 00:23:04,770
this crate the cat the specific

00:23:03,190 --> 00:23:08,710
implementation that I was working on

00:23:04,770 --> 00:23:11,380
required clones so I initially expected

00:23:08,710 --> 00:23:14,080
the clone requirement as well the good

00:23:11,380 --> 00:23:16,030
news is that in rust removing a trait

00:23:14,080 --> 00:23:18,130
constraint is not a backward it's a

00:23:16,030 --> 00:23:21,690
backwards compatible change so we can

00:23:18,130 --> 00:23:25,120
just trash them and call it a call today

00:23:21,690 --> 00:23:27,700
there's only one more fairly obvious

00:23:25,120 --> 00:23:29,950
property visibility modifiers go on

00:23:27,700 --> 00:23:32,620
trait definitions traits are interfaces

00:23:29,950 --> 00:23:38,340
there is no such thing as a private

00:23:32,620 --> 00:23:40,870
method inside of a tree so you that's it

00:23:38,340 --> 00:23:42,520
also implementing a cache once you've

00:23:40,870 --> 00:23:45,220
got this we have just moved the in

00:23:42,520 --> 00:23:47,620
Pollock from on from existing on the

00:23:45,220 --> 00:23:52,360
cache itself to an input of a trait for

00:23:47,620 --> 00:23:53,830
the cache as promised because get our

00:23:52,360 --> 00:23:57,390
insert was defined in terms of in sort

00:23:53,830 --> 00:23:59,980
of missing it doesn't need to be defined

00:23:57,390 --> 00:24:01,690
one slightly interesting property here

00:23:59,980 --> 00:24:03,370
is that you're not allowed to while

00:24:01,690 --> 00:24:06,640
you're while you are allowed to define

00:24:03,370 --> 00:24:09,490
new where constraints on implementations

00:24:06,640 --> 00:24:11,650
you're not allowed to unlike an input

00:24:09,490 --> 00:24:14,140
lock raw input block or an inherent

00:24:11,650 --> 00:24:16,300
dimple you're not allowed to add trait

00:24:14,140 --> 00:24:18,160
constraints on to methods themselves the

00:24:16,300 --> 00:24:23,290
entire treatment implementation needs to

00:24:18,160 --> 00:24:26,250
be needs the needs the where clause or

00:24:23,290 --> 00:24:26,250
the trade constraint

00:24:26,550 --> 00:24:31,360
now that we've got a treat consider now

00:24:28,870 --> 00:24:32,740
that we've got a treat we can create a

00:24:31,360 --> 00:24:33,730
cache matrix type that can handle any

00:24:32,740 --> 00:24:35,260
type of cache

00:24:33,730 --> 00:24:38,470
we've only got one so far but that's

00:24:35,260 --> 00:24:45,160
okay except that this does not work

00:24:38,470 --> 00:24:49,570
traits aren't types even though here we

00:24:45,160 --> 00:24:51,820
are saying that the V is the compiler is

00:24:49,570 --> 00:24:54,190
telling us that the V is required we're

00:24:51,820 --> 00:24:58,990
using the V it shows up in there but it

00:24:54,190 --> 00:25:03,220
is it's not it's not present the issue

00:24:58,990 --> 00:25:05,740
is that traits are not types rust only

00:25:03,220 --> 00:25:09,640
uses only considers traits used when

00:25:05,740 --> 00:25:13,180
they actually show up inside of the U of

00:25:09,640 --> 00:25:16,120
the implementation luckily the error

00:25:13,180 --> 00:25:18,400
message in this case tells us that gives

00:25:16,120 --> 00:25:20,350
us a pointer to what we need so we can

00:25:18,400 --> 00:25:23,680
get around this with the phantom data

00:25:20,350 --> 00:25:28,570
Cluj give the compiler a little bit of

00:25:23,680 --> 00:25:30,390
hints and work around it I'm going to

00:25:28,570 --> 00:25:34,030
ignore phantom data this is just like a

00:25:30,390 --> 00:25:37,200
reminder that traits are type

00:25:34,030 --> 00:25:37,200
constraints they are not types

00:25:37,860 --> 00:25:41,650
implementing calf still looks very

00:25:40,390 --> 00:25:43,330
similar to the way we did before now

00:25:41,650 --> 00:25:46,000
we've got access to the default getter

00:25:43,330 --> 00:25:48,400
method get our insert method so we're

00:25:46,000 --> 00:25:49,630
continuing to ignore it one other sort

00:25:48,400 --> 00:25:51,910
of interesting property here is with the

00:25:49,630 --> 00:25:55,870
implementation delegation pattern that

00:25:51,910 --> 00:25:57,970
shows up and rust all the time our cache

00:25:55,870 --> 00:26:00,280
has a get method so when we implement a

00:25:57,970 --> 00:26:01,390
trait for a cache for something that

00:26:00,280 --> 00:26:06,460
we're the only thing we know about is

00:26:01,390 --> 00:26:08,500
that it's a cache we just call that and

00:26:06,460 --> 00:26:10,480
here we are tying it all together with

00:26:08,500 --> 00:26:16,470
the core implementation the inherent in

00:26:10,480 --> 00:26:18,700
pull on the cache metrics block the

00:26:16,470 --> 00:26:20,410
coolest thing here is we finally have

00:26:18,700 --> 00:26:22,030
some dependency injection if you come

00:26:20,410 --> 00:26:27,820
from Java this should make you feel a

00:26:22,030 --> 00:26:29,470
little more comfortable yeah

00:26:27,820 --> 00:26:31,180
something else is sort of interesting is

00:26:29,470 --> 00:26:34,750
that the ROS community has decided that

00:26:31,180 --> 00:26:36,250
functions like getters just get the same

00:26:34,750 --> 00:26:37,230
name as a field that they get which I

00:26:36,250 --> 00:26:39,480
love

00:26:37,230 --> 00:26:40,440
lots of other languages support this but

00:26:39,480 --> 00:26:44,100
it's not actually common in their

00:26:40,440 --> 00:26:45,330
communities and that's it

00:26:44,100 --> 00:26:47,520
the overall the implementation of cache

00:26:45,330 --> 00:26:48,840
metrics is straightforward it just has a

00:26:47,520 --> 00:26:52,740
few design decisions that you are

00:26:48,840 --> 00:26:54,030
allowed to make here we are tying

00:26:52,740 --> 00:26:57,480
everything together

00:26:54,030 --> 00:27:00,300
is there anything interesting here we

00:26:57,480 --> 00:27:03,120
created one new line that was six

00:27:00,300 --> 00:27:04,530
minutes of talking and this line is more

00:27:03,120 --> 00:27:07,110
complex than the previous code so what

00:27:04,530 --> 00:27:08,700
have we gained a single direction of

00:27:07,110 --> 00:27:09,870
implementation the cache metrics knows

00:27:08,700 --> 00:27:11,570
about the cache shape but it no longer

00:27:09,870 --> 00:27:14,490
knows about the specific implementation

00:27:11,570 --> 00:27:17,300
the black uses line is completely

00:27:14,490 --> 00:27:20,700
isolated from the implementation line

00:27:17,300 --> 00:27:22,500
which gives you the which is a

00:27:20,700 --> 00:27:27,300
demonstration of traits performing as a

00:27:22,500 --> 00:27:28,470
code type level privacy bear here now

00:27:27,300 --> 00:27:29,850
the actual work that we're doing doesn't

00:27:28,470 --> 00:27:33,210
know what it's interacting with any more

00:27:29,850 --> 00:27:34,950
than it needs to you know okay now that

00:27:33,210 --> 00:27:40,350
we've got a trait what can we do with it

00:27:34,950 --> 00:27:41,160
she seems so happy a cache that falls

00:27:40,350 --> 00:27:43,410
back

00:27:41,160 --> 00:27:46,320
this will really abstract our business

00:27:43,410 --> 00:27:50,160
policy I really like that we've got the

00:27:46,320 --> 00:27:52,410
type type aliasing this pretty much just

00:27:50,160 --> 00:27:53,340
allows us to abstract is fairly complex

00:27:52,410 --> 00:27:58,200
thing into something that's easier to

00:27:53,340 --> 00:27:59,490
say any cache is any cache focusing on

00:27:58,200 --> 00:28:00,960
the axle implementation we've got a

00:27:59,490 --> 00:28:03,420
little bit of an odd shape to this

00:28:00,960 --> 00:28:05,820
struct it's got an any cache in first

00:28:03,420 --> 00:28:12,480
position and a vac of any cache in rest

00:28:05,820 --> 00:28:14,850
position we this is an example of using

00:28:12,480 --> 00:28:16,950
the type system to avoid having to write

00:28:14,850 --> 00:28:20,850
some tests we want every cascade cache

00:28:16,950 --> 00:28:23,040
to have a at least one cache if we were

00:28:20,850 --> 00:28:24,150
if we had just a Veck of any cache then

00:28:23,040 --> 00:28:28,500
we'd have to write a bunch of tests that

00:28:24,150 --> 00:28:30,060
verify that this is caching this always

00:28:28,500 --> 00:28:33,480
has at least one cache here the type

00:28:30,060 --> 00:28:34,440
system will guarantee that for us the

00:28:33,480 --> 00:28:36,510
only other thing here is that we're

00:28:34,440 --> 00:28:38,460
using the Builder pattern every we just

00:28:36,510 --> 00:28:42,470
return itself and that makes it like we

00:28:38,460 --> 00:28:42,470
can do with and and and it'll be nice

00:28:43,340 --> 00:28:48,600
this is a reasonable implementation

00:28:46,560 --> 00:28:49,140
assuming a reasonable implementation of

00:28:48,600 --> 00:28:51,840
ket

00:28:49,140 --> 00:28:53,549
cash for any cash we can now comfortably

00:28:51,840 --> 00:28:59,100
double our memory usage for absolutely

00:28:53,549 --> 00:29:01,320
no gain which I like okay so let's talk

00:28:59,100 --> 00:29:04,950
about what it takes to build an

00:29:01,320 --> 00:29:07,080
ecosystem the most prop the most

00:29:04,950 --> 00:29:08,730
important property in a large and

00:29:07,080 --> 00:29:10,950
complex ecosystem is the ability for

00:29:08,730 --> 00:29:12,929
users to walk to work together without

00:29:10,950 --> 00:29:21,210
ever having to speak to each other in

00:29:12,929 --> 00:29:22,559
any way the in this case things that can

00:29:21,210 --> 00:29:28,290
contribute to that there's small

00:29:22,559 --> 00:29:29,669
genuinely public items in general your

00:29:28,290 --> 00:29:33,860
code will just be much simpler to

00:29:29,669 --> 00:29:36,270
understand and use if it is simple

00:29:33,860 --> 00:29:37,620
making up items public means that it's

00:29:36,270 --> 00:29:38,610
possible for developers so we use the

00:29:37,620 --> 00:29:41,910
work that you've done without

00:29:38,610 --> 00:29:44,429
communicating with you building your own

00:29:41,910 --> 00:29:46,290
implementations in separate crates is a

00:29:44,429 --> 00:29:48,360
great way to guarantee that what you

00:29:46,290 --> 00:29:52,140
think is actually usable is actually

00:29:48,360 --> 00:29:54,120
usable means that other people can come

00:29:52,140 --> 00:29:57,660
in and build things for you and you

00:29:54,120 --> 00:30:01,490
won't have to worry about it but you

00:29:57,660 --> 00:30:05,760
still have ideally a clear definition of

00:30:01,490 --> 00:30:07,620
what like what the core of your code is

00:30:05,760 --> 00:30:10,230
doing everything is going in one

00:30:07,620 --> 00:30:14,210
direction and that is the direction that

00:30:10,230 --> 00:30:19,070
changes the least so what have I done

00:30:14,210 --> 00:30:21,480
I talked about leaning in the strictness

00:30:19,070 --> 00:30:24,630
trying to encode business rules into the

00:30:21,480 --> 00:30:26,700
type and life time system keeping API

00:30:24,630 --> 00:30:28,919
small is really something that is hard

00:30:26,700 --> 00:30:32,390
to do in general and the best way to

00:30:28,919 --> 00:30:34,770
make sure that you succeed at that is to

00:30:32,390 --> 00:30:36,950
just make it as small as possible and

00:30:34,770 --> 00:30:39,360
give yourself for all those speed bumps

00:30:36,950 --> 00:30:42,860
you can read the rest of this I'm out of

00:30:39,360 --> 00:30:54,859
time that was my talk

00:30:42,860 --> 00:30:54,859
[Applause]

00:30:55,530 --> 00:31:03,220
[Music]

00:31:01,159 --> 00:31:03,220

YouTube URL: https://www.youtube.com/watch?v=2uBbjq-Trnk


