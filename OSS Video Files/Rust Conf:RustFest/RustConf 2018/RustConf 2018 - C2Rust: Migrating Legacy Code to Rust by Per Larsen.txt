Title: RustConf 2018 - C2Rust: Migrating Legacy Code to Rust by Per Larsen
Publication date: 2018-09-06
Playlist: RustConf 2018
Description: 
	RustConf 2018 - C2Rust: Migrating Legacy Code to Rust by Per Larsen

Although Rust is safer and more modern than C/C++, it is still difficult to justify the cost of migrating existing, mature systems code.

This talk will present a trifecta of tools to address the costs and risks of such migration efforts. The first tool is a transpiler which generates structurally equivalent-yet-unsafe Rust code from the input C code. The second is a dynamic analysis tool which runs the original C code alongside the new Rust code to check whether they are performing the same computations. The third is a refactoring tool which helps programmers idiomize the output of our transpiler.

Our aim is to automate many of the steps that are entirely manual when migrating from C to Rust today. However, we do not expect that the migration process will be fully automatic. Therefore, we focus on detecting unexpected discrepancies as the programmer gradually rewrites the transpiled code to make better use of Rust idioms. Our tools are open source and available to anyone.

Additional resources:

Code: https://www.github.com/immunant/c2rust
Demo: https://www.c2rust.com
Slides: https://www.ics.uci.edu/~perl/rustconf18_c2rust.pdf
Writeup: https://galois.com/blog/2018/08/c2rust/
Captions: 
	00:00:00,410 --> 00:00:17,390
[Music]

00:00:14,410 --> 00:00:20,960
thank you I'm I'm super happy to be here

00:00:17,390 --> 00:00:23,150
and presenter work today this is a joint

00:00:20,960 --> 00:00:25,550
work with a gala wah and the company I'm

00:00:23,150 --> 00:00:31,400
from eminent I'll get into that in a

00:00:25,550 --> 00:00:38,500
second but just in case hmm I gotta

00:00:31,400 --> 00:00:40,610
figure out how to switch slides okay

00:00:38,500 --> 00:00:42,860
just in case you thought this was going

00:00:40,610 --> 00:00:48,260
to be a talk with cute cat pictures and

00:00:42,860 --> 00:00:50,600
gifts and jokes it's not what we we do

00:00:48,260 --> 00:00:52,670
is has been funded in part by DARPA and

00:00:50,600 --> 00:00:56,239
and they require us to start with this

00:00:52,670 --> 00:00:58,910
legal disclaimer so I'm sorry but this

00:00:56,239 --> 00:01:01,309
is what I have to show you that we asked

00:00:58,910 --> 00:01:03,260
if we could please talk to people about

00:01:01,309 --> 00:01:07,640
this at Ross conf and and DARPA said yes

00:01:03,260 --> 00:01:10,039
so that's all the legalese I have to

00:01:07,640 --> 00:01:12,050
bore you guys with so just really

00:01:10,039 --> 00:01:14,570
quickly my name is Pierre I'm a

00:01:12,050 --> 00:01:16,009
co-founder at immune --nt I work with a

00:01:14,570 --> 00:01:18,860
crack team of compiler and linker

00:01:16,009 --> 00:01:20,900
experts from Denmark originally if in in

00:01:18,860 --> 00:01:21,619
case you wonder why my my accent is

00:01:20,900 --> 00:01:23,780
weird

00:01:21,619 --> 00:01:26,720
I enjoy enjoy living in Southern

00:01:23,780 --> 00:01:29,060
California these days and I'm actually

00:01:26,720 --> 00:01:31,070
not an expert on rust so I have a little

00:01:29,060 --> 00:01:33,640
bit of impostor syndrome going on today

00:01:31,070 --> 00:01:37,159
my background is mainly in c and c++

00:01:33,640 --> 00:01:39,439
exploit mitigation and I'll talk about

00:01:37,159 --> 00:01:40,820
how that led us to the C to rust work

00:01:39,439 --> 00:01:43,159
but first I just want to acknowledge

00:01:40,820 --> 00:01:44,990
that I'm part of a much larger team

00:01:43,159 --> 00:01:46,939
there's three gentlemen from Galois

00:01:44,990 --> 00:01:49,670
shown here and three of my colleagues at

00:01:46,939 --> 00:01:51,439
immune end that are all crack coders and

00:01:49,670 --> 00:01:52,579
and they do much of the heavy lifting

00:01:51,439 --> 00:01:55,159
and if you have any really hard

00:01:52,579 --> 00:01:58,670
questions I'm going to defer to Andre

00:01:55,159 --> 00:02:00,560
who's in the audience today there's also

00:01:58,670 --> 00:02:03,290
some researchers that UC Irvine that

00:02:00,560 --> 00:02:08,119
helped with this work from Michael

00:02:03,290 --> 00:02:10,910
France and in a stint falter so with

00:02:08,119 --> 00:02:13,010
that out of the way why why should you

00:02:10,910 --> 00:02:17,150
consider even moving your your well test

00:02:13,010 --> 00:02:20,180
at C code to rust even even as awesome

00:02:17,150 --> 00:02:21,349
as rust this it's I think that's a fair

00:02:20,180 --> 00:02:24,800
question to ask

00:02:21,349 --> 00:02:26,450
so I've showing a graph here from the

00:02:24,800 --> 00:02:27,200
National Institute of Technology's

00:02:26,450 --> 00:02:28,640
national boner

00:02:27,200 --> 00:02:32,030
ability database and it essentially

00:02:28,640 --> 00:02:34,670
tracks 20 years worth of stats on buffer

00:02:32,030 --> 00:02:36,830
errors which is not the only security

00:02:34,670 --> 00:02:38,420
issue you can have in C and C++ code but

00:02:36,830 --> 00:02:40,310
it's it's among one of the most common

00:02:38,420 --> 00:02:43,550
so that's this kind of stuff where you

00:02:40,310 --> 00:02:45,500
under overflow and array index and you

00:02:43,550 --> 00:02:48,170
access memory that you're not supposed

00:02:45,500 --> 00:02:53,930
to and in many cases that's exploitable

00:02:48,170 --> 00:02:56,569
and all hell could break loose so as I

00:02:53,930 --> 00:02:58,940
said I have a background in working on C

00:02:56,569 --> 00:03:02,209
and C++ exploit mitigations where we try

00:02:58,940 --> 00:03:04,910
to change the way we compile C and C++

00:03:02,209 --> 00:03:06,680
code and and you can do something to

00:03:04,910 --> 00:03:09,319
sort of take the lowest hanging fruit

00:03:06,680 --> 00:03:12,019
off the table to adversaries but in the

00:03:09,319 --> 00:03:13,730
end the pattern is that you come up with

00:03:12,019 --> 00:03:15,799
a new exploit mitigation and then the

00:03:13,730 --> 00:03:17,630
adversaries find another way to work

00:03:15,799 --> 00:03:20,840
around that and still exploit the C and

00:03:17,630 --> 00:03:24,280
C++ code so it's it's it's an arms race

00:03:20,840 --> 00:03:27,110
really in in in rust is an attractive

00:03:24,280 --> 00:03:29,540
migration target I'm sure I won't have

00:03:27,110 --> 00:03:30,829
to sell you guys on rust but it does

00:03:29,540 --> 00:03:32,630
have this interesting property of

00:03:30,829 --> 00:03:34,549
providing not just type and memory

00:03:32,630 --> 00:03:36,560
safety but also freedom from data data

00:03:34,549 --> 00:03:38,239
races so that's that's like catnip to

00:03:36,560 --> 00:03:43,340
people that have written a lot of C in

00:03:38,239 --> 00:03:46,579
C++ so we thought well okay rust is

00:03:43,340 --> 00:03:49,940
great but it's obviously not easy to get

00:03:46,579 --> 00:03:52,310
into rust is there anything we can do to

00:03:49,940 --> 00:03:54,350
lower the barrier to entry there if you

00:03:52,310 --> 00:03:57,620
have a C code base that that you sort of

00:03:54,350 --> 00:03:59,090
depend on and must use so we're going to

00:03:57,620 --> 00:04:01,819
be talking about doing two things and

00:03:59,090 --> 00:04:04,130
the first one is reducing the the tedium

00:04:01,819 --> 00:04:06,470
of just getting into rust syntax I'm

00:04:04,130 --> 00:04:09,950
gonna show you some really disturbing

00:04:06,470 --> 00:04:11,389
and ugly rust code later and that's

00:04:09,950 --> 00:04:13,519
something you you're gonna want to

00:04:11,389 --> 00:04:15,470
refactor into pretty and idiomatic

00:04:13,519 --> 00:04:17,599
rusted that doesn't make your eyes bleed

00:04:15,470 --> 00:04:22,430
and as you're doing that that's gonna be

00:04:17,599 --> 00:04:23,780
a mostly manual process so we're also

00:04:22,430 --> 00:04:26,660
gonna do something to try and help you

00:04:23,780 --> 00:04:30,169
catch errors during transfer factoring

00:04:26,660 --> 00:04:32,180
into a more idiomatic rust so this is

00:04:30,169 --> 00:04:36,229
this is the grand idea this is what we

00:04:32,180 --> 00:04:38,680
pitched initially and and what I hope we

00:04:36,229 --> 00:04:40,700
can get to one day in the far future so

00:04:38,680 --> 00:04:43,370
the main points of

00:04:40,700 --> 00:04:46,100
this year is to notice is the flow on

00:04:43,370 --> 00:04:47,840
the top where we're taking untrusted

00:04:46,100 --> 00:04:51,350
unsafe C code and we run it through a

00:04:47,840 --> 00:04:54,860
transpiler and outcomes unsafe rust

00:04:51,350 --> 00:04:56,810
it's a syntax driven translation into

00:04:54,860 --> 00:04:58,460
rust that basically projects the

00:04:56,810 --> 00:05:01,610
structure of the C code into rust and

00:04:58,460 --> 00:05:03,290
uses C types and it doesn't buy much in

00:05:01,610 --> 00:05:05,290
terms of security but at least it

00:05:03,290 --> 00:05:08,900
compiles to rust C and that's something

00:05:05,290 --> 00:05:10,460
so that's the initial stage from 0 to 1

00:05:08,900 --> 00:05:13,520
and then the latter stages is sort of

00:05:10,460 --> 00:05:15,260
iterative from n to n plus 1 where you

00:05:13,520 --> 00:05:17,090
have some Russ code that you're not

00:05:15,260 --> 00:05:18,740
entirely happy with yet and you want to

00:05:17,090 --> 00:05:20,660
make it more dramatic and you basically

00:05:18,740 --> 00:05:22,310
have two options you can either manually

00:05:20,660 --> 00:05:24,350
rewrite it or you can hope that we

00:05:22,310 --> 00:05:26,930
provide some sort of refactoring that

00:05:24,350 --> 00:05:31,010
can either suggest or do a rewrite for

00:05:26,930 --> 00:05:36,890
you that improves the the quality of the

00:05:31,010 --> 00:05:39,260
rust in some way and in case you are

00:05:36,890 --> 00:05:40,910
forced to do a manual rewriting we know

00:05:39,260 --> 00:05:43,580
that humans are tend to make errors

00:05:40,910 --> 00:05:47,120
we're not perfect so what we do to catch

00:05:43,580 --> 00:05:48,980
those errors are is that we cross-check

00:05:47,120 --> 00:05:51,890
the Russ code you have against the

00:05:48,980 --> 00:05:54,740
original C program so we're we have a

00:05:51,890 --> 00:05:56,930
tacit assumption here that you wanna at

00:05:54,740 --> 00:05:58,790
some level preserve the functionality of

00:05:56,930 --> 00:06:02,470
what your C programming is doing so

00:05:58,790 --> 00:06:05,330
let's say you're trans you're migrating

00:06:02,470 --> 00:06:07,700
decoder you still want to decode an

00:06:05,330 --> 00:06:09,980
output from your s code to be the same

00:06:07,700 --> 00:06:12,380
as your C code so there's lots of

00:06:09,980 --> 00:06:14,090
opportunities in there to to check the

00:06:12,380 --> 00:06:16,160
two versions or sanitize them against

00:06:14,090 --> 00:06:19,510
each other so we'll talk about that

00:06:16,160 --> 00:06:21,800
later but first transpiling

00:06:19,510 --> 00:06:23,390
the things we wanted to accomplish

00:06:21,800 --> 00:06:25,580
without transpiler i'm going to talk

00:06:23,390 --> 00:06:27,880
about a few other transpilers in a

00:06:25,580 --> 00:06:30,320
second so we have some unique goals

00:06:27,880 --> 00:06:32,000
partially informed by the experiences of

00:06:30,320 --> 00:06:34,160
others that fought to build deterrents

00:06:32,000 --> 00:06:37,490
pilot before us and inspired us in that

00:06:34,160 --> 00:06:42,680
way is that we wanted to do robust C and

00:06:37,490 --> 00:06:44,150
C++ parsing we basically want to handle

00:06:42,680 --> 00:06:48,710
more than hello world we want to be able

00:06:44,150 --> 00:06:50,900
to take huge and crusty old C code bases

00:06:48,710 --> 00:06:52,490
and parse them and we want to preserve

00:06:50,900 --> 00:06:54,139
the functionality of that code because

00:06:52,490 --> 00:06:55,729
it's most likely we'll just the despair

00:06:54,139 --> 00:06:57,650
if you care enough about it to move it

00:06:55,729 --> 00:06:59,330
into rust so we've got to preserve the

00:06:57,650 --> 00:07:02,110
functionality of the code we take in and

00:06:59,330 --> 00:07:04,909
convert to rust

00:07:02,110 --> 00:07:07,099
we also want to the extent possible

00:07:04,909 --> 00:07:07,789
generate output that's fit for human

00:07:07,099 --> 00:07:09,710
consumption

00:07:07,789 --> 00:07:12,919
somebody's going to be hopefully

00:07:09,710 --> 00:07:14,270
refactoring it later so if there's

00:07:12,919 --> 00:07:17,469
something we can do to not make your

00:07:14,270 --> 00:07:20,810
eyes beat we will try and do that

00:07:17,469 --> 00:07:22,819
finally we're also excited about rust so

00:07:20,810 --> 00:07:25,669
we want to write as much as a transpiler

00:07:22,819 --> 00:07:28,759
in rust and we want to reuse some of the

00:07:25,669 --> 00:07:32,169
rust compiler internals on the back end

00:07:28,759 --> 00:07:35,229
so first a hat tip to other efforts

00:07:32,169 --> 00:07:37,849
co-wrote was the first C to rust

00:07:35,229 --> 00:07:41,889
transpiler it's written in Haskell in

00:07:37,849 --> 00:07:45,319
the by Jamie sharp we met him yesterday

00:07:41,889 --> 00:07:47,870
nice gentleman it uses the Haskell C

00:07:45,319 --> 00:07:50,060
parsing library and because that is less

00:07:47,870 --> 00:07:52,550
used and less maintained and and

00:07:50,060 --> 00:07:54,650
battle-tested than the clang c compiler

00:07:52,550 --> 00:07:56,719
that leads to certain limitations but

00:07:54,650 --> 00:08:00,319
it's certainly an impressive effort for

00:07:56,719 --> 00:08:02,839
one guy and and so that's good work and

00:08:00,319 --> 00:08:05,389
there's also a citrus RS which is

00:08:02,839 --> 00:08:07,819
interesting because it's it's based on

00:08:05,389 --> 00:08:10,069
clang like we do but it's not making any

00:08:07,819 --> 00:08:12,199
effort to generate C code that were a

00:08:10,069 --> 00:08:15,110
sorry rust code that would actually run

00:08:12,199 --> 00:08:17,149
right away it's trying to generate the

00:08:15,110 --> 00:08:20,000
closest approximation of what what you

00:08:17,149 --> 00:08:22,009
would want to write ultimately so it's

00:08:20,000 --> 00:08:24,139
it's it's merely trying to help you with

00:08:22,009 --> 00:08:28,039
the syntactical changes so we sort of

00:08:24,139 --> 00:08:29,629
slot in between these two by by handling

00:08:28,039 --> 00:08:31,610
all C input and also generating

00:08:29,629 --> 00:08:32,329
something that runs and that you can

00:08:31,610 --> 00:08:34,310
work further on

00:08:32,329 --> 00:08:36,769
so our transpiler is kind of a chimera

00:08:34,310 --> 00:08:40,630
it's C++ on the front end because if

00:08:36,769 --> 00:08:40,630
clang and then it's rust in the back end

00:08:40,930 --> 00:08:46,310
so the flow is that we take in a bunch

00:08:43,699 --> 00:08:48,260
of C sources and we take a JSON file

00:08:46,310 --> 00:08:51,649
that's called compile commands n which

00:08:48,260 --> 00:08:54,230
informs us of how the compiler was

00:08:51,649 --> 00:08:56,360
invoked so we can have playing

00:08:54,230 --> 00:08:58,220
pre-process the the C code and then we

00:08:56,360 --> 00:09:00,529
translate it and that that has some

00:08:58,220 --> 00:09:03,260
interesting consequences that I'll

00:09:00,529 --> 00:09:05,959
mention briefly later so all of this is

00:09:03,260 --> 00:09:07,400
driven by a blue Python script and

00:09:05,959 --> 00:09:10,310
underneath the hood we have two

00:09:07,400 --> 00:09:12,910
- one is a C++ binary called the ASC

00:09:10,310 --> 00:09:15,620
exporter it's very boring it it merely

00:09:12,910 --> 00:09:17,540
serializes the clang ast into a c4 file

00:09:15,620 --> 00:09:20,140
it's a completely arbitrary choice of

00:09:17,540 --> 00:09:23,870
format and that seaboard file isn't

00:09:20,140 --> 00:09:26,180
consumed by our ast importer

00:09:23,870 --> 00:09:28,940
so the a ste importers that is the most

00:09:26,180 --> 00:09:30,950
interesting part of the transpiler it DC

00:09:28,940 --> 00:09:33,800
realizes the Seaboard file and then that

00:09:30,950 --> 00:09:36,950
gives you a claim AST which we represent

00:09:33,800 --> 00:09:39,110
in in in in rust and i think we use

00:09:36,950 --> 00:09:41,270
pungent too to make sure that we

00:09:39,110 --> 00:09:44,210
synchronize some of the data structures

00:09:41,270 --> 00:09:47,150
there we transform that clang ast into

00:09:44,210 --> 00:09:49,070
our own internal importer ASC and then

00:09:47,150 --> 00:09:50,960
as a second step we do a similar

00:09:49,070 --> 00:09:55,190
transformation I walk over the importer

00:09:50,960 --> 00:09:57,320
ast and build up a rust C syntax ast

00:09:55,190 --> 00:10:00,290
from the RUS compiler which means that

00:09:57,320 --> 00:10:04,100
all this code has to use the the nightly

00:10:00,290 --> 00:10:06,100
channel because the rust compiler syntax

00:10:04,100 --> 00:10:09,950
tree is only exposed than the 90 channel

00:10:06,100 --> 00:10:14,030
for now in in the in the process of this

00:10:09,950 --> 00:10:16,250
second stage conversion we prune a seed

00:10:14,030 --> 00:10:17,840
declaration that we don't see being used

00:10:16,250 --> 00:10:20,240
in the current translation unit because

00:10:17,840 --> 00:10:22,730
you have even in your hello world you'll

00:10:20,240 --> 00:10:25,940
you'll probably have to include a header

00:10:22,730 --> 00:10:28,010
file for printf and that that pulls in a

00:10:25,940 --> 00:10:29,570
lot of other gunk that you are you don't

00:10:28,010 --> 00:10:33,290
necessarily use so we'd prune that out

00:10:29,570 --> 00:10:35,030
and we also look at loops that contain

00:10:33,290 --> 00:10:37,370
unstructured control flow such as go

00:10:35,030 --> 00:10:39,020
twos and we try to generate a valid

00:10:37,370 --> 00:10:41,920
dress code for that so I have a few

00:10:39,020 --> 00:10:45,020
details on that later too but first

00:10:41,920 --> 00:10:47,090
pre-processing we do our transpiling

00:10:45,020 --> 00:10:48,710
after pre-processing and that means that

00:10:47,090 --> 00:10:50,540
we need to know how to invoke the

00:10:48,710 --> 00:10:53,060
compiler with the write flags for a

00:10:50,540 --> 00:10:55,880
given platform so this is a problem that

00:10:53,060 --> 00:10:57,790
IDs always also have an analysis tools

00:10:55,880 --> 00:11:00,620
so there's an existing solution where

00:10:57,790 --> 00:11:02,060
clang will actually read this JSON file

00:11:00,620 --> 00:11:04,340
I mentioned earlier there's an example

00:11:02,060 --> 00:11:05,840
on on the right showing the contents

00:11:04,340 --> 00:11:07,520
it's very simple it just gives the

00:11:05,840 --> 00:11:10,310
arguments of the compiler and in the

00:11:07,520 --> 00:11:13,090
build context and you can get this file

00:11:10,310 --> 00:11:16,340
automatically but the way you do so

00:11:13,090 --> 00:11:17,750
depends a little bit on what build

00:11:16,340 --> 00:11:20,450
system you have on what platform you're

00:11:17,750 --> 00:11:21,290
on so if you're using C make great you

00:11:20,450 --> 00:11:24,050
just add another

00:11:21,290 --> 00:11:25,820
flag if you're not using see make claim

00:11:24,050 --> 00:11:28,339
comes with a script that's called

00:11:25,820 --> 00:11:32,389
intercept built that you can use for

00:11:28,339 --> 00:11:35,540
make file projects both on Linux and Mac

00:11:32,389 --> 00:11:37,310
OS or you can use pair on Linux so

00:11:35,540 --> 00:11:38,360
there's there's a few different ways and

00:11:37,310 --> 00:11:40,730
you got to find out what's right for

00:11:38,360 --> 00:11:44,360
your environment it's messy and C C Lane

00:11:40,730 --> 00:11:47,269
as usual so let's get back to

00:11:44,360 --> 00:11:48,560
transpiling loops in the simple case

00:11:47,269 --> 00:11:51,019
where the C code doesn't have any

00:11:48,560 --> 00:11:53,690
unstructured control file we simply

00:11:51,019 --> 00:11:55,279
generate rust while loops so that's

00:11:53,690 --> 00:11:56,720
fairly simple and straightforward we

00:11:55,279 --> 00:11:59,600
generated while loop no matter whether

00:11:56,720 --> 00:12:03,649
you put in a for loop or Y loop on the

00:11:59,600 --> 00:12:09,139
see sign in case you have go-to things

00:12:03,649 --> 00:12:11,269
get a lot more interesting so this this

00:12:09,139 --> 00:12:14,120
code example we have a demo I don't know

00:12:11,269 --> 00:12:16,399
if you've seen it out front but the

00:12:14,120 --> 00:12:17,980
conveniens from gondwana they've they've

00:12:16,399 --> 00:12:20,089
been running the demo website and

00:12:17,980 --> 00:12:23,480
somebody actually submitted this code

00:12:20,089 --> 00:12:24,649
example to the demo website and and and

00:12:23,480 --> 00:12:27,560
we're presenting here for your viewing

00:12:24,649 --> 00:12:33,350
pleasure it actually reads quite nicely

00:12:27,560 --> 00:12:35,420
too while loop in rust so I'm calling

00:12:33,350 --> 00:12:38,870
you looping because we're using the real

00:12:35,420 --> 00:12:41,480
looper algorithm by Alan Sakai of the

00:12:38,870 --> 00:12:44,060
inscription project they face the

00:12:41,480 --> 00:12:46,519
similar project a problem in so far that

00:12:44,060 --> 00:12:48,740
they're translating LLVM ir into

00:12:46,519 --> 00:12:51,920
javascript code which also doesn't allow

00:12:48,740 --> 00:12:54,740
in structured control flow so we we

00:12:51,920 --> 00:12:56,660
reuse the Alan's work but we're doing a

00:12:54,740 --> 00:12:58,790
little bit more because we are

00:12:56,660 --> 00:13:00,470
interested in human consumption of our

00:12:58,790 --> 00:13:02,060
output where it's Krypton is simply

00:13:00,470 --> 00:13:04,010
feeding the JavaScript to a JavaScript

00:13:02,060 --> 00:13:07,029
compiler hopefully nobody touches that

00:13:04,010 --> 00:13:11,420
once it's been transpired so we try to

00:13:07,029 --> 00:13:14,990
preserve comments while real ooping and

00:13:11,420 --> 00:13:17,000
and we also optimize for readability and

00:13:14,990 --> 00:13:20,420
in this this is this is obviously an

00:13:17,000 --> 00:13:23,120
example where where it works all right

00:13:20,420 --> 00:13:26,930
so there's a couple of things we can't

00:13:23,120 --> 00:13:29,420
transpile today the one we run into the

00:13:26,930 --> 00:13:32,120
most is lack of support for very otic

00:13:29,420 --> 00:13:34,100
function definition we can call very

00:13:32,120 --> 00:13:35,839
attic functions it

00:13:34,100 --> 00:13:37,790
that are external in C code so we can

00:13:35,839 --> 00:13:40,490
call printf for instance no problem

00:13:37,790 --> 00:13:42,230
there's syntax for that but there's

00:13:40,490 --> 00:13:45,230
still a blocking issue on actually

00:13:42,230 --> 00:13:49,670
having rust function definitions that

00:13:45,230 --> 00:13:52,339
have a very attic argument list bid

00:13:49,670 --> 00:13:54,920
fields is also something that we're

00:13:52,339 --> 00:13:58,279
blocked on but there's also a rust rc4

00:13:54,920 --> 00:14:00,920
that so if if that ever gets implemented

00:13:58,279 --> 00:14:02,209
in rust we can translate it I'm not

00:14:00,920 --> 00:14:03,079
going to go into long doubles and

00:14:02,209 --> 00:14:06,649
complex types

00:14:03,079 --> 00:14:09,230
that's a Lib C rusts create issue but

00:14:06,649 --> 00:14:12,019
macros is is something that that we're

00:14:09,230 --> 00:14:14,240
not showing in the output because we do

00:14:12,019 --> 00:14:17,300
the translation after macro expansion so

00:14:14,240 --> 00:14:19,009
that means whatever the macros expand to

00:14:17,300 --> 00:14:20,930
on your platform that's what the Bross

00:14:19,009 --> 00:14:24,230
code is going to reflect now it would be

00:14:20,930 --> 00:14:26,750
much nicer if you could preserve the

00:14:24,230 --> 00:14:31,940
portability and flexibility of your C

00:14:26,750 --> 00:14:35,120
code by at least handling macro cases

00:14:31,940 --> 00:14:37,160
where there is a reasonable translation

00:14:35,120 --> 00:14:39,620
into rust so remember that C macros

00:14:37,160 --> 00:14:41,089
don't operate on on the syntax tree

00:14:39,620 --> 00:14:43,730
there they're purely textual

00:14:41,089 --> 00:14:45,439
replacements so it's possible for a

00:14:43,730 --> 00:14:47,720
macro to expand to something that

00:14:45,439 --> 00:14:50,029
doesn't generate a valid syntax tree and

00:14:47,720 --> 00:14:51,620
sometimes you have pair of Mac pairs of

00:14:50,029 --> 00:14:54,290
macros begin and end that have to be

00:14:51,620 --> 00:14:55,850
used together to get valid C code so

00:14:54,290 --> 00:14:58,430
stuff like that is something we don't

00:14:55,850 --> 00:15:00,199
see ourselves ever supporting in Reverse

00:14:58,430 --> 00:15:01,730
but there's there's probably a good deal

00:15:00,199 --> 00:15:04,779
of macros that we can support with

00:15:01,730 --> 00:15:07,519
reasonable effort but as of now we don't

00:15:04,779 --> 00:15:09,769
so this is the web demo I hope everybody

00:15:07,519 --> 00:15:11,810
has seen this already now and actually

00:15:09,769 --> 00:15:15,319
talked to people that at the demo slot

00:15:11,810 --> 00:15:19,189
instead but if you haven't go to C to

00:15:15,319 --> 00:15:21,019
Roz comm and you can see that you can

00:15:19,189 --> 00:15:24,620
either type in your own C code or you

00:15:21,019 --> 00:15:26,600
can choose from a few pre-baked examples

00:15:24,620 --> 00:15:32,569
you can translate it download the output

00:15:26,600 --> 00:15:37,939
hopefully it runs and there's also links

00:15:32,569 --> 00:15:40,759
to the source code in an FAQ so we

00:15:37,939 --> 00:15:42,290
consider this our our our business card

00:15:40,759 --> 00:15:45,949
and the way to get ahold of us if you

00:15:42,290 --> 00:15:47,720
want to complain so if you want to do

00:15:45,949 --> 00:15:50,450
more than just translate

00:15:47,720 --> 00:15:55,130
one file at a time you got a clone the

00:15:50,450 --> 00:15:56,840
software and build it locally and it the

00:15:55,130 --> 00:16:00,380
way you do that depends a little bit on

00:15:56,840 --> 00:16:03,830
what platform you are on so some of the

00:16:00,380 --> 00:16:05,900
our code is Linux only so if you're on

00:16:03,830 --> 00:16:10,280
another platform I'd encourage you to

00:16:05,900 --> 00:16:15,050
either take a look at docker or vagrant

00:16:10,280 --> 00:16:16,820
we provide scripts for both it's one

00:16:15,050 --> 00:16:18,410
it's a containerization technology and

00:16:16,820 --> 00:16:21,410
another one is a virtualization

00:16:18,410 --> 00:16:23,960
technology and we provide scripts that

00:16:21,410 --> 00:16:25,880
will build a doctor of a current

00:16:23,960 --> 00:16:27,350
environment and provision it's such that

00:16:25,880 --> 00:16:29,390
you have all the right packages in the

00:16:27,350 --> 00:16:31,700
right places for the seizure or s build

00:16:29,390 --> 00:16:33,110
systems to just function flawlessly and

00:16:31,700 --> 00:16:35,660
if they don't I hope you'll file an

00:16:33,110 --> 00:16:40,490
issue or write me a sternly a worded

00:16:35,660 --> 00:16:42,890
letter so because it's kind of a chimera

00:16:40,490 --> 00:16:45,410
we use Python to glue together the build

00:16:42,890 --> 00:16:47,600
processes so you simply run the build

00:16:45,410 --> 00:16:49,160
translator script with claim and that

00:16:47,600 --> 00:16:51,860
gives you the translator and you can

00:16:49,160 --> 00:16:53,780
similarly build all the projects that

00:16:51,860 --> 00:16:56,390
your that are required for cross

00:16:53,780 --> 00:16:59,180
checking on this c and c plus a c and

00:16:56,390 --> 00:17:02,300
rust side and the refracting tool is

00:16:59,180 --> 00:17:08,030
pure rust that's that's built with cargo

00:17:02,300 --> 00:17:12,680
the way we know and love so here's an

00:17:08,030 --> 00:17:14,569
example of how to transpile i've have a

00:17:12,680 --> 00:17:16,760
little buffer a library that i cloned

00:17:14,569 --> 00:17:18,860
from from c lips and i removed very

00:17:16,760 --> 00:17:21,380
attic functions so i won't be

00:17:18,860 --> 00:17:24,020
embarrassed by warning messages in

00:17:21,380 --> 00:17:26,180
harris and you simply use bear to make

00:17:24,020 --> 00:17:29,030
it such that you get a compiled commands

00:17:26,180 --> 00:17:30,590
a json file as you build it and it

00:17:29,030 --> 00:17:33,680
automatically runs the test suite and

00:17:30,590 --> 00:17:35,600
prints out okay so that's just the c

00:17:33,680 --> 00:17:38,420
code and then you can you can use our

00:17:35,600 --> 00:17:39,740
trans pilot that py script to point it

00:17:38,420 --> 00:17:41,390
to the compiled commands and we'll look

00:17:39,740 --> 00:17:43,040
at all the C files and it'll run the

00:17:41,390 --> 00:17:44,600
transpiler on them and it will pick up

00:17:43,040 --> 00:17:46,730
the main method from the test

00:17:44,600 --> 00:17:49,580
translation unit because we put a pass

00:17:46,730 --> 00:17:52,130
in the - m argument and then you can

00:17:49,580 --> 00:17:55,400
simply go into the C trust builds up

00:17:52,130 --> 00:17:58,850
gear and run cargo and lo and behold it

00:17:55,400 --> 00:18:01,380
does the same thing great success so

00:17:58,850 --> 00:18:03,060
here's here's an example

00:18:01,380 --> 00:18:08,150
input function from that buffer library

00:18:03,060 --> 00:18:12,450
that I just showed you and here is the

00:18:08,150 --> 00:18:14,970
translated rust output so you can see

00:18:12,450 --> 00:18:18,150
it's not exactly the rust that a human

00:18:14,970 --> 00:18:23,190
would write it's it uses its it's all

00:18:18,150 --> 00:18:24,990
unsafe it uses no mangle it basically

00:18:23,190 --> 00:18:28,160
calls malloc just like the C code did it

00:18:24,990 --> 00:18:31,020
has the same kind of error handling and

00:18:28,160 --> 00:18:34,410
initializes the allocation after it's

00:18:31,020 --> 00:18:37,710
returned you can see pointer accesses

00:18:34,410 --> 00:18:39,840
are not pretty ads we use wrapping add

00:18:37,710 --> 00:18:41,640
to preserve C semantics so that's also

00:18:39,840 --> 00:18:45,360
not pretty and and there's a there's a

00:18:41,640 --> 00:18:48,120
few superfluous casts in there or not

00:18:45,360 --> 00:18:50,100
superfluous but ideally one wouldn't

00:18:48,120 --> 00:18:52,320
have that have them in idiomatic rust so

00:18:50,100 --> 00:18:54,600
here's here's something we rewrote by

00:18:52,320 --> 00:18:56,370
hand and you can see that it does the

00:18:54,600 --> 00:18:58,860
same thing it's much cleaner and more

00:18:56,370 --> 00:19:01,380
compact there's one little change which

00:18:58,860 --> 00:19:03,210
is that when we allocate on the heap

00:19:01,380 --> 00:19:06,860
with rust we get zero allocated memory

00:19:03,210 --> 00:19:08,910
so this is actually not a semantics

00:19:06,860 --> 00:19:11,520
preserving transformation and that's why

00:19:08,910 --> 00:19:14,540
we do refactoring separately so we can

00:19:11,520 --> 00:19:19,430
have a program approve these changes

00:19:14,540 --> 00:19:22,170
rather than just doing them silently so

00:19:19,430 --> 00:19:23,370
when we're doing manual refactoring I

00:19:22,170 --> 00:19:25,530
mentioned that there's there's the

00:19:23,370 --> 00:19:30,990
possibility for errors creeping in so we

00:19:25,530 --> 00:19:33,000
have a cross-checking tool to verify

00:19:30,990 --> 00:19:34,740
that your current rust version does

00:19:33,000 --> 00:19:37,410
something similar to the original C code

00:19:34,740 --> 00:19:39,390
to the extent you want to so what you

00:19:37,410 --> 00:19:41,610
gotta do is instrument the original C

00:19:39,390 --> 00:19:45,060
code and the translated rust code we

00:19:41,610 --> 00:19:47,220
provide plugins to do that I'll get to

00:19:45,060 --> 00:19:49,710
those in a second and once you have your

00:19:47,220 --> 00:19:51,090
instrumented C in rust code you run both

00:19:49,710 --> 00:19:54,150
of their programs and you feed them

00:19:51,090 --> 00:19:56,190
identical inputs such that you'd expect

00:19:54,150 --> 00:19:57,930
them to carry out the same computations

00:19:56,190 --> 00:20:00,810
and you can see an example here where we

00:19:57,930 --> 00:20:02,400
have a symbol ID function what we'll do

00:20:00,810 --> 00:20:04,110
is we'll cross check that the function

00:20:02,400 --> 00:20:06,180
names are the same and that argument

00:20:04,110 --> 00:20:10,200
values coming into the function are the

00:20:06,180 --> 00:20:12,120
same and we'll also also cross check

00:20:10,200 --> 00:20:14,220
that they return the same value so this

00:20:12,120 --> 00:20:15,180
is a very simple example it gets a

00:20:14,220 --> 00:20:19,050
little bit more here

00:20:15,180 --> 00:20:20,580
once the functions are non-trivial so

00:20:19,050 --> 00:20:22,980
you have two options for cross-checking

00:20:20,580 --> 00:20:25,650
one is to do the cross-checking online

00:20:22,980 --> 00:20:27,570
using something that's called an MBE

00:20:25,650 --> 00:20:29,340
I'll explain that in a second but for

00:20:27,570 --> 00:20:32,910
now just think of it as a way to execute

00:20:29,340 --> 00:20:34,920
two processes side by side and make sure

00:20:32,910 --> 00:20:37,230
that they get the same input so you want

00:20:34,920 --> 00:20:39,480
to do this because you don't have to do

00:20:37,230 --> 00:20:43,050
any logging and the NVE will replicate

00:20:39,480 --> 00:20:44,610
inputs to the two processes for you

00:20:43,050 --> 00:20:46,410
it does have some drawbacks in the area

00:20:44,610 --> 00:20:47,820
of compatibility you can can't take

00:20:46,410 --> 00:20:49,620
something as complex as a web browser

00:20:47,820 --> 00:20:52,440
and run two copies and cross checks and

00:20:49,620 --> 00:20:53,580
with an MBE for a variety of reasons

00:20:52,440 --> 00:20:56,820
that I'm not going to bore you with

00:20:53,580 --> 00:20:59,220
today so if if you can't use an MBE you

00:20:56,820 --> 00:21:02,070
have the option of doing cross offline

00:20:59,220 --> 00:21:04,560
checking where we log the program

00:21:02,070 --> 00:21:06,210
behavior to do log files and if you

00:21:04,560 --> 00:21:07,560
program small enough that's something

00:21:06,210 --> 00:21:10,080
you can do and you'll you avoid some of

00:21:07,560 --> 00:21:14,280
the compatibility issues of using MBEs

00:21:10,080 --> 00:21:17,730
so really quickly this is a fairly large

00:21:14,280 --> 00:21:19,770
research area but the idea is you have

00:21:17,730 --> 00:21:21,750
two variants of the same program so in

00:21:19,770 --> 00:21:23,250
our case it would be a C program on one

00:21:21,750 --> 00:21:25,530
side and the translate the Ross program

00:21:23,250 --> 00:21:28,080
on the other side and as soon as they

00:21:25,530 --> 00:21:29,820
make a system call we have a monitoring

00:21:28,080 --> 00:21:32,070
component that intercept system calls

00:21:29,820 --> 00:21:36,240
and forwards them to the kernel so you

00:21:32,070 --> 00:21:37,680
can see first we call a BRK to allocate

00:21:36,240 --> 00:21:39,270
memory and in that case we want to

00:21:37,680 --> 00:21:41,070
allocate memory for both processes so

00:21:39,270 --> 00:21:43,920
the money's were forwards both calls and

00:21:41,070 --> 00:21:46,080
then later we make a right to system

00:21:43,920 --> 00:21:47,610
call and in that case the monitor

00:21:46,080 --> 00:21:49,290
intercepts both calls but it only

00:21:47,610 --> 00:21:51,390
forwards one of them to the kernel and

00:21:49,290 --> 00:21:53,190
it waits for the results and then it

00:21:51,390 --> 00:21:57,390
sends the results back to both of the

00:21:53,190 --> 00:22:00,360
processes so essentially the monitor

00:21:57,390 --> 00:22:02,460
provides the surrounding host with

00:22:00,360 --> 00:22:04,080
illusion of one process running when in

00:22:02,460 --> 00:22:05,850
fact you have two processes running and

00:22:04,080 --> 00:22:08,550
doing the same thing receiving the same

00:22:05,850 --> 00:22:10,200
input and the monitor will also cross

00:22:08,550 --> 00:22:12,690
check that the two variants produce the

00:22:10,200 --> 00:22:14,700
same output so that's how we we can

00:22:12,690 --> 00:22:19,410
detect differences in the C code and the

00:22:14,700 --> 00:22:21,150
run rust code online without logging so

00:22:19,410 --> 00:22:22,710
as I said we have plugins to instrument

00:22:21,150 --> 00:22:24,510
the code we have different runtimes

00:22:22,710 --> 00:22:26,250
based on whether you use MV based or

00:22:24,510 --> 00:22:26,850
cross checking or log based

00:22:26,250 --> 00:22:28,650
cross-checking

00:22:26,850 --> 00:22:32,030
you have a zeroing matter

00:22:28,650 --> 00:22:35,490
replacement so in case we end up

00:22:32,030 --> 00:22:38,640
cross-checking data that that would be

00:22:35,490 --> 00:22:42,120
uninitialized than the seaside that that

00:22:38,640 --> 00:22:43,710
does not create any problem for us I'm

00:22:42,120 --> 00:22:46,020
gonna skip the last because we're

00:22:43,710 --> 00:22:48,810
running a little behind schedule so

00:22:46,020 --> 00:22:50,700
here's an example of cross-checking a

00:22:48,810 --> 00:22:53,790
very simple library that we just

00:22:50,700 --> 00:22:56,190
transpired we make it again we transpile

00:22:53,790 --> 00:22:58,680
it and this time we add two new flags to

00:22:56,190 --> 00:23:02,160
transpile we add dash X to enable cross

00:22:58,680 --> 00:23:04,230
checking and - you to select the log

00:23:02,160 --> 00:23:08,850
based cross checking and then we built

00:23:04,230 --> 00:23:11,610
it again and we point I said LD library

00:23:08,850 --> 00:23:14,460
path to point to our log based cross

00:23:11,610 --> 00:23:18,840
checking runtime and then I simply cargo

00:23:14,460 --> 00:23:22,470
run and output I log standard error to a

00:23:18,840 --> 00:23:24,630
file and then I I run the C program

00:23:22,470 --> 00:23:26,760
which has also been instrumented because

00:23:24,630 --> 00:23:29,340
I have a make file target called test

00:23:26,760 --> 00:23:31,530
underscore X check which passes the

00:23:29,340 --> 00:23:33,390
write plug-in parameters to claim such

00:23:31,530 --> 00:23:35,940
that the C code will be instrumented for

00:23:33,390 --> 00:23:38,910
cross-checking and again when it's run I

00:23:35,940 --> 00:23:41,490
lock the standard error output to two

00:23:38,910 --> 00:23:44,370
buffered CX checks and then I simply dip

00:23:41,490 --> 00:23:46,350
it to and and that returns zero so the

00:23:44,370 --> 00:23:48,170
they did the same thing which is lucky

00:23:46,350 --> 00:23:52,410
for this example

00:23:48,170 --> 00:23:54,660
so finally briefly we I mentioned that

00:23:52,410 --> 00:23:58,890
we also want to do refactoring this is

00:23:54,660 --> 00:24:00,450
the this is the least mature area for

00:23:58,890 --> 00:24:02,900
our work right now so I'm just gonna

00:24:00,450 --> 00:24:06,810
show you a simple example where you have

00:24:02,900 --> 00:24:09,660
some while loops that step from 0 to 9

00:24:06,810 --> 00:24:11,670
and it with a stride of 1 and 2 and and

00:24:09,660 --> 00:24:13,500
we have simple patterns that can

00:24:11,670 --> 00:24:19,800
recognize that this is better expressed

00:24:13,500 --> 00:24:22,170
as a for range loop in interest this is

00:24:19,800 --> 00:24:25,580
obviously fairly simple and and and and

00:24:22,170 --> 00:24:27,690
we hope that that will get to

00:24:25,580 --> 00:24:30,210
substantially more advanced refactoring

00:24:27,690 --> 00:24:32,970
across files and involving a substantial

00:24:30,210 --> 00:24:36,120
amounts of program analysis to do much

00:24:32,970 --> 00:24:37,560
more useful things so if we have a few

00:24:36,120 --> 00:24:39,660
minutes I'll just really briefly talk

00:24:37,560 --> 00:24:42,210
about pie in the sky stuff that we hope

00:24:39,660 --> 00:24:42,580
we'll be able to do so the main main

00:24:42,210 --> 00:24:44,620
feed

00:24:42,580 --> 00:24:46,210
we've gotten so far in our project is

00:24:44,620 --> 00:24:48,390
that it would be really nice if we could

00:24:46,210 --> 00:24:52,260
do something to generate safer rust

00:24:48,390 --> 00:24:55,960
right away or automate some of the tasks

00:24:52,260 --> 00:25:01,240
so 100% automation is is really really

00:24:55,960 --> 00:25:04,000
difficult so I I have this illustration

00:25:01,240 --> 00:25:06,930
here that shows that the arrows were

00:25:04,000 --> 00:25:09,940
sort of we're sort of moving on on rings

00:25:06,930 --> 00:25:11,470
in and without any kind of safety

00:25:09,940 --> 00:25:13,390
transformation we're just staying on the

00:25:11,470 --> 00:25:15,190
outer rings and what we want to do is we

00:25:13,390 --> 00:25:19,420
want to bend those rings so we go into a

00:25:15,190 --> 00:25:21,610
provably safe subset of rust and the

00:25:19,420 --> 00:25:24,820
challenges of doing so is that we have

00:25:21,610 --> 00:25:27,520
no an automated analysis has no domain

00:25:24,820 --> 00:25:29,440
knowledge that's really hard and then

00:25:27,520 --> 00:25:31,480
Russ has a substantially different type

00:25:29,440 --> 00:25:33,820
system so things like ownership gain are

00:25:31,480 --> 00:25:36,970
aware of simply propagating types around

00:25:33,820 --> 00:25:38,410
so a really quick example here is

00:25:36,970 --> 00:25:40,060
something Istanbul upon while just

00:25:38,410 --> 00:25:44,050
refactoring a very simple quicksort

00:25:40,060 --> 00:25:47,860
example the partition method function

00:25:44,050 --> 00:25:49,540
sorry calls swap and this is all done

00:25:47,860 --> 00:25:52,030
with raw pointer so there are no

00:25:49,540 --> 00:25:54,130
restrictions on how we can do this as

00:25:52,030 --> 00:25:56,890
opposed to whether if we use array

00:25:54,130 --> 00:26:00,670
slices so if I start using array slices

00:25:56,890 --> 00:26:02,260
in my partition and swap functions I get

00:26:00,670 --> 00:26:04,630
into a problem because I want to pass

00:26:02,260 --> 00:26:06,370
two mutable references to the swap

00:26:04,630 --> 00:26:08,110
function and that's not allowed on the

00:26:06,370 --> 00:26:11,440
rusts ownership rules and for good

00:26:08,110 --> 00:26:14,890
reason so that's that kind of a bummer

00:26:11,440 --> 00:26:18,610
for us so like any sane rust program

00:26:14,890 --> 00:26:20,920
would realize that the array slice type

00:26:18,610 --> 00:26:23,920
provides exactly what we need and one

00:26:20,920 --> 00:26:25,990
should simply use that and that allows

00:26:23,920 --> 00:26:29,050
us to get rid of this the C code hooray

00:26:25,990 --> 00:26:31,240
right that's awesome the problem is that

00:26:29,050 --> 00:26:33,730
that that we have no domain knowledge in

00:26:31,240 --> 00:26:37,000
in in in a mechanised analysis so we

00:26:33,730 --> 00:26:38,590
have to do something well I'm not sure

00:26:37,000 --> 00:26:41,260
what the best solution is but one thing

00:26:38,590 --> 00:26:44,170
I could imagine or be convinced that a

00:26:41,260 --> 00:26:46,780
mechanised analysis could do is is do

00:26:44,170 --> 00:26:49,510
some some some magic swapping where we

00:26:46,780 --> 00:26:52,150
basically take elements out of of the

00:26:49,510 --> 00:26:54,010
array and pass them to swap both mutable

00:26:52,150 --> 00:26:54,680
and then put them back into the array

00:26:54,010 --> 00:26:56,480
and

00:26:54,680 --> 00:27:00,380
that lets us do is actually preserve the

00:26:56,480 --> 00:27:02,240
swap function as as we have it so that's

00:27:00,380 --> 00:27:04,550
that's one way to get to say for us but

00:27:02,240 --> 00:27:06,500
it's pie-in-the-sky it's it's it's an

00:27:04,550 --> 00:27:08,750
open question if somebody has a really

00:27:06,500 --> 00:27:12,080
good idea in this area I'd love to hear

00:27:08,750 --> 00:27:14,410
about it and speaking of that we would

00:27:12,080 --> 00:27:16,640
love to work with anyone that has C code

00:27:14,410 --> 00:27:19,640
that they want to migrate to rest

00:27:16,640 --> 00:27:21,290
because we think the we really need to

00:27:19,640 --> 00:27:23,540
get some hints on porting experience to

00:27:21,290 --> 00:27:25,190
figure out where to go from here and we

00:27:23,540 --> 00:27:29,090
need to learn where to focus our effort

00:27:25,190 --> 00:27:34,370
so please get in touch if if this sounds

00:27:29,090 --> 00:27:36,440
like something you care about so this is

00:27:34,370 --> 00:27:38,240
the link to the demo website and this is

00:27:36,440 --> 00:27:40,730
the link to the source code please

00:27:38,240 --> 00:27:42,490
please go to our github and clone it and

00:27:40,730 --> 00:27:44,770
open issues if you run into problems

00:27:42,490 --> 00:27:55,279
thank you very much

00:27:44,770 --> 00:27:55,279
[Applause]

00:27:55,950 --> 00:28:03,620
[Music]

00:28:01,560 --> 00:28:03,620

YouTube URL: https://www.youtube.com/watch?v=WEsR0Vv7jhg


