Title: RustConf 2018 - Embedding Rust in C C++ by Katharina
Publication date: 2018-09-11
Playlist: RustConf 2018
Description: 
	RustConf 2018 - Embedding Rust in C/C++ by Katharina

We all know that using C/C++ code in Rust is not too complicated. extern "C", bindgen and build.rs scripts make this pretty easy. But letâ€™s challenge ourselves: what about the other way around? There are huge C and C++ projects that could use some corrosion.

In this talk I will not just show simple examples of how to use Rust modules inside larger C/C++ applications, the common pitfalls you will encounter, and to deal with them.
Captions: 
	00:00:00,410 --> 00:00:18,170
[Music]

00:00:14,800 --> 00:00:20,779
hi everyone thanks for coming by

00:00:18,170 --> 00:00:24,080
I'm gonna tell you the tale of two

00:00:20,779 --> 00:00:26,540
unlikely friends that are up there and

00:00:24,080 --> 00:00:28,820
they are very much in love I'm gonna

00:00:26,540 --> 00:00:31,820
talk about myself for a second here i my

00:00:28,820 --> 00:00:34,220
name is Katerina Faye I'm an active open

00:00:31,820 --> 00:00:36,140
source contributor I like tea a lot and

00:00:34,220 --> 00:00:40,699
sometimes I play around with embedded

00:00:36,140 --> 00:00:43,100
hardware I do some rust things who would

00:00:40,699 --> 00:00:45,500
have thought so I was a contributor to

00:00:43,100 --> 00:00:47,960
or I guess so I'm a contributor to the

00:00:45,500 --> 00:00:49,850
SEL i working group i write too many

00:00:47,960 --> 00:00:52,489
crates most of them are probably useless

00:00:49,850 --> 00:00:55,160
but i've met a few people here who told

00:00:52,489 --> 00:00:57,950
me that like one of them isn't so that's

00:00:55,160 --> 00:01:00,230
pretty cool and I'm a member of Berlin

00:00:57,950 --> 00:01:03,829
RS which is a an implementation group

00:01:00,230 --> 00:01:05,600
that's starting out to be so we we work

00:01:03,829 --> 00:01:08,660
on stuff together we organize workshops

00:01:05,600 --> 00:01:10,220
and little conferences for example a few

00:01:08,660 --> 00:01:15,110
weeks ago we had all mini cons about

00:01:10,220 --> 00:01:17,570
bind gen which was pretty fun so before

00:01:15,110 --> 00:01:19,670
I really started talking about this I

00:01:17,570 --> 00:01:27,500
want to answer this simple question

00:01:19,670 --> 00:01:29,780
why as in why would you do that so there

00:01:27,500 --> 00:01:31,610
are lots of I have people who tell me

00:01:29,780 --> 00:01:34,159
that if you have to reach for FFI your

00:01:31,610 --> 00:01:35,869
day has already basically gone wrong and

00:01:34,159 --> 00:01:38,540
I think that's very wrong I think

00:01:35,869 --> 00:01:40,640
there's very good reasons to use FFI

00:01:38,540 --> 00:01:42,500
between languages to make languages talk

00:01:40,640 --> 00:01:45,860
to each other and especially with rust

00:01:42,500 --> 00:01:47,030
and native code to embed rust into a

00:01:45,860 --> 00:01:49,700
said native code

00:01:47,030 --> 00:01:52,310
I could probably like this could be its

00:01:49,700 --> 00:01:56,270
own talk so I'm just gonna list like a

00:01:52,310 --> 00:01:58,009
few up there and if you find yourself in

00:01:56,270 --> 00:01:59,720
the situation where you where you want

00:01:58,009 --> 00:02:03,320
to grab like where you want to reach for

00:01:59,720 --> 00:02:05,840
an FFA interaction between C or C++ and

00:02:03,320 --> 00:02:08,030
rust just know that it's a valid thing

00:02:05,840 --> 00:02:12,200
to do even though there's people on the

00:02:08,030 --> 00:02:14,120
internet who will tell you otherwise but

00:02:12,200 --> 00:02:17,170
I realize that that's not really the

00:02:14,120 --> 00:02:20,600
only the only meaning of the word why

00:02:17,170 --> 00:02:22,310
it's also why give this talk so about

00:02:20,600 --> 00:02:23,850
six months ago I was working on a

00:02:22,310 --> 00:02:27,150
project and I wanted to

00:02:23,850 --> 00:02:29,070
do exactly this and I encountered a lot

00:02:27,150 --> 00:02:32,910
of roadblocks and a lot of stumbled a

00:02:29,070 --> 00:02:38,370
lot and Russ promises to be efficient in

00:02:32,910 --> 00:02:40,350
its bindings and I mean I know what the

00:02:38,370 --> 00:02:43,770
people who wrote the website wrote meant

00:02:40,350 --> 00:02:45,840
with efficient but when I have to do a

00:02:43,770 --> 00:02:47,820
lot of research and there's not a lot of

00:02:45,840 --> 00:02:50,010
documentation about it and basically all

00:02:47,820 --> 00:02:52,500
the knowledge that I get for this is

00:02:50,010 --> 00:02:55,830
from blog post I wouldn't exactly call

00:02:52,500 --> 00:02:58,410
that workflow efficient so my hope was

00:02:55,830 --> 00:03:00,390
to engage people a bit more in

00:02:58,410 --> 00:03:03,060
documenting things and experimenting

00:03:00,390 --> 00:03:05,850
with things and building tools that are

00:03:03,060 --> 00:03:07,500
more publicized than what already exists

00:03:05,850 --> 00:03:13,110
where everyone basically has to reinvent

00:03:07,500 --> 00:03:14,790
the wheel so the second thing I want to

00:03:13,110 --> 00:03:17,010
get out the way before we really get

00:03:14,790 --> 00:03:19,560
started is I want to talk about abis

00:03:17,010 --> 00:03:21,720
because a lot of people don't know this

00:03:19,560 --> 00:03:25,920
ABI stands for application binary

00:03:21,720 --> 00:03:27,660
interface and it's it's basically like

00:03:25,920 --> 00:03:29,310
an API but for your linker or your

00:03:27,660 --> 00:03:31,860
compiler it's not something that humans

00:03:29,310 --> 00:03:34,470
would ever interact with it specifies

00:03:31,860 --> 00:03:36,450
how a function looks at memory it

00:03:34,470 --> 00:03:41,040
specifies the way that data is laid out

00:03:36,450 --> 00:03:42,810
in memory and depending on the ABI you

00:03:41,040 --> 00:03:44,700
can make certain pieces of code talk to

00:03:42,810 --> 00:03:50,310
each other whereas if the ABI is wrong

00:03:44,700 --> 00:03:53,700
it won't link and it won't compile in

00:03:50,310 --> 00:03:55,200
rust we use the external keyword - so

00:03:53,700 --> 00:03:57,840
this is a rusty talk after all you will

00:03:55,200 --> 00:04:00,570
sometimes forget in rust we'll use the

00:03:57,840 --> 00:04:02,640
extra and keyword followed by a string -

00:04:00,570 --> 00:04:05,400
to specify the ABI that we're using for

00:04:02,640 --> 00:04:09,210
example external c4 structures and enums

00:04:05,400 --> 00:04:10,980
we need to use the repressive macro to

00:04:09,210 --> 00:04:15,060
tell the compiler that we wanted to look

00:04:10,980 --> 00:04:16,859
like there see variants now you might

00:04:15,060 --> 00:04:19,020
have noticed that's a that's a string up

00:04:16,859 --> 00:04:20,580
there can there there's other stuff that

00:04:19,020 --> 00:04:22,440
you can put in there by default it says

00:04:20,580 --> 00:04:24,390
external rust you can put that in your

00:04:22,440 --> 00:04:26,370
code it'll not change anything you'll

00:04:24,390 --> 00:04:28,710
have made your course code worse to read

00:04:26,370 --> 00:04:31,110
but it's not gonna make a difference

00:04:28,710 --> 00:04:33,180
there is a lot of different abis that

00:04:31,110 --> 00:04:35,370
you can target most of them are platform

00:04:33,180 --> 00:04:36,630
specific and usually you will just use

00:04:35,370 --> 00:04:38,370
externally unless

00:04:36,630 --> 00:04:42,390
doing something super funky at which

00:04:38,370 --> 00:04:44,550
point my hats off and good luck rest

00:04:42,390 --> 00:04:47,730
doesn't have a stable ABI in so when

00:04:44,550 --> 00:04:50,010
rust was made stable in 2015 that was a

00:04:47,730 --> 00:04:52,290
promise that code that you wrote one day

00:04:50,010 --> 00:04:55,050
would still work the other and that

00:04:52,290 --> 00:04:56,820
promise extends pretty much to the

00:04:55,050 --> 00:04:59,100
language itself so the the syntactic

00:04:56,820 --> 00:05:02,040
features and the standard library it

00:04:59,100 --> 00:05:05,970
does not however extend to the ABI there

00:05:02,040 --> 00:05:08,310
is this issue by Steve open number 600

00:05:05,970 --> 00:05:12,330
there's that Russ might want to define

00:05:08,310 --> 00:05:15,510
an API at some point because this is

00:05:12,330 --> 00:05:18,450
also talked about C++ there isn't one

00:05:15,510 --> 00:05:20,100
standardized C++ ABI it always very much

00:05:18,450 --> 00:05:23,190
depends on the compiler that you're

00:05:20,100 --> 00:05:25,470
using and a lot of different things this

00:05:23,190 --> 00:05:27,900
could be another 30 minute to talk so

00:05:25,470 --> 00:05:29,310
I'm just going to gloss over this there

00:05:27,900 --> 00:05:32,850
are certain things that are standardized

00:05:29,310 --> 00:05:37,020
but most of them aren't so when we deal

00:05:32,850 --> 00:05:39,150
when we talk about the C ABI there is no

00:05:37,020 --> 00:05:41,850
such thing as a C avi because she never

00:05:39,150 --> 00:05:44,250
standardized or specified in avi what we

00:05:41,850 --> 00:05:46,170
mean instead is whatever platform that

00:05:44,250 --> 00:05:49,740
we're building on and that is and

00:05:46,170 --> 00:05:53,340
hopefully stable so yeah a little

00:05:49,740 --> 00:05:55,740
background on that so let's get into

00:05:53,340 --> 00:05:57,570
some FFA and I want to do it the other

00:05:55,740 --> 00:05:59,490
way around then this talk is advertising

00:05:57,570 --> 00:06:01,380
first because I think it's it

00:05:59,490 --> 00:06:03,120
demonstrates a lot of the same

00:06:01,380 --> 00:06:05,850
principles and it's a lot better

00:06:03,120 --> 00:06:09,060
documented that's why I'm usually called

00:06:05,850 --> 00:06:10,830
a boring FFA there is an entire chapter

00:06:09,060 --> 00:06:13,560
or like a section and the rest book

00:06:10,830 --> 00:06:15,870
about it there's a lot of blog post and

00:06:13,560 --> 00:06:17,580
just generally if you want to do this

00:06:15,870 --> 00:06:21,000
route there's great tooling and

00:06:17,580 --> 00:06:23,880
generally people know how to do it so

00:06:21,000 --> 00:06:26,550
the way you go about using C code with

00:06:23,880 --> 00:06:28,350
rust is by using external functions that

00:06:26,550 --> 00:06:30,660
are declared has the ABI that you want

00:06:28,350 --> 00:06:32,100
to use you need to wrap those function

00:06:30,660 --> 00:06:33,720
calls and unsafe because the compiler

00:06:32,100 --> 00:06:36,510
can verify that they will actually be

00:06:33,720 --> 00:06:38,940
there when you run and you may have to

00:06:36,510 --> 00:06:41,130
make data compatible in a way that C can

00:06:38,940 --> 00:06:43,860
understand because rust is smarter than

00:06:41,130 --> 00:06:47,400
C in this aspect the work falls onto you

00:06:43,860 --> 00:06:49,480
with a bunch of stuff so this would be

00:06:47,400 --> 00:06:51,370
an example we have

00:06:49,480 --> 00:06:53,920
function called reverse and it takes a

00:06:51,370 --> 00:06:58,330
string and returns a string or sorry a

00:06:53,920 --> 00:07:00,760
constant character array we call this

00:06:58,330 --> 00:07:05,530
function in an unsafe block and you can

00:07:00,760 --> 00:07:07,390
see we here we use the cstr type to

00:07:05,530 --> 00:07:10,480
transform our string slice into

00:07:07,390 --> 00:07:12,520
something that C can then understand in

00:07:10,480 --> 00:07:13,630
the reverse like I've left the the

00:07:12,520 --> 00:07:14,710
reverse you would have to do the same

00:07:13,630 --> 00:07:18,690
thing I won't didn't want to make the

00:07:14,710 --> 00:07:22,450
code example unnecessarily complicated

00:07:18,690 --> 00:07:24,940
so there's two type there's two modules

00:07:22,450 --> 00:07:27,850
and the the standard library one is OS

00:07:24,940 --> 00:07:30,130
raw and FFI and both of them deal with

00:07:27,850 --> 00:07:33,580
transmute like transforming data into a

00:07:30,130 --> 00:07:36,750
form that C will understand OS raw our

00:07:33,580 --> 00:07:39,310
primitives whereas FFI are things like

00:07:36,750 --> 00:07:43,200
string that becomes a C string it's an

00:07:39,310 --> 00:07:46,090
owned allocated string there is STR

00:07:43,200 --> 00:07:48,910
becomes CSTR which is just a string

00:07:46,090 --> 00:07:51,220
slice and and then there is lots of

00:07:48,910 --> 00:07:53,020
primitives so void and c becomes c void

00:07:51,220 --> 00:07:54,970
and etc i'm not going to go through all

00:07:53,020 --> 00:07:57,250
of them when the documentation of this

00:07:54,970 --> 00:07:58,600
is really great there's good examples in

00:07:57,250 --> 00:08:02,100
the standard library so this is usually

00:07:58,600 --> 00:08:06,520
not an issue how to like transform data

00:08:02,100 --> 00:08:08,050
okay so let's turn this around and let's

00:08:06,520 --> 00:08:10,480
let's look at what you actually have to

00:08:08,050 --> 00:08:12,730
do to call some rust code from C we use

00:08:10,480 --> 00:08:16,780
the same mechanism with the externship

00:08:12,730 --> 00:08:17,950
as previously except with a little

00:08:16,780 --> 00:08:21,010
difference which you'll see in a second

00:08:17,950 --> 00:08:23,470
you have to take data in a C form so

00:08:21,010 --> 00:08:25,390
whatever data C provides you then have

00:08:23,470 --> 00:08:28,570
to make rust compatible not the other

00:08:25,390 --> 00:08:30,070
way around but there's also a thing you

00:08:28,570 --> 00:08:32,440
have to declare your functions as no

00:08:30,070 --> 00:08:35,590
mangle because the rust compiler mangles

00:08:32,440 --> 00:08:39,700
function names differently than a say

00:08:35,590 --> 00:08:41,410
GCC would expect and as such you need to

00:08:39,700 --> 00:08:44,440
declare them as no mangle so that the

00:08:41,410 --> 00:08:46,120
the c compiler that then links you and

00:08:44,440 --> 00:08:49,330
your application can actually find your

00:08:46,120 --> 00:08:51,130
functions usually if you have function

00:08:49,330 --> 00:08:53,860
errors it's probably because you forgot

00:08:51,130 --> 00:08:57,700
my angle it's because I forgot my mango

00:08:53,860 --> 00:08:59,500
at least so this would be an example we

00:08:57,700 --> 00:09:01,720
so it's a function called reverse it

00:08:59,500 --> 00:09:03,280
takes a string returns a string it's no

00:09:01,720 --> 00:09:04,690
mango it's ex turns

00:09:03,280 --> 00:09:06,700
the implementation isn't really

00:09:04,690 --> 00:09:09,550
important right now I wanted to do an

00:09:06,700 --> 00:09:11,320
example where safely like reverse

00:09:09,550 --> 00:09:13,090
unicode and there's a great credit for

00:09:11,320 --> 00:09:14,500
that but the example ended up being like

00:09:13,090 --> 00:09:18,220
half my slide and I just took it out

00:09:14,500 --> 00:09:21,100
because it's really not relevant at this

00:09:18,220 --> 00:09:24,040
point you will need a few more fields in

00:09:21,100 --> 00:09:27,550
your cargo towel so there is the lip

00:09:24,040 --> 00:09:29,710
section which I don't usually use unless

00:09:27,550 --> 00:09:31,810
I'm doing this sort of stuff you can

00:09:29,710 --> 00:09:33,220
give it a different name if you want it

00:09:31,810 --> 00:09:35,020
to be different from your normal trade

00:09:33,220 --> 00:09:38,350
name and you also have to provide a

00:09:35,020 --> 00:09:41,110
crate type cdy lib will generate a

00:09:38,350 --> 00:09:42,790
shared object file where as static clip

00:09:41,110 --> 00:09:46,810
will create a statically compiled

00:09:42,790 --> 00:09:48,040
library as the name might suggest but

00:09:46,810 --> 00:09:50,680
something to keep in mind at this point

00:09:48,040 --> 00:09:54,940
is that cargo does not own your project

00:09:50,680 --> 00:09:56,650
so cargo will build your rest code but

00:09:54,940 --> 00:09:59,920
it's not in charge of your actual

00:09:56,650 --> 00:10:03,250
application that falls to whatever build

00:09:59,920 --> 00:10:04,600
system you're using with C or C++ I had

00:10:03,250 --> 00:10:07,480
a wonderful conversation over lunch

00:10:04,600 --> 00:10:12,820
about how wonderful the situation with

00:10:07,480 --> 00:10:17,230
C++ build systems are so whatever

00:10:12,820 --> 00:10:19,720
whatever you'll use in that regards will

00:10:17,230 --> 00:10:24,250
have to understand how to link in a

00:10:19,720 --> 00:10:25,840
library that is generated by cargo one

00:10:24,250 --> 00:10:27,850
thing so in this example here I'm using

00:10:25,840 --> 00:10:29,680
C make all of this code will be online

00:10:27,850 --> 00:10:31,960
after like the conference so that you

00:10:29,680 --> 00:10:35,890
can go through it one thing of note is

00:10:31,960 --> 00:10:37,750
the reverse or dot H header in which we

00:10:35,890 --> 00:10:41,890
declare a function which you might

00:10:37,750 --> 00:10:44,260
recognize so basically every function

00:10:41,890 --> 00:10:46,840
that you're rust API exposes needs to

00:10:44,260 --> 00:10:49,860
then again be declared in AC header so

00:10:46,840 --> 00:10:53,560
that your C code can actually use it

00:10:49,860 --> 00:10:57,000
okay so so far so good calling this from

00:10:53,560 --> 00:10:59,590
C is then actually pretty simple we

00:10:57,000 --> 00:11:02,500
include the Reverso header we generate

00:10:59,590 --> 00:11:04,870
it like we use a Unicode a very Unicode

00:11:02,500 --> 00:11:07,660
greeting and then we call our arrest

00:11:04,870 --> 00:11:10,840
code that will reverse this this for us

00:11:07,660 --> 00:11:12,640
and when we call it we get that out

00:11:10,840 --> 00:11:14,650
funnily enough the crater was using

00:11:12,640 --> 00:11:16,209
couldn't deal properly with all of the

00:11:14,650 --> 00:11:19,119
composite emojis so

00:11:16,209 --> 00:11:20,889
um yeah it reversed them individually

00:11:19,119 --> 00:11:25,990
which means computer a woman is not the

00:11:20,889 --> 00:11:28,329
same as computer woman so that's pretty

00:11:25,990 --> 00:11:35,139
much it then everything works like share

00:11:28,329 --> 00:11:37,660
and subscribe ok not quite so I see some

00:11:35,139 --> 00:11:39,429
problems here the first one is that I'm

00:11:37,660 --> 00:11:41,439
notoriously lazy and I don't wanna write

00:11:39,429 --> 00:11:44,589
headers and not just because I'm lazy

00:11:41,439 --> 00:11:46,240
but because if you have a header in your

00:11:44,589 --> 00:11:47,769
repo and it's out of date from your

00:11:46,240 --> 00:11:48,850
library and then you get weird linking

00:11:47,769 --> 00:11:50,499
errors and you don't know what's going

00:11:48,850 --> 00:11:51,939
on and then you find out that there's

00:11:50,499 --> 00:11:54,279
like a merge conflict from three weeks

00:11:51,939 --> 00:11:56,559
ago because someone like push the button

00:11:54,279 --> 00:11:58,209
too quickly or github and that's why

00:11:56,559 --> 00:12:01,209
your application doesn't build that's

00:11:58,209 --> 00:12:03,610
not really cool the the other thing is

00:12:01,209 --> 00:12:05,499
this was a very optimistic function it

00:12:03,610 --> 00:12:09,309
returns a string what could possibly go

00:12:05,499 --> 00:12:13,119
wrong so maybe we might want to fix that

00:12:09,309 --> 00:12:14,709
and the thing is rusts makes it very

00:12:13,119 --> 00:12:18,449
easy for you to forget about memory

00:12:14,709 --> 00:12:21,249
management so how does that happen and

00:12:18,449 --> 00:12:23,769
the last point is less of a problem it's

00:12:21,249 --> 00:12:25,540
more of a philosophy I guess I want to

00:12:23,769 --> 00:12:28,660
talk about what even makes a pretty API

00:12:25,540 --> 00:12:30,490
because this isn't just about making

00:12:28,660 --> 00:12:33,069
rusts to talk to see you can make

00:12:30,490 --> 00:12:35,410
anything talk to anything this is about

00:12:33,069 --> 00:12:39,490
efficiently talking to C which means

00:12:35,410 --> 00:12:42,910
making it pretty so let's start with the

00:12:39,490 --> 00:12:45,100
easiest thing first time this could be

00:12:42,910 --> 00:12:47,019
another 30 minute talk I think you're

00:12:45,100 --> 00:12:50,110
seeing a pattern here it's a lot of

00:12:47,019 --> 00:12:53,199
stuff so there's this project called sea

00:12:50,110 --> 00:12:55,649
pines gem which is pretty awesome it's

00:12:53,199 --> 00:12:58,990
basically like bind gen but in Reverse

00:12:55,649 --> 00:13:01,209
so you pointed at a crate and then it'll

00:12:58,990 --> 00:13:04,389
generate header files for you you can

00:13:01,209 --> 00:13:07,360
either do this in your build RS in rust

00:13:04,389 --> 00:13:08,829
code or it provides a CLI that you can

00:13:07,360 --> 00:13:15,040
then invoke in your favorite build

00:13:08,829 --> 00:13:16,629
system which you probably have yeah so

00:13:15,040 --> 00:13:20,069
when it comes to actual build system

00:13:16,629 --> 00:13:22,779
support you have to do a lot of work so

00:13:20,069 --> 00:13:25,209
usually I find that writing a few bash

00:13:22,779 --> 00:13:27,220
scripts that hook into some make file or

00:13:25,209 --> 00:13:28,440
something is usually the easiest to deal

00:13:27,220 --> 00:13:31,080
with

00:13:28,440 --> 00:13:32,700
like invoking cargo building it than

00:13:31,080 --> 00:13:34,440
taking the library from the target

00:13:32,700 --> 00:13:35,910
directory putting it somewhere that your

00:13:34,440 --> 00:13:37,200
build system will understand and then

00:13:35,910 --> 00:13:40,740
letting the build system do the rest

00:13:37,200 --> 00:13:43,350
like it would normally do but this isn't

00:13:40,740 --> 00:13:47,220
like this isn't a thing way you can just

00:13:43,350 --> 00:13:47,940
go somewhere and look it up it's figure

00:13:47,220 --> 00:13:51,870
it out yourself

00:13:47,940 --> 00:13:53,970
which isn't very nice so let's talk a

00:13:51,870 --> 00:13:56,100
little bit about memory management the

00:13:53,970 --> 00:14:00,300
thing that rust doesn't really need you

00:13:56,100 --> 00:14:02,460
to handle so by a default when you

00:14:00,300 --> 00:14:05,970
create an object and rust it creates it

00:14:02,460 --> 00:14:09,420
on the stack which is really convenient

00:14:05,970 --> 00:14:12,120
I guess if if you don't need it to be on

00:14:09,420 --> 00:14:13,710
the heap and in most situations this is

00:14:12,120 --> 00:14:14,880
fine there are situations where you

00:14:13,710 --> 00:14:17,310
might want it to be on the heap and then

00:14:14,880 --> 00:14:20,760
you make that explicit and especially

00:14:17,310 --> 00:14:22,650
when we talk to some other piece of code

00:14:20,760 --> 00:14:25,800
where we have no idea what it's doing

00:14:22,650 --> 00:14:27,960
what it's doing to the stack it's not a

00:14:25,800 --> 00:14:30,630
great idea to use the stack as permanent

00:14:27,960 --> 00:14:34,140
data storage so put your troubles in a

00:14:30,630 --> 00:14:37,200
box the box is a heap allocated pointer

00:14:34,140 --> 00:14:39,600
in the standard library and whatever

00:14:37,200 --> 00:14:44,040
thing you put inside of it will then be

00:14:39,600 --> 00:14:46,920
on the heap and you this code up there

00:14:44,040 --> 00:14:50,340
the extra and see the box thing what

00:14:46,920 --> 00:14:52,620
that does is return a pointer to

00:14:50,340 --> 00:14:54,060
whatever you put into memory and the

00:14:52,620 --> 00:14:56,520
thing is we declared our structures

00:14:54,060 --> 00:14:58,050
repres I which means that C will be able

00:14:56,520 --> 00:15:01,500
to follow that pointer and then do

00:14:58,050 --> 00:15:06,030
something with it the other thing is

00:15:01,500 --> 00:15:08,130
that boxes retain type information where

00:15:06,030 --> 00:15:11,670
they store the data which means that you

00:15:08,130 --> 00:15:14,430
can also get the data back so you can if

00:15:11,670 --> 00:15:16,050
you have some piece of code say PTR and

00:15:14,430 --> 00:15:17,850
I just realized that code example is

00:15:16,050 --> 00:15:23,700
wrong it should be PTR that you

00:15:17,850 --> 00:15:26,400
dereference not CTX so whoops you get a

00:15:23,700 --> 00:15:28,170
C void which can be literally anything

00:15:26,400 --> 00:15:30,660
and then in an unsafe block you

00:15:28,170 --> 00:15:33,839
essentially cast that to be a mutable

00:15:30,660 --> 00:15:36,060
reference to my thing because you can

00:15:33,839 --> 00:15:37,560
follow the pointer to wherever the thing

00:15:36,060 --> 00:15:39,990
is a memory and then you can use that

00:15:37,560 --> 00:15:42,210
and then you can in your rust code that

00:15:39,990 --> 00:15:45,450
follows safely access all of your stuff

00:15:42,210 --> 00:15:49,740
without having to worry about something

00:15:45,450 --> 00:15:52,260
going wrong this is what this looks like

00:15:49,740 --> 00:15:54,090
from the seaside so basically yes the

00:15:52,260 --> 00:15:57,930
mixing function just returns a pointer

00:15:54,090 --> 00:15:59,340
the my thing pointer is then on the on

00:15:57,930 --> 00:16:01,710
the stack and we can deal with this

00:15:59,340 --> 00:16:03,360
something to remember though is that you

00:16:01,710 --> 00:16:07,500
can't make your application memory safe

00:16:03,360 --> 00:16:10,350
so the rusts guarantee ends at when you

00:16:07,500 --> 00:16:12,540
return back into c code which means that

00:16:10,350 --> 00:16:15,300
you should not make any assumptions

00:16:12,540 --> 00:16:17,370
about persistence of data it might be

00:16:15,300 --> 00:16:19,260
gone something might write over it or it

00:16:17,370 --> 00:16:21,480
might just die before you can do

00:16:19,260 --> 00:16:23,580
anything with it so always be prepared

00:16:21,480 --> 00:16:25,680
when you build these api's for them to

00:16:23,580 --> 00:16:28,400
have a certain amount of hardening

00:16:25,680 --> 00:16:31,320
against C code doing something stupid

00:16:28,400 --> 00:16:32,970
even if it's like unintentional or a bug

00:16:31,320 --> 00:16:36,750
it's something that you have to deal

00:16:32,970 --> 00:16:40,050
with speaking of things exploding in

00:16:36,750 --> 00:16:43,500
your face let's talk about errors so

00:16:40,050 --> 00:16:45,990
errors and and generally reporting if

00:16:43,500 --> 00:16:48,960
and when things go wrong and C are a

00:16:45,990 --> 00:16:52,740
little weird so in rust we have these

00:16:48,960 --> 00:16:55,920
amazing types result in option that let

00:16:52,740 --> 00:16:58,770
you return something from a function and

00:16:55,920 --> 00:17:01,050
it contains some type information or

00:16:58,770 --> 00:17:02,990
some state information about what state

00:17:01,050 --> 00:17:05,490
it is in the result

00:17:02,990 --> 00:17:07,830
realistically communicates the state if

00:17:05,490 --> 00:17:10,920
it's okay or an error and the option

00:17:07,830 --> 00:17:13,020
just communicates of its existent and

00:17:10,920 --> 00:17:14,580
that is super convenient because you can

00:17:13,020 --> 00:17:16,800
just return something from a function

00:17:14,580 --> 00:17:20,400
and it's I don't have to explain this to

00:17:16,800 --> 00:17:22,709
you you probably know this well this is

00:17:20,400 --> 00:17:25,290
something that you can do in C but

00:17:22,709 --> 00:17:27,720
before I go there I want to talk about

00:17:25,290 --> 00:17:30,630
something because this talk is called C

00:17:27,720 --> 00:17:33,900
and C++ and I've really only talked

00:17:30,630 --> 00:17:37,070
about C so far we have to split this up

00:17:33,900 --> 00:17:40,710
in errors and C and errors in C++

00:17:37,070 --> 00:17:43,170
because errors in C are something that

00:17:40,710 --> 00:17:45,000
we can deal with we have a binding to C

00:17:43,170 --> 00:17:47,430
code and we can deal with interacting

00:17:45,000 --> 00:17:51,960
with C code errors in C++ are either

00:17:47,430 --> 00:17:54,990
exceptions or some class that uses a

00:17:51,960 --> 00:17:55,650
template to like essentially be the same

00:17:54,990 --> 00:17:57,750
thing as a

00:17:55,650 --> 00:17:59,789
just in C++ and that's not something

00:17:57,750 --> 00:18:01,169
that we can really easily interact with

00:17:59,789 --> 00:18:02,730
and even if you could it would be very

00:18:01,169 --> 00:18:04,169
dependent on your compiler version and

00:18:02,730 --> 00:18:08,340
it's not something that you ever want to

00:18:04,169 --> 00:18:10,260
touch so whenever we we talk about

00:18:08,340 --> 00:18:12,240
errors and whenever we talk about

00:18:10,260 --> 00:18:15,330
building pretty API is you have to keep

00:18:12,240 --> 00:18:18,299
in mind that you build a layer to see

00:18:15,330 --> 00:18:20,520
from roster to see and then your C++

00:18:18,299 --> 00:18:23,340
code if you have it we'll have to use

00:18:20,520 --> 00:18:25,830
that C code just the same way like

00:18:23,340 --> 00:18:29,010
externally as your rest code would so

00:18:25,830 --> 00:18:30,659
you basically have two parts that sort

00:18:29,010 --> 00:18:32,490
of communicate via a common ground that

00:18:30,659 --> 00:18:37,020
they both don't really like but they

00:18:32,490 --> 00:18:40,620
just put up with it so this is something

00:18:37,020 --> 00:18:44,730
that we can do we we can emulate a

00:18:40,620 --> 00:18:47,610
result in C so this is a rust struct

00:18:44,730 --> 00:18:49,500
obviously and what we can do is we we

00:18:47,610 --> 00:18:51,960
have some struct over a generic T we

00:18:49,500 --> 00:18:54,179
have a box in there so that C doesn't

00:18:51,960 --> 00:18:56,880
have to understand how big this is

00:18:54,179 --> 00:18:59,970
because in the end for us it's just a

00:18:56,880 --> 00:19:01,679
void pointer and we can mark that field

00:18:59,970 --> 00:19:04,500
as ignore me or like hide it or

00:19:01,679 --> 00:19:06,270
something as long as the structure knows

00:19:04,500 --> 00:19:08,220
that there is a pointer in there that

00:19:06,270 --> 00:19:12,620
points to something it doesn't have to

00:19:08,220 --> 00:19:15,059
care so this way you can deal with

00:19:12,620 --> 00:19:17,700
returning rust objects that you might

00:19:15,059 --> 00:19:19,980
want to give to other rust functions but

00:19:17,700 --> 00:19:22,080
C doesn't have to deal with while also

00:19:19,980 --> 00:19:26,640
returning an error code that when it's

00:19:22,080 --> 00:19:29,820
convenient and this is what this would

00:19:26,640 --> 00:19:31,649
be used then so we call some function

00:19:29,820 --> 00:19:35,580
this is C code we call some function

00:19:31,649 --> 00:19:40,140
called my function and the return value

00:19:35,580 --> 00:19:41,850
is this wonderful result type and after

00:19:40,140 --> 00:19:45,750
the function was called we can just call

00:19:41,850 --> 00:19:47,549
code and if if that's a if that doesn't

00:19:45,750 --> 00:19:52,919
trigger and we don't have to deal with

00:19:47,549 --> 00:19:55,559
an error it's a valid thing there's

00:19:52,919 --> 00:19:59,100
another pattern in a lot of C libraries

00:19:55,559 --> 00:20:01,740
and I've been trying to look at how it

00:19:59,100 --> 00:20:03,809
evolved over time it seems to have like

00:20:01,740 --> 00:20:05,490
a lot of older libraries use this but a

00:20:03,809 --> 00:20:07,020
lot of humans as well so it's not really

00:20:05,490 --> 00:20:07,779
sure like I'm not super sure about a

00:20:07,020 --> 00:20:10,239
trend

00:20:07,779 --> 00:20:11,919
that used double pointers and so as a

00:20:10,239 --> 00:20:14,019
little bit of a refresher I guess

00:20:11,919 --> 00:20:15,969
because rust developers usually don't

00:20:14,019 --> 00:20:19,299
deal with pointers directly because we

00:20:15,969 --> 00:20:21,789
don't have to the idea behind this is

00:20:19,299 --> 00:20:24,429
that you provide the pointer to a

00:20:21,789 --> 00:20:26,799
pointer to something and then by

00:20:24,429 --> 00:20:29,710
dereferencing one of them you gain

00:20:26,799 --> 00:20:31,269
access to the other in this case we have

00:20:29,710 --> 00:20:35,529
a variable which is a pointer on the

00:20:31,269 --> 00:20:37,450
stack and we give a function a pointer

00:20:35,529 --> 00:20:39,429
through this pointer on the stack at

00:20:37,450 --> 00:20:41,559
which point in the function we can

00:20:39,429 --> 00:20:44,219
dereference the first pointer and right

00:20:41,559 --> 00:20:47,889
onto the stack outside of our function

00:20:44,219 --> 00:20:52,419
this is a pattern that you can use and C

00:20:47,889 --> 00:20:54,460
to do error reporting by always

00:20:52,419 --> 00:20:56,289
returning an integer from your function

00:20:54,460 --> 00:20:57,669
you have the ability to communicate if

00:20:56,289 --> 00:21:00,249
something goes wrong if it returns a

00:20:57,669 --> 00:21:02,169
zero it's fine and happy or it can

00:21:00,249 --> 00:21:06,249
return some error code or an enum or

00:21:02,169 --> 00:21:09,269
whatever while handling data return

00:21:06,249 --> 00:21:11,529
types with double pointers where you

00:21:09,269 --> 00:21:13,690
make some field on the stack so we have

00:21:11,529 --> 00:21:15,159
this function called get client and we

00:21:13,690 --> 00:21:17,139
have a client pointer on the stack and

00:21:15,159 --> 00:21:19,690
then we give a pointer to this pointer

00:21:17,139 --> 00:21:21,339
to the get client function at which

00:21:19,690 --> 00:21:24,369
point it'll fill it in and if there is

00:21:21,339 --> 00:21:27,059
no error the client variable will then

00:21:24,369 --> 00:21:29,139
contain the pointer to a valid client

00:21:27,059 --> 00:21:31,509
you can do the same thing for

00:21:29,139 --> 00:21:33,339
initializations you can also provide

00:21:31,509 --> 00:21:36,249
parameters obviously that are have

00:21:33,339 --> 00:21:40,690
nothing to do with any sort of return

00:21:36,249 --> 00:21:44,529
value and just yeah this is the same

00:21:40,690 --> 00:21:48,969
pattern essentially so from rust this is

00:21:44,529 --> 00:21:50,409
super organ ami to use basically what

00:21:48,969 --> 00:21:51,909
you're getting so let's take the

00:21:50,409 --> 00:21:55,539
initialize function where we have a

00:21:51,909 --> 00:21:59,009
pointer to a pointer and a port we get

00:21:55,539 --> 00:22:02,259
in a star star star mu star mute C void

00:21:59,009 --> 00:22:03,759
and a port we you can check if the port

00:22:02,259 --> 00:22:06,969
is valid and then returned like an error

00:22:03,759 --> 00:22:12,219
if you want to allocate like port -1 or

00:22:06,969 --> 00:22:14,200
something and then what we do is we

00:22:12,219 --> 00:22:15,849
generate like we create a new server in

00:22:14,200 --> 00:22:18,339
rust we put it on the heap with a box

00:22:15,849 --> 00:22:20,750
and then we use the box into raw

00:22:18,339 --> 00:22:23,510
function what that does is

00:22:20,750 --> 00:22:26,810
it destroys the box and turns it into a

00:22:23,510 --> 00:22:30,260
raw pointer so rust does have pointers

00:22:26,810 --> 00:22:32,570
they're just unsafe and so whenever you

00:22:30,260 --> 00:22:34,430
want to deal with an actual raw pointers

00:22:32,570 --> 00:22:37,130
or something when you can seriously

00:22:34,430 --> 00:22:40,130
shoot yourself in the foot you have to

00:22:37,130 --> 00:22:43,760
put in an unsafe block and you then also

00:22:40,130 --> 00:22:45,950
have to deal with the lifetime and the

00:22:43,760 --> 00:22:49,100
cleanup of this piece of data yourself

00:22:45,950 --> 00:22:51,110
so you can actually this way you can

00:22:49,100 --> 00:22:53,720
leak memory quite beautifully because

00:22:51,110 --> 00:22:55,700
you can put something on the heap give

00:22:53,720 --> 00:22:56,990
yourself the raw pointer and then never

00:22:55,700 --> 00:23:03,380
do anything with the raw pointer again

00:22:56,990 --> 00:23:06,140
and it's just it remains on the heap but

00:23:03,380 --> 00:23:09,530
so it's pretty ugly from rust but if

00:23:06,140 --> 00:23:12,800
your priority is to be in line with the

00:23:09,530 --> 00:23:14,690
rest of a CA B C API that you're trying

00:23:12,800 --> 00:23:18,050
to match this is really great because it

00:23:14,690 --> 00:23:21,410
feels exactly the same you can even like

00:23:18,050 --> 00:23:23,240
the server struct can be exported to C

00:23:21,410 --> 00:23:26,810
so that it can directly access the port

00:23:23,240 --> 00:23:29,030
if it if you want that to happen and if

00:23:26,810 --> 00:23:31,460
all of your other code uses this pattern

00:23:29,030 --> 00:23:34,370
or if some of your other code uses this

00:23:31,460 --> 00:23:37,760
pattern it's a good way to sort of match

00:23:34,370 --> 00:23:39,770
that and this is like literally figuring

00:23:37,760 --> 00:23:41,420
out the box into raw was why I then

00:23:39,770 --> 00:23:43,610
wrote this talk because there's like no

00:23:41,420 --> 00:23:49,200
documentation about this well there's

00:23:43,610 --> 00:23:50,950
now but so let's let's talk about C++

00:23:49,200 --> 00:23:53,420
[Music]

00:23:50,950 --> 00:23:56,810
well I already mentioned that we'll have

00:23:53,420 --> 00:24:00,260
to wrap some stuff and what we can do is

00:23:56,810 --> 00:24:02,330
so I'm not I don't write that much C++

00:24:00,260 --> 00:24:04,100
code I know that people shout at each

00:24:02,330 --> 00:24:05,870
other about whether or not to throw

00:24:04,100 --> 00:24:07,700
exceptions so I have one example that

00:24:05,870 --> 00:24:10,370
throws an exception and one but that

00:24:07,700 --> 00:24:14,420
doesn't basically what you will have to

00:24:10,370 --> 00:24:16,100
do is include the the header that is

00:24:14,420 --> 00:24:19,580
generated for you the same way that you

00:24:16,100 --> 00:24:21,680
would include any C header from C++ and

00:24:19,580 --> 00:24:24,530
then you would probably want to write a

00:24:21,680 --> 00:24:26,780
module around it that calls into it and

00:24:24,530 --> 00:24:28,370
then abstracts away any sort of errors

00:24:26,780 --> 00:24:30,800
into the system that you're using in

00:24:28,370 --> 00:24:33,570
your code this is very specific to your

00:24:30,800 --> 00:24:37,170
project so if you use exceptions then

00:24:33,570 --> 00:24:39,300
exceptions or if you use like a result

00:24:37,170 --> 00:24:40,740
structs that your immunity because there

00:24:39,300 --> 00:24:43,110
are things like that you can use

00:24:40,740 --> 00:24:45,870
templates or something you can return

00:24:43,110 --> 00:24:48,330
that instead so at this point it's very

00:24:45,870 --> 00:24:51,650
much down to you and your project what

00:24:48,330 --> 00:24:54,450
you need the important thing is that

00:24:51,650 --> 00:24:56,370
with the patterns that I showed you and

00:24:54,450 --> 00:24:58,170
see at least you have a good basis for

00:24:56,370 --> 00:24:59,730
communicating errors in the first place

00:24:58,170 --> 00:25:02,580
because the worst thing you want to do

00:24:59,730 --> 00:25:04,980
is in your C++ code just throw an oopsie

00:25:02,580 --> 00:25:06,390
exception that tells you that something

00:25:04,980 --> 00:25:10,590
went wrong and you have no idea how to

00:25:06,390 --> 00:25:13,230
debug it okay so I have five minutes

00:25:10,590 --> 00:25:15,240
left and I hope that until this point

00:25:13,230 --> 00:25:18,090
I've shown you some useful information

00:25:15,240 --> 00:25:20,550
and maybe shown you where maybe the

00:25:18,090 --> 00:25:23,670
ecosystem needs more work for the last

00:25:20,550 --> 00:25:27,000
five minutes I want to answer this

00:25:23,670 --> 00:25:30,330
question which has been haunting me for

00:25:27,000 --> 00:25:32,100
the last six months or so so I think if

00:25:30,330 --> 00:25:36,240
this isn't your reaction by the way then

00:25:32,100 --> 00:25:40,920
I'm deeply worried about you and well

00:25:36,240 --> 00:25:42,870
the answer is yes you can so let's let's

00:25:40,920 --> 00:25:45,240
look at let's look at what exceptions

00:25:42,870 --> 00:25:47,490
actually are maybe you've never worked

00:25:45,240 --> 00:25:50,250
in a language that has exceptions like C

00:25:47,490 --> 00:25:52,350
or rust or you've never looked under the

00:25:50,250 --> 00:25:55,770
hood deeply enough this is based on the

00:25:52,350 --> 00:25:57,360
C++ LLVM documentation which is really

00:25:55,770 --> 00:25:59,790
great so if you're curious about that

00:25:57,360 --> 00:26:02,610
definitely read that it's really

00:25:59,790 --> 00:26:04,500
well-written so there's really three key

00:26:02,610 --> 00:26:07,110
words involved sometimes four but like

00:26:04,500 --> 00:26:10,590
we only care about three right now try

00:26:07,110 --> 00:26:13,440
throw-and-catch what a try does is

00:26:10,590 --> 00:26:15,930
create a sort of landing pad that you

00:26:13,440 --> 00:26:18,540
can jump into later and I'll go into the

00:26:15,930 --> 00:26:20,640
details in a bit then when you call

00:26:18,540 --> 00:26:22,470
throw at some point in your code what

00:26:20,640 --> 00:26:24,600
you do is you start walking up the stack

00:26:22,470 --> 00:26:26,970
at the same way or similar to how you

00:26:24,600 --> 00:26:29,160
would unwind your stack you go up until

00:26:26,970 --> 00:26:33,450
you find the landing pad and you jump

00:26:29,160 --> 00:26:36,240
into it catch blocks are then basically

00:26:33,450 --> 00:26:39,510
function pointers that you jump onto and

00:26:36,240 --> 00:26:41,490
like call them the thing there is that

00:26:39,510 --> 00:26:43,380
there is a bit more logic to handle

00:26:41,490 --> 00:26:46,350
which again I'll deal with it in a

00:26:43,380 --> 00:26:46,990
second so the try the landing pad

00:26:46,350 --> 00:26:50,140
actually

00:26:46,990 --> 00:26:52,929
more information than just how to deal

00:26:50,140 --> 00:26:54,460
with an exception because the the try

00:26:52,929 --> 00:26:56,260
block can be ended in two different ways

00:26:54,460 --> 00:26:59,500
either you can have thrown an error or

00:26:56,260 --> 00:27:02,080
you can have not so it needs to

00:26:59,500 --> 00:27:03,429
understand the difference between or it

00:27:02,080 --> 00:27:05,920
understands the difference between an

00:27:03,429 --> 00:27:08,770
allocated exception that sets somewhere

00:27:05,920 --> 00:27:11,520
in a buffer and not at which point it'll

00:27:08,770 --> 00:27:14,110
either choose to evaluate the catch

00:27:11,520 --> 00:27:17,950
clauses or it'll just continue in your

00:27:14,110 --> 00:27:22,240
code as normal so the catch is actually

00:27:17,950 --> 00:27:24,100
a filter because in C++ at least you can

00:27:22,240 --> 00:27:26,429
catch for multiple exceptions at the

00:27:24,100 --> 00:27:28,980
same time kind of multiple catch

00:27:26,429 --> 00:27:31,120
statements or a catch blocks I guess

00:27:28,980 --> 00:27:33,309
that that filter for different

00:27:31,120 --> 00:27:36,570
exceptions and you can even like use the

00:27:33,309 --> 00:27:39,190
pipe or logical or operator on them and

00:27:36,570 --> 00:27:41,110
maybe you don't have a catch block which

00:27:39,190 --> 00:27:42,940
catches the exception and then it gets

00:27:41,110 --> 00:27:47,170
wreath roan in the hopes that someone

00:27:42,940 --> 00:27:48,760
upstairs will care the last part is

00:27:47,170 --> 00:27:50,980
actually the easiest and that is nice

00:27:48,760 --> 00:27:54,610
because that's what we care about

00:27:50,980 --> 00:27:57,580
so the throat keyword gets replaced by

00:27:54,610 --> 00:28:00,429
the compiler with calls into Lib C++

00:27:57,580 --> 00:28:03,760
that allocate an exception define types

00:28:00,429 --> 00:28:08,440
with certain mangling rules and then

00:28:03,760 --> 00:28:12,190
throw the exception so this is the talk

00:28:08,440 --> 00:28:14,559
about rust and I'm sorry if I went a

00:28:12,190 --> 00:28:17,740
little far there and introducing

00:28:14,559 --> 00:28:20,290
exception RS so I wrote a create that

00:28:17,740 --> 00:28:23,559
can throw exceptions C++ exceptions in

00:28:20,290 --> 00:28:25,330
rust this is what it would look like so

00:28:23,559 --> 00:28:27,760
you have the exception thing and then

00:28:25,330 --> 00:28:32,110
you can like throw some structure with a

00:28:27,760 --> 00:28:33,850
whatever payload you want how this is

00:28:32,110 --> 00:28:35,710
implemented well there's no Lib C++

00:28:33,850 --> 00:28:38,429
binding instrument bindings in rust

00:28:35,710 --> 00:28:41,050
which is probably a good thing so

00:28:38,429 --> 00:28:43,150
instead I wrote a little shim layer and

00:28:41,050 --> 00:28:45,340
see that just invokes those functions

00:28:43,150 --> 00:28:47,500
that are exported so those are the two

00:28:45,340 --> 00:28:50,380
functions there's like a third that it's

00:28:47,500 --> 00:28:52,059
not important for this example these are

00:28:50,380 --> 00:28:54,010
the two big functions that you need to

00:28:52,059 --> 00:28:57,880
allocate an exception and to throw it

00:28:54,010 --> 00:29:01,190
and those declarations are in the C code

00:28:57,880 --> 00:29:03,500
exactly that way because I

00:29:01,190 --> 00:29:05,360
I can't provide those and I am compiling

00:29:03,500 --> 00:29:08,210
my code in the hopes that before it's

00:29:05,360 --> 00:29:09,740
run a C++ compiler will look at my code

00:29:08,210 --> 00:29:12,290
and go oh yeah I know where to find

00:29:09,740 --> 00:29:14,299
those so you're very much dependent on

00:29:12,290 --> 00:29:17,780
your project being compiled with a C++

00:29:14,299 --> 00:29:20,960
compiler or else it won't work and this

00:29:17,780 --> 00:29:22,760
is what that looks like now so you the

00:29:20,960 --> 00:29:25,190
car go bolt release as so that I build

00:29:22,760 --> 00:29:28,160
the actual rust code that throws the

00:29:25,190 --> 00:29:32,090
exception and in then you invoke a jeep

00:29:28,160 --> 00:29:34,880
jeep Laplace or C++ compiler that links

00:29:32,090 --> 00:29:36,890
in the exception throwing library and

00:29:34,880 --> 00:29:39,350
then it's well I didn't handle it

00:29:36,890 --> 00:29:43,160
because I thought it looked nicer too to

00:29:39,350 --> 00:29:46,309
die with a custom rust exception alright

00:29:43,160 --> 00:29:49,840
so there's one more thing that I've been

00:29:46,309 --> 00:29:56,270
working on and I kind of got it to work

00:29:49,840 --> 00:29:59,660
answering that question and the answer

00:29:56,270 --> 00:30:00,980
is yes but I'm out of time and I will

00:29:59,660 --> 00:30:03,020
write a blog post about that because

00:30:00,980 --> 00:30:06,080
it's a whole different like can of worms

00:30:03,020 --> 00:30:09,740
and I died a minute or so thank you real

00:30:06,080 --> 00:30:11,270
and I so follow me on Twitter I do a lot

00:30:09,740 --> 00:30:13,549
of posting if you can put up with

00:30:11,270 --> 00:30:15,260
that or if you have if you have

00:30:13,549 --> 00:30:17,929
questions or want to get in touch with

00:30:15,260 --> 00:30:19,880
me if you see this online at some point

00:30:17,929 --> 00:30:22,760
or a year you're like shy or you don't

00:30:19,880 --> 00:30:25,309
meet me write me an email so I I do like

00:30:22,760 --> 00:30:27,200
getting emails I want to thank my

00:30:25,309 --> 00:30:29,630
employer for our systems the surname you

00:30:27,200 --> 00:30:31,880
might be familiar with it's the company

00:30:29,630 --> 00:30:34,730
that I'm working on like in with James

00:30:31,880 --> 00:30:36,770
and they sent me here so I want to thank

00:30:34,730 --> 00:30:38,780
Mozilla for allowing me to be here and

00:30:36,770 --> 00:30:41,150
like providing accommodation and stuff

00:30:38,780 --> 00:30:42,080
and I want to thank all of you the rest

00:30:41,150 --> 00:30:46,160
community

00:30:42,080 --> 00:30:48,049
i I really like the the keynote this

00:30:46,160 --> 00:30:50,840
morning because I talked about how the

00:30:48,049 --> 00:30:53,090
the rest community can be inclusive and

00:30:50,840 --> 00:30:55,640
welcoming and it's really one of the

00:30:53,090 --> 00:30:59,070
reasons why I like contributing to rust

00:30:55,640 --> 00:31:03,560
so thank you and yeah have a nice day

00:30:59,070 --> 00:31:06,660
[Applause]

00:31:03,560 --> 00:31:06,660
[Music]

00:31:07,540 --> 00:31:10,640
[Applause]

00:31:11,320 --> 00:31:19,910

YouTube URL: https://www.youtube.com/watch?v=x9acx2zgx4Q


