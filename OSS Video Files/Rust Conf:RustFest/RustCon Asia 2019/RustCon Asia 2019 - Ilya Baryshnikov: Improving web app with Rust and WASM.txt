Title: RustCon Asia 2019 - Ilya Baryshnikov: Improving web app with Rust and WASM
Publication date: 2019-04-30
Playlist: RustCon Asia 2019
Description: 
	WebAssembly is a new standard which can be used to speed up heavy computations in the browser. But what is a “heavy computation”? How it may affect your users and your business? I will show several examples of heavy computations in React + three.js app. We will compare performance of JS and Rust. Then I will share our story of introducing Rust and WebAssembly to the app. How to write the code, how to build and publish npm module, and how to finally load it with webpack. We will discuss how wasm-bindgen library can help you to communicate with the JS world and reduce the boilerplate. In the end we’ll talk about quality control tools and tests.

Find slides here: https://github.com/ibaryshnikov/beijing-talk-2019

Follow us on Twitter: https://twitter.com/RustConAsia
Captions: 
	00:00:06,190 --> 00:00:12,380
hello

00:00:07,950 --> 00:00:12,380
I really don't like to see your here

00:00:21,349 --> 00:00:26,490
how many of you are web developers can

00:00:25,829 --> 00:00:29,369
you write there

00:00:26,490 --> 00:00:32,220
Wow a lot okay so you're probably

00:00:29,369 --> 00:00:34,410
familiar with stuff like non J's and the

00:00:32,220 --> 00:00:40,640
park and so on I'll be talking about

00:00:34,410 --> 00:00:40,640
them and let's talk about what assembly

00:00:42,409 --> 00:00:49,110
yeah

00:00:43,800 --> 00:00:53,460
few words about me I work in a line

00:00:49,110 --> 00:00:57,030
technology previously I'm a JavaScript

00:00:53,460 --> 00:01:13,439
developer both know Jesus and browser

00:00:57,030 --> 00:01:17,070
and the most awesome thing and the most

00:01:13,439 --> 00:01:24,060
of some thing is that I use a rust and

00:01:17,070 --> 00:01:28,230
webassembly at work so in online

00:01:24,060 --> 00:01:36,000
technology we use rust with web assembly

00:01:28,230 --> 00:01:42,780
and what do we exactly do there are two

00:01:36,000 --> 00:01:49,650
major products in the company the

00:01:42,780 --> 00:01:52,650
scanner and the aligners so a patient

00:01:49,650 --> 00:01:56,340
can come to a doctor I can scan the

00:01:52,650 --> 00:02:00,150
teeth and then the doctor can see the

00:01:56,340 --> 00:02:09,299
result and we provide web tools for

00:02:00,150 --> 00:02:12,269
doctors and also I really or something

00:02:09,299 --> 00:02:14,540
that we can preview the results of the

00:02:12,269 --> 00:02:14,540
treatment

00:02:34,220 --> 00:02:42,630
they're liners are designed to move

00:02:37,740 --> 00:02:46,290
teeth in a predictable way and our tools

00:02:42,630 --> 00:02:47,010
help us to see the outcome what will be

00:02:46,290 --> 00:02:54,380
in the end

00:02:47,010 --> 00:02:56,730
and what about webassembly here well

00:02:54,380 --> 00:03:08,040
what is the most important thing when

00:02:56,730 --> 00:03:10,550
you do any updates any improvements to

00:03:08,040 --> 00:03:14,490
not break your product because if

00:03:10,550 --> 00:03:17,160
patient comes to a doctor and he runs an

00:03:14,490 --> 00:03:33,680
application and doesn't work it will not

00:03:17,160 --> 00:03:37,440
be good here teeth is scanned it is a

00:03:33,680 --> 00:03:40,320
predefined object predefined objects

00:03:37,440 --> 00:03:46,040
which we received from the backend but

00:03:40,320 --> 00:03:54,420
the flesh of the red stuff is generated

00:03:46,040 --> 00:04:00,200
dynamically and in order to render the

00:03:54,420 --> 00:04:06,360
light on the flesh we have to do some

00:04:00,200 --> 00:04:16,230
computations and they are quite heavy

00:04:06,360 --> 00:04:23,640
there is involved 3d mathematics and

00:04:16,230 --> 00:04:26,610
let's check the code it is a perfect use

00:04:23,640 --> 00:04:33,200
case for assembly computations because

00:04:26,610 --> 00:04:39,380
we have several arrays for our input and

00:04:33,200 --> 00:04:39,380
we have an output array

00:04:41,890 --> 00:04:51,590
well and I'd like to introduce was

00:04:47,030 --> 00:04:54,610
invention it is a library there are two

00:04:51,590 --> 00:04:59,380
parts of this library say Lytle and

00:04:54,610 --> 00:05:07,490
actual library so the library provides

00:04:59,380 --> 00:05:12,980
utilities for JavaScript generation so

00:05:07,490 --> 00:05:19,360
we can write our annotations and we can

00:05:12,980 --> 00:05:27,860
effect they generated JavaScript and

00:05:19,360 --> 00:05:31,010
let's check the result so when we run

00:05:27,860 --> 00:05:33,440
SLI to the following JavaScript will be

00:05:31,010 --> 00:05:40,430
generated it's a lot of code

00:05:33,440 --> 00:05:50,060
yeah so it is possible to write all of

00:05:40,430 --> 00:05:55,280
it by hand but it's hard to do it right

00:05:50,060 --> 00:05:58,340
and it's easy to do a mistake and was

00:05:55,280 --> 00:06:01,910
binding helps us here it takes care of

00:05:58,340 --> 00:06:06,590
us and it also does minor memory

00:06:01,910 --> 00:06:10,480
management let's shake a line 53

00:06:06,590 --> 00:06:13,820
there is an array percent to webassembly

00:06:10,480 --> 00:06:18,380
we involve assembly we have a distinct

00:06:13,820 --> 00:06:21,560
memory liner or memory buffer so we

00:06:18,380 --> 00:06:24,280
caught the JavaScript array to

00:06:21,560 --> 00:06:24,280
webassembly

00:06:24,490 --> 00:06:33,190
well here are we do it several times and

00:06:27,110 --> 00:06:33,190
then line 60 we do actual calculation

00:06:34,810 --> 00:06:43,780
after our calculation we copy the result

00:06:39,650 --> 00:06:43,780
from web assembly back to JavaScript

00:06:43,870 --> 00:06:51,000
pay attention online 65 there is a slice

00:06:48,260 --> 00:06:54,030
in the end so

00:06:51,000 --> 00:06:56,670
just copy an array from AB assembly

00:06:54,030 --> 00:07:00,210
memory buffer and then we free the

00:06:56,670 --> 00:07:04,500
memory so must buy engine handles memory

00:07:00,210 --> 00:07:07,010
management for us and it's kind of all

00:07:04,500 --> 00:07:07,010
something

00:07:10,670 --> 00:07:19,680
what about what to do if you want to

00:07:14,550 --> 00:07:22,740
return to erase here we have normals and

00:07:19,680 --> 00:07:26,790
minerals we want to calculate more

00:07:22,740 --> 00:07:32,310
values at the moment it is not possible

00:07:26,790 --> 00:07:35,400
to return at Apple of arrays or an array

00:07:32,310 --> 00:07:42,350
of generic types or something like that

00:07:35,400 --> 00:07:47,190
using wasn't benjin and here is a trick

00:07:42,350 --> 00:07:50,630
we can define with visa was imagine we

00:07:47,190 --> 00:07:52,800
can define any JavaScript object so

00:07:50,630 --> 00:07:57,680
let's call it callback

00:07:52,800 --> 00:08:02,220
it will be our JavaScript object and

00:07:57,680 --> 00:08:06,870
let's assume it has a method load

00:08:02,220 --> 00:08:09,840
results in annotation we mentioned that

00:08:06,870 --> 00:08:12,960
it is a mess and it is structural and we

00:08:09,840 --> 00:08:17,669
can even affect the name which will be

00:08:12,960 --> 00:08:22,260
in generated JavaScript and this means

00:08:17,669 --> 00:08:26,430
that any JavaScript object which will

00:08:22,260 --> 00:08:30,180
have a lot results method will be fine

00:08:26,430 --> 00:08:35,370
for us it is so called that type in the

00:08:30,180 --> 00:08:39,750
interface well as far as it can work it

00:08:35,370 --> 00:08:44,219
is fine for us and here we use the

00:08:39,750 --> 00:08:48,300
callback and then we be passed to our

00:08:44,219 --> 00:08:51,350
two arrays to come back well it's

00:08:48,300 --> 00:08:55,220
slightly more complicated

00:08:51,350 --> 00:08:57,970
it could be with tuples I hope the

00:08:55,220 --> 00:09:01,310
bindings will be updated in the future

00:08:57,970 --> 00:09:08,330
but it is a good example of that type of

00:09:01,310 --> 00:09:10,670
interface usage and then again we can

00:09:08,330 --> 00:09:14,420
see the Lord results which isn't

00:09:10,670 --> 00:09:17,270
generated we receive the data from AB

00:09:14,420 --> 00:09:24,500
assembly then here the memory is freed

00:09:17,270 --> 00:09:27,920
line 27 then we get the secondary again

00:09:24,500 --> 00:09:30,650
we free the memory and here we finally

00:09:27,920 --> 00:09:35,450
pass the results to our JavaScript

00:09:30,650 --> 00:09:38,510
method again it is possible to write all

00:09:35,450 --> 00:09:50,510
of feed my hand but who would like to do

00:09:38,510 --> 00:09:54,170
it and let's talk about performance we

00:09:50,510 --> 00:10:03,110
already seen there were three arrays in

00:09:54,170 --> 00:10:09,980
two arrays out like 60,000 items in well

00:10:03,110 --> 00:10:14,840
actually numbers and 30,000 out and what

00:10:09,980 --> 00:10:18,080
I measured in JavaScript it's only time

00:10:14,840 --> 00:10:21,140
to compute the result and in women

00:10:18,080 --> 00:10:23,350
sembly we still need to pass the data to

00:10:21,140 --> 00:10:27,260
webassembly memory and to copy it back

00:10:23,350 --> 00:10:38,210
so it is actual computation and data

00:10:27,260 --> 00:10:41,270
transfer overhead really well yes it's

00:10:38,210 --> 00:10:45,440
unfair because in web assembly part we

00:10:41,270 --> 00:10:50,330
do more work we still do this data

00:10:45,440 --> 00:10:54,650
transfer part well actually it takes

00:10:50,330 --> 00:11:02,190
probably 20% of time of the computation

00:10:54,650 --> 00:11:05,410
time and

00:11:02,190 --> 00:11:11,230
when I started to murder I started with

00:11:05,410 --> 00:11:13,470
the development bills so in a buck there

00:11:11,230 --> 00:11:17,310
are several profiles like profile

00:11:13,470 --> 00:11:20,800
development Hank profiler ease and

00:11:17,310 --> 00:11:23,470
development produce like stuff like

00:11:20,800 --> 00:11:29,590
cultural art and used a lot of a wall so

00:11:23,470 --> 00:11:35,350
it's the JavaScript is slower and I was

00:11:29,590 --> 00:11:38,890
using web assembly release built because

00:11:35,350 --> 00:11:44,530
in web assembly tools release is the

00:11:38,890 --> 00:11:47,410
default mode so most of all the

00:11:44,530 --> 00:11:50,140
developers are happy they have more

00:11:47,410 --> 00:11:54,910
performance benefits and when it's

00:11:50,140 --> 00:11:57,610
reached later to production build I was

00:11:54,910 --> 00:12:08,050
not that happy with the performance

00:11:57,610 --> 00:12:12,970
boosts well but there is so in most of

00:12:08,050 --> 00:12:19,630
the browsers it's like 1.3 and we also

00:12:12,970 --> 00:12:23,200
support Safari on iPod and probably evap

00:12:19,630 --> 00:12:27,280
assembly on the far e on iPod is the

00:12:23,200 --> 00:12:29,740
same as JavaScript but we still have

00:12:27,280 --> 00:12:31,780
this data transfer of our head so it's a

00:12:29,740 --> 00:12:34,720
little bit slower because of this and

00:12:31,780 --> 00:12:37,000
surprisingly in edge even in production

00:12:34,720 --> 00:12:39,790
built it was it was like six times

00:12:37,000 --> 00:12:44,080
faster it was a little bit surprised

00:12:39,790 --> 00:12:47,880
maybe didn't notice something but well

00:12:44,080 --> 00:12:51,670
in production is the Oh the same thing

00:12:47,880 --> 00:12:55,030
happens in Safari in development build

00:12:51,670 --> 00:12:57,370
it's also like six times faster over

00:12:55,030 --> 00:13:03,430
similar than JavaScript but when you

00:12:57,370 --> 00:13:04,800
compile to with a pack using production

00:13:03,430 --> 00:13:11,940
mode

00:13:04,800 --> 00:13:11,940
Eitan there is again in gain like 1.3

00:13:12,540 --> 00:13:22,840
and how to improve the station the first

00:13:17,790 --> 00:13:26,170
obvious thing is to eliminate data

00:13:22,840 --> 00:13:29,920
transfer overhead so there is a need to

00:13:26,170 --> 00:13:34,270
keep the state on the web assembly side

00:13:29,920 --> 00:13:37,330
in our line of memory and the most

00:13:34,270 --> 00:13:41,080
problem here is that it involves a lot

00:13:37,330 --> 00:13:44,410
of changes as I was doing the prototype

00:13:41,080 --> 00:13:46,740
I needed to show that it works we can

00:13:44,410 --> 00:13:52,110
trust it it will not break our

00:13:46,740 --> 00:13:56,280
application so I just decided not to

00:13:52,110 --> 00:13:59,890
change the thing ok let's let's keep our

00:13:56,280 --> 00:14:03,970
overhead it's still a little bit faster

00:13:59,890 --> 00:14:06,280
we can build things on top of it so the

00:14:03,970 --> 00:14:10,170
first thing here is keep the state on

00:14:06,280 --> 00:14:15,100
the web assembly side and the second

00:14:10,170 --> 00:14:18,460
part we can actually use web assembly

00:14:15,100 --> 00:14:24,690
memory buffer to create JavaScript ipad

00:14:18,460 --> 00:14:30,090
arrays and for example if we use WebGL

00:14:24,690 --> 00:14:33,490
we can pass such type at arrays to WebGL

00:14:30,090 --> 00:14:39,220
in such way we can eliminate the it'll

00:14:33,490 --> 00:14:41,590
transfer overhead totally but well we

00:14:39,220 --> 00:14:46,930
will have the application completely

00:14:41,590 --> 00:14:50,050
righted written in rust this way well

00:14:46,930 --> 00:14:54,910
it's probably not not the way for if you

00:14:50,050 --> 00:15:00,960
have a big JavaScript application well

00:14:54,910 --> 00:15:00,960
there's some things to think about

00:15:02,620 --> 00:15:08,320
so yeah it's a small example actual

00:15:05,640 --> 00:15:11,140
computation took like two milliseconds

00:15:08,320 --> 00:15:16,960
and if it's not that often

00:15:11,140 --> 00:15:22,630
let's talk about something more more

00:15:16,960 --> 00:15:28,870
heavy as you know there is no hover

00:15:22,630 --> 00:15:34,020
events in WebGL and we have to to do

00:15:28,870 --> 00:15:41,650
them manually we use three J's and

00:15:34,020 --> 00:15:54,510
there's a built-in selecting API in

00:15:41,650 --> 00:16:02,490
three.js so the next thing I decided to

00:15:54,510 --> 00:16:07,450
to improve this part why it is important

00:16:02,490 --> 00:16:13,990
when we have WebGL and renderers we have

00:16:07,450 --> 00:16:18,780
limits we have if you want to render 60

00:16:13,990 --> 00:16:25,210
frames per second we have only 16

00:16:18,780 --> 00:16:29,380
milliseconds per frame and selection in

00:16:25,210 --> 00:16:33,460
each frame took four milliseconds so

00:16:29,380 --> 00:16:39,540
it's 25% of our time it's a lot of we

00:16:33,460 --> 00:16:39,540
can actually start improving it

00:16:41,460 --> 00:16:57,210
and I'd like to talk directly about the

00:16:48,899 --> 00:16:59,430
outcomes I develop on modern laptop and

00:16:57,210 --> 00:17:03,089
it's Greek and everything is fine I

00:16:59,430 --> 00:17:07,230
always have a 60 FPS I don't mean to

00:17:03,089 --> 00:17:15,030
improve anything but our users probably

00:17:07,230 --> 00:17:20,150
have different devices and it may help

00:17:15,030 --> 00:17:24,240
them to to have better user experience

00:17:20,150 --> 00:17:28,530
for example even if you have an old

00:17:24,240 --> 00:17:34,230
computer and it may be like you know

00:17:28,530 --> 00:17:37,020
slow and if we improve this thing the

00:17:34,230 --> 00:17:40,620
doctor probably will not need to buy a

00:17:37,020 --> 00:17:43,080
new device new computer and it will

00:17:40,620 --> 00:17:47,250
would be easier for people to start

00:17:43,080 --> 00:17:51,750
using using our application also when it

00:17:47,250 --> 00:17:59,570
goes to rendering we want things to be

00:17:51,750 --> 00:17:59,570
smooth and what garbage collector does

00:18:00,140 --> 00:18:06,840
let's assume we are going to render a

00:18:02,700 --> 00:18:11,550
frame and there is a lot of garbage and

00:18:06,840 --> 00:18:14,670
garbage collector tells us hey wait wait

00:18:11,550 --> 00:18:16,860
I meant I need to clean the garbage and

00:18:14,670 --> 00:18:19,559
we wait and the user receives there is a

00:18:16,860 --> 00:18:24,870
stop because the garbage collector was

00:18:19,559 --> 00:18:29,280
cleaning the stuff and with webassembly

00:18:24,870 --> 00:18:31,559
there is no garbage collector so we

00:18:29,280 --> 00:18:36,900
prayed you while using probe assembly we

00:18:31,559 --> 00:18:41,520
produced less garbage and it's hard to

00:18:36,900 --> 00:18:45,910
measure in micro benchmark but having

00:18:41,520 --> 00:18:49,190
less garbage we will have less stops

00:18:45,910 --> 00:18:55,940
while or entering and also we can

00:18:49,190 --> 00:18:59,660
deliver more features initially I just

00:18:55,940 --> 00:19:03,140
used JavaScript code and rewrote it

00:18:59,660 --> 00:19:04,190
directly to arrest but we have great

00:19:03,140 --> 00:19:07,580
aiya

00:19:04,190 --> 00:19:13,430
and we can use a lot of libraries from

00:19:07,580 --> 00:19:16,700
there and we can bring more 3d features

00:19:13,430 --> 00:19:18,980
like previously we can we could think

00:19:16,700 --> 00:19:23,120
it's it's too complicated

00:19:18,980 --> 00:19:25,580
it's too hard let's not do it in the

00:19:23,120 --> 00:19:29,840
browser but now we can start thinking

00:19:25,580 --> 00:19:35,630
about it one example of really hard

00:19:29,840 --> 00:19:39,320
feature is 3d collisions imagine we have

00:19:35,630 --> 00:19:43,730
two 3d objects and they collide somehow

00:19:39,320 --> 00:19:47,030
and then we can create a new object from

00:19:43,730 --> 00:19:50,270
two objects and using geometry it's

00:19:47,030 --> 00:19:55,790
really it's matter of not milliseconds

00:19:50,270 --> 00:19:59,830
but seconds it quite heavy and we can

00:19:55,790 --> 00:19:59,830
start thinking about doing such stuff

00:20:02,920 --> 00:20:12,710
well it also brings some problems we

00:20:07,310 --> 00:20:17,840
have higher complexity and we have to

00:20:12,710 --> 00:20:21,710
think about browser support and the

00:20:17,840 --> 00:20:26,480
second thing with browser supports there

00:20:21,710 --> 00:20:30,290
is a wasn't 2gs tool it helps us we can

00:20:26,480 --> 00:20:33,530
generate in JavaScript from our new

00:20:30,290 --> 00:20:36,560
assembly binary the problem with it is

00:20:33,530 --> 00:20:43,190
when I tested it it was 2 times slower

00:20:36,560 --> 00:20:45,920
than handwritten JavaScript well not

00:20:43,190 --> 00:20:49,640
that impressive but if you have no other

00:20:45,920 --> 00:20:52,130
choice we can either write fallback my

00:20:49,640 --> 00:20:56,710
hand or generate it well probably

00:20:52,130 --> 00:20:56,710
sometimes it's better to generate

00:21:01,520 --> 00:21:07,040
and here is the complexity

00:21:07,190 --> 00:21:13,100
let's check line three when working with

00:21:13,760 --> 00:21:19,350
webassembly we have to allow it 8i

00:21:16,590 --> 00:21:23,130
synchronously by design here's an

00:21:19,350 --> 00:21:25,620
example of loading with the verb pack it

00:21:23,130 --> 00:21:29,190
is compatible and supported out of the

00:21:25,620 --> 00:21:34,710
box with the web assembly experimental

00:21:29,190 --> 00:21:36,570
order and later on line seven the year

00:21:34,710 --> 00:21:40,710
Lord fall back

00:21:36,570 --> 00:21:42,929
either handwritten or generated and then

00:21:40,710 --> 00:21:48,690
imagine we want to start using the

00:21:42,929 --> 00:21:51,390
function immediately or in any browser

00:21:48,690 --> 00:21:53,160
and we check if there is a web assembly

00:21:51,390 --> 00:21:56,910
we calculate with assembly stuff if

00:21:53,160 --> 00:21:59,880
there is a javascript we do and if there

00:21:56,910 --> 00:22:04,290
is no assembly we do it in JavaScript

00:21:59,880 --> 00:22:08,100
fallback and here's an example of our

00:22:04,290 --> 00:22:11,490
duck typed interface you remember the

00:22:08,100 --> 00:22:15,179
callback we defined it previously so

00:22:11,490 --> 00:22:21,570
here is the plain JavaScript object with

00:22:15,179 --> 00:22:26,040
a load results method and then we pass

00:22:21,570 --> 00:22:31,950
this object to assembly and return the

00:22:26,040 --> 00:22:37,290
result kind of a boilerplate more

00:22:31,950 --> 00:22:39,390
complexity and we have to think about is

00:22:37,290 --> 00:22:42,450
it supported at the moment or not with

00:22:39,390 --> 00:22:47,400
this if-else and the complexity with the

00:22:42,450 --> 00:22:50,100
Cobra can be solved with Java scripts

00:22:47,400 --> 00:22:52,710
and snippets Joe skips local snippets is

00:22:50,100 --> 00:22:56,880
a new feature which was recently added

00:22:52,710 --> 00:23:00,179
to or wasn't Benjen and I can encourage

00:22:56,880 --> 00:23:03,500
you to check it it can really help to

00:23:00,179 --> 00:23:03,500
reduce the boilerplate

00:23:05,059 --> 00:23:12,169
and I was talking about wasn't park it

00:23:07,429 --> 00:23:15,889
is a general tool to build tests and

00:23:12,169 --> 00:23:18,860
publish your package it uses non GS

00:23:15,889 --> 00:23:27,980
under the hood it can install all the

00:23:18,860 --> 00:23:33,080
required additional set of CLI tools and

00:23:27,980 --> 00:23:35,720
a few words about quality control we

00:23:33,080 --> 00:23:42,289
have wasn't PARCC test to test our

00:23:35,720 --> 00:23:50,090
assembly I personally prefer a cargo

00:23:42,289 --> 00:23:55,039
test for unit testing when it goes to o

00:23:50,090 --> 00:24:01,210
CI it would be great to have reports so

00:23:55,039 --> 00:24:09,169
cargo to G in it produces the unit or

00:24:01,210 --> 00:24:12,590
reports out of a cargo output from cargo

00:24:09,169 --> 00:24:15,220
test output and there is also a cargo

00:24:12,590 --> 00:24:19,330
audit to check that there are no

00:24:15,220 --> 00:24:22,519
vulnerabilities in your dependencies

00:24:19,330 --> 00:24:25,940
finally if there is a headless Chrome it

00:24:22,519 --> 00:24:26,659
is for integration testing the whole

00:24:25,940 --> 00:24:30,249
pipeline

00:24:26,659 --> 00:24:33,950
looook looks like we have to build our

00:24:30,249 --> 00:24:37,700
robe assembly then we have to build a

00:24:33,950 --> 00:24:40,580
bundle with a park then we have to solve

00:24:37,700 --> 00:24:43,850
the statics then we have to use a

00:24:40,580 --> 00:24:46,190
headless browser to navigate to the

00:24:43,850 --> 00:24:49,929
statics load the page in check that

00:24:46,190 --> 00:24:53,899
javascript uses web assembly correctly

00:24:49,929 --> 00:25:00,889
so headless chrome is a chrome dev tools

00:24:53,899 --> 00:25:03,639
protocol to create rust grade to control

00:25:00,889 --> 00:25:03,639
the headless Crowe

00:25:06,010 --> 00:25:16,990
and let's talk about future there was a

00:25:12,580 --> 00:25:19,660
a lot of movement in Washington to J's a

00:25:16,990 --> 00:25:22,510
lot of commits because I'm script and

00:25:19,660 --> 00:25:29,500
folks are interested in it and they are

00:25:22,510 --> 00:25:33,400
improving it right now also well when it

00:25:29,500 --> 00:25:36,220
goes to was invention it is quite low

00:25:33,400 --> 00:25:41,860
level it's some times painful to work

00:25:36,220 --> 00:25:46,440
with and there is an initiative go model

00:25:41,860 --> 00:25:51,130
our web toolkit which will provide a

00:25:46,440 --> 00:25:57,130
better more high-level libraries so you

00:25:51,130 --> 00:26:00,850
could just do your things without

00:25:57,130 --> 00:26:02,410
thinking about low-level stuff it's just

00:26:00,850 --> 00:26:04,720
any initiative

00:26:02,410 --> 00:26:10,169
it was just created and if you have any

00:26:04,720 --> 00:26:10,169
ideas just come and comment there and

00:26:10,470 --> 00:26:19,240
there will be a link in the end well

00:26:15,340 --> 00:26:27,220
also there is STD web draw script

00:26:19,240 --> 00:26:30,429
bindings and a lot of libraries uses TD

00:26:27,220 --> 00:26:33,730
web I said as for Vogue girl or

00:26:30,429 --> 00:26:37,120
endurance and overall a lot of people

00:26:33,730 --> 00:26:41,250
use this to develop and previously they

00:26:37,120 --> 00:26:45,400
were not compatible with wasn't binding

00:26:41,250 --> 00:26:48,549
and even someone started to rewrite from

00:26:45,400 --> 00:26:52,090
mr. debate was invention but recently

00:26:48,549 --> 00:26:54,549
like three or four days ago there was a

00:26:52,090 --> 00:26:57,580
religious support of compatibility

00:26:54,549 --> 00:27:06,250
between STD web and must-buy engine you

00:26:57,580 --> 00:27:09,190
can use both and it is really awesome it

00:27:06,250 --> 00:27:11,740
just initial support expect bugs but I

00:27:09,190 --> 00:27:13,550
highly encourage you to try it it's

00:27:11,740 --> 00:27:16,990
really cool thing

00:27:13,550 --> 00:27:21,050
also remember the host bindings proposal

00:27:16,990 --> 00:27:23,990
in JavaScript community it was recently

00:27:21,050 --> 00:27:28,040
renamed to web idea bindings proposal

00:27:23,990 --> 00:27:36,400
and vast Benjen uses web idea to

00:27:28,040 --> 00:27:40,840
generate some of JavaScript bindings and

00:27:36,400 --> 00:27:45,470
finally again new thing or y'see

00:27:40,840 --> 00:27:48,790
it is a system interface for things like

00:27:45,470 --> 00:27:51,470
file system or well currently in

00:27:48,790 --> 00:27:54,190
webassembly there is no Esther diode

00:27:51,470 --> 00:27:57,350
support you cannot just print something

00:27:54,190 --> 00:28:01,640
which Bazzi you will be able it is

00:27:57,350 --> 00:28:07,180
already on nightly you can test it well

00:28:01,640 --> 00:28:07,180
and that that's oh thank you very much

00:28:09,170 --> 00:28:13,760
how do you handle the problem of

00:28:11,350 --> 00:28:15,380
debugging webassembly when something

00:28:13,760 --> 00:28:18,380
really goes wrong in the rust

00:28:15,380 --> 00:28:21,740
webassembly backup so when you need to

00:28:18,380 --> 00:28:25,130
debug the outputted webassembly binary

00:28:21,740 --> 00:28:32,320
or the wrapper javascript code how to

00:28:25,130 --> 00:28:32,320
handle this problem and dreaming

00:28:32,560 --> 00:28:39,980
debugging they're compiling

00:28:34,820 --> 00:28:42,410
infrastructure or both both the rasta c

00:28:39,980 --> 00:28:46,070
compiler architecture and also your

00:28:42,410 --> 00:28:51,350
wasn't by ingesting okay the question is

00:28:46,070 --> 00:28:53,990
how do i do bug yeah well when I had

00:28:51,350 --> 00:28:57,920
troubles with JavaScript and Russ

00:28:53,990 --> 00:29:01,640
incompatibility I could specifically in

00:28:57,920 --> 00:29:02,900
float the handle floats a little bit

00:29:01,640 --> 00:29:07,840
differently

00:29:02,900 --> 00:29:13,190
I just compiled my rust natively to

00:29:07,840 --> 00:29:16,790
native then the packet and then well so

00:29:13,190 --> 00:29:20,300
usually I don't do back but if well I I

00:29:16,790 --> 00:29:22,880
read code there is a hard hard story

00:29:20,300 --> 00:29:26,360
with the bug in people work on it they

00:29:22,880 --> 00:29:29,180
want to generate JavaScript then

00:29:26,360 --> 00:29:32,840
generate source maps to web assembly and

00:29:29,180 --> 00:29:37,930
then the back is through it but it is an

00:29:32,840 --> 00:29:37,930

YouTube URL: https://www.youtube.com/watch?v=C10gSyxO4i4


