Title: RustCon Asia 2019 - Nick Cameron: Making Rust Delightful
Publication date: 2019-04-30
Playlist: RustCon Asia 2019
Description: 
	Rust strives to be an ergonomic language: easy to read, easy to write, and easy to maintain. We want it to be a language which delights! But what does that mean? How do the language and library designers decide what makes a feature ergonomic? And how do we consider the trade-offs between ergonomics and other design pressures such as safety and performance?

I’ll cover Rust’s design philosophy, some case studies on ergonomics from the language, libraries, and tools, and talk about how design decisions are made by the language team and others. I’ll talk about issues such as ‘explicit vs implicit’, syntactic sugar, and consistency.

Find slides here: https://github.com/nrc/talks/blob/master/rustcon-asia-19/making-rust-delightful.pdf

Follow us on Twitter: https://twitter.com/RustConAsia
Captions: 
	00:00:04,630 --> 00:00:09,600
okay again this is Nick from the core

00:00:07,390 --> 00:00:09,600
team

00:00:11,219 --> 00:00:17,759
I thank you so I'm gonna make my excuses

00:00:15,449 --> 00:00:20,759
before I even start is using this other

00:00:17,759 --> 00:00:23,099
computer I don't have my notes so if I

00:00:20,759 --> 00:00:30,390
miss and forget and stumble you have to

00:00:23,099 --> 00:00:33,600
forgive me so people choose rust for

00:00:30,390 --> 00:00:36,510
lots of different reasons the its memory

00:00:33,600 --> 00:00:38,760
safe it's fast there are no GC pauses

00:00:36,510 --> 00:00:45,300
and so on and so forth but you wouldn't

00:00:38,760 --> 00:00:47,190
use it if it were painful to use I look

00:00:45,300 --> 00:00:49,739
forward to programming and rust I get up

00:00:47,190 --> 00:00:51,659
in the morning and I go to work and I

00:00:49,739 --> 00:00:53,940
think yeah I get to use rust today it's

00:00:51,659 --> 00:00:56,359
a good day and I don't think like that

00:00:53,940 --> 00:00:58,440
about every programming language and

00:00:56,359 --> 00:01:01,769
apparently I'm not the only one because

00:00:58,440 --> 00:01:04,830
for the fourth year in the row the stack

00:01:01,769 --> 00:01:11,729
overflow developer survey has picked

00:01:04,830 --> 00:01:15,570
rust as the most loved language so in

00:01:11,729 --> 00:01:18,530
the talk today I want to try and say how

00:01:15,570 --> 00:01:18,530
we got to this point

00:01:22,560 --> 00:01:37,800
sure I have to stand close to the mic

00:01:25,770 --> 00:01:41,070
okay so the I think one of the really

00:01:37,800 --> 00:01:43,710
great one of the main reasons that rust

00:01:41,070 --> 00:01:47,190
is a delightful language to use is

00:01:43,710 --> 00:01:50,100
because the the Russ community has

00:01:47,190 --> 00:01:52,050
always tried to make it a delightful

00:01:50,100 --> 00:01:54,780
language to use and this sounds kind of

00:01:52,050 --> 00:01:57,240
obvious but it's very easy to get caught

00:01:54,780 --> 00:02:00,960
up in what's the most elegant solution

00:01:57,240 --> 00:02:03,630
or what's the most technically pleasing

00:02:00,960 --> 00:02:06,900
solution to a problem and not what will

00:02:03,630 --> 00:02:09,030
make it the the user the happiest ever

00:02:06,900 --> 00:02:11,190
since kind of the very first days of

00:02:09,030 --> 00:02:15,209
rust there's been this emphasis on

00:02:11,190 --> 00:02:16,650
making it a practical language it it was

00:02:15,209 --> 00:02:20,520
never set out to be kind of like primary

00:02:16,650 --> 00:02:25,940
like an academic thing or something in

00:02:20,520 --> 00:02:25,940
the in the run-up to the the 1.0 release

00:02:27,290 --> 00:02:33,630
this is why I need the notes sorry so in

00:02:31,500 --> 00:02:40,920
the one in the run up to the the 1.0

00:02:33,630 --> 00:02:42,660
release there was like a huge effort to

00:02:40,920 --> 00:02:45,930
actually get something released there

00:02:42,660 --> 00:02:47,250
was like we needed kind of like get all

00:02:45,930 --> 00:02:49,860
these kind of moving parts in the

00:02:47,250 --> 00:02:53,250
language and and the library is all

00:02:49,860 --> 00:02:55,860
working together and but there was also

00:02:53,250 --> 00:02:58,380
this sense that like once your once you

00:02:55,860 --> 00:03:00,360
have the 1.0 release you you can't go

00:02:58,380 --> 00:03:02,040
back we've got this backwards

00:03:00,360 --> 00:03:03,299
compatibility guarantee and it's not

00:03:02,040 --> 00:03:06,320
good enough to make just a language

00:03:03,299 --> 00:03:12,360
which exists it has to be kind of

00:03:06,320 --> 00:03:15,120
pleasant to use it and then after the

00:03:12,360 --> 00:03:17,190
1.0 release there's a period where we

00:03:15,120 --> 00:03:22,459
were kind of like landing some some more

00:03:17,190 --> 00:03:24,660
big changes and in I think 2017 we

00:03:22,459 --> 00:03:28,820
announced the ergonomics initiative

00:03:24,660 --> 00:03:33,209
which was to refocus on usability and

00:03:28,820 --> 00:03:35,580
the ergonomics of the language and it

00:03:33,209 --> 00:03:38,190
was kind of between kind of like

00:03:35,580 --> 00:03:40,740
the the 1.0 release and the ergonomics

00:03:38,190 --> 00:03:42,720
initiative that this idea of programming

00:03:40,740 --> 00:03:45,260
language ergonomics really became kind

00:03:42,720 --> 00:03:52,350
of a fundamental goal for the language

00:03:45,260 --> 00:03:54,600
and now we're we had the 2018 edition

00:03:52,350 --> 00:03:56,970
release and we've kind of in another

00:03:54,600 --> 00:04:00,270
phase where I think we we want kind of

00:03:56,970 --> 00:04:05,130
like look away from the the big things

00:04:00,270 --> 00:04:08,970
and look at making making the usability

00:04:05,130 --> 00:04:11,490
of the language much better again okay

00:04:08,970 --> 00:04:14,970
so for the rest of the talk I'm gonna

00:04:11,490 --> 00:04:15,720
start by going over some general issues

00:04:14,970 --> 00:04:17,910
around

00:04:15,720 --> 00:04:22,230
ergonomics and then in turn I'm going to

00:04:17,910 --> 00:04:24,090
look at the tools libraries and the

00:04:22,230 --> 00:04:29,330
language itself and how we think about

00:04:24,090 --> 00:04:32,550
ergonomics within each of this domains

00:04:29,330 --> 00:04:34,560
okay so economics is usually something

00:04:32,550 --> 00:04:36,390
you think about with hardware you'd say

00:04:34,560 --> 00:04:38,150
like this is an ergonomic chair or an

00:04:36,390 --> 00:04:40,230
ergonomic keyboard

00:04:38,150 --> 00:04:43,920
what does ergonomics mean for a

00:04:40,230 --> 00:04:47,130
programming language and primarily it's

00:04:43,920 --> 00:04:49,940
the the language helps you to be

00:04:47,130 --> 00:04:55,590
efficient there's an absence of friction

00:04:49,940 --> 00:04:58,170
and there we prevent you getting injured

00:04:55,590 --> 00:05:01,020
in in some way whatever that means for a

00:04:58,170 --> 00:05:05,190
programming language a little bit more

00:05:01,020 --> 00:05:08,160
concretely we think that the language is

00:05:05,190 --> 00:05:11,340
is an economic one when the code you

00:05:08,160 --> 00:05:13,260
write closely matches the mental model

00:05:11,340 --> 00:05:21,720
of the program that you have in your

00:05:13,260 --> 00:05:25,070
head an example of this is if you want

00:05:21,720 --> 00:05:28,140
to have data that can represent multiple

00:05:25,070 --> 00:05:30,060
variants then you can even write this

00:05:28,140 --> 00:05:33,540
using kind of classes and inheritance

00:05:30,060 --> 00:05:36,750
and it and it works but in rust we give

00:05:33,540 --> 00:05:41,340
you in ins and enums and variants much

00:05:36,750 --> 00:05:43,440
more closely match that mental model and

00:05:41,340 --> 00:05:45,960
and so this is reducing friction and

00:05:43,440 --> 00:05:48,169
making your program easier it's a reason

00:05:45,960 --> 00:05:48,169
about

00:05:48,669 --> 00:05:57,099
but I said at the beginning that one of

00:05:54,969 --> 00:05:59,319
the reasons we've ended up with a

00:05:57,099 --> 00:06:01,659
language which is I think quite pleasant

00:05:59,319 --> 00:06:03,729
use is because we've we focused on that

00:06:01,659 --> 00:06:06,340
so why doesn't everybody focus on it

00:06:03,729 --> 00:06:08,669
well I think one reason is it's really

00:06:06,340 --> 00:06:11,050
difficult

00:06:08,669 --> 00:06:13,539
ergonomics is all about people it's

00:06:11,050 --> 00:06:15,099
about your users and anything to do with

00:06:13,539 --> 00:06:19,629
people is always difficult because

00:06:15,099 --> 00:06:22,500
people are complicated and all people

00:06:19,629 --> 00:06:24,340
are different in some way and it's it's

00:06:22,500 --> 00:06:26,409
especially for people with a very

00:06:24,340 --> 00:06:29,729
technical mindset often it's it's

00:06:26,409 --> 00:06:33,840
difficult to think about these issues

00:06:29,729 --> 00:06:36,099
it's it's full of gray areas and fuzzy

00:06:33,840 --> 00:06:38,500
questions and there's no like hard

00:06:36,099 --> 00:06:42,669
answers it's it's just all kind of

00:06:38,500 --> 00:06:45,759
trade-offs and there's a lot of context

00:06:42,669 --> 00:06:47,740
what works well for one library might

00:06:45,759 --> 00:06:49,569
not work in another library what works

00:06:47,740 --> 00:06:51,430
for one programming language might not

00:06:49,569 --> 00:06:53,620
work in another one so just because

00:06:51,430 --> 00:06:57,810
something's ergonomic and say Python

00:06:53,620 --> 00:07:03,879
doesn't mean that it's ergonomic in rust

00:06:57,810 --> 00:07:07,210
and there's all sorts of cross-cutting

00:07:03,879 --> 00:07:11,319
concerns and intersections for example

00:07:07,210 --> 00:07:13,389
if your user is using an IDE as opposed

00:07:11,319 --> 00:07:16,649
to say vim then you're going to have a

00:07:13,389 --> 00:07:20,969
very different experience of what's

00:07:16,649 --> 00:07:20,969
economic in the language and what's not

00:07:21,270 --> 00:07:28,029
so if it's so difficult how do we

00:07:23,830 --> 00:07:29,560
actually make decisions about this in an

00:07:28,029 --> 00:07:36,219
ideal world would be very scientific

00:07:29,560 --> 00:07:38,439
would conduct user studies we would come

00:07:36,219 --> 00:07:40,990
up with you know evidence and data and

00:07:38,439 --> 00:07:43,599
so forth but this is actually really

00:07:40,990 --> 00:07:46,060
difficult it's a set of skills that have

00:07:43,599 --> 00:07:47,680
have not really existed in the Ross

00:07:46,060 --> 00:07:50,110
community and more importantly we just

00:07:47,680 --> 00:07:53,500
don't have the resources to to do this

00:07:50,110 --> 00:07:55,300
kind of work and even if we did even if

00:07:53,500 --> 00:07:57,099
you have some nice crisp scientific

00:07:55,300 --> 00:07:59,649
answers well you still have you know

00:07:57,099 --> 00:08:03,330
which users do you study which questions

00:07:59,649 --> 00:08:03,330
do you ask and so forth

00:08:04,090 --> 00:08:09,590
thinking about use cases can help but

00:08:07,700 --> 00:08:12,230
there is a risk fair that you over

00:08:09,590 --> 00:08:14,690
specialize that you like language

00:08:12,230 --> 00:08:18,980
designed by kind of addressing use cases

00:08:14,690 --> 00:08:22,250
January doesn't work out so well but we

00:08:18,980 --> 00:08:24,800
can we can also explicitly ask users and

00:08:22,250 --> 00:08:27,320
even when we don't ask we get plenty of

00:08:24,800 --> 00:08:32,419
feedback through the RFC process and

00:08:27,320 --> 00:08:34,580
other channels and there's a lot of rust

00:08:32,419 --> 00:08:37,969
code that already exists we can look at

00:08:34,580 --> 00:08:40,130
how people use rust today or happiest

00:08:37,969 --> 00:08:43,400
Pat rust in the past and with tools like

00:08:40,130 --> 00:08:48,589
crate so we can actually look at almost

00:08:43,400 --> 00:08:51,589
the entire ecosystem of rust code but

00:08:48,589 --> 00:08:55,520
the really most important tool I think

00:08:51,589 --> 00:08:59,870
is empathy and this is for for any of

00:08:55,520 --> 00:09:02,839
the rust design teams being able to kind

00:08:59,870 --> 00:09:05,750
of use empathy is a really important

00:09:02,839 --> 00:09:07,790
skill and it's about being able to

00:09:05,750 --> 00:09:09,740
imagine who your users are what their

00:09:07,790 --> 00:09:12,020
environment is what their background is

00:09:09,740 --> 00:09:15,500
and what problems are they trying to

00:09:12,020 --> 00:09:19,610
solve and then put yourself in in those

00:09:15,500 --> 00:09:25,070
users positions and and use that to kind

00:09:19,610 --> 00:09:26,660
of drive your decision-making having

00:09:25,070 --> 00:09:30,620
said that there are some kind of

00:09:26,660 --> 00:09:33,200
principles and heuristics that I and I

00:09:30,620 --> 00:09:35,960
think others in the rust leadership

00:09:33,200 --> 00:09:37,430
teams kind of stand by and throughout

00:09:35,960 --> 00:09:41,900
the talk I'm going to try and highlight

00:09:37,430 --> 00:09:43,640
some of these a first one is that doing

00:09:41,900 --> 00:09:48,980
the right thing ought to be the easiest

00:09:43,640 --> 00:09:51,410
thing to do the the complication of

00:09:48,980 --> 00:09:55,010
course is what is the right thing often

00:09:51,410 --> 00:10:00,140
it's the most performant thing or the

00:09:55,010 --> 00:10:02,930
the safest thing important things should

00:10:00,140 --> 00:10:05,750
be explicit and there's a corollary to

00:10:02,930 --> 00:10:08,209
that which is that things that are not

00:10:05,750 --> 00:10:10,100
important should be implicit

00:10:08,209 --> 00:10:11,690
you shouldn't have to write lots of

00:10:10,100 --> 00:10:14,980
boilerplate we'll go through lots of

00:10:11,690 --> 00:10:14,980
ceremony to get your work done

00:10:15,160 --> 00:10:21,140
again this begs the question what's

00:10:17,690 --> 00:10:23,120
important and this is a really hard

00:10:21,140 --> 00:10:24,950
question because it gets back to every

00:10:23,120 --> 00:10:26,510
user being different what's important

00:10:24,950 --> 00:10:31,910
for one user might not be important for

00:10:26,510 --> 00:10:33,500
another and well so one thing that just

00:10:31,910 --> 00:10:35,680
a pic kind of something concrete that is

00:10:33,500 --> 00:10:39,140
often important in rust it

00:10:35,680 --> 00:10:41,180
ownership/borrowing these are really

00:10:39,140 --> 00:10:44,860
important concepts in rust and are often

00:10:41,180 --> 00:10:44,860
things that we want to make explicit

00:10:46,570 --> 00:10:58,730
okay so I'm going to start by talking

00:10:49,640 --> 00:11:01,280
about tools one of the core principles

00:10:58,730 --> 00:11:04,520
in developing the the rust tool

00:11:01,280 --> 00:11:07,100
ecosystem has been to to put the user

00:11:04,520 --> 00:11:09,110
first and again this sounds really

00:11:07,100 --> 00:11:11,360
obvious thing but there are lots of

00:11:09,110 --> 00:11:13,250
other kind of design constraints do you

00:11:11,360 --> 00:11:15,170
want to make your tool fast do you want

00:11:13,250 --> 00:11:19,030
to make your tool scriptable should the

00:11:15,170 --> 00:11:22,700
output be machine readable these are all

00:11:19,030 --> 00:11:24,860
important goals but I believe they

00:11:22,700 --> 00:11:27,710
should be secondary what's really

00:11:24,860 --> 00:11:32,200
important is the user interacting with

00:11:27,710 --> 00:11:32,200
the tool should have a good experience a

00:11:32,560 --> 00:11:39,230
principle that we come back to again and

00:11:35,120 --> 00:11:41,390
again is consistency I four tools that

00:11:39,230 --> 00:11:43,760
means if you if at all can do multiple

00:11:41,390 --> 00:11:47,120
different things then it should do them

00:11:43,760 --> 00:11:49,490
in a similar way and between tools we

00:11:47,120 --> 00:11:53,120
should try and stick to the same kind of

00:11:49,490 --> 00:11:56,120
user experience and this is this makes

00:11:53,120 --> 00:11:58,490
the tools ergonomic because you spend

00:11:56,120 --> 00:12:01,070
less time looking up how it all works

00:11:58,490 --> 00:12:03,430
and you can apply the usage patterns

00:12:01,070 --> 00:12:08,300
you've you've got from using other tools

00:12:03,430 --> 00:12:10,160
so when you come to a new tool it should

00:12:08,300 --> 00:12:15,110
just work you should it should be

00:12:10,160 --> 00:12:17,540
intuitive to you another principle that

00:12:15,110 --> 00:12:20,360
we usually stick to is convention over

00:12:17,540 --> 00:12:22,010
configuration where we're not extreme

00:12:20,360 --> 00:12:24,260
about this we like to offer you ways to

00:12:22,010 --> 00:12:26,360
configure your tools because that's

00:12:24,260 --> 00:12:28,130
important every user is different every

00:12:26,360 --> 00:12:30,649
users trying to do different things

00:12:28,130 --> 00:12:34,490
but the idea is that if you're doing

00:12:30,649 --> 00:12:38,209
something common then the tool should

00:12:34,490 --> 00:12:42,440
just work you should not have to create

00:12:38,209 --> 00:12:47,480
a configuration file if you're using a

00:12:42,440 --> 00:12:50,740
at all in the normal kind of way so I

00:12:47,480 --> 00:12:52,940
want to go through an example to show

00:12:50,740 --> 00:12:55,339
how these principles apply in practice

00:12:52,940 --> 00:12:57,709
let's say you want to format some code

00:12:55,339 --> 00:13:01,579
well you can use the russ format tool to

00:12:57,709 --> 00:13:03,560
do this and in order to make it you have

00:13:01,579 --> 00:13:05,720
to install this tool on your computer

00:13:03,560 --> 00:13:07,819
and in order to make this whole flow as

00:13:05,720 --> 00:13:11,779
easy as possible we provide a tool for

00:13:07,819 --> 00:13:14,000
installing these tools okay so you run

00:13:11,779 --> 00:13:17,899
rust up and this is the same thing you

00:13:14,000 --> 00:13:22,120
would run rust up to install other tools

00:13:17,899 --> 00:13:24,050
and to install things like source code

00:13:22,120 --> 00:13:26,569
once it's installed

00:13:24,050 --> 00:13:30,259
and hopefully that was easy to install

00:13:26,569 --> 00:13:33,980
it running rust for map is consistent

00:13:30,259 --> 00:13:36,560
with other cargo commands you run it

00:13:33,980 --> 00:13:39,380
just like you would run car go build

00:13:36,560 --> 00:13:40,870
your own carry out format and sticking

00:13:39,380 --> 00:13:43,790
to the convention of a configuration

00:13:40,870 --> 00:13:45,589
principle when you do this it should do

00:13:43,790 --> 00:13:47,720
the right thing if you have a regular

00:13:45,589 --> 00:13:52,069
cargo project it will reformat the whole

00:13:47,720 --> 00:13:54,350
project and nothing more and the

00:13:52,069 --> 00:13:57,019
formatting we use is hopefully something

00:13:54,350 --> 00:13:59,000
that you will approve of it's a sensible

00:13:57,019 --> 00:14:02,540
formatting which you can configure if

00:13:59,000 --> 00:14:04,160
you really want to and if you do have to

00:14:02,540 --> 00:14:07,430
do something unusual if you do need to

00:14:04,160 --> 00:14:11,839
pass some arguments to rust format then

00:14:07,430 --> 00:14:13,730
you can do that using the same arguments

00:14:11,839 --> 00:14:17,600
that you would pass to cargo build so

00:14:13,730 --> 00:14:23,209
there's consistency between these

00:14:17,600 --> 00:14:28,670
different tools a last principle I want

00:14:23,209 --> 00:14:32,600
to mention about tools is that tools are

00:14:28,670 --> 00:14:35,839
not just kind of like a robots or a

00:14:32,600 --> 00:14:38,510
hammer or something it's the the tools

00:14:35,839 --> 00:14:41,360
can teach the user and the best example

00:14:38,510 --> 00:14:44,130
of that is rust error messages

00:14:41,360 --> 00:14:45,930
so we can see this is the the rust error

00:14:44,130 --> 00:14:49,290
message from a few years back and this

00:14:45,930 --> 00:14:51,050
is how it looks today a lot of people

00:14:49,290 --> 00:14:57,650
will have put a lot of effort into

00:14:51,050 --> 00:14:59,880
making our error messages great and the

00:14:57,650 --> 00:15:01,440
the best example is probably borrow

00:14:59,880 --> 00:15:02,910
checking you know borrow checking is

00:15:01,440 --> 00:15:05,550
something a lot of people struggle with

00:15:02,910 --> 00:15:08,280
in rust especially as they're learning

00:15:05,550 --> 00:15:11,490
the language it's it's a pretty unique

00:15:08,280 --> 00:15:13,980
concept and so we put a lot of effort

00:15:11,490 --> 00:15:16,710
into the error messages not only to

00:15:13,980 --> 00:15:18,750
clearly explain the error but to help

00:15:16,710 --> 00:15:20,730
you learn from your mistake to not that

00:15:18,750 --> 00:15:22,620
make that mistake again to better

00:15:20,730 --> 00:15:26,820
understand what's going on inside the

00:15:22,620 --> 00:15:28,920
compiler and it's you know it's been a

00:15:26,820 --> 00:15:31,760
lot of work to do that it's not just

00:15:28,920 --> 00:15:34,710
about writing a nice message there's

00:15:31,760 --> 00:15:38,580
fundamental work in the compiler that

00:15:34,710 --> 00:15:40,410
make the compiler more complex in order

00:15:38,580 --> 00:15:43,110
to give you better error messages when

00:15:40,410 --> 00:15:47,760
you get a bourchek error and that's a

00:15:43,110 --> 00:15:50,910
great example of the ergonomics being a

00:15:47,760 --> 00:15:52,770
priority when we're doing kind of design

00:15:50,910 --> 00:15:55,700
work in the same way that you know

00:15:52,770 --> 00:15:55,700
performances

00:16:04,080 --> 00:16:12,340
next up I want to talk about the

00:16:06,430 --> 00:16:14,170
libraries again consistency is a really

00:16:12,340 --> 00:16:16,660
important principle here and for

00:16:14,170 --> 00:16:20,050
libraries this means consistency of

00:16:16,660 --> 00:16:23,500
naming it means consistency of usage

00:16:20,050 --> 00:16:25,480
patterns so if you're used to using a

00:16:23,500 --> 00:16:28,600
vac then when you start using a hashmap

00:16:25,480 --> 00:16:30,970
it'll be a similar experience and it

00:16:28,600 --> 00:16:33,010
means consistency in the declaration

00:16:30,970 --> 00:16:36,760
patterns as well so when you're reading

00:16:33,010 --> 00:16:38,880
the documentation or the source code you

00:16:36,760 --> 00:16:40,510
don't have too much friction between

00:16:38,880 --> 00:16:44,380
different data types or different

00:16:40,510 --> 00:16:49,720
functionality another principle is to

00:16:44,380 --> 00:16:52,990
minimize duplication a good example of

00:16:49,720 --> 00:16:55,270
this is prior to 1.0 there were seven

00:16:52,990 --> 00:16:57,700
different find methods on a on hash map

00:16:55,270 --> 00:16:59,380
seven and they were all doing

00:16:57,700 --> 00:17:03,450
essentially the same thing they were

00:16:59,380 --> 00:17:05,680
just doing a find but with you know

00:17:03,450 --> 00:17:07,570
slightly different semantics around

00:17:05,680 --> 00:17:17,980
referencing or ownership or something

00:17:07,570 --> 00:17:19,660
and that's very unorganized op and think

00:17:17,980 --> 00:17:25,170
do I use this find all this fine well

00:17:19,660 --> 00:17:28,450
all you want to do is find a value and

00:17:25,170 --> 00:17:29,950
that's unnecessary unnecessary ceremony

00:17:28,450 --> 00:17:32,110
because you're focusing on what's not

00:17:29,950 --> 00:17:35,050
important okay what's important is

00:17:32,110 --> 00:17:38,860
finding a value and what's not important

00:17:35,050 --> 00:17:44,650
and in this case is the state of the key

00:17:38,860 --> 00:17:47,080
I want to kind of like dig into this

00:17:44,650 --> 00:17:50,350
with an example so here we've got a hash

00:17:47,080 --> 00:17:53,860
map it's a mapping from strings to

00:17:50,350 --> 00:17:56,550
integers perhaps we're counting the

00:17:53,860 --> 00:17:59,740
words in a document or something and

00:17:56,550 --> 00:18:05,910
looking at the the signature of hash map

00:17:59,740 --> 00:18:09,060
here you would expect to take string and

00:18:05,910 --> 00:18:12,150
indeed if you can call gat like this

00:18:09,060 --> 00:18:14,560
where we take a reference to a string

00:18:12,150 --> 00:18:15,610
but it's actually much more common to

00:18:14,560 --> 00:18:18,370
use

00:18:15,610 --> 00:18:24,730
this type right which is a reference to

00:18:18,370 --> 00:18:28,300
a stir so how do we handle this note

00:18:24,730 --> 00:18:30,820
that this is not just a type and a

00:18:28,300 --> 00:18:35,620
reference or type these are two distinct

00:18:30,820 --> 00:18:38,260
types that are related in some way and

00:18:35,620 --> 00:18:40,060
just to make it more complicated when

00:18:38,260 --> 00:18:40,510
you insert something with it into the

00:18:40,060 --> 00:18:42,190
hashmap

00:18:40,510 --> 00:18:44,980
you don't want to allow our reference

00:18:42,190 --> 00:18:47,890
you own you want to to only have the own

00:18:44,980 --> 00:18:50,590
type and here the ownership is important

00:18:47,890 --> 00:18:52,600
and so you do have to think about it

00:18:50,590 --> 00:18:55,360
because if we let you pass references

00:18:52,600 --> 00:18:58,000
then the hashmap would have to clone

00:18:55,360 --> 00:19:00,190
that reference and that can be a really

00:18:58,000 --> 00:19:04,450
expensive operation so that's something

00:19:00,190 --> 00:19:06,580
that is possibly important for for users

00:19:04,450 --> 00:19:11,350
to know about and so we make our users

00:19:06,580 --> 00:19:13,780
be explicit so how do we kind of like

00:19:11,350 --> 00:19:16,000
make all this work well so let's have a

00:19:13,780 --> 00:19:18,010
look at the the signature for for

00:19:16,000 --> 00:19:20,200
hashmap this is kind of a slightly

00:19:18,010 --> 00:19:22,450
simplified version of the real hash map

00:19:20,200 --> 00:19:25,240
by the way so this is just a hash map

00:19:22,450 --> 00:19:31,090
from keys with type k2 values with type

00:19:25,240 --> 00:19:34,240
V and this is what the GAT method looks

00:19:31,090 --> 00:19:36,520
like and what's interesting here is you

00:19:34,240 --> 00:19:39,910
might expect get to take a reference to

00:19:36,520 --> 00:19:43,750
K but it doesn't we have this new type Q

00:19:39,910 --> 00:19:46,840
and we take a reference to Q and we use

00:19:43,750 --> 00:19:49,270
the trait called borrow to relate the

00:19:46,840 --> 00:19:52,270
types K and Q we say that K can be

00:19:49,270 --> 00:19:54,400
borrowed as Q and there are

00:19:52,270 --> 00:19:58,090
implementations for stuff like string

00:19:54,400 --> 00:20:00,640
and stir to make this connection and

00:19:58,090 --> 00:20:02,860
that's kind of complicated I'll go back

00:20:00,640 --> 00:20:04,510
a second this is kind of complicated you

00:20:02,860 --> 00:20:08,140
may well say well this is not very

00:20:04,510 --> 00:20:10,930
ergonomic and you'd be right but it does

00:20:08,140 --> 00:20:13,780
laughs this example work and I think

00:20:10,930 --> 00:20:15,970
that this usage is very ergonomic and

00:20:13,780 --> 00:20:18,550
furthermore not only does it work with

00:20:15,970 --> 00:20:19,750
strings but it works with VAX and slices

00:20:18,550 --> 00:20:21,760
and it works with all your other

00:20:19,750 --> 00:20:25,000
reference types as well so there's

00:20:21,760 --> 00:20:29,170
consistency here as well as eliminating

00:20:25,000 --> 00:20:33,160
duplication and this is a

00:20:29,170 --> 00:20:36,190
leads to another heuristic which is that

00:20:33,160 --> 00:20:39,040
if you have to trade off complexity in

00:20:36,190 --> 00:20:41,350
the in a library versus complexity in a

00:20:39,040 --> 00:20:43,750
client put the complexity in the library

00:20:41,350 --> 00:20:45,850
because hopefully many more people will

00:20:43,750 --> 00:20:51,400
use your library than write your library

00:20:45,850 --> 00:20:54,730
right and usually library authors are

00:20:51,400 --> 00:21:06,760
much more experienced developers and can

00:20:54,730 --> 00:21:12,040
better handle that complexity all right

00:21:06,760 --> 00:21:17,100
let's talk about language language is

00:21:12,040 --> 00:21:19,890
really about trade-offs a kind of really

00:21:17,100 --> 00:21:23,230
classic and a shred of a start with is

00:21:19,890 --> 00:21:27,060
kind of do you want to make a general

00:21:23,230 --> 00:21:31,510
solution or a very specific solution

00:21:27,060 --> 00:21:33,670
general might give you kind of less

00:21:31,510 --> 00:21:35,830
duplication but specific might be easier

00:21:33,670 --> 00:21:39,430
to understand so error handling is an

00:21:35,830 --> 00:21:41,830
example of this in Haskell you have do

00:21:39,430 --> 00:21:45,880
notation which handles any monadic type

00:21:41,830 --> 00:21:50,020
this is extremely general in Java and

00:21:45,880 --> 00:21:54,820
JavaScript you have syntax like throw

00:21:50,020 --> 00:21:57,130
which is extremely specific to exception

00:21:54,820 --> 00:21:58,480
types in rust we've picked the question

00:21:57,130 --> 00:22:03,690
mark operator which is somewhere in

00:21:58,480 --> 00:22:06,700
between you can supply your own generic

00:22:03,690 --> 00:22:09,490
arrow types you're not trapped into the

00:22:06,700 --> 00:22:12,370
rust ones but and it works with the

00:22:09,490 --> 00:22:16,020
option for example but you don't have

00:22:12,370 --> 00:22:20,290
the full generality of DU notation

00:22:16,020 --> 00:22:23,560
another trade-off is do you want a

00:22:20,290 --> 00:22:24,910
simple analysis so the compiler is doing

00:22:23,560 --> 00:22:26,920
an analysis that the programmer can

00:22:24,910 --> 00:22:29,530
actually understand or do you want

00:22:26,920 --> 00:22:32,530
something to be easy to use an example

00:22:29,530 --> 00:22:34,990
of this is the borrow checker prior to

00:22:32,530 --> 00:22:37,480
the 2080 in addition we had lexical

00:22:34,990 --> 00:22:41,290
lifetimes which as a concept are pretty

00:22:37,480 --> 00:22:43,059
easy to explain it's not an easy concept

00:22:41,290 --> 00:22:46,899
to explain sorry it's rare

00:22:43,059 --> 00:22:51,220
EEZ since the 2080 in addition we have

00:22:46,899 --> 00:22:53,289
non lexical lifetimes nll which is much

00:22:51,220 --> 00:22:57,279
harder to explain I could not sit down

00:22:53,289 --> 00:22:59,350
and explain it to you but it does make

00:22:57,279 --> 00:23:01,659
the your programs easier to use it's

00:22:59,350 --> 00:23:04,659
often more ergonomic to use nll because

00:23:01,659 --> 00:23:09,340
you have to worry less about some

00:23:04,659 --> 00:23:11,620
borrowing errors and then the the

00:23:09,340 --> 00:23:16,809
biggest trade-off of all is between

00:23:11,620 --> 00:23:21,159
explicit and implicit an example of this

00:23:16,809 --> 00:23:23,830
and Russ is you usually don't need to

00:23:21,159 --> 00:23:27,210
annotate when you move a value so the

00:23:23,830 --> 00:23:30,399
difference between move and and copy is

00:23:27,210 --> 00:23:32,559
implicit but you do have to annotate

00:23:30,399 --> 00:23:34,119
when you borrow a value and so the

00:23:32,559 --> 00:23:38,100
difference between a borrowed reference

00:23:34,119 --> 00:23:40,869
and an owned reference is explicit and

00:23:38,100 --> 00:23:43,179
getting back to what's important it's

00:23:40,869 --> 00:23:45,009
the ownership that's important in rust

00:23:43,179 --> 00:23:46,600
and so that's why you have to make

00:23:45,009 --> 00:23:48,460
explicit whether something is owned or

00:23:46,600 --> 00:23:50,769
borrowed but whether it's moved or

00:23:48,460 --> 00:23:56,379
copied we think is not as important so

00:23:50,769 --> 00:23:58,299
that is left implicit I'm gonna try and

00:23:56,379 --> 00:24:03,309
put all this together with another

00:23:58,299 --> 00:24:07,419
example this is a common way to match an

00:24:03,309 --> 00:24:10,149
expression this is pre 2018 edition code

00:24:07,419 --> 00:24:12,940
and what's really important here well

00:24:10,149 --> 00:24:14,470
the important thing is that you're

00:24:12,940 --> 00:24:20,559
matching you're doing some pattern

00:24:14,470 --> 00:24:23,799
matching and the the you've got the the

00:24:20,559 --> 00:24:26,909
two variants some and none and in the

00:24:23,799 --> 00:24:30,909
some case you're binding the variable ax

00:24:26,909 --> 00:24:33,970
what's not important well exactly like

00:24:30,909 --> 00:24:36,639
the fact that X is going to end up

00:24:33,970 --> 00:24:39,549
borrowed is kind of important but we

00:24:36,639 --> 00:24:42,639
know that what's not important is

00:24:39,549 --> 00:24:45,940
exactly how that borrowing flows from

00:24:42,639 --> 00:24:50,470
the outer X variable insert the the

00:24:45,940 --> 00:24:54,399
matched variable yeah this is just kind

00:24:50,470 --> 00:24:56,050
of type Tetris you you just have to play

00:24:54,399 --> 00:25:01,150
until you got it right usually

00:24:56,050 --> 00:25:03,100
and so with the 28 in addition we've

00:25:01,150 --> 00:25:04,780
eliminated that we think it's not

00:25:03,100 --> 00:25:06,850
important so you can leave it implicit

00:25:04,780 --> 00:25:09,370
and concentrate on what's important and

00:25:06,850 --> 00:25:10,750
hopefully this is easier to write you

00:25:09,370 --> 00:25:12,130
don't need to worry about this stuff and

00:25:10,750 --> 00:25:15,810
it's easier to read there's less

00:25:12,130 --> 00:25:18,040
distraction the downside is that the

00:25:15,810 --> 00:25:24,130
analysis the compiler doing has got more

00:25:18,040 --> 00:25:25,990
complex okay so what does the future

00:25:24,130 --> 00:25:31,110
hold are we done

00:25:25,990 --> 00:25:33,670
I mean it's a it's apparently a

00:25:31,110 --> 00:25:37,360
well-loved language already what we're

00:25:33,670 --> 00:25:39,820
not obviously a core principle of of

00:25:37,360 --> 00:25:43,030
rust is about stability without

00:25:39,820 --> 00:25:45,070
stagnation we want to maintain backwards

00:25:43,030 --> 00:25:51,220
compatibility but we also want to keep

00:25:45,070 --> 00:25:53,170
making rust better and that's

00:25:51,220 --> 00:25:55,960
particularly true in the areas of of

00:25:53,170 --> 00:25:58,450
ergonomics unfortunately this gets more

00:25:55,960 --> 00:26:01,060
difficult as you get more and more users

00:25:58,450 --> 00:26:03,130
and those users have relatively more and

00:26:01,060 --> 00:26:06,220
more experience there's a lot of kind of

00:26:03,130 --> 00:26:08,470
pushback stop energy on what you can do

00:26:06,220 --> 00:26:14,020
because people know how to do stuff

00:26:08,470 --> 00:26:18,370
they've got used to it what you know

00:26:14,020 --> 00:26:21,340
what might be a total showstopper for a

00:26:18,370 --> 00:26:23,530
new rust user is just a paper cut for an

00:26:21,340 --> 00:26:24,790
experienced rust user and if it's not a

00:26:23,530 --> 00:26:26,470
problem for them they don't want change

00:26:24,790 --> 00:26:34,720
for the sake of change because change is

00:26:26,470 --> 00:26:36,310
painful but we want to continue making

00:26:34,720 --> 00:26:38,200
positive change we want to continue

00:26:36,310 --> 00:26:41,710
making rusts better so a few things that

00:26:38,200 --> 00:26:44,140
we might do I'm not saying that we will

00:26:41,710 --> 00:26:46,840
I talked a little bit about error

00:26:44,140 --> 00:26:50,410
handling earlier well I still think that

00:26:46,840 --> 00:26:54,460
it's not perfect to me if I've got a

00:26:50,410 --> 00:26:56,980
function that looks like this there's a

00:26:54,460 --> 00:27:00,160
lot of boilerplate there why do I have

00:26:56,980 --> 00:27:03,340
this okay and all these parenthesis of

00:27:00,160 --> 00:27:05,560
the bar bottom like if I if I if I'm not

00:27:03,340 --> 00:27:09,040
doing the error handling I don't need to

00:27:05,560 --> 00:27:09,870
put the parenthesis there and why do I

00:27:09,040 --> 00:27:12,630
need to declare

00:27:09,870 --> 00:27:15,510
result it's like if we're thinking about

00:27:12,630 --> 00:27:17,340
convention of a configuration 99% of the

00:27:15,510 --> 00:27:20,910
time you are using result why do I have

00:27:17,340 --> 00:27:22,920
to write that out so maybe we can do

00:27:20,910 --> 00:27:25,080
something about that here's another case

00:27:22,920 --> 00:27:27,120
why I said earlier that it's often

00:27:25,080 --> 00:27:28,860
important that you know whether

00:27:27,120 --> 00:27:30,210
something is borrowed or owned but if

00:27:28,860 --> 00:27:34,080
it's a copy type it doesn't really

00:27:30,210 --> 00:27:37,470
matter so why when I expect a reference

00:27:34,080 --> 00:27:39,750
do I have to explicitly borrow a copy

00:27:37,470 --> 00:27:41,850
type when it makes no difference to the

00:27:39,750 --> 00:27:44,910
caller this is another kind of kind of

00:27:41,850 --> 00:27:49,620
useless ceremony so maybe we can do

00:27:44,910 --> 00:27:51,510
something there and async/await

00:27:49,620 --> 00:27:53,670
is probably the most exciting thing to

00:27:51,510 --> 00:27:55,290
happen to rust since the whompin over

00:27:53,670 --> 00:27:57,300
lease and this is all about

00:27:55,290 --> 00:28:00,179
ergonomics you can write using futures

00:27:57,300 --> 00:28:03,120
today and it works it's fine it's very

00:28:00,179 --> 00:28:05,850
fast it's very safe but it's not very

00:28:03,120 --> 00:28:09,210
ergonomic it's it's a pain to write all

00:28:05,850 --> 00:28:13,620
your futures code with async/await we we

00:28:09,210 --> 00:28:16,080
make things much more pleasant on the

00:28:13,620 --> 00:28:19,080
tool size our areas are still not

00:28:16,080 --> 00:28:23,640
perfect I would not think this is a

00:28:19,080 --> 00:28:26,720
useful error we can do better okay

00:28:23,640 --> 00:28:29,640
that's the whole talk just to summarize

00:28:26,720 --> 00:28:33,330
well there's no easy answer there's no

00:28:29,640 --> 00:28:37,080
easy takeaway here working with users

00:28:33,330 --> 00:28:40,470
making things usable is hard work you

00:28:37,080 --> 00:28:43,320
need intention you have to want to do it

00:28:40,470 --> 00:28:46,980
you need to keep putting the effort in

00:28:43,320 --> 00:28:49,559
to make things better and the the key

00:28:46,980 --> 00:28:54,780
tool you have to make things better is

00:28:49,559 --> 00:28:57,750
empathy and you need to relentlessly

00:28:54,780 --> 00:29:01,380
focus on what is important and what is

00:28:57,750 --> 00:29:04,559
important for your users not what is

00:29:01,380 --> 00:29:06,570
important for you or you and your

00:29:04,559 --> 00:29:11,400
friends or you in your colleagues or

00:29:06,570 --> 00:29:13,470
something okay that's everything quickly

00:29:11,400 --> 00:29:15,720
I just want to thank Brian Anderson and

00:29:13,470 --> 00:29:18,360
Nika Markus who gave some really

00:29:15,720 --> 00:29:20,300
valuable input to this talk and I want

00:29:18,360 --> 00:29:21,970
to thank you all for sitting through it

00:29:20,300 --> 00:29:23,890
thank you

00:29:21,970 --> 00:29:28,040
[Applause]

00:29:23,890 --> 00:29:30,550
sanim the q10 Oliver winces our window

00:29:28,040 --> 00:29:30,550
you sure

00:29:35,900 --> 00:29:41,600
API consistency is very important in

00:29:38,330 --> 00:29:44,570
library but some consistency is ensured

00:29:41,600 --> 00:29:48,110
by the design of the library directive l

00:29:44,570 --> 00:29:51,320
of her no such as the flat map method on

00:29:48,110 --> 00:29:53,840
option on without an iterator or other

00:29:51,320 --> 00:29:56,680
things do you think that rust should

00:29:53,840 --> 00:30:01,220
import some high order traits

00:29:56,680 --> 00:30:06,170
abstractions such as such as functor

00:30:01,220 --> 00:30:09,920
applicative or moneda in Haskell - first

00:30:06,170 --> 00:30:13,270
the library developer to keep the

00:30:09,920 --> 00:30:20,260
consistent to keep the avi consistency

00:30:13,270 --> 00:30:20,260
explicitly that's an excellent question

00:30:20,630 --> 00:30:24,980
just to repeat for the audience I did

00:30:23,570 --> 00:30:27,530
the gist of the question is should we be

00:30:24,980 --> 00:30:31,850
using kind of more sophisticated type

00:30:27,530 --> 00:30:36,080
system things like high higher kind of

00:30:31,850 --> 00:30:40,040
types or functors and so forth in order

00:30:36,080 --> 00:30:43,310
to enforce generality across the the

00:30:40,040 --> 00:30:47,840
libraries and I think this gets back to

00:30:43,310 --> 00:30:53,060
an yet another trade-off which is do you

00:30:47,840 --> 00:30:55,760
want to make your your code as reusable

00:30:53,060 --> 00:30:58,310
as possible even if that comes at the

00:30:55,760 --> 00:31:00,200
expense of a more complex type system or

00:30:58,310 --> 00:31:03,350
do you want a really simple type system

00:31:00,200 --> 00:31:06,080
where you you lose some safety or you

00:31:03,350 --> 00:31:07,730
lose some reusability and like with a

00:31:06,080 --> 00:31:10,220
lot of things rust is somewhere in the

00:31:07,730 --> 00:31:12,200
middle where you know we do have very

00:31:10,220 --> 00:31:15,380
expressive generics but we don't have

00:31:12,200 --> 00:31:19,220
higher kind of types and at the moment

00:31:15,380 --> 00:31:22,900
we think that that is the right place on

00:31:19,220 --> 00:31:26,090
that spectrum there are a few things

00:31:22,900 --> 00:31:29,980
coming up like generic associated types

00:31:26,090 --> 00:31:34,130
which movers a little bit kind of to

00:31:29,980 --> 00:31:35,270
further towards more generality but in

00:31:34,130 --> 00:31:38,360
general

00:31:35,270 --> 00:31:40,160
I think the things like higher kind of

00:31:38,360 --> 00:31:42,800
types are not a good fit for rust and

00:31:40,160 --> 00:31:44,330
and again it's getting back to kind of

00:31:42,800 --> 00:31:46,190
the beginning of the talk I said that

00:31:44,330 --> 00:31:48,050
context was really important what works

00:31:46,190 --> 00:31:49,850
really well in Haskell what is really

00:31:48,050 --> 00:31:52,670
economic in Haskell is not necessarily

00:31:49,850 --> 00:31:55,460
really ergonomic and rust and I think

00:31:52,670 --> 00:32:00,110
yeah things like you know explicit

00:31:55,460 --> 00:32:05,690
monads or higher kind of types are not a

00:32:00,110 --> 00:32:08,230
good fit for rust thank you how about

00:32:05,690 --> 00:32:08,230
you mom

00:32:16,000 --> 00:32:20,240
hello niche I enjoyed your talk thank

00:32:19,850 --> 00:32:25,340
you

00:32:20,240 --> 00:32:29,300
so I am completely new to arrest her but

00:32:25,340 --> 00:32:32,990
before I did a C+ password so if I am

00:32:29,300 --> 00:32:36,740
considering switching from rust to rust

00:32:32,990 --> 00:32:40,700
so what kind of specific other ones it

00:32:36,740 --> 00:32:43,970
is I can get by the switching and maybe

00:32:40,700 --> 00:32:47,330
probably what kind of peace advantages

00:32:43,970 --> 00:32:51,670
what kind of a shortage does rust how

00:32:47,330 --> 00:32:51,670
currently so thank you

00:32:53,090 --> 00:32:59,000
so I repeat some of the question like

00:32:56,480 --> 00:33:03,860
what kind of shorts it like why are we

00:32:59,000 --> 00:33:07,850
deficient yeah yeah some maybe you want

00:33:03,860 --> 00:33:11,270
talk a little bit about the shortage of

00:33:07,850 --> 00:33:13,220
the current rust so compare the two

00:33:11,270 --> 00:33:16,760
steel as part you know supplies past

00:33:13,220 --> 00:33:21,140
I'll already have a very good very

00:33:16,760 --> 00:33:25,370
mature ecosystem so is there any

00:33:21,140 --> 00:33:26,800
shortage I between compared with the

00:33:25,370 --> 00:33:29,900
cicadas

00:33:26,800 --> 00:33:31,700
yeah I think there's kind of lots and I

00:33:29,900 --> 00:33:37,010
wouldn't even know where to start I

00:33:31,700 --> 00:33:40,940
think kind of on the sole on the

00:33:37,010 --> 00:33:42,950
language side sometimes kind of the the

00:33:40,940 --> 00:33:46,419
generics in C++ can be a bit more

00:33:42,950 --> 00:33:48,500
expressive than they are in rust and

00:33:46,419 --> 00:33:51,430
hopefully we can address the

00:33:48,500 --> 00:33:57,050
with better procedural macros and

00:33:51,430 --> 00:34:00,680
generic associated types error handling

00:33:57,050 --> 00:34:03,560
in C++ although kind of exception I

00:34:00,680 --> 00:34:05,420
think most kind of like real uses of C++

00:34:03,560 --> 00:34:08,899
kind of always turn off the the can

00:34:05,420 --> 00:34:11,810
don't use exception throwing but this is

00:34:08,899 --> 00:34:17,060
sometimes more more ergonomic than rust

00:34:11,810 --> 00:34:19,429
is I think obviously kind of like the

00:34:17,060 --> 00:34:22,520
the ecosystem is much more mature you

00:34:19,429 --> 00:34:25,040
know you could in in in in C++ you have

00:34:22,520 --> 00:34:27,530
a you can find libraries that do do

00:34:25,040 --> 00:34:30,860
everything I you know there's a lot of

00:34:27,530 --> 00:34:32,270
gaps in in rust support but you know

00:34:30,860 --> 00:34:35,929
that's getting better like literally

00:34:32,270 --> 00:34:38,870
every day and on the tool side

00:34:35,929 --> 00:34:42,200
the tools are kind of much more mature

00:34:38,870 --> 00:34:44,600
and more closely suited to C++ it would

00:34:42,200 --> 00:34:46,129
be great to have you know better IDE

00:34:44,600 --> 00:34:50,780
support or debuggers the better

00:34:46,129 --> 00:34:53,030
understand Russ natively thank you I I

00:34:50,780 --> 00:34:57,530
know that it takes some time to for

00:34:53,030 --> 00:35:02,270
rusty to get material so but what's the

00:34:57,530 --> 00:35:06,980
big advantages big gets are if I do the

00:35:02,270 --> 00:35:08,270
switching from tsipras pass to rust also

00:35:06,980 --> 00:35:11,980
the big gaps

00:35:08,270 --> 00:35:19,190
I mean advantages so talk about some

00:35:11,980 --> 00:35:21,650
advantages of rust compared to C C++ I'm

00:35:19,190 --> 00:35:23,930
not sure I understand the question very

00:35:21,650 --> 00:35:26,900
well maybe we can talk afterwards and I

00:35:23,930 --> 00:35:31,070
can answer you better okay it's okay

00:35:26,900 --> 00:35:33,950
it's okay thanks Jim Quincy woman how

00:35:31,070 --> 00:35:34,310
are you going to attack to have a happy

00:35:33,950 --> 00:35:39,650
ending

00:35:34,310 --> 00:35:43,240
did you quit negatory now we have

00:35:39,650 --> 00:35:47,900
library like third and some regular is

00:35:43,240 --> 00:35:52,580
expressions we use procedural macros and

00:35:47,900 --> 00:35:56,090
as far as I can I know the community and

00:35:52,580 --> 00:36:00,890
the core team is developing the constant

00:35:56,090 --> 00:36:03,440
function to re-meet rating from

00:36:00,890 --> 00:36:08,330
the procedural macro to constant

00:36:03,440 --> 00:36:12,250
function to make more economic the line

00:36:08,330 --> 00:36:21,920
language now there are pretty different

00:36:12,250 --> 00:36:26,120
use cases between the two not exactly

00:36:21,920 --> 00:36:31,760
sure how to procedural macros allow you

00:36:26,120 --> 00:36:36,710
to kind of like process kind of like

00:36:31,760 --> 00:36:38,300
input compile time as as if you were

00:36:36,710 --> 00:36:41,930
kind of like changing the language I

00:36:38,300 --> 00:36:44,420
guess and that's kind of very different

00:36:41,930 --> 00:36:47,500
from what Const functions let you do

00:36:44,420 --> 00:36:52,010
which is kind of much more limited

00:36:47,500 --> 00:36:59,420
compile time execution so yeah they have

00:36:52,010 --> 00:37:03,730
quite different scopes in my intending

00:36:59,420 --> 00:37:08,360
the custom function is some kind of

00:37:03,730 --> 00:37:12,470
constant reflection like for example if

00:37:08,360 --> 00:37:17,240
we have a regular expression input to

00:37:12,470 --> 00:37:21,590
the constant function we can output the

00:37:17,240 --> 00:37:26,660
Machine constant steam machine to to

00:37:21,590 --> 00:37:29,600
handle the strings I'm I'm not exactly

00:37:26,660 --> 00:37:31,460
sure for that particular use case but in

00:37:29,600 --> 00:37:40,340
general what you can do with Const

00:37:31,460 --> 00:37:41,810
functions is very limited I think this

00:37:40,340 --> 00:37:43,850
is probably again maybe something better

00:37:41,810 --> 00:37:46,040
to take outside so it's quite a detailed

00:37:43,850 --> 00:37:48,620
kind of thing to get into but at the end

00:37:46,040 --> 00:37:50,570
it like I think kind of like the the the

00:37:48,620 --> 00:37:52,910
big picture is that procedural macros

00:37:50,570 --> 00:37:55,370
are much more flexible and a much better

00:37:52,910 --> 00:38:00,320
suited for kind of processing this kind

00:37:55,370 --> 00:38:01,870
of input okay thank you okay thank you

00:38:00,320 --> 00:38:03,930
Nick

00:38:01,870 --> 00:38:03,930

YouTube URL: https://www.youtube.com/watch?v=YSEx8wtlPWc


