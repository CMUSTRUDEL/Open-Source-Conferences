Title: RustCon Asia 2019 - Ravi Shankar: How Rust taught me to think about systems
Publication date: 2019-04-30
Playlist: RustCon Asia 2019
Description: 
	All Rustaceans know that Rust’s borrow checker is merciless to newcomers. This talk covers the pain points encountered by me, back when I was a newcomer to Rust (and systems, in general). We’ll see a variety of situations which are totally normal in a number of high-level languages but not in Rust, how the same code differed in Rust, how the errors made sense after a while, and how that changed me to think about approaching problems from there on. If you’re looking for motivation to get into Rust, or if it made you angry or scared you away at some point, then this talk is for you!

Find slides here: https://reveal.waffles.space/presentations/rustcon-asia/#/

Follow us on Twitter: https://twitter.com/RustConAsia
Captions: 
	00:00:05,170 --> 00:00:15,199
hello everyone okay that's a lot of

00:00:09,950 --> 00:00:19,510
people and I feel pretty nervous but

00:00:15,199 --> 00:00:23,419
anyway welcome thanks for coming by

00:00:19,510 --> 00:00:26,509
today I'm gonna tell you a story a story

00:00:23,419 --> 00:00:29,509
of how Russ taught me to think about

00:00:26,509 --> 00:00:33,260
systems before we start I'd like to

00:00:29,509 --> 00:00:35,360
introduce myself I am Ravi I am a

00:00:33,260 --> 00:00:38,090
full-stack developer who loves frost

00:00:35,360 --> 00:00:42,740
swift typescript Cuban it is among other

00:00:38,090 --> 00:00:46,250
things and you can find me in github and

00:00:42,740 --> 00:00:47,750
Twitter in that handle and if you have

00:00:46,250 --> 00:00:51,290
trouble pronouncing my name you could

00:00:47,750 --> 00:00:56,630
just call me waffles okay

00:00:51,290 --> 00:01:01,910
anyway now yeah and I also run the Ross

00:00:56,630 --> 00:01:03,470
me meetup group in Chennai and that's

00:01:01,910 --> 00:01:07,900
partially because I'm a big fan of Frost

00:01:03,470 --> 00:01:12,590
the first thing I wanted to answer was

00:01:07,900 --> 00:01:17,359
how why this talk why I wanted to do

00:01:12,590 --> 00:01:18,829
this talk and if you for that we need to

00:01:17,359 --> 00:01:22,759
go through the facts the first thing is

00:01:18,829 --> 00:01:25,399
most of the people love frost that's

00:01:22,759 --> 00:01:29,840
based on this hacker flow survey over

00:01:25,399 --> 00:01:33,170
the past four years and and if you visit

00:01:29,840 --> 00:01:35,630
Twitter or hack news or credit or

00:01:33,170 --> 00:01:37,009
whatever you can find people praising

00:01:35,630 --> 00:01:39,259
about frost every now and then and

00:01:37,009 --> 00:01:43,850
that's one of the proof on the other

00:01:39,259 --> 00:01:45,530
hand if you see the newcomers almost all

00:01:43,850 --> 00:01:48,850
the time they are convincing the

00:01:45,530 --> 00:01:52,219
compiler that their code is fine and

00:01:48,850 --> 00:01:55,840
this is perfectly normal for anyone

00:01:52,219 --> 00:01:59,899
getting into rust I'm pretty sure

00:01:55,840 --> 00:02:01,399
everyone who tries to compile something

00:01:59,899 --> 00:02:03,609
into us may have encountered this at

00:02:01,399 --> 00:02:07,189
some point in their a station lifetime

00:02:03,609 --> 00:02:09,319
the goal so the goal is not to eliminate

00:02:07,189 --> 00:02:12,740
this problem and write error-free code

00:02:09,319 --> 00:02:15,319
instead the goal is to understand what

00:02:12,740 --> 00:02:17,540
those errors mean and how we can get

00:02:15,319 --> 00:02:19,099
around those errors just like how we

00:02:17,540 --> 00:02:22,069
deal with every

00:02:19,099 --> 00:02:24,709
I know that the bar ticker could be

00:02:22,069 --> 00:02:27,590
rather daunting for and frustrating for

00:02:24,709 --> 00:02:32,209
newcomers particularly for folks from

00:02:27,590 --> 00:02:35,390
high-level languages and that were I

00:02:32,209 --> 00:02:37,459
present you my story and it's not it's

00:02:35,390 --> 00:02:40,310
not just a story I will be praising

00:02:37,459 --> 00:02:45,410
rusty every now and then but I hope that

00:02:40,310 --> 00:02:50,930
my story helps you to helps you my story

00:02:45,410 --> 00:02:54,410
modok's you and to you try rust without

00:02:50,930 --> 00:02:56,450
giving up for others who are already

00:02:54,410 --> 00:03:01,220
familiar with rust I think this should

00:02:56,450 --> 00:03:05,810
be fun it's kind of hard to use this one

00:03:01,220 --> 00:03:09,860
of my expense anyway I will be covering

00:03:05,810 --> 00:03:11,599
three situations these scenarios or

00:03:09,860 --> 00:03:17,750
rather a rather common in most of the

00:03:11,599 --> 00:03:19,489
languages and and whenever I go through

00:03:17,750 --> 00:03:21,890
any of these situations I'll be telling

00:03:19,489 --> 00:03:24,500
you what the borrow checker complained

00:03:21,890 --> 00:03:26,150
what the compiler complained and how

00:03:24,500 --> 00:03:29,530
what those errors meant what I learned

00:03:26,150 --> 00:03:32,150
and how they that change everything and

00:03:29,530 --> 00:03:34,640
before I begin there's one other thing I

00:03:32,150 --> 00:03:36,709
wanted to say it's a disclaimer that I

00:03:34,640 --> 00:03:39,170
am I will be using some languages in

00:03:36,709 --> 00:03:41,269
here and I'm not comparing any of these

00:03:39,170 --> 00:03:43,250
languages or undermining them in front

00:03:41,269 --> 00:03:45,350
of rust it's just that I've used them

00:03:43,250 --> 00:03:48,139
because I am familiar with those

00:03:45,350 --> 00:03:50,239
languages and I wanted to show you how

00:03:48,139 --> 00:03:55,329
Rossi first from this from those

00:03:50,239 --> 00:04:01,609
languages okay so let's start with

00:03:55,329 --> 00:04:03,970
variable bindings in so the first

00:04:01,609 --> 00:04:06,950
example is in Python it's snippet it's

00:04:03,970 --> 00:04:10,220
somewhat simpler to read I guess it's a

00:04:06,950 --> 00:04:13,130
list of integers and those are bound to

00:04:10,220 --> 00:04:15,620
the variable a and then we are binding a

00:04:13,130 --> 00:04:19,459
to B and finally we are printing the

00:04:15,620 --> 00:04:21,709
contents of a and B if we were to write

00:04:19,459 --> 00:04:25,700
the same thing in Swift we would do

00:04:21,709 --> 00:04:27,800
something like that and both things work

00:04:25,700 --> 00:04:30,950
if you run it you won't encounter any

00:04:27,800 --> 00:04:32,340
errors and that's totally normal but if

00:04:30,950 --> 00:04:34,770
you do the same thing in rust

00:04:32,340 --> 00:04:36,360
this is perfectly normal right you're

00:04:34,770 --> 00:04:38,490
just declaring a variable and you're

00:04:36,360 --> 00:04:41,100
putting the contents but if you try to

00:04:38,490 --> 00:04:47,100
compile compile it the body circuit

00:04:41,100 --> 00:04:49,680
won't allow you to and that bring that

00:04:47,100 --> 00:04:54,060
kind of stopped me when I tried Ross for

00:04:49,680 --> 00:04:57,660
the first time so I began to read the

00:04:54,060 --> 00:05:02,790
book when I try trust Python was my only

00:04:57,660 --> 00:05:06,180
background so this is how I thought of

00:05:02,790 --> 00:05:08,340
memory so memory is a contiguous set of

00:05:06,180 --> 00:05:09,750
blocks and the program requests the

00:05:08,340 --> 00:05:12,240
operating system and the operating

00:05:09,750 --> 00:05:13,500
system gives gives blocks to the program

00:05:12,240 --> 00:05:16,800
and the program freezes them in the end

00:05:13,500 --> 00:05:21,360
now that's partially true but not

00:05:16,800 --> 00:05:23,820
exactly when about four years back when

00:05:21,360 --> 00:05:25,950
the Ross book started thanks to Steve

00:05:23,820 --> 00:05:28,980
cloud Nick and others in the

00:05:25,950 --> 00:05:31,410
documentation team it began with the

00:05:28,980 --> 00:05:36,200
differentiation of the stack with a heap

00:05:31,410 --> 00:05:41,100
and there's this whole new process of

00:05:36,200 --> 00:05:43,050
thinking through things like some you

00:05:41,100 --> 00:05:44,490
can only have some of the stuff in stack

00:05:43,050 --> 00:05:46,880
because stack is limited in size you

00:05:44,490 --> 00:05:49,200
know you can only push and pop and and

00:05:46,880 --> 00:05:51,930
then you can have anything in heap but

00:05:49,200 --> 00:05:53,880
then you are you need to take care of

00:05:51,930 --> 00:05:57,950
the allocation and de-allocation all by

00:05:53,880 --> 00:06:02,130
yourself and this changed how I viewed

00:05:57,950 --> 00:06:06,870
things through the program when I

00:06:02,130 --> 00:06:10,560
program now coming back to our example I

00:06:06,870 --> 00:06:13,500
am assigning that I'm changing the first

00:06:10,560 --> 00:06:18,690
element in our list in Python and Swift

00:06:13,500 --> 00:06:20,850
and then I'm printing the is comparing

00:06:18,690 --> 00:06:24,810
the results of those after change in

00:06:20,850 --> 00:06:28,530
Python I'm using the identity operator

00:06:24,810 --> 00:06:30,450
which is the is operator and in Swift

00:06:28,530 --> 00:06:34,290
I'm using the Equality operator the

00:06:30,450 --> 00:06:39,600
result has got to do with the outcome of

00:06:34,290 --> 00:06:43,200
this in Python you get true and in Swift

00:06:39,600 --> 00:06:44,949
the Equality itself is false and that's

00:06:43,200 --> 00:06:48,399
because

00:06:44,949 --> 00:06:50,289
and now I'm curious why because I just

00:06:48,399 --> 00:06:52,539
tried to add in Python a loss if then

00:06:50,289 --> 00:06:55,469
now I don't know why that happened so I

00:06:52,539 --> 00:06:58,529
investigated and I figure out that

00:06:55,469 --> 00:07:03,099
everything is an object in Python

00:06:58,529 --> 00:07:04,689
everything that means the a and B the

00:07:03,099 --> 00:07:10,539
both variables are pointing to the same

00:07:04,689 --> 00:07:12,339
list and whereas in Swift it's not the

00:07:10,539 --> 00:07:13,449
same object it uses something called

00:07:12,339 --> 00:07:17,199
copy-on-write

00:07:13,449 --> 00:07:19,989
so when you change B B gets a new copy

00:07:17,199 --> 00:07:23,379
of that list so the change is reflected

00:07:19,989 --> 00:07:25,569
in B not in a if you have used for us

00:07:23,379 --> 00:07:29,979
before then you would be familiar with

00:07:25,569 --> 00:07:35,529
cow clone on right pointer so that's how

00:07:29,979 --> 00:07:38,169
Swift works and if you think about it

00:07:35,529 --> 00:07:43,179
these languages to take care of these

00:07:38,169 --> 00:07:45,159
decisions implicitly because they don't

00:07:43,179 --> 00:07:49,119
trust the programmer because programmers

00:07:45,159 --> 00:07:51,969
are known to do bad things like not

00:07:49,119 --> 00:07:53,889
freeing what they are locate so the

00:07:51,969 --> 00:07:56,979
languages take care of the decisions and

00:07:53,889 --> 00:08:02,799
make make the environment make the

00:07:56,979 --> 00:08:05,619
program safe now I go on figuring out

00:08:02,799 --> 00:08:08,129
why all the high level languages do that

00:08:05,619 --> 00:08:13,569
and almost all the high level languages

00:08:08,129 --> 00:08:17,199
safe languages guarantee memory safety

00:08:13,569 --> 00:08:19,989
through a bite and they I'm sorry I

00:08:17,199 --> 00:08:22,899
missed it so they are built on the

00:08:19,989 --> 00:08:26,409
premise that variables can be used any

00:08:22,899 --> 00:08:28,569
number of times and this means you only

00:08:26,409 --> 00:08:30,219
have one or the other way one way you go

00:08:28,569 --> 00:08:33,129
for references like Python or the other

00:08:30,219 --> 00:08:34,899
way you copy everything like Swift but

00:08:33,129 --> 00:08:38,349
reference this is a bad idea

00:08:34,899 --> 00:08:41,169
we know that through C C++ so we are

00:08:38,349 --> 00:08:45,639
left with copying but doing that all the

00:08:41,169 --> 00:08:48,790
time is also bad is equally bad so now

00:08:45,639 --> 00:08:51,160
we have Ferris coming in and saying okay

00:08:48,790 --> 00:08:54,639
but we can copy some values for example

00:08:51,160 --> 00:08:56,170
integers pointers and characters

00:08:54,639 --> 00:08:57,130
basically everything that could be in

00:08:56,170 --> 00:09:00,820
the stack can

00:08:57,130 --> 00:09:03,790
be copied safely and what about the

00:09:00,820 --> 00:09:05,380
other values more importantly what about

00:09:03,790 --> 00:09:07,900
the destructible values the values of

00:09:05,380 --> 00:09:11,740
the destructors which may not be saved

00:09:07,900 --> 00:09:13,990
for a bitwise copy and which may need to

00:09:11,740 --> 00:09:18,070
clean up additional resources like say

00:09:13,990 --> 00:09:22,060
closing a socket our are closing a file

00:09:18,070 --> 00:09:24,010
or whatever and these resources may have

00:09:22,060 --> 00:09:25,870
to move somewhere else in the heap along

00:09:24,010 --> 00:09:29,740
the way and we need to keep track of

00:09:25,870 --> 00:09:33,580
that too in order to solve this problem

00:09:29,740 --> 00:09:36,850
rust take some ideas from something

00:09:33,580 --> 00:09:40,720
called affine types what this does is

00:09:36,850 --> 00:09:42,580
that a resource can what this says is

00:09:40,720 --> 00:09:47,350
that a resource can only be used once

00:09:42,580 --> 00:09:51,760
and this may sound similar similar to

00:09:47,350 --> 00:09:54,700
what the ownership model does when we

00:09:51,760 --> 00:09:57,850
use something in broth we can only use

00:09:54,700 --> 00:10:04,480
once that is own types can only be used

00:09:57,850 --> 00:10:06,910
once and that kind of struck me it when

00:10:04,480 --> 00:10:09,850
I thought about it it didn't it didn't

00:10:06,910 --> 00:10:11,440
really mean much but eventually I kind

00:10:09,850 --> 00:10:15,130
of got the point it's a pretty neat way

00:10:11,440 --> 00:10:17,560
of doing things and rust doesn't take

00:10:15,130 --> 00:10:20,700
taking decisions for you by default it

00:10:17,560 --> 00:10:23,650
it allocates everything on the stack and

00:10:20,700 --> 00:10:26,410
when if you want heap then you need to

00:10:23,650 --> 00:10:30,970
specify that to rust and you do that

00:10:26,410 --> 00:10:33,550
through two interfaces or market types

00:10:30,970 --> 00:10:37,390
the copy and the clone which tells you

00:10:33,550 --> 00:10:40,060
whether what are the types or values can

00:10:37,390 --> 00:10:41,620
be easily copied and safely or whether

00:10:40,060 --> 00:10:45,190
they need additional work to be

00:10:41,620 --> 00:10:49,720
performed like heap allocation or file

00:10:45,190 --> 00:10:54,280
descriptors over now moving on to the

00:10:49,720 --> 00:10:58,720
next situation why this and pointers are

00:10:54,280 --> 00:11:00,400
hot in C at least when I tried C yeah

00:10:58,720 --> 00:11:04,710
that was the only one that scared me

00:11:00,400 --> 00:11:07,720
away so and I never tried C after that I

00:11:04,710 --> 00:11:11,080
couldn't recall all my struggles with

00:11:07,720 --> 00:11:15,029
the Ross compiler from three years bags

00:11:11,080 --> 00:11:18,670
let's go for a thought experiment I am i

00:11:15,029 --> 00:11:22,870
let's imagine me as a newcomer rolling

00:11:18,670 --> 00:11:27,040
my own csvde Jason converter the idea is

00:11:22,870 --> 00:11:30,070
to just read CSV strings to the standard

00:11:27,040 --> 00:11:31,959
input or whatever and output Jason's

00:11:30,070 --> 00:11:36,510
friends it's they're all rows and

00:11:31,959 --> 00:11:39,610
columns get translated to adjacent areas

00:11:36,510 --> 00:11:41,920
so I start with the search for reading

00:11:39,610 --> 00:11:44,079
lines from a CDN and the communities

00:11:41,920 --> 00:11:47,649
kind of trade you always have a highly

00:11:44,079 --> 00:11:50,980
voted answer in Stack Overflow and then

00:11:47,649 --> 00:11:54,279
I'd go for splitting strings and I kind

00:11:50,980 --> 00:11:56,430
of put together my prototype for reading

00:11:54,279 --> 00:12:01,690
strings from the standard input and

00:11:56,430 --> 00:12:04,899
output again and I try to compile it and

00:12:01,690 --> 00:12:07,180
it doesn't compile because I now see

00:12:04,899 --> 00:12:09,250
that the collection type such as vectors

00:12:07,180 --> 00:12:11,890
don't implement the display trade okay

00:12:09,250 --> 00:12:14,800
so I try to implement the display

00:12:11,890 --> 00:12:16,870
display trade and I regret doing that

00:12:14,800 --> 00:12:22,540
and eventually I ditch might display

00:12:16,870 --> 00:12:26,770
trade and go for sir Jason now comes the

00:12:22,540 --> 00:12:29,320
first Porsche Carerra temporary value

00:12:26,770 --> 00:12:32,649
drop well borrow okay and Russ tells me

00:12:29,320 --> 00:12:35,770
that and points at the exact line where

00:12:32,649 --> 00:12:39,120
it happens and asked me to create a lead

00:12:35,770 --> 00:12:42,970
binding for that line okay I do that and

00:12:39,120 --> 00:12:46,089
now it compiles and I couldn't

00:12:42,970 --> 00:12:50,380
understand a thing so I researched what

00:12:46,089 --> 00:12:53,880
had just happened and I realized that

00:12:50,380 --> 00:12:57,370
the s3 in lock method returns a handle

00:12:53,880 --> 00:12:59,470
the handle implements puff read and the

00:12:57,370 --> 00:13:03,220
buff read gives you the lines it trader

00:12:59,470 --> 00:13:05,410
which returns which yields a result of

00:13:03,220 --> 00:13:07,570
string for every time you call the

00:13:05,410 --> 00:13:11,410
function it sorry every time you trade

00:13:07,570 --> 00:13:14,800
and the split method that I used creates

00:13:11,410 --> 00:13:18,160
references on that string the string

00:13:14,800 --> 00:13:21,760
that gets dropped and the references get

00:13:18,160 --> 00:13:23,740
collected into the vector that's a

00:13:21,760 --> 00:13:29,220
classic use of Freiburg

00:13:23,740 --> 00:13:32,440
and Russ has stopped us from doing that

00:13:29,220 --> 00:13:35,230
moving on now I'm kind of familiar with

00:13:32,440 --> 00:13:40,270
some of the errors in the compiler and I

00:13:35,230 --> 00:13:42,010
am having this dinner not to navigate

00:13:40,270 --> 00:13:44,860
this I'm going for this iterator

00:13:42,010 --> 00:13:46,600
implementation so that I can do things

00:13:44,860 --> 00:13:51,250
in a nice way

00:13:46,600 --> 00:13:54,160
so I just called that struct with using

00:13:51,250 --> 00:13:57,070
it for it for loop and I'll get the

00:13:54,160 --> 00:14:01,000
lines the JSON lines and that's easier

00:13:57,070 --> 00:14:01,600
to work with so I start from the

00:14:01,000 --> 00:14:04,660
beginning

00:14:01,600 --> 00:14:07,930
I know returns SVN lock so I just put it

00:14:04,660 --> 00:14:10,600
there and it says it's missing lifetime

00:14:07,930 --> 00:14:13,450
specifier I have no idea what it does so

00:14:10,600 --> 00:14:15,640
I searched around and eventually I found

00:14:13,450 --> 00:14:18,310
find that the dark documentation say

00:14:15,640 --> 00:14:21,240
something like - a now I don't know what

00:14:18,310 --> 00:14:24,190
that - a is I'll just put it there and

00:14:21,240 --> 00:14:27,160
it says use of undeclared lifetime and

00:14:24,190 --> 00:14:29,710
it tells me what change I should make

00:14:27,160 --> 00:14:33,790
like changing the struct to use that

00:14:29,710 --> 00:14:37,180
lifetime and I had that okay and it

00:14:33,790 --> 00:14:39,730
compiles again now I want to figure out

00:14:37,180 --> 00:14:41,580
why it works and that's part of the

00:14:39,730 --> 00:14:43,690
programming workflow right so you could

00:14:41,580 --> 00:14:45,370
it doesn't compile you shout at the

00:14:43,690 --> 00:14:49,600
computer if it does compile you shadowed

00:14:45,370 --> 00:14:55,120
computer and I go on a quest to find

00:14:49,600 --> 00:14:57,580
what just happened I see that the study

00:14:55,120 --> 00:15:01,720
in struct looks something like that

00:14:57,580 --> 00:15:04,930
okay and the loc method currently looks

00:15:01,720 --> 00:15:07,360
like that but previously it looks

00:15:04,930 --> 00:15:13,090
something like that I mean about three

00:15:07,360 --> 00:15:16,240
years back so now the STD in lock this

00:15:13,090 --> 00:15:18,520
fact has its label but then you see that

00:15:16,240 --> 00:15:20,350
there's a mutex odd and the label is now

00:15:18,520 --> 00:15:23,620
in the mutex guard so you follow along

00:15:20,350 --> 00:15:26,860
and you find music squad now I see a

00:15:23,620 --> 00:15:27,640
reference holding that label and now I

00:15:26,860 --> 00:15:30,850
finally see it

00:15:27,640 --> 00:15:35,150
okay so references have a label that's

00:15:30,850 --> 00:15:40,820
great oh I just missed this slide

00:15:35,150 --> 00:15:41,570
now I realize something's a study in

00:15:40,820 --> 00:15:44,630
luck

00:15:41,570 --> 00:15:49,430
the struck which we just saw borrows STD

00:15:44,630 --> 00:15:54,410
in and the borrow constrains the owner

00:15:49,430 --> 00:15:57,350
from moving somewhere else and that made

00:15:54,410 --> 00:16:00,620
sense it made complete sense because if

00:15:57,350 --> 00:16:02,600
we are wrapping over a reference then we

00:16:00,620 --> 00:16:05,420
cannot outlive that reference because

00:16:02,600 --> 00:16:08,060
then we'll have something we'll have a

00:16:05,420 --> 00:16:12,140
dangling pointer which is bad and rust

00:16:08,060 --> 00:16:14,900
has proven it bed again now I have

00:16:12,140 --> 00:16:18,800
struggled a bit further after a few more

00:16:14,900 --> 00:16:21,020
hours or weeks and I have this iterator

00:16:18,800 --> 00:16:24,290
the contents of the trade doesn't really

00:16:21,020 --> 00:16:26,510
matter what matters is that I am not

00:16:24,290 --> 00:16:28,220
satisfied with that iterator because the

00:16:26,510 --> 00:16:33,860
usage looks something like that

00:16:28,220 --> 00:16:35,720
I need to deal with an additional scrap

00:16:33,860 --> 00:16:36,500
raises and I need to print the Commerce

00:16:35,720 --> 00:16:40,130
by myself

00:16:36,500 --> 00:16:42,470
which I don't want to do so I'm

00:16:40,130 --> 00:16:45,620
unsatisfied I am looking for a way to

00:16:42,470 --> 00:16:48,440
improve things and these are all the

00:16:45,620 --> 00:16:50,420
improvements that I come up with the

00:16:48,440 --> 00:16:54,529
attire should handle everything like

00:16:50,420 --> 00:16:56,720
when I call for line in date for every

00:16:54,529 --> 00:16:58,790
iteration the line should give me the

00:16:56,720 --> 00:17:01,250
Jason the valid JSON output that I

00:16:58,790 --> 00:17:04,390
should get I shouldn't have to deal with

00:17:01,250 --> 00:17:07,809
anything anything on my own

00:17:04,390 --> 00:17:10,520
they trailer should work on all readers

00:17:07,809 --> 00:17:14,270
that means a file should it should work

00:17:10,520 --> 00:17:20,809
it should work on TCP streams and write

00:17:14,270 --> 00:17:24,140
this same thing now I'm kind of at this

00:17:20,809 --> 00:17:27,230
point I'm kind of familiar with the

00:17:24,140 --> 00:17:30,860
lifetime errors from Rossi and I kind of

00:17:27,230 --> 00:17:36,340
like it so I go I purposefully go for

00:17:30,860 --> 00:17:36,340
something like this a nightmare spot and

00:17:36,910 --> 00:17:41,809
again we don't have to focus on the next

00:17:39,679 --> 00:17:43,760
method we can just assume that the next

00:17:41,809 --> 00:17:46,429
method has already been implemented by

00:17:43,760 --> 00:17:48,710
me and I don't want to show you my dirty

00:17:46,429 --> 00:17:52,010
code

00:17:48,710 --> 00:17:53,870
the right way to use this method will be

00:17:52,010 --> 00:17:57,410
will look something like this

00:17:53,870 --> 00:18:00,920
so I have s to D in and STD out and I

00:17:57,410 --> 00:18:05,180
get a lock on those so I get pandals for

00:18:00,920 --> 00:18:09,320
both both actually in an SPL and I used

00:18:05,180 --> 00:18:12,830
that in the struct and when it sorry

00:18:09,320 --> 00:18:15,440
when I do that when I use the for each

00:18:12,830 --> 00:18:18,620
up for each method on that iterator I

00:18:15,440 --> 00:18:20,270
get the lines because it's passing this

00:18:18,620 --> 00:18:23,929
really in and transferring that to a

00:18:20,270 --> 00:18:27,790
studio which is exactly what I want now

00:18:23,929 --> 00:18:31,040
I try to make things worse

00:18:27,790 --> 00:18:33,020
I'm trying to use a buffer ok buffer

00:18:31,040 --> 00:18:36,950
implement buffer in this case is a

00:18:33,020 --> 00:18:41,780
vector and the vector implements the

00:18:36,950 --> 00:18:43,550
right trait and I'm using the buffer and

00:18:41,780 --> 00:18:47,030
just passing a reference to that buffer

00:18:43,550 --> 00:18:49,970
to the struct that's what we're that's

00:18:47,030 --> 00:18:52,280
where our problem is instead of passing

00:18:49,970 --> 00:18:55,040
a mutable reference that is giving right

00:18:52,280 --> 00:18:58,130
axis I am giving readable axis it's just

00:18:55,040 --> 00:19:02,210
a reference and must prevents that and

00:18:58,130 --> 00:19:04,640
it's pretty cool because those are two

00:19:02,210 --> 00:19:06,230
different types according to rust a

00:19:04,640 --> 00:19:07,400
readable reference is completely

00:19:06,230 --> 00:19:08,330
different from the writable reference

00:19:07,400 --> 00:19:12,020
okay

00:19:08,330 --> 00:19:15,550
so I change that and it works now I'm

00:19:12,020 --> 00:19:19,010
doing something like that I'm dropping

00:19:15,550 --> 00:19:22,070
the bytes vector after initializing the

00:19:19,010 --> 00:19:25,309
trader so I'm creating another use have

00:19:22,070 --> 00:19:27,920
free out of thin air and Russ prevents

00:19:25,309 --> 00:19:33,020
that again but the bar to go saves the

00:19:27,920 --> 00:19:37,520
day and what about now I am mutating the

00:19:33,020 --> 00:19:39,559
vector after creating the trader so this

00:19:37,520 --> 00:19:42,020
means the vector could have reached its

00:19:39,559 --> 00:19:44,300
capacity at this point and may have

00:19:42,020 --> 00:19:47,330
relocated elsewhere in the heap and the

00:19:44,300 --> 00:19:49,040
point was now somewhere else and rust

00:19:47,330 --> 00:19:54,230
doesn't allow allowed that allow me to

00:19:49,040 --> 00:19:56,960
do that either so it wouldn't be wrong

00:19:54,230 --> 00:20:00,080
to say that was just like angel sitting

00:19:56,960 --> 00:20:02,350
in my computer telling me right from

00:20:00,080 --> 00:20:02,350
wrong

00:20:02,460 --> 00:20:09,040
moving on to threats a ball of fire you

00:20:08,770 --> 00:20:13,480
know

00:20:09,040 --> 00:20:17,110
threads we have a conference II example

00:20:13,480 --> 00:20:19,870
in Python and I have a list of values a

00:20:17,110 --> 00:20:23,320
list of integers and it's stored in the

00:20:19,870 --> 00:20:26,560
variable values and the do work function

00:20:23,320 --> 00:20:29,230
is capturing context from the global

00:20:26,560 --> 00:20:31,660
scope and it's incrementing the values

00:20:29,230 --> 00:20:34,630
50 times for no reason I know it's a

00:20:31,660 --> 00:20:38,740
dumb function but the point is just stay

00:20:34,630 --> 00:20:41,800
with me and we'll see I'm launching a

00:20:38,740 --> 00:20:45,220
thread targeting not just a thread

00:20:41,800 --> 00:20:47,950
twenty threats targeting do work keen

00:20:45,220 --> 00:20:53,680
breeders may notice a problem with this

00:20:47,950 --> 00:20:56,500
step this is a race condition because

00:20:53,680 --> 00:20:58,990
when some some thread reads the value

00:20:56,500 --> 00:21:01,840
some other thread may write the value

00:20:58,990 --> 00:21:05,230
and you are overriding an already

00:21:01,840 --> 00:21:07,660
incremented value anyway we're just

00:21:05,230 --> 00:21:09,520
assuming that Python helps us and we're

00:21:07,660 --> 00:21:11,530
just moving along and starting the

00:21:09,520 --> 00:21:14,710
threads I'm joining threads and finally

00:21:11,530 --> 00:21:16,810
I'm printing the value it's always

00:21:14,710 --> 00:21:18,700
something like photos and one two five

00:21:16,810 --> 00:21:20,530
four thousand six nine nine but never

00:21:18,700 --> 00:21:24,160
five thousand because we lost all those

00:21:20,530 --> 00:21:26,950
values because of the race condition if

00:21:24,160 --> 00:21:29,770
we were to repeat that in Swift we will

00:21:26,950 --> 00:21:34,270
be using array and we have the same do

00:21:29,770 --> 00:21:36,940
work function and so if we the the

00:21:34,270 --> 00:21:40,290
normal approach is to go for the Grand

00:21:36,940 --> 00:21:44,410
Central Dispatch in sort of threads so

00:21:40,290 --> 00:21:46,390
using that and we have a semaphore we

00:21:44,410 --> 00:21:49,750
have dispatch group which acts like a

00:21:46,390 --> 00:21:51,790
semaphore for us to wait for things and

00:21:49,750 --> 00:21:54,310
eventually we will print the value open

00:21:51,790 --> 00:21:59,850
the song it does the same thing and it

00:21:54,310 --> 00:22:03,940
has similar results what about cost I

00:21:59,850 --> 00:22:05,530
have a vector same file elements I I

00:22:03,940 --> 00:22:08,650
could I could have used an array because

00:22:05,530 --> 00:22:11,950
I'm not resizing but anyway I have a do

00:22:08,650 --> 00:22:13,870
work closure that borrows context from

00:22:11,950 --> 00:22:14,800
the from a surroundings which is the

00:22:13,870 --> 00:22:18,970
values

00:22:14,800 --> 00:22:22,150
and I'm spawning 20 threads again using

00:22:18,970 --> 00:22:24,550
that vector and I'm joining it okay if

00:22:22,150 --> 00:22:27,640
if you know Russ then you would say that

00:22:24,550 --> 00:22:29,860
this program is horribly wrong and I

00:22:27,640 --> 00:22:33,460
would agree with you because it doesn't

00:22:29,860 --> 00:22:36,570
compile and it says the closure may

00:22:33,460 --> 00:22:41,350
outlive the current function which means

00:22:36,570 --> 00:22:45,040
the vector that we had may move may get

00:22:41,350 --> 00:22:46,090
lost because threads we don't know the

00:22:45,040 --> 00:22:47,200
lifetime of the threads different

00:22:46,090 --> 00:22:49,720
threads could live for different times

00:22:47,200 --> 00:22:51,640
and which means if the vector R which is

00:22:49,720 --> 00:22:54,070
part of this function gets dropped in

00:22:51,640 --> 00:22:59,860
the end and what else is there in the

00:22:54,070 --> 00:23:02,770
thread okay so Brust asks you to think

00:22:59,860 --> 00:23:04,480
about your decisions like it asks you

00:23:02,770 --> 00:23:07,930
what exactly do you want

00:23:04,480 --> 00:23:10,420
do we want to clone or ritto no we don't

00:23:07,930 --> 00:23:14,710
want that we want writable access from

00:23:10,420 --> 00:23:18,460
all the threads so rust brings you to

00:23:14,710 --> 00:23:21,610
two elegant solutions to this the send

00:23:18,460 --> 00:23:24,730
and sink markers sense says that passing

00:23:21,610 --> 00:23:29,050
by value is safe and sinks is that

00:23:24,730 --> 00:23:31,570
passing by reference is safe and now

00:23:29,050 --> 00:23:35,020
there's an endless discovery going on

00:23:31,570 --> 00:23:38,590
and I have come up with some

00:23:35,020 --> 00:23:42,340
realizations firstly we have the normal

00:23:38,590 --> 00:23:46,420
reference which which applies to a

00:23:42,340 --> 00:23:49,300
vector or a slice and the problem with

00:23:46,420 --> 00:23:54,490
this is that the references are bound to

00:23:49,300 --> 00:23:58,540
the scope so they are not static we have

00:23:54,490 --> 00:24:01,690
vector of some type and it it doesn't

00:23:58,540 --> 00:24:05,320
women sense ink and Static but we don't

00:24:01,690 --> 00:24:07,690
want to clone or move anywhere so that's

00:24:05,320 --> 00:24:10,600
not a choice either now we are going for

00:24:07,690 --> 00:24:14,140
a reference counted pointer which is

00:24:10,600 --> 00:24:19,140
static but then it's not send it only

00:24:14,140 --> 00:24:21,160
allows reference methods which use

00:24:19,140 --> 00:24:25,090
breathable reference instead of writable

00:24:21,160 --> 00:24:27,700
reference we have rough saw which which

00:24:25,090 --> 00:24:28,060
is sent and it does allow mutable

00:24:27,700 --> 00:24:32,320
reference

00:24:28,060 --> 00:24:34,120
but then it's not sink eventually we

00:24:32,320 --> 00:24:37,510
will get to the point where we are left

00:24:34,120 --> 00:24:41,830
with the thread-safe variants of our c

00:24:37,510 --> 00:24:45,550
and r f soul and that's what we want if

00:24:41,830 --> 00:24:48,280
and once we change our code it looks

00:24:45,550 --> 00:24:52,270
something like that but again the only

00:24:48,280 --> 00:25:01,120
change that you need to worry about is

00:24:52,270 --> 00:25:02,770
that doesn't highlight okay anyway this

00:25:01,120 --> 00:25:07,360
brings us to the question of whether R

00:25:02,770 --> 00:25:10,180
Us prevents race conditions no it

00:25:07,360 --> 00:25:14,950
doesn't it only forces you to think

00:25:10,180 --> 00:25:16,750
about it because the code is expressive

00:25:14,950 --> 00:25:19,600
and that's one other thing I like or

00:25:16,750 --> 00:25:23,440
trust if you read the code you'll know

00:25:19,600 --> 00:25:25,750
what exactly you're dealing with life

00:25:23,440 --> 00:25:29,050
unlike other languages rust doesn't

00:25:25,750 --> 00:25:34,170
expect you to know things it teaches you

00:25:29,050 --> 00:25:37,630
things along the way now coming back to

00:25:34,170 --> 00:25:40,750
how the last four years were for me I

00:25:37,630 --> 00:25:44,440
had moments like why doesn't this work

00:25:40,750 --> 00:25:49,150
or what do you even want from me Rossi

00:25:44,440 --> 00:25:52,330
and I had happier moments like okay that

00:25:49,150 --> 00:25:58,870
is actually great I didn't know this all

00:25:52,330 --> 00:26:01,480
this time and my journey was kind of

00:25:58,870 --> 00:26:07,450
nice and I liked every bit of my moment

00:26:01,480 --> 00:26:09,550
spend with the Ross compiler so if this

00:26:07,450 --> 00:26:15,460
makes this could probably make you think

00:26:09,550 --> 00:26:18,370
that drug isn't as hard like isn't just

00:26:15,460 --> 00:26:21,850
too hard to learn or if you're new comer

00:26:18,370 --> 00:26:24,430
then it is definitely hard but you

00:26:21,850 --> 00:26:28,900
should stick to it anyway because of the

00:26:24,430 --> 00:26:30,940
perks that come will come in the end now

00:26:28,900 --> 00:26:33,220
if you ask me it was too hard to be

00:26:30,940 --> 00:26:35,920
widely adopted then I would point you to

00:26:33,220 --> 00:26:40,179
Steve club Nick who says I believe in

00:26:35,920 --> 00:26:40,600
people thank you and have a great lunch

00:26:40,179 --> 00:26:45,760
you

00:26:40,600 --> 00:26:45,760

YouTube URL: https://www.youtube.com/watch?v=qmk3NGooDYI


