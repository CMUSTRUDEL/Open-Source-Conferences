Title: Rust Berlin - rust ❤️ sensors - Claus Matzinger
Publication date: 2017-09-19
Playlist: Rust Berlin
Description: 
	With Rust being a safe and efficient language, it's perfect for embedded and more lower level applications. However, its ecosystem is missing a crucial thing to succeed: Drivers. More often than not reference implementations are in C or Python, and re-implementing them using that code or even the data sheet is often tricky. This talk will explore available drivers, common pitfalls, and show the audience how to implement their own drivers for i2c devices.

A software engineer by trade, Claus runs field engineering at Crate.io, the creators of CrateDB, a distributed SQL database. As a former CTO of a health startup and an Raspberry Pi and Rust (the programming language) enthusiast, Claus also maintains several drivers for sensors in the Rust community. He loves connecting with developers to talk about putting machine data to work in exciting IoT systems.
Captions: 
	00:00:11,840 --> 00:00:28,710
alright folks we're continuing with our

00:00:14,280 --> 00:00:31,380
second talk right hi yeah welcome to my

00:00:28,710 --> 00:00:34,770
talk about sensors so we are going to

00:00:31,380 --> 00:00:39,360
move move a level down from CSS and

00:00:34,770 --> 00:00:41,219
layered rendering if you have asked on

00:00:39,360 --> 00:00:44,399
anything with embedded systems or

00:00:41,219 --> 00:00:47,190
something like that hmm quite quite a

00:00:44,399 --> 00:00:49,800
few uh I yeah um

00:00:47,190 --> 00:00:53,969
we'll see how much it I can tell you but

00:00:49,800 --> 00:00:56,190
yeah let's go I'm Klaus I work as a

00:00:53,969 --> 00:00:58,949
Technical Evangelist a company called

00:00:56,190 --> 00:00:59,489
crate IO actually until the day after

00:00:58,949 --> 00:01:02,219
tomorrow

00:00:59,489 --> 00:01:08,420
then I switch over to Microsoft which is

00:01:02,219 --> 00:01:12,570
fairly larger company probably yeah and

00:01:08,420 --> 00:01:15,900
yeah I'm a software engineer so my view

00:01:12,570 --> 00:01:18,600
of this you know of this thing and that

00:01:15,900 --> 00:01:23,250
wire attached it is fairly limited so I

00:01:18,600 --> 00:01:25,350
had that during my studies but after

00:01:23,250 --> 00:01:28,530
tinkering with rust for about a year I

00:01:25,350 --> 00:01:31,409
kind of went into you know why not

00:01:28,530 --> 00:01:34,850
program something on that arm device and

00:01:31,409 --> 00:01:37,770
can get something going there and

00:01:34,850 --> 00:01:40,020
especially since I'm sort of curious

00:01:37,770 --> 00:01:42,930
person I kind of like to re-implement

00:01:40,020 --> 00:01:46,470
stuff on you know just to get to know it

00:01:42,930 --> 00:01:49,890
a bit better which is yeah something

00:01:46,470 --> 00:01:52,770
that we shouldn't endorse a lot I guess

00:01:49,890 --> 00:01:56,250
and but it's a yeah it's a nice way to

00:01:52,770 --> 00:01:59,729
kind of get into getting to stuff all

00:01:56,250 --> 00:02:01,560
kinds of stuff so last year I set out

00:01:59,729 --> 00:02:03,960
and said like yeah let's build something

00:02:01,560 --> 00:02:07,799
really complicated something like a

00:02:03,960 --> 00:02:10,379
thermometer and you know like make it

00:02:07,799 --> 00:02:12,420
not as easy and add a Raspberry Pi into

00:02:10,379 --> 00:02:13,620
the mix and add some something like a

00:02:12,420 --> 00:02:15,750
sensor

00:02:13,620 --> 00:02:18,330
and this will be done then afternoon I

00:02:15,750 --> 00:02:19,860
want to do it with rust so yeah I'm

00:02:18,330 --> 00:02:23,480
gonna look for a driver because there is

00:02:19,860 --> 00:02:26,880
Python drivers and who wants to do that

00:02:23,480 --> 00:02:30,750
yeah of course there was no driver for

00:02:26,880 --> 00:02:33,390
us so I said yeah yeah let's do

00:02:30,750 --> 00:02:35,820
something quick and dirty and you know

00:02:33,390 --> 00:02:38,520
it's a since it's something GPIO so I

00:02:35,820 --> 00:02:41,520
kind of you know how hard can it be

00:02:38,520 --> 00:02:45,930
I implement I changed my agenda to

00:02:41,520 --> 00:02:49,170
implementing a driver you know I had a

00:02:45,930 --> 00:02:52,560
Raspberry Pi I have my sensor I know

00:02:49,170 --> 00:02:54,660
what base library I wanted to work with

00:02:52,560 --> 00:02:57,470
I had a reference implementation in c

00:02:54,660 --> 00:03:00,810
plus plus I had a Python reference and

00:02:57,470 --> 00:03:03,180
yeah it's it's gonna work out I guess I

00:03:00,810 --> 00:03:10,050
had found a datasheet and the datasheet

00:03:03,180 --> 00:03:12,270
contained one test so I'll be fine it

00:03:10,050 --> 00:03:15,000
also my scoping changed from an

00:03:12,270 --> 00:03:20,790
afternoon to probably a few weeks and

00:03:15,000 --> 00:03:22,800
yeah so it's all easy right and so yeah

00:03:20,790 --> 00:03:25,980
the first thing I learned is that GPIO

00:03:22,800 --> 00:03:27,870
is not everything and yeah it's mostly

00:03:25,980 --> 00:03:31,230
interrupts and events and things like

00:03:27,870 --> 00:03:35,280
the buttons give you what I was actually

00:03:31,230 --> 00:03:38,660
looking for is something like SPI or i2c

00:03:35,280 --> 00:03:43,410
both of which the Raspberry Pi supports

00:03:38,660 --> 00:03:47,700
but yeah these are two bus systems

00:03:43,410 --> 00:03:49,860
essentially and i2c is more common so

00:03:47,700 --> 00:03:54,810
especially since SPI needs a pin for

00:03:49,860 --> 00:03:57,450
every device you plug in so yeah so I

00:03:54,810 --> 00:04:00,300
looked closer at i2c I to see something

00:03:57,450 --> 00:04:04,340
called inter integrated circuit from

00:04:00,300 --> 00:04:07,950
1982 and it has phenomenal bandwidth of

00:04:04,340 --> 00:04:10,950
400 kilobits a second there's actually

00:04:07,950 --> 00:04:13,890
faster variants but yeah I assume that

00:04:10,950 --> 00:04:17,910
this is more more of in the vicinity of

00:04:13,890 --> 00:04:20,160
that small thing here and it uses seven

00:04:17,910 --> 00:04:22,740
bit addresses goes up to ten bits and

00:04:20,160 --> 00:04:26,660
this lets you connect about a thousand

00:04:22,740 --> 00:04:29,430
devices which I thought was enough

00:04:26,660 --> 00:04:31,140
yeah they are also able to connect

00:04:29,430 --> 00:04:34,350
multiple raspberry PI's on the same bus

00:04:31,140 --> 00:04:36,450
and the devices come pre address so if

00:04:34,350 --> 00:04:38,400
you want to connect two of those sensors

00:04:36,450 --> 00:04:41,700
you're out of luck unless you get a

00:04:38,400 --> 00:04:45,270
second bus going which in this case

00:04:41,700 --> 00:04:49,680
needs a second raspberry pi so yeah

00:04:45,270 --> 00:04:51,150
that's an easy start this is what what I

00:04:49,680 --> 00:04:55,260
had to do and wanted to do so this is

00:04:51,150 --> 00:04:56,780
essentially this device here so the

00:04:55,260 --> 00:05:04,470
Raspberry Pi which is Raspberry Pi zero

00:04:56,780 --> 00:05:06,030
it has one wire for voltage okay hold it

00:05:04,470 --> 00:05:09,720
may be in this direction bit more since

00:05:06,030 --> 00:05:13,650
you have a picture one device base one

00:05:09,720 --> 00:05:18,960
wire basically suppose gives the sensor

00:05:13,650 --> 00:05:22,140
power and there's two other wires one of

00:05:18,960 --> 00:05:24,600
which is the data wire so SDA for data

00:05:22,140 --> 00:05:26,460
and SEL for the clock so it kind of it

00:05:24,600 --> 00:05:28,890
knows when something's actually sent and

00:05:26,460 --> 00:05:31,740
not just you know random noise for

00:05:28,890 --> 00:05:33,900
example and of course there's a

00:05:31,740 --> 00:05:37,020
groundings to complete the circuit so

00:05:33,900 --> 00:05:38,640
this is you know this is fairly easy to

00:05:37,020 --> 00:05:39,990
find out what the pin layout is and

00:05:38,640 --> 00:05:42,720
connect the things that are named the

00:05:39,990 --> 00:05:44,640
same so this is this is the sort of

00:05:42,720 --> 00:05:51,060
thing complexity I was dealing with

00:05:44,640 --> 00:05:54,810
there and yeah the base library to talk

00:05:51,060 --> 00:05:58,550
to these ITC devices is called ITC death

00:05:54,810 --> 00:06:02,100
and it's on crates i/o

00:05:58,550 --> 00:06:04,080
just yeah easy to find it already comes

00:06:02,100 --> 00:06:06,720
pre implemented with two drivers one

00:06:04,080 --> 00:06:09,750
accelerometer and one barometer

00:06:06,720 --> 00:06:11,700
thermometer but a different one and you

00:06:09,750 --> 00:06:14,460
know you can it's not easy to reuse

00:06:11,700 --> 00:06:18,419
these things so but I was very excited I

00:06:14,460 --> 00:06:21,930
kind of took it as a you know sort of an

00:06:18,419 --> 00:06:23,250
example to work with and since i2c death

00:06:21,930 --> 00:06:25,380
gives me all the lower level

00:06:23,250 --> 00:06:28,320
communication and including a few

00:06:25,380 --> 00:06:31,260
examples that was quite nice to start

00:06:28,320 --> 00:06:36,740
off with so the result was that I

00:06:31,260 --> 00:06:40,050
created a crate called pmpo 85 which is

00:06:36,740 --> 00:06:44,970
technically a different device

00:06:40,050 --> 00:06:45,659
somewhere here yeah it's yeah I think

00:06:44,970 --> 00:06:47,550
it's that one

00:06:45,659 --> 00:06:49,409
so it's a bit larger than this one so

00:06:47,550 --> 00:06:52,020
this is a bmp180

00:06:49,409 --> 00:06:55,199
you can see what what the version

00:06:52,020 --> 00:06:57,690
difference makes and but they use the

00:06:55,199 --> 00:07:01,169
same driver so this driver works for

00:06:57,690 --> 00:07:02,729
both of those devices and it gives you

00:07:01,169 --> 00:07:07,710
the temperature and air pressure of

00:07:02,729 --> 00:07:09,750
whatever it measures so the essential

00:07:07,710 --> 00:07:13,469
part of how to implement this driver was

00:07:09,750 --> 00:07:17,069
how to get the data these these sensors

00:07:13,469 --> 00:07:20,819
have registers basically these registers

00:07:17,069 --> 00:07:23,729
are addressed using a u8 address so it's

00:07:20,819 --> 00:07:25,770
just a byte telling it where to do stuff

00:07:23,729 --> 00:07:31,349
and doing stuff means either writing or

00:07:25,770 --> 00:07:34,080
reading so in case of this PMP this need

00:07:31,349 --> 00:07:36,090
means you need to read calibration data

00:07:34,080 --> 00:07:38,370
from the sensor say if it's somewhere

00:07:36,090 --> 00:07:39,930
then you write to a command register

00:07:38,370 --> 00:07:42,930
until it's like I want to have

00:07:39,930 --> 00:07:45,750
temperature next then you wait and then

00:07:42,930 --> 00:07:49,349
you read from the data register and get

00:07:45,750 --> 00:07:51,630
what you yeah what you want it and then

00:07:49,349 --> 00:07:53,460
you translate you factory in the

00:07:51,630 --> 00:07:57,029
calibration data and then you're

00:07:53,460 --> 00:07:58,729
basically done so let's take a look how

00:07:57,029 --> 00:08:04,279
easy that is

00:07:58,729 --> 00:08:04,279
so it's not readable at all

00:08:09,110 --> 00:08:16,669
so yeah the layout of the project is

00:08:12,569 --> 00:08:23,569
fairly simple there's one file it has

00:08:16,669 --> 00:08:25,219
one dependency so yeah let's look at the

00:08:23,569 --> 00:08:31,319
fun

00:08:25,219 --> 00:08:34,860
so it's an apache license asking this is

00:08:31,319 --> 00:08:39,680
the default address that it got assigned

00:08:34,860 --> 00:08:43,730
to from the manufacturer I assume and

00:08:39,680 --> 00:08:45,810
yeah Russ there's some Russ code that

00:08:43,730 --> 00:08:47,970
basically it makes it very simple to

00:08:45,810 --> 00:08:51,180
deal with a couple of things in this

00:08:47,970 --> 00:08:53,800
case it's the sampling mode so you know

00:08:51,180 --> 00:08:56,649
to pressure that kind of determines how

00:08:53,800 --> 00:08:58,420
how fast it should how long you should

00:08:56,649 --> 00:09:01,540
actually wait between commanding and

00:08:58,420 --> 00:09:04,360
reading and it also factors into the

00:09:01,540 --> 00:09:06,880
command we will see that later but enums

00:09:04,360 --> 00:09:08,860
are very nice to use in this space in

00:09:06,880 --> 00:09:12,160
general as you can see there is also

00:09:08,860 --> 00:09:15,130
more of that of these items especially

00:09:12,160 --> 00:09:19,149
for registers this is very handy you can

00:09:15,130 --> 00:09:22,290
use some hex literals there in order to

00:09:19,149 --> 00:09:25,930
you know mapped addressing space quite

00:09:22,290 --> 00:09:29,170
quite nicely in C++ for example that was

00:09:25,930 --> 00:09:30,820
just a gigantic amount of constant

00:09:29,170 --> 00:09:34,899
variables that wasn't defined the header

00:09:30,820 --> 00:09:36,910
file which yeah is you know it's hard to

00:09:34,899 --> 00:09:42,550
find sometimes the stuff you're looking

00:09:36,910 --> 00:09:44,350
for these are the calibration registers

00:09:42,550 --> 00:09:48,070
I was talking to talking about earlier

00:09:44,350 --> 00:09:49,720
and this is the the actual thing that

00:09:48,070 --> 00:09:53,230
does something to control register and

00:09:49,720 --> 00:09:55,779
this is where something is yeah when you

00:09:53,230 --> 00:09:58,899
read data from the data register then

00:09:55,779 --> 00:10:01,890
there's also two commands that you put

00:09:58,899 --> 00:10:07,060
in yeah like read temperature or read

00:10:01,890 --> 00:10:09,000
pressure of course since we're in that

00:10:07,060 --> 00:10:12,160
space we also need to convert between

00:10:09,000 --> 00:10:14,140
big-endian and little-endian which is

00:10:12,160 --> 00:10:19,870
always quite fun to find out what you

00:10:14,140 --> 00:10:23,040
actually have to use and you'll figure

00:10:19,870 --> 00:10:23,040
it out you have one test

00:10:23,550 --> 00:10:28,810
yeah this is this is where the actual

00:10:25,930 --> 00:10:33,220
reading happens so you read the raw

00:10:28,810 --> 00:10:35,589
temperature by as I said sending a to

00:10:33,220 --> 00:10:38,140
control as sending to the control

00:10:35,589 --> 00:10:40,480
register so the device comes in so you

00:10:38,140 --> 00:10:43,920
have an SMS right bytes data so you

00:10:40,480 --> 00:10:47,980
write exactly one byte to this register

00:10:43,920 --> 00:10:51,160
and you add this command so you know

00:10:47,980 --> 00:10:54,250
it's like reads this or get me some

00:10:51,160 --> 00:10:56,019
temperature then you wait in this case

00:10:54,250 --> 00:10:57,640
five milliseconds which is exactly

00:10:56,019 --> 00:10:59,560
according to the specification but it's

00:10:57,640 --> 00:11:03,310
a blocking thing you have to put it in

00:10:59,560 --> 00:11:04,779
there and then you read from the data

00:11:03,310 --> 00:11:07,000
register and you hopefully get something

00:11:04,779 --> 00:11:09,310
back if you

00:11:07,000 --> 00:11:11,550
are quicker than those five milliseconds

00:11:09,310 --> 00:11:14,620
you will get some garbage data probably

00:11:11,550 --> 00:11:16,960
or an overflow because you know you're

00:11:14,620 --> 00:11:19,770
doing some extensive calculations done

00:11:16,960 --> 00:11:24,670
here and some of them fail quite easily

00:11:19,770 --> 00:11:26,470
especially it shifting things yeah and

00:11:24,670 --> 00:11:29,470
there's a lot of those things that are

00:11:26,470 --> 00:11:32,710
really peculiar to drivers I guess

00:11:29,470 --> 00:11:36,130
because there's a lot more coming from

00:11:32,710 --> 00:11:38,440
that and I've I've copied most of that I

00:11:36,130 --> 00:11:40,840
try to look through what it actually

00:11:38,440 --> 00:11:45,370
means but it's quite hard to understand

00:11:40,840 --> 00:11:46,930
what actual thing does since also it's

00:11:45,370 --> 00:11:50,590
not it's not helpful that they use the

00:11:46,930 --> 00:11:53,500
register names to describe the variables

00:11:50,590 --> 00:11:56,890
and yeah this is from the specification

00:11:53,500 --> 00:11:59,560
and it's quite interesting the the D

00:11:56,890 --> 00:12:04,210
test I kind of tells you if you're right

00:11:59,560 --> 00:12:06,430
or wrong and yeah the same goes for the

00:12:04,210 --> 00:12:09,430
pressure the pressure has some something

00:12:06,430 --> 00:12:11,320
in here that it factors in the sampling

00:12:09,430 --> 00:12:15,460
which is quite interesting so you have

00:12:11,320 --> 00:12:17,740
basically put in some yeah a binary

00:12:15,460 --> 00:12:19,930
pattern and you add the sampling so it

00:12:17,740 --> 00:12:22,810
kind of knows where how long it should

00:12:19,930 --> 00:12:25,720
read or rather what did you what did how

00:12:22,810 --> 00:12:27,130
accurate it should be and you have to

00:12:25,720 --> 00:12:29,970
figure out the nearside how long you

00:12:27,130 --> 00:12:34,030
should wait in order to get the right

00:12:29,970 --> 00:12:36,130
yeah the right reading out of this and

00:12:34,030 --> 00:12:37,030
then the register here is for example

00:12:36,130 --> 00:12:39,490
three bytes

00:12:37,030 --> 00:12:41,740
the other one was two bytes so this time

00:12:39,490 --> 00:12:44,050
you have three bytes and yeah I wasn't

00:12:41,740 --> 00:12:48,270
really sure how to put this in use the

00:12:44,050 --> 00:12:50,830
u-32 and then I used the integer a

00:12:48,270 --> 00:12:52,810
32-bit integer because I wasn't sure if

00:12:50,830 --> 00:12:56,589
there's negative pressure that it can

00:12:52,810 --> 00:12:59,170
read something this these are the sort

00:12:56,589 --> 00:13:00,930
of things that you deal with a lot so

00:12:59,170 --> 00:13:03,880
every temperature is quite easy here

00:13:00,930 --> 00:13:08,380
this basically directly gives you back

00:13:03,880 --> 00:13:10,089
Celsius the read pressure is a bit more

00:13:08,380 --> 00:13:13,000
complicated so you read the temperature

00:13:10,089 --> 00:13:14,680
in order to obtain a coefficient that

00:13:13,000 --> 00:13:17,080
you only get when you're reading to

00:13:14,680 --> 00:13:19,810
temperature so the temperature

00:13:17,080 --> 00:13:20,660
influences the pressure reading quite a

00:13:19,810 --> 00:13:24,560
lot

00:13:20,660 --> 00:13:26,990
then you have coefficients you read from

00:13:24,560 --> 00:13:29,029
your you know from your calibration

00:13:26,990 --> 00:13:31,550
earlier and then you do a bit more of

00:13:29,029 --> 00:13:36,620
random more or less random calculations

00:13:31,550 --> 00:13:42,139
of stuff you know that makes it quite

00:13:36,620 --> 00:13:45,769
easy to kind of so I started off using

00:13:42,139 --> 00:13:49,089
you 64 and then I narrowed it down until

00:13:45,769 --> 00:13:51,319
until it fails sort of and then yeah

00:13:49,089 --> 00:13:56,449
yeah and then you returned pascal

00:13:51,319 --> 00:14:02,569
indians so that's that's that's the

00:13:56,449 --> 00:14:03,980
secret sauce I guess in there so this is

00:14:02,569 --> 00:14:08,240
this is destruct itself

00:14:03,980 --> 00:14:10,370
there's no no no big secret here does

00:14:08,240 --> 00:14:13,160
this is reading the the coefficients

00:14:10,370 --> 00:14:16,160
that a new method really goes into and

00:14:13,160 --> 00:14:18,290
reads like a bunch of 10 10 or something

00:14:16,160 --> 00:14:20,810
coefficients from the device and returns

00:14:18,290 --> 00:14:23,089
it here and then you save it and then

00:14:20,810 --> 00:14:26,420
this is for the lifetime so I guess if

00:14:23,089 --> 00:14:28,759
you probably change altitude a lot so if

00:14:26,420 --> 00:14:30,410
you you know calibrated at the bottom of

00:14:28,759 --> 00:14:34,009
a mountain and then go up maybe this

00:14:30,410 --> 00:14:36,560
changes I didn't try that so if anyone

00:14:34,009 --> 00:14:38,980
does that please let me know submit a

00:14:36,560 --> 00:14:42,800
pull request and github or something

00:14:38,980 --> 00:14:45,439
because that would be interesting what I

00:14:42,800 --> 00:14:49,550
used was from i from the i2c dev library

00:14:45,439 --> 00:14:51,860
since this guy already created a

00:14:49,550 --> 00:14:54,949
barometer and thermometer trait i

00:14:51,860 --> 00:14:57,529
implemented those sort of i thought it

00:14:54,949 --> 00:15:00,199
was a nice thing to integrate with so

00:14:57,529 --> 00:15:05,839
this is was yeah a fairly simple fairly

00:15:00,199 --> 00:15:09,639
simple thing to do um to do here and as

00:15:05,839 --> 00:15:12,740
I said the coefficients so just just a

00:15:09,639 --> 00:15:14,870
massive amount of reading done here and

00:15:12,740 --> 00:15:17,029
then save it it's not nothing special

00:15:14,870 --> 00:15:19,279
and here is the test

00:15:17,029 --> 00:15:23,059
no actually it's more tests than that

00:15:19,279 --> 00:15:27,529
but it's yeah first of all I have to had

00:15:23,059 --> 00:15:29,870
to implement a mock device and for the

00:15:27,529 --> 00:15:32,569
mock device to kind of save data and

00:15:29,870 --> 00:15:34,779
return it properly in order to test you

00:15:32,569 --> 00:15:36,369
know what I was calculating

00:15:34,779 --> 00:15:41,769
since I wasn't really sure how this

00:15:36,369 --> 00:15:44,230
works and yeah there's a lot of stuff

00:15:41,769 --> 00:15:46,720
going into the calibration so I faked

00:15:44,230 --> 00:15:49,689
the calibration and the calibration

00:15:46,720 --> 00:15:53,920
itself and the writing of course you

00:15:49,689 --> 00:15:56,350
saved it into a bearable but the writing

00:15:53,920 --> 00:15:58,929
itself so the the test that was from the

00:15:56,350 --> 00:16:01,529
specification was basically giving you a

00:15:58,929 --> 00:16:04,029
bunch of coefficient coefficient

00:16:01,529 --> 00:16:06,160
calibration values and then an input

00:16:04,029 --> 00:16:09,279
value and then what the output should be

00:16:06,160 --> 00:16:12,850
and then you kind of iterate on that as

00:16:09,279 --> 00:16:14,980
as long as needed until it worked which

00:16:12,850 --> 00:16:17,589
is probably not the way to do this

00:16:14,980 --> 00:16:20,079
properly but this was this is currently

00:16:17,589 --> 00:16:22,480
the only thing that I have in order to

00:16:20,079 --> 00:16:26,290
improve that driver I added a few tests

00:16:22,480 --> 00:16:28,269
on top of that so I tried to do come up

00:16:26,290 --> 00:16:30,519
with some crazy values and in the end

00:16:28,269 --> 00:16:34,329
also have a random testing that just

00:16:30,519 --> 00:16:37,809
shoots in reading values and then it

00:16:34,329 --> 00:16:41,589
should not crash it's the mean not a

00:16:37,809 --> 00:16:48,160
main goal here so yeah that was a quick

00:16:41,589 --> 00:16:56,499
run-through how to implement this so but

00:16:48,160 --> 00:17:01,269
we can look at it in action so I'm here

00:16:56,499 --> 00:17:05,980
connected by H onto this thing so it

00:17:01,269 --> 00:17:08,769
only has a network with me right and in

00:17:05,980 --> 00:17:11,649
order to connect and i2c device to a

00:17:08,769 --> 00:17:13,990
Raspberry Pi you need to load some

00:17:11,649 --> 00:17:16,510
common modules that probably come with

00:17:13,990 --> 00:17:20,289
with raspbian they're probably already

00:17:16,510 --> 00:17:22,600
loaded and then you have some tools in

00:17:20,289 --> 00:17:27,880
order to work with all of that I to see

00:17:22,600 --> 00:17:30,490
stuff from the get-go so you can do I to

00:17:27,880 --> 00:17:33,549
see detect and then you get the matrix

00:17:30,490 --> 00:17:37,000
of stuff let's connect there and as we

00:17:33,549 --> 00:17:42,549
can see 77 is connected so the sensor is

00:17:37,000 --> 00:17:47,049
sort of detected and ready to go now

00:17:42,549 --> 00:17:48,659
what I created like a small small

00:17:47,049 --> 00:17:53,279
project here

00:17:48,659 --> 00:17:56,039
which yeah is a small else as you

00:17:53,279 --> 00:17:59,909
probably have guessed so this is this is

00:17:56,039 --> 00:18:02,309
just saying it just has the sensor the

00:17:59,909 --> 00:18:04,760
sensor driver as a dependency and I to

00:18:02,309 --> 00:18:08,370
see deaf in order to get out those

00:18:04,760 --> 00:18:12,390
traits to use the barometer in

00:18:08,370 --> 00:18:16,529
thermometer and the same in that way and

00:18:12,390 --> 00:18:20,970
when we look at at the code itself so

00:18:16,529 --> 00:18:22,830
this is all extant rates up there yeah

00:18:20,970 --> 00:18:26,039
we have some new statements and here are

00:18:22,830 --> 00:18:29,429
the department and thermometer

00:18:26,039 --> 00:18:32,880
traits and this is this is an import for

00:18:29,429 --> 00:18:35,130
for getting the i2c device from the from

00:18:32,880 --> 00:18:37,350
the operating system into the code

00:18:35,130 --> 00:18:41,220
essentially because the operating system

00:18:37,350 --> 00:18:44,070
or the kernel module for ITC Maps it as

00:18:41,220 --> 00:18:48,630
a regular device and then you have to

00:18:44,070 --> 00:18:50,640
ITC - one and this is your bus and you

00:18:48,630 --> 00:18:53,610
write binary data to the bus and then

00:18:50,640 --> 00:18:58,080
stuff comes back and it all comes

00:18:53,610 --> 00:19:01,470
together essentially yeah instantiation

00:18:58,080 --> 00:19:04,710
and then just a infinite loop of

00:19:01,470 --> 00:19:08,070
printing and waiting for stuff so we can

00:19:04,710 --> 00:19:08,760
I already built it because building on a

00:19:08,070 --> 00:19:13,590
Raspberry Pi

00:19:08,760 --> 00:19:19,080
takes a while so in this case it should

00:19:13,590 --> 00:19:20,850
not do anything and we have to run the

00:19:19,080 --> 00:19:27,899
binary directory because we're gonna use

00:19:20,850 --> 00:19:29,909
sudo so and yeah this is it so it reads

00:19:27,899 --> 00:19:36,090
that it has 25 degrees Celsius in here

00:19:29,909 --> 00:19:44,909
and we can warm it up maybe a bit so

00:19:36,090 --> 00:19:46,140
yeah and of course it crashes yeah that

00:19:44,909 --> 00:19:48,369
gives you something to work on the

00:19:46,140 --> 00:19:51,619
weekend

00:19:48,369 --> 00:19:55,029
yeah that's that's I I think I touched

00:19:51,619 --> 00:19:58,419
it but that's that's the sort of stuff

00:19:55,029 --> 00:20:02,509
you deal with when you have devices and

00:19:58,419 --> 00:20:04,389
yeah I can turn it on again but I think

00:20:02,509 --> 00:20:08,119
it doesn't change much

00:20:04,389 --> 00:20:13,129
yeah so let's go on to the pitfalls

00:20:08,119 --> 00:20:16,399
right so this this happens especially it

00:20:13,129 --> 00:20:18,469
is multiplied with overflow as we can

00:20:16,399 --> 00:20:20,839
see it is this would probably wouldn't

00:20:18,469 --> 00:20:24,259
happen in Python as much or maybe not at

00:20:20,839 --> 00:20:27,830
all since it has very let's say flexible

00:20:24,259 --> 00:20:29,869
data structures there and then see also

00:20:27,830 --> 00:20:32,779
there's sometimes students like yeah use

00:20:29,869 --> 00:20:34,729
this number pointer and then you do some

00:20:32,779 --> 00:20:38,139
magic on in the end you say it's like

00:20:34,729 --> 00:20:41,629
yeah this is now basically a 16-bit

00:20:38,139 --> 00:20:43,789
signed integer and and it all kind of

00:20:41,629 --> 00:20:46,460
works it's now it's not complaining as

00:20:43,789 --> 00:20:48,469
much Russ complains a lot which is

00:20:46,460 --> 00:20:50,719
probably good because it makes you

00:20:48,469 --> 00:20:55,669
figure out the boundaries of the whole

00:20:50,719 --> 00:20:58,489
thing then Indian Ness of course I dealt

00:20:55,669 --> 00:21:01,519
a lot with that because it's both both

00:20:58,489 --> 00:21:04,599
of these give you a number the question

00:21:01,519 --> 00:21:06,710
is only what number and can you you know

00:21:04,599 --> 00:21:10,489
sometimes it doesn't really say or it's

00:21:06,710 --> 00:21:12,499
not clear what what they actually give

00:21:10,489 --> 00:21:14,479
you back and maybe sometimes it changes

00:21:12,499 --> 00:21:18,049
because you can read two registers with

00:21:14,479 --> 00:21:21,049
each byte and then you have a 16 16 bit

00:21:18,049 --> 00:21:22,149
number and you know you can use it

00:21:21,049 --> 00:21:27,320
however you want

00:21:22,149 --> 00:21:30,200
it's maybe not right though yeah the

00:21:27,320 --> 00:21:34,129
tests or tests or however many you can

00:21:30,200 --> 00:21:35,929
make out is it's very interesting and

00:21:34,129 --> 00:21:38,299
this was valuable feedback right it's

00:21:35,929 --> 00:21:40,460
not I tried it I have used this sensor

00:21:38,299 --> 00:21:42,559
and this driver a lot of a lot of times

00:21:40,460 --> 00:21:46,940
I did never crash for me it's like that

00:21:42,559 --> 00:21:48,889
so I can use this valuable feedback to

00:21:46,940 --> 00:21:53,989
kind of try and figure out what went

00:21:48,889 --> 00:21:55,759
wrong there and yeah it's you know

00:21:53,989 --> 00:21:57,320
that's different since this is physics

00:21:55,759 --> 00:21:59,810
about this could be very different

00:21:57,320 --> 00:22:01,700
experience for someone who lives in

00:21:59,810 --> 00:22:03,650
or something where they have like a

00:22:01,700 --> 00:22:07,720
thousand meters above sea level by

00:22:03,650 --> 00:22:11,420
default and here we have like what 30 so

00:22:07,720 --> 00:22:12,980
there's differences in yeah and a lot of

00:22:11,420 --> 00:22:16,250
things and it's very hard to get it

00:22:12,980 --> 00:22:18,790
right and of course you have you know

00:22:16,250 --> 00:22:22,880
some minor things like cross compilation

00:22:18,790 --> 00:22:25,520
issues that for example these io things

00:22:22,880 --> 00:22:27,440
don't build very well on a Mac because

00:22:25,520 --> 00:22:29,870
there's something missing that I didn't

00:22:27,440 --> 00:22:33,880
know what it was I just used the virtual

00:22:29,870 --> 00:22:36,440
machine because Linux works really well

00:22:33,880 --> 00:22:38,120
and of course dependencies you walk

00:22:36,440 --> 00:22:41,390
straight in the dependency hell if you

00:22:38,120 --> 00:22:43,250
don't keep it updated or yeah if you add

00:22:41,390 --> 00:22:45,700
too many dependencies and you have like

00:22:43,250 --> 00:22:49,280
I think this driver has not like for

00:22:45,700 --> 00:22:51,650
just by one by adding one crate but yeah

00:22:49,280 --> 00:22:54,050
other other project I have have like

00:22:51,650 --> 00:22:58,370
hundred dependencies just from nothing

00:22:54,050 --> 00:23:00,200
essentially yeah and of course I learn

00:22:58,370 --> 00:23:02,630
something so that drivers are not that

00:23:00,200 --> 00:23:05,330
scary to implement they're sort of fun

00:23:02,630 --> 00:23:08,260
actually and and you can you know you

00:23:05,330 --> 00:23:10,640
can interact with the real world and

00:23:08,260 --> 00:23:15,230
especially since I to see is fairly

00:23:10,640 --> 00:23:17,330
simple as a as a bus system to work it's

00:23:15,230 --> 00:23:20,270
like to operations and registers and

00:23:17,330 --> 00:23:22,190
addresses and then you're good to go but

00:23:20,270 --> 00:23:25,250
the devices itself make it sort of

00:23:22,190 --> 00:23:27,290
complex to to work with and that's or

00:23:25,250 --> 00:23:31,700
that's also kind of the interesting part

00:23:27,290 --> 00:23:34,850
of all of that rust as a language works

00:23:31,700 --> 00:23:38,510
really well on on low memory devices and

00:23:34,850 --> 00:23:41,960
they have yeah you can create something

00:23:38,510 --> 00:23:45,320
very nice with also a very little effort

00:23:41,960 --> 00:23:46,820
or rather little effort I did something

00:23:45,320 --> 00:23:47,990
with typescript the other day and it

00:23:46,820 --> 00:23:49,910
kind of yeah

00:23:47,990 --> 00:23:51,950
it only took pictures of about three

00:23:49,910 --> 00:23:53,690
megabytes then serialized a picture that

00:23:51,950 --> 00:23:55,640
took about ten megabytes the whole

00:23:53,690 --> 00:23:58,760
application had about a hundred and ten

00:23:55,640 --> 00:24:03,320
megabytes for some reason that I didn't

00:23:58,760 --> 00:24:04,790
know and yeah it used to run out of

00:24:03,320 --> 00:24:07,940
memory because the garbage click that

00:24:04,790 --> 00:24:12,470
didn't go into going as quickly as a

00:24:07,940 --> 00:24:13,680
thought so yeah it was not the greatest

00:24:12,470 --> 00:24:17,100
experiences

00:24:13,680 --> 00:24:19,380
the rest unfortunate and yeah there's a

00:24:17,100 --> 00:24:23,880
lot of CPU architectures available to

00:24:19,380 --> 00:24:27,000
build for and it's yeah drivers are

00:24:23,880 --> 00:24:30,750
great to do just do stuff with IOT then

00:24:27,000 --> 00:24:35,100
you can yeah fancy yourself being an IOT

00:24:30,750 --> 00:24:36,600
person quite quickly so yeah as a

00:24:35,100 --> 00:24:40,680
summary if you didn't pay attention

00:24:36,600 --> 00:24:42,840
until now I have just grabbed I to see

00:24:40,680 --> 00:24:45,060
death if you have an i2c sensor figure

00:24:42,840 --> 00:24:49,170
out the messaging protocol created wrap

00:24:45,060 --> 00:24:53,570
it into a nice API and find tests it's I

00:24:49,170 --> 00:24:56,070
think the mean are things to do here

00:24:53,570 --> 00:24:58,620
something that is nice to work with is

00:24:56,070 --> 00:25:01,710
the tehsil since it has comes

00:24:58,620 --> 00:25:04,710
prepackaged with rust api for all of

00:25:01,710 --> 00:25:07,910
their senses i think and it's yeah it's

00:25:04,710 --> 00:25:10,980
a similar board as the Raspberry Pi and

00:25:07,910 --> 00:25:14,340
yeah it's documentation and all kinds of

00:25:10,980 --> 00:25:16,560
stuff and the other two things are links

00:25:14,340 --> 00:25:20,910
to the crates I've been using and

00:25:16,560 --> 00:25:22,800
developing so thank you it's not time

00:25:20,910 --> 00:25:40,800
for questions and you can follow me in

00:25:22,800 --> 00:25:42,210
Twitter questions anyone so maybe it

00:25:40,800 --> 00:25:45,660
wasn't paying attention that when you

00:25:42,210 --> 00:25:49,140
showed the code but did you use any and

00:25:45,660 --> 00:26:05,610
safe features or was it no it's all safe

00:25:49,140 --> 00:26:07,740
it's all safe yeah just one question so

00:26:05,610 --> 00:26:09,840
I use it on wesberry pi did you tried

00:26:07,740 --> 00:26:11,840
any bare bones and I'm serious like an

00:26:09,840 --> 00:26:17,160
ARM Cortex or something like that

00:26:11,840 --> 00:26:19,800
no so when I started I thought of

00:26:17,160 --> 00:26:22,470
creating like there's this rust

00:26:19,800 --> 00:26:24,270
operating system project areas that you

00:26:22,470 --> 00:26:27,640
also can run on a recipe I thought of

00:26:24,270 --> 00:26:30,580
using trying to do that and make it just

00:26:27,640 --> 00:26:41,440
have a driver but I think this would

00:26:30,580 --> 00:26:46,110
have went too far so no anyone else okay

00:26:41,440 --> 00:26:46,110
then I'm calling it thank you very much

00:26:46,190 --> 00:26:50,529
[Applause]

00:26:50,550 --> 00:26:56,110
and thank you everyone for attending it

00:26:53,560 --> 00:26:57,190
was really nice and you can stay around

00:26:56,110 --> 00:26:58,960
if you want I'm not gonna leave

00:26:57,190 --> 00:27:00,550
immediately so if you want to eat some

00:26:58,960 --> 00:27:02,080
of the leftover bagels or just have

00:27:00,550 --> 00:27:04,740
another drink and talk you can do that

00:27:02,080 --> 00:27:07,510
but you are also free to leave of course

00:27:04,740 --> 00:27:09,610
and yeah see you next time we will have

00:27:07,510 --> 00:27:11,920
meetup in late October I haven't settled

00:27:09,610 --> 00:27:14,760
on a date yet but we will yeah let you

00:27:11,920 --> 00:27:14,760

YouTube URL: https://www.youtube.com/watch?v=VMaKQ8_y_6s


