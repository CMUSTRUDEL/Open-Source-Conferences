Title: Rust Berlin October 2017 - Application containers for IoT and BDD in Rust
Publication date: 2017-10-19
Playlist: Rust Berlin
Description: 
	We are aware of audio issues in Vincents talk and are working on providing subtitles as a replacement.

Arvid E. Picciani (https://github.com/aep)

Application container deployment for the Internet of Things with Rust

Solving containerization on very constrained devices will enable a new way we deliver system updates to embedded systems. We'll learn about one possible approach with korhal's bolter and how it ties into the interplanetary hash router to deliver content addressable system updates to microcontrollers anywhere, without a cloud.


Arvid is a controversial break-the-whole-box-thinker getting hired to put Linux on stuff where Linux would prefer to not be with deadlines you'd prefer to not have. He's currently CTO of superscale networks and Founder of korhal.io, an organization dedicated to liberating IoT and preventing consumer lock-in.


Vincent Esche (https://github.com/regexident)

rspec and what it takes to make a BDD test framework in stable Rust

While the existence of native language-level support for unit testing in Rust is a blessing, classical JUnit-style unit testing can feel a bit antiquated at times. You. Just. Keep. Repeating. Yourself. This is where BDD frameworks come in with their shared scopes and user-friendly matchers. Rspec's aim is to provide the BDD testing experience to Rust without the need to bend over backwards or drink the nightly kool-aid. Tests should be just as stable as the rest of your code, if not more. After all who tests your tests if those break?


A mobile dev lead writing Swift at an emerging fitness/health and IoT startup in Berlin by day, and Rustacean by night, Vincent authored cargo modules and rustfmt's comprehensive configuration guide and is currently working on a modern and extensible Support Vector Machine implementation in Rust.
Captions: 
	00:00:01,929 --> 00:00:08,780
alright let's just start hello everyone

00:00:06,319 --> 00:00:10,340
thanks for being here this is the rust

00:00:08,780 --> 00:00:12,619
Berlin meetup the second one in this

00:00:10,340 --> 00:00:17,210
wonderful new office I'm really glad

00:00:12,619 --> 00:00:19,279
that you're all here we have two Talk's

00:00:17,210 --> 00:00:20,749
today the first is a bead who talks

00:00:19,279 --> 00:00:22,039
about application content container

00:00:20,749 --> 00:00:25,339
deployment for the Internet of Things

00:00:22,039 --> 00:00:27,800
with rust which is really exciting then

00:00:25,339 --> 00:00:29,509
we have a five minutes break and then

00:00:27,800 --> 00:00:31,489
Vincent will talk about our step back

00:00:29,509 --> 00:00:33,830
and what it takes to make a bdd test

00:00:31,489 --> 00:00:38,720
framework in rust which is also really

00:00:33,830 --> 00:00:43,490
exciting if you want to do a talk please

00:00:38,720 --> 00:00:45,710
reach out to me via personal

00:00:43,490 --> 00:00:48,050
communication or you know email or

00:00:45,710 --> 00:00:50,420
message on meetup or in any way you like

00:00:48,050 --> 00:00:52,220
if you're not sure if it's good we can

00:00:50,420 --> 00:00:55,030
we can talk about it and we can like

00:00:52,220 --> 00:00:57,350
work something out I'm sure it's good

00:00:55,030 --> 00:00:59,210
there's also the rust tech and learn

00:00:57,350 --> 00:01:01,010
which is our co learning group which is

00:00:59,210 --> 00:01:02,840
kind of in cooperation with open tech

00:01:01,010 --> 00:01:05,210
school and I can totally recommend you

00:01:02,840 --> 00:01:07,999
to go there it's every second Wednesday

00:01:05,210 --> 00:01:09,229
so it would be today but we're having

00:01:07,999 --> 00:01:11,899
the rust meetup so that's why it's not

00:01:09,229 --> 00:01:14,869
today so that it means it's next in two

00:01:11,899 --> 00:01:17,509
weeks from now in this office in the

00:01:14,869 --> 00:01:19,880
community space at 7 p.m. so feel free

00:01:17,509 --> 00:01:22,069
to come there and it's like a open

00:01:19,880 --> 00:01:23,810
hacking learning session where you can

00:01:22,069 --> 00:01:25,850
just work on rust stuff and get stuff

00:01:23,810 --> 00:01:28,819
explained from other people or explain

00:01:25,850 --> 00:01:30,590
stuff to other people last but not least

00:01:28,819 --> 00:01:34,399
we have a code of conduct and we're

00:01:30,590 --> 00:01:36,439
ready to enforce it so if you notice

00:01:34,399 --> 00:01:39,490
anything if somebody isn't treating you

00:01:36,439 --> 00:01:42,590
as they should please reach out to me or

00:01:39,490 --> 00:01:44,179
reach out to Valerie who is our security

00:01:42,590 --> 00:01:46,819
person now I can get you in touch if you

00:01:44,179 --> 00:01:49,639
would like to talk to a woman and we

00:01:46,819 --> 00:01:55,100
will handle it and yeah that's about it

00:01:49,639 --> 00:01:58,959
thank you okay I'll give over to a beat

00:01:55,100 --> 00:01:58,959
for the first talk Thanks

00:02:02,240 --> 00:02:11,730
thank you young let me just get set it

00:02:05,070 --> 00:02:20,970
up set up here of Linux in my laptop so

00:02:11,730 --> 00:02:26,519
it's gonna take a while to wake up yeah

00:02:20,970 --> 00:02:28,349
I was actually instantaneous okay great

00:02:26,519 --> 00:02:30,000
works cool

00:02:28,349 --> 00:02:33,799
so hey welcome everyone thank you for

00:02:30,000 --> 00:02:37,860
coming I'm Arvid I'm the CTO of

00:02:33,799 --> 00:02:38,280
superscalar networks and also founder of

00:02:37,860 --> 00:02:41,489
Korhal

00:02:38,280 --> 00:02:43,079
I'm gonna today talk about Kohala the

00:02:41,489 --> 00:02:45,420
project dedicated to liberating the

00:02:43,079 --> 00:02:47,129
Internet of Things I'm going to

00:02:45,420 --> 00:02:48,420
introduce our con and vulture today two

00:02:47,129 --> 00:02:51,900
of our projects that we that were

00:02:48,420 --> 00:02:54,209
working on closer this which are just

00:02:51,900 --> 00:02:56,970
working last week so if the demo also

00:02:54,209 --> 00:02:58,680
broken please bear with me you know that

00:02:56,970 --> 00:03:00,840
that's the usual thing people say then

00:02:58,680 --> 00:03:04,620
they break but I tested them two more

00:03:00,840 --> 00:03:05,190
air today so cool so let's get started

00:03:04,620 --> 00:03:09,150
on this

00:03:05,190 --> 00:03:10,709
so since I'm going to talk about a lot

00:03:09,150 --> 00:03:12,540
about the Internet of Things today I

00:03:10,709 --> 00:03:15,889
just want to get something out of the

00:03:12,540 --> 00:03:18,060
way when I talk about Internet of Things

00:03:15,889 --> 00:03:21,120
there is something specific I mean by

00:03:18,060 --> 00:03:23,069
that and so it's important to get the

00:03:21,120 --> 00:03:26,099
perspective of that there it's certainly

00:03:23,069 --> 00:03:27,690
interesting to get deployments working

00:03:26,099 --> 00:03:28,889
or applications to deployments when

00:03:27,690 --> 00:03:31,019
system deployments working on small

00:03:28,889 --> 00:03:33,030
computers but that's not what I'm gonna

00:03:31,019 --> 00:03:35,340
talk to about today about today I'm

00:03:33,030 --> 00:03:37,769
gonna talk about much smaller and

00:03:35,340 --> 00:03:41,579
cheaper devices specifically things like

00:03:37,769 --> 00:03:45,269
edge gateways or gateway devices I call

00:03:41,579 --> 00:03:47,099
them embedded also things like small

00:03:45,269 --> 00:03:48,750
computer and consumer devices like the

00:03:47,099 --> 00:03:50,489
Amazon echo if you have one those are

00:03:48,750 --> 00:03:52,590
little devices that I put in the middle

00:03:50,489 --> 00:03:54,419
and then we have constrained devices on

00:03:52,590 --> 00:03:56,400
the on the far right of the picture

00:03:54,419 --> 00:03:57,810
which are something like the sensor

00:03:56,400 --> 00:03:59,790
nodes things like that they don't even

00:03:57,810 --> 00:04:02,370
run Linux so it's important to

00:03:59,790 --> 00:04:03,810
understand that this is this is IOT when

00:04:02,370 --> 00:04:10,049
I talk about that it's it's not about

00:04:03,810 --> 00:04:11,939
raspberry PI's let's do a test so so to

00:04:10,049 --> 00:04:13,980
see it a test to see if everyone's awake

00:04:11,939 --> 00:04:15,180
not just kidding let's do a test

00:04:13,980 --> 00:04:18,239
raise your hands

00:04:15,180 --> 00:04:19,910
you know that wpa2 the Wi-Fi encryption

00:04:18,239 --> 00:04:22,109
is broken

00:04:19,910 --> 00:04:24,680
that's a lot of educated people I'm

00:04:22,109 --> 00:04:28,080
really glad I don't have to explain that

00:04:24,680 --> 00:04:30,449
now we do something more harder raise

00:04:28,080 --> 00:04:33,120
your hands if all of your devices in

00:04:30,449 --> 00:04:36,000
your home including your router your

00:04:33,120 --> 00:04:41,340
phone your toaster your lightbulbs are

00:04:36,000 --> 00:04:43,500
updated that's absolutely no one let's

00:04:41,340 --> 00:04:47,130
face it we have an update problem in IOT

00:04:43,500 --> 00:04:50,400
and it's dramatic so what I mean by

00:04:47,130 --> 00:04:52,530
dramatic is take the Mirai botnet which

00:04:50,400 --> 00:04:55,440
is which took down a million telecom

00:04:52,530 --> 00:04:58,620
bruders in 2016 and almost broke the

00:04:55,440 --> 00:05:01,470
internet it took down github it runs on

00:04:58,620 --> 00:05:01,919
I think IP cameras yeah something like

00:05:01,470 --> 00:05:03,720
that

00:05:01,919 --> 00:05:05,699
and these IT primers don't get any

00:05:03,720 --> 00:05:07,169
updates anymore and I'm not even going

00:05:05,699 --> 00:05:08,639
to talk about things like I mean it's

00:05:07,169 --> 00:05:10,530
just IP cameras you could think right

00:05:08,639 --> 00:05:11,910
but we also have other IT device which

00:05:10,530 --> 00:05:14,220
are much more critical things like

00:05:11,910 --> 00:05:16,740
nuclear power plans but we're not going

00:05:14,220 --> 00:05:18,630
to talk about that today because as we

00:05:16,740 --> 00:05:21,630
say in Germany untie design for video

00:05:18,630 --> 00:05:24,599
before conference each other I'm going

00:05:21,630 --> 00:05:26,280
to leave you with that so now let me try

00:05:24,599 --> 00:05:28,229
to explain what I'm a part of what I'm

00:05:26,280 --> 00:05:29,729
doing with quarrel it is essentially a

00:05:28,229 --> 00:05:31,409
solution to some of the problems that

00:05:29,729 --> 00:05:33,630
have been seen the last 15 years working

00:05:31,409 --> 00:05:35,099
on embedded devices we're embedded

00:05:33,630 --> 00:05:38,130
Internet connected devices specifically

00:05:35,099 --> 00:05:40,880
if you work in embedded devices you know

00:05:38,130 --> 00:05:43,650
that our tool chains are terribly broken

00:05:40,880 --> 00:05:46,050
you were to look within yet web

00:05:43,650 --> 00:05:48,150
developers we've got things like docker

00:05:46,050 --> 00:05:50,310
we've got things like radar DES and

00:05:48,150 --> 00:05:51,960
great languages I mean not that

00:05:50,310 --> 00:05:54,720
javascript is great but you know other

00:05:51,960 --> 00:05:56,610
languages specifically engineered for

00:05:54,720 --> 00:05:57,990
web developers which are which are great

00:05:56,610 --> 00:05:59,970
there's a vast echo system out there

00:05:57,990 --> 00:06:02,580
with embedded devices we're pretty much

00:05:59,970 --> 00:06:03,479
stuck with printf C debugging and a

00:06:02,580 --> 00:06:07,349
screwdriver

00:06:03,479 --> 00:06:10,949
if you're lucky so it's not great until

00:06:07,349 --> 00:06:13,440
rust came along rust really gave me hope

00:06:10,949 --> 00:06:14,849
that someone is designing an ecosystem

00:06:13,440 --> 00:06:16,580
that's actually going to work on

00:06:14,849 --> 00:06:18,570
automatic and constraint systems and

00:06:16,580 --> 00:06:21,539
what I'm gonna what I'm going to present

00:06:18,570 --> 00:06:23,330
now is my part in that ecosystem and in

00:06:21,539 --> 00:06:25,979
the hope that someday we're gonna have

00:06:23,330 --> 00:06:27,840
tools in in embedded that are actually

00:06:25,979 --> 00:06:28,380
equal in quality to what we have in

00:06:27,840 --> 00:06:31,890
embedding

00:06:28,380 --> 00:06:33,840
in web development I'm gonna keep this

00:06:31,890 --> 00:06:35,550
brother short today um there's a whole

00:06:33,840 --> 00:06:37,170
bunch of things we do with Korhal but

00:06:35,550 --> 00:06:39,270
I'm going to talk about arcane and

00:06:37,170 --> 00:06:41,490
bolter which are fairly interesting

00:06:39,270 --> 00:06:43,470
things and as I said they work unlike

00:06:41,490 --> 00:06:45,930
what we're planning for example with the

00:06:43,470 --> 00:06:47,100
Crypt incentivized edge network which

00:06:45,930 --> 00:06:49,130
doesn't work yet so I'm not going to

00:06:47,100 --> 00:06:52,520
talk about that yet

00:06:49,130 --> 00:06:56,700
specifically Archon is in its use case

00:06:52,520 --> 00:06:59,070
very similar to to docker it allows you

00:06:56,700 --> 00:07:01,140
to to just to just store a bunch of

00:06:59,070 --> 00:07:02,670
files in an image and you can deploy

00:07:01,140 --> 00:07:04,890
that image as a single file

00:07:02,670 --> 00:07:07,770
unlike docker it thought it doesn't use

00:07:04,890 --> 00:07:08,790
layers docker uses layers what we do is

00:07:07,770 --> 00:07:11,420
we use a content addressable storage

00:07:08,790 --> 00:07:13,320
okay I'm gonna explain what that is a

00:07:11,420 --> 00:07:16,650
content in the rest of the storage is

00:07:13,320 --> 00:07:18,620
very similar to what you think Dropbox

00:07:16,650 --> 00:07:21,630
will hopefully do or similar service

00:07:18,620 --> 00:07:24,030
instead of indexing data like your

00:07:21,630 --> 00:07:26,250
filesystem does by name it indexes it by

00:07:24,030 --> 00:07:30,750
a content or by the address of the

00:07:26,250 --> 00:07:32,580
content supplied by its hash so imagine

00:07:30,750 --> 00:07:35,750
you and me both of a music library on

00:07:32,580 --> 00:07:39,750
Dropbox or a similar storage service

00:07:35,750 --> 00:07:43,110
we're both kind of storing heavy mp3

00:07:39,750 --> 00:07:44,700
there in in my picture and now what what

00:07:43,110 --> 00:07:46,410
you think is heavy and what I think is

00:07:44,700 --> 00:07:48,780
heavy it might be different I think your

00:07:46,410 --> 00:07:50,310
music is rather lame so they're gonna be

00:07:48,780 --> 00:07:52,350
different although we both call them

00:07:50,310 --> 00:07:53,970
heavy right but we can kind of both

00:07:52,350 --> 00:07:56,880
agree then Taylor Swift is cool so we

00:07:53,970 --> 00:07:58,350
both store the same file and Dropbox or

00:07:56,880 --> 00:07:59,730
similar service can figure out that

00:07:58,350 --> 00:08:02,370
there is the same file based on their

00:07:59,730 --> 00:08:04,680
content and can store only one of those

00:08:02,370 --> 00:08:06,210
so in those picture of four files but

00:08:04,680 --> 00:08:08,160
Dropbox is only going to store three and

00:08:06,210 --> 00:08:09,390
give us both a reference to one of these

00:08:08,160 --> 00:08:11,310
fights this is country content or

00:08:09,390 --> 00:08:13,320
estimate storage it's not new some of

00:08:11,310 --> 00:08:15,260
you will probably know what it is just

00:08:13,320 --> 00:08:18,560
explaining your context

00:08:15,260 --> 00:08:22,500
leading me to update safety on embedded

00:08:18,560 --> 00:08:24,510
update safety means that if we screw up

00:08:22,500 --> 00:08:27,720
anything on a device during update and

00:08:24,510 --> 00:08:30,210
I've screwed up things we need to be

00:08:27,720 --> 00:08:32,430
able to undo this because user

00:08:30,210 --> 00:08:33,539
interaction with devices with embedded

00:08:32,430 --> 00:08:35,700
devices they're out there with IOT

00:08:33,539 --> 00:08:37,740
devices is really expensive if you think

00:08:35,700 --> 00:08:39,450
of sending one fridge might be okay but

00:08:37,740 --> 00:08:40,729
sending like a millions of fridges it's

00:08:39,450 --> 00:08:43,729
going to be bankrupt

00:08:40,729 --> 00:08:45,589
company think of something like

00:08:43,729 --> 00:08:47,600
dieselgate would have been a lot less

00:08:45,589 --> 00:08:50,180
costly if Volkswagen goes like Tesla and

00:08:47,600 --> 00:08:51,620
just had removed updates but then there

00:08:50,180 --> 00:08:56,930
would be kind of cool in the first place

00:08:51,620 --> 00:08:58,790
so on embedded systems we can do various

00:08:56,930 --> 00:09:00,620
things for update safety

00:08:58,790 --> 00:09:02,810
so update safety in the skeins means

00:09:00,620 --> 00:09:04,699
again being able to rollback versions

00:09:02,810 --> 00:09:06,290
that don't work typically what we do is

00:09:04,699 --> 00:09:07,760
called dual systems so we just put two

00:09:06,290 --> 00:09:09,500
versions of the same system on it and if

00:09:07,760 --> 00:09:12,199
one has a back or something we just boot

00:09:09,500 --> 00:09:13,850
the other one and sometimes what people

00:09:12,199 --> 00:09:15,620
do is called a fat bootloader to just

00:09:13,850 --> 00:09:18,290
put the update capabilities inside the

00:09:15,620 --> 00:09:19,880
boot order so that you have a way if

00:09:18,290 --> 00:09:21,889
your system breaks your bootloader can

00:09:19,880 --> 00:09:23,540
still update your system that means

00:09:21,889 --> 00:09:26,600
you're putting the updater in the region

00:09:23,540 --> 00:09:29,420
of the memory that isn't updated you can

00:09:26,600 --> 00:09:31,310
get yourself why that a bad idea this is

00:09:29,420 --> 00:09:34,639
actually what Android does it's really

00:09:31,310 --> 00:09:37,100
really complicated what I'm proposing to

00:09:34,639 --> 00:09:39,320
do if is doing updates with content or

00:09:37,100 --> 00:09:40,790
storage this is again not new we've

00:09:39,320 --> 00:09:43,880
tried this before it didn't work I'll

00:09:40,790 --> 00:09:46,490
tell you why what you do there is you

00:09:43,880 --> 00:09:48,949
take both systems both versions of the

00:09:46,490 --> 00:09:51,620
system's like we did before but instead

00:09:48,949 --> 00:09:53,060
of storing them separately as full

00:09:51,620 --> 00:09:55,339
systems we just store the part that

00:09:53,060 --> 00:09:58,699
changed you see when we do system

00:09:55,339 --> 00:10:00,139
updates on embedded we do really big

00:09:58,699 --> 00:10:02,269
changes sometimes we just do a little

00:10:00,139 --> 00:10:03,310
bit of tweaking and then we do store the

00:10:02,269 --> 00:10:07,970
whole thing that's really inefficient

00:10:03,310 --> 00:10:10,490
it's also Network inefficient we do know

00:10:07,970 --> 00:10:12,139
how to share code I mean we do how to

00:10:10,490 --> 00:10:13,399
know how to make multi call binaries

00:10:12,139 --> 00:10:15,589
this is something we do for any

00:10:13,399 --> 00:10:17,420
something with busybox on embedded it's

00:10:15,589 --> 00:10:20,540
kind of like your shell toolkit and

00:10:17,420 --> 00:10:23,120
stuff like that just in one binary now

00:10:20,540 --> 00:10:25,519
that's that we know we'll also learn how

00:10:23,120 --> 00:10:28,670
considerable storage can be done we do

00:10:25,519 --> 00:10:29,899
this with our con and now what we don't

00:10:28,670 --> 00:10:31,579
know so far is how to do it with

00:10:29,899 --> 00:10:33,860
executables and this is the reason no

00:10:31,579 --> 00:10:37,579
one does this yet because executables

00:10:33,860 --> 00:10:40,370
are not like a linear story of like a

00:10:37,579 --> 00:10:43,130
poem or something like that executables

00:10:40,370 --> 00:10:45,110
are mostly just addresses so they jump

00:10:43,130 --> 00:10:47,029
to each other and continuously jump to

00:10:45,110 --> 00:10:48,500
other memory regions if you change the

00:10:47,029 --> 00:10:50,630
tiny part of it all of these addresses

00:10:48,500 --> 00:10:52,750
change and this is why you can't do it

00:10:50,630 --> 00:10:55,930
with controversial storage because

00:10:52,750 --> 00:10:57,190
and because these won't match with

00:10:55,930 --> 00:10:58,510
another executable the address is going

00:10:57,190 --> 00:11:00,160
to be completely different even if it

00:10:58,510 --> 00:11:03,820
just changed how the world into hello

00:11:00,160 --> 00:11:07,150
something right now what we do with

00:11:03,820 --> 00:11:09,610
bolter bolter is a completely new elf

00:11:07,150 --> 00:11:11,980
linker that replaces kin uld it's

00:11:09,610 --> 00:11:13,570
completely written in rust and it's

00:11:11,980 --> 00:11:15,580
completely written from scratch there is

00:11:13,570 --> 00:11:17,140
no new code in there nothing like that

00:11:15,580 --> 00:11:19,800
there's no license infection it's all

00:11:17,140 --> 00:11:22,810
MIT all open-source open and github and

00:11:19,800 --> 00:11:24,970
what we do with that is we link

00:11:22,810 --> 00:11:27,700
executables in a way that they're

00:11:24,970 --> 00:11:30,520
globally the same which means that if

00:11:27,700 --> 00:11:32,560
you link to executables both of which

00:11:30,520 --> 00:11:34,480
contain the same static library like a

00:11:32,560 --> 00:11:36,490
lip see or a lip OpenSSL or something

00:11:34,480 --> 00:11:40,420
like that no matter where you link it on

00:11:36,490 --> 00:11:42,250
earth or in space they're the same that

00:11:40,420 --> 00:11:46,390
allows us to deduplicate most of that

00:11:42,250 --> 00:11:48,520
code that is shared very similar to a

00:11:46,390 --> 00:11:51,100
music example by the way if you have

00:11:48,520 --> 00:11:53,080
recognized that this is not unlike

00:11:51,100 --> 00:11:54,670
dynamic libraries of course you're gonna

00:11:53,080 --> 00:11:57,460
say that boolean question is going to

00:11:54,670 --> 00:11:59,410
come up so dynamic library is a little

00:11:57,460 --> 00:12:01,690
different and we have this problem

00:11:59,410 --> 00:12:03,760
called DLL hell if you remember from if

00:12:01,690 --> 00:12:07,330
you ever worked on desktop systems like

00:12:03,760 --> 00:12:09,490
when they were relevant we had this

00:12:07,330 --> 00:12:13,360
problem that if you if you deploy shared

00:12:09,490 --> 00:12:15,310
code on a system that the code that gets

00:12:13,360 --> 00:12:16,900
executed at runtime on the user's

00:12:15,310 --> 00:12:19,330
machine might not be the one that you're

00:12:16,900 --> 00:12:20,530
expecting at linked time because the

00:12:19,330 --> 00:12:23,320
user might have updated different

00:12:20,530 --> 00:12:25,570
application that also need a library but

00:12:23,320 --> 00:12:26,950
a new version and your application code

00:12:25,570 --> 00:12:28,060
might be completely incompatible with

00:12:26,950 --> 00:12:30,250
that new version you don't have any

00:12:28,060 --> 00:12:31,839
guarantees in shared libraries with

00:12:30,250 --> 00:12:33,730
bolter we have this guarantee because

00:12:31,839 --> 00:12:36,520
we're linking by content we're not

00:12:33,730 --> 00:12:39,100
linking by name so when you link a Lib C

00:12:36,520 --> 00:12:41,350
it is linked by its hash and that hash

00:12:39,100 --> 00:12:42,970
is the content as well as put into the

00:12:41,350 --> 00:12:44,980
binary so if you have two different

00:12:42,970 --> 00:12:46,300
applications using incompatible

00:12:44,980 --> 00:12:48,310
libraries they're just going to be not

00:12:46,300 --> 00:12:51,430
deduplicated they're both gonna have the

00:12:48,310 --> 00:12:52,810
original C in there but with the the

00:12:51,430 --> 00:12:55,330
reason that they're actually actually

00:12:52,810 --> 00:12:57,790
expect and we either going to store just

00:12:55,330 --> 00:13:00,390
one of the Lipsey's or both of them and

00:12:57,790 --> 00:13:02,709
we can also later decide to change that

00:13:00,390 --> 00:13:03,730
automatically of course based on based

00:13:02,709 --> 00:13:08,079
on the hash of the content

00:13:03,730 --> 00:13:09,089
oh yeah demo time okay let's hope this

00:13:08,079 --> 00:13:15,459
works

00:13:09,089 --> 00:13:24,160
give me give me all your prayers sorry

00:13:15,459 --> 00:13:26,079
come again you wish I got to say with

00:13:24,160 --> 00:13:29,889
that actually we have the this not in

00:13:26,079 --> 00:13:33,009
production we have a work at super scale

00:13:29,889 --> 00:13:35,109
networks as a CTO and we have there's

00:13:33,009 --> 00:13:36,669
8,000 devices out there with a complete

00:13:35,109 --> 00:13:39,609
rest stack but we didn't they're

00:13:36,669 --> 00:13:41,230
deploying this yet so since I just got

00:13:39,609 --> 00:13:45,339
it working last week

00:13:41,230 --> 00:13:47,139
we're not that crazy I hope okay cool so

00:13:45,339 --> 00:13:49,629
I prepared a little test here this is

00:13:47,139 --> 00:13:51,699
this is just to test files really this

00:13:49,629 --> 00:13:53,949
is hello world in C now this looks very

00:13:51,699 --> 00:13:56,739
simple and to some of you know C

00:13:53,949 --> 00:13:58,569
probably all of you and this just hello

00:13:56,739 --> 00:14:01,179
world but in terms of what it links into

00:13:58,569 --> 00:14:03,459
Lib C is actually pretty crazy you're

00:14:01,179 --> 00:14:05,230
gonna see that in a second and Mona's

00:14:03,459 --> 00:14:07,749
not library and we've got hello to see

00:14:05,230 --> 00:14:10,329
which is which is almost the same thing

00:14:07,749 --> 00:14:12,069
it's just going to print the local you

00:14:10,329 --> 00:14:16,689
name which is the name of the operating

00:14:12,069 --> 00:14:18,129
system whirring now these two look very

00:14:16,689 --> 00:14:19,720
similar and you would expect that the

00:14:18,129 --> 00:14:23,769
binaries are very similar but if we link

00:14:19,720 --> 00:14:28,869
that with new LG I I'm gonna risk it and

00:14:23,769 --> 00:14:32,049
delete the binaries lucky me

00:14:28,869 --> 00:14:33,819
if we risk it and I mean if we link it

00:14:32,049 --> 00:14:36,220
with can you LD this is this is hello 1

00:14:33,819 --> 00:14:38,289
this is hello to the LOD binary link

00:14:36,220 --> 00:14:39,850
with can ult and that's a trick here

00:14:38,289 --> 00:14:44,289
could show you to make file but it's not

00:14:39,850 --> 00:14:45,730
that interesting and so if you could

00:14:44,289 --> 00:14:47,980
expect these binaries to be very similar

00:14:45,730 --> 00:14:50,109
and if we looked at it from a

00:14:47,980 --> 00:14:51,489
considerable storage perspective they're

00:14:50,109 --> 00:14:54,639
not gonna be so I'm gonna use our cone

00:14:51,489 --> 00:14:55,929
here and I'm gonna store actually need

00:14:54,639 --> 00:15:00,899
to make sure that my test thing is

00:14:55,929 --> 00:15:02,769
removed or actually it just um in a sec

00:15:00,899 --> 00:15:05,709
I'll just use a different different

00:15:02,769 --> 00:15:07,929
storage oops

00:15:05,709 --> 00:15:09,959
you seem that right why didn't you tell

00:15:07,929 --> 00:15:09,959
me

00:15:11,290 --> 00:15:19,600
- life did help me I'm just gonna store

00:15:17,170 --> 00:15:23,110
these both into a contour decibel

00:15:19,600 --> 00:15:25,060
storage and this one was seventeen

00:15:23,110 --> 00:15:26,889
kilobytes because it includes the Dipsy

00:15:25,060 --> 00:15:28,149
boosted static linking and I'm going to

00:15:26,889 --> 00:15:29,920
store the other one and it's gonna try

00:15:28,149 --> 00:15:33,370
to deduplicate it based on something

00:15:29,920 --> 00:15:35,709
that our sync uses as well which is the

00:15:33,370 --> 00:15:37,089
bop algorithm sbo piece is from our so

00:15:35,709 --> 00:15:39,069
and it basically tries to go through a

00:15:37,089 --> 00:15:40,899
binary and try to find cutting points

00:15:39,069 --> 00:15:43,740
that it can use based on its content

00:15:40,899 --> 00:15:45,910
it's basically also the CI sink uses or

00:15:43,740 --> 00:15:47,949
any contra does of a storage really

00:15:45,910 --> 00:15:50,589
they're all very similar so we've seen

00:15:47,949 --> 00:15:53,350
that what we see here is that we we've

00:15:50,589 --> 00:15:54,970
stored 17 kilo bytes on actually let me

00:15:53,350 --> 00:15:58,089
do this in the other screen ok reach my

00:15:54,970 --> 00:15:59,230
mouse over there we stored this is so

00:15:58,089 --> 00:16:02,019
much intimate delight I'm not gonna be

00:15:59,230 --> 00:16:03,880
able to do it we stored 17 kilobytes

00:16:02,019 --> 00:16:05,319
with one binary and the other binary we

00:16:03,880 --> 00:16:07,240
still have to store 15 kilobytes so

00:16:05,319 --> 00:16:08,709
we'll only be able to share a minor part

00:16:07,240 --> 00:16:10,060
of it between those binaries this is

00:16:08,709 --> 00:16:12,550
because all the addresses have changed

00:16:10,060 --> 00:16:14,920
now if you do this with bolter if you

00:16:12,550 --> 00:16:16,870
just build a binary link with bolter if

00:16:14,920 --> 00:16:19,420
you just do this with just gonna make up

00:16:16,870 --> 00:16:24,069
around them in here I'm gonna store

00:16:19,420 --> 00:16:25,360
hello one and also 18.4 for kilobytes

00:16:24,069 --> 00:16:27,459
you notice that this is slightly bigger

00:16:25,360 --> 00:16:28,810
than the you know LD of by library

00:16:27,459 --> 00:16:31,269
there's a reason for that which I'm

00:16:28,810 --> 00:16:34,449
gonna explain a sec having a store or

00:16:31,269 --> 00:16:35,769
hello to you're going to see that this

00:16:34,449 --> 00:16:39,100
is significantly better

00:16:35,769 --> 00:16:41,260
we're only storing five kilobytes these

00:16:39,100 --> 00:16:43,120
are these are basically this is what's

00:16:41,260 --> 00:16:45,360
going to enable you to do partial system

00:16:43,120 --> 00:16:47,440
updates and it completely safe Y by

00:16:45,360 --> 00:16:48,519
deduplicating most of your application

00:16:47,440 --> 00:16:51,100
code that is shared between two

00:16:48,519 --> 00:16:53,170
different binaries now the reason that

00:16:51,100 --> 00:16:56,649
the Bolton link fire is slightly bigger

00:16:53,170 --> 00:16:58,180
is because we first of all I just got

00:16:56,649 --> 00:17:00,100
the linker working last week so there's

00:16:58,180 --> 00:17:02,170
a lot of optimization missing but

00:17:00,100 --> 00:17:05,260
there's also an index into the content

00:17:02,170 --> 00:17:06,760
inside which are can uses for for

00:17:05,260 --> 00:17:08,559
cutting points like it's going to know

00:17:06,760 --> 00:17:10,150
exactly which contents in there so I can

00:17:08,559 --> 00:17:12,640
compare it to any other thing it has

00:17:10,150 --> 00:17:13,659
already in the store and this is

00:17:12,640 --> 00:17:15,549
something you would do in an embedded

00:17:13,659 --> 00:17:17,230
device for example from the outside you

00:17:15,549 --> 00:17:19,390
would say push this device push this

00:17:17,230 --> 00:17:20,790
image on there with that's really not

00:17:19,390 --> 00:17:22,380
cool okay

00:17:20,790 --> 00:17:25,740
and really glad this didn't show them in

00:17:22,380 --> 00:17:28,199
yellow screen you could put you could

00:17:25,740 --> 00:17:29,190
push content in there on an embedded

00:17:28,199 --> 00:17:33,600
device and it would automatically

00:17:29,190 --> 00:17:34,620
deduplicate it cool so that that's all

00:17:33,600 --> 00:17:37,400
the demo I'm gonna show you're not going

00:17:34,620 --> 00:17:43,020
to deploy on a customer device forget it

00:17:37,400 --> 00:17:44,810
thanks for tempting me so let me just

00:17:43,020 --> 00:17:49,590
get back to my nose

00:17:44,810 --> 00:17:51,330
okay so let me just do this first right

00:17:49,590 --> 00:17:53,430
so I just want to lose a quick work and

00:17:51,330 --> 00:17:56,610
rest as I said before because it's tough

00:17:53,430 --> 00:17:59,030
time I ran super scale which is a

00:17:56,610 --> 00:18:01,890
company that recently got got sold and

00:17:59,030 --> 00:18:04,110
we did rust there we have an embedded

00:18:01,890 --> 00:18:05,550
stack for for almost eight thousand it

00:18:04,110 --> 00:18:08,160
could be more than a thousand devices

00:18:05,550 --> 00:18:09,270
now out there that runs on there I'm

00:18:08,160 --> 00:18:10,740
really in love with rust

00:18:09,270 --> 00:18:12,570
especially because it's the first

00:18:10,740 --> 00:18:14,970
language really that that the first

00:18:12,570 --> 00:18:17,070
major popular language I could say offer

00:18:14,970 --> 00:18:19,620
you C++ that allowed us to do something

00:18:17,070 --> 00:18:21,840
like this because it's portable to micro

00:18:19,620 --> 00:18:24,270
or really really small and embedded in

00:18:21,840 --> 00:18:25,940
constraint systems and I really hope the

00:18:24,270 --> 00:18:28,380
community doesn't lose track of that and

00:18:25,940 --> 00:18:30,840
really encourage people to keep thinking

00:18:28,380 --> 00:18:34,530
about portability in in constrained

00:18:30,840 --> 00:18:36,690
environments now where I'm going with

00:18:34,530 --> 00:18:38,460
core Hall is I'm trying to change the

00:18:36,690 --> 00:18:40,070
Internet itself the Internet of Things

00:18:38,460 --> 00:18:42,510
itself from an engineering perspective

00:18:40,070 --> 00:18:44,820
we need much better tools to deal with

00:18:42,510 --> 00:18:46,200
things like end of life clouds service

00:18:44,820 --> 00:18:48,450
disruption monopolize data

00:18:46,200 --> 00:18:49,800
infrastructure and coronal is larger

00:18:48,450 --> 00:18:52,020
project I'm trying to set up so if

00:18:49,800 --> 00:18:53,760
you're if you're interested in Internet

00:18:52,020 --> 00:18:55,530
of Things infrastructure specifically

00:18:53,760 --> 00:18:57,420
decentralized Internet infrastructure

00:18:55,530 --> 00:19:00,240
that doesn't need a cloud I'm gonna talk

00:18:57,420 --> 00:19:02,640
about that in another talk give a shout

00:19:00,240 --> 00:19:04,350
out to me after the talk or stalk me and

00:19:02,640 --> 00:19:06,420
github or stalk any of my project

00:19:04,350 --> 00:19:14,010
members on github and help me fix IOT

00:19:06,420 --> 00:19:14,640
thank you I guess I guess we have time

00:19:14,010 --> 00:19:23,910
to take questions

00:19:14,640 --> 00:19:26,510
that's all so what is your relationship

00:19:23,910 --> 00:19:30,690
with iota

00:19:26,510 --> 00:19:32,130
that's a nasty question because because

00:19:30,690 --> 00:19:33,179
you saw the Krypton certifies Network

00:19:32,130 --> 00:19:36,530
and I'm not going to talk about that

00:19:33,179 --> 00:19:36,530
today that's that's still in secret

00:19:44,000 --> 00:19:47,450
other questions

00:19:51,820 --> 00:19:58,239
what if you are going to opted one of

00:19:53,979 --> 00:20:01,299
your tools and that fails on the device

00:19:58,239 --> 00:20:04,269
turn or tools the the as you've seen in

00:20:01,299 --> 00:20:06,190
my demo the binary executes on itself it

00:20:04,269 --> 00:20:09,179
all of the all of the loader elements

00:20:06,190 --> 00:20:11,139
are inside the binary just like before

00:20:09,179 --> 00:20:13,359
you also don't need a specialized

00:20:11,139 --> 00:20:16,179
bootloader actually because everything's

00:20:13,359 --> 00:20:18,220
inside the binary that also allows you

00:20:16,179 --> 00:20:20,229
to do something that I find really

00:20:18,220 --> 00:20:22,289
important which is reproducibility so if

00:20:20,229 --> 00:20:24,729
you if you put this on one device and

00:20:22,289 --> 00:20:25,960
you and it works you know test device

00:20:24,729 --> 00:20:27,279
you can be sure that it also works on

00:20:25,960 --> 00:20:31,599
another device because the images are

00:20:27,279 --> 00:20:33,720
going to be the same great question

00:20:31,599 --> 00:20:33,720
though

00:20:38,530 --> 00:20:45,970
I also last slide point for you set a

00:20:43,289 --> 00:20:49,210
direct device to device interaction

00:20:45,970 --> 00:20:55,390
isn't that in a high risk for an active

00:20:49,210 --> 00:20:57,720
attack that that's going a bit further

00:20:55,390 --> 00:21:00,610
than than what I would have set here

00:20:57,720 --> 00:21:02,020
this is this is not well thought out I

00:21:00,610 --> 00:21:04,179
got to say so I don't have a direct

00:21:02,020 --> 00:21:07,539
answer because I'm not sure where you're

00:21:04,179 --> 00:21:08,919
going with this especially because this

00:21:07,539 --> 00:21:10,809
is in the direction of the decentralized

00:21:08,919 --> 00:21:13,840
network that I haven't talked about yet

00:21:10,809 --> 00:21:16,000
but you right it has a risk of fraud and

00:21:13,840 --> 00:21:19,990
this is why there's a crypto element to

00:21:16,000 --> 00:21:20,950
it that did tries to prevent fraud but

00:21:19,990 --> 00:21:22,110
that's not what we're talking about

00:21:20,950 --> 00:21:26,590
today

00:21:22,110 --> 00:21:28,480
Thanks right question but if I

00:21:26,590 --> 00:21:32,080
understood correctly Boulder does

00:21:28,480 --> 00:21:35,280
deterministic linking yes how do you

00:21:32,080 --> 00:21:38,400
solve things like static initialization

00:21:35,280 --> 00:21:41,950
order and things that are not really

00:21:38,400 --> 00:21:43,960
deterministic and see and the

00:21:41,950 --> 00:21:45,940
initialization order is is deterministic

00:21:43,960 --> 00:21:47,440
in a sense of if you have the same input

00:21:45,940 --> 00:21:49,600
you're always going to get the same

00:21:47,440 --> 00:21:51,070
result it's not hidden mystic in a sense

00:21:49,600 --> 00:21:51,490
of you feeling something else that's

00:21:51,070 --> 00:21:52,809
correct

00:21:51,490 --> 00:21:54,429
yeah if you link something else in the

00:21:52,809 --> 00:21:56,830
the orders gonna change that's correct

00:21:54,429 --> 00:21:59,169
but it's not gonna change in the sense

00:21:56,830 --> 00:22:01,210
of that if if you have the same

00:21:59,169 --> 00:22:02,559
application no matter what underlying

00:22:01,210 --> 00:22:04,539
code you share it's still going to be

00:22:02,559 --> 00:22:08,110
the same initialization order because

00:22:04,539 --> 00:22:09,789
that's not part of the runtime at

00:22:08,110 --> 00:22:11,890
runtime it's always gonna be the same in

00:22:09,789 --> 00:22:13,990
the TLS section it's although it's going

00:22:11,890 --> 00:22:16,630
to be the same in your application code

00:22:13,990 --> 00:22:19,090
it's not going to change because you

00:22:16,630 --> 00:22:20,740
don't link other code at runtime does

00:22:19,090 --> 00:22:22,929
that some explanation make sense maybe

00:22:20,740 --> 00:22:24,010
we can talk about it yeah let's talk a

00:22:22,929 --> 00:22:25,630
bit later because it's pretty deep

00:22:24,010 --> 00:22:28,740
technical but thank you for the question

00:22:25,630 --> 00:22:28,740
it definitely talked to me about that

00:22:35,779 --> 00:22:43,129
I'm not an expert but there's something

00:22:38,879 --> 00:22:47,460
called a is a letter I think it's to

00:22:43,129 --> 00:22:51,210
replace moose pointers with random

00:22:47,460 --> 00:22:52,649
addresses so that oh I cannot replace

00:22:51,210 --> 00:22:56,309
questions

00:22:52,649 --> 00:22:58,529
wouldn't you linker go against it

00:22:56,309 --> 00:23:00,799
absolutely a great question this is this

00:22:58,529 --> 00:23:03,379
is address page one address space

00:23:00,799 --> 00:23:05,279
randomization this is to prevent

00:23:03,379 --> 00:23:06,870
break-ins when you're already found a

00:23:05,279 --> 00:23:09,299
buffer overflow and application that you

00:23:06,870 --> 00:23:11,309
can't just run jump to a known address

00:23:09,299 --> 00:23:14,429
where you can execute code and this is

00:23:11,309 --> 00:23:15,960
enabled by default in Linux and the the

00:23:14,429 --> 00:23:18,750
demo that you just saw those are with

00:23:15,960 --> 00:23:21,600
address space randomization the way we

00:23:18,750 --> 00:23:25,980
do it is the the global address space

00:23:21,600 --> 00:23:27,870
you see it's shifted by the load base so

00:23:25,980 --> 00:23:29,279
it run at what happens at run time is

00:23:27,870 --> 00:23:31,320
the Linux loads this at a specific

00:23:29,279 --> 00:23:33,720
address that it just randomly thinks up

00:23:31,320 --> 00:23:36,600
and we just lay out the entire address

00:23:33,720 --> 00:23:39,600
space after that relative to that base

00:23:36,600 --> 00:23:41,309
address this is how it works it's it's a

00:23:39,600 --> 00:23:42,929
bit fancy it could show you the internal

00:23:41,309 --> 00:23:46,169
details but it does not conflict with

00:23:42,929 --> 00:23:49,340
with random with randomization okay

00:23:46,169 --> 00:23:49,340
thank you great question

00:23:51,230 --> 00:23:56,190
all right I think that's it thank you

00:23:55,379 --> 00:23:58,080
everyone

00:23:56,190 --> 00:24:00,570
we'll have a five minutes break give

00:23:58,080 --> 00:24:06,210
another round of applause to of it thank

00:24:00,570 --> 00:24:09,110
you and we'll be back with our next talk

00:24:06,210 --> 00:24:09,110
then Thanks

00:32:31,470 --> 00:32:38,440
all right everyone it's part four it's

00:32:36,070 --> 00:32:43,780
time for the second part of our meetup

00:32:38,440 --> 00:32:46,080
it's Winston talks about r-spec making a

00:32:43,780 --> 00:32:49,720
bdd test framework and stale rust and

00:32:46,080 --> 00:32:52,710
I'm looking forward to it and I'll give

00:32:49,720 --> 00:32:52,710
over to Vincent

00:38:15,619 --> 00:38:24,670
oh yeah and then you can further nest

00:38:22,039 --> 00:38:27,949
those and have arbitrarily deep nested

00:38:24,670 --> 00:38:30,259
tests there and the interesting part is

00:38:27,949 --> 00:38:32,119
that these ones share the same set up

00:38:30,259 --> 00:38:36,949
right you don't you don't repeat

00:38:32,119 --> 00:38:39,349
yourself over and over again and they

00:38:36,949 --> 00:38:42,199
can also like fork if you are right so

00:38:39,349 --> 00:38:44,170
they could diverge here and here as well

00:38:42,199 --> 00:38:48,709
but still share the same origin up here

00:38:44,170 --> 00:38:50,749
and if you express this in some kind of

00:38:48,709 --> 00:38:53,959
hierarchy then this stuff on the right

00:38:50,749 --> 00:38:56,479
would look like this diagram this tree

00:38:53,959 --> 00:38:58,400
diagram on the left here but the given

00:38:56,479 --> 00:39:08,900
and these two when clauses being those

00:38:58,400 --> 00:39:11,209
two and this subtree and if you look in

00:39:08,900 --> 00:39:15,829
the rust ecosystem for BDD frameworks

00:39:11,209 --> 00:39:17,929
then they're basically three that I

00:39:15,829 --> 00:39:22,969
found that are usable another iPhone

00:39:17,929 --> 00:39:26,179
usual there's shiny which has a very

00:39:22,969 --> 00:39:28,819
nice syntax by using by basically being

00:39:26,179 --> 00:39:33,049
a compiler flag plug-in and using macros

00:39:28,819 --> 00:39:36,709
to be able to have a very nice DSL to

00:39:33,049 --> 00:39:39,170
define those those cases the big

00:39:36,709 --> 00:39:42,910
downside of shiny is that it's single

00:39:39,170 --> 00:39:45,799
level so you have you can kind of define

00:39:42,910 --> 00:39:49,969
multiple bags but they're still bags

00:39:45,799 --> 00:39:53,779
it's not a hierarchy for any kind and

00:39:49,969 --> 00:39:56,719
you can define those before each before

00:39:53,779 --> 00:39:59,150
each snippets which then basically like

00:39:56,719 --> 00:40:01,759
what Johnny does is it compiles down and

00:39:59,150 --> 00:40:03,949
it's basically some kind of templating

00:40:01,759 --> 00:40:06,289
language if you will so what it does is

00:40:03,949 --> 00:40:09,920
it's instantly it's that instantly its

00:40:06,289 --> 00:40:11,359
initial individual test functions which

00:40:09,920 --> 00:40:15,890
then are recognized for the test Runner

00:40:11,359 --> 00:40:18,949
and rest natively and simply like copy

00:40:15,890 --> 00:40:22,239
and pastes those before each blocks into

00:40:18,949 --> 00:40:24,170
those test functions so you get like

00:40:22,239 --> 00:40:25,970
you're repeating yourself

00:40:24,170 --> 00:40:28,609
but like the compiled

00:40:25,970 --> 00:40:31,160
repeating for yourself you don't have to

00:40:28,609 --> 00:40:32,140
do it manually but still is repeated all

00:40:31,160 --> 00:40:34,550
over again

00:40:32,140 --> 00:40:39,200
and also obviously also has to be

00:40:34,550 --> 00:40:42,440
executed all over again next one this

00:40:39,200 --> 00:40:46,640
famous which is kind of similar also in

00:40:42,440 --> 00:40:49,790
syntax is bit more sophisticated it also

00:40:46,640 --> 00:40:52,580
has these after each companions which

00:40:49,790 --> 00:40:54,800
are like behave similar to before each

00:40:52,580 --> 00:40:55,880
just that are executed afterwards so for

00:40:54,800 --> 00:40:58,760
example what you could do is they could

00:40:55,880 --> 00:41:00,200
open a database connection and before eh

00:40:58,760 --> 00:41:02,750
and then close it in the after age in

00:41:00,200 --> 00:41:06,260
order to make sure it's you're not

00:41:02,750 --> 00:41:11,119
leaking anything and then you can have

00:41:06,260 --> 00:41:12,859
arbitrarily deeply nested contexts the

00:41:11,119 --> 00:41:17,630
big problem here is that again this is

00:41:12,859 --> 00:41:20,780
templating so you cannot like define the

00:41:17,630 --> 00:41:23,690
behavior up here and then further use

00:41:20,780 --> 00:41:25,750
whatever is like whatever you reached at

00:41:23,690 --> 00:41:29,150
this point of the current state and

00:41:25,750 --> 00:41:31,820
further specify behavior like add

00:41:29,150 --> 00:41:34,099
something to a set then further at other

00:41:31,820 --> 00:41:38,060
options other elements to the set and

00:41:34,099 --> 00:41:40,190
stuff like this is the only thing you

00:41:38,060 --> 00:41:42,470
get is adding some structure to your

00:41:40,190 --> 00:41:45,619
tests but it's just in the structure not

00:41:42,470 --> 00:41:49,339
in the behavior so we're not quite there

00:41:45,619 --> 00:41:52,700
yet also because it's unstable yeah I

00:41:49,339 --> 00:41:56,599
mean the tests are the last part of my

00:41:52,700 --> 00:41:58,970
program I want to not compile so I

00:41:56,599 --> 00:42:00,950
always want my tests to be stable and to

00:41:58,970 --> 00:42:04,660
be to compile because like I don't have

00:42:00,950 --> 00:42:09,260
tests for my not non compiling tests

00:42:04,660 --> 00:42:11,420
tests all the way down and they are

00:42:09,260 --> 00:42:13,270
breaking regularly shiny actually I

00:42:11,420 --> 00:42:15,940
couldn't get to compile today so

00:42:13,270 --> 00:42:18,619
stainless does compile shiny doesn't

00:42:15,940 --> 00:42:23,390
because the internal ast of the rest

00:42:18,619 --> 00:42:26,690
compile has changed and again you're

00:42:23,390 --> 00:42:28,010
limited to kind of shallow context so at

00:42:26,690 --> 00:42:32,089
least at least from the point of

00:42:28,010 --> 00:42:34,400
behavior and it's not actually code

00:42:32,089 --> 00:42:36,830
sharing because your copy and pasting

00:42:34,400 --> 00:42:38,180
and it's also again it's executed over

00:42:36,830 --> 00:42:41,900
and over again instead of

00:42:38,180 --> 00:42:45,589
simply a certain state at some

00:42:41,900 --> 00:42:47,210
point and it has kind of an incomplete

00:42:45,589 --> 00:42:49,069
feature set if you compare to what this

00:42:47,210 --> 00:42:52,930
gherkin language should actually allow

00:42:49,069 --> 00:42:57,230
you to do and also in the expressiveness

00:42:52,930 --> 00:43:02,660
so this is how this would look in r-spec

00:42:57,230 --> 00:43:07,609
it's a bit more noisy because we don't

00:43:02,660 --> 00:43:09,079
have the the benefit of a DSL because we

00:43:07,609 --> 00:43:10,700
want to be stable at some point I would

00:43:09,079 --> 00:43:12,950
like to add a DSL but it's right now

00:43:10,700 --> 00:43:15,049
likely the stable part at least has to

00:43:12,950 --> 00:43:17,779
be like this so instead of inferring

00:43:15,049 --> 00:43:21,500
some some implicit context we actually

00:43:17,779 --> 00:43:24,440
have to always like pass the context to

00:43:21,500 --> 00:43:24,920
the further down contexts to then

00:43:24,440 --> 00:43:29,299
further

00:43:24,920 --> 00:43:31,579
append them so we add an it Clause one

00:43:29,299 --> 00:43:34,910
after and after block to the current

00:43:31,579 --> 00:43:37,039
context and then in every further nested

00:43:34,910 --> 00:43:41,630
context the context actually is the sub

00:43:37,039 --> 00:43:45,859
context that's initiated here and one

00:43:41,630 --> 00:43:48,410
interesting part is in the top like this

00:43:45,859 --> 00:43:50,690
is a convenience runner you can further

00:43:48,410 --> 00:43:54,589
specify how you want to run this stuff

00:43:50,690 --> 00:43:56,450
this is just for convenience and you

00:43:54,589 --> 00:44:01,369
pass an environment to it and that's the

00:43:56,450 --> 00:44:03,260
fixture and so for example if you were I

00:44:01,369 --> 00:44:05,089
don't testing whether a number actually

00:44:03,260 --> 00:44:08,690
behaves like a number should behavior

00:44:05,089 --> 00:44:10,520
just like pass 42 or you could have a

00:44:08,690 --> 00:44:12,619
struct which then also contains your

00:44:10,520 --> 00:44:15,109
stuff and in some cases like if you want

00:44:12,619 --> 00:44:19,549
to have some additional state for

00:44:15,109 --> 00:44:23,020
example if you wanted to test if the the

00:44:19,549 --> 00:44:25,760
state after a certain action actually

00:44:23,020 --> 00:44:27,410
had a certain effect then you have to

00:44:25,760 --> 00:44:30,980
keep both of these in this environment

00:44:27,410 --> 00:44:34,970
so only stuff within the environment is

00:44:30,980 --> 00:44:36,710
actually accessible in here which is it

00:44:34,970 --> 00:44:39,799
is a feature but it's kind of tedious on

00:44:36,710 --> 00:44:42,170
some points so and you only get access

00:44:39,799 --> 00:44:44,539
to the environment in certain places so

00:44:42,170 --> 00:44:46,099
you get access in those beforeeach in

00:44:44,539 --> 00:44:48,289
which case the environment that's being

00:44:46,099 --> 00:44:51,950
passed into the closure is moodily

00:44:48,289 --> 00:44:54,650
burrowed same for the after and

00:44:51,950 --> 00:44:59,119
in signed it you get the immutable

00:44:54,650 --> 00:45:01,609
environment within these like within

00:44:59,119 --> 00:45:03,680
here you actually don't have any access

00:45:01,609 --> 00:45:06,290
to it and it this completely issue

00:45:03,680 --> 00:45:08,510
ensures that you're not like messing

00:45:06,290 --> 00:45:11,920
with the data at places and times when

00:45:08,510 --> 00:45:11,920
you shouldn't be messing with the data

00:45:12,430 --> 00:45:18,530
because one of the goals of us of this

00:45:15,079 --> 00:45:20,960
project is to not only be efficient in

00:45:18,530 --> 00:45:23,599
execution but also safe you shouldn't

00:45:20,960 --> 00:45:26,270
have to worry about worry about how your

00:45:23,599 --> 00:45:29,060
code is executed you should only worry

00:45:26,270 --> 00:45:31,640
about the stuff like within these blocks

00:45:29,060 --> 00:45:36,950
not like what's going on behind the

00:45:31,640 --> 00:45:39,500
scenes so we are stable and principle we

00:45:36,950 --> 00:45:43,190
have arbitrarily deeply nested tests and

00:45:39,500 --> 00:45:48,020
contexts it is fully paralyzed in its

00:45:43,190 --> 00:45:49,250
execution so thanks to Ryan but at the

00:45:48,020 --> 00:45:51,140
same time it completely guarantees

00:45:49,250 --> 00:45:53,660
execution safety so there's no way that

00:45:51,140 --> 00:45:54,710
one of those contexts could infant

00:45:53,660 --> 00:45:56,869
interfere with any of the other

00:45:54,710 --> 00:46:00,140
currently or maybe in future whatever

00:45:56,869 --> 00:46:03,829
past running contexts while still

00:46:00,140 --> 00:46:08,480
completely sharing any previously ran

00:46:03,829 --> 00:46:13,040
context at least like parent context and

00:46:08,480 --> 00:46:15,109
it's rich in features like it is it has

00:46:13,040 --> 00:46:17,089
has more of the more features than any

00:46:15,109 --> 00:46:20,420
of the other two while still being

00:46:17,089 --> 00:46:22,700
extensible and this is the current state

00:46:20,420 --> 00:46:24,170
is just like the beginning of what I

00:46:22,700 --> 00:46:29,390
would like to to make out of this

00:46:24,170 --> 00:46:30,560
framework it had been written the the

00:46:29,390 --> 00:46:35,050
first version had been written by by

00:46:30,560 --> 00:46:37,310
Thomas and then in a shamefully large PR

00:46:35,050 --> 00:46:41,770
which had like two hundred twenty seven

00:46:37,310 --> 00:46:44,720
comments and usually reviewed and I

00:46:41,770 --> 00:46:46,369
basically changed all the things like

00:46:44,720 --> 00:46:48,500
the name is to say the names the same

00:46:46,369 --> 00:46:50,359
and kind of the API state kind of the

00:46:48,500 --> 00:46:52,099
same but they the all underpinning is

00:46:50,359 --> 00:46:57,460
pretty much completely ripped out and

00:46:52,099 --> 00:47:02,060
replaced so but now it's a shared effort

00:46:57,460 --> 00:47:06,430
we support three different accent

00:47:02,060 --> 00:47:08,870
language styles for different variants

00:47:06,430 --> 00:47:10,880
my favorite is the given one then but

00:47:08,870 --> 00:47:12,470
you also can use any of these to other

00:47:10,880 --> 00:47:15,410
and you actually you could completely

00:47:12,470 --> 00:47:18,770
change them they're just aliases to like

00:47:15,410 --> 00:47:23,600
those right one to right bones or I use

00:47:18,770 --> 00:47:25,430
for the first ones and this would then

00:47:23,600 --> 00:47:28,760
either look like this in variant a where

00:47:25,430 --> 00:47:31,700
you have food context an example to to

00:47:28,760 --> 00:47:35,270
open those specific contexts describe

00:47:31,700 --> 00:47:36,680
specified it or given when done the

00:47:35,270 --> 00:47:39,800
execution of those is completely the

00:47:36,680 --> 00:47:42,650
same and then you have before and after

00:47:39,800 --> 00:47:44,360
blocks were before it's a shorthand for

00:47:42,650 --> 00:47:47,000
before all you know after Street Horton

00:47:44,360 --> 00:47:51,770
for after all and there's also after

00:47:47,000 --> 00:47:54,770
agent before each the all variants are

00:47:51,770 --> 00:47:57,800
executed before any of the sub contexts

00:47:54,770 --> 00:48:00,980
or sub tests are executed the each ones

00:47:57,800 --> 00:48:07,510
are executed before any of those

00:48:00,980 --> 00:48:11,260
individually unless you're actually

00:48:07,510 --> 00:48:14,510
using some some shared state in an arc

00:48:11,260 --> 00:48:16,640
these two don't differ from the effect

00:48:14,510 --> 00:48:18,140
but if you have some shared database

00:48:16,640 --> 00:48:20,390
where you want to for whatever reason

00:48:18,140 --> 00:48:22,520
have one single shared one that's that's

00:48:20,390 --> 00:48:25,550
be hidden behind UNIX then these would

00:48:22,520 --> 00:48:30,140
actually differ but mostly those won't

00:48:25,550 --> 00:48:32,210
suffice and again what what we do

00:48:30,140 --> 00:48:37,300
basically is by executing by executing

00:48:32,210 --> 00:48:39,800
like these these pieces of code you then

00:48:37,300 --> 00:48:42,950
generate a data structure that looks

00:48:39,800 --> 00:48:45,110
like this or you have the suit at the

00:48:42,950 --> 00:48:46,880
suite at the top and then those contexts

00:48:45,110 --> 00:48:50,240
and further examples on the at the

00:48:46,880 --> 00:48:53,900
bottom and then we have a test runner

00:48:50,240 --> 00:48:55,970
that executed this so this is the code

00:48:53,900 --> 00:49:03,230
that we generate structure it looks like

00:48:55,970 --> 00:49:06,380
this so now to the internals so every

00:49:03,230 --> 00:49:07,870
one of these nodes in the tree has a

00:49:06,380 --> 00:49:10,910
header attached to it which then

00:49:07,870 --> 00:49:15,940
contains the name that we gave them in a

00:49:10,910 --> 00:49:18,080
string and also the label and the label

00:49:15,940 --> 00:49:19,130
depends on the on the type of your

00:49:18,080 --> 00:49:20,869
structure

00:49:19,130 --> 00:49:23,749
and as you can see this is the only

00:49:20,869 --> 00:49:25,009
place where it actually matters which of

00:49:23,749 --> 00:49:28,789
these cells you choose they're

00:49:25,009 --> 00:49:31,210
completely interchangeable the suite

00:49:28,789 --> 00:49:33,559
then also it sort of contains a header

00:49:31,210 --> 00:49:35,690
the environment that you pass to it

00:49:33,559 --> 00:49:37,549
which it's then hiding and only like

00:49:35,690 --> 00:49:43,190
revealing to you in certain places of

00:49:37,549 --> 00:49:45,619
the execution and the route context the

00:49:43,190 --> 00:49:48,079
context then has an optional header

00:49:45,619 --> 00:49:50,900
because the route had the route context

00:49:48,079 --> 00:49:52,880
is enormous and there's also an option

00:49:50,900 --> 00:49:56,299
for having anonymous context which allow

00:49:52,880 --> 00:49:58,640
you to to further specify before and

00:49:56,299 --> 00:50:02,869
after blocks without polluting the

00:49:58,640 --> 00:50:06,559
output and then you store each of these

00:50:02,869 --> 00:50:09,470
execution blocks and also further sub

00:50:06,559 --> 00:50:13,279
structures which can be a block which is

00:50:09,470 --> 00:50:15,380
either a context on example in case of

00:50:13,279 --> 00:50:17,749
an example is again the header and then

00:50:15,380 --> 00:50:23,900
also the function that actually does the

00:50:17,749 --> 00:50:25,880
evaluation of your test and once we have

00:50:23,900 --> 00:50:29,210
this structure it is completely

00:50:25,880 --> 00:50:31,489
immutable and during the execution of

00:50:29,210 --> 00:50:35,390
the test is completely immutable over

00:50:31,489 --> 00:50:37,759
the over the actual code structure or

00:50:35,390 --> 00:50:41,509
test structure and what it basically

00:50:37,759 --> 00:50:45,650
does is it takes those takes this tree

00:50:41,509 --> 00:50:49,039
as an input and returns a different tree

00:50:45,650 --> 00:50:50,749
and it's a tree of reports and those

00:50:49,039 --> 00:50:56,269
reports have the same structure as you

00:50:50,749 --> 00:51:01,819
saw before basically you go from here to

00:50:56,269 --> 00:51:05,599
here and like every time you enter one

00:51:01,819 --> 00:51:06,799
of these you get a modification to do

00:51:05,599 --> 00:51:09,799
your observers that you just entered

00:51:06,799 --> 00:51:11,509
some scope or left some scope if you

00:51:09,799 --> 00:51:14,269
enter it you just get the header if you

00:51:11,509 --> 00:51:17,029
exit it you get the header plus the

00:51:14,269 --> 00:51:21,469
report so that you can then like

00:51:17,029 --> 00:51:25,130
implement loggers for example so this is

00:51:21,469 --> 00:51:27,170
how you create a runner you add your

00:51:25,130 --> 00:51:30,769
your observers which in this case just

00:51:27,170 --> 00:51:32,479
as the standard logger to the runner in

00:51:30,769 --> 00:51:33,050
a configuration which currently just

00:51:32,479 --> 00:51:38,540
contains

00:51:33,050 --> 00:51:40,040
whether the execution is parallel and

00:51:38,540 --> 00:51:44,720
something else which just look my mind

00:51:40,040 --> 00:51:46,520
was not so important and then also

00:51:44,720 --> 00:51:49,190
because this is kind of tedious to do

00:51:46,520 --> 00:51:51,140
this before every single like scenario

00:51:49,190 --> 00:51:56,420
there also is this convenience function

00:51:51,140 --> 00:51:58,400
which just does it for you and then

00:51:56,420 --> 00:52:00,200
there's this trait which you can

00:51:58,400 --> 00:52:02,120
implement implement yourself by default

00:52:00,200 --> 00:52:05,540
we just provide a simple logger which

00:52:02,120 --> 00:52:07,820
does call console logging if you wanted

00:52:05,540 --> 00:52:09,620
some some structure login using JSON or

00:52:07,820 --> 00:52:13,040
whatever you could easily implement this

00:52:09,620 --> 00:52:15,350
yourself and here you can see basically

00:52:13,040 --> 00:52:17,420
it's it's it's a visitor it's just a

00:52:15,350 --> 00:52:23,270
like more appropriately named visitor

00:52:17,420 --> 00:52:27,230
pattern and yeah the logger that

00:52:23,270 --> 00:52:30,170
implements this and why we need this

00:52:27,230 --> 00:52:34,100
internal serial lager we will get to in

00:52:30,170 --> 00:52:36,680
a minute so this is how the output of

00:52:34,100 --> 00:52:40,280
such a test run would look and the

00:52:36,680 --> 00:52:41,660
actual console those okay's would be

00:52:40,280 --> 00:52:45,200
green and the field would be red just

00:52:41,660 --> 00:52:47,440
like you used to from rust itself the

00:52:45,200 --> 00:52:50,060
nice feature is whenever something fails

00:52:47,440 --> 00:52:52,820
you get the full path of those failures

00:52:50,060 --> 00:52:57,800
and for example if two of those failed

00:52:52,820 --> 00:52:59,660
at this yeah at this hierarchy then this

00:52:57,800 --> 00:53:01,850
one would be shared so you would have

00:52:59,660 --> 00:53:04,490
those listed together here it's not like

00:53:01,850 --> 00:53:05,810
you get all the stuff again don't repeat

00:53:04,490 --> 00:53:09,160
yourself is the principle of this

00:53:05,810 --> 00:53:15,860
framework and then you also get like

00:53:09,160 --> 00:53:18,020
test execution durations which are kind

00:53:15,860 --> 00:53:19,250
of like initially I thought I get yeah

00:53:18,020 --> 00:53:20,660
I'm also gonna be implementing like

00:53:19,250 --> 00:53:23,450
timing so you can figure out which of

00:53:20,660 --> 00:53:26,270
those tests is the slowest but given

00:53:23,450 --> 00:53:30,680
that they pretty much all share those

00:53:26,270 --> 00:53:32,240
parent notes it's kind of difficult to

00:53:30,680 --> 00:53:35,810
figure out like what actually makes

00:53:32,240 --> 00:53:38,840
sense to like call a long-running test

00:53:35,810 --> 00:53:40,400
because like then pretty much all of

00:53:38,840 --> 00:53:42,710
them would be run like long-running

00:53:40,400 --> 00:53:46,040
because they share the same bulk of

00:53:42,710 --> 00:53:46,910
setup code so right now we're only

00:53:46,040 --> 00:53:50,059
showing

00:53:46,910 --> 00:53:51,950
the total duration but if someone has a

00:53:50,059 --> 00:53:55,099
good idea how to do this more

00:53:51,950 --> 00:53:57,769
intelligently to also give you with some

00:53:55,099 --> 00:53:59,869
reasonable semantics like individual

00:53:57,769 --> 00:54:02,240
long-running tests so if there were some

00:53:59,869 --> 00:54:05,059
outliners outliers so you could like

00:54:02,240 --> 00:54:07,069
have us have a further part where you

00:54:05,059 --> 00:54:09,799
just have like long-running tests they

00:54:07,069 --> 00:54:11,359
would be nice and then just like you

00:54:09,799 --> 00:54:19,630
used to you from from rust itself you

00:54:11,359 --> 00:54:22,279
get this this very short statistic so

00:54:19,630 --> 00:54:27,470
basically every block in a block in this

00:54:22,279 --> 00:54:29,329
case like again it's the context does

00:54:27,470 --> 00:54:33,019
this execution to figure out what's the

00:54:29,329 --> 00:54:36,019
result of the test run so it basically

00:54:33,019 --> 00:54:39,200
does it goes through its own sub blocks

00:54:36,019 --> 00:54:41,329
iterates over them then maps the block

00:54:39,200 --> 00:54:45,559
to its evaluation which is which is a

00:54:41,329 --> 00:54:47,960
result passing at the current context in

00:54:45,559 --> 00:54:53,740
its environment and then simply collects

00:54:47,960 --> 00:54:58,339
those into into a vector of reports

00:54:53,740 --> 00:55:00,799
that's the serial execution then at some

00:54:58,339 --> 00:55:03,049
point I decided well I mean given that

00:55:00,799 --> 00:55:05,029
most of this stuff or all of the

00:55:03,049 --> 00:55:09,680
structure is immutable why not just try

00:55:05,029 --> 00:55:12,529
to make it parallel so I did that's all

00:55:09,680 --> 00:55:15,980
it took adding four four characters

00:55:12,529 --> 00:55:19,130
thanks to Ryan and now you have like

00:55:15,980 --> 00:55:21,079
fearless concurrency right because

00:55:19,130 --> 00:55:22,579
basically like you're running over this

00:55:21,079 --> 00:55:24,710
and creating a different structure

00:55:22,579 --> 00:55:26,230
you're not changing anything other than

00:55:24,710 --> 00:55:29,750
the environment but the environment

00:55:26,230 --> 00:55:31,190
every time there's a fork here you clone

00:55:29,750 --> 00:55:33,049
the environment so the environment has

00:55:31,190 --> 00:55:35,210
to be horrible obviously you clone the

00:55:33,049 --> 00:55:39,589
environment and then pass those further

00:55:35,210 --> 00:55:42,650
down but this way you have a very low

00:55:39,589 --> 00:55:44,900
memory usage and also again you don't

00:55:42,650 --> 00:55:47,690
have like any calculation is only done

00:55:44,900 --> 00:55:51,710
once instead of n times like you would

00:55:47,690 --> 00:55:54,859
do in shiny and stainless so fully

00:55:51,710 --> 00:55:57,859
concurrent and fully safe because thanks

00:55:54,859 --> 00:56:00,270
to rust we know that there's no context

00:55:57,859 --> 00:56:02,790
can interfere with any other context and

00:56:00,270 --> 00:56:07,130
see some ref sell magic whatever menu I

00:56:02,790 --> 00:56:12,110
mean that's up to you well almost

00:56:07,130 --> 00:56:17,130
because the way implement the the logger

00:56:12,110 --> 00:56:20,310
this is what gets printed instead again

00:56:17,130 --> 00:56:23,370
like you're you're printing this part

00:56:20,310 --> 00:56:26,760
when you're entering the example plus

00:56:23,370 --> 00:56:30,930
this and then you print the okay when

00:56:26,760 --> 00:56:34,380
you accidental different contexts at the

00:56:30,930 --> 00:56:37,790
same time potentially so yeah you get

00:56:34,380 --> 00:56:40,890
kind of like it not not joke here and

00:56:37,790 --> 00:56:44,330
the way we solve this the way I solve

00:56:40,890 --> 00:56:47,100
this is by having an internal

00:56:44,330 --> 00:56:51,870
non-exposed serial logger which then is

00:56:47,100 --> 00:56:53,640
wrapped by a public logger which reads

00:56:51,870 --> 00:56:56,220
out the configuration and whether it's

00:56:53,640 --> 00:56:58,590
parallel and if it is parallel and

00:56:56,220 --> 00:57:01,500
pretty much every of those functions

00:56:58,590 --> 00:57:05,010
from the runner observer simply nope

00:57:01,500 --> 00:57:08,220
they don't do anything all of these have

00:57:05,010 --> 00:57:10,500
the healthy comments so it's not okay so

00:57:08,220 --> 00:57:12,390
it's still kind of kind of understand

00:57:10,500 --> 00:57:16,230
what's going on here because it's kind

00:57:12,390 --> 00:57:18,840
of subtle but only if it actually is

00:57:16,230 --> 00:57:20,640
serial then it's actually doing

00:57:18,840 --> 00:57:22,860
something and here it would be pushing

00:57:20,640 --> 00:57:27,450
stuff to the to the buffer to standard

00:57:22,860 --> 00:57:29,580
out for example the only part where it

00:57:27,450 --> 00:57:33,450
behaves differently is this exit suite

00:57:29,580 --> 00:57:36,450
function where if it's zero it just does

00:57:33,450 --> 00:57:40,890
its thing but if it's parallel then it

00:57:36,450 --> 00:57:46,410
actually replace the entire events on to

00:57:40,890 --> 00:57:49,620
its internal serial logger and thanks

00:57:46,410 --> 00:57:52,020
for having the same structure from the

00:57:49,620 --> 00:57:55,740
code context and the same structure from

00:57:52,020 --> 00:58:01,760
the reports we just walk the Suites

00:57:55,740 --> 00:58:05,100
report and like simulate one execution

00:58:01,760 --> 00:58:07,020
so this is the report and this is the

00:58:05,100 --> 00:58:10,200
code for doing the replay I removed some

00:58:07,020 --> 00:58:12,350
some lines which are not important and

00:58:10,200 --> 00:58:14,160
also the types so it so it still fits

00:58:12,350 --> 00:58:16,349
well this is pretty much

00:58:14,160 --> 00:58:20,270
takes to make this thing parallely

00:58:16,349 --> 00:58:23,250
achievable without any locking there

00:58:20,270 --> 00:58:30,539
there's locking in the serial logger out

00:58:23,250 --> 00:58:33,030
however and we support four different

00:58:30,539 --> 00:58:36,170
kinds of types for matching so we can

00:58:33,030 --> 00:58:39,030
either return result a blue value or

00:58:36,170 --> 00:58:43,460
void which always is a success or panic

00:58:39,030 --> 00:58:46,980
which always is a failure and also

00:58:43,460 --> 00:58:51,780
because I like to use expect test crate

00:58:46,980 --> 00:58:55,799
for very nice mattress similar to the

00:58:51,780 --> 00:58:57,690
nimble framework and Swift or similar to

00:58:55,799 --> 00:59:04,260
what you would be used from the Ruby

00:58:57,690 --> 00:59:06,680
r-spec framework we also support expect

00:59:04,260 --> 00:59:09,569
test by the expect test compact feature

00:59:06,680 --> 00:59:12,359
which then recognizes the expected

00:59:09,569 --> 00:59:18,990
result expect test results type that's

00:59:12,359 --> 00:59:24,119
returned from those measures and so the

00:59:18,990 --> 00:59:26,309
roadmap right now is i'm i implemented

00:59:24,119 --> 00:59:29,130
some very very basic timing so you can

00:59:26,309 --> 00:59:30,990
just get the total time so you at least

00:59:29,130 --> 00:59:34,500
know how long you take your tests took

00:59:30,990 --> 00:59:36,869
to run but for the parallel execution

00:59:34,500 --> 00:59:40,140
you don't get any progress right because

00:59:36,869 --> 00:59:43,079
we do this let's just ignore any result

00:59:40,140 --> 00:59:46,470
but the last one and then we play so

00:59:43,079 --> 00:59:51,480
what i would like to do next is to add

00:59:46,470 --> 00:59:56,029
some progress bars for this and probably

00:59:51,480 --> 00:59:56,029
even also for the for the serial one

00:59:56,750 --> 01:00:02,760
also some kind of prioritization i'm

00:59:59,849 --> 01:00:04,230
thinking about like you might want to

01:00:02,760 --> 01:00:09,660
execute long-running tests before

01:00:04,230 --> 01:00:12,089
shorter tests so you would have to to

01:00:09,660 --> 01:00:14,069
keep some statistics about your test

01:00:12,089 --> 01:00:15,839
execution for example in the target for

01:00:14,069 --> 01:00:19,170
in the target directory and then based

01:00:15,839 --> 01:00:23,250
on this reorder your your blocks within

01:00:19,170 --> 01:00:24,990
the context and also filtering and

01:00:23,250 --> 01:00:27,810
focusing as you might know from our spec

01:00:24,990 --> 01:00:30,160
where you basically add a

01:00:27,810 --> 01:00:31,810
some prefix to your function I'm not

01:00:30,160 --> 01:00:34,930
sure if I would like to use a prefix but

01:00:31,810 --> 01:00:37,510
to add some kind of flag to your

01:00:34,930 --> 01:00:39,280
function to temporarily either focus on

01:00:37,510 --> 01:00:42,090
this particular test and ignore all the

01:00:39,280 --> 01:00:46,050
others or ignore this particular test or

01:00:42,090 --> 01:00:50,500
its context and all its sub test movie

01:00:46,050 --> 01:00:54,430
and then even though the tests execution

01:00:50,500 --> 01:00:56,560
itself is asynchronous that tests

01:00:54,430 --> 01:00:58,090
themselves right now are synchronous so

01:00:56,560 --> 01:01:00,550
I would like to be able to also support

01:00:58,090 --> 01:01:05,470
asynchronous tests but I mean I think

01:01:00,550 --> 01:01:10,750
this would be better suited for for an

01:01:05,470 --> 01:01:12,880
external crate using async measures so

01:01:10,750 --> 01:01:17,410
that you could use it with like standard

01:01:12,880 --> 01:01:21,130
rust tests or somewhere else and then

01:01:17,410 --> 01:01:25,869
maybe implement a DSL like you will you

01:01:21,130 --> 01:01:27,280
saw for for shiny and and and stainless

01:01:25,869 --> 01:01:30,160
but which then would still have the same

01:01:27,280 --> 01:01:32,800
semantics as the stuff here I'm not sure

01:01:30,160 --> 01:01:34,359
how feasible this is but this is at

01:01:32,800 --> 01:01:35,770
least my plan this stuff obviously would

01:01:34,359 --> 01:01:40,660
then be optional and not be stable

01:01:35,770 --> 01:01:43,650
obviously and then also that can be

01:01:40,660 --> 01:01:45,359
longer perspective I would like to

01:01:43,650 --> 01:01:53,590
[Music]

01:01:45,359 --> 01:01:55,420
revive a discussion about the extension

01:01:53,590 --> 01:01:58,330
of the current testing infrastructure

01:01:55,420 --> 01:02:01,359
because for this to be integrated into

01:01:58,330 --> 01:02:06,220
rust and to use the default native test

01:02:01,359 --> 01:02:08,320
Runner we would kind of have to like

01:02:06,220 --> 01:02:10,869
concatenate all those different levels

01:02:08,320 --> 01:02:12,850
of names that given when then into a

01:02:10,869 --> 01:02:15,160
long name and run this and you would

01:02:12,850 --> 01:02:19,090
pretty much lose any of the semantics

01:02:15,160 --> 01:02:21,220
and I'm also not sure how the execution

01:02:19,090 --> 01:02:23,320
with all this logic sharing and

01:02:21,220 --> 01:02:26,730
execution sharing would would map on

01:02:23,320 --> 01:02:31,540
this so this would probably need some

01:02:26,730 --> 01:02:35,200
some bigger discussion on how we would

01:02:31,540 --> 01:02:38,040
like to proceed with the overall scope

01:02:35,200 --> 01:02:38,040
of testing and rest

01:02:40,250 --> 01:02:50,910
yeah and if you want to contribute then

01:02:45,180 --> 01:02:52,740
please please please do there is there's

01:02:50,910 --> 01:02:54,990
instructions on how to contribute that

01:02:52,740 --> 01:02:56,310
basically it's just the the common

01:02:54,990 --> 01:02:58,710
common way of contributing and Russ

01:02:56,310 --> 01:03:03,990
project and there also is a tracking

01:02:58,710 --> 01:03:07,280
issue for all the currently open open

01:03:03,990 --> 01:03:11,510
things which i think is number six here

01:03:07,280 --> 01:03:15,300
which is at about sixty seventy percent

01:03:11,510 --> 01:03:26,640
that i have tackled so far so thanks

01:03:15,300 --> 01:03:29,520
many questions i just started to think

01:03:26,640 --> 01:03:31,260
that using that um what if you in your

01:03:29,520 --> 01:03:34,530
context you have an entity like a

01:03:31,260 --> 01:03:37,730
database and then you have a parallel

01:03:34,530 --> 01:03:39,930
tests and you somehow want to share a

01:03:37,730 --> 01:03:41,820
transaction or something and i don't

01:03:39,930 --> 01:03:44,220
want to spoil my own code because of

01:03:41,820 --> 01:03:45,660
tests so I could you know share is the

01:03:44,220 --> 01:03:47,850
same transaction or something how do you

01:03:45,660 --> 01:03:51,240
solve issues like you know external

01:03:47,850 --> 01:03:55,350
entities in a context so you would have

01:03:51,240 --> 01:03:57,960
to wrap this in in a mutex in arc in

01:03:55,350 --> 01:03:59,790
whatever is appropriate for your

01:03:57,960 --> 01:04:04,020
scenario because right the way it is

01:03:59,790 --> 01:04:06,020
defined let me see if it's here

01:04:04,020 --> 01:04:13,770
somewhere

01:04:06,020 --> 01:04:15,180
yeah so your key is the environment and

01:04:13,770 --> 01:04:17,820
the environment needs to implement clone

01:04:15,180 --> 01:04:20,160
send and sync and also most needs to be

01:04:17,820 --> 01:04:24,180
debuggable so it just stuff can actually

01:04:20,160 --> 01:04:28,550
get some output so as long as you ensure

01:04:24,180 --> 01:04:28,550
this stuff yourself you're free to go

01:04:28,910 --> 01:04:36,690
you certainly can use shared mutable

01:04:31,860 --> 01:04:38,250
state but avoiding it it's basically

01:04:36,690 --> 01:04:39,690
just you write your stuff and you simply

01:04:38,250 --> 01:04:41,490
don't have to care about any kind of

01:04:39,690 --> 01:04:42,840
interview interview thinking having my

01:04:41,490 --> 01:04:45,810
project running you know every every

01:04:42,840 --> 01:04:47,670
single call does something in a database

01:04:45,810 --> 01:04:50,250
and you run everything in parallel I

01:04:47,670 --> 01:04:53,220
just don't see it you know to be an easy

01:04:50,250 --> 01:04:53,950
easily solvable and test so well these

01:04:53,220 --> 01:04:55,690
wouldn't be running

01:04:53,950 --> 01:04:58,060
all of them because they were due

01:04:55,690 --> 01:05:00,520
blocking you would lose the parallel

01:04:58,060 --> 01:05:03,099
nature but then you can in this case you

01:05:00,520 --> 01:05:04,960
would just pass a different config

01:05:03,099 --> 01:05:07,180
to your runner which simply says it's

01:05:04,960 --> 01:05:09,670
zero you would still need to provide

01:05:07,180 --> 01:05:12,460
those constraints but it's at least then

01:05:09,670 --> 01:05:21,310
you wouldn't have any threat contention

01:05:12,460 --> 01:05:22,210
of stuff like this so I had a look at

01:05:21,310 --> 01:05:24,490
the r-spec

01:05:22,210 --> 01:05:28,329
some some time ago it wasn't that

01:05:24,490 --> 01:05:32,829
feature-rich at the time yes this one is

01:05:28,329 --> 01:05:35,980
on this one PR yeah yeah just draw a

01:05:32,829 --> 01:05:39,730
girl grew grew quite a lot and I really

01:05:35,980 --> 01:05:44,619
liked it - two additions there is

01:05:39,730 --> 01:05:47,560
already one one rust module with which

01:05:44,619 --> 01:05:50,650
implements the gherkin language but they

01:05:47,560 --> 01:05:54,820
don't do it with modules they parse

01:05:50,650 --> 01:05:57,339
feature files and I think just tables so

01:05:54,820 --> 01:06:00,750
maybe you can have a look there okay and

01:05:57,339 --> 01:06:04,869
check if we can maybe interface wisdom

01:06:00,750 --> 01:06:09,550
2nd edition to test frameworks this also

01:06:04,869 --> 01:06:13,119
the galvanic team test framework ok it's

01:06:09,550 --> 01:06:15,130
split in 3 parts in the surgeon part I

01:06:13,119 --> 01:06:16,390
was specifically looking for BDD

01:06:15,130 --> 01:06:18,369
frameworks like Jung there are lots of

01:06:16,390 --> 01:06:20,349
other testing frameworks which are good

01:06:18,369 --> 01:06:22,060
yeah I didn't mean to say that none of

01:06:20,349 --> 01:06:23,770
these work other than me alone but for

01:06:22,060 --> 01:06:25,089
BDD these are pretty much the only ones

01:06:23,770 --> 01:06:28,030
I could find there actually someone

01:06:25,089 --> 01:06:31,630
usable the stainless is the oldest one I

01:06:28,030 --> 01:06:34,869
think interesting it's still compliance

01:06:31,630 --> 01:06:37,329
well shiny doesn't yeah so like this is

01:06:34,869 --> 01:06:45,099
this huge PR and it's like intensely

01:06:37,329 --> 01:06:57,430
reviewed and oh what's happening here so

01:06:45,099 --> 01:06:58,930
where's the it's huge and like those are

01:06:57,430 --> 01:07:01,240
the two people right this is Thomas and

01:06:58,930 --> 01:07:04,230
me here I'm doing reviews and me like

01:07:01,240 --> 01:07:04,230
fixing this stuff he does like

01:07:09,240 --> 01:07:15,040
one thing basically is like I mean

01:07:13,120 --> 01:07:17,140
obviously I wanted to do this much lots

01:07:15,040 --> 01:07:19,540
of smaller and that's also what I what I

01:07:17,140 --> 01:07:24,640
wrote in the beginning like consider

01:07:19,540 --> 01:07:25,780
this like one of many I'm sure but I had

01:07:24,640 --> 01:07:29,200
to completely rip out the entire

01:07:25,780 --> 01:07:31,000
structure and then like replace it with

01:07:29,200 --> 01:07:32,920
something that's immutable and actually

01:07:31,000 --> 01:07:35,440
paralyze about because the way it was

01:07:32,920 --> 01:07:37,300
before you couldn't you didn't have

01:07:35,440 --> 01:07:39,220
environments you didn't have any kind of

01:07:37,300 --> 01:07:42,640
like environment sharing environment

01:07:39,220 --> 01:07:44,830
forking on this kind of stuff so yeah it

01:07:42,640 --> 01:07:49,770
was very limited before you didn't have

01:07:44,830 --> 01:07:49,770
any before or after functions and stuff

01:07:49,890 --> 01:07:55,540
I've got another question similar to the

01:07:52,420 --> 01:07:57,580
first one which is that I think you said

01:07:55,540 --> 01:07:59,500
that the the Continental context the

01:07:57,580 --> 01:08:02,020
environment that is passed between this

01:07:59,500 --> 01:08:04,780
history is immutable was that today no

01:08:02,020 --> 01:08:06,670
oh it's me the environment is the

01:08:04,780 --> 01:08:09,010
environment is immutable or I mean it's

01:08:06,670 --> 01:08:10,720
just a type right okay so any time you

01:08:09,010 --> 01:08:12,760
pass just any type you pass because

01:08:10,720 --> 01:08:14,020
because I was thinking something similar

01:08:12,760 --> 01:08:16,000
than the first question because what we

01:08:14,020 --> 01:08:17,920
do is we do testing with hardware so we

01:08:16,000 --> 01:08:21,460
do external allocation off test tracks

01:08:17,920 --> 01:08:24,100
and and how we do it in BDD at least

01:08:21,460 --> 01:08:26,050
before rest what we did is we allocate a

01:08:24,100 --> 01:08:27,820
test track in one of the upper parent

01:08:26,050 --> 01:08:29,170
modes and then passed that to the inner

01:08:27,820 --> 01:08:33,070
ones but but would that be something

01:08:29,170 --> 01:08:36,100
that we can do that way so let me just

01:08:33,070 --> 01:08:40,600
show you how the stuff is initialized

01:08:36,100 --> 01:08:42,880
here so this is the advanced example of

01:08:40,600 --> 01:08:47,760
ours and you basically are trying to

01:08:42,880 --> 01:08:50,440
test beat reset oh yeah sure

01:08:47,760 --> 01:08:51,940
so you try to test the beat reset and

01:08:50,440 --> 01:08:57,550
whether it like behaves like it should

01:08:51,940 --> 01:08:59,950
and here you like define your initial

01:08:57,550 --> 01:09:03,250
state of your of your of your scenario

01:08:59,950 --> 01:09:04,990
you pass it to the suite and then

01:09:03,250 --> 01:09:06,910
whenever you want to do any further

01:09:04,990 --> 01:09:08,650
modifications of this environment you

01:09:06,910 --> 01:09:12,160
have to do it within these before all

01:09:08,650 --> 01:09:13,690
before each after or after each there's

01:09:12,160 --> 01:09:16,300
no other way we actually have access

01:09:13,690 --> 01:09:16,869
mutable access to this you have actually

01:09:16,300 --> 01:09:18,639
really good

01:09:16,869 --> 01:09:24,880
Thanks you have access in the den but

01:09:18,639 --> 01:09:26,770
this is just immutable and like so

01:09:24,880 --> 01:09:33,219
basically what happens if you run this

01:09:26,770 --> 01:09:35,529
maybe let's take these the simple one so

01:09:33,219 --> 01:09:38,739
what happens when you run this is you

01:09:35,529 --> 01:09:41,349
first when we run this we collect all

01:09:38,739 --> 01:09:42,730
those contexts there could be code you

01:09:41,349 --> 01:09:45,449
could write code in here I mean can we

01:09:42,730 --> 01:09:47,730
cannot prevent this but this stuff

01:09:45,449 --> 01:09:50,469
interesting leanness like gets executed

01:09:47,730 --> 01:09:52,480
before anything happens in here because

01:09:50,469 --> 01:09:56,320
we first create the stuff and then in

01:09:52,480 --> 01:09:58,599
the end when this stuff is calculated

01:09:56,320 --> 01:10:02,409
and passed to the run function then we

01:09:58,599 --> 01:10:04,599
execute the tests so like you could like

01:10:02,409 --> 01:10:06,489
write and entire program and within

01:10:04,599 --> 01:10:09,099
these two lines but the testing

01:10:06,489 --> 01:10:13,989
framework doesn't care and then you just

01:10:09,099 --> 01:10:16,330
execute those in order I'm thinking

01:10:13,989 --> 01:10:18,280
about like also alternating the order so

01:10:16,330 --> 01:10:19,960
you don't but it shouldnt actually

01:10:18,280 --> 01:10:22,060
matter because you cannot have an t into

01:10:19,960 --> 01:10:24,580
any interference it should be completely

01:10:22,060 --> 01:10:26,380
isolated with her right unlike other

01:10:24,580 --> 01:10:29,550
testing frameworks where you wouldn't

01:10:26,380 --> 01:10:35,349
want to rely on the order of your tests

01:10:29,550 --> 01:10:38,139
and so this stuff is executed before any

01:10:35,349 --> 01:10:58,360
of these and there could be several of

01:10:38,139 --> 01:10:59,530
those are executed same for this one so

01:10:58,360 --> 01:11:01,300
the question is whether it would make

01:10:59,530 --> 01:11:03,310
sense to grow the environment to have

01:11:01,300 --> 01:11:10,690
some kind of stick and that's pretty

01:11:03,310 --> 01:11:15,909
much what we're doing yeah so also

01:11:10,690 --> 01:11:20,460
there's it's fully documented so should

01:11:15,909 --> 01:11:20,460
hopefully be somewhat understandable for

01:11:20,639 --> 01:11:24,210
someone new to the project

01:11:26,579 --> 01:11:40,590
oh yeah my n key is stuck new

01:11:35,730 --> 01:11:42,690
MacBooks yeah and my ctrl key is broken

01:11:40,590 --> 01:11:47,579
so that's I need I need to go to the

01:11:42,690 --> 01:11:51,809
genius person so basically you you clone

01:11:47,579 --> 01:11:54,179
the environment whenever whenever you

01:11:51,809 --> 01:11:58,110
you reach one of those sub sub contacts

01:11:54,179 --> 01:12:01,190
and you don't have like an explicit

01:11:58,110 --> 01:12:04,559
stack but the call stack is your stack

01:12:01,190 --> 01:12:09,210
so in the end effectively you do have

01:12:04,559 --> 01:12:11,849
stack yeah so if you do receive a serial

01:12:09,210 --> 01:12:13,619
execution then you only have this they

01:12:11,849 --> 01:12:16,469
only have the current branch of your

01:12:13,619 --> 01:12:22,500
tree in memory if you have power then of

01:12:16,469 --> 01:12:25,590
course things can be a bit different I

01:12:22,500 --> 01:12:27,780
have a completely unrelated question are

01:12:25,590 --> 01:12:30,119
there are some facilities for auto

01:12:27,780 --> 01:12:35,639
registering test cases if there are for

01:12:30,119 --> 01:12:42,829
example on different files yes so right

01:12:35,639 --> 01:12:42,829
now you have to do wait

01:12:46,790 --> 01:12:52,460
all this run function or call run on the

01:12:48,770 --> 01:12:54,830
runner and there's no we cannot cannot

01:12:52,460 --> 01:12:57,500
simply like hook into this this test

01:12:54,830 --> 01:12:59,330
annotation stuff that's what I would

01:12:57,500 --> 01:13:01,340
like to be able to do but for this we

01:12:59,330 --> 01:13:04,270
would have to extend the native test

01:13:01,340 --> 01:13:07,160
furniture except like structural testing

01:13:04,270 --> 01:13:09,830
maybe it could be one of those rare

01:13:07,160 --> 01:13:12,860
places where singleton would make sense

01:13:09,830 --> 01:13:15,440
because so you could for example auto

01:13:12,860 --> 01:13:17,990
regressive surfing and in an array or

01:13:15,440 --> 01:13:20,150
all the functions they may have the

01:13:17,990 --> 01:13:24,140
r-spec run in the function and then

01:13:20,150 --> 01:13:27,290
execute all those functions so you mean

01:13:24,140 --> 01:13:33,290
like having a like a dummy test function

01:13:27,290 --> 01:13:35,570
which simply right yeah I mean or yeah

01:13:33,290 --> 01:13:38,330
or you could just basic what you could

01:13:35,570 --> 01:13:41,720
do is you could just like put this into

01:13:38,330 --> 01:13:44,060
a single test function for which the

01:13:41,720 --> 01:13:45,980
name would then have like the actual

01:13:44,060 --> 01:13:48,470
name of your scenario but this might

01:13:45,980 --> 01:13:50,870
interfere with the test logging in test

01:13:48,470 --> 01:13:54,440
running because we do our own logging

01:13:50,870 --> 01:13:56,420
and we also that so you can you can run

01:13:54,440 --> 01:13:59,300
multiple scenarios at the same time not

01:13:56,420 --> 01:14:02,120
as serious but you can specify whether

01:13:59,300 --> 01:14:03,710
it should bail out once any of these

01:14:02,120 --> 01:14:06,470
fails or whether they should continue

01:14:03,710 --> 01:14:09,050
and like log the certain failures or

01:14:06,470 --> 01:14:11,660
successes but there is no way to easily

01:14:09,050 --> 01:14:15,320
integrate this right now you pretty much

01:14:11,660 --> 01:14:17,630
have to create a specific like binary

01:14:15,320 --> 01:14:20,810
target for running this that's what I

01:14:17,630 --> 01:14:23,030
would like to fix by opening some

01:14:20,810 --> 01:14:24,620
discussion about how to make the rust

01:14:23,030 --> 01:14:28,670
run or more extensible in this regard

01:14:24,620 --> 01:14:31,850
okay but probably should just continue

01:14:28,670 --> 01:14:36,140
this question outside of the general

01:14:31,850 --> 01:14:39,440
forum is there a last a final very quick

01:14:36,140 --> 01:14:44,360
question or I think we can is it really

01:14:39,440 --> 01:14:46,190
quick too okay the parallelization is it

01:14:44,360 --> 01:14:51,690
is a global setting or can you enable it

01:14:46,190 --> 01:14:55,020
for context per context

01:14:51,690 --> 01:14:56,610
no you can you can you spit and you you

01:14:55,020 --> 01:14:59,340
specified in the conflict which you pass

01:14:56,610 --> 01:15:01,280
through the runner wait actually have to

01:14:59,340 --> 01:15:04,890
I think that's a good answer

01:15:01,280 --> 01:15:09,380
you it's it's it's II I'm not quite sure

01:15:04,890 --> 01:15:11,730
it's either per runner or purse sweet

01:15:09,380 --> 01:15:13,560
but in the end it doesn't really make

01:15:11,730 --> 01:15:16,730
much of a difference you can run several

01:15:13,560 --> 01:15:20,940
suite with one runner but all right

01:15:16,730 --> 01:15:23,100
thank you that was very extensive thanks

01:15:20,940 --> 01:15:24,390
for all the great questions sorry for

01:15:23,100 --> 01:15:26,160
everyone who's watching this live stream

01:15:24,390 --> 01:15:29,580
that we had might issue in the first

01:15:26,160 --> 01:15:31,680
minute and yeah thank you everyone for

01:15:29,580 --> 01:15:33,210
coming this is the end of the talks it's

01:15:31,680 --> 01:15:34,949
not necessarily the end of the Meetup

01:15:33,210 --> 01:15:37,230
I'll be around for a bit longer so you

01:15:34,949 --> 01:15:39,180
can linger here as well and and talk to

01:15:37,230 --> 01:15:41,100
each other and have some more food

01:15:39,180 --> 01:15:44,940
there's still some bagels left and and

01:15:41,100 --> 01:15:46,320
free drinks on the house and again thank

01:15:44,940 --> 01:15:48,239
you for coming we'll have another

01:15:46,320 --> 01:15:51,440
edition in November and we'll announce

01:15:48,239 --> 01:15:54,630
it again a couple of weeks before and

01:15:51,440 --> 01:15:56,040
again if you want to talk well will not

01:15:54,630 --> 01:15:58,230
do a meet-up in December but if you want

01:15:56,040 --> 01:16:00,300
to talk in 2018 please reach out to me

01:15:58,230 --> 01:16:02,140
and I'd be happy to arrange it thanks

01:16:00,300 --> 01:16:09,819
for being here

01:16:02,140 --> 01:16:09,819
[Applause]

01:16:16,610 --> 01:16:19,689

YouTube URL: https://www.youtube.com/watch?v=-9DXoSEdNoc


