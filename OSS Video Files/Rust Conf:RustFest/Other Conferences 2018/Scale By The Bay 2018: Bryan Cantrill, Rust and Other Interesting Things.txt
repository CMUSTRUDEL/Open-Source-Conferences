Title: Scale By The Bay 2018: Bryan Cantrill, Rust and Other Interesting Things
Publication date: 2018-12-10
Playlist: Other Conferences 2018
Description: 
	Scale By the Bay 2019 is held on November 13-15 in sunny Oakland, California, on the shores of Lake Merritt: https://scale.bythebay.io.  Join us!
-----

Bryan, the CTO of Joyent, and a core contributor to Solaris, ZFS, and DTrace, formerly a Distinguished Engineer at Sun, has recently picked up Rust.  He'll share his experience with us.
Captions: 
	00:00:14,490 --> 00:00:19,810
good morning everybody um it's great to

00:00:17,920 --> 00:00:22,210
be here I this is definitely the first

00:00:19,810 --> 00:00:23,890
time maybe the only time in my life that

00:00:22,210 --> 00:00:27,130
I'm in the functional programming track

00:00:23,890 --> 00:00:30,210
that is definitely a first so it's

00:00:27,130 --> 00:00:32,619
exciting because often on honestly

00:00:30,210 --> 00:00:34,570
functional languages have not really

00:00:32,619 --> 00:00:37,510
functional programming has not really

00:00:34,570 --> 00:00:39,880
been on the menu for me as a system

00:00:37,510 --> 00:00:40,989
software programmer it kind of actually

00:00:39,880 --> 00:00:42,310
entered the menu ironically enough with

00:00:40,989 --> 00:00:46,030
JavaScript I mean I'm embarrassed to say

00:00:42,310 --> 00:00:48,100
this but I I really I mean I yes my

00:00:46,030 --> 00:00:50,890
degrees in computer science so there's

00:00:48,100 --> 00:00:53,109
no real excuse for this but I didn't

00:00:50,890 --> 00:00:54,489
really appreciate or learn functional

00:00:53,109 --> 00:00:57,760
programming until implanting in

00:00:54,489 --> 00:00:59,170
JavaScript in 2006 so I hopefully I'm in

00:00:57,760 --> 00:01:02,469
kind of a safe space where I can confess

00:00:59,170 --> 00:01:04,269
that to you but um and actually it was

00:01:02,469 --> 00:01:05,860
funny for those of you who weren't

00:01:04,269 --> 00:01:08,200
around at that time to tell it was kind

00:01:05,860 --> 00:01:10,080
of a weird time because we had this

00:01:08,200 --> 00:01:13,060
thing called Ajax asynchronous

00:01:10,080 --> 00:01:15,160
JavaScript and XML worst acronym ever

00:01:13,060 --> 00:01:16,420
like you can't have one of the letters

00:01:15,160 --> 00:01:19,329
be a conjunction another be an

00:01:16,420 --> 00:01:21,400
abbreviation of a terrible terrible an

00:01:19,329 --> 00:01:23,740
idea or a good idea but of a terrible

00:01:21,400 --> 00:01:25,420
abbreviation terrible acronym and a

00:01:23,740 --> 00:01:26,950
bunch of us kind of simultaneously were

00:01:25,420 --> 00:01:28,509
waiting in the JavaScript in late 2005

00:01:26,950 --> 00:01:30,369
2006 because we're trying to actually

00:01:28,509 --> 00:01:32,049
build these like interesting programs on

00:01:30,369 --> 00:01:33,369
the browser and discovering like oh my

00:01:32,049 --> 00:01:34,960
god that's a real language here in terms

00:01:33,369 --> 00:01:36,130
of JavaScript it's not just for blank

00:01:34,960 --> 00:01:38,229
tags like I'm actually doing interesting

00:01:36,130 --> 00:01:41,140
things and I actually like oh my god I

00:01:38,229 --> 00:01:43,180
actually I I'm learning what a closure

00:01:41,140 --> 00:01:44,530
is I'm actually I am appreciating a

00:01:43,180 --> 00:01:47,979
lambda I'm actually appreciating this

00:01:44,530 --> 00:01:50,890
stuff so that was great um but in

00:01:47,979 --> 00:01:52,360
JavaScript has been great but and we've

00:01:50,890 --> 00:01:54,579
used to Detroit for a bunch of different

00:01:52,360 --> 00:01:56,710
reasons but the truth is that in the

00:01:54,579 --> 00:01:58,689
deeper parts of system software we have

00:01:56,710 --> 00:02:00,430
not really had that kind of power that

00:01:58,689 --> 00:02:03,039
that programmatic power we've proven

00:02:00,430 --> 00:02:04,240
kind of stuck and I think we're about to

00:02:03,039 --> 00:02:05,829
get unstuck and I want to kind of

00:02:04,240 --> 00:02:08,860
explain what what I'm seeing there I

00:02:05,829 --> 00:02:10,690
want to talk first about about platform

00:02:08,860 --> 00:02:13,930
values and software values because the

00:02:10,690 --> 00:02:16,210
older I get the more I believe that that

00:02:13,930 --> 00:02:19,360
values are really core to the decisions

00:02:16,210 --> 00:02:23,290
that we make so what do I mean by by

00:02:19,360 --> 00:02:26,390
values so values are positive traits

00:02:23,290 --> 00:02:28,850
that you are choosing amongst

00:02:26,390 --> 00:02:31,670
so we all that there are lots of kind of

00:02:28,850 --> 00:02:34,370
positive things but our own individual

00:02:31,670 --> 00:02:36,709
values will dictate when if we when we

00:02:34,370 --> 00:02:38,750
have to choose between two things how we

00:02:36,709 --> 00:02:42,110
actually make that choice and different

00:02:38,750 --> 00:02:45,350
platforms make that choice differently

00:02:42,110 --> 00:02:46,700
and too often I think that we look at

00:02:45,350 --> 00:02:49,550
the different choices that a different

00:02:46,700 --> 00:02:51,290
platform has made and we we will

00:02:49,550 --> 00:02:53,360
criticize those choices or we will

00:02:51,290 --> 00:02:56,120
embrace those choices but we're actually

00:02:53,360 --> 00:02:59,060
doing is we are commenting on our own

00:02:56,120 --> 00:03:01,220
values relative to the values perhaps of

00:02:59,060 --> 00:03:03,320
a different system so our own values are

00:03:01,220 --> 00:03:06,200
really important and the values that we

00:03:03,320 --> 00:03:09,560
have shift based on what we're doing

00:03:06,200 --> 00:03:12,560
where when we don't have necessarily one

00:03:09,560 --> 00:03:14,840
set of values for all of the software we

00:03:12,560 --> 00:03:16,850
write we got different software what we

00:03:14,840 --> 00:03:19,220
write we will have different values and

00:03:16,850 --> 00:03:21,290
we want our software to reflect those

00:03:19,220 --> 00:03:22,280
values and I think that actually in the

00:03:21,290 --> 00:03:24,260
in the kind of the post open source

00:03:22,280 --> 00:03:25,640
world when we are selecting a

00:03:24,260 --> 00:03:26,989
programming language we're looking at a

00:03:25,640 --> 00:03:29,060
programming language we're looking at a

00:03:26,989 --> 00:03:32,000
software platform we should be looking

00:03:29,060 --> 00:03:35,030
as much at values as we are at anything

00:03:32,000 --> 00:03:36,680
else do the values here reflect the

00:03:35,030 --> 00:03:38,660
values that I want for this thing

00:03:36,680 --> 00:03:40,180
especially when community is so

00:03:38,660 --> 00:03:42,620
important I mean in an open source world

00:03:40,180 --> 00:03:44,690
you're selecting community as much as

00:03:42,620 --> 00:03:46,459
you're selecting anything else and I've

00:03:44,690 --> 00:03:47,900
learned this the hard way where you've

00:03:46,459 --> 00:03:50,000
got because if you like I love the

00:03:47,900 --> 00:03:51,140
technology and the community is I've got

00:03:50,000 --> 00:03:53,269
come comes vicious with but I really

00:03:51,140 --> 00:03:54,920
love the technology if the community

00:03:53,269 --> 00:03:56,660
doesn't reflect your values you will

00:03:54,920 --> 00:03:58,670
find that the software will come to not

00:03:56,660 --> 00:04:00,350
reflect your values as well so you

00:03:58,670 --> 00:04:01,970
really need to need to define the right

00:04:00,350 --> 00:04:04,010
community for the values the right

00:04:01,970 --> 00:04:05,420
values then for it for the job the right

00:04:04,010 --> 00:04:07,310
software for the value so what's gonna

00:04:05,420 --> 00:04:10,370
make this a little more specific here so

00:04:07,310 --> 00:04:13,250
this is just kind of a scattering of

00:04:10,370 --> 00:04:15,320
random values these are this is not a

00:04:13,250 --> 00:04:16,489
very well organized list I guess it's

00:04:15,320 --> 00:04:18,380
alphabetical I guess I could make it

00:04:16,489 --> 00:04:19,760
alphabetical other than that it's not

00:04:18,380 --> 00:04:21,410
really sorted it's not meant to be

00:04:19,760 --> 00:04:23,570
exhaustive there are lots more values

00:04:21,410 --> 00:04:24,560
than this and each of these values kind

00:04:23,570 --> 00:04:26,390
of mean different things to different

00:04:24,560 --> 00:04:28,580
people so there's a lot of nuance here

00:04:26,390 --> 00:04:30,800
but we can kind of generally agree what

00:04:28,580 --> 00:04:32,930
it means to have performances of value

00:04:30,800 --> 00:04:34,849
what it means to have robustness as a

00:04:32,930 --> 00:04:35,870
value or debug ability as a value or

00:04:34,849 --> 00:04:38,320
composability

00:04:35,870 --> 00:04:42,190
as a value or expressiveness as of

00:04:38,320 --> 00:04:44,620
you and you can't have it all you can't

00:04:42,190 --> 00:04:46,780
choose all of these things we can all

00:04:44,620 --> 00:04:48,670
agree that each of these things is

00:04:46,780 --> 00:04:51,550
important I don't think any of us would

00:04:48,670 --> 00:04:53,290
say that that value is just garbage and

00:04:51,550 --> 00:04:55,060
you should never want it right I mean

00:04:53,290 --> 00:04:56,080
for I don't know maybe there are some

00:04:55,060 --> 00:04:58,060
things up here but I think that in

00:04:56,080 --> 00:05:00,100
general we would say you know all of

00:04:58,060 --> 00:05:01,900
these things are important they're good

00:05:00,100 --> 00:05:04,060
they have their place but the real

00:05:01,900 --> 00:05:07,210
question is when you have to make a

00:05:04,060 --> 00:05:09,970
choice between two of them what do you

00:05:07,210 --> 00:05:12,910
choose and those what that choice that

00:05:09,970 --> 00:05:15,960
you make you being a software platform a

00:05:12,910 --> 00:05:20,080
language a community that choice

00:05:15,960 --> 00:05:21,940
reflects the core values of that that

00:05:20,080 --> 00:05:24,700
platform or language and you can't have

00:05:21,940 --> 00:05:26,320
every value be a core value so what are

00:05:24,700 --> 00:05:28,360
the core values of some of these things

00:05:26,320 --> 00:05:30,850
because these things are in tension and

00:05:28,360 --> 00:05:32,890
I think that they do when you have these

00:05:30,850 --> 00:05:35,890
core values they're going to attract

00:05:32,890 --> 00:05:38,890
like-minded folks and as a result they

00:05:35,890 --> 00:05:40,600
become self reinforcing because those

00:05:38,890 --> 00:05:42,490
who are attracted to those values are

00:05:40,600 --> 00:05:44,110
attracted to the software and then they

00:05:42,490 --> 00:05:45,400
want to defend those values in the

00:05:44,110 --> 00:05:47,530
software they want those values to

00:05:45,400 --> 00:05:49,690
remain consistent so that they there's a

00:05:47,530 --> 00:05:52,000
self-fulfilling prophecy here so let's

00:05:49,690 --> 00:05:54,910
look at these values so kind of grayed

00:05:52,000 --> 00:05:58,270
out the values that they don't have and

00:05:54,910 --> 00:06:01,320
say you know the history of C is pretty

00:05:58,270 --> 00:06:04,360
interesting we we tend to think of C and

00:06:01,320 --> 00:06:05,650
UNIX as being identical twins born at

00:06:04,360 --> 00:06:07,360
the same moment kind of in the birth

00:06:05,650 --> 00:06:08,250
canal at the same time that's not

00:06:07,360 --> 00:06:12,040
actually the case

00:06:08,250 --> 00:06:14,110
UNIX was actually developed before C if

00:06:12,040 --> 00:06:16,900
slightly units was developed originally

00:06:14,110 --> 00:06:18,490
all in assembly and there was an opera

00:06:16,900 --> 00:06:20,560
there was a language called B that was

00:06:18,490 --> 00:06:23,250
kind of floating around but they didn't

00:06:20,560 --> 00:06:25,960
really use B for very much B was slow so

00:06:23,250 --> 00:06:27,820
B was used for some ancillary parts of

00:06:25,960 --> 00:06:30,490
the operating system and they they saw

00:06:27,820 --> 00:06:33,130
the need to develop a higher-level

00:06:30,490 --> 00:06:35,290
language a structured language although

00:06:33,130 --> 00:06:37,330
the higher level came first that would

00:06:35,290 --> 00:06:39,550
allow them to not have to employ in the

00:06:37,330 --> 00:06:43,200
operating system in assembly that is

00:06:39,550 --> 00:06:46,270
that the birthplace of C is we want

00:06:43,200 --> 00:06:50,080
effectively a better assembly we want a

00:06:46,270 --> 00:06:51,309
non machine specific assembly and that's

00:06:50,080 --> 00:06:53,559
what C is

00:06:51,309 --> 00:06:55,719
see is effectively portably assemble

00:06:53,559 --> 00:06:58,809
portable assembly the a number one goal

00:06:55,719 --> 00:07:00,099
of C is is performance and I add

00:06:58,809 --> 00:07:02,469
interoperability that are as well

00:07:00,099 --> 00:07:04,539
because it is just models the Machine C

00:07:02,469 --> 00:07:06,429
is designed to interoperate with

00:07:04,539 --> 00:07:08,559
anything that can execute on the machine

00:07:06,429 --> 00:07:10,139
effectively so C interoperates with

00:07:08,559 --> 00:07:12,339
assembly it can interoperate with

00:07:10,139 --> 00:07:13,869
effectively anything that is going to

00:07:12,339 --> 00:07:15,339
actually operate on the machine so

00:07:13,869 --> 00:07:17,289
interoperability is very important

00:07:15,339 --> 00:07:18,909
portability these are important and then

00:07:17,289 --> 00:07:22,989
simplicity one of the things that's

00:07:18,909 --> 00:07:25,149
interesting about C is C only grew those

00:07:22,989 --> 00:07:28,059
things that were needed to implement

00:07:25,149 --> 00:07:30,249
UNIX so they didn't add structures to

00:07:28,059 --> 00:07:31,989
UNIX or just C until they realize they

00:07:30,249 --> 00:07:34,029
needed them named one UNIX so C it

00:07:31,989 --> 00:07:35,860
really didn't have structures seems like

00:07:34,029 --> 00:07:37,029
what do you what does he have if it

00:07:35,860 --> 00:07:38,979
doesn't have structures seems like it

00:07:37,029 --> 00:07:40,269
has precious precious little but

00:07:38,979 --> 00:07:41,469
assembly doesn't have structures so why

00:07:40,269 --> 00:07:42,909
would you and then that you know what

00:07:41,469 --> 00:07:45,279
structures would make this a lot easier

00:07:42,909 --> 00:07:50,499
so they added structures okay but they

00:07:45,279 --> 00:07:53,379
kind of stopped there and C has retained

00:07:50,499 --> 00:07:56,229
that minimalist aesthetic which i think

00:07:53,379 --> 00:07:57,969
is very core to two C's value so this is

00:07:56,229 --> 00:07:59,649
what I would say these values are and

00:07:57,969 --> 00:08:00,999
it's not that C doesn't care about these

00:07:59,649 --> 00:08:02,559
other things it's just that it

00:08:00,999 --> 00:08:04,419
deliberately if it has to make a choice

00:08:02,559 --> 00:08:06,309
between these or when it had to make a

00:08:04,419 --> 00:08:08,919
choice between these these are the ones

00:08:06,309 --> 00:08:10,989
that that it chose and admittedly C is

00:08:08,919 --> 00:08:13,239
also in a time when a lot of these

00:08:10,989 --> 00:08:14,709
things are much more profound tension

00:08:13,239 --> 00:08:16,149
performance and expressiveness for

00:08:14,709 --> 00:08:19,389
example we're very much in tension and

00:08:16,149 --> 00:08:20,439
that they chose performance just throw

00:08:19,389 --> 00:08:22,329
that as long as doing one letter

00:08:20,439 --> 00:08:24,699
languages in terms of B and C might as

00:08:22,329 --> 00:08:26,169
well throw K in there it's got nothing

00:08:24,699 --> 00:08:30,789
to do with system software enough people

00:08:26,169 --> 00:08:33,430
know K K and Q it's follow-on were

00:08:30,789 --> 00:08:35,860
developed by again Arthur Whitney who is

00:08:33,430 --> 00:08:37,240
definitely unlike a different astral

00:08:35,860 --> 00:08:40,990
plane

00:08:37,240 --> 00:08:45,100
so Arthur believes that the Arthur's

00:08:40,990 --> 00:08:49,149
aesthetic is all around minimalism and

00:08:45,100 --> 00:08:51,910
expressiveness Arthur Arthur learned APL

00:08:49,149 --> 00:08:53,170
from Ken Iverson at age four I'm not

00:08:51,910 --> 00:08:55,870
making this up he's like Ken Iverson's

00:08:53,170 --> 00:08:57,699
neighbor and further Arthur has the

00:08:55,870 --> 00:08:59,949
belief which I admire and I love and I I

00:08:57,699 --> 00:09:01,629
mean I I don't want to like III don't

00:08:59,949 --> 00:09:03,830
want to talk him out of this belief that

00:09:01,629 --> 00:09:06,410
he can teach any four-year-old API

00:09:03,830 --> 00:09:08,390
now when he told me this I had a four

00:09:06,410 --> 00:09:10,310
year old that I knew for a fact could

00:09:08,390 --> 00:09:12,830
not be taught APL I mean I'm Betty and

00:09:10,310 --> 00:09:14,060
and he's like you should bring your four

00:09:12,830 --> 00:09:15,380
year old and I will teach them aap I'm

00:09:14,060 --> 00:09:18,500
like this is gonna end poorly for

00:09:15,380 --> 00:09:20,360
everybody because I you are not gonna be

00:09:18,500 --> 00:09:22,459
able to teach him APL and he's gonna be

00:09:20,360 --> 00:09:23,899
very upset having to learn aap I think

00:09:22,459 --> 00:09:26,260
this is not gonna do well we're not I'm

00:09:23,899 --> 00:09:29,600
not gonna call this Bluff but I I I

00:09:26,260 --> 00:09:31,850
admire the beauty of a brain that

00:09:29,600 --> 00:09:34,070
believes that APL can be taught to a

00:09:31,850 --> 00:09:38,089
four-year-old that's that's amazing to

00:09:34,070 --> 00:09:40,640
me on but Kay's only values are in that

00:09:38,089 --> 00:09:42,920
expressiveness Arthur wants to write a

00:09:40,640 --> 00:09:44,600
program and I guess it's not funny I

00:09:42,920 --> 00:09:47,360
shouldn't say without laughing in as few

00:09:44,600 --> 00:09:50,540
characters as possible I mean that is

00:09:47,360 --> 00:09:53,480
what beauty is - Arthur fewest number of

00:09:50,540 --> 00:09:54,740
characters I don't know if he feels he's

00:09:53,480 --> 00:09:55,790
gonna be vividly punished for the number

00:09:54,740 --> 00:09:57,410
of characters uses I don't quite

00:09:55,790 --> 00:09:59,839
understand what drives that but that's

00:09:57,410 --> 00:10:01,550
what drives that and and he will make

00:09:59,839 --> 00:10:04,040
code denser and denser and denser and

00:10:01,550 --> 00:10:05,870
denser is it readable it is emphatically

00:10:04,040 --> 00:10:08,000
not readable and it looks like you know

00:10:05,870 --> 00:10:09,320
and from if you're of my vintage it

00:10:08,000 --> 00:10:11,060
looks like your mom picked up the phone

00:10:09,320 --> 00:10:13,130
when you were on the modem and you get

00:10:11,060 --> 00:10:16,250
like a bunch of line noise like that's

00:10:13,130 --> 00:10:16,670
like compilable K I think um but it's

00:10:16,250 --> 00:10:18,380
beautiful

00:10:16,670 --> 00:10:20,149
alright so that's in but these are the

00:10:18,380 --> 00:10:21,820
only values like don't care do we dead

00:10:20,149 --> 00:10:23,810
we don't get maintainability readability

00:10:21,820 --> 00:10:25,010
no don't care we care about its

00:10:23,810 --> 00:10:27,490
expressiveness in performance

00:10:25,010 --> 00:10:31,430
that's it performs very very well and

00:10:27,490 --> 00:10:33,589
used often for market facing kind of

00:10:31,430 --> 00:10:34,790
operations I just gotta throw this in

00:10:33,589 --> 00:10:36,200
there for another one that's quick

00:10:34,790 --> 00:10:38,209
that's kind of clarifying you know

00:10:36,200 --> 00:10:42,380
OpenBSD the operating system security

00:10:38,209 --> 00:10:44,720
end of core values the there is no other

00:10:42,380 --> 00:10:47,270
core value in open BSD in that and that

00:10:44,720 --> 00:10:49,820
that's not I'm not being perative it's

00:10:47,270 --> 00:10:52,279
actually incredibly clarifying when you

00:10:49,820 --> 00:10:54,110
have a system that is so upfront and

00:10:52,279 --> 00:10:56,959
transparent about this is what we care

00:10:54,110 --> 00:10:59,270
about and we don't care if we're gonna

00:10:56,959 --> 00:11:01,730
make the system much slower to make it

00:10:59,270 --> 00:11:03,860
secure that's what we're gonna do if we

00:11:01,730 --> 00:11:05,180
need to turn off hyper-threading because

00:11:03,860 --> 00:11:07,250
we believe that hyper threading is

00:11:05,180 --> 00:11:08,720
unsafe at any speed that's what we're

00:11:07,250 --> 00:11:10,310
gonna go do and you're gonna lose half

00:11:08,720 --> 00:11:11,870
your virtual cores but too bad they were

00:11:10,310 --> 00:11:13,579
never secure they were always vulnerable

00:11:11,870 --> 00:11:15,079
to side channel attacks but it's all

00:11:13,579 --> 00:11:16,880
true actually that's all that that's a

00:11:15,079 --> 00:11:17,720
totally reasonable

00:11:16,880 --> 00:11:19,910
if

00:11:17,720 --> 00:11:22,010
position an admirable position this is

00:11:19,910 --> 00:11:24,620
what OpenBSD cares about and and more

00:11:22,010 --> 00:11:26,570
power to them um I just I love auch

00:11:24,620 --> 00:11:29,030
gotta lock in there just give you kind

00:11:26,570 --> 00:11:31,010
of some different examples auch is

00:11:29,030 --> 00:11:33,680
really about like writing programs

00:11:31,010 --> 00:11:35,780
quickly I write I mean I don't know

00:11:33,680 --> 00:11:37,700
about you but I you know I write awk on

00:11:35,780 --> 00:11:40,040
a daily basis I write three or four

00:11:37,700 --> 00:11:41,630
Ockham's day like I just and these are

00:11:40,040 --> 00:11:45,020
one-liners right these are super quick

00:11:41,630 --> 00:11:46,430
programs but awk is really beautiful in

00:11:45,020 --> 00:11:48,650
that then I can write something super

00:11:46,430 --> 00:11:50,270
quickly it's very simple it's pretty

00:11:48,650 --> 00:11:52,010
expressive as these things go you can do

00:11:50,270 --> 00:11:54,830
a lot with a little anak it's very

00:11:52,010 --> 00:11:56,690
approachable you can get anyone to be if

00:11:54,830 --> 00:11:59,120
you've read the awk programming language

00:11:56,690 --> 00:12:00,230
so awk named because of aho Weinberger

00:11:59,120 --> 00:12:02,660
and Kernighan the three people that

00:12:00,230 --> 00:12:05,180
invented it the ark programming language

00:12:02,660 --> 00:12:07,610
I think is an absolute model of

00:12:05,180 --> 00:12:09,290
programming language documentation so

00:12:07,610 --> 00:12:11,450
you you get the awk program language

00:12:09,290 --> 00:12:13,670
it's like 130 pages the book it's

00:12:11,450 --> 00:12:15,980
beautifully written beautifully typeset

00:12:13,670 --> 00:12:17,930
you'll read it in like two hours and

00:12:15,980 --> 00:12:19,670
then you're done like that's it

00:12:17,930 --> 00:12:21,320
you know all about there's there's

00:12:19,670 --> 00:12:24,470
nothing more to know about Ock like you

00:12:21,320 --> 00:12:26,240
actually learned it all the end and it's

00:12:24,470 --> 00:12:27,620
there's something that is great and

00:12:26,240 --> 00:12:29,840
beautiful by that it's simple its

00:12:27,620 --> 00:12:30,890
approachable and so on I think you might

00:12:29,840 --> 00:12:32,900
be able to teach a four-year-old awk

00:12:30,890 --> 00:12:34,880
maybe you know that's crazy you can't do

00:12:32,900 --> 00:12:37,460
that I died but maybe a seven-year-old

00:12:34,880 --> 00:12:39,680
I'm okay now I have never written a line

00:12:37,460 --> 00:12:41,780
of Scala so and if you like if you like

00:12:39,680 --> 00:12:43,730
rush the stage because this is wrong um

00:12:41,780 --> 00:12:46,160
I'm sorry that's I put a question mark

00:12:43,730 --> 00:12:50,420
there to try to reason with the mob as

00:12:46,160 --> 00:12:52,070
they were throwing chairs at me so and I

00:12:50,420 --> 00:12:53,630
I'm not necessary asserting this but it

00:12:52,070 --> 00:12:55,070
is just kind of like try this one I

00:12:53,630 --> 00:12:57,440
think it's a useful exercise to think

00:12:55,070 --> 00:12:58,790
about like what are the core values for

00:12:57,440 --> 00:13:00,230
the things that I implement in the

00:12:58,790 --> 00:13:01,850
things that are important to me because

00:13:00,230 --> 00:13:03,290
that's probably why they're important to

00:13:01,850 --> 00:13:05,300
you that's probably why you gravitated

00:13:03,290 --> 00:13:07,730
them at some level um in what I see in

00:13:05,300 --> 00:13:10,130
Scala is certainly expressiveness

00:13:07,730 --> 00:13:12,620
writing is very important I think you've

00:13:10,130 --> 00:13:14,270
got to put interoperability way way way

00:13:12,620 --> 00:13:16,010
up there I mean the whole point of Scala

00:13:14,270 --> 00:13:18,230
is to be able to interact with the Java

00:13:16,010 --> 00:13:19,880
ecosystem at large that's a very core

00:13:18,230 --> 00:13:21,500
principle to me that's a core value I

00:13:19,880 --> 00:13:22,550
mean I remember actually seeing what I

00:13:21,500 --> 00:13:25,580
think must have been one of Martin's

00:13:22,550 --> 00:13:29,810
very first talks on Scala um back and I

00:13:25,580 --> 00:13:31,070
think 2004 and the this was a big deal

00:13:29,810 --> 00:13:34,760
the ability to reuse

00:13:31,070 --> 00:13:36,290
java classes in a language that provided

00:13:34,760 --> 00:13:37,820
integrity and robustness and

00:13:36,290 --> 00:13:39,650
expressiveness and composability

00:13:37,820 --> 00:13:41,000
and I'm not saying that Scala doesn't

00:13:39,650 --> 00:13:43,460
care about the things that that aren't

00:13:41,000 --> 00:13:45,200
bolded here but just if it has to choose

00:13:43,460 --> 00:13:46,040
this is what scholars gonna choose I

00:13:45,200 --> 00:13:48,110
thought was very interesting because you

00:13:46,040 --> 00:13:49,730
saw the panel last night where Martin

00:13:48,110 --> 00:13:51,860
was being asked what is your kind of

00:13:49,730 --> 00:13:54,080
vision for Scala going forward and it

00:13:51,860 --> 00:13:55,340
wants to make it easier to write robust

00:13:54,080 --> 00:13:58,280
programs it's really about writing

00:13:55,340 --> 00:13:59,930
robust software and I thought it was

00:13:58,280 --> 00:14:03,650
interesting too that eliminating some of

00:13:59,930 --> 00:14:04,910
the things like the XML in URLs I did

00:14:03,650 --> 00:14:06,020
not know that XML literals but

00:14:04,910 --> 00:14:07,310
eliminating some of things that we no

00:14:06,020 --> 00:14:09,920
longer need because they're not gonna

00:14:07,310 --> 00:14:13,160
serve these values I'm not sure where

00:14:09,920 --> 00:14:17,630
xml literals fall on the values and the

00:14:13,160 --> 00:14:19,460
moon Ranelagh okay so the there the

00:14:17,630 --> 00:14:21,170
challenge for that we have in system

00:14:19,460 --> 00:14:22,070
software that is not necessarily a

00:14:21,170 --> 00:14:23,510
challenge that you might have in

00:14:22,070 --> 00:14:26,060
software your writing but in the in in

00:14:23,510 --> 00:14:28,790
the software in the system software that

00:14:26,060 --> 00:14:31,310
is beneath you or beneath us that is

00:14:28,790 --> 00:14:33,860
that that is that is say it comprises

00:14:31,310 --> 00:14:36,380
the the foundation upon which we build

00:14:33,860 --> 00:14:38,150
the values are dictated by those who

00:14:36,380 --> 00:14:40,520
will use the software it's dictated by

00:14:38,150 --> 00:14:43,010
the expectations like the the an

00:14:40,520 --> 00:14:45,920
operating system that for example does

00:14:43,010 --> 00:14:50,750
not hold of the values around say

00:14:45,920 --> 00:14:52,280
robustness or safety or or security that

00:14:50,750 --> 00:14:53,960
operating system is one that is not long

00:14:52,280 --> 00:14:55,370
for this universe because you're not

00:14:53,960 --> 00:14:57,740
gonna want to use it no one wants to

00:14:55,370 --> 00:14:58,940
have an operating system that panics on

00:14:57,740 --> 00:15:00,620
them no one wants have an operating

00:14:58,940 --> 00:15:01,640
system and our expectations for the

00:15:00,620 --> 00:15:04,250
operon system and for system software

00:15:01,640 --> 00:15:07,520
are very very very high and rightfully

00:15:04,250 --> 00:15:08,840
so they should be high on and so in an

00:15:07,520 --> 00:15:09,950
in particular if there are certain

00:15:08,840 --> 00:15:12,110
values that if your system software

00:15:09,950 --> 00:15:14,240
doesn't have it your software can't have

00:15:12,110 --> 00:15:16,370
it and we are learning this the hard way

00:15:14,240 --> 00:15:19,610
because these values go even deeper into

00:15:16,370 --> 00:15:22,760
security right I mean 2018 has been my

00:15:19,610 --> 00:15:25,580
Anna's horrible us because of and it was

00:15:22,760 --> 00:15:27,440
it was on you know January 2nd of 2018

00:15:25,580 --> 00:15:29,060
when I'm looking at this hacker news

00:15:27,440 --> 00:15:30,350
story that someone trying to kind of

00:15:29,060 --> 00:15:32,300
reverse engineer some patches that are

00:15:30,350 --> 00:15:33,530
being floated against the Linux kernel

00:15:32,300 --> 00:15:36,230
thinking there may be a really serious

00:15:33,530 --> 00:15:38,060
security vulnerability here with Intel

00:15:36,230 --> 00:15:41,330
and the US and that was the beginning of

00:15:38,060 --> 00:15:45,080
the end for my 2018 because 2018 has

00:15:41,330 --> 00:15:47,690
taught us that that security what was

00:15:45,080 --> 00:15:49,519
ultimately subservient to performance in

00:15:47,690 --> 00:15:50,959
the design of the microprocessor and we

00:15:49,519 --> 00:15:52,700
were all complicit in that by the way

00:15:50,959 --> 00:15:54,260
like what's not it's easy to kind of

00:15:52,700 --> 00:15:56,510
like blame Intel for that but the

00:15:54,260 --> 00:15:58,310
reality was we were all complicit in

00:15:56,510 --> 00:16:00,950
that we that's what we demanded the

00:15:58,310 --> 00:16:04,579
problem is we discovered that that that

00:16:00,950 --> 00:16:07,070
very lowest substrate because it chose

00:16:04,579 --> 00:16:09,769
performance over security at some very

00:16:07,070 --> 00:16:11,690
key and implicit junctures we ended up

00:16:09,769 --> 00:16:13,070
with a substrate that self above it in

00:16:11,690 --> 00:16:16,459
the operating system the system software

00:16:13,070 --> 00:16:19,010
that now lost security as a value it

00:16:16,459 --> 00:16:22,010
doesn't matter how much how dear you

00:16:19,010 --> 00:16:24,079
hold security if you have

00:16:22,010 --> 00:16:27,290
hyper-threading enabled doesn't matter

00:16:24,079 --> 00:16:30,980
because because the hyper threading

00:16:27,290 --> 00:16:32,600
itself is not secure or it doesn't

00:16:30,980 --> 00:16:34,010
matter in if you don't have kernel page

00:16:32,600 --> 00:16:35,420
table isolation doesn't matter how dear

00:16:34,010 --> 00:16:38,360
you hold it because now you are

00:16:35,420 --> 00:16:40,250
vulnerable to an attack but from a

00:16:38,360 --> 00:16:42,260
substrate that ultimately chose

00:16:40,250 --> 00:16:44,600
something else over over security and

00:16:42,260 --> 00:16:47,300
this is very painful for us it's very

00:16:44,600 --> 00:16:48,950
painful when you're when the the

00:16:47,300 --> 00:16:50,360
infrastructure the layer that you depend

00:16:48,950 --> 00:16:52,640
on because we all depend on layers

00:16:50,360 --> 00:16:54,890
beneath us when the layer that kind of a

00:16:52,640 --> 00:16:56,390
jack-in-the-box hey surprise I don't

00:16:54,890 --> 00:16:58,040
hold the values you thought I held it's

00:16:56,390 --> 00:17:00,800
like okay well I guess I will cancel

00:16:58,040 --> 00:17:03,170
what I was gonna do for 2018 and spend

00:17:00,800 --> 00:17:05,660
the time getting the system back to

00:17:03,170 --> 00:17:08,059
where I thought it was on on December

00:17:05,660 --> 00:17:09,230
31st 2017 which is what we have

00:17:08,059 --> 00:17:11,329
effectively done it's been it's been

00:17:09,230 --> 00:17:14,929
very frustrating in that regard but

00:17:11,329 --> 00:17:17,449
that's a four system software we have to

00:17:14,929 --> 00:17:19,610
hold these values it is essential so

00:17:17,449 --> 00:17:22,100
these are the values that we demand of

00:17:19,610 --> 00:17:24,860
system software um it's got to be

00:17:22,100 --> 00:17:26,449
compatible right you you're not gonna an

00:17:24,860 --> 00:17:28,100
upgrade to a microprocessor to an

00:17:26,449 --> 00:17:30,050
operating system to a database when that

00:17:28,100 --> 00:17:31,280
breaks your software that's not okay

00:17:30,050 --> 00:17:32,840
it's got to be developed we have to

00:17:31,280 --> 00:17:34,669
understand what's going on why things

00:17:32,840 --> 00:17:35,929
are failing you've got to have integrity

00:17:34,669 --> 00:17:38,179
as a core value you can't have data

00:17:35,929 --> 00:17:39,830
corruption um you need performance I

00:17:38,179 --> 00:17:41,270
really wish we get just like can we just

00:17:39,830 --> 00:17:43,309
get rid of performance then it'll be

00:17:41,270 --> 00:17:45,530
fine and we don't need performance you

00:17:43,309 --> 00:17:46,730
know a the the late great Roger Faulkner

00:17:45,530 --> 00:17:48,440
I worked with at Sun Microsystems for a

00:17:46,730 --> 00:17:51,050
long time which said that performance is

00:17:48,440 --> 00:17:52,250
the root of all evil and and he's right

00:17:51,050 --> 00:17:55,010
performance is the root of all evil if

00:17:52,250 --> 00:17:57,429
we are are happy with our systems not

00:17:55,010 --> 00:17:58,630
performing well things get a lot easier

00:17:57,429 --> 00:17:59,770
but if

00:17:58,630 --> 00:18:01,360
that's not we don't want to do that

00:17:59,770 --> 00:18:03,190
right performance is important

00:18:01,360 --> 00:18:04,810
performance drives right to the

00:18:03,190 --> 00:18:07,750
economics of what we're doing it's not

00:18:04,810 --> 00:18:09,460
okay to be wasting cycles that we don't

00:18:07,750 --> 00:18:11,830
need to waste we actually have to have

00:18:09,460 --> 00:18:13,420
performance as a constraint and this can

00:18:11,830 --> 00:18:14,890
be brutal by the way especially when the

00:18:13,420 --> 00:18:16,540
numbers are small it's like man this

00:18:14,890 --> 00:18:19,690
thing is like 2% faster than you guys

00:18:16,540 --> 00:18:21,010
just like that 2% is brutal to get out

00:18:19,690 --> 00:18:22,660
of but it's important it should be

00:18:21,010 --> 00:18:24,250
important it's important that we hold

00:18:22,660 --> 00:18:25,270
that value for our system software it's

00:18:24,250 --> 00:18:27,340
got to be resilient it's got to be

00:18:25,270 --> 00:18:30,040
robust it's got to be safe it's got to

00:18:27,340 --> 00:18:30,910
be secure we that that's paramount that

00:18:30,040 --> 00:18:33,130
it's secure

00:18:30,910 --> 00:18:34,960
it's be stable it's gonna be thorough in

00:18:33,130 --> 00:18:37,000
that our system software our

00:18:34,960 --> 00:18:39,070
microprocessors our operating systems

00:18:37,000 --> 00:18:41,500
even our databases we need them to

00:18:39,070 --> 00:18:43,480
support a wide range of things they

00:18:41,500 --> 00:18:44,650
these are not purpose-built things we

00:18:43,480 --> 00:18:45,850
can't afford for them to be

00:18:44,650 --> 00:18:48,340
purpose-built things they have to be

00:18:45,850 --> 00:18:49,630
generic that generic ism requires a

00:18:48,340 --> 00:18:51,490
thoroughness that is actually really

00:18:49,630 --> 00:18:53,200
challenging we got to be transparent we

00:18:51,490 --> 00:18:55,060
got any kind of the day of proprietary

00:18:53,200 --> 00:18:57,010
glop well it was but it behind us and

00:18:55,060 --> 00:18:59,620
then that's actually this is coming back

00:18:57,010 --> 00:19:01,090
actually with the whole cloud thing so

00:18:59,620 --> 00:19:02,290
I'm we work for a cloud cloud provider

00:19:01,090 --> 00:19:04,390
although our software's all open-source

00:19:02,290 --> 00:19:06,910
but right now us compute is being

00:19:04,390 --> 00:19:09,070
reprioritized by the by the cloud

00:19:06,910 --> 00:19:10,540
providers so transparency may be fading

00:19:09,070 --> 00:19:12,730
as a value I hope that we'd go and

00:19:10,540 --> 00:19:14,410
demand that it back again okay so I just

00:19:12,730 --> 00:19:16,510
wanna remind you with the platform that

00:19:14,410 --> 00:19:18,520
the core values of C are so we're just

00:19:16,510 --> 00:19:21,820
gonna kinda do this all right so that's

00:19:18,520 --> 00:19:23,830
what we demand that's C what we demand C

00:19:21,820 --> 00:19:27,340
it's like right eye left eye right eye

00:19:23,830 --> 00:19:29,110
left eye right eye left eye all right

00:19:27,340 --> 00:19:33,150
there's only one value these things have

00:19:29,110 --> 00:19:36,010
in common performance that's it

00:19:33,150 --> 00:19:38,560
everything else and this is actually and

00:19:36,010 --> 00:19:40,660
you know what Roger accepted Roger

00:19:38,560 --> 00:19:41,560
passed away a couple years ago Roger you

00:19:40,660 --> 00:19:42,610
are haunting us from the grave because

00:19:41,560 --> 00:19:43,810
you are actually all right Ron

00:19:42,610 --> 00:19:48,010
performance actually is the root of all

00:19:43,810 --> 00:19:50,080
evil here because if it performance

00:19:48,010 --> 00:19:51,430
ultimately in terms of the values we

00:19:50,080 --> 00:19:53,050
demand for system software we do demand

00:19:51,430 --> 00:19:55,510
performance over all else that is the

00:19:53,050 --> 00:19:58,810
reality we might not like that but we

00:19:55,510 --> 00:20:00,760
cannot accept a system that is better in

00:19:58,810 --> 00:20:03,700
all of these other attributes but

00:20:00,760 --> 00:20:05,890
suffers in terms of performance and for

00:20:03,700 --> 00:20:08,620
evidence of that just look at history's

00:20:05,890 --> 00:20:10,330
graveyard of systems that did deliver

00:20:08,620 --> 00:20:12,400
and you will find people that that talk

00:20:10,330 --> 00:20:14,110
about you know capability based systems

00:20:12,400 --> 00:20:17,380
or micro no based systems or other other

00:20:14,110 --> 00:20:19,840
systems that ultimately fell down on

00:20:17,380 --> 00:20:20,950
this most important criteria and I say

00:20:19,840 --> 00:20:22,780
how you sort fork UNIX so I love my

00:20:20,950 --> 00:20:26,020
kernel so I'm not I'm not trying to pick

00:20:22,780 --> 00:20:27,640
I pick at wounds but performance

00:20:26,020 --> 00:20:30,640
ultimately is is the most important

00:20:27,640 --> 00:20:31,870
thing so that's C C is clearly I mean we

00:20:30,640 --> 00:20:32,650
kind of got in there with C but it's

00:20:31,870 --> 00:20:34,720
been really painful

00:20:32,650 --> 00:20:38,560
well what about C++ all right well this

00:20:34,720 --> 00:20:40,660
might be for C++ so so C++ okay

00:20:38,560 --> 00:20:42,280
so we're definitely gonna get rid of

00:20:40,660 --> 00:20:43,780
simplicity I don't have a way of saying

00:20:42,280 --> 00:20:46,300
there should be a way of like I need a

00:20:43,780 --> 00:20:48,040
strikeout to be like I hate simplicity

00:20:46,300 --> 00:20:49,300
like that's like I am actually anti

00:20:48,040 --> 00:20:51,940
simplicity cross that one out

00:20:49,300 --> 00:20:55,930
so see West boss is like anti simplicity

00:20:51,940 --> 00:20:58,810
um and then I also decided that again in

00:20:55,930 --> 00:21:01,980
my kind of as long as I am issuing

00:20:58,810 --> 00:21:04,450
fatwas against programming languages I I

00:21:01,980 --> 00:21:06,070
decided that expressiveness is important

00:21:04,450 --> 00:21:09,670
interoperability is actually less

00:21:06,070 --> 00:21:14,410
important to C++ C++ has actually made

00:21:09,670 --> 00:21:16,180
choices yes C++ is a better C and yes I

00:21:14,410 --> 00:21:17,320
think it can still compile C although

00:21:16,180 --> 00:21:20,230
that becomes less and less important

00:21:17,320 --> 00:21:22,030
over time but the C++ struggles with

00:21:20,230 --> 00:21:23,650
interoperability at a deeper level where

00:21:22,030 --> 00:21:25,990
you have components that are written in

00:21:23,650 --> 00:21:28,330
non C++ trying to cooperate with

00:21:25,990 --> 00:21:31,450
components that are written in C++ it is

00:21:28,330 --> 00:21:32,920
possible but very very painful and C++

00:21:31,450 --> 00:21:35,260
does not make it easy

00:21:32,920 --> 00:21:36,520
across the board I mean it starts with

00:21:35,260 --> 00:21:38,740
name mangling and gets much much worse

00:21:36,520 --> 00:21:41,680
it's really really painful to make

00:21:38,740 --> 00:21:43,540
software uh you have to design your C++

00:21:41,680 --> 00:21:44,650
to explicitly interoperate with C which

00:21:43,540 --> 00:21:46,120
is very frustrating because you have

00:21:44,650 --> 00:21:47,680
these software out there that it's

00:21:46,120 --> 00:21:48,790
actually only in C++ is gonna be very

00:21:47,680 --> 00:21:52,120
hard to actually get a dinner operate

00:21:48,790 --> 00:21:53,710
with C so this gives us the this this

00:21:52,120 --> 00:21:57,520
tremendous divide this tremendous

00:21:53,710 --> 00:21:59,170
disconnect between the values that that

00:21:57,520 --> 00:22:00,730
the system software programming

00:21:59,170 --> 00:22:04,510
languages have had in a way performance

00:22:00,730 --> 00:22:05,980
and then nothing else um and the values

00:22:04,510 --> 00:22:07,480
that we need for the software we have

00:22:05,980 --> 00:22:11,460
have all these other values now we've

00:22:07,480 --> 00:22:15,250
gotten there um it's been a long painful

00:22:11,460 --> 00:22:17,620
arduous path the reality is our system

00:22:15,250 --> 00:22:20,140
software does work it is actually it

00:22:17,620 --> 00:22:22,840
does have all these other values it does

00:22:20,140 --> 00:22:25,600
it is stable it is sick it is I mean it

00:22:22,840 --> 00:22:26,230
is relatively stable it is relatively

00:22:25,600 --> 00:22:27,910
secure

00:22:26,230 --> 00:22:30,790
or I thought it was secured on on

00:22:27,910 --> 00:22:32,679
December 31st 2017 anyway it is

00:22:30,790 --> 00:22:35,830
relatively safe relatively robust does

00:22:32,679 --> 00:22:38,919
perform well but we've gotten there the

00:22:35,830 --> 00:22:41,650
painful way it has taken us a very long

00:22:38,919 --> 00:22:43,330
time we've written a lot of bespoke

00:22:41,650 --> 00:22:47,470
tooling now we've also gotten very good

00:22:43,330 --> 00:22:49,690
at it I'm good at writing my C does not

00:22:47,470 --> 00:22:51,700
it is not going to dereference memory it

00:22:49,690 --> 00:22:53,770
does not have that is not a failure mode

00:22:51,700 --> 00:22:55,179
that I have in the C that I write

00:22:53,770 --> 00:22:56,559
because I've been doing this for a long

00:22:55,179 --> 00:22:58,330
time and I know how to malloc and free

00:22:56,559 --> 00:23:00,549
and I know how to create dynamic data

00:22:58,330 --> 00:23:02,860
structures and do that do so completely

00:23:00,549 --> 00:23:03,250
safely and I can very quickly that's

00:23:02,860 --> 00:23:06,040
good

00:23:03,250 --> 00:23:08,290
it was very painful and the truth is it

00:23:06,040 --> 00:23:10,419
is very much dependent on me the

00:23:08,290 --> 00:23:13,299
programmer and my reviewers and my

00:23:10,419 --> 00:23:15,640
testing and so on there's no net that is

00:23:13,299 --> 00:23:17,169
provided by the language at all the

00:23:15,640 --> 00:23:19,090
language is allowing me to do whatever I

00:23:17,169 --> 00:23:20,860
want it's you know it's like a

00:23:19,090 --> 00:23:22,870
Montessori Preschool as long as we all

00:23:20,860 --> 00:23:27,190
worship at the old or at the altar of

00:23:22,870 --> 00:23:28,419
performance um so the you know the

00:23:27,190 --> 00:23:30,610
question is like it can we do better

00:23:28,419 --> 00:23:32,620
because we've succeeded despite the

00:23:30,610 --> 00:23:33,970
language not because of it is there an

00:23:32,620 --> 00:23:36,700
opportunity to better and I was actually

00:23:33,970 --> 00:23:40,570
at the point where I was beginning to

00:23:36,700 --> 00:23:42,309
despair a little bit where I had and yes

00:23:40,570 --> 00:23:44,020
there are the language to come out you

00:23:42,309 --> 00:23:48,280
may be familiar with giant because of

00:23:44,020 --> 00:23:50,290
nodejs I had this like great belief that

00:23:48,280 --> 00:23:53,380
no js' was going to be what would save

00:23:50,290 --> 00:23:54,850
us all um yeah and if you would be like

00:23:53,380 --> 00:23:56,620
no that's just JavaScript I'm like I

00:23:54,850 --> 00:23:58,360
know I know it's just Josh but I wanted

00:23:56,620 --> 00:24:00,130
so much better I wanted so much better

00:23:58,360 --> 00:24:01,929
for JavaScript it wasn't gonna be

00:24:00,130 --> 00:24:03,309
JavaScript it was gonna be a dynamic

00:24:01,929 --> 00:24:05,530
language in which we could write robust

00:24:03,309 --> 00:24:07,299
server-side software and it's just

00:24:05,530 --> 00:24:09,669
JavaScript it's just JavaScript dude I

00:24:07,299 --> 00:24:11,410
it is just JavaScript and and what I

00:24:09,669 --> 00:24:14,169
mean by that is the values that

00:24:11,410 --> 00:24:15,700
JavaScript has aren't bad values but

00:24:14,169 --> 00:24:17,350
they are not the values that we have for

00:24:15,700 --> 00:24:20,080
system software that defies JavaScript

00:24:17,350 --> 00:24:21,429
as is really around velocity and

00:24:20,080 --> 00:24:23,440
especially approachability we want as

00:24:21,429 --> 00:24:25,330
many people as possible to be able to

00:24:23,440 --> 00:24:26,860
write JavaScript and that is not that's

00:24:25,330 --> 00:24:28,900
I think that's a great ambition and

00:24:26,860 --> 00:24:30,820
there's nothing wrong with that value it

00:24:28,900 --> 00:24:33,160
is antithetical to system software

00:24:30,820 --> 00:24:34,720
because that does become in tension and

00:24:33,160 --> 00:24:38,530
suck if we want to choose an abstraction

00:24:34,720 --> 00:24:39,789
that allows ten thousand more people to

00:24:38,530 --> 00:24:41,289
write software but

00:24:39,789 --> 00:24:42,580
that soft word will be rife with edge

00:24:41,289 --> 00:24:45,429
conditions that they will probably never

00:24:42,580 --> 00:24:47,200
encounter should we do it if your first

00:24:45,429 --> 00:24:47,590
value is robustus you say no of course

00:24:47,200 --> 00:24:49,989
not

00:24:47,590 --> 00:24:52,479
if your first value is approachability

00:24:49,989 --> 00:24:53,619
and and growth then yes of course you

00:24:52,479 --> 00:24:56,229
should and that is the fundamental

00:24:53,619 --> 00:24:59,139
tension for us um so I want us to do

00:24:56,229 --> 00:25:01,149
better um I I was I was beginning to

00:24:59,139 --> 00:25:02,489
despair because I didn't see a language

00:25:01,149 --> 00:25:05,320
that was that was really offering

00:25:02,489 --> 00:25:08,739
fundamentally different values and then

00:25:05,320 --> 00:25:10,139
along came rust and now along came rust

00:25:08,739 --> 00:25:12,669
rust has been around for a long time

00:25:10,139 --> 00:25:16,389
started actually a long long long time

00:25:12,669 --> 00:25:18,580
ago started in like 2006 or just a

00:25:16,389 --> 00:25:21,159
little bit later but rust has kind of

00:25:18,580 --> 00:25:23,590
has grown over time and I like I think

00:25:21,159 --> 00:25:26,799
many people have been increasingly rust

00:25:23,590 --> 00:25:30,249
curious over the years right and my my

00:25:26,799 --> 00:25:32,679
rust curiosity has has grown over the

00:25:30,249 --> 00:25:35,710
years because rust has this incredibly

00:25:32,679 --> 00:25:39,340
interesting system of ownership where

00:25:35,710 --> 00:25:42,159
whereby you are the programmer are going

00:25:39,340 --> 00:25:45,909
to work with the compiler to figure out

00:25:42,159 --> 00:25:48,279
who owns what when who owns what piece

00:25:45,909 --> 00:25:50,409
of memory the compiler is gonna restrict

00:25:48,279 --> 00:25:51,820
what you do and you're not going to

00:25:50,409 --> 00:25:53,259
burst into tears when it does it that's

00:25:51,820 --> 00:25:55,749
like that that's the bargain that you're

00:25:53,259 --> 00:25:58,539
gonna have with the compiler as a result

00:25:55,749 --> 00:26:00,369
the compiler knows when things need to

00:25:58,539 --> 00:26:02,739
be allocated and when things need to be

00:26:00,369 --> 00:26:04,029
de-allocated when they're that are still

00:26:02,739 --> 00:26:05,080
reference to this and when there is no

00:26:04,029 --> 00:26:08,049
longer reference to and you're gonna

00:26:05,080 --> 00:26:10,690
work with it and as a result you get the

00:26:08,049 --> 00:26:13,239
denied then the dynamicism that you get

00:26:10,690 --> 00:26:14,739
in a garbage collected language but the

00:26:13,239 --> 00:26:16,960
performance of explicit memory

00:26:14,739 --> 00:26:20,440
management and this is amazing and

00:26:16,960 --> 00:26:22,419
importantly unlike see rust is highly

00:26:20,440 --> 00:26:23,769
composable so the big problem with see I

00:26:22,419 --> 00:26:26,259
mean this is always the problem right

00:26:23,769 --> 00:26:28,119
it's not it's not you it's the other

00:26:26,259 --> 00:26:29,979
person like I know how to write memory

00:26:28,119 --> 00:26:31,599
say I know how to actually deal with

00:26:29,979 --> 00:26:33,970
memory safely but calling you to a

00:26:31,599 --> 00:26:35,499
library that jerk no I don't know how to

00:26:33,970 --> 00:26:36,249
do a memory safely or but it's even

00:26:35,499 --> 00:26:38,200
worse than that right

00:26:36,249 --> 00:26:40,450
because what where things get dropped is

00:26:38,200 --> 00:26:42,039
in the boundary is in the the library is

00:26:40,450 --> 00:26:43,809
allocating something on your behalf that

00:26:42,039 --> 00:26:45,940
you are explicitly or implicitly

00:26:43,809 --> 00:26:47,710
expected to free or deallocate you lose

00:26:45,940 --> 00:26:49,899
track of that you've got a memory leak

00:26:47,710 --> 00:26:52,179
memory corruption are worse it is very

00:26:49,899 --> 00:26:52,960
hard even if you're very good at seeing

00:26:52,179 --> 00:26:55,840
a between here

00:26:52,960 --> 00:26:57,070
career it's very hard to compose it so

00:26:55,840 --> 00:26:59,590
what we end up doing is having these

00:26:57,070 --> 00:27:01,539
very minimal kind of structures where we

00:26:59,590 --> 00:27:03,580
embed these things in larger structures

00:27:01,539 --> 00:27:06,399
and we're able to do so totally safely

00:27:03,580 --> 00:27:07,690
but ultimately sub-optimally rust

00:27:06,399 --> 00:27:10,179
actually allows us to have higher

00:27:07,690 --> 00:27:12,340
performing primitives and so as a result

00:27:10,179 --> 00:27:14,679
and I'll come back to the rust values

00:27:12,340 --> 00:27:16,059
but in in my experience and this is my

00:27:14,679 --> 00:27:18,010
experience I'm not trying to draw a

00:27:16,059 --> 00:27:19,779
large conclusions this is a bit of

00:27:18,010 --> 00:27:21,580
software that is what I was alluding to

00:27:19,779 --> 00:27:24,279
us on in the panel that I'd written in C

00:27:21,580 --> 00:27:26,380
and I'd kind of written in you know hand

00:27:24,279 --> 00:27:28,090
optimized C I went to rewrite it and

00:27:26,380 --> 00:27:30,010
rust because I was increasingly rust

00:27:28,090 --> 00:27:32,429
curious and wanted to finally say that

00:27:30,010 --> 00:27:34,690
rust curiosity by writing some real rust

00:27:32,429 --> 00:27:36,909
after a lot of back and forth of the

00:27:34,690 --> 00:27:39,370
compiler some tears that I wiped away um

00:27:36,909 --> 00:27:40,539
do it like let the wookie win is my

00:27:39,370 --> 00:27:43,360
advice when you're dealing with rust

00:27:40,539 --> 00:27:45,429
that what you want to rust wants you to

00:27:43,360 --> 00:27:47,110
do things certain ways and you're much

00:27:45,429 --> 00:27:48,940
better off doing things the way rust

00:27:47,110 --> 00:27:50,799
wants you to do it so I did it in a way

00:27:48,940 --> 00:27:52,299
that was obviously suboptimal but fine I

00:27:50,799 --> 00:27:53,440
can get it to compile I just gotta like

00:27:52,299 --> 00:27:54,970
I don't even care about performance

00:27:53,440 --> 00:27:57,309
anymore just let me get this thing

00:27:54,970 --> 00:27:59,080
working and then and I know it's gonna

00:27:57,309 --> 00:28:02,559
perform terribly and then I ran it and

00:27:59,080 --> 00:28:05,289
it outperformed my C it's like what how

00:28:02,559 --> 00:28:07,090
did that happen how and I took it apart

00:28:05,289 --> 00:28:08,710
and how did I outperform I see well this

00:28:07,090 --> 00:28:11,679
particular software spends all of its

00:28:08,710 --> 00:28:13,779
time rebalancing a binary tree and in

00:28:11,679 --> 00:28:15,010
rust the primitive that I was using was

00:28:13,779 --> 00:28:16,330
an AVL tree which is the thing we've

00:28:15,010 --> 00:28:17,590
used for ever and I've got a very robust

00:28:16,330 --> 00:28:19,330
AVL tree implementation that I've used

00:28:17,590 --> 00:28:21,070
in rust you don't have to AVL tree

00:28:19,330 --> 00:28:23,200
actually the betray B tree you may

00:28:21,070 --> 00:28:25,000
remember from databases right but the

00:28:23,200 --> 00:28:26,470
rust observation is actually with the

00:28:25,000 --> 00:28:28,510
memory hierarchy being what it is a

00:28:26,470 --> 00:28:30,460
beech tree actually makes sense just in

00:28:28,510 --> 00:28:32,020
software that's not talking to disk you

00:28:30,460 --> 00:28:33,610
can view DRAM as the disk that you're

00:28:32,020 --> 00:28:35,020
talking to and a beech tree actually

00:28:33,610 --> 00:28:36,700
makes a lot more sense beech trees a

00:28:35,020 --> 00:28:38,799
pain in the butt to implement but with

00:28:36,700 --> 00:28:40,390
rust you can just use it you don't have

00:28:38,799 --> 00:28:42,130
to actually know any of the

00:28:40,390 --> 00:28:45,250
implementation details of it and as a

00:28:42,130 --> 00:28:47,110
result it outperformed my safe in large

00:28:45,250 --> 00:28:48,250
part because the data structure but also

00:28:47,110 --> 00:28:50,740
because there are optimizations that

00:28:48,250 --> 00:28:52,000
Russ can make that C could not make and

00:28:50,740 --> 00:28:53,860
then of course it was like wow that's a

00:28:52,000 --> 00:28:55,149
GCC issue how about clang I'm like clang

00:28:53,860 --> 00:28:57,190
is not gonna fundamentally change the

00:28:55,149 --> 00:28:58,870
physics of my C which it doesn't like

00:28:57,190 --> 00:29:01,779
clang makes it a little bit better this

00:28:58,870 --> 00:29:03,039
is the lower is better here um so this

00:29:01,779 --> 00:29:05,889
was really interesting to me and it

00:29:03,039 --> 00:29:06,490
shows the the kind of the core values of

00:29:05,889 --> 00:29:09,040
Russ

00:29:06,490 --> 00:29:10,240
um so yes performance it has to be

00:29:09,040 --> 00:29:11,440
performance it kind of the epicenter of

00:29:10,240 --> 00:29:13,600
the universe but you get that

00:29:11,440 --> 00:29:15,910
composability the expressiveness that

00:29:13,600 --> 00:29:18,010
you in the scala world have had for a

00:29:15,910 --> 00:29:20,140
long time we now get this to have this

00:29:18,010 --> 00:29:21,700
at a much lower level we get safety we

00:29:20,140 --> 00:29:24,460
get security we get rigor we get

00:29:21,700 --> 00:29:26,440
robustness we get integrity and very

00:29:24,460 --> 00:29:27,580
importantly we get interoperability and

00:29:26,440 --> 00:29:28,960
this is actually the difference between

00:29:27,580 --> 00:29:31,570
rust and other languages that look

00:29:28,960 --> 00:29:34,030
somewhat similar is rusts emphasis on

00:29:31,570 --> 00:29:35,530
interoperability rust does not aspire to

00:29:34,030 --> 00:29:37,690
rewrite everything in rust rust is

00:29:35,530 --> 00:29:39,790
trying to cooperate with those systems

00:29:37,690 --> 00:29:43,120
that already exist so it's not just

00:29:39,790 --> 00:29:45,520
ownership um the I know that you know

00:29:43,120 --> 00:29:47,440
and you would be right to be annoyed

00:29:45,520 --> 00:29:49,390
when a bunch of systems people discover

00:29:47,440 --> 00:29:52,179
algebraic types like it's a brand new

00:29:49,390 --> 00:29:54,880
invention it's like hey I just found out

00:29:52,179 --> 00:29:56,679
like I'm getting clean water out of the

00:29:54,880 --> 00:29:59,410
tap I don't have to boy you're just like

00:29:56,679 --> 00:30:01,300
yes you knucklehead like yes you clean

00:29:59,410 --> 00:30:03,760
water it's valuable like your babies are

00:30:01,300 --> 00:30:05,410
no longer dying it's amazing um but

00:30:03,760 --> 00:30:07,300
algebraic types okay and I knew about

00:30:05,410 --> 00:30:09,010
algebraic types in the abstract but to

00:30:07,300 --> 00:30:11,110
actually be able to see how algebraic

00:30:09,010 --> 00:30:13,179
types can be used for really concise

00:30:11,110 --> 00:30:14,320
error handling you can make much more

00:30:13,179 --> 00:30:15,460
robust stuff and again you know this I'm

00:30:14,320 --> 00:30:16,179
actually I'm literally preaching to the

00:30:15,460 --> 00:30:18,429
choir so what next

00:30:16,179 --> 00:30:20,230
um but algebraic types are amazing and

00:30:18,429 --> 00:30:21,550
they are amazing for reasons beyond what

00:30:20,230 --> 00:30:24,610
I appreciated um

00:30:21,550 --> 00:30:26,950
hygienic macros true story I did not

00:30:24,610 --> 00:30:28,600
know how to spell hygienic before rust

00:30:26,950 --> 00:30:29,620
hygienic is kind of a pain in the butt

00:30:28,600 --> 00:30:30,220
you got that second eye in there like

00:30:29,620 --> 00:30:33,160
what's that doing there

00:30:30,220 --> 00:30:35,140
but the the eye I have been so far from

00:30:33,160 --> 00:30:35,910
hygienic macros that I literally didn't

00:30:35,140 --> 00:30:39,040
know how to spell it

00:30:35,910 --> 00:30:41,380
now macros are a key for us and C we use

00:30:39,040 --> 00:30:42,160
the C preprocessor all the time I could

00:30:41,380 --> 00:30:43,059
not have written the code that I've

00:30:42,160 --> 00:30:44,860
written in my career without C

00:30:43,059 --> 00:30:46,360
preprocessor macros are very important

00:30:44,860 --> 00:30:47,530
the macros and rust are amazing the

00:30:46,360 --> 00:30:48,820
foreign function interface is what

00:30:47,530 --> 00:30:50,679
allows it to interact with C based

00:30:48,820 --> 00:30:52,000
systems it's outstanding and then

00:30:50,679 --> 00:30:54,790
there's this unsafe keyword which is

00:30:52,000 --> 00:30:57,010
this kind of get-out-of-jail kind of

00:30:54,790 --> 00:30:59,190
like a furlough program you get to go

00:30:57,010 --> 00:31:03,700
away a conjugal visit with your memory

00:30:59,190 --> 00:31:04,929
you don't actually um sometimes these

00:31:03,700 --> 00:31:06,070
metaphors occur to me on the fly and I

00:31:04,929 --> 00:31:07,059
realize like as it's going out of my

00:31:06,070 --> 00:31:08,410
mouth the other part of my brain is like

00:31:07,059 --> 00:31:09,610
no let's kind of let's pull that one

00:31:08,410 --> 00:31:11,110
back please pull them out here that

00:31:09,610 --> 00:31:12,550
one's gone all right fine never mind

00:31:11,110 --> 00:31:16,120
it's been it's been tweeted forget it um

00:31:12,550 --> 00:31:19,390
but the the unsafe keyword allows you to

00:31:16,120 --> 00:31:20,169
relax certain restrictions that Russ

00:31:19,390 --> 00:31:22,320
puts in place

00:31:20,169 --> 00:31:25,570
that allows you to then in very isolated

00:31:22,320 --> 00:31:27,309
parts actually leverage what you know of

00:31:25,570 --> 00:31:28,629
memory and to build even higher

00:31:27,309 --> 00:31:30,669
performing things better things but

00:31:28,629 --> 00:31:31,749
you've really can find that unsafety so

00:31:30,669 --> 00:31:33,999
I think actually unsafe keyword is

00:31:31,749 --> 00:31:35,350
terrific terrific community thriving

00:31:33,999 --> 00:31:37,239
ecosystem I mean there's a lot to love

00:31:35,350 --> 00:31:41,080
about it um so that's the promise of

00:31:37,239 --> 00:31:43,389
rust there there is uh it and I made

00:31:41,080 --> 00:31:44,919
made references last night but the

00:31:43,389 --> 00:31:47,350
beauty of rust is that it shifts the

00:31:44,919 --> 00:31:48,730
cognitive load back from software when

00:31:47,350 --> 00:31:50,950
it's running in production to the

00:31:48,730 --> 00:31:53,769
developer and development which is great

00:31:50,950 --> 00:31:55,389
news if you're me I think great is if

00:31:53,769 --> 00:31:56,350
you're us but it means if you're the

00:31:55,389 --> 00:31:58,059
developer and development you're like

00:31:56,350 --> 00:32:00,369
where did all this cognitive load come

00:31:58,059 --> 00:32:01,929
from like I I'm much more used to being

00:32:00,369 --> 00:32:03,429
able to just kind of like push it into

00:32:01,929 --> 00:32:04,720
production but I know there's a lot more

00:32:03,429 --> 00:32:06,879
cognitive load a lot more things you

00:32:04,720 --> 00:32:09,759
need to think about and Russ complains

00:32:06,879 --> 00:32:12,070
about things that seem very very very

00:32:09,759 --> 00:32:14,289
pedantic and it can take a while to

00:32:12,070 --> 00:32:15,940
realize that oh rest is right actually

00:32:14,289 --> 00:32:17,559
rust is right there's an actual real

00:32:15,940 --> 00:32:19,210
issue here I mean there are a couple

00:32:17,559 --> 00:32:20,980
instances where people are convinced

00:32:19,210 --> 00:32:22,269
they're having a fruitless argument with

00:32:20,980 --> 00:32:23,200
a compiler because the compiler is wrong

00:32:22,269 --> 00:32:25,090
and they realize the compiler is

00:32:23,200 --> 00:32:26,559
actually right so um it's a really

00:32:25,090 --> 00:32:28,809
interesting that regarding it restricts

00:32:26,559 --> 00:32:30,700
what we can do it can be very very

00:32:28,809 --> 00:32:32,100
frustrating this is a quote from from

00:32:30,700 --> 00:32:34,869
the programming rossbach which I love

00:32:32,100 --> 00:32:36,970
that they you have a period of intense

00:32:34,869 --> 00:32:38,320
arguing with a compiler at the end of

00:32:36,970 --> 00:32:40,119
which the code looks rather nice as if

00:32:38,320 --> 00:32:42,100
it'd been a breeze to write and runs

00:32:40,119 --> 00:32:44,200
beautifully but there's no way that code

00:32:42,100 --> 00:32:46,210
is like you don't get the screams of

00:32:44,200 --> 00:32:47,619
pain that the developer had in getting

00:32:46,210 --> 00:32:50,289
that that kind of beautiful code that

00:32:47,619 --> 00:32:52,779
beautiful artifact so the the the peril

00:32:50,289 --> 00:32:54,369
of rust um is that it's got less of an

00:32:52,779 --> 00:32:57,100
advantage I think when we are

00:32:54,369 --> 00:32:59,379
reimplemented extant systems so when the

00:32:57,100 --> 00:33:00,879
software already works it's less clear

00:32:59,379 --> 00:33:02,950
to me especially you've got multiple own

00:33:00,879 --> 00:33:04,330
data structures like an OS kernel um I

00:33:02,950 --> 00:33:05,830
think that's gonna be brutal for rust

00:33:04,330 --> 00:33:06,879
but there are a lot of opportunities for

00:33:05,830 --> 00:33:08,289
us and start to kind of speed through

00:33:06,879 --> 00:33:10,330
here at the end but there are a lot of

00:33:08,289 --> 00:33:12,009
opportunities for rust because of its

00:33:10,330 --> 00:33:14,259
interoperability as a core value god

00:33:12,009 --> 00:33:15,999
bless that interoperability and

00:33:14,259 --> 00:33:19,029
performance is a core value because it

00:33:15,999 --> 00:33:21,309
allows us to do with rust what we did

00:33:19,029 --> 00:33:24,759
with C which is take an iterative

00:33:21,309 --> 00:33:26,679
approach start rewriting things in rust

00:33:24,759 --> 00:33:28,299
we don't have to rewrite the entire

00:33:26,679 --> 00:33:29,619
world in rust we can start rewriting

00:33:28,299 --> 00:33:30,639
parts of Ross and I think this is

00:33:29,619 --> 00:33:32,470
something that the scholar community

00:33:30,639 --> 00:33:33,789
really gets from its interoperability

00:33:32,470 --> 00:33:35,259
with Java but I think we're

00:33:33,789 --> 00:33:37,359
really learning it in system software um

00:33:35,259 --> 00:33:39,549
and so I think it's it's a new dawn of

00:33:37,359 --> 00:33:41,499
development in that regard the system is

00:33:39,549 --> 00:33:42,549
obviously much they're much broader than

00:33:41,499 --> 00:33:43,779
just the operating system there are a

00:33:42,549 --> 00:33:45,789
lot of use global components that are a

00:33:43,779 --> 00:33:47,350
natural fit for rust if I were writing

00:33:45,789 --> 00:33:49,539
system D today I mean I didn't write

00:33:47,350 --> 00:33:51,639
system B but if one were right actually

00:33:49,539 --> 00:33:54,070
mentioned system B if one were writing a

00:33:51,639 --> 00:33:57,720
user level facility to manage software

00:33:54,070 --> 00:34:00,009
as a service I would write that in rust

00:33:57,720 --> 00:34:01,899
absolutely and in particular just to

00:34:00,009 --> 00:34:03,519
close with the other body of software

00:34:01,899 --> 00:34:05,470
that I really want to see rewritten is

00:34:03,519 --> 00:34:06,729
the software that you can't see and I

00:34:05,470 --> 00:34:07,690
can't see and none of us can see the

00:34:06,729 --> 00:34:10,809
software that works beneath us is

00:34:07,690 --> 00:34:12,970
firmware I've been fond of saying but I

00:34:10,809 --> 00:34:15,700
believe it fervently that we are engaged

00:34:12,970 --> 00:34:17,230
in a war with firmware it is humanity

00:34:15,700 --> 00:34:19,299
versus firmware and everyone needs to

00:34:17,230 --> 00:34:21,760
pick a side so I hope that you pick the

00:34:19,299 --> 00:34:24,639
side of humanity and I think there's a

00:34:21,760 --> 00:34:26,139
lot of opportunity to rewrite that Louis

00:34:24,639 --> 00:34:28,000
all the software which I honestly is

00:34:26,139 --> 00:34:30,069
still in assembly or C I think there's a

00:34:28,000 --> 00:34:31,780
lot of opportunity to rewrite that in

00:34:30,069 --> 00:34:32,980
Rus so I think the you know one of the

00:34:31,780 --> 00:34:35,049
things that the Rus community says over

00:34:32,980 --> 00:34:37,210
and over again is we can have nice

00:34:35,049 --> 00:34:40,089
things and I think that that is very

00:34:37,210 --> 00:34:42,339
much borne out by Rus values the values

00:34:40,089 --> 00:34:43,960
themselves are a great fit for system

00:34:42,339 --> 00:34:45,970
software it doesn't mean it's a fit for

00:34:43,960 --> 00:34:47,589
everything and you shouldn't let anyone

00:34:45,970 --> 00:34:49,359
try to convince you that it's a fit for

00:34:47,589 --> 00:34:51,309
everything it's not but for certain

00:34:49,359 --> 00:34:53,349
bodies of software and in particular the

00:34:51,309 --> 00:34:55,480
software that I like to write it's a

00:34:53,349 --> 00:34:57,099
great fit and really liberating and I

00:34:55,480 --> 00:34:58,510
think we're gonna see a lot of system

00:34:57,099 --> 00:35:00,900
software written in rust with that thank

00:34:58,510 --> 00:35:00,900
you very much

00:35:07,309 --> 00:35:13,170
yeah I don't like negative five minutes

00:35:09,720 --> 00:35:21,510
for questions okay yeah I'm happy to

00:35:13,170 --> 00:35:23,400
take a question or two yes yeah so

00:35:21,510 --> 00:35:25,559
that's a great question and I mean

00:35:23,400 --> 00:35:27,539
clearly like if when you're talking to

00:35:25,559 --> 00:35:30,599
si si you can clearly be zero your

00:35:27,539 --> 00:35:32,160
address space I mean so it's Russ is

00:35:30,599 --> 00:35:34,529
going Russ is going to help you out with

00:35:32,160 --> 00:35:36,089
the safety of your code but when you

00:35:34,529 --> 00:35:39,119
need it I mean so for example if you

00:35:36,089 --> 00:35:41,460
want to call em map the which is allows

00:35:39,119 --> 00:35:42,869
you to actually M map a an object into

00:35:41,460 --> 00:35:44,400
your own address space that's an unsafe

00:35:42,869 --> 00:35:46,799
operation so you will need to wrap that

00:35:44,400 --> 00:35:49,260
in on safety I think what it's doing is

00:35:46,799 --> 00:35:50,609
confining that on safety such that

00:35:49,260 --> 00:35:52,859
you're aware of it so it does help you

00:35:50,609 --> 00:35:54,750
out in that it limits it as opposed to

00:35:52,859 --> 00:35:57,500
like letting that poison an entire

00:35:54,750 --> 00:36:00,990
application that make sense yeah cool

00:35:57,500 --> 00:36:04,109
any other other questions

00:36:00,990 --> 00:36:06,330
yes so what do you think of the idea of

00:36:04,109 --> 00:36:09,630
what systems for every but there's other

00:36:06,330 --> 00:36:13,890
spaces where it's very important to just

00:36:09,630 --> 00:36:17,820
in yes we're worse they did what was

00:36:13,890 --> 00:36:19,650
intended right you see a role for us not

00:36:17,820 --> 00:36:23,280
just as a system software but for

00:36:19,650 --> 00:36:25,290
example like cooperating what they did

00:36:23,280 --> 00:36:29,839
game or as some kind of date libraries

00:36:25,290 --> 00:36:31,230
and where you can combine the two system

00:36:29,839 --> 00:36:33,300
absolutely

00:36:31,230 --> 00:36:35,720
and I'd say any place where these values

00:36:33,300 --> 00:36:38,849
are important Russ is gonna have a place

00:36:35,720 --> 00:36:40,290
and in particular where these are the

00:36:38,849 --> 00:36:42,030
choices you want to make and in

00:36:40,290 --> 00:36:43,589
particular particular where performance

00:36:42,030 --> 00:36:45,780
is the is your top choice if if

00:36:43,589 --> 00:36:47,849
performance is your overarching value

00:36:45,780 --> 00:36:49,650
I think rust is absolutely gonna have a

00:36:47,849 --> 00:36:51,550
place all right I think I'm out of time

00:36:49,650 --> 00:36:57,039
thank you very much everybody

00:36:51,550 --> 00:36:57,039
[Applause]

00:37:01,619 --> 00:37:03,680

YouTube URL: https://www.youtube.com/watch?v=2wZ1pCpJUIM


