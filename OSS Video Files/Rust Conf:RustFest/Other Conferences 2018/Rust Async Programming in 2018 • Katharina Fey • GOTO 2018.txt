Title: Rust Async Programming in 2018 â€¢ Katharina Fey â€¢ GOTO 2018
Publication date: 2019-01-23
Playlist: Other Conferences 2018
Description: 
	This presentation was recorded at GOTO Copenhagen 2018. #gotocon #gotocph
http://gotocph.com

Katharina Fey - Software engineer at Ferrous Systems

ABSTRACT
Async IO, network programming and microservices have become a popular application of the Rust programming language.
This talk will give an introduction into these subjects and highlight why people are choosing Rust over other options.
The talk presents specific language features, like the concurrency-aware type system, as well as libraries that have emerged in the [...]

Download slides and read the full abstract here:
https://gotocph.com/2018/sessions/587

https://twitter.com/gotocph
https://www.facebook.com/GOTOConference
https://www.linkedin.com/company/goto-
http://gotocon.com
#Rustlang #AsyncProgramming

Looking for a unique learning experience?
Attend the next GOTO Conference near you! Get your ticket at http://gotocon.com

SUBSCRIBE TO OUR CHANNEL - new videos posted almost daily.
https://www.youtube.com/user/GotoConferences/?sub_confirmation=1
Captions: 
	00:00:03,510 --> 00:00:07,530
[Music]

00:00:12,559 --> 00:00:21,029
all right so hi welcome to my talk thank

00:00:16,740 --> 00:00:23,849
you for coming I'm gonna I'm gonna say

00:00:21,029 --> 00:00:25,800
up front something this slide says async

00:00:23,849 --> 00:00:28,560
and Rus 2018 and the the talk

00:00:25,800 --> 00:00:31,590
description might say something about

00:00:28,560 --> 00:00:36,450
features and async async' features and

00:00:31,590 --> 00:00:41,550
2018 rust but this talk really is the

00:00:36,450 --> 00:00:45,410
history of how it's rust 2019 so be

00:00:41,550 --> 00:00:48,030
warned right before I get started

00:00:45,410 --> 00:00:50,420
Who am I my name is Katerina Fey I'm

00:00:48,030 --> 00:00:52,940
from Berlin I'm a software engineer I

00:00:50,420 --> 00:00:55,680
have a background in systems programming

00:00:52,940 --> 00:00:58,200
drivers and that sort of stuff I go by

00:00:55,680 --> 00:01:02,280
that handled I'm on most social media

00:00:58,200 --> 00:01:04,140
and github whatever I develop a lot of

00:01:02,280 --> 00:01:07,170
open source software I'm involved with a

00:01:04,140 --> 00:01:11,159
few different projects with different

00:01:07,170 --> 00:01:13,740
priorities and so I sort of visit a lot

00:01:11,159 --> 00:01:17,190
of communities sometimes only

00:01:13,740 --> 00:01:20,159
ephemerally and pick up concepts and

00:01:17,190 --> 00:01:21,300
ideas that are sort of only locally

00:01:20,159 --> 00:01:23,280
being thought about in different

00:01:21,300 --> 00:01:24,600
communities I drink a lot of tea and

00:01:23,280 --> 00:01:28,620
sometimes I hack around with hardware

00:01:24,600 --> 00:01:30,600
although not as much as I used to I make

00:01:28,620 --> 00:01:32,520
some really atrocious puns and I say

00:01:30,600 --> 00:01:36,450
this to sort of warn you about the slide

00:01:32,520 --> 00:01:37,920
deck that you're about to see I am sorry

00:01:36,450 --> 00:01:39,780
I have a bad sense of humor and I can't

00:01:37,920 --> 00:01:44,250
help myself

00:01:39,780 --> 00:01:46,799
so this is a rusted talk so one would

00:01:44,250 --> 00:01:48,900
think that I do some rust things I am a

00:01:46,799 --> 00:01:52,830
contributor to the the CLI working group

00:01:48,900 --> 00:01:56,280
which is a group of people that sort of

00:01:52,830 --> 00:02:00,630
exists close to the core team that deals

00:01:56,280 --> 00:02:02,700
with developing CLI libraries and making

00:02:00,630 --> 00:02:05,880
the development of CLI applications

00:02:02,700 --> 00:02:08,459
nicer I am a member of the community

00:02:05,880 --> 00:02:11,069
team and Berlin RS which is sort of a

00:02:08,459 --> 00:02:13,349
local community group in Berlin we

00:02:11,069 --> 00:02:16,620
organize events and workshops I've been

00:02:13,349 --> 00:02:19,980
I've given rust bridge which is a one

00:02:16,620 --> 00:02:21,340
day workshop organized by or around

00:02:19,980 --> 00:02:22,870
Mozilla events

00:02:21,340 --> 00:02:25,209
to teach trust to people

00:02:22,870 --> 00:02:28,090
underrepresented in technology twice now

00:02:25,209 --> 00:02:29,620
once in Paris and once in Portland and I

00:02:28,090 --> 00:02:31,690
maintain a bunch of libraries so if

00:02:29,620 --> 00:02:34,330
you're writing CLI is chances are that

00:02:31,690 --> 00:02:39,040
you're using my code and if you're not

00:02:34,330 --> 00:02:41,410
then you probably won't have to so I

00:02:39,040 --> 00:02:43,690
want to start this talk with a hopefully

00:02:41,410 --> 00:02:46,720
very uncontroversial statement which is

00:02:43,690 --> 00:02:51,040
that concurrency is really hard it's the

00:02:46,720 --> 00:02:54,640
kind of hard that makes you find 99% of

00:02:51,040 --> 00:02:57,250
bugs really easy and then that last

00:02:54,640 --> 00:02:58,690
percent costs you your sanity and then

00:02:57,250 --> 00:03:03,100
you want to quit computers forever

00:02:58,690 --> 00:03:04,540
because they're always sad we there's

00:03:03,100 --> 00:03:07,150
two different types of concurrency

00:03:04,540 --> 00:03:09,430
problems that you usually encounter the

00:03:07,150 --> 00:03:11,980
ones is the cars jumping over each other

00:03:09,430 --> 00:03:15,099
and the other one is not enough cars

00:03:11,980 --> 00:03:17,920
going over the same road now not enough

00:03:15,099 --> 00:03:19,690
cars so inefficient scaling usually

00:03:17,920 --> 00:03:22,870
isn't a big problem except that you're

00:03:19,690 --> 00:03:25,540
wasting you know hardware resources but

00:03:22,870 --> 00:03:29,079
they don't generally cause any bugs what

00:03:25,540 --> 00:03:34,799
is the problem or race conditions as you

00:03:29,079 --> 00:03:37,630
saw in a literal race so race conditions

00:03:34,799 --> 00:03:40,390
I'm gonna give a little bit of a primer

00:03:37,630 --> 00:03:42,819
on a few concurrency issues race

00:03:40,390 --> 00:03:45,190
conditions ultimately come down to the

00:03:42,819 --> 00:03:47,680
problem of what thread owns a piece of

00:03:45,190 --> 00:03:51,160
data so if you have two threads that

00:03:47,680 --> 00:03:53,200
both want to change your value and say

00:03:51,160 --> 00:03:55,799
read the value incremented by one and

00:03:53,200 --> 00:03:58,120
write it back if you're not careful

00:03:55,799 --> 00:03:59,920
depending on the timing on how your

00:03:58,120 --> 00:04:02,530
threads are going to be executed by your

00:03:59,920 --> 00:04:04,209
scheduler either if the value is going

00:04:02,530 --> 00:04:06,519
to be one or it's going to be two and

00:04:04,209 --> 00:04:09,370
only one of those is the correct answer

00:04:06,519 --> 00:04:14,079
the other one is a data race that makes

00:04:09,370 --> 00:04:18,760
you lose data and this is exactly where

00:04:14,079 --> 00:04:20,799
we're rust comes in so I normally speak

00:04:18,760 --> 00:04:23,110
more at a trust conferences where I can

00:04:20,799 --> 00:04:24,669
assume that people generally understand

00:04:23,110 --> 00:04:27,010
what the language is about so I'm gonna

00:04:24,669 --> 00:04:29,260
give a bit of a high-level overview and

00:04:27,010 --> 00:04:31,580
we're going to dip down into a few more

00:04:29,260 --> 00:04:35,240
specific concepts throughout the talk

00:04:31,580 --> 00:04:37,400
when they become relevant so rust is a

00:04:35,240 --> 00:04:40,310
systems programming language that runs

00:04:37,400 --> 00:04:43,099
blazingly fast prevents seg faults and

00:04:40,310 --> 00:04:45,259
guarantees thread safety that is the

00:04:43,099 --> 00:04:47,389
marketing pitch on the website and I

00:04:45,259 --> 00:04:52,550
think the correct response to that is to

00:04:47,389 --> 00:04:55,460
be a little confused because while if

00:04:52,550 --> 00:04:57,500
you're in the systems programming world

00:04:55,460 --> 00:05:00,590
already and you might be familiar with a

00:04:57,500 --> 00:05:04,460
lot of these concepts there is a lot of

00:05:00,590 --> 00:05:06,560
jargon there and so to break down word

00:05:04,460 --> 00:05:09,280
rust is really about there is one word

00:05:06,560 --> 00:05:13,120
that summarizes certain which is safety

00:05:09,280 --> 00:05:17,330
that's safety in two different domains

00:05:13,120 --> 00:05:20,690
memory safety for one rust was developed

00:05:17,330 --> 00:05:23,150
as a replacement for C++ and Firefox and

00:05:20,690 --> 00:05:24,620
there is a few other design decisions

00:05:23,150 --> 00:05:27,800
that come from that for example very

00:05:24,620 --> 00:05:32,000
easy interoperability with C code which

00:05:27,800 --> 00:05:35,240
can can be quite fun and the second

00:05:32,000 --> 00:05:39,409
thing is thread safety so a lot of

00:05:35,240 --> 00:05:42,110
concurrency issues revolve around what

00:05:39,409 --> 00:05:46,520
thread owns data and well rust makes

00:05:42,110 --> 00:05:50,960
this very explicit with ownership so in

00:05:46,520 --> 00:05:53,180
rust all data has an owner and all data

00:05:50,960 --> 00:05:56,479
is always owned even if this owner is

00:05:53,180 --> 00:06:01,130
the static binary which is then the

00:05:56,479 --> 00:06:04,069
owner and static data that you own can

00:06:01,130 --> 00:06:06,190
be borrowed with specific rules and

00:06:04,069 --> 00:06:10,039
there's in fact very strict rules about

00:06:06,190 --> 00:06:12,020
how you can own and borrow data and in

00:06:10,039 --> 00:06:15,909
what contexts this is allowed and

00:06:12,020 --> 00:06:20,740
there's a few small examples following

00:06:15,909 --> 00:06:23,060
so let's take this piece of code and I

00:06:20,740 --> 00:06:24,949
again I don't know how many people here

00:06:23,060 --> 00:06:26,630
actually I would like to see how many

00:06:24,949 --> 00:06:27,729
people have programmed rust in this room

00:06:26,630 --> 00:06:31,099
before

00:06:27,729 --> 00:06:34,699
okay that's about five percent maybe

00:06:31,099 --> 00:06:36,560
okay so the syntax should be fairly

00:06:34,699 --> 00:06:40,250
straightforward two things I will

00:06:36,560 --> 00:06:42,710
mention is this question mark is a way

00:06:40,250 --> 00:06:45,320
to gracefully propagate errors upwards

00:06:42,710 --> 00:06:48,200
so F in this case will either be of

00:06:45,320 --> 00:06:49,970
by all or the function will be exited

00:06:48,200 --> 00:06:54,830
early with an error

00:06:49,970 --> 00:06:58,250
it's the let something error and if

00:06:54,830 --> 00:07:01,370
error return era from go I don't write

00:06:58,250 --> 00:07:02,750
much go ever but like I've seen this

00:07:01,370 --> 00:07:04,970
pattern and like a lot of people know

00:07:02,750 --> 00:07:06,500
that pattern there's no exceptions and

00:07:04,970 --> 00:07:09,110
Russ so this is how you deal with errors

00:07:06,500 --> 00:07:11,180
you can just sort of say ok this is now

00:07:09,110 --> 00:07:13,570
a file and if the file opening failed

00:07:11,180 --> 00:07:15,770
then the function will return an error

00:07:13,570 --> 00:07:17,510
the second thing that you might be a

00:07:15,770 --> 00:07:20,480
little confused by whoops

00:07:17,510 --> 00:07:23,600
ok calm the move with the pipes so the

00:07:20,480 --> 00:07:26,330
pipes open a closure with curly break

00:07:23,600 --> 00:07:30,590
versus being the actual function move in

00:07:26,330 --> 00:07:32,150
this context means that the environment

00:07:30,590 --> 00:07:34,310
of the closure is captured in a mutable

00:07:32,150 --> 00:07:36,410
sort of way which is important if you

00:07:34,310 --> 00:07:39,680
want to then change anything about it

00:07:36,410 --> 00:07:42,890
and so if you look at this code this is

00:07:39,680 --> 00:07:44,420
not correct this will not work and in

00:07:42,890 --> 00:07:46,760
any other language this would cause a

00:07:44,420 --> 00:07:50,420
runtime issue whereas in rust

00:07:46,760 --> 00:07:54,080
it just doesn't compile it doesn't

00:07:50,420 --> 00:07:57,620
compile because of ownership because the

00:07:54,080 --> 00:08:01,070
first time this thread is invoked it

00:07:57,620 --> 00:08:03,860
takes ownership of the value F and then

00:08:01,070 --> 00:08:08,270
F is dropped which is the equivalent of

00:08:03,860 --> 00:08:09,650
closing a file but so the next time you

00:08:08,270 --> 00:08:12,110
would want to do anything which is

00:08:09,650 --> 00:08:13,610
literally the loop and the compiler

00:08:12,110 --> 00:08:17,750
understands that the thread is being

00:08:13,610 --> 00:08:19,400
spawned in a loop it the the ownership

00:08:17,750 --> 00:08:22,070
has already been moved into the first

00:08:19,400 --> 00:08:24,770
thread so you can't do that and it won't

00:08:22,070 --> 00:08:28,040
compile and to simplify this this

00:08:24,770 --> 00:08:30,590
example a little bit this would also not

00:08:28,040 --> 00:08:33,229
compile so we have a we have some

00:08:30,590 --> 00:08:36,110
function read from file which just takes

00:08:33,229 --> 00:08:38,930
a file and it does whatever and then if

00:08:36,110 --> 00:08:42,410
you want to open a file and read from it

00:08:38,930 --> 00:08:44,180
twice or call this function twice this

00:08:42,410 --> 00:08:47,960
would also not compile for the same

00:08:44,180 --> 00:08:50,180
reason the reason being that you try to

00:08:47,960 --> 00:08:53,630
move ownership instead of borrowing the

00:08:50,180 --> 00:08:56,829
data now I could talk for a very great

00:08:53,630 --> 00:08:59,829
length about borrowing and

00:08:56,829 --> 00:09:01,179
it's there's a component in the in the

00:08:59,829 --> 00:09:02,949
rust compiler called the burrow checker

00:09:01,179 --> 00:09:05,709
which is the source of frequent

00:09:02,949 --> 00:09:08,980
frustration for people who are new to

00:09:05,709 --> 00:09:10,269
the language realistically it's it's

00:09:08,980 --> 00:09:12,970
something you need to learn to

00:09:10,269 --> 00:09:16,239
understand and the borrow checker and

00:09:12,970 --> 00:09:17,649
the borrow dynamics in rust forced you

00:09:16,239 --> 00:09:19,420
to think about data in a different way

00:09:17,649 --> 00:09:23,589
that prevents a lot of concurrency

00:09:19,420 --> 00:09:26,410
issues from ever happening people like

00:09:23,589 --> 00:09:29,529
to put programming languages on some

00:09:26,410 --> 00:09:33,069
imaginary spectrum I don't know exactly

00:09:29,529 --> 00:09:36,360
what the spectrum would be but you know

00:09:33,069 --> 00:09:39,639
everything is PowerPoint apparently and

00:09:36,360 --> 00:09:40,769
and rust makes makes being put into a

00:09:39,639 --> 00:09:43,420
spectrum like this very difficult

00:09:40,769 --> 00:09:45,819
because it has memory safety without

00:09:43,420 --> 00:09:48,519
having a garbage collector it is thread

00:09:45,819 --> 00:09:51,189
safe despite being a very low-level

00:09:48,519 --> 00:09:53,110
language and not requiring a runtime or

00:09:51,189 --> 00:09:54,029
a virtual environment or anything like

00:09:53,110 --> 00:09:58,420
that

00:09:54,029 --> 00:10:00,759
and I think if I had to summarize rust

00:09:58,420 --> 00:10:03,399
as a language I would use this quote

00:10:00,759 --> 00:10:05,679
from the foreword of the rust book which

00:10:03,399 --> 00:10:08,290
says that rust is about empowering

00:10:05,679 --> 00:10:11,049
developers to have confidence in what

00:10:08,290 --> 00:10:13,509
they develop and to be able to expand

00:10:11,049 --> 00:10:16,720
their usage domains of a language

00:10:13,509 --> 00:10:18,759
further than they program before and

00:10:16,720 --> 00:10:20,350
we've seen this a lot of people are

00:10:18,759 --> 00:10:22,299
programming and rust in systems

00:10:20,350 --> 00:10:23,709
programming even though they have you

00:10:22,299 --> 00:10:25,779
know a Java Script or a Python

00:10:23,709 --> 00:10:29,970
background and they did mostly scripting

00:10:25,779 --> 00:10:33,999
or whatever or the other way around so

00:10:29,970 --> 00:10:36,519
so with that out the way I hope you you

00:10:33,999 --> 00:10:38,769
have a bit of a picture about what rust

00:10:36,519 --> 00:10:41,049
is and why it's interesting let's talk

00:10:38,769 --> 00:10:43,389
about async what is that what does it

00:10:41,049 --> 00:10:43,990
know it doesn't know anything and let's

00:10:43,389 --> 00:10:49,419
find out

00:10:43,990 --> 00:10:51,610
so async programming for people who

00:10:49,419 --> 00:10:54,249
don't do async programming can be a

00:10:51,610 --> 00:10:57,069
little confusing because it boils down

00:10:54,249 --> 00:10:58,689
to this sentence please do this thing

00:10:57,069 --> 00:11:02,529
but don't make me wait

00:10:58,689 --> 00:11:05,679
it's about non-blocking i/o but it's

00:11:02,529 --> 00:11:07,689
about non-blocking i/o in a way that it

00:11:05,679 --> 00:11:09,209
just doesn't doesn't just spawn new

00:11:07,689 --> 00:11:13,499
threads

00:11:09,209 --> 00:11:16,620
and the way that this works is kind of

00:11:13,499 --> 00:11:19,259
interesting and it usually results in

00:11:16,620 --> 00:11:22,649
two component or it requires two

00:11:19,259 --> 00:11:26,160
components one of them is futures and

00:11:22,649 --> 00:11:31,110
we're gonna look at what not those types

00:11:26,160 --> 00:11:32,850
of futures but futures are calculations

00:11:31,110 --> 00:11:35,749
that haven't happened yet

00:11:32,850 --> 00:11:38,100
so when with async programming

00:11:35,749 --> 00:11:41,189
non-blocking i/o or non-blocking

00:11:38,100 --> 00:11:43,709
operations generally become speculating

00:11:41,189 --> 00:11:45,870
about what will be in the future and in

00:11:43,709 --> 00:11:47,850
most languages this is called literally

00:11:45,870 --> 00:11:50,790
a future although javascript Koston

00:11:47,850 --> 00:11:52,499
promises it means that something is

00:11:50,790 --> 00:11:56,309
probably going to happen at some point

00:11:52,499 --> 00:11:59,610
and you just should keep asking it and

00:11:56,309 --> 00:12:02,850
the interesting thing here is whenever I

00:11:59,610 --> 00:12:05,790
talk to people who don't don't have a

00:12:02,850 --> 00:12:08,009
familiarity with async programming and I

00:12:05,790 --> 00:12:09,600
tell them this they asked me well is

00:12:08,009 --> 00:12:12,809
that not just a thread and a joint

00:12:09,600 --> 00:12:14,879
handle and I mean in a way I like

00:12:12,809 --> 00:12:15,959
spawning a thread and then waiting for

00:12:14,879 --> 00:12:17,509
that thread to terminate and do

00:12:15,959 --> 00:12:20,160
something and give you something back

00:12:17,509 --> 00:12:24,360
has similarities to that but the big

00:12:20,160 --> 00:12:27,089
difference is the event loop so futures

00:12:24,360 --> 00:12:30,930
run inside an event loop which means

00:12:27,089 --> 00:12:33,389
that it's a it's a scheduler that runs

00:12:30,930 --> 00:12:36,629
your features it is responsible for

00:12:33,389 --> 00:12:38,879
pulling the futures for readiness and

00:12:36,629 --> 00:12:41,309
then calling whatever code that you want

00:12:38,879 --> 00:12:44,730
it to call call when a future becomes

00:12:41,309 --> 00:12:49,769
ready this is this can be seen as a user

00:12:44,730 --> 00:12:52,589
space scheduler for well futures now

00:12:49,769 --> 00:12:54,870
event loops can be multi-threaded but

00:12:52,589 --> 00:12:56,490
they don't have to be by definition they

00:12:54,870 --> 00:12:58,639
can be single threaded nodejs for

00:12:56,490 --> 00:13:02,610
example is a single threaded event loop

00:12:58,639 --> 00:13:05,040
and what it means is that it takes all

00:13:02,610 --> 00:13:06,870
of the responsibility of scheduling your

00:13:05,040 --> 00:13:08,790
application and takes it from the

00:13:06,870 --> 00:13:10,740
developer of the actual application and

00:13:08,790 --> 00:13:16,350
puts it on to the developer of the event

00:13:10,740 --> 00:13:19,980
loop so why would you want to do this it

00:13:16,350 --> 00:13:21,060
boils down to complexity of context

00:13:19,980 --> 00:13:23,700
switching

00:13:21,060 --> 00:13:26,370
so when you spot a new thread that's a

00:13:23,700 --> 00:13:28,470
lot of work it there's a lot of overhead

00:13:26,370 --> 00:13:31,020
involved you have to allocate memory you

00:13:28,470 --> 00:13:33,510
have to copy registers around your

00:13:31,020 --> 00:13:35,940
kernel needs to do a lot of legwork and

00:13:33,510 --> 00:13:40,710
there's a syscall involved so you know

00:13:35,940 --> 00:13:43,020
all of this requires a bit of dedication

00:13:40,710 --> 00:13:45,690
if you spawned a thread for literally

00:13:43,020 --> 00:13:47,640
every call that you do your application

00:13:45,690 --> 00:13:50,460
would be a lot slower because you have

00:13:47,640 --> 00:13:53,010
so much overhead that you never see the

00:13:50,460 --> 00:13:56,130
returns or you have diminishing returns

00:13:53,010 --> 00:13:58,050
from spotting threads there's this

00:13:56,130 --> 00:14:01,410
picture and I think it's a few years old

00:13:58,050 --> 00:14:03,090
and I don't think I like I think this

00:14:01,410 --> 00:14:05,370
should be taken with a bit of salt

00:14:03,090 --> 00:14:09,870
because obviously Apache and nginx are

00:14:05,370 --> 00:14:13,230
not comparable in many domains but

00:14:09,870 --> 00:14:15,540
fundamentally Apache spawns is much more

00:14:13,230 --> 00:14:18,380
eager to spawn new threads when dealing

00:14:15,540 --> 00:14:21,810
with connections than nginx nginx

00:14:18,380 --> 00:14:23,460
usually allocates a pool of workers and

00:14:21,810 --> 00:14:25,790
it can you know it can grow that if it

00:14:23,460 --> 00:14:30,510
needs to but it uses async programming

00:14:25,790 --> 00:14:32,040
paradigms to use the threads that it

00:14:30,510 --> 00:14:34,910
already has in the workers that it

00:14:32,040 --> 00:14:37,970
already has with more efficiency and

00:14:34,910 --> 00:14:42,120
well you can see this in the memory

00:14:37,970 --> 00:14:44,820
usage this is for example also the

00:14:42,120 --> 00:14:48,180
reason why nginx is basically immune to

00:14:44,820 --> 00:14:50,040
the slow lorry a dose or DDoS attack

00:14:48,180 --> 00:14:52,020
where you open connections to a web

00:14:50,040 --> 00:14:55,350
server and then just let them time out

00:14:52,020 --> 00:14:57,600
in order to like make the servers for

00:14:55,350 --> 00:15:03,000
lots of workers and where nginx does

00:14:57,600 --> 00:15:05,670
just in care right so I hope that you

00:15:03,000 --> 00:15:07,200
have a even if you weren't familiar with

00:15:05,670 --> 00:15:10,710
async programming before I hope you

00:15:07,200 --> 00:15:12,900
understand what it's about and with the

00:15:10,710 --> 00:15:14,910
the history of rust in mind or a little

00:15:12,900 --> 00:15:16,950
bit of context about rust in mind I'm

00:15:14,910 --> 00:15:18,930
here to show you some code and talk

00:15:16,950 --> 00:15:20,820
about history and I was gonna say I'm

00:15:18,930 --> 00:15:23,580
all out of code but then I added some

00:15:20,820 --> 00:15:27,510
code so I'm mostly out of code and we

00:15:23,580 --> 00:15:32,400
need to travel back in time to the year

00:15:27,510 --> 00:15:33,670
late 2013 to understand where a rust was

00:15:32,400 --> 00:15:36,490
coming from and

00:15:33,670 --> 00:15:38,620
where it is going and why that is

00:15:36,490 --> 00:15:40,090
interesting in the context of the

00:15:38,620 --> 00:15:49,120
development that has happened in the

00:15:40,090 --> 00:15:52,720
last year or in the last few years so in

00:15:49,120 --> 00:15:55,540
late 2013 rust was still unstable the

00:15:52,720 --> 00:16:00,250
language became stable in May of I want

00:15:55,540 --> 00:16:02,560
to say May or March of 2015 so in 2013

00:16:00,250 --> 00:16:04,240
there were a lot of changes that were

00:16:02,560 --> 00:16:06,340
still happening to the language if you a

00:16:04,240 --> 00:16:09,250
program to Neda would be very frequent

00:16:06,340 --> 00:16:10,900
that you would download the new light

00:16:09,250 --> 00:16:12,340
nightly version of the compiler and your

00:16:10,900 --> 00:16:14,490
code wouldn't compile anymore because

00:16:12,340 --> 00:16:17,980
the keywords you were using disappeared

00:16:14,490 --> 00:16:20,890
around this time there was a library

00:16:17,980 --> 00:16:23,410
called Lib green and green threading is

00:16:20,890 --> 00:16:25,390
a different name for this concept of

00:16:23,410 --> 00:16:28,000
spawning micro processes that don't

00:16:25,390 --> 00:16:31,630
necessarily correspond to the number of

00:16:28,000 --> 00:16:34,030
system threads that you have Lib Green

00:16:31,630 --> 00:16:38,260
was introduced into the the rust

00:16:34,030 --> 00:16:39,790
standard library at December 26 2013 for

00:16:38,260 --> 00:16:43,000
the development efforts before that

00:16:39,790 --> 00:16:46,390
we're obviously already and in place and

00:16:43,000 --> 00:16:49,210
so there were two threading directives

00:16:46,390 --> 00:16:52,300
and and schedule schedule schedule errs

00:16:49,210 --> 00:16:53,800
essentially for further adds one that

00:16:52,300 --> 00:16:55,780
used sort of these asynchronous

00:16:53,800 --> 00:16:57,700
non-blocking micro threads and the other

00:16:55,780 --> 00:17:02,260
one that actually bounds like a one to

00:16:57,700 --> 00:17:05,200
one system thread this enabled the the

00:17:02,260 --> 00:17:07,720
rust standard library to do non-blocking

00:17:05,200 --> 00:17:11,110
i/o and do a lot of asynchronous

00:17:07,720 --> 00:17:14,500
programming very early on the problem is

00:17:11,110 --> 00:17:16,450
or the problem was that that required

00:17:14,500 --> 00:17:19,720
the standard library to actually include

00:17:16,450 --> 00:17:22,150
a run time or a run time for an event

00:17:19,720 --> 00:17:24,220
loop for these features or for

00:17:22,150 --> 00:17:26,410
asynchronous there wasn't a futurist

00:17:24,220 --> 00:17:28,510
abstraction yet it was just generally

00:17:26,410 --> 00:17:31,180
asynchronous calls and this came with a

00:17:28,510 --> 00:17:33,310
lot of problems and like a lot of them

00:17:31,180 --> 00:17:34,960
are specific to how the rust compiler

00:17:33,310 --> 00:17:39,180
was implemented and how the rest of the

00:17:34,960 --> 00:17:41,630
standard library was implemented but

00:17:39,180 --> 00:17:44,390
ultimately

00:17:41,630 --> 00:17:46,039
the decision to remove this again was

00:17:44,390 --> 00:17:47,059
because rust wanted to go into a

00:17:46,039 --> 00:17:49,190
different direction

00:17:47,059 --> 00:17:52,100
rust didn't want to have to rely on a

00:17:49,190 --> 00:17:56,150
runtime and wanted to be more low-level

00:17:52,100 --> 00:18:01,700
and bare metal so just a year later in

00:17:56,150 --> 00:18:07,610
late 2014 November 21st 2014 lip green

00:18:01,700 --> 00:18:13,160
was removed and so it was dead and very

00:18:07,610 --> 00:18:16,720
soon after people wanted to have a sink

00:18:13,160 --> 00:18:20,200
i/o again and so this project me ors

00:18:16,720 --> 00:18:24,470
started which stands for metal i/o and

00:18:20,200 --> 00:18:29,030
what mio or me ORS allows you to do is

00:18:24,470 --> 00:18:30,740
it allows you to do non-blocking i/o in

00:18:29,030 --> 00:18:32,720
a slightly different way than lib green

00:18:30,740 --> 00:18:34,429
used to do it because lib green was

00:18:32,720 --> 00:18:37,789
integrated in the standard library and

00:18:34,429 --> 00:18:39,230
it sort of had to coexist with a native

00:18:37,789 --> 00:18:43,100
threading model with a common

00:18:39,230 --> 00:18:45,260
abstraction that over both of them so it

00:18:43,100 --> 00:18:49,130
was a little awkward to use whereas mio

00:18:45,260 --> 00:18:52,150
is really only a very slim abstraction

00:18:49,130 --> 00:18:56,000
over platform-specific asynchronous

00:18:52,150 --> 00:18:57,770
primitives and at this point it has

00:18:56,000 --> 00:19:01,190
grown an ecosystem around it

00:18:57,770 --> 00:19:03,799
there is plugins essentially for me oh

00:19:01,190 --> 00:19:06,919
so that you can have asynchronous i/o

00:19:03,799 --> 00:19:10,850
on all sorts of different well not just

00:19:06,919 --> 00:19:13,549
platforms but devices realistically and

00:19:10,850 --> 00:19:15,770
so yeah this is something that the

00:19:13,549 --> 00:19:17,750
community kept developing it it just

00:19:15,770 --> 00:19:19,490
maintained by a few people in the core

00:19:17,750 --> 00:19:21,200
team so it's not just like the community

00:19:19,490 --> 00:19:22,330
but Missoula is putting its weight

00:19:21,200 --> 00:19:26,419
behind it

00:19:22,330 --> 00:19:29,330
so yeah before we go any further there

00:19:26,419 --> 00:19:31,070
is a second concept or a technically

00:19:29,330 --> 00:19:33,620
third I guess if we count borrowing and

00:19:31,070 --> 00:19:36,350
ownership is two different concepts that

00:19:33,620 --> 00:19:38,770
I need to explain to you and this is

00:19:36,350 --> 00:19:42,710
really where a lot of magic comes from

00:19:38,770 --> 00:19:44,299
which is zero costs abstractions so I

00:19:42,710 --> 00:19:46,940
would show the travolta gif again and

00:19:44,299 --> 00:19:48,620
because it's one of those marketing

00:19:46,940 --> 00:19:52,220
terms again that a lot of people throw

00:19:48,620 --> 00:19:54,030
around and it confuses people who aren't

00:19:52,220 --> 00:19:57,240
in the Rust space

00:19:54,030 --> 00:20:00,720
one way that I've heard it be explained

00:19:57,240 --> 00:20:05,360
is that a zero cost abstraction has no

00:20:00,720 --> 00:20:08,850
discernable runtime overhead and that

00:20:05,360 --> 00:20:11,700
sounds interesting but then it makes me

00:20:08,850 --> 00:20:16,710
ask the question in comparison to what

00:20:11,700 --> 00:20:20,130
run time so like if you compare some

00:20:16,710 --> 00:20:23,010
rust code that is zero abstraction zero

00:20:20,130 --> 00:20:25,500
cost abstraction to the Java JVM and

00:20:23,010 --> 00:20:26,580
well of course you know your costs are

00:20:25,500 --> 00:20:29,460
going to be different than your runtime

00:20:26,580 --> 00:20:33,900
caustic not gonna be comparable so a

00:20:29,460 --> 00:20:36,660
much better way to look about it look at

00:20:33,900 --> 00:20:38,850
it is that it is code that you can't

00:20:36,660 --> 00:20:42,330
have written better by hand even if you

00:20:38,850 --> 00:20:44,570
tried and there's gonna be I'm gonna

00:20:42,330 --> 00:20:47,280
talk about an example in a second so

00:20:44,570 --> 00:20:49,650
basically what a zero cost abstraction

00:20:47,280 --> 00:20:53,610
is is an abstraction that disappears at

00:20:49,650 --> 00:20:55,350
compile time it is a concept a type that

00:20:53,610 --> 00:20:58,680
the compiler knows about in the first

00:20:55,350 --> 00:20:59,910
few steps of you know compilation that

00:20:58,680 --> 00:21:01,350
the borrowed checker knows about that

00:20:59,910 --> 00:21:03,420
the type system knows about the do you

00:21:01,350 --> 00:21:05,490
as a developer can use but when it

00:21:03,420 --> 00:21:07,730
actually comes to code generation there

00:21:05,490 --> 00:21:11,040
is nothing left of it and this is

00:21:07,730 --> 00:21:13,620
especially beautiful in embedded

00:21:11,040 --> 00:21:18,420
development where you can use a lot of

00:21:13,620 --> 00:21:20,220
type type information and cleverness

00:21:18,420 --> 00:21:21,810
about nesting types and sort of

00:21:20,220 --> 00:21:23,340
attaching metadata to the type

00:21:21,810 --> 00:21:26,190
information so that the compiler can

00:21:23,340 --> 00:21:28,410
verify certain things while your final

00:21:26,190 --> 00:21:30,600
binary will still fit into like 4k of

00:21:28,410 --> 00:21:36,600
memory on some microcontroller that you

00:21:30,600 --> 00:21:38,700
need to target oh and so for example I

00:21:36,600 --> 00:21:41,610
forgot the example I thought that was

00:21:38,700 --> 00:21:43,820
code here the example of this that a lot

00:21:41,610 --> 00:21:47,130
of people like to consider is iterators

00:21:43,820 --> 00:21:49,530
so in rust iterator the iterator API is

00:21:47,130 --> 00:21:51,330
a zero cost abstraction which means that

00:21:49,530 --> 00:21:53,220
if you spawn an iterator over a

00:21:51,330 --> 00:21:56,250
collection and then you do some like

00:21:53,220 --> 00:21:57,540
fold map like a filter map and a fault

00:21:56,250 --> 00:22:00,030
or something and you go nuts with

00:21:57,540 --> 00:22:03,030
combinators and then you collect that

00:22:00,030 --> 00:22:05,010
into a non allocating collection say an

00:22:03,030 --> 00:22:09,210
array on the stack

00:22:05,010 --> 00:22:10,470
then that will generate code that in the

00:22:09,210 --> 00:22:12,950
final binary if you were to reverse

00:22:10,470 --> 00:22:15,390
engineer it and you apply all the

00:22:12,950 --> 00:22:18,960
optimizations of release mode which is

00:22:15,390 --> 00:22:21,420
important you would not be able to tell

00:22:18,960 --> 00:22:23,550
if you had used the iterator API or

00:22:21,420 --> 00:22:25,950
written a for loop yourself in fact

00:22:23,550 --> 00:22:27,870
sometimes because type information can

00:22:25,950 --> 00:22:30,990
be traced through certain parts of the

00:22:27,870 --> 00:22:32,910
compile steps sometimes the iterator API

00:22:30,990 --> 00:22:35,010
is actually faster than writing a for

00:22:32,910 --> 00:22:38,430
loop because the compiler can do things

00:22:35,010 --> 00:22:40,260
like cache locality that you know you

00:22:38,430 --> 00:22:44,760
could otherwise not assume because you

00:22:40,260 --> 00:22:48,210
have a greater scope so which brings us

00:22:44,760 --> 00:22:52,590
to May 2016 this point rust had been

00:22:48,210 --> 00:22:55,590
stable for about a year and a library

00:22:52,590 --> 00:22:58,580
emerged that would change asynchronous

00:22:55,590 --> 00:23:01,080
programming forever which is futures RS

00:22:58,580 --> 00:23:05,850
you can see a theme and the memes and

00:23:01,080 --> 00:23:08,400
the slides so futures RS is a zero cost

00:23:05,850 --> 00:23:10,770
abstraction for futures so the same

00:23:08,400 --> 00:23:13,710
thing that you can do for iterators and

00:23:10,770 --> 00:23:17,580
a for loop if you use this futures

00:23:13,710 --> 00:23:20,540
library and you build these these future

00:23:17,580 --> 00:23:23,790
these async tape machines essentially

00:23:20,540 --> 00:23:28,650
you can be guaranteed that the code that

00:23:23,790 --> 00:23:31,260
ends up in your binary has no allocation

00:23:28,650 --> 00:23:34,350
overhead and no runtime overhead in

00:23:31,260 --> 00:23:35,040
comparison to if you had written it all

00:23:34,350 --> 00:23:38,460
yourself

00:23:35,040 --> 00:23:40,590
and you were hand optimizing this exact

00:23:38,460 --> 00:23:43,620
scenario that you know you've you've

00:23:40,590 --> 00:23:46,770
programmed into your computer and like

00:23:43,620 --> 00:23:48,570
you're doing all of it yourself I don't

00:23:46,770 --> 00:23:51,780
want to go as far as say hand written

00:23:48,570 --> 00:23:53,940
assembly because I do like the LLVM but

00:23:51,780 --> 00:23:57,210
I don't have faith in its optimizations

00:23:53,940 --> 00:24:00,090
that much but you can be you can be

00:23:57,210 --> 00:24:02,940
guaranteed that you could not write non

00:24:00,090 --> 00:24:05,070
assembly code yourself any better if you

00:24:02,940 --> 00:24:07,860
use a this abstraction which is

00:24:05,070 --> 00:24:08,460
brilliant and it allowed a second

00:24:07,860 --> 00:24:10,410
project

00:24:08,460 --> 00:24:12,840
Tokio core at this point it's just

00:24:10,410 --> 00:24:16,290
called Tokyo but back then it was called

00:24:12,840 --> 00:24:18,610
Tokyo core to combine two libraries that

00:24:16,290 --> 00:24:21,179
existed in the rusty Coast

00:24:18,610 --> 00:24:23,410
which were mio the asynchronous

00:24:21,179 --> 00:24:26,799
generally threading and scheduling

00:24:23,410 --> 00:24:29,830
models and futures as a as a futures

00:24:26,799 --> 00:24:34,679
abstraction and add an event reactor to

00:24:29,830 --> 00:24:39,340
it and this has been the situation since

00:24:34,679 --> 00:24:43,990
roughly 2016 until the beginning of this

00:24:39,340 --> 00:24:47,140
year at least so this technology stack

00:24:43,990 --> 00:24:52,299
is generally has been generally stable

00:24:47,140 --> 00:24:54,789
since 2016 it's not in a 1.0 so you know

00:24:52,299 --> 00:24:57,340
the reserve the right to bump the minor

00:24:54,789 --> 00:24:59,500
version which hasn't happened yet so the

00:24:57,340 --> 00:25:02,350
API has remained stable for this time

00:24:59,500 --> 00:25:03,490
and people have been wondering how to go

00:25:02,350 --> 00:25:07,710
from here

00:25:03,490 --> 00:25:11,770
building asynchronous code in rusts

00:25:07,710 --> 00:25:16,030
until now and still now looks a little

00:25:11,770 --> 00:25:18,970
bit like this so I offered to do some

00:25:16,030 --> 00:25:21,340
some buffer reading because it's simple

00:25:18,970 --> 00:25:25,690
and we had a fire earlier so there's

00:25:21,340 --> 00:25:27,130
variety so we defined standard in and

00:25:25,690 --> 00:25:29,470
standard out outside the code I didn't

00:25:27,130 --> 00:25:30,940
want the code block to be too big we we

00:25:29,470 --> 00:25:32,679
define a reader and we've defined a

00:25:30,940 --> 00:25:34,600
buffer the the reader is a buffered

00:25:32,679 --> 00:25:38,409
reader over standard N and the buffer is

00:25:34,600 --> 00:25:42,010
a vector a vector in rust is a heap

00:25:38,409 --> 00:25:44,049
allocated data structure which grows

00:25:42,010 --> 00:25:45,820
with different sizes so if you add

00:25:44,049 --> 00:25:47,350
things to it it will grow and if you

00:25:45,820 --> 00:25:51,340
remove them again it will shrink

00:25:47,350 --> 00:25:52,600
depending on what it feels is

00:25:51,340 --> 00:25:54,549
appropriate but under the hood it's

00:25:52,600 --> 00:25:58,299
implemented as an array not a linked

00:25:54,549 --> 00:26:01,630
list so to build a future with the

00:25:58,299 --> 00:26:07,090
futures library you can for example say

00:26:01,630 --> 00:26:09,039
well let's read until some thing so we

00:26:07,090 --> 00:26:10,929
read until we hit a new line the B just

00:26:09,039 --> 00:26:13,480
says that it's a binary string and we'd

00:26:10,929 --> 00:26:15,610
read it into buffer and when this

00:26:13,480 --> 00:26:18,100
happens and now you're building a future

00:26:15,610 --> 00:26:19,600
or you're attaching some piece of

00:26:18,100 --> 00:26:23,559
information to the future that should

00:26:19,600 --> 00:26:25,299
execute when it is ready which it's

00:26:23,559 --> 00:26:29,600
readiness is defined by edge reading in

00:26:25,299 --> 00:26:32,419
your line and then we call this code

00:26:29,600 --> 00:26:34,010
here give it standard in as you know

00:26:32,419 --> 00:26:36,350
maybe you want to read more and the

00:26:34,010 --> 00:26:37,580
buffer but what we do is we ignore

00:26:36,350 --> 00:26:39,740
standardin

00:26:37,580 --> 00:26:43,520
and we write two standard out the

00:26:39,740 --> 00:26:46,640
contents of the entire buffer map error

00:26:43,520 --> 00:26:48,260
by the way in this case just like math

00:26:46,640 --> 00:26:50,390
error you panic

00:26:48,260 --> 00:26:52,340
means that if there is any kind of error

00:26:50,390 --> 00:26:54,890
we don't want to gracefully handle it we

00:26:52,340 --> 00:26:56,900
want to panic and run out the room with

00:26:54,890 --> 00:26:59,330
an error message and the same applies

00:26:56,900 --> 00:27:01,610
down here I am NOT doing well with

00:26:59,330 --> 00:27:05,120
selecting things today

00:27:01,610 --> 00:27:07,730
this map error here is essentially the

00:27:05,120 --> 00:27:10,520
alternative to if the reading process

00:27:07,730 --> 00:27:13,150
hits any sort of problem your pipe goes

00:27:10,520 --> 00:27:16,669
away or whatever then it'll also panic

00:27:13,150 --> 00:27:18,710
okay so we defined a future but the

00:27:16,669 --> 00:27:20,330
interesting thing here is that this is

00:27:18,710 --> 00:27:25,340
just some type information this is a

00:27:20,330 --> 00:27:29,299
collection of data types again which

00:27:25,340 --> 00:27:31,700
will disappear in a minute and this is

00:27:29,299 --> 00:27:35,450
actually where this gets wrong Tokyo is

00:27:31,700 --> 00:27:38,210
the event loop of our choice here and we

00:27:35,450 --> 00:27:40,730
give Tokyo this future and Tokyo will

00:27:38,210 --> 00:27:43,400
now make sure to keep reading from

00:27:40,730 --> 00:27:46,309
standardin and call our future chain

00:27:43,400 --> 00:27:48,620
whenever it is ready and that's

00:27:46,309 --> 00:27:50,840
basically like this is the basics and

00:27:48,620 --> 00:27:54,140
you can expand this really easily you

00:27:50,840 --> 00:27:56,900
could do TCP like you could read from

00:27:54,140 --> 00:28:00,260
from a TCP socket instead of like

00:27:56,900 --> 00:28:02,120
standard in the api's are the same you

00:28:00,260 --> 00:28:03,559
could read from a serial port if you

00:28:02,120 --> 00:28:08,299
wanted which is kind of cool if you're

00:28:03,559 --> 00:28:10,460
embedded so like this is the these are

00:28:08,299 --> 00:28:14,059
the basic building blocks of of building

00:28:10,460 --> 00:28:17,960
building async applications and really

00:28:14,059 --> 00:28:21,530
the thing to to remind yourself of here

00:28:17,960 --> 00:28:25,039
is that all of this type complexity all

00:28:21,530 --> 00:28:26,900
of the combinators and you know you have

00:28:25,039 --> 00:28:30,679
a closure and you jump into some code

00:28:26,900 --> 00:28:34,070
and like you you do whatever this just

00:28:30,679 --> 00:28:36,320
that disappears at compile time and what

00:28:34,070 --> 00:28:39,460
you're left with is very bare metal code

00:28:36,320 --> 00:28:39,460
that is highly optimized

00:28:39,960 --> 00:28:47,470
another thing I mentioned ownership

00:28:44,320 --> 00:28:49,059
earlier and I showed you how ownership

00:28:47,470 --> 00:28:51,160
sort of prevents you from doing a few

00:28:49,059 --> 00:28:53,440
things like closing a file too many

00:28:51,160 --> 00:28:56,760
times or calling a function with the

00:28:53,440 --> 00:28:58,750
same value twice without borrowing it

00:28:56,760 --> 00:29:01,179
the interesting thing about the

00:28:58,750 --> 00:29:04,299
ownership model here is that we access

00:29:01,179 --> 00:29:06,429
reader and buffer and both reader or

00:29:04,299 --> 00:29:09,400
reader I guess is only accessed by the

00:29:06,429 --> 00:29:12,370
first step part but buffer is then

00:29:09,400 --> 00:29:15,280
passed on to the next Combinator both of

00:29:12,370 --> 00:29:17,320
these values are handed over to the to

00:29:15,280 --> 00:29:22,150
the beginning of the future chain and so

00:29:17,320 --> 00:29:23,830
this future now owns the the data which

00:29:22,150 --> 00:29:27,780
means that when we pass this entire

00:29:23,830 --> 00:29:33,429
future to Tokyo Tokyo owns this data

00:29:27,780 --> 00:29:35,710
what that means is that if you if your

00:29:33,429 --> 00:29:39,010
code gets run you can be sure that

00:29:35,710 --> 00:29:41,049
you're the only like because of the way

00:29:39,010 --> 00:29:43,510
that ownership works you can be sure

00:29:41,049 --> 00:29:45,669
that you're the only function in your

00:29:43,510 --> 00:29:48,909
application that accesses buffer at the

00:29:45,669 --> 00:29:53,140
same time if you were to put this into a

00:29:48,909 --> 00:29:55,480
loop or sorry if you were to run Tokyo

00:29:53,140 --> 00:29:56,440
in on multiple threads then this

00:29:55,480 --> 00:29:58,240
wouldn't work anymore

00:29:56,440 --> 00:30:00,039
because it would tell you the exact same

00:29:58,240 --> 00:30:02,590
error message that we got with the

00:30:00,039 --> 00:30:04,539
thread saying hey you just moved

00:30:02,590 --> 00:30:07,059
ownership into this one thread and

00:30:04,539 --> 00:30:09,520
you're trying to spawn seven more that

00:30:07,059 --> 00:30:11,710
this doesn't work and at that point you

00:30:09,520 --> 00:30:13,690
need to make like you need to explicitly

00:30:11,710 --> 00:30:16,809
make sure that the data structure says

00:30:13,690 --> 00:30:19,120
you use our thread safe I haven't gone

00:30:16,809 --> 00:30:22,720
into that at all because that's a whole

00:30:19,120 --> 00:30:25,419
can of worms or it's a very complicated

00:30:22,720 --> 00:30:27,970
issue and it's it's something that when

00:30:25,419 --> 00:30:30,429
you learn rust is something you have to

00:30:27,970 --> 00:30:32,440
get used to but the point is concurrency

00:30:30,429 --> 00:30:35,020
issues here are being made explicit you

00:30:32,440 --> 00:30:36,970
can accidentally have a race condition

00:30:35,020 --> 00:30:38,740
because the compiler will check and like

00:30:36,970 --> 00:30:40,929
the compiler will not let your code

00:30:38,740 --> 00:30:43,830
compile if there is any ambiguity about

00:30:40,929 --> 00:30:43,830
it being thread safe

00:30:43,860 --> 00:30:52,980
so hmm so far so good this talk was

00:30:49,230 --> 00:30:56,850
entitled rust 20 18 and not rust 2013 to

00:30:52,980 --> 00:31:00,679
2016 something that has happened this

00:30:56,850 --> 00:31:06,990
year as part of rust 2018 as async/await

00:31:00,679 --> 00:31:10,019
so rust 2018 is a marketing release it's

00:31:06,990 --> 00:31:12,600
actual version number if I remember

00:31:10,019 --> 00:31:14,250
correctly it's gonna be one point 31

00:31:12,600 --> 00:31:16,440
because I think one point thirty is

00:31:14,250 --> 00:31:18,120
currently out so it's still backwards

00:31:16,440 --> 00:31:21,659
compatible with all the rest code that

00:31:18,120 --> 00:31:24,179
you've written and seen and whatever the

00:31:21,659 --> 00:31:26,610
way that features and new features are

00:31:24,179 --> 00:31:29,100
being enabled and features are being

00:31:26,610 --> 00:31:32,070
liked even a few breaking features are

00:31:29,100 --> 00:31:33,960
enabled with an on an opt-in basis so

00:31:32,070 --> 00:31:37,649
you can declare your project as being a

00:31:33,960 --> 00:31:40,169
rust 20 18 project and then a rust 2015

00:31:37,649 --> 00:31:44,659
compiler would no longer understand

00:31:40,169 --> 00:31:47,899
these features as part of that and

00:31:44,659 --> 00:31:51,389
pretty interesting actually how you can

00:31:47,899 --> 00:31:53,490
combine rust 2015 and 2018 libraries

00:31:51,389 --> 00:31:55,740
into the same project the compiler can

00:31:53,490 --> 00:31:57,389
on-the-fly switch between whichever it

00:31:55,740 --> 00:31:59,370
needs to so it has like different run

00:31:57,389 --> 00:32:01,500
modes so there's not going to be a

00:31:59,370 --> 00:32:03,779
dependency chaos where your dependencies

00:32:01,500 --> 00:32:05,130
can't be used because you're using the

00:32:03,779 --> 00:32:08,519
new version and they're using the old

00:32:05,130 --> 00:32:11,639
version that still works as part of this

00:32:08,519 --> 00:32:14,070
development effort there were a few

00:32:11,639 --> 00:32:16,409
working groups that were created and a

00:32:14,070 --> 00:32:18,830
few pushes for stabilizations and

00:32:16,409 --> 00:32:23,630
features were made and async/await

00:32:18,830 --> 00:32:26,610
was one of them so the idea behind it is

00:32:23,630 --> 00:32:29,330
basically the same as there's a few

00:32:26,610 --> 00:32:32,850
other languages that do it this way

00:32:29,330 --> 00:32:35,580
write code that looks like synchronous

00:32:32,850 --> 00:32:37,230
normal blocking code but which really

00:32:35,580 --> 00:32:39,809
isn't which uses an event loop in the

00:32:37,230 --> 00:32:41,730
background which you have to set up

00:32:39,809 --> 00:32:43,110
before because rust still doesn't have

00:32:41,730 --> 00:32:44,909
an implicit runtime you need to

00:32:43,110 --> 00:32:48,779
explicitly choose a runtime that you

00:32:44,909 --> 00:32:51,330
want but then instead of having to you

00:32:48,779 --> 00:32:53,299
know define the future type and thinking

00:32:51,330 --> 00:32:55,879
about what type of return value you have

00:32:53,299 --> 00:32:58,249
and the nesting like the type signatures

00:32:55,879 --> 00:33:01,249
are gonna be really gnarly and so

00:32:58,249 --> 00:33:03,350
instead you just mark a function as

00:33:01,249 --> 00:33:05,330
async that that's the idea

00:33:03,350 --> 00:33:08,210
and this async in front of the function

00:33:05,330 --> 00:33:09,889
declaration here well mean that this

00:33:08,210 --> 00:33:11,119
function first of all is kind of

00:33:09,889 --> 00:33:12,559
pointless because the trigger doesn't

00:33:11,119 --> 00:33:15,110
return anything but it would return a

00:33:12,559 --> 00:33:20,840
future of nothing instead which is

00:33:15,110 --> 00:33:24,139
interesting and then instead of having

00:33:20,840 --> 00:33:27,139
to pass this function or this function

00:33:24,139 --> 00:33:29,029
chain I guess whichever it ends up being

00:33:27,139 --> 00:33:31,070
to an event loop there is this a weight

00:33:29,029 --> 00:33:33,710
macro which you call which then

00:33:31,070 --> 00:33:35,529
interacts implicitly with the runtime

00:33:33,710 --> 00:33:39,590
that you previously set up explicitly

00:33:35,529 --> 00:33:41,059
and that way you can write code that is

00:33:39,590 --> 00:33:43,220
basically a weight this thing awaits

00:33:41,059 --> 00:33:44,840
this thing do these things like

00:33:43,220 --> 00:33:47,269
asynchronously and then await all three

00:33:44,840 --> 00:33:50,960
of them or something a lot of things

00:33:47,269 --> 00:33:53,779
become possible this way and it it

00:33:50,960 --> 00:33:56,239
generally cleans up the code that you

00:33:53,779 --> 00:34:00,289
write because you don't end up having

00:33:56,239 --> 00:34:03,499
these huge state machines because yeah

00:34:00,289 --> 00:34:05,210
they can be really cute but sometimes

00:34:03,499 --> 00:34:07,759
they'd become a little large and they

00:34:05,210 --> 00:34:12,369
become unmaintainable and this way you

00:34:07,759 --> 00:34:17,030
can avoid this so how does this work

00:34:12,369 --> 00:34:18,409
it's kind of complicated and clever

00:34:17,030 --> 00:34:21,139
people are working on it

00:34:18,409 --> 00:34:23,869
in groups you might even call them

00:34:21,139 --> 00:34:27,139
working groups which is the networking

00:34:23,869 --> 00:34:29,869
working group so this is a bunch of

00:34:27,139 --> 00:34:33,079
people either from the rust core teams

00:34:29,869 --> 00:34:34,730
themselves or peripherals so like I am

00:34:33,079 --> 00:34:38,899
in the CLI working group and I'm not on

00:34:34,730 --> 00:34:40,549
the core team who is people who

00:34:38,899 --> 00:34:43,609
implement these features in the compiler

00:34:40,549 --> 00:34:45,859
and provide a library ecosystem the way

00:34:43,609 --> 00:34:47,929
that this works is that this futures

00:34:45,859 --> 00:34:50,990
abstraction that I showed you earlier

00:34:47,929 --> 00:34:53,299
has moved into the standard lab at Lib

00:34:50,990 --> 00:34:55,879
core or parts of it have moved into Lib

00:34:53,299 --> 00:34:59,119
core of the language which means that

00:34:55,879 --> 00:35:02,380
you can use all of these features to

00:34:59,119 --> 00:35:04,190
some extent even on embedded

00:35:02,380 --> 00:35:05,869
microcontrollers where you don't have

00:35:04,190 --> 00:35:07,820
access to the standard lab because it's

00:35:05,869 --> 00:35:11,210
too big for it

00:35:07,820 --> 00:35:14,869
and then there's their certain API is

00:35:11,210 --> 00:35:17,570
that run times and like event loops can

00:35:14,869 --> 00:35:20,599
use to make themselves compatible to

00:35:17,570 --> 00:35:22,490
this to the syntax so that you actually

00:35:20,599 --> 00:35:24,920
have a have a choice which runtime you

00:35:22,490 --> 00:35:26,780
want to use you can use Tokyo if you

00:35:24,920 --> 00:35:29,450
know it's a general-purpose good runtime

00:35:26,780 --> 00:35:33,349
if you were running on some quirky

00:35:29,450 --> 00:35:35,030
embedded device you can either use an

00:35:33,349 --> 00:35:37,010
embedded runtime of one exists or if

00:35:35,030 --> 00:35:39,260
you're a company and you need to like

00:35:37,010 --> 00:35:40,910
specifically target one device you can

00:35:39,260 --> 00:35:42,950
write your own and you can still be

00:35:40,910 --> 00:35:45,440
compatible with all of the other future

00:35:42,950 --> 00:35:47,480
stuff which means that you can take you

00:35:45,440 --> 00:35:48,859
can take advantage of all the work that

00:35:47,480 --> 00:35:52,970
other people are putting into the

00:35:48,859 --> 00:35:57,130
futures ecosystem so well yeah can you

00:35:52,970 --> 00:36:00,170
use this and the answer is kind of so

00:35:57,130 --> 00:36:03,680
the async/await syntax itself is a

00:36:00,170 --> 00:36:06,050
stable or stable-ish in the nightly

00:36:03,680 --> 00:36:08,750
compiler it requires a feature flag its

00:36:06,050 --> 00:36:11,690
usage hasn't changed in the last few

00:36:08,750 --> 00:36:13,010
months and as preparation to this talk

00:36:11,690 --> 00:36:14,630
I've interviewed a few people who are

00:36:13,010 --> 00:36:17,750
working on it and they don't expect it

00:36:14,630 --> 00:36:20,300
to change very much so you know chances

00:36:17,750 --> 00:36:23,150
are that if you start writing some code

00:36:20,300 --> 00:36:24,230
using this it's not gonna break but you

00:36:23,150 --> 00:36:26,869
know you're still living a little

00:36:24,230 --> 00:36:29,830
dangerously with the nightly the problem

00:36:26,869 --> 00:36:32,690
is the library ecosystem namely that

00:36:29,830 --> 00:36:36,140
event loops are missing that useless or

00:36:32,690 --> 00:36:40,910
their usability isn't perfect yet I

00:36:36,140 --> 00:36:43,190
guess and realistically the first few

00:36:40,910 --> 00:36:46,190
months like January February March

00:36:43,190 --> 00:36:49,280
something like that in 2019 is supposed

00:36:46,190 --> 00:36:51,140
to be when this becomes stable there

00:36:49,280 --> 00:36:54,109
were a few delays throughout the year

00:36:51,140 --> 00:36:56,030
when it came to a few other blocking

00:36:54,109 --> 00:36:58,640
issues on the compiler which is why this

00:36:56,030 --> 00:37:00,290
is all a little late which means that

00:36:58,640 --> 00:37:04,700
it's not officially in this umbrella

00:37:00,290 --> 00:37:07,880
term of frost 2018 all right um and

00:37:04,700 --> 00:37:10,010
that's it I thought my talk slot would

00:37:07,880 --> 00:37:15,020
be a lot shorter than it had actually

00:37:10,010 --> 00:37:16,550
ended up being you can so I don't want

00:37:15,020 --> 00:37:18,230
to answer your question on question or

00:37:16,550 --> 00:37:20,470
questions on stage but I'm gonna be

00:37:18,230 --> 00:37:22,839
around if you want to talk to me

00:37:20,470 --> 00:37:24,519
follow me on twitter if you want to have

00:37:22,839 --> 00:37:26,950
terrible puns on technology and your

00:37:24,519 --> 00:37:28,210
feed if you're watching this remotely or

00:37:26,950 --> 00:37:31,119
you're shy and you don't want to come up

00:37:28,210 --> 00:37:33,339
to me you can send me an email or my DMS

00:37:31,119 --> 00:37:36,119
on Twitter are always open and I want to

00:37:33,339 --> 00:37:38,440
thank my employers so I do

00:37:36,119 --> 00:37:41,769
Rustom bed at work at first systems

00:37:38,440 --> 00:37:42,970
which is why I I'm really excited about

00:37:41,769 --> 00:37:44,349
some of the future stuff when it comes

00:37:42,970 --> 00:37:48,999
to embedded especially embedded

00:37:44,349 --> 00:37:50,769
networking with like low overhead TCP

00:37:48,999 --> 00:37:52,839
handling for example on a

00:37:50,769 --> 00:37:55,359
microcontroller and I also do

00:37:52,839 --> 00:37:58,089
distributed systems set up architecture

00:37:55,359 --> 00:38:00,999
and sort of like operations at a scarer

00:37:58,089 --> 00:38:03,480
which is a second company from Berlin so

00:38:00,999 --> 00:38:03,480
yeah thank you

00:38:03,790 --> 00:38:10,389

YouTube URL: https://www.youtube.com/watch?v=j0SIcN-Y-LA


