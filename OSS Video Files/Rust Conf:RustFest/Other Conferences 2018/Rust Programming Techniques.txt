Title: Rust Programming Techniques
Publication date: 2018-01-28
Playlist: Other Conferences 2018
Description: 
	Nicholas Cameron

http://lca2018.linux.org.au/schedule/presentation/22/

Rust is a language for fearless systems programming. It offers memory safety, data race freedom, and a modern programming environment, without sacrificing low-level control over performance and memory usage.

Learning a new programming language is hard. Even after mastering the syntax and type system, learning the libraries and techniques can take years. If you've read or written Rust and want to improve, this talk will give you a turbo boost! This will be a very practical tutorial, aimed at taking your Rust programming to the next level. We'll teach some core Rust design principles by covering a few key topics in depth. This tutorial is aimed at those with some Rust experience, but if you're a total beginner, you'll still learn a lot about what Rust programming is like in practice.

The tutorial will start with programming 'in the small': we'll explore some key library types (Option, Result, and Iterator) and cover practical error handling. Putting these together we'll see how to structure your control flow to write clear, succinct programs. We'll then cover some larger-scale design issues - using ownership as a primary architectural principle, and abstraction using traits.

You'll learn how to be more productive in Rust by writing clean and idiomatic code. You'll learn to work with the language rather than fighting against it.

This talk was given at Linux.conf.au 2018 (LCA2018) which was held on 22-26 January 2018 in Sydney Australia.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

#linux.conf.au #linux #foss #opensource
Captions: 
	00:00:03,470 --> 00:00:10,260
good afternoon everybody

00:00:05,339 --> 00:00:11,940
how we all doing so coming up in here we

00:00:10,260 --> 00:00:13,500
now have a workshop presented by Nick

00:00:11,940 --> 00:00:20,820
Cameron on Rus programming techniques

00:00:13,500 --> 00:00:22,800
please make him feel welcome hey thanks

00:00:20,820 --> 00:00:26,580
everybody and thanks for coming for the

00:00:22,800 --> 00:00:30,119
tutorial so I'm Nick Cameron I'm from

00:00:26,580 --> 00:00:32,579
Mozilla I'm quite involved in rust I'm I

00:00:30,119 --> 00:00:35,660
lead the tools team I'm on the compiler

00:00:32,579 --> 00:00:39,870
team the language team and the core team

00:00:35,660 --> 00:00:42,110
and today this is meant to be kind of

00:00:39,870 --> 00:00:43,829
like an intermediate level tutorial

00:00:42,110 --> 00:00:45,390
hopefully you'll still be able to get

00:00:43,829 --> 00:00:47,399
something out of it even if you're kind

00:00:45,390 --> 00:00:49,649
of a very advanced programmer in rust or

00:00:47,399 --> 00:00:51,120
you've never touched rust before I'm not

00:00:49,649 --> 00:00:52,590
going to kind of introduce the syntax

00:00:51,120 --> 00:00:55,129
but hopefully if you can program in

00:00:52,590 --> 00:01:00,539
something you'll be able to follow along

00:00:55,129 --> 00:01:02,399
I what an alternate title I played

00:01:00,539 --> 00:01:04,439
around with this talk was kind of

00:01:02,399 --> 00:01:07,080
thinking in rust and why I want you to

00:01:04,439 --> 00:01:08,760
get to what I want to help you do is to

00:01:07,080 --> 00:01:11,460
really get into kind of like the mindset

00:01:08,760 --> 00:01:12,960
of an experienced rust programmer so

00:01:11,460 --> 00:01:14,580
you're not kind of like fighting the

00:01:12,960 --> 00:01:21,500
rust compiler anymore you're kind of

00:01:14,580 --> 00:01:23,670
like working with it and winning so the

00:01:21,500 --> 00:01:26,640
it's it's mostly going to be kind of

00:01:23,670 --> 00:01:27,600
like a chalk and talk kind of tutorial I

00:01:26,640 --> 00:01:29,400
didn't realize we'd have this awesome

00:01:27,600 --> 00:01:31,770
room where you could like actually get

00:01:29,400 --> 00:01:33,450
some really proper work done but there

00:01:31,770 --> 00:01:34,560
are going to be like a few exercises but

00:01:33,450 --> 00:01:37,350
don't worry if you don't have like a

00:01:34,560 --> 00:01:39,299
rust kind of environment set up like

00:01:37,350 --> 00:01:42,090
that you can do them on pen and paper if

00:01:39,299 --> 00:01:43,560
you like and maybe even use them the

00:01:42,090 --> 00:01:45,689
compilers gonna be cheating for some of

00:01:43,560 --> 00:01:48,240
them ah

00:01:45,689 --> 00:01:50,640
and I'll stop every now and again to ask

00:01:48,240 --> 00:01:51,810
questions but please interrupt if if you

00:01:50,640 --> 00:01:54,450
don't understand something or I can

00:01:51,810 --> 00:01:55,770
clear something up for anyone don't wait

00:01:54,450 --> 00:01:57,360
until the end cuz it's quite a long

00:01:55,770 --> 00:02:02,520
tutorial and I'll have forgotten what I

00:01:57,360 --> 00:02:04,649
was talking about okay so the tutorials

00:02:02,520 --> 00:02:07,920
going to be in kind of two halves the

00:02:04,649 --> 00:02:10,050
first half is gonna be kind of

00:02:07,920 --> 00:02:12,510
programming in the small so like how to

00:02:10,050 --> 00:02:13,420
write better function bodies how to

00:02:12,510 --> 00:02:16,959
write better kind of

00:02:13,420 --> 00:02:19,500
like code the micro kind of level so

00:02:16,959 --> 00:02:23,230
gonna cover a few of the really key

00:02:19,500 --> 00:02:25,209
fundamental data types that every Russ

00:02:23,230 --> 00:02:28,750
program I'd like users will have you

00:02:25,209 --> 00:02:31,180
Russ program uses a lot I'm gonna talk

00:02:28,750 --> 00:02:33,370
about some control flow that's maybe not

00:02:31,180 --> 00:02:34,690
so familiar from other languages and

00:02:33,370 --> 00:02:37,030
then I'm gonna tell you how to like

00:02:34,690 --> 00:02:40,390
avoid doing that and write better

00:02:37,030 --> 00:02:42,340
control flow and by using kind of other

00:02:40,390 --> 00:02:46,840
constructs and some methods on these

00:02:42,340 --> 00:02:49,030
types the second half of the tutorial is

00:02:46,840 --> 00:02:50,350
gonna be kind of like programming in the

00:02:49,030 --> 00:02:52,209
large although it's more kind of like

00:02:50,350 --> 00:02:54,130
the medium are not so much gonna touch

00:02:52,209 --> 00:02:57,370
on kind of architectural issues so much

00:02:54,130 --> 00:02:59,500
is kind of like design issues how to

00:02:57,370 --> 00:03:01,360
design the kind of like data types and

00:02:59,500 --> 00:03:03,250
abstractions in your programming how to

00:03:01,360 --> 00:03:08,890
do error handling in your in your

00:03:03,250 --> 00:03:11,470
program Before we jump into all of that

00:03:08,890 --> 00:03:13,420
though I just want to kind of like talk

00:03:11,470 --> 00:03:15,190
about some principles that have gone

00:03:13,420 --> 00:03:17,410
into kind of like the design of rust and

00:03:15,190 --> 00:03:24,700
its libraries and that will kind of give

00:03:17,410 --> 00:03:29,560
a themed this tutorial safe and fast

00:03:24,700 --> 00:03:32,920
this is like the kind of the foundation

00:03:29,560 --> 00:03:35,109
of everything and rust we we want to be

00:03:32,920 --> 00:03:36,940
like a systems programming language and

00:03:35,109 --> 00:03:40,060
that means it has to be fast like as

00:03:36,940 --> 00:03:42,790
fast as C or C++ or even like hundred

00:03:40,060 --> 00:03:45,940
and assembly and a lot of cases but it

00:03:42,790 --> 00:03:48,549
has to be safe memory safety is like a

00:03:45,940 --> 00:03:50,109
big selling point and rust in this

00:03:48,549 --> 00:03:52,350
respect we kind of as safe as like a

00:03:50,109 --> 00:03:54,910
higher-level garbage-collected language

00:03:52,350 --> 00:03:57,370
but also safe in other ways we want to

00:03:54,910 --> 00:03:59,319
like avoid giving you so many options

00:03:57,370 --> 00:04:02,370
for shooting yourself in the foot as you

00:03:59,319 --> 00:04:04,959
have in some programming languages but

00:04:02,370 --> 00:04:06,459
really this is just like this I mean

00:04:04,959 --> 00:04:08,260
this would be quite cool in a language

00:04:06,459 --> 00:04:10,359
if you just have safe and fast write but

00:04:08,260 --> 00:04:13,030
actually this is just like the starting

00:04:10,359 --> 00:04:14,950
point this is like what we consider like

00:04:13,030 --> 00:04:17,229
table stakes or any kind of like new

00:04:14,950 --> 00:04:19,419
feature in the language and what we want

00:04:17,229 --> 00:04:22,090
kind of like move towards is we want

00:04:19,419 --> 00:04:23,919
kind of the the language as a whole to

00:04:22,090 --> 00:04:26,050
be kind of economic we wants it to be

00:04:23,919 --> 00:04:27,220
pleasurable to write Russ code we want

00:04:26,050 --> 00:04:30,780
it to be easy to

00:04:27,220 --> 00:04:33,970
to stand when you're reading Ross code

00:04:30,780 --> 00:04:36,760
or debugging rust code and so that's

00:04:33,970 --> 00:04:39,490
kind of like what we we want everything

00:04:36,760 --> 00:04:43,420
in rust to be where we want to end up

00:04:39,490 --> 00:04:45,250
and that's kind of like a theme for like

00:04:43,420 --> 00:04:47,110
a lot of the parts of the tutorial is

00:04:45,250 --> 00:04:49,990
I'm gonna start by showing you a kind of

00:04:47,110 --> 00:04:51,910
a basic maybe naive way of doing

00:04:49,990 --> 00:04:54,160
something in rust and sure it'll be safe

00:04:51,910 --> 00:04:56,230
and it'll be fast because hopefully

00:04:54,160 --> 00:04:58,000
everything is but then I'm gonna show

00:04:56,230 --> 00:05:01,330
you a better way to do it which will

00:04:58,000 --> 00:05:04,030
give you kind of more concise code and

00:05:01,330 --> 00:05:10,300
easier to read code and faster to write

00:05:04,030 --> 00:05:12,940
code okay so let's start throwing in the

00:05:10,300 --> 00:05:15,130
small so just to let you know what's

00:05:12,940 --> 00:05:18,130
coming up the data types are going to

00:05:15,130 --> 00:05:21,220
talk about option results and iterator

00:05:18,130 --> 00:05:23,800
and I reckon that in any given like Russ

00:05:21,220 --> 00:05:26,070
program maybe 50 percent of the types

00:05:23,800 --> 00:05:27,940
that you ever use are these three types

00:05:26,070 --> 00:05:32,169
basically so these are really kind of

00:05:27,940 --> 00:05:33,820
like fundamental to rust and in terms of

00:05:32,169 --> 00:05:35,770
control flow we're going to touch on the

00:05:33,820 --> 00:05:39,160
match statement which is a kind of

00:05:35,770 --> 00:05:43,510
pattern matching construct and iteration

00:05:39,160 --> 00:05:45,070
in just kind of it in in general I know

00:05:43,510 --> 00:05:47,200
we're not quite gonna go in this order

00:05:45,070 --> 00:05:52,960
we're gonna kind of zigzag between kind

00:05:47,200 --> 00:05:55,870
of data types and control flow okay so

00:05:52,960 --> 00:05:58,990
I'm gonna start with some C code so this

00:05:55,870 --> 00:06:01,990
is fairly idiomatic C code although it's

00:05:58,990 --> 00:06:05,950
not actually doing very much or C++

00:06:01,990 --> 00:06:08,650
sorry we're gonna take her to stern

00:06:05,950 --> 00:06:09,940
objects of type foo and of course we're

00:06:08,650 --> 00:06:12,310
good programmers so we're going to do a

00:06:09,940 --> 00:06:15,310
null check because there could be a null

00:06:12,310 --> 00:06:20,830
pointer and if it's not then we're going

00:06:15,310 --> 00:06:26,050
to call a method on this object so what

00:06:20,830 --> 00:06:27,640
could go wrong there's actually quite a

00:06:26,050 --> 00:06:29,800
lot I mean it's pretty easy to forget

00:06:27,640 --> 00:06:31,660
the null check I mean hopefully we're

00:06:29,800 --> 00:06:33,669
all excellent programmers no one here

00:06:31,660 --> 00:06:35,110
would ever forget doing a null check but

00:06:33,669 --> 00:06:37,330
it's a pretty easy mistake to make if

00:06:35,110 --> 00:06:40,060
you're a beginner and actually much more

00:06:37,330 --> 00:06:40,569
common is you don't need the null check

00:06:40,060 --> 00:06:41,919
because

00:06:40,569 --> 00:06:43,689
there is some invariant established

00:06:41,919 --> 00:06:46,960
somewhere else but of course it's code

00:06:43,689 --> 00:06:48,999
and code evolves and that invariant

00:06:46,960 --> 00:06:51,099
changes and all of a sudden you need a

00:06:48,999 --> 00:06:53,529
null check we didn't need it before but

00:06:51,099 --> 00:06:56,080
like there's no indication in the code

00:06:53,529 --> 00:07:01,029
that you need one and so nobody adds it

00:06:56,080 --> 00:07:03,729
and so you're missing the null check the

00:07:01,029 --> 00:07:06,309
this pointer variable could get mutated

00:07:03,729 --> 00:07:08,169
I mean probably not in the function as

00:07:06,309 --> 00:07:09,759
it's written at the moment but you know

00:07:08,169 --> 00:07:12,930
if this were a more complex function and

00:07:09,759 --> 00:07:15,159
especially if that variable is aliased

00:07:12,930 --> 00:07:18,879
and/or it gets passed to some other

00:07:15,159 --> 00:07:21,219
function it's actually pretty easy for a

00:07:18,879 --> 00:07:26,589
variable to get mutated without it being

00:07:21,219 --> 00:07:28,569
obvious from the from the code and

00:07:26,589 --> 00:07:30,069
pointer could be like it could be non

00:07:28,569 --> 00:07:33,550
null but it might be like otherwise

00:07:30,069 --> 00:07:35,860
invalid so I mean it could it could just

00:07:33,550 --> 00:07:37,629
be a random punch in numbers right or it

00:07:35,860 --> 00:07:39,519
could point to memory that's already

00:07:37,629 --> 00:07:41,169
been freed or to memory that's never

00:07:39,519 --> 00:07:45,459
been initialized and your null check

00:07:41,169 --> 00:07:47,499
isn't gonna catch that so here's what

00:07:45,459 --> 00:07:49,539
the same code looks like in rust and you

00:07:47,499 --> 00:07:52,539
don't have any of those problems which

00:07:49,539 --> 00:07:53,339
is nice so let me kind of explain what's

00:07:52,539 --> 00:07:55,449
going on here

00:07:53,339 --> 00:07:57,849
as you say I'm not really going to like

00:07:55,449 --> 00:07:59,499
explore in this tutorial why you're not

00:07:57,849 --> 00:08:00,819
getting all of those problems just kind

00:07:59,499 --> 00:08:04,599
of like some of them you have to set my

00:08:00,819 --> 00:08:05,680
word for it on the others so the really

00:08:04,599 --> 00:08:08,050
interesting things that are happening

00:08:05,680 --> 00:08:12,009
here let's start with the type of the

00:08:08,050 --> 00:08:15,240
points who are passing in so the amps

00:08:12,009 --> 00:08:18,219
and foo is a is a reference to foo and

00:08:15,240 --> 00:08:22,209
references are pointers but they are

00:08:18,219 --> 00:08:23,800
they can never be known okay if you want

00:08:22,209 --> 00:08:25,689
to represent a pointer that might be

00:08:23,800 --> 00:08:28,449
null you have to wrap it in this option

00:08:25,689 --> 00:08:31,899
type and an option says either you have

00:08:28,449 --> 00:08:33,819
something or you have nothing okay so

00:08:31,899 --> 00:08:35,139
it's just like a null pointer like ether

00:08:33,819 --> 00:08:37,360
it like we've got something and we're

00:08:35,139 --> 00:08:40,209
pointing all we've got zero and we're

00:08:37,360 --> 00:08:42,490
pointing at nothing except that it's

00:08:40,209 --> 00:08:44,350
explicit in the type and rust okay so

00:08:42,490 --> 00:08:49,420
you have to opt in you know that it's

00:08:44,350 --> 00:08:51,910
there and unlike a null pointer you are

00:08:49,420 --> 00:08:53,890
forced by the type system to

00:08:51,910 --> 00:08:57,460
check whether you have something on

00:08:53,890 --> 00:09:00,310
nothing if you try to just run this G

00:08:57,460 --> 00:09:02,980
method on the the PTR variable it would

00:09:00,310 --> 00:09:06,910
be a type error instead we have to use

00:09:02,980 --> 00:09:09,040
this match statement and a match does a

00:09:06,910 --> 00:09:10,480
pattern match and there are two patterns

00:09:09,040 --> 00:09:13,000
that this option can be it can either be

00:09:10,480 --> 00:09:15,730
sum or it can be none and in the son

00:09:13,000 --> 00:09:17,350
case you can go ahead and use the value

00:09:15,730 --> 00:09:21,370
that's there and you know that it's

00:09:17,350 --> 00:09:23,320
there and in the none case we do nothing

00:09:21,370 --> 00:09:25,060
and we return exactly like we would in

00:09:23,320 --> 00:09:28,420
the null check and because of the

00:09:25,060 --> 00:09:30,910
scoping in this statements it's

00:09:28,420 --> 00:09:33,730
impossible to mutate the the PTR

00:09:30,910 --> 00:09:40,060
variable once you've done the equivalent

00:09:33,730 --> 00:09:44,080
of the null check so these these two two

00:09:40,060 --> 00:09:46,240
these two key concepts option and match

00:09:44,080 --> 00:09:51,460
and it's gonna come out drill into into

00:09:46,240 --> 00:09:53,440
these a little bit so match is an

00:09:51,460 --> 00:09:57,090
exhaustive pattern matching it's a

00:09:53,440 --> 00:10:00,370
little bit like a switch statement

00:09:57,090 --> 00:10:01,900
except that we force it to be the

00:10:00,370 --> 00:10:05,050
compiler kind of like checks that will

00:10:01,900 --> 00:10:08,080
be exhaustive so here's a really simple

00:10:05,050 --> 00:10:11,770
example we've got an enum type with

00:10:08,080 --> 00:10:15,310
three variants a B and C and assume that

00:10:11,770 --> 00:10:20,500
X has type foo we're then going to match

00:10:15,310 --> 00:10:22,570
that variable and we've got the three

00:10:20,500 --> 00:10:25,060
cases either it's a either it's or it's

00:10:22,570 --> 00:10:28,540
B or at C and in each case we have a

00:10:25,060 --> 00:10:35,620
code block and we execute the you know

00:10:28,540 --> 00:10:38,560
obvious one at runtime you can use the

00:10:35,620 --> 00:10:40,090
an underscore here to say like you know

00:10:38,560 --> 00:10:42,430
we're interested in what happens if it's

00:10:40,090 --> 00:10:45,760
a and we want kind of like we interested

00:10:42,430 --> 00:10:46,930
in anything else happening and so you

00:10:45,760 --> 00:10:48,660
don't have to kind of like repeat

00:10:46,930 --> 00:10:57,220
yourself all the time

00:10:48,660 --> 00:10:58,920
and unlike a switch statement the match

00:10:57,220 --> 00:11:03,190
statement can be used as an expression

00:10:58,920 --> 00:11:04,810
so oh and also it binds variables in the

00:11:03,190 --> 00:11:05,660
pattern matching so we've changed the

00:11:04,810 --> 00:11:08,000
enum a little

00:11:05,660 --> 00:11:11,780
so now the a variant takes a value with

00:11:08,000 --> 00:11:14,330
it so either it so if we have a foo like

00:11:11,780 --> 00:11:15,980
X is meant to be a foo here then we've

00:11:14,330 --> 00:11:18,470
got three options either it's an A or

00:11:15,980 --> 00:11:20,540
it's a B or it's a C and if it's an A

00:11:18,470 --> 00:11:23,510
then it's carrying with it a 32-bit

00:11:20,540 --> 00:11:27,530
integer and so when we pattern match

00:11:23,510 --> 00:11:31,880
using the match statement in the a case

00:11:27,530 --> 00:11:35,780
we can bind this new variable n to the

00:11:31,880 --> 00:11:39,650
value and we can use that value in the

00:11:35,780 --> 00:11:43,280
code block and we can or we can kind of

00:11:39,650 --> 00:11:45,560
return it as the value of the match

00:11:43,280 --> 00:11:47,060
statement and in this case like all the

00:11:45,560 --> 00:11:51,050
branches have to have the same type so

00:11:47,060 --> 00:11:53,180
in the default case we use 0 and then we

00:11:51,050 --> 00:11:58,850
assign all that into the the variable

00:11:53,180 --> 00:12:00,560
little case food so that's a very very

00:11:58,850 --> 00:12:03,920
brief introduction to match there's a

00:12:00,560 --> 00:12:06,680
lot more that match can do you you can

00:12:03,920 --> 00:12:08,660
have quite fancy patterns you can it

00:12:06,680 --> 00:12:10,940
does deep pattern matching if you have

00:12:08,660 --> 00:12:13,250
kind of like nested types that you want

00:12:10,940 --> 00:12:15,020
to match into there are kind of if

00:12:13,250 --> 00:12:17,870
guards that you can have on the the

00:12:15,020 --> 00:12:19,370
match arms and so forth but that's if

00:12:17,870 --> 00:12:25,340
your interests in that you can can look

00:12:19,370 --> 00:12:27,020
it up the option type so we've seen can

00:12:25,340 --> 00:12:29,480
await the option type in action before

00:12:27,020 --> 00:12:31,550
the option type is not magic it's not

00:12:29,480 --> 00:12:33,080
built into the language it's just a part

00:12:31,550 --> 00:12:36,740
of the standard library and it's a

00:12:33,080 --> 00:12:40,970
perfectly ordinary enum it has two

00:12:36,740 --> 00:12:43,370
variants some none but it is generic so

00:12:40,970 --> 00:12:45,260
in the some case we have whatever we

00:12:43,370 --> 00:12:49,910
instantiate it to so before we saw we

00:12:45,260 --> 00:12:53,840
had like an integer as the type

00:12:49,910 --> 00:12:59,660
parameter and we can have any any type

00:12:53,840 --> 00:13:01,400
we want in the some case it's very easy

00:12:59,660 --> 00:13:03,230
to use because it's so common it's part

00:13:01,400 --> 00:13:05,180
of the Russ prelude that means like you

00:13:03,230 --> 00:13:07,010
don't need to import the name or quad or

00:13:05,180 --> 00:13:10,400
qualify the name when you use it you can

00:13:07,010 --> 00:13:11,900
directly use kind of the option or some

00:13:10,400 --> 00:13:15,920
or none the names of the variants

00:13:11,900 --> 00:13:18,830
directly in your Russ program and also

00:13:15,920 --> 00:13:19,680
in arms are kind of optimized cleverly

00:13:18,830 --> 00:13:22,260
by the vampire

00:13:19,680 --> 00:13:24,180
so even though you have like an option

00:13:22,260 --> 00:13:25,770
of a pointer and so this seems like it's

00:13:24,180 --> 00:13:27,120
a little bit more heavyweight than just

00:13:25,770 --> 00:13:29,010
having a pointer that might be nullable

00:13:27,120 --> 00:13:31,050
the compiler will optimize that to the

00:13:29,010 --> 00:13:33,960
same thing okay so if you know that a

00:13:31,050 --> 00:13:36,270
pointer will never be 0 which you do or

00:13:33,960 --> 00:13:39,690
sorry the compiler knows then it will

00:13:36,270 --> 00:13:42,210
optimize the the option representation

00:13:39,690 --> 00:13:45,180
in memory so that it's just a pointer

00:13:42,210 --> 00:13:48,779
and the non case is represented by the

00:13:45,180 --> 00:13:51,120
null pointer so it's some you know that

00:13:48,779 --> 00:13:57,150
works out to be just as fast and very

00:13:51,120 --> 00:13:59,339
efficient to see when you at runtime the

00:13:57,150 --> 00:14:02,220
result type is very similar to the

00:13:59,339 --> 00:14:04,410
option type it's just another generic

00:14:02,220 --> 00:14:06,930
enum the difference being that whereas

00:14:04,410 --> 00:14:09,930
with option you either have like

00:14:06,930 --> 00:14:12,120
something or you have like nothing with

00:14:09,930 --> 00:14:14,490
the result with the result type you

00:14:12,120 --> 00:14:17,040
either have something or you have an

00:14:14,490 --> 00:14:19,260
explanation of why you have nothing okay

00:14:17,040 --> 00:14:22,350
so you have like the the value type

00:14:19,260 --> 00:14:24,720
which is kind of like the success value

00:14:22,350 --> 00:14:30,630
and you have like an error type in case

00:14:24,720 --> 00:14:33,779
the an error happened so I'll just show

00:14:30,630 --> 00:14:37,770
that in action here we've got a very

00:14:33,779 --> 00:14:41,220
small slightly silly function it takes

00:14:37,770 --> 00:14:43,709
an integer and it returns a result where

00:14:41,220 --> 00:14:46,860
the success value is an integer and the

00:14:43,709 --> 00:14:48,420
error value the error type is a string

00:14:46,860 --> 00:14:51,779
in this case it's just gonna be a

00:14:48,420 --> 00:14:53,250
message about what went wrong and we're

00:14:51,779 --> 00:14:56,430
going to use the pattern matching

00:14:53,250 --> 00:14:59,700
construct match again on the input and

00:14:56,430 --> 00:15:01,440
if it's a positive integer we're going

00:14:59,700 --> 00:15:04,290
to return success and we're going to add

00:15:01,440 --> 00:15:05,880
10 to the input and if it's negative

00:15:04,290 --> 00:15:07,940
then we're going to give you an error

00:15:05,880 --> 00:15:07,940
message

00:15:11,300 --> 00:15:21,630
and then here you see how we would use

00:15:14,660 --> 00:15:24,150
this kind of function so we call on the

00:15:21,630 --> 00:15:27,030
second line in the main function we're

00:15:24,150 --> 00:15:32,370
going to call that function and we're

00:15:27,030 --> 00:15:34,080
going to get back either a success with

00:15:32,370 --> 00:15:36,270
an integer all we're going to get back

00:15:34,080 --> 00:15:38,940
the strength and we're going to use

00:15:36,270 --> 00:15:41,040
match and we're going to give a message

00:15:38,940 --> 00:15:45,510
to the user that's appropriate in in

00:15:41,040 --> 00:15:46,950
each case so just look is it clear to

00:15:45,510 --> 00:16:10,950
everyone what's happening in this code

00:15:46,950 --> 00:16:14,280
does anyone do I need to explain bits no

00:16:10,950 --> 00:16:16,640
reason like I mean success is kind of

00:16:14,280 --> 00:16:20,700
the sorry I should repeat the question

00:16:16,640 --> 00:16:23,550
the question is why why are the type

00:16:20,700 --> 00:16:26,310
parameters in the order te and not ET

00:16:23,550 --> 00:16:28,980
that is success type failure type and

00:16:26,310 --> 00:16:30,630
not failure type success type and the

00:16:28,980 --> 00:16:31,980
order of type parameters in Rus is not

00:16:30,630 --> 00:16:33,630
really important doesn't signify

00:16:31,980 --> 00:16:35,880
anything like we don't have any kind of

00:16:33,630 --> 00:16:38,070
currying or anything so like it

00:16:35,880 --> 00:16:40,800
basically doesn't matter what order the

00:16:38,070 --> 00:16:44,970
type parameters are in and given that

00:16:40,800 --> 00:16:48,750
like success is more common than like

00:16:44,970 --> 00:16:53,720
error hopefully and so that's the order

00:16:48,750 --> 00:16:53,720
it's in any other yep

00:16:54,830 --> 00:16:58,340
so the question is is there any

00:16:56,270 --> 00:17:00,740
significance to the exclamation mark yes

00:16:58,340 --> 00:17:04,010
so an exclamation mark means that this

00:17:00,740 --> 00:17:09,410
is a macro usage rather than a function

00:17:04,010 --> 00:17:11,600
call so you so print line is a macro not

00:17:09,410 --> 00:17:14,180
a function and whenever you use a macro

00:17:11,600 --> 00:17:16,730
you have to use an exclamation mark the

00:17:14,180 --> 00:17:18,560
reason for that is that there are things

00:17:16,730 --> 00:17:21,949
that a macro can do that a function call

00:17:18,560 --> 00:17:24,920
can't do for example a macro can hide a

00:17:21,949 --> 00:17:26,480
return so you know print line prop isn't

00:17:24,920 --> 00:17:29,630
gonna return out to your function but

00:17:26,480 --> 00:17:31,460
like other macros might do so it's to

00:17:29,630 --> 00:17:33,770
make it clear when you're reading like

00:17:31,460 --> 00:17:36,710
that the invariants around you know what

00:17:33,770 --> 00:17:41,240
you can assume this is going to do of

00:17:36,710 --> 00:17:48,740
are different any other questions for

00:17:41,240 --> 00:17:51,410
move them excellent okay so the result

00:17:48,740 --> 00:17:53,540
type is absolutely central to rust error

00:17:51,410 --> 00:17:56,570
handling essentially it is rust error

00:17:53,540 --> 00:17:59,410
handling story we're going to go into a

00:17:56,570 --> 00:18:01,940
little bit of detail right now about how

00:17:59,410 --> 00:18:03,200
you can use it ergonomically and then

00:18:01,940 --> 00:18:04,730
we're going to see a bit later in the

00:18:03,200 --> 00:18:06,710
talk about kind of like designing error

00:18:04,730 --> 00:18:11,950
handling but its result that's really

00:18:06,710 --> 00:18:14,630
important okay and so what you often see

00:18:11,950 --> 00:18:16,850
a function signature which looks like

00:18:14,630 --> 00:18:19,670
this like it returns a result of T in

00:18:16,850 --> 00:18:22,340
and arrow type and the kind of way the

00:18:19,670 --> 00:18:24,770
way to read that is that it returns a

00:18:22,340 --> 00:18:27,590
team the success case or it can throw

00:18:24,770 --> 00:18:30,230
this kind of like error this is not

00:18:27,590 --> 00:18:35,840
valid rust syntax but maybe will evolve

00:18:30,230 --> 00:18:38,270
to something similar to this soon and I

00:18:35,840 --> 00:18:40,220
think it's worth making kind of like or

00:18:38,270 --> 00:18:41,930
comparing to kind of like error handling

00:18:40,220 --> 00:18:44,720
mechanisms in other languages if you're

00:18:41,930 --> 00:18:45,740
kind of like a die-hard C program out

00:18:44,720 --> 00:18:48,680
then you're probably used to kind of

00:18:45,740 --> 00:18:51,740
like return codes and result basically

00:18:48,680 --> 00:18:53,540
works like that except that you're

00:18:51,740 --> 00:18:56,080
forced to check it in the same way that

00:18:53,540 --> 00:18:59,120
you're forced to check for null pointers

00:18:56,080 --> 00:19:01,429
so you can imagine you know the these

00:18:59,120 --> 00:19:03,950
are the error codes like in when you get

00:19:01,429 --> 00:19:05,720
like your arrow type but like the you

00:19:03,950 --> 00:19:06,480
know if you have success then you get

00:19:05,720 --> 00:19:08,429
the

00:19:06,480 --> 00:19:12,029
the success value passed back at the

00:19:08,429 --> 00:19:15,299
same time you can also see this kind of

00:19:12,029 --> 00:19:18,929
like analogous elite exception types and

00:19:15,299 --> 00:19:21,980
Java or C++ except that there's when we

00:19:18,929 --> 00:19:24,330
kind of throw an error there's kind of

00:19:21,980 --> 00:19:25,890
nothing special is happening in the

00:19:24,330 --> 00:19:28,590
language there's no stack unwinding

00:19:25,890 --> 00:19:36,779
whatever else it's just a a regular

00:19:28,590 --> 00:19:40,970
return from a function so I want to

00:19:36,779 --> 00:19:44,940
introduce a few bits of control flomax

00:19:40,970 --> 00:19:48,350
that make it easier to use types like

00:19:44,940 --> 00:19:50,600
result so it's pretty common to see

00:19:48,350 --> 00:19:54,419
idioms like this with the match

00:19:50,600 --> 00:19:57,240
statement where we call some function or

00:19:54,419 --> 00:19:59,730
we do some work and if it's if there's

00:19:57,240 --> 00:20:02,960
success then we do something with the

00:19:59,730 --> 00:20:04,860
value that was that we got back and

00:20:02,960 --> 00:20:06,299
otherwise we're just gonna do nothing

00:20:04,860 --> 00:20:07,860
actually this is probably more common

00:20:06,299 --> 00:20:09,120
with option than with result you

00:20:07,860 --> 00:20:11,010
probably want to handle your error and

00:20:09,120 --> 00:20:16,380
not just do nothing although that's a

00:20:11,010 --> 00:20:18,870
strategy but this is this is common

00:20:16,380 --> 00:20:21,149
nevertheless and so we have a special

00:20:18,870 --> 00:20:23,250
construct which does essentially kind of

00:20:21,149 --> 00:20:26,309
non-exhaustive pattern matching which is

00:20:23,250 --> 00:20:31,830
a flat so if let matches just a single

00:20:26,309 --> 00:20:33,630
pattern so here like the we've got like

00:20:31,830 --> 00:20:36,480
a result type and so we're gonna match

00:20:33,630 --> 00:20:38,669
like the okay pattern and so if you've

00:20:36,480 --> 00:20:40,289
got kind of okay we're gonna do

00:20:38,669 --> 00:20:42,899
something with the value we got and it

00:20:40,289 --> 00:20:45,330
binds the the variable I in the same way

00:20:42,899 --> 00:20:51,539
as match does and if it's not that then

00:20:45,330 --> 00:20:54,809
we're just going to carry on here's

00:20:51,539 --> 00:20:56,789
another somewhat common idiom in rust

00:20:54,809 --> 00:20:59,130
which is actually more common with

00:20:56,789 --> 00:21:03,029
result type we're going to call a

00:20:59,130 --> 00:21:05,669
function again like we had H before and

00:21:03,029 --> 00:21:07,440
if it's okay we're gonna do something

00:21:05,669 --> 00:21:09,330
with the variable I and if there's an

00:21:07,440 --> 00:21:11,940
error we're not going to try and handle

00:21:09,330 --> 00:21:13,830
it we're just gonna throw it again and

00:21:11,940 --> 00:21:16,049
assume that I caller can handle it in

00:21:13,830 --> 00:21:17,940
some way I'm assuming the return type of

00:21:16,049 --> 00:21:19,179
the function here is is result otherwise

00:21:17,940 --> 00:21:30,820
this wouldn't work

00:21:19,179 --> 00:21:35,200
ah this one or this one okay okay so

00:21:30,820 --> 00:21:38,200
like the if flat is kind of a single

00:21:35,200 --> 00:21:43,210
keyword and then okay I as a pattern and

00:21:38,200 --> 00:21:45,669
then equals just as an equals and then

00:21:43,210 --> 00:21:47,769
we've got an expression which will be

00:21:45,669 --> 00:21:49,389
executed and then we try and match the

00:21:47,769 --> 00:21:52,779
result of that expression against the

00:21:49,389 --> 00:21:56,229
pattern and if it matches then we do the

00:21:52,779 --> 00:22:04,119
block so it's it has exactly the same

00:21:56,229 --> 00:22:08,469
semantics as this okay so here's here's

00:22:04,119 --> 00:22:11,669
this other idiom where we we are we the

00:22:08,469 --> 00:22:14,139
take the success or we throw the error

00:22:11,669 --> 00:22:17,549
and actually it's more common to write

00:22:14,139 --> 00:22:20,139
this like like like this and rust where

00:22:17,549 --> 00:22:23,859
we're using the kind of like expression

00:22:20,139 --> 00:22:27,190
or inside version of the match statement

00:22:23,859 --> 00:22:28,839
and we either binding into a local

00:22:27,190 --> 00:22:30,549
variable if we had success or we're

00:22:28,839 --> 00:22:33,339
throwing the error to be dealt with

00:22:30,549 --> 00:22:34,899
elsewhere and this is such a common

00:22:33,339 --> 00:22:37,119
idiom in rust that we have some

00:22:34,899 --> 00:22:39,999
extremely sweet syntax to deal with it

00:22:37,119 --> 00:22:42,369
which is this so when you see like this

00:22:39,999 --> 00:22:44,619
postfix question mark operator that's

00:22:42,369 --> 00:22:48,089
basically doing exactly that match right

00:22:44,619 --> 00:22:51,249
if we it was successful then we keep the

00:22:48,089 --> 00:22:52,359
we keep that variable bind it into I and

00:22:51,249 --> 00:22:54,669
then we can do something with it

00:22:52,359 --> 00:22:58,269
and if there was an error we throw that

00:22:54,669 --> 00:23:00,450
for our caller to deal with okay so this

00:22:58,269 --> 00:23:03,450
question mark

00:23:00,450 --> 00:23:03,450
sure

00:23:04,920 --> 00:23:25,930
and this becomes this yeah okay so

00:23:23,410 --> 00:23:30,160
repeat the question what happens if the

00:23:25,930 --> 00:23:31,390
return types are different so it doesn't

00:23:30,160 --> 00:23:33,610
matter what it will do

00:23:31,390 --> 00:23:36,250
type adjustment yes is the short answer

00:23:33,610 --> 00:23:39,310
it will can it doesn't matter what the

00:23:36,250 --> 00:23:40,750
tears and actually the ease can be

00:23:39,310 --> 00:23:42,460
different as well as long as the

00:23:40,750 --> 00:23:45,490
compiler can find a way to convert one

00:23:42,460 --> 00:23:47,140
into the other and it's kind of beyond

00:23:45,490 --> 00:24:13,360
this tour to talk about how we do that

00:23:47,140 --> 00:24:14,860
but it can be done yes yes I mean I I

00:24:13,360 --> 00:24:18,660
think it's probably easier to kind of

00:24:14,860 --> 00:24:21,739
like look lit like this in that like the

00:24:18,660 --> 00:24:21,739
[Music]

00:24:22,080 --> 00:24:28,750
yeah like if the error case is still

00:24:26,620 --> 00:24:30,940
kind of like wrapped in the result and

00:24:28,750 --> 00:24:32,560
will be be thrown because the return

00:24:30,940 --> 00:24:36,340
type for the function has to be result

00:24:32,560 --> 00:24:38,680
not with the arrow type whereas if we

00:24:36,340 --> 00:24:40,480
want to use the value then there's no

00:24:38,680 --> 00:24:42,550
point about keeping it in side the

00:24:40,480 --> 00:24:45,840
result because we know it must be like

00:24:42,550 --> 00:24:45,840
okay at this one okay

00:24:57,040 --> 00:25:07,040
result-type yes so we're not so the

00:25:04,430 --> 00:25:09,710
unwrapping kind of happens at the patent

00:25:07,040 --> 00:25:11,570
level so it's the the unwrapping is not

00:25:09,710 --> 00:25:14,030
part of the the whole match statement

00:25:11,570 --> 00:25:16,660
the unwrapping is like because we're

00:25:14,030 --> 00:25:20,090
matching the okay pattern then we're

00:25:16,660 --> 00:25:21,710
unlike by by matching it we're kind of

00:25:20,090 --> 00:25:24,620
doing the unwrapping and we're left with

00:25:21,710 --> 00:25:26,330
the I was on the earth case so I

00:25:24,620 --> 00:25:28,430
probably should have used the better

00:25:26,330 --> 00:25:32,330
that's that's a local variable called

00:25:28,430 --> 00:25:33,740
not capital e of which is the name of

00:25:32,330 --> 00:25:38,420
the variant and so there's no unwrapping

00:25:33,740 --> 00:25:50,990
happening on that case there's a

00:25:38,420 --> 00:25:52,520
question over here somewhere so the

00:25:50,990 --> 00:25:54,380
question is this looks a little bit like

00:25:52,520 --> 00:25:56,450
a macro shouldn't there be like an

00:25:54,380 --> 00:25:57,950
exclamation right so the the history of

00:25:56,450 --> 00:26:00,500
this is it used to be a macro it used to

00:25:57,950 --> 00:26:03,050
be called tri exclamation mark and was

00:26:00,500 --> 00:26:05,360
was a macro and we're on earth question

00:26:03,050 --> 00:26:10,370
mark for reasons I'll discuss kind of on

00:26:05,360 --> 00:26:13,760
the next slide and basically it like

00:26:10,370 --> 00:26:15,950
it's not a macro and so it doesn't need

00:26:13,760 --> 00:26:17,720
it and if you're looking for like all

00:26:15,950 --> 00:26:19,700
the places a function can return while

00:26:17,720 --> 00:26:21,050
you look for the return keyword you look

00:26:19,700 --> 00:26:22,460
for an exclamation mark and you look for

00:26:21,050 --> 00:26:24,380
a question mark and if you see these

00:26:22,460 --> 00:26:29,510
bits of punctuation then you know it

00:26:24,380 --> 00:26:37,750
could return and if not it can't Oh what

00:26:29,510 --> 00:26:37,750
so no we do not have that

00:26:40,669 --> 00:26:53,340
videos I will talk about unwrapped a

00:26:51,450 --> 00:27:00,380
little bit later the short story is you

00:26:53,340 --> 00:27:03,299
should never use it okay so this is the

00:27:00,380 --> 00:27:06,929
simple kind of syntax for question mark

00:27:03,299 --> 00:27:09,179
and you often see it in chains of method

00:27:06,929 --> 00:27:10,890
calls or field lookups like this where

00:27:09,179 --> 00:27:12,630
you know if you did the matching

00:27:10,890 --> 00:27:14,580
explicitly this would be like I don't

00:27:12,630 --> 00:27:16,500
know ten lines of code and it'd be

00:27:14,580 --> 00:27:18,900
really hard to follow what's actually

00:27:16,500 --> 00:27:20,970
happening here but in this case you can

00:27:18,900 --> 00:27:23,309
actually see quite clearly what's the

00:27:20,970 --> 00:27:24,809
you know what's the kind of control flow

00:27:23,309 --> 00:27:28,350
what's happening here it's just a chain

00:27:24,809 --> 00:27:30,270
of method calls but if you want to know

00:27:28,350 --> 00:27:32,700
what the exceptional control flow looks

00:27:30,270 --> 00:27:35,159
like it's explicit here like exactly

00:27:32,700 --> 00:27:38,640
where you might be kind of throwing out

00:27:35,159 --> 00:27:40,320
of this function and so the question

00:27:38,640 --> 00:27:42,419
marks this really nice compromise in

00:27:40,320 --> 00:27:45,000
that it's extremely lightweight so you

00:27:42,419 --> 00:27:47,250
can quite easily see what the kind of

00:27:45,000 --> 00:27:49,409
common case control flow is doing but it

00:27:47,250 --> 00:27:52,679
is explicit and so if you need to know

00:27:49,409 --> 00:28:00,570
like every possible path of control you

00:27:52,679 --> 00:28:01,950
can see it right so having kind of

00:28:00,570 --> 00:28:03,690
talked about various kind of like

00:28:01,950 --> 00:28:05,220
control flow constructs I want to now

00:28:03,690 --> 00:28:09,570
show you ways you can avoid using them

00:28:05,220 --> 00:28:11,610
at all okay so there is a lot of methods

00:28:09,570 --> 00:28:13,320
on the option and result types or not

00:28:11,610 --> 00:28:14,850
don't have anywhere near enough time to

00:28:13,320 --> 00:28:17,700
cover them all here but you should look

00:28:14,850 --> 00:28:19,650
at the documentation I think kind of

00:28:17,700 --> 00:28:21,450
like mastering these things is a really

00:28:19,650 --> 00:28:24,870
important step to kind of like writing

00:28:21,450 --> 00:28:28,100
kind of clean elegant code and rust I'm

00:28:24,870 --> 00:28:30,299
gonna that there's kind of like a

00:28:28,100 --> 00:28:32,100
symmetry between the option and result

00:28:30,299 --> 00:28:33,659
types so I'm only going to cover option

00:28:32,100 --> 00:28:36,179
but pretty much everything I cover here

00:28:33,659 --> 00:28:39,890
exist for results as well either exactly

00:28:36,179 --> 00:28:39,890
the same or in some variation

00:28:41,899 --> 00:28:49,679
so here's kind of a common thing that

00:28:46,649 --> 00:28:51,419
you often want to do so sorry look at

00:28:49,679 --> 00:28:55,950
the second function this kind of maybe

00:28:51,419 --> 00:28:58,470
add four so we're gonna pass in either

00:28:55,950 --> 00:29:00,570
an integer or not an integer like

00:28:58,470 --> 00:29:02,690
nothing at all and if we get the integer

00:29:00,570 --> 00:29:05,190
then we want to add 4 to it and then

00:29:02,690 --> 00:29:07,200
return that and if there's nothing there

00:29:05,190 --> 00:29:09,240
we're just gonna return nothing okay so

00:29:07,200 --> 00:29:12,299
this is kind of like a really common way

00:29:09,240 --> 00:29:15,870
it's kind of like unpack do something

00:29:12,299 --> 00:29:18,480
repack and we can express this really

00:29:15,870 --> 00:29:22,140
simply and rust with the map function

00:29:18,480 --> 00:29:25,980
method so this is a method on the option

00:29:22,140 --> 00:29:27,480
type and so it can it's if there's

00:29:25,980 --> 00:29:29,789
something that then it applies the

00:29:27,480 --> 00:29:31,350
function that we passed to it and if

00:29:29,789 --> 00:29:35,340
it's not if there's nothing there we

00:29:31,350 --> 00:29:36,870
just pass none out of it and actually

00:29:35,340 --> 00:29:40,080
it's much more common to see kind of

00:29:36,870 --> 00:29:41,640
this closure form where the the function

00:29:40,080 --> 00:29:44,429
we're going to apply is written in line

00:29:41,640 --> 00:29:46,200
as a closure and even if this syntax is

00:29:44,429 --> 00:29:47,909
a little bit kind of funky if you're

00:29:46,200 --> 00:29:53,429
coming from C then it should be kind of

00:29:47,909 --> 00:29:55,500
clear what's going on here X is the what

00:29:53,429 --> 00:29:57,419
we've we've got an option if we indeed

00:29:55,500 --> 00:30:03,600
have anything at all and then we're

00:29:57,419 --> 00:30:11,840
going to return X plus 4 so is it clear

00:30:03,600 --> 00:30:11,840
to everyone what's going on yeah yes

00:30:13,560 --> 00:30:19,650
yes so I'll show this on the next slide

00:30:19,860 --> 00:30:27,580
yep it does sorry the question is why

00:30:26,140 --> 00:30:30,160
doesn't the question mark work for the

00:30:27,580 --> 00:30:32,470
option type and it does and you could

00:30:30,160 --> 00:30:34,360
use that here but it would actually be a

00:30:32,470 --> 00:30:35,650
little bit less sin for doing it this

00:30:34,360 --> 00:30:39,940
way because you would have to do the

00:30:35,650 --> 00:30:42,220
repacking yourself so you have to you

00:30:39,940 --> 00:30:49,920
know put the the sum in there whereas

00:30:42,220 --> 00:30:49,920
that's done as part of the map here yeah

00:31:01,410 --> 00:31:05,920
so the question is given that you have

00:31:03,940 --> 00:31:09,130
liked this map function why have the

00:31:05,920 --> 00:31:12,370
question mark operator as well it just

00:31:09,130 --> 00:31:13,900
leads to like better control flow like

00:31:12,370 --> 00:31:18,130
when you when you have this really

00:31:13,900 --> 00:31:20,320
common case of like the chains like this

00:31:18,130 --> 00:31:23,200
with the question mark it's really easy

00:31:20,320 --> 00:31:25,540
to read like what's going on here like a

00:31:23,200 --> 00:31:39,490
set of kind of like nested map calls is

00:31:25,540 --> 00:31:41,380
just not as clear no it's a short answer

00:31:39,490 --> 00:31:43,690
we don't have high kind of tight so the

00:31:41,380 --> 00:31:46,380
question was is there like some kind of

00:31:43,690 --> 00:31:51,160
syntax for doing this in general I guess

00:31:46,380 --> 00:31:53,770
like do syntax in Haskell and the answer

00:31:51,160 --> 00:31:56,110
is no we don't have higher kind of types

00:31:53,770 --> 00:31:58,660
and rust we can't really express like

00:31:56,110 --> 00:32:00,850
the the concepts of kind of like do in

00:31:58,660 --> 00:32:02,880
the more general case so we have stuff

00:32:00,850 --> 00:32:06,420
like the question mark operator and

00:32:02,880 --> 00:32:06,420
functions as a replacement

00:32:07,380 --> 00:32:13,200
okay I lost my place where do we get up

00:32:10,620 --> 00:32:15,000
to okay yeah I was gonna show you the

00:32:13,200 --> 00:32:17,789
function signature form app which I had

00:32:15,000 --> 00:32:20,429
a question about just now so looking at

00:32:17,789 --> 00:32:22,110
the the function signature hopefully

00:32:20,429 --> 00:32:23,910
it's kind of clear what's going on here

00:32:22,110 --> 00:32:29,220
even though it's not the clearest

00:32:23,910 --> 00:32:31,470
function signature if we look we see the

00:32:29,220 --> 00:32:34,440
first argument itself we have to be

00:32:31,470 --> 00:32:36,720
explicit in rust about taking a cell for

00:32:34,440 --> 00:32:39,860
this argument so that just basically

00:32:36,720 --> 00:32:44,250
shows that it's a method with a receiver

00:32:39,860 --> 00:32:45,630
we see that we take a function and if

00:32:44,250 --> 00:32:48,870
you look at the where clause you see the

00:32:45,630 --> 00:32:52,020
type of that function don't worry about

00:32:48,870 --> 00:32:55,110
the details but like the the essential

00:32:52,020 --> 00:32:59,820
bit is we're mapping T to you where T is

00:32:55,110 --> 00:33:02,220
the type parameter for the receiver and

00:32:59,820 --> 00:33:05,880
you is the type parameter of the option

00:33:02,220 --> 00:33:07,830
that we return so in the example here T

00:33:05,880 --> 00:33:09,390
and u are the same they're both i-32

00:33:07,830 --> 00:33:12,350
but there's no reason they have to be

00:33:09,390 --> 00:33:12,350
the same in general

00:33:19,030 --> 00:33:23,080
okay so I want to look at some other

00:33:21,130 --> 00:33:24,370
methods and I'm going to go over there's

00:33:23,080 --> 00:33:28,960
a bit more quickly and I'm just going to

00:33:24,370 --> 00:33:31,230
show you the type signatures so one kind

00:33:28,960 --> 00:33:35,950
of intuitive way you can think of

00:33:31,230 --> 00:33:39,100
optional result types is like a like a

00:33:35,950 --> 00:33:41,590
boolean where if you've got saw more

00:33:39,100 --> 00:33:44,110
okay it's true and if you've got nothing

00:33:41,590 --> 00:33:46,630
or error then it's false with that

00:33:44,110 --> 00:33:50,380
interpretation then it makes sense to

00:33:46,630 --> 00:33:52,480
want to and or all these things together

00:33:50,380 --> 00:33:59,530
and indeed we have these functions so

00:33:52,480 --> 00:34:03,370
and takes another option and we can look

00:33:59,530 --> 00:34:07,450
at the two and if both of those are true

00:34:03,370 --> 00:34:11,669
like some then we're going to return the

00:34:07,450 --> 00:34:15,070
the second one that we passed in and if

00:34:11,669 --> 00:34:19,149
either of them is none like false then

00:34:15,070 --> 00:34:23,500
we return none similarly or does exactly

00:34:19,149 --> 00:34:25,720
what you would expect these are actually

00:34:23,500 --> 00:34:27,070
kind of like more useful if you think

00:34:25,720 --> 00:34:30,070
about these well like maybe a more kind

00:34:27,070 --> 00:34:34,570
of practical programming terms so and is

00:34:30,070 --> 00:34:38,290
kind of like map except where what

00:34:34,570 --> 00:34:40,990
you're sorry I have skipped ahead

00:34:38,290 --> 00:34:43,060
I should before getting to this I should

00:34:40,990 --> 00:34:45,520
introduce that they're like the and and

00:34:43,060 --> 00:34:47,230
the or are kind of eager versions of and

00:34:45,520 --> 00:34:50,200
and or and that there are also kind of

00:34:47,230 --> 00:34:52,120
like lazy versions of and and or so and

00:34:50,200 --> 00:34:53,950
then or else you can think of the

00:34:52,120 --> 00:34:58,770
boolean operations and and all but the

00:34:53,950 --> 00:35:02,920
short-circuiting kind so and then takes

00:34:58,770 --> 00:35:05,620
function and if the the receiver is none

00:35:02,920 --> 00:35:08,860
we never execute that function but if

00:35:05,620 --> 00:35:12,340
the receiver is some then we unwrap the

00:35:08,860 --> 00:35:15,070
receiver pass it to this function and if

00:35:12,340 --> 00:35:16,990
that function gives you some then that's

00:35:15,070 --> 00:35:21,040
the results of the hole and then

00:35:16,990 --> 00:35:22,930
function similarly like or else takes a

00:35:21,040 --> 00:35:24,730
function and if the receiver is

00:35:22,930 --> 00:35:26,620
something then it never executes s--

00:35:24,730 --> 00:35:31,210
whereas if it's nothing then we ask you

00:35:26,620 --> 00:35:32,080
the function and then you can think like

00:35:31,210 --> 00:35:34,900
and then

00:35:32,080 --> 00:35:36,880
is exactly like mapping but where the

00:35:34,900 --> 00:35:39,850
function that we're mapping can actually

00:35:36,880 --> 00:35:41,710
return a nun right rather than always

00:35:39,850 --> 00:35:45,520
succeeding where we would wrap it back

00:35:41,710 --> 00:35:48,040
up in the map case and then lets you

00:35:45,520 --> 00:35:51,820
execute a function that might return

00:35:48,040 --> 00:35:54,210
something I might return nothing but

00:35:51,820 --> 00:35:57,010
handles like the nun case to start with

00:35:54,210 --> 00:35:58,720
similarly or else you can think oh well

00:35:57,010 --> 00:36:00,790
or as well you can think of being like

00:35:58,720 --> 00:36:04,000
about having a default value so it's

00:36:00,790 --> 00:36:06,160
saying if if this is something then

00:36:04,000 --> 00:36:08,980
great I'll just you keep using it if

00:36:06,160 --> 00:36:10,750
it's if there's nothing there then I'm

00:36:08,980 --> 00:36:15,070
going to execute this function or use

00:36:10,750 --> 00:36:17,260
this value and and that's kind of like

00:36:15,070 --> 00:36:19,150
the default I'm going to going to use so

00:36:17,260 --> 00:36:21,220
these are both like really common really

00:36:19,150 --> 00:36:23,830
useful functions for on the option and

00:36:21,220 --> 00:36:25,810
result types and there's this pattern

00:36:23,830 --> 00:36:28,480
that often you have they're kind of like

00:36:25,810 --> 00:36:29,920
eager and lazy versions where the eager

00:36:28,480 --> 00:36:33,400
version takes of value and the lazy

00:36:29,920 --> 00:36:40,120
version takes the function that'll be

00:36:33,400 --> 00:36:42,100
executed if necessary okay okay

00:36:40,120 --> 00:36:43,630
before I it so this is probably another

00:36:42,100 --> 00:36:53,860
good point to ask if people have

00:36:43,630 --> 00:36:57,640
questions on on these methods know the

00:36:53,860 --> 00:37:00,250
type parameter is on the option so it

00:36:57,640 --> 00:37:03,270
all requires the argument that's passed

00:37:00,250 --> 00:37:05,620
I have the same type parameter as the

00:37:03,270 --> 00:37:12,010
the receiver was that's not the case

00:37:05,620 --> 00:37:16,150
with hand okay cool so another couple of

00:37:12,010 --> 00:37:18,310
methods so I said before option and

00:37:16,150 --> 00:37:19,900
results are fairly similar and it's

00:37:18,310 --> 00:37:21,370
often extremely common that you will

00:37:19,900 --> 00:37:24,160
want to convert between them and so

00:37:21,370 --> 00:37:25,960
there are methods to convert from an

00:37:24,160 --> 00:37:30,910
option to a result and vice versa

00:37:25,960 --> 00:37:34,840
so okay or turns an option into a result

00:37:30,910 --> 00:37:37,030
and you the the all bit is because you

00:37:34,840 --> 00:37:38,830
have to supply like the error case if it

00:37:37,030 --> 00:37:41,530
was if there was nothing there and

00:37:38,830 --> 00:37:44,180
there's a there's like a lazy version

00:37:41,530 --> 00:37:47,150
okay or else of this

00:37:44,180 --> 00:37:48,349
it sir is a way to convert an option

00:37:47,150 --> 00:37:51,650
into an iterator

00:37:48,349 --> 00:37:53,869
so if boolean is one intuition you can

00:37:51,650 --> 00:37:55,819
have an option type you can also think

00:37:53,869 --> 00:37:57,710
of an option type as a collection it's

00:37:55,819 --> 00:37:59,420
kind of like a list which always have

00:37:57,710 --> 00:38:02,540
zero or one elements in it

00:37:59,420 --> 00:38:04,339
so given this intuition of like a list

00:38:02,540 --> 00:38:07,010
of zero one elements then you might want

00:38:04,339 --> 00:38:08,869
to iterate over those elements and so it

00:38:07,010 --> 00:38:10,880
gives you an iterator back and we'll see

00:38:08,869 --> 00:38:15,079
kind of like more details of the

00:38:10,880 --> 00:38:19,190
iterator next okay so time for an

00:38:15,079 --> 00:38:22,329
exercise basically here are two

00:38:19,190 --> 00:38:27,849
functions these are written kind of

00:38:22,329 --> 00:38:29,930
badly so write them really well is the

00:38:27,849 --> 00:38:32,030
exercise there's a link in the top right

00:38:29,930 --> 00:38:34,700
corner for the documentation you might

00:38:32,030 --> 00:38:38,359
find it handy to look up the the docs

00:38:34,700 --> 00:38:40,010
for for option in order to do this we

00:38:38,359 --> 00:38:41,510
can figure figure this out I'm just

00:38:40,010 --> 00:38:42,980
going to give you a couple of minutes to

00:38:41,510 --> 00:38:46,510
do and if you have any questions that

00:38:42,980 --> 00:38:46,510
you along just stick up your hand

00:39:06,120 --> 00:39:11,340
but I'm gonna interrupt because I'm

00:39:09,210 --> 00:39:14,250
already slightly over time sorry

00:39:11,340 --> 00:39:16,770
but I want to go through what we're what

00:39:14,250 --> 00:39:24,150
we've talked about so I'm just going to

00:39:16,770 --> 00:39:27,540
go through the first function first so

00:39:24,150 --> 00:39:30,810
this if input it's none returned none

00:39:27,540 --> 00:39:33,170
and then unwrap the input well we can do

00:39:30,810 --> 00:39:36,930
this much quicker using a try operator

00:39:33,170 --> 00:39:38,880
sorry the question mark operator so that

00:39:36,930 --> 00:39:41,280
this is exactly what's happened in this

00:39:38,880 --> 00:39:43,530
version but if we keep reading a little

00:39:41,280 --> 00:39:46,830
bit further down then we see that like

00:39:43,530 --> 00:39:49,170
in we're then doing like an if test and

00:39:46,830 --> 00:39:51,000
we're gonna return none and otherwise

00:39:49,170 --> 00:39:52,620
we're gonna wrap it all back up in a sum

00:39:51,000 --> 00:39:55,260
so that suggests that we can do even

00:39:52,620 --> 00:39:57,630
better we can use the and then function

00:39:55,260 --> 00:40:00,810
that I talked about before rather than

00:39:57,630 --> 00:40:02,370
like the the try operator so this is

00:40:00,810 --> 00:40:04,320
doing like an implicit check and whether

00:40:02,370 --> 00:40:07,560
it's some or none and then we're

00:40:04,320 --> 00:40:11,490
returning none if we're we're less than

00:40:07,560 --> 00:40:13,860
zero and actually if you're using

00:40:11,490 --> 00:40:15,390
nightly rust you can do even better than

00:40:13,860 --> 00:40:17,130
that because there's a function that

00:40:15,390 --> 00:40:20,660
hasn't been stabilized in the standard

00:40:17,130 --> 00:40:23,970
library yet called filter which does

00:40:20,660 --> 00:40:26,520
what and then was doing like with some

00:40:23,970 --> 00:40:28,230
or none but then applies a predicate to

00:40:26,520 --> 00:40:32,610
the value if there was something there

00:40:28,230 --> 00:40:34,800
and effectively kind of like those and

00:40:32,610 --> 00:40:39,080
then returns like some if the predicate

00:40:34,800 --> 00:40:39,080
is true and none if it's if it's false

00:40:39,860 --> 00:40:47,630
okay so the second function is a bit

00:40:44,880 --> 00:40:52,590
simpler it just has a match statement

00:40:47,630 --> 00:40:56,160
where and it calls the previous function

00:40:52,590 --> 00:40:58,710
which returns an option and it gives you

00:40:56,160 --> 00:41:02,130
an okay result or it gives you an error

00:40:58,710 --> 00:41:06,660
and this can quite easily be mapped onto

00:41:02,130 --> 00:41:08,640
the okay or function that we talked

00:41:06,660 --> 00:41:11,700
about earlier this is just converting

00:41:08,640 --> 00:41:14,700
from the option type into the result

00:41:11,700 --> 00:41:18,740
type so does anyone have any questions

00:41:14,700 --> 00:41:18,740
about the exercise before we move on

00:41:21,210 --> 00:41:28,150
okay great

00:41:22,870 --> 00:41:30,690
so on to iteration and iterators so I

00:41:28,150 --> 00:41:33,100
want to start again with an example in C

00:41:30,690 --> 00:41:36,580
we've got a ping all function this is

00:41:33,100 --> 00:41:40,120
going to take an array of some type foo

00:41:36,580 --> 00:41:42,730
it also needs to take the length of that

00:41:40,120 --> 00:41:45,940
array it's gonna iterate over that

00:41:42,730 --> 00:41:47,710
arrays and standard C for loop and then

00:41:45,940 --> 00:41:50,170
it's gonna index into that array and

00:41:47,710 --> 00:41:58,930
call some ping function on every element

00:41:50,170 --> 00:42:00,790
of the array what could go wrong so that

00:41:58,930 --> 00:42:02,710
length might just be wrong right who

00:42:00,790 --> 00:42:03,700
knows who's calling this function right

00:42:02,710 --> 00:42:06,330
there's nothing that says they're gonna

00:42:03,700 --> 00:42:09,580
get this right

00:42:06,330 --> 00:42:11,710
the array could actually be mutated

00:42:09,580 --> 00:42:13,270
inside the loop we could be adding

00:42:11,710 --> 00:42:16,390
something on to the end or taking

00:42:13,270 --> 00:42:18,310
something away or changing things or

00:42:16,390 --> 00:42:22,360
what have you the counter variable could

00:42:18,310 --> 00:42:23,800
be mutated I mean not in it that would

00:42:22,360 --> 00:42:25,570
be an obvious error in a simple loop

00:42:23,800 --> 00:42:27,520
like this but in more complicated loops

00:42:25,570 --> 00:42:29,170
especially if you're mutating the thing

00:42:27,520 --> 00:42:31,990
you're iterating over then it's kind of

00:42:29,170 --> 00:42:33,820
common to mutate the counter you could

00:42:31,990 --> 00:42:36,310
have some logic errors so a really

00:42:33,820 --> 00:42:39,010
simple one would be you know starting at

00:42:36,310 --> 00:42:41,860
one rather than zero or using less than

00:42:39,010 --> 00:42:43,330
or equal to rather than less than these

00:42:41,860 --> 00:42:44,890
are probably pretty obvious hopefully

00:42:43,330 --> 00:42:47,530
they'd get caught in code of view but

00:42:44,890 --> 00:42:50,350
who knows and certainly once you start

00:42:47,530 --> 00:42:52,390
having like nested iteration or you're

00:42:50,350 --> 00:42:54,460
iterating over multiple arrays or you're

00:42:52,390 --> 00:42:56,410
going backwards rather than forwards or

00:42:54,460 --> 00:42:58,900
you're stepping over multiple elements

00:42:56,410 --> 00:43:02,770
at a time it gets much much easier to

00:42:58,900 --> 00:43:05,740
make this kind of logic error finally

00:43:02,770 --> 00:43:07,390
this array is just a pointer and so it

00:43:05,740 --> 00:43:10,750
could be null and we'd into a null check

00:43:07,390 --> 00:43:12,580
and it could be otherwise invalid in the

00:43:10,750 --> 00:43:15,880
same way that a pointer could be so

00:43:12,580 --> 00:43:16,930
there's a lot that could go wrong here's

00:43:15,880 --> 00:43:19,450
the version in rust

00:43:16,930 --> 00:43:20,020
so hopefully the type looks kind of

00:43:19,450 --> 00:43:22,300
similar

00:43:20,020 --> 00:43:24,370
unlike see the type includes the length

00:43:22,300 --> 00:43:26,080
and so we don't need to separately pass

00:43:24,370 --> 00:43:27,440
the length so that's one thing that

00:43:26,080 --> 00:43:30,450
can't go wrong

00:43:27,440 --> 00:43:32,670
iterating over it is like a much simpler

00:43:30,450 --> 00:43:36,300
expression it's a for-loop but it's not

00:43:32,670 --> 00:43:37,980
like a c4 loop we're just gonna this is

00:43:36,300 --> 00:43:42,780
going to bind the variable F to each

00:43:37,980 --> 00:43:45,030
elements in Fu's in sequence and then

00:43:42,780 --> 00:43:49,100
we're gonna call this ping function on

00:43:45,030 --> 00:43:52,590
it so this is already like much better

00:43:49,100 --> 00:43:54,869
hopefully you all agree but actually

00:43:52,590 --> 00:43:56,460
it's kind of uncommon to even see like

00:43:54,869 --> 00:43:58,800
four loops for this kind of single

00:43:56,460 --> 00:44:00,720
simple case because there's a whole

00:43:58,800 --> 00:44:02,040
bunch of functions on iterators just

00:44:00,720 --> 00:44:04,080
like there's a whole bunch of functions

00:44:02,040 --> 00:44:07,140
on option and result that let you write

00:44:04,080 --> 00:44:08,790
kind of like much more succinct code so

00:44:07,140 --> 00:44:10,619
here we explicitly have to ask for an

00:44:08,790 --> 00:44:12,540
iterate over the array using the inter

00:44:10,619 --> 00:44:15,330
function and then there's a for each

00:44:12,540 --> 00:44:23,850
function which just executes the

00:44:15,330 --> 00:44:25,619
function for each element so having got

00:44:23,850 --> 00:44:27,119
this kind of like taste what's going on

00:44:25,619 --> 00:44:33,480
I want to kind of like oh yeah sorry

00:44:27,119 --> 00:44:34,920
question so the sorry the question is

00:44:33,480 --> 00:44:42,930
what's the benefit of using for each

00:44:34,920 --> 00:44:44,340
rather than for its so the I can I want

00:44:42,930 --> 00:44:45,869
to make the general point that when we

00:44:44,340 --> 00:44:47,760
see like other functions that I'm going

00:44:45,869 --> 00:44:49,350
to introduce next then it gives you kind

00:44:47,760 --> 00:44:51,480
of like a nicer kind of control flow

00:44:49,350 --> 00:44:55,980
it's more explicit about exactly what's

00:44:51,480 --> 00:44:58,410
going on with for each there's not a lot

00:44:55,980 --> 00:45:00,600
of benefit over using for like it's a

00:44:58,410 --> 00:45:02,640
it's a more secend construction if

00:45:00,600 --> 00:45:04,230
you're not doing if you if you know if

00:45:02,640 --> 00:45:06,150
this was gonna be like a 10 line

00:45:04,230 --> 00:45:08,280
closure I would say use a for loop if

00:45:06,150 --> 00:45:10,650
it's just like a real simple thing like

00:45:08,280 --> 00:45:12,270
this then it's easier to read the code

00:45:10,650 --> 00:45:14,480
if you use for each it's just on one

00:45:12,270 --> 00:45:14,480
line

00:45:16,930 --> 00:45:23,589
okay let's look at some methods on the

00:45:19,990 --> 00:45:25,710
iterator type so option and result were

00:45:23,589 --> 00:45:27,460
concrete types I showed you the the

00:45:25,710 --> 00:45:29,710
definitions that are in the standard

00:45:27,460 --> 00:45:31,240
library iterator as a trait and we're

00:45:29,710 --> 00:45:35,140
going to cover traits like at the end of

00:45:31,240 --> 00:45:37,089
this talk but what the important thing

00:45:35,140 --> 00:45:39,339
is that like iterator is kind of like an

00:45:37,089 --> 00:45:41,319
interface of which there are many many

00:45:39,339 --> 00:45:43,329
concrete implementations you may even

00:45:41,319 --> 00:45:47,050
write your own it's common to write your

00:45:43,329 --> 00:45:48,700
own in rust code and that for various

00:45:47,050 --> 00:45:50,230
reasons that means that actually looking

00:45:48,700 --> 00:45:51,790
at the signatures these functions is not

00:45:50,230 --> 00:45:53,500
very useful so I'm going to do this all

00:45:51,790 --> 00:45:58,420
by example rather than by showing you

00:45:53,500 --> 00:46:03,579
the signature okay it's so a vac and

00:45:58,420 --> 00:46:04,750
rust is just a resizable array so here

00:46:03,579 --> 00:46:07,059
we're just going to create our back

00:46:04,750 --> 00:46:08,200
we're going to call it iran it's got an

00:46:07,059 --> 00:46:11,950
iterator and then we're going to use

00:46:08,200 --> 00:46:13,990
some functions so map just like map on

00:46:11,950 --> 00:46:16,480
option applies this function to every

00:46:13,990 --> 00:46:20,920
elements of the it's razor and then

00:46:16,480 --> 00:46:22,900
gives you a new iterator filter applies

00:46:20,920 --> 00:46:24,460
the predicate and if it's true it keeps

00:46:22,900 --> 00:46:27,549
it and if it's false

00:46:24,460 --> 00:46:30,760
dumps it so this gives you a iterator

00:46:27,549 --> 00:46:32,470
that's the same size or shorter and then

00:46:30,760 --> 00:46:35,470
for each we've already seen what for

00:46:32,470 --> 00:46:38,710
each does it just execute this function

00:46:35,470 --> 00:46:43,299
on all of these so what's the output

00:46:38,710 --> 00:46:46,799
going to be here you can have a think or

00:46:43,299 --> 00:46:46,799
shout it out if you're feeling brave

00:46:47,760 --> 00:46:54,869
yeah so we just going to prints out two

00:46:52,329 --> 00:46:54,869
three and four

00:46:57,170 --> 00:47:00,440
okay another couple of functions this

00:46:59,089 --> 00:47:03,890
time we're going to use a for loop as

00:47:00,440 --> 00:47:05,779
well so it's actually pretty common to

00:47:03,890 --> 00:47:07,609
kind of like gas an iterator and

00:47:05,779 --> 00:47:11,269
manipulate the iterator in some way and

00:47:07,609 --> 00:47:14,180
then use a for loop to iterate over the

00:47:11,269 --> 00:47:16,609
iterator if you like so we're going to

00:47:14,180 --> 00:47:18,200
use the chain function so chain takes

00:47:16,609 --> 00:47:20,390
two iterators and change them together

00:47:18,200 --> 00:47:22,609
so you got a new iterator that iterates

00:47:20,390 --> 00:47:24,140
over all the first element all the

00:47:22,609 --> 00:47:27,460
elements in the first iterator and then

00:47:24,140 --> 00:47:30,619
all the elements in the second iterator

00:47:27,460 --> 00:47:32,269
enumerate well sometimes I mean so in

00:47:30,619 --> 00:47:34,160
the for loop we saw earlier there's no

00:47:32,269 --> 00:47:36,200
counter variable sometimes you want a

00:47:34,160 --> 00:47:37,730
counter variable right it's useful so

00:47:36,200 --> 00:47:39,710
enumerate gives you a way to give that

00:47:37,730 --> 00:47:42,880
back so enumerate takes an iterator and

00:47:39,710 --> 00:47:46,490
then gives you back an iterator which is

00:47:42,880 --> 00:47:48,589
an iterator over pairs of the counter

00:47:46,490 --> 00:47:52,640
variable and the value from the original

00:47:48,589 --> 00:47:54,680
iterator and so that's when we see the

00:47:52,640 --> 00:47:56,660
for loop doing some kind of basic

00:47:54,680 --> 00:47:59,059
pattern matching on the left hand side

00:47:56,660 --> 00:48:01,730
here so I is the count value and V is

00:47:59,059 --> 00:48:04,849
the the value from that we're iterating

00:48:01,730 --> 00:48:08,029
over and then again we're going to like

00:48:04,849 --> 00:48:18,230
print stuff out so what do we think it's

00:48:08,029 --> 00:48:22,119
gonna get printed out this time yes just

00:48:18,230 --> 00:48:22,119
pop up what's gonna get printed out

00:48:24,070 --> 00:48:30,580
okay finally the collect methods like

00:48:28,600 --> 00:48:33,670
we've gone from a collection like a

00:48:30,580 --> 00:48:34,990
vector into an iterator but often you

00:48:33,670 --> 00:48:36,700
want to go back you've done your

00:48:34,990 --> 00:48:39,520
iteration and you want to collect back

00:48:36,700 --> 00:48:41,200
down into a collection so in the first

00:48:39,520 --> 00:48:41,890
example here we're going to get our

00:48:41,200 --> 00:48:44,290
iterator

00:48:41,890 --> 00:48:46,060
we're gonna run map we've seen map just

00:48:44,290 --> 00:48:48,430
now and then we're going to get a new

00:48:46,060 --> 00:48:51,100
vector which is kind of all the results

00:48:48,430 --> 00:48:52,960
that we've tucked that we've got and

00:48:51,100 --> 00:48:54,970
then in the second example we're going

00:48:52,960 --> 00:48:56,530
to do map again but then we're going to

00:48:54,970 --> 00:48:59,380
run in numerate and so this is going to

00:48:56,530 --> 00:49:01,480
give us an iterator of counter variables

00:48:59,380 --> 00:49:03,820
and value pairs and then we're going to

00:49:01,480 --> 00:49:06,910
collect into a hash map so we're going

00:49:03,820 --> 00:49:10,450
to get a map from the counter variables

00:49:06,910 --> 00:49:12,280
to the values and the fact that these

00:49:10,450 --> 00:49:14,170
are two quite different things gives you

00:49:12,280 --> 00:49:16,840
a hint that collect is quite a smart

00:49:14,170 --> 00:49:19,600
little function and exactly how it

00:49:16,840 --> 00:49:21,160
behaves depends on the the type that

00:49:19,600 --> 00:49:24,490
you're expecting and that's why we need

00:49:21,160 --> 00:49:26,410
to put some explicit types on the

00:49:24,490 --> 00:49:28,890
variable declarations even though

00:49:26,410 --> 00:49:32,950
usually in rust we can just infer these

00:49:28,890 --> 00:49:35,590
and the the output is going to be like a

00:49:32,950 --> 00:49:41,000
vector and the hash map with these

00:49:35,590 --> 00:49:43,730
values question

00:49:41,000 --> 00:49:46,490
a hat so question is are there any

00:49:43,730 --> 00:49:51,100
lazier taters and all these raters are

00:49:46,490 --> 00:49:55,510
lazy or most of the iterators are lazy

00:49:51,100 --> 00:49:58,130
yes and there's kind of like there's

00:49:55,510 --> 00:50:01,250
functions for taking like a certain

00:49:58,130 --> 00:50:02,930
segment of that yeah so when I say like

00:50:01,250 --> 00:50:04,820
this takes one iterator and gives you

00:50:02,930 --> 00:50:07,640
another one that's actually not what

00:50:04,820 --> 00:50:09,920
happens it happens lazily when you kind

00:50:07,640 --> 00:50:20,480
of like call one of the terminating

00:50:09,920 --> 00:50:27,710
functions like collapse or 4-h okay well

00:50:20,480 --> 00:50:30,200
I have a question so we have this back

00:50:27,710 --> 00:50:32,660
right and we've seen two ways we can

00:50:30,200 --> 00:50:34,640
iterate over it and I think intuitively

00:50:32,660 --> 00:50:37,040
these are very similar you can see why

00:50:34,640 --> 00:50:39,470
these might correspond but it's kind of

00:50:37,040 --> 00:50:42,230
odd that these are maybe not as close as

00:50:39,470 --> 00:50:44,630
you might be expecting right like the in

00:50:42,230 --> 00:50:46,430
the first case we have to explicitly get

00:50:44,630 --> 00:50:48,800
an iterator and in the second case we

00:50:46,430 --> 00:50:55,280
done but we do have an extra ampersand

00:50:48,800 --> 00:50:58,100
in there so what exactly is the for loop

00:50:55,280 --> 00:51:00,530
expecting like a for loop is built into

00:50:58,100 --> 00:51:02,840
the language is a is it expecting a

00:51:00,530 --> 00:51:04,640
vector but we saw an array earlier and

00:51:02,840 --> 00:51:09,740
we saw kind of some iterator stuff as

00:51:04,640 --> 00:51:12,410
well so what's what's going on here okay

00:51:09,740 --> 00:51:15,170
so let's start at the beginning like

00:51:12,410 --> 00:51:17,300
this this vak macro this creating a

00:51:15,170 --> 00:51:22,370
vector for us the type of that is

00:51:17,300 --> 00:51:24,470
capital v vac this is not kind of an

00:51:22,370 --> 00:51:26,120
iterator which is why in the first

00:51:24,470 --> 00:51:30,620
expression you have to call it sir to

00:51:26,120 --> 00:51:33,620
actually get an iterator but the vac

00:51:30,620 --> 00:51:35,780
type does implement into iterator which

00:51:33,620 --> 00:51:40,400
is a trait and we'll see what that gives

00:51:35,780 --> 00:51:42,950
you in a second but actually there are

00:51:40,400 --> 00:51:45,320
multiple implementations so there's

00:51:42,950 --> 00:51:48,890
actually an implementation for just vac

00:51:45,320 --> 00:51:52,490
which gives you an iterator over the

00:51:48,890 --> 00:51:54,190
values in fact and as an iterator for a

00:51:52,490 --> 00:51:56,590
reference to vac which

00:51:54,190 --> 00:52:00,100
- an iterator over a reference to each

00:51:56,590 --> 00:52:03,610
value in the vac and seeing us in our

00:52:00,100 --> 00:52:06,400
for loop we we don't want to kind of use

00:52:03,610 --> 00:52:08,590
up that vac we won't have access to it

00:52:06,400 --> 00:52:10,630
afterwards it's it's pretty common that

00:52:08,590 --> 00:52:13,480
you want to get the the references and

00:52:10,630 --> 00:52:16,870
so that ampersand before the vac ensures

00:52:13,480 --> 00:52:18,310
that we get the the implementation of

00:52:16,870 --> 00:52:21,280
into iterator which is going to give an

00:52:18,310 --> 00:52:26,260
iterator over the references rather than

00:52:21,280 --> 00:52:27,970
values and what is into iterator do into

00:52:26,260 --> 00:52:31,900
iterator house like a single function

00:52:27,970 --> 00:52:34,060
which just turns the receiver ah I

00:52:31,900 --> 00:52:36,160
forgot the South bit sorry that should

00:52:34,060 --> 00:52:38,980
be in to iterate sort of intuitive self

00:52:36,160 --> 00:52:44,380
and so it turns that receiver into an

00:52:38,980 --> 00:52:46,360
iterator and then the iterator trait it

00:52:44,380 --> 00:52:47,470
has a lot of functions I've been talking

00:52:46,360 --> 00:52:50,200
about some of them there's an awful lot

00:52:47,470 --> 00:52:52,330
more but the one that you actually the

00:52:50,200 --> 00:52:55,060
really kind of like key function is this

00:52:52,330 --> 00:52:57,430
next function and it returns an option

00:52:55,060 --> 00:52:59,440
we've seen option already and what

00:52:57,430 --> 00:53:01,540
happens is if the iterator has been used

00:52:59,440 --> 00:53:03,880
up we return none because there's

00:53:01,540 --> 00:53:10,180
nothing left to give otherwise we return

00:53:03,880 --> 00:53:12,460
the next element as a Sun so you might

00:53:10,180 --> 00:53:14,710
have an inkling of how this is gonna fit

00:53:12,460 --> 00:53:16,270
together but let's kind of like explore

00:53:14,710 --> 00:53:16,960
a little bit more so I talked about if

00:53:16,270 --> 00:53:19,830
lat

00:53:16,960 --> 00:53:22,360
there's a control flow statement before

00:53:19,830 --> 00:53:25,600
so it's just pattern matching and if we

00:53:22,360 --> 00:53:28,180
match the pattern and we execute the

00:53:25,600 --> 00:53:30,640
block there's also while lat

00:53:28,180 --> 00:53:33,370
so while light does exactly like if flat

00:53:30,640 --> 00:53:35,620
except it keeps doing it so while lat

00:53:33,370 --> 00:53:38,110
says while I can match this pattern

00:53:35,620 --> 00:53:40,690
execute the block and keep going and

00:53:38,110 --> 00:53:46,090
then when I can no longer match that

00:53:40,690 --> 00:53:47,980
pattern then I stop so this is

00:53:46,090 --> 00:53:51,460
essentially what the for code for loop

00:53:47,980 --> 00:53:52,870
boils down to we run into it so to get

00:53:51,460 --> 00:53:55,480
ourselves an iterator and then we

00:53:52,870 --> 00:53:58,480
repeatedly call it a dot next and whilst

00:53:55,480 --> 00:54:00,700
that returns a some variant we execute

00:53:58,480 --> 00:54:05,320
the body of the the loop and if it

00:54:00,700 --> 00:54:07,780
returns none then we stop but that's not

00:54:05,320 --> 00:54:10,660
the end of the story as we

00:54:07,780 --> 00:54:12,910
before with flats then you can rewrite

00:54:10,660 --> 00:54:14,890
that with match so similarly like with

00:54:12,910 --> 00:54:17,920
violet we can reduce this to even more

00:54:14,890 --> 00:54:20,470
primitive constructs but you need to

00:54:17,920 --> 00:54:23,020
know that their exists loop which takes

00:54:20,470 --> 00:54:24,790
no arguments and just loops forever it's

00:54:23,020 --> 00:54:27,520
an infinite loop and also the rust has a

00:54:24,790 --> 00:54:29,710
break statement and so I'm going to get

00:54:27,520 --> 00:54:34,960
you all to do this as an exercise which

00:54:29,710 --> 00:54:37,300
is can you write the this while lat

00:54:34,960 --> 00:54:39,760
loop that we had before to do iteration

00:54:37,300 --> 00:54:41,050
using these more basic constructs so

00:54:39,760 --> 00:54:45,750
just give you a couple of minutes to do

00:54:41,050 --> 00:54:45,750
that okay

00:54:46,869 --> 00:54:52,220
so hopefully you had some fun with this

00:54:49,700 --> 00:54:57,829
I want to kind of like just show you

00:54:52,220 --> 00:55:02,089
what the solution looks like quickly so

00:54:57,829 --> 00:55:04,880
we still need to kind of run the into

00:55:02,089 --> 00:55:06,440
iterate it into is earth function to get

00:55:04,880 --> 00:55:07,940
ourselves an iterator then we've all

00:55:06,440 --> 00:55:10,130
this infinite loop and we've got a match

00:55:07,940 --> 00:55:11,690
that will break out if there's nothing

00:55:10,130 --> 00:55:14,720
left on the iterator otherwise we're

00:55:11,690 --> 00:55:16,599
going to like a sign into a local

00:55:14,720 --> 00:55:19,730
variable and this should hopefully

00:55:16,599 --> 00:55:22,250
remind you a little bit of where we saw

00:55:19,730 --> 00:55:27,140
the question mark it operated earlier

00:55:22,250 --> 00:55:29,780
and the idiom that led to that so just

00:55:27,140 --> 00:55:31,400
to summarize like where we've we've come

00:55:29,780 --> 00:55:34,849
from here like we're looking at the for

00:55:31,400 --> 00:55:37,400
loop and I've shown you kind of how you

00:55:34,849 --> 00:55:41,059
can think of the for loop like getting

00:55:37,400 --> 00:55:43,460
rid of this implicit so a for loop works

00:55:41,059 --> 00:55:46,670
over an iterator it takes any any

00:55:43,460 --> 00:55:49,940
iterator and then by using kind of wild

00:55:46,670 --> 00:55:51,559
lap I've shown you how explicitly we're

00:55:49,940 --> 00:55:53,750
kind of getting that iterator and then

00:55:51,559 --> 00:55:56,690
iterating over it and then shown how

00:55:53,750 --> 00:55:59,869
like while that itself is can be thought

00:55:56,690 --> 00:56:01,250
of in even lower level terms the second

00:55:59,869 --> 00:56:03,500
part of it is probably not too useful

00:56:01,250 --> 00:56:05,900
but it is often useful in your Rusco to

00:56:03,500 --> 00:56:08,690
be able to use while lat for kind of

00:56:05,900 --> 00:56:11,480
various complex kinds of iterations so

00:56:08,690 --> 00:56:15,770
that's really nice things kind of having

00:56:11,480 --> 00:56:18,109
you in your toolbox okay so that's the

00:56:15,770 --> 00:56:20,329
end of the the first half of the the

00:56:18,109 --> 00:56:23,690
too-tall it's been slightly more than

00:56:20,329 --> 00:56:25,240
half the time but never mind and in the

00:56:23,690 --> 00:56:30,680
next section we're going to talk about

00:56:25,240 --> 00:56:32,990
programming in the large ish so we're

00:56:30,680 --> 00:56:34,910
going to talk about error handling we're

00:56:32,990 --> 00:56:37,460
gonna talk about ownership primarily

00:56:34,910 --> 00:56:39,530
like as a design principle and we're

00:56:37,460 --> 00:56:45,069
gonna talk about traits if we have

00:56:39,530 --> 00:56:45,069
enough time so error handling

00:56:46,150 --> 00:56:53,420
so my my my first and most important

00:56:51,140 --> 00:56:55,910
point I think is that you should think

00:56:53,420 --> 00:56:58,610
of error handling as an architectural

00:56:55,910 --> 00:57:00,110
concern in your program from earlier

00:56:58,610 --> 00:57:02,840
that means you have to think about it

00:57:00,110 --> 00:57:04,490
really early in the design process so

00:57:02,840 --> 00:57:07,490
when you're thinking you know should

00:57:04,490 --> 00:57:12,040
this app run on a server or should it

00:57:07,490 --> 00:57:14,720
have a GUI or should it have like a

00:57:12,040 --> 00:57:16,790
restful api like when you're making that

00:57:14,720 --> 00:57:18,740
level of architectural decisions you

00:57:16,790 --> 00:57:20,750
also want to be thinking about you know

00:57:18,740 --> 00:57:25,730
what is the error handling story gonna

00:57:20,750 --> 00:57:27,410
be for this piece of software and in

00:57:25,730 --> 00:57:29,240
this section we're gonna go over the

00:57:27,410 --> 00:57:35,150
kind of decisions you'd be making as

00:57:29,240 --> 00:57:37,340
part of that so we talked about results

00:57:35,150 --> 00:57:40,370
earlier I told you result was kind of

00:57:37,340 --> 00:57:42,350
like the fundamental part of the a

00:57:40,370 --> 00:57:48,620
fundamental part of rusts error handling

00:57:42,350 --> 00:57:50,300
story so we've basically kind of I've

00:57:48,620 --> 00:57:53,120
been showing you all this code that uses

00:57:50,300 --> 00:57:55,460
a result but whenever like we've got the

00:57:53,120 --> 00:57:58,520
error type who's basically kind of like

00:57:55,460 --> 00:58:01,310
you know ignored that so what should you

00:57:58,520 --> 00:58:04,640
do when you get this when you get the

00:58:01,310 --> 00:58:08,120
error case of your result you have a few

00:58:04,640 --> 00:58:13,640
options the first option is that you're

00:58:08,120 --> 00:58:15,380
able to recover somehow so often a way

00:58:13,640 --> 00:58:17,180
to recover is like you can pick an

00:58:15,380 --> 00:58:18,860
appropriate default value so you know

00:58:17,180 --> 00:58:20,570
that if this thing succeeded you've got

00:58:18,860 --> 00:58:23,140
a value and if it didn't succeed then

00:58:20,570 --> 00:58:25,460
there's a default value I can use

00:58:23,140 --> 00:58:27,170
there's if you were paying attention

00:58:25,460 --> 00:58:29,770
earlier you could write this more

00:58:27,170 --> 00:58:35,500
succinctly using like an okay or

00:58:29,770 --> 00:58:40,040
function ah sorry

00:58:35,500 --> 00:58:42,170
unwrap or function some people think

00:58:40,040 --> 00:58:44,000
that an appropriate way to recover from

00:58:42,170 --> 00:58:50,090
an error is to give it to the user and

00:58:44,000 --> 00:58:52,610
this is wrong you'd like it might at

00:58:50,090 --> 00:58:55,280
some points in your program be

00:58:52,610 --> 00:58:57,140
appropriate to alert the the user that

00:58:55,280 --> 00:58:59,150
there has been an error and maybe the

00:58:57,140 --> 00:59:03,160
error the user can give you some input

00:58:59,150 --> 00:59:05,990
to help recover from that the mistake is

00:59:03,160 --> 00:59:09,340
and presumably what is going on here is

00:59:05,990 --> 00:59:12,890
that like your actual arrow types are

00:59:09,340 --> 00:59:14,900
internal for the to the program it you

00:59:12,890 --> 00:59:16,850
should almost never actually show your

00:59:14,900 --> 00:59:18,140
internal arrow types to the user this is

00:59:16,850 --> 00:59:21,950
almost certainly going to give a bad

00:59:18,140 --> 00:59:23,380
user experience if you're going to do

00:59:21,950 --> 00:59:26,180
this you need some kind of like

00:59:23,380 --> 00:59:29,510
dedicated code in your in your software

00:59:26,180 --> 00:59:31,670
that handles the the internal arrow type

00:59:29,510 --> 00:59:33,500
and gives you like you know user

00:59:31,670 --> 00:59:37,460
interface over that that you're going to

00:59:33,500 --> 00:59:39,830
present the user okay it's option number

00:59:37,460 --> 00:59:42,560
two is to just wreath row so we've seen

00:59:39,830 --> 00:59:45,980
this before we've seen this is what the

00:59:42,560 --> 00:59:48,410
question mark operator is for this is

00:59:45,980 --> 00:59:50,450
like in I mean this particular function

00:59:48,410 --> 00:59:52,760
and I don't know how to recover from

00:59:50,450 --> 00:59:55,070
this era so I'm going to just throw it

00:59:52,760 --> 00:59:58,070
up the stack and hope that my caller or

00:59:55,070 --> 01:00:03,140
their caller and so on will be able to

00:59:58,070 --> 01:00:05,510
handle it oh yeah that's the yeah

01:00:03,140 --> 01:00:08,110
question mark operator the third option

01:00:05,510 --> 01:00:11,660
is that you can panic so a panic is a

01:00:08,110 --> 01:00:14,750
controlled crash in in rust so it

01:00:11,660 --> 01:00:18,200
crashes the current threat but it does

01:00:14,750 --> 01:00:20,600
so by it does so kind of like cleanly by

01:00:18,200 --> 01:00:24,080
unwinding the stack so destructors will

01:00:20,600 --> 01:00:26,480
get called and this isn't a seg fault

01:00:24,080 --> 01:00:28,250
it's not exploitable and you can

01:00:26,480 --> 01:00:33,500
actually catch this panic or you can

01:00:28,250 --> 01:00:34,670
catch it at thread boundaries it's you

01:00:33,500 --> 01:00:37,930
you don't net this doesn't necessarily

01:00:34,670 --> 01:00:40,370
have to crash your entire process and

01:00:37,930 --> 01:00:42,170
you can explicitly do that using the

01:00:40,370 --> 01:00:45,590
panic macro but it's much more common to

01:00:42,170 --> 01:00:50,060
use the unwrapped or expect functions on

01:00:45,590 --> 01:00:52,580
an optional error where they if it's if

01:00:50,060 --> 01:00:58,220
it's okay then we unwrap and if it's not

01:00:52,580 --> 01:01:00,980
okay then we panic so these are your

01:00:58,220 --> 01:01:03,560
three options so the first two options

01:01:00,980 --> 01:01:05,390
are like actual error handling and the

01:01:03,560 --> 01:01:08,840
third option is not error handling

01:01:05,390 --> 01:01:11,640
basically and it's acceptable to do that

01:01:08,840 --> 01:01:14,640
sometimes like if you're writing like

01:01:11,640 --> 01:01:17,040
a very experimental bit of code then

01:01:14,640 --> 01:01:20,490
maybe it's okay but really we should be

01:01:17,040 --> 01:01:22,710
doing one of the first two and so the

01:01:20,490 --> 01:01:26,040
obvious question it becomes like which

01:01:22,710 --> 01:01:28,260
of those two should I do

01:01:26,040 --> 01:01:31,020
so an intuition I want to try and get

01:01:28,260 --> 01:01:34,380
across is about kind of the modularity

01:01:31,020 --> 01:01:39,900
of error handling and so I want it like

01:01:34,380 --> 01:01:42,690
think of think of your code in terms of

01:01:39,900 --> 01:01:44,640
kind of error modules now these are not

01:01:42,690 --> 01:01:46,800
like this is not a rust concept this is

01:01:44,640 --> 01:01:50,310
not like something that's actually

01:01:46,800 --> 01:01:52,170
explicit in your code and an error

01:01:50,310 --> 01:01:53,640
module could be smaller than a rust

01:01:52,170 --> 01:01:56,550
module but more commonly it would be

01:01:53,640 --> 01:01:58,410
bigger than a rusts module I mean quite

01:01:56,550 --> 01:02:02,070
common is like your error module fits

01:01:58,410 --> 01:02:08,910
with a whole crate and an error module

01:02:02,070 --> 01:02:11,610
like is so within that error module you

01:02:08,910 --> 01:02:13,520
have context specific ways that you can

01:02:11,610 --> 01:02:16,680
recover from the errors that happen

01:02:13,520 --> 01:02:21,570
whereas outside there's no way that you

01:02:16,680 --> 01:02:23,460
can recover like in a in a kind of local

01:02:21,570 --> 01:02:25,080
kind of way and so you instead you want

01:02:23,460 --> 01:02:27,960
to present enough information so that

01:02:25,080 --> 01:02:29,760
you can do kind of like try something

01:02:27,960 --> 01:02:31,830
else completely instead so to give you a

01:02:29,760 --> 01:02:35,670
little example of this like imagine that

01:02:31,830 --> 01:02:37,890
you're doing some network i/o okay so

01:02:35,670 --> 01:02:39,570
within your error module then this might

01:02:37,890 --> 01:02:41,790
be as small as a single function right

01:02:39,570 --> 01:02:44,160
like you're gonna try to use this

01:02:41,790 --> 01:02:47,370
connection and maybe you'll get like a

01:02:44,160 --> 01:02:49,590
woodblock error back from your system

01:02:47,370 --> 01:02:52,860
call or maybe you've got a you know

01:02:49,590 --> 01:02:54,600
connection busy kind of error well you

01:02:52,860 --> 01:02:55,950
can kind of like recover from that in a

01:02:54,600 --> 01:03:00,000
very context-sensitive way you can just

01:02:55,950 --> 01:03:01,530
sleep and then try again right but if

01:03:00,000 --> 01:03:03,570
none of this if this doesn't work

01:03:01,530 --> 01:03:06,600
then at some point you've got to kind of

01:03:03,570 --> 01:03:09,690
tell your caller that like you failed to

01:03:06,600 --> 01:03:13,770
do this i/o and for them like whether

01:03:09,690 --> 01:03:14,850
you got like you know couldn't get the

01:03:13,770 --> 01:03:16,740
connection or whether you got like a

01:03:14,850 --> 01:03:18,900
wood block kind of error this is useless

01:03:16,740 --> 01:03:20,490
right but they might want to know well

01:03:18,900 --> 01:03:23,670
there was an i/o error trying to connect

01:03:20,490 --> 01:03:24,990
to this particular IP address okay

01:03:23,670 --> 01:03:27,150
so that's kind of a difference between

01:03:24,990 --> 01:03:28,620
like a kind of internal kind of error in

01:03:27,150 --> 01:03:30,510
an external error and where you want to

01:03:28,620 --> 01:03:33,950
convert from one to the other is kind of

01:03:30,510 --> 01:03:38,130
like the boundary of your error module

01:03:33,950 --> 01:03:41,370
and generally like within an error

01:03:38,130 --> 01:03:42,030
module you or a common pattern for error

01:03:41,370 --> 01:03:45,840
handling

01:03:42,030 --> 01:03:47,220
is that you always throw re throw your

01:03:45,840 --> 01:03:49,830
error when you're inside the error

01:03:47,220 --> 01:03:52,080
module and then you have in US and the

01:03:49,830 --> 01:03:54,360
kind of boundary of this module you have

01:03:52,080 --> 01:03:57,510
like a single place where you try and do

01:03:54,360 --> 01:03:58,830
recovery okay and if that recovery fails

01:03:57,510 --> 01:04:00,840
then you're going to convert the

01:03:58,830 --> 01:04:04,260
internal error into a kind of public

01:04:00,840 --> 01:04:07,080
facing error and so that's kind of like

01:04:04,260 --> 01:04:09,800
the the intuition that I kind of pushes

01:04:07,080 --> 01:04:12,330
to knowing when you should kind of like

01:04:09,800 --> 01:04:14,540
throttle versus recover is kind of

01:04:12,330 --> 01:04:22,230
getting this intuition of kind of like

01:04:14,540 --> 01:04:51,570
modular error stuff actually do you have

01:04:22,230 --> 01:04:53,340
any questions about that so the question

01:04:51,570 --> 01:05:00,210
is how do you deal with out-of-bounds

01:04:53,340 --> 01:05:04,080
accesses in arrays and so I so bounds

01:05:00,210 --> 01:05:08,760
checking is done at runtime and rust and

01:05:04,080 --> 01:05:10,830
it depends like you can index into an

01:05:08,760 --> 01:05:13,650
array in different rays the pen which

01:05:10,830 --> 01:05:16,440
depend will give you different ways of

01:05:13,650 --> 01:05:19,290
getting the different ways of handling

01:05:16,440 --> 01:05:22,290
the out-of-bounds error so if you just

01:05:19,290 --> 01:05:24,000
use like the square bracket operators

01:05:22,290 --> 01:05:27,120
and you're out of bounds then that's

01:05:24,000 --> 01:05:28,920
going to panic which you don't want to

01:05:27,120 --> 01:05:32,280
happen so if you think that you might

01:05:28,920 --> 01:05:34,380
possibly access out of bounds then you

01:05:32,280 --> 01:05:35,700
should not be using those indexing

01:05:34,380 --> 01:05:37,680
operations and you should use an

01:05:35,700 --> 01:05:39,450
explicit gap which returns an option I

01:05:37,680 --> 01:05:42,420
think either an option or result bshorts

01:05:39,450 --> 01:05:44,070
an option and then you can like

01:05:42,420 --> 01:05:45,360
explicitly check or you can use the

01:05:44,070 --> 01:05:49,980
various functions we talked about on the

01:05:45,360 --> 01:05:51,480
first half to say if this is a if there

01:05:49,980 --> 01:05:53,970
was something there then do something

01:05:51,480 --> 01:05:58,770
and if it was none than recover in some

01:05:53,970 --> 01:06:01,790
way so that yeah and then how you do it

01:05:58,770 --> 01:06:01,790
is up to you

01:06:05,829 --> 01:06:13,199
ah yes correct

01:06:19,510 --> 01:06:27,650
okay so if you remember the result type

01:06:25,460 --> 01:06:29,390
has two type parameters it has the value

01:06:27,650 --> 01:06:31,340
type that we haven't had success and

01:06:29,390 --> 01:06:33,290
how's the arrow type hopefully what

01:06:31,340 --> 01:06:35,210
value type you know that I don't need to

01:06:33,290 --> 01:06:36,500
talk about that it's obviously just what

01:06:35,210 --> 01:06:38,480
you're doing and your function that's

01:06:36,500 --> 01:06:41,180
going to take the value type what should

01:06:38,480 --> 01:06:45,940
you use for your arrow type this is kind

01:06:41,180 --> 01:06:48,680
of a big question but first of all

01:06:45,940 --> 01:06:50,360
result type I mentioned earlier it's not

01:06:48,680 --> 01:06:51,710
magic it's not built into the language

01:06:50,360 --> 01:06:53,510
it's just part of the standard library

01:06:51,710 --> 01:06:56,120
and it's actually totally possible to

01:06:53,510 --> 01:06:58,490
use your own result type but don't do

01:06:56,120 --> 01:06:59,870
that there's like there's very rarely

01:06:58,490 --> 01:07:02,330
any reason you would want to do that

01:06:59,870 --> 01:07:04,610
unless you are reimplemented some really

01:07:02,330 --> 01:07:06,800
kind of like fundamental library stuff I

01:07:04,610 --> 01:07:08,510
can't imagine a scenario where it makes

01:07:06,800 --> 01:07:12,470
sense to implement your own result type

01:07:08,510 --> 01:07:14,540
on the other hand aliasing the result

01:07:12,470 --> 01:07:17,210
type is almost always a good idea if

01:07:14,540 --> 01:07:20,890
like within a module you are using a

01:07:17,210 --> 01:07:24,200
single arrow type then kind of having a

01:07:20,890 --> 01:07:37,520
an alias for that makes your your code

01:07:24,200 --> 01:07:40,400
much clearer no you can think of like

01:07:37,520 --> 01:07:44,750
the an alias like this being resolved oh

01:07:40,400 --> 01:07:47,770
sorry the question was does this prevent

01:07:44,750 --> 01:07:51,950
kind of implicit coercion between your

01:07:47,770 --> 01:07:53,570
results I found thus general results

01:07:51,950 --> 01:07:56,870
I've announcer is no and you probably

01:07:53,570 --> 01:07:58,430
don't want that like you want to be you

01:07:56,870 --> 01:08:00,650
want to just be using the result type

01:07:58,430 --> 01:08:02,240
you want to be able to in gonna interact

01:08:00,650 --> 01:08:06,050
with the rest of the ecosystem by doing

01:08:02,240 --> 01:08:08,240
that but by this is just a convenient so

01:08:06,050 --> 01:08:10,130
you don't have to keep typing my every

01:08:08,240 --> 01:08:24,050
kind of function that you have this end

01:08:10,130 --> 01:08:27,380
which gets boring really fast you you

01:08:24,050 --> 01:08:31,940
can oh sorry so the question is there is

01:08:27,380 --> 01:08:34,430
an option for not allowing the coercion

01:08:31,940 --> 01:08:36,620
so I should clarify that there's it's

01:08:34,430 --> 01:08:39,650
not a coercion like the aliasing is

01:08:36,620 --> 01:08:42,109
happens or the D aliasing I guess

01:08:39,650 --> 01:08:43,700
happens very early in compilation so as

01:08:42,109 --> 01:08:45,410
far as the compiler is concerned these

01:08:43,700 --> 01:08:46,960
are the same types it's not that it's

01:08:45,410 --> 01:08:50,839
being coerced from one type to another

01:08:46,960 --> 01:08:53,300
if you do want an something that is like

01:08:50,839 --> 01:08:57,140
an alias but does not coerce you can use

01:08:53,300 --> 01:08:58,640
like a unit struct as like a new type

01:08:57,140 --> 01:09:00,680
type

01:08:58,640 --> 01:09:03,430
trick but you should definitely not do

01:09:00,680 --> 01:09:03,430
that with results

01:09:08,699 --> 01:09:15,969
it's the one option is you use something

01:09:12,520 --> 01:09:18,040
really simple as your arrow type so you

01:09:15,969 --> 01:09:20,290
could not use anything at all if you're

01:09:18,040 --> 01:09:23,380
if this is really early days code maybe

01:09:20,290 --> 01:09:26,710
you just want you know it's it's nice to

01:09:23,380 --> 01:09:28,420
be able to throw errors but there's

01:09:26,710 --> 01:09:30,099
maybe no relevant information that you

01:09:28,420 --> 01:09:32,830
can get in there and so you can actually

01:09:30,099 --> 01:09:34,449
just use the void type which is just the

01:09:32,830 --> 01:09:36,159
the empty parens and there's no

01:09:34,449 --> 01:09:38,290
information at all you could use error

01:09:36,159 --> 01:09:39,339
codes like you know one two three or

01:09:38,290 --> 01:09:41,319
error codes

01:09:39,339 --> 01:09:43,719
that's not very user-friendly but it's

01:09:41,319 --> 01:09:45,400
fine for experimental programming it's

01:09:43,719 --> 01:09:46,900
pretty common see people use strings

01:09:45,400 --> 01:09:49,000
like a Gaines it's not something I

01:09:46,900 --> 01:09:50,139
recommend in kind of production code but

01:09:49,000 --> 01:09:52,420
it's great when you're experimenting

01:09:50,139 --> 01:09:57,730
it's very lightweight and it lets you

01:09:52,420 --> 01:10:00,730
debug it the other option is you do this

01:09:57,730 --> 01:10:02,860
properly and you have like a struct or

01:10:00,730 --> 01:10:04,510
an enum with lots of variants and data

01:10:02,860 --> 01:10:06,369
that it's carrying around which lets

01:10:04,510 --> 01:10:08,230
gives you lots of information for

01:10:06,369 --> 01:10:10,330
recovering lots of information that you

01:10:08,230 --> 01:10:12,520
can give to the user about what went

01:10:10,330 --> 01:10:14,440
wrong if necessary and you have a couple

01:10:12,520 --> 01:10:17,020
of and but you have some options you can

01:10:14,440 --> 01:10:19,630
use like a single arrow type for all of

01:10:17,020 --> 01:10:22,690
your code or you can use multiple arrow

01:10:19,630 --> 01:10:25,389
types so if you're using a single one

01:10:22,690 --> 01:10:27,610
it's quite often to you common to use an

01:10:25,389 --> 01:10:30,310
enum so here we're just using the single

01:10:27,610 --> 01:10:32,860
enum type as our arrow type and every

01:10:30,310 --> 01:10:37,090
possible kind of error gets a different

01:10:32,860 --> 01:10:39,219
variant and you know any data you want

01:10:37,090 --> 01:10:40,780
is carried along with that so here we've

01:10:39,219 --> 01:10:42,810
got like a server error user error

01:10:40,780 --> 01:10:44,739
connection error whatever else

01:10:42,810 --> 01:10:46,929
alternatively you can use multiple

01:10:44,739 --> 01:10:50,440
different arrow types so different

01:10:46,929 --> 01:10:53,260
functions would return different throw

01:10:50,440 --> 01:10:55,810
different kinds of errors so here we've

01:10:53,260 --> 01:10:57,849
got like a struct for a server error and

01:10:55,810 --> 01:10:59,590
that has like quite different data from

01:10:57,849 --> 01:11:04,840
all the other kind of errors that we

01:10:59,590 --> 01:11:06,429
might have you in the end you're gonna

01:11:04,840 --> 01:11:08,260
have to deal with multiple error types

01:11:06,429 --> 01:11:10,179
anyway because the standard library is

01:11:08,260 --> 01:11:11,469
full of different ones with its own kind

01:11:10,179 --> 01:11:14,050
so you're gonna have to accommodate that

01:11:11,469 --> 01:11:15,969
so even though using a single kind of

01:11:14,050 --> 01:11:17,290
arrow type is simpler and often look

01:11:15,969 --> 01:11:18,340
kind of like what you want to do you

01:11:17,290 --> 01:11:22,060
still have to handle

01:11:18,340 --> 01:11:24,130
types often if you're thinking of like

01:11:22,060 --> 01:11:26,889
this in terms of error modules you want

01:11:24,130 --> 01:11:27,940
like one arrow type / arrow module and

01:11:26,889 --> 01:11:29,380
that's like another way that this

01:11:27,940 --> 01:11:32,170
intuition of arrow module is really

01:11:29,380 --> 01:11:34,060
helpful and I'd say if you do have

01:11:32,170 --> 01:11:35,469
multiple types and if you want to do can

01:11:34,060 --> 01:11:38,380
I error handling properly you should

01:11:35,469 --> 01:11:41,650
look at the failure library this is a

01:11:38,380 --> 01:11:43,989
library for error handling and it is on

01:11:41,650 --> 01:11:46,570
the road to being part of the standard

01:11:43,989 --> 01:11:51,940
library and hopefully it's gonna be

01:11:46,570 --> 01:11:53,860
widely used in the ecosystems so it's it

01:11:51,940 --> 01:11:56,020
gives your your librarian advantage so

01:11:53,860 --> 01:11:57,550
it lets you handle kind of lots of

01:11:56,020 --> 01:11:59,409
different kinds of arrow types very

01:11:57,550 --> 01:12:02,530
clearly it lets you change a rose

01:11:59,409 --> 01:12:04,540
together so often you'll have an arrow

01:12:02,530 --> 01:12:06,310
that has like an underlying calls and it

01:12:04,540 --> 01:12:08,830
lets you deal with that kind of like

01:12:06,310 --> 01:12:11,050
chain of causes and it'll allow you to

01:12:08,830 --> 01:12:13,570
have like back traces when you when

01:12:11,050 --> 01:12:16,239
these kind of errors get surfaced and it

01:12:13,570 --> 01:12:20,710
lets you interoperate very cleanly with

01:12:16,239 --> 01:12:22,989
the rest of the rust ecosystem oh and

01:12:20,710 --> 01:12:26,889
it's extremely easy to use okay like if

01:12:22,989 --> 01:12:28,869
you have like if this is your error in

01:12:26,889 --> 01:12:31,500
Unum then you can opt into using failure

01:12:28,869 --> 01:12:35,820
just with this very small derive fail

01:12:31,500 --> 01:12:35,820
attribute question

01:12:45,090 --> 01:12:50,580
question was it seems there's no era

01:12:47,490 --> 01:12:53,100
hierarchy is there a reason and we get I

01:12:50,580 --> 01:12:55,500
mean we generally don't have hierarchies

01:12:53,100 --> 01:12:57,780
and rust life

01:12:55,500 --> 01:13:01,260
there's no inheritance between data

01:12:57,780 --> 01:13:05,190
types so there's no kind of obvious

01:13:01,260 --> 01:13:06,930
weights that even have such a thing yeah

01:13:05,190 --> 01:13:09,060
is the is the short answer it just

01:13:06,930 --> 01:13:11,190
doesn't kind of like fit with the rust

01:13:09,060 --> 01:13:18,180
philosophy of the way we do things to do

01:13:11,190 --> 01:13:21,600
that okay so what should I do like

01:13:18,180 --> 01:13:23,580
you're your programmer like what should

01:13:21,600 --> 01:13:26,520
I do like what kind of approach does

01:13:23,580 --> 01:13:29,870
have error handling so the first

01:13:26,520 --> 01:13:33,810
question is are you writing a library or

01:13:29,870 --> 01:13:35,430
are you writing an application if you're

01:13:33,810 --> 01:13:38,250
running a library basically you have to

01:13:35,430 --> 01:13:39,720
do everything properly if you want other

01:13:38,250 --> 01:13:42,810
people to use your library they're going

01:13:39,720 --> 01:13:44,730
to expect it to have proper error

01:13:42,810 --> 01:13:47,010
handling so you need to use your own

01:13:44,730 --> 01:13:48,690
arrow type don't try and use like a

01:13:47,010 --> 01:13:51,210
string or an error code or something

01:13:48,690 --> 01:13:54,120
like a Paik like that you need to think

01:13:51,210 --> 01:13:56,550
you need to like consider like the arrow

01:13:54,120 --> 01:13:58,290
boundaries that I was talking about

01:13:56,550 --> 01:14:02,130
earlier and you should probably use the

01:13:58,290 --> 01:14:04,050
failure library if you're using an

01:14:02,130 --> 01:14:05,460
application if you're producing an

01:14:04,050 --> 01:14:07,140
application then you want to think about

01:14:05,460 --> 01:14:08,970
what kind of application that is if

01:14:07,140 --> 01:14:12,090
you're writing a script that you're only

01:14:08,970 --> 01:14:16,020
going to use once and throw away then

01:14:12,090 --> 01:14:18,270
just panic everywhere but like bear in

01:14:16,020 --> 01:14:19,860
mind that scripts that you use once and

01:14:18,270 --> 01:14:22,380
throw away have a tendency to become

01:14:19,860 --> 01:14:24,570
scripts that get used twice and then go

01:14:22,380 --> 01:14:30,030
into production and are in essential

01:14:24,570 --> 01:14:31,590
part of your you know business plan if

01:14:30,030 --> 01:14:34,290
you're running like very experimental

01:14:31,590 --> 01:14:35,790
prototype software then you probably

01:14:34,290 --> 01:14:38,310
want to have some quite lightweight

01:14:35,790 --> 01:14:40,410
error handling so you know something

01:14:38,310 --> 01:14:43,500
like using a string as an error message

01:14:40,410 --> 01:14:45,030
it's quite a good idea and if you're

01:14:43,500 --> 01:14:46,500
putting something in production then you

01:14:45,030 --> 01:14:48,900
need to do like with a library you need

01:14:46,500 --> 01:14:51,170
to have like a really kind of like full

01:14:48,900 --> 01:14:55,699
error handling thing I should

01:14:51,170 --> 01:14:57,770
say that it's kind of hard to refactor

01:14:55,699 --> 01:14:59,719
from a system that panics everywhere

01:14:57,770 --> 01:15:04,010
into a system with proper error handling

01:14:59,719 --> 01:15:07,580
but it's pretty easy to refactor from a

01:15:04,010 --> 01:15:10,340
system that just uses like strings say

01:15:07,580 --> 01:15:12,410
into something that those proper error

01:15:10,340 --> 01:15:14,179
handling so if you're running prototype

01:15:12,410 --> 01:15:16,730
or experimental software that's why I

01:15:14,179 --> 01:15:18,739
say you should kind of do kind of like

01:15:16,730 --> 01:15:22,070
the basic and error handling approach

01:15:18,739 --> 01:15:25,340
because it's really easy to factor that

01:15:22,070 --> 01:15:26,900
into like proper error handling whereas

01:15:25,340 --> 01:15:29,870
if you just panic in everywhere that's

01:15:26,900 --> 01:15:31,190
that's really difficult plus it lets you

01:15:29,870 --> 01:15:35,239
do stuff like using the question mark

01:15:31,190 --> 01:15:38,750
operator and the easy interaction with

01:15:35,239 --> 01:15:41,330
some of the standard library types ok so

01:15:38,750 --> 01:15:42,800
that's the end of this section and a

01:15:41,330 --> 01:15:45,670
good place to ask if people have

01:15:42,800 --> 01:15:45,670
questions

01:15:49,770 --> 01:15:56,000
ah sorry

01:15:58,999 --> 01:16:05,210
yes sorry the question was can you write

01:16:03,380 --> 01:16:08,749
a trait which relies on things having

01:16:05,210 --> 01:16:11,210
other traits the answer is yes and but

01:16:08,749 --> 01:16:15,460
stick around and we can talk about it

01:16:11,210 --> 01:16:21,289
rather than going into it right now cool

01:16:15,460 --> 01:16:24,920
okay so I have vastly underestimated how

01:16:21,289 --> 01:16:26,749
long this talk would take and I only

01:16:24,920 --> 01:16:28,940
have seven more minutes which is

01:16:26,749 --> 01:16:30,739
probably not enough time to cover even a

01:16:28,940 --> 01:16:34,849
half of one of the two sections that I

01:16:30,739 --> 01:16:36,440
have left so I'm happy to kind of stick

01:16:34,849 --> 01:16:37,849
around but I think they need to stop

01:16:36,440 --> 01:16:39,800
video recording at some point people

01:16:37,849 --> 01:16:44,440
might want to leave so now is probably a

01:16:39,800 --> 01:16:44,440
good place to stop and carry on

01:16:53,830 --> 01:17:15,550
thank you thank you

01:17:18,640 --> 01:17:24,770
Thanks so I wrecked so I have two

01:17:21,740 --> 01:17:27,890
sections remaining one is on ownership

01:17:24,770 --> 01:17:29,750
and using that for as a kind of

01:17:27,890 --> 01:17:33,980
principle of designing your us programs

01:17:29,750 --> 01:17:36,830
and a second section is on traits as an

01:17:33,980 --> 01:17:39,230
abstraction mechanism in rust I figure

01:17:36,830 --> 01:17:41,930
even going into the coffee break that we

01:17:39,230 --> 01:17:44,000
only have time for one of those so does

01:17:41,930 --> 01:17:45,020
anybody have a preference so raise your

01:17:44,000 --> 01:17:49,250
hands if you'd rather hear about

01:17:45,020 --> 01:17:50,990
ownership it's a few and raise your

01:17:49,250 --> 01:17:54,740
hands if you'd rather hear about traits

01:17:50,990 --> 01:17:59,600
I think the traits have it sorry

01:17:54,740 --> 01:18:01,280
ownership folk I'm happy so I think

01:17:59,600 --> 01:18:02,480
we'll be done hopefully early in the

01:18:01,280 --> 01:18:04,400
coffee break and I'm happy it's gonna

01:18:02,480 --> 01:18:15,050
stick around and talk about ownership if

01:18:04,400 --> 01:18:16,840
anyone wants to hear about that so that

01:18:15,050 --> 01:18:23,800
was everything you missed

01:18:16,840 --> 01:18:27,560
okay so traits traits are the primary

01:18:23,800 --> 01:18:33,800
abstraction mechanism in rust so if

01:18:27,560 --> 01:18:36,320
you're coming from kind of like any

01:18:33,800 --> 01:18:38,060
other well many other languages there's

01:18:36,320 --> 01:18:42,350
a quite kind of novel abstraction

01:18:38,060 --> 01:18:44,630
mechanism so rust is in the large at

01:18:42,350 --> 01:18:46,490
least is a very object-oriented language

01:18:44,630 --> 01:18:49,040
but it's certainly not a class or

01:18:46,490 --> 01:18:50,780
incited language and the way that you

01:18:49,040 --> 01:18:52,220
use traits is very different from the

01:18:50,780 --> 01:18:53,360
way that you would use classes and even

01:18:52,220 --> 01:18:55,280
if you think of they're more like

01:18:53,360 --> 01:18:57,410
interfaces than classes which they are

01:18:55,280 --> 01:19:02,900
that I think designing with traits is

01:18:57,410 --> 01:19:06,780
very different so the basic syntax for

01:19:02,900 --> 01:19:08,640
using traits is pretty simple you

01:19:06,780 --> 01:19:11,520
declare a trait using the trait keyword

01:19:08,640 --> 01:19:12,990
you in the ellipses where I've alighted

01:19:11,520 --> 01:19:16,650
the code you'd have a bunch of method

01:19:12,990 --> 01:19:18,900
signatures and then when you implement a

01:19:16,650 --> 01:19:20,670
trait for some concrete type which is

01:19:18,900 --> 01:19:22,560
what's going on in the second line then

01:19:20,670 --> 01:19:29,790
you have to provide the implementations

01:19:22,560 --> 01:19:32,040
of all those methods so I'll do a kind

01:19:29,790 --> 01:19:36,810
of little comparison between classes and

01:19:32,040 --> 01:19:40,260
traits so classes are a way to share

01:19:36,810 --> 01:19:41,880
both behavior and data okay so when you

01:19:40,260 --> 01:19:43,440
inherit from a class you inherit the

01:19:41,880 --> 01:19:46,260
data that's in the super class and you

01:19:43,440 --> 01:19:48,510
inherit the the behavior the methods

01:19:46,260 --> 01:19:50,910
that are there as well

01:19:48,510 --> 01:19:54,510
whereas traits are only about sharing

01:19:50,910 --> 01:19:56,820
behavior you cannot like share data in a

01:19:54,510 --> 01:20:01,770
trait that's part of the concrete data

01:19:56,820 --> 01:20:04,890
types that russa provides classes are

01:20:01,770 --> 01:20:08,540
mostly hierarchical they got a question

01:20:04,890 --> 01:20:10,740
earlier about kind of like why arrows on

01:20:08,540 --> 01:20:12,750
hierarchical in rust and we don't really

01:20:10,740 --> 01:20:15,060
have like the kind of hierarchies that

01:20:12,750 --> 01:20:19,590
you get all over the place you know in

01:20:15,060 --> 01:20:21,330
most other languages so just like it's

01:20:19,590 --> 01:20:22,500
actually possible in classes that you

01:20:21,330 --> 01:20:25,040
can have multiple inheritance and

01:20:22,500 --> 01:20:28,590
therefore you have like a dag of

01:20:25,040 --> 01:20:32,660
inheritance rather than a tree it is

01:20:28,590 --> 01:20:32,660
possible that you have some kind of

01:20:32,840 --> 01:20:37,920
inheritance between between traits and

01:20:35,550 --> 01:20:40,860
rust but it's the exception rather than

01:20:37,920 --> 01:20:44,010
the rule and in general you compose

01:20:40,860 --> 01:20:46,770
behavior without inheritance so it's

01:20:44,010 --> 01:20:49,710
it's more of kind of an unstructured

01:20:46,770 --> 01:20:56,310
blob of behavior sharing rather than a

01:20:49,710 --> 01:21:00,000
than a hierarchy so in a class whether

01:20:56,310 --> 01:21:04,020
you are sharing behavior is declared

01:21:00,000 --> 01:21:05,670
when you define the class so you write

01:21:04,020 --> 01:21:10,610
out your class and you write the classes

01:21:05,670 --> 01:21:12,840
that that it inherits from in rust

01:21:10,610 --> 01:21:15,420
declaring the traits you implement is

01:21:12,840 --> 01:21:18,000
completely different from declaring the

01:21:15,420 --> 01:21:20,190
concrete data types and so that means

01:21:18,000 --> 01:21:24,480
that you can

01:21:20,190 --> 01:21:25,680
implements a trait for data types that

01:21:24,480 --> 01:21:27,570
are in any of your kind of like

01:21:25,680 --> 01:21:29,160
dependency libraries or even in the

01:21:27,570 --> 01:21:32,040
standard library so it's quite common

01:21:29,160 --> 01:21:33,960
for you know I write my own trait in my

01:21:32,040 --> 01:21:36,270
code and then I can implement that for

01:21:33,960 --> 01:21:40,410
the integer types and for string and so

01:21:36,270 --> 01:21:42,180
forth so this means this all these

01:21:40,410 --> 01:21:44,130
things together basically make traits a

01:21:42,180 --> 01:21:50,940
much more flexible sharing mechanism

01:21:44,130 --> 01:21:52,500
than than classes traits are also really

01:21:50,940 --> 01:21:56,430
important in rust because they're the

01:21:52,500 --> 01:21:59,520
way that user-defined types can interact

01:21:56,430 --> 01:22:01,920
with the language itself okay so we saw

01:21:59,520 --> 01:22:03,270
earlier this iterates a trait and we saw

01:22:01,920 --> 01:22:05,219
the for loop which is part of the

01:22:03,270 --> 01:22:07,500
language and by implementing the

01:22:05,219 --> 01:22:09,900
iterator trait you allow your own like

01:22:07,500 --> 01:22:13,440
user types to be iterated over using the

01:22:09,900 --> 01:22:17,070
for loop similarly there is a D ref

01:22:13,440 --> 01:22:20,850
trait which allows your user defined

01:22:17,070 --> 01:22:22,830
types to act like pointers and to to

01:22:20,850 --> 01:22:24,270
take part in kind of dereferencing that

01:22:22,830 --> 01:22:27,390
happens with the dot operator and

01:22:24,270 --> 01:22:30,510
elsewhere and then there's the index

01:22:27,390 --> 01:22:32,520
trait which allows your user defined

01:22:30,510 --> 01:22:35,520
types to act like an array and be able

01:22:32,520 --> 01:22:39,420
to be indexed into with the square

01:22:35,520 --> 01:22:41,400
bracket operators and traits also

01:22:39,420 --> 01:22:43,440
essential to the safety guarantees and

01:22:41,400 --> 01:22:45,600
rust a really good example of this is

01:22:43,440 --> 01:22:47,070
the send and sync traits and these

01:22:45,600 --> 01:22:49,020
actually don't have any methods in them

01:22:47,070 --> 01:22:52,469
at all these are just market rates and

01:22:49,020 --> 01:22:54,660
by implementing the these traits you are

01:22:52,469 --> 01:22:58,170
making a guarantee to the RUS compiler

01:22:54,660 --> 01:22:59,910
that your data type is safe to move

01:22:58,170 --> 01:23:07,020
between threads or to share between

01:22:59,910 --> 01:23:09,870
threads respectively so this is my kind

01:23:07,020 --> 01:23:13,199
of lightning summary of traits and rust

01:23:09,870 --> 01:23:15,860
as any questions about how this is work

01:23:13,199 --> 01:23:15,860
yep

01:23:29,860 --> 01:23:38,650
so the question is are you restricted in

01:23:36,429 --> 01:23:40,900
way you can implement a trait for a

01:23:38,650 --> 01:23:45,309
concrete data type so the answer is yes

01:23:40,900 --> 01:23:46,989
so sir rust is structured into crates

01:23:45,309 --> 01:23:48,880
which are kind of like the compilation

01:23:46,989 --> 01:23:51,460
unit and similar to a like it's

01:23:48,880 --> 01:23:54,489
basically a conflict a library

01:23:51,460 --> 01:23:57,219
so either the traits or the concrete

01:23:54,489 --> 01:24:00,070
type must be defined in a crate within

01:23:57,219 --> 01:24:01,780
with the implementation so you can input

01:24:00,070 --> 01:24:03,789
a few define the trade so you can input

01:24:01,780 --> 01:24:07,119
a few define the concrete data or both

01:24:03,789 --> 01:24:10,030
of course but you can't in pull if you

01:24:07,119 --> 01:24:12,699
don't know either and then there's also

01:24:10,030 --> 01:24:15,730
a really sorry I should say really

01:24:12,699 --> 01:24:19,570
complex there's a somewhat complex set

01:24:15,730 --> 01:24:21,699
of rules around coherence which dictate

01:24:19,570 --> 01:24:25,650
like what kind of implementations you

01:24:21,699 --> 01:24:28,539
can have certain data types but yeah we

01:24:25,650 --> 01:24:30,929
we prevent and I'll do it the orphan

01:24:28,539 --> 01:24:30,929
problem

01:24:36,030 --> 01:24:39,959
question is do we prevent two

01:24:38,579 --> 01:24:41,849
implementations of the same trade for

01:24:39,959 --> 01:24:44,550
the same data type yes that's what the

01:24:41,849 --> 01:24:45,929
coherence rules are for but I'm not

01:24:44,550 --> 01:24:52,469
gonna explain them because they're

01:24:45,929 --> 01:24:57,570
complicated yeah any other questions

01:24:52,469 --> 01:24:59,760
okay so you should use more traits this

01:24:57,570 --> 01:25:04,559
is probably good advice for nearly every

01:24:59,760 --> 01:25:06,659
Russ programmer it's tenting I mean you

01:25:04,559 --> 01:25:10,860
can write Russ code without any traits

01:25:06,659 --> 01:25:12,900
and especially if you come for so you

01:25:10,860 --> 01:25:17,280
can write methods in what we call an

01:25:12,900 --> 01:25:19,769
inherent imple which is an impulse rate

01:25:17,280 --> 01:25:23,179
at all so these are just methods that

01:25:19,769 --> 01:25:25,829
are available on the data type without

01:25:23,179 --> 01:25:27,360
without naming a trait and if you're

01:25:25,829 --> 01:25:29,610
used to kind of like the LOA way of

01:25:27,360 --> 01:25:31,800
coding this connect you can feel quite a

01:25:29,610 --> 01:25:35,309
natural way it means you define all your

01:25:31,800 --> 01:25:37,709
methods on the concrete data type so

01:25:35,309 --> 01:25:39,630
it's just combining the the data and the

01:25:37,709 --> 01:25:43,229
behavior but you should probably avoid

01:25:39,630 --> 01:25:46,679
doing that you should use more traits so

01:25:43,229 --> 01:25:49,019
by doing so like you enable like much

01:25:46,679 --> 01:25:50,699
better testing if you're if you take a

01:25:49,019 --> 01:25:53,429
trait rather than a concrete type it's

01:25:50,699 --> 01:25:56,489
really easy to mock out the the concrete

01:25:53,429 --> 01:25:59,010
type and have like mock you have like a

01:25:56,489 --> 01:26:00,449
mock object for testing it makes your

01:25:59,010 --> 01:26:01,679
code much more extensible this is

01:26:00,449 --> 01:26:04,380
especially important if you're writing a

01:26:01,679 --> 01:26:06,030
library if you're always expecting a

01:26:04,380 --> 01:26:07,739
concrete type your code is not very

01:26:06,030 --> 01:26:09,570
flexible whereas if you have generic

01:26:07,739 --> 01:26:11,280
code that'll accept any type that

01:26:09,570 --> 01:26:13,349
implements a trait that's much more

01:26:11,280 --> 01:26:15,209
flexible and much more extensible and

01:26:13,349 --> 01:26:18,659
that's encouraging like reuse of your

01:26:15,209 --> 01:26:21,510
code it also tends to lead to a cleaner

01:26:18,659 --> 01:26:23,969
design like you can think of the traits

01:26:21,510 --> 01:26:27,929
as kind of document self-documenting

01:26:23,969 --> 01:26:29,820
code it tells you what what methods are

01:26:27,929 --> 01:26:33,269
closely associated with each other it

01:26:29,820 --> 01:26:35,429
tells you like what what the kind of

01:26:33,269 --> 01:26:41,789
like effect of having all these methods

01:26:35,429 --> 01:26:43,889
is and and and so on and so forth so it

01:26:41,789 --> 01:26:46,709
leads to just generally kind of like by

01:26:43,889 --> 01:26:48,150
using many using more traits you kind of

01:26:46,709 --> 01:26:48,690
end up with a cleaner more elegant

01:26:48,150 --> 01:26:53,880
design

01:26:48,690 --> 01:26:55,739
usually but there's always a limit as

01:26:53,880 --> 01:26:58,410
with any abstraction mechanism it's

01:26:55,739 --> 01:27:01,530
really easy to kind of go overboard and

01:26:58,410 --> 01:27:07,100
you know have the equivalents of a kind

01:27:01,530 --> 01:27:09,570
of you know enterprise javabean type

01:27:07,100 --> 01:27:13,020
situations so you know I appreciate the

01:27:09,570 --> 01:27:15,270
the trade-offs around abstraction and

01:27:13,020 --> 01:27:17,400
it's pretty easy to kind of factor out

01:27:15,270 --> 01:27:19,530
trait sort of split traits up and so

01:27:17,400 --> 01:27:23,940
forth so keep revisiting refactoring

01:27:19,530 --> 01:27:27,440
your code to to make more traits so what

01:27:23,940 --> 01:27:30,180
makes a good trait it should be small

01:27:27,440 --> 01:27:31,980
some traits as I said have no methods at

01:27:30,180 --> 01:27:35,190
all it's really common for the traits

01:27:31,980 --> 01:27:37,020
only have a single method for traits

01:27:35,190 --> 01:27:40,530
with more complex functionality like

01:27:37,020 --> 01:27:42,900
three four methods super common it's

01:27:40,530 --> 01:27:45,540
really rare to have like a lot of

01:27:42,900 --> 01:27:47,280
methods if you have like you know pages

01:27:45,540 --> 01:27:50,850
full of methods you probably want to

01:27:47,280 --> 01:27:52,890
refactor that's kind of you you having

01:27:50,850 --> 01:27:55,980
more of a kind of class design mindset

01:27:52,890 --> 01:27:58,560
there and they should be independent so

01:27:55,980 --> 01:28:00,300
don't make them too small if every time

01:27:58,560 --> 01:28:02,070
you're using one trait you're also using

01:28:00,300 --> 01:28:03,719
another one they're probably too tightly

01:28:02,070 --> 01:28:09,390
coupled and you want to either merge

01:28:03,719 --> 01:28:10,530
them or otherwise refactor and you know

01:28:09,390 --> 01:28:12,239
I've talked about this from the traits

01:28:10,530 --> 01:28:14,790
perspective but from the perspective of

01:28:12,239 --> 01:28:18,960
the concrete data what makes better data

01:28:14,790 --> 01:28:20,790
structures so I told you before these

01:28:18,960 --> 01:28:22,739
that you can have like methods in the

01:28:20,790 --> 01:28:25,560
inherent impulse and you should probably

01:28:22,739 --> 01:28:29,460
limit that that for behavior that is

01:28:25,560 --> 01:28:31,500
specific to the data itself so if you've

01:28:29,460 --> 01:28:33,449
got like a gasser or set of function

01:28:31,500 --> 01:28:36,780
that's probably better off as a inherent

01:28:33,449 --> 01:28:39,449
in on a is an inherent method if you've

01:28:36,780 --> 01:28:41,460
got something very closely tied to the

01:28:39,449 --> 01:28:43,590
implementation the same if you've got

01:28:41,460 --> 01:28:46,260
behavior that's could be specified

01:28:43,590 --> 01:28:48,360
generically or that constitutes an

01:28:46,260 --> 01:28:51,510
interface then that's something that you

01:28:48,360 --> 01:28:53,130
should factor out into a trait so

01:28:51,510 --> 01:28:54,540
hopefully I have enough so this is an

01:28:53,130 --> 01:28:57,000
example that I would have introduced in

01:28:54,540 --> 01:28:58,650
the ownership section I probably don't

01:28:57,000 --> 01:29:00,870
even have the time to introduce it

01:28:58,650 --> 01:29:01,650
properly here right now but on the right

01:29:00,870 --> 01:29:04,739
hand side

01:29:01,650 --> 01:29:07,500
here's a set of methods that I might

01:29:04,739 --> 01:29:09,420
want on this kind of abstract ship so

01:29:07,500 --> 01:29:11,610
chunk is an abstraction of some memory

01:29:09,420 --> 01:29:14,159
being managed so we've got empty to

01:29:11,610 --> 01:29:15,719
create a new empty chunk we've got two

01:29:14,159 --> 01:29:17,370
string which gives a string

01:29:15,719 --> 01:29:19,290
representation of a chunk we've got a

01:29:17,370 --> 01:29:21,390
debug string which does the same thing

01:29:19,290 --> 01:29:24,090
but for debugging for a developer rather

01:29:21,390 --> 01:29:29,429
than a user we've got get buffer to get

01:29:24,090 --> 01:29:31,830
like the underlying memory as a as a as

01:29:29,429 --> 01:29:35,100
an array of bytes and the size of that

01:29:31,830 --> 01:29:39,570
buffer and the potential capacity that

01:29:35,100 --> 01:29:42,270
we have that this would be not a great

01:29:39,570 --> 01:29:45,300
way to design this code it would be

01:29:42,270 --> 01:29:46,260
better to make this some trait so first

01:29:45,300 --> 01:29:48,090
of all we're going to use some traits

01:29:46,260 --> 01:29:50,330
from the standard library default is a

01:29:48,090 --> 01:29:52,290
trait that says I can create a default

01:29:50,330 --> 01:29:55,949
object and in this case that would be

01:29:52,290 --> 01:29:58,739
like an empty chunk display and debugger

01:29:55,949 --> 01:30:02,909
ways to convert an object into a string

01:29:58,739 --> 01:30:04,620
representation aimed for being a user

01:30:02,909 --> 01:30:07,050
facing string and a developer facing

01:30:04,620 --> 01:30:10,590
string and then we're gonna create our

01:30:07,050 --> 01:30:13,800
own trait buffer which is the kind of

01:30:10,590 --> 01:30:15,480
collection of methods that we might want

01:30:13,800 --> 01:30:17,130
for any kind of buffer provider and then

01:30:15,480 --> 01:30:19,199
that would let us for example have a

01:30:17,130 --> 01:30:20,880
mock buffer for testing that's always

01:30:19,199 --> 01:30:22,940
going to return zero or something like

01:30:20,880 --> 01:30:22,940
that

01:30:24,380 --> 01:30:29,489
okay so I've really just skimmed the

01:30:27,540 --> 01:30:32,640
surface of traits it's a really big

01:30:29,489 --> 01:30:35,550
topic and rust there is like a huge

01:30:32,640 --> 01:30:40,110
number of like little features around

01:30:35,550 --> 01:30:41,969
traits in the language that that let you

01:30:40,110 --> 01:30:43,500
do various things it's a good really

01:30:41,969 --> 01:30:45,690
good idea to kind of like read up on

01:30:43,500 --> 01:30:46,980
this stuff and you know it's a great way

01:30:45,690 --> 01:30:48,719
it's kind of like improve your design

01:30:46,980 --> 01:30:51,300
and make you a better programmer and I

01:30:48,719 --> 01:30:53,190
think like the best way to do that is to

01:30:51,300 --> 01:30:55,920
look at some examples so a few good

01:30:53,190 --> 01:30:59,159
examples to look at cerveau is the

01:30:55,920 --> 01:31:05,730
experimental web browser from rust they

01:30:59,159 --> 01:31:08,390
use a lot of traits to with of quite

01:31:05,730 --> 01:31:08,390
small traits

01:31:10,010 --> 01:31:19,250
yeah sure and the the the traits often

01:31:17,630 --> 01:31:21,050
correspond to something that like a web

01:31:19,250 --> 01:31:22,340
developer would know about whereas like

01:31:21,050 --> 01:31:24,980
the concrete data is kind of the

01:31:22,340 --> 01:31:26,660
internal structures chalk is an

01:31:24,980 --> 01:31:29,239
implementation of the trait system but

01:31:26,660 --> 01:31:32,239
this uses a traits for everything and

01:31:29,239 --> 01:31:34,790
it's great to see like how that kind of

01:31:32,239 --> 01:31:36,440
like really almost an overuse of traits

01:31:34,790 --> 01:31:41,090
actually leads to a really great design

01:31:36,440 --> 01:31:43,400
and Tokyo is an async IO library for

01:31:41,090 --> 01:31:46,280
rust and is great if you really want to

01:31:43,400 --> 01:31:48,170
like blow your mind about traits I mean

01:31:46,280 --> 01:31:50,750
we told stop his summary we talked about

01:31:48,170 --> 01:31:53,480
lots of stuff this is my contact

01:31:50,750 --> 01:31:55,080
information thank you very much but all

01:31:53,480 --> 01:32:01,470
the pay attention

01:31:55,080 --> 01:32:01,470

YouTube URL: https://www.youtube.com/watch?v=vqavdUGKeb4


