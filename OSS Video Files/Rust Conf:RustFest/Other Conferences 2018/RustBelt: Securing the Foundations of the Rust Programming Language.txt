Title: RustBelt: Securing the Foundations of the Rust Programming Language
Publication date: 2018-01-28
Playlist: Other Conferences 2018
Description: 
	
Captions: 
	00:00:24,800 --> 00:00:29,100
Mic Check

00:00:26,070 --> 00:00:30,539
great hi all and thank you very much for

00:00:29,100 --> 00:00:30,930
sticking around with me until the bitter

00:00:30,539 --> 00:00:33,540
end

00:00:30,930 --> 00:00:36,649
so um yes as neil already said let's

00:00:33,540 --> 00:00:38,790
talk about rust rust is a very recent

00:00:36,649 --> 00:00:42,960
programming language designed by Mozilla

00:00:38,790 --> 00:00:44,640
and it's kind of claimed to be a safe

00:00:42,960 --> 00:00:46,020
and modern systems programming language

00:00:44,640 --> 00:00:48,000
so let me explain some of these

00:00:46,020 --> 00:00:49,110
buzzwords here it's a modern language in

00:00:48,000 --> 00:00:51,540
the center that comes with all the

00:00:49,110 --> 00:00:52,950
features that we all love from our nice

00:00:51,540 --> 00:00:54,960
and high-level functional languages

00:00:52,950 --> 00:00:57,719
first-class functions like closures

00:00:54,960 --> 00:01:00,120
algebraic data types polymorphism and

00:00:57,719 --> 00:01:03,449
traits which are rusts type a take on

00:01:00,120 --> 00:01:05,399
type classes and associated types at the

00:01:03,449 --> 00:01:07,320
same time it's it's kind of a low-level

00:01:05,399 --> 00:01:09,690
language as well because it gives you

00:01:07,320 --> 00:01:12,390
control over resource management in

00:01:09,690 --> 00:01:13,679
particular memory management so in rust

00:01:12,390 --> 00:01:15,240
you have control over when memory is

00:01:13,679 --> 00:01:17,130
allocated and D allocated there is no

00:01:15,240 --> 00:01:19,560
mandatory garbage collection and you

00:01:17,130 --> 00:01:20,970
also have control over how data is

00:01:19,560 --> 00:01:22,679
layered or the memory where they are

00:01:20,970 --> 00:01:25,319
pointer and directions and things like

00:01:22,679 --> 00:01:27,569
that and rust chips all of this together

00:01:25,319 --> 00:01:29,610
in a package with a strong type system

00:01:27,569 --> 00:01:31,890
that guarantees or is claimed to

00:01:29,610 --> 00:01:34,619
guarantee memory safety as well as

00:01:31,890 --> 00:01:37,649
threat safety so in the Rust Belt

00:01:34,619 --> 00:01:39,690
research project we are well essentially

00:01:37,649 --> 00:01:44,190
we have the goal of verifying these

00:01:39,690 --> 00:01:46,170
claims on a mathematical basis so in in

00:01:44,190 --> 00:01:46,530
this paper we report on our progress so

00:01:46,170 --> 00:01:48,330
far

00:01:46,530 --> 00:01:50,880
concretely are the contributions

00:01:48,330 --> 00:01:53,910
represent here are we design we defined

00:01:50,880 --> 00:01:56,099
a lambda rust which is a core calculus

00:01:53,910 --> 00:01:57,390
representing a fragment of the rough

00:01:56,099 --> 00:01:59,670
programming language and it's type

00:01:57,390 --> 00:02:01,860
system we have improving semantic

00:01:59,670 --> 00:02:03,660
soundness of lambda rust by giving it a

00:02:01,860 --> 00:02:05,069
lot circulation in iris which gives us

00:02:03,660 --> 00:02:06,810
not just the types on as result but also

00:02:05,069 --> 00:02:08,910
a way to reason about unsafe code and

00:02:06,810 --> 00:02:10,440
then we've applied this and reason about

00:02:08,910 --> 00:02:11,970
reasoned about a bunch of the

00:02:10,440 --> 00:02:15,120
interesting and important unsafe code

00:02:11,970 --> 00:02:17,219
that comes in roster library so before I

00:02:15,120 --> 00:02:18,550
go into these contributions however I

00:02:17,219 --> 00:02:20,770
will teach you a little rusty

00:02:18,550 --> 00:02:22,780
if I only had one slide to explain the

00:02:20,770 --> 00:02:24,940
type system to you it would be this one

00:02:22,780 --> 00:02:26,800
the central proposition of the rest type

00:02:24,940 --> 00:02:29,670
system is to rule out the unrestricted

00:02:26,800 --> 00:02:32,260
combination of aliasing and mutation and

00:02:29,670 --> 00:02:34,480
the mechanism through which rust rust

00:02:32,260 --> 00:02:36,430
achieves this is ownership so for

00:02:34,480 --> 00:02:38,710
example if you create a vector influence

00:02:36,430 --> 00:02:41,590
and data and then you call a function

00:02:38,710 --> 00:02:43,570
which could be called send and pass the

00:02:41,590 --> 00:02:45,190
vector to that function rust consider

00:02:43,570 --> 00:02:46,870
this to be ownership transfer so you

00:02:45,190 --> 00:02:48,420
owned the vector after you created it

00:02:46,870 --> 00:02:51,280
meaning you are the only exclusive

00:02:48,420 --> 00:02:52,750
person able to access it and you gave it

00:02:51,280 --> 00:02:54,790
to send and now it's theirs and no

00:02:52,750 --> 00:02:56,470
longer yours one consequence of that is

00:02:54,790 --> 00:02:58,630
if you try to you do anything to the

00:02:56,470 --> 00:03:00,520
vector again later actually rust will

00:02:58,630 --> 00:03:02,890
disallow that it will tell you that V

00:03:00,520 --> 00:03:04,510
has been moved and this is actually

00:03:02,890 --> 00:03:06,490
really useful because one of the things

00:03:04,510 --> 00:03:08,500
sent could do is it could spawn a new

00:03:06,490 --> 00:03:09,970
thread and put the vector there and have

00:03:08,500 --> 00:03:11,770
the thread loop computation on the side

00:03:09,970 --> 00:03:13,270
even after Sanders returned and then

00:03:11,770 --> 00:03:16,270
there would be data raised here and that

00:03:13,270 --> 00:03:18,700
would not be fun so in general if you

00:03:16,270 --> 00:03:20,440
have some variable X of type T rust

00:03:18,700 --> 00:03:22,450
consider this data to be owned at the

00:03:20,440 --> 00:03:24,370
given type ownership implies that you

00:03:22,450 --> 00:03:26,170
can't do mutation and hence no aliasing

00:03:24,370 --> 00:03:27,610
and you can even deallocate because

00:03:26,170 --> 00:03:30,460
really if you own this nobody else even

00:03:27,610 --> 00:03:32,680
knows the data or even exists however

00:03:30,460 --> 00:03:34,600
ownership can't be everything because if

00:03:32,680 --> 00:03:36,700
you look at this example a closely you

00:03:34,600 --> 00:03:38,530
can see that we actually called a method

00:03:36,700 --> 00:03:40,540
here on the vector V and we were allowed

00:03:38,530 --> 00:03:42,070
to use it again so what's going on well

00:03:40,540 --> 00:03:43,780
let's disregard this method call and

00:03:42,070 --> 00:03:45,820
then we can see that what actually

00:03:43,780 --> 00:03:47,560
happens here is that we are creating a

00:03:45,820 --> 00:03:49,870
reference to the vector and passing that

00:03:47,560 --> 00:03:51,910
reference to push so the crucial

00:03:49,870 --> 00:03:54,040
difference here is that send is passed

00:03:51,910 --> 00:03:56,080
by a value which and rust is interpreted

00:03:54,040 --> 00:03:58,360
to be ownership transfer where as push

00:03:56,080 --> 00:04:01,120
is passed by a reference and in this

00:03:58,360 --> 00:04:03,700
case push is said to borrow ownership of

00:04:01,120 --> 00:04:05,620
the vector temporarily well I said

00:04:03,700 --> 00:04:07,210
temporarily but I should really make

00:04:05,620 --> 00:04:09,010
this precise because we don't want to

00:04:07,210 --> 00:04:11,590
just be guessing here how long is

00:04:09,010 --> 00:04:13,660
temporarily well to control this rust

00:04:11,590 --> 00:04:15,420
uses the concept of a lifetime which is

00:04:13,660 --> 00:04:18,190
also called a region in the literature

00:04:15,420 --> 00:04:20,920
so in the full type of push you can see

00:04:18,190 --> 00:04:22,900
tick a here is at the lifetime of the

00:04:20,920 --> 00:04:24,310
reference which pushed X's argument and

00:04:22,900 --> 00:04:25,600
it's an angle bracket indicating that

00:04:24,310 --> 00:04:26,800
the function is actually pulling off

00:04:25,600 --> 00:04:29,140
again that can't we left hand you think

00:04:26,800 --> 00:04:31,180
there is no lifetime given in the source

00:04:29,140 --> 00:04:31,879
code above so the compiler and first the

00:04:31,180 --> 00:04:33,709
left hand for

00:04:31,879 --> 00:04:35,179
and this scare didn't further Lefton to

00:04:33,709 --> 00:04:37,099
be just the duration of the function

00:04:35,179 --> 00:04:39,199
call which then explains why after

00:04:37,099 --> 00:04:41,990
function returned we can actually call

00:04:39,199 --> 00:04:43,699
send and use the vector V again because

00:04:41,990 --> 00:04:44,659
push can no longer be using it the

00:04:43,699 --> 00:04:47,209
borough has expired

00:04:44,659 --> 00:04:48,699
so ampersand mutex is a way to create a

00:04:47,209 --> 00:04:50,749
mutable reference to some data

00:04:48,699 --> 00:04:52,669
implicitly there's a lifetime here which

00:04:50,749 --> 00:04:55,759
is inferred by the compiler mutable

00:04:52,669 --> 00:04:57,619
references do a lot of mutation and

00:04:55,759 --> 00:04:58,999
hence not allow any aliasing so mutable

00:04:57,619 --> 00:05:02,149
references are always unique pointers

00:04:58,999 --> 00:05:03,709
now we've seen two examples of I'm

00:05:02,149 --> 00:05:04,999
having mutation and no aliasing so

00:05:03,709 --> 00:05:07,999
unsurprisingly the third example

00:05:04,999 --> 00:05:10,129
involves aliasing so concretely this

00:05:07,999 --> 00:05:12,699
code creates a local variable then

00:05:10,129 --> 00:05:15,769
spawns to threat that both concurrently

00:05:12,699 --> 00:05:17,569
read a pointer pointing to the stack

00:05:15,769 --> 00:05:19,369
frame of the main thread printing the

00:05:17,569 --> 00:05:21,349
current value of that of that variable

00:05:19,369 --> 00:05:23,899
and then when both threads are done we

00:05:21,349 --> 00:05:25,909
mutate X what's going on here is that

00:05:23,899 --> 00:05:28,129
ampersand X is a way to create a shared

00:05:25,909 --> 00:05:30,619
reference with which like mutable

00:05:28,129 --> 00:05:32,419
references come with a lifetime that is

00:05:30,619 --> 00:05:33,740
inferred by the compiler and shared

00:05:32,419 --> 00:05:35,059
references as the name indicates they

00:05:33,740 --> 00:05:37,129
can be a Lea they can be shared by

00:05:35,059 --> 00:05:39,559
multiple threads in this case and hence

00:05:37,129 --> 00:05:40,999
they do not allow rotation we can also

00:05:39,559 --> 00:05:43,159
see that in this case the lifetime

00:05:40,999 --> 00:05:45,039
inferred by the compiler is actually the

00:05:43,159 --> 00:05:47,779
duration of this joint function call

00:05:45,039 --> 00:05:49,639
which means that once join is done and

00:05:47,779 --> 00:05:51,800
both threads are actually done computing

00:05:49,639 --> 00:05:53,869
we can mutate the variable again so

00:05:51,800 --> 00:05:57,019
share references having a lifetime means

00:05:53,869 --> 00:05:58,339
that we can temporarily make data

00:05:57,019 --> 00:06:02,179
read-only and shared and then later

00:05:58,339 --> 00:06:04,069
regain full exclusive access so to

00:06:02,179 --> 00:06:05,509
summarize what we've seen so far rust

00:06:04,069 --> 00:06:07,459
type system is based on ownership which

00:06:05,509 --> 00:06:08,990
comes in three flavors there's full

00:06:07,459 --> 00:06:11,449
ownership you can do anything you want

00:06:08,990 --> 00:06:13,639
and then there's two kind of temporarily

00:06:11,449 --> 00:06:16,909
borrowing ownership which comes in the

00:06:13,639 --> 00:06:19,639
flavors of mutable and aliasing and both

00:06:16,909 --> 00:06:21,769
of these are controlled by lifetimes so

00:06:19,639 --> 00:06:22,819
this is all working very nicely the

00:06:21,769 --> 00:06:24,829
problem now is this seems pretty

00:06:22,819 --> 00:06:26,449
restrictive right sometimes you do need

00:06:24,829 --> 00:06:28,039
alias mutable state maybe you're doing

00:06:26,449 --> 00:06:29,569
shared memory concurrency and you have

00:06:28,039 --> 00:06:31,579
locks or something like that maybe you

00:06:29,569 --> 00:06:33,439
prefer a message passing and you have

00:06:31,579 --> 00:06:34,490
some channels that sin theta between

00:06:33,439 --> 00:06:35,539
threads there's also shared mutable

00:06:34,490 --> 00:06:37,999
state there

00:06:35,539 --> 00:06:39,319
or maybe it's sequential setting and

00:06:37,999 --> 00:06:41,509
you're doing reference counting for your

00:06:39,319 --> 00:06:43,189
memory management so what is rusts

00:06:41,509 --> 00:06:45,560
answer to this problem

00:06:43,189 --> 00:06:47,750
well let us look at an example

00:06:45,560 --> 00:06:49,970
this program creates a new text and

00:06:47,750 --> 00:06:52,669
mutexes contain data and rust so we

00:06:49,970 --> 00:06:55,190
initialize this with value 0 and then we

00:06:52,669 --> 00:06:58,040
spawn two threats that both acquire the

00:06:55,190 --> 00:06:59,510
lock do some error handling or well not

00:06:58,040 --> 00:07:02,090
to error handing it nor the Unruh appear

00:06:59,510 --> 00:07:04,220
and then increment the value that's

00:07:02,090 --> 00:07:06,410
stored in the lock and implicitly the

00:07:04,220 --> 00:07:08,510
lock is then released again when this

00:07:06,410 --> 00:07:10,130
goes out of scope and then once both of

00:07:08,510 --> 00:07:12,200
those words are done we print the

00:07:10,130 --> 00:07:14,900
current value and of course we expect

00:07:12,200 --> 00:07:16,820
this to be 3 so to understand what's

00:07:14,900 --> 00:07:19,280
going on here we should look at closer

00:07:16,820 --> 00:07:20,720
at the type of this lock method first of

00:07:19,280 --> 00:07:23,479
all it's a polymorphic method again

00:07:20,720 --> 00:07:25,700
taking working on any lifetime and it

00:07:23,479 --> 00:07:26,300
takes a shared reference to a mutex as

00:07:25,700 --> 00:07:28,400
its argument

00:07:26,300 --> 00:07:29,990
it's cooler this is shared because the

00:07:28,400 --> 00:07:31,729
holy idea of a lock is that multiple

00:07:29,990 --> 00:07:33,139
threads can be racing and trying to

00:07:31,729 --> 00:07:34,669
access the lock at the same time so if

00:07:33,139 --> 00:07:36,979
we wouldn't allow aliasing here that

00:07:34,669 --> 00:07:38,780
wouldn't make any sense the return type

00:07:36,979 --> 00:07:40,220
is little unwieldy but you can

00:07:38,780 --> 00:07:41,720
essentially think of this as being a

00:07:40,220 --> 00:07:43,160
mutable reference there's some more

00:07:41,720 --> 00:07:46,010
magic going on to do this automatic

00:07:43,160 --> 00:07:48,200
unlocking so what we've seen here is a

00:07:46,010 --> 00:07:50,539
method which takes a shared reference

00:07:48,200 --> 00:07:52,610
and then gives you a way to mutate stuff

00:07:50,539 --> 00:07:54,680
in there this is a phenomenon that is

00:07:52,610 --> 00:07:56,240
there has several instances in this 9

00:07:54,680 --> 00:07:59,300
library it's code interior mutability

00:07:56,240 --> 00:08:01,220
and it seems to completely break

00:07:59,300 --> 00:08:03,080
everything I said so far and it seems to

00:08:01,220 --> 00:08:04,280
be also inherently unimplemented because

00:08:03,080 --> 00:08:06,140
there are types that you shouldn't allow

00:08:04,280 --> 00:08:09,500
you to do anything like that

00:08:06,140 --> 00:08:11,390
well for the second part the reason that

00:08:09,500 --> 00:08:13,190
works is that rust has unsafe box and

00:08:11,390 --> 00:08:15,200
inside unsafe blocks there's additional

00:08:13,190 --> 00:08:17,150
things you can do and the compiler kind

00:08:15,200 --> 00:08:18,800
of says you're on your own there so for

00:08:17,150 --> 00:08:20,780
example you can call into the operating

00:08:18,800 --> 00:08:23,419
system and ask P thread to please

00:08:20,780 --> 00:08:24,710
acquire a lock for you and this is what

00:08:23,419 --> 00:08:26,800
the implementation of lock does if you

00:08:24,710 --> 00:08:29,450
run it on Linux

00:08:26,800 --> 00:08:30,800
however the claim of the developers of

00:08:29,450 --> 00:08:32,539
this library is that even though the

00:08:30,800 --> 00:08:35,209
implementation of the mutex is unsafe

00:08:32,539 --> 00:08:37,940
its API is safe so if you write safe

00:08:35,209 --> 00:08:39,440
code that uses the mutex you can't screw

00:08:37,940 --> 00:08:41,930
up and you can't have data races or

00:08:39,440 --> 00:08:44,810
other kind of memory problems and this

00:08:41,930 --> 00:08:46,700
is not isolated to mutex the explicity

00:08:44,810 --> 00:08:48,500
of rust is continuously extended in this

00:08:46,700 --> 00:08:50,570
way not just understand a library also

00:08:48,500 --> 00:08:53,360
by user libraries so this join method

00:08:50,570 --> 00:08:54,950
we've seen a couple times is actually an

00:08:53,360 --> 00:08:57,530
additional library that you can add into

00:08:54,950 --> 00:08:59,240
your rust code which has a sophisticate

00:08:57,530 --> 00:09:00,860
implemented based on average stealing

00:08:59,240 --> 00:09:02,839
who are using some unsafe code to be

00:09:00,860 --> 00:09:05,029
well possible and also to be efficient

00:09:02,839 --> 00:09:07,579
and again the claim of the author is if

00:09:05,029 --> 00:09:08,959
you use this from safe code your your

00:09:07,579 --> 00:09:10,850
program is not gonna crash I have any

00:09:08,959 --> 00:09:13,819
other kind of memory or threat safety

00:09:10,850 --> 00:09:16,009
issues so this brings us back to the

00:09:13,819 --> 00:09:17,629
goal of our raspberry search project we

00:09:16,009 --> 00:09:19,639
want to actually prove these claims of

00:09:17,629 --> 00:09:22,149
the rough types of some developers and

00:09:19,639 --> 00:09:24,139
of the library developers true and

00:09:22,149 --> 00:09:25,699
clearly because of this extensible

00:09:24,139 --> 00:09:27,110
nature of rust we have to do this in a

00:09:25,699 --> 00:09:29,179
way that our proof is also extensible

00:09:27,110 --> 00:09:30,980
and we can kind of prove new unsafe

00:09:29,179 --> 00:09:33,459
libraries safe without redoing the

00:09:30,980 --> 00:09:33,459
entire proof

00:09:40,770 --> 00:09:44,820
so now in the second part I'm going to

00:09:43,260 --> 00:09:46,830
give you an impression of what we did

00:09:44,820 --> 00:09:49,290
there we defined this lambda rust

00:09:46,830 --> 00:09:50,310
language and a type system for it the

00:09:49,290 --> 00:09:51,959
type system comes with a bunch of

00:09:50,310 --> 00:09:54,120
dead-end types like Moonies and integers

00:09:51,959 --> 00:09:55,830
three kinds of pointers matching the

00:09:54,120 --> 00:09:57,480
three kinds of ownership that rust has

00:09:55,830 --> 00:10:00,720
owned pointers new table and shared

00:09:57,480 --> 00:10:02,670
references some types product types and

00:10:00,720 --> 00:10:06,029
also of course function types recursive

00:10:02,670 --> 00:10:07,589
types or the usual business these types

00:10:06,029 --> 00:10:10,230
of them collected in the Taiping context

00:10:07,589 --> 00:10:11,760
which assigns types to pass that

00:10:10,230 --> 00:10:13,560
provides a way to directly talk about

00:10:11,760 --> 00:10:15,360
the types of individual fields of

00:10:13,560 --> 00:10:16,800
stretched because the rest types are

00:10:15,360 --> 00:10:18,270
actually tracks these separately for the

00:10:16,800 --> 00:10:21,270
purposes of these references and

00:10:18,270 --> 00:10:22,230
borrowing and of course we have a cup of

00:10:21,270 --> 00:10:23,880
typing judgments which are a

00:10:22,230 --> 00:10:25,350
substructure it shouldn't be a surprise

00:10:23,880 --> 00:10:27,029
after all the rest type system has

00:10:25,350 --> 00:10:29,550
ownership and you can lose access to

00:10:27,029 --> 00:10:32,040
data so we have a typing judgment for

00:10:29,550 --> 00:10:33,480
typing individual instructions which as

00:10:32,040 --> 00:10:35,160
usual and sub structure type systems

00:10:33,480 --> 00:10:36,720
comes with a pre and the post typing

00:10:35,160 --> 00:10:38,339
context indicating which stuff we have

00:10:36,720 --> 00:10:39,660
before and after executing the

00:10:38,339 --> 00:10:40,830
instruction and there are some

00:10:39,660 --> 00:10:44,220
additional context for tracking

00:10:40,830 --> 00:10:46,010
lifetimes and then we have having good

00:10:44,220 --> 00:10:48,570
me typing judgment for wholly functions

00:10:46,010 --> 00:10:50,579
and whole functions are written in

00:10:48,570 --> 00:10:51,750
continuation passing style so it doesn't

00:10:50,579 --> 00:10:53,550
come with the post type in context

00:10:51,750 --> 00:10:56,910
instead it comes with the context K

00:10:53,550 --> 00:10:58,470
tracking the possible continuations so

00:10:56,910 --> 00:11:00,000
of course you may not be expecting me to

00:10:58,470 --> 00:11:01,440
show you some typing rules so we do have

00:11:00,000 --> 00:11:03,660
we do have typing words we have plenty

00:11:01,440 --> 00:11:04,860
of time in fact you have so many

00:11:03,660 --> 00:11:06,660
interpreters I'm not going to show you

00:11:04,860 --> 00:11:09,959
any of them and focus on the high-level

00:11:06,660 --> 00:11:11,940
aspects of the type system instead the

00:11:09,959 --> 00:11:13,680
usual thing we will do now is prove a

00:11:11,940 --> 00:11:15,540
form of syntactic type safety result

00:11:13,680 --> 00:11:17,130
through progress and preservation but

00:11:15,540 --> 00:11:19,829
the problem with this is we would not

00:11:17,130 --> 00:11:21,510
have a story for doing unsafe code so we

00:11:19,829 --> 00:11:23,640
do what essentially what direct told us

00:11:21,510 --> 00:11:25,470
to do in his keynote and we use a

00:11:23,640 --> 00:11:28,079
semantic approach based on logical

00:11:25,470 --> 00:11:29,490
relations concretely we define an

00:11:28,079 --> 00:11:31,110
ownership predicate you can think of

00:11:29,490 --> 00:11:33,240
this as a somewhat elaborate version of

00:11:31,110 --> 00:11:36,240
this value relation that Derek had in

00:11:33,240 --> 00:11:38,130
his talk that for every type Tao tells

00:11:36,240 --> 00:11:40,730
us what does it mean to own data at this

00:11:38,130 --> 00:11:43,589
type ownership predicate in our model

00:11:40,730 --> 00:11:45,209
take two arguments one is the thread ID

00:11:43,589 --> 00:11:47,730
of the owning thread rust has a notion

00:11:45,209 --> 00:11:49,290
of types being thread safe and so we

00:11:47,730 --> 00:11:51,270
make ownership kind of depend on the

00:11:49,290 --> 00:11:53,279
thread to be able to model that and the

00:11:51,270 --> 00:11:54,420
second is the list of values at the list

00:11:53,279 --> 00:11:56,579
because rust types

00:11:54,420 --> 00:11:58,290
scrapp can describe data and memory so

00:11:56,579 --> 00:12:00,810
we kind of can kind of think of this as

00:11:58,290 --> 00:12:02,130
being all the adjacent memories that one

00:12:00,810 --> 00:12:03,779
after the other and then the predicate

00:12:02,130 --> 00:12:06,930
tells you is this valid at the given

00:12:03,779 --> 00:12:08,430
time once we have defined that for all

00:12:06,930 --> 00:12:10,649
types and we later give you a glimpse

00:12:08,430 --> 00:12:10,949
for how we do that we can excuse me

00:12:10,649 --> 00:12:14,130
sorry

00:12:10,949 --> 00:12:15,870
so we and of course we define this

00:12:14,130 --> 00:12:17,699
predicate and iris shouldn't be too

00:12:15,870 --> 00:12:19,680
surprising and that's very useful

00:12:17,699 --> 00:12:21,690
because iris kind of comes the built-in

00:12:19,680 --> 00:12:23,279
notion of ownership so we don't have any

00:12:21,690 --> 00:12:25,380
trouble modeling that part of rust it's

00:12:23,279 --> 00:12:27,300
also useful because iris lets us derive

00:12:25,380 --> 00:12:29,329
new reasoning principles inside the

00:12:27,300 --> 00:12:31,139
logic and this is very very useful later

00:12:29,329 --> 00:12:33,630
once we've defined this ownership

00:12:31,139 --> 00:12:35,850
predicate we can lift it to contexts and

00:12:33,630 --> 00:12:37,440
you can see already here that we are

00:12:35,850 --> 00:12:39,000
fully using the fact that we are in a

00:12:37,440 --> 00:12:40,680
separation logic clearly in Rus if you

00:12:39,000 --> 00:12:41,880
have two vectors and give away one of

00:12:40,680 --> 00:12:43,709
them you want to know you still have the

00:12:41,880 --> 00:12:45,839
other vector so we put a separate in

00:12:43,709 --> 00:12:48,540
conjunction between the elements of our

00:12:45,839 --> 00:12:49,649
typing context and if we if we wouldn't

00:12:48,540 --> 00:12:51,180
use the separation logic would now have

00:12:49,649 --> 00:12:53,160
to start manually talking about

00:12:51,180 --> 00:12:55,589
splitting resources we don't want to do

00:12:53,160 --> 00:12:58,290
that once we have all the typing

00:12:55,589 --> 00:12:59,850
contexts defined we can define typing

00:12:58,290 --> 00:13:01,829
judgments and again we make use of the

00:12:59,850 --> 00:13:03,810
fact that iris provides a program logic

00:13:01,829 --> 00:13:05,790
so we use a hot wrapper to say what is

00:13:03,810 --> 00:13:08,430
it what is it what does it mean to be a

00:13:05,790 --> 00:13:10,230
well typed instruction we are the pre

00:13:08,430 --> 00:13:14,610
and post type in context become pre and

00:13:10,230 --> 00:13:17,459
post conditions of the hot river so next

00:13:14,610 --> 00:13:19,019
we have to show that our semantic

00:13:17,459 --> 00:13:20,339
triples have anything to do with the

00:13:19,019 --> 00:13:22,589
syntactic type system we defined

00:13:20,339 --> 00:13:24,480
previously so I'm here are two all the

00:13:22,589 --> 00:13:26,130
typing rules I didn't show you and the

00:13:24,480 --> 00:13:27,449
exact rules don't matter the important

00:13:26,130 --> 00:13:29,220
thing is there's a bunch of turn starts

00:13:27,449 --> 00:13:30,690
near single turn starts and what we now

00:13:29,220 --> 00:13:32,190
do is we replace them by double turn

00:13:30,690 --> 00:13:35,070
starts and this makes it a statement in

00:13:32,190 --> 00:13:37,709
iris and for every single proof rule we

00:13:35,070 --> 00:13:39,630
go ahead and prove this iris this iris

00:13:37,709 --> 00:13:41,670
statement at the theorem once we did all

00:13:39,630 --> 00:13:44,069
that we get as the corollary that well

00:13:41,670 --> 00:13:45,690
type programs can go wrong so there's no

00:13:44,069 --> 00:13:46,500
later races and there's no invalid

00:13:45,690 --> 00:13:48,149
memory axis

00:13:46,500 --> 00:13:50,760
however we actually get much more than

00:13:48,149 --> 00:13:52,290
that if we have a large program which is

00:13:50,760 --> 00:13:54,180
mostly written in safe code but then

00:13:52,290 --> 00:13:57,149
uses some unsaved library let's say

00:13:54,180 --> 00:13:58,500
mutex then where we can type check the

00:13:57,149 --> 00:14:00,180
safe part of the program and we get a

00:13:58,500 --> 00:14:02,100
typing judgment for that but we can't

00:14:00,180 --> 00:14:04,019
type track mutexes loses uses features

00:14:02,100 --> 00:14:07,130
which we won't get a safe type system

00:14:04,019 --> 00:14:09,980
for however we can manually prove

00:14:07,130 --> 00:14:12,680
that mutex is semantically well typed at

00:14:09,980 --> 00:14:14,780
the type that is given in its in its API

00:14:12,680 --> 00:14:16,250
and because we have shown that

00:14:14,780 --> 00:14:18,140
everything that happened that we have

00:14:16,250 --> 00:14:19,220
shown this compatibility lemmas for

00:14:18,140 --> 00:14:21,380
everything that's happening we can

00:14:19,220 --> 00:14:24,290
actually lift the semantic softness of

00:14:21,380 --> 00:14:26,420
mutex and link it with the syntactically

00:14:24,290 --> 00:14:28,850
type checked code and obtain semantic

00:14:26,420 --> 00:14:30,650
soundness of the entire program so in

00:14:28,850 --> 00:14:32,660
the other words the whole program is

00:14:30,650 --> 00:14:34,520
safe if the unsaved pieces are safe and

00:14:32,660 --> 00:14:36,110
this is where the semantic approach

00:14:34,520 --> 00:14:37,940
really gives us a much stronger result

00:14:36,110 --> 00:14:41,510
than just showing a syntactic typed

00:14:37,940 --> 00:14:43,360
exterior so in the last part of the talk

00:14:41,510 --> 00:14:46,670
I want to give you a brief impression of

00:14:43,360 --> 00:14:49,010
how this type ownership predicate looks

00:14:46,670 --> 00:14:51,740
like so let's have a look at owned

00:14:49,010 --> 00:14:53,090
pointers to some type tau there's a

00:14:51,740 --> 00:14:54,740
bunch of bookkeeping going on here

00:14:53,090 --> 00:14:56,180
because we have these lists but what

00:14:54,740 --> 00:14:58,220
does me that what it says that its core

00:14:56,180 --> 00:14:59,660
is hopefully the kind of the interpreter

00:14:58,220 --> 00:15:02,000
you would expect there's a maps to there

00:14:59,660 --> 00:15:04,040
saying we own some memory we have some

00:15:02,000 --> 00:15:06,560
location L there's a list of values W

00:15:04,040 --> 00:15:09,980
and this list of values is a valid towel

00:15:06,560 --> 00:15:11,420
whatever the contour points to right now

00:15:09,980 --> 00:15:13,190
the really interesting types of course

00:15:11,420 --> 00:15:15,680
are the ones which makes which make was

00:15:13,190 --> 00:15:16,850
kind of different there are these

00:15:15,680 --> 00:15:19,040
reference types that come with a

00:15:16,850 --> 00:15:20,810
lifetime all right so first of all I

00:15:19,040 --> 00:15:22,130
would like to point out how the mutable

00:15:20,810 --> 00:15:24,680
reference is pretty similar to the old

00:15:22,130 --> 00:15:27,110
pointer it also has this maps to some

00:15:24,680 --> 00:15:28,760
list of values and then there's the list

00:15:27,110 --> 00:15:30,770
of values as valid as how well then

00:15:28,760 --> 00:15:32,360
there is this funny thing here which is

00:15:30,770 --> 00:15:33,560
this looks like a tie but it's actually

00:15:32,360 --> 00:15:36,620
a connective in the logic it's like a

00:15:33,560 --> 00:15:38,060
modality this is really find a way to be

00:15:36,620 --> 00:15:39,680
able to talk about borrowing in

00:15:38,060 --> 00:15:41,270
separation logic in general not just

00:15:39,680 --> 00:15:44,300
syntactically as part of the type system

00:15:41,270 --> 00:15:46,430
and we call this the lifetime logic the

00:15:44,300 --> 00:15:49,280
central proposition of the tab lifetime

00:15:46,430 --> 00:15:51,260
logic is that in contrast to traditional

00:15:49,280 --> 00:15:53,450
separation logic where you split

00:15:51,260 --> 00:15:55,790
ownership in space right P star Q means

00:15:53,450 --> 00:15:57,860
P and Q hold for different parts of the

00:15:55,790 --> 00:16:00,350
heap and the left-hand object we can

00:15:57,860 --> 00:16:01,970
separate ownership in time so let me

00:16:00,350 --> 00:16:04,100
demonstrate this by looking a little

00:16:01,970 --> 00:16:05,300
closer at the central approval of the

00:16:04,100 --> 00:16:09,320
lifetime logic at the bottom you can

00:16:05,300 --> 00:16:11,930
find a timeline where now is the point

00:16:09,320 --> 00:16:14,630
in time when when the rule is applied

00:16:11,930 --> 00:16:17,089
and dagger Kappa is the point in time at

00:16:14,630 --> 00:16:18,500
the left and gets killed and in so

00:16:17,089 --> 00:16:19,939
before they got kept are kept as alive

00:16:18,500 --> 00:16:23,299
after they got Kappa

00:16:19,939 --> 00:16:26,569
dead now this rule says that if we own

00:16:23,299 --> 00:16:28,699
any assertion P then we can do the

00:16:26,569 --> 00:16:32,089
following we can split P into two parts

00:16:28,699 --> 00:16:34,189
the first part grants us access to P Y

00:16:32,089 --> 00:16:35,720
the lifetime cap our last that's from

00:16:34,189 --> 00:16:38,839
now until take a Kappa

00:16:35,720 --> 00:16:41,659
and the second part grants us access to

00:16:38,839 --> 00:16:43,819
P when after Kappa has ended so that's

00:16:41,659 --> 00:16:46,359
that's essentially from daga Kappa until

00:16:43,819 --> 00:16:49,009
the end of time and because these two

00:16:46,359 --> 00:16:50,959
these two parts of the timeline are

00:16:49,009 --> 00:16:52,579
disjoint it is justified to put a

00:16:50,959 --> 00:16:54,019
separate in conjunction between these

00:16:52,579 --> 00:16:57,049
two pieces even though they both take

00:16:54,019 --> 00:16:59,239
talked about the same resources P and

00:16:57,049 --> 00:17:01,459
the way we've shown that this makes any

00:16:59,239 --> 00:17:03,739
sense is we have given a model to the

00:17:01,459 --> 00:17:05,240
left hand logic in iris and proved

00:17:03,739 --> 00:17:07,730
incorrect its roots and this is where we

00:17:05,240 --> 00:17:09,019
really fully honed in on irises ability

00:17:07,730 --> 00:17:10,909
to be able to derive new reasoning

00:17:09,019 --> 00:17:12,649
principles inside the logic we didn't

00:17:10,909 --> 00:17:16,429
have to touch the model of iris to be

00:17:12,649 --> 00:17:18,199
able to do the verification so this

00:17:16,429 --> 00:17:20,959
brings me especially to the end of my

00:17:18,199 --> 00:17:23,179
talk the in the paper we show a couple

00:17:20,959 --> 00:17:25,699
more details about lambda rust the

00:17:23,179 --> 00:17:26,720
language about the type system some of

00:17:25,699 --> 00:17:28,700
the typing boots that didn't show you

00:17:26,720 --> 00:17:30,950
and of course the left hand logic and a

00:17:28,700 --> 00:17:32,629
whole bunch of rules for that we also

00:17:30,950 --> 00:17:34,279
show how we can handle in theory

00:17:32,629 --> 00:17:35,809
immutability remember that's this idea

00:17:34,279 --> 00:17:38,720
where you can actually in controlled

00:17:35,809 --> 00:17:40,639
ways mutate share data

00:17:38,720 --> 00:17:43,490
I hope it's somewhat intuitively clear

00:17:40,639 --> 00:17:45,049
that this makes the the justification

00:17:43,490 --> 00:17:46,940
for why share references work more

00:17:45,049 --> 00:17:48,799
complicated but it's not just shared

00:17:46,940 --> 00:17:50,480
references are read only in a mutex you

00:17:48,799 --> 00:17:51,620
can actually write to them so the

00:17:50,480 --> 00:17:53,840
justification can become more

00:17:51,620 --> 00:17:56,120
complicated we explain how that works

00:17:53,840 --> 00:17:59,450
and for two country two types a few tags

00:17:56,120 --> 00:18:01,220
and cell moreover we have a compromise

00:17:59,450 --> 00:18:03,200
ation where we've shown a couple more

00:18:01,220 --> 00:18:05,059
types to be that also all in work

00:18:03,200 --> 00:18:06,649
interior mutability to be semantically

00:18:05,059 --> 00:18:08,000
well typed and in one of them we

00:18:06,649 --> 00:18:09,639
actually found a bark that we've then

00:18:08,000 --> 00:18:12,220
also fixed in the rest in a library

00:18:09,639 --> 00:18:14,269
that's that we don't model full rust

00:18:12,220 --> 00:18:16,460
there are still a couple of things from

00:18:14,269 --> 00:18:18,500
in rust that we that we didn't handle

00:18:16,460 --> 00:18:19,879
one of them is trade objects which are

00:18:18,500 --> 00:18:22,279
essentially a form of existential types

00:18:19,879 --> 00:18:23,960
and rust we don't have a big memory so

00:18:22,279 --> 00:18:26,000
we consider things to be sequentially

00:18:23,960 --> 00:18:27,470
consistent but we do have a notion of

00:18:26,000 --> 00:18:29,450
non-atomic accesses so that we can

00:18:27,470 --> 00:18:32,100
reason about data races and we don't

00:18:29,450 --> 00:18:33,419
consider drop which is kind of automatic

00:18:32,100 --> 00:18:35,100
structure and they're actually being

00:18:33,419 --> 00:18:36,750
some interesting issues there as well so

00:18:35,100 --> 00:18:40,110
this is certainly very interesting

00:18:36,750 --> 00:18:42,840
future work to look at so to to finish

00:18:40,110 --> 00:18:44,850
up we claim that logic relations are a

00:18:42,840 --> 00:18:47,250
great way to prove safety of languages

00:18:44,850 --> 00:18:48,720
with unsafe operations and in this paper

00:18:47,250 --> 00:18:51,090
we have shown that advances in

00:18:48,720 --> 00:18:53,490
separation logic as realized in iris

00:18:51,090 --> 00:18:55,770
actually make this possible for logic

00:18:53,490 --> 00:18:57,860
that is as sophisticated as rusty thank

00:18:55,770 --> 00:18:57,860
you

00:19:03,110 --> 00:19:21,679
ah excellent so is the way to think

00:19:19,880 --> 00:19:24,470
about this that the only unsafe actions

00:19:21,679 --> 00:19:26,600
modeled here are ignoring the ownership

00:19:24,470 --> 00:19:28,580
protocol or are there other kinds of

00:19:26,600 --> 00:19:31,190
unsafety like for example an unsafe

00:19:28,580 --> 00:19:31,700
course operation unsafety allows you to

00:19:31,190 --> 00:19:33,890
do anything

00:19:31,700 --> 00:19:35,919
simply drop down to see you have full

00:19:33,890 --> 00:19:37,820
casts role Ponder's point arithmetic

00:19:35,919 --> 00:19:41,150
everything you can do and see ok how

00:19:37,820 --> 00:19:43,130
much of that is modeled in we I mean we

00:19:41,150 --> 00:19:44,450
don't model all of the subtle cases of

00:19:43,130 --> 00:19:46,130
undefined behavior but certainly our

00:19:44,450 --> 00:19:49,940
language does allow you to do IRA's

00:19:46,130 --> 00:19:51,620
arithmetic and deallocate stuff too

00:19:49,940 --> 00:19:53,750
early and try to access it and all of

00:19:51,620 --> 00:19:54,950
that so we have our language is a

00:19:53,750 --> 00:19:57,260
low-level language would be a location

00:19:54,950 --> 00:19:59,690
and front arithmetic and everything and

00:19:57,260 --> 00:20:01,190
we prove that you don't access data that

00:19:59,690 --> 00:20:01,820
has already been dedicated or that is

00:20:01,190 --> 00:20:07,370
out of bounds

00:20:01,820 --> 00:20:10,130
I see thank you so first thanks for the

00:20:07,370 --> 00:20:12,140
talk um so it's kind of you have to

00:20:10,130 --> 00:20:13,700
explain that if you if you had to

00:20:12,140 --> 00:20:15,549
mutable references and you would send

00:20:13,700 --> 00:20:17,990
them to different threads and both

00:20:15,549 --> 00:20:19,760
resonate them obviously that would pose

00:20:17,990 --> 00:20:22,270
a problem and that's why you said man

00:20:19,760 --> 00:20:26,740
mutable references are not allowed

00:20:22,270 --> 00:20:29,270
multiple of them so now the question is

00:20:26,740 --> 00:20:32,059
from from my experience from using rust

00:20:29,270 --> 00:20:35,059
like in most of the cases of course most

00:20:32,059 --> 00:20:37,549
of the variables and data structures you

00:20:35,059 --> 00:20:39,860
don't send to others writes still you

00:20:37,549 --> 00:20:42,320
cannot use multiple mutable references

00:20:39,860 --> 00:20:44,330
and now the question that that I kind of

00:20:42,320 --> 00:20:48,169
sometimes head is is this restriction

00:20:44,330 --> 00:20:51,049
that is that has some kind of background

00:20:48,169 --> 00:20:53,690
so that would would something break down

00:20:51,049 --> 00:20:55,520
except for this reading part if you were

00:20:53,690 --> 00:20:56,929
to use multiple mutable refer or if it

00:20:55,520 --> 00:20:58,929
were allowed to use multiple multiple

00:20:56,929 --> 00:21:02,990
mutable references or is this just

00:20:58,929 --> 00:21:05,740
because it's considered not a good style

00:21:02,990 --> 00:21:08,299
to have multiple mutable references

00:21:05,740 --> 00:21:10,460
things would break one example is

00:21:08,299 --> 00:21:12,440
interpreting validation if you have if

00:21:10,460 --> 00:21:14,419
you have a mutable reference or any kind

00:21:12,440 --> 00:21:15,559
of reference into a vector but then also

00:21:14,419 --> 00:21:16,550
have a mutable reference to the vector

00:21:15,559 --> 00:21:18,800
as a whole

00:21:16,550 --> 00:21:21,740
like empty it now you're in a reference

00:21:18,800 --> 00:21:24,290
is broken so so this completely serves

00:21:21,740 --> 00:21:26,570
iterator imitation a static way

00:21:24,290 --> 00:21:28,790
another example is Russa has some types

00:21:26,570 --> 00:21:30,590
so you can actually change the type of

00:21:28,790 --> 00:21:31,970
memory by switching sometimes the

00:21:30,590 --> 00:21:33,770
implement is unions overlapping memory

00:21:31,970 --> 00:21:35,450
we can change the type of a particular

00:21:33,770 --> 00:21:37,100
location in memory by switching to a

00:21:35,450 --> 00:21:38,900
different variant so if you would have

00:21:37,100 --> 00:21:41,420
still a metered reference into the thing

00:21:38,900 --> 00:21:43,670
and then mutate the outer thing know

00:21:41,420 --> 00:21:44,960
you're in a reference is at the wrong

00:21:43,670 --> 00:21:46,370
type okay

00:21:44,960 --> 00:21:49,930
sequential code you have the same

00:21:46,370 --> 00:21:51,800
problems that's kind of what I wanted a

00:21:49,930 --> 00:21:54,080
very nice look

00:21:51,800 --> 00:21:56,900
I had couple of questions one is I was

00:21:54,080 --> 00:22:00,710
pretty intrigued by your lifetime

00:21:56,900 --> 00:22:02,720
separation concept in your paper and in

00:22:00,710 --> 00:22:04,970
mind way reminded me of cryptographic

00:22:02,720 --> 00:22:08,150
storage protocols where you have

00:22:04,970 --> 00:22:10,130
revocation of keys owned by a owner so

00:22:08,150 --> 00:22:13,220
they can define different access

00:22:10,130 --> 00:22:16,340
controls for different points in time so

00:22:13,220 --> 00:22:18,380
have you considered kind of using the

00:22:16,340 --> 00:22:20,030
theory developed in iris to kind of look

00:22:18,380 --> 00:22:23,720
at verification of those stories

00:22:20,030 --> 00:22:25,580
protocols okay but that seems like a

00:22:23,720 --> 00:22:27,110
promise interaction your second question

00:22:25,580 --> 00:22:29,330
was kind of related to the previous

00:22:27,110 --> 00:22:33,290
question which is you mentioned that

00:22:29,330 --> 00:22:36,260
lots of users of unsafe in rust and some

00:22:33,290 --> 00:22:38,030
of them are for optimization so did you

00:22:36,260 --> 00:22:39,380
discover during this project some

00:22:38,030 --> 00:22:41,990
reasoning principles that you can

00:22:39,380 --> 00:22:44,290
translate back into type system concepts

00:22:41,990 --> 00:22:48,350
to to kind of enrich the type system to

00:22:44,290 --> 00:22:52,010
not have to use so know is to kind of

00:22:48,350 --> 00:23:04,340
take those unsafe uses and transformed

00:22:52,010 --> 00:23:06,620
into safe uses so we can type check more

00:23:04,340 --> 00:23:07,730
programs than last can maybe not

00:23:06,620 --> 00:23:09,500
strictly more because you don't have a

00:23:07,730 --> 00:23:11,210
formal version of what the compiler

00:23:09,500 --> 00:23:13,190
concretely does but there's certainly

00:23:11,210 --> 00:23:15,080
programs we can type check after manual

00:23:13,190 --> 00:23:16,330
translation to our core calculus which

00:23:15,080 --> 00:23:18,200
the rest compiler doesn't have check

00:23:16,330 --> 00:23:19,430
that's that the rest compiler is

00:23:18,200 --> 00:23:21,230
currently being extended with a new

00:23:19,430 --> 00:23:23,390
lifetime mechanism or lexical lifetimes

00:23:21,230 --> 00:23:24,980
which is extremely powerful and seems to

00:23:23,390 --> 00:23:27,200
in some places even be even more

00:23:24,980 --> 00:23:28,430
powerful than what we model so they are

00:23:27,200 --> 00:23:29,690
certainly going to be a little bit of

00:23:28,430 --> 00:23:30,980
back and forth in terms of

00:23:29,690 --> 00:23:33,590
justing the power of what we can prove

00:23:30,980 --> 00:23:37,399
and and what the growth compiler is able

00:23:33,590 --> 00:23:41,240
to check okay thank you you said that

00:23:37,399 --> 00:23:42,799
you had verified the mutex code B as

00:23:41,240 --> 00:23:45,379
being safe does that mean that you have

00:23:42,799 --> 00:23:49,309
a formal semantics for P threads now

00:23:45,379 --> 00:23:52,129
model mutex by doing a spin lock by by

00:23:49,309 --> 00:23:53,899
doing a spin lock okay so we've not

00:23:52,129 --> 00:23:56,210
focused on on the actual C

00:23:53,899 --> 00:23:58,309
implementation it was more we it was

00:23:56,210 --> 00:24:00,350
code of this behavior which after doing

00:23:58,309 --> 00:24:02,299
mutual exclusion gives you a rust like

00:24:00,350 --> 00:24:04,009
type level mutable reference is that

00:24:02,299 --> 00:24:06,940
actually a sane and safe thing to do in

00:24:04,009 --> 00:24:06,940
rust and that what we fool

00:24:25,940 --> 00:24:31,440
no rust subsystem doesn't guarantee the

00:24:29,850 --> 00:24:34,139
question is linear tap systems often

00:24:31,440 --> 00:24:35,899
guarantee that you don't have any rust

00:24:34,139 --> 00:24:37,529
type system doesn't guarantee that

00:24:35,899 --> 00:24:39,690
certainly they made this choice

00:24:37,529 --> 00:24:41,580
liberally because they tried to find a

00:24:39,690 --> 00:24:43,049
way to have ref counted pointers and

00:24:41,580 --> 00:24:44,759
still guarantee League freedom and

00:24:43,049 --> 00:24:47,669
didn't find anything that was sane and

00:24:44,759 --> 00:24:49,259
then decided that we not they don't

00:24:47,669 --> 00:24:51,450
guarantee that so the the core us

00:24:49,259 --> 00:24:52,679
without any unsafe code could probably

00:24:51,450 --> 00:24:54,450
you could probably prove a theorem like

00:24:52,679 --> 00:24:55,919
that but rust-eze adduced the factor

00:24:54,450 --> 00:24:57,450
with the style library does not

00:24:55,919 --> 00:24:59,639
guarantee League freedom and anyway I

00:24:57,450 --> 00:25:03,409
was not currently set up to prove League

00:24:59,639 --> 00:25:03,409
freedom so we couldn't prove that anyway

00:25:05,400 --> 00:25:10,849

YouTube URL: https://www.youtube.com/watch?v=Cy9NUVaiYUg


