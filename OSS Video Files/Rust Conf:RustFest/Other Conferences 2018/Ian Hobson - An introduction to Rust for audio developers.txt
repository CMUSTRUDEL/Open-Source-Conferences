Title: Ian Hobson - An introduction to Rust for audio developers
Publication date: 2018-11-28
Playlist: Other Conferences 2018
Description: 
	Rust is a relatively new systems programming language which is quickly developing into an alternative to C++ for realtime audio applications. Starting with the basics, weâ€™ll quickly get up to speed with everything needed to write audio applications in Rust, explore some of its pros and cons, and how to make use of it in existing codebases.
Captions: 
	00:00:00,000 --> 00:00:03,990
talk of the day and also of the

00:00:01,890 --> 00:00:06,629
conference so we've got in Hobson here

00:00:03,990 --> 00:00:08,370
who is the technical principal for DSP

00:00:06,629 --> 00:00:10,349
and device sir Ableton and he's going to

00:00:08,370 --> 00:00:11,790
talk about an introduction to rust for

00:00:10,349 --> 00:00:19,590
audio developer so please give a back

00:00:11,790 --> 00:00:24,300
and for in hello hi can you can you hear

00:00:19,590 --> 00:00:27,570
me cool great yes so welcome I'm very

00:00:24,300 --> 00:00:29,400
excited to be able to talk with you all

00:00:27,570 --> 00:00:31,710
today about rust the programming

00:00:29,400 --> 00:00:34,280
language which I've been following for a

00:00:31,710 --> 00:00:37,020
few years now I'm very interested in and

00:00:34,280 --> 00:00:42,270
I'm looking forward to sharing some of

00:00:37,020 --> 00:00:45,360
my thoughts about it with you my goals

00:00:42,270 --> 00:00:47,039
for this talk definitely not to suggest

00:00:45,360 --> 00:00:50,219
that you should drop everything in news

00:00:47,039 --> 00:00:53,100
for us that's totally not my goal what

00:00:50,219 --> 00:00:55,860
I'm hoping to achieve is to show you a

00:00:53,100 --> 00:00:58,079
brief overview of the language and then

00:00:55,860 --> 00:01:00,030
give you the necessary entry points to

00:00:58,079 --> 00:01:02,010
be able to explore it on your own I

00:01:00,030 --> 00:01:05,400
think it's a fun language to play with

00:01:02,010 --> 00:01:07,860
and hopefully if if I if I do this right

00:01:05,400 --> 00:01:09,990
you'll feel like there's nothing

00:01:07,860 --> 00:01:14,369
stopping you from exploring it if you if

00:01:09,990 --> 00:01:16,140
you fancy it also I'm going to show how

00:01:14,369 --> 00:01:17,549
you can use rust in your existing

00:01:16,140 --> 00:01:20,490
projects if that's something that would

00:01:17,549 --> 00:01:22,080
be interesting to you and at the end if

00:01:20,490 --> 00:01:24,299
we have time I'll give a quick overview

00:01:22,080 --> 00:01:25,590
of the state of some of the important

00:01:24,299 --> 00:01:30,869
features that we need an audio

00:01:25,590 --> 00:01:34,680
development so a bit about me working at

00:01:30,869 --> 00:01:36,570
Ableton in Berlin since 2011 as

00:01:34,680 --> 00:01:39,020
mentioned already I'm the technical

00:01:36,570 --> 00:01:41,909
principal for DSP and devices there and

00:01:39,020 --> 00:01:43,409
what that means is I have a dual role

00:01:41,909 --> 00:01:44,729
essentially where I'm working as a

00:01:43,409 --> 00:01:46,649
software engineer in the sound team

00:01:44,729 --> 00:01:50,159
working on our instruments and effects

00:01:46,649 --> 00:01:55,049
and I'm also looking after a long term

00:01:50,159 --> 00:01:56,549
strategy for sound technology so in

00:01:55,049 --> 00:01:58,259
terms of sound technology there isn't

00:01:56,549 --> 00:02:02,189
really anything more fundamental to what

00:01:58,259 --> 00:02:05,610
we do than use C++ so why am i

00:02:02,189 --> 00:02:09,750
interested in rust well like many of you

00:02:05,610 --> 00:02:12,590
I think you'll be using C++ it really

00:02:09,750 --> 00:02:15,260
dominates the music software industry

00:02:12,590 --> 00:02:17,989
and it has since the start of my career

00:02:15,260 --> 00:02:19,400
so about 15 years and there hasn't

00:02:17,989 --> 00:02:23,569
really been much choice we've been using

00:02:19,400 --> 00:02:26,390
C++ or C if you're feeling brave or some

00:02:23,569 --> 00:02:29,840
somewhere on the spectrum between basic

00:02:26,390 --> 00:02:31,610
C and full-blown C++ with all the bells

00:02:29,840 --> 00:02:34,430
and whistles and you'll find some

00:02:31,610 --> 00:02:40,069
comfort zone in that spectrum of C and

00:02:34,430 --> 00:02:43,790
C++ did we have a choice beyond that not

00:02:40,069 --> 00:02:47,150
really that I've known about I haven't

00:02:43,790 --> 00:02:50,599
seen a viable alternative in my career I

00:02:47,150 --> 00:02:54,860
think there might have been in the old

00:02:50,599 --> 00:02:56,630
days like Delfy I think I remember

00:02:54,860 --> 00:02:58,250
seeing some code examples in Delfy when

00:02:56,630 --> 00:03:01,610
I was starting out I haven't seen many

00:02:58,250 --> 00:03:03,200
since if you use Delfy and you think

00:03:01,610 --> 00:03:09,019
it's great then let me know I'd be

00:03:03,200 --> 00:03:10,849
interested but rust like it has caught

00:03:09,019 --> 00:03:15,170
my eye and I think is caught a few of

00:03:10,849 --> 00:03:17,359
your eyes too because it offers much of

00:03:15,170 --> 00:03:20,239
what I like about C++ you get low level

00:03:17,359 --> 00:03:24,019
control high level abstractions

00:03:20,239 --> 00:03:27,019
I like abstractions so I tend towards

00:03:24,019 --> 00:03:29,420
the C++ end of things performance on par

00:03:27,019 --> 00:03:31,700
with C and C++ I'm not gonna spend time

00:03:29,420 --> 00:03:33,200
improving this but if you allow me to

00:03:31,700 --> 00:03:34,459
wave my hands and say it's basically the

00:03:33,200 --> 00:03:36,170
same kind of performance II you get

00:03:34,459 --> 00:03:39,859
received plus past and one how you tune

00:03:36,170 --> 00:03:43,370
things but we can just say that they're

00:03:39,859 --> 00:03:46,190
in the same ballpark and it offers

00:03:43,370 --> 00:03:48,889
precise timing and this is the the thing

00:03:46,190 --> 00:03:51,109
that really has stopped me from

00:03:48,889 --> 00:03:53,630
investigating a lot of languages that

00:03:51,109 --> 00:03:55,639
look attractive that usually have

00:03:53,630 --> 00:03:58,220
garbage collection or some kind of

00:03:55,639 --> 00:04:01,130
messaging system that locks or something

00:03:58,220 --> 00:04:03,470
that's just in the way so it's quite

00:04:01,130 --> 00:04:05,900
exciting to me that there's maybe a

00:04:03,470 --> 00:04:11,000
viable alternative now to C++ for

00:04:05,900 --> 00:04:12,380
real-time audio so a bit about the

00:04:11,000 --> 00:04:14,299
background of rust for those of you who

00:04:12,380 --> 00:04:16,400
don't know it started as a project at

00:04:14,299 --> 00:04:17,750
Mozilla they were interested in maybe

00:04:16,400 --> 00:04:20,659
finding an alternative language for

00:04:17,750 --> 00:04:22,520
building complex applications like web

00:04:20,659 --> 00:04:24,169
browsers that have lots of security

00:04:22,520 --> 00:04:25,730
holes because of common programming

00:04:24,169 --> 00:04:28,460
mistakes that people

00:04:25,730 --> 00:04:30,770
often makin see in C++ so this was a

00:04:28,460 --> 00:04:33,200
language that was intended for maybe a

00:04:30,770 --> 00:04:35,330
new approach to building complex

00:04:33,200 --> 00:04:38,270
applications if they announced it

00:04:35,330 --> 00:04:39,830
publicly in 2012 I've got lots of other

00:04:38,270 --> 00:04:41,750
people on board now Mozilla aren't the

00:04:39,830 --> 00:04:43,280
majority contributor many other people

00:04:41,750 --> 00:04:47,060
are contributing to rust and there's an

00:04:43,280 --> 00:04:51,220
open development process and they

00:04:47,060 --> 00:04:54,320
reached a stable 1.0 release in 2015

00:04:51,220 --> 00:04:55,550
which allowed people to start using it

00:04:54,320 --> 00:04:57,080
in production essentially because they

00:04:55,550 --> 00:05:02,540
knew their code would continue to run as

00:04:57,080 --> 00:05:05,210
the chain evolved and in 2016 Mozilla

00:05:02,540 --> 00:05:07,340
managed to start shipping code that was

00:05:05,210 --> 00:05:09,320
written with rust in Firefox and since

00:05:07,340 --> 00:05:12,500
then the amount of code that is shipping

00:05:09,320 --> 00:05:15,010
in Firefox with rust has grown and they

00:05:12,500 --> 00:05:17,840
seem very happy about it

00:05:15,010 --> 00:05:19,820
also happy about rust are the people who

00:05:17,840 --> 00:05:22,130
vote in the stack overflow developer

00:05:19,820 --> 00:05:23,810
survey and for the last three years it

00:05:22,130 --> 00:05:26,060
has been voted the most loved language

00:05:23,810 --> 00:05:29,330
know what that means exactly I don't

00:05:26,060 --> 00:05:31,310
know but it's worth pointing out that

00:05:29,330 --> 00:05:33,500
this language is getting a lot of

00:05:31,310 --> 00:05:38,150
attention a lot of mainstream traction

00:05:33,500 --> 00:05:40,010
and so then to me it seems sensible for

00:05:38,150 --> 00:05:42,470
us to be thinking about it in this

00:05:40,010 --> 00:05:45,530
context which is why I suggested doing a

00:05:42,470 --> 00:05:47,090
talk about it and it's not really my

00:05:45,530 --> 00:05:49,490
place to give this talk in a way like

00:05:47,090 --> 00:05:51,680
I'm not a rust contributor or anything

00:05:49,490 --> 00:05:54,410
I'm not an expert but a an enthusiast

00:05:51,680 --> 00:05:56,960
and thought see if we could start a

00:05:54,410 --> 00:05:59,660
conversation about having an alternative

00:05:56,960 --> 00:06:03,560
language to C++ C figures worth talking

00:05:59,660 --> 00:06:06,830
about so let's get involved in a bits of

00:06:03,560 --> 00:06:09,050
rust is hello world and you can see

00:06:06,830 --> 00:06:10,940
already that it looks quite familiar to

00:06:09,050 --> 00:06:12,710
C in C++

00:06:10,940 --> 00:06:15,800
I've got curly braces and semicolons

00:06:12,710 --> 00:06:18,920
we've got a function that's being called

00:06:15,800 --> 00:06:21,650
called main the the exclamation mark on

00:06:18,920 --> 00:06:23,060
the end of print line means macro and in

00:06:21,650 --> 00:06:25,340
rust macros are okay

00:06:23,060 --> 00:06:27,590
they're not even looking C and that

00:06:25,340 --> 00:06:30,260
prints out hello world very good

00:06:27,590 --> 00:06:32,270
here's a slightly more complicated hello

00:06:30,260 --> 00:06:35,000
world I don't know if that's maybe too

00:06:32,270 --> 00:06:36,710
big for that looks all right okay so we

00:06:35,000 --> 00:06:38,090
call a function get name that returns a

00:06:36,710 --> 00:06:38,840
string then we pass that string into

00:06:38,090 --> 00:06:41,120
another function

00:06:38,840 --> 00:06:44,630
then we use a formatting thing to print

00:06:41,120 --> 00:06:47,120
out hello ADC isn't even more

00:06:44,630 --> 00:06:50,090
complicated example where now we're

00:06:47,120 --> 00:06:51,860
using an enum and here in rust enums are

00:06:50,090 --> 00:06:54,650
like see like enums but also like

00:06:51,860 --> 00:06:56,990
variants in c++ they they are some types

00:06:54,650 --> 00:06:59,060
and you can apply very nice language

00:06:56,990 --> 00:07:02,479
based pattern matching 2d structure the

00:06:59,060 --> 00:07:06,590
the option in the in the enum and then

00:07:02,479 --> 00:07:09,380
print that out and this is nice but this

00:07:06,590 --> 00:07:11,660
isn't why I think rust is interesting it

00:07:09,380 --> 00:07:14,750
offers like a lot of interesting

00:07:11,660 --> 00:07:18,830
ergonomic enhancements to your your

00:07:14,750 --> 00:07:22,700
programming that don't exist yet in C++

00:07:18,830 --> 00:07:25,729
but maybe over time they will we'll see

00:07:22,700 --> 00:07:28,639
what happens we hope but that's not why

00:07:25,729 --> 00:07:31,070
I think it rust is worth investigating

00:07:28,639 --> 00:07:32,479
really if if that if economics was all

00:07:31,070 --> 00:07:36,949
it was it wouldn't be particularly

00:07:32,479 --> 00:07:38,860
interesting I think but there are some

00:07:36,949 --> 00:07:41,419
fundamental properties that make rust

00:07:38,860 --> 00:07:46,190
very different to work with compared to

00:07:41,419 --> 00:07:50,570
C++ let's take a look at what some of

00:07:46,190 --> 00:07:54,800
those properties are this is C C++ code

00:07:50,570 --> 00:07:59,060
we have a value a and then we take two

00:07:54,800 --> 00:08:00,590
pointers to a and then we manipulate a

00:07:59,060 --> 00:08:03,200
via the pointers and then we dereference

00:08:00,590 --> 00:08:06,590
the pointers to print out a value if we

00:08:03,200 --> 00:08:09,020
do the same thing in rust well this is

00:08:06,590 --> 00:08:11,450
the equivalent code here we have a

00:08:09,020 --> 00:08:13,070
mutable value a in rust everything is

00:08:11,450 --> 00:08:16,250
concert by default and you have to buy

00:08:13,070 --> 00:08:18,289
into mutability we take two mutable

00:08:16,250 --> 00:08:20,810
references to a then we manipulate

00:08:18,289 --> 00:08:22,130
values print them out but the compiler

00:08:20,810 --> 00:08:24,710
will block you from doing this because

00:08:22,130 --> 00:08:27,260
we cannot borrow a as mutiple more than

00:08:24,710 --> 00:08:30,950
once at a time first mutable borrow

00:08:27,260 --> 00:08:33,260
occurs here a second okay so that's a

00:08:30,950 --> 00:08:34,459
rule that the compiler has the you're

00:08:33,260 --> 00:08:38,089
not allowed more than one mutable

00:08:34,459 --> 00:08:43,070
reference okay what if we make the

00:08:38,089 --> 00:08:44,779
second reference immutable so that we're

00:08:43,070 --> 00:08:46,190
only taking one mutable reference well

00:08:44,779 --> 00:08:48,140
the compiler still blocks you here

00:08:46,190 --> 00:08:50,690
cannot borrow hey as immutable because

00:08:48,140 --> 00:08:53,130
it's also borrowed as mutable

00:08:50,690 --> 00:08:54,120
now this might seem a bit restrictive

00:08:53,130 --> 00:08:55,590
because actually there's nothing

00:08:54,120 --> 00:08:58,080
particularly wrong with that careers

00:08:55,590 --> 00:08:59,760
this is a toy example but this

00:08:58,080 --> 00:09:01,110
illustrates the the kinds of

00:08:59,760 --> 00:09:04,230
restrictions that are baked into the

00:09:01,110 --> 00:09:08,130
language and maybe it's best spelled out

00:09:04,230 --> 00:09:10,440
in writing the rules are you can have as

00:09:08,130 --> 00:09:12,300
many immutable references to a value as

00:09:10,440 --> 00:09:15,690
you like you can have a thousand if

00:09:12,300 --> 00:09:18,660
they're all immutable or a single

00:09:15,690 --> 00:09:20,790
mutable reference those are your two

00:09:18,660 --> 00:09:24,720
choices as many immutable references or

00:09:20,790 --> 00:09:27,030
one mutable reference and also those are

00:09:24,720 --> 00:09:29,460
all the values that references refer to

00:09:27,030 --> 00:09:32,730
have to outlive their references so the

00:09:29,460 --> 00:09:36,360
lifetime of values is statically tracked

00:09:32,730 --> 00:09:37,650
throughout your program to put it

00:09:36,360 --> 00:09:39,840
another way because maybe that's not

00:09:37,650 --> 00:09:42,390
entirely clear we'll say it again but in

00:09:39,840 --> 00:09:44,190
a different way if you want to access a

00:09:42,390 --> 00:09:47,760
value by reference the language

00:09:44,190 --> 00:09:50,250
guarantees that the value exists and if

00:09:47,760 --> 00:09:55,710
you want to modify a value you must have

00:09:50,250 --> 00:09:57,270
the only reference to it now in a toy

00:09:55,710 --> 00:10:02,100
example that might not be particularly

00:09:57,270 --> 00:10:03,240
interesting or exciting but if you apply

00:10:02,100 --> 00:10:06,000
those rules throughout your entire

00:10:03,240 --> 00:10:07,950
program as you build up a more complex

00:10:06,000 --> 00:10:09,870
application then these rules start to

00:10:07,950 --> 00:10:14,220
become much more important as you start

00:10:09,870 --> 00:10:18,510
like doing things that maybe you had to

00:10:14,220 --> 00:10:22,110
put it have unintended consequences so

00:10:18,510 --> 00:10:25,620
here's an example of a classic pitfall

00:10:22,110 --> 00:10:27,780
in C++ we have dangling pointers so we

00:10:25,620 --> 00:10:31,620
have a pointed at X which we point to

00:10:27,780 --> 00:10:34,380
the first element in a vector the vector

00:10:31,620 --> 00:10:36,470
gets destroyed we still have a point of

00:10:34,380 --> 00:10:41,130
what happens if we dereference it well

00:10:36,470 --> 00:10:43,070
crash I guess certainly something you

00:10:41,130 --> 00:10:45,480
don't want to do if you have the

00:10:43,070 --> 00:10:48,150
equivalent code in rust so here we're

00:10:45,480 --> 00:10:51,810
assigning X as a reference to the first

00:10:48,150 --> 00:10:54,510
element of a vector V then we try and

00:10:51,810 --> 00:10:56,010
dereference it well we we can't even get

00:10:54,510 --> 00:10:59,910
to the dereferencing because the

00:10:56,010 --> 00:11:00,990
lifetime checker knows that V does not

00:10:59,910 --> 00:11:03,060
live long enough

00:11:00,990 --> 00:11:05,640
and we're trying to borrow a value that

00:11:03,060 --> 00:11:07,620
does not live long enough v gets dropped

00:11:05,640 --> 00:11:10,740
here while it's still borrowed and the

00:11:07,620 --> 00:11:12,209
borrowed value needs to live here and in

00:11:10,740 --> 00:11:13,500
terms of like understandable error

00:11:12,209 --> 00:11:15,170
messages I'm not sure what they could do

00:11:13,500 --> 00:11:18,089
better there I think it's it's really

00:11:15,170 --> 00:11:21,120
spelled out super clearly on it's quite

00:11:18,089 --> 00:11:26,279
nice another way you can shoot yourself

00:11:21,120 --> 00:11:28,140
in the foot in C++ is if you have if

00:11:26,279 --> 00:11:29,700
you're iterating over a container and

00:11:28,140 --> 00:11:31,290
then you happen to be modifying the

00:11:29,700 --> 00:11:34,140
container while you're iterating over it

00:11:31,290 --> 00:11:35,880
so here we're going over the the integer

00:11:34,140 --> 00:11:36,890
0 1 2 3 we're printing them out but

00:11:35,880 --> 00:11:38,910
while we're doing that we're also

00:11:36,890 --> 00:11:41,040
manipulating the contents of the vector

00:11:38,910 --> 00:11:44,390
then strange things can happen on my

00:11:41,040 --> 00:11:47,399
machine I get 0 0 2 3 I don't know why

00:11:44,390 --> 00:11:50,490
but that's what happens maybe you would

00:11:47,399 --> 00:11:53,100
get something else if we try and do the

00:11:50,490 --> 00:11:58,140
same thing in rust this is the

00:11:53,100 --> 00:11:59,850
equivalent code then we get an error

00:11:58,140 --> 00:12:03,510
cannonball V is mutable because it is

00:11:59,850 --> 00:12:05,310
also borrowed as immutable so like the

00:12:03,510 --> 00:12:06,839
the mutable borrow is happening here

00:12:05,310 --> 00:12:09,540
we're trying to push into the vector but

00:12:06,839 --> 00:12:11,430
we can't do that because we have to have

00:12:09,540 --> 00:12:14,279
we have to be the sole owner to be able

00:12:11,430 --> 00:12:16,920
to mutate V and we can't because there's

00:12:14,279 --> 00:12:21,540
already an immutable borrow active like

00:12:16,920 --> 00:12:24,149
from the iteration now we can go a lot

00:12:21,540 --> 00:12:26,070
further with examples where safety comes

00:12:24,149 --> 00:12:29,850
into play in particular with like

00:12:26,070 --> 00:12:32,610
parallel algorithms where these kinds of

00:12:29,850 --> 00:12:33,779
safety checks allow you to have or they

00:12:32,610 --> 00:12:35,399
what do they call it fearless

00:12:33,779 --> 00:12:38,660
concurrency or something like this is

00:12:35,399 --> 00:12:41,579
like you can write threads thread

00:12:38,660 --> 00:12:43,740
multi-threaded code in a guaranteed to

00:12:41,579 --> 00:12:46,290
be safe way without really having to

00:12:43,740 --> 00:12:50,040
think about it too hard which is quite

00:12:46,290 --> 00:12:51,660
refreshing and quite cool and hopefully

00:12:50,040 --> 00:12:53,390
I've made the point that there are some

00:12:51,660 --> 00:12:57,450
fundamental properties here which just

00:12:53,390 --> 00:13:01,320
simply don't apply in C++ so it's worthy

00:12:57,450 --> 00:13:03,480
of attention I think so if you want to

00:13:01,320 --> 00:13:05,880
play around with rust although there are

00:13:03,480 --> 00:13:07,250
online compilers that you can try out

00:13:05,880 --> 00:13:11,750
but if you want to install it locally

00:13:07,250 --> 00:13:14,690
you go to this website rust RS

00:13:11,750 --> 00:13:16,340
then if your honor if you're on Mac or

00:13:14,690 --> 00:13:17,930
Linux then you run a shell script and

00:13:16,340 --> 00:13:19,510
you you get a tool chain installed if

00:13:17,930 --> 00:13:22,040
you're on Windows you get an installer

00:13:19,510 --> 00:13:25,280
and then you get a tool chain on your

00:13:22,040 --> 00:13:26,810
system and on my system I happens we've

00:13:25,280 --> 00:13:29,840
installed three you get the stable by

00:13:26,810 --> 00:13:31,820
default and then rust up is a command

00:13:29,840 --> 00:13:33,680
that you can run to manage your tool

00:13:31,820 --> 00:13:35,480
chain so if you want to like see which

00:13:33,680 --> 00:13:36,860
ones you have rust up if you want to

00:13:35,480 --> 00:13:39,890
switch between them then you go to rust

00:13:36,860 --> 00:13:43,820
up and once you've installed the tool

00:13:39,890 --> 00:13:48,320
chain then you have access to the cargo

00:13:43,820 --> 00:13:52,040
command which is very useful now I'm

00:13:48,320 --> 00:13:58,880
gonna do a risky thing let's see if I

00:13:52,040 --> 00:14:07,760
can show you how this works so if you

00:13:58,880 --> 00:14:11,420
say cargo hello so we created a binary

00:14:07,760 --> 00:14:13,760
application called hello very good let's

00:14:11,420 --> 00:14:16,100
have a look at that sorry the screens a

00:14:13,760 --> 00:14:18,860
bit laggy so it's not the easiest thing

00:14:16,100 --> 00:14:22,339
to type on we have a directory then we

00:14:18,860 --> 00:14:25,190
can see what's in the directory we have

00:14:22,339 --> 00:14:30,260
a main source file which looks promising

00:14:25,190 --> 00:14:32,570
and a cargo tamil file the cargo tamil

00:14:30,260 --> 00:14:34,160
file is the configuration for the

00:14:32,570 --> 00:14:35,870
package that you're in so cargo has

00:14:34,160 --> 00:14:37,700
created a package which is this binary

00:14:35,870 --> 00:14:47,900
application and then you can configure

00:14:37,700 --> 00:14:50,080
it using the tamil file then you can run

00:14:47,900 --> 00:14:50,080
it

00:14:52,540 --> 00:14:57,250
so it compiles the application then runs

00:14:54,850 --> 00:14:59,230
it for you and prints out the result and

00:14:57,250 --> 00:15:00,430
it just happens to have a world example

00:14:59,230 --> 00:15:01,660
for you I was going to edit this and

00:15:00,430 --> 00:15:02,830
play with it but actually I think it's

00:15:01,660 --> 00:15:05,230
probably better if I just go back to the

00:15:02,830 --> 00:15:08,620
slides at this point but yeah that's the

00:15:05,230 --> 00:15:11,650
idea you can it's almost instant to

00:15:08,620 --> 00:15:15,240
setup a project and get building and you

00:15:11,650 --> 00:15:15,240
can edit that for hold and play around

00:15:17,250 --> 00:15:25,540
see how do I get back to the slides of

00:15:20,140 --> 00:15:28,830
things like this yeah now Pargo isn't

00:15:25,540 --> 00:15:31,210
just a build run out but it's also a

00:15:28,830 --> 00:15:32,800
package managers so you external

00:15:31,210 --> 00:15:35,170
dependencies pulled in through cargo

00:15:32,800 --> 00:15:37,750
it's the same my command you do cargo

00:15:35,170 --> 00:15:40,390
search and you find a library that you

00:15:37,750 --> 00:15:42,690
want to use in your application it's

00:15:40,390 --> 00:15:45,630
also a test runner a benchmark runner

00:15:42,690 --> 00:15:50,530
sort of a documentation generator and

00:15:45,630 --> 00:15:53,050
more it's really quite nice to have all

00:15:50,530 --> 00:15:56,200
of the tools that you probably find and

00:15:53,050 --> 00:15:58,600
bundle together in your C++ projects and

00:15:56,200 --> 00:16:00,130
you come up with your own stack of stuff

00:15:58,600 --> 00:16:02,680
that you put together so you make and

00:16:00,130 --> 00:16:06,300
oxygen and Google test or you know you

00:16:02,680 --> 00:16:09,970
find your own combination of these tools

00:16:06,300 --> 00:16:12,160
here it's all standard and people mostly

00:16:09,970 --> 00:16:15,520
use the same stuff and that's also quite

00:16:12,160 --> 00:16:20,130
nice because like everyone's aligned

00:16:15,520 --> 00:16:20,130
around the same tool set it's just great

00:16:21,990 --> 00:16:26,860
quickly mention that when you're looking

00:16:24,910 --> 00:16:27,940
into using rust you're going to see that

00:16:26,860 --> 00:16:30,310
there are different release channels

00:16:27,940 --> 00:16:31,750
it's fairly straightforward you have the

00:16:30,310 --> 00:16:33,640
stable version which is updated every

00:16:31,750 --> 00:16:35,770
six weeks beta is the thing that's about

00:16:33,640 --> 00:16:38,980
to become stable and nightly is where

00:16:35,770 --> 00:16:40,750
the new changes implemented and people

00:16:38,980 --> 00:16:42,220
play around with like the new stuff and

00:16:40,750 --> 00:16:44,140
this updates every night might be

00:16:42,220 --> 00:16:45,280
unstable and you probably don't want to

00:16:44,140 --> 00:16:47,770
use it unless you want to try the new

00:16:45,280 --> 00:16:50,830
thing but if you do want to try the new

00:16:47,770 --> 00:16:53,020
things then you can use rust up and just

00:16:50,830 --> 00:16:56,770
immediately switch between the different

00:16:53,020 --> 00:16:59,890
tools of tool chains the other thing

00:16:56,770 --> 00:17:02,070
that I need to mention I dunno I

00:16:59,890 --> 00:17:05,089
wouldn't but I kind of have to do that

00:17:02,070 --> 00:17:06,620
coming up is the 2018

00:17:05,089 --> 00:17:08,720
addition of rust which is going to be

00:17:06,620 --> 00:17:10,189
released in a couple of weeks and I

00:17:08,720 --> 00:17:12,380
figured it's close enough in time that I

00:17:10,189 --> 00:17:14,959
should just be using the 2018 editions

00:17:12,380 --> 00:17:16,459
so the examples you see you have to use

00:17:14,959 --> 00:17:18,350
the beta channel or the nightly channel

00:17:16,459 --> 00:17:23,299
but in a couple of weeks it's all going

00:17:18,350 --> 00:17:28,909
to be stable rust 1.0 is now known as

00:17:23,299 --> 00:17:30,620
the 2015 edition and yeah something

00:17:28,909 --> 00:17:32,570
that's nice about the additions is that

00:17:30,620 --> 00:17:34,370
it allows the language designers to

00:17:32,570 --> 00:17:36,080
incrementally introduce breaking changes

00:17:34,370 --> 00:17:38,840
so the language can evolve and then you

00:17:36,080 --> 00:17:41,059
opt in to the breaking changes and this

00:17:38,840 --> 00:17:42,799
allows the community and like the user

00:17:41,059 --> 00:17:43,960
base to come along with improvements to

00:17:42,799 --> 00:17:45,919
the language while still maintaining

00:17:43,960 --> 00:17:47,750
kobata compatibility with the old

00:17:45,919 --> 00:17:50,510
changes these are subtle tweaks but it

00:17:47,750 --> 00:17:53,419
allows for ergonomic enhancements which

00:17:50,510 --> 00:17:54,350
is quite a nice thing and in general

00:17:53,419 --> 00:17:57,200
though that new features will be

00:17:54,350 --> 00:18:00,260
available in auditions all right so I

00:17:57,200 --> 00:18:03,919
think that's enough orientation so let's

00:18:00,260 --> 00:18:05,779
see if we can build something I thought

00:18:03,919 --> 00:18:08,000
an audio application would be nice and

00:18:05,779 --> 00:18:11,450
over 20 minutes in so we've got 25

00:18:08,000 --> 00:18:14,090
minutes left so I'm gonna have to hustle

00:18:11,450 --> 00:18:16,070
a bit but okay so something that's

00:18:14,090 --> 00:18:17,870
interesting enough but small enough and

00:18:16,070 --> 00:18:20,390
I thought maybe a rust version of free

00:18:17,870 --> 00:18:23,029
verb which is this like well-known open

00:18:20,390 --> 00:18:27,110
source like reverb algorithm that's been

00:18:23,029 --> 00:18:28,640
around since 2000 and was made public

00:18:27,110 --> 00:18:30,289
domain there and it's everywhere you

00:18:28,640 --> 00:18:32,210
find it in tons of different software

00:18:30,289 --> 00:18:33,320
packages but I didn't see a rust version

00:18:32,210 --> 00:18:36,200
so I thought that might be a nice thing

00:18:33,320 --> 00:18:37,250
to work on and we can go through like

00:18:36,200 --> 00:18:38,779
how the whole thing is put together

00:18:37,250 --> 00:18:43,010
pretty quickly because it's extremely

00:18:38,779 --> 00:18:45,470
simple that is like the the structure of

00:18:43,010 --> 00:18:47,750
the algorithm you have a stack of comb

00:18:45,470 --> 00:18:50,360
filters that have internal feedback and

00:18:47,750 --> 00:18:51,620
filtering there's some together and then

00:18:50,360 --> 00:18:55,549
passed through a series of all pass

00:18:51,620 --> 00:18:56,990
filters so the this is for one channel

00:18:55,549 --> 00:18:58,850
then you duplicate the structure for the

00:18:56,990 --> 00:19:02,360
other channel and like do some mixing

00:18:58,850 --> 00:19:04,789
and then you have a stereo reverb the

00:19:02,360 --> 00:19:06,590
the image comes from a write-up that

00:19:04,789 --> 00:19:08,899
julie smith has on the common website

00:19:06,590 --> 00:19:10,520
where he talks about the structure

00:19:08,899 --> 00:19:12,230
analyzes the properties of it and that's

00:19:10,520 --> 00:19:13,760
worth reading and you can find the

00:19:12,230 --> 00:19:16,190
original source code which i've

00:19:13,760 --> 00:19:17,990
converted into rust following the link

00:19:16,190 --> 00:19:19,460
below they're easy to find on google if

00:19:17,990 --> 00:19:23,510
you don't have

00:19:19,460 --> 00:19:26,700
you know you'll find it easy enough so

00:19:23,510 --> 00:19:28,830
it's easy to build this we only need two

00:19:26,700 --> 00:19:34,500
things really current fields for in an

00:19:28,830 --> 00:19:39,200
allpass filter they all create a library

00:19:34,500 --> 00:19:42,000
first so instead we use cagonu Lib and

00:19:39,200 --> 00:19:43,590
instead of a main RS we now have a live

00:19:42,000 --> 00:19:45,840
RS so this package that we've just

00:19:43,590 --> 00:19:47,100
created is a library which we're then

00:19:45,840 --> 00:19:50,730
going to reuse in a couple of different

00:19:47,100 --> 00:19:54,470
applications so the comb filter in the

00:19:50,730 --> 00:19:57,240
or pass filter both use delay lines and

00:19:54,470 --> 00:19:59,400
we can create a delay line we've made a

00:19:57,240 --> 00:20:02,070
new file here to lay line two RS inside

00:19:59,400 --> 00:20:03,750
our free verb library and this in this

00:20:02,070 --> 00:20:07,740
implicitly creates a delay line module

00:20:03,750 --> 00:20:09,990
and so I like I'll be referring to the

00:20:07,740 --> 00:20:13,260
delay line module here inside the module

00:20:09,990 --> 00:20:14,669
we've created a delay line struct so

00:20:13,260 --> 00:20:17,340
this is the same thing essentially as a

00:20:14,669 --> 00:20:21,000
C struct pub means that it's public

00:20:17,340 --> 00:20:23,159
outside of this module and we have two

00:20:21,000 --> 00:20:26,090
elements in our strut a buffer and an

00:20:23,159 --> 00:20:28,669
index buffer is effect of 64-bit floats

00:20:26,090 --> 00:20:35,730
index you size you sizes essentially

00:20:28,669 --> 00:20:38,580
society in C++ terms to add methods to

00:20:35,730 --> 00:20:40,380
this type we don't do that in line in

00:20:38,580 --> 00:20:42,539
the type like you would in C++ but we

00:20:40,380 --> 00:20:46,020
separate the behavior out into

00:20:42,539 --> 00:20:48,150
implementations and the default

00:20:46,020 --> 00:20:50,010
implementation by convention will

00:20:48,150 --> 00:20:52,740
usually include a static method called

00:20:50,010 --> 00:20:53,970
new this isn't a constructor or it's not

00:20:52,740 --> 00:20:55,710
like the new keyword it doesn't allocate

00:20:53,970 --> 00:20:57,270
anything unless you happen to be not

00:20:55,710 --> 00:21:01,590
using a vector here that will allocate

00:20:57,270 --> 00:21:04,559
but new is just a convention we don't

00:21:01,590 --> 00:21:05,970
have constructors in rust instead it

00:21:04,559 --> 00:21:08,220
there's an expectation that whenever you

00:21:05,970 --> 00:21:10,080
have a delay line value it has been

00:21:08,220 --> 00:21:11,669
fully initialized and however you

00:21:10,080 --> 00:21:15,059
achieve that is is up to you

00:21:11,669 --> 00:21:16,500
but the convention is new so we're

00:21:15,059 --> 00:21:21,480
initializing a buffer with a zero doubt

00:21:16,500 --> 00:21:23,570
like string of zeros and an index of

00:21:21,480 --> 00:21:27,420
zero

00:21:23,570 --> 00:21:31,350
then adding some methods here we you see

00:21:27,420 --> 00:21:33,900
a fast method essentially is a method in

00:21:31,350 --> 00:21:37,140
an implementation that has a reference

00:21:33,900 --> 00:21:41,970
to self as the first parameter this is

00:21:37,140 --> 00:21:44,070
like this pointer in C++ so we have a

00:21:41,970 --> 00:21:46,290
read method that returns the current

00:21:44,070 --> 00:21:47,730
currently index value in the buffer and

00:21:46,290 --> 00:21:49,740
we have a write an advanced method which

00:21:47,730 --> 00:21:52,170
takes a value it sticks it in the buffer

00:21:49,740 --> 00:21:53,940
and then it increments the index or

00:21:52,170 --> 00:21:56,270
wraps around if we're at the end and so

00:21:53,940 --> 00:22:00,990
then we just have a continuously

00:21:56,270 --> 00:22:04,530
circling delay line we can show that

00:22:00,990 --> 00:22:07,440
with a test so here we've added a unit

00:22:04,530 --> 00:22:10,470
test that's in the same module in a

00:22:07,440 --> 00:22:14,120
child module called tests and the

00:22:10,470 --> 00:22:16,710
conflict test command here is a compiler

00:22:14,120 --> 00:22:17,790
declaration that says you only need to

00:22:16,710 --> 00:22:20,130
worry about building this if we're

00:22:17,790 --> 00:22:22,200
building tests and then we have a length

00:22:20,130 --> 00:22:26,940
10 function which we tagged with the

00:22:22,200 --> 00:22:31,380
test declaration and this is now

00:22:26,940 --> 00:22:33,420
registered as a unit test so we create a

00:22:31,380 --> 00:22:35,580
delay line with ten elements shove a

00:22:33,420 --> 00:22:36,870
bunch of numbers in and expect to be

00:22:35,580 --> 00:22:42,170
able to read them back out on the next

00:22:36,870 --> 00:22:45,780
time around then if we run cargo tests

00:22:42,170 --> 00:22:49,290
it will find this test and then run it

00:22:45,780 --> 00:22:50,940
and tell us that everything's ok so

00:22:49,290 --> 00:22:52,710
something I really like about this is

00:22:50,940 --> 00:22:55,230
writing the tests with the code I think

00:22:52,710 --> 00:22:57,060
this is like quite a nice way of working

00:22:55,230 --> 00:22:59,640
that they're in the same module in

00:22:57,060 --> 00:23:03,270
context of the code that they're testing

00:22:59,640 --> 00:23:05,100
and you know having a having like a test

00:23:03,270 --> 00:23:07,170
framework a test runner out of the box

00:23:05,100 --> 00:23:12,420
is also really nice there's there's no

00:23:07,170 --> 00:23:14,400
setup cost here the all pass filter well

00:23:12,420 --> 00:23:16,440
we're going to create a new module all

00:23:14,400 --> 00:23:19,200
pass and use the delay line that we've

00:23:16,440 --> 00:23:20,910
just created stick it in a struct that's

00:23:19,200 --> 00:23:23,460
all the old past needs the delay line

00:23:20,910 --> 00:23:25,590
then we initialize it and the tick

00:23:23,460 --> 00:23:30,270
function is like reading value out

00:23:25,590 --> 00:23:31,890
mixing it with the input applying some

00:23:30,270 --> 00:23:35,599
gain and then putting it back in the

00:23:31,890 --> 00:23:37,669
delay line and it's all passed ish

00:23:35,599 --> 00:23:39,979
is how it would be described it's not

00:23:37,669 --> 00:23:44,169
exactly in all past but it's it's what

00:23:39,979 --> 00:23:48,529
the free vote algorithm calls an allpass

00:23:44,169 --> 00:23:49,999
the comb filter is slightly more

00:23:48,529 --> 00:23:52,609
sophisticated again it's a delay line

00:23:49,999 --> 00:23:54,440
with feedback but here we have some

00:23:52,609 --> 00:23:57,289
filter state there's a one-pot filter

00:23:54,440 --> 00:23:58,849
embedded in this and like here's the

00:23:57,289 --> 00:24:01,759
tick function we're again reading a

00:23:58,849 --> 00:24:03,559
value out from the delay line applying

00:24:01,759 --> 00:24:05,450
some filtering and then putting it back

00:24:03,559 --> 00:24:07,729
into the delay line and returning the

00:24:05,450 --> 00:24:10,159
output so I take here is just a method

00:24:07,729 --> 00:24:12,739
beam on using for these DSP blocks that

00:24:10,159 --> 00:24:14,479
taken in a sample of input and then give

00:24:12,739 --> 00:24:19,190
you a sample of output that's just a

00:24:14,479 --> 00:24:22,969
name that I've chosen putting it

00:24:19,190 --> 00:24:24,709
together we then have like a free verb

00:24:22,969 --> 00:24:27,589
module and a free verb struct in the

00:24:24,709 --> 00:24:29,839
module and here we see that we're using

00:24:27,589 --> 00:24:35,179
our all passes and combs that we just

00:24:29,839 --> 00:24:39,859
created and on we have eight pairs of

00:24:35,179 --> 00:24:41,839
combs and four pairs of all passes the

00:24:39,859 --> 00:24:43,820
this pass syntax this is actually tuple

00:24:41,839 --> 00:24:47,269
syntax they can be like n elements long

00:24:43,820 --> 00:24:49,519
but this is good enough for this purpose

00:24:47,269 --> 00:24:51,529
I think that you just have a pair left

00:24:49,519 --> 00:24:53,450
and right and then a bunch of other

00:24:51,529 --> 00:24:58,779
state like for the different parameters

00:24:53,450 --> 00:25:01,579
that are used in the new construction we

00:24:58,779 --> 00:25:05,599
sorry the new method we're initializing

00:25:01,579 --> 00:25:07,190
our combs using these like delay lengths

00:25:05,599 --> 00:25:08,899
that have been carefully tuned by the

00:25:07,190 --> 00:25:12,769
original author and you'll find in the

00:25:08,899 --> 00:25:15,079
source code and same here with the all

00:25:12,769 --> 00:25:17,919
passes then a bunch of stuff and you

00:25:15,079 --> 00:25:21,440
have a free verb that is ready to go so

00:25:17,919 --> 00:25:25,399
that's fully initialized and like yeah

00:25:21,440 --> 00:25:26,809
it sounds like a reverb the tunings look

00:25:25,399 --> 00:25:28,579
like this so you can have constants and

00:25:26,809 --> 00:25:31,129
the syntax there is just put them all in

00:25:28,579 --> 00:25:32,179
caps and find it's a convention we're

00:25:31,129 --> 00:25:35,179
adjusting the length because the

00:25:32,179 --> 00:25:37,820
original only sports 44.1 I think that

00:25:35,179 --> 00:25:42,529
does the job I'm really tested it that

00:25:37,820 --> 00:25:43,940
much but so something to show here okay

00:25:42,529 --> 00:25:45,919
it's a bunch of setters for the free

00:25:43,940 --> 00:25:47,890
verb and the only different thing here

00:25:45,919 --> 00:25:51,250
that you haven't seen so far is that

00:25:47,890 --> 00:25:53,700
a private method is just a function in

00:25:51,250 --> 00:25:55,990
an implementation that isn't public so

00:25:53,700 --> 00:25:58,930
these two setters are publicly available

00:25:55,990 --> 00:26:02,230
they defer to a helper which is private

00:25:58,930 --> 00:26:05,080
I just figured I'd show that then the

00:26:02,230 --> 00:26:06,940
the tick function we take the input the

00:26:05,080 --> 00:26:09,760
stereo and put summit to mano

00:26:06,940 --> 00:26:12,700
pass it into each of the stereo pairs of

00:26:09,760 --> 00:26:14,770
cones sum all of that together run

00:26:12,700 --> 00:26:17,590
through the old passes and then the

00:26:14,770 --> 00:26:20,620
output is a bit of stereo mixing plus

00:26:17,590 --> 00:26:23,410
the dry signal oh the thing that's new

00:26:20,620 --> 00:26:25,390
here is tuple accesses dot zero for left

00:26:23,410 --> 00:26:26,980
dot one for right if you sort of mean

00:26:25,390 --> 00:26:32,170
that's the the zeroth element at the

00:26:26,980 --> 00:26:34,270
table the first element of the tuple yes

00:26:32,170 --> 00:26:36,550
so that that's it that at this point we

00:26:34,270 --> 00:26:42,160
have the complete algorithm defined for

00:26:36,550 --> 00:26:45,370
the free verb so then does it work how

00:26:42,160 --> 00:26:51,790
does it sound well let's try it see if

00:26:45,370 --> 00:26:54,300
we can get this to work think you can

00:26:51,790 --> 00:26:54,300
say is

00:27:17,780 --> 00:27:22,970
but you can hear that that's actually

00:27:23,270 --> 00:27:26,600
playing in the background

00:27:27,630 --> 00:27:31,110
my first playing is passing through

00:27:29,130 --> 00:27:34,680
sound fire into the application that has

00:27:31,110 --> 00:27:36,669
two inputs to our first lecture than me

00:27:34,680 --> 00:27:49,980
yeah

00:27:36,669 --> 00:27:49,980
that is processing audio it gets better

00:27:50,820 --> 00:27:55,600
okay so there we had an application that

00:27:53,499 --> 00:27:57,129
was like a full audio application with

00:27:55,600 --> 00:28:01,809
the GUI how did we put that together

00:27:57,129 --> 00:28:04,989
well I'm using existing libraries that

00:28:01,809 --> 00:28:06,820
happen to have rust wrappers so I was

00:28:04,989 --> 00:28:08,859
able to pull them in as like

00:28:06,820 --> 00:28:09,999
dependencies into the application

00:28:08,859 --> 00:28:12,879
project very easily which I'll show you

00:28:09,999 --> 00:28:14,409
now our main function

00:28:12,879 --> 00:28:16,090
I'm calling the run main you don't have

00:28:14,409 --> 00:28:17,440
to worry about this template e syntax

00:28:16,090 --> 00:28:20,230
for now I'm going to explain this but

00:28:17,440 --> 00:28:22,899
for now the thing that's interesting is

00:28:20,230 --> 00:28:27,129
that we're creating a command queue

00:28:22,899 --> 00:28:28,450
using the external crate crossbeam so

00:28:27,129 --> 00:28:30,639
this is a dependency that I'm pulling in

00:28:28,450 --> 00:28:34,149
this is a rust library and then I'm

00:28:30,639 --> 00:28:37,720
using port audio for audio in and out it

00:28:34,149 --> 00:28:40,720
does the job and here we're we're

00:28:37,720 --> 00:28:43,419
spawning a thread where the audio will

00:28:40,720 --> 00:28:45,129
run and then that thread receives the

00:28:43,419 --> 00:28:48,820
command receiver and then on the sender

00:28:45,129 --> 00:28:50,230
side we have UI widgets I'm not going to

00:28:48,820 --> 00:28:54,309
show you everything but like you get the

00:28:50,230 --> 00:28:59,259
idea I'm using a gtk window here and gtk

00:28:54,309 --> 00:29:02,139
window widgets and this this just works

00:28:59,259 --> 00:29:03,549
is it it it feels straightforward to use

00:29:02,139 --> 00:29:06,309
that you don't have to worry about this

00:29:03,549 --> 00:29:07,600
too much the the way that you declare

00:29:06,309 --> 00:29:10,239
these dependencies is in your cargo

00:29:07,600 --> 00:29:13,450
tamil in the dependency section you say

00:29:10,239 --> 00:29:16,090
okay I want version 0.5 of gtk point 7

00:29:13,450 --> 00:29:17,470
of poor audio the thing that's

00:29:16,090 --> 00:29:20,139
interesting here is that I've included

00:29:17,470 --> 00:29:22,989
two internal dependencies for things I

00:29:20,139 --> 00:29:24,190
haven't shown you yet one called audio

00:29:22,989 --> 00:29:26,710
module and the other called free verb

00:29:24,190 --> 00:29:28,179
module and I really didn't need to do

00:29:26,710 --> 00:29:31,480
this but I figured it would be good for

00:29:28,179 --> 00:29:34,960
the talk to show a bit of a more

00:29:31,480 --> 00:29:37,269
sophisticated application than just

00:29:34,960 --> 00:29:38,769
basic setters so I started making a

00:29:37,269 --> 00:29:41,159
module framework and I'm not sure it was

00:29:38,769 --> 00:29:45,070
the best idea but it gets to it gets to

00:29:41,159 --> 00:29:45,590
a nice feature of rust which is trait

00:29:45,070 --> 00:29:46,860
and

00:29:45,590 --> 00:29:51,210
[Music]

00:29:46,860 --> 00:29:54,240
traits are very similar to virtual

00:29:51,210 --> 00:29:57,030
interfaces in C++ they're also very

00:29:54,240 --> 00:30:04,640
similar to concepts which are coming in

00:29:57,030 --> 00:30:07,200
C++ 20 I think and they allow for like

00:30:04,640 --> 00:30:08,370
different different different behaviors

00:30:07,200 --> 00:30:09,780
depending on what you do with them but

00:30:08,370 --> 00:30:11,520
really if you think of it as declaring

00:30:09,780 --> 00:30:13,980
an interface and then how you use that

00:30:11,520 --> 00:30:16,470
interface is something that will become

00:30:13,980 --> 00:30:21,530
a bit clearer so here we're saying an

00:30:16,470 --> 00:30:23,910
audio module is a parameter provider so

00:30:21,530 --> 00:30:25,710
that's another trait there is a trait

00:30:23,910 --> 00:30:28,260
called parameter provider and the trait

00:30:25,710 --> 00:30:32,070
audio module also includes that trait as

00:30:28,260 --> 00:30:34,260
part of its interface the audio module

00:30:32,070 --> 00:30:37,350
declares a processor type and the

00:30:34,260 --> 00:30:39,150
processor type meets the it satisfies

00:30:37,350 --> 00:30:41,580
the interface of audio processor and

00:30:39,150 --> 00:30:43,920
then it also has a method called create

00:30:41,580 --> 00:30:52,230
processor which when given a sample rate

00:30:43,920 --> 00:30:53,700
gives you a a processor by a value the

00:30:52,230 --> 00:30:56,790
audio processor trait

00:30:53,700 --> 00:31:00,390
I've got define it as like being

00:30:56,790 --> 00:31:02,880
something that processes stereo audio so

00:31:00,390 --> 00:31:04,800
we have an input buffer and an output

00:31:02,880 --> 00:31:07,920
buffer this syntax here you haven't seen

00:31:04,800 --> 00:31:09,809
yet this is like an array but it's sized

00:31:07,920 --> 00:31:13,110
at runtime so this is like I said spam

00:31:09,809 --> 00:31:16,380
that's coming in C++ so it's just a

00:31:13,110 --> 00:31:18,179
reference plus a length and that's the

00:31:16,380 --> 00:31:20,010
standard syntax for it the audio

00:31:18,179 --> 00:31:23,190
processor we expect to also be able to

00:31:20,010 --> 00:31:25,770
handle commands and so you can compose

00:31:23,190 --> 00:31:28,860
these traits together and create a full

00:31:25,770 --> 00:31:30,660
declaration of an interface which on its

00:31:28,860 --> 00:31:37,559
own doesn't do anything but can then be

00:31:30,660 --> 00:31:41,309
used for cases like this so we I created

00:31:37,559 --> 00:31:42,990
a new module free verb module which then

00:31:41,309 --> 00:31:46,410
has a free verb processor which

00:31:42,990 --> 00:31:49,350
internally has the free verb struct that

00:31:46,410 --> 00:31:51,809
we made that does the ticking but we're

00:31:49,350 --> 00:31:54,030
kind of encapsulating that here and then

00:31:51,809 --> 00:31:56,190
we implement audio processor and the

00:31:54,030 --> 00:31:59,240
process stereo method for it

00:31:56,190 --> 00:32:01,620
and instead of taking sample by sample

00:31:59,240 --> 00:32:03,809
here we're dealing with a buffer so we

00:32:01,620 --> 00:32:07,110
have to iterate over the buffer and what

00:32:03,809 --> 00:32:08,820
this is doing is taking the indices or

00:32:07,110 --> 00:32:12,809
the even indices up to the input length

00:32:08,820 --> 00:32:15,539
and then using those even indices to

00:32:12,809 --> 00:32:16,789
give access to the interleaved stereo

00:32:15,539 --> 00:32:19,919
data in the buffer

00:32:16,789 --> 00:32:21,149
maybe explain that clearer but I think

00:32:19,919 --> 00:32:22,379
you get the idea it's interleaved audio

00:32:21,149 --> 00:32:24,149
so you need to take left right left

00:32:22,379 --> 00:32:27,929
right left right and we do that by

00:32:24,149 --> 00:32:30,870
stepping by 2 over the indices then we

00:32:27,929 --> 00:32:34,559
take the input get some output and

00:32:30,870 --> 00:32:36,690
assign it to the output how am i doing

00:32:34,559 --> 00:32:39,870
for time not great okay we start

00:32:36,690 --> 00:32:41,580
skipping over I wanted to show here also

00:32:39,870 --> 00:32:46,080
so the parameter trait here that I

00:32:41,580 --> 00:32:49,919
didn't show you yet but this is now

00:32:46,080 --> 00:32:53,070
being used in this context for dynamic

00:32:49,919 --> 00:32:55,379
polymorphism so the parameter provided

00:32:53,070 --> 00:32:57,120
given an ID will give you a parameter

00:32:55,379 --> 00:32:59,360
which we don't know about at compile

00:32:57,120 --> 00:33:01,830
time but we do know about at runtime and

00:32:59,360 --> 00:33:03,600
it becomes a what's called a trait

00:33:01,830 --> 00:33:06,179
object in C++ I guess this would be a

00:33:03,600 --> 00:33:09,840
virtual object so it has a V table and

00:33:06,179 --> 00:33:15,840
this object is stored in a box which in

00:33:09,840 --> 00:33:18,570
C++ tones is a unique pointer so I'm

00:33:15,840 --> 00:33:20,340
gonna I'm gonna skip ahead a bit so we

00:33:18,570 --> 00:33:21,389
have a free verb module that declare

00:33:20,340 --> 00:33:24,090
some parameters and there's a whole

00:33:21,389 --> 00:33:27,360
thing about that but I get I think we

00:33:24,090 --> 00:33:29,700
get the idea come on handler as a trait

00:33:27,360 --> 00:33:31,289
we have to handle commands and then so

00:33:29,700 --> 00:33:33,629
if the processor receives a command and

00:33:31,289 --> 00:33:37,379
then calls the relevant setter on the

00:33:33,629 --> 00:33:39,419
processor so now coming back to the main

00:33:37,379 --> 00:33:41,309
function I think we we see what's going

00:33:39,419 --> 00:33:43,919
on here like I wanted to separate out

00:33:41,309 --> 00:33:46,080
the the free verb aspects of the

00:33:43,919 --> 00:33:49,259
application from the the thing that

00:33:46,080 --> 00:33:51,480
actually runs the runs the system so

00:33:49,259 --> 00:33:54,870
like we just passed in a module which

00:33:51,480 --> 00:33:56,279
implements the trait audio module so the

00:33:54,870 --> 00:33:57,809
the whole application doesn't know

00:33:56,279 --> 00:34:00,299
anything about free verb it just knows

00:33:57,809 --> 00:34:04,580
about audio modules so then maybe it

00:34:00,299 --> 00:34:04,580
could be reused for other effects

00:34:06,249 --> 00:34:11,510
so treats are generic type constraints

00:34:09,169 --> 00:34:14,419
similar to C++ twenties concepts also

00:34:11,510 --> 00:34:17,030
offer static polymorphism functionality

00:34:14,419 --> 00:34:21,639
also dynamic polymorphism similar to C++

00:34:17,030 --> 00:34:23,690
virtual objects and having like the same

00:34:21,639 --> 00:34:26,240
language feature providing all of this

00:34:23,690 --> 00:34:29,210
functionality is really quite remarkable

00:34:26,240 --> 00:34:33,109
I think and like it's one of my favorite

00:34:29,210 --> 00:34:37,220
things about rust so I'm gonna have to

00:34:33,109 --> 00:34:38,770
prattle on right so Fi yeah linkie again

00:34:37,220 --> 00:34:40,940
see libraries and rust is well supported

00:34:38,770 --> 00:34:43,369
crates are available for many major c

00:34:40,940 --> 00:34:46,399
libraries and also c++ libraries that

00:34:43,369 --> 00:34:47,929
happen to have c bindings if you find

00:34:46,399 --> 00:34:49,909
that a crate doesn't have a rust wrapper

00:34:47,929 --> 00:34:51,770
than making a rust repair would be a

00:34:49,909 --> 00:34:53,419
nice contribution to the ecosystem so if

00:34:51,770 --> 00:34:55,450
you felt so inclined that would be a

00:34:53,419 --> 00:34:58,609
really good thing to be spending time on

00:34:55,450 --> 00:35:00,920
how is it possible to call c code given

00:34:58,609 --> 00:35:01,990
rust safety restrictions this is an

00:35:00,920 --> 00:35:04,460
important question

00:35:01,990 --> 00:35:06,500
Rusty's very strict C code is not if

00:35:04,460 --> 00:35:10,640
we're calling in C code then how does

00:35:06,500 --> 00:35:13,099
rust allow this so to quickly highlight

00:35:10,640 --> 00:35:15,980
how this is possible we have the unsafe

00:35:13,099 --> 00:35:18,319
keyword which tells rust I know what I'm

00:35:15,980 --> 00:35:20,420
doing just don't worry about what I'm

00:35:18,319 --> 00:35:22,549
about to do here with memory or like

00:35:20,420 --> 00:35:24,140
lifetimes or whatever like you can just

00:35:22,549 --> 00:35:26,540
bypass the whole of the all of the

00:35:24,140 --> 00:35:28,609
safety checks for most of them if you

00:35:26,540 --> 00:35:30,200
need to and when you need to might be

00:35:28,609 --> 00:35:34,190
when you are working with a C library

00:35:30,200 --> 00:35:35,750
that communicates in raw pointers and if

00:35:34,190 --> 00:35:38,240
you're using unsafe you probably want to

00:35:35,750 --> 00:35:41,059
extract it away I think it's very rare

00:35:38,240 --> 00:35:42,619
that you'll actually see much unsafe

00:35:41,059 --> 00:35:43,849
code in the in the client code that

00:35:42,619 --> 00:35:46,210
you're writing if you're writing unsafe

00:35:43,849 --> 00:35:49,760
code probably you're building a library

00:35:46,210 --> 00:35:55,280
so we've seen using C and rust how could

00:35:49,760 --> 00:35:59,420
we use rust in C++ well if the way that

00:35:55,280 --> 00:36:00,890
you do this is that you build a static

00:35:59,420 --> 00:36:07,400
library or a dynamic library if you

00:36:00,890 --> 00:36:10,640
prefer and you apply attributes to the

00:36:07,400 --> 00:36:15,380
functions in your library to ensure that

00:36:10,640 --> 00:36:17,119
they're exposed in a C compatible way so

00:36:15,380 --> 00:36:17,700
here we're creating a new library free

00:36:17,119 --> 00:36:20,790
lips

00:36:17,700 --> 00:36:23,480
free verbs feelin and it depends on our

00:36:20,790 --> 00:36:26,520
free library that we created earlier and

00:36:23,480 --> 00:36:31,470
we're telling cargo please build it as a

00:36:26,520 --> 00:36:34,260
static library in the Russ code for this

00:36:31,470 --> 00:36:36,510
library we have a create and destroy

00:36:34,260 --> 00:36:39,180
method where we're able to create a raw

00:36:36,510 --> 00:36:42,690
pointer to a free verb struct which we

00:36:39,180 --> 00:36:45,869
essentially forward declare for the

00:36:42,690 --> 00:36:47,910
purposes of C so we tell see there is

00:36:45,869 --> 00:36:50,069
this struct you can allocate it but

00:36:47,910 --> 00:36:51,720
we'll take care of the details and here

00:36:50,069 --> 00:36:53,280
we're using box to allocate on the heap

00:36:51,720 --> 00:36:55,500
and then it gets returned as overall

00:36:53,280 --> 00:36:58,980
pointer and on the destroy side then we

00:36:55,500 --> 00:37:04,200
receive a pointer that we just have to

00:36:58,980 --> 00:37:06,059
hope is and we tag it as unsafe it's

00:37:04,200 --> 00:37:08,069
like the the thing that comes in here

00:37:06,059 --> 00:37:10,260
could be anything but we fingers crossed

00:37:08,069 --> 00:37:13,190
and it will be okay also no mangle and

00:37:10,260 --> 00:37:16,200
that that's pretty much all you need to

00:37:13,190 --> 00:37:18,030
make sure that extern so it's no mangle

00:37:16,200 --> 00:37:21,000
annex turn make sure that that function

00:37:18,030 --> 00:37:22,260
is available outside so once you built

00:37:21,000 --> 00:37:24,329
that you have a library that can be

00:37:22,260 --> 00:37:26,280
linked into your C++ application but you

00:37:24,329 --> 00:37:27,510
also need a header or you know the

00:37:26,280 --> 00:37:29,970
declarations of the things that you're

00:37:27,510 --> 00:37:32,099
trying to access you can write that by

00:37:29,970 --> 00:37:34,260
hand if you want there's also a tool C

00:37:32,099 --> 00:37:36,869
bind gen which will generate a head of

00:37:34,260 --> 00:37:41,089
for you from the Russ library and used

00:37:36,869 --> 00:37:42,710
that here and you get a like a regular

00:37:41,089 --> 00:37:48,390
C++ header

00:37:42,710 --> 00:37:50,130
speaking in types that C++ understands I

00:37:48,390 --> 00:37:52,920
can skip over this we have a process

00:37:50,130 --> 00:38:00,440
function inputs and outputs and ticking

00:37:52,920 --> 00:38:00,440
and we get this kind of C interface

00:38:01,960 --> 00:38:06,560
using the free road a rust library in a

00:38:04,670 --> 00:38:09,200
juice project right so now we have a C

00:38:06,560 --> 00:38:11,359
library we can use it in C++ and because

00:38:09,200 --> 00:38:12,500
this is an audio conference I guess

00:38:11,359 --> 00:38:15,680
there's a lot of juice developers here

00:38:12,500 --> 00:38:19,760
so this is how you do it in producer you

00:38:15,680 --> 00:38:22,970
tell you you set the the right flags and

00:38:19,760 --> 00:38:26,540
the flags you need are where where the

00:38:22,970 --> 00:38:29,960
header is so it's in this C Lib folder

00:38:26,540 --> 00:38:31,190
local to the juice project you tell you

00:38:29,960 --> 00:38:35,300
where the library is you tell it which

00:38:31,190 --> 00:38:38,599
library you want to link against to make

00:38:35,300 --> 00:38:41,359
this nice you can create a pre build

00:38:38,599 --> 00:38:42,619
script that takes care of compiling the

00:38:41,359 --> 00:38:46,869
Russ library and generating the matter

00:38:42,619 --> 00:38:46,869
for you and this works pretty nicely

00:38:47,470 --> 00:38:56,540
then in our juice code right quickly we

00:38:53,660 --> 00:39:00,650
have free vert HPP I didn't do the whole

00:38:56,540 --> 00:39:03,710
module thing in the juicer example but

00:39:00,650 --> 00:39:05,990
what we have is a unique pointer to a

00:39:03,710 --> 00:39:08,349
free verb and when it gets destroyed we

00:39:05,990 --> 00:39:12,410
need to call the free verb destroy a

00:39:08,349 --> 00:39:14,599
function when we are preparing to play

00:39:12,410 --> 00:39:17,210
we create a free verb using our create

00:39:14,599 --> 00:39:21,230
function and we we stick it into our

00:39:17,210 --> 00:39:23,330
unique pointer to hold on to it then

00:39:21,230 --> 00:39:25,580
when we're processing an audio book well

00:39:23,330 --> 00:39:28,849
we have a command Q and we we set our

00:39:25,580 --> 00:39:32,300
parameters as necessary and then we call

00:39:28,849 --> 00:39:38,770
free verb process with our instance of

00:39:32,300 --> 00:39:43,780
the fever now let's see does that work

00:39:38,770 --> 00:39:43,780
well here is the juice project

00:39:44,600 --> 00:39:53,420
so this is with the same do speed

00:39:48,170 --> 00:39:53,420
implements with us running

00:39:56,650 --> 00:40:12,010
very basic but it works better so I

00:40:15,520 --> 00:40:20,410
don't get to the slides it's like this

00:40:20,500 --> 00:40:24,740
right so now you know you you're in a

00:40:23,210 --> 00:40:26,540
juice project so you could build a VST

00:40:24,740 --> 00:40:29,020
with this or you know whatever you want

00:40:26,540 --> 00:40:33,740
to do with you your juice project

00:40:29,020 --> 00:40:37,910
another target that's interesting is web

00:40:33,740 --> 00:40:39,650
assembly and with rust the the tool

00:40:37,910 --> 00:40:42,500
chain for generating web assembly is

00:40:39,650 --> 00:40:44,960
pretty nice and we're going to follow

00:40:42,500 --> 00:40:46,370
the same approach here creating a

00:40:44,960 --> 00:40:51,080
another wrapper library in this case

00:40:46,370 --> 00:40:52,460
I'll call it wiesen and in in this case

00:40:51,080 --> 00:40:54,020
why isn't vine gen is the tool that

00:40:52,460 --> 00:40:59,540
we're using rather than step engine and

00:40:54,020 --> 00:41:02,900
here we tag our objects and methods that

00:40:59,540 --> 00:41:06,320
we want to like expose using this white

00:41:02,900 --> 00:41:07,520
and Biogen attribute so this is a

00:41:06,320 --> 00:41:10,400
slightly different approach to the C

00:41:07,520 --> 00:41:15,320
approach but I it's pretty

00:41:10,400 --> 00:41:16,460
straightforward really the process

00:41:15,320 --> 00:41:17,630
function is very similar to what we've

00:41:16,460 --> 00:41:19,070
seen before but now we're speaking in

00:41:17,630 --> 00:41:20,660
native rust Heights because why's it bun

00:41:19,070 --> 00:41:26,450
Jen knows a bit more about rust and it

00:41:20,660 --> 00:41:28,070
can like expose the correct types for

00:41:26,450 --> 00:41:30,380
the JavaScript that ends up being called

00:41:28,070 --> 00:41:33,170
the web suddenly the ends up being

00:41:30,380 --> 00:41:36,500
called so it's much the same as you've

00:41:33,170 --> 00:41:38,540
seen before then the way that this is

00:41:36,500 --> 00:41:41,420
compiled well we use cargo build but we

00:41:38,540 --> 00:41:43,460
tell it to cut the target weird assembly

00:41:41,420 --> 00:41:46,520
instead of whatever your platform is

00:41:43,460 --> 00:41:49,550
compiling for and then you run wise and

00:41:46,520 --> 00:41:52,310
bind gem you tell it where your web

00:41:49,550 --> 00:41:53,990
somebody is and then it gives you a set

00:41:52,310 --> 00:41:56,300
of files it gives you some JavaScript

00:41:53,990 --> 00:41:57,860
bindings which I wouldn't show you it

00:41:56,300 --> 00:42:00,560
gives you web assembly in the correct

00:41:57,860 --> 00:42:02,420
place and it also gives you some debug

00:42:00,560 --> 00:42:03,710
symbols for typescript which I'm not

00:42:02,420 --> 00:42:05,510
front-end developer so I wouldn't know

00:42:03,710 --> 00:42:07,160
what to do with but I can put them on a

00:42:05,510 --> 00:42:07,610
slide for you because they're much more

00:42:07,160 --> 00:42:09,020
readable

00:42:07,610 --> 00:42:12,050
the other files and that shows you the

00:42:09,020 --> 00:42:16,610
the shape of what wasn't blind Jen is

00:42:12,050 --> 00:42:17,960
outputting then I don't have time to

00:42:16,610 --> 00:42:20,450
show you how to hook this up but it

00:42:17,960 --> 00:42:22,820
we're just using Web Audio we instance

00:42:20,450 --> 00:42:23,540
we import the the web sembly blah blah

00:42:22,820 --> 00:42:26,300
blah

00:42:23,540 --> 00:42:28,640
and then we create a script processor

00:42:26,300 --> 00:42:32,060
this isn't the the the modern way to do

00:42:28,640 --> 00:42:36,140
custom DSP for the web but it's slight

00:42:32,060 --> 00:42:38,690
friendly so there we have the input and

00:42:36,140 --> 00:42:41,810
output and we're calling process on our

00:42:38,690 --> 00:42:43,670
free verb object connected to a

00:42:41,810 --> 00:42:47,500
microphone and then connected to the

00:42:43,670 --> 00:42:47,500
output hook up some sliders

00:42:53,349 --> 00:43:01,199
then yeah this looks familiar

00:42:58,020 --> 00:43:01,199
[Music]

00:43:04,529 --> 00:43:09,849
sorry again that's the same DSP that we

00:43:07,239 --> 00:43:13,359
wrote at the start of the talk and now

00:43:09,849 --> 00:43:15,220
we've used it in a GC project and we're

00:43:13,359 --> 00:43:29,319
using it in the web which i think is

00:43:15,220 --> 00:43:31,180
pretty decent okay to summarize exposing

00:43:29,319 --> 00:43:32,950
rust to C is easy by skype-ing and

00:43:31,180 --> 00:43:35,440
exposing rust code to JavaScript as easy

00:43:32,950 --> 00:43:36,849
Verizon bunging I'm making the claim

00:43:35,440 --> 00:43:38,769
easier I think is straightforward

00:43:36,849 --> 00:43:41,049
there's a few details to figure out but

00:43:38,769 --> 00:43:45,479
like it's there like the tool changes

00:43:41,049 --> 00:43:51,430
there and like it you can you can use it

00:43:45,479 --> 00:43:53,890
that's it's fine you've totally got it

00:43:51,430 --> 00:43:55,450
is anything missing right so this is the

00:43:53,890 --> 00:43:56,710
wrap up now and we've got five minutes

00:43:55,450 --> 00:43:58,119
left so I'm going to rattle through this

00:43:56,710 --> 00:44:03,069
and then maybe there's time for a couple

00:43:58,119 --> 00:44:05,609
of questions so 70 support is in its

00:44:03,069 --> 00:44:08,170
stable the intrinsics are available

00:44:05,609 --> 00:44:10,869
there are there is a crate now which is

00:44:08,170 --> 00:44:13,059
building a nice abstraction over the

00:44:10,869 --> 00:44:15,910
low-level operations there's also an

00:44:13,059 --> 00:44:18,910
effort to create a standard abstraction

00:44:15,910 --> 00:44:20,589
for the low-level intrinsics kant's

00:44:18,910 --> 00:44:23,410
generics is still working progress but

00:44:20,589 --> 00:44:25,359
it's coming soon what this means is in

00:44:23,410 --> 00:44:29,680
C++ you could say static vector of T's

00:44:25,359 --> 00:44:31,719
and there are n n as a maximum number

00:44:29,680 --> 00:44:33,160
for your static vector and you can't

00:44:31,719 --> 00:44:36,460
express that in rust and run you have to

00:44:33,160 --> 00:44:38,049
use macros or workarounds but I would

00:44:36,460 --> 00:44:40,839
really like this feature and it's coming

00:44:38,049 --> 00:44:45,309
soon inline assembly still work in

00:44:40,839 --> 00:44:48,489
progress it's unstable but gated and

00:44:45,309 --> 00:44:50,920
maybe will change fast math intrinsic

00:44:48,489 --> 00:44:52,809
tonight Leone they're not stable and I

00:44:50,920 --> 00:44:54,279
think these are quite important but

00:44:52,809 --> 00:44:55,390
hopefully they'll come soon and maybe

00:44:54,279 --> 00:44:57,430
some people in the audience here would

00:44:55,390 --> 00:44:59,680
be able to help the the Russel community

00:44:57,430 --> 00:45:01,719
figure out how to do this well placement

00:44:59,680 --> 00:45:04,349
you wasn't Knightly is not anymore

00:45:01,719 --> 00:45:06,579
they have things to figure out there

00:45:04,349 --> 00:45:07,240
what's not great will compile times are

00:45:06,579 --> 00:45:11,099
getting there

00:45:07,240 --> 00:45:13,960
like they they were not great they

00:45:11,099 --> 00:45:15,339
decent enough now I think like either I

00:45:13,960 --> 00:45:17,680
find it usable unless I'm using a

00:45:15,339 --> 00:45:20,410
particular crate that is slow to compile

00:45:17,680 --> 00:45:22,060
but then maybe I don't use that crate

00:45:20,410 --> 00:45:23,800
I'd say if you if you're building

00:45:22,060 --> 00:45:25,750
complex C++ applications you won't

00:45:23,800 --> 00:45:26,980
notice things are dramatically slower

00:45:25,750 --> 00:45:28,119
you'll be okay you'll be okay with the

00:45:26,980 --> 00:45:29,859
compile times and rust if you're writing

00:45:28,119 --> 00:45:33,010
more like low-level C style code then

00:45:29,859 --> 00:45:34,660
maybe you'll find it unbearable but yeah

00:45:33,010 --> 00:45:35,530
you should you should try it out and see

00:45:34,660 --> 00:45:38,109
what you think

00:45:35,530 --> 00:45:39,940
incomplete iOS support there is an issue

00:45:38,109 --> 00:45:41,790
with component to iOS bit code which

00:45:39,940 --> 00:45:43,690
maybe you need for the App Store

00:45:41,790 --> 00:45:47,260
apparently there are ways of making it

00:45:43,690 --> 00:45:49,420
work I haven't tried it there's a long

00:45:47,260 --> 00:45:51,040
issue that you can read to describe this

00:45:49,420 --> 00:45:52,650
but if iOS support is important to you

00:45:51,040 --> 00:45:55,480
then you should really look into this

00:45:52,650 --> 00:45:57,460
what is great safety is great ergonomics

00:45:55,480 --> 00:45:59,560
at the language are very nice traits are

00:45:57,460 --> 00:46:01,000
wonderful having a standard tool tool

00:45:59,560 --> 00:46:03,310
chain that everyone uses is great I

00:46:01,000 --> 00:46:04,599
think if we could take in C++ if we

00:46:03,310 --> 00:46:05,500
could take something from rust this is

00:46:04,599 --> 00:46:07,390
the thing that's kind of low-hanging

00:46:05,500 --> 00:46:09,540
fruit by creating standard tool chains

00:46:07,390 --> 00:46:11,800
that everyone can like rally around and

00:46:09,540 --> 00:46:12,580
get guest interaction behind I think

00:46:11,800 --> 00:46:14,410
this would be really good for people

00:46:12,580 --> 00:46:17,109
learning the language and coming into

00:46:14,410 --> 00:46:18,430
the language debugging Visual Studio

00:46:17,109 --> 00:46:20,230
code I didn't get to show you this but

00:46:18,430 --> 00:46:21,700
if you have Visual Studio code then the

00:46:20,230 --> 00:46:25,060
Russ community have kind of chosen that

00:46:21,700 --> 00:46:26,830
as their standard IDE and it seems like

00:46:25,060 --> 00:46:28,240
that's the thing to use and debugging

00:46:26,830 --> 00:46:30,339
works really well breakpoints and

00:46:28,240 --> 00:46:32,560
inspecting symbols and values and

00:46:30,339 --> 00:46:34,150
everything the Russ book is brilliant

00:46:32,560 --> 00:46:35,830
you should read it it will give you a

00:46:34,150 --> 00:46:38,560
full orientation of the language and

00:46:35,830 --> 00:46:42,010
it's very well-written the the

00:46:38,560 --> 00:46:44,589
communication effort that is part of the

00:46:42,010 --> 00:46:48,040
community I think is fantastic and worth

00:46:44,589 --> 00:46:49,510
studying really good and in general the

00:46:48,040 --> 00:46:51,910
community is great get involved like

00:46:49,510 --> 00:46:53,920
they would love to have you like I think

00:46:51,910 --> 00:46:56,410
the more people involved in real-time

00:46:53,920 --> 00:46:58,119
audio who are working in a community the

00:46:56,410 --> 00:46:59,500
more things will be built and at the

00:46:58,119 --> 00:47:01,450
moment there's not so many people doing

00:46:59,500 --> 00:47:03,730
this stuff and so there's if you'd like

00:47:01,450 --> 00:47:06,760
places where just tools that you need

00:47:03,730 --> 00:47:08,200
don't exist yet and maybe making those

00:47:06,760 --> 00:47:10,089
tools would be a good contribution and

00:47:08,200 --> 00:47:12,430
maybe you know how to so it would be a

00:47:10,089 --> 00:47:13,500
good thing to do a couple projects worth

00:47:12,430 --> 00:47:15,910
looking at

00:47:13,500 --> 00:47:18,099
Ralph Levine did a talk last week at a

00:47:15,910 --> 00:47:19,720
meet-up and presented his work on

00:47:18,099 --> 00:47:20,740
building an open-source synthesizer in

00:47:19,720 --> 00:47:22,750
rust it's looking very

00:47:20,740 --> 00:47:24,280
promising and interesting and if you

00:47:22,750 --> 00:47:25,360
you're looking for a thing to contribute

00:47:24,280 --> 00:47:25,990
to you then this would be a good place

00:47:25,360 --> 00:47:27,220
to start

00:47:25,990 --> 00:47:28,660
also there's a group of people are

00:47:27,220 --> 00:47:30,160
interested in building vsts with rust

00:47:28,660 --> 00:47:32,440
and they're working on a project there

00:47:30,160 --> 00:47:33,970
that's worth checking out alright so

00:47:32,440 --> 00:47:35,860
that's it thanks for listening you can

00:47:33,970 --> 00:47:39,580
find the code examples that github

00:47:35,860 --> 00:47:42,310
tapcon / ir h slash free verb - RS and

00:47:39,580 --> 00:47:43,510
there's also gonna be an ADC 2018 branch

00:47:42,310 --> 00:47:44,560
there which will capture the current

00:47:43,510 --> 00:47:45,820
stake so I think I'm going to keep

00:47:44,560 --> 00:47:47,650
working on it but like if you want to

00:47:45,820 --> 00:47:49,270
see the state if the code as it was when

00:47:47,650 --> 00:47:52,119
this talk was done then there'll be a

00:47:49,270 --> 00:47:53,619
branch also on Twitter on unschool hops

00:47:52,119 --> 00:47:54,790
and underscore and I should probably

00:47:53,619 --> 00:47:56,680
mention that the company I work for

00:47:54,790 --> 00:47:58,590
Ableton is hiring especially for C++

00:47:56,680 --> 00:48:00,730
engineers and you can look at our

00:47:58,590 --> 00:48:04,410
positions at Ableton comm slash jobs

00:48:00,730 --> 00:48:04,410
alright that's it thank you very much

00:48:09,140 --> 00:48:15,359
so I think we've got time for a couple

00:48:11,700 --> 00:48:17,430
of questions there's one here first

00:48:15,359 --> 00:48:18,630
question is there manual control over

00:48:17,430 --> 00:48:22,950
function inlining

00:48:18,630 --> 00:48:25,890
in rust and second you mentioned

00:48:22,950 --> 00:48:28,019
debugging if I write a C++ application

00:48:25,890 --> 00:48:32,549
with some pieces in rust can I just be

00:48:28,019 --> 00:48:36,420
bucket like using existing tools the

00:48:32,549 --> 00:48:38,519
first question lining finance

00:48:36,420 --> 00:48:40,650
applause-plause basically I don't know I

00:48:38,519 --> 00:48:42,059
didn't check that seems like a good

00:48:40,650 --> 00:48:44,970
thing to have I would imagine they

00:48:42,059 --> 00:48:47,190
thought about that if it exists it will

00:48:44,970 --> 00:48:49,049
be easy to find and if it doesn't then

00:48:47,190 --> 00:48:52,229
you'll find a long discussion about why

00:48:49,049 --> 00:48:53,849
they haven't added it that's generally

00:48:52,229 --> 00:48:55,829
the way these things go like they they

00:48:53,849 --> 00:48:58,619
see these problems and discuss them in

00:48:55,829 --> 00:49:01,410
depth and it's all in the open and easy

00:48:58,619 --> 00:49:04,529
to find so the simple answer is I don't

00:49:01,410 --> 00:49:08,309
know but like I think it's a really good

00:49:04,529 --> 00:49:09,869
question practicality but mixed

00:49:08,309 --> 00:49:12,029
applications written like partially in

00:49:09,869 --> 00:49:16,140
C++ partially in rust using existing

00:49:12,029 --> 00:49:18,180
tools Windows Mac you should be able to

00:49:16,140 --> 00:49:20,279
yet the debug symbols like in the

00:49:18,180 --> 00:49:23,309
standard format and I haven't tried that

00:49:20,279 --> 00:49:24,569
but I would anticipate that there is

00:49:23,309 --> 00:49:27,059
something we could we could give it a go

00:49:24,569 --> 00:49:35,299
after the talk if you like we'll see if

00:49:27,059 --> 00:49:39,410
it works anyone else going once

00:49:35,299 --> 00:49:39,410

YouTube URL: https://www.youtube.com/watch?v=Yom9E-67bdI


