Title: Embedded cryptography: RustCrypto + Veriform
Publication date: 2020-11-06
Playlist: Oxidize Global 2020
Description: 
	Historically cryptography in the embedded space has been a disaster, but with the growing pervasiveness of “IoT”, a topic of increasing importance. Rust provides a great language for building secure embedded applications, and with it a great platform for embedded cryptography.

This talk covers two cryptography projects written in pure Rust:

1. RustCrypto (“2.0”): a multi-crate “embedded-first” GitHub organization with trait-based implementations of several cryptographic algorithms including AEAD algorithms (AES-GCM, ChaCha20Poly1305), digest algorithms (SHA-2, SHA-3, BLAKE2), elliptic curves (NIST P-256, secp256k1), MACs (CMAC, HMAC), and signature algorithms (ECDSA, Ed25519)

2. Veriform: cryptographically verifiable and canonicalized message format similar to Protocol Buffers, with an “embedded-first” (heapless) implementation suitable for certificates or other signed objects


Recorded at Oxidize Global 2020
Captions: 
	00:00:03,010 --> 00:00:32,800
[Music]

00:00:32,079 --> 00:00:35,600
all right

00:00:32,800 --> 00:00:35,920
well we're about ready for our next talk

00:00:35,600 --> 00:00:38,399
so

00:00:35,920 --> 00:00:40,079
our next speaker is tony r siri who is

00:00:38,399 --> 00:00:42,800
actually a returning speaker from

00:00:40,079 --> 00:00:43,760
oxidized 1k so we're super excited to

00:00:42,800 --> 00:00:46,000
have tony back

00:00:43,760 --> 00:00:47,440
to talk about embedded cryptography rust

00:00:46,000 --> 00:00:50,399
crypto and veriform

00:00:47,440 --> 00:00:53,440
all right take it away tony all right uh

00:00:50,399 --> 00:00:53,440
you can hear me you're right

00:00:54,079 --> 00:00:57,199
double trucking i can hear you no

00:00:56,800 --> 00:01:00,160
worries

00:00:57,199 --> 00:01:02,399
all right all right great um yeah so as

00:01:00,160 --> 00:01:03,440
james said this is embedded cryptography

00:01:02,399 --> 00:01:05,680
and rust uh

00:01:03,440 --> 00:01:06,479
talking primarily about russ crypto and

00:01:05,680 --> 00:01:10,720
a little bit

00:01:06,479 --> 00:01:14,080
about veriform uh so i am tony irsuri

00:01:10,720 --> 00:01:17,680
i go by vascular on twitter ntr siri

00:01:14,080 --> 00:01:20,320
on github uh i work for a company called

00:01:17,680 --> 00:01:21,680
inclusion uh we do a lot of

00:01:20,320 --> 00:01:24,240
cryptocurrency stuff

00:01:21,680 --> 00:01:26,720
my background is primarily in more

00:01:24,240 --> 00:01:29,840
traditional cryptography though

00:01:26,720 --> 00:01:32,079
um we're working on a couple um

00:01:29,840 --> 00:01:33,680
interesting projects at occlusion that

00:01:32,079 --> 00:01:36,000
is leveraging all this stuff

00:01:33,680 --> 00:01:38,320
uh some of which we worked together with

00:01:36,000 --> 00:01:41,520
on with ferris

00:01:38,320 --> 00:01:41,920
we're developing embedded rust apps for

00:01:41,520 --> 00:01:44,640
this

00:01:41,920 --> 00:01:45,280
uh usb armory mark ii platform which is

00:01:44,640 --> 00:01:47,520
a cool

00:01:45,280 --> 00:01:48,320
little relatively inexpensive secure

00:01:47,520 --> 00:01:51,439
cortex a

00:01:48,320 --> 00:01:54,079
platform and we're also working on

00:01:51,439 --> 00:01:55,600
a hardware security module kind of

00:01:54,079 --> 00:01:58,799
operating system

00:01:55,600 --> 00:02:00,880
for the usb r mary mark ii uh based on

00:01:58,799 --> 00:02:02,240
arctic formerly known as real time for

00:02:00,880 --> 00:02:04,719
the masses

00:02:02,240 --> 00:02:07,280
so that's uh kind of what we're doing

00:02:04,719 --> 00:02:10,239
with all this stuff

00:02:07,280 --> 00:02:12,080
but i'm gonna back up a little bit um so

00:02:10,239 --> 00:02:16,400
i've been using a rust for

00:02:12,080 --> 00:02:19,599
about six years and in 2014

00:02:16,400 --> 00:02:23,599
i gave this talk at uh kind of the

00:02:19,599 --> 00:02:26,239
uh uh rust bay area meet up at mozilla

00:02:23,599 --> 00:02:28,080
uh i talked about how i thought rust was

00:02:26,239 --> 00:02:30,239
a very promising language for

00:02:28,080 --> 00:02:32,800
cryptography at the time

00:02:30,239 --> 00:02:33,440
uh and particularly talked about this

00:02:32,800 --> 00:02:36,319
idea

00:02:33,440 --> 00:02:37,440
of can we just do brand new green field

00:02:36,319 --> 00:02:40,720
cryptography in

00:02:37,440 --> 00:02:43,519
rust is that safe uh

00:02:40,720 --> 00:02:45,599
and you know i spent a long time talking

00:02:43,519 --> 00:02:48,480
about this particular topic

00:02:45,599 --> 00:02:50,959
that covered a lot of areas uh with a

00:02:48,480 --> 00:02:54,160
particular focus on things like

00:02:50,959 --> 00:02:56,319
timing side channels and uh

00:02:54,160 --> 00:02:58,400
like can we generate constant time code

00:02:56,319 --> 00:03:00,959
and rust and all of that

00:02:58,400 --> 00:03:02,080
um all of which at the time seemed very

00:03:00,959 --> 00:03:05,519
tricky to me

00:03:02,080 --> 00:03:08,800
um and so i ultimately ended up uh

00:03:05,519 --> 00:03:11,760
suggesting at the end of the talk is to

00:03:08,800 --> 00:03:13,760
take this sort of two-pronged approach

00:03:11,760 --> 00:03:15,200
uh you know i think it's very common in

00:03:13,760 --> 00:03:18,560
rust right it's like you

00:03:15,200 --> 00:03:21,360
grab existing uh mature

00:03:18,560 --> 00:03:22,480
well-vetted mainstream libraries to

00:03:21,360 --> 00:03:24,720
start with

00:03:22,480 --> 00:03:26,239
but then i also thought there was a lot

00:03:24,720 --> 00:03:28,720
of potential

00:03:26,239 --> 00:03:29,280
to kind of just you know start over from

00:03:28,720 --> 00:03:31,519
scratch

00:03:29,280 --> 00:03:34,080
do it all in rust and write pure us

00:03:31,519 --> 00:03:37,440
cryptography libraries

00:03:34,080 --> 00:03:38,879
so fast forward to 2020 we've kind of

00:03:37,440 --> 00:03:42,640
seen this

00:03:38,879 --> 00:03:45,840
two pronged approach play out

00:03:42,640 --> 00:03:49,319
so quite a few different libraries that

00:03:45,840 --> 00:03:52,080
wrap existing mature high quality

00:03:49,319 --> 00:03:54,319
implementations

00:03:52,080 --> 00:03:55,680
probably most notably ring is a

00:03:54,319 --> 00:03:59,120
fantastic library

00:03:55,680 --> 00:04:01,360
that also in some cases includes

00:03:59,120 --> 00:04:02,720
uh purest implementations of the same

00:04:01,360 --> 00:04:05,840
algorithms but

00:04:02,720 --> 00:04:07,680
mostly focusing on providing a wrapper

00:04:05,840 --> 00:04:10,159
for these high quality implementations

00:04:07,680 --> 00:04:12,799
from libraries like boring ssl

00:04:10,159 --> 00:04:14,400
um there's also sodium oxide which is a

00:04:12,799 --> 00:04:17,359
wrapper for lip sodium

00:04:14,400 --> 00:04:18,079
which is also a popular library um

00:04:17,359 --> 00:04:20,720
through in

00:04:18,079 --> 00:04:21,280
uh everybody is in the cryptocurrency

00:04:20,720 --> 00:04:24,400
space

00:04:21,280 --> 00:04:24,880
there is a uh c library from bitcoin

00:04:24,400 --> 00:04:28,080
core

00:04:24,880 --> 00:04:29,680
called libsec p256k1 that is

00:04:28,080 --> 00:04:31,520
probably the best library for this

00:04:29,680 --> 00:04:33,360
elliptic curve so

00:04:31,520 --> 00:04:35,520
um so that's great we have all these

00:04:33,360 --> 00:04:38,639
nice wrappers for

00:04:35,520 --> 00:04:40,840
high quality existing libraries um

00:04:38,639 --> 00:04:42,560
you know there's also many more that are

00:04:40,840 --> 00:04:44,000
necessarily uh

00:04:42,560 --> 00:04:45,919
you know they're wrappers for what are

00:04:44,000 --> 00:04:49,120
necessarily high quality libraries like

00:04:45,919 --> 00:04:52,000
open ssl or other native tls stocks

00:04:49,120 --> 00:04:53,040
um but the other thing the other side

00:04:52,000 --> 00:04:56,400
the other prong

00:04:53,040 --> 00:04:58,240
uh to this approach is um what we're

00:04:56,400 --> 00:05:01,360
seeing is the proliferation of

00:04:58,240 --> 00:05:03,600
libraries that are written in pure rusts

00:05:01,360 --> 00:05:04,479
uh more or less from the ground up you

00:05:03,600 --> 00:05:07,680
know uh

00:05:04,479 --> 00:05:09,440
maybe they started as like a translation

00:05:07,680 --> 00:05:12,800
of a c library or something but

00:05:09,440 --> 00:05:15,120
have definitely earlier matured um so i

00:05:12,800 --> 00:05:17,199
will be talking primarily about rus

00:05:15,120 --> 00:05:18,400
crypto which is kind of a suite of

00:05:17,199 --> 00:05:21,280
different uh

00:05:18,400 --> 00:05:22,240
cryptographic crates uh a couple other

00:05:21,280 --> 00:05:24,479
notable ones

00:05:22,240 --> 00:05:26,639
i thought i just mentioned um the dalek

00:05:24,479 --> 00:05:30,320
libraries these are elliptic curve fly

00:05:26,639 --> 00:05:33,120
uh libraries for curve 255.19

00:05:30,320 --> 00:05:34,000
there's also a cool one called fiat rust

00:05:33,120 --> 00:05:37,520
which is

00:05:34,000 --> 00:05:37,840
uh generated it was originally a project

00:05:37,520 --> 00:05:40,880
to

00:05:37,840 --> 00:05:44,080
generate uh c libraries c

00:05:40,880 --> 00:05:46,240
field arithmetic libraries uh that are

00:05:44,080 --> 00:05:49,680
formally verified using coke

00:05:46,240 --> 00:05:51,199
um and now they have a back end that

00:05:49,680 --> 00:05:53,520
targets rust as well so

00:05:51,199 --> 00:05:54,960
we've seen a really cool proliferation

00:05:53,520 --> 00:05:58,080
of these pure

00:05:54,960 --> 00:06:00,720
rust cryptography libraries and that is

00:05:58,080 --> 00:06:03,199
going to be the focus of my talk tonight

00:06:00,720 --> 00:06:04,800
um tonight for me morning for several of

00:06:03,199 --> 00:06:08,639
you

00:06:04,800 --> 00:06:11,680
so uh so what is russ crypto um

00:06:08,639 --> 00:06:15,600
so you may have heard of uh

00:06:11,680 --> 00:06:17,680
this rust dash crypto crates um

00:06:15,600 --> 00:06:19,280
so this is not what i'm talking about

00:06:17,680 --> 00:06:22,080
tonight

00:06:19,280 --> 00:06:22,720
you might notice this crate uh was last

00:06:22,080 --> 00:06:26,120
updated

00:06:22,720 --> 00:06:30,000
four years ago um so it's kind of

00:06:26,120 --> 00:06:34,160
unmaintained and uh effectively

00:06:30,000 --> 00:06:36,880
dead as a project um it's also got

00:06:34,160 --> 00:06:39,759
its keywords md5 and shot one which are

00:06:36,880 --> 00:06:42,319
both cryptographically broken algorithms

00:06:39,759 --> 00:06:43,280
so uh this this crate is not what i'm

00:06:42,319 --> 00:06:46,080
talking about

00:06:43,280 --> 00:06:48,880
um you know this was cool earlier a

00:06:46,080 --> 00:06:49,919
cryptography effort um the project

00:06:48,880 --> 00:06:52,240
stalled

00:06:49,919 --> 00:06:53,680
and it hasn't been worked on and at this

00:06:52,240 --> 00:06:57,759
point it's effectively a

00:06:53,680 --> 00:07:00,880
time capsule from about uh 2016.

00:06:57,759 --> 00:07:04,319
um so i'm not talking about

00:07:00,880 --> 00:07:05,360
russ dash crypto so not the one with the

00:07:04,319 --> 00:07:08,400
dash

00:07:05,360 --> 00:07:10,639
um instead i'm talking about the eras

00:07:08,400 --> 00:07:14,479
crypto github organization

00:07:10,639 --> 00:07:17,440
um kind of informally branded this as

00:07:14,479 --> 00:07:19,680
russ crypto 2.0 sometimes to kind of

00:07:17,440 --> 00:07:23,039
distinguish it from the old crate

00:07:19,680 --> 00:07:23,520
um here is a quick uh screenshot of the

00:07:23,039 --> 00:07:26,720
page

00:07:23,520 --> 00:07:28,880
on github um it's a little bit of

00:07:26,720 --> 00:07:31,039
project information

00:07:28,880 --> 00:07:32,479
you can find it on github under

00:07:31,039 --> 00:07:35,840
github.com

00:07:32,479 --> 00:07:36,080
arrest crypto um a bit of history about

00:07:35,840 --> 00:07:39,599
it

00:07:36,080 --> 00:07:42,880
started in 2016. uh the leads

00:07:39,599 --> 00:07:46,160
um are already on pavlov uh

00:07:42,880 --> 00:07:47,919
who is a phd candidate at school tech

00:07:46,160 --> 00:07:49,919
uh you might have seen him on the rust

00:07:47,919 --> 00:07:53,199
internals message board

00:07:49,919 --> 00:07:55,440
uh he's pretty involved in rust

00:07:53,199 --> 00:07:56,479
language development aside from us

00:07:55,440 --> 00:07:58,639
crypto

00:07:56,479 --> 00:07:59,840
uh and myself i'm the other leader of

00:07:58,639 --> 00:08:03,199
the project

00:07:59,840 --> 00:08:05,199
um we have roughly a dozen other uh

00:08:03,199 --> 00:08:06,879
active contributors like people are

00:08:05,199 --> 00:08:10,800
contributing to the project on

00:08:06,879 --> 00:08:13,199
ongoing basis and we have approximately

00:08:10,800 --> 00:08:16,400
a hundred crates

00:08:13,199 --> 00:08:19,680
so it's a very uh

00:08:16,400 --> 00:08:22,080
multi-crate sort of project um

00:08:19,680 --> 00:08:23,199
so you might be using uh one of our

00:08:22,080 --> 00:08:27,199
crates already

00:08:23,199 --> 00:08:31,120
uh shot two is very popular says digest

00:08:27,199 --> 00:08:33,519
uh but we have the names of kind of

00:08:31,120 --> 00:08:34,479
you know we have the short names of many

00:08:33,519 --> 00:08:37,120
cryptographic

00:08:34,479 --> 00:08:40,080
algorithms so hopefully our crates are

00:08:37,120 --> 00:08:42,640
pretty easy to find

00:08:40,080 --> 00:08:43,599
so the project uh got started off in

00:08:42,640 --> 00:08:46,800
00:08:43,599 --> 00:08:47,279
is kind of rethinking rus crypto from a

00:08:46,800 --> 00:08:50,399
single

00:08:47,279 --> 00:08:50,880
monolithic crate uh including one that

00:08:50,399 --> 00:08:52,959
had

00:08:50,880 --> 00:08:54,000
kind of you know a lot of algorithms

00:08:52,959 --> 00:08:56,800
that were

00:08:54,000 --> 00:08:59,120
either broken like md5 or just about to

00:08:56,800 --> 00:09:01,120
be broken like shot one right

00:08:59,120 --> 00:09:02,320
um so the idea was kind of how do you

00:09:01,120 --> 00:09:04,959
unpack

00:09:02,320 --> 00:09:05,680
uh res crypto into something where you

00:09:04,959 --> 00:09:07,440
can

00:09:05,680 --> 00:09:10,000
just grab only the crates for the

00:09:07,440 --> 00:09:12,959
algorithms you need

00:09:10,000 --> 00:09:14,880
so a quick uh overview of our goals and

00:09:12,959 --> 00:09:18,160
architectural principles

00:09:14,880 --> 00:09:18,640
uh so everything we write we initially

00:09:18,160 --> 00:09:22,160
write

00:09:18,640 --> 00:09:25,279
in pure rost so there is no

00:09:22,160 --> 00:09:27,920
algorithm within our org where there is

00:09:25,279 --> 00:09:31,040
only an assembly implementation

00:09:27,920 --> 00:09:34,560
uh don't you see

00:09:31,040 --> 00:09:36,480
everything is pressed um we also know

00:09:34,560 --> 00:09:39,360
stood as a baseline so this was

00:09:36,480 --> 00:09:41,920
uh kind of a big hold up for the

00:09:39,360 --> 00:09:43,920
original rust dash crypto crate uh it

00:09:41,920 --> 00:09:47,920
was not new student friendly

00:09:43,920 --> 00:09:51,200
so we are every single one of our crates

00:09:47,920 --> 00:09:52,240
uh except for one uh i'll talk about a

00:09:51,200 --> 00:09:55,360
bit later

00:09:52,240 --> 00:09:58,399
uh works understood and all of them

00:09:55,360 --> 00:10:00,640
except for two uh

00:09:58,399 --> 00:10:02,640
work in a heapless environment and do

00:10:00,640 --> 00:10:05,200
not need outlook so they're basically

00:10:02,640 --> 00:10:07,519
of these hundred crates are only to you

00:10:05,200 --> 00:10:10,800
that will not work in a heapless nested

00:10:07,519 --> 00:10:11,560
environment um so you also write

00:10:10,800 --> 00:10:14,560
portable

00:10:11,560 --> 00:10:15,440
implementations uh they're effectively

00:10:14,560 --> 00:10:19,040
designed to run

00:10:15,440 --> 00:10:20,880
anywhere um so we don't at a baseline

00:10:19,040 --> 00:10:22,480
make any sort of architectural

00:10:20,880 --> 00:10:25,440
assumptions

00:10:22,480 --> 00:10:26,160
except uh for a few about security i

00:10:25,440 --> 00:10:28,720
will highlight

00:10:26,160 --> 00:10:30,320
later we don't block you from compiling

00:10:28,720 --> 00:10:33,600
on those platforms but there are some

00:10:30,320 --> 00:10:36,399
things you need to be aware of um

00:10:33,600 --> 00:10:36,959
we do allow optional assembly so there

00:10:36,399 --> 00:10:39,200
are a few

00:10:36,959 --> 00:10:40,720
crates that have an asm feature that you

00:10:39,200 --> 00:10:43,760
can turn on

00:10:40,720 --> 00:10:46,800
uh we don't turn these on by default

00:10:43,760 --> 00:10:48,640
uh we make it really easy to

00:10:46,800 --> 00:10:50,720
uh get your cryptographic code or

00:10:48,640 --> 00:10:51,360
running anywhere and then if you want

00:10:50,720 --> 00:10:53,040
speed

00:10:51,360 --> 00:10:55,839
uh you can turn on these awesome

00:10:53,040 --> 00:10:56,560
features uh we're also very excited

00:10:55,839 --> 00:10:59,760
about

00:10:56,560 --> 00:11:02,240
inline assembly being stabilized and

00:10:59,760 --> 00:11:04,640
especially its potential on things like

00:11:02,240 --> 00:11:06,160
cortex-m

00:11:04,640 --> 00:11:08,480
as i mentioned earlier we are

00:11:06,160 --> 00:11:11,680
multi-crate architecture

00:11:08,480 --> 00:11:14,880
so we tend to use a one crate

00:11:11,680 --> 00:11:18,399
poor concept model

00:11:14,880 --> 00:11:20,320
so that's either we have a crate

00:11:18,399 --> 00:11:21,920
per trait or we have traits for

00:11:20,320 --> 00:11:24,240
different algorithm families where we

00:11:21,920 --> 00:11:26,839
have create super algorithm

00:11:24,240 --> 00:11:28,000
and uh finally we have a trait based

00:11:26,839 --> 00:11:30,560
architecture

00:11:28,000 --> 00:11:31,760
where every single algorithm and

00:11:30,560 --> 00:11:35,040
algorithm family

00:11:31,760 --> 00:11:35,519
has a trait that describes it and we

00:11:35,040 --> 00:11:38,000
made

00:11:35,519 --> 00:11:40,560
uh kind of architected things in such a

00:11:38,000 --> 00:11:43,839
way that anybody can implement these

00:11:40,560 --> 00:11:45,440
so you don't have to be like locked into

00:11:43,839 --> 00:11:48,320
our ecosystem

00:11:45,440 --> 00:11:49,920
to implement our traits and kind of

00:11:48,320 --> 00:11:53,839
interrupt and combine

00:11:49,920 --> 00:11:56,959
with the rest of our algorithms

00:11:53,839 --> 00:11:59,279
so if you are looking to kind of do a

00:11:56,959 --> 00:12:02,639
deep dive on the whole project

00:11:59,279 --> 00:12:05,040
uh we also have the cryptography great

00:12:02,639 --> 00:12:05,839
it's very kindly donated to us recently

00:12:05,040 --> 00:12:09,120
um

00:12:05,839 --> 00:12:12,560
so go to docs.rs cryptography

00:12:09,120 --> 00:12:16,000
you will get a rust dock high level

00:12:12,560 --> 00:12:19,040
overview of the whole project

00:12:16,000 --> 00:12:22,240
um so i'll do a quick

00:12:19,040 --> 00:12:24,399
uh tour of uh like some of the notable

00:12:22,240 --> 00:12:27,920
parts of the project here

00:12:24,399 --> 00:12:30,959
um so the main things we author

00:12:27,920 --> 00:12:33,440
is uh symmetric encryption

00:12:30,959 --> 00:12:36,320
using this idea of authenticated

00:12:33,440 --> 00:12:40,079
encryption with associated data

00:12:36,320 --> 00:12:42,240
this is high level uh encryption

00:12:40,079 --> 00:12:43,440
that is designed to detect things like

00:12:42,240 --> 00:12:47,200
forgeries

00:12:43,440 --> 00:12:50,160
um it significantly

00:12:47,200 --> 00:12:51,360
mitigates uh things that attacker can do

00:12:50,160 --> 00:12:53,519
to you

00:12:51,360 --> 00:12:55,120
uh so if you're trying to do symmetrical

00:12:53,519 --> 00:12:56,000
cryptography this is basically what you

00:12:55,120 --> 00:12:59,040
want to use

00:12:56,000 --> 00:13:01,200
um so this

00:12:59,040 --> 00:13:03,040
uh algorithm family authenticated

00:13:01,200 --> 00:13:05,440
encryption with associated data the

00:13:03,040 --> 00:13:08,480
traits are described in the aead

00:13:05,440 --> 00:13:09,200
crate and then we have several algorithm

00:13:08,480 --> 00:13:11,440
crates

00:13:09,200 --> 00:13:13,120
um hopefully you've heard of some of

00:13:11,440 --> 00:13:15,839
these but aes gcm

00:13:13,120 --> 00:13:16,720
is a popular cipher uh we also have

00:13:15,839 --> 00:13:20,240
these cool

00:13:16,720 --> 00:13:24,519
misuse resistant um synthetic

00:13:20,240 --> 00:13:26,240
initialization vector mode crates uh

00:13:24,519 --> 00:13:28,320
asgcm7asiv

00:13:26,240 --> 00:13:30,480
um these are really cool for things like

00:13:28,320 --> 00:13:33,680
keywrapping or if you need really short

00:13:30,480 --> 00:13:36,000
messages and they also

00:13:33,680 --> 00:13:37,680
use some neat tricks to mitigate against

00:13:36,000 --> 00:13:38,240
things like knots for use and that kind

00:13:37,680 --> 00:13:40,930
of thing

00:13:38,240 --> 00:13:42,320
so i think they're very slick um

00:13:40,930 --> 00:13:44,240
[Music]

00:13:42,320 --> 00:13:46,160
they also have a popular in the embedded

00:13:44,240 --> 00:13:49,279
world uh

00:13:46,160 --> 00:13:52,320
ccm mode uh an aes ccm

00:13:49,279 --> 00:13:53,040
um so these are probably the most

00:13:52,320 --> 00:13:57,120
commonly

00:13:53,040 --> 00:14:00,240
found um aed modes that you will see

00:13:57,120 --> 00:14:03,600
in embedded um so

00:14:00,240 --> 00:14:06,720
the chatro 20 poly 1305 crate this is

00:14:03,600 --> 00:14:09,040
a fantastic one if you don't have access

00:14:06,720 --> 00:14:11,360
to a cryptographic accelerator and you

00:14:09,040 --> 00:14:15,839
just want a very fast cipher

00:14:11,360 --> 00:14:17,199
uh we also have its sort of uh legacy

00:14:15,839 --> 00:14:20,880
version equivalent

00:14:17,199 --> 00:14:23,600
uh x also 20 poly 1305

00:14:20,880 --> 00:14:25,040
which you will find in uh lib sodium and

00:14:23,600 --> 00:14:27,760
knackle

00:14:25,040 --> 00:14:28,560
uh and more uh so this is just some of

00:14:27,760 --> 00:14:32,000
them

00:14:28,560 --> 00:14:32,959
um what's cool is two of these have been

00:14:32,000 --> 00:14:36,160
audited

00:14:32,959 --> 00:14:39,040
by uh ncc group so they

00:14:36,160 --> 00:14:39,600
published uh this report of an audit

00:14:39,040 --> 00:14:43,440
they did

00:14:39,600 --> 00:14:44,480
in december 2019 uh there were no major

00:14:43,440 --> 00:14:48,079
findings

00:14:44,480 --> 00:14:51,680
um very effectively a few minor findings

00:14:48,079 --> 00:14:54,800
uh mostly due to performance uh

00:14:51,680 --> 00:14:58,320
but really uh

00:14:54,800 --> 00:15:02,320
they didn't find anything uh substantive

00:14:58,320 --> 00:15:05,120
uh in their audit uh so moving on

00:15:02,320 --> 00:15:06,320
uh so we also have block ciphers have a

00:15:05,120 --> 00:15:09,120
little warning sign there

00:15:06,320 --> 00:15:10,240
because this is kind of hazmat crypto so

00:15:09,120 --> 00:15:12,639
if uh

00:15:10,240 --> 00:15:14,160
you uh don't know what you're doing you

00:15:12,639 --> 00:15:16,800
probably shouldn't use the black silvers

00:15:14,160 --> 00:15:19,279
directly you should use the aeds

00:15:16,800 --> 00:15:21,279
um so the traits for these are described

00:15:19,279 --> 00:15:23,839
in the block cipher crates

00:15:21,279 --> 00:15:27,360
block dash cipher um and then the

00:15:23,839 --> 00:15:30,800
algorithm crates so we have aes

00:15:27,360 --> 00:15:34,000
this will map on to

00:15:30,800 --> 00:15:36,720
if you use this it will use a

00:15:34,000 --> 00:15:38,160
software implementation that is constant

00:15:36,720 --> 00:15:40,560
time using a technique called bit

00:15:38,160 --> 00:15:42,880
slicing on embedded platforms

00:15:40,560 --> 00:15:45,040
it also has a special back end for intel

00:15:42,880 --> 00:15:48,399
platforms for esi

00:15:45,040 --> 00:15:50,639
um also as far as uh legacy block

00:15:48,399 --> 00:15:52,160
cypress go we also have desks this also

00:15:50,639 --> 00:15:55,920
implements triple desks

00:15:52,160 --> 00:15:59,440
uh and more so there are plenty of

00:15:55,920 --> 00:16:02,880
other block ciphers um we don't

00:15:59,440 --> 00:16:04,160
really um we we will uh take whatever

00:16:02,880 --> 00:16:05,600
ciphers people

00:16:04,160 --> 00:16:07,759
kind of want to give us but these are

00:16:05,600 --> 00:16:09,440
the ones we recommend um and i wouldn't

00:16:07,759 --> 00:16:13,120
even recommend dust unless you

00:16:09,440 --> 00:16:15,600
need legacy interhop so moving on to

00:16:13,120 --> 00:16:17,920
your hashes or digest algorithms

00:16:15,600 --> 00:16:18,959
um chances are you probably have the

00:16:17,920 --> 00:16:22,320
digest crates

00:16:18,959 --> 00:16:24,399
in your project somewhere already um

00:16:22,320 --> 00:16:25,759
name some of the crates that use it uh

00:16:24,399 --> 00:16:28,160
blake2 this is

00:16:25,759 --> 00:16:29,519
a cool fast new hash function on

00:16:28,160 --> 00:16:32,399
software

00:16:29,519 --> 00:16:33,440
uh there's also your ibm d160 this kind

00:16:32,399 --> 00:16:35,199
of legacy one

00:16:33,440 --> 00:16:36,959
but it's somewhat popular in the

00:16:35,199 --> 00:16:40,240
cryptocurrency world

00:16:36,959 --> 00:16:43,440
and a good old shot too uh providing

00:16:40,240 --> 00:16:45,519
shot 256 384 and 512.

00:16:43,440 --> 00:16:48,399
uh and more uh there are tons of

00:16:45,519 --> 00:16:52,000
cryptographic algorithms

00:16:48,399 --> 00:16:53,920
uh message authentication codes uh

00:16:52,000 --> 00:16:55,920
we have the crypto mac crate that

00:16:53,920 --> 00:16:58,959
defines the traits for them

00:16:55,920 --> 00:17:00,160
uh as far as algorithms go uh c-max

00:16:58,959 --> 00:17:02,959
cipher-based mac

00:17:00,160 --> 00:17:04,000
you might see this in the embedded space

00:17:02,959 --> 00:17:05,839
um one of my first

00:17:04,000 --> 00:17:07,039
interactions with russ crypto as a

00:17:05,839 --> 00:17:10,720
project

00:17:07,039 --> 00:17:12,319
was uh implementing a secure embedded

00:17:10,720 --> 00:17:15,280
secure channel protocol

00:17:12,319 --> 00:17:16,480
called the global platform uh secure

00:17:15,280 --> 00:17:19,520
channel

00:17:16,480 --> 00:17:22,640
protocol u3 which uh builds on this

00:17:19,520 --> 00:17:26,000
um probably a bit familiar

00:17:22,640 --> 00:17:29,039
more familiar to everyone's hvac uh pmac

00:17:26,000 --> 00:17:30,400
is a cool parallelizable cypher-based

00:17:29,039 --> 00:17:34,080
mac as well

00:17:30,400 --> 00:17:37,440
and more they're still more max

00:17:34,080 --> 00:17:39,200
so stream savers again um

00:17:37,440 --> 00:17:40,720
he's kind of fallen to that hazmat

00:17:39,200 --> 00:17:43,600
category where

00:17:40,720 --> 00:17:45,280
uh if they're misused you can fail

00:17:43,600 --> 00:17:47,840
catastrophically so again i have a

00:17:45,280 --> 00:17:47,840
warning sign

00:17:48,400 --> 00:17:51,440
so as far as traits uh we have the

00:17:50,880 --> 00:17:54,559
stream

00:17:51,440 --> 00:17:55,840
dash cipher crates um as far as the

00:17:54,559 --> 00:17:59,280
algorithm crates go

00:17:55,840 --> 00:18:02,880
we have uh counter and aes counter

00:17:59,280 --> 00:18:04,320
uh so counter mode turns a block cipher

00:18:02,880 --> 00:18:07,520
into a stream cipher

00:18:04,320 --> 00:18:08,960
uh this is used by things like aes gcm

00:18:07,520 --> 00:18:11,520
internally

00:18:08,960 --> 00:18:13,440
um we also have trencha 20 that the

00:18:11,520 --> 00:18:16,640
utrocha 20

00:18:13,440 --> 00:18:18,080
creative is based on as well as salsa 20

00:18:16,640 --> 00:18:21,520
which is what the

00:18:18,080 --> 00:18:24,960
x also 20 poly 1305 crate is based on

00:18:21,520 --> 00:18:24,960
uh and more all right

00:18:25,039 --> 00:18:29,520
finally here um my

00:18:28,160 --> 00:18:31,679
favorite and possibly the most

00:18:29,520 --> 00:18:35,120
interesting uh we have

00:18:31,679 --> 00:18:38,160
a fairly recent addition a bunch of

00:18:35,120 --> 00:18:40,080
public key cryptography crates um

00:18:38,160 --> 00:18:44,320
probably is there some that will be the

00:18:40,080 --> 00:18:44,320
most interesting to embedded developers

00:18:44,640 --> 00:18:48,160
so you have elliptic curve cryptography

00:18:46,880 --> 00:18:50,400
crates

00:18:48,160 --> 00:18:52,400
they have traits to find in the elliptic

00:18:50,400 --> 00:18:55,600
curve crate

00:18:52,400 --> 00:18:56,080
we have three curves implemented right

00:18:55,600 --> 00:19:00,360
now

00:18:56,080 --> 00:19:02,559
we have a k256 providing the secp

00:19:00,360 --> 00:19:04,000
256k1 curve this is popular in

00:19:02,559 --> 00:19:06,880
cryptocurrency

00:19:04,000 --> 00:19:07,440
uh the other three there are nist curves

00:19:06,880 --> 00:19:09,520
uh

00:19:07,440 --> 00:19:12,640
so these are the nsp curves that are

00:19:09,520 --> 00:19:17,360
used in things like tls bluetooth

00:19:12,640 --> 00:19:20,320
that kind of thing um we have 256 384

00:19:17,360 --> 00:19:21,240
implemented uh that's that last one is

00:19:20,320 --> 00:19:25,280
supposed to be

00:19:21,240 --> 00:19:27,520
p521 it's a typo

00:19:25,280 --> 00:19:29,039
when your curve has a weird number in it

00:19:27,520 --> 00:19:32,480
um but that crate

00:19:29,039 --> 00:19:34,880
is also um effectively like uh

00:19:32,480 --> 00:19:35,600
vaporware it's empty we just reserved it

00:19:34,880 --> 00:19:39,760
um

00:19:35,600 --> 00:19:42,559
so really k256 p2506 and p384

00:19:39,760 --> 00:19:43,280
are the crates we have available today

00:19:42,559 --> 00:19:46,000
um

00:19:43,280 --> 00:19:47,520
we also have the rsa crate so i said

00:19:46,000 --> 00:19:50,720
earlier

00:19:47,520 --> 00:19:54,400
that uh there's only one that

00:19:50,720 --> 00:19:59,039
is presently uh presently requires stood

00:19:54,400 --> 00:20:02,400
uh this is it um we have a open pr

00:19:59,039 --> 00:20:06,159
to make it support nested plus alec

00:20:02,400 --> 00:20:09,600
uh and plan so that pr is ready to merge

00:20:06,159 --> 00:20:12,720
we have planned uh future support

00:20:09,600 --> 00:20:14,880
to eventually drop the alec requirement

00:20:12,720 --> 00:20:15,840
um and finally here we have digital

00:20:14,880 --> 00:20:18,080
signatures

00:20:15,840 --> 00:20:20,000
um so the traits for these are defined

00:20:18,080 --> 00:20:22,880
in the signature crates

00:20:20,000 --> 00:20:24,080
uh and we have algorithm crates for both

00:20:22,880 --> 00:20:26,320
ecdsa

00:20:24,080 --> 00:20:27,520
uh the olympic curve digital signature

00:20:26,320 --> 00:20:31,720
algorithm

00:20:27,520 --> 00:20:34,400
um as well as ed 255.19 uh

00:20:31,720 --> 00:20:36,320
ccdsa are in the process of implementing

00:20:34,400 --> 00:20:37,200
the algorithm i'll talk more about that

00:20:36,320 --> 00:20:40,400
later

00:20:37,200 --> 00:20:43,760
um and 255.19 just defines

00:20:40,400 --> 00:20:45,360
a set of interoperable signature formats

00:20:43,760 --> 00:20:47,440
uh we're not trying to compete with the

00:20:45,360 --> 00:20:50,960
dalek libraries or anything

00:20:47,440 --> 00:20:53,440
um but notably uh the ed 255

00:20:50,960 --> 00:20:55,600
19 crate is now used by the dalek

00:20:53,440 --> 00:20:59,120
library which is cool

00:20:55,600 --> 00:21:00,640
all right so that is a big intro to the

00:20:59,120 --> 00:21:04,400
whole project

00:21:00,640 --> 00:21:07,520
um but this is embedded uh conference

00:21:04,400 --> 00:21:11,440
so um here are a bunch of highlights

00:21:07,520 --> 00:21:13,280
of why i think these are interesting uh

00:21:11,440 --> 00:21:17,039
uh why i think russ crypto is

00:21:13,280 --> 00:21:19,600
interesting uh for rust embedded

00:21:17,039 --> 00:21:20,480
so first as i mentioned earlier uh all

00:21:19,600 --> 00:21:23,679
our crates

00:21:20,480 --> 00:21:24,799
are sea i'd and routinely tested in

00:21:23,679 --> 00:21:26,960
nosted

00:21:24,799 --> 00:21:27,919
uh environments including heapless

00:21:26,960 --> 00:21:31,120
environments

00:21:27,919 --> 00:21:32,720
um that in and of itself uh probably

00:21:31,120 --> 00:21:34,159
isn't that interesting right like that's

00:21:32,720 --> 00:21:37,919
kind of like table stakes

00:21:34,159 --> 00:21:40,240
um so when we talk about embedded

00:21:37,919 --> 00:21:41,360
uh what are we talking about so kind of

00:21:40,240 --> 00:21:43,679
our tier one

00:21:41,360 --> 00:21:44,960
embedded targets are really going to be

00:21:43,679 --> 00:21:48,320
arm cortex a

00:21:44,960 --> 00:21:48,799
and rm cortex m uh i feel like this is

00:21:48,320 --> 00:21:51,840
kind of

00:21:48,799 --> 00:21:54,559
par for the course for uh rust embedded

00:21:51,840 --> 00:21:56,840
in general right when people say rust

00:21:54,559 --> 00:21:59,840
and betta they're usually talking arm

00:21:56,840 --> 00:22:00,960
um you want to support other

00:21:59,840 --> 00:22:04,240
environments

00:22:00,960 --> 00:22:05,039
uh you know the effectively everything

00:22:04,240 --> 00:22:08,960
else to us

00:22:05,039 --> 00:22:11,919
is like tier three but it's a little bit

00:22:08,960 --> 00:22:13,679
tricky so you know our code will compile

00:22:11,919 --> 00:22:17,440
on these targets

00:22:13,679 --> 00:22:21,039
um we know when we say

00:22:17,440 --> 00:22:24,559
uh our implementations are constant time

00:22:21,039 --> 00:22:25,520
uh it's specifically noted we're talking

00:22:24,559 --> 00:22:30,240
about arm

00:22:25,520 --> 00:22:32,559
uh or are we talking about intel um

00:22:30,240 --> 00:22:34,960
when it comes to other processors it

00:22:32,559 --> 00:22:38,000
kind of really depends

00:22:34,960 --> 00:22:38,799
uh you know like uh constant time is

00:22:38,000 --> 00:22:41,919
effectively

00:22:38,799 --> 00:22:44,080
like a uh hardware a property of a

00:22:41,919 --> 00:22:45,120
combined hardware and software system

00:22:44,080 --> 00:22:47,520
right

00:22:45,120 --> 00:22:49,520
so there are plenty of cpus and

00:22:47,520 --> 00:22:51,120
microcontrollers out there

00:22:49,520 --> 00:22:52,640
for example that don't have constant

00:22:51,120 --> 00:22:54,799
time multiplication

00:22:52,640 --> 00:22:56,320
uh like some cpu designer thought they

00:22:54,799 --> 00:22:58,240
were really clever

00:22:56,320 --> 00:22:59,679
and if you tried to multiply it by zero

00:22:58,240 --> 00:23:02,240
or one they uh

00:22:59,679 --> 00:23:02,960
short circuit the uh aou or something

00:23:02,240 --> 00:23:05,840
right

00:23:02,960 --> 00:23:07,600
um so they thought they were clever but

00:23:05,840 --> 00:23:09,679
that kind of destroys cryptography on

00:23:07,600 --> 00:23:13,520
that entire platform

00:23:09,679 --> 00:23:16,320
um so moving on um

00:23:13,520 --> 00:23:16,640
notably i think one of the cool things

00:23:16,320 --> 00:23:19,679
uh

00:23:16,640 --> 00:23:22,240
rus crypto lets you do is integrate uh

00:23:19,679 --> 00:23:25,679
with hardware accelerators

00:23:22,240 --> 00:23:26,799
uh so we're doing this in our armistice

00:23:25,679 --> 00:23:29,360
project

00:23:26,799 --> 00:23:30,559
uh and ideally i think the traits were

00:23:29,360 --> 00:23:32,799
developing

00:23:30,559 --> 00:23:33,919
you know you see a lot of talk in uh

00:23:32,799 --> 00:23:36,159
like rust embedded

00:23:33,919 --> 00:23:37,600
circles about having like a crypto howl

00:23:36,159 --> 00:23:40,080
or something right

00:23:37,600 --> 00:23:42,240
um so i think ideally our traits can

00:23:40,080 --> 00:23:44,400
function as a crypto how

00:23:42,240 --> 00:23:45,840
um to give you an idea of what these

00:23:44,400 --> 00:23:47,600
look like and

00:23:45,840 --> 00:23:48,880
some of how we're trying to optimize

00:23:47,600 --> 00:23:52,080
from better targets

00:23:48,880 --> 00:23:52,880
um so you have this trade called block

00:23:52,080 --> 00:23:57,120
cipher

00:23:52,880 --> 00:23:59,240
um so you might have looked at some of

00:23:57,120 --> 00:24:01,440
our traits before and we had things like

00:23:59,240 --> 00:24:03,440
initializers tied into the trait

00:24:01,440 --> 00:24:05,679
which made it hard to apply them to

00:24:03,440 --> 00:24:08,559
things like cryptographic accelerators

00:24:05,679 --> 00:24:09,679
um so the latest versions of all these

00:24:08,559 --> 00:24:12,400
traits which were

00:24:09,679 --> 00:24:14,080
released a few months ago completely

00:24:12,400 --> 00:24:17,440
splits initialization

00:24:14,080 --> 00:24:19,360
from the core algorithm itself

00:24:17,440 --> 00:24:20,720
but you might see in this trade right we

00:24:19,360 --> 00:24:23,919
have this par blocks

00:24:20,720 --> 00:24:26,320
uh we're trying to encode ways to do

00:24:23,919 --> 00:24:27,440
things like cindy and that kind of thing

00:24:26,320 --> 00:24:30,000
um

00:24:27,440 --> 00:24:30,480
and you know like that that really helps

00:24:30,000 --> 00:24:32,799
uh

00:24:30,480 --> 00:24:34,559
intel on things like esi and that kind

00:24:32,799 --> 00:24:36,080
of thing it's not necessarily very

00:24:34,559 --> 00:24:38,480
embedded friendly

00:24:36,080 --> 00:24:39,120
um this is some of the things we started

00:24:38,480 --> 00:24:43,360
doing

00:24:39,120 --> 00:24:46,320
is um adding uh sort of separate

00:24:43,360 --> 00:24:48,480
more embedded friendly traits um so we

00:24:46,320 --> 00:24:49,679
think this block cipher mutate for

00:24:48,480 --> 00:24:52,880
example

00:24:49,679 --> 00:24:55,279
is a uh better target for embedded um

00:24:52,880 --> 00:24:57,039
so you want to talk to a cryptographic

00:24:55,279 --> 00:24:59,039
accelerator that's like effectively a

00:24:57,039 --> 00:25:01,760
hardware peripheral right

00:24:59,039 --> 00:25:04,000
uh normally a block cipher is just doing

00:25:01,760 --> 00:25:06,480
a permutation it doesn't have any state

00:25:04,000 --> 00:25:07,120
so we didn't have a meat reference

00:25:06,480 --> 00:25:10,159
before

00:25:07,120 --> 00:25:12,000
on that previous block cipher trace um

00:25:10,159 --> 00:25:14,000
this one has a meat reference which we

00:25:12,000 --> 00:25:15,760
think is very nice for getting to a

00:25:14,000 --> 00:25:19,279
hardware peripheral

00:25:15,760 --> 00:25:21,520
um and this is effectively our i think

00:25:19,279 --> 00:25:23,200
our trait that we will focus on using

00:25:21,520 --> 00:25:24,640
draft things like cryptographic

00:25:23,200 --> 00:25:26,720
accelerators

00:25:24,640 --> 00:25:28,159
i think it might be pretty interesting

00:25:26,720 --> 00:25:30,240
to play with things like parallel

00:25:28,159 --> 00:25:31,760
pipelining that kind of thing uh with

00:25:30,240 --> 00:25:33,919
this retreat

00:25:31,760 --> 00:25:35,600
um but we would love feedback on this

00:25:33,919 --> 00:25:37,919
sort of thing and whether or not

00:25:35,600 --> 00:25:39,360
our traits are mapping well or aren't

00:25:37,919 --> 00:25:40,799
mapping well the cryptographic

00:25:39,360 --> 00:25:42,400
accelerators

00:25:40,799 --> 00:25:43,840
if they aren't mapping well we would

00:25:42,400 --> 00:25:47,120
like uh to

00:25:43,840 --> 00:25:49,279
figure out how to solve that

00:25:47,120 --> 00:25:50,720
so giving an example of how a trait like

00:25:49,279 --> 00:25:54,000
this is kind of useful

00:25:50,720 --> 00:25:56,400
um here's an example of how

00:25:54,000 --> 00:25:57,760
you can combine this block cipher trait

00:25:56,400 --> 00:26:01,600
with the asgcm

00:25:57,760 --> 00:26:02,080
crate um so one interesting thing we've

00:26:01,600 --> 00:26:05,039
done

00:26:02,080 --> 00:26:06,720
is make the aes crate a optional

00:26:05,039 --> 00:26:09,760
dependency of

00:26:06,720 --> 00:26:11,120
this aesgcm authenticated encryption

00:26:09,760 --> 00:26:12,640
crate

00:26:11,120 --> 00:26:14,559
so if you want to use a hardware

00:26:12,640 --> 00:26:16,480
accelerator instead of the software

00:26:14,559 --> 00:26:18,240
implementation

00:26:16,480 --> 00:26:20,320
you can completely shut that aes

00:26:18,240 --> 00:26:21,679
dependency off

00:26:20,320 --> 00:26:24,480
so you're not even pulling in any of

00:26:21,679 --> 00:26:26,880
that code and then

00:26:24,480 --> 00:26:29,279
if you implement this block cipher trait

00:26:26,880 --> 00:26:32,720
uh for your cryptographic accelerator

00:26:29,279 --> 00:26:36,320
uh using generics you can instantiate

00:26:32,720 --> 00:26:39,120
aes gcm using the hardware accelerator

00:26:36,320 --> 00:26:42,159
instead of the software implementation

00:26:39,120 --> 00:26:43,520
so i think that's pretty cool um so

00:26:42,159 --> 00:26:46,640
speaking of aes

00:26:43,520 --> 00:26:50,080
gcm uh we have

00:26:46,640 --> 00:26:52,400
probably one of the uh

00:26:50,080 --> 00:26:54,480
best uh embedded optimized

00:26:52,400 --> 00:26:57,679
implementations of this algorithm

00:26:54,480 --> 00:27:01,840
available today uh specifically

00:26:57,679 --> 00:27:05,279
targeting 32-bit uh cortex-m

00:27:01,840 --> 00:27:09,039
devices and specifically even

00:27:05,279 --> 00:27:12,080
i think having devices like cortex m0

00:27:09,039 --> 00:27:14,559
in mind um so i say this

00:27:12,080 --> 00:27:17,760
uh you might be thinking or i've heard

00:27:14,559 --> 00:27:19,360
that asgcm performs poorly on embedded

00:27:17,760 --> 00:27:22,480
platforms

00:27:19,360 --> 00:27:25,120
and in general you'd be right um

00:27:22,480 --> 00:27:25,600
the funny thing is uh you know what if

00:27:25,120 --> 00:27:27,760
people

00:27:25,600 --> 00:27:29,520
have just been implementing it badly all

00:27:27,760 --> 00:27:32,640
along

00:27:29,520 --> 00:27:33,600
so this is kind of funny um so the main

00:27:32,640 --> 00:27:36,640
way

00:27:33,600 --> 00:27:37,200
people implement asgcm using these sort

00:27:36,640 --> 00:27:40,399
of

00:27:37,200 --> 00:27:43,200
like bit slicing techniques uh it does

00:27:40,399 --> 00:27:46,399
actually wind up being very slow but

00:27:43,200 --> 00:27:49,039
that doesn't have to be the case

00:27:46,399 --> 00:27:49,919
so there's this library called bear ssl

00:27:49,039 --> 00:27:53,039
made by

00:27:49,919 --> 00:27:57,279
thomas pornen uh that's a embedded

00:27:53,039 --> 00:28:00,960
optimized ssl library it uses this very

00:27:57,279 --> 00:28:04,000
clever technique uh so

00:28:00,960 --> 00:28:04,960
the core of this g hash function is

00:28:04,000 --> 00:28:08,000
effectively

00:28:04,960 --> 00:28:11,440
a carrier-less multiplication operation

00:28:08,000 --> 00:28:14,320
or a finite field um so this is normally

00:28:11,440 --> 00:28:17,039
done using very complicated techniques

00:28:14,320 --> 00:28:18,080
to kind of uh get rid of that carry

00:28:17,039 --> 00:28:20,960
spelling rate

00:28:18,080 --> 00:28:21,520
um to kind of get rid of those carries

00:28:20,960 --> 00:28:24,559
um

00:28:21,520 --> 00:28:28,080
so what bear ssl does is it takes

00:28:24,559 --> 00:28:29,279
uh integers and kind of splits them up

00:28:28,080 --> 00:28:31,919
into chunks

00:28:29,279 --> 00:28:33,760
and then whenever these carriers occur

00:28:31,919 --> 00:28:37,200
uh they fall into one of these

00:28:33,760 --> 00:28:41,200
uh he calls them holes and then they

00:28:37,200 --> 00:28:41,200
end up getting masked out of the results

00:28:41,360 --> 00:28:46,559
so it's surprisingly efficient um

00:28:44,799 --> 00:28:49,919
so here is a comment in the

00:28:46,559 --> 00:28:52,799
implementation of uh this is taken

00:28:49,919 --> 00:28:54,000
pretty much verbatim from bear ssl uh

00:28:52,799 --> 00:28:57,360
which is where

00:28:54,000 --> 00:29:00,559
uh implementation is inspired by um

00:28:57,360 --> 00:29:01,279
and it uh describes this technique a

00:29:00,559 --> 00:29:04,320
little bit

00:29:01,279 --> 00:29:08,159
um but effectively it is uh

00:29:04,320 --> 00:29:11,440
been optimized for cortex m and m zero

00:29:08,159 --> 00:29:14,720
um so just to give you an idea um

00:29:11,440 --> 00:29:18,399
here is the entire uh effectively

00:29:14,720 --> 00:29:21,120
g hash uh multiplication

00:29:18,399 --> 00:29:22,159
operation on a single slide uh you

00:29:21,120 --> 00:29:24,240
probably can't read it

00:29:22,159 --> 00:29:26,720
but yeah i'm just trying to get the

00:29:24,240 --> 00:29:27,440
point across that uh it isn't very much

00:29:26,720 --> 00:29:30,960
code

00:29:27,440 --> 00:29:34,559
um so here's the heart of it uh

00:29:30,960 --> 00:29:35,919
is bmol32u so everything you're seeing

00:29:34,559 --> 00:29:38,159
this is the only part with any

00:29:35,919 --> 00:29:41,600
multiplications everything else is just

00:29:38,159 --> 00:29:42,399
bitwise uh arithmetic you can see it's

00:29:41,600 --> 00:29:45,600
doing

00:29:42,399 --> 00:29:48,320
16 multiplications there

00:29:45,600 --> 00:29:50,559
and then that is called within this loop

00:29:48,320 --> 00:29:53,679
that calls it 18 times

00:29:50,559 --> 00:29:57,039
um so that's like 288

00:29:53,679 --> 00:29:59,919
integer multiplications per block uh

00:29:57,039 --> 00:30:02,159
which for g hash actually ends up being

00:29:59,919 --> 00:30:04,480
pretty good

00:30:02,159 --> 00:30:05,600
so i saw this like it kind of blew my

00:30:04,480 --> 00:30:08,480
mind because g

00:30:05,600 --> 00:30:09,360
hash is just notoriously slow otherwise

00:30:08,480 --> 00:30:12,000
right so

00:30:09,360 --> 00:30:14,480
i think we have a very nice

00:30:12,000 --> 00:30:14,960
implementation of g ash that's intended

00:30:14,480 --> 00:30:18,559
to be

00:30:14,960 --> 00:30:19,679
embedded friendly um so one more

00:30:18,559 --> 00:30:22,159
interesting thing

00:30:19,679 --> 00:30:23,840
is uh how to do lightweight symmetric

00:30:22,159 --> 00:30:26,159
cryptography

00:30:23,840 --> 00:30:28,240
uh that we support through the chat 20

00:30:26,159 --> 00:30:31,279
poly 1305 crates

00:30:28,240 --> 00:30:33,600
um so one way you can make this faster

00:30:31,279 --> 00:30:35,679
so it's already pretty fast in software

00:30:33,600 --> 00:30:37,919
um but you can make it even faster by

00:30:35,679 --> 00:30:40,720
using fewer rounds so you

00:30:37,919 --> 00:30:42,240
use a reduced round construction uh so

00:30:40,720 --> 00:30:44,399
this sounds a little scary

00:30:42,240 --> 00:30:46,480
but um there's a pretty interesting

00:30:44,399 --> 00:30:47,919
paper that came out last year called too

00:30:46,480 --> 00:30:50,640
much crypto

00:30:47,919 --> 00:30:51,120
that really analyze the number of rounds

00:30:50,640 --> 00:30:53,200
that

00:30:51,120 --> 00:30:54,159
are being used in various cryptographic

00:30:53,200 --> 00:30:58,320
constructions

00:30:54,159 --> 00:30:58,640
including uh cha-cha 20. so chacha 20 is

00:30:58,320 --> 00:31:01,679
a

00:30:58,640 --> 00:31:02,480
stream cipher uh specifically this thing

00:31:01,679 --> 00:31:06,720
called an arc

00:31:02,480 --> 00:31:09,200
cipher where arcs's add rotator xor

00:31:06,720 --> 00:31:09,840
it's a improvement over this previous

00:31:09,200 --> 00:31:13,360
cipher

00:31:09,840 --> 00:31:14,960
called salsa 20. so these are

00:31:13,360 --> 00:31:16,799
block diagrams of what's called the

00:31:14,960 --> 00:31:17,440
quarter round function which is kind of

00:31:16,799 --> 00:31:20,240
the heart

00:31:17,440 --> 00:31:21,440
of the cipher uh it takes some input and

00:31:20,240 --> 00:31:24,559
effectively

00:31:21,440 --> 00:31:26,159
blends it up uh until it looks uniformly

00:31:24,559 --> 00:31:29,519
random

00:31:26,159 --> 00:31:31,679
uh so salsa 20 or cha-cha 20

00:31:29,519 --> 00:31:34,480
can be combined with this universal hash

00:31:31,679 --> 00:31:36,640
function called poly1305

00:31:34,480 --> 00:31:38,480
which acts as a message authentication

00:31:36,640 --> 00:31:40,480
code and provides you this nice

00:31:38,480 --> 00:31:43,519
authenticated encryption

00:31:40,480 --> 00:31:44,640
um so you might be wondering uh why 20

00:31:43,519 --> 00:31:46,799
rounds right like

00:31:44,640 --> 00:31:47,679
where did where is this number 20 come

00:31:46,799 --> 00:31:50,720
from

00:31:47,679 --> 00:31:53,440
um so the answer that uh

00:31:50,720 --> 00:31:55,279
we gotta get back to 1949 this paper

00:31:53,440 --> 00:31:57,279
called communication theory of secrecy

00:31:55,279 --> 00:31:59,600
systems by claude shannon

00:31:57,279 --> 00:32:01,519
um in this paper he talks about this

00:31:59,600 --> 00:32:04,799
notion of diffusion

00:32:01,519 --> 00:32:08,240
uh so diffusion is uh having this

00:32:04,799 --> 00:32:09,120
uh very complicated uh structure to

00:32:08,240 --> 00:32:12,640
where

00:32:09,120 --> 00:32:14,640
statistical analysis of uh

00:32:12,640 --> 00:32:15,840
the cipher text becomes incredibly

00:32:14,640 --> 00:32:19,039
difficult

00:32:15,840 --> 00:32:21,200
uh so fundamentally the

00:32:19,039 --> 00:32:22,640
amount of diffusion that is occurring in

00:32:21,200 --> 00:32:25,279
each of these ciphers

00:32:22,640 --> 00:32:28,480
is what controls the number of rounds

00:32:25,279 --> 00:32:31,760
and how easy it is to attack

00:32:28,480 --> 00:32:35,120
so comparing cha-cha 20 to salsa 20 uh

00:32:31,760 --> 00:32:36,960
really quick um 20

00:32:35,120 --> 00:32:39,360
improved per round of fusion so it has

00:32:36,960 --> 00:32:41,440
even better diffusions also 20.

00:32:39,360 --> 00:32:42,559
uh simultaneously improved performance

00:32:41,440 --> 00:32:46,080
right so win-win

00:32:42,559 --> 00:32:47,120
so this is really cool um then notably

00:32:46,080 --> 00:32:49,519
salsa 20

00:32:47,120 --> 00:32:51,120
already had these reduced round variants

00:32:49,519 --> 00:32:52,000
they have these weird names where it's

00:32:51,120 --> 00:32:54,240
also 20

00:32:52,000 --> 00:32:57,760
8. it's the eight round version and it

00:32:54,240 --> 00:33:00,960
had 12 round version two

00:32:57,760 --> 00:33:04,799
so i'm looking at uh both of these

00:33:00,960 --> 00:33:07,760
and uh what the best known attacks are

00:33:04,799 --> 00:33:08,640
um this is one of the papers that came

00:33:07,760 --> 00:33:11,039
out that did

00:33:08,640 --> 00:33:13,600
uh most of the security analysis around

00:33:11,039 --> 00:33:15,039
them uh it was in 2007 new features

00:33:13,600 --> 00:33:17,519
latin dances

00:33:15,039 --> 00:33:18,880
uh and then in 2019 we got this too much

00:33:17,519 --> 00:33:21,679
crypto paper

00:33:18,880 --> 00:33:23,600
um you might notice uh the same guy's

00:33:21,679 --> 00:33:24,720
name is on both of them jean-philippe

00:33:23,600 --> 00:33:27,840
anderson

00:33:24,720 --> 00:33:30,640
uh mr jean-philippe uh

00:33:27,840 --> 00:33:31,039
knows what he's talking about because he

00:33:30,640 --> 00:33:33,360
did

00:33:31,039 --> 00:33:34,559
uh the initial attack some of the best

00:33:33,360 --> 00:33:37,200
attacks

00:33:34,559 --> 00:33:38,320
against both of these algorithms and

00:33:37,200 --> 00:33:41,440
what they saw

00:33:38,320 --> 00:33:44,159
um salsa 20 it was

00:33:41,440 --> 00:33:46,159
broken quote unquote as in it was

00:33:44,159 --> 00:33:48,799
reduced below its promise security

00:33:46,159 --> 00:33:51,840
margin of 256 bits

00:33:48,799 --> 00:33:53,360
uh the seven round version of salsa 20

00:33:51,840 --> 00:33:57,039
was broken

00:33:53,360 --> 00:33:59,440
um as well as the eight round version um

00:33:57,039 --> 00:34:01,200
so you need at least nine rounds it's

00:33:59,440 --> 00:34:04,640
also 20 to get the full

00:34:01,200 --> 00:34:07,200
uh full security uh promise security

00:34:04,640 --> 00:34:10,960
level um trout

00:34:07,200 --> 00:34:13,200
7 was broken it was not um

00:34:10,960 --> 00:34:14,159
future attacks kind of reduces even

00:34:13,200 --> 00:34:17,679
further to

00:34:14,159 --> 00:34:20,480
235 but kind of point being um

00:34:17,679 --> 00:34:21,839
salsa 8 is safe and even with these

00:34:20,480 --> 00:34:24,320
breakages which were

00:34:21,839 --> 00:34:25,760
effectively due to insufficient

00:34:24,320 --> 00:34:28,159
diffusion

00:34:25,760 --> 00:34:29,200
um even with these breakages they're not

00:34:28,159 --> 00:34:32,480
that broken right

00:34:29,200 --> 00:34:34,159
like they're still like two to the 235

00:34:32,480 --> 00:34:36,320
bits is still fine

00:34:34,159 --> 00:34:37,760
but chacha 8 still gives you that full

00:34:36,320 --> 00:34:41,359
256 bit

00:34:37,760 --> 00:34:42,159
255 bits of security um so the paper

00:34:41,359 --> 00:34:44,639
concludes

00:34:42,159 --> 00:34:45,599
uh so how many rounds of cha cha do we

00:34:44,639 --> 00:34:48,879
need like a j

00:34:45,599 --> 00:34:49,679
uh like i just said uh eight rounds of

00:34:48,879 --> 00:34:52,800
cha-cha

00:34:49,679 --> 00:34:55,520
should be sufficient um

00:34:52,800 --> 00:34:56,639
for like all attacks that we can force a

00:34:55,520 --> 00:35:00,079
year right now right

00:34:56,639 --> 00:35:02,240
um based on the these principles that go

00:35:00,079 --> 00:35:05,760
back to 1949

00:35:02,240 --> 00:35:08,160
um so in conclusion chacha 20

00:35:05,760 --> 00:35:11,119
is overkill uh probably should have been

00:35:08,160 --> 00:35:13,359
standardized with 20 rounds like 12

00:35:11,119 --> 00:35:14,240
would have been sufficient it's kind of

00:35:13,359 --> 00:35:15,839
a mistake

00:35:14,240 --> 00:35:17,839
and it's kind of unfortunate that was

00:35:15,839 --> 00:35:20,480
standardized for 20 rounds

00:35:17,839 --> 00:35:21,520
um but eight rounds still beats the best

00:35:20,480 --> 00:35:25,359
known attack

00:35:21,520 --> 00:35:29,040
and gives you a 256-bit security level

00:35:25,359 --> 00:35:32,160
um so if you uh

00:35:29,040 --> 00:35:34,640
want to get more performance out of this

00:35:32,160 --> 00:35:35,760
uh you can get effectively a two and a

00:35:34,640 --> 00:35:38,800
half

00:35:35,760 --> 00:35:41,440
uh x speed up uh by using

00:35:38,800 --> 00:35:42,160
uh one of these reducer or using the

00:35:41,440 --> 00:35:46,000
cha-cha

00:35:42,160 --> 00:35:48,960
eight reduced round variants and if you

00:35:46,000 --> 00:35:50,960
you know want to take maybe a little bit

00:35:48,960 --> 00:35:53,040
less potential risk but not really you

00:35:50,960 --> 00:35:56,079
could use cha cha 12 instead

00:35:53,040 --> 00:35:59,359
um so you offer this cha cha

00:35:56,079 --> 00:36:00,240
each pulley 1305 variant uh in the

00:35:59,359 --> 00:36:03,599
charge of 20

00:36:00,240 --> 00:36:04,560
poly 1305 crate um so if you're looking

00:36:03,599 --> 00:36:07,520
for a

00:36:04,560 --> 00:36:09,680
very fast software in software that

00:36:07,520 --> 00:36:13,359
doesn't need a cryptographic accelerator

00:36:09,680 --> 00:36:16,240
this is the one i'd recommend um

00:36:13,359 --> 00:36:17,760
so finally uh the this is the end of the

00:36:16,240 --> 00:36:21,359
euros crypto section

00:36:17,760 --> 00:36:24,480
um we have elliptic curve cryptography

00:36:21,359 --> 00:36:25,280
um which i'm very excited about and i

00:36:24,480 --> 00:36:27,440
think it

00:36:25,280 --> 00:36:28,720
might be very useful for uh rust

00:36:27,440 --> 00:36:30,880
embedded

00:36:28,720 --> 00:36:32,400
um so some quick highlights on what

00:36:30,880 --> 00:36:35,200
we're doing uh

00:36:32,400 --> 00:36:35,920
so we support the legacy elliptic curves

00:36:35,200 --> 00:36:37,760
um

00:36:35,920 --> 00:36:39,760
these are the ones these are actually

00:36:37,760 --> 00:36:40,160
the i say legacy but they're the ones

00:36:39,760 --> 00:36:42,560
you're

00:36:40,160 --> 00:36:44,320
probably going to care about um they're

00:36:42,560 --> 00:36:45,280
wire straws curves either the nest

00:36:44,320 --> 00:36:48,800
curves or

00:36:45,280 --> 00:36:51,119
sec-p this cryptocurrency curve um

00:36:48,800 --> 00:36:52,880
we've implemented the modern formula so

00:36:51,119 --> 00:36:54,240
the older formulas had all sorts of

00:36:52,880 --> 00:36:56,560
security vulnerabilities

00:36:54,240 --> 00:36:57,520
if you ever saw djb's like safe curve

00:36:56,560 --> 00:37:00,880
site

00:36:57,520 --> 00:37:03,040
um he made fun of them uh this is

00:37:00,880 --> 00:37:04,480
kind of the things djv was complaining

00:37:03,040 --> 00:37:06,240
about have been addressed through the

00:37:04,480 --> 00:37:09,599
use of these modern formulas

00:37:06,240 --> 00:37:10,960
um so optimizing for correctness first

00:37:09,599 --> 00:37:15,079
performance second

00:37:10,960 --> 00:37:17,440
uh and providing constant time

00:37:15,079 --> 00:37:18,079
implementations uh based on the subtle

00:37:17,440 --> 00:37:20,800
crates

00:37:18,079 --> 00:37:22,640
um perhaps most notably we're not using

00:37:20,800 --> 00:37:24,480
any lookup tables these are usually the

00:37:22,640 --> 00:37:25,280
killer a thing for doing elliptic curve

00:37:24,480 --> 00:37:28,720
cryptography

00:37:25,280 --> 00:37:30,640
and embedded uh so we have compared to

00:37:28,720 --> 00:37:33,280
most other implementations very small

00:37:30,640 --> 00:37:33,280
code size

00:37:33,359 --> 00:37:38,320
so here's a kind of at a glance table of

00:37:36,320 --> 00:37:42,000
the status of all these things

00:37:38,320 --> 00:37:43,119
um so right now the k250d6 crate is the

00:37:42,000 --> 00:37:45,839
most mature

00:37:43,119 --> 00:37:47,839
uh it's got a nice 32-bit uh field

00:37:45,839 --> 00:37:51,440
arithmetic back end

00:37:47,839 --> 00:37:55,480
uh just today i got ecdsa

00:37:51,440 --> 00:37:59,280
kind of poc'd

00:37:55,480 --> 00:38:02,560
p256 we have plans for a 32-bit back end

00:37:59,280 --> 00:38:06,000
uh it's kind of underway um the

00:38:02,560 --> 00:38:06,480
only available back end is 64-bit and we

00:38:06,000 --> 00:38:09,920
have

00:38:06,480 --> 00:38:10,960
uh some cool prs from nicholas styler of

00:38:09,920 --> 00:38:14,800
solo keys

00:38:10,960 --> 00:38:16,880
to implement uh p256 ecdsa and kind of

00:38:14,800 --> 00:38:18,720
like the scalar arithmetic formulas that

00:38:16,880 --> 00:38:21,920
you need to implement it

00:38:18,720 --> 00:38:23,040
um p384 we don't have any arithmetic and

00:38:21,920 --> 00:38:26,400
p521

00:38:23,040 --> 00:38:28,720
is effectively uh us squatting that

00:38:26,400 --> 00:38:28,720
crate

00:38:29,280 --> 00:38:33,760
so uh some highlights uh closing

00:38:32,640 --> 00:38:34,880
highlights on elliptic curve

00:38:33,760 --> 00:38:38,240
cryptography

00:38:34,880 --> 00:38:41,040
um so you're targeting uh electric curve

00:38:38,240 --> 00:38:44,320
diffie-hellman in ec dsa use cases

00:38:41,040 --> 00:38:46,000
uh you can do ecdh today

00:38:44,320 --> 00:38:48,079
um it's a little bit tricky we're going

00:38:46,000 --> 00:38:49,280
to try to put a friendlier interface on

00:38:48,079 --> 00:38:51,760
it

00:38:49,280 --> 00:38:54,160
we'll hopefully have ecdsa fully shipped

00:38:51,760 --> 00:38:58,320
by august

00:38:54,160 --> 00:39:00,960
and elliptic career cryptography on

00:38:58,320 --> 00:39:03,599
embedded is also notoriously tricky

00:39:00,960 --> 00:39:05,839
especially things like side channels

00:39:03,599 --> 00:39:07,680
um so we're already building in things

00:39:05,839 --> 00:39:09,599
like side channel or resistance to

00:39:07,680 --> 00:39:12,400
things like differential power attacks

00:39:09,599 --> 00:39:13,920
using uh techniques like random blinding

00:39:12,400 --> 00:39:16,000
which is hiding these scalar

00:39:13,920 --> 00:39:17,760
multiplication operations behind a

00:39:16,000 --> 00:39:20,960
random number

00:39:17,760 --> 00:39:22,640
uh we intend to mitigate our random

00:39:20,960 --> 00:39:24,960
number generators they're using

00:39:22,640 --> 00:39:28,000
deterministic ecdsa

00:39:24,960 --> 00:39:31,359
this rfc6979 technique

00:39:28,000 --> 00:39:35,040
um funny thing though when you do that

00:39:31,359 --> 00:39:37,440
you open yourself up to fault attacks um

00:39:35,040 --> 00:39:39,599
so there's an even more interesting

00:39:37,440 --> 00:39:41,359
technique we might explore

00:39:39,599 --> 00:39:43,359
which allows you to combine both the

00:39:41,359 --> 00:39:45,839
determinism and the randomness in

00:39:43,359 --> 00:39:48,800
addition to this random finding

00:39:45,839 --> 00:39:49,359
and mitigate fault attacks as well by

00:39:48,800 --> 00:39:51,359
adding

00:39:49,359 --> 00:39:53,920
even more randomness to the signature

00:39:51,359 --> 00:39:55,760
generation process

00:39:53,920 --> 00:39:58,160
all right i feel i'm running a bit over

00:39:55,760 --> 00:40:00,160
on time uh so i'm gonna be very quick

00:39:58,160 --> 00:40:03,839
but very for him unfortunately

00:40:00,160 --> 00:40:04,560
um but veriform is something we've been

00:40:03,839 --> 00:40:07,680
developing

00:40:04,560 --> 00:40:08,240
as part of this armistice project um to

00:40:07,680 --> 00:40:10,800
create

00:40:08,240 --> 00:40:12,560
a nice embedded friendly

00:40:10,800 --> 00:40:16,480
cryptographically verifiable

00:40:12,560 --> 00:40:18,880
serialization format um

00:40:16,480 --> 00:40:20,280
so the problem is you know even if we

00:40:18,880 --> 00:40:21,920
have these nice cryptographic

00:40:20,280 --> 00:40:25,680
implementations

00:40:21,920 --> 00:40:29,359
um like uh as uh adi shamir said

00:40:25,680 --> 00:40:30,640
uh cryptography isn't uh penetrated it's

00:40:29,359 --> 00:40:32,560
circumvented

00:40:30,640 --> 00:40:35,200
so usually the crypto isn't the part

00:40:32,560 --> 00:40:38,720
that breaks it's uh

00:40:35,200 --> 00:40:39,359
the tldr of this is things like x509 and

00:40:38,720 --> 00:40:43,280
asn

00:40:39,359 --> 00:40:44,720
1 and all that um devices are routinely

00:40:43,280 --> 00:40:49,119
compromised by

00:40:44,720 --> 00:40:49,839
failing to parse uh x 509 certificates

00:40:49,119 --> 00:40:52,160
correctly

00:40:49,839 --> 00:40:53,200
failing to validate the signatures

00:40:52,160 --> 00:40:55,119
unfortunately

00:40:53,200 --> 00:40:57,200
uh this sort of process is often

00:40:55,119 --> 00:41:00,319
instrumental in things like

00:40:57,200 --> 00:41:03,040
code updates uh boot loaders uh secure

00:41:00,319 --> 00:41:06,079
boot processes that kind of thing

00:41:03,040 --> 00:41:08,880
so this paper i have up is a

00:41:06,079 --> 00:41:10,960
very scary paper about how pretty much

00:41:08,880 --> 00:41:13,599
nothing besides browsers implements

00:41:10,960 --> 00:41:15,119
x 509 correctly you know all all these

00:41:13,599 --> 00:41:16,880
things have like horrible security

00:41:15,119 --> 00:41:22,079
vulnerabilities

00:41:16,880 --> 00:41:25,680
um see quick overview of veriform

00:41:22,079 --> 00:41:27,599
so provides a canonical encoding using a

00:41:25,680 --> 00:41:28,880
taglink value structure which is very

00:41:27,599 --> 00:41:32,720
common

00:41:28,880 --> 00:41:34,800
we've taken ideas from both asn.1 a few

00:41:32,720 --> 00:41:38,480
of its different encodings

00:41:34,800 --> 00:41:41,119
as well as google protocol buffers um

00:41:38,480 --> 00:41:43,200
i've done a heap list new did first

00:41:41,119 --> 00:41:44,319
implementation this is all we support

00:41:43,200 --> 00:41:48,240
right now

00:41:44,319 --> 00:41:51,760
um so uh this is what we're targeting

00:41:48,240 --> 00:41:55,280
uh via armistice um so it will work

00:41:51,760 --> 00:41:58,720
out of the box you don't need a heap

00:41:55,280 --> 00:42:01,119
um cool thing uh that really

00:41:58,720 --> 00:42:02,640
uh makes it unique is this concept of

00:42:01,119 --> 00:42:05,040
structured hashing

00:42:02,640 --> 00:42:06,160
uh so we automatically compute digest

00:42:05,040 --> 00:42:09,200
for all parts of

00:42:06,160 --> 00:42:10,560
a message uh in as part of the message

00:42:09,200 --> 00:42:13,040
decoder

00:42:10,560 --> 00:42:14,000
uh so it's extensible this is kind of a

00:42:13,040 --> 00:42:17,359
big important thing

00:42:14,000 --> 00:42:19,599
in x509 and tls uh

00:42:17,359 --> 00:42:20,880
this is capable of supporting unknown

00:42:19,599 --> 00:42:23,440
fields uh

00:42:20,880 --> 00:42:24,400
in security contacts you may not want to

00:42:23,440 --> 00:42:26,480
have

00:42:24,400 --> 00:42:27,680
fields you don't recognize so it also

00:42:26,480 --> 00:42:30,800
supports this idea

00:42:27,680 --> 00:42:32,000
from x509 of being able to mark certain

00:42:30,800 --> 00:42:34,960
fields is critical

00:42:32,000 --> 00:42:36,319
uh so if you're the decoders these are

00:42:34,960 --> 00:42:37,920
these fields

00:42:36,319 --> 00:42:39,760
uh doesn't know what it is but it has

00:42:37,920 --> 00:42:40,640
this critical bit it will fail to parse

00:42:39,760 --> 00:42:43,839
the message

00:42:40,640 --> 00:42:44,720
if it's security critical uh and finally

00:42:43,839 --> 00:42:46,960
it's got these cool

00:42:44,720 --> 00:42:47,920
product macro derived encoders and

00:42:46,960 --> 00:42:51,040
decoders

00:42:47,920 --> 00:42:53,520
uh that were inspired by prost um

00:42:51,040 --> 00:42:54,079
so here's a really quick uh syntax

00:42:53,520 --> 00:42:56,400
example

00:42:54,079 --> 00:42:58,480
showing the product macros um if you've

00:42:56,400 --> 00:43:01,200
ever seen pros drive

00:42:58,480 --> 00:43:02,319
it's very similar to that um you drive

00:43:01,200 --> 00:43:04,960
message

00:43:02,319 --> 00:43:06,319
uh you tag each of the fields uh with

00:43:04,960 --> 00:43:08,960
these attributes

00:43:06,319 --> 00:43:12,560
and it will automatically generate a

00:43:08,960 --> 00:43:15,280
parser and serializer

00:43:12,560 --> 00:43:17,119
some quick use case examples here uh i'm

00:43:15,280 --> 00:43:18,720
running out of time unfortunately

00:43:17,119 --> 00:43:20,480
yeah tony if unfortunately we've got to

00:43:18,720 --> 00:43:23,839
go into our next talk here in a second

00:43:20,480 --> 00:43:26,240
so are there any parting thoughts uh

00:43:23,839 --> 00:43:27,680
yeah i can wrap it up quickly um so you

00:43:26,240 --> 00:43:29,200
see there yeah this would be

00:43:27,680 --> 00:43:30,880
this is good for certificates we're

00:43:29,200 --> 00:43:33,280
using it for our pc

00:43:30,880 --> 00:43:34,319
and uh finally for uh having

00:43:33,280 --> 00:43:37,839
cryptographically

00:43:34,319 --> 00:43:41,200
authenticated and signed logs um

00:43:37,839 --> 00:43:44,560
that's it thanks for watching everyone

00:43:41,200 --> 00:43:54,960
uh and there are some uh final links

00:43:44,560 --> 00:43:57,040
and i will take questions uh in the chat

00:43:54,960 --> 00:43:57,040

YouTube URL: https://www.youtube.com/watch?v=yyyVIxptScY


