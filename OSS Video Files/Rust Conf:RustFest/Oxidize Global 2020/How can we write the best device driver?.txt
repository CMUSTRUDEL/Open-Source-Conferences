Title: How can we write the best device driver?
Publication date: 2020-11-06
Playlist: Oxidize Global 2020
Description: 
	Writing a device driver can be a lot of work, writing a good one even more.

In this talk, we’ll explore some different styles of writing to and reading from registers and we’ll be weighing the pros and the cons. It will not conclude with a definitive best way, but hopefully it will give some ideas to use for the next driver you write.

The library discussed in this talk has also been publicly released since the talk was recorded: https://crates.io/crates/device-driver
Captions: 
	00:00:01,770 --> 00:00:33,360
[Music]

00:00:32,640 --> 00:00:36,480
hello

00:00:33,360 --> 00:00:39,520
and we're back after the break

00:00:36,480 --> 00:00:42,399
we're driving music to driving hardware

00:00:39,520 --> 00:00:43,360
um diane will talk to us about how we

00:00:42,399 --> 00:00:47,200
can write

00:00:43,360 --> 00:00:50,000
the best device driver for rust

00:00:47,200 --> 00:00:51,039
that's a tall order i'll give you the

00:00:50,000 --> 00:00:54,559
stage

00:00:51,039 --> 00:00:56,640
a little bit clickbaity but yeah um

00:00:54,559 --> 00:00:59,039
welcome everybody welcome to my talk

00:00:56,640 --> 00:00:59,600
about how can we write the best device

00:00:59,039 --> 00:01:04,080
driver

00:00:59,600 --> 00:01:07,680
let's get my slides together here yes

00:01:04,080 --> 00:01:10,720
okay um yeah i'm the undoctor

00:01:07,680 --> 00:01:12,720
and i'm gonna be talking about this

00:01:10,720 --> 00:01:13,920
so due to time i can talk about

00:01:12,720 --> 00:01:17,119
everything i want

00:01:13,920 --> 00:01:19,200
uh so it's quite limited but hopefully

00:01:17,119 --> 00:01:22,240
it'll give you some ideas for your

00:01:19,200 --> 00:01:23,920
next well device driver so uh

00:01:22,240 --> 00:01:26,400
for the overview first we're gonna talk

00:01:23,920 --> 00:01:28,400
about how to do the hardware interface

00:01:26,400 --> 00:01:29,600
we're going to be looking at how it is

00:01:28,400 --> 00:01:33,280
generally done in c

00:01:29,600 --> 00:01:35,040
and then how we can improve it in rust

00:01:33,280 --> 00:01:37,119
and then we're going to talk about the

00:01:35,040 --> 00:01:40,240
software interface and we'll take

00:01:37,119 --> 00:01:43,759
a an imaginary chip and

00:01:40,240 --> 00:01:44,479
write a little start of a device driver

00:01:43,759 --> 00:01:46,640
for it

00:01:44,479 --> 00:01:48,320
so there's a lot of code but i hope

00:01:46,640 --> 00:01:50,560
you'll like it

00:01:48,320 --> 00:01:51,680
so the hardware interface what is that

00:01:50,560 --> 00:01:55,600
actually well

00:01:51,680 --> 00:01:59,119
it's how we want to talk to the device

00:01:55,600 --> 00:02:01,680
and if we look at c well we get

00:01:59,119 --> 00:02:03,600
into a problem because well we want an

00:02:01,680 --> 00:02:05,600
abstract interface we want to plug in

00:02:03,600 --> 00:02:08,080
anything and if you google

00:02:05,600 --> 00:02:08,640
see abstract interface well it only

00:02:08,080 --> 00:02:12,239
shows

00:02:08,640 --> 00:02:14,480
other languages not c so

00:02:12,239 --> 00:02:15,280
that's a little bit problem problematic

00:02:14,480 --> 00:02:17,680
so

00:02:15,280 --> 00:02:18,879
in c there are three main ways that i've

00:02:17,680 --> 00:02:22,000
seen people

00:02:18,879 --> 00:02:24,720
do it and i'm gonna go

00:02:22,000 --> 00:02:25,520
through them all now and the first one

00:02:24,720 --> 00:02:28,560
i've called

00:02:25,520 --> 00:02:31,680
pre-made fill-in functions so the idea

00:02:28,560 --> 00:02:34,480
is that you you clone

00:02:31,680 --> 00:02:35,680
the library there are some functions

00:02:34,480 --> 00:02:38,959
provided for you and

00:02:35,680 --> 00:02:41,280
you need to fill in to talk to your

00:02:38,959 --> 00:02:44,560
hardware you need to fill them some code

00:02:41,280 --> 00:02:46,879
and the good for this is that it's

00:02:44,560 --> 00:02:49,599
pretty performant like the compiler has

00:02:46,879 --> 00:02:52,239
got all the information it needs

00:02:49,599 --> 00:02:53,440
but usability is bad because well you're

00:02:52,239 --> 00:02:56,879
expected to

00:02:53,440 --> 00:02:58,760
clone or rather fork the library

00:02:56,879 --> 00:02:59,920
and maintain your own hardware

00:02:58,760 --> 00:03:03,599
implementation

00:02:59,920 --> 00:03:07,200
for it so what does it look like

00:03:03,599 --> 00:03:10,159
well this is some example code

00:03:07,200 --> 00:03:10,879
so at the top we've got some sbi type

00:03:10,159 --> 00:03:14,080
which is

00:03:10,879 --> 00:03:16,080
void by standard which you can change

00:03:14,080 --> 00:03:17,840
you've got some initializer function

00:03:16,080 --> 00:03:20,480
that takes the instance

00:03:17,840 --> 00:03:21,840
and then provides it to your functions

00:03:20,480 --> 00:03:24,159
over here

00:03:21,840 --> 00:03:25,440
and this is literally what the library

00:03:24,159 --> 00:03:28,400
does it says to do

00:03:25,440 --> 00:03:28,720
here enable the cs pin disable the cs

00:03:28,400 --> 00:03:32,000
pin

00:03:28,720 --> 00:03:35,040
i've taken spi as an example

00:03:32,000 --> 00:03:36,319
during this talk by the way and there is

00:03:35,040 --> 00:03:39,040
a transfer function

00:03:36,319 --> 00:03:40,560
and you just need to do what's what's

00:03:39,040 --> 00:03:44,080
required

00:03:40,560 --> 00:03:46,000
but for the library side here in this

00:03:44,080 --> 00:03:48,640
example code

00:03:46,000 --> 00:03:49,680
that's pretty easy you just say hey

00:03:48,640 --> 00:03:52,239
enable cs

00:03:49,680 --> 00:03:53,200
transfer transfer and we get the result

00:03:52,239 --> 00:03:56,239
back disable

00:03:53,200 --> 00:03:56,799
cs and we get a result and if we look at

00:03:56,239 --> 00:04:00,080
the

00:03:56,799 --> 00:04:03,599
assembly we can see

00:04:00,080 --> 00:04:06,400
our function over here and it's all

00:04:03,599 --> 00:04:09,920
just moves because my implementation

00:04:06,400 --> 00:04:12,400
i've written over here for the

00:04:09,920 --> 00:04:14,000
hardware interface just pokes on

00:04:12,400 --> 00:04:17,359
registers read some values

00:04:14,000 --> 00:04:20,000
out of it so we'd expect only to

00:04:17,359 --> 00:04:21,440
to have move instructions and that's the

00:04:20,000 --> 00:04:23,840
case

00:04:21,440 --> 00:04:25,520
in all the other examples i will use the

00:04:23,840 --> 00:04:28,800
exact same instructions here

00:04:25,520 --> 00:04:32,080
so we can compare them all

00:04:28,800 --> 00:04:34,320
but yeah we we need to maintain our own

00:04:32,080 --> 00:04:37,120
fork

00:04:34,320 --> 00:04:38,320
and it's all static and stuff and i

00:04:37,120 --> 00:04:41,600
don't really like it so

00:04:38,320 --> 00:04:44,400
let's let's throw it away the other one

00:04:41,600 --> 00:04:45,120
is runtime function pointers and this is

00:04:44,400 --> 00:04:47,520
where

00:04:45,120 --> 00:04:48,880
the library doesn't have like the

00:04:47,520 --> 00:04:51,520
defined

00:04:48,880 --> 00:04:53,680
uh functions for it but it allows you to

00:04:51,520 --> 00:04:55,919
plug in your own function pointers

00:04:53,680 --> 00:04:57,840
and for usability this is pretty good

00:04:55,919 --> 00:04:58,479
because when you pass in a function

00:04:57,840 --> 00:05:01,120
pointer

00:04:58,479 --> 00:05:04,000
it's actually type checked even in c

00:05:01,120 --> 00:05:04,000
it's amazing right

00:05:04,160 --> 00:05:10,479
so but the performance is not very good

00:05:06,960 --> 00:05:15,280
because the compiler won't be able to

00:05:10,479 --> 00:05:17,919
always know ahead of time which pointer

00:05:15,280 --> 00:05:19,199
or which function gets pointed to so it

00:05:17,919 --> 00:05:22,880
it can't inline

00:05:19,199 --> 00:05:26,160
everything if we look at the code

00:05:22,880 --> 00:05:26,880
at the top here we have our definitions

00:05:26,160 --> 00:05:30,720
for our

00:05:26,880 --> 00:05:33,520
function pointers they get stored here

00:05:30,720 --> 00:05:35,280
in these static variables our

00:05:33,520 --> 00:05:37,759
initializer functions just

00:05:35,280 --> 00:05:39,199
takes them and stores them here and our

00:05:37,759 --> 00:05:41,199
example looks pretty

00:05:39,199 --> 00:05:42,720
simple again just enable transfer

00:05:41,199 --> 00:05:47,440
transfer disable

00:05:42,720 --> 00:05:50,560
result but our assembly

00:05:47,440 --> 00:05:53,680
is not as good like the initialization

00:05:50,560 --> 00:05:57,039
is pretty good it's just moving the uh

00:05:53,680 --> 00:05:57,840
arguments to the uh to the fields over

00:05:57,039 --> 00:06:01,199
here

00:05:57,840 --> 00:06:03,600
but our example is suddenly quite

00:06:01,199 --> 00:06:04,400
inefficient uh we're doing all kinds of

00:06:03,600 --> 00:06:06,800
stuff

00:06:04,400 --> 00:06:07,840
and mostly we're actually calling and

00:06:06,800 --> 00:06:11,199
branching out

00:06:07,840 --> 00:06:12,080
to the function that is in the function

00:06:11,199 --> 00:06:14,080
pointers

00:06:12,080 --> 00:06:15,919
so that's not very good performance we

00:06:14,080 --> 00:06:16,400
want good performance and it's even

00:06:15,919 --> 00:06:19,520
longer

00:06:16,400 --> 00:06:22,400
as well so no no let's

00:06:19,520 --> 00:06:23,120
let's take this away uh another one is

00:06:22,400 --> 00:06:26,319
extern

00:06:23,120 --> 00:06:27,440
link time binding so uh our library

00:06:26,319 --> 00:06:31,120
doesn't really

00:06:27,440 --> 00:06:33,280
say uh what functions there are there

00:06:31,120 --> 00:06:34,639
you just say like hey there are some

00:06:33,280 --> 00:06:37,440
somewhere over

00:06:34,639 --> 00:06:38,400
i don't know where the linker will will

00:06:37,440 --> 00:06:40,880
figure it out

00:06:38,400 --> 00:06:41,440
and that's also kind of the problem with

00:06:40,880 --> 00:06:43,199
this

00:06:41,440 --> 00:06:45,120
because the linker will have to figure

00:06:43,199 --> 00:06:47,120
it out and if the linker doesn't

00:06:45,120 --> 00:06:48,800
find it or if there's a mistake you will

00:06:47,120 --> 00:06:52,800
get a linker error

00:06:48,800 --> 00:06:53,919
and i've learned that i want to avoid

00:06:52,800 --> 00:06:55,680
linker errors

00:06:53,919 --> 00:06:57,199
as much as i can because they are not

00:06:55,680 --> 00:06:59,120
plasm

00:06:57,199 --> 00:07:02,240
what does the code look like well this

00:06:59,120 --> 00:07:03,039
is the most simple of them all we just

00:07:02,240 --> 00:07:05,840
say hey

00:07:03,039 --> 00:07:06,800
these are extern and then our example is

00:07:05,840 --> 00:07:10,319
pretty much

00:07:06,800 --> 00:07:12,000
the same again to reiterate the example

00:07:10,319 --> 00:07:14,560
is from the library's

00:07:12,000 --> 00:07:14,560
perspective

00:07:15,199 --> 00:07:18,560
so what does it look like well if we

00:07:17,120 --> 00:07:21,039
look at the

00:07:18,560 --> 00:07:23,360
assembly over here the example function

00:07:21,039 --> 00:07:26,560
is pretty good because i've written an

00:07:23,360 --> 00:07:28,800
implementation here and you need to this

00:07:26,560 --> 00:07:31,599
is normally done in another file

00:07:28,800 --> 00:07:32,160
but here on godbolt i've just done it

00:07:31,599 --> 00:07:34,160
over here

00:07:32,160 --> 00:07:37,360
so the example function is pretty

00:07:34,160 --> 00:07:39,440
efficient but we can also see that these

00:07:37,360 --> 00:07:41,039
transfer enable and disable functions

00:07:39,440 --> 00:07:44,160
are now part of the public

00:07:41,039 --> 00:07:46,879
api because well extern

00:07:44,160 --> 00:07:48,800
private doesn't really make much sense

00:07:46,879 --> 00:07:52,080
so that's logical but

00:07:48,800 --> 00:07:55,919
our api is not public and i don't really

00:07:52,080 --> 00:07:58,000
know if that's a good idea so

00:07:55,919 --> 00:07:59,039
throw it away as well now we're going to

00:07:58,000 --> 00:08:01,280
look at the rest what

00:07:59,039 --> 00:08:02,400
if we want both performance and

00:08:01,280 --> 00:08:06,319
usability

00:08:02,400 --> 00:08:08,639
well rust does provide abstract

00:08:06,319 --> 00:08:09,599
interface machinery and we can do it

00:08:08,639 --> 00:08:12,800
with generics

00:08:09,599 --> 00:08:16,800
and traits and actually

00:08:12,800 --> 00:08:18,800
if we use trades we get more usability

00:08:16,800 --> 00:08:21,120
than c could ever offer us

00:08:18,800 --> 00:08:23,039
because we can reuse trades from the

00:08:21,120 --> 00:08:26,720
embedded hull

00:08:23,039 --> 00:08:29,759
so if we want to implement spi

00:08:26,720 --> 00:08:30,639
we just take the spi trade from the

00:08:29,759 --> 00:08:33,360
embedded hall

00:08:30,639 --> 00:08:34,320
and any platform that implements that

00:08:33,360 --> 00:08:37,519
can just

00:08:34,320 --> 00:08:39,360
plug it in to our library and nobody

00:08:37,519 --> 00:08:43,039
needs to implement anything

00:08:39,360 --> 00:08:46,560
so that's a huge plus but for now

00:08:43,039 --> 00:08:48,770
we'll stick to our own interface

00:08:46,560 --> 00:08:50,000
and what i've also done

00:08:48,770 --> 00:08:53,600
[Music]

00:08:50,000 --> 00:08:57,120
is using a struct to implement it in

00:08:53,600 --> 00:08:58,399
because i don't want to use dynamic

00:08:57,120 --> 00:09:01,680
dispatch i want to use

00:08:58,399 --> 00:09:04,560
generics for the performance so my

00:09:01,680 --> 00:09:05,680
device here contains the interface and

00:09:04,560 --> 00:09:08,959
the interface is just

00:09:05,680 --> 00:09:11,360
the three functions that we saw and see

00:09:08,959 --> 00:09:11,360
as well

00:09:11,600 --> 00:09:15,760
so we've got a constructor for the

00:09:13,519 --> 00:09:18,959
device and our example

00:09:15,760 --> 00:09:22,160
now goes through self. interface but

00:09:18,959 --> 00:09:22,959
all the functions are the same and if we

00:09:22,160 --> 00:09:25,680
look

00:09:22,959 --> 00:09:28,720
at the assembly i hope everything is big

00:09:25,680 --> 00:09:31,279
enough because there's a lot of code

00:09:28,720 --> 00:09:33,440
but we can look over here and i had to

00:09:31,279 --> 00:09:33,920
trick godbolt into showing the assembly

00:09:33,440 --> 00:09:36,640
but

00:09:33,920 --> 00:09:37,839
it's all exactly the same just move

00:09:36,640 --> 00:09:41,440
instructions

00:09:37,839 --> 00:09:41,920
that's it and uh the spi implementation

00:09:41,440 --> 00:09:45,519
here

00:09:41,920 --> 00:09:48,240
can be part of the public api uh but you

00:09:45,519 --> 00:09:49,279
need an instance for this so that's

00:09:48,240 --> 00:09:51,680
that's fine

00:09:49,279 --> 00:09:52,800
so this is what our hardware interface

00:09:51,680 --> 00:09:55,680
looks like

00:09:52,800 --> 00:09:57,440
um now let's look at our software

00:09:55,680 --> 00:10:00,959
interface

00:09:57,440 --> 00:10:05,040
and the software interface is more about

00:10:00,959 --> 00:10:08,640
how do we talk to the library

00:10:05,040 --> 00:10:12,320
instead of to the hardware and you can

00:10:08,640 --> 00:10:13,440
split this up in a two kind of levels

00:10:12,320 --> 00:10:16,640
namely low level

00:10:13,440 --> 00:10:20,399
and high level low level is more about

00:10:16,640 --> 00:10:23,519
hey how do we talk to the hardware

00:10:20,399 --> 00:10:26,800
what are the registers or commands the

00:10:23,519 --> 00:10:28,000
the chip has and if you want to make a

00:10:26,800 --> 00:10:29,839
library

00:10:28,000 --> 00:10:32,959
this is pretty much the minimal

00:10:29,839 --> 00:10:34,800
implementation you can get away with

00:10:32,959 --> 00:10:37,279
but if you want to make a really good

00:10:34,800 --> 00:10:40,480
library you also want a

00:10:37,279 --> 00:10:43,360
high level part

00:10:40,480 --> 00:10:45,519
and at the high level does not concern

00:10:43,360 --> 00:10:48,079
itself really with the hardware but with

00:10:45,519 --> 00:10:52,320
the registers themselves already

00:10:48,079 --> 00:10:54,240
and abstraction and instead of saying

00:10:52,320 --> 00:10:55,600
like the low level does instead of

00:10:54,240 --> 00:10:59,760
saying

00:10:55,600 --> 00:11:04,079
hey i want to set register 12

00:10:59,760 --> 00:11:07,519
bit 3 to 1 no we want to say hey

00:11:04,079 --> 00:11:08,079
i want to reset the chip and then you

00:11:07,519 --> 00:11:09,519
will

00:11:08,079 --> 00:11:11,120
then there's a function that will just

00:11:09,519 --> 00:11:13,920
do it so that's the

00:11:11,120 --> 00:11:15,600
full implementation now during this talk

00:11:13,920 --> 00:11:19,440
i'm gonna mainly talk about

00:11:15,600 --> 00:11:21,519
uh the low level uh side of things

00:11:19,440 --> 00:11:23,600
but uh you can do a lot of things in

00:11:21,519 --> 00:11:26,720
high level as well

00:11:23,600 --> 00:11:30,079
but yeah time

00:11:26,720 --> 00:11:34,320
so this is our uh imaginary device uh

00:11:30,079 --> 00:11:37,360
it's a gpio expander it runs over spi

00:11:34,320 --> 00:11:40,320
it has six registers of each one byte

00:11:37,360 --> 00:11:40,640
and we want to do the following thing

00:11:40,320 --> 00:11:43,279
with

00:11:40,640 --> 00:11:44,880
it just as an example if the

00:11:43,279 --> 00:11:49,519
manufacturer id

00:11:44,880 --> 00:11:52,320
is not 0 then we must set pin 7 high

00:11:49,519 --> 00:11:53,519
it's pretty easy we need to read we need

00:11:52,320 --> 00:11:56,639
to write something

00:11:53,519 --> 00:11:57,600
it's a pretty good example i don't know

00:11:56,639 --> 00:12:00,880
if a mage mark

00:11:57,600 --> 00:12:04,079
makes much sense but yeah so

00:12:00,880 --> 00:12:07,839
here's what you would do in c

00:12:04,079 --> 00:12:10,560
you would generally

00:12:07,839 --> 00:12:11,040
define the register definitions with

00:12:10,560 --> 00:12:14,560
either

00:12:11,040 --> 00:12:17,680
an enum or macro defines

00:12:14,560 --> 00:12:20,720
and then you'd provide some functions to

00:12:17,680 --> 00:12:23,200
write and read those registers

00:12:20,720 --> 00:12:25,040
and the only thing you really have are

00:12:23,200 --> 00:12:28,160
the raw words you say hey

00:12:25,040 --> 00:12:31,519
to register 12 write

00:12:28,160 --> 00:12:34,320
15 something like that

00:12:31,519 --> 00:12:35,040
and to use those raw words maybe there

00:12:34,320 --> 00:12:39,120
are some

00:12:35,040 --> 00:12:42,880
helper macros to set and read the bits

00:12:39,120 --> 00:12:45,920
but that's not even always the case so

00:12:42,880 --> 00:12:48,639
here's my example at the top here we've

00:12:45,920 --> 00:12:52,800
got our register definitions i've put it

00:12:48,639 --> 00:12:56,240
in an enum for our manufacturer

00:12:52,800 --> 00:12:57,360
i've provided some masks and a position

00:12:56,240 --> 00:13:00,399
to set our bits

00:12:57,360 --> 00:13:02,320
and and read it out and then we've got

00:13:00,399 --> 00:13:05,440
our

00:13:02,320 --> 00:13:07,279
read and write registers and

00:13:05,440 --> 00:13:09,120
for now apparently for my imaginary

00:13:07,279 --> 00:13:10,639
device this is the way to read it and

00:13:09,120 --> 00:13:13,680
this is the way to

00:13:10,639 --> 00:13:16,079
write to it you transfer the address

00:13:13,680 --> 00:13:17,839
and then transfer zero and you get the

00:13:16,079 --> 00:13:20,320
result or

00:13:17,839 --> 00:13:22,800
you transfer the actual value you want

00:13:20,320 --> 00:13:22,800
to write

00:13:23,040 --> 00:13:28,639
and in our example code here we first

00:13:26,560 --> 00:13:32,959
want to read the manufacturer id

00:13:28,639 --> 00:13:35,680
so we read register the id register

00:13:32,959 --> 00:13:37,360
we and it with the manufacturer mask

00:13:35,680 --> 00:13:39,519
that i've defined up here

00:13:37,360 --> 00:13:41,120
and then we bit shift it with the amount

00:13:39,519 --> 00:13:44,000
of positions here

00:13:41,120 --> 00:13:46,880
and if it's not 0 then we want to read

00:13:44,000 --> 00:13:50,560
the port register

00:13:46,880 --> 00:13:53,760
we want to enable the seventh

00:13:50,560 --> 00:13:57,199
or rather eighth um gpio pin

00:13:53,760 --> 00:14:01,360
so we set the the the biggest

00:13:57,199 --> 00:14:03,600
bit and then we write back the register

00:14:01,360 --> 00:14:04,880
so it's pretty straightforward but it's

00:14:03,600 --> 00:14:08,000
not really

00:14:04,880 --> 00:14:10,240
well the api is not really that nice but

00:14:08,000 --> 00:14:11,040
if we look at the assembly the assembly

00:14:10,240 --> 00:14:14,639
is like

00:14:11,040 --> 00:14:17,199
perfect if you had written this by hand

00:14:14,639 --> 00:14:18,240
it wouldn't look much different well

00:14:17,199 --> 00:14:21,040
except for the

00:14:18,240 --> 00:14:22,560
numbers maybe um but we just move move

00:14:21,040 --> 00:14:24,160
move with move

00:14:22,560 --> 00:14:26,399
so that's pretty efficient we do a

00:14:24,160 --> 00:14:26,800
comparing the jump oh hey that sounds

00:14:26,399 --> 00:14:30,000
like

00:14:26,800 --> 00:14:33,839
an if statement we compare

00:14:30,000 --> 00:14:36,639
and we maybe we jump uh

00:14:33,839 --> 00:14:37,600
but we do more moves we do an ore that's

00:14:36,639 --> 00:14:40,880
this or

00:14:37,600 --> 00:14:44,079
more moves and then return so this is as

00:14:40,880 --> 00:14:47,920
efficient as it can be but this

00:14:44,079 --> 00:14:48,959
api is i don't i don't really like it

00:14:47,920 --> 00:14:50,959
because we

00:14:48,959 --> 00:14:53,839
we need to do the mask ourselves we need

00:14:50,959 --> 00:14:56,000
to do bit shifts

00:14:53,839 --> 00:14:57,360
we need to create a temporary register

00:14:56,000 --> 00:15:01,760
here

00:14:57,360 --> 00:15:04,160
it works but i think we can do better

00:15:01,760 --> 00:15:05,600
and some of the things can already be

00:15:04,160 --> 00:15:08,399
better

00:15:05,600 --> 00:15:10,160
if we do it in rust because i almost

00:15:08,399 --> 00:15:13,120
forgot

00:15:10,160 --> 00:15:14,320
this register here this address the only

00:15:13,120 --> 00:15:17,839
valid values

00:15:14,320 --> 00:15:21,360
are one through six but

00:15:17,839 --> 00:15:25,199
c doesn't stop us from just plugging in

00:15:21,360 --> 00:15:26,320
seven or a hundred and what happens then

00:15:25,199 --> 00:15:30,079
well

00:15:26,320 --> 00:15:30,560
i don't know um but it's probably not

00:15:30,079 --> 00:15:33,040
good

00:15:30,560 --> 00:15:34,079
but c will just allow you and we can fix

00:15:33,040 --> 00:15:37,360
that

00:15:34,079 --> 00:15:41,600
by doing it in rust so we

00:15:37,360 --> 00:15:44,399
actually use a proper rust enum

00:15:41,600 --> 00:15:45,600
and if you plug in any other value then

00:15:44,399 --> 00:15:48,639
the rust will give

00:15:45,600 --> 00:15:50,800
a compiler error so

00:15:48,639 --> 00:15:53,519
everything else is still pretty much the

00:15:50,800 --> 00:15:56,639
same we've got our device struct

00:15:53,519 --> 00:15:57,360
constructor and then we implement read

00:15:56,639 --> 00:16:00,399
register

00:15:57,360 --> 00:16:01,040
and write register and they do pretty

00:16:00,399 --> 00:16:04,320
much

00:16:01,040 --> 00:16:06,480
the same and in our example code we say

00:16:04,320 --> 00:16:07,759
hey we've got our device based on our

00:16:06,480 --> 00:16:10,959
sbi

00:16:07,759 --> 00:16:14,079
we read the manufacturer we mask it

00:16:10,959 --> 00:16:16,399
we bit shift it if the manufacturer is

00:16:14,079 --> 00:16:19,519
not equal to zero

00:16:16,399 --> 00:16:21,680
well everything really looks

00:16:19,519 --> 00:16:22,800
the same but at least it's a little bit

00:16:21,680 --> 00:16:27,600
safer because we

00:16:22,800 --> 00:16:30,639
now use a proper enum for it

00:16:27,600 --> 00:16:31,279
and the assembly the output is still

00:16:30,639 --> 00:16:33,800
just as

00:16:31,279 --> 00:16:34,959
efficient this is literally the same

00:16:33,800 --> 00:16:38,800
output

00:16:34,959 --> 00:16:39,759
um so yeah but we still got the problems

00:16:38,800 --> 00:16:44,240
that we need to

00:16:39,759 --> 00:16:47,440
mask and shift and create this temporary

00:16:44,240 --> 00:16:49,440
we can do better than the rest

00:16:47,440 --> 00:16:51,440
we can make it type safe we can use

00:16:49,440 --> 00:16:54,160
types to do everything

00:16:51,440 --> 00:16:55,199
because if you think about it every

00:16:54,160 --> 00:16:58,079
register is

00:16:55,199 --> 00:16:58,639
actually different because you've got an

00:16:58,079 --> 00:17:00,880
id

00:16:58,639 --> 00:17:03,040
and a port and the port controls pins

00:17:00,880 --> 00:17:05,520
and the id just has some

00:17:03,040 --> 00:17:06,720
id values those are different so why are

00:17:05,520 --> 00:17:10,240
we using

00:17:06,720 --> 00:17:13,360
a u8 or a char for all of them

00:17:10,240 --> 00:17:14,240
what if we create more types to

00:17:13,360 --> 00:17:17,520
represent

00:17:14,240 --> 00:17:18,640
the registers

00:17:17,520 --> 00:17:21,039
because right now the burden of

00:17:18,640 --> 00:17:22,959
correctness is on the user instead of

00:17:21,039 --> 00:17:24,880
the library writer

00:17:22,959 --> 00:17:26,480
while the library writer probably has

00:17:24,880 --> 00:17:30,480
more knowledge about it

00:17:26,480 --> 00:17:33,520
so we want to improve that

00:17:30,480 --> 00:17:35,760
so uh we can you we can make it both

00:17:33,520 --> 00:17:37,919
easier and correct by default because we

00:17:35,760 --> 00:17:41,039
have a good example of where it's done

00:17:37,919 --> 00:17:44,160
already namely the pack crates uh

00:17:41,039 --> 00:17:46,880
they have a pretty good api which is all

00:17:44,160 --> 00:17:47,280
which is also very efficient so let's

00:17:46,880 --> 00:17:48,880
use

00:17:47,280 --> 00:17:51,760
that as an inspiration and make

00:17:48,880 --> 00:17:51,760
something similar

00:17:51,840 --> 00:17:59,600
so we want to define our registers in

00:17:55,039 --> 00:18:02,400
some way so on our device

00:17:59,600 --> 00:18:03,039
we have the implementation here and what

00:18:02,400 --> 00:18:06,240
we'll do

00:18:03,039 --> 00:18:09,600
is for every register we'll have a

00:18:06,240 --> 00:18:11,520
function so for now i'm only

00:18:09,600 --> 00:18:14,880
implementing the two registers

00:18:11,520 --> 00:18:16,400
we really need for our example but we've

00:18:14,880 --> 00:18:19,679
got the id register

00:18:16,400 --> 00:18:23,200
and the port register and what they do

00:18:19,679 --> 00:18:27,280
is they return a register accessor

00:18:23,200 --> 00:18:30,000
and this is the trick we will use

00:18:27,280 --> 00:18:30,720
um the register accessor borrows the

00:18:30,000 --> 00:18:34,160
interface

00:18:30,720 --> 00:18:37,440
so you get the object back which borrows

00:18:34,160 --> 00:18:37,919
like uh yeah the interface so you can't

00:18:37,440 --> 00:18:40,840
use

00:18:37,919 --> 00:18:42,640
the device until you've dealt with the

00:18:40,840 --> 00:18:45,840
register

00:18:42,640 --> 00:18:48,799
and we use generics to wrap

00:18:45,840 --> 00:18:49,440
the r and w value around it so what are

00:18:48,799 --> 00:18:52,720
the

00:18:49,440 --> 00:18:55,760
w and r value well we've got still

00:18:52,720 --> 00:18:59,440
underneath our raw register

00:18:55,760 --> 00:19:00,240
words but we want to make a type save so

00:18:59,440 --> 00:19:04,080
we

00:19:00,240 --> 00:19:07,919
wrap around it a new type that

00:19:04,080 --> 00:19:08,720
pulls out all the data we need in a way

00:19:07,919 --> 00:19:12,320
we want

00:19:08,720 --> 00:19:14,480
or write it back and

00:19:12,320 --> 00:19:15,600
what does that look like so for example

00:19:14,480 --> 00:19:18,720
if we want to

00:19:15,600 --> 00:19:22,080
do it for the id register

00:19:18,720 --> 00:19:25,200
well i've decided that the id register

00:19:22,080 --> 00:19:28,320
is only so

00:19:25,200 --> 00:19:31,200
we only create an r struct

00:19:28,320 --> 00:19:32,559
and it's around a u8 which is our our

00:19:31,200 --> 00:19:35,120
word

00:19:32,559 --> 00:19:36,240
now our manufacturer number is now a

00:19:35,120 --> 00:19:39,440
function

00:19:36,240 --> 00:19:41,200
and the masking is done uh

00:19:39,440 --> 00:19:42,720
right in the function we just get the u8

00:19:41,200 --> 00:19:44,240
back and

00:19:42,720 --> 00:19:45,919
apparently there's a version field as

00:19:44,240 --> 00:19:49,280
well which get masks

00:19:45,919 --> 00:19:51,840
and uh returned and

00:19:49,280 --> 00:19:53,919
in our register accessor we have a

00:19:51,840 --> 00:19:57,440
specific implementation for

00:19:53,919 --> 00:20:00,000
our read wrapper and our

00:19:57,440 --> 00:20:01,919
right well which is unit because it

00:20:00,000 --> 00:20:05,360
doesn't exist

00:20:01,919 --> 00:20:08,720
so we implement the read function

00:20:05,360 --> 00:20:11,840
which is just the same we plug in the

00:20:08,720 --> 00:20:13,840
address over here and then we return

00:20:11,840 --> 00:20:16,159
the value we get from the hardware

00:20:13,840 --> 00:20:19,280
interface and wrap it inside our

00:20:16,159 --> 00:20:21,590
r struct

00:20:19,280 --> 00:20:22,720
and we can do the same for the port

00:20:21,590 --> 00:20:26,799
[Applause]

00:20:22,720 --> 00:20:29,840
here at the right is the actual code for

00:20:26,799 --> 00:20:33,520
enabling all the pins and reading

00:20:29,840 --> 00:20:37,520
the enable status and then we can read

00:20:33,520 --> 00:20:40,400
write and modify it and this

00:20:37,520 --> 00:20:42,080
this api works pretty much the same as

00:20:40,400 --> 00:20:45,440
in the back crates

00:20:42,080 --> 00:20:45,440
namely in the right

00:20:46,880 --> 00:20:51,280
and the right function you give it a

00:20:49,919 --> 00:20:54,960
closure

00:20:51,280 --> 00:20:54,960
and for the modify as well

00:20:55,200 --> 00:21:02,559
so actually that's it

00:20:58,799 --> 00:21:05,200
so what does the api now look like well

00:21:02,559 --> 00:21:07,200
if we want to get the manufacturer we

00:21:05,200 --> 00:21:10,080
just say hey device

00:21:07,200 --> 00:21:10,480
i want to access the id register and i

00:21:10,080 --> 00:21:12,960
want to

00:21:10,480 --> 00:21:15,200
read it and then i want to read the

00:21:12,960 --> 00:21:17,520
manufacturer field

00:21:15,200 --> 00:21:20,000
so we just get it then if the

00:21:17,520 --> 00:21:22,480
manufacturer is not zero

00:21:20,000 --> 00:21:23,600
the device we want to access the port

00:21:22,480 --> 00:21:26,240
register

00:21:23,600 --> 00:21:27,039
we want to modify the port register and

00:21:26,240 --> 00:21:31,039
what we do

00:21:27,039 --> 00:21:34,799
is our right object we want to enable

00:21:31,039 --> 00:21:38,240
the 7th or again 8th

00:21:34,799 --> 00:21:41,520
gpio because we set it to true

00:21:38,240 --> 00:21:44,559
that's it so now we've got a

00:21:41,520 --> 00:21:47,039
a pretty good api

00:21:44,559 --> 00:21:48,320
if you ask me that doesn't allow for

00:21:47,039 --> 00:21:52,880
mistakes because

00:21:48,320 --> 00:21:56,640
all the shifting and masking is done

00:21:52,880 --> 00:21:59,360
underneath this but how

00:21:56,640 --> 00:22:00,080
efficient is this because well a nicer

00:21:59,360 --> 00:22:02,400
api

00:22:00,080 --> 00:22:04,080
it's higher level it's got to be more

00:22:02,400 --> 00:22:07,679
inefficient right well

00:22:04,080 --> 00:22:09,200
the answer is no the assembly is exactly

00:22:07,679 --> 00:22:13,039
the same

00:22:09,200 --> 00:22:15,760
which is i think like amazing

00:22:13,039 --> 00:22:16,080
uh it's exactly the same while the api

00:22:15,760 --> 00:22:19,440
is

00:22:16,080 --> 00:22:22,080
a lot nicer so um

00:22:19,440 --> 00:22:23,360
you can go a lot further with this but i

00:22:22,080 --> 00:22:25,280
haven't got time to

00:22:23,360 --> 00:22:27,919
really show you how to implement it but

00:22:25,280 --> 00:22:31,679
i can show you a practical example

00:22:27,919 --> 00:22:35,840
of where i've implemented this myself

00:22:31,679 --> 00:22:35,840
and it's here

00:22:36,080 --> 00:22:40,320
this is what i've written for my job and

00:22:38,960 --> 00:22:43,360
um

00:22:40,320 --> 00:22:46,320
i got permission to show it to you and

00:22:43,360 --> 00:22:47,039
this is basically the same api but a

00:22:46,320 --> 00:22:50,559
little bit more

00:22:47,039 --> 00:22:51,280
extended and it's wrapped inside a macro

00:22:50,559 --> 00:22:54,080
to

00:22:51,280 --> 00:22:55,360
easily implement all the registers so

00:22:54,080 --> 00:22:58,240
i've got my

00:22:55,360 --> 00:23:00,240
ll device low level device and then i

00:22:58,240 --> 00:23:02,480
implement all the registers so i've got

00:23:00,240 --> 00:23:05,760
the bmcr register

00:23:02,480 --> 00:23:07,520
this is the address it is read write

00:23:05,760 --> 00:23:10,080
and these are all the fields that are in

00:23:07,520 --> 00:23:14,240
here and i can just specify

00:23:10,080 --> 00:23:15,919
at which bits they are

00:23:14,240 --> 00:23:17,360
now this register isn't really

00:23:15,919 --> 00:23:21,760
interesting but if i go

00:23:17,360 --> 00:23:23,520
down i need to look for it a little bit

00:23:21,760 --> 00:23:27,919
that's a good register

00:23:23,520 --> 00:23:32,000
for example here so we see that

00:23:27,919 --> 00:23:35,600
in the var control register

00:23:32,000 --> 00:23:39,200
we've got the var timer and it

00:23:35,600 --> 00:23:41,679
takes two bits of

00:23:39,200 --> 00:23:44,240
of width but it doesn't really turn a

00:23:41,679 --> 00:23:45,120
bit no it returns a variance computation

00:23:44,240 --> 00:23:48,799
timer

00:23:45,120 --> 00:23:52,240
which is just an enum over here

00:23:48,799 --> 00:23:55,600
because i don't want to deal with

00:23:52,240 --> 00:23:56,000
the register being 0 1 2 or 3 no i'm on

00:23:55,600 --> 00:23:59,279
00:23:56,000 --> 00:24:01,039
no is it well it isn't properly

00:23:59,279 --> 00:24:04,159
documented but

00:24:01,039 --> 00:24:06,080
2 milliseconds 4 milliseconds 6 or eight

00:24:04,159 --> 00:24:08,159
which i think is a lot better than zero

00:24:06,080 --> 00:24:10,720
one two three

00:24:08,159 --> 00:24:11,600
um and there are other examples here as

00:24:10,720 --> 00:24:15,120
well

00:24:11,600 --> 00:24:18,480
um can i find them where are you

00:24:15,120 --> 00:24:21,770
or here for example so we've got the

00:24:18,480 --> 00:24:23,360
three bits over here ptp trigger number

00:24:21,770 --> 00:24:25,919
[Music]

00:24:23,360 --> 00:24:27,279
yeah so these are a lot of registers

00:24:25,919 --> 00:24:29,600
which is why i

00:24:27,279 --> 00:24:31,039
created this macro to implement

00:24:29,600 --> 00:24:33,840
implement it all

00:24:31,039 --> 00:24:35,120
for example here event capture it can be

00:24:33,840 --> 00:24:36,880
zero or one

00:24:35,120 --> 00:24:39,120
but i don't want to know if it's zero or

00:24:36,880 --> 00:24:40,559
one i want to know if it's falling or

00:24:39,120 --> 00:24:44,720
rising

00:24:40,559 --> 00:24:45,200
and yeah so this is the low level api

00:24:44,720 --> 00:24:47,279
but

00:24:45,200 --> 00:24:49,039
what does a high level look like or

00:24:47,279 --> 00:24:51,520
what's possible well i've talked about

00:24:49,039 --> 00:24:54,880
the reset function

00:24:51,520 --> 00:24:59,360
we need to set the reset bit within bmcr

00:24:54,880 --> 00:25:01,919
so we go through self low level device

00:24:59,360 --> 00:25:03,520
bmcr register we want to modify it and

00:25:01,919 --> 00:25:07,120
we want to

00:25:03,520 --> 00:25:10,000
take the reset field and set the bit

00:25:07,120 --> 00:25:11,440
but like you can see here there's a lot

00:25:10,000 --> 00:25:12,840
of documentation here that comes

00:25:11,440 --> 00:25:15,919
straight from the

00:25:12,840 --> 00:25:18,640
datasheet so if i hover over this

00:25:15,919 --> 00:25:19,760
i can just see the documentation that's

00:25:18,640 --> 00:25:21,840
part of this

00:25:19,760 --> 00:25:23,120
this bit which is self-clearing returns

00:25:21,840 --> 00:25:26,159
a value of 1

00:25:23,120 --> 00:25:28,000
until the reset process is complete so

00:25:26,159 --> 00:25:29,679
if i want to know that the reset process

00:25:28,000 --> 00:25:32,400
is complete i need to

00:25:29,679 --> 00:25:33,279
keep checking it so i'll do that within

00:25:32,400 --> 00:25:36,159
the while loop

00:25:33,279 --> 00:25:37,200
haven't had to access the data sheet for

00:25:36,159 --> 00:25:40,240
this

00:25:37,200 --> 00:25:43,679
which is pretty good i think

00:25:40,240 --> 00:25:47,039
and there's also another benefit namely

00:25:43,679 --> 00:25:49,520
documentation uh this is the generated

00:25:47,039 --> 00:25:52,960
documentation for this

00:25:49,520 --> 00:25:55,760
and if i go to the low level well

00:25:52,960 --> 00:25:56,000
well here are all the registers and i

00:25:55,760 --> 00:25:59,279
can

00:25:56,000 --> 00:26:01,919
just pick one no they all

00:25:59,279 --> 00:26:02,880
are small and then go to the reader and

00:26:01,919 --> 00:26:06,720
i can just

00:26:02,880 --> 00:26:09,360
read or yeah what fields are in here

00:26:06,720 --> 00:26:10,640
i can read what the register is for so

00:26:09,360 --> 00:26:13,760
all the documentation

00:26:10,640 --> 00:26:16,799
is now part of my rust documentation

00:26:13,760 --> 00:26:20,000
which i think is fantastic

00:26:16,799 --> 00:26:22,080
um let's go back yes

00:26:20,000 --> 00:26:24,000
so i'm almost done this is the

00:26:22,080 --> 00:26:26,880
conclusion

00:26:24,000 --> 00:26:28,880
the api i've described is i think pretty

00:26:26,880 --> 00:26:29,600
good and we can even use macros to make

00:26:28,880 --> 00:26:33,600
our lives

00:26:29,600 --> 00:26:36,159
even easier for implementing it but

00:26:33,600 --> 00:26:37,360
compared to the more c-like type the

00:26:36,159 --> 00:26:39,760
compile times are

00:26:37,360 --> 00:26:41,039
longer because because we use generics

00:26:39,760 --> 00:26:44,000
and macros

00:26:41,039 --> 00:26:44,960
um yeah that's that's just one of the

00:26:44,000 --> 00:26:47,919
costs

00:26:44,960 --> 00:26:48,400
um maybe we can even generate it from a

00:26:47,919 --> 00:26:50,880
file

00:26:48,400 --> 00:26:53,600
so we maybe we don't want to do it in

00:26:50,880 --> 00:26:57,279
macros but maybe from a file because the

00:26:53,600 --> 00:26:57,919
pack crates also do it from the svd

00:26:57,279 --> 00:27:02,159
files

00:26:57,919 --> 00:27:02,159
that are part of the

00:27:02,799 --> 00:27:06,159
which go alongside the microcontrollers

00:27:04,960 --> 00:27:09,279
therefore

00:27:06,159 --> 00:27:11,520
so maybe that's a good idea

00:27:09,279 --> 00:27:12,799
and a lot can be done in the high level

00:27:11,520 --> 00:27:14,720
part as well

00:27:12,799 --> 00:27:16,799
i've shown you the reset function which

00:27:14,720 --> 00:27:18,640
is pretty easy but you can also use a

00:27:16,799 --> 00:27:19,840
lot of type state there because there is

00:27:18,640 --> 00:27:23,039
the

00:27:19,840 --> 00:27:26,159
crate which is a radio chip

00:27:23,039 --> 00:27:29,520
and it uses type state to manage

00:27:26,159 --> 00:27:31,840
when the radio is sending receiving or

00:27:29,520 --> 00:27:31,840
idle

00:27:32,399 --> 00:27:36,159
so yeah a lot a lot more can be said and

00:27:35,279 --> 00:27:39,360
discussed

00:27:36,159 --> 00:27:40,159
um and i hope to see some questions and

00:27:39,360 --> 00:27:43,120
discussion in

00:27:40,159 --> 00:27:43,919
in the chat uh but for now i want to

00:27:43,120 --> 00:27:47,120
throw up

00:27:43,919 --> 00:27:51,120
a ball maybe maybe we can

00:27:47,120 --> 00:27:53,520
create a unified device crate which

00:27:51,120 --> 00:27:54,480
maybe makes it easier to implement a

00:27:53,520 --> 00:27:57,679
good api

00:27:54,480 --> 00:27:58,240
like the one i've showed you maybe we

00:27:57,679 --> 00:28:02,159
can

00:27:58,240 --> 00:28:02,880
have traits for a general a device trade

00:28:02,159 --> 00:28:05,919
for

00:28:02,880 --> 00:28:09,120
which manages a power up reset maybe

00:28:05,919 --> 00:28:12,320
sleep access to the api

00:28:09,120 --> 00:28:12,960
um maybe that's a good idea that some of

00:28:12,320 --> 00:28:16,640
you would

00:28:12,960 --> 00:28:17,440
like to see so we can maybe discuss

00:28:16,640 --> 00:28:20,720
about that

00:28:17,440 --> 00:28:21,360
and with that that's the end i hope i'm

00:28:20,720 --> 00:28:24,640
not

00:28:21,360 --> 00:28:25,360
too much over time so thanks for

00:28:24,640 --> 00:28:29,279
watching

00:28:25,360 --> 00:28:29,279
and i'd love to answer any

00:28:29,520 --> 00:28:32,720
all questions we're running ahead of

00:28:30,559 --> 00:28:34,159
time anyways um

00:28:32,720 --> 00:28:36,480
there's a number of questions in the

00:28:34,159 --> 00:28:38,240
channel and uh definitely good feedback

00:28:36,480 --> 00:28:40,720
but here's just the questions

00:28:38,240 --> 00:28:42,640
um are you planning to open source your

00:28:40,720 --> 00:28:44,960
register creation macro this is actually

00:28:42,640 --> 00:28:48,159
a question by james

00:28:44,960 --> 00:28:51,279
um well it's written for my job

00:28:48,159 --> 00:28:52,399
i got permission to show it but my

00:28:51,279 --> 00:28:55,919
company is

00:28:52,399 --> 00:28:59,360
sadly not really into open source

00:28:55,919 --> 00:29:01,919
but um yeah if there's interest

00:28:59,360 --> 00:29:02,640
i may be willing to do something in my

00:29:01,919 --> 00:29:04,640
uh

00:29:02,640 --> 00:29:06,240
free time to to set something up if

00:29:04,640 --> 00:29:09,840
there's interest yeah

00:29:06,240 --> 00:29:13,600
okay thank you um another question

00:29:09,840 --> 00:29:16,159
um how slow is this in debug mode

00:29:13,600 --> 00:29:18,320
um i presume it is like pax where it is

00:29:16,159 --> 00:29:22,000
much slower

00:29:18,320 --> 00:29:26,240
um yeah i've not tested it for

00:29:22,000 --> 00:29:28,559
this right now uh but the benefits

00:29:26,240 --> 00:29:29,360
or one of the things you can do in cargo

00:29:28,559 --> 00:29:32,799
is you can

00:29:29,360 --> 00:29:34,720
selectively optimize separate libraries

00:29:32,799 --> 00:29:37,279
so if it's a separate library you can

00:29:34,720 --> 00:29:39,600
just enable the optimizations there

00:29:37,279 --> 00:29:41,120
and then you won't get slowed down as

00:29:39,600 --> 00:29:43,200
much

00:29:41,120 --> 00:29:44,480
but yeah it's definitely a bit slower

00:29:43,200 --> 00:29:48,480
yeah

00:29:44,480 --> 00:29:50,159
okay um one other question

00:29:48,480 --> 00:29:51,679
how does error handling regarding the

00:29:50,159 --> 00:29:56,159
underlying peripherals

00:29:51,679 --> 00:30:00,159
for example i2c bus errors work out here

00:29:56,159 --> 00:30:03,200
well in my um in my practical example

00:30:00,159 --> 00:30:06,640
i've dealt with it that you whenever you

00:30:03,200 --> 00:30:09,039
read you get an error back

00:30:06,640 --> 00:30:10,640
so you need to do a question mark behind

00:30:09,039 --> 00:30:14,000
it well if you want

00:30:10,640 --> 00:30:17,840
and every time you actually read a

00:30:14,000 --> 00:30:20,080
field when you read a an enum back

00:30:17,840 --> 00:30:20,960
that can also go wrong because maybe it

00:30:20,080 --> 00:30:23,120
uh

00:30:20,960 --> 00:30:24,240
it hands you back the number 12 but your

00:30:23,120 --> 00:30:26,640
enums does

00:30:24,240 --> 00:30:27,279
don't expect that so every time you read

00:30:26,640 --> 00:30:30,399
that

00:30:27,279 --> 00:30:32,000
you also get a result type so it just

00:30:30,399 --> 00:30:35,360
works with result types

00:30:32,000 --> 00:30:38,880
but that's you can really plug that in

00:30:35,360 --> 00:30:42,640
that's doable yeah okay

00:30:38,880 --> 00:30:46,799
and then there's uh one other question

00:30:42,640 --> 00:30:50,559
um how is this related to svd to rust

00:30:46,799 --> 00:30:54,799
uh it's not directly related but the api

00:30:50,559 --> 00:30:57,519
is very similar the ideas behind it are

00:30:54,799 --> 00:30:59,679
well yeah similar so that's the only

00:30:57,519 --> 00:31:03,279
connection really

00:30:59,679 --> 00:31:04,799
okay yeah

00:31:03,279 --> 00:31:06,480
that's all the questions there has been

00:31:04,799 --> 00:31:07,440
a lot of discussion in the chat i also

00:31:06,480 --> 00:31:10,000
want to

00:31:07,440 --> 00:31:11,919
highlight how people have now gone to

00:31:10,000 --> 00:31:15,600
actually highlight the questions in chat

00:31:11,919 --> 00:31:18,240
by prefixing them while

00:31:15,600 --> 00:31:19,440
having active discussion so i leave you

00:31:18,240 --> 00:31:21,760
to the discussion

00:31:19,440 --> 00:31:22,799
around your subject there's definitely a

00:31:21,760 --> 00:31:25,440
lot

00:31:22,799 --> 00:31:27,039
that you can follow up on and i'm very

00:31:25,440 --> 00:31:30,480
happy that the talks

00:31:27,039 --> 00:31:31,440
turn out to be the conversations go on

00:31:30,480 --> 00:31:34,480
until the next

00:31:31,440 --> 00:31:38,000
one starts so there's always something

00:31:34,480 --> 00:31:39,519
to see during the breaks and yeah

00:31:38,000 --> 00:31:42,960
this is the next one coming up before

00:31:39,519 --> 00:31:42,960
the last talk for this section

00:31:43,279 --> 00:31:47,840

YouTube URL: https://www.youtube.com/watch?v=z9z74VpqO9A


