Title: RTIC: Real Time Interrupt driven Concurrency
Publication date: 2020-11-06
Playlist: Oxidize Global 2020
Description: 
	The use of embedded systems grows at an immense rate with 3 billion+ Cortex-M ARM chips shipped! However, someone has to write the programs that run on all these chips, where the trifecta of safety, performance and ergonomics comes as a wish, while in many applications an MCU hanging or crashing is simply not allowed. Currently the embedded Rust ecosystem provides the necessary foundational crates, but lacks the ergonomics and safe utilization of resources.

This talk aims to show that with Rust and the Real-Time Interrupt-driven Concurrency scheduler we get this trifecta, with how resources, memory safety, deadlock free and data-race free execution that can be guaranteed at compile time, no defining of thread stacks, and keeping the generated binary minimal without losing expressiveness! All built on a sound theoretical foundation of Stack Resource Policy.

ARM has shipped 100+ billion cores - letâ€™s build the next 100+ billion on a strong foundation, ease of use and safe programs!
Captions: 
	00:00:01,770 --> 00:00:36,079
[Music]

00:00:32,800 --> 00:00:37,600
hello back and we're going to continue

00:00:36,079 --> 00:00:41,280
with our next speaker

00:00:37,600 --> 00:00:42,480
emil frisk and emma is going to talk

00:00:41,280 --> 00:00:44,640
about

00:00:42,480 --> 00:00:45,920
arctic real-time interrupt-driven

00:00:44,640 --> 00:00:47,840
concurrency

00:00:45,920 --> 00:00:49,360
previously known as rtfm and i can

00:00:47,840 --> 00:00:51,280
personally share

00:00:49,360 --> 00:00:52,399
i knew always that there was interest in

00:00:51,280 --> 00:00:54,160
the embedded

00:00:52,399 --> 00:00:55,440
uh rust scene and there were always

00:00:54,160 --> 00:00:57,680
hobbies trying it but

00:00:55,440 --> 00:00:58,719
when rtfm showed up that was really the

00:00:57,680 --> 00:01:01,520
point where we're like

00:00:58,719 --> 00:01:03,359
well this is getting serious and i'm

00:01:01,520 --> 00:01:06,320
happy that the project is still around

00:01:03,359 --> 00:01:07,920
and is in industrial use and emel was

00:01:06,320 --> 00:01:10,080
probably the best person to talk about

00:01:07,920 --> 00:01:10,080
that

00:01:10,240 --> 00:01:16,400
yeah thanks let's see is uh

00:01:13,280 --> 00:01:19,439
sound working fine just as a check

00:01:16,400 --> 00:01:20,560
perfect perfect so i welcome you all to

00:01:19,439 --> 00:01:23,759
my presentation

00:01:20,560 --> 00:01:27,360
on arctic and demos around arctic

00:01:23,759 --> 00:01:29,520
so my name is emma fresc i am one of the

00:01:27,360 --> 00:01:30,799
developers of arctic and i've been

00:01:29,520 --> 00:01:32,640
around with the

00:01:30,799 --> 00:01:36,000
since a little bit since the research

00:01:32,640 --> 00:01:39,040
days of this scheduler actually

00:01:36,000 --> 00:01:42,640
and what we're going to see today

00:01:39,040 --> 00:01:45,759
is more or less i want to give you all

00:01:42,640 --> 00:01:47,439
an overview of the arctic scheduler and

00:01:45,759 --> 00:01:50,720
i really want you after this to even be

00:01:47,439 --> 00:01:50,720
able to use it yourselves

00:01:52,159 --> 00:01:55,280
so this is going to be a talk with very

00:01:54,240 --> 00:01:59,280
few slides

00:01:55,280 --> 00:02:02,000
so let's hope everything works fine

00:01:59,280 --> 00:02:04,079
so just to give you a small overview

00:02:02,000 --> 00:02:07,439
what we're going to do here

00:02:04,079 --> 00:02:07,439
so we will start with

00:02:07,520 --> 00:02:12,080
let's say the info sheet of this

00:02:09,679 --> 00:02:14,239
scheduler i mean what does it support

00:02:12,080 --> 00:02:15,840
in the end this is usually what once

00:02:14,239 --> 00:02:17,360
lecture scheduler on

00:02:15,840 --> 00:02:19,120
so we'll start there and then we're

00:02:17,360 --> 00:02:21,680
going to have a lot of demos

00:02:19,120 --> 00:02:23,040
nine in total that i will do live and

00:02:21,680 --> 00:02:26,879
run here

00:02:23,040 --> 00:02:28,720
for you while uh online

00:02:26,879 --> 00:02:30,400
and once we've done this you've got a

00:02:28,720 --> 00:02:32,720
feeling for how this

00:02:30,400 --> 00:02:33,680
looks in code what you can expect a

00:02:32,720 --> 00:02:34,879
little bit at least

00:02:33,680 --> 00:02:39,280
let's see a little bit how it works

00:02:34,879 --> 00:02:41,840
under the hood and finish with that

00:02:39,280 --> 00:02:43,040
so if you start with the let's call it

00:02:41,840 --> 00:02:44,720
the info sheet

00:02:43,040 --> 00:02:46,800
what does this scalder support or what

00:02:44,720 --> 00:02:48,879
are its features

00:02:46,800 --> 00:02:50,640
the first one which is probably the most

00:02:48,879 --> 00:02:53,920
important one that

00:02:50,640 --> 00:02:54,640
people get let's say not hanged up on

00:02:53,920 --> 00:02:56,319
but

00:02:54,640 --> 00:02:57,840
it takes some you're getting used to

00:02:56,319 --> 00:03:00,480
this scheduler

00:02:57,840 --> 00:03:01,280
is based on tasks that run to completion

00:03:00,480 --> 00:03:03,360
or jobs

00:03:01,280 --> 00:03:05,280
one might call it so it's not threads

00:03:03,360 --> 00:03:07,519
where you have infinite loops

00:03:05,280 --> 00:03:08,879
but these tasks they're either event

00:03:07,519 --> 00:03:09,840
triggered which means they're connected

00:03:08,879 --> 00:03:11,840
to hardware

00:03:09,840 --> 00:03:13,360
or they can be spawned on demand through

00:03:11,840 --> 00:03:14,720
software tasks

00:03:13,360 --> 00:03:16,879
it's very important to remember that

00:03:14,720 --> 00:03:18,640
this is run to completion we do not have

00:03:16,879 --> 00:03:21,360
infinite loops

00:03:18,640 --> 00:03:21,360
in the tasks

00:03:22,000 --> 00:03:25,280
arctic supports message passing this is

00:03:24,480 --> 00:03:27,200
quite

00:03:25,280 --> 00:03:29,280
an important feature if you want to make

00:03:27,200 --> 00:03:32,319
any type of system

00:03:29,280 --> 00:03:33,599
so between two tasks or multiple tasks

00:03:32,319 --> 00:03:36,080
you can send messages

00:03:33,599 --> 00:03:36,080
freely

00:03:37,599 --> 00:03:42,400
and a scheduler is not really a

00:03:40,080 --> 00:03:44,480
scheduler unless you can schedule

00:03:42,400 --> 00:03:45,680
so we have support for a timer queue

00:03:44,480 --> 00:03:48,480
which means that you can

00:03:45,680 --> 00:03:49,519
schedule a task to be run sometime in

00:03:48,480 --> 00:03:52,400
the future

00:03:49,519 --> 00:03:54,239
so you can say that task 1 should run in

00:03:52,400 --> 00:03:57,120
200 milliseconds

00:03:54,239 --> 00:03:57,120
or similar

00:03:58,080 --> 00:04:01,760
and another big and very important part

00:04:00,799 --> 00:04:03,840
of

00:04:01,760 --> 00:04:06,319
arctic to understand is that this is a

00:04:03,840 --> 00:04:09,040
preemptive multitasking scheduler

00:04:06,319 --> 00:04:10,239
and not a cooperative multitasking

00:04:09,040 --> 00:04:12,000
scheduler

00:04:10,239 --> 00:04:14,000
that means if you have two tasks running

00:04:12,000 --> 00:04:16,000
at the same priority

00:04:14,000 --> 00:04:17,199
the first task will first finish and

00:04:16,000 --> 00:04:19,359
then the second

00:04:17,199 --> 00:04:21,199
task will run and finish they will not

00:04:19,359 --> 00:04:21,759
do like round robin scheduling or what

00:04:21,199 --> 00:04:25,440
you might be

00:04:21,759 --> 00:04:27,759
used to in some other schedulers

00:04:25,440 --> 00:04:28,560
and when we come to some of the details

00:04:27,759 --> 00:04:31,199
in the end

00:04:28,560 --> 00:04:32,240
we'll see why this is very important and

00:04:31,199 --> 00:04:35,919
why we do not have

00:04:32,240 --> 00:04:35,919
cooperative multitasking as this now

00:04:37,040 --> 00:04:44,479
something that is a very big feature

00:04:40,880 --> 00:04:47,919
is compared to thread-based schedulers

00:04:44,479 --> 00:04:50,880
is that we have

00:04:47,919 --> 00:04:51,759
data race-free memory sharing in this

00:04:50,880 --> 00:04:53,360
system

00:04:51,759 --> 00:04:55,680
you could think of it then well as

00:04:53,360 --> 00:04:57,600
mutexus but the mutica

00:04:55,680 --> 00:04:58,800
mutaxes can never fail they are

00:04:57,600 --> 00:05:02,160
guaranteed to always

00:04:58,800 --> 00:05:04,400
succeed so what we have technically

00:05:02,160 --> 00:05:06,000
are what are called priority-based

00:05:04,400 --> 00:05:08,960
critical sections

00:05:06,000 --> 00:05:10,639
and this makes it extremely efficient in

00:05:08,960 --> 00:05:13,120
this torque cover i will not show the

00:05:10,639 --> 00:05:16,240
machine code that is generated from this

00:05:13,120 --> 00:05:20,720
but taking locks and releasing locks

00:05:16,240 --> 00:05:24,080
in arctic are a few instructions

00:05:20,720 --> 00:05:27,840
and awaiting nothing like that

00:05:24,080 --> 00:05:30,800
and something that i'm very happy

00:05:27,840 --> 00:05:32,720
with this scheduler is that we have

00:05:30,800 --> 00:05:35,600
deadlock free execution

00:05:32,720 --> 00:05:36,000
and this is guaranteed at compile time

00:05:35,600 --> 00:05:37,680
so

00:05:36,000 --> 00:05:39,520
you can never get for example two moot

00:05:37,680 --> 00:05:41,759
access or semaphores

00:05:39,520 --> 00:05:42,720
that get locked on each other or waiting

00:05:41,759 --> 00:05:45,440
on something

00:05:42,720 --> 00:05:48,000
forever this can never happen in this

00:05:45,440 --> 00:05:48,000
scheduler

00:05:48,800 --> 00:05:53,199
and the thing is since this

00:05:52,160 --> 00:05:55,280
how we're going to see in the end is

00:05:53,199 --> 00:05:57,680
that this how this does the scheduling

00:05:55,280 --> 00:05:59,199
we are have extremely low scheduling

00:05:57,680 --> 00:06:01,520
overhead because we are letting the

00:05:59,199 --> 00:06:03,680
hardware do all the scheduling for us

00:06:01,520 --> 00:06:04,560
so in the end there is no scheduler per

00:06:03,680 --> 00:06:06,800
se running

00:06:04,560 --> 00:06:08,479
we're just setting up the hardware to do

00:06:06,800 --> 00:06:10,240
the scheduling for us

00:06:08,479 --> 00:06:11,840
and this is quite an interesting detail

00:06:10,240 --> 00:06:15,280
that turns out to

00:06:11,840 --> 00:06:19,440
make it extremely fast

00:06:15,280 --> 00:06:22,080
and the final one which is nice but um

00:06:19,440 --> 00:06:23,919
also to have let's say if you have

00:06:22,080 --> 00:06:25,840
threads usually set up stacks for each

00:06:23,919 --> 00:06:28,560
thread in a norm or a

00:06:25,840 --> 00:06:29,520
which is common in schedulers however

00:06:28,560 --> 00:06:32,639
since

00:06:29,520 --> 00:06:35,440
or how arctic is designed is that we are

00:06:32,639 --> 00:06:36,160
not setting up call stacks or stack

00:06:35,440 --> 00:06:38,479
frames for

00:06:36,160 --> 00:06:39,759
each task they just shared the same one

00:06:38,479 --> 00:06:40,720
since the hardware's doing the

00:06:39,759 --> 00:06:42,319
scheduling for us

00:06:40,720 --> 00:06:44,560
so the hardware has control over the

00:06:42,319 --> 00:06:45,039
stack frames so we never need to worry

00:06:44,560 --> 00:06:47,039
about

00:06:45,039 --> 00:06:48,400
stacks meshing between tasks stack

00:06:47,039 --> 00:06:50,000
overruns

00:06:48,400 --> 00:06:51,440
the only thing you can do is use so much

00:06:50,000 --> 00:06:53,440
stack in the system

00:06:51,440 --> 00:06:56,639
that you start going over the maximum

00:06:53,440 --> 00:07:00,160
ram or going into

00:06:56,639 --> 00:07:00,160
the data sections

00:07:00,800 --> 00:07:03,919
and this is what i would usually call

00:07:02,800 --> 00:07:07,120
the info sheet

00:07:03,919 --> 00:07:08,800
and if you have a look at the book

00:07:07,120 --> 00:07:11,280
this is more or less the first page of

00:07:08,800 --> 00:07:12,720
the book and i highly after this

00:07:11,280 --> 00:07:13,520
recommend actually to read the book it's

00:07:12,720 --> 00:07:17,360
a

00:07:13,520 --> 00:07:20,800
it's a very good reference but

00:07:17,360 --> 00:07:22,560
we're here for demos and with this i'm

00:07:20,800 --> 00:07:31,840
going to switch over

00:07:22,560 --> 00:07:31,840
actually and start running demos

00:07:32,319 --> 00:07:45,840
and we shall

00:07:46,160 --> 00:07:49,039
that's the second

00:07:50,240 --> 00:08:03,280
i don't know seems to be

00:07:59,759 --> 00:08:07,039
okay now it should be working perfect

00:08:03,280 --> 00:08:09,520
so let's start with the basics

00:08:07,039 --> 00:08:10,080
of this scheduler and that is what we

00:08:09,520 --> 00:08:14,800
call

00:08:10,080 --> 00:08:18,080
the app macro the app macro

00:08:14,800 --> 00:08:19,680
which is included here and this is

00:08:18,080 --> 00:08:20,319
usually the only include you need for

00:08:19,680 --> 00:08:23,039
arctic

00:08:20,319 --> 00:08:25,280
if you only want to do basic use of it

00:08:23,039 --> 00:08:27,280
what the app macro does

00:08:25,280 --> 00:08:28,879
which is the outline you can see down

00:08:27,280 --> 00:08:30,960
here

00:08:28,879 --> 00:08:33,440
is that this is where you write your

00:08:30,960 --> 00:08:35,120
application

00:08:33,440 --> 00:08:36,560
you might have questions like why is

00:08:35,120 --> 00:08:38,800
does it say const up

00:08:36,560 --> 00:08:41,279
and this and more or less this is just

00:08:38,800 --> 00:08:43,360
to make proc macros in rust happy

00:08:41,279 --> 00:08:45,120
in a newer version of rust that is

00:08:43,360 --> 00:08:47,120
coming this is going to be switched out

00:08:45,120 --> 00:08:48,480
to a normal rust module

00:08:47,120 --> 00:08:50,399
however this is how we have to do it for

00:08:48,480 --> 00:08:52,080
now

00:08:50,399 --> 00:08:54,080
and this is generally if you're starting

00:08:52,080 --> 00:08:57,120
a new project

00:08:54,080 --> 00:08:58,480
it's quite common to start here the

00:08:57,120 --> 00:09:00,080
important thing to know about the app

00:08:58,480 --> 00:09:02,480
macro what it requires

00:09:00,080 --> 00:09:03,920
is that you provide the device which

00:09:02,480 --> 00:09:06,720
this is running on

00:09:03,920 --> 00:09:07,120
which means the peripheral access crit

00:09:06,720 --> 00:09:09,839
and

00:09:07,120 --> 00:09:09,839
in this case

00:09:12,399 --> 00:09:18,399
there we're running on an stm32

00:09:17,200 --> 00:09:19,680
and for those who want to look in the

00:09:18,399 --> 00:09:21,040
code later you're going to see we're

00:09:19,680 --> 00:09:23,839
running on an l4

00:09:21,040 --> 00:09:23,839
board

00:09:25,200 --> 00:09:29,360
so with this there's not much of a demo

00:09:27,839 --> 00:09:31,360
but this is the basics

00:09:29,360 --> 00:09:34,800
so if you ever see this app macro then

00:09:31,360 --> 00:09:38,959
you know that you're an arctic land

00:09:34,800 --> 00:09:42,000
but let's switch to actually something

00:09:38,959 --> 00:09:42,880
real where we actually run something so

00:09:42,000 --> 00:09:47,120
i'm going to show you

00:09:42,880 --> 00:09:49,440
the three main components of arctic

00:09:47,120 --> 00:09:50,720
which is what we call the init function

00:09:49,440 --> 00:09:53,440
the idle function

00:09:50,720 --> 00:09:53,440
and tasks

00:09:54,160 --> 00:09:59,600
and let's jump down to the code

00:09:59,839 --> 00:10:07,600
so the app macro which defines the

00:10:03,839 --> 00:10:10,160
we have resources but none for now

00:10:07,600 --> 00:10:10,880
and then we have actually in it in it is

00:10:10,160 --> 00:10:13,360
one of the

00:10:10,880 --> 00:10:15,040
most important functions in arctic

00:10:13,360 --> 00:10:17,040
because whenever arctic starts this is

00:10:15,040 --> 00:10:19,360
the main of arctic

00:10:17,040 --> 00:10:21,440
so if you ever start any code this is

00:10:19,360 --> 00:10:24,079
the code that will run first

00:10:21,440 --> 00:10:25,360
so you put initialization code you start

00:10:24,079 --> 00:10:27,519
your drivers

00:10:25,360 --> 00:10:29,600
these type of things for all of my

00:10:27,519 --> 00:10:31,600
examples i'm only going to do logging so

00:10:29,600 --> 00:10:32,880
you can see prints of the system

00:10:31,600 --> 00:10:34,959
and we can see a few leds blinking as

00:10:32,880 --> 00:10:37,279
well of course so

00:10:34,959 --> 00:10:39,120
what i've put in here is only that i'm

00:10:37,279 --> 00:10:42,240
enabling a logging framework

00:10:39,120 --> 00:10:42,240
so we can see what's happening

00:10:42,480 --> 00:10:48,320
now if we continue we have the optional

00:10:45,760 --> 00:10:50,880
idle task

00:10:48,320 --> 00:10:50,880
and idle

00:10:51,360 --> 00:10:58,000
is that if no tasks are running

00:10:54,399 --> 00:10:59,519
idle runs so this is

00:10:58,000 --> 00:11:01,120
quite common to put maybe background

00:10:59,519 --> 00:11:03,920
work logging

00:11:01,120 --> 00:11:05,279
maybe writing to a logging chip maybe

00:11:03,920 --> 00:11:06,800
you have some background work needs to

00:11:05,279 --> 00:11:09,279
be on your system

00:11:06,800 --> 00:11:11,920
they're done here and this is actually

00:11:09,279 --> 00:11:14,959
the only place in arctic

00:11:11,920 --> 00:11:16,000
where you will find an infinite loop one

00:11:14,959 --> 00:11:19,200
can see this as

00:11:16,000 --> 00:11:22,480
the infinite main loop in a way

00:11:19,200 --> 00:11:25,040
so just to get some feeling however

00:11:22,480 --> 00:11:25,600
it is perfectly fine to not have an idle

00:11:25,040 --> 00:11:29,920
task

00:11:25,600 --> 00:11:31,920
at all if you don't have an idle task

00:11:29,920 --> 00:11:34,480
then the what will happen is it will

00:11:31,920 --> 00:11:37,600
only run a wait for

00:11:34,480 --> 00:11:37,600
interrupt instruction

00:11:39,680 --> 00:11:45,839
and what is also what's

00:11:42,880 --> 00:11:46,880
in in all of our functions here so

00:11:45,839 --> 00:11:49,760
you'll always see that

00:11:46,880 --> 00:11:50,320
all functions take a context and we'll

00:11:49,760 --> 00:11:53,200
see more

00:11:50,320 --> 00:11:54,560
i said for the examples progress how

00:11:53,200 --> 00:11:57,839
this context is used

00:11:54,560 --> 00:12:01,360
for example for accessing resources

00:11:57,839 --> 00:12:02,000
or other features and finally let's have

00:12:01,360 --> 00:12:05,680
a look

00:12:02,000 --> 00:12:08,160
at the two task syntaxes that exist

00:12:05,680 --> 00:12:11,839
if you have a software task which means

00:12:08,160 --> 00:12:11,839
that this task is not

00:12:11,920 --> 00:12:19,920
linked to a hardware interrupt then

00:12:15,120 --> 00:12:21,760
you only have the task attribute

00:12:19,920 --> 00:12:23,200
and also everything looks the same for

00:12:21,760 --> 00:12:26,480
everything in our pic

00:12:23,200 --> 00:12:27,680
you have the context and a normal

00:12:26,480 --> 00:12:31,920
function which is

00:12:27,680 --> 00:12:35,200
has to attribute and we have

00:12:31,920 --> 00:12:39,920
what is called hardware

00:12:35,200 --> 00:12:43,040
bound tasks so if you add this binds

00:12:39,920 --> 00:12:43,920
argument then this task will be bound to

00:12:43,040 --> 00:12:46,959
an actual

00:12:43,920 --> 00:12:48,800
hardware interrupt so in this case

00:12:46,959 --> 00:12:50,639
if we were to get data or do anything

00:12:48,800 --> 00:12:54,160
with uart 1

00:12:50,639 --> 00:12:55,440
this task would run and there's a lot of

00:12:54,160 --> 00:12:57,200
comments here for

00:12:55,440 --> 00:12:58,959
when you want to look at this after the

00:12:57,200 --> 00:13:02,399
talks so you can see it go through

00:12:58,959 --> 00:13:04,800
and go through and take in all of this

00:13:02,399 --> 00:13:08,320
information

00:13:04,800 --> 00:13:11,680
and finally a detail which is

00:13:08,320 --> 00:13:12,639
necessary is that for software tasks to

00:13:11,680 --> 00:13:14,639
run

00:13:12,639 --> 00:13:16,560
they still need to run in and interrupt

00:13:14,639 --> 00:13:17,440
this is how arctic the core of arctic

00:13:16,560 --> 00:13:19,600
works

00:13:17,440 --> 00:13:21,839
so what whenever you use a software task

00:13:19,600 --> 00:13:25,040
as we have defined up here

00:13:21,839 --> 00:13:27,040
you must give to arctic what we call

00:13:25,040 --> 00:13:28,800
free interrupt vectors this means

00:13:27,040 --> 00:13:31,040
interrupts that you are not using for

00:13:28,800 --> 00:13:33,200
specific hardware interrupts

00:13:31,040 --> 00:13:34,399
so in my case these are put in an extern

00:13:33,200 --> 00:13:35,680
c block for now

00:13:34,399 --> 00:13:37,279
but this will probably change to

00:13:35,680 --> 00:13:38,880
something more user friendly in the

00:13:37,279 --> 00:13:40,720
future

00:13:38,880 --> 00:13:42,959
so in this case since i have one

00:13:40,720 --> 00:13:46,639
software interrupt i have put in

00:13:42,959 --> 00:13:48,720
one free interrupt here

00:13:46,639 --> 00:13:50,560
i only need as many free interrupts as

00:13:48,720 --> 00:13:53,680
priority levels

00:13:50,560 --> 00:13:55,199
for software tasks

00:13:53,680 --> 00:13:57,360
and what this code in practice will do

00:13:55,199 --> 00:13:59,920
if we run it is we will get hello

00:13:57,360 --> 00:14:03,839
from init and a hello from idle let's

00:13:59,920 --> 00:14:03,839
try and run this code

00:14:05,279 --> 00:14:08,639
and this is exactly what we get

00:14:12,320 --> 00:14:16,720
and if you run this or open this project

00:14:14,399 --> 00:14:18,160
yourself with vs code all of these tasks

00:14:16,720 --> 00:14:19,199
for running all these examples are

00:14:18,160 --> 00:14:20,800
prepared there

00:14:19,199 --> 00:14:24,079
so as long as you have the same board

00:14:20,800 --> 00:14:25,440
you can run this one straight off

00:14:24,079 --> 00:14:27,760
well let's go to a more interesting

00:14:25,440 --> 00:14:31,839
example maybe to see

00:14:27,760 --> 00:14:31,839
how we use tasks

00:14:34,720 --> 00:14:42,720
so in this case

00:14:39,440 --> 00:14:45,120
we are going to have one task

00:14:42,720 --> 00:14:48,000
we are calling it our hello world task

00:14:45,120 --> 00:14:49,199
and this is the task we're going to run

00:14:48,000 --> 00:14:51,199
and what we're going to do is we're

00:14:49,199 --> 00:14:54,720
going to run this one from main

00:14:51,199 --> 00:14:54,720
or the init function

00:14:54,959 --> 00:14:59,120
so in init we're still doing a lot of

00:14:57,440 --> 00:15:02,880
initialization

00:14:59,120 --> 00:15:02,880
and here's the interesting thing in

00:15:03,120 --> 00:15:09,279
the init attribute we can add the

00:15:06,560 --> 00:15:12,560
argument to say that this

00:15:09,279 --> 00:15:16,079
task or function is allowed to spawn

00:15:12,560 --> 00:15:17,920
software tasks or spawn tasks overall

00:15:16,079 --> 00:15:21,519
so we've said that init is now allowed

00:15:17,920 --> 00:15:21,519
to spawn the hello world task

00:15:21,680 --> 00:15:25,279
what this means is that we can access

00:15:23,920 --> 00:15:27,519
and spawn

00:15:25,279 --> 00:15:30,480
a task which means that you are going to

00:15:27,519 --> 00:15:30,480
tell this task to run

00:15:30,560 --> 00:15:34,560
however what is interesting here is that

00:15:32,880 --> 00:15:35,759
we have hello from init at the end of

00:15:34,560 --> 00:15:38,079
init

00:15:35,759 --> 00:15:39,279
the hello world task has hello world

00:15:38,079 --> 00:15:42,480
from task

00:15:39,279 --> 00:15:45,600
and idle has its hello from idle

00:15:42,480 --> 00:15:48,240
but let's see how these actually run in

00:15:45,600 --> 00:15:48,240
which order

00:15:51,040 --> 00:15:55,360
so we get hello from init and then we

00:15:53,600 --> 00:15:59,199
get hello from task

00:15:55,360 --> 00:16:02,880
even though we spawned the task before

00:15:59,199 --> 00:16:06,839
we sent the hello from init and finally

00:16:02,880 --> 00:16:09,120
idle let's have a quick look at why this

00:16:06,839 --> 00:16:11,920
is

00:16:09,120 --> 00:16:12,560
how it works is that no tasks can

00:16:11,920 --> 00:16:15,600
preempt

00:16:12,560 --> 00:16:16,720
init tasks all tasks are disabled until

00:16:15,600 --> 00:16:20,320
init finishes

00:16:16,720 --> 00:16:20,320
this is a very good detail to remember

00:16:20,480 --> 00:16:24,160
let's continue to the next one

00:16:26,320 --> 00:16:28,639
and now we're going to have a little bit

00:16:27,440 --> 00:16:30,000
more interesting we're going to use

00:16:28,639 --> 00:16:31,759
priorities else we're going to have more

00:16:30,000 --> 00:16:34,000
or less the same thing

00:16:31,759 --> 00:16:35,519
so let's start looking at our tasks we

00:16:34,000 --> 00:16:37,279
have two tasks

00:16:35,519 --> 00:16:39,519
a low priority task and a high priority

00:16:37,279 --> 00:16:41,440
task which means

00:16:39,519 --> 00:16:42,880
simply that you add the priority

00:16:41,440 --> 00:16:46,320
attribute

00:16:42,880 --> 00:16:46,320
or priority argument

00:16:47,120 --> 00:16:51,279
and in spawn we are first spawning the

00:16:50,079 --> 00:16:52,320
low priority task and then the high

00:16:51,279 --> 00:16:53,440
priority

00:16:52,320 --> 00:16:55,759
but we're going to see that a high

00:16:53,440 --> 00:16:58,079
priority task it will run first

00:16:55,759 --> 00:16:58,959
even though low priority is spawned

00:16:58,079 --> 00:17:00,399
first

00:16:58,959 --> 00:17:02,000
and this is because no tasks are allowed

00:17:00,399 --> 00:17:03,440
to run until end of init which means

00:17:02,000 --> 00:17:05,120
that both will be started at the same

00:17:03,440 --> 00:17:08,079
time at the end of init

00:17:05,120 --> 00:17:10,480
and then the high priority task will run

00:17:08,079 --> 00:17:10,480
first

00:17:11,199 --> 00:17:14,720
so we get our hello for a minute the

00:17:13,120 --> 00:17:16,799
high priority task

00:17:14,720 --> 00:17:20,240
and low priority task and finally idle

00:17:16,799 --> 00:17:21,760
after all tasks have finished

00:17:20,240 --> 00:17:23,760
and this is an example i highly

00:17:21,760 --> 00:17:25,280
recommend you to play around with

00:17:23,760 --> 00:17:26,799
if you want to try it out to see how

00:17:25,280 --> 00:17:30,720
priorities work

00:17:26,799 --> 00:17:34,320
and how they interact let's continue to

00:17:30,720 --> 00:17:34,320
the next example

00:17:34,720 --> 00:17:39,520
and this is probably one of the more

00:17:36,960 --> 00:17:39,520
important

00:17:39,679 --> 00:17:42,320
parts here

00:17:43,600 --> 00:17:51,200
so we are going oops

00:17:47,440 --> 00:17:51,200
let's just do that you didn't see that

00:17:51,360 --> 00:17:55,600
we're going to schedule this means we're

00:17:53,440 --> 00:17:56,960
going to run something in the future

00:17:55,600 --> 00:17:59,120
what arctic needs if we're going to

00:17:56,960 --> 00:18:01,360
schedule tasks into the future

00:17:59,120 --> 00:18:02,960
is that it needs to know what time base

00:18:01,360 --> 00:18:05,120
are we using it needs a timer

00:18:02,960 --> 00:18:06,640
practically and in arctic we're

00:18:05,120 --> 00:18:09,039
providing the

00:18:06,640 --> 00:18:10,480
debug watchdog timer as one of these

00:18:09,039 --> 00:18:11,600
time references

00:18:10,480 --> 00:18:12,840
so what you do if you want to use the

00:18:11,600 --> 00:18:15,039
scheduling is that you add this

00:18:12,840 --> 00:18:18,960
monotonic

00:18:15,039 --> 00:18:22,320
argument and this will enable scheduling

00:18:18,960 --> 00:18:25,200
so what we're simply going to do here

00:18:22,320 --> 00:18:25,840
and some details but what we're going to

00:18:25,200 --> 00:18:29,280
do

00:18:25,840 --> 00:18:32,160
is that we're going to schedule

00:18:29,280 --> 00:18:33,919
the hello world task and now i happen to

00:18:32,160 --> 00:18:36,240
know that this

00:18:33,919 --> 00:18:37,520
mcu runs at 4 megahertz at startup so

00:18:36,240 --> 00:18:40,640
we're going to schedule it

00:18:37,520 --> 00:18:43,840
three seconds into the future

00:18:40,640 --> 00:18:43,840
and let's see that happening

00:18:49,919 --> 00:18:53,760
so idle since the scheduled task had not

00:18:53,039 --> 00:18:55,679
happened

00:18:53,760 --> 00:18:58,640
and here we got it in the future three

00:18:55,679 --> 00:19:02,480
seconds into the future

00:18:58,640 --> 00:19:02,480
and this is the basis for scheduling

00:19:03,520 --> 00:19:07,360
what is the details as a small detail

00:19:05,919 --> 00:19:10,400
everyone needs to know

00:19:07,360 --> 00:19:11,760
is that you need to start the timer that

00:19:10,400 --> 00:19:13,840
you're going to use

00:19:11,760 --> 00:19:15,280
and this can be part of how it can be

00:19:13,840 --> 00:19:16,400
part of startup code

00:19:15,280 --> 00:19:18,559
however here i've written it out

00:19:16,400 --> 00:19:24,799
explicitly so for you who go through

00:19:18,559 --> 00:19:28,559
these examples you'll see it's directly

00:19:24,799 --> 00:19:34,240
let's jump to actually using resources

00:19:28,559 --> 00:19:36,720
this is something that is very important

00:19:34,240 --> 00:19:38,160
so if we start we're going to define our

00:19:36,720 --> 00:19:41,200
first resource

00:19:38,160 --> 00:19:42,640
in this case we name it value

00:19:41,200 --> 00:19:47,039
and you just have defined this as a

00:19:42,640 --> 00:19:50,480
normal structure and it has a u32

00:19:47,039 --> 00:19:53,919
what we see here then is that init gets

00:19:50,480 --> 00:19:56,720
this late resources added as return

00:19:53,919 --> 00:19:58,799
this means that after init the return of

00:19:56,720 --> 00:20:02,320
init is will be the start

00:19:58,799 --> 00:20:07,120
value of the resource structure

00:20:02,320 --> 00:20:10,799
so we are enabling our scheduling

00:20:07,120 --> 00:20:11,919
and in the end here we are starting

00:20:10,799 --> 00:20:14,720
value

00:20:11,919 --> 00:20:15,440
with the value of 42. and more

00:20:14,720 --> 00:20:17,280
interesting

00:20:15,440 --> 00:20:18,880
we have the two priority tasks one high

00:20:17,280 --> 00:20:21,360
priority and one low priority

00:20:18,880 --> 00:20:22,480
let's have a quick look at the tasks

00:20:21,360 --> 00:20:25,919
we're going to see

00:20:22,480 --> 00:20:27,840
that the high prototasks only increases

00:20:25,919 --> 00:20:30,159
the value

00:20:27,840 --> 00:20:31,039
and the low priority task it does a lot

00:20:30,159 --> 00:20:34,080
of

00:20:31,039 --> 00:20:36,159
long computations let's say so here we

00:20:34,080 --> 00:20:38,960
just have a poor man's delay

00:20:36,159 --> 00:20:39,840
so this means hopefully that we will see

00:20:38,960 --> 00:20:44,240
a different value

00:20:39,840 --> 00:20:44,240
as this will be preempted in the middle

00:20:44,320 --> 00:20:49,840
let's run this

00:20:50,559 --> 00:20:53,520
number six

00:20:55,679 --> 00:20:58,880
and here you see the low peritosis runs

00:20:58,000 --> 00:21:00,880
first as

00:20:58,880 --> 00:21:03,600
after it was scheduled the high

00:21:00,880 --> 00:21:05,600
prototasks

00:21:03,600 --> 00:21:07,200
preempts this one and updates this

00:21:05,600 --> 00:21:10,320
resource which has been

00:21:07,200 --> 00:21:13,440
accessed and then the low power to

00:21:10,320 --> 00:21:15,360
reuse it again and the important thing

00:21:13,440 --> 00:21:17,919
to see here

00:21:15,360 --> 00:21:20,080
is that low priority task it accesses

00:21:17,919 --> 00:21:23,600
resources through this context structure

00:21:20,080 --> 00:21:26,799
and it must lock it however

00:21:23,600 --> 00:21:26,799
the high priority task

00:21:27,280 --> 00:21:30,880
it does not need a lock as this is

00:21:29,520 --> 00:21:32,400
guaranteed to run

00:21:30,880 --> 00:21:34,000
at the highest priority that may take

00:21:32,400 --> 00:21:36,240
this resource so

00:21:34,000 --> 00:21:37,200
it doesn't need a lock this will allow

00:21:36,240 --> 00:21:39,120
change in the future

00:21:37,200 --> 00:21:40,400
due to we want the resource access to be

00:21:39,120 --> 00:21:43,760
symmetric

00:21:40,400 --> 00:21:46,480
so but for now in version five

00:21:43,760 --> 00:21:46,480
this is how it is

00:21:47,919 --> 00:21:53,520
and now let's just do a quick example of

00:21:50,799 --> 00:21:53,520
message passing

00:21:55,679 --> 00:21:59,360
in this case we're going to have two

00:21:57,600 --> 00:22:01,520
tasks printer one

00:21:59,360 --> 00:22:02,960
and printer two and this is an example i

00:22:01,520 --> 00:22:05,280
recommend to sit a lot with

00:22:02,960 --> 00:22:07,360
to see how these work and let's have a

00:22:05,280 --> 00:22:10,000
quick look at printer one and two

00:22:07,360 --> 00:22:11,600
they have arguments here so if you look

00:22:10,000 --> 00:22:13,919
at their

00:22:11,600 --> 00:22:16,240
definitions we see that they have now

00:22:13,919 --> 00:22:17,440
input values

00:22:16,240 --> 00:22:19,440
and they will simply print out these

00:22:17,440 --> 00:22:21,280
values as they come

00:22:19,440 --> 00:22:23,360
the important thing to notice is that

00:22:21,280 --> 00:22:26,080
this new capacity

00:22:23,360 --> 00:22:26,720
argument what this one does is that it

00:22:26,080 --> 00:22:29,280
allows

00:22:26,720 --> 00:22:30,159
printer 2 to queue up multiple messages

00:22:29,280 --> 00:22:32,400
to it

00:22:30,159 --> 00:22:34,240
while printer 1 has does not have this

00:22:32,400 --> 00:22:36,159
attribute

00:22:34,240 --> 00:22:37,440
this means that the capacity of task 1

00:22:36,159 --> 00:22:40,640
will be defaulted to one

00:22:37,440 --> 00:22:42,799
so you can only put one at a time

00:22:40,640 --> 00:22:44,799
and then you see up here that if we put

00:22:42,799 --> 00:22:47,679
a value into printer one

00:22:44,799 --> 00:22:49,440
it will work if you put another one in

00:22:47,679 --> 00:22:50,240
the second will fail because its q is

00:22:49,440 --> 00:22:52,159
full

00:22:50,240 --> 00:22:54,480
our printer two will be able to take all

00:22:52,159 --> 00:22:57,840
of these four values

00:22:54,480 --> 00:22:57,840
let's run this and see it in action

00:23:01,120 --> 00:23:06,080
so we see first the second spawn failed

00:23:03,679 --> 00:23:08,000
so as we predicted the queue was full

00:23:06,080 --> 00:23:12,320
printer one prints this value 42 that i

00:23:08,000 --> 00:23:12,320
got and printer 2 prints is 4 values

00:23:12,640 --> 00:23:17,919
and now let's do a blink key

00:23:19,120 --> 00:23:24,080
as and this one it has a lot of code

00:23:22,880 --> 00:23:26,960
just in it to

00:23:24,080 --> 00:23:29,520
set up the pins but what is interesting

00:23:26,960 --> 00:23:30,799
is as to the blinky task in this case

00:23:29,520 --> 00:23:33,039
and again we're using a resource which

00:23:30,799 --> 00:23:36,159
is the lead

00:23:33,039 --> 00:23:37,919
so in this example we're demonstrating

00:23:36,159 --> 00:23:40,159
the save static modes which is a

00:23:37,919 --> 00:23:42,559
transformation of rtfn does for you

00:23:40,159 --> 00:23:45,520
one could use a toggle led here but i'm

00:23:42,559 --> 00:23:47,919
doing it manually just so you can see it

00:23:45,520 --> 00:23:47,919
and

00:23:48,720 --> 00:23:51,840
we will simply run this

00:23:55,919 --> 00:23:59,919
and here we will see it going but my

00:23:58,720 --> 00:24:05,840
hope is that this will

00:23:59,919 --> 00:24:05,840
show up well here

00:24:07,279 --> 00:24:10,159
and this is an example i recommend you

00:24:08,640 --> 00:24:13,600
even more to play around with because

00:24:10,159 --> 00:24:13,600
what's funnier than blinking let's say

00:24:15,360 --> 00:24:22,799
but we need one final thing and this is

00:24:18,960 --> 00:24:22,799
actually reacting to events

00:24:23,840 --> 00:24:28,000
so in the final launches button it has

00:24:26,400 --> 00:24:29,840
the same blink task

00:24:28,000 --> 00:24:31,919
and it has more hardware setup code and

00:24:29,840 --> 00:24:32,559
this will jump over for you to read

00:24:31,919 --> 00:24:34,159
later

00:24:32,559 --> 00:24:35,600
this is a standard hall code for setting

00:24:34,159 --> 00:24:38,640
up interrupts

00:24:35,600 --> 00:24:40,080
and pins so what we're going to do is

00:24:38,640 --> 00:24:43,679
we're going to a button event

00:24:40,080 --> 00:24:45,760
task which binds to an interrupt

00:24:43,679 --> 00:24:47,840
it will spawn blinky when we click the

00:24:45,760 --> 00:24:49,440
button

00:24:47,840 --> 00:24:51,200
so if we press the button after running

00:24:49,440 --> 00:24:51,520
this example the old blinky code will

00:24:51,200 --> 00:24:54,400
run

00:24:51,520 --> 00:24:56,960
but only after pressing the button so

00:24:54,400 --> 00:24:56,960
let's do that

00:24:58,960 --> 00:25:06,320
so nothing is happening and i hope i can

00:25:03,600 --> 00:25:08,640
do this without and if i click the

00:25:06,320 --> 00:25:08,640
button

00:25:09,039 --> 00:25:12,000
link starts running

00:25:13,760 --> 00:25:18,080
and this is quite common if you have a

00:25:16,480 --> 00:25:19,919
hardware high priority task and you want

00:25:18,080 --> 00:25:21,039
to let's say offload work to a lower

00:25:19,919 --> 00:25:22,880
task later

00:25:21,039 --> 00:25:24,080
maybe get the radio message and then you

00:25:22,880 --> 00:25:25,919
just want to slowly process it in the

00:25:24,080 --> 00:25:27,360
background

00:25:25,919 --> 00:25:29,840
and this is all the demos i was planning

00:25:27,360 --> 00:25:42,080
to run and let's now have a look

00:25:29,840 --> 00:25:46,720
at some of the guts of this

00:25:42,080 --> 00:25:46,720
there so

00:25:50,480 --> 00:25:53,919
in arctic web preemptive scheduling this

00:25:53,440 --> 00:25:56,640
means

00:25:53,919 --> 00:25:58,080
if we look at this picture is that every

00:25:56,640 --> 00:26:01,200
line up here

00:25:58,080 --> 00:26:02,880
is a priority level and jobs and tasks

00:26:01,200 --> 00:26:06,159
are interchangeable

00:26:02,880 --> 00:26:07,679
so if red dots are where we spawn tasks

00:26:06,159 --> 00:26:09,600
and straight lines or where we execute a

00:26:07,679 --> 00:26:12,960
task we can see it as

00:26:09,600 --> 00:26:15,120
jobs of higher priority are spawned

00:26:12,960 --> 00:26:16,000
they will run directly and this is what

00:26:15,120 --> 00:26:19,200
means to preempt

00:26:16,000 --> 00:26:22,400
multitasking and as the first

00:26:19,200 --> 00:26:23,279
one finishes the lower and low priority

00:26:22,400 --> 00:26:26,000
will run again

00:26:23,279 --> 00:26:27,200
until eventually coming back to idle and

00:26:26,000 --> 00:26:30,240
this is

00:26:27,200 --> 00:26:32,960
how all of the or the thought behind the

00:26:30,240 --> 00:26:35,279
preemptive multitasking

00:26:32,960 --> 00:26:36,240
finally the same thing if we have a low

00:26:35,279 --> 00:26:38,400
priority

00:26:36,240 --> 00:26:39,279
the highest spread runs and the middle

00:26:38,400 --> 00:26:41,600
one is

00:26:39,279 --> 00:26:43,120
spawned it will not run because a higher

00:26:41,600 --> 00:26:45,520
priority is running

00:26:43,120 --> 00:26:48,799
this is also what one would expect from

00:26:45,520 --> 00:26:48,799
preemptive multitasking

00:26:49,440 --> 00:26:52,559
however here comes the real interesting

00:26:50,960 --> 00:26:53,760
part which is usually the resource

00:26:52,559 --> 00:26:55,440
access problem and why

00:26:53,760 --> 00:26:58,000
it's so important with the locks let's

00:26:55,440 --> 00:27:01,039
say job1 and job2 can access the

00:26:58,000 --> 00:27:03,919
resource which is down here

00:27:01,039 --> 00:27:04,480
so task 1 access resource does work on

00:27:03,919 --> 00:27:07,760
it

00:27:04,480 --> 00:27:08,640
it gets preempted by task three however

00:27:07,760 --> 00:27:09,760
it's not doing anything with the

00:27:08,640 --> 00:27:12,159
resource everything is fine

00:27:09,760 --> 00:27:13,520
however task two does something to the

00:27:12,159 --> 00:27:15,520
resource

00:27:13,520 --> 00:27:17,120
so if we do not have locks here we have

00:27:15,520 --> 00:27:21,679
now create corrupted

00:27:17,120 --> 00:27:23,679
the resource because we have changed or

00:27:21,679 --> 00:27:25,440
interrupted the job one or task one in

00:27:23,679 --> 00:27:28,640
the middle of its execution

00:27:25,440 --> 00:27:32,480
and this is not acceptable

00:27:28,640 --> 00:27:34,240
so of course if this happens

00:27:32,480 --> 00:27:35,520
i mean we've broken everything there are

00:27:34,240 --> 00:27:39,279
no guarantees left

00:27:35,520 --> 00:27:42,000
at all in this system however

00:27:39,279 --> 00:27:43,120
what one expects to happen with locks is

00:27:42,000 --> 00:27:47,840
of course this

00:27:43,120 --> 00:27:48,480
when job one runs job three still runs

00:27:47,840 --> 00:27:52,159
and two

00:27:48,480 --> 00:27:55,440
is pended for execution however

00:27:52,159 --> 00:27:57,600
the job one is not finished with

00:27:55,440 --> 00:27:58,480
the resource so only when it's finished

00:27:57,600 --> 00:28:00,799
with the resource

00:27:58,480 --> 00:28:01,600
will jump to be allowed to run and this

00:28:00,799 --> 00:28:05,600
is

00:28:01,600 --> 00:28:08,640
how it works in arctic

00:28:05,600 --> 00:28:10,960
however how can this happen and how

00:28:08,640 --> 00:28:12,159
does this work everything in arctic is

00:28:10,960 --> 00:28:13,840
based on what's called the stack

00:28:12,159 --> 00:28:15,919
resource policy

00:28:13,840 --> 00:28:17,279
and i usually call it our savior because

00:28:15,919 --> 00:28:19,520
this guy

00:28:17,279 --> 00:28:20,640
you know he figured out a long time ago

00:28:19,520 --> 00:28:23,279
and now we're reaping

00:28:20,640 --> 00:28:24,720
huge benefits from it and if anyone

00:28:23,279 --> 00:28:25,440
wants to read it this is the paper

00:28:24,720 --> 00:28:28,559
actually

00:28:25,440 --> 00:28:30,399
where this was invented

00:28:28,559 --> 00:28:31,760
so what we're doing when we're looking a

00:28:30,399 --> 00:28:35,279
resource is

00:28:31,760 --> 00:28:37,840
simply this we disable all tasks

00:28:35,279 --> 00:28:38,880
which are at equal or lower priority

00:28:37,840 --> 00:28:42,000
than the highest

00:28:38,880 --> 00:28:44,159
of all jobs that takes this resource

00:28:42,000 --> 00:28:45,200
and this one takes a bit to sync in but

00:28:44,159 --> 00:28:46,480
we're going to see image what this

00:28:45,200 --> 00:28:49,520
actually means

00:28:46,480 --> 00:28:53,200
and we release a resource where we

00:28:49,520 --> 00:28:53,200
enable all of these disabled tasks

00:28:53,360 --> 00:28:59,279
and how does this what's this called

00:28:56,240 --> 00:29:01,200
this is what's called a priority ceiling

00:28:59,279 --> 00:29:02,640
and this is something called a priority

00:29:01,200 --> 00:29:08,399
ceiling scheduler

00:29:02,640 --> 00:29:08,399
or it's also called a an eager scheduler

00:29:08,880 --> 00:29:13,279
so if we add the priority ceiling into

00:29:10,720 --> 00:29:16,080
this old

00:29:13,279 --> 00:29:16,559
graph that we saw that when job run one

00:29:16,080 --> 00:29:20,399
takes

00:29:16,559 --> 00:29:21,039
the resource it raises the priority

00:29:20,399 --> 00:29:24,159
ceiling

00:29:21,039 --> 00:29:25,760
to this level this means that job 2

00:29:24,159 --> 00:29:28,240
is at this level so it's not allowed to

00:29:25,760 --> 00:29:29,919
run jump 3 however is above this level

00:29:28,240 --> 00:29:32,559
so it is allowed to run

00:29:29,919 --> 00:29:33,520
and then when task 1 releases its

00:29:32,559 --> 00:29:35,760
resource

00:29:33,520 --> 00:29:37,440
this even goes down to the lowest level

00:29:35,760 --> 00:29:40,880
and when job 2 runs

00:29:37,440 --> 00:29:43,520
we're back and this is how

00:29:40,880 --> 00:29:44,399
arctic works internally with priority

00:29:43,520 --> 00:29:48,480
ceilings

00:29:44,399 --> 00:29:48,480
however how does this work

00:29:49,200 --> 00:29:53,200
so this is what how it works is what has

00:29:51,360 --> 00:29:55,440
this feature in our microprocessor

00:29:53,200 --> 00:29:57,200
specifically the cortex-m

00:29:55,440 --> 00:29:58,640
in the cortex-m we have the nested

00:29:57,200 --> 00:30:01,919
vector interrupt controller

00:29:58,640 --> 00:30:01,919
which can do this type of

00:30:03,360 --> 00:30:09,840
let's call it scheduling for us

00:30:06,480 --> 00:30:11,520
because it is a priority based or the

00:30:09,840 --> 00:30:13,520
interest vectors are priority based and

00:30:11,520 --> 00:30:15,520
will preempt each other

00:30:13,520 --> 00:30:18,720
so the first feature we want is given

00:30:15,520 --> 00:30:18,720
for to us from the end

00:30:19,440 --> 00:30:23,760
the final one what about the priority

00:30:22,000 --> 00:30:27,039
ceiling what has this behavior

00:30:23,760 --> 00:30:27,600
in the cortex ends well something that

00:30:27,039 --> 00:30:29,520
does this

00:30:27,600 --> 00:30:30,640
is a feature of the nvik which is called

00:30:29,520 --> 00:30:32,640
base pre

00:30:30,640 --> 00:30:34,640
and this is simply if you set brace pre

00:30:32,640 --> 00:30:36,640
to a value

00:30:34,640 --> 00:30:38,640
anything at this value or lower will not

00:30:36,640 --> 00:30:40,799
run from the nvik

00:30:38,640 --> 00:30:42,799
and this is what we're using internally

00:30:40,799 --> 00:30:45,760
so locks are only

00:30:42,799 --> 00:30:46,320
or in it is only setting up the nvik for

00:30:45,760 --> 00:30:48,880
us

00:30:46,320 --> 00:30:50,000
and locks are only accessing and

00:30:48,880 --> 00:30:51,200
changing base print

00:30:50,000 --> 00:30:52,720
so in the end you have only very few

00:30:51,200 --> 00:30:54,080
instructions which is the entire

00:30:52,720 --> 00:30:56,159
scheduler

00:30:54,080 --> 00:30:57,120
and this is the entire magic that is the

00:30:56,159 --> 00:31:01,760
core

00:30:57,120 --> 00:31:03,279
of arctic so just to wrap up

00:31:01,760 --> 00:31:05,120
this means that all your tasks running

00:31:03,279 --> 00:31:05,760
interrupt vectors which means that the

00:31:05,120 --> 00:31:07,919
hardware does

00:31:05,760 --> 00:31:08,799
all the scheduling for us we don't lift

00:31:07,919 --> 00:31:13,279
a clock cycle

00:31:08,799 --> 00:31:13,279
to do scheduling only to set it up

00:31:13,440 --> 00:31:16,960
and we need to find these values of base

00:31:15,519 --> 00:31:19,760
pre and this is

00:31:16,960 --> 00:31:21,600
why arctic is a huge prop macro the

00:31:19,760 --> 00:31:23,760
arctic app proc macro

00:31:21,600 --> 00:31:25,200
finds the values needed for basebree

00:31:23,760 --> 00:31:26,640
through code analysis

00:31:25,200 --> 00:31:29,200
and this is why everything is inside

00:31:26,640 --> 00:31:29,200
this app

00:31:30,080 --> 00:31:36,880
and with that i thank you

00:31:34,480 --> 00:31:38,480
for coming to this talk i highly

00:31:36,880 --> 00:31:41,039
recommend you to check out the code the

00:31:38,480 --> 00:31:44,320
documentation come join us in the chat

00:31:41,039 --> 00:31:47,279
and uh i hope we have good discussions

00:31:44,320 --> 00:31:50,000
afterwards on this

00:31:47,279 --> 00:31:52,960
and we all thank the gods for technology

00:31:50,000 --> 00:31:54,880
and demos working

00:31:52,960 --> 00:31:56,240
thank you for this nice run through

00:31:54,880 --> 00:31:59,279
arctic and its

00:31:56,240 --> 00:32:00,960
ideas um we actually have no time for

00:31:59,279 --> 00:32:02,480
questions but there are questions in the

00:32:00,960 --> 00:32:05,200
chat so i highly recommend you

00:32:02,480 --> 00:32:08,399
to to move over and start the discussion

00:32:05,200 --> 00:32:11,279
it's quite active already

00:32:08,399 --> 00:32:12,320
or the matrix it's in your it's in your

00:32:11,279 --> 00:32:15,279
matrix channel

00:32:12,320 --> 00:32:27,039
exactly perfect i'll jump in there see

00:32:15,279 --> 00:32:27,039

YouTube URL: https://www.youtube.com/watch?v=saNdh0m_qHc


