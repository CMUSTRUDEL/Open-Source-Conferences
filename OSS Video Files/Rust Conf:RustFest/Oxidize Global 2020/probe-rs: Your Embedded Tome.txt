Title: probe-rs: Your Embedded Tome
Publication date: 2020-11-06
Playlist: Oxidize Global 2020
Description: 
	Ever wanted to know how the magic spell you always used to program that mystery ELF file onto your embedded target works? I did so in February 2019. This is the story of probe-rs, your magic spellbook to talk to embedded targets.

Close to a decade now, I have been working with embedded systems. While complaining about subpar tooling was always an option, stepping up and making better tooling somehow seemed impossible. One year ago, having no prior knowledge of this matter, I started to look into how debug probes and the debug interface of ARM cores works and how prior tooling, approaches this.

Today, we have a working library to interact with ARM and RISC-V targets. Of course we are not done yet. There is a plethora of embedded targets, bugs arise everyday and there is way more awesome functionality and tooling we want to provide.

This talk is the story probe-rs, giving you a little bit of the why, the how, the good and the bad and why you should use it and contribute to it.
Captions: 
	00:00:01,770 --> 00:00:30,839
[Music]

00:00:32,480 --> 00:00:36,960
hello everyone

00:00:33,520 --> 00:00:39,360
and welcome to the last talk of the day

00:00:36,960 --> 00:00:41,040
and it's a special highlight because i'm

00:00:39,360 --> 00:00:44,480
really glad to introduce

00:00:41,040 --> 00:00:45,440
noah husser who's one of the authors of

00:00:44,480 --> 00:00:48,160
probe arrest

00:00:45,440 --> 00:00:49,760
really a cornerstone of the embedded

00:00:48,160 --> 00:00:51,840
ecosystem in ross

00:00:49,760 --> 00:00:54,640
i'm so glad that he's going to talk

00:00:51,840 --> 00:00:58,239
about that as the final talk of the day

00:00:54,640 --> 00:01:00,960
thank you so

00:00:58,239 --> 00:01:02,719
good evening everybody i hope you

00:01:00,960 --> 00:01:04,559
enjoyed the great day of oxidize with a

00:01:02,719 --> 00:01:07,760
lot of interesting talks

00:01:04,559 --> 00:01:11,200
and have some energy left to spare for

00:01:07,760 --> 00:01:14,560
my top pro bars your embedded tome

00:01:11,200 --> 00:01:15,600
so very short introduction my name is

00:01:14,560 --> 00:01:19,759
noah husser

00:01:15,600 --> 00:01:22,560
better known as elteki on the internet

00:01:19,759 --> 00:01:23,600
i'm a twist software engineer and i work

00:01:22,560 --> 00:01:26,240
at my own

00:01:23,600 --> 00:01:27,360
tech consultancy technocrat we're doing

00:01:26,240 --> 00:01:30,240
all sorts

00:01:27,360 --> 00:01:32,560
of electronics and software so from

00:01:30,240 --> 00:01:34,479
power electronics to server backends

00:01:32,560 --> 00:01:36,240
and we try to use rust as much as

00:01:34,479 --> 00:01:38,000
possible more and more

00:01:36,240 --> 00:01:39,680
and in my spare time i like doing all

00:01:38,000 --> 00:01:42,880
sorts of sports such as

00:01:39,680 --> 00:01:45,119
jiu-jitsu which i especially like

00:01:42,880 --> 00:01:46,720
so let me talk a little bit about

00:01:45,119 --> 00:01:50,799
embedded development

00:01:46,720 --> 00:01:52,000
so when doing embedded development i

00:01:50,799 --> 00:01:55,439
guess most of you

00:01:52,000 --> 00:01:58,000
have used some tools um

00:01:55,439 --> 00:01:58,560
i have listed here so there's lots of

00:01:58,000 --> 00:02:01,600
probes

00:01:58,560 --> 00:02:03,119
and on-chip debugging tools that can

00:02:01,600 --> 00:02:06,000
talk to those probes and

00:02:03,119 --> 00:02:07,280
your target and you use them to flash an

00:02:06,000 --> 00:02:09,920
elf binary

00:02:07,280 --> 00:02:10,640
to your target or to get debug

00:02:09,920 --> 00:02:13,840
information

00:02:10,640 --> 00:02:14,720
from your target so this sounds great at

00:02:13,840 --> 00:02:17,120
first and

00:02:14,720 --> 00:02:18,480
it is great sometimes that you have such

00:02:17,120 --> 00:02:20,400
a huge

00:02:18,480 --> 00:02:21,680
selection of tools from which you can

00:02:20,400 --> 00:02:24,879
choose

00:02:21,680 --> 00:02:27,920
but there's drawbacks and drawbacks

00:02:24,879 --> 00:02:30,800
of course so the ecosystem

00:02:27,920 --> 00:02:32,160
is very stiff so oftentimes you don't

00:02:30,800 --> 00:02:34,720
really get to choose

00:02:32,160 --> 00:02:36,239
each tool but they're a chain of tools

00:02:34,720 --> 00:02:39,599
that you have to use and

00:02:36,239 --> 00:02:44,000
many vendors ship their own toolset

00:02:39,599 --> 00:02:46,239
such as eclipse which then is gdp based

00:02:44,000 --> 00:02:47,599
again and they all add their own flavor

00:02:46,239 --> 00:02:48,319
and you're kind of stuck with those

00:02:47,599 --> 00:02:50,160
tools

00:02:48,319 --> 00:02:52,160
and in the last seven years i've been

00:02:50,160 --> 00:02:54,560
doing embedded development

00:02:52,160 --> 00:02:56,080
i have always been using those tools and

00:02:54,560 --> 00:02:57,599
for every project it was a different

00:02:56,080 --> 00:02:58,400
tool and you always have to relearn

00:02:57,599 --> 00:03:01,280
stuff

00:02:58,400 --> 00:03:03,120
and even in the open source community

00:03:01,280 --> 00:03:04,239
some tools require conflicts you don't

00:03:03,120 --> 00:03:06,879
really understand it

00:03:04,239 --> 00:03:09,440
it was always kind of magic to me and

00:03:06,879 --> 00:03:10,239
then in 2019 shortly before the first

00:03:09,440 --> 00:03:12,239
oxidized

00:03:10,239 --> 00:03:13,519
where i met a lot of folks that actually

00:03:12,239 --> 00:03:16,879
contribute now to

00:03:13,519 --> 00:03:17,280
probe rs um i started looking into those

00:03:16,879 --> 00:03:19,599
things

00:03:17,280 --> 00:03:21,040
because i was kind of disappointed with

00:03:19,599 --> 00:03:23,920
how the setup went

00:03:21,040 --> 00:03:25,920
because in rust we have those great

00:03:23,920 --> 00:03:28,239
tools such as cargo for example

00:03:25,920 --> 00:03:28,959
that really make development nice and

00:03:28,239 --> 00:03:31,760
easy

00:03:28,959 --> 00:03:33,040
and i think embedded development should

00:03:31,760 --> 00:03:36,159
be fun too

00:03:33,040 --> 00:03:37,680
so we have many cool tools with a lot of

00:03:36,159 --> 00:03:38,319
features but they're not really nice to

00:03:37,680 --> 00:03:41,599
use and

00:03:38,319 --> 00:03:41,599
we tried to change that

00:03:41,760 --> 00:03:45,519
so in the traditional debug setup you

00:03:44,480 --> 00:03:49,120
have

00:03:45,519 --> 00:03:51,280
a target here at the bottom that is

00:03:49,120 --> 00:03:53,200
a cpu of a different architecture than

00:03:51,280 --> 00:03:54,400
your host at the top where you write

00:03:53,200 --> 00:03:56,720
code on

00:03:54,400 --> 00:03:58,799
and those two can't really speak with

00:03:56,720 --> 00:04:01,840
each other so you need a debug probe

00:03:58,799 --> 00:04:02,080
here in the middle that translates sort

00:04:01,840 --> 00:04:05,200
of

00:04:02,080 --> 00:04:08,239
on the protocol that the target cpu uses

00:04:05,200 --> 00:04:10,159
and this is mostly swd or jtag

00:04:08,239 --> 00:04:11,439
and this is a standardized interface

00:04:10,159 --> 00:04:14,159
which is different

00:04:11,439 --> 00:04:15,280
for each architectures sure some share a

00:04:14,159 --> 00:04:17,280
common interface

00:04:15,280 --> 00:04:18,880
but this is basically defined by the

00:04:17,280 --> 00:04:22,240
architecture

00:04:18,880 --> 00:04:24,560
and it is well documented too and then

00:04:22,240 --> 00:04:26,400
on the host side the debug probe mostly

00:04:24,560 --> 00:04:28,240
uses a proprietary interface

00:04:26,400 --> 00:04:30,000
there is some standards defined by arm

00:04:28,240 --> 00:04:32,160
but not everybody uses them

00:04:30,000 --> 00:04:33,199
and it's really tricky to get this right

00:04:32,160 --> 00:04:35,680
because

00:04:33,199 --> 00:04:36,800
not all debug probes use the same level

00:04:35,680 --> 00:04:38,880
of abstraction so

00:04:36,800 --> 00:04:40,639
some are higher level interfaces and

00:04:38,880 --> 00:04:42,639
some are lower level interfaces

00:04:40,639 --> 00:04:44,080
so this is kind of a tricky point to get

00:04:42,639 --> 00:04:47,360
this run

00:04:44,080 --> 00:04:48,000
and of course we have been writing rost

00:04:47,360 --> 00:04:50,000
software

00:04:48,000 --> 00:04:51,120
on the target in the form of firmware

00:04:50,000 --> 00:04:53,520
for a long time

00:04:51,120 --> 00:04:55,360
and now with probe rs we have also

00:04:53,520 --> 00:04:59,360
implemented those interfaces

00:04:55,360 --> 00:05:01,680
um in ros2 uh swd and jtag

00:04:59,360 --> 00:05:02,720
and of course the host site interface to

00:05:01,680 --> 00:05:04,240
talk with the probe

00:05:02,720 --> 00:05:05,919
and of course you have written a lot of

00:05:04,240 --> 00:05:07,199
software that is running on the host so

00:05:05,919 --> 00:05:09,120
so this is rust2

00:05:07,199 --> 00:05:10,560
and the only missing piece really is the

00:05:09,120 --> 00:05:13,840
probe which is still

00:05:10,560 --> 00:05:15,600
proprietary so and

00:05:13,840 --> 00:05:18,320
on the host of course there is a whole

00:05:15,600 --> 00:05:22,000
stack of applications i have listed them

00:05:18,320 --> 00:05:22,720
a few slides earlier that you normally

00:05:22,000 --> 00:05:26,000
use

00:05:22,720 --> 00:05:28,000
so traditionally you have a target here

00:05:26,000 --> 00:05:29,520
at the bottom again and then in the

00:05:28,000 --> 00:05:31,440
middle you have a debugger

00:05:29,520 --> 00:05:33,520
in the form of gdp mostly at least for

00:05:31,440 --> 00:05:34,000
open source embedded development but

00:05:33,520 --> 00:05:36,160
many

00:05:34,000 --> 00:05:37,280
manufacturers actually ship ship it

00:05:36,160 --> 00:05:40,080
inside their

00:05:37,280 --> 00:05:40,800
their eclipse based distribution or the

00:05:40,080 --> 00:05:42,479
likes

00:05:40,800 --> 00:05:44,960
and then you have a ui on top

00:05:42,479 --> 00:05:47,520
traditionally i know it's from eclipse

00:05:44,960 --> 00:05:49,280
but uh many folks nowadays for example

00:05:47,520 --> 00:05:51,600
use vs code of course

00:05:49,280 --> 00:05:52,800
um such as you would know it from normal

00:05:51,600 --> 00:05:55,919
x64

00:05:52,800 --> 00:05:58,639
development but in between

00:05:55,919 --> 00:06:00,319
those three components you have on one

00:05:58,639 --> 00:06:03,680
side the gdp stop which is

00:06:00,319 --> 00:06:05,919
the gdp server and it basically

00:06:03,680 --> 00:06:07,039
translates the gtp commands such as read

00:06:05,919 --> 00:06:10,160
memory write memory

00:06:07,039 --> 00:06:12,560
etc to commands the target understands

00:06:10,160 --> 00:06:14,960
and yields the data back

00:06:12,560 --> 00:06:16,319
so so this is sort of the probe driver

00:06:14,960 --> 00:06:18,639
right and

00:06:16,319 --> 00:06:22,479
every probe manufacturer ships their own

00:06:18,639 --> 00:06:24,720
flavor of gdd stuff so you always have

00:06:22,479 --> 00:06:26,960
the interface is always similar but for

00:06:24,720 --> 00:06:28,560
example i'm flashing a target this is

00:06:26,960 --> 00:06:29,680
not always the same for each and every

00:06:28,560 --> 00:06:32,720
target

00:06:29,680 --> 00:06:34,960
and the same is

00:06:32,720 --> 00:06:36,479
on the other side you have the gdbmi the

00:06:34,960 --> 00:06:39,199
machine interface

00:06:36,479 --> 00:06:40,639
which sort of provides a machine

00:06:39,199 --> 00:06:43,759
readable interface to

00:06:40,639 --> 00:06:45,759
the gdp ui that

00:06:43,759 --> 00:06:48,319
for example an editor can use to

00:06:45,759 --> 00:06:51,520
actually interface the debugger

00:06:48,319 --> 00:06:53,520
but then again the the editor needs

00:06:51,520 --> 00:06:54,720
another plugin which speaks this machine

00:06:53,520 --> 00:06:57,440
interface so you get

00:06:54,720 --> 00:06:59,680
all these different interfaces and this

00:06:57,440 --> 00:07:00,880
sort of layer cake which can be unstable

00:06:59,680 --> 00:07:04,319
at times

00:07:00,880 --> 00:07:07,520
so what we are aiming for is eliminating

00:07:04,319 --> 00:07:08,560
all those interfaces that can cause

00:07:07,520 --> 00:07:10,560
friction

00:07:08,560 --> 00:07:11,840
and provide one single block in the

00:07:10,560 --> 00:07:13,520
middle here named as

00:07:11,840 --> 00:07:15,680
server and also marked with a rust

00:07:13,520 --> 00:07:16,000
symbol because we already have written

00:07:15,680 --> 00:07:19,599
that

00:07:16,000 --> 00:07:21,280
in rust um which is sort of the

00:07:19,599 --> 00:07:22,720
missing link between the ui and the

00:07:21,280 --> 00:07:25,120
target because

00:07:22,720 --> 00:07:26,960
um many editors nowadays provide at

00:07:25,120 --> 00:07:29,840
least some sort of ui to debug

00:07:26,960 --> 00:07:30,720
um and there's also standardized

00:07:29,840 --> 00:07:34,160
interfaces

00:07:30,720 --> 00:07:35,919
to implement this so

00:07:34,160 --> 00:07:37,759
this simplifies the entire chain and

00:07:35,919 --> 00:07:41,120
should remove a lot of

00:07:37,759 --> 00:07:43,360
problems so

00:07:41,120 --> 00:07:44,960
here are some of the probe rs benefits

00:07:43,360 --> 00:07:48,400
that we can get

00:07:44,960 --> 00:07:51,759
or that we try to to achieve

00:07:48,400 --> 00:07:53,520
so as i said we want to have an editor

00:07:51,759 --> 00:07:54,319
of our choice for me this would be

00:07:53,520 --> 00:07:58,960
ideally

00:07:54,319 --> 00:08:01,520
vs code and we try to make um

00:07:58,960 --> 00:08:02,240
pro bars as a library such that you can

00:08:01,520 --> 00:08:05,280
use it

00:08:02,240 --> 00:08:06,319
um or that you can just put a thin layer

00:08:05,280 --> 00:08:08,560
of ui on top

00:08:06,319 --> 00:08:10,160
or a little server such that it can

00:08:08,560 --> 00:08:11,919
interact with your own tools so you

00:08:10,160 --> 00:08:12,639
don't have to write any weird script or

00:08:11,919 --> 00:08:15,520
something

00:08:12,639 --> 00:08:17,120
but you have a clean rust api and we try

00:08:15,520 --> 00:08:19,599
to document this

00:08:17,120 --> 00:08:20,400
properly it's not always the case yet

00:08:19,599 --> 00:08:22,000
and what's

00:08:20,400 --> 00:08:23,520
very important to is that it is

00:08:22,000 --> 00:08:26,639
streamlined so

00:08:23,520 --> 00:08:29,039
for example in open ocd

00:08:26,639 --> 00:08:30,160
you have for different architectures you

00:08:29,039 --> 00:08:31,919
have

00:08:30,160 --> 00:08:33,519
different commands to read memory for

00:08:31,919 --> 00:08:36,000
example

00:08:33,519 --> 00:08:37,120
and we try to not make this different

00:08:36,000 --> 00:08:39,680
because the user

00:08:37,120 --> 00:08:41,039
is mostly interested in executing a

00:08:39,680 --> 00:08:43,039
command on the core for example read

00:08:41,039 --> 00:08:45,600
memory and this this is always the same

00:08:43,039 --> 00:08:46,880
from a user perspective right so the

00:08:45,600 --> 00:08:49,279
user shouldn't be

00:08:46,880 --> 00:08:50,560
forced into using different commands and

00:08:49,279 --> 00:08:54,000
learning different

00:08:50,560 --> 00:08:58,240
interfaces but they should just need to

00:08:54,000 --> 00:09:01,519
to do a memory read right um yeah

00:08:58,240 --> 00:09:03,440
so and for our binary tools and also

00:09:01,519 --> 00:09:05,120
library usage we strive for a simple

00:09:03,440 --> 00:09:06,880
setup and usage of course

00:09:05,120 --> 00:09:08,880
uh such that you that the user can

00:09:06,880 --> 00:09:11,040
really go developing and not

00:09:08,880 --> 00:09:12,399
just setting up tools right for all

00:09:11,040 --> 00:09:15,040
eternity

00:09:12,399 --> 00:09:16,880
um we're trying to use uh standard

00:09:15,040 --> 00:09:20,080
protocols or de facto

00:09:16,880 --> 00:09:23,279
standards um from microsoft and arm

00:09:20,080 --> 00:09:24,480
mostly and we're trying to be as rust

00:09:23,279 --> 00:09:27,600
friendly as possible

00:09:24,480 --> 00:09:29,120
so we're providing cargo plug-ins but

00:09:27,600 --> 00:09:30,880
pro bars should really be language

00:09:29,120 --> 00:09:33,519
agnostic in its core

00:09:30,880 --> 00:09:36,640
so the library can be interfaced with

00:09:33,519 --> 00:09:39,760
ffi of course in other languages um

00:09:36,640 --> 00:09:40,720
and all the cargo plug-ins could be used

00:09:39,760 --> 00:09:43,440
as standalone

00:09:40,720 --> 00:09:44,720
applications too and if we ever have

00:09:43,440 --> 00:09:46,800
some time to spare

00:09:44,720 --> 00:09:48,160
we will of course make this even better

00:09:46,800 --> 00:09:50,959
by maybe not naming it

00:09:48,160 --> 00:09:52,959
cargo flash but rather just flash or

00:09:50,959 --> 00:09:54,560
whatever the tools name then is

00:09:52,959 --> 00:09:56,480
and we try to actively encourage

00:09:54,560 --> 00:10:00,480
contribution um

00:09:56,480 --> 00:10:02,800
by having the library on github

00:10:00,480 --> 00:10:04,399
such that we really motivate people to

00:10:02,800 --> 00:10:07,040
contribute to the project

00:10:04,399 --> 00:10:09,040
and i try to be as active as possible on

00:10:07,040 --> 00:10:11,519
matrix2 where we have our chat room

00:10:09,040 --> 00:10:13,440
so that we can exchange ideas that not

00:10:11,519 --> 00:10:16,079
one person just defines the

00:10:13,440 --> 00:10:18,320
entire interface such that really all

00:10:16,079 --> 00:10:21,120
ideas can be combined in this one

00:10:18,320 --> 00:10:21,120
great library

00:10:22,399 --> 00:10:26,240
so i've talked a bit about what probe rs

00:10:25,760 --> 00:10:30,800
can do

00:10:26,240 --> 00:10:34,000
and what it should be if possible

00:10:30,800 --> 00:10:35,279
but now let me show you please how

00:10:34,000 --> 00:10:38,320
simple it really is

00:10:35,279 --> 00:10:40,800
so let me make a small example

00:10:38,320 --> 00:10:42,079
so let us have this imaginary program

00:10:40,800 --> 00:10:46,000
that just increases

00:10:42,079 --> 00:10:48,800
a counter at the memory location in ram

00:10:46,000 --> 00:10:50,079
then let's flash that program then reset

00:10:48,800 --> 00:10:52,240
and hold the cpu to

00:10:50,079 --> 00:10:53,279
get it into a known state then we set

00:10:52,240 --> 00:10:56,240
the breakpoint

00:10:53,279 --> 00:10:58,000
after the counter or at the memory

00:10:56,240 --> 00:10:59,279
location in flash where the counter will

00:10:58,000 --> 00:11:01,440
be incremented

00:10:59,279 --> 00:11:02,320
then we wait for the cpu to halt read

00:11:01,440 --> 00:11:04,160
the counter

00:11:02,320 --> 00:11:06,480
and we repeat the last two points such

00:11:04,160 --> 00:11:08,560
that we can see the counter incrementing

00:11:06,480 --> 00:11:11,920
uh or the counter is incrementing on the

00:11:08,560 --> 00:11:14,800
target and we can see it on the host

00:11:11,920 --> 00:11:15,519
so first of all we are acquiring a

00:11:14,800 --> 00:11:17,600
session

00:11:15,519 --> 00:11:19,839
um this is just a struct that holds a

00:11:17,600 --> 00:11:23,440
handle to our probe internally

00:11:19,839 --> 00:11:24,240
and a handle to our more specific target

00:11:23,440 --> 00:11:27,519
description

00:11:24,240 --> 00:11:31,360
in this case this is the nrf52

00:11:27,519 --> 00:11:35,200
um yeah

00:11:31,360 --> 00:11:38,959
so then we're

00:11:35,200 --> 00:11:41,519
flashing the elf binary onto our target

00:11:38,959 --> 00:11:42,720
we just do this by handing the session

00:11:41,519 --> 00:11:45,600
to the function

00:11:42,720 --> 00:11:45,920
the elf path and a form it we could also

00:11:45,600 --> 00:11:48,800
use

00:11:45,920 --> 00:11:49,440
uh bind pure binary format or intel hex

00:11:48,800 --> 00:11:52,880
here

00:11:49,440 --> 00:11:53,360
so we support all three so this is this

00:11:52,880 --> 00:11:56,399
is really

00:11:53,360 --> 00:11:59,920
convenient uh normal magic to that

00:11:56,399 --> 00:12:01,920
and then um we get a core handle

00:11:59,920 --> 00:12:04,720
in this case core zero because there's

00:12:01,920 --> 00:12:08,959
just one core on the nrf52

00:12:04,720 --> 00:12:08,959
and we reset and hold the core

00:12:09,120 --> 00:12:13,200
and then we can already set the

00:12:11,360 --> 00:12:16,000
breakpoint at this imaginary

00:12:13,200 --> 00:12:16,560
location in flash where the code resides

00:12:16,000 --> 00:12:21,360
um

00:12:16,560 --> 00:12:24,880
after the counter has been increased

00:12:21,360 --> 00:12:26,240
and then we run the core um because yeah

00:12:24,880 --> 00:12:28,800
it's halted at the moment

00:12:26,240 --> 00:12:29,279
um we wait for the core to be halted

00:12:28,800 --> 00:12:31,040
again

00:12:29,279 --> 00:12:32,639
because it will hold once the breakpoint

00:12:31,040 --> 00:12:36,959
is hit right

00:12:32,639 --> 00:12:39,040
and then we will read one 32-bit words

00:12:36,959 --> 00:12:40,160
at the location in ram where the counter

00:12:39,040 --> 00:12:43,920
resides

00:12:40,160 --> 00:12:45,839
so this is really simple and easy

00:12:43,920 --> 00:12:47,360
and as you can see we have control over

00:12:45,839 --> 00:12:49,360
the entire cpu

00:12:47,360 --> 00:12:51,600
so this is really neat because now we

00:12:49,360 --> 00:12:55,360
have a library which enables us

00:12:51,600 --> 00:12:56,560
to create any any sort of magic tool

00:12:55,360 --> 00:12:59,440
that can

00:12:56,560 --> 00:13:00,560
let us inspect and inspect our cpu talk

00:12:59,440 --> 00:13:02,959
to it

00:13:00,560 --> 00:13:06,880
flash and heal finally etc so this is

00:13:02,959 --> 00:13:09,120
really cool

00:13:06,880 --> 00:13:10,079
a little bit about how the probe r

00:13:09,120 --> 00:13:12,399
structure works

00:13:10,079 --> 00:13:13,279
i won't go into too much details but

00:13:12,399 --> 00:13:15,839
just to give you an

00:13:13,279 --> 00:13:16,800
overview um how this all conceptually

00:13:15,839 --> 00:13:19,920
works

00:13:16,800 --> 00:13:21,839
so we tried to have the structure as

00:13:19,920 --> 00:13:25,279
close as possible to how this

00:13:21,839 --> 00:13:28,320
actually physically works uh in

00:13:25,279 --> 00:13:31,600
in like a probe and core sense so

00:13:28,320 --> 00:13:34,639
on the lowest level in the probe rs

00:13:31,600 --> 00:13:35,600
space so to say and we have the probe

00:13:34,639 --> 00:13:38,000
drivers

00:13:35,600 --> 00:13:38,959
so we provide a trait that is used by

00:13:38,000 --> 00:13:42,880
the probe struct

00:13:38,959 --> 00:13:43,600
internally that implementers of a probe

00:13:42,880 --> 00:13:45,760
can

00:13:43,600 --> 00:13:47,040
implement so for the chaining for the

00:13:45,760 --> 00:13:50,079
sd-link and for the

00:13:47,040 --> 00:13:52,079
cmc stuff we already provide this

00:13:50,079 --> 00:13:53,839
but if you were to manufacture your own

00:13:52,079 --> 00:13:54,399
probe you could implement a driver for

00:13:53,839 --> 00:13:56,560
your probe

00:13:54,399 --> 00:13:58,000
just by implementing this trade so this

00:13:56,560 --> 00:14:00,079
should be really easy

00:13:58,000 --> 00:14:01,360
and all the internals use uh this

00:14:00,079 --> 00:14:04,800
trademark

00:14:01,360 --> 00:14:05,360
and then on the next level we we have a

00:14:04,800 --> 00:14:07,199
core

00:14:05,360 --> 00:14:08,880
it works basically the same we have a

00:14:07,199 --> 00:14:11,440
trade that you would implement for

00:14:08,880 --> 00:14:12,560
each and every different architecture so

00:14:11,440 --> 00:14:16,560
at the moment we have

00:14:12,560 --> 00:14:17,279
our v6 rmv7 um i guess rmb8 is to come

00:14:16,560 --> 00:14:20,399
soon

00:14:17,279 --> 00:14:22,160
and then we have risk v and maybe

00:14:20,399 --> 00:14:23,360
someone is to implement avr in the

00:14:22,160 --> 00:14:25,279
future for example

00:14:23,360 --> 00:14:27,120
and this is really just implementing a

00:14:25,279 --> 00:14:30,880
trade more or less

00:14:27,120 --> 00:14:34,160
and then we have the target descriptions

00:14:30,880 --> 00:14:36,639
which are sort of uh

00:14:34,160 --> 00:14:37,760
a better or a more uh in detailed

00:14:36,639 --> 00:14:40,480
description

00:14:37,760 --> 00:14:41,680
of all the targets there are for example

00:14:40,480 --> 00:14:44,720
the nrf52

00:14:41,680 --> 00:14:46,240
840 which describes the target memory

00:14:44,720 --> 00:14:48,399
locations and sizes

00:14:46,240 --> 00:14:49,279
and their flash algorithms a little bit

00:14:48,399 --> 00:14:52,399
more about that

00:14:49,279 --> 00:14:54,240
in a second and then uh at the top level

00:14:52,399 --> 00:14:55,760
we have the session struct we have seen

00:14:54,240 --> 00:14:59,199
in the code example two

00:14:55,760 --> 00:15:02,320
it just holds a reference the probe

00:14:59,199 --> 00:15:05,040
and the target description and it holds

00:15:02,320 --> 00:15:07,199
core state sort of internally and you

00:15:05,040 --> 00:15:09,680
can get a handle to a core

00:15:07,199 --> 00:15:10,320
by pulling the session for the core

00:15:09,680 --> 00:15:12,959
handle

00:15:10,320 --> 00:15:13,600
and then you can control the core from

00:15:12,959 --> 00:15:16,240
that so

00:15:13,600 --> 00:15:18,000
the session is just really a top level

00:15:16,240 --> 00:15:21,920
uh entry

00:15:18,000 --> 00:15:23,199
um entry struct um which manages all

00:15:21,920 --> 00:15:26,399
state

00:15:23,199 --> 00:15:28,160
and then this is basically probe rs and

00:15:26,399 --> 00:15:30,880
on top of that we can build third party

00:15:28,160 --> 00:15:34,399
libraries for example probe rsrt

00:15:30,880 --> 00:15:36,000
um a gtp stop or our flashing tools

00:15:34,399 --> 00:15:37,519
of course the flashing tools are inside

00:15:36,000 --> 00:15:40,880
probe rs because they're

00:15:37,519 --> 00:15:42,000
commonly used uh very often but it's

00:15:40,880 --> 00:15:45,920
really just

00:15:42,000 --> 00:15:48,079
building on the layers below and

00:15:45,920 --> 00:15:49,519
on top of that we can build applications

00:15:48,079 --> 00:15:53,199
for example cargo flash

00:15:49,519 --> 00:15:55,920
cargo embeds or our vs code plugin so

00:15:53,199 --> 00:15:57,120
oftentimes people ask me is this already

00:15:55,920 --> 00:15:59,920
in cargo flash

00:15:57,120 --> 00:16:02,160
um or cargo embed or they if they issue

00:15:59,920 --> 00:16:04,160
an issue over there in the repost

00:16:02,160 --> 00:16:05,279
but all the functionality is really in

00:16:04,160 --> 00:16:07,600
probe rs

00:16:05,279 --> 00:16:09,120
so if we add a new target or new

00:16:07,600 --> 00:16:12,480
functionality in general

00:16:09,120 --> 00:16:14,480
this will always be in probe rs so

00:16:12,480 --> 00:16:16,079
if you install the newest tool and it

00:16:14,480 --> 00:16:16,399
uses the newest version of pro virus you

00:16:16,079 --> 00:16:18,320
get

00:16:16,399 --> 00:16:20,480
all this functionality so so this is

00:16:18,320 --> 00:16:21,680
really cool so it really doesn't depend

00:16:20,480 --> 00:16:23,680
on the application

00:16:21,680 --> 00:16:25,279
so the application is a very thin ui

00:16:23,680 --> 00:16:25,920
layer that basically just parses

00:16:25,279 --> 00:16:29,519
arguments

00:16:25,920 --> 00:16:31,680
and passes them to pro bars

00:16:29,519 --> 00:16:33,759
and so i've spoken a little bit about

00:16:31,680 --> 00:16:37,759
those flash algorithms

00:16:33,759 --> 00:16:39,120
so those are um elf blobs that we flash

00:16:37,759 --> 00:16:41,440
onto the target that

00:16:39,120 --> 00:16:42,560
are into ram that manage the flashing

00:16:41,440 --> 00:16:45,759
process

00:16:42,560 --> 00:16:48,880
um and this would be huge work

00:16:45,759 --> 00:16:51,759
and also describing all the memory

00:16:48,880 --> 00:16:53,279
properties of the different targets we

00:16:51,759 --> 00:16:56,079
couldn't do all that work

00:16:53,279 --> 00:16:56,320
i think or at least it would take years

00:16:56,079 --> 00:16:59,920
or

00:16:56,320 --> 00:17:02,320
many many many work hours

00:16:59,920 --> 00:17:04,079
this is where cm6 packs come in handy so

00:17:02,320 --> 00:17:08,319
this is an arm standard

00:17:04,079 --> 00:17:11,120
um for target descriptions so

00:17:08,319 --> 00:17:12,559
these cm cmss packs contain all the

00:17:11,120 --> 00:17:14,640
flash algorithms the

00:17:12,559 --> 00:17:15,760
target descriptions and they're

00:17:14,640 --> 00:17:19,520
implemented by

00:17:15,760 --> 00:17:21,760
the vendors of the targets so that means

00:17:19,520 --> 00:17:24,079
we don't get to do any work and we still

00:17:21,760 --> 00:17:26,559
get thousands of available targets

00:17:24,079 --> 00:17:27,679
and many of those targets are to be

00:17:26,559 --> 00:17:30,720
included soon

00:17:27,679 --> 00:17:32,799
uh yeah we can just export them

00:17:30,720 --> 00:17:35,600
so this is really really great that this

00:17:32,799 --> 00:17:39,280
was done by arm

00:17:35,600 --> 00:17:41,360
so i've talked a little bit about

00:17:39,280 --> 00:17:42,880
how everything looks like and what it

00:17:41,360 --> 00:17:45,200
should be optimally

00:17:42,880 --> 00:17:46,720
so at the moment we have a few binary

00:17:45,200 --> 00:17:48,080
tools and we have this library that's

00:17:46,720 --> 00:17:50,080
working great actually

00:17:48,080 --> 00:17:51,440
but of course we can always extend the

00:17:50,080 --> 00:17:53,520
tool set so

00:17:51,440 --> 00:17:56,000
what's planned next of course is the vs

00:17:53,520 --> 00:17:58,480
code plugin so we have a working plugin

00:17:56,000 --> 00:17:59,679
but it's very early alpha state and it

00:17:58,480 --> 00:18:02,720
uses the microsoft app

00:17:59,679 --> 00:18:06,000
this is a modern json api for debugger

00:18:02,720 --> 00:18:10,400
interfaces and this is implemented in in

00:18:06,000 --> 00:18:12,559
vim and emacs 2 for example

00:18:10,400 --> 00:18:13,600
and i'm sure it will get into other

00:18:12,559 --> 00:18:15,840
editors soon too

00:18:13,600 --> 00:18:17,919
just like the language server protocol

00:18:15,840 --> 00:18:20,080
has been implemented by many too

00:18:17,919 --> 00:18:21,840
and this means we get rid of the entire

00:18:20,080 --> 00:18:23,600
gtb stack in between

00:18:21,840 --> 00:18:25,120
of course this means a little bit more

00:18:23,600 --> 00:18:26,000
work because we have to implement all

00:18:25,120 --> 00:18:28,799
the debugging

00:18:26,000 --> 00:18:30,640
things ourselves but there's cool rust

00:18:28,799 --> 00:18:31,280
projects coming up that do this already

00:18:30,640 --> 00:18:33,919
so

00:18:31,280 --> 00:18:35,360
maybe we can tap into that and as of now

00:18:33,919 --> 00:18:37,520
i think we can

00:18:35,360 --> 00:18:38,720
we can print the stack trace we can look

00:18:37,520 --> 00:18:42,480
at the stack frame very

00:18:38,720 --> 00:18:45,200
rudimentary just point to values we can

00:18:42,480 --> 00:18:46,960
run step and halts and maybe even set

00:18:45,200 --> 00:18:47,280
breakpoints i'm not entirely sure how

00:18:46,960 --> 00:18:49,039
far

00:18:47,280 --> 00:18:51,440
that is and you can check it out on

00:18:49,039 --> 00:18:55,520
github have a look try it out

00:18:51,440 --> 00:18:57,520
contribute codes it's going to be cool

00:18:55,520 --> 00:18:59,039
and then the next thing uh i have been

00:18:57,520 --> 00:19:01,760
discussing on the probe rs channel

00:18:59,039 --> 00:19:02,880
just a minute before the talk um with

00:19:01,760 --> 00:19:05,840
brian cantrell and

00:19:02,880 --> 00:19:06,240
uh adam greek uh two um we're trying to

00:19:05,840 --> 00:19:09,280
get

00:19:06,240 --> 00:19:11,280
itm uh into master uh

00:19:09,280 --> 00:19:13,440
after this weekend so we're trying to

00:19:11,280 --> 00:19:15,039
implement this during the input days

00:19:13,440 --> 00:19:17,520
so for those of you who don't know what

00:19:15,039 --> 00:19:21,679
itm is this is really really powerful

00:19:17,520 --> 00:19:25,039
data streaming on arm v7 and rmd8

00:19:21,679 --> 00:19:27,120
and it enables you to track uh interrupt

00:19:25,039 --> 00:19:29,280
events and memory access events

00:19:27,120 --> 00:19:30,480
uh which then are streamed out in a uart

00:19:29,280 --> 00:19:32,320
kinda interface

00:19:30,480 --> 00:19:33,760
and you can also send custom binary data

00:19:32,320 --> 00:19:36,480
so this is really cool for

00:19:33,760 --> 00:19:38,960
uh tracing your target in real time

00:19:36,480 --> 00:19:41,120
because this doesn't use any cpu cycles

00:19:38,960 --> 00:19:42,480
or additional ct cycles so this is

00:19:41,120 --> 00:19:44,160
around the corner

00:19:42,480 --> 00:19:45,840
and there's an open pull request and

00:19:44,160 --> 00:19:47,760
there's lots of features coming i

00:19:45,840 --> 00:19:49,600
won't go through them for time reasons

00:19:47,760 --> 00:19:50,240
but you can find it in the presentation

00:19:49,600 --> 00:19:54,160
if you

00:19:50,240 --> 00:19:57,280
scroll down i will publish that later on

00:19:54,160 --> 00:20:00,640
so now uh for a short demo because

00:19:57,280 --> 00:20:03,120
i guess most of you um i mean sure

00:20:00,640 --> 00:20:04,960
the library is cool to use but most of

00:20:03,120 --> 00:20:06,720
you are interested in flashing a target

00:20:04,960 --> 00:20:09,360
or actually

00:20:06,720 --> 00:20:11,200
debugging a target right so we provide

00:20:09,360 --> 00:20:13,840
two cool binary tools for that

00:20:11,200 --> 00:20:15,600
and the first one is cargo flash so i'm

00:20:13,840 --> 00:20:18,720
here inside the nordic

00:20:15,600 --> 00:20:20,240
dev kits repository and

00:20:18,720 --> 00:20:22,799
just to show you the structure it's just

00:20:20,240 --> 00:20:24,560
a normal uh rust project

00:20:22,799 --> 00:20:25,840
and um

00:20:24,560 --> 00:20:28,960
[Music]

00:20:25,840 --> 00:20:29,280
yeah we can uh normally we can we could

00:20:28,960 --> 00:20:32,880
do

00:20:29,280 --> 00:20:34,400
cargo cargo run um and then dash dash

00:20:32,880 --> 00:20:37,520
release

00:20:34,400 --> 00:20:40,400
and an example blinky

00:20:37,520 --> 00:20:41,919
and this of course i'm sorry this of

00:20:40,400 --> 00:20:44,240
course won't work because we're

00:20:41,919 --> 00:20:46,320
not having the right target architecture

00:20:44,240 --> 00:20:49,360
we also don't have sdg

00:20:46,320 --> 00:20:51,280
etc but what we can do is use our

00:20:49,360 --> 00:20:52,720
in-place replacement so we just replace

00:20:51,280 --> 00:20:56,400
run with flash

00:20:52,720 --> 00:20:59,760
and we add our chip um at the end

00:20:56,400 --> 00:21:01,600
this is the nrf 52 840

00:20:59,760 --> 00:21:03,679
and then we can flash the blinky onto

00:21:01,600 --> 00:21:05,679
the dev kit i have here with me i

00:21:03,679 --> 00:21:07,120
i think we can't really see it well but

00:21:05,679 --> 00:21:09,039
it shouldn't blink yet

00:21:07,120 --> 00:21:11,039
oh the camera even does a nice job so it

00:21:09,039 --> 00:21:12,720
should flash and now it should blink

00:21:11,039 --> 00:21:14,640
so this is really simple we have a clean

00:21:12,720 --> 00:21:15,440
interface and there's a lot of comfort

00:21:14,640 --> 00:21:18,240
flags

00:21:15,440 --> 00:21:19,520
which we can configure the entire

00:21:18,240 --> 00:21:21,840
process

00:21:19,520 --> 00:21:23,520
and of course always putting all those

00:21:21,840 --> 00:21:24,960
flags onto the command line is not

00:21:23,520 --> 00:21:27,200
really nice especially when you want to

00:21:24,960 --> 00:21:30,080
configure the probe or the speed

00:21:27,200 --> 00:21:30,880
or you want to have rtt working or a gdp

00:21:30,080 --> 00:21:34,720
server

00:21:30,880 --> 00:21:36,720
so we provide a second tool called cargo

00:21:34,720 --> 00:21:38,480
embed and this is sort of the big

00:21:36,720 --> 00:21:41,679
brother of cargo flash

00:21:38,480 --> 00:21:45,280
that can also do rtt things

00:21:41,679 --> 00:21:47,200
etc and it really um doesn't need any

00:21:45,280 --> 00:21:50,240
more arguments because there is this

00:21:47,200 --> 00:21:53,280
embed tumble here at the top which

00:21:50,240 --> 00:21:56,960
has all those configurations stored

00:21:53,280 --> 00:22:00,240
and yeah so um when we

00:21:56,960 --> 00:22:02,080
run this command um let's

00:22:00,240 --> 00:22:03,760
for example i have to put an example of

00:22:02,080 --> 00:22:06,320
course rtp

00:22:03,760 --> 00:22:08,320
it should flash the example onto the

00:22:06,320 --> 00:22:09,919
board and open this rtt console

00:22:08,320 --> 00:22:11,360
so we can't really see any output yet

00:22:09,919 --> 00:22:14,559
but if we switch to tab two

00:22:11,360 --> 00:22:16,480
we can see uh what it tells us um

00:22:14,559 --> 00:22:18,240
that we can type on channel one and it

00:22:16,480 --> 00:22:22,159
will return it to us

00:22:18,240 --> 00:22:27,840
so we can type for example um hello

00:22:22,159 --> 00:22:27,840
oops oxygen

00:22:30,400 --> 00:22:34,320
and it will return just in caps so this

00:22:32,559 --> 00:22:35,520
is really communication from the host to

00:22:34,320 --> 00:22:36,320
the target and it should be really

00:22:35,520 --> 00:22:38,960
convenient

00:22:36,320 --> 00:22:40,000
and we will only expand only expand

00:22:38,960 --> 00:22:42,799
those tools even more

00:22:40,000 --> 00:22:44,400
in the coming weeks and months so they

00:22:42,799 --> 00:22:48,320
should really provide a nice

00:22:44,400 --> 00:22:52,159
development experience so

00:22:48,320 --> 00:22:54,799
uh to hop back into the slides

00:22:52,159 --> 00:22:55,360
so i've been talking about this debug

00:22:54,799 --> 00:22:57,200
chain

00:22:55,360 --> 00:22:58,559
uh at the beginning of my talk and the

00:22:57,200 --> 00:23:00,400
only missing piece here

00:22:58,559 --> 00:23:03,360
is really the piece in between so the

00:23:00,400 --> 00:23:06,080
probe um which has not been done in ross

00:23:03,360 --> 00:23:06,400
but a few folks from the pro bars team

00:23:06,080 --> 00:23:08,960
uh

00:23:06,400 --> 00:23:10,799
namely corkin this awesome and adam

00:23:08,960 --> 00:23:12,640
greek have been really hard at work

00:23:10,799 --> 00:23:14,080
and we have this uh little debug probe

00:23:12,640 --> 00:23:16,880
here which operates

00:23:14,080 --> 00:23:18,559
um fully with rust firmware and it

00:23:16,880 --> 00:23:22,400
implements the cms's

00:23:18,559 --> 00:23:24,559
dab debug spec and

00:23:22,400 --> 00:23:25,600
yeah so we have the last missing piece

00:23:24,559 --> 00:23:27,760
in ros2

00:23:25,600 --> 00:23:30,559
uh the probe is extremely fast and very

00:23:27,760 --> 00:23:32,080
little and it implements this standard

00:23:30,559 --> 00:23:33,760
api so you can also use it with

00:23:32,080 --> 00:23:36,480
commercial tools such as

00:23:33,760 --> 00:23:37,520
arm keil for example and it can stream

00:23:36,480 --> 00:23:40,159
all the things

00:23:37,520 --> 00:23:40,720
you would need such as dab itm and your

00:23:40,159 --> 00:23:43,120
data

00:23:40,720 --> 00:23:44,960
and you can find it on corkin's github

00:23:43,120 --> 00:23:45,679
the firmware repository has been kept a

00:23:44,960 --> 00:23:48,640
secret

00:23:45,679 --> 00:23:50,320
it will be open sourced on the pro bars

00:23:48,640 --> 00:23:52,960
workspace soon

00:23:50,320 --> 00:23:54,640
and if you want a probe um just join the

00:23:52,960 --> 00:23:56,880
probe rs metrics channel

00:23:54,640 --> 00:23:57,760
we will see that we can get sort of dev

00:23:56,880 --> 00:24:00,799
kits out

00:23:57,760 --> 00:24:01,760
in the next few days uh we will have to

00:24:00,799 --> 00:24:03,679
set up

00:24:01,760 --> 00:24:05,600
some kind of supply chain so if you want

00:24:03,679 --> 00:24:06,960
one uh join there i will make an

00:24:05,600 --> 00:24:10,880
announcement so you can all

00:24:06,960 --> 00:24:11,520
uh join them yeah so this was it for my

00:24:10,880 --> 00:24:14,400
talk

00:24:11,520 --> 00:24:14,960
i hope uh you enjoyed it um you can find

00:24:14,400 --> 00:24:17,360
us

00:24:14,960 --> 00:24:18,320
uh on several places on the internet our

00:24:17,360 --> 00:24:21,440
web page

00:24:18,320 --> 00:24:23,279
the github organization

00:24:21,440 --> 00:24:25,760
the matrix channel where we talk a lot

00:24:23,279 --> 00:24:27,679
or mostly me spamming

00:24:25,760 --> 00:24:29,360
and then of course hit us with your

00:24:27,679 --> 00:24:31,679
questions and talk reports uh you're

00:24:29,360 --> 00:24:35,120
very welcome to report any box

00:24:31,679 --> 00:24:38,559
and of course prs are even more welcome

00:24:35,120 --> 00:24:42,080
um yeah so i guess this was it

00:24:38,559 --> 00:24:42,720
for my talk uh yeah if there are any

00:24:42,080 --> 00:24:46,400
questions

00:24:42,720 --> 00:24:47,600
i think i can answer them now i think we

00:24:46,400 --> 00:24:50,799
have a few minutes left

00:24:47,600 --> 00:24:52,320
not sure yes there are a couple of

00:24:50,799 --> 00:24:52,960
questions and a couple of discussions

00:24:52,320 --> 00:24:56,000
already got

00:24:52,960 --> 00:24:56,640
going on in the channel and the first

00:24:56,000 --> 00:25:00,279
question

00:24:56,640 --> 00:25:03,279
is when would you want to use rtt

00:25:00,279 --> 00:25:07,120
verses atm

00:25:03,279 --> 00:25:10,559
okay so rtt is platform independent

00:25:07,120 --> 00:25:13,760
the only requirement is really that um

00:25:10,559 --> 00:25:16,799
the core has the capability

00:25:13,760 --> 00:25:18,720
to let you read memory over the debug

00:25:16,799 --> 00:25:20,640
interface while it is running

00:25:18,720 --> 00:25:22,159
so this is really just two ring buffers

00:25:20,640 --> 00:25:24,400
in in the ram of the core

00:25:22,159 --> 00:25:26,240
which the host and the core access with

00:25:24,400 --> 00:25:29,360
some safety locks of course

00:25:26,240 --> 00:25:30,480
and they put data and read data from uh

00:25:29,360 --> 00:25:32,559
to and from it

00:25:30,480 --> 00:25:34,559
so this is platform independent so you

00:25:32,559 --> 00:25:38,240
could use it on avr technically

00:25:34,559 --> 00:25:40,640
on on arm or on riskview and also on arm

00:25:38,240 --> 00:25:43,360
v6 which misses itm

00:25:40,640 --> 00:25:45,440
the itm is very proprietary so to say

00:25:43,360 --> 00:25:47,600
it's only on v7 and v8

00:25:45,440 --> 00:25:48,880
but what's cool about ikea is that it

00:25:47,600 --> 00:25:52,240
has those additional

00:25:48,880 --> 00:25:52,960
um tools for streaming out uh core

00:25:52,240 --> 00:25:56,559
events

00:25:52,960 --> 00:25:59,200
such as interrupts or um

00:25:56,559 --> 00:26:01,440
memory reads and writes which would use

00:25:59,200 --> 00:26:02,880
up cpu cycles if you were to do this

00:26:01,440 --> 00:26:06,640
manually over rtt

00:26:02,880 --> 00:26:08,960
um so to say so this is really cool if

00:26:06,640 --> 00:26:11,279
you don't want to intrude your firmware

00:26:08,960 --> 00:26:12,880
but this is a one-way connection um you

00:26:11,279 --> 00:26:15,679
can only stream data from the target to

00:26:12,880 --> 00:26:17,200
your host in rtt you get both ways

00:26:15,679 --> 00:26:19,120
so yeah those are kind of the

00:26:17,200 --> 00:26:20,720
differences

00:26:19,120 --> 00:26:23,039
thank you i hope this answers the

00:26:20,720 --> 00:26:23,039
question

00:26:23,200 --> 00:26:29,840
i guess so um and then there's

00:26:26,400 --> 00:26:32,159
one other question uh with oklahoma city

00:26:29,840 --> 00:26:34,960
and a small cargo config

00:26:32,159 --> 00:26:36,720
cargo run works as a spec as expected is

00:26:34,960 --> 00:26:38,880
there a way to do something similar with

00:26:36,720 --> 00:26:41,760
cargo flash cargo embed

00:26:38,880 --> 00:26:42,640
so basically cargo run does everything

00:26:41,760 --> 00:26:45,120
yeah um

00:26:42,640 --> 00:26:46,320
i know of a few folks that do this um

00:26:45,120 --> 00:26:48,320
you can

00:26:46,320 --> 00:26:49,440
make this happen it shouldn't be a

00:26:48,320 --> 00:26:52,320
problem um

00:26:49,440 --> 00:26:54,559
you can configure cargo flash as your

00:26:52,320 --> 00:26:57,520
runner i think

00:26:54,559 --> 00:26:58,240
if not come to the probe rs channel we

00:26:57,520 --> 00:27:01,600
can figure

00:26:58,240 --> 00:27:03,600
out the solution i'm sure because it is

00:27:01,600 --> 00:27:05,600
possible to use those tools standalone

00:27:03,600 --> 00:27:06,799
at least cargo flash cargo embed misses

00:27:05,600 --> 00:27:09,360
the flag i think

00:27:06,799 --> 00:27:11,600
but in cargo flash you can point it to a

00:27:09,360 --> 00:27:21,840
specific elf binary

00:27:11,600 --> 00:27:21,840
so that works yeah

00:27:22,320 --> 00:27:24,399

YouTube URL: https://www.youtube.com/watch?v=esNPoXbhHkU


