Title: An Overview of the Embedded Rust Ecosystem
Publication date: 2020-11-06
Playlist: Oxidize Global 2020
Description: 
	If you have considered using embedded rust, you may have run into questions such as “What is embedded_hal, a pac and a hal implementation?”, “What is a driver crate?” “Where does rtfm/rtic and cortex_m fit into the picture?” This talk will give you an overview of what the crates are, how they fit together and why they exist which should give you a good place to start your embedded rust journey.
Captions: 
	00:00:01,770 --> 00:00:30,839
[Music]

00:00:32,239 --> 00:00:36,000
introduce our next

00:00:33,680 --> 00:00:37,680
speaker who is franz skarman who's going

00:00:36,000 --> 00:00:39,840
to be talking about an overview of the

00:00:37,680 --> 00:00:41,840
embedded rust ecosystem

00:00:39,840 --> 00:00:44,000
all right franz do you want to say hi

00:00:41,840 --> 00:00:46,559
real quick to make sure your mic's going

00:00:44,000 --> 00:00:47,840
hi is it working perfect sounds great so

00:00:46,559 --> 00:00:50,399
we're going to hand it over to you and

00:00:47,840 --> 00:00:54,320
we'll see you all uh at the next break

00:00:50,399 --> 00:00:54,320
all right thank you

00:00:54,879 --> 00:00:59,520
uh yeah so like james said i'm gonna

00:00:57,360 --> 00:01:01,359
talk about give you an overview on the

00:00:59,520 --> 00:01:02,879
embedded rust ecosystem and the reason i

00:01:01,359 --> 00:01:03,520
want to do this is because there are a

00:01:02,879 --> 00:01:06,320
whole lot of

00:01:03,520 --> 00:01:07,840
crates out there and what they do and

00:01:06,320 --> 00:01:09,439
their connection to each other may not

00:01:07,840 --> 00:01:11,280
always be clear we've already seen a

00:01:09,439 --> 00:01:12,080
couple of crates today like drivers and

00:01:11,280 --> 00:01:13,760
arctic

00:01:12,080 --> 00:01:15,520
and we'll probably see many more so

00:01:13,760 --> 00:01:17,119
hopefully this talk will

00:01:15,520 --> 00:01:19,520
sort of show you how everything is

00:01:17,119 --> 00:01:21,520
connected together

00:01:19,520 --> 00:01:22,720
my name is franz garman online i go by

00:01:21,520 --> 00:01:24,560
the zork2

00:01:22,720 --> 00:01:26,560
i talk too much about russ sometimes to

00:01:24,560 --> 00:01:28,159
the point where even non-programmers are

00:01:26,560 --> 00:01:31,119
talking to me about rust

00:01:28,159 --> 00:01:32,000
which is kind of strange okay to happen

00:01:31,119 --> 00:01:34,320
um

00:01:32,000 --> 00:01:35,759
in the embedded world i am a maintainer

00:01:34,320 --> 00:01:38,799
of the stm32

00:01:35,759 --> 00:01:40,240
f1xx hull crate which i hope that the

00:01:38,799 --> 00:01:41,840
name of that crate will make more sense

00:01:40,240 --> 00:01:43,600
after this talk than it does now if it

00:01:41,840 --> 00:01:45,840
doesn't make sense already

00:01:43,600 --> 00:01:47,040
and fun fact my desk is covered in rust

00:01:45,840 --> 00:01:48,880
my keyboard

00:01:47,040 --> 00:01:50,560
i hope you can see that runs thrust and

00:01:48,880 --> 00:01:53,360
a couple of other projects i have

00:01:50,560 --> 00:01:54,000
also run rust which is kind of fun

00:01:53,360 --> 00:01:55,439
that's not very

00:01:54,000 --> 00:01:57,759
important though it's more important who

00:01:55,439 --> 00:02:00,000
you are i presume uh

00:01:57,759 --> 00:02:01,360
quite a lot of you are here as embedded

00:02:00,000 --> 00:02:03,439
dress users already

00:02:01,360 --> 00:02:04,640
and then most of the content in this

00:02:03,439 --> 00:02:05,920
talk probably won't be

00:02:04,640 --> 00:02:08,399
new but feel free to stick around

00:02:05,920 --> 00:02:10,399
anyways for the people who are

00:02:08,399 --> 00:02:12,160
interested in this court talk i would

00:02:10,399 --> 00:02:12,959
assume that you come from one of three

00:02:12,160 --> 00:02:14,560
categories

00:02:12,959 --> 00:02:16,239
you may come from an arduino background

00:02:14,560 --> 00:02:17,440
where you've done embedded programming

00:02:16,239 --> 00:02:20,400
at a higher level

00:02:17,440 --> 00:02:21,440
um like arduino or maybe raspberry pi's

00:02:20,400 --> 00:02:23,200
but you haven't

00:02:21,440 --> 00:02:25,680
gone down to the lowest level of

00:02:23,200 --> 00:02:27,200
microcontroller programming

00:02:25,680 --> 00:02:29,520
you may be coming from an embedded c

00:02:27,200 --> 00:02:30,959
background um

00:02:29,520 --> 00:02:33,200
and are used to working at that lower

00:02:30,959 --> 00:02:34,959
level or you may just be a rust user who

00:02:33,200 --> 00:02:37,280
is interested in

00:02:34,959 --> 00:02:38,720
embedded development and i hope that

00:02:37,280 --> 00:02:42,560
this talk will be interesting to

00:02:38,720 --> 00:02:44,959
all three of you or these categories

00:02:42,560 --> 00:02:46,160
um so like i said the goal here is that

00:02:44,959 --> 00:02:47,840
i want to explain you

00:02:46,160 --> 00:02:49,760
to you why there are so many crates and

00:02:47,840 --> 00:02:50,000
what they do and i think the best way of

00:02:49,760 --> 00:02:53,040
doing

00:02:50,000 --> 00:02:54,879
that is by showing you the need for them

00:02:53,040 --> 00:02:56,640
sort of showing you how you can work up

00:02:54,879 --> 00:02:57,920
your way up to an ecosystem that looks

00:02:56,640 --> 00:03:00,319
the way it does today

00:02:57,920 --> 00:03:01,760
from starting from nothing and what that

00:03:00,319 --> 00:03:03,360
means in practice is that

00:03:01,760 --> 00:03:04,640
the initial code is really not something

00:03:03,360 --> 00:03:06,480
you would write in rust so don't be

00:03:04,640 --> 00:03:07,920
scared when there's a bunch of weird

00:03:06,480 --> 00:03:09,680
code on the slides

00:03:07,920 --> 00:03:10,879
it's more important to look at the sort

00:03:09,680 --> 00:03:14,319
of structure in the code than the

00:03:10,879 --> 00:03:15,840
general operations that i do

00:03:14,319 --> 00:03:17,440
with that said let's dive into this

00:03:15,840 --> 00:03:19,519
lowest level how do you program a

00:03:17,440 --> 00:03:22,159
microcontroller

00:03:19,519 --> 00:03:23,920
and generally you do that by controlling

00:03:22,159 --> 00:03:25,440
registers or writing and reading from

00:03:23,920 --> 00:03:26,799
registers in order to affect

00:03:25,440 --> 00:03:28,640
the outside world through the

00:03:26,799 --> 00:03:30,239
microcontroller's pins

00:03:28,640 --> 00:03:32,400
the registers are typically memory

00:03:30,239 --> 00:03:36,400
mapped and what that means is that you

00:03:32,400 --> 00:03:38,400
you write to them by

00:03:36,400 --> 00:03:40,000
writing to a specific address in memory

00:03:38,400 --> 00:03:41,599
and that rate gets intercepted at some

00:03:40,000 --> 00:03:43,680
point and handed off to the peripheral

00:03:41,599 --> 00:03:45,920
which controls the pins

00:03:43,680 --> 00:03:47,360
and to see what to write where and when

00:03:45,920 --> 00:03:49,519
to write it you should

00:03:47,360 --> 00:03:51,200
read the data sheets for instructions i

00:03:49,519 --> 00:03:52,879
think this will all be more clear if we

00:03:51,200 --> 00:03:54,799
give you an example

00:03:52,879 --> 00:03:56,400
so the example i'm going to show you is

00:03:54,799 --> 00:03:59,599
sort of the hello world of the

00:03:56,400 --> 00:04:02,959
embedded world um turning on an led

00:03:59,599 --> 00:04:04,560
i'll use an sm32 f1 processor uh because

00:04:02,959 --> 00:04:06,080
it's the one i'm most familiar with but

00:04:04,560 --> 00:04:09,280
the process is similar for

00:04:06,080 --> 00:04:11,840
almost all microcontrollers out there

00:04:09,280 --> 00:04:14,080
so the first step is to read the 1000

00:04:11,840 --> 00:04:15,599
page data sheet of the processor

00:04:14,080 --> 00:04:17,600
and you don't need to read all the

00:04:15,599 --> 00:04:19,600
thousand pages to turn on an led

00:04:17,600 --> 00:04:21,359
but to turn on the microcontroller and

00:04:19,600 --> 00:04:23,680
start up the

00:04:21,359 --> 00:04:25,759
corresponding parts and turning on the

00:04:23,680 --> 00:04:27,120
led you probably need about 100 pages of

00:04:25,759 --> 00:04:28,560
reading

00:04:27,120 --> 00:04:30,880
the process once you've done that

00:04:28,560 --> 00:04:33,280
reading is that you start with

00:04:30,880 --> 00:04:35,199
powering up the gpio peripheral that

00:04:33,280 --> 00:04:37,759
stands for general purpose input output

00:04:35,199 --> 00:04:40,400
and is for just turning pins on and off

00:04:37,759 --> 00:04:42,560
for reading from pins directly

00:04:40,400 --> 00:04:44,560
you turn it on in a peripheral called

00:04:42,560 --> 00:04:46,000
rcc

00:04:44,560 --> 00:04:48,160
then once you've done that you want to

00:04:46,000 --> 00:04:49,440
configure the pin you are interested in

00:04:48,160 --> 00:04:51,199
as an output

00:04:49,440 --> 00:04:52,560
and you need to set that output in the

00:04:51,199 --> 00:04:53,120
correct mode because there are many

00:04:52,560 --> 00:04:54,880
modes

00:04:53,120 --> 00:04:56,800
that can create outputs in different

00:04:54,880 --> 00:04:58,479
ways in different electrical ways

00:04:56,800 --> 00:05:00,960
and you need to set one that is suitable

00:04:58,479 --> 00:05:02,960
for your task and then finally

00:05:00,960 --> 00:05:05,039
after all of this you can set your pin

00:05:02,960 --> 00:05:07,199
to high and your led will hopefully turn

00:05:05,039 --> 00:05:07,199
on

00:05:08,240 --> 00:05:14,000
so reading a bit more in the data sheet

00:05:11,360 --> 00:05:16,000
uh let's say we want to turn on pin 13

00:05:14,000 --> 00:05:17,680
and we want to set it as an output

00:05:16,000 --> 00:05:19,039
you will find a table like this now i'm

00:05:17,680 --> 00:05:20,639
not expecting you to see all of the

00:05:19,039 --> 00:05:21,680
details in this table it's more of the

00:05:20,639 --> 00:05:23,680
general structure

00:05:21,680 --> 00:05:25,360
but it gives you some information we

00:05:23,680 --> 00:05:28,960
have a control register for

00:05:25,360 --> 00:05:29,759
the pin of for the pins in a bank a gpio

00:05:28,960 --> 00:05:32,320
bank

00:05:29,759 --> 00:05:34,160
and that's offset by four from the start

00:05:32,320 --> 00:05:35,280
of that gpio peripheral so we have an

00:05:34,160 --> 00:05:36,960
address to the peripheral

00:05:35,280 --> 00:05:39,759
and then we want to offset that to get

00:05:36,960 --> 00:05:42,160
the control register

00:05:39,759 --> 00:05:44,800
then we want to write some values to

00:05:42,160 --> 00:05:47,840
that register and from this we can see

00:05:44,800 --> 00:05:48,880
that we want to write a 1 0 in bits 20

00:05:47,840 --> 00:05:51,759
and 21

00:05:48,880 --> 00:05:52,800
and a 0 1 in bits 22 and 23 and this is

00:05:51,759 --> 00:05:54,960
for setting the mode

00:05:52,800 --> 00:05:56,080
the output or the input and the

00:05:54,960 --> 00:05:59,440
configuration

00:05:56,080 --> 00:06:02,160
the the type of

00:05:59,440 --> 00:06:03,520
electrical output we want and the same

00:06:02,160 --> 00:06:05,199
is true for the output value

00:06:03,520 --> 00:06:07,199
we have a specific bit we need to change

00:06:05,199 --> 00:06:09,120
in a specific register

00:06:07,199 --> 00:06:10,880
in rus that would look something like

00:06:09,120 --> 00:06:12,080
this i said before we need to start the

00:06:10,880 --> 00:06:14,560
gpio

00:06:12,080 --> 00:06:16,240
functionality in the rcc peripheral

00:06:14,560 --> 00:06:18,639
that's done in the startup gpio function

00:06:16,240 --> 00:06:21,039
because it doesn't fit on the slide here

00:06:18,639 --> 00:06:23,120
then we compute some addresses so we

00:06:21,039 --> 00:06:24,960
have this start of the gbio bank

00:06:23,120 --> 00:06:26,880
and then we have the control register

00:06:24,960 --> 00:06:28,160
offset and the offset for the output

00:06:26,880 --> 00:06:30,240
data register

00:06:28,160 --> 00:06:31,520
so this will get added to the start

00:06:30,240 --> 00:06:33,280
value

00:06:31,520 --> 00:06:34,960
the patterns we want to write to

00:06:33,280 --> 00:06:38,160
specific places are

00:06:34,960 --> 00:06:40,080
0 1 for the output mode and 1 0 for the

00:06:38,160 --> 00:06:42,160
push pull mode

00:06:40,080 --> 00:06:44,240
and then we can actually do this writing

00:06:42,160 --> 00:06:46,240
so we compute the address

00:06:44,240 --> 00:06:48,240
using normal arithmetic and then we

00:06:46,240 --> 00:06:50,639
dereference that as a pointer

00:06:48,240 --> 00:06:52,160
as a u32 pointer because it's a 32-bit

00:06:50,639 --> 00:06:55,440
processor

00:06:52,160 --> 00:06:56,720
and then we compute the value we want to

00:06:55,440 --> 00:07:00,720
write so we wanted to write

00:06:56,720 --> 00:07:02,319
0 1 to bits 20 and 21 so we have to

00:07:00,720 --> 00:07:05,120
shift that 20 bits to the

00:07:02,319 --> 00:07:06,160
right or to the left sorry and the same

00:07:05,120 --> 00:07:07,680
thing is true for the push-pull

00:07:06,160 --> 00:07:09,280
configuration

00:07:07,680 --> 00:07:11,680
shifted a bit more because that's where

00:07:09,280 --> 00:07:13,840
the configuration is stored

00:07:11,680 --> 00:07:15,840
and we do a bit twice or between them

00:07:13,840 --> 00:07:18,080
and then the same thing is true for

00:07:15,840 --> 00:07:19,520
output so we compute the address of the

00:07:18,080 --> 00:07:21,759
output data register

00:07:19,520 --> 00:07:23,919
and set the 13th bit to a 1 to actually

00:07:21,759 --> 00:07:27,039
turn on an led

00:07:23,919 --> 00:07:28,720
right that was not very fun at least i

00:07:27,039 --> 00:07:31,280
don't think that's fun code to write

00:07:28,720 --> 00:07:32,400
it's very unsafe it's really unergonomic

00:07:31,280 --> 00:07:34,400
we hope

00:07:32,400 --> 00:07:36,080
throwing a bunch of magical constants

00:07:34,400 --> 00:07:38,080
around with dereferencing pointers which

00:07:36,080 --> 00:07:40,400
you almost never do in rust

00:07:38,080 --> 00:07:41,280
um yeah we really don't want to work

00:07:40,400 --> 00:07:43,680
like this

00:07:41,280 --> 00:07:45,759
luckily the manufacturers of

00:07:43,680 --> 00:07:49,280
microcontrollers often publish

00:07:45,759 --> 00:07:51,039
uh svd files um

00:07:49,280 --> 00:07:52,400
which describe the function of each

00:07:51,039 --> 00:07:55,120
register in

00:07:52,400 --> 00:07:56,240
a way that the computer is better at

00:07:55,120 --> 00:07:59,759
understanding

00:07:56,240 --> 00:08:02,800
so in svd in the svd case that's

00:07:59,759 --> 00:08:03,520
xml and then there's a tool called svd2

00:08:02,800 --> 00:08:06,080
rust

00:08:03,520 --> 00:08:07,360
that generates crates from these svd

00:08:06,080 --> 00:08:10,160
files

00:08:07,360 --> 00:08:11,199
so by applying a few patches to kind of

00:08:10,160 --> 00:08:12,720
make the svd files

00:08:11,199 --> 00:08:14,400
a bit nicer to work with and pick some

00:08:12,720 --> 00:08:14,960
errors that are often present in the svd

00:08:14,400 --> 00:08:17,280
files

00:08:14,960 --> 00:08:19,360
and then running the files through svd

00:08:17,280 --> 00:08:21,520
trust we get what's called a peripheral

00:08:19,360 --> 00:08:23,840
access crate a pac

00:08:21,520 --> 00:08:25,680
it's a mostly safe interface around all

00:08:23,840 --> 00:08:27,360
of this register manipulation

00:08:25,680 --> 00:08:29,039
and that interface is created using a

00:08:27,360 --> 00:08:31,360
whole lot of zero cost abstraction

00:08:29,039 --> 00:08:32,320
and this is similar similar to what was

00:08:31,360 --> 00:08:34,320
talked about in the

00:08:32,320 --> 00:08:36,159
in the writing a good driver talk that

00:08:34,320 --> 00:08:39,760
was earlier today

00:08:36,159 --> 00:08:40,800
and as a bonus we also prevent reuse of

00:08:39,760 --> 00:08:44,080
peripherals

00:08:40,800 --> 00:08:46,080
once we have this svd file or as pac

00:08:44,080 --> 00:08:47,680
we have a struct representing each

00:08:46,080 --> 00:08:49,440
register and we only have one of that

00:08:47,680 --> 00:08:50,880
for each register so if we want to share

00:08:49,440 --> 00:08:52,720
it for some reason

00:08:50,880 --> 00:08:55,839
the ownership system will make sure that

00:08:52,720 --> 00:08:55,839
we do that properly

00:08:56,160 --> 00:09:00,800
in code the same thing we did before

00:08:59,120 --> 00:09:01,680
turning on the led looks like this

00:09:00,800 --> 00:09:04,720
instead

00:09:01,680 --> 00:09:06,720
we just we again start the gpio function

00:09:04,720 --> 00:09:09,600
in the rcc register

00:09:06,720 --> 00:09:11,200
and then the code for setting the mode

00:09:09,600 --> 00:09:14,320
and configuration of pin 13

00:09:11,200 --> 00:09:17,600
is much nicer we want to modify

00:09:14,320 --> 00:09:19,120
the crh register of jpioc setting the

00:09:17,600 --> 00:09:21,200
mode of a pin 13

00:09:19,120 --> 00:09:23,200
to an output and the configuration of

00:09:21,200 --> 00:09:24,880
pin 13 as a push pull

00:09:23,200 --> 00:09:26,320
and that's all we have to do now the pin

00:09:24,880 --> 00:09:27,760
is configured

00:09:26,320 --> 00:09:29,920
then we want to actually change the

00:09:27,760 --> 00:09:32,080
output and to do that we want to modify

00:09:29,920 --> 00:09:33,680
the output data register setting the

00:09:32,080 --> 00:09:37,920
output data of pin 13

00:09:33,680 --> 00:09:38,880
to high alright this was a much nicer

00:09:37,920 --> 00:09:43,120
interface i

00:09:38,880 --> 00:09:44,720
i'd say and i hope you agree um

00:09:43,120 --> 00:09:46,399
it does this through a lot of zero cost

00:09:44,720 --> 00:09:47,920
abstractions so you can see there's a

00:09:46,399 --> 00:09:50,399
bunch of closures going on here and

00:09:47,920 --> 00:09:52,000
there's a bunch of weird function calls

00:09:50,399 --> 00:09:54,160
all of this gets optimized away by the

00:09:52,000 --> 00:09:55,680
compiler though it's only done in

00:09:54,160 --> 00:09:57,519
release mode so if you run your

00:09:55,680 --> 00:09:59,200
embedded project in the bug mode it may

00:09:57,519 --> 00:10:00,959
be much much slower than it is in

00:09:59,200 --> 00:10:01,760
release mode which is a pitfall that is

00:10:00,959 --> 00:10:03,600
easy to

00:10:01,760 --> 00:10:05,440
fall into but luckily the fix is to just

00:10:03,600 --> 00:10:08,800
compile with release mode and your code

00:10:05,440 --> 00:10:10,800
will be linked blazingly fast we are we

00:10:08,800 --> 00:10:13,279
fixed most of the unsafety now as well

00:10:10,800 --> 00:10:13,920
um there's no one safe in this code

00:10:13,279 --> 00:10:16,160
example

00:10:13,920 --> 00:10:19,399
but there is some unsafe in some cases

00:10:16,160 --> 00:10:21,279
when working with pacs

00:10:19,399 --> 00:10:22,480
unfortunately there are still some

00:10:21,279 --> 00:10:24,560
issues

00:10:22,480 --> 00:10:26,800
the key one is there's no check for

00:10:24,560 --> 00:10:28,880
dependencies between peripherals

00:10:26,800 --> 00:10:30,560
earlier i said that you need to start

00:10:28,880 --> 00:10:32,560
the gpio function before you can

00:10:30,560 --> 00:10:34,560
configure the registers

00:10:32,560 --> 00:10:35,680
that's done through that start gpio

00:10:34,560 --> 00:10:37,839
function but

00:10:35,680 --> 00:10:38,800
there's never any check that we run that

00:10:37,839 --> 00:10:41,040
if we don't the

00:10:38,800 --> 00:10:42,640
program will misbehave and we'll only

00:10:41,040 --> 00:10:43,440
find out at runtime after a whole lot of

00:10:42,640 --> 00:10:45,519
debugging

00:10:43,440 --> 00:10:46,800
the same thing is true when we talk

00:10:45,519 --> 00:10:49,360
about initialization

00:10:46,800 --> 00:10:51,360
so there's no check for that you set

00:10:49,360 --> 00:10:54,399
correct values in every register

00:10:51,360 --> 00:10:56,240
you may have combinations that are

00:10:54,399 --> 00:10:58,399
impossible or that don't do the thing

00:10:56,240 --> 00:11:00,320
you expect so the bottom line here is

00:10:58,399 --> 00:11:02,240
that we still need to read these 100

00:11:00,320 --> 00:11:03,920
pages in the data sheet to effectively

00:11:02,240 --> 00:11:07,120
work with the microcontroller

00:11:03,920 --> 00:11:09,839
not very fun the

00:11:07,120 --> 00:11:12,640
fix for that in in rust land is to use

00:11:09,839 --> 00:11:14,480
hardware abstraction layers or hulls

00:11:12,640 --> 00:11:16,320
there are higher level interface around

00:11:14,480 --> 00:11:18,880
this register manipulation

00:11:16,320 --> 00:11:21,040
and if you're used to embedded c you may

00:11:18,880 --> 00:11:23,279
also be used to hulls but i would say in

00:11:21,040 --> 00:11:25,680
general the hulls are much higher level

00:11:23,279 --> 00:11:27,600
than they are in embedded c closer to

00:11:25,680 --> 00:11:30,640
arduino code than to

00:11:27,600 --> 00:11:30,640
embedded c-hulls

00:11:31,680 --> 00:11:36,160
so yeah how would turning on an led in a

00:11:34,480 --> 00:11:39,040
hull look like that

00:11:36,160 --> 00:11:40,880
well we first need to start up the gpio

00:11:39,040 --> 00:11:42,480
or the rcc register

00:11:40,880 --> 00:11:44,079
put it in a known state that the hull

00:11:42,480 --> 00:11:47,200
can work with that's done through the

00:11:44,079 --> 00:11:49,920
constrain function or something similar

00:11:47,200 --> 00:11:50,800
and that gives us a struct for the rcc

00:11:49,920 --> 00:11:52,240
register

00:11:50,800 --> 00:11:54,399
that we can then pass to the next

00:11:52,240 --> 00:11:55,680
function the function that configures

00:11:54,399 --> 00:11:58,160
the gpio pins

00:11:55,680 --> 00:11:59,440
themselves for the gpio peripheral in

00:11:58,160 --> 00:12:02,079
the sdm32

00:11:59,440 --> 00:12:03,440
hull or f1 hell that's called split

00:12:02,079 --> 00:12:05,040
because it does a bunch of other things

00:12:03,440 --> 00:12:07,760
than just turning on the led

00:12:05,040 --> 00:12:09,200
or turning on the the gpio peripheral

00:12:07,760 --> 00:12:10,000
but the key thing here is that we have

00:12:09,200 --> 00:12:12,880
to pass this

00:12:10,000 --> 00:12:14,000
rcc register to the split function and

00:12:12,880 --> 00:12:15,600
if we don't

00:12:14,000 --> 00:12:17,600
if we don't have access to that rcc

00:12:15,600 --> 00:12:19,680
register that means we haven't

00:12:17,600 --> 00:12:21,040
started up the rcc peripheral and that

00:12:19,680 --> 00:12:23,040
means our code would misbehave at

00:12:21,040 --> 00:12:24,160
runtime but we get told that at compile

00:12:23,040 --> 00:12:27,680
time here

00:12:24,160 --> 00:12:29,680
so once we have this gpioc struct we can

00:12:27,680 --> 00:12:31,680
configure the pin we're interested in

00:12:29,680 --> 00:12:34,320
pin 13 and we want to set it as a

00:12:31,680 --> 00:12:36,000
push-pull output

00:12:34,320 --> 00:12:37,120
and this is a much higher level function

00:12:36,000 --> 00:12:38,079
call there's no chance of

00:12:37,120 --> 00:12:40,000
misconfiguration

00:12:38,079 --> 00:12:41,920
for example setting it as a push-pull

00:12:40,000 --> 00:12:44,800
input which doesn't make sense

00:12:41,920 --> 00:12:46,399
um so we get some safety there and again

00:12:44,800 --> 00:12:48,560
there's a check that we have

00:12:46,399 --> 00:12:50,079
initialized the gpio before we start

00:12:48,560 --> 00:12:52,320
configuring it

00:12:50,079 --> 00:12:53,680
and finally we just do lead dot set high

00:12:52,320 --> 00:12:57,440
to turn the led on

00:12:53,680 --> 00:13:00,480
and hopefully it turns on um

00:12:57,440 --> 00:13:02,320
and again we make sure that we configure

00:13:00,480 --> 00:13:03,360
the pin as an output before we can turn

00:13:02,320 --> 00:13:04,880
on the led

00:13:03,360 --> 00:13:07,040
because otherwise we don't have a set

00:13:04,880 --> 00:13:09,680
high function on this struct

00:13:07,040 --> 00:13:11,279
so all the whole way through this we get

00:13:09,680 --> 00:13:12,639
guided by the type system

00:13:11,279 --> 00:13:14,320
to make sure we're not doing anything

00:13:12,639 --> 00:13:16,240
stupid so

00:13:14,320 --> 00:13:18,000
we have a high level interface and we

00:13:16,240 --> 00:13:18,959
have type state that ensures correct

00:13:18,000 --> 00:13:20,480
initialization

00:13:18,959 --> 00:13:22,000
meaning that we barely have to read the

00:13:20,480 --> 00:13:24,399
data sheet when working with

00:13:22,000 --> 00:13:24,399
hulls

00:13:25,680 --> 00:13:30,399
right so the next step is to work with

00:13:28,880 --> 00:13:31,680
something more advanced than just

00:13:30,399 --> 00:13:32,959
turning on an led

00:13:31,680 --> 00:13:34,720
let's say we want to talk to this

00:13:32,959 --> 00:13:37,040
ultrasonic distance sensor

00:13:34,720 --> 00:13:38,160
it has two pins one called trig and one

00:13:37,040 --> 00:13:40,320
called echo

00:13:38,160 --> 00:13:42,399
to use it you send a pulse on the trig

00:13:40,320 --> 00:13:43,519
pin and after a while you get a pulse

00:13:42,399 --> 00:13:45,519
back on the echo pin

00:13:43,519 --> 00:13:46,639
and the length of that pulse is

00:13:45,519 --> 00:13:50,160
proportional to this

00:13:46,639 --> 00:13:50,160
distance as the sensor measured

00:13:50,240 --> 00:13:54,720
so using our hull we can define a

00:13:52,079 --> 00:13:57,040
function that reads a measure that does

00:13:54,720 --> 00:13:59,519
a measurement from this sensor

00:13:57,040 --> 00:14:01,040
the function takes a timer and two pins

00:13:59,519 --> 00:14:03,440
trig and echo

00:14:01,040 --> 00:14:05,199
at the type saved system level we ensure

00:14:03,440 --> 00:14:05,839
that the pins are configured as outputs

00:14:05,199 --> 00:14:08,560
and inputs

00:14:05,839 --> 00:14:10,240
if they're not we'll get an error then

00:14:08,560 --> 00:14:11,839
we send the start pulse

00:14:10,240 --> 00:14:13,680
using just a set high and set low

00:14:11,839 --> 00:14:16,399
functions we saw before and the wait

00:14:13,680 --> 00:14:18,560
function on the timer

00:14:16,399 --> 00:14:20,399
then we simply have to wait for the pins

00:14:18,560 --> 00:14:24,240
for the return pulse to arrive

00:14:20,399 --> 00:14:24,240
and measure the duration of that pulse

00:14:24,560 --> 00:14:28,160
to use this we do the initial setup i

00:14:26,959 --> 00:14:30,399
showed before

00:14:28,160 --> 00:14:31,440
i just moved that into a function here

00:14:30,399 --> 00:14:34,399
and then we

00:14:31,440 --> 00:14:36,880
configure our pins so we say that we

00:14:34,399 --> 00:14:37,920
need pa0 to be a push-pull output pa1 to

00:14:36,880 --> 00:14:40,079
be an input

00:14:37,920 --> 00:14:40,959
and the timer to be a configured timer

00:14:40,079 --> 00:14:42,959
in the hull

00:14:40,959 --> 00:14:45,920
and then we can just call measure

00:14:42,959 --> 00:14:49,839
distance using these pins

00:14:45,920 --> 00:14:53,279
every time we do output or every time

00:14:49,839 --> 00:14:55,279
or if we if we forget to use output

00:14:53,279 --> 00:14:57,360
or to configure the pin as an output or

00:14:55,279 --> 00:14:58,160
an input again the type system will tell

00:14:57,360 --> 00:15:01,760
us and we'll

00:14:58,160 --> 00:15:03,600
avoid debugging that issue at runtime

00:15:01,760 --> 00:15:04,880
so what we just did was make our first

00:15:03,600 --> 00:15:07,680
driver

00:15:04,880 --> 00:15:09,040
drivers in embedded rust is any crate

00:15:07,680 --> 00:15:11,279
that

00:15:09,040 --> 00:15:13,120
talks to external peripherals through a

00:15:11,279 --> 00:15:16,160
hull or it could be without a

00:15:13,120 --> 00:15:17,519
hell as well we use types to ensure that

00:15:16,160 --> 00:15:19,600
things are configured correctly

00:15:17,519 --> 00:15:20,639
and we also use ownership to ensure that

00:15:19,600 --> 00:15:23,839
timers aren't shared

00:15:20,639 --> 00:15:26,880
so to go back to the previous example

00:15:23,839 --> 00:15:28,720
we made sure that pin is in an output

00:15:26,880 --> 00:15:30,880
if we didn't unlike arduino where you

00:15:28,720 --> 00:15:33,600
could set pin mode

00:15:30,880 --> 00:15:34,320
or do digital write on a pin that hasn't

00:15:33,600 --> 00:15:37,759
been

00:15:34,320 --> 00:15:40,000
set to an output using pin mode

00:15:37,759 --> 00:15:41,759
we get that check at runtime and also

00:15:40,000 --> 00:15:43,759
once we've done this setup for the timer

00:15:41,759 --> 00:15:45,600
for example or these push-pull outputs

00:15:43,759 --> 00:15:47,519
we've taken ownership over the pins and

00:15:45,600 --> 00:15:49,440
the timers so we can't accidentally

00:15:47,519 --> 00:15:50,240
reuse these pins or timers somewhere

00:15:49,440 --> 00:15:52,639
else

00:15:50,240 --> 00:15:55,839
so all of this makes sure that a lot of

00:15:52,639 --> 00:15:55,839
the debugging we have to do

00:15:56,000 --> 00:16:01,120
we may have to do in hardware is done at

00:15:58,160 --> 00:16:01,120
compile time here

00:16:01,279 --> 00:16:07,040
all right so after a while someone else

00:16:04,320 --> 00:16:08,880
uh pick makes another hal for another

00:16:07,040 --> 00:16:10,800
microcontroller

00:16:08,880 --> 00:16:12,320
it's likely that this hull does similar

00:16:10,800 --> 00:16:13,920
things they

00:16:12,320 --> 00:16:15,759
all the microcontrollers will probably

00:16:13,920 --> 00:16:16,720
have gpio functions all of them will

00:16:15,759 --> 00:16:20,079
have timers

00:16:16,720 --> 00:16:21,759
and so on but it's likely it's also

00:16:20,079 --> 00:16:24,720
likely that it has slightly different

00:16:21,759 --> 00:16:26,480
apis because the registers aren't the

00:16:24,720 --> 00:16:28,959
same in every microcontroller

00:16:26,480 --> 00:16:30,480
and the preferences of the developers

00:16:28,959 --> 00:16:32,399
may be different so

00:16:30,480 --> 00:16:34,160
we may have focused a lot on type safety

00:16:32,399 --> 00:16:36,079
they might defer a bit of the tops

00:16:34,160 --> 00:16:37,839
the type safety and runtime to make

00:16:36,079 --> 00:16:40,880
initial development easier

00:16:37,839 --> 00:16:42,720
but the bottom line is that we have two

00:16:40,880 --> 00:16:44,320
projects that do similar things with

00:16:42,720 --> 00:16:46,720
different apis

00:16:44,320 --> 00:16:48,320
unfortunately our driver that we wrote

00:16:46,720 --> 00:16:51,120
for that sensor

00:16:48,320 --> 00:16:52,720
uses our types and the that driver will

00:16:51,120 --> 00:16:55,199
not be compatible with the other

00:16:52,720 --> 00:16:56,399
the other hull so they will have to

00:16:55,199 --> 00:16:57,920
write their own measure distance

00:16:56,399 --> 00:16:58,480
function for that ultrasonic distance

00:16:57,920 --> 00:17:00,639
sensor

00:16:58,480 --> 00:17:02,160
and if they develop a driver we won't be

00:17:00,639 --> 00:17:03,920
able to take advantage

00:17:02,160 --> 00:17:07,199
so we're duplicating a lot of the work

00:17:03,920 --> 00:17:07,199
and that's not really good

00:17:07,280 --> 00:17:13,039
enter embedded hull embedded hull is

00:17:10,480 --> 00:17:14,400
a project that provides traits for

00:17:13,039 --> 00:17:17,360
common peripherals

00:17:14,400 --> 00:17:17,839
in the e or in microcontrollers gpio

00:17:17,360 --> 00:17:21,600
pins

00:17:17,839 --> 00:17:24,319
timers serial communication and so on

00:17:21,600 --> 00:17:24,880
then embedded hull let's drive hulls

00:17:24,319 --> 00:17:28,799
implement

00:17:24,880 --> 00:17:30,720
those traits and by doing so

00:17:28,799 --> 00:17:32,000
drivers can use the traits in the

00:17:30,720 --> 00:17:34,400
embedded hall or

00:17:32,000 --> 00:17:35,360
in embedded hal to implement their

00:17:34,400 --> 00:17:36,960
functionality

00:17:35,360 --> 00:17:39,600
and by doing that they are compatible

00:17:36,960 --> 00:17:41,760
with every hull in the ecosystem

00:17:39,600 --> 00:17:43,440
so we only have to write one ultrasonic

00:17:41,760 --> 00:17:45,600
distance sensor

00:17:43,440 --> 00:17:47,760
driver and every hull can take advantage

00:17:45,600 --> 00:17:49,440
of that work

00:17:47,760 --> 00:17:50,880
to convert our ultrasonic distance

00:17:49,440 --> 00:17:54,400
sensor driver

00:17:50,880 --> 00:17:55,520
to um to use embedded health rates it's

00:17:54,400 --> 00:17:57,440
quite simple

00:17:55,520 --> 00:17:58,559
we import the traits from remember.hull

00:17:57,440 --> 00:18:00,160
called input pin

00:17:58,559 --> 00:18:02,720
pin and timer because that's the three

00:18:00,160 --> 00:18:06,000
we used then we

00:18:02,720 --> 00:18:07,840
just make the function generic over

00:18:06,000 --> 00:18:11,039
the input pin and the output pin and the

00:18:07,840 --> 00:18:11,039
timer i messed up here

00:18:12,400 --> 00:18:17,600
and we just replace our output our

00:18:15,600 --> 00:18:19,280
concrete output pin with a generic one

00:18:17,600 --> 00:18:21,600
and then the code can remain the same as

00:18:19,280 --> 00:18:23,360
before because we use the same names

00:18:21,600 --> 00:18:25,600
of the functions as would be in embedded

00:18:23,360 --> 00:18:28,880
hull and by doing so

00:18:25,600 --> 00:18:32,480
we enable reuse of this ultrasonic

00:18:28,880 --> 00:18:32,480
distance sensor across the ecosystem

00:18:32,880 --> 00:18:36,160
so that's sort of the end of the stack

00:18:35,600 --> 00:18:38,960
of

00:18:36,160 --> 00:18:40,799
lay of crates on top of register

00:18:38,960 --> 00:18:42,880
manipulations but there is

00:18:40,799 --> 00:18:44,559
there are some other crates that will

00:18:42,880 --> 00:18:47,840
that you will come across and that

00:18:44,559 --> 00:18:49,520
i want to explain next the first one is

00:18:47,840 --> 00:18:50,960
arctic real-time internet delivering

00:18:49,520 --> 00:18:52,320
concurrency um

00:18:50,960 --> 00:18:54,480
which is a framework for building

00:18:52,320 --> 00:18:55,200
real-time systems it provides tasks and

00:18:54,480 --> 00:18:57,120
communication

00:18:55,200 --> 00:18:58,240
between the tasks and enables real-time

00:18:57,120 --> 00:19:01,120
analysis

00:18:58,240 --> 00:19:02,640
among a whole lot of other things um if

00:19:01,120 --> 00:19:03,039
you haven't already you should go back

00:19:02,640 --> 00:19:05,200
and

00:19:03,039 --> 00:19:06,640
back and watch emil frisk's talk about

00:19:05,200 --> 00:19:09,760
this which he gave

00:19:06,640 --> 00:19:11,440
just an hour or so ago

00:19:09,760 --> 00:19:14,160
because it goes into a lot more details

00:19:11,440 --> 00:19:16,640
than this uh it should be noted that

00:19:14,160 --> 00:19:18,480
this crate was previously known as rtfm

00:19:16,640 --> 00:19:20,720
or real time for the masses but that

00:19:18,480 --> 00:19:22,320
acronym turned out to be a bit weird so

00:19:20,720 --> 00:19:24,880
they renamed it to arctic

00:19:22,320 --> 00:19:26,880
a month or so ago which means that you

00:19:24,880 --> 00:19:29,039
will still come across this rtfm name

00:19:26,880 --> 00:19:31,760
but just remember that rdfm and arctic

00:19:29,039 --> 00:19:31,760
are the same thing

00:19:32,320 --> 00:19:35,760
there's you will also come across crates

00:19:34,160 --> 00:19:37,440
called board support crates

00:19:35,760 --> 00:19:39,280
and what they do is provide utilities

00:19:37,440 --> 00:19:39,760
for breakout boards so for example i

00:19:39,280 --> 00:19:42,240
have this

00:19:39,760 --> 00:19:43,280
tnc 3.6 here it has a microcontroller in

00:19:42,240 --> 00:19:45,919
the middle

00:19:43,280 --> 00:19:46,559
but it also has a bunch of pins on the

00:19:45,919 --> 00:19:49,039
outside

00:19:46,559 --> 00:19:51,120
which unlike the microcontroller are

00:19:49,039 --> 00:19:53,600
labeled with arduino names

00:19:51,120 --> 00:19:56,080
so pin one two three and so on instead

00:19:53,600 --> 00:19:59,520
of for example pa1pb1

00:19:56,080 --> 00:20:01,919
and so on so what the bsp for

00:19:59,520 --> 00:20:03,039
this board would do is replace the names

00:20:01,919 --> 00:20:04,960
of those pins

00:20:03,039 --> 00:20:06,720
it would also probably include drivers

00:20:04,960 --> 00:20:08,880
for the peripherals so this one has a

00:20:06,720 --> 00:20:12,000
micro sd card slot up here

00:20:08,880 --> 00:20:14,640
um and the p bsp for a team

00:20:12,000 --> 00:20:15,440
3.6 would include a driver for that

00:20:14,640 --> 00:20:17,520
unfortunately

00:20:15,440 --> 00:20:18,640
in the three points in the teensy case i

00:20:17,520 --> 00:20:21,760
don't think there is a

00:20:18,640 --> 00:20:25,679
bsp for it yet if there even is a hull

00:20:21,760 --> 00:20:28,320
but in general that's what a bsp does

00:20:25,679 --> 00:20:29,520
finally you will probably come across

00:20:28,320 --> 00:20:33,039
great

00:20:29,520 --> 00:20:34,400
with the cortex x name generally in the

00:20:33,039 --> 00:20:35,600
embedded world you would come across

00:20:34,400 --> 00:20:38,720
cortex-m

00:20:35,600 --> 00:20:42,480
but there is also a and r and

00:20:38,720 --> 00:20:46,240
cortex-m and similar is the core of many

00:20:42,480 --> 00:20:48,240
are microcontrollers so

00:20:46,240 --> 00:20:49,679
it has some timers it has some debuggers

00:20:48,240 --> 00:20:53,200
it has interrupts it

00:20:49,679 --> 00:20:56,320
does the actual instruction execution

00:20:53,200 --> 00:20:58,559
um and the cortex-m crate itself is

00:20:56,320 --> 00:21:00,320
essentially a peripheral access crates

00:20:58,559 --> 00:21:03,520
for the core peripherals so the timers

00:21:00,320 --> 00:21:06,720
and the debuggers and so on

00:21:03,520 --> 00:21:09,679
there's also a crate called cortex mrt

00:21:06,720 --> 00:21:11,280
which has a minimal run time so handling

00:21:09,679 --> 00:21:13,039
exceptions handling entry points

00:21:11,280 --> 00:21:14,720
handling interrupts

00:21:13,039 --> 00:21:17,039
and so on and if you're working with a

00:21:14,720 --> 00:21:18,880
pac that will be included with the rt

00:21:17,039 --> 00:21:20,480
feature

00:21:18,880 --> 00:21:23,280
and finally you will probably come

00:21:20,480 --> 00:21:26,000
across some crates with the post fix

00:21:23,280 --> 00:21:27,679
dash semi hosting there's cortex

00:21:26,000 --> 00:21:28,880
amsterdam and panic some hosting and

00:21:27,679 --> 00:21:30,400
maybe a few others

00:21:28,880 --> 00:21:32,480
and they provide conveniences for

00:21:30,400 --> 00:21:35,679
working with debuggers so typically

00:21:32,480 --> 00:21:38,240
in the way i worked with them you would

00:21:35,679 --> 00:21:39,039
program your devices using this debugger

00:21:38,240 --> 00:21:42,320
like this or

00:21:39,039 --> 00:21:43,840
similar and then cortex-m semi-hosting

00:21:42,320 --> 00:21:44,720
allows you to print to the debugger

00:21:43,840 --> 00:21:46,320
console

00:21:44,720 --> 00:21:48,159
and a whole bunch of other things that

00:21:46,320 --> 00:21:49,039
are useful uh when working with the

00:21:48,159 --> 00:21:51,120
debugger

00:21:49,039 --> 00:21:52,960
though be careful if you if you're using

00:21:51,120 --> 00:21:54,799
semi hosting and your debugger isn't

00:21:52,960 --> 00:21:57,840
attached your program will crash and

00:21:54,799 --> 00:21:58,320
your mic your controller will do nothing

00:21:57,840 --> 00:21:59,919
uh

00:21:58,320 --> 00:22:01,440
that's fine if you're just using it for

00:21:59,919 --> 00:22:02,080
panic messages but if you're starting to

00:22:01,440 --> 00:22:03,919
print to the

00:22:02,080 --> 00:22:07,280
debugger and then disconnect that things

00:22:03,919 --> 00:22:09,360
may go wrong so keep that in mind

00:22:07,280 --> 00:22:12,000
with that uh we're getting to the end of

00:22:09,360 --> 00:22:14,480
my talk uh embedded hull

00:22:12,000 --> 00:22:15,760
is sort of the core of the ecosystem

00:22:14,480 --> 00:22:19,280
it's

00:22:15,760 --> 00:22:22,799
what hals implement uh all the traits

00:22:19,280 --> 00:22:22,799
in number that hal are implemented

00:22:23,360 --> 00:22:28,080
by health and this is usually done

00:22:26,159 --> 00:22:30,320
through peripheral access crates

00:22:28,080 --> 00:22:31,440
then drivers can talk can use these

00:22:30,320 --> 00:22:34,960
embedded health crates

00:22:31,440 --> 00:22:37,520
to talk to external devices

00:22:34,960 --> 00:22:38,240
um and that allows reuse across the

00:22:37,520 --> 00:22:40,000
ecosystem

00:22:38,240 --> 00:22:42,159
there's also a bunch of other crates

00:22:40,000 --> 00:22:43,919
that you will come across arctic

00:22:42,159 --> 00:22:45,679
to provide concurrency as we did your

00:22:43,919 --> 00:22:48,640
rest for generating pacs

00:22:45,679 --> 00:22:51,280
the cortex something family of crates

00:22:48,640 --> 00:22:53,600
and so on

00:22:51,280 --> 00:22:54,880
so if you're starting out with a metal

00:22:53,600 --> 00:22:56,159
brush you may still have the question

00:22:54,880 --> 00:22:57,760
where should i start

00:22:56,159 --> 00:22:59,280
should i always start with han should i

00:22:57,760 --> 00:23:02,080
start with the pac

00:22:59,280 --> 00:23:03,840
um and i would say hulls are really nice

00:23:02,080 --> 00:23:05,360
you want to work with a hal if you can

00:23:03,840 --> 00:23:07,039
so if you're starting from scratch i

00:23:05,360 --> 00:23:08,400
would say pick a microcontroller with a

00:23:07,039 --> 00:23:10,000
good hal

00:23:08,400 --> 00:23:12,880
what a good hal is might be a bit

00:23:10,000 --> 00:23:14,240
difficult to tell but pick one with a

00:23:12,880 --> 00:23:15,919
well maintained health check when the

00:23:14,240 --> 00:23:18,000
last commit on github was how many pill

00:23:15,919 --> 00:23:19,280
requests there are and so on

00:23:18,000 --> 00:23:21,120
if you're starting if you have a

00:23:19,280 --> 00:23:22,080
specific project in mind with specific

00:23:21,120 --> 00:23:24,159
hardware

00:23:22,080 --> 00:23:26,000
you should start off by looking for a

00:23:24,159 --> 00:23:29,200
hull and i'll give you a list of

00:23:26,000 --> 00:23:32,320
hulls that exist at the end here um

00:23:29,200 --> 00:23:33,840
if there are no hulls for your hardware

00:23:32,320 --> 00:23:35,280
check if there's a peripheral access

00:23:33,840 --> 00:23:36,080
crate maybe you can use that to build

00:23:35,280 --> 00:23:37,760
your own hull

00:23:36,080 --> 00:23:39,760
or check if there are sod files and

00:23:37,760 --> 00:23:41,520
users you need to rush to generate it

00:23:39,760 --> 00:23:43,200
and then build your hell on top now this

00:23:41,520 --> 00:23:45,600
will be a whole lot more work

00:23:43,200 --> 00:23:47,440
but that work will only have to be done

00:23:45,600 --> 00:23:48,640
once and then the whole community can

00:23:47,440 --> 00:23:50,159
take advantage

00:23:48,640 --> 00:23:51,840
especially if you're using the embedded

00:23:50,159 --> 00:23:54,400
health rates

00:23:51,840 --> 00:23:56,159
and the same is similar or the same

00:23:54,400 --> 00:23:59,440
steps apply for drivers

00:23:56,159 --> 00:24:00,559
you should look for a driver if there

00:23:59,440 --> 00:24:02,320
isn't one already

00:24:00,559 --> 00:24:04,480
or to see if there isn't one already if

00:24:02,320 --> 00:24:06,080
there isn't you may want to build one

00:24:04,480 --> 00:24:06,880
and if you do that using the embedded

00:24:06,080 --> 00:24:08,880
hull crates

00:24:06,880 --> 00:24:10,480
then everyone can take advantage and you

00:24:08,880 --> 00:24:12,159
can take advantage of every hull in the

00:24:10,480 --> 00:24:14,960
ecosystem so you're not locked into one

00:24:12,159 --> 00:24:14,960
microcontroller

00:24:16,159 --> 00:24:20,080
finally and this is my last slide uh

00:24:18,480 --> 00:24:22,480
this is just a few resources

00:24:20,080 --> 00:24:24,240
almost all of the relevant resources for

00:24:22,480 --> 00:24:24,960
embedded rust can be found on this rust

00:24:24,240 --> 00:24:28,000
embedded

00:24:24,960 --> 00:24:30,240
also member rust repo that has a list of

00:24:28,000 --> 00:24:32,000
hulls a list of drivers a list of pacs a

00:24:30,240 --> 00:24:34,080
list of chat rooms

00:24:32,000 --> 00:24:36,480
tutorials and probably a bunch of other

00:24:34,080 --> 00:24:38,240
things that i'm forgetting

00:24:36,480 --> 00:24:40,320
there's also the embedded working group

00:24:38,240 --> 00:24:42,159
chat room

00:24:40,320 --> 00:24:43,919
where you can come and ask questions if

00:24:42,159 --> 00:24:46,080
you run into any issues

00:24:43,919 --> 00:24:47,919
and finally there's the community

00:24:46,080 --> 00:24:49,279
discord where you can also ask questions

00:24:47,919 --> 00:24:51,039
in the embedded channel

00:24:49,279 --> 00:24:53,520
uh i think both of these are linked from

00:24:51,039 --> 00:24:55,039
the awesome member stream

00:24:53,520 --> 00:24:56,480
and with that i want to thank you for

00:24:55,039 --> 00:25:01,840
listening and i wish you good luck with

00:24:56,480 --> 00:25:01,840
all your embedded rust projects

00:25:02,880 --> 00:25:06,400
all right thank you very much funs we

00:25:04,480 --> 00:25:07,919
did actually have a a number of

00:25:06,400 --> 00:25:09,520
questions in the chat so let's see how

00:25:07,919 --> 00:25:11,919
many we can go through in the next uh

00:25:09,520 --> 00:25:12,559
five minutes or so um the first question

00:25:11,919 --> 00:25:14,720
that i see

00:25:12,559 --> 00:25:16,480
is what is the state of code sharing

00:25:14,720 --> 00:25:18,000
between similar hows

00:25:16,480 --> 00:25:19,760
so not necessarily through the embedded

00:25:18,000 --> 00:25:21,400
hal traits but rather between something

00:25:19,760 --> 00:25:25,840
like the

00:25:21,400 --> 00:25:28,640
stm32f1xx and the stm32f4xx

00:25:25,840 --> 00:25:30,640
uh there isn't much of that as far as i

00:25:28,640 --> 00:25:34,080
know at least not in the

00:25:30,640 --> 00:25:36,640
stm case there might be in other um

00:25:34,080 --> 00:25:38,559
other families of microcontrollers it

00:25:36,640 --> 00:25:40,799
has been discussed

00:25:38,559 --> 00:25:42,400
recently but i don't think i'm not aware

00:25:40,799 --> 00:25:44,240
of any effort to actually

00:25:42,400 --> 00:25:45,679
share code there though it would be nice

00:25:44,240 --> 00:25:47,440
because i think we're duplicating a lot

00:25:45,679 --> 00:25:48,880
of the effort

00:25:47,440 --> 00:25:51,039
yeah i know a lot of the different chips

00:25:48,880 --> 00:25:51,679
have overlapping peripherals but a lot

00:25:51,039 --> 00:25:53,360
of

00:25:51,679 --> 00:25:55,279
similar ships have non-overlapping

00:25:53,360 --> 00:25:59,200
peripherals as well

00:25:55,279 --> 00:25:59,440
yeah all right the next question i have

00:25:59,200 --> 00:26:00,720
is

00:25:59,440 --> 00:26:03,200
are the house just written by

00:26:00,720 --> 00:26:06,240
enthusiasts are there any standards over

00:26:03,200 --> 00:26:08,799
what a house should provide

00:26:06,240 --> 00:26:10,159
uh yeah they will as far as i know most

00:26:08,799 --> 00:26:12,240
of written by enthusiasts

00:26:10,159 --> 00:26:13,279
although i'm guessing ferris does some

00:26:12,240 --> 00:26:15,760
for example

00:26:13,279 --> 00:26:17,679
maybe i know we definitely work with the

00:26:15,760 --> 00:26:19,919
nr52 the most

00:26:17,679 --> 00:26:21,360
right yeah uh but yeah there's no

00:26:19,919 --> 00:26:24,159
official

00:26:21,360 --> 00:26:25,279
no vendors making official house yet as

00:26:24,159 --> 00:26:29,679
far as i know

00:26:25,279 --> 00:26:32,080
and what was the other question uh the

00:26:29,679 --> 00:26:33,679
let's see on that one there was uh are

00:26:32,080 --> 00:26:35,200
there any standards on what a house

00:26:33,679 --> 00:26:38,400
should provide

00:26:35,200 --> 00:26:39,919
all right um well i guess there's the

00:26:38,400 --> 00:26:42,000
embedded hall crate so it's

00:26:39,919 --> 00:26:43,679
useful if the hull implements everything

00:26:42,000 --> 00:26:44,720
in embedded hull because otherwise you

00:26:43,679 --> 00:26:48,400
may have drivers that

00:26:44,720 --> 00:26:50,000
don't work with embedded hull um

00:26:48,400 --> 00:26:51,679
or don't work with the hull but work

00:26:50,000 --> 00:26:53,919
with them but at home

00:26:51,679 --> 00:26:54,799
other than that i don't think there are

00:26:53,919 --> 00:26:57,919
any standards

00:26:54,799 --> 00:26:58,960
but in general you would want to support

00:26:57,919 --> 00:27:00,480
everything that is on the

00:26:58,960 --> 00:27:03,520
microcontroller

00:27:00,480 --> 00:27:05,440
i would say definitely someone was

00:27:03,520 --> 00:27:06,400
asking about debug versus release you

00:27:05,440 --> 00:27:08,880
mentioned the

00:27:06,400 --> 00:27:10,559
uh the pack code being slow in debug

00:27:08,880 --> 00:27:12,480
mode uh someone mentioned that they've

00:27:10,559 --> 00:27:14,400
seen that you can override optimization

00:27:12,480 --> 00:27:16,240
flags and rust for specific crates is it

00:27:14,400 --> 00:27:18,840
reasonable to optimize just the pack

00:27:16,240 --> 00:27:20,720
and then leave the user code uh debug

00:27:18,840 --> 00:27:23,600
optimized

00:27:20,720 --> 00:27:25,520
yeah i think that would make sense i

00:27:23,600 --> 00:27:26,559
think i tried that like a year ago with

00:27:25,520 --> 00:27:28,320
some crate but

00:27:26,559 --> 00:27:30,399
i'm not sure if i got it working back

00:27:28,320 --> 00:27:34,080
then i think it was a nightly

00:27:30,399 --> 00:27:36,000
uh feature flag as well to override

00:27:34,080 --> 00:27:37,440
the bonuses i'm not sure if it's that

00:27:36,000 --> 00:27:39,120
case anymore

00:27:37,440 --> 00:27:40,480
yeah i think that's stabilized now so i

00:27:39,120 --> 00:27:43,120
think you can override

00:27:40,480 --> 00:27:44,240
profiles for specific crates now yeah it

00:27:43,120 --> 00:27:46,000
would be useful to

00:27:44,240 --> 00:27:48,240
investigate because it's not very useful

00:27:46,000 --> 00:27:51,440
to jump into the pack

00:27:48,240 --> 00:27:53,039
code with the debugger anyway okay

00:27:51,440 --> 00:27:55,200
well i'm not seeing any more questions

00:27:53,039 --> 00:27:56,559
so unless one comes up in the last

00:27:55,200 --> 00:27:58,399
second i'm scrolling through to make

00:27:56,559 --> 00:28:00,080
sure i haven't missed anyone but i think

00:27:58,399 --> 00:28:01,200
we've answered all the open questions

00:28:00,080 --> 00:28:02,799
right now there's definitely some more

00:28:01,200 --> 00:28:04,159
conversation going on so it'd be great

00:28:02,799 --> 00:28:06,320
to have you join the uh

00:28:04,159 --> 00:28:17,279
the matrix chat after this but otherwise

00:28:06,320 --> 00:28:19,360
thank you very much for a wonderful talk

00:28:17,279 --> 00:28:19,360

YouTube URL: https://www.youtube.com/watch?v=vLYit_HHPaY


