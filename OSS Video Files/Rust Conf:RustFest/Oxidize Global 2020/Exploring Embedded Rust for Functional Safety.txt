Title: Exploring Embedded Rust for Functional Safety
Publication date: 2020-11-06
Playlist: Oxidize Global 2020
Description: 
	Jack Greenbaum from Green Hills Software shares his experience with exploring Embedded Rust for use in functional safety systems at Green Hills Software. This includes the parts that are easy, a few rough edges for the end to end Embedded workflow, and recommendations for bringing Rust to the broader Embedded Systems market and Function Safety Systems in particular.


Interested in using Rust for safety critical systems? Reach out to us at sealed-rust@ferrous-systems.com!
Captions: 
	00:00:01,770 --> 00:00:19,199
[Music]

00:00:16,640 --> 00:00:21,760
thanks for the handoff james all right

00:00:19,199 --> 00:00:21,760
i'm gonna go ahead

00:00:22,000 --> 00:00:27,279
go ahead you go you go ahead okay i just

00:00:25,439 --> 00:00:29,679
want to start off by thanking everyone

00:00:27,279 --> 00:00:30,160
for for being here at these odd hours

00:00:29,679 --> 00:00:32,559
and

00:00:30,160 --> 00:00:34,000
odd places this is definitely the type

00:00:32,559 --> 00:00:36,239
of event that

00:00:34,000 --> 00:00:38,239
i would have uh traveled for and and

00:00:36,239 --> 00:00:40,160
really enjoyed the conversation so i'll

00:00:38,239 --> 00:00:45,840
be watching the chat

00:00:40,160 --> 00:00:45,840
and uh well let's see how this works

00:00:46,559 --> 00:00:51,280
so i'm going to start tonight with an

00:00:48,960 --> 00:00:54,000
introduction to green hill software and

00:00:51,280 --> 00:00:55,600
functional safety functional safety is

00:00:54,000 --> 00:00:56,960
one of those things that

00:00:55,600 --> 00:00:58,719
it sounds like it's something you ought

00:00:56,960 --> 00:01:00,719
to know what it is but then when you dig

00:00:58,719 --> 00:01:03,440
into it you don't

00:01:00,719 --> 00:01:05,920
so it's sort of a cryptic topic for a

00:01:03,440 --> 00:01:08,400
lot of folk

00:01:05,920 --> 00:01:11,200
i'll talk about why uh you might want to

00:01:08,400 --> 00:01:13,040
use rust in a functional safety system

00:01:11,200 --> 00:01:17,040
and and explore whether it's suitable

00:01:13,040 --> 00:01:17,040
for functional safety systems today

00:01:19,360 --> 00:01:23,040
so here's a an overview of green hill

00:01:21,439 --> 00:01:26,080
software we're the largest

00:01:23,040 --> 00:01:27,840
independent provider of software for

00:01:26,080 --> 00:01:30,479
embedded systems

00:01:27,840 --> 00:01:33,360
we've been in the industry for 35 years

00:01:30,479 --> 00:01:36,880
we started out as a compiler company

00:01:33,360 --> 00:01:39,119
in the late 20th century we

00:01:36,880 --> 00:01:40,400
added an integrated development

00:01:39,119 --> 00:01:43,040
environment and then

00:01:40,400 --> 00:01:44,320
a real-time operating system to our

00:01:43,040 --> 00:01:46,079
offering

00:01:44,320 --> 00:01:48,079
and today we're the leader in safety

00:01:46,079 --> 00:01:51,439
qualified tool chains with our

00:01:48,079 --> 00:01:53,840
our multi-ide and green hills compiler

00:01:51,439 --> 00:01:56,000
and safety certified operating systems

00:01:53,840 --> 00:01:58,079
with our integrity real-time operating

00:01:56,000 --> 00:02:00,880
system

00:01:58,079 --> 00:02:02,799
i've got these uh posters uh we use

00:02:00,880 --> 00:02:03,920
these at trade shows we have them around

00:02:02,799 --> 00:02:07,200
the office and they

00:02:03,920 --> 00:02:09,119
they highlight uh different customers

00:02:07,200 --> 00:02:10,800
and this grouping here shows our

00:02:09,119 --> 00:02:13,440
traditional market

00:02:10,800 --> 00:02:15,840
of safety systems planes trains and

00:02:13,440 --> 00:02:18,560
automobiles

00:02:15,840 --> 00:02:20,560
if you drive a japanese us or european

00:02:18,560 --> 00:02:24,319
produced automobile then you

00:02:20,560 --> 00:02:25,360
likely are have some green hill software

00:02:24,319 --> 00:02:27,840
in there

00:02:25,360 --> 00:02:30,879
because we've been shipped in 130

00:02:27,840 --> 00:02:34,160
million vehicles to date

00:02:30,879 --> 00:02:36,080
in aviation if you uh when back when we

00:02:34,160 --> 00:02:38,160
used to fly on commercial aircraft

00:02:36,080 --> 00:02:41,519
you probably flew on an aircraft that

00:02:38,160 --> 00:02:41,519
used green hill software

00:02:42,000 --> 00:02:45,840
all modern fighters in the west use

00:02:44,959 --> 00:02:48,640
integrity

00:02:45,840 --> 00:02:49,840
for their operating environment and a

00:02:48,640 --> 00:02:52,319
lot of transportation

00:02:49,840 --> 00:02:55,440
infrastructure trains is built around

00:02:52,319 --> 00:02:57,840
our integrity rtos

00:02:55,440 --> 00:02:59,280
but safety markets are much broader

00:02:57,840 --> 00:03:00,959
really

00:02:59,280 --> 00:03:02,959
they also include things like

00:03:00,959 --> 00:03:05,200
agricultural equipment

00:03:02,959 --> 00:03:06,640
um these have whirling blades of death

00:03:05,200 --> 00:03:08,560
and when you want the

00:03:06,640 --> 00:03:10,319
the whirling things to not be whirling

00:03:08,560 --> 00:03:13,040
so it's safe

00:03:10,319 --> 00:03:13,599
then uh you know you want assurance that

00:03:13,040 --> 00:03:15,200
that

00:03:13,599 --> 00:03:16,720
it's going to be safe when you know

00:03:15,200 --> 00:03:18,159
especially when the operator is out

00:03:16,720 --> 00:03:20,400
around the equipment

00:03:18,159 --> 00:03:22,400
so there's safety certification

00:03:20,400 --> 00:03:25,599
standards for

00:03:22,400 --> 00:03:27,440
agricultural equipment

00:03:25,599 --> 00:03:29,120
medical is interesting because it not

00:03:27,440 --> 00:03:31,680
only has safety but also

00:03:29,120 --> 00:03:35,200
cyber security standards these days and

00:03:31,680 --> 00:03:37,360
that that's a new requirement

00:03:35,200 --> 00:03:38,720
and then there are kind of niche markets

00:03:37,360 --> 00:03:42,319
um

00:03:38,720 --> 00:03:46,239
nasa and jpl use us in space flight

00:03:42,319 --> 00:03:49,360
equipment as well as in defense

00:03:46,239 --> 00:03:51,519
and then yeah that's an hp printer

00:03:49,360 --> 00:03:53,840
you know the cost of a failure in a

00:03:51,519 --> 00:03:56,560
consumer appliance

00:03:53,840 --> 00:03:58,000
isn't a safety issue but it's a big

00:03:56,560 --> 00:04:02,319
business issue

00:03:58,000 --> 00:04:02,319
so reliability matters there too

00:04:05,040 --> 00:04:08,720
so what is functional safety

00:04:07,200 --> 00:04:10,640
certification and how

00:04:08,720 --> 00:04:12,319
what role does it play in the in these

00:04:10,640 --> 00:04:14,319
products

00:04:12,319 --> 00:04:16,160
well functional safety certification

00:04:14,319 --> 00:04:16,560
provides assurance that a system was

00:04:16,160 --> 00:04:18,400
built

00:04:16,560 --> 00:04:20,160
taking the safety of the system into

00:04:18,400 --> 00:04:23,120
account

00:04:20,160 --> 00:04:25,520
now notice that wording it doesn't

00:04:23,120 --> 00:04:27,840
assure that the system is safe

00:04:25,520 --> 00:04:31,600
only the processes that are essential to

00:04:27,840 --> 00:04:34,400
building a safe system are followed

00:04:31,600 --> 00:04:37,360
see it's a little cryptic it's assurance

00:04:34,400 --> 00:04:40,840
that you followed a safe process

00:04:37,360 --> 00:04:42,240
because that's something that you can

00:04:40,840 --> 00:04:44,720
measure

00:04:42,240 --> 00:04:45,840
examples of functional safety standards

00:04:44,720 --> 00:04:49,199
include

00:04:45,840 --> 00:04:52,320
the usfaa do178c for

00:04:49,199 --> 00:04:55,520
software used in commercial aviation

00:04:52,320 --> 00:04:58,960
iso 26262 for

00:04:55,520 --> 00:05:04,240
automobiles and software in automotive

00:04:58,960 --> 00:05:06,720
uh electrical systems and iec 61508

00:05:04,240 --> 00:05:08,880
for industrial automation factory floor

00:05:06,720 --> 00:05:11,199
equipment

00:05:08,880 --> 00:05:13,759
now the interesting thing is even though

00:05:11,199 --> 00:05:16,080
we've got these different standards from

00:05:13,759 --> 00:05:19,520
different fields they're all pretty much

00:05:16,080 --> 00:05:23,120
the same only a little bit different

00:05:19,520 --> 00:05:24,400
they all talk about goals supporting

00:05:23,120 --> 00:05:27,360
processes

00:05:24,400 --> 00:05:29,120
and work products and this is really the

00:05:27,360 --> 00:05:31,639
secret decoder ring

00:05:29,120 --> 00:05:33,600
if you ever go to read a standard like

00:05:31,639 --> 00:05:35,199
00:05:33,600 --> 00:05:36,800
and you're wondering well what do i have

00:05:35,199 --> 00:05:39,759
to do

00:05:36,800 --> 00:05:41,600
so that my product is certified what

00:05:39,759 --> 00:05:44,880
you're looking for

00:05:41,600 --> 00:05:44,880
are the processes

00:05:47,199 --> 00:05:50,880
so the processes are things you do to

00:05:50,320 --> 00:05:54,240
achieve

00:05:50,880 --> 00:05:57,680
goals and work products

00:05:54,240 --> 00:06:02,080
are what you show an assessor

00:05:57,680 --> 00:06:02,080
to prove that you followed the process

00:06:02,720 --> 00:06:09,039
it sounds simple it is that's a lot of

00:06:05,919 --> 00:06:11,199
work and there's a lot of details

00:06:09,039 --> 00:06:12,400
the good news is that the processes and

00:06:11,199 --> 00:06:15,199
work products

00:06:12,400 --> 00:06:16,000
are are typically tailored to the risk

00:06:15,199 --> 00:06:17,919
level

00:06:16,000 --> 00:06:20,319
for example using different types of

00:06:17,919 --> 00:06:23,520
structured methods for risk analysis

00:06:20,319 --> 00:06:24,720
based on risk impact if the product is

00:06:23,520 --> 00:06:27,440
low risk

00:06:24,720 --> 00:06:28,319
you don't have to look too hard all of

00:06:27,440 --> 00:06:30,720
these

00:06:28,319 --> 00:06:31,840
standards have different levels of

00:06:30,720 --> 00:06:34,000
assurance

00:06:31,840 --> 00:06:35,440
where the highest level is for life

00:06:34,000 --> 00:06:37,199
critical systems

00:06:35,440 --> 00:06:38,639
and the lowest level are for systems

00:06:37,199 --> 00:06:41,199
that have

00:06:38,639 --> 00:06:43,840
much less impact for example an

00:06:41,199 --> 00:06:47,120
instrument cluster

00:06:43,840 --> 00:06:47,759
in an automobile a safe state for a

00:06:47,120 --> 00:06:51,840
graphical

00:06:47,759 --> 00:06:53,759
instrument cluster is actually blank

00:06:51,840 --> 00:06:55,919
the safety rules there say it's better

00:06:53,759 --> 00:06:56,639
to show no information to the driver

00:06:55,919 --> 00:07:03,599
than to show

00:06:56,639 --> 00:07:06,720
incorrect information to the driver

00:07:03,599 --> 00:07:10,319
now that is considered a

00:07:06,720 --> 00:07:10,720
a middle low safety level now compare

00:07:10,319 --> 00:07:14,720
that

00:07:10,720 --> 00:07:15,280
with uh an ecu controlling a hydraulic

00:07:14,720 --> 00:07:18,639
system

00:07:15,280 --> 00:07:21,120
on a commercial aircraft if that fails

00:07:18,639 --> 00:07:22,800
it could be catastrophic

00:07:21,120 --> 00:07:24,319
so that requires a higher level of

00:07:22,800 --> 00:07:27,520
assurance

00:07:24,319 --> 00:07:29,759
and therefore more work more processes

00:07:27,520 --> 00:07:31,520
more work products to achieve the higher

00:07:29,759 --> 00:07:33,199
goals

00:07:31,520 --> 00:07:34,800
so that's what functional safety

00:07:33,199 --> 00:07:37,840
certification is

00:07:34,800 --> 00:07:37,840
is really all about

00:07:43,280 --> 00:07:48,560
so typical development of safety systems

00:07:47,120 --> 00:07:53,520
follows a v

00:07:48,560 --> 00:07:55,520
model of development down the left side

00:07:53,520 --> 00:07:56,960
you do the design work to avoid

00:07:55,520 --> 00:07:59,840
systematic faults

00:07:56,960 --> 00:08:01,919
that are that is faults that are due to

00:07:59,840 --> 00:08:05,520
failures in your systems

00:08:01,919 --> 00:08:07,759
failure and your processes to engineer a

00:08:05,520 --> 00:08:09,759
correct system

00:08:07,759 --> 00:08:13,120
you should be able to anticipate these

00:08:09,759 --> 00:08:16,720
and mitigate those risks

00:08:13,120 --> 00:08:18,000
now on the upper side heading up the

00:08:16,720 --> 00:08:22,240
other side of our v

00:08:18,000 --> 00:08:26,240
model we're going to contain the faults

00:08:22,240 --> 00:08:29,280
that are unavoidable you know if the

00:08:26,240 --> 00:08:31,199
if the chip fails the chip fails

00:08:29,280 --> 00:08:34,000
what is it that you do about it what is

00:08:31,199 --> 00:08:36,399
the system supposed to do

00:08:34,000 --> 00:08:38,479
when the chip fails so that's what you

00:08:36,399 --> 00:08:42,159
provide assurance for

00:08:38,479 --> 00:08:45,039
on uh on the upward side

00:08:42,159 --> 00:08:45,039
of the v model

00:08:45,279 --> 00:08:52,000
and at each level of abstraction

00:08:48,640 --> 00:08:55,440
you pair a design process

00:08:52,000 --> 00:08:58,800
with an assurance process

00:08:55,440 --> 00:09:01,839
so you assure your detailed design

00:08:58,800 --> 00:09:01,839
through unit testing

00:09:01,920 --> 00:09:05,680
you assure your high level design

00:09:03,600 --> 00:09:07,839
through integration testing

00:09:05,680 --> 00:09:10,320
and requirements coverage through system

00:09:07,839 --> 00:09:10,320
testing

00:09:10,560 --> 00:09:14,080
so this is the typical flow of

00:09:12,640 --> 00:09:22,480
development

00:09:14,080 --> 00:09:26,320
in a safety system

00:09:22,480 --> 00:09:28,720
here's why we are interested in rust

00:09:26,320 --> 00:09:31,519
we have a theory we have a theory that

00:09:28,720 --> 00:09:34,320
using rust reduces systematic faults

00:09:31,519 --> 00:09:35,200
due to memory related bugs remember that

00:09:34,320 --> 00:09:37,680
00:09:35,200 --> 00:09:40,160
of bugs that james talked about in the

00:09:37,680 --> 00:09:40,160
keynote

00:09:40,399 --> 00:09:43,440
so we see the rust borrow checker

00:09:42,640 --> 00:09:45,440
enforcing

00:09:43,440 --> 00:09:47,600
correct by construction pointer use and

00:09:45,440 --> 00:09:49,600
memory allocation

00:09:47,600 --> 00:09:50,640
this is a big deal because that's where

00:09:49,600 --> 00:09:52,160
the bugs are

00:09:50,640 --> 00:09:53,600
and not only is that where they are

00:09:52,160 --> 00:09:55,279
they're there because they're very

00:09:53,600 --> 00:09:58,720
difficult to test for

00:09:55,279 --> 00:10:02,079
because they're very state dependent

00:09:58,720 --> 00:10:05,200
we also think async await is a big win

00:10:02,079 --> 00:10:08,800
for rtos application code readability

00:10:05,200 --> 00:10:08,800
and therefore reliability

00:10:08,959 --> 00:10:14,959
you know today for event driven code

00:10:12,560 --> 00:10:18,399
we often are writing state machines with

00:10:14,959 --> 00:10:22,320
big switch statements

00:10:18,399 --> 00:10:23,600
async await unwraps that state machine

00:10:22,320 --> 00:10:26,560
and makes it read like

00:10:23,600 --> 00:10:28,079
procedural code and humans are much

00:10:26,560 --> 00:10:30,800
better at procedural code than

00:10:28,079 --> 00:10:32,640
declarative code

00:10:30,800 --> 00:10:34,160
that's why we're not all programming in

00:10:32,640 --> 00:10:36,320
reactive functional programming

00:10:34,160 --> 00:10:39,600
languages

00:10:36,320 --> 00:10:39,600
at least not commercially

00:10:39,839 --> 00:10:44,440
and then we think that um the benefits

00:10:42,000 --> 00:10:46,079
of rust actually extend above the unit

00:10:44,440 --> 00:10:48,320
level

00:10:46,079 --> 00:10:50,240
correct composition is also enabled by

00:10:48,320 --> 00:10:55,279
the borrow checker

00:10:50,240 --> 00:10:55,279
so we think it reaches further up

00:10:56,720 --> 00:11:01,839
but there's a context here

00:11:02,880 --> 00:11:08,399
you know that context is

00:11:06,000 --> 00:11:10,480
this v model and it's been developed

00:11:08,399 --> 00:11:12,079
over a very long time

00:11:10,480 --> 00:11:14,560
you know this isn't functional safety

00:11:12,079 --> 00:11:16,959
isn't a new concept the v model

00:11:14,560 --> 00:11:19,839
preventing systematic faults it's it's

00:11:16,959 --> 00:11:19,839
not a new thing

00:11:20,640 --> 00:11:25,279
so you know when we bring in rust

00:11:26,560 --> 00:11:32,720
rust has its it's a

00:11:29,680 --> 00:11:34,399
c foreign function interface and we

00:11:32,720 --> 00:11:38,000
think that's how rust has to be

00:11:34,399 --> 00:11:40,640
integrated into safety systems for the

00:11:38,000 --> 00:11:44,959
foreseeable future

00:11:40,640 --> 00:11:47,600
you've got rust maybe you have

00:11:44,959 --> 00:11:49,839
um other compiled code from other

00:11:47,600 --> 00:11:52,639
authoring systems like uml or other

00:11:49,839 --> 00:11:54,839
model driven tools like

00:11:52,639 --> 00:11:56,480
from system design companies like

00:11:54,839 --> 00:12:00,800
mathworks

00:11:56,480 --> 00:12:03,920
but in the end it's a sea world

00:12:00,800 --> 00:12:06,560
all of the processes

00:12:03,920 --> 00:12:07,120
that get you to implementation and then

00:12:06,560 --> 00:12:11,279
back

00:12:07,120 --> 00:12:13,839
up are geared around a c compatible

00:12:11,279 --> 00:12:13,839
abi

00:12:16,399 --> 00:12:20,160
now the world of embedded systems is a

00:12:18,959 --> 00:12:24,639
bit different

00:12:20,160 --> 00:12:29,519
than general purpose operating systems

00:12:24,639 --> 00:12:29,519
and this importance of a c tool chain

00:12:30,800 --> 00:12:39,279
really goes very deep into

00:12:34,240 --> 00:12:42,000
what is different about embedded systems

00:12:39,279 --> 00:12:44,720
the big thing is embedded systems are

00:12:42,000 --> 00:12:44,720
diverse

00:12:46,320 --> 00:12:49,680
there are diversities in the there's

00:12:47,839 --> 00:12:51,600
diversity in the type of cores that are

00:12:49,680 --> 00:12:54,399
used

00:12:51,600 --> 00:12:58,240
you know arm is of course very very very

00:12:54,399 --> 00:13:01,600
very popular and embedded these days

00:12:58,240 --> 00:13:03,120
intel's there also there's a lot of

00:13:01,600 --> 00:13:05,760
vehicles driving around

00:13:03,120 --> 00:13:08,880
with arm and intel chips especially in

00:13:05,760 --> 00:13:08,880
the instrument clusters

00:13:08,959 --> 00:13:13,360
you might be surprised to know though

00:13:11,600 --> 00:13:15,839
that there's a lot of life left in power

00:13:13,360 --> 00:13:15,839
pc

00:13:16,160 --> 00:13:20,399
power pc is still we're still seeing new

00:13:19,680 --> 00:13:24,240
starts

00:13:20,399 --> 00:13:26,000
in automotive and also in aviation both

00:13:24,240 --> 00:13:28,480
commercial and defense

00:13:26,000 --> 00:13:29,920
these chips are really well known

00:13:28,480 --> 00:13:33,440
they're worst case

00:13:29,920 --> 00:13:37,360
uh performance

00:13:33,440 --> 00:13:41,040
um and there's a lot of code

00:13:37,360 --> 00:13:42,480
code lasts forever code lasts a long

00:13:41,040 --> 00:13:44,880
time

00:13:42,480 --> 00:13:46,560
so when you have an operating system

00:13:44,880 --> 00:13:48,800
that you've been flying

00:13:46,560 --> 00:13:51,680
for a long time you don't want to change

00:13:48,800 --> 00:13:54,800
it because that's risk

00:13:51,680 --> 00:13:58,079
people stick with power pc because to

00:13:54,800 --> 00:13:58,079
them it's a risk to move

00:13:59,279 --> 00:14:04,800
now a newcomers risk five

00:14:02,800 --> 00:14:06,880
we're seeing some applications that are

00:14:04,800 --> 00:14:10,320
on power pc move to risk five

00:14:06,880 --> 00:14:13,279
instead of arm for future proofing

00:14:10,320 --> 00:14:14,240
it's seen as got having a longer tail

00:14:13,279 --> 00:14:17,519
more vendors

00:14:14,240 --> 00:14:19,440
avoid vendor lock-in

00:14:17,519 --> 00:14:21,519
and then there's kind of some funny

00:14:19,440 --> 00:14:22,320
processors that you mostly only see in

00:14:21,519 --> 00:14:24,720
automotive

00:14:22,320 --> 00:14:28,000
like the infineon tri core and the

00:14:24,720 --> 00:14:29,440
renaissance rh-850

00:14:28,000 --> 00:14:31,120
so why do you care that there's all

00:14:29,440 --> 00:14:32,240
these different cores

00:14:31,120 --> 00:14:35,279
well it's because they all come with

00:14:32,240 --> 00:14:35,279
different tool chains

00:14:36,399 --> 00:14:41,600
at green hills our tool chain supports

00:14:39,279 --> 00:14:44,320
all of these processors

00:14:41,600 --> 00:14:46,560
and that's nice for the customer because

00:14:44,320 --> 00:14:50,399
the compiler flags the linker

00:14:46,560 --> 00:14:50,399
everything is is all the same

00:14:51,040 --> 00:14:55,920
but you know arm has an arm compiler

00:14:54,079 --> 00:14:58,880
they want their customers to get the

00:14:55,920 --> 00:14:59,519
most out of their processor core so they

00:14:58,880 --> 00:15:03,440
provide

00:14:59,519 --> 00:15:05,279
their own compiler intel does the same

00:15:03,440 --> 00:15:07,600
then there are independent vendors like

00:15:05,279 --> 00:15:08,959
iar

00:15:07,600 --> 00:15:11,519
and then we have our open source

00:15:08,959 --> 00:15:14,000
alternatives gcc

00:15:11,519 --> 00:15:14,000
clang

00:15:14,720 --> 00:15:21,440
so you know there's diversity here

00:15:18,720 --> 00:15:23,920
and where it really hits home is in the

00:15:21,440 --> 00:15:23,920
linker

00:15:24,720 --> 00:15:29,199
linkers are actually pretty magical

00:15:28,000 --> 00:15:33,519
things

00:15:29,199 --> 00:15:33,519
they perform magic in embedded systems

00:15:34,160 --> 00:15:38,480
in the general purpose os you almost

00:15:36,079 --> 00:15:41,279
never interact with the linker

00:15:38,480 --> 00:15:41,839
maybe you need to set an ld library path

00:15:41,279 --> 00:15:44,720
or

00:15:41,839 --> 00:15:45,759
make sure a dll got into the registry or

00:15:44,720 --> 00:15:47,839
something

00:15:45,759 --> 00:15:50,079
but in embedded systems they are

00:15:47,839 --> 00:15:51,519
touching your code in a very first-class

00:15:50,079 --> 00:15:53,839
way

00:15:51,519 --> 00:15:55,440
for example linkers will modify your

00:15:53,839 --> 00:15:58,160
code to reduce size

00:15:55,440 --> 00:16:00,560
things like far call patching some

00:15:58,160 --> 00:16:03,120
common sub expression refactoring in the

00:16:00,560 --> 00:16:05,040
binary code to reduce code size

00:16:03,120 --> 00:16:06,639
and then we've got overlays that'll take

00:16:05,040 --> 00:16:10,560
parts of your code chop it up

00:16:06,639 --> 00:16:12,320
put it into separate binaries so

00:16:10,560 --> 00:16:14,800
you know these are pretty pretty deep

00:16:12,320 --> 00:16:14,800
features

00:16:14,880 --> 00:16:18,320
now they'll also modify your code for

00:16:16,800 --> 00:16:20,560
functionality

00:16:18,320 --> 00:16:22,720
and this typically happens with silicon

00:16:20,560 --> 00:16:24,480
errata workarounds

00:16:22,720 --> 00:16:26,399
where you throw a magic flag and all of

00:16:24,480 --> 00:16:28,320
a sudden a no-op is inserted

00:16:26,399 --> 00:16:30,160
in between two instructions where it

00:16:28,320 --> 00:16:32,160
hadn't been when it came out of the

00:16:30,160 --> 00:16:35,120
compiler

00:16:32,160 --> 00:16:35,759
this is a real safe way to patch errata

00:16:35,120 --> 00:16:37,839
that

00:16:35,759 --> 00:16:38,880
are exercised by certain instruction

00:16:37,839 --> 00:16:40,240
sequences

00:16:38,880 --> 00:16:42,240
because it doesn't matter where the

00:16:40,240 --> 00:16:45,040
binary came from as long as it's linked

00:16:42,240 --> 00:16:45,040
by this linker

00:16:46,320 --> 00:16:50,639
and linkers also feed downstream tools

00:16:48,959 --> 00:16:51,759
you know they tell the bootloader what's

00:16:50,639 --> 00:16:53,680
live what's not

00:16:51,759 --> 00:16:56,480
what needs to be cleared and where to

00:16:53,680 --> 00:16:56,480
load things

00:16:56,639 --> 00:17:03,519
so linkers are

00:17:00,320 --> 00:17:05,439
first class objects in an embedded chain

00:17:03,519 --> 00:17:07,520
an embedded tool chain whereas you just

00:17:05,439 --> 00:17:09,679
don't see them much

00:17:07,520 --> 00:17:12,000
uh in general in the general purpose

00:17:09,679 --> 00:17:12,000
world

00:17:12,160 --> 00:17:17,360
now these magical features

00:17:15,199 --> 00:17:19,039
they're often implemented as bespoke

00:17:17,360 --> 00:17:22,480
features

00:17:19,039 --> 00:17:26,400
so this entrenched

00:17:22,480 --> 00:17:27,839
c based ecosystem

00:17:26,400 --> 00:17:29,760
really goes all the way down to the

00:17:27,839 --> 00:17:30,880
linker

00:17:29,760 --> 00:17:32,880
and if you're going to bring a new

00:17:30,880 --> 00:17:36,960
language in

00:17:32,880 --> 00:17:40,400
it has to support the diversity of cores

00:17:36,960 --> 00:17:43,440
and the diversity of linkers diversity

00:17:40,400 --> 00:17:43,440
of tool chains

00:17:43,520 --> 00:17:49,600
throughout the ecosystem

00:17:46,720 --> 00:17:50,640
an entire rust build is is a ways off

00:17:49,600 --> 00:17:55,600
because of how long

00:17:50,640 --> 00:17:58,559
code lives and not just the code

00:17:55,600 --> 00:17:59,600
but the supporting processes and

00:17:58,559 --> 00:18:02,799
infrastructure

00:17:59,600 --> 00:18:04,559
around your application you know take a

00:18:02,799 --> 00:18:08,640
look at build tools

00:18:04,559 --> 00:18:11,120
we have a builder we like it i like it

00:18:08,640 --> 00:18:12,559
a lot of our customers use make files

00:18:11,120 --> 00:18:16,559
they use cmake

00:18:12,559 --> 00:18:19,760
or cons or bitbake or cargo.tamel

00:18:16,559 --> 00:18:21,039
there's a gajillion build tools and if

00:18:19,760 --> 00:18:24,160
you want to fit in

00:18:21,039 --> 00:18:27,360
you got to fit in with the build tools

00:18:24,160 --> 00:18:32,559
and the operating systems and the test

00:18:27,360 --> 00:18:36,880
tools you know bespoke test runners

00:18:32,559 --> 00:18:40,559
that's what you find in embedded systems

00:18:36,880 --> 00:18:41,840
i i didn't have time to get a picture of

00:18:40,559 --> 00:18:44,880
the

00:18:41,840 --> 00:18:45,520
the test lab at green hills our test

00:18:44,880 --> 00:18:49,200
labs

00:18:45,520 --> 00:18:53,280
we have a board for every

00:18:49,200 --> 00:18:53,679
bsp that we support and connected to it

00:18:53,280 --> 00:18:56,320
is

00:18:53,679 --> 00:18:57,760
a jtag probe a serial port a network

00:18:56,320 --> 00:19:00,799
power supply

00:18:57,760 --> 00:19:02,400
and an ethernet port and we have

00:19:00,799 --> 00:19:05,520
hundreds of these

00:19:02,400 --> 00:19:07,120
and we're running validations constantly

00:19:05,520 --> 00:19:09,200
and you can't do that with an

00:19:07,120 --> 00:19:10,480
off-the-shelf system you have to tailor

00:19:09,200 --> 00:19:13,520
it to your needs and that's what our

00:19:10,480 --> 00:19:13,520
customers do as well

00:19:13,840 --> 00:19:17,039
and there are other essential tools in

00:19:15,360 --> 00:19:18,480
the build chain that are used to this

00:19:17,039 --> 00:19:20,880
cbase flow

00:19:18,480 --> 00:19:24,160
things like license scanners that read

00:19:20,880 --> 00:19:26,160
your code and look for whether you

00:19:24,160 --> 00:19:28,320
whether your engineers accidentally cut

00:19:26,160 --> 00:19:31,360
and pasted from open source

00:19:28,320 --> 00:19:34,240
and look for open source license headers

00:19:31,360 --> 00:19:35,440
and then things like secure boot signers

00:19:34,240 --> 00:19:38,240
you know so if

00:19:35,440 --> 00:19:40,000
if rust is to be adopted it it can't be

00:19:38,240 --> 00:19:44,000
tied to a single tool chain

00:19:40,000 --> 00:19:47,200
and embedded and this is really what's

00:19:44,000 --> 00:19:53,840
what's different about embedded

00:19:47,200 --> 00:19:53,840
and therefore functional safety

00:19:55,360 --> 00:20:01,039
so where are we today

00:20:03,360 --> 00:20:07,039
so if you go look at the rust embedded

00:20:06,480 --> 00:20:08,480
book

00:20:07,039 --> 00:20:11,200
you'll see a system that kind of looks

00:20:08,480 --> 00:20:14,720
like this it takes rust

00:20:11,200 --> 00:20:17,679
and a cargo.tommel as input and

00:20:14,720 --> 00:20:18,720
it'll connect to a cortex m3 based

00:20:17,679 --> 00:20:21,919
system

00:20:18,720 --> 00:20:24,640
it suit the nuts you know it frank

00:20:21,919 --> 00:20:25,840
this is a really good system if you

00:20:24,640 --> 00:20:28,000
haven't

00:20:25,840 --> 00:20:29,280
done embedded systems programming before

00:20:28,000 --> 00:20:32,000
and are curious

00:20:29,280 --> 00:20:32,799
this is a great system there's a talk

00:20:32,000 --> 00:20:36,640
later on

00:20:32,799 --> 00:20:38,559
in the conference about is rust embedded

00:20:36,640 --> 00:20:40,320
the new arduino

00:20:38,559 --> 00:20:42,000
well take a look at this board over here

00:20:40,320 --> 00:20:43,360
this board's literally sitting on my

00:20:42,000 --> 00:20:46,960
desk

00:20:43,360 --> 00:20:49,120
this is a an st nucleo board

00:20:46,960 --> 00:20:50,640
they provide arduino images for this

00:20:49,120 --> 00:20:53,440
board

00:20:50,640 --> 00:20:54,559
the daughter card that's an arduino

00:20:53,440 --> 00:20:57,760
compatible

00:20:54,559 --> 00:21:03,840
nxp sensor module i bought it for a

00:20:57,760 --> 00:21:03,840
geek time project that that i'm doing

00:21:04,080 --> 00:21:08,960
the cortex m3 based software

00:21:07,120 --> 00:21:11,200
hardware abstraction layer that rust

00:21:08,960 --> 00:21:16,320
embedded provides

00:21:11,200 --> 00:21:19,440
the rtfm real time for the masses

00:21:16,320 --> 00:21:24,799
this is a great system

00:21:19,440 --> 00:21:26,880
for building small embedded systems

00:21:24,799 --> 00:21:28,480
and it just works and that's really one

00:21:26,880 --> 00:21:30,320
of the things i like about it and that's

00:21:28,480 --> 00:21:32,159
why i really do believe

00:21:30,320 --> 00:21:34,799
yeah this is a better way to go than an

00:21:32,159 --> 00:21:34,799
arduino

00:21:36,640 --> 00:21:41,679
so let's just look one level deep here

00:21:39,679 --> 00:21:44,720
um what's different about programming

00:21:41,679 --> 00:21:47,600
rust embedded then uh any other rust

00:21:44,720 --> 00:21:49,919
platform well one thing is this is this

00:21:47,600 --> 00:21:53,679
link map

00:21:49,919 --> 00:21:55,120
this link.x file this is input to the

00:21:53,679 --> 00:21:56,159
linker remember i was talking about

00:21:55,120 --> 00:21:59,280
linkers

00:21:56,159 --> 00:22:00,880
so in embedded systems you have to tell

00:21:59,280 --> 00:22:02,400
the linker where to put things

00:22:00,880 --> 00:22:04,240
because you've got a lot of different

00:22:02,400 --> 00:22:04,880
types of memory and embedded systems

00:22:04,240 --> 00:22:07,120
that

00:22:04,880 --> 00:22:08,720
you don't have in a general purpose os

00:22:07,120 --> 00:22:11,120
and the general purpose os

00:22:08,720 --> 00:22:13,440
everything's just memory it's just ram

00:22:11,120 --> 00:22:16,000
and pages it looks infinite to you

00:22:13,440 --> 00:22:17,679
well memory is not that like that in

00:22:16,000 --> 00:22:19,679
embedded systems

00:22:17,679 --> 00:22:20,880
you have flash typically you're booting

00:22:19,679 --> 00:22:22,640
from flash

00:22:20,880 --> 00:22:24,000
rust embed it'll flash it for you it's

00:22:22,640 --> 00:22:25,840
really awesome

00:22:24,000 --> 00:22:27,200
then you've got to manage your ram and

00:22:25,840 --> 00:22:27,600
sometimes you'll have different types of

00:22:27,200 --> 00:22:30,559
ram

00:22:27,600 --> 00:22:32,159
fast ram external slow ram so that

00:22:30,559 --> 00:22:34,960
linker command file is

00:22:32,159 --> 00:22:37,600
is really important so that's a that's a

00:22:34,960 --> 00:22:39,120
difference here

00:22:37,600 --> 00:22:40,880
and then you've got the cargo run

00:22:39,120 --> 00:22:44,240
command that

00:22:40,880 --> 00:22:46,000
doesn't just shell out it actually talks

00:22:44,240 --> 00:22:49,200
to

00:22:46,000 --> 00:22:52,159
this part of the board here

00:22:49,200 --> 00:22:54,000
is what's called this is a small jtag

00:22:52,159 --> 00:22:57,679
run control thing they call it st

00:22:54,000 --> 00:22:59,760
link and cargo run for cargo embedded

00:22:57,679 --> 00:23:00,880
actually talks to this thing and resets

00:22:59,760 --> 00:23:04,000
the whole board

00:23:00,880 --> 00:23:08,159
and flashes memory images through this

00:23:04,000 --> 00:23:10,880
and provides your debug interface so

00:23:08,159 --> 00:23:12,000
really it's providing a link map and

00:23:10,880 --> 00:23:14,159
cargo run

00:23:12,000 --> 00:23:15,360
okay and uh you know that's what's

00:23:14,159 --> 00:23:19,039
different here oh and

00:23:15,360 --> 00:23:19,039
a bunch of really awesome crates

00:23:20,559 --> 00:23:25,120
so what if i wanted to use this system

00:23:24,080 --> 00:23:28,559
with something

00:23:25,120 --> 00:23:31,840
other than this um

00:23:28,559 --> 00:23:31,840
arduino looking board

00:23:33,360 --> 00:23:37,200
what if i wanted to use it with

00:23:34,799 --> 00:23:39,600
something more industrial strength

00:23:37,200 --> 00:23:42,480
what what do i have to do can i take

00:23:39,600 --> 00:23:46,320
rust embedded as it exists today

00:23:42,480 --> 00:23:48,799
and use it in a more commercial manner

00:23:46,320 --> 00:23:50,960
so this board i'm showing now this one's

00:23:48,799 --> 00:23:53,840
on my desk as well while actually on a

00:23:50,960 --> 00:23:55,840
little rack next to my desk

00:23:53,840 --> 00:23:58,240
and you know some things to note is

00:23:55,840 --> 00:24:00,240
compared to the hobbyist nucleo

00:23:58,240 --> 00:24:02,000
arduino baseboard this one's got a

00:24:00,240 --> 00:24:02,960
display okay it costs a little bit of

00:24:02,000 --> 00:24:06,240
money

00:24:02,960 --> 00:24:09,440
it's got canon rs232 down here

00:24:06,240 --> 00:24:12,559
but really importantly it's got an arm

00:24:09,440 --> 00:24:16,480
cs20 trace connector and i've got it

00:24:12,559 --> 00:24:18,480
connected to a green hills trace pod

00:24:16,480 --> 00:24:20,159
if you've not ever used trace debugging

00:24:18,480 --> 00:24:22,720
oh man it can be

00:24:20,159 --> 00:24:23,760
so useful especially in embedded systems

00:24:22,720 --> 00:24:25,600
where

00:24:23,760 --> 00:24:28,080
because you don't have memory protection

00:24:25,600 --> 00:24:29,919
often when bad things happen

00:24:28,080 --> 00:24:31,840
really bad things happen and you'll end

00:24:29,919 --> 00:24:33,200
up in an error handler and you'll often

00:24:31,840 --> 00:24:37,039
wonder well how did i

00:24:33,200 --> 00:24:38,880
get here this trace pod

00:24:37,039 --> 00:24:40,880
connected to the trace port with the

00:24:38,880 --> 00:24:41,919
appropriate electrical on this higher

00:24:40,880 --> 00:24:44,960
cost board

00:24:41,919 --> 00:24:44,960
lets me do that

00:24:45,120 --> 00:24:52,559
so the extra peripherals the extra debug

00:24:49,919 --> 00:24:54,720
um that's what makes this a more

00:24:52,559 --> 00:24:56,559
commercial oriented board this is in

00:24:54,720 --> 00:24:59,840
fact a reference board that's frequently

00:24:56,559 --> 00:25:01,520
used for medical designs

00:24:59,840 --> 00:25:03,440
infusion pumps and those types of

00:25:01,520 --> 00:25:05,039
systems

00:25:03,440 --> 00:25:08,320
so i asked the question what do i have

00:25:05,039 --> 00:25:10,720
to change if i want to use this board

00:25:08,320 --> 00:25:12,159
well the first thing is i already have

00:25:10,720 --> 00:25:13,760
this board up and running with the green

00:25:12,159 --> 00:25:16,000
hills tool chain

00:25:13,760 --> 00:25:17,520
i've got a green hills linker command

00:25:16,000 --> 00:25:19,760
file

00:25:17,520 --> 00:25:21,679
oh shoot but i'm using the rust linker

00:25:19,760 --> 00:25:22,960
here okay what am i going to do about

00:25:21,679 --> 00:25:25,200
that

00:25:22,960 --> 00:25:26,240
and then cargo run cargo run knows how

00:25:25,200 --> 00:25:29,679
to talk to

00:25:26,240 --> 00:25:31,679
open ocd devices and run control them

00:25:29,679 --> 00:25:33,200
the greenhouse probe is not an open ocd

00:25:31,679 --> 00:25:36,559
device so i

00:25:33,200 --> 00:25:41,600
can't just immediately use

00:25:36,559 --> 00:25:46,400
cargo embedded as its shipped

00:25:41,600 --> 00:25:46,400
but i don't have to go very far

00:25:46,799 --> 00:25:51,520
and that's because cargo will also build

00:25:50,400 --> 00:25:53,840
a static lib

00:25:51,520 --> 00:25:55,360
it'll build a crate as a static library

00:25:53,840 --> 00:25:57,039
a dot a file

00:25:55,360 --> 00:26:00,080
fully linked with everything but the

00:25:57,039 --> 00:26:00,080
operating system

00:26:00,320 --> 00:26:07,679
this dot a file looks to a tool chain

00:26:04,080 --> 00:26:09,120
like any other dot a file so all those

00:26:07,679 --> 00:26:12,559
integration points

00:26:09,120 --> 00:26:15,840
are now super easy

00:26:12,559 --> 00:26:16,400
because now i can use my ghs linker

00:26:15,840 --> 00:26:19,279
command

00:26:16,400 --> 00:26:20,880
file and c code that compiles with the

00:26:19,279 --> 00:26:24,480
green hills compiler

00:26:20,880 --> 00:26:26,320
and even in rtos because i can pull that

00:26:24,480 --> 00:26:26,960
static library into my green hills

00:26:26,320 --> 00:26:30,880
builder

00:26:26,960 --> 00:26:30,880
this is our our project manager

00:26:32,320 --> 00:26:35,600
so with that static library and just

00:26:34,559 --> 00:26:37,679
changing my

00:26:35,600 --> 00:26:39,120
my crate to be a static lib instead of

00:26:37,679 --> 00:26:40,720
an executable

00:26:39,120 --> 00:26:43,679
now i get into the green hills tool

00:26:40,720 --> 00:26:44,480
chain and now i can run with green hills

00:26:43,679 --> 00:26:47,360
multi

00:26:44,480 --> 00:26:50,640
and now i can do trace-based debug on

00:26:47,360 --> 00:26:50,640
this commercial board

00:26:50,840 --> 00:26:57,760
so you know the static lib

00:26:54,960 --> 00:26:57,760
integration

00:26:58,080 --> 00:27:01,840
it means we we don't need to modify

00:27:00,080 --> 00:27:02,640
cargo to know about a different link or

00:27:01,840 --> 00:27:06,000
we could

00:27:02,640 --> 00:27:08,640
we could modify cargo to know about a

00:27:06,000 --> 00:27:10,320
different linker

00:27:08,640 --> 00:27:12,000
we could modify cargo to know how to

00:27:10,320 --> 00:27:14,640
talk to the multi-debugger but but we

00:27:12,000 --> 00:27:16,960
don't have to do that

00:27:14,640 --> 00:27:18,799
and we don't have to modify cargo to run

00:27:16,960 --> 00:27:21,840
test tools secure boot encrypters

00:27:18,799 --> 00:27:25,039
license scanners

00:27:21,840 --> 00:27:28,240
this is a really good integration point

00:27:25,039 --> 00:27:29,679
and it's supported today now there are

00:27:28,240 --> 00:27:32,080
downsides

00:27:29,679 --> 00:27:34,159
we lose cargo run i put that with

00:27:32,080 --> 00:27:36,080
strikethrough because i'm not sure

00:27:34,159 --> 00:27:37,600
in an embedded world i'm not sure cargo

00:27:36,080 --> 00:27:40,399
runs a great thing

00:27:37,600 --> 00:27:43,200
for the use model of an arduino yeah in

00:27:40,399 --> 00:27:43,200
a commercial world

00:27:43,760 --> 00:27:49,120
but cargo test is a loss

00:27:47,200 --> 00:27:50,720
you know having an ubiquitous test

00:27:49,120 --> 00:27:54,159
runner

00:27:50,720 --> 00:27:55,760
and really um well supporting test

00:27:54,159 --> 00:27:58,640
driven development

00:27:55,760 --> 00:28:01,120
that's a really good thing but you know

00:27:58,640 --> 00:28:03,840
cargo test today isn't exactly embedded

00:28:01,120 --> 00:28:03,840
friendly

00:28:07,360 --> 00:28:11,360
so i want to use this opportunity to

00:28:09,760 --> 00:28:14,640
invite the community to consider how

00:28:11,360 --> 00:28:17,919
cargo tests can be targeted to embedded

00:28:14,640 --> 00:28:21,520
you know like right now cargo test

00:28:17,919 --> 00:28:25,440
without changes or

00:28:21,520 --> 00:28:27,679
you know pulling in things uh

00:28:25,440 --> 00:28:29,200
requires a test runner you need to be

00:28:27,679 --> 00:28:30,799
able to run and that

00:28:29,200 --> 00:28:32,399
requires a lot of integration if you're

00:28:30,799 --> 00:28:34,240
going to pull it into

00:28:32,399 --> 00:28:37,679
a test environment like we have at green

00:28:34,240 --> 00:28:41,279
hills and our customers have

00:28:37,679 --> 00:28:44,320
but what if it just output a static lib

00:28:41,279 --> 00:28:46,960
then we could integrate but then we get

00:28:44,320 --> 00:28:48,880
into things like the size of the binary

00:28:46,960 --> 00:28:50,559
i don't know if features are enough to

00:28:48,880 --> 00:28:53,120
where you could

00:28:50,559 --> 00:28:54,880
just keep rebuilding and get static libs

00:28:53,120 --> 00:28:58,880
for each of your tests to make sure that

00:28:54,880 --> 00:29:01,039
they fit in the amount of ram

00:28:58,880 --> 00:29:03,279
i love cargo test when i'm running on a

00:29:01,039 --> 00:29:07,919
general purpose os

00:29:03,279 --> 00:29:07,919
i'd love for it to be more embedded

00:29:10,840 --> 00:29:13,840
friendly

00:29:14,640 --> 00:29:17,440
okay so

00:29:17,840 --> 00:29:24,880
you know for general purpose

00:29:21,039 --> 00:29:27,520
embedded non-safety critical development

00:29:24,880 --> 00:29:28,640
i've been able to use rust embedded and

00:29:27,520 --> 00:29:31,279
i really like it

00:29:28,640 --> 00:29:31,279
i like it

00:29:32,000 --> 00:29:40,320
so what's really missing for um

00:29:35,279 --> 00:29:42,640
for safety using it in a safety system

00:29:40,320 --> 00:29:43,360
well safety qualified tool chains is is

00:29:42,640 --> 00:29:46,960
a gap

00:29:43,360 --> 00:29:50,320
and if you saw um james's

00:29:46,960 --> 00:29:53,360
uh keynote leading into this

00:29:50,320 --> 00:29:56,880
then you know a bit about sealed rust

00:29:53,360 --> 00:29:59,679
and we like sealed rust we endorse

00:29:56,880 --> 00:30:01,440
sealed rust

00:29:59,679 --> 00:30:03,440
you know you really need a language

00:30:01,440 --> 00:30:05,360
standard that's on the sophistication of

00:30:03,440 --> 00:30:09,840
iso c

00:30:05,360 --> 00:30:09,840
to support qualification requirements

00:30:10,000 --> 00:30:13,520
now if you look at the backing material

00:30:11,600 --> 00:30:15,600
behind sealed rust you'll see that james

00:30:13,520 --> 00:30:17,200
calls out and ferrous systems calls out

00:30:15,600 --> 00:30:17,760
and the supporters of sealed rust call

00:30:17,200 --> 00:30:20,159
out

00:30:17,760 --> 00:30:21,120
that rust is already in a really good

00:30:20,159 --> 00:30:22,880
place

00:30:21,120 --> 00:30:24,880
because of the test infrastructure and

00:30:22,880 --> 00:30:26,960
the rfc process

00:30:24,880 --> 00:30:28,080
you know the rationale for the design

00:30:26,960 --> 00:30:32,159
choices is there

00:30:28,080 --> 00:30:32,159
this is a good place to start from

00:30:32,240 --> 00:30:37,039
but the level of rigor needs to be

00:30:34,399 --> 00:30:40,480
brought up the level of formality

00:30:37,039 --> 00:30:42,640
and stability um

00:30:40,480 --> 00:30:44,720
you know i've said a couple times that

00:30:42,640 --> 00:30:47,200
code lives forever

00:30:44,720 --> 00:30:49,840
code lives much longer than you ever

00:30:47,200 --> 00:30:53,200
possibly imagined

00:30:49,840 --> 00:30:53,600
stacks are really an example some of the

00:30:53,200 --> 00:30:55,520
can

00:30:53,600 --> 00:30:57,039
stacks in automobiles from the big

00:30:55,520 --> 00:30:59,360
companies 15

00:30:57,039 --> 00:31:00,559
20 years old same software they just

00:30:59,360 --> 00:31:05,840
keep rebuilding it

00:31:00,559 --> 00:31:05,840
it's too expensive to test again

00:31:06,640 --> 00:31:12,799
so the stability in the

00:31:09,760 --> 00:31:15,440
language that sealed rust you know takes

00:31:12,799 --> 00:31:17,039
beyond the quarterly releases

00:31:15,440 --> 00:31:19,039
that provides a level of certainty that

00:31:17,039 --> 00:31:19,600
the long-lived code and safety systems

00:31:19,039 --> 00:31:22,559
needs

00:31:19,600 --> 00:31:23,760
in addition to the formality of the

00:31:22,559 --> 00:31:25,600
language

00:31:23,760 --> 00:31:28,320
so that accurate testing and test

00:31:25,600 --> 00:31:30,840
coverage can be achieved

00:31:28,320 --> 00:31:33,120
so that's a piece that's missing for

00:31:30,840 --> 00:31:35,799
safety there's some smaller

00:31:33,120 --> 00:31:37,279
things too in the c foreign function

00:31:35,799 --> 00:31:39,679
interface

00:31:37,279 --> 00:31:40,720
a couple niggling details like c

00:31:39,679 --> 00:31:44,000
volatiles and c

00:31:40,720 --> 00:31:46,320
bit fields you know it's a sea world

00:31:44,000 --> 00:31:47,279
today and it will be for the foreseeable

00:31:46,320 --> 00:31:48,960
future

00:31:47,279 --> 00:31:51,519
and i know there's spirited discussion

00:31:48,960 --> 00:31:55,200
about volatiles and bitfields

00:31:51,519 --> 00:31:57,840
um but i think these need to be

00:31:55,200 --> 00:31:59,279
not just crates but either standard

00:31:57,840 --> 00:32:02,640
crates

00:31:59,279 --> 00:32:06,320
are more than just a pointer type

00:32:02,640 --> 00:32:06,320
um i think there's more to do here

00:32:06,559 --> 00:32:09,840
and then another aspect of the c4 and

00:32:08,480 --> 00:32:12,640
function interfaces

00:32:09,840 --> 00:32:14,159
is you know bind gen is it exists you

00:32:12,640 --> 00:32:16,480
know binden

00:32:14,159 --> 00:32:18,240
open source buying gen i think aspires

00:32:16,480 --> 00:32:19,440
to the wonderful ideal

00:32:18,240 --> 00:32:22,159
wouldn't it be great if you could just

00:32:19,440 --> 00:32:26,640
call c from rust and just hit a button

00:32:22,159 --> 00:32:28,559
it's it's not that simple um

00:32:26,640 --> 00:32:30,320
you know binding's built with klang's

00:32:28,559 --> 00:32:32,240
front end and if you have a different

00:32:30,320 --> 00:32:35,120
set of headers well

00:32:32,240 --> 00:32:36,480
it's not quite gonna work or if clang is

00:32:35,120 --> 00:32:38,320
a little bit different than the c

00:32:36,480 --> 00:32:39,440
compiler that the code you're trying to

00:32:38,320 --> 00:32:41,840
translate uses

00:32:39,440 --> 00:32:43,360
and you know as advances as our

00:32:41,840 --> 00:32:45,840
standards are these days

00:32:43,360 --> 00:32:47,919
there's still always little differences

00:32:45,840 --> 00:32:50,640
in c compilers

00:32:47,919 --> 00:32:51,360
so you know bind gen just isn't is

00:32:50,640 --> 00:32:54,799
portable

00:32:51,360 --> 00:32:57,360
or and and it has some attitude about

00:32:54,799 --> 00:32:58,559
volatiles and bit fields i don't know

00:32:57,360 --> 00:33:00,480
it's

00:32:58,559 --> 00:33:02,240
it's not complete and i don't know if it

00:33:00,480 --> 00:33:04,559
ever will be and it probably doesn't

00:33:02,240 --> 00:33:06,320
even need to be

00:33:04,559 --> 00:33:08,320
but a conclusion i've come to is that

00:33:06,320 --> 00:33:09,200
each tool chain will need its own bind

00:33:08,320 --> 00:33:25,840
gen

00:33:09,200 --> 00:33:25,840
to really help ramp up the productivity

00:33:28,640 --> 00:33:30,960
today

00:33:36,000 --> 00:33:42,880
well that's a nice internet glitch

00:33:39,279 --> 00:33:44,960
so in summary russ today is ready for

00:33:42,880 --> 00:33:47,039
use in non-safety critical embedded

00:33:44,960 --> 00:33:49,200
systems

00:33:47,039 --> 00:33:51,120
we think that static lib is the best

00:33:49,200 --> 00:33:52,399
integration point today

00:33:51,120 --> 00:33:54,640
there's still some work to do with the

00:33:52,399 --> 00:33:56,320
c4 and function interface level but

00:33:54,640 --> 00:33:58,559
i mean this is a usable system for

00:33:56,320 --> 00:34:00,320
building in non-safety critical embedded

00:33:58,559 --> 00:34:02,960
systems

00:34:00,320 --> 00:34:04,640
to take it over the finish line and

00:34:02,960 --> 00:34:07,039
really get the advantage of the language

00:34:04,640 --> 00:34:08,960
that we all see

00:34:07,039 --> 00:34:10,560
we think that sealed rust or something

00:34:08,960 --> 00:34:13,599
like it is needed

00:34:10,560 --> 00:34:15,839
to enable use and safety systems and

00:34:13,599 --> 00:34:18,320
and that's what will unlock commercially

00:34:15,839 --> 00:34:21,040
available qualified tool chains

00:34:18,320 --> 00:34:22,079
i don't think any one vendor or any one

00:34:21,040 --> 00:34:25,760
program adopting

00:34:22,079 --> 00:34:27,839
rust is going to be able to

00:34:25,760 --> 00:34:29,200
pay for all the process that provides

00:34:27,839 --> 00:34:30,960
the assurance

00:34:29,200 --> 00:34:35,839
that we've built a system that properly

00:34:30,960 --> 00:34:35,839
takes the safety into account

00:34:36,079 --> 00:34:43,919
so that's the end of my talk

00:34:39,679 --> 00:34:46,839
um james do you want to help me moderate

00:34:43,919 --> 00:34:49,839
uh questions or how should we take

00:34:46,839 --> 00:34:49,839
questions

00:34:54,879 --> 00:34:58,240
i think you're muted james i am muted

00:34:57,440 --> 00:34:59,920
thank you

00:34:58,240 --> 00:35:02,240
yeah so we've had a couple questions in

00:34:59,920 --> 00:35:03,200
the chat so we're a little over time but

00:35:02,240 --> 00:35:05,040
we've got time for

00:35:03,200 --> 00:35:08,000
a couple questions before we go back

00:35:05,040 --> 00:35:08,400
into break um so the first question was

00:35:08,000 --> 00:35:10,960
from

00:35:08,400 --> 00:35:12,240
evan richter and evan richter asked jack

00:35:10,960 --> 00:35:14,320
i would love to hear your thoughts

00:35:12,240 --> 00:35:16,480
on efforts to help the difficulty of

00:35:14,320 --> 00:35:18,400
testing on embedded platforms

00:35:16,480 --> 00:35:20,160
fuzzing and coverage guiding fuzzing in

00:35:18,400 --> 00:35:21,280
particular has really taken off in the

00:35:20,160 --> 00:35:22,800
last five years

00:35:21,280 --> 00:35:24,400
but still it is very difficult to

00:35:22,800 --> 00:35:25,359
harness embedded solutions into a

00:35:24,400 --> 00:35:27,440
fuzzing target

00:35:25,359 --> 00:35:29,599
any thoughts on fuzzing or other dynamic

00:35:27,440 --> 00:35:31,440
analysis techniques

00:35:29,599 --> 00:35:34,800
yeah you know one of the difficulties of

00:35:31,440 --> 00:35:38,160
embedded systems is the lack of resource

00:35:34,800 --> 00:35:40,079
and uh so that's one problem with

00:35:38,160 --> 00:35:42,560
with test generation techniques like

00:35:40,079 --> 00:35:42,560
fuzzing

00:35:42,839 --> 00:35:48,400
um you know we

00:35:44,720 --> 00:35:51,200
we do fuzzing uh at the api level

00:35:48,400 --> 00:35:52,640
so it's certainly a great way to check

00:35:51,200 --> 00:35:55,119
for robustness

00:35:52,640 --> 00:35:57,200
in general we found the usability of

00:35:55,119 --> 00:35:59,839
test generation tools to be

00:35:57,200 --> 00:35:59,839
lacking

00:36:00,320 --> 00:36:07,760
and i'm not sure how to resolve

00:36:03,599 --> 00:36:09,359
that you know we use various test

00:36:07,760 --> 00:36:12,560
generation tools both

00:36:09,359 --> 00:36:15,200
uh in-house tools and third-party tools

00:36:12,560 --> 00:36:19,680
for test generation

00:36:15,200 --> 00:36:22,720
they're all really awkward to use

00:36:19,680 --> 00:36:25,760
and i think that the only way they get

00:36:22,720 --> 00:36:28,320
better is more people using them

00:36:25,760 --> 00:36:29,920
and not being willing to put up with low

00:36:28,320 --> 00:36:32,320
quality

00:36:29,920 --> 00:36:34,240
you know i think eda tools fall into

00:36:32,320 --> 00:36:36,560
this trap as well

00:36:34,240 --> 00:36:38,560
the quality of electronic design

00:36:36,560 --> 00:36:40,880
automation tools things you would use to

00:36:38,560 --> 00:36:44,079
program fpgas

00:36:40,880 --> 00:36:45,760
is incredibly low and the cost is

00:36:44,079 --> 00:36:49,599
incredibly high

00:36:45,760 --> 00:36:53,359
but the number of seats worldwide is low

00:36:49,599 --> 00:36:56,240
so my hope is that as more people

00:36:53,359 --> 00:36:56,880
are involved in safety critical systems

00:36:56,240 --> 00:36:59,040
and

00:36:56,880 --> 00:37:00,640
the mandate for using safety critical

00:36:59,040 --> 00:37:02,480
systems and functional safety

00:37:00,640 --> 00:37:05,040
certifications is growing

00:37:02,480 --> 00:37:06,240
just look at the european car safety

00:37:05,040 --> 00:37:07,920
standards

00:37:06,240 --> 00:37:10,480
i think that's really the key to making

00:37:07,920 --> 00:37:12,800
these tools more usable is more people

00:37:10,480 --> 00:37:13,680
demanding better tools and where

00:37:12,800 --> 00:37:17,359
necessary

00:37:13,680 --> 00:37:17,359
just writing them in open source

00:37:17,520 --> 00:37:20,839
all right i've got a second and probably

00:37:19,119 --> 00:37:24,000
last question for you

00:37:20,839 --> 00:37:25,920
um b brown in the chat is asking i

00:37:24,000 --> 00:37:28,000
appreciated the static lib example of

00:37:25,920 --> 00:37:30,320
how to plug into an existing project

00:37:28,000 --> 00:37:31,520
but do tool companies worry that their

00:37:30,320 --> 00:37:33,680
long-term market share

00:37:31,520 --> 00:37:35,040
may reduce if new projects pick a fully

00:37:33,680 --> 00:37:36,800
open source tool chain

00:37:35,040 --> 00:37:38,400
with c and c plus plus the open source

00:37:36,800 --> 00:37:41,520
tools can be so clunky that id

00:37:38,400 --> 00:37:43,200
ees like iar add a ton of value but the

00:37:41,520 --> 00:37:44,640
rust tool chain is just so easy and user

00:37:43,200 --> 00:37:46,480
friendly i'm not sure if i need an

00:37:44,640 --> 00:37:48,400
iar although i may want the compiler

00:37:46,480 --> 00:37:50,720
back end still

00:37:48,400 --> 00:37:52,640
you know my attitude about open source

00:37:50,720 --> 00:37:56,560
is if open source is good enough for you

00:37:52,640 --> 00:37:58,800
go for it you know um our customers find

00:37:56,560 --> 00:38:00,960
that open source doesn't have

00:37:58,800 --> 00:38:03,680
uh properties that they need for

00:38:00,960 --> 00:38:05,280
long-term support and functional safety

00:38:03,680 --> 00:38:07,040
they don't have certifications they

00:38:05,280 --> 00:38:08,720
don't have long-term support

00:38:07,040 --> 00:38:10,480
they may lack features for embedded

00:38:08,720 --> 00:38:11,280
systems companies often pay us to

00:38:10,480 --> 00:38:13,119
customize

00:38:11,280 --> 00:38:14,720
tool chains to exactly their

00:38:13,119 --> 00:38:16,720
specifications

00:38:14,720 --> 00:38:18,240
so when open source is good enough hey

00:38:16,720 --> 00:38:21,359
that's great

00:38:18,240 --> 00:38:24,480
um you know i'm not threatened by an

00:38:21,359 --> 00:38:24,480
open source rust

00:38:25,680 --> 00:38:28,880
there's a reason that closed source

00:38:27,359 --> 00:38:30,960
exists and

00:38:28,880 --> 00:38:34,160
it will there will continue to be the

00:38:30,960 --> 00:38:36,000
need you know look at debuggers

00:38:34,160 --> 00:38:38,079
i think there's a reason that people on

00:38:36,000 --> 00:38:39,040
linux don't use debuggers and it's

00:38:38,079 --> 00:38:42,640
because gdb

00:38:39,040 --> 00:38:45,520
is not a good debugger it lies to you

00:38:42,640 --> 00:38:47,920
constantly about your data values and

00:38:45,520 --> 00:38:50,400
how you got there and where you are

00:38:47,920 --> 00:38:52,480
you know a trace-based debugger like

00:38:50,400 --> 00:38:53,760
like ours or from one of our competitors

00:38:52,480 --> 00:38:55,599
like lauterbach

00:38:53,760 --> 00:38:57,280
oh my goodness it just lights up the

00:38:55,599 --> 00:38:59,599
world and

00:38:57,280 --> 00:39:01,359
the information that we can show you

00:38:59,599 --> 00:39:04,079
about your system by coupling our

00:39:01,359 --> 00:39:06,320
compiler and our debugger and our linker

00:39:04,079 --> 00:39:08,320
and give you unprecedented visibility

00:39:06,320 --> 00:39:09,599
into the timing and behavior of your

00:39:08,320 --> 00:39:12,320
system

00:39:09,599 --> 00:39:14,400
you know that's just not stuff that open

00:39:12,320 --> 00:39:17,280
source is good at

00:39:14,400 --> 00:39:19,280
so open source is good at stuff that's

00:39:17,280 --> 00:39:21,520
used by a whole ton of people

00:39:19,280 --> 00:39:23,520
and less good at stuff that's used by

00:39:21,520 --> 00:39:25,680
fewer numbers of people

00:39:23,520 --> 00:39:26,640
and uh you know we're always going to

00:39:25,680 --> 00:39:28,800
have value

00:39:26,640 --> 00:39:30,160
is is what i think greenhill there will

00:39:28,800 --> 00:39:32,320
always be a need for

00:39:30,160 --> 00:39:33,359
a company like green hills even as open

00:39:32,320 --> 00:39:35,359
source takes

00:39:33,359 --> 00:39:37,359
more and more of the software content as

00:39:35,359 --> 00:39:39,359
you've observed

00:39:37,359 --> 00:39:41,280
all right thank you so much jack i know

00:39:39,359 --> 00:39:42,000
uh we'll probably have at least one more

00:39:41,280 --> 00:39:44,240
question in the chat

00:39:42,000 --> 00:39:46,160
and it'd be great to uh if if you could

00:39:44,240 --> 00:39:47,520
comment on that on the matrix chat

00:39:46,160 --> 00:39:48,880
um but i know you also need to get to

00:39:47,520 --> 00:39:50,480
sleep before you come back for our

00:39:48,880 --> 00:39:52,720
safety critical panel

00:39:50,480 --> 00:39:54,480
uh tomorrow for you and later today for

00:39:52,720 --> 00:39:56,240
us so thank you so much for your talk

00:39:54,480 --> 00:39:57,839
and we're gonna go to break now

00:39:56,240 --> 00:40:01,760
and we'll be back in a couple minutes

00:39:57,839 --> 00:40:01,760

YouTube URL: https://www.youtube.com/watch?v=G5A7rSPYpb8


