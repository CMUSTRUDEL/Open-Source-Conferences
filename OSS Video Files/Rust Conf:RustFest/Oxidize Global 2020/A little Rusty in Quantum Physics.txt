Title: A little Rusty in Quantum Physics
Publication date: 2020-11-06
Playlist: Oxidize Global 2020
Description: 
	Embedded Hardware Abstraction Layers (HALs) and other Rust frameworks work well for demos and prototype projects, but how do they hold up in real-world, professional implementations?

Stabilizer is an open-sourced hardware platform used for controlling lasers in quantum physics experiments. It offers a unique environment to exercise the usage of embedded HAL traits and the Real-Time For the Masses (RTFM) framework in a high-performance, internet-connected embedded system.

This talk will discuss the advantages (and shortfalls) of the both RTFM and the embedded HAL approach to Rust development in a real-world embedded application where timing, throughput, and internet-connectivity are crucial.
Captions: 
	00:00:01,770 --> 00:00:33,840
[Music]

00:00:32,800 --> 00:00:35,280
all right hi there ryan how are you

00:00:33,840 --> 00:00:39,440
doing hello

00:00:35,280 --> 00:00:40,640
how's it going it's going well

00:00:39,440 --> 00:00:44,000
all right we're going to hand it over to

00:00:40,640 --> 00:00:47,120
ryan uh for his talk thank you very much

00:00:44,000 --> 00:00:50,480
thanks hey there everyone

00:00:47,120 --> 00:00:51,760
my name is ryan um i am an embedded

00:00:50,480 --> 00:00:53,440
engineering consultant

00:00:51,760 --> 00:00:55,280
contractor whatever you want to call me

00:00:53,440 --> 00:00:56,480
um i've been working in the embedded

00:00:55,280 --> 00:00:59,120
world for the last

00:00:56,480 --> 00:01:01,359
probably five years now i've developed a

00:00:59,120 --> 00:01:03,920
whole variety of languages all

00:01:01,359 --> 00:01:05,519
the whole stacks c c plus plus recently

00:01:03,920 --> 00:01:08,479
been getting into rest

00:01:05,519 --> 00:01:09,360
um i tend to work in the safety critical

00:01:08,479 --> 00:01:12,240
timing critical

00:01:09,360 --> 00:01:13,520
kind of realm um big project i'm on

00:01:12,240 --> 00:01:16,479
right now we've been doing

00:01:13,520 --> 00:01:16,960
an embedded device uh embedded obviously

00:01:16,479 --> 00:01:19,439
embedded

00:01:16,960 --> 00:01:21,040
medical device um implantable class

00:01:19,439 --> 00:01:24,400
three medical device for

00:01:21,040 --> 00:01:26,799
patients to help cure sleep apnea um

00:01:24,400 --> 00:01:29,040
and i recently got in contact with

00:01:26,799 --> 00:01:31,360
cortic which is a company up in berlin

00:01:29,040 --> 00:01:32,320
after the oxidized 1k conference earlier

00:01:31,360 --> 00:01:34,720
this year

00:01:32,320 --> 00:01:36,880
about doing some firmware development in

00:01:34,720 --> 00:01:38,240
rust for some of their hardware

00:01:36,880 --> 00:01:40,880
and so i kind of wanted to give a

00:01:38,240 --> 00:01:42,560
different take on the talk here

00:01:40,880 --> 00:01:44,000
where instead of going into some of the

00:01:42,560 --> 00:01:45,439
internals and rust i wanted to talk

00:01:44,000 --> 00:01:46,799
about a project that we did with it and

00:01:45,439 --> 00:01:48,479
kind of the experience in working with

00:01:46,799 --> 00:01:51,280
the cargo ecosystem and all the various

00:01:48,479 --> 00:01:54,240
different crates that we have

00:01:51,280 --> 00:01:55,600
and so quartu develops open source

00:01:54,240 --> 00:01:57,920
typically hardware

00:01:55,600 --> 00:02:00,000
and firmware solutions for use in

00:01:57,920 --> 00:02:03,520
quantum physics research labs

00:02:00,000 --> 00:02:05,360
and so they have a new

00:02:03,520 --> 00:02:07,200
project that they have called stabilizer

00:02:05,360 --> 00:02:10,319
that is used for stabilizing

00:02:07,200 --> 00:02:12,640
laser frequencies and essentially the

00:02:10,319 --> 00:02:14,080
board shown on the right here boils down

00:02:12,640 --> 00:02:16,319
to

00:02:14,080 --> 00:02:17,120
two analog inputs that we want to sample

00:02:16,319 --> 00:02:18,959
really quickly

00:02:17,120 --> 00:02:21,120
we pass the data through a digital

00:02:18,959 --> 00:02:22,160
filter and then we can reconstruct the

00:02:21,120 --> 00:02:24,800
data on the output

00:02:22,160 --> 00:02:26,879
pass the digital codes back out to a dac

00:02:24,800 --> 00:02:28,720
and we can reconstruct a new waveform

00:02:26,879 --> 00:02:29,920
and then we can use this as a feedback

00:02:28,720 --> 00:02:31,760
loop to control

00:02:29,920 --> 00:02:33,040
the laser frequencies because they need

00:02:31,760 --> 00:02:35,599
to have them really precise when they're

00:02:33,040 --> 00:02:37,840
performing quantum physics experiments

00:02:35,599 --> 00:02:40,000
and so cortic had just developed some

00:02:37,840 --> 00:02:42,879
new hardware for this stabilizer going

00:02:40,000 --> 00:02:44,720
from v 1.0 to v 1.1

00:02:42,879 --> 00:02:46,879
they swapped around a lot of the pins

00:02:44,720 --> 00:02:49,519
they had an existing firmware solution

00:02:46,879 --> 00:02:51,200
that was working on the v 1.0 hardware

00:02:49,519 --> 00:02:53,280
but what they were looking for is

00:02:51,200 --> 00:02:53,680
converting all of that to using some of

00:02:53,280 --> 00:02:55,519
the

00:02:53,680 --> 00:02:57,200
stm house that are out there because it

00:02:55,519 --> 00:02:59,920
was originally developed using only the

00:02:57,200 --> 00:03:02,480
peripheral access crate

00:02:59,920 --> 00:03:04,319
and so one of the other major portions

00:03:02,480 --> 00:03:06,239
of this project was

00:03:04,319 --> 00:03:08,480
that there is a mezzanine card that they

00:03:06,239 --> 00:03:08,959
wanted to place on top of stabilizer

00:03:08,480 --> 00:03:12,000
that is

00:03:08,959 --> 00:03:13,360
essentially just another form it

00:03:12,000 --> 00:03:15,360
implements another algorithm for

00:03:13,360 --> 00:03:15,920
stabilizing lasers using the pound river

00:03:15,360 --> 00:03:18,159
hall

00:03:15,920 --> 00:03:20,720
technique and if that's all you know

00:03:18,159 --> 00:03:23,200
about uh quantum physics don't worry i

00:03:20,720 --> 00:03:25,120
the only parts of that algorithm i

00:03:23,200 --> 00:03:27,200
actually understand are on wikipedia

00:03:25,120 --> 00:03:28,480
um if you're looking for more in-depth

00:03:27,200 --> 00:03:29,680
quantum physics here i'm sorry you're

00:03:28,480 --> 00:03:30,720
probably not going to get it in this

00:03:29,680 --> 00:03:33,200
presentation

00:03:30,720 --> 00:03:34,080
my quantum physics is also pretty rusty

00:03:33,200 --> 00:03:36,480
so

00:03:34,080 --> 00:03:37,360
this um card that sits on top of

00:03:36,480 --> 00:03:40,000
stabilizer

00:03:37,360 --> 00:03:41,440
is intended to be another like i said

00:03:40,000 --> 00:03:44,000
laser stabilization

00:03:41,440 --> 00:03:46,000
source and it doesn't have any micro

00:03:44,000 --> 00:03:48,959
controller directly so it's intended to

00:03:46,000 --> 00:03:49,680
be controlled by stabilizer directly and

00:03:48,959 --> 00:03:51,599
so

00:03:49,680 --> 00:03:53,040
essentially what it boils down to is one

00:03:51,599 --> 00:03:54,720
really interesting

00:03:53,040 --> 00:03:55,920
high performance chip that's sitting on

00:03:54,720 --> 00:03:57,120
there called a direct digital

00:03:55,920 --> 00:03:59,120
synthesizer

00:03:57,120 --> 00:04:00,640
and that chip is capable of generating

00:03:59,120 --> 00:04:03,120
four analog outputs

00:04:00,640 --> 00:04:04,159
with a known phase relation amplitude

00:04:03,120 --> 00:04:06,799
frequency

00:04:04,159 --> 00:04:08,319
and all of that good stuff and so having

00:04:06,799 --> 00:04:09,040
that precise control over these

00:04:08,319 --> 00:04:11,680
waveforms

00:04:09,040 --> 00:04:13,760
allows the physics experiments or the

00:04:11,680 --> 00:04:15,439
control algorithms to precisely tune the

00:04:13,760 --> 00:04:17,519
laser frequencies

00:04:15,439 --> 00:04:19,919
and so this card also has a number of

00:04:17,519 --> 00:04:21,919
various other peripherals on it

00:04:19,919 --> 00:04:24,960
such as digital attenuators that we can

00:04:21,919 --> 00:04:26,960
control to adjust the power inputs for

00:04:24,960 --> 00:04:29,680
the various rf signals that we're taking

00:04:26,960 --> 00:04:31,280
input and taking in or generating

00:04:29,680 --> 00:04:33,040
there's a lot of analog hardware for

00:04:31,280 --> 00:04:34,160
mixing the various signals together to

00:04:33,040 --> 00:04:37,440
generate outputs

00:04:34,160 --> 00:04:39,440
for controlling the laser but

00:04:37,440 --> 00:04:41,040
generally it sits on top of the

00:04:39,440 --> 00:04:43,360
stabilizer card and we talk

00:04:41,040 --> 00:04:45,199
to the direct digital synthesizer chip

00:04:43,360 --> 00:04:46,880
over a quad spy interface which is

00:04:45,199 --> 00:04:48,720
essentially just a spy interface with

00:04:46,880 --> 00:04:51,280
four i o lines instead of one so it

00:04:48,720 --> 00:04:53,520
allows us to talk really quickly to it

00:04:51,280 --> 00:04:55,680
um going back a little bit stabilizer

00:04:53,520 --> 00:04:56,320
the main control interface that's used

00:04:55,680 --> 00:04:58,160
for

00:04:56,320 --> 00:05:00,160
configuring experiments and such is

00:04:58,160 --> 00:05:02,639
through an ethernet interface and so

00:05:00,160 --> 00:05:05,039
what cortic was interested in is

00:05:02,639 --> 00:05:06,000
allowing all of the various parameters

00:05:05,039 --> 00:05:08,800
of the derivative

00:05:06,000 --> 00:05:10,479
of the dds chip to be configured through

00:05:08,800 --> 00:05:12,639
the ethernet interface

00:05:10,479 --> 00:05:14,639
while also providing telemetry and

00:05:12,639 --> 00:05:16,639
information from the actual stabilizer

00:05:14,639 --> 00:05:19,039
platform

00:05:16,639 --> 00:05:20,400
and so going forward and looking into

00:05:19,039 --> 00:05:22,080
how we want to develop this because

00:05:20,400 --> 00:05:24,240
there's an existing peripheral access

00:05:22,080 --> 00:05:25,919
create implementation that it had the

00:05:24,240 --> 00:05:27,680
functionality necessary it was able to

00:05:25,919 --> 00:05:30,880
talk to the various adcs

00:05:27,680 --> 00:05:32,400
um send information out to the dax

00:05:30,880 --> 00:05:33,840
did everything we needed to do it had

00:05:32,400 --> 00:05:35,360
the timing so there's a general

00:05:33,840 --> 00:05:37,120
structure of the algorithm that we were

00:05:35,360 --> 00:05:40,160
looking for

00:05:37,120 --> 00:05:42,080
it had used rtfm as well and so

00:05:40,160 --> 00:05:43,759
we were really looking into how we can

00:05:42,080 --> 00:05:46,240
leverage as many of the rust

00:05:43,759 --> 00:05:48,400
crates in the rust ecosystem to

00:05:46,240 --> 00:05:51,280
implementing this application and so

00:05:48,400 --> 00:05:53,039
rtic formerly known as rtfm if you

00:05:51,280 --> 00:05:54,639
watched any of the previous talks this

00:05:53,039 --> 00:05:56,319
is going to kind of build on top of that

00:05:54,639 --> 00:05:58,160
going into the application layer of some

00:05:56,319 --> 00:06:00,880
of these crates

00:05:58,160 --> 00:06:02,479
is a really nice kind of framework for

00:06:00,880 --> 00:06:04,080
implementing this kind of application

00:06:02,479 --> 00:06:06,160
because if you think about it

00:06:04,080 --> 00:06:07,680
stabilizer essentially only has three

00:06:06,160 --> 00:06:08,319
really large tasks that we're trying to

00:06:07,680 --> 00:06:10,319
do

00:06:08,319 --> 00:06:13,039
there's taking in and filtering channel

00:06:10,319 --> 00:06:14,720
one taking in and filtering channel two

00:06:13,039 --> 00:06:16,160
and then handling all of the ethernet

00:06:14,720 --> 00:06:16,720
traffic and handling the control

00:06:16,160 --> 00:06:18,400
interface

00:06:16,720 --> 00:06:20,960
sending any log messages out that we

00:06:18,400 --> 00:06:23,120
need to but it's also a little bit more

00:06:20,960 --> 00:06:24,800
complicated because

00:06:23,120 --> 00:06:26,479
we need to share some of that state

00:06:24,800 --> 00:06:28,080
between these various tasks

00:06:26,479 --> 00:06:30,560
and if we're having some kind of

00:06:28,080 --> 00:06:31,840
concurrent where the filters are running

00:06:30,560 --> 00:06:32,800
dynamically in higher interrupt

00:06:31,840 --> 00:06:34,400
priorities

00:06:32,800 --> 00:06:35,840
sharing that state can get complicated

00:06:34,400 --> 00:06:39,280
and risky and so

00:06:35,840 --> 00:06:40,400
rtic posed a really nice solution for

00:06:39,280 --> 00:06:42,479
kind of working with this

00:06:40,400 --> 00:06:43,919
because we can lock the digital filter

00:06:42,479 --> 00:06:45,440
states as we're trying to read them so

00:06:43,919 --> 00:06:47,360
we can send them out of the ethernet

00:06:45,440 --> 00:06:48,720
interface or if the user wanted to

00:06:47,360 --> 00:06:50,080
update their filter

00:06:48,720 --> 00:06:51,919
to change what it was doing to the

00:06:50,080 --> 00:06:53,840
output signals we can allow them to do

00:06:51,919 --> 00:06:55,759
that as well

00:06:53,840 --> 00:06:58,160
we are also really interested in

00:06:55,759 --> 00:07:01,039
converting over all of the existing code

00:06:58,160 --> 00:07:04,560
to using the stm32h7 hal

00:07:01,039 --> 00:07:06,000
um largely because this is a fairly new

00:07:04,560 --> 00:07:08,080
chip and i don't know if the hal

00:07:06,000 --> 00:07:09,919
actually existed before the first

00:07:08,080 --> 00:07:11,120
implementation of stabilizer was

00:07:09,919 --> 00:07:12,800
developed

00:07:11,120 --> 00:07:14,560
and so we really wanted to look into

00:07:12,800 --> 00:07:16,000
using a how because it's really nice for

00:07:14,560 --> 00:07:17,759
expressing exactly what's happening

00:07:16,000 --> 00:07:19,440
with the system for example when you're

00:07:17,759 --> 00:07:20,000
configuring the whole clock interface

00:07:19,440 --> 00:07:22,080
for the chip

00:07:20,000 --> 00:07:23,199
you can say system clock is running at

00:07:22,080 --> 00:07:24,720
200 megahertz

00:07:23,199 --> 00:07:27,199
this peripheral clock that is powering

00:07:24,720 --> 00:07:29,120
the spy is running at 50 megahertz and

00:07:27,199 --> 00:07:30,400
we can really precisely control of all

00:07:29,120 --> 00:07:31,840
of that information

00:07:30,400 --> 00:07:33,360
and really nicely displayed in the

00:07:31,840 --> 00:07:35,280
source code so that when we're auditing

00:07:33,360 --> 00:07:37,919
it later to verify functionality it's

00:07:35,280 --> 00:07:39,199
explicitly clear what's happening we

00:07:37,919 --> 00:07:40,639
also wanted to use the how

00:07:39,199 --> 00:07:42,720
obviously for the peripheral

00:07:40,639 --> 00:07:44,960
implementations we needed an i squared c

00:07:42,720 --> 00:07:46,560
bus that's going on to a gpio expander

00:07:44,960 --> 00:07:48,160
that's sitting on top of the pounder

00:07:46,560 --> 00:07:50,800
hardware so that we can control some of

00:07:48,160 --> 00:07:53,280
the ios going into the synthesis chip

00:07:50,800 --> 00:07:55,599
we also needed to have spy going to the

00:07:53,280 --> 00:07:56,319
adcs and the dax on the stabilizer

00:07:55,599 --> 00:07:58,479
hardware

00:07:56,319 --> 00:08:00,400
we needed spy also going to the digital

00:07:58,479 --> 00:08:02,960
attenuators that are connected on the

00:08:00,400 --> 00:08:04,720
pounder hardware and so there's all of

00:08:02,960 --> 00:08:05,919
these various hardware interfaces that

00:08:04,720 --> 00:08:08,240
we needed to implement

00:08:05,919 --> 00:08:09,919
and the hal had ready to go

00:08:08,240 --> 00:08:11,440
implementations for them

00:08:09,919 --> 00:08:12,960
the one thing that we did need that the

00:08:11,440 --> 00:08:14,720
hal did not have was that

00:08:12,960 --> 00:08:16,560
we needed the quadsphy interface to be

00:08:14,720 --> 00:08:18,080
able to talk to the dds really quickly

00:08:16,560 --> 00:08:19,360
and so we knew going into this that was

00:08:18,080 --> 00:08:21,280
likely something we were going to have

00:08:19,360 --> 00:08:24,639
to implement ourselves

00:08:21,280 --> 00:08:26,879
there's also an stm32h7 ethernet crate

00:08:24,639 --> 00:08:29,120
that explicitly takes in ethernet

00:08:26,879 --> 00:08:30,000
peripherals from the peripheral access

00:08:29,120 --> 00:08:33,760
crate for the

00:08:30,000 --> 00:08:36,399
h7 chip and exposes a small tcp

00:08:33,760 --> 00:08:37,120
5 device interface which is a fancy way

00:08:36,399 --> 00:08:39,519
of saying

00:08:37,120 --> 00:08:41,039
it allows us to instantiate a tcp stack

00:08:39,519 --> 00:08:41,760
without having to actually write any

00:08:41,039 --> 00:08:45,519
code which

00:08:41,760 --> 00:08:47,279
is extremely powerful and so

00:08:45,519 --> 00:08:49,040
next i kind of want to get into a little

00:08:47,279 --> 00:08:50,880
bit more of exactly

00:08:49,040 --> 00:08:52,240
what we were how we accomplished this

00:08:50,880 --> 00:08:54,320
because we finished up the project

00:08:52,240 --> 00:08:57,519
probably about a month ago um

00:08:54,320 --> 00:08:59,440
so we were able to leverage small tcp um

00:08:57,519 --> 00:09:03,120
creating a network stack that sat on top

00:08:59,440 --> 00:09:06,320
of that stm32h7 ethernet crate

00:09:03,120 --> 00:09:08,880
um and if it sounds simple

00:09:06,320 --> 00:09:10,320
that's because it is it was extremely

00:09:08,880 --> 00:09:10,800
straightforward to get set up and

00:09:10,320 --> 00:09:13,440
working

00:09:10,800 --> 00:09:15,200
um just configuring the gpio pins to the

00:09:13,440 --> 00:09:18,320
correct alternate functions

00:09:15,200 --> 00:09:20,880
um passing in various peripherals to the

00:09:18,320 --> 00:09:23,200
stmh7 ethernet hal creating that

00:09:20,880 --> 00:09:25,120
interface providing that interface into

00:09:23,200 --> 00:09:27,600
the constructor to small tcp

00:09:25,120 --> 00:09:28,800
and it basically all worked it was

00:09:27,600 --> 00:09:31,680
really impressive

00:09:28,800 --> 00:09:32,880
then we could focus on just implementing

00:09:31,680 --> 00:09:35,680
now we have a tcp

00:09:32,880 --> 00:09:37,600
port that we can open up bind to we

00:09:35,680 --> 00:09:39,519
implemented a server sitting on top of

00:09:37,600 --> 00:09:41,519
that that uses certainty and just passes

00:09:39,519 --> 00:09:42,399
json back and forth so that we can have

00:09:41,519 --> 00:09:44,399
the user

00:09:42,399 --> 00:09:45,440
send in a request that says like hey can

00:09:44,399 --> 00:09:48,160
you modify

00:09:45,440 --> 00:09:50,000
the channel one output frequency from

00:09:48,160 --> 00:09:51,440
500 megahertz to 400 acres

00:09:50,000 --> 00:09:53,120
and then we can pass that all the way up

00:09:51,440 --> 00:09:56,959
to the stack to go to actually

00:09:53,120 --> 00:09:59,279
configuring the dds chip itself

00:09:56,959 --> 00:10:01,760
what was really interesting was working

00:09:59,279 --> 00:10:04,320
on the stabilizer firmware because

00:10:01,760 --> 00:10:05,040
that was this is the two channel chip

00:10:04,320 --> 00:10:07,200
that is

00:10:05,040 --> 00:10:08,560
or a two channel board that is sampling

00:10:07,200 --> 00:10:10,480
the rf inputs

00:10:08,560 --> 00:10:12,160
filtering them and sending them out

00:10:10,480 --> 00:10:13,120
largely because this needed to be really

00:10:12,160 --> 00:10:15,920
high

00:10:13,120 --> 00:10:17,839
high performance design we had strict

00:10:15,920 --> 00:10:19,040
timing requirements we needed to be able

00:10:17,839 --> 00:10:20,560
to sample the signals

00:10:19,040 --> 00:10:22,640
as quickly as we could filter them and

00:10:20,560 --> 00:10:24,240
send them back out we needed to

00:10:22,640 --> 00:10:25,760
try and have fixed delay between the

00:10:24,240 --> 00:10:27,839
input and the output so that

00:10:25,760 --> 00:10:28,800
the signals were coherent with each

00:10:27,839 --> 00:10:31,040
other

00:10:28,800 --> 00:10:33,600
and so really if you start thinking

00:10:31,040 --> 00:10:35,680
about it well okay we need to have

00:10:33,600 --> 00:10:37,440
a timer periodically we need to sample

00:10:35,680 --> 00:10:38,560
them we need to filter them and then we

00:10:37,440 --> 00:10:41,519
need to write them out

00:10:38,560 --> 00:10:42,480
so if we set up a timer every 500

00:10:41,519 --> 00:10:44,880
kilohertz

00:10:42,480 --> 00:10:45,600
then we get our interrupt we sample the

00:10:44,880 --> 00:10:47,279
adcs

00:10:45,600 --> 00:10:48,640
we pass it through our digital filter

00:10:47,279 --> 00:10:50,000
and we write it back out right

00:10:48,640 --> 00:10:51,279
like we just do that for the first

00:10:50,000 --> 00:10:52,399
channel then we do it for the second

00:10:51,279 --> 00:10:54,720
channel

00:10:52,399 --> 00:10:56,640
well it turns out that if we're looking

00:10:54,720 --> 00:10:59,930
for a really fast implementation

00:10:56,640 --> 00:11:01,200
that doesn't quite work largely because

00:10:59,930 --> 00:11:03,279
[Music]

00:11:01,200 --> 00:11:05,680
just the spy transactions of reading

00:11:03,279 --> 00:11:08,240
from the adc and writing to the dac

00:11:05,680 --> 00:11:10,399
if we incorporate those results in too

00:11:08,240 --> 00:11:11,600
long the latency the maximum frequency

00:11:10,399 --> 00:11:13,519
we're able to run the filter out is

00:11:11,600 --> 00:11:14,959
about 100 kilohertz or so

00:11:13,519 --> 00:11:17,440
and we're trying to get into the range

00:11:14,959 --> 00:11:20,240
of about 500 kilohertz was the target

00:11:17,440 --> 00:11:22,160
and so we're already about five times

00:11:20,240 --> 00:11:24,560
too slow for what we need

00:11:22,160 --> 00:11:26,079
and so instead what we're thinking okay

00:11:24,560 --> 00:11:27,600
well maybe we can pipeline this

00:11:26,079 --> 00:11:30,640
implementation as well

00:11:27,600 --> 00:11:33,040
and so we set up a

00:11:30,640 --> 00:11:34,959
timer to instead of performing an

00:11:33,040 --> 00:11:37,360
interrupt it generates a dma request

00:11:34,959 --> 00:11:38,800
and that dma request writes directly

00:11:37,360 --> 00:11:41,360
into the peripheral block

00:11:38,800 --> 00:11:42,320
to start the adc transaction then as

00:11:41,360 --> 00:11:44,399
soon as the adc

00:11:42,320 --> 00:11:45,360
transaction is finished then we can wake

00:11:44,399 --> 00:11:46,800
up

00:11:45,360 --> 00:11:49,040
we get an interrupt that says hey your

00:11:46,800 --> 00:11:49,920
data is ready we pass that data into the

00:11:49,040 --> 00:11:51,360
filter

00:11:49,920 --> 00:11:53,279
and then we take the result of the

00:11:51,360 --> 00:11:54,320
filter write it out to the dac we don't

00:11:53,279 --> 00:11:56,240
even wait for the

00:11:54,320 --> 00:11:58,000
spy transaction the dac to finish and

00:11:56,240 --> 00:11:59,519
then we continue onward

00:11:58,000 --> 00:12:01,360
it's a really nice solution because

00:11:59,519 --> 00:12:03,839
essentially this boils down to

00:12:01,360 --> 00:12:05,600
just the blue portions the digital

00:12:03,839 --> 00:12:07,279
filter of this is the only foreground

00:12:05,600 --> 00:12:08,240
task that is being done in this whole

00:12:07,279 --> 00:12:10,880
pipeline

00:12:08,240 --> 00:12:12,639
the entire adc read the conversion

00:12:10,880 --> 00:12:13,920
writing out to the dax is all performed

00:12:12,639 --> 00:12:16,160
automatically in hardware

00:12:13,920 --> 00:12:17,519
by based on dma requests and timers and

00:12:16,160 --> 00:12:19,440
so there's no

00:12:17,519 --> 00:12:21,839
requirement for any kind of processing

00:12:19,440 --> 00:12:23,120
and arctic and so we can really pipeline

00:12:21,839 --> 00:12:25,200
all of the implementation and get it

00:12:23,120 --> 00:12:27,200
running fast and we were able to hit our

00:12:25,200 --> 00:12:29,839
500 kilohertz just fine

00:12:27,200 --> 00:12:31,440
using this implementation in fact we

00:12:29,839 --> 00:12:33,200
could probably even get it going faster

00:12:31,440 --> 00:12:34,560
if we needed to if we can optimize the

00:12:33,200 --> 00:12:36,880
digital filtering

00:12:34,560 --> 00:12:38,480
portion of this as that's kind of the

00:12:36,880 --> 00:12:41,120
bottleneck at this point

00:12:38,480 --> 00:12:42,399
we also got a custom quad spy interface

00:12:41,120 --> 00:12:46,000
going

00:12:42,399 --> 00:12:47,519
using the stm32 help

00:12:46,000 --> 00:12:49,200
um it's kind of an interesting

00:12:47,519 --> 00:12:50,000
peripheral because there's many ways you

00:12:49,200 --> 00:12:52,160
can use it

00:12:50,000 --> 00:12:53,519
there the intended way typically is to

00:12:52,160 --> 00:12:55,680
map directly some

00:12:53,519 --> 00:12:57,440
external flash memory or ram into your

00:12:55,680 --> 00:12:57,680
chip memory space so that you can use it

00:12:57,440 --> 00:13:00,399
as

00:12:57,680 --> 00:13:02,240
extra memory or you can use it in an

00:13:00,399 --> 00:13:03,040
indirect way just kind of like a spy

00:13:02,240 --> 00:13:04,800
peripheral

00:13:03,040 --> 00:13:06,320
where you just do register rights

00:13:04,800 --> 00:13:09,600
register reads and such to

00:13:06,320 --> 00:13:10,880
various other portions of whatever chip

00:13:09,600 --> 00:13:12,880
you have on the other end

00:13:10,880 --> 00:13:16,160
we also have a driver crate going now

00:13:12,880 --> 00:13:18,480
for our ad9959 which is the dds chip

00:13:16,160 --> 00:13:20,639
that generates all of the sinusoidal

00:13:18,480 --> 00:13:22,079
outputs we're able to read back any of

00:13:20,639 --> 00:13:24,320
the frequencies phases

00:13:22,079 --> 00:13:28,000
amplitudes configure the clock for the

00:13:24,320 --> 00:13:28,000
um dds chip and all of that

00:13:28,720 --> 00:13:32,720
and so now i kind of wanted to get into

00:13:30,959 --> 00:13:34,959
more like what did we learn from this

00:13:32,720 --> 00:13:37,839
whole experience

00:13:34,959 --> 00:13:39,279
one embedded rust is extremely effective

00:13:37,839 --> 00:13:40,480
when you're trying to do really high

00:13:39,279 --> 00:13:42,079
performance time in critical

00:13:40,480 --> 00:13:43,440
applications which was a bit surprising

00:13:42,079 --> 00:13:45,839
to me coming from

00:13:43,440 --> 00:13:46,720
a c c plus plus background where you

00:13:45,839 --> 00:13:48,720
really

00:13:46,720 --> 00:13:50,399
you've dug into some of the disassembly

00:13:48,720 --> 00:13:51,920
listings of your previous application so

00:13:50,399 --> 00:13:52,480
you know exactly what the compiler is

00:13:51,920 --> 00:13:54,399
generating

00:13:52,480 --> 00:13:57,199
rust it's a bit less transparent because

00:13:54,399 --> 00:13:59,120
it's a bit more of a new language for me

00:13:57,199 --> 00:14:00,880
and so really being able to hit that

00:13:59,120 --> 00:14:02,480
like hit those timing requirements we

00:14:00,880 --> 00:14:03,680
needed being able to analyze it with

00:14:02,480 --> 00:14:05,360
logic analyzers and

00:14:03,680 --> 00:14:07,199
visualizing the output and saying like

00:14:05,360 --> 00:14:08,399
oh yes we're hitting our 500 kilos we

00:14:07,199 --> 00:14:09,600
can see exactly where we're spending

00:14:08,399 --> 00:14:12,880
time it was really

00:14:09,600 --> 00:14:15,600
fascinating to see one thing that was

00:14:12,880 --> 00:14:16,320
interesting to me is that we had a lot

00:14:15,600 --> 00:14:18,079
of

00:14:16,320 --> 00:14:19,760
difficulty with hal and i think this was

00:14:18,079 --> 00:14:21,199
largely because the how was new

00:14:19,760 --> 00:14:23,600
and we have managed to work through the

00:14:21,199 --> 00:14:25,120
fixes by working with the creator which

00:14:23,600 --> 00:14:27,360
richard meadows if you're watching this

00:14:25,120 --> 00:14:28,959
thank you very much that is a fantastic

00:14:27,360 --> 00:14:30,399
how i believe he gave a presentation

00:14:28,959 --> 00:14:33,440
earlier

00:14:30,399 --> 00:14:35,440
but what i mean is with the stm32 house

00:14:33,440 --> 00:14:37,440
typically the peripheral has to be

00:14:35,440 --> 00:14:38,800
enabled before you can start working

00:14:37,440 --> 00:14:40,480
with it so that it allows

00:14:38,800 --> 00:14:42,000
essentially a clock to go to the portion

00:14:40,480 --> 00:14:43,279
of silicon that you're actually working

00:14:42,000 --> 00:14:46,160
with

00:14:43,279 --> 00:14:47,760
and the quad spy did not have any of any

00:14:46,160 --> 00:14:49,600
implementation yet because it's a

00:14:47,760 --> 00:14:51,199
relatively young hell and so there's a

00:14:49,600 --> 00:14:53,279
lot that still needs to be done and it's

00:14:51,199 --> 00:14:55,199
a very complex chip and there's

00:14:53,279 --> 00:14:56,320
the data sheet is probably about 2 000

00:14:55,199 --> 00:14:59,199
pages long it's

00:14:56,320 --> 00:15:00,399
a little brutal and so trying to

00:14:59,199 --> 00:15:02,399
implement a custom

00:15:00,399 --> 00:15:03,920
quad spy interface wasn't actually

00:15:02,399 --> 00:15:06,320
possible with the existing how

00:15:03,920 --> 00:15:09,199
because the peripheral enables were all

00:15:06,320 --> 00:15:11,519
hidden within the hal crate and so

00:15:09,199 --> 00:15:12,480
using any of the spy or i squared c

00:15:11,519 --> 00:15:14,160
interfaces

00:15:12,480 --> 00:15:17,279
didn't allow us to implement our own

00:15:14,160 --> 00:15:19,120
custom quad spy interface

00:15:17,279 --> 00:15:20,959
so what i'm trying to say is when we're

00:15:19,120 --> 00:15:23,920
trying to architect our house let's try

00:15:20,959 --> 00:15:25,279
and make them as versatile as we can for

00:15:23,920 --> 00:15:27,440
when people are trying to implement

00:15:25,279 --> 00:15:30,720
their own custom implementations as well

00:15:27,440 --> 00:15:32,880
while working within the hal framework

00:15:30,720 --> 00:15:35,279
however what we did find is that hows

00:15:32,880 --> 00:15:36,959
are extremely versatile and when we're

00:15:35,279 --> 00:15:38,480
trying to make really custom high

00:15:36,959 --> 00:15:41,040
performance behavior

00:15:38,480 --> 00:15:42,639
for example the adcs that we have on the

00:15:41,040 --> 00:15:44,880
stabilizer front end

00:15:42,639 --> 00:15:47,519
require when the chip select goes low

00:15:44,880 --> 00:15:49,040
you need to wait 220 nanoseconds before

00:15:47,519 --> 00:15:50,480
you start clocking out

00:15:49,040 --> 00:15:52,639
any of the data because it needs to

00:15:50,480 --> 00:15:53,759
convert that and we were able to

00:15:52,639 --> 00:15:56,959
essentially

00:15:53,759 --> 00:15:58,800
allow the hal for the spy

00:15:56,959 --> 00:16:00,560
to take in a custom configuration

00:15:58,800 --> 00:16:01,680
structure that specified all of these

00:16:00,560 --> 00:16:04,000
hardware level

00:16:01,680 --> 00:16:05,600
configurations so that even though we

00:16:04,000 --> 00:16:07,199
weren't having any software intervention

00:16:05,600 --> 00:16:09,199
for these kind of

00:16:07,199 --> 00:16:11,440
transaction so there's no timer wait for

00:16:09,199 --> 00:16:12,720
this 220 nanoseconds to elapse before we

00:16:11,440 --> 00:16:14,560
do the transfer

00:16:12,720 --> 00:16:16,480
we passed all of that configuration into

00:16:14,560 --> 00:16:18,079
the spy constructor in the hal

00:16:16,480 --> 00:16:19,759
and it automatically was able to

00:16:18,079 --> 00:16:21,600
configure the peripheral to operate in

00:16:19,759 --> 00:16:23,040
that way so we were able to pass these

00:16:21,600 --> 00:16:25,360
really hardware independent

00:16:23,040 --> 00:16:27,279
hardware dependent configurations

00:16:25,360 --> 00:16:29,759
through this agnostic driver interface

00:16:27,279 --> 00:16:31,839
and it was really impressive to see

00:16:29,759 --> 00:16:33,600
we also discovered that interface

00:16:31,839 --> 00:16:34,240
programming and the embedded hal allows

00:16:33,600 --> 00:16:37,360
us to

00:16:34,240 --> 00:16:39,120
rapidly develop things in the sense

00:16:37,360 --> 00:16:42,320
where we can develop the ad

00:16:39,120 --> 00:16:44,480
dds chip driver without having any

00:16:42,320 --> 00:16:46,240
hardware we can just go ahead and

00:16:44,480 --> 00:16:48,000
start thinking logically reading through

00:16:46,240 --> 00:16:50,320
the datasheet implementing things and

00:16:48,000 --> 00:16:52,240
compiling it and checking all of that

00:16:50,320 --> 00:16:53,759
and that really allows us power while

00:16:52,240 --> 00:16:55,199
we're working with our schedules

00:16:53,759 --> 00:16:57,600
and that's kind of what i wanted to get

00:16:55,199 --> 00:16:59,680
into in the next portion as well

00:16:57,600 --> 00:17:01,519
is that what was truly impressive to me

00:16:59,680 --> 00:17:02,240
is how much of this we were able to

00:17:01,519 --> 00:17:05,199
accomplish

00:17:02,240 --> 00:17:06,319
using pre-built blocks from rust and

00:17:05,199 --> 00:17:08,480
from cargo

00:17:06,319 --> 00:17:10,079
because we're able to leverage arctic

00:17:08,480 --> 00:17:12,079
for building all of our task and

00:17:10,079 --> 00:17:13,839
resource management in the application

00:17:12,079 --> 00:17:15,760
we're able to use the hal for doing a

00:17:13,839 --> 00:17:17,679
vast majority of all of our peripheral

00:17:15,760 --> 00:17:20,240
configuration and development

00:17:17,679 --> 00:17:21,760
i the only the largest amount of time i

00:17:20,240 --> 00:17:23,919
spent working at the hardware level was

00:17:21,760 --> 00:17:26,079
developing the quad spy interface

00:17:23,919 --> 00:17:29,440
we were able to essentially just drop in

00:17:26,079 --> 00:17:31,840
an entire tcp ip stack using small tcp

00:17:29,440 --> 00:17:33,679
in probably not even more than about two

00:17:31,840 --> 00:17:35,840
to three hours before i was talking to

00:17:33,679 --> 00:17:37,440
it from my linux computer

00:17:35,840 --> 00:17:39,600
and then we were able to use a number of

00:17:37,440 --> 00:17:41,520
pre-built device driver crates such as

00:17:39,600 --> 00:17:42,880
the gpio expander on the pounder

00:17:41,520 --> 00:17:44,880
hardware

00:17:42,880 --> 00:17:47,440
and so really what this gets into is

00:17:44,880 --> 00:17:50,400
that it is

00:17:47,440 --> 00:17:51,919
truly absurd to me how quickly we can

00:17:50,400 --> 00:17:53,760
develop applications when we can

00:17:51,919 --> 00:17:54,480
leverage the cargo ecosystem and so

00:17:53,760 --> 00:17:56,000
really

00:17:54,480 --> 00:17:57,679
what i want to try and point out here is

00:17:56,000 --> 00:17:59,520
that as a result of that we should

00:17:57,679 --> 00:18:01,799
really try and pay it forward

00:17:59,520 --> 00:18:04,640
so taking our custom driver creates

00:18:01,799 --> 00:18:06,640
89.959 dds chip even if

00:18:04,640 --> 00:18:08,559
maybe likely no one else is going to be

00:18:06,640 --> 00:18:10,160
using that it's a very complex chip

00:18:08,559 --> 00:18:11,679
kind of a niche market in quantum

00:18:10,160 --> 00:18:13,520
physics but

00:18:11,679 --> 00:18:14,799
maybe we can still publish those and

00:18:13,520 --> 00:18:18,240
give them because

00:18:14,799 --> 00:18:18,880
give them out put them out into cargo

00:18:18,240 --> 00:18:20,799
because

00:18:18,880 --> 00:18:21,919
that helps develop the ecosystem and

00:18:20,799 --> 00:18:24,080
when we introduce

00:18:21,919 --> 00:18:25,360
more driver chips then we obviously get

00:18:24,080 --> 00:18:26,880
more interest in the language and

00:18:25,360 --> 00:18:28,480
women's more interest more people are

00:18:26,880 --> 00:18:30,240
writing drivers suddenly

00:18:28,480 --> 00:18:32,160
we reap the benefits of that even if

00:18:30,240 --> 00:18:34,640
we're our own private company

00:18:32,160 --> 00:18:36,160
because other people are now providing

00:18:34,640 --> 00:18:38,080
drivers that we can leverage in our

00:18:36,160 --> 00:18:39,600
products as well

00:18:38,080 --> 00:18:41,039
other ways we can help pay it back

00:18:39,600 --> 00:18:43,120
through these projects implementing bug

00:18:41,039 --> 00:18:45,679
fixes and house we worked closely with a

00:18:43,120 --> 00:18:47,760
lot of the guys over at the stm h7 hal

00:18:45,679 --> 00:18:48,799
to implement changes into the api and

00:18:47,760 --> 00:18:51,200
such so that

00:18:48,799 --> 00:18:53,600
things just worked smoother we can

00:18:51,200 --> 00:18:56,480
provide usage examples and we can help

00:18:53,600 --> 00:18:58,640
improve various interfaces and how the

00:18:56,480 --> 00:19:00,640
pals are interacting with our code

00:18:58,640 --> 00:19:02,640
and all of that is helped to help kind

00:19:00,640 --> 00:19:04,640
of drive the ecosystem forward and help

00:19:02,640 --> 00:19:07,440
with adoption

00:19:04,640 --> 00:19:08,880
and i just want to really stress how

00:19:07,440 --> 00:19:10,480
incredible it was for me working with

00:19:08,880 --> 00:19:13,200
this project because we got

00:19:10,480 --> 00:19:15,360
a high speed timing critical application

00:19:13,200 --> 00:19:17,520
with the networking interface

00:19:15,360 --> 00:19:18,880
going in less than a hundred hours

00:19:17,520 --> 00:19:21,520
that's less than

00:19:18,880 --> 00:19:23,360
two and a half weeks to get a fully

00:19:21,520 --> 00:19:26,000
functional prototype going

00:19:23,360 --> 00:19:27,039
for our client now it i truly think

00:19:26,000 --> 00:19:30,160
you're doing

00:19:27,039 --> 00:19:31,840
a disservice to anything if you're

00:19:30,160 --> 00:19:34,000
to any of your development if you're not

00:19:31,840 --> 00:19:35,280
looking into rust as a potential source

00:19:34,000 --> 00:19:36,480
for embedded development and that's

00:19:35,280 --> 00:19:39,440
coming from an environment

00:19:36,480 --> 00:19:41,039
using c assembly and c plus plus as well

00:19:39,440 --> 00:19:43,039
because just the amount i was able to

00:19:41,039 --> 00:19:45,760
get done in this road amount of time was

00:19:43,039 --> 00:19:46,320
truly absurd if you look at this there's

00:19:45,760 --> 00:19:48,960
um

00:19:46,320 --> 00:19:50,080
this is a tracking of the time i spent

00:19:48,960 --> 00:19:53,360
on this project

00:19:50,080 --> 00:19:54,960
and the first portion here in april was

00:19:53,360 --> 00:19:55,919
before we had any hardware available

00:19:54,960 --> 00:19:57,840
this was all just

00:19:55,919 --> 00:19:58,960
software development from a high level

00:19:57,840 --> 00:20:00,240
perspective we

00:19:58,960 --> 00:20:02,080
took a break in may while we were

00:20:00,240 --> 00:20:03,679
waiting for the hardware to come in and

00:20:02,080 --> 00:20:04,320
then over the next two weeks once we had

00:20:03,679 --> 00:20:06,960
hardware

00:20:04,320 --> 00:20:07,919
we did all the testing got it up working

00:20:06,960 --> 00:20:11,039
and it was truly

00:20:07,919 --> 00:20:12,640
an impressive experience so i guess what

00:20:11,039 --> 00:20:14,240
i really want to say is embedded rest is

00:20:12,640 --> 00:20:15,760
definitely production ready and i think

00:20:14,240 --> 00:20:18,799
a lot of people are missing out

00:20:15,760 --> 00:20:20,640
by not taking the chance to look at it

00:20:18,799 --> 00:20:22,400
there's a lot of libraries you can

00:20:20,640 --> 00:20:24,320
leverage and even if the libraries

00:20:22,400 --> 00:20:27,600
aren't fully functional yet

00:20:24,320 --> 00:20:29,039
it's still more than what you would have

00:20:27,600 --> 00:20:31,200
otherwise because all of this hal

00:20:29,039 --> 00:20:33,039
development when you're doing your own

00:20:31,200 --> 00:20:35,280
implementation is something you would

00:20:33,039 --> 00:20:36,960
have to do anyways it's something in a c

00:20:35,280 --> 00:20:38,720
project where you assume that's going to

00:20:36,960 --> 00:20:40,240
be the first few months of development

00:20:38,720 --> 00:20:42,480
you're just going to get the i scored c

00:20:40,240 --> 00:20:44,880
implementation of the spy going

00:20:42,480 --> 00:20:46,720
and so really even if it's still

00:20:44,880 --> 00:20:47,440
preliminary or it's hobbyist level or

00:20:46,720 --> 00:20:49,440
enthusiast

00:20:47,440 --> 00:20:51,280
it's still more than what you have now

00:20:49,440 --> 00:20:55,440
and that's a really valuable poor

00:20:51,280 --> 00:20:57,919
place to come from so going forward this

00:20:55,440 --> 00:20:59,760
project we really want to replace our

00:20:57,919 --> 00:21:01,679
tcp server that's sitting on top of the

00:20:59,760 --> 00:21:03,360
stack because it's kind of this custom

00:21:01,679 --> 00:21:04,480
cerdy json that doesn't really make

00:21:03,360 --> 00:21:06,240
sense

00:21:04,480 --> 00:21:08,240
because it's only request response

00:21:06,240 --> 00:21:10,159
oriented we want to replace that with an

00:21:08,240 --> 00:21:12,159
mqtt interface which is

00:21:10,159 --> 00:21:13,760
if you don't know what mqtt is it's kind

00:21:12,159 --> 00:21:15,440
of an iot protocol where

00:21:13,760 --> 00:21:18,080
essentially you can broadcast to some

00:21:15,440 --> 00:21:19,919
broker the broker will then facilitate

00:21:18,080 --> 00:21:21,919
message passing to various clients and

00:21:19,919 --> 00:21:22,320
so there's nice applications on linux

00:21:21,919 --> 00:21:25,440
that

00:21:22,320 --> 00:21:26,960
you just run a broker and your whatever

00:21:25,440 --> 00:21:27,520
you want can connect to it your little

00:21:26,960 --> 00:21:29,679
iot

00:21:27,520 --> 00:21:31,200
node and transmit temperature data or

00:21:29,679 --> 00:21:32,960
any kind of telemetry

00:21:31,200 --> 00:21:35,039
and then you can hook up a client on

00:21:32,960 --> 00:21:36,240
your laptop and it'll plot all the data

00:21:35,039 --> 00:21:38,159
in real time and so

00:21:36,240 --> 00:21:40,000
there's also brokers that'll hook up to

00:21:38,159 --> 00:21:42,159
web-based interfaces so that you can

00:21:40,000 --> 00:21:43,440
store all this data into the cloud

00:21:42,159 --> 00:21:45,280
and so what we want to do is try and

00:21:43,440 --> 00:21:47,280
move a lot of the telemetry that

00:21:45,280 --> 00:21:50,080
stabilizer and pounder generate

00:21:47,280 --> 00:21:51,600
and broadcast that over mqtt instead we

00:21:50,080 --> 00:21:54,559
also want to work on getting a lot of

00:21:51,600 --> 00:21:57,360
our hal implementations back into

00:21:54,559 --> 00:21:58,640
the actual how uh we have the q spy

00:21:57,360 --> 00:22:00,640
sitting as a draft pr

00:21:58,640 --> 00:22:02,080
we've got custom spy configurations that

00:22:00,640 --> 00:22:02,720
we're working on getting the pr and

00:22:02,080 --> 00:22:04,720
still

00:22:02,720 --> 00:22:05,760
there's a number of dma implementations

00:22:04,720 --> 00:22:08,799
that we did

00:22:05,760 --> 00:22:10,320
a little bit hacky but work

00:22:08,799 --> 00:22:12,640
and so we're looking at how we can try

00:22:10,320 --> 00:22:14,799
and incorporate that back in

00:22:12,640 --> 00:22:16,480
so as a last thing i just wanted to have

00:22:14,799 --> 00:22:17,600
a shameless plug here for quartic

00:22:16,480 --> 00:22:19,679
quartic is currently

00:22:17,600 --> 00:22:20,640
looking for an engineer to help them

00:22:19,679 --> 00:22:22,480
with some of this

00:22:20,640 --> 00:22:23,919
embedded rest development in quantum

00:22:22,480 --> 00:22:25,919
computing so

00:22:23,919 --> 00:22:28,080
if you are interested in looking for a

00:22:25,919 --> 00:22:30,480
job please get in contact with me and i

00:22:28,080 --> 00:22:32,720
will get you in contact with cortic

00:22:30,480 --> 00:22:33,679
thank you very much i appreciate all of

00:22:32,720 --> 00:22:37,120
you listening

00:22:33,679 --> 00:22:37,120
i think that is all i have for now

00:22:38,080 --> 00:22:41,280
all right great thank you so much for

00:22:39,440 --> 00:22:42,960
the presentation we have a couple of

00:22:41,280 --> 00:22:44,159
questions ready to go and a lot of

00:22:42,960 --> 00:22:47,360
people excited about

00:22:44,159 --> 00:22:48,159
uh embedded rust being ready so i'll

00:22:47,360 --> 00:22:49,600
start with the

00:22:48,159 --> 00:22:51,600
the first question was did you use

00:22:49,600 --> 00:22:54,080
arctic for all of the timing functions

00:22:51,600 --> 00:22:57,679
you mentioned in the project

00:22:54,080 --> 00:22:59,200
yeah i artic was basically the whole

00:22:57,679 --> 00:22:59,760
framework that we were using without the

00:22:59,200 --> 00:23:03,360
whole thing

00:22:59,760 --> 00:23:04,799
um all of the timing for like adcs and

00:23:03,360 --> 00:23:05,520
stuff was all done at a hardware level

00:23:04,799 --> 00:23:08,559
there

00:23:05,520 --> 00:23:09,520
was we didn't use so in terms of

00:23:08,559 --> 00:23:13,039
scheduling the

00:23:09,520 --> 00:23:14,480
trend the filters to execute that was

00:23:13,039 --> 00:23:15,440
all done using a hardware peripheral

00:23:14,480 --> 00:23:17,120
timer

00:23:15,440 --> 00:23:19,120
so it wasn't using any of the cycle

00:23:17,120 --> 00:23:20,720
counter monotonic of arctic or anything

00:23:19,120 --> 00:23:23,200
like that

00:23:20,720 --> 00:23:24,400
great uh our next question is regarding

00:23:23,200 --> 00:23:26,320
extendable house

00:23:24,400 --> 00:23:28,320
this is a super good point did you add a

00:23:26,320 --> 00:23:30,000
solution for that in the h7 hal or do

00:23:28,320 --> 00:23:30,720
you have any ideas for how to do it in a

00:23:30,000 --> 00:23:32,000
neat way

00:23:30,720 --> 00:23:35,440
uh we have someone who would love to do

00:23:32,000 --> 00:23:35,440
something similar with the f1

00:23:35,600 --> 00:23:39,760
yeah so i did not implement the solution

00:23:38,240 --> 00:23:42,559
but richard meadows did

00:23:39,760 --> 00:23:43,679
um what he got going is a really nice

00:23:42,559 --> 00:23:45,760
solution and it's

00:23:43,679 --> 00:23:47,200
i it's called the p-rex structure and i

00:23:45,760 --> 00:23:48,400
don't know exactly what it stands for

00:23:47,200 --> 00:23:51,919
but essentially it's

00:23:48,400 --> 00:23:55,120
an interface that abstracts the stm32

00:23:51,919 --> 00:23:57,039
rcc into a programmable reset and

00:23:55,120 --> 00:23:59,440
control interface so essentially

00:23:57,039 --> 00:24:01,679
it exposes a public api for resetting a

00:23:59,440 --> 00:24:04,240
peripheral or enabling a peripheral

00:24:01,679 --> 00:24:05,679
um so take a look at the h7 how for the

00:24:04,240 --> 00:24:07,679
p-rex structure and that's a great

00:24:05,679 --> 00:24:09,840
implementation

00:24:07,679 --> 00:24:11,520
great uh the next question is would you

00:24:09,840 --> 00:24:12,880
want to change anything in the ecosystem

00:24:11,520 --> 00:24:14,799
with your project if you were starting

00:24:12,880 --> 00:24:17,440
over

00:24:14,799 --> 00:24:18,080
or anything in the ecosystem or with

00:24:17,440 --> 00:24:20,799
your project

00:24:18,080 --> 00:24:22,400
if you were starting over if i was

00:24:20,799 --> 00:24:24,400
starting over i would not have gone for

00:24:22,400 --> 00:24:25,840
a custom tcp server implementation i

00:24:24,400 --> 00:24:29,039
would have rather gone with the

00:24:25,840 --> 00:24:29,679
an mqtt kind of implementation there

00:24:29,039 --> 00:24:32,720
aren't

00:24:29,679 --> 00:24:34,480
there are some still heavily in develop

00:24:32,720 --> 00:24:35,919
heavily in development and qtt

00:24:34,480 --> 00:24:37,360
implementations that we were looking at

00:24:35,919 --> 00:24:40,480
but it was a little too early

00:24:37,360 --> 00:24:43,279
initially so we have cortic has

00:24:40,480 --> 00:24:44,240
a prototype mqtt implementation going

00:24:43,279 --> 00:24:45,520
and i've had it

00:24:44,240 --> 00:24:47,279
running on the nucleo board and

00:24:45,520 --> 00:24:48,880
reporting up a little temperature sensor

00:24:47,279 --> 00:24:49,520
lately so we're working on stabilizing

00:24:48,880 --> 00:24:53,039
that

00:24:49,520 --> 00:24:54,720
as well great uh we have someone asking

00:24:53,039 --> 00:24:56,480
how to contact you uh that might be

00:24:54,720 --> 00:24:58,400
better to drop into the chat um

00:24:56,480 --> 00:25:01,279
someone's still typing so

00:24:58,400 --> 00:25:14,320
sorry go ahead i'll hop into uh matrix

00:25:01,279 --> 00:25:14,320

YouTube URL: https://www.youtube.com/watch?v=OawVYsTUyrM


