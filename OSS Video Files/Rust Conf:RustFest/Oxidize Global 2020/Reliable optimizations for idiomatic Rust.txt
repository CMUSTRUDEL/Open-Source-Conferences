Title: Reliable optimizations for idiomatic Rust
Publication date: 2020-11-06
Playlist: Oxidize Global 2020
Description: 
	Optimizations are mainly known for

 - making code fast,
 - aggravating undefined behavior, and
 - making developers suffer during debugging.


In the Rust compiler we have a scheme that allows us to optimize code without affecting the debug-ability while at the same time actually causing compile time speed ups. This talk first introduces the MIR, on which the Rust compiler does optimizations. Then various concepts are explained, which allow us to write idiomatic Rust and still getting performance that hand-crafted low level code can’t beat. Finally an outlook on cool-things-to-come ™️ shows how language-guaranteed optimizations can be leveraged in resource constrained environments.
Captions: 
	00:00:01,770 --> 00:00:35,360
[Music]

00:00:32,640 --> 00:00:36,559
all right hi there ollie

00:00:35,360 --> 00:00:38,000
all right thanks so much for joining us

00:00:36,559 --> 00:00:40,000
again on short notice i think you put

00:00:38,000 --> 00:00:41,360
out a tweet beginning of this week or

00:00:40,000 --> 00:00:42,719
end of last week and you're like i

00:00:41,360 --> 00:00:45,600
really want to talk about this and we're

00:00:42,719 --> 00:00:47,440
like we have a place for you

00:00:45,600 --> 00:00:48,879
i was super glad to have you last minute

00:00:47,440 --> 00:00:51,039
and i'll go ahead and hand it over to

00:00:48,879 --> 00:00:54,480
you

00:00:51,039 --> 00:00:58,719
okay thanks so hi everyone

00:00:54,480 --> 00:01:01,039
um this is my other hat

00:00:58,719 --> 00:01:02,160
i do lots of cons stuff but i also do

00:01:01,039 --> 00:01:03,760
optimizations

00:01:02,160 --> 00:01:05,680
in ros compiler so today i'm going to

00:01:03,760 --> 00:01:09,119
talk to you about

00:01:05,680 --> 00:01:13,040
how we do fancy optimizations in rest

00:01:09,119 --> 00:01:15,520
that make our lives in

00:01:13,040 --> 00:01:17,759
easier in many many ways that were

00:01:15,520 --> 00:01:18,799
unintended before we even

00:01:17,759 --> 00:01:20,960
when we started to do these

00:01:18,799 --> 00:01:23,040
optimizations but

00:01:20,960 --> 00:01:25,200
as usually with rust things get really

00:01:23,040 --> 00:01:27,920
cool once you start digging into it

00:01:25,200 --> 00:01:29,360
so just quick reminder i have this logo

00:01:27,920 --> 00:01:31,280
so if you see this anywhere this is very

00:01:29,360 --> 00:01:35,360
likely to be me

00:01:31,280 --> 00:01:38,320
and yeah just say hi if you see me

00:01:35,360 --> 00:01:39,520
so let's dig into rust optimizations

00:01:38,320 --> 00:01:42,799
before we do that

00:01:39,520 --> 00:01:43,920
um what are we optimizing um i have to

00:01:42,799 --> 00:01:47,600
introduce a few

00:01:43,920 --> 00:01:48,880
uh words so um let's start with the mir

00:01:47,600 --> 00:01:51,119
this is the medium intermediate

00:01:48,880 --> 00:01:53,600
representation in the rust compiler

00:01:51,119 --> 00:01:54,880
which is placed around here so you go

00:01:53,600 --> 00:01:57,360
from source code

00:01:54,880 --> 00:01:58,159
over abstract syntax tree into some kind

00:01:57,360 --> 00:02:01,200
of higher

00:01:58,159 --> 00:02:03,680
intermediate representation and

00:02:01,200 --> 00:02:05,759
finally we go into the mir and from that

00:02:03,680 --> 00:02:09,280
we go to llam or cranelift

00:02:05,759 --> 00:02:12,239
for generating assembly code

00:02:09,280 --> 00:02:12,879
lots of optimizations happen in lvm but

00:02:12,239 --> 00:02:15,599
we have

00:02:12,879 --> 00:02:17,040
done a few optimizations on mir and

00:02:15,599 --> 00:02:17,920
these have been really really high

00:02:17,040 --> 00:02:21,360
impact

00:02:17,920 --> 00:02:24,400
so let's look at mir first mir

00:02:21,360 --> 00:02:26,480
is basically rust but

00:02:24,400 --> 00:02:27,680
remove all syntax sugar that you can

00:02:26,480 --> 00:02:30,560
think of

00:02:27,680 --> 00:02:32,080
so if there's anything that happens with

00:02:30,560 --> 00:02:34,319
any kind of magic

00:02:32,080 --> 00:02:36,080
it's not happening on mrr mir is really

00:02:34,319 --> 00:02:39,040
really low level rest so

00:02:36,080 --> 00:02:40,160
you have no macros you have no loops you

00:02:39,040 --> 00:02:43,840
you really have goto

00:02:40,160 --> 00:02:46,239
in in um mr it's it's that bad

00:02:43,840 --> 00:02:47,519
yeah there's no if no match you have a

00:02:46,239 --> 00:02:48,959
switch similar to c

00:02:47,519 --> 00:02:51,040
you're basically just switching on

00:02:48,959 --> 00:02:52,000
integers there's no type inference trade

00:02:51,040 --> 00:02:53,360
resolution

00:02:52,000 --> 00:02:55,440
all your function calls are going to be

00:02:53,360 --> 00:02:56,959
like fully qualified function calls you

00:02:55,440 --> 00:03:00,400
write the entire path

00:02:56,959 --> 00:03:00,720
in mir there's no auto draft so you have

00:03:00,400 --> 00:03:02,400
to

00:03:00,720 --> 00:03:04,000
write all the stars and reference

00:03:02,400 --> 00:03:07,040
operators that you

00:03:04,000 --> 00:03:08,800
normally take for granted and rest and

00:03:07,040 --> 00:03:10,000
there's no expression chaining so every

00:03:08,800 --> 00:03:12,640
expression

00:03:10,000 --> 00:03:13,040
is a single operation you can't do a

00:03:12,640 --> 00:03:15,760
plus b

00:03:13,040 --> 00:03:16,480
plus c you have to do a plus b stored in

00:03:15,760 --> 00:03:18,720
a variable

00:03:16,480 --> 00:03:19,760
and then do plus c in a different way so

00:03:18,720 --> 00:03:22,720
there's no

00:03:19,760 --> 00:03:23,519
no complex things in mrr the cool thing

00:03:22,720 --> 00:03:25,360
about that is

00:03:23,519 --> 00:03:27,840
it makes optimizations much easier and

00:03:25,360 --> 00:03:31,200
it makes lots of analyses much easier

00:03:27,840 --> 00:03:32,159
so um let's look at an example how mr

00:03:31,200 --> 00:03:34,799
looks

00:03:32,159 --> 00:03:35,680
um this is rest there's not mr yet but

00:03:34,799 --> 00:03:38,959
just a demo

00:03:35,680 --> 00:03:41,040
so if we have this piece of rest code um

00:03:38,959 --> 00:03:42,400
we have a small assignment 2x we have

00:03:41,040 --> 00:03:45,040
some operation

00:03:42,400 --> 00:03:46,080
during the assignment where we compute

00:03:45,040 --> 00:03:48,959
42 to the power

00:03:46,080 --> 00:03:50,640
of three we do a condition and after the

00:03:48,959 --> 00:03:52,560
condition we either go into loop or we

00:03:50,640 --> 00:03:55,920
finish our program

00:03:52,560 --> 00:03:58,560
so um in mir

00:03:55,920 --> 00:03:59,200
this looks like this so what's going on

00:03:58,560 --> 00:04:00,720
here

00:03:59,200 --> 00:04:03,950
at the beginning you still see your main

00:04:00,720 --> 00:04:05,120
function this time was an explicit type

00:04:03,950 --> 00:04:09,840
[Music]

00:04:05,120 --> 00:04:12,959
similar to on cc you have to specify all

00:04:09,840 --> 00:04:15,280
local variables in the beginning so you

00:04:12,959 --> 00:04:18,799
declare all your variables and then you

00:04:15,280 --> 00:04:19,600
write code but um in contrast to rest

00:04:18,799 --> 00:04:22,079
code

00:04:19,600 --> 00:04:23,600
um where you write your code it was like

00:04:22,079 --> 00:04:25,919
blocks and

00:04:23,600 --> 00:04:28,000
well how you write last code obviously

00:04:25,919 --> 00:04:31,120
here we have so-called basic blocks

00:04:28,000 --> 00:04:34,960
you see them specified with bb0 bb1

00:04:31,120 --> 00:04:40,000
and so on and these basic blocks

00:04:34,960 --> 00:04:43,199
are essentially a single unit of

00:04:40,000 --> 00:04:45,280
execution that you

00:04:43,199 --> 00:04:46,400
fill with statements and at the end of

00:04:45,280 --> 00:04:48,000
this

00:04:46,400 --> 00:04:50,479
basic block you have a so-called

00:04:48,000 --> 00:04:52,160
terminator which moves to another block

00:04:50,479 --> 00:04:54,160
or which returns

00:04:52,160 --> 00:04:56,400
and here you can already see a bunch of

00:04:54,160 --> 00:04:59,440
go-to's and at the bottom

00:04:56,400 --> 00:05:01,039
these jump to other blocks and you can

00:04:59,440 --> 00:05:02,960
also see the switch end

00:05:01,039 --> 00:05:04,080
but this representation is not really

00:05:02,960 --> 00:05:06,160
fun to explore

00:05:04,080 --> 00:05:08,560
so we have a different one graphical

00:05:06,160 --> 00:05:09,680
ones so this is the same piece of code

00:05:08,560 --> 00:05:11,919
that you just saw

00:05:09,680 --> 00:05:13,199
but this time it's much easier to

00:05:11,919 --> 00:05:15,039
comprehend as a human

00:05:13,199 --> 00:05:16,400
so you start out with the power

00:05:15,039 --> 00:05:17,919
operation that we had

00:05:16,400 --> 00:05:19,919
as i already said you have a fully

00:05:17,919 --> 00:05:23,120
qualified path so there's the core

00:05:19,919 --> 00:05:24,800
num then there's the input block for i32

00:05:23,120 --> 00:05:26,240
in there there's a power function and

00:05:24,800 --> 00:05:28,160
then the arguments

00:05:26,240 --> 00:05:30,160
and after that's called we store the

00:05:28,160 --> 00:05:31,199
result in the variable underscore one

00:05:30,160 --> 00:05:34,400
whatever that means

00:05:31,199 --> 00:05:36,400
um then we go to the next block here we

00:05:34,400 --> 00:05:39,600
compare the variable and let's go one

00:05:36,400 --> 00:05:40,320
with a number get a result we switch on

00:05:39,600 --> 00:05:42,560
this number

00:05:40,320 --> 00:05:44,000
and if it's false we return otherwise we

00:05:42,560 --> 00:05:45,919
go to another block

00:05:44,000 --> 00:05:47,680
and then we end up in this loop that we

00:05:45,919 --> 00:05:49,280
saw so

00:05:47,680 --> 00:05:51,600
this is just a little bit of the basics

00:05:49,280 --> 00:05:53,440
of mir that we're going to need

00:05:51,600 --> 00:05:54,639
when i'm going to show you optimizations

00:05:53,440 --> 00:05:56,639
later

00:05:54,639 --> 00:05:58,160
so let's talk about optimizations in

00:05:56,639 --> 00:05:59,919
general

00:05:58,160 --> 00:06:02,720
optimizations are there to make your

00:05:59,919 --> 00:06:03,919
code fast you want the code to be small

00:06:02,720 --> 00:06:06,960
and you want to reduce your memory

00:06:03,919 --> 00:06:09,520
footprint this has several reasons

00:06:06,960 --> 00:06:10,880
you'd want to write high-level code but

00:06:09,520 --> 00:06:12,160
you still want the code to be fast so

00:06:10,880 --> 00:06:13,840
you don't want to do all these little

00:06:12,160 --> 00:06:14,960
bit twigly things just to make code

00:06:13,840 --> 00:06:18,479
faster

00:06:14,960 --> 00:06:21,039
you also don't want to use up a lot of

00:06:18,479 --> 00:06:22,160
program space on your embedded device

00:06:21,039 --> 00:06:24,560
for example

00:06:22,160 --> 00:06:26,240
um and so you want to shrink the code

00:06:24,560 --> 00:06:27,440
into the smallest thing possible

00:06:26,240 --> 00:06:29,520
and you want to reduce the memory

00:06:27,440 --> 00:06:31,120
footprint so if you call lots of

00:06:29,520 --> 00:06:33,919
functions each functional call

00:06:31,120 --> 00:06:35,199
needs lots of memory and yeah you just

00:06:33,919 --> 00:06:37,360
want to reduce it so that

00:06:35,199 --> 00:06:38,960
if you do lots of operations you don't

00:06:37,360 --> 00:06:41,199
run out of stack space or

00:06:38,960 --> 00:06:42,639
otherwise blow up your memory there's

00:06:41,199 --> 00:06:44,160
not even talking about memory leaks it's

00:06:42,639 --> 00:06:44,479
literally just about the memory usage

00:06:44,160 --> 00:06:47,600
that

00:06:44,479 --> 00:06:49,759
a normal program uses the other thing

00:06:47,600 --> 00:06:51,280
about optimizations is

00:06:49,759 --> 00:06:54,560
they make debugging basically a

00:06:51,280 --> 00:06:57,360
nightmare so if you ever used a debugger

00:06:54,560 --> 00:06:58,560
on an optimized program you probably

00:06:57,360 --> 00:07:01,120
went partially crazy

00:06:58,560 --> 00:07:02,240
um before either going back to print of

00:07:01,120 --> 00:07:05,039
debugging or

00:07:02,240 --> 00:07:06,960
turning off lots of optimizations so you

00:07:05,039 --> 00:07:08,960
could nicely debug your code

00:07:06,960 --> 00:07:11,039
the other thing that optimizations do is

00:07:08,960 --> 00:07:12,240
they make undefined behavior symptoms

00:07:11,039 --> 00:07:13,919
much much worse

00:07:12,240 --> 00:07:16,160
so optimizations are the things that

00:07:13,919 --> 00:07:19,599
actually abuse undefined behavior to

00:07:16,160 --> 00:07:22,960
cause well lots of fun behaviors that

00:07:19,599 --> 00:07:25,360
you've seen from undefined behavior

00:07:22,960 --> 00:07:26,000
and yeah so i'm going to talk about all

00:07:25,360 --> 00:07:29,520
these

00:07:26,000 --> 00:07:31,919
points but let's start out

00:07:29,520 --> 00:07:33,520
with one confusing thing about

00:07:31,919 --> 00:07:36,800
optimizations

00:07:33,520 --> 00:07:39,840
optimizations can reduce compile time

00:07:36,800 --> 00:07:41,520
so that seems like contradictory right

00:07:39,840 --> 00:07:44,560
you do more work

00:07:41,520 --> 00:07:47,840
and then you do less work

00:07:44,560 --> 00:07:48,560
so the thing is when you optimize out

00:07:47,840 --> 00:07:51,599
code

00:07:48,560 --> 00:07:53,440
later optimizations have to do less work

00:07:51,599 --> 00:07:55,120
so you have some cheap easy

00:07:53,440 --> 00:07:56,800
optimizations that you can do up front

00:07:55,120 --> 00:07:59,280
the next optimization has to do less

00:07:56,800 --> 00:08:02,560
work and will be faster

00:07:59,280 --> 00:08:04,720
and this is a

00:08:02,560 --> 00:08:05,840
super high impact if you are optimizing

00:08:04,720 --> 00:08:06,960
generic functions

00:08:05,840 --> 00:08:09,039
because generic functions are

00:08:06,960 --> 00:08:09,680
instantiated many times for each generic

00:08:09,039 --> 00:08:11,440
parameter

00:08:09,680 --> 00:08:13,680
when you're compiling down the assembly

00:08:11,440 --> 00:08:16,000
but if you optimize the generic function

00:08:13,680 --> 00:08:17,919
each instantiation of this generic

00:08:16,000 --> 00:08:20,160
function will have to do less work

00:08:17,919 --> 00:08:21,840
so for example vectors are used

00:08:20,160 --> 00:08:22,400
everywhere if you can optimize a

00:08:21,840 --> 00:08:25,759
function

00:08:22,400 --> 00:08:26,400
inside vector it will reduce the compile

00:08:25,759 --> 00:08:28,960
times

00:08:26,400 --> 00:08:30,400
because it's it's used in all kind of

00:08:28,960 --> 00:08:32,080
rust crates and

00:08:30,400 --> 00:08:34,240
with all kinds of types so each

00:08:32,080 --> 00:08:34,640
duplication you save a little bit there

00:08:34,240 --> 00:08:36,560
but

00:08:34,640 --> 00:08:38,839
if you have many duplications well you

00:08:36,560 --> 00:08:42,719
save a lot

00:08:38,839 --> 00:08:43,039
so um the next point that i talked about

00:08:42,719 --> 00:08:45,360
was

00:08:43,039 --> 00:08:46,320
optimizations optimizations makes things

00:08:45,360 --> 00:08:49,279
faster

00:08:46,320 --> 00:08:50,959
um for example take this for loop um a

00:08:49,279 --> 00:08:52,480
for loop and rust

00:08:50,959 --> 00:08:54,480
does several things when it's being

00:08:52,480 --> 00:08:55,440
compiled as first step if you take this

00:08:54,480 --> 00:08:58,000
for loop

00:08:55,440 --> 00:08:59,680
it will get converted into this beast so

00:08:58,000 --> 00:09:00,959
you have like this interior function

00:08:59,680 --> 00:09:03,920
call there's a loop

00:09:00,959 --> 00:09:04,560
there's a match on the iterator then you

00:09:03,920 --> 00:09:06,839
look at the

00:09:04,560 --> 00:09:08,240
sum and none and then it executes some

00:09:06,839 --> 00:09:11,279
code

00:09:08,240 --> 00:09:12,720
but that is a lot of noise just to

00:09:11,279 --> 00:09:15,120
iterate from the numbers

00:09:12,720 --> 00:09:15,839
from zero to n like you want this tight

00:09:15,120 --> 00:09:17,519
loop on

00:09:15,839 --> 00:09:20,000
in assembly where just incrementing a

00:09:17,519 --> 00:09:21,360
counter and then executing the loop body

00:09:20,000 --> 00:09:23,519
you don't want all this function call

00:09:21,360 --> 00:09:24,640
noise so there's lots of optimizations

00:09:23,519 --> 00:09:28,399
here where we

00:09:24,640 --> 00:09:30,640
uh clean up um this uh

00:09:28,399 --> 00:09:31,680
generated code um and then simplify it

00:09:30,640 --> 00:09:33,440
down to the point

00:09:31,680 --> 00:09:35,360
where you literally have this perfect

00:09:33,440 --> 00:09:38,480
assembly um

00:09:35,360 --> 00:09:40,959
tight loop that you want other things

00:09:38,480 --> 00:09:42,480
you want code to be small so if there's

00:09:40,959 --> 00:09:45,200
operations that you can

00:09:42,480 --> 00:09:46,000
remove without changing the program for

00:09:45,200 --> 00:09:49,120
example

00:09:46,000 --> 00:09:51,440
here we could divide do the division at

00:09:49,120 --> 00:09:54,000
compile time and just store the result

00:09:51,440 --> 00:09:55,040
um then you save some assembly

00:09:54,000 --> 00:09:57,600
instructions that

00:09:55,040 --> 00:09:59,600
you're not going to need because they're

00:09:57,600 --> 00:10:03,040
not going to happen at runtime

00:09:59,600 --> 00:10:03,040
and this makes your binary smaller

00:10:03,120 --> 00:10:06,800
um for reducing the memory footprint

00:10:05,440 --> 00:10:09,600
there's um

00:10:06,800 --> 00:10:11,440
optimizations for example inlining which

00:10:09,600 --> 00:10:13,040
takes the body for example of this do

00:10:11,440 --> 00:10:15,440
something function and just

00:10:13,040 --> 00:10:17,040
verbatim copies this body into this for

00:10:15,440 --> 00:10:19,440
loop directly

00:10:17,040 --> 00:10:21,519
here so you don't have a function call

00:10:19,440 --> 00:10:22,720
you don't have to store variables to

00:10:21,519 --> 00:10:24,160
stack or

00:10:22,720 --> 00:10:25,760
move some registers around you can

00:10:24,160 --> 00:10:26,320
literally just execute the code that's

00:10:25,760 --> 00:10:29,839
there

00:10:26,320 --> 00:10:33,279
and it saves you a bunch of memory

00:10:29,839 --> 00:10:35,120
during execution and the other thing

00:10:33,279 --> 00:10:36,079
that it can do it can open up new

00:10:35,120 --> 00:10:38,640
optimization

00:10:36,079 --> 00:10:40,240
avenues where after you do one

00:10:38,640 --> 00:10:43,040
optimization

00:10:40,240 --> 00:10:46,640
suddenly other optimizations jump in and

00:10:43,040 --> 00:10:49,519
do even more things okay

00:10:46,640 --> 00:10:50,240
um this was just a broad intro so let's

00:10:49,519 --> 00:10:51,839
actually look

00:10:50,240 --> 00:10:54,160
at optimizations because that's what

00:10:51,839 --> 00:10:57,040
you're here for right

00:10:54,160 --> 00:10:57,440
um there's a very common thing that is

00:10:57,040 --> 00:10:58,720
used

00:10:57,440 --> 00:11:01,040
in rust which is the question mic

00:10:58,720 --> 00:11:04,240
operator um and the thing

00:11:01,040 --> 00:11:06,399
was for a long time after it was

00:11:04,240 --> 00:11:09,279
stabilized i think over a year

00:11:06,399 --> 00:11:10,240
it was actually not optimized that well

00:11:09,279 --> 00:11:13,120
um

00:11:10,240 --> 00:11:15,279
it's allow me i'm just couldn't figure

00:11:13,120 --> 00:11:16,959
out like a pattern that was in there

00:11:15,279 --> 00:11:18,480
so i'm going to show you what pattern

00:11:16,959 --> 00:11:21,760
llm couldn't detect

00:11:18,480 --> 00:11:24,160
and what we did in rust to well

00:11:21,760 --> 00:11:25,760
optimize the question mark operator

00:11:24,160 --> 00:11:28,720
better

00:11:25,760 --> 00:11:30,160
so if you look at this piece of code we

00:11:28,720 --> 00:11:31,279
apply the question mark operator to the

00:11:30,160 --> 00:11:33,360
x variable

00:11:31,279 --> 00:11:35,360
add one to the result and then wrap it

00:11:33,360 --> 00:11:38,640
again in an okay

00:11:35,360 --> 00:11:39,839
so if we unroll this manually we would

00:11:38,640 --> 00:11:41,680
get something like this

00:11:39,839 --> 00:11:43,120
so there's a match on this variable if

00:11:41,680 --> 00:11:45,760
it's okay

00:11:43,120 --> 00:11:46,320
then we add one and put it back into it

00:11:45,760 --> 00:11:49,519
okay

00:11:46,320 --> 00:11:51,839
if it's an error then we create

00:11:49,519 --> 00:11:53,279
the error object object again and return

00:11:51,839 --> 00:11:55,600
that

00:11:53,279 --> 00:11:56,800
and if you look at this piece of rust

00:11:55,600 --> 00:11:59,200
code and then you

00:11:56,800 --> 00:12:00,399
look at the mir code for each of these

00:11:59,200 --> 00:12:02,880
branches

00:12:00,399 --> 00:12:04,959
you get mr code that looks like this so

00:12:02,880 --> 00:12:07,279
let me explain what's going on here

00:12:04,959 --> 00:12:08,560
we have the x variable and we are

00:12:07,279 --> 00:12:11,519
matching on it

00:12:08,560 --> 00:12:13,279
so then we want to read the a field from

00:12:11,519 --> 00:12:14,560
the okay block so what we're doing is

00:12:13,279 --> 00:12:17,839
we're

00:12:14,560 --> 00:12:21,200
actually accessing the first element

00:12:17,839 --> 00:12:24,160
of the okay tuple struct

00:12:21,200 --> 00:12:26,720
um which is with the dot zero operation

00:12:24,160 --> 00:12:29,760
and reading that into the variable a

00:12:26,720 --> 00:12:33,440
then we do an addition by adding 1

00:12:29,760 --> 00:12:37,600
to a and writing that into

00:12:33,440 --> 00:12:39,920
the first field of the ok tuple struct

00:12:37,600 --> 00:12:41,600
which is stored at the return place so

00:12:39,920 --> 00:12:44,800
it's stored where the return

00:12:41,600 --> 00:12:46,560
command would return from a function

00:12:44,800 --> 00:12:48,399
and the final thing we have to do is we

00:12:46,560 --> 00:12:51,760
have to set the discriminant

00:12:48,399 --> 00:12:54,800
so the part that says this enum

00:12:51,760 --> 00:12:56,720
is now an okay to zero because zero

00:12:54,800 --> 00:12:57,920
in this case means okay and one would

00:12:56,720 --> 00:12:59,360
mean error

00:12:57,920 --> 00:13:02,399
so we have to do all these operations

00:12:59,360 --> 00:13:04,079
where we take apart this complex enum

00:13:02,399 --> 00:13:06,480
pull out the fields then do some

00:13:04,079 --> 00:13:09,839
operation put it back into a field

00:13:06,480 --> 00:13:12,000
change some things and um

00:13:09,839 --> 00:13:13,279
lmm really really has a lot of trouble

00:13:12,000 --> 00:13:15,279
figuring this out like

00:13:13,279 --> 00:13:16,800
lvm just basically gives up it verb

00:13:15,279 --> 00:13:19,360
attempt translates this code

00:13:16,800 --> 00:13:20,560
one to one into assembly and if you look

00:13:19,360 --> 00:13:22,480
at the error path

00:13:20,560 --> 00:13:24,079
it's even worse we're not actually doing

00:13:22,480 --> 00:13:27,200
any operation we're taking

00:13:24,079 --> 00:13:29,120
the e out of the x

00:13:27,200 --> 00:13:31,360
and then putting it back into the return

00:13:29,120 --> 00:13:31,839
value so we basically didn't do anything

00:13:31,360 --> 00:13:33,600
we just

00:13:31,839 --> 00:13:35,519
copied something out copied it back in

00:13:33,600 --> 00:13:38,480
and it was all the same types

00:13:35,519 --> 00:13:41,440
so if we're looking at this error type

00:13:38,480 --> 00:13:44,320
error path what we actually want to do

00:13:41,440 --> 00:13:44,800
we simply want to return the original

00:13:44,320 --> 00:13:46,480
thing

00:13:44,800 --> 00:13:48,000
like we don't want to take it apart and

00:13:46,480 --> 00:13:50,880
build it back together we

00:13:48,000 --> 00:13:52,320
just want to return the thing and lvm

00:13:50,880 --> 00:13:53,040
just could not figure this out so we

00:13:52,320 --> 00:13:55,440
wrote a

00:13:53,040 --> 00:13:57,199
so called people optimization which is

00:13:55,440 --> 00:13:59,199
an optimization that is very very

00:13:57,199 --> 00:14:01,920
targeted to a specific

00:13:59,199 --> 00:14:02,880
um piece of code so we we're literally

00:14:01,920 --> 00:14:05,519
looking for the

00:14:02,880 --> 00:14:06,320
pattern that you're seeing here like it

00:14:05,519 --> 00:14:09,440
looks for

00:14:06,320 --> 00:14:12,160
take something out of an oven a number

00:14:09,440 --> 00:14:13,920
variant put it back into an enum variant

00:14:12,160 --> 00:14:15,920
and then set the discriminant to the

00:14:13,920 --> 00:14:17,040
same enum variant and if this exact

00:14:15,920 --> 00:14:18,800
pattern happens somewhere

00:14:17,040 --> 00:14:20,160
we just remove all the code and write an

00:14:18,800 --> 00:14:23,279
assignment

00:14:20,160 --> 00:14:23,760
and this optimization caused compile

00:14:23,279 --> 00:14:26,959
times

00:14:23,760 --> 00:14:30,160
to go down and cost

00:14:26,959 --> 00:14:31,760
runtime to speed up and there to be less

00:14:30,160 --> 00:14:33,839
instructions in the assembly

00:14:31,760 --> 00:14:36,320
so this is one of these operations where

00:14:33,839 --> 00:14:38,240
we are using idiomatic rust code with

00:14:36,320 --> 00:14:40,160
for example the question mark operator

00:14:38,240 --> 00:14:41,440
and um we're getting the same

00:14:40,160 --> 00:14:44,000
performance that you would get if you

00:14:41,440 --> 00:14:47,360
handcrafted your pointer arithmetic or

00:14:44,000 --> 00:14:50,720
whatever you're doing around your

00:14:47,360 --> 00:14:53,839
enum handling okay

00:14:50,720 --> 00:14:56,079
so this is how

00:14:53,839 --> 00:14:57,360
we are building optimizations right now

00:14:56,079 --> 00:14:58,480
but

00:14:57,360 --> 00:15:00,959
there's several things around

00:14:58,480 --> 00:15:02,480
optimizations that um i already talked

00:15:00,959 --> 00:15:05,519
about for example debugging

00:15:02,480 --> 00:15:08,000
suddenly becomes hard and um

00:15:05,519 --> 00:15:09,519
so let's dig into this question so what

00:15:08,000 --> 00:15:13,040
are common misconceptions about

00:15:09,519 --> 00:15:16,880
optimizations in general the first one

00:15:13,040 --> 00:15:19,680
optimizations make debugging harder well

00:15:16,880 --> 00:15:20,800
no optimizations just make debugging

00:15:19,680 --> 00:15:24,160
harder because

00:15:20,800 --> 00:15:27,199
lots of optimization developers

00:15:24,160 --> 00:15:30,880
didn't really put the effort in

00:15:27,199 --> 00:15:34,160
to get optimizations

00:15:30,880 --> 00:15:37,199
to the point where debugging just stays

00:15:34,160 --> 00:15:38,639
a decent experience when you're

00:15:37,199 --> 00:15:40,000
optimizing some code

00:15:38,639 --> 00:15:42,079
you know a lot about what you're

00:15:40,000 --> 00:15:43,040
changing you can change the back

00:15:42,079 --> 00:15:45,920
information

00:15:43,040 --> 00:15:46,320
to actually handle what's going on so

00:15:45,920 --> 00:15:50,320
let's

00:15:46,320 --> 00:15:51,680
look at an example if you have this

00:15:50,320 --> 00:15:52,720
instruction somewhere in your program

00:15:51,680 --> 00:15:54,000
code and you have nothing else you're

00:15:52,720 --> 00:15:56,800
not even using x or anything

00:15:54,000 --> 00:15:58,240
you literally have just let x equals 42.

00:15:56,800 --> 00:16:00,480
and then you're debugging your program

00:15:58,240 --> 00:16:02,720
the debugger will at best tell you

00:16:00,480 --> 00:16:04,959
x is a local variable that's optimized

00:16:02,720 --> 00:16:08,639
out and that's it like

00:16:04,959 --> 00:16:11,680
it won't tell you anything about x um

00:16:08,639 --> 00:16:12,800
but it's actually very easy to change

00:16:11,680 --> 00:16:15,440
your system

00:16:12,800 --> 00:16:16,320
to figure out that the value is 42

00:16:15,440 --> 00:16:18,880
because you knew

00:16:16,320 --> 00:16:20,639
at compile time the value is 42 so you

00:16:18,880 --> 00:16:24,160
can change your debug information

00:16:20,639 --> 00:16:25,920
to just contain this 42

00:16:24,160 --> 00:16:27,600
and instead of pointing to some memory

00:16:25,920 --> 00:16:28,880
location that doesn't exist anymore

00:16:27,600 --> 00:16:30,880
you're just pointing to

00:16:28,880 --> 00:16:33,519
a debugging for the back info

00:16:30,880 --> 00:16:36,160
information and reading that value

00:16:33,519 --> 00:16:39,040
so that's the easy part like doing

00:16:36,160 --> 00:16:42,320
storing some constants and um

00:16:39,040 --> 00:16:44,639
well reading them again doing debugging

00:16:42,320 --> 00:16:46,160
but this kind of debugging information

00:16:44,639 --> 00:16:48,240
can do a lot more

00:16:46,160 --> 00:16:49,920
you can literally do any kind of

00:16:48,240 --> 00:16:51,199
computation that you can do in the

00:16:49,920 --> 00:16:54,320
debugging console

00:16:51,199 --> 00:16:55,360
and just repeat it during the reading of

00:16:54,320 --> 00:16:56,800
such a variable

00:16:55,360 --> 00:16:58,639
so look at this example there's a little

00:16:56,800 --> 00:17:00,720
bit more complex you have

00:16:58,639 --> 00:17:02,399
next variable that's of type substruct

00:17:00,720 --> 00:17:05,600
and has a bunch of fields so a b

00:17:02,399 --> 00:17:08,880
c d and you're reading variable y

00:17:05,600 --> 00:17:11,600
from x dot a and at some point

00:17:08,880 --> 00:17:13,520
y gets optimized out but you keep the

00:17:11,600 --> 00:17:16,559
debugging information that the y

00:17:13,520 --> 00:17:18,640
value comes from x sort a

00:17:16,559 --> 00:17:19,600
and then debugger at runtime while

00:17:18,640 --> 00:17:21,520
you're debugging

00:17:19,600 --> 00:17:22,880
will read from the x variable which

00:17:21,520 --> 00:17:25,039
didn't get optimised out

00:17:22,880 --> 00:17:26,319
and will read the a field from this x

00:17:25,039 --> 00:17:28,400
variable

00:17:26,319 --> 00:17:29,919
and you can even add computations in

00:17:28,400 --> 00:17:32,640
there so if you wrote like

00:17:29,919 --> 00:17:34,640
let y equals 2 times x dot a you could

00:17:32,640 --> 00:17:37,679
store in debug information

00:17:34,640 --> 00:17:40,240
that y's value

00:17:37,679 --> 00:17:42,240
is literally 2 times x dot a and then

00:17:40,240 --> 00:17:46,640
the debugger could compute this

00:17:42,240 --> 00:17:50,160
while you're debugging so um

00:17:46,640 --> 00:17:52,400
this is one thing that um the rest

00:17:50,160 --> 00:17:53,919
compiler does in the background when

00:17:52,400 --> 00:17:56,559
it's doing optimizations

00:17:53,919 --> 00:17:57,360
and um you can turn it off if you want

00:17:56,559 --> 00:17:59,760
to you can

00:17:57,360 --> 00:18:00,640
nuke all the back information and just

00:17:59,760 --> 00:18:04,400
go ahead like

00:18:00,640 --> 00:18:06,160
optimize everything but

00:18:04,400 --> 00:18:07,600
if you're not changing anything by the

00:18:06,160 --> 00:18:09,440
default settings this is what you're

00:18:07,600 --> 00:18:12,880
getting now

00:18:09,440 --> 00:18:15,600
the other thing is optimizations

00:18:12,880 --> 00:18:16,720
use uv to just like mess up your program

00:18:15,600 --> 00:18:19,679
format your

00:18:16,720 --> 00:18:20,480
hard drive and i don't know nasal demons

00:18:19,679 --> 00:18:24,400
and

00:18:20,480 --> 00:18:26,480
um well yeah okay they do sorry

00:18:24,400 --> 00:18:27,840
there's no way around that because

00:18:26,480 --> 00:18:28,880
that's actually what we want from

00:18:27,840 --> 00:18:30,880
optimizations

00:18:28,880 --> 00:18:32,000
optimizations are supposed to take

00:18:30,880 --> 00:18:34,559
assumptions

00:18:32,000 --> 00:18:36,640
that are guaranteed and use them to make

00:18:34,559 --> 00:18:40,160
your code fast

00:18:36,640 --> 00:18:40,799
but what if optimizations emitted

00:18:40,160 --> 00:18:42,320
warnings

00:18:40,799 --> 00:18:45,120
when it was doing something that it

00:18:42,320 --> 00:18:46,000
found fishy became less aggressive for

00:18:45,120 --> 00:18:49,200
example around

00:18:46,000 --> 00:18:50,640
certain unsafe code constructs and

00:18:49,200 --> 00:18:52,320
you could configure them from the

00:18:50,640 --> 00:18:56,000
surface language so you could say this

00:18:52,320 --> 00:18:58,080
function here should use

00:18:56,000 --> 00:19:00,000
should be used differently in in certain

00:18:58,080 --> 00:19:02,160
optimizations

00:19:00,000 --> 00:19:03,600
you can give meta information to

00:19:02,160 --> 00:19:05,760
optimization passes

00:19:03,600 --> 00:19:07,840
so they handle your code specifically in

00:19:05,760 --> 00:19:09,200
different ways

00:19:07,840 --> 00:19:11,760
one way that you might already know

00:19:09,200 --> 00:19:14,480
about is allow in

00:19:11,760 --> 00:19:16,000
inline always or inline never which is

00:19:14,480 --> 00:19:17,280
which are attributes that you can add to

00:19:16,000 --> 00:19:18,240
functions to change the inlining

00:19:17,280 --> 00:19:21,600
behavior

00:19:18,240 --> 00:19:22,799
but there are avenues for adding more of

00:19:21,600 --> 00:19:25,360
these annotations

00:19:22,799 --> 00:19:27,200
so you can fine-tune your functions

00:19:25,360 --> 00:19:29,440
without

00:19:27,200 --> 00:19:31,120
changing your source code so you keep

00:19:29,440 --> 00:19:33,120
writing idiomatic rust

00:19:31,120 --> 00:19:34,480
but you're changing the way it gets

00:19:33,120 --> 00:19:38,720
optimized to

00:19:34,480 --> 00:19:41,919
fit your use case and um

00:19:38,720 --> 00:19:43,360
the the one thing that maybe got um

00:19:41,919 --> 00:19:45,039
a little bit under the wheels here is

00:19:43,360 --> 00:19:47,679
the emit warnings part

00:19:45,039 --> 00:19:49,600
um if you're emitting warnings when

00:19:47,679 --> 00:19:51,039
during optimizations when when something

00:19:49,600 --> 00:19:53,440
weird is happening

00:19:51,039 --> 00:19:55,600
you can turn them off after having

00:19:53,440 --> 00:19:57,039
reviewed the situation and saying

00:19:55,600 --> 00:19:58,640
okay i've actually looked at assembly

00:19:57,039 --> 00:20:00,640
the assembly is totally fine

00:19:58,640 --> 00:20:03,039
and i'm fine with this optimization

00:20:00,640 --> 00:20:05,679
doing something fishy here

00:20:03,039 --> 00:20:07,360
but you get notified about each site

00:20:05,679 --> 00:20:10,240
where something weird is happening

00:20:07,360 --> 00:20:12,320
so if you're reading your your source

00:20:10,240 --> 00:20:15,280
code for

00:20:12,320 --> 00:20:16,960
any kind of security or safety issues

00:20:15,280 --> 00:20:18,080
this would be a really powerful tool

00:20:16,960 --> 00:20:20,080
that you can use

00:20:18,080 --> 00:20:22,320
and there's some preliminary work that

00:20:20,080 --> 00:20:24,960
uh in the rust compiler where you can

00:20:22,320 --> 00:20:26,559
already do this on some const evaluation

00:20:24,960 --> 00:20:28,960
things where you get warnings

00:20:26,559 --> 00:20:29,600
if your code for example would panic at

00:20:28,960 --> 00:20:32,320
runtime

00:20:29,600 --> 00:20:35,840
or if your code would guaranteed cause

00:20:32,320 --> 00:20:35,840
undefined behavior at runtime

00:20:36,300 --> 00:20:41,360
[Music]

00:20:37,919 --> 00:20:45,280
so summarizing optimizations

00:20:41,360 --> 00:20:47,760
are totally awesome because they make

00:20:45,280 --> 00:20:48,400
not only your code faster they actually

00:20:47,760 --> 00:20:51,440
make your

00:20:48,400 --> 00:20:52,640
compilation times faster and

00:20:51,440 --> 00:20:55,440
they're super fun because they're

00:20:52,640 --> 00:20:58,000
basically puzzle games so for me

00:20:55,440 --> 00:20:59,600
when i'm writing optimizations i'm

00:20:58,000 --> 00:21:02,960
basically a programmer that programs

00:20:59,600 --> 00:21:06,080
programs for other programmers and

00:21:02,960 --> 00:21:06,320
this is like you you move pieces around

00:21:06,080 --> 00:21:09,120
and

00:21:06,320 --> 00:21:09,600
trying to to like put them together in a

00:21:09,120 --> 00:21:12,080
way that

00:21:09,600 --> 00:21:13,440
they become faster and yeah this is a

00:21:12,080 --> 00:21:15,679
really fun experience

00:21:13,440 --> 00:21:17,360
and it's also super accessible because

00:21:15,679 --> 00:21:19,440
it's very close to high

00:21:17,360 --> 00:21:20,559
to surface language rest so you

00:21:19,440 --> 00:21:23,679
basically have

00:21:20,559 --> 00:21:26,400
your um your

00:21:23,679 --> 00:21:27,200
you your cut down language that you can

00:21:26,400 --> 00:21:29,840
work on

00:21:27,200 --> 00:21:31,200
and you you look at how it is before how

00:21:29,840 --> 00:21:33,919
it is afterwards

00:21:31,200 --> 00:21:35,280
and you adjust your optimization until

00:21:33,919 --> 00:21:37,200
it does exactly what you want

00:21:35,280 --> 00:21:39,200
then you run it on this really big test

00:21:37,200 --> 00:21:40,799
suite that we have in the rest compiler

00:21:39,200 --> 00:21:42,640
and check if it doesn't mess up anything

00:21:40,799 --> 00:21:44,720
else and

00:21:42,640 --> 00:21:48,240
it's a really good way to get into

00:21:44,720 --> 00:21:51,760
working on the on the rest compiler

00:21:48,240 --> 00:21:54,000
um so

00:21:51,760 --> 00:21:54,880
um there's a bunch of things that are

00:21:54,000 --> 00:21:57,679
really

00:21:54,880 --> 00:21:58,240
high impact that we'll have coming in in

00:21:57,679 --> 00:22:01,030
the

00:21:58,240 --> 00:22:02,559
near or sometimes very far future

00:22:01,030 --> 00:22:05,919
[Music]

00:22:02,559 --> 00:22:09,039
for optimizations um so one thing

00:22:05,919 --> 00:22:10,720
that is

00:22:09,039 --> 00:22:13,520
known from a bunch of other languages is

00:22:10,720 --> 00:22:16,720
called partial special specialization

00:22:13,520 --> 00:22:18,720
when you replace one function argument

00:22:16,720 --> 00:22:20,559
with a constant because for example all

00:22:18,720 --> 00:22:22,640
call sides to a function

00:22:20,559 --> 00:22:24,720
are using a constant for the function

00:22:22,640 --> 00:22:26,880
argument you can

00:22:24,720 --> 00:22:28,880
just replace all the uses of this

00:22:26,880 --> 00:22:31,280
argument inside the function

00:22:28,880 --> 00:22:32,080
with this constant and then optimize the

00:22:31,280 --> 00:22:34,960
function

00:22:32,080 --> 00:22:36,400
so um you're basically creating special

00:22:34,960 --> 00:22:39,120
instances of a function

00:22:36,400 --> 00:22:40,480
for your use sites while this increases

00:22:39,120 --> 00:22:43,039
your binary size

00:22:40,480 --> 00:22:43,840
um if all the users have used the same

00:22:43,039 --> 00:22:47,039
constant

00:22:43,840 --> 00:22:48,480
um there's no loss here and um

00:22:47,039 --> 00:22:50,400
depending on the complexity of the

00:22:48,480 --> 00:22:51,120
function um this might actually be a

00:22:50,400 --> 00:22:54,000
speed up

00:22:51,120 --> 00:22:56,000
both in in your runtime or it might

00:22:54,000 --> 00:22:58,559
actually shrink your your memory usage

00:22:56,000 --> 00:23:01,280
because um a lot of code inside the

00:22:58,559 --> 00:23:02,799
function can get optimized out

00:23:01,280 --> 00:23:04,720
um the other thing that we are working

00:23:02,799 --> 00:23:05,760
on actively right now is called mirror

00:23:04,720 --> 00:23:08,960
inlining

00:23:05,760 --> 00:23:10,159
so we are trying to create an inliner

00:23:08,960 --> 00:23:13,120
that

00:23:10,159 --> 00:23:13,600
does not have the downsides that lots of

00:23:13,120 --> 00:23:16,320
um

00:23:13,600 --> 00:23:17,520
heuristic inliners have so basically you

00:23:16,320 --> 00:23:20,240
get a deterministic

00:23:17,520 --> 00:23:21,039
inliner that looks at the function body

00:23:20,240 --> 00:23:23,679
and

00:23:21,039 --> 00:23:24,960
knows either inlining this function will

00:23:23,679 --> 00:23:26,880
be an improvement

00:23:24,960 --> 00:23:28,960
or it won't it's not that it makes a

00:23:26,880 --> 00:23:30,000
heuristic like statistically this should

00:23:28,960 --> 00:23:31,919
be an improvement

00:23:30,000 --> 00:23:33,200
but it tells you like this is guaranteed

00:23:31,919 --> 00:23:34,799
to be an improvement and that's why

00:23:33,200 --> 00:23:36,640
we're in lining

00:23:34,799 --> 00:23:38,559
um of course you can still find unit

00:23:36,640 --> 00:23:39,520
manually by using inline always or

00:23:38,559 --> 00:23:43,360
inline never

00:23:39,520 --> 00:23:45,279
but the default will become a guaranteed

00:23:43,360 --> 00:23:47,360
optimization

00:23:45,279 --> 00:23:48,640
there's uh also some work going on on

00:23:47,360 --> 00:23:51,279
polymorphization

00:23:48,640 --> 00:23:52,640
uh this is a long confusing word that

00:23:51,279 --> 00:23:56,000
i'm slowly getting into my

00:23:52,640 --> 00:23:57,360
um into my dictionary but it basically

00:23:56,000 --> 00:24:00,080
means that

00:23:57,360 --> 00:24:01,600
you have a function that is generic but

00:24:00,080 --> 00:24:04,640
instead of

00:24:01,600 --> 00:24:07,120
combining the function down to

00:24:04,640 --> 00:24:08,400
assembly for each generic parameter

00:24:07,120 --> 00:24:10,880
that's being used in

00:24:08,400 --> 00:24:12,960
you look at the function and realize oh

00:24:10,880 --> 00:24:14,720
this function just

00:24:12,960 --> 00:24:17,279
doesn't really care about the generic

00:24:14,720 --> 00:24:20,480
parameter for example if you have

00:24:17,279 --> 00:24:22,000
len so the lens function on vectors

00:24:20,480 --> 00:24:23,919
it doesn't really care what the generic

00:24:22,000 --> 00:24:26,240
parameter is it literally just

00:24:23,919 --> 00:24:27,360
reads a field out of the vector struct

00:24:26,240 --> 00:24:30,240
so there's no reason

00:24:27,360 --> 00:24:31,679
ever to instantiate multiple versions of

00:24:30,240 --> 00:24:34,000
the function back len

00:24:31,679 --> 00:24:35,039
but right now that's what russ compiler

00:24:34,000 --> 00:24:36,960
does it looks

00:24:35,039 --> 00:24:38,799
at the function and if you have a back

00:24:36,960 --> 00:24:39,679
i-32 it will create a length function

00:24:38,799 --> 00:24:41,840
for that if you have

00:24:39,679 --> 00:24:42,960
string we'll create another length

00:24:41,840 --> 00:24:44,720
function for that

00:24:42,960 --> 00:24:47,840
so polymorphisation would prevent this

00:24:44,720 --> 00:24:47,840
kind of duplication

00:24:47,919 --> 00:24:55,840
then we have value range analysis

00:24:51,279 --> 00:24:55,840
this is a really neat feature where you

00:24:56,640 --> 00:25:00,720
look at the values how they are used so

00:24:59,120 --> 00:25:03,679
if you for example

00:25:00,720 --> 00:25:06,640
somewhere a condition if the slice

00:25:03,679 --> 00:25:09,440
length is less than 10

00:25:06,640 --> 00:25:10,880
then from then on any index that is

00:25:09,440 --> 00:25:13,039
smaller than 10

00:25:10,880 --> 00:25:14,400
is known not to ever panic because of

00:25:13,039 --> 00:25:17,039
out of bounds because you just

00:25:14,400 --> 00:25:17,760
checked if the slice length is less than

00:25:17,039 --> 00:25:22,240
10.

00:25:17,760 --> 00:25:25,200
so from then on you can optimize out all

00:25:22,240 --> 00:25:29,840
index operation out of bounds checks if

00:25:25,200 --> 00:25:29,840
the index is known to be less than 10.

00:25:30,400 --> 00:25:35,600
another optimization the nrvo named

00:25:33,679 --> 00:25:39,039
return value optimization

00:25:35,600 --> 00:25:41,200
it is a really cool thing for

00:25:39,039 --> 00:25:42,960
recursive functions or simply functions

00:25:41,200 --> 00:25:44,640
that return big objects

00:25:42,960 --> 00:25:46,080
so if a function that returns a large

00:25:44,640 --> 00:25:49,279
thing um

00:25:46,080 --> 00:25:51,679
what you might want to do is um

00:25:49,279 --> 00:25:53,039
sometimes is to put a function pointer

00:25:51,679 --> 00:25:55,120
into the

00:25:53,039 --> 00:25:56,080
function a pointer into the argument

00:25:55,120 --> 00:25:58,559
list of your function

00:25:56,080 --> 00:26:00,000
and right through that pointer but rust

00:25:58,559 --> 00:26:01,039
can do this magically in the background

00:26:00,000 --> 00:26:05,279
for you so you can

00:26:01,039 --> 00:26:07,679
automatically return the object by value

00:26:05,279 --> 00:26:09,360
from a function and rust will in the

00:26:07,679 --> 00:26:13,120
background turn everything around

00:26:09,360 --> 00:26:15,440
to optimize out any

00:26:13,120 --> 00:26:18,159
additional copies that you wouldn't

00:26:15,440 --> 00:26:18,159
normally need

00:26:18,240 --> 00:26:22,880
similar to that there's copy propagation

00:26:20,159 --> 00:26:25,360
it's basically the opposite of nrvo

00:26:22,880 --> 00:26:26,480
instead of looking um where you can

00:26:25,360 --> 00:26:28,720
return things

00:26:26,480 --> 00:26:30,159
or like like looking from from the end

00:26:28,720 --> 00:26:32,000
where things are written to

00:26:30,159 --> 00:26:34,480
you're looking from the beginning like

00:26:32,000 --> 00:26:38,080
this variable is only ever used once

00:26:34,480 --> 00:26:40,480
so maybe all users of it should just get

00:26:38,080 --> 00:26:42,640
the value the variable directly so if

00:26:40,480 --> 00:26:46,080
you have like x equals five somewhere

00:26:42,640 --> 00:26:48,480
and the the uses of x can simply be

00:26:46,080 --> 00:26:50,640
replaced by the number five so you can

00:26:48,480 --> 00:26:54,159
optimize this kind of um

00:26:50,640 --> 00:26:55,440
this assignment uh another fun one is d

00:26:54,159 --> 00:26:57,039
virtualization

00:26:55,440 --> 00:26:59,360
so if the rest compiler can figure out

00:26:57,039 --> 00:27:00,320
that your trade object is actually known

00:26:59,360 --> 00:27:02,480
at compile time

00:27:00,320 --> 00:27:04,240
it can just remove the trade object and

00:27:02,480 --> 00:27:07,200
remove any virtual function calls and

00:27:04,240 --> 00:27:11,039
just call the functions directly

00:27:07,200 --> 00:27:13,600
this is a really common around

00:27:11,039 --> 00:27:14,400
a bunch of generic functions related to

00:27:13,600 --> 00:27:17,039
closures

00:27:14,400 --> 00:27:20,159
so we could really really speed up some

00:27:17,039 --> 00:27:22,320
some kind of closure usage here

00:27:20,159 --> 00:27:23,279
and of course as already mentioned

00:27:22,320 --> 00:27:27,120
earlier

00:27:23,279 --> 00:27:28,480
i really want to harden programs against

00:27:27,120 --> 00:27:31,760
undefined behavior

00:27:28,480 --> 00:27:34,880
by making optimizations lint

00:27:31,760 --> 00:27:36,720
when there is fishy behavior going on

00:27:34,880 --> 00:27:38,240
and while this will give you false

00:27:36,720 --> 00:27:42,000
positives we won't turn these

00:27:38,240 --> 00:27:44,559
limbs on by default but

00:27:42,000 --> 00:27:45,440
basically if you are really in a

00:27:44,559 --> 00:27:47,760
critical

00:27:45,440 --> 00:27:49,279
environment you rather take a false

00:27:47,760 --> 00:27:51,440
positive of a limb

00:27:49,279 --> 00:27:53,760
and turn it off and say i checked this

00:27:51,440 --> 00:27:56,880
lint is triggering falsely

00:27:53,760 --> 00:27:59,039
then have it not trigger on a situation

00:27:56,880 --> 00:27:59,919
where um well you're doing undefined

00:27:59,039 --> 00:28:02,159
behavior and

00:27:59,919 --> 00:28:03,520
i don't know throwing away some secret

00:28:02,159 --> 00:28:06,559
data or well

00:28:03,520 --> 00:28:10,640
worth like shouting it out to the world

00:28:06,559 --> 00:28:13,200
um yep so

00:28:10,640 --> 00:28:14,720
this is it for me um i'm going to be

00:28:13,200 --> 00:28:17,200
working on the impulse on me

00:28:14,720 --> 00:28:20,880
optimizations and consewas so

00:28:17,200 --> 00:28:24,960
talk to me in the next two days if you

00:28:20,880 --> 00:28:24,960
want to know more about these topics

00:28:28,840 --> 00:28:31,840
thanks

00:28:35,919 --> 00:28:38,000

YouTube URL: https://www.youtube.com/watch?v=Tr9CiKg-z4c


