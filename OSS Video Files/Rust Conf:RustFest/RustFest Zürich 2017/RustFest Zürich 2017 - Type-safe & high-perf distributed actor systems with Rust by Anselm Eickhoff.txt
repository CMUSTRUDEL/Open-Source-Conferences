Title: RustFest Zürich 2017 - Type-safe & high-perf distributed actor systems with Rust by Anselm Eickhoff
Publication date: 2017-10-21
Playlist: RustFest Zürich 2017
Description: 
	Introducing a working prototype for a minimal actor-oriented system runtime to handle millions of actors and passed messages, across processor cores and even machines. It is written in and used from Rust. Using an additional code-generating build script, type-safe remote message sending and handling is magically desugared from plain Rust function calls and definitions, including dynamic dispatch with traits. This makes it possible to write complex, extensible distributed systems in idiomatic Rust.

About Anselm Eickhoff:
Self-taught hacker and CS student from Germany. Got the crazy idea to build Citybound - a new, large-scale city simulation game and engine, on my own. I’m busy plowing through all the custom technology that needs to be invented and implemented for that, all of which I write in Rust.
Captions: 
	00:00:11,940 --> 00:00:17,220
all right hi everyone conference table

00:00:15,089 --> 00:00:20,759
conference driven development is great

00:00:17,220 --> 00:00:22,169
because you can say that you will hold a

00:00:20,759 --> 00:00:23,610
presentation about something that you

00:00:22,169 --> 00:00:25,050
would like to exist and then if they

00:00:23,610 --> 00:00:28,860
take you you're kind of forced to

00:00:25,050 --> 00:00:30,899
implement that so this is what happened

00:00:28,860 --> 00:00:32,850
for me and I will talk to you today

00:00:30,899 --> 00:00:35,570
about typesafe high-performance

00:00:32,850 --> 00:00:38,820
distributed active systems and rust I

00:00:35,570 --> 00:00:40,590
would introduce myself as a hacker who

00:00:38,820 --> 00:00:42,660
loves systems that are complex and

00:00:40,590 --> 00:00:44,820
interesting ways and I think that this

00:00:42,660 --> 00:00:47,219
has in large parts to do with what I

00:00:44,820 --> 00:00:49,829
grew up with which were games like a

00:00:47,219 --> 00:00:51,749
train or SimCity 2000 we're at a very

00:00:49,829 --> 00:00:54,329
young age I was interacting with these

00:00:51,749 --> 00:00:56,370
really complicated systems and through

00:00:54,329 --> 00:01:00,059
play getting an intuitive feeling for

00:00:56,370 --> 00:01:02,159
something like that and what I think

00:01:00,059 --> 00:01:04,290
needs to happen in general is that we

00:01:02,159 --> 00:01:06,330
should bring this intuitive systems

00:01:04,290 --> 00:01:07,920
level thinking to the next generation

00:01:06,330 --> 00:01:10,860
and I think the best way to do that is

00:01:07,920 --> 00:01:13,560
through Play as well my brand for doing

00:01:10,860 --> 00:01:15,950
that is a play and let me tell you about

00:01:13,560 --> 00:01:18,750
my first step along this mission

00:01:15,950 --> 00:01:20,550
thinking back to these city building

00:01:18,750 --> 00:01:22,860
games of my childhood I realized that a

00:01:20,550 --> 00:01:24,630
lot of my interests intersect there and

00:01:22,860 --> 00:01:27,330
it was really the logical thing for me

00:01:24,630 --> 00:01:30,420
to do to create a city building sandbox

00:01:27,330 --> 00:01:32,460
where large-scale cities with citizen

00:01:30,420 --> 00:01:35,280
level detail become understandable and

00:01:32,460 --> 00:01:37,290
design able and the new thing which I

00:01:35,280 --> 00:01:41,250
wanted to add is in a collaborative

00:01:37,290 --> 00:01:42,540
planning fashion and this is my project

00:01:41,250 --> 00:01:45,780
which I've been working on for a couple

00:01:42,540 --> 00:01:47,460
years now called City bound let me give

00:01:45,780 --> 00:01:48,930
you a short history and I will go

00:01:47,460 --> 00:01:50,730
through this really quickly but just to

00:01:48,930 --> 00:01:54,510
give you the general background it all

00:01:50,730 --> 00:01:58,020
started in 2013 when EA and Mac's us

00:01:54,510 --> 00:02:00,240
together announced a new instance in the

00:01:58,020 --> 00:02:02,970
genre-defining series of SimCity SimCity

00:02:00,240 --> 00:02:05,760
2013 and what I promised was this like

00:02:02,970 --> 00:02:07,500
beautiful detailed cities where you

00:02:05,760 --> 00:02:08,849
could see every individual car and they

00:02:07,500 --> 00:02:11,670
said they would simulate every

00:02:08,849 --> 00:02:13,800
individual citizen with their lives and

00:02:11,670 --> 00:02:16,050
you could watch that and interact with

00:02:13,800 --> 00:02:17,750
that when they released it it looked

00:02:16,050 --> 00:02:21,090
more like this where you have this like

00:02:17,750 --> 00:02:23,310
city with skyscrapers but restricted to

00:02:21,090 --> 00:02:25,230
like two by two kilometer box which is

00:02:23,310 --> 00:02:26,490
more like the size of a village and then

00:02:25,230 --> 00:02:28,350
when you play it for some

00:02:26,490 --> 00:02:30,060
you realize that yeah there are

00:02:28,350 --> 00:02:31,950
individual cars but it's really weird

00:02:30,060 --> 00:02:33,690
because the people in the morning just

00:02:31,950 --> 00:02:35,730
go to a random workplace and in the

00:02:33,690 --> 00:02:39,330
evening return to a different home and

00:02:35,730 --> 00:02:43,440
where they came from which is kinda not

00:02:39,330 --> 00:02:45,810
how it works in real life but but still

00:02:43,440 --> 00:02:48,180
this this promise and this vision of

00:02:45,810 --> 00:02:50,400
actually simulating a huge city at the

00:02:48,180 --> 00:02:52,290
individual person level was so

00:02:50,400 --> 00:02:54,330
fascinating for me that I really really

00:02:52,290 --> 00:02:56,550
wanted to try for myself and this is

00:02:54,330 --> 00:02:59,280
what started city bond I started first

00:02:56,550 --> 00:03:00,480
by building some traffic simulation

00:02:59,280 --> 00:03:03,450
prototypes

00:03:00,480 --> 00:03:04,920
I used JavaScript and WebGL simply

00:03:03,450 --> 00:03:06,360
because there was what I was most

00:03:04,920 --> 00:03:08,760
familiar with and which allowed me to

00:03:06,360 --> 00:03:11,550
iterate the quickest and once I had that

00:03:08,760 --> 00:03:13,440
ready I just announced that in a blog

00:03:11,550 --> 00:03:15,210
post together with my like general plans

00:03:13,440 --> 00:03:17,610
of all I want to do a city bullying game

00:03:15,210 --> 00:03:20,340
and assume cities separated and I had

00:03:17,610 --> 00:03:22,200
what I call the let me see if I can

00:03:20,340 --> 00:03:24,060
figure this out yeah the announcement

00:03:22,200 --> 00:03:25,680
weekend because they literally spend a

00:03:24,060 --> 00:03:27,150
whole weekend just answering comments

00:03:25,680 --> 00:03:29,310
and questions by other people who were

00:03:27,150 --> 00:03:32,160
also frustrated by SimCity and who

00:03:29,310 --> 00:03:34,620
really believed in my vision I then

00:03:32,160 --> 00:03:37,110
quickly continued iterating implementing

00:03:34,620 --> 00:03:39,990
several very important basic game

00:03:37,110 --> 00:03:41,520
features and I started to interact more

00:03:39,990 --> 00:03:44,250
and more closely with my newfound

00:03:41,520 --> 00:03:46,820
community through blog post update

00:03:44,250 --> 00:03:48,990
videos and even programming live streams

00:03:46,820 --> 00:03:51,420
there was I would say one defining

00:03:48,990 --> 00:03:52,770
moment where I invented and implemented

00:03:51,420 --> 00:03:54,750
a first prototype of what I call

00:03:52,770 --> 00:03:57,480
planning mode which really sets it apart

00:03:54,750 --> 00:03:59,850
from other city building games where you

00:03:57,480 --> 00:04:01,650
don't directly manipulate the city you

00:03:59,850 --> 00:04:05,910
just don't build roads over buildings

00:04:01,650 --> 00:04:07,350
but you create first a draft a plan of

00:04:05,910 --> 00:04:09,780
what you want to create much like in

00:04:07,350 --> 00:04:11,910
real life that represents the kind of

00:04:09,780 --> 00:04:13,380
change set I think this should be

00:04:11,910 --> 00:04:15,570
intuitive to as programmers that you

00:04:13,380 --> 00:04:17,549
want to apply to your city and that this

00:04:15,570 --> 00:04:21,210
would be the main way of interacting and

00:04:17,549 --> 00:04:23,370
playing city bound but soon after that I

00:04:21,210 --> 00:04:25,910
got into a phase where I noticed myself

00:04:23,370 --> 00:04:29,010
focusing more and more on like hardcore

00:04:25,910 --> 00:04:33,650
optimization problems and low level

00:04:29,010 --> 00:04:33,650
architecture questions in JavaScript

00:04:33,870 --> 00:04:37,800
and it was quite clear that that

00:04:36,270 --> 00:04:40,080
wouldn't cut it so I did the obvious

00:04:37,800 --> 00:04:44,790
thing and decided to implement

00:04:40,080 --> 00:04:46,350
everything in C++ it took me quite some

00:04:44,790 --> 00:04:48,330
time just to get the graphics and

00:04:46,350 --> 00:04:50,490
fundamentals going again I did some

00:04:48,330 --> 00:04:52,949
preparation for geometry procedural

00:04:50,490 --> 00:04:54,930
buildings then decided to focus on these

00:04:52,949 --> 00:04:57,660
difficult topics like memory layout

00:04:54,930 --> 00:05:00,360
persistence optimization and realized

00:04:57,660 --> 00:05:02,520
that if I would continue with C++ I

00:05:00,360 --> 00:05:04,290
would probably be able to finish within

00:05:02,520 --> 00:05:09,600
my lifetime but I would also go insane

00:05:04,290 --> 00:05:11,430
so luckily at this point in time I heard

00:05:09,600 --> 00:05:14,330
about rust and it seemed stable enough

00:05:11,430 --> 00:05:17,580
to give it a try so I gave it a try and

00:05:14,330 --> 00:05:20,280
got really blazingly quickly through the

00:05:17,580 --> 00:05:22,950
graphics and fundamentals part thanks to

00:05:20,280 --> 00:05:24,450
projects like gleam for example which

00:05:22,950 --> 00:05:25,919
allowed me to immediately focus on the

00:05:24,450 --> 00:05:27,690
difficult topics like memory layout

00:05:25,919 --> 00:05:29,700
found out that of course they are

00:05:27,690 --> 00:05:32,280
inherently difficult but rust allowed me

00:05:29,700 --> 00:05:34,889
to do both really difficult low-level

00:05:32,280 --> 00:05:37,080
stuff but then abstracted nicely so I

00:05:34,889 --> 00:05:39,300
could move on quickly to re-implement my

00:05:37,080 --> 00:05:41,280
traffic simulation and I decided at this

00:05:39,300 --> 00:05:43,800
point I wanted to have again I kind of

00:05:41,280 --> 00:05:45,360
released to my community and I decided

00:05:43,800 --> 00:05:46,950
to radically change how I think about

00:05:45,360 --> 00:05:49,380
the project and decided to make it open

00:05:46,950 --> 00:05:50,700
source and to make the first prototype

00:05:49,380 --> 00:05:52,979
even though it was just traffic

00:05:50,700 --> 00:05:55,470
simulation available to all of my fans

00:05:52,979 --> 00:05:58,050
and I also launched a page on patreon

00:05:55,470 --> 00:05:59,780
since then I have been again reiterating

00:05:58,050 --> 00:06:02,520
from the beginning all the different

00:05:59,780 --> 00:06:05,550
game features that I needed and we will

00:06:02,520 --> 00:06:07,560
take a look at that later I want to talk

00:06:05,550 --> 00:06:09,690
in this presentation about what I feel

00:06:07,560 --> 00:06:14,190
is the one underlying architectural

00:06:09,690 --> 00:06:16,260
enabler which is actor systems which I

00:06:14,190 --> 00:06:20,039
would call an effective abstraction and

00:06:16,260 --> 00:06:23,310
for me effective abstractions are like

00:06:20,039 --> 00:06:25,530
arcs they need very little material but

00:06:23,310 --> 00:06:28,139
they allow you to robustly establish a

00:06:25,530 --> 00:06:30,300
higher ground which is so robust that

00:06:28,139 --> 00:06:32,580
you can just stand on top and trust them

00:06:30,300 --> 00:06:35,190
and even completely forget how

00:06:32,580 --> 00:06:36,660
everything below works they're so

00:06:35,190 --> 00:06:38,520
flexible that if you're building like a

00:06:36,660 --> 00:06:41,669
bridge out of rx you don't even feel the

00:06:38,520 --> 00:06:43,469
changes of landscape below continuing

00:06:41,669 --> 00:06:45,150
with this metaphor and they're so

00:06:43,469 --> 00:06:47,540
elegant that they solve many problems at

00:06:45,150 --> 00:06:50,430
once if you use them

00:06:47,540 --> 00:06:53,280
to give you an idea of how I arrived at

00:06:50,430 --> 00:06:55,050
using actor systems let me give you my

00:06:53,280 --> 00:06:56,670
original motivating challenge which was

00:06:55,050 --> 00:07:00,900
of course to simulate a whole metropolis

00:06:56,670 --> 00:07:03,240
in real time on one computer this

00:07:00,900 --> 00:07:05,310
implies several challenges the first one

00:07:03,240 --> 00:07:07,080
is if you think about it it's common in

00:07:05,310 --> 00:07:09,180
game development that you have millions

00:07:07,080 --> 00:07:11,220
of particles for example the particles

00:07:09,180 --> 00:07:13,440
are pretty simple things like they're

00:07:11,220 --> 00:07:15,090
all the same in size they don't have

00:07:13,440 --> 00:07:18,300
references to other particles whereas

00:07:15,090 --> 00:07:21,090
for me I have citizens with a workplace

00:07:18,300 --> 00:07:24,090
and other family members and they might

00:07:21,090 --> 00:07:27,660
have different amounts and different

00:07:24,090 --> 00:07:29,460
kinds of resources each of them so and I

00:07:27,660 --> 00:07:33,240
needed to batch process millions of them

00:07:29,460 --> 00:07:35,370
several like 60 times per second at

00:07:33,240 --> 00:07:37,500
least so what I needed was to achieve

00:07:35,370 --> 00:07:39,590
cache locality for something like that

00:07:37,500 --> 00:07:42,180
even though they were dynamically sized

00:07:39,590 --> 00:07:43,860
second because I was pretty much aware

00:07:42,180 --> 00:07:46,050
that my game state would be several

00:07:43,860 --> 00:07:47,940
gigabytes in RAM I didn't want to

00:07:46,050 --> 00:07:49,350
serialize that on to disk to create a

00:07:47,940 --> 00:07:53,430
safe game like that would take forever

00:07:49,350 --> 00:07:57,570
so this was my second maybe requirement

00:07:53,430 --> 00:07:59,280
and I came up with a pretty well working

00:07:57,570 --> 00:08:01,710
solutions for both of these problems

00:07:59,280 --> 00:08:04,260
already back in C++ times where I

00:08:01,710 --> 00:08:07,350
decided to only use plain old data and

00:08:04,260 --> 00:08:09,900
what I call special recursively compact

00:08:07,350 --> 00:08:12,600
containers where you have for example a

00:08:09,900 --> 00:08:15,590
struct of vectors and maybe a dictionary

00:08:12,600 --> 00:08:17,940
in there but each of them are laid out

00:08:15,590 --> 00:08:20,790
consecutively in memory and if they grow

00:08:17,940 --> 00:08:22,860
the whole thing grows and the individual

00:08:20,790 --> 00:08:24,420
parts gets more space that's a whole

00:08:22,860 --> 00:08:26,970
topic in itself if you're interested in

00:08:24,420 --> 00:08:28,470
asking about it later but I think I kind

00:08:26,970 --> 00:08:31,110
of get the idea across the important

00:08:28,470 --> 00:08:34,950
thing is that now everything in my game

00:08:31,110 --> 00:08:36,990
stayed each entity has a continuous data

00:08:34,950 --> 00:08:42,030
format that is the same but in RAM and

00:08:36,990 --> 00:08:44,340
disk but there's a problem because these

00:08:42,030 --> 00:08:46,920
entities cross reference each other and

00:08:44,340 --> 00:08:49,590
like they can both be moved in memory

00:08:46,920 --> 00:08:51,360
and also persisted to disk and at this

00:08:49,590 --> 00:08:53,130
point if you just use pointers as

00:08:51,360 --> 00:08:55,920
references that stops working they

00:08:53,130 --> 00:08:57,990
stopped being valid so the solution for

00:08:55,920 --> 00:08:58,650
Redis again something pretty common in

00:08:57,990 --> 00:09:00,670
game development

00:08:58,650 --> 00:09:02,620
I used entity IDs as an indirection

00:09:00,670 --> 00:09:05,580
and slot maps that resolve the entity

00:09:02,620 --> 00:09:08,140
ladies into actual pointers at runtime

00:09:05,580 --> 00:09:09,730
the last challenge and the toughest one

00:09:08,140 --> 00:09:11,710
which I think we're all facing was

00:09:09,730 --> 00:09:13,510
parallelization it was clear that one

00:09:11,710 --> 00:09:15,580
core wouldn't be enough to simulate it

00:09:13,510 --> 00:09:17,380
maybe not even one computer if I'm

00:09:15,580 --> 00:09:21,280
thinking about really large cities or

00:09:17,380 --> 00:09:23,200
whole regions and what is the solution

00:09:21,280 --> 00:09:24,880
well this is something that we're all

00:09:23,200 --> 00:09:27,160
thinking about that is a problem to all

00:09:24,880 --> 00:09:29,200
of us the traditional approaches that

00:09:27,160 --> 00:09:31,240
you take many cores or many computers

00:09:29,200 --> 00:09:32,350
and pretend that they're 1 and for that

00:09:31,240 --> 00:09:35,460
you use shared memory and

00:09:32,350 --> 00:09:37,840
synchronization that is inherently

00:09:35,460 --> 00:09:40,720
unsafe and tricky rust helps a little

00:09:37,840 --> 00:09:42,190
bit with that but if you think about the

00:09:40,720 --> 00:09:43,930
scale that I'm dealing with where you

00:09:42,190 --> 00:09:45,910
have millions of tiny entities and you

00:09:43,930 --> 00:09:49,270
want to synchronize them in real time it

00:09:45,910 --> 00:09:51,070
just kind of stops being feasible but I

00:09:49,270 --> 00:09:53,200
heard about this other philosophy where

00:09:51,070 --> 00:09:55,600
you do the opposite and you say that

00:09:53,200 --> 00:09:58,180
what if one computer was real like many

00:09:55,600 --> 00:09:59,800
computers how do many computers

00:09:58,180 --> 00:10:01,600
communicate in the internet they pass

00:09:59,800 --> 00:10:03,010
messages with each other why don't we

00:10:01,600 --> 00:10:06,790
just take this pattern and scale it down

00:10:03,010 --> 00:10:10,000
and say that our basic abstraction is a

00:10:06,790 --> 00:10:11,890
computer which I've seen before only in

00:10:10,000 --> 00:10:13,300
Erlang but it works really well there

00:10:11,890 --> 00:10:15,760
and I really enjoyed writing systems

00:10:13,300 --> 00:10:17,710
that way and this basic abstraction is

00:10:15,760 --> 00:10:20,110
not called a tiny computer but it's

00:10:17,710 --> 00:10:22,900
actually an actor it's also known as an

00:10:20,110 --> 00:10:24,010
object in the original sense as Alan Kay

00:10:22,900 --> 00:10:26,290
defined it when he invented

00:10:24,010 --> 00:10:28,780
object-oriented programming and the idea

00:10:26,290 --> 00:10:31,180
is really simple it's just an object

00:10:28,780 --> 00:10:35,380
that has isolated state that only it

00:10:31,180 --> 00:10:38,590
itself can mutate and the only way it

00:10:35,380 --> 00:10:41,020
can influence other hector's objects is

00:10:38,590 --> 00:10:43,810
to message passing by sending the

00:10:41,020 --> 00:10:45,280
messages so to represent this cycle

00:10:43,810 --> 00:10:47,590
let's just take one actor here which has

00:10:45,280 --> 00:10:50,020
some actor state and it receives a

00:10:47,590 --> 00:10:52,480
message from another actor it has a

00:10:50,020 --> 00:10:55,350
message handler that is associated with

00:10:52,480 --> 00:10:58,120
this particular type of message and

00:10:55,350 --> 00:10:59,710
while handling the message we can mutate

00:10:58,120 --> 00:11:02,230
the actor state to produce a new actor

00:10:59,710 --> 00:11:05,170
state and we can send arbitrary messages

00:11:02,230 --> 00:11:07,960
to other actors and all of this you

00:11:05,170 --> 00:11:11,010
built everything in an actor system

00:11:07,960 --> 00:11:11,010
based architecture

00:11:11,910 --> 00:11:16,180
there were even I think actor systems

00:11:14,500 --> 00:11:18,310
for us when I started this there were

00:11:16,180 --> 00:11:19,839
definitely a lot of solutions for actor

00:11:18,310 --> 00:11:22,140
systems out there but I needed something

00:11:19,839 --> 00:11:25,029
much more lightweight than most of them

00:11:22,140 --> 00:11:26,649
because they had lots of fancy features

00:11:25,029 --> 00:11:28,149
they operated on a really high level

00:11:26,649 --> 00:11:30,070
which is cool if you're writing high

00:11:28,149 --> 00:11:31,750
level applications like Web Services or

00:11:30,070 --> 00:11:33,430
something like that but I was really

00:11:31,750 --> 00:11:36,220
okay with something less fancy like I

00:11:33,430 --> 00:11:37,990
didn't need to hide a synchronicity or

00:11:36,220 --> 00:11:40,450
something like that I just needed raw

00:11:37,990 --> 00:11:42,970
speed so I started writing my own actor

00:11:40,450 --> 00:11:44,860
system which I called Kay and when I

00:11:42,970 --> 00:11:46,720
started I realized that thanks to my

00:11:44,860 --> 00:11:49,209
previous work I already had a lot of the

00:11:46,720 --> 00:11:51,190
basic ingredients that I needed to

00:11:49,209 --> 00:11:53,050
represent the actor state and messages I

00:11:51,190 --> 00:11:56,709
could use my plain old beta plus

00:11:53,050 --> 00:11:58,240
recursively compact containers for the

00:11:56,709 --> 00:12:00,370
actor identity and references between

00:11:58,240 --> 00:12:01,779
actors I could again just use entity IDs

00:12:00,370 --> 00:12:04,360
and pointer maps and the only thing that

00:12:01,779 --> 00:12:06,579
I was really missing were the message

00:12:04,360 --> 00:12:08,200
inboxes for the actors where incoming

00:12:06,579 --> 00:12:12,160
messages are stored and for that I just

00:12:08,200 --> 00:12:13,750
used a simple cube per actor type in the

00:12:12,160 --> 00:12:16,269
single court case in the multi core case

00:12:13,750 --> 00:12:18,220
I would just need something like multi

00:12:16,269 --> 00:12:20,800
producer single consumer cube but these

00:12:18,220 --> 00:12:24,870
are really easy to synchronize and

00:12:20,800 --> 00:12:27,399
really easy to synchronize in a fast way

00:12:24,870 --> 00:12:30,130
and then I looked at which new freedoms

00:12:27,399 --> 00:12:32,649
does this approach give me first one is

00:12:30,130 --> 00:12:34,390
actors don't really care where and how

00:12:32,649 --> 00:12:36,250
they are stored which allows you to

00:12:34,390 --> 00:12:38,860
completely separate your business logic

00:12:36,250 --> 00:12:41,050
which is encoded in the actor message

00:12:38,860 --> 00:12:44,190
handlers from the memory allocation and

00:12:41,050 --> 00:12:47,290
the layout of the actor state

00:12:44,190 --> 00:12:50,170
furthermore they don't care where and by

00:12:47,290 --> 00:12:51,910
whom they are updated so it doesn't

00:12:50,170 --> 00:12:54,490
really matter on which core an actor is

00:12:51,910 --> 00:12:56,680
running and which core decides to

00:12:54,490 --> 00:12:58,420
process which actor wins so again you

00:12:56,680 --> 00:13:02,430
separate your business logic for from

00:12:58,420 --> 00:13:02,430
things like multi-core load balancing

00:13:02,490 --> 00:13:08,140
actors also don't care when and how

00:13:04,779 --> 00:13:09,699
often they are updated and scheduling is

00:13:08,140 --> 00:13:11,350
something very important in games where

00:13:09,699 --> 00:13:13,570
you might have rendering which runs at a

00:13:11,350 --> 00:13:15,040
different pace than physics which runs

00:13:13,570 --> 00:13:16,870
at a different pace than other things

00:13:15,040 --> 00:13:18,940
that only need to be updated from time

00:13:16,870 --> 00:13:21,370
to time and doing something like this is

00:13:18,940 --> 00:13:23,140
very natural and easy in actor system so

00:13:21,370 --> 00:13:24,640
again because the business logic itself

00:13:23,140 --> 00:13:27,130
doesn't care how

00:13:24,640 --> 00:13:30,160
grunts if you combine some of the

00:13:27,130 --> 00:13:31,690
previous points that actors don't care

00:13:30,160 --> 00:13:33,640
when at home they are updated and where

00:13:31,690 --> 00:13:36,250
and how they are stored you realize that

00:13:33,640 --> 00:13:38,140
it actually becomes possible to stop the

00:13:36,250 --> 00:13:40,750
whole simulated world save it to the

00:13:38,140 --> 00:13:46,330
disk and resume it at any later point

00:13:40,750 --> 00:13:48,160
without any serialization and one extra

00:13:46,330 --> 00:13:50,470
bonus thing is that actors don't care

00:13:48,160 --> 00:13:51,940
who exactly they interact with if they

00:13:50,470 --> 00:13:54,070
send a message to someone they don't

00:13:51,940 --> 00:13:56,350
care about the type of that l director

00:13:54,070 --> 00:13:58,060
they just care that it will understand

00:13:56,350 --> 00:13:59,680
this message which allows you to

00:13:58,060 --> 00:14:03,310
actually create a whole new form of

00:13:59,680 --> 00:14:06,250
dynamic dispatch from them and at this

00:14:03,310 --> 00:14:07,990
point I ask myself is it possible to

00:14:06,250 --> 00:14:09,790
write a whole basic game engine with

00:14:07,990 --> 00:14:12,520
that and build city bond with that and

00:14:09,790 --> 00:14:21,190
the answer is yes and this will be my

00:14:12,520 --> 00:14:27,640
first live demo all right so let me

00:14:21,190 --> 00:14:31,120
start up city bond here we are and I

00:14:27,640 --> 00:14:32,530
will start by just drawing a plan for a

00:14:31,120 --> 00:14:35,580
small village you were drawing like a

00:14:32,530 --> 00:14:37,840
four-lane road let's create another

00:14:35,580 --> 00:14:41,130
second four-lane road maybe a couple

00:14:37,840 --> 00:14:43,240
smaller ones to connect everything and

00:14:41,130 --> 00:14:45,250
you can see it automatically like

00:14:43,240 --> 00:14:47,890
figures out pretty complex intersection

00:14:45,250 --> 00:14:50,890
geometry here if I wanted I could have

00:14:47,890 --> 00:14:54,310
like this horrible six way intersection

00:14:50,890 --> 00:14:56,740
here and just works okay let's say I'm

00:14:54,310 --> 00:14:58,060
happy with that so I built that you can

00:14:56,740 --> 00:15:00,820
see the roads built you can see it

00:14:58,060 --> 00:15:03,190
created traffic lights for this horrible

00:15:00,820 --> 00:15:06,970
intersection which actually have timings

00:15:03,190 --> 00:15:09,040
that kind of make sense but just like

00:15:06,970 --> 00:15:10,600
this it's a little boring and empty so

00:15:09,040 --> 00:15:15,550
let's spawn a couple of buildings where

00:15:10,600 --> 00:15:18,160
people can live all right that's good

00:15:15,550 --> 00:15:21,850
and now if you wait for a second we will

00:15:18,160 --> 00:15:23,020
see that some cars appear and these are

00:15:21,850 --> 00:15:25,030
actually the inhabitants of these

00:15:23,020 --> 00:15:27,730
buildings going about their daily

00:15:25,030 --> 00:15:29,920
business you can see the cars like break

00:15:27,730 --> 00:15:31,180
and slow down they disappear when they

00:15:29,920 --> 00:15:37,390
reach their destination they change

00:15:31,180 --> 00:15:38,500
lanes and if we click on a building by

00:15:37,390 --> 00:15:41,740
the way this is also

00:15:38,500 --> 00:15:43,480
in GUI really amazing library we can see

00:15:41,740 --> 00:15:46,150
bought that the family he has some

00:15:43,480 --> 00:15:47,980
resources and the individual members of

00:15:46,150 --> 00:15:49,840
the family have some resources this

00:15:47,980 --> 00:15:51,130
person in particular is like getting

00:15:49,840 --> 00:15:55,570
more and more hungry and more and more

00:15:51,130 --> 00:15:57,580
sleepy as I think all of us are but they

00:15:55,570 --> 00:15:59,470
actually solve these problems by driving

00:15:57,580 --> 00:16:01,180
to these like great buildings here which

00:15:59,470 --> 00:16:03,940
are grocery shops and the grocery shops

00:16:01,180 --> 00:16:06,550
selling food and everything you see here

00:16:03,940 --> 00:16:09,040
is actors like every piece of road is an

00:16:06,550 --> 00:16:11,500
actor every family is an actor every

00:16:09,040 --> 00:16:13,600
family actor belongs to this family

00:16:11,500 --> 00:16:15,370
every house is an actor the renderer

00:16:13,600 --> 00:16:17,410
itself is actually an actor and all

00:16:15,370 --> 00:16:22,150
these other objects send it messages to

00:16:17,410 --> 00:16:24,190
render themselves and I think you can

00:16:22,150 --> 00:16:27,250
see that I mean this is just the village

00:16:24,190 --> 00:16:29,560
but I'm actually representing every

00:16:27,250 --> 00:16:31,240
single person with all of their detail

00:16:29,560 --> 00:16:34,390
I'm not cheating they go back to the

00:16:31,240 --> 00:16:36,790
same home and so on but of course the

00:16:34,390 --> 00:16:38,470
important question for me was would it

00:16:36,790 --> 00:16:42,340
actually scale to the scale that I

00:16:38,470 --> 00:16:47,800
wanted so let me restart that and use a

00:16:42,340 --> 00:16:50,350
handy generating tool so let's force the

00:16:47,800 --> 00:16:53,670
game to create a huge 10 by 10 kilometer

00:16:50,350 --> 00:16:56,050
grid of roads with 8 Lane roads actually

00:16:53,670 --> 00:17:00,340
here you see the plan for that let me

00:16:56,050 --> 00:17:03,640
zoom out it's pretty big let's build

00:17:00,340 --> 00:17:05,080
that this takes a little bit now because

00:17:03,640 --> 00:17:06,640
this is something that would never

00:17:05,080 --> 00:17:08,830
really happen in the game itself like I

00:17:06,640 --> 00:17:11,320
would just gradually build the city but

00:17:08,830 --> 00:17:14,020
it doesn't really take that long now you

00:17:11,320 --> 00:17:15,760
can see the roads building again with

00:17:14,020 --> 00:17:18,790
the traffic lights and everything just

00:17:15,760 --> 00:17:20,890
here to give you a sense of scale and

00:17:18,790 --> 00:17:22,240
now if you look at the frames per second

00:17:20,890 --> 00:17:24,190
and slows down a little because right

00:17:22,240 --> 00:17:26,320
now it's calculating all the pathfinding

00:17:24,190 --> 00:17:33,040
from every possible spot in this grid to

00:17:26,320 --> 00:17:36,400
every other possible spot and yeah let's

00:17:33,040 --> 00:17:38,740
just wait for it to settle up what I

00:17:36,400 --> 00:17:42,110
will do next is I will spawn 100,000

00:17:38,740 --> 00:17:45,870
cars which should be enough to simulate

00:17:42,110 --> 00:17:47,970
which which should be enough to simulate

00:17:45,870 --> 00:17:50,580
a city of about 1 million people because

00:17:47,970 --> 00:17:51,930
at rush hour there's roughly 10% of the

00:17:50,580 --> 00:17:56,190
population on the road at once

00:17:51,930 --> 00:17:59,010
according to statistics I looked this up

00:17:56,190 --> 00:18:03,960
I just don't have the source now okay so

00:17:59,010 --> 00:18:15,120
let's spawn the cars again give it a

00:18:03,960 --> 00:18:17,390
second for them to appear I hate such

00:18:15,120 --> 00:18:17,390
smallness

00:18:25,890 --> 00:18:33,210
and here they are and you can see note

00:18:30,429 --> 00:18:33,210
that they're up here

00:18:43,160 --> 00:18:47,850
now that they appeared it still runs

00:18:45,480 --> 00:18:50,250
battery smooth you see every single one

00:18:47,850 --> 00:18:52,170
of them interacting with each other here

00:18:50,250 --> 00:18:55,049
you can see some changing lanes the

00:18:52,170 --> 00:18:56,730
others waiting for them and again like

00:18:55,049 --> 00:18:58,410
numbers like a hundred thousand I'm not

00:18:56,730 --> 00:19:00,000
that really easy to understand but let

00:18:58,410 --> 00:19:04,860
me just like look towards the horizon

00:19:00,000 --> 00:19:06,929
here or zoom out and I'm not doing

00:19:04,860 --> 00:19:08,850
anything like that you would expect from

00:19:06,929 --> 00:19:11,520
games where you only simulate the ones

00:19:08,850 --> 00:19:15,299
that you see like no I just constantly

00:19:11,520 --> 00:19:19,190
do all of them and yet you can see these

00:19:15,299 --> 00:19:19,190
cars now found out what gridlock is

00:19:22,040 --> 00:19:27,000
alright cool and they all dynamically

00:19:25,290 --> 00:19:28,679
like they have randomly chosen source

00:19:27,000 --> 00:19:30,570
and destination positions along the

00:19:28,679 --> 00:19:33,660
street and they dynamically path find

00:19:30,570 --> 00:19:36,260
their way there all right that was the

00:19:33,660 --> 00:19:36,260
first demo

00:19:45,580 --> 00:19:49,880
but now let's come back to these

00:19:47,690 --> 00:19:51,380
freedoms that I mentioned earlier and

00:19:49,880 --> 00:19:54,260
really think them to their logical

00:19:51,380 --> 00:19:56,300
conclusion actors don't care we aren't

00:19:54,260 --> 00:19:59,360
how they're stored so storing them on a

00:19:56,300 --> 00:20:01,010
different computers okay they don't care

00:19:59,360 --> 00:20:02,750
where and by whom they are updated so

00:20:01,010 --> 00:20:05,480
updating them on a different computers

00:20:02,750 --> 00:20:07,400
okay and since everything is

00:20:05,480 --> 00:20:09,260
asynchronous and actors don't really

00:20:07,400 --> 00:20:10,970
care when exactly their messages arrive

00:20:09,260 --> 00:20:13,610
sending the messages over network is

00:20:10,970 --> 00:20:15,020
actually also okay and at this point you

00:20:13,610 --> 00:20:17,270
have to ask yourself is it actually

00:20:15,020 --> 00:20:20,900
possible to write a distributed game

00:20:17,270 --> 00:20:23,810
engine based on that and again the

00:20:20,900 --> 00:20:25,790
answer seems to be yes and this

00:20:23,810 --> 00:20:31,430
inevitably leads me to the second much

00:20:25,790 --> 00:20:35,390
more risky demo let's get started I will

00:20:31,430 --> 00:20:40,220
again launch city bound this time you

00:20:35,390 --> 00:20:42,080
see some IP addresses here and I will

00:20:40,220 --> 00:20:43,760
start the same way first just by drawing

00:20:42,080 --> 00:20:48,580
a small village let's keep it a little

00:20:43,760 --> 00:20:53,450
simpler this time just one main road and

00:20:48,580 --> 00:20:55,900
two others let's build that whoops let

00:20:53,450 --> 00:20:55,900
me do it again

00:20:58,570 --> 00:21:01,930
that was a glitch

00:21:03,630 --> 00:21:14,350
entirely unrelated to all the exciting

00:21:06,100 --> 00:21:16,870
stuff that I talked about okay let's

00:21:14,350 --> 00:21:20,410
build that and now let's lean back and

00:21:16,870 --> 00:21:26,500
watch what happens if player 2 enters

00:21:20,410 --> 00:21:28,900
the game which is actually Veronica

00:21:26,500 --> 00:21:31,990
sitting over there drawing planning a

00:21:28,900 --> 00:21:33,670
road on her laptop she's seeing a real

00:21:31,990 --> 00:21:37,060
time synchronized version of my game

00:21:33,670 --> 00:21:39,160
mode she's seeing one yeah do it like

00:21:37,060 --> 00:21:41,140
that perfect she built the road in my

00:21:39,160 --> 00:21:43,290
city which is running both on this

00:21:41,140 --> 00:21:45,910
laptop and on her laptop over there and

00:21:43,290 --> 00:21:50,620
again let's give the city some life by

00:21:45,910 --> 00:21:52,840
spawning a couple buildings and just as

00:21:50,620 --> 00:21:54,520
before we will see these citizens going

00:21:52,840 --> 00:21:56,080
about their business only that they

00:21:54,520 --> 00:21:57,490
don't know that like some of these

00:21:56,080 --> 00:21:59,920
buildings might be on her laptop some

00:21:57,490 --> 00:22:02,500
online the positions of the cars are

00:21:59,920 --> 00:22:05,230
synced in real time and it all just

00:22:02,500 --> 00:22:06,670
works without me really touching the

00:22:05,230 --> 00:22:09,580
business logic at all which is the

00:22:06,670 --> 00:22:14,290
creepy part and just for fun let's just

00:22:09,580 --> 00:22:15,820
dress test this as well I don't know how

00:22:14,290 --> 00:22:20,920
well it will work because this is just

00:22:15,820 --> 00:22:22,600
over Wi-Fi but let's try so Veronica

00:22:20,920 --> 00:22:25,900
could you please create the grid a

00:22:22,600 --> 00:22:27,340
slightly smaller one just with less

00:22:25,900 --> 00:22:32,620
lanes actually and can you build it

00:22:27,340 --> 00:22:34,660
please and yeah it took a second for it

00:22:32,620 --> 00:22:36,490
to arrive but now this grid was actually

00:22:34,660 --> 00:22:38,530
kind of streamed from her laptop to mine

00:22:36,490 --> 00:22:43,060
including like all the lanes and traffic

00:22:38,530 --> 00:22:47,860
lights and everything and yeah why don't

00:22:43,060 --> 00:22:49,240
you spawn some cars there and here the

00:22:47,860 --> 00:22:55,180
cars are I'm not doing anything

00:22:49,240 --> 00:22:57,190
and we can see them with slight hiccups

00:22:55,180 --> 00:22:59,440
but now running just as smoothly as

00:22:57,190 --> 00:23:00,970
before with the only difference being

00:22:59,440 --> 00:23:03,250
that they're not only being rendered

00:23:00,970 --> 00:23:04,690
here on my screen but that all of their

00:23:03,250 --> 00:23:07,570
positions and everything is also being

00:23:04,690 --> 00:23:09,970
writing to her laptop and it should look

00:23:07,570 --> 00:23:11,980
pretty much exactly the same for her

00:23:09,970 --> 00:23:14,560
sore here we have this potentially huge

00:23:11,980 --> 00:23:15,760
city here just the traffic running in

00:23:14,560 --> 00:23:18,210
real-time synchronization

00:23:15,760 --> 00:23:18,210
two laptops

00:23:18,270 --> 00:23:32,659
[Applause]

00:23:28,179 --> 00:23:35,059
cool so thank you very much

00:23:32,659 --> 00:23:37,809
Veronica for being my player to both in

00:23:35,059 --> 00:23:43,429
this demo and in real life

00:23:37,809 --> 00:23:44,960
and just to give you an idea of how well

00:23:43,429 --> 00:23:46,700
all the different parts of the game

00:23:44,960 --> 00:23:48,739
already distributed because even though

00:23:46,700 --> 00:23:50,869
everything is implemented as actors I'm

00:23:48,739 --> 00:23:52,249
still used to like the traditional kind

00:23:50,869 --> 00:23:54,470
of coding where you write everything

00:23:52,249 --> 00:23:55,429
very centralized but for example like I

00:23:54,470 --> 00:23:56,210
mentioned the render is really

00:23:55,429 --> 00:23:57,830
centralized

00:23:56,210 --> 00:23:59,720
the traffic simulation part funding

00:23:57,830 --> 00:24:01,729
already really well centralized other

00:23:59,720 --> 00:24:03,169
stuff I still have to work on to make it

00:24:01,729 --> 00:24:04,700
more concrete this is kind of what

00:24:03,169 --> 00:24:06,409
happened right now like there are the

00:24:04,700 --> 00:24:08,749
two laptops both of them have a renderer

00:24:06,409 --> 00:24:11,359
we each had our individual plan that we

00:24:08,749 --> 00:24:12,979
were editing all the roads and the cars

00:24:11,359 --> 00:24:14,749
on them lived on my machine right here

00:24:12,979 --> 00:24:17,029
but they were also rendered on hers for

00:24:14,749 --> 00:24:18,470
example but like the trips which

00:24:17,029 --> 00:24:20,659
represent the journeys of the people

00:24:18,470 --> 00:24:22,729
could exist to both and like use a car

00:24:20,659 --> 00:24:25,190
on either of the laptops same for the

00:24:22,729 --> 00:24:26,869
families but there's only one economic

00:24:25,190 --> 00:24:28,159
market for example right now but you can

00:24:26,869 --> 00:24:30,409
imagine all of them just cross

00:24:28,159 --> 00:24:32,539
communicating to each other and they

00:24:30,409 --> 00:24:34,720
really don't know if they're talking to

00:24:32,539 --> 00:24:37,460
another actor on the same machine or not

00:24:34,720 --> 00:24:39,109
to give you just a quick idea in the end

00:24:37,460 --> 00:24:40,940
about what this looks like in code I

00:24:39,109 --> 00:24:43,279
want to show you two iterations of my

00:24:40,940 --> 00:24:44,809
API design for that okay is something

00:24:43,279 --> 00:24:47,059
really specialized that I really only

00:24:44,809 --> 00:24:49,729
write for myself but I should be even

00:24:47,059 --> 00:24:51,830
nice to the user who is me so let me

00:24:49,729 --> 00:24:53,539
show you what I did and we will use the

00:24:51,830 --> 00:25:01,099
example of a parrot we will implement a

00:24:53,539 --> 00:25:04,039
parrot so let's start here we define our

00:25:01,099 --> 00:25:06,679
parrot we say that it's an actor it has

00:25:04,039 --> 00:25:09,049
an ID and a state let's just say it has

00:25:06,679 --> 00:25:11,779
happiness as a number and it has this

00:25:09,049 --> 00:25:14,419
compact vector of IDs which represent

00:25:11,779 --> 00:25:16,279
the friends of this parrot let's invent

00:25:14,419 --> 00:25:18,590
a message which we could possibly parrot

00:25:16,279 --> 00:25:20,869
a greeting a greeting has a greeter

00:25:18,590 --> 00:25:22,309
which is the other bird I guess which

00:25:20,869 --> 00:25:24,019
sent this greeting and the number of

00:25:22,309 --> 00:25:26,389
tweets encoding all of the information

00:25:24,019 --> 00:25:28,879
in the greeting as is normal for birds

00:25:26,389 --> 00:25:30,590
and then for the parrot to be able to

00:25:28,879 --> 00:25:32,809
understand the greeting we implement

00:25:30,590 --> 00:25:35,330
recipient of greeting for parrot it has

00:25:32,809 --> 00:25:38,059
this receive function which takes the

00:25:35,330 --> 00:25:39,650
state of the parrot as mutable self gets

00:25:38,059 --> 00:25:42,350
a reference to the message and then

00:25:39,650 --> 00:25:44,450
a third parameter called word world

00:25:42,350 --> 00:25:46,370
which represents the worldview of this

00:25:44,450 --> 00:25:50,300
actor the parrot and is mainly used to

00:25:46,370 --> 00:25:52,250
send messages when we receive such such

00:25:50,300 --> 00:25:55,070
a message we update our happiness by the

00:25:52,250 --> 00:25:56,930
number of tweets that we received and we

00:25:55,070 --> 00:25:58,850
add the greeter to our list of friends

00:25:56,930 --> 00:26:00,800
and of course since we are paired we

00:25:58,850 --> 00:26:04,220
will just reply with exactly the same so

00:26:00,800 --> 00:26:07,130
in our world we send to the greeting dot

00:26:04,220 --> 00:26:09,860
greeter a greeting ourselves we put our

00:26:07,130 --> 00:26:12,320
own ideas the greeter and we reply with

00:26:09,860 --> 00:26:14,510
the same number of tweets finally the

00:26:12,320 --> 00:26:16,460
return value specifies whether after

00:26:14,510 --> 00:26:18,020
receiving this kind of message this

00:26:16,460 --> 00:26:19,820
actor should continue living or dying

00:26:18,020 --> 00:26:21,650
and since I don't really see why a

00:26:19,820 --> 00:26:25,190
parrot should die after being greeted

00:26:21,650 --> 00:26:27,170
let's let it live finally in the bottom

00:26:25,190 --> 00:26:28,850
I have some boilerplate which I need to

00:26:27,170 --> 00:26:30,590
register the parrot with the actor

00:26:28,850 --> 00:26:33,850
system and to tell the actor system that

00:26:30,590 --> 00:26:36,140
it can actually handle the greeting so

00:26:33,850 --> 00:26:37,910
there's kind of lots of repetition and

00:26:36,140 --> 00:26:39,320
verbosity here and in this example it's

00:26:37,910 --> 00:26:40,640
still kind of fine but if you imagine a

00:26:39,320 --> 00:26:43,010
whole code base that gets really

00:26:40,640 --> 00:26:45,410
annoying really quickly something that's

00:26:43,010 --> 00:26:47,330
really cool is that this ID can refer to

00:26:45,410 --> 00:26:49,520
any actor of any kind

00:26:47,330 --> 00:26:51,260
thanks to this indirection something

00:26:49,520 --> 00:26:53,930
that's not cool is that this means that

00:26:51,260 --> 00:26:56,300
this can horribly fail at runtime if we

00:26:53,930 --> 00:26:57,860
send this message to some random ID

00:26:56,300 --> 00:26:59,690
where we don't know if this actor will

00:26:57,860 --> 00:27:03,110
actually be able to understand this

00:26:59,690 --> 00:27:04,550
message regarding the verbosity I tried

00:27:03,110 --> 00:27:05,960
a couple iterations that are really

00:27:04,550 --> 00:27:07,430
similar to this one that just got a

00:27:05,960 --> 00:27:08,990
little shorter but the main point that I

00:27:07,430 --> 00:27:12,530
wanted to address was really this

00:27:08,990 --> 00:27:14,750
problem here and to invent version 2 of

00:27:12,530 --> 00:27:17,690
the syntax I had to involve

00:27:14,750 --> 00:27:20,210
metaprogramming not the typical meta

00:27:17,690 --> 00:27:21,200
programming for rust macros because it

00:27:20,210 --> 00:27:23,540
really wasn't enough but the

00:27:21,200 --> 00:27:26,270
lesser-known one which is build scripts

00:27:23,540 --> 00:27:28,900
and what I did was I used the very

00:27:26,270 --> 00:27:31,910
amazing sin in quote crates which

00:27:28,900 --> 00:27:33,800
respectively parse any kind of rust code

00:27:31,910 --> 00:27:37,040
or generate any kind of rust code and

00:27:33,800 --> 00:27:38,840
what I did was I basically write this

00:27:37,040 --> 00:27:41,840
kind of code which I will explain in a

00:27:38,840 --> 00:27:43,970
second this gets parsed and the build

00:27:41,840 --> 00:27:46,070
script generates additional rust code

00:27:43,970 --> 00:27:47,540
that is basically what I all the

00:27:46,070 --> 00:27:50,210
annoying stuff that I did by hand in the

00:27:47,540 --> 00:27:52,220
past so let's look at this again I

00:27:50,210 --> 00:27:53,240
defined a parrot you will notice that it

00:27:52,220 --> 00:27:55,190
has a parrot

00:27:53,240 --> 00:27:57,440
Idina so the first thing the build

00:27:55,190 --> 00:27:59,510
script does is for each actor type that

00:27:57,440 --> 00:28:02,600
automatically generates a corresponding

00:27:59,510 --> 00:28:06,260
typed actor ID which can only refer to

00:28:02,600 --> 00:28:07,970
this kind of actor next I just implement

00:28:06,260 --> 00:28:09,350
parrot itself and I define a greet

00:28:07,970 --> 00:28:10,880
function I don't have to create a struct

00:28:09,350 --> 00:28:14,450
anymore for the message I just define a

00:28:10,880 --> 00:28:16,310
function takes again the state here's my

00:28:14,450 --> 00:28:18,980
parameters and the world this looks the

00:28:16,310 --> 00:28:21,320
same and the cool thing is that the

00:28:18,980 --> 00:28:24,350
build script then generates for the ID

00:28:21,320 --> 00:28:27,050
type a corresponding sending function so

00:28:24,350 --> 00:28:29,930
I can for example just say greeter dot

00:28:27,050 --> 00:28:31,580
greet and this is actually this is not a

00:28:29,930 --> 00:28:34,010
parrot object or something it's just an

00:28:31,580 --> 00:28:36,830
ID but what this internally does is send

00:28:34,010 --> 00:28:39,470
a message to the actor system using this

00:28:36,830 --> 00:28:41,450
world reference here to some other actor

00:28:39,470 --> 00:28:43,310
but it just looks like a normal function

00:28:41,450 --> 00:28:46,070
call and the code became super short and

00:28:43,310 --> 00:28:48,100
normal looking I have to include this

00:28:46,070 --> 00:28:50,870
additional like auto-generated module

00:28:48,100 --> 00:28:53,480
but this makes all of this possible and

00:28:50,870 --> 00:28:55,100
also includes automatically all the

00:28:53,480 --> 00:28:57,160
boilerplate for registering all the

00:28:55,100 --> 00:29:02,000
different messages and actor can handle

00:28:57,160 --> 00:29:06,410
so not so nice is that greeter can now

00:29:02,000 --> 00:29:07,970
only refer exactly to Paris but at least

00:29:06,410 --> 00:29:11,210
we can be sure and the type system

00:29:07,970 --> 00:29:13,400
ensures that the ID which we sent this

00:29:11,210 --> 00:29:15,620
message to the actor behind that can

00:29:13,400 --> 00:29:16,970
actually handle this message but this

00:29:15,620 --> 00:29:18,140
wasn't enough for me because I really

00:29:16,970 --> 00:29:21,230
didn't want to give up on this dynamic

00:29:18,140 --> 00:29:22,670
dispatch so I made the build script a

00:29:21,230 --> 00:29:24,500
little smarter that it can also

00:29:22,670 --> 00:29:27,170
understand crates so let's define

00:29:24,500 --> 00:29:30,650
instead a trade word here with our greet

00:29:27,170 --> 00:29:33,260
function and it takes a bird ID so the

00:29:30,650 --> 00:29:40,090
build script now also creates generic

00:29:33,260 --> 00:29:45,200
typed IDs for actor traits and if our

00:29:40,090 --> 00:29:47,840
actor implements the trait then it makes

00:29:45,200 --> 00:29:51,410
sure that our actor ID implements into

00:29:47,840 --> 00:29:53,300
the trade ID so now I can pass the ID of

00:29:51,410 --> 00:29:56,090
the parrot converted into a generic bird

00:29:53,300 --> 00:29:59,870
ID and at the same time this creature is

00:29:56,090 --> 00:30:01,640
a bird ID and I don't know which exact

00:29:59,870 --> 00:30:03,410
type it will be but I know for sure that

00:30:01,640 --> 00:30:05,060
it's an implementer of bird and it will

00:30:03,410 --> 00:30:06,320
understand my message so it could also

00:30:05,060 --> 00:30:09,350
be a human

00:30:06,320 --> 00:30:11,090
implements bird for example and still

00:30:09,350 --> 00:30:13,159
the type system ensures that this will

00:30:11,090 --> 00:30:17,899
actually work and I have dynamic

00:30:13,159 --> 00:30:20,720
dispatch success so now we have typesafe

00:30:17,899 --> 00:30:22,639
distributed message passing in what I

00:30:20,720 --> 00:30:24,799
would call a dialect of rust that's

00:30:22,639 --> 00:30:26,059
still very close to idiomatic rust I

00:30:24,799 --> 00:30:27,529
don't have to create any kind of

00:30:26,059 --> 00:30:29,720
structures for message I just write

00:30:27,529 --> 00:30:31,460
struts for my actors I can have trades

00:30:29,720 --> 00:30:35,750
and I have functions to handle messages

00:30:31,460 --> 00:30:37,610
I want to in the end tell you a couple

00:30:35,750 --> 00:30:42,259
lessons learned maybe from the most

00:30:37,610 --> 00:30:43,940
specific to the most generic using three

00:30:42,259 --> 00:30:45,259
different languages I had different

00:30:43,940 --> 00:30:47,809
feelings about them and being a

00:30:45,259 --> 00:30:51,860
programmer I will present my feelings to

00:30:47,809 --> 00:30:53,659
you as a matrix of unicode symbols look

00:30:51,860 --> 00:30:55,159
at this information density I will not

00:30:53,659 --> 00:30:58,879
go through it in detail I think you can

00:30:55,159 --> 00:31:00,379
understand this one pretty well and here

00:30:58,879 --> 00:31:02,830
different aspects of the programming

00:31:00,379 --> 00:31:02,830
languages

00:31:03,060 --> 00:31:08,260
and I want to highlight one in

00:31:06,760 --> 00:31:10,270
particular which is really important for

00:31:08,260 --> 00:31:12,040
me prototyping speed or iteration speed

00:31:10,270 --> 00:31:14,500
where of course nothing beats a dynamic

00:31:12,040 --> 00:31:16,300
language and rust compiler is still kind

00:31:14,500 --> 00:31:21,550
of slow but it's getting better so let's

00:31:16,300 --> 00:31:23,890
give it a poker face yeah in general

00:31:21,550 --> 00:31:25,600
consider active systems as a solution to

00:31:23,890 --> 00:31:27,100
your problem if it's distributed or

00:31:25,600 --> 00:31:29,290
parallel in any kind it can be

00:31:27,100 --> 00:31:31,030
surprisingly clean no matter if you use

00:31:29,290 --> 00:31:33,820
a high-level actor system with lots of

00:31:31,030 --> 00:31:36,940
fancy stuff or like a low-level really

00:31:33,820 --> 00:31:39,130
fast one consider meta programming and

00:31:36,940 --> 00:31:40,540
domain specific languages or if you want

00:31:39,130 --> 00:31:44,590
something less extreme domain-specific

00:31:40,540 --> 00:31:47,350
dialects and something that I really had

00:31:44,590 --> 00:31:49,210
to learn working on a big codebase like

00:31:47,350 --> 00:31:51,160
this is that you should think about

00:31:49,210 --> 00:31:53,350
coding not just in space but in time

00:31:51,160 --> 00:31:55,150
don't just think like you realize all

00:31:53,350 --> 00:31:57,070
this is a really ugly architecture and

00:31:55,150 --> 00:31:59,470
then you invent like your ideal vision

00:31:57,070 --> 00:32:02,650
but always keep in mind two steps in

00:31:59,470 --> 00:32:05,050
between and be ready to take compromises

00:32:02,650 --> 00:32:06,730
like okay I will write part of my code

00:32:05,050 --> 00:32:08,230
in the new architecture but if the new

00:32:06,730 --> 00:32:10,210
architecture is completely backwards

00:32:08,230 --> 00:32:12,280
compatible to the old one I can just

00:32:10,210 --> 00:32:14,560
slowly readily do this until everything

00:32:12,280 --> 00:32:16,330
is in the new style and then remove all

00:32:14,560 --> 00:32:18,490
the superfluous stuff which I don't need

00:32:16,330 --> 00:32:20,470
anymore I did this a couple times in

00:32:18,490 --> 00:32:22,510
city bound the borrowed check and type

00:32:20,470 --> 00:32:24,160
system are your best friends when it

00:32:22,510 --> 00:32:27,160
comes to this because they both let you

00:32:24,160 --> 00:32:29,290
see into the future and make you keep

00:32:27,160 --> 00:32:31,870
the promises which you passed self-made

00:32:29,290 --> 00:32:33,790
by that I mean like for example seeing

00:32:31,870 --> 00:32:35,590
into the future you can just change one

00:32:33,790 --> 00:32:38,230
core essential part of your project and

00:32:35,590 --> 00:32:39,790
it will immediately throw errors show

00:32:38,230 --> 00:32:41,350
you everything that will be affected

00:32:39,790 --> 00:32:43,600
which gives you really good first idea

00:32:41,350 --> 00:32:45,580
and of course if you start drafting a

00:32:43,600 --> 00:32:48,010
new system just with types and then

00:32:45,580 --> 00:32:49,750
start implementing it for a second type

00:32:48,010 --> 00:32:52,350
system will be there to make sure that

00:32:49,750 --> 00:32:54,730
you actually follow your plan in general

00:32:52,350 --> 00:32:57,100
build cool stuff this is such an amazing

00:32:54,730 --> 00:33:00,130
community and if you like the cool stuff

00:32:57,100 --> 00:33:01,900
which I'm building check out city bound

00:33:00,130 --> 00:33:03,250
open source on github maybe not today

00:33:01,900 --> 00:33:05,140
but tomorrow because then I can actually

00:33:03,250 --> 00:33:09,940
update the documentation to what I

00:33:05,140 --> 00:33:11,500
quickly implemented the last days look

00:33:09,940 --> 00:33:13,810
at city burns simcom check out the

00:33:11,500 --> 00:33:15,520
awesome community and read it and if you

00:33:13,810 --> 00:33:17,140
like city building games at all

00:33:15,520 --> 00:33:19,630
shameless plug consider becoming a

00:33:17,140 --> 00:33:20,130
patron thank you all very much for your

00:33:19,630 --> 00:33:42,739
attention

00:33:20,130 --> 00:33:42,739

YouTube URL: https://www.youtube.com/watch?v=LiIoE8ArACs


