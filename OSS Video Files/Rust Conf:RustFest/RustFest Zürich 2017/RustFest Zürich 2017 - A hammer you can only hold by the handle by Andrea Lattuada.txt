Title: RustFest Zürich 2017 - A hammer you can only hold by the handle by Andrea Lattuada
Publication date: 2017-10-21
Playlist: RustFest Zürich 2017
Description: 
	Rust’s type system provides tools to ensure safe memory management, and safe concurrent access to data. What if we used those same tools to encode and enforce other API constraints?

We can leverage affine types (non-Clone structs) to enforce that a user performs a series of operations in a certain order; or we can use structs as tokens representing the user’s ability to perform certain actions. And everything’s checked at compile time.

We’ll see how these techniques let us encode complex API constraints, and make them self-documenting by preventing disallowed behaviour at compile time.

About Andrea Lattuada:
I’m a PhD student and Research assistant in the Systems Group, Dept. of Computer Science at ETH Zürich. I have past industry experience with type-heavy programming languages and now work with Rust on safe, reliable, distributed data processing.
Captions: 
	00:00:11,969 --> 00:00:16,289
hi everyone thanks for the introduction

00:00:13,589 --> 00:00:18,960
and yes I am the laziest in the sense

00:00:16,289 --> 00:00:20,970
that my workplace is literally across

00:00:18,960 --> 00:00:25,980
the street from here so it's like two

00:00:20,970 --> 00:00:28,980
minutes walk I'm I'm Andrea I am a PhD

00:00:25,980 --> 00:00:30,930
student in eight months now at the

00:00:28,980 --> 00:00:35,550
Systems Group at the department of

00:00:30,930 --> 00:00:37,980
computer science at ETH and we work we

00:00:35,550 --> 00:00:40,829
rust a lot in the group especially in my

00:00:37,980 --> 00:00:42,120
part of the group and it's been a really

00:00:40,829 --> 00:00:45,780
really good experience it's been a lot

00:00:42,120 --> 00:00:48,899
of fun this talk is about it stemmed

00:00:45,780 --> 00:00:51,089
from my master thesis but it's intended

00:00:48,899 --> 00:00:55,909
to talk more about how we can leverage

00:00:51,089 --> 00:00:58,440
the type system to make as more

00:00:55,909 --> 00:01:02,089
confident in how we use our high-level

00:00:58,440 --> 00:01:04,440
API so we know that rust helps us in

00:01:02,089 --> 00:01:06,210
making sure that we don't make mistake

00:01:04,440 --> 00:01:08,909
when managing memory or when we're doing

00:01:06,210 --> 00:01:11,880
concurrent access but can we use those

00:01:08,909 --> 00:01:14,010
tools to make things better when we are

00:01:11,880 --> 00:01:15,780
designing api's and this is the point we

00:01:14,010 --> 00:01:18,210
have an API we can document it and

00:01:15,780 --> 00:01:21,180
explain how we the user should approach

00:01:18,210 --> 00:01:23,370
it but we know we can also try and see

00:01:21,180 --> 00:01:27,450
if we can make sure that the only way to

00:01:23,370 --> 00:01:31,560
use an API is the right way to do it so

00:01:27,450 --> 00:01:33,660
let's look at a bit of an API we may

00:01:31,560 --> 00:01:36,720
want to send a letter and we want it

00:01:33,660 --> 00:01:40,470
delivered quick so we probably ask a

00:01:36,720 --> 00:01:42,450
delivery company so we ask company they

00:01:40,470 --> 00:01:45,930
send us delivery lorry we order a

00:01:42,450 --> 00:01:47,760
delivery and they come to us to pick up

00:01:45,930 --> 00:01:51,030
our letter we of course have a letter as

00:01:47,760 --> 00:01:53,520
well the letter has any interesting

00:01:51,030 --> 00:01:56,670
content hopefully and we probably want

00:01:53,520 --> 00:01:59,700
to put it in an envelope so we assume

00:01:56,670 --> 00:02:01,860
that we have a way to getting a pre

00:01:59,700 --> 00:02:04,440
stamped envelope for our letter so we

00:02:01,860 --> 00:02:06,390
take a letter we fall there and we put

00:02:04,440 --> 00:02:09,450
it in the envelope and then now the

00:02:06,390 --> 00:02:11,069
delivery person is right outside so we

00:02:09,450 --> 00:02:15,989
tell them yeah we're done we close the

00:02:11,069 --> 00:02:17,489
envelope and we put the letter in the in

00:02:15,989 --> 00:02:20,250
Deloria I was wondering whether I could

00:02:17,489 --> 00:02:22,319
say series while going through all of

00:02:20,250 --> 00:02:24,360
this and I didn't really manage that

00:02:22,319 --> 00:02:25,180
it's very good so and then we said we

00:02:24,360 --> 00:02:27,189
tell them with

00:02:25,180 --> 00:02:32,799
we don't have anything else for you and

00:02:27,189 --> 00:02:35,379
the driver goes on their way so what

00:02:32,799 --> 00:02:37,750
we're doing here is of course this is a

00:02:35,379 --> 00:02:40,120
representation of what an API could be

00:02:37,750 --> 00:02:41,859
we have a series of steps to perform to

00:02:40,120 --> 00:02:44,769
achieve a certain certain result and

00:02:41,859 --> 00:02:47,139
what we're doing if you squint hard

00:02:44,769 --> 00:02:50,139
enough is that we are managing resources

00:02:47,139 --> 00:02:51,969
so the lorry driver was waiting for us

00:02:50,139 --> 00:02:53,709
is a resource we have a short amount of

00:02:51,969 --> 00:02:56,620
time to give them their letter we have

00:02:53,709 --> 00:02:59,049
one letter because we wrote it by hand

00:02:56,620 --> 00:03:02,459
for some reason and and then we also

00:02:59,049 --> 00:03:05,709
have one envelope which we ordered so

00:03:02,459 --> 00:03:06,579
what in language helps us deal with

00:03:05,709 --> 00:03:08,980
resources

00:03:06,579 --> 00:03:10,480
first of all ownership or what some

00:03:08,980 --> 00:03:14,049
people in other communities especially

00:03:10,480 --> 00:03:17,169
called linear or affine types first of

00:03:14,049 --> 00:03:19,750
all we have a function for example use

00:03:17,169 --> 00:03:22,239
name they take the string it doesn't

00:03:19,750 --> 00:03:24,189
take a reference so when we call this

00:03:22,239 --> 00:03:26,950
function we are gonna relinquish

00:03:24,189 --> 00:03:29,199
ownership over the string and then when

00:03:26,950 --> 00:03:32,530
we call this function with our string

00:03:29,199 --> 00:03:35,049
name then because we are giving away

00:03:32,530 --> 00:03:35,500
ownership then if you try to compile

00:03:35,049 --> 00:03:37,989
this

00:03:35,500 --> 00:03:40,419
Russy will complain will say you gave

00:03:37,989 --> 00:03:43,930
away this piece of data you're not

00:03:40,419 --> 00:03:46,239
allowed to use it anymore so to clarify

00:03:43,930 --> 00:03:49,479
we create a string we are the sole

00:03:46,239 --> 00:03:52,389
owners of this string we give away on a

00:03:49,479 --> 00:03:55,120
shape of the string and then we print

00:03:52,389 --> 00:03:57,599
out we try to print out something that

00:03:55,120 --> 00:04:00,370
we don't have ownership for anymore

00:03:57,599 --> 00:04:02,859
another tool to manage ownership and

00:04:00,370 --> 00:04:06,609
mostly a relinquishing ownership is drop

00:04:02,859 --> 00:04:08,799
so drop is a special trait that if

00:04:06,609 --> 00:04:11,470
implemented for a certain structure will

00:04:08,799 --> 00:04:14,560
get invoked just before the piece of

00:04:11,470 --> 00:04:16,120
data gets dropped and these examples are

00:04:14,560 --> 00:04:17,799
slightly contrived of course we're

00:04:16,120 --> 00:04:19,209
getting some data from somewhere and

00:04:17,799 --> 00:04:22,180
then we have an if statement

00:04:19,209 --> 00:04:24,159
the only issue eliza's data if that

00:04:22,180 --> 00:04:25,960
value is more than three and then we try

00:04:24,159 --> 00:04:28,419
to print out this of course doesn't work

00:04:25,960 --> 00:04:32,500
because of lexical scoping but more

00:04:28,419 --> 00:04:36,340
importantly once the piece of data in

00:04:32,500 --> 00:04:38,050
the if statement goes out of scope that

00:04:36,340 --> 00:04:38,880
dr. gets dropped and that memory gets

00:04:38,050 --> 00:04:41,650
the okay

00:04:38,880 --> 00:04:44,050
so we have a way to manage a resource

00:04:41,650 --> 00:04:47,380
and make sure that the resource we are

00:04:44,050 --> 00:04:52,090
holding so memory gets released at the

00:04:47,380 --> 00:04:54,190
end so as we were saying for we are

00:04:52,090 --> 00:04:58,510
still managing resources even in higher

00:04:54,190 --> 00:04:59,860
level API so if you're writing an API to

00:04:58,510 --> 00:05:01,480
send a letter we're still managing

00:04:59,860 --> 00:05:03,340
resources it's just a different kind of

00:05:01,480 --> 00:05:06,120
resources it's not memory anymore it's

00:05:03,340 --> 00:05:09,310
the time of the driver it's the letter

00:05:06,120 --> 00:05:10,840
so let's try and model that ridiculous

00:05:09,310 --> 00:05:14,070
API from before

00:05:10,840 --> 00:05:18,340
as Ross code pretty simply we have a

00:05:14,070 --> 00:05:19,990
letter that contains some text then we

00:05:18,340 --> 00:05:20,500
have an envelope that we order and is

00:05:19,990 --> 00:05:22,690
pre-stamped

00:05:20,500 --> 00:05:26,410
and optionally contains a letter once we

00:05:22,690 --> 00:05:30,040
put it in in the letter and we have a

00:05:26,410 --> 00:05:31,990
handle to our lorry and this is a handle

00:05:30,040 --> 00:05:33,760
because this write this lorry could be a

00:05:31,990 --> 00:05:35,470
shared resource it could be there in

00:05:33,760 --> 00:05:38,230
front of our apartment building waiting

00:05:35,470 --> 00:05:42,160
for multiple people to give their mail

00:05:38,230 --> 00:05:44,530
to them so implementation wise we can

00:05:42,160 --> 00:05:48,490
start with just a way to make a letter

00:05:44,530 --> 00:05:50,410
from a string and then for the envelope

00:05:48,490 --> 00:05:53,920
we need a couple of things we need a way

00:05:50,410 --> 00:05:57,790
to put the letter in the envelope and

00:05:53,920 --> 00:06:02,500
then we need a way to obtain a new

00:05:57,790 --> 00:06:06,070
envelope that's already pre stamped the

00:06:02,500 --> 00:06:08,080
handle we need again all of things we

00:06:06,070 --> 00:06:11,200
need a way to obtain this large driver

00:06:08,080 --> 00:06:14,860
so let me go through it in the right

00:06:11,200 --> 00:06:16,600
order so first of all we need once we

00:06:14,860 --> 00:06:19,450
have the driver there we need to be able

00:06:16,600 --> 00:06:21,340
to give the envelope to the driver so

00:06:19,450 --> 00:06:24,640
that they put it in the lorry and we get

00:06:21,340 --> 00:06:26,440
our mail delivered we should have a way

00:06:24,640 --> 00:06:29,050
to tell them we're done we don't have

00:06:26,440 --> 00:06:31,120
any mail for you anymore and they can

00:06:29,050 --> 00:06:36,070
leave and of course we need a way to

00:06:31,120 --> 00:06:40,690
order a new pickup so how would we use

00:06:36,070 --> 00:06:43,660
this in a Maine somewhere we make a

00:06:40,690 --> 00:06:46,870
letter dear Rose first we grab an

00:06:43,660 --> 00:06:50,320
envelope we put the letter in the

00:06:46,870 --> 00:06:51,999
envelope we order Lori we tell the

00:06:50,320 --> 00:06:56,289
driver his letter and then with

00:06:51,999 --> 00:06:59,289
we're done and they go so what could

00:06:56,289 --> 00:07:01,089
what could go wrong in that code I'm

00:06:59,289 --> 00:07:04,569
gonna focus on three main things and

00:07:01,089 --> 00:07:09,939
these things are first of all we have

00:07:04,569 --> 00:07:12,519
one copy of the letter but right now we

00:07:09,939 --> 00:07:15,209
have nothing enforcing us no preventing

00:07:12,519 --> 00:07:19,360
us from making a copy of the letter

00:07:15,209 --> 00:07:21,249
second we have one envelope and we have

00:07:19,360 --> 00:07:23,009
one letter if we put the first letter in

00:07:21,249 --> 00:07:27,369
the envelope but then develop is used

00:07:23,009 --> 00:07:29,949
but we'll see how this may go wrong and

00:07:27,369 --> 00:07:32,139
of course we also may end up with an

00:07:29,949 --> 00:07:34,209
empty envelope that we end up giving to

00:07:32,139 --> 00:07:37,749
the driver without having put any any

00:07:34,209 --> 00:07:42,129
letter in it and finally we may forget

00:07:37,749 --> 00:07:45,759
to tell the driver we are done so how

00:07:42,129 --> 00:07:48,369
does this look in code first of all they

00:07:45,759 --> 00:07:50,319
do placate copy right now the first good

00:07:48,369 --> 00:07:53,289
because earlier I showed you has add a

00:07:50,319 --> 00:07:54,909
single letter in it and now we still

00:07:53,289 --> 00:07:57,309
every single letter in gear as fast but

00:07:54,909 --> 00:07:59,019
two envelopes we just construct them by

00:07:57,309 --> 00:08:01,089
putting it them in a batch vector we

00:07:59,019 --> 00:08:02,709
ordered a pickup and then we try and put

00:08:01,089 --> 00:08:05,050
the same letter into two different

00:08:02,709 --> 00:08:08,979
envelopes if you look at the code that

00:08:05,050 --> 00:08:10,869
does this that's what I said if you look

00:08:08,979 --> 00:08:12,369
at the code that does this we have the

00:08:10,869 --> 00:08:15,069
screen the letter that is cloneable so

00:08:12,369 --> 00:08:17,709
we can make copies which is now exactly

00:08:15,069 --> 00:08:21,279
the correct considering that these

00:08:17,709 --> 00:08:22,749
letter which is a minimal example here

00:08:21,279 --> 00:08:25,449
could actually represent us all you know

00:08:22,749 --> 00:08:32,069
on two important resources in the array

00:08:25,449 --> 00:08:35,740
in the API and specifically specifically

00:08:32,069 --> 00:08:39,849
because we are putting the same letter

00:08:35,740 --> 00:08:43,300
into two envelopes we are going to end

00:08:39,849 --> 00:08:45,790
up making two copies of this so is there

00:08:43,300 --> 00:08:47,410
a wave to prevent us and there is of

00:08:45,790 --> 00:08:52,300
course it's we don't make letter

00:08:47,410 --> 00:08:55,750
cloneable anymore and when we we change

00:08:52,300 --> 00:09:00,160
the wrap function a little bit in a way

00:08:55,750 --> 00:09:04,179
that when we get a letter from the API

00:09:00,160 --> 00:09:05,889
client we get ownership over it so that

00:09:04,179 --> 00:09:07,720
the client is not able

00:09:05,889 --> 00:09:09,309
to touch the letter anymore this also

00:09:07,720 --> 00:09:10,720
prevents the risk of somebody putting

00:09:09,309 --> 00:09:13,089
the letter in the envelope and then

00:09:10,720 --> 00:09:14,259
attempting to modify it while it's in

00:09:13,089 --> 00:09:18,999
their mouth which is ridiculous of

00:09:14,259 --> 00:09:21,009
course so if we do this then what

00:09:18,999 --> 00:09:23,919
happens when we make this call this is

00:09:21,009 --> 00:09:28,600
the same code as before we end up with

00:09:23,919 --> 00:09:30,009
rust lovey complaining that we move the

00:09:28,600 --> 00:09:31,389
letter in the previous iteration of the

00:09:30,009 --> 00:09:32,910
loop we already used this letter we

00:09:31,389 --> 00:09:36,639
cannot use it again

00:09:32,910 --> 00:09:38,379
so first problem solved we know how to

00:09:36,639 --> 00:09:40,389
prevent to make copies of things that

00:09:38,379 --> 00:09:43,809
are not actually copyable in the real

00:09:40,389 --> 00:09:46,239
world second problem we have some good

00:09:43,809 --> 00:09:49,269
and again we have a single envelope this

00:09:46,239 --> 00:09:51,249
time but we try to use two letters first

00:09:49,269 --> 00:09:52,299
letter is dead your response one but

00:09:51,249 --> 00:09:53,980
then we change this code a little bit

00:09:52,299 --> 00:09:55,899
maybe later we don't really really

00:09:53,980 --> 00:09:57,850
understand how it works anymore so we

00:09:55,899 --> 00:10:01,239
make a new letter called D or a th and

00:09:57,850 --> 00:10:02,889
then we try to wrap the new letter in

00:10:01,239 --> 00:10:04,869
this same envelope what's happens here

00:10:02,889 --> 00:10:07,480
of course is we are all writing the

00:10:04,869 --> 00:10:09,699
letter we are dead before which again in

00:10:07,480 --> 00:10:11,980
the real world makes no sense is there a

00:10:09,699 --> 00:10:14,079
way we can prevent this and of course

00:10:11,980 --> 00:10:15,699
there is we can put an assert and say if

00:10:14,079 --> 00:10:17,949
there was a radial letter in the

00:10:15,699 --> 00:10:20,499
envelope just stop at run-time say

00:10:17,949 --> 00:10:20,949
something's wrong and panic but maybe we

00:10:20,499 --> 00:10:22,929
can do better

00:10:20,949 --> 00:10:24,579
maybe we can represent the two states of

00:10:22,929 --> 00:10:26,799
the envelope as two different types and

00:10:24,579 --> 00:10:28,989
make sure that the order in which we are

00:10:26,799 --> 00:10:32,019
doing the operations is enforced by Russ

00:10:28,989 --> 00:10:34,089
C by the type system so we represent the

00:10:32,019 --> 00:10:35,230
envelope with two types empty envelope

00:10:34,089 --> 00:10:38,529
and closed envelope an empty envelope

00:10:35,230 --> 00:10:40,600
doesn't ever have any letter in it and a

00:10:38,529 --> 00:10:42,669
closed envelope always has a lot organs

00:10:40,600 --> 00:10:46,119
and we change the code a little bit so

00:10:42,669 --> 00:10:48,730
empty envelope wraps a letter in the

00:10:46,119 --> 00:10:51,549
envelope and returns us a closed

00:10:48,730 --> 00:10:54,100
envelope and even importantly this

00:10:51,549 --> 00:10:57,039
method is only defined on rough envelope

00:10:54,100 --> 00:10:58,689
and consumes sorry on empty envelope and

00:10:57,039 --> 00:11:00,220
consumes the empty envelope

00:10:58,689 --> 00:11:02,859
so once we've called this on empty

00:11:00,220 --> 00:11:05,829
envelope these envelope is not available

00:11:02,859 --> 00:11:09,119
to us anymore this is done by not

00:11:05,829 --> 00:11:13,569
defining self as a reference of course

00:11:09,119 --> 00:11:15,759
secondly when we hand the letter to the

00:11:13,569 --> 00:11:17,499
driver we want to make sure we hand the

00:11:15,759 --> 00:11:19,780
closed one the one completed with the

00:11:17,499 --> 00:11:22,240
letter inside and so instead of just x

00:11:19,780 --> 00:11:23,800
any envelope we expect a close one and

00:11:22,240 --> 00:11:25,480
this enforces the correct order of

00:11:23,800 --> 00:11:27,610
operations we put letter into the

00:11:25,480 --> 00:11:30,130
envelope and then we give the closed

00:11:27,610 --> 00:11:31,870
envelope to the driver of course this

00:11:30,130 --> 00:11:35,590
requires a bit of a change to this as

00:11:31,870 --> 00:11:38,980
well so if you look at the main for this

00:11:35,590 --> 00:11:40,600
we need to do at all changes again the

00:11:38,980 --> 00:11:44,080
by percent envelope looks exactly the

00:11:40,600 --> 00:11:46,720
same but when we wrap the letter inside

00:11:44,080 --> 00:11:51,400
of the envelope we give ownership away

00:11:46,720 --> 00:11:52,330
and when we try to give the letter to

00:11:51,400 --> 00:11:55,510
the driver

00:11:52,330 --> 00:11:57,430
we again give ownership and we should

00:11:55,510 --> 00:12:00,040
make sure that we do the right thing so

00:11:57,430 --> 00:12:01,090
if we try this and this envelope and you

00:12:00,040 --> 00:12:04,150
may have noticed the problem already

00:12:01,090 --> 00:12:06,100
this is gonna not compile because we

00:12:04,150 --> 00:12:08,020
tried to give the empty envelope and

00:12:06,100 --> 00:12:10,030
rust is preventing us from doing this

00:12:08,020 --> 00:12:12,160
and helpful fully is actually saying I

00:12:10,030 --> 00:12:13,630
expected an envelope completed with the

00:12:12,160 --> 00:12:15,520
letter inside I got an empty envelope

00:12:13,630 --> 00:12:17,710
and also we mail it away maybe we want

00:12:15,520 --> 00:12:19,030
to use wrap which is really cool because

00:12:17,710 --> 00:12:21,130
it's pointing us in the right direction

00:12:19,030 --> 00:12:23,440
in terms of documentation we don't need

00:12:21,130 --> 00:12:25,839
to document this explicitly the compiler

00:12:23,440 --> 00:12:28,530
is going to tell us where to look and so

00:12:25,839 --> 00:12:31,360
of course you just change it a bit and

00:12:28,530 --> 00:12:33,820
try to put the closed envelope and give

00:12:31,360 --> 00:12:36,010
it to the driver hey this is this good

00:12:33,820 --> 00:12:40,780
but again we are trying to put the same

00:12:36,010 --> 00:12:43,050
to put two different letters in the same

00:12:40,780 --> 00:12:45,280
envelope but with the changes we made

00:12:43,050 --> 00:12:47,440
Russy is gonna prevent us from doing so

00:12:45,280 --> 00:12:48,820
again and here it's helping us again

00:12:47,440 --> 00:12:49,960
enforcing that we are following the

00:12:48,820 --> 00:12:53,589
right steps and we are not doing

00:12:49,960 --> 00:12:56,350
anything that sounds sensible so two is

00:12:53,589 --> 00:12:59,140
done three how we make sure that we

00:12:56,350 --> 00:13:03,880
don't forget how to tell the driver we

00:12:59,140 --> 00:13:06,339
are done well I say we give the letter

00:13:03,880 --> 00:13:08,680
to the driver and then we just focus and

00:13:06,339 --> 00:13:10,690
forget about this of course is not gonna

00:13:08,680 --> 00:13:12,760
result in the letter being completely

00:13:10,690 --> 00:13:15,100
correctly delivered but of course we can

00:13:12,760 --> 00:13:18,250
just implement drop for the handle and

00:13:15,100 --> 00:13:20,830
make sure that every time the handle

00:13:18,250 --> 00:13:22,120
goes out of scope we are making sure to

00:13:20,830 --> 00:13:26,380
release all resources and send

00:13:22,120 --> 00:13:29,800
everything we had in the buffer and when

00:13:26,380 --> 00:13:33,110
lorries top tier whatever this gives the

00:13:29,800 --> 00:13:37,220
information to the driver to just leave

00:13:33,110 --> 00:13:40,190
so we fix this as well and what we fix

00:13:37,220 --> 00:13:42,080
here is three things we are ensured that

00:13:40,190 --> 00:13:45,020
some things can only be done once and

00:13:42,080 --> 00:13:47,120
this happens a lot in AP is or at least

00:13:45,020 --> 00:13:49,610
only once in a certain context for

00:13:47,120 --> 00:13:51,350
example when a shared HTTP connection we

00:13:49,610 --> 00:13:53,690
made sure that we are following the

00:13:51,350 --> 00:13:56,600
correct order of operations when we are

00:13:53,690 --> 00:13:59,600
doing something and we guaranteed that

00:13:56,600 --> 00:14:01,730
we drop a resource when we don't need it

00:13:59,600 --> 00:14:06,770
anymore even if you forget about doing

00:14:01,730 --> 00:14:09,770
explicitly so many missions I forget

00:14:06,770 --> 00:14:12,800
about sometimes sometimes so of course

00:14:09,770 --> 00:14:14,870
the trouble here is that when you try to

00:14:12,800 --> 00:14:16,490
enforce correct ordering if you have

00:14:14,870 --> 00:14:19,070
multiple ways from getting to a - beans

00:14:16,490 --> 00:14:21,020
in terms of the steps you need to do the

00:14:19,070 --> 00:14:22,520
number of states you may go have to go

00:14:21,020 --> 00:14:24,620
through is a lot and you may end up with

00:14:22,520 --> 00:14:26,390
a lot of different stocks representing

00:14:24,620 --> 00:14:28,310
all the states of course there's a bit

00:14:26,390 --> 00:14:31,160
of a trade-off sometimes it's useful to

00:14:28,310 --> 00:14:32,720
just have a lot of strikes and force the

00:14:31,160 --> 00:14:34,880
API precisely and sometimes it's just

00:14:32,720 --> 00:14:37,730
better to put in a little bit of runtime

00:14:34,880 --> 00:14:40,970
checks and better documentation so two

00:14:37,730 --> 00:14:42,410
really quick examples on how this works

00:14:40,970 --> 00:14:45,050
in practice let's say we are writing an

00:14:42,410 --> 00:14:48,140
HTTP response on a connection we have

00:14:45,050 --> 00:14:49,550
the response and we represent two states

00:14:48,140 --> 00:14:51,980
writing the headers and writing the body

00:14:49,550 --> 00:14:54,020
if you know HTTP once you've written the

00:14:51,980 --> 00:14:55,280
address you're not allowed to write more

00:14:54,020 --> 00:14:56,690
so when you started with writing the

00:14:55,280 --> 00:14:58,640
body you're not allowed to write more

00:14:56,690 --> 00:15:01,310
others if you have already sender that's

00:14:58,640 --> 00:15:04,640
a way so we can get started on that

00:15:01,310 --> 00:15:06,320
starts writing the address and then we

00:15:04,640 --> 00:15:08,390
get an object that only allows us to

00:15:06,320 --> 00:15:11,180
write errors once we are done we call

00:15:08,390 --> 00:15:13,400
body which consumes this current object

00:15:11,180 --> 00:15:17,420
and gives us another thing which is the

00:15:13,400 --> 00:15:19,370
way to write the body we write as many

00:15:17,420 --> 00:15:22,100
chunks of the body as we want and then

00:15:19,370 --> 00:15:23,840
we say we are done and of course if we

00:15:22,100 --> 00:15:26,540
forget to say we are done we have

00:15:23,840 --> 00:15:30,350
dropped setting us and flushing this

00:15:26,540 --> 00:15:32,480
through the connection so I have another

00:15:30,350 --> 00:15:37,750
examples but we are 50 minutes so I'm

00:15:32,480 --> 00:15:43,570
gonna skip over this and just say that

00:15:37,750 --> 00:15:47,059
the point of this is Russ gives us a few

00:15:43,570 --> 00:15:49,009
really good tools to make API is clear

00:15:47,059 --> 00:15:51,529
and sometimes even self-documenting as

00:15:49,009 --> 00:15:53,449
we see so we can leverage these at

00:15:51,529 --> 00:15:56,319
various levels IRAs management but also

00:15:53,449 --> 00:15:59,560
at higher levels at API design so

00:15:56,319 --> 00:16:08,380
there's my top thank you very much

00:15:59,560 --> 00:16:08,380

YouTube URL: https://www.youtube.com/watch?v=3Q2hQfYW-XM


