Title: RustFest Zürich 2017 - Impractical Macros by Alex Burka
Publication date: 2017-10-21
Playlist: RustFest Zürich 2017
Description: 
	A whirlwind tour through a (macro_rules 1.0!) macro that interprets everyone’s favorite Turing tarpit, Brainfuck, completely at compile time. I’ll highlight various components such as number encoding, arithmetic, input/output and explain how they work.

This is not a macro tutorial. I’ll cover a few techniques that you might possibly be able to use in real code, such as how to set up a recursive macro with an accumulator, but I’ll be breezing through them to get to the fun stuff, like memory zippers and “Zermelo numbers” (a term I may have invented).

About Alex Burka:
Alex is a robotics graduate student at the University of Pennsylvania. He got into Rust by writing his research software (a hardware controller and web interface for a sensor suite), and continues to spend too much of his free time writing macros.
Captions: 
	00:00:11,550 --> 00:00:16,180
okay I'm Alex and so we just heard about

00:00:15,010 --> 00:00:17,860
the way

00:00:16,180 --> 00:00:19,510
right macros that you would want to use

00:00:17,860 --> 00:00:22,540
and so I'm going to talk about macros

00:00:19,510 --> 00:00:24,430
that you would never want to use so I

00:00:22,540 --> 00:00:26,830
figured I should have a cat on my slide

00:00:24,430 --> 00:00:28,810
but this would be a more relevant kind

00:00:26,830 --> 00:00:32,230
of cat you might have seen this April

00:00:28,810 --> 00:00:34,480
Fool's joke but really it's this cat

00:00:32,230 --> 00:00:37,600
program so I just want a quick show of

00:00:34,480 --> 00:00:39,370
fans who can read this program okay

00:00:37,600 --> 00:00:41,309
great so most of you I'm going to be

00:00:39,370 --> 00:00:44,800
introducing to brainfuck so that's great

00:00:41,309 --> 00:00:47,350
and by the way I hope you for this talk

00:00:44,800 --> 00:00:48,790
you don't consider brainfuck to be

00:00:47,350 --> 00:00:51,820
profanity because I'll be saying it a

00:00:48,790 --> 00:00:53,380
few times ok so we just have a whole

00:00:51,820 --> 00:00:56,670
talk about this but I'll go through real

00:00:53,380 --> 00:00:59,380
quickly what I think of as macros so

00:00:56,670 --> 00:01:01,989
what if I told you I have a new language

00:00:59,380 --> 00:01:04,360
it's pure functional language weak

00:01:01,989 --> 00:01:07,780
typing oh my Connick it's mostly pine or

00:01:04,360 --> 00:01:11,500
matching okay but this language is rest

00:01:07,780 --> 00:01:13,119
macro rules so a macro is just a

00:01:11,500 --> 00:01:16,930
function except it runs at compile time

00:01:13,119 --> 00:01:19,270
and it basically processes code into

00:01:16,930 --> 00:01:22,299
other code the inputs and outputs are

00:01:19,270 --> 00:01:25,690
both rest syntax and the output has to

00:01:22,299 --> 00:01:27,909
be a complete part of rest syntax like a

00:01:25,690 --> 00:01:31,920
complete function or item or expression

00:01:27,909 --> 00:01:35,590
or whatever and so when you can't

00:01:31,920 --> 00:01:39,040
produce your complete element right away

00:01:35,590 --> 00:01:40,570
you have to write a recursive macro so

00:01:39,040 --> 00:01:42,610
then you can get around that restriction

00:01:40,570 --> 00:01:45,040
by like passing some incomplete results

00:01:42,610 --> 00:01:46,860
as arguments to another macro do some

00:01:45,040 --> 00:01:49,030
we're processing accumulate your

00:01:46,860 --> 00:01:52,299
permutations or whatever and then I put

00:01:49,030 --> 00:01:54,759
something at the end so these end up

00:01:52,299 --> 00:01:58,049
being called munchers often because they

00:01:54,759 --> 00:02:00,369
tend to munch one token at a time and

00:01:58,049 --> 00:02:03,100
specifically I'll be talking about VF

00:02:00,369 --> 00:02:05,350
which munches brain flex syntax runs it

00:02:03,100 --> 00:02:07,720
at compile time and then hence the

00:02:05,350 --> 00:02:11,459
output of the brain flow program to rest

00:02:07,720 --> 00:02:14,470
C to compile so here's a little preview

00:02:11,459 --> 00:02:17,250
here's a call to the macro and here's a

00:02:14,470 --> 00:02:19,959
brain v program and here is some input

00:02:17,250 --> 00:02:21,160
which kind of looks likes numbers and

00:02:19,959 --> 00:02:23,769
there's something weird about it but

00:02:21,160 --> 00:02:25,389
we'll get to that later and after the

00:02:23,769 --> 00:02:28,480
macro is expanded this is what it looks

00:02:25,389 --> 00:02:30,100
like so it's basically a struct literal

00:02:28,480 --> 00:02:31,810
and the only computation

00:02:30,100 --> 00:02:33,850
this left to do is adding up one plus

00:02:31,810 --> 00:02:39,040
one plus one plus one plus one and then

00:02:33,850 --> 00:02:40,810
it prints this okay so that was a

00:02:39,040 --> 00:02:41,560
preview what is this language I'm

00:02:40,810 --> 00:02:44,590
talking about

00:02:41,560 --> 00:02:47,350
so brainfuck is what's called a Turing

00:02:44,590 --> 00:02:49,870
tarpit which means it's Turing complete

00:02:47,350 --> 00:02:52,090
you can compute any computable function

00:02:49,870 --> 00:02:55,180
but it's really annoying to compute any

00:02:52,090 --> 00:02:57,220
computable functions because brainfuck

00:02:55,180 --> 00:03:00,970
is basically an assembly language with

00:02:57,220 --> 00:03:02,530
eight instructions so I'm gonna go

00:03:00,970 --> 00:03:05,860
through those instructions one by one

00:03:02,530 --> 00:03:07,300
with a little cartoon and some rest code

00:03:05,860 --> 00:03:10,380
to illustrate what I'm talking about

00:03:07,300 --> 00:03:14,650
so the brain struck abstract machine is

00:03:10,380 --> 00:03:17,110
a big array of bytes of you eights and a

00:03:14,650 --> 00:03:18,910
pointer to the current cell so here's a

00:03:17,110 --> 00:03:23,710
drawing of themselves and a pointer to

00:03:18,910 --> 00:03:26,530
the current cell so the first type of

00:03:23,710 --> 00:03:29,260
instructions you can do are shifting the

00:03:26,530 --> 00:03:32,050
pointer back and forth shift right shift

00:03:29,260 --> 00:03:34,510
left and those are the instructions our

00:03:32,050 --> 00:03:36,280
angle brackets um so in breasts you

00:03:34,510 --> 00:03:38,500
would just be you know changing this

00:03:36,280 --> 00:03:40,600
index you can also increment and

00:03:38,500 --> 00:03:46,000
decrement the value in the current cell

00:03:40,600 --> 00:03:48,970
with the plus and minus instructions you

00:03:46,000 --> 00:03:51,790
can do input and output so here is a STD

00:03:48,970 --> 00:03:55,000
in and here is STD out and so you can do

00:03:51,790 --> 00:03:58,720
input one byte at a time

00:03:55,000 --> 00:04:02,800
so usually ask you but my implementation

00:03:58,720 --> 00:04:04,780
does support Unicode if you want and the

00:04:02,800 --> 00:04:06,160
last two instructions are actually the

00:04:04,780 --> 00:04:08,350
most interesting because they're the

00:04:06,160 --> 00:04:10,660
only control flow instructions the only

00:04:08,350 --> 00:04:13,990
control so you can do is loop and it's

00:04:10,660 --> 00:04:16,750
basically a while loop with only one

00:04:13,990 --> 00:04:18,460
condition available so the code or the

00:04:16,750 --> 00:04:20,710
instructions within the square brackets

00:04:18,460 --> 00:04:22,630
in your brain flight program will repeat

00:04:20,710 --> 00:04:27,760
as long as the current cell doesn't drop

00:04:22,630 --> 00:04:31,660
to zero cool so how are we going to

00:04:27,760 --> 00:04:32,890
implement this in a macro so I don't

00:04:31,660 --> 00:04:34,930
have time to go through the whole thing

00:04:32,890 --> 00:04:37,000
but I'm gonna go through a few specific

00:04:34,930 --> 00:04:40,930
parts of the macro and techniques we

00:04:37,000 --> 00:04:42,010
used to implement this so the first

00:04:40,930 --> 00:04:43,870
question is what are we going to do

00:04:42,010 --> 00:04:46,750
about integers we just saw that

00:04:43,870 --> 00:04:50,020
that too full indexing and succession

00:04:46,750 --> 00:04:51,580
macro that does some special cases of

00:04:50,020 --> 00:04:54,100
addition because macros don't know what

00:04:51,580 --> 00:04:55,780
integers are basically the data

00:04:54,100 --> 00:04:59,950
structure they have that we can use is

00:04:55,780 --> 00:05:03,370
tokens and lists of tokens so that's how

00:04:59,950 --> 00:05:07,420
I'm going to define integers in an

00:05:03,370 --> 00:05:11,530
integer n is a list square bracketed

00:05:07,420 --> 00:05:14,230
list of n times empty parentheses so

00:05:11,530 --> 00:05:17,110
here's one token and a lit and a number

00:05:14,230 --> 00:05:20,890
n is a list of n tokens and so this is

00:05:17,110 --> 00:05:23,710
kind of a recursive definition oh by the

00:05:20,890 --> 00:05:28,210
way this is Zermelo from the F set

00:05:23,710 --> 00:05:30,160
theory this bunch of sets so because

00:05:28,210 --> 00:05:32,080
this is a recursive definition I can

00:05:30,160 --> 00:05:34,900
write it as a recursive background so if

00:05:32,080 --> 00:05:36,670
my input is a list of n tokens and I

00:05:34,900 --> 00:05:39,370
want to increment I just add one more

00:05:36,670 --> 00:05:41,380
token and if I want to decrement let's

00:05:39,370 --> 00:05:43,570
say I have at least one token and then I

00:05:41,380 --> 00:05:45,730
have some more and I just toss about the

00:05:43,570 --> 00:05:49,330
first one and so I've decremented my

00:05:45,730 --> 00:05:50,920
numbers so just a quick example here's

00:05:49,330 --> 00:05:53,680
that machine again I put numbers in the

00:05:50,920 --> 00:05:57,070
cells and the current value is 2 so

00:05:53,680 --> 00:06:00,460
that's 2 tokens we can increment we get

00:05:57,070 --> 00:06:04,360
3 tokens we could decrement and it's

00:06:00,460 --> 00:06:06,970
just a list of two tokens okay a little

00:06:04,360 --> 00:06:10,180
bit more complex is representing the

00:06:06,970 --> 00:06:12,100
memory this array of cells because I

00:06:10,180 --> 00:06:13,960
really need an array but macros don't

00:06:12,100 --> 00:06:15,640
have arrays you can't index into a list

00:06:13,960 --> 00:06:19,690
you can only like look at what's at the

00:06:15,640 --> 00:06:20,770
beginning of the list like this so we're

00:06:19,690 --> 00:06:22,660
going to use a really cool data

00:06:20,770 --> 00:06:24,250
structure called a zipper where you can

00:06:22,660 --> 00:06:26,110
represent a list and the current

00:06:24,250 --> 00:06:27,040
position in a list with no indexing at

00:06:26,110 --> 00:06:29,890
all

00:06:27,040 --> 00:06:32,500
and we do that by storing three things

00:06:29,890 --> 00:06:34,210
we store the current value so two we

00:06:32,500 --> 00:06:35,880
store the values to the right three and

00:06:34,210 --> 00:06:39,850
four and we store the values to the left

00:06:35,880 --> 00:06:42,340
zero and one and then when we want to

00:06:39,850 --> 00:06:46,120
move that we just adjust those three

00:06:42,340 --> 00:06:47,590
different things so here here's what

00:06:46,120 --> 00:06:49,960
that looks like written down as a macro

00:06:47,590 --> 00:06:52,210
rule so it's a little harder to read but

00:06:49,960 --> 00:06:54,670
you can see in in this set of square

00:06:52,210 --> 00:06:57,660
brackets I'm taking like the first

00:06:54,670 --> 00:06:59,790
element and the rest

00:06:57,660 --> 00:07:01,290
so this is the elements to the left the

00:06:59,790 --> 00:07:04,170
current element and the elements to the

00:07:01,290 --> 00:07:06,890
right so for example the current element

00:07:04,170 --> 00:07:10,080
is two elements to the left one and zero

00:07:06,890 --> 00:07:12,210
elements to the right three and four you

00:07:10,080 --> 00:07:15,420
might notice that these are stored in

00:07:12,210 --> 00:07:19,110
reverse order so let's see what happens

00:07:15,420 --> 00:07:21,180
if we move to the left now the current

00:07:19,110 --> 00:07:22,650
element is one there's only one element

00:07:21,180 --> 00:07:25,560
to the left and these three to the right

00:07:22,650 --> 00:07:27,720
if we move back to the right and again

00:07:25,560 --> 00:07:30,480
so if you look closely the only thing I

00:07:27,720 --> 00:07:32,040
need to do because these were stored in

00:07:30,480 --> 00:07:33,840
reverse order is I only need to touch

00:07:32,040 --> 00:07:35,700
the beginning of the two lists so we can

00:07:33,840 --> 00:07:42,060
do that in a macro that's good no

00:07:35,700 --> 00:07:47,400
indexing yeah okay so we have integers

00:07:42,060 --> 00:07:50,990
we can have memory full of integers next

00:07:47,400 --> 00:07:54,150
big question is how do we do those loops

00:07:50,990 --> 00:07:58,110
so I'll review the semantics of looping

00:07:54,150 --> 00:08:01,200
in brainfuck if we get to an opening

00:07:58,110 --> 00:08:02,760
square bracket if the current if the

00:08:01,200 --> 00:08:06,060
pointer is pointing at a cell was

00:08:02,760 --> 00:08:07,530
nonzero we go start executing the loop

00:08:06,060 --> 00:08:09,990
otherwise you just skip the whole thing

00:08:07,530 --> 00:08:12,240
and if we get to a closing bracket if

00:08:09,990 --> 00:08:13,440
the current memory cell is nonzero you

00:08:12,240 --> 00:08:15,870
go back to the beginning of the loop

00:08:13,440 --> 00:08:18,330
otherwise we're done with the loop so

00:08:15,870 --> 00:08:21,510
the best data structure that I came up

00:08:18,330 --> 00:08:24,600
with to implement this is two stacks so

00:08:21,510 --> 00:08:26,520
one because the loops come we nested we

00:08:24,600 --> 00:08:31,380
need a stack of the currently executing

00:08:26,520 --> 00:08:34,710
loop bodies but when I'm executing a

00:08:31,380 --> 00:08:36,570
loop I have this variable or really just

00:08:34,710 --> 00:08:38,280
a macro argument that's keeping track of

00:08:36,570 --> 00:08:40,169
the rest of the program to execute and

00:08:38,280 --> 00:08:43,229
during the loop I just set that to the

00:08:40,169 --> 00:08:45,720
body of the loop so when we exit an

00:08:43,229 --> 00:08:47,910
inner loop we need to remember the code

00:08:45,720 --> 00:08:51,900
to execute after that so that's what I

00:08:47,910 --> 00:08:53,640
call the tail stack by the way the

00:08:51,900 --> 00:08:55,850
parsing is not very hard because macros

00:08:53,640 --> 00:08:58,220
already know how to match brackets

00:08:55,850 --> 00:09:00,660
someone has written a brain-fuck

00:08:58,220 --> 00:09:04,260
compiler in rust macros it doesn't do

00:09:00,660 --> 00:09:06,720
this and it's called Luke I'll have a

00:09:04,260 --> 00:09:08,700
link to it later okay so I'm going to

00:09:06,720 --> 00:09:09,990
try to illustrate this with the two

00:09:08,700 --> 00:09:12,990
stacks

00:09:09,990 --> 00:09:14,550
so here's my machine again and I'm

00:09:12,990 --> 00:09:16,950
showing three things the rest of the

00:09:14,550 --> 00:09:18,630
program that's left to go the loop stack

00:09:16,950 --> 00:09:22,050
and the tail stack so we're just going

00:09:18,630 --> 00:09:24,750
to run through this program okay let's

00:09:22,050 --> 00:09:27,060
go first it's pretty easy we're going to

00:09:24,750 --> 00:09:28,800
increment the current cell and notice

00:09:27,060 --> 00:09:33,089
when and when when an instruction

00:09:28,800 --> 00:09:36,779
executes it gets popped off of the list

00:09:33,089 --> 00:09:38,610
of instructions that are left so now we

00:09:36,779 --> 00:09:40,950
get to the beginning of the outer loop

00:09:38,610 --> 00:09:44,040
and the current cell is not zero so we

00:09:40,950 --> 00:09:45,630
push the loop body we push the tails of

00:09:44,040 --> 00:09:49,200
what's left of the program after the

00:09:45,630 --> 00:09:51,560
loop and then the future instructions to

00:09:49,200 --> 00:09:55,140
execute just become the body of the loop

00:09:51,560 --> 00:09:58,140
okay now there's another loop and if you

00:09:55,140 --> 00:10:00,300
know brain-fuck you recognize this loop

00:09:58,140 --> 00:10:03,270
with just a - in it it's going to zero

00:10:00,300 --> 00:10:05,550
out the cell okay so again I got an

00:10:03,270 --> 00:10:07,170
outer loop and I'm sorry an inner loop

00:10:05,550 --> 00:10:10,200
and the current cell is not zero so we

00:10:07,170 --> 00:10:12,330
push the loop body we push what's after

00:10:10,200 --> 00:10:15,630
the loop body and the program is just

00:10:12,330 --> 00:10:19,470
this - so that decrement the cell and

00:10:15,630 --> 00:10:21,270
now we're at the closing bracket and the

00:10:19,470 --> 00:10:25,440
current cell is still nonzero so nothing

00:10:21,270 --> 00:10:27,589
happens here but the future program to

00:10:25,440 --> 00:10:31,410
execute is the body of the loop again

00:10:27,589 --> 00:10:33,390
so it decrements the cell again and now

00:10:31,410 --> 00:10:35,730
when we get to the end of the loop the

00:10:33,390 --> 00:10:38,579
current cell is zero so we're going to

00:10:35,730 --> 00:10:39,810
pop those two entries from the top of

00:10:38,579 --> 00:10:43,860
the stacks because we're done with the

00:10:39,810 --> 00:10:46,200
loop for now and then so the future

00:10:43,860 --> 00:10:47,820
program comes from remembered from the

00:10:46,200 --> 00:10:52,200
tail stack and it becomes these two

00:10:47,820 --> 00:10:55,860
instructions here so we move increment

00:10:52,200 --> 00:10:57,360
this cell and we're at the end of the

00:10:55,860 --> 00:11:00,209
outer loop and the current cell is

00:10:57,360 --> 00:11:02,550
nonzero so we take the loop body that's

00:11:00,209 --> 00:11:04,440
on the top here we peek this stack and

00:11:02,550 --> 00:11:07,560
put it in the future program

00:11:04,440 --> 00:11:10,620
instructions and this is going to go a

00:11:07,560 --> 00:11:13,140
little faster it decrements again and it

00:11:10,620 --> 00:11:15,149
moves over and this ends up being an

00:11:13,140 --> 00:11:16,709
infinite loop so it increments this cell

00:11:15,149 --> 00:11:18,570
and then it's going to clear it out and

00:11:16,709 --> 00:11:22,010
move over and then we would run out of

00:11:18,570 --> 00:11:23,699
space so instead we're going to look at

00:11:22,010 --> 00:11:28,919
some macro

00:11:23,699 --> 00:11:30,809
that actually does this alright ready

00:11:28,919 --> 00:11:33,269
take a deep breath to see some macro

00:11:30,809 --> 00:11:38,249
code so there's four cases actually

00:11:33,269 --> 00:11:39,660
there's six but I'm showing four so the

00:11:38,249 --> 00:11:40,799
first case is when we get to the

00:11:39,660 --> 00:11:42,749
beginning of the loop and the current

00:11:40,799 --> 00:11:45,299
cell is zero because this is the easiest

00:11:42,749 --> 00:11:48,809
case we can just skip the loop so here's

00:11:45,299 --> 00:11:52,290
some code at the top you can see the

00:11:48,809 --> 00:11:54,119
inputs to the macro and the bottom it

00:11:52,290 --> 00:11:56,879
just calls itself again with with new

00:11:54,119 --> 00:12:00,119
arguments I'm gonna have some color

00:11:56,879 --> 00:12:02,669
coding okay so this is the current

00:12:00,119 --> 00:12:05,069
instruction so the current instruction

00:12:02,669 --> 00:12:09,720
at the beginning is the entire loop in

00:12:05,069 --> 00:12:11,459
the brackets here's the state of the

00:12:09,720 --> 00:12:13,079
machine so here's that zipper I talked

00:12:11,459 --> 00:12:17,100
about here's the current cell elements

00:12:13,079 --> 00:12:19,139
to the left elements to the right and

00:12:17,100 --> 00:12:22,199
this is the rest of the program that's

00:12:19,139 --> 00:12:24,899
left to be executed and the loop stack

00:12:22,199 --> 00:12:26,549
and the tail stack and so you'll notice

00:12:24,899 --> 00:12:30,239
that all of these are just lists of

00:12:26,549 --> 00:12:31,679
tokens and so it's to skip the loop we

00:12:30,239 --> 00:12:34,049
take the code that was in the loop and

00:12:31,679 --> 00:12:36,239
we throw it away and the next

00:12:34,049 --> 00:12:39,839
instruction to execute we take from the

00:12:36,239 --> 00:12:41,730
from the program list and then the

00:12:39,839 --> 00:12:43,559
instructions left after that are the

00:12:41,730 --> 00:12:46,589
rest of the program from before and

00:12:43,559 --> 00:12:48,299
everything else is unchanged for a

00:12:46,589 --> 00:12:50,850
little bit more complexity what happens

00:12:48,299 --> 00:12:55,910
when the current cell is not zero and we

00:12:50,850 --> 00:13:01,559
need to so we need to enter the loop

00:12:55,910 --> 00:13:03,329
code and more colors same colors ok so

00:13:01,559 --> 00:13:04,739
again the current instruction is the

00:13:03,329 --> 00:13:06,329
entire loop but we have to deconstruct

00:13:04,739 --> 00:13:08,669
it into the beginning of the loop and

00:13:06,329 --> 00:13:10,529
the rest of the loop because the next

00:13:08,669 --> 00:13:12,480
instruction that the Machine executes is

00:13:10,529 --> 00:13:15,269
the first one from the body of the loop

00:13:12,480 --> 00:13:17,910
and the future instructions are the tail

00:13:15,269 --> 00:13:21,480
of the loop plus this special token to

00:13:17,910 --> 00:13:23,789
mark the end of a stream and then we

00:13:21,480 --> 00:13:25,739
take our two stacks for the loop stack

00:13:23,789 --> 00:13:28,709
we're going to push the loop body on the

00:13:25,739 --> 00:13:32,009
beginning and the tail stack we push the

00:13:28,709 --> 00:13:33,629
rest of the program that has that we're

00:13:32,009 --> 00:13:35,929
not executing anymore because we entered

00:13:33,629 --> 00:13:35,929
the loop

00:13:37,140 --> 00:13:43,620
okay that's two cases how about closing

00:13:40,500 --> 00:13:45,120
brackets the easier case is when we

00:13:43,620 --> 00:13:48,950
close the brackets and the current cell

00:13:45,120 --> 00:13:48,950
is zero so the loop is over

00:13:50,209 --> 00:13:57,480
looks colors so the current instruction

00:13:54,300 --> 00:14:00,120
now is this magic end of code sentinel

00:13:57,480 --> 00:14:03,750
value and the current cell the memory in

00:14:00,120 --> 00:14:05,040
the current cell is zero so we take our

00:14:03,750 --> 00:14:07,529
two stacks and we're going to pop off

00:14:05,040 --> 00:14:10,769
the entry from the top so we pop the

00:14:07,529 --> 00:14:12,750
loop stack loops head and throw it away

00:14:10,769 --> 00:14:15,839
the rest and the loop stack is the rest

00:14:12,750 --> 00:14:17,579
of it we pop the tail stack so you see

00:14:15,839 --> 00:14:20,310
the rest of the tails becomes a tail

00:14:17,579 --> 00:14:22,410
stack and where this is the code that we

00:14:20,310 --> 00:14:24,930
remembered to run after the loop so the

00:14:22,410 --> 00:14:26,790
next instruction is the first one from

00:14:24,930 --> 00:14:28,490
here and the rest of them are just the

00:14:26,790 --> 00:14:32,940
rest of it from here

00:14:28,490 --> 00:14:34,649
lastly when the current cell is not zero

00:14:32,940 --> 00:14:37,380
we're going to restart the loop this is

00:14:34,649 --> 00:14:39,209
actually a little bit easier because we

00:14:37,380 --> 00:14:41,430
don't have to touch the tail stack and

00:14:39,209 --> 00:14:43,470
all we do is we peek at the first

00:14:41,430 --> 00:14:46,430
element of the loop stack so it's a peek

00:14:43,470 --> 00:14:48,930
not a pop the stack is unchanged

00:14:46,430 --> 00:14:51,000
but the next instruction to execute is

00:14:48,930 --> 00:14:52,949
the first one from the top of the loop

00:14:51,000 --> 00:14:59,760
stack and the rest of it is the rest of

00:14:52,949 --> 00:15:02,550
the loop body so this is a we just went

00:14:59,760 --> 00:15:06,750
through a lightly edited part of an

00:15:02,550 --> 00:15:09,720
important part of the macro so that was

00:15:06,750 --> 00:15:15,740
pretty cool I bet you're ready to see a

00:15:09,720 --> 00:15:15,740
demo so hopefully this works

00:15:18,620 --> 00:15:28,700
so here's some code and we're defining a

00:15:24,510 --> 00:15:31,830
Const called machine of type machine and

00:15:28,700 --> 00:15:34,050
the whole value of the constant is going

00:15:31,830 --> 00:15:38,700
to be constructed by the macro which has

00:15:34,050 --> 00:15:41,550
two inputs first is the brain fed

00:15:38,700 --> 00:15:44,640
program so this is actually basically

00:15:41,550 --> 00:15:48,480
the normal hello world program but I

00:15:44,640 --> 00:15:52,200
modified it to do something and then the

00:15:48,480 --> 00:15:54,480
second input is a bunch of numbers

00:15:52,200 --> 00:15:58,410
I mentioned that macros don't understand

00:15:54,480 --> 00:16:00,450
numbers and so the BF macro actually has

00:15:58,410 --> 00:16:01,950
a parser for decimal numbers and you

00:16:00,450 --> 00:16:04,440
just have to have every digit as a

00:16:01,950 --> 00:16:08,880
separate token and then it works great

00:16:04,440 --> 00:16:11,280
oh and by the way we need a pretty high

00:16:08,880 --> 00:16:12,660
recursion limit for this macro it

00:16:11,280 --> 00:16:14,910
doesn't have to be quite this high but

00:16:12,660 --> 00:16:22,250
it doesn't work with the default okay so

00:16:14,910 --> 00:16:25,430
if we run this code it's pretty fast and

00:16:22,250 --> 00:16:25,430
it works

00:16:25,440 --> 00:16:29,889
[Applause]

00:16:30,800 --> 00:16:37,350
Thanks so you see this is the output

00:16:34,680 --> 00:16:39,149
that got printed and this is the

00:16:37,350 --> 00:16:43,310
basically the state of the memory cells

00:16:39,149 --> 00:16:46,769
that's left over thank you

00:16:43,310 --> 00:16:50,759
okay so I just wanted to mention real

00:16:46,769 --> 00:16:52,470
quick that there's a long tradition of

00:16:50,759 --> 00:16:55,649
implementing brain suck in ridiculous

00:16:52,470 --> 00:16:57,569
environments like Luke or Hodor that I

00:16:55,649 --> 00:17:00,300
mentioned before is a brain fed compiler

00:16:57,569 --> 00:17:01,829
from brain psych syntax to rest syntax

00:17:00,300 --> 00:17:06,959
so it doesn't run a compile time but it

00:17:01,829 --> 00:17:09,270
compiles the brain s de Leffler

00:17:06,959 --> 00:17:11,039
made this insanity and the type system

00:17:09,270 --> 00:17:12,689
implementing small which is like

00:17:11,039 --> 00:17:15,240
brain track with fools instead of you

00:17:12,689 --> 00:17:17,220
eighths someone has implemented it in

00:17:15,240 --> 00:17:21,720
vim someone has implemented a full

00:17:17,220 --> 00:17:23,130
Turing machine in PowerPoint and every

00:17:21,720 --> 00:17:25,650
time I go to finish this slide there's

00:17:23,130 --> 00:17:29,340
have been another one so you can you can

00:17:25,650 --> 00:17:32,400
look these up they're telling me I have

00:17:29,340 --> 00:17:34,020
exceeded my recursion limit so the code

00:17:32,400 --> 00:17:36,360
I talked about in the talk is here

00:17:34,020 --> 00:17:39,690
although I should probably clean it up

00:17:36,360 --> 00:17:42,240
more but you can find it online and I'll

00:17:39,690 --> 00:17:45,169
invite questions oh that's old code

00:17:42,240 --> 00:17:45,169
questions

00:17:49,970 --> 00:17:52,030

YouTube URL: https://www.youtube.com/watch?v=ApOUBBOvZDo


