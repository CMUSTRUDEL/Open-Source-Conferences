Title: RustFest Zürich 2017 - A Rust-based Runtime for the Internet of Things by Niklas Adolfsson
Publication date: 2017-10-21
Playlist: RustFest Zürich 2017
Description: 
	In this talk, I’ll share my experience evaluating Rust as a basis for building Internet of Things (IoT) applications down to the bare metal.

In principle, Rust’s combination of memory safety and low runtime overhead makes it an ideal candidate for building IoT applications which currently are almost the exclusive domain of C and C++. As part of my master’s studies, we ported Tock, an embedded operating system written in Rust, to a Bluetooth Low Energy SoC processor.

In the end, we found that Rust is usable for building IoT applications with similar power consumption as production C implementations.

About Niklas Adolfsson:
Niklas Adolfsson is embedded software developer at Cybercom in Sweden. He received a B.S. degree at in Electrical at University of Borås and is currently pursing a MSc. in Computer Science at Chalmers University. He is also a contributor to Tock and has worked as a dependability engineer at SP Technical Research Institute of Sweden.
Captions: 
	00:00:12,410 --> 00:00:23,360
Niclas at austin everyone so thank you

00:00:16,360 --> 00:00:26,250
[Applause]

00:00:23,360 --> 00:00:28,320
so welcome everyone to this talk which

00:00:26,250 --> 00:00:31,200
is called raw space runtime for Internet

00:00:28,320 --> 00:00:34,710
of Things I'm Nicolas I'm from the rainy

00:00:31,200 --> 00:00:36,480
city in Sweden as you heard of and I

00:00:34,710 --> 00:00:38,430
currently work as an embedded software

00:00:36,480 --> 00:00:41,430
engineer at the consulting company in

00:00:38,430 --> 00:00:44,970
Sweden names I become where we primarily

00:00:41,430 --> 00:00:47,670
focus on connecting this society and in

00:00:44,970 --> 00:00:49,770
my daily job I mainly write C but on my

00:00:47,670 --> 00:00:52,879
free time I write rust of course and

00:00:49,770 --> 00:00:55,739
I've been writing rust for a year now

00:00:52,879 --> 00:00:57,690
and recently I also graduate from

00:00:55,739 --> 00:01:00,360
Chalmers University with a master's

00:00:57,690 --> 00:01:01,680
degree in computer science and some

00:01:00,360 --> 00:01:04,050
other things I will talk to you about

00:01:01,680 --> 00:01:07,080
today has been part of me and my thesis

00:01:04,050 --> 00:01:10,200
partner Frederick Nielsen's worked along

00:01:07,080 --> 00:01:12,930
with that I am interested in software

00:01:10,200 --> 00:01:15,510
security in general I enjoy embedded

00:01:12,930 --> 00:01:17,670
system programming languages and when I

00:01:15,510 --> 00:01:21,990
don't write code I usually try to lift

00:01:17,670 --> 00:01:24,690
some weights in the gym as well and what

00:01:21,990 --> 00:01:27,750
is this talk about this talk is about my

00:01:24,690 --> 00:01:30,600
experience using rust to build Bluetooth

00:01:27,750 --> 00:01:32,760
Low Energy firmware and we have used a

00:01:30,600 --> 00:01:34,290
new IOT operating system named

00:01:32,760 --> 00:01:37,290
thought which is written in rust

00:01:34,290 --> 00:01:39,840
actually and we are ported to

00:01:37,290 --> 00:01:44,880
development kits for IOT prototyping

00:01:39,840 --> 00:01:47,330
named NR 51 DK and NRF 52 DK and we have

00:01:44,880 --> 00:01:51,840
implemented a couple of drivers

00:01:47,330 --> 00:01:54,450
including Bluetooth Low Energy and I

00:01:51,840 --> 00:01:56,760
will focus on an RF 51 DK in this talk

00:01:54,450 --> 00:01:59,700
because I will show you some benchmarks

00:01:56,760 --> 00:02:03,780
on it that we have performed further

00:01:59,700 --> 00:02:06,090
along I don't I don't I will not explain

00:02:03,780 --> 00:02:07,800
what was this and how it achieves speed

00:02:06,090 --> 00:02:09,330
safety and concurrency and that stuff

00:02:07,800 --> 00:02:12,209
because I assume you're all familiar

00:02:09,330 --> 00:02:14,010
with that and if you have any questions

00:02:12,209 --> 00:02:17,129
I'll be happy to answer them after this

00:02:14,010 --> 00:02:20,640
talk and if you run out of time come see

00:02:17,129 --> 00:02:23,450
me be happy to talk to you but what is

00:02:20,640 --> 00:02:26,040
really Internet of Things well its

00:02:23,450 --> 00:02:28,590
traditional physical systems that are

00:02:26,040 --> 00:02:32,099
now gaining connected such as course

00:02:28,590 --> 00:02:36,989
light bulbs refrigerators small

00:02:32,099 --> 00:02:39,920
fitness bracelet and so on but but what

00:02:36,989 --> 00:02:42,900
really characterizes these IOT devices

00:02:39,920 --> 00:02:46,260
in general these are low-end devices

00:02:42,900 --> 00:02:50,480
that that are based on microcontrollers

00:02:46,260 --> 00:02:53,790
for a reason of low power and low cost

00:02:50,480 --> 00:02:56,579
and but some of you may not be familiar

00:02:53,790 --> 00:02:58,919
what really a microcontroller is it's an

00:02:56,579 --> 00:03:02,129
entire computer integrated on a single

00:02:58,919 --> 00:03:05,129
chip which typically has one one core

00:03:02,129 --> 00:03:07,530
CPU with tens of megahertz tens of

00:03:05,129 --> 00:03:12,569
kilobytes of RAM hundreds of kilobytes

00:03:07,530 --> 00:03:14,699
of flash but but like memory a memory

00:03:12,569 --> 00:03:16,919
management unit which means that they

00:03:14,699 --> 00:03:20,219
don't have any notion or virtual address

00:03:16,919 --> 00:03:22,799
space and also these are getting

00:03:20,219 --> 00:03:28,139
equipped with radio ships integrated

00:03:22,799 --> 00:03:30,090
such as this board here and I commonly

00:03:28,139 --> 00:03:33,139
use protocol for this it's Bluetooth Low

00:03:30,090 --> 00:03:36,569
Energy some of you may be familiar with

00:03:33,139 --> 00:03:39,060
Bluetooth classic bluetooth but you can

00:03:36,569 --> 00:03:41,939
think about Bluetooth Low Energy as as

00:03:39,060 --> 00:03:44,699
Bluetooth classics little brother which

00:03:41,939 --> 00:03:47,519
focus on low-end devices and low-power

00:03:44,699 --> 00:03:51,120
applications for example IOT device

00:03:47,519 --> 00:03:53,449
running running on a battery can run for

00:03:51,120 --> 00:03:56,579
months using Bluetooth Low Energy and

00:03:53,449 --> 00:03:58,979
its support arrange less than hundred

00:03:56,579 --> 00:04:01,439
meters I will show you an example later

00:03:58,979 --> 00:04:05,819
so maybe we can try if you can reach it

00:04:01,439 --> 00:04:08,609
at the back but Bluetooth Low Energy has

00:04:05,819 --> 00:04:12,169
two type of packets it has advertisement

00:04:08,609 --> 00:04:14,790
packets which are essentially

00:04:12,169 --> 00:04:17,789
broadcasting for example this can be

00:04:14,790 --> 00:04:19,889
used for a device to advertise I'm

00:04:17,789 --> 00:04:22,919
device X and you can connect to me and I

00:04:19,889 --> 00:04:26,820
provide these services or it can also be

00:04:22,919 --> 00:04:29,610
used for arbitrary broadcasting such as

00:04:26,820 --> 00:04:30,770
advertising GPS coordinates or something

00:04:29,610 --> 00:04:34,919
like that

00:04:30,770 --> 00:04:39,360
and these are sent on three dedicated

00:04:34,919 --> 00:04:42,180
channels periodically and then we have

00:04:39,360 --> 00:04:44,940
something called data packets and data

00:04:42,180 --> 00:04:45,810
packets or packets which support a

00:04:44,940 --> 00:04:48,120
bigger pelo

00:04:45,810 --> 00:04:50,040
or use the in connections but I will not

00:04:48,120 --> 00:04:52,440
talk anymore about this because we have

00:04:50,040 --> 00:04:57,050
not focused on it I just want you to see

00:04:52,440 --> 00:05:00,120
this tact to follow along with this talk

00:04:57,050 --> 00:05:03,270
but let's continue about the IOT

00:05:00,120 --> 00:05:05,400
characteristics and because these

00:05:03,270 --> 00:05:08,520
devices are located in areas with

00:05:05,400 --> 00:05:11,270
limited physical access or no physical

00:05:08,520 --> 00:05:13,260
access at all reliability is more

00:05:11,270 --> 00:05:15,510
important than in general-purpose

00:05:13,260 --> 00:05:18,600
computers because we cannot rely on

00:05:15,510 --> 00:05:20,850
humans to recover from failures and also

00:05:18,600 --> 00:05:23,340
these are integrated in safety critical

00:05:20,850 --> 00:05:27,510
systems and these can endanger human

00:05:23,340 --> 00:05:30,330
life essentially also these collectors

00:05:27,510 --> 00:05:35,520
store a lot of our private private data

00:05:30,330 --> 00:05:37,350
about the about our daily lives and so

00:05:35,520 --> 00:05:40,500
on which means the security and privacy

00:05:37,350 --> 00:05:43,229
is also important but as I said these

00:05:40,500 --> 00:05:45,960
are very resource constrained devices

00:05:43,229 --> 00:05:49,260
which limits the number of suitable

00:05:45,960 --> 00:05:51,720
programming languages and they really

00:05:49,260 --> 00:05:54,120
require a low runtime overhead with fine

00:05:51,720 --> 00:05:57,479
grained memory control and deterministic

00:05:54,120 --> 00:06:01,010
behavior and for those reasons C and C++

00:05:57,479 --> 00:06:03,780
so more or less exclusive in this domain

00:06:01,010 --> 00:06:06,840
but as you are probably familiar with C

00:06:03,780 --> 00:06:09,530
and C++ or memory unsafe languages where

00:06:06,840 --> 00:06:12,600
memory corruption is a problem with

00:06:09,530 --> 00:06:17,400
buffer overruns and dangling pointers

00:06:12,600 --> 00:06:20,460
and so on and also these IOT

00:06:17,400 --> 00:06:23,220
applications becomes more and more

00:06:20,460 --> 00:06:26,510
complex because they need to run several

00:06:23,220 --> 00:06:30,210
tasks at the same time they need to

00:06:26,510 --> 00:06:32,100
provide complex drivers as IP stack or

00:06:30,210 --> 00:06:34,950
something like that and for those

00:06:32,100 --> 00:06:38,400
reasons in general and special purpose

00:06:34,950 --> 00:06:40,919
operating system is used in general

00:06:38,400 --> 00:06:43,350
these operating systems trade-off memory

00:06:40,919 --> 00:06:45,630
and power efficiency over safety

00:06:43,350 --> 00:06:47,850
features and that means that these

00:06:45,630 --> 00:06:50,400
operating systems don't provide any

00:06:47,850 --> 00:06:52,740
memory solution but what does that mean

00:06:50,400 --> 00:06:55,310
well it means that they're all

00:06:52,740 --> 00:06:58,729
essentially no net no separation between

00:06:55,310 --> 00:07:01,460
applications and kernel

00:06:58,729 --> 00:07:04,189
and and that means that the entire

00:07:01,460 --> 00:07:08,050
computing base needs to be trusted so

00:07:04,189 --> 00:07:10,699
let's consider this if we have a faulty

00:07:08,050 --> 00:07:13,370
application with a buffer overflow for

00:07:10,699 --> 00:07:18,169
example what will happen will disable

00:07:13,370 --> 00:07:20,930
for example no it's much worse than a

00:07:18,169 --> 00:07:23,990
seg fault it's actually undefined

00:07:20,930 --> 00:07:26,719
behavior because we have no notion of

00:07:23,990 --> 00:07:29,089
virtual address space and this can for

00:07:26,719 --> 00:07:33,349
example write over the kernel and crash

00:07:29,089 --> 00:07:37,460
the entire thing and yes it's not

00:07:33,349 --> 00:07:42,800
surprised that IOT is insecure during

00:07:37,460 --> 00:07:45,770
this summer security researchers found a

00:07:42,800 --> 00:07:47,899
buffer overflow vulnerability in an open

00:07:45,770 --> 00:07:51,649
source library we'd made hundreds

00:07:47,899 --> 00:07:54,830
millions of devices vulnerable but what

00:07:51,649 --> 00:07:58,550
can we do about this well we can use a

00:07:54,830 --> 00:08:03,439
new safe programming language such a

00:07:58,550 --> 00:08:05,120
trust or rust and rust actually the

00:08:03,439 --> 00:08:07,479
benefits of having memory safety

00:08:05,120 --> 00:08:10,370
prevents these memory corruption attacks

00:08:07,479 --> 00:08:12,349
completely along with fine-grained

00:08:10,370 --> 00:08:14,839
memory control and low runtime overhead

00:08:12,349 --> 00:08:18,490
makes Rost an ideal candidate to

00:08:14,839 --> 00:08:20,629
implement IOT applications in and

00:08:18,490 --> 00:08:24,649
andross can actually reduce the number

00:08:20,629 --> 00:08:26,749
of rely on vulnerable IOT devices this

00:08:24,649 --> 00:08:30,740
sounds great right why don't we write an

00:08:26,749 --> 00:08:32,479
IOT operating system in rust well it

00:08:30,740 --> 00:08:35,449
turns out that somebody's already done

00:08:32,479 --> 00:08:38,899
this which leads us into talk talk is a

00:08:35,449 --> 00:08:41,149
new secure LTE operating system which

00:08:38,899 --> 00:08:44,079
actually provides memory solution I will

00:08:41,149 --> 00:08:47,410
come back to that in the next slide how

00:08:44,079 --> 00:08:51,170
but it focused on reliability and safety

00:08:47,410 --> 00:08:53,540
security sorry it's it's part of a

00:08:51,170 --> 00:08:55,990
research project where they rethink the

00:08:53,540 --> 00:09:00,170
entire IOT domain from the ground up and

00:08:55,990 --> 00:09:02,860
talk actually support at the moment talk

00:09:00,170 --> 00:09:06,890
support arm cortex-m microcontrollers

00:09:02,860 --> 00:09:11,000
which you can see here to the right and

00:09:06,890 --> 00:09:12,590
this is one of them let's continue and

00:09:11,000 --> 00:09:14,450
talk about

00:09:12,590 --> 00:09:16,940
textual talk because I think it's very

00:09:14,450 --> 00:09:21,440
interesting as I said it provides

00:09:16,940 --> 00:09:24,140
actually memory solution and it talked

00:09:21,440 --> 00:09:26,750
actually use a process based abstraction

00:09:24,140 --> 00:09:30,770
where they have something called user

00:09:26,750 --> 00:09:33,400
space processes that are all restricted

00:09:30,770 --> 00:09:37,160
and executed outside the kernel with

00:09:33,400 --> 00:09:40,460
restricted privileges and for example it

00:09:37,160 --> 00:09:43,640
a process only has access to its own

00:09:40,460 --> 00:09:46,700
heap stack in data segment and it uses

00:09:43,640 --> 00:09:48,830
this by using a new memory feature in

00:09:46,700 --> 00:09:50,840
arm cortex-m microcontrollers which is

00:09:48,830 --> 00:09:53,060
called an MP you a memory protection

00:09:50,840 --> 00:09:56,270
unit you can view it as a very

00:09:53,060 --> 00:09:59,390
lightweight MMU but we know virtual

00:09:56,270 --> 00:10:01,790
address space and moving on to the

00:09:59,390 --> 00:10:06,110
kernel itself it's kind of a microkernel

00:10:01,790 --> 00:10:08,000
but not really because it has two two

00:10:06,110 --> 00:10:10,760
components first of all they have the

00:10:08,000 --> 00:10:13,430
dicobalt kernel which has a hardware

00:10:10,760 --> 00:10:15,740
abstraction layer scheduler and so on

00:10:13,430 --> 00:10:18,110
and then top you actually have something

00:10:15,740 --> 00:10:20,870
called capsules and capsules or

00:10:18,110 --> 00:10:26,420
essentially device drivers but because

00:10:20,870 --> 00:10:29,570
tox targets very tiny computers this

00:10:26,420 --> 00:10:32,200
cannot be executed as separate uses

00:10:29,570 --> 00:10:35,840
based processes and instead they are

00:10:32,200 --> 00:10:38,810
integrated in kernel but relies on the

00:10:35,840 --> 00:10:43,010
type system a rust which makes it very

00:10:38,810 --> 00:10:44,930
unlikely that they will fail along with

00:10:43,010 --> 00:10:48,680
that the kernel itself is statically

00:10:44,930 --> 00:10:53,450
allocated for safety reasons but that's

00:10:48,680 --> 00:10:56,510
all I want to say about talk which moves

00:10:53,450 --> 00:10:58,100
which moves on to what we have done we

00:10:56,510 --> 00:11:00,740
have used this micro controller I will

00:10:58,100 --> 00:11:05,510
not touch this because they didn't work

00:11:00,740 --> 00:11:08,810
that well before which is an RF 51 it's

00:11:05,510 --> 00:11:13,940
arm cortex-m CRO microcontroller which

00:11:08,810 --> 00:11:18,710
has a CPU of 60 megahertz ram of 32

00:11:13,940 --> 00:11:22,520
kilobytes flash 256 kilobytes comes with

00:11:18,710 --> 00:11:24,800
a radio integrated on the on the ship in

00:11:22,520 --> 00:11:26,270
the red rectangle actually that is an RF

00:11:24,800 --> 00:11:28,850
fixed ones

00:11:26,270 --> 00:11:31,940
and process the microcontroller itself

00:11:28,850 --> 00:11:35,150
support some other referrals such as AES

00:11:31,940 --> 00:11:39,260
true random generator temperature sensor

00:11:35,150 --> 00:11:44,150
and similar but what have you really

00:11:39,260 --> 00:11:46,640
done to illustrate this this blue this

00:11:44,150 --> 00:11:48,110
blue box is actually an effect one

00:11:46,640 --> 00:11:50,330
microcontroller where we have

00:11:48,110 --> 00:11:53,900
implemented some device drivers for

00:11:50,330 --> 00:11:56,810
actually which is a temperature sensor

00:11:53,900 --> 00:11:59,390
AES encryption through random generator

00:11:56,810 --> 00:12:04,970
and blue to flow and the driver over the

00:11:59,390 --> 00:12:07,490
radio and to create a good example for

00:12:04,970 --> 00:12:11,060
you to understand what this really is

00:12:07,490 --> 00:12:13,070
we created a demonstration app that

00:12:11,060 --> 00:12:14,590
combines all these drivers so we

00:12:13,070 --> 00:12:17,870
construct a Bluetooth low-energy

00:12:14,590 --> 00:12:22,700
advertisement packet and use Talk OS as

00:12:17,870 --> 00:12:24,710
device name and then we encrypt the

00:12:22,700 --> 00:12:27,890
master temperature and they generated

00:12:24,710 --> 00:12:31,850
random numbers and let's see if we can

00:12:27,890 --> 00:12:35,270
get this to work so this is actually

00:12:31,850 --> 00:12:40,370
very ugly Android app that we are

00:12:35,270 --> 00:12:42,640
created for this purpose so we have this

00:12:40,370 --> 00:12:46,820
board here it's supposed to advertise

00:12:42,640 --> 00:12:49,070
yes it does so for example first of all

00:12:46,820 --> 00:12:50,600
in the top here we have the talk

00:12:49,070 --> 00:12:53,630
taco voice which is the advertisement

00:12:50,600 --> 00:12:57,670
name this is nothing cryptid and then we

00:12:53,630 --> 00:13:01,640
have the encrypted payload down here

00:12:57,670 --> 00:13:03,770
down here and and the app actually has

00:13:01,640 --> 00:13:07,430
the hard-coded encryption key that can

00:13:03,770 --> 00:13:10,090
decrypt these things and that's what I

00:13:07,430 --> 00:13:10,090
wanted to show you

00:13:11,440 --> 00:13:17,810
moving on to to the general architecture

00:13:14,570 --> 00:13:20,480
of of the things that we have

00:13:17,810 --> 00:13:23,540
implemented of the Bluetooth low-energy

00:13:20,480 --> 00:13:27,340
device driver it looks something like

00:13:23,540 --> 00:13:31,520
this and the blue box this illustrates

00:13:27,340 --> 00:13:33,440
user space stuff and I don't want to

00:13:31,520 --> 00:13:38,990
scare you but this is written in C at

00:13:33,440 --> 00:13:40,140
the moment because this is something to

00:13:38,990 --> 00:13:42,960
do with that talk

00:13:40,140 --> 00:13:46,050
is position independent code in theory

00:13:42,960 --> 00:13:48,810
any language is supported but there is

00:13:46,050 --> 00:13:50,790
some problem with global variables at

00:13:48,810 --> 00:13:53,100
the moment so therefore we have

00:13:50,790 --> 00:13:58,440
implemented this EC at the moment but

00:13:53,100 --> 00:14:01,170
this is this is this is really not that

00:13:58,440 --> 00:14:03,990
complicated and most of the complexities

00:14:01,170 --> 00:14:07,530
actually in the kernel at the moment but

00:14:03,990 --> 00:14:12,360
we have a Bluetooth Low Energy library -

00:14:07,530 --> 00:14:15,780
for example - to send advertisement to

00:14:12,360 --> 00:14:19,110
configure different data configure the

00:14:15,780 --> 00:14:22,410
radio to send on a given advertisement

00:14:19,110 --> 00:14:26,250
interval and so on and also we can use

00:14:22,410 --> 00:14:29,580
it to do passive scanning but we don't

00:14:26,250 --> 00:14:35,250
support connections and complicated

00:14:29,580 --> 00:14:36,960
security modes at the moment but let's

00:14:35,250 --> 00:14:39,150
move on and talk about what we have done

00:14:36,960 --> 00:14:42,390
in the kernel and we have something

00:14:39,150 --> 00:14:44,970
called ble capsule which is essentially

00:14:42,390 --> 00:14:49,290
the logic of the entire beautiful oh and

00:14:44,970 --> 00:14:51,470
the device driver it it keeps track to

00:14:49,290 --> 00:14:55,440
put the processor to sleep between

00:14:51,470 --> 00:14:59,730
advertisements and also include the ble

00:14:55,440 --> 00:15:02,570
bluetooth low energy state machine and

00:14:59,730 --> 00:15:05,400
similar things it's written in

00:15:02,570 --> 00:15:08,160
approximately 400 lines or Russ code and

00:15:05,400 --> 00:15:11,880
I cannot show you all the code of course

00:15:08,160 --> 00:15:14,820
but I can only show you one one snippet

00:15:11,880 --> 00:15:19,680
that we have that for configuring data

00:15:14,820 --> 00:15:22,980
in advertisement packet and as you can

00:15:19,680 --> 00:15:28,320
see we have to use an iterator and you

00:15:22,980 --> 00:15:32,220
use nested closures to do this because

00:15:28,320 --> 00:15:35,820
we are iterating through all boys here

00:15:32,220 --> 00:15:38,280
which is very which is very dangerous

00:15:35,820 --> 00:15:41,250
but in rust we can use the type system

00:15:38,280 --> 00:15:48,990
to benefit all this and this is actually

00:15:41,250 --> 00:15:50,610
very bug bug prone in C and moving on we

00:15:48,990 --> 00:15:53,929
have something called a hardware module

00:15:50,610 --> 00:15:56,489
or a ble radio this is where we do

00:15:53,929 --> 00:15:58,589
close to the metal things that we

00:15:56,489 --> 00:16:01,739
interact directly with with the hardware

00:15:58,589 --> 00:16:03,839
so for example if you want to turn on

00:16:01,739 --> 00:16:06,720
the radio we have to write this on

00:16:03,839 --> 00:16:10,769
memory mapped i/o and we write some bits

00:16:06,720 --> 00:16:14,369
there and while the radio is on and this

00:16:10,769 --> 00:16:18,569
is implemented in around 450 lines or us

00:16:14,369 --> 00:16:19,889
code at the moment and it looks

00:16:18,569 --> 00:16:21,929
something like this this is very

00:16:19,889 --> 00:16:27,509
simplified of course but we have a

00:16:21,929 --> 00:16:31,379
pointer to a struct which contains the

00:16:27,509 --> 00:16:33,779
memory map of this radio registers and

00:16:31,379 --> 00:16:37,679
then we can turn on the radio for

00:16:33,779 --> 00:16:41,100
example here if we hear a dereference

00:16:37,679 --> 00:16:42,899
the pointer and then we write write some

00:16:41,100 --> 00:16:48,869
bits here here we reset the radio and

00:16:42,899 --> 00:16:51,269
turn it on but that's all i want to give

00:16:48,869 --> 00:16:54,660
you about actual implementation today

00:16:51,269 --> 00:16:57,359
and but we also wanted to evaluate these

00:16:54,660 --> 00:17:01,079
device drivers and we did some

00:16:57,359 --> 00:17:03,929
comparisons with with the state current

00:17:01,079 --> 00:17:08,399
state or thai OTE operating systems we

00:17:03,929 --> 00:17:11,579
elected this based on that they are open

00:17:08,399 --> 00:17:17,510
source they provide drivers for our

00:17:11,579 --> 00:17:21,539
board and they also are open source and

00:17:17,510 --> 00:17:25,500
we did we did actually measure the power

00:17:21,539 --> 00:17:28,380
on the board we did this by advertising

00:17:25,500 --> 00:17:30,840
during 10 seconds and we configured each

00:17:28,380 --> 00:17:34,260
operating system in the in the same way

00:17:30,840 --> 00:17:37,820
which was that we used advertisement

00:17:34,260 --> 00:17:42,210
interval or 150 milliseconds we used

00:17:37,820 --> 00:17:45,389
transmitting power of 0 DBM and we used

00:17:42,210 --> 00:17:49,590
the payload size of 20 2 bytes and for

00:17:45,389 --> 00:17:52,230
each operating system we have 3 balls

00:17:49,590 --> 00:17:54,470
the red ball illustrates the total power

00:17:52,230 --> 00:17:58,169
consumption during during this period

00:17:54,470 --> 00:18:00,450
the blue bar illustrates where the power

00:17:58,169 --> 00:18:03,330
consumption when the radio is on and the

00:18:00,450 --> 00:18:05,669
green bar illustrates the power

00:18:03,330 --> 00:18:07,450
consumption when the radio is turned off

00:18:05,669 --> 00:18:09,820
and

00:18:07,450 --> 00:18:11,980
and this has nothing to do whether they

00:18:09,820 --> 00:18:15,220
are written in C or rust I believe

00:18:11,980 --> 00:18:17,590
because these are more or less how good

00:18:15,220 --> 00:18:19,870
these operating system or to turn off

00:18:17,590 --> 00:18:25,240
power-hungry free-for-all such as UART

00:18:19,870 --> 00:18:28,000
and so on when they are sleeping but

00:18:25,240 --> 00:18:32,170
this was great right but how was the

00:18:28,000 --> 00:18:34,900
journey really been well I would say

00:18:32,170 --> 00:18:37,510
this fail pick yourself up and fail

00:18:34,900 --> 00:18:42,430
again because this has been a very tough

00:18:37,510 --> 00:18:45,520
journey and a lot of sweat and tears

00:18:42,430 --> 00:18:47,650
first of all learning an IOT operating

00:18:45,520 --> 00:18:51,820
system with limited documentation is

00:18:47,650 --> 00:18:54,490
it's really hard for example how do the

00:18:51,820 --> 00:18:58,780
system calls work how do we pass a

00:18:54,490 --> 00:19:01,630
buffer to the kernel how do we iterate

00:18:58,780 --> 00:19:04,660
over raw bytes in the kernel you saw an

00:19:01,630 --> 00:19:07,660
example of that earlier which which was

00:19:04,660 --> 00:19:12,820
kind of hard for for us to understand

00:19:07,660 --> 00:19:15,160
and but the tote has a nice community we

00:19:12,820 --> 00:19:17,410
then I see channel where you can go and

00:19:15,160 --> 00:19:23,110
ask questions and we have got a lot of

00:19:17,410 --> 00:19:27,070
help from them actually but a top of

00:19:23,110 --> 00:19:30,700
that we have no debugging symbols at all

00:19:27,070 --> 00:19:33,250
so and for me I'm not really that

00:19:30,700 --> 00:19:38,500
familiar with or assembly and this was

00:19:33,250 --> 00:19:41,230
really hard so so we thought let's not

00:19:38,500 --> 00:19:43,600
do debugging with gdb let's go do

00:19:41,230 --> 00:19:44,790
printouts in the kernel instead but that

00:19:43,600 --> 00:19:49,690
didn't work either

00:19:44,790 --> 00:19:57,760
so the first the first time we did only

00:19:49,690 --> 00:19:59,800
blinked with LEDs but but eventually we

00:19:57,760 --> 00:20:02,140
actually this is actually our first

00:19:59,800 --> 00:20:06,160
contribution to talk where we actually

00:20:02,140 --> 00:20:08,530
fix these printouts or panics F but

00:20:06,160 --> 00:20:11,110
after this this they the work has gone

00:20:08,530 --> 00:20:14,770
pretty good I would say and it's it's

00:20:11,110 --> 00:20:17,050
been very fun actually but what I want

00:20:14,770 --> 00:20:19,210
to give some of my views on using Ross

00:20:17,050 --> 00:20:21,020
because I only use Ross for one year I

00:20:19,210 --> 00:20:23,720
would say as

00:20:21,020 --> 00:20:27,200
Maddi others that the learning curve is

00:20:23,720 --> 00:20:29,870
ready steep learning ownership interior

00:20:27,200 --> 00:20:32,630
mutability lifetimes and similar things

00:20:29,870 --> 00:20:36,410
it's hard to get your head around but

00:20:32,630 --> 00:20:40,220
the compiler in rust is awesome it helps

00:20:36,410 --> 00:20:45,110
you give you good good error messages

00:20:40,220 --> 00:20:48,320
and write learned educates you how to to

00:20:45,110 --> 00:20:50,750
write good code also I want to claim

00:20:48,320 --> 00:20:52,820
that the using rosters actually made me

00:20:50,750 --> 00:20:55,580
a better programmer especially about a C

00:20:52,820 --> 00:20:58,970
programmer because now I know exactly

00:20:55,580 --> 00:21:00,950
which which operations are unsafe for

00:20:58,970 --> 00:21:02,840
example the reference a pointer or

00:21:00,950 --> 00:21:07,910
something like that and that has helped

00:21:02,840 --> 00:21:11,270
me actually writing C as well and and

00:21:07,910 --> 00:21:14,690
when using rust I have not experienced

00:21:11,270 --> 00:21:17,840
many crashes but I advise you don't do

00:21:14,690 --> 00:21:21,920
unwrapped on option types because then

00:21:17,840 --> 00:21:24,380
then you're on your own and I just want

00:21:21,920 --> 00:21:26,990
to give a shout out to the rust IRC

00:21:24,380 --> 00:21:28,670
channels because I have never

00:21:26,990 --> 00:21:31,490
experienced something like that in

00:21:28,670 --> 00:21:33,440
another community and it's a very good

00:21:31,490 --> 00:21:35,809
resource to learn new things and ask

00:21:33,440 --> 00:21:40,429
questions that I really appreciate keep

00:21:35,809 --> 00:21:42,740
it up and I always want to dream a

00:21:40,429 --> 00:21:46,400
little bit as well what I want to see in

00:21:42,740 --> 00:21:48,770
the future and I want to see rust in

00:21:46,400 --> 00:21:51,530
safety critical applications such as

00:21:48,770 --> 00:21:54,950
medical devices out in almost vehicles

00:21:51,530 --> 00:21:58,550
and similar fields because I know how

00:21:54,950 --> 00:22:00,950
hard it is to write safe and secure C

00:21:58,550 --> 00:22:04,220
code for example you have to go through

00:22:00,950 --> 00:22:06,440
a very painful process and it costs a

00:22:04,220 --> 00:22:10,730
lot of money which I think Russ can

00:22:06,440 --> 00:22:13,460
reduce but one tricky thing that rust

00:22:10,730 --> 00:22:16,460
has to do is to convince the embedded

00:22:13,460 --> 00:22:19,550
community to adopt rust so for example

00:22:16,460 --> 00:22:22,460
if you try talk to and by the software

00:22:19,550 --> 00:22:25,040
engineer he or she will say I've been

00:22:22,460 --> 00:22:29,870
written C for 20 years and it works just

00:22:25,040 --> 00:22:33,169
fine but clearly it doesn't because we

00:22:29,870 --> 00:22:34,340
have a lot of security problems and also

00:22:33,169 --> 00:22:37,309
when nupro

00:22:34,340 --> 00:22:39,169
grammars coming into the field their

00:22:37,309 --> 00:22:41,390
first programming language is probably

00:22:39,169 --> 00:22:43,909
not see they go to more high-level

00:22:41,390 --> 00:22:47,330
programming languages which rust is a

00:22:43,909 --> 00:22:50,150
better fit for and the less the last

00:22:47,330 --> 00:22:52,279
thing I want to see is for Fletch I des

00:22:50,150 --> 00:22:54,250
with integrated debuggers in Ross

00:22:52,279 --> 00:22:57,760
especially in the embedded community

00:22:54,250 --> 00:23:00,470
because everybody doesn't like to use

00:22:57,760 --> 00:23:04,010
Rhodey DB with a text prompt even though

00:23:00,470 --> 00:23:07,610
it's very powerful I just want to leave

00:23:04,010 --> 00:23:10,250
you with some some last words we would

00:23:07,610 --> 00:23:13,370
like to see more country abuses talk so

00:23:10,250 --> 00:23:16,820
if you want to get get into that buy

00:23:13,370 --> 00:23:18,529
some board by some of the supported

00:23:16,820 --> 00:23:22,539
boards or put your own favorite

00:23:18,529 --> 00:23:22,539
processors thank you for attention

00:23:28,320 --> 00:23:35,440
yeah so say to Nikolas that was amazing

00:23:32,830 --> 00:23:48,059
we have a lot of time for questions as

00:23:35,440 --> 00:23:50,920
well all right first question over here

00:23:48,059 --> 00:23:53,470
hey this might be a naive question but

00:23:50,920 --> 00:24:06,240
is this all targeting 16-bit CPAs or

00:23:53,470 --> 00:24:06,240
also eight bits or 32 bits 32 bits very

00:24:11,130 --> 00:24:18,880
high any noticeable overhead of a rust

00:24:16,540 --> 00:24:23,620
runtime against the corresponding code

00:24:18,880 --> 00:24:27,040
in C a good question I think I don't

00:24:23,620 --> 00:24:29,340
this but I didn't want to show this

00:24:27,040 --> 00:24:32,679
because it's as much more to do with

00:24:29,340 --> 00:24:35,500
because we may measure the efficiency of

00:24:32,679 --> 00:24:40,090
the system calls B between the different

00:24:35,500 --> 00:24:42,730
operating systems and and I think this

00:24:40,090 --> 00:24:44,470
has something to do with overhead in the

00:24:42,730 --> 00:24:47,650
OSHA texturally different operating

00:24:44,470 --> 00:24:51,970
system not nothing to do with which C

00:24:47,650 --> 00:24:53,440
versus rust so it's hard to say so

00:24:51,970 --> 00:24:56,410
that's why I didn't want to show this

00:24:53,440 --> 00:25:00,240
picture but I figured I I get this

00:24:56,410 --> 00:25:00,240
question and it's better yeah

00:25:08,320 --> 00:25:16,280
hi at some point you mentioned that talk

00:25:12,980 --> 00:25:18,980
requires an MP you to function to to

00:25:16,280 --> 00:25:20,270
separate the processes is that a hard

00:25:18,980 --> 00:25:22,040
requirement because you're using a

00:25:20,270 --> 00:25:24,410
cortex on zero and that one doesn't have

00:25:22,040 --> 00:25:28,640
an MP you have yeah yeah you all right

00:25:24,410 --> 00:25:31,400
no we support under this one but in

00:25:28,640 --> 00:25:33,350
general we enable MP you but for this

00:25:31,400 --> 00:25:37,550
one you're right it doesn't have an MP

00:25:33,350 --> 00:25:39,440
you so so the there are two ball we have

00:25:37,550 --> 00:25:41,180
this is the only board that not have a

00:25:39,440 --> 00:25:44,780
real amp to you but other processors

00:25:41,180 --> 00:25:47,600
have an real amp you but talk doesn't

00:25:44,780 --> 00:25:50,900
require that I will MP you then the

00:25:47,600 --> 00:25:55,220
assembly code for the MP you is is there

00:25:50,900 --> 00:25:57,740
but it becomes knobs no operations so

00:25:55,220 --> 00:26:07,330
it's it's in the is in the kernel but

00:25:57,740 --> 00:26:07,330
it's not used any further questions

00:26:19,510 --> 00:26:24,070
what about the size of the compiled

00:26:22,150 --> 00:26:24,640
binary so they significantly bigger in

00:26:24,070 --> 00:26:29,410
rust

00:26:24,640 --> 00:26:32,800
I have heard probably I don't really

00:26:29,410 --> 00:26:34,570
really know actually I have not looked

00:26:32,800 --> 00:26:38,559
into that but I don't think that's a

00:26:34,570 --> 00:26:40,450
problem but you have to ask the real

00:26:38,559 --> 00:26:52,750
talk community because there are more

00:26:40,450 --> 00:26:55,090
details about that Hey how ready do you

00:26:52,750 --> 00:26:56,920
think the rust ecosystem is for a better

00:26:55,090 --> 00:26:59,710
development so I don't necessarily mean

00:26:56,920 --> 00:27:01,720
things like cargo or the compiler but

00:26:59,710 --> 00:27:07,990
more like the crates that are out there

00:27:01,720 --> 00:27:11,020
I think actually if you go to I think

00:27:07,990 --> 00:27:13,750
his name is Joel gay or something like

00:27:11,020 --> 00:27:16,330
that sorry if I pronounce his name wrong

00:27:13,750 --> 00:27:18,070
but I think he is better to answer that

00:27:16,330 --> 00:27:21,520
question because he has done a lot of

00:27:18,070 --> 00:27:23,710
grace in rust for the embedded stuff so

00:27:21,520 --> 00:27:26,200
ask that question to him is that I think

00:27:23,710 --> 00:27:28,380
it's more more appropriate to answer

00:27:26,200 --> 00:27:30,790
that question

00:27:28,380 --> 00:27:36,700
sure sure here do you want to answer

00:27:30,790 --> 00:27:39,490
that question yeah he gives a talk later

00:27:36,700 --> 00:27:41,140
so answer him that question I think it's

00:27:39,490 --> 00:27:43,960
better better person to answer that

00:27:41,140 --> 00:27:48,000
because I don't have performed any

00:27:43,960 --> 00:27:55,270
crates and I don't have have any

00:27:48,000 --> 00:28:00,309
thoughts about that really you mentioned

00:27:55,270 --> 00:28:04,510
that in C++ an embed the price of error

00:28:00,309 --> 00:28:07,179
is very high how would you subject them

00:28:04,510 --> 00:28:10,900
to compare the price of error in

00:28:07,179 --> 00:28:12,990
embedded C and in embedded trust a great

00:28:10,900 --> 00:28:14,730
question

00:28:12,990 --> 00:28:17,620
[Music]

00:28:14,730 --> 00:28:22,809
it depends what kind of program in your

00:28:17,620 --> 00:28:24,850
how familiar we see but I can't really

00:28:22,809 --> 00:28:28,620
give a good exam good answer to that

00:28:24,850 --> 00:28:28,620
question it depends on your background

00:28:30,490 --> 00:28:35,990
okay we have time for one more question

00:28:32,450 --> 00:28:38,440
and it's just in front of the stage

00:28:35,990 --> 00:28:38,440
perfect

00:28:42,250 --> 00:28:48,970
out of curiosity how many percent of

00:28:45,919 --> 00:28:52,610
your rust code would you say is unsafe

00:28:48,970 --> 00:28:56,179
good question I would I have not

00:28:52,610 --> 00:28:59,480
performed any any measurements or this

00:28:56,179 --> 00:29:03,320
but in my opinion is like 10% something

00:28:59,480 --> 00:29:07,480
like that but I take that with I'm not

00:29:03,320 --> 00:29:07,480
really sure but something in that range

00:29:08,019 --> 00:29:12,270
all right thank you and thank you for

00:29:11,659 --> 00:29:17,549
taking the time

00:29:12,270 --> 00:29:17,549

YouTube URL: https://www.youtube.com/watch?v=reQ7_oXwECQ


