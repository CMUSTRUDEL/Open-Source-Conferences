Title: RustFest Zürich 2017 - Teaching an IDE to understand Rust by Igor Matuszewski
Publication date: 2017-10-21
Playlist: RustFest Zürich 2017
Description: 
	IDE support is one of Rust’s most requested features. From the 2017 State of Rust Survey: roughly 30% of Rust users are looking forward to IDE support more than any other feature in 2017 and for 22% of non-users, lack of IDE support is their main reason for not using Rust. In this talk, I’ll cover what it took to support Cargo workspaces in the RLS and I’ll explain how the RLS leverages existing tooling, including Cargo and the compiler. I’ll demonstrate the current state of Rust programming with an IDE, and how you can benefit from using an IDE with your Rust projects.

About Igor Matuszewski:
Igor is studying Computer Science at the University of Warsaw, Poland. Having worked on a AAA game and various smaller ones, he grew tired of the repetitiveness of the process and started a journey to find a language that would aid in building better abstractions. He discovered Rust and decided to help further the IDE story, so the development process would be more enjoyable. He was accepted onto the Google Summer of Code 2017 as a student and has been working to improve the RLS and IDE support.
Captions: 
	00:00:19,450 --> 00:00:29,660
hi everyone and this does not work maybe

00:00:27,080 --> 00:00:34,670
that's just a second yep

00:00:29,660 --> 00:00:37,190
okay so I D story our other ID support

00:00:34,670 --> 00:00:39,260
for us is something very surely

00:00:37,190 --> 00:00:41,330
something to be excited about and by the

00:00:39,260 --> 00:00:44,120
end of this talk I expect everyone to

00:00:41,330 --> 00:00:48,379
know what it is how would we use it and

00:00:44,120 --> 00:00:50,510
how it currently works so the plan for

00:00:48,379 --> 00:00:52,760
this talk is to first talk about the

00:00:50,510 --> 00:00:55,880
architecture of the rust language server

00:00:52,760 --> 00:00:59,090
which currently is the officially kind

00:00:55,880 --> 00:01:01,640
of support away the way to have your ID

00:00:59,090 --> 00:01:04,759
features and for your favorite editor of

00:01:01,640 --> 00:01:08,240
choice then I plan to demonstrate very

00:01:04,759 --> 00:01:10,430
quickly how such features work then I'll

00:01:08,240 --> 00:01:12,940
talk about how Karger coordinates builds

00:01:10,430 --> 00:01:15,649
and why the RLS should bother and

00:01:12,940 --> 00:01:19,220
finally I'll talk about supporting cargo

00:01:15,649 --> 00:01:21,940
workspaces and the RLS itself so without

00:01:19,220 --> 00:01:25,700
further ado let us begin

00:01:21,940 --> 00:01:28,340
so first the architecture so as the name

00:01:25,700 --> 00:01:30,830
suggests rust language server is

00:01:28,340 --> 00:01:33,709
actually a language smartness server as

00:01:30,830 --> 00:01:36,890
in it's not a monolithic ID let's say

00:01:33,709 --> 00:01:39,920
the compiler is not embedded in the ID

00:01:36,890 --> 00:01:42,200
itself but rather it serves to be sort

00:01:39,920 --> 00:01:44,569
of a standalone server with with

00:01:42,200 --> 00:01:47,300
different IDs or text editors can

00:01:44,569 --> 00:01:50,060
communicate with and they communicate

00:01:47,300 --> 00:01:54,380
with it via a custom interposes protocol

00:01:50,060 --> 00:01:56,990
called the LSP and the LSP has been

00:01:54,380 --> 00:02:00,229
developed by Microsoft it's the full

00:01:56,990 --> 00:02:02,899
name is language server protocol and so

00:02:00,229 --> 00:02:05,119
it aims to abstract away all it aims to

00:02:02,899 --> 00:02:08,239
be as language agnostic as possible as

00:02:05,119 --> 00:02:10,610
in it does not even try to define any

00:02:08,239 --> 00:02:13,280
semantics of a language so for example

00:02:10,610 --> 00:02:15,920
it does not know what let's say class or

00:02:13,280 --> 00:02:18,709
interface or structures it mostly deals

00:02:15,920 --> 00:02:21,020
with text buffers and texts and the most

00:02:18,709 --> 00:02:23,870
abstract thing to define let's say a

00:02:21,020 --> 00:02:27,760
symbol for language as a symbol or a

00:02:23,870 --> 00:02:27,760
reference and that's it and that's it

00:02:28,610 --> 00:02:34,159
so why even

00:02:31,790 --> 00:02:38,780
start using LSB why not just create

00:02:34,159 --> 00:02:41,209
another ID such as visual studio for n

00:02:38,780 --> 00:02:43,280
languages and n editors we can see that

00:02:41,209 --> 00:02:45,920
we get M times n different

00:02:43,280 --> 00:02:49,400
implementations for different language

00:02:45,920 --> 00:02:51,650
supports in different editors and by

00:02:49,400 --> 00:02:54,109
being as language agnostic as possible

00:02:51,650 --> 00:02:56,659
and by abstracting away the of the

00:02:54,109 --> 00:02:59,510
protocol at a communication we only need

00:02:56,659 --> 00:03:02,450
to implement only a single client for

00:02:59,510 --> 00:03:04,790
each editor and only a single LSB server

00:03:02,450 --> 00:03:08,030
for each language we want to support and

00:03:04,790 --> 00:03:10,400
in this example if let's say we use LSP

00:03:08,030 --> 00:03:13,310
compliant client and let's see then that

00:03:10,400 --> 00:03:16,280
can talk to let's say Rus language

00:03:13,310 --> 00:03:18,379
server which aims to support rust we can

00:03:16,280 --> 00:03:20,450
see that they can interrupt very easily

00:03:18,379 --> 00:03:23,419
so with this the number of

00:03:20,450 --> 00:03:27,590
implementations goes down to well M plus

00:03:23,419 --> 00:03:30,470
n only so this is very convenient so

00:03:27,590 --> 00:03:33,500
what may be the responsibilities of a

00:03:30,470 --> 00:03:35,239
set server well first of all it has to

00:03:33,500 --> 00:03:38,030
coordinate and schedule different

00:03:35,239 --> 00:03:41,870
analysis builds so let's say users

00:03:38,030 --> 00:03:45,139
starts typing or modifying a file the

00:03:41,870 --> 00:03:46,970
RLS shouldn't really try to let's say

00:03:45,139 --> 00:03:49,549
you run cargo check or run cargo build

00:03:46,970 --> 00:03:52,069
with every keystroke that's not optimal

00:03:49,549 --> 00:03:55,280
to say the least so it has to coordinate

00:03:52,069 --> 00:03:58,780
that it also has to manage all the

00:03:55,280 --> 00:04:01,250
announces data that let's say it's a

00:03:58,780 --> 00:04:03,859
small database that contains all the

00:04:01,250 --> 00:04:06,229
references to the symbols and whatnot so

00:04:03,859 --> 00:04:08,030
it has to know how to answer all the

00:04:06,229 --> 00:04:11,510
let's say final references week was

00:04:08,030 --> 00:04:13,489
accordingly and lastly well it's LSP

00:04:11,510 --> 00:04:16,930
servers so it has to respond using the

00:04:13,489 --> 00:04:20,449
LSP queries respond to all the speakers

00:04:16,930 --> 00:04:23,510
so it actually aims to reuse all the

00:04:20,449 --> 00:04:26,260
existing tools and it's probably a bad

00:04:23,510 --> 00:04:29,539
idea to just try and reimplementation

00:04:26,260 --> 00:04:33,169
ality again inside a different tool

00:04:29,539 --> 00:04:36,349
while we have all these awesome tools

00:04:33,169 --> 00:04:39,110
that are existent and supported and the

00:04:36,349 --> 00:04:41,599
rust ecosystem so for example when you

00:04:39,110 --> 00:04:43,669
want to format your document you can use

00:04:41,599 --> 00:04:45,560
rust format for that or when you want to

00:04:43,669 --> 00:04:47,840
analyze project structure you can use

00:04:45,560 --> 00:04:52,130
card go in the library auto-completion

00:04:47,840 --> 00:04:54,950
racer etc etc so in this regard are less

00:04:52,130 --> 00:04:57,380
actually aims to serve as a single point

00:04:54,950 --> 00:05:02,120
of entry for all the ID features you

00:04:57,380 --> 00:05:04,040
might want and you can get it now easily

00:05:02,120 --> 00:05:05,960
I assume almost everyone has rust of

00:05:04,040 --> 00:05:08,330
installed so the only thing you need to

00:05:05,960 --> 00:05:11,080
do is to run rust of component odds are

00:05:08,330 --> 00:05:14,030
less and if you have a less be compliant

00:05:11,080 --> 00:05:14,480
extension let's say and an editor you're

00:05:14,030 --> 00:05:17,510
good to go

00:05:14,480 --> 00:05:21,260
they're also like different extensions

00:05:17,510 --> 00:05:24,560
that are more rust and are less oriented

00:05:21,260 --> 00:05:26,810
as in you can click your where you click

00:05:24,560 --> 00:05:28,970
your way through and they will install

00:05:26,810 --> 00:05:31,550
rasta for you the appropriate tool chain

00:05:28,970 --> 00:05:33,919
and the component itself so right now

00:05:31,550 --> 00:05:37,850
for Visual Studio code the officially

00:05:33,919 --> 00:05:39,440
supported one is rust RLS and from last

00:05:37,850 --> 00:05:41,960
time I checked you get the same

00:05:39,440 --> 00:05:46,700
functionality installing the IDE rust

00:05:41,960 --> 00:05:48,830
package for atom okay so the

00:05:46,700 --> 00:05:51,229
capabilities and I'm going to demo that

00:05:48,830 --> 00:05:53,390
using Visual Studio codes because it's

00:05:51,229 --> 00:05:56,060
mostly supported I mean you can probably

00:05:53,390 --> 00:05:58,940
get the most support from the RLS right

00:05:56,060 --> 00:06:00,289
now and I recorded videos because I

00:05:58,940 --> 00:06:02,120
don't want to do live coding because

00:06:00,289 --> 00:06:04,789
there are a lot of new and try a new

00:06:02,120 --> 00:06:10,039
dimension for screw-ups with that so

00:06:04,789 --> 00:06:12,380
let's see if it works okay so first I'm

00:06:10,039 --> 00:06:15,050
going to talk about Diagnostics and it's

00:06:12,380 --> 00:06:16,520
probably very easily overlooked but it's

00:06:15,050 --> 00:06:18,560
just simple but the most essential

00:06:16,520 --> 00:06:21,229
feature as in it's probably the

00:06:18,560 --> 00:06:23,450
embodiment of the edits and cargo check

00:06:21,229 --> 00:06:28,340
cycle you must probably find ourselves

00:06:23,450 --> 00:06:30,229
in so when you edit your code you want

00:06:28,340 --> 00:06:33,850
to run cargo check to see if you have

00:06:30,229 --> 00:06:37,760
any errors or warnings then you fix them

00:06:33,850 --> 00:06:40,310
editor code again etc etc so it's very

00:06:37,760 --> 00:06:42,639
handy for the errors that are rusty

00:06:40,310 --> 00:06:49,400
generated to be displayed in line and

00:06:42,639 --> 00:06:51,830
let's see if it's gonna work out okay so

00:06:49,400 --> 00:06:53,810
we can see that there are error

00:06:51,830 --> 00:06:57,440
squiggles for this and the error comes

00:06:53,810 --> 00:06:59,240
from rusty compiler we can double check

00:06:57,440 --> 00:07:06,520
using cargo check and

00:06:59,240 --> 00:07:06,520
that's dope this is why

00:07:11,690 --> 00:07:17,420
okay you can believe me that deers are

00:07:14,780 --> 00:07:19,190
the same for the rusty and they were the

00:07:17,420 --> 00:07:22,430
one that was displayed and the ID itself

00:07:19,190 --> 00:07:25,400
so the next functionality that LSB also

00:07:22,430 --> 00:07:27,080
offers is horror so let's say you have

00:07:25,400 --> 00:07:29,750
your definition let's see a structure or

00:07:27,080 --> 00:07:31,490
a function and it has an associate

00:07:29,750 --> 00:07:34,910
documentation whether it's the dark

00:07:31,490 --> 00:07:38,060
comments these are also served by the

00:07:34,910 --> 00:07:41,150
LSP and the RLS itself so when you hover

00:07:38,060 --> 00:07:43,880
over the function let's say you also get

00:07:41,150 --> 00:07:45,850
an a tooltip the documentation and

00:07:43,880 --> 00:07:48,230
markdown so that's really convenient

00:07:45,850 --> 00:07:51,800
also you can see for a given identifier

00:07:48,230 --> 00:07:53,390
what type is it so you can see that for

00:07:51,800 --> 00:07:55,970
example it's a function that takes these

00:07:53,390 --> 00:07:58,460
arguments return that and it's very

00:07:55,970 --> 00:08:02,180
convenient let's say when you manipulate

00:07:58,460 --> 00:08:04,580
your data using some mapping etc so

00:08:02,180 --> 00:08:11,780
that's convenient to see the type of a

00:08:04,580 --> 00:08:14,360
given identifier so as you can see we

00:08:11,780 --> 00:08:16,990
are served also the documentation for it

00:08:14,360 --> 00:08:25,880
and it's the same as the one that's

00:08:16,990 --> 00:08:28,520
declared above next thing we have go to

00:08:25,880 --> 00:08:32,000
definition so it's also very convenient

00:08:28,520 --> 00:08:35,000
to be able to jump to where a given

00:08:32,000 --> 00:08:36,890
structure or function is defined most

00:08:35,000 --> 00:08:38,570
importantly to see for example how a

00:08:36,890 --> 00:08:40,789
structure is defined what are the

00:08:38,570 --> 00:08:43,640
members possibly there's also an in

00:08:40,789 --> 00:08:45,860
block nearby or in which context the

00:08:43,640 --> 00:08:48,770
given function is defined and this also

00:08:45,860 --> 00:08:50,390
allows us to strengthen the kind of

00:08:48,770 --> 00:08:58,850
mental connections the metal model of

00:08:50,390 --> 00:09:01,340
our project that we work on so this is

00:08:58,850 --> 00:09:02,960
pretty straightforward we have mix we

00:09:01,340 --> 00:09:05,420
issued go to definition and we

00:09:02,960 --> 00:09:09,680
automatically jump to a module

00:09:05,420 --> 00:09:12,010
containing that definition also we have

00:09:09,680 --> 00:09:14,090
find references this is also handy to

00:09:12,010 --> 00:09:15,860
realize what may be the

00:09:14,090 --> 00:09:17,840
interdependencies between modules so

00:09:15,860 --> 00:09:21,410
let's say we work on another module and

00:09:17,840 --> 00:09:24,140
we want to see in which other modules or

00:09:21,410 --> 00:09:25,330
parts of the codebase the symbols are

00:09:24,140 --> 00:09:28,520
full then and

00:09:25,330 --> 00:09:35,630
so it's also very convenient thing to

00:09:28,520 --> 00:09:37,820
have for example we can do that on the

00:09:35,630 --> 00:09:41,270
same example here and we were presented

00:09:37,820 --> 00:09:46,640
with two files and where a given symbol

00:09:41,270 --> 00:09:48,920
is defined or reference and last but not

00:09:46,640 --> 00:09:53,000
least I think one of the most definitive

00:09:48,920 --> 00:09:55,160
features of ID is code completion so I

00:09:53,000 --> 00:09:57,440
think it opens up an entire new

00:09:55,160 --> 00:09:59,810
dimension of learning which is learning

00:09:57,440 --> 00:10:01,870
about experimentation not only do you

00:09:59,810 --> 00:10:04,700
need to read through all the

00:10:01,870 --> 00:10:06,920
documentation of a project of a language

00:10:04,700 --> 00:10:08,570
although it is very much recommended to

00:10:06,920 --> 00:10:11,900
do that first

00:10:08,570 --> 00:10:14,390
but it it's basically your assistant

00:10:11,900 --> 00:10:17,090
that helps you while your code and you

00:10:14,390 --> 00:10:23,000
can see which symbols are valid inside a

00:10:17,090 --> 00:10:25,370
given context so this is a very simple

00:10:23,000 --> 00:10:29,560
example as I said we are served this is

00:10:25,370 --> 00:10:32,450
part by racer and we are served the

00:10:29,560 --> 00:10:35,180
suggestions for all the symbols that

00:10:32,450 --> 00:10:38,960
were defined locally in this in this

00:10:35,180 --> 00:10:41,780
context and for example after we type

00:10:38,960 --> 00:10:44,540
dot and after the structure we are

00:10:41,780 --> 00:10:47,390
served the data members and the

00:10:44,540 --> 00:10:49,790
functions that are valid for that

00:10:47,390 --> 00:10:53,300
structure and we can check that these

00:10:49,790 --> 00:10:55,760
are in fact the ones that all that are

00:10:53,300 --> 00:10:57,890
valid and we can double check that these

00:10:55,760 --> 00:11:02,590
suggestions are in fact valid and they

00:10:57,890 --> 00:11:06,170
work and the program compiles and works

00:11:02,590 --> 00:11:08,540
ok so with the demo uttered way let's

00:11:06,170 --> 00:11:12,230
talk about how cargo coordinates builds

00:11:08,540 --> 00:11:15,050
but first of all to talk about the RLS

00:11:12,230 --> 00:11:18,170
not cargo so why should our less butter

00:11:15,050 --> 00:11:20,660
well first of all as I said it leverages

00:11:18,170 --> 00:11:23,390
all the existing tools which is cargo

00:11:20,660 --> 00:11:25,910
also its uses it to analyze a project

00:11:23,390 --> 00:11:27,410
structure and schedule it built and it's

00:11:25,910 --> 00:11:31,160
good to know about that

00:11:27,410 --> 00:11:34,640
so we can reuse all the results to cache

00:11:31,160 --> 00:11:36,290
it and then reduce the latency for the

00:11:34,640 --> 00:11:38,660
user so the user doesn't have to wait

00:11:36,290 --> 00:11:42,550
three seconds you can right now wait

00:11:38,660 --> 00:11:45,620
two and a half that's an improvement

00:11:42,550 --> 00:11:48,079
okay so very simply I'm going to talk

00:11:45,620 --> 00:11:50,420
about from the RLS point of view what

00:11:48,079 --> 00:11:52,879
cargo does and even then I'm going to

00:11:50,420 --> 00:11:53,629
simplify a little bit to extract the

00:11:52,879 --> 00:11:56,449
gist of it

00:11:53,629 --> 00:11:59,209
so what cargo does is it looks at the

00:11:56,449 --> 00:12:02,569
declared package dependencies with using

00:11:59,209 --> 00:12:04,639
several constraints so let's say we can

00:12:02,569 --> 00:12:08,720
declare our dependency saying okay I

00:12:04,639 --> 00:12:11,000
need exactly version 1.2 point O for a

00:12:08,720 --> 00:12:13,730
given dependency or any other compatible

00:12:11,000 --> 00:12:16,550
with it so with this information with

00:12:13,730 --> 00:12:19,910
these dependency constraints we get a

00:12:16,550 --> 00:12:24,709
constraint graph dependency graph so

00:12:19,910 --> 00:12:27,829
what we do later is we resolve the

00:12:24,709 --> 00:12:31,519
constraints to actually specify packages

00:12:27,829 --> 00:12:33,410
there are the resulting data structure

00:12:31,519 --> 00:12:37,730
is a dependency directed acyclic graph

00:12:33,410 --> 00:12:41,120
between packages and let's delve deeper

00:12:37,730 --> 00:12:43,550
what it means and what it is so let's

00:12:41,120 --> 00:12:45,980
take an example web render which

00:12:43,550 --> 00:12:49,040
consists of three packages wrench web

00:12:45,980 --> 00:12:51,050
render and would render API so the graph

00:12:49,040 --> 00:12:53,529
has to be between packages at least at

00:12:51,050 --> 00:12:55,880
this point it has to be directed because

00:12:53,529 --> 00:12:58,579
dependency is very directed in its

00:12:55,880 --> 00:13:01,459
nature as in when a package a depends on

00:12:58,579 --> 00:13:04,459
B the B does not depend back on a it's

00:13:01,459 --> 00:13:08,269
only one way and it also has to be a

00:13:04,459 --> 00:13:09,829
cyclic because it's necessary to be able

00:13:08,269 --> 00:13:12,139
to know where to start when we want to

00:13:09,829 --> 00:13:14,870
issue a build so we can have cycles

00:13:12,139 --> 00:13:16,189
because if for in this example we want

00:13:14,870 --> 00:13:18,529
to build wrench then we have to build

00:13:16,189 --> 00:13:20,360
API first but it all depends on each

00:13:18,529 --> 00:13:22,759
other and we can do it so the graph has

00:13:20,360 --> 00:13:26,209
to be a cyclic and these properties

00:13:22,759 --> 00:13:29,029
actually guarantee that we can achieve a

00:13:26,209 --> 00:13:31,970
topological sorting of a graph so

00:13:29,029 --> 00:13:35,110
topological sorting what it is simply

00:13:31,970 --> 00:13:39,290
put from a build system point of view

00:13:35,110 --> 00:13:43,009
the order the linear order of a graph of

00:13:39,290 --> 00:13:46,430
how in which order can the packages be

00:13:43,009 --> 00:13:48,410
compelled so that's no point of time we

00:13:46,430 --> 00:13:50,120
are compiling a package for which its

00:13:48,410 --> 00:13:52,700
dependencies were not build before

00:13:50,120 --> 00:13:54,980
basically so in this example

00:13:52,700 --> 00:13:57,500
we can take web render API first because

00:13:54,980 --> 00:14:00,140
it does not depend on anything else then

00:13:57,500 --> 00:14:02,720
we render and then we can't build rent

00:14:00,140 --> 00:14:05,020
yet we have to build Sri before and

00:14:02,720 --> 00:14:07,790
after that as you can see the numbers

00:14:05,020 --> 00:14:11,450
create the linear ordering of a given

00:14:07,790 --> 00:14:13,670
graph and there's no only one ordering

00:14:11,450 --> 00:14:17,050
for a given graph most often there are

00:14:13,670 --> 00:14:20,270
many but I guess you can pick one and

00:14:17,050 --> 00:14:23,450
then when we have that we need to

00:14:20,270 --> 00:14:27,200
transform it into a dependency dag

00:14:23,450 --> 00:14:30,020
between package targets so we have to go

00:14:27,200 --> 00:14:32,300
lever down let's say more fine-grained

00:14:30,020 --> 00:14:35,330
on a more fine-grained level so what

00:14:32,300 --> 00:14:37,400
package target is is that package can

00:14:35,330 --> 00:14:40,610
have multiple targets so let's have any

00:14:37,400 --> 00:14:43,790
binary target library targets and above

00:14:40,610 --> 00:14:45,710
script targets and the way it works is

00:14:43,790 --> 00:14:48,560
that it creates an implicit dependency

00:14:45,710 --> 00:14:50,720
between those as an we have to first

00:14:48,560 --> 00:14:52,490
build and compile the both script to

00:14:50,720 --> 00:14:53,930
let's say prepare the environment for

00:14:52,490 --> 00:14:56,750
which the rest of the package can be

00:14:53,930 --> 00:14:58,760
built and then since the library hosts

00:14:56,750 --> 00:15:01,640
most of the implementation and the API

00:14:58,760 --> 00:15:06,860
no not it has to be both first before we

00:15:01,640 --> 00:15:08,450
build binary that uses it so equipped

00:15:06,860 --> 00:15:10,760
with that knowledge we can very easily

00:15:08,450 --> 00:15:13,010
transform the dependency graph between

00:15:10,760 --> 00:15:15,980
packages into dependency graph between

00:15:13,010 --> 00:15:18,410
package targets and there's also a small

00:15:15,980 --> 00:15:20,870
caveat here that when a package depends

00:15:18,410 --> 00:15:25,010
on another one it implicitly depends on

00:15:20,870 --> 00:15:26,390
its library package target and this

00:15:25,010 --> 00:15:28,730
transformation retains all the

00:15:26,390 --> 00:15:30,560
properties as in the graph can also be

00:15:28,730 --> 00:15:35,510
topologically sorted and used to

00:15:30,560 --> 00:15:37,910
schedule a built so we can sure that as

00:15:35,510 --> 00:15:40,040
I said then we get the ordering of

00:15:37,910 --> 00:15:43,460
package targets and how this is very

00:15:40,040 --> 00:15:45,800
convenient is that this almost Maps one

00:15:43,460 --> 00:15:49,100
to one to appropriate receipt and

00:15:45,800 --> 00:15:51,380
vacations so after we did that the only

00:15:49,100 --> 00:15:54,050
thing cargo still has to do is to

00:15:51,380 --> 00:15:56,570
schedule and spawn Russy process and

00:15:54,050 --> 00:16:01,640
processes that's the data coordinated

00:15:56,570 --> 00:16:03,470
etc okay so with this out of the way

00:16:01,640 --> 00:16:06,620
let's talk about supporting cargo

00:16:03,470 --> 00:16:08,990
workspaces but first of all

00:16:06,620 --> 00:16:12,920
what's a workspace so let's take a look

00:16:08,990 --> 00:16:14,510
what cargo new creates by default so by

00:16:12,920 --> 00:16:17,090
default it creates a single package

00:16:14,510 --> 00:16:18,980
project so there's a cargo door lock

00:16:17,090 --> 00:16:20,930
file with all the resolve dependencies

00:16:18,980 --> 00:16:22,370
which is basically the resolve

00:16:20,930 --> 00:16:25,160
dependency graph that I told you about

00:16:22,370 --> 00:16:26,870
and the target directory for the build

00:16:25,160 --> 00:16:29,720
artifacts that are created during the

00:16:26,870 --> 00:16:31,700
build and obviously also there is an

00:16:29,720 --> 00:16:32,680
actual package with its manifest file

00:16:31,700 --> 00:16:36,170
apartment amo

00:16:32,680 --> 00:16:38,480
so how workspaces differ from the single

00:16:36,170 --> 00:16:40,700
package project is that we still have

00:16:38,480 --> 00:16:43,520
the same lock file and the target

00:16:40,700 --> 00:16:46,040
directory but now the main package is

00:16:43,520 --> 00:16:48,950
optional and we can explicitly specify

00:16:46,040 --> 00:16:53,780
all the member packages inside a project

00:16:48,950 --> 00:16:56,510
so it can host multiple packages so how

00:16:53,780 --> 00:16:58,550
the RLS operated up and up until this

00:16:56,510 --> 00:17:01,880
point is that it's supported only a

00:16:58,550 --> 00:17:04,190
single package target which is quite

00:17:01,880 --> 00:17:07,010
limiting as you can guess because even a

00:17:04,190 --> 00:17:09,860
single package can contain binary and

00:17:07,010 --> 00:17:12,040
library so even if you want to work on

00:17:09,860 --> 00:17:14,300
your library you only get the

00:17:12,040 --> 00:17:18,110
Diagnostics the warnings and the ID

00:17:14,300 --> 00:17:21,170
features only for the library but as is

00:17:18,110 --> 00:17:24,290
most um most often the case the package

00:17:21,170 --> 00:17:25,730
is split into binary and library and

00:17:24,290 --> 00:17:28,610
library hosts almost all of the

00:17:25,730 --> 00:17:31,370
implementation and binary is mostly a

00:17:28,610 --> 00:17:34,220
thin wrapper around that so when we

00:17:31,370 --> 00:17:36,560
switch to actually supporting bin we

00:17:34,220 --> 00:17:38,720
lose all the ID features for the lip

00:17:36,560 --> 00:17:41,570
which is the most part of the program so

00:17:38,720 --> 00:17:45,860
it's very limiting at this point so how

00:17:41,570 --> 00:17:47,900
did how it works in this mode is that it

00:17:45,860 --> 00:17:52,400
runs cargo procedure first when

00:17:47,900 --> 00:17:55,220
analyzing a project and it stores the

00:17:52,400 --> 00:17:58,940
final compiler invocation that cargo

00:17:55,220 --> 00:18:02,360
issued and you can configure it right

00:17:58,940 --> 00:18:04,610
now with rust dot build underscore bin

00:18:02,360 --> 00:18:07,280
andross build underscore live options

00:18:04,610 --> 00:18:09,590
obviously any LSP supporting clients

00:18:07,280 --> 00:18:12,500
that support the configuration API will

00:18:09,590 --> 00:18:18,170
do but right now I think only the rusts

00:18:12,500 --> 00:18:20,510
extension for the vs code does so let's

00:18:18,170 --> 00:18:23,230
see how that works and that we get this

00:18:20,510 --> 00:18:26,090
between binary and library so we have

00:18:23,230 --> 00:18:27,770
Diagnostics only for library here as we

00:18:26,090 --> 00:18:31,160
can see this is a simple package that is

00:18:27,770 --> 00:18:33,230
split into a Lib and bin so we changed

00:18:31,160 --> 00:18:36,470
the configuration to analyze the binary

00:18:33,230 --> 00:18:38,570
and as we can see it flipped to for the

00:18:36,470 --> 00:18:40,910
Diagnostics for the binary so we lost

00:18:38,570 --> 00:18:46,040
all the information and the Diagnostics

00:18:40,910 --> 00:18:47,600
for the library and the newly

00:18:46,040 --> 00:18:50,420
implemented mode which is still

00:18:47,600 --> 00:18:53,900
experimental and your mileage may vary

00:18:50,420 --> 00:18:56,450
as the workspace mode so how does that

00:18:53,900 --> 00:18:58,430
differ from the previous one is that I

00:18:56,450 --> 00:19:00,650
told you the previous one only caches

00:18:58,430 --> 00:19:03,080
the last invocation while in the

00:19:00,650 --> 00:19:05,390
workspace mode we teach are less about

00:19:03,080 --> 00:19:08,270
the interdependencies between packets

00:19:05,390 --> 00:19:10,490
targets and thus between packages so we

00:19:08,270 --> 00:19:13,430
are able to fetch all the Diagnostics

00:19:10,490 --> 00:19:16,040
data for each target and end result for

00:19:13,430 --> 00:19:18,590
each package and because it's still

00:19:16,040 --> 00:19:20,750
unstable you need to enable its feature

00:19:18,590 --> 00:19:23,600
is behind a future gate : stable

00:19:20,750 --> 00:19:26,230
features so you need to enable both the

00:19:23,600 --> 00:19:28,730
stable features and the workspace mode

00:19:26,230 --> 00:19:32,390
so let's see how this implementation

00:19:28,730 --> 00:19:35,590
actually helped for single package that

00:19:32,390 --> 00:19:35,590
is split until they've been bin

00:19:40,650 --> 00:19:45,900
so as previously we only have

00:19:43,170 --> 00:19:48,900
Diagnostics for the binary so when we

00:19:45,900 --> 00:19:51,540
toggle the option we can see that we are

00:19:48,900 --> 00:19:56,550
fed the Diagnostics for both package

00:19:51,540 --> 00:19:58,830
targets which is good and with this

00:19:56,550 --> 00:20:01,410
let's see how it actually helped how the

00:19:58,830 --> 00:20:06,690
workspace mode helps for supporting

00:20:01,410 --> 00:20:10,740
actual workspaces so this is a simple

00:20:06,690 --> 00:20:17,520
workspace it has two members literally

00:20:10,740 --> 00:20:20,010
called first and second their first one

00:20:17,520 --> 00:20:24,690
depends on the second one as you can see

00:20:20,010 --> 00:20:27,000
in the manifest file and the code

00:20:24,690 --> 00:20:29,970
obviously should not compile but we are

00:20:27,000 --> 00:20:33,030
not fed any diagnostics and we can use

00:20:29,970 --> 00:20:38,280
any features for it so let's try

00:20:33,030 --> 00:20:42,690
flipping the switch to on for the

00:20:38,280 --> 00:20:43,820
workspace mode and sits in sits since

00:20:42,690 --> 00:20:46,740
it's unstable

00:20:43,820 --> 00:20:49,740
sometimes it's best to just reload it

00:20:46,740 --> 00:20:57,929
and restart it with the workspace mode

00:20:49,740 --> 00:21:01,410
on and we need to wait a bit and here we

00:20:57,929 --> 00:21:03,179
go we are served diagnostics and we also

00:21:01,410 --> 00:21:11,250
get the outer completion inside a

00:21:03,179 --> 00:21:13,830
workspace okay so simply how does it

00:21:11,250 --> 00:21:16,559
work how the how is the workspace mode

00:21:13,830 --> 00:21:18,410
implemented and how does it differ well

00:21:16,559 --> 00:21:21,809
first of all we need to cache the

00:21:18,410 --> 00:21:23,760
structure that is used by cargo that

00:21:21,809 --> 00:21:26,640
cargo generates between packets targets

00:21:23,760 --> 00:21:29,880
and when we have that we can then easily

00:21:26,640 --> 00:21:32,670
map the dirty packages sort the result

00:21:29,880 --> 00:21:34,650
and get the appropriate compiler

00:21:32,670 --> 00:21:37,140
invocations that the RLS can actually

00:21:34,650 --> 00:21:42,059
execute and fetch the data and analysis

00:21:37,140 --> 00:21:44,910
from so first as I said we use a

00:21:42,059 --> 00:21:47,820
heuristic we map dirty files since last

00:21:44,910 --> 00:21:49,710
successful analysis built for

00:21:47,820 --> 00:21:52,350
appropriate package targets inside a

00:21:49,710 --> 00:21:54,269
graph so in this example we modified the

00:21:52,350 --> 00:21:55,919
library of web render

00:21:54,269 --> 00:21:58,200
then when we modify in quick succession

00:21:55,919 --> 00:22:02,549
let's say bill script of wrench we also

00:21:58,200 --> 00:22:05,279
mark that mark that and then after the

00:22:02,549 --> 00:22:08,339
build is scheduled and actually executed

00:22:05,279 --> 00:22:10,309
we have to perform another step which is

00:22:08,339 --> 00:22:12,929
mark all the transitive dependencies

00:22:10,309 --> 00:22:15,749
because in this case when we let's say

00:22:12,929 --> 00:22:19,109
when we have analysis data we modify the

00:22:15,749 --> 00:22:21,839
both scripts we still have to recompile

00:22:19,109 --> 00:22:23,459
and fetch results from the binary which

00:22:21,839 --> 00:22:26,159
depends on it because it might be

00:22:23,459 --> 00:22:29,070
invalidated by any recompilation of the

00:22:26,159 --> 00:22:31,139
build script so when we have that when

00:22:29,070 --> 00:22:34,289
we have diagraph we can then easily

00:22:31,139 --> 00:22:37,259
topologically sorted again we get the

00:22:34,289 --> 00:22:41,249
same ordering we had when with what

00:22:37,259 --> 00:22:43,499
cargo did previously we use the cached

00:22:41,249 --> 00:22:47,820
compiler invocations which we captured

00:22:43,499 --> 00:22:50,249
during running cargo build procedure and

00:22:47,820 --> 00:22:53,099
then we actually have to run in process

00:22:50,249 --> 00:22:55,409
compiler so how does that how does that

00:22:53,099 --> 00:22:58,499
differ from what cargo does is that

00:22:55,409 --> 00:23:02,419
cargo spawns new processes for each

00:22:58,499 --> 00:23:05,159
compiler invocation and this actually

00:23:02,419 --> 00:23:08,099
won't do for the our last case because

00:23:05,159 --> 00:23:10,469
there's a significant overhead for when

00:23:08,099 --> 00:23:13,859
we want to omit the safe analysis data

00:23:10,469 --> 00:23:15,899
which is an annotation love to the disk

00:23:13,859 --> 00:23:18,329
only to be read later so we're talking

00:23:15,899 --> 00:23:20,219
about Meg's of text data that is only

00:23:18,329 --> 00:23:23,039
written to disk without any purpose so

00:23:20,219 --> 00:23:25,559
we passed that in memory so there is a

00:23:23,039 --> 00:23:27,809
small caveat here also we have to take

00:23:25,559 --> 00:23:30,209
care of all the environment variables

00:23:27,809 --> 00:23:33,349
that are set for by cargo for each

00:23:30,209 --> 00:23:36,809
package so when we actually do that

00:23:33,349 --> 00:23:39,239
we run it linearly we coordinate the

00:23:36,809 --> 00:23:43,079
environment for each package we collect

00:23:39,239 --> 00:23:48,509
the results and then it actually works

00:23:43,079 --> 00:23:50,629
inside a bigger workspace okay so that's

00:23:48,509 --> 00:23:54,089
how supporting workspaces work and

00:23:50,629 --> 00:23:57,290
that's how rest language server first

00:23:54,089 --> 00:24:05,450
right now thank you

00:23:57,290 --> 00:24:08,100
[Applause]

00:24:05,450 --> 00:24:10,770
so if you have any questions I guess it

00:24:08,100 --> 00:24:12,960
would be better to just catch me and ask

00:24:10,770 --> 00:24:16,800
me directly I hope you have many

00:24:12,960 --> 00:24:19,260
questions so we have time oh oh you

00:24:16,800 --> 00:24:22,860
don't want to craft restaurants I mean

00:24:19,260 --> 00:24:25,440
true no we have how many minutes two

00:24:22,860 --> 00:24:29,880
questions okay we can do that also

00:24:25,440 --> 00:24:39,060
two questions over here and next one

00:24:29,880 --> 00:24:42,000
over there so at the start you said with

00:24:39,060 --> 00:24:46,380
the RLS and the LSP don't need n times

00:24:42,000 --> 00:24:48,870
and plugins and plus n but then you said

00:24:46,380 --> 00:24:53,430
you should install the vs code RLS

00:24:48,870 --> 00:24:57,210
plug-in how like how big is the specific

00:24:53,430 --> 00:25:00,510
plugin for virtual studio is it just a

00:24:57,210 --> 00:25:02,580
small shim to like setting up or is

00:25:00,510 --> 00:25:04,740
there actually law code in it no so

00:25:02,580 --> 00:25:07,890
actually Microsoft developed the

00:25:04,740 --> 00:25:09,930
standard because the the LSP actually is

00:25:07,890 --> 00:25:12,420
developing Microsoft they also developed

00:25:09,930 --> 00:25:14,130
vs code so it was actually very handy

00:25:12,420 --> 00:25:16,860
and convenient for them to implement a

00:25:14,130 --> 00:25:19,710
generic LSP client first and they expose

00:25:16,860 --> 00:25:22,350
it as a library so how the rust

00:25:19,710 --> 00:25:25,130
extension works is that it loads a bulk

00:25:22,350 --> 00:25:27,270
of the LSP it uploads all the LSP

00:25:25,130 --> 00:25:29,400
responsibilities to the library that's

00:25:27,270 --> 00:25:33,720
created by Microsoft and I think the

00:25:29,400 --> 00:25:36,210
rust specific parts are like 5% 10% of

00:25:33,720 --> 00:25:39,480
the overall size of the extension I

00:25:36,210 --> 00:25:43,500
guess so not not much it mostly handles

00:25:39,480 --> 00:25:45,240
configuration in a custom way and also

00:25:43,500 --> 00:25:48,980
installs the rest of tool chain and

00:25:45,240 --> 00:25:51,150
component and whatnot so it's helpful

00:25:48,980 --> 00:25:55,080
all right another question over here

00:25:51,150 --> 00:25:58,830
yeah so my question is you mentioned

00:25:55,080 --> 00:26:01,380
that you use rusty and cargo itself

00:25:58,830 --> 00:26:05,670
already but it sounds like you do a lot

00:26:01,380 --> 00:26:08,360
of the tasks that would be the job of

00:26:05,670 --> 00:26:13,710
those things instead in RLS itself

00:26:08,360 --> 00:26:15,450
specifically the compilation ordering

00:26:13,710 --> 00:26:18,990
and stuff like that so is that something

00:26:15,450 --> 00:26:23,130
you do in RLS or is that something that

00:26:18,990 --> 00:26:27,330
rusty does which exact part if you can

00:26:23,130 --> 00:26:29,310
repeat like why do we apply the question

00:26:27,330 --> 00:26:30,270
sorry the stuff that you talked about

00:26:29,310 --> 00:26:32,430
today

00:26:30,270 --> 00:26:36,300
it sounds like you do a lot of that

00:26:32,430 --> 00:26:38,610
yourself in RLS but it sounds to me it

00:26:36,300 --> 00:26:40,410
sounds like that's a job for rusty so

00:26:38,610 --> 00:26:43,770
how much do you did it yourself and how

00:26:40,410 --> 00:26:46,560
much of that is delegated to rusty I'm

00:26:43,770 --> 00:26:48,900
not exactly sure how much rusty does I

00:26:46,560 --> 00:26:51,330
mean it can it is capable of creating

00:26:48,900 --> 00:26:53,700
all the DEP and fo for the packages

00:26:51,330 --> 00:26:55,830
themselves but right now we use the

00:26:53,700 --> 00:26:58,620
heuristic for mapping the dirty files to

00:26:55,830 --> 00:27:01,260
does is that what you're asking more or

00:26:58,620 --> 00:27:03,360
less yeah yes okay okay so right now we

00:27:01,260 --> 00:27:05,700
use a heuristic as I said but probably

00:27:03,360 --> 00:27:07,590
we can just switch to mark exactly to

00:27:05,700 --> 00:27:10,830
use to consume the DEP and for files

00:27:07,590 --> 00:27:14,130
that rusty a myth and it's so but right

00:27:10,830 --> 00:27:16,860
now we don't do it yet all right Thank

00:27:14,130 --> 00:27:23,380
You Igor okay thanks

00:27:16,860 --> 00:27:23,380

YouTube URL: https://www.youtube.com/watch?v=-OPc_XvVLVs


