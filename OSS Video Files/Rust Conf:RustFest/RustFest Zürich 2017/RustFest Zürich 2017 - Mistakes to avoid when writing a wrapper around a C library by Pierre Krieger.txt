Title: RustFest Zürich 2017 - Mistakes to avoid when writing a wrapper around a C library by Pierre Krieger
Publication date: 2017-10-21
Playlist: RustFest Zürich 2017
Description: 
	Do you need to perform a certain task in Rust? Why not pick a mature C library that already does what you want, and write a wrapping library around it?

Writing a wrapping library is sometimes not as easy as one could think, and you will probably make mistakes that will make you lose time or even make your wrapper unsound.

This talk will show you the most common safety problems you may not have thought of, such as leak safety, but will also give you advices on what not to do when designing the API of your library.

About Pierre Krieger:
After coding in C++ for about ten years, Pierre switched to Rust in 2014 and has been maintaining several game-development-related libraries. He specializes in graphics programming.
Captions: 
	00:00:12,420 --> 00:00:17,040
so hello hello everybody my name is

00:00:14,580 --> 00:00:20,640
Pierre Tiger also known as Tanaka on

00:00:17,040 --> 00:00:23,010
github and this talk is named the top 9

00:00:20,640 --> 00:00:25,110
most common mistakes to avoid when you

00:00:23,010 --> 00:00:32,460
start writing a wrapper around a seed

00:00:25,110 --> 00:00:35,430
library but before getting started let's

00:00:32,460 --> 00:00:38,370
define what a wrapper is so the idea is

00:00:35,430 --> 00:00:40,950
that a wrapper is simply a regular rest

00:00:38,370 --> 00:00:44,120
diary but that acts as a bridge between

00:00:40,950 --> 00:00:49,260
rust and C which are two different word

00:00:44,120 --> 00:00:52,859
rust is safe and C is unsafe rust rust

00:00:49,260 --> 00:00:54,840
and C have different kind of api's the

00:00:52,859 --> 00:00:58,320
wrapper is here to make a bridge between

00:00:54,840 --> 00:01:01,350
the two but writing a wrapper is not an

00:00:58,320 --> 00:01:03,539
easy task and and can be very difficult

00:01:01,350 --> 00:01:08,310
because of the differences between two

00:01:03,539 --> 00:01:10,680
languages so here are and these

00:01:08,310 --> 00:01:12,900
differences can introduce mistakes in

00:01:10,680 --> 00:01:15,270
your code so here are the biggest

00:01:12,900 --> 00:01:18,750
mistakes or not the biggest but most

00:01:15,270 --> 00:01:23,189
common mistakes I see in Ivor is in the

00:01:18,750 --> 00:01:26,040
ecosystem mistake number 9 not catching

00:01:23,189 --> 00:01:26,700
rust panics within fallbacks code by C

00:01:26,040 --> 00:01:29,970
library

00:01:26,700 --> 00:01:32,759
so when you see library uses a callback

00:01:29,970 --> 00:01:35,220
based design so your register a callback

00:01:32,759 --> 00:01:37,470
and this callback caused our rest

00:01:35,220 --> 00:01:40,979
function one thing that can be easy to

00:01:37,470 --> 00:01:45,420
forget is that the C language is not

00:01:40,979 --> 00:01:48,740
capable of handling rust panics so the

00:01:45,420 --> 00:01:51,000
code here is dangerous because if

00:01:48,740 --> 00:01:54,570
user-provided function that may panic

00:01:51,000 --> 00:01:56,460
actually panics then bad things are

00:01:54,570 --> 00:01:59,820
going to happen the stock is going to

00:01:56,460 --> 00:02:02,030
unwind into C code and everything is

00:01:59,820 --> 00:02:05,340
going to fall apart and probably crush

00:02:02,030 --> 00:02:08,070
instead you always have to use the catch

00:02:05,340 --> 00:02:12,180
and win function which was introduced

00:02:08,070 --> 00:02:15,840
this morning by the way it's good

00:02:12,180 --> 00:02:18,270
coincidence as always wrap your rest

00:02:15,840 --> 00:02:21,209
code are on our own catch n winds and

00:02:18,270 --> 00:02:24,209
handover result I was asked earlier

00:02:21,209 --> 00:02:26,349
today how you are supposed to handle

00:02:24,209 --> 00:02:28,420
errors in these situations

00:02:26,349 --> 00:02:30,430
and it really depends on the sitar we

00:02:28,420 --> 00:02:33,280
sometimes you just need to abort you

00:02:30,430 --> 00:02:35,560
have no real choice sometimes you can

00:02:33,280 --> 00:02:37,599
use a pointing system but it really

00:02:35,560 --> 00:02:42,609
depends on C libraries case-by-case

00:02:37,599 --> 00:02:46,000
situation okay mistake number ain't not

00:02:42,609 --> 00:02:48,909
testing your rapper on a large scale so

00:02:46,000 --> 00:02:52,840
that's obviously more easily said and

00:02:48,909 --> 00:02:54,790
done but yeah but I really advise you to

00:02:52,840 --> 00:02:57,849
write at the same time at the same time

00:02:54,790 --> 00:03:00,489
your rapper and a large scale project

00:02:57,849 --> 00:03:03,909
that actually uses your rapper and

00:03:00,489 --> 00:03:06,849
that's very useful because it's going to

00:03:03,909 --> 00:03:08,709
let you find flows in your API things

00:03:06,849 --> 00:03:11,439
you didn't necessary you didn't

00:03:08,709 --> 00:03:14,560
necessarily think about and talks it

00:03:11,439 --> 00:03:18,459
also acts as a giant test suit whenever

00:03:14,560 --> 00:03:22,389
you make modification your app that's

00:03:18,459 --> 00:03:24,849
not really trivial you can just execute

00:03:22,389 --> 00:03:26,639
your big your large-scale project and

00:03:24,849 --> 00:03:30,430
see if it still works

00:03:26,639 --> 00:03:32,019
of course that's not very proof but if

00:03:30,430 --> 00:03:34,689
it doesn't work at least you know you

00:03:32,019 --> 00:03:40,750
have a problem so it's kind of a giant

00:03:34,689 --> 00:03:42,939
astute mistake number seven assuming

00:03:40,750 --> 00:03:46,750
that structs and enums have a certain

00:03:42,939 --> 00:03:49,030
layout so for example in the code at the

00:03:46,750 --> 00:03:52,239
top you have a strict strict name foo

00:03:49,030 --> 00:03:56,769
with two fields in a and b.a you eight

00:03:52,239 --> 00:03:59,530
and you thirty-two and the mistake here

00:03:56,769 --> 00:04:02,470
would be to assume that bean comes after

00:03:59,530 --> 00:04:05,319
eight in memory while in reality it's

00:04:02,470 --> 00:04:08,319
not necessarily the case the compiler is

00:04:05,319 --> 00:04:08,919
free to optimize just layout of its

00:04:08,319 --> 00:04:11,379
tracks

00:04:08,919 --> 00:04:14,469
as it wishes so I think I'm not sure

00:04:11,379 --> 00:04:16,690
that I think but right now it's not the

00:04:14,469 --> 00:04:19,509
case right now the compiler isn't going

00:04:16,690 --> 00:04:21,729
to optimize anything but it could be the

00:04:19,509 --> 00:04:25,449
case in the future anyway if that's not

00:04:21,729 --> 00:04:28,659
the case yet I'm not sure actually so if

00:04:25,449 --> 00:04:31,389
you want to be to be bulletproof here

00:04:28,659 --> 00:04:34,449
you should not assume that D comes after

00:04:31,389 --> 00:04:38,139
eighteen memory if you really need or if

00:04:34,449 --> 00:04:39,940
you need to ensure that being actually

00:04:38,139 --> 00:04:42,850
comes after eight you have to use

00:04:39,940 --> 00:04:44,640
rep receipt annotation and that forces

00:04:42,850 --> 00:04:47,440
the layout

00:04:44,640 --> 00:04:49,960
similarly something that's you can

00:04:47,440 --> 00:04:52,510
sometimes sign in rust libraries that's

00:04:49,960 --> 00:04:55,300
not necessarily related to see libraries

00:04:52,510 --> 00:04:58,300
but that's also a problem in general is

00:04:55,300 --> 00:05:01,270
when people transmute between arrays and

00:04:58,300 --> 00:05:03,430
tuples but that's actually we're

00:05:01,270 --> 00:05:06,760
dangerous because for the same reason as

00:05:03,430 --> 00:05:10,060
I just explained the compiler does not

00:05:06,760 --> 00:05:12,670
necessarily put two elements of a tuple

00:05:10,060 --> 00:05:15,030
right next to each other even for right

00:05:12,670 --> 00:05:18,370
now it's the case for that I'm sure

00:05:15,030 --> 00:05:21,310
right now it's the case but it's not

00:05:18,370 --> 00:05:27,820
totally sure that it's going to be

00:05:21,310 --> 00:05:31,030
always the case so don't do that mistake

00:05:27,820 --> 00:05:33,790
number six trying to write a high level

00:05:31,030 --> 00:05:36,610
abstraction first so in this example

00:05:33,790 --> 00:05:39,910
code you have a create objects function

00:05:36,610 --> 00:05:43,750
I put it in an external blog to show

00:05:39,910 --> 00:05:46,570
that it represents the API of C library

00:05:43,750 --> 00:05:49,600
so the C library provides a function in

00:05:46,570 --> 00:05:53,410
create objects which take an array s

00:05:49,600 --> 00:05:55,930
parameter in the form of a pointer and a

00:05:53,410 --> 00:05:58,540
number of elements and I inverted the

00:05:55,930 --> 00:06:01,450
two parameter usually is a pointer first

00:05:58,540 --> 00:06:04,150
but whatever and the create object

00:06:01,450 --> 00:06:07,410
function create objects function creates

00:06:04,150 --> 00:06:10,840
a number of objects equal to new objects

00:06:07,410 --> 00:06:14,200
but since you're trying to provide a

00:06:10,840 --> 00:06:18,370
nice API over this in rust what you do

00:06:14,200 --> 00:06:20,860
is create a type named object a struct

00:06:18,370 --> 00:06:25,240
which wraps around the concept of an

00:06:20,860 --> 00:06:28,510
object and you provide a function mu

00:06:25,240 --> 00:06:30,790
which calls create objects and only

00:06:28,510 --> 00:06:32,680
creates one object because that's what

00:06:30,790 --> 00:06:36,460
people we do most of the time and that's

00:06:32,680 --> 00:06:40,540
what's convenient but if you do that

00:06:36,460 --> 00:06:42,910
what is going to happen sooner or later

00:06:40,540 --> 00:06:44,790
is that someone is going to open an

00:06:42,910 --> 00:06:48,760
issue in universe in your repository

00:06:44,790 --> 00:06:52,390
saying that they call the new function

00:06:48,760 --> 00:06:53,770
thousands of times and since the c

00:06:52,390 --> 00:06:57,250
library could create

00:06:53,770 --> 00:07:01,060
it's a thousand objects at once they are

00:06:57,250 --> 00:07:05,110
going to wonder if how they could do so

00:07:01,060 --> 00:07:09,520
with your wrapper you have to solution

00:07:05,110 --> 00:07:12,759
to handle this issue either you say I'm

00:07:09,520 --> 00:07:14,710
too lazy to fix this or you take a lot

00:07:12,759 --> 00:07:16,270
of time to rewrite your library of

00:07:14,710 --> 00:07:18,849
course here is it simple it's a simple

00:07:16,270 --> 00:07:20,560
situation so it's not going to take a

00:07:18,849 --> 00:07:22,900
lot of the time to fix this

00:07:20,560 --> 00:07:26,110
but in a real large-scale wrapper it's

00:07:22,900 --> 00:07:29,550
going to take a lot of time the so by

00:07:26,110 --> 00:07:32,020
the way that's a bit caricatural in

00:07:29,550 --> 00:07:34,680
reality you shouldn't hesitate about

00:07:32,020 --> 00:07:38,169
open issues do not think that

00:07:34,680 --> 00:07:39,970
complaining usually he is do not think

00:07:38,169 --> 00:07:42,039
that it's annoying to open issue it's

00:07:39,970 --> 00:07:47,280
better to have too many issues when to

00:07:42,039 --> 00:07:51,520
view what I advise you to do is first

00:07:47,280 --> 00:07:52,840
write an API but is as close to Bercy

00:07:51,520 --> 00:07:55,810
library as possible

00:07:52,840 --> 00:07:58,479
but by but still remain safe while doing

00:07:55,810 --> 00:08:00,940
so you're out your IP I should still be

00:07:58,479 --> 00:08:05,009
safe but it should be as close to the C

00:08:00,940 --> 00:08:08,289
API as possible so in the example here

00:08:05,009 --> 00:08:12,150
here result here is all here is how you

00:08:08,289 --> 00:08:14,940
fix this you first write a create object

00:08:12,150 --> 00:08:17,860
as a pointer here

00:08:14,940 --> 00:08:20,080
whatever you first write a create

00:08:17,860 --> 00:08:22,870
objects rather a wrapper on create

00:08:20,080 --> 00:08:25,599
objects but directly calls the C

00:08:22,870 --> 00:08:28,090
function create objects that can return

00:08:25,599 --> 00:08:31,300
any number of objects as an indeed and

00:08:28,090 --> 00:08:34,539
then on top of create objects you add

00:08:31,300 --> 00:08:37,089
another function in foo which creates Y

00:08:34,539 --> 00:08:40,120
which creates one object so you have a

00:08:37,089 --> 00:08:41,979
but the best of both worlds people who

00:08:40,120 --> 00:08:44,079
need to create thousands of objects at

00:08:41,979 --> 00:08:47,920
work at once can simply call create

00:08:44,079 --> 00:08:50,200
objects and most people who are just

00:08:47,920 --> 00:08:53,020
looking for a convenient API we just

00:08:50,200 --> 00:08:55,779
call new but what I advise you is to

00:08:53,020 --> 00:08:57,970
first write create objects first write a

00:08:55,779 --> 00:09:02,740
wrapper around create objects and then

00:08:57,970 --> 00:09:05,199
only you call new and then later if

00:09:02,740 --> 00:09:08,730
needed you can always optimize new to be

00:09:05,199 --> 00:09:12,519
more efficient if that's needed

00:09:08,730 --> 00:09:14,439
mistake number five ignoring the problem

00:09:12,519 --> 00:09:18,339
of leak safety and we're going to play a

00:09:14,439 --> 00:09:22,959
little game try to spot the problem so

00:09:18,339 --> 00:09:28,019
here is from here on it's going to get a

00:09:22,959 --> 00:09:31,720
big more trickier so we have a capi

00:09:28,019 --> 00:09:34,569
represented by the external block the C

00:09:31,720 --> 00:09:38,139
API provides an object named foo which I

00:09:34,569 --> 00:09:41,170
didn't show here for the sake of being a

00:09:38,139 --> 00:09:43,660
brief and there are three functions one

00:09:41,170 --> 00:09:46,420
function to lock a foo one function to

00:09:43,660 --> 00:09:49,480
unlock it once it's locked and one

00:09:46,420 --> 00:09:51,970
function named do something which must

00:09:49,480 --> 00:09:54,490
not be used waifu is locked that's what

00:09:51,970 --> 00:09:56,559
the c library says do not call do

00:09:54,490 --> 00:10:00,879
something what wild of who is locked

00:09:56,559 --> 00:10:03,189
because i don't handle that and your

00:10:00,879 --> 00:10:05,410
rust wrapper that your attack that

00:10:03,189 --> 00:10:07,720
you're writing provides a wrapper around

00:10:05,410 --> 00:10:11,679
the concept of a foo which i named here

00:10:07,720 --> 00:10:13,709
foo brother it provides two function two

00:10:11,679 --> 00:10:16,869
functions do something unlock which

00:10:13,709 --> 00:10:19,079
simply call the c functions directly

00:10:16,869 --> 00:10:22,809
they just cover c functions directly

00:10:19,079 --> 00:10:25,689
except that the lock function returns a

00:10:22,809 --> 00:10:29,949
guard objects if you're familiar with

00:10:25,689 --> 00:10:32,649
the concept of AII in c++ that's exactly

00:10:29,949 --> 00:10:35,949
the same principle the lock method

00:10:32,649 --> 00:10:39,730
returns an object named locked named

00:10:35,949 --> 00:10:42,040
lock which represents the fact that the

00:10:39,730 --> 00:10:46,449
foo is currently locked and the

00:10:42,040 --> 00:10:49,649
destructor of fuko's unlock foo so try

00:10:46,449 --> 00:10:49,649
to find what is wrong here

00:10:52,120 --> 00:11:06,970
I forgot the lock that's not a problem

00:11:04,569 --> 00:11:20,439
that's just me because if you wouldn't

00:11:06,970 --> 00:11:22,920
fit in a slide the lock object has has

00:11:20,439 --> 00:11:25,059
an exclusive burrow of full rudder

00:11:22,920 --> 00:11:28,689
actually I'm going to explain because

00:11:25,059 --> 00:11:30,910
the explanation is in the next slide so

00:11:28,689 --> 00:11:35,410
this is how you're supposed to use this

00:11:30,910 --> 00:11:39,279
API you call food lock and you get back

00:11:35,410 --> 00:11:42,879
a lock object-- so the lock object at

00:11:39,279 --> 00:11:45,490
the bottom here and then while the lock

00:11:42,879 --> 00:11:49,689
object is alive you cannot call do

00:11:45,490 --> 00:11:52,629
something because the lock object has an

00:11:49,689 --> 00:11:56,230
exclusive burrow of the foo and do

00:11:52,629 --> 00:11:57,850
something also needs an x ^ foo and you

00:11:56,230 --> 00:12:01,120
can't have two exclusive burrow so you

00:11:57,850 --> 00:12:03,759
get a compilation error so that's that's

00:12:01,120 --> 00:12:06,399
the intent of these API that's what this

00:12:03,759 --> 00:12:09,279
API is trying to do and it's quite nice

00:12:06,399 --> 00:12:11,379
you think you you ain't sure at compile

00:12:09,279 --> 00:12:13,300
time but you cannot call do something

00:12:11,379 --> 00:12:16,329
while the foo is lock that's quite nice

00:12:13,300 --> 00:12:18,819
but actually this is unsafe because you

00:12:16,329 --> 00:12:21,939
can actually bypass the burrow you can

00:12:18,819 --> 00:12:24,459
simply call as shown in the second block

00:12:21,939 --> 00:12:27,519
of code you can simply call man forget

00:12:24,459 --> 00:12:31,449
on the lock and the foo is actually

00:12:27,519 --> 00:12:35,110
going to stay locked while your lock

00:12:31,449 --> 00:12:37,389
variable disappears and then the user

00:12:35,110 --> 00:12:39,610
will be able to call do something even

00:12:37,389 --> 00:12:41,920
verbal foo is still locked and you're

00:12:39,610 --> 00:12:44,559
very you're violating the rules of the

00:12:41,920 --> 00:12:48,850
capi wrapping around and that's really

00:12:44,559 --> 00:12:51,879
just bad so the rule here is to never

00:12:48,850 --> 00:12:54,249
assume but the structures are going to

00:12:51,879 --> 00:12:57,040
be called but was also mentioned this

00:12:54,249 --> 00:13:01,509
morning it's called the leek apocalypse

00:12:57,040 --> 00:13:05,209
or something like that it's a famous

00:13:01,509 --> 00:13:08,089
event at the time of 1.0

00:13:05,209 --> 00:13:10,850
kalique apocalypse and how you fix this

00:13:08,089 --> 00:13:13,480
problem in your wrapper is by using a

00:13:10,850 --> 00:13:18,379
technique named pre pooping your pants

00:13:13,480 --> 00:13:24,129
so that's that's not I didn't name that

00:13:18,379 --> 00:13:26,869
myself so someone came up with a name

00:13:24,129 --> 00:13:29,360
and I mentioned this name here so you

00:13:26,869 --> 00:13:31,790
can google it but I recommend googling

00:13:29,360 --> 00:13:35,589
rust-free popping offense and not just

00:13:31,790 --> 00:13:40,009
recruiting events that's my suggestion

00:13:35,589 --> 00:13:42,649
so the idea here to fix this is that you

00:13:40,009 --> 00:13:46,309
need a second field in your foo wrapper

00:13:42,649 --> 00:13:49,459
that contains whether or not befool is

00:13:46,309 --> 00:13:51,769
currently locked so when you call do

00:13:49,459 --> 00:13:54,170
some when your user calls do something

00:13:51,769 --> 00:13:57,679
or lock you first have to check at run

00:13:54,170 --> 00:14:00,410
time whether the variable contains you

00:13:57,679 --> 00:14:03,829
need to ensure that is locked variable

00:14:00,410 --> 00:14:07,309
field in sports overwise you're

00:14:03,829 --> 00:14:10,459
violating the C API and in the drop in

00:14:07,309 --> 00:14:14,410
the destructor of lock your right force

00:14:10,459 --> 00:14:18,139
is in your right force in is locked and

00:14:14,410 --> 00:14:20,179
but what add that adds a small runtime

00:14:18,139 --> 00:14:24,079
overhead but unfortunately there's no

00:14:20,179 --> 00:14:26,629
real choice here mistake number four

00:14:24,079 --> 00:14:29,360
forgetting about hidden global variables

00:14:26,629 --> 00:14:33,049
I'm going to take for example of open

00:14:29,360 --> 00:14:36,049
Yale open a L sound driver here because

00:14:33,049 --> 00:14:39,230
it's really representative so the way

00:14:36,049 --> 00:14:41,809
you use open in your library is you

00:14:39,230 --> 00:14:44,569
first create what is called a context

00:14:41,809 --> 00:14:46,819
we've functioned that a dinner show here

00:14:44,569 --> 00:14:49,009
which is called a se create context or

00:14:46,819 --> 00:14:51,769
whatever it's not the point here you

00:14:49,009 --> 00:14:54,769
first create a context when you set the

00:14:51,769 --> 00:14:58,579
context as current by calling ALC make

00:14:54,769 --> 00:15:01,999
context current and only one context can

00:14:58,579 --> 00:15:04,819
be current at any given time and once

00:15:01,999 --> 00:15:07,220
you've made a context current all the

00:15:04,819 --> 00:15:10,850
functions of open Yale library that you

00:15:07,220 --> 00:15:13,370
call apply to the current context but to

00:15:10,850 --> 00:15:15,980
the context that you set us current and

00:15:13,370 --> 00:15:19,850
if if you think about it this is in fact

00:15:15,980 --> 00:15:22,370
a global variable hidden inside the open

00:15:19,850 --> 00:15:25,100
when you call a scenic context current

00:15:22,370 --> 00:15:27,080
what you're essentially doing is just

00:15:25,100 --> 00:15:31,520
set the value of this global variable

00:15:27,080 --> 00:15:34,130
and this design is really not fret safe

00:15:31,520 --> 00:15:36,380
at all because if you have two threads

00:15:34,130 --> 00:15:39,230
that are trying to use open yellow say

00:15:36,380 --> 00:15:41,870
time well Fred one calls a seam in

00:15:39,230 --> 00:15:44,930
context current and some open a year

00:15:41,870 --> 00:15:48,380
staff fred to cause a scene a context

00:15:44,930 --> 00:15:50,660
currents wire fred one is running and it

00:15:48,380 --> 00:15:53,860
will modify the behavior of red one and

00:15:50,660 --> 00:15:57,650
that's bad and that's really fred unsafe

00:15:53,860 --> 00:16:01,820
so you may think but what if i use a new

00:15:57,650 --> 00:16:06,050
text and that's the solution people can

00:16:01,820 --> 00:16:07,430
come up with so that's the code here is

00:16:06,050 --> 00:16:09,770
what you would put in your wrapper you

00:16:07,430 --> 00:16:14,180
create a new text named current context

00:16:09,770 --> 00:16:16,190
new text a static mutex and whenever you

00:16:14,180 --> 00:16:18,380
want to do something with open air you

00:16:16,190 --> 00:16:22,010
first lock the new text and then on

00:16:18,380 --> 00:16:24,530
inequal yes you made contacts current so

00:16:22,010 --> 00:16:26,750
if two threads try to call do something

00:16:24,530 --> 00:16:29,690
at the same time they are not going to

00:16:26,750 --> 00:16:32,060
conflict because second thread is going

00:16:29,690 --> 00:16:37,040
to wait until do something is finished

00:16:32,060 --> 00:16:40,780
in the first read before starting do you

00:16:37,040 --> 00:16:44,060
think that this is safe if I use a mutex

00:16:40,780 --> 00:16:47,530
that's not a good question because if it

00:16:44,060 --> 00:16:47,530
was I wouldn't talk about it

00:16:47,560 --> 00:16:54,110
unfortunately it doesn't work why

00:16:51,050 --> 00:16:58,370
because if you create a project named

00:16:54,110 --> 00:17:01,310
project which uses two dependencies open

00:16:58,370 --> 00:17:03,590
al you're opening a wrapper and no a

00:17:01,310 --> 00:17:06,199
third-party dependency named over some

00:17:03,590 --> 00:17:09,650
library and this third-party library

00:17:06,199 --> 00:17:11,689
uses open ear open ear wrapper as well

00:17:09,650 --> 00:17:14,270
but a different version

00:17:11,689 --> 00:17:17,089
what cargo is going to do in this

00:17:14,270 --> 00:17:19,819
situation here I showed you a small

00:17:17,089 --> 00:17:22,850
dependency graph what cargo is going to

00:17:19,819 --> 00:17:25,400
do here is that it's going to put two

00:17:22,850 --> 00:17:27,709
different versions of open year of an

00:17:25,400 --> 00:17:32,120
open ear wrapper at the same time but

00:17:27,709 --> 00:17:33,140
with only one open ear in your final

00:17:32,120 --> 00:17:35,120
executive oil

00:17:33,140 --> 00:17:36,710
going to have only one open year but

00:17:35,120 --> 00:17:38,600
you're going to have to open air

00:17:36,710 --> 00:17:41,630
wrappers so you're going to have two

00:17:38,600 --> 00:17:44,750
different new taxes for only one opening

00:17:41,630 --> 00:17:48,140
F only one global variable hidden inside

00:17:44,750 --> 00:17:50,990
open L so if you try to use open air

00:17:48,140 --> 00:17:53,570
wrapper and over sound library at the

00:17:50,990 --> 00:17:56,060
same times in two different threads but

00:17:53,570 --> 00:17:56,690
we each lock the own version of the

00:17:56,060 --> 00:17:59,650
mutex

00:17:56,690 --> 00:18:04,280
and they will conflict with each other

00:17:59,650 --> 00:18:08,300
so you know you can't do that

00:18:04,280 --> 00:18:11,990
and the problem here as my conclusion is

00:18:08,300 --> 00:18:14,450
that there's just no solution openly I

00:18:11,990 --> 00:18:18,980
can unfortunately not be wrapped around

00:18:14,450 --> 00:18:24,320
safely or if you have an idea let me

00:18:18,980 --> 00:18:29,000
know because I already have okay we can

00:18:24,320 --> 00:18:32,810
talk later if you have an idea of our

00:18:29,000 --> 00:18:35,810
examples of similar impossible ap is our

00:18:32,810 --> 00:18:39,860
X deep because of a function in exit

00:18:35,810 --> 00:18:43,070
Handler and I actually have a wrapper on

00:18:39,860 --> 00:18:47,090
X leave myself and I know it's unsafe

00:18:43,070 --> 00:18:50,150
but I really have no choice get end and

00:18:47,090 --> 00:18:52,220
because you're not going to say screw X

00:18:50,150 --> 00:18:56,360
leave just because of this unfortunately

00:18:52,220 --> 00:19:00,680
it has too much market last year yeah

00:18:56,360 --> 00:19:02,960
get in one set and also unsafe cannot be

00:19:00,680 --> 00:19:05,300
wrapped on safety but fortunately since

00:19:02,960 --> 00:19:08,360
the STD wraps around it and you can only

00:19:05,300 --> 00:19:10,730
have one version of STI live in any

00:19:08,360 --> 00:19:14,690
given executable then it's safe

00:19:10,730 --> 00:19:17,840
actually our example of API is what are

00:19:14,690 --> 00:19:21,970
problematic but also have a global kind

00:19:17,840 --> 00:19:25,040
of global variable in thing OpenGL

00:19:21,970 --> 00:19:30,410
several api's from the Windows operating

00:19:25,040 --> 00:19:33,110
system they both have constable let you

00:19:30,410 --> 00:19:34,580
set properties for the current thread so

00:19:33,110 --> 00:19:36,550
you have to have spawn a background

00:19:34,580 --> 00:19:39,530
thread when you who want to do stuff

00:19:36,550 --> 00:19:42,080
that's also our runtime overhead but you

00:19:39,530 --> 00:19:44,000
have no choice and other libraries that

00:19:42,080 --> 00:19:46,210
have a global initialization function

00:19:44,000 --> 00:19:48,500
you have to take care of

00:19:46,210 --> 00:19:52,040
initialization and the initialization

00:19:48,500 --> 00:19:55,550
functions are reference counted if you

00:19:52,040 --> 00:20:00,140
call the initialize while something else

00:19:55,550 --> 00:20:02,300
is using your library when it's bad it's

00:20:00,140 --> 00:20:06,100
tech number free reading primitives from

00:20:02,300 --> 00:20:09,260
memory without checking so it concerns

00:20:06,100 --> 00:20:15,860
three different things floating points

00:20:09,260 --> 00:20:20,570
booze and cars so rest specifications of

00:20:15,860 --> 00:20:23,120
rest say that boolean's must on account

00:20:20,570 --> 00:20:27,190
must represent the memory representation

00:20:23,120 --> 00:20:30,740
of boolean must always be either 1 or 0

00:20:27,190 --> 00:20:34,340
of all visits technically unspecified

00:20:30,740 --> 00:20:36,860
with whatever memory pass representation

00:20:34,340 --> 00:20:38,960
of cars must always be evaded unique on

00:20:36,860 --> 00:20:41,240
scalar value and the memory

00:20:38,960 --> 00:20:44,300
representation of 14 points men must

00:20:41,240 --> 00:20:46,700
never be a signalling none so if you

00:20:44,300 --> 00:20:47,440
have memory and you don't know what it

00:20:46,700 --> 00:20:50,720
contains

00:20:47,440 --> 00:20:54,170
it's dangerous to read a bull a car or a

00:20:50,720 --> 00:20:57,280
floating point from it you you can judge

00:20:54,170 --> 00:21:00,770
you cannot just blindly read memory

00:20:57,280 --> 00:21:03,440
because it's very dangerous and I give

00:21:00,770 --> 00:21:09,320
some examples here in the first example

00:21:03,440 --> 00:21:12,290
if if uninitialized even an initialize

00:21:09,320 --> 00:21:14,930
function returns something else than 0

00:21:12,290 --> 00:21:17,660
or 1 when you have an in find behavior

00:21:14,930 --> 00:21:20,900
and the second example is an and if I'm

00:21:17,660 --> 00:21:23,480
behavior as well and of course structs

00:21:20,900 --> 00:21:25,760
but are made of booze cars and floating

00:21:23,480 --> 00:21:28,940
points are also concerned so how you

00:21:25,760 --> 00:21:33,560
check this for floating points you use

00:21:28,940 --> 00:21:36,230
from bits functions you first you first

00:21:33,560 --> 00:21:39,800
read an integer and then you call from

00:21:36,230 --> 00:21:42,380
bits on that integer instead of reading

00:21:39,800 --> 00:21:44,600
a pool you also first read an integer

00:21:42,380 --> 00:21:46,820
and then check whether integer a

00:21:44,600 --> 00:21:49,760
different is different from 0 and

00:21:46,820 --> 00:21:53,480
forecast as a function name car from you

00:21:49,760 --> 00:21:55,790
32 so you first read are you 32 and when

00:21:53,480 --> 00:21:58,490
you call this functions this function

00:21:55,790 --> 00:21:59,410
and B is this fourth where these three

00:21:58,490 --> 00:22:01,690
functions

00:21:59,410 --> 00:22:02,910
and comparing whether integer is

00:22:01,690 --> 00:22:06,130
different from zero

00:22:02,910 --> 00:22:08,290
what you should do to ensure that you're

00:22:06,130 --> 00:22:12,960
actually doing something correct and not

00:22:08,290 --> 00:22:16,120
undefined behavior mistake number two

00:22:12,960 --> 00:22:18,580
assuming the threat implementations are

00:22:16,120 --> 00:22:21,460
bug free and this one is really tricky

00:22:18,580 --> 00:22:25,440
so we're going to sports we're going to

00:22:21,460 --> 00:22:28,480
play try to spot the problem again so

00:22:25,440 --> 00:22:31,180
the C API that you're trying to wrap

00:22:28,480 --> 00:22:33,640
around here again in an external block

00:22:31,180 --> 00:22:36,730
it's very simple here you have a

00:22:33,640 --> 00:22:40,270
function a c function named foo which

00:22:36,730 --> 00:22:42,610
takes as parameter an array array is

00:22:40,270 --> 00:22:44,740
passed as a pointer and the number of

00:22:42,610 --> 00:22:47,260
elements if you have ever done and you

00:22:44,740 --> 00:22:51,640
see in your life you probably familiar

00:22:47,260 --> 00:22:54,870
with that in rust we are trying to wrap

00:22:51,640 --> 00:22:58,180
around with API with a full wrapper API

00:22:54,870 --> 00:23:01,330
so since you're trying to write a

00:22:58,180 --> 00:23:04,180
convenient API you make your flu wrapper

00:23:01,330 --> 00:23:08,470
function generic over any type that

00:23:04,180 --> 00:23:10,510
implements the ref to an array of u8 so

00:23:08,470 --> 00:23:14,230
what that means is that array arc

00:23:10,510 --> 00:23:17,230
parameter can be anything but represents

00:23:14,230 --> 00:23:20,260
an array but you you write your wrapper

00:23:17,230 --> 00:23:23,170
you're trying to be convenient and then

00:23:20,260 --> 00:23:26,560
you simply call the C function the Foo

00:23:23,170 --> 00:23:29,410
function you call as PTR and land on

00:23:26,560 --> 00:23:31,870
your array and you call the fee foo

00:23:29,410 --> 00:23:35,350
functions the Foo function with these

00:23:31,870 --> 00:23:37,800
parameters if you have an idea of a

00:23:35,350 --> 00:23:37,800
problem here

00:23:42,229 --> 00:23:57,389
sorry I don't know and as Ponto may

00:23:50,759 --> 00:24:01,609
panic oh no it's not a problem here you

00:23:57,389 --> 00:24:01,609
don't have any care back any call back

00:24:03,109 --> 00:24:09,509
yes that's the problem

00:24:05,720 --> 00:24:13,379
so our problem here is that since few

00:24:09,509 --> 00:24:15,389
rapper can accept anything the user the

00:24:13,379 --> 00:24:18,629
user of your library can simply write

00:24:15,389 --> 00:24:20,879
malicious pointer so the user of your

00:24:18,629 --> 00:24:24,450
library writes malicious pointer it

00:24:20,879 --> 00:24:27,419
contains two fields to vex and the user

00:24:24,450 --> 00:24:31,889
implements the RF on malicious pointer

00:24:27,419 --> 00:24:33,720
and half over time but the error

00:24:31,889 --> 00:24:37,229
function is going to read on the first

00:24:33,720 --> 00:24:41,539
back and half over time a second back so

00:24:37,229 --> 00:24:41,539
you're betting why would someone do this

00:24:41,960 --> 00:24:48,659
and I'm going to come to this and what's

00:24:46,559 --> 00:24:51,090
happening if you create a malicious

00:24:48,659 --> 00:24:53,700
pointer and you've called full rapper if

00:24:51,090 --> 00:24:55,710
it with it is that what could end up

00:24:53,700 --> 00:24:58,769
happening

00:24:55,710 --> 00:25:02,129
let me explain first when you call array

00:24:58,769 --> 00:25:05,789
arc dot as PTR what happens in reality

00:25:02,129 --> 00:25:09,059
is what you call array arc dots D F dot

00:25:05,789 --> 00:25:11,099
PTO and when in call array our clan what

00:25:09,059 --> 00:25:12,869
happens in reality is you call array are

00:25:11,099 --> 00:25:15,059
dots the F dot length

00:25:12,869 --> 00:25:18,029
so what could end up happening is that

00:25:15,059 --> 00:25:21,440
you get a function pointer to the first

00:25:18,029 --> 00:25:24,389
back and the length of a second back and

00:25:21,440 --> 00:25:28,289
then bad things are going to happen

00:25:24,389 --> 00:25:31,259
ouch so back to a question why would

00:25:28,289 --> 00:25:33,450
someone do that of obviously nobody is

00:25:31,259 --> 00:25:36,899
going to write in malicious pointer but

00:25:33,450 --> 00:25:38,789
in a real life project what could end up

00:25:36,899 --> 00:25:42,570
happening is the Burg in its right

00:25:38,789 --> 00:25:45,779
implementation so that's obvious that's

00:25:42,570 --> 00:25:51,690
obviously a very serious bug but it

00:25:45,779 --> 00:25:55,740
could really be a bug oh ok I fought my

00:25:51,690 --> 00:25:57,750
over side was next it could be a real

00:25:55,740 --> 00:26:01,799
in the DRF implementation and not

00:25:57,750 --> 00:26:04,049
intended so how would you solve that the

00:26:01,799 --> 00:26:06,690
first solution is to call the ref at the

00:26:04,049 --> 00:26:11,039
start of a function so you turn your

00:26:06,690 --> 00:26:14,730
array arc parameter into an actual slice

00:26:11,039 --> 00:26:17,760
of you ate at WA for the first time does

00:26:14,730 --> 00:26:20,610
that and the second line calls the full

00:26:17,760 --> 00:26:22,860
function but sometimes this solution can

00:26:20,610 --> 00:26:27,179
be inconvenient so the second solution

00:26:22,860 --> 00:26:30,630
is to use a custom unsafe threat so

00:26:27,179 --> 00:26:34,159
instead of requiring drf you'll require

00:26:30,630 --> 00:26:37,649
a trade name and safety ref and

00:26:34,159 --> 00:26:41,279
basically the burden of implementing the

00:26:37,649 --> 00:26:46,440
ref correctly is on the user layer of

00:26:41,279 --> 00:26:49,020
your library so basically what was in in

00:26:46,440 --> 00:26:52,860
the lines two and three you have these

00:26:49,020 --> 00:26:55,740
unsafe keywords and that means that a

00:26:52,860 --> 00:26:59,250
person who implements the safety read

00:26:55,740 --> 00:27:04,049
threat guarantee is that safety ref is

00:26:59,250 --> 00:27:07,169
actually implemented correctly so so

00:27:04,049 --> 00:27:09,210
basically as a writer of your wrapper

00:27:07,169 --> 00:27:12,470
you only write through brother and the

00:27:09,210 --> 00:27:16,789
user of your wrapper has to write in

00:27:12,470 --> 00:27:20,520
safety ref for whatever they want and

00:27:16,789 --> 00:27:22,919
here are all here are other examples of

00:27:20,520 --> 00:27:26,850
threats which can be dangerous as rebel

00:27:22,919 --> 00:27:28,230
row partial a partial or - iterator if

00:27:26,850 --> 00:27:32,610
you use a new Venus

00:27:28,230 --> 00:27:34,409
for example iterator if a number of

00:27:32,610 --> 00:27:37,289
elements return if the number of

00:27:34,409 --> 00:27:40,230
elements return by size size hint

00:27:37,289 --> 00:27:44,490
doesn't match actual number of elements

00:27:40,230 --> 00:27:46,080
in the iterator then it could happen it

00:27:44,490 --> 00:27:48,390
could actually be a bug someone

00:27:46,080 --> 00:27:50,669
implements it right on the custom type

00:27:48,390 --> 00:27:54,990
and they have a mismatch between what

00:27:50,669 --> 00:27:56,909
sizings returns and what next returns so

00:27:54,990 --> 00:27:59,970
and you had when you write a wrapper you

00:27:56,909 --> 00:28:02,360
have to be aware of that you for example

00:27:59,970 --> 00:28:05,250
shouldn't allocate a block of

00:28:02,360 --> 00:28:07,799
uninitialized memory of a certain number

00:28:05,250 --> 00:28:09,270
of elements and then on your and then

00:28:07,799 --> 00:28:11,790
don't write any animal

00:28:09,270 --> 00:28:14,130
because iterator is actually empty so

00:28:11,790 --> 00:28:16,920
that's just an example I didn't really

00:28:14,130 --> 00:28:18,930
write it as code I just quickly went

00:28:16,920 --> 00:28:21,090
over it if you use any of this thread

00:28:18,930 --> 00:28:24,780
you have to be aware of this kind of

00:28:21,090 --> 00:28:29,550
problems a mistake number one so this is

00:28:24,780 --> 00:28:33,480
an API related mistake using lifetimes

00:28:29,550 --> 00:28:36,810
for long-lived objects so a very common

00:28:33,480 --> 00:28:39,990
situation in C libraries is that the C

00:28:36,810 --> 00:28:43,260
library the C library provides wavy

00:28:39,990 --> 00:28:48,390
provides you with two types of objects

00:28:43,260 --> 00:28:53,700
named a and B and says that you must

00:28:48,390 --> 00:28:59,400
ensure that a outlives B and a common

00:28:53,700 --> 00:29:02,310
solution as writer of a rudder is to use

00:28:59,400 --> 00:29:04,470
a lifetime that's what that's what comes

00:29:02,310 --> 00:29:08,190
to mind when you want to write to wrap

00:29:04,470 --> 00:29:11,430
around this API so you the C library

00:29:08,190 --> 00:29:17,580
says that a must out leaf being so your

00:29:11,430 --> 00:29:19,470
your wrapper on B holds a borrow to a by

00:29:17,580 --> 00:29:22,670
the way we ignore the problem of League

00:29:19,470 --> 00:29:25,770
safety because it's not the topic here

00:29:22,670 --> 00:29:27,870
however using a lifetime actually is

00:29:25,770 --> 00:29:32,400
more restrictive than just the concept

00:29:27,870 --> 00:29:35,490
of outlives the C API says says that

00:29:32,400 --> 00:29:39,300
build must out if a sorry a must out if

00:29:35,490 --> 00:29:42,870
B but a burrow is more restrictive than

00:29:39,300 --> 00:29:45,480
that and the problem with being wrong as

00:29:42,870 --> 00:29:49,350
to given the restriction question is

00:29:45,480 --> 00:29:54,000
that the be sorry

00:29:49,350 --> 00:29:56,340
the a must not move in memory as long as

00:29:54,000 --> 00:29:59,040
it's being borrowed the consequences of

00:29:56,340 --> 00:30:03,780
that is that someone trying to use a

00:29:59,040 --> 00:30:07,050
wrapper cannot put an A and a B both in

00:30:03,780 --> 00:30:10,050
the same struct and that's a problem why

00:30:07,050 --> 00:30:12,690
why we can do that because what do you

00:30:10,050 --> 00:30:16,830
use as a lifetime a lifetime here should

00:30:12,690 --> 00:30:20,520
be self quote self but that doesn't

00:30:16,830 --> 00:30:23,190
exist maybe it will exist in long future

00:30:20,520 --> 00:30:29,200
but for now it doesn't exist

00:30:23,190 --> 00:30:33,039
so what I advise you to do is simply use

00:30:29,200 --> 00:30:35,830
only lifetimes for temporary objects the

00:30:33,039 --> 00:30:39,220
kind of objects virtue only keep on the

00:30:35,830 --> 00:30:41,710
stack so locks accessors what I mean by

00:30:39,220 --> 00:30:43,750
keep on the stack is that at the

00:30:41,710 --> 00:30:46,600
beginning of a function you create an

00:30:43,750 --> 00:30:48,850
object and then object is drop that we

00:30:46,600 --> 00:30:52,059
end our function for this kind of types

00:30:48,850 --> 00:30:54,400
you can use lifetimes but when you have

00:30:52,059 --> 00:30:57,460
objects that leave for a long time do

00:30:54,400 --> 00:31:01,780
not use lifetimes and sell I suggest you

00:30:57,460 --> 00:31:05,770
use arcs on our seas that's also a small

00:31:01,780 --> 00:31:07,990
runtime overhead but again it's I think

00:31:05,770 --> 00:31:10,500
in my that's my personal opinion but

00:31:07,990 --> 00:31:13,120
it's better than these restrictions

00:31:10,500 --> 00:31:16,919
because users are going to be really

00:31:13,120 --> 00:31:21,280
confused about how you to use your API

00:31:16,919 --> 00:31:23,980
and as a cop you as a conclusion if you

00:31:21,280 --> 00:31:25,600
if you're writing a wraparound around

00:31:23,980 --> 00:31:27,820
the sea library I strongly recommend

00:31:25,600 --> 00:31:33,669
that you read the rest on Aamir Khan

00:31:27,820 --> 00:31:35,710
which I put the URL here if you feel

00:31:33,669 --> 00:31:39,580
overwhelmed by the safety related

00:31:35,710 --> 00:31:43,240
problems you have to you have to be

00:31:39,580 --> 00:31:45,490
positive keep in mind that safe first

00:31:43,240 --> 00:31:47,500
actually protects you against all these

00:31:45,490 --> 00:31:49,870
problems well if you're right if you

00:31:47,500 --> 00:31:55,690
were writing C you would have to deal

00:31:49,870 --> 00:31:58,090
with this second thing I advise you is

00:31:55,690 --> 00:32:01,929
to take inspiration from the API

00:31:58,090 --> 00:32:05,260
guidelines official API guidelines which

00:32:01,929 --> 00:32:07,419
I also provided a link here in my

00:32:05,260 --> 00:32:12,600
opinions are not perfect as they also

00:32:07,419 --> 00:32:12,600
very good starting point and that's it

00:32:19,820 --> 00:32:32,720
thank you so much we have time for one

00:32:22,340 --> 00:32:35,060
question you one um

00:32:32,720 --> 00:32:37,460
you were asking about if anyone had

00:32:35,060 --> 00:32:40,820
ideas for the multiple version of the

00:32:37,460 --> 00:32:44,420
libraries and there's that cargo Tom

00:32:40,820 --> 00:32:45,980
will key links equals a string that I

00:32:44,420 --> 00:32:48,800
never really understood what it was for

00:32:45,980 --> 00:32:50,630
but does that solve the problem or does

00:32:48,800 --> 00:32:54,740
it still conflict twenty of multiple

00:32:50,630 --> 00:32:59,060
versions of a problem with I'm going to

00:32:54,740 --> 00:33:01,880
back to this is it the problem is that

00:32:59,060 --> 00:33:05,210
when you here is the dependency graph of

00:33:01,880 --> 00:33:07,160
your project in the cargo that tunnel of

00:33:05,210 --> 00:33:10,400
your project you only have open air

00:33:07,160 --> 00:33:13,880
wrapper over sound library you don't

00:33:10,400 --> 00:33:16,670
really know which version of open air

00:33:13,880 --> 00:33:19,130
wrapper is used by over sound library I

00:33:16,670 --> 00:33:22,250
mean you can know it but it's not it's

00:33:19,130 --> 00:33:24,410
none of your concern the person who

00:33:22,250 --> 00:33:26,690
writes over sound library could decide

00:33:24,410 --> 00:33:30,710
to burn the version of open air rather

00:33:26,690 --> 00:33:33,740
without notifying you so you don't as

00:33:30,710 --> 00:33:37,040
well if you when you as a writer of

00:33:33,740 --> 00:33:38,960
project you don't control the version of

00:33:37,040 --> 00:33:43,820
open air wrapper you don't control the

00:33:38,960 --> 00:33:46,960
version 0.1 yeah so I can't ensure that

00:33:43,820 --> 00:33:46,960
we always say in version

00:33:48,400 --> 00:33:59,040
do you have a short comment no mango

00:33:56,390 --> 00:34:02,740
[Music]

00:33:59,040 --> 00:34:07,180
yeah I see what you mean you can you can

00:34:02,740 --> 00:34:09,700
fix that with no basically if you write

00:34:07,180 --> 00:34:11,649
if you're the writer of the open year

00:34:09,700 --> 00:34:13,870
Radford library you can ensure that

00:34:11,649 --> 00:34:17,200
people can have two different version of

00:34:13,870 --> 00:34:20,440
open Yale library of open air wrapper in

00:34:17,200 --> 00:34:23,139
their project as well rapper as writers

00:34:20,440 --> 00:34:26,320
and I'm going and getting this that as

00:34:23,139 --> 00:34:28,870
the writer of open air rapper you can

00:34:26,320 --> 00:34:31,179
ensure that this doesn't happen but if

00:34:28,870 --> 00:34:34,889
someone else writes another open year

00:34:31,179 --> 00:34:34,889
rapper then you have the same problem

00:34:35,399 --> 00:34:40,780
maybe you can solve this in the hallway

00:34:38,139 --> 00:34:43,550
because we are out of time I'm sorry but

00:34:40,780 --> 00:34:51,699
thank you so much for Tokyo

00:34:43,550 --> 00:34:51,699

YouTube URL: https://www.youtube.com/watch?v=LLde-PJJZQA


