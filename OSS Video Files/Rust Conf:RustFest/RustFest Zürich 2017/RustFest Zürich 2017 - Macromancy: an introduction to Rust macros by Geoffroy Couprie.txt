Title: RustFest Zürich 2017 - Macromancy: an introduction to Rust macros by Geoffroy Couprie
Publication date: 2017-10-21
Playlist: RustFest Zürich 2017
Description: 
	Many times you must reuse code
And your generics aren’t commode
Can you deal in the macro dark arts
Recompose code of similar parts
Or would the compiler explode?

Rejoice! Follow now our ways
Unlock the compiler’s high praise
Listen here to this initiation
Each eldritch arcane incantation
Summons help ‘gainst the terrors we face.

About Geoffroy Couprie:
Geoffroy handles security and quality assurance at Clever Cloud, develops in Rust and researches on parser security at VideoLAN. He thinks a lot about cryptography, protocol design and data management.
Captions: 
	00:00:12,880 --> 00:00:24,350
okay so hi let's talk about macros

00:00:19,510 --> 00:00:27,590
yeah right now good yeah so I will talk

00:00:24,350 --> 00:00:31,460
about macros first yeah he introduced me

00:00:27,590 --> 00:00:34,340
I do Nam and other stuff I also work at

00:00:31,460 --> 00:00:42,410
the hosting company and we can toast you

00:00:34,340 --> 00:00:45,019
rust among other stuff so we're writing

00:00:42,410 --> 00:00:47,330
a lot of things I have lots of project

00:00:45,019 --> 00:00:50,239
we can talk about it afterwards right

00:00:47,330 --> 00:00:53,150
now I'm doing a video toolkit it's quite

00:00:50,239 --> 00:00:56,809
fun so we were talking about macros

00:00:53,150 --> 00:01:02,629
which macros procedural macros syntax

00:00:56,809 --> 00:01:04,460
extension that kind of thing no but this

00:01:02,629 --> 00:01:07,549
is quite cool except that it's not

00:01:04,460 --> 00:01:12,490
available in style and sale or maybe you

00:01:07,549 --> 00:01:15,470
could talk about custom derive stuff so

00:01:12,490 --> 00:01:17,740
this is quite interesting like okay we

00:01:15,470 --> 00:01:20,840
cannot have compiler plugins that are

00:01:17,740 --> 00:01:24,170
stable so let's just do an annotation

00:01:20,840 --> 00:01:28,280
that will and you get a function that we

00:01:24,170 --> 00:01:29,870
received the code and we write code

00:01:28,280 --> 00:01:32,870
that's basically you get the string will

00:01:29,870 --> 00:01:36,170
give a string and you have a rest parser

00:01:32,870 --> 00:01:39,470
that's called sin that use none fork of

00:01:36,170 --> 00:01:43,340
nan desu call sinem to pass press code

00:01:39,470 --> 00:01:45,170
everywhere so whenever you use that

00:01:43,340 --> 00:01:46,670
there are lot of macros as well but this

00:01:45,170 --> 00:01:50,150
is still not the point

00:01:46,670 --> 00:01:54,220
I'm basically talking about decorative

00:01:50,150 --> 00:02:00,230
macros like the macro rules and whatever

00:01:54,220 --> 00:02:06,650
so why would you use those macros I know

00:02:00,230 --> 00:02:10,909
why because I can this is quite nice

00:02:06,650 --> 00:02:12,739
effect so roast macros are ugly yeah but

00:02:10,909 --> 00:02:14,300
they allow some flexibility we don't

00:02:12,739 --> 00:02:16,610
have basically in the language like

00:02:14,300 --> 00:02:20,389
generating a lot of codes from some kind

00:02:16,610 --> 00:02:23,959
of templates so the kind of thing you

00:02:20,389 --> 00:02:25,400
can do with macros you can have one that

00:02:23,959 --> 00:02:27,829
will generate structures and

00:02:25,400 --> 00:02:35,030
limitation from just an identifier and

00:02:27,829 --> 00:02:38,420
some types you know like the arrays with

00:02:35,030 --> 00:02:41,599
a static size you can do implementation

00:02:38,420 --> 00:02:43,220
fondues so there's a future communing

00:02:41,599 --> 00:02:47,239
with The Associated clones that are kind

00:02:43,220 --> 00:02:50,780
of thing no it's in stable right now but

00:02:47,239 --> 00:02:53,000
before we had to do like not close

00:02:50,780 --> 00:02:54,349
everywhere else stuff like that all of

00:02:53,000 --> 00:02:56,840
all over the place in the standard

00:02:54,349 --> 00:02:59,989
library where you have a macro that will

00:02:56,840 --> 00:03:02,480
go through integers and make the

00:02:59,989 --> 00:03:05,180
implementation for each size of array or

00:03:02,480 --> 00:03:09,290
a Perl or whatever it's quite funny to

00:03:05,180 --> 00:03:12,139
watch you can also use macros like

00:03:09,290 --> 00:03:16,579
PrinterOn and over ones they're quite

00:03:12,139 --> 00:03:19,670
useful so it's a very common component

00:03:16,579 --> 00:03:23,180
universe but most people don't reuse

00:03:19,670 --> 00:03:24,500
them they have a bad reputation but

00:03:23,180 --> 00:03:26,480
thankfully there are people like me that

00:03:24,500 --> 00:03:29,750
really really like those so let's take a

00:03:26,480 --> 00:03:32,299
look this is a basic macro block you saw

00:03:29,750 --> 00:03:35,209
the previous one like the generate

00:03:32,299 --> 00:03:38,209
struct so this is how it could work

00:03:35,209 --> 00:03:40,970
basically you define the name of the

00:03:38,209 --> 00:03:42,859
macro you define the pattern like what

00:03:40,970 --> 00:03:46,010
will go into the parentheses in my macro

00:03:42,859 --> 00:03:48,319
and then you write the code like what

00:03:46,010 --> 00:03:50,810
the thing that became that begins with

00:03:48,319 --> 00:03:52,849
the dollar sign will be like a kind of

00:03:50,810 --> 00:03:56,720
variable it will be replaced inside the

00:03:52,849 --> 00:03:59,840
code so here we have an ID and it will

00:03:56,720 --> 00:04:02,569
be named the natural expects kind of

00:03:59,840 --> 00:04:05,389
name and we define a struct called with

00:04:02,569 --> 00:04:09,079
that name make the main implementation

00:04:05,389 --> 00:04:12,769
to generate a new one and you can then

00:04:09,079 --> 00:04:14,329
write that for any name you have a hello

00:04:12,769 --> 00:04:17,209
stroke you have a world street or

00:04:14,329 --> 00:04:19,489
whatever it would work we're not limited

00:04:17,209 --> 00:04:23,510
to just names like that we have lots of

00:04:19,489 --> 00:04:27,590
things available in patterns so that was

00:04:23,510 --> 00:04:29,810
the ident you can have a pattern like

00:04:27,590 --> 00:04:31,130
you can do can have macro that will take

00:04:29,810 --> 00:04:34,630
some stuff that will be using pattern

00:04:31,130 --> 00:04:37,400
matching you can use types you can use

00:04:34,630 --> 00:04:39,350
what's interesting the expression I use

00:04:37,400 --> 00:04:41,600
that a lot like the

00:04:39,350 --> 00:04:44,090
McCoy expects something that will be an

00:04:41,600 --> 00:04:45,590
expression so it can be a block it can

00:04:44,090 --> 00:04:47,630
be a function call can be whatever

00:04:45,590 --> 00:04:52,940
anything that will return basically

00:04:47,630 --> 00:04:57,200
value and this is difference with like

00:04:52,940 --> 00:05:00,080
see macros is they're kind of smart but

00:04:57,200 --> 00:05:01,910
what they expect in the input so they

00:05:00,080 --> 00:05:05,720
will check things a bit and make sure

00:05:01,910 --> 00:05:08,360
the code is quite all right so here we

00:05:05,720 --> 00:05:10,430
have an oculist quite simple

00:05:08,360 --> 00:05:14,180
another interesting part is that you can

00:05:10,430 --> 00:05:15,890
specify different patterns so like this

00:05:14,180 --> 00:05:21,950
one we have the default implementation

00:05:15,890 --> 00:05:24,650
for something and we have not the main

00:05:21,950 --> 00:05:27,530
one the text that takes an expression as

00:05:24,650 --> 00:05:29,480
default default number and we have one

00:05:27,530 --> 00:05:33,710
where we can call the macro we had the

00:05:29,480 --> 00:05:36,440
second argument and it will put 0 in its

00:05:33,710 --> 00:05:38,030
place so you can make macros with lots

00:05:36,440 --> 00:05:42,260
and lots of different alternative like

00:05:38,030 --> 00:05:44,330
that and basically call them differently

00:05:42,260 --> 00:05:46,550
like you know very logic functions like

00:05:44,330 --> 00:05:49,850
the Castella thing that's the way

00:05:46,550 --> 00:05:51,470
println and other things work an

00:05:49,850 --> 00:05:54,380
interesting part is the order in which

00:05:51,470 --> 00:05:57,700
you will declare its alternative is

00:05:54,380 --> 00:06:00,530
important so sometimes you will have

00:05:57,700 --> 00:06:03,860
annoying issues in the way the macros

00:06:00,530 --> 00:06:05,990
are interpreted and that's why they are

00:06:03,860 --> 00:06:09,680
a pain to the back but we're not there

00:06:05,990 --> 00:06:16,900
yet another interesting part is the

00:06:09,680 --> 00:06:19,220
macarons are hygienic so no wait there

00:06:16,900 --> 00:06:21,590
so basically here we have an example

00:06:19,220 --> 00:06:24,140
like we defined variable that's called

00:06:21,590 --> 00:06:26,900
state and we pass that to the macro log

00:06:24,140 --> 00:06:29,930
it says from the the main documentation

00:06:26,900 --> 00:06:32,870
and inside the macro we have another

00:06:29,930 --> 00:06:35,150
variable called state and we will use

00:06:32,870 --> 00:06:39,110
the expression we get in in reg'ment

00:06:35,150 --> 00:06:43,460
so you can have this it's really really

00:06:39,110 --> 00:06:46,630
useful like basically macro it will be

00:06:43,460 --> 00:06:51,050
nicely isolated there's still one

00:06:46,630 --> 00:06:55,729
annoying thing is if you want to do like

00:06:51,050 --> 00:06:58,460
strucked method method calls on strikes

00:06:55,729 --> 00:07:00,380
and stuff you have to pass self to the

00:06:58,460 --> 00:07:02,060
macro because self will not be available

00:07:00,380 --> 00:07:04,580
that kind of thing this is the kind of

00:07:02,060 --> 00:07:06,889
issue but still this is quite useful

00:07:04,580 --> 00:07:08,780
like if you've debugged some SEMA cruise

00:07:06,889 --> 00:07:14,180
you've seen that like hygiene is just

00:07:08,780 --> 00:07:23,060
painting yes to use them import them and

00:07:14,180 --> 00:07:25,250
stuff sorry my notes are sled I have by

00:07:23,060 --> 00:07:28,789
one should not have an interest oh yes a

00:07:25,250 --> 00:07:33,710
repetition so maybe you see like this

00:07:28,789 --> 00:07:36,110
dollar parents staff parents plus maybe

00:07:33,710 --> 00:07:37,699
we can expect multiple arguments and so

00:07:36,110 --> 00:07:40,099
we can apply the pattern multiple times

00:07:37,699 --> 00:07:44,060
so this is the the thing that was used

00:07:40,099 --> 00:07:49,509
in the our impt before so here we define

00:07:44,060 --> 00:07:53,509
the clone the current rate for the

00:07:49,509 --> 00:07:56,449
arrays of different sizes and this is

00:07:53,509 --> 00:08:00,949
quite small starting to be a bit harder

00:07:56,449 --> 00:08:03,979
to read but it's still doable I use that

00:08:00,949 --> 00:08:06,259
kind of thing a lot all over noon so

00:08:03,979 --> 00:08:09,770
with that like if you have already a lot

00:08:06,259 --> 00:08:12,590
of tools to start and write your own

00:08:09,770 --> 00:08:16,490
macros so now you have to expose them so

00:08:12,590 --> 00:08:18,580
yeah yeah basically to import macros

00:08:16,490 --> 00:08:21,289
from a crate you use the macro use

00:08:18,580 --> 00:08:23,479
annotation you can use macros with

00:08:21,289 --> 00:08:26,599
parameters to say I want this specific

00:08:23,479 --> 00:08:30,500
macro or that specific one it's not

00:08:26,599 --> 00:08:36,079
useful muscle time but still and you can

00:08:30,500 --> 00:08:36,860
export macros for moderate etcetera what

00:08:36,079 --> 00:08:41,029
do we have next

00:08:36,860 --> 00:08:44,660
yeah so a part that's been very

00:08:41,029 --> 00:08:48,529
confusing for people it's like how do we

00:08:44,660 --> 00:08:50,690
declare macro do we use the the parens

00:08:48,529 --> 00:08:52,490
the square brackets or whatever and like

00:08:50,690 --> 00:08:54,260
when I wrote the total was just

00:08:52,490 --> 00:08:56,360
panicking hey I've always used the same

00:08:54,260 --> 00:08:59,150
one over and over and I don't know if

00:08:56,360 --> 00:09:00,890
they do different thing so basically all

00:08:59,150 --> 00:09:03,860
the same stacks they do the same thing

00:09:00,890 --> 00:09:06,529
is just whatever you want

00:09:03,860 --> 00:09:09,440
and they will just expand to the same

00:09:06,529 --> 00:09:18,560
stuff but there's something interesting

00:09:09,440 --> 00:09:20,510
you can do is put another layer because

00:09:18,560 --> 00:09:22,279
then it will expand to a block and then

00:09:20,510 --> 00:09:24,649
inside the block you will be able to

00:09:22,279 --> 00:09:26,660
like import stuff isolate your card

00:09:24,649 --> 00:09:31,459
stuff so this is a good technique to use

00:09:26,660 --> 00:09:34,010
in your own macros so this was basically

00:09:31,459 --> 00:09:38,000
how you write macros and if you stop

00:09:34,010 --> 00:09:41,029
there you like at non 1.0 which was

00:09:38,000 --> 00:09:43,130
painless to debug which was made of huge

00:09:41,029 --> 00:09:46,160
macros still make a fusion backwards but

00:09:43,130 --> 00:09:49,220
they're much more manageable now and it

00:09:46,160 --> 00:09:56,360
was really not nice so how can we prove

00:09:49,220 --> 00:09:58,640
that first where am i again okay yeah

00:09:56,360 --> 00:10:04,970
printer in micro so it's the example I

00:09:58,640 --> 00:10:08,990
was talking about about a pigeon so now

00:10:04,970 --> 00:10:11,690
we can do some funny stuff norm is full

00:10:08,990 --> 00:10:16,390
of macros that call over macros again

00:10:11,690 --> 00:10:19,880
and again and over so to match a macro

00:10:16,390 --> 00:10:23,600
the idea is you take an ident so the

00:10:19,880 --> 00:10:25,100
thing called sub Mac you put a bank then

00:10:23,600 --> 00:10:28,820
the parents then the arguments of the

00:10:25,100 --> 00:10:31,220
macro then another parents and then I

00:10:28,820 --> 00:10:33,680
match something that behaves like a

00:10:31,220 --> 00:10:37,399
macro and I couldn't call him I can't

00:10:33,680 --> 00:10:39,560
call it afterwards so this is quite cool

00:10:37,399 --> 00:10:42,320
to do which you can combine stuff very

00:10:39,560 --> 00:10:45,260
easy that way and you can go a bit

00:10:42,320 --> 00:10:48,490
further this is an example from the

00:10:45,260 --> 00:10:53,600
documentation to write HTML from like

00:10:48,490 --> 00:10:55,130
square brackets basically you have

00:10:53,600 --> 00:10:57,649
macros column across over and over over

00:10:55,130 --> 00:11:02,600
there's an issue you can run into with

00:10:57,649 --> 00:11:04,699
this is that it's a pain to sometimes

00:11:02,600 --> 00:11:06,829
the compiler will just show up and say

00:11:04,699 --> 00:11:10,640
okay there's just too much recursion

00:11:06,829 --> 00:11:16,760
it's a pain like for the recent path I

00:11:10,640 --> 00:11:17,610
made the compiler side okay there's a 64

00:11:16,760 --> 00:11:20,730
M it on recursion

00:11:17,610 --> 00:11:22,769
no it should be 128 because you do too

00:11:20,730 --> 00:11:25,709
much and then I write the next parser

00:11:22,769 --> 00:11:29,430
and say okay 128 was not enough yet

00:11:25,709 --> 00:11:31,529
I had to refactor a bit of stuff but it

00:11:29,430 --> 00:11:34,890
gets really into the bag at this point

00:11:31,529 --> 00:11:41,250
so maybe we will need some tricks for

00:11:34,890 --> 00:11:42,690
that I should just yeah so let's debug

00:11:41,250 --> 00:11:47,790
the macros because that's the biggest

00:11:42,690 --> 00:11:49,740
pain we have yeah you just put a

00:11:47,790 --> 00:11:52,230
parameter somewhere and something else

00:11:49,740 --> 00:11:53,760
explodes and you will not know from

00:11:52,230 --> 00:11:58,529
where it comes so it's pretty pretty

00:11:53,760 --> 00:12:01,350
annoying so basically I have a list of

00:11:58,529 --> 00:12:05,519
tools to use first one is the pretty

00:12:01,350 --> 00:12:09,240
file basically you can pass arguments to

00:12:05,519 --> 00:12:11,550
Rossi or kangaroo and it will expand all

00:12:09,240 --> 00:12:13,290
the code like if we show you the code

00:12:11,550 --> 00:12:17,640
just after passing the macros and

00:12:13,290 --> 00:12:20,760
importing stuff it's quite useful can be

00:12:17,640 --> 00:12:23,610
a bit verbose at some time but it's

00:12:20,760 --> 00:12:25,470
quite nice so yeah here we have a macro

00:12:23,610 --> 00:12:29,220
that will just take a value and replace

00:12:25,470 --> 00:12:31,949
that with the value plus one and the

00:12:29,220 --> 00:12:33,660
code in the end looks like okay we

00:12:31,949 --> 00:12:37,620
declare a macro but then the main

00:12:33,660 --> 00:12:42,600
function is just value plus one which

00:12:37,620 --> 00:12:47,970
was zero you can do the trace macro

00:12:42,600 --> 00:12:49,949
stuff trace macro is unstable but I

00:12:47,970 --> 00:12:52,949
still use it extensively basically you

00:12:49,949 --> 00:12:55,140
call trace macro through before you use

00:12:52,949 --> 00:12:57,839
your macro and then you can trace micro

00:12:55,140 --> 00:12:59,370
files to stop using because it will just

00:12:57,839 --> 00:13:02,519
run for every macro and it will just

00:12:59,370 --> 00:13:04,230
print how it's expanded and it got just

00:13:02,519 --> 00:13:06,300
really nice with recent versions of the

00:13:04,230 --> 00:13:09,360
compiler before I was just treating

00:13:06,300 --> 00:13:13,880
everything as fast as possible now it's

00:13:09,360 --> 00:13:16,230
trying to to make it more readable and

00:13:13,880 --> 00:13:18,209
here we have just a very small layer but

00:13:16,230 --> 00:13:20,279
in non when you have macros calling

00:13:18,209 --> 00:13:22,320
macros macros if you say ok so this

00:13:20,279 --> 00:13:24,570
thing expended to that and due to that

00:13:22,320 --> 00:13:26,880
and to that and that and you will see

00:13:24,570 --> 00:13:32,150
where it breaks so it's quite quite

00:13:26,880 --> 00:13:36,150
useful there's the lock syntax macro

00:13:32,150 --> 00:13:40,040
she's see which will show like how it

00:13:36,150 --> 00:13:43,200
how something has been called there's

00:13:40,040 --> 00:13:46,230
last one that still useful is string if

00:13:43,200 --> 00:13:48,870
I like basically you call you wrap

00:13:46,230 --> 00:13:50,940
whatever we string we file and you'd be

00:13:48,870 --> 00:13:53,130
able to to print it basically if you

00:13:50,940 --> 00:13:55,950
make a string so this is how I make the

00:13:53,130 --> 00:13:59,610
beginning stuffing in non it's been is

00:13:55,950 --> 00:14:01,740
basically I I have a macro that I

00:13:59,610 --> 00:14:04,050
wrapped with a debug and it will print

00:14:01,740 --> 00:14:08,510
the macro and call it as if it was the

00:14:04,050 --> 00:14:11,550
macro itself so lots and lots of tools

00:14:08,510 --> 00:14:15,030
it can still take some time to to the

00:14:11,550 --> 00:14:17,010
back then understand so I have a few few

00:14:15,030 --> 00:14:20,180
tricks to make sure that you might

00:14:17,010 --> 00:14:32,850
probably walk correctly so basically

00:14:20,180 --> 00:14:34,560
just yep so first being in a macro the

00:14:32,850 --> 00:14:39,720
place where the macro will be called

00:14:34,560 --> 00:14:43,370
from may not be inside your crate so if

00:14:39,720 --> 00:14:46,560
you have a reference to something that's

00:14:43,370 --> 00:14:51,450
inside you crate you have to use the

00:14:46,560 --> 00:14:54,089
dollar crate name to import like to

00:14:51,450 --> 00:14:56,130
create name inside otherwise people we

00:14:54,089 --> 00:14:58,580
have to import the new modules

00:14:56,130 --> 00:15:01,800
everywhere and it will be quite annoying

00:14:58,580 --> 00:15:04,440
you can do that also for the result of

00:15:01,800 --> 00:15:06,620
shown that stuff and so since I wrap

00:15:04,440 --> 00:15:10,770
correctly with the parents and stuff I

00:15:06,620 --> 00:15:13,770
can do my import locally and then have

00:15:10,770 --> 00:15:16,770
something that looks kind of nice in in

00:15:13,770 --> 00:15:18,450
Roscoe I had before everything was fully

00:15:16,770 --> 00:15:20,880
qualified because I could not do the

00:15:18,450 --> 00:15:23,100
importance it was a bit annoying this is

00:15:20,880 --> 00:15:27,060
quite nice to it right like if you see

00:15:23,100 --> 00:15:31,350
the example of the Tri macro that was

00:15:27,060 --> 00:15:34,050
mentioned earlier yeah we fully qualify

00:15:31,350 --> 00:15:36,540
everything but to try macro is okay if

00:15:34,050 --> 00:15:38,550
we have okay something with written we

00:15:36,540 --> 00:15:42,690
give the value if we have never all we

00:15:38,550 --> 00:15:44,220
just do an area return but it's not

00:15:42,690 --> 00:15:45,480
really nice to read that way because

00:15:44,220 --> 00:15:48,720
there's dollar create everywhere

00:15:45,480 --> 00:15:51,480
and with the import stuff it gets more

00:15:48,720 --> 00:15:55,579
manageable so I've been reading writing

00:15:51,480 --> 00:15:55,579
all of them like this it's quite nice

00:15:56,299 --> 00:16:02,669
another thing that's interesting to fix

00:15:59,999 --> 00:16:05,749
there with the macros that expect

00:16:02,669 --> 00:16:10,799
different stuff depending on the order

00:16:05,749 --> 00:16:14,249
you have one macro at the at the end

00:16:10,799 --> 00:16:17,790
like this that they expect like the user

00:16:14,249 --> 00:16:19,470
facing code it's how you will call it

00:16:17,790 --> 00:16:22,109
and then it called the implementation

00:16:19,470 --> 00:16:24,179
that will be prefixed with imp so that

00:16:22,109 --> 00:16:29,220
whatever people are calling it will not

00:16:24,179 --> 00:16:30,809
get into those those alternatives so we

00:16:29,220 --> 00:16:35,040
can make a private part for your macro

00:16:30,809 --> 00:16:37,499
but it will not be called backed by

00:16:35,040 --> 00:16:40,769
people too tightly before I made like a

00:16:37,499 --> 00:16:42,359
separate macro for that but then there

00:16:40,769 --> 00:16:44,249
were people complaining because they

00:16:42,359 --> 00:16:47,489
were trying to selectively import macros

00:16:44,249 --> 00:16:51,269
from none and so like they got the alt

00:16:47,489 --> 00:16:53,819
macro and then they the Saudia to also

00:16:51,269 --> 00:16:55,379
import the art passer macro and or alt

00:16:53,819 --> 00:16:57,359
in from whatever and it was quite

00:16:55,379 --> 00:17:01,279
annoying so you can just fold everything

00:16:57,359 --> 00:17:05,389
inside one use the macro like that a

00:17:01,279 --> 00:17:10,500
very nice trick I really liked now

00:17:05,389 --> 00:17:12,360
macros will just match patterns and when

00:17:10,500 --> 00:17:15,510
you have people that are misusing your

00:17:12,360 --> 00:17:18,000
macros usually they will all you misuse

00:17:15,510 --> 00:17:22,139
it the same way so maybe you can match

00:17:18,000 --> 00:17:25,649
that pattern and so on error message and

00:17:22,139 --> 00:17:28,039
so there was a feature that was merged

00:17:25,649 --> 00:17:31,169
very recently thus available in stable

00:17:28,039 --> 00:17:34,429
hope I will just show an error message

00:17:31,169 --> 00:17:40,260
at compile time

00:17:34,429 --> 00:17:43,080
sorry so the idea is if you match that

00:17:40,260 --> 00:17:46,919
pattern you shown our message with the

00:17:43,080 --> 00:17:48,990
correct syntax this will make the code

00:17:46,919 --> 00:17:53,879
much easier to debug for for people

00:17:48,990 --> 00:17:57,169
since not macros are a bit we had to use

00:17:53,879 --> 00:17:57,169
this is quite good

00:17:58,669 --> 00:18:05,190
I'll never good one I talked earlier

00:18:02,399 --> 00:18:08,880
about using stringy fire stuff this is a

00:18:05,190 --> 00:18:10,350
macro that's used in Dom where if you

00:18:08,880 --> 00:18:13,169
get a collect value it will return the

00:18:10,350 --> 00:18:16,200
value but if you get an error it will

00:18:13,169 --> 00:18:20,730
print the the macro that was called and

00:18:16,200 --> 00:18:22,740
the input we have a hex dump I can do

00:18:20,730 --> 00:18:26,520
that kind of stuff it's quite nice to

00:18:22,740 --> 00:18:28,710
use and it's just like reusing

00:18:26,520 --> 00:18:31,770
components we had before like we have

00:18:28,710 --> 00:18:34,710
stringify we have we matched a macro and

00:18:31,770 --> 00:18:40,950
called called it inside of 25 but also

00:18:34,710 --> 00:18:43,260
inside the match match pattern that way

00:18:40,950 --> 00:18:45,419
it's quite interesting and the

00:18:43,260 --> 00:18:47,730
interesting thing is the dump I can just

00:18:45,419 --> 00:18:53,850
put it anywhere to wrap any macro it

00:18:47,730 --> 00:18:55,230
works concat I don't it's quite

00:18:53,850 --> 00:18:57,240
interesting as well

00:18:55,230 --> 00:18:59,700
might not work for all the use case you

00:18:57,240 --> 00:19:01,230
might have in mind but basically you

00:18:59,700 --> 00:19:07,580
have different names you can concatenate

00:19:01,230 --> 00:19:07,580
them sometimes it's useful sometimes not

00:19:10,010 --> 00:19:18,120
this one is quite fun basically

00:19:15,470 --> 00:19:23,070
basically stop seeing basically it's not

00:19:18,120 --> 00:19:26,149
basic there you have the name the macro

00:19:23,070 --> 00:19:30,360
in them that used to generate a function

00:19:26,149 --> 00:19:32,970
and you can match on attributes and

00:19:30,360 --> 00:19:34,649
patterns and stuff and put them on the

00:19:32,970 --> 00:19:36,480
function and it will work so you can

00:19:34,649 --> 00:19:39,000
have documentation that's passed to the

00:19:36,480 --> 00:19:46,890
macro and will be passed to the to the

00:19:39,000 --> 00:19:54,210
function afterwards the trick is quite

00:19:46,890 --> 00:19:58,260
tricky takes time to sink in

00:19:54,210 --> 00:20:03,090
yeah this is the total passer this is

00:19:58,260 --> 00:20:06,570
not the worst one I wrote you have to

00:20:03,090 --> 00:20:08,790
call different passers in the sequence

00:20:06,570 --> 00:20:11,910
and return the result as

00:20:08,790 --> 00:20:14,280
as a total and so you see the first

00:20:11,910 --> 00:20:16,350
argument is the input and in each

00:20:14,280 --> 00:20:20,790
pattern but the second argument is like

00:20:16,350 --> 00:20:24,090
the expected name of the function the

00:20:20,790 --> 00:20:28,160
expected result and so we passed through

00:20:24,090 --> 00:20:32,520
all of the macros one after another and

00:20:28,160 --> 00:20:38,610
accumulate the the result inside this

00:20:32,520 --> 00:20:43,020
stopper and in the last I can just know

00:20:38,610 --> 00:20:46,950
in the last one we just return the the

00:20:43,020 --> 00:20:50,910
second argument when we have no more no

00:20:46,950 --> 00:20:53,310
more macros so this is a pattern that

00:20:50,910 --> 00:20:57,330
you can use a lot to accumulate stuff

00:20:53,310 --> 00:20:59,310
because sometimes it's like when you

00:20:57,330 --> 00:21:04,710
request you accumulate data over and

00:20:59,310 --> 00:21:08,430
over but instead of allocating anything

00:21:04,710 --> 00:21:12,000
like it will just write exactly the code

00:21:08,430 --> 00:21:18,330
you want with one variable so it's quite

00:21:12,000 --> 00:21:21,030
interesting so those were a lot of very

00:21:18,330 --> 00:21:23,540
weird tricks to write a macro basically

00:21:21,030 --> 00:21:26,790
you don't have to remember much stuff

00:21:23,540 --> 00:21:30,810
just that you can write them so that the

00:21:26,790 --> 00:21:33,630
user friendly when you present them to

00:21:30,810 --> 00:21:35,790
people they away at their how to read so

00:21:33,630 --> 00:21:37,320
make sure that you can do in parts

00:21:35,790 --> 00:21:39,630
correctly that you can separate in

00:21:37,320 --> 00:21:42,620
smaller macros that call each other it's

00:21:39,630 --> 00:21:46,070
much more manageable that way and

00:21:42,620 --> 00:21:49,440
they're quite fun to write really

00:21:46,070 --> 00:21:51,900
because you just start writing code and

00:21:49,440 --> 00:21:56,660
then it generates a lot of stuff and

00:21:51,900 --> 00:22:06,880
it's quite cool in the end thank you

00:21:56,660 --> 00:22:08,990
[Applause]

00:22:06,880 --> 00:22:13,670
okay we have a few minutes for questions

00:22:08,990 --> 00:22:17,660
I have a suggestion we can do questions

00:22:13,670 --> 00:22:24,670
oh we can see the weird the really weird

00:22:17,660 --> 00:22:25,910
stuff Oh weird stuff rest your hands

00:22:24,670 --> 00:22:30,370
okay

00:22:25,910 --> 00:22:34,400
you asked for it don't regret it so I

00:22:30,370 --> 00:22:37,809
showed you the non macros so the thing

00:22:34,400 --> 00:22:43,070
is with the first agreement is the input

00:22:37,809 --> 00:22:43,549
but most of the time I will just where

00:22:43,070 --> 00:22:50,990
am I

00:22:43,549 --> 00:22:54,340
yep so most of the time yeah the first

00:22:50,990 --> 00:22:58,070
argument is the input but when you call

00:22:54,340 --> 00:23:00,799
a an on an imposter

00:22:58,070 --> 00:23:06,470
you don't pass this argument that's

00:23:00,799 --> 00:23:09,500
because the named the name function just

00:23:06,470 --> 00:23:10,970
pass it there so you see a lot of

00:23:09,500 --> 00:23:13,309
microscale in each other and you say

00:23:10,970 --> 00:23:14,960
that where is the input and it's been

00:23:13,309 --> 00:23:16,970
passed automatically and you don't see

00:23:14,960 --> 00:23:19,190
it and this is confusing a lot of people

00:23:16,970 --> 00:23:21,350
because they try to call it on just but

00:23:19,190 --> 00:23:23,720
what's that I argument that's used

00:23:21,350 --> 00:23:26,750
everywhere if you don't you call that

00:23:23,720 --> 00:23:35,540
input yeah maybe but one character is

00:23:26,750 --> 00:23:39,830
enough so the permutation Combinator is

00:23:35,540 --> 00:23:45,470
a really great one where am I

00:23:39,830 --> 00:23:49,760
yeah it's there so the idea is you will

00:23:45,470 --> 00:23:52,100
try to pass stuff to pass stuff in the

00:23:49,760 --> 00:23:53,450
sequence like you have a list of pass or

00:23:52,100 --> 00:23:55,940
to apply but you don't know it which

00:23:53,450 --> 00:23:59,840
order they will go and just know like

00:23:55,940 --> 00:24:02,450
each of them will be called once so

00:23:59,840 --> 00:24:04,429
first you need to like do permission in

00:24:02,450 --> 00:24:08,570
it this is where I create a total of the

00:24:04,429 --> 00:24:11,780
right size which is like basically a

00:24:08,570 --> 00:24:15,640
just a long list of known that will be

00:24:11,780 --> 00:24:15,640
replaced by some something

00:24:16,740 --> 00:24:22,529
then you have the permutation iterate

00:24:19,289 --> 00:24:26,399
that's where we call one passer after

00:24:22,529 --> 00:24:28,559
the next the ID is okay don't forget

00:24:26,399 --> 00:24:31,950
that yet

00:24:28,559 --> 00:24:34,169
the permutation later you call if if the

00:24:31,950 --> 00:24:36,450
current value for the current wizard for

00:24:34,169 --> 00:24:39,779
that passer is known we call the passer

00:24:36,450 --> 00:24:43,460
and if we got a value we press by some

00:24:39,779 --> 00:24:48,149
otherwise we try the next one

00:24:43,460 --> 00:24:52,080
so the interesting thing is when we get

00:24:48,149 --> 00:24:54,690
the result it's like when we know that

00:24:52,080 --> 00:24:57,600
all of them are some something instead

00:24:54,690 --> 00:25:00,299
of known we want to unwrap all of them

00:24:57,600 --> 00:25:02,760
but to get access to one of the

00:25:00,299 --> 00:25:05,760
parameters one of the other elements of

00:25:02,760 --> 00:25:08,460
a tuple you do like my topple dot 0 my

00:25:05,760 --> 00:25:12,149
topple dot 1 or whatever so this is why

00:25:08,460 --> 00:25:15,149
I have this I have the success

00:25:12,149 --> 00:25:18,240
succession Combinator the I call macro

00:25:15,149 --> 00:25:22,169
with 0 and macro and will pass the next

00:25:18,240 --> 00:25:24,990
integer and when I get number and the

00:25:22,169 --> 00:25:27,120
topper topper dot zero dot one and

00:25:24,990 --> 00:25:32,159
whatever and I will do all the unwrap

00:25:27,120 --> 00:25:34,830
track that this this is quite

00:25:32,159 --> 00:25:37,049
interesting to write really it took me

00:25:34,830 --> 00:25:42,110
like a few weeks to just think of how I

00:25:37,049 --> 00:25:42,110
would do it and then just mad evening

00:25:42,770 --> 00:25:47,760
the whitespace Combinator is quite

00:25:44,940 --> 00:25:49,289
interesting at some point for people

00:25:47,760 --> 00:25:51,799
that want to write languages they

00:25:49,289 --> 00:25:57,210
complain that they have to intersperse

00:25:51,799 --> 00:25:58,950
space it in parcels everywhere and I say

00:25:57,210 --> 00:26:00,990
oh yeah that's knowing maybe we can

00:25:58,950 --> 00:26:05,640
write a Combinator for that so you are

00:26:00,990 --> 00:26:09,870
do WS Combinator can just wrap a list of

00:26:05,640 --> 00:26:12,770
macros and it will automatically insert

00:26:09,870 --> 00:26:16,440
the space sitting passers everywhere

00:26:12,770 --> 00:26:20,039
like interval you double will be visit

00:26:16,440 --> 00:26:24,240
in the end space like free space study

00:26:20,039 --> 00:26:28,380
space and the way it's done is well

00:26:24,240 --> 00:26:30,810
macros calling macros like the pair

00:26:28,380 --> 00:26:35,100
separator

00:26:30,810 --> 00:26:37,740
like what we had it called the separator

00:26:35,100 --> 00:26:39,660
and calls each macro recursively we have

00:26:37,740 --> 00:26:46,530
specific versions like every Combinator

00:26:39,660 --> 00:26:51,360
for that and it's a lot of God amazingly

00:26:46,530 --> 00:26:57,380
it works but this is still not the worst

00:26:51,360 --> 00:27:01,620
finger rods so may I introduce the lapa

00:26:57,380 --> 00:27:05,450
project which is M AMQP client in roast

00:27:01,620 --> 00:27:08,870
like RabbitMQ JMS that kind of stuff so

00:27:05,450 --> 00:27:11,300
this protocol is generating from

00:27:08,870 --> 00:27:14,460
specification that's written in XML

00:27:11,300 --> 00:27:16,620
basically that the Z so they give you

00:27:14,460 --> 00:27:18,570
this huge file and they say ok these are

00:27:16,620 --> 00:27:20,940
all the methods all the things you can

00:27:18,570 --> 00:27:23,990
see on the protocol and so you should

00:27:20,940 --> 00:27:33,380
probably generate you cut like that

00:27:23,990 --> 00:27:35,700
let's say ok let's make handlebars

00:27:33,380 --> 00:27:40,110
template but what we call in the build

00:27:35,700 --> 00:27:43,380
script and in that handlebar template I

00:27:40,110 --> 00:27:46,140
will make non macros and I will also use

00:27:43,380 --> 00:27:48,690
cookie factory which is a nice little

00:27:46,140 --> 00:27:51,030
project I made it's kind of like Mak

00:27:48,690 --> 00:27:53,370
like Nam but for serialization

00:27:51,030 --> 00:28:00,470
so that's macros all the way there as

00:27:53,370 --> 00:28:04,560
well and so here's the template so it's

00:28:00,470 --> 00:28:08,990
handlebars and syntax so the mustache

00:28:04,560 --> 00:28:13,460
stuff everywhere and then at some point

00:28:08,990 --> 00:28:15,960
we start defining non parsers and

00:28:13,460 --> 00:28:19,130
generators with cookie factory

00:28:15,960 --> 00:28:21,540
so here it's like for every every method

00:28:19,130 --> 00:28:25,440
within the in that class we will

00:28:21,540 --> 00:28:27,150
generate stuff and we generate when we

00:28:25,440 --> 00:28:28,350
say as we said eyes first the idea of

00:28:27,150 --> 00:28:32,880
the class then the name of the method

00:28:28,350 --> 00:28:38,700
and whatever it gets worse and worse and

00:28:32,880 --> 00:28:42,300
worse from there but it was not that hot

00:28:38,700 --> 00:28:44,310
right like you can generate code and you

00:28:42,300 --> 00:28:44,730
can do very great stuff but it's so

00:28:44,310 --> 00:28:51,780
useful

00:28:44,730 --> 00:28:56,510
- it's not theoretically clean but it

00:28:51,780 --> 00:28:56,510
works thank you

00:28:56,890 --> 00:29:02,779

YouTube URL: https://www.youtube.com/watch?v=8rodUyaGkQo


