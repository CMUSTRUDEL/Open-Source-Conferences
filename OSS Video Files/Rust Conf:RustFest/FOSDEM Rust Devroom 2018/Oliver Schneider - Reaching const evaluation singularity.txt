Title: Oliver Schneider - Reaching const evaluation singularity
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	An introduction into miri and Rust's const evaluation

The Rust interpreter miri has been merged into rustc to be its new const evaluator. This merge not only fixed various bugs in the old const evaluator, it opened up the avenue for many new features. Ever wanted to do a for loop in a constant? Want to parse a toml file into a static Config struct and report parsing errors as compile-time errors? Well, now you can do all that (pending RFCs for the details). In this talk I will present miri's design, its usage in the compile-time evaluator as well as future features that are enabled by it

PhD Student in Software Engineering for Safety and Security Critical Software at the Karlsruhe Institute for Technology since 2014. Rust tools peer (clippy, miri) since 2017. Likes books, embedded development, programming languages and dogs.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_miri_const_evaluation/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:04:58,940 --> 00:05:06,000
hello perfect okay so how do works now

00:05:02,990 --> 00:05:07,440
so at the end you get a thirteen so it

00:05:06,000 --> 00:05:08,940
doesn't go country valuing works well

00:05:07,440 --> 00:05:13,110
this actually called constant folding

00:05:08,940 --> 00:05:14,610
but the difference is moot so now we get

00:05:13,110 --> 00:05:16,530
to more complex stuff imagine you have a

00:05:14,610 --> 00:05:18,960
function it has local variables and it

00:05:16,530 --> 00:05:21,569
has some loops and stuff so how do you

00:05:18,960 --> 00:05:24,419
consult that like turn that into a tree

00:05:21,569 --> 00:05:26,099
and start collapsing it like that's not

00:05:24,419 --> 00:05:28,199
really possible this is code that you

00:05:26,099 --> 00:05:31,050
walk down from the bot to the bottom and

00:05:28,199 --> 00:05:33,000
you execute its instruction after each

00:05:31,050 --> 00:05:34,620
other like you would do at runtime but

00:05:33,000 --> 00:05:36,979
this is not possible if you try to

00:05:34,620 --> 00:05:41,099
combine things like you cannot combine

00:05:36,979 --> 00:05:42,509
why divides equals two because what are

00:05:41,099 --> 00:05:44,400
you combining there there's there's no

00:05:42,509 --> 00:05:46,919
two values to combine to something else

00:05:44,400 --> 00:05:49,169
so we were trying to look up for a look

00:05:46,919 --> 00:05:50,699
at something new where we could do local

00:05:49,169 --> 00:05:52,289
variables which are not possible in

00:05:50,699 --> 00:05:55,199
constants right now where you can do

00:05:52,289 --> 00:05:56,639
mutation and where we can do loops these

00:05:55,199 --> 00:05:58,050
are things that we want to be able to do

00:05:56,639 --> 00:06:00,719
it like right now you cannot do them at

00:05:58,050 --> 00:06:02,969
compile time you you just can do them at

00:06:00,719 --> 00:06:04,530
runtime but even if the if there's an

00:06:02,969 --> 00:06:06,210
error in this program you won't detect

00:06:04,530 --> 00:06:09,810
it at compile time it'll panic at

00:06:06,210 --> 00:06:12,419
runtime so the compiler developers

00:06:09,810 --> 00:06:15,240
decided to do it right they created a

00:06:12,419 --> 00:06:18,509
mirror which is a structure that allows

00:06:15,240 --> 00:06:20,099
you to do the sequential constant

00:06:18,509 --> 00:06:22,050
evaluation instead of the folding and

00:06:20,099 --> 00:06:24,319
then somebody wrote something called

00:06:22,050 --> 00:06:27,599
Miri which is the mirror interpreter

00:06:24,319 --> 00:06:30,120
which allows you to evaluate Mir code

00:06:27,599 --> 00:06:32,280
and if the mir code contains solely

00:06:30,120 --> 00:06:33,870
constants well then you can just

00:06:32,280 --> 00:06:35,520
evaluate it to the end and look at the

00:06:33,870 --> 00:06:38,250
end result and then store the end result

00:06:35,520 --> 00:06:40,949
and when you started doing it they were

00:06:38,250 --> 00:06:43,500
looking at like integers and and adding

00:06:40,949 --> 00:06:45,120
them and similar things like that but at

00:06:43,500 --> 00:06:48,539
some point they kind of got crazy and

00:06:45,120 --> 00:06:51,090
then we got pointers and pointer

00:06:48,539 --> 00:06:53,039
arithmetic and calling C functions and

00:06:51,090 --> 00:06:54,960
calling syscalls and yeah right now

00:06:53,039 --> 00:06:57,630
we're not quite at reading files yet but

00:06:54,960 --> 00:07:00,060
we can do print line and reading from s

00:06:57,630 --> 00:07:04,380
Citian so if you just pipe your file

00:07:00,060 --> 00:07:05,699
until the SDN you can read files that's

00:07:04,380 --> 00:07:06,990
a little bit much for currency valuation

00:07:05,699 --> 00:07:10,889
but well

00:07:06,990 --> 00:07:13,919
we try to get there so last year I added

00:07:10,889 --> 00:07:15,599
Mira to Rusty as an experiment where we

00:07:13,919 --> 00:07:17,610
were running the old console a little

00:07:15,599 --> 00:07:19,440
next to the new one and comparing them

00:07:17,610 --> 00:07:20,849
so just to make sure like we're not

00:07:19,440 --> 00:07:22,410
introducing any weird stuff that we

00:07:20,849 --> 00:07:24,569
don't want to have because right now we

00:07:22,410 --> 00:07:26,729
just want to get the new we're married

00:07:24,569 --> 00:07:28,139
so we can get new features in the future

00:07:26,729 --> 00:07:30,569
but we don't want to break anybody's

00:07:28,139 --> 00:07:34,530
code so that was running well in

00:07:30,569 --> 00:07:37,259
December that was a big pull request a

00:07:34,530 --> 00:07:40,800
trust fest which had like a 1,600

00:07:37,259 --> 00:07:43,229
commits it has 7k lines of code added to

00:07:40,800 --> 00:07:46,770
the rest compiler which is a lot but you

00:07:43,229 --> 00:07:48,419
have to remember this is something

00:07:46,770 --> 00:07:50,400
that's essentially a virtual machine

00:07:48,419 --> 00:07:53,130
running your rest code at compile time

00:07:50,400 --> 00:07:57,720
and producing a value that you can then

00:07:53,130 --> 00:08:00,060
compile down into your final binary the

00:07:57,720 --> 00:08:02,729
next step was well removing the old

00:08:00,060 --> 00:08:05,099
console valuator which touched another

00:08:02,729 --> 00:08:06,960
6,000 lines of code but it doesn't add

00:08:05,099 --> 00:08:09,389
anything new instead it removed all the

00:08:06,960 --> 00:08:13,349
old crap that we had in there in the old

00:08:09,389 --> 00:08:14,909
compiler and well now it's gone the pull

00:08:13,349 --> 00:08:16,949
request isn't merged yet but it's

00:08:14,909 --> 00:08:18,509
running right now is the rest compiled

00:08:16,949 --> 00:08:20,099
developers are merging it at the moment

00:08:18,509 --> 00:08:22,139
it's basically already approved just

00:08:20,099 --> 00:08:24,360
checking every single crate and crate

00:08:22,139 --> 00:08:26,130
sale whether we don't break it with the

00:08:24,360 --> 00:08:29,400
gnu compiler because well we don't want

00:08:26,130 --> 00:08:31,919
to break anybody's code so let's go back

00:08:29,400 --> 00:08:33,750
to the bottom what is Mir Mir is called

00:08:31,919 --> 00:08:35,640
the medium intermediate representation

00:08:33,750 --> 00:08:38,550
where what's that well it's basically an

00:08:35,640 --> 00:08:42,390
assembler assembler language but it's

00:08:38,550 --> 00:08:46,170
very close to what how rust builds here

00:08:42,390 --> 00:08:47,520
your code so you have types you don't

00:08:46,170 --> 00:08:50,490
have any registers you have local

00:08:47,520 --> 00:08:51,959
variables and it's already used for a

00:08:50,490 --> 00:08:54,000
lot of things like Baro checking is done

00:08:51,959 --> 00:08:55,440
completely on the mirror so that's where

00:08:54,000 --> 00:08:58,110
we're getting nonlinear lifetimes in the

00:08:55,440 --> 00:09:00,270
future from from Mir and Baro checking

00:08:58,110 --> 00:09:01,980
on the mirror also in the future we

00:09:00,270 --> 00:09:03,300
might be able to do guaranteed

00:09:01,980 --> 00:09:04,980
optimizations like tail call

00:09:03,300 --> 00:09:09,029
optimization and so on on the mir like

00:09:04,980 --> 00:09:12,870
everything that's rust required will be

00:09:09,029 --> 00:09:14,339
done on a mirror so mirror looks a

00:09:12,870 --> 00:09:16,770
little bit like that it's like a big

00:09:14,339 --> 00:09:19,949
text blob that you can't really read

00:09:16,770 --> 00:09:20,790
it's essentially if you if you read all

00:09:19,949 --> 00:09:22,080
the small steps

00:09:20,790 --> 00:09:25,560
there it looks like rest code but

00:09:22,080 --> 00:09:28,020
there's go to us in there like a lot of

00:09:25,560 --> 00:09:29,730
go tooth and you don't want to read code

00:09:28,020 --> 00:09:30,900
let's go to us so instead you can

00:09:29,730 --> 00:09:32,880
convert it into a graphical

00:09:30,900 --> 00:09:34,170
representation so this is exactly the

00:09:32,880 --> 00:09:35,880
same code this and this is the same

00:09:34,170 --> 00:09:37,920
thing the only difference is all the

00:09:35,880 --> 00:09:39,990
local variables declared on top are

00:09:37,920 --> 00:09:42,030
turned into virtual stack and all the

00:09:39,990 --> 00:09:44,370
blocks in there with go-to are turned

00:09:42,030 --> 00:09:47,250
into a graph was arrows between them so

00:09:44,370 --> 00:09:48,690
you can actually read your code and this

00:09:47,250 --> 00:09:52,890
is actually a tool that you can use to

00:09:48,690 --> 00:09:55,470
step through your your constant code to

00:09:52,890 --> 00:09:58,380
check like what is the doing what is the

00:09:55,470 --> 00:10:03,530
the virtual memory of Mary doing well

00:09:58,380 --> 00:10:03,530
what's going on and yeah

00:10:04,220 --> 00:10:11,190
so Mary is a mere interpreter so you can

00:10:08,690 --> 00:10:12,420
execute all the code it has no undefined

00:10:11,190 --> 00:10:15,060
behavior you can do pointer arithmetic

00:10:12,420 --> 00:10:16,860
you can do whatever you want and if you

00:10:15,060 --> 00:10:19,320
try to do anything behavior compiler

00:10:16,860 --> 00:10:21,450
will simply tell you well you try to do

00:10:19,320 --> 00:10:21,810
anything any behavior here please don't

00:10:21,450 --> 00:10:24,810
do that

00:10:21,810 --> 00:10:26,880
so it'll give you an error message that

00:10:24,810 --> 00:10:28,650
like it looks like a rest compiler error

00:10:26,880 --> 00:10:30,150
message it just tells you at this line

00:10:28,650 --> 00:10:34,230
of code you're doing any fine behavior

00:10:30,150 --> 00:10:35,850
just stop and try again and this works

00:10:34,230 --> 00:10:37,740
for a lot of things like like please try

00:10:35,850 --> 00:10:40,020
to break Mary it's really hard like

00:10:37,740 --> 00:10:42,270
there's a few things that we know about

00:10:40,020 --> 00:10:44,730
like you can actually mutate non mutable

00:10:42,270 --> 00:10:47,490
variables but that's basically by the

00:10:44,730 --> 00:10:49,980
definition a mutable variable is just a

00:10:47,490 --> 00:10:52,920
lint telling you you are allowed to

00:10:49,980 --> 00:10:55,320
mutate it but whether you like that at a

00:10:52,920 --> 00:10:58,350
background memory is mutable that's

00:10:55,320 --> 00:11:00,540
completely well you're completely

00:10:58,350 --> 00:11:02,400
allowed to modify it actually there's no

00:11:00,540 --> 00:11:09,180
nothing restricting you from modifying

00:11:02,400 --> 00:11:11,100
immutable variable yeah so I already

00:11:09,180 --> 00:11:13,200
told you me read the tool it can do a

00:11:11,100 --> 00:11:17,930
lot of stuff like read from command line

00:11:13,200 --> 00:11:19,890
or do some syscalls some easier ones but

00:11:17,930 --> 00:11:22,200
well we don't want all of that in

00:11:19,890 --> 00:11:25,320
compiler so what we're doing right now

00:11:22,200 --> 00:11:28,530
is we're separating Merida tool and Mary

00:11:25,320 --> 00:11:29,790
the constable Raider and the constant

00:11:28,530 --> 00:11:30,990
value that does everything you expect

00:11:29,790 --> 00:11:33,750
from constable

00:11:30,990 --> 00:11:35,399
it computes your plusses your

00:11:33,750 --> 00:11:37,950
multiplications it calls functions and

00:11:35,399 --> 00:11:39,300
so on but it doesn't do print line it

00:11:37,950 --> 00:11:40,860
doesn't use those calls because this

00:11:39,300 --> 00:11:43,260
calls Jenkins revaluation that's just

00:11:40,860 --> 00:11:45,600
weird but we might do it in the future

00:11:43,260 --> 00:11:46,950
but we'll need RFC's for that because we

00:11:45,600 --> 00:11:50,040
don't just randomly want to enable

00:11:46,950 --> 00:11:51,690
random features that maybe are bad so

00:11:50,040 --> 00:11:53,790
but what you can do instead was married

00:11:51,690 --> 00:11:56,070
a tool is well you have a test suite and

00:11:53,790 --> 00:11:57,990
you kind of getting undefined behavior

00:11:56,070 --> 00:11:58,709
somewhere you don't know where so you

00:11:57,990 --> 00:12:01,110
just run

00:11:58,709 --> 00:12:03,140
kygo miri instead of Karger test and

00:12:01,110 --> 00:12:05,490
it'll run all your tests with miry

00:12:03,140 --> 00:12:07,350
through the console valuator so if you

00:12:05,490 --> 00:12:09,450
do any undefined behavior it'll just

00:12:07,350 --> 00:12:11,270
stop and tell you this test at this line

00:12:09,450 --> 00:12:14,160
of code is doing anything behavior and

00:12:11,270 --> 00:12:17,220
to top off on that it'll print a stack

00:12:14,160 --> 00:12:18,630
trace like if you're inside lip STD in

00:12:17,220 --> 00:12:21,000
the vector function push inside

00:12:18,630 --> 00:12:22,860
something whatever deep it'll tell you a

00:12:21,000 --> 00:12:25,080
stack trace down to where you're doing

00:12:22,860 --> 00:12:26,850
undefined behavior it's not like gdb

00:12:25,080 --> 00:12:30,720
which which crashes at some point when

00:12:26,850 --> 00:12:32,490
you're at an actual error it it stops

00:12:30,720 --> 00:12:34,200
you right when you're doing a defined

00:12:32,490 --> 00:12:35,579
behavior like right before it and then

00:12:34,200 --> 00:12:37,860
you can even look at the memory and say

00:12:35,579 --> 00:12:40,050
okay well how does it look what where am

00:12:37,860 --> 00:12:42,000
i all right now and then you can find

00:12:40,050 --> 00:12:46,350
out how your code is doing anything

00:12:42,000 --> 00:12:48,089
behavior so this is the tool side

00:12:46,350 --> 00:12:49,740
effects of using all of this and cons

00:12:48,089 --> 00:12:51,120
evaluation is you can start doing heap

00:12:49,740 --> 00:12:53,730
allocation in constants

00:12:51,120 --> 00:12:55,020
well you can't we disabled it but we

00:12:53,730 --> 00:12:56,940
will be able to build and if in the

00:12:55,020 --> 00:12:59,640
futures they can do strings you can do

00:12:56,940 --> 00:13:02,220
serda decoding of JSON files at compile

00:12:59,640 --> 00:13:03,810
time convert that into a structure

00:13:02,220 --> 00:13:05,700
store that structure and static memory

00:13:03,810 --> 00:13:07,470
and then you have your configuration

00:13:05,700 --> 00:13:09,930
already parsed already check for errors

00:13:07,470 --> 00:13:11,490
everything at compile time in memory

00:13:09,930 --> 00:13:13,050
they could just say okay we're like

00:13:11,490 --> 00:13:14,910
what's the setting and you get the

00:13:13,050 --> 00:13:15,959
setting you you don't need to check

00:13:14,910 --> 00:13:18,180
anything you don't need it I'm gonna

00:13:15,959 --> 00:13:19,829
have the file present and you have like

00:13:18,180 --> 00:13:21,600
a big configuration file like a JSON or

00:13:19,829 --> 00:13:23,459
XML this might take megabytes or

00:13:21,600 --> 00:13:25,980
something convert them down to binary is

00:13:23,459 --> 00:13:29,279
the down to kilobytes or even less so

00:13:25,980 --> 00:13:31,220
you save all the computation time at

00:13:29,279 --> 00:13:33,870
compile time you save all the memory and

00:13:31,220 --> 00:13:40,340
you even get error checking at compile

00:13:33,870 --> 00:13:46,790
time so yeah these are a side-effect

00:13:40,340 --> 00:13:48,560
[Applause]

00:13:46,790 --> 00:13:50,440
there's still some things that we need

00:13:48,560 --> 00:13:54,320
to do in the future

00:13:50,440 --> 00:13:55,780
for example there's some very complex

00:13:54,320 --> 00:13:57,800
things when people start using

00:13:55,780 --> 00:14:00,650
associated types and associated

00:13:57,800 --> 00:14:01,160
constants like technically do you think

00:14:00,650 --> 00:14:03,650
so all right

00:14:01,160 --> 00:14:05,810
but Miria will just say sorry this is

00:14:03,650 --> 00:14:07,130
too complex for me the old Kong sevillio

00:14:05,810 --> 00:14:09,980
said the same thing so we're not losing

00:14:07,130 --> 00:14:11,690
any and any features here but the thing

00:14:09,980 --> 00:14:14,060
is was Miri we can actually start doing

00:14:11,690 --> 00:14:15,830
these things like we can think about how

00:14:14,060 --> 00:14:17,900
are you going to do is we we have a

00:14:15,830 --> 00:14:20,570
structured way to approach this for

00:14:17,900 --> 00:14:23,800
example think about you have an array

00:14:20,570 --> 00:14:27,170
and the length of the array depends on a

00:14:23,800 --> 00:14:30,890
trait implementation for this array that

00:14:27,170 --> 00:14:32,360
you don't know the length of so you need

00:14:30,890 --> 00:14:33,680
to look at the trait implementation but

00:14:32,360 --> 00:14:34,940
to get at a trait implementation you

00:14:33,680 --> 00:14:36,620
need to have to type for which you need

00:14:34,940 --> 00:14:38,390
the length for which you need to trade

00:14:36,620 --> 00:14:42,140
implementation yeah you're gonna end in

00:14:38,390 --> 00:14:44,300
a cycle so but maybe that value you need

00:14:42,140 --> 00:14:46,850
for the length is completely independent

00:14:44,300 --> 00:14:48,770
of the length that you need so there's

00:14:46,850 --> 00:14:51,290
no cycle it's it's just an information

00:14:48,770 --> 00:14:52,730
attached to the array in general and to

00:14:51,290 --> 00:14:54,560
do these things that's called partial

00:14:52,730 --> 00:14:56,750
evaluation because you don't know

00:14:54,560 --> 00:14:58,490
everything but you know enough to

00:14:56,750 --> 00:14:59,690
compute the value and this is the big

00:14:58,490 --> 00:15:03,460
thing that we're gonna be working on

00:14:59,690 --> 00:15:06,320
this year but it's gonna take time and

00:15:03,460 --> 00:15:09,410
yeah we're not a big thing that we're

00:15:06,320 --> 00:15:14,990
working on is allowing for example gdb

00:15:09,410 --> 00:15:20,330
to run rest code with miry on actual

00:15:14,990 --> 00:15:23,060
physical memory so instead of trying to

00:15:20,330 --> 00:15:25,040
actually execute real code you're gonna

00:15:23,060 --> 00:15:27,710
run these things on your actual memory

00:15:25,040 --> 00:15:30,830
but with the miry debugger checking the

00:15:27,710 --> 00:15:33,200
code for things like undefined behavior

00:15:30,830 --> 00:15:35,270
and so on in your debugger so you can

00:15:33,200 --> 00:15:37,430
run gdb and then you execute a small

00:15:35,270 --> 00:15:39,410
command it got compiled it'll get run by

00:15:37,430 --> 00:15:41,840
Miri and I'll tell you some results that

00:15:39,410 --> 00:15:44,300
you usually could not get because this

00:15:41,840 --> 00:15:50,000
kind of complex evaluation just isn't

00:15:44,300 --> 00:15:51,500
possible in gdb also one feature that we

00:15:50,000 --> 00:15:53,310
want to have if you compile your code

00:15:51,500 --> 00:15:56,249
and you have a constant evaluation

00:15:53,310 --> 00:15:59,009
well compiler could stop at that point

00:15:56,249 --> 00:16:01,019
and offer your debugging window telling

00:15:59,009 --> 00:16:02,699
you exactly what went wrong like you

00:16:01,019 --> 00:16:04,379
usually get a stack trace that tells you

00:16:02,699 --> 00:16:05,970
okay it went wrong here and there and

00:16:04,379 --> 00:16:08,430
there and there but you don't know any

00:16:05,970 --> 00:16:09,689
values you know you don't know how the

00:16:08,430 --> 00:16:11,430
memory looks maybe you did some weird

00:16:09,689 --> 00:16:13,019
pointers things and your constants you

00:16:11,430 --> 00:16:15,389
don't know exactly what's going on so

00:16:13,019 --> 00:16:18,120
the next step is to allow you to call

00:16:15,389 --> 00:16:19,709
your compiler and then just stop when

00:16:18,120 --> 00:16:22,230
something goes wrong and inspect what

00:16:19,709 --> 00:16:24,209
exactly exactly is going on so these are

00:16:22,230 --> 00:16:25,949
things that we are working on but what's

00:16:24,209 --> 00:16:28,410
even better for you is you can help too

00:16:25,949 --> 00:16:29,819
and you can write RFC's because we have

00:16:28,410 --> 00:16:34,139
a lot of features that are basically

00:16:29,819 --> 00:16:36,360
just error needs RFC formats some texts

00:16:34,139 --> 00:16:38,249
about what kind of RC we need this is

00:16:36,360 --> 00:16:40,920
literally just to check if something is

00:16:38,249 --> 00:16:42,809
not allowed report this error and below

00:16:40,920 --> 00:16:45,480
us the code that would execute if it

00:16:42,809 --> 00:16:47,339
were allowed so the code is there like

00:16:45,480 --> 00:16:50,910
we just need our seats you need to write

00:16:47,339 --> 00:16:52,860
a text and that explains how to how this

00:16:50,910 --> 00:16:54,329
affects our things but you need to write

00:16:52,860 --> 00:16:56,100
it from a user perspective you don't

00:16:54,329 --> 00:16:57,899
need to care about implementation the

00:16:56,100 --> 00:16:59,370
implementation is there you just need to

00:16:57,899 --> 00:17:03,059
write how you wanted this feature to

00:16:59,370 --> 00:17:05,130
work and we can just turn it on so yeah

00:17:03,059 --> 00:17:06,569
please do that we need RFC's and we

00:17:05,130 --> 00:17:09,260
don't have enough people annoying the

00:17:06,569 --> 00:17:12,179
arrest compiler or developers to

00:17:09,260 --> 00:17:14,159
actually enable the features if the

00:17:12,179 --> 00:17:17,299
features required by enough people we're

00:17:14,159 --> 00:17:17,299
probably going to get it pretty quickly

00:17:17,659 --> 00:17:22,949
yeah one other thing you can do you can

00:17:20,819 --> 00:17:24,959
go to the rest compiler and look through

00:17:22,949 --> 00:17:27,419
the documentation and think this

00:17:24,959 --> 00:17:28,740
function doesn't do anything weird it

00:17:27,419 --> 00:17:31,440
doesn't do anything that depends on

00:17:28,740 --> 00:17:34,140
runtime value is no randomization and so

00:17:31,440 --> 00:17:36,480
on mmm it could be a constant function

00:17:34,140 --> 00:17:38,340
this function could be evaluated at

00:17:36,480 --> 00:17:41,070
compile time so all you need to do is

00:17:38,340 --> 00:17:43,679
open an put request to the rest compiler

00:17:41,070 --> 00:17:46,350
writing Const in front of the FN and

00:17:43,679 --> 00:17:47,460
you're already helping us because you

00:17:46,350 --> 00:17:48,929
found a function that we couldn't make

00:17:47,460 --> 00:17:50,039
Const there's a pull request you're

00:17:48,929 --> 00:17:52,200
talking with the rest compiler

00:17:50,039 --> 00:17:55,260
developers about it and we're gonna turn

00:17:52,200 --> 00:17:59,250
in a constant and then it works it's now

00:17:55,260 --> 00:18:01,500
a constant function these things are

00:17:59,250 --> 00:18:03,870
really easy to do but somebody needs to

00:18:01,500 --> 00:18:05,700
do them and we already trying to do hard

00:18:03,870 --> 00:18:06,450
saying so would be really cool if you

00:18:05,700 --> 00:18:10,080
guys

00:18:06,450 --> 00:18:11,430
help us there and yeah make the rest

00:18:10,080 --> 00:18:12,950
compiler even more awesome than it

00:18:11,430 --> 00:18:24,750
already is

00:18:12,950 --> 00:18:38,340
Thanks so does anybody have any

00:18:24,750 --> 00:18:41,490
questions yes okay the question is if we

00:18:38,340 --> 00:18:43,520
can automate the process from finding

00:18:41,490 --> 00:18:46,380
functions that could be constant and

00:18:43,520 --> 00:18:49,320
making them making these suggestions

00:18:46,380 --> 00:18:51,780
automatic we probably can that's I have

00:18:49,320 --> 00:18:54,120
no idea why I've never thought about

00:18:51,780 --> 00:18:57,210
that that's like I'm developing Clippy

00:18:54,120 --> 00:18:59,130
like every few weeks but yeah that's

00:18:57,210 --> 00:19:00,600
that's really good question we should

00:18:59,130 --> 00:19:02,550
totally do that it won't work for

00:19:00,600 --> 00:19:05,340
everything like it's really hard to

00:19:02,550 --> 00:19:08,310
detect if something is considerable if

00:19:05,340 --> 00:19:09,960
it were easy we just do it automatic and

00:19:08,310 --> 00:19:12,330
you wouldn't need to annotate anything

00:19:09,960 --> 00:19:16,200
but it is basically the halting problem

00:19:12,330 --> 00:19:19,230
like sometimes to check whether function

00:19:16,200 --> 00:19:20,670
is considerable you probably need

00:19:19,230 --> 00:19:20,910
infinite computation time to figure it

00:19:20,670 --> 00:19:23,760
out

00:19:20,910 --> 00:19:25,050
so that might not quite work out but for

00:19:23,760 --> 00:19:34,500
the easy things we can definitely do

00:19:25,050 --> 00:19:36,930
that yes the question is where they're

00:19:34,500 --> 00:19:39,120
adding cons to a constant to a function

00:19:36,930 --> 00:19:41,490
so making it a constant would be a

00:19:39,120 --> 00:19:43,440
breaking change no it will never be a

00:19:41,490 --> 00:19:45,750
breaking change to move from FN to

00:19:43,440 --> 00:19:48,090
conserve n that's impossible to be

00:19:45,750 --> 00:19:49,440
breaking change in by itself what would

00:19:48,090 --> 00:19:49,770
be a breaking change is going the other

00:19:49,440 --> 00:19:52,920
way

00:19:49,770 --> 00:19:54,570
quantum constant to FN to say this means

00:19:52,920 --> 00:19:56,970
you need to think about whether this

00:19:54,570 --> 00:19:59,430
function would ever in the future of

00:19:56,970 --> 00:20:01,740
rust do something that could be not

00:19:59,430 --> 00:20:03,360
constant for example access random

00:20:01,740 --> 00:20:06,090
number generators or do something other

00:20:03,360 --> 00:20:09,000
like actually in the current time or so

00:20:06,090 --> 00:20:10,740
so on if it would ever do that in the

00:20:09,000 --> 00:20:12,660
future then you cannot turn it from FN

00:20:10,740 --> 00:20:14,190
to constant right now this is something

00:20:12,660 --> 00:20:15,600
that wouldn't be automatically checkable

00:20:14,190 --> 00:20:17,809
because it's just semantics of the

00:20:15,600 --> 00:20:25,919
function

00:20:17,809 --> 00:20:28,320
yes okay I am prepared for this question

00:20:25,919 --> 00:20:28,859
because Pascal already asked me this

00:20:28,320 --> 00:20:31,409
question

00:20:28,859 --> 00:20:33,479
so sufficiently advanced incremental

00:20:31,409 --> 00:20:36,539
compilation it's indistinguishable from

00:20:33,479 --> 00:20:37,559
a ripple so the rest can pilot if

00:20:36,539 --> 00:20:39,119
they're doing incremental compilation

00:20:37,559 --> 00:20:41,609
things we might have heard about those

00:20:39,119 --> 00:20:43,709
this is to speed up compilation so

00:20:41,609 --> 00:20:46,409
instead of having to recompile for

00:20:43,709 --> 00:20:47,940
adding a small variable or anything the

00:20:46,409 --> 00:20:51,209
compiler just recompile supports that

00:20:47,940 --> 00:20:54,570
you changed if you get this incremental

00:20:51,209 --> 00:20:57,450
compilation good enough at some point

00:20:54,570 --> 00:20:59,669
you won't care if there's no repple

00:20:57,450 --> 00:21:01,589
because you'll just be weak like the

00:20:59,669 --> 00:21:03,749
repple will be just a wrapper around the

00:21:01,589 --> 00:21:05,999
rest compiler that just adds new stuff

00:21:03,749 --> 00:21:07,619
to a file and then reruns the rest

00:21:05,999 --> 00:21:10,320
compiler and memory

00:21:07,619 --> 00:21:11,849
the country valuation memorizes with

00:21:10,320 --> 00:21:14,039
Instragram incremental compilation the

00:21:11,849 --> 00:21:16,259
values from the previous compilation so

00:21:14,039 --> 00:21:23,359
this will be a batch script with like

00:21:16,259 --> 00:21:23,359
three lines yes

00:21:33,120 --> 00:21:40,210
the question is since mutable

00:21:37,750 --> 00:21:44,259
immutability is to default for locals

00:21:40,210 --> 00:21:46,360
and so on would it be better like if

00:21:44,259 --> 00:21:48,970
Rath started in you to make everything

00:21:46,360 --> 00:21:51,659
default consonant and then half of a

00:21:48,970 --> 00:21:53,440
flag for making it not constant I

00:21:51,659 --> 00:21:56,710
personally would think that would be the

00:21:53,440 --> 00:21:58,059
correct solution we had a narf see about

00:21:56,710 --> 00:21:59,769
that where there was a big discussion

00:21:58,059 --> 00:22:01,990
about it and at some point we just

00:21:59,769 --> 00:22:08,830
realized well switching around would be

00:22:01,990 --> 00:22:11,019
a breaking change so it it's

00:22:08,830 --> 00:22:13,870
questionable like you can't really test

00:22:11,019 --> 00:22:15,460
it like with immutability and mutability

00:22:13,870 --> 00:22:17,139
it's easy to just look at big database a

00:22:15,460 --> 00:22:19,210
big big code basis and look how it's

00:22:17,139 --> 00:22:22,029
done there but Wisconsin ofin the

00:22:19,210 --> 00:22:24,399
problem is there's not much previous

00:22:22,029 --> 00:22:26,529
experience about that like we have other

00:22:24,399 --> 00:22:29,110
languages that do best effort console

00:22:26,529 --> 00:22:30,759
valuation where you for example enlist

00:22:29,110 --> 00:22:32,230
where you just throw random statements

00:22:30,759 --> 00:22:36,700
in there and they're gonna get evaluated

00:22:32,230 --> 00:22:38,740
if they are valuable and here we try to

00:22:36,700 --> 00:22:42,370
do it upfront by by deciding whether

00:22:38,740 --> 00:22:44,350
it's constant variable or not it's a

00:22:42,370 --> 00:22:45,639
really hard decision and it would

00:22:44,350 --> 00:22:48,370
probably be better to do the other way

00:22:45,639 --> 00:22:50,379
around but that might just lead to

00:22:48,370 --> 00:22:53,799
people randomly throwing not constant on

00:22:50,379 --> 00:22:55,360
it so right now we're just opting for

00:22:53,799 --> 00:22:57,279
the Lindt option that tells you when to

00:22:55,360 --> 00:22:59,580
make it constant and then you're done

00:22:57,279 --> 00:22:59,580
with it

00:23:15,790 --> 00:23:24,680

YouTube URL: https://www.youtube.com/watch?v=EnL2mhkyeuE


