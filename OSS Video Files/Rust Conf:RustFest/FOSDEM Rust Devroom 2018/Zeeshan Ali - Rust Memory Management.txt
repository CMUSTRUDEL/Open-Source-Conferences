Title: Zeeshan Ali - Rust Memory Management
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	A short intro

A quick introduction to the unique memory management concepts of Rust.

Rust is a systems programming language that focuses on safety and performance at the same time. Most people new to Rust, often struggle with memory management. The goal of this talk is to give a very quick overview of Rust's memory management.


Developer, helicopter pilot and cat lover.
I'm a software developer with many years of C and Vala experience but more recently I've been in love with Rust language. I work for Kinvolk GmbH in Berlin. I've a private pilot license for helicopters and a very loving and lovely cat.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_memory_management_intro/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:22,950 --> 00:00:28,720
hello everyone I wasn't expecting this

00:00:26,230 --> 00:00:31,270
many people say I care for people

00:00:28,720 --> 00:00:33,520
because it's 10:00 in the morning but

00:00:31,270 --> 00:00:37,269
yeah thanks for coming

00:00:33,520 --> 00:00:40,449
I my name is Ishaan I work at a company

00:00:37,269 --> 00:00:43,030
small company in Berlin called kinfolk

00:00:40,449 --> 00:00:45,579
it's a far higher Linux expertise

00:00:43,030 --> 00:00:49,889
company mostly I work around kubernetes

00:00:45,579 --> 00:00:53,559
and stuff container technologies and

00:00:49,889 --> 00:00:56,889
I've been fond of rust for a long time

00:00:53,559 --> 00:00:58,629
ever since it was first introduced it

00:00:56,889 --> 00:01:00,969
was pretty unstable so nobody could use

00:00:58,629 --> 00:01:04,479
it but lately I have been using it

00:01:00,969 --> 00:01:06,880
especially now also at work a bit so

00:01:04,479 --> 00:01:09,340
yeah I wanted to introduce memory

00:01:06,880 --> 00:01:11,680
management because a lot of people when

00:01:09,340 --> 00:01:14,170
they come across this new language they

00:01:11,680 --> 00:01:16,240
stumble with at least I did I was really

00:01:14,170 --> 00:01:18,579
having a hard time with the memory

00:01:16,240 --> 00:01:24,700
aspect of it so it's good to have an

00:01:18,579 --> 00:01:28,500
introduction to that so how many of you

00:01:24,700 --> 00:01:32,020
know essential rust like some some of it

00:01:28,500 --> 00:01:33,759
okay quite many so I do I won't get into

00:01:32,020 --> 00:01:36,250
a lot of details anyway but I'll just

00:01:33,759 --> 00:01:39,850
quickly introduce the aspects that I'll

00:01:36,250 --> 00:01:41,439
use later in the examples well mainly

00:01:39,850 --> 00:01:44,979
it's like a system programming language

00:01:41,439 --> 00:01:47,320
so it's there some programming languages

00:01:44,979 --> 00:01:49,990
they ensure safety some programming

00:01:47,320 --> 00:01:51,729
languages ensure efficiency but with

00:01:49,990 --> 00:01:53,829
rust you have both of them at the same

00:01:51,729 --> 00:01:56,229
time there there is the focus on both of

00:01:53,829 --> 00:01:59,380
these things in the design of the

00:01:56,229 --> 00:02:02,770
language so it makes it really really

00:01:59,380 --> 00:02:05,280
awesome language in my opinion and you

00:02:02,770 --> 00:02:09,610
have a concept of zero cost abstractions

00:02:05,280 --> 00:02:14,740
so everything you code in in rust you it

00:02:09,610 --> 00:02:17,930
will be have a equivalent performance as

00:02:14,740 --> 00:02:20,060
it were if you write it in C or C++

00:02:17,930 --> 00:02:23,989
actually Sebastian he's in the queue

00:02:20,060 --> 00:02:26,599
outside I think he's not here right he's

00:02:23,989 --> 00:02:29,269
working on GStreamer he's writing

00:02:26,599 --> 00:02:33,859
gstreamer plugins and elements in in

00:02:29,269 --> 00:02:37,879
rust and he actually saved a lot of CPU

00:02:33,859 --> 00:02:39,769
he made it made the code perform much

00:02:37,879 --> 00:02:42,560
better because in rust you can you can

00:02:39,769 --> 00:02:44,269
achieve it more easily because of the

00:02:42,560 --> 00:02:49,189
zero cost abstractions that we have in

00:02:44,269 --> 00:02:53,030
rust it has a non mutable state by

00:02:49,189 --> 00:02:55,909
default so if you want to mark something

00:02:53,030 --> 00:02:58,099
as mutable you have to use a keyword so

00:02:55,909 --> 00:03:00,470
when you have a problem in your code

00:02:58,099 --> 00:03:02,870
base so you can you know which variables

00:03:00,470 --> 00:03:06,230
and which parameters to to look for

00:03:02,870 --> 00:03:08,569
because if it's a non mutable state you

00:03:06,230 --> 00:03:11,689
it won't give you any problem because it

00:03:08,569 --> 00:03:14,989
doesn't change so why would Pro create a

00:03:11,689 --> 00:03:16,879
problem so it's a mutant mutable state

00:03:14,989 --> 00:03:19,400
that you need to look for and that's why

00:03:16,879 --> 00:03:22,699
it's by default you have I'll be taking

00:03:19,400 --> 00:03:28,549
on mutable and it has strict ownership

00:03:22,699 --> 00:03:31,129
semantics in C and C++ you usually just

00:03:28,549 --> 00:03:32,989
give a pointer to someone and then you

00:03:31,129 --> 00:03:36,169
have to establish some sort of way to

00:03:32,989 --> 00:03:40,519
make sure that nobody double freeze it

00:03:36,169 --> 00:03:42,470
or especially in C we have like we have

00:03:40,519 --> 00:03:45,879
been using in genome G live libraries

00:03:42,470 --> 00:03:48,829
for reference counting all objects so

00:03:45,879 --> 00:03:51,109
you have to handle that manually in C of

00:03:48,829 --> 00:03:53,180
course but in rust you don't have to do

00:03:51,109 --> 00:03:57,169
that manually but you have to think

00:03:53,180 --> 00:03:59,780
about how ownership works and at one

00:03:57,169 --> 00:04:04,340
time there can be only one owner to a

00:03:59,780 --> 00:04:09,979
resource I'll show it examples later how

00:04:04,340 --> 00:04:13,669
that is so we will start with a simple

00:04:09,979 --> 00:04:16,130
example in an other in other programming

00:04:13,669 --> 00:04:20,780
languages something like this you're

00:04:16,130 --> 00:04:22,490
passing an array vector to to a function

00:04:20,780 --> 00:04:25,460
and it's just adding two first two

00:04:22,490 --> 00:04:27,440
elements of that and returning it and in

00:04:25,460 --> 00:04:30,100
many languages this would just work fine

00:04:27,440 --> 00:04:33,250
but

00:04:30,100 --> 00:04:34,180
now you add that and then you show it

00:04:33,250 --> 00:04:38,830
it's fine

00:04:34,180 --> 00:04:43,990
but in rust this won't work because when

00:04:38,830 --> 00:04:47,020
you as it says when you past the vector

00:04:43,990 --> 00:04:49,000
there you pass the ownership to that

00:04:47,020 --> 00:04:51,610
function and you never get got that

00:04:49,000 --> 00:04:54,430
ownership back so later on you can't use

00:04:51,610 --> 00:04:55,930
the the resource that you already pass

00:04:54,430 --> 00:04:58,990
to it because you gave it the ownership

00:04:55,930 --> 00:05:01,690
and the main thing is there are two

00:04:58,990 --> 00:05:04,540
kinds of types and in rust there is copy

00:05:01,690 --> 00:05:09,310
types and then there's move types by

00:05:04,540 --> 00:05:11,740
copy types there is the simple types in

00:05:09,310 --> 00:05:13,930
in rust for example integers and volumes

00:05:11,740 --> 00:05:16,360
and those kind that can be passed around

00:05:13,930 --> 00:05:19,810
like as copies without any performance

00:05:16,360 --> 00:05:21,280
problems easily copied those always get

00:05:19,810 --> 00:05:24,070
copied so when you pass it to a function

00:05:21,280 --> 00:05:26,230
if in the in the example if I was

00:05:24,070 --> 00:05:27,700
passing integers directly that example

00:05:26,230 --> 00:05:32,710
would have worked because it's a copy

00:05:27,700 --> 00:05:34,570
type but move types which are most of

00:05:32,710 --> 00:05:36,760
the types by default you create your own

00:05:34,570 --> 00:05:40,420
data type it will be by default a move

00:05:36,760 --> 00:05:43,420
type and by move I don't mean the whole

00:05:40,420 --> 00:05:44,830
thing moving but moving off ownership so

00:05:43,420 --> 00:05:46,810
you give the ownership to someone else

00:05:44,830 --> 00:05:49,500
when you pass it to them if you pass by

00:05:46,810 --> 00:05:53,800
by value and you can't use it anymore

00:05:49,500 --> 00:05:56,770
and that's as I said in rust by default

00:05:53,800 --> 00:05:58,930
everything has only an only one every

00:05:56,770 --> 00:06:02,290
juicer resource has only one owner at a

00:05:58,930 --> 00:06:04,930
time in the code so it's very clear and

00:06:02,290 --> 00:06:09,250
it's been rushed so knows where it went

00:06:04,930 --> 00:06:10,870
to free the resource and not you but the

00:06:09,250 --> 00:06:12,490
thing is you can't you can't work like

00:06:10,870 --> 00:06:15,340
that you have to you know I have

00:06:12,490 --> 00:06:17,590
multiple ownership owners and stuff and

00:06:15,340 --> 00:06:20,250
one of the first ways to do it and one

00:06:17,590 --> 00:06:23,620
of the most obvious and most used is

00:06:20,250 --> 00:06:27,790
borrowing which is like in C++ and C

00:06:23,620 --> 00:06:30,820
both pass by reference more like C++ so

00:06:27,790 --> 00:06:34,480
the same example we just turned the

00:06:30,820 --> 00:06:38,140
parameter into a reference so when you

00:06:34,480 --> 00:06:40,660
pass it by reference you are borrowing

00:06:38,140 --> 00:06:42,850
the ownership of that resource to that

00:06:40,660 --> 00:06:44,110
function you're calling temporarily and

00:06:42,850 --> 00:06:46,180
once that school

00:06:44,110 --> 00:06:48,039
when which ships borrowed that's over

00:06:46,180 --> 00:06:51,960
then the boring is finished and you have

00:06:48,039 --> 00:06:54,789
the your resource back but if I had kept

00:06:51,960 --> 00:06:56,469
ownership if I for example if I had said

00:06:54,789 --> 00:06:58,750
ampersand we and then assign it to a

00:06:56,469 --> 00:07:01,780
local variable it has the same scope as

00:06:58,750 --> 00:07:04,000
V then and then I could not have used it

00:07:01,780 --> 00:07:05,830
while it's still borrowed so while it's

00:07:04,000 --> 00:07:07,750
borrowed you cannot use it but once the

00:07:05,830 --> 00:07:11,439
borrowing is finished which is based on

00:07:07,750 --> 00:07:13,930
scopes and the scope in this case is the

00:07:11,439 --> 00:07:15,310
from that function that you called so

00:07:13,930 --> 00:07:20,440
when it returns you got the ownership

00:07:15,310 --> 00:07:22,000
back I went following so far or I have

00:07:20,440 --> 00:07:24,129
20 minutes to explain this very

00:07:22,000 --> 00:07:27,460
complicated subject so I'm trying my

00:07:24,129 --> 00:07:29,169
best but the problem with borrows is as

00:07:27,460 --> 00:07:31,930
I said it's temporary you you get it

00:07:29,169 --> 00:07:33,909
back and the resource that borrowed it

00:07:31,930 --> 00:07:35,169
if you can't keep it forever and you

00:07:33,909 --> 00:07:40,090
don't have the ownership at the same

00:07:35,169 --> 00:07:41,590
time exactly so we will we will start

00:07:40,090 --> 00:07:45,129
with an example

00:07:41,590 --> 00:07:49,240
I fly helicopters so I have my examples

00:07:45,129 --> 00:07:50,830
are linked to that so the average

00:07:49,240 --> 00:07:52,719
patient every aircraft has a

00:07:50,830 --> 00:07:55,750
registration so it's a simple structure

00:07:52,719 --> 00:07:59,020
and I have an implementation for it it's

00:07:55,750 --> 00:08:02,229
just a constructor get a registration as

00:07:59,020 --> 00:08:05,500
a string this string type is the owned

00:08:02,229 --> 00:08:07,389
string type so you it's instant there is

00:08:05,500 --> 00:08:10,300
two string types in rust one is the own

00:08:07,389 --> 00:08:12,759
one is not owned there are none owned is

00:08:10,300 --> 00:08:15,039
there is a borrow it's a piece of the

00:08:12,759 --> 00:08:17,080
string which could be the whole string

00:08:15,039 --> 00:08:20,770
itself as well but it's a borrow but

00:08:17,080 --> 00:08:25,719
this string with the capital S is a is

00:08:20,770 --> 00:08:29,650
the own type so we from main we pass it

00:08:25,719 --> 00:08:32,260
a string and on string and then we want

00:08:29,650 --> 00:08:34,449
to just use it there and then after we

00:08:32,260 --> 00:08:36,430
passed it to the Hallie the struct

00:08:34,449 --> 00:08:39,669
constructor we again use it ourselves

00:08:36,430 --> 00:08:42,570
and that won't work because when we pass

00:08:39,669 --> 00:08:45,699
by value we gave it the ownership so as

00:08:42,570 --> 00:08:47,740
you like last time so it's very similar

00:08:45,699 --> 00:08:51,699
or actually it's the same just different

00:08:47,740 --> 00:08:52,380
context you move the value and you can't

00:08:51,699 --> 00:08:54,940
use it anymore

00:08:52,380 --> 00:08:57,370
so what would we do in this case the

00:08:54,940 --> 00:08:57,940
easiest solution is to use a data type

00:08:57,370 --> 00:09:01,990
called

00:08:57,940 --> 00:09:05,050
RC which it's abbreviation for reference

00:09:01,990 --> 00:09:07,840
counting and what it does it's a

00:09:05,050 --> 00:09:10,060
container type which you you put

00:09:07,840 --> 00:09:12,580
something in it and it adds reference

00:09:10,060 --> 00:09:14,110
counting to that resource so the

00:09:12,580 --> 00:09:16,300
resource itself you don't need to copy

00:09:14,110 --> 00:09:19,030
it around if you want to pass it around

00:09:16,300 --> 00:09:21,130
and have multiple owners in the same

00:09:19,030 --> 00:09:24,400
code of the same resource and instead

00:09:21,130 --> 00:09:26,770
you just use RC and what it does is like

00:09:24,400 --> 00:09:30,010
each time you create a new user for it

00:09:26,770 --> 00:09:33,220
you increase the reference count on on

00:09:30,010 --> 00:09:35,130
that resource contain resource and then

00:09:33,220 --> 00:09:37,570
once you're all these scopes are

00:09:35,130 --> 00:09:40,090
finished that have borrowed their that

00:09:37,570 --> 00:09:44,920
have increased the reference count the

00:09:40,090 --> 00:09:46,750
rest automatically the destroys the

00:09:44,920 --> 00:09:50,800
resource the underlying resource because

00:09:46,750 --> 00:09:52,390
now there is no owners for it so it's

00:09:50,800 --> 00:09:54,420
just like any reference counting in any

00:09:52,390 --> 00:09:57,130
programming languages you must have seen

00:09:54,420 --> 00:09:59,680
so in this case we just we do it exactly

00:09:57,130 --> 00:10:02,440
the same but instead of passing the

00:09:59,680 --> 00:10:06,520
string directly we now put it in a RC

00:10:02,440 --> 00:10:10,420
and pass the RC clone method so by clone

00:10:06,520 --> 00:10:12,340
I created a new reference count I

00:10:10,420 --> 00:10:14,530
increase the reference count on it so

00:10:12,340 --> 00:10:18,070
the Bandit goes to that one then when

00:10:14,530 --> 00:10:20,290
the new function ap keeps the ownership

00:10:18,070 --> 00:10:22,180
so now we have two owners of the same

00:10:20,290 --> 00:10:25,570
resource so when I said in the beginning

00:10:22,180 --> 00:10:27,940
that you can only have one owner at a

00:10:25,570 --> 00:10:30,730
time I kind of lied but not exactly

00:10:27,940 --> 00:10:33,070
because you really can't have two owners

00:10:30,730 --> 00:10:35,500
but just provides you ways of working

00:10:33,070 --> 00:10:37,450
around it in a safe way in other

00:10:35,500 --> 00:10:39,130
programming languages you just you can

00:10:37,450 --> 00:10:41,080
just really nearly pass things around

00:10:39,130 --> 00:10:43,900
and ownership they can there can be

00:10:41,080 --> 00:10:47,740
multiple owners and language have no way

00:10:43,900 --> 00:10:50,320
of testing if you will destroy the

00:10:47,740 --> 00:10:52,630
resource while another part of the code

00:10:50,320 --> 00:10:55,750
is still using that resource but in rust

00:10:52,630 --> 00:10:58,360
since you put it in RC breast ensures

00:10:55,750 --> 00:11:03,510
that the resource is always there as

00:10:58,360 --> 00:11:03,510
long as there is a user of that resource

00:11:04,620 --> 00:11:11,740
sir no it's not it's a it's a yeah it's

00:11:10,090 --> 00:11:18,670
in this case it's just increases there

00:11:11,740 --> 00:11:21,010
let's count good question but the

00:11:18,670 --> 00:11:25,150
problem is our city's not for multiple

00:11:21,010 --> 00:11:26,710
threats if I run this for example now I

00:11:25,150 --> 00:11:28,990
introduce it's the same example as

00:11:26,710 --> 00:11:31,420
previously almost except this time I

00:11:28,990 --> 00:11:34,030
have added a method and I'm calling that

00:11:31,420 --> 00:11:35,880
method from another thread so I launched

00:11:34,030 --> 00:11:38,500
another threat to call that method and

00:11:35,880 --> 00:11:42,910
now multiple threads are using the same

00:11:38,500 --> 00:11:46,510
RC which we have RC in the in the

00:11:42,910 --> 00:11:50,800
structure so this one will end up in an

00:11:46,510 --> 00:11:53,710
error something like this arrests have

00:11:50,800 --> 00:11:55,540
these traits concept of traits and

00:11:53,710 --> 00:12:01,830
different structs implement different

00:11:55,540 --> 00:12:01,830
traits and that's how it ensures that

00:12:01,860 --> 00:12:07,480
different guarantees are met and in this

00:12:05,560 --> 00:12:09,670
case there is a trait called sin that

00:12:07,480 --> 00:12:11,710
needs to be implemented by structures if

00:12:09,670 --> 00:12:17,080
they want to be accessible by different

00:12:11,710 --> 00:12:20,200
threads so we need a different struct

00:12:17,080 --> 00:12:21,760
which implements that trait that rust

00:12:20,200 --> 00:12:24,790
needs if you want to access it from

00:12:21,760 --> 00:12:27,700
different threads and that structure we

00:12:24,790 --> 00:12:28,960
have in the STD in the standard library

00:12:27,700 --> 00:12:32,050
is arc

00:12:28,960 --> 00:12:34,360
it's just atomic reference counting so

00:12:32,050 --> 00:12:37,390
the reference count is atomic in this

00:12:34,360 --> 00:12:40,120
case it's very similar to the RC the

00:12:37,390 --> 00:12:44,560
main thing is that it's thread safe so

00:12:40,120 --> 00:12:48,810
instead of RC I use arc and the same

00:12:44,560 --> 00:12:48,810
example it's same code will just work

00:12:49,500 --> 00:12:58,630
yeah but the problem is then R sees that

00:12:55,630 --> 00:13:01,900
it's not a sorry arc is not is that it's

00:12:58,630 --> 00:13:04,080
not mutable so you can't like get a

00:13:01,900 --> 00:13:09,550
resource out of it and then modify it

00:13:04,080 --> 00:13:12,750
that's not possible so let's look at

00:13:09,550 --> 00:13:15,610
example so this time it's the same exact

00:13:12,750 --> 00:13:19,780
code again and I accept that in the

00:13:15,610 --> 00:13:23,560
hover method now we are modifying the

00:13:19,780 --> 00:13:25,060
resource and these are the methods I'm

00:13:23,560 --> 00:13:27,820
calling is just the normal methods

00:13:25,060 --> 00:13:29,710
the string type clearing the string and

00:13:27,820 --> 00:13:32,890
then pushing another spring on on the

00:13:29,710 --> 00:13:37,810
existing string but this this won't work

00:13:32,890 --> 00:13:39,910
because modifying it and the main thing

00:13:37,810 --> 00:13:41,800
is I can't borrow is as mutable because

00:13:39,910 --> 00:13:46,030
it's not a mutable resource and then

00:13:41,800 --> 00:13:48,910
market as money so for those things you

00:13:46,030 --> 00:13:50,100
need yet another data structure called

00:13:48,910 --> 00:13:53,140
mutex

00:13:50,100 --> 00:13:55,570
which is just like a mutex in any

00:13:53,140 --> 00:14:00,090
programming languages and libraries you

00:13:55,570 --> 00:14:02,650
get locks on the resource so we put our

00:14:00,090 --> 00:14:04,630
mutex in an arc because we want to

00:14:02,650 --> 00:14:06,970
access it from multiple threads atomic

00:14:04,630 --> 00:14:08,710
with the atomic reference counting so

00:14:06,970 --> 00:14:11,140
the arc is adding atomic reference

00:14:08,710 --> 00:14:14,920
counting and then the mutex is ensuring

00:14:11,140 --> 00:14:17,950
that you can have mutable locks on the

00:14:14,920 --> 00:14:20,740
resource so you have multiple container

00:14:17,950 --> 00:14:22,120
types you you will see that in some

00:14:20,740 --> 00:14:24,820
times and rust you you need to have

00:14:22,120 --> 00:14:27,400
multiple containers to the same resource

00:14:24,820 --> 00:14:29,920
but the thing is you have type aliasing

00:14:27,400 --> 00:14:32,050
so you can use that to create a new type

00:14:29,920 --> 00:14:34,750
for your complex type very very easily

00:14:32,050 --> 00:14:40,390
and that's just a elías so it makes

00:14:34,750 --> 00:14:45,760
things pretty easy to follow anyway so

00:14:40,390 --> 00:14:47,710
this time you just use mutex you you

00:14:45,760 --> 00:14:50,980
create like when you created the arc you

00:14:47,710 --> 00:14:53,410
in there you just to a new mutex and put

00:14:50,980 --> 00:14:57,040
the resource in the mutex but in the

00:14:53,410 --> 00:15:00,370
hover you need a you take a lock of the

00:14:57,040 --> 00:15:02,830
off the from the mutex and when you

00:15:00,370 --> 00:15:05,620
access the mutex is since it's contained

00:15:02,830 --> 00:15:07,890
in arc you you get an atomic reference

00:15:05,620 --> 00:15:07,890
so you

00:15:08,290 --> 00:15:14,200
it's the thread safe and once you get

00:15:11,380 --> 00:15:16,090
the lock you then you can do whatever

00:15:14,200 --> 00:15:18,280
you want because you have gotten

00:15:16,090 --> 00:15:22,240
yourself a new tech mutable reference to

00:15:18,280 --> 00:15:24,790
the to the resource and then the thing

00:15:22,240 --> 00:15:26,290
is that rust is very much the memory

00:15:24,790 --> 00:15:29,770
management is very much based on scopes

00:15:26,290 --> 00:15:32,410
so once you are out of that scope which

00:15:29,770 --> 00:15:34,810
is the hover method the lock that you

00:15:32,410 --> 00:15:36,840
acquired will be freed automatically for

00:15:34,810 --> 00:15:39,330
you so you don't have to

00:15:36,840 --> 00:15:41,970
Freed's if you want you at as far as I

00:15:39,330 --> 00:15:44,130
know there is an unlock method but you

00:15:41,970 --> 00:15:47,700
usually you don't need to you just use

00:15:44,130 --> 00:15:56,120
scopes to signal like that okay I'm done

00:15:47,700 --> 00:15:59,280
with the with a lock and similar to the

00:15:56,120 --> 00:16:01,290
mutex there is a type called read/write

00:15:59,280 --> 00:16:03,420
lock which is if you have multiple

00:16:01,290 --> 00:16:06,000
threads that some of them needs only

00:16:03,420 --> 00:16:09,000
read access not write access so it it

00:16:06,000 --> 00:16:10,950
could be very inefficient if you have if

00:16:09,000 --> 00:16:12,360
you're if you use new Tex because every

00:16:10,950 --> 00:16:16,170
thread will have to wait for the other

00:16:12,360 --> 00:16:18,000
tribe to finish access and then be able

00:16:16,170 --> 00:16:20,700
to access with the readwrite lock you

00:16:18,000 --> 00:16:25,680
can have multiple readers of the same

00:16:20,700 --> 00:16:29,340
resource so multiple this the threads

00:16:25,680 --> 00:16:32,550
can get lock on the same resource at the

00:16:29,340 --> 00:16:35,280
same time as a read read lock but not

00:16:32,550 --> 00:16:37,710
write lock so but if there is a thread X

00:16:35,280 --> 00:16:41,430
having a write lock then others have to

00:16:37,710 --> 00:16:44,760
wait for for that to finish yeah it's

00:16:41,430 --> 00:16:47,460
very similar I'm I'm really sorry I'm

00:16:44,760 --> 00:16:54,890
going really fast but I have very little

00:16:47,460 --> 00:16:57,870
time as I mentioned so box is the type

00:16:54,890 --> 00:17:00,720
when you when you usually act create a

00:16:57,870 --> 00:17:04,530
resource you put it usually on the stack

00:17:00,720 --> 00:17:07,920
and but if you use those data structures

00:17:04,530 --> 00:17:11,850
that I mentioned RCE arc and those you

00:17:07,920 --> 00:17:15,300
put it on the heap but it's it's more

00:17:11,850 --> 00:17:17,100
heavy RCS has a reference counting and

00:17:15,300 --> 00:17:21,390
it needs to ensure that reference count

00:17:17,100 --> 00:17:23,130
increases decreases thathe so you don't

00:17:21,390 --> 00:17:24,959
want to use it just for allocating on

00:17:23,130 --> 00:17:26,520
the heap so if you want to just allocate

00:17:24,959 --> 00:17:30,060
something on the heap to pass it around

00:17:26,520 --> 00:17:32,160
well and keep the the resource around

00:17:30,060 --> 00:17:34,170
for longer than one function or

00:17:32,160 --> 00:17:37,860
something you can use something called

00:17:34,170 --> 00:17:40,950
box and it's very simple you just create

00:17:37,860 --> 00:17:43,170
a new box and the v in there is not the

00:17:40,950 --> 00:17:45,120
size people think fits the size but

00:17:43,170 --> 00:17:48,090
that's just an integer that I want to

00:17:45,120 --> 00:17:50,340
keep in the box and then you just use it

00:17:48,090 --> 00:17:53,010
like as if it's not contained in a box

00:17:50,340 --> 00:17:56,310
it's like usable like as if it was just

00:17:53,010 --> 00:17:59,790
the integer itself just like in our case

00:17:56,310 --> 00:18:03,390
of our CN arc another thing with the box

00:17:59,790 --> 00:18:07,770
is very important is that it gives the

00:18:03,390 --> 00:18:11,190
resource it keeps a size so if for

00:18:07,770 --> 00:18:14,340
example this case in rust you your enums

00:18:11,190 --> 00:18:17,520
can be complex you can have data inside

00:18:14,340 --> 00:18:19,470
your inner particular enums and so in

00:18:17,520 --> 00:18:27,150
this case we want to create a list that

00:18:19,470 --> 00:18:30,810
is have other nodes in it so we want to

00:18:27,150 --> 00:18:32,340
keep a list in a list and you we can't

00:18:30,810 --> 00:18:35,100
do that because rust won't be able to

00:18:32,340 --> 00:18:38,570
tell how much memory to allocate to this

00:18:35,100 --> 00:18:41,040
because you know it's infinite recursion

00:18:38,570 --> 00:18:44,220
we can break that infinite recursion by

00:18:41,040 --> 00:18:47,400
using box because box the list that if

00:18:44,220 --> 00:18:49,110
it's it's going to be a list it's on the

00:18:47,400 --> 00:18:51,840
on the heap and you only get a pointer

00:18:49,110 --> 00:18:54,660
in the box and pointer is always the

00:18:51,840 --> 00:18:58,320
same size so you solve the problem and

00:18:54,660 --> 00:19:01,110
without using any pointers itself in

00:18:58,320 --> 00:19:03,090
rust you can use pointers especially an

00:19:01,110 --> 00:19:05,910
unsafe code and you mark it as unsafe

00:19:03,090 --> 00:19:09,300
but typically you can't avoid it and you

00:19:05,910 --> 00:19:13,830
should avoid it because that's where the

00:19:09,300 --> 00:19:15,960
problems are usually yeah I wanted to

00:19:13,830 --> 00:19:19,410
discuss briefly the life times and this

00:19:15,960 --> 00:19:21,720
was another reason I was hurrying up I

00:19:19,410 --> 00:19:24,000
have done the same talk before in other

00:19:21,720 --> 00:19:26,400
conferences but I always avoid lifetimes

00:19:24,000 --> 00:19:29,250
so this is my first time addressing it I

00:19:26,400 --> 00:19:33,170
hope I can do some justice to it because

00:19:29,250 --> 00:19:33,170
it's people are afraid of it

00:19:33,470 --> 00:19:42,200
so as I mentioned you can you can pass

00:19:38,550 --> 00:19:46,770
things by reference and references are

00:19:42,200 --> 00:19:49,800
temporary and the the scopes define the

00:19:46,770 --> 00:19:52,320
lifetimes of things so in this case you

00:19:49,800 --> 00:19:53,940
get two strings in the longest function

00:19:52,320 --> 00:20:01,740
it just returns the longest string you

00:19:53,940 --> 00:20:03,300
have sorry I have my pointer and so this

00:20:01,740 --> 00:20:03,900
should work right because you just pass

00:20:03,300 --> 00:20:05,400
the reference

00:20:03,900 --> 00:20:09,030
you get the reference to the longest

00:20:05,400 --> 00:20:14,010
string and yeah

00:20:09,030 --> 00:20:18,060
but it wouldn't work because rust

00:20:14,010 --> 00:20:20,130
doesn't know when and you get helpful

00:20:18,060 --> 00:20:21,840
very helpful messages and nowadays from

00:20:20,130 --> 00:20:25,440
from Russ compilers so that's that's

00:20:21,840 --> 00:20:27,810
really cool so you borrowed a value and

00:20:25,440 --> 00:20:29,340
then you return a reference to one of

00:20:27,810 --> 00:20:32,220
the board values and Russ doesn't know

00:20:29,340 --> 00:20:33,240
well you can easily can t to tell which

00:20:32,220 --> 00:20:37,260
which one it is

00:20:33,240 --> 00:20:40,620
and you have multiple n parameters and

00:20:37,260 --> 00:20:45,300
one out parameter so in in this case you

00:20:40,620 --> 00:20:48,450
have to tell it how long would the

00:20:45,300 --> 00:20:51,630
reference that you're returning have to

00:20:48,450 --> 00:20:54,570
be kept alive and what other resources

00:20:51,630 --> 00:21:00,390
it is associated with so it keeps them

00:20:54,570 --> 00:21:03,690
both alive long enough so we can I know

00:21:00,390 --> 00:21:06,360
there the syntax of lifetime's it's a

00:21:03,690 --> 00:21:08,160
bit takes a while to get used to and

00:21:06,360 --> 00:21:10,920
even when you get used to its you still

00:21:08,160 --> 00:21:13,710
hate it but that's how it is I don't I

00:21:10,920 --> 00:21:17,250
have no better suggestion so I don't

00:21:13,710 --> 00:21:21,120
criticize much but I know that it seems

00:21:17,250 --> 00:21:24,050
really really weird so you you declare

00:21:21,120 --> 00:21:27,030
and the function definition a lifetime

00:21:24,050 --> 00:21:30,000
it's an abstract concept of the lifetime

00:21:27,030 --> 00:21:32,820
so and you declared that all the all the

00:21:30,000 --> 00:21:35,370
resources that you're using like the in

00:21:32,820 --> 00:21:39,720
input parameters and the return value

00:21:35,370 --> 00:21:43,730
have the same exact lifetime which means

00:21:39,720 --> 00:21:50,070
to tell two compiler res compiler that

00:21:43,730 --> 00:21:52,770
if you if a s1 s2 and the return value

00:21:50,070 --> 00:21:56,310
needs to be kept alive together so you

00:21:52,770 --> 00:21:59,820
can't it can't free for example the s-1

00:21:56,310 --> 00:22:02,940
that is being passed before the usage of

00:21:59,820 --> 00:22:08,810
the return value is finished or the same

00:22:02,940 --> 00:22:11,690
with s2 so in in here in the example we

00:22:08,810 --> 00:22:15,300
sorry

00:22:11,690 --> 00:22:16,830
we passed the two values and then we get

00:22:15,300 --> 00:22:18,870
the reference back and

00:22:16,830 --> 00:22:20,670
at this time it's it the usage is

00:22:18,870 --> 00:22:23,340
exactly the same as we we had in the

00:22:20,670 --> 00:22:27,270
previous example it's just that we now

00:22:23,340 --> 00:22:31,140
told rust what are the association of

00:22:27,270 --> 00:22:33,060
the different lifetimes involved and the

00:22:31,140 --> 00:22:36,330
lifetimes are more like declarative than

00:22:33,060 --> 00:22:38,850
instructive so it's like you give hint

00:22:36,330 --> 00:22:40,950
to the compiler and it's up to the

00:22:38,850 --> 00:22:42,780
compiler how it handles those you just

00:22:40,950 --> 00:22:47,780
tell it like these resources are related

00:22:42,780 --> 00:22:47,780
don't free them before you free others

00:22:47,810 --> 00:22:52,620
yeah actually that's all I had so I

00:22:50,910 --> 00:23:06,000
think I have a lot of time for questions

00:22:52,620 --> 00:23:08,930
and that's good thing okay do you want

00:23:06,000 --> 00:23:08,930
me to move to the previous slide

00:23:27,470 --> 00:23:35,010
not exactly sorry I'm not used to it so

00:23:32,340 --> 00:23:38,610
and I was told to repeat the question

00:23:35,010 --> 00:23:43,560
the question is that there is case where

00:23:38,610 --> 00:23:45,630
s1 is is to be returned and not s2 and

00:23:43,560 --> 00:23:48,930
in that case we don't care about s2

00:23:45,630 --> 00:23:50,550
anymore and it's the s-1 that that can't

00:23:48,930 --> 00:23:55,950
be freed while they return well you

00:23:50,550 --> 00:23:59,850
still well around that's true but it's

00:23:55,950 --> 00:24:02,010
very hard for compiler to to find these

00:23:59,850 --> 00:24:04,050
out one thing I did not mention is that

00:24:02,010 --> 00:24:06,270
in rust you have something called

00:24:04,050 --> 00:24:09,270
lifetime elysian like the one of the

00:24:06,270 --> 00:24:11,520
code that you saw earlier where I was

00:24:09,270 --> 00:24:13,830
using references but you noticed that

00:24:11,520 --> 00:24:16,320
there was no lifetime involved there and

00:24:13,830 --> 00:24:19,140
the reason was that lifetimes are always

00:24:16,320 --> 00:24:21,480
there except that in many cases at least

00:24:19,140 --> 00:24:24,570
the simple cases rust is smart enough to

00:24:21,480 --> 00:24:26,340
detect okay the compiler and it declares

00:24:24,570 --> 00:24:28,320
them for you in the code so you don't

00:24:26,340 --> 00:24:30,070
have to care for them but it's like a

00:24:28,320 --> 00:24:31,600
bit complicated

00:24:30,070 --> 00:24:33,760
temples like these then you will start

00:24:31,600 --> 00:24:35,860
to when you have multiple references

00:24:33,760 --> 00:24:37,960
being passed and then you have returned

00:24:35,860 --> 00:24:40,180
as a reference as well then rust will

00:24:37,960 --> 00:24:44,650
get would not know how to handle that

00:24:40,180 --> 00:24:47,170
because it can handle it on its own but

00:24:44,650 --> 00:24:49,150
not through their lifetime syntax it's

00:24:47,170 --> 00:24:51,910
like because it's more dynamic like we

00:24:49,150 --> 00:24:54,040
don't know which one the witch string

00:24:51,910 --> 00:24:56,110
that will be passed is is going to be

00:24:54,040 --> 00:24:59,020
longest so it's more like a dynamic

00:24:56,110 --> 00:25:02,440
decision and Russ does all all thing

00:24:59,020 --> 00:25:18,130
statically so it needs to repeat to do

00:25:02,440 --> 00:25:21,490
it this way no you can have multiple

00:25:18,130 --> 00:25:23,560
lifetimes that's true but in this case

00:25:21,490 --> 00:25:27,490
you need both of them because you don't

00:25:23,560 --> 00:25:29,350
know before you know which parameters

00:25:27,490 --> 00:25:32,260
will be passed because it's more dynamic

00:25:29,350 --> 00:25:33,720
thing like you don't know what when

00:25:32,260 --> 00:25:37,930
you're compiling just that function

00:25:33,720 --> 00:25:41,200
let's say in a library and it will be

00:25:37,930 --> 00:25:43,900
used by people you don't know and you

00:25:41,200 --> 00:25:45,610
don't know what will be passed so it

00:25:43,900 --> 00:25:49,420
will you will only know dynamically

00:25:45,610 --> 00:25:55,150
which which case would it be so that's

00:25:49,420 --> 00:25:57,270
why it's it's not possible no other

00:25:55,150 --> 00:25:57,270
questions

00:26:00,749 --> 00:26:07,990
you put like in there in this example

00:26:04,059 --> 00:26:10,570
you you have like a lifetime a you just

00:26:07,990 --> 00:26:11,980
put a comma lifetime B so you can

00:26:10,570 --> 00:26:16,080
declare multiple and then you can use

00:26:11,980 --> 00:26:19,480
them like the same as C I'm using a left

00:26:16,080 --> 00:26:22,840
sorry the question was if I can have

00:26:19,480 --> 00:26:26,789
multiple lifetimes in there and that's

00:26:22,840 --> 00:26:26,789
what answered sorry

00:26:35,440 --> 00:26:39,899
the question is if the lifetime is part

00:26:37,629 --> 00:26:43,659
of the reference type

00:26:39,899 --> 00:26:46,539
not exactly but it's always there like

00:26:43,659 --> 00:26:49,149
when you pass things by reference the

00:26:46,539 --> 00:26:51,179
life there's a lifetime involved it's

00:26:49,149 --> 00:26:55,080
just the difference is whether you

00:26:51,179 --> 00:26:58,299
declare you have to declare it or not

00:26:55,080 --> 00:27:01,629
yeah actually it's implemented through

00:26:58,299 --> 00:27:04,409
something called generics in rust if you

00:27:01,629 --> 00:27:06,999
look into generics you will see that

00:27:04,409 --> 00:27:09,360
syntax of declaring them exactly exactly

00:27:06,999 --> 00:27:11,529
the same and that's how it's implemented

00:27:09,360 --> 00:27:13,149
and you might want to read up on that

00:27:11,529 --> 00:27:37,539
it's it's pretty interesting stuff how

00:27:13,149 --> 00:27:39,129
lifetimes are implemented so that the

00:27:37,539 --> 00:27:40,330
question is if I understood correctly is

00:27:39,129 --> 00:27:42,399
that if the in multi-threaded

00:27:40,330 --> 00:27:45,460
application is it possible for one

00:27:42,399 --> 00:27:51,100
tattoo or write the other resource of

00:27:45,460 --> 00:27:58,600
others no no no like you can't really

00:27:51,100 --> 00:28:00,690
mess up with lifetime no I sure you know

00:27:58,600 --> 00:28:03,810
it

00:28:00,690 --> 00:28:03,810

YouTube URL: https://www.youtube.com/watch?v=LYxxJL6Jumo


