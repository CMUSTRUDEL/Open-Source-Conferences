Title: Jorge Aparicio Rivera - Rusty Robots
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	Programming a self-balancing robot in Rust

Are we embedded yet? I'd say yes! In this talk I'll show you how I programmed a self-balancing robot from scratch. I'll cover IO abstractions, motion sensors, motor drivers, filters, control stuff, bare metal multitasking, logging, etc. And I'll explain how some of Rust features made development easier and made the program more correct.

Jorge (@japaric) has been part of the Rust community for over three years. Over that time he has contributed to the Rust compiler, standard library and other official Rust projects like Cargo. With his background in mechatronics engineering and the help of the vibrant embedded Rust sub-community he's working towards making Rust a great language and ecosystem for embedded development.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rusty_robots/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:04,950 --> 00:00:25,680
we have holiday up ratio is going to be

00:00:08,980 --> 00:00:28,180
presenting on Rasta robots thank you

00:00:25,680 --> 00:00:30,250
we don't have as much time I would like

00:00:28,180 --> 00:00:33,010
so we'll type in right into you

00:00:30,250 --> 00:00:43,059
yeah sure can you hear mother back yes

00:00:33,010 --> 00:00:44,859
oh sure a shout okay I will shout okay

00:00:43,059 --> 00:00:46,899
so this is the robot and this is the

00:00:44,859 --> 00:00:48,640
front view and you can see it's a wheel

00:00:46,899 --> 00:00:50,589
robot and only has two wheels

00:00:48,640 --> 00:00:53,519
and the mass of white on the top is the

00:00:50,589 --> 00:00:55,989
electronics that will control it and

00:00:53,519 --> 00:00:58,359
there's some cortex in my controller in

00:00:55,989 --> 00:01:00,159
there among other things and this the

00:00:58,359 --> 00:01:02,679
side view you can see he only has two

00:01:00,159 --> 00:01:04,720
wheels no extra support point and the

00:01:02,679 --> 00:01:06,610
robot is clearly unstable it doesn't

00:01:04,720 --> 00:01:11,079
matter which position you put it on it

00:01:06,610 --> 00:01:14,289
will always fall to either side and this

00:01:11,079 --> 00:01:15,820
is similar to a common problem in

00:01:14,289 --> 00:01:18,250
control theory which is the inverted

00:01:15,820 --> 00:01:19,990
pendulum problem and if that problem we

00:01:18,250 --> 00:01:21,729
have an inverted pendulum on top of a

00:01:19,990 --> 00:01:24,310
moving car which you can move using this

00:01:21,729 --> 00:01:27,340
force F now the pendulum will fall due

00:01:24,310 --> 00:01:29,560
to gravity and to compensate that

00:01:27,340 --> 00:01:31,390
falling action what you have to do is if

00:01:29,560 --> 00:01:32,890
the pendulum is moving to a lab then you

00:01:31,390 --> 00:01:34,990
also have to move the car to a left to

00:01:32,890 --> 00:01:38,649
compensate so the problem boils down to

00:01:34,990 --> 00:01:43,149
picking a force F that according to the

00:01:38,649 --> 00:01:46,030
hill angle theta that you see there okay

00:01:43,149 --> 00:01:47,890
so we'll need to find that tilt angle

00:01:46,030 --> 00:01:50,409
and for that we have an accelerometer on

00:01:47,890 --> 00:01:52,060
the robot and as the name implies an

00:01:50,409 --> 00:01:54,759
accelerometer measures proper

00:01:52,060 --> 00:01:58,780
acceleration and this since we're using

00:01:54,759 --> 00:02:01,530
as the MPU 9250 now how do I get the

00:01:58,780 --> 00:02:03,399
tilt angle from the acceleration and

00:02:01,530 --> 00:02:04,659
accelerometers even when they are non

00:02:03,399 --> 00:02:07,390
moving they always sends the

00:02:04,659 --> 00:02:08,800
acceleration of the gravity and on the

00:02:07,390 --> 00:02:11,080
picture on the left you see that the

00:02:08,800 --> 00:02:12,850
sensor is horizontal and in that case

00:02:11,080 --> 00:02:14,180
the salaah meter is going to indicate

00:02:12,850 --> 00:02:17,030
that the acceleration across the

00:02:14,180 --> 00:02:20,060
X and y-axis are zero but across the

00:02:17,030 --> 00:02:22,159
CRC's is one times the gravity or 1g and

00:02:20,060 --> 00:02:23,930
that's going to be a fill angle of zero

00:02:22,159 --> 00:02:26,030
degrees and now on the right you see

00:02:23,930 --> 00:02:28,459
that I have tilde essential by some

00:02:26,030 --> 00:02:31,069
angle and it had case they really across

00:02:28,459 --> 00:02:33,260
the y&z axis are going to be nonzero and

00:02:31,069 --> 00:02:34,819
if you do some trigonometry there you'll

00:02:33,260 --> 00:02:37,430
find out that the angle is the

00:02:34,819 --> 00:02:41,239
arctangent of the ratio of the Y and C

00:02:37,430 --> 00:02:43,430
components and let's see how that works

00:02:41,239 --> 00:02:45,290
out in practice this is data collecting

00:02:43,430 --> 00:02:47,480
from the accelerometer and one is

00:02:45,290 --> 00:02:49,129
horizontal and it's not moving on the

00:02:47,480 --> 00:02:52,400
top you see the acceleration across the

00:02:49,129 --> 00:02:55,579
y and z axis and the Delta is noisy and

00:02:52,400 --> 00:02:57,109
at the bottom you see the our tangent

00:02:55,579 --> 00:02:59,359
formula from before and that's going to

00:02:57,109 --> 00:03:01,879
be the feel angle and the angle is

00:02:59,359 --> 00:03:03,739
around 2.9 degrees and that makes sense

00:03:01,879 --> 00:03:07,519
since the sensory isolation valve should

00:03:03,739 --> 00:03:09,230
be near zero now what happens if I start

00:03:07,519 --> 00:03:10,879
moving the SLO meter and this data is

00:03:09,230 --> 00:03:13,129
from moving the thermometer on a

00:03:10,879 --> 00:03:14,599
horizontal table so in that case the

00:03:13,129 --> 00:03:17,810
feel angle should still be zero because

00:03:14,599 --> 00:03:19,489
I know tilt in the sensor but what we

00:03:17,810 --> 00:03:21,620
see here is that once you compute the

00:03:19,489 --> 00:03:23,870
angle using the formula from before you

00:03:21,620 --> 00:03:25,669
get a lot of oscillations and this is

00:03:23,870 --> 00:03:27,620
clearly wrong and the problem is that

00:03:25,669 --> 00:03:29,269
the formula from before was assuming

00:03:27,620 --> 00:03:31,069
that the only acceleration measured by

00:03:29,269 --> 00:03:32,389
the sensor passed the gravity and that's

00:03:31,069 --> 00:03:35,389
not going to be the case as soon as you

00:03:32,389 --> 00:03:37,549
start moving the sensor now the salami

00:03:35,389 --> 00:03:39,260
that is not enough to get us telling

00:03:37,549 --> 00:03:42,019
goals so we also have a gyroscope on the

00:03:39,260 --> 00:03:45,319
robot an algebra scope measures the

00:03:42,019 --> 00:03:47,509
angular rate or the speed at which the

00:03:45,319 --> 00:03:48,889
sensor is rotating and this is perfect

00:03:47,509 --> 00:03:51,949
because with this we can measure exactly

00:03:48,889 --> 00:03:53,840
how the angle is changing and the same

00:03:51,949 --> 00:03:57,049
sense of from before has both an

00:03:53,840 --> 00:03:59,209
accelerometer and a gyroscope again this

00:03:57,049 --> 00:04:01,699
is data from the sensor horizontally

00:03:59,209 --> 00:04:04,280
without moving at the top you have the

00:04:01,699 --> 00:04:05,720
angular rate and at what when you have

00:04:04,280 --> 00:04:08,479
the tell angle which you can get from

00:04:05,720 --> 00:04:11,120
integrating the top signal and you see

00:04:08,479 --> 00:04:14,150
there that the angle says that it's

00:04:11,120 --> 00:04:16,159
increasing as time goes by and that's

00:04:14,150 --> 00:04:17,870
wrong because the sensor is horizontal

00:04:16,159 --> 00:04:20,419
and the problem here is that the

00:04:17,870 --> 00:04:23,960
gyroscope says that the angular rate is

00:04:20,419 --> 00:04:25,969
nonzero and that's common in this kind

00:04:23,960 --> 00:04:27,080
of sensors and it's called bias and the

00:04:25,969 --> 00:04:28,879
opposite in the measurements

00:04:27,080 --> 00:04:31,430
bias and what I have to do is calibrate

00:04:28,879 --> 00:04:33,770
the sensor by removing the bias and this

00:04:31,430 --> 00:04:35,750
the the data once the sensor has been

00:04:33,770 --> 00:04:37,520
calibrated and now the angular rate is

00:04:35,750 --> 00:04:39,379
around zero and once you compute the

00:04:37,520 --> 00:04:41,389
integral at the bottom the angle is also

00:04:39,379 --> 00:04:43,189
around zero which is the correct result

00:04:41,389 --> 00:04:44,810
you want now

00:04:43,189 --> 00:04:46,729
the accelerometer and gyroscope have

00:04:44,810 --> 00:04:48,860
problems on their own but what you can

00:04:46,729 --> 00:04:50,419
do is combine both measurements using a

00:04:48,860 --> 00:04:53,210
technique called sensor efficient I get

00:04:50,419 --> 00:04:55,520
a better estimate of the angle and turn

00:04:53,210 --> 00:04:56,960
many ways to do sensor vision but a

00:04:55,520 --> 00:04:59,389
Kalman filter is appropriate in this

00:04:56,960 --> 00:05:02,060
case now I'm going into the details of

00:04:59,389 --> 00:05:03,650
the mat behind Kalman filters but as you

00:05:02,060 --> 00:05:06,500
said that they are not actually filters

00:05:03,650 --> 00:05:08,719
but they are system state estimators and

00:05:06,500 --> 00:05:10,969
for this Kalman filter have chosen and

00:05:08,719 --> 00:05:13,729
state of the teal angle and also the

00:05:10,969 --> 00:05:15,500
yellow scope bias and here we see a

00:05:13,729 --> 00:05:18,110
simplified interface to the Canon Peter

00:05:15,500 --> 00:05:20,240
has omitted some tuning parameters from

00:05:18,110 --> 00:05:22,669
here and the filter have to start with

00:05:20,240 --> 00:05:26,210
some initial state which is the angle

00:05:22,669 --> 00:05:27,590
and the yellow scope bias and then every

00:05:26,210 --> 00:05:30,529
time we have a new measurement we are

00:05:27,590 --> 00:05:32,300
going to update this filter and what the

00:05:30,529 --> 00:05:35,180
filter will do is try to predict a nexus

00:05:32,300 --> 00:05:36,710
state using his previous state and they

00:05:35,180 --> 00:05:37,759
will compare that to the measurements

00:05:36,710 --> 00:05:39,379
from the yellow scope and the

00:05:37,759 --> 00:05:41,139
accelerometer and you start information

00:05:39,379 --> 00:05:44,599
to get a better estimate of the angle

00:05:41,139 --> 00:05:47,419
and this is Polly Kalman filter looks

00:05:44,599 --> 00:05:50,210
like in action again this is data from

00:05:47,419 --> 00:05:52,129
the sensor horizontal without moving and

00:05:50,210 --> 00:05:54,199
the blue dots are the teal angle

00:05:52,129 --> 00:05:56,710
computed only using accelerometer data

00:05:54,199 --> 00:05:59,479
and the Green Line is the Kalman filter

00:05:56,710 --> 00:06:02,089
and what said the same thing that the

00:05:59,479 --> 00:06:03,650
angle is around 2.9 but the difference

00:06:02,089 --> 00:06:05,569
is that the Kalman filter has much less

00:06:03,650 --> 00:06:08,870
noise and it has one order of magnitude

00:06:05,569 --> 00:06:10,909
less noise now we have another example

00:06:08,870 --> 00:06:14,509
where I move the sensor from a position

00:06:10,909 --> 00:06:16,639
of three agrees to 19 and the blue line

00:06:14,509 --> 00:06:18,830
is teal angle from only that kilometer

00:06:16,639 --> 00:06:21,259
and Green Line is the Kalman filter as

00:06:18,830 --> 00:06:24,229
you can see the color filter you see it

00:06:21,259 --> 00:06:26,180
has a smooth transition from 0 to 90 but

00:06:24,229 --> 00:06:28,520
the thermometer has oscillations around

00:06:26,180 --> 00:06:31,219
the whole transition while were using

00:06:28,520 --> 00:06:33,529
the Kalman filter here ok now we have

00:06:31,219 --> 00:06:35,509
the angle and have to move the motors to

00:06:33,529 --> 00:06:38,599
be able to stabilize the robot and for

00:06:35,509 --> 00:06:40,039
that we use this piece of electronics

00:06:38,599 --> 00:06:42,020
called H bridge

00:06:40,039 --> 00:06:43,520
and this module has to a bridge and we

00:06:42,020 --> 00:06:46,819
can use that to control the two motors

00:06:43,520 --> 00:06:48,639
on the robot and with h-bridge we can

00:06:46,819 --> 00:06:51,289
control the direction of the motor and

00:06:48,639 --> 00:06:54,050
each bridge basically use four switches

00:06:51,289 --> 00:06:55,550
arranged as you see on the screen and on

00:06:54,050 --> 00:06:58,729
the left we have one of the possible

00:06:55,550 --> 00:07:01,309
states of the H bridge and in that state

00:06:58,729 --> 00:07:03,139
the power supply supplied to them motor

00:07:01,309 --> 00:07:05,930
and I will apply some voltage to make

00:07:03,139 --> 00:07:08,719
the motor move and and the state on the

00:07:05,930 --> 00:07:10,460
right the voltage is also going to be

00:07:08,719 --> 00:07:12,289
applied to the motor but with reverse

00:07:10,460 --> 00:07:15,469
polarity and that will make it a spin in

00:07:12,289 --> 00:07:17,240
the other direction so it has four

00:07:15,469 --> 00:07:19,610
switches and you could get sixteen

00:07:17,240 --> 00:07:22,189
different possible state from that but

00:07:19,610 --> 00:07:23,960
in practice we only use four states the

00:07:22,189 --> 00:07:25,309
two you see there and the other one is

00:07:23,960 --> 00:07:27,020
when you have everything open and the

00:07:25,309 --> 00:07:29,569
motor is disconnected from the power

00:07:27,020 --> 00:07:31,669
supply and the other state is when you

00:07:29,569 --> 00:07:33,469
short it with the motor by say closing

00:07:31,669 --> 00:07:34,939
the two switches at the bottom and that

00:07:33,469 --> 00:07:38,240
will make it about or break so we will

00:07:34,939 --> 00:07:39,919
stop almost immediately and with this

00:07:38,240 --> 00:07:41,539
bridge you can also control the speed of

00:07:39,919 --> 00:07:44,120
the motor which we are going to need in

00:07:41,539 --> 00:07:45,800
this robot and we can do that using this

00:07:44,120 --> 00:07:48,409
technique called pulse width modulation

00:07:45,800 --> 00:07:50,330
and the main idea is that instead of

00:07:48,409 --> 00:07:52,129
having the motor connected to the power

00:07:50,330 --> 00:07:55,159
supply the whole time we are going to

00:07:52,129 --> 00:07:57,800
connect it just for 75% of the time say

00:07:55,159 --> 00:07:59,659
and you're 25% we are going to leave it

00:07:57,800 --> 00:08:01,519
disconnected this is going to transfer

00:07:59,659 --> 00:08:04,009
less power into the model we should make

00:08:01,519 --> 00:08:06,019
it a spin slower so this ratio between

00:08:04,009 --> 00:08:07,819
the own time and the total time is

00:08:06,019 --> 00:08:11,419
called the duty cycle and it can go from

00:08:07,819 --> 00:08:13,490
zero to 100% and so one hundred percent

00:08:11,419 --> 00:08:15,309
will make the motor spin at full speed

00:08:13,490 --> 00:08:18,430
and zero will make it stop

00:08:15,309 --> 00:08:21,139
now we have the two pieces we have the

00:08:18,430 --> 00:08:23,539
angle and we can control the mother so

00:08:21,139 --> 00:08:26,300
how can we pick a duty cycle to

00:08:23,539 --> 00:08:29,479
stabilize the robot we can use this PID

00:08:26,300 --> 00:08:31,189
controller and there in this diagram the

00:08:29,479 --> 00:08:33,740
process on the right is the robot and

00:08:31,189 --> 00:08:36,860
the variable Y is the till angle measure

00:08:33,740 --> 00:08:38,680
and on the Left we have this variable R

00:08:36,860 --> 00:08:41,690
which is the set point which is the

00:08:38,680 --> 00:08:42,919
angle we want the trouble to be at so if

00:08:41,690 --> 00:08:45,949
we pick something like zero that will

00:08:42,919 --> 00:08:47,510
make the robot stay upright and the

00:08:45,949 --> 00:08:49,610
difference between those two is the

00:08:47,510 --> 00:08:52,050
error and that error is going to be is

00:08:49,610 --> 00:08:54,720
called by these three PID gains

00:08:52,050 --> 00:08:56,490
and it's going to turn into this control

00:08:54,720 --> 00:09:01,020
variable u which is the duty cycle we

00:08:56,490 --> 00:09:02,670
apply to the model and now everything

00:09:01,020 --> 00:09:05,070
here is going to be compute at runtime

00:09:02,670 --> 00:09:07,440
except for the PID gains or has to be

00:09:05,070 --> 00:09:11,010
selected before running the PID

00:09:07,440 --> 00:09:16,589
controller so if you pick the right

00:09:11,010 --> 00:09:19,980
gains for the PID controller then we get

00:09:16,589 --> 00:09:24,410
something like this we get a stable

00:09:19,980 --> 00:09:27,630
system the robot and longer Falls and

00:09:24,410 --> 00:09:31,140
here we have data from that previous

00:09:27,630 --> 00:09:33,660
video and you can see that at the top we

00:09:31,140 --> 00:09:35,550
have the teal angle measure and the blue

00:09:33,660 --> 00:09:37,440
line and the Green Line is the set point

00:09:35,550 --> 00:09:39,209
which shows in this case it was 10

00:09:37,440 --> 00:09:41,240
degrees and the action of the PID

00:09:39,209 --> 00:09:44,040
controller is going to try to stabilize

00:09:41,240 --> 00:09:46,560
the teal angle so it will try to match

00:09:44,040 --> 00:09:48,990
the set point at the bottom you can see

00:09:46,560 --> 00:09:52,410
the duty cycle shows him by the PID

00:09:48,990 --> 00:09:54,779
controller and there a negative value

00:09:52,410 --> 00:09:58,110
means that the motor reverses its

00:09:54,779 --> 00:10:01,410
orientation but that's not the only

00:09:58,110 --> 00:10:03,900
possible outcome if you are trying to

00:10:01,410 --> 00:10:06,120
guess what the correct KD gains are so

00:10:03,900 --> 00:10:09,560
if you're in chosen correctly you add

00:10:06,120 --> 00:10:14,490
something like this an unstable system

00:10:09,560 --> 00:10:16,740
and what you got there is oscillatory

00:10:14,490 --> 00:10:19,110
behavior so instead of having the T Lang

00:10:16,740 --> 00:10:22,400
will converge to the set point you get

00:10:19,110 --> 00:10:24,870
this oscillation around the set point

00:10:22,400 --> 00:10:27,480
and well that's something you don't want

00:10:24,870 --> 00:10:29,970
so let's continue with the stable PD

00:10:27,480 --> 00:10:32,279
gains so before we have unstable system

00:10:29,970 --> 00:10:34,380
by the robot didn't move but again we

00:10:32,279 --> 00:10:36,720
want to be able to move the robot so

00:10:34,380 --> 00:10:39,810
what should we do to move the robot like

00:10:36,720 --> 00:10:41,579
this for example and the only thing we

00:10:39,810 --> 00:10:43,320
have to do is change the setpoint so

00:10:41,579 --> 00:10:45,779
before it was 10 degrees and that gave

00:10:43,320 --> 00:10:49,170
us almost no motion but just in a value

00:10:45,779 --> 00:10:51,770
of 4 in this case is going to make the

00:10:49,170 --> 00:10:54,450
robot move so the top we see again the

00:10:51,770 --> 00:10:56,610
tail angle stabilizes around the

00:10:54,450 --> 00:10:59,550
setpoint and at the bottom we have the

00:10:56,610 --> 00:11:00,959
PID a output which is the duty cycle

00:10:59,550 --> 00:11:02,640
which stabilizes but this time in

00:11:00,959 --> 00:11:04,770
stabilizers two unknowns zero value and

00:11:02,640 --> 00:11:08,040
that give us a speed

00:11:04,770 --> 00:11:10,380
and I value less time thing give us our

00:11:08,040 --> 00:11:12,029
forward motion and if we shows a value

00:11:10,380 --> 00:11:18,089
larger than 10 that will give us a

00:11:12,029 --> 00:11:19,680
backward motion okay so at this point of

00:11:18,089 --> 00:11:22,220
time you are wondering okay this is cool

00:11:19,680 --> 00:11:25,500
and all but wasn't this talk about rust

00:11:22,220 --> 00:11:31,380
so now let's talk about how rust helped

00:11:25,500 --> 00:11:33,029
build this kind of application and in

00:11:31,380 --> 00:11:35,520
this diagram you see the microcontroller

00:11:33,029 --> 00:11:37,350
in the center and the other components

00:11:35,520 --> 00:11:40,260
are the external components to which the

00:11:37,350 --> 00:11:42,270
my controller is connected to and each H

00:11:40,260 --> 00:11:45,540
in this graph is one of the my

00:11:42,270 --> 00:11:47,220
controller pins and the direction of the

00:11:45,540 --> 00:11:49,800
H indicates where the pin is configured

00:11:47,220 --> 00:11:51,600
as an input or as an output and the

00:11:49,800 --> 00:11:53,760
label indicates what the functionality

00:11:51,600 --> 00:11:55,200
of that pin is and the bottom line here

00:11:53,760 --> 00:11:56,790
is that you want to configure everything

00:11:55,200 --> 00:11:58,770
correctly otherwise your system will not

00:11:56,790 --> 00:12:01,610
work and you will have a hard time

00:11:58,770 --> 00:12:05,370
figuring out what it's not working and

00:12:01,610 --> 00:12:09,360
Roskam health fear if you design your

00:12:05,370 --> 00:12:11,670
API like something like this and write

00:12:09,360 --> 00:12:13,560
in this program we are going to set up a

00:12:11,670 --> 00:12:16,079
serial interface and for that we need to

00:12:13,560 --> 00:12:19,649
use two pins a transmission pin TX and

00:12:16,079 --> 00:12:21,630
our reception pin rx now and the first

00:12:19,649 --> 00:12:23,610
line we are going to take all the

00:12:21,630 --> 00:12:26,220
peripherals of the my controller into

00:12:23,610 --> 00:12:28,560
the current scope and at the second line

00:12:26,220 --> 00:12:30,810
we are going to take just one peripheral

00:12:28,560 --> 00:12:32,640
which is the EPI oh a which is in charge

00:12:30,810 --> 00:12:34,829
of configuring the pins of the

00:12:32,640 --> 00:12:38,700
microcontroller and we are going to

00:12:34,829 --> 00:12:41,370
split that into 16 independent pins now

00:12:38,700 --> 00:12:44,640
the frontline is going to change the pin

00:12:41,370 --> 00:12:47,970
pa9 into is going to put it into

00:12:44,640 --> 00:12:49,709
alternate push-pull output mode and that

00:12:47,970 --> 00:12:53,760
being we are going to use for the TX pin

00:12:49,709 --> 00:12:57,120
and important to note here is the type

00:12:53,760 --> 00:13:00,660
of the TX variable and then you can see

00:12:57,120 --> 00:13:02,730
the pin name pi9 but you also have this

00:13:00,660 --> 00:13:04,890
parameter inside which says alternate

00:13:02,730 --> 00:13:07,589
push-pull and that's the state the pin

00:13:04,890 --> 00:13:11,040
is in and this technique of putting the

00:13:07,589 --> 00:13:15,240
state of your some value into the type

00:13:11,040 --> 00:13:17,880
is called a type state and the in line

00:13:15,240 --> 00:13:18,630
number 4 we have simply assigned the

00:13:17,880 --> 00:13:22,440
ping PA

00:13:18,630 --> 00:13:24,810
10 to the our X variable and we have

00:13:22,440 --> 00:13:26,880
again the name of a pin in the type VI

00:13:24,810 --> 00:13:30,360
10 but the state is different it is in

00:13:26,880 --> 00:13:32,340
input mode and the next thing we do is

00:13:30,360 --> 00:13:35,040
quickly we create a certain interface

00:13:32,340 --> 00:13:37,040
and to create that we pass both TX and

00:13:35,040 --> 00:13:40,860
rx by value

00:13:37,040 --> 00:13:43,050
now this constructor is written in such

00:13:40,860 --> 00:13:45,030
a way that if you haven't configured

00:13:43,050 --> 00:13:47,190
your PIN correctly in the right mode

00:13:45,030 --> 00:13:49,710
then this won't compile because it has

00:13:47,190 --> 00:13:52,620
to have any specific type to be passed

00:13:49,710 --> 00:13:54,210
here and that means that you cannot do

00:13:52,620 --> 00:13:57,510
the configuration incorrectly because

00:13:54,210 --> 00:13:59,850
then your program won't compile and

00:13:57,510 --> 00:14:01,410
another thing you get here is that for

00:13:59,850 --> 00:14:04,170
example the last line tries to change

00:14:01,410 --> 00:14:06,120
the mode of the RX pin into output mode

00:14:04,170 --> 00:14:08,490
and that will break the seal extraction

00:14:06,120 --> 00:14:10,890
because the cell extraction expects that

00:14:08,490 --> 00:14:13,350
pin to be in input mode but you cannot

00:14:10,890 --> 00:14:14,820
do that in this with this API because

00:14:13,350 --> 00:14:17,700
when you constructed the serial

00:14:14,820 --> 00:14:20,460
abstraction you pass TX and rx by value

00:14:17,700 --> 00:14:22,680
so now the serial extraction owns what

00:14:20,460 --> 00:14:28,650
pins and you cannot confer them to be

00:14:22,680 --> 00:14:32,100
any other thing and one other thing

00:14:28,650 --> 00:14:33,960
a-rod's helps with is generic drivers so

00:14:32,100 --> 00:14:35,340
the my controller has two interface this

00:14:33,960 --> 00:14:39,090
external component which is the

00:14:35,340 --> 00:14:42,120
accelerometer and gyroscope so instead

00:14:39,090 --> 00:14:43,590
of writing code or a driver that lets my

00:14:42,120 --> 00:14:47,250
my controller interface with that

00:14:43,590 --> 00:14:50,040
component I chose to write the driver

00:14:47,250 --> 00:14:52,950
using generic programming so that it can

00:14:50,040 --> 00:14:55,320
work with different platforms and the

00:14:52,950 --> 00:14:59,180
key here with generic programming are

00:14:55,320 --> 00:15:02,580
traits which you can see and this spi

00:14:59,180 --> 00:15:04,020
type parameter in this bound by these

00:15:02,580 --> 00:15:06,540
two traits and the strains are

00:15:04,020 --> 00:15:08,970
interfaces and they basically said you

00:15:06,540 --> 00:15:10,920
can construct this driver is you pass me

00:15:08,970 --> 00:15:14,550
this type which implements this SPI

00:15:10,920 --> 00:15:16,230
interface and that means that as long as

00:15:14,550 --> 00:15:17,970
I provide a type that implements the

00:15:16,230 --> 00:15:19,680
interface then it could be implemented

00:15:17,970 --> 00:15:22,410
for a my controller or for a raspberry

00:15:19,680 --> 00:15:24,990
pi this driver doesn't care about that

00:15:22,410 --> 00:15:27,270
about those details so this driver can

00:15:24,990 --> 00:15:29,370
be reused across different devices or

00:15:27,270 --> 00:15:32,430
platforms

00:15:29,370 --> 00:15:34,290
and now so the community is putting

00:15:32,430 --> 00:15:37,350
together this embedded help right what

00:15:34,290 --> 00:15:39,540
we have is just a bunch of trades which

00:15:37,350 --> 00:15:42,660
represent different abstraction you have

00:15:39,540 --> 00:15:43,500
and embedded systems which are sharing a

00:15:42,660 --> 00:15:47,460
phase spi

00:15:43,500 --> 00:15:50,540
I to see bus and they ultimate goal here

00:15:47,460 --> 00:15:53,940
is code reuse so as a mission before

00:15:50,540 --> 00:15:57,030
driver arataura simply write the driver

00:15:53,940 --> 00:15:59,310
using these trades and they will support

00:15:57,030 --> 00:16:00,990
any platform that implements these

00:15:59,310 --> 00:16:03,660
traits and they don't have to write any

00:16:00,990 --> 00:16:06,690
platform specific code and the benefit

00:16:03,660 --> 00:16:08,040
for the developers who are targeting

00:16:06,690 --> 00:16:10,440
some platform is that once they

00:16:08,040 --> 00:16:12,390
implement is embedded health trades they

00:16:10,440 --> 00:16:15,870
get for free all the generic drivers

00:16:12,390 --> 00:16:18,450
that are built upon to that and right

00:16:15,870 --> 00:16:20,400
now we don't have many drivers published

00:16:18,450 --> 00:16:22,380
on crates Lodi oh but the communities

00:16:20,400 --> 00:16:28,110
were linking together to get allow then

00:16:22,380 --> 00:16:31,230
out this year and the communication

00:16:28,110 --> 00:16:34,200
model is one model well was really

00:16:31,230 --> 00:16:36,180
shined and I'm using this model for

00:16:34,200 --> 00:16:39,810
communicating wirelessly between the

00:16:36,180 --> 00:16:41,970
robot and my laptop or my phone and this

00:16:39,810 --> 00:16:43,380
model steps are serial interface from

00:16:41,970 --> 00:16:45,120
the micron Tori which is a simplified

00:16:43,380 --> 00:16:47,330
interface so then the Macondo doesn't

00:16:45,120 --> 00:16:50,310
have to implement the Bluetooth stack

00:16:47,330 --> 00:16:52,050
now I use this mainly to lock data from

00:16:50,310 --> 00:16:55,650
the robot so then I can analyze that

00:16:52,050 --> 00:16:57,510
later on and this model is limited to

00:16:55,650 --> 00:16:59,490
communication speed of around 10

00:16:57,510 --> 00:17:02,120
kilobytes per second and I want to lock

00:16:59,490 --> 00:17:05,490
data really fast so I have two shows

00:17:02,120 --> 00:17:08,400
format that will let me do that and I

00:17:05,490 --> 00:17:10,740
chose a binary form and just directly

00:17:08,400 --> 00:17:13,860
translate all the types into binary

00:17:10,740 --> 00:17:15,840
format but in my application you have to

00:17:13,860 --> 00:17:18,420
write any binary serialization on

00:17:15,840 --> 00:17:21,030
personality instead I simply grab this

00:17:18,420 --> 00:17:24,290
biodegrade from Chris dot IO and I use

00:17:21,030 --> 00:17:26,790
that to serialize the data into an array

00:17:24,290 --> 00:17:29,310
and now this works and I can send data

00:17:26,790 --> 00:17:30,840
in binary format to my laptop but there

00:17:29,310 --> 00:17:33,540
is a problem because this is a wireless

00:17:30,840 --> 00:17:35,720
link data might be dropped if the robot

00:17:33,540 --> 00:17:39,510
said gets too far away

00:17:35,720 --> 00:17:42,840
so to sortal prolene I can add friend

00:17:39,510 --> 00:17:44,909
limiters to my data before sending that

00:17:42,840 --> 00:17:47,190
and for that I'm going to use this cops

00:17:44,909 --> 00:17:51,480
frame crate which is also increased load

00:17:47,190 --> 00:17:53,399
i/o and this a gorilla had a friend a

00:17:51,480 --> 00:17:55,379
limiter which is usually zero and then

00:17:53,399 --> 00:17:58,080
translates the rest of the data so it

00:17:55,379 --> 00:17:59,759
doesn't have any zero in there and it

00:17:58,080 --> 00:18:04,499
what provides a way to encode and decode

00:17:59,759 --> 00:18:07,379
the frame and once I had that then my

00:18:04,499 --> 00:18:08,970
data was properly friendly limited but

00:18:07,379 --> 00:18:11,340
then I started wondering could it be

00:18:08,970 --> 00:18:13,710
that I lose some weight

00:18:11,340 --> 00:18:16,470
right and I still get a valid frame on

00:18:13,710 --> 00:18:20,909
the laptop and I will still get a young

00:18:16,470 --> 00:18:23,009
date out of that so I checksum to my

00:18:20,909 --> 00:18:25,980
data to verify that the frame is

00:18:23,009 --> 00:18:27,149
actually what I wanted to send and again

00:18:25,980 --> 00:18:29,129
I didn't implement that in my

00:18:27,149 --> 00:18:31,169
application I simply grab a checksum

00:18:29,129 --> 00:18:34,830
Crichton press dot IO in this case the

00:18:31,169 --> 00:18:38,460
CRC 16 and here you can see the full

00:18:34,830 --> 00:18:40,499
code i sterilize my data and compute the

00:18:38,460 --> 00:18:44,779
checksum append that and then turn that

00:18:40,499 --> 00:18:49,590
into a cop's print and put on the wire

00:18:44,779 --> 00:18:51,509
and one of the last parts is concurrency

00:18:49,590 --> 00:18:54,749
so I have to do multitasking on the my

00:18:51,509 --> 00:18:56,999
controller and I don't have to do this

00:18:54,749 --> 00:18:59,639
two tasks and for that I use this real

00:18:56,999 --> 00:19:04,860
time for the masses or RTFM framework

00:18:59,639 --> 00:19:06,929
and it lets me do a task on top of inner

00:19:04,860 --> 00:19:09,090
handlers so it's basically a harbor base

00:19:06,929 --> 00:19:11,940
scheduler so it is really fast and

00:19:09,090 --> 00:19:14,580
efficient but since this was I have to

00:19:11,940 --> 00:19:17,850
worry about data races so I have this

00:19:14,580 --> 00:19:19,710
two tasks one was periodic where I read

00:19:17,850 --> 00:19:21,539
the sensors update my comma filter

00:19:19,710 --> 00:19:23,820
update the PID component and lock the

00:19:21,539 --> 00:19:27,149
data and then I have this other kind of

00:19:23,820 --> 00:19:29,129
a synchronous task where my laptop send

00:19:27,149 --> 00:19:31,169
some data to the PI controller and I

00:19:29,129 --> 00:19:37,499
start to change the PID game because I

00:19:31,169 --> 00:19:40,470
was manually tuning the gains and we use

00:19:37,499 --> 00:19:41,759
inner handlers then and you need to

00:19:40,470 --> 00:19:45,809
share data between the a and then you

00:19:41,759 --> 00:19:48,210
have to use static variables and static

00:19:45,809 --> 00:19:51,059
variables are troublesome one because

00:19:48,210 --> 00:19:53,460
they you might run into that arises but

00:19:51,059 --> 00:19:56,070
I think a major problem from my point of

00:19:53,460 --> 00:19:56,370
view is that they make the code and not

00:19:56,070 --> 00:19:58,230
read

00:19:56,370 --> 00:19:59,820
because then anything can modify the

00:19:58,230 --> 00:20:02,700
variables so you don't know who has

00:19:59,820 --> 00:20:05,580
access to the variable but with this

00:20:02,700 --> 00:20:07,140
framework we have this declare a tip-up

00:20:05,580 --> 00:20:08,880
macro where you define all your

00:20:07,140 --> 00:20:11,250
resources which are nothing else that

00:20:08,880 --> 00:20:13,559
static variables and then you declare

00:20:11,250 --> 00:20:16,650
your task and you assign the resources

00:20:13,559 --> 00:20:17,970
to the task so then when you're writing

00:20:16,650 --> 00:20:21,390
the task body which is at the bottom

00:20:17,970 --> 00:20:23,820
then thus task only has access to the

00:20:21,390 --> 00:20:27,809
resources which was declared in the app

00:20:23,820 --> 00:20:29,429
macro and if you try to access any other

00:20:27,809 --> 00:20:31,140
resource that wasn't declared up for

00:20:29,429 --> 00:20:34,470
that task you will get a compiler error

00:20:31,140 --> 00:20:38,250
and the framework also takes care of if

00:20:34,470 --> 00:20:39,750
you have sharing between a resource is

00:20:38,250 --> 00:20:41,610
shared between two tasks and the frame

00:20:39,750 --> 00:20:44,580
will take care of ensuring that the

00:20:41,610 --> 00:20:46,890
access is free of that raises and for

00:20:44,580 --> 00:20:49,799
example they are staffed at the bottom

00:20:46,890 --> 00:20:53,250
to access the PID resources share it has

00:20:49,799 --> 00:20:59,820
to use a lock to achieve data raise

00:20:53,250 --> 00:21:02,580
freedom okay some other random stuff the

00:20:59,820 --> 00:21:05,789
CPU uses of the migrant dollar was

00:21:02,580 --> 00:21:10,080
around 21 percent the CPU was running a

00:21:05,789 --> 00:21:11,789
64 may occurs and had no FPU and the

00:21:10,080 --> 00:21:15,929
control loop was running around 500

00:21:11,789 --> 00:21:19,140
times per second binary size my

00:21:15,929 --> 00:21:20,789
application was around what four hundred

00:21:19,140 --> 00:21:22,770
lines of code excluding the code from

00:21:20,789 --> 00:21:25,320
the dependencies everything that ended

00:21:22,770 --> 00:21:28,230
in the binary came from our source code

00:21:25,320 --> 00:21:31,230
and the binary size was around eight

00:21:28,230 --> 00:21:33,390
point five kilobytes in flash an actor

00:21:31,230 --> 00:21:35,429
like two kilobytes of that are due to

00:21:33,390 --> 00:21:40,890
software emulation of flowed aromatic

00:21:35,429 --> 00:21:43,289
because I don't have an FPU Ram was 140

00:21:40,890 --> 00:21:45,720
bytes and I didn't use any dynamic

00:21:43,289 --> 00:21:48,270
memory allocation the button you can see

00:21:45,720 --> 00:21:49,980
they the biggest symbols and a mountain

00:21:48,270 --> 00:21:54,750
you will find this software emulation of

00:21:49,980 --> 00:21:56,789
ITP floats finally this is the

00:21:54,750 --> 00:22:00,270
dependency graph of the project it has

00:21:56,789 --> 00:22:02,250
around 20 dependencies excluding build

00:22:00,270 --> 00:22:05,100
dependencies so there's a lot of code

00:22:02,250 --> 00:22:07,649
reuse in there one thing I found scary

00:22:05,100 --> 00:22:09,390
is that most of those crates have been

00:22:07,649 --> 00:22:09,970
written by me except for like three or

00:22:09,390 --> 00:22:11,740
four

00:22:09,970 --> 00:22:14,919
but if you were writing this then you

00:22:11,740 --> 00:22:17,080
have to do all the work right in the

00:22:14,919 --> 00:22:19,750
dependencies okay

00:22:17,080 --> 00:22:21,730
in conclusion ross is small enough so he

00:22:19,750 --> 00:22:23,350
can fit in a micron juror is also

00:22:21,730 --> 00:22:26,409
perform enough that you can implement

00:22:23,350 --> 00:22:28,690
this time-sensitive control system on a

00:22:26,409 --> 00:22:30,429
resource-constrained device is also

00:22:28,690 --> 00:22:33,159
memory safe you can do multitasking

00:22:30,429 --> 00:22:35,679
without having to care about data races

00:22:33,159 --> 00:22:37,600
or whatever that it also lets you write

00:22:35,679 --> 00:22:38,919
more correct code we saw in the pink

00:22:37,600 --> 00:22:41,649
configuration you cannot get it wrong

00:22:38,919 --> 00:22:43,330
with the api you can also easily use the

00:22:41,649 --> 00:22:45,399
particle which we use a lot in the

00:22:43,330 --> 00:22:47,440
communication module and it's also good

00:22:45,399 --> 00:22:49,419
for code reuse we'll have this genetic

00:22:47,440 --> 00:22:52,990
driver which skill can be used in many

00:22:49,419 --> 00:23:14,559
different platforms and that's all I

00:22:52,990 --> 00:23:18,039
have thank you yes so what is already a

00:23:14,559 --> 00:23:20,529
costume oh yes the question was how was

00:23:18,039 --> 00:23:21,730
it to cross-compiled to that target so I

00:23:20,529 --> 00:23:24,789
think is that the rest compiler is

00:23:21,730 --> 00:23:27,399
already a cross compiler by default so I

00:23:24,789 --> 00:23:29,200
didn't need to do anything special

00:23:27,399 --> 00:23:31,779
I could really generate machine code for

00:23:29,200 --> 00:23:33,669
the UM context Mike Rinder the only

00:23:31,779 --> 00:23:35,740
external dude told that I needed was a

00:23:33,669 --> 00:23:39,279
linker because Rossi doesn't include a

00:23:35,740 --> 00:23:41,320
linker inside so I use LD unknown ABI LD

00:23:39,279 --> 00:23:52,149
and then there was the only external

00:23:41,320 --> 00:23:55,090
dependency I had the question is what's

00:23:52,149 --> 00:23:56,789
my background for doing this and

00:23:55,090 --> 00:24:00,340
actually I have a Bachelor in

00:23:56,789 --> 00:24:02,019
mechatronics engineering and yeah

00:24:00,340 --> 00:24:04,059
basically I took like several semesters

00:24:02,019 --> 00:24:10,990
of control theory so this is the kind of

00:24:04,059 --> 00:24:13,860
stuff we do there yes the back

00:24:10,990 --> 00:24:13,860
yes you

00:24:34,820 --> 00:24:40,709
okay the question is so it was using a

00:24:38,879 --> 00:24:42,989
cortex in my condo how hard will be to

00:24:40,709 --> 00:24:48,599
support all the architects it also all

00:24:42,989 --> 00:24:51,139
the other my controllers right okay okay

00:24:48,599 --> 00:24:54,450
only about the cortex my controller and

00:24:51,139 --> 00:24:58,200
so to get a more device support we have

00:24:54,450 --> 00:25:00,779
a tool called SVD two rods which so

00:24:58,200 --> 00:25:02,940
benders give us this description of all

00:25:00,779 --> 00:25:05,429
the register in a my controller in this

00:25:02,940 --> 00:25:08,519
SVD format which is a finished an XML

00:25:05,429 --> 00:25:10,709
file and we can translate that into rust

00:25:08,519 --> 00:25:11,729
coated levels use all the registers on

00:25:10,709 --> 00:25:14,099
the my contrary

00:25:11,729 --> 00:25:17,909
so that gets like ninety percent of the

00:25:14,099 --> 00:25:19,259
work done and if you have the SVD file

00:25:17,909 --> 00:25:21,749
for American product and basically you

00:25:19,259 --> 00:25:24,359
can already do io and use the registers

00:25:21,749 --> 00:25:26,700
and on top of that you will want to

00:25:24,359 --> 00:25:28,979
build something a slightly higher level

00:25:26,700 --> 00:25:31,200
because manipulating the register can be

00:25:28,979 --> 00:25:33,539
error-prone and for that we have this

00:25:31,200 --> 00:25:36,809
embedded halt rates and if you implement

00:25:33,539 --> 00:25:39,059
a halt I uses that interface then it's

00:25:36,809 --> 00:25:40,979
like a 10 percent of the job left and

00:25:39,059 --> 00:25:44,759
once you do that then you get access to

00:25:40,979 --> 00:25:47,249
these generic drivers right now people

00:25:44,759 --> 00:25:49,409
are mainly using stm32 my controllers I

00:25:47,249 --> 00:25:56,249
have seen some people using like an XP

00:25:49,409 --> 00:25:58,619
LPC and a bit of sound from a PR and but

00:25:56,249 --> 00:26:00,690
the boards that have most support are

00:25:58,619 --> 00:26:07,079
the blue pill which is the one here and

00:26:00,690 --> 00:26:09,440
a few of the discoveries is mr. another

00:26:07,079 --> 00:26:09,440
question

00:26:10,290 --> 00:26:14,580
they've anyone who's interested in

00:26:12,390 --> 00:26:18,060
robotics we're gonna have a virtual

00:26:14,580 --> 00:26:22,730
feathering about 30 minutes so if you

00:26:18,060 --> 00:26:22,730
are what is this or just love robots

00:26:25,210 --> 00:26:33,650

YouTube URL: https://www.youtube.com/watch?v=XyMqYdJeXu8


