Title: Luca Barbato - Introducing rust-av
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	A pure-Rust approach to multimedia

Multimedia development is mainly done in C+assembly since speed is important and such combination of languages traditionally gives the best control over the hardware.

Rust is considered a mature system language that provides strong warranties about memory access (and more) without sacrificing runtime speed.

Multimedia libraries are plagued by classes of bugs that Rust actively prevents at compile time, thus this talk is about leveraging Rust to have a multimedia framework that is nice to use and at the same time more trustworthy.

Target audience is people with some Rust knowledge and some experience with multimedia libraries and concepts.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_av/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:06,620 --> 00:00:11,959
look up no okay

00:00:16,190 --> 00:00:28,079
[Applause]

00:00:21,770 --> 00:00:29,610
welcome well let's start with me who I

00:00:28,079 --> 00:00:34,469
am

00:00:29,610 --> 00:00:38,970
I contribute to quite a bit of different

00:00:34,469 --> 00:00:45,180
open-source project gentle vidalin liebe

00:00:38,970 --> 00:00:47,820
V Roth directly VPX h.264 so my

00:00:45,180 --> 00:00:50,280
experience is mostly on everything that

00:00:47,820 --> 00:00:53,730
goes from fixing random software that

00:00:50,280 --> 00:00:55,590
ends up broken because of gentle since

00:00:53,730 --> 00:00:58,470
we build everything from source if the

00:00:55,590 --> 00:01:01,590
source break with that compiler we have

00:00:58,470 --> 00:01:05,390
to fix it I have a quite an experience

00:01:01,590 --> 00:01:11,219
with multimedia brought on fixing bugs

00:01:05,390 --> 00:01:13,499
getting stuff built designing api's I

00:01:11,219 --> 00:01:17,210
started to get my hands dirty

00:01:13,499 --> 00:01:21,710
directly with the first compiler and

00:01:17,210 --> 00:01:21,710
today I'm going to talk to you about

00:01:22,999 --> 00:01:30,799
multimedia and Russ as in writing a

00:01:26,759 --> 00:01:30,799
multimedia framework impure rust

00:01:35,340 --> 00:01:45,310
why to do that I guess you all know

00:01:40,359 --> 00:01:49,149
already that Russ is touted as a quite

00:01:45,310 --> 00:01:51,759
safe language that is still for system

00:01:49,149 --> 00:01:55,840
programming and it's supposed to be

00:01:51,759 --> 00:01:58,299
quite fast and quite good for writing

00:01:55,840 --> 00:02:01,810
threaded code Multimedia's fee loved it

00:01:58,299 --> 00:02:04,090
and I say give you some guarantees that

00:02:01,810 --> 00:02:07,390
what you're writing is not going to

00:02:04,090 --> 00:02:13,150
explode just because you happen to feed

00:02:07,390 --> 00:02:16,720
it to the wrong pointer what idea why

00:02:13,150 --> 00:02:20,680
not going the other way so replacing

00:02:16,720 --> 00:02:25,359
just some piece of an existing framework

00:02:20,680 --> 00:02:28,720
with Russ well Russ is also good to

00:02:25,359 --> 00:02:32,440
writing better api's because the way

00:02:28,720 --> 00:02:37,690
Russ works make you easier to describe

00:02:32,440 --> 00:02:41,470
concept so why not start writing a good

00:02:37,690 --> 00:02:44,590
API write possibly good code and

00:02:41,470 --> 00:02:47,769
leverage the whole language and actually

00:02:44,590 --> 00:02:51,160
try that what is the current it touted

00:02:47,769 --> 00:02:54,609
about rust is actual real and working

00:02:51,160 --> 00:02:58,359
for multimedia so the main idea is that

00:02:54,609 --> 00:02:59,340
I want to make a framework that is easy

00:02:58,359 --> 00:03:03,180
to use

00:02:59,340 --> 00:03:06,400
possibly fast and trustworthy so

00:03:03,180 --> 00:03:11,079
possibly less bugs that CVEs

00:03:06,400 --> 00:03:17,290
less bad situation because you you play

00:03:11,079 --> 00:03:20,380
your movie and something bad happens is

00:03:17,290 --> 00:03:23,019
it use do we have other frameworks that

00:03:20,380 --> 00:03:27,250
are easy to use we have a problem with

00:03:23,019 --> 00:03:29,859
multimedia multimedia is lots of easy to

00:03:27,250 --> 00:03:31,870
grasp concept with many many many

00:03:29,859 --> 00:03:34,510
different queries and details that you

00:03:31,870 --> 00:03:37,000
have to work around so usually the

00:03:34,510 --> 00:03:39,940
framework if it's easy is quiet

00:03:37,000 --> 00:03:43,299
opinionated makes decision for you and

00:03:39,940 --> 00:03:45,160
you cannot undo them easily on the other

00:03:43,299 --> 00:03:47,510
hand if the framework lets you do

00:03:45,160 --> 00:03:50,120
everything that you could want

00:03:47,510 --> 00:03:54,980
there you have to face the complexity

00:03:50,120 --> 00:03:58,909
and the ideas since Russ

00:03:54,980 --> 00:04:03,709
give us the this concept of zero cost

00:03:58,909 --> 00:04:06,790
abstraction I can layer my extraction so

00:04:03,709 --> 00:04:11,360
I can match your need regarding

00:04:06,790 --> 00:04:14,810
simplicity and well power to do whatever

00:04:11,360 --> 00:04:18,049
you want first

00:04:14,810 --> 00:04:20,930
sebastian already said that you can

00:04:18,049 --> 00:04:24,710
write a dramatic rust that result in

00:04:20,930 --> 00:04:27,350
code that executes fast enough or asleep

00:04:24,710 --> 00:04:33,590
in my experience even faster than you

00:04:27,350 --> 00:04:36,320
would expect trustworthy I guess

00:04:33,590 --> 00:04:38,120
everybody here ready here and experience

00:04:36,320 --> 00:04:40,190
the fact that the compiler prevents you

00:04:38,120 --> 00:04:42,310
to make lots and lots of mistakes that

00:04:40,190 --> 00:04:50,240
are quite common if you're writing C or

00:04:42,310 --> 00:04:55,220
even Java what would be good but it is

00:04:50,240 --> 00:04:59,150
an experiment so far as in I can tell

00:04:55,220 --> 00:05:01,520
you that so far Russ is great but it's

00:04:59,150 --> 00:05:04,669
not perfect and during this presentation

00:05:01,520 --> 00:05:07,370
I will show you orally I will tell you

00:05:04,669 --> 00:05:10,539
what I would like to have in during this

00:05:07,370 --> 00:05:13,970
year that is currently not available

00:05:10,539 --> 00:05:16,760
also since I don't like to reinvent

00:05:13,970 --> 00:05:19,039
completely the wheel I'm leveraging

00:05:16,760 --> 00:05:22,520
other libraries that is part of the

00:05:19,039 --> 00:05:24,949
rustico system I mean the in the case

00:05:22,520 --> 00:05:28,550
multimedia needs can be different from

00:05:24,949 --> 00:05:31,760
the needs of other software so even

00:05:28,550 --> 00:05:33,830
regarding libraries we have some

00:05:31,760 --> 00:05:35,990
interaction some patches getting written

00:05:33,830 --> 00:05:38,680
sometimes I have to adapt to what

00:05:35,990 --> 00:05:43,190
deliberate there every wants to do

00:05:38,680 --> 00:05:45,800
currently in this version we are using a

00:05:43,190 --> 00:05:48,580
bit of nom that I guess you know what

00:05:45,800 --> 00:05:51,889
well who doesn't know gnome

00:05:48,580 --> 00:05:54,229
okay enough people probably you don't

00:05:51,889 --> 00:05:57,650
know that there is the khaki cookie

00:05:54,229 --> 00:05:59,990
cutter that is from the same person that

00:05:57,650 --> 00:06:01,040
wrote gnome and does exactly the

00:05:59,990 --> 00:06:03,680
opposite instead

00:06:01,040 --> 00:06:11,560
of chewing bytes and give you structure

00:06:03,680 --> 00:06:11,560
to structures and gives you bytes so

00:06:12,730 --> 00:06:23,960
what I did so far the idea for the

00:06:19,360 --> 00:06:29,240
toolkit of framework is that I'd like to

00:06:23,960 --> 00:06:31,520
have it modular so I want that all the

00:06:29,240 --> 00:06:35,720
code that is written for Razavi can be

00:06:31,520 --> 00:06:38,780
reduced as much as possible I said

00:06:35,720 --> 00:06:41,570
already I'm trying to use a layered

00:06:38,780 --> 00:06:44,870
approach so if you don't care about

00:06:41,570 --> 00:06:47,630
details you can write your player in few

00:06:44,870 --> 00:06:50,990
lines of code if you do care about

00:06:47,630 --> 00:06:56,240
details you can dig down as deep as

00:06:50,990 --> 00:07:00,200
possible with within reason how I'm

00:06:56,240 --> 00:07:03,230
doing that modular russ as the concept

00:07:00,200 --> 00:07:06,710
of crate that works quite well to do

00:07:03,230 --> 00:07:09,710
that every single component every single

00:07:06,710 --> 00:07:14,780
codec every single format lives in a

00:07:09,710 --> 00:07:17,420
standalone crate then if you want to not

00:07:14,780 --> 00:07:22,490
care about details we have crates that

00:07:17,420 --> 00:07:26,270
just react sport collection of different

00:07:22,490 --> 00:07:30,290
formats collection a different codec if

00:07:26,270 --> 00:07:33,680
you want capabilities instead of

00:07:30,290 --> 00:07:38,060
directly using the the codec you can use

00:07:33,680 --> 00:07:41,390
a context that sort of embeds the codec

00:07:38,060 --> 00:07:45,320
and gives you some layer of a structure

00:07:41,390 --> 00:07:47,540
to simplify your life for the format you

00:07:45,320 --> 00:07:49,970
would you can feed the format just with

00:07:47,540 --> 00:07:52,130
bytes but usually you want to use a

00:07:49,970 --> 00:07:55,160
Europe you have a contest that take and

00:07:52,130 --> 00:07:59,150
I your object take your the format that

00:07:55,160 --> 00:08:01,460
is supposed to be able to parse it and

00:07:59,150 --> 00:08:07,280
then from there you could just get

00:08:01,460 --> 00:08:11,180
packets out of it with reusable said I

00:08:07,280 --> 00:08:13,460
want to make sure that people like who

00:08:11,180 --> 00:08:14,390
is implementing gstreamer do not have to

00:08:13,460 --> 00:08:18,290
undo

00:08:14,390 --> 00:08:21,710
I choose my choices about what what

00:08:18,290 --> 00:08:25,580
should be done so they can just wiring

00:08:21,710 --> 00:08:31,250
directly in the specific called akan

00:08:25,580 --> 00:08:34,040
format that should be helpful what we

00:08:31,250 --> 00:08:38,110
have so far the idea is that we have

00:08:34,040 --> 00:08:43,130
some essential crate that give us the

00:08:38,110 --> 00:08:45,350
basic data types that are used for

00:08:43,130 --> 00:08:48,530
multimedia so I want to represent a role

00:08:45,350 --> 00:08:52,580
frame a role frame can contain video

00:08:48,530 --> 00:08:56,990
pixel or audio samples and if we are

00:08:52,580 --> 00:09:00,110
talking about encoded data we have

00:08:56,990 --> 00:09:03,200
packets and that's the basics that's the

00:09:00,110 --> 00:09:07,030
only part that currently everything else

00:09:03,200 --> 00:09:11,540
in rostov II depends on when you are

00:09:07,030 --> 00:09:14,680
writing codecs usually want to read bit

00:09:11,540 --> 00:09:20,210
by bit having to deal with codebook

00:09:14,680 --> 00:09:23,150
variable length codes and so on we have

00:09:20,210 --> 00:09:25,760
another sort of based mostly used just

00:09:23,150 --> 00:09:28,970
for the codecs that he is a bit stream

00:09:25,760 --> 00:09:30,680
reader and writer then we got the core

00:09:28,970 --> 00:09:34,520
functionality so far

00:09:30,680 --> 00:09:44,210
Russell II provides you I mean to the

00:09:34,520 --> 00:09:47,180
MOOCs MOOCs decode and encode I say if

00:09:44,210 --> 00:09:51,620
you don't care about details we have an

00:09:47,180 --> 00:09:57,560
upper layer we have a player crate that

00:09:51,620 --> 00:09:58,460
just give you the base component just to

00:09:57,560 --> 00:10:04,090
have the playback

00:09:58,460 --> 00:10:08,210
I give it an read object I get back my

00:10:04,090 --> 00:10:11,150
frames that I can just fit to STL and I

00:10:08,210 --> 00:10:16,640
have my player encoder same idea

00:10:11,150 --> 00:10:19,810
I got frames and I'm getting encoded

00:10:16,640 --> 00:10:24,010
data meta craze the concept of just

00:10:19,810 --> 00:10:28,750
making a sample so you don't have to

00:10:24,010 --> 00:10:28,750
think okay I want to have the

00:10:28,899 --> 00:10:35,329
matroska more bees you have just a

00:10:32,839 --> 00:10:38,600
jumble you don't care you have

00:10:35,329 --> 00:10:41,829
everything we also have some test

00:10:38,600 --> 00:10:44,839
programs and transcoding tool and a

00:10:41,829 --> 00:10:49,120
player tool that is pretty much used to

00:10:44,839 --> 00:10:49,120
validate everything that is up there

00:10:52,060 --> 00:11:00,920
where are we so far so far what is done

00:10:56,990 --> 00:11:04,339
for the possibly first release is the

00:11:00,920 --> 00:11:06,709
API just to do that so I say encoding

00:11:04,339 --> 00:11:09,680
decoding maxing the maxing we have

00:11:06,709 --> 00:11:12,040
already some codecs we have non native

00:11:09,680 --> 00:11:15,740
cause the codecs that are just wrapping

00:11:12,040 --> 00:11:20,389
known libraries from C to R us is quite

00:11:15,740 --> 00:11:24,170
easy I'm working on native codecs so

00:11:20,389 --> 00:11:29,060
completely pure rust so I'm experiencing

00:11:24,170 --> 00:11:31,699
face fear first how is it going that

00:11:29,060 --> 00:11:34,880
kind of level of detail using just rust

00:11:31,699 --> 00:11:38,480
as a format we have Matroska and the

00:11:34,880 --> 00:11:43,339
programs available are just those two in

00:11:38,480 --> 00:11:45,980
the future we will have more API surface

00:11:43,339 --> 00:11:49,970
so you can do more stuff with this

00:11:45,980 --> 00:11:54,410
toolkit we will have more native code we

00:11:49,970 --> 00:11:58,190
probably expose more reference codecs

00:11:54,410 --> 00:12:01,190
and we will have more formats for the

00:11:58,190 --> 00:12:03,610
next next version we will still even

00:12:01,190 --> 00:12:06,970
discussing about hardware acceleration

00:12:03,610 --> 00:12:11,930
so this is more or less the roadmap and

00:12:06,970 --> 00:12:16,189
is mostly related on my time and how

00:12:11,930 --> 00:12:17,930
mature rust is for this purpose what do

00:12:16,189 --> 00:12:20,569
I mean

00:12:17,930 --> 00:12:22,839
rust currently in my experience is a

00:12:20,569 --> 00:12:26,149
great language to write this kind of

00:12:22,839 --> 00:12:30,740
software because the compiler really

00:12:26,149 --> 00:12:33,740
helps you you don't have that many

00:12:30,740 --> 00:12:37,209
problems in getting performance even if

00:12:33,740 --> 00:12:41,950
you're writing high-level automatic code

00:12:37,209 --> 00:12:44,470
it's quite easy to write bindings to see

00:12:41,950 --> 00:12:46,440
so you don't have even problem in

00:12:44,470 --> 00:12:50,440
getting something that you can compare

00:12:46,440 --> 00:12:54,820
what is missing and what we would like

00:12:50,440 --> 00:12:57,250
to have simply Cindy is pretty much a

00:12:54,820 --> 00:12:59,320
need when you're writing multimedia

00:12:57,250 --> 00:13:02,740
because you need code that is really

00:12:59,320 --> 00:13:05,140
fast it's coming soon it's coming point

00:13:02,740 --> 00:13:08,320
soon and we have all ready to inter

00:13:05,140 --> 00:13:10,180
interesting ways in nightly to use it we

00:13:08,320 --> 00:13:14,560
are faster that is a great that let you

00:13:10,180 --> 00:13:17,410
use high-level it I traitors and it

00:13:14,560 --> 00:13:20,650
generates Cindy out of it quite good

00:13:17,410 --> 00:13:24,300
because you write it once and you sort

00:13:20,650 --> 00:13:29,080
of for free something that is faster

00:13:24,300 --> 00:13:32,770
STDs Cindy this part will be part of STD

00:13:29,080 --> 00:13:35,920
and will get you all the power of the

00:13:32,770 --> 00:13:42,060
intrinsic that you currently have like

00:13:35,920 --> 00:13:45,250
from Syria and GCC another need is a

00:13:42,060 --> 00:13:46,930
location that is aligned to something

00:13:45,250 --> 00:13:50,170
large why

00:13:46,930 --> 00:13:53,260
Cindy works much better or works at all

00:13:50,170 --> 00:13:55,780
with a lion buffers and harder

00:13:53,260 --> 00:13:58,750
acceleration just need the buffer

00:13:55,780 --> 00:14:03,850
aligned to their specific needs that

00:13:58,750 --> 00:14:07,180
could be a large as a page something

00:14:03,850 --> 00:14:09,130
else that would be nice to have it's not

00:14:07,180 --> 00:14:11,560
that compulsory but it's really nice to

00:14:09,130 --> 00:14:15,640
have and it's coming soon Constitution

00:14:11,560 --> 00:14:18,580
Eric's currently you can be you can

00:14:15,640 --> 00:14:21,010
write generic code in rust but cannot be

00:14:18,580 --> 00:14:22,720
generic over a constant and in

00:14:21,010 --> 00:14:25,180
multimedia you have many situation which

00:14:22,720 --> 00:14:27,130
you have some small details that are

00:14:25,180 --> 00:14:29,790
just constants and embedded this

00:14:27,130 --> 00:14:34,510
information in types is cumbersome and

00:14:29,790 --> 00:14:38,760
ugly in line assembly some people like

00:14:34,510 --> 00:14:43,720
it some people doesn't is coming soon is

00:14:38,760 --> 00:14:46,720
sort of interesting since we add it from

00:14:43,720 --> 00:14:48,340
start but it's not really stable and

00:14:46,720 --> 00:14:51,940
since the language wants to be as stable

00:14:48,340 --> 00:14:55,110
as possible you cannot leverage the LLVM

00:14:51,940 --> 00:14:58,200
syntax that is completely in flux and

00:14:55,110 --> 00:15:00,149
you cannot even leverage the syntax that

00:14:58,200 --> 00:15:04,680
is currently shared between GCC and

00:15:00,149 --> 00:15:06,899
Silang because again you don't have any

00:15:04,680 --> 00:15:10,529
kind of warranties beside the fact that

00:15:06,899 --> 00:15:13,200
if the Salang / DCC change the syntax

00:15:10,529 --> 00:15:15,060
you will have lots of angry users that

00:15:13,200 --> 00:15:17,339
have perfectly working called the stuff

00:15:15,060 --> 00:15:18,000
working but it's not exactly a great

00:15:17,339 --> 00:15:20,820
warranty

00:15:18,000 --> 00:15:24,470
so what is going on is that we have a

00:15:20,820 --> 00:15:27,269
new RFC a new syntax being discussed and

00:15:24,470 --> 00:15:31,529
possibly we will that get that within

00:15:27,269 --> 00:15:35,640
this year and this is the good part the

00:15:31,529 --> 00:15:40,410
bad part is that for multimedia you

00:15:35,640 --> 00:15:43,800
would like to have look-up tables you

00:15:40,410 --> 00:15:46,620
want to generate a lot of them and rust

00:15:43,800 --> 00:15:50,899
doesn't really work for this kind of

00:15:46,620 --> 00:15:53,640
purpose a brace in brass are okay but

00:15:50,899 --> 00:15:56,310
they are not good as vector they are

00:15:53,640 --> 00:16:00,300
sort of second-class citizen so you

00:15:56,310 --> 00:16:04,980
cannot collect you a slice you cannot do

00:16:00,300 --> 00:16:10,079
a number of automatic use a number of a

00:16:04,980 --> 00:16:13,579
dramatic feature on a race is going to

00:16:10,079 --> 00:16:17,790
change mainly because of the cons

00:16:13,579 --> 00:16:21,959
generic but nobody's really working on

00:16:17,790 --> 00:16:24,269
the part and this is pretty much the

00:16:21,959 --> 00:16:27,500
remaining bit that we would need for

00:16:24,269 --> 00:16:29,279
having a perfect language for multimedia

00:16:27,500 --> 00:16:31,620
that's it

00:16:29,279 --> 00:16:41,459
we have five minutes left and if you

00:16:31,620 --> 00:16:43,110
have question please I thought oh I

00:16:41,459 --> 00:16:47,089
thought that the question were part of

00:16:43,110 --> 00:16:47,089
the five days okay

00:16:48,980 --> 00:16:55,500
it is open source here we have a github

00:16:52,589 --> 00:16:58,380
organization everybody is welcome to

00:16:55,500 --> 00:17:01,079
contribute code I already have somebody

00:16:58,380 --> 00:17:05,010
that currently offered a Vorbis decoder

00:17:01,079 --> 00:17:07,559
so now beside what we have we also have

00:17:05,010 --> 00:17:10,939
a Vorbis decoder that's was sort of a

00:17:07,559 --> 00:17:13,169
surprise and was quite needed so I got a

00:17:10,939 --> 00:17:19,290
validation from a different person that

00:17:13,169 --> 00:17:22,709
the API works for the purpose say usual

00:17:19,290 --> 00:17:25,169
rules you can fork the what you like to

00:17:22,709 --> 00:17:29,010
contribute and issue a pull request and

00:17:25,169 --> 00:17:51,720
I will be quite delighted for to have

00:17:29,010 --> 00:17:54,480
more contribution okay the question is

00:17:51,720 --> 00:17:56,790
when you write Cindy you write simply

00:17:54,480 --> 00:17:58,590
usually for a specific architecture and

00:17:56,790 --> 00:18:02,130
you repeat the exercise for every

00:17:58,590 --> 00:18:06,419
architecture what Russ provide that help

00:18:02,130 --> 00:18:08,820
us in this regard say currently there is

00:18:06,419 --> 00:18:12,299
a crate that is called faster that is

00:18:08,820 --> 00:18:14,910
leveraging the fact that the brass

00:18:12,299 --> 00:18:18,809
compiler itself can be made aware of

00:18:14,910 --> 00:18:22,230
simply types and you can write automatic

00:18:18,809 --> 00:18:27,360
code so you can write iterators instead

00:18:22,230 --> 00:18:30,510
of doing loops and automatically up to a

00:18:27,360 --> 00:18:35,669
point and the faster crate tries to

00:18:30,510 --> 00:18:37,950
abstract more let you do some sim D that

00:18:35,669 --> 00:18:41,190
is generic enough so it's going to work

00:18:37,950 --> 00:18:44,850
on x86 doesn't matter which is your

00:18:41,190 --> 00:18:48,740
specific target and arm possibly soon

00:18:44,850 --> 00:18:48,740
PowerPC but not yet

00:18:51,770 --> 00:18:58,790
brass is as portable as LLVM provides

00:18:56,360 --> 00:19:00,800
that means that you can write a rest

00:18:58,790 --> 00:19:10,810
code and it's going to work pretty much

00:19:00,800 --> 00:19:14,360
on our mips x86 PowerPC race five other

00:19:10,810 --> 00:19:27,490
some other platform that are little

00:19:14,360 --> 00:19:31,360
stranger yes the output is not a concern

00:19:27,490 --> 00:19:35,240
your question is what about the output

00:19:31,360 --> 00:19:38,780
well the output is not exactly a concern

00:19:35,240 --> 00:19:42,040
for the toolkit usually what you have as

00:19:38,780 --> 00:19:46,550
output nowadays is some kind of OpenGL

00:19:42,040 --> 00:19:51,320
Vulcan open CV surface that you feel

00:19:46,550 --> 00:19:53,930
somehow but usually that part is a

00:19:51,320 --> 00:19:59,140
different problem that is more related

00:19:53,930 --> 00:20:02,480
to the GPU and graphics programming that

00:19:59,140 --> 00:20:04,190
multimedia once you got your buffer you

00:20:02,480 --> 00:20:07,010
want to convert it to something that you

00:20:04,190 --> 00:20:10,370
can put on the screen and usually that

00:20:07,010 --> 00:20:15,770
means that you just move to a different

00:20:10,370 --> 00:20:18,380
field OpenCL OpenGL Vulcan and then

00:20:15,770 --> 00:20:21,170
that's another ratio for the audience is

00:20:18,380 --> 00:20:26,170
the same you have many many different

00:20:21,170 --> 00:20:26,170
API to just directly output

00:20:35,029 --> 00:20:41,519
yes usually what you do right now is

00:20:38,159 --> 00:20:44,370
trying to if possible have the hardware

00:20:41,519 --> 00:20:46,370
do most of the work that means that your

00:20:44,370 --> 00:20:50,490
multimedia framework is supposed to be

00:20:46,370 --> 00:20:53,850
good with the format then once you get

00:20:50,490 --> 00:20:56,639
the data usually you end up formatting

00:20:53,850 --> 00:21:01,580
it so it can be fit to the hardware

00:20:56,639 --> 00:21:05,369
pipeline you know probably nvidia AMD

00:21:01,580 --> 00:21:09,809
inter they all provide a open source

00:21:05,369 --> 00:21:14,970
friendly sdk to leverage that so that

00:21:09,809 --> 00:21:18,149
part is part of the roadmap 0.3 is going

00:21:14,970 --> 00:21:20,029
to get there but first i wanted to prove

00:21:18,149 --> 00:21:23,399
that you can route use rostov write

00:21:20,029 --> 00:21:25,200
software decoders the hardware

00:21:23,399 --> 00:21:27,749
acceleration is part of the equation and

00:21:25,200 --> 00:21:30,149
will be implemented and obviously Russ

00:21:27,749 --> 00:21:32,190
is going to help you because then you

00:21:30,149 --> 00:21:35,419
don't have many problem in dealing with

00:21:32,190 --> 00:21:37,470
the hardware buffers since that's

00:21:35,419 --> 00:21:39,570
usually an issue since they are your

00:21:37,470 --> 00:21:42,720
buffer has to be properly reference

00:21:39,570 --> 00:21:46,649
counted and sometimes your API and SDK

00:21:42,720 --> 00:22:03,119
API and reality could not perfectly

00:21:46,649 --> 00:22:05,129
match other question okay your question

00:22:03,119 --> 00:22:08,269
is if you want to contribute

00:22:05,129 --> 00:22:14,869
do you have an easy task to get your

00:22:08,269 --> 00:22:18,929
well fit wet yes we have few right now

00:22:14,869 --> 00:22:22,740
the code base is quite lean so we don't

00:22:18,929 --> 00:22:26,100
have many real issue or many tasks but

00:22:22,740 --> 00:22:27,809
we have a couple some are sort of easy

00:22:26,100 --> 00:22:31,740
if you have experience in writing

00:22:27,809 --> 00:22:32,399
bindings since that's one of the easiest

00:22:31,740 --> 00:22:35,369
part

00:22:32,399 --> 00:22:38,129
you write binding to the C library that

00:22:35,369 --> 00:22:41,039
is a reference implementation and you

00:22:38,129 --> 00:22:44,850
prepare the wrappers so you can expose

00:22:41,039 --> 00:23:01,110
it from recipie that is the kind of easy

00:22:44,850 --> 00:23:04,580
tasks that currently we have currently

00:23:01,110 --> 00:23:08,130
we don't have any fit your question is

00:23:04,580 --> 00:23:11,460
how much of it is unsafe wrath and much

00:23:08,130 --> 00:23:14,220
of it is safe wrath currently is almost

00:23:11,460 --> 00:23:20,310
everything safe wrath beside when you

00:23:14,220 --> 00:23:23,730
try to read bits because then you have

00:23:20,310 --> 00:23:25,650
some data type and you want to convert

00:23:23,730 --> 00:23:29,750
it so to another data types and that

00:23:25,650 --> 00:23:29,750
operation is inherently unsafe

00:23:33,610 --> 00:23:41,810

YouTube URL: https://www.youtube.com/watch?v=lBFdr85PgW8


