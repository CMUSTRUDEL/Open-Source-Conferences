Title: Frank Rehberger - Rust - embedding WebAssembly for scripting
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	WebAssembly in non-Javascript environments

Rust is associated with performance, memory safety and control of memory usage. Embedding dynamic runtimes such as for Lua or Javascript for dynamic scripting within the Rust-App would introduce an huge overhead. A WebAssembly-engine seems to be a good choice as compact and portable runtime environment. JIT-compiler may be used in future to transform WASM files to native code.

The talk will present WebAssembly technology and the benefits and pitfalls integrating it into a Rust-app. Small routines are implemented in C++/Rust and compiled to Wasm. The Rust-App is loading the wasm-code as plugin at runtime to execute dynamic tasks.

Frank is Software Consultant with the focus onto back ends, messaging, security, automotive, embedded and CI. Already having experience with various programming languages in small and large development projects, Frank is enthusiastic about the combination of features of the programming language of Rust. Hands-on projects permit the evaluation of these features.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_embedding_wasm/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:05,090 --> 00:00:13,639
still here okay

00:00:16,490 --> 00:00:23,490
okay so welcome to everybody my name is

00:00:21,480 --> 00:00:26,010
Frank Rebecca so I'm living in Berlin

00:00:23,490 --> 00:00:29,779
I'm software consultant and some time

00:00:26,010 --> 00:00:32,820
ago I got attracted by rust and you

00:00:29,779 --> 00:00:35,550
assume everybody here knows rust or just

00:00:32,820 --> 00:00:38,070
to repeat it so its key features are

00:00:35,550 --> 00:00:41,070
support for concurrency memory safety

00:00:38,070 --> 00:00:44,190
performance and especially memory

00:00:41,070 --> 00:00:47,100
management deterministic management of

00:00:44,190 --> 00:00:50,640
resources there is no garbage collector

00:00:47,100 --> 00:00:53,550
built in which is a very important

00:00:50,640 --> 00:00:56,160
feature its favor stack allocation no

00:00:53,550 --> 00:01:00,210
implicit boxing so there is no hidden

00:00:56,160 --> 00:01:03,719
location of heap memory and causing

00:01:00,210 --> 00:01:07,890
delays in processing so and I asked

00:01:03,719 --> 00:01:10,649
myself so if we want to or did you ask

00:01:07,890 --> 00:01:13,460
yourself did you ever ask if I've got

00:01:10,649 --> 00:01:17,070
such a cool system how could I integrate

00:01:13,460 --> 00:01:19,619
customizable features that are performed

00:01:17,070 --> 00:01:22,229
some scripting and so allowing me to

00:01:19,619 --> 00:01:25,220
change behavior during runtime without

00:01:22,229 --> 00:01:29,340
restarts without reprogramming so and I

00:01:25,220 --> 00:01:33,150
I thought about a small message broker

00:01:29,340 --> 00:01:34,710
which should be customizable so we would

00:01:33,150 --> 00:01:36,720
need byte level manipulation

00:01:34,710 --> 00:01:38,670
deterministic management of resources of

00:01:36,720 --> 00:01:41,820
course because we don't want to get a

00:01:38,670 --> 00:01:43,950
step back back to the system so if I

00:01:41,820 --> 00:01:45,750
want to if I want to have for heap

00:01:43,950 --> 00:01:48,689
allocation I could you use Java whatever

00:01:45,750 --> 00:01:50,880
or JavaScript from the beginning and

00:01:48,689 --> 00:01:53,549
implement everything in JavaScript so

00:01:50,880 --> 00:01:56,310
this is a very important feature for me

00:01:53,549 --> 00:02:00,600
small footprint security safety and

00:01:56,310 --> 00:02:04,610
customizable and so I had to look around

00:02:00,600 --> 00:02:08,070
so what's available what could I use and

00:02:04,610 --> 00:02:11,760
so I had a look at Lua Python and

00:02:08,070 --> 00:02:16,350
JavaScript as interpreters and there is

00:02:11,760 --> 00:02:18,540
always a high complexity dynamic heap

00:02:16,350 --> 00:02:22,230
allocation it's always involved so we

00:02:18,540 --> 00:02:24,840
can't get a get out of it there's an

00:02:22,230 --> 00:02:28,050
execution overhead and similar with

00:02:24,840 --> 00:02:29,190
JavaScript to the age so there is even a

00:02:28,050 --> 00:02:31,530
more higher complete

00:02:29,190 --> 00:02:35,790
city because it's everything

00:02:31,530 --> 00:02:39,690
during start-up and then the the benefit

00:02:35,790 --> 00:02:43,890
is there was a lower lower overhead

00:02:39,690 --> 00:02:46,650
execution overhead during runtime but

00:02:43,890 --> 00:02:48,720
none of these really allow me to do the

00:02:46,650 --> 00:02:51,210
domestic resource management they all

00:02:48,720 --> 00:02:53,880
kick in they all bring in a garbage

00:02:51,210 --> 00:02:56,550
collector and in fact they destroy the

00:02:53,880 --> 00:03:01,410
benefits of the rust environment or the

00:02:56,550 --> 00:03:04,890
application executing this this

00:03:01,410 --> 00:03:07,560
execution engine and so I had a look

00:03:04,890 --> 00:03:08,490
finally at forth and I stumbled across

00:03:07,560 --> 00:03:14,550
webassembly

00:03:08,490 --> 00:03:18,930
and which is very low level has low

00:03:14,550 --> 00:03:22,560
overhead or almost no overhead and the

00:03:18,930 --> 00:03:25,920
difference is that the other concepts

00:03:22,560 --> 00:03:29,190
they always incorporate a full powers

00:03:25,920 --> 00:03:32,250
are pausing abstract syntax tree

00:03:29,190 --> 00:03:34,200
optimizing the code getting intermediate

00:03:32,250 --> 00:03:37,470
representation and then if it's treated

00:03:34,200 --> 00:03:40,620
getting some execution code but still

00:03:37,470 --> 00:03:42,030
JavaScript still is based so it's not it

00:03:40,620 --> 00:03:44,640
doesn't favor stack allocation

00:03:42,030 --> 00:03:47,760
javascript favors heap allocation so we

00:03:44,640 --> 00:03:50,040
always end up with a system allocating a

00:03:47,760 --> 00:03:55,489
lot of memory and I don't want this so

00:03:50,040 --> 00:04:01,019
that was my main red line so and so

00:03:55,489 --> 00:04:03,060
having a look at bread assembly so where

00:04:01,019 --> 00:04:07,290
does it come from and what is it

00:04:03,060 --> 00:04:12,300
intended for so weapon sembly has came

00:04:07,290 --> 00:04:14,760
up in 2015 and it's not a replacement of

00:04:12,300 --> 00:04:18,660
javascript so it's a complement of

00:04:14,760 --> 00:04:21,540
JavaScript so every time the the problem

00:04:18,660 --> 00:04:24,390
with JavaScript is that it's always heap

00:04:21,540 --> 00:04:26,490
oriented and it's doing a lot of even

00:04:24,390 --> 00:04:32,600
mathematical operations requiring

00:04:26,490 --> 00:04:37,260
refrain and keep operations and so

00:04:32,600 --> 00:04:40,500
depend the ADEA is we introduced some

00:04:37,260 --> 00:04:42,270
kind of assembly code which will call by

00:04:40,500 --> 00:04:46,590
the JavaScript to do

00:04:42,270 --> 00:04:51,210
to to speed up perform perform critical

00:04:46,590 --> 00:04:54,690
operations and so if we've got a

00:04:51,210 --> 00:04:57,750
JavaScript code and we have got the flow

00:04:54,690 --> 00:05:00,150
the flow here so there might be in

00:04:57,750 --> 00:05:03,000
operation which kicks into the web

00:05:00,150 --> 00:05:05,460
assembly code during the performance

00:05:03,000 --> 00:05:10,110
critical computation and then getting

00:05:05,460 --> 00:05:13,680
back and continuing JavaScript and so

00:05:10,110 --> 00:05:17,040
web assemblies incorporates a portable

00:05:13,680 --> 00:05:21,420
stack machine the notation is it's a

00:05:17,040 --> 00:05:25,190
binary notation and but it also provides

00:05:21,420 --> 00:05:33,420
a text text-based or a representation

00:05:25,190 --> 00:05:37,140
and you can you can use C++ or rust to

00:05:33,420 --> 00:05:39,960
create a binary code webassembly binary

00:05:37,140 --> 00:05:42,960
code which will be glued with JavaScript

00:05:39,960 --> 00:05:43,440
into an HTML page and then execute it in

00:05:42,960 --> 00:05:47,310
the browser

00:05:43,440 --> 00:05:49,800
and the idea or the question now boss

00:05:47,310 --> 00:05:52,620
would I be able to get away with

00:05:49,800 --> 00:05:54,900
JavaScript and would it be a solution

00:05:52,620 --> 00:05:57,570
just to use what assembly just to use

00:05:54,900 --> 00:06:01,470
the the execution engine here and

00:05:57,570 --> 00:06:04,470
instead of JavaScript interacting with

00:06:01,470 --> 00:06:07,470
the execution engine directly

00:06:04,470 --> 00:06:10,980
interacting from grass to to webassembly

00:06:07,470 --> 00:06:13,350
engine and getting all the benefits so

00:06:10,980 --> 00:06:16,440
it's a it's widespread so there is a

00:06:13,350 --> 00:06:20,220
community using that assembly there are

00:06:16,440 --> 00:06:22,230
good compilers I can do my compilation

00:06:20,220 --> 00:06:25,560
on a high level language compiler too

00:06:22,230 --> 00:06:31,800
but assembly and execute it in an in a

00:06:25,560 --> 00:06:36,000
small lightweight stack machine so the

00:06:31,800 --> 00:06:38,130
built so for C++ and rust web assembly

00:06:36,000 --> 00:06:40,680
is a build target so we've got the

00:06:38,130 --> 00:06:43,050
binary form a format webassembly the

00:06:40,680 --> 00:06:43,500
text representation as expressions are

00:06:43,050 --> 00:06:48,060
called

00:06:43,500 --> 00:06:53,460
ray st it what assembly supports only

00:06:48,060 --> 00:07:00,300
few scalar types guy scalar types key so

00:06:53,460 --> 00:07:03,360
integer 3264 floating 32 and floating 64

00:07:00,300 --> 00:07:06,940
and there was no support so there was no

00:07:03,360 --> 00:07:09,340
native support of unsigned integers so

00:07:06,940 --> 00:07:14,670
everything is mapped onto these onto

00:07:09,340 --> 00:07:18,940
these types the webassembly

00:07:14,670 --> 00:07:21,670
stack machine supports less than or has

00:07:18,940 --> 00:07:24,220
fewer than 256 operations or

00:07:21,670 --> 00:07:28,270
instructions so it's very compact and

00:07:24,220 --> 00:07:32,910
these operations can be met or could be

00:07:28,270 --> 00:07:36,100
mapped easily onto up-to-date

00:07:32,910 --> 00:07:41,080
architecture GPU architecture so it's

00:07:36,100 --> 00:07:43,180
sandboxed it's using linear memory so it

00:07:41,080 --> 00:07:45,940
hasn't direct access to the global

00:07:43,180 --> 00:07:50,140
memory of your application it's using

00:07:45,940 --> 00:07:53,110
tables and all their memory access every

00:07:50,140 --> 00:07:56,020
memory accesses a bond checked if we

00:07:53,110 --> 00:07:59,830
stay in the linear memory and so on so

00:07:56,020 --> 00:08:07,330
pointers are just indices into the

00:07:59,830 --> 00:08:10,170
linear memory and so when we well when

00:08:07,330 --> 00:08:13,150
we do it just in time compilation the

00:08:10,170 --> 00:08:17,670
there are it's possible to get a one

00:08:13,150 --> 00:08:17,670
point five factor of native code speed

00:08:17,820 --> 00:08:24,670
so how would it look like so we saw we

00:08:23,020 --> 00:08:29,520
have we have seen the picture before

00:08:24,670 --> 00:08:33,130
with a JavaScript and and but assembly

00:08:29,520 --> 00:08:35,620
execution engine so with rust would look

00:08:33,130 --> 00:08:39,010
like like like this one we've got the

00:08:35,620 --> 00:08:44,350
controller setting up or allocating some

00:08:39,010 --> 00:08:46,960
memory which will be assigned to the web

00:08:44,350 --> 00:08:49,960
assembly instance we've got a web

00:08:46,960 --> 00:08:52,450
assembly file which will be loaded into

00:08:49,960 --> 00:08:54,850
into the context of the rust application

00:08:52,450 --> 00:09:00,550
executable and which represents the

00:08:54,850 --> 00:09:05,380
module we have got a table where we can

00:09:00,550 --> 00:09:06,940
register callbacks which could be which

00:09:05,380 --> 00:09:10,600
these callbacks

00:09:06,940 --> 00:09:13,810
are there the functions the module has

00:09:10,600 --> 00:09:16,300
got depends on has got to import so

00:09:13,810 --> 00:09:21,010
anytime we've got an external function

00:09:16,300 --> 00:09:25,900
here and loaded as a module we have got

00:09:21,010 --> 00:09:28,270
provide a table which will provide the

00:09:25,900 --> 00:09:31,570
functionality of a function to step to

00:09:28,270 --> 00:09:35,680
call in indirect call to call this rust

00:09:31,570 --> 00:09:39,310
implementation we've got a stack machine

00:09:35,680 --> 00:09:43,500
and so this is the Box web assemblies

00:09:39,310 --> 00:09:48,370
running in and so it's quite secure

00:09:43,500 --> 00:09:53,020
execution environment so how does it

00:09:48,370 --> 00:09:56,350
look like so I tried with as a set we

00:09:53,020 --> 00:10:01,900
can use rust or C++ to create web

00:09:56,350 --> 00:10:07,840
assembly code binary code and so for

00:10:01,900 --> 00:10:12,250
example if we use rust few thrusts we

00:10:07,840 --> 00:10:14,380
declare a function and we declare some

00:10:12,250 --> 00:10:17,980
parameters in a return point a return

00:10:14,380 --> 00:10:21,430
value as you can see here this is an

00:10:17,980 --> 00:10:23,830
integer 32 and in fact this one would be

00:10:21,430 --> 00:10:27,610
a pointer into the into linear memory

00:10:23,830 --> 00:10:33,070
and this would be mapped onto an index

00:10:27,610 --> 00:10:33,640
of type integer 32 as well and I can

00:10:33,070 --> 00:10:37,360
show you later

00:10:33,640 --> 00:10:39,760
and so we would do there

00:10:37,360 --> 00:10:44,550
I would iterate over over the memory

00:10:39,760 --> 00:10:49,120
over this buffer and check for all

00:10:44,550 --> 00:10:53,430
characters e I and replace it by O so

00:10:49,120 --> 00:10:59,410
compiling this was cargo nightly I get a

00:10:53,430 --> 00:11:06,339
file transform wasn't of size 50 50 57k

00:10:59,410 --> 00:11:09,400
kilobytes and which is quite big so rust

00:11:06,339 --> 00:11:12,880
compiled into a lot of additional meter

00:11:09,400 --> 00:11:16,150
information for the panic panicking so

00:11:12,880 --> 00:11:18,430
in case there is an Fault in the

00:11:16,150 --> 00:11:20,240
application that would there's also all

00:11:18,430 --> 00:11:22,850
the the integers and Aramis

00:11:20,240 --> 00:11:27,620
is inside that are written into the

00:11:22,850 --> 00:11:29,540
console and so far I didn't manage to

00:11:27,620 --> 00:11:33,680
get this to optimize it and get rid of

00:11:29,540 --> 00:11:35,779
these strings so name mangling so the

00:11:33,680 --> 00:11:38,240
within the module the operation would be

00:11:35,779 --> 00:11:40,550
called transform that would be the

00:11:38,240 --> 00:11:43,750
method name that's important because if

00:11:40,550 --> 00:11:47,270
we look at the C++ implementation

00:11:43,750 --> 00:11:49,459
similar return type integer integer

00:11:47,270 --> 00:11:55,279
first parameter we've got a pointer to

00:11:49,459 --> 00:12:03,050
an array the same logic and so this will

00:11:55,279 --> 00:12:07,399
be compiled with with her what M script

00:12:03,050 --> 00:12:11,720
right and the result is just not is 296

00:12:07,399 --> 00:12:14,959
bytes because it doesn't contain all the

00:12:11,720 --> 00:12:18,709
error strings rust is compelling the the

00:12:14,959 --> 00:12:23,570
drawback is that the compiler is doing

00:12:18,709 --> 00:12:25,850
name mangling and the name within the

00:12:23,570 --> 00:12:28,490
module would be underlined transform but

00:12:25,850 --> 00:12:30,680
that's just so and I didn't manage to

00:12:28,490 --> 00:12:33,170
get this way so I didn't manage to get

00:12:30,680 --> 00:12:37,250
the underline away so if anybody has got

00:12:33,170 --> 00:12:41,450
a clue the binary code looks like this

00:12:37,250 --> 00:12:43,970
this jar the 296 bytes and their textual

00:12:41,450 --> 00:12:48,680
form would look like this and here you

00:12:43,970 --> 00:12:50,390
can see their first parameters this is

00:12:48,680 --> 00:12:52,459
the first parameter and this is the

00:12:50,390 --> 00:12:54,740
second parameter pointing to the

00:12:52,459 --> 00:12:59,300
location of the array within the linear

00:12:54,740 --> 00:13:01,190
memory and calling it we would just we

00:12:59,300 --> 00:13:07,550
would just we would create a linear

00:13:01,190 --> 00:13:09,620
memory place our our message byte

00:13:07,550 --> 00:13:13,610
message into the linear memory at index

00:13:09,620 --> 00:13:18,290
1 0 and then calling this function with

00:13:13,610 --> 00:13:21,740
the length of the array and 0 index 0

00:13:18,290 --> 00:13:25,670
and this way we would tell the web

00:13:21,740 --> 00:13:32,680
assembly where in the linear memory the

00:13:25,670 --> 00:13:32,680
error is located so the credits to this

00:13:32,910 --> 00:13:39,060
they well based no this is the

00:13:36,089 --> 00:13:41,100
implementation prototype at it is based

00:13:39,060 --> 00:13:45,029
on rep assembly interpreter done by Nick

00:13:41,100 --> 00:13:48,029
Worf formerly at parity wasn't github

00:13:45,029 --> 00:13:50,399
and this one has been renamed now to

00:13:48,029 --> 00:13:53,040
bottom interpreter

00:13:50,399 --> 00:13:56,399
Alex Christian for Tokyo IO and Karl

00:13:53,040 --> 00:14:01,380
Asia for me oh these are the three

00:13:56,399 --> 00:14:09,630
important modules my prototypes based on

00:14:01,380 --> 00:14:13,410
just as a proof of concept so I've got

00:14:09,630 --> 00:14:17,639
their the code here and as you could see

00:14:13,410 --> 00:14:20,850
here can you read it this one is the the

00:14:17,639 --> 00:14:26,120
method I declare this is the file I'm

00:14:20,850 --> 00:14:35,959
loading then I declare environment very

00:14:26,120 --> 00:14:40,019
environment object here and then I

00:14:35,959 --> 00:14:41,490
create the memory linear memory this one

00:14:40,019 --> 00:14:43,380
is the place where the buffer the

00:14:41,490 --> 00:14:49,199
message buffer is placed into the linear

00:14:43,380 --> 00:14:57,350
memory and then this execution is

00:14:49,199 --> 00:14:57,350
performed these are the parameters

00:15:00,790 --> 00:15:06,459
and here is the invoke export that I

00:15:04,360 --> 00:15:09,399
invoke an exported operation of the

00:15:06,459 --> 00:15:16,440
module and I get a return value and then

00:15:09,399 --> 00:15:20,589
I've got to evaluate the return value so

00:15:16,440 --> 00:15:26,680
ten minutes left okay I've got a small

00:15:20,589 --> 00:15:31,420
showcase so I'm starting I'm starting

00:15:26,680 --> 00:15:34,269
the application so it's listening at the

00:15:31,420 --> 00:15:45,209
udp-based application listening for UDP

00:15:34,269 --> 00:15:49,690
packets so I've got this client and and

00:15:45,209 --> 00:15:51,970
if I send a hello e it responds so it

00:15:49,690 --> 00:15:55,389
receives the message it's processed by

00:15:51,970 --> 00:15:58,870
web assembly replacing all the I's bios

00:15:55,389 --> 00:16:03,970
and sending back the message just to

00:15:58,870 --> 00:16:08,829
demonstrate so so it works even with

00:16:03,970 --> 00:16:16,300
longer strings and that's it so what I

00:16:08,829 --> 00:16:20,699
can do now is I can change so all I

00:16:16,300 --> 00:16:20,699
shall be replaced by wise

00:16:23,190 --> 00:16:41,280
and I I reckon filed the bottom and now

00:16:38,560 --> 00:16:41,280
when I sent

00:16:43,459 --> 00:16:56,399
so I get a why Hey hooray it works so so

00:16:54,209 --> 00:16:58,230
I did not check for performance I did

00:16:56,399 --> 00:17:00,240
not so it's it's a proof of concept so

00:16:58,230 --> 00:17:02,279
every time every message it loads the

00:17:00,240 --> 00:17:05,640
the wasn't file okay

00:17:02,279 --> 00:17:08,280
creating the assembly instance the

00:17:05,640 --> 00:17:09,990
module instance executing it and then

00:17:08,280 --> 00:17:14,809
throwing it away so don't ask me about

00:17:09,990 --> 00:17:18,360
performance so and another aspect is

00:17:14,809 --> 00:17:21,750
it's it's interpreted so the bottom eye

00:17:18,360 --> 00:17:24,809
is interpreting webassembly so there is

00:17:21,750 --> 00:17:28,290
the would be possible to create some

00:17:24,809 --> 00:17:30,140
kind of JIT compiler compiling the

00:17:28,290 --> 00:17:32,540
module directly to native code and

00:17:30,140 --> 00:17:35,270
probably there would be much faster now

00:17:32,540 --> 00:17:38,850
but that would be the next step and

00:17:35,270 --> 00:17:43,020
maybe I could make use of existing

00:17:38,850 --> 00:17:46,820
modules for for Mozilla Firefox or other

00:17:43,020 --> 00:17:51,600
web browsers and just reusing those

00:17:46,820 --> 00:17:54,080
webassembly execution engines okay are

00:17:51,600 --> 00:17:54,080
there any questions

00:18:12,280 --> 00:18:20,420
this interpreter

00:18:14,570 --> 00:18:23,210
well the question is the question is how

00:18:20,420 --> 00:18:30,230
much code does it require to create a

00:18:23,210 --> 00:18:35,210
web assembly interpreter I've know I

00:18:30,230 --> 00:18:43,490
can't tell you number of lines but it's

00:18:35,210 --> 00:18:45,220
a small project at github and so yeah I

00:18:43,490 --> 00:18:51,110
can't I can't answer the question so

00:18:45,220 --> 00:18:55,070
sorry it's more it's a small it's a

00:18:51,110 --> 00:19:03,790
small module and when I strip this

00:18:55,070 --> 00:19:03,790
application which is not ideal stripped

00:19:11,270 --> 00:19:26,500
so so this is so it's 800 K so the

00:19:22,010 --> 00:19:30,980
application containing all the Tokyo

00:19:26,500 --> 00:19:33,220
logic as inference IO and the and the

00:19:30,980 --> 00:19:38,660
interpreter book wasn't interpreter is

00:19:33,220 --> 00:19:41,870
800 K statically linked against the

00:19:38,660 --> 00:19:45,490
local libraries so that's not much and

00:19:41,870 --> 00:19:45,490
probably could be even reduced

00:19:46,900 --> 00:19:50,260
yes please

00:20:00,260 --> 00:20:07,520
yes you can the question is is it

00:20:03,480 --> 00:20:09,990
possible to declare - - to access

00:20:07,520 --> 00:20:14,330
functions in the rust environment from

00:20:09,990 --> 00:20:21,900
the web assembly yes there is a good

00:20:14,330 --> 00:20:28,400
there is this one this is the callback

00:20:21,900 --> 00:20:32,760
table for or the table this table here

00:20:28,400 --> 00:20:37,290
this contains so you you define in your

00:20:32,760 --> 00:20:39,480
C++ code or US code you define a

00:20:37,290 --> 00:20:42,450
signature of a method and which is

00:20:39,480 --> 00:20:44,100
external you use it in your code you

00:20:42,450 --> 00:20:46,410
call it in your code the compiler will

00:20:44,100 --> 00:20:49,890
realize how it's an external external

00:20:46,410 --> 00:20:51,840
function and it will be declared as

00:20:49,890 --> 00:20:55,550
external function here which needs to be

00:20:51,840 --> 00:20:59,160
imported and these functions are

00:20:55,550 --> 00:21:01,170
accessed using the table so when you

00:20:59,160 --> 00:21:05,940
when you load there wasn't filed module

00:21:01,170 --> 00:21:08,730
and resolve all the dependencies it will

00:21:05,940 --> 00:21:12,240
check for the existence of specific

00:21:08,730 --> 00:21:14,370
functions and so it will call the

00:21:12,240 --> 00:21:19,700
function which is registered here and

00:21:14,370 --> 00:21:19,700
call a call in here yes

00:21:27,850 --> 00:21:42,309
I don't know well it's a question if if

00:21:33,100 --> 00:21:45,460
we can stack up so I would I I didn't I

00:21:42,309 --> 00:21:49,360
didn't try this but I don't see I don't

00:21:45,460 --> 00:21:51,669
see why this shouldn't be possible so it

00:21:49,360 --> 00:21:53,200
might be well I don't know how well I've

00:21:51,669 --> 00:21:57,879
got to check the the web assembly

00:21:53,200 --> 00:22:00,669
interpreter how this the the calling the

00:21:57,879 --> 00:22:02,799
exported function if there is an a

00:22:00,669 --> 00:22:05,740
restriction that there should be only

00:22:02,799 --> 00:22:08,350
one call to an exported function at any

00:22:05,740 --> 00:22:27,190
time I don't know so good question I

00:22:08,350 --> 00:22:29,139
didn't I didn't check this that's so

00:22:27,190 --> 00:22:32,769
right now

00:22:29,139 --> 00:22:34,119
strings are problem because strings so

00:22:32,769 --> 00:22:36,490
if we talk about web assembly

00:22:34,119 --> 00:22:40,840
webassembly is something which has been

00:22:36,490 --> 00:22:43,149
established in a JavaScript world and so

00:22:40,840 --> 00:22:46,419
javascript strings look different to

00:22:43,149 --> 00:22:55,149
rust strings but there is some there is

00:22:46,419 --> 00:22:58,299
a there are what is it there are some

00:22:55,149 --> 00:22:59,999
people are working right to get some

00:22:58,299 --> 00:23:03,190
kind of together it's kind of standard

00:22:59,999 --> 00:23:07,090
to access strings so the idea is to use

00:23:03,190 --> 00:23:08,860
to register strings in here so if let's

00:23:07,090 --> 00:23:10,779
assume we've got a function we want to

00:23:08,860 --> 00:23:13,179
call the function and hand over a string

00:23:10,779 --> 00:23:15,850
so the string could be would be

00:23:13,179 --> 00:23:18,820
registered here and the state machine or

00:23:15,850 --> 00:23:21,399
the module could verify what kind of

00:23:18,820 --> 00:23:23,799
string is it and then performing the

00:23:21,399 --> 00:23:25,899
correct interpretation of the string so

00:23:23,799 --> 00:23:28,029
it could be 0 terminated string it could

00:23:25,899 --> 00:23:31,629
be a length and coded string it could be

00:23:28,029 --> 00:23:34,149
whatever string so so that that's the

00:23:31,629 --> 00:23:34,570
problem some people are using the linear

00:23:34,149 --> 00:23:36,730
memory

00:23:34,570 --> 00:23:39,430
more effect more or less they serialize

00:23:36,730 --> 00:23:42,070
the data into the zero into linear

00:23:39,430 --> 00:23:44,740
memory and then call the sec machine so

00:23:42,070 --> 00:23:48,160
right now a stack machine should be so

00:23:44,740 --> 00:23:52,240
if you define a boundary between rust

00:23:48,160 --> 00:23:54,460
and represent me you should use the the

00:23:52,240 --> 00:23:56,740
boundary where you deal with binary data

00:23:54,460 --> 00:23:59,620
for example if you receive a message

00:23:56,740 --> 00:24:04,480
from the network and you want to process

00:23:59,620 --> 00:24:06,130
it that would be easy to to put into the

00:24:04,480 --> 00:24:08,980
linear memory and then process it using

00:24:06,130 --> 00:24:11,980
web assembly if you've got a complex Dom

00:24:08,980 --> 00:24:15,990
tree internally that's not a good idea

00:24:11,980 --> 00:24:19,780
so but people are working on this and

00:24:15,990 --> 00:24:22,570
JavaScript the JavaScript community is

00:24:19,780 --> 00:24:25,240
working on this too so getting Dom trees

00:24:22,570 --> 00:24:28,210
handed over to the web assembly engine

00:24:25,240 --> 00:24:31,270
and we've got to check how we would be

00:24:28,210 --> 00:24:35,530
able from rust to do the same but we

00:24:31,270 --> 00:24:38,110
always have got to - first of all it's a

00:24:35,530 --> 00:24:40,360
it's a JavaScript standard or web

00:24:38,110 --> 00:24:43,090
standard it's not defined by the rest

00:24:40,360 --> 00:24:45,250
community so we are we are always second

00:24:43,090 --> 00:24:48,010
and we have got to check out how we

00:24:45,250 --> 00:24:59,880
could incorporate our using the

00:24:48,010 --> 00:24:59,880

YouTube URL: https://www.youtube.com/watch?v=EmoaYQ4MpC0


