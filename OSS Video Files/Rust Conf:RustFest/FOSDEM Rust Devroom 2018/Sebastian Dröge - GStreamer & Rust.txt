Title: Sebastian Dröge - GStreamer & Rust
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	Fast, safe and productive multimedia software

GStreamer is a highly versatile, cross-platform, plugin-based multimedia framework that caters to the whole range of multimedia needs. It can be used basically everywhere, from embedded devices like phones, TVs or drones to desktop applications or on huge server farms.

This talk will focus on how and why Rust looks like the perfect programming language for evolving GStreamer and provide a safer but still performant and even more productive development environment than C. Both GStreamer application development in Rust, and GStreamer plugin development will be covered. What is possible today already, for which applications can Rust be perfectly used already and which parts are still missing? How does it feel like to write an application in Rust compared to doing it in C? And how and why would one write GStreamer plugins in Rust to extend the framework and all applications with support for new codecs, filters or anything else?

Afterwards there will be a short outlook into the future of Rust in the GStreamer project itself and for GStreamer application and plugin development.

Sebastian Dröge (slomo) is a Free Software developer and one of the GStreamer maintainers and core developers. He has been involved with the project since more than 10 years now. He also contributes to various other Free Software projects, like Debian, Rust, GNOME and WebKit. While finishing his master's degree in computer sciences at the University of Paderborn in Germany, he started working as a contractor for GStreamer and related technologies. Sebastian is one of the founders of Centricular, a company providing consultancy services, where he's working from his new home in Greece on improving GStreamer and the Free Software ecosystem in general.

Apart from multimedia related topics, Sebastian has an interest in digital signal processing, programming languages, machine learning, network protocols and distributed systems.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_gstreamer/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:04,630 --> 00:00:09,620
so the next speaker is Sebastian

00:00:07,550 --> 00:00:12,230
interview and he will be talking about

00:00:09,620 --> 00:00:15,190
gstreamer and rest or how to be both

00:00:12,230 --> 00:00:15,190
safe and productive

00:00:20,460 --> 00:00:26,440
thank you good morning and so today I'm

00:00:24,490 --> 00:00:29,530
going to talk about well as I said keys

00:00:26,440 --> 00:00:32,169
to mind rust but first of all when when

00:00:29,530 --> 00:00:36,270
who I first of all I will tell you who I

00:00:32,169 --> 00:00:42,190
am so I'm just my developer since about

00:00:36,270 --> 00:00:43,180
2006 long long time now and yeah I can

00:00:42,190 --> 00:00:45,940
try

00:00:43,180 --> 00:00:47,920
so I'm a just my developer since 2006

00:00:45,940 --> 00:00:50,949
which is quite a long time now I

00:00:47,920 --> 00:00:52,600
probably touched every piece of code

00:00:50,949 --> 00:00:56,500
over the last years I mean doing

00:00:52,600 --> 00:00:57,730
currently the releases and I'm one of

00:00:56,500 --> 00:01:01,000
the founders of centric Euler

00:00:57,730 --> 00:01:02,769
consultancy a company providing services

00:01:01,000 --> 00:01:07,480
around GStreamer and related software

00:01:02,769 --> 00:01:10,750
and since about 2014-2015 I started

00:01:07,480 --> 00:01:13,590
experimenting with rust and also with

00:01:10,750 --> 00:01:15,790
how we can use rust for gstreamer and

00:01:13,590 --> 00:01:18,280
that's exactly what we are going to talk

00:01:15,790 --> 00:01:21,340
about today in the beginning I will

00:01:18,280 --> 00:01:23,729
introduce what gstreamer is many of you

00:01:21,340 --> 00:01:26,710
probably don't know that then talk about

00:01:23,729 --> 00:01:30,610
why rust is a perfect fit for

00:01:26,710 --> 00:01:34,240
gstreamer well I will explain a bit what

00:01:30,610 --> 00:01:36,789
you can do nowadays what that what kind

00:01:34,240 --> 00:01:40,210
of projects using GCM are you can write

00:01:36,789 --> 00:01:43,600
in rust and give some kind of outlook

00:01:40,210 --> 00:01:45,159
into the mirror and Farah future and in

00:01:43,600 --> 00:01:47,289
the very end

00:01:45,159 --> 00:01:51,240
something personal a bit my experience

00:01:47,289 --> 00:01:54,609
with rust for doing all of this and

00:01:51,240 --> 00:01:57,250
maybe this also gives others some idea

00:01:54,609 --> 00:01:59,820
how how it is to work with rust for this

00:01:57,250 --> 00:02:03,159
kind of projects so what is to streamer

00:01:59,820 --> 00:02:05,289
I will only give a very very high-level

00:02:03,159 --> 00:02:08,679
short introduction if you want to see

00:02:05,289 --> 00:02:09,970
details go to the website there's lots

00:02:08,679 --> 00:02:13,330
of documentation that you can read

00:02:09,970 --> 00:02:15,100
probably more than you want to read but

00:02:13,330 --> 00:02:17,560
from a very very high level what you

00:02:15,100 --> 00:02:20,380
steam is is it's a pipeline based

00:02:17,560 --> 00:02:22,390
cross-platform multimedia framework it's

00:02:20,380 --> 00:02:26,409
completely open source free software

00:02:22,390 --> 00:02:29,680
it's a GPL license and there's no big

00:02:26,409 --> 00:02:32,200
company behind it there are lots of

00:02:29,680 --> 00:02:36,010
but lots of bigger and smaller companies

00:02:32,200 --> 00:02:38,049
that arrive driving it but most most of

00:02:36,010 --> 00:02:41,650
the development is really something that

00:02:38,049 --> 00:02:45,700
is community driven it's quite widely

00:02:41,650 --> 00:02:48,430
used nowadays also commercially you can

00:02:45,700 --> 00:02:50,889
find many applications using it TVs

00:02:48,430 --> 00:02:55,269
drones cameras all kinds of things in

00:02:50,889 --> 00:02:57,730
the cloud and it's running on Linux

00:02:55,269 --> 00:02:59,680
Android iOS Mac OS Windows basically

00:02:57,730 --> 00:03:04,109
everywhere where you have some kind of C

00:02:59,680 --> 00:03:07,269
compiler and a standard c library and

00:03:04,109 --> 00:03:11,109
it's not at this point used only for

00:03:07,269 --> 00:03:13,239
multimedia related things there are also

00:03:11,109 --> 00:03:15,340
people using it for other stuff for

00:03:13,239 --> 00:03:17,530
example the legal project that was

00:03:15,340 --> 00:03:18,819
detecting the gravitational waves they

00:03:17,530 --> 00:03:20,590
are using GStreamer for their data

00:03:18,819 --> 00:03:22,030
processing and that that doesn't have

00:03:20,590 --> 00:03:26,379
anything to do with multimedia at all

00:03:22,030 --> 00:03:28,659
anymore at that point so on I said do

00:03:26,379 --> 00:03:31,870
Simha is pipeline based what does that

00:03:28,659 --> 00:03:33,579
mean so in G stream are the basic

00:03:31,870 --> 00:03:37,919
components that you have are so-called

00:03:33,579 --> 00:03:40,690
elements there's something that that are

00:03:37,919 --> 00:03:43,000
processing media data or data in general

00:03:40,690 --> 00:03:46,000
and you connect them to other so-called

00:03:43,000 --> 00:03:48,489
elements and each of these elements in

00:03:46,000 --> 00:03:50,949
the end is doing one little task so for

00:03:48,489 --> 00:03:53,500
example what we have here is a very

00:03:50,949 --> 00:03:56,109
small pipeline that is they could be

00:03:53,500 --> 00:03:57,939
used for playing a video file so you

00:03:56,109 --> 00:04:00,939
have one element that is just reading

00:03:57,939 --> 00:04:02,859
from a file in this case another element

00:04:00,939 --> 00:04:04,930
that is splitting the file into the

00:04:02,859 --> 00:04:06,849
audio and video parts then you have

00:04:04,930 --> 00:04:08,859
decoders for the audio and video and in

00:04:06,849 --> 00:04:12,819
the end it goes to the speaker or the

00:04:08,859 --> 00:04:15,099
screen and well this is a playback

00:04:12,819 --> 00:04:17,349
example but you could also imagine that

00:04:15,099 --> 00:04:19,180
in the beginning you have an element

00:04:17,349 --> 00:04:21,870
that is outputting the video from your

00:04:19,180 --> 00:04:24,370
camera and the audio from your

00:04:21,870 --> 00:04:26,139
microphone while you are on could happen

00:04:24,370 --> 00:04:28,630
input that somehow reads over the

00:04:26,139 --> 00:04:30,220
network you could send data out over the

00:04:28,630 --> 00:04:31,780
network in the end each of these

00:04:30,220 --> 00:04:35,070
elements they could do anything they

00:04:31,780 --> 00:04:37,620
would like to do with the data and

00:04:35,070 --> 00:04:40,029
you're taking all these little

00:04:37,620 --> 00:04:43,510
components put them together build

00:04:40,029 --> 00:04:44,800
bigger components out of them

00:04:43,510 --> 00:04:47,290
and in the end you have something like

00:04:44,800 --> 00:04:49,990
Lego and you can build anything you

00:04:47,290 --> 00:04:53,770
would like to out of this out of small

00:04:49,990 --> 00:04:56,560
little components and but in this

00:04:53,770 --> 00:04:58,900
picture it all looks quite static but if

00:04:56,560 --> 00:05:00,460
you're actually writing code doing these

00:04:58,900 --> 00:05:03,040
things you could also change the

00:05:00,460 --> 00:05:05,200
topology of the pipeline graph at any

00:05:03,040 --> 00:05:08,920
point in time if you want to or if you

00:05:05,200 --> 00:05:10,690
need and the general philosophy of G

00:05:08,920 --> 00:05:13,030
streamers that we provide some kind of

00:05:10,690 --> 00:05:15,400
tool box for higher level and multimedia

00:05:13,030 --> 00:05:17,050
processing it's not a finished solution

00:05:15,400 --> 00:05:19,360
for anything but it's something that

00:05:17,050 --> 00:05:23,200
allows you to build solutions for

00:05:19,360 --> 00:05:26,020
anything you would like to do and the

00:05:23,200 --> 00:05:28,540
the basis is that we have some kind of

00:05:26,020 --> 00:05:31,000
flexible extensible design that is based

00:05:28,540 --> 00:05:33,340
on simple ideas like what we saw before

00:05:31,000 --> 00:05:36,400
with the pipelines it's a very generic

00:05:33,340 --> 00:05:39,280
API the Koji's from api does not know

00:05:36,400 --> 00:05:40,630
anything about multimedia it doesn't

00:05:39,280 --> 00:05:43,180
know anything about video or audio

00:05:40,630 --> 00:05:45,790
that's something that is added in other

00:05:43,180 --> 00:05:48,130
components and the main focus is on

00:05:45,790 --> 00:05:51,400
making it very easy to embed

00:05:48,130 --> 00:05:53,560
gstreamer into other things in both

00:05:51,400 --> 00:05:55,390
directions to make it easy to embed

00:05:53,560 --> 00:05:58,120
gstreamer in applications in other

00:05:55,390 --> 00:06:00,430
frameworks like cute or WebKit they are

00:05:58,120 --> 00:06:02,680
for example able to use free streamer

00:06:00,430 --> 00:06:05,050
for their multimedia needs but also on

00:06:02,680 --> 00:06:07,140
the other side to make it easy to embed

00:06:05,050 --> 00:06:10,390
existing multimedia solutions

00:06:07,140 --> 00:06:13,240
introducing Malaika ffmpeg OpenCV we're

00:06:10,390 --> 00:06:15,730
not redeveloping the world we try to

00:06:13,240 --> 00:06:19,240
make use of whatever is out there

00:06:15,730 --> 00:06:21,130
already and the target systems are

00:06:19,240 --> 00:06:24,370
everything from embedded systems of

00:06:21,130 --> 00:06:25,990
words and a search this might serve

00:06:24,370 --> 00:06:26,350
doesn't know anything about audio and

00:06:25,990 --> 00:06:29,550
video

00:06:26,350 --> 00:06:31,540
everything is added via plugins and we

00:06:29,550 --> 00:06:33,400
will have some kind of batteries

00:06:31,540 --> 00:06:35,410
included philosophy here and there are

00:06:33,400 --> 00:06:39,460
more than 250 plugins provided by

00:06:35,410 --> 00:06:41,620
gstreamer if you just get the source

00:06:39,460 --> 00:06:43,030
code and build it and they're also

00:06:41,620 --> 00:06:45,940
plugins that are reusing existing

00:06:43,030 --> 00:06:49,030
libraries like ffmpeg OpenCV and what I

00:06:45,940 --> 00:06:52,210
mentioned before and in addition are

00:06:49,030 --> 00:06:54,880
plugins that allow you to use things

00:06:52,210 --> 00:06:57,250
like me on your embedded device the

00:06:54,880 --> 00:07:00,160
hardware codex or

00:06:57,250 --> 00:07:02,440
to use cameras and stuff like that

00:07:00,160 --> 00:07:04,120
the other thing yes system itself is

00:07:02,440 --> 00:07:07,690
completely written in C at this point

00:07:04,120 --> 00:07:10,270
but nobody wants to write C and so on we

00:07:07,690 --> 00:07:13,110
provide bindings for many other

00:07:10,270 --> 00:07:16,270
languages like Python c-sharp c++ java

00:07:13,110 --> 00:07:16,660
gaudi and also rust i wouldn't be here

00:07:16,270 --> 00:07:24,190
otherwise

00:07:16,660 --> 00:07:25,780
and yeah so what is my snot it's not a

00:07:24,190 --> 00:07:27,520
media player or playback library it's

00:07:25,780 --> 00:07:29,080
not a codec or protocol library or not a

00:07:27,520 --> 00:07:31,210
transcoding tool or not a streaming

00:07:29,080 --> 00:07:33,280
server many people seem to think that

00:07:31,210 --> 00:07:35,080
that's not what it is but it's something

00:07:33,280 --> 00:07:38,380
that can be used for building all these

00:07:35,080 --> 00:07:40,090
things it's something more generic well

00:07:38,380 --> 00:07:42,009
and I say it's not a playback library

00:07:40,090 --> 00:07:44,800
but nowadays we also include a little

00:07:42,009 --> 00:07:46,360
playback library to make your life a bit

00:07:44,800 --> 00:07:49,000
easier if you want to just implement a

00:07:46,360 --> 00:07:51,669
playback application but it's not the

00:07:49,000 --> 00:07:55,720
main focus so now let's talk a bit about

00:07:51,669 --> 00:07:59,250
rust and why gstreamer why for GStreamer

00:07:55,720 --> 00:08:01,389
rust is something like the perfect fit

00:07:59,250 --> 00:08:04,060
well first of all we have the usual

00:08:01,389 --> 00:08:05,770
suspects the memory safety the fields

00:08:04,060 --> 00:08:08,199
concurrency and that we have something

00:08:05,770 --> 00:08:10,030
like that is a modern language not from

00:08:08,199 --> 00:08:14,800
the 70s anymore and something that has

00:08:10,030 --> 00:08:16,990
modern tooling so if i say here memory

00:08:14,800 --> 00:08:22,020
safety in the past in gstreamer what we

00:08:16,990 --> 00:08:25,930
had is a couple of CDEs many bugs

00:08:22,020 --> 00:08:28,659
related to memory safety which might not

00:08:25,930 --> 00:08:30,159
be really a security related often they

00:08:28,659 --> 00:08:31,599
are but it might not also be just

00:08:30,159 --> 00:08:33,310
something that is annoying if you watch

00:08:31,599 --> 00:08:34,360
a movie for example you don't want it to

00:08:33,310 --> 00:08:37,419
stop in the middle just because

00:08:34,360 --> 00:08:39,039
something is crashing and most of these

00:08:37,419 --> 00:08:40,959
bugs would be something that would never

00:08:39,039 --> 00:08:44,589
have happened with rust sure there would

00:08:40,959 --> 00:08:46,300
be other bugs but at least not those the

00:08:44,589 --> 00:08:48,760
other thing is do smells heavily

00:08:46,300 --> 00:08:50,110
multi-threaded as an application

00:08:48,760 --> 00:08:52,570
developer you don't really see that but

00:08:50,110 --> 00:08:54,490
internally everything is running in

00:08:52,570 --> 00:08:56,500
different threads in a normal playback

00:08:54,490 --> 00:08:59,140
application you easily have tens of

00:08:56,500 --> 00:09:00,660
threads and it's very annoying to do

00:08:59,140 --> 00:09:04,180
this kind of development and see and

00:09:00,660 --> 00:09:07,510
rust can help here

00:09:04,180 --> 00:09:09,160
the last part well I said everything is

00:09:07,510 --> 00:09:10,220
written in C nobody wants to write C

00:09:09,160 --> 00:09:12,320
even worse

00:09:10,220 --> 00:09:15,380
in the case of GStreamer it's using the

00:09:12,320 --> 00:09:18,950
object lots of macros very hard and

00:09:15,380 --> 00:09:20,960
difficult to learn and using rust could

00:09:18,950 --> 00:09:23,840
make everything much more convenient to

00:09:20,960 --> 00:09:26,570
use and ideally it would also allow us

00:09:23,840 --> 00:09:28,700
to find new developers interested in

00:09:26,570 --> 00:09:31,760
using or developing for GStreamer

00:09:28,700 --> 00:09:33,350
because new developers they wanted to a

00:09:31,760 --> 00:09:36,500
fancy tools they don't want to learn

00:09:33,350 --> 00:09:43,400
this we are C and G objects stuff they

00:09:36,500 --> 00:09:46,700
want something modern and similarly rust

00:09:43,400 --> 00:09:48,110
is perfect for in the context of

00:09:46,700 --> 00:09:49,760
restreamer because it does not have any

00:09:48,110 --> 00:09:52,580
runtime it does not have any garbage

00:09:49,760 --> 00:09:55,940
collection and the keywords zero cost

00:09:52,580 --> 00:09:58,610
abstractions because our goal is to run

00:09:55,940 --> 00:10:00,950
on everything from low-power embedded

00:09:58,610 --> 00:10:03,590
systems where you can't really afford a

00:10:00,950 --> 00:10:08,090
big runtime or garbage collection up to

00:10:03,590 --> 00:10:09,980
anything that is huge and in general

00:10:08,090 --> 00:10:12,170
whenever you do something of multimedia

00:10:09,980 --> 00:10:14,420
you want to be able for example to have

00:10:12,170 --> 00:10:15,590
control over where things are allocated

00:10:14,420 --> 00:10:20,480
when are they located

00:10:15,590 --> 00:10:23,860
when are they released again and yeah in

00:10:20,480 --> 00:10:26,780
the case of rust what also is quite

00:10:23,860 --> 00:10:28,490
useful on Isis that everything in the

00:10:26,780 --> 00:10:32,030
end is compiling down to very optimized

00:10:28,490 --> 00:10:34,190
code you don't have something like yeah

00:10:32,030 --> 00:10:37,490
like something like an interpreted

00:10:34,190 --> 00:10:38,450
language behind that it's all very fast

00:10:37,490 --> 00:10:41,060
and low-level

00:10:38,450 --> 00:10:43,370
and the last part that I personally like

00:10:41,060 --> 00:10:47,150
very much is that the ownership model

00:10:43,370 --> 00:10:48,710
for things like video frames or in

00:10:47,150 --> 00:10:51,770
general media data and all kinds of

00:10:48,710 --> 00:10:53,900
other processing related things inside

00:10:51,770 --> 00:10:56,840
restreamer the ownership model of that

00:10:53,900 --> 00:10:59,510
that's perfectly to the ownership model

00:10:56,840 --> 00:11:01,370
of rust and so far from all the

00:10:59,510 --> 00:11:03,920
languages that we support russ is the

00:11:01,370 --> 00:11:08,390
only language where this mapping is

00:11:03,920 --> 00:11:11,870
really one to one and in the end if you

00:11:08,390 --> 00:11:15,410
know a bit the arc type in rust it has

00:11:11,870 --> 00:11:16,850
something that allows you to do at

00:11:15,410 --> 00:11:20,450
runtime copy-on-write

00:11:16,850 --> 00:11:22,340
so you can check with this reference

00:11:20,450 --> 00:11:23,240
comment at container thing if you are

00:11:22,340 --> 00:11:25,550
the only owner if

00:11:23,240 --> 00:11:27,350
you're the only owner you can write to

00:11:25,550 --> 00:11:29,779
the thing if you're if not you might

00:11:27,350 --> 00:11:35,060
have to take a copy and this is exactly

00:11:29,779 --> 00:11:36,410
how the basic types and GStreamer are

00:11:35,060 --> 00:11:37,940
working if you're the only owner you're

00:11:36,410 --> 00:11:40,730
allowed to do whatever you want with it

00:11:37,940 --> 00:11:43,940
otherwise you might have to take a copy

00:11:40,730 --> 00:11:45,740
instead and the nice thing here along

00:11:43,940 --> 00:11:47,420
with rust is that well we have that all

00:11:45,740 --> 00:11:49,850
in scene and see you have to call all

00:11:47,420 --> 00:11:51,860
kinds of functions manually in the case

00:11:49,850 --> 00:11:53,750
of rust the compiler is making sure that

00:11:51,860 --> 00:11:56,480
you don't forget to do these things and

00:11:53,750 --> 00:12:01,670
to some degree it's also all happening

00:11:56,480 --> 00:12:04,880
automatically so then let's talk a bit

00:12:01,670 --> 00:12:15,529
about using this drama from rust what is

00:12:04,880 --> 00:12:18,170
possible at this point so the first

00:12:15,529 --> 00:12:20,089
thing that you might want to do and what

00:12:18,170 --> 00:12:23,660
the majority of people using Vista ma

00:12:20,089 --> 00:12:26,060
are doing is writing applications so at

00:12:23,660 --> 00:12:28,910
this point we have almost complete

00:12:26,060 --> 00:12:32,000
bindings of the GC Makua and lots of the

00:12:28,910 --> 00:12:35,360
helper libraries available it's all

00:12:32,000 --> 00:12:37,339
based on the infrastructure that GK RSS

00:12:35,360 --> 00:12:39,170
providing it's also using the same code

00:12:37,339 --> 00:12:42,920
generator to generate most of the

00:12:39,170 --> 00:12:46,490
bindings code from the API metadata that

00:12:42,920 --> 00:12:48,920
Giustra is providing and well you can

00:12:46,490 --> 00:12:51,410
find the code here it's in the end

00:12:48,920 --> 00:12:54,140
providing some kind of safe and more or

00:12:51,410 --> 00:12:57,970
less idiomatic bindings to the gstreamer

00:12:54,140 --> 00:13:00,320
api if you know gstreamer you can

00:12:57,970 --> 00:13:02,450
probably easily learn the bindings

00:13:00,320 --> 00:13:04,700
because in the end all the functions are

00:13:02,450 --> 00:13:08,050
called the same all the objects are all

00:13:04,700 --> 00:13:11,779
the same it's just a different language

00:13:08,050 --> 00:13:14,899
but different to see you actually have

00:13:11,779 --> 00:13:20,000
something that is safer or in this case

00:13:14,899 --> 00:13:22,100
actually memory safe to use personally I

00:13:20,000 --> 00:13:25,550
use the bindings now for everything I

00:13:22,100 --> 00:13:27,920
can including test cases that I have to

00:13:25,550 --> 00:13:29,510
write even for things when if there if

00:13:27,920 --> 00:13:30,829
there's some kind of bug reported in

00:13:29,510 --> 00:13:32,690
this room and I need to write a test

00:13:30,829 --> 00:13:34,430
case I'm just writing the test case and

00:13:32,690 --> 00:13:36,620
rust because it's much more convenient a

00:13:34,430 --> 00:13:38,540
faster and

00:13:36,620 --> 00:13:41,510
it's so close to the metal the debugging

00:13:38,540 --> 00:13:43,130
of things that are actually inside

00:13:41,510 --> 00:13:47,600
restreamer from a rust application

00:13:43,130 --> 00:13:49,310
that's just like if you are it's as if

00:13:47,600 --> 00:13:53,750
you had written the test case and see

00:13:49,310 --> 00:13:58,250
there's no no heavy runtime or anything

00:13:53,750 --> 00:13:59,900
in between and this stuff is all stable

00:13:58,250 --> 00:14:03,850
and ready to be used you can also find

00:13:59,900 --> 00:14:07,580
it on credit i oh it works at least on

00:14:03,850 --> 00:14:09,170
Linux Mac OS and Windows I didn't try it

00:14:07,580 --> 00:14:14,300
anywhere else I would assume that it

00:14:09,170 --> 00:14:15,980
also works as well the other part that

00:14:14,300 --> 00:14:18,530
is very important for us to mess that

00:14:15,980 --> 00:14:22,580
all the functionality is provided via

00:14:18,530 --> 00:14:24,920
plugins and with the code that you can't

00:14:22,580 --> 00:14:26,810
find here um you can find some kind of

00:14:24,920 --> 00:14:28,600
infrastructure that allows you to write

00:14:26,810 --> 00:14:32,510
plug-ins for gstreamer in rust

00:14:28,600 --> 00:14:33,770
completely plain rust they are for

00:14:32,510 --> 00:14:37,190
writing the plugins you don't have to

00:14:33,770 --> 00:14:38,810
use any macros any weird language

00:14:37,190 --> 00:14:41,750
constructs or anything you just have to

00:14:38,810 --> 00:14:45,560
implement a few trades then implement

00:14:41,750 --> 00:14:48,410
the functions of the trades and that's

00:14:45,560 --> 00:14:51,770
it you also don't have to use any unsafe

00:14:48,410 --> 00:14:54,590
code unless you want to and it's really

00:14:51,770 --> 00:14:57,770
convenient to write do some uh plugins

00:14:54,590 --> 00:14:58,460
like that of course not everything is

00:14:57,770 --> 00:15:00,530
perfect

00:14:58,460 --> 00:15:04,700
as I said GCMs based on the object so

00:15:00,530 --> 00:15:07,610
there's some kind of object-oriented

00:15:04,700 --> 00:15:09,410
paradigm behind that so we induce Tamala

00:15:07,610 --> 00:15:12,440
there's lots of inheritance happening

00:15:09,410 --> 00:15:14,750
well it's kind of emulated in this

00:15:12,440 --> 00:15:17,600
infrastructure with trades it's not

00:15:14,750 --> 00:15:19,370
perfect but it works and it's not as

00:15:17,600 --> 00:15:22,760
ugly as I would have expected from

00:15:19,370 --> 00:15:25,400
before I started this so on what is

00:15:22,760 --> 00:15:28,670
currently available in as plugins

00:15:25,400 --> 00:15:31,400
written in rust is if a vida Maxo which

00:15:28,670 --> 00:15:34,460
is the container format that was used by

00:15:31,400 --> 00:15:36,650
flash in the past there's an HTTP sauce

00:15:34,460 --> 00:15:38,270
that is using high power there's some

00:15:36,650 --> 00:15:41,450
audio and video filters available

00:15:38,270 --> 00:15:44,720
there's Amazon s3 source and sync

00:15:41,450 --> 00:15:48,020
available in other repositories there's

00:15:44,720 --> 00:15:49,730
start of animated gif decoder VA API

00:15:48,020 --> 00:15:50,360
sync and all kinds of things that are

00:15:49,730 --> 00:15:53,000
probably don't

00:15:50,360 --> 00:15:55,070
know about it's not complete yet it's in

00:15:53,000 --> 00:15:57,950
the very early stages but nonetheless

00:15:55,070 --> 00:16:00,230
it's useful already and you can use it

00:15:57,950 --> 00:16:01,700
to write do summer plugins to extend

00:16:00,230 --> 00:16:04,160
juice tomorrow with new functionality

00:16:01,700 --> 00:16:06,200
and all these plugins

00:16:04,160 --> 00:16:07,970
while they are written in rust they will

00:16:06,200 --> 00:16:09,769
work in any gstreamer application no

00:16:07,970 --> 00:16:15,170
matter what language this application is

00:16:09,769 --> 00:16:17,600
written in so for the future of course

00:16:15,170 --> 00:16:21,740
the plan is to write more rust to write

00:16:17,600 --> 00:16:25,310
less see especially new plugins if

00:16:21,740 --> 00:16:30,019
possible it would be good to have them

00:16:25,310 --> 00:16:32,470
written in rust snow and some of the

00:16:30,019 --> 00:16:35,870
ideas that have is to write some a

00:16:32,470 --> 00:16:38,930
plaque in about an around rust AV about

00:16:35,870 --> 00:16:41,360
which we will have a talk afterwards

00:16:38,930 --> 00:16:44,029
there are various codec libraries

00:16:41,360 --> 00:16:45,560
already available in rust this a flux

00:16:44,029 --> 00:16:48,440
decoder for the flacc audio format

00:16:45,560 --> 00:16:50,480
there's a Vorbis decoder that's the

00:16:48,440 --> 00:16:53,510
start of an AV one video encoder

00:16:50,480 --> 00:16:55,399
available some subtitle decoders and it

00:16:53,510 --> 00:16:57,649
would be nice to wrap all these existing

00:16:55,399 --> 00:17:00,649
rust libraries and add restreamer plugin

00:16:57,649 --> 00:17:04,130
because then every user of GStreamer

00:17:00,649 --> 00:17:06,280
would have something safe available

00:17:04,130 --> 00:17:09,079
something that is not wrapped around

00:17:06,280 --> 00:17:11,390
decades old syllabus that nobody is

00:17:09,079 --> 00:17:16,069
maintaining anymore so that would be

00:17:11,390 --> 00:17:17,390
very very nice and the other thing would

00:17:16,069 --> 00:17:19,130
be to write more applications more

00:17:17,390 --> 00:17:21,110
useful applications in rust currently

00:17:19,130 --> 00:17:22,640
they are not that many out there people

00:17:21,110 --> 00:17:24,919
are just starting to use the bindings

00:17:22,640 --> 00:17:26,959
and all of this is something where you

00:17:24,919 --> 00:17:29,380
can also get involved if you're

00:17:26,959 --> 00:17:32,809
interested in this kind of stuff just

00:17:29,380 --> 00:17:35,000
look at the existing code look at the

00:17:32,809 --> 00:17:37,880
existing examples if you've any

00:17:35,000 --> 00:17:39,710
questions ask me all this is something

00:17:37,880 --> 00:17:44,360
that I really care about and if you need

00:17:39,710 --> 00:17:46,100
help with that just ask for help what we

00:17:44,360 --> 00:17:48,650
are not going to do at this point is to

00:17:46,100 --> 00:17:51,020
rewrite this demand rust it's a lot of

00:17:48,650 --> 00:17:53,179
code nobody is going to have the time

00:17:51,020 --> 00:17:57,860
for rewriting all that but in the long

00:17:53,179 --> 00:18:01,040
run if we continue continue to see that

00:17:57,860 --> 00:18:02,600
rust is really the perfect fit

00:18:01,040 --> 00:18:04,490
quad gstreamer components could be

00:18:02,600 --> 00:18:07,549
rewritten and rust but that's all in

00:18:04,490 --> 00:18:11,919
long run first of all applications and

00:18:07,549 --> 00:18:15,169
plugins which is already a huge part and

00:18:11,919 --> 00:18:16,580
also now would be the perfect time for

00:18:15,169 --> 00:18:18,320
you to start writing do some

00:18:16,580 --> 00:18:20,419
applications in pluck and plugins in

00:18:18,320 --> 00:18:23,509
rust all what you need is available

00:18:20,419 --> 00:18:25,429
already and also people that didn't

00:18:23,509 --> 00:18:26,899
touch this to me before because oh this

00:18:25,429 --> 00:18:28,879
is all see this is we have the object

00:18:26,899 --> 00:18:32,629
stuff you can also start now if you

00:18:28,879 --> 00:18:34,759
prefer rust so I don't have that much

00:18:32,629 --> 00:18:39,919
time left so I will speed up a little

00:18:34,759 --> 00:18:42,169
bit so my rust experience so far I said

00:18:39,919 --> 00:18:44,600
before I'm using it for my own projects

00:18:42,169 --> 00:18:46,340
wherever possible we are at simple and

00:18:44,600 --> 00:18:50,419
it's in pretty low we are also using it

00:18:46,340 --> 00:18:52,700
for various client projects by now it's

00:18:50,419 --> 00:18:55,700
mostly little applications or our

00:18:52,700 --> 00:18:57,529
plugins and for myself everything is

00:18:55,700 --> 00:19:00,980
much much more enjoyable to write in

00:18:57,529 --> 00:19:04,789
rust than in C and also more and roil or

00:19:00,980 --> 00:19:08,360
also on from water source of our rust is

00:19:04,789 --> 00:19:10,279
much better or much better suited for

00:19:08,360 --> 00:19:12,850
this kind of applications than any of

00:19:10,279 --> 00:19:15,139
the other languages are tried before

00:19:12,850 --> 00:19:17,659
some things that I noticed though is

00:19:15,139 --> 00:19:22,429
that people are generally very afraid of

00:19:17,659 --> 00:19:24,619
unsafe code so what I noticed is that

00:19:22,429 --> 00:19:26,809
you really shouldn't be that afraid of

00:19:24,619 --> 00:19:28,159
unsafe code especially if your

00:19:26,809 --> 00:19:30,350
alternative would be to write something

00:19:28,159 --> 00:19:32,869
in C and see everything is unsafe it's

00:19:30,350 --> 00:19:34,700
just not written on on it so if you

00:19:32,869 --> 00:19:36,860
really have to use unsafe code don't be

00:19:34,700 --> 00:19:40,700
afraid to do that just do it but wrap it

00:19:36,860 --> 00:19:42,289
in safe abstractions and before you do

00:19:40,700 --> 00:19:43,999
something very complicated and never get

00:19:42,289 --> 00:19:45,710
your code finished it's better to do

00:19:43,999 --> 00:19:48,799
something unsafe especially if it's

00:19:45,710 --> 00:19:52,039
impossible to do otherwise like for FFI

00:19:48,799 --> 00:19:53,480
or for optimizations or in some cases if

00:19:52,039 --> 00:19:56,419
you implement your own data structures

00:19:53,480 --> 00:19:58,820
and have situations where you can't

00:19:56,419 --> 00:20:00,499
possibly convince the compiler that what

00:19:58,820 --> 00:20:02,809
you are doing there is safe these guys

00:20:00,499 --> 00:20:05,509
exist and well use unsafe code if you

00:20:02,809 --> 00:20:08,210
have to another thing I noticed is that

00:20:05,509 --> 00:20:09,919
people are looking at rust projects and

00:20:08,210 --> 00:20:13,749
also for example the G Summa bindings

00:20:09,919 --> 00:20:15,889
and they have a million dependencies and

00:20:13,749 --> 00:20:17,570
people coming from C are usually very

00:20:15,889 --> 00:20:18,350
afraid of that because dependencies

00:20:17,570 --> 00:20:20,750
there's something they

00:20:18,350 --> 00:20:23,960
difficult you somehow have to compile

00:20:20,750 --> 00:20:25,580
all that and it's other people's code it

00:20:23,960 --> 00:20:27,799
might not work properly you might not

00:20:25,580 --> 00:20:30,080
have a way to fix it so far my

00:20:27,799 --> 00:20:32,480
experience with rust in this regard is

00:20:30,080 --> 00:20:34,130
quite the opposite it's very easy to

00:20:32,480 --> 00:20:36,679
depend on something new it's very easy

00:20:34,130 --> 00:20:37,910
to create your own fork of that if you

00:20:36,679 --> 00:20:40,460
have to fix something in the maintain

00:20:37,910 --> 00:20:42,830
that's not available but what I noticed

00:20:40,460 --> 00:20:45,320
so far is that all the projects that I'm

00:20:42,830 --> 00:20:46,809
depending on remain the maintenance are

00:20:45,320 --> 00:20:49,160
very active very friendly and helpful

00:20:46,809 --> 00:20:50,870
even if I don't want to fix anything in

00:20:49,160 --> 00:20:53,630
there usually they are interested in

00:20:50,870 --> 00:20:55,340
fixing it and otherwise usually the code

00:20:53,630 --> 00:20:57,380
is kind of clean you don't have the

00:20:55,340 --> 00:20:58,760
situation that you haven't see that you

00:20:57,380 --> 00:21:02,210
might use the library that was written

00:20:58,760 --> 00:21:04,039
20 years ago in a code style that nobody

00:21:02,210 --> 00:21:07,100
would use nowadays anymore and it's just

00:21:04,039 --> 00:21:09,250
impossible to read but I guess that's

00:21:07,100 --> 00:21:12,650
just because the language is kind of new

00:21:09,250 --> 00:21:14,750
and the other part is people shouldn't

00:21:12,650 --> 00:21:16,370
be really afraid of performance

00:21:14,750 --> 00:21:18,169
penalties for using high-level

00:21:16,370 --> 00:21:20,480
abstractions especially things like

00:21:18,169 --> 00:21:23,360
iterators they look like complete magic

00:21:20,480 --> 00:21:26,659
but in the end they compile compile down

00:21:23,360 --> 00:21:28,850
to very fast and optimized code so in

00:21:26,659 --> 00:21:30,470
general what I saw is don't worry so

00:21:28,850 --> 00:21:32,240
much about optimizing things in the

00:21:30,470 --> 00:21:33,740
beginning just write readable code and

00:21:32,240 --> 00:21:38,169
you will notice that for most things it

00:21:33,740 --> 00:21:41,659
it is already as optimal as possible and

00:21:38,169 --> 00:21:43,370
in general as usual when you optimize in

00:21:41,659 --> 00:21:46,010
the end and you measure first what you

00:21:43,370 --> 00:21:49,400
want to optimize and what I saw so far

00:21:46,010 --> 00:21:51,919
is that most of the things that I was

00:21:49,400 --> 00:21:55,280
writing even the inner processing loops

00:21:51,919 --> 00:21:57,140
of audio filters for example in the end

00:21:55,280 --> 00:21:58,789
the assembly that the compiler is

00:21:57,140 --> 00:22:00,650
outputting that's basically the same

00:21:58,789 --> 00:22:04,429
thing that AC compiler would have output

00:22:00,650 --> 00:22:05,530
or sometimes even better but not

00:22:04,429 --> 00:22:08,330
everything is perfect

00:22:05,530 --> 00:22:13,330
the language is continuously improving

00:22:08,330 --> 00:22:17,390
but there are still many open

00:22:13,330 --> 00:22:18,740
construction sites and for myself I have

00:22:17,390 --> 00:22:20,690
a little wish list of things that I

00:22:18,740 --> 00:22:23,960
would really like to see in a stable

00:22:20,690 --> 00:22:29,110
rust in the near future and this would

00:22:23,960 --> 00:22:31,549
be all these little little items so

00:22:29,110 --> 00:22:32,269
everybody who ever wrote a little bit of

00:22:31,549 --> 00:22:35,299
Roscoe

00:22:32,269 --> 00:22:37,669
probably saw that at some point you have

00:22:35,299 --> 00:22:39,409
to a fight with a bold checker and the

00:22:37,669 --> 00:22:41,989
non lexical lifetimes are something that

00:22:39,409 --> 00:22:45,229
is that are going to improve this

00:22:41,989 --> 00:22:48,229
situation a lot and well it's in nightly

00:22:45,229 --> 00:22:50,299
already as far as I remember so it

00:22:48,229 --> 00:22:53,080
should be stable at some point in the

00:22:50,299 --> 00:22:57,080
future we will see and other things are

00:22:53,080 --> 00:23:00,080
supported in in stable rust releases for

00:22:57,080 --> 00:23:02,269
SIMD instructions which is currently not

00:23:00,080 --> 00:23:05,029
available available something which

00:23:02,269 --> 00:23:06,950
would make many multimedia processing

00:23:05,029 --> 00:23:09,799
tasks much much faster it's something

00:23:06,950 --> 00:23:11,649
that is available in nightly but ideally

00:23:09,799 --> 00:23:14,450
I wouldn't like to use nightly and

00:23:11,649 --> 00:23:17,299
another thing would be the ability to

00:23:14,450 --> 00:23:19,489
use custom educators also something that

00:23:17,299 --> 00:23:21,259
is a nightly but not stable yet all the

00:23:19,489 --> 00:23:24,019
other parts are something that is

00:23:21,259 --> 00:23:26,690
planned or that is not even planned yet

00:23:24,019 --> 00:23:29,200
we will have to see I think Luka who is

00:23:26,690 --> 00:23:33,139
doing the next talk will also talk about

00:23:29,200 --> 00:23:38,130
these items in more details and with

00:23:33,139 --> 00:23:46,649
that I'm done yeah thanks any questions

00:23:38,130 --> 00:23:46,649
[Applause]

00:24:02,940 --> 00:24:09,700
well so the question was that he was

00:24:07,749 --> 00:24:11,440
talking to someone before who's writing

00:24:09,700 --> 00:24:13,749
this summer code and why they don't use

00:24:11,440 --> 00:24:16,870
trust and the answer was and currently

00:24:13,749 --> 00:24:19,990
it's impossible to submit rust through

00:24:16,870 --> 00:24:22,480
Summa plugins to the existing system of

00:24:19,990 --> 00:24:25,749
source code modules which is true

00:24:22,480 --> 00:24:27,999
unfortunately but for that the at least

00:24:25,749 --> 00:24:31,029
my plan in the near future is that we

00:24:27,999 --> 00:24:33,159
will have a new plug-in module called

00:24:31,029 --> 00:24:34,809
I don't know just do ste plugins RS or

00:24:33,159 --> 00:24:38,529
something like that where there is

00:24:34,809 --> 00:24:40,059
already the start of that and then you

00:24:38,529 --> 00:24:42,549
would just have another module that has

00:24:40,059 --> 00:24:45,639
all the rust based things main reason

00:24:42,549 --> 00:24:48,190
for that is well that that it can't be

00:24:45,639 --> 00:24:50,169
much in the existing modules is that

00:24:48,190 --> 00:24:53,830
where you have to convince people that

00:24:50,169 --> 00:24:54,999
this new language is something that it's

00:24:53,830 --> 00:24:57,220
not going to make their life more

00:24:54,999 --> 00:24:59,769
difficult to have inside the main source

00:24:57,220 --> 00:25:01,899
code modules and also on currently the

00:24:59,769 --> 00:25:05,830
build system is all Auto tools or

00:25:01,899 --> 00:25:08,049
Mazzone based and building blast code

00:25:05,830 --> 00:25:09,639
from there it's not trivial so something

00:25:08,049 --> 00:25:11,789
else that is separate and completely

00:25:09,639 --> 00:25:14,110
cago based would be much much nicer

00:25:11,789 --> 00:25:16,659
but the goal is to have something like

00:25:14,110 --> 00:25:21,690
an official rust plug-in module where

00:25:16,659 --> 00:25:21,690
all the things are collected

00:25:25,450 --> 00:25:33,670
do you see some of the like official

00:25:27,670 --> 00:25:36,430
plugins replaced by probably so the

00:25:33,670 --> 00:25:39,340
question was if I see existing system

00:25:36,430 --> 00:25:43,420
are plugins replaced by rust versions of

00:25:39,340 --> 00:25:45,640
them and yes I think so there's one that

00:25:43,420 --> 00:25:46,030
is the FLV democracy that I mentioned

00:25:45,640 --> 00:25:48,220
earlier

00:25:46,030 --> 00:25:50,130
that's almost feature equivalent with

00:25:48,220 --> 00:25:53,590
existing one that is written in C and

00:25:50,130 --> 00:25:54,850
that could very well replace it but in

00:25:53,590 --> 00:25:57,010
the end we don't really have to replace

00:25:54,850 --> 00:25:59,770
it it it is enough if it exists as an

00:25:57,010 --> 00:26:01,750
additional atom AXA we could give it a

00:25:59,770 --> 00:26:03,730
higher priority so that whenever it is

00:26:01,750 --> 00:26:06,580
installed it will be used and otherwise

00:26:03,730 --> 00:26:08,590
people who don't want to worry about how

00:26:06,580 --> 00:26:11,200
to compile this we addressed code they

00:26:08,590 --> 00:26:15,160
could just continue using the C version

00:26:11,200 --> 00:26:16,630
but yeah same thing with the HTTP sauce

00:26:15,160 --> 00:26:18,070
that I mentioned before the goal is to

00:26:16,630 --> 00:26:20,530
make it feature equivalent with the

00:26:18,070 --> 00:26:23,850
existing one written in C and then it

00:26:20,530 --> 00:26:23,850
would also be a replacement

00:26:25,780 --> 00:26:33,140

YouTube URL: https://www.youtube.com/watch?v=znEEkyGmkcc


