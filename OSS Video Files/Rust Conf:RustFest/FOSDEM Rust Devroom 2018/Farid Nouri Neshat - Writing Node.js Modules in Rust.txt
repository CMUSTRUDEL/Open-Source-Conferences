Title: Farid Nouri Neshat - Writing Node.js Modules in Rust
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	An introduction to Neon

There's always some use cases where you need a systems language inside your node.js application. Neon is Rust bindings for writing safe and fast native Node.js modules. This talk is mainly about Neon, I'll go through the current state of project, a few examples, problems and also the future of the project.

I'm a software engineer with a web development background and a hint of DevOps.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_nodejs_neon/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:04,630 --> 00:00:12,490
okay but it already started introducing

00:00:07,180 --> 00:00:16,440
yourself so just go yeah so ah you need

00:00:12,490 --> 00:00:19,660
an odious add-on Oh some kind of fast

00:00:16,440 --> 00:00:23,560
because you might need more performance

00:00:19,660 --> 00:00:27,310
in noches or you have a native librarian

00:00:23,560 --> 00:00:31,390
that you want to you want it to be used

00:00:27,310 --> 00:00:35,320
in different languages for example Ruby

00:00:31,390 --> 00:00:38,469
Python and then your right arm bindings

00:00:35,320 --> 00:00:42,339
for that library of yours or you want

00:00:38,469 --> 00:00:44,469
more freedom in memory management or you

00:00:42,339 --> 00:00:46,239
might even use you won't even want to

00:00:44,469 --> 00:00:48,850
use some low-level API is in your

00:00:46,239 --> 00:00:52,269
application and in OTS you just can't

00:00:48,850 --> 00:00:53,620
without the proper binding or you don't

00:00:52,269 --> 00:00:57,760
even like JavaScript but that's not a

00:00:53,620 --> 00:01:00,339
good reason all right so how to write an

00:00:57,760 --> 00:01:05,080
odious add-on on I thirst it and C++

00:01:00,339 --> 00:01:08,799
fills up not a fan and I hope you are

00:01:05,080 --> 00:01:13,509
not a fan of C++ because this is the

00:01:08,799 --> 00:01:16,469
Ross room so I found nyan nyan is a

00:01:13,509 --> 00:01:20,890
project to bring Ross and nodejs closer

00:01:16,469 --> 00:01:24,570
well it helps you to write bindings so

00:01:20,890 --> 00:01:24,570
it sound quite easy to get started with

00:01:25,049 --> 00:01:31,990
is not very visible but you could

00:01:28,450 --> 00:01:34,170
install the CLI from NPM and you can

00:01:31,990 --> 00:01:38,409
easily create a new project with neon

00:01:34,170 --> 00:01:40,960
new and then it will tell you that hey

00:01:38,409 --> 00:01:45,929
this is your javascript file and this is

00:01:40,960 --> 00:01:51,880
your rust fire now they're connected so

00:01:45,929 --> 00:01:57,570
this is a example of a Ross file that

00:01:51,880 --> 00:01:57,570
that the exports are module two no js'

00:01:57,630 --> 00:02:03,299
so this is this is the example that neon

00:02:00,759 --> 00:02:07,630
actually gives you it's quite simple

00:02:03,299 --> 00:02:11,680
what it does is just returns the hello

00:02:07,630 --> 00:02:13,180
node string and then on the other side

00:02:11,680 --> 00:02:17,230
you can see on the JavaScript side on

00:02:13,180 --> 00:02:18,730
the right you require the module and you

00:02:17,230 --> 00:02:24,010
call the hello method

00:02:18,730 --> 00:02:27,910
and when you run it and works so there

00:02:24,010 --> 00:02:32,319
is um you can see there is a neon

00:02:27,910 --> 00:02:35,319
created the register module macro and

00:02:32,319 --> 00:02:39,750
then using that you can export your

00:02:35,319 --> 00:02:46,690
functions and at the same time it also

00:02:39,750 --> 00:02:49,150
it brought the j/s types that for

00:02:46,690 --> 00:02:51,220
example here we use the J string so

00:02:49,150 --> 00:02:54,430
there is like a J's knowledge is

00:02:51,220 --> 00:02:59,290
undefined ts number it's all these

00:02:54,430 --> 00:03:02,920
things and it it built this on top of

00:02:59,290 --> 00:03:08,680
the v8 bindings which is v8 is the

00:03:02,920 --> 00:03:11,019
JavaScript engine for nodejs alright so

00:03:08,680 --> 00:03:13,780
talking about performance so some people

00:03:11,019 --> 00:03:15,940
say that ok we want to use this we want

00:03:13,780 --> 00:03:19,390
to writing Ross because I think Ross is

00:03:15,940 --> 00:03:20,470
going to be way faster than nodejs it's

00:03:19,390 --> 00:03:25,720
going to be way faster than JavaScript

00:03:20,470 --> 00:03:28,269
but do not underestimate JavaScript it

00:03:25,720 --> 00:03:30,489
can optimize it well it can be never

00:03:28,269 --> 00:03:33,670
like drost but you can get pretty close

00:03:30,489 --> 00:03:36,070
sometimes sometimes but what is also

00:03:33,670 --> 00:03:39,400
hard to optimize it so if you're good at

00:03:36,070 --> 00:03:41,109
javascript it may be better to just um C

00:03:39,400 --> 00:03:46,440
optimize it and if you'd see if it

00:03:41,109 --> 00:03:49,930
matches your goals or not so and

00:03:46,440 --> 00:03:52,600
whenever you make a call from the from

00:03:49,930 --> 00:03:59,019
the JavaScript land to the Ross land and

00:03:52,600 --> 00:04:01,390
then the v8 has to do a certain number

00:03:59,019 --> 00:04:07,030
of checks and these things cannot be

00:04:01,390 --> 00:04:12,100
optimized mmm so trying to avoid it as

00:04:07,030 --> 00:04:14,170
much as possible so like the best if you

00:04:12,100 --> 00:04:16,090
if you using the library for performance

00:04:14,170 --> 00:04:20,079
and let's say you have a lot of data to

00:04:16,090 --> 00:04:22,180
be processed you want to send all the

00:04:20,079 --> 00:04:25,990
data at one shot through to the Ross

00:04:22,180 --> 00:04:27,700
code process it and then send it back so

00:04:25,990 --> 00:04:29,440
do not call the Ross code from

00:04:27,700 --> 00:04:31,910
JavaScript multiple times during this

00:04:29,440 --> 00:04:36,380
because that would be expensive

00:04:31,910 --> 00:04:40,520
in terms of performance so same thing

00:04:36,380 --> 00:04:44,890
goes down interacting JavaScript on

00:04:40,520 --> 00:04:50,360
objects from rust so in this example you

00:04:44,890 --> 00:04:54,920
can see that we create a new JavaScript

00:04:50,360 --> 00:05:01,280
object and then we trying to set tree in

00:04:54,920 --> 00:05:04,100
properties and this potentially might

00:05:01,280 --> 00:05:07,300
call the JavaScript code from the rust

00:05:04,100 --> 00:05:12,260
because in JavaScript you can set

00:05:07,300 --> 00:05:15,530
setters on objects and this will also be

00:05:12,260 --> 00:05:19,550
expensive in fact I would say for

00:05:15,530 --> 00:05:21,020
setting setting properties in objects as

00:05:19,550 --> 00:05:23,090
much as you can trying to do it in

00:05:21,020 --> 00:05:24,560
JavaScript code because the age will

00:05:23,090 --> 00:05:25,760
optimize your code but this is not

00:05:24,560 --> 00:05:30,920
optimized code anymore

00:05:25,760 --> 00:05:35,870
and if you have a lot of data trying to

00:05:30,920 --> 00:05:39,230
use buffers which are which is an odious

00:05:35,870 --> 00:05:44,510
datatype that refers to a space in

00:05:39,230 --> 00:05:47,000
memory and they are much they are much

00:05:44,510 --> 00:05:53,270
faster than strings in when you send

00:05:47,000 --> 00:05:55,070
them to rust so you saw some this called

00:05:53,270 --> 00:05:59,540
dot scope and you're probably wondering

00:05:55,070 --> 00:06:01,640
what is that why do you have to pass it

00:05:59,540 --> 00:06:07,550
around so javascript is a garbage

00:06:01,640 --> 00:06:09,260
collected language and v8 we it wants to

00:06:07,550 --> 00:06:12,640
know that where did you where this

00:06:09,260 --> 00:06:15,290
object belongs to and which function

00:06:12,640 --> 00:06:18,890
belong to so if that function goes on

00:06:15,290 --> 00:06:22,900
out of scope it can garbage collect at

00:06:18,890 --> 00:06:26,900
those values that were created there so

00:06:22,900 --> 00:06:30,020
this call dot scope is is the way that

00:06:26,900 --> 00:06:32,419
you hint v8 that Hades for example this

00:06:30,020 --> 00:06:38,360
string that we are creating it belongs

00:06:32,419 --> 00:06:40,280
to the function that called it so you

00:06:38,360 --> 00:06:44,020
have to pass around called dot scope

00:06:40,280 --> 00:06:44,020
whenever you create a new values

00:06:44,370 --> 00:06:53,650
puffers this is something about them so

00:06:48,780 --> 00:06:56,670
like I said it would be faster to use

00:06:53,650 --> 00:07:00,340
buffers around rather than strings

00:06:56,670 --> 00:07:06,240
here's a small example of buffers and

00:07:00,340 --> 00:07:11,170
time in this example you get this work

00:07:06,240 --> 00:07:13,090
great so you have you can access the

00:07:11,170 --> 00:07:15,790
comp the arguments after your function

00:07:13,090 --> 00:07:18,610
that for example is exported to

00:07:15,790 --> 00:07:23,020
JavaScript this require makes shows that

00:07:18,610 --> 00:07:26,560
that it has the it has that argument the

00:07:23,020 --> 00:07:29,650
first argument and then it will convert

00:07:26,560 --> 00:07:34,960
it to a J's buffer so able to answer

00:07:29,650 --> 00:07:36,280
cast it to J's buffer so then once you

00:07:34,960 --> 00:07:38,200
have your buffer you want to get your

00:07:36,280 --> 00:07:40,180
date you want to get the data out well

00:07:38,200 --> 00:07:47,170
do you have to call this Tod grab method

00:07:40,180 --> 00:07:48,730
which which creates a lock because you

00:07:47,170 --> 00:07:53,830
don't want to be messing around with the

00:07:48,730 --> 00:07:56,290
data in memory whenever whenever you're

00:07:53,830 --> 00:07:59,290
in Ross because assuming that you could

00:07:56,290 --> 00:08:01,060
be on another thread and then there is a

00:07:59,290 --> 00:08:03,220
there is a JavaScript thread rezoning

00:08:01,060 --> 00:08:05,560
you want to acquire a lock and make sure

00:08:03,220 --> 00:08:09,070
that nobody else is watching that data

00:08:05,560 --> 00:08:11,140
and it is saying cost in some state so

00:08:09,070 --> 00:08:14,530
this graph takes care of that and then

00:08:11,140 --> 00:08:18,580
in here you can get the data or mutate

00:08:14,530 --> 00:08:23,260
the data in the then so in this case you

00:08:18,580 --> 00:08:26,470
are converting to a slice and then so

00:08:23,260 --> 00:08:28,030
just for this example what I should I

00:08:26,470 --> 00:08:31,780
should also show that how to create a

00:08:28,030 --> 00:08:35,020
new buffer so it's quite easy just some

00:08:31,780 --> 00:08:39,460
faster scope and then the length so in

00:08:35,020 --> 00:08:44,730
this case I wanted to just copy this and

00:08:39,460 --> 00:08:47,680
this buffer that the function was called

00:08:44,730 --> 00:08:52,690
so in this case we just get the size of

00:08:47,680 --> 00:08:55,660
it and then have to call the grab method

00:08:52,690 --> 00:08:56,960
again so you can create a lock and in

00:08:55,660 --> 00:09:03,020
this case we

00:08:56,960 --> 00:09:04,790
people so you put the mute so then we

00:09:03,020 --> 00:09:09,260
say that this this argument is going to

00:09:04,790 --> 00:09:11,900
be muted and we just say that copy from

00:09:09,260 --> 00:09:14,470
slice which which copies and that

00:09:11,900 --> 00:09:16,970
original buffer into it so then we can

00:09:14,470 --> 00:09:21,710
return that buffer and then JavaScript

00:09:16,970 --> 00:09:22,070
Sam has that a new buffer around all

00:09:21,710 --> 00:09:27,770
right

00:09:22,070 --> 00:09:34,460
so classes so jnanam created another

00:09:27,770 --> 00:09:37,750
macro for creating types so you can have

00:09:34,460 --> 00:09:40,970
your own Ross classes in in neon and

00:09:37,750 --> 00:09:44,630
then then you can use them in JavaScript

00:09:40,970 --> 00:09:46,880
have the same some methods and some some

00:09:44,630 --> 00:09:50,380
properties on top of them maybe you can

00:09:46,880 --> 00:09:55,640
also have some hidden properties there

00:09:50,380 --> 00:09:58,220
so there is a so neon

00:09:55,640 --> 00:10:04,070
makes it easily in gives you a you have

00:09:58,220 --> 00:10:06,470
to make in it emitted so with this in

00:10:04,070 --> 00:10:11,770
that method you will create your object

00:10:06,470 --> 00:10:14,150
and then make sure that all the

00:10:11,770 --> 00:10:16,340
arguments worried are there so this is a

00:10:14,150 --> 00:10:20,150
this is a in JavaScript we would call

00:10:16,340 --> 00:10:24,460
that the constructor and then here's

00:10:20,150 --> 00:10:28,310
another method hello so which which have

00:10:24,460 --> 00:10:33,200
two arguments so we want one argument

00:10:28,310 --> 00:10:36,500
and then which is an name and then also

00:10:33,200 --> 00:10:40,190
accesses the this argument in the method

00:10:36,500 --> 00:10:43,280
which in JavaScript refers to the the

00:10:40,190 --> 00:10:51,590
objects itself so which refers to this

00:10:43,280 --> 00:10:54,380
whole greater object and in this case we

00:10:51,590 --> 00:10:58,100
also have to use this on grab method to

00:10:54,380 --> 00:11:01,520
make sure that we can get our own

00:10:58,100 --> 00:11:04,010
greater object and get this original

00:11:01,520 --> 00:11:08,210
string that put was put there and from

00:11:04,010 --> 00:11:09,779
it so in case and you have to call the

00:11:08,210 --> 00:11:11,910
grab so it

00:11:09,779 --> 00:11:16,639
the lock around it make sure it's not

00:11:11,910 --> 00:11:21,839
modified in the in the JavaScript land

00:11:16,639 --> 00:11:24,269
no there is also tasks it is for

00:11:21,839 --> 00:11:26,100
background jobs so for example you have

00:11:24,269 --> 00:11:29,490
some synchronous code that you want to

00:11:26,100 --> 00:11:32,339
run you can you can use tasks and then

00:11:29,490 --> 00:11:36,629
they will it will use the v8 API to

00:11:32,339 --> 00:11:38,459
create a thread in the background and it

00:11:36,629 --> 00:11:43,019
can do some heavy computation without

00:11:38,459 --> 00:11:47,339
blocking the non je s main without

00:11:43,019 --> 00:11:48,629
blocking the node.js main thread so in

00:11:47,339 --> 00:11:50,999
this case you can now for example

00:11:48,629 --> 00:11:56,249
calculate all the Fibonacci numbers I

00:11:50,999 --> 00:12:01,939
should have an argument I forgot that so

00:11:56,249 --> 00:12:04,589
you would have a perform function that

00:12:01,939 --> 00:12:06,540
that you do whatever needs to be done in

00:12:04,589 --> 00:12:10,350
that thread and then you will also get a

00:12:06,540 --> 00:12:13,379
call and it's completed and then you can

00:12:10,350 --> 00:12:18,470
convert the results to the JavaScript

00:12:13,379 --> 00:12:18,470
values in there or throw an error and

00:12:19,370 --> 00:12:26,100
running it is quite easy just called the

00:12:22,559 --> 00:12:33,629
scheduled task so schedule method of

00:12:26,100 --> 00:12:37,470
your of your object so there is another

00:12:33,629 --> 00:12:41,670
tip there is um something called the

00:12:37,470 --> 00:12:44,519
project called not neon Thurday I'm not

00:12:41,670 --> 00:12:48,480
sure if I'm pronouncing it right but it

00:12:44,519 --> 00:12:52,050
makes it quite easy to write write write

00:12:48,480 --> 00:12:54,929
write code with neon because it takes

00:12:52,050 --> 00:12:58,699
care of all the conversion of the

00:12:54,929 --> 00:13:03,480
arguments and everything so this is also

00:12:58,699 --> 00:13:08,699
a module that is exported to the

00:13:03,480 --> 00:13:13,199
Roseland so you can see that it's quite

00:13:08,699 --> 00:13:16,170
simple raus code and it doesn't have any

00:13:13,199 --> 00:13:20,449
of those it doesn't have any conversion

00:13:16,170 --> 00:13:23,160
of the arguments to the Ross types and

00:13:20,449 --> 00:13:28,140
back and forth

00:13:23,160 --> 00:13:32,300
so it's quite good I say try because I'm

00:13:28,140 --> 00:13:34,980
not sure about the performance

00:13:32,300 --> 00:13:37,320
requirements for your project this might

00:13:34,980 --> 00:13:42,030
be a little bit slower than then I think

00:13:37,320 --> 00:13:45,000
it is and at the same time it's a new

00:13:42,030 --> 00:13:46,890
project so things might go wrong and

00:13:45,000 --> 00:13:50,490
sometimes some people are not fan of

00:13:46,890 --> 00:13:51,720
abstractions too much so it might be a

00:13:50,490 --> 00:13:54,120
little bit too much of an abstraction

00:13:51,720 --> 00:13:59,910
for you but if you want to just try

00:13:54,120 --> 00:14:04,650
things out it's quite good so who uses

00:13:59,910 --> 00:14:06,930
neon well I think it's not done it's not

00:14:04,650 --> 00:14:10,010
very visible that but in the NPM

00:14:06,930 --> 00:14:12,330
registry I could um I did a search and

00:14:10,010 --> 00:14:15,030
there was more than a few projects

00:14:12,330 --> 00:14:18,870
interestingly used neon that was

00:14:15,030 --> 00:14:23,120
surprised actually one of the most

00:14:18,870 --> 00:14:28,020
interesting ones is um is a leap sodium

00:14:23,120 --> 00:14:32,520
which is which is no js' body bindings

00:14:28,020 --> 00:14:36,890
to raw sodium and it is used in the wire

00:14:32,520 --> 00:14:40,860
app which is which is a messaging app so

00:14:36,890 --> 00:14:43,110
that's um that that's that's and then

00:14:40,860 --> 00:14:45,810
they are one of the contributors to this

00:14:43,110 --> 00:14:51,290
project and sure makes it even more

00:14:45,810 --> 00:14:54,390
interesting so it's like that I saw that

00:14:51,290 --> 00:14:57,540
there are a few more cryptography

00:14:54,390 --> 00:14:59,610
modules in that were written with rust

00:14:57,540 --> 00:15:05,040
and then exported to no js' which makes

00:14:59,610 --> 00:15:07,590
sense cause you probably want to want to

00:15:05,040 --> 00:15:10,140
do some sensitive stuff fine your Rosco

00:15:07,590 --> 00:15:15,030
that is arm that has a high performance

00:15:10,140 --> 00:15:17,850
and then do you tend your buffers energy

00:15:15,030 --> 00:15:19,500
has to be used there it makes a lot of

00:15:17,850 --> 00:15:23,550
sense to use rust to write cryptographic

00:15:19,500 --> 00:15:30,090
code in JavaScript in short so I dad

00:15:23,550 --> 00:15:34,430
there's some there is some compilers and

00:15:30,090 --> 00:15:37,020
parsers that are written for rust and

00:15:34,430 --> 00:15:39,980
this is a good thing because

00:15:37,020 --> 00:15:45,240
so you would write your own for example

00:15:39,980 --> 00:15:47,610
library let's say is it's a compiler and

00:15:45,240 --> 00:15:49,680
then you would write bindings for it in

00:15:47,610 --> 00:15:52,709
in different languages for example one

00:15:49,680 --> 00:15:56,190
for JavaScript is the one for Ruby one

00:15:52,709 --> 00:15:58,230
for python one for Java and then you

00:15:56,190 --> 00:16:01,470
only have to write your library once but

00:15:58,230 --> 00:16:03,089
it can be used everywhere it also makes

00:16:01,470 --> 00:16:04,860
sense if you don't like um all those

00:16:03,089 --> 00:16:09,000
languages and you want to use your own

00:16:04,860 --> 00:16:12,450
favorite rust so there's a lot of

00:16:09,000 --> 00:16:17,370
examples like that with C++ for example

00:16:12,450 --> 00:16:22,880
libsass which is which is a transpiler

00:16:17,370 --> 00:16:25,589
for converting SAS code to CSS which

00:16:22,880 --> 00:16:27,750
which makes it makes it easier for some

00:16:25,589 --> 00:16:31,170
front-end developers to write in a

00:16:27,750 --> 00:16:33,779
better language than CSS and leap SAS is

00:16:31,170 --> 00:16:36,770
is actually in written in C++ but it has

00:16:33,779 --> 00:16:42,120
bindings for all the different languages

00:16:36,770 --> 00:16:44,579
so a good example of this kind of is

00:16:42,120 --> 00:16:46,740
this type of library the the reason I'm

00:16:44,579 --> 00:16:49,470
saying that is that I'm hoping that you

00:16:46,740 --> 00:16:51,839
guys are Ross developers and you would

00:16:49,470 --> 00:16:59,270
go on and create some node.js modules

00:16:51,839 --> 00:17:00,959
for somebody like me to use anyway so

00:16:59,270 --> 00:17:04,819
talking the row being able to be

00:17:00,959 --> 00:17:10,620
shortened than I thought so there's a

00:17:04,819 --> 00:17:12,929
about the examples neon is quite new so

00:17:10,620 --> 00:17:18,500
you will go to the website and you will

00:17:12,929 --> 00:17:21,329
see there is nothing there so I can

00:17:18,500 --> 00:17:24,030
there is I found if I found a few and

00:17:21,329 --> 00:17:27,559
then looking around and trying to

00:17:24,030 --> 00:17:29,970
experiment so here they are

00:17:27,559 --> 00:17:32,040
it would be nice if you if you have a

00:17:29,970 --> 00:17:35,040
write a name if you try something and

00:17:32,040 --> 00:17:38,250
then you could um add on your example so

00:17:35,040 --> 00:17:47,480
to the neon example project it would be

00:17:38,250 --> 00:17:47,480
appreciated so yeah any questions

00:17:48,270 --> 00:17:51,420
all right

00:18:01,610 --> 00:18:10,460
well what's the best practice for us

00:18:07,620 --> 00:18:17,670
developers to write the JavaScript API

00:18:10,460 --> 00:18:21,780
documentation is it alright the tricky

00:18:17,670 --> 00:18:27,900
question well there is a there is a lot

00:18:21,780 --> 00:18:31,110
of JavaScript projects and that and all

00:18:27,900 --> 00:18:34,170
of them use different tools to to have

00:18:31,110 --> 00:18:41,400
their own documentation and to build up

00:18:34,170 --> 00:18:45,480
their website hmm so I think one of my

00:18:41,400 --> 00:18:49,710
favorites is the J's talk I'm sorry doc

00:18:45,480 --> 00:18:52,050
module and which which compiles your

00:18:49,710 --> 00:18:54,330
code and which compiles your

00:18:52,050 --> 00:18:58,890
documentation it makes a nice UML page

00:18:54,330 --> 00:19:01,430
from out of it I might be my it might be

00:18:58,890 --> 00:19:03,750
like it's a bit nam in the past because

00:19:01,430 --> 00:19:09,480
it's it's been a wine that I have

00:19:03,750 --> 00:19:13,490
maintained any project but I think that

00:19:09,480 --> 00:19:17,660
the thing is that if you are if you're

00:19:13,490 --> 00:19:19,710
if you have a look at there some immune

00:19:17,660 --> 00:19:21,540
JavaScript project with all the bells

00:19:19,710 --> 00:19:22,860
and whistles and you can have a look

00:19:21,540 --> 00:19:25,380
around and what tools they use I think

00:19:22,860 --> 00:19:26,910
that would be the best the that's that's

00:19:25,380 --> 00:19:30,020
another problem in the JavaScript world

00:19:26,910 --> 00:19:32,760
that everything changes every year and

00:19:30,020 --> 00:19:37,620
me as a JavaScript developer I cannot

00:19:32,760 --> 00:19:39,950
keep up with it so I hope I answered

00:19:37,620 --> 00:19:39,950
your question

00:19:45,300 --> 00:19:52,930
no no I've it's um it's my understanding

00:19:50,650 --> 00:19:54,840
that I might be wrong it's it's a it's a

00:19:52,930 --> 00:19:57,850
guess but from the project description

00:19:54,840 --> 00:20:02,770
that lips sodium is written in grassed

00:19:57,850 --> 00:20:06,540
and then the the the wire messaging app

00:20:02,770 --> 00:20:09,100
is written in ojs and then they use that

00:20:06,540 --> 00:20:24,360
the user and they use the bindings that

00:20:09,100 --> 00:20:25,890
they wrote for lip sodium so neon oh

00:20:24,360 --> 00:20:30,010
yeah sorry

00:20:25,890 --> 00:20:32,710
how is it to distribute nodejs module

00:20:30,010 --> 00:20:38,050
with a with neon and rose bindings in

00:20:32,710 --> 00:20:43,210
NPM so neon takes care of it luckily it

00:20:38,050 --> 00:20:45,940
gives you it gives you one one command

00:20:43,210 --> 00:20:48,060
neon build and it'll build your code and

00:20:45,940 --> 00:20:51,580
it's pretty ready to be imported from

00:20:48,060 --> 00:20:53,890
JavaScript at the same time you can you

00:20:51,580 --> 00:20:58,240
put your Ross code and the JavaScript

00:20:53,890 --> 00:21:03,790
code in your project and then and then

00:20:58,240 --> 00:21:07,090
in the package dot JSON you put a put

00:21:03,790 --> 00:21:08,830
neon billed as a installed script so

00:21:07,090 --> 00:21:12,850
whenever the package is installed it

00:21:08,830 --> 00:21:17,860
will build build a module and then you

00:21:12,850 --> 00:21:21,210
can publish that as an NPM project on

00:21:17,860 --> 00:21:21,210
NPM alright

00:21:28,070 --> 00:21:31,950
the other thing something I forgot to

00:21:30,510 --> 00:21:35,070
mention that you would also have to

00:21:31,950 --> 00:21:39,930
install the neon CLI as a dependency to

00:21:35,070 --> 00:21:41,430
your app and then which would be

00:21:39,930 --> 00:21:43,620
automatically installed whenever

00:21:41,430 --> 00:21:45,390
whenever you user installs it but the

00:21:43,620 --> 00:21:49,080
roast wouldn't be installed with it so

00:21:45,390 --> 00:21:53,790
you have to tell the user that install

00:21:49,080 --> 00:21:56,160
roast as well well you could also build

00:21:53,790 --> 00:22:00,660
build your binaries ahead of time and

00:21:56,160 --> 00:22:03,900
then and then download them whenever the

00:22:00,660 --> 00:22:05,730
project is installed but I'm not sure

00:22:03,900 --> 00:22:07,680
how that would work out because I don't

00:22:05,730 --> 00:22:10,760
have any experience in building binaries

00:22:07,680 --> 00:22:10,760
for multiple platforms

00:22:18,160 --> 00:22:28,730
um that would be a bad idea

00:22:23,590 --> 00:22:29,480
so a scannable to be feasible to install

00:22:28,730 --> 00:22:31,730
rust

00:22:29,480 --> 00:22:38,030
beside your package whenever it's

00:22:31,730 --> 00:22:40,640
installed and well damn yeah you don't

00:22:38,030 --> 00:22:41,900
want to mess with the with the user that

00:22:40,640 --> 00:22:44,540
they have their have their own rust

00:22:41,900 --> 00:22:49,960
installed but well one thing that you

00:22:44,540 --> 00:22:49,960
could do is that you would give it

00:22:50,980 --> 00:22:55,790
installed for example well don't don't

00:22:53,510 --> 00:22:58,160
install it have a local binary of loss

00:22:55,790 --> 00:23:00,800
downloaded to your to the to your

00:22:58,160 --> 00:23:03,770
package a folder and then try to use

00:23:00,800 --> 00:23:06,440
that hopefully you can configure neon to

00:23:03,770 --> 00:23:10,010
be smart about it and use that binary

00:23:06,440 --> 00:23:12,290
instead not not sure if neon can you can

00:23:10,010 --> 00:23:17,080
do that with neon maybe if you are if

00:23:12,290 --> 00:23:22,070
you if you mess around with the path

00:23:17,080 --> 00:23:25,730
variable so yeah it's a kind of I guess

00:23:22,070 --> 00:23:26,380
that's kind of uncharted territory all

00:23:25,730 --> 00:23:40,070
right

00:23:26,380 --> 00:23:44,450
any more questions so Dave Herman is the

00:23:40,070 --> 00:23:47,290
original maintainer so thanks to him I'm

00:23:44,450 --> 00:23:47,290

YouTube URL: https://www.youtube.com/watch?v=5Cbjk8w9mEM


