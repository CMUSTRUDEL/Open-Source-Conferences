Title: Matthias Endler - Idiomatic Rust
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	Writing concise and elegant Rust code

Rust is a big language and it gets bigger every day. Many beginners ask: "What is idiomatic Rust?". This talk will highlight simple tips to make your Rust code more elegant and concise, and introduce you to my peer-reviewed collection of articles/talks/repos for writing idiomatic Rust code.

Coming from dynamic languages like Python, JavaScript or Ruby, many Rust beginners are missing some guidelines on how to write elegant and concise Rust code. For this purpose, I started a project called "Idiomatic Rust", which is a peer-reviewed collection of articles/talks/repos which teach the essence of good Rust.

In this talk I will introduce the project and show you some quick tips on how to make your Rust code more idiomatic. I will cover error handling (e.g. Option to Result conversions, the failure crate), efficiently working with (built-in) traits, and some more.


Matthias is a Backend Engineer located in DÃ¼sseldorf, Germany. His interests are scalability, performance and distributed systems. At work he improves the infrastructure at trivago by making it faster and more reliable. When not on his laptop he plays guitar and drinks hot chocolate.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_idiomatic/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:06,780 --> 00:00:14,140
welcome everybody and I'm very happy

00:00:11,139 --> 00:00:16,210
that you made it here especially

00:00:14,140 --> 00:00:19,840
that it's 9:30 in the morning on a

00:00:16,210 --> 00:00:21,790
Sunday and maybe I feel few have been

00:00:19,840 --> 00:00:23,529
drinking yesterday so I appreciate it

00:00:21,790 --> 00:00:28,270
also the people that are on the

00:00:23,529 --> 00:00:31,270
livestream kudos to you I hope I don't

00:00:28,270 --> 00:00:35,440
disappoint what I want to talk to you

00:00:31,270 --> 00:00:39,190
about is idea Matic rust and it's a huge

00:00:35,440 --> 00:00:43,239
topic I want to show you a little bit on

00:00:39,190 --> 00:00:47,770
what I learned in my journey using rust

00:00:43,239 --> 00:00:52,390
in the last a couple years and how my

00:00:47,770 --> 00:00:57,730
code evolved over time but first Who am

00:00:52,390 --> 00:01:01,899
I i'm mateus I live in Dusseldorf I'm a

00:00:57,730 --> 00:01:03,670
backing engineer at Chicago I do a lot

00:01:01,899 --> 00:01:07,510
with website performance monitoring

00:01:03,670 --> 00:01:09,520
metrics talk to me about it I'll do like

00:01:07,510 --> 00:01:12,280
programming languages a lot so I'm kind

00:01:09,520 --> 00:01:15,310
of a language nerd and I also like hot

00:01:12,280 --> 00:01:17,640
chocolate you can find me on various

00:01:15,310 --> 00:01:21,909
places on the internet so on Twitter and

00:01:17,640 --> 00:01:25,990
I also have a website and now you know

00:01:21,909 --> 00:01:30,430
my your expectations are somewhere here

00:01:25,990 --> 00:01:32,590
for this talk but Russ is a big language

00:01:30,430 --> 00:01:37,000
and it's getting bigger every day

00:01:32,590 --> 00:01:41,140
so I cannot possibly cover everything in

00:01:37,000 --> 00:01:45,969
20 minutes that's insane so lower your

00:01:41,140 --> 00:01:47,710
expectations a little bit this is going

00:01:45,969 --> 00:01:52,270
to be something more practical something

00:01:47,710 --> 00:01:53,920
more hands-on you might be saying okay

00:01:52,270 --> 00:01:57,700
right why should I even care why should

00:01:53,920 --> 00:02:03,850
I watch this talk well when I started

00:01:57,700 --> 00:02:07,090
programming I was I was attracted by

00:02:03,850 --> 00:02:11,710
languages that were simple beautiful

00:02:07,090 --> 00:02:13,540
elegant that had a concise syntax and I

00:02:11,710 --> 00:02:15,880
had a favorite language of course and by

00:02:13,540 --> 00:02:19,090
now you might have guessed which

00:02:15,880 --> 00:02:22,209
language that is of course it's Python

00:02:19,090 --> 00:02:27,069
and I did a lot of Python in the past

00:02:22,209 --> 00:02:32,020
and I appreciated what they call the sin

00:02:27,069 --> 00:02:33,400
of Python which is those rules here are

00:02:32,020 --> 00:02:36,130
the rules

00:02:33,400 --> 00:02:38,140
I hope you all read them all they are

00:02:36,130 --> 00:02:40,120
very important there will be a test

00:02:38,140 --> 00:02:42,550
after the talk now

00:02:40,120 --> 00:02:45,610
those rules they are more or less the

00:02:42,550 --> 00:02:49,810
the the gist of what it means to write

00:02:45,610 --> 00:02:54,250
good well-formed Python code pythonic

00:02:49,810 --> 00:02:56,860
code it's even a word we're not going to

00:02:54,250 --> 00:02:58,959
talk about Python anymore but we want to

00:02:56,860 --> 00:03:03,190
talk a little bit about rust what is

00:02:58,959 --> 00:03:04,690
automatic rust and for that you need to

00:03:03,190 --> 00:03:06,250
know what is automatic

00:03:04,690 --> 00:03:08,049
I hope you've seen the previous part

00:03:06,250 --> 00:03:11,680
from antonin which is super awesome you

00:03:08,049 --> 00:03:14,549
should check it out if not so I will

00:03:11,680 --> 00:03:16,799
focus on the idea Matic part here and

00:03:14,549 --> 00:03:20,230
there is a definition which I quite like

00:03:16,799 --> 00:03:22,060
which is the most concise convenient and

00:03:20,230 --> 00:03:23,709
common way of accomplishing a task in a

00:03:22,060 --> 00:03:25,420
programming language that's from the

00:03:23,709 --> 00:03:27,220
main three that's from not from me all

00:03:25,420 --> 00:03:30,040
of those things underlined are links so

00:03:27,220 --> 00:03:33,130
you can check them out later so that's

00:03:30,040 --> 00:03:36,819
quite awesome this description because

00:03:33,130 --> 00:03:39,040
yeah it's concise convenient and common

00:03:36,819 --> 00:03:40,959
so that makes it automatic and not in

00:03:39,040 --> 00:03:42,730
any programming language but in a

00:03:40,959 --> 00:03:44,620
programming language you're writing it

00:03:42,730 --> 00:03:46,630
should feel natural in the language

00:03:44,620 --> 00:03:49,630
you're writing so if you're a Java

00:03:46,630 --> 00:03:51,459
developer this might be idea Matic Java

00:03:49,630 --> 00:03:56,590
I'm just kidding of course I'm just

00:03:51,459 --> 00:03:58,810
kidding this is non idea magic code you

00:03:56,590 --> 00:04:01,900
can see here that this code will work

00:03:58,810 --> 00:04:04,209
it's checking for a boolean value but in

00:04:01,900 --> 00:04:05,980
a kind of awkward way if you like those

00:04:04,209 --> 00:04:07,950
kind of things there's also leak down to

00:04:05,980 --> 00:04:13,239
the down at the bottom for more of those

00:04:07,950 --> 00:04:15,850
mmm but everybody can agree that this is

00:04:13,239 --> 00:04:17,979
not really idea metric code right most

00:04:15,850 --> 00:04:21,220
people will say yeah that doesn't feel

00:04:17,979 --> 00:04:24,580
right but what is really good code what

00:04:21,220 --> 00:04:27,190
is solid ergonomic natural code you can

00:04:24,580 --> 00:04:30,490
focus on many things

00:04:27,190 --> 00:04:32,889
but if most people would say yeah you

00:04:30,490 --> 00:04:36,330
could focus around those areas

00:04:32,889 --> 00:04:39,550
syntax semantics and design patterns and

00:04:36,330 --> 00:04:41,740
since this is a small talk I'm not going

00:04:39,550 --> 00:04:44,969
to talk about syntax or design patterns

00:04:41,740 --> 00:04:48,879
I'm talking about semantics for syntax

00:04:44,969 --> 00:04:51,550
just use a standard any standard can be

00:04:48,879 --> 00:04:55,120
rust form it actually use rust form it

00:04:51,550 --> 00:04:57,219
it's quite nice for design patterns

00:04:55,120 --> 00:05:00,280
there is a project from one of the core

00:04:57,219 --> 00:05:03,159
members Nick or Cameron rust unofficial

00:05:00,280 --> 00:05:05,469
patterns do checked it out but for

00:05:03,159 --> 00:05:08,830
semantics I did not know where to start

00:05:05,469 --> 00:05:11,110
and I was looking for a lot of resources

00:05:08,830 --> 00:05:15,520
and I couldn't find him when I started

00:05:11,110 --> 00:05:22,439
there was literally none so I had an

00:05:15,520 --> 00:05:27,729
idea what what if I started collecting a

00:05:22,439 --> 00:05:31,509
list of things where intermediate rusty

00:05:27,729 --> 00:05:34,719
developers could go and read about more

00:05:31,509 --> 00:05:38,889
sophisticated code so there are a few

00:05:34,719 --> 00:05:41,199
links from projects and talks actually a

00:05:38,889 --> 00:05:44,349
lot of people that contributed are here

00:05:41,199 --> 00:05:46,870
so yeah ask them if they know something

00:05:44,349 --> 00:05:49,870
about it please contribute to that I

00:05:46,870 --> 00:05:51,879
guess this will be a first step towards

00:05:49,870 --> 00:05:53,469
something that is a guideline not a sin

00:05:51,879 --> 00:05:55,629
of Python because we are not Python we

00:05:53,469 --> 00:05:59,560
don't want to be Python we want to be

00:05:55,629 --> 00:06:03,849
something like rust but a start of a

00:05:59,560 --> 00:06:06,460
conversation on how to write idea

00:06:03,849 --> 00:06:08,770
Metagross code so if you find something

00:06:06,460 --> 00:06:09,509
on the web and you say this is missing

00:06:08,770 --> 00:06:12,159
on the list

00:06:09,509 --> 00:06:14,110
shoot me poor request I'm gonna

00:06:12,159 --> 00:06:16,750
transferred it eventually to some

00:06:14,110 --> 00:06:20,139
official space so you are not locked in

00:06:16,750 --> 00:06:25,120
or something I would happily accept your

00:06:20,139 --> 00:06:28,029
recommendations for that that is all

00:06:25,120 --> 00:06:31,240
very nice and stuff but it's also very

00:06:28,029 --> 00:06:34,389
theoretical so why not look at a very

00:06:31,240 --> 00:06:38,080
practical example and for that I thought

00:06:34,389 --> 00:06:40,389
we build a little tool a little library

00:06:38,080 --> 00:06:43,360
and the case study is going to be

00:06:40,389 --> 00:06:45,759
handling money in rust so we think about

00:06:43,360 --> 00:06:46,810
the data object how does a data object

00:06:45,759 --> 00:06:49,810
look like and how does the

00:06:46,810 --> 00:06:53,170
Pilar help us guiding us along towards

00:06:49,810 --> 00:06:56,380
something that is more convenient to use

00:06:53,170 --> 00:06:59,500
and feels very natural so the task is

00:06:56,380 --> 00:07:03,100
parse money what can go wrong let's

00:06:59,500 --> 00:07:06,040
parse some money so twenty dollars forty

00:07:03,100 --> 00:07:09,880
two cents or 140 euros this is our task

00:07:06,040 --> 00:07:13,630
for the next couple minutes and as a

00:07:09,880 --> 00:07:16,090
beginning rust programmer you might

00:07:13,630 --> 00:07:18,700
start with a function like this you take

00:07:16,090 --> 00:07:23,110
an input which is a spur which is a

00:07:18,700 --> 00:07:26,380
borrowed string which lives on a stack

00:07:23,110 --> 00:07:27,790
and you do something with it and this

00:07:26,380 --> 00:07:29,380
something might go a little bit like

00:07:27,790 --> 00:07:32,290
this first you need to decide what you

00:07:29,380 --> 00:07:34,660
want to return so you could say yeah I

00:07:32,290 --> 00:07:38,470
don't know in my previous language I use

00:07:34,660 --> 00:07:41,830
a tuple for that I say my monetary value

00:07:38,470 --> 00:07:45,130
is an i-32 so an integer and the

00:07:41,830 --> 00:07:47,410
currency is a string so I take the input

00:07:45,130 --> 00:07:50,890
I split it on the whitespace and I

00:07:47,410 --> 00:07:53,560
collected into a vector so this part

00:07:50,890 --> 00:07:55,780
thing in the end has two components if

00:07:53,560 --> 00:07:58,180
everything was right one is the monetary

00:07:55,780 --> 00:08:00,700
value or the amount and the other one is

00:07:58,180 --> 00:08:04,479
the currency and we check if we have an

00:08:00,700 --> 00:08:07,830
amount we just parse the first element

00:08:04,479 --> 00:08:10,419
in our vector and if we have an error

00:08:07,830 --> 00:08:14,080
where we return some magic number as we

00:08:10,419 --> 00:08:18,160
do in C or any many other languages and

00:08:14,080 --> 00:08:21,910
we say we have this invalid currency and

00:08:18,160 --> 00:08:24,820
if not then everything was all right and

00:08:21,910 --> 00:08:28,240
we just take the second element from our

00:08:24,820 --> 00:08:30,940
vector which contains the currency we

00:08:28,240 --> 00:08:38,469
parse it into a string and we return it

00:08:30,940 --> 00:08:43,240
as a tuple yeah can work not so

00:08:38,469 --> 00:08:44,770
beautiful why well let's look at a

00:08:43,240 --> 00:08:49,080
little bit about what I'm doing you I

00:08:44,770 --> 00:08:51,640
have this explicit error check so I'm

00:08:49,080 --> 00:08:54,010
checking I have a condition

00:08:51,640 --> 00:08:56,950
so I'm branching I need to have more

00:08:54,010 --> 00:08:59,380
metal overhead to remember that there

00:08:56,950 --> 00:09:00,220
can be something wrong and also I have

00:08:59,380 --> 00:09:03,910
this

00:09:00,220 --> 00:09:06,790
number -1 which you need to remember is

00:09:03,910 --> 00:09:09,820
not a correct value and -1 is a totally

00:09:06,790 --> 00:09:13,210
correct value for a currency for for a

00:09:09,820 --> 00:09:14,830
monetary value and invalid yeah somebody

00:09:13,210 --> 00:09:19,540
invents a currency called invalid well

00:09:14,830 --> 00:09:21,160
bad luck for us but nevertheless most

00:09:19,540 --> 00:09:23,800
people in a community might agree that

00:09:21,160 --> 00:09:27,190
this is not the way you write solid Ross

00:09:23,800 --> 00:09:29,950
code so the first thing you can do in a

00:09:27,190 --> 00:09:33,340
prototype is to replace this error

00:09:29,950 --> 00:09:36,610
checking with unrep a lot of people will

00:09:33,340 --> 00:09:39,400
say unrep is evil I don't think so unrep

00:09:36,610 --> 00:09:41,530
is very can be very idea Matic

00:09:39,400 --> 00:09:43,690
especially if you're writing a prototype

00:09:41,530 --> 00:09:46,180
and if you want to do get something done

00:09:43,690 --> 00:09:49,540
real quick then unwrap can help you

00:09:46,180 --> 00:09:56,200
because later on actually what is unwrap

00:09:49,540 --> 00:09:58,260
unwrap will just try and fail and there

00:09:56,200 --> 00:10:00,460
will be a panic if there was a failure

00:09:58,260 --> 00:10:03,070
so you might say wow this is dangerous

00:10:00,460 --> 00:10:04,960
and it is but also it helps you get

00:10:03,070 --> 00:10:08,230
going you don't need to think about the

00:10:04,960 --> 00:10:11,110
error handling part in the beginning so

00:10:08,230 --> 00:10:15,390
that's not bad it's just a pattern that

00:10:11,110 --> 00:10:18,790
a lot of people use and you will see why

00:10:15,390 --> 00:10:21,970
so if we take this library actually this

00:10:18,790 --> 00:10:27,660
function parses our thing we can use it

00:10:21,970 --> 00:10:32,670
to parse our money and we're done right

00:10:27,660 --> 00:10:40,600
well what if somebody tries to parse

00:10:32,670 --> 00:10:43,090
some sub euro amount well bad luck you

00:10:40,600 --> 00:10:46,150
get a compile error actually a runtime

00:10:43,090 --> 00:10:50,050
error with a panic even though a rust is

00:10:46,150 --> 00:10:53,760
safe it cannot save you from not

00:10:50,050 --> 00:10:58,030
declaring what you want so our intent

00:10:53,760 --> 00:10:59,620
our intent we must define actually this

00:10:58,030 --> 00:11:03,070
is my colleagues cat I think it's very

00:10:59,620 --> 00:11:05,170
ugly but that's just a side note and it

00:11:03,070 --> 00:11:08,530
should be a meme somewhere so we get an

00:11:05,170 --> 00:11:11,140
error saying called result unwrap on

00:11:08,530 --> 00:11:13,780
error and then we have this weird parse

00:11:11,140 --> 00:11:18,710
in error invalidated and so on

00:11:13,780 --> 00:11:21,650
what happened well turns out we panic on

00:11:18,710 --> 00:11:24,530
this unrep here I told you well it's

00:11:21,650 --> 00:11:26,720
it's totally fine to use that and the

00:11:24,530 --> 00:11:29,630
reason why is that you can later when

00:11:26,720 --> 00:11:31,910
you have something running search for

00:11:29,630 --> 00:11:34,010
unrep in your code and just replace it

00:11:31,910 --> 00:11:37,310
with something nicer and have error

00:11:34,010 --> 00:11:39,200
handling out of the box so you have the

00:11:37,310 --> 00:11:42,860
best of both worlds rapid prototyping

00:11:39,200 --> 00:11:44,810
and safety when you need it so one

00:11:42,860 --> 00:11:48,170
common pattern to use is you replace

00:11:44,810 --> 00:11:50,060
that unwrap with something we call the

00:11:48,170 --> 00:11:52,450
question mark operator or the carrier

00:11:50,060 --> 00:11:55,670
operator that's in line number three

00:11:52,450 --> 00:11:56,870
behind the parse we just replaced unwrap

00:11:55,670 --> 00:11:59,600
with question one let me go back one

00:11:56,870 --> 00:12:02,300
second you see unwrapped becomes a

00:11:59,600 --> 00:12:05,270
question mark and then we return a

00:12:02,300 --> 00:12:08,360
result so in the end and line number

00:12:05,270 --> 00:12:11,930
five you see okay that is the correct

00:12:08,360 --> 00:12:14,540
result so when everything went right the

00:12:11,930 --> 00:12:16,610
happy path and if there's an error or so

00:12:14,540 --> 00:12:18,290
then for example in line number three

00:12:16,610 --> 00:12:20,930
the question mark means there can be an

00:12:18,290 --> 00:12:23,270
error so in this case we just returned

00:12:20,930 --> 00:12:25,160
in parts into error you can see in line

00:12:23,270 --> 00:12:28,400
number one at the end there is the parts

00:12:25,160 --> 00:12:31,070
in error now so we just pass on the

00:12:28,400 --> 00:12:33,560
arrow to the caller and we don't deal

00:12:31,070 --> 00:12:36,350
with error handling anymore it's it's

00:12:33,560 --> 00:12:40,190
also a better concept and exceptions for

00:12:36,350 --> 00:12:42,500
us because these are zero cost you don't

00:12:40,190 --> 00:12:45,620
have a runtime overhead with that but

00:12:42,500 --> 00:12:47,570
you have it's very concise and the way

00:12:45,620 --> 00:12:49,610
you want to write your code and in the

00:12:47,570 --> 00:12:53,360
way of error conditions that can happen

00:12:49,610 --> 00:12:55,100
so all of that is covered now if I

00:12:53,360 --> 00:12:58,460
covered I mean if you take the same

00:12:55,100 --> 00:13:01,190
example from before at least we don't

00:12:58,460 --> 00:13:04,520
panic anymore so but we get something

00:13:01,190 --> 00:13:07,400
which is looking a bit foreign or a bit

00:13:04,520 --> 00:13:11,060
alien you get an error parsing error of

00:13:07,400 --> 00:13:13,760
kind invalid digit so parse int error is

00:13:11,060 --> 00:13:16,310
in fact an enum and enum has actually

00:13:13,760 --> 00:13:20,270
percent error has a kind field and kind

00:13:16,310 --> 00:13:23,300
can be many different types of error

00:13:20,270 --> 00:13:26,660
kind and for a rusty fella but that

00:13:23,300 --> 00:13:28,730
totally makes sense but maybe not for a

00:13:26,660 --> 00:13:32,899
on Russ developer or somebody using your

00:13:28,730 --> 00:13:36,079
library em but first we're trying to

00:13:32,899 --> 00:13:41,209
parse a float here right and we get a

00:13:36,079 --> 00:13:43,129
parse int error so we use the wrong type

00:13:41,209 --> 00:13:47,870
for the parsing if we want to pause a

00:13:43,129 --> 00:13:51,199
float maybe use a float there might be

00:13:47,870 --> 00:13:53,029
people here in the audience which have a

00:13:51,199 --> 00:13:55,660
little experience on how to handle money

00:13:53,029 --> 00:13:58,850
float is not a good idea

00:13:55,660 --> 00:14:03,529
don't use float in production code this

00:13:58,850 --> 00:14:04,339
is not about proper business logic this

00:14:03,529 --> 00:14:07,069
is about Russ

00:14:04,339 --> 00:14:09,889
so that's why in this talk it's fine but

00:14:07,069 --> 00:14:11,660
for production use please check out the

00:14:09,889 --> 00:14:13,670
link at the bottom which you totally

00:14:11,660 --> 00:14:16,040
cannot read any more like I see faces

00:14:13,670 --> 00:14:17,750
stretching up but there is a link at the

00:14:16,040 --> 00:14:21,290
bottom saying caution please don't use

00:14:17,750 --> 00:14:23,600
float for real-world money object in

00:14:21,290 --> 00:14:25,189
this case I want to improve the error

00:14:23,600 --> 00:14:27,350
handling here so think about the rust

00:14:25,189 --> 00:14:28,879
part but if you're a business person

00:14:27,350 --> 00:14:35,269
it's totally fine if you don't accept

00:14:28,879 --> 00:14:38,870
that solution and let's go back again we

00:14:35,269 --> 00:14:42,800
have Ted float 32 and we return the

00:14:38,870 --> 00:14:45,920
parsefloat error now so with that when

00:14:42,800 --> 00:14:49,610
we parse that thing yeah we actually get

00:14:45,920 --> 00:14:52,639
the first real result which is our tuple

00:14:49,610 --> 00:14:59,019
of float and then a currency what about

00:14:52,639 --> 00:15:02,630
this one okay we are missing a currency

00:14:59,019 --> 00:15:05,480
that's an error variant because we can

00:15:02,630 --> 00:15:07,370
hardly know what currency that is we

00:15:05,480 --> 00:15:11,569
don't and what happens if we run the

00:15:07,370 --> 00:15:16,759
code well we burnt because we died at

00:15:11,569 --> 00:15:23,750
runtime again because it says Lane is

00:15:16,759 --> 00:15:25,550
one but index is one and why actually

00:15:23,750 --> 00:15:29,089
look let me show the cat again just for

00:15:25,550 --> 00:15:35,540
good measure yeah I forgot that I had it

00:15:29,089 --> 00:15:37,189
in the slides this we parse the first

00:15:35,540 --> 00:15:40,380
element we try to get the first element

00:15:37,189 --> 00:15:45,210
from our vector which is undefined

00:15:40,380 --> 00:15:48,560
we should handle that we can handle it

00:15:45,210 --> 00:15:52,950
explicitly and say if the length of our

00:15:48,560 --> 00:15:55,410
vector is not 2 then we don't have an

00:15:52,950 --> 00:15:57,870
amount and the currency so then we need

00:15:55,410 --> 00:15:59,730
to return an error you can see that I

00:15:57,870 --> 00:16:02,940
don't write return anymore because

00:15:59,730 --> 00:16:05,220
return is implicit everything in Russ is

00:16:02,940 --> 00:16:07,650
an expression and the last statement

00:16:05,220 --> 00:16:09,210
will be returned or actually the the

00:16:07,650 --> 00:16:11,220
result of the expression will be

00:16:09,210 --> 00:16:13,470
returned to the caller in this case in

00:16:11,220 --> 00:16:18,270
line number 4 debts are returned and in

00:16:13,470 --> 00:16:22,530
line number 7 that's also return so you

00:16:18,270 --> 00:16:27,470
can see that we do this explicit check

00:16:22,530 --> 00:16:32,130
for two elements and also you can see

00:16:27,470 --> 00:16:34,580
that we have a new type here a custom

00:16:32,130 --> 00:16:37,530
error which we call the money error and

00:16:34,580 --> 00:16:41,850
in this case the variant of that is a

00:16:37,530 --> 00:16:44,160
parse error you define it like this

00:16:41,850 --> 00:16:47,490
you have money error which is can be any

00:16:44,160 --> 00:16:50,340
type in interests no like an enum an

00:16:47,490 --> 00:16:54,150
enum with one word variant which is

00:16:50,340 --> 00:16:57,240
parse error you need to implement error

00:16:54,150 --> 00:16:59,580
for this type what you get from that is

00:16:57,240 --> 00:17:04,050
when you try to print it this is what

00:16:59,580 --> 00:17:05,970
will be printed so that's just a trait

00:17:04,050 --> 00:17:08,130
that we implement error is a trait and

00:17:05,970 --> 00:17:09,660
description is a method that we need to

00:17:08,130 --> 00:17:11,250
implement which belongs to the trade and

00:17:09,660 --> 00:17:14,640
it's also the only method in the trade

00:17:11,250 --> 00:17:16,350
and when we implement this yeah more or

00:17:14,640 --> 00:17:17,940
less we have an arrow type at the top

00:17:16,350 --> 00:17:20,660
you can see debug do you write debug

00:17:17,940 --> 00:17:24,120
there is some kind of standard way to

00:17:20,660 --> 00:17:25,890
have something some output when you try

00:17:24,120 --> 00:17:28,620
to print it because there is no real

00:17:25,890 --> 00:17:30,390
yeah yeah it's actually actually you can

00:17:28,620 --> 00:17:34,950
provide a default output for that and

00:17:30,390 --> 00:17:36,870
this is a hand with the derive and for

00:17:34,950 --> 00:17:38,700
our description this is handled when we

00:17:36,870 --> 00:17:42,420
try to print something that the user

00:17:38,700 --> 00:17:47,340
should understand also we need to

00:17:42,420 --> 00:17:49,830
implement a display trade and that's a

00:17:47,340 --> 00:17:51,360
lot of boilerplate you might say you

00:17:49,830 --> 00:17:53,559
have this display trade you have the

00:17:51,360 --> 00:17:56,690
arrow trade

00:17:53,559 --> 00:17:59,630
you even have another thing for

00:17:56,690 --> 00:18:01,789
converting from our parsefloat arrow to

00:17:59,630 --> 00:18:03,559
our internal money error so we wrap

00:18:01,789 --> 00:18:05,990
around the internal standard library

00:18:03,559 --> 00:18:10,789
parsefloat error and we get something

00:18:05,990 --> 00:18:13,070
that is our money error this is a lot of

00:18:10,789 --> 00:18:15,019
code especially for a beginner so

00:18:13,070 --> 00:18:17,090
there's a library to make that easier

00:18:15,019 --> 00:18:18,919
which is called failure and the same

00:18:17,090 --> 00:18:21,500
code that you see here can also be

00:18:18,919 --> 00:18:23,120
expressed like this even there's even

00:18:21,500 --> 00:18:24,620
more in that slide actually we have two

00:18:23,120 --> 00:18:26,389
error types here we have parts amount

00:18:24,620 --> 00:18:30,019
error and we have parts formatting error

00:18:26,389 --> 00:18:31,549
pause amount for yeah parsing the amount

00:18:30,019 --> 00:18:33,080
of course and parts formatting if we

00:18:31,549 --> 00:18:35,929
don't have two elements so we can

00:18:33,080 --> 00:18:38,779
separate the arrow types here and yeah

00:18:35,929 --> 00:18:41,299
we keep the implementation for

00:18:38,779 --> 00:18:45,620
parsefloat arrow down there to do the

00:18:41,299 --> 00:18:47,659
implicit conversion automatically with

00:18:45,620 --> 00:18:49,519
that you get beautiful error messages so

00:18:47,659 --> 00:18:50,990
you say if you're trying to parse

00:18:49,519 --> 00:18:52,970
something without a currency you get

00:18:50,990 --> 00:18:57,409
expecting amount and currency if you

00:18:52,970 --> 00:18:59,149
price something which is not a digits in

00:18:57,409 --> 00:19:04,090
the beginning you get a possible error

00:18:59,149 --> 00:19:06,740
kind invalid all of our own types and

00:19:04,090 --> 00:19:09,919
the usual suspects for the normal case

00:19:06,740 --> 00:19:13,429
but still we check for the length here

00:19:09,919 --> 00:19:15,139
explicitly and yeah it's kind of yeah

00:19:13,429 --> 00:19:19,820
then there might be a better way and

00:19:15,139 --> 00:19:21,649
there is using sliced patterns with

00:19:19,820 --> 00:19:24,740
sliced patterns you can say I take this

00:19:21,649 --> 00:19:27,529
slice in line number 4 I take the vector

00:19:24,740 --> 00:19:29,240
and I take all of it so that's what we

00:19:27,529 --> 00:19:31,279
have two dots here we take the whole

00:19:29,240 --> 00:19:33,769
thing and we compare it to different

00:19:31,279 --> 00:19:36,139
outcomes so match means compare it to

00:19:33,769 --> 00:19:40,100
different versions to different outcomes

00:19:36,139 --> 00:19:41,960
of the computation and we compare if we

00:19:40,100 --> 00:19:44,750
get an amount in the currency if so we

00:19:41,960 --> 00:19:47,059
return it and if not then yeah we throw

00:19:44,750 --> 00:19:48,830
an error but this is just in nightly

00:19:47,059 --> 00:19:52,760
right now but this will help you later

00:19:48,830 --> 00:19:55,220
to make your code even more readable so

00:19:52,760 --> 00:20:00,139
now we use our own money type also

00:19:55,220 --> 00:20:03,529
instead of returning a tuple and there's

00:20:00,139 --> 00:20:05,389
also the way to implement it is you you

00:20:03,529 --> 00:20:07,130
use a struct money you have two fields

00:20:05,389 --> 00:20:09,230
amount and currency

00:20:07,130 --> 00:20:12,919
and this implement block down there this

00:20:09,230 --> 00:20:14,210
is where you write your methods and yeah

00:20:12,919 --> 00:20:18,200
we just have a new function which

00:20:14,210 --> 00:20:20,600
returns a new object of money and for

00:20:18,200 --> 00:20:26,860
the currency we also use a currency enum

00:20:20,600 --> 00:20:29,570
and we have dollar and euro as types and

00:20:26,860 --> 00:20:33,740
we can also implement from string which

00:20:29,570 --> 00:20:35,330
is another trait for the currency and we

00:20:33,740 --> 00:20:37,910
only need to implement one method which

00:20:35,330 --> 00:20:40,460
is called from string and in there we do

00:20:37,910 --> 00:20:45,230
the matching of the string input so

00:20:40,460 --> 00:20:47,870
dollar or euro and anti output of this

00:20:45,230 --> 00:20:51,559
function so when we call Paris on a

00:20:47,870 --> 00:20:55,010
string which is euro or dollar then this

00:20:51,559 --> 00:20:58,580
will return a an object of type currency

00:20:55,010 --> 00:21:03,260
of this enum and the same can be done

00:20:58,580 --> 00:21:05,840
for our money type we also implement

00:21:03,260 --> 00:21:08,000
from string on that money type you can

00:21:05,840 --> 00:21:09,740
see that i just copied over the function

00:21:08,000 --> 00:21:12,140
that we had before in the very beginning

00:21:09,740 --> 00:21:16,429
we had our parsing function I just

00:21:12,140 --> 00:21:20,630
copied it over from line five to line 13

00:21:16,429 --> 00:21:26,210
I guess or order 12 just took that block

00:21:20,630 --> 00:21:29,990
and now if I have a string which is a

00:21:26,210 --> 00:21:34,640
real monetary amount and I I call pars

00:21:29,990 --> 00:21:38,000
on it then I can return automatically an

00:21:34,640 --> 00:21:40,760
element of type money an object of type

00:21:38,000 --> 00:21:44,929
money that is super helpful because then

00:21:40,760 --> 00:21:47,510
we can do things like this you just call

00:21:44,929 --> 00:21:50,570
it on a string and you see that : :

00:21:47,510 --> 00:21:53,000
turbo fish : : angle bracket is called a

00:21:50,570 --> 00:21:56,360
Kluber fish and inside I define the type

00:21:53,000 --> 00:21:57,799
that I want and with this yeah I get

00:21:56,360 --> 00:22:02,990
something that which is very fluent to

00:21:57,799 --> 00:22:03,860
read I say 100 euro dot parse : : angle

00:22:02,990 --> 00:22:08,570
bracket money :

00:22:03,860 --> 00:22:12,110
angle bracket and that's it and so we

00:22:08,570 --> 00:22:14,360
took our initial code we modified it

00:22:12,110 --> 00:22:17,870
based on the compilers input and then we

00:22:14,360 --> 00:22:20,680
reach something which is both readable

00:22:17,870 --> 00:22:22,960
maintainable and safe

00:22:20,680 --> 00:22:29,610
without doing much so this is what I

00:22:22,960 --> 00:22:34,210
learned as a process in those last years

00:22:29,610 --> 00:22:36,610
using rust start with something iterate

00:22:34,210 --> 00:22:37,990
and the compiler will help you a lot so

00:22:36,610 --> 00:22:42,040
if you're interested in that kind of

00:22:37,990 --> 00:22:44,470
stuff check out my website and also ping

00:22:42,040 --> 00:22:46,600
me on Twitter and please contribute to

00:22:44,470 --> 00:22:49,360
that list maybe we can make it bigger

00:22:46,600 --> 00:22:51,730
and if you want somebody that can

00:22:49,360 --> 00:22:54,550
entitiy along then use the Clippy crate

00:22:51,730 --> 00:22:57,860
which has a lot more links to help you

00:22:54,550 --> 00:23:05,320
write more idea magic code thank you

00:22:57,860 --> 00:23:05,320
[Applause]

00:23:19,000 --> 00:23:24,190
the question was since you cannot use

00:23:22,360 --> 00:23:26,050
the slice match with because it is a

00:23:24,190 --> 00:23:28,780
nightly what would you use in stay with

00:23:26,050 --> 00:23:30,460
us well in stay with us you can use what

00:23:28,780 --> 00:23:33,160
I showed you in the previous slide which

00:23:30,460 --> 00:23:36,640
is just the explicit matching on the

00:23:33,160 --> 00:23:38,790
type what would also be nice in the

00:23:36,640 --> 00:23:41,710
future will be collecting into a tuple

00:23:38,790 --> 00:23:43,060
because we collected into a vector and

00:23:41,710 --> 00:23:45,100
then we checked the elements of the

00:23:43,060 --> 00:23:48,310
vector but this is not possible right

00:23:45,100 --> 00:23:50,260
now there will be a lot of those paper

00:23:48,310 --> 00:23:52,870
cuts will go away in the next year or

00:23:50,260 --> 00:23:55,210
two because there's an ergonomics

00:23:52,870 --> 00:23:57,340
initiative and that means that all of

00:23:55,210 --> 00:23:59,700
those things they are right on the verge

00:23:57,340 --> 00:24:03,370
so you can expect this to become stable

00:23:59,700 --> 00:24:06,790
very soon I guess within this year and

00:24:03,370 --> 00:24:09,280
then you will see the the rest of next

00:24:06,790 --> 00:24:12,460
year probably will have even more

00:24:09,280 --> 00:24:15,940
patterns and this is like a growing

00:24:12,460 --> 00:24:17,770
ecosystem and growing stack so probably

00:24:15,940 --> 00:24:20,740
this list of idea Matic things this will

00:24:17,770 --> 00:24:22,450
be longer and longer and longer and the

00:24:20,740 --> 00:24:24,490
things that I told you today might not

00:24:22,450 --> 00:24:27,750
be the things that you want to use in 10

00:24:24,490 --> 00:24:31,000
years but same with other languages

00:24:27,750 --> 00:24:34,050
there are some paper cuts I I admit but

00:24:31,000 --> 00:24:34,050
we will get there in the end

00:24:35,320 --> 00:24:41,690

YouTube URL: https://www.youtube.com/watch?v=P2mooqNMxMs


