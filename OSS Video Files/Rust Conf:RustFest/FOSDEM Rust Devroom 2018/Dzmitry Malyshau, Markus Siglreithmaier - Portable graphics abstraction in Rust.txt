Title: Dzmitry Malyshau, Markus Siglreithmaier - Portable graphics abstraction in Rust
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	Bringing Vulkan everywhere with gfx-rs

Graphics abstraction is an important part of maturing Rust ecosystem. gfx-rs has been the basis of many graphics applications since 2013, but as of this year it undergoes a total rewrite with the new vision, set of goals, and talented contributors. In this talk, I want to explain what this means to existing users, Mozilla, and the world.

Intended audience: people interested in Rust ecosystem foundational libraries, graphics and game development, Vulkan.

Dzmitry Malyshau
Lots of computing and gaming in childhood. Graduated with math and computer science in Belarus, then migrated to Canada to work in game development. Now working with Rust on graphics at Mozilla.

Markus Siglreithmaier
I'm a Computer Science student focusing on Computer Graphics (including Real-time rendering and physically-based animations). I'm mainly working on gfx-rs and associated projects in my spare time at the moment among other smaller Rust projects.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_vulkan_gfx_rs/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:26,760 --> 00:01:09,820
okay so we're not gonna sit here so I'm

00:00:29,470 --> 00:01:12,370
gonna turn yep the keys work so hello

00:01:09,820 --> 00:01:15,040
everyone I'm medium also a graphics

00:01:12,370 --> 00:01:17,710
engineer at Mozilla I work in Firefox

00:01:15,040 --> 00:01:21,250
web browser and before that I worked in

00:01:17,710 --> 00:01:23,950
a game dev industry which inspired me to

00:01:21,250 --> 00:01:28,450
start writing a graphics abstraction

00:01:23,950 --> 00:01:31,210
layer in rust and this is Markus who

00:01:28,450 --> 00:01:34,440
joined us recently to rewrite it and

00:01:31,210 --> 00:01:34,440
that's what we are going to talk about

00:01:35,100 --> 00:01:43,030
the idea is to have a single abstraction

00:01:38,890 --> 00:01:46,720
layer to run on all the platforms that

00:01:43,030 --> 00:01:50,550
we have unfortunately the graphics API

00:01:46,720 --> 00:01:53,860
have been branched out we have Microsoft

00:01:50,550 --> 00:01:56,350
pushing the DirectX 12 in the windows

00:01:53,860 --> 00:02:01,690
ecosystem and we have Apple pushing for

00:01:56,350 --> 00:02:04,060
metal everything else is adopting Vulcan

00:02:01,690 --> 00:02:08,129
quite successfully including the Android

00:02:04,060 --> 00:02:11,110
the most popular ability system and

00:02:08,129 --> 00:02:12,790
OpenGL is still alive as well and we

00:02:11,110 --> 00:02:14,800
want all of those to be available

00:02:12,790 --> 00:02:18,480
through a single interface in rust that

00:02:14,800 --> 00:02:18,480
is hopefully safe and fast

00:02:19,590 --> 00:02:27,850
we started in 2014 and the legend is we

00:02:25,870 --> 00:02:30,220
had three threats at the beginning and

00:02:27,850 --> 00:02:33,190
then we were fast tracking through the

00:02:30,220 --> 00:02:36,700
evolution of the api's as the native API

00:02:33,190 --> 00:02:39,520
did so first we got cumin buffers we got

00:02:36,700 --> 00:02:43,239
rid of threads and then we followed with

00:02:39,520 --> 00:02:45,580
resource fews pipeline States eventually

00:02:43,239 --> 00:02:50,500
getting this VD 11 and metal back ends

00:02:45,580 --> 00:02:52,750
and then somewhere around 2017 when we

00:02:50,500 --> 00:02:56,310
started first talks about integrating

00:02:52,750 --> 00:03:00,280
into web render it appeared to us that

00:02:56,310 --> 00:03:02,920
even though we already had the core

00:03:00,280 --> 00:03:05,860
layer split out of the higher-level

00:03:02,920 --> 00:03:08,530
rendering we still weren't zero-cost

00:03:05,860 --> 00:03:12,069
enough so we decided to go lower level

00:03:08,530 --> 00:03:17,040
we decided to implement the core to be

00:03:12,069 --> 00:03:24,100
completely zero cost and that's where

00:03:17,040 --> 00:03:28,060
Marcus comes in this is the main road

00:03:24,100 --> 00:03:30,010
map of our work and if you are taking

00:03:28,060 --> 00:03:32,980
one thing from our top and that should

00:03:30,010 --> 00:03:35,200
be this slide I believe at the center

00:03:32,980 --> 00:03:37,390
you see hardware abstraction layer

00:03:35,200 --> 00:03:38,440
that's our new core that's the name of

00:03:37,390 --> 00:03:43,269
the new core

00:03:38,440 --> 00:03:48,489
it's Vulcan like rust API very low level

00:03:43,269 --> 00:03:50,709
quite unsafe that different graphics

00:03:48,489 --> 00:03:53,890
backends implement including Vulcan

00:03:50,709 --> 00:03:56,920
metal d3 12 and OpenGL these are the

00:03:53,890 --> 00:03:59,290
backends that we already have now and we

00:03:56,920 --> 00:04:02,920
are getting this VG 11 soon enough as

00:03:59,290 --> 00:04:05,799
well the clients of the hardware

00:04:02,920 --> 00:04:08,590
abstraction layer are many aside from

00:04:05,799 --> 00:04:10,120
the user apps we have the Vulcan

00:04:08,590 --> 00:04:12,459
portability layer which we are talking

00:04:10,120 --> 00:04:14,890
about a little bit later we have the

00:04:12,459 --> 00:04:17,769
warden test framework to ensure no

00:04:14,890 --> 00:04:20,799
regressions in the graphics tests and we

00:04:17,769 --> 00:04:23,820
have a web GPU prototype based on servo

00:04:20,799 --> 00:04:23,820
that's using that

00:04:25,090 --> 00:04:30,820
little bit more about the warden test

00:04:27,560 --> 00:04:34,390
framework it consists of three parts

00:04:30,820 --> 00:04:38,090
first one is we are able to describe

00:04:34,390 --> 00:04:42,320
graphics resources and passes in

00:04:38,090 --> 00:04:46,010
readable source which we use the raster

00:04:42,320 --> 00:04:48,800
object notation for it says here's my

00:04:46,010 --> 00:04:50,120
images buffers here's what I'm going to

00:04:48,800 --> 00:04:53,210
do this with them

00:04:50,120 --> 00:04:56,600
in the following passes and then we have

00:04:53,210 --> 00:04:59,270
we can load it all with a particular

00:04:56,600 --> 00:05:01,030
graphics back-end so that it instant she

00:04:59,270 --> 00:05:03,680
eats the resources on the GPU and

00:05:01,030 --> 00:05:06,350
creates the common buffers to implement

00:05:03,680 --> 00:05:09,620
passes and then we have a brief test

00:05:06,350 --> 00:05:13,220
framework which has very simple ref

00:05:09,620 --> 00:05:16,640
that's defined and it runs the graphics

00:05:13,220 --> 00:05:20,450
passes on the specific backends compares

00:05:16,640 --> 00:05:23,570
the expectations with the tests this is

00:05:20,450 --> 00:05:26,410
an example of the resources we have an

00:05:23,570 --> 00:05:29,900
image with the specified format and

00:05:26,410 --> 00:05:33,020
dimensions we have a render pass with

00:05:29,900 --> 00:05:38,540
one attachment and once a pass just as

00:05:33,020 --> 00:05:40,360
an example of roughly how it looks this

00:05:38,540 --> 00:05:43,010
is the contents of the pass we have the

00:05:40,360 --> 00:05:49,360
setting the viewports the pipeline and

00:05:43,010 --> 00:05:49,360
drawing a single single triangle here

00:06:16,890 --> 00:06:24,310
okay so then why we want to actually use

00:06:20,350 --> 00:06:26,470
rust instead of for example C++ there

00:06:24,310 --> 00:06:31,200
are a few nice bits of rust and compared

00:06:26,470 --> 00:06:33,460
to the basic concurrency all Const new

00:06:31,200 --> 00:06:37,960
features like pattern matching and

00:06:33,460 --> 00:06:41,070
they're sensing which basically tells

00:06:37,960 --> 00:06:43,570
you that every object in our API is

00:06:41,070 --> 00:06:47,260
sensing so you can access it from all

00:06:43,570 --> 00:06:51,700
threats and concurrently and there's

00:06:47,260 --> 00:06:55,630
also immutability which we use to say

00:06:51,700 --> 00:06:56,650
for example you can change this object

00:06:55,630 --> 00:07:00,330
or you can't

00:06:56,650 --> 00:07:06,070
and it also encodes if you need to

00:07:00,330 --> 00:07:08,190
externally enforce single access because

00:07:06,070 --> 00:07:12,460
for example some objects can only be

00:07:08,190 --> 00:07:14,860
accessed on one thread at one time so if

00:07:12,460 --> 00:07:18,690
you have if you see mutable access you

00:07:14,860 --> 00:07:18,690
usually indicates that you need to

00:07:18,720 --> 00:07:26,290
externally synchronize your object then

00:07:22,110 --> 00:07:29,080
traits and associated types which we use

00:07:26,290 --> 00:07:32,530
quite heavily which is which you will

00:07:29,080 --> 00:07:36,190
see later on and we split all the things

00:07:32,530 --> 00:07:38,470
into multiple repositories for example

00:07:36,190 --> 00:07:40,360
one repository is the hardware

00:07:38,470 --> 00:07:41,740
abstraction layer and then for each

00:07:40,360 --> 00:07:48,400
back-end we have an additional

00:07:41,740 --> 00:07:50,800
repository and for each yeah ok great so

00:07:48,400 --> 00:07:54,430
what we are currently missing is for

00:07:50,800 --> 00:07:57,100
example non-exhaustive enums which are

00:07:54,430 --> 00:08:00,160
basically required as we also provide an

00:07:57,100 --> 00:08:03,400
higher level abstraction for this work

00:08:00,160 --> 00:08:05,510
and portability implementation and there

00:08:03,400 --> 00:08:10,100
are cases where

00:08:05,510 --> 00:08:12,290
Wilkin could return as enum values which

00:08:10,100 --> 00:08:15,430
we not really know at the current time

00:08:12,290 --> 00:08:18,890
of implementing which could come from us

00:08:15,430 --> 00:08:22,400
future driver which would return as this

00:08:18,890 --> 00:08:25,460
new enum values then struct alignments

00:08:22,400 --> 00:08:28,340
and shaders which it happens every day

00:08:25,460 --> 00:08:32,060
that we misaligned some shader struct

00:08:28,340 --> 00:08:35,060
because I'm just one page of Vulcan

00:08:32,060 --> 00:08:37,580
specification which basically says how

00:08:35,060 --> 00:08:41,570
you need to align your fields and it's

00:08:37,580 --> 00:08:44,120
usually you do something wrong there

00:08:41,570 --> 00:08:45,920
then Constantine Erik's

00:08:44,120 --> 00:08:52,490
which would give us the possibility to

00:08:45,920 --> 00:08:55,270
use arrays fixed size areas more often

00:08:52,490 --> 00:08:58,220
in the library interface we basically

00:08:55,270 --> 00:09:02,540
expose a quite generic interface using

00:08:58,220 --> 00:09:04,790
into iterator but yeah fixed sized

00:09:02,540 --> 00:09:07,870
errors would help quite a lot for the

00:09:04,790 --> 00:09:10,430
user side to looks a bit better and

00:09:07,870 --> 00:09:12,290
exclusive cargo futures and at the

00:09:10,430 --> 00:09:16,720
moment you could something could do

00:09:12,290 --> 00:09:20,240
something like I want X 12 and Wilkin to

00:09:16,720 --> 00:09:22,940
run at the same time somehow but it

00:09:20,240 --> 00:09:29,240
usually will mess up here and you

00:09:22,940 --> 00:09:31,130
usually only want and TX 12 or Vulcan so

00:09:29,240 --> 00:09:35,120
the packet right is our main interface

00:09:31,130 --> 00:09:36,740
it's one large right you have to have to

00:09:35,120 --> 00:09:41,630
implement if you want to implement a

00:09:36,740 --> 00:09:43,910
back-end we basically divided into the

00:09:41,630 --> 00:09:48,380
special objects like the device or a

00:09:43,910 --> 00:09:52,670
command Q which you can call functions

00:09:48,380 --> 00:09:56,210
on and the basic resources like shaders

00:09:52,670 --> 00:10:01,850
above image which you usually just pass

00:09:56,210 --> 00:10:05,710
around and create and delete so for the

00:10:01,850 --> 00:10:10,880
roadmap 2018 and we would like to become

00:10:05,710 --> 00:10:13,340
Mozilla project because we want to

00:10:10,880 --> 00:10:17,060
integrate into web render and also into

00:10:13,340 --> 00:10:18,470
the web chip you part which will Dimitri

00:10:17,060 --> 00:10:22,550
will talk about

00:10:18,470 --> 00:10:26,360
and one side project is working

00:10:22,550 --> 00:10:31,460
portability it's an initiative from

00:10:26,360 --> 00:10:36,650
Vulcan from Kronos where they try to do

00:10:31,460 --> 00:10:40,190
all the 3 3 backends Vulcan digs 12 and

00:10:36,650 --> 00:10:42,860
metal and provide one RP Eve subset from

00:10:40,190 --> 00:10:47,660
the work and a PE which can map to all

00:10:42,860 --> 00:10:50,510
these three backends and our goal is to

00:10:47,660 --> 00:10:53,230
implement the vole compatibility layer

00:10:50,510 --> 00:10:56,480
using our hardware abstraction layer and

00:10:53,230 --> 00:10:58,630
we currently can already pass a few

00:10:56,480 --> 00:11:04,220
examples like triangles or pipeline

00:10:58,630 --> 00:11:07,000
example from common samples from working

00:11:04,220 --> 00:11:10,550
samples and we are aiming at

00:11:07,000 --> 00:11:14,210
implementing or hooking up the Vulcan

00:11:10,550 --> 00:11:17,200
conformance test we can we try to hook

00:11:14,210 --> 00:11:20,900
up the Vulcan conformance test suit and

00:11:17,200 --> 00:11:24,800
run run the tests against our hardware

00:11:20,900 --> 00:11:27,740
exception layer that's how it looks from

00:11:24,800 --> 00:11:29,330
our side we basically have our hardware

00:11:27,740 --> 00:11:32,510
abstraction layer on the bottom which is

00:11:29,330 --> 00:11:36,260
to DFARS side and on the top we have the

00:11:32,510 --> 00:11:40,250
portability layer and you can interface

00:11:36,260 --> 00:11:43,130
it using driver in the implementation or

00:11:40,250 --> 00:11:45,950
using a static library and if you don't

00:11:43,130 --> 00:11:48,340
want to directly link it link it from C

00:11:45,950 --> 00:11:48,340
library

00:11:50,670 --> 00:12:06,290
a little bit more information about what

00:12:00,510 --> 00:12:10,290
web GPU is it's a w3c working group

00:12:06,290 --> 00:12:12,600
which Microsoft Apple Mozilla and Google

00:12:10,290 --> 00:12:15,480
are part of and as well as a lot of

00:12:12,600 --> 00:12:20,910
independent actors that is trying to

00:12:15,480 --> 00:12:23,820
design a new API to provide newer lower

00:12:20,910 --> 00:12:26,840
level concepts onto the web for faster

00:12:23,820 --> 00:12:29,220
interactive applications on the web and

00:12:26,840 --> 00:12:33,120
there's been a lot of discussions over

00:12:29,220 --> 00:12:35,760
what the next-gen API is gonna be in we

00:12:33,120 --> 00:12:40,640
I'm a part of the group and we don't

00:12:35,760 --> 00:12:43,440
seem to have a lot to agree on so far

00:12:40,640 --> 00:12:46,680
everyone is sort of pushing in a

00:12:43,440 --> 00:12:49,950
different direction so our position

00:12:46,680 --> 00:12:52,050
there is to have something either

00:12:49,950 --> 00:12:58,110
exactly like Vulcan or very close to

00:12:52,050 --> 00:13:02,280
Vulcan and based on that we developed a

00:12:58,110 --> 00:13:08,970
prototype that is using servo but adding

00:13:02,280 --> 00:13:11,190
a new web IDL based API that has

00:13:08,970 --> 00:13:16,320
basically Vulcan calls in it so you can

00:13:11,190 --> 00:13:18,960
I go that low level and create your

00:13:16,320 --> 00:13:22,580
pipeline barriers and descriptors on the

00:13:18,960 --> 00:13:25,590
web using javascript or web assembly and

00:13:22,580 --> 00:13:27,600
run it in the browsers which in the

00:13:25,590 --> 00:13:31,010
browser which is currently a very

00:13:27,600 --> 00:13:31,010
specific Fork of servo

00:13:31,430 --> 00:13:38,250
our future plans with the web GPU

00:13:34,590 --> 00:13:43,200
include trying to get a native

00:13:38,250 --> 00:13:44,940
application France compiling to the web

00:13:43,200 --> 00:13:47,310
using web assembly

00:13:44,940 --> 00:13:49,320
so a native application using volca to

00:13:47,310 --> 00:13:51,720
be compiled using web assembly for the

00:13:49,320 --> 00:13:53,570
web on the browser so that it just runs

00:13:51,720 --> 00:13:57,050
in the browser so that you don't need to

00:13:53,570 --> 00:14:00,410
learn a new API that you can just use

00:13:57,050 --> 00:14:00,410
Vulcan on the web

00:14:03,190 --> 00:14:07,220
now a little bit more about the

00:14:05,510 --> 00:14:09,560
ecosystem that we have when it's history

00:14:07,220 --> 00:14:12,470
seems to have a lot more time left that

00:14:09,560 --> 00:14:15,680
we're gonna start on each of them

00:14:12,470 --> 00:14:18,740
closely there is a few engines in rust

00:14:15,680 --> 00:14:22,730
at the moment none of them is major

00:14:18,740 --> 00:14:27,710
enough but they're very promising namely

00:14:22,730 --> 00:14:31,040
good game easy amethyst and three RS all

00:14:27,710 --> 00:14:34,220
of those use the older Jeff Express at

00:14:31,040 --> 00:14:36,410
the moment where amethyst is already

00:14:34,220 --> 00:14:39,470
transitioning towards the new hardware

00:14:36,410 --> 00:14:42,530
abstraction layer it's extremely

00:14:39,470 --> 00:14:44,450
promising to us since they not only are

00:14:42,530 --> 00:14:46,550
poured into the hardware abstraction

00:14:44,450 --> 00:14:49,270
layer they're bringing bringing the

00:14:46,550 --> 00:14:53,810
higher levels for us to use for example

00:14:49,270 --> 00:14:55,810
a library that manages memory for you so

00:14:53,810 --> 00:14:58,160
that you don't have to care about

00:14:55,810 --> 00:15:00,290
particular memory types that the driver

00:14:58,160 --> 00:15:02,480
exposes you just say oh I want this

00:15:00,290 --> 00:15:06,260
buffer and the library handles the

00:15:02,480 --> 00:15:10,550
actual heat management and allocation of

00:15:06,260 --> 00:15:13,970
the memory from the driver for you or a

00:15:10,550 --> 00:15:16,280
frame graph sort of thing which allows

00:15:13,970 --> 00:15:19,580
you to describe all your graphics

00:15:16,280 --> 00:15:22,190
workload as one big graph which is then

00:15:19,580 --> 00:15:25,900
automatically deriving the dependencies

00:15:22,190 --> 00:15:28,370
the memory barriers for you and possibly

00:15:25,900 --> 00:15:31,760
schedules it to run on multiple Hardware

00:15:28,370 --> 00:15:33,800
queues for execution in parallel so this

00:15:31,760 --> 00:15:36,110
is what amethyst folks are bringing on

00:15:33,800 --> 00:15:39,080
the table and I'm sure a good be museum

00:15:36,110 --> 00:15:43,310
vrs will follow and use hardware

00:15:39,080 --> 00:15:46,430
abstraction layer in 2018 other than

00:15:43,310 --> 00:15:50,780
that we have a very interesting plans

00:15:46,430 --> 00:15:54,260
with volcano as a project that we are

00:15:50,780 --> 00:15:55,550
often being compared to in fact now the

00:15:54,260 --> 00:15:57,650
comparison doesn't make much sense

00:15:55,550 --> 00:16:00,680
because we are lower level we are

00:15:57,650 --> 00:16:04,870
implementing Vulcan and volcano is based

00:16:00,680 --> 00:16:09,020
on Vulcan so what we want to do is to

00:16:04,870 --> 00:16:11,510
let users use volcano on top of GFX

00:16:09,020 --> 00:16:13,400
hardware abstraction layer so in a sense

00:16:11,510 --> 00:16:14,089
it's a drop-in replacement the users

00:16:13,400 --> 00:16:15,949
will not need to

00:16:14,089 --> 00:16:19,339
do anything and they will instantly get

00:16:15,949 --> 00:16:23,990
access to Apple and Microsoft platforms

00:16:19,339 --> 00:16:25,399
potentially Xbox one as well so that's

00:16:23,990 --> 00:16:25,939
something that we are working on right

00:16:25,399 --> 00:16:30,499
now

00:16:25,939 --> 00:16:32,089
and finally web render is Mozilla

00:16:30,499 --> 00:16:37,449
research project that is currently being

00:16:32,089 --> 00:16:40,490
integrated into Firefox it is in need of

00:16:37,449 --> 00:16:44,990
better control of the latency resources

00:16:40,490 --> 00:16:46,850
and more direct access on Windows

00:16:44,990 --> 00:16:47,959
platforms for for example playing a

00:16:46,850 --> 00:16:52,850
video efficiently

00:16:47,959 --> 00:16:55,100
so our volcán portability or graphic

00:16:52,850 --> 00:16:58,009
abstraction layer makes perfect sense to

00:16:55,100 --> 00:17:00,199
be a part of web render and we are

00:16:58,009 --> 00:17:04,250
already working on that we have a group

00:17:00,199 --> 00:17:07,630
in Zagat University in Hungary that's 14

00:17:04,250 --> 00:17:11,899
by blender and they have an exciting

00:17:07,630 --> 00:17:14,299
progress so far so they translated the

00:17:11,899 --> 00:17:16,730
shaders automatically and they already

00:17:14,299 --> 00:17:18,740
rust they already run our ref test

00:17:16,730 --> 00:17:22,250
framework so we're looking forward to

00:17:18,740 --> 00:17:24,890
see where bender running on how this

00:17:22,250 --> 00:17:32,649
year potentially up streamed as well to

00:17:24,890 --> 00:17:36,590
Firefox and we have a very lively Gator

00:17:32,649 --> 00:17:38,990
chat which does not have a link here but

00:17:36,590 --> 00:17:42,260
we have also a blog post and you can

00:17:38,990 --> 00:17:44,149
just jump on the project page on gif tab

00:17:42,260 --> 00:17:49,429
and it will have all the links that you

00:17:44,149 --> 00:17:52,539
you will ever need we are always happy

00:17:49,429 --> 00:17:56,539
to answer your questions and right now

00:17:52,539 --> 00:18:00,399
I'm going to run a demo that markers

00:17:56,539 --> 00:18:00,399
have reading written

00:18:08,290 --> 00:18:14,430
the demo features quite a few compute

00:18:10,840 --> 00:18:18,640
shaders in some rendering as well and

00:18:14,430 --> 00:18:22,000
it's fairly complex it simulates ocean

00:18:18,640 --> 00:18:24,550
water and it runs exactly the same on

00:18:22,000 --> 00:18:29,700
this video twelve metal and Vulcan using

00:18:24,550 --> 00:18:29,700
the same shaders and the same API calls

00:18:32,340 --> 00:18:56,800
so that is it really for questions so

00:18:53,980 --> 00:19:01,300
the question is why do we consider it a

00:18:56,800 --> 00:19:05,710
zero cost abstraction layer it's zero

00:19:01,300 --> 00:19:08,020
cost in a sense that if you want to it

00:19:05,710 --> 00:19:12,610
to be backed by Vulcan then we don't do

00:19:08,020 --> 00:19:16,450
any hippo locations and we don't do any

00:19:12,610 --> 00:19:18,850
smart pointers management for you it has

00:19:16,450 --> 00:19:23,440
explicit like allocation at free calls

00:19:18,850 --> 00:19:25,690
for resources of course there is certain

00:19:23,440 --> 00:19:29,740
parts that we have to do in order for

00:19:25,690 --> 00:19:33,310
the same API to run on d3 12 and metal

00:19:29,740 --> 00:19:35,350
so this is not exactly zero cost in that

00:19:33,310 --> 00:19:37,660
sense this is as low cost as we can

00:19:35,350 --> 00:19:40,320
afford but this is this goes in line not

00:19:37,660 --> 00:19:43,300
in our own reasoning but more in line of

00:19:40,320 --> 00:19:45,850
the Vulcan portability technical

00:19:43,300 --> 00:19:49,900
subgroup and the design that we're doing

00:19:45,850 --> 00:19:52,210
as a part of the group so it's very

00:19:49,900 --> 00:19:55,990
little minimum overhead we can't afford

00:19:52,210 --> 00:19:58,230
any extra GPU work for whatever we're

00:19:55,990 --> 00:19:58,230
doing

00:20:06,880 --> 00:20:24,650
is your question that we're losing quite

00:20:09,260 --> 00:20:25,909
a bit of common buffers in metal okay so

00:20:24,650 --> 00:20:27,590
the question is how do we deal with the

00:20:25,909 --> 00:20:30,409
performance loss from not being able to

00:20:27,590 --> 00:20:31,340
reuse common buffers in metal that is

00:20:30,409 --> 00:20:36,679
very unfortunate

00:20:31,340 --> 00:20:41,390
and what molten vicki is doing as one of

00:20:36,679 --> 00:20:43,880
our competitors technically is having a

00:20:41,390 --> 00:20:47,710
like a software a list of commands build

00:20:43,880 --> 00:20:49,970
up independent of the hardware list so I

00:20:47,710 --> 00:20:53,679
don't think we have that included right

00:20:49,970 --> 00:20:53,679
now but that's the plan right now

00:21:01,550 --> 00:21:08,340
other any plans for the graphical UI

00:21:04,560 --> 00:21:10,080
toolkit we are extremely busy with

00:21:08,340 --> 00:21:12,300
making sure that the hardware

00:21:10,080 --> 00:21:17,070
abstraction layer like the lowest level

00:21:12,300 --> 00:21:21,540
of abstraction works and our next steps

00:21:17,070 --> 00:21:23,580
are more in terms of getting the like

00:21:21,540 --> 00:21:26,220
frame graph sort of libraries or the

00:21:23,580 --> 00:21:29,460
memory management libraries solid before

00:21:26,220 --> 00:21:33,210
we can think about the UI however I

00:21:29,460 --> 00:21:36,900
expect Conrad to be able to report it on

00:21:33,210 --> 00:21:42,030
GFX Hall eventually it's a graphical UI

00:21:36,900 --> 00:21:44,040
toolkit for rust as well as our friendly

00:21:42,030 --> 00:21:46,560
amethyst folks are likely to come up

00:21:44,040 --> 00:21:48,830
with something too so we hope for your

00:21:46,560 --> 00:21:48,830
help

00:22:12,490 --> 00:22:19,250
so historically before the you write we

00:22:15,830 --> 00:22:21,350
required we require sorry the question

00:22:19,250 --> 00:22:23,740
was how do we handle shaders with

00:22:21,350 --> 00:22:26,840
regards to different platforms

00:22:23,740 --> 00:22:28,610
historically we required the users to

00:22:26,840 --> 00:22:30,260
provide all the shaders for the backends

00:22:28,610 --> 00:22:33,980
that they use like separate shaders for

00:22:30,260 --> 00:22:36,710
metal OpenGL and d3 at 11:00 after the

00:22:33,980 --> 00:22:39,910
rewrite as we are going for the Vulcan

00:22:36,710 --> 00:22:42,410
portability goal we only accepts PRV and

00:22:39,910 --> 00:22:45,080
from spare v we generate all the backend

00:22:42,410 --> 00:22:47,060
specific shaders we patched the logic

00:22:45,080 --> 00:22:50,330
like coordinate systems and descriptors

00:22:47,060 --> 00:22:52,520
IDs according to the specifics of the

00:22:50,330 --> 00:22:55,730
backend that we are translating the

00:22:52,520 --> 00:22:58,910
shader into we're using the spirit

00:22:55,730 --> 00:23:02,720
across as like a helper library to do

00:22:58,910 --> 00:23:05,840
that and our far future far plans would

00:23:02,720 --> 00:23:08,060
be to have a rust alternative to that as

00:23:05,840 --> 00:23:10,790
well since that's the biggest non rust

00:23:08,060 --> 00:23:12,980
component that we use right now so right

00:23:10,790 --> 00:23:15,020
now you supply your shaders in spirit II

00:23:12,980 --> 00:23:17,840
of course the most convenient way to do

00:23:15,020 --> 00:23:20,420
that would be to write it in GLSL say

00:23:17,840 --> 00:23:23,990
4.1 and then have them converted using

00:23:20,420 --> 00:23:25,580
gel assault asperity that's what warden

00:23:23,990 --> 00:23:28,640
test framework is saying at least you

00:23:25,580 --> 00:23:31,600
writer shaders in like geocell and tests

00:23:28,640 --> 00:23:31,600
them against Barry

00:23:53,870 --> 00:24:00,799
so the question the question is how does

00:23:57,049 --> 00:24:03,620
web GPU is going to expose Volk and even

00:24:00,799 --> 00:24:07,039
the WebGL is way higher level

00:24:03,620 --> 00:24:09,529
so yes it's a hard question and volcán

00:24:07,039 --> 00:24:12,020
is a hard sell for multiple reasons on

00:24:09,529 --> 00:24:14,659
the web not only because it's low level

00:24:12,020 --> 00:24:16,340
but all the consequences from it is like

00:24:14,659 --> 00:24:19,070
it's easy to build a user signature

00:24:16,340 --> 00:24:21,230
based on what you worry about what

00:24:19,070 --> 00:24:23,960
device can do and on the web it's not

00:24:21,230 --> 00:24:26,960
safe and there's a whole lot of concerns

00:24:23,960 --> 00:24:29,210
that not only make not only Valken but

00:24:26,960 --> 00:24:32,870
in general go in any low level on the

00:24:29,210 --> 00:24:35,600
graphic side to slightly start breaking

00:24:32,870 --> 00:24:38,750
the rules of the web so we're trying to

00:24:35,600 --> 00:24:40,580
find our philosophy there and our

00:24:38,750 --> 00:24:43,419
priority is getting like the maximum

00:24:40,580 --> 00:24:43,419
performance of the web

00:24:47,920 --> 00:24:58,720
[Applause]

00:24:54,790 --> 00:24:58,720

YouTube URL: https://www.youtube.com/watch?v=oy6xFkJcoi8


