Title: Jos van den Oever - Qt GUIs with Rust
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	Rust Qt Binding Generator

Build a graphical application with Qt and Rust. Qt is a mature GUI library. Rust is a new, exciting and strict programming language. You can build most of your application logic in Rust and write the GUI in QML or Qt Widgets.

This talks will walk through how to do this with Rust Qt Binding Generator.

Jos van den Oever represents the Dutch government on the ODF Technical Committee. He has worked in the Free Software community for over a decade. He created WebODF, an ODF editor for the browser. He is active in the KDE community.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_qt_binding_generator/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:05,940 --> 00:00:11,740
we've got your Thunder Google is going

00:00:08,830 --> 00:00:15,150
to talk about rust with beauty please

00:00:11,740 --> 00:00:15,150
give me a real warm welcome

00:00:19,140 --> 00:00:25,360
well thank you very much I'm happy to

00:00:23,199 --> 00:00:27,039
finally may have made it into this room

00:00:25,360 --> 00:00:32,680
it turned out you have to be speaker and

00:00:27,039 --> 00:00:36,370
then it's easy to get in so I assume

00:00:32,680 --> 00:00:38,290
that most people here are firstly Russ

00:00:36,370 --> 00:00:40,150
developers and maybe secondly also

00:00:38,290 --> 00:00:42,489
there's some cute guys here so who is a

00:00:40,150 --> 00:00:45,430
cute developer here just to oh great

00:00:42,489 --> 00:00:47,589
quite a few yeah so some of the stuff

00:00:45,430 --> 00:00:50,799
will look more familiar to you then most

00:00:47,589 --> 00:00:52,659
of the other stuff so I yeah for the

00:00:50,799 --> 00:00:54,909
people who don't know cute so much I've

00:00:52,659 --> 00:00:58,390
also had some have added some code

00:00:54,909 --> 00:01:00,100
examples there since there are not so

00:00:58,390 --> 00:01:02,769
many cute developers I think also this

00:01:00,100 --> 00:01:06,520
image here who has ever seen this image

00:01:02,769 --> 00:01:10,119
before two people yeah I guess three

00:01:06,520 --> 00:01:11,830
even right so this is like a logo which

00:01:10,119 --> 00:01:13,600
was on the top of the documentation of

00:01:11,830 --> 00:01:17,650
cute one there about so it's like

00:01:13,600 --> 00:01:21,130
somewhere in the 90s but considering

00:01:17,650 --> 00:01:24,490
that combining worst and cute is not so

00:01:21,130 --> 00:01:26,980
easy I thought this sort of man looking

00:01:24,490 --> 00:01:29,740
a bit distraught would be a good opening

00:01:26,980 --> 00:01:32,260
image for this talk but the good news is

00:01:29,740 --> 00:01:35,409
it's actually totally feasible to

00:01:32,260 --> 00:01:36,970
combine those two things and the rest

00:01:35,409 --> 00:01:40,870
cute binding generator will help you

00:01:36,970 --> 00:01:42,850
with that to start us off well a

00:01:40,870 --> 00:01:45,909
takeaway I think this talk would be good

00:01:42,850 --> 00:01:48,310
for for us developers for cue developers

00:01:45,909 --> 00:01:49,990
for people developing cute because I

00:01:48,310 --> 00:01:51,909
think they can learn enough a lot from

00:01:49,990 --> 00:01:53,710
the worst language but also people who

00:01:51,909 --> 00:01:56,770
are interested in writing a native ques

00:01:53,710 --> 00:01:58,960
native rust UI learning from what cute

00:01:56,770 --> 00:02:00,790
has done over the past 20 years could

00:01:58,960 --> 00:02:03,549
also be very insightful so for them I

00:02:00,790 --> 00:02:05,880
hope this talk is also one that has some

00:02:03,549 --> 00:02:08,890
nice messages so here are three

00:02:05,880 --> 00:02:11,200
applications this is a tiny one that I

00:02:08,890 --> 00:02:14,319
blogged a while back and which was also

00:02:11,200 --> 00:02:16,450
on the west reddit as a tutorial this is

00:02:14,319 --> 00:02:18,930
basically a qml application I'll explain

00:02:16,450 --> 00:02:22,690
later what qml is that is powered by

00:02:18,930 --> 00:02:24,639
rust and all that was does here is it

00:02:22,690 --> 00:02:26,469
has a threat and it gives some seconds

00:02:24,639 --> 00:02:28,980
of every second has an event and then

00:02:26,469 --> 00:02:31,340
this rust mogul rotates

00:02:28,980 --> 00:02:34,769
the rustic you'd binding generator

00:02:31,340 --> 00:02:37,170
repository has a demo application which

00:02:34,769 --> 00:02:40,590
showcases all the different styles of

00:02:37,170 --> 00:02:42,810
widgets you have in cute so this is just

00:02:40,590 --> 00:02:45,959
a different styling but you can also use

00:02:42,810 --> 00:02:48,150
cute quick which is a type of widget

00:02:45,959 --> 00:02:51,300
that is very much optimized for your

00:02:48,150 --> 00:02:53,700
graphics processor and we also have cute

00:02:51,300 --> 00:02:56,660
quick controls too which is more in line

00:02:53,700 --> 00:03:00,090
with what you see on mobile devices and

00:02:56,660 --> 00:03:04,380
all of these things are bundled into one

00:03:00,090 --> 00:03:07,590
application here but later on in this

00:03:04,380 --> 00:03:09,329
talk will mostly be talking about this

00:03:07,590 --> 00:03:12,000
demo application we're going to walk

00:03:09,329 --> 00:03:15,750
through how to write code like this to

00:03:12,000 --> 00:03:21,329
power a to-do application with rust and

00:03:15,750 --> 00:03:24,390
cute so back to the slides the goal of

00:03:21,329 --> 00:03:27,239
this project was to find a way to write

00:03:24,390 --> 00:03:29,730
programs that combine Q robust but since

00:03:27,239 --> 00:03:31,260
I was doing in the server as a hobby it

00:03:29,730 --> 00:03:33,540
should be a small effort to create this

00:03:31,260 --> 00:03:35,280
tool but when it's finished it should

00:03:33,540 --> 00:03:37,680
also be small I've had to actually use

00:03:35,280 --> 00:03:39,870
it it should be easy to combine these

00:03:37,680 --> 00:03:42,900
two languages even though C++

00:03:39,870 --> 00:03:44,690
arrests also very different it should be

00:03:42,900 --> 00:03:46,950
simple with minimal dependencies and

00:03:44,690 --> 00:03:48,510
this is very important to me the end

00:03:46,950 --> 00:03:51,900
result should be that you write good

00:03:48,510 --> 00:03:55,290
cute code and good worst code and and

00:03:51,900 --> 00:03:59,130
not rust with ugly cute or cute with

00:03:55,290 --> 00:04:00,200
ugly rust so where what is cute and

00:03:59,130 --> 00:04:02,549
where is it used

00:04:00,200 --> 00:04:07,680
these are logos from some of the

00:04:02,549 --> 00:04:09,690
projects that are using cute here's one

00:04:07,680 --> 00:04:14,489
that Linus Torvalds helps coding VLC you

00:04:09,690 --> 00:04:18,229
all know the KDE community is basically

00:04:14,489 --> 00:04:22,680
built on cute the the plasma desktop

00:04:18,229 --> 00:04:24,810
uses cutes you can write 3d applications

00:04:22,680 --> 00:04:27,690
with cute and there you have a sort of

00:04:24,810 --> 00:04:31,680
state state machine to steer everything

00:04:27,690 --> 00:04:34,800
so it's a very rich very large set of

00:04:31,680 --> 00:04:37,860
libraries to write your user interface

00:04:34,800 --> 00:04:41,569
in and therefore it would be great if

00:04:37,860 --> 00:04:44,300
you could use it with worst

00:04:41,569 --> 00:04:46,610
also in the embedded world cute is used

00:04:44,300 --> 00:04:48,229
a lot here's a picture from a promo

00:04:46,610 --> 00:04:50,389
video and you see that they're pointing

00:04:48,229 --> 00:04:52,669
the cute logo to lots of parts of the

00:04:50,389 --> 00:04:54,169
car not exactly sure what they mean by

00:04:52,669 --> 00:04:56,949
that but I think the overall message is

00:04:54,169 --> 00:04:59,770
we have some low-power processors and a

00:04:56,949 --> 00:05:02,479
display on it and we power it with cute

00:04:59,770 --> 00:05:05,360
so you can also put it on your fridge or

00:05:02,479 --> 00:05:08,180
on your thermostat whatever there are

00:05:05,360 --> 00:05:10,610
tons of bindings already for cute lots

00:05:08,180 --> 00:05:13,729
of different languages and yeah why do

00:05:10,610 --> 00:05:15,529
you normally have bindings do you want

00:05:13,729 --> 00:05:16,129
to use a language which is more familiar

00:05:15,529 --> 00:05:18,379
to you

00:05:16,129 --> 00:05:19,819
cute itself is written in C++ and maybe

00:05:18,379 --> 00:05:22,490
you're more familiar with one of the

00:05:19,819 --> 00:05:24,949
languages on top here or you have a

00:05:22,490 --> 00:05:28,789
large project and maybe all the guys

00:05:24,949 --> 00:05:30,919
from the lots of logos before existing

00:05:28,789 --> 00:05:32,899
projects are interested in adding some

00:05:30,919 --> 00:05:35,300
rest into their into their mix into the

00:05:32,899 --> 00:05:38,089
projects so you might want to combine

00:05:35,300 --> 00:05:40,729
existing code with it and then you also

00:05:38,089 --> 00:05:43,669
need a library the typical approach to

00:05:40,729 --> 00:05:45,830
do a binding is to take the cute C++

00:05:43,669 --> 00:05:48,139
base build a binding on top and then put

00:05:45,830 --> 00:05:50,330
the other language there and that's not

00:05:48,139 --> 00:05:51,979
the approach I'm going to take here and

00:05:50,330 --> 00:05:55,219
I'll explain later

00:05:51,979 --> 00:05:57,680
what we are going to do well I guess you

00:05:55,219 --> 00:06:01,819
know these advantages by heart why it

00:05:57,680 --> 00:06:02,959
was so cool it's very safe one of my

00:06:01,819 --> 00:06:05,539
favorite things the first is the

00:06:02,959 --> 00:06:07,310
algebraic data types also known as

00:06:05,539 --> 00:06:09,080
simply the in Arms that's something that

00:06:07,310 --> 00:06:12,830
C++ simply doesn't have I think it's

00:06:09,080 --> 00:06:15,589
great the markers are very clever cargo

00:06:12,830 --> 00:06:18,770
is great but all of these things are not

00:06:15,589 --> 00:06:21,229
really there in C++ at least not in the

00:06:18,770 --> 00:06:23,149
way that QED uses them it's a great

00:06:21,229 --> 00:06:25,729
library but these innovations in rust

00:06:23,149 --> 00:06:27,589
simply haven't made it into cutely yet

00:06:25,729 --> 00:06:30,020
so if you're going to make an API of

00:06:27,589 --> 00:06:32,539
rust on top of cute then we're leaving a

00:06:30,020 --> 00:06:35,479
lot of advantages on the table so that's

00:06:32,539 --> 00:06:37,909
why I think that wrapping a cute API in

00:06:35,479 --> 00:06:40,569
rust would be like fitting a square peg

00:06:37,909 --> 00:06:44,389
in a round hole that's not going to work

00:06:40,569 --> 00:06:46,279
but there's a solution what we could do

00:06:44,389 --> 00:06:50,449
is just shine a light differently on it

00:06:46,279 --> 00:06:53,269
and well here's the square year's round

00:06:50,449 --> 00:06:55,479
great we just put some JSON in the

00:06:53,269 --> 00:06:55,479
middle

00:06:55,509 --> 00:07:01,009
so yeah how will that work okay so we're

00:06:59,930 --> 00:07:03,439
going to do the binding in two

00:07:01,009 --> 00:07:05,509
directions first you're gonna write your

00:07:03,439 --> 00:07:07,699
data model in JSON and I'll show you

00:07:05,509 --> 00:07:09,499
later how to do that and then you

00:07:07,699 --> 00:07:12,379
generate bindings from that and these

00:07:09,499 --> 00:07:14,869
bindings talk to your user interface and

00:07:12,379 --> 00:07:16,399
to us and all the purple boxes here

00:07:14,869 --> 00:07:18,589
stuff that you have to write so if you

00:07:16,399 --> 00:07:20,960
came in here thinking I'm gonna write a

00:07:18,589 --> 00:07:22,669
user interface only arrest that's not

00:07:20,960 --> 00:07:25,069
what this talk is about you still will

00:07:22,669 --> 00:07:27,139
have to either use qml which is a very

00:07:25,069 --> 00:07:30,110
nice declarative language or cute which

00:07:27,139 --> 00:07:31,849
is C++ on top of your worst but the

00:07:30,110 --> 00:07:34,610
advantages if you take this approach

00:07:31,849 --> 00:07:37,669
then you have separated the logic of

00:07:34,610 --> 00:07:39,110
your application very well and if you

00:07:37,669 --> 00:07:42,800
want you could also put then a different

00:07:39,110 --> 00:07:46,249
UI on top like HTML so this is the

00:07:42,800 --> 00:07:48,740
approach we're going to take now I need

00:07:46,249 --> 00:07:50,809
to explain a bit about the core

00:07:48,740 --> 00:07:54,860
principle of how cute works the basic

00:07:50,809 --> 00:07:59,120
thing in cute is Q objects a Q object is

00:07:54,860 --> 00:08:02,149
a class and you can give it signals and

00:07:59,120 --> 00:08:05,569
slots and outside of cute people call

00:08:02,149 --> 00:08:07,639
these things events and listeners and so

00:08:05,569 --> 00:08:10,939
you combine build a loosely coupled

00:08:07,639 --> 00:08:12,259
system and it's loosely coupled if one

00:08:10,939 --> 00:08:14,419
of the object is destroyed then the

00:08:12,259 --> 00:08:16,999
connection is broken it's the same as

00:08:14,419 --> 00:08:19,279
what you have in JavaScript I imagine so

00:08:16,999 --> 00:08:21,499
it takes care of memory manager because

00:08:19,279 --> 00:08:22,879
you have hierarchical ownership you just

00:08:21,499 --> 00:08:24,229
say when you create something this is

00:08:22,879 --> 00:08:27,110
the parent when you destroyed the whole

00:08:24,229 --> 00:08:29,899
hayek hierarchies destroyed and objects

00:08:27,110 --> 00:08:31,729
have properties now there's another

00:08:29,899 --> 00:08:34,399
important building block in cute and

00:08:31,729 --> 00:08:37,130
that's the cue abstract item model a

00:08:34,399 --> 00:08:40,279
long complex name but basically what it

00:08:37,130 --> 00:08:44,930
is it's the way data is represented from

00:08:40,279 --> 00:08:47,630
your logic to to the user interface and

00:08:44,930 --> 00:08:50,959
it's used everywhere so here is a table

00:08:47,630 --> 00:08:53,329
and a graph and there's one data model

00:08:50,959 --> 00:08:55,939
underneath which is an implementation of

00:08:53,329 --> 00:08:59,000
this model and it's used in two places

00:08:55,939 --> 00:09:01,220
in a very different way and here you see

00:08:59,000 --> 00:09:02,540
a table I'm not sure if everybody in the

00:09:01,220 --> 00:09:04,189
back and see it here but one of the

00:09:02,540 --> 00:09:06,529
cells on the table shows a percentage

00:09:04,189 --> 00:09:07,960
and it's filled partially and that's

00:09:06,529 --> 00:09:09,880
also a trick we

00:09:07,960 --> 00:09:12,760
she's implemented on the UI level but

00:09:09,880 --> 00:09:14,620
the data underneath is provided by this

00:09:12,760 --> 00:09:17,050
abstract item model and you can also

00:09:14,620 --> 00:09:19,000
have trees so this is used everywhere in

00:09:17,050 --> 00:09:22,300
cute but it's kind of hard to implement

00:09:19,000 --> 00:09:25,360
even if you just do it in C++ so the

00:09:22,300 --> 00:09:27,400
tool that I'm presenting is focusing

00:09:25,360 --> 00:09:32,050
very strongly on making it easy to do

00:09:27,400 --> 00:09:36,130
this so yet basically you can even

00:09:32,050 --> 00:09:37,870
forget about this and just know that

00:09:36,130 --> 00:09:42,250
we're gonna build a model which gives

00:09:37,870 --> 00:09:45,070
you all of that okay so how it's gonna

00:09:42,250 --> 00:09:47,740
work we write a model description in

00:09:45,070 --> 00:09:50,080
Jason and then the tool would generate a

00:09:47,740 --> 00:09:53,320
binding dot H and a binding dot CPP file

00:09:50,080 --> 00:09:55,810
which we use in our C++ code and an

00:09:53,320 --> 00:09:57,790
interface RS which will contain a trait

00:09:55,810 --> 00:10:01,750
arrest rate which you have to implement

00:09:57,790 --> 00:10:03,940
and then you compile your rest code into

00:10:01,750 --> 00:10:07,270
a static library which you link to your

00:10:03,940 --> 00:10:11,200
C++ application and you either import it

00:10:07,270 --> 00:10:14,350
with binding dot H or if you're using

00:10:11,200 --> 00:10:15,850
qml with import lost code the rest code

00:10:14,350 --> 00:10:17,680
is the name you can use you can think of

00:10:15,850 --> 00:10:25,750
yourself just this is what I use in my

00:10:17,680 --> 00:10:29,880
examples briefly about qml cute modeling

00:10:25,750 --> 00:10:32,800
language this is a very nice innovation

00:10:29,880 --> 00:10:36,100
which was triggered when Nokia bought

00:10:32,800 --> 00:10:38,320
cute they wanted to make phones with

00:10:36,100 --> 00:10:40,750
very performant and easy to write user

00:10:38,320 --> 00:10:42,820
interfaces so what they did is they came

00:10:40,750 --> 00:10:47,220
up with a declarative user interface

00:10:42,820 --> 00:10:50,170
language and it can do to the do to deal

00:10:47,220 --> 00:10:51,730
programs or 3d even and it's used in

00:10:50,170 --> 00:10:54,070
lots of mobile applications so it

00:10:51,730 --> 00:10:55,630
started off at Nokia megaphones the

00:10:54,070 --> 00:10:59,440
bunch of phones are using it everywhere

00:10:55,630 --> 00:11:02,080
sailfish KDE plasma desktop KDE plasma

00:10:59,440 --> 00:11:04,500
mobile and you can also use it for iOS

00:11:02,080 --> 00:11:06,880
and Android apps if you like that stuff

00:11:04,500 --> 00:11:10,300
which apparently is the majority of the

00:11:06,880 --> 00:11:12,960
people it's designed for efficiency on

00:11:10,300 --> 00:11:15,190
graphics cards so and that's actually

00:11:12,960 --> 00:11:17,890
when we're talking about rust is not

00:11:15,190 --> 00:11:19,540
unlike web render which is as quite a

00:11:17,890 --> 00:11:21,100
lot of similarities in the way it's

00:11:19,540 --> 00:11:24,620
designed

00:11:21,100 --> 00:11:26,720
okay so now we're going to write a small

00:11:24,620 --> 00:11:29,870
application so you understand a bit more

00:11:26,720 --> 00:11:32,570
of how all of this works together this

00:11:29,870 --> 00:11:38,060
is a to do application and this

00:11:32,570 --> 00:11:42,770
application there is a website called to

00:11:38,060 --> 00:11:44,720
do MVC comm where the same specification

00:11:42,770 --> 00:11:48,380
is implemented in like 20 or 30

00:11:44,720 --> 00:11:50,149
different JavaScript frameworks and I

00:11:48,380 --> 00:11:53,660
took that specification and implemented

00:11:50,149 --> 00:11:55,279
this with qml arrests just because I

00:11:53,660 --> 00:11:56,690
didn't really know what I should write I

00:11:55,279 --> 00:11:58,820
thought well here's a specification

00:11:56,690 --> 00:12:02,080
already given let's just implement that

00:11:58,820 --> 00:12:05,540
and I can look at application here a bit

00:12:02,080 --> 00:12:09,560
so what else should I need to do well

00:12:05,540 --> 00:12:12,649
keep talking I guess and you can tick

00:12:09,560 --> 00:12:15,050
off stuff here and you can just see the

00:12:12,649 --> 00:12:17,600
active parts or only the completed ones

00:12:15,050 --> 00:12:20,870
I can come clear the stuff that's

00:12:17,600 --> 00:12:23,600
completed go back to all I can toggle

00:12:20,870 --> 00:12:26,330
here everything so it has some basic

00:12:23,600 --> 00:12:28,700
functionality and this is the UI part of

00:12:26,330 --> 00:12:33,080
this is about 150 lines of code and the

00:12:28,700 --> 00:12:34,730
model beneath is is fairly simple so if

00:12:33,080 --> 00:12:37,700
you want to build this how do we start

00:12:34,730 --> 00:12:42,140
first we need to write the binding where

00:12:37,700 --> 00:12:45,350
we describe our model now the objects we

00:12:42,140 --> 00:12:47,720
call todos and the type will be a list

00:12:45,350 --> 00:12:50,270
we have a list of to-do items what you

00:12:47,720 --> 00:12:54,290
can put here is either an object which

00:12:50,270 --> 00:12:55,610
is only one item or a list or a tree the

00:12:54,290 --> 00:12:57,260
it will have properties and the

00:12:55,610 --> 00:12:58,970
properties are there should be a count

00:12:57,260 --> 00:13:00,770
of a number of items and the active

00:12:58,970 --> 00:13:03,860
count which is the number of items I

00:13:00,770 --> 00:13:06,620
still need to do and every item in the

00:13:03,860 --> 00:13:09,560
list is either completed or not so this

00:13:06,620 --> 00:13:15,620
is a boolean field and it has a text a

00:13:09,560 --> 00:13:17,420
description probably some people here

00:13:15,620 --> 00:13:20,209
are thinking why not just write a rust

00:13:17,420 --> 00:13:23,260
macro well maybe we'll do that at some

00:13:20,209 --> 00:13:28,910
point but for now it's just adjacent

00:13:23,260 --> 00:13:30,620
description okay let's checked off now

00:13:28,910 --> 00:13:33,380
we need to run the generator

00:13:30,620 --> 00:13:34,760
so that's just one executable you call

00:13:33,380 --> 00:13:37,850
it with the file

00:13:34,760 --> 00:13:39,860
and this is set up like this so that you

00:13:37,850 --> 00:13:42,740
can integrate it at sea make over its

00:13:39,860 --> 00:13:44,870
cargo and build RS and this generates so

00:13:42,740 --> 00:13:46,699
these three files that I mentioned and

00:13:44,870 --> 00:13:49,310
then what I need to do is I need to

00:13:46,699 --> 00:13:53,720
write an implementation dot RS which is

00:13:49,310 --> 00:13:55,459
a rest file ok now we're going to look

00:13:53,720 --> 00:13:57,589
inside the three generated files and

00:13:55,459 --> 00:13:59,209
they're gonna look a bit complicated but

00:13:57,589 --> 00:14:02,240
you don't have to do that it's just to

00:13:59,209 --> 00:14:05,660
show you a bit of how it goes what goes

00:14:02,240 --> 00:14:09,110
on underneath so this is a bit of C++

00:14:05,660 --> 00:14:13,040
it's the class 2 deuce and it implements

00:14:09,110 --> 00:14:15,100
abstract item model it has a constructor

00:14:13,040 --> 00:14:18,560
a destructor it declares and properties

00:14:15,100 --> 00:14:20,899
and it declares also some functions for

00:14:18,560 --> 00:14:24,050
setting and getting the values so this

00:14:20,899 --> 00:14:27,290
is fairly simple and there's an

00:14:24,050 --> 00:14:30,680
implementation along with it so here is

00:14:27,290 --> 00:14:32,899
the foreign function interface that

00:14:30,680 --> 00:14:35,750
talks to us so these functions are

00:14:32,899 --> 00:14:38,149
declared in the C++ part and should be

00:14:35,750 --> 00:14:39,769
implemented by rusts you also won't have

00:14:38,149 --> 00:14:41,089
to do this but this is the point where

00:14:39,769 --> 00:14:44,420
the two languages meet where they

00:14:41,089 --> 00:14:50,209
connect up and here is a bit of example

00:14:44,420 --> 00:14:52,069
code which is typical for this data

00:14:50,209 --> 00:14:55,730
model you have the class and as a

00:14:52,069 --> 00:14:57,529
function data you give it an index and a

00:14:55,730 --> 00:15:01,819
world and the role can be I would like

00:14:57,529 --> 00:15:03,649
to have a display or a color or in our

00:15:01,819 --> 00:15:05,149
case the description or if it's

00:15:03,649 --> 00:15:08,240
completed or not that can also be your

00:15:05,149 --> 00:15:10,250
world and then here's this big switch

00:15:08,240 --> 00:15:13,339
statement which calls into the worst

00:15:10,250 --> 00:15:15,470
code so it calls to rust and asks get me

00:15:13,339 --> 00:15:18,920
the completed version for this index or

00:15:15,470 --> 00:15:21,110
the description for this index and again

00:15:18,920 --> 00:15:23,959
all of this is generated so you don't

00:15:21,110 --> 00:15:26,630
have to worry about it but how does it

00:15:23,959 --> 00:15:29,569
look on the rough side well on the west

00:15:26,630 --> 00:15:32,949
side we have a trait called the tool to

00:15:29,569 --> 00:15:36,649
deuce trait and it has a constructor

00:15:32,949 --> 00:15:40,069
which you need to implement and it has

00:15:36,649 --> 00:15:41,899
an emitter the emitter is there so that

00:15:40,069 --> 00:15:44,540
you can emit signals when something has

00:15:41,899 --> 00:15:47,899
changed so you can signal to the user

00:15:44,540 --> 00:15:48,800
interface that something has changed for

00:15:47,899 --> 00:15:53,029
example some I

00:15:48,800 --> 00:15:55,010
was added to the list as functions for

00:15:53,029 --> 00:15:59,269
inserting worse and here are the

00:15:55,010 --> 00:16:02,420
functions to get the value if number 1 2

00:15:59,269 --> 00:16:04,459
3 or 5 is completed or not and you can

00:16:02,420 --> 00:16:10,760
set it to be completed or it can get the

00:16:04,459 --> 00:16:13,519
description or set the description so 2

00:16:10,760 --> 00:16:15,820
items left and this is the work that you

00:16:13,519 --> 00:16:18,290
will have to do when you write

00:16:15,820 --> 00:16:20,060
connection when you write an application

00:16:18,290 --> 00:16:22,760
with rust and cute so we need to

00:16:20,060 --> 00:16:27,560
implement the rust part and the cute

00:16:22,760 --> 00:16:29,420
part so hurt the rust part we are

00:16:27,560 --> 00:16:32,720
implementing a list the list has items

00:16:29,420 --> 00:16:35,839
so we just have a struct with a boolean

00:16:32,720 --> 00:16:37,970
and a string so far so good and then we

00:16:35,839 --> 00:16:40,459
have the object that contains the whole

00:16:37,970 --> 00:16:43,790
list of these items and it also contains

00:16:40,459 --> 00:16:46,339
a account of how many items have not

00:16:43,790 --> 00:16:50,870
been finished yet this is a cached value

00:16:46,339 --> 00:16:55,220
and it has two objects to talk to the

00:16:50,870 --> 00:16:58,279
outside so the how now we implement

00:16:55,220 --> 00:17:01,520
implement the trade and this is also

00:16:58,279 --> 00:17:03,380
fairly simple we need to get the value

00:17:01,520 --> 00:17:06,230
for the active count and we just return

00:17:03,380 --> 00:17:08,150
the value also for the total count we

00:17:06,230 --> 00:17:10,610
just return the the length of the list

00:17:08,150 --> 00:17:12,770
and when we want to know the description

00:17:10,610 --> 00:17:16,459
at a certain index we just give back

00:17:12,770 --> 00:17:18,110
that value so this is quite

00:17:16,459 --> 00:17:19,610
straightforward and simple and this is

00:17:18,110 --> 00:17:22,459
the part which you will have to

00:17:19,610 --> 00:17:26,169
implement when you are writing a

00:17:22,459 --> 00:17:29,090
connection between wealth and cubes so

00:17:26,169 --> 00:17:35,270
how do we do the last bit of it and

00:17:29,090 --> 00:17:37,910
that's the qml part in our case we have

00:17:35,270 --> 00:17:40,070
created this object and this object we

00:17:37,910 --> 00:17:44,090
want to expose to this rust code to this

00:17:40,070 --> 00:17:46,100
cute code so we import the rust code we

00:17:44,090 --> 00:17:50,809
have called version 1 well you can give

00:17:46,100 --> 00:17:52,640
it any number you like the application

00:17:50,809 --> 00:17:55,910
window is basically something between

00:17:52,640 --> 00:17:58,250
brackets here so this is qml if in case

00:17:55,910 --> 00:18:01,580
you've never seen it it's a very fairly

00:17:58,250 --> 00:18:02,450
simple language and here we have our

00:18:01,580 --> 00:18:04,460
object so

00:18:02,450 --> 00:18:08,870
object here is what we have implemented

00:18:04,460 --> 00:18:11,240
with rust and we give it an ID so all of

00:18:08,870 --> 00:18:13,850
our to-do information is in this object

00:18:11,240 --> 00:18:16,280
and we put it here it's not a graphical

00:18:13,850 --> 00:18:19,310
thing but we we put it here so that we

00:18:16,280 --> 00:18:21,560
can access it from our graphical

00:18:19,310 --> 00:18:23,900
interface and our main graphical

00:18:21,560 --> 00:18:27,380
interface is below here that is

00:18:23,900 --> 00:18:30,050
applicable list view and it has a model

00:18:27,380 --> 00:18:33,200
the model is the to do model which we

00:18:30,050 --> 00:18:37,220
have defined here and we have a delegate

00:18:33,200 --> 00:18:39,020
and the delegate is the UI item that we

00:18:37,220 --> 00:18:41,540
show for every item in the list and

00:18:39,020 --> 00:18:43,940
that's defined here so it's a component

00:18:41,540 --> 00:18:47,750
and it has a pain and it has a checkbox

00:18:43,940 --> 00:18:49,640
the checkbox is the checkbox checked or

00:18:47,750 --> 00:18:52,040
not it's a declarative language it is

00:18:49,640 --> 00:18:54,350
checked if the value of completed is

00:18:52,040 --> 00:18:57,110
true so this is the information which is

00:18:54,350 --> 00:18:58,520
gotten from the rust side and this

00:18:57,110 --> 00:19:01,010
description is also gotten from the

00:18:58,520 --> 00:19:02,900
website but in here it just looks very

00:19:01,010 --> 00:19:05,840
natural you just write the name of the

00:19:02,900 --> 00:19:08,360
value you want and it's automatically

00:19:05,840 --> 00:19:12,020
assigned to this text here to the text

00:19:08,360 --> 00:19:18,530
of this label yeah and that's it

00:19:12,020 --> 00:19:21,560
so our application is done so in

00:19:18,530 --> 00:19:22,220
conclusion if you want to combine rust

00:19:21,560 --> 00:19:23,930
and cute

00:19:22,220 --> 00:19:26,660
you should not in my opinion at least

00:19:23,930 --> 00:19:29,870
shoehorn the whole of cute into a REST

00:19:26,660 --> 00:19:32,120
API but instead you should wrap your

00:19:29,870 --> 00:19:34,100
rust code in a cue object or acute

00:19:32,120 --> 00:19:36,740
abstract item model which you can then

00:19:34,100 --> 00:19:39,590
naturally use in your cute or qml

00:19:36,740 --> 00:19:40,910
application and by doing that and you

00:19:39,590 --> 00:19:43,580
don't actually have to do it yourself

00:19:40,910 --> 00:19:46,310
because the prosecute binding generator

00:19:43,580 --> 00:19:49,920
does it for you you get good cute code

00:19:46,310 --> 00:19:57,880
and good westco's that's it

00:19:49,920 --> 00:20:23,120
[Applause]

00:19:57,880 --> 00:20:25,130
yes yes okay so the question is how do

00:20:23,120 --> 00:20:27,860
you deal with different threats because

00:20:25,130 --> 00:20:29,900
cute must have a user interface threat

00:20:27,860 --> 00:20:32,840
well it does if you have a cute

00:20:29,900 --> 00:20:35,510
application the main threat the threat

00:20:32,840 --> 00:20:37,370
that you start is the cute threat and if

00:20:35,510 --> 00:20:40,010
you want additional threats in your rest

00:20:37,370 --> 00:20:41,870
code you will simply start when you

00:20:40,010 --> 00:20:44,690
construct your object you start a

00:20:41,870 --> 00:20:47,030
separate threat and that is then alive

00:20:44,690 --> 00:20:50,540
as long as your object is kept alive by

00:20:47,030 --> 00:20:53,870
your cute code so you can do any type of

00:20:50,540 --> 00:20:56,300
number of threats you can you can keep

00:20:53,870 --> 00:20:57,350
the running and the signals you send to

00:20:56,300 --> 00:20:59,810
the user interface

00:20:57,350 --> 00:21:01,460
those are threat safe but you don't have

00:20:59,810 --> 00:21:03,500
to worry about that it's automatically

00:21:01,460 --> 00:21:05,630
taken care of what you need to know is

00:21:03,500 --> 00:21:08,630
that in rust you can just start as many

00:21:05,630 --> 00:21:10,070
sets as you want in the object that is

00:21:08,630 --> 00:21:12,890
generated for you so in your

00:21:10,070 --> 00:21:30,890
implementation dot RS you can go wild

00:21:12,890 --> 00:21:32,960
with the threats you want yes the

00:21:30,890 --> 00:21:34,850
question is how do you do with build

00:21:32,960 --> 00:21:39,620
systems do you take a lot of advantage

00:21:34,850 --> 00:21:40,940
of cargo or not basically you're free to

00:21:39,620 --> 00:21:44,800
do whatever you like with your build

00:21:40,940 --> 00:21:47,420
system all you need to do is call this

00:21:44,800 --> 00:21:51,730
binary to generate the code for you and

00:21:47,420 --> 00:21:55,010
we have some templates that have C make

00:21:51,730 --> 00:21:56,600
which call into cargo but if you don't

00:21:55,010 --> 00:21:58,610
like that if you would like to put

00:21:56,600 --> 00:22:00,560
everything in cargo you're free to do

00:21:58,610 --> 00:22:03,100
that but this project doesn't currently

00:22:00,560 --> 00:22:06,380
do it but it's a matter of just calling

00:22:03,100 --> 00:22:09,470
calling that in in build RS

00:22:06,380 --> 00:22:14,140
in cargo yeah so it's not in the box but

00:22:09,470 --> 00:22:14,140
you can do it yes

00:22:20,340 --> 00:22:27,460
yeah the question is how do you do

00:22:23,740 --> 00:22:29,740
asynchronous work like with hyper for

00:22:27,460 --> 00:22:32,410
example or other Tokyo things that works

00:22:29,740 --> 00:22:36,370
exactly perfectly fine what you do is

00:22:32,410 --> 00:22:38,620
you your implementation those RS you set

00:22:36,370 --> 00:22:41,410
up your hyper or tokyo loop and that is

00:22:38,620 --> 00:22:43,360
running in your rust threat then which

00:22:41,410 --> 00:22:45,460
you sit which you create yourself and

00:22:43,360 --> 00:22:47,350
there you you set up everything for

00:22:45,460 --> 00:22:47,920
asynchronous IO and Q it is not involved

00:22:47,350 --> 00:22:49,360
at all

00:22:47,920 --> 00:22:51,910
whenever you get asynchronous

00:22:49,360 --> 00:22:53,710
information you can decide if it wants a

00:22:51,910 --> 00:22:55,900
signal to the user interface and then

00:22:53,710 --> 00:22:58,030
the user interface is updated so it's

00:22:55,900 --> 00:23:10,930
it's thread safe and it's kind of

00:22:58,030 --> 00:23:15,970
separate yes the question was where is

00:23:10,930 --> 00:23:20,070
the code that exposes the rust the Q

00:23:15,970 --> 00:23:20,070
objects to the qml is that a question

00:23:21,630 --> 00:23:27,460
they're initiating the qml scene yes

00:23:24,940 --> 00:23:29,650
okay so the question is how did you

00:23:27,460 --> 00:23:34,350
create the qml scene and how did you tie

00:23:29,650 --> 00:23:38,260
the the rough stuff into qml that was a

00:23:34,350 --> 00:23:40,480
10 line c++ file which i write i didn't

00:23:38,260 --> 00:23:46,050
show but it's mainly always the same you

00:23:40,480 --> 00:23:49,840
initiate your qml scene you instantiate

00:23:46,050 --> 00:23:51,880
you sorry you you you register your rust

00:23:49,840 --> 00:23:54,600
object into the UML scene and you're

00:23:51,880 --> 00:23:57,880
done it's off to the races

00:23:54,600 --> 00:24:01,530
yeah but it's always the same so you can

00:23:57,880 --> 00:24:04,530
copy the file from a template yeah yeah

00:24:01,530 --> 00:24:04,530
yes

00:24:24,399 --> 00:24:44,119
right hey okay repeat the first part of

00:24:27,859 --> 00:24:45,889
the question yes yes right yeah the

00:24:44,119 --> 00:24:49,940
question again is how do you register

00:24:45,889 --> 00:24:54,349
the the rust cute objects to the qml and

00:24:49,940 --> 00:24:57,259
can I do it live as well the answer is

00:24:54,349 --> 00:24:59,479
the same you do what you normally do on

00:24:57,259 --> 00:25:01,849
the C++ site is you have a cue object

00:24:59,479 --> 00:25:05,539
you instantiate it and you register it

00:25:01,849 --> 00:25:06,979
to the qml scene and yes I am pretty

00:25:05,539 --> 00:25:13,959
sure you can do it life although I don't

00:25:06,979 --> 00:25:13,959
have an example which does that yes

00:25:22,320 --> 00:25:26,040
yet the question is the implementation

00:25:24,450 --> 00:25:28,080
looks pretty straightforward have you

00:25:26,040 --> 00:25:33,000
considered doing it with derive and I

00:25:28,080 --> 00:25:37,050
assume that you mean derive on the rough

00:25:33,000 --> 00:25:39,210
side so basically amico I'm not entirely

00:25:37,050 --> 00:25:45,240
sure how the rive is implemented to be

00:25:39,210 --> 00:25:49,160
honest okay yeah so could you implement

00:25:45,240 --> 00:25:52,560
this in rust as annotation on a class

00:25:49,160 --> 00:25:54,420
you probably could yes you probably

00:25:52,560 --> 00:25:57,030
could I simply haven't done so because

00:25:54,420 --> 00:25:58,850
initially I wanted to be very hands-on

00:25:57,030 --> 00:26:02,280
on the code that was generated in fact

00:25:58,850 --> 00:26:04,440
all the demo codes and the testing code

00:26:02,280 --> 00:26:06,270
which is in the project which is

00:26:04,440 --> 00:26:09,270
generated is also committed so that

00:26:06,270 --> 00:26:11,250
whenever I change the generator to that

00:26:09,270 --> 00:26:14,220
I have a sort of testing that the code

00:26:11,250 --> 00:26:16,200
is still the same and if I would have

00:26:14,220 --> 00:26:17,640
done it way to derive then it would be

00:26:16,200 --> 00:26:19,110
only there during the compile step and

00:26:17,640 --> 00:26:20,550
it would a bit I would need to do some

00:26:19,110 --> 00:26:27,390
different things to actually check but

00:26:20,550 --> 00:26:30,740
it's perfectly possible yes yes oh yeah

00:26:27,390 --> 00:26:30,740
that's fine yep

00:26:34,200 --> 00:26:36,260

YouTube URL: https://www.youtube.com/watch?v=fJ-6wsn1bZg


