Title: Nikita Baksalyar - Demystifying Rust Parsing
Publication date: 2018-02-06
Playlist: FOSDEM Rust Devroom 2018
Description: 
	Language parsing and automatic binding generation



Usually, the topic of parsing the Rust source code is associated with the Rust compiler itself, which for many is an uncharted territory. However, parsing by itself can (and should) be used out of the context of the Rust compiler: given the wealth of information that we can extract out of the code, we can do a lot of thing with it.

In this talk, we'll discuss several interesting applications for the Rust parser and the abstract syntax trees it produces, with practical examples of Mozilla bindgen (automatic generation of Rust library bindings based on C source code) and a Java binding generator written by the author for a large-scale open source library.

Some prior basic knowledge of compilers and parsing is expected.

The intended audience is Rust developers who want to learn more about the internal implementation of the Rust compiler and to practically apply this knowledge in their projects.

Nikita is a Mozilla Tech Speaker and a Rust engineer at MaidSafe, developing an open source peer-to-peer network technology and contributing to other open-source projects, including the Rust compiler. He's enthusiastic about the Rust programming language, also interested in low-level development, P2P networks, and alternative operating systems (like e.g. BSD/Illumos).

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_demystifying_parsing/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:07,549 --> 00:00:11,570
so our next speaker is

00:00:15,940 --> 00:00:22,350
hey thanks a lot and first let me

00:00:20,140 --> 00:00:25,960
introduce myself and before that let me

00:00:22,350 --> 00:00:29,110
say that it's always great to see so

00:00:25,960 --> 00:00:31,540
many people in this room people who are

00:00:29,110 --> 00:00:34,830
interested in rust and the language

00:00:31,540 --> 00:00:38,140
itself has started about two years ago

00:00:34,830 --> 00:00:41,199
less than a little bit more than two

00:00:38,140 --> 00:00:42,610
years ago and there will were maybe a

00:00:41,199 --> 00:00:44,920
couple of hundreds of people who were

00:00:42,610 --> 00:00:46,839
interested in that language and now it's

00:00:44,920 --> 00:00:49,000
really great to see that is getting

00:00:46,839 --> 00:00:53,039
traction and see a lot of people in this

00:00:49,000 --> 00:00:56,110
room who are interested in this topic so

00:00:53,039 --> 00:00:58,899
introducing myself my name is Nikita I

00:00:56,110 --> 00:01:01,690
work at made safe and might safe is a

00:00:58,899 --> 00:01:05,050
company that develops peer-to-peer

00:01:01,690 --> 00:01:07,840
network technology and I think we have

00:01:05,050 --> 00:01:11,200
one of the largest code bases that are

00:01:07,840 --> 00:01:15,490
written in rust so today I want to share

00:01:11,200 --> 00:01:17,649
or share my experience developing one of

00:01:15,490 --> 00:01:22,119
the comprise one of the libraries that

00:01:17,649 --> 00:01:27,550
comprise our stack and they want to talk

00:01:22,119 --> 00:01:31,420
to you about parsing so Parsi is one of

00:01:27,550 --> 00:01:34,660
the crucial steps in the company in the

00:01:31,420 --> 00:01:39,399
topic of compilers and the compilers is

00:01:34,660 --> 00:01:41,800
a a complex topic by itself so it's it

00:01:39,399 --> 00:01:46,060
will be almost impossible to cover all

00:01:41,800 --> 00:01:48,700
the things that go into compilers in 20

00:01:46,060 --> 00:01:52,599
minutes so this will be more like more

00:01:48,700 --> 00:01:56,229
of an observant talk so I will cover the

00:01:52,599 --> 00:01:59,140
basics and my goal here my goal today is

00:01:56,229 --> 00:02:01,450
not to give you the entirety of

00:01:59,140 --> 00:02:04,929
information about compilers but to

00:02:01,450 --> 00:02:09,190
inspire you and basically to pique your

00:02:04,929 --> 00:02:11,739
interest and actually compilers is a

00:02:09,190 --> 00:02:15,040
complex topic and a lot of people are

00:02:11,739 --> 00:02:17,739
scared but it they opened the Dragon

00:02:15,040 --> 00:02:19,930
book they see that it consists of more

00:02:17,739 --> 00:02:21,910
than thousand pages and they close the

00:02:19,930 --> 00:02:24,520
book and never read it again but

00:02:21,910 --> 00:02:27,880
actually compilers are very interesting

00:02:24,520 --> 00:02:29,740
topic and if you take one part of it

00:02:27,880 --> 00:02:36,400
they can be immensely

00:02:29,740 --> 00:02:40,630
useful and they're not that complex so

00:02:36,400 --> 00:02:43,060
let's start from the basics so how how

00:02:40,630 --> 00:02:45,670
parsing can be useful for you so what is

00:02:43,060 --> 00:02:49,530
actually parsing so if you don't know it

00:02:45,670 --> 00:02:52,900
is one of the steps in the compiler you

00:02:49,530 --> 00:02:55,240
know which allows you to extract meta

00:02:52,900 --> 00:02:57,910
information about your code so you can

00:02:55,240 --> 00:03:00,670
actually imagine the compiler as a kind

00:02:57,910 --> 00:03:04,060
of a pipeline that consists of several

00:03:00,670 --> 00:03:09,520
steps and the first step in the compiler

00:03:04,060 --> 00:03:12,580
is the lexical parsing or the excuse me

00:03:09,520 --> 00:03:16,240
the lexical analysis the lexical

00:03:12,580 --> 00:03:20,460
analysis is a simplest step that gets

00:03:16,240 --> 00:03:25,300
your code in its text representation and

00:03:20,460 --> 00:03:28,480
transforms it to a set of tokens a token

00:03:25,300 --> 00:03:31,480
is a very simple thing and can be

00:03:28,480 --> 00:03:34,540
thought of as a word it can be a keyword

00:03:31,480 --> 00:03:36,280
it can be a string out of your code it

00:03:34,540 --> 00:03:39,040
can be a number it can be basically

00:03:36,280 --> 00:03:45,850
anything the return return is a curl is

00:03:39,040 --> 00:03:48,730
a token a fan is a token but have a just

00:03:45,850 --> 00:03:51,670
jokin x' we can't do many useful things

00:03:48,730 --> 00:03:55,900
with them right we can do many useful

00:03:51,670 --> 00:03:59,620
things with just code as text so what we

00:03:55,900 --> 00:04:03,460
do here is we put tokens in a token in

00:03:59,620 --> 00:04:08,860
token trees and out of those token trees

00:04:03,460 --> 00:04:13,570
we create out of those token trees we

00:04:08,860 --> 00:04:16,000
create a data structure that's that is

00:04:13,570 --> 00:04:21,070
called abstract syntax tree or SD for

00:04:16,000 --> 00:04:23,800
shirt HD allows us to extract meta

00:04:21,070 --> 00:04:26,140
information out of our codes and use

00:04:23,800 --> 00:04:28,620
this information to do basically

00:04:26,140 --> 00:04:28,620
anything

00:04:32,200 --> 00:04:38,690
so how do we apply is these for our

00:04:36,140 --> 00:04:41,840
practical gold you might think that HDS

00:04:38,690 --> 00:04:45,320
are usable only for the rats compiler

00:04:41,840 --> 00:04:48,860
itself or for now building some I don't

00:04:45,320 --> 00:04:51,140
know some utilities or things that

00:04:48,860 --> 00:04:56,000
belong to the Ross compiler but actually

00:04:51,140 --> 00:04:58,100
these have many everyday applications so

00:04:56,000 --> 00:05:00,260
you can extract metal information from

00:04:58,100 --> 00:05:03,710
your code and based on that information

00:05:00,260 --> 00:05:07,670
you can generate code in other languages

00:05:03,710 --> 00:05:09,740
this is very useful if you want to for

00:05:07,670 --> 00:05:11,810
example if you deal with F of Phi or a

00:05:09,740 --> 00:05:15,440
foreign function interface and you want

00:05:11,810 --> 00:05:17,900
to create a library in rust that you

00:05:15,440 --> 00:05:20,510
want to be make usable from other

00:05:17,900 --> 00:05:23,390
languages and it will be very tedious

00:05:20,510 --> 00:05:26,270
and complicated to write this code in

00:05:23,390 --> 00:05:31,760
other languages to work with your rough

00:05:26,270 --> 00:05:33,980
library that's why we have a steez you

00:05:31,760 --> 00:05:36,080
can basically scan all of your libraries

00:05:33,980 --> 00:05:37,730
code and extract that information about

00:05:36,080 --> 00:05:39,740
the functions that you export from your

00:05:37,730 --> 00:05:41,990
library and generate code in other

00:05:39,740 --> 00:05:45,380
languages based on that extracted

00:05:41,990 --> 00:05:47,690
information and you can also transform

00:05:45,380 --> 00:05:50,870
your code it's perfect Chloe

00:05:47,690 --> 00:05:53,360
now when you want to apply some kind of

00:05:50,870 --> 00:05:56,080
refactoring to your code and I believe

00:05:53,360 --> 00:05:59,060
the next talk will will be on this topic

00:05:56,080 --> 00:06:01,840
so for example you have Clippy that

00:05:59,060 --> 00:06:06,980
shows you many compile errors in your

00:06:01,840 --> 00:06:09,500
rusts code and it's not it is very

00:06:06,980 --> 00:06:12,110
useful but it will be very nice if it

00:06:09,500 --> 00:06:14,170
could do automatic transformation how

00:06:12,110 --> 00:06:18,350
automatic refactoring of your code right

00:06:14,170 --> 00:06:20,090
so that what you can do with ASD with HD

00:06:18,350 --> 00:06:22,220
you have full information about your

00:06:20,090 --> 00:06:25,490
code and you can also generate new code

00:06:22,220 --> 00:06:27,680
out of a steez so basically what you do

00:06:25,490 --> 00:06:29,480
here is you you're taking the code of

00:06:27,680 --> 00:06:33,350
your library and you're generating new

00:06:29,480 --> 00:06:36,580
code based on based on that code and as

00:06:33,350 --> 00:06:39,350
an output you have a refactoring code

00:06:36,580 --> 00:06:41,630
and there is also the meta programming

00:06:39,350 --> 00:06:44,450
aspect as basically you're related to

00:06:41,630 --> 00:06:45,680
macros and macros are very similar to

00:06:44,450 --> 00:06:48,680
how a Steve's or

00:06:45,680 --> 00:06:50,620
so mockers basically employed the HD

00:06:48,680 --> 00:06:54,880
framework that you have in your compiler

00:06:50,620 --> 00:06:57,410
but the macros are accessible to only

00:06:54,880 --> 00:07:00,140
within the scope of the compiler and

00:06:57,410 --> 00:07:05,570
with a ste you have the full information

00:07:00,140 --> 00:07:07,400
about your code so basically that means

00:07:05,570 --> 00:07:11,270
that with meta programming you can

00:07:07,400 --> 00:07:12,830
generate any rust code based on the full

00:07:11,270 --> 00:07:18,710
information that you have extracted from

00:07:12,830 --> 00:07:22,690
the ast and of course you can use is to

00:07:18,710 --> 00:07:25,160
compile your code to a binary but

00:07:22,690 --> 00:07:29,090
thankfully you rusts the Ross compiler

00:07:25,160 --> 00:07:32,090
does that part for us and of course you

00:07:29,090 --> 00:07:33,980
need to know that the use cases are not

00:07:32,090 --> 00:07:37,160
limited to those that were listed on the

00:07:33,980 --> 00:07:39,490
previous slide there is a lot of there

00:07:37,160 --> 00:07:41,270
is a lot more use cases and they are

00:07:39,490 --> 00:07:49,940
basically limited only by your

00:07:41,270 --> 00:07:52,490
imagination but a person is these by

00:07:49,940 --> 00:07:55,490
themselves are pretty abstract concept

00:07:52,490 --> 00:07:57,980
how do we actually apply them to rust

00:07:55,490 --> 00:07:58,760
because this is talked about the rust

00:07:57,980 --> 00:08:03,800
language right

00:07:58,760 --> 00:08:06,500
and in fact rust library's multiple rust

00:08:03,800 --> 00:08:10,850
libraries already apply that concept and

00:08:06,500 --> 00:08:13,610
we use these tools every day and rust

00:08:10,850 --> 00:08:15,350
F&G is also another great example of

00:08:13,610 --> 00:08:19,640
code transformation because what it does

00:08:15,350 --> 00:08:22,030
is basically takes the HD that it has

00:08:19,640 --> 00:08:26,030
extracted from the source code and

00:08:22,030 --> 00:08:29,420
outputs this iced tea with with a

00:08:26,030 --> 00:08:33,080
formatting that follows the presets

00:08:29,420 --> 00:08:36,140
preset rules about the how indentation

00:08:33,080 --> 00:08:37,610
should work how to put it how to put the

00:08:36,140 --> 00:08:43,910
brackets where to put the brackets and

00:08:37,610 --> 00:08:46,310
so on and clip is a similar beast so it

00:08:43,910 --> 00:08:50,000
extracts the meta information from a ste

00:08:46,310 --> 00:08:53,780
and based on that instructed extracted

00:08:50,000 --> 00:08:57,740
information it checks whether your code

00:08:53,780 --> 00:08:59,370
has any bad patterns in it and suggests

00:08:57,740 --> 00:09:02,850
how to fix

00:08:59,370 --> 00:09:05,070
those bad patterns and there is no magic

00:09:02,850 --> 00:09:07,830
in it you can basically write your own

00:09:05,070 --> 00:09:11,280
clip a based on the compiler

00:09:07,830 --> 00:09:16,530
technologies and finally if you use IDs

00:09:11,280 --> 00:09:20,010
or text editors with with the eraser

00:09:16,530 --> 00:09:22,140
plugin installed you are also using SDS

00:09:20,010 --> 00:09:25,050
is these extract information from your

00:09:22,140 --> 00:09:27,810
code and you have killed completion

00:09:25,050 --> 00:09:28,440
syntax highlighting all the nice things

00:09:27,810 --> 00:09:31,350
that

00:09:28,440 --> 00:09:35,730
IDs provide you so IDE is basically a

00:09:31,350 --> 00:09:38,070
compiler that compiler that extracts

00:09:35,730 --> 00:09:40,700
information from your code and makes it

00:09:38,070 --> 00:09:45,470
more usable and convenient for you to

00:09:40,700 --> 00:09:45,470
write your code in the users interface

00:09:47,120 --> 00:09:55,140
so how do we actually use these a steez

00:09:53,250 --> 00:09:57,390
and of course you don't have to write

00:09:55,140 --> 00:09:59,790
your own library or you don't have to

00:09:57,390 --> 00:10:03,090
write your own code to extract this

00:09:59,790 --> 00:10:06,480
information or parser code into HTS you

00:10:03,090 --> 00:10:10,170
have you have it already in the Rath

00:10:06,480 --> 00:10:12,660
compiler and you can use the lip syntax

00:10:10,170 --> 00:10:17,540
that is an integral part of the compiler

00:10:12,660 --> 00:10:22,410
to basically extract this information

00:10:17,540 --> 00:10:25,230
and use it in your code there is a

00:10:22,410 --> 00:10:30,360
caveat though that's lip syntax library

00:10:25,230 --> 00:10:36,270
is available only in Nigel in the Nidal

00:10:30,360 --> 00:10:40,070
version of compiler and brass use it to

00:10:36,270 --> 00:10:45,240
parser code and it provides a teaser

00:10:40,070 --> 00:10:49,950
basically in as an API but if you can't

00:10:45,240 --> 00:10:52,460
use the nightly version of the compiler

00:10:49,950 --> 00:10:56,280
the an alternative version will be

00:10:52,460 --> 00:10:58,920
syntax that is a grade that has been

00:10:56,280 --> 00:11:02,100
ported from the lips index to a separate

00:10:58,920 --> 00:11:04,590
grade is basically a code that has been

00:11:02,100 --> 00:11:07,380
taken from the Russ compiler and put

00:11:04,590 --> 00:11:11,970
into a crate that can work on a stable

00:11:07,380 --> 00:11:12,990
branch of the Russ compiler and it's it

00:11:11,970 --> 00:11:16,410
has the

00:11:12,990 --> 00:11:18,810
exact same API so you can basically use

00:11:16,410 --> 00:11:21,810
it interchangeably in your library if

00:11:18,810 --> 00:11:24,210
you want to if you are not allowed to

00:11:21,810 --> 00:11:27,660
use an idle version of compiler you can

00:11:24,210 --> 00:11:31,610
basically just link this this little

00:11:27,660 --> 00:11:35,790
library and it's a drop-in replacement

00:11:31,610 --> 00:11:40,050
but there's another kavia in that this

00:11:35,790 --> 00:11:43,970
library has been deprecated and its

00:11:40,050 --> 00:11:46,320
usage mostly confined to legacy projects

00:11:43,970 --> 00:11:48,330
well you can still use it it's still

00:11:46,320 --> 00:11:52,830
available on the grades dot IO

00:11:48,330 --> 00:11:54,510
repository but there is also an

00:11:52,830 --> 00:11:57,270
alternative and if you're starting a new

00:11:54,510 --> 00:11:58,950
version of your basically if you're

00:11:57,270 --> 00:12:01,260
starting from scratch and not from some

00:11:58,950 --> 00:12:03,860
kind of legacy code you can use an

00:12:01,260 --> 00:12:09,720
alternative library that's called as sin

00:12:03,860 --> 00:12:11,790
sy n and it is used by multiple projects

00:12:09,720 --> 00:12:16,080
too and this syntax crate is used by

00:12:11,790 --> 00:12:17,400
rust affinity stable so it's basically a

00:12:16,080 --> 00:12:19,830
matter of preference

00:12:17,400 --> 00:12:25,200
although the authors of for this library

00:12:19,830 --> 00:12:27,750
that I would prefer you to not use it so

00:12:25,200 --> 00:12:29,730
how do you actually to put it in

00:12:27,750 --> 00:12:34,770
practical terms how do you actually use

00:12:29,730 --> 00:12:38,160
that you basically import the syntax

00:12:34,770 --> 00:12:42,570
which is a part of the russ compiler as

00:12:38,160 --> 00:12:46,110
a crate you add this separate mmm kicker

00:12:42,570 --> 00:12:49,140
flag that says that it's a lot to import

00:12:46,110 --> 00:12:51,839
private parts of the rust compiler and

00:12:49,140 --> 00:12:58,529
you basically import it and use it as a

00:12:51,839 --> 00:13:01,589
as a usual library so then you provide a

00:12:58,529 --> 00:13:06,690
file name of a rust file that you want

00:13:01,589 --> 00:13:12,029
to parse and other and as a result you

00:13:06,690 --> 00:13:16,680
get a vector of items so items are

00:13:12,029 --> 00:13:19,020
actually e noms that represent all that

00:13:16,680 --> 00:13:20,310
you can use in your code so it

00:13:19,020 --> 00:13:23,190
represents functions with their

00:13:20,310 --> 00:13:25,050
arguments it represents statements it

00:13:23,190 --> 00:13:26,590
represents all the expressions that you

00:13:25,050 --> 00:13:29,680
have in her code

00:13:26,590 --> 00:13:34,480
it's a nice thing about it is that it's

00:13:29,680 --> 00:13:36,490
an enum and as you know we have a very

00:13:34,480 --> 00:13:39,040
nice language construct in rust that

00:13:36,490 --> 00:13:43,200
works with enums there's called match

00:13:39,040 --> 00:13:47,800
and by using pattern matching it's very

00:13:43,200 --> 00:13:52,170
simple it's very easy to actually

00:13:47,800 --> 00:13:55,630
extract the information from those items

00:13:52,170 --> 00:13:59,860
you basically match on the type of your

00:13:55,630 --> 00:14:02,410
AC item which could also call carry the

00:13:59,860 --> 00:14:06,040
all the relevant information with it in

00:14:02,410 --> 00:14:12,790
its anon variant and you use it however

00:14:06,040 --> 00:14:15,300
you like so that's how it could look

00:14:12,790 --> 00:14:19,920
yeah it could be a function declaration

00:14:15,300 --> 00:14:23,680
which has its inputs its arguments with

00:14:19,920 --> 00:14:28,810
together with its types and it has also

00:14:23,680 --> 00:14:32,080
an output type so it goes on like that

00:14:28,810 --> 00:14:35,890
with other kinds of items with other

00:14:32,080 --> 00:14:39,430
kinds of STS so it's not a rocket

00:14:35,890 --> 00:14:44,290
science so you basically can continue in

00:14:39,430 --> 00:14:48,089
the same manner and finally you know

00:14:44,290 --> 00:14:50,490
there is a cogeneration aspect so

00:14:48,089 --> 00:14:53,890
cogeneration has a lots and lots of

00:14:50,490 --> 00:14:57,580
useful and practical applications so if

00:14:53,890 --> 00:15:00,190
for for example when Mozilla started to

00:14:57,580 --> 00:15:03,670
develop servo they stumbled upon an

00:15:00,190 --> 00:15:08,890
issue that there is many libraries that

00:15:03,670 --> 00:15:10,780
are not written in rust yet so to use

00:15:08,890 --> 00:15:16,209
these libraries that are written in C

00:15:10,780 --> 00:15:18,670
and C++ they got together with a library

00:15:16,209 --> 00:15:23,110
read sculptress banking so what it does

00:15:18,670 --> 00:15:26,020
basically it uses si Lang to extract the

00:15:23,110 --> 00:15:28,510
meta information from C++ code so

00:15:26,020 --> 00:15:32,560
basically can think about it as as an

00:15:28,510 --> 00:15:36,010
analogy of that lip syntax from the Russ

00:15:32,560 --> 00:15:37,959
compiler but it works for C++ so will

00:15:36,010 --> 00:15:39,490
extracts the meta information from the

00:15:37,959 --> 00:15:43,510
C++ code

00:15:39,490 --> 00:15:47,350
and Jerry's code in rust so that that

00:15:43,510 --> 00:15:49,089
way you get a library that can talk to a

00:15:47,350 --> 00:15:51,640
single class library but you don't need

00:15:49,089 --> 00:15:59,740
to write it by hand which will be of

00:15:51,640 --> 00:16:03,430
course very tedious and error-prone so

00:15:59,740 --> 00:16:06,370
then there is a civilization aspect so

00:16:03,430 --> 00:16:09,040
if you work with proto buffs or ro or

00:16:06,370 --> 00:16:11,410
other frameworks that work with other

00:16:09,040 --> 00:16:14,230
languages they basically follow the same

00:16:11,410 --> 00:16:17,220
pattern they have a description of data

00:16:14,230 --> 00:16:22,870
structures that you might need to use in

00:16:17,220 --> 00:16:25,839
different languages and they basically

00:16:22,870 --> 00:16:29,740
use code generation to provide this

00:16:25,839 --> 00:16:32,140
feature and in rust you can do the same

00:16:29,740 --> 00:16:34,300
and I believe there is already a bunch

00:16:32,140 --> 00:16:37,600
of libraries that provide this thing for

00:16:34,300 --> 00:16:39,640
you but if you want to make a similar

00:16:37,600 --> 00:16:46,690
thing you can use code generation as

00:16:39,640 --> 00:16:50,110
well and finally why why do we use HTS

00:16:46,690 --> 00:16:54,520
why do we use parsing instead of instead

00:16:50,110 --> 00:16:56,890
of just going by macros well of first of

00:16:54,520 --> 00:17:00,250
all macros don't have an access to you

00:16:56,890 --> 00:17:03,520
the environment that you know run your

00:17:00,250 --> 00:17:06,339
program in so micros are kind of

00:17:03,520 --> 00:17:08,290
isolated by the compiler context but

00:17:06,339 --> 00:17:12,069
they can't access the input out they

00:17:08,290 --> 00:17:14,050
can't read a file from your file system

00:17:12,069 --> 00:17:18,670
they can't go to the network and so on

00:17:14,050 --> 00:17:21,130
and with and with parsing by parsing

00:17:18,670 --> 00:17:24,880
your code you can basically have and

00:17:21,130 --> 00:17:26,319
have a the all the power that rust the

00:17:24,880 --> 00:17:30,040
rust compiler and the rust language

00:17:26,319 --> 00:17:32,770
provide you and and not only the rust

00:17:30,040 --> 00:17:37,450
language and the the full power of your

00:17:32,770 --> 00:17:41,530
environment and the second aspect of it

00:17:37,450 --> 00:17:43,780
is that macros 2.0 that should be

00:17:41,530 --> 00:17:46,840
available in the wrath compiler soon

00:17:43,780 --> 00:17:49,510
should cover at least a part of these

00:17:46,840 --> 00:17:51,830
use cases so you might want to follow

00:17:49,510 --> 00:17:55,040
this closely

00:17:51,830 --> 00:17:58,790
and finally how do you actually generate

00:17:55,040 --> 00:18:01,940
your code huh you can use a tool that

00:17:58,790 --> 00:18:06,170
utilizes the Builder pattern they

00:18:01,940 --> 00:18:08,480
basically call functions so to construct

00:18:06,170 --> 00:18:10,160
a function you will call item of fun and

00:18:08,480 --> 00:18:11,900
provide the context of that function you

00:18:10,160 --> 00:18:13,850
provide the function name you provide

00:18:11,900 --> 00:18:16,490
the function arguments and you provide

00:18:13,850 --> 00:18:21,770
the function body and as a result you

00:18:16,490 --> 00:18:24,530
will get the HT item that will contain

00:18:21,770 --> 00:18:27,290
on all the relevant information for your

00:18:24,530 --> 00:18:30,200
function and from that HT item you can

00:18:27,290 --> 00:18:34,520
convert it into into a string and get

00:18:30,200 --> 00:18:38,990
the rescue as a result but it's not very

00:18:34,520 --> 00:18:40,430
convenient so whoever can use instead we

00:18:38,990 --> 00:18:44,690
can employ the concept that is called

00:18:40,430 --> 00:18:47,870
quasi quasi quotation and it is widely

00:18:44,690 --> 00:18:50,270
known and widely used in the Lisp

00:18:47,870 --> 00:18:51,920
language and it's widely used by some

00:18:50,270 --> 00:18:55,520
functional languages like Haskell for

00:18:51,920 --> 00:18:59,600
example and the concept is quite simple

00:18:55,520 --> 00:19:03,410
it's server resembling of macros but

00:18:59,600 --> 00:19:06,380
actually instead of you know instead of

00:19:03,410 --> 00:19:09,320
outputting just string it provides you

00:19:06,380 --> 00:19:14,120
with tokens and the HD items that you

00:19:09,320 --> 00:19:17,420
can use further so there is also a Russ

00:19:14,120 --> 00:19:19,970
library that that's called code that

00:19:17,420 --> 00:19:23,570
provides a bunch of handy markers that

00:19:19,970 --> 00:19:27,020
you can use to generate your code it

00:19:23,570 --> 00:19:30,170
looks like this as you can see it's

00:19:27,020 --> 00:19:32,660
almost the same as you would have

00:19:30,170 --> 00:19:34,820
written it if you have dealt with macros

00:19:32,660 --> 00:19:38,720
so you can just create in your

00:19:34,820 --> 00:19:41,930
identifier and place it in your code

00:19:38,720 --> 00:19:44,720
instead of placeholder and as a result

00:19:41,930 --> 00:19:48,170
and as a result if you convert it into a

00:19:44,720 --> 00:19:52,220
string you will get a resulting function

00:19:48,170 --> 00:19:55,460
a resulting source code and you can

00:19:52,220 --> 00:19:59,210
output it into a file or do whatever

00:19:55,460 --> 00:20:02,390
you'd like with it and finally a small

00:19:59,210 --> 00:20:05,720
case a small case study about how can

00:20:02,390 --> 00:20:10,730
you use parsing in your project

00:20:05,720 --> 00:20:14,629
so it made safe we dealt with our task

00:20:10,730 --> 00:20:19,460
will was to provide a library to be used

00:20:14,629 --> 00:20:21,470
in basically in multiple languages we

00:20:19,460 --> 00:20:24,080
have a library that talks to a p2p

00:20:21,470 --> 00:20:27,139
network a peer-to-peer network and we

00:20:24,080 --> 00:20:29,750
want people to use it from basically any

00:20:27,139 --> 00:20:32,149
language that exists and we provide this

00:20:29,750 --> 00:20:34,580
library as an fi interface so it exports

00:20:32,149 --> 00:20:36,769
a foreign function interface and it's

00:20:34,580 --> 00:20:41,679
available as a C library as any other C

00:20:36,769 --> 00:20:44,690
library but as we want it to be used by

00:20:41,679 --> 00:20:47,600
as we want it to be used by Java scripts

00:20:44,690 --> 00:20:53,360
or from Python and from Java and from

00:20:47,600 --> 00:20:56,809
other languages we and it's a very

00:20:53,360 --> 00:20:59,210
tedious process to just write that code

00:20:56,809 --> 00:21:01,100
by hand to write the language bindings

00:20:59,210 --> 00:21:04,700
code by hand we came up with that

00:21:01,100 --> 00:21:08,120
solution of parsing basically parsing

00:21:04,700 --> 00:21:11,059
our entire library and export on looking

00:21:08,120 --> 00:21:13,580
at the exported f5 functions and create

00:21:11,059 --> 00:21:17,840
generating Java and c-sharp and Python

00:21:13,580 --> 00:21:20,690
code based on that and besides that now

00:21:17,840 --> 00:21:23,899
Java wouldn't work simple with that code

00:21:20,690 --> 00:21:26,990
so we also generate Jane I bindings in

00:21:23,899 --> 00:21:29,750
rust so we generate rust code that

00:21:26,990 --> 00:21:33,019
exports Jane I functions that Java

00:21:29,750 --> 00:21:35,379
understand and that the entire code of

00:21:33,019 --> 00:21:37,940
that libraries ik is generated by

00:21:35,379 --> 00:21:43,549
basically as a result of code generator

00:21:37,940 --> 00:21:46,570
and the parser so that's it and if you

00:21:43,549 --> 00:21:46,570
have any questions please ask

00:21:46,890 --> 00:21:54,539
[Applause]

00:22:03,610 --> 00:22:21,760
my source my library and I want to

00:22:08,300 --> 00:22:24,670
replace well the question is can you use

00:22:21,760 --> 00:22:28,100
basically can you transform a STIs

00:22:24,670 --> 00:22:30,350
in the compiled time so when you're

00:22:28,100 --> 00:22:32,600
compiling your library can you transform

00:22:30,350 --> 00:22:35,240
the ast to have some other

00:22:32,600 --> 00:22:37,100
representation and of course it is

00:22:35,240 --> 00:22:39,470
possible when you do it's with macros

00:22:37,100 --> 00:22:42,650
basically that what micros does they

00:22:39,470 --> 00:22:46,190
take the ast three and they produce

00:22:42,650 --> 00:22:48,380
another ast tree so mmm that is sold by

00:22:46,190 --> 00:22:51,680
macros and also there is a procedural

00:22:48,380 --> 00:22:54,980
macros thing and there is also macros

00:22:51,680 --> 00:22:57,590
2.0 so Russ provides multiple ways to

00:22:54,980 --> 00:22:59,540
transform your code to some other

00:22:57,590 --> 00:23:02,710
representation and you can choose

00:22:59,540 --> 00:23:02,710
whatever suits you better

00:23:28,180 --> 00:23:34,420
so the question is can you basically do

00:23:32,000 --> 00:23:38,810
a mock testing and rust by replacing

00:23:34,420 --> 00:23:41,570
structures with some other version with

00:23:38,810 --> 00:23:44,540
versions with instrumentation and test

00:23:41,570 --> 00:23:46,940
functions now and so on and yeah I

00:23:44,540 --> 00:23:49,100
believe it's possible if you use the

00:23:46,940 --> 00:23:51,380
compiler plugins and the procedural

00:23:49,100 --> 00:23:53,900
markers and if you use the derived key

00:23:51,380 --> 00:23:56,930
in keyword that what it basically does

00:23:53,900 --> 00:24:00,260
and that's also how serda how the serger

00:23:56,930 --> 00:24:02,179
library works it derives your structs so

00:24:00,260 --> 00:24:04,580
you just write derive

00:24:02,179 --> 00:24:07,490
our allies and the rest the surgery

00:24:04,580 --> 00:24:10,610
library takes that instruction and

00:24:07,490 --> 00:24:12,889
generates the serialization and

00:24:10,610 --> 00:24:16,039
deserialization codes for your structure

00:24:12,889 --> 00:24:18,980
so I believe that so I can work in a

00:24:16,039 --> 00:24:24,049
very similar way for the mock testing

00:24:18,980 --> 00:24:26,629
and the mock features of so for the mock

00:24:24,049 --> 00:24:29,080
version of your structs any other

00:24:26,629 --> 00:24:29,080
questions

00:24:40,650 --> 00:24:48,250
yes so the question is is is there a

00:24:44,500 --> 00:24:49,930
project in rust that that is a basically

00:24:48,250 --> 00:24:51,610
compiler generator that takes a

00:24:49,930 --> 00:24:56,110
description of a compiler and generates

00:24:51,610 --> 00:24:59,320
a compiler from from the BNF grammar or

00:24:56,110 --> 00:25:02,440
whatever it's called yeah there is there

00:24:59,320 --> 00:25:05,710
is a bunch of such projects I believe

00:25:02,440 --> 00:25:09,840
for one is called Lal earth and it is

00:25:05,710 --> 00:25:12,160
based obviously on all our parsing so

00:25:09,840 --> 00:25:13,660
yeah there are there's a multiple

00:25:12,160 --> 00:25:17,160
projects and you can basically find them

00:25:13,660 --> 00:25:21,400
by googling Roz compiler generator and

00:25:17,160 --> 00:25:23,770
there is a prominent once and activity

00:25:21,400 --> 00:25:28,150
that are being actively developed so you

00:25:23,770 --> 00:25:28,760
can find many of them okay thanks all

00:25:28,150 --> 00:25:33,329
for your attention

00:25:28,760 --> 00:25:33,329

YouTube URL: https://www.youtube.com/watch?v=4qEuWJPVeFs


