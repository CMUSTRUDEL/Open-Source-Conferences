Title: RustFest Barcelona - Neville Dipale: Powering Crowd-sourcing of Public Transit Delays with Rust
Publication date: 2019-11-28
Playlist: RustFest Barcelona 2019
Description: 
	“Your train is arriving in between 20 to 90 minutes”. This is a reality for about 3 million train commuters in South Africa, who not only battle to commute daily, but are faced with a lack of accurate information and high uncertainty about their trains.

This talk explores how we progressively use Rust to power crowd-sourcing of train delays, and are helping reduce the uncertainty of arrival times in our ailing train (and bus) services; all with little computing resources.

We focus on how the Rust language and ecosystem helps us to create tools and services that run at scale and low cost.

https://barcelona.rustfest.eu/sessions/public-transit-delays
Captions: 
	00:00:05,190 --> 00:00:34,780
NEVILLE: Good morning, everyone.

00:00:34,780 --> 00:00:42,909
This talk is going to be about powering crowdsourcing of public transit delays using Rust.

00:00:42,909 --> 00:00:51,329
Morning, everyone.

00:00:51,329 --> 00:00:52,940
My name is Neville Dipale.

00:00:52,940 --> 00:00:54,430
I'm from South Africa.

00:00:54,430 --> 00:00:56,039
I'm on Twitter.

00:00:56,039 --> 00:00:59,069
I work as a data engineer, mostly as a freelancer.

00:00:59,069 --> 00:01:10,330
I started as a hobby about ten years ago now, I run a public transit info service, I started

00:01:10,330 --> 00:01:17,390
using Rust about a year ago and recently became an Apache Arrow committer contributing to

00:01:17,390 --> 00:01:18,980
the Rust implementation.

00:01:18,980 --> 00:01:26,280
Today I am going to be talking about trains in our region and challenges with them so

00:01:26,280 --> 00:01:31,380
I will give an overview of how they work, I will talk about the crowdsourcing solution,

00:01:31,380 --> 00:01:35,340
how we use Rust and what the benefits of having used Rust are.

00:01:35,340 --> 00:01:40,490
So as a background to the train service, we have two train services in our region.

00:01:40,490 --> 00:01:46,820
Out of interest, how many people have been in South Africa, by a raise of hands?

00:01:46,820 --> 00:01:48,340
Cool, thanks.

00:01:48,340 --> 00:01:54,280
So we've got two trains and we've got the fast train and the metro train.

00:01:54,280 --> 00:01:57,080
The fast train was actually built for the 2010 soccer World Cup.

00:01:57,080 --> 00:02:00,060
We hosted it, and won it.

00:02:00,060 --> 00:02:06,170
The metro train has been around since the 80s so it has very aged infrastructure, they

00:02:06,170 --> 00:02:09,789
haven't replaced some of the trains in quite a long time.

00:02:09,789 --> 00:02:11,420
The metro train is very cheap.

00:02:11,420 --> 00:02:15,871
You can get from one side of the province to the other side of the province for about

00:02:15,871 --> 00:02:22,170
2 to €3 and then most trips would be 1 to €2.

00:02:22,170 --> 00:02:26,470
The fast train is a bit more expensive so it goes from the airport into the city and

00:02:26,470 --> 00:02:33,110
you pay about €10 a time for that train so the metro train is used mostly by poorer

00:02:33,110 --> 00:02:38,090
communities and students though rely on the service.

00:02:38,090 --> 00:02:39,810
Let's guess which train is which here.

00:02:39,810 --> 00:02:41,690
We've got this one.

00:02:41,690 --> 00:02:43,570
Which would it be?

00:02:43,570 --> 00:02:44,570
Fast train.

00:02:44,570 --> 00:02:47,130
Then you've got this one, being the metro train.

00:02:47,130 --> 00:02:49,430
[Laughter] So we've had this problem for a very long

00:02:49,430 --> 00:02:55,150
time where, because there aren't enough trains, they get overcrowded and people get desperate

00:02:55,150 --> 00:02:57,610
to get to work and then they hang on to the trains.

00:02:57,610 --> 00:03:01,740
They are changing that now with new metro trains but we've had problems over the years

00:03:01,740 --> 00:03:03,520
with procurement, government issues, etc.

00:03:03,520 --> 00:03:07,200
We were supposed to have these new trains about four years ago.

00:03:07,200 --> 00:03:11,880
I think now there's only three running and they've promised that we will have all of

00:03:11,880 --> 00:03:15,040
the trains being replaced by these ones in the next ten years so the struggle is still

00:03:15,040 --> 00:03:17,870
going to continue.

00:03:17,870 --> 00:03:22,310
With metro train delays they've got severe infrastructure issues, as I've mentioned.

00:03:22,310 --> 00:03:28,130
It's estimated that 40% of rolling stock, ie the train coaches, are out of service,

00:03:28,130 --> 00:03:32,770
are not available, and this affects peak time services quite significantly.

00:03:32,770 --> 00:03:36,700
It's only during the day when there's fewer people taking trains, fewer services, where

00:03:36,700 --> 00:03:40,380
they get to catch up and then the same problem then begins again in the evening.

00:03:40,380 --> 00:03:45,090
Trains can get stuck in the middle of the tracks, cable theft, signalling problems,

00:03:45,090 --> 00:03:46,090
etc.

00:03:46,090 --> 00:03:52,700
It's not uncommon to be on a train, stop in the middle of nowhere for 15, 20 minutes,

00:03:52,700 --> 00:03:54,210
and then the train continue again.

00:03:54,210 --> 00:03:58,860
I did an interesting analysis - not here though, for something else - where we were looking

00:03:58,860 --> 00:04:06,739
at the average train travel times, factoring into account the delays, and one of the trains

00:04:06,739 --> 00:04:11,629
took about - I think it travelled at 30km/h effectively and was travelling about 100 kilometres

00:04:11,629 --> 00:04:15,910
so you can imagine how long that train trip was.

00:04:15,910 --> 00:04:19,530
Delays of over 60 minutes in most cases.

00:04:19,530 --> 00:04:26,340
Part of my pitch, it was dramatic, I said, "Your train is arriving in 20 to 90 minutes",

00:04:26,340 --> 00:04:28,419
because that's the kind of uncertainty.

00:04:28,419 --> 00:04:32,220
There are communication issues also from the operator.

00:04:32,220 --> 00:04:35,060
None of it is digital, all of it is analogue.

00:04:35,060 --> 00:04:41,000
We don't have an API that provides information as such and a lot of the times, even for the

00:04:41,000 --> 00:04:44,370
train to say move themselves, they rely on phones.

00:04:44,370 --> 00:04:47,750
The train conductor will stop the train and say: can I move on?

00:04:47,750 --> 00:04:50,000
Then they have to wait 10, 15 minutes or so.

00:04:50,000 --> 00:04:54,180
In the past 15 years we've had a number of collisions of trains.

00:04:54,180 --> 00:05:00,280
One big one, 20 people died or so, so it has been very bad over the years.

00:05:00,280 --> 00:05:05,930
Here is a graphic that just shows some of the data that we've collected.

00:05:05,930 --> 00:05:13,630
I've split it into delays, so a histogram of delays where the first two packets are

00:05:13,630 --> 00:05:20,949
trains that are early or on time and in the ten-minute category, 53% of trains are delayed

00:05:20,949 --> 00:05:26,639
by up to ten minutes, so this is great but also bear in mind that we don't crowdsource

00:05:26,639 --> 00:05:29,920
the entire network, so it's only a snapshot of some of the trains.

00:05:29,920 --> 00:05:36,350
Then you will see that the delays sort of go down.

00:05:36,350 --> 00:05:40,760
You still have quite a number of trains that are very late in most cases and each time,

00:05:40,760 --> 00:05:44,340
this is normally either in the morning, somebody has to get to work or a meeting at 8.00 am,

00:05:44,340 --> 00:05:48,600
they end up getting there at 9.00 and as a result a lot of people have lost their jobs

00:05:48,600 --> 00:05:52,910
because you would come late every day in the week and your employer just says: well, sorry.

00:05:52,910 --> 00:05:57,320
There are people who wake up at 3.00 am just so that they can get to work at 8.00 am in

00:05:57,320 --> 00:06:02,190
the morning which is quite terrible, and then the same again happens at night, where people

00:06:02,190 --> 00:06:08,610
would leave work at 5.00 pm, if you work 9.00 to 5.00, and then only get home at 10.00 pm.

00:06:08,610 --> 00:06:13,610
So our solution has been to provide metro commuters with information on train delays.

00:06:13,610 --> 00:06:17,740
We use Twitter and push notifications on an android app, so we've got a android app that

00:06:17,740 --> 00:06:20,620
people use to process this information.

00:06:20,620 --> 00:06:25,432
We crowdsource delays either by sharing a train trip or spotting trains so if you would

00:06:25,432 --> 00:06:31,419
have noticed on the first picture, there's normally 4-digit numbers on each train and

00:06:31,419 --> 00:06:36,009
we use those, map them to the schedule and people provide us with the train number and

00:06:36,009 --> 00:06:37,970
we figure out which it is.

00:06:37,970 --> 00:06:41,790
We calculate delays based on the actual versus scheduled.

00:06:41,790 --> 00:06:50,169
We use a linear model: if the train was supposed to be here five minutes ago, and the average

00:06:50,169 --> 00:06:55,020
speed has been let's say 20% less than what it should be, we just do a simple linear progression

00:06:55,020 --> 00:06:57,539
of what the delays would be.

00:06:57,539 --> 00:07:02,520
Then we generate estimated arrivals at stations and then notify commuters about delays.

00:07:02,520 --> 00:07:04,720
This is what we use Rust for.

00:07:04,720 --> 00:07:09,990
Okay, so in terms of submitting train delays, the architecture is quite complex.

00:07:09,990 --> 00:07:13,590
There's a lot of services that are running around because I have been doing this for

00:07:13,590 --> 00:07:15,570
about seven years now.

00:07:15,570 --> 00:07:16,639
Some of the stuff is in Rust.

00:07:16,639 --> 00:07:21,171
A lot of it is not in Rust but for the talk I'm just going to talk about the few components,

00:07:21,171 --> 00:07:22,660
specifically three components that are built in Rust.

00:07:22,660 --> 00:07:28,880
We've got a location sample service that checks for sample validity and accuracy so imagine

00:07:28,880 --> 00:07:32,580
when you are crowdsourcing one of the problems that you have is that some information might

00:07:32,580 --> 00:07:35,190
be accurate, some might not be accurate.

00:07:35,190 --> 00:07:39,890
There's nothing stopping a person from saying: I'm on train 1235 instead of 1234 and then

00:07:39,890 --> 00:07:41,850
they give you incorrect information.

00:07:41,850 --> 00:07:46,190
One of the things I saw in the early days of deploying this was a train that was moving

00:07:46,190 --> 00:07:49,850
in reverse and it took me a while to figure out that somebody is actually on the other

00:07:49,850 --> 00:07:54,890
train but they are submitting train locations for this one, so it looks like the train just

00:07:54,890 --> 00:07:56,420
keeps going backwards.

00:07:56,420 --> 00:07:59,000
Then this location sample deals with that.

00:07:59,000 --> 00:08:02,010
We've got a service that saves samples in the database.

00:08:02,010 --> 00:08:03,949
I will explain more in detail about that.

00:08:03,949 --> 00:08:05,700
Then you've got a Vehicle Stream service.

00:08:05,700 --> 00:08:13,120
If you were in Rust Lab in Italy I talked specifically about the Vehicle Stream service.

00:08:13,120 --> 00:08:18,130
It calculates delays of trains.

00:08:18,130 --> 00:08:21,820
The user sent delays was samples and then other users are notified of delays.

00:08:21,820 --> 00:08:23,650
I will talk about this in detail.

00:08:23,650 --> 00:08:27,310
Here is an example of a process.

00:08:27,310 --> 00:08:30,860
So train A is expected at station 3 at 8.00 am.

00:08:30,860 --> 00:08:33,599
There are no samples yet so we are just relying on schedules.

00:08:33,599 --> 00:08:41,050
The users - different users are waiting for the train at stations 4, 5, 6 and 7 and those

00:08:41,050 --> 00:08:43,910
are the estimated arrivals at those stations.

00:08:43,910 --> 00:08:50,790
Once we receive the first sample, let's say at 8.12 and that's between station 3 and 4,

00:08:50,790 --> 00:08:55,370
already for station 4 there's a delay so we will just project those and then I've marked

00:08:55,370 --> 00:08:58,060
them in red to show the users that you are notifying.

00:08:58,060 --> 00:09:01,950
One of the problems is that we don't want to spam users and notify them every other

00:09:01,950 --> 00:09:06,441
minute to say your train is arriving in four minutes, now it's three minutes, etc, so we

00:09:06,441 --> 00:09:11,560
project those and then at the next sample that you get we only then calculate the difference

00:09:11,560 --> 00:09:12,560
in delays.

00:09:12,560 --> 00:09:16,360
If the delay is still more or less the same we use a five-minute range, we don't notify

00:09:16,360 --> 00:09:17,360
the user again.

00:09:17,360 --> 00:09:25,750
So when you get a sample at 8.16, the station for the train was already passed, the next

00:09:25,750 --> 00:09:31,950
one is at 8.25, it's within a four-minute difference, so we are not going on notify

00:09:31,950 --> 00:09:32,950
the user.

00:09:32,950 --> 00:09:37,149
We are only going to notify the user whose train is now arriving at 8.33.

00:09:37,149 --> 00:09:43,060
In terms of the Rust services themselves, the location sample is a gRPC server that

00:09:43,060 --> 00:09:48,050
uses tower gRPC, it receives vehicle samples and processes them.

00:09:48,050 --> 00:09:53,990
It matches samples to trains and so we take the four-digit train number, match it to the

00:09:53,990 --> 00:09:56,740
train and generate a last known location.

00:09:56,740 --> 00:09:59,880
It uses actix to monitor state of users and trains.

00:09:59,880 --> 00:10:01,850
I will talk more about it.

00:10:01,850 --> 00:10:03,790
There, I've just shown a screenshot.

00:10:03,790 --> 00:10:07,080
I know Actor is more popular than actix.

00:10:07,080 --> 00:10:21,360
We have a trip status struct that tracks the last known

00:10:21,360 --> 00:10:22,480
details of each trip.

00:10:22,480 --> 00:10:26,960
Going back to the previous slide there, you see that we've got user trips and trips.

00:10:26,960 --> 00:10:31,641
A user trip just matches the user to say - the user is on this train so when they submit

00:10:31,641 --> 00:10:38,780
another train sample, we automatically reject it because you can't be on two trains at the

00:10:38,780 --> 00:10:39,780
same time.

00:10:39,780 --> 00:10:41,670
The trip just checks the overall status of a trip.

00:10:41,670 --> 00:10:46,790
So in the trip status you will see we've got the trip ID, route ID, the last distance and

00:10:46,790 --> 00:10:48,420
then location.

00:10:48,420 --> 00:10:52,950
The last distance is very important because we calculate the distance based on the geometry

00:10:52,950 --> 00:10:58,149
of the trip so if somebody submits a sample and says that the train is close to station

00:10:58,149 --> 00:11:02,930
3, let's say it's 2 kilometres away from station 3, and another user submits a sample five

00:11:02,930 --> 00:11:07,860
minutes later saying: actually, it's close to station 2 - we are going to reject the

00:11:07,860 --> 00:11:13,050
second sample because the train can't go back in reverse so that's how we work around that

00:11:13,050 --> 00:11:14,050
issue.

00:11:14,050 --> 00:11:15,770
Then also keep track of congestion and occupancy.

00:11:15,770 --> 00:11:21,959
We are hoping that with a lot of users we will be able to reliably tell people that

00:11:21,959 --> 00:11:26,870
your train is actually full, it's better maybe to wait for the next one, if it's coming.

00:11:26,870 --> 00:11:33,150
Okay, so we've got an actix actor that receives a sample and handles it.

00:11:33,150 --> 00:11:38,560
The benefit is that I don't have to worry about multi-threading because actix has a

00:11:38,560 --> 00:11:46,529
mailbox so as long as I have a big enough mailbox to handle it - one benefit of Rust

00:11:46,529 --> 00:11:51,790
is that it's very fast so I never have a big backlog at any point in time.

00:11:51,790 --> 00:12:01,180
The sample produces a location or an error if, for example, the location is invalid.

00:12:01,180 --> 00:12:08,690
So after the service saves the valid sample onto the database before it returns it to

00:12:08,690 --> 00:12:13,110
the client, this sample then gets picked up by the next service that I'm going to talk

00:12:13,110 --> 00:12:14,110
about.

00:12:14,110 --> 00:12:18,690
If you have worked with geospatial data, it gives vehicle co-ordinates and then some information

00:12:18,690 --> 00:12:21,010
about the vehicle.

00:12:21,010 --> 00:12:29,890
So the next service that I then used is the Vehicle Streams so this reads data from a

00:12:29,890 --> 00:12:37,209
database periodically every 7 to 10 seconds and it projects the delays per route so this

00:12:37,209 --> 00:12:43,160
is for estimate and live - sorry, scheduled services and live services.

00:12:43,160 --> 00:12:46,450
It calculates the estimates and keeps churning them out throughout the day.

00:12:46,450 --> 00:12:54,000
It starts running from 2.00 am when the first train moves up until 11.00 pm when the last

00:12:54,000 --> 00:12:57,420
bus is moving, so it's both for trains and buses.

00:12:57,420 --> 00:13:05,320
It sends all the results to a service, it uses nats.io for that, and then it uses a

00:13:05,320 --> 00:13:11,720
Tokio interval and runs it every 7 seconds to generate my sample.

00:13:11,720 --> 00:13:13,579
How does Rust help with Vehicle Streams?

00:13:13,579 --> 00:13:23,170
I first wrote the service four years ago, initially in JavaScript where a small crash

00:13:23,170 --> 00:13:25,100
would collapse the whole thing.

00:13:25,100 --> 00:13:30,250
I moved it to Kotlin in the JVM hoping that it will be better, but then I had to keep

00:13:30,250 --> 00:13:33,519
throwing more RAM at it.

00:13:33,519 --> 00:13:38,600
You will remember I talked at Rust Lab about going from 20 gigs of RAM to less than a gig

00:13:38,600 --> 00:13:43,990
of RAM at peak time so it took a few months.

00:13:43,990 --> 00:13:49,910
This was about 14, 15 months ago and I'm seeing very impressive performance.

00:13:49,910 --> 00:13:53,810
I previously talked about how the service just runs for months on end.

00:13:53,810 --> 00:13:55,839
I never need to restart anything.

00:13:55,839 --> 00:13:57,990
I use a third of the CPU usage.

00:13:57,990 --> 00:14:05,610
I talked before about going down in RAM and the main benefit is that I was able to replace

00:14:05,610 --> 00:14:08,279
an in-memory cache with a simple HashMap.

00:14:08,279 --> 00:14:14,730
I will talk more about this and then the service is easier to maintain and expand.

00:14:14,730 --> 00:14:20,300
Then there's a notification service because I mentioned that users have an Android app

00:14:20,300 --> 00:14:25,160
so when one user is submitting samples, other users are relying on that sample.

00:14:25,160 --> 00:14:27,079
It's a Firebase cloud messaging service.

00:14:27,079 --> 00:14:33,790
I think it was abandoned but somebody picked it up and started using it which is one of

00:14:33,790 --> 00:14:36,400
the nice things about open source in general.

00:14:36,400 --> 00:14:42,470
It notifies users about a range of things.

00:14:42,470 --> 00:14:48,769
There's effectively a generic cloud messaging app where I can just keep on extending it

00:14:48,769 --> 00:14:53,610
by different types, so it's not really train-delay specific.

00:14:53,610 --> 00:14:59,830
We personalise information for individual time delays so if you've got five people waiting

00:14:59,830 --> 00:15:06,330
for the train at different stations and you notify one user now, but the delay doesn't

00:15:06,330 --> 00:15:10,399
affect the other person, when it does affect the other person, the second user, we only

00:15:10,399 --> 00:15:11,399
notify them.

00:15:11,399 --> 00:15:18,959
So we keep the state of each individual user and one of the things we try to avoid is spamming

00:15:18,959 --> 00:15:23,529
users by sending them hundreds of notifications per second because immediately someone will

00:15:23,529 --> 00:15:29,329
uninstall your app and you will never see them again.

00:15:29,329 --> 00:15:36,029
The service also uses actix but instead of using gRPC we use nats.io, so within the whole

00:15:36,029 --> 00:15:43,320
architecture there are messages being passed around quite a lot.

00:15:43,320 --> 00:15:44,320
I used to use Kafka.

00:15:44,320 --> 00:15:47,740
Subscriptions are edited in realtime.

00:15:47,740 --> 00:15:55,149
A user says I only take the 7.00 am train, or I only take trains from 7.00 am to 8.00

00:15:55,149 --> 00:15:58,360
am, between station 7 and station 24.

00:15:58,360 --> 00:16:03,180
So once the train passes station 24 we don't notify about anything because it's no longer

00:16:03,180 --> 00:16:04,850
relevant for you.

00:16:04,850 --> 00:16:10,170
This is one of the nice things because the fast train service that I talked about, they

00:16:10,170 --> 00:16:17,600
will send you a notification about a bus in some far-away place not running an it's just

00:16:17,600 --> 00:16:19,800
irritating and a poor user experience.

00:16:19,800 --> 00:16:24,970
All transit data state is loaded at start-up, when the application starts, and I keep it

00:16:24,970 --> 00:16:30,520
in memory so specific data like what the train numbers are, what the stop locations are,

00:16:30,520 --> 00:16:32,580
etc, as well as the trip data.

00:16:32,580 --> 00:16:37,670
The benefit here is that we end up storing everything in memory because the application

00:16:37,670 --> 00:16:41,920
effectively, as long as the application doesn't crash, which is one of the benefits of Rust,

00:16:41,920 --> 00:16:43,760
it will keep running indefinitely.

00:16:43,760 --> 00:16:48,820
So if you use actor systems quite a lot you will know that some actor systems support

00:16:48,820 --> 00:16:55,459
snapshotting where periodically you'll save the user state onto a database so if the application

00:16:55,459 --> 00:16:58,269
crashes you can recover that state.

00:16:58,269 --> 00:17:00,230
Here, I don't use that.

00:17:00,230 --> 00:17:04,209
I just load everything in memory and keep it running.

00:17:04,209 --> 00:17:07,799
So why Rust then?

00:17:07,799 --> 00:17:12,829
The main benefits are that I'm really getting stability out of this because being able to

00:17:12,829 --> 00:17:20,079
write a programme where I can prove to myself or to a compiler that it won't crash, I handle

00:17:20,079 --> 00:17:25,109
every state that will cause a panic, helps me to create a cheap in-memory store using

00:17:25,109 --> 00:17:31,169
a HashMap for example, instead of using bootstrap or something else.

00:17:31,169 --> 00:17:37,690
I don't really use Rust for something very novel per se, but it's really just to give

00:17:37,690 --> 00:17:40,409
me the performance.

00:17:40,409 --> 00:17:46,220
Actix has been good to avoid concurrency issues.

00:17:46,220 --> 00:17:51,549
I rarely have problems with borrow check or lifetimes or anything because everything is

00:17:51,549 --> 00:17:52,549
simple.

00:17:52,549 --> 00:17:59,289
The cost saving is the important element for me because this is a hobby and maintaining

00:17:59,289 --> 00:18:04,409
this means - if I was doing it as a profession or whatever I would need to wake up at 2.00

00:18:04,409 --> 00:18:09,769
am in the morning to notify users of cancellations of trips and all of those things, and then

00:18:09,769 --> 00:18:11,820
stay up all day until late at night.

00:18:11,820 --> 00:18:13,970
Because it's a hobby, it's very costly.

00:18:13,970 --> 00:18:18,239
Every hour that I spend on this is a hour that I could be working as a freelancer and

00:18:18,239 --> 00:18:24,340
putting food on the table, etc, and also the other thing that I save on a lot is server

00:18:24,340 --> 00:18:25,340
cost.

00:18:25,340 --> 00:18:29,960
Initially, about two years ago we first started using Rust, I had to have a 64 gig server

00:18:29,960 --> 00:18:34,659
because the Kotlin service would use about 20 gigs of RAM and all the other services

00:18:34,659 --> 00:18:41,879
would cumulatively add up so I used to normally run at around 40 gigs of RAM usage, just running

00:18:41,879 --> 00:18:47,609
this aspect of this public transit stuff and now the services that I just talked about

00:18:47,609 --> 00:18:52,740
in Rust, including others that I haven't mentioned in this talk, I can run all of them in a 1

00:18:52,740 --> 00:18:57,929
gigabyte container with 2 CPU cores so that's significant for me.

00:18:57,929 --> 00:19:00,480
The other thing is scalability in terms of performance.

00:19:00,480 --> 00:19:07,080
I use two CPU cores but I use very little.

00:19:07,080 --> 00:19:13,019
If we were to expand maybe even 100-fold I would still be able to use them within the

00:19:13,019 --> 00:19:14,019
same resources.

00:19:14,019 --> 00:19:16,779
Okay, that's it from me.

00:19:16,779 --> 00:19:23,679
Are there any questions?

00:19:23,679 --> 00:19:40,359
[Applause] >> Hello, thanks for that interesting talk.

00:19:40,359 --> 00:19:42,389
I already saw you at Rust Lab.

00:19:42,389 --> 00:19:44,159
That's amazing.

00:19:44,159 --> 00:19:49,549
About the scale of the thing, so how many users does this actually serve concurrently

00:19:49,549 --> 00:19:54,769
and what's the frequency of notifications and messages to users, just to get an idea?

00:19:54,769 --> 00:20:03,419
NEVILLE: In terms of the number of users, we get about 100 users a day submitting samples.

00:20:03,419 --> 00:20:07,769
There's a lot more who receive samples but it's not very frequent and it's only really

00:20:07,769 --> 00:20:11,669
busy in the mornings, when a lot of people are taking the trains and then again in the

00:20:11,669 --> 00:20:12,669
evening.

00:20:12,669 --> 00:20:16,899
Throughout the day you will see one sample once in a while but it's not a lot.

00:20:16,899 --> 00:20:21,809
Then, in terms of notifications that are sent, there's a hard rule that says we won't send

00:20:21,809 --> 00:20:27,379
a notification to someone for the same train within five minutes, but we send about - the

00:20:27,379 --> 00:20:34,989
last time I checked, it was about 400, 500 notifications per hour, at peak times.

00:20:34,989 --> 00:20:39,269
But it's still quite a young service.

00:20:39,269 --> 00:20:45,139
>> Any other questions?

00:20:45,139 --> 00:20:55,220
>> Again, a very interesting talk.

00:20:55,220 --> 00:20:58,570
You mentioned you run it from about 3.00 am until late in the evening.

00:20:58,570 --> 00:21:02,379
Does that mean you can shut down your service and, if you didn't have that option, would

00:21:02,379 --> 00:21:04,919
you have to change anything about your infrastructure?

00:21:04,919 --> 00:21:12,340
NEVILLE: So in terms of running it, the running aspect of it at one point is standing on a

00:21:12,340 --> 00:21:17,520
chair, looking at cancellations more than delays.

00:21:17,520 --> 00:21:23,070
The whole delay infrastructure - it's the cancellations where there's a WhatsApp group

00:21:23,070 --> 00:21:26,789
from the train operator where they say: this train has been cancelled.

00:21:26,789 --> 00:21:29,340
So those ones we can't automate as yet.

00:21:29,340 --> 00:21:33,320
We have to capture a cancellation and send that out.

00:21:33,320 --> 00:21:37,580
Everything else is just automated, so at night when - it's based on schedule, so if there's

00:21:37,580 --> 00:21:41,350
no scheduled trains that are running the service will just keep calling every 7 seconds but

00:21:41,350 --> 00:21:42,649
do nothing.

00:21:42,649 --> 00:21:48,610
Once activity picks up, it starts running.

00:21:48,610 --> 00:21:50,259
>> Hi.

00:21:50,259 --> 00:21:51,470
Great talk by the way.

00:21:51,470 --> 00:22:01,629
I was just wondering, does the app send regular updates, or does the user have to actually

00:22:01,629 --> 00:22:02,639
send the update themselves?

00:22:02,639 --> 00:22:04,090
Press a button or whatever?

00:22:04,090 --> 00:22:08,630
NEVILLE: My apologies, I actually didn't talk about how users submit.

00:22:08,630 --> 00:22:12,900
There are two ways.

00:22:12,900 --> 00:22:24,460
First is ... depending on where they are - when a train passes by you can spot the train by

00:22:24,460 --> 00:22:31,350
saying I just saw a train passing by and we use that one sample to calculate.

00:22:31,350 --> 00:22:36,299
But then once you get on the train, if you've used Waze it's something similar, where once

00:22:36,299 --> 00:22:40,799
you get on the train you can say I'm on this train and then it will take a sample I think

00:22:40,799 --> 00:22:43,090
between every 45 and 60 seconds.

00:22:43,090 --> 00:22:44,169
That's how we get the sample.

00:22:44,169 --> 00:22:46,950
Then once you get on the train.

00:22:46,950 --> 00:22:48,320
>> Thanks.

00:22:48,320 --> 00:22:53,809
>> A very nice talk.

00:22:53,809 --> 00:22:58,330
So you mentioned you store the state as a HashMap in memory.

00:22:58,330 --> 00:23:04,229
Have you ever had the issue that the state got - you were not able to forget?

00:23:04,229 --> 00:23:11,259
So something you use is ETL so you can forget an entry automatically; do you need to handle

00:23:11,259 --> 00:23:13,539
that in your application or is that not an issue?

00:23:13,539 --> 00:23:16,250
NEVILLE: So I used both.

00:23:16,250 --> 00:23:21,479
There's a crate called ETL Index, I think, I cannot remember.

00:23:21,479 --> 00:23:28,429
I used that for state where I want to keep stuff ... I restart the application once a

00:23:28,429 --> 00:23:37,590
month, I will just load that information.

00:23:37,590 --> 00:23:43,820
I do do incremental updates where there are changes that happen and in terms of the application

00:23:43,820 --> 00:23:52,870
getting big, right now with about 7,000 services, or 7,000 different routes, yes, and 7,000

00:23:52,870 --> 00:23:59,879
vehicles, I use less than a gig, so in the Vehicle Stream service I use about 500 megs

00:23:59,879 --> 00:24:07,789
and then for static information I use about 400 megs, so if I were to increase the service

00:24:07,789 --> 00:24:21,190
tenfold, still say 10 gigs of RAM so that's not a concern.

00:24:21,190 --> 00:24:30,669
>> Do you have trainspotters in South Africa and could you maybe change your app a little

00:24:30,669 --> 00:24:35,019
bit so that it gamified it for trainspotters?

00:24:35,019 --> 00:24:39,960
NEVILLE: Well, there's a lot of stuff I didn't talk about and I see there's a lot of questions

00:24:39,960 --> 00:24:45,859
about, so one of the things you do on the app is we keep track on - we've created a

00:24:45,859 --> 00:24:57,049
points system for trainspotters where based on how much the trains - how much you travel

00:24:57,049 --> 00:24:59,309
- the first person will get more points.

00:24:59,309 --> 00:25:05,669
At the end of the month, because people are often students, etc, we buy them data in small

00:25:05,669 --> 00:25:11,190
prices that they can afford, and then the other one is we keep track of how many kilometres

00:25:11,190 --> 00:25:18,639
in total you've travelled and we also incentivise those people so we do gamify, because otherwise

00:25:18,639 --> 00:25:30,730
people don't see the benefit of spending their data helping the service, even though it helps.

00:25:30,730 --> 00:25:33,850
>> More question?

00:25:33,850 --> 00:25:37,929
I don't see any.

00:25:37,929 --> 00:25:51,489
>> Do you know if the train drivers use the app as well, or do the company use it?

00:25:51,489 --> 00:25:59,580
NEVILLE: Some background, one of the problems we have in our country is that the government

00:25:59,580 --> 00:26:03,150
outsources a lot of its sources.

00:26:03,150 --> 00:26:08,679
The problem with that is that, even when you are coming with good intentions, trying to

00:26:08,679 --> 00:26:12,999
help out, they can't just take your services, they have to go through permanent services

00:26:12,999 --> 00:26:14,960
and things like that.

00:26:14,960 --> 00:26:21,100
We have put in a proposal a number of times where we said instead of putting GPSs on trains

00:26:21,100 --> 00:26:26,270
because the trains are old anyway and might get vandalised, let's create an app for train

00:26:26,270 --> 00:26:32,409
drivers because all train drivers have smartphones and then those drivers, when they get on the

00:26:32,409 --> 00:26:35,630
train, they can say: I'm logging in on this train.

00:26:35,630 --> 00:26:41,019
One of the problems though that we have, because we've tried that with buses also, is that

00:26:41,019 --> 00:26:45,919
bus drivers are very unionised, so there's a lot of organised data and there's always

00:26:45,919 --> 00:26:50,499
issues about whether this information will be used to the prejudice of drivers.

00:26:50,499 --> 00:26:55,320
Sometimes the drivers aren't very honest in the sense that when a bus is supposed to leave

00:26:55,320 --> 00:27:02,190
at 9.00 am or it leaves and every 15 minutes, sometimes the drivers will intentionally not

00:27:02,190 --> 00:27:04,320
leave at 9.00 and leave in a bunch together.

00:27:04,320 --> 00:27:05,419
There's a concept called bunching.

00:27:05,419 --> 00:27:14,200
There are quite a few issues that work against us trying to implement that but we are trying

00:27:14,200 --> 00:27:28,659
because if you do that then you don't need the crowdsourcing.

00:27:28,659 --> 00:27:29,659
>> Anyone else?

00:27:29,659 --> 00:27:30,659
Okay, thanks, Neville, for your talk.

00:27:30,659 --> 00:27:30,660

YouTube URL: https://www.youtube.com/watch?v=s3Iga7FTnyA


