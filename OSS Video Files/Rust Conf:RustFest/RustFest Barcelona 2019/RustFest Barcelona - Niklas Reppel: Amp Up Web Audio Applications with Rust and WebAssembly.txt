Title: RustFest Barcelona - Niklas Reppel: Amp Up Web Audio Applications with Rust and WebAssembly
Publication date: 2019-11-27
Playlist: RustFest Barcelona 2019
Description: 
	With the advent of the Web Audio API, creating browser-based audio applications became reality, potentially making creative applications available to a wider audience. There’s just one problem: writing real-time digital sound processing code in a garbage-collected language isn’t all that easy. A systems programming language like Rust, on the other hand, is perfectly suited for that task. Cue WebAssembly! Thanks to Rust’s convenient tooling, efficient DSP applications for the web browser can now easily be created, helping to make creative tools available on every platform.

https://barcelona.rustfest.eu/sessions/amp-up-web-audio
Captions: 
	00:00:06,390 --> 00:00:14,539
NIKLAS: Hello?

00:00:14,539 --> 00:00:22,699
Good morning.

00:00:22,699 --> 00:00:24,499
Thanks for having me here.

00:00:24,499 --> 00:00:33,050
I'm Niklas, working for the local research and development centre of Catalonia, Eurecat,

00:00:33,050 --> 00:00:41,760
and my job is making audio software, nowadays still in C++, and I'm fairly new to Rust but

00:00:41,760 --> 00:00:47,440
very well related to Claudia Saxer's talk yesterday.

00:00:47,440 --> 00:00:52,350
My journey was pretty similar in the first few months.

00:00:52,350 --> 00:01:00,440
Today I'm going to talk about the web audio and how Rust can be used for this but also

00:01:00,440 --> 00:01:08,020
a little bit why Rust might be a good option for audio software in general.

00:01:08,020 --> 00:01:14,470
So why would you want to put complex web audio, or complex audio applications on the web in

00:01:14,470 --> 00:01:17,080
the first place?

00:01:17,080 --> 00:01:19,850
I'm part of a community that does music with code.

00:01:19,850 --> 00:01:26,340
I don't know - who does not know live coding here?

00:01:26,340 --> 00:01:32,670
Everybody knows it, I'm surprised.

00:01:32,670 --> 00:01:38,070
Small programming languages, with domain-specific languages, and one of the problems that this

00:01:38,070 --> 00:01:45,240
community has is that workshops often end up being installation workshops and after

00:01:45,240 --> 00:01:55,370
two or three hours people manage to their things which is kind of sad because the stuff

00:01:55,370 --> 00:02:00,689
is fairly easy to use and it's a lot of fun to use and might be educational, a lot of

00:02:00,689 --> 00:02:04,829
people might get interested in the programming but if you need two days just to install,

00:02:04,829 --> 00:02:13,410
I don't know, whatever weird environment people develop the languages on, it might discourage.

00:02:13,410 --> 00:02:20,590
So if you can put it on the web you just need to load a website, you don't need a lot of

00:02:20,590 --> 00:02:30,730
computer literacy and it may just lower the boundary for people to use your stuff and

00:02:30,730 --> 00:02:34,980
might make it more fun for more people.

00:02:34,980 --> 00:02:44,159
I went on a journey to try to put my own stuff to the web and I'm still fairly early in that

00:02:44,159 --> 00:02:51,080
process, but I was looking for the perfect web audio stack, so what are the requirements

00:02:51,080 --> 00:02:54,720
for audio software in general?

00:02:54,720 --> 00:03:01,209
You need a deterministic way of working for the audio thread itself.

00:03:01,209 --> 00:03:04,900
That means you don't - you shouldn't allocate memory in the audio thread.

00:03:04,900 --> 00:03:10,060
You shouldn't lock, you shouldn't wait on conditional variables and all those kind of

00:03:10,060 --> 00:03:18,900
things, and it is inherently multi-threaded because you always have the audio, the realtime

00:03:18,900 --> 00:03:30,800
thread and some control thread at least to either set parameters or schedule stuff, sequencing

00:03:30,800 --> 00:03:34,980
stuff, and so on, and so on.

00:03:34,980 --> 00:03:40,720
Out of personal preference what would be nice to have not only for the within but for audio

00:03:40,720 --> 00:03:50,730
in general, memory safety is a thing because you suddenly get random memory contents pumped

00:03:50,730 --> 00:03:59,769
directly into your ear, what at work we affectionately call noise from hell, then memory safety becomes

00:03:59,769 --> 00:04:07,680
very important suddenly, just to be able to keep on working and not being deaf.

00:04:07,680 --> 00:04:13,090
Portability is a thing because for me, if at some point I would not be happy with the

00:04:13,090 --> 00:04:17,049
web performance anymore and want to have a native programme, it would be nice if it would

00:04:17,049 --> 00:04:18,739
be easy to port.

00:04:18,739 --> 00:04:19,739
Small footprint.

00:04:19,739 --> 00:04:27,690
I don't like bloaty software, and the easier it is to use, the better.

00:04:27,690 --> 00:04:39,060
So options here, eked go with pure JavaScript but it's not that portable, I'm not an expert

00:04:39,060 --> 00:04:46,190
in JavaScript, but I think compiling it to a native executable is something different.

00:04:46,190 --> 00:04:47,580
It's a dynamic scripting language.

00:04:47,580 --> 00:04:52,550
That means it has probably something like garbage collection which in some languages

00:04:52,550 --> 00:04:58,050
can easily stop the audio for a second, you get glitches, and it gets easily bloaty.

00:04:58,050 --> 00:05:03,260
I don't want to chime into JavaScript bashing here, I like JavaScript, but I don't think

00:05:03,260 --> 00:05:05,370
it's the best for this kind of purpose.

00:05:05,370 --> 00:05:12,060
You could just compile C++ with emscripten but that's neither very convenient or very

00:05:12,060 --> 00:05:15,330
comfortable, I don't know.

00:05:15,330 --> 00:05:23,130
So I came across Rust and WebAssembly and that seemed to be a fairly good option.

00:05:23,130 --> 00:05:24,350
Why?

00:05:24,350 --> 00:05:32,510
Well, so first of all I looked around and tried to find something that has already been

00:05:32,510 --> 00:05:39,530
done and I came across this little synthesiser that's not made by me but by some person from

00:05:39,530 --> 00:05:47,470
Japan and that was the proof of concept that showed me: okay, it's actually working.

00:05:47,470 --> 00:06:00,680
It's like a little TV303 simulation, kind of funny.

00:06:00,680 --> 00:06:10,190
[Music] Even though it's still lacking sample playback

00:06:10,190 --> 00:06:17,090
and precise timing and all things that need to be done, but apart from that everything

00:06:17,090 --> 00:06:22,780
that's written about it is in Japanese, which is a beautiful language of which I have very

00:06:22,780 --> 00:06:30,700
little command unfortunately, so I need to put some effort into that.

00:06:30,700 --> 00:06:35,160
So yes, why use Rust for audio applications in the first place?

00:06:35,160 --> 00:06:40,090
And for web audio applications in particular?

00:06:40,090 --> 00:06:46,930
So the memory aspect, memory safety aspect I already lost a few words about that, why

00:06:46,930 --> 00:06:50,630
you would want to have that in audio software.

00:06:50,630 --> 00:06:57,200
Rust boasts itself of fearless concurrency so for multi-threading applications it might

00:06:57,200 --> 00:06:59,650
actually be pretty good.

00:06:59,650 --> 00:07:03,150
It's a deterministic systems programming language.

00:07:03,150 --> 00:07:04,990
Gives you stable results.

00:07:04,990 --> 00:07:12,440
You don't have any garbage collection to deal with and don't have to expect glitches.

00:07:12,440 --> 00:07:16,110
You can port it to the web or if you are not happy with the web audio software anymore

00:07:16,110 --> 00:07:22,300
you could easily compile it to a native executable.

00:07:22,300 --> 00:07:30,610
The WebAssembly integration is very seamless, compared to C++ or other languages where you

00:07:30,610 --> 00:07:35,000
have to struggle with emscripten or whatever.

00:07:35,000 --> 00:07:40,090
For Rust you just set a different target and there you go.

00:07:40,090 --> 00:07:41,880
And last but not least the performance.

00:07:41,880 --> 00:07:52,930
I only did some very casual profiling in the developer console but looking at the numbers

00:07:52,930 --> 00:08:03,710
the main audio processing method needed roughly 15, 20% less than the native JavaScript applications

00:08:03,710 --> 00:08:15,490
to test sample playback and to work around, in general get used to working in Rust and

00:08:15,490 --> 00:08:16,570
WebAssembly.

00:08:16,570 --> 00:08:22,790
This usually needs headphones so it doesn't do a lot on a single speaker but it's a very

00:08:22,790 --> 00:08:30,190
simple sample player and for profiling the stuff I did the same thing in pure JavaScript

00:08:30,190 --> 00:08:37,110
and it seems to be more reliable with Rust and WebAssembly.

00:08:37,110 --> 00:08:43,060
So what are the ingredients of an application made with Rust?

00:08:43,060 --> 00:08:48,430
First of all you need a module compiled to a WebAssembly module.

00:08:48,430 --> 00:08:56,470
Bindgen doesn't really work that well in that context, so it's a raw library that you compile

00:08:56,470 --> 00:08:58,300
to WebAssembly.

00:08:58,300 --> 00:09:09,430
You need the Audio Worklet that is part of the Web API that allows you to do custom processes

00:09:09,430 --> 00:09:15,250
that can use a WebAssembly model.

00:09:15,250 --> 00:09:22,360
You need some setup and control script, obviously the main thread, the user interaction.

00:09:22,360 --> 00:09:32,120
If you want to do any scheduling, any time-based stuff, you need some additional WebWorker

00:09:32,120 --> 00:09:39,570
thread for sequencing and these kind of things and ideally some pure Rust DSP crates that

00:09:39,570 --> 00:09:49,520
easily comply to WebAssembly as opposed to bindings, like if you want to do some advanced

00:09:49,520 --> 00:09:59,450
transform libraries like FFTW or whatever, it's probably harder, but with the pure Rust

00:09:59,450 --> 00:10:03,180
crate that works pretty well.

00:10:03,180 --> 00:10:08,490
What are the challenges of making a web audio application with Rust?

00:10:08,490 --> 00:10:13,940
The Audio Worklet and WebWorker stuff is a little bit tricky because you cannot load

00:10:13,940 --> 00:10:17,810
the models directly.

00:10:17,810 --> 00:10:24,870
You have to fetch them in the main thread and then post them using the message system,

00:10:24,870 --> 00:10:29,400
but once you've got through that, once you've got the setup done, it's fairly easy.

00:10:29,400 --> 00:10:36,220
Setting up the shared memory between the WebAssembly and the main JavaScript is a little bit tricky,

00:10:36,220 --> 00:10:48,070
and as I already said, it was the bindgen for the worklet part itself, exactly because

00:10:48,070 --> 00:10:53,250
of the limitations of the Audio Worklet that you cannot load the module directly in the

00:10:53,250 --> 00:10:59,760
work that you have to post it there in binary data.

00:10:59,760 --> 00:11:04,410
What's already there?

00:11:04,410 --> 00:11:13,530
Crates that support or that help you creating audio software with Rust?

00:11:13,530 --> 00:11:21,040
There's chfft, a pure Rust library if you want to do convolutions.

00:11:21,040 --> 00:11:33,220
I use that followed by normalisation of this part, like for the simulation of the 3D impression,

00:11:33,220 --> 00:11:37,850
and this if you want to check this out with headphones and play around with it a bit,

00:11:37,850 --> 00:11:44,660
the current version is still time-based convolution but the new version that I might upload soon

00:11:44,660 --> 00:11:48,380
is based on actual fast convolutions.

00:11:48,380 --> 00:11:55,580
There's an alternative called Rust FFT but I haven't had a lot of luck with that.

00:11:55,580 --> 00:12:02,830
Basic.dsp crate which I wasn't very happy with, it's a very vector-based way of thinking

00:12:02,830 --> 00:12:09,270
and it's a little bit too detailed maybe but anyway it exists so you might want to check

00:12:09,270 --> 00:12:13,320
it out if you are into dsp and want to do some audio software with Rust.

00:12:13,320 --> 00:12:18,420
What's New York working all that well yet?

00:12:18,420 --> 00:12:25,150
I haven't managed to do any threading directly from Rust, so in the sense that I want to

00:12:25,150 --> 00:12:35,140
spawn a thread to do scheduling tasks, so scheduling music events, so you still have

00:12:35,140 --> 00:12:39,780
to rely on the WebWorkers I think, unless somebody knows something more, and I'm willing

00:12:39,780 --> 00:12:46,160
to learn because as I said I'm still fairly new to that in the first place.

00:12:46,160 --> 00:12:52,480
Debugging is a bit tricky, as we already learned in the talk yesterday.

00:12:52,480 --> 00:12:58,790
You should test your dsp code well to make sure it runs because to debug it directly

00:12:58,790 --> 00:13:01,100
in the WebAssembly part is fairly annoying.

00:13:01,100 --> 00:13:06,550
And unfortunately Audio Worklet is not yet available in Firefox.

00:13:06,550 --> 00:13:16,680
So far it only works in Chrome and Opera, which is a bit sad and I hope it will be implemented

00:13:16,680 --> 00:13:22,960
in a proper way in the future in Firefox as well, but we are not there yet.

00:13:22,960 --> 00:13:25,560
So what is to be done?

00:13:25,560 --> 00:13:30,930
One of my future tasks in general is to do some general benchmarking because I want to

00:13:30,930 --> 00:13:38,030
know how the Rust software on the web in particular but also in general compares to my C++ stuff

00:13:38,030 --> 00:13:44,040
which I haven't done yet, especially regarding fast Fourier transforms which is a central

00:13:44,040 --> 00:13:46,840
thing in my daily work.

00:13:46,840 --> 00:13:54,950
To do past convolutions crate, to be able to do re-works on the web and other things,

00:13:54,950 --> 00:13:59,810
and in general I had hoped maybe somebody would be inspired to do audio software and

00:13:59,810 --> 00:14:06,260
we can sharpen Rust's profile as an audio language in general, so I can avoid in the

00:14:06,260 --> 00:14:11,440
future having random memory contents pumped into my ear directly.

00:14:11,440 --> 00:14:15,330
As I already mentioned, that's not a very pleasant experience.

00:14:15,330 --> 00:14:27,170
So yes, some resources, there's a Rust audio forum, this discourse group.

00:14:27,170 --> 00:14:34,160
The Rust audio environment is actually bigger than you might think.

00:14:34,160 --> 00:14:42,750
There is a VST crate that you can use to do plugins for audio work stations, which I haven't

00:14:42,750 --> 00:14:48,650
used so far but I know it exists, so if you want to look for any resources, that's where

00:14:48,650 --> 00:14:51,230
you would go.

00:14:51,230 --> 00:14:57,750
This is for some examples, if you want to learn from that, especially with the WebAssembly

00:14:57,750 --> 00:14:59,130
part.

00:14:59,130 --> 00:15:05,170
There is this original seminal example that I already presented.

00:15:05,170 --> 00:15:10,470
It's all in Japanese, if you speak Japanese, there's stuff written about that.

00:15:10,470 --> 00:15:15,290
If not, I did the sample player.

00:15:15,290 --> 00:15:20,589
It's well commented so it might be a nice starting point for your own applications if

00:15:20,589 --> 00:15:22,420
you want to check that.

00:15:22,420 --> 00:15:28,910
And last but not least, a more complex example that I made and as you say in my native language

00:15:28,910 --> 00:15:36,090
[German language] I might give you a little demo of that, what life coding means and what

00:15:36,090 --> 00:15:42,310
you can do with Rust audio so put the microphone away and I will give you a little impression

00:15:42,310 --> 00:16:06,110
of that.

00:16:06,110 --> 00:16:53,390
[Music] [Applause]

00:16:53,390 --> 00:18:27,960
Thank you for listening.

00:18:27,960 --> 00:19:19,060
I don't know if there's time for questions, or anything else?

00:19:19,060 --> 00:19:21,350
All of this is running in a web browser.

00:19:21,350 --> 00:19:31,690
It doesn't need any server backend, it just needs a web page and there you go.

00:19:31,690 --> 00:19:41,950
>> Hi, an amazing talk and demonstration, thank you very much.

00:19:41,950 --> 00:19:49,380
Last time I checked for web audio in Firefox I think there was a limitation of 256 milliseconds

00:19:49,380 --> 00:19:51,370
on latency.

00:19:51,370 --> 00:19:57,640
I don't know how it is now but, depending on which kind of application, latency is important.

00:19:57,640 --> 00:20:05,620
Also what is the difference between Audio Worklet and web audio?

00:20:05,620 --> 00:20:11,190
NIKLAS: I would assume it's getting less and less.

00:20:11,190 --> 00:20:16,130
250 milliseconds sounds quite a lot.

00:20:16,130 --> 00:20:21,760
I must admit I'm not - my own work is mostly based just on output, not on input.

00:20:21,760 --> 00:20:27,630
I don't do live processing where this would be very important, but I've seen applications

00:20:27,630 --> 00:20:32,150
that do guitar effects on a web page and they are fast enough so that you can play it with

00:20:32,150 --> 00:20:37,340
the recent advances.

00:20:37,340 --> 00:20:43,620
I don't know if I could find it but there are guitar effects that run on the browser

00:20:43,620 --> 00:20:49,850
that are at least fast enough to test them and not completely bring you out of the rhythm

00:20:49,850 --> 00:20:57,830
when you bring guitar, so I assume that would be better now.

00:20:57,830 --> 00:21:09,980
>> Hi, a great talk by the way.

00:21:09,980 --> 00:21:10,980
NIKLAS: Thank you.

00:21:10,980 --> 00:21:15,880
>> In the Ruffbox play-through there was a sort of scripting language that you typed

00:21:15,880 --> 00:21:19,270
and it made the music.

00:21:19,270 --> 00:21:20,270
NIKLAS: Yes.

00:21:20,270 --> 00:21:21,270
>> What is it?

00:21:21,270 --> 00:21:30,000
NIKLAS: That is just a very, very simple pattern, basically a sequencer that I made to test

00:21:30,000 --> 00:21:31,000
it.

00:21:31,000 --> 00:21:33,480
It doesn't have big functionality.

00:21:33,480 --> 00:21:40,020
That's my next project basically, to make an actual more complex language for the synthesiser

00:21:40,020 --> 00:21:47,150
to use it more productively, or to port, I don't know, my existing stuff to these kind

00:21:47,150 --> 00:21:48,890
of things, and maybe other stuff.

00:21:48,890 --> 00:21:54,149
There's a lot of nice live coding languages, so that's a future project.

00:21:54,149 --> 00:21:56,299
>> Good luck.

00:21:56,299 --> 00:21:59,519
NIKLAS: Thank you.

00:21:59,519 --> 00:22:01,670
>> Final question.

00:22:01,670 --> 00:22:09,030
Raise your hand.

00:22:09,030 --> 00:22:27,030
>> I'm curious if it would be technically possible to do this kind of audio processing

00:22:27,030 --> 00:22:33,890
with the main web audio without Audio Worklet and if you can explain why this needs Audio

00:22:33,890 --> 00:22:37,130
Worklet maybe it would help motivate implementation.

00:22:37,130 --> 00:22:46,670
NIKLAS: There's always multiple ways to do things, but yes, one of the reasons for me

00:22:46,670 --> 00:22:51,570
is that, for example, if the performance isn't enough, I can use it natively as well and

00:22:51,570 --> 00:22:56,780
in different contexts, which might not be that great with pure JavaScript.

00:22:56,780 --> 00:23:02,210
Of course, everything of that could be done in pure JavaScript or with different text

00:23:02,210 --> 00:23:09,950
apps but I think the Web API itself and the nodes it currently provides, it's not that

00:23:09,950 --> 00:23:10,950
flexible.

00:23:10,950 --> 00:23:14,320
For example, all the timing stuff you saw here is done in the Rust part.

00:23:14,320 --> 00:23:20,890
The precise time, the scheduler, the pattern language only gives out very coarse events

00:23:20,890 --> 00:23:28,350
and they are requeued and re-ordered in the Rust part, and so on, and so on, so I think

00:23:28,350 --> 00:23:33,950
the complexity might just be easier to handle if you have a systems programming language

00:23:33,950 --> 00:23:45,340
there instead of the basic web audio API facilities, but of course that's all personal preference,

00:23:45,340 --> 00:23:50,851
so there are of course different ways to do it, and whatever suits your needs, you can

00:23:50,851 --> 00:23:54,210
use it.

00:23:54,210 --> 00:23:55,210
>> Thank you, Niklas.

00:23:55,210 --> 00:23:56,210
Give him a round of applause.

00:23:56,210 --> 00:23:56,211

YouTube URL: https://www.youtube.com/watch?v=fCFPl2LrzJc


