Title: RustFest Barcelona - Zeeshan Ali: zbus: Yet another D-Bus library
Publication date: 2019-11-26
Playlist: RustFest Barcelona 2019
Description: 
	In this talk, I will present zbus, a D-Bus crate written from scratch. D-Bus is an inter-process communication mechanism, available and used on almost all modern Linux desktops and many embedded systems. I will start with why I felt the need to take this huge undertaking on my shoulders, followed by the design goals, the challenges faced and how I overcame them during the development.

https://barcelona.rustfest.eu/sessions/zbus-yet-another-d-bus-library
Captions: 
	00:00:07,359 --> 00:00:08,359
ZEESHAN: Hello?

00:00:08,359 --> 00:00:09,830
Okay, this works.

00:00:09,830 --> 00:00:10,830
Hello, everyone.

00:00:10,830 --> 00:00:18,680
As the MC said, I'm going to present about zbus.

00:00:18,680 --> 00:00:22,779
Before I begin, a big round of applause, please, for the transcriber.

00:00:22,779 --> 00:00:31,300
They are doing an amazing job and it's a really difficult job.

00:00:31,300 --> 00:00:35,030
[Applause] So thank you for that.

00:00:35,030 --> 00:00:37,789
First of all, who am I?

00:00:37,789 --> 00:00:40,130
My name is Zeeshan Ali, as said.

00:00:40,130 --> 00:00:42,920
I work for this small company called redhat.

00:00:42,920 --> 00:00:54,580
I have been working in open source software for a long time.

00:00:54,580 --> 00:01:00,590
Nowadays I work with these cloud weird things in my day job.

00:01:00,590 --> 00:01:05,250
I'm into flying and I love cats.

00:01:05,250 --> 00:01:08,340
So background story about this talk, right?

00:01:08,340 --> 00:01:12,000
It starts with a project called Geoclue.

00:01:12,000 --> 00:01:14,490
Does anyone who what that is?

00:01:14,490 --> 00:01:17,300
You, good.

00:01:17,300 --> 00:01:19,740
It's a framework for your Linux system.

00:01:19,740 --> 00:01:24,040
If you have a Linux desktop you probably have it installed on your machine, if it's a modern

00:01:24,040 --> 00:01:30,701
one, and the task of this service is to locate where you are, so applications, when they

00:01:30,701 --> 00:01:35,000
need access to your location data, that's the service that it needs to talk to.

00:01:35,000 --> 00:01:37,400
Firefox still hasn't ported to that.

00:01:37,400 --> 00:01:46,119
It would be really nice if they do that, if any one of you works on Firefox.

00:01:46,119 --> 00:01:52,100
It's written in C entirely and I have been the maintainer since a re-write.

00:01:52,100 --> 00:01:56,921
There was a complete re-write because the old score was really bad and stuff, and that

00:01:56,921 --> 00:02:02,020
was 2013 so it has been quite many years that I have been maintaining it.

00:02:02,020 --> 00:02:04,189
So I thought: let's oxidise it.

00:02:04,189 --> 00:02:09,369
Those of you who don't know this term, it means to port it to Rust.

00:02:09,369 --> 00:02:10,729
But why?

00:02:10,729 --> 00:02:17,380
Well, it would be singing to the choir but still: crash reports.

00:02:17,380 --> 00:02:19,380
I get crash reports all the time.

00:02:19,380 --> 00:02:26,600
I'm tired of them so I don't want to deal with those anymore.

00:02:26,600 --> 00:02:29,690
Also leaks.

00:02:29,690 --> 00:02:33,940
Your location is one of your most sensitive data on your machine.

00:02:33,940 --> 00:02:40,660
You don't want to give it to any app or - you don't want anything bad to happen to the geodata,

00:02:40,660 --> 00:02:47,569
this data of yours, so that is another reason, but most importantly I just love Rust.

00:02:47,569 --> 00:02:52,510
I don't do Rust in my day job, at least at the moment, so in my spare time at least I

00:02:52,510 --> 00:02:59,900
don't want to look at C and I want to do something nice like Rust.

00:02:59,900 --> 00:03:06,470
So what are the challenges for porting Geoclue to Rust?

00:03:06,470 --> 00:03:13,150
First of all, the thing that came to my mind was this build system called Meson.

00:03:13,150 --> 00:03:21,099
All the system level services like System D and related services on your system, they

00:03:21,099 --> 00:03:22,940
make use of this build system nowadays.

00:03:22,940 --> 00:03:28,910
Also, all of GNOME and hopeful at some point maybe KD will use it too if they are not already.

00:03:28,910 --> 00:03:29,910
I don't know.

00:03:29,910 --> 00:03:38,110
And so yes, Geoclue uses it and it has Rust support in it for a very long time, but doesn't

00:03:38,110 --> 00:03:43,349
have cargo support and it looks unlikely there will ever be any cargo support there.

00:03:43,349 --> 00:03:50,590
So I thought this would be the biggest challenge, but we will see later how it will work out.

00:03:50,590 --> 00:03:54,480
The other thing I thought of was D-Bus, how do I talk to D-Bus?

00:03:54,480 --> 00:03:56,349
What is D-Bus?

00:03:56,349 --> 00:04:04,159
It's a very efficient interprocess communication protocol and it's very popular on the desktop

00:04:04,159 --> 00:04:07,290
and in embedded systems as well.

00:04:07,290 --> 00:04:15,420
As I mentioned, the other projects like System D and related services and GNOME in the same

00:04:15,420 --> 00:04:22,930
two bubbles, D-Bus also exists and it's very popular and I don't see why it wouldn't be.

00:04:22,930 --> 00:04:26,559
It's very awesome and very efficient.

00:04:26,559 --> 00:04:37,059
There is a crate, dbus-rs but it relies on libdbus which is a C code so it relies heavily

00:04:37,059 --> 00:04:48,619
on C code and also it is not shown to be a reliable library.

00:04:48,619 --> 00:04:55,479
There are other issues but I still decided to use it and not just use it but I also contributed

00:04:55,479 --> 00:05:01,139
in terms of issues and patches and stuff and I thought I will just use it.

00:05:01,139 --> 00:05:13,339
Until Rust GNOME Hackfest that happened in May this year, and I started doing it, an

00:05:13,339 --> 00:05:17,219
amazing part turned out to be much, much easier than I thought.

00:05:17,219 --> 00:05:23,530
It's a work-around still but an easy work-around, I can call Meson from D-Bus easily.

00:05:23,530 --> 00:05:33,050
It turns out, I wanted to use code generation, it was very, very complicated.

00:05:33,050 --> 00:05:40,830
Also, sorry, I have to convey a lot of information here so if you don't understand something,

00:05:40,830 --> 00:05:45,419
that's fine, I'm doing a bad job, please grab me after the talk and I will explain further

00:05:45,419 --> 00:05:46,419
to you.

00:05:46,419 --> 00:05:47,550
I will be happy to you.

00:05:47,550 --> 00:05:50,289
That's okay.

00:05:50,289 --> 00:05:52,460
D-Bus crate from scratch?

00:05:52,460 --> 00:05:56,689
I thought maybe that's an option.

00:05:56,689 --> 00:06:00,940
So I was like: how hard can it be?

00:06:00,940 --> 00:06:04,939
[Laughter] So let's see what's involved first.

00:06:04,939 --> 00:06:09,399
I looked at the pack, there is a D-Bus pack, a one page which explains everything.

00:06:09,399 --> 00:06:15,949
It's a really nicely written pack in my opinion so I started the low level and lowest level

00:06:15,949 --> 00:06:24,300
is just message passing on any kind of socket or any kind of medium.

00:06:24,300 --> 00:06:30,929
It's medium agnostic actually, the protocol and there's a wire format that you have to

00:06:30,929 --> 00:06:35,710
implement to be able to talk to D-Bus.

00:06:35,710 --> 00:06:45,169
It's also called GVariant because D-Bus was implemented by non-folks and the main library

00:06:45,169 --> 00:06:53,069
made use of that from the very beginning and they realised that the wire format of D-Bus,

00:06:53,069 --> 00:06:59,289
it can be used in a very generic way so the API is provided to use it in a generic way

00:06:59,289 --> 00:07:07,949
outside of D-Bus as well so it could be like a database and people use it that way.

00:07:07,949 --> 00:07:13,379
What that is, it's mostly defining data types and their encodings.

00:07:13,379 --> 00:07:16,870
By encoding I mean you have to have alignment.

00:07:16,870 --> 00:07:18,490
All the data is aligned.

00:07:18,490 --> 00:07:22,599
If you don't know what alignment means, again grab me after the talk and I will explain

00:07:22,599 --> 00:07:27,740
it to you, what that is all about.

00:07:27,740 --> 00:07:30,379
D-Bus has natural alignment for the most part.

00:07:30,379 --> 00:07:31,770
99% of it.

00:07:31,770 --> 00:07:32,770
There is one exception.

00:07:32,770 --> 00:07:36,150
I will talk later about that.

00:07:36,150 --> 00:07:42,990
Every data type that D-Bus defines has a signature, which is a string which is a suggested designation

00:07:42,990 --> 00:07:44,740
for that particular data type.

00:07:44,740 --> 00:07:49,009
We will see the use of that in a bit.

00:07:49,009 --> 00:07:50,990
So we start with the basic data types.

00:07:50,990 --> 00:07:51,990
What are they?

00:07:51,990 --> 00:07:56,379
They map exactly to the Rust data types.

00:07:56,379 --> 00:07:59,240
It's a subset of Rust data types actually.

00:07:59,240 --> 00:08:03,240
The only difference is that they are encoded differently, of course, because they need

00:08:03,240 --> 00:08:06,879
to go on a socket, not in a programming language.

00:08:06,879 --> 00:08:09,139
Then there's container data types.

00:08:09,139 --> 00:08:14,509
Array maps nicely to a vector or array itself.

00:08:14,509 --> 00:08:19,439
Structure, it's a bit weird to have like a dynamic structure with maps actually to struct

00:08:19,439 --> 00:08:27,179
in Rust, but of course it's more dynamic so we can't just use a struct as there is in

00:08:27,179 --> 00:08:28,179
Rust.

00:08:28,179 --> 00:08:35,349
And dict is just short for dictionary and that maps nicely to hash maps and most importantly

00:08:35,349 --> 00:08:40,120
there's another data type called variant which is basically just generate data.

00:08:40,120 --> 00:08:46,660
So if you want to put - you can put any of the data types I mentioned before in this

00:08:46,660 --> 00:08:52,829
variant and what the variant contains is the signature of the data and the data itself,

00:08:52,829 --> 00:08:57,569
so if you want to transfer data in a very generic way, this is the way and this data

00:08:57,569 --> 00:09:01,290
type is used a lot in D-Bus.

00:09:01,290 --> 00:09:04,130
On a high level, you have objects.

00:09:04,130 --> 00:09:09,980
When you talk to the D-Bus you usually deal with objects that are exposed on these specific

00:09:09,980 --> 00:09:10,980
paths.

00:09:10,980 --> 00:09:17,600
These are shown here, the object paths, and the way you talk to them is through interfaces.

00:09:17,600 --> 00:09:21,329
This is a really horrible example, sorry for that.

00:09:21,329 --> 00:09:27,300
There's a one-to-one relationship here between the objects and the interfaces, but it doesn't

00:09:27,300 --> 00:09:28,300
have to be.

00:09:28,300 --> 00:09:33,519
Any object can implement any number of interfaces and what that means is that, if they implement

00:09:33,519 --> 00:09:36,660
an interface, they need to provide specific API of that interface.

00:09:36,660 --> 00:09:50,579
You can have methods and they have to have the data types that I said before.

00:09:50,579 --> 00:09:53,910
Signals is just a method but in the reverse direction.

00:09:53,910 --> 00:10:00,190
If the service needs to notify apps of some change, they use these signals, and they also

00:10:00,190 --> 00:10:04,310
have parameters, but only I think in parameters - also out parameters.

00:10:04,310 --> 00:10:08,259
We are not sure right now.

00:10:08,259 --> 00:10:14,280
And of course they can have properties that they expose and they can be read only, they

00:10:14,280 --> 00:10:18,939
can be read write.

00:10:18,939 --> 00:10:22,630
So I thought actually it's not that hard after all.

00:10:22,630 --> 00:10:27,270
Am I going too fast?

00:10:27,270 --> 00:10:29,870
Okay.

00:10:29,870 --> 00:10:37,459
So after three days, which includes the Hackfest and I had an excuse to not do my work-work,

00:10:37,459 --> 00:10:44,550
I could do Rust and I started implementing it first as a hack and what I could accomplish

00:10:44,550 --> 00:10:53,360
in three days, the first day I established a connection to the D-Bus on the service,

00:10:53,360 --> 00:10:54,470
and I called a method.

00:10:54,470 --> 00:10:56,240
That felt so great.

00:10:56,240 --> 00:11:01,360
Within three days I could do this.

00:11:01,360 --> 00:11:04,040
So I was like: yes, let's do this.

00:11:04,040 --> 00:11:07,690
It doesn't sound too hard!

00:11:07,690 --> 00:11:09,870
So zbus was born.

00:11:09,870 --> 00:11:10,870
Don't ask about the name.

00:11:10,870 --> 00:11:14,319
It's a cool name and you have to accept it.

00:11:14,319 --> 00:11:18,860
[Laughter] So let's start with the hard part, the low

00:11:18,860 --> 00:11:27,420
level, which is called the GVariant as I mentioned before, which is dealing with the data types.

00:11:27,420 --> 00:11:37,379
So I came up with this to represent the data type that can be encoded to and encoded from

00:11:37,379 --> 00:11:40,269
D-Bus wire format.

00:11:40,269 --> 00:11:44,189
It's pretty simple actually, I think.

00:11:44,189 --> 00:11:47,699
Encoding is - I tried to make it very efficient.

00:11:47,699 --> 00:11:54,370
Encoding, I can't make it efficient because you have to copy data because the D-Bus encoding

00:11:54,370 --> 00:11:59,740
is different from the Rust encoding so there's no way out of this as far as I know.

00:11:59,740 --> 00:12:02,020
If you know a way out of it, please do tell me.

00:12:02,020 --> 00:12:03,860
I would love to know that.

00:12:03,860 --> 00:12:08,820
But decoding, I made it very efficient so that you don't have to copy the data.

00:12:08,820 --> 00:12:13,439
Only for container types you have to allocate, but even that only the container, not the

00:12:13,439 --> 00:12:15,939
actual data contained in it.

00:12:15,939 --> 00:12:20,829
Signature, you might see there's a constant signature and then there's a signature.

00:12:20,829 --> 00:12:27,970
For simple data types it's exactly the same, the screen that you represent, it is one corrector,

00:12:27,970 --> 00:12:33,250
but for complex data types, the container types, they have to also specify what is included

00:12:33,250 --> 00:12:37,230
in them so it's more dynamic, so it's not the same.

00:12:37,230 --> 00:12:41,629
The constant - actually, I have a pointer!

00:12:41,629 --> 00:12:45,639
But it doesn't work on this, does it?

00:12:45,639 --> 00:12:46,810
No.

00:12:46,810 --> 00:12:52,569
Anyway, so this signature, the constant that you see on the top and the signature method,

00:12:52,569 --> 00:12:57,440
they don't always have the same output.

00:12:57,440 --> 00:13:02,029
So basic data types as I mentioned before, the same as Rust, very easy to implement.

00:13:02,029 --> 00:13:03,029
I did that.

00:13:03,029 --> 00:13:05,860
Container types were the next.

00:13:05,860 --> 00:13:12,999
Arrays, as I said, vector, only thing is that I had a constraint that it can only have the

00:13:12,999 --> 00:13:15,759
variant type in it.

00:13:15,759 --> 00:13:21,649
All the other types, the D-Bus support, not anything else.

00:13:21,649 --> 00:13:28,310
Structures: yes, I have to create another data type for that.

00:13:28,310 --> 00:13:31,830
Captured as simple as I could.

00:13:31,830 --> 00:13:37,110
You have fields on the structure and you can create them and then you can use that, and

00:13:37,110 --> 00:13:43,939
then you implement variant type for it so that you can encode and decode structures.

00:13:43,939 --> 00:13:50,480
Of course, the most important one is variant which as I said contains a signature of what

00:13:50,480 --> 00:13:54,660
it contains and the data in encoded format.

00:13:54,660 --> 00:13:59,170
Now, this is the important bit that, it keeps already in encoded format.

00:13:59,170 --> 00:14:01,990
It doesn't encode when it's needed, but already.

00:14:01,990 --> 00:14:05,110
I thought that would be more efficient.

00:14:05,110 --> 00:14:09,420
We will see later how much trouble that gave me.

00:14:09,420 --> 00:14:14,160
So yes, this is how you will use variant in isolation without D-Bus.

00:14:14,160 --> 00:14:17,480
There is no D-Bus here so this is the type I came up with.

00:14:17,480 --> 00:14:26,079
This is my unit test which just shows you, you create a type that is D-Bus - which implements

00:14:26,079 --> 00:14:31,620
for a type and then you create a variant from that and then you can do different tests on

00:14:31,620 --> 00:14:32,620
it.

00:14:32,620 --> 00:14:38,660
You can get the data back from it and you can - once it's encoded you can also decode

00:14:38,660 --> 00:14:40,339
it and stuff.

00:14:40,339 --> 00:14:41,749
Yes.

00:14:41,749 --> 00:14:51,899
I lied before when I showed the variant type frame.

00:14:51,899 --> 00:15:00,880
It has lifetimes on it and I did it to be as efficient as possible and I was successful

00:15:00,880 --> 00:15:05,309
in making it efficient, but at the same time it made life much, much harder.

00:15:05,309 --> 00:15:10,329
Each time I change anything, lifetimes come in the way and I have been bugging lots of

00:15:10,329 --> 00:15:15,529
people, especially Florian over there, about how to deal with lifetimes.

00:15:15,529 --> 00:15:25,999
Oops, sorry, I pressed the wrong button.

00:15:25,999 --> 00:15:26,999
So back to D-Bus.

00:15:26,999 --> 00:15:30,800
So this is what the D-Bus API looks like.

00:15:30,800 --> 00:15:36,470
You just create a connection, there's two kind of common connections that you talk to,

00:15:36,470 --> 00:15:40,040
one is a session connection which is for the user and then there is the system connection

00:15:40,040 --> 00:15:47,670
which is used by, for example, Geoclue for system services, and then you just call a

00:15:47,670 --> 00:15:48,670
method on it.

00:15:48,670 --> 00:15:55,980
You specify the - there's the service, the path, the interface and the method and parameters

00:15:55,980 --> 00:16:00,589
which are zero here, so I pass none.

00:16:00,589 --> 00:16:08,600
Then you get a reply and then you get the first out parameter and it's the type of string

00:16:08,600 --> 00:16:14,689
so I could get the string and display it.

00:16:14,689 --> 00:16:16,559
All done with variants, right?

00:16:16,559 --> 00:16:18,240
It's all done?

00:16:18,240 --> 00:16:20,660
That's what I thought and I thought: like, yes.

00:16:20,660 --> 00:16:26,649
I didn't talk about an additional part which I implemented really late but it's kind of

00:16:26,649 --> 00:16:32,540
implemented already, and I thought: I'm done with variants.

00:16:32,540 --> 00:16:37,060
But I added new test cases for the dictionary.

00:16:37,060 --> 00:16:41,820
Actually, these test cases were more complex and I was like: why is it failing?

00:16:41,820 --> 00:16:48,180
I thought maybe I had made the wrong test case or something else wrong with it.

00:16:48,180 --> 00:16:49,370
And then I had this face.

00:16:49,370 --> 00:16:51,160
This is an actual picture of me actually.

00:16:51,160 --> 00:16:53,769
That's how I felt.

00:16:53,769 --> 00:16:57,670
[Laughter] Variant alignment is all wrong.

00:16:57,670 --> 00:17:00,019
It's completely wrong.

00:17:00,019 --> 00:17:01,579
Why?

00:17:01,579 --> 00:17:03,720
D-Bus has a few strange rules.

00:17:03,720 --> 00:17:06,959
Turns out, D-Bus is not that easy after all.

00:17:06,959 --> 00:17:16,520
[Laughing] So first of all alignment of data when you encode it is based on the whole message,

00:17:16,520 --> 00:17:17,810
it's not individual levels.

00:17:17,810 --> 00:17:25,320
So if you put an integer in a structure the alignment is not based on the parent structure

00:17:25,320 --> 00:17:35,750
but the whole message when you put all the data together, which is okay on its own, but

00:17:35,750 --> 00:17:40,539
that's not the only - and also if you see at first what I came up with, there is no

00:17:40,539 --> 00:17:49,970
way with this API, I don't pass to encoder how many bytes were before, so this API cannot

00:17:49,970 --> 00:17:57,700
accomplish this but I modified it soon after and added 10 bytes before so then the encoder

00:17:57,700 --> 00:18:03,630
knew how many bytes were before so it knew how much padding to add for alignment and

00:18:03,630 --> 00:18:13,039
stuff like that so that was an easy problem to solve on its own, but variants and contained

00:18:13,039 --> 00:18:20,720
value do not need alignment, which is okay but - surprising, but okay, we will deal with

00:18:20,720 --> 00:18:21,720
this.

00:18:21,720 --> 00:18:25,809
It's no alignment, better, but the problem is its grandchildren do.

00:18:25,809 --> 00:18:32,890
If you have, for example, a structure in a variant that structure does not need padding

00:18:32,890 --> 00:18:39,929
nor alignment but all the fields in the structure, they do, so how do you pass that along, all

00:18:39,929 --> 00:18:41,740
the information?

00:18:41,740 --> 00:18:47,730
As I showed you before, variant already keeps things in encoded format so when you create

00:18:47,730 --> 00:18:52,870
a variant in isolation then you put it in a message the encoding is not correct and

00:18:52,870 --> 00:18:57,970
that's what was wrong in my whole thing, so it turns out my whole structure, the whole

00:18:57,970 --> 00:19:03,510
API I built in three months was fundamentally wrong.

00:19:03,510 --> 00:19:07,990
So I have been on this for a month now.

00:19:07,990 --> 00:19:12,370
Mind you, I only work on this in my spare time which is very limited, so one month is

00:19:12,370 --> 00:19:16,350
not that long in reality.

00:19:16,350 --> 00:19:19,760
So I still have not solved this problem.

00:19:19,760 --> 00:19:22,270
I came up with multiple solutions.

00:19:22,270 --> 00:19:27,559
They all had some problem in the end after all and I couldn't solve it.

00:19:27,559 --> 00:19:33,029
Now I have a solution but before I implement it I have to kill the lifetimes from the very

00:19:33,029 --> 00:19:34,029
end.

00:19:34,029 --> 00:19:40,169
Because that makes - when I said I came up with multiple solutions and many of them failed

00:19:40,169 --> 00:19:47,649
because of this lifetimes because I just couldn't satisfy the lifetimes, so the lesson I learned

00:19:47,649 --> 00:19:51,860
from all this practice is that efficiency is not a religion.

00:19:51,860 --> 00:19:58,370
I was being so focused on making it very efficient that I wasn't making it more efficient than

00:19:58,370 --> 00:20:06,169
I would be in C. In C, I would be using something called GObjects from GLib API and they use

00:20:06,169 --> 00:20:08,430
reference counting all the time.

00:20:08,430 --> 00:20:13,450
That's what they are based on, and their reference counting is by default atomic so it's much

00:20:13,450 --> 00:20:21,740
more heavier than the RC reference counting type in Rust, so why not use it?

00:20:21,740 --> 00:20:29,350
So with our team I would really like to make use - to share data between different points

00:20:29,350 --> 00:20:32,350
of the code and then it will work out.

00:20:32,350 --> 00:20:33,350
I have a solution.

00:20:33,350 --> 00:20:34,350
It will work.

00:20:34,350 --> 00:20:39,529
If not, I'm in this conference for three more, four more days, so I will grab someone to

00:20:39,529 --> 00:20:41,330
help me.

00:20:41,330 --> 00:20:43,809
That's my hope at least.

00:20:43,809 --> 00:20:49,680
Anyway, once I solve that problem, which I will, looking forward, I want to separate

00:20:49,680 --> 00:20:52,260
out the variant crate into its own crate.

00:20:52,260 --> 00:20:59,409
As I said, it's useful in a generic way and there is one application in Rust that the

00:20:59,409 --> 00:21:03,649
maintainers said yes, if you make a crate, I will use it, so yes.

00:21:03,649 --> 00:21:06,740
I have to do that.

00:21:06,740 --> 00:21:13,860
Then in D-Bus, we have an API for receiving messages, I have to implement signals which

00:21:13,860 --> 00:21:16,330
should be really trivial actually.

00:21:16,330 --> 00:21:19,950
"Should be", in quotes.

00:21:19,950 --> 00:21:28,970
Async, I need to add asynchronous API, and I'm hoping that actually the API will just

00:21:28,970 --> 00:21:35,620
be asynchronous by default and hoping to use the new async STD, or how do you pronounce

00:21:35,620 --> 00:21:38,370
it, I don't know, crate.

00:21:38,370 --> 00:21:44,290
It looks pretty awesome, that crate, and also it's good that I was stuck on the variant

00:21:44,290 --> 00:21:52,289
part until now so that all the async stories, all in stable, so I can just use the async

00:21:52,289 --> 00:21:54,690
from stable.

00:21:54,690 --> 00:21:56,679
High level API, then I need to add.

00:21:56,679 --> 00:22:02,940
That shouldn't be extremely hard but I need to be careful in creating a good API.

00:22:02,940 --> 00:22:11,570
Fortunately, GLib has a really good high level API and I can copy that; not copy, but I can

00:22:11,570 --> 00:22:17,620
learn a lot from that so I don't need to figure out a lot of things.

00:22:17,620 --> 00:22:24,720
Code generation: most of the D-Bus code that I see out there, they use code generation.

00:22:24,720 --> 00:22:31,470
You give it like - you can define your D-Bus API in XML which people do and you can give

00:22:31,470 --> 00:22:40,240
it to code generator and it generates the code so I need on implement that, and maybe

00:22:40,240 --> 00:22:43,890
also macros for making it super easy.

00:22:43,890 --> 00:22:48,000
If you don't want to do code generation, some people, I don't know why, but they don't like

00:22:48,000 --> 00:22:53,640
code generation, so sure for them there should be some macros.

00:22:53,640 --> 00:22:57,071
And a lot more of easy stuff.

00:22:57,071 --> 00:22:58,071
Yes, that's it from me.

00:22:58,071 --> 00:22:59,071
If you have any questions.

00:22:59,071 --> 00:23:00,071
[Applause] No questions?

00:23:00,071 --> 00:23:01,071
Everything was clear?

00:23:01,071 --> 00:23:02,071
Yes, there is a question.

00:23:02,071 --> 00:23:03,071
Do you get a mic?

00:23:03,071 --> 00:23:04,071
It's better.

00:23:04,071 --> 00:23:05,071
>> Tech team, please enable microphone 2.

00:23:05,071 --> 00:23:06,071
>> [Question off mic].

00:23:06,071 --> 00:23:07,071
ZEESHAN: Yes, when I said receiving messages, that's the server side, yes.

00:23:07,071 --> 00:23:08,071
That's coming.

00:23:08,071 --> 00:23:09,071
I need it myself for Geoclue.

00:23:09,071 --> 00:23:10,071
That's the main use for me, so it will definitely be there.

00:23:10,071 --> 00:23:11,071
Someone else?

00:23:11,071 --> 00:23:12,071
>> It's working, so I have a magic hand.

00:23:12,071 --> 00:23:13,071
So you were saying that performance shouldn't be an issue, but did you compare it to native

00:23:13,071 --> 00:23:14,071
implementation in GNOME or other implementations?

00:23:14,071 --> 00:23:15,071
How does it fare?

00:23:15,071 --> 00:23:16,071
ZEESHAN: I haven't done any actual comparisons but I could see that I'm not allocating anything

00:23:16,071 --> 00:23:17,071
or copying anything, so yes, I made sure of that, so that's the way I know it's as efficient

00:23:17,071 --> 00:23:18,071
as it would be, but no, I haven't done any real comparisons.

00:23:18,071 --> 00:23:19,071
Once I'm ready, once it's done, then I can look at that.

00:23:19,071 --> 00:23:20,071
>> Any more questions?

00:23:20,071 --> 00:23:21,071
No?

00:23:21,071 --> 00:23:22,071
One more.

00:23:22,071 --> 00:23:23,071
>> Could you explain alignment?

00:23:23,071 --> 00:23:24,071
ZEESHAN: [Laughing] So some CPUs require you to start your messages and to be able to read

00:23:24,071 --> 00:23:25,071
specific data types from on a particular boundary, so the memory address has to start with some

00:23:25,071 --> 00:23:26,071
multiple - or it has to be a multiple of 8 bytes, something like that.

00:23:26,071 --> 00:23:27,071
That's as far as I know, so that's why you need alignment.

00:23:27,071 --> 00:23:28,071
If you generate protocol that's CPU or architecture agnostic you need to make sure of the padding

00:23:28,071 --> 00:23:29,071
and the alignment.

00:23:29,071 --> 00:23:30,071
The way to align is that you do something called padding, and padding means you just

00:23:30,071 --> 00:23:31,071
add zero bytes before the data starts so make it so that that data actually starts at a

00:23:31,071 --> 00:23:32,071
boundary that is defined for that data type.

00:23:32,071 --> 00:23:33,071
So, for example, as I said, natural alignment in D-Bus, what that means is that, if it's

00:23:33,071 --> 00:23:34,071
a 4 byte integer it has to be aligned with 4 byte value, so you have to have 4 bytes

00:23:34,071 --> 00:23:35,071
of padding if it doesn't start at a multiple of four address.

00:23:35,071 --> 00:23:36,071
Things like that.

00:23:36,071 --> 00:23:37,071
Okay?

00:23:37,071 --> 00:23:38,071
So thank you so much for attending and I hope you understood some of it at least.

00:23:38,071 --> 00:23:39,071
And if you don't, as I said, let me know.

00:23:39,071 --> 00:23:40,071
I'm very happy to explain things to you.

00:23:40,071 --> 00:23:41,071
I'm wearing the green one, so you can do that.

00:23:41,071 --> 00:23:41,072

YouTube URL: https://www.youtube.com/watch?v=iWVn48Av8Ng


