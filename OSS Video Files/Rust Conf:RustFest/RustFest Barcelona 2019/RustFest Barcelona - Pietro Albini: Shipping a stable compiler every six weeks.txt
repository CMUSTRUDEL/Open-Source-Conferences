Title: RustFest Barcelona - Pietro Albini: Shipping a stable compiler every six weeks
Publication date: 2019-11-29
Playlist: RustFest Barcelona 2019
Description: 
	A new version of the Rust compiler is released every six weeks, with lots of new features and bug fixes in it. So far the Rust team managed to ship stable releases on schedule with almost no regressions, ensuring everyone can upgrade their toolchain without fear of broken builds. This talk explains how our release process works and the tools we developed to catch regressions before our users do.

https://barcelona.rustfest.eu/sessions/shipping-a-compiler
Captions: 
	00:00:05,060 --> 00:00:35,860
PIETRO: Hi, everyone.

00:00:35,860 --> 00:00:45,090
In this talk I am going to shed a bit of light on why we - on how it works and why we do

00:00:45,090 --> 00:00:46,230
it that way.

00:00:46,230 --> 00:00:51,730
As they said, I'm Pietro, a member of the Rust release team and a colleague of the infrastructure

00:00:51,730 --> 00:00:53,460
team.

00:00:53,460 --> 00:01:00,170
I'm actually a member of other teams, but I do a lot of stuff in the project.

00:01:00,170 --> 00:01:04,930
I think everyone is aware by now that we actually got our release out a few days ago, with some

00:01:04,930 --> 00:01:11,250
features everyone waited for, for a long time but that's not the only release.

00:01:11,250 --> 00:01:19,679
Six weeks later we released 1.38 which was released in September and changed a lot of

00:01:19,679 --> 00:01:21,759
code.

00:01:21,759 --> 00:01:25,249
Users just reported 5 regressions after the release.

00:01:25,249 --> 00:01:31,390
Two of them just broke valid code.

00:01:31,390 --> 00:01:40,139
Six weeks earlier, there was another release, and this changed tens of thousands of lines

00:01:40,139 --> 00:01:45,960
of code and we just got three regressions reported and unfortunately all of them broke

00:01:45,960 --> 00:01:50,600
valid code, but it's a very little number.

00:01:50,600 --> 00:01:58,470
Even before, we got 1.46 out in July with just four regressions supported so I wanted

00:01:58,470 --> 00:02:05,560
to explain a little bit why we do releases this fast which creates a lot of problems

00:02:05,560 --> 00:02:13,300
for us and how can we prevent regressions, and just get very few reported after the release

00:02:13,300 --> 00:02:15,220
is out?

00:02:15,220 --> 00:02:17,260
So why do we have this schedule?

00:02:17,260 --> 00:02:22,599
The question is interesting because it's really unusual in the compiler world.

00:02:22,599 --> 00:02:27,481
I collected some stats on some of the most popular languages, like why there are some

00:02:27,481 --> 00:02:29,569
efforts to shorten the release cycle.

00:02:29,569 --> 00:02:35,230
Python recently announced that they are going to switch to a year schedule.

00:02:35,230 --> 00:02:43,819
Rust is sort of popular and has a six-week release cycle.

00:02:43,819 --> 00:02:48,760
In a compiler world that's pretty fast, but there is a simple reason why we do that.

00:02:48,760 --> 00:02:51,510
We have no pressure to ship things.

00:02:51,510 --> 00:02:57,049
If a feature is not ready, we have issues, we can just delay it by a few weeks and nobody

00:02:57,049 --> 00:03:01,989
is going to care if it's going to get stabilised today or in a month and a half.

00:03:01,989 --> 00:03:03,680
And we actually do that a lot.

00:03:03,680 --> 00:03:10,909
The most obvious example is a few weeks ago, when we decided that async/await wasn't ready

00:03:10,909 --> 00:03:18,030
enough to be shipped into Rust 1.38 because it turns out it wasn't actually stabilised

00:03:18,030 --> 00:03:21,950
when the beta freeze happened and there were blocker issues so we would have to crash the

00:03:21,950 --> 00:03:29,140
future and that's something that we would not love to do.

00:03:29,140 --> 00:03:38,420
We actually tried long release cycles and it turns out we don't actually - it doesn't

00:03:38,420 --> 00:03:40,319
work for us.

00:03:40,319 --> 00:03:45,939
The addition came out - the stable edition came out in early December and in September

00:03:45,939 --> 00:03:52,390
we still had questions: how to make the module system work?

00:03:52,390 --> 00:03:57,909
We had a proposal at the end of September which was not implemented yet and that's what

00:03:57,909 --> 00:04:05,489
actually was released, but the proposal had no time, users didn't have much time to break

00:04:05,489 --> 00:04:06,489
it.

00:04:06,489 --> 00:04:08,760
It broke a lot of our internal processes.

00:04:08,760 --> 00:04:14,610
We actually did this thing which is something I'm not comfortable with still, which is we

00:04:14,610 --> 00:04:20,330
actually learned that a change in the behaviour of the model system directly on the beta branch,

00:04:20,330 --> 00:04:24,910
two weeks before the stable release came out, and if we did a mistake there we would have

00:04:24,910 --> 00:04:28,500
no way to roll it back before waiting for the next edition and we don't even know if

00:04:28,500 --> 00:04:31,780
we are going to do the 2021 edition yet.

00:04:31,780 --> 00:04:40,639
This broke almost all the policies we have but we had to do it because otherwise we would

00:04:40,639 --> 00:04:50,310
not be able to ship a working condition, and thankfully it ended great.

00:04:50,310 --> 00:04:55,919
I'm not aware of any huge mistakes we made but if we actually made them it would be really

00:04:55,919 --> 00:05:03,090
bad because we would have to wait a lot to fix them and we would be stuck in the 2018

00:05:03,090 --> 00:05:07,840
edition with a broken features set for compatibility reasons.

00:05:07,840 --> 00:05:13,630
So with such fast early cycle, how can you actually prevent regressions from reaching

00:05:13,630 --> 00:05:15,820
the stable channel?

00:05:15,820 --> 00:05:21,599
Of course, the first answer is the compiler's test suite because rustc has a lot of tests.

00:05:21,599 --> 00:05:28,699
We have thousands of them that test both the compiled outward but also their messages and

00:05:28,699 --> 00:05:35,440
we have builders for each poll request which takes three to four hours so we actually do

00:05:35,440 --> 00:05:41,720
a lot of testing but that's not enough because a test suite can't really express everything

00:05:41,720 --> 00:05:43,870
that Rust language can do.

00:05:43,870 --> 00:05:48,419
So of course we use the compiler to build the compiler itself.

00:05:48,419 --> 00:05:52,270
Because for every release we use the previous one to build the compiler.

00:05:52,270 --> 00:05:56,120
Like on nat we used beta, on beta we used stable and on stable we used the previous

00:05:56,120 --> 00:05:57,740
stable.

00:05:57,740 --> 00:06:03,729
That allows us to cut some corners because the compiler bases use some unstable features

00:06:03,729 --> 00:06:10,310
and also it's a bit old so there are a lot of quirks in it but still that can't catch

00:06:10,310 --> 00:06:12,070
everything.

00:06:12,070 --> 00:06:15,660
We get back reports from you all.

00:06:15,660 --> 00:06:22,789
We get them mostly from nat, not from beta, because people don't actually use beta.

00:06:22,789 --> 00:06:27,340
Asking our users to test beta is something we can't really do.

00:06:27,340 --> 00:06:34,419
With such a fast cycle we don't have time to test everything manually with the new compiler

00:06:34,419 --> 00:06:41,370
every six weeks; and languages with long release cycles can afford to test the beta release,

00:06:41,370 --> 00:06:48,379
but we can't, and even when we ask, people don't really do that, so we actually had an

00:06:48,379 --> 00:06:49,379
idea.

00:06:49,379 --> 00:06:51,250
Why don't we test our users' code ourselves?

00:06:51,250 --> 00:06:57,620
This is an idea that seems really bad and seems to waste a lot of money but it actually

00:06:57,620 --> 00:07:00,900
works and it's Crater.

00:07:00,900 --> 00:07:07,380
Crater is a project that Brian Anderson started and I'm now the maintainer of which creates

00:07:07,380 --> 00:07:15,520
experiments which actually get all the source code available on crates.io and all the Rust

00:07:15,520 --> 00:07:28,210
[inaudible] on GitHub with the cargo, so it's actually tested for every release to catch

00:07:28,210 --> 00:07:29,319
regressions.

00:07:29,319 --> 00:07:36,889
For each project we run cargo test two times, once with stable and one with beta and if

00:07:36,889 --> 00:07:43,139
the cargo tests runs on beta - on stable but fails on beta then that's a regression and

00:07:43,139 --> 00:07:47,169
we get a nice colourful report where we can inspect them.

00:07:47,169 --> 00:07:54,199
This is the actual report for 1.38 and we got just 46 crates that failed and those are

00:07:54,199 --> 00:07:57,639
regressions nobody reported before.

00:07:57,639 --> 00:08:05,380
Then manually, it goes through each - I hope we didn't break any of yours - and manages

00:08:05,380 --> 00:08:11,789
the log and then files the issue so then the compiler team looks at the issues, fixes them

00:08:11,789 --> 00:08:15,400
and ships the fix to you all.

00:08:15,400 --> 00:08:22,939
1.39 went pretty well - this is 1.38 and we actually had 600 crates that were broken so

00:08:22,939 --> 00:08:28,930
if we didn't have Crater there is a good chance your project wouldn't compile anymore and

00:08:28,930 --> 00:08:34,430
this would break the trust you have.

00:08:34,430 --> 00:08:37,130
We know it's not perfect.

00:08:37,130 --> 00:08:47,680
We don't test any kind of code because we don't have access to your source code and

00:08:47,680 --> 00:08:55,690
nobody got round to write scrapers yet, and also not every crate can be built in a sandbox

00:08:55,690 --> 00:09:00,380
environment.

00:09:00,380 --> 00:09:11,230
It's not really something we can scale forever in the long term because it uses a lot of

00:09:11,230 --> 00:09:18,250
computer sources already, which thankfully are sponsored, but if the users sky rocket

00:09:18,250 --> 00:09:23,000
we are going to reach a point where it's not economically feasible to run Crater in a timely

00:09:23,000 --> 00:09:27,560
fashion anymore.

00:09:27,560 --> 00:09:31,529
Those are real problems but for now it works great.

00:09:31,529 --> 00:09:39,779
It allows the types of regressions that often affect some thousands of crates and it's a

00:09:39,779 --> 00:09:43,030
real reason why we can afford to make such fast releases.

00:09:43,030 --> 00:09:47,670
Without it, this is my personal opinion, but I know it's shared by other members of the

00:09:47,670 --> 00:09:53,420
release team, I wouldn't be comfortable making releases every six weeks without Crater because

00:09:53,420 --> 00:09:57,889
they would be so buggy I wouldn't use them myself.

00:09:57,889 --> 00:10:06,420
So to recap, the fast release cycles that we have allow the team not to burn out and

00:10:06,420 --> 00:10:14,250
to simply ignore deadlines, and that's great especially for a community of mostly volunteers.

00:10:14,250 --> 00:10:17,589
And Crater is the real reason why we can afford to do that.

00:10:17,589 --> 00:10:25,200
It's a tool that wastes a lot of money but actually gets us great results.

00:10:25,200 --> 00:10:29,930
So unfortunately I don't think I have time for questions, but I'm going to be around

00:10:29,930 --> 00:10:37,970
the conference today so if you have any questions, you want to implement support for the repositories,

00:10:37,970 --> 00:10:44,100
reach out to me, I'm happy to talk to you all, and thanks.

00:10:44,100 --> 00:10:52,899
[Applause] >> Actually, you have some time for questions.

00:10:52,899 --> 00:10:56,749
PIETRO: Oh, that's great.

00:10:56,749 --> 00:11:05,110
>> Do we have time for one question or two, because I have actually two.

00:11:05,110 --> 00:11:07,529
PIETRO: I don't know that.

00:11:07,529 --> 00:11:14,820
>> Okay, so first question, you were hinting that maybe the addition idea wasn't such a

00:11:14,820 --> 00:11:15,820
success for us.

00:11:15,820 --> 00:11:22,290
Would you think that jeopardises a possible 2021 edition of the language?

00:11:22,290 --> 00:11:27,700
PIETRO: Like the man issue wasn't really the addition itself; it was that we actually started

00:11:27,700 --> 00:11:29,649
working on it really late.

00:11:29,649 --> 00:11:35,860
So basically we went way over time with implementing the features.

00:11:35,860 --> 00:11:45,610
This is my personal opinion, it's not the official opinion of the project, but if we

00:11:45,610 --> 00:11:51,340
make another edition I want explicit phrases that we won't accept any more changes after

00:11:51,340 --> 00:11:56,459
this date and to actually enforce that because we nearly burnt out most of the team with

00:11:56,459 --> 00:11:57,459
the edition.

00:11:57,459 --> 00:12:02,699
There were people that were just for months fixing regressions and fixing bugs and that's

00:12:02,699 --> 00:12:08,959
not sustainable, especially because most of the contributors to the compiler are volunteers.

00:12:08,959 --> 00:12:10,250
>> Okay.

00:12:10,250 --> 00:12:12,899
I will ask also my second question.

00:12:12,899 --> 00:12:19,620
So the second question is: for private repository, of course you cannot run Crater, but how could

00:12:19,620 --> 00:12:27,230
somebody who has a private repository, a private crate setup, would run Crater, or is that

00:12:27,230 --> 00:12:28,410
possible now?

00:12:28,410 --> 00:12:34,959
PIETRO: Someone could just test on Crater and create bug reports if they could face

00:12:34,959 --> 00:12:37,220
compile.

00:12:37,220 --> 00:12:44,459
We have some ideas on how to create a Crater for enterprises but it's just a plan, an idea,

00:12:44,459 --> 00:12:49,550
and at the moment we don't have enough development resources to actually do the implementation

00:12:49,550 --> 00:12:53,620
test and documentation work that such a project would require.

00:12:53,620 --> 00:12:57,420
>> So that would be necessary to support Crater in a private environment?

00:12:57,420 --> 00:12:58,970
PIETRO: Yes.

00:12:58,970 --> 00:12:59,970
>> Okay.

00:12:59,970 --> 00:13:05,600
>> Any other questions?

00:13:05,600 --> 00:13:10,649
>> A lot of crates have peculiar requirements about their environments.

00:13:10,649 --> 00:13:18,779
Can you talk about how Crater handles that and specifically is it possible to customise

00:13:18,779 --> 00:13:23,480
the environment in which my crates are built on Crater?

00:13:23,480 --> 00:13:29,470
PIETRO: So the environment doesn't have any kind of network access for obvious security

00:13:29,470 --> 00:13:39,750
reasons, so you can't really - you can't install the dependency yourself but the build environment

00:13:39,750 --> 00:13:41,480
runs inside Docker.

00:13:41,480 --> 00:13:49,740
We have these big Docker images, 4GB, which just has our usual packages installed, so

00:13:49,740 --> 00:13:56,390
if you know your crate doesn't work you can easily check with Docks LS because since recently

00:13:56,390 --> 00:14:01,970
it uses the same build code as Crater, so if it builds on Docks LS it builds on Crater

00:14:01,970 --> 00:14:03,019
as well.

00:14:03,019 --> 00:14:08,740
And if it doesn't build, you can file an issue, probably on Docks LS is the best place, and

00:14:08,740 --> 00:14:14,649
if I want 18 of 4 packages available, we are just going to install the package on the build

00:14:14,649 --> 00:14:17,600
environment and then your package will work.

00:14:17,600 --> 00:14:20,510
>> Hello, thanks for the great talk.

00:14:20,510 --> 00:14:23,730
How long does it take to run Crater on all of the -

00:14:23,730 --> 00:14:29,959
PIETRO: Okay, so that actually varies a lot because we are making constant changes to

00:14:29,959 --> 00:14:34,420
the build environment, changes with machines and such.

00:14:34,420 --> 00:14:39,690
I think at the moment running cargo test on the entire ecosystem takes a week and the

00:14:39,690 --> 00:14:45,990
running cargo checker, which we actually do for sample requests, if there is a poll request

00:14:45,990 --> 00:14:54,509
that we know is risky, we usually run it beforehand and then do cargo checker which is faster,

00:14:54,509 --> 00:15:01,079
takes about three days, but that really varies mostly because we make a lot of changes to

00:15:01,079 --> 00:15:04,230
the machines.

00:15:04,230 --> 00:15:10,079
>> Any more?

00:15:10,079 --> 00:15:15,940
>> Thank you.

00:15:15,940 --> 00:15:21,620
Is it possible to supply the Crater run with more runners to speed up the process?

00:15:21,620 --> 00:15:24,380
PIETRO: I think we could.

00:15:24,380 --> 00:15:32,070
At the moment, we are just in a sweet spot because we have enough experiments that we

00:15:32,070 --> 00:15:38,740
fill out the service, but we don't have any idle time.

00:15:38,740 --> 00:15:40,009
And the queue is not that long.

00:15:40,009 --> 00:15:44,009
If we had more servers then the end result is that for a bunch of time the server is

00:15:44,009 --> 00:15:53,389
going to be idle so we are just wasting resources and we have actually a sponsorship firm co-operation,

00:15:53,389 --> 00:15:59,470
so if we reach a point where the queue is not sustainable anymore we are going to actually

00:15:59,470 --> 00:16:04,430
get funding, though Crater is really heavy on resources.

00:16:04,430 --> 00:16:12,819
At the moment I think we have 24 cores and 38GB of RAM, 4 telebytes of this space, so

00:16:12,819 --> 00:16:18,240
it's not something where you can throw out some old machine and get meaningful results

00:16:18,240 --> 00:16:19,300
out of it.

00:16:19,300 --> 00:16:23,720
>> All right, we are out of time for questions.

00:16:23,720 --> 00:16:25,380
We are going on to the next talk.

00:16:25,380 --> 00:16:25,850

YouTube URL: https://www.youtube.com/watch?v=As1gXp5kX1M


