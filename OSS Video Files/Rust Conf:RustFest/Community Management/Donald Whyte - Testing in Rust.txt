Title: Donald Whyte - Testing in Rust
Publication date: 2019-02-06
Playlist: Community Management
Description: 
	A Primer in Testing and Mocking

Rust is designed for building low-level systems processes that are reliable and safe. Nevertheless, it is still important for developers to ensure their code is doing the right thing. To achieve this, Rust has a rich set of built-in testing tools for writing unit tests.

In this talk we cover general unit testing techniques for Rust. We will also demonstrate how to mock out complex dependencies using the double crate. Examples will range from simple cases to complex cases that you'll often see when testing real world systems.

The talk is suitable for both novice and experienced Rust developers, as well as non-Rust developers who are interested in learning more about the language.

Donald Whyte is a software engineer at a leading quant hedgefund. He has thorough experience in distributed systems and machine learning. Previously, he worked at Bloomberg where he built core infrastructure technology that is still used across the firm globally.

A Rust and distributed systems enthusiast, Donald has given many talks about software infrastructure and distributed systems around the world.

Rust devroom @ FOSDEM 2018
https://fosdem.org/2018/schedule/event/rust_testing_mocking/

These talks have been recorded at FOSDEM (https://fosdem.org/)
This work is licensed under the Creative Commons Attribution 2.0 Belgium Licence.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/2.0/be/deed.en
Captions: 
	00:00:04,640 --> 00:00:10,720
yeah yeah like the bigger ones not like

00:00:33,760 --> 00:00:38,540
hello so here we're going to talk about

00:00:36,500 --> 00:00:40,670
testing in rust but specifically with a

00:00:38,540 --> 00:00:42,320
focus on mocking so just a little bit

00:00:40,670 --> 00:00:43,610
about me I'm a software engineer that

00:00:42,320 --> 00:00:45,410
works for a quant hedge fund called

00:00:43,610 --> 00:00:47,270
engineer's gate and my time is split

00:00:45,410 --> 00:00:49,940
between building real time low latency

00:00:47,270 --> 00:00:52,160
trading systems and also scalable data

00:00:49,940 --> 00:00:54,380
infrastructure so I'm primarily a Python

00:00:52,160 --> 00:00:55,940
C++ and rust developer although one day

00:00:54,380 --> 00:00:57,890
I'm hoping to kind of scratch out C++

00:00:55,940 --> 00:01:00,530
and just replace that with rust as I'm

00:00:57,890 --> 00:01:01,730
sure many people here are so the

00:01:00,530 --> 00:01:04,790
motivation for this talk is that rust

00:01:01,730 --> 00:01:06,049
focuses on safety on memory safety on

00:01:04,790 --> 00:01:08,180
safety when running concurrent

00:01:06,049 --> 00:01:09,950
applications and it does a great job at

00:01:08,180 --> 00:01:12,590
this without compromising or an ease of

00:01:09,950 --> 00:01:14,120
use of of api's and whatnot but even if

00:01:12,590 --> 00:01:15,290
our code is safe we still need to make

00:01:14,120 --> 00:01:18,020
sure that it's doing the logically

00:01:15,290 --> 00:01:19,880
correct thing so what we're gonna cover

00:01:18,020 --> 00:01:22,100
here is an extremely brief introduction

00:01:19,880 --> 00:01:24,200
to you running unit tests in rust then

00:01:22,100 --> 00:01:26,840
about running behavior verification

00:01:24,200 --> 00:01:28,040
tests in rust using crate called double

00:01:26,840 --> 00:01:29,630
and then we're gonna talk about some

00:01:28,040 --> 00:01:31,760
design considerations because actually

00:01:29,630 --> 00:01:33,860
generating mock implementations in rust

00:01:31,760 --> 00:01:35,570
is particularly challenging because it's

00:01:33,860 --> 00:01:37,130
a statically typed compiled language and

00:01:35,570 --> 00:01:40,939
the baura checker makes things even more

00:01:37,130 --> 00:01:43,790
difficult so unit tests for those of you

00:01:40,939 --> 00:01:47,060
haven't actually wrote any kind of risk

00:01:43,790 --> 00:01:49,150
before you create a library with russ

00:01:47,060 --> 00:01:50,930
package management all cargo cargo new

00:01:49,150 --> 00:01:53,750
when you create in the library for

00:01:50,930 --> 00:01:56,180
example some Lib it generates a single

00:01:53,750 --> 00:01:58,369
source file and this contains this bit

00:01:56,180 --> 00:02:00,950
of code here which is just an empty test

00:01:58,369 --> 00:02:03,380
case so if we had some production code

00:02:00,950 --> 00:02:05,770
say in this Lib de RS file here we have

00:02:03,380 --> 00:02:08,479
say add - it's just adds - to an integer

00:02:05,770 --> 00:02:10,759
we can write tests for this function by

00:02:08,479 --> 00:02:13,099
defining a private test module in the

00:02:10,759 --> 00:02:16,130
same source file and annotating it with

00:02:13,099 --> 00:02:17,540
CFG tests which tells cargo to only

00:02:16,130 --> 00:02:19,010
build this code

00:02:17,540 --> 00:02:22,159
in the test belt not in a production

00:02:19,010 --> 00:02:23,689
binary then you write various test

00:02:22,159 --> 00:02:26,180
functions inside and you annotate in

00:02:23,689 --> 00:02:28,280
each individual test with tests and then

00:02:26,180 --> 00:02:29,870
when you run cargo tests it builds all

00:02:28,280 --> 00:02:31,939
the production code builds the test code

00:02:29,870 --> 00:02:34,609
and actually runs all of those test

00:02:31,939 --> 00:02:37,220
functions rust has a native support for

00:02:34,609 --> 00:02:39,140
documentation tests so running tests in

00:02:37,220 --> 00:02:40,819
that are actually example code that are

00:02:39,140 --> 00:02:43,790
in your documentation to make sure your

00:02:40,819 --> 00:02:46,099
example code and your your library don't

00:02:43,790 --> 00:02:47,389
actually miss a line as well as

00:02:46,099 --> 00:02:50,329
integration tests but again the focus

00:02:47,389 --> 00:02:51,739
here is on unit tests and walking so the

00:02:50,329 --> 00:02:53,810
motivation behind mocking is that if you

00:02:51,739 --> 00:02:56,000
imagine any software system you know

00:02:53,810 --> 00:02:58,129
it's basically a dag of various

00:02:56,000 --> 00:02:59,900
components and if we wanted to test one

00:02:58,129 --> 00:03:02,060
of these components you know we have

00:02:59,900 --> 00:03:04,459
many many dependencies or may have many

00:03:02,060 --> 00:03:05,930
dependencies in this case at this top

00:03:04,459 --> 00:03:08,060
level component as highlighted in red if

00:03:05,930 --> 00:03:09,980
we were to test this we have to actually

00:03:08,060 --> 00:03:12,079
construct instantiate and configure all

00:03:09,980 --> 00:03:14,480
three of their dependencies and then

00:03:12,079 --> 00:03:15,680
their dependencies as well so suddenly

00:03:14,480 --> 00:03:16,549
if you just wanted to test like five

00:03:15,680 --> 00:03:17,810
lines of code

00:03:16,549 --> 00:03:20,209
suddenly you're writing dozens if not

00:03:17,810 --> 00:03:22,389
hundreds of lines of setup code so the

00:03:20,209 --> 00:03:24,889
solution to this is to simply mock out

00:03:22,389 --> 00:03:27,169
or create fake implementations of the

00:03:24,889 --> 00:03:29,989
direct dependencies to simplify the

00:03:27,169 --> 00:03:31,579
actual overall test fixture itself

00:03:29,989 --> 00:03:33,199
we typically eliminate anything that's

00:03:31,579 --> 00:03:35,449
non-deterministic that can't be reliably

00:03:33,199 --> 00:03:36,650
controlled in a unit test datasources

00:03:35,449 --> 00:03:38,269
network connections

00:03:36,650 --> 00:03:40,430
potentially libraries that have global

00:03:38,269 --> 00:03:42,319
state or something some horrible library

00:03:40,430 --> 00:03:44,239
the end of using and you can also

00:03:42,319 --> 00:03:45,949
eliminate large internal dependencies as

00:03:44,239 --> 00:03:47,599
well there's advantages and

00:03:45,949 --> 00:03:50,090
disadvantages to doing that but if

00:03:47,599 --> 00:03:51,409
you've got particularly large complex of

00:03:50,090 --> 00:03:52,879
dependencies that take a long time to

00:03:51,409 --> 00:03:54,650
set up you can eliminate those as well

00:03:52,879 --> 00:03:56,389
so the solution to this to use the test

00:03:54,650 --> 00:03:58,489
double and that kind of comes from the

00:03:56,389 --> 00:03:59,959
notion of a stunt double in films and

00:03:58,489 --> 00:04:01,189
I'm surprised he actually managed to get

00:03:59,959 --> 00:04:04,549
away with being a son double of Brad

00:04:01,189 --> 00:04:06,229
Pitt so a testable is basically a

00:04:04,549 --> 00:04:07,699
replacement for any actual real

00:04:06,229 --> 00:04:10,849
production code that behaves the same

00:04:07,699 --> 00:04:12,349
way but is easier to set up and there

00:04:10,849 --> 00:04:14,379
are many types but most people just

00:04:12,349 --> 00:04:16,459
refer to all of these doubles as mocks

00:04:14,379 --> 00:04:18,739
in this case what we're actually

00:04:16,459 --> 00:04:22,280
covering is spies which is a specific

00:04:18,739 --> 00:04:24,169
type that you can configure to behave in

00:04:22,280 --> 00:04:25,880
different ways but it also records all

00:04:24,169 --> 00:04:27,320
the interaction of the code and the test

00:04:25,880 --> 00:04:29,870
has with it all the times it was called

00:04:27,320 --> 00:04:31,340
and what it was called with and what

00:04:29,870 --> 00:04:33,650
this is called as behavior

00:04:31,340 --> 00:04:35,690
which is a style of unit testing is a

00:04:33,650 --> 00:04:37,639
style of writing tests by testing the

00:04:35,690 --> 00:04:38,930
code by asserting on its interaction

00:04:37,639 --> 00:04:41,960
with his collaborators or its

00:04:38,930 --> 00:04:44,690
dependencies so immersed we can generate

00:04:41,960 --> 00:04:46,370
testable x' in a variety of ways two

00:04:44,690 --> 00:04:48,229
ways of doing this with the double crate

00:04:46,370 --> 00:04:50,389
for example is by generating mock

00:04:48,229 --> 00:04:52,729
implementations of traits and also

00:04:50,389 --> 00:04:54,860
generating mock functions as well and

00:04:52,729 --> 00:04:56,240
you can configure flexibly configure the

00:04:54,860 --> 00:04:58,010
the various behavior what it returns

00:04:56,240 --> 00:05:00,350
does it when a function does an error as

00:04:58,010 --> 00:05:02,240
well as simple but also quite nuanced

00:05:00,350 --> 00:05:05,660
assertions about how it was called and

00:05:02,240 --> 00:05:08,060
how it was used so classic example in

00:05:05,660 --> 00:05:09,889
the kind of field I work in is let's say

00:05:08,060 --> 00:05:13,010
we were trying to predict the profit of

00:05:09,889 --> 00:05:14,830
a stock portfolio over time now imagine

00:05:13,010 --> 00:05:17,750
we have some traits called profit model

00:05:14,830 --> 00:05:19,430
this has one method profit act which

00:05:17,750 --> 00:05:21,229
takes some time stamp and then we'll

00:05:19,430 --> 00:05:23,720
return the profit at that given time

00:05:21,229 --> 00:05:25,820
stamp we have a function called predicts

00:05:23,720 --> 00:05:28,669
profit over time whose goal is to

00:05:25,820 --> 00:05:31,610
generate a time series of profits so we

00:05:28,669 --> 00:05:34,430
give it a start and end time series the

00:05:31,610 --> 00:05:36,200
model itself which can be any model and

00:05:34,430 --> 00:05:37,400
then we simply iterate through that

00:05:36,200 --> 00:05:39,110
through all of the individual time

00:05:37,400 --> 00:05:40,580
stamps generating the profit of that

00:05:39,110 --> 00:05:42,770
time stamp and then returning a vector

00:05:40,580 --> 00:05:44,090
of the profits and we want to test this

00:05:42,770 --> 00:05:47,000
function simple function but

00:05:44,090 --> 00:05:48,590
illustration purposes let's test it so

00:05:47,000 --> 00:05:50,090
recall that our test should be

00:05:48,590 --> 00:05:52,039
repeatable and not rely in an external

00:05:50,090 --> 00:05:53,150
environment however this is very

00:05:52,039 --> 00:05:55,510
challenging in this case because the

00:05:53,150 --> 00:05:58,130
profit model is a very complex beast

00:05:55,510 --> 00:05:59,780
predicting profit is really hard so real

00:05:58,130 --> 00:06:01,910
implementations actually use a lot of

00:05:59,780 --> 00:06:04,039
different data sources a lot of very

00:06:01,910 --> 00:06:06,169
complex mathematical models so if you

00:06:04,039 --> 00:06:07,550
just want to test this simple basic code

00:06:06,169 --> 00:06:09,710
here you probably don't want to have

00:06:07,550 --> 00:06:11,660
this ginormous setup of what is

00:06:09,710 --> 00:06:14,539
extremely complex for piyah tree code

00:06:11,660 --> 00:06:17,270
so we mock it and in R us we do this

00:06:14,539 --> 00:06:20,360
with two macros the first is mocked rate

00:06:17,270 --> 00:06:22,190
so much rate generates a struct that has

00:06:20,360 --> 00:06:24,470
a bunch of boilerplate and bookkeeping

00:06:22,190 --> 00:06:25,849
inside it to keep track of what how it's

00:06:24,470 --> 00:06:28,130
been called and how it hasn't so in this

00:06:25,849 --> 00:06:29,419
case we have this trait we call mock

00:06:28,130 --> 00:06:32,000
trait this is the name of our mock

00:06:29,419 --> 00:06:33,530
struct and then we list the methods in

00:06:32,000 --> 00:06:34,460
the trait that we're mocking so it

00:06:33,530 --> 00:06:37,580
generates the right

00:06:34,460 --> 00:06:39,560
boilerplate code internally then we have

00:06:37,580 --> 00:06:41,659
to explicitly tell the risk compiler to

00:06:39,560 --> 00:06:43,789
that the mock model implements the

00:06:41,659 --> 00:06:45,050
profit model trait so we have import

00:06:43,789 --> 00:06:47,120
profit model for mock

00:06:45,050 --> 00:06:49,250
and then we have the mock method macro

00:06:47,120 --> 00:06:51,259
inside it which again will generate the

00:06:49,250 --> 00:06:53,840
actual real profit at function which

00:06:51,259 --> 00:06:55,039
caused our internal struct and so that's

00:06:53,840 --> 00:06:56,870
the kind of light that's all the code

00:06:55,039 --> 00:06:58,580
you need to generate in what that has

00:06:56,870 --> 00:07:01,639
all the features that I'm about to

00:06:58,580 --> 00:07:03,319
explain so actually using this if you

00:07:01,639 --> 00:07:05,810
imagine you wanted to just say one

00:07:03,319 --> 00:07:07,699
through three timestamps and assert that

00:07:05,810 --> 00:07:09,440
the profit over time the time series and

00:07:07,699 --> 00:07:11,870
generated was correct and at the profit

00:07:09,440 --> 00:07:13,550
model was used in the correct manner we

00:07:11,870 --> 00:07:14,900
instantiate the mock by doing mock model

00:07:13,550 --> 00:07:17,449
default which just creates a default

00:07:14,900 --> 00:07:19,819
initialized mock model we say profit

00:07:17,449 --> 00:07:21,919
that return value ten and then this

00:07:19,819 --> 00:07:23,720
thing will the profit foot method will

00:07:21,919 --> 00:07:25,430
just keep returning Tet so we see that

00:07:23,720 --> 00:07:27,590
the actual time series it returns is ten

00:07:25,430 --> 00:07:29,389
ten ten and we can make assertions at

00:07:27,590 --> 00:07:31,819
the end of the test how the mock was

00:07:29,389 --> 00:07:35,000
caught so in this case profit at non

00:07:31,819 --> 00:07:36,500
cause is three and there's various ways

00:07:35,000 --> 00:07:38,330
you can set mock behavior if you don't

00:07:36,500 --> 00:07:40,310
specify anything it just uses a default

00:07:38,330 --> 00:07:41,900
value of the return type we can set a

00:07:40,310 --> 00:07:43,879
single return value for all calls like

00:07:41,900 --> 00:07:47,240
we did before we can set sequence of

00:07:43,879 --> 00:07:50,360
return values so 1 5 10 we can set

00:07:47,240 --> 00:07:53,180
return values for specific arguments so

00:07:50,360 --> 00:07:55,280
we can say for timestamp 1 return this

00:07:53,180 --> 00:07:58,069
otherwise do some other default behavior

00:07:55,280 --> 00:07:59,750
in this case return 0 and we can even

00:07:58,069 --> 00:08:01,310
use arbitrary functions as well or

00:07:59,750 --> 00:08:03,139
closures and the benefit of doing it

00:08:01,310 --> 00:08:05,330
like this as opposed to just writing a

00:08:03,139 --> 00:08:06,770
mock implementation that has that code

00:08:05,330 --> 00:08:08,630
in like manually confirm writing a

00:08:06,770 --> 00:08:10,789
markup limitation is that in this way

00:08:08,630 --> 00:08:12,830
you get all the boilerplate and code

00:08:10,789 --> 00:08:16,310
generated so you can do these types of

00:08:12,830 --> 00:08:18,110
assertions that about to discuss so once

00:08:16,310 --> 00:08:19,550
you've configured the mock and how it's

00:08:18,110 --> 00:08:21,139
supposed to behave you want to assert

00:08:19,550 --> 00:08:22,940
that it was used as expected it was

00:08:21,139 --> 00:08:25,430
called the right number of times and had

00:08:22,940 --> 00:08:27,319
the right arguments now there's fairly

00:08:25,430 --> 00:08:29,210
loose assertions so you can say the mock

00:08:27,319 --> 00:08:31,159
was called at least once it was called

00:08:29,210 --> 00:08:33,890
with one and it all it was called with

00:08:31,159 --> 00:08:35,570
time someone and also timestamp 0 well

00:08:33,890 --> 00:08:37,130
often you actually want to tighten your

00:08:35,570 --> 00:08:38,959
call assertion so you might want to say

00:08:37,130 --> 00:08:41,599
not only do you care that it was called

00:08:38,959 --> 00:08:43,099
with 1 and 0 but you also care that it

00:08:41,599 --> 00:08:45,829
never had any more calls than that

00:08:43,099 --> 00:08:47,660
so has caused exactly 1 0 2 which is

00:08:45,829 --> 00:08:50,899
well past because in this case we're

00:08:47,660 --> 00:08:53,329
passing timestamp 0 to 2 inclusive and

00:08:50,899 --> 00:08:55,190
then you can even say has caused exactly

00:08:53,329 --> 00:08:56,600
in order and it's kind of up to you how

00:08:55,190 --> 00:08:58,490
tight you want to make your assertions

00:08:56,600 --> 00:09:00,950
or loose and that's something

00:08:58,490 --> 00:09:02,630
to discuss in a second we can also mock

00:09:00,950 --> 00:09:04,880
free functions so for example if you're

00:09:02,630 --> 00:09:06,800
passing in some function a box function

00:09:04,880 --> 00:09:08,390
for example for runtime polymorphism you

00:09:06,800 --> 00:09:09,290
can pass that in as well you can

00:09:08,390 --> 00:09:11,720
generate something for that as well

00:09:09,290 --> 00:09:13,280
sorry so here we have mock funk we

00:09:11,720 --> 00:09:15,320
specify the actual mock object that

00:09:13,280 --> 00:09:16,970
stores all the bookkeeping the actual

00:09:15,320 --> 00:09:19,100
function itself which is just a closure

00:09:16,970 --> 00:09:20,630
and then the return types and argument

00:09:19,100 --> 00:09:21,980
types and whatnot and then you can

00:09:20,630 --> 00:09:24,980
specify just like you would with the

00:09:21,980 --> 00:09:27,800
traipse behavior it will return ten and

00:09:24,980 --> 00:09:29,570
also specify how it was used so say we

00:09:27,800 --> 00:09:31,790
had some function that we expected to

00:09:29,570 --> 00:09:35,060
call it the the function we pass in

00:09:31,790 --> 00:09:39,740
twice then we say that it was called two

00:09:35,060 --> 00:09:40,940
times so that's all well and good but

00:09:39,740 --> 00:09:42,560
there's some serious of that

00:09:40,940 --> 00:09:44,990
disadvantages - mocking if you're not

00:09:42,560 --> 00:09:46,790
careful so let's talk about another use

00:09:44,990 --> 00:09:51,380
case so imagine we were trying to test

00:09:46,790 --> 00:09:54,080
how a robot makes decisions so suppose

00:09:51,380 --> 00:09:57,260
that we have some robot logic and this

00:09:54,080 --> 00:09:59,240
thing takes some world States so has

00:09:57,260 --> 00:10:01,520
some like perception of what the world

00:09:59,240 --> 00:10:03,740
looks like and this is a value type just

00:10:01,520 --> 00:10:06,230
a basic struct and then we have a robot

00:10:03,740 --> 00:10:08,450
which takes some internal state and then

00:10:06,230 --> 00:10:11,480
decides what to do and once it's decided

00:10:08,450 --> 00:10:13,210
it acts on those decisions by correlate

00:10:11,480 --> 00:10:16,310
by actually calling this actuator

00:10:13,210 --> 00:10:19,070
component here so saying I want to move

00:10:16,310 --> 00:10:21,410
forward or I want to speak in this case

00:10:19,070 --> 00:10:23,000
suppose that we wanted to test this

00:10:21,410 --> 00:10:24,470
robot logic this is very complex logic

00:10:23,000 --> 00:10:29,690
and it's a kind of thing that we want to

00:10:24,470 --> 00:10:32,120
poke and prod so we want to mock the

00:10:29,690 --> 00:10:34,010
actuator in this case because if this

00:10:32,120 --> 00:10:35,870
world state is just a simple value type

00:10:34,010 --> 00:10:37,700
we can just construct that as a struct

00:10:35,870 --> 00:10:39,050
and just in and have various different

00:10:37,700 --> 00:10:43,130
unit tests with various different world

00:10:39,050 --> 00:10:45,200
states the robot is the complex hard

00:10:43,130 --> 00:10:47,270
part and the actuator if you imagine

00:10:45,200 --> 00:10:49,550
that this robot was say an entity in a

00:10:47,270 --> 00:10:51,200
video game or like a renderable entity

00:10:49,550 --> 00:10:52,660
or it was an actual physical set of

00:10:51,200 --> 00:10:54,950
hardware that you were sending orders to

00:10:52,660 --> 00:10:57,110
obviously that's not very tractable to

00:10:54,950 --> 00:11:01,730
mock sorry to test and in an automated

00:10:57,110 --> 00:11:03,740
fashion so we mock this out and again if

00:11:01,730 --> 00:11:06,200
this actuator will say a trait so for

00:11:03,740 --> 00:11:08,810
example it could have many actions one

00:11:06,200 --> 00:11:10,010
of them being moved forward this policy

00:11:08,810 --> 00:11:11,510
would realistically have lots more

00:11:10,010 --> 00:11:12,560
nuanced actions but for the purposes of

00:11:11,510 --> 00:11:14,270
illustration

00:11:12,560 --> 00:11:16,940
move forward and it moves by forward by

00:11:14,270 --> 00:11:19,580
some amount we mock this as we did

00:11:16,940 --> 00:11:21,590
before we use mock traits and then we do

00:11:19,580 --> 00:11:24,140
in pull actuator for mock actuator the

00:11:21,590 --> 00:11:26,090
robot itself in this case takes a

00:11:24,140 --> 00:11:29,360
reference to the actuator and it has

00:11:26,090 --> 00:11:31,040
this take action function which receives

00:11:29,360 --> 00:11:32,270
some world states again we don't care

00:11:31,040 --> 00:11:34,040
about the exact contents of it at this

00:11:32,270 --> 00:11:35,870
point we just receive some world states

00:11:34,040 --> 00:11:39,380
and then there's some business logic on

00:11:35,870 --> 00:11:40,820
on how the robot decides what actions it

00:11:39,380 --> 00:11:44,210
should take and this is a thing we want

00:11:40,820 --> 00:11:46,339
to test after we've done that we can

00:11:44,210 --> 00:11:49,310
test the robot by again instantiating a

00:11:46,339 --> 00:11:51,920
mock actuator we run the code under test

00:11:49,310 --> 00:11:54,350
which is take action and then we assert

00:11:51,920 --> 00:11:56,560
on what actions the robot actually took

00:11:54,350 --> 00:11:58,279
one thing to note here is that

00:11:56,560 --> 00:11:59,960
realistically you would have many many

00:11:58,279 --> 00:12:02,029
many different test functions or with

00:11:59,960 --> 00:12:04,550
different world states or to test and

00:12:02,029 --> 00:12:08,300
poke and prod and and test how this

00:12:04,550 --> 00:12:11,000
robot works now the issue with this

00:12:08,300 --> 00:12:13,029
specific example is robots in particular

00:12:11,000 --> 00:12:16,850
and decision-making is quite complicated

00:12:13,029 --> 00:12:18,440
and it's quite nuanced do we really care

00:12:16,850 --> 00:12:20,810
that the robot in this case we're

00:12:18,440 --> 00:12:23,030
setting do we that the robot moved

00:12:20,810 --> 00:12:24,500
exactly 100 times is that something we

00:12:23,030 --> 00:12:26,150
actually care about do we care that it's

00:12:24,500 --> 00:12:27,890
move forward a little bit or within a

00:12:26,150 --> 00:12:30,500
range we might not actually care that

00:12:27,890 --> 00:12:32,510
it's exactly 100 units so if you imagine

00:12:30,500 --> 00:12:34,370
the space of all possible behavior that

00:12:32,510 --> 00:12:37,310
the robot can take or the code of the

00:12:34,370 --> 00:12:40,640
test in a more generic fashion and this

00:12:37,310 --> 00:12:42,980
is the expected behavior what we've just

00:12:40,640 --> 00:12:45,500
done is we've tightened the assertion

00:12:42,980 --> 00:12:47,960
way too much so now we've artificially

00:12:45,500 --> 00:12:49,160
constrained the test so if someone

00:12:47,960 --> 00:12:50,660
decides to slightly change the

00:12:49,160 --> 00:12:53,510
implementation of the robot and how it

00:12:50,660 --> 00:12:57,050
makes decisions so instead of moving 100

00:12:53,510 --> 00:13:00,470
it moves as say 120 that might still be

00:12:57,050 --> 00:13:02,780
within a realm of expected but it will

00:13:00,470 --> 00:13:05,209
break the test because it's moved out of

00:13:02,780 --> 00:13:06,800
that tight assertive space so what we

00:13:05,209 --> 00:13:08,990
really want is I expected I'll set it to

00:13:06,800 --> 00:13:10,070
be the same so basically behavior

00:13:08,990 --> 00:13:11,990
verification can over fit the

00:13:10,070 --> 00:13:13,700
implementation and the lack of tooling

00:13:11,990 --> 00:13:15,920
and good ways of of matching and

00:13:13,700 --> 00:13:17,510
argument values makes us more likely so

00:13:15,920 --> 00:13:19,850
let's talk about pattern matching

00:13:17,510 --> 00:13:22,130
so rather than match arguments to values

00:13:19,850 --> 00:13:26,150
you match them to actual more generic

00:13:22,130 --> 00:13:27,950
patterns so we have called with pattern

00:13:26,150 --> 00:13:30,140
so you can say actuator don't move

00:13:27,950 --> 00:13:33,110
forward called with pattern and you pass

00:13:30,140 --> 00:13:34,730
in some matching function so here we had

00:13:33,110 --> 00:13:36,200
is greater than or equal to 100

00:13:34,730 --> 00:13:38,360
this takes the argument being matched

00:13:36,200 --> 00:13:40,279
and then it runs some check say are

00:13:38,360 --> 00:13:41,810
greater than equals 100 returning true

00:13:40,279 --> 00:13:42,260
if the value is matched and false

00:13:41,810 --> 00:13:44,839
otherwise

00:13:42,260 --> 00:13:46,910
now obviously rotten handwriting a bunch

00:13:44,839 --> 00:13:49,940
of closures all the time is probably not

00:13:46,910 --> 00:13:52,220
ideal it's very verbose and it's quite

00:13:49,940 --> 00:13:54,620
painful so you get around this with

00:13:52,220 --> 00:13:56,420
parameterised matcher butchers so for

00:13:54,620 --> 00:13:58,670
example you would have a greater than or

00:13:56,420 --> 00:14:01,520
equal to function this is a generic

00:13:58,670 --> 00:14:03,860
function that can take any type that

00:14:01,520 --> 00:14:05,720
implements partial eq and partial or in

00:14:03,860 --> 00:14:08,240
other words any type that you can say

00:14:05,720 --> 00:14:10,220
greater than you pull on it takes a

00:14:08,240 --> 00:14:12,440
single parameter the first argument is

00:14:10,220 --> 00:14:14,420
the the value being matched and it takes

00:14:12,440 --> 00:14:16,550
a single parameter base though which is

00:14:14,420 --> 00:14:18,860
actually what it does here like what the

00:14:16,550 --> 00:14:21,110
base value should be and so now instead

00:14:18,860 --> 00:14:22,970
of actually generating a so manually

00:14:21,110 --> 00:14:26,120
writing all of our matches we can just

00:14:22,970 --> 00:14:28,940
use a macro called P which is defined in

00:14:26,120 --> 00:14:30,589
double - to basically generate these

00:14:28,940 --> 00:14:32,029
matching closures for us so this

00:14:30,589 --> 00:14:34,010
generates matching closures on the fly

00:14:32,029 --> 00:14:37,850
by you saying take this parameter rise

00:14:34,010 --> 00:14:40,279
match of GE and then 100 and so what

00:14:37,850 --> 00:14:42,230
this code looks like is pretty much the

00:14:40,279 --> 00:14:44,390
same so we have P GE 100 and then

00:14:42,230 --> 00:14:46,070
matcher and there's loads of built-in

00:14:44,390 --> 00:14:47,420
matches there's wildcard matches if you

00:14:46,070 --> 00:14:50,540
don't care about specific arguments

00:14:47,420 --> 00:14:52,850
comparisons floating points string

00:14:50,540 --> 00:14:54,620
matches container matches you also

00:14:52,850 --> 00:14:56,450
compose matches together so you can say

00:14:54,620 --> 00:14:58,250
maybe you don't care that the robot

00:14:56,450 --> 00:14:59,630
moved just to point more than 100 but

00:14:58,250 --> 00:15:01,459
then it moved within some range so you

00:14:59,630 --> 00:15:05,000
can say it matches all of greater than

00:15:01,459 --> 00:15:06,500
equal to 100 lower than equal to 200 you

00:15:05,000 --> 00:15:08,480
can also and this is particularly useful

00:15:06,500 --> 00:15:10,430
feature is do is do matching across

00:15:08,480 --> 00:15:14,779
individual elements in the collection so

00:15:10,430 --> 00:15:17,089
any iterable an iterable object it you

00:15:14,779 --> 00:15:19,100
can use this each match so here we have

00:15:17,089 --> 00:15:21,040
some mock that record two numbers or

00:15:19,100 --> 00:15:24,050
something it takes a vector of integers

00:15:21,040 --> 00:15:27,170
and you want to assert that this mock

00:15:24,050 --> 00:15:29,990
was called with a vector where each

00:15:27,170 --> 00:15:33,470
element matched to this pattern which is

00:15:29,990 --> 00:15:35,390
not equal zero and yeah so you can also

00:15:33,470 --> 00:15:37,670
define custom matches so design

00:15:35,390 --> 00:15:40,190
considerations so there are two design

00:15:37,670 --> 00:15:45,110
goals in double and this was

00:15:40,190 --> 00:15:46,520
stable so rust sable was a requirement

00:15:45,110 --> 00:15:48,290
particularly for me because I was

00:15:46,520 --> 00:15:50,750
working on software that required the

00:15:48,290 --> 00:15:53,870
stable and not nightly and it's

00:15:50,750 --> 00:15:55,640
surprising how many mocking mocking

00:15:53,870 --> 00:15:58,280
frameworks out there always go with

00:15:55,640 --> 00:16:00,470
nightly and it's because mocking and

00:15:58,280 --> 00:16:01,700
cogeneration is often a lot more

00:16:00,470 --> 00:16:03,470
convenient when you're using various

00:16:01,700 --> 00:16:05,690
nightly plugins and compiler plugins and

00:16:03,470 --> 00:16:07,510
whatnot for me I didn't have that option

00:16:05,690 --> 00:16:10,160
so I needed to go with something that

00:16:07,510 --> 00:16:11,960
could only use stable features and the

00:16:10,160 --> 00:16:15,350
second one was no changes to production

00:16:11,960 --> 00:16:19,040
code now it's okay to refactor your code

00:16:15,350 --> 00:16:20,780
to make it more testable but actually

00:16:19,040 --> 00:16:22,670
adding extra awkward boilerplate to the

00:16:20,780 --> 00:16:25,400
code just to make it testable always

00:16:22,670 --> 00:16:27,350
this has been a bit icky to me and also

00:16:25,400 --> 00:16:29,600
at the same time if you do that that

00:16:27,350 --> 00:16:32,030
means you can't just mock any arbitrary

00:16:29,600 --> 00:16:34,190
traits like you would have to rely on

00:16:32,030 --> 00:16:36,410
the library developer adding a certain

00:16:34,190 --> 00:16:38,810
annotation to a trait or a structural or

00:16:36,410 --> 00:16:41,600
function for you to be able to mock it

00:16:38,810 --> 00:16:43,490
so with this you can actually mock any

00:16:41,600 --> 00:16:45,770
arbitrary trait from any library and it

00:16:43,490 --> 00:16:48,500
doesn't matter and these are challenging

00:16:45,770 --> 00:16:51,410
goals again because that should the the

00:16:48,500 --> 00:16:53,540
original talk that I had was the second

00:16:51,410 --> 00:16:56,300
part of it was 20 minutes purely on why

00:16:53,540 --> 00:16:57,440
this was so challenging but sadly we

00:16:56,300 --> 00:16:59,750
don't have time but I would love to

00:16:57,440 --> 00:17:00,980
discuss it but basically it's really

00:16:59,750 --> 00:17:03,680
really difficult and it's partly in

00:17:00,980 --> 00:17:05,540
because Russell's as a compiler is so

00:17:03,680 --> 00:17:07,550
strict that it actually makes all this

00:17:05,540 --> 00:17:10,220
automatic code generation and generic

00:17:07,550 --> 00:17:11,300
mock functionality quite difficult one

00:17:10,220 --> 00:17:13,160
thing this was Pattinson this was

00:17:11,300 --> 00:17:15,860
inspired by was Google mock so if any of

00:17:13,160 --> 00:17:17,660
you view c++ google mock is an amazing

00:17:15,860 --> 00:17:19,660
mocking framework but it cheats in some

00:17:17,660 --> 00:17:22,250
ways that the borrow check of caches

00:17:19,660 --> 00:17:25,699
which is quite frustrating but also a

00:17:22,250 --> 00:17:27,230
good thing as well so as eventually most

00:17:25,699 --> 00:17:28,730
mocking libraries require nightly and

00:17:27,230 --> 00:17:30,110
pretty much all I found required

00:17:28,730 --> 00:17:31,850
production code change that you at least

00:17:30,110 --> 00:17:34,190
have to annotate the trace that you want

00:17:31,850 --> 00:17:35,990
to mock but there is a cost to actually

00:17:34,190 --> 00:17:39,920
achieving those two goals and that is

00:17:35,990 --> 00:17:42,590
the slightly more verbose generation so

00:17:39,920 --> 00:17:45,770
as you saw earlier there was two macros

00:17:42,590 --> 00:17:47,060
there was more trait and mock method and

00:17:45,770 --> 00:17:50,000
so basically add to repeat yourself

00:17:47,060 --> 00:17:51,920
twice and there's limitations in the

00:17:50,000 --> 00:17:53,360
current rust stable version that

00:17:51,920 --> 00:17:55,340
basically make it impossible

00:17:53,360 --> 00:18:00,350
if you don't want any production code

00:17:55,340 --> 00:18:01,970
changes to to to merge those two macros

00:18:00,350 --> 00:18:04,850
together it's a specific feature I'm

00:18:01,970 --> 00:18:06,440
waiting for which is generic

00:18:04,850 --> 00:18:09,679
specialization which will make this

00:18:06,440 --> 00:18:11,330
problem go away and once that does they

00:18:09,679 --> 00:18:13,610
can be merged but until that point it is

00:18:11,330 --> 00:18:15,890
slightly more of a base and that's

00:18:13,610 --> 00:18:18,410
pretty much the talk to summarize

00:18:15,890 --> 00:18:19,970
mocking is often used to isolate unit

00:18:18,410 --> 00:18:22,370
tests from external resources or large

00:18:19,970 --> 00:18:23,690
dependencies and you can achieve one way

00:18:22,370 --> 00:18:26,290
of achieving this interest is by

00:18:23,690 --> 00:18:29,990
replacing traits and functions

00:18:26,290 --> 00:18:31,190
however using mocking can often overfit

00:18:29,990 --> 00:18:33,679
the implementation so you need to be

00:18:31,190 --> 00:18:36,380
very very careful and you need to have

00:18:33,679 --> 00:18:38,510
good tools that enable you to make these

00:18:36,380 --> 00:18:40,400
more nuanced assertions not just you

00:18:38,510 --> 00:18:42,200
record with exactly this you need to

00:18:40,400 --> 00:18:43,580
have these more looser assertions so

00:18:42,200 --> 00:18:45,290
that your developers don't hate their

00:18:43,580 --> 00:18:46,820
lives a year in the project and have to

00:18:45,290 --> 00:18:47,720
constantly change test code all the time

00:18:46,820 --> 00:18:50,630
when they slightly change it

00:18:47,720 --> 00:18:51,980
implementation double is a crate that

00:18:50,630 --> 00:18:53,450
generates these these traits and

00:18:51,980 --> 00:18:55,160
functions there's a wide array of

00:18:53,450 --> 00:18:56,540
behaviors and setups I only actually

00:18:55,160 --> 00:18:59,030
covered a very small subset of the

00:18:56,540 --> 00:19:00,620
overall set of features and it has first

00:18:59,030 --> 00:19:02,360
class mashup at mashing support that was

00:19:00,620 --> 00:19:05,150
the biggest reason I actually made this

00:19:02,360 --> 00:19:08,210
library was because pattern matching and

00:19:05,150 --> 00:19:09,559
roster staple pretty much it requires no

00:19:08,210 --> 00:19:11,870
changes to production code but that does

00:19:09,559 --> 00:19:13,040
come at a cost these are some

00:19:11,870 --> 00:19:15,309
alternative mocking libraries that I

00:19:13,040 --> 00:19:17,030
recommend checking out after this talk

00:19:15,309 --> 00:19:19,100
depending on your use case you might

00:19:17,030 --> 00:19:20,690
actually find these are a lot easier to

00:19:19,100 --> 00:19:23,030
use for you some mockers in particular

00:19:20,690 --> 00:19:25,010
is quite a good one here's winter links

00:19:23,030 --> 00:19:26,809
and that's it get in touch if you're

00:19:25,010 --> 00:19:30,070
interested or check out the double repo

00:19:26,809 --> 00:19:30,070
on github if you want to

00:19:36,340 --> 00:19:44,560
questions everyone's ready for home

00:19:51,950 --> 00:19:57,969
[Applause]

00:20:02,440 --> 00:20:05,740
noise noise

00:20:06,790 --> 00:20:11,380
thank you yeah it was a bit concise but

00:20:17,910 --> 00:20:20,979
[Music]

00:20:23,530 --> 00:20:28,400
yeah yeah it was like I think one of the

00:20:26,660 --> 00:20:29,660
reasons why mocking and testing so big

00:20:28,400 --> 00:20:31,190
in turn and inside languages because you

00:20:29,660 --> 00:20:32,420
can't rely on the compiler or when

00:20:31,190 --> 00:20:33,470
you've got something like rust yeah

00:20:32,420 --> 00:20:35,210
you're doing learn never systems often

00:20:33,470 --> 00:20:37,310
you don't actually need to I still I

00:20:35,210 --> 00:20:39,410
still found even doing like quite low

00:20:37,310 --> 00:20:41,990
level at least to C++ anyway I've still

00:20:39,410 --> 00:20:43,880
found that mocking has its uses but

00:20:41,990 --> 00:20:47,020
definitely you can / you can overuse it

00:20:43,880 --> 00:20:52,580
right so you say it's very suppose your

00:20:47,020 --> 00:20:55,520
hypotheses you could have a yes you

00:20:52,580 --> 00:20:57,110
could you could do that yes yeah the

00:20:55,520 --> 00:20:59,300
reason I decided not to go with that

00:20:57,110 --> 00:21:00,680
approach was like I personally preferred

00:20:59,300 --> 00:21:02,420
the idea of having like an isolated

00:21:00,680 --> 00:21:04,250
library yeah I having to require the

00:21:02,420 --> 00:21:06,290
users to have like an extra step in

00:21:04,250 --> 00:21:07,340
their tool chain was kind of I don't

00:21:06,290 --> 00:21:09,050
know for me you just kind of have it all

00:21:07,340 --> 00:21:10,850
quick you know I don't you but I

00:21:09,050 --> 00:21:14,750
understand I think it'll be call a lot

00:21:10,850 --> 00:21:17,090
more a lot a lot better when when rust

00:21:14,750 --> 00:21:18,830
macros 2.0 class yeah so there's that

00:21:17,090 --> 00:21:21,410
and there's also the actual reason why

00:21:18,830 --> 00:21:23,660
they can't be merged is because in if

00:21:21,410 --> 00:21:26,750
you've got macros you're you're matching

00:21:23,660 --> 00:21:28,580
to the T Y token but when you're storing

00:21:26,750 --> 00:21:30,650
what you've been called with you want to

00:21:28,580 --> 00:21:34,400
store the raw value type so if you have

00:21:30,650 --> 00:21:36,340
say a reference to an integer so you got

00:21:34,400 --> 00:21:39,970
like a reference to an integer yeah then

00:21:36,340 --> 00:21:43,200
you can't decayed

00:21:39,970 --> 00:21:43,200
I want more secrets yes

00:22:47,539 --> 00:22:49,600

YouTube URL: https://www.youtube.com/watch?v=sZ8mF3CBAZE


