Title: RustConf 2019 - Closing Keynote by Lin Clark
Publication date: 2019-09-16
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Closing Keynote by Lin Clark
Captions: 
	00:00:08,770 --> 00:00:15,680
[Music]

00:00:16,810 --> 00:00:23,150
I'm Lynn Clark and I make code cartoons

00:00:19,910 --> 00:00:26,090
and I also work at Mozilla and advance

00:00:23,150 --> 00:00:28,220
development and today I'm going to be

00:00:26,090 --> 00:00:30,439
talking about a possible future for rust

00:00:28,220 --> 00:00:35,090
and the impact it could have on the

00:00:30,439 --> 00:00:36,440
programming world I have to say it was

00:00:35,090 --> 00:00:38,449
quite an honor when I was asked to

00:00:36,440 --> 00:00:39,500
keynote this conference you know of

00:00:38,449 --> 00:00:41,570
course it's always an honor when you're

00:00:39,500 --> 00:00:42,980
asked a keynote a conference but that's

00:00:41,570 --> 00:00:44,809
not what I'm talking about here it was

00:00:42,980 --> 00:00:48,440
an honor to be asked specifically to

00:00:44,809 --> 00:00:52,239
keynote ruskov and that's because of

00:00:48,440 --> 00:00:54,860
what rust has done and what rust means

00:00:52,239 --> 00:00:57,199
what I'm talking about is that rust is

00:00:54,860 --> 00:00:59,600
really a leader in a whole new

00:00:57,199 --> 00:01:02,479
generation of programming languages and

00:00:59,600 --> 00:01:04,760
programming language communities it's

00:01:02,479 --> 00:01:06,470
truly transformative is transforming the

00:01:04,760 --> 00:01:09,170
conversations we can have about what's

00:01:06,470 --> 00:01:10,610
possible now I'm sure that many of you

00:01:09,170 --> 00:01:13,520
are aware of some of the things I'm

00:01:10,610 --> 00:01:15,830
referencing here so the most well-known

00:01:13,520 --> 00:01:17,750
of these of course is how rust is

00:01:15,830 --> 00:01:20,930
ushering in a whole new way of thinking

00:01:17,750 --> 00:01:22,700
about systems programming and the impact

00:01:20,930 --> 00:01:25,580
of this is visible in a lot of different

00:01:22,700 --> 00:01:28,220
places one recent example is the series

00:01:25,580 --> 00:01:30,620
of blog posts that Microsoft put out you

00:01:28,220 --> 00:01:32,480
know in these posts they say if only the

00:01:30,620 --> 00:01:34,340
developers could have all of the memory

00:01:32,480 --> 00:01:38,030
security guarantees of language

00:01:34,340 --> 00:01:40,910
languages like dotnet c-sharp combined

00:01:38,030 --> 00:01:43,810
with the efficiencies of C++ maybe we

00:01:40,910 --> 00:01:46,910
can with rust and they go on to say

00:01:43,810 --> 00:01:50,360
rather than providing guidance and tools

00:01:46,910 --> 00:01:51,740
for addressing flaws we should strive to

00:01:50,360 --> 00:01:55,160
prevent the developer from introducing

00:01:51,740 --> 00:01:57,110
the flaws in the first place so we have

00:01:55,160 --> 00:01:59,750
one of the world's finest tool

00:01:57,110 --> 00:02:02,870
manufacturers saying do we really need

00:01:59,750 --> 00:02:04,909
to build tools for this at all what if

00:02:02,870 --> 00:02:07,810
we can make developers lives easier

00:02:04,909 --> 00:02:10,700
without having to resort to tooling and

00:02:07,810 --> 00:02:12,860
we have them asserting that rust has

00:02:10,700 --> 00:02:17,480
opened up a different more desirable

00:02:12,860 --> 00:02:19,250
possible future even if it were just for

00:02:17,480 --> 00:02:21,080
that rust would be an incredibly

00:02:19,250 --> 00:02:23,659
impactful language blazing a new trail

00:02:21,080 --> 00:02:27,019
for other languages to follow but it's

00:02:23,659 --> 00:02:29,200
not just that rust has also blazed a

00:02:27,019 --> 00:02:32,790
trail on a completely different front

00:02:29,200 --> 00:02:35,170
and this one has more to do with

00:02:32,790 --> 00:02:38,980
technology's intersection with social

00:02:35,170 --> 00:02:41,140
issues from the early days rusts core

00:02:38,980 --> 00:02:43,060
leadership understood that there was a

00:02:41,140 --> 00:02:46,300
problem with the way that our language

00:02:43,060 --> 00:02:47,770
communities work they understood that if

00:02:46,300 --> 00:02:50,470
you looked around and saw faces you saw

00:02:47,770 --> 00:02:52,989
people that only looked like you that

00:02:50,470 --> 00:02:55,630
that meant that there was a flaw in the

00:02:52,989 --> 00:02:56,860
system a flaw that was keeping other

00:02:55,630 --> 00:02:58,420
people from having the same

00:02:56,860 --> 00:03:01,450
opportunities and reaching their full

00:02:58,420 --> 00:03:03,730
potential and these leaders were very

00:03:01,450 --> 00:03:04,600
public and very vocal about the fact

00:03:03,730 --> 00:03:06,519
that they didn't think the

00:03:04,600 --> 00:03:08,290
responsibility for solving these

00:03:06,519 --> 00:03:11,230
problems lay on the shoulders of those

00:03:08,290 --> 00:03:13,630
most affected by them but instead they

00:03:11,230 --> 00:03:17,410
themselves intended to work towards

00:03:13,630 --> 00:03:19,630
fixing these problems and this is one

00:03:17,410 --> 00:03:22,989
aspect of rusts leadership that has

00:03:19,630 --> 00:03:24,819
affected me quite personally when you

00:03:22,989 --> 00:03:27,160
come from an underrepresented group in

00:03:24,819 --> 00:03:29,290
tech it can feel like you're swimming in

00:03:27,160 --> 00:03:31,959
a sea of unconscious bias and sometimes

00:03:29,290 --> 00:03:35,140
outward aggression and seeing a beacon

00:03:31,959 --> 00:03:36,430
seeing people waving a flag saying that

00:03:35,140 --> 00:03:39,609
they're going to make space for you to

00:03:36,430 --> 00:03:41,650
join them that can be the difference

00:03:39,609 --> 00:03:45,420
between leaving Tech and finding a

00:03:41,650 --> 00:03:48,160
future in it and I know this feeling

00:03:45,420 --> 00:03:51,010
this is where things were for me when I

00:03:48,160 --> 00:03:53,380
first heard about rust and seeing those

00:03:51,010 --> 00:03:55,600
rust leaders seeing them waving this

00:03:53,380 --> 00:03:58,989
flag of inclusion gave me a place to

00:03:55,600 --> 00:04:01,030
swim towards and that was actually a big

00:03:58,989 --> 00:04:02,739
part of me taking the job at Mozilla

00:04:01,030 --> 00:04:04,690
knowing that I was gonna be working at

00:04:02,739 --> 00:04:08,109
the same company as a lot of the people

00:04:04,690 --> 00:04:11,170
that were waving this flag so I swam in

00:04:08,109 --> 00:04:12,489
that direction I started working at

00:04:11,170 --> 00:04:14,739
Mozilla I wasn't working closely with

00:04:12,489 --> 00:04:17,320
the rust team at that time but I wanted

00:04:14,739 --> 00:04:19,269
to move in that direction so after about

00:04:17,320 --> 00:04:22,270
a year I started thinking about how I

00:04:19,269 --> 00:04:24,520
could do that and it turned out that

00:04:22,270 --> 00:04:25,870
starting on that path would be a

00:04:24,520 --> 00:04:27,970
defining moment for me

00:04:25,870 --> 00:04:31,360
even though it I didn't end up exactly

00:04:27,970 --> 00:04:33,160
where I expected to be I was coming from

00:04:31,360 --> 00:04:35,020
a role that dealt mostly with web

00:04:33,160 --> 00:04:37,120
technology so I figured the best entry

00:04:35,020 --> 00:04:40,360
point for me with rust would be web web

00:04:37,120 --> 00:04:42,210
assembly the first most rudimentary

00:04:40,360 --> 00:04:44,610
support for rust compiled

00:04:42,210 --> 00:04:48,120
assembly had landed at that point and so

00:04:44,610 --> 00:04:50,639
I started playing around with that not

00:04:48,120 --> 00:04:52,259
long after I started down that path I

00:04:50,639 --> 00:04:56,220
ran into a pivotal character in this

00:04:52,259 --> 00:04:58,560
story and that's Luke Wagner now if you

00:04:56,220 --> 00:05:00,479
don't know him he's the person that had

00:04:58,560 --> 00:05:03,930
the key insight that led to as in Jay s

00:05:00,479 --> 00:05:05,699
and he was also a major driving force in

00:05:03,930 --> 00:05:06,590
turning webs as in chase into

00:05:05,699 --> 00:05:10,710
webassembly

00:05:06,590 --> 00:05:13,910
so he's a co-creator of webassembly he's

00:05:10,710 --> 00:05:16,050
also something of a nerd sniping expert

00:05:13,910 --> 00:05:17,849
anyone who's worked with Luke can tell

00:05:16,050 --> 00:05:20,220
you how great he is at getting you

00:05:17,849 --> 00:05:22,259
excited about his ideas and making you

00:05:20,220 --> 00:05:26,580
really want to work to drive them with

00:05:22,259 --> 00:05:28,620
him so I got a little bit waylaid on my

00:05:26,580 --> 00:05:30,539
journey and I ended up not getting all

00:05:28,620 --> 00:05:34,199
the way to rust but ending up somewhere

00:05:30,539 --> 00:05:36,000
rust adjacent but as I was preparing

00:05:34,199 --> 00:05:38,039
this talk I realized that's actually

00:05:36,000 --> 00:05:40,229
given me a really great vantage point to

00:05:38,039 --> 00:05:42,810
see another place where rust is starting

00:05:40,229 --> 00:05:44,460
to blaze a trail and that's because

00:05:42,810 --> 00:05:46,710
since those early days when I was first

00:05:44,460 --> 00:05:47,220
playing around with rust compiled to

00:05:46,710 --> 00:05:50,550
webassembly

00:05:47,220 --> 00:05:53,490
rust has developed top-notch support for

00:05:50,550 --> 00:05:56,070
webassembly the experience is so good

00:05:53,490 --> 00:05:57,599
it's widely considered to be the best

00:05:56,070 --> 00:05:58,139
tool chain around for compiling to

00:05:57,599 --> 00:06:00,810
webassembly

00:05:58,139 --> 00:06:04,470
and it's not just that rust has a great

00:06:00,810 --> 00:06:07,260
implementation rust is also informing

00:06:04,470 --> 00:06:10,009
the specification actively participating

00:06:07,260 --> 00:06:12,240
in shaping the future of webassembly a

00:06:10,009 --> 00:06:15,870
big part of this is a project called

00:06:12,240 --> 00:06:17,639
wasm bind gen this project was created

00:06:15,870 --> 00:06:19,860
to make it easier for rust code that was

00:06:17,639 --> 00:06:23,099
compiled to webassembly to interoperate

00:06:19,860 --> 00:06:25,380
with JavaScript and web api's because at

00:06:23,099 --> 00:06:28,110
least up until now web assembly has only

00:06:25,380 --> 00:06:30,150
been able to talk in numbers if you had

00:06:28,110 --> 00:06:31,020
anything more complex so you know

00:06:30,150 --> 00:06:33,750
something that you wouldn't even think

00:06:31,020 --> 00:06:35,820
of being that complex a string that

00:06:33,750 --> 00:06:38,159
wouldn't work you couldn't actually pass

00:06:35,820 --> 00:06:41,909
that back and forth you'd have to write

00:06:38,159 --> 00:06:45,659
all this glue code in between to encode

00:06:41,909 --> 00:06:47,759
and decode this string so Luke expert

00:06:45,659 --> 00:06:49,380
nerd sniper that he is found some folks

00:06:47,759 --> 00:06:50,009
to work with him to sort out this

00:06:49,380 --> 00:06:52,590
problem

00:06:50,009 --> 00:06:54,270
he explained a few rough ideas so to

00:06:52,590 --> 00:06:54,660
people you might know Alex Crichton and

00:06:54,270 --> 00:06:58,320
Nix

00:06:54,660 --> 00:07:01,650
Jerald and this was how wise invention

00:06:58,320 --> 00:07:05,550
was born a provided really ergonomic yet

00:07:01,650 --> 00:07:07,890
performance it allows a Russ programmer

00:07:05,550 --> 00:07:10,020
to stay at a high level using high level

00:07:07,890 --> 00:07:13,230
types when talking to JavaScript into

00:07:10,020 --> 00:07:16,110
web api's despite web assemblies minimal

00:07:13,230 --> 00:07:19,380
type system so it showed what was

00:07:16,110 --> 00:07:22,110
possible and there started to be this

00:07:19,380 --> 00:07:23,400
virtuous cycle with web assembly

00:07:22,110 --> 00:07:26,160
proposals around interoperability

00:07:23,400 --> 00:07:28,020
influencing wise and bind gen and woz

00:07:26,160 --> 00:07:32,010
and bind gen influencing those proposals

00:07:28,020 --> 00:07:34,320
and with this virtuous cycle this is

00:07:32,010 --> 00:07:37,260
becoming a much bigger much more

00:07:34,320 --> 00:07:38,940
impactful thing it's moved past just

00:07:37,260 --> 00:07:42,630
interoperability with the web platform

00:07:38,940 --> 00:07:47,100
and onto interoperability with all of

00:07:42,630 --> 00:07:48,750
the things so one example you know you

00:07:47,100 --> 00:07:51,780
could run a web assembly module using

00:07:48,750 --> 00:07:55,020
rich api's with high-level types to talk

00:07:51,780 --> 00:07:58,290
to Python or Ruby or PHP when they're

00:07:55,020 --> 00:07:59,640
running in their own runtimes and then

00:07:58,290 --> 00:08:01,560
you could turn around and take that same

00:07:59,640 --> 00:08:02,970
module and use it to directly talk to

00:08:01,560 --> 00:08:05,370
the host or to the operating system

00:08:02,970 --> 00:08:06,840
using the same high-level types even

00:08:05,370 --> 00:08:08,430
though the types of that operating

00:08:06,840 --> 00:08:10,610
system understands are different from

00:08:08,430 --> 00:08:12,810
the types that Python understands and

00:08:10,610 --> 00:08:15,210
then you could use those same high-level

00:08:12,810 --> 00:08:17,190
api's when talking to a web assembly

00:08:15,210 --> 00:08:19,620
module compiled from a different source

00:08:17,190 --> 00:08:21,690
language for example you could have one

00:08:19,620 --> 00:08:25,080
that's compiles from go interoperating

00:08:21,690 --> 00:08:26,910
with one that's compiled from rust why

00:08:25,080 --> 00:08:28,530
would you want to do this why would you

00:08:26,910 --> 00:08:31,860
want to use it as a web assembly module

00:08:28,530 --> 00:08:34,800
in all of these different contexts well

00:08:31,860 --> 00:08:37,860
there are a few reasons if your app is

00:08:34,800 --> 00:08:38,789
in a scripting language like Python then

00:08:37,860 --> 00:08:40,560
what would something could be much

00:08:38,789 --> 00:08:42,060
faster you could get near native

00:08:40,560 --> 00:08:45,480
performance without the hassle of

00:08:42,060 --> 00:08:47,580
compiling a native extension if your app

00:08:45,480 --> 00:08:49,290
is in a lower level language like C++

00:08:47,580 --> 00:08:52,170
then web assembly can give you

00:08:49,290 --> 00:08:54,240
lightweight sandboxing the module can't

00:08:52,170 --> 00:08:56,550
access memory or other resources unless

00:08:54,240 --> 00:08:58,700
they've been directly handed to it so

00:08:56,550 --> 00:09:01,290
this can make reusing code more secure

00:08:58,700 --> 00:09:04,380
and for both scripting and lower-level

00:09:01,290 --> 00:09:06,390
languages being able to reuse code from

00:09:04,380 --> 00:09:07,500
any language ecosystem without having to

00:09:06,390 --> 00:09:10,740
rewrite it in your own layer

00:09:07,500 --> 00:09:14,190
which can help you move faster and can

00:09:10,740 --> 00:09:16,110
ease your maintenance costs and this is

00:09:14,190 --> 00:09:17,790
an area where rust is really primed to

00:09:16,110 --> 00:09:21,840
take the lead and set an example for

00:09:17,790 --> 00:09:23,210
other languages why is this well it's

00:09:21,840 --> 00:09:26,340
for a couple of reasons

00:09:23,210 --> 00:09:29,520
rust already has really a really good

00:09:26,340 --> 00:09:33,390
story around code reuse with affordances

00:09:29,520 --> 00:09:35,220
like the module system and creció and it

00:09:33,390 --> 00:09:37,500
already does have what's widely

00:09:35,220 --> 00:09:39,780
considered to be the best tool chain for

00:09:37,500 --> 00:09:42,570
compiling to web assembly so rust could

00:09:39,780 --> 00:09:44,790
blaze a trail here and I know that I for

00:09:42,570 --> 00:09:46,620
one would really like to see that I'd

00:09:44,790 --> 00:09:49,050
like to see rust bring those technical

00:09:46,620 --> 00:09:51,420
values and those social values to a much

00:09:49,050 --> 00:09:54,300
broader community to the union of all of

00:09:51,420 --> 00:09:55,770
these language communities so I'm going

00:09:54,300 --> 00:09:57,300
to explain the proposal in more depth

00:09:55,770 --> 00:09:59,400
and I hope that this helps you all think

00:09:57,300 --> 00:10:02,430
through what kind of impact rust can

00:09:59,400 --> 00:10:04,290
have here now there may be some things

00:10:02,430 --> 00:10:05,760
in this explanation that our review for

00:10:04,290 --> 00:10:07,770
you but I like to make sure that

00:10:05,760 --> 00:10:11,970
everybody's on the same page so please

00:10:07,770 --> 00:10:14,400
bear with me for those parts first I'll

00:10:11,970 --> 00:10:16,260
start by explaining the initial problem

00:10:14,400 --> 00:10:18,720
that both the specification and wasum

00:10:16,260 --> 00:10:20,370
bind gen we're trying to solve and then

00:10:18,720 --> 00:10:25,050
I'll talk about the larger problem that

00:10:20,370 --> 00:10:26,730
they've moved on to since then so like I

00:10:25,050 --> 00:10:28,680
am in like I mentioned the initial

00:10:26,730 --> 00:10:31,050
problem was a more tractable one

00:10:28,680 --> 00:10:34,230
how can webassembly interact with the

00:10:31,050 --> 00:10:36,690
web platform using high-level types now

00:10:34,230 --> 00:10:38,940
this still isn't a tiny problem web api

00:10:36,690 --> 00:10:41,310
parameters and return values can be lots

00:10:38,940 --> 00:10:43,680
and lots of different types so it could

00:10:41,310 --> 00:10:47,250
be hard to manually create mappings for

00:10:43,680 --> 00:10:48,750
these types to simplify things there's a

00:10:47,250 --> 00:10:51,020
standard way to talk about the structure

00:10:48,750 --> 00:10:53,100
of these types which is called web IDL

00:10:51,020 --> 00:10:54,960
and you can actually do a pretty

00:10:53,100 --> 00:10:57,480
straightforward mapping between web IDL

00:10:54,960 --> 00:11:00,210
and the types in other languages like

00:10:57,480 --> 00:11:02,460
JavaScript so here we have an obvious

00:11:00,210 --> 00:11:04,890
solution just create a mapping from web

00:11:02,460 --> 00:11:07,860
assembly to web IDL just as there is for

00:11:04,890 --> 00:11:10,860
JavaScript but that's not as

00:11:07,860 --> 00:11:13,110
straightforward as it may seem for

00:11:10,860 --> 00:11:14,970
simple web ideal types like boolean and

00:11:13,110 --> 00:11:17,090
unsigned long they're clear mappings

00:11:14,970 --> 00:11:20,070
from web assemblies numbers to web ideal

00:11:17,090 --> 00:11:22,399
but for the most part web web

00:11:20,070 --> 00:11:25,320
keep parameters are more complex types

00:11:22,399 --> 00:11:26,970
so for example an API might take a

00:11:25,320 --> 00:11:29,009
dictionary which is basically an object

00:11:26,970 --> 00:11:32,009
with properties or a sequence which is

00:11:29,009 --> 00:11:33,690
basically an array to have a

00:11:32,009 --> 00:11:36,029
straightforward mapping between

00:11:33,690 --> 00:11:38,639
webassembly types and these web IDL

00:11:36,029 --> 00:11:41,250
types we need to add some higher-level

00:11:38,639 --> 00:11:45,089
types to web assembly and we actually

00:11:41,250 --> 00:11:46,800
are doing that with the GC proposal with

00:11:45,089 --> 00:11:49,470
that web assembly modules we'll be able

00:11:46,800 --> 00:11:52,350
to create GC objects things like structs

00:11:49,470 --> 00:11:53,790
and arrays and those will be you know

00:11:52,350 --> 00:11:57,930
you'll be able to map those to the more

00:11:53,790 --> 00:12:00,000
complex web ideal types but if the only

00:11:57,930 --> 00:12:02,850
way to interoperate with these web api

00:12:00,000 --> 00:12:05,130
is through GC objects that makes life

00:12:02,850 --> 00:12:08,149
harder for languages like rust and c++

00:12:05,130 --> 00:12:10,769
that wouldn't use GC objects otherwise

00:12:08,149 --> 00:12:12,899
whenever that code interoperates with a

00:12:10,769 --> 00:12:14,880
web api would have to create a new GC

00:12:12,899 --> 00:12:18,180
object and copy values from its linear

00:12:14,880 --> 00:12:20,519
memory into that object but we want to

00:12:18,180 --> 00:12:22,860
be just as easy for languages that use

00:12:20,519 --> 00:12:25,500
linear memory like Russ and C++ to call

00:12:22,860 --> 00:12:29,339
web IP eyes as languages that use the

00:12:25,500 --> 00:12:31,470
browser's built-in GC so we need a way

00:12:29,339 --> 00:12:35,029
to create a mapping between objects and

00:12:31,470 --> 00:12:38,790
linear memory and web IDL types as well

00:12:35,029 --> 00:12:40,740
there's another problem here though each

00:12:38,790 --> 00:12:43,350
of these languages these linear memory

00:12:40,740 --> 00:12:45,660
languages represents things differently

00:12:43,350 --> 00:12:47,579
in their linear memory and we can't just

00:12:45,660 --> 00:12:49,019
pick one languages representation

00:12:47,579 --> 00:12:52,680
because that would make things less

00:12:49,019 --> 00:12:54,569
efficient for the other languages but

00:12:52,680 --> 00:12:56,610
even though the exact layout and memory

00:12:54,569 --> 00:12:58,740
for these is often different there are

00:12:56,610 --> 00:13:01,319
some abstract concepts that are they

00:12:58,740 --> 00:13:02,670
usually share in common so for example

00:13:01,319 --> 00:13:05,430
for Strings the language often has a

00:13:02,670 --> 00:13:08,370
pointer to the offset in memory and a

00:13:05,430 --> 00:13:09,630
number indicating the length so this

00:13:08,370 --> 00:13:11,790
means that we could reduce this string

00:13:09,630 --> 00:13:17,370
down to a type that webassembly does

00:13:11,790 --> 00:13:19,350
understand 2-inch 32s now we could hard

00:13:17,370 --> 00:13:22,199
code this mapping into the engine just

00:13:19,350 --> 00:13:24,389
like the JavaScript to what ID l1 is you

00:13:22,199 --> 00:13:25,889
know we could say that if this web api

00:13:24,389 --> 00:13:27,720
is taking a string and i pass two

00:13:25,889 --> 00:13:31,699
numbers just figure out what to do from

00:13:27,720 --> 00:13:34,550
there but there's another problem here

00:13:31,699 --> 00:13:37,259
webassembly is a type checked language

00:13:34,550 --> 00:13:39,839
to keep things secure the engine has to

00:13:37,259 --> 00:13:42,899
check that the calling code is passing

00:13:39,839 --> 00:13:45,089
in the right types the ones at the

00:13:42,899 --> 00:13:46,829
colleagues backs and this is because

00:13:45,089 --> 00:13:49,350
there are ways for attackers to exploit

00:13:46,829 --> 00:13:51,540
type mismatches and make the engine do

00:13:49,350 --> 00:13:52,680
things that's not supposed to do so if

00:13:51,540 --> 00:13:55,170
you're calling something that takes a

00:13:52,680 --> 00:13:57,509
string and try to pass an integer to it

00:13:55,170 --> 00:14:01,110
the engines gonna yell at you and it

00:13:57,509 --> 00:14:03,120
should yell at you so we need a way for

00:14:01,110 --> 00:14:05,759
a module to explicitly tell the engine

00:14:03,120 --> 00:14:08,370
something like I know document create

00:14:05,759 --> 00:14:10,529
element I know that that takes a string

00:14:08,370 --> 00:14:13,079
but when I call it I'm gonna pass you

00:14:10,529 --> 00:14:16,309
two integers now use these to create a

00:14:13,079 --> 00:14:18,600
Dom string from my linear memory and

00:14:16,309 --> 00:14:20,790
this is what an early version of the

00:14:18,600 --> 00:14:22,259
proposal did it gave a web assembly

00:14:20,790 --> 00:14:24,360
module a way to map between the types

00:14:22,259 --> 00:14:26,970
that it uses and web ideal types

00:14:24,360 --> 00:14:29,519
now these mappings aren't hard-coded in

00:14:26,970 --> 00:14:31,980
the engine instead the module comes with

00:14:29,519 --> 00:14:33,629
his own little booklet of mappings so

00:14:31,980 --> 00:14:35,519
get this gives the module a way to say

00:14:33,629 --> 00:14:37,079
to the engine for this function do the

00:14:35,519 --> 00:14:40,889
type checking as if these two integers

00:14:37,079 --> 00:14:42,569
we're a string the fact that this book

00:14:40,889 --> 00:14:45,689
that comes with the module is useful for

00:14:42,569 --> 00:14:47,610
another reason though sometimes a module

00:14:45,689 --> 00:14:49,800
that would usually store its strings in

00:14:47,610 --> 00:14:51,870
linear memory will want to use a GC type

00:14:49,800 --> 00:14:54,269
in a particular case so for example if

00:14:51,870 --> 00:14:58,860
the module got something from Jas and

00:14:54,269 --> 00:15:00,750
just wants to pass it to a Web API so

00:14:58,860 --> 00:15:02,519
modules need to be able to choose on a

00:15:00,750 --> 00:15:04,589
function by function or even an argument

00:15:02,519 --> 00:15:07,470
by argument basis how different types

00:15:04,589 --> 00:15:10,139
should be handled and since the mapping

00:15:07,470 --> 00:15:14,220
is provided by the module it can be

00:15:10,139 --> 00:15:16,889
custom tailored for that module so how

00:15:14,220 --> 00:15:19,439
do we generate this booklet well the

00:15:16,889 --> 00:15:21,029
compiler takes care of that for you it

00:15:19,439 --> 00:15:23,339
adds a custom section to the web

00:15:21,029 --> 00:15:25,139
assembly module so for many language

00:15:23,339 --> 00:15:27,120
toolchains the programmer doesn't have

00:15:25,139 --> 00:15:28,379
to do very much work at all so for

00:15:27,120 --> 00:15:30,149
example let's take a look at how the RUS

00:15:28,379 --> 00:15:32,009
tool chain handles this for one of those

00:15:30,149 --> 00:15:35,220
simplest cases where you're passing a

00:15:32,009 --> 00:15:36,779
string into the alert function the

00:15:35,220 --> 00:15:38,309
programmer just has to tell the compiler

00:15:36,779 --> 00:15:40,850
to include this function in the booklet

00:15:38,309 --> 00:15:42,720
using the annotation wise and bind gen

00:15:40,850 --> 00:15:44,459
by default

00:15:42,720 --> 00:15:45,370
the compiler will treat this as a linear

00:15:44,459 --> 00:15:47,290
memory string

00:15:45,370 --> 00:15:48,910
and add it the right mapping for that

00:15:47,290 --> 00:15:50,590
and if you wanted it to be some other

00:15:48,910 --> 00:15:54,880
kind of string you could add a little

00:15:50,590 --> 00:15:57,010
bit more to that annotation so with this

00:15:54,880 --> 00:15:58,870
we're able to provide really expressive

00:15:57,010 --> 00:16:01,600
mappings between a web assembly modules

00:15:58,870 --> 00:16:03,460
types and web ideal types and we didn't

00:16:01,600 --> 00:16:06,160
have to make any kinds of compromises on

00:16:03,460 --> 00:16:07,720
what kinds of languages we support it's

00:16:06,160 --> 00:16:09,400
possible to have all different kinds of

00:16:07,720 --> 00:16:11,890
languages compiling to web assembly and

00:16:09,400 --> 00:16:14,200
all of them can map their types to web

00:16:11,890 --> 00:16:19,300
ideal types whether the language uses

00:16:14,200 --> 00:16:20,800
linear memory or GC objects or both once

00:16:19,300 --> 00:16:22,240
we stepped back and looked at the

00:16:20,800 --> 00:16:24,610
solution we realized there's actually a

00:16:22,240 --> 00:16:27,160
solution to the bigger hairier problem

00:16:24,610 --> 00:16:29,140
here and here's where we get back to

00:16:27,160 --> 00:16:32,140
that much larger potential for impact

00:16:29,140 --> 00:16:34,330
that I was talking about before is there

00:16:32,140 --> 00:16:37,000
a feasible way for web assembly to talk

00:16:34,330 --> 00:16:40,150
to all of these different things using

00:16:37,000 --> 00:16:42,850
all these different type systems let's

00:16:40,150 --> 00:16:44,080
look at the options like I talked about

00:16:42,850 --> 00:16:48,070
before you could try to create mappings

00:16:44,080 --> 00:16:49,510
like the js2 web IDL ones but to do that

00:16:48,070 --> 00:16:52,180
for each language you have to create a

00:16:49,510 --> 00:16:53,890
specific mapping and the engine would

00:16:52,180 --> 00:16:55,930
have to explicitly support all of these

00:16:53,890 --> 00:16:58,360
mappings and update them as the language

00:16:55,930 --> 00:17:02,610
on either side changes and this creates

00:16:58,360 --> 00:17:05,560
a real mess this is kind of how early

00:17:02,610 --> 00:17:07,150
compilers were designed you know there

00:17:05,560 --> 00:17:09,910
was a pipeline from each source language

00:17:07,150 --> 00:17:12,160
teach machine code language I talked

00:17:09,910 --> 00:17:13,600
about this more in one of my early posts

00:17:12,160 --> 00:17:16,900
about web assembly so you may have seen

00:17:13,600 --> 00:17:19,900
this image there before we don't want

00:17:16,900 --> 00:17:21,700
something this complicated we want it

00:17:19,900 --> 00:17:23,920
possible for all different kinds of

00:17:21,700 --> 00:17:25,660
languages and platforms to talk to each

00:17:23,920 --> 00:17:27,970
other but we want it to be scalable as

00:17:25,660 --> 00:17:29,920
well so we need a different way to do

00:17:27,970 --> 00:17:33,670
this more like modern-day

00:17:29,920 --> 00:17:35,050
compiler architectures these are going

00:17:33,670 --> 00:17:37,180
to split between the front end and the

00:17:35,050 --> 00:17:39,100
back end the front end goes from the

00:17:37,180 --> 00:17:41,230
source language to an abstract

00:17:39,100 --> 00:17:43,900
intermediate representation or IR and

00:17:41,230 --> 00:17:47,320
then the back end goes from that IR to

00:17:43,900 --> 00:17:50,050
the target machine code this is where

00:17:47,320 --> 00:17:51,190
the insight from web IDL comes in when

00:17:50,050 --> 00:17:53,290
you squint at it

00:17:51,190 --> 00:17:57,460
what bad girl kind of looks like an IR

00:17:53,290 --> 00:17:58,300
now why by DL is pretty specific to the

00:17:57,460 --> 00:17:59,470
web

00:17:58,300 --> 00:18:01,450
and there are lots of use cases for

00:17:59,470 --> 00:18:04,150
webassembly outside of the web so what

00:18:01,450 --> 00:18:06,610
my deal itself isn't really great ir for

00:18:04,150 --> 00:18:08,860
us to use but what have you just used

00:18:06,610 --> 00:18:12,760
web ID Allah is inspiration and create a

00:18:08,860 --> 00:18:14,560
new set of abstract types this is how we

00:18:12,760 --> 00:18:17,740
got to the web assembly interface types

00:18:14,560 --> 00:18:19,690
proposal these types aren't concrete

00:18:17,740 --> 00:18:22,600
types they aren't like the inch 32 where

00:18:19,690 --> 00:18:24,340
the float 64 in web assembly today there

00:18:22,600 --> 00:18:26,200
are no operations on them in web

00:18:24,340 --> 00:18:27,760
assembly so for example we won't be

00:18:26,200 --> 00:18:30,970
adding any string concatenation

00:18:27,760 --> 00:18:32,710
operations to web assembly instead all

00:18:30,970 --> 00:18:36,070
operations are performed on the concrete

00:18:32,710 --> 00:18:38,620
types on either side there's one key

00:18:36,070 --> 00:18:40,390
point that makes us possible with

00:18:38,620 --> 00:18:42,790
interface types the two sides aren't

00:18:40,390 --> 00:18:45,370
trying to share a representation instead

00:18:42,790 --> 00:18:48,700
the default is to copy values between

00:18:45,370 --> 00:18:50,170
one side and the other side so this

00:18:48,700 --> 00:18:52,180
makes a lot easier for a single module

00:18:50,170 --> 00:18:56,170
to talk to many different languages

00:18:52,180 --> 00:18:57,910
because it decouples them in some cases

00:18:56,170 --> 00:18:59,680
like the browser the mapping from the

00:18:57,910 --> 00:19:02,530
interface types of the hosts concrete

00:18:59,680 --> 00:19:04,150
types will be baked into the engine so

00:19:02,530 --> 00:19:06,100
one set of mappings will be baked in at

00:19:04,150 --> 00:19:09,400
compile time and the other is handed to

00:19:06,100 --> 00:19:10,990
the engine at load time but in other

00:19:09,400 --> 00:19:12,460
cases when you have two web assembly

00:19:10,990 --> 00:19:14,850
modules that are talking to each other

00:19:12,460 --> 00:19:17,350
they'll both send down a little booklet

00:19:14,850 --> 00:19:19,750
they both have that booklet that maps

00:19:17,350 --> 00:19:24,100
their types to the abstract types the

00:19:19,750 --> 00:19:26,200
interface types now one thing I forgot

00:19:24,100 --> 00:19:27,670
to mention here is that these the

00:19:26,200 --> 00:19:30,610
instructions that use for defining these

00:19:27,670 --> 00:19:32,650
are actually declarative you know use

00:19:30,610 --> 00:19:34,270
instructions but there's no loops or

00:19:32,650 --> 00:19:35,680
other control flow mechanisms that would

00:19:34,270 --> 00:19:39,130
turn this into a turing-complete

00:19:35,680 --> 00:19:41,290
instruction set so what do these

00:19:39,130 --> 00:19:43,300
instructions look like well before we

00:19:41,290 --> 00:19:46,780
get into that I should say this proposal

00:19:43,300 --> 00:19:48,490
still under development so the what I'm

00:19:46,780 --> 00:19:50,680
showing you here is very likely to

00:19:48,490 --> 00:19:52,590
change before it's all said and done and

00:19:50,680 --> 00:19:55,270
also this is all handled by the compiler

00:19:52,590 --> 00:19:56,620
so even when this proposal is finalized

00:19:55,270 --> 00:19:59,110
you'll only need to know what

00:19:56,620 --> 00:20:00,820
annotations your tool chain expects to

00:19:59,110 --> 00:20:01,930
be in your source code you won't

00:20:00,820 --> 00:20:05,080
actually need to know how this works

00:20:01,930 --> 00:20:06,940
under the covers but the details of this

00:20:05,080 --> 00:20:09,730
proposal are pretty neat so I'm going to

00:20:06,940 --> 00:20:10,910
show you the current thinking so let's

00:20:09,730 --> 00:20:13,190
say we want to take a function that

00:20:10,910 --> 00:20:15,020
return a string except webassembly

00:20:13,190 --> 00:20:17,780
doesn't have strings so it returns to

00:20:15,020 --> 00:20:20,540
integers what we would do in our mapping

00:20:17,780 --> 00:20:22,430
is say call export so this would call

00:20:20,540 --> 00:20:24,260
that function and put the two integers

00:20:22,430 --> 00:20:27,410
on the stack and then we would use

00:20:24,260 --> 00:20:28,940
memory to string so that instruction

00:20:27,410 --> 00:20:31,370
tells the engine to use these two

00:20:28,940 --> 00:20:32,600
integers to take the bytes from linear

00:20:31,370 --> 00:20:35,560
memory and turn it into the abstract

00:20:32,600 --> 00:20:37,880
string the immediate value there the mem

00:20:35,560 --> 00:20:40,370
that tells the engine which memory

00:20:37,880 --> 00:20:42,590
object to operate on and then the engine

00:20:40,370 --> 00:20:44,570
pops off those two integers and uses

00:20:42,590 --> 00:20:46,490
them to find the string in there and it

00:20:44,570 --> 00:20:48,160
creates the abstract string which is

00:20:46,490 --> 00:20:50,420
basically just the sequence of Ko points

00:20:48,160 --> 00:20:52,960
and then that's ready to be translated

00:20:50,420 --> 00:20:55,700
into the concrete type on the other side

00:20:52,960 --> 00:20:57,260
what does this look like in Reverse like

00:20:55,700 --> 00:21:01,130
if we were trying to take a string as

00:20:57,260 --> 00:21:03,770
parameter in that case we'd use string

00:21:01,130 --> 00:21:05,480
to memory so this would go from the

00:21:03,770 --> 00:21:08,840
abstract string to the concrete string

00:21:05,480 --> 00:21:10,820
type in our linear memory so we do an r

00:21:08,840 --> 00:21:13,280
get to put a reference to the abstract

00:21:10,820 --> 00:21:14,570
string on the stack and then we would

00:21:13,280 --> 00:21:16,310
call string to memory and the first

00:21:14,570 --> 00:21:18,770
immediate here does the same thing that

00:21:16,310 --> 00:21:21,260
the memory to string one did it tells

00:21:18,770 --> 00:21:22,700
you what memory to operate on and then

00:21:21,260 --> 00:21:24,350
the second tells the engine which

00:21:22,700 --> 00:21:28,520
allocator function to use when

00:21:24,350 --> 00:21:30,260
allocating the bytes here so this is how

00:21:28,520 --> 00:21:32,270
the declarative mapping works and

00:21:30,260 --> 00:21:36,020
there's a really nice side effect to it

00:21:32,270 --> 00:21:37,400
being declarative the engine can see

00:21:36,020 --> 00:21:39,710
when the translation is actually

00:21:37,400 --> 00:21:41,420
unnecessary one you know the two modules

00:21:39,710 --> 00:21:43,700
on either side are already using the

00:21:41,420 --> 00:21:47,690
same type and then the engine can skip a

00:21:43,700 --> 00:21:50,930
lot of the steps in between so that's

00:21:47,690 --> 00:21:52,190
how all of this works under the hood but

00:21:50,930 --> 00:21:53,540
if you want to use this you actually

00:21:52,190 --> 00:21:55,160
don't need to know any of that

00:21:53,540 --> 00:21:58,310
the proposal really makes this whole

00:21:55,160 --> 00:22:00,710
experience pretty seamless so now I want

00:21:58,310 --> 00:22:02,210
to show you that and again I should warn

00:22:00,710 --> 00:22:03,890
you like I said before early stage

00:22:02,210 --> 00:22:05,210
proposal that means that things are

00:22:03,890 --> 00:22:07,610
changing rapidly and you should not use

00:22:05,210 --> 00:22:09,710
this in production but if you want to

00:22:07,610 --> 00:22:11,630
start playing with it we've implemented

00:22:09,710 --> 00:22:14,360
this across the tool chain from

00:22:11,630 --> 00:22:16,760
production to consumption consumption so

00:22:14,360 --> 00:22:18,800
in the RUS tool chain in wes and bind

00:22:16,760 --> 00:22:21,920
gen and in the web assembly runtime

00:22:18,800 --> 00:22:24,140
while some time and since people on our

00:22:21,920 --> 00:22:26,540
team are maintainer zhan all

00:22:24,140 --> 00:22:29,540
these tools and we also are working on

00:22:26,540 --> 00:22:33,980
the standardization itself we can keep

00:22:29,540 --> 00:22:35,540
up with the standard as it develops even

00:22:33,980 --> 00:22:37,400
though all of these parts will continue

00:22:35,540 --> 00:22:38,870
changing we're synchronizing the changes

00:22:37,400 --> 00:22:40,370
so as long as you're using up-to-date

00:22:38,870 --> 00:22:42,140
versions of all of these

00:22:40,370 --> 00:22:47,120
you shouldn't have things breaking on

00:22:42,140 --> 00:22:48,770
you too much so now on to the demo and I

00:22:47,120 --> 00:22:49,970
have to say I have a healthy fear of the

00:22:48,770 --> 00:22:54,440
demo gods so these are actually all

00:22:49,970 --> 00:22:56,180
recorded to show of how this works we

00:22:54,440 --> 00:22:57,890
need a web assembly module that uses

00:22:56,180 --> 00:22:59,540
interface types so let's go ahead and

00:22:57,890 --> 00:23:01,310
make one and since I've been talking

00:22:59,540 --> 00:23:04,940
about strings so much I'll use one that

00:23:01,310 --> 00:23:08,120
takes strings and return strings so a

00:23:04,940 --> 00:23:10,010
markdown parser and since I'm not this

00:23:08,120 --> 00:23:12,560
modules author I'll do this by wrapping

00:23:10,010 --> 00:23:19,430
functionality with the functionality of

00:23:12,560 --> 00:23:22,340
this module with my own module so I'll

00:23:19,430 --> 00:23:24,500
create a render function and that uses

00:23:22,340 --> 00:23:28,550
string types and annotate it with the

00:23:24,500 --> 00:23:31,550
blossom blind Jen macro and this is all

00:23:28,550 --> 00:23:34,310
the magic it knows how the the various

00:23:31,550 --> 00:23:38,060
string types in rust should be matched

00:23:34,310 --> 00:23:40,130
to the webassembly string type and then

00:23:38,060 --> 00:23:41,870
I'll compile it using wasum pack and the

00:23:40,130 --> 00:23:42,890
woz and interface types lag which is

00:23:41,870 --> 00:23:45,950
needed right now because this is

00:23:42,890 --> 00:23:48,260
experimental so this gives us that

00:23:45,950 --> 00:23:52,190
single wasm file that we can use in all

00:23:48,260 --> 00:23:53,420
of these different environments for our

00:23:52,190 --> 00:23:56,150
first environment let's try something

00:23:53,420 --> 00:24:00,080
like pure web assembly this is a

00:23:56,150 --> 00:24:02,330
standalone runtime so I'll download

00:24:00,080 --> 00:24:07,370
class some time from while some time

00:24:02,330 --> 00:24:10,150
talk to F and then we can run this

00:24:07,370 --> 00:24:12,590
module and pass it a markdown string and

00:24:10,150 --> 00:24:14,570
you see if the web assembly module took

00:24:12,590 --> 00:24:16,490
that markdown string and returned to the

00:24:14,570 --> 00:24:18,620
HTML string even though the runtime

00:24:16,490 --> 00:24:20,210
doesn't know anything about how rough

00:24:18,620 --> 00:24:21,470
strings work they were able to

00:24:20,210 --> 00:24:24,410
communicate with each other using these

00:24:21,470 --> 00:24:26,950
high-level types so that was easy and

00:24:24,410 --> 00:24:29,650
straightforward but what about Python

00:24:26,950 --> 00:24:32,000
can we use this markdown parser there

00:24:29,650 --> 00:24:33,059
yes we can and we might want to for the

00:24:32,000 --> 00:24:35,380
speed

00:24:33,059 --> 00:24:37,929
to do this we download the West and time

00:24:35,380 --> 00:24:39,670
extension and this makes it possible for

00:24:37,929 --> 00:24:45,160
Python modules to call webassembly

00:24:39,670 --> 00:24:48,010
functions and then all I need to do is

00:24:45,160 --> 00:24:51,640
import the extension and the markdown

00:24:48,010 --> 00:25:04,720
module and then I can call the render

00:24:51,640 --> 00:25:06,880
function now we can run this and again

00:25:04,720 --> 00:25:09,190
it works the types were different this

00:25:06,880 --> 00:25:11,860
time we're passing in Python values but

00:25:09,190 --> 00:25:13,600
it still just works and this is because

00:25:11,860 --> 00:25:17,320
of that magic of interface types the

00:25:13,600 --> 00:25:18,970
same file runs in the same way we can

00:25:17,320 --> 00:25:21,550
also use the same web assembly module

00:25:18,970 --> 00:25:23,530
and rust one reason you'd want to use

00:25:21,550 --> 00:25:24,640
the web assembly module here is for

00:25:23,530 --> 00:25:25,870
lightweight sandboxing that I was

00:25:24,640 --> 00:25:27,760
talking about before you know this

00:25:25,870 --> 00:25:30,370
isolates this third-party code from the

00:25:27,760 --> 00:25:33,580
rest of your application so let's look

00:25:30,370 --> 00:25:36,400
at how this works so we add while some

00:25:33,580 --> 00:25:39,510
time rust as a dependency and this does

00:25:36,400 --> 00:25:43,510
the same thing as the Python extension

00:25:39,510 --> 00:25:45,940
and then in the main file we add the

00:25:43,510 --> 00:25:48,640
Oise and time rust macro and then add a

00:25:45,940 --> 00:25:52,210
trait and we're gonna add a render

00:25:48,640 --> 00:25:53,590
method as part of that tree but we won't

00:25:52,210 --> 00:25:55,750
add an implementation here where you

00:25:53,590 --> 00:25:57,070
might expect it instead the web assembly

00:25:55,750 --> 00:25:59,380
module is going to be that

00:25:57,070 --> 00:26:02,860
implementation so the macro just wires

00:25:59,380 --> 00:26:05,080
that up for us it also adds in other

00:26:02,860 --> 00:26:06,910
methods on that trait like load file

00:26:05,080 --> 00:26:09,250
which instantiates a web assembly module

00:26:06,910 --> 00:26:11,950
from a file so in the main function

00:26:09,250 --> 00:26:16,920
we'll call low file to instantiate the

00:26:11,950 --> 00:26:18,880
module and then we'll call render and

00:26:16,920 --> 00:26:22,120
something that's important to note here

00:26:18,880 --> 00:26:23,770
the result is actually strongly typed so

00:26:22,120 --> 00:26:26,140
it can be used exactly in the same way

00:26:23,770 --> 00:26:30,160
as a natively compiled version of this

00:26:26,140 --> 00:26:34,240
functionality so now let's use cargo to

00:26:30,160 --> 00:26:35,440
run it and again it just works except

00:26:34,240 --> 00:26:38,020
with a different environment using

00:26:35,440 --> 00:26:39,429
different types now this might not seem

00:26:38,020 --> 00:26:41,620
impressive since we compiled the

00:26:39,429 --> 00:26:43,300
original version from rust but it would

00:26:41,620 --> 00:26:45,070
work just as seamlessly even if this

00:26:43,300 --> 00:26:45,850
were compiled from go receive plus plus

00:26:45,070 --> 00:26:50,350
as long as

00:26:45,850 --> 00:26:53,169
module was using interface types so

00:26:50,350 --> 00:26:54,309
where else can we make this work I don't

00:26:53,169 --> 00:26:56,620
have enough time to show you but it

00:26:54,309 --> 00:26:58,679
already works in node and the web as

00:26:56,620 --> 00:27:00,820
well through Watson behind Jun and

00:26:58,679 --> 00:27:03,160
that's the same what Russ module

00:27:00,820 --> 00:27:05,620
compiled to web assembly and we're using

00:27:03,160 --> 00:27:07,840
it the same rich API and types to talk

00:27:05,620 --> 00:27:09,940
to five wildly different runtimes and

00:27:07,840 --> 00:27:11,770
languages and those are just a few

00:27:09,940 --> 00:27:13,330
examples there's no reason this can't

00:27:11,770 --> 00:27:16,960
work in other languages and other

00:27:13,330 --> 00:27:19,059
runtimes many more of them so I hope

00:27:16,960 --> 00:27:21,730
this helps illuminate the potential here

00:27:19,059 --> 00:27:23,140
the potential for rust to bring the many

00:27:21,730 --> 00:27:25,360
things that have made it so impactful

00:27:23,140 --> 00:27:27,880
the technical values and the social

00:27:25,360 --> 00:27:30,280
values directly to the rest of the

00:27:27,880 --> 00:27:32,380
programming world because that is a

00:27:30,280 --> 00:27:34,000
possible future now and I know it's a

00:27:32,380 --> 00:27:37,299
future that many of us would like to see

00:27:34,000 --> 00:27:38,590
I want to thank the people who have been

00:27:37,299 --> 00:27:40,630
working on this the folks they've been

00:27:38,590 --> 00:27:41,830
working on the specification and a huge

00:27:40,630 --> 00:27:43,059
thanks to the folks that worked on the

00:27:41,830 --> 00:27:44,919
demo they did a tremendous job

00:27:43,059 --> 00:27:47,110
incorporating web assembly into all of

00:27:44,919 --> 00:27:49,690
these environments and they also are

00:27:47,110 --> 00:27:51,370
very involved in all of the rust and web

00:27:49,690 --> 00:27:52,960
assembly work so if you want to learn

00:27:51,370 --> 00:27:54,640
more about how you can incorporate web

00:27:52,960 --> 00:27:56,110
assembly into another language or

00:27:54,640 --> 00:27:58,750
runtime they're definitely good people

00:27:56,110 --> 00:28:00,909
to talk to I also want to thank my

00:27:58,750 --> 00:28:02,470
fantastic collaborators till Schneider 8

00:28:00,909 --> 00:28:04,419
and Luc Wagner for their invaluable

00:28:02,470 --> 00:28:07,090
input on both the talk in the post

00:28:04,419 --> 00:28:08,490
around this and thank you all for

00:28:07,090 --> 00:28:13,540
listening

00:28:08,490 --> 00:28:20,280
[Applause]

00:28:13,540 --> 00:28:22,340
[Music]

00:28:20,280 --> 00:28:22,340

YouTube URL: https://www.youtube.com/watch?v=KFpU30xluxo


