Title: RustConf 2019 - Class Fixes; Or, You Become the Rust Compiler by Isobel Redelmeier
Publication date: 2019-09-16
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Class Fixes; Or, You Become the Rust Compiler by Isobel Redelmeier

What's a "class fix"? Well, a class break is a is a security term for a type of vulnerability that breaks not just a single instance (e.g., a single database), but instead a whole category of systems (e.g., all MySQL databases). Let's think of class fixes, then, as the happy opposite: one solution that addresses a whole slew of problems - much like Rust does by enforcing code correctness so strictly.

We'll go on a tour of the Rust features that provide us with class fixes, such as our dear, persistent friend, the borrow checker. But let's not stop there! Learning Rust can help train you to think more like the Rust compiler. We'll turn that into your new superpower, so that you can start applying the same rigor to even your non-Rust projects.

Expect to walk a way with a better toolkit for holistic debugging and system design!
Captions: 
	00:00:08,770 --> 00:00:15,680
[Music]

00:00:17,320 --> 00:00:21,950
I'm Isabella's mentioned really really

00:00:20,390 --> 00:00:24,410
excited to be here and talk to you all

00:00:21,950 --> 00:00:28,670
about class fixes or how you can become

00:00:24,410 --> 00:00:31,640
the rest compiler yourself so quick mini

00:00:28,670 --> 00:00:33,680
agenda basically just intro and then I'm

00:00:31,640 --> 00:00:36,470
going to talk about class breaks and how

00:00:33,680 --> 00:00:38,180
we can invert that concept and use it to

00:00:36,470 --> 00:00:43,070
think about things in terms of class

00:00:38,180 --> 00:00:45,320
fixes and then how that can can help you

00:00:43,070 --> 00:00:47,120
to become the compiler either when you

00:00:45,320 --> 00:00:50,300
are writing rust or also when you are

00:00:47,120 --> 00:00:52,190
not writing rust and then maybe maybe a

00:00:50,300 --> 00:00:54,140
quick Q&A at the end

00:00:52,190 --> 00:00:55,729
you can definitely come find me

00:00:54,140 --> 00:00:58,940
afterwards it's all stick around and

00:00:55,729 --> 00:01:02,629
I'll be here all day and so on more than

00:00:58,940 --> 00:01:04,699
happy to talk about this so Who am I um

00:01:02,629 --> 00:01:06,979
I work on open source mostly open

00:01:04,699 --> 00:01:08,990
telemetry at light step these days I

00:01:06,979 --> 00:01:13,340
used to work at cloud print on Cloud

00:01:08,990 --> 00:01:17,020
Foundry at pivotal so I mostly do go by

00:01:13,340 --> 00:01:19,940
day also some Python Ruby JavaScript

00:01:17,020 --> 00:01:23,630
done a bunch of whatever is kind of

00:01:19,940 --> 00:01:28,130
necessary a lot of bash turns out often

00:01:23,630 --> 00:01:31,430
is what's necessary but by night rust is

00:01:28,130 --> 00:01:36,050
where I'm happiest also get to maybe do

00:01:31,430 --> 00:01:38,900
it at work and hopefully more soon but

00:01:36,050 --> 00:01:43,880
mostly go these days I work or text

00:01:38,900 --> 00:01:46,300
because specs so what are the goals of

00:01:43,880 --> 00:01:51,890
this talk what do I hope that you can

00:01:46,300 --> 00:01:54,260
take away from it basically the hope is

00:01:51,890 --> 00:01:56,030
that you'll be able to use this as a

00:01:54,260 --> 00:02:00,680
framework for approaching error

00:01:56,030 --> 00:02:03,290
mitigation so in other words how to not

00:02:00,680 --> 00:02:07,370
necessarily solve individual bugs but

00:02:03,290 --> 00:02:12,620
instead how to prevent whole categories

00:02:07,370 --> 00:02:14,239
of bugs and ideally so I thought I had

00:02:12,620 --> 00:02:18,530
another slide in there but I forgot to

00:02:14,239 --> 00:02:21,440
put it into this version ideally how to

00:02:18,530 --> 00:02:24,349
actually use rust and therefore leverage

00:02:21,440 --> 00:02:27,319
the compiler directly but also how when

00:02:24,349 --> 00:02:29,330
you're not using rust how to essentially

00:02:27,319 --> 00:02:31,190
think the same way that the compiler

00:02:29,330 --> 00:02:33,350
and therefore kind of conventionalized

00:02:31,190 --> 00:02:37,310
some of the things that rust does for

00:02:33,350 --> 00:02:40,520
you so class breaks

00:02:37,310 --> 00:02:43,130
start there basically this is a security

00:02:40,520 --> 00:02:44,720
term um don't think it was originally

00:02:43,130 --> 00:02:46,550
coined by Bruce Schneier but he's

00:02:44,720 --> 00:02:49,210
certainly how I first heard about it so

00:02:46,550 --> 00:02:51,590
a class break is a particular security

00:02:49,210 --> 00:02:54,680
vulnerability that breaks not just one

00:02:51,590 --> 00:02:56,510
system but entire entire class of

00:02:54,680 --> 00:03:00,440
systems he has a really good essay about

00:02:56,510 --> 00:03:03,290
this out there so an example would be

00:03:00,440 --> 00:03:05,270
locks you know traditional locks you

00:03:03,290 --> 00:03:08,210
have one lock you need one key for that

00:03:05,270 --> 00:03:10,070
lock therefore in order to break in she

00:03:08,210 --> 00:03:13,520
let's say ten houses you would need to

00:03:10,070 --> 00:03:16,180
break into ten walks separately so

00:03:13,520 --> 00:03:22,220
that's essentially safe in that regard

00:03:16,180 --> 00:03:24,890
however there are your locks however if

00:03:22,220 --> 00:03:27,050
you instead have the same lock for

00:03:24,890 --> 00:03:29,390
example maybe you have a skeleton key or

00:03:27,050 --> 00:03:32,870
you know the TSA they had they had this

00:03:29,390 --> 00:03:36,440
issue a few years ago where they had a

00:03:32,870 --> 00:03:40,190
skeleton key for all luggage locks and

00:03:36,440 --> 00:03:42,350
someone someone printed like the

00:03:40,190 --> 00:03:44,239
Washington Post I think printed a copy

00:03:42,350 --> 00:03:48,010
of it online basically so now suddenly

00:03:44,239 --> 00:03:52,670
everyone had access to every luggage

00:03:48,010 --> 00:03:54,530
piece out there or similarly smart locks

00:03:52,670 --> 00:03:58,670
also have the same potential

00:03:54,530 --> 00:04:01,340
vulnerability and was exploited a couple

00:03:58,670 --> 00:04:04,100
years or so ago with a hotel where

00:04:01,340 --> 00:04:06,290
basically someone went and like held all

00:04:04,100 --> 00:04:10,250
the hotel guests hostage I think this

00:04:06,290 --> 00:04:12,550
was in Austria so essentially there are

00:04:10,250 --> 00:04:15,130
some nice genes that you get from having

00:04:12,550 --> 00:04:19,690
from essentially drying up your locks

00:04:15,130 --> 00:04:22,160
drying in the software sense not in the

00:04:19,690 --> 00:04:25,640
meteorological sense however there are

00:04:22,160 --> 00:04:27,710
also potential problems and this isn't

00:04:25,640 --> 00:04:30,650
just true for things like locks it's

00:04:27,710 --> 00:04:33,340
true for basically every piece of every

00:04:30,650 --> 00:04:33,340
dependency we

00:04:38,420 --> 00:04:45,620
then every every machine using that same

00:04:42,050 --> 00:04:48,080
version of OS or another another version

00:04:45,620 --> 00:04:49,820
affected by the same vulnerability is

00:04:48,080 --> 00:04:53,600
affected those are thermometers for

00:04:49,820 --> 00:04:55,370
anyone who can't tell turns out it's

00:04:53,600 --> 00:05:00,740
really hard to draw a thermometers I am

00:04:55,370 --> 00:05:02,420
NOT an artist so essentially um you know

00:05:00,740 --> 00:05:05,420
hopefully you're using a common

00:05:02,420 --> 00:05:08,000
operating system I mean I were a trust

00:05:05,420 --> 00:05:10,550
conf I suspect that some of you here

00:05:08,000 --> 00:05:13,340
today are also working on your own and

00:05:10,550 --> 00:05:16,750
that you have very awesome reasons to do

00:05:13,340 --> 00:05:19,240
so but in general if you are running

00:05:16,750 --> 00:05:22,100
running most companies you probably

00:05:19,240 --> 00:05:25,490
don't want to be running I want to be

00:05:22,100 --> 00:05:28,400
writing your own OS from scratch for

00:05:25,490 --> 00:05:31,090
this just in order to skirt around class

00:05:28,400 --> 00:05:34,130
breaks if you're you know Google or

00:05:31,090 --> 00:05:36,680
whomever you might have your own Fork or

00:05:34,130 --> 00:05:38,750
you might go and write fuchsia or

00:05:36,680 --> 00:05:40,460
something um I suspect that there are

00:05:38,750 --> 00:05:44,420
some fuchsia people um here especially

00:05:40,460 --> 00:05:47,480
since I think it's largely rust but in

00:05:44,420 --> 00:05:49,520
general if you are for example someone

00:05:47,480 --> 00:05:52,490
like me working at like 100 or so person

00:05:49,520 --> 00:05:55,730
startup that is not focused on

00:05:52,490 --> 00:05:57,080
delivering on OS that probably isn't

00:05:55,730 --> 00:05:58,670
something you should be focusing on

00:05:57,080 --> 00:06:02,630
because you will instead have other

00:05:58,670 --> 00:06:04,940
problems if you try to write your own so

00:06:02,630 --> 00:06:09,740
essentially a class break break once

00:06:04,940 --> 00:06:11,810
break everywhere so what if we invert

00:06:09,740 --> 00:06:14,240
that what if we instead have something

00:06:11,810 --> 00:06:16,700
that we fix once and there by fixed

00:06:14,240 --> 00:06:20,870
everywhere can think of this as a class

00:06:16,700 --> 00:06:25,750
fix it's what I'm calling it so what

00:06:20,870 --> 00:06:25,750
would it mean to fix our code everywhere

00:06:26,470 --> 00:06:32,350
if we think about bugs and if we think

00:06:30,230 --> 00:06:36,680
about them kind of in just like a basic

00:06:32,350 --> 00:06:38,150
cs101 sense at least then you

00:06:36,680 --> 00:06:40,690
essentially have kind of three main

00:06:38,150 --> 00:06:43,820
categories of bugs you have logic errors

00:06:40,690 --> 00:06:46,850
so things that those things where you as

00:06:43,820 --> 00:06:48,660
the programmer got something wrong

00:06:46,850 --> 00:06:52,140
so maybe

00:06:48,660 --> 00:06:54,600
you for example the other day couple

00:06:52,140 --> 00:06:57,660
co-workers were working on on an

00:06:54,600 --> 00:07:00,420
interesting algorithm and they were miss

00:06:57,660 --> 00:07:02,160
implementing it the algorithm was

00:07:00,420 --> 00:07:05,940
theoretically correct just the

00:07:02,160 --> 00:07:10,710
implementation it was wrong then you

00:07:05,940 --> 00:07:13,730
have runtime errors which we most of us

00:07:10,710 --> 00:07:16,470
have probably encountered hopefully not

00:07:13,730 --> 00:07:19,410
too much in production but almost

00:07:16,470 --> 00:07:21,570
definitely in productions and because

00:07:19,410 --> 00:07:26,190
these happen most often in production

00:07:21,570 --> 00:07:28,890
they're quite hard to tackle near

00:07:26,190 --> 00:07:30,360
compile time errors and while these

00:07:28,890 --> 00:07:32,490
might be annoying when you're actually

00:07:30,360 --> 00:07:35,820
writing code they're also kind of

00:07:32,490 --> 00:07:37,860
awesome in another sense in that if you

00:07:35,820 --> 00:07:40,020
know at compile time that something

00:07:37,860 --> 00:07:45,090
doesn't work then you can just kind of

00:07:40,020 --> 00:07:47,220
fix it before you deploy it or send it

00:07:45,090 --> 00:07:50,370
out to your customers or whatever

00:07:47,220 --> 00:07:52,980
depending on your particular deployment

00:07:50,370 --> 00:07:55,080
stress your delivery mechanism so

00:07:52,980 --> 00:07:58,410
compile time errors essentially are the

00:07:55,080 --> 00:08:01,800
safest of these three categories in that

00:07:58,410 --> 00:08:04,560
regard they're kind of better than the

00:08:01,800 --> 00:08:07,560
other two of types of errors and that as

00:08:04,560 --> 00:08:11,430
an engineer it's a lot easier to to fix

00:08:07,560 --> 00:08:14,850
them so the more that we can move logic

00:08:11,430 --> 00:08:17,550
and runtime errors towards becoming

00:08:14,850 --> 00:08:22,020
compile time errors the safer our

00:08:17,550 --> 00:08:25,230
systems are going to be essentially if

00:08:22,020 --> 00:08:28,800
we can downgrade a bugs category ideally

00:08:25,230 --> 00:08:30,510
all the way to compile time then it's I

00:08:28,800 --> 00:08:34,229
would argue a form of fixing it

00:08:30,510 --> 00:08:37,860
everywhere so the rust compiler does

00:08:34,229 --> 00:08:40,500
this a lot for us and sorry for the

00:08:37,860 --> 00:08:43,800
large wall of text up there basically

00:08:40,500 --> 00:08:46,770
Gary Bernhardt he have watt fame also

00:08:43,800 --> 00:08:47,820
the future of JavaScript or life and

00:08:46,770 --> 00:08:50,970
death of JavaScript

00:08:47,820 --> 00:08:53,520
it's called had this quote the other day

00:08:50,970 --> 00:08:56,070
programming is rolling boulders uphill

00:08:53,520 --> 00:08:58,320
forever a type system tells you when

00:08:56,070 --> 00:09:00,690
boulders roll back down if you look at

00:08:58,320 --> 00:09:02,910
that and say I will not expend effort

00:09:00,690 --> 00:09:04,290
- no when boulders roll back down you

00:09:02,910 --> 00:09:06,090
should at least know how much effort

00:09:04,290 --> 00:09:09,900
you're talking about versus how many

00:09:06,090 --> 00:09:12,480
boulders it stops so he was talking

00:09:09,900 --> 00:09:13,950
mostly about type systems in this

00:09:12,480 --> 00:09:17,820
context I think it was a tweet thread

00:09:13,950 --> 00:09:20,850
about about typescript versus regular

00:09:17,820 --> 00:09:22,710
untyped JavaScript however you can also

00:09:20,850 --> 00:09:26,400
extrapolate and apply it to other

00:09:22,710 --> 00:09:27,810
aspects of a language um even just kind

00:09:26,400 --> 00:09:31,920
of from the ground up you can think of

00:09:27,810 --> 00:09:35,910
how how basically any modern language

00:09:31,920 --> 00:09:38,940
that we're using improves a lot on for

00:09:35,910 --> 00:09:40,470
on like assembly for example again some

00:09:38,940 --> 00:09:43,500
of us are probably using assembly I

00:09:40,470 --> 00:09:47,400
personally am NOT or haven't since had

00:09:43,500 --> 00:09:54,630
to you for CS reasons but day to day I

00:09:47,400 --> 00:09:56,610
suspect some people are which rest that

00:09:54,630 --> 00:09:58,320
is supposed to be a cape it's okay if

00:09:56,610 --> 00:10:00,390
you think of it as a chef's hat instead

00:09:58,320 --> 00:10:03,450
I I won't

00:10:00,390 --> 00:10:06,770
I won't blame you um but the point is

00:10:03,450 --> 00:10:11,250
Harris is awesome

00:10:06,770 --> 00:10:13,470
so Russ type system gives us so so so

00:10:11,250 --> 00:10:15,900
many niceties it's awesome I'm not going

00:10:13,470 --> 00:10:18,090
to go into all of them here because I

00:10:15,900 --> 00:10:20,490
think most of us are probably pretty

00:10:18,090 --> 00:10:24,510
familiar with them and all of them also

00:10:20,490 --> 00:10:26,790
aren't the the improvements that Russ

00:10:24,510 --> 00:10:29,610
type system gives us compared to most

00:10:26,790 --> 00:10:32,670
other languages type systems are awesome

00:10:29,610 --> 00:10:34,410
but in some ways less relevant than

00:10:32,670 --> 00:10:38,970
other things also more languages are

00:10:34,410 --> 00:10:41,550
kind of moving in moving towards rest

00:10:38,970 --> 00:10:45,270
like type systems I would say so for

00:10:41,550 --> 00:10:47,280
example typescript has has pattern

00:10:45,270 --> 00:10:48,600
matching similar to Russ I don't know

00:10:47,280 --> 00:10:50,660
exactly how similar I have really

00:10:48,600 --> 00:10:53,640
written much typescript but it has some

00:10:50,660 --> 00:10:55,170
go is getting generics it's still a bit

00:10:53,640 --> 00:10:59,480
unclear what they're generics are going

00:10:55,170 --> 00:11:01,950
to look like but they'll have generics I

00:10:59,480 --> 00:11:05,880
really like breast choice type system

00:11:01,950 --> 00:11:07,980
but the general the general factor of

00:11:05,880 --> 00:11:09,450
kind of a type system versus note type

00:11:07,980 --> 00:11:12,470
system I think most of us are familiar

00:11:09,450 --> 00:11:15,530
with how how

00:11:12,470 --> 00:11:18,110
having your compiler be aware of your

00:11:15,530 --> 00:11:21,310
types and thus stop you from trying to

00:11:18,110 --> 00:11:26,090
like add an int to a string for example

00:11:21,310 --> 00:11:28,130
it's pretty nice we we when we write on

00:11:26,090 --> 00:11:30,530
type languages we can do that to some

00:11:28,130 --> 00:11:32,270
extent we can you know anticipate that

00:11:30,530 --> 00:11:35,390
we probably shouldn't be adding an int

00:11:32,270 --> 00:11:38,600
to a string however it just is nice to

00:11:35,390 --> 00:11:41,240
have to have the compiler do that for us

00:11:38,600 --> 00:11:43,730
which gets back to what Gary Burton

00:11:41,240 --> 00:11:45,800
Hertz that here about how much effort

00:11:43,730 --> 00:11:48,140
you're talking about versus how many

00:11:45,800 --> 00:11:50,930
boulders have stops like you as a

00:11:48,140 --> 00:11:53,270
programmer can stop some by just kind of

00:11:50,930 --> 00:11:56,750
thinking knowing that like you shouldn't

00:11:53,270 --> 00:11:58,970
add an in to a string however when your

00:11:56,750 --> 00:12:02,510
compiler does it you you get more or

00:11:58,970 --> 00:12:05,300
less 100 percent again depends on

00:12:02,510 --> 00:12:08,450
whether you have like any types or

00:12:05,300 --> 00:12:14,660
things like that but it removes you

00:12:08,450 --> 00:12:18,230
towards perfection so another big thing

00:12:14,660 --> 00:12:21,320
rust doesn't have reflection which in

00:12:18,230 --> 00:12:25,130
some ways might make it harder than

00:12:21,320 --> 00:12:27,230
other languages getting back to the the

00:12:25,130 --> 00:12:30,350
analogy of how many boulders it stops

00:12:27,230 --> 00:12:32,660
versus how much effort it takes to UM to

00:12:30,350 --> 00:12:35,720
lever it to harness it in order to stop

00:12:32,660 --> 00:12:38,390
those boulders however what it gives us

00:12:35,720 --> 00:12:40,070
instead is pattern matching I know that

00:12:38,390 --> 00:12:43,550
they're not kind of a that it's not a

00:12:40,070 --> 00:12:46,970
perfect flip however in many ways it

00:12:43,550 --> 00:12:48,740
gets you what you might it gets you what

00:12:46,970 --> 00:12:53,480
you would use reflection for

00:12:48,740 --> 00:12:56,840
traditionally so essentially if you wrap

00:12:53,480 --> 00:13:00,440
a tricky enum types with their own types

00:12:56,840 --> 00:13:02,210
you can capture a lot of what a lot of

00:13:00,440 --> 00:13:06,590
the use cases for reflection in the

00:13:02,210 --> 00:13:10,070
first place an example here's some go

00:13:06,590 --> 00:13:13,040
it's very messy go but basically there

00:13:10,070 --> 00:13:15,740
you have you want to open it a database

00:13:13,040 --> 00:13:18,650
connection varies depending on what what

00:13:15,740 --> 00:13:21,950
database type you're using see how this

00:13:18,650 --> 00:13:23,680
open DB function that just takes a DD

00:13:21,950 --> 00:13:26,619
type which is the post

00:13:23,680 --> 00:13:29,110
it's own type but this code compiles

00:13:26,619 --> 00:13:31,389
despite the fact that it huh it lets you

00:13:29,110 --> 00:13:33,850
throw in random string so here we have

00:13:31,389 --> 00:13:37,360
to to find to tie to defined DB types

00:13:33,850 --> 00:13:39,869
Postgres in my sequel we're using my

00:13:37,360 --> 00:13:42,129
sequel correctly however Postgres

00:13:39,869 --> 00:13:45,579
there's a mismatch between the strings

00:13:42,129 --> 00:13:48,279
and then this switch statement also lets

00:13:45,579 --> 00:13:51,670
us handle foo which is not a database

00:13:48,279 --> 00:13:54,160
and it lets us call a function with

00:13:51,670 --> 00:13:56,050
something that again is invalid

00:13:54,160 --> 00:14:00,610
literally the string invalid in this

00:13:56,050 --> 00:14:03,100
case so well we have the type there too

00:14:00,610 --> 00:14:05,259
kind of hint at at ourselves and other

00:14:03,100 --> 00:14:07,660
engineers I personally like to think of

00:14:05,259 --> 00:14:09,040
kind of myself from yesterday as another

00:14:07,660 --> 00:14:12,369
engineer because they have really bad

00:14:09,040 --> 00:14:14,559
short-term memory apparently so it lets

00:14:12,369 --> 00:14:16,509
you suggest that you should be using a

00:14:14,559 --> 00:14:19,329
database type but it isn't really that

00:14:16,509 --> 00:14:22,839
good at enforcing that and a lot of

00:14:19,329 --> 00:14:25,720
other languages that have enums have

00:14:22,839 --> 00:14:28,360
kind of similar shortcomings in their

00:14:25,720 --> 00:14:33,870
types go also does have enums but

00:14:28,360 --> 00:14:38,829
they're about as unsafe I would say as

00:14:33,870 --> 00:14:40,629
doing a type like this not unsafe in the

00:14:38,829 --> 00:14:43,300
rest sense just unsafe in the sense of

00:14:40,629 --> 00:14:48,490
like the compiler it doesn't really let

00:14:43,300 --> 00:14:49,899
you do anything interesting with them if

00:14:48,490 --> 00:14:52,660
you compare this though to what you

00:14:49,899 --> 00:14:55,779
would write in crust here here you just

00:14:52,660 --> 00:14:59,199
have a simple enum and then you have an

00:14:55,779 --> 00:15:01,720
open method which is aware of what type

00:14:59,199 --> 00:15:05,079
it should be handling and the rust

00:15:01,720 --> 00:15:07,720
compiler is able to tell us whether if

00:15:05,079 --> 00:15:10,179
we are missing a type or not handling

00:15:07,720 --> 00:15:12,699
something it also is able to ensure that

00:15:10,179 --> 00:15:15,129
we are handling everything that we

00:15:12,699 --> 00:15:17,410
should be and that we're not handling

00:15:15,129 --> 00:15:23,379
anything that is invalid so now we can

00:15:17,410 --> 00:15:26,769
just say Postgres open and carry on if

00:15:23,379 --> 00:15:30,920
we went back to go we could kind of hack

00:15:26,769 --> 00:15:34,310
it have something similar ish together

00:15:30,920 --> 00:15:36,710
this is not the neatest go codes alright

00:15:34,310 --> 00:15:40,640
but basically for those unfamiliar with

00:15:36,710 --> 00:15:43,820
go capitalized things get our public

00:15:40,640 --> 00:15:46,280
uncapitalized things are private so here

00:15:43,820 --> 00:15:47,930
this DB type interface is something that

00:15:46,280 --> 00:15:51,290
can only be implemented within the

00:15:47,930 --> 00:15:53,990
package because it has this private

00:15:51,290 --> 00:15:55,880
method that it requires is DP type so

00:15:53,990 --> 00:15:57,950
now we have two type two types that

00:15:55,880 --> 00:16:01,340
implement the interface post for us in

00:15:57,950 --> 00:16:03,230
my sequel and they both are forms of

00:16:01,340 --> 00:16:05,330
this DB type which again we can use

00:16:03,230 --> 00:16:08,030
anywhere we can only but we can only

00:16:05,330 --> 00:16:10,070
implement within the one package and

00:16:08,030 --> 00:16:11,960
then they also have their own open

00:16:10,070 --> 00:16:15,140
methods and so now I can just say

00:16:11,960 --> 00:16:17,120
Postgres open kind of similar to what

00:16:15,140 --> 00:16:19,040
you would do in rust it just doesn't

00:16:17,120 --> 00:16:22,250
have quite as much of what the compiler

00:16:19,040 --> 00:16:25,130
gives us and in my opinion at least this

00:16:22,250 --> 00:16:28,210
is a lot messier than what you have in

00:16:25,130 --> 00:16:32,630
rust certainly rust fewer lines of code

00:16:28,210 --> 00:16:34,880
and if you were missing it type the rust

00:16:32,630 --> 00:16:37,310
compiler would complain unless you were

00:16:34,880 --> 00:16:40,570
handling it in some other way

00:16:37,310 --> 00:16:44,090
but again the compiler would ensure that

00:16:40,570 --> 00:16:46,460
another thing option instead of null so

00:16:44,090 --> 00:16:49,430
who here has ever encountered some sort

00:16:46,460 --> 00:16:53,000
of null pointer exceptions yeah I think

00:16:49,430 --> 00:16:56,390
that's everyone's so option pretty

00:16:53,000 --> 00:16:57,860
awesome some languages like Java for

00:16:56,390 --> 00:17:00,440
example are moving in the direction of

00:16:57,860 --> 00:17:04,750
gaining it um personally the last time

00:17:00,440 --> 00:17:08,959
that I wrote a like application in Java

00:17:04,750 --> 00:17:10,400
we attempted to use option however like

00:17:08,959 --> 00:17:12,320
half the team wasn't really on board

00:17:10,400 --> 00:17:13,699
with it so we still kind of and then we

00:17:12,320 --> 00:17:15,980
were using a bunch of libraries that

00:17:13,699 --> 00:17:18,410
didn't that didn't support it and we

00:17:15,980 --> 00:17:20,150
ended up having nil checks all over the

00:17:18,410 --> 00:17:24,020
place despite having options

00:17:20,150 --> 00:17:26,360
I imagine that others have more success

00:17:24,020 --> 00:17:30,580
with it also that that another group

00:17:26,360 --> 00:17:34,220
have even less success than my team did

00:17:30,580 --> 00:17:40,679
so if we again go back to go here we

00:17:34,220 --> 00:17:44,110
have this kind of plain bit of a

00:17:40,679 --> 00:17:46,630
and example here where we have an

00:17:44,110 --> 00:17:48,399
interface and then another interface

00:17:46,630 --> 00:17:51,010
that contains that first one so

00:17:48,399 --> 00:17:54,250
interface and interface container really

00:17:51,010 --> 00:17:57,549
creatively named I'm I know and in the

00:17:54,250 --> 00:18:03,090
container one we call into the first

00:17:57,549 --> 00:18:08,669
ones method so we say we have this

00:18:03,090 --> 00:18:10,990
wrapper dot internal dot foo essentially

00:18:08,669 --> 00:18:15,190
however as you see at the bottom

00:18:10,990 --> 00:18:18,970
basically when we use when we use a

00:18:15,190 --> 00:18:21,880
valid interface for this things work

00:18:18,970 --> 00:18:25,419
properly because our struct implements

00:18:21,880 --> 00:18:28,360
few correctly however in go and in many

00:18:25,419 --> 00:18:31,419
other languages on nil is a valid empty

00:18:28,360 --> 00:18:34,840
inter neil satisfies any interface and

00:18:31,419 --> 00:18:36,760
so nil in this case is actually of type

00:18:34,840 --> 00:18:38,919
interface it just doesn't actually

00:18:36,760 --> 00:18:43,389
implement foo and therefore when we

00:18:38,919 --> 00:18:48,610
attempt to call to call foo on nil it

00:18:43,389 --> 00:18:50,740
compiles but we get a panic so

00:18:48,610 --> 00:18:52,929
essentially there are two other

00:18:50,740 --> 00:18:55,570
mechanism two main mechanisms that we

00:18:52,929 --> 00:19:01,029
can use in languages that that don't

00:18:55,570 --> 00:19:03,220
support option so one is when one is on

00:19:01,029 --> 00:19:05,440
get and that is to return basically a

00:19:03,220 --> 00:19:10,600
bool this is assuming that your language

00:19:05,440 --> 00:19:12,850
has has like tuple types or multi return

00:19:10,600 --> 00:19:15,159
values otherwise you're kind of stuck

00:19:12,850 --> 00:19:16,750
with the second option and then the

00:19:15,159 --> 00:19:21,490
second option is to use the null object

00:19:16,750 --> 00:19:24,490
pattern which basically is well I'll

00:19:21,490 --> 00:19:25,809
show you in a second and so these partly

00:19:24,490 --> 00:19:27,970
are dependent on what language you're

00:19:25,809 --> 00:19:30,250
using since again not all languages

00:19:27,970 --> 00:19:34,480
support like tuples or multi return

00:19:30,250 --> 00:19:38,409
values also partly dependent on on how

00:19:34,480 --> 00:19:42,880
you want your your client to consume it

00:19:38,409 --> 00:19:46,720
so we look at examples of both here this

00:19:42,880 --> 00:19:47,450
one this one is using the first one

00:19:46,720 --> 00:19:50,720
where

00:19:47,450 --> 00:19:55,210
Mensah don't get by by representing

00:19:50,720 --> 00:19:58,550
whether or not it existed with a pool so

00:19:55,210 --> 00:20:01,490
essentially in here we check on the

00:19:58,550 --> 00:20:05,780
getter if the thing is nil and if it is

00:20:01,490 --> 00:20:08,510
your turn basically a nil value as well

00:20:05,780 --> 00:20:14,210
as false and then when we actually use

00:20:08,510 --> 00:20:16,760
it we say hi like that we say if the

00:20:14,210 --> 00:20:19,340
thing actually exists then use it

00:20:16,760 --> 00:20:23,060
otherwise just carry on and so in this

00:20:19,340 --> 00:20:26,120
case the program will print hello

00:20:23,060 --> 00:20:27,860
response and then just nothing else it

00:20:26,120 --> 00:20:30,400
doesn't even print like an empty line or

00:20:27,860 --> 00:20:33,860
something it just doesn't hit that line

00:20:30,400 --> 00:20:36,440
in more realistic scenarios sometimes

00:20:33,860 --> 00:20:38,960
knowing that the thing is that the thing

00:20:36,440 --> 00:20:41,330
wasn't ever set it's useful that's why

00:20:38,960 --> 00:20:44,510
in rest we up we often like having

00:20:41,330 --> 00:20:49,940
having option rather than using the null

00:20:44,510 --> 00:20:52,280
the null object pattern and then the

00:20:49,940 --> 00:20:55,910
other option is this null object pattern

00:20:52,280 --> 00:20:58,010
where now we have a no abstract and on

00:20:55,910 --> 00:21:00,560
the sutter or in this case and the

00:20:58,010 --> 00:21:03,620
constructor we check to see if the thing

00:21:00,560 --> 00:21:05,840
would be nil and in that case fill

00:21:03,620 --> 00:21:08,300
basically back fill it in with a no op

00:21:05,840 --> 00:21:11,180
thing so no op in the sense that like

00:21:08,300 --> 00:21:14,000
it'll comply with all the interfaces and

00:21:11,180 --> 00:21:16,190
so on without blowing up but it doesn't

00:21:14,000 --> 00:21:19,970
do anything interesting so in this case

00:21:16,190 --> 00:21:23,420
for example it prints an empty line on

00:21:19,970 --> 00:21:27,680
or it returns an empty string on foo go

00:21:23,420 --> 00:21:31,040
doesn't have a go doesn't support like

00:21:27,680 --> 00:21:35,690
nil for for Strings so empty string is

00:21:31,040 --> 00:21:38,570
all you guys and so in some ways using

00:21:35,690 --> 00:21:40,010
this one is nicer since it's shorter on

00:21:38,570 --> 00:21:42,730
the other hand you don't know how to

00:21:40,010 --> 00:21:46,400
distinguish between empty string and

00:21:42,730 --> 00:21:51,170
unset so it really just depends on your

00:21:46,400 --> 00:21:54,290
use case as well again as your language

00:21:51,170 --> 00:22:00,800
and essentially there again is where the

00:21:54,290 --> 00:22:03,920
nil where the no op gets provided then

00:22:00,800 --> 00:22:06,470
the Bor Oh tracker so I know that

00:22:03,920 --> 00:22:07,910
there's a heart here and we all have

00:22:06,470 --> 00:22:11,060
probably struggled with the Baro checker

00:22:07,910 --> 00:22:13,970
at some point but you know it's kind of

00:22:11,060 --> 00:22:16,490
our frenemy it's there to help us at the

00:22:13,970 --> 00:22:19,580
end of the day and even if it means that

00:22:16,490 --> 00:22:22,610
sometimes writing the code is is

00:22:19,580 --> 00:22:27,650
trickier means that running it is a lot

00:22:22,610 --> 00:22:30,200
easier so here again don't mean to be

00:22:27,650 --> 00:22:31,850
picking you on go it just was convenient

00:22:30,200 --> 00:22:35,930
since its language I personally write a

00:22:31,850 --> 00:22:40,310
fair amount and it also is tight here's

00:22:35,930 --> 00:22:43,390
a little program where basically half of

00:22:40,310 --> 00:22:48,740
the time it attempts to append something

00:22:43,390 --> 00:22:51,140
to an array in a what's called a go

00:22:48,740 --> 00:22:53,570
routine so basically you know not a

00:22:51,140 --> 00:22:59,810
thread but like a green thread type

00:22:53,570 --> 00:23:04,150
thing however goes slices or rays are

00:22:59,810 --> 00:23:07,610
not tight are not thread safe and so

00:23:04,150 --> 00:23:10,700
this part this part will give you some

00:23:07,610 --> 00:23:14,540
funkiness know the go hat the go

00:23:10,700 --> 00:23:16,820
compiler has a runtime race detector but

00:23:14,540 --> 00:23:19,460
it's only runtime so here like if you

00:23:16,820 --> 00:23:21,140
build if you build the program with the

00:23:19,460 --> 00:23:23,510
race detector on it thinks that

00:23:21,140 --> 00:23:25,910
everything is hunky-dory we got a nice

00:23:23,510 --> 00:23:28,430
exit zero it thought the program was

00:23:25,910 --> 00:23:31,250
great when we actually attempt to run it

00:23:28,430 --> 00:23:33,640
with the race detector half the time we

00:23:31,250 --> 00:23:38,300
get this where it finds the data race

00:23:33,640 --> 00:23:39,920
the other time we don't have any

00:23:38,300 --> 00:23:43,670
complaints we just have our nice little

00:23:39,920 --> 00:23:46,430
empty array also in here there's kind of

00:23:43,670 --> 00:23:48,260
an extra data race where since it

00:23:46,430 --> 00:23:53,810
doesn't actually wait for the go routine

00:23:48,260 --> 00:23:56,360
to complete even when it does I love

00:23:53,810 --> 00:23:59,890
even when it does detect the data race

00:23:56,360 --> 00:24:02,860
it also doesn't successfully append it

00:23:59,890 --> 00:24:08,560
time essentially the main doesn't wait

00:24:02,860 --> 00:24:12,040
for that girl routine to complete now

00:24:08,560 --> 00:24:15,870
compare this to rust where the naive

00:24:12,040 --> 00:24:19,900
version would be you have again a vac of

00:24:15,870 --> 00:24:22,330
events and you attempt to push that you

00:24:19,900 --> 00:24:25,900
attempt to push something in there into

00:24:22,330 --> 00:24:27,670
there in a thread and I know that that

00:24:25,900 --> 00:24:32,230
that's maybe not the prettiest way of

00:24:27,670 --> 00:24:35,980
checking to see if the time is even but

00:24:32,230 --> 00:24:37,570
it was way um could have also probably

00:24:35,980 --> 00:24:43,270
just thrown in a ranch too or something

00:24:37,570 --> 00:24:47,290
but anyway this doesn't compile we get

00:24:43,270 --> 00:24:50,950
nice set of errors things we've all

00:24:47,290 --> 00:24:53,710
probably seen before basically where the

00:24:50,950 --> 00:24:56,890
compiler helpfully tells us hey there's

00:24:53,710 --> 00:24:59,770
a problem here's how like here's where

00:24:56,890 --> 00:25:05,200
it is and here's how you might be able

00:24:59,770 --> 00:25:09,580
to fix it and so essentially if you only

00:25:05,200 --> 00:25:13,930
use type safe threads or methods things

00:25:09,580 --> 00:25:17,590
become happier so now back to rust if we

00:25:13,930 --> 00:25:20,080
use an arc and mutex and just was trying

00:25:17,590 --> 00:25:24,420
to omit the import statements so that

00:25:20,080 --> 00:25:28,930
things should be bigger font in here

00:25:24,420 --> 00:25:31,870
then we then now this program compiles

00:25:28,930 --> 00:25:37,660
and is safe there's no longer a data

00:25:31,870 --> 00:25:42,130
race goes sorry if that's hard to read

00:25:37,660 --> 00:25:46,210
up back basically I made a thread safe

00:25:42,130 --> 00:25:49,020
inch slice again they don't have

00:25:46,210 --> 00:25:51,670
generics right now so bear with me um

00:25:49,020 --> 00:25:55,990
but basically in here whenever you're

00:25:51,670 --> 00:25:59,140
attempting to append it grabs a lock and

00:25:55,990 --> 00:26:01,450
when you are attempting to to read from

00:25:59,140 --> 00:26:04,260
it or just grab the string in this case

00:26:01,450 --> 00:26:07,600
the string of fight version it again

00:26:04,260 --> 00:26:10,540
sets a read lock

00:26:07,600 --> 00:26:14,050
and now this is safe its Cruiser but

00:26:10,540 --> 00:26:15,790
it's safe so here we can see that with

00:26:14,050 --> 00:26:18,580
the race detector on we were able to

00:26:15,790 --> 00:26:24,400
successfully print both the empty and

00:26:18,580 --> 00:26:26,800
non-empty versions so in short thinking

00:26:24,400 --> 00:26:28,210
of things in terms of class fixes can

00:26:26,800 --> 00:26:30,640
really help you when you are actually

00:26:28,210 --> 00:26:32,020
writing rust because the compiler does

00:26:30,640 --> 00:26:33,220
it for you

00:26:32,020 --> 00:26:36,340
but even when you're writing other

00:26:33,220 --> 00:26:38,020
things other languages you can still

00:26:36,340 --> 00:26:40,920
basically treat some of the rust

00:26:38,020 --> 00:26:43,800
compiler compiler niceties as

00:26:40,920 --> 00:26:46,770
conventions and attempt to kind of

00:26:43,800 --> 00:26:50,920
backfill your own patterns for runtime

00:26:46,770 --> 00:26:54,130
and then you can go to your team and say

00:26:50,920 --> 00:26:57,550
hey we're using all these patterns

00:26:54,130 --> 00:27:00,490
they're better than having runtime

00:26:57,550 --> 00:27:04,060
errors but there's still conventions

00:27:00,490 --> 00:27:06,910
what if we had the compiler do it for us

00:27:04,060 --> 00:27:10,980
and then your team can become that much

00:27:06,910 --> 00:27:15,860
more powerful thank you

00:27:10,980 --> 00:27:29,150
[Applause]

00:27:15,860 --> 00:27:29,150

YouTube URL: https://www.youtube.com/watch?v=8rlai-F-_1o


