Title: RustConf 2019 - Taking Constant Evaluation to the Limit by Oliver Schneider
Publication date: 2019-09-16
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Taking Constant Evaluation to the Limit by Oliver Schneider

Have you ever wanted to write a static with a complex initial value? Are you programming microcontrollers? Do you want to run as little code as possible at runtime or are you trying to reduce your memory footprint? If you answered yes to any of these questions, then you probably want to evaluate all-the-thingsâ„¢ at compile-time with a constant evaluator.

This talk will focus on explaining the inner workings of the new theoretically unrestricted constant evaluator in rustc (nicknamed Miri for "MIR interpreter") and give a short outlook on the future features Miri will enable in the Rust language.
Captions: 
	00:00:08,770 --> 00:00:15,680
[Music]

00:00:16,760 --> 00:00:26,300
hi everyone I'm oli so you might have

00:00:22,070 --> 00:00:29,020
seen this logo that's me and I work for

00:00:26,300 --> 00:00:31,580
kasnian so we take security research

00:00:29,020 --> 00:00:33,200
like multi-party computation and

00:00:31,580 --> 00:00:35,120
homomorphic crypto and like put it into

00:00:33,200 --> 00:00:37,460
products that actually protect your

00:00:35,120 --> 00:00:39,890
privacy so yeah trying to do cool stuff

00:00:37,460 --> 00:00:43,370
here anyway you're here for constables

00:00:39,890 --> 00:00:46,910
oh stop talking about me why constable

00:00:43,370 --> 00:00:48,530
well I guess everybody has used

00:00:46,910 --> 00:00:50,900
constables somewhere maybe for an array

00:00:48,530 --> 00:00:53,570
links or something so usually use

00:00:50,900 --> 00:00:55,309
constable to save resources you want to

00:00:53,570 --> 00:00:57,050
make sure that something happens at

00:00:55,309 --> 00:00:59,150
compile time instead of at runtime so he

00:00:57,050 --> 00:01:01,129
just like especially if I'm embedded you

00:00:59,150 --> 00:01:03,110
don't have many resources at all so you

00:01:01,129 --> 00:01:04,430
don't really want to use them up other

00:01:03,110 --> 00:01:06,380
things that he can do is like you can

00:01:04,430 --> 00:01:08,180
reduce some types of some trickery like

00:01:06,380 --> 00:01:12,860
sometimes you end up like working around

00:01:08,180 --> 00:01:16,729
weird weird things so you're working

00:01:12,860 --> 00:01:18,290
with the system to get it to do like the

00:01:16,729 --> 00:01:20,330
type system get something to do that you

00:01:18,290 --> 00:01:22,460
want to do but it's very hard to do so

00:01:20,330 --> 00:01:24,410
you're doing like weird tricks and it

00:01:22,460 --> 00:01:25,850
just gets annoying so constable saves

00:01:24,410 --> 00:01:28,970
you from that because it just allows you

00:01:25,850 --> 00:01:31,640
to write stuff in real rest code so it

00:01:28,970 --> 00:01:34,670
can do whatever you you were previously

00:01:31,640 --> 00:01:36,140
doing comp in complex ways also you can

00:01:34,670 --> 00:01:38,720
prove constraints at compile time so you

00:01:36,140 --> 00:01:39,920
can make your program secure by ensuring

00:01:38,720 --> 00:01:41,720
that some things that simply check the

00:01:39,920 --> 00:01:45,280
compile time error out at compile time

00:01:41,720 --> 00:01:49,610
and most importantly because we can

00:01:45,280 --> 00:01:51,170
that's my reason so there's a bunch of

00:01:49,610 --> 00:01:52,430
levels of constant evaluation that you

00:01:51,170 --> 00:01:54,410
can get at so there's like the

00:01:52,430 --> 00:01:55,880
omnipotent level you know it is from

00:01:54,410 --> 00:01:57,440
scripting languages you have an invalid

00:01:55,880 --> 00:01:59,570
function you can just involve anything

00:01:57,440 --> 00:02:01,700
and you get a result from it and you can

00:01:59,570 --> 00:02:03,200
just use that at compile time and then

00:02:01,700 --> 00:02:06,020
use the values and the during

00:02:03,200 --> 00:02:08,119
compilation so that's like omnipotent

00:02:06,020 --> 00:02:09,500
like in crazy levels because you can do

00:02:08,119 --> 00:02:11,150
anything in there you can open that for

00:02:09,500 --> 00:02:13,069
connections and like connect to whatever

00:02:11,150 --> 00:02:14,599
database somewhere and then do weird

00:02:13,069 --> 00:02:16,099
stuff on the internet that's not what

00:02:14,599 --> 00:02:18,260
you should do it in console but you

00:02:16,099 --> 00:02:20,060
could then use restricted omnipotent

00:02:18,260 --> 00:02:20,780
which is like well you're not allowed to

00:02:20,060 --> 00:02:22,459
do Network

00:02:20,780 --> 00:02:24,349
to the internet because that's kind of

00:02:22,459 --> 00:02:26,180
yeah weird so let's not do that

00:02:24,349 --> 00:02:27,170
and then there's inherently limited

00:02:26,180 --> 00:02:29,090
which is basically a glorified

00:02:27,170 --> 00:02:30,500
calculator and allows you just to like

00:02:29,090 --> 00:02:34,820
compute some values and

00:02:30,500 --> 00:02:37,700
and so we are right now at be very

00:02:34,820 --> 00:02:40,250
restricted omnipotent so big shout out

00:02:37,700 --> 00:02:42,890
to Scott Olsen who wrote the so called

00:02:40,250 --> 00:02:45,440
Mira Mira interpreter which is the BAE

00:02:42,890 --> 00:02:48,890
thing that we are using in Constable in

00:02:45,440 --> 00:02:50,930
rusty it is basically all-powerful it is

00:02:48,890 --> 00:02:53,540
a virtual machine interpreting rest code

00:02:50,930 --> 00:02:55,160
it is a virtual machine in all of the

00:02:53,540 --> 00:02:59,740
definition of a virtual machine you can

00:02:55,160 --> 00:03:02,830
run anything in there theoretically and

00:02:59,740 --> 00:03:05,990
we want to go to restricted omnipotent

00:03:02,830 --> 00:03:08,120
so we want to keep some restrictions

00:03:05,990 --> 00:03:09,980
around we don't want to run anything to

00:03:08,120 --> 00:03:11,900
be possible at compile time and there's

00:03:09,980 --> 00:03:14,900
a bunch of reasons for that so first of

00:03:11,900 --> 00:03:17,180
all soundness if you allow anything at

00:03:14,900 --> 00:03:19,880
compile time you get some weird issues

00:03:17,180 --> 00:03:21,260
where like you compute a value over

00:03:19,880 --> 00:03:22,940
there and you compute it over there and

00:03:21,260 --> 00:03:24,620
it's suddenly not the same value even

00:03:22,940 --> 00:03:26,390
though like the logic is entirely the

00:03:24,620 --> 00:03:29,450
same this happens for example if you

00:03:26,390 --> 00:03:31,550
have random number generators as like at

00:03:29,450 --> 00:03:33,680
compile time that's a bad idea

00:03:31,550 --> 00:03:36,410
then again though that all boils down

00:03:33,680 --> 00:03:38,480
basically to determinism you want your

00:03:36,410 --> 00:03:39,920
constants to always be the same thing so

00:03:38,480 --> 00:03:41,300
if you have a constant and you look at

00:03:39,920 --> 00:03:44,680
it and you look at it later again it

00:03:41,300 --> 00:03:47,030
should still be the same constant and

00:03:44,680 --> 00:03:49,520
finally like for us implementing

00:03:47,030 --> 00:03:51,290
constant evaluators we don't want this

00:03:49,520 --> 00:03:52,760
to get more complex entities it's like

00:03:51,290 --> 00:03:54,980
already a thousand lines of code inside

00:03:52,760 --> 00:03:57,200
a rest compiler that's pretty big for

00:03:54,980 --> 00:04:01,340
just a constant evaluator but we'll get

00:03:57,200 --> 00:04:03,380
to that later so we want some

00:04:01,340 --> 00:04:06,410
restrictions for example we don't want

00:04:03,380 --> 00:04:07,670
mutation of global state mutation of

00:04:06,410 --> 00:04:09,920
global state essentially boils down to

00:04:07,670 --> 00:04:11,480
random number generators because you can

00:04:09,920 --> 00:04:13,420
have some global variable and you're

00:04:11,480 --> 00:04:15,560
mutating like you're accessing definite

00:04:13,420 --> 00:04:17,690
differend them or something getting

00:04:15,560 --> 00:04:22,310
random numbers whatnot mutating global

00:04:17,690 --> 00:04:24,950
state is a bad idea because you get like

00:04:22,310 --> 00:04:27,680
the initializer in another sized

00:04:24,950 --> 00:04:30,290
initialization order problem that you

00:04:27,680 --> 00:04:33,200
know from other languages so yeah no

00:04:30,290 --> 00:04:34,160
global state we don't want any non

00:04:33,200 --> 00:04:36,980
determinism

00:04:34,160 --> 00:04:38,780
so you're not allowed to get check the

00:04:36,980 --> 00:04:41,360
bytes from some pointers because like

00:04:38,780 --> 00:04:42,919
pointers to some things in memory like

00:04:41,360 --> 00:04:43,639
they'd change the address between

00:04:42,919 --> 00:04:46,580
compilation

00:04:43,639 --> 00:04:48,680
and the order is not defined that the

00:04:46,580 --> 00:04:50,419
actual addresses are not defined so we

00:04:48,680 --> 00:04:53,389
don't really want that kind of things

00:04:50,419 --> 00:04:54,800
and we also don't want Cindy again back

00:04:53,389 --> 00:04:56,719
because it's very complex to implement

00:04:54,800 --> 00:04:59,150
like thousands and thousands of similar

00:04:56,719 --> 00:05:00,620
instructions so there are some

00:04:59,150 --> 00:05:03,099
restrictions that we just want to keep

00:05:00,620 --> 00:05:05,779
around and we have to work around those

00:05:03,099 --> 00:05:09,199
but we have loads of unnecessary

00:05:05,779 --> 00:05:11,150
restrictions so one thing I often get is

00:05:09,199 --> 00:05:12,919
like why can't I have like new I mean

00:05:11,150 --> 00:05:15,229
BEC new doesn't even allocate it doesn't

00:05:12,919 --> 00:05:17,779
do anything it's like just like create

00:05:15,229 --> 00:05:19,610
some vector that has no element so why

00:05:17,779 --> 00:05:22,340
can't I have this well there are some

00:05:19,610 --> 00:05:24,169
problems with with that because

00:05:22,340 --> 00:05:25,550
internally it uses things that are a

00:05:24,169 --> 00:05:25,939
little bit more complex than doing

00:05:25,550 --> 00:05:27,680
nothing

00:05:25,939 --> 00:05:29,960
and those little bit more complex things

00:05:27,680 --> 00:05:31,610
they aren't really possible right now so

00:05:29,960 --> 00:05:34,520
but we're working on that there's no

00:05:31,610 --> 00:05:36,949
Canarsie for that then another thing is

00:05:34,520 --> 00:05:40,219
box new vector so anything that kind of

00:05:36,949 --> 00:05:42,169
like needs to heap so we want heap

00:05:40,219 --> 00:05:43,969
during conservation I'll get to that

00:05:42,169 --> 00:05:46,520
later and explain in detail how that is

00:05:43,969 --> 00:05:49,099
happening because it's actually a very

00:05:46,520 --> 00:05:53,000
hot topic because C++ just got heap

00:05:49,099 --> 00:05:56,180
during constable 4 to some 20 so but

00:05:53,000 --> 00:05:58,729
yeah so loops and if conditions so any

00:05:56,180 --> 00:06:01,849
kind of branching we can't do right now

00:05:58,729 --> 00:06:03,349
and we want to get rid of them and cool

00:06:01,849 --> 00:06:04,849
update yesterday morning and you pull

00:06:03,349 --> 00:06:06,889
request was open that actually will help

00:06:04,849 --> 00:06:08,509
us get there and another one is in the

00:06:06,889 --> 00:06:11,899
work so I'm pretty positive we can have

00:06:08,509 --> 00:06:14,060
this in the next month well reverie

00:06:11,899 --> 00:06:16,029
unstably and not for anybody using it

00:06:14,060 --> 00:06:19,339
unstable but like it'll work at least

00:06:16,029 --> 00:06:21,349
then calling trade methods you cannot

00:06:19,339 --> 00:06:24,169
call a trade method in constable right

00:06:21,349 --> 00:06:25,550
now we have concept and since the 2018

00:06:24,169 --> 00:06:28,430
edition so you can define your own

00:06:25,550 --> 00:06:30,050
consequence but you cannot call trade

00:06:28,430 --> 00:06:32,719
methods you did there's no way to

00:06:30,050 --> 00:06:35,389
specify those bounds so there's an open

00:06:32,719 --> 00:06:36,919
RFC for that and yeah once we have that

00:06:35,389 --> 00:06:38,569
and we can implement it and then we'll

00:06:36,919 --> 00:06:40,839
have that so this is work in progress

00:06:38,569 --> 00:06:43,580
but we're getting there

00:06:40,839 --> 00:06:46,460
format a space Atika lamination of

00:06:43,580 --> 00:06:47,990
everything that you saw above so we need

00:06:46,460 --> 00:06:50,509
trade methods we need if we need loop

00:06:47,990 --> 00:06:53,539
and we need heap allocations and then

00:06:50,509 --> 00:06:55,399
you will be able to call format and when

00:06:53,539 --> 00:06:57,440
you can call format you can basically

00:06:55,399 --> 00:06:59,300
like end up using like all

00:06:57,440 --> 00:07:02,660
thirty because that just uses the same

00:06:59,300 --> 00:07:05,300
stuff so my goal is personally to get

00:07:02,660 --> 00:07:07,220
Sri at compile time so you take like a

00:07:05,300 --> 00:07:09,320
configuration file for like a Tamil file

00:07:07,220 --> 00:07:10,430
on your source and then you run it

00:07:09,320 --> 00:07:12,050
through surly at compile time and you

00:07:10,430 --> 00:07:14,180
get struck at compile time with all your

00:07:12,050 --> 00:07:16,250
configuration and you get an error at

00:07:14,180 --> 00:07:17,930
compile time telling you that the file

00:07:16,250 --> 00:07:19,460
was bad instead of like getting it

00:07:17,930 --> 00:07:21,920
during run time and having your product

00:07:19,460 --> 00:07:24,230
crashed somewhere so the last

00:07:21,920 --> 00:07:26,450
restriction that is basically

00:07:24,230 --> 00:07:28,420
unnecessary is that we're not really

00:07:26,450 --> 00:07:31,370
allowing you to do I'm safe right now

00:07:28,420 --> 00:07:34,870
you can do unsafe but only if the unsafe

00:07:31,370 --> 00:07:34,870
contains nothing that is actually unsafe

00:07:37,630 --> 00:07:42,200
I'll get to unsafe later

00:07:39,560 --> 00:07:45,860
ant if is pretty cool during comfortable

00:07:42,200 --> 00:07:47,810
and yeah I have some examples what we're

00:07:45,860 --> 00:07:49,580
gonna do there but everybody here

00:07:47,810 --> 00:07:51,470
probably came here not to hear what you

00:07:49,580 --> 00:07:53,930
can't do you want to hear what's gonna

00:07:51,470 --> 00:07:59,330
happen how it's gonna happen and so

00:07:53,930 --> 00:08:01,490
let's continue things that like aren't

00:07:59,330 --> 00:08:04,010
constable but well they are now so

00:08:01,490 --> 00:08:06,260
Siouxland just got constable like

00:08:04,010 --> 00:08:08,480
yesterday it's not nor yet but like it's

00:08:06,260 --> 00:08:10,100
working and so it's empty and all these

00:08:08,480 --> 00:08:11,690
kinds of functions so Stephan standard

00:08:10,100 --> 00:08:14,060
Larry is getting constable all the time

00:08:11,690 --> 00:08:15,080
basically if you want something to be

00:08:14,060 --> 00:08:17,210
canceled I'll just open it an issue

00:08:15,080 --> 00:08:18,770
about it and like we'll we'll fix it

00:08:17,210 --> 00:08:21,230
like most of the things can be constable

00:08:18,770 --> 00:08:23,660
nowadays so conce offense so we can just

00:08:21,230 --> 00:08:25,190
do that so panic panic is constant and

00:08:23,660 --> 00:08:27,290
it's pretty useless because you don't

00:08:25,190 --> 00:08:29,210
know if so it's just gonna panic at

00:08:27,290 --> 00:08:32,300
content there all the time which is an

00:08:29,210 --> 00:08:34,370
error but like hey it works

00:08:32,300 --> 00:08:36,080
you can have let let moot so you can

00:08:34,370 --> 00:08:37,610
actually like write some pretty linear

00:08:36,080 --> 00:08:39,830
code and you can have to be structuring

00:08:37,610 --> 00:08:41,719
in there so you can create things and

00:08:39,830 --> 00:08:45,320
destructured them again and so on so

00:08:41,719 --> 00:08:46,760
that works and there's all kinds of

00:08:45,320 --> 00:08:49,250
functions on you to your triplet

00:08:46,760 --> 00:08:51,430
integers that are constant now so you

00:08:49,250 --> 00:08:55,190
you have like overflowing and wrapping

00:08:51,430 --> 00:08:57,140
operations you're like what's it count

00:08:55,190 --> 00:08:59,780
zeros count ones whatever like there's

00:08:57,140 --> 00:09:01,490
loads of operations on integers that are

00:08:59,780 --> 00:09:03,470
now consonant and you can use them and

00:09:01,490 --> 00:09:05,000
there's probably more that we could make

00:09:03,470 --> 00:09:06,530
constant so if there's something you

00:09:05,000 --> 00:09:08,270
know you're missing just open an issue

00:09:06,530 --> 00:09:10,880
about it if if you're telling us about

00:09:08,270 --> 00:09:11,030
it then we can probably fix it but most

00:09:10,880 --> 00:09:13,490
of

00:09:11,030 --> 00:09:15,770
shortly but probably a lot of people

00:09:13,490 --> 00:09:18,110
really want is pointer offset from you

00:09:15,770 --> 00:09:21,620
may ask why do you want that if you were

00:09:18,110 --> 00:09:25,340
to offset off its like to calculate the

00:09:21,620 --> 00:09:27,830
offset of a field instruct to the base

00:09:25,340 --> 00:09:30,770
of the truck so you may wonder why you

00:09:27,830 --> 00:09:32,840
need that well it is used in so many

00:09:30,770 --> 00:09:34,670
kinds of abstractions where you're doing

00:09:32,840 --> 00:09:39,740
some some neat hackery at compile time

00:09:34,670 --> 00:09:42,500
and this feature is constant now and we

00:09:39,740 --> 00:09:46,010
can use it again on nightly obviously

00:09:42,500 --> 00:09:48,200
but like it works so these are kind of

00:09:46,010 --> 00:09:50,840
things like library wise that we get but

00:09:48,200 --> 00:09:53,720
there's more than that you can basically

00:09:50,840 --> 00:09:55,340
end up making anything Const of n like

00:09:53,720 --> 00:09:57,110
literally you pointed it and we can make

00:09:55,340 --> 00:09:58,610
it constant there's very few things that

00:09:57,110 --> 00:10:00,380
we can I give you restrictions earlier

00:09:58,610 --> 00:10:02,150
everything outside is restrictions make

00:10:00,380 --> 00:10:05,840
it constant tell us about it if you want

00:10:02,150 --> 00:10:08,000
it will make it constant so what kind of

00:10:05,840 --> 00:10:09,440
stuff is being happening as console fans

00:10:08,000 --> 00:10:11,240
now I already told you about looping if

00:10:09,440 --> 00:10:12,620
there's accepted RC for that so this is

00:10:11,240 --> 00:10:15,500
just like implementation work and it's

00:10:12,620 --> 00:10:17,570
happening right now so there's some open

00:10:15,500 --> 00:10:20,780
RFC's which give us like calling trade

00:10:17,570 --> 00:10:23,990
methods and vacuu and so on and this is

00:10:20,780 --> 00:10:25,880
gonna happen sometimes sooner I guess we

00:10:23,990 --> 00:10:30,860
don't have an RC it for heap allocations

00:10:25,880 --> 00:10:33,500
once we have CR RC through for for trade

00:10:30,860 --> 00:10:35,900
methods then we'll go to the heap

00:10:33,500 --> 00:10:37,640
allocations and with HEPA locations

00:10:35,900 --> 00:10:39,020
people can start doing all kinds of

00:10:37,640 --> 00:10:41,150
crazy things you can start allocating

00:10:39,020 --> 00:10:42,500
graphs at compile time and just putting

00:10:41,150 --> 00:10:45,080
them in a static and you have them

00:10:42,500 --> 00:10:46,340
available later and the computation is

00:10:45,080 --> 00:10:47,510
like all happening at compile time or

00:10:46,340 --> 00:10:48,980
perfect hashmaps

00:10:47,510 --> 00:10:50,810
well you computer perfect hash map at

00:10:48,980 --> 00:10:52,580
compile time right now this is all like

00:10:50,810 --> 00:10:54,740
procedural macros and all kinds of other

00:10:52,580 --> 00:10:56,720
black magic but then you can just run

00:10:54,740 --> 00:10:58,610
your normal code that you would run at

00:10:56,720 --> 00:11:01,460
runtime just run it at compile time put

00:10:58,610 --> 00:11:03,440
in a static and you're done and of

00:11:01,460 --> 00:11:05,990
course I already talked about unsafe C

00:11:03,440 --> 00:11:07,490
unsafe shenanigans and there's lots of

00:11:05,990 --> 00:11:11,990
fun section again so there's super super

00:11:07,490 --> 00:11:15,620
fun but before we go into all of these

00:11:11,990 --> 00:11:17,800
details let's give an example about heap

00:11:15,620 --> 00:11:20,180
allocations because he fell occasions

00:11:17,800 --> 00:11:24,590
especially in the presence of C++

00:11:20,180 --> 00:11:26,450
getting isn't 2020 a very hot topic so

00:11:24,590 --> 00:11:28,970
keep allocations have lots of curious

00:11:26,450 --> 00:11:31,190
problems most of them boiled down to

00:11:28,970 --> 00:11:34,460
this you have a constant and that

00:11:31,190 --> 00:11:35,990
constant is of type string however you

00:11:34,460 --> 00:11:40,160
get that constant I don't care like it's

00:11:35,990 --> 00:11:41,690
you somehow computer constant and then

00:11:40,160 --> 00:11:44,630
you use that constant you say let x

00:11:41,690 --> 00:11:47,660
equals foo and then at some point fruit

00:11:44,630 --> 00:11:51,080
X is being dropped the runners go up you

00:11:47,660 --> 00:11:53,150
drop it explicitly whatever the question

00:11:51,080 --> 00:11:56,990
is what happens at this assignment like

00:11:53,150 --> 00:11:59,270
X equals foo usually when we didn't have

00:11:56,990 --> 00:12:01,520
heap allocations there was always a very

00:11:59,270 --> 00:12:03,350
simple solution we just bit copied a

00:12:01,520 --> 00:12:06,890
constant into X and then we have the

00:12:03,350 --> 00:12:10,430
value right there but if we bit copy the

00:12:06,890 --> 00:12:12,890
constant string object we are referring

00:12:10,430 --> 00:12:15,140
to a static heap allocation this is like

00:12:12,890 --> 00:12:17,779
in static memory this is this is in your

00:12:15,140 --> 00:12:19,520
in your data section somewhere where you

00:12:17,779 --> 00:12:21,260
can't get it back out isn't you can't

00:12:19,520 --> 00:12:23,360
deallocate it it was never allocated

00:12:21,260 --> 00:12:25,490
this just exists like a static would be

00:12:23,360 --> 00:12:28,970
like calling free on a static as like

00:12:25,490 --> 00:12:31,730
undefined behavior so this is illegal

00:12:28,970 --> 00:12:33,350
code we can't have this so the question

00:12:31,730 --> 00:12:34,880
is what kind of things are K and what

00:12:33,350 --> 00:12:38,210
kind of things are not okay and this is

00:12:34,880 --> 00:12:41,089
what the we could we were able to take a

00:12:38,210 --> 00:12:44,150
lot of information out of the C++

00:12:41,089 --> 00:12:46,250
discussions about heap allocations in

00:12:44,150 --> 00:12:48,920
C++ this is illegal you're not even

00:12:46,250 --> 00:12:51,140
allowed to compile the Const definition

00:12:48,920 --> 00:12:53,330
so it becomes foo string is jut not

00:12:51,140 --> 00:12:55,220
legal and we are not going to make it

00:12:53,330 --> 00:12:58,220
legal either because it has this obvious

00:12:55,220 --> 00:12:58,760
problem here so what kind of things are

00:12:58,220 --> 00:13:00,890
okay

00:12:58,760 --> 00:13:03,170
so as I showed you the first thing is

00:13:00,890 --> 00:13:05,600
bad but if you put the thing behind a

00:13:03,170 --> 00:13:07,310
reference suddenly it's okay because you

00:13:05,600 --> 00:13:10,730
can't move out of a reference and rest

00:13:07,310 --> 00:13:11,959
so anything behind a reference even if

00:13:10,730 --> 00:13:14,930
there's heap allocations in there

00:13:11,959 --> 00:13:17,120
it's basically fine you can just access

00:13:14,930 --> 00:13:18,800
this as and you can't move out of it you

00:13:17,120 --> 00:13:20,510
need to clone it and once you clone it

00:13:18,800 --> 00:13:21,680
you create a new heap allocation and

00:13:20,510 --> 00:13:24,500
everything is fine there's there's no

00:13:21,680 --> 00:13:27,080
problems there and even if you convert

00:13:24,500 --> 00:13:30,260
this to it's no problem

00:13:27,080 --> 00:13:31,520
because then it's just a it doesn't even

00:13:30,260 --> 00:13:33,800
show you that there's a heap allocation

00:13:31,520 --> 00:13:36,290
there and you can't move out of it

00:13:33,800 --> 00:13:38,330
anyway and any kind of other non heap

00:13:36,290 --> 00:13:40,220
types so if you have integers or

00:13:38,330 --> 00:13:42,140
custom structs or slit that don't have

00:13:40,220 --> 00:13:43,700
keep in there you can just put them

00:13:42,140 --> 00:13:46,550
directly in a constant and everything

00:13:43,700 --> 00:13:47,990
stays fine so this kind of setting where

00:13:46,550 --> 00:13:49,430
is something behind the reference is

00:13:47,990 --> 00:13:52,310
okay and something not behind the

00:13:49,430 --> 00:13:55,040
references but may be problematic maybe

00:13:52,310 --> 00:13:57,590
it reminds you of anything like it took

00:13:55,040 --> 00:13:59,720
us like two weeks to figure this out

00:13:57,590 --> 00:14:01,760
when we were like like sitting there and

00:13:59,720 --> 00:14:03,710
just discussing the whole time about all

00:14:01,760 --> 00:14:06,590
of the steep stuff and at some point

00:14:03,710 --> 00:14:09,200
somebody noticed well it's almost like

00:14:06,590 --> 00:14:11,750
sentencing it's like not quite

00:14:09,200 --> 00:14:14,810
sentencing but like we could create two

00:14:11,750 --> 00:14:16,430
new traits one is Const which means

00:14:14,810 --> 00:14:18,500
you're allowed to put it in a constant

00:14:16,430 --> 00:14:20,710
and the other thing is concept safe

00:14:18,500 --> 00:14:24,550
which means if it's behind a reference

00:14:20,710 --> 00:14:28,330
then you could put it in a constant so

00:14:24,550 --> 00:14:30,470
the ideas will create the system and

00:14:28,330 --> 00:14:32,030
we'll just do an unsafe employ

00:14:30,470 --> 00:14:33,950
constructs a four-string because we'll

00:14:32,030 --> 00:14:36,140
say we checked we check the

00:14:33,950 --> 00:14:38,240
implementation our string and we are

00:14:36,140 --> 00:14:40,340
sure we are very very sure you allow to

00:14:38,240 --> 00:14:41,330
put it behind the reference because once

00:14:40,340 --> 00:14:43,130
it's behind a reference the only thing

00:14:41,330 --> 00:14:45,260
you can do is clone it or turn it and

00:14:43,130 --> 00:14:47,000
just roll and just like work with the

00:14:45,260 --> 00:14:50,300
slice but like you can't do anything

00:14:47,000 --> 00:14:52,460
more than that so we have a system

00:14:50,300 --> 00:14:55,520
forward here and now comes the

00:14:52,460 --> 00:14:59,210
difference to C++ we are allowed to put

00:14:55,520 --> 00:15:00,860
heap allocations into constants as long

00:14:59,210 --> 00:15:05,030
as they are protected somehow behind

00:15:00,860 --> 00:15:06,980
references or something else and in C++

00:15:05,030 --> 00:15:08,660
they decided it's too dangerous we can't

00:15:06,980 --> 00:15:11,240
do it as because we can't possibly ever

00:15:08,660 --> 00:15:12,770
check that this will work out so the

00:15:11,240 --> 00:15:15,410
only time you can use heap allocations

00:15:12,770 --> 00:15:18,050
in C++ is during your computation

00:15:15,410 --> 00:15:21,140
compilation but the final product does

00:15:18,050 --> 00:15:25,520
not have any heap pointers even if you

00:15:21,140 --> 00:15:27,350
converted to an ampersand STR your if

00:15:25,520 --> 00:15:29,870
you do the same thing in C++ if it's a

00:15:27,350 --> 00:15:31,100
child pointer that came somewhere from a

00:15:29,870 --> 00:15:34,400
heap allocation you're not allowed to do

00:15:31,100 --> 00:15:35,720
that it's just forbidden but in rest we

00:15:34,400 --> 00:15:37,610
can do this because we have our awesome

00:15:35,720 --> 00:15:40,340
type system that has stuff like

00:15:37,610 --> 00:15:42,530
sentencing that we can now reuse for

00:15:40,340 --> 00:15:44,150
this kind of setting so we'll be able to

00:15:42,530 --> 00:15:46,520
do a lot more and we can do it safely we

00:15:44,150 --> 00:15:48,410
can do it completely safely as the user

00:15:46,520 --> 00:15:51,070
will never have to worry about it if it

00:15:48,410 --> 00:15:56,210
compiles it's fine to do

00:15:51,070 --> 00:15:59,630
and here's the example which will make

00:15:56,210 --> 00:16:01,580
all of this possible if it's concept

00:15:59,630 --> 00:16:04,580
safe this is the T bound consular safe

00:16:01,580 --> 00:16:06,910
here then you can make it con safe if

00:16:04,580 --> 00:16:09,200
you put it behind a reference so

00:16:06,910 --> 00:16:10,940
everything is being done for you as a

00:16:09,200 --> 00:16:13,010
user will never actually have to touch

00:16:10,940 --> 00:16:15,140
this is all happening in the standard

00:16:13,010 --> 00:16:16,940
library will expose it like send and

00:16:15,140 --> 00:16:19,130
swings so if you're doing some your own

00:16:16,940 --> 00:16:21,020
shenanigans you can just implement the

00:16:19,130 --> 00:16:24,920
appropriate unsafe trades and you'll be

00:16:21,020 --> 00:16:27,050
fine and so yeah we have a system now to

00:16:24,920 --> 00:16:30,320
get heap allocations there and this

00:16:27,050 --> 00:16:32,510
system it doesn't look very complex

00:16:30,320 --> 00:16:34,010
it isn't very complex and we are pretty

00:16:32,510 --> 00:16:35,360
positive we can get this through maybe

00:16:34,010 --> 00:16:39,500
in the next year that at least you have

00:16:35,360 --> 00:16:41,870
an on lightly and so we're not playing

00:16:39,500 --> 00:16:44,300
catch-up to C++ here anymore we are like

00:16:41,870 --> 00:16:45,980
on the racetrack just taking over not

00:16:44,300 --> 00:16:50,510
having taking over yet but like we're

00:16:45,980 --> 00:16:52,220
there okay so keep allocations now we're

00:16:50,510 --> 00:16:54,350
coming to unsafe unsafe is awesome

00:16:52,220 --> 00:16:57,380
because unsafe gives you a compile time

00:16:54,350 --> 00:16:59,560
undefined behavior the best thing I love

00:16:57,380 --> 00:16:59,560
it

00:17:01,060 --> 00:17:05,150
so indifferent behavior isn't really

00:17:03,350 --> 00:17:08,209
that problematic at compile-time because

00:17:05,150 --> 00:17:10,310
you just get an error but sometimes you

00:17:08,209 --> 00:17:12,800
don't get an error because we are not

00:17:10,310 --> 00:17:14,360
like we did we haven't taught self the

00:17:12,800 --> 00:17:16,579
halting problem yet so you can't really

00:17:14,360 --> 00:17:19,730
figure out if it is really undefined

00:17:16,579 --> 00:17:20,959
behavior so what we're doing is like we

00:17:19,730 --> 00:17:22,220
reserve the right if you do anything

00:17:20,959 --> 00:17:24,110
behavior we'll just break your code in

00:17:22,220 --> 00:17:26,900
the future but by breaking code I mean

00:17:24,110 --> 00:17:29,090
like will emit an error later so don't

00:17:26,900 --> 00:17:33,020
do undefined behavior it's not a good

00:17:29,090 --> 00:17:35,570
idea for example what is undefined

00:17:33,020 --> 00:17:37,580
behavior well give a boolean let's take

00:17:35,570 --> 00:17:42,680
the Y first you have a boolean and you

00:17:37,580 --> 00:17:44,930
transmute a 3-2 boolean a boolean memory

00:17:42,680 --> 00:17:47,900
representation is only allowed to be

00:17:44,930 --> 00:17:49,430
either 0 or 1 if it's a 3 that's

00:17:47,900 --> 00:17:52,190
undefined behavior because a bool with

00:17:49,430 --> 00:17:56,210
number 3 enter and there is just a legal

00:17:52,190 --> 00:17:59,780
value it makes no sense or if you cast a

00:17:56,210 --> 00:18:02,270
an integer to a row pointer and then the

00:17:59,780 --> 00:18:03,860
reference that and 1 then that may be

00:18:02,270 --> 00:18:05,060
okay if you're like on embedded and

00:18:03,860 --> 00:18:07,490
you're giving like the address of some

00:18:05,060 --> 00:18:09,950
hardware thingy but at compile time like

00:18:07,490 --> 00:18:11,540
what is on the address 42 like what I'm

00:18:09,950 --> 00:18:14,060
what am I supposed to do is a compiler

00:18:11,540 --> 00:18:15,560
developer like there's nothing there so

00:18:14,060 --> 00:18:17,480
these kind of things are undefined

00:18:15,560 --> 00:18:19,910
behavior there's lots more about like

00:18:17,480 --> 00:18:21,350
well all kinds of under sign to find

00:18:19,910 --> 00:18:23,360
behavior that you already know but like

00:18:21,350 --> 00:18:25,250
if you do any of these things

00:18:23,360 --> 00:18:26,660
they were like League if you compile

00:18:25,250 --> 00:18:28,460
time error telling you exactly why

00:18:26,660 --> 00:18:30,800
you're screwed up so you can actually

00:18:28,460 --> 00:18:32,210
use this a little bit to play around

00:18:30,800 --> 00:18:34,300
with undefined behavior to see like the

00:18:32,210 --> 00:18:36,920
boundaries of what what console I can do

00:18:34,300 --> 00:18:39,410
there's lots of fun things to do there

00:18:36,920 --> 00:18:41,120
so if other things are not 90 fine

00:18:39,410 --> 00:18:43,250
behavior but like you still need an say

00:18:41,120 --> 00:18:47,929
for for example here we create a

00:18:43,250 --> 00:18:50,360
reference to the number 42 we convert

00:18:47,929 --> 00:18:52,910
that to a row pointer and put that in a

00:18:50,360 --> 00:18:57,350
constant and then from another constant

00:18:52,910 --> 00:18:59,270
we dereference that raw pointer and this

00:18:57,350 --> 00:19:01,390
operation is basically the same

00:18:59,270 --> 00:19:04,130
operation we had in the previous slide

00:19:01,390 --> 00:19:05,330
where we would be referencing a pointer

00:19:04,130 --> 00:19:07,670
that was actually just an integer

00:19:05,330 --> 00:19:09,380
address but here it's an actual address

00:19:07,670 --> 00:19:11,800
it's an address to the number 42

00:19:09,380 --> 00:19:14,530
somewhere in the stack and

00:19:11,800 --> 00:19:16,390
in a static memory and we can be

00:19:14,530 --> 00:19:18,250
referenced at totally fine so the

00:19:16,390 --> 00:19:19,690
dereference operation is something we

00:19:18,250 --> 00:19:21,160
really want at compile time because

00:19:19,690 --> 00:19:25,690
people will be able to do these nice

00:19:21,160 --> 00:19:28,990
three mannequins so to do you be or not

00:19:25,690 --> 00:19:30,850
to be that is the question and the

00:19:28,990 --> 00:19:32,860
problem is there are much stricter rules

00:19:30,850 --> 00:19:34,840
at compile time because we just really

00:19:32,860 --> 00:19:36,880
can't figure out what you're doing here

00:19:34,840 --> 00:19:38,410
like if you put this pineapple variable

00:19:36,880 --> 00:19:38,920
and puff pizza stuff will happen that's

00:19:38,410 --> 00:19:46,840
not good

00:19:38,920 --> 00:19:48,790
so for example we are doing the same

00:19:46,840 --> 00:19:51,640
thing we did earlier we take an address

00:19:48,790 --> 00:19:53,200
to a statically allocated 42 convert it

00:19:51,640 --> 00:19:57,130
to a row pointer convert it to you size

00:19:53,200 --> 00:20:00,250
and then we divide that you size by 99

00:19:57,130 --> 00:20:02,320
but like what does that do like we don't

00:20:00,250 --> 00:20:05,110
have addresses at compile time there's

00:20:02,320 --> 00:20:07,150
no memory like what is dividing like

00:20:05,110 --> 00:20:08,980
magical address of something bit by 99

00:20:07,150 --> 00:20:11,770
like we don't know like okay we could

00:20:08,980 --> 00:20:13,480
add like symbol symbolic executors and

00:20:11,770 --> 00:20:15,730
all kind of set solvers and whatnot and

00:20:13,480 --> 00:20:17,800
go crazy but like do we really want that

00:20:15,730 --> 00:20:20,380
like this is probably not a good idea

00:20:17,800 --> 00:20:24,180
anyway so and I'm not talking about a

00:20:20,380 --> 00:20:26,410
pineapple of pizza I like that so

00:20:24,180 --> 00:20:28,740
sometimes we have less stricter rules at

00:20:26,410 --> 00:20:31,420
compile time too so we don't have any

00:20:28,740 --> 00:20:33,700
concrete rules about the alignment at

00:20:31,420 --> 00:20:35,200
compile time you can just do weird

00:20:33,700 --> 00:20:37,390
alignment thing so if you have like an

00:20:35,200 --> 00:20:41,110
array of you eight bytes and you convert

00:20:37,390 --> 00:20:43,150
that to you 64 like an array of just you

00:20:41,110 --> 00:20:44,620
eights can be anywhere in your memory it

00:20:43,150 --> 00:20:46,060
doesn't have to be aligned it just

00:20:44,620 --> 00:20:48,520
definitely has not to be aligned like

00:20:46,060 --> 00:20:49,690
you 64 needs to be aligned and if you do

00:20:48,520 --> 00:20:52,600
this code at runtime

00:20:49,690 --> 00:20:56,350
that's only fine behavior if you do this

00:20:52,600 --> 00:20:57,700
at compile time it'll compile but we

00:20:56,350 --> 00:20:58,600
reserve the right to break your code in

00:20:57,700 --> 00:21:00,990
the future because you're doing

00:20:58,600 --> 00:21:03,820
undefined behavior so they're very

00:21:00,990 --> 00:21:05,830
careful rules what you can actually do

00:21:03,820 --> 00:21:07,360
and you can do more things like you can

00:21:05,830 --> 00:21:10,300
do an undefined behavior at compile time

00:21:07,360 --> 00:21:12,700
we might not catch it but it gives you

00:21:10,300 --> 00:21:14,650
the right to do all these kinds of cool

00:21:12,700 --> 00:21:23,100
things if you're just as careful as you

00:21:14,650 --> 00:21:25,410
should be at at runtime so summarizing

00:21:23,100 --> 00:21:27,600
we don't really have

00:21:25,410 --> 00:21:30,630
in limits but we are restricting

00:21:27,600 --> 00:21:33,510
ourselves on purpose just to stay sane

00:21:30,630 --> 00:21:35,760
because at some point like we we don't

00:21:33,510 --> 00:21:38,550
want to put all this complexity on users

00:21:35,760 --> 00:21:40,740
because that's what lots Rus is all

00:21:38,550 --> 00:21:42,660
about taking away to complexity making

00:21:40,740 --> 00:21:44,220
the same for everyone to work with code

00:21:42,660 --> 00:21:46,140
and we want to do the same thing for

00:21:44,220 --> 00:21:47,820
constable and there's lots of work

00:21:46,140 --> 00:21:49,890
happening right now to make everything

00:21:47,820 --> 00:21:52,740
easier for you so don't have to write

00:21:49,890 --> 00:21:54,450
any complex trickeries to get stuff to

00:21:52,740 --> 00:21:56,160
work at compile time so just write

00:21:54,450 --> 00:21:57,570
normal Rosco and just execute the same

00:21:56,160 --> 00:22:00,420
thing at runtime at compile time and

00:21:57,570 --> 00:22:02,100
you'll be all happy many features that

00:22:00,420 --> 00:22:05,340
somebody might want need a load look

00:22:02,100 --> 00:22:06,540
like small base features so there's lots

00:22:05,340 --> 00:22:08,190
of work that's happening where it's like

00:22:06,540 --> 00:22:10,380
we're implementing three base features

00:22:08,190 --> 00:22:12,690
just to get one major feature so example

00:22:10,380 --> 00:22:15,240
as I said for 30 we'll need like heap

00:22:12,690 --> 00:22:17,090
allocations we need if we need loop we

00:22:15,240 --> 00:22:20,850
need traits the others even four so yeah

00:22:17,090 --> 00:22:22,440
and what do we actually need as more

00:22:20,850 --> 00:22:24,420
people telling us what they want to do

00:22:22,440 --> 00:22:26,070
at compile time as like so we can

00:22:24,420 --> 00:22:29,100
prioritize there's so many things we can

00:22:26,070 --> 00:22:30,720
do but like there's very few issues

00:22:29,100 --> 00:22:31,770
opened actually about people wanting

00:22:30,720 --> 00:22:34,440
something to become Stefan

00:22:31,770 --> 00:22:35,880
so that's my call to you Oh more issues

00:22:34,440 --> 00:22:41,960
telling us to do stuff at constant at

00:22:35,880 --> 00:22:44,640
all time yeah so this is basically

00:22:41,960 --> 00:22:47,160
everything I had prepared but I have a

00:22:44,640 --> 00:22:48,510
small appendix because people were

00:22:47,160 --> 00:22:50,250
telling me of the last few days all

00:22:48,510 --> 00:22:53,100
kinds of stuff that they are already

00:22:50,250 --> 00:23:00,210
interested in so I prepared a few small

00:22:53,100 --> 00:23:02,610
things this one is a compiler flag you

00:23:00,210 --> 00:23:05,460
can add this flag to a compiler and it

00:23:02,610 --> 00:23:08,370
will simply take off the guardrails like

00:23:05,460 --> 00:23:10,770
it'll just be like okay sorry I'll stop

00:23:08,370 --> 00:23:12,930
trying to be sound just just I try to

00:23:10,770 --> 00:23:15,000
run everything that you give me and you

00:23:12,930 --> 00:23:18,150
can do loops and there you can do if you

00:23:15,000 --> 00:23:19,590
can do end amout of stuff and it's a

00:23:18,150 --> 00:23:21,780
very bad idea we're using it just for

00:23:19,590 --> 00:23:25,200
internal testing never use this in

00:23:21,780 --> 00:23:27,600
production never ever some of the tests

00:23:25,200 --> 00:23:28,980
that we have actually error out no panic

00:23:27,600 --> 00:23:30,600
actually because you're doing something

00:23:28,980 --> 00:23:33,480
unsound that the compiler just doesn't

00:23:30,600 --> 00:23:34,680
understand so yeah don't try this know

00:23:33,480 --> 00:23:36,780
them but if you want to play around with

00:23:34,680 --> 00:23:39,780
the consequent and see how far it can go

00:23:36,780 --> 00:23:41,610
use it

00:23:39,780 --> 00:23:43,590
I want to shout out to add aesthetic

00:23:41,610 --> 00:23:44,880
assertions grade if you want to check

00:23:43,590 --> 00:23:46,440
something at compile time you use the

00:23:44,880 --> 00:23:48,540
static a surgeon's grade it basically

00:23:46,440 --> 00:23:51,450
that's this weird trick and some other

00:23:48,540 --> 00:23:53,700
way so if you want to check if a boolean

00:23:51,450 --> 00:23:55,380
is true and error out otherwise at

00:23:53,700 --> 00:23:58,050
compile time what you do is you create

00:23:55,380 --> 00:24:00,870
an array of one element you convert the

00:23:58,050 --> 00:24:02,730
boolean to you size and you need index

00:24:00,870 --> 00:24:04,950
another one element array if the boolean

00:24:02,730 --> 00:24:07,080
is zero you get something if your bully

00:24:04,950 --> 00:24:08,550
is not zero you panic and panning at the

00:24:07,080 --> 00:24:11,910
compile time compile time error

00:24:08,550 --> 00:24:13,470
wonderful so we have static surgeons use

00:24:11,910 --> 00:24:16,400
it it'll get better better error

00:24:13,470 --> 00:24:18,750
messages and so on once we are

00:24:16,400 --> 00:24:20,250
developing more things at a complaint in

00:24:18,750 --> 00:24:22,860
the compiler but I've been told that

00:24:20,250 --> 00:24:24,570
it's gonna go as 1.0 soonish the static

00:24:22,860 --> 00:24:25,920
assertions great so you can use it and

00:24:24,570 --> 00:24:28,200
it won't change its API

00:24:25,920 --> 00:24:30,360
we're just improving the Diagnostics

00:24:28,200 --> 00:24:34,680
that you are getting so you can just use

00:24:30,360 --> 00:24:37,740
it everywhere and now a final small

00:24:34,680 --> 00:24:40,070
anecdote so you can compute the

00:24:37,740 --> 00:24:42,720
Fibonacci sequence at compile time

00:24:40,070 --> 00:24:44,640
unstable but you'll get a compile time

00:24:42,720 --> 00:24:46,530
error or two and a compiler error will

00:24:44,640 --> 00:24:48,860
tell you the Fibonacci number that's

00:24:46,530 --> 00:24:48,860
being computed

00:24:52,570 --> 00:24:58,130
so this program uses wire loops it loses

00:24:55,790 --> 00:25:00,560
if conditions and so I yeah you don't

00:24:58,130 --> 00:25:02,930
really want to use that but what we it's

00:25:00,560 --> 00:25:04,610
doing its computing the length and a

00:25:02,930 --> 00:25:06,410
Fibonacci number and using it as the

00:25:04,610 --> 00:25:09,080
lengths of the type of the underscore

00:25:06,410 --> 00:25:11,270
variable here and then assigning an

00:25:09,080 --> 00:25:14,690
array of the links for t2 so you'll get

00:25:11,270 --> 00:25:16,580
a type mismatch ever before that you get

00:25:14,690 --> 00:25:18,050
an unlimited expression type that's the

00:25:16,580 --> 00:25:20,930
error that Eric actually gonna error out

00:25:18,050 --> 00:25:23,600
but we also get some it's net type error

00:25:20,930 --> 00:25:27,290
and there you can see it correctly

00:25:23,600 --> 00:25:29,540
computed at 1:44 for you and then they

00:25:27,290 --> 00:25:32,710
are allowed died

00:25:29,540 --> 00:25:32,710
[Applause]

00:25:38,340 --> 00:25:42,910
yeah so that's it from me for today if

00:25:41,559 --> 00:25:44,230
you have any questions just grab me at a

00:25:42,910 --> 00:25:45,610
rest of the day and also be here for the

00:25:44,230 --> 00:25:47,470
in place tomorrow

00:25:45,610 --> 00:25:49,059
two days ago somebody had a problem they

00:25:47,470 --> 00:25:51,340
wanted a fixed and constant valuator the

00:25:49,059 --> 00:25:52,630
pr is open now so just come to me we can

00:25:51,340 --> 00:25:54,220
usually do this very quickly because

00:25:52,630 --> 00:25:57,070
many things I just don't know about

00:25:54,220 --> 00:25:59,110
don't work and they often can be fixed

00:25:57,070 --> 00:26:00,360
pretty quickly so yeah thanks for being

00:25:59,110 --> 00:26:05,340
here and

00:26:00,360 --> 00:26:18,650
[Applause]

00:26:05,340 --> 00:26:18,650

YouTube URL: https://www.youtube.com/watch?v=wkXNm_qo8aY


