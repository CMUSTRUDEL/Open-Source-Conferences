Title: RustConf 2019 - The Symbiotic Relationship of C++ and Rust by Isabella Muerte
Publication date: 2019-09-16
Playlist: RustConf 2019
Description: 
	RustConf 2019 - The Symbiotic Relationship of C++ and Rust by Isabella Muerte

For better or worse, Rust and C++ have a shared future ahead of them. C++ will affect the design of Rust, and so too will Rust affect the design of C++. Rust's future is most likely the same path as C++, but what does that mean exactly? In this talk, we'll learn about the evolution of these languages, how much they have in common, the power their respective communities have to shape them, and the responsibility these communities have to each other.
Captions: 
	00:00:08,770 --> 00:00:15,680
[Music]

00:00:16,790 --> 00:00:22,550
all right cool so as was briefly

00:00:20,960 --> 00:00:25,939
mentioned we're gonna talk about C++ and

00:00:22,550 --> 00:00:30,890
rest today so just so you all know who I

00:00:25,939 --> 00:00:32,960
am I missing Marte and I'm a C++ bruja I

00:00:30,890 --> 00:00:34,010
do a lot of dark magic stuff with C++ if

00:00:32,960 --> 00:00:37,220
you know me personally than you know

00:00:34,010 --> 00:00:40,220
that I do some really cursed things I'm

00:00:37,220 --> 00:00:42,980
an aspirant row station so I do do a bit

00:00:40,220 --> 00:00:44,059
of rust on the side not my day job also

00:00:42,980 --> 00:00:46,270
don't really contribute to a lot of

00:00:44,059 --> 00:00:49,250
projects that's because I'm busy because

00:00:46,270 --> 00:00:53,979
as of lately I've become a bit of a sea

00:00:49,250 --> 00:00:56,089
make war criminal so um I do some really

00:00:53,979 --> 00:00:57,409
disgusting things in seeming as of late

00:00:56,089 --> 00:00:58,489
you could also make the argument that

00:00:57,409 --> 00:00:58,970
I'm not a super sports programmer

00:00:58,489 --> 00:01:00,589
anymore

00:00:58,970 --> 00:01:02,500
I'm a seeming program that just happens

00:01:00,589 --> 00:01:04,820
to those people see what's plus I

00:01:02,500 --> 00:01:07,940
promised not to talk about see make

00:01:04,820 --> 00:01:09,590
today I did that at the rusco last year

00:01:07,940 --> 00:01:11,150
and at one point someone just kind of

00:01:09,590 --> 00:01:13,040
walked away a little little like

00:01:11,150 --> 00:01:14,390
depersonalized disassociating like I

00:01:13,040 --> 00:01:18,020
just wish I didn't know any of what you

00:01:14,390 --> 00:01:20,240
just told me and then Michael made this

00:01:18,020 --> 00:01:21,860
tweet the other day he it's been zero

00:01:20,240 --> 00:01:24,800
days since I had a truly cursed idea and

00:01:21,860 --> 00:01:26,950
that's pretty accurate representation I

00:01:24,800 --> 00:01:30,140
care a lot about developer workflows

00:01:26,950 --> 00:01:31,880
build tools making it's that you have to

00:01:30,140 --> 00:01:34,250
type lessee or computer cuz the more we

00:01:31,880 --> 00:01:37,670
type the heart higher a chance of having

00:01:34,250 --> 00:01:38,990
arthritis as we get older increases

00:01:37,670 --> 00:01:40,670
I also currently hold the record for

00:01:38,990 --> 00:01:42,920
most papers submitted to a single C++

00:01:40,670 --> 00:01:45,020
sustainers meeting um that was

00:01:42,920 --> 00:01:46,370
completely by accident my name was on 20

00:01:45,020 --> 00:01:49,850
papers I don't think anyone's gonna

00:01:46,370 --> 00:01:51,410
break that anytime soon so just just to

00:01:49,850 --> 00:01:53,930
give you an idea that I do care abouts

00:01:51,410 --> 00:01:55,310
people supposed a little bit I started

00:01:53,930 --> 00:01:57,110
teach myself see post post about 10

00:01:55,310 --> 00:01:58,940
years ago by writing the build system

00:01:57,110 --> 00:02:01,400
don't learn how to program but I write

00:01:58,940 --> 00:02:02,690
in the build system if you have a friend

00:02:01,400 --> 00:02:05,600
that is like I'm thinking of writing a

00:02:02,690 --> 00:02:07,420
build system tell them not to care about

00:02:05,600 --> 00:02:09,470
your friends and the people around you

00:02:07,420 --> 00:02:11,420
I've been pay attention to rest for a

00:02:09,470 --> 00:02:14,959
while as Steve kind of made made mention

00:02:11,420 --> 00:02:17,659
of 0.5 and the kind of the syntax of you

00:02:14,959 --> 00:02:20,060
know the the old tilde T back when tilde

00:02:17,659 --> 00:02:22,580
T and at T were still a thing this was

00:02:20,060 --> 00:02:24,050
before the borrowed checker and when I

00:02:22,580 --> 00:02:26,329
think everything was still either like

00:02:24,050 --> 00:02:27,769
equivalent to a unique pointer or a

00:02:26,329 --> 00:02:29,810
shared pointer in this equals plus side

00:02:27,769 --> 00:02:31,819
and iterators were still more Ruby like

00:02:29,810 --> 00:02:34,550
so the the current stream iterator

00:02:31,819 --> 00:02:36,880
implementation that has been used since

00:02:34,550 --> 00:02:39,950
you know forever

00:02:36,880 --> 00:02:43,610
wasn't really a thing so that's my

00:02:39,950 --> 00:02:47,090
Twitter that's my github yes it is

00:02:43,610 --> 00:02:49,670
slurps mad rips I can go into the story

00:02:47,090 --> 00:02:52,310
of why I chose that username in 2012 but

00:02:49,670 --> 00:02:53,569
let's not right now and I also just want

00:02:52,310 --> 00:02:55,970
to set up some some boundaries real

00:02:53,569 --> 00:02:59,420
quick so you know any questions

00:02:55,970 --> 00:03:00,560
let's look until after the talk if we

00:02:59,420 --> 00:03:02,150
don't have time for questions you can

00:03:00,560 --> 00:03:03,380
speak to me in person outside I won't

00:03:02,150 --> 00:03:05,120
actually sit off to the side here I'll

00:03:03,380 --> 00:03:06,920
actually physically walk out just so

00:03:05,120 --> 00:03:10,160
that we can give more people space up

00:03:06,920 --> 00:03:12,290
here for the next talk and lastly you

00:03:10,160 --> 00:03:16,310
can always tweet a question to me with

00:03:12,290 --> 00:03:17,540
that hashtag 1 2 3 you got a CPP I and I

00:03:16,310 --> 00:03:20,239
actually checked this hashtag every

00:03:17,540 --> 00:03:22,160
couple of every couple of weeks because

00:03:20,239 --> 00:03:24,739
you know maybe you're watching this at

00:03:22,160 --> 00:03:26,330
home maybe you had a question that you

00:03:24,739 --> 00:03:28,610
wanted to ask me forgot about it then

00:03:26,330 --> 00:03:30,560
remembered it on the way home after the

00:03:28,610 --> 00:03:31,940
conference this allows you to ask that

00:03:30,560 --> 00:03:34,430
question I will respond to it

00:03:31,940 --> 00:03:35,959
you can also at me but by using this

00:03:34,430 --> 00:03:39,079
hashtag other people can also see what

00:03:35,959 --> 00:03:43,190
questions you yourselves have asked so a

00:03:39,079 --> 00:03:45,230
couple extra talks that I suggest all of

00:03:43,190 --> 00:03:46,579
you go and watch at some point after

00:03:45,230 --> 00:03:48,920
this conference and after this talks to

00:03:46,579 --> 00:03:51,109
you can kind of get a better idea we

00:03:48,920 --> 00:03:52,489
only have 30 minutes obviously there's

00:03:51,109 --> 00:03:56,660
the elsewhere memory talk by Neil

00:03:52,489 --> 00:03:59,329
Douglas I'm from ACC u 2019 Jen shivers

00:03:56,660 --> 00:04:01,459
talk on JavaScript considered useful and

00:03:59,329 --> 00:04:03,620
then the tragedy of systemd

00:04:01,459 --> 00:04:06,380
by Ben o rice I'm pretty sure I just

00:04:03,620 --> 00:04:08,989
murdered his first name there but these

00:04:06,380 --> 00:04:10,760
these three talks I've been watching

00:04:08,989 --> 00:04:13,010
pretty pretty regularly because they

00:04:10,760 --> 00:04:14,930
they cover a wide variety of different

00:04:13,010 --> 00:04:17,120
things from the super suppose abstract

00:04:14,930 --> 00:04:19,130
machine to community related things as

00:04:17,120 --> 00:04:21,139
well as even standardization in the case

00:04:19,130 --> 00:04:22,520
of Jen's talk and we're going to talk a

00:04:21,139 --> 00:04:24,139
little bit about each of the things that

00:04:22,520 --> 00:04:26,500
is that are in these talks but in

00:04:24,139 --> 00:04:29,870
reference to super supposin dress today

00:04:26,500 --> 00:04:32,120
so as I said you know why are we here so

00:04:29,870 --> 00:04:34,610
I think they're gonna be super so much

00:04:32,120 --> 00:04:38,000
gonna be living side by side for quite a

00:04:34,610 --> 00:04:41,300
long time if only because contracts with

00:04:38,000 --> 00:04:43,199
you know various industries exist there

00:04:41,300 --> 00:04:47,159
are people that are still running seek

00:04:43,199 --> 00:04:48,840
until 2050 on military hardware so if

00:04:47,159 --> 00:04:49,770
she's gonna live that long C++ will

00:04:48,840 --> 00:04:52,639
definitely live as long because

00:04:49,770 --> 00:04:56,340
currently the C Standards Committee

00:04:52,639 --> 00:04:58,680
Charter says that they are to keep

00:04:56,340 --> 00:05:00,300
basically in lockstep with C++ and to

00:04:58,680 --> 00:05:02,129
make sure that C stays compatible as C++

00:05:00,300 --> 00:05:03,539
rather than what used to be the other

00:05:02,129 --> 00:05:05,249
way around

00:05:03,539 --> 00:05:06,990
Russ also is not going anywhere I think

00:05:05,249 --> 00:05:09,349
it has too much momentum at this point

00:05:06,990 --> 00:05:11,759
it is technically a 13 year old language

00:05:09,349 --> 00:05:13,379
so you know it's it's old enough to

00:05:11,759 --> 00:05:17,639
curse at me and tell me I'm bad at

00:05:13,379 --> 00:05:19,289
counter-strike online C++ is kind of

00:05:17,639 --> 00:05:20,939
like the 40 year old burned-out person

00:05:19,289 --> 00:05:23,849
that used to play quake in 1993 or

00:05:20,939 --> 00:05:26,819
whatever so you know neither of us are

00:05:23,849 --> 00:05:27,749
going anywhere anytime soon and we might

00:05:26,819 --> 00:05:28,770
as well work together to learn from each

00:05:27,749 --> 00:05:31,110
other's mistakes there's a lot of stuff

00:05:28,770 --> 00:05:33,629
involved with tooling with optimizations

00:05:31,110 --> 00:05:35,669
that we can learn from and you know

00:05:33,629 --> 00:05:37,460
while be honest use to creative C++

00:05:35,669 --> 00:05:40,620
might say other languages are copying

00:05:37,460 --> 00:05:41,580
C++ there are people on the Standards

00:05:40,620 --> 00:05:42,839
Committee at first super suppose that

00:05:41,580 --> 00:05:45,029
are looking at what Russ does for

00:05:42,839 --> 00:05:46,680
optimizations for language futures and

00:05:45,029 --> 00:05:48,029
we are borrowing from them I've

00:05:46,680 --> 00:05:50,099
submitted quite a few papers in

00:05:48,029 --> 00:05:51,779
regarding that so just to give you an

00:05:50,099 --> 00:05:55,199
idea of like how similar languages are

00:05:51,779 --> 00:05:56,819
we've got you know a lot of stuff that

00:05:55,199 --> 00:05:58,169
is similar but our terminology is

00:05:56,819 --> 00:06:00,960
starting to drift kind of like you know

00:05:58,169 --> 00:06:02,879
how you know the Romance language is

00:06:00,960 --> 00:06:04,139
drifted and if you speak Spanish you can

00:06:02,879 --> 00:06:05,339
kind of understand Italian and if you

00:06:04,139 --> 00:06:06,479
speak a tell you can kind of understand

00:06:05,339 --> 00:06:08,550
Spanish

00:06:06,479 --> 00:06:10,560
you know there's a lot of similarities

00:06:08,550 --> 00:06:11,909
there and we're both kind of trapped

00:06:10,560 --> 00:06:15,539
trying to express high-level concepts

00:06:11,909 --> 00:06:18,149
for machine code and rust doesn't have

00:06:15,539 --> 00:06:21,499
an abstract machine C++ does and our

00:06:18,149 --> 00:06:23,789
abstract machine is basically the pdp-11

00:06:21,499 --> 00:06:25,680
and if something can't meet that then

00:06:23,789 --> 00:06:28,439
it's not really an abstract machine it's

00:06:25,680 --> 00:06:29,879
kind of a shame but rust does have to

00:06:28,439 --> 00:06:32,999
meet a lot of the stuff that C++ does

00:06:29,879 --> 00:06:37,319
because by using LLVM you're stuck with

00:06:32,999 --> 00:06:39,479
our memory model and if in the future

00:06:37,319 --> 00:06:41,399
and Vidya says we'll adopt the rust

00:06:39,479 --> 00:06:44,039
memory model over C++ then we'll have to

00:06:41,399 --> 00:06:44,909
follow you know your direction of things

00:06:44,039 --> 00:06:47,009
but I don't think that's gonna be

00:06:44,909 --> 00:06:48,899
happening time soon unfortunately or

00:06:47,009 --> 00:06:50,879
fortunately so here's some code

00:06:48,899 --> 00:06:53,459
differences here so you know russ has

00:06:50,879 --> 00:06:56,129
let we have auto I didn't put Auto Const

00:06:53,459 --> 00:06:59,580
because you don't want an auto

00:06:56,129 --> 00:07:00,719
our value reference and that's let's not

00:06:59,580 --> 00:07:03,149
you know what let's just not get into

00:07:00,719 --> 00:07:05,759
that part of the language it's kind of a

00:07:03,149 --> 00:07:10,649
landmine russ has the turbot fish we

00:07:05,759 --> 00:07:11,759
have both the apologize I used Furyk

00:07:10,649 --> 00:07:15,509
hose that's why it looks like a diamond

00:07:11,759 --> 00:07:19,050
there as well as the scope template

00:07:15,509 --> 00:07:21,539
syntax the the form of that we used less

00:07:19,050 --> 00:07:23,039
nowadays we're relaxing type name and

00:07:21,539 --> 00:07:24,330
its usage and it's making write a

00:07:23,039 --> 00:07:26,909
generic code easier also means that this

00:07:24,330 --> 00:07:30,360
kind of you know call scope template

00:07:26,909 --> 00:07:34,369
thing is disappearing the if let's some

00:07:30,360 --> 00:07:37,199
or if let you know some value expression

00:07:34,369 --> 00:07:41,189
is kind of equivalent if Auto X equals

00:07:37,199 --> 00:07:45,839
some boolean expression and moving into

00:07:41,189 --> 00:07:49,469
more literals in C++ xx we still have to

00:07:45,839 --> 00:07:52,949
write using this stupid macro from C's C

00:07:49,469 --> 00:07:57,929
stood int in 64 underscore C to get an

00:07:52,949 --> 00:07:59,939
actual int 6040 whereas in 23 do paper

00:07:57,929 --> 00:08:01,789
I'm writing we can we will actually able

00:07:59,939 --> 00:08:05,159
to write the same thing that rust has

00:08:01,789 --> 00:08:07,949
and that is actually a library feature a

00:08:05,159 --> 00:08:09,749
language feature because we're so cursed

00:08:07,949 --> 00:08:12,449
we said hey what if anyone could just

00:08:09,749 --> 00:08:15,629
write whatever suffix literal they

00:08:12,449 --> 00:08:20,990
wanted for a given built-in tight and

00:08:15,629 --> 00:08:23,159
someone said yeah that sounds cool our

00:08:20,990 --> 00:08:25,229
integer separators are a bit different

00:08:23,159 --> 00:08:27,869
rust has borrowed from a variety of the

00:08:25,229 --> 00:08:29,490
languages Python Ruby I think Perl maybe

00:08:27,869 --> 00:08:30,749
but a lot of people are moving in this

00:08:29,490 --> 00:08:33,449
direction of you know that using

00:08:30,749 --> 00:08:35,519
underscores as an digit separator we

00:08:33,449 --> 00:08:39,389
chose the single quote in C++ because

00:08:35,519 --> 00:08:40,740
econometrics this the choice of a period

00:08:39,389 --> 00:08:43,229
or comma without us having to get into

00:08:40,740 --> 00:08:45,029
localization issues I personally believe

00:08:43,229 --> 00:08:48,689
that the C++ one is a little better and

00:08:45,029 --> 00:08:53,040
I've also seen people writing integers

00:08:48,689 --> 00:08:55,769
out in actual like papers using the C++

00:08:53,040 --> 00:08:58,079
syntax instead of the underscored

00:08:55,769 --> 00:09:00,120
version I think in academic papers

00:08:58,079 --> 00:09:02,810
you'll see that C++ form more even if

00:09:00,120 --> 00:09:05,309
the paper has nothing to do with C++

00:09:02,810 --> 00:09:07,649
both Wilson Russ can overload some

00:09:05,309 --> 00:09:09,610
operators I found out last night that

00:09:07,649 --> 00:09:13,570
you can over

00:09:09,610 --> 00:09:16,000
overload the not operator in rust and we

00:09:13,570 --> 00:09:20,220
can also do that in C++ so hey we both

00:09:16,000 --> 00:09:20,220
have a really bad decision that's great

00:09:20,250 --> 00:09:24,459
rust moves are equivalent to a new

00:09:22,870 --> 00:09:27,339
concept that we're trying to try out in

00:09:24,459 --> 00:09:29,500
C++ which is called relocation our moves

00:09:27,339 --> 00:09:30,670
are kind of just a tag on the type

00:09:29,500 --> 00:09:32,320
system so when you have an r-value

00:09:30,670 --> 00:09:34,269
reference and you've moved something

00:09:32,320 --> 00:09:36,670
into a function that does not mean that

00:09:34,269 --> 00:09:38,589
the data has been moved from where as in

00:09:36,670 --> 00:09:42,579
rust moving from something implies

00:09:38,589 --> 00:09:43,779
destruction relocation might be an

00:09:42,579 --> 00:09:44,829
optimization that comes in the future

00:09:43,779 --> 00:09:47,560
we're still trying to even figure out

00:09:44,829 --> 00:09:49,089
the basics of antics of it it's gonna be

00:09:47,560 --> 00:09:53,019
a long road we probably won't see it in

00:09:49,089 --> 00:09:54,250
actual practice until 26 or 29 rust has

00:09:53,019 --> 00:09:56,200
working groups we have study groups

00:09:54,250 --> 00:09:57,940
they're both kind of the same anyone can

00:09:56,200 --> 00:09:59,320
participate in a study group in C++

00:09:57,940 --> 00:10:01,420
anyone can participate in the working

00:09:59,320 --> 00:10:03,630
group you still to book you know

00:10:01,420 --> 00:10:07,240
approach both of good faith arguments

00:10:03,630 --> 00:10:10,390
and that's a like I said we don't have

00:10:07,240 --> 00:10:11,860
enough time unfortunately so apologies

00:10:10,390 --> 00:10:13,990
so also technically speaking this code

00:10:11,860 --> 00:10:16,600
that you see here this could be valid

00:10:13,990 --> 00:10:17,560
C++ or rest code those of you that are

00:10:16,600 --> 00:10:18,699
familiar with plus plus might have

00:10:17,560 --> 00:10:21,430
figured out already what I'm doing here

00:10:18,699 --> 00:10:25,120
which is you just start define let to

00:10:21,430 --> 00:10:27,130
auto and you're on your way I already

00:10:25,120 --> 00:10:29,140
discussed the memory model stuff and

00:10:27,130 --> 00:10:31,089
Neil's talk about the abstract machine

00:10:29,140 --> 00:10:34,899
is very interesting if it's actually

00:10:31,089 --> 00:10:36,040
about two hours but it is extremely

00:10:34,899 --> 00:10:37,779
interesting talk because it kind of

00:10:36,040 --> 00:10:39,910
gives you an idea of where the hardware

00:10:37,779 --> 00:10:42,220
that we currently use today comes from

00:10:39,910 --> 00:10:43,839
where it's going to and the limitations

00:10:42,220 --> 00:10:44,829
that we have to deal with because you

00:10:43,839 --> 00:10:46,470
know you could have a high level

00:10:44,829 --> 00:10:49,029
language that could do everything but if

00:10:46,470 --> 00:10:50,769
you know the CPU is gonna be flipping

00:10:49,029 --> 00:10:52,120
bits behind your back and you don't know

00:10:50,769 --> 00:10:55,089
about it that's gonna cause problems for

00:10:52,120 --> 00:10:56,560
you of course we also have our

00:10:55,089 --> 00:10:58,209
differences we're not going to talk

00:10:56,560 --> 00:11:00,100
about defaults okay we already know

00:10:58,209 --> 00:11:02,680
about it's like a dead mean right like

00:11:00,100 --> 00:11:04,630
rewrite it in rust dead meme talking

00:11:02,680 --> 00:11:06,579
about cost as default and mutability

00:11:04,630 --> 00:11:08,829
also a dead meme I don't want to talk

00:11:06,579 --> 00:11:10,870
about it let's talk about lifetime

00:11:08,829 --> 00:11:12,190
semantics we're talking about concepts

00:11:10,870 --> 00:11:14,890
and traits because they're very similar

00:11:12,190 --> 00:11:16,240
but very different this is just what I'm

00:11:14,890 --> 00:11:18,430
calling this right now the execution

00:11:16,240 --> 00:11:18,740
context boundary this isn't a thing that

00:11:18,430 --> 00:11:21,530
we have

00:11:18,740 --> 00:11:22,460
term for in either community yet but it

00:11:21,530 --> 00:11:25,250
is something that's gonna be coming up

00:11:22,460 --> 00:11:26,510
because of changes in C++ 20 so Russ

00:11:25,250 --> 00:11:28,340
lifetime semantics as I'm sure you're

00:11:26,510 --> 00:11:30,640
all aware it's baked into the language

00:11:28,340 --> 00:11:33,610
otherwise you wouldn't have a you know

00:11:30,640 --> 00:11:36,740
lifetime you know syntax to represent it

00:11:33,610 --> 00:11:38,180
most of the time this this concept of

00:11:36,740 --> 00:11:40,640
lifetime ownership and stuff like that

00:11:38,180 --> 00:11:43,910
can be mapped to existing api's from

00:11:40,640 --> 00:11:47,390
foreign languages so see if you're

00:11:43,910 --> 00:11:48,860
trying to call into C++ in some way and

00:11:47,390 --> 00:11:50,830
you figured out how to generate the

00:11:48,860 --> 00:11:54,080
correct symbol for it sure even there

00:11:50,830 --> 00:11:55,220
and custom semantics do break down

00:11:54,080 --> 00:11:57,410
though when you get into stuff like

00:11:55,220 --> 00:12:00,200
objective-c or OpenCL and yes from an

00:11:57,410 --> 00:12:03,080
optimization perspective you do not want

00:12:00,200 --> 00:12:06,620
to always be retaining and releasing

00:12:03,080 --> 00:12:08,210
these but at the same time sometimes

00:12:06,620 --> 00:12:10,340
it's nice to just take someone's really

00:12:08,210 --> 00:12:12,290
garbage objective-c code and then to

00:12:10,340 --> 00:12:15,620
just copy it into your own code and not

00:12:12,290 --> 00:12:18,680
have to change as much C++ lifetime

00:12:15,620 --> 00:12:20,540
semantics we don't have any we literally

00:12:18,680 --> 00:12:23,210
do not and everything involving unique

00:12:20,540 --> 00:12:26,870
pointers shared pointer all of this

00:12:23,210 --> 00:12:28,730
stuff has is defined by the library

00:12:26,870 --> 00:12:30,710
portion of the standard so the language

00:12:28,730 --> 00:12:34,070
doesn't have a concept of a unique

00:12:30,710 --> 00:12:38,780
pointer of ownership and releasing

00:12:34,070 --> 00:12:40,850
ownership of you know incremental counts

00:12:38,780 --> 00:12:44,080
and dereference counts and all that

00:12:40,850 --> 00:12:46,400
other stuff or sorry decrement accounts

00:12:44,080 --> 00:12:49,310
but as so as I said everything's library

00:12:46,400 --> 00:12:50,780
to find mostly obviously value semantics

00:12:49,310 --> 00:12:53,990
destructors and stuff like that those

00:12:50,780 --> 00:12:55,670
are at the language level both languages

00:12:53,990 --> 00:12:57,500
have this constant of D res I'm not

00:12:55,670 --> 00:12:59,690
gonna use are aii because one it's a

00:12:57,500 --> 00:13:01,610
terrible terrible acronym it's

00:12:59,690 --> 00:13:03,650
impossible pronounced right it sounds

00:13:01,610 --> 00:13:06,680
like a bread if you just say it out loud

00:13:03,650 --> 00:13:09,110
whereas d res you can make a joke about

00:13:06,680 --> 00:13:11,930
Tron and everyone's gonna understand it

00:13:09,110 --> 00:13:14,660
like immediately right and yes I know a

00:13:11,930 --> 00:13:17,300
drop does not imply a destructor it

00:13:14,660 --> 00:13:20,860
could be a scope based resource but de

00:13:17,300 --> 00:13:22,820
res de sounds cooler as an example

00:13:20,860 --> 00:13:25,250
retain pointer this is a type I've been

00:13:22,820 --> 00:13:25,910
working on so retain pointer I first

00:13:25,250 --> 00:13:28,940
wrote it

00:13:25,910 --> 00:13:32,390
the proposal for it in a night in 2016

00:13:28,940 --> 00:13:35,240
because this is a type that is

00:13:32,390 --> 00:13:36,890
meant to you know work with capi is like

00:13:35,240 --> 00:13:39,530
you know open Seattle or Objective C

00:13:36,890 --> 00:13:41,360
because Objective C is AC runtime it's

00:13:39,530 --> 00:13:44,600
meant to work with you know calm and

00:13:41,360 --> 00:13:47,810
direct decks and some parts of the the

00:13:44,600 --> 00:13:49,580
mono framework web browsers have

00:13:47,810 --> 00:13:51,200
implementations of retained pointer

00:13:49,580 --> 00:13:55,010
inside of them

00:13:51,200 --> 00:13:57,620
Safari specifically inside of the WebKit

00:13:55,010 --> 00:13:59,900
tool framework which is namespace as WTF

00:13:57,620 --> 00:14:01,010
has a type called retain pointer as it

00:13:59,900 --> 00:14:03,500
turns out I did not know this when I

00:14:01,010 --> 00:14:05,090
wrote the paper and then also it's

00:14:03,500 --> 00:14:07,700
useful for implementing async API it's

00:14:05,090 --> 00:14:09,410
basically stood future stood shared

00:14:07,700 --> 00:14:12,830
pointer stood weak pointer it's an

00:14:09,410 --> 00:14:13,430
exception pointer and we still retain

00:14:12,830 --> 00:14:14,900
pointer itself

00:14:13,430 --> 00:14:17,420
all of these can be implemented with

00:14:14,900 --> 00:14:19,250
retained pointer you know on the rough

00:14:17,420 --> 00:14:20,390
side if you had an equivalent to retain

00:14:19,250 --> 00:14:24,170
pointer you would be able to implement

00:14:20,390 --> 00:14:25,790
both RC and arc in terms of a retain

00:14:24,170 --> 00:14:28,670
pointers this is a very low-level type

00:14:25,790 --> 00:14:30,380
and introduces this concept of adoption

00:14:28,670 --> 00:14:32,510
right we have we have the concept of

00:14:30,380 --> 00:14:34,070
extending a lifetime of a type we had

00:14:32,510 --> 00:14:37,880
the concept of ownership of a type but

00:14:34,070 --> 00:14:39,980
we do not have a concept of a value has

00:14:37,880 --> 00:14:41,330
come in from some boundary that we do

00:14:39,980 --> 00:14:43,400
not know where it might come from

00:14:41,330 --> 00:14:45,770
exactly we just know that it has come in

00:14:43,400 --> 00:14:47,690
from a function and we want to be able

00:14:45,770 --> 00:14:49,190
to use that tight for a brief period and

00:14:47,690 --> 00:14:52,640
eventually kick it out of our house

00:14:49,190 --> 00:14:54,110
so kind of like adoption but not maybe

00:14:52,640 --> 00:15:02,060
not the best term in that case I guess

00:14:54,110 --> 00:15:03,590
so so this this type is there's a

00:15:02,060 --> 00:15:06,710
someone on Twitter whose name is our

00:15:03,590 --> 00:15:08,690
Berger ceman he is a bit of a firebrand

00:15:06,710 --> 00:15:10,220
and in that he disagrees with everything

00:15:08,690 --> 00:15:12,080
that c++ company does and says this is

00:15:10,220 --> 00:15:14,630
just over complicated I don't care about

00:15:12,080 --> 00:15:16,520
this in either should you but after I

00:15:14,630 --> 00:15:18,350
presented this the subjective version of

00:15:16,520 --> 00:15:19,760
retain pointer in 2018 last year he came

00:15:18,350 --> 00:15:21,680
up to me and said I've implemented this

00:15:19,760 --> 00:15:24,380
six times in my code base I'm replacing

00:15:21,680 --> 00:15:25,490
it with this and if Arvid says this is a

00:15:24,380 --> 00:15:27,440
good idea for this people suppose

00:15:25,490 --> 00:15:30,200
standard library to have then maybe

00:15:27,440 --> 00:15:31,760
you're onto something so let's talk

00:15:30,200 --> 00:15:33,290
about resource concepts for quick so

00:15:31,760 --> 00:15:36,500
rust rates are maximally constrained

00:15:33,290 --> 00:15:39,140
right if if a type does not mention what

00:15:36,500 --> 00:15:42,230
traits it uses you can't call any member

00:15:39,140 --> 00:15:44,780
functions on that right whereas in C++

00:15:42,230 --> 00:15:46,220
they're minimally constraining C++ says

00:15:44,780 --> 00:15:48,470
this type has to meet

00:15:46,220 --> 00:15:50,900
the basics of this interface but other

00:15:48,470 --> 00:15:53,000
than that go hog-wild I don't care if

00:15:50,900 --> 00:15:55,970
this function doesn't exist if I have to

00:15:53,000 --> 00:15:58,460
do a lookup later you might get an error

00:15:55,970 --> 00:16:00,110
there and so more work has to go into a

00:15:58,460 --> 00:16:03,170
concept to make sure that the minimum

00:16:00,110 --> 00:16:06,380
interface is being met and we're gonna

00:16:03,170 --> 00:16:08,180
also discuss briefly so they are now I

00:16:06,380 --> 00:16:10,550
had to add this literally five minutes

00:16:08,180 --> 00:16:11,990
ago special members which are

00:16:10,550 --> 00:16:14,390
constructors destructors copy

00:16:11,990 --> 00:16:16,280
constructors assignment or now follow

00:16:14,390 --> 00:16:19,340
the best fit model as of Cologne which

00:16:16,280 --> 00:16:21,620
was back in June and as an example here

00:16:19,340 --> 00:16:25,970
here's a cost expert optional

00:16:21,620 --> 00:16:28,970
implementation where the destructor that

00:16:25,970 --> 00:16:31,520
is trivially defaulted there will be

00:16:28,970 --> 00:16:34,310
used if the given T which is

00:16:31,520 --> 00:16:36,920
destructible is also trivially

00:16:34,310 --> 00:16:40,900
destructible if it is not then we have

00:16:36,920 --> 00:16:42,710
to reset the optional on destruction

00:16:40,900 --> 00:16:46,250
that does that make sense

00:16:42,710 --> 00:16:47,870
like I know this it's a mouthful but the

00:16:46,250 --> 00:16:49,190
semantics for this are basically why we

00:16:47,870 --> 00:16:52,910
did this because we can use this on

00:16:49,190 --> 00:16:54,590
member functions as well in C++ so let's

00:16:52,910 --> 00:16:56,750
look at using a concept so this is this

00:16:54,590 --> 00:16:59,030
is some garbage code here and I

00:16:56,750 --> 00:17:00,380
apologize but this is just the best way

00:16:59,030 --> 00:17:02,780
I was able to implement this and this is

00:17:00,380 --> 00:17:05,420
basically to say if a type has an

00:17:02,780 --> 00:17:07,730
element type def or if it has a pointer

00:17:05,420 --> 00:17:11,750
type def i want to get that out of it

00:17:07,730 --> 00:17:14,829
and use that as a storage value and so

00:17:11,750 --> 00:17:17,540
this is a slightly regular type because

00:17:14,829 --> 00:17:19,640
unfortunately we have the concept of a

00:17:17,540 --> 00:17:21,199
regular and semi regular type but for

00:17:19,640 --> 00:17:24,110
that to be true something has to be

00:17:21,199 --> 00:17:27,920
copyable not only movable as a minimum

00:17:24,110 --> 00:17:31,070
we also decided at cologne to change all

00:17:27,920 --> 00:17:32,930
of these names to a snake case instead

00:17:31,070 --> 00:17:34,880
of the upper cased form and I didn't

00:17:32,930 --> 00:17:37,610
feel relighting any of this code so

00:17:34,880 --> 00:17:39,410
you're just gonna have to deal with it

00:17:37,610 --> 00:17:40,970
so here's a pointer like type this is

00:17:39,410 --> 00:17:42,980
for our smart pointer interfaces right

00:17:40,970 --> 00:17:45,560
so you can get it you can cast it to a

00:17:42,980 --> 00:17:47,090
bowl explicitly you can reset it you can

00:17:45,560 --> 00:17:49,550
reset it with an instance of the pointer

00:17:47,090 --> 00:17:52,490
type internally hence the pointer type

00:17:49,550 --> 00:17:54,170
of T which we saw two slides up we're

00:17:52,490 --> 00:17:56,720
not gonna get into this explicitly here

00:17:54,170 --> 00:17:58,260
but you'll also notice on this line

00:17:56,720 --> 00:17:59,970
right here

00:17:58,260 --> 00:18:02,460
we're checking to see if you can call

00:17:59,970 --> 00:18:04,410
the arrow operator directly as a member

00:18:02,460 --> 00:18:06,600
function rather than calling the arrow

00:18:04,410 --> 00:18:09,650
because that's a thing we can also do in

00:18:06,600 --> 00:18:12,059
C++ isn't that a nightmare

00:18:09,650 --> 00:18:14,130
but here's here's a handle right this

00:18:12,059 --> 00:18:16,440
handle can implement any kind of

00:18:14,130 --> 00:18:18,210
ownership model as long as that

00:18:16,440 --> 00:18:21,270
ownership is defined by this pointer

00:18:18,210 --> 00:18:23,340
like storage type and as an example here

00:18:21,270 --> 00:18:24,870
we can have a unique handle we can have

00:18:23,340 --> 00:18:26,580
a shared handle we can have a retained

00:18:24,870 --> 00:18:28,710
handle we can also have a viewed handle

00:18:26,580 --> 00:18:29,730
and you wouldn't hold this as a member

00:18:28,710 --> 00:18:31,260
inside of the class you would actually

00:18:29,730 --> 00:18:34,830
inherit from this in C++ this is

00:18:31,260 --> 00:18:38,669
basically a mixin type and as an example

00:18:34,830 --> 00:18:40,679
if we use the Android NDK as an example

00:18:38,669 --> 00:18:43,080
here we have a simple enum class with an

00:18:40,679 --> 00:18:44,549
orientation and here's a configuration

00:18:43,080 --> 00:18:45,990
type now there's a lot of code here the

00:18:44,549 --> 00:18:48,480
important part here is that we just

00:18:45,990 --> 00:18:50,880
inherit from it and in our constructor

00:18:48,480 --> 00:18:53,490
we that is copying we have to call this

00:18:50,880 --> 00:18:55,470
a configuration copy thing use this

00:18:53,490 --> 00:18:56,460
other thing called out pointer let's not

00:18:55,470 --> 00:18:58,020
get into that part that's not what

00:18:56,460 --> 00:19:00,780
matters what matters though is you'll

00:18:58,020 --> 00:19:02,640
notice this class does a whole bunch of

00:19:00,780 --> 00:19:04,799
stuff you can reset with it you can cast

00:19:02,640 --> 00:19:08,760
a tooling you can check to see if it is

00:19:04,799 --> 00:19:10,799
a valid configuration or not that is I

00:19:08,760 --> 00:19:13,470
think really powerful and C++ is that we

00:19:10,799 --> 00:19:16,260
do have the ability to have mix-ins that

00:19:13,470 --> 00:19:18,510
also then expand the lifetime

00:19:16,260 --> 00:19:21,990
semantics of whatever it is trying to

00:19:18,510 --> 00:19:25,110
make C's needs to manage so and in seven

00:19:21,990 --> 00:19:27,540
slides we described a per type opt in

00:19:25,110 --> 00:19:29,370
for lifetime semantics you can have a

00:19:27,540 --> 00:19:32,040
non owning handle you can have a

00:19:29,370 --> 00:19:35,250
retained handle and shared handle or a

00:19:32,040 --> 00:19:37,200
unique handle and that's just with

00:19:35,250 --> 00:19:39,750
concepts implementing that without

00:19:37,200 --> 00:19:41,370
concepts absolutely a nightmare and

00:19:39,750 --> 00:19:43,500
there's a whole bunch of side effects

00:19:41,370 --> 00:19:44,940
that I don't want to get into but I

00:19:43,500 --> 00:19:47,190
think that's a very powerful part of C++

00:19:44,940 --> 00:19:49,580
here we can also extend this by

00:19:47,190 --> 00:19:52,460
implementing other pointer like types so

00:19:49,580 --> 00:19:55,440
hazard pointer which is meant more for

00:19:52,460 --> 00:19:57,480
concurrency related stuff boost offset

00:19:55,440 --> 00:19:59,970
pointer which is a an optimisation for

00:19:57,480 --> 00:20:01,860
shared memory operations and even if you

00:19:59,970 --> 00:20:04,799
wanted to have some weird pointer and to

00:20:01,860 --> 00:20:06,860
like go and you were binding code with C

00:20:04,799 --> 00:20:10,309
go you would be able to use this as well

00:20:06,860 --> 00:20:12,060
the execution context boundary is

00:20:10,309 --> 00:20:13,920
basically this idea

00:20:12,060 --> 00:20:16,740
of executing code at compile time versus

00:20:13,920 --> 00:20:19,740
runtime I believe oli was discussing

00:20:16,740 --> 00:20:21,030
this in their talk I missed that talk

00:20:19,740 --> 00:20:23,610
because I was trying to finish up a few

00:20:21,030 --> 00:20:25,050
slides I apologize for that but

00:20:23,610 --> 00:20:26,790
cautionary sources concise spirit

00:20:25,050 --> 00:20:28,530
constant eval is basically where we're

00:20:26,790 --> 00:20:31,650
getting into this supercilious has

00:20:28,530 --> 00:20:32,670
explored this a lot more areas our

00:20:31,650 --> 00:20:34,640
compilers are trying to implement

00:20:32,670 --> 00:20:38,670
bytecode interpreters for context per

00:20:34,640 --> 00:20:40,500
just for speed purposes so in super

00:20:38,670 --> 00:20:42,270
suppose 20 we're getting cost eval cost

00:20:40,500 --> 00:20:44,550
in it and we still have cost expert

00:20:42,270 --> 00:20:46,860
we're not going to talk about constant

00:20:44,550 --> 00:20:48,990
it it is a terrible keyword with one

00:20:46,860 --> 00:20:51,180
specific use a lot of people don't

00:20:48,990 --> 00:20:53,220
understand its meaning I am one of those

00:20:51,180 --> 00:20:56,010
people so I can't explain it even if I

00:20:53,220 --> 00:20:58,680
wanted to functions our runtime by

00:20:56,010 --> 00:21:00,570
default as they are in rust cons eval

00:20:58,680 --> 00:21:03,420
means it can only execute at compile

00:21:00,570 --> 00:21:05,250
time and in a compile time context so if

00:21:03,420 --> 00:21:07,170
you try to you know return a function

00:21:05,250 --> 00:21:09,270
from main the function will still

00:21:07,170 --> 00:21:11,370
execute a compile time but then the

00:21:09,270 --> 00:21:13,920
value that is returned will be stored

00:21:11,370 --> 00:21:17,010
and then returned in a runtime context

00:21:13,920 --> 00:21:19,490
cost expert is sometimes at compile time

00:21:17,010 --> 00:21:22,290
and this is where the bridge

00:21:19,490 --> 00:21:24,870
concept of a bridge between these two

00:21:22,290 --> 00:21:27,390
boundaries for execution context comes

00:21:24,870 --> 00:21:29,520
in we can now detect and see what

00:21:27,390 --> 00:21:32,850
suppose 20 if we are running underneath

00:21:29,520 --> 00:21:34,710
a context pert context or not and then

00:21:32,850 --> 00:21:35,910
change our code dependent on that then

00:21:34,710 --> 00:21:38,940
sequel suppose 20 we will be able to

00:21:35,910 --> 00:21:41,550
have cost expert Cindy semantics because

00:21:38,940 --> 00:21:43,650
at cons you know at compile time we just

00:21:41,550 --> 00:21:46,050
do what it would normally do in a non

00:21:43,650 --> 00:21:48,090
efficient way and at compile time we can

00:21:46,050 --> 00:21:50,970
actually insert assembly instructions

00:21:48,090 --> 00:21:55,620
right I think that that's extremely

00:21:50,970 --> 00:21:57,780
powerful and allows you to also check to

00:21:55,620 --> 00:21:59,310
see like okay because a context where

00:21:57,780 --> 00:22:01,290
function cannot invoke undefined

00:21:59,310 --> 00:22:03,210
behavior you can kind of check your

00:22:01,290 --> 00:22:06,600
stuff with static assert at compile time

00:22:03,210 --> 00:22:09,330
and allow the you know the the type

00:22:06,600 --> 00:22:11,280
system to kick into place we also

00:22:09,330 --> 00:22:13,320
support virtual cost expert which yes

00:22:11,280 --> 00:22:14,430
this is terrifying because if you think

00:22:13,320 --> 00:22:17,370
about it means that you can have a

00:22:14,430 --> 00:22:20,490
virtual cost expert destructor so we can

00:22:17,370 --> 00:22:23,460
have compiled time polymorphism in the

00:22:20,490 --> 00:22:25,020
1990s style way of inheritance and

00:22:23,460 --> 00:22:27,240
virtual functions

00:22:25,020 --> 00:22:29,070
public inheritance and yes this also

00:22:27,240 --> 00:22:31,380
supports virtual based classes so if you

00:22:29,070 --> 00:22:33,210
remember that massive slide that

00:22:31,380 --> 00:22:34,770
everyone just like gasped in horror at

00:22:33,210 --> 00:22:39,240
the closing keynote last year that had a

00:22:34,770 --> 00:22:40,740
million virtual base classes that could

00:22:39,240 --> 00:22:46,470
technically be done at compile time as

00:22:40,740 --> 00:22:48,900
well that said though if we can do any

00:22:46,470 --> 00:22:51,810
of this I think rust can do it too I

00:22:48,900 --> 00:22:54,210
again not that part

00:22:51,810 --> 00:22:56,880
specifically I should note but just the

00:22:54,210 --> 00:22:58,830
ability to have like a dime trait B

00:22:56,880 --> 00:23:01,110
compile time I think is something that

00:22:58,830 --> 00:23:03,780
could potentially be in rust future

00:23:01,110 --> 00:23:05,700
wouldn't obviously be a Dyne trait I'd

00:23:03,780 --> 00:23:06,990
probably be a constant dine trait but

00:23:05,700 --> 00:23:09,630
that is something I think is definitely

00:23:06,990 --> 00:23:11,310
possible maybe not right now

00:23:09,630 --> 00:23:12,450
I'm not gonna write the proposal I have

00:23:11,310 --> 00:23:14,370
too many things going on in my life

00:23:12,450 --> 00:23:17,220
right now I have seventeen papers you

00:23:14,370 --> 00:23:18,690
need to get through the C++ standard so

00:23:17,220 --> 00:23:21,030
we're gonna talk about something here

00:23:18,690 --> 00:23:22,500
we're gonna be switching gears right the

00:23:21,030 --> 00:23:25,410
technical part of this talk is over with

00:23:22,500 --> 00:23:27,360
and this is we're gonna be leaning into

00:23:25,410 --> 00:23:28,950
this very slowly it's just let it build

00:23:27,360 --> 00:23:31,380
up but I promise what we over with it

00:23:28,950 --> 00:23:33,210
soon so in Ben arises talked he mentions

00:23:31,380 --> 00:23:35,550
that the FreeBSD community was telling

00:23:33,210 --> 00:23:37,770
those unhappy with system D to come to

00:23:35,550 --> 00:23:40,980
FreeBSD right and this is a problem

00:23:37,770 --> 00:23:42,420
because system DS creator even if he is

00:23:40,980 --> 00:23:43,680
an abrasive person even if you don't

00:23:42,420 --> 00:23:45,930
like him I don't think he deserves death

00:23:43,680 --> 00:23:47,790
threats and if these are the same people

00:23:45,930 --> 00:23:51,660
that are then going into the freebsd

00:23:47,790 --> 00:23:53,520
community that is a problem and those

00:23:51,660 --> 00:23:55,560
are not the people you want in a

00:23:53,520 --> 00:23:57,930
community right you don't want to find

00:23:55,560 --> 00:24:01,160
out that oh this speaker at a conference

00:23:57,930 --> 00:24:03,780
sent a death threat to someone that

00:24:01,160 --> 00:24:07,320
maintains a C++ compiler and also now

00:24:03,780 --> 00:24:10,070
they're running rust kind of like this

00:24:07,320 --> 00:24:13,230
sort of thing that happened here

00:24:10,070 --> 00:24:15,450
saying that the people in charge of C++

00:24:13,230 --> 00:24:18,150
are idiots and that it is academic

00:24:15,450 --> 00:24:20,520
masturbation is not going to win any

00:24:18,150 --> 00:24:23,190
points with anyone and furthermore

00:24:20,520 --> 00:24:24,930
saying oh we should try to get game

00:24:23,190 --> 00:24:26,490
developers to come to rust as one gonna

00:24:24,930 --> 00:24:27,660
make everyone here have an aneurysm when

00:24:26,490 --> 00:24:28,470
you have to see all the unsafe code

00:24:27,660 --> 00:24:30,150
they're gonna write because they're

00:24:28,470 --> 00:24:31,680
gonna use the unsafe keyword trust me

00:24:30,150 --> 00:24:33,450
I've already seen some of the code

00:24:31,680 --> 00:24:35,550
that's out there and also you don't want

00:24:33,450 --> 00:24:39,450
this kind of person to be talking to

00:24:35,550 --> 00:24:41,010
people in general right like

00:24:39,450 --> 00:24:43,710
do you do you want to have a

00:24:41,010 --> 00:24:46,200
conversation with this is like oh this

00:24:43,710 --> 00:24:49,290
is a tweet from a dude that has written

00:24:46,200 --> 00:24:52,800
a book on physics in C++ and using it

00:24:49,290 --> 00:24:56,400
over the network and and he lost his

00:24:52,800 --> 00:24:57,900
absolute mind at me I also wanted to

00:24:56,400 --> 00:25:00,960
show a few tweets from the VP of

00:24:57,900 --> 00:25:02,040
Technology activision but he blocked me

00:25:00,960 --> 00:25:03,390
on Twitter when I said the game

00:25:02,040 --> 00:25:06,150
companies that make billions of dollars

00:25:03,390 --> 00:25:08,520
should maybe pay their employees a valid

00:25:06,150 --> 00:25:10,080
salary and maybe they could just send

00:25:08,520 --> 00:25:10,920
representatives to C++ if they're that

00:25:10,080 --> 00:25:16,890
upset about it

00:25:10,920 --> 00:25:18,360
so you know I and also I don't I don't

00:25:16,890 --> 00:25:19,770
think you want people like this in your

00:25:18,360 --> 00:25:23,250
milieu right in your general social

00:25:19,770 --> 00:25:24,870
environment and if we start to see other

00:25:23,250 --> 00:25:27,180
implementations arise you may not have a

00:25:24,870 --> 00:25:29,850
choice but to interact with them right

00:25:27,180 --> 00:25:32,340
just because the rust community right

00:25:29,850 --> 00:25:34,140
now has a code of conduct and just

00:25:32,340 --> 00:25:35,520
because the rust subreddit has a code of

00:25:34,140 --> 00:25:38,040
conduct does not mean that an

00:25:35,520 --> 00:25:39,510
alternative implementation of rust has

00:25:38,040 --> 00:25:42,630
to follow those same code of conduct

00:25:39,510 --> 00:25:44,220
rules and that kind of brings this into

00:25:42,630 --> 00:25:47,180
the concept of standard versus

00:25:44,220 --> 00:25:50,130
specifications so all standards are a

00:25:47,180 --> 00:25:51,870
specification but not all specifications

00:25:50,130 --> 00:25:54,120
are a standard especially if they only

00:25:51,870 --> 00:25:55,860
apply to single product right if there

00:25:54,120 --> 00:25:57,660
was a specification for the rust

00:25:55,860 --> 00:25:59,550
compiler that would just be a

00:25:57,660 --> 00:26:02,460
specification for what the rust compiler

00:25:59,550 --> 00:26:04,680
can and cannot do it does not imply that

00:26:02,460 --> 00:26:06,240
if I write my own rust compiler that I

00:26:04,680 --> 00:26:08,810
have to implement every part of said

00:26:06,240 --> 00:26:12,150
specification thus there could be a

00:26:08,810 --> 00:26:14,100
standard rust in the future where bar or

00:26:12,150 --> 00:26:16,200
CK is not a part of that right and

00:26:14,100 --> 00:26:17,700
that's one of those powerful parts of

00:26:16,200 --> 00:26:19,140
the rust compiler but it is not part of

00:26:17,700 --> 00:26:21,930
the language the borrowed checker is

00:26:19,140 --> 00:26:25,740
just a static analysis tool it is not

00:26:21,930 --> 00:26:26,760
baked into the language itself and yeah

00:26:25,740 --> 00:26:27,870
that's terrified but we're gonna put

00:26:26,760 --> 00:26:31,170
that aside for now okay we're not gonna

00:26:27,870 --> 00:26:32,400
actually bring this up again so in C++

00:26:31,170 --> 00:26:34,470
were limited to the rules of ISO ISO

00:26:32,400 --> 00:26:36,960
actually has this hard rule of five

00:26:34,470 --> 00:26:39,720
years is them is the minimum at had time

00:26:36,960 --> 00:26:42,300
or the maximum amount of time you are

00:26:39,720 --> 00:26:43,170
allowed to release a standard between so

00:26:42,300 --> 00:26:45,030
the fact that we're doing that every

00:26:43,170 --> 00:26:48,840
three years in C++ we're kind of

00:26:45,030 --> 00:26:49,740
breaking the rules and rust is limited

00:26:48,840 --> 00:26:51,540
to the laws of the United States under

00:26:49,740 --> 00:26:53,040
which Mozilla operates right if they say

00:26:51,540 --> 00:26:55,230
you cannot

00:26:53,040 --> 00:26:59,960
provide software to someone in Iran

00:26:55,230 --> 00:27:02,100
right then all of Iran cannot use rust I

00:26:59,960 --> 00:27:03,930
could technically hand a USB Drive to

00:27:02,100 --> 00:27:06,000
someone from Germany and then that

00:27:03,930 --> 00:27:09,110
person could hand it to someone from

00:27:06,000 --> 00:27:11,070
Iran but I can't know about that at all

00:27:09,110 --> 00:27:14,280
this is where things start to get like

00:27:11,070 --> 00:27:16,080
really hairy in general ISO draws its

00:27:14,280 --> 00:27:17,700
authority from multiple nations each

00:27:16,080 --> 00:27:19,110
backed by treaties international

00:27:17,700 --> 00:27:21,690
trademark laws in some case they use

00:27:19,110 --> 00:27:23,160
their military to enforce these laws and

00:27:21,690 --> 00:27:26,220
by only the content found of this

00:27:23,160 --> 00:27:28,350
document so C++ the the working group 21

00:27:26,220 --> 00:27:32,220
C++ Standards Committee we don't own the

00:27:28,350 --> 00:27:34,080
C++ standard the ISO you know

00:27:32,220 --> 00:27:38,520
organization owns it

00:27:34,080 --> 00:27:40,590
ISO organization ATM machine so it's so

00:27:38,520 --> 00:27:42,750
there's this concept of a standard plate

00:27:40,590 --> 00:27:44,550
of spaghetti right a plate of spaghetti

00:27:42,750 --> 00:27:49,140
against which you could technically

00:27:44,550 --> 00:27:51,480
judge all other you know plates of

00:27:49,140 --> 00:27:53,040
spaghetti and if something doesn't meet

00:27:51,480 --> 00:27:56,420
that standard plate of spaghetti it can

00:27:53,040 --> 00:27:59,040
be deemed subpar so there is in fact a

00:27:56,420 --> 00:28:01,620
minimum amount of you know cooked

00:27:59,040 --> 00:28:04,170
spaghetti that you can meet and ISO owns

00:28:01,620 --> 00:28:08,400
the copyright and Trademark for set

00:28:04,170 --> 00:28:09,660
document membership access to I so by

00:28:08,400 --> 00:28:10,650
the way changes per country in the

00:28:09,660 --> 00:28:12,870
United States it's twenty two hundred

00:28:10,650 --> 00:28:15,840
dollars a year and you can also get some

00:28:12,870 --> 00:28:17,430
of that money just made to disappear or

00:28:15,840 --> 00:28:19,170
that requirement to disappear if you

00:28:17,430 --> 00:28:20,700
make less than three million dollars as

00:28:19,170 --> 00:28:24,030
a result United States national body for

00:28:20,700 --> 00:28:25,800
ISO is massive we have tons of companies

00:28:24,030 --> 00:28:27,270
that are not based in the United States

00:28:25,800 --> 00:28:29,190
because it's just easier to join the

00:28:27,270 --> 00:28:33,060
u.s. one than it is to join their own

00:28:29,190 --> 00:28:35,130
countries ECMA is an alternative

00:28:33,060 --> 00:28:36,480
organization to ISO and draws its

00:28:35,130 --> 00:28:39,060
authority from the same sources except

00:28:36,480 --> 00:28:40,260
it's based out of Switzerland what

00:28:39,060 --> 00:28:42,270
corporations have as much of a say

00:28:40,260 --> 00:28:45,210
there's a national body if Google pay

00:28:42,270 --> 00:28:48,960
$17,000 and I n CITS the American

00:28:45,210 --> 00:28:51,570
standards body pay $17,000 they have an

00:28:48,960 --> 00:28:53,610
equal say it's also prohibitively

00:28:51,570 --> 00:28:55,020
expensive I think the the minimum amount

00:28:53,610 --> 00:28:57,510
of money you need to pay per year for

00:28:55,020 --> 00:28:59,310
voting rights is 17,000 Swiss marks or

00:28:57,510 --> 00:28:59,580
whatever their currency as I don't care

00:28:59,310 --> 00:29:02,630
anymore

00:28:59,580 --> 00:29:05,470
I don't pay attention to that stuff so

00:29:02,630 --> 00:29:07,120
Mozilla draws its authority for me

00:29:05,470 --> 00:29:08,080
it's corporate laws such as intellectual

00:29:07,120 --> 00:29:10,299
property laws that can be used to

00:29:08,080 --> 00:29:12,250
threaten permanent destitution to anyone

00:29:10,299 --> 00:29:14,020
violating them if a court scene Dean's

00:29:12,250 --> 00:29:16,720
and someone has violated these laws

00:29:14,020 --> 00:29:18,880
right if a judge says yes you are in

00:29:16,720 --> 00:29:21,179
violation of this intellectual property

00:29:18,880 --> 00:29:25,270
and as a result I'm going to find you

00:29:21,179 --> 00:29:28,480
$500 a day until you decide to come in

00:29:25,270 --> 00:29:33,070
line with these rules that can seriously

00:29:28,480 --> 00:29:34,960
limit your future and currently Chelsea

00:29:33,070 --> 00:29:36,309
Manning is I believe paying $1,000 a day

00:29:34,960 --> 00:29:38,289
for refusing to testify in front of a

00:29:36,309 --> 00:29:41,860
grand jury she could use some help

00:29:38,289 --> 00:29:44,559
financially by the way and in the above

00:29:41,860 --> 00:29:47,140
cases a person does not have the power

00:29:44,559 --> 00:29:48,970
to say something right without some

00:29:47,140 --> 00:29:51,400
labor derived a reason right so if

00:29:48,970 --> 00:29:53,740
something isn't for work then changes

00:29:51,400 --> 00:29:55,539
people's supposed to write rest might be

00:29:53,740 --> 00:29:57,429
dismissed right if I'm not doing it for

00:29:55,539 --> 00:29:58,419
a project then you can just ignore my

00:29:57,429 --> 00:29:59,740
changes

00:29:58,419 --> 00:30:01,179
this takes power away from users and

00:29:59,740 --> 00:30:02,830
replaces it with submission to Authority

00:30:01,179 --> 00:30:04,539
also I'm sorry I'm getting the note that

00:30:02,830 --> 00:30:06,610
I need to speed up here and basically

00:30:04,539 --> 00:30:10,600
wrap up so I'm just gonna skip ahead

00:30:06,610 --> 00:30:14,200
here and the the thing I'm trying to get

00:30:10,600 --> 00:30:17,380
at here I guess is that can get to a lot

00:30:14,200 --> 00:30:22,419
of this stuff I tried so hard got so far

00:30:17,380 --> 00:30:24,240
to the end didn't even matter so I guess

00:30:22,419 --> 00:30:27,610
the thing I'm trying to say is that I

00:30:24,240 --> 00:30:29,980
don't want rust to standardize I think

00:30:27,610 --> 00:30:33,309
that trying to force it into an

00:30:29,980 --> 00:30:36,370
organization that has to be backed by a

00:30:33,309 --> 00:30:39,460
nation state to enforce it is a mistake

00:30:36,370 --> 00:30:44,110
and what rust really needs is some kind

00:30:39,460 --> 00:30:45,159
of informal body to well also by the way

00:30:44,110 --> 00:30:46,870
I'm an Turkish I don't have all the

00:30:45,159 --> 00:30:48,190
answers and apparently neither do I have

00:30:46,870 --> 00:30:52,750
the time to finish this upset where's

00:30:48,190 --> 00:30:54,130
going yeah so so if in a formal body for

00:30:52,750 --> 00:30:55,539
homeless Tanner does not exist I don't

00:30:54,130 --> 00:30:56,860
know if it could exist and how you would

00:30:55,539 --> 00:30:58,450
even force any of these things it's very

00:30:56,860 --> 00:30:59,590
difficult to talk about this stuff and

00:30:58,450 --> 00:31:01,600
this is something that I would rather

00:30:59,590 --> 00:31:02,770
have had a lot more time to get to this

00:31:01,600 --> 00:31:07,630
point maybe I should have pushed it

00:31:02,770 --> 00:31:08,890
further up in the talk and you know you

00:31:07,630 --> 00:31:09,970
offer responsible yourselves new

00:31:08,890 --> 00:31:13,210
communities well since the industries

00:31:09,970 --> 00:31:15,610
we're working and I guess what's gonna

00:31:13,210 --> 00:31:18,010
closes this talk up with this you know

00:31:15,610 --> 00:31:19,180
if if you want to hide horrors and fight

00:31:18,010 --> 00:31:22,240
for major catastrophe

00:31:19,180 --> 00:31:23,440
you have to feel pain to be alone that's

00:31:22,240 --> 00:31:27,460
not language evangelism

00:31:23,440 --> 00:31:28,960
that's language Evangelion ISM and I'm

00:31:27,460 --> 00:31:31,120
sorry that this talk ended up going over

00:31:28,960 --> 00:31:33,880
the time here I guess we're out of time

00:31:31,120 --> 00:31:36,580
yeah so I will be putting these slides

00:31:33,880 --> 00:31:39,670
up on github so feel free to check that

00:31:36,580 --> 00:31:41,440
out later and if you want to actually

00:31:39,670 --> 00:31:43,120
have the important part of the talk that

00:31:41,440 --> 00:31:46,600
I wanted to get to which is please don't

00:31:43,120 --> 00:31:50,200
make a standard that has to close off

00:31:46,600 --> 00:31:51,640
access to the current milieu that is in

00:31:50,200 --> 00:31:53,770
this room that is if this conference

00:31:51,640 --> 00:31:57,040
that is at other conferences and

00:31:53,770 --> 00:31:59,620
requires people to pay to to vote I

00:31:57,040 --> 00:32:01,030
highly suggest that you you look into

00:31:59,620 --> 00:32:02,410
alternatives even if they don't exist

00:32:01,030 --> 00:32:03,930
yet even if you have to make something

00:32:02,410 --> 00:32:09,270
new

00:32:03,930 --> 00:32:16,690
[Applause]

00:32:09,270 --> 00:32:16,690
[Music]

00:32:19,160 --> 00:32:21,220

YouTube URL: https://www.youtube.com/watch?v=YZomx3Jt4Xs


