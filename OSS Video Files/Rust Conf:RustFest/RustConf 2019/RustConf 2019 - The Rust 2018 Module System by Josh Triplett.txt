Title: RustConf 2019 - The Rust 2018 Module System by Josh Triplett
Publication date: 2019-09-16
Playlist: RustConf 2019
Description: 
	RustConf 2019 - The Rust 2018 Module System by Josh Triplett

The Rust 2018 edition, as one of its flagship highlights, introduced a new module system, aimed to simplify the use of modules and crates for everyone. This talk will provide full documentation and exploration of the new module system, including motivations and mode of thinking, the practical impact of changes, and future enhancements in progress.

Whether you've had difficulties with modules in the past, or you're an experienced module user who wants to understand all the corners of the new system, come find out the present and future of modules in Rust!
Captions: 
	00:00:08,770 --> 00:00:15,680
[Music]

00:00:16,790 --> 00:00:21,890
thanks for the introduction all right so

00:00:20,060 --> 00:00:24,260
yeah I'm gonna be telling you a little

00:00:21,890 --> 00:00:26,060
bit about the Russ 2018 module system

00:00:24,260 --> 00:00:28,760
but to build up to that I want to give a

00:00:26,060 --> 00:00:31,100
little bit of history about both myself

00:00:28,760 --> 00:00:33,230
and how I came to be giving this

00:00:31,100 --> 00:00:35,420
particular talk and what other types of

00:00:33,230 --> 00:00:37,610
things I want to be covering with it so

00:00:35,420 --> 00:00:39,770
I first got involved with rust a while

00:00:37,610 --> 00:00:41,809
before the first rust comp here in

00:00:39,770 --> 00:00:44,750
Portland three years ago and I gave a

00:00:41,809 --> 00:00:46,239
talk at that first rust conf called in

00:00:44,750 --> 00:00:51,290
order to form a more perfect union

00:00:46,239 --> 00:00:53,780
because I've been working on c-style

00:00:51,290 --> 00:00:56,269
unions for rust I work I got those

00:00:53,780 --> 00:00:58,159
contributed as part of an RFC so that I

00:00:56,269 --> 00:01:00,500
could support building virtual machines

00:00:58,159 --> 00:01:02,540
based on Linux and the dev KBM interface

00:01:00,500 --> 00:01:04,370
and this was something I was really

00:01:02,540 --> 00:01:06,229
excited about it did eventually get

00:01:04,370 --> 00:01:08,510
merged and released and there are now

00:01:06,229 --> 00:01:09,500
many virtual machines based on rust

00:01:08,510 --> 00:01:13,130
which I'm incredibly excited

00:01:09,500 --> 00:01:15,440
enthusiastic about but that talk was not

00:01:13,130 --> 00:01:20,060
just about a specific language feature

00:01:15,440 --> 00:01:22,850
that talk was also about how we build a

00:01:20,060 --> 00:01:25,700
more perfect rust through the RFC system

00:01:22,850 --> 00:01:28,310
it was a case study on the RFC process

00:01:25,700 --> 00:01:31,190
how we evolved rust and how we interact

00:01:28,310 --> 00:01:33,830
with the rust community I love the rest

00:01:31,190 --> 00:01:36,560
community it's incredibly fun incredibly

00:01:33,830 --> 00:01:38,270
energizing to work with it is the most

00:01:36,560 --> 00:01:41,960
fun open-source community I've ever

00:01:38,270 --> 00:01:43,940
worked with and as a result of that talk

00:01:41,960 --> 00:01:46,370
and other work that I'd been doing I

00:01:43,940 --> 00:01:48,320
ended up getting involved with the rust

00:01:46,370 --> 00:01:50,810
language team and later the rust cargo

00:01:48,320 --> 00:01:52,880
team and from that perspective I'd like

00:01:50,810 --> 00:01:54,830
to tell you about the new module system

00:01:52,880 --> 00:01:58,160
that was developed for the rust 2018

00:01:54,830 --> 00:01:59,810
edition but as before that's not the

00:01:58,160 --> 00:02:02,060
only thing this talk is about it's

00:01:59,810 --> 00:02:03,860
really about how the language team works

00:02:02,060 --> 00:02:06,140
what the processes are behind the scenes

00:02:03,860 --> 00:02:06,800
what it's like to be in the room where

00:02:06,140 --> 00:02:11,060
it happens

00:02:06,800 --> 00:02:13,400
and the so I want to go into some more

00:02:11,060 --> 00:02:16,970
detail about how we iterate on a

00:02:13,400 --> 00:02:18,950
solution and how over a couple of years

00:02:16,970 --> 00:02:20,450
we managed to develop this module system

00:02:18,950 --> 00:02:24,200
starting from I think there's a problem

00:02:20,450 --> 00:02:26,060
here so not long after I got involved

00:02:24,200 --> 00:02:28,730
there was an effort called the

00:02:26,060 --> 00:02:30,560
ergonomics initiative that was aiming to

00:02:28,730 --> 00:02:32,300
try to provide further simplicity

00:02:30,560 --> 00:02:35,090
for the language as well as a measure of

00:02:32,300 --> 00:02:37,340
consistency how can we not just add

00:02:35,090 --> 00:02:39,920
things to the language but how do we

00:02:37,340 --> 00:02:41,480
improve what we have how do we simplify

00:02:39,920 --> 00:02:45,800
what we have and make it a lot more

00:02:41,480 --> 00:02:47,120
usable for people so in January 2017

00:02:45,800 --> 00:02:50,030
we started having some interesting

00:02:47,120 --> 00:02:51,530
discussions about the module system one

00:02:50,030 --> 00:02:55,069
of the members of the language team made

00:02:51,530 --> 00:02:56,690
a blog post talking about the usability

00:02:55,069 --> 00:02:58,370
of the module system what problems they

00:02:56,690 --> 00:03:00,950
saw that kicked off a whole bunch of

00:02:58,370 --> 00:03:03,170
discussion many other people made posts

00:03:00,950 --> 00:03:06,049
and discussions and how to offline

00:03:03,170 --> 00:03:08,600
conversations and we started discussing

00:03:06,049 --> 00:03:11,180
well what do we use modules for what

00:03:08,600 --> 00:03:13,459
purpose should they serve and how do we

00:03:11,180 --> 00:03:15,049
want them to work so I want to give a

00:03:13,459 --> 00:03:18,739
little bit of overview of how Rus

00:03:15,049 --> 00:03:22,160
modules work and what style they form

00:03:18,739 --> 00:03:23,750
starting with the Rus 2015 module system

00:03:22,160 --> 00:03:25,849
so that I can contrast that a little bit

00:03:23,750 --> 00:03:27,370
so a bit of review for anyone who

00:03:25,849 --> 00:03:31,340
doesn't already know

00:03:27,370 --> 00:03:33,980
rust in Rus terminology a module is one

00:03:31,340 --> 00:03:35,959
organizational unit of code often but

00:03:33,980 --> 00:03:40,040
not always corresponding to one source

00:03:35,959 --> 00:03:43,700
file in rust and a crate is a library or

00:03:40,040 --> 00:03:45,530
a group of modules that is used as a

00:03:43,700 --> 00:03:49,130
reusable library within the rest

00:03:45,530 --> 00:03:51,230
ecosystem so the other piece of

00:03:49,130 --> 00:03:52,489
terminology and syntax that I need to

00:03:51,230 --> 00:03:55,970
introduce if you haven't seen it before

00:03:52,489 --> 00:03:57,980
is that rust modules can correspond

00:03:55,970 --> 00:04:00,290
precisely to a file you can say mod

00:03:57,980 --> 00:04:03,920
example semicolon and you will get a

00:04:00,290 --> 00:04:06,230
module from example RS but you can also

00:04:03,920 --> 00:04:08,239
say mod example and then put curly

00:04:06,230 --> 00:04:10,760
braces and you can inline the contents

00:04:08,239 --> 00:04:12,049
of a module this is really useful if

00:04:10,760 --> 00:04:14,120
you're just using them as a local

00:04:12,049 --> 00:04:15,799
organization tool within a large file

00:04:14,120 --> 00:04:17,720
they're also really useful if you're

00:04:15,799 --> 00:04:18,950
trying to give examples on slides and

00:04:17,720 --> 00:04:22,430
don't want to say this is part of this

00:04:18,950 --> 00:04:25,550
file and this is part of this file so

00:04:22,430 --> 00:04:28,700
with that in mind here's what normal use

00:04:25,550 --> 00:04:30,320
of some rust dependencies look like this

00:04:28,700 --> 00:04:33,500
is using the command line argument

00:04:30,320 --> 00:04:34,820
parser clap in cargo Tamil which is this

00:04:33,500 --> 00:04:38,000
is the only time I'll be showing this

00:04:34,820 --> 00:04:40,220
part you add I want to use this version

00:04:38,000 --> 00:04:42,299
of this crate it will automatically get

00:04:40,220 --> 00:04:44,699
pulled in by cargo and

00:04:42,299 --> 00:04:46,559
somewhere in your main program or your

00:04:44,699 --> 00:04:50,039
main library you can say I have this

00:04:46,559 --> 00:04:52,259
external crate named clap and I want to

00:04:50,039 --> 00:04:54,119
use potentially this thing in it without

00:04:52,259 --> 00:04:55,889
having to give the full path to it and

00:04:54,119 --> 00:04:58,649
then I could define a function that uses

00:04:55,889 --> 00:05:01,319
pieces of it so I could reference clap

00:04:58,649 --> 00:05:03,509
app or I can reference just argh after

00:05:01,319 --> 00:05:06,539
I've said use clap argh so this is the

00:05:03,509 --> 00:05:07,199
2015 module system and this is how it

00:05:06,539 --> 00:05:10,079
works

00:05:07,199 --> 00:05:12,449
when you're in the top level module main

00:05:10,079 --> 00:05:15,029
dot RS or libbed RS depending on if your

00:05:12,449 --> 00:05:18,269
program or a library and most crates

00:05:15,029 --> 00:05:20,279
start with just one module they start

00:05:18,269 --> 00:05:21,779
out building things up from scratch they

00:05:20,279 --> 00:05:23,939
do some interesting stuff they put it in

00:05:21,779 --> 00:05:26,639
main they put it in Lib and everything

00:05:23,939 --> 00:05:29,939
works nice and simple and the problem is

00:05:26,639 --> 00:05:32,129
that paths for crates as among many

00:05:29,939 --> 00:05:34,229
other things worked differently once you

00:05:32,129 --> 00:05:37,229
created sub modules which made it harder

00:05:34,229 --> 00:05:38,399
for people to introduce modularity into

00:05:37,229 --> 00:05:40,739
their program they start building

00:05:38,399 --> 00:05:42,869
something with a single module they add

00:05:40,739 --> 00:05:44,939
more modules and suddenly they run

00:05:42,869 --> 00:05:47,339
headlong into the brick wall of I didn't

00:05:44,939 --> 00:05:49,619
know about this part of the language so

00:05:47,339 --> 00:05:51,389
if I define a sub module say I want to

00:05:49,619 --> 00:05:54,059
move argument parsing all off to

00:05:51,389 --> 00:05:57,019
somewhere else in the program then use

00:05:54,059 --> 00:06:01,889
looks the same I still use clap : : argh

00:05:57,019 --> 00:06:04,529
but the usage suddenly I have to say : :

00:06:01,889 --> 00:06:07,319
clap : : app if I want to reference it

00:06:04,529 --> 00:06:08,969
if I try if I leave that out I get a

00:06:07,319 --> 00:06:10,679
compile-time error saying well I don't

00:06:08,969 --> 00:06:14,339
know what clap is even though you can

00:06:10,679 --> 00:06:17,039
use clap you can't reference clap so

00:06:14,339 --> 00:06:19,289
this was really confusing to a lot of

00:06:17,039 --> 00:06:20,969
people and it was especially confusing

00:06:19,289 --> 00:06:23,879
because you didn't hit it until you

00:06:20,969 --> 00:06:25,589
introduced sub modules another problem

00:06:23,879 --> 00:06:27,899
is that paths for sub modules themselves

00:06:25,589 --> 00:06:29,419
also worked differently in sub modules

00:06:27,899 --> 00:06:31,919
when you've organized your program

00:06:29,419 --> 00:06:33,809
referencing pieces of that program from

00:06:31,919 --> 00:06:35,159
other pieces of your program works

00:06:33,809 --> 00:06:37,559
differently depending on where you're

00:06:35,159 --> 00:06:39,749
doing it from so let's say I defined

00:06:37,559 --> 00:06:41,879
this module this small module that

00:06:39,749 --> 00:06:46,409
defines a few public structures s1 and

00:06:41,879 --> 00:06:47,969
s2 I can go use em the module : : s1 and

00:06:46,409 --> 00:06:50,039
then I can name s1 anywhere I want I

00:06:47,969 --> 00:06:51,779
could use it as the type of arg1 or I

00:06:50,039 --> 00:06:53,639
can directly name something if I'm only

00:06:51,779 --> 00:06:55,500
going to reference it once for example M

00:06:53,639 --> 00:06:56,970
: : s2

00:06:55,500 --> 00:07:00,570
now let me move that into a sub-module

00:06:56,970 --> 00:07:04,830
and I still reference arguments by

00:07:00,570 --> 00:07:08,970
saying M : : s - in aargh - here but

00:07:04,830 --> 00:07:12,600
notice that I have to say self : : : : s

00:07:08,970 --> 00:07:14,100
1 by the end of this talk : is probably

00:07:12,600 --> 00:07:16,350
going to stop sounding like an English

00:07:14,100 --> 00:07:18,530
word so forgive me in advance for you

00:07:16,350 --> 00:07:22,170
know your brain for the following hour

00:07:18,530 --> 00:07:24,420
the the problem again with this is this

00:07:22,170 --> 00:07:26,340
is unexpected you get an error saying I

00:07:24,420 --> 00:07:27,690
don't know what M is you stare at it

00:07:26,340 --> 00:07:29,730
you're like M is that thing I just

00:07:27,690 --> 00:07:32,670
defined and told you about you should

00:07:29,730 --> 00:07:34,710
understand this so these are the types

00:07:32,670 --> 00:07:37,980
of inconsistencies that we saw when

00:07:34,710 --> 00:07:40,340
saying why does the rust 2015 module

00:07:37,980 --> 00:07:43,020
system work the way that it does and

00:07:40,340 --> 00:07:44,700
these introduced big surprises when you

00:07:43,020 --> 00:07:46,380
add modules to an existing one file

00:07:44,700 --> 00:07:48,930
project there were also many other

00:07:46,380 --> 00:07:50,250
improvements that we wanted to make out

00:07:48,930 --> 00:07:52,620
of this system and I'll talk about some

00:07:50,250 --> 00:07:54,540
of those later but I also want to take a

00:07:52,620 --> 00:07:56,370
moment here and say this is not yeah not

00:07:54,540 --> 00:07:58,500
just to talk about how we wanted to fix

00:07:56,370 --> 00:08:00,450
the module system this is also a talk

00:07:58,500 --> 00:08:02,550
about development and consensus

00:08:00,450 --> 00:08:05,070
processes and how we reach to the

00:08:02,550 --> 00:08:07,560
successful module system so let's look

00:08:05,070 --> 00:08:09,150
at the requirements we have so far first

00:08:07,560 --> 00:08:11,340
of all we said you really shouldn't have

00:08:09,150 --> 00:08:12,720
to say extern crate it's a little

00:08:11,340 --> 00:08:15,540
redundant when you look at that first

00:08:12,720 --> 00:08:17,970
example you had define it in cargo tamil

00:08:15,540 --> 00:08:20,460
ad extern crate and then use it or

00:08:17,970 --> 00:08:21,960
reference it that's three places that

00:08:20,460 --> 00:08:23,640
you have to name it well one of those is

00:08:21,960 --> 00:08:25,110
actually using it and one of those is

00:08:23,640 --> 00:08:27,360
saying where it's version is so those

00:08:25,110 --> 00:08:30,030
are clearly required extern crate just

00:08:27,360 --> 00:08:32,219
feels redundant in that regard so we

00:08:30,030 --> 00:08:34,260
said you shouldn't have to do that we

00:08:32,219 --> 00:08:37,589
also said that you should have the same

00:08:34,260 --> 00:08:39,960
syntax in the top-level module and in

00:08:37,589 --> 00:08:41,640
sub modules I should say I'm glossing a

00:08:39,960 --> 00:08:43,020
little bit over the requirements here of

00:08:41,640 --> 00:08:45,300
these are kind of what we eventually

00:08:43,020 --> 00:08:46,950
figured out the requirements were but

00:08:45,300 --> 00:08:48,300
this is about what we ended up at that

00:08:46,950 --> 00:08:50,190
these are the most important things we

00:08:48,300 --> 00:08:52,230
wanted the same syntax whether you were

00:08:50,190 --> 00:08:55,530
in main dot RS or two levels down or

00:08:52,230 --> 00:08:58,080
three levels down so this led to some

00:08:55,530 --> 00:09:00,360
very extensive discussion in language

00:08:58,080 --> 00:09:03,270
team meetings many times over we have

00:09:00,360 --> 00:09:05,250
regular weekly video calls with all of

00:09:03,270 --> 00:09:07,260
the members of the language team we had

00:09:05,250 --> 00:09:09,420
discussions on the in rust internals

00:09:07,260 --> 00:09:12,810
forum which is a discourse instance

00:09:09,420 --> 00:09:14,580
we had discussions on discord the chat

00:09:12,810 --> 00:09:16,320
service and a number of in-person

00:09:14,580 --> 00:09:17,760
discussions and pretty much anywhere

00:09:16,320 --> 00:09:20,060
else we were talking about things this

00:09:17,760 --> 00:09:23,220
was one of our top topics to go through

00:09:20,060 --> 00:09:25,620
we also debated things like should you

00:09:23,220 --> 00:09:27,930
have to reference external crates

00:09:25,620 --> 00:09:30,450
especially with extern : : or should you

00:09:27,930 --> 00:09:32,250
reference your own crate specially we

00:09:30,450 --> 00:09:34,290
were trying to figure out what is the

00:09:32,250 --> 00:09:35,880
unusual case and what is the common case

00:09:34,290 --> 00:09:37,260
and we kept going back and forth because

00:09:35,880 --> 00:09:39,600
it felt like if we're going to be

00:09:37,260 --> 00:09:42,150
consistent about paths one of these

00:09:39,600 --> 00:09:45,000
would have to be qualified somehow and

00:09:42,150 --> 00:09:47,100
one of them wouldn't so this resulted in

00:09:45,000 --> 00:09:50,150
a series of not one not two but three

00:09:47,100 --> 00:09:53,040
separate RFC's trying to get this right

00:09:50,150 --> 00:09:54,990
the first two were closed the third one

00:09:53,040 --> 00:09:59,640
had eventually reached an approach that

00:09:54,990 --> 00:10:01,410
we all had a rough consensus on so the

00:09:59,640 --> 00:10:04,080
approach is what we later came to call

00:10:01,410 --> 00:10:05,790
anchored use paths we didn't name it at

00:10:04,080 --> 00:10:08,340
first for much the same reason that rust

00:10:05,790 --> 00:10:09,810
2015 wasn't originally called rust 2015

00:10:08,340 --> 00:10:12,900
until we had to distinguish it from rust

00:10:09,810 --> 00:10:15,600
2018 but we eventually called it

00:10:12,900 --> 00:10:17,550
anchored use paths and the idea was that

00:10:15,600 --> 00:10:19,740
use paths always had to start with

00:10:17,550 --> 00:10:23,760
something that referenced a crate either

00:10:19,740 --> 00:10:26,490
a crate name like clap : : or ray on : :

00:10:23,760 --> 00:10:29,070
or your own current crate in which case

00:10:26,490 --> 00:10:31,020
they would be crate : : or you could

00:10:29,070 --> 00:10:33,420
still use self if you wanted to use

00:10:31,020 --> 00:10:35,400
relative names but you didn't have to or

00:10:33,420 --> 00:10:36,960
you could use super to reference the

00:10:35,400 --> 00:10:39,750
parent module which was really common

00:10:36,960 --> 00:10:42,090
when writing things like mod tests let

00:10:39,750 --> 00:10:44,520
me pull in things from super in order to

00:10:42,090 --> 00:10:47,610
test them so we finally had language

00:10:44,520 --> 00:10:49,830
team consensus on this RFC 21:26 called

00:10:47,610 --> 00:10:51,240
path clarity and that's exactly what it

00:10:49,830 --> 00:10:52,860
was trying to provide is clear up a

00:10:51,240 --> 00:10:54,140
bunch of the confusion around how do you

00:10:52,860 --> 00:10:57,750
reference paths

00:10:54,140 --> 00:11:00,660
it wasn't however not fully satisfying

00:10:57,750 --> 00:11:02,430
exactly it had a fairly mixed community

00:11:00,660 --> 00:11:04,050
reaction and there was something about

00:11:02,430 --> 00:11:06,510
reading through it and dealing with it

00:11:04,050 --> 00:11:09,360
that felt kind of okay this technically

00:11:06,510 --> 00:11:11,880
meets all the requirements but so to

00:11:09,360 --> 00:11:15,480
best sum up what we later realized the

00:11:11,880 --> 00:11:18,120
issue with it was I want to use a post

00:11:15,480 --> 00:11:20,670
that Aaron Turan used to describe the

00:11:18,120 --> 00:11:22,590
module system as proposed he said these

00:11:20,670 --> 00:11:23,310
situations meaning dealing with sub

00:11:22,590 --> 00:11:26,310
modules are

00:11:23,310 --> 00:11:28,680
Achille bad in Rus 2015 because the code

00:11:26,310 --> 00:11:31,980
works without self : : a top-level

00:11:28,680 --> 00:11:33,510
module but not elsewhere the rus 2018 s

00:11:31,980 --> 00:11:37,560
current design helps by making the code

00:11:33,510 --> 00:11:41,040
not work anywhere ok technically that's

00:11:37,560 --> 00:11:43,529
a consistency uh it also would have

00:11:41,040 --> 00:11:45,600
required changing most existing rust

00:11:43,529 --> 00:11:48,150
code out there to change how it

00:11:45,600 --> 00:11:49,589
referenced modules rust fix would have

00:11:48,150 --> 00:11:51,000
potentially helped with this and it

00:11:49,589 --> 00:11:53,339
would have been essential to have that

00:11:51,000 --> 00:11:55,770
available but none of us were wildly

00:11:53,339 --> 00:11:58,920
excited about what felt like it would be

00:11:55,770 --> 00:12:01,050
the most invasive rust 2018 change

00:11:58,920 --> 00:12:04,310
please go change all your programs to

00:12:01,050 --> 00:12:08,160
use this new module system so around

00:12:04,310 --> 00:12:10,830
June ich of 2018 maybe a few somewhere

00:12:08,160 --> 00:12:13,470
in those months Aaron and I had a

00:12:10,830 --> 00:12:15,660
discussion on discord that amounted to

00:12:13,470 --> 00:12:17,279
ok this is where we ended up this was

00:12:15,660 --> 00:12:19,230
the consensus we had could we talk about

00:12:17,279 --> 00:12:21,360
how we got there and why we couldn't

00:12:19,230 --> 00:12:22,920
judge it was one of those like are we

00:12:21,360 --> 00:12:24,839
really here is this really what we're

00:12:22,920 --> 00:12:26,760
about to do kinds of conversations and

00:12:24,839 --> 00:12:28,080
to look over it we talked about well

00:12:26,760 --> 00:12:30,240
what are the additional requirements

00:12:28,080 --> 00:12:33,120
would really love to have if we could

00:12:30,240 --> 00:12:34,950
and what we said was that the new

00:12:33,120 --> 00:12:38,670
requirements were we'd like to have

00:12:34,950 --> 00:12:41,760
uniform paths between use and between

00:12:38,670 --> 00:12:44,220
expressions so that the same paths that

00:12:41,760 --> 00:12:46,860
you can use anywhere in your program to

00:12:44,220 --> 00:12:49,320
reference a module or a crate you could

00:12:46,860 --> 00:12:52,200
always take that path and hoist it up to

00:12:49,320 --> 00:12:54,780
a use declaration so if you can write a

00:12:52,200 --> 00:12:57,990
: : b : : C you should always be able to

00:12:54,780 --> 00:13:00,360
use a colon : b : : c and then just

00:12:57,990 --> 00:13:02,190
write c it's a very nice property when

00:13:00,360 --> 00:13:03,900
you're used to like IDE refactoring

00:13:02,190 --> 00:13:05,580
tools and similar you feel like this

00:13:03,900 --> 00:13:08,550
name should look the same as this name

00:13:05,580 --> 00:13:10,830
and then I just shortened this name so

00:13:08,550 --> 00:13:12,270
with that in mind we also wanted

00:13:10,830 --> 00:13:14,940
something that was compatible with the

00:13:12,270 --> 00:13:16,980
majority of rust 2015 code out there we

00:13:14,940 --> 00:13:19,200
said this edition should be an

00:13:16,980 --> 00:13:21,900
opportunity to have new features and

00:13:19,200 --> 00:13:23,550
exciting new things and not worry that

00:13:21,900 --> 00:13:25,260
we are breaking things but at the same

00:13:23,550 --> 00:13:28,680
time we shouldn't gratuitously break

00:13:25,260 --> 00:13:31,380
everything if we can help it so the

00:13:28,680 --> 00:13:34,890
concept here was one of uniform path

00:13:31,380 --> 00:13:36,959
resolution the idea was you could check

00:13:34,890 --> 00:13:40,499
a series of things

00:13:36,959 --> 00:13:43,139
and whenever you name an identifier name

00:13:40,499 --> 00:13:45,269
a path you would first check whatever

00:13:43,139 --> 00:13:48,089
was in the local scope the whole while I

00:13:45,269 --> 00:13:50,579
just told you what mod iam is then check

00:13:48,089 --> 00:13:52,199
crates that you have available and check

00:13:50,579 --> 00:13:54,240
the pre lewd which is where we put

00:13:52,199 --> 00:13:56,759
things that are automatically in scope

00:13:54,240 --> 00:14:00,089
that you can always name like option and

00:13:56,759 --> 00:14:03,449
result so here is some rust

00:14:00,089 --> 00:14:05,970
20:18 code that uses that as an example

00:14:03,449 --> 00:14:10,470
we define those same two struts in a sub

00:14:05,970 --> 00:14:13,829
sub module we can just use em : : sub s1

00:14:10,470 --> 00:14:16,170
and it works and we can also name em : :

00:14:13,829 --> 00:14:19,949
s2 it's the same syntax whether you're

00:14:16,170 --> 00:14:22,259
gonna use or in argument but we can also

00:14:19,949 --> 00:14:25,379
do the same thing for crates we can use

00:14:22,259 --> 00:14:28,079
clap : : argh that still looks for a

00:14:25,379 --> 00:14:30,300
crate name in the previous proposal this

00:14:28,079 --> 00:14:33,749
would have required potentially naming

00:14:30,300 --> 00:14:36,269
it explicitly or you would have needed

00:14:33,749 --> 00:14:37,679
something to reference the previous case

00:14:36,269 --> 00:14:39,209
one or the other case would have had to

00:14:37,679 --> 00:14:41,610
have been decorated somehow to be

00:14:39,209 --> 00:14:43,620
unambiguous and you can also reference

00:14:41,610 --> 00:14:45,779
crate names in expressions like this

00:14:43,620 --> 00:14:47,519
clap : : app no matter where you are in

00:14:45,779 --> 00:14:51,120
the program that will always work if you

00:14:47,519 --> 00:14:53,040
have clap in use so this does introduce

00:14:51,120 --> 00:14:54,540
a kind of search ambiguity it's

00:14:53,040 --> 00:14:56,279
effectively saying well I'm going to do

00:14:54,540 --> 00:14:58,290
the right thing when I see a name like

00:14:56,279 --> 00:15:00,230
clap do you have a local variable named

00:14:58,290 --> 00:15:03,149
clap or do you have a crate named clap

00:15:00,230 --> 00:15:05,189
but it's only ambiguous if a name in

00:15:03,149 --> 00:15:06,569
scope conflicts with an extern crate

00:15:05,189 --> 00:15:08,009
name that's not a situation that comes

00:15:06,569 --> 00:15:12,120
up that often it does happen sometimes

00:15:08,009 --> 00:15:14,129
but there's a way to disambiguate that

00:15:12,120 --> 00:15:16,350
and then in the end if you have an

00:15:14,129 --> 00:15:18,259
ambiguous case i've got the same name

00:15:16,350 --> 00:15:20,939
for a crate and a module in a variable

00:15:18,259 --> 00:15:23,220
then I can disambiguate it I can still

00:15:20,939 --> 00:15:25,470
write crate : : to reference my own

00:15:23,220 --> 00:15:28,379
top-level names I can still use self to

00:15:25,470 --> 00:15:31,470
reference my own module level names or I

00:15:28,379 --> 00:15:35,160
can still use just leading : : to say no

00:15:31,470 --> 00:15:37,350
really it's a an external crate so by

00:15:35,160 --> 00:15:39,209
this time we had two proposals on the

00:15:37,350 --> 00:15:41,309
table we had this solution which we were

00:15:39,209 --> 00:15:44,970
calling uniform paths and we had

00:15:41,309 --> 00:15:46,860
anchored use paths so we had some

00:15:44,970 --> 00:15:48,749
discussion about how those worked and

00:15:46,860 --> 00:15:50,190
the biggest thing we found was that

00:15:48,749 --> 00:15:52,890
there was some

00:15:50,190 --> 00:15:55,380
reluctance towards a new round of debate

00:15:52,890 --> 00:15:57,390
on this we had gone through the better

00:15:55,380 --> 00:15:59,190
part of a year and a half worth of

00:15:57,390 --> 00:16:02,400
talking about this and we had found

00:15:59,190 --> 00:16:04,620
something where everybody seemed more or

00:16:02,400 --> 00:16:06,060
less happy with it it was not exactly

00:16:04,620 --> 00:16:07,500
satisfying but it was kind of

00:16:06,060 --> 00:16:11,250
satisficing it met all the requirements

00:16:07,500 --> 00:16:12,510
and so people were not excited about the

00:16:11,250 --> 00:16:15,990
idea of wait we're talking about this

00:16:12,510 --> 00:16:18,180
again on top of that there was some very

00:16:15,990 --> 00:16:19,590
reasonable technical considerations with

00:16:18,180 --> 00:16:21,750
this new proposal that didn't apply to

00:16:19,590 --> 00:16:23,460
the old one they amounted to don't

00:16:21,750 --> 00:16:26,460
meddle with name resolution for his

00:16:23,460 --> 00:16:28,200
subtle and quick to anger everybody who

00:16:26,460 --> 00:16:31,650
had touched that area of the compiler

00:16:28,200 --> 00:16:33,930
understood very well that it was very

00:16:31,650 --> 00:16:36,510
subtle and when you messed with it it

00:16:33,930 --> 00:16:38,700
would mostly work and then you'd have

00:16:36,510 --> 00:16:40,950
corner cases after corner cases after

00:16:38,700 --> 00:16:42,930
corner cases and so people were very

00:16:40,950 --> 00:16:44,340
hesitant to adopt a solution that

00:16:42,930 --> 00:16:48,780
effectively said well if we just made

00:16:44,340 --> 00:16:49,920
the compiler smarter and finally there

00:16:48,780 --> 00:16:52,680
were actually some meaningful

00:16:49,920 --> 00:16:54,450
differences in the core values and

00:16:52,680 --> 00:16:56,340
preferences among members of the

00:16:54,450 --> 00:16:58,560
language team I don't want to suggest

00:16:56,340 --> 00:17:00,210
that this was a case of oh this solution

00:16:58,560 --> 00:17:01,620
was obviously better and it just had

00:17:00,210 --> 00:17:03,840
technical limitations and maybe we

00:17:01,620 --> 00:17:05,579
didn't want to reopen old wounds there

00:17:03,840 --> 00:17:07,310
are meaningful differences here not

00:17:05,579 --> 00:17:11,310
everybody is happy with the idea of

00:17:07,310 --> 00:17:14,430
let's figure out in a well-defined order

00:17:11,310 --> 00:17:16,140
how to handle ambiguity where this might

00:17:14,430 --> 00:17:17,430
mean this or it might mean that the

00:17:16,140 --> 00:17:19,829
thought was well the compiler can do

00:17:17,430 --> 00:17:22,500
that what if the programmer wants to be

00:17:19,829 --> 00:17:24,410
able to do that and say I want to know

00:17:22,500 --> 00:17:26,939
looking at a path what it is

00:17:24,410 --> 00:17:28,470
unambiguously all the time and that was

00:17:26,939 --> 00:17:31,290
a reasonable request and it was a

00:17:28,470 --> 00:17:32,880
different request it was a different set

00:17:31,290 --> 00:17:34,470
of goals different set of values where

00:17:32,880 --> 00:17:36,120
they were saying well why are we

00:17:34,470 --> 00:17:37,830
optimizing for writing code maybe we

00:17:36,120 --> 00:17:40,290
should be optimizing for a reading code

00:17:37,830 --> 00:17:41,790
and that's a reasonable statement and

00:17:40,290 --> 00:17:44,880
people disagreed on how to implement

00:17:41,790 --> 00:17:47,790
that so all that by way of saying this

00:17:44,880 --> 00:17:52,500
was one of our and the language team one

00:17:47,790 --> 00:17:56,370
of our first major heavy ideological

00:17:52,500 --> 00:17:58,920
differences heavy bits of this is really

00:17:56,370 --> 00:18:00,960
kind of stressful to debate over how do

00:17:58,920 --> 00:18:03,900
we reach a consensus it seems like we're

00:18:00,960 --> 00:18:04,230
deadlocked that kind of thing there have

00:18:03,900 --> 00:18:06,210
been

00:18:04,230 --> 00:18:07,559
in the past if anybody wants to look at

00:18:06,210 --> 00:18:09,059
the history of the question mark

00:18:07,559 --> 00:18:11,100
operator there's a long and storied

00:18:09,059 --> 00:18:13,410
history there and that one was also

00:18:11,100 --> 00:18:15,210
heavily like community consensus and

00:18:13,410 --> 00:18:17,190
whether everybody was in favor of it but

00:18:15,210 --> 00:18:19,860
this was one of the first ones where the

00:18:17,190 --> 00:18:21,480
language team itself was heavily divided

00:18:19,860 --> 00:18:24,720
and debating and trying to figure out

00:18:21,480 --> 00:18:27,809
what is the best answer for rust and the

00:18:24,720 --> 00:18:31,260
community so as part of moving forward

00:18:27,809 --> 00:18:34,350
on this we first of all tried to make

00:18:31,260 --> 00:18:36,720
sure well can we actually do this and so

00:18:34,350 --> 00:18:38,940
I've got credits at the end in detail

00:18:36,720 --> 00:18:40,169
but a couple of folks sat down and

00:18:38,940 --> 00:18:42,540
actually wrote a prototype

00:18:40,169 --> 00:18:44,490
implementation of this they said yes we

00:18:42,540 --> 00:18:46,440
can do this here's how it works try it

00:18:44,490 --> 00:18:48,720
out experiment with it see how it feels

00:18:46,440 --> 00:18:50,790
so there was a successful technical

00:18:48,720 --> 00:18:53,370
implementation of the new proposal which

00:18:50,790 --> 00:18:55,799
then meant hey you can sit there on play

00:18:53,370 --> 00:18:57,600
and play in nightly and figure out what

00:18:55,799 --> 00:19:00,179
we want it to look like we went ahead

00:18:57,600 --> 00:19:02,730
and tried it out on nightly and said

00:19:00,179 --> 00:19:04,559
let's see how these implementations work

00:19:02,730 --> 00:19:07,500
because the critical point is which one

00:19:04,559 --> 00:19:09,120
do we choose to stabilize we looked for

00:19:07,500 --> 00:19:11,910
feedback from the community there were

00:19:09,120 --> 00:19:14,220
several polls but more importantly not

00:19:11,910 --> 00:19:16,950
just numeric and quantitative questions

00:19:14,220 --> 00:19:18,750
but more what do people think what are

00:19:16,950 --> 00:19:21,630
other people's values what are other

00:19:18,750 --> 00:19:24,090
people's arguments for it it's not

00:19:21,630 --> 00:19:25,950
helpful to have 47 people saying they'd

00:19:24,090 --> 00:19:28,380
like this and 43 saying they'd like that

00:19:25,950 --> 00:19:30,570
it's extremely helpful to have four

00:19:28,380 --> 00:19:33,000
people say here's why I prefer this

00:19:30,570 --> 00:19:35,010
alternative or here's why my code would

00:19:33,000 --> 00:19:37,470
look better with this alternative that

00:19:35,010 --> 00:19:39,780
kind of thing as more of a qualitative

00:19:37,470 --> 00:19:42,030
helped me understand what your

00:19:39,780 --> 00:19:43,890
preferences are that's the kind of thing

00:19:42,030 --> 00:19:45,299
that was extremely helpful to see when

00:19:43,890 --> 00:19:47,100
we're trying to figure out what

00:19:45,299 --> 00:19:50,130
arguments aren't we seeing what balance

00:19:47,100 --> 00:19:52,860
aren't we seeing beyond that we found

00:19:50,130 --> 00:19:55,380
that we were doing a lot of careful

00:19:52,860 --> 00:19:58,470
discussion and introspection on what

00:19:55,380 --> 00:20:01,440
these core values that we had are that

00:19:58,470 --> 00:20:03,840
there's an argument or tactic where you

00:20:01,440 --> 00:20:05,700
can say all right let's step back for a

00:20:03,840 --> 00:20:08,549
moment let's both figure out what our

00:20:05,700 --> 00:20:10,830
values are that are causing us to get

00:20:08,549 --> 00:20:13,080
very attached to what our solution is

00:20:10,830 --> 00:20:14,429
let's figure out what the other person's

00:20:13,080 --> 00:20:16,140
values are well enough that we can

00:20:14,429 --> 00:20:18,330
explain it back to them and they're like

00:20:16,140 --> 00:20:20,460
yeah that's what we believe

00:20:18,330 --> 00:20:23,010
and if you can't get at least that far

00:20:20,460 --> 00:20:24,870
then you're not going to be able to have

00:20:23,010 --> 00:20:27,870
a good clear discussion about it you're

00:20:24,870 --> 00:20:30,600
just disagreeing and so we had a lot of

00:20:27,870 --> 00:20:33,150
very careful conversations like that

00:20:30,600 --> 00:20:35,460
where we wrote up documents we wrote up

00:20:33,150 --> 00:20:37,080
a Dropbox paper document where everyone

00:20:35,460 --> 00:20:38,370
wrote separately what their views were

00:20:37,080 --> 00:20:41,160
but then went through everyone else's

00:20:38,370 --> 00:20:43,110
and we discussed what those were and

00:20:41,160 --> 00:20:44,610
trying to understand where work where

00:20:43,110 --> 00:20:48,390
each other are coming from and that

00:20:44,610 --> 00:20:53,070
helped hugely so in the meantime we went

00:20:48,390 --> 00:20:55,640
ahead and released 1.31 and rust 2018

00:20:53,070 --> 00:20:58,470
with a compromise solution we said okay

00:20:55,640 --> 00:21:01,200
these two are actually very similar and

00:20:58,470 --> 00:21:03,510
the main issue they have is when you

00:21:01,200 --> 00:21:05,970
have ambiguity one of them would say you

00:21:03,510 --> 00:21:08,130
must disambiguate it like this and the

00:21:05,970 --> 00:21:10,560
other would say here's how we resolve it

00:21:08,130 --> 00:21:12,360
so we effectively made that an error and

00:21:10,560 --> 00:21:15,990
said you can't hit the case where these

00:21:12,360 --> 00:21:17,760
two systems differ you have to use

00:21:15,990 --> 00:21:20,580
something that's compatible with both

00:21:17,760 --> 00:21:22,560
and that allowed us to defer a little

00:21:20,580 --> 00:21:24,360
bit longer figuring out what the correct

00:21:22,560 --> 00:21:27,150
answer was it's again not wildly

00:21:24,360 --> 00:21:29,850
satisfying but it's worth noting that

00:21:27,150 --> 00:21:32,130
even critically important and very heavy

00:21:29,850 --> 00:21:34,410
features like this still wait for the

00:21:32,130 --> 00:21:36,360
next train if they're not ready in time

00:21:34,410 --> 00:21:37,530
there is no pass for oh you're on the

00:21:36,360 --> 00:21:39,870
language team so we'll sneak something

00:21:37,530 --> 00:21:41,730
in in time we very much said let's wait

00:21:39,870 --> 00:21:44,400
a release we're not ready to make this

00:21:41,730 --> 00:21:45,990
call yet so I mentioned we

00:21:44,400 --> 00:21:48,090
collaboratively wrote a document about

00:21:45,990 --> 00:21:50,760
both alternatives we explored down both

00:21:48,090 --> 00:21:53,970
paths very extensively had some very

00:21:50,760 --> 00:21:55,740
excellent discussions where people it is

00:21:53,970 --> 00:21:58,140
incredibly rare to see people genuinely

00:21:55,740 --> 00:22:00,330
change their mind on something that they

00:21:58,140 --> 00:22:01,980
felt very strongly about and it was an

00:22:00,330 --> 00:22:04,170
impressive sight to see on several

00:22:01,980 --> 00:22:06,120
counts so we ended up making the

00:22:04,170 --> 00:22:07,650
decision shortly thereafter and we

00:22:06,120 --> 00:22:11,900
finished up the uniform pads

00:22:07,650 --> 00:22:15,120
implementation in 132 and that

00:22:11,900 --> 00:22:17,250
discussion had wrapped up in that form

00:22:15,120 --> 00:22:18,960
but it's worth noting that one of the

00:22:17,250 --> 00:22:20,640
reasons I'm giving this talk is that

00:22:18,960 --> 00:22:21,930
because it was iterating so quickly

00:22:20,640 --> 00:22:24,450
because it was going through all of

00:22:21,930 --> 00:22:26,760
these decision processes the final

00:22:24,450 --> 00:22:28,920
version of this implementation is not

00:22:26,760 --> 00:22:31,460
exactly what was documented in the

00:22:28,920 --> 00:22:33,200
original RFC for path clarity

00:22:31,460 --> 00:22:35,210
and the new version of what was

00:22:33,200 --> 00:22:38,179
implemented was effectively defined by

00:22:35,210 --> 00:22:39,710
the compiler for 132 more so than by

00:22:38,179 --> 00:22:40,849
written documentation and then we went

00:22:39,710 --> 00:22:43,249
back and wrote some more of the

00:22:40,849 --> 00:22:45,139
documentation later and so part of the

00:22:43,249 --> 00:22:47,509
point of this talk was to say here's how

00:22:45,139 --> 00:22:50,450
we got there and here's what we ended up

00:22:47,509 --> 00:22:52,639
with so I want to go through a few more

00:22:50,450 --> 00:22:54,589
of the technical details that I had

00:22:52,639 --> 00:22:56,259
skipped past earlier to make sure that I

00:22:54,589 --> 00:22:59,749
would go all through all of the

00:22:56,259 --> 00:23:02,330
decision-making process and values so

00:22:59,749 --> 00:23:04,279
with that in mind some of the other

00:23:02,330 --> 00:23:05,389
items that we looked at were how to

00:23:04,279 --> 00:23:06,559
handle macros

00:23:05,389 --> 00:23:08,269
this was actually handled through a

00:23:06,559 --> 00:23:10,399
somewhat separate process in separate

00:23:08,269 --> 00:23:13,159
RFC's but it was part of the same

00:23:10,399 --> 00:23:15,649
unifying theory for a module system in

00:23:13,159 --> 00:23:18,769
rust 2015 there's a whole separate way

00:23:15,649 --> 00:23:20,269
to export and then use macros so if you

00:23:18,769 --> 00:23:22,539
want to use one of these macros like

00:23:20,269 --> 00:23:26,839
crate name or crate authors from Clapp

00:23:22,539 --> 00:23:29,479
then you use macro use extern crate clap

00:23:26,839 --> 00:23:33,830
which will import effectively import

00:23:29,479 --> 00:23:35,690
star from clap if it's a macro and then

00:23:33,830 --> 00:23:37,399
all of those macros are just directly in

00:23:35,690 --> 00:23:38,929
scope and you use them unqualified

00:23:37,399 --> 00:23:40,609
there's no way to qualify them there's

00:23:38,929 --> 00:23:42,979
no way to limit which ones you grab and

00:23:40,609 --> 00:23:44,539
so this is what you ended up with this

00:23:42,979 --> 00:23:48,710
is the only way you can pull in and be

00:23:44,539 --> 00:23:52,279
modular about macros in rust 2018 you

00:23:48,710 --> 00:23:54,710
can actually use a macro exactly like

00:23:52,279 --> 00:23:56,029
any other name if you're using it from

00:23:54,710 --> 00:23:58,369
an external crate there's some corner

00:23:56,029 --> 00:24:00,259
cases that I won't go into involving

00:23:58,369 --> 00:24:02,479
local modules in your own crate and

00:24:00,259 --> 00:24:04,969
we're hoping to fix those someday but in

00:24:02,479 --> 00:24:06,739
the meantime you could just use clap

00:24:04,969 --> 00:24:09,019
colon colon crate name and then use

00:24:06,739 --> 00:24:11,239
crate name as a macro just like crate

00:24:09,019 --> 00:24:13,789
name was any other kind of name you

00:24:11,239 --> 00:24:16,489
could also just reference a macro with a

00:24:13,789 --> 00:24:18,469
scoped name in case you didn't want to

00:24:16,489 --> 00:24:21,080
pull it in by name you just wanted to

00:24:18,469 --> 00:24:23,450
use it where it was so macro pads now

00:24:21,080 --> 00:24:26,330
work more or less like function pads and

00:24:23,450 --> 00:24:28,519
again unification and simplification we

00:24:26,330 --> 00:24:30,409
added something new to the language but

00:24:28,519 --> 00:24:33,169
we did so in a way to make the language

00:24:30,409 --> 00:24:34,999
as orthogonal as possible so that it

00:24:33,169 --> 00:24:36,769
worked the same way and you didn't need

00:24:34,999 --> 00:24:39,469
to learn the rule for functions and then

00:24:36,769 --> 00:24:41,239
the learn the rule for macros just like

00:24:39,469 --> 00:24:42,979
you didn't have to learn the rule for

00:24:41,239 --> 00:24:44,870
use statements and then the rule for

00:24:42,979 --> 00:24:47,480
expressions the

00:24:44,870 --> 00:24:51,200
couple other changes you can now have

00:24:47,480 --> 00:24:53,840
food RS and a sub-module foo slash bar

00:24:51,200 --> 00:24:57,790
dot RS you no longer have to write foo

00:24:53,840 --> 00:25:00,290
slash mod RS mod RS was similar to

00:24:57,790 --> 00:25:01,640
dunder and net dot pie if you're

00:25:00,290 --> 00:25:03,890
familiar with that in Python or

00:25:01,640 --> 00:25:06,920
otherwise this is the module that

00:25:03,890 --> 00:25:08,570
represents the parent module previously

00:25:06,920 --> 00:25:11,510
there were some ambiguities here and you

00:25:08,570 --> 00:25:13,430
had to always use mod dot RS if you had

00:25:11,510 --> 00:25:15,650
sub modules which meant with you want to

00:25:13,430 --> 00:25:19,040
add a sub-module you have to move food

00:25:15,650 --> 00:25:20,480
RS and people also observed that if you

00:25:19,040 --> 00:25:22,850
had it open in an editor you'd have a

00:25:20,480 --> 00:25:25,429
lot of files named mod RS and you'd have

00:25:22,850 --> 00:25:27,410
to see where they were so this is a

00:25:25,429 --> 00:25:30,890
little cleanup that is just quality of

00:25:27,410 --> 00:25:32,570
life improvements one other item was we

00:25:30,890 --> 00:25:34,850
started seeing well why else are people

00:25:32,570 --> 00:25:36,380
using X turn crate we wanted to deal

00:25:34,850 --> 00:25:39,710
with macros so we needed a way to

00:25:36,380 --> 00:25:41,809
substitute for macro use we also needed

00:25:39,710 --> 00:25:44,720
to deal with crate renaming people could

00:25:41,809 --> 00:25:46,460
do extern crate foo as bar and then

00:25:44,720 --> 00:25:48,679
reference the crate as bar everywhere

00:25:46,460 --> 00:25:51,530
else so we ended up with a new feature

00:25:48,679 --> 00:25:54,860
in cargo that allowed you to say hey I'm

00:25:51,530 --> 00:25:56,840
using the crate bar but I'm sorry I'm

00:25:54,860 --> 00:25:59,690
using the name bar but it's really the

00:25:56,840 --> 00:26:01,640
package named foo so go get the package

00:25:59,690 --> 00:26:04,520
foo with this version and then name it

00:26:01,640 --> 00:26:06,740
bar in my program throughout so this was

00:26:04,520 --> 00:26:08,690
the replacement for extern crate foo as

00:26:06,740 --> 00:26:11,030
bar and that was kind of the last you

00:26:08,690 --> 00:26:14,570
have to use extern crate other than if

00:26:11,030 --> 00:26:15,920
you're using no standard or no core then

00:26:14,570 --> 00:26:17,750
there are some cases where you need to

00:26:15,920 --> 00:26:19,850
reference standard or core with extern

00:26:17,750 --> 00:26:21,440
crate but because those are a lot less

00:26:19,850 --> 00:26:24,320
common those didn't get addressed quite

00:26:21,440 --> 00:26:26,510
yet but this effectively meant the

00:26:24,320 --> 00:26:29,540
normal most normal programs did not need

00:26:26,510 --> 00:26:32,179
to use extra and crate so a few other

00:26:29,540 --> 00:26:35,420
bits of future work that come from the

00:26:32,179 --> 00:26:37,760
nature of let's pull things out and do

00:26:35,420 --> 00:26:41,840
the minimal step that we can in order to

00:26:37,760 --> 00:26:43,730
bypass controversy and avoid bundling 27

00:26:41,840 --> 00:26:46,790
different things into an amalgam that

00:26:43,730 --> 00:26:50,150
will never pass we talked about what

00:26:46,790 --> 00:26:51,860
cost so possible future work were a lot

00:26:50,150 --> 00:26:54,500
of people really don't like having to

00:26:51,860 --> 00:26:57,110
write mod statements writing mod example

00:26:54,500 --> 00:26:58,140
in order to kind of mount example dot RS

00:26:57,110 --> 00:26:59,850
into the names

00:26:58,140 --> 00:27:01,920
face and so there was a lot of

00:26:59,850 --> 00:27:04,140
discussion that you could implicitly

00:27:01,920 --> 00:27:06,750
assume mod example whenever you had an

00:27:04,140 --> 00:27:08,460
example RS there are some corner cases

00:27:06,750 --> 00:27:10,110
here there are issues like well what if

00:27:08,460 --> 00:27:11,490
I had a local temporary file I was

00:27:10,110 --> 00:27:13,140
playing with and I don't want it to be

00:27:11,490 --> 00:27:15,450
compiled that kind of thing

00:27:13,140 --> 00:27:17,430
so this was separated out due to

00:27:15,450 --> 00:27:19,410
controversy but there's still interest

00:27:17,430 --> 00:27:21,000
in revisiting it at some point in the

00:27:19,410 --> 00:27:23,880
future when there is the appetite to

00:27:21,000 --> 00:27:26,700
look at the module system again the

00:27:23,880 --> 00:27:28,260
other was that you're from you're

00:27:26,700 --> 00:27:30,330
probably familiar with the pub

00:27:28,260 --> 00:27:31,770
visibility and this is exported I'm

00:27:30,330 --> 00:27:33,900
allowed to use it from outside the

00:27:31,770 --> 00:27:36,150
module or crate as well as anything you

00:27:33,900 --> 00:27:38,010
don't mark as pub is private the one

00:27:36,150 --> 00:27:40,550
that people don't often know about is

00:27:38,010 --> 00:27:43,860
you can write pub parenthesis crate and

00:27:40,550 --> 00:27:45,900
this is effectively protected inside my

00:27:43,860 --> 00:27:47,700
crate but and outside the module you can

00:27:45,900 --> 00:27:49,950
use this but I can't use it outside the

00:27:47,700 --> 00:27:52,170
crate so there was a proposal to make

00:27:49,950 --> 00:27:54,720
this easier to use by defining a new

00:27:52,170 --> 00:27:56,460
visibility named crate rather than pub

00:27:54,720 --> 00:27:58,440
crate you could just write crate you're

00:27:56,460 --> 00:28:01,200
saying instead of a pub type this is a

00:27:58,440 --> 00:28:04,410
crate type so it had a kind of logical

00:28:01,200 --> 00:28:06,780
flow to it it was separated out due to a

00:28:04,410 --> 00:28:08,280
bunch of dude primarily to one corner

00:28:06,780 --> 00:28:10,230
case that we'd seen where it's a little

00:28:08,280 --> 00:28:12,240
ambiguous and we weren't very satisfied

00:28:10,230 --> 00:28:13,740
making the call there were some other

00:28:12,240 --> 00:28:16,770
reasons as well but the biggest one was

00:28:13,740 --> 00:28:20,730
this if I write a struct a parenthesis

00:28:16,770 --> 00:28:24,210
tuple struct that has crate colon colon

00:28:20,730 --> 00:28:26,220
T does that mean the type T that is at

00:28:24,210 --> 00:28:30,300
the top level of my crate we're crate is

00:28:26,220 --> 00:28:34,740
a scope or does that mean a type colon

00:28:30,300 --> 00:28:37,470
colon T that is named elsewhere that has

00:28:34,740 --> 00:28:39,500
visibility crate so this was a

00:28:37,470 --> 00:28:41,900
delightful little ambiguity that

00:28:39,500 --> 00:28:45,000
resolving this would have required

00:28:41,900 --> 00:28:47,880
either defining one or the other to be

00:28:45,000 --> 00:28:50,070
what happens or having a rule that says

00:28:47,880 --> 00:28:53,370
you must disambiguate and we won't allow

00:28:50,070 --> 00:28:55,470
either one of them but again there is

00:28:53,370 --> 00:28:57,750
still interest in simplifying the use of

00:28:55,470 --> 00:28:59,550
the pub crate visibility and so what

00:28:57,750 --> 00:29:03,240
form that will take in the future I

00:28:59,550 --> 00:29:05,640
don't know so I wanted to take this time

00:29:03,240 --> 00:29:08,370
to kind of reflect on difficult

00:29:05,640 --> 00:29:12,140
decisions this was one of the first

00:29:08,370 --> 00:29:13,850
major ideological disagree

00:29:12,140 --> 00:29:15,770
so we had to work our way through but

00:29:13,850 --> 00:29:18,320
they're going to be and have been many

00:29:15,770 --> 00:29:20,990
more overtime I'm going to very briefly

00:29:18,320 --> 00:29:24,140
mention async/await for example where

00:29:20,990 --> 00:29:26,900
there was a lot of controversy on what

00:29:24,140 --> 00:29:29,330
the right syntax was many many people

00:29:26,900 --> 00:29:31,520
said we definitely need this feature we

00:29:29,330 --> 00:29:34,370
need to settle on some syntax for this

00:29:31,520 --> 00:29:37,070
feature there were in fact almost three

00:29:34,370 --> 00:29:38,990
camps here of people who wanted prefix

00:29:37,070 --> 00:29:42,970
people who wanted postfix and people who

00:29:38,990 --> 00:29:45,500
want something real soon now please and

00:29:42,970 --> 00:29:48,679
I'm not joking those were the three

00:29:45,500 --> 00:29:50,929
camps and so there was a lot of

00:29:48,679 --> 00:29:54,380
discussion about this it did finally get

00:29:50,929 --> 00:29:57,140
stabilized for 139 very recently in the

00:29:54,380 --> 00:29:59,630
last few days in fact so that is awesome

00:29:57,140 --> 00:30:01,700
I'm so glad to see yesterday people

00:29:59,630 --> 00:30:04,820
actively using the new async/await

00:30:01,700 --> 00:30:05,960
syntax from nightly in a training class

00:30:04,820 --> 00:30:08,240
about async/await

00:30:05,960 --> 00:30:09,919
so that's incredibly exciting but again

00:30:08,240 --> 00:30:12,669
this is the kind of thing that took a

00:30:09,919 --> 00:30:16,040
lot of discussion a lot of very careful

00:30:12,669 --> 00:30:17,870
working through of well what is it about

00:30:16,040 --> 00:30:19,570
this Intex to you that you like what is

00:30:17,870 --> 00:30:21,890
it about the syntax that you like

00:30:19,570 --> 00:30:24,110
everybody's trying to build a good

00:30:21,890 --> 00:30:26,150
language nobody's trying to sabotage a

00:30:24,110 --> 00:30:28,700
language and remembering that and moving

00:30:26,150 --> 00:30:31,400
forward and saying how do we get to the

00:30:28,700 --> 00:30:33,500
best solution ended up allowing us to

00:30:31,400 --> 00:30:36,470
reach something that everybody was

00:30:33,500 --> 00:30:38,299
either thrilled with happy with or could

00:30:36,470 --> 00:30:41,330
otherwise live with moving forward with

00:30:38,299 --> 00:30:43,130
without causing any of the problems that

00:30:41,330 --> 00:30:46,220
people were concerned about with other

00:30:43,130 --> 00:30:48,650
syntaxes so I want to sum this up with a

00:30:46,220 --> 00:30:50,450
few different points first of all I

00:30:48,650 --> 00:30:53,630
would encourage people to beware of

00:30:50,450 --> 00:30:54,830
satisficing solutions cases where yes

00:30:53,630 --> 00:30:56,540
you've technically met all the

00:30:54,830 --> 00:30:59,179
requirements you've technically done

00:30:56,540 --> 00:31:02,809
everything you need to do but nobody's

00:30:59,179 --> 00:31:04,280
really happy with it and so when this

00:31:02,809 --> 00:31:05,450
happens sometimes it really is something

00:31:04,280 --> 00:31:07,160
where you're balancing so many

00:31:05,450 --> 00:31:09,710
conflicting values you just cannot make

00:31:07,160 --> 00:31:11,929
everybody happy at the same time there

00:31:09,710 --> 00:31:13,940
was a degree to which the module system

00:31:11,929 --> 00:31:15,710
was in that state and then we ended up

00:31:13,940 --> 00:31:17,270
coming up with a new solution that made

00:31:15,710 --> 00:31:21,080
the vast majority of people much happier

00:31:17,270 --> 00:31:23,120
than anything we'd seen yet so far so a

00:31:21,080 --> 00:31:24,950
satisficing solution might be a sign

00:31:23,120 --> 00:31:25,910
that you need to look more closely for

00:31:24,950 --> 00:31:29,270
other potential

00:31:25,910 --> 00:31:31,100
Avenues another is to raise issues very

00:31:29,270 --> 00:31:32,890
early no matter how much you declare

00:31:31,100 --> 00:31:35,240
something is interim or experimental

00:31:32,890 --> 00:31:37,460
people will get attached to it some

00:31:35,240 --> 00:31:39,350
people got attached to a weight bang the

00:31:37,460 --> 00:31:41,350
macro like syntax and said oh I thought

00:31:39,350 --> 00:31:44,960
that was what we were stabilizing and

00:31:41,350 --> 00:31:47,810
the same thing goes for a lot for many

00:31:44,960 --> 00:31:49,760
other cases where once you've gotten

00:31:47,810 --> 00:31:52,130
something down the path to it looks like

00:31:49,760 --> 00:31:55,340
this is what I can use in nightly then

00:31:52,130 --> 00:31:58,790
people will get attached to it

00:31:55,340 --> 00:32:01,160
I always introspect on what values your

00:31:58,790 --> 00:32:03,080
opinion is based on if you have

00:32:01,160 --> 00:32:05,480
disagreements and it's worth going one

00:32:03,080 --> 00:32:07,730
level lower and saying what is it that

00:32:05,480 --> 00:32:09,680
makes you attach to this what is it that

00:32:07,730 --> 00:32:11,960
makes it important to you why do you

00:32:09,680 --> 00:32:14,360
consider the solution bad and can you

00:32:11,960 --> 00:32:15,770
define what bad means and that includes

00:32:14,360 --> 00:32:17,960
your own values which this is a

00:32:15,770 --> 00:32:20,420
challenging thing to do to realize ok I

00:32:17,960 --> 00:32:22,070
feel really strongly about this why do I

00:32:20,420 --> 00:32:23,630
feel really strongly about this can I

00:32:22,070 --> 00:32:27,470
explain that to somebody who's not

00:32:23,630 --> 00:32:29,810
inside my head then once you know what

00:32:27,470 --> 00:32:31,820
those values are you can turn it even a

00:32:29,810 --> 00:32:33,650
disagreement into a collaboration of

00:32:31,820 --> 00:32:35,420
saying all right let's look at those

00:32:33,650 --> 00:32:37,400
values how best can we satisfy those

00:32:35,420 --> 00:32:40,010
values do we all agree what those values

00:32:37,400 --> 00:32:43,460
are and can we find a common shared set

00:32:40,010 --> 00:32:45,770
that we can satisfy all of and in

00:32:43,460 --> 00:32:47,600
general I would encourage people to seek

00:32:45,770 --> 00:32:50,210
satisfying rather than satisficing

00:32:47,600 --> 00:32:52,880
solutions were ever even remotely

00:32:50,210 --> 00:32:56,300
possible so I want to end with a couple

00:32:52,880 --> 00:32:58,460
of acknowledgments Aaron on the language

00:32:56,300 --> 00:33:01,700
team formerly on the language team has

00:32:58,460 --> 00:33:03,200
been incredibly helpful in formulating a

00:33:01,700 --> 00:33:05,360
lot of these ideas he wrote several

00:33:03,200 --> 00:33:06,400
really good blog posts on consensus and

00:33:05,360 --> 00:33:10,580
decision making

00:33:06,400 --> 00:33:12,860
Eddie B Kramer TJ and Petra chenkov as

00:33:10,580 --> 00:33:14,870
well as a host of other people were

00:33:12,860 --> 00:33:17,060
critical in making the new module system

00:33:14,870 --> 00:33:18,380
work getting it implemented debugging at

00:33:17,060 --> 00:33:20,540
all sorts of other issues and I am

00:33:18,380 --> 00:33:22,670
probably forgetting some people as well

00:33:20,540 --> 00:33:24,470
as the entire rust language team which

00:33:22,670 --> 00:33:27,380
has been extraordinary to work with and

00:33:24,470 --> 00:33:29,330
again the incredible rest community so

00:33:27,380 --> 00:33:32,420
with that thank you I'm available by

00:33:29,330 --> 00:33:33,680
email and on Twitter and it's been

00:33:32,420 --> 00:33:37,939
wonderful talking to you

00:33:33,680 --> 00:33:37,939
[Applause]

00:33:39,530 --> 00:33:52,829

YouTube URL: https://www.youtube.com/watch?v=AN9FoZgLcFg


