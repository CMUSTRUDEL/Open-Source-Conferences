Title: RustConf 2019 - Monotron - Building a Retro Computer in Embedded Rust by Jonathan Pallant
Publication date: 2019-09-16
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Monotron - Building a Retro Computer in Embedded Rust by Jonathan Pallant

I missed the simplicity of computers like the C64 and the Apple II and I wondered if I could recreate something like that, but using the inexpensive Cortex-M development board I had lying around on my desk. Can you generate VGA without a video chip? Can you render text without enough RAM to hold a bitmap framebuffer? Can I work out how to decode signals from a PS/2 keyboard? What about SD card support? What about audio output? A real-time clock? MIDI?! Parallel Printer support?!!

I will outline the story of my ongoing obsession to cram as much functionality as possible into 256 KiB of Flash and 32 KiB of SRAM, using the power of Rust to build re-usable, testable components along the way.
Captions: 
	00:00:08,770 --> 00:00:15,680
[Music]

00:00:16,960 --> 00:00:20,540
they said would you like some would you

00:00:19,160 --> 00:00:22,910
like some music to kick off said yeah

00:00:20,540 --> 00:00:24,980
it's some 80s montage music will will

00:00:22,910 --> 00:00:29,570
set the scene for this as you could see

00:00:24,980 --> 00:00:31,580
fairly retro themed talk I've seen some

00:00:29,570 --> 00:00:34,010
really beautiful slide shows today I

00:00:31,580 --> 00:00:36,170
don't want you to underestimate the

00:00:34,010 --> 00:00:40,430
amount of effort required in making

00:00:36,170 --> 00:00:42,230
slides look this bad so you're welcome

00:00:40,430 --> 00:00:44,300
yeah with a clock so I got the

00:00:42,230 --> 00:00:46,010
timekeeping going on yeah we'll see how

00:00:44,300 --> 00:00:47,809
that works out so yeah so my name is

00:00:46,010 --> 00:00:50,809
Jonathan I'm here to talk about embedded

00:00:47,809 --> 00:00:52,850
rust and this crazy project I've been on

00:00:50,809 --> 00:00:54,220
for about 18 months called the the

00:00:52,850 --> 00:00:56,720
monotron and we'll see what that's

00:00:54,220 --> 00:00:59,269
spiraled into so first some some

00:00:56,720 --> 00:01:03,559
introductions so you can find all of my

00:00:59,269 --> 00:01:05,960
code on github where I am the J pista I

00:01:03,559 --> 00:01:07,970
tweet a lot these days but I came to

00:01:05,960 --> 00:01:10,790
Twitter relatively light so on Twitter

00:01:07,970 --> 00:01:13,670
I am the real JP ster because somebody

00:01:10,790 --> 00:01:15,530
took the JP stir before me don't ask

00:01:13,670 --> 00:01:17,869
that person rust questions because I'm

00:01:15,530 --> 00:01:19,729
pretty sure they they can't help you can

00:01:17,869 --> 00:01:21,860
find cryptographic proofs that prove I

00:01:19,729 --> 00:01:23,660
am who I say I am at key based which is

00:01:21,860 --> 00:01:26,060
a great service recommend you check it

00:01:23,660 --> 00:01:27,770
out and I belong to the rust embedded

00:01:26,060 --> 00:01:29,870
working group and you can find all of

00:01:27,770 --> 00:01:32,630
the embedded working group materials on

00:01:29,870 --> 00:01:34,070
github the slash rust embedded check it

00:01:32,630 --> 00:01:37,210
out some great stuff on there we've got

00:01:34,070 --> 00:01:39,080
a number of books that are embedded

00:01:37,210 --> 00:01:42,500
related and a whole bunch of other

00:01:39,080 --> 00:01:44,000
material so have a look so what are we

00:01:42,500 --> 00:01:46,340
going to talk about today well this is a

00:01:44,000 --> 00:01:47,930
talk in three parts I guess so we're

00:01:46,340 --> 00:01:50,320
gonna talk a little bit about embedded

00:01:47,930 --> 00:01:52,280
rust and what makes embedded rust

00:01:50,320 --> 00:01:54,680
different to normal

00:01:52,280 --> 00:01:56,570
rust programming we're going to talk

00:01:54,680 --> 00:01:58,730
about this project which I built to sort

00:01:56,570 --> 00:02:01,850
of demonstrate embedded rust and act as

00:01:58,730 --> 00:02:05,150
an example of of what you can do and

00:02:01,850 --> 00:02:07,580
then fingers crossed we might be able to

00:02:05,150 --> 00:02:09,470
put together a little demo for you no

00:02:07,580 --> 00:02:13,819
promises it's always a bit tricky with

00:02:09,470 --> 00:02:15,680
with AV set ups as you see well but what

00:02:13,819 --> 00:02:19,459
we've got here is pretty experimental

00:02:15,680 --> 00:02:20,900
but we're see what we can do so I think

00:02:19,459 --> 00:02:23,030
you'll find that is the highest fidelity

00:02:20,900 --> 00:02:25,870
version of the the rust logo you'll see

00:02:23,030 --> 00:02:27,880
all day so I came to the Ross project

00:02:25,870 --> 00:02:29,860
it's always around

00:02:27,880 --> 00:02:33,070
the one point one pick one one point two

00:02:29,860 --> 00:02:35,230
I think it's actually I took a week off

00:02:33,070 --> 00:02:36,760
work with the flu and I was stuck in bed

00:02:35,230 --> 00:02:38,950
and unable to move and I had nothing to

00:02:36,760 --> 00:02:41,170
do was watched all the TV I could manage

00:02:38,950 --> 00:02:42,400
so someone to work have been going on

00:02:41,170 --> 00:02:44,580
about this language and said you know

00:02:42,400 --> 00:02:47,590
it's interesting it does good stuff and

00:02:44,580 --> 00:02:48,730
within a couple of days having never

00:02:47,590 --> 00:02:51,160
picked up the language before I'd

00:02:48,730 --> 00:02:53,020
written a functional web server that

00:02:51,160 --> 00:02:54,610
could sort of parse HTTP requests there

00:02:53,020 --> 00:02:57,010
was like okay yeah there was a

00:02:54,610 --> 00:02:59,290
professional C programmer I was sort of

00:02:57,010 --> 00:03:00,460
falling over these foot guns all the

00:02:59,290 --> 00:03:02,140
time all these things that are really

00:03:00,460 --> 00:03:03,520
easy to get wrong and I'd spent a lot of

00:03:02,140 --> 00:03:06,040
my professional life building up these

00:03:03,520 --> 00:03:07,350
processes to deal with these things that

00:03:06,040 --> 00:03:09,280
are really easy to get wrong and

00:03:07,350 --> 00:03:11,710
suddenly there's a language it's like

00:03:09,280 --> 00:03:13,480
now we've we've taken care of that for

00:03:11,710 --> 00:03:15,670
you you can go and concentrate on the

00:03:13,480 --> 00:03:18,730
more interesting aspects of programming

00:03:15,670 --> 00:03:20,890
and so yep fell completely in love with

00:03:18,730 --> 00:03:22,930
the language and I've been getting more

00:03:20,890 --> 00:03:25,150
and more involved in in the embedded

00:03:22,930 --> 00:03:28,080
side so the embedded working group again

00:03:25,150 --> 00:03:30,670
I think we agree that's a great quality

00:03:28,080 --> 00:03:33,070
logo incidentally there is a there is a

00:03:30,670 --> 00:03:36,040
tool you can download called Rex paint

00:03:33,070 --> 00:03:38,080
it is an ASCII art painting tool your

00:03:36,040 --> 00:03:39,670
palette of brushes is basically the set

00:03:38,080 --> 00:03:41,740
of ASCII characters and then you can

00:03:39,670 --> 00:03:44,590
draw with them and do lines and

00:03:41,740 --> 00:03:47,710
rectangles and so on yeah it's a

00:03:44,590 --> 00:03:49,720
real-time sync so if you're like me

00:03:47,710 --> 00:03:51,580
maybe maybe avoid that so the rust

00:03:49,720 --> 00:03:53,530
embedded working group formed oh gosh

00:03:51,580 --> 00:03:55,570
maybe about two years ago I can't

00:03:53,530 --> 00:03:57,220
remember now and it started out with

00:03:55,570 --> 00:04:00,160
about five or six of us and we'd get

00:03:57,220 --> 00:04:01,750
together once a week or every so often

00:04:00,160 --> 00:04:05,200
just to chat about and what we've been

00:04:01,750 --> 00:04:07,540
working on and it's it's spiraled

00:04:05,200 --> 00:04:09,959
especially with the rust 20:18 release

00:04:07,540 --> 00:04:14,470
we put a lot of effort into making

00:04:09,959 --> 00:04:17,440
embedded rust work on stable on a number

00:04:14,470 --> 00:04:18,700
of different targets and now I think

00:04:17,440 --> 00:04:22,330
there's you know well over a hundred

00:04:18,700 --> 00:04:25,000
people involved we get together once a

00:04:22,330 --> 00:04:27,310
week on a Tuesday and we chat on matrix

00:04:25,000 --> 00:04:29,140
recently had to switch from IRC to

00:04:27,310 --> 00:04:31,840
matrix so there's a whole bunch of fun

00:04:29,140 --> 00:04:33,100
for you and yeah we've written a bunch

00:04:31,840 --> 00:04:34,450
of support crates of the different

00:04:33,100 --> 00:04:37,150
boards which I'll talk about we've

00:04:34,450 --> 00:04:39,850
written a couple of books one is an

00:04:37,150 --> 00:04:42,730
introduction to embedded systems

00:04:39,850 --> 00:04:44,110
that happens to use rust and one is a

00:04:42,730 --> 00:04:46,060
book for people who already know

00:04:44,110 --> 00:04:49,030
embedded systems and it teaches them the

00:04:46,060 --> 00:04:51,940
the rust specific bits and then there's

00:04:49,030 --> 00:04:54,160
a third book called the embedded nomicon

00:04:51,940 --> 00:04:56,020
which is all the deep dark and scary

00:04:54,160 --> 00:04:58,210
bits of rust we've written so you don't

00:04:56,020 --> 00:05:00,970
have to actually you know get these

00:04:58,210 --> 00:05:04,210
chips to to boot in the absence of an

00:05:00,970 --> 00:05:05,980
operating system as I say so it will all

00:05:04,210 --> 00:05:06,450
that stuff's don't github so go check it

00:05:05,980 --> 00:05:09,610
out

00:05:06,450 --> 00:05:11,500
so if you want to do embedded rust what

00:05:09,610 --> 00:05:13,350
what do you need and what I guess what

00:05:11,500 --> 00:05:15,220
do I mean by embedded rusts so I mean

00:05:13,350 --> 00:05:17,260
you're running on a platform that

00:05:15,220 --> 00:05:19,330
doesn't have an operating system you

00:05:17,260 --> 00:05:22,030
could say that running rust on a

00:05:19,330 --> 00:05:23,260
Raspberry Pi is embedded and for some

00:05:22,030 --> 00:05:25,660
people that is a resource-constrained

00:05:23,260 --> 00:05:26,680
platform but I think when I talk about

00:05:25,660 --> 00:05:29,080
embedded rust you're talking about

00:05:26,680 --> 00:05:30,280
systems that don't have an operating

00:05:29,080 --> 00:05:32,770
system or if they do it's a really

00:05:30,280 --> 00:05:35,110
simple artist and they've got memory

00:05:32,770 --> 00:05:37,750
measured in the in the kilobytes rather

00:05:35,110 --> 00:05:39,250
than the megabytes so if you want to to

00:05:37,750 --> 00:05:41,710
write some embedded rust code for a

00:05:39,250 --> 00:05:43,450
specific chip and there are an awful lot

00:05:41,710 --> 00:05:47,440
of chips out there you need a few things

00:05:43,450 --> 00:05:50,050
so first of all you need LLVM to be able

00:05:47,440 --> 00:05:54,460
to generate machine code for your target

00:05:50,050 --> 00:05:59,560
it has a bunch of CPU architectures

00:05:54,460 --> 00:06:01,180
built in and there are there are more

00:05:59,560 --> 00:06:04,810
being added so we're aware there's a

00:06:01,180 --> 00:06:06,430
fork for the Atmel AVR series so what

00:06:04,810 --> 00:06:09,040
happened was somebody took LLVM and they

00:06:06,430 --> 00:06:11,410
forked it to add AVR support and then

00:06:09,040 --> 00:06:12,700
the rust team took LLVM and forked it

00:06:11,410 --> 00:06:15,490
for their thing and then someone just

00:06:12,700 --> 00:06:17,110
needs to like zip the two forks together

00:06:15,490 --> 00:06:18,280
and that's a that's a work in progress

00:06:17,110 --> 00:06:21,400
but there are a number of platforms

00:06:18,280 --> 00:06:23,650
where the support is all all sorted out

00:06:21,400 --> 00:06:26,800
so once you've got an LLVM back-end you

00:06:23,650 --> 00:06:30,250
have to tell rust c to which will then

00:06:26,800 --> 00:06:32,710
tell LLVM how to generate code just

00:06:30,250 --> 00:06:36,820
because it knows how to generate a know

00:06:32,710 --> 00:06:38,710
for example x86 machine code that's not

00:06:36,820 --> 00:06:42,730
enough you need to know the rules about

00:06:38,710 --> 00:06:44,440
how big the integers should be and how

00:06:42,730 --> 00:06:45,880
much stack space you allocate in in

00:06:44,440 --> 00:06:48,250
various places so that's the thing

00:06:45,880 --> 00:06:49,840
called a target file you can supply your

00:06:48,250 --> 00:06:52,130
own if you're in an experimental

00:06:49,840 --> 00:06:55,280
platform you might find someone

00:06:52,130 --> 00:06:57,230
has a dot JSON file in the tree and that

00:06:55,280 --> 00:06:58,820
contains all of the information but

00:06:57,230 --> 00:07:00,440
eventually that will get merged into the

00:06:58,820 --> 00:07:04,310
compiler source code and it becomes a

00:07:00,440 --> 00:07:08,180
built-in target the next thing you need

00:07:04,310 --> 00:07:11,600
really is a pre compiled Lib core core

00:07:08,180 --> 00:07:13,160
is the subset of of standard we can't

00:07:11,600 --> 00:07:15,200
run standard because we don't have an

00:07:13,160 --> 00:07:16,880
operating system we don't have threads

00:07:15,200 --> 00:07:18,890
and file systems and all that nice stuff

00:07:16,880 --> 00:07:22,130
so we're stuck with core which is sort

00:07:18,890 --> 00:07:25,310
of the basic subset you can compile your

00:07:22,130 --> 00:07:27,170
own core but as far as I know it's still

00:07:25,310 --> 00:07:30,320
the case that compiling core requires

00:07:27,170 --> 00:07:32,210
nightly which is not ideal if you're

00:07:30,320 --> 00:07:34,250
trying to build a stable system using

00:07:32,210 --> 00:07:36,980
the stable compiler is better so the

00:07:34,250 --> 00:07:39,380
solution was to ship pre-compiled core

00:07:36,980 --> 00:07:41,810
libraries so if you use rust up target

00:07:39,380 --> 00:07:43,850
list it will show you a whole bunch of

00:07:41,810 --> 00:07:45,620
targets where you've got precompiled

00:07:43,850 --> 00:07:47,960
standard libraries if you search for the

00:07:45,620 --> 00:07:51,050
word none in there that shows you the

00:07:47,960 --> 00:07:54,740
embedded ones and we've got cortex m2

00:07:51,050 --> 00:07:57,710
arm cortex-m ARM Cortex r and some risk

00:07:54,740 --> 00:08:00,350
v 32 and 64-bit platforms in there at

00:07:57,710 --> 00:08:01,400
the moment so those binaries are pre

00:08:00,350 --> 00:08:03,020
compiled and they're shipped out to

00:08:01,400 --> 00:08:05,360
everyone through rust ups so getting

00:08:03,020 --> 00:08:07,700
setup free a sort of a standard cortex-m

00:08:05,360 --> 00:08:10,310
system is super simple you just need

00:08:07,700 --> 00:08:13,340
rust up and then that will that can pull

00:08:10,310 --> 00:08:17,510
in everything else you need so let's

00:08:13,340 --> 00:08:18,860
have a look at an example of why I think

00:08:17,510 --> 00:08:20,690
rust is really powerful on

00:08:18,860 --> 00:08:22,850
microcontrollers the classic example is

00:08:20,690 --> 00:08:24,950
you're doing you need to disable

00:08:22,850 --> 00:08:26,210
interrupts to perform some operation

00:08:24,950 --> 00:08:28,520
perhaps you've got some shared mutable

00:08:26,210 --> 00:08:30,800
states that stuff we all think is really

00:08:28,520 --> 00:08:33,800
scary when turns out embedded hardware

00:08:30,800 --> 00:08:37,039
is just a giant ball of mutable shared

00:08:33,800 --> 00:08:38,900
State it's just what it is so yeah you

00:08:37,039 --> 00:08:40,760
need to disable interrupts in C you

00:08:38,900 --> 00:08:42,080
might have a function disable interrupts

00:08:40,760 --> 00:08:43,310
I'm gonna do a bunch of stuff I'm going

00:08:42,080 --> 00:08:45,770
to turn the interrupts back on again

00:08:43,310 --> 00:08:47,660
afterwards it's really easy to return

00:08:45,770 --> 00:08:50,720
early and then never get to the

00:08:47,660 --> 00:08:52,250
re-enable line at the bottom or you

00:08:50,720 --> 00:08:53,660
could forget to re-enable and you know

00:08:52,250 --> 00:08:56,180
the compiler won't check that you've got

00:08:53,660 --> 00:08:58,100
the got the right calls in well we can

00:08:56,180 --> 00:09:01,339
use closures you know you don't need an

00:08:58,100 --> 00:09:02,930
operating system to use a closure so

00:09:01,339 --> 00:09:05,090
here we've got a function called free

00:09:02,930 --> 00:09:08,880
and it operates

00:09:05,090 --> 00:09:10,860
so execute some function f in an in an

00:09:08,880 --> 00:09:13,710
interrupt free environment so it's going

00:09:10,860 --> 00:09:15,660
to disable interrupts with the prime ask

00:09:13,710 --> 00:09:17,100
module so we're good so we're going to

00:09:15,660 --> 00:09:19,050
get the current interrupts Tate with

00:09:17,100 --> 00:09:21,600
prime ask we're going to disable we're

00:09:19,050 --> 00:09:24,270
going to call our closure giving it this

00:09:21,600 --> 00:09:25,740
magic critical section object the

00:09:24,270 --> 00:09:28,110
critical section object basically acts

00:09:25,740 --> 00:09:30,240
as a proof that you are in a state where

00:09:28,110 --> 00:09:33,030
interrupts have been disabled stops

00:09:30,240 --> 00:09:33,480
people calling functions outside of that

00:09:33,030 --> 00:09:36,240
state

00:09:33,480 --> 00:09:39,480
that's an unsafe thing to create we're

00:09:36,240 --> 00:09:42,840
unsafe means don't worry compiler I've

00:09:39,480 --> 00:09:45,090
got this that would be a fairly lengthy

00:09:42,840 --> 00:09:47,310
key words if I'm honest so I could see

00:09:45,090 --> 00:09:48,330
why they went with unsafe but yeah he

00:09:47,310 --> 00:09:50,790
said who the pilot don't worry I've got

00:09:48,330 --> 00:09:52,290
this make me a critical section because

00:09:50,790 --> 00:09:56,370
I know I've got interrupts disabled and

00:09:52,290 --> 00:09:58,020
no matter what happens in function f no

00:09:56,370 --> 00:10:00,420
if it returns early whatever it doesn't

00:09:58,020 --> 00:10:04,050
like its arguments you will always

00:10:00,420 --> 00:10:05,070
reenable the interrupts afterwards so

00:10:04,050 --> 00:10:06,300
there's a whole bunch of stuff now I

00:10:05,070 --> 00:10:07,680
don't have to worry about I don't have

00:10:06,300 --> 00:10:09,120
to worry that I've got these things

00:10:07,680 --> 00:10:12,360
matched up and that's that's super

00:10:09,120 --> 00:10:15,780
powerful so another example doing memory

00:10:12,360 --> 00:10:17,820
mapped i/o the cute thing here so this

00:10:15,780 --> 00:10:19,770
is for an object called a cache and

00:10:17,820 --> 00:10:21,630
branch predictor embedded systems are

00:10:19,770 --> 00:10:24,660
full of really really forgetful

00:10:21,630 --> 00:10:27,000
forgettable names so the CBP is the

00:10:24,660 --> 00:10:29,790
cache and branch predictor the important

00:10:27,000 --> 00:10:32,640
thing is this struct is 0 sized and then

00:10:29,790 --> 00:10:35,490
the the address of the peripheral in

00:10:32,640 --> 00:10:38,790
memory is is produced through the

00:10:35,490 --> 00:10:40,050
through the D ref system so to get it's

00:10:38,790 --> 00:10:41,610
really efficient and then the compiler

00:10:40,050 --> 00:10:44,340
just in lines a whole bunch of stuff but

00:10:41,610 --> 00:10:45,990
basically I'm saying we can access the

00:10:44,340 --> 00:10:48,510
the hardware the serial ports the

00:10:45,990 --> 00:10:51,780
low-level stuff in the chip we can we

00:10:48,510 --> 00:10:54,750
can access it in a nice fashion so the

00:10:51,780 --> 00:10:56,340
projects you you work on it is sort of a

00:10:54,750 --> 00:10:57,840
built in inner stack so at the top

00:10:56,340 --> 00:11:00,600
there's the thing you're writing the

00:10:57,840 --> 00:11:03,270
application the game that a little

00:11:00,600 --> 00:11:04,650
widget demo whatever it is so that's

00:11:03,270 --> 00:11:06,030
it's at the top and underneath you've

00:11:04,650 --> 00:11:08,370
probably got what we call a board

00:11:06,030 --> 00:11:10,890
Support Package so this will be a crate

00:11:08,370 --> 00:11:12,420
someone has written that describes the

00:11:10,890 --> 00:11:15,090
board you're running on it might be a

00:11:12,420 --> 00:11:17,640
commercial board you can buy maybe an ST

00:11:15,090 --> 00:11:18,520
micro discovery board there'll be a

00:11:17,640 --> 00:11:20,620
crate that says

00:11:18,520 --> 00:11:22,630
okay I've got three LEDs and I've got

00:11:20,620 --> 00:11:26,050
two buttons and you can call button one

00:11:22,630 --> 00:11:28,000
is pressed returns a true or false so

00:11:26,050 --> 00:11:29,860
basically just sets up a bunch of stuff

00:11:28,000 --> 00:11:31,090
related to how your board is configured

00:11:29,860 --> 00:11:33,610
which pins are connected to which

00:11:31,090 --> 00:11:35,710
interesting things below that we have a

00:11:33,610 --> 00:11:37,090
hardware abstraction layer so the

00:11:35,710 --> 00:11:39,610
embedded working group have put a lot of

00:11:37,090 --> 00:11:42,940
effort into making for example an ST

00:11:39,610 --> 00:11:45,610
micro serial port look and feel like a

00:11:42,940 --> 00:11:48,400
Texas Instruments serial port or maybe a

00:11:45,610 --> 00:11:50,470
serial port on your Linux laptop these

00:11:48,400 --> 00:11:51,490
see reports all do the same thing but at

00:11:50,470 --> 00:11:55,150
the hardware level they look very

00:11:51,490 --> 00:11:57,700
different and in C it's very tricky to

00:11:55,150 --> 00:11:59,170
come up with a uniform implementation

00:11:57,700 --> 00:12:00,730
you end up in very vendor specific

00:11:59,170 --> 00:12:02,890
places so here we've said no we're gonna

00:12:00,730 --> 00:12:04,780
have a standard implementation of a

00:12:02,890 --> 00:12:06,700
serial port as a trait you can read a

00:12:04,780 --> 00:12:08,080
bytes you can write a byte and then if

00:12:06,700 --> 00:12:09,910
we implement that for a whole bunch of

00:12:08,080 --> 00:12:11,890
different chips your code is now

00:12:09,910 --> 00:12:13,360
portable you can run it on SD micro you

00:12:11,890 --> 00:12:14,530
can run it on Texas Instruments and

00:12:13,360 --> 00:12:16,660
that's what the hardware abstraction

00:12:14,530 --> 00:12:19,000
layer is about and then below that we

00:12:16,660 --> 00:12:22,090
have some auto generated code we can

00:12:19,000 --> 00:12:25,210
take manufacturer definition files that

00:12:22,090 --> 00:12:26,890
say we have a you are peripheral here it

00:12:25,210 --> 00:12:28,630
has these registers that these addresses

00:12:26,890 --> 00:12:30,700
with these fields that these fields have

00:12:28,630 --> 00:12:32,320
these meanings there's a lot of stuff to

00:12:30,700 --> 00:12:34,780
read in the datasheet I mean I've seen

00:12:32,320 --> 00:12:37,750
data sheets that are 5000 pages long and

00:12:34,780 --> 00:12:41,770
to convert that into Russ code is pretty

00:12:37,750 --> 00:12:43,060
tedious to do it by hand the the files

00:12:41,770 --> 00:12:44,890
would get aren't perfect but it's a

00:12:43,060 --> 00:12:46,750
pretty good start until we we also

00:12:44,890 --> 00:12:48,970
generate this this sort of access layer

00:12:46,750 --> 00:12:53,380
which is how we get to the to the

00:12:48,970 --> 00:12:55,420
hardware and finally you need something

00:12:53,380 --> 00:12:57,700
for the specific architecture so these

00:12:55,420 --> 00:12:59,970
chips have a process by which they boot

00:12:57,700 --> 00:13:02,590
up and start running and we've got code

00:12:59,970 --> 00:13:04,540
certainly for cortex em and cortex are

00:13:02,590 --> 00:13:06,220
that that do that for you so you don't

00:13:04,540 --> 00:13:08,470
have to worry but so that's the sort of

00:13:06,220 --> 00:13:10,570
the bottom layer right so let's talk

00:13:08,470 --> 00:13:12,580
about this project I've been working on

00:13:10,570 --> 00:13:13,350
some of you may remember the Commodore

00:13:12,580 --> 00:13:15,070
00:13:13,350 --> 00:13:17,530
yeah I'm just about old enough to

00:13:15,070 --> 00:13:18,580
remember that yeah a bit of basic you

00:13:17,530 --> 00:13:20,560
never thought you'd come to a rust

00:13:18,580 --> 00:13:22,390
conference and see basic up on there up

00:13:20,560 --> 00:13:23,920
on the slides so this is where I got

00:13:22,390 --> 00:13:25,690
into embedded computing I had my

00:13:23,920 --> 00:13:27,790
Commodore 64 I was terrible at playing

00:13:25,690 --> 00:13:29,830
games so I'd plug stuff in the little

00:13:27,790 --> 00:13:31,570
connector at the back and I'd write

00:13:29,830 --> 00:13:33,850
peaks and pokes that we can

00:13:31,570 --> 00:13:34,900
turn motors on and do that stuff so

00:13:33,850 --> 00:13:36,940
that's where I love this sort of

00:13:34,900 --> 00:13:41,050
interactivity where I do a thing and

00:13:36,940 --> 00:13:44,290
then physical real stuff happens and

00:13:41,050 --> 00:13:46,240
recently last year I wasn't enjoying my

00:13:44,290 --> 00:13:47,890
job I wanted a side project I was really

00:13:46,240 --> 00:13:50,380
getting into rust and I thought well

00:13:47,890 --> 00:13:52,660
maybe I can recreate some of that sort

00:13:50,380 --> 00:13:55,390
of 1980s experience of having a really

00:13:52,660 --> 00:13:57,070
limited platform and I think there's a

00:13:55,390 --> 00:14:00,340
lot of art to be found in extracting a

00:13:57,070 --> 00:14:02,560
lot from from very little so what did I

00:14:00,340 --> 00:14:05,890
want to do well yeah I needed this this

00:14:02,560 --> 00:14:07,990
distraction the problem the challenge I

00:14:05,890 --> 00:14:11,440
set myself was can i generate video can

00:14:07,990 --> 00:14:13,780
I get a picture up on a monitor using a

00:14:11,440 --> 00:14:18,040
microcontroller that's not designed to

00:14:13,780 --> 00:14:19,870
do that and then if I can do that how

00:14:18,040 --> 00:14:22,000
much more can you get in what can you

00:14:19,870 --> 00:14:24,640
get out of one of these tiny processes

00:14:22,000 --> 00:14:26,020
so the first board I looked at was it's

00:14:24,640 --> 00:14:29,880
a wonderful photograph I think you'll

00:14:26,020 --> 00:14:32,380
agree it's a board called the St

00:14:29,880 --> 00:14:34,990
stm32f4discovery again with great at

00:14:32,380 --> 00:14:36,340
naming things in the embedded world but

00:14:34,990 --> 00:14:39,100
this board comes with like a four inch

00:14:36,340 --> 00:14:40,540
LCD on the front and you get a fairly

00:14:39,100 --> 00:14:43,120
powerful processor runs at a couple

00:14:40,540 --> 00:14:45,010
hundred megahertz I think I could have

00:14:43,120 --> 00:14:47,020
done the project on this board it would

00:14:45,010 --> 00:14:50,080
have worked but it already came with a

00:14:47,020 --> 00:14:52,450
screen so generating video is like a

00:14:50,080 --> 00:14:54,760
solved problem it's got built-in video

00:14:52,450 --> 00:14:56,020
accelerators that do this work for me

00:14:54,760 --> 00:15:00,240
and yeah it sure using them would have

00:14:56,020 --> 00:15:02,910
been interesting but it's too easy so

00:15:00,240 --> 00:15:06,480
why use this board instead this is the

00:15:02,910 --> 00:15:08,890
Texas Instruments Teva see launchpad

00:15:06,480 --> 00:15:11,260
it's quite nice because it contains two

00:15:08,890 --> 00:15:13,870
processors the one at the top does USB

00:15:11,260 --> 00:15:15,940
serial conversion and is a flash

00:15:13,870 --> 00:15:17,590
programmer and JTAG tool so you can just

00:15:15,940 --> 00:15:19,540
plug it in via USB and that's all you

00:15:17,590 --> 00:15:21,670
need to reprogram the board and then the

00:15:19,540 --> 00:15:24,070
top chip actually reprograms the the

00:15:21,670 --> 00:15:26,020
chip in the middle we've got a cortex-m

00:15:24,070 --> 00:15:29,260
that runs at 80 megahertz

00:15:26,020 --> 00:15:33,520
we've got 256 K of Flash and we've got

00:15:29,260 --> 00:15:36,160
32 K of RAM and that's it so that is

00:15:33,520 --> 00:15:38,560
incidentally not enough RAM to hold an

00:15:36,160 --> 00:15:39,329
entire picture at a resolution that

00:15:38,560 --> 00:15:42,779
you're looking at

00:15:39,329 --> 00:15:45,269
up on the up on the screen so what can

00:15:42,779 --> 00:15:47,970
we do so to generate analog video how

00:15:45,269 --> 00:15:50,189
does this work well in the olden days

00:15:47,970 --> 00:15:53,069
you had electron guns and yeah in the

00:15:50,189 --> 00:15:54,839
olden days when kids watch TV they sat

00:15:53,069 --> 00:15:57,299
in front of a particle accelerator which

00:15:54,839 --> 00:15:59,879
fired electrons at their face and made

00:15:57,299 --> 00:16:02,399
special chemicals glow kids these days

00:15:59,879 --> 00:16:04,290
don't believe it but this electron gun

00:16:02,399 --> 00:16:06,839
swings from left to right lighting up

00:16:04,290 --> 00:16:09,089
the screen as it goes and that's

00:16:06,839 --> 00:16:11,220
basically how the video signal works you

00:16:09,089 --> 00:16:12,869
generate a picture by sending each

00:16:11,220 --> 00:16:15,029
horizontal line you need to get the

00:16:12,869 --> 00:16:17,189
timing correct the pixels are sent out

00:16:15,029 --> 00:16:19,709
from left to right then there's a bit of

00:16:17,189 --> 00:16:21,389
a gap while you wait for the gun to move

00:16:19,709 --> 00:16:22,379
back to the the other side of the screen

00:16:21,389 --> 00:16:24,239
and then you've got these sort of

00:16:22,379 --> 00:16:28,649
blanking areas at the bottom and they're

00:16:24,239 --> 00:16:30,929
on the side so when it comes to

00:16:28,649 --> 00:16:34,290
generating VGA video and I went with VGA

00:16:30,929 --> 00:16:36,420
because what you see as the the numbers

00:16:34,290 --> 00:16:38,610
work out a bit nicer but VGA monitors

00:16:36,420 --> 00:16:41,989
are kind of easier to come by like I can

00:16:38,610 --> 00:16:43,799
feed VGA into into systems like this

00:16:41,989 --> 00:16:46,799
there's an amazing website you should

00:16:43,799 --> 00:16:48,269
check it out called tiny VGA it's really

00:16:46,799 --> 00:16:50,189
good so there's a bunch of different

00:16:48,269 --> 00:16:52,589
standards different set of resolutions

00:16:50,189 --> 00:16:56,489
that are specified the standard VGA

00:16:52,589 --> 00:16:59,029
resolution 640 480 it's 25 point one

00:16:56,489 --> 00:17:02,519
seven five megahertz

00:16:59,029 --> 00:17:04,049
I've got an 80 megahertz clock that is

00:17:02,519 --> 00:17:06,809
not going to divide out there is no

00:17:04,049 --> 00:17:08,549
number I can no integer I can divide 80

00:17:06,809 --> 00:17:10,699
by to get twenty five point one seven

00:17:08,549 --> 00:17:13,649
five that's going to be a nightmare

00:17:10,699 --> 00:17:15,449
standard bios text mode of a text mode

00:17:13,649 --> 00:17:18,299
using DOS turns out is this resolution

00:17:15,449 --> 00:17:20,429
720 400 yeah no that's a bad number I'm

00:17:18,299 --> 00:17:22,230
not gonna be able to generate that so I

00:17:20,429 --> 00:17:25,889
kept going through the list the next one

00:17:22,230 --> 00:17:28,559
800 by 600 60 Hertz turns out to use a

00:17:25,889 --> 00:17:30,870
pixel clock of 40 megahertz that is

00:17:28,559 --> 00:17:32,970
there are 40 million pixels generated

00:17:30,870 --> 00:17:35,190
per second and if you can generate them

00:17:32,970 --> 00:17:38,010
at that rate you will generate a signal

00:17:35,190 --> 00:17:40,649
that any standard VGA monitor will will

00:17:38,010 --> 00:17:45,419
connect to and so that's the that's the

00:17:40,649 --> 00:17:48,000
system I built now I said before we're

00:17:45,419 --> 00:17:51,149
using VGA or VGA xur is a is a color

00:17:48,000 --> 00:17:52,400
standard in mono world you just

00:17:51,149 --> 00:17:53,990
basically send a voltage

00:17:52,400 --> 00:17:56,450
to the monitor and the bigger the

00:17:53,990 --> 00:17:59,510
voltage the brighter the dot and I goes

00:17:56,450 --> 00:18:01,220
you from black to white and then there's

00:17:59,510 --> 00:18:02,510
a little period on the Left where it

00:18:01,220 --> 00:18:04,010
goes negative a little while and that

00:18:02,510 --> 00:18:05,980
just tells the monitor where the edges

00:18:04,010 --> 00:18:09,350
are so it knows how to line a picture up

00:18:05,980 --> 00:18:11,120
in in color world we have a raised panel

00:18:09,350 --> 00:18:14,030
a green Channel and a blue Channel and

00:18:11,120 --> 00:18:17,360
then by mixing those together if you

00:18:14,030 --> 00:18:19,130
have analog levels maybe eight bits for

00:18:17,360 --> 00:18:21,620
each that's where you get your 24-bit

00:18:19,130 --> 00:18:24,410
color from in my world I'll be lucky if

00:18:21,620 --> 00:18:27,970
I could just turn them on or off which

00:18:24,410 --> 00:18:30,410
gives me an about eight choices of color

00:18:27,970 --> 00:18:33,560
but that's that's what we have to do and

00:18:30,410 --> 00:18:36,680
then - because I said we don't have

00:18:33,560 --> 00:18:37,850
enough RAM to generate the picture what

00:18:36,680 --> 00:18:41,660
we're going to need to do is store

00:18:37,850 --> 00:18:43,160
basically a font which has on or off so

00:18:41,660 --> 00:18:45,260
you have your pixels on or off and then

00:18:43,160 --> 00:18:48,110
call it maybe foreground and background

00:18:45,260 --> 00:18:49,700
and then I pick and pick two colors so I

00:18:48,110 --> 00:18:51,230
could set my foreground to green and my

00:18:49,700 --> 00:18:52,910
background black and it would look like

00:18:51,230 --> 00:18:55,220
this but if I set my foreground to white

00:18:52,910 --> 00:18:57,230
my background blue it would look

00:18:55,220 --> 00:19:00,410
different so then all I need to store in

00:18:57,230 --> 00:19:02,990
memory is just I'm using a copyright

00:19:00,410 --> 00:19:05,420
character at this location and I want it

00:19:02,990 --> 00:19:07,520
blue and white or black and green and

00:19:05,420 --> 00:19:09,770
that uses much much less memory than

00:19:07,520 --> 00:19:12,320
trying to store the color of every

00:19:09,770 --> 00:19:13,130
single pixel in RAM because we haven't

00:19:12,320 --> 00:19:15,710
got enough RAM for that

00:19:13,130 --> 00:19:18,470
the downside is as the screen gets drawn

00:19:15,710 --> 00:19:20,510
I have to look up the character in the

00:19:18,470 --> 00:19:22,430
font and then apply the color

00:19:20,510 --> 00:19:25,340
transformation to color all the pixels

00:19:22,430 --> 00:19:27,530
and then get the pixels chucked out

00:19:25,340 --> 00:19:30,470
I actually burn the video at half speed

00:19:27,530 --> 00:19:31,970
so I'm only running a 20 megahertz but

00:19:30,470 --> 00:19:34,730
that does mean I only have four clock

00:19:31,970 --> 00:19:37,880
cycles per pixel that's quite a lot of

00:19:34,730 --> 00:19:40,430
work to do to get each pixel center of

00:19:37,880 --> 00:19:43,310
this system in only four clock cycles it

00:19:40,430 --> 00:19:45,590
was a fairly tall order so that it's not

00:19:43,310 --> 00:19:49,250
terribly readable example I get that but

00:19:45,590 --> 00:19:52,250
basically we're just saying I have my my

00:19:49,250 --> 00:19:55,490
array of characters and colors in a line

00:19:52,250 --> 00:19:57,740
I can each I can iterate through that I

00:19:55,490 --> 00:19:59,750
have to do some funky pointer arithmetic

00:19:57,740 --> 00:20:01,640
because I can't afford the bounds check

00:19:59,750 --> 00:20:03,710
because I've only got four clock cycles

00:20:01,640 --> 00:20:05,760
per pixel so there's a bit of funky

00:20:03,710 --> 00:20:09,840
pointer arithmetic in there

00:20:05,760 --> 00:20:12,900
but spoilers this works this code will

00:20:09,840 --> 00:20:17,840
run fast enough on this chip to generate

00:20:12,900 --> 00:20:19,500
actual video the the color lookup

00:20:17,840 --> 00:20:21,810
attends like if you do it is like a

00:20:19,500 --> 00:20:23,160
match or a so I'm gonna have a statement

00:20:21,810 --> 00:20:26,160
like that or a bunch of if statements

00:20:23,160 --> 00:20:27,210
takes way too long the the solution and

00:20:26,160 --> 00:20:30,510
it took a long while to work this out

00:20:27,210 --> 00:20:33,810
the solution is to blow 25% of my flash

00:20:30,510 --> 00:20:35,760
space on a massive color lookup table so

00:20:33,810 --> 00:20:39,090
I take the 8 bits I want to color and

00:20:35,760 --> 00:20:42,080
then the 2 colors are chosen well that

00:20:39,090 --> 00:20:46,230
gives me 14 bits in total well that's a

00:20:42,080 --> 00:20:49,620
table with 16,000 entries in it and each

00:20:46,230 --> 00:20:51,900
entry is the red set of pixels the green

00:20:49,620 --> 00:20:55,470
set of pixels and the blue set of pixels

00:20:51,900 --> 00:20:57,840
and some padding so it takes up 64k but

00:20:55,470 --> 00:21:00,060
it means I can go from foreground and

00:20:57,840 --> 00:21:03,570
background color to red green and blue

00:21:00,060 --> 00:21:06,690
in only a couple of clock cycles which

00:21:03,570 --> 00:21:07,980
is really powerful without that it so

00:21:06,690 --> 00:21:10,020
the reason it's called the monotron was

00:21:07,980 --> 00:21:13,530
because for ages it only did black and

00:21:10,020 --> 00:21:17,610
white I guess I should rename it now but

00:21:13,530 --> 00:21:19,200
yeah we can we can do color interesting

00:21:17,610 --> 00:21:21,030
from with the timing if you don't get

00:21:19,200 --> 00:21:22,260
the red green in the blue completely

00:21:21,030 --> 00:21:24,120
aligned you get these sort of weird

00:21:22,260 --> 00:21:27,480
fringing effects it's actually

00:21:24,120 --> 00:21:29,270
impossible to get this CPU to to start

00:21:27,480 --> 00:21:31,260
the red the green and the blue

00:21:29,270 --> 00:21:33,960
simultaneously I'm using a special

00:21:31,260 --> 00:21:35,970
peripheral here called the SPI bus I'm

00:21:33,960 --> 00:21:37,230
using three of them you can't start them

00:21:35,970 --> 00:21:38,880
at the same time they need different

00:21:37,230 --> 00:21:40,620
memory rights and it's impossible to do

00:21:38,880 --> 00:21:43,350
to memory rights at the same time and

00:21:40,620 --> 00:21:45,840
for ages this stumped me it turns out

00:21:43,350 --> 00:21:47,820
what you can do is you start the red

00:21:45,840 --> 00:21:48,540
channel early and then you use a bunch

00:21:47,820 --> 00:21:51,090
of no-ops

00:21:48,540 --> 00:21:53,220
to just slow the processor down just

00:21:51,090 --> 00:21:55,170
enough until the exact moment you've

00:21:53,220 --> 00:21:56,880
transmitted eight bits of red and then

00:21:55,170 --> 00:21:59,160
you can start the green and then you

00:21:56,880 --> 00:22:00,990
have a bunch more no-ops and then you

00:21:59,160 --> 00:22:04,530
can start the blue and then it all ends

00:22:00,990 --> 00:22:08,040
up in phase yeah that that took some

00:22:04,530 --> 00:22:09,240
batiks I'm doing so how does the the

00:22:08,040 --> 00:22:11,130
memory layout look what I've got I've

00:22:09,240 --> 00:22:13,200
got a flash ROM I think of that as sort

00:22:11,130 --> 00:22:15,020
of a ROM and a sort of typical home

00:22:13,200 --> 00:22:16,850
computer sense and I've got Ram

00:22:15,020 --> 00:22:20,000
get the various sections which is like

00:22:16,850 --> 00:22:21,380
compiling code for any other platform

00:22:20,000 --> 00:22:22,910
really you know if you were writing C

00:22:21,380 --> 00:22:25,160
code you'd be familiar with all of these

00:22:22,910 --> 00:22:27,590
sections the data section gets copied

00:22:25,160 --> 00:22:30,440
from flash to ram on on start up on my

00:22:27,590 --> 00:22:32,600
interrupt vectors at the bottom so once

00:22:30,440 --> 00:22:33,680
I got this system I said well I mean

00:22:32,600 --> 00:22:36,230
it's fine I can make pretty pictures

00:22:33,680 --> 00:22:38,050
appear but I wish it was a computer I

00:22:36,230 --> 00:22:40,130
could use I want to be able to install

00:22:38,050 --> 00:22:42,320
applications I want to load an

00:22:40,130 --> 00:22:44,090
application in use it and then when I

00:22:42,320 --> 00:22:45,500
turn the computer off and on again the

00:22:44,090 --> 00:22:47,660
applications gone because you know

00:22:45,500 --> 00:22:51,350
that's how these systems are I like from

00:22:47,660 --> 00:22:53,450
the eighties tentative work let's get

00:22:51,350 --> 00:22:56,000
your application to talk to this sort of

00:22:53,450 --> 00:22:59,510
ROM and this sort of kernel like built

00:22:56,000 --> 00:23:01,550
you need an interface so the system I

00:22:59,510 --> 00:23:03,830
designed was basically when you load a

00:23:01,550 --> 00:23:06,140
program into RAM you get the top 24k to

00:23:03,830 --> 00:23:10,400
play with the bottom 8k belongs to the

00:23:06,140 --> 00:23:12,500
system the first word in in your

00:23:10,400 --> 00:23:15,590
application space should be a function

00:23:12,500 --> 00:23:18,200
pointer and then if you put your code in

00:23:15,590 --> 00:23:20,230
RAM the kernel will look at that treat

00:23:18,200 --> 00:23:22,070
it as a function pointer jump to it

00:23:20,230 --> 00:23:24,320
don't care what you do with the rest of

00:23:22,070 --> 00:23:25,760
the RAM that's your business but what I

00:23:24,320 --> 00:23:27,350
will give you is a structure full of

00:23:25,760 --> 00:23:29,480
function pointers and those function

00:23:27,350 --> 00:23:31,970
pointers are how your application can

00:23:29,480 --> 00:23:33,980
ask the kernel to do things like draw on

00:23:31,970 --> 00:23:36,590
the screen or in various other

00:23:33,980 --> 00:23:39,440
operations and then I've spent a long

00:23:36,590 --> 00:23:42,470
time thinking about what should the sort

00:23:39,440 --> 00:23:44,300
of system calls look like I think maybe

00:23:42,470 --> 00:23:45,950
they should look like CPM maybe they

00:23:44,300 --> 00:23:47,870
should look like ms-dos maybe they

00:23:45,950 --> 00:23:49,280
should look like POSIX I haven't really

00:23:47,870 --> 00:23:52,700
got a good answer for that they sort of

00:23:49,280 --> 00:23:53,900
a bit of a mismatch at the moment but we

00:23:52,700 --> 00:23:56,090
can do things like have so anyone

00:23:53,900 --> 00:23:58,340
pressed a key on the keyboard you can

00:23:56,090 --> 00:24:00,260
connect up maybe a serial interface and

00:23:58,340 --> 00:24:02,990
you could type some some text into your

00:24:00,260 --> 00:24:05,330
computer wait for the wait full verticle

00:24:02,990 --> 00:24:07,820
blank interval so that's wait till the

00:24:05,330 --> 00:24:10,070
screen has finished redrawing because if

00:24:07,820 --> 00:24:11,780
you try and draw on the screen if try

00:24:10,070 --> 00:24:13,400
and modify the contents of screen memory

00:24:11,780 --> 00:24:15,080
while it's drawing you get sort of weird

00:24:13,400 --> 00:24:16,730
tearing effect so it's probably best to

00:24:15,080 --> 00:24:18,050
wait to the bottom of the screen before

00:24:16,730 --> 00:24:20,480
you you have to take a bunch of stuff

00:24:18,050 --> 00:24:22,550
you know maybe if you had fonts port you

00:24:20,480 --> 00:24:24,440
could change fonts that sort of thing

00:24:22,550 --> 00:24:25,120
wouldn't be cool if out of joystick

00:24:24,440 --> 00:24:26,710
interface

00:24:25,120 --> 00:24:31,620
yeah because then you could play like

00:24:26,710 --> 00:24:35,550
simple games will be interesting so

00:24:31,620 --> 00:24:38,590
that's sort of the project in a nutshell

00:24:35,550 --> 00:24:41,230
I can say at this point there is a PCB

00:24:38,590 --> 00:24:43,780
I've got one here you can grab me in the

00:24:41,230 --> 00:24:45,310
hallway track and have a look I started

00:24:43,780 --> 00:24:47,170
out as a bit very board a bit unreliable

00:24:45,310 --> 00:24:50,230
so there is a PCB there's gonna be a rev

00:24:47,170 --> 00:24:52,420
- because it has bugs but it's got

00:24:50,230 --> 00:24:55,590
serial ports on it it's got a clock and

00:24:52,420 --> 00:24:59,050
you used to a clock in in the slide here

00:24:55,590 --> 00:25:00,190
show that off so what else we got we've

00:24:59,050 --> 00:25:01,960
got printer port would that be

00:25:00,190 --> 00:25:03,790
interesting if you could print there's a

00:25:01,960 --> 00:25:05,170
printer port on the PCB haven't worked

00:25:03,790 --> 00:25:07,120
out how to make it work here I need to

00:25:05,170 --> 00:25:10,270
go and do some research on how the hell

00:25:07,120 --> 00:25:14,580
printers work and there's some more

00:25:10,270 --> 00:25:18,390
right so that's the end of the slides

00:25:14,580 --> 00:25:18,390
who wants to see a demo

00:25:23,330 --> 00:25:31,730
okay so I did say that making slides

00:25:28,440 --> 00:25:35,240
look this bad is remarkably difficult

00:25:31,730 --> 00:25:41,669
I'm gonna be honest with you the laptop

00:25:35,240 --> 00:25:42,800
is a it's still in the bag the computer

00:25:41,669 --> 00:25:49,880
itself is

00:25:42,800 --> 00:25:49,880
[Applause]

00:25:51,409 --> 00:25:55,200
so we've got a computer to play with and

00:25:53,789 --> 00:25:57,299
I've got about five minutes and I've

00:25:55,200 --> 00:26:00,349
lost my clock so I'm probably gonna run

00:25:57,299 --> 00:26:02,789
over and I apologize in advance so

00:26:00,349 --> 00:26:07,019
wouldn't it be fun if we had a disk

00:26:02,789 --> 00:26:09,929
drive so we could load programs we have

00:26:07,019 --> 00:26:12,299
a disk drive with fat16 fat32 support I

00:26:09,929 --> 00:26:13,679
can read from an SD card I can just pull

00:26:12,299 --> 00:26:15,720
the card out shoveled in the laptop

00:26:13,679 --> 00:26:18,929
I've got programs on disks that I can

00:26:15,720 --> 00:26:21,479
load into RAM and then execute so if you

00:26:18,929 --> 00:26:23,549
want to I don't know maybe you want to

00:26:21,479 --> 00:26:29,129
do some programming so we can deal ode

00:26:23,549 --> 00:26:32,369
tiny bears don't we have basic so this

00:26:29,129 --> 00:26:34,529
is basic for the 68000 I just it's a C

00:26:32,369 --> 00:26:36,720
program I managed to hook the C program

00:26:34,529 --> 00:26:39,239
up with my rust crate that contains all

00:26:36,720 --> 00:26:44,639
of my all of my system calls so yeah we

00:26:39,239 --> 00:26:46,169
can do you know it's got to be done I

00:26:44,639 --> 00:26:51,110
can't bring up a basic program and not

00:26:46,169 --> 00:26:54,410
type this so let's place that

00:26:51,110 --> 00:26:57,380
[Applause]

00:26:54,410 --> 00:27:00,200
so that the screen is redrawing every

00:26:57,380 --> 00:27:01,820
line there are thirty seven thousand

00:27:00,200 --> 00:27:03,290
five hundred lines per second

00:27:01,820 --> 00:27:06,470
effectively if you take the sixty Hertz

00:27:03,290 --> 00:27:09,620
times it by the the six hundred plus the

00:27:06,470 --> 00:27:14,750
blanking interval well it's a tiny bit

00:27:09,620 --> 00:27:17,980
of CPU left at the end of the line maybe

00:27:14,750 --> 00:27:20,930
you could get it to I don't know

00:27:17,980 --> 00:27:30,260
generate a beep that'll be interesting

00:27:20,930 --> 00:27:32,750
wouldn't it maybe in fact you could you

00:27:30,260 --> 00:27:34,220
could use the the MIDI interface so I

00:27:32,750 --> 00:27:37,490
apologize because I am not a musician

00:27:34,220 --> 00:27:38,670
but I do happen to have a mini keyboard

00:27:37,490 --> 00:27:47,849
with me

00:27:38,670 --> 00:27:47,849
[Music]

00:27:47,929 --> 00:27:53,250
so it if you are a musician feel free to

00:27:51,870 --> 00:27:54,510
come and grab me later we can set this

00:27:53,250 --> 00:27:59,370
up a little set of speakers as I say I

00:27:54,510 --> 00:28:03,210
can't really play music but we can we

00:27:59,370 --> 00:28:07,970
can do that what else have we got we've

00:28:03,210 --> 00:28:10,409
got a joystick so maybe to finish up

00:28:07,970 --> 00:28:12,269
we're going to play we're gonna play a

00:28:10,409 --> 00:28:16,620
little game some of you have seen it up

00:28:12,269 --> 00:28:19,049
there before we go into that you're

00:28:16,620 --> 00:28:20,309
about to see an effect in the title

00:28:19,049 --> 00:28:23,279
screen I just want to explain a little

00:28:20,309 --> 00:28:25,169
bit about how that works when I'm

00:28:23,279 --> 00:28:27,929
drawing the video lines I have to work

00:28:25,169 --> 00:28:30,419
out what's on each line of text based on

00:28:27,929 --> 00:28:34,350
where I am on the screen it turns out

00:28:30,419 --> 00:28:37,080
just because you're in line 300 doesn't

00:28:34,350 --> 00:28:40,139
mean you have to draw the pixels that

00:28:37,080 --> 00:28:42,240
should be on line 300 you can in fact

00:28:40,139 --> 00:28:44,279
have a little mapping table inserted in

00:28:42,240 --> 00:28:46,380
the front which allows you to move any

00:28:44,279 --> 00:28:48,480
line to anywhere else on the screen

00:28:46,380 --> 00:28:50,789
which lets you do this kind of effect

00:28:48,480 --> 00:28:52,139
which is kind of fun so you can see how

00:28:50,789 --> 00:28:55,500
this sort of thing might be useful for

00:28:52,139 --> 00:29:01,529
sort of scrolling scrolling backgrounds

00:28:55,500 --> 00:29:03,389
or things like that so let's let's fire

00:29:01,529 --> 00:29:05,549
this up so this might be loud so I'm

00:29:03,389 --> 00:29:08,830
just going to warn that this is the AV

00:29:05,549 --> 00:29:11,470
guy run

00:29:08,830 --> 00:29:13,030
yeah I was really impressed with this

00:29:11,470 --> 00:29:15,550
tune because I wrote it on an aeroplane

00:29:13,030 --> 00:29:18,880
by typing in the frequencies into the

00:29:15,550 --> 00:29:21,100
source code and then afterwards my wife

00:29:18,880 --> 00:29:24,520
said why does your computer keep playing

00:29:21,100 --> 00:29:29,680
Bob as a builder classic British kids TV

00:29:24,520 --> 00:29:31,840
show seem familiar so to finish up I'm

00:29:29,680 --> 00:29:33,670
gonna have a click bash on snake every

00:29:31,840 --> 00:29:35,560
time I eat an apple I would like you to

00:29:33,670 --> 00:29:38,440
whoop and cheer because it's really not

00:29:35,560 --> 00:29:40,630
very easy and then when I eventually

00:29:38,440 --> 00:29:43,000
come to my terminal demise and eat my

00:29:40,630 --> 00:29:45,490
own tail that will be the end of it so

00:29:43,000 --> 00:29:48,510
thank you very much let's let's give

00:29:45,490 --> 00:29:48,510
this a go all right

00:29:48,530 --> 00:30:07,190
oh yeah come on ten points

00:29:59,530 --> 00:30:09,290
the mall right so that the more I eat

00:30:07,190 --> 00:30:10,490
the faster it goes so we really won't be

00:30:09,290 --> 00:30:12,520
here all day don't worry

00:30:10,490 --> 00:30:12,520
Oh

00:30:16,780 --> 00:30:28,160
now again quicker okay thank very much

00:30:27,590 --> 00:30:28,490
everyone

00:30:28,160 --> 00:30:36,380
thank you

00:30:28,490 --> 00:30:49,680
[Applause]

00:30:36,380 --> 00:30:49,680

YouTube URL: https://www.youtube.com/watch?v=PXaSUiGgyEw


