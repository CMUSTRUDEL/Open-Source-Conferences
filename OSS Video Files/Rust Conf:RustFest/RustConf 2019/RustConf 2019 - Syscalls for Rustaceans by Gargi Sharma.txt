Title: RustConf 2019 - Syscalls for Rustaceans by Gargi Sharma
Publication date: 2019-09-16
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Syscalls for Rustaceans by Gargi Sharma

Even if you haven't used Rust's nix package, and have just written println!("Hello, World!"), you have most certainly used syscalls. Syscalls are an interface between the operating system and a user program.

strace can be used to debug git performance issues, examining internals of closed source programs, sandboxing programs and is a powerful debugging tool under your arsenal. This talk explains what syscalls are, how they work, how you can track them using strace and how you can write your own syscall tracer (strace) in Rust!
Captions: 
	00:00:08,770 --> 00:00:15,680
[Music]

00:00:17,380 --> 00:00:23,780
hi everyone my name is Carly and I'm

00:00:20,870 --> 00:00:32,270
going to be talking about just cause

00:00:23,780 --> 00:00:35,470
fire stations oh sorry I forgot that now

00:00:32,270 --> 00:00:39,890
I don't need to speak up in war yeah

00:00:35,470 --> 00:00:43,910
yeah and if you want to follow the

00:00:39,890 --> 00:00:47,720
slides alone here's the link and yeah

00:00:43,910 --> 00:00:50,360
let's get started so before I even begin

00:00:47,720 --> 00:00:53,089
to talk about system cuz I want to talk

00:00:50,360 --> 00:00:56,510
about what it means to be a systems

00:00:53,089 --> 00:00:58,760
programming language so it's a term you

00:00:56,510 --> 00:01:00,589
hear a lot in contacts with traffic

00:00:58,760 --> 00:01:03,650
Trust is a new systems programming

00:01:00,589 --> 00:01:05,089
language and but what makes a

00:01:03,650 --> 00:01:07,520
programming language a systems

00:01:05,089 --> 00:01:10,549
programming language and what makes C

00:01:07,520 --> 00:01:13,400
and C++ and Rus good candidates first

00:01:10,549 --> 00:01:17,119
essential gaming languages where it says

00:01:13,400 --> 00:01:19,130
Python and Perl and not so good

00:01:17,119 --> 00:01:22,610
candidates for assistance programming

00:01:19,130 --> 00:01:25,730
languages so only take us to take us to

00:01:22,610 --> 00:01:28,070
a tray of history and talk about

00:01:25,730 --> 00:01:30,770
evolution assistance regarding languages

00:01:28,070 --> 00:01:33,200
so the two things that I will be

00:01:30,770 --> 00:01:34,670
sticking to in this talk will be what

00:01:33,200 --> 00:01:36,380
does it mean to be assistance regarding

00:01:34,670 --> 00:01:38,630
language

00:01:36,380 --> 00:01:41,090
what makes trust a good candidate for

00:01:38,630 --> 00:01:43,040
systems programming language and third

00:01:41,090 --> 00:01:45,800
is learning about system calls and

00:01:43,040 --> 00:01:47,780
writing your first programming our first

00:01:45,800 --> 00:01:50,510
system for a German trust if you haven't

00:01:47,780 --> 00:01:53,710
written it already and to empower people

00:01:50,510 --> 00:01:58,640
to write more systems programs in rust

00:01:53,710 --> 00:02:01,970
so my research tells me that the first

00:01:58,640 --> 00:02:06,290
time systems the systems program term

00:02:01,970 --> 00:02:08,899
was coined was in 1970s so this was the

00:02:06,290 --> 00:02:13,069
era where we where we were improving on

00:02:08,899 --> 00:02:16,790
assembly and the author of this paper

00:02:13,069 --> 00:02:19,459
consistent programming language defined

00:02:16,790 --> 00:02:22,220
assistant program as an integrated set

00:02:19,459 --> 00:02:25,129
of sub programs in exceeding some

00:02:22,220 --> 00:02:28,010
threshold of size of complexity so some

00:02:25,129 --> 00:02:28,989
examples of such systems would be like

00:02:28,010 --> 00:02:32,079
simulator

00:02:28,989 --> 00:02:34,659
or time-sharing systems information

00:02:32,079 --> 00:02:38,620
management systems and then the author

00:02:34,659 --> 00:02:41,920
goes on to define what system program is

00:02:38,620 --> 00:02:43,900
so assistant program is defeated likely

00:02:41,920 --> 00:02:49,750
to be used to support other software

00:02:43,900 --> 00:02:53,170
programs so I'm system so this this

00:02:49,750 --> 00:02:55,030
system program can be an application in

00:02:53,170 --> 00:02:59,049
itself or it can be used to support

00:02:55,030 --> 00:03:01,930
something else for example the operating

00:02:59,049 --> 00:03:07,629
system is written in like some systems

00:03:01,930 --> 00:03:10,389
programming language like C provides so

00:03:07,629 --> 00:03:13,060
if you want to read or read from a write

00:03:10,389 --> 00:03:15,040
to files on disk the operating system

00:03:13,060 --> 00:03:19,419
would provide you the functionality to

00:03:15,040 --> 00:03:25,450
do this it makes sure you have sorry it

00:03:19,419 --> 00:03:29,530
makes sure you have programs to access

00:03:25,450 --> 00:03:31,989
permissions to handle multiple files of

00:03:29,530 --> 00:03:33,849
accessing files and loading blocks into

00:03:31,989 --> 00:03:36,699
memory and so on

00:03:33,849 --> 00:03:40,299
so it is likely to be continuously

00:03:36,699 --> 00:03:42,430
evolving so it is in contrast with the

00:03:40,299 --> 00:03:45,400
systems of nineteen seventies where you

00:03:42,430 --> 00:03:47,859
had one shot one shot solution using an

00:03:45,400 --> 00:03:52,540
application rather than continously

00:03:47,859 --> 00:03:58,750
evolving o canonist e evolving systems

00:03:52,540 --> 00:04:03,909
so oh sorry the key idea in this paper

00:03:58,750 --> 00:04:07,629
is descriptive so defining a system but

00:04:03,909 --> 00:04:12,150
the but the key idea in this paper is

00:04:07,629 --> 00:04:14,590
prescriptive so separating the

00:04:12,150 --> 00:04:17,739
separating the language at the time

00:04:14,590 --> 00:04:24,759
assembly from Fortran which was more

00:04:17,739 --> 00:04:26,919
higher level so a language which can be

00:04:24,759 --> 00:04:29,500
used without undue concern for bit

00:04:26,919 --> 00:04:32,620
twiddling which can be used to design

00:04:29,500 --> 00:04:36,870
and write more systems without

00:04:32,620 --> 00:04:40,180
unnecessary overhead on resources and

00:04:36,870 --> 00:04:42,730
the last paper from 1970s was this

00:04:40,180 --> 00:04:47,770
program was the paper consistent

00:04:42,730 --> 00:04:50,500
programming but Donovan so the first

00:04:47,770 --> 00:04:53,140
time we had computers we dealt with them

00:04:50,500 --> 00:04:55,120
using on and off switches and then we

00:04:53,140 --> 00:04:59,260
wanted to do more complicated things

00:04:55,120 --> 00:05:01,690
like if I have Y which is 50 and I want

00:04:59,260 --> 00:05:02,470
to calculate X which is 30 into R how do

00:05:01,690 --> 00:05:06,070
I do that

00:05:02,470 --> 00:05:08,350
so present-day programs cannot

00:05:06,070 --> 00:05:11,140
understand these without the aid of

00:05:08,350 --> 00:05:16,680
systems programs like microprocessors

00:05:11,140 --> 00:05:19,930
and compilers and assemblers and etc so

00:05:16,680 --> 00:05:22,090
to make computers better adapted to the

00:05:19,930 --> 00:05:26,590
needs of the user we need systems

00:05:22,090 --> 00:05:31,450
program is what the paper said in 1972

00:05:26,590 --> 00:05:35,080
and then in the 70s and 80s most

00:05:31,450 --> 00:05:37,480
researchers saw systems systems

00:05:35,080 --> 00:05:39,760
programming languages in contrast with

00:05:37,480 --> 00:05:44,200
assembly programming there was something

00:05:39,760 --> 00:05:47,230
no good tools to build but both systems

00:05:44,200 --> 00:05:50,530
however in the mid 90s it was the rise

00:05:47,230 --> 00:05:55,450
of scripting like there's a dynamically

00:05:50,530 --> 00:05:58,570
typed scripting languages so bash

00:05:55,450 --> 00:06:01,870
languages like Perl Python Adobe you

00:05:58,570 --> 00:06:04,800
gain steam and make make made their way

00:06:01,870 --> 00:06:07,660
to the works through the mainstream and

00:06:04,800 --> 00:06:09,490
systems programming languages who are

00:06:07,660 --> 00:06:12,940
designed to been more primitive computer

00:06:09,490 --> 00:06:16,000
elements versus cryptic languages were

00:06:12,940 --> 00:06:18,100
designed for gluing so you can separate

00:06:16,000 --> 00:06:21,310
scripting languages and systems

00:06:18,100 --> 00:06:23,080
languages on technically you can

00:06:21,310 --> 00:06:27,730
separate them on the access of type

00:06:23,080 --> 00:06:30,400
safety vs. if you were to step or

00:06:27,730 --> 00:06:33,550
separate them on the access on on the

00:06:30,400 --> 00:06:36,910
basis of design you can say that systems

00:06:33,550 --> 00:06:40,420
languages are programming languages are

00:06:36,910 --> 00:06:43,720
designed to build more complicated

00:06:40,420 --> 00:06:46,900
software versus scripting languages are

00:06:43,720 --> 00:06:53,050
designed to glue those cars do glue

00:06:46,900 --> 00:06:56,360
those components together and so in 2010

00:06:53,050 --> 00:06:59,479
stubborn 2010 around that time the

00:06:56,360 --> 00:07:03,080
splurt so massive resources were put

00:06:59,479 --> 00:07:05,840
into Java Justin building just-in-time

00:07:03,080 --> 00:07:08,780
compilers for JavaScript like create or

00:07:05,840 --> 00:07:11,479
patents paid by and their performance is

00:07:08,780 --> 00:07:17,919
not better but if not better

00:07:11,479 --> 00:07:21,379
almost as competitive to C and C++ and

00:07:17,919 --> 00:07:23,810
draw box was able to burn its large and

00:07:21,379 --> 00:07:26,270
scalable system and just fight on chest

00:07:23,810 --> 00:07:29,840
rip is he stood under your show time and

00:07:26,270 --> 00:07:32,810
Georgia you eyes with in in billions of

00:07:29,840 --> 00:07:37,129
web pages and there was gradual typing

00:07:32,810 --> 00:07:40,069
in JavaScript and Python which enables

00:07:37,129 --> 00:07:43,189
people to transition from prototype to

00:07:40,069 --> 00:07:45,860
production code and large-scale

00:07:43,189 --> 00:07:52,580
distributed systems languages like go

00:07:45,860 --> 00:07:56,060
and go etc say go etcetera put in

00:07:52,580 --> 00:07:59,960
resources so that garbage collector

00:07:56,060 --> 00:08:04,069
languages also performed well so which

00:07:59,960 --> 00:08:06,169
are leads all of this leads us to what

00:08:04,069 --> 00:08:10,909
does it mean to be a system for learning

00:08:06,169 --> 00:08:15,069
language today so languages in the

00:08:10,909 --> 00:08:17,750
category of C and C++ and rust in D are

00:08:15,069 --> 00:08:21,529
distinguished in the terms of the level

00:08:17,750 --> 00:08:22,610
of abstraction they provide you from the

00:08:21,529 --> 00:08:26,419
machine

00:08:22,610 --> 00:08:28,129
so the languages expose the videos of

00:08:26,419 --> 00:08:31,990
underlying hardware like memory

00:08:28,129 --> 00:08:36,560
allocation layout etc so when you have a

00:08:31,990 --> 00:08:39,589
efficiency problem is it in your part to

00:08:36,560 --> 00:08:41,810
eliminate the bottleneck so the

00:08:39,589 --> 00:08:46,279
wonderful part about these languages is

00:08:41,810 --> 00:08:48,529
that they provide you confidence so if

00:08:46,279 --> 00:08:50,839
you have a statically typed language and

00:08:48,529 --> 00:08:52,730
you say this language gives me the

00:08:50,839 --> 00:08:55,339
confidence that if I'm adding these two

00:08:52,730 --> 00:08:57,589
integers I'm going to get a result which

00:08:55,339 --> 00:09:00,140
is an integer the same way these

00:08:57,589 --> 00:09:02,990
languages give you the confidence that

00:09:00,140 --> 00:09:05,959
if I'm executing this instruction and a

00:09:02,990 --> 00:09:07,040
machine then it will work exactly as I

00:09:05,959 --> 00:09:09,830
wanted to

00:09:07,040 --> 00:09:14,360
so lower level programmers should seek

00:09:09,830 --> 00:09:16,910
you understand how the system design

00:09:14,360 --> 00:09:19,450
could be adapted to the reality of

00:09:16,910 --> 00:09:21,710
modern-day hardware and

00:09:19,450 --> 00:09:25,610
something-something rust does really

00:09:21,710 --> 00:09:30,010
well is that it takes the ideas of the

00:09:25,610 --> 00:09:32,690
functional programming and and

00:09:30,010 --> 00:09:36,080
lower-level problems like futures and

00:09:32,690 --> 00:09:38,860
type safety of course and uses them I

00:09:36,080 --> 00:09:42,710
uses them to make the language better

00:09:38,860 --> 00:09:46,010
and we should also consider the added

00:09:42,710 --> 00:09:49,100
benefits of using our switches it

00:09:46,010 --> 00:09:52,040
provide which are enabled for us types

00:09:49,100 --> 00:09:55,310
establishes static information for

00:09:52,040 --> 00:09:58,580
control and safe showers of pointillist

00:09:55,310 --> 00:10:04,610
data structures and software fault

00:09:58,580 --> 00:10:06,620
isolation and with that with with the

00:10:04,610 --> 00:10:09,350
history of the sensor having languages

00:10:06,620 --> 00:10:14,450
and where we stand today I want to jump

00:10:09,350 --> 00:10:17,540
into the next part of this talk which is

00:10:14,450 --> 00:10:19,040
oh sorry before that you can throw

00:10:17,540 --> 00:10:21,290
everything I've said out of the windows

00:10:19,040 --> 00:10:22,940
and systems programming is when you

00:10:21,290 --> 00:10:27,320
spend more time looking at the man

00:10:22,940 --> 00:10:30,770
spacious than reading so with that I

00:10:27,320 --> 00:10:34,880
want to jump on to the next part of my

00:10:30,770 --> 00:10:37,490
talk which is writing our own s tres um

00:10:34,880 --> 00:10:39,560
so for this I hope to empower you to

00:10:37,490 --> 00:10:44,780
like your own s tres are even more

00:10:39,560 --> 00:10:47,780
complicated systems Perkins so let's say

00:10:44,780 --> 00:10:51,530
you have a user program and user process

00:10:47,780 --> 00:10:54,250
and you want to do something that that

00:10:51,530 --> 00:10:57,890
seems as trivial as reading from a file

00:10:54,250 --> 00:11:00,110
but it's your operating system has the

00:10:57,890 --> 00:11:02,480
necessary privileges to read the file it

00:11:00,110 --> 00:11:08,270
has to find a scripture and it has the

00:11:02,480 --> 00:11:10,700
it has the it had and it has the

00:11:08,270 --> 00:11:13,250
location of the file and you want to

00:11:10,700 --> 00:11:15,890
read this file but you have to talk to

00:11:13,250 --> 00:11:19,660
the operating system to do that so who

00:11:15,890 --> 00:11:19,660
you got a car system cars

00:11:19,889 --> 00:11:25,569
so you can think of system cars as an

00:11:22,720 --> 00:11:27,910
interface between your operating system

00:11:25,569 --> 00:11:30,730
and user program or you can think of as

00:11:27,910 --> 00:11:35,829
an API that is given by the operating

00:11:30,730 --> 00:11:38,740
system to you for you to use and there's

00:11:35,829 --> 00:11:42,009
like around 330 system cars and they're

00:11:38,740 --> 00:11:45,220
not so if though I write esoteric and

00:11:42,009 --> 00:11:47,199
some of them are very common so some of

00:11:45,220 --> 00:11:51,130
the common ones for like file access a

00:11:47,199 --> 00:11:54,000
create read write open and close so I

00:11:51,130 --> 00:11:56,589
included create here because one can

00:11:54,000 --> 00:11:57,790
Thompson was asked if he had any regrets

00:11:56,589 --> 00:12:00,399
about Unix

00:11:57,790 --> 00:12:05,920
he said I wish I had named let's see Rea

00:12:00,399 --> 00:12:08,079
te and not G and which is also this

00:12:05,920 --> 00:12:12,699
system guy is obsolete now because if

00:12:08,079 --> 00:12:17,050
open but I included it for that Chuck so

00:12:12,699 --> 00:12:18,790
and the net more system cause so for the

00:12:17,050 --> 00:12:22,089
process control if you want to wait for

00:12:18,790 --> 00:12:24,850
a process you can use rater a PID if you

00:12:22,089 --> 00:12:26,380
want a killer process you are you would

00:12:24,850 --> 00:12:32,829
use kill if you want to spawn another

00:12:26,380 --> 00:12:36,130
process you would use for it and for

00:12:32,829 --> 00:12:38,410
network access you have socket when you

00:12:36,130 --> 00:12:42,639
wanna create a socket get suck suck it

00:12:38,410 --> 00:12:45,399
get suck obd when you want to set or get

00:12:42,639 --> 00:12:49,449
the options in a socket or anyone listen

00:12:45,399 --> 00:12:52,269
to a sake when he's listen so what

00:12:49,449 --> 00:12:55,779
happens when assistant occur is that say

00:12:52,269 --> 00:12:59,620
we want to read from a file so the user

00:12:55,779 --> 00:13:02,649
program would push the number of bytes

00:12:59,620 --> 00:13:05,050
it wants to read push the buffer which

00:13:02,649 --> 00:13:08,079
is the address of where it wants the

00:13:05,050 --> 00:13:11,350
result of the reader to be stored and

00:13:08,079 --> 00:13:13,870
the file descriptor into registers and

00:13:11,350 --> 00:13:16,360
it will call feed and then it gives you

00:13:13,870 --> 00:13:19,209
a library procedure which will put the

00:13:16,360 --> 00:13:21,490
code for the system call in a register

00:13:19,209 --> 00:13:24,430
so each system called has a number

00:13:21,490 --> 00:13:29,889
associated with it for example either 0

00:13:24,430 --> 00:13:32,050
openness 2 and so on so you've read the

00:13:29,889 --> 00:13:35,410
code and the register and the son

00:13:32,050 --> 00:13:37,149
trap to the corner and then now there's

00:13:35,410 --> 00:13:40,180
a context switch and you go to the

00:13:37,149 --> 00:13:45,580
colonel the colonel will go and look

00:13:40,180 --> 00:13:47,560
into the register for what what side so

00:13:45,580 --> 00:13:50,200
when you send a chap you send a chopper

00:13:47,560 --> 00:13:52,720
with a number so that number is the

00:13:50,200 --> 00:13:54,970
number of the system call and in the

00:13:52,720 --> 00:13:57,430
operating system there's an array where

00:13:54,970 --> 00:14:00,700
like the colonel goes are you sent zero

00:13:57,430 --> 00:14:03,040
and zero Main Street so it go and look

00:14:00,700 --> 00:14:06,010
into the registers of like what file I

00:14:03,040 --> 00:14:09,250
have to read and where I have to store

00:14:06,010 --> 00:14:11,800
the result of the read and once the

00:14:09,250 --> 00:14:13,450
colonel does that it's written there's

00:14:11,800 --> 00:14:16,029
another context switch back to the

00:14:13,450 --> 00:14:18,370
library procedure and finally to the

00:14:16,029 --> 00:14:21,690
user program so one thing to note is

00:14:18,370 --> 00:14:25,800
that system calls are fairly expensive

00:14:21,690 --> 00:14:30,250
you have two context switches involved

00:14:25,800 --> 00:14:34,029
yeah so making a system cut is you have

00:14:30,250 --> 00:14:35,829
a register where you would have the file

00:14:34,029 --> 00:14:38,350
descriptor stored at register where you

00:14:35,829 --> 00:14:40,600
have the buffer stored and the register

00:14:38,350 --> 00:14:43,600
with the count of bytes that are that

00:14:40,600 --> 00:14:45,370
are to be that Oh dad for example so you

00:14:43,600 --> 00:14:48,279
set up a register with the system card

00:14:45,370 --> 00:14:50,470
number and parametres you send a trap to

00:14:48,279 --> 00:14:54,730
the kernel and you get the result stone

00:14:50,470 --> 00:14:57,370
in the register but the good thing is we

00:14:54,730 --> 00:15:01,300
don't have to do it oops we don't have

00:14:57,370 --> 00:15:06,130
to do any of this because UNIX provides

00:15:01,300 --> 00:15:10,089
us with a library called MC which is a C

00:15:06,130 --> 00:15:12,430
library and the problem that we must

00:15:10,089 --> 00:15:18,190
respect our is however this array is

00:15:12,430 --> 00:15:20,620
that it has it has our King types so it

00:15:18,190 --> 00:15:25,920
gives you white pointers a lot of white

00:15:20,620 --> 00:15:31,540
pointers that you'd have to use oh but

00:15:25,920 --> 00:15:34,449
it's the only API so that's cool so we

00:15:31,540 --> 00:15:37,329
so now that we have an idea of what

00:15:34,449 --> 00:15:40,149
happens when assist occurs and how do

00:15:37,329 --> 00:15:43,690
you make assess color I want to jump on

00:15:40,149 --> 00:15:45,670
what's what is as trace so X traces are

00:15:43,690 --> 00:15:47,740
the nasty buggin you

00:15:45,670 --> 00:15:52,089
which allows you to debug the source

00:15:47,740 --> 00:15:56,410
programs for example if you have and it

00:15:52,089 --> 00:15:58,779
allows you to identify it allows you to

00:15:56,410 --> 00:16:01,060
identify bottlenecks in the program so

00:15:58,779 --> 00:16:04,029
we already know that system calls are

00:16:01,060 --> 00:16:05,740
expensive so if you have a program and

00:16:04,029 --> 00:16:07,959
what you have optimize it for its

00:16:05,740 --> 00:16:11,050
performance then you see that it's

00:16:07,959 --> 00:16:14,709
making more open calls than you thought

00:16:11,050 --> 00:16:16,930
it would you can go and optimize trace

00:16:14,709 --> 00:16:19,089
or tell you how many open system costs

00:16:16,930 --> 00:16:22,690
that your program is making and I can go

00:16:19,089 --> 00:16:25,870
and up demonstrate that and it's also

00:16:22,690 --> 00:16:29,200
invaluable when you have closed source

00:16:25,870 --> 00:16:31,480
program you can't just go and attach gdb

00:16:29,200 --> 00:16:33,220
and say oh please stop at like 12

00:16:31,480 --> 00:16:37,089
because you don't know what's it like 12

00:16:33,220 --> 00:16:40,450
so in that case if you have a cursors

00:16:37,089 --> 00:16:43,149
program which has which you thought was

00:16:40,450 --> 00:16:46,720
oh it's not working like you wished it

00:16:43,149 --> 00:16:48,850
would and you you go and see the s trace

00:16:46,720 --> 00:16:51,310
for it and it's opening X instead of

00:16:48,850 --> 00:16:56,320
opening why he cast race will tell you

00:16:51,310 --> 00:16:59,800
that so if I have a very so prepare

00:16:56,320 --> 00:17:02,500
yourself for the record and I see the a

00:16:59,800 --> 00:17:04,510
straight out portrayed I'm not sure if

00:17:02,500 --> 00:17:08,130
it's visible but I will still see what

00:17:04,510 --> 00:17:11,319
it is so it has it first has an exact

00:17:08,130 --> 00:17:14,410
system code which is executing my script

00:17:11,319 --> 00:17:16,839
and then it has a break and access and M

00:17:14,410 --> 00:17:18,669
map and so on and it lists all the

00:17:16,839 --> 00:17:22,630
system cards that are made in that order

00:17:18,669 --> 00:17:24,669
and if I have our s trees - C which will

00:17:22,630 --> 00:17:29,110
tell me the count of all the system

00:17:24,669 --> 00:17:31,929
calls that were made so I have eleven

00:17:29,110 --> 00:17:34,330
system comes to read a nine to open and

00:17:31,929 --> 00:17:37,690
so on twelve tell me oh this isn't cars

00:17:34,330 --> 00:17:40,840
that were made which is pretty honey um

00:17:37,690 --> 00:17:43,150
so that's the laughs now it's the last

00:17:40,840 --> 00:17:48,460
part of myself wishes we will write our

00:17:43,150 --> 00:17:51,700
own s trace so we need three things to

00:17:48,460 --> 00:17:53,800
write our own s trace one is we need to

00:17:51,700 --> 00:17:56,890
know how to observe another process

00:17:53,800 --> 00:17:58,119
which is an important part because we

00:17:56,890 --> 00:18:00,639
want to find out how many

00:17:58,119 --> 00:18:04,119
some colace other process is making

00:18:00,639 --> 00:18:07,179
second is how to trap assistant go once

00:18:04,119 --> 00:18:10,269
we know that we have a process how do we

00:18:07,179 --> 00:18:13,149
know that it's making a system card and

00:18:10,269 --> 00:18:14,379
the third is once we know that system

00:18:13,149 --> 00:18:16,509
call is being made

00:18:14,379 --> 00:18:18,489
that's right sure but now you want to

00:18:16,509 --> 00:18:21,189
look at the registers to see what's

00:18:18,489 --> 00:18:23,199
happening or like what system code was

00:18:21,189 --> 00:18:27,189
made because the registers the value of

00:18:23,199 --> 00:18:31,029
the system card so how do we observe

00:18:27,189 --> 00:18:32,229
another process who have system costs to

00:18:31,029 --> 00:18:35,949
the rescue again

00:18:32,229 --> 00:18:38,199
P trace so P trace is a not a POSIX

00:18:35,949 --> 00:18:39,579
system card which means it has different

00:18:38,199 --> 00:18:43,449
behaviors and different operating

00:18:39,579 --> 00:18:46,389
systems but for Linux we have P trace so

00:18:43,449 --> 00:18:49,299
you have a tracer and a Tracy and what

00:18:46,389 --> 00:18:51,459
we trace allows you to do is observe

00:18:49,299 --> 00:18:56,619
uncontrolled execution of this other

00:18:51,459 --> 00:18:59,079
process which is very shady because you

00:18:56,619 --> 00:19:01,209
can go and change the dredge esters of

00:18:59,079 --> 00:19:06,279
this other the profit this other process

00:19:01,209 --> 00:19:09,579
and do malicious things but the good

00:19:06,279 --> 00:19:13,599
thing is that if you want to observe

00:19:09,579 --> 00:19:17,139
another process this other process has

00:19:13,599 --> 00:19:20,559
to give you explicit permission that yes

00:19:17,139 --> 00:19:22,419
I want to be traced and the second is if

00:19:20,559 --> 00:19:24,849
you want to chase this other process you

00:19:22,419 --> 00:19:28,569
need to be in the parent namespace of

00:19:24,849 --> 00:19:32,319
this process so the first line of this

00:19:28,569 --> 00:19:35,109
code is the process giving me explicit

00:19:32,319 --> 00:19:37,389
permission to trace it and the second is

00:19:35,109 --> 00:19:39,159
me spawning this process so that I can

00:19:37,389 --> 00:19:43,089
be in the parent name space of the

00:19:39,159 --> 00:19:46,239
process and the next is the next thing

00:19:43,089 --> 00:19:51,119
we care about is how to chop the system

00:19:46,239 --> 00:19:55,479
code so P traits do the rescue again

00:19:51,119 --> 00:19:58,719
so every time the process that we are

00:19:55,479 --> 00:20:02,769
tracing makes a system call a sig shop

00:19:58,719 --> 00:20:04,749
is sent to the tracer and then execution

00:20:02,769 --> 00:20:08,019
stops so you can go and check the

00:20:04,749 --> 00:20:11,390
register if you want to and you wait on

00:20:08,019 --> 00:20:16,520
this process so you will stop every time

00:20:11,390 --> 00:20:18,920
I said a cig trap is send so few choice

00:20:16,520 --> 00:20:23,830
to the rescue again it has a flag called

00:20:18,920 --> 00:20:23,830
P trade system car which means that

00:20:24,160 --> 00:20:31,550
every time a system cars called a sec

00:20:27,500 --> 00:20:33,650
traffic miss path would be would be a

00:20:31,550 --> 00:20:38,690
cig trap would be sent and you can stop

00:20:33,650 --> 00:20:41,320
and inspect the registers or arguments

00:20:38,690 --> 00:20:44,840
to the system call if you wish to and

00:20:41,320 --> 00:20:47,050
then you can start race so this will

00:20:44,840 --> 00:20:50,390
happen in a loop so you can resume

00:20:47,050 --> 00:20:52,520
resume your process again and then the

00:20:50,390 --> 00:20:57,200
next time a system happens you stop

00:20:52,520 --> 00:21:02,390
again and you can inspect the arguments

00:20:57,200 --> 00:21:06,290
again and so on and then the last is how

00:21:02,390 --> 00:21:09,890
to fetch a sir values which is again

00:21:06,290 --> 00:21:12,440
features it's amazing you know Sophie

00:21:09,890 --> 00:21:15,110
trace has a flag called P trace

00:21:12,440 --> 00:21:18,620
underscore cash registers which will get

00:21:15,110 --> 00:21:21,260
you all the registers but once you get

00:21:18,620 --> 00:21:23,570
all the registers you know you have to

00:21:21,260 --> 00:21:27,860
know which register stores which value

00:21:23,570 --> 00:21:31,220
so I found out through googling that the

00:21:27,860 --> 00:21:33,980
other extra gesture stores the value of

00:21:31,220 --> 00:21:36,860
this stores the number of the system car

00:21:33,980 --> 00:21:39,860
so you can use that to find out what

00:21:36,860 --> 00:21:47,300
system code was made and you know I have

00:21:39,860 --> 00:21:53,240
a demo so I have a simple program

00:21:47,300 --> 00:21:55,730
because some people feel cool I have a

00:21:53,240 --> 00:21:59,990
simple program stuff hello Josh Roscoe

00:21:55,730 --> 00:22:03,580
and in this and I have another yes five

00:21:59,990 --> 00:22:07,250
restores are the three thirty two sister

00:22:03,580 --> 00:22:10,100
thinks so zero is read and then one is

00:22:07,250 --> 00:22:15,200
dried and two is open I shouldn't make a

00:22:10,100 --> 00:22:17,300
trade yeah and then in this main program

00:22:15,200 --> 00:22:19,010
I have like a function code get

00:22:17,300 --> 00:22:23,440
registers which would get me the

00:22:19,010 --> 00:22:23,440
registers and then I

00:22:23,660 --> 00:22:29,960
the the child allows the parent to trace

00:22:26,600 --> 00:22:34,460
it and I spun the process and in this

00:22:29,960 --> 00:22:36,590
loop I will get the registers and map

00:22:34,460 --> 00:22:41,929
the system call names and insert in the

00:22:36,590 --> 00:22:49,190
milk and if I want to run s trace on

00:22:41,929 --> 00:22:54,590
hello oops sorry yeah then it says the

00:22:49,190 --> 00:22:58,010
Raskin and telling me that Oh sounds was

00:22:54,590 --> 00:23:00,440
gone nine times and F start with seven

00:22:58,010 --> 00:23:05,059
times and readers cut seven times which

00:23:00,440 --> 00:23:11,390
is pretty neat yeah so in conclusion I

00:23:05,059 --> 00:23:15,679
want to say say in conclusion I want to

00:23:11,390 --> 00:23:18,650
say that trust is very empowering and

00:23:15,679 --> 00:23:23,179
it's so much cooler than C or C++

00:23:18,650 --> 00:23:24,890
because because it follows the ax - that

00:23:23,179 --> 00:23:27,980
like if it compiles

00:23:24,890 --> 00:23:31,880
it will work which is which is not true

00:23:27,980 --> 00:23:33,350
for C or C++ at R and if you were doing

00:23:31,880 --> 00:23:36,380
this you would have to do memory

00:23:33,350 --> 00:23:42,320
allocation and other things which are

00:23:36,380 --> 00:23:44,390
hard and scary for new people yeah so

00:23:42,320 --> 00:23:46,490
and I would like to give it a minor that

00:23:44,390 --> 00:23:49,700
systems things are not hard at all

00:23:46,490 --> 00:23:52,760
if they are explained well and I made

00:23:49,700 --> 00:23:55,880
more accessible to more people it's like

00:23:52,760 --> 00:23:58,000
if you think about networking it seems

00:23:55,880 --> 00:24:01,820
very hard because it has all these

00:23:58,000 --> 00:24:04,250
intimidating concepts but then it's like

00:24:01,820 --> 00:24:06,799
the core concepts are like IP addresses

00:24:04,250 --> 00:24:10,130
and first cetera and once you understand

00:24:06,799 --> 00:24:12,169
though you can do that thank you so much

00:24:10,130 --> 00:24:14,690
also I want to give a shout out to a

00:24:12,169 --> 00:24:17,919
shallow Hardy Taylor Kerry and with you

00:24:14,690 --> 00:24:20,900
Harris ho Steven Steven for helping me

00:24:17,919 --> 00:24:25,240
with the stock and thank you so much

00:24:20,900 --> 00:24:38,549
[Applause]

00:24:25,240 --> 00:24:38,549

YouTube URL: https://www.youtube.com/watch?v=G0e2lVENaCU


