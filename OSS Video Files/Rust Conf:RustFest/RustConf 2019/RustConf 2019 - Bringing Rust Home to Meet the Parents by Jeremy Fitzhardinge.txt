Title: RustConf 2019 - Bringing Rust Home to Meet the Parents by Jeremy Fitzhardinge
Publication date: 2019-09-16
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Bringing Rust Home to Meet the Parents by Jeremy Fitzhardinge

How can you bring your love for Rust to your organization, and how can you set it up for success?

Facebook has a ton of code written in a lot of languages. Is there room for Rust? Yes! This talk covers my journey of discovery integrating Rust into a large existing software ecosystem while trying to preserve all of Rust’s nice properties. Writing, building, testing, third-party code, foreign bindings, debugging, deployment, monitoring all need to be re-examined in the light of this new environment. How did we go from nothing to a core production service in Rust?

No two orgs are alike - you’ll walk away with a practical set of questions you’ll need to consider for your org (and maybe some answers).
Captions: 
	00:00:08,770 --> 00:00:15,680
[Music]

00:00:16,870 --> 00:00:24,530
hello so we've all been using rust for

00:00:22,150 --> 00:00:28,430
some amount of time I've been using it

00:00:24,530 --> 00:00:34,360
since before 1.0 and for a long time it

00:00:28,430 --> 00:00:36,440
was a fun sort of side experiment but

00:00:34,360 --> 00:00:38,000
what have you wanted to make it part of

00:00:36,440 --> 00:00:42,199
your everyday life one if you wanted to

00:00:38,000 --> 00:00:46,809
bring it to work and make it the focus

00:00:42,199 --> 00:00:49,070
of your working day so hello I'm Jeremy

00:00:46,809 --> 00:00:51,860
I've been in the industry for about

00:00:49,070 --> 00:00:55,699
thirty years mostly doing system

00:00:51,860 --> 00:00:57,710
software and like at the kernel level

00:00:55,699 --> 00:01:02,989
below the kernel just above the kernel

00:00:57,710 --> 00:01:05,059
mostly see mostly C++ a bit of C++ but

00:01:02,989 --> 00:01:08,090
basically I've seen everything that can

00:01:05,059 --> 00:01:10,280
go wrong in a C program which as it's

00:01:08,090 --> 00:01:14,990
commonly known is a lot of things so

00:01:10,280 --> 00:01:17,420
when I found rust and I'm also appeal

00:01:14,990 --> 00:01:18,830
kind of enthusiast and so I've been

00:01:17,420 --> 00:01:21,490
experimenting with a lot of languages

00:01:18,830 --> 00:01:23,990
but when I found rust it was the first

00:01:21,490 --> 00:01:25,640
programming language that I that

00:01:23,990 --> 00:01:28,310
genuinely solved a whole class of

00:01:25,640 --> 00:01:30,680
problems but also could replace C in

00:01:28,310 --> 00:01:33,230
every possible role that C currently has

00:01:30,680 --> 00:01:35,780
so I was super enthusiastic about it and

00:01:33,230 --> 00:01:38,150
started using it everywhere three years

00:01:35,780 --> 00:01:39,740
ago I joined Facebook it was the first

00:01:38,150 --> 00:01:42,650
time I had deliberately joined a large

00:01:39,740 --> 00:01:45,470
company and so it was an interesting

00:01:42,650 --> 00:01:47,090
experience for me to learn how large

00:01:45,470 --> 00:01:49,940
companies work how things fit together

00:01:47,090 --> 00:01:52,700
how technologies are used in large

00:01:49,940 --> 00:01:54,770
companies I found that there was a lot

00:01:52,700 --> 00:01:56,300
of interest in rust but no one really

00:01:54,770 --> 00:01:59,659
doing anything about it was just sort of

00:01:56,300 --> 00:02:04,250
an ambient enthusiasm so I thought why

00:01:59,659 --> 00:02:05,840
not do something about this so what does

00:02:04,250 --> 00:02:12,630
it mean to bring a new programming

00:02:05,840 --> 00:02:14,620
language to a company like Facebook it's

00:02:12,630 --> 00:02:17,709
[Music]

00:02:14,620 --> 00:02:20,120
not really a technical matter like

00:02:17,709 --> 00:02:21,769
introducing new language just download

00:02:20,120 --> 00:02:24,140
the compiler build something hooray

00:02:21,769 --> 00:02:27,219
we've introduced in your language it's

00:02:24,140 --> 00:02:30,300
not a technical matter it's a lot of

00:02:27,219 --> 00:02:32,970
social factors to take into account

00:02:30,300 --> 00:02:34,560
new languages are intrinsically risky if

00:02:32,970 --> 00:02:36,120
you're gonna write some code in a new

00:02:34,560 --> 00:02:39,060
language you're investing in that

00:02:36,120 --> 00:02:40,739
language and if that language doesn't

00:02:39,060 --> 00:02:42,930
work out for some reason you've just

00:02:40,739 --> 00:02:44,580
wasted some time and worse you might

00:02:42,930 --> 00:02:46,010
have wasted some time that turns into

00:02:44,580 --> 00:02:47,970
tech tip that you have to like

00:02:46,010 --> 00:02:51,900
continuously drags on you for a long

00:02:47,970 --> 00:02:54,239
period of time and people are

00:02:51,900 --> 00:02:56,040
fundamentally interested in getting

00:02:54,239 --> 00:02:57,329
their job done like theirs enthusiasts

00:02:56,040 --> 00:02:59,519
and they'll be enthusiastic about

00:02:57,329 --> 00:03:03,299
anything they're enthusiastic about but

00:02:59,519 --> 00:03:05,250
a lot of people at a job they're to work

00:03:03,299 --> 00:03:07,680
and they've got a thing to do and they

00:03:05,250 --> 00:03:09,569
have managers and performance bonuses

00:03:07,680 --> 00:03:13,910
and data that are all kind of attached

00:03:09,569 --> 00:03:13,910
to being able to do that thing and so

00:03:14,000 --> 00:03:18,000
it's a risk for them to choose rust

00:03:16,410 --> 00:03:22,230
there has to be a good reason for them

00:03:18,000 --> 00:03:24,959
to do so and so rust doesn't have to be

00:03:22,230 --> 00:03:27,870
just a bit better than something else it

00:03:24,959 --> 00:03:30,569
has to be much better at at least one

00:03:27,870 --> 00:03:33,599
specific thing to even be worth worth

00:03:30,569 --> 00:03:35,010
their time and it has to be generally as

00:03:33,599 --> 00:03:46,130
good as their what they're currently

00:03:35,010 --> 00:03:48,840
using for everything else so there we go

00:03:46,130 --> 00:03:52,260
so what is much better mean let's say

00:03:48,840 --> 00:03:54,060
just random hand wavy figures much

00:03:52,260 --> 00:03:56,790
better is that it has to be 10 times

00:03:54,060 --> 00:03:58,639
better at something than any of the

00:03:56,790 --> 00:04:01,530
incumbent languages so rust

00:03:58,639 --> 00:04:08,459
you-know-whats rusts 10x advantage in

00:04:01,530 --> 00:04:10,950
this case then the argument I'm going

00:04:08,459 --> 00:04:14,129
for that I think holds pretty well is

00:04:10,950 --> 00:04:17,940
that rust detects large classes of

00:04:14,129 --> 00:04:20,160
serious bugs at compile time and that

00:04:17,940 --> 00:04:22,650
detecting bugs at compile time is orders

00:04:20,160 --> 00:04:24,630
of magnitude cheaper than running

00:04:22,650 --> 00:04:26,820
finding those bugs when the code has

00:04:24,630 --> 00:04:34,250
gone into production when it's crashing

00:04:26,820 --> 00:04:38,550
in a bad way so there that sounds good

00:04:34,250 --> 00:04:40,710
why why what what on what grounds

00:04:38,550 --> 00:04:42,010
can I make that case to the rest of

00:04:40,710 --> 00:04:46,090
Facebook

00:04:42,010 --> 00:04:47,650
so when I joined I was in the source

00:04:46,090 --> 00:04:49,660
control team and the source control team

00:04:47,650 --> 00:04:53,860
had this problem that they could see a

00:04:49,660 --> 00:04:56,680
whole bunch of curves going mm-hmm and

00:04:53,860 --> 00:04:58,570
they could see at some point that the

00:04:56,680 --> 00:05:00,310
source control team like primarily the

00:04:58,570 --> 00:05:02,740
tooling is based around material which

00:05:00,310 --> 00:05:04,840
is written in Python and they had spent

00:05:02,740 --> 00:05:07,360
many years very thoroughly tuning that

00:05:04,840 --> 00:05:09,280
that code base so it was actually doing

00:05:07,360 --> 00:05:10,990
a reasonably good a surprisingly good

00:05:09,280 --> 00:05:12,760
job given the scale that it was

00:05:10,990 --> 00:05:14,370
operating at but they could see that

00:05:12,760 --> 00:05:17,410
there was a maximum limit at which

00:05:14,370 --> 00:05:19,090
mercurial could accept commits which was

00:05:17,410 --> 00:05:20,680
one of the sort of primary concerns and

00:05:19,090 --> 00:05:22,630
they could see that the curves were

00:05:20,680 --> 00:05:24,430
going to hit that rate within a couple

00:05:22,630 --> 00:05:28,570
of years so there was gonna be a hard

00:05:24,430 --> 00:05:30,730
ceiling and you know one off one

00:05:28,570 --> 00:05:32,680
possibility would have been to just try

00:05:30,730 --> 00:05:34,420
and optimize mercurial a bit more

00:05:32,680 --> 00:05:37,450
rewrite bits of it in other languages

00:05:34,420 --> 00:05:38,770
hack around but there was also a whole

00:05:37,450 --> 00:05:41,040
bunch of functional things that

00:05:38,770 --> 00:05:44,320
mercurial's model wasn't really

00:05:41,040 --> 00:05:45,880
accommodating so we made the sort of

00:05:44,320 --> 00:05:47,680
architectural decision to say let's

00:05:45,880 --> 00:05:49,900
build a whole new source control backend

00:05:47,680 --> 00:05:51,700
from scratch that not only has better

00:05:49,900 --> 00:05:56,650
performance but unlocks a whole bunch of

00:05:51,700 --> 00:05:58,300
new capabilities so this plan was

00:05:56,650 --> 00:05:59,440
already formed when I joined the company

00:05:58,300 --> 00:06:00,970
and it was sort of sitting on the Shelf

00:05:59,440 --> 00:06:02,830
waiting for someone to adopt it and it

00:06:00,970 --> 00:06:04,600
was basically new source control server

00:06:02,830 --> 00:06:06,730
written in a compiled language no

00:06:04,600 --> 00:06:09,880
compiled language in facebook terms

00:06:06,730 --> 00:06:11,740
that's really a code for C++ but I kind

00:06:09,880 --> 00:06:13,360
of was new to the company and so I could

00:06:11,740 --> 00:06:15,040
like happily ignore that and go well

00:06:13,360 --> 00:06:19,780
compiled like rust as a compact let's do

00:06:15,040 --> 00:06:23,020
it and rest and the case I made then was

00:06:19,780 --> 00:06:25,090
that a source control server correctness

00:06:23,020 --> 00:06:26,590
is a very is like the primary

00:06:25,090 --> 00:06:28,030
requirement like obviously we had

00:06:26,590 --> 00:06:29,530
performance goals but we were pretty

00:06:28,030 --> 00:06:31,120
confident we could hit those regardless

00:06:29,530 --> 00:06:33,760
just by writing into compiled language

00:06:31,120 --> 00:06:35,430
but correctness was very important that

00:06:33,760 --> 00:06:37,300
corrupting source code which is

00:06:35,430 --> 00:06:40,120
literally the crown jewels of the

00:06:37,300 --> 00:06:41,980
company is a complete non-starter so we

00:06:40,120 --> 00:06:44,170
would have to be very confident in the

00:06:41,980 --> 00:06:45,880
correctness of this new source control

00:06:44,170 --> 00:06:48,700
server before we could put it into

00:06:45,880 --> 00:06:51,160
production and so I argued that rust

00:06:48,700 --> 00:06:52,600
safety guarantees would give us that and

00:06:51,160 --> 00:06:54,190
that was a very nebulous argument at

00:06:52,600 --> 00:06:56,430
that point because it was really just on

00:06:54,190 --> 00:06:56,430
faith

00:06:56,650 --> 00:07:00,980
so we started Mononoke and also made the

00:06:59,390 --> 00:07:03,320
decision at that point to make it an

00:07:00,980 --> 00:07:06,230
async thing and that was a super early

00:07:03,320 --> 00:07:08,450
adopter of Tokyo and rust async because

00:07:06,230 --> 00:07:11,120
I started the project I committed the

00:07:08,450 --> 00:07:14,180
first file for it on the day that Tokyo

00:07:11,120 --> 00:07:15,710
hit crates i/o and that was just

00:07:14,180 --> 00:07:17,900
coincidence I was going to vendor it

00:07:15,710 --> 00:07:21,620
from get but it hit Cate say oh and so

00:07:17,900 --> 00:07:22,670
that made it easier to do but don't even

00:07:21,620 --> 00:07:26,060
get started I had to do a bit of

00:07:22,670 --> 00:07:28,040
groundwork I had to make a few targeted

00:07:26,060 --> 00:07:29,630
but high quality integrations into the

00:07:28,040 --> 00:07:31,700
environment I'm going to go into a bit

00:07:29,630 --> 00:07:33,560
more detail about this but I had to

00:07:31,700 --> 00:07:35,600
integrate rust into the build system

00:07:33,560 --> 00:07:38,630
integrate it into the test environment

00:07:35,600 --> 00:07:40,370
and integrate it working on a way of

00:07:38,630 --> 00:07:45,250
handling third-party dependencies with

00:07:40,370 --> 00:07:47,390
crates layer so three years later

00:07:45,250 --> 00:07:48,920
Mononoke is now in production it's the

00:07:47,390 --> 00:07:51,470
source of truth of one of our largest

00:07:48,920 --> 00:07:54,080
highest through foot repos and it's been

00:07:51,470 --> 00:07:57,560
working pretty well and all of the rust

00:07:54,080 --> 00:08:00,080
claims checked out we basically spent no

00:07:57,560 --> 00:08:01,760
time debugging weird memory corruption

00:08:00,080 --> 00:08:05,150
and strange race conditions and stuff

00:08:01,760 --> 00:08:07,640
like that and a lot of the people who

00:08:05,150 --> 00:08:09,110
sort of watched the project and then

00:08:07,640 --> 00:08:11,900
sort of looked at the retrospective and

00:08:09,110 --> 00:08:13,640
thought and and observed that compared

00:08:11,900 --> 00:08:17,180
to a C++ program in which that would

00:08:13,640 --> 00:08:19,160
have been the normal last few months of

00:08:17,180 --> 00:08:22,130
going into production that was

00:08:19,160 --> 00:08:29,270
remarkable there are still core dumps in

00:08:22,130 --> 00:08:31,640
production but they're kind of

00:08:29,270 --> 00:08:38,450
interesting sources one of them is stack

00:08:31,640 --> 00:08:41,030
overflows one of them is just unhandled

00:08:38,450 --> 00:08:43,700
C++ exceptions Crossing the FFI boundary

00:08:41,030 --> 00:08:45,380
and so and the rest are just buggy C++

00:08:43,700 --> 00:08:48,110
code and there isn't too much of that to

00:08:45,380 --> 00:08:49,280
be honest but the stack overflow is one

00:08:48,110 --> 00:08:52,690
was the kind of the most interesting

00:08:49,280 --> 00:08:57,140
from my point of view and so that was a

00:08:52,690 --> 00:08:59,630
successful enough project that the rest

00:08:57,140 --> 00:09:02,090
of the source control team has adopted

00:08:59,630 --> 00:09:04,400
rest for all new code development and

00:09:02,090 --> 00:09:07,040
they've been incrementally converting a

00:09:04,400 --> 00:09:09,529
lot of the existing Python code

00:09:07,040 --> 00:09:11,029
mercurial - well essentially - a new

00:09:09,529 --> 00:09:21,320
source control system that's written in

00:09:11,029 --> 00:09:23,329
rust alright so what is the environment

00:09:21,320 --> 00:09:26,360
that I'm talking about here like what

00:09:23,329 --> 00:09:28,819
does what does a facebook codebase look

00:09:26,360 --> 00:09:31,459
like and I'm specifically talking here

00:09:28,819 --> 00:09:33,740
about back-end code bases like where

00:09:31,459 --> 00:09:35,870
else sort of back-end services live that

00:09:33,740 --> 00:09:38,810
are not directly visible to the front

00:09:35,870 --> 00:09:41,540
side of either your apps or your the

00:09:38,810 --> 00:09:44,509
website the primary languages in there

00:09:41,540 --> 00:09:47,269
are C++ Java and Python like most of the

00:09:44,509 --> 00:09:48,800
back-end services are written in C++ a

00:09:47,269 --> 00:09:51,380
lot of the kind of analysis stuff is in

00:09:48,800 --> 00:09:54,589
Java and there's tons of Python just

00:09:51,380 --> 00:09:57,079
gluing things together but those are the

00:09:54,589 --> 00:09:59,990
three main languages it's a highly

00:09:57,079 --> 00:10:03,470
highly polyglot code base there are lots

00:09:59,990 --> 00:10:05,180
and lots of languages in use in general

00:10:03,470 --> 00:10:06,740
teams have a lot of freedom to choose

00:10:05,180 --> 00:10:11,180
what technologies and what languages

00:10:06,740 --> 00:10:16,190
they wish to use and answer they do and

00:10:11,180 --> 00:10:21,230
so we have Oh camel and Haskell and R

00:10:16,190 --> 00:10:23,120
and even bits of D in there but normally

00:10:21,230 --> 00:10:24,529
when teams choose a language they have a

00:10:23,120 --> 00:10:26,510
very good reason to do so they're very

00:10:24,529 --> 00:10:27,709
pragmatic like they can choose whatever

00:10:26,510 --> 00:10:30,079
they want and someone's going to come

00:10:27,709 --> 00:10:32,660
along and say are you surely you wanted

00:10:30,079 --> 00:10:35,510
to use say brain-fuck for this project

00:10:32,660 --> 00:10:41,180
like it's got a really good debugging

00:10:35,510 --> 00:10:43,100
environment say it's a huge codebase we

00:10:41,180 --> 00:10:45,620
have a single great big mono repo that

00:10:43,100 --> 00:10:47,420
well we have multiple mono repos we like

00:10:45,620 --> 00:10:50,360
them a lot but we are hoping to get it

00:10:47,420 --> 00:10:52,790
to be one mono repo eventually but it's

00:10:50,360 --> 00:10:56,480
got millions of files in it hundreds of

00:10:52,790 --> 00:10:58,730
millions of lines of code all just

00:10:56,480 --> 00:11:02,510
scattered across many many directories

00:10:58,730 --> 00:11:04,970
and we have a sort of general tooling

00:11:02,510 --> 00:11:06,319
goal like we have like it obviously that

00:11:04,970 --> 00:11:09,110
is just not going to work if you made a

00:11:06,319 --> 00:11:12,079
regular git repo of that size checked it

00:11:09,110 --> 00:11:14,120
out tried to Rumble around and use that

00:11:12,079 --> 00:11:16,850
it wouldn't work so we spend a lot of

00:11:14,120 --> 00:11:18,959
investment on tooling with a general

00:11:16,850 --> 00:11:22,480
goal that

00:11:18,959 --> 00:11:24,249
the amount of time you spend waiting for

00:11:22,480 --> 00:11:26,499
things to happen should be proportional

00:11:24,249 --> 00:11:28,480
to the size of your project not to the

00:11:26,499 --> 00:11:30,579
size of the entire repo and as the repo

00:11:28,480 --> 00:11:32,319
grows if your project stays the same

00:11:30,579 --> 00:11:37,509
size it should still take about the same

00:11:32,319 --> 00:11:38,920
time to get things done one of the

00:11:37,509 --> 00:11:42,160
important tools in there is bucked the

00:11:38,920 --> 00:11:44,199
build system which builds a dependency

00:11:42,160 --> 00:11:46,480
graph across the entire source base and

00:11:44,199 --> 00:11:48,730
so when you say build this specific

00:11:46,480 --> 00:11:50,379
target it knows how to build that target

00:11:48,730 --> 00:11:55,809
and all its dependencies no matter what

00:11:50,379 --> 00:11:57,489
language they're in so and then there's

00:11:55,809 --> 00:12:00,970
a whole bunch of production side stuff

00:11:57,489 --> 00:12:08,079
as well to monitor things and deploy

00:12:00,970 --> 00:12:10,119
them and so by contrast let's look at

00:12:08,079 --> 00:12:12,100
the the rest view of the world like as a

00:12:10,119 --> 00:12:18,309
way of getting to how does rust fit into

00:12:12,100 --> 00:12:21,519
all of this so I think an ambiguous lis

00:12:18,309 --> 00:12:23,169
the first rule of rust is safety if like

00:12:21,519 --> 00:12:26,649
safety is a foundation of everything

00:12:23,169 --> 00:12:29,319
else without safety nothing nothing else

00:12:26,649 --> 00:12:31,239
is really worth talking about but it's a

00:12:29,319 --> 00:12:33,519
new language so there's a lot of scope

00:12:31,239 --> 00:12:36,009
for experimentation greenfield

00:12:33,519 --> 00:12:37,569
development there's no reason why rust

00:12:36,009 --> 00:12:39,850
has to do things the same way that

00:12:37,569 --> 00:12:43,779
everything else does it's worth

00:12:39,850 --> 00:12:46,149
experimenting that's offset by having a

00:12:43,779 --> 00:12:48,809
core stability there's the stability

00:12:46,149 --> 00:12:51,549
guarantees of the language that allow

00:12:48,809 --> 00:12:54,910
continuous evolution while not breaking

00:12:51,549 --> 00:12:57,369
backwards compatibility but again I've

00:12:54,910 --> 00:12:59,499
set by crates i/o this incredibly

00:12:57,369 --> 00:13:00,549
vibrant environment with lots and lots

00:12:59,499 --> 00:13:03,009
of third-party things in which

00:13:00,549 --> 00:13:04,839
experiments can happen and things can be

00:13:03,009 --> 00:13:06,790
trying to and accepted and adopted

00:13:04,839 --> 00:13:11,799
widely or thrown away if they don't work

00:13:06,790 --> 00:13:15,579
out so then cargo managers build in

00:13:11,799 --> 00:13:17,199
dependency and it's one of the things

00:13:15,579 --> 00:13:19,839
that regular you know newcomers to Rush

00:13:17,199 --> 00:13:21,100
regularly say cargo is is one of the

00:13:19,839 --> 00:13:23,079
brilliant things about the Rast

00:13:21,100 --> 00:13:25,720
ecosystem I could add a new dependency

00:13:23,079 --> 00:13:28,980
really easily you know particularly for

00:13:25,720 --> 00:13:32,910
C++ programmers it's a revelation but

00:13:28,980 --> 00:13:36,130
for other environments it's pretty

00:13:32,910 --> 00:13:38,650
you know it's it's a lovely tool and so

00:13:36,130 --> 00:13:41,970
as a result cargo is kind of the center

00:13:38,650 --> 00:13:44,440
of the rust universe it's the thing that

00:13:41,970 --> 00:13:45,730
binds the rust ecosystem together in a

00:13:44,440 --> 00:13:47,830
particular it's the thing that gives you

00:13:45,730 --> 00:13:50,080
access to crates IO so in order to have

00:13:47,830 --> 00:13:55,060
access to this vibrant third party code

00:13:50,080 --> 00:13:57,250
culture you need cargo but cargo is very

00:13:55,060 --> 00:14:00,160
highly tuned towards rust it treats the

00:13:57,250 --> 00:14:02,890
entire universe as rust and everything

00:14:00,160 --> 00:14:06,310
else and if the everything else gets

00:14:02,890 --> 00:14:08,230
very short shrift and in fact you could

00:14:06,310 --> 00:14:11,460
say that supporting non rust is an on

00:14:08,230 --> 00:14:13,660
goal for cargo certainly no one would I

00:14:11,460 --> 00:14:17,050
think it would be hard to argue that you

00:14:13,660 --> 00:14:19,570
would reduce cargos capability as far as

00:14:17,050 --> 00:14:23,620
rust goes in order to support something

00:14:19,570 --> 00:14:25,630
non rust and so that means that in our

00:14:23,620 --> 00:14:28,240
Facebook environment with many languages

00:14:25,630 --> 00:14:31,000
and a large repo in which almost all of

00:14:28,240 --> 00:14:35,230
it is not rust cargo alone is not enough

00:14:31,000 --> 00:14:37,990
to support what we want to do so the big

00:14:35,230 --> 00:14:42,280
question is how do we retain rusts

00:14:37,990 --> 00:14:44,290
essential benefits while integrating it

00:14:42,280 --> 00:14:47,350
with this this larger existing ecosystem

00:14:44,290 --> 00:14:49,060
and also get the benefits of that that

00:14:47,350 --> 00:14:51,670
other ecosystem because you know it's

00:14:49,060 --> 00:14:55,570
been built that way for specific reasons

00:14:51,670 --> 00:15:01,330
to support some specific kinds of

00:14:55,570 --> 00:15:03,160
activities so going back to the rust 10x

00:15:01,330 --> 00:15:07,000
advantage what is the cost of a bug to

00:15:03,160 --> 00:15:10,890
Facebook well if you see a headline

00:15:07,000 --> 00:15:16,240
saying Facebook down for users in X

00:15:10,890 --> 00:15:18,340
internally what that turns into is you

00:15:16,240 --> 00:15:22,960
know specifically it's a lot of lost

00:15:18,340 --> 00:15:25,210
revenue so you know even you know an

00:15:22,960 --> 00:15:28,960
hour of downtime is an ungodly amount of

00:15:25,210 --> 00:15:33,760
money and so and at least some of those

00:15:28,960 --> 00:15:35,590
those bugs root cause to yeah we traced

00:15:33,760 --> 00:15:37,540
it through and then this program here

00:15:35,590 --> 00:15:41,020
did a use after free after this diff and

00:15:37,540 --> 00:15:42,940
like yeah this one little innocuous

00:15:41,020 --> 00:15:43,910
change turned out to to take out the

00:15:42,940 --> 00:15:46,460
entire

00:15:43,910 --> 00:15:52,160
the entire site for six hours or

00:15:46,460 --> 00:15:53,660
whatever so as a result it behooves

00:15:52,160 --> 00:15:55,970
Facebook to spend quite a lot of money

00:15:53,660 --> 00:15:57,080
on improving code quality and it does

00:15:55,970 --> 00:15:59,630
this in a number of different dimensions

00:15:57,080 --> 00:16:04,790
one is like code review and static

00:15:59,630 --> 00:16:06,140
analysis and test infrastructure and you

00:16:04,790 --> 00:16:09,520
know in a lot of ways what Facebook does

00:16:06,140 --> 00:16:12,700
in these areas is is world class like

00:16:09,520 --> 00:16:14,900
and you know we spend a lot of

00:16:12,700 --> 00:16:17,930
engineering hours on these kinds of

00:16:14,900 --> 00:16:19,670
activities and they're effective like we

00:16:17,930 --> 00:16:21,950
do see improvements when when we spend

00:16:19,670 --> 00:16:27,560
more effort on on these areas the rate

00:16:21,950 --> 00:16:29,120
of bugs goes down mostly but the trouble

00:16:27,560 --> 00:16:32,480
with all of these things is that they're

00:16:29,120 --> 00:16:34,340
kind of afterwards things so the typical

00:16:32,480 --> 00:16:35,870
pattern is you write some code you

00:16:34,340 --> 00:16:38,210
bitter eight it kind of does what you

00:16:35,870 --> 00:16:40,580
think it should do pass some local tests

00:16:38,210 --> 00:16:45,170
you get it reviewed you commit that to

00:16:40,580 --> 00:16:46,460
the repo goes into production done I'm

00:16:45,170 --> 00:16:49,250
gonna go off and think about the next

00:16:46,460 --> 00:16:52,430
thing and then I mean even code review

00:16:49,250 --> 00:16:54,560
like is a pretty like manual thing so

00:16:52,430 --> 00:16:56,000
you're kind of relying for C++ code base

00:16:54,560 --> 00:16:57,890
you're relying on someone to actually

00:16:56,000 --> 00:17:00,530
pay attention to every single allocation

00:16:57,890 --> 00:17:04,730
and look at all of the details for

00:17:00,530 --> 00:17:06,800
static analysis it can take 20 minutes

00:17:04,730 --> 00:17:10,670
30 minutes half an hour and it's half

00:17:06,800 --> 00:17:13,910
now an hour to to come back with the

00:17:10,670 --> 00:17:15,380
result and that may be too late

00:17:13,910 --> 00:17:18,170
yucky it may have gone out of your

00:17:15,380 --> 00:17:20,540
context out of your head and you haven't

00:17:18,170 --> 00:17:22,189
really you don't really see what the

00:17:20,540 --> 00:17:24,110
implication is and because that ik

00:17:22,189 --> 00:17:26,449
analysis is it can give you false

00:17:24,110 --> 00:17:27,949
positives it can be quite easy to delude

00:17:26,449 --> 00:17:29,360
yourself into thinking oh this is

00:17:27,949 --> 00:17:35,110
definitely a false positive it's clearly

00:17:29,360 --> 00:17:37,070
ok and so what Russ does is by having

00:17:35,110 --> 00:17:39,230
solving a learned class of these

00:17:37,070 --> 00:17:41,330
problems depicting them at compile time

00:17:39,230 --> 00:17:42,980
it's in your inner loop it's while

00:17:41,330 --> 00:17:45,860
you're busy working on the code

00:17:42,980 --> 00:17:47,870
everything's in your head when it pops

00:17:45,860 --> 00:17:49,310
up a life time error you go oh I see

00:17:47,870 --> 00:17:51,200
yeah that's obvious let's fix that up

00:17:49,310 --> 00:17:53,720
and so by the time the code commit is

00:17:51,200 --> 00:17:55,580
committed it's got at least some base

00:17:53,720 --> 00:18:00,770
level of correctness that you're not

00:17:55,580 --> 00:18:03,260
to worry about anymore and and the nice

00:18:00,770 --> 00:18:05,840
thing about rust is that the executables

00:18:03,260 --> 00:18:07,280
themselves operationally looked like C++

00:18:05,840 --> 00:18:09,920
executables they're standalone

00:18:07,280 --> 00:18:11,750
self-contained executables so you can

00:18:09,920 --> 00:18:14,030
take that and you can drop those into a

00:18:11,750 --> 00:18:16,750
production environment expecting C++ and

00:18:14,030 --> 00:18:18,980
it more or less works the same way but

00:18:16,750 --> 00:18:21,140
we haven't opened challenge here because

00:18:18,980 --> 00:18:23,870
the essence of this argument is rust

00:18:21,140 --> 00:18:25,790
souls bugs really early so the key

00:18:23,870 --> 00:18:28,010
question is how can you quantify the

00:18:25,790 --> 00:18:32,030
bugs that didn't happen how can you

00:18:28,010 --> 00:18:34,160
quantify you know this bug this might

00:18:32,030 --> 00:18:35,870
have had a bug this this particular

00:18:34,160 --> 00:18:37,100
compilation had a compilation area that

00:18:35,870 --> 00:18:39,650
had a crept through would have turned

00:18:37,100 --> 00:18:40,760
into a massive outage it's very hard to

00:18:39,650 --> 00:18:42,860
do that and we're still kind of I'm

00:18:40,760 --> 00:18:44,450
still working on like how to quantify

00:18:42,860 --> 00:18:49,180
these things because that would really

00:18:44,450 --> 00:18:49,180
help with coming up with an argument

00:18:49,750 --> 00:18:56,360
some of the secondary effects here are

00:18:52,070 --> 00:18:59,300
that code reviews a higher level I sort

00:18:56,360 --> 00:19:01,040
of alluded to this earlier but when you

00:18:59,300 --> 00:19:03,260
don't have to worry about fine-grained

00:19:01,040 --> 00:19:05,090
details of lifetimes and locking and

00:19:03,260 --> 00:19:06,170
that sort of stuff a reviewer can just

00:19:05,090 --> 00:19:08,060
look at the code and say well if it

00:19:06,170 --> 00:19:09,650
compiles all of that stuff is basically

00:19:08,060 --> 00:19:11,180
correct let's look at the high level

00:19:09,650 --> 00:19:13,100
design is this actually the right way to

00:19:11,180 --> 00:19:15,920
fit this code together is this actually

00:19:13,100 --> 00:19:17,990
you know the correct design and you know

00:19:15,920 --> 00:19:21,230
whatever scale you you want to look at

00:19:17,990 --> 00:19:22,880
but it means that the amount of reviewer

00:19:21,230 --> 00:19:24,380
attention is is is much more sort of

00:19:22,880 --> 00:19:28,490
intellectually engaging and you get

00:19:24,380 --> 00:19:29,570
higher quality reviews which you know

00:19:28,490 --> 00:19:32,570
helps a lot

00:19:29,570 --> 00:19:34,610
you know it's in essence why is this

00:19:32,570 --> 00:19:36,140
diff lock it is rather than how it works

00:19:34,610 --> 00:19:37,760
though obviously how it works is

00:19:36,140 --> 00:19:39,920
important but you don't have to worry

00:19:37,760 --> 00:19:42,860
about the correctness a spec to that and

00:19:39,920 --> 00:19:45,620
there's also a maintenance improvement

00:19:42,860 --> 00:19:46,880
one of the biggest risks is not the when

00:19:45,620 --> 00:19:49,040
the code is originally written because

00:19:46,880 --> 00:19:50,720
the person who wrote it is thinking

00:19:49,040 --> 00:19:51,890
deeply about that domain they have

00:19:50,720 --> 00:19:53,810
everything in their head they have all

00:19:51,890 --> 00:19:56,120
the context they can probably get that

00:19:53,810 --> 00:20:00,080
code right you know eventually first

00:19:56,120 --> 00:20:01,850
time you know even in C++ but it's when

00:20:00,080 --> 00:20:03,800
the same engineer comes back three

00:20:01,850 --> 00:20:05,570
months later six months later to just

00:20:03,800 --> 00:20:06,950
drop in one little bug fix and we saw

00:20:05,570 --> 00:20:07,980
this weird little thing let's just drop

00:20:06,950 --> 00:20:10,110
a fix in here

00:20:07,980 --> 00:20:11,880
and without having that complete context

00:20:10,110 --> 00:20:14,040
in the head they can say oh I'm going to

00:20:11,880 --> 00:20:15,510
put it in here not realizing that the

00:20:14,040 --> 00:20:18,270
thing that they're doing the test on for

00:20:15,510 --> 00:20:20,970
that little one one-liner fix was

00:20:18,270 --> 00:20:22,410
actually freed five lines before

00:20:20,970 --> 00:20:24,179
whereas in rust you can just sort of

00:20:22,410 --> 00:20:25,559
make those code changes and they are the

00:20:24,179 --> 00:20:27,690
compiler they don't and if they do

00:20:25,559 --> 00:20:29,040
compile you have a much higher assurance

00:20:27,690 --> 00:20:35,610
that at least the fix is not going to be

00:20:29,040 --> 00:20:37,919
desperately broken so who's actually

00:20:35,610 --> 00:20:39,210
using rest we've we've had quite a lot

00:20:37,919 --> 00:20:41,429
of people adopting rust within the

00:20:39,210 --> 00:20:44,010
company as a result of these initial

00:20:41,429 --> 00:20:46,799
successes who are they well surprisingly

00:20:44,010 --> 00:20:52,110
it's been the dynamic language users

00:20:46,799 --> 00:20:53,820
that by far the most active enthusiastic

00:20:52,110 --> 00:20:55,860
early adopters of rust where Python

00:20:53,820 --> 00:20:59,400
programmers they basically set

00:20:55,860 --> 00:21:00,929
themselves up a game of take my favorite

00:20:59,400 --> 00:21:03,660
plaything scripts and convert it to rest

00:21:00,929 --> 00:21:05,669
and the resulting rust looks like a

00:21:03,660 --> 00:21:09,270
Python script that's been converted into

00:21:05,669 --> 00:21:11,940
rust it's not at all idiomatic or Kruti

00:21:09,270 --> 00:21:14,549
or anything like that but it did compile

00:21:11,940 --> 00:21:16,140
and as a result it probably works

00:21:14,549 --> 00:21:18,809
because it looks exactly like the

00:21:16,140 --> 00:21:21,179
patient that also probably worked and so

00:21:18,809 --> 00:21:22,799
this was a really great educational

00:21:21,179 --> 00:21:24,570
opportunity for a large number of

00:21:22,799 --> 00:21:27,270
engineers or relatively large a large

00:21:24,570 --> 00:21:28,890
number India is to get familiarity with

00:21:27,270 --> 00:21:30,900
rust in you know they here burrow

00:21:28,890 --> 00:21:35,220
checker and scary lifetime stuff and

00:21:30,900 --> 00:21:36,690
that but really they got their Python

00:21:35,220 --> 00:21:38,910
script working it's not that scary

00:21:36,690 --> 00:21:40,350
anymore it's you know they probably had

00:21:38,910 --> 00:21:42,299
to fight with a compiler a bit to get it

00:21:40,350 --> 00:21:44,070
to compile but having got it to compile

00:21:42,299 --> 00:21:46,890
it works whereas if you do the same

00:21:44,070 --> 00:21:48,600
thing with the C++ C++ you get something

00:21:46,890 --> 00:21:49,919
either compiles really easily and then

00:21:48,600 --> 00:21:51,419
it crashes and then you look in the

00:21:49,919 --> 00:21:53,309
manual and you look at this you look at

00:21:51,419 --> 00:21:54,540
that and like nothing in Python prepares

00:21:53,309 --> 00:21:56,450
you for debugging a segmentation

00:21:54,540 --> 00:21:58,380
violation and nothing in the C++

00:21:56,450 --> 00:21:59,910
specification prepares you for it either

00:21:58,380 --> 00:22:02,730
you're suddenly in a completely

00:21:59,910 --> 00:22:04,410
different domain of expertise required

00:22:02,730 --> 00:22:08,210
to even get started on debugging that

00:22:04,410 --> 00:22:08,210
thing so you just kind of like walk away

00:22:11,889 --> 00:22:16,940
we have a lot of command line interface

00:22:14,659 --> 00:22:20,179
programs a lot of them are written in

00:22:16,940 --> 00:22:21,919
Python Python is quite nice language for

00:22:20,179 --> 00:22:25,669
writing those things but the result is

00:22:21,919 --> 00:22:28,729
very unusable due to lots of ways in

00:22:25,669 --> 00:22:30,619
which we kind of deploy Python it starts

00:22:28,729 --> 00:22:32,239
up very slowly so it's quite common to

00:22:30,619 --> 00:22:34,090
have a command-line interface that takes

00:22:32,239 --> 00:22:37,099
five seconds to show a usage message

00:22:34,090 --> 00:22:38,629
it's very unpleasant and obviously the

00:22:37,099 --> 00:22:40,399
Python side of things could be fixed but

00:22:38,629 --> 00:22:42,739
if you could just sit down and write a

00:22:40,399 --> 00:22:45,080
Russ program that has a nice CLA that

00:22:42,739 --> 00:22:48,289
does the thing you want and starts up in

00:22:45,080 --> 00:22:50,960
a millisecond then that's a huge huge

00:22:48,289 --> 00:22:54,619
advantage so given that you're rewriting

00:22:50,960 --> 00:22:56,769
Python code into rust anyway why not use

00:22:54,619 --> 00:23:00,200
it for these interactive programs and

00:22:56,769 --> 00:23:02,749
rust has a secret weapon here like Plath

00:23:00,200 --> 00:23:05,059
is a very capable library and the

00:23:02,749 --> 00:23:07,249
combination was struct up is just

00:23:05,059 --> 00:23:09,289
magical people really love it

00:23:07,249 --> 00:23:10,309
you can show them your definer structure

00:23:09,289 --> 00:23:12,200
if you're not familiar with struck

00:23:10,309 --> 00:23:13,729
ducked it's a procedural macro that you

00:23:12,200 --> 00:23:15,469
apply to a structure and that structure

00:23:13,729 --> 00:23:18,830
defines your command-line interface and

00:23:15,469 --> 00:23:20,690
so you can just show someone here is a

00:23:18,830 --> 00:23:22,879
structure this structure represents the

00:23:20,690 --> 00:23:24,259
command-line interface and the value of

00:23:22,879 --> 00:23:26,479
that structure is the command line you

00:23:24,259 --> 00:23:30,200
actually got you go that's incredibly

00:23:26,479 --> 00:23:31,909
simple it's way ahead of any technology

00:23:30,200 --> 00:23:33,619
that's well these commonly available

00:23:31,909 --> 00:23:37,129
technologies for other languages for

00:23:33,619 --> 00:23:39,409
doing that sort of thing and yeah even

00:23:37,129 --> 00:23:40,700
Python presumably could in principle

00:23:39,409 --> 00:23:44,839
have something similar but I don't know

00:23:40,700 --> 00:23:48,080
that that exists so we have all of these

00:23:44,839 --> 00:23:52,309
new russ users in the company how do we

00:23:48,080 --> 00:23:54,799
support them most almost all the teams

00:23:52,309 --> 00:23:56,719
that have adopted rest have not actually

00:23:54,799 --> 00:23:59,299
had any Russ programmers on the team at

00:23:56,719 --> 00:24:04,369
that time they've had people who are

00:23:59,299 --> 00:24:05,989
enthusiastic about rest but very few

00:24:04,369 --> 00:24:08,299
people who have actually used it in any

00:24:05,989 --> 00:24:12,549
kind of intensive way so as a result

00:24:08,299 --> 00:24:14,629
ramp up time has been a big concern and

00:24:12,549 --> 00:24:17,809
it turns out that there's a kind of

00:24:14,629 --> 00:24:19,669
universal experience which is that it

00:24:17,809 --> 00:24:22,849
takes about two to three weeks of

00:24:19,669 --> 00:24:25,040
fighting the compiler three to five

00:24:22,849 --> 00:24:28,910
weeks of working out how to get things

00:24:25,040 --> 00:24:30,470
and at about eight weeks there's people

00:24:28,910 --> 00:24:32,360
feel actually competent and sort of

00:24:30,470 --> 00:24:35,060
reasonably capable of getting the thing

00:24:32,360 --> 00:24:36,610
done that they want to get done

00:24:35,060 --> 00:24:38,480
[Music]

00:24:36,610 --> 00:24:40,190
that's quite dependent on the language

00:24:38,480 --> 00:24:41,570
background like people coming from

00:24:40,190 --> 00:24:43,160
functional language backgrounds have a

00:24:41,570 --> 00:24:45,560
much better time of it than people

00:24:43,160 --> 00:24:47,690
coming from go and Java go and java's

00:24:45,560 --> 00:24:50,270
sort of general model of like a great

00:24:47,690 --> 00:24:51,860
big tangled heap of references in a in a

00:24:50,270 --> 00:24:53,960
garbage collected heap where everything

00:24:51,860 --> 00:24:55,250
can mutate everything else is a terrible

00:24:53,960 --> 00:24:59,800
starting place for anything to do with

00:24:55,250 --> 00:25:02,210
rest the big danger point happens

00:24:59,800 --> 00:25:05,870
sometime later like say within a month

00:25:02,210 --> 00:25:08,300
or two in which someone says you know I

00:25:05,870 --> 00:25:10,280
really understand treats now I'm going

00:25:08,300 --> 00:25:12,140
to use them everywhere and then suddenly

00:25:10,280 --> 00:25:14,480
you end up with a code base that's full

00:25:12,140 --> 00:25:18,350
of type parameters and type constraints

00:25:14,480 --> 00:25:21,800
and 15 line wear blocks and it takes

00:25:18,350 --> 00:25:23,330
maybe in the best case a week to realize

00:25:21,800 --> 00:25:25,250
that that was a disastrous mistake this

00:25:23,330 --> 00:25:27,920
mistake but sometimes that can last for

00:25:25,250 --> 00:25:29,450
months and the relief of just sort of

00:25:27,920 --> 00:25:32,350
like collapsing all of that complexity

00:25:29,450 --> 00:25:32,350
out is palpable

00:25:32,720 --> 00:25:36,680
we haven't actually needed very much

00:25:34,820 --> 00:25:38,390
internal training materials so far but

00:25:36,680 --> 00:25:41,870
that's definitely changing now that the

00:25:38,390 --> 00:25:43,130
the user base is changing mostly the

00:25:41,870 --> 00:25:45,200
people who've been ducting arrests are

00:25:43,130 --> 00:25:46,310
intrinsically enthusiastic about rust so

00:25:45,200 --> 00:25:48,080
they've already found that found

00:25:46,310 --> 00:25:50,620
everything for themselves but we're

00:25:48,080 --> 00:25:52,870
moving into a class of people where

00:25:50,620 --> 00:25:54,890
where that's not the case

00:25:52,870 --> 00:25:57,350
so we're having to build a community

00:25:54,890 --> 00:26:01,190
within the company that is a reflection

00:25:57,350 --> 00:26:03,070
of rust external community it depends a

00:26:01,190 --> 00:26:07,040
lot on the external community being very

00:26:03,070 --> 00:26:08,810
vibrant and healthy and one of the

00:26:07,040 --> 00:26:10,580
foundational principles of rust as I

00:26:08,810 --> 00:26:13,010
said before a safety but I see that that

00:26:10,580 --> 00:26:15,530
extends into rusts community that the

00:26:13,010 --> 00:26:17,810
like psychological safety of being able

00:26:15,530 --> 00:26:19,610
to jump in and ask questions and not get

00:26:17,810 --> 00:26:21,770
shouted at is an extremely important

00:26:19,610 --> 00:26:24,260
property that I see the Russ community

00:26:21,770 --> 00:26:27,320
trying to maintain and so we have the

00:26:24,260 --> 00:26:30,980
same yeah I've been explicitly adopting

00:26:27,320 --> 00:26:33,140
the same policy internally as well we

00:26:30,980 --> 00:26:34,790
need to reboot bootstrap the review

00:26:33,140 --> 00:26:37,420
culture so that teams can review their

00:26:34,790 --> 00:26:37,420
own code and

00:26:38,290 --> 00:26:42,980
we have a rust reviewers kind of

00:26:41,390 --> 00:26:49,520
reviewer tag that you can stack and

00:26:42,980 --> 00:26:51,200
attach to it to appear and then that

00:26:49,520 --> 00:26:53,120
allows you to sort of register yourself

00:26:51,200 --> 00:26:54,770
as someone who's who's good at reviewing

00:26:53,120 --> 00:26:56,330
rusts code and you can help out a team

00:26:54,770 --> 00:26:58,400
review some of their code they also

00:26:56,330 --> 00:27:00,170
encourage people to join that if they're

00:26:58,400 --> 00:27:03,670
learning because watching other reviews

00:27:00,170 --> 00:27:06,530
is quite a useful learning experience

00:27:03,670 --> 00:27:09,500
one of the big things that you had to do

00:27:06,530 --> 00:27:12,140
is that I've been emphasizing is

00:27:09,500 --> 00:27:13,430
removing gratuitous weirdness so even if

00:27:12,140 --> 00:27:15,950
something is not entirely compatible

00:27:13,430 --> 00:27:18,800
with the way that you might do it and

00:27:15,950 --> 00:27:20,180
rust doing it in a way that's compatible

00:27:18,800 --> 00:27:22,130
with the way that we do it in in

00:27:20,180 --> 00:27:24,020
Facebook helps people come to the code

00:27:22,130 --> 00:27:26,660
base and understand it in a way that

00:27:24,020 --> 00:27:28,820
they might not otherwise so for example

00:27:26,660 --> 00:27:31,070
if you're doing a binding to a C++ API

00:27:28,820 --> 00:27:33,710
use the same names for the rest and the

00:27:31,070 --> 00:27:35,090
CH C++ sides so that like exactly the

00:27:33,710 --> 00:27:38,000
same name so that you can find them both

00:27:35,090 --> 00:27:43,250
with grep and that helps people who are

00:27:38,000 --> 00:27:47,960
sort of digging through code bases to to

00:27:43,250 --> 00:27:50,570
work out how the Rascon fits in so we're

00:27:47,960 --> 00:27:52,190
getting to a point now where rust is not

00:27:50,570 --> 00:27:54,260
just for the enthusiasts not just for

00:27:52,190 --> 00:27:57,530
the fans we need to reach out to the

00:27:54,260 --> 00:27:59,600
people who very pragmatic they have a

00:27:57,530 --> 00:28:01,460
job to get done they have many options

00:27:59,600 --> 00:28:04,880
rust as one of them and it's not obvious

00:28:01,460 --> 00:28:06,170
to them that rust is the best option and

00:28:04,880 --> 00:28:07,970
maybe it's not there could be completely

00:28:06,170 --> 00:28:10,220
correct like we have lots of very strong

00:28:07,970 --> 00:28:11,660
engineers who have very fine-grain

00:28:10,220 --> 00:28:16,760
understandings of all of the trade-offs

00:28:11,660 --> 00:28:19,430
involved but some of the onions you can

00:28:16,760 --> 00:28:22,100
make for rust is that undetected bugs a

00:28:19,430 --> 00:28:24,320
huge expense the intrinsic security

00:28:22,100 --> 00:28:26,870
aspect of it is very important for any

00:28:24,320 --> 00:28:30,110
use case where rust might be used on

00:28:26,870 --> 00:28:33,890
untrusted data and kind of tied to that

00:28:30,110 --> 00:28:35,600
is that like the learning curve is

00:28:33,890 --> 00:28:37,550
really steep which sounds like a bad

00:28:35,600 --> 00:28:41,290
thing but the thing about steep slopes

00:28:37,550 --> 00:28:44,540
is that you end up higher faster and so

00:28:41,290 --> 00:28:46,670
newcomers to rust once you've learned

00:28:44,540 --> 00:28:48,170
the basic language you could then set

00:28:46,670 --> 00:28:50,030
them to write security-critical code

00:28:48,170 --> 00:28:51,500
without really worrying about it too

00:28:50,030 --> 00:28:52,700
much you like you ordered it for unsay

00:28:51,500 --> 00:28:54,350
when you look for egregiously wrong

00:28:52,700 --> 00:28:55,970
things but you're then fairly confident

00:28:54,350 --> 00:28:58,550
that it can't do anything very broken

00:28:55,970 --> 00:29:00,110
whereas in C++ you wouldn't put someone

00:28:58,550 --> 00:29:02,980
who'd been using the language for three

00:29:00,110 --> 00:29:05,810
months on a security critical thing and

00:29:02,980 --> 00:29:09,410
you know there's trade-offs there but I

00:29:05,810 --> 00:29:11,420
think it's an important point and they

00:29:09,410 --> 00:29:15,980
think is really nice that's that's still

00:29:11,420 --> 00:29:17,720
a strong a strong point I think I mean

00:29:15,980 --> 00:29:20,150
interestingly every team that has

00:29:17,720 --> 00:29:21,740
considered using rust so far and this

00:29:20,150 --> 00:29:24,320
won't be true forever but I think it's

00:29:21,740 --> 00:29:27,260
true so far everyone who's considered

00:29:24,320 --> 00:29:29,630
rust has ended up using it and everyone

00:29:27,260 --> 00:29:32,330
who's adopted it so far has not

00:29:29,630 --> 00:29:35,630
regretted it so I see that as basically

00:29:32,330 --> 00:29:38,870
strong reinforcement for why other teams

00:29:35,630 --> 00:29:42,440
should adopt it so where are we now we

00:29:38,870 --> 00:29:44,360
are in a place where we have a very

00:29:42,440 --> 00:29:46,700
solid starting point there's an active

00:29:44,360 --> 00:29:48,800
community there's several critical like

00:29:46,700 --> 00:29:52,460
teams working on strategically critical

00:29:48,800 --> 00:29:54,050
software using rust many of the standard

00:29:52,460 --> 00:29:55,700
api's are available so it's fairly easy

00:29:54,050 --> 00:29:57,380
to sit down and write new code and just

00:29:55,700 --> 00:30:00,260
expect it to work within facebook's

00:29:57,380 --> 00:30:01,820
infrastructure but and the sort of

00:30:00,260 --> 00:30:04,730
general development experience feels

00:30:01,820 --> 00:30:07,120
good and generally people are

00:30:04,730 --> 00:30:09,500
enthusiastic there's a lot of enthusiasm

00:30:07,120 --> 00:30:11,600
but it's not the default language for

00:30:09,500 --> 00:30:14,360
any particular domain yet like I think

00:30:11,600 --> 00:30:17,690
that security software ought to be rust

00:30:14,360 --> 00:30:18,860
by default but it's not yet the non

00:30:17,690 --> 00:30:20,540
enthusiasts are beginning to pay

00:30:18,860 --> 00:30:24,680
attention but we need to make this case

00:30:20,540 --> 00:30:26,860
we need to be convincing about it we are

00:30:24,680 --> 00:30:29,060
making terrible use of rust doc and

00:30:26,860 --> 00:30:30,560
there's a bunch of other parts the rust

00:30:29,060 --> 00:30:33,680
ecosystem that we're not really making

00:30:30,560 --> 00:30:36,320
good use of that we need to spend more

00:30:33,680 --> 00:30:39,020
effort on and in general lots of Polish

00:30:36,320 --> 00:30:41,300
there is what what's there is high

00:30:39,020 --> 00:30:43,730
quality and generally quite useful but

00:30:41,300 --> 00:30:46,430
there's rough edges and there's missing

00:30:43,730 --> 00:30:49,040
functionality as we say in facebook this

00:30:46,430 --> 00:30:52,360
journey is 1% finished but if you want

00:30:49,040 --> 00:30:52,360
to come and help we're hiring

00:30:55,950 --> 00:31:10,509
[Applause]

00:30:57,200 --> 00:31:10,509

YouTube URL: https://www.youtube.com/watch?v=kylqq8pEgRs


