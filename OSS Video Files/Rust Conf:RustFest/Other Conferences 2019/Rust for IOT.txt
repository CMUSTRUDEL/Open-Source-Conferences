Title: Rust for IOT
Publication date: 2019-10-02
Playlist: Other Conferences 2019
Description: 
	E. Dunham

https://2019.linux.conf.au/schedule/presentation/119/

Is Rust ready for the embedded world yet? If your IOT project is on ARM or MSP430, it already has native support in the Rust compiler, and AVR and RISC-V have compiler forks available. 

But architecture support is only the first challenge: If you're used to writing Rust for hosts that run an operating system, the paradigm shift of having to do everything yourself in the embedded world can be jarring. 

This talk will introduce the basic techniques for writing Rust to run microcontrollers, and survey outstanding embedded rust projects already available in the ecosystem.

linux.conf.au is a conference about the Linux operating system, and all aspects of the thriving ecosystem of Free and Open Source Software that has grown up around it. Run since 1999, in a different Australian or New Zealand city each year, by a team of local volunteers, LCA invites more than 500 people to learn from the people who shape the future of Open Source. For more information on the conference see https://linux.conf.au/

#linux.conf.au #linux #foss #opensource
Captions: 
	00:00:03,589 --> 00:00:09,510
all right thank you everyone for coming

00:00:05,670 --> 00:00:13,920
it's introduced sorry introducing Emily

00:00:09,510 --> 00:00:17,730
to talk about rust thank you for having

00:00:13,920 --> 00:00:21,539
me so I hope that you're here today to

00:00:17,730 --> 00:00:23,640
talk about rust and IOT with me if not

00:00:21,539 --> 00:00:25,230
there are several other parallel talks

00:00:23,640 --> 00:00:26,849
that I would absolutely be in if I

00:00:25,230 --> 00:00:29,039
weren't speaking in this particular slot

00:00:26,849 --> 00:00:31,920
so I've personally contributed to the

00:00:29,039 --> 00:00:34,559
rest project in various ways for several

00:00:31,920 --> 00:00:36,030
years now and in past lives I've built

00:00:34,559 --> 00:00:38,969
all kinds of robotics and embedded

00:00:36,030 --> 00:00:42,210
projects now you won't have heard of me

00:00:38,969 --> 00:00:44,670
from the prominent embedded rust project

00:00:42,210 --> 00:00:46,800
or the fantastic embedded rest book

00:00:44,670 --> 00:00:49,170
because the experts who work on those

00:00:46,800 --> 00:00:52,469
things know better than to try to fit a

00:00:49,170 --> 00:00:56,399
summary into a 45-minute slot but that's

00:00:52,469 --> 00:00:59,129
what I'm going to try to do for you when

00:00:56,399 --> 00:01:01,320
I first proposed this talk to LCA there

00:00:59,129 --> 00:01:03,840
wasn't a central repository of all the

00:01:01,320 --> 00:01:06,810
scattered knowledge about doing rests on

00:01:03,840 --> 00:01:09,600
embedded systems and between that time

00:01:06,810 --> 00:01:12,450
and right now some amazing resources

00:01:09,600 --> 00:01:14,939
have been produced that I will refer to

00:01:12,450 --> 00:01:18,030
and refer to you to throughout the talk

00:01:14,939 --> 00:01:19,950
so that frees up a bit of time that

00:01:18,030 --> 00:01:22,049
might otherwise have been spent on facts

00:01:19,950 --> 00:01:25,770
and details for a bit of an impromptu

00:01:22,049 --> 00:01:27,119
birds of a feather session at the end so

00:01:25,770 --> 00:01:28,439
that you can take advantage of what

00:01:27,119 --> 00:01:30,930
really makes a conference like this

00:01:28,439 --> 00:01:33,420
special which is the other humans and

00:01:30,930 --> 00:01:35,610
experts in the room so what I'm going to

00:01:33,420 --> 00:01:37,320
do at the end I'll ask everyone who

00:01:35,610 --> 00:01:39,180
wants to connect with others about rest

00:01:37,320 --> 00:01:41,430
whether that's recruiting for a project

00:01:39,180 --> 00:01:44,189
of your own sharing a project that you

00:01:41,430 --> 00:01:46,140
think is cool or asking for a project to

00:01:44,189 --> 00:01:49,380
contribute to to give me a quick rundown

00:01:46,140 --> 00:01:51,720
on what that is and I will thank you

00:01:49,380 --> 00:01:53,579
with a little plush rust mascot for

00:01:51,720 --> 00:01:54,720
doing so you can then display that

00:01:53,579 --> 00:01:56,009
through the rest of the conference and

00:01:54,720 --> 00:02:00,329
people that will know to talk to you

00:01:56,009 --> 00:02:02,219
about rest so first things first most of

00:02:00,329 --> 00:02:04,560
you probably know a bit about the rest

00:02:02,219 --> 00:02:07,020
language it attacks the apparent

00:02:04,560 --> 00:02:09,899
dichotomies between human readable code

00:02:07,020 --> 00:02:11,310
versus fast performing code ergonomic to

00:02:09,899 --> 00:02:14,740
develop code

00:02:11,310 --> 00:02:16,750
verifiable certified bug-free code by

00:02:14,740 --> 00:02:18,850
sweeping a lot of problems under the rug

00:02:16,750 --> 00:02:21,160
of the compiler they then build a

00:02:18,850 --> 00:02:22,990
compiler and associated tool chain

00:02:21,160 --> 00:02:26,620
that's capable of solving all of those

00:02:22,990 --> 00:02:28,720
problems to write code free of certain

00:02:26,620 --> 00:02:31,330
classes of bug in any language you need

00:02:28,720 --> 00:02:34,180
to follow a bunch of rules and what sets

00:02:31,330 --> 00:02:36,370
rest apart is that these rules live

00:02:34,180 --> 00:02:38,440
explicitly in the language spec and in

00:02:36,370 --> 00:02:41,080
the compiler and they're enforced at

00:02:38,440 --> 00:02:42,340
compile time rather than at the time

00:02:41,080 --> 00:02:45,220
when you're thinking and reasoning and

00:02:42,340 --> 00:02:50,080
designing the code or at runtime like

00:02:45,220 --> 00:02:52,720
interpreted languages often are so what

00:02:50,080 --> 00:02:55,420
we call safe rust is the set of all

00:02:52,720 --> 00:02:58,540
programs that you know are within this

00:02:55,420 --> 00:03:02,110
weird fractal barely defined space of

00:02:58,540 --> 00:03:03,580
correct programs and that means that

00:03:02,110 --> 00:03:05,470
there's going to be some correct

00:03:03,580 --> 00:03:09,130
programs that you can't necessarily

00:03:05,470 --> 00:03:12,130
prove are free from bugs especially when

00:03:09,130 --> 00:03:14,590
it comes to Io any interaction with the

00:03:12,130 --> 00:03:16,840
outside world and so for those cases

00:03:14,590 --> 00:03:19,150
when you need to write programs that are

00:03:16,840 --> 00:03:21,040
outside of what you know it's safe but

00:03:19,150 --> 00:03:23,680
you as a programmer think they're inside

00:03:21,040 --> 00:03:26,350
of what's correct you use what's called

00:03:23,680 --> 00:03:28,510
unsafe rust which does permit you to

00:03:26,350 --> 00:03:33,430
write some programs outside of that

00:03:28,510 --> 00:03:35,650
space of correct things also and the

00:03:33,430 --> 00:03:38,620
language is under rapid and active

00:03:35,650 --> 00:03:40,630
development to expand what's safe to

00:03:38,620 --> 00:03:42,670
push the boundaries of safe so they get

00:03:40,630 --> 00:03:45,880
as close as possible to the boundaries

00:03:42,670 --> 00:03:49,090
of what the correct programs free of

00:03:45,880 --> 00:03:51,850
memory misuse are and so if you've come

00:03:49,090 --> 00:03:54,940
to my LCA talks in the past I've talked

00:03:51,850 --> 00:03:57,070
about how the new bleeding edge features

00:03:54,940 --> 00:03:59,380
that we're not sure whether they're

00:03:57,070 --> 00:04:01,000
really going to land come out daily in

00:03:59,380 --> 00:04:03,310
what's called the nightly rest Channel

00:04:01,000 --> 00:04:05,080
some of them graduate to a beta channel

00:04:03,310 --> 00:04:07,570
and then a stable channel with the

00:04:05,080 --> 00:04:10,140
tested features is released every six

00:04:07,570 --> 00:04:13,420
weeks that's always backwards compatible

00:04:10,140 --> 00:04:15,519
one thing that's new since last year and

00:04:13,420 --> 00:04:17,850
since last we talked here about rust is

00:04:15,519 --> 00:04:21,310
that they've also added the concept of

00:04:17,850 --> 00:04:24,540
additions and additions are an opt-in

00:04:21,310 --> 00:04:26,770
feature basically that allow

00:04:24,540 --> 00:04:29,380
wonderful new syntax wonderful

00:04:26,770 --> 00:04:31,449
ergonomics increased safety that might

00:04:29,380 --> 00:04:32,560
not be backwards compatible to the

00:04:31,449 --> 00:04:35,740
beginning of time

00:04:32,560 --> 00:04:37,539
so if you want some backwards compatible

00:04:35,740 --> 00:04:39,190
feature you don't have to opt in to the

00:04:37,539 --> 00:04:42,310
addition but if you want the new or

00:04:39,190 --> 00:04:45,210
cooler syntax like saying use the crate

00:04:42,310 --> 00:04:48,850
instead of external crates whatever then

00:04:45,210 --> 00:04:54,910
you can opt into an addition with those

00:04:48,850 --> 00:04:57,039
features so to talk about rust on IOT we

00:04:54,910 --> 00:04:58,750
need to pick a definition for what this

00:04:57,039 --> 00:05:02,260
buzzword even means

00:04:58,750 --> 00:05:05,110
so IOT is a bunch of physical devices

00:05:02,260 --> 00:05:07,389
with some kind of computer in them and

00:05:05,110 --> 00:05:08,949
those devices interface with the

00:05:07,389 --> 00:05:10,930
physical world through their inputs and

00:05:08,949 --> 00:05:13,120
outputs and they interface with each

00:05:10,930 --> 00:05:15,520
other and often a server over the

00:05:13,120 --> 00:05:19,960
network often a public network what

00:05:15,520 --> 00:05:22,990
could go wrong in practice this often

00:05:19,960 --> 00:05:25,930
means a design pattern where you have a

00:05:22,990 --> 00:05:28,449
bunch of individual little pieces of low

00:05:25,930 --> 00:05:30,610
power low capability Hardware heavy on

00:05:28,449 --> 00:05:33,130
the i/o that talk back to some

00:05:30,610 --> 00:05:35,320
centralized server or database which

00:05:33,130 --> 00:05:37,539
then does some heavier computation on

00:05:35,320 --> 00:05:39,550
what has learned from them and possibly

00:05:37,539 --> 00:05:41,800
sends instructions back out to them as

00:05:39,550 --> 00:05:45,099
to what outputs they should give into

00:05:41,800 --> 00:05:48,159
the world so we need software on both

00:05:45,099 --> 00:05:50,620
sides for a real IOT system both that

00:05:48,159 --> 00:05:53,500
server side and the embedded devices

00:05:50,620 --> 00:05:55,539
side of course is also the case of just

00:05:53,500 --> 00:05:58,210
a mesh of little devices talking to each

00:05:55,539 --> 00:06:00,159
other over a network and never actually

00:05:58,210 --> 00:06:03,639
talking that close server but that's

00:06:00,159 --> 00:06:05,289
less common than the server case when

00:06:03,639 --> 00:06:06,789
you need it to interact with humans or

00:06:05,289 --> 00:06:09,699
interact with an app that a human is

00:06:06,789 --> 00:06:12,130
going to be working with so both sides

00:06:09,699 --> 00:06:14,289
of this equation the embedded low-level

00:06:12,130 --> 00:06:19,030
stuff and the high-level server stuff

00:06:14,289 --> 00:06:21,849
can be written in rust so most

00:06:19,030 --> 00:06:24,190
programmers find working directly on the

00:06:21,849 --> 00:06:26,500
hardware to be much less familiar and

00:06:24,190 --> 00:06:29,320
more challenging than writing code that

00:06:26,500 --> 00:06:31,960
runs basically as a server that central

00:06:29,320 --> 00:06:34,479
server or database in most IOT design

00:06:31,960 --> 00:06:36,639
patterns is actually super familiar if

00:06:34,479 --> 00:06:39,069
you've done web development at

00:06:36,639 --> 00:06:42,009
ocation development atop an operating

00:06:39,069 --> 00:06:43,389
system and that makes them a great place

00:06:42,009 --> 00:06:45,279
to start if you're learning a new

00:06:43,389 --> 00:06:48,060
programming language for the first time

00:06:45,279 --> 00:06:51,249
there's often more mentors and resources

00:06:48,060 --> 00:06:54,219
for running a program atop an operating

00:06:51,249 --> 00:06:55,840
system then and it's easier to reproduce

00:06:54,219 --> 00:06:57,249
for someone else to reproduce the error

00:06:55,840 --> 00:07:00,699
you're getting then if you're going

00:06:57,249 --> 00:07:02,439
directly on hardware plus writing atop

00:07:00,699 --> 00:07:04,240
the operating system lets you avoid

00:07:02,439 --> 00:07:07,060
thinking about a lot of hardware

00:07:04,240 --> 00:07:09,069
problems that the operating system just

00:07:07,060 --> 00:07:15,159
solves for you before you even notice

00:07:09,069 --> 00:07:17,050
them so if you choose to start an IOT

00:07:15,159 --> 00:07:19,090
project where you have a bunch of little

00:07:17,050 --> 00:07:21,129
devices talking back to some server that

00:07:19,090 --> 00:07:23,409
does something clever over the internet

00:07:21,129 --> 00:07:26,050
you can choose to use a specification

00:07:23,409 --> 00:07:28,930
such as the web thing standard which you

00:07:26,050 --> 00:07:31,300
can learn about at the IOT mozilla.org

00:07:28,930 --> 00:07:33,759
link and you can build on the work that

00:07:31,300 --> 00:07:36,490
others have done to get the physical

00:07:33,759 --> 00:07:38,349
hardware talking speaking that standard

00:07:36,490 --> 00:07:41,500
and talking to that API that you expose

00:07:38,349 --> 00:07:44,800
so you can get a working IOT project

00:07:41,500 --> 00:07:47,229
doing minimal if any development on the

00:07:44,800 --> 00:07:49,629
hardware to start with so the Mozilla

00:07:47,229 --> 00:07:52,089
things project has a rest example where

00:07:49,629 --> 00:07:54,430
you can write the server in rust there

00:07:52,089 --> 00:07:57,279
example shows how to use the web think

00:07:54,430 --> 00:07:59,139
rate to talk to a dimmable light bulb

00:07:57,279 --> 00:08:02,139
and a humidity sensor that expose the

00:07:59,139 --> 00:08:04,990
web thing API and you can talk to

00:08:02,139 --> 00:08:06,789
anything talk to that API which you can

00:08:04,990 --> 00:08:09,639
find in the wiki list of supported

00:08:06,789 --> 00:08:12,189
hardware there so if you're interested

00:08:09,639 --> 00:08:13,930
in learning more about building IOT

00:08:12,189 --> 00:08:17,680
through this Web thing spec I'd

00:08:13,930 --> 00:08:20,830
recommend Kathy Jory's talk tomorrow in

00:08:17,680 --> 00:08:22,899
room a3 from 350 to 530 it's a workshop

00:08:20,830 --> 00:08:24,279
on starting out with it she won't be

00:08:22,899 --> 00:08:28,060
using rust but she will be using the

00:08:24,279 --> 00:08:30,219
framework so I point this out because

00:08:28,060 --> 00:08:32,529
when you run a program within an

00:08:30,219 --> 00:08:34,839
operating system the standard library

00:08:32,529 --> 00:08:37,449
makes all of these useful guesses about

00:08:34,839 --> 00:08:40,839
what you want for topics like

00:08:37,449 --> 00:08:43,209
multi-threading and i/o and various

00:08:40,839 --> 00:08:45,760
primitives so it's better to avoid

00:08:43,209 --> 00:08:47,350
reimplemented these features if you can

00:08:45,760 --> 00:08:49,300
get away with it because that standard

00:08:47,350 --> 00:08:50,110
library has been well tested for years

00:08:49,300 --> 00:08:53,470
and years on a ver

00:08:50,110 --> 00:08:54,490
of platforms as a rule of thumb if a

00:08:53,470 --> 00:08:57,010
piece of hardware that you're

00:08:54,490 --> 00:08:59,530
considering is used to run a Linux

00:08:57,010 --> 00:09:01,510
derivative you can probably write rest

00:08:59,530 --> 00:09:04,150
with the standard library for targeted a

00:09:01,510 --> 00:09:06,130
great example of this and probably in

00:09:04,150 --> 00:09:08,260
the room here right now is wesley

00:09:06,130 --> 00:09:10,360
moore's ePaper badge for this conference

00:09:08,260 --> 00:09:12,220
whose code is written in rust with the

00:09:10,360 --> 00:09:15,070
source at that github link right there

00:09:12,220 --> 00:09:16,960
so he runs a Linux derivative on a

00:09:15,070 --> 00:09:18,940
Raspberry Pi which means a regular old

00:09:16,960 --> 00:09:20,590
rest program can interface with the

00:09:18,940 --> 00:09:23,560
peripherals like the ePaper screen

00:09:20,590 --> 00:09:24,520
through that operating system Leslie

00:09:23,560 --> 00:09:26,080
could I ask you to raise your hand if

00:09:24,520 --> 00:09:30,370
you're here so there he is if you want

00:09:26,080 --> 00:09:33,070
to talk to him later on so what about

00:09:30,370 --> 00:09:34,930
the embedded case what about the tiny

00:09:33,070 --> 00:09:38,290
little chips the ones with the power

00:09:34,930 --> 00:09:40,210
size or price constraints that rule out

00:09:38,290 --> 00:09:42,730
the possibility of running an operating

00:09:40,210 --> 00:09:44,800
system to run your program on writing

00:09:42,730 --> 00:09:47,530
software for these like writing the

00:09:44,800 --> 00:09:49,990
operating systems themselves is called

00:09:47,530 --> 00:09:51,610
embedded programming when you don't have

00:09:49,990 --> 00:09:53,770
an operating system exposing those

00:09:51,610 --> 00:09:56,500
multi-threading those i/o primitives to

00:09:53,770 --> 00:09:58,210
your standard library you obviously

00:09:56,500 --> 00:09:59,980
can't use a standard library and instead

00:09:58,210 --> 00:10:02,020
you have to be much more explicit about

00:09:59,980 --> 00:10:04,480
how you want your program to perform

00:10:02,020 --> 00:10:07,540
those tasks so micromanaging how the

00:10:04,480 --> 00:10:10,840
hardware is used means that the output

00:10:07,540 --> 00:10:12,790
code is less portable across different

00:10:10,840 --> 00:10:15,240
platforms and more difficult to compile

00:10:12,790 --> 00:10:18,610
across platforms

00:10:15,240 --> 00:10:20,680
fortunately rust provides support out of

00:10:18,610 --> 00:10:25,270
the box for quite a few different

00:10:20,680 --> 00:10:27,700
architectures so rust categorizes its

00:10:25,270 --> 00:10:31,270
support for different families of chips

00:10:27,700 --> 00:10:34,780
in what it calls tears so the tier one

00:10:31,270 --> 00:10:38,230
is guaranteed to work so every change to

00:10:34,780 --> 00:10:40,570
rust runs tests they build the code they

00:10:38,230 --> 00:10:43,240
test the code on that architecture and

00:10:40,570 --> 00:10:46,330
if it fails then they go back and fix it

00:10:43,240 --> 00:10:48,310
before pushing that change tier to is

00:10:46,330 --> 00:10:50,560
guaranteed to build they'll build the

00:10:48,310 --> 00:10:51,700
code for that architecture and if it

00:10:50,560 --> 00:10:53,140
builds good enough they don't

00:10:51,700 --> 00:10:55,840
necessarily have the hardware available

00:10:53,140 --> 00:10:58,600
to test the code on that architecture

00:10:55,840 --> 00:11:01,010
and tier 3 is basically this might work

00:10:58,600 --> 00:11:02,930
but we don't really make any promises

00:11:01,010 --> 00:11:04,970
because there's not the resources

00:11:02,930 --> 00:11:06,350
available to do that

00:11:04,970 --> 00:11:08,570
continuous building for it and

00:11:06,350 --> 00:11:11,240
continuous testing on it that tiers 1 &

00:11:08,570 --> 00:11:13,670
2 may have so those different levels of

00:11:11,240 --> 00:11:15,410
testing basically correlate to whether

00:11:13,670 --> 00:11:17,570
you're likely to be the first one to

00:11:15,410 --> 00:11:20,990
find some bug that a test might have

00:11:17,570 --> 00:11:23,209
caught if you want a full list of all of

00:11:20,990 --> 00:11:25,250
the supported architectures and

00:11:23,209 --> 00:11:27,470
platforms you can check out the rest

00:11:25,250 --> 00:11:29,449
Forge they have a wonderful list with

00:11:27,470 --> 00:11:33,380
the cargo support and all of the details

00:11:29,449 --> 00:11:35,660
on there so what happens if you want the

00:11:33,380 --> 00:11:39,290
target a platform that isn't supported

00:11:35,660 --> 00:11:41,899
yet you can add support but the

00:11:39,290 --> 00:11:44,240
difficulty of doing that will vary based

00:11:41,899 --> 00:11:46,610
on whether the tools that rust uses are

00:11:44,240 --> 00:11:49,279
already ported to that platform or not

00:11:46,610 --> 00:11:52,519
so to understand the different processes

00:11:49,279 --> 00:11:54,290
you can use to address support to some

00:11:52,519 --> 00:11:58,279
other architecture that doesn't have it

00:11:54,290 --> 00:12:00,019
yet let's quickly recap what a rust

00:11:58,279 --> 00:12:04,760
program goes through as it's being

00:12:00,019 --> 00:12:07,880
compiled so when you compile rust code

00:12:04,760 --> 00:12:10,250
it goes through a series of steps first

00:12:07,880 --> 00:12:12,440
the compiler makes what's called Mir

00:12:10,250 --> 00:12:15,740
which is an intermediate representation

00:12:12,440 --> 00:12:18,319
of that code within rust that mirror is

00:12:15,740 --> 00:12:20,870
what your IDE can use to expose any

00:12:18,319 --> 00:12:23,810
errors in your code as you're writing it

00:12:20,870 --> 00:12:26,300
and relatedly if you're not using it

00:12:23,810 --> 00:12:27,800
rust integration with your IDE yet I

00:12:26,300 --> 00:12:31,430
would strongly recommend checking out

00:12:27,800 --> 00:12:33,199
our we IDE yet comm which will tell you

00:12:31,430 --> 00:12:38,300
exactly what the status is and where to

00:12:33,199 --> 00:12:41,480
get that integration so after Mir they

00:12:38,300 --> 00:12:44,120
make LLVM which is the low-level Virtual

00:12:41,480 --> 00:12:49,149
Machines intermediate representation so

00:12:44,120 --> 00:12:53,930
the LLVM ir and that goes to a big old

00:12:49,149 --> 00:12:57,290
utility the LLVM that does optimization

00:12:53,930 --> 00:13:00,800
on it to optimize away any code that's

00:12:57,290 --> 00:13:05,420
irrelevant to the final outcome of your

00:13:00,800 --> 00:13:08,750
programs behavior and the LLVM converts

00:13:05,420 --> 00:13:10,760
the ir into a runnable program so if you

00:13:08,750 --> 00:13:13,189
want to see what your code looks like at

00:13:10,760 --> 00:13:14,389
each of these steps which is really

00:13:13,189 --> 00:13:16,879
interesting to see

00:13:14,389 --> 00:13:20,480
where did those abstractions go away

00:13:16,879 --> 00:13:23,449
when did they go away you can either use

00:13:20,480 --> 00:13:26,660
the emit flag to rest sea to tell it

00:13:23,449 --> 00:13:29,269
emit Azzam emit LLVM IR emit Mir

00:13:26,660 --> 00:13:32,029
emit LLVM byte code whatever it is that

00:13:29,269 --> 00:13:33,559
you want to see or if you're not

00:13:32,029 --> 00:13:35,360
depending on a lot of other crates and

00:13:33,559 --> 00:13:38,209
you're just curious you can hop into the

00:13:35,360 --> 00:13:40,100
rest play pin at play trust Lang org and

00:13:38,209 --> 00:13:42,379
under the little run button up in the

00:13:40,100 --> 00:13:44,899
corner you can ask it to show assembly

00:13:42,379 --> 00:13:49,489
or show IR for that particular program

00:13:44,899 --> 00:13:51,649
that you've pasted it in so to figure

00:13:49,489 --> 00:13:53,749
out whether you're embedded device is

00:13:51,649 --> 00:13:56,389
supported or can be supported by rest

00:13:53,749 --> 00:13:58,429
you first check whether its architecture

00:13:56,389 --> 00:14:00,319
appears as a target in that platform

00:13:58,429 --> 00:14:02,600
support list that I linked earlier if

00:14:00,319 --> 00:14:04,850
it's not there have a search around the

00:14:02,600 --> 00:14:06,799
web to see whether LLVM can target it

00:14:04,850 --> 00:14:09,170
yet if you find that you're working on a

00:14:06,799 --> 00:14:11,239
platform that has LLVM support but

00:14:09,170 --> 00:14:12,920
doesn't have rest support yet contact

00:14:11,239 --> 00:14:17,269
the rest embedded working group for

00:14:12,920 --> 00:14:20,179
guidance on how to add it to rest if you

00:14:17,269 --> 00:14:21,529
don't want to use LLVM let's say you're

00:14:20,179 --> 00:14:24,649
not on an architecture that it does

00:14:21,529 --> 00:14:27,199
support but you want to omit rest code

00:14:24,649 --> 00:14:29,629
for it you can also try a project called

00:14:27,199 --> 00:14:31,850
crane lift cream lift used to be known

00:14:29,629 --> 00:14:34,189
as Croton so you've probably heard of it

00:14:31,850 --> 00:14:36,290
even if it sounds a bit new right now so

00:14:34,189 --> 00:14:38,569
it's an alternative code generator and

00:14:36,290 --> 00:14:40,970
it takes in a slightly lower level

00:14:38,569 --> 00:14:43,819
intermediate representation than LLVM

00:14:40,970 --> 00:14:47,029
uses and you can use it from rust see

00:14:43,819 --> 00:14:51,799
just the way you'd use LLVM and it's

00:14:47,029 --> 00:14:54,350
primarily targeting larger regular like

00:14:51,799 --> 00:14:56,689
x86 kind of things but it's written in

00:14:54,350 --> 00:14:59,169
rust so if you want to write rust to add

00:14:56,689 --> 00:15:01,970
support it's a good place to look and

00:14:59,169 --> 00:15:04,129
regardless of which code generator you

00:15:01,970 --> 00:15:06,439
prefer if you want to add a new target

00:15:04,129 --> 00:15:08,360
to rest you do have to add it to some

00:15:06,439 --> 00:15:10,279
code generator and that's a bunch of

00:15:08,360 --> 00:15:13,459
work there's one other workaround that

00:15:10,279 --> 00:15:15,319
you can consider so if you don't have if

00:15:13,459 --> 00:15:18,079
you do have a platform that you can

00:15:15,319 --> 00:15:20,119
write C for but you can't generate rest

00:15:18,079 --> 00:15:22,639
code for that platform through either of

00:15:20,119 --> 00:15:25,429
the code generators you can try turning

00:15:22,639 --> 00:15:27,649
your rust into C and then compiling that

00:15:25,429 --> 00:15:31,339
C through whatever methods you

00:15:27,649 --> 00:15:34,610
anyways I Tenma Sanchez did this to get

00:15:31,339 --> 00:15:37,730
rest running on the esp8266 by compiling

00:15:34,610 --> 00:15:40,670
rust in to see with the M rest C

00:15:37,730 --> 00:15:42,649
compiler and then putting that C through

00:15:40,670 --> 00:15:44,449
the usual tool train to target that

00:15:42,649 --> 00:15:46,430
board you can see his project and

00:15:44,449 --> 00:15:48,589
scripts at that github link that I've

00:15:46,430 --> 00:15:51,949
got on the screen the drawback of using

00:15:48,589 --> 00:15:54,170
M rust see is that on its own it doesn't

00:15:51,949 --> 00:15:57,800
do the same Baro checking and validation

00:15:54,170 --> 00:15:59,629
that regular rust C does so it just

00:15:57,800 --> 00:16:02,449
hopes that you passed it valid rust to

00:15:59,629 --> 00:16:03,740
start with you can make sure that you've

00:16:02,449 --> 00:16:06,529
got valid rest by running it through

00:16:03,740 --> 00:16:08,629
rust C first but if you don't if you

00:16:06,529 --> 00:16:14,240
skip that step you can introduce all

00:16:08,629 --> 00:16:16,399
kinds of errors so finally you might

00:16:14,240 --> 00:16:19,370
find yourself in a situation where you

00:16:16,399 --> 00:16:21,170
want to use some C code alongside some

00:16:19,370 --> 00:16:23,240
rust code or a little bit of rust code

00:16:21,170 --> 00:16:26,059
alongside some C code in an embedded

00:16:23,240 --> 00:16:28,160
context and if that's the case the

00:16:26,059 --> 00:16:30,470
embedded rust book goes into great

00:16:28,160 --> 00:16:34,220
detail on how to impure operate between

00:16:30,470 --> 00:16:36,439
embedded rust and embedded C if you want

00:16:34,220 --> 00:16:38,059
to take advantage of existing C code in

00:16:36,439 --> 00:16:41,149
this kind of way

00:16:38,059 --> 00:16:43,430
check out the embedded rest book at that

00:16:41,149 --> 00:16:45,949
link additionally if you're integrating

00:16:43,430 --> 00:16:49,120
between C and rust you'll probably find

00:16:45,949 --> 00:16:51,709
yourself spending a lot of time writing

00:16:49,120 --> 00:16:54,110
foreign function interface bindings

00:16:51,709 --> 00:16:56,899
between the two some of that binding

00:16:54,110 --> 00:16:58,910
writing challenge can be automated using

00:16:56,899 --> 00:17:03,139
the crate called bind gen but you can

00:16:58,910 --> 00:17:04,909
find on crates at i/o so if you're

00:17:03,139 --> 00:17:07,250
working without the standard library

00:17:04,909 --> 00:17:09,679
where do the primitive types and the

00:17:07,250 --> 00:17:11,780
methods come from so even when you opt

00:17:09,679 --> 00:17:13,339
out of the standard library most rust

00:17:11,780 --> 00:17:15,799
programs will have the cork rake

00:17:13,339 --> 00:17:17,419
available it doesn't help you with IO

00:17:15,799 --> 00:17:19,280
and multi-threading in the same way that

00:17:17,419 --> 00:17:20,990
the standard library does but it still

00:17:19,280 --> 00:17:22,370
exposes a bunch of the primitives and

00:17:20,990 --> 00:17:24,799
the macros that you're used to having

00:17:22,370 --> 00:17:26,480
you can find all of the core crate docks

00:17:24,799 --> 00:17:29,720
and compare them to a standard library

00:17:26,480 --> 00:17:32,059
docks there on the rest side so if

00:17:29,720 --> 00:17:34,130
you're on a chip that's more powerful

00:17:32,059 --> 00:17:36,140
and you think it could run something

00:17:34,130 --> 00:17:38,450
kind of like the standard library but

00:17:36,140 --> 00:17:40,370
that won't work for some reason you may

00:17:38,450 --> 00:17:41,059
find yourself wanting to make a custom

00:17:40,370 --> 00:17:42,799
standard

00:17:41,059 --> 00:17:44,809
Prairie and this is a workflow that's

00:17:42,799 --> 00:17:47,809
also supported the tool you want in that

00:17:44,809 --> 00:17:49,580
case is called zargo it's like cargo but

00:17:47,809 --> 00:17:51,799
with an X instead of a say for cross

00:17:49,580 --> 00:17:55,610
compiling if you're watching this talk

00:17:51,799 --> 00:17:57,830
on the recording after 2019 Durga's

00:17:55,610 --> 00:17:59,960
sister root building features may very

00:17:57,830 --> 00:18:02,779
well have finished integrating into

00:17:59,960 --> 00:18:05,360
cargo so check its wiki and if it says

00:18:02,779 --> 00:18:10,190
yay will ended in cargo now just use the

00:18:05,360 --> 00:18:11,929
cargo features instead so after all that

00:18:10,190 --> 00:18:14,240
let's hope that you've found a device

00:18:11,929 --> 00:18:16,940
with a story for targeting it with rust

00:18:14,240 --> 00:18:19,220
maybe that story's LLVM maybe that story

00:18:16,940 --> 00:18:22,190
is used crane left maybe that story is

00:18:19,220 --> 00:18:24,649
work through with see tool chain so next

00:18:22,190 --> 00:18:28,009
check out the awesome embedded rust repo

00:18:24,649 --> 00:18:30,740
link there which is another new thing

00:18:28,009 --> 00:18:33,320
since I initially proposed this talk to

00:18:30,740 --> 00:18:37,340
find what support crates and example

00:18:33,320 --> 00:18:39,950
code are available for your platform so

00:18:37,340 --> 00:18:41,570
many popular embedded platforms have

00:18:39,950 --> 00:18:43,639
several support crates that are already

00:18:41,570 --> 00:18:46,490
written for them remember to check the

00:18:43,639 --> 00:18:49,009
rest versions that they use and have a

00:18:46,490 --> 00:18:51,409
look at the activity the recent activity

00:18:49,009 --> 00:18:53,629
for the repository of the project when

00:18:51,409 --> 00:18:55,399
evaluating whether it's still active or

00:18:53,629 --> 00:18:57,379
whether this was someone's weekend

00:18:55,399 --> 00:18:59,299
project several years ago and may

00:18:57,379 --> 00:19:01,309
require a bit more effort than you

00:18:59,299 --> 00:19:03,289
thought to get it up to date so if

00:19:01,309 --> 00:19:05,210
you've only been doing regular rests

00:19:03,289 --> 00:19:07,580
atop an operating system so far

00:19:05,210 --> 00:19:09,740
you'll be almost overwhelmed by all of

00:19:07,580 --> 00:19:11,899
the new words and concepts that pop up

00:19:09,740 --> 00:19:13,999
when you jump into embedded development

00:19:11,899 --> 00:19:15,440
and many of these concepts are just

00:19:13,999 --> 00:19:18,200
common to all embedded development

00:19:15,440 --> 00:19:20,450
everywhere but these kind of seems scary

00:19:18,200 --> 00:19:22,369
when they all come at you at once so I'd

00:19:20,450 --> 00:19:24,200
like to go through a few of the first

00:19:22,369 --> 00:19:26,570
things that you'll need to be acquainted

00:19:24,200 --> 00:19:30,559
with when writing rest target and

00:19:26,570 --> 00:19:32,929
embedded system first you'll see a bunch

00:19:30,559 --> 00:19:36,889
of references to hell the hardware

00:19:32,929 --> 00:19:42,590
abstraction layer not the 2001 musical

00:19:36,889 --> 00:19:43,970
machine so this expresses the way that

00:19:42,590 --> 00:19:45,529
those standard functions that you

00:19:43,970 --> 00:19:47,389
normally get through the operating

00:19:45,529 --> 00:19:50,929
system should be performed on a

00:19:47,389 --> 00:19:52,970
particular CPU family so how crates for

00:19:50,929 --> 00:19:54,190
a given board that you're working on are

00:19:52,970 --> 00:19:57,159
a great place to

00:19:54,190 --> 00:19:59,230
find example code as well since the

00:19:57,159 --> 00:20:01,029
person who wrote the hell crate usually

00:19:59,230 --> 00:20:03,009
did it as a side-effect of trying to get

00:20:01,029 --> 00:20:05,470
some other more compelling project

00:20:03,009 --> 00:20:08,080
working on that hardware for instance

00:20:05,470 --> 00:20:10,990
the Tomo that's Tom's open micro USB

00:20:08,080 --> 00:20:13,720
device was developed by members of our

00:20:10,990 --> 00:20:15,730
own LCA community and it's helped create

00:20:13,720 --> 00:20:17,500
linked right there includes some

00:20:15,730 --> 00:20:20,980
wonderful examples of how to blink the

00:20:17,500 --> 00:20:23,049
LED and how to boot it up just to get

00:20:20,980 --> 00:20:27,370
the user started with doing anything

00:20:23,049 --> 00:20:30,279
with that crate so while an embedded

00:20:27,370 --> 00:20:31,990
board is really good at interfacing with

00:20:30,279 --> 00:20:34,360
the inputs and outputs in the

00:20:31,990 --> 00:20:36,009
environment the sensors the lights

00:20:34,360 --> 00:20:38,259
the motors whatever that might be

00:20:36,009 --> 00:20:40,929
they're generally really lacking in the

00:20:38,259 --> 00:20:43,059
human readable output Department if your

00:20:40,929 --> 00:20:45,460
program fails in some way while it's

00:20:43,059 --> 00:20:48,279
running on the board maybe it can blink

00:20:45,460 --> 00:20:51,370
an LED at you and that's generally about

00:20:48,279 --> 00:20:53,830
it so in order to get actual useful

00:20:51,370 --> 00:20:55,179
debug information off of a program while

00:20:53,830 --> 00:20:56,980
it's running on an embedded system

00:20:55,179 --> 00:21:00,279
you're going to probably want a

00:20:56,980 --> 00:21:04,960
technique known as semi hosting so this

00:21:00,279 --> 00:21:07,179
is where the code is connected to the

00:21:04,960 --> 00:21:10,240
host machine probably your development

00:21:07,179 --> 00:21:14,740
environment and it can put its errors

00:21:10,240 --> 00:21:17,789
and panics back to your console and log

00:21:14,740 --> 00:21:20,590
them out for you to analyze later on so

00:21:17,789 --> 00:21:23,019
just basically look for a semi hosting

00:21:20,590 --> 00:21:26,259
crate for your platform or family of

00:21:23,019 --> 00:21:29,379
platforms and then you can log messages

00:21:26,259 --> 00:21:31,149
from your chip as it has them back to

00:21:29,379 --> 00:21:33,100
your host machine there is a fantastic

00:21:31,149 --> 00:21:36,070
example of semi hosting in the embedded

00:21:33,100 --> 00:21:40,330
rest book for the cortex-m that they're

00:21:36,070 --> 00:21:43,750
using in their examples so definitely

00:21:40,330 --> 00:21:45,190
look for that if you want I owe in a

00:21:43,750 --> 00:21:48,669
useful feedback kind of sense

00:21:45,190 --> 00:21:53,169
another challenge of designing embedded

00:21:48,669 --> 00:21:55,720
rest programs is another site of the i/o

00:21:53,169 --> 00:21:57,700
heavy nature of all of the IOT stuff

00:21:55,720 --> 00:22:00,370
although the compiler can check the

00:21:57,700 --> 00:22:03,009
logic in your program it doesn't know

00:22:00,370 --> 00:22:06,309
enough about what the peripheral devices

00:22:03,009 --> 00:22:07,909
attached to your board might do to make

00:22:06,309 --> 00:22:10,699
any guarantees about them

00:22:07,909 --> 00:22:14,449
but the principles behind writing memory

00:22:10,699 --> 00:22:16,209
safe code still apply to writing safe

00:22:14,449 --> 00:22:19,190
interfaces to your peripherals for

00:22:16,209 --> 00:22:21,679
anything that we can read or write even

00:22:19,190 --> 00:22:24,709
if it's a peripheral device we want

00:22:21,679 --> 00:22:27,199
either one mutable that is writable

00:22:24,709 --> 00:22:29,599
reference to it at any give at any time

00:22:27,199 --> 00:22:33,709
or we can have as many readable ones as

00:22:29,599 --> 00:22:35,719
we want the way that you enforce this

00:22:33,709 --> 00:22:38,029
when it comes to an external device is

00:22:35,719 --> 00:22:40,429
using the singleton design pattern

00:22:38,029 --> 00:22:42,349
because when you use Singleton's that

00:22:40,429 --> 00:22:44,989
helps the compiler verify that there's

00:22:42,349 --> 00:22:47,299
only one instance of this peripheral in

00:22:44,989 --> 00:22:49,729
the code and once you know there's only

00:22:47,299 --> 00:22:51,589
one place in the code that's going to be

00:22:49,729 --> 00:22:52,999
pointing at let's say there networking

00:22:51,589 --> 00:22:55,609
chip the little cell phone that the

00:22:52,999 --> 00:22:57,709
cartoon chips have then the Boro checker

00:22:55,609 --> 00:22:59,509
can help you reason about whether it's

00:22:57,709 --> 00:23:01,699
possible for the code to ever try to

00:22:59,509 --> 00:23:05,239
read and write it simultaneously which

00:23:01,699 --> 00:23:07,339
is the huge no-no the alternative to

00:23:05,239 --> 00:23:10,190
using the singleton pattern would be to

00:23:07,339 --> 00:23:12,259
use mutable global state to store that

00:23:10,190 --> 00:23:14,599
code that represents the peripheral but

00:23:12,259 --> 00:23:16,579
that's guaranteed to be unsafe because

00:23:14,599 --> 00:23:18,139
you can't make any promises about

00:23:16,579 --> 00:23:20,359
whether the other parts of your program

00:23:18,139 --> 00:23:22,339
may try to write it while you're trying

00:23:20,359 --> 00:23:26,629
to read it or vice versa at any point in

00:23:22,339 --> 00:23:28,579
time so another way to improve the

00:23:26,629 --> 00:23:30,769
compilers ability to reason about your

00:23:28,579 --> 00:23:32,749
peripherals is to model them as state

00:23:30,769 --> 00:23:35,539
machines a state machine is just a

00:23:32,749 --> 00:23:38,719
representation of which of several valid

00:23:35,539 --> 00:23:42,139
conditions the peripheral can transition

00:23:38,719 --> 00:23:44,089
between from which other ones like if I

00:23:42,139 --> 00:23:46,309
was in the state of waiting to give my

00:23:44,089 --> 00:23:47,929
talk then I had to get on stage give the

00:23:46,309 --> 00:23:50,239
intro give the talk and then take

00:23:47,929 --> 00:23:53,089
questions it would be illegal to go

00:23:50,239 --> 00:23:55,219
directly from waiting to speak to taking

00:23:53,089 --> 00:23:59,269
questions it just wouldn't make sense so

00:23:55,219 --> 00:24:02,239
by quantifying that common sense in your

00:23:59,269 --> 00:24:04,940
code it helps the compiler check whether

00:24:02,239 --> 00:24:06,909
any of your assumptions have been or

00:24:04,940 --> 00:24:10,819
could be violated

00:24:06,909 --> 00:24:13,219
so abstractions like oh yes express your

00:24:10,819 --> 00:24:15,079
peripheral as a state machine are

00:24:13,219 --> 00:24:17,659
written with a lot of lines of code and

00:24:15,079 --> 00:24:19,549
this probably makes you worried that

00:24:17,659 --> 00:24:22,999
they'll produce larger or slower

00:24:19,549 --> 00:24:24,739
programs after compilation but they use

00:24:22,999 --> 00:24:27,289
a bunch of struts that don't actually

00:24:24,739 --> 00:24:29,889
hold any data to represent the states

00:24:27,289 --> 00:24:33,049
which might seem kind of unnecessary

00:24:29,889 --> 00:24:35,329
until you realize that as it compiles

00:24:33,049 --> 00:24:36,919
down as long as they're empty they'll

00:24:35,329 --> 00:24:38,899
just get compiled away because it's

00:24:36,919 --> 00:24:40,579
smart enough to realize it's got nothing

00:24:38,899 --> 00:24:43,279
in can't have enough of it it'll never

00:24:40,579 --> 00:24:46,039
be needed at runtime so you can get the

00:24:43,279 --> 00:24:48,979
benefit of having the logic expressed by

00:24:46,039 --> 00:24:51,019
these empty abstractions without the

00:24:48,979 --> 00:24:52,879
cost of having them alter the code

00:24:51,019 --> 00:24:54,619
that's produced at the end that's the

00:24:52,879 --> 00:24:56,779
zero cost abstraction that restorations

00:24:54,619 --> 00:24:58,339
go on about and it's when you get

00:24:56,779 --> 00:25:01,069
basically the best of both worlds

00:24:58,339 --> 00:25:03,589
another challenge in writing embedded

00:25:01,069 --> 00:25:05,959
software is concurrency if you take no

00:25:03,589 --> 00:25:07,789
special precautions around concurrency

00:25:05,959 --> 00:25:09,229
it's possible that you might be halfway

00:25:07,789 --> 00:25:10,909
through doing something that you really

00:25:09,229 --> 00:25:13,369
don't want to get interrupted with like

00:25:10,909 --> 00:25:15,440
reading or writing something and then an

00:25:13,369 --> 00:25:16,699
interrupt fires and changes the state of

00:25:15,440 --> 00:25:18,199
that thing you were working with and

00:25:16,699 --> 00:25:19,729
then who knows what's going to happen

00:25:18,199 --> 00:25:21,679
afterwards you get undefined behavior

00:25:19,729 --> 00:25:24,469
and that's what we're trying to avoid

00:25:21,679 --> 00:25:27,229
so instead there's three ways you can

00:25:24,469 --> 00:25:29,299
tackle concurrency in your code the

00:25:27,229 --> 00:25:31,879
first way to handle concurrency is to

00:25:29,299 --> 00:25:33,379
avoid it don't handle interrupts and if

00:25:31,879 --> 00:25:35,209
you need to get the state of something

00:25:33,379 --> 00:25:37,429
around you just pull it when you have

00:25:35,209 --> 00:25:40,519
time to for some devices especially

00:25:37,429 --> 00:25:43,190
those that upload data every so often or

00:25:40,519 --> 00:25:45,440
toggle their output upon detecting some

00:25:43,190 --> 00:25:47,209
condition that persists over time this

00:25:45,440 --> 00:25:50,089
can actually be a perfectly viable

00:25:47,209 --> 00:25:52,279
solution and avoiding concurrency all

00:25:50,089 --> 00:25:54,349
together makes programs easier to write

00:25:52,279 --> 00:25:58,759
and easier to reason about in debug but

00:25:54,349 --> 00:26:00,139
it's often not possible so instead when

00:25:58,759 --> 00:26:01,669
you need to handle concurrency on a

00:26:00,139 --> 00:26:04,279
board that supports it you can use

00:26:01,669 --> 00:26:06,859
atomic operations that are provided by

00:26:04,279 --> 00:26:08,779
the instruction set of the device that

00:26:06,859 --> 00:26:11,509
you're targeting for instance if you're

00:26:08,779 --> 00:26:14,029
using a cortex m3 you'll have atomic

00:26:11,509 --> 00:26:15,949
operations for reads and writes that

00:26:14,029 --> 00:26:18,079
will just retry until they're successful

00:26:15,949 --> 00:26:19,969
if something that can't be interrupted

00:26:18,079 --> 00:26:22,039
was going on when they first tried to

00:26:19,969 --> 00:26:24,649
happen for earlier cortex as though you

00:26:22,039 --> 00:26:26,299
won't have those so if your board and

00:26:24,649 --> 00:26:29,119
your Howell create support Atomics

00:26:26,299 --> 00:26:30,739
they can let you do important operations

00:26:29,119 --> 00:26:33,079
without the risk of them getting

00:26:30,739 --> 00:26:33,580
interrupted or ever getting forgotten to

00:26:33,079 --> 00:26:36,250
get

00:26:33,580 --> 00:26:37,960
but what if you don't have them the

00:26:36,250 --> 00:26:40,990
final approach if you've got to have

00:26:37,960 --> 00:26:42,730
concurrency and you can't do Atomics is

00:26:40,990 --> 00:26:44,980
you can just temporarily disable

00:26:42,730 --> 00:26:47,620
interrupts while the important pieces of

00:26:44,980 --> 00:26:49,450
code are executed but leave them on the

00:26:47,620 --> 00:26:53,260
rest of the time when the less critical

00:26:49,450 --> 00:26:54,820
code is going on so those areas where

00:26:53,260 --> 00:26:56,800
there's no interrupts allowed are called

00:26:54,820 --> 00:27:00,520
critical sections and the syntax for

00:26:56,800 --> 00:27:02,590
them will vary based on the crates that

00:27:00,520 --> 00:27:05,020
you're using to target your particular

00:27:02,590 --> 00:27:07,210
architecture so they do have the

00:27:05,020 --> 00:27:08,950
drawback that if an interrupt just gets

00:27:07,210 --> 00:27:11,350
ignored then you have to figure out

00:27:08,950 --> 00:27:12,880
what's going to happen but that's less

00:27:11,350 --> 00:27:14,230
problematic than getting the undefined

00:27:12,880 --> 00:27:18,910
behavior of interrupting at the wrong

00:27:14,230 --> 00:27:20,560
time so finally one of the parts of CPU

00:27:18,910 --> 00:27:22,420
behavior that you're gonna have to

00:27:20,560 --> 00:27:25,180
micromanage well you don't have an OS

00:27:22,420 --> 00:27:27,130
helping you is telling it what all the

00:27:25,180 --> 00:27:28,800
registers do the registers are just

00:27:27,130 --> 00:27:31,720
little spaces in memory where the

00:27:28,800 --> 00:27:33,820
processor stores little specific pieces

00:27:31,720 --> 00:27:36,400
of information each one has an address

00:27:33,820 --> 00:27:38,260
and some of them store special

00:27:36,400 --> 00:27:40,210
information where the CPU will always

00:27:38,260 --> 00:27:41,980
look to that place for that fact and

00:27:40,210 --> 00:27:44,680
others can hold whatever you want them

00:27:41,980 --> 00:27:46,720
to so using the right specialized

00:27:44,680 --> 00:27:48,940
registers matters a lot because an

00:27:46,720 --> 00:27:50,620
instruction might read from a particular

00:27:48,940 --> 00:27:52,810
register and if you have the wrong thing

00:27:50,620 --> 00:27:55,690
there nothing is going to work as

00:27:52,810 --> 00:27:57,370
expected so one of your jobs as an

00:27:55,690 --> 00:27:59,530
embedded programmer is to tell rust

00:27:57,370 --> 00:28:02,040
about what registers that target

00:27:59,530 --> 00:28:04,450
platform has available on what they do

00:28:02,040 --> 00:28:07,420
rather than writing everything out by

00:28:04,450 --> 00:28:10,210
hand you can define your registers using

00:28:07,420 --> 00:28:12,280
a tool called SVD to rust that's based

00:28:10,210 --> 00:28:14,740
on the system view description of format

00:28:12,280 --> 00:28:16,750
files that are often provided by chip

00:28:14,740 --> 00:28:19,690
manufacturers that are a standard way of

00:28:16,750 --> 00:28:21,580
telling you what all the registers are

00:28:19,690 --> 00:28:24,460
and it can convert these into support

00:28:21,580 --> 00:28:26,890
crêpes if you search crates tocayo

00:28:24,460 --> 00:28:28,180
for SVD to rest plus the name of the

00:28:26,890 --> 00:28:29,980
chip or chip family that you're

00:28:28,180 --> 00:28:32,110
targeting somebody might have already

00:28:29,980 --> 00:28:35,470
made this support crate for you and

00:28:32,110 --> 00:28:38,260
provided it so otherwise you can use the

00:28:35,470 --> 00:28:41,710
SVD to rest tool itself to turn an SVG

00:28:38,260 --> 00:28:45,280
file into a rust compatible expression

00:28:41,710 --> 00:28:47,049
of what those registers are so if you're

00:28:45,280 --> 00:28:49,330
interested in learning more about

00:28:47,049 --> 00:28:51,519
embedded or low-level rest by reading it

00:28:49,330 --> 00:28:53,679
the many operating systems that are

00:28:51,519 --> 00:28:56,379
written in rust can be a great place to

00:28:53,679 --> 00:29:00,100
see it really pushing the boundaries so

00:28:56,379 --> 00:29:03,039
a few of those the red ox OS is probably

00:29:00,100 --> 00:29:05,529
the most famous of those and it runs on

00:29:03,039 --> 00:29:07,360
the nightly rust that has all of the

00:29:05,529 --> 00:29:10,389
cool new features there are others

00:29:07,360 --> 00:29:13,419
though Robo Galia is trying to improve

00:29:10,389 --> 00:29:14,950
the rest ecosystem around the SEL for

00:29:13,419 --> 00:29:16,600
microkernel so if that's something that

00:29:14,950 --> 00:29:19,149
interests you check out their site and

00:29:16,600 --> 00:29:21,519
if you'd really just like to be walked

00:29:19,149 --> 00:29:23,679
through a teaching operating system that

00:29:21,519 --> 00:29:26,559
comes with a book explaining systems

00:29:23,679 --> 00:29:28,989
concepts as they apply to it check out

00:29:26,559 --> 00:29:30,759
Intermezzo s-- which is exactly that

00:29:28,989 --> 00:29:34,570
teaching OS to help programmers

00:29:30,759 --> 00:29:36,220
transition into systems programming so

00:29:34,570 --> 00:29:38,080
another thing to call out especially

00:29:36,220 --> 00:29:40,359
since we're talking about IOT today is

00:29:38,080 --> 00:29:43,210
that there's the top operating system

00:29:40,359 --> 00:29:45,489
and project they're at Taco S org that

00:29:43,210 --> 00:29:48,129
offers a couple of open hardware boards

00:29:45,489 --> 00:29:49,950
and is customized for them that's

00:29:48,129 --> 00:29:53,200
focused on improving the IOT ecosystem

00:29:49,950 --> 00:29:54,820
so if open hardware is a big deal to you

00:29:53,200 --> 00:29:58,359
and you want to go buy a board or

00:29:54,820 --> 00:30:00,850
produce a board that has a huge amount

00:29:58,359 --> 00:30:05,200
of rust support seriously consider their

00:30:00,850 --> 00:30:06,730
hail and I mix products so as I

00:30:05,200 --> 00:30:09,700
mentioned at the start of this talk

00:30:06,730 --> 00:30:11,950
rusts embedded resources have expanded

00:30:09,700 --> 00:30:14,649
so much even just in the ten months

00:30:11,950 --> 00:30:16,450
since I proposed this talk to fill what

00:30:14,649 --> 00:30:19,480
felt at the time like a gap in their

00:30:16,450 --> 00:30:22,269
documentation so there's now an embedded

00:30:19,480 --> 00:30:25,440
working group with an IRC channel and

00:30:22,269 --> 00:30:28,659
the handle rest embedded on Twitter so

00:30:25,440 --> 00:30:30,999
you can absolutely join them ask them

00:30:28,659 --> 00:30:33,220
questions they are the experts there's a

00:30:30,999 --> 00:30:36,129
couple of books out the embedded nomicon

00:30:33,220 --> 00:30:38,019
and the debugger nomicon this is a

00:30:36,129 --> 00:30:40,210
common naming convention for how to

00:30:38,019 --> 00:30:43,389
write unsafe rest is just always the

00:30:40,210 --> 00:30:45,850
nomicon if you would like to go into

00:30:43,389 --> 00:30:47,559
more detail and the working groups

00:30:45,850 --> 00:30:50,739
repository has a bunch of things

00:30:47,559 --> 00:30:54,340
including they're working at the moment

00:30:50,739 --> 00:30:57,850
on a repository and a website of

00:30:54,340 --> 00:30:59,859
showcasing a bunch of cool embedded

00:30:57,850 --> 00:31:00,190
projects that's not ready yet but pretty

00:30:59,859 --> 00:31:01,870
soon

00:31:00,190 --> 00:31:03,429
we'll be ready for polls proposing your

00:31:01,870 --> 00:31:05,740
own rust embedded projects to be

00:31:03,429 --> 00:31:07,539
showcased there and if you're just

00:31:05,740 --> 00:31:10,330
getting started in embedded development

00:31:07,539 --> 00:31:12,789
I'd strongly recommend the rest embedded

00:31:10,330 --> 00:31:14,879
discovery book which is focused on

00:31:12,789 --> 00:31:17,230
teaching people about how to use

00:31:14,879 --> 00:31:19,210
microcontrollers who haven't used

00:31:17,230 --> 00:31:21,220
microcontrollers before and just

00:31:19,210 --> 00:31:25,090
happening to use rust as the language

00:31:21,220 --> 00:31:28,509
they do it in so with that I've

00:31:25,090 --> 00:31:31,149
basically surveyed the core concepts of

00:31:28,509 --> 00:31:33,730
embedded rest to hopefully launch you

00:31:31,149 --> 00:31:36,759
out into doing or continuing your own

00:31:33,730 --> 00:31:38,409
rust project and I would like to use the

00:31:36,759 --> 00:31:41,740
rest of the time that's available to me

00:31:38,409 --> 00:31:44,379
these last 15 minutes to have more or

00:31:41,740 --> 00:31:46,629
less a mini buff the way that I would

00:31:44,379 --> 00:31:49,210
like this to work is I'd like to hear

00:31:46,629 --> 00:31:51,580
from those of you who have ruffs IOT

00:31:49,210 --> 00:31:54,370
projects or just rest projects or want

00:31:51,580 --> 00:31:56,830
to start one so put up your hand we'll

00:31:54,370 --> 00:31:59,980
come around with a mic and tell us

00:31:56,830 --> 00:32:02,200
basically these questions what's your

00:31:59,980 --> 00:32:03,970
favorite rest IOT project or the project

00:32:02,200 --> 00:32:06,250
you contribute to or that you're looking

00:32:03,970 --> 00:32:09,340
for what kind of help and feedback does

00:32:06,250 --> 00:32:11,559
it need what should people search to

00:32:09,340 --> 00:32:13,720
find it online and for everybody that

00:32:11,559 --> 00:32:16,480
shares a project up until I run out I

00:32:13,720 --> 00:32:17,860
have a little rest mascot for you and if

00:32:16,480 --> 00:32:19,659
we give you one of these please display

00:32:17,860 --> 00:32:21,940
it through the conference and if you

00:32:19,659 --> 00:32:23,559
want to talk about rest to someone find

00:32:21,940 --> 00:32:25,600
someone with the mascot on them and you

00:32:23,559 --> 00:32:29,740
will know that they are a friendly rust

00:32:25,600 --> 00:32:31,240
nerd so if you have questions we can

00:32:29,740 --> 00:32:33,700
take questions in the end at the end

00:32:31,240 --> 00:32:36,250
outside but I would recommend talking to

00:32:33,700 --> 00:32:38,230
the experts who are using and doing

00:32:36,250 --> 00:32:41,289
these projects because so many questions

00:32:38,230 --> 00:32:43,360
our value judgments and matters of

00:32:41,289 --> 00:32:45,820
experience and opinion that you will get

00:32:43,360 --> 00:32:47,110
a better answer from polling several

00:32:45,820 --> 00:32:49,299
people who've tried it at different

00:32:47,110 --> 00:32:53,500
times than from asking any one speaker

00:32:49,299 --> 00:32:56,649
so with that let's start going around to

00:32:53,500 --> 00:33:00,610
for people to share their IOT rust stuff

00:32:56,649 --> 00:33:05,379
mm-hmm hi thanks Emily I'll stop I'm

00:33:00,610 --> 00:33:07,210
William Brown or first year online my I

00:33:05,379 --> 00:33:09,909
have a number of projects one of them is

00:33:07,210 --> 00:33:12,129
a lifx based light bulb controller which

00:33:09,909 --> 00:33:13,539
is for my home network it also does

00:33:12,129 --> 00:33:15,369
party hard mode

00:33:13,539 --> 00:33:18,820
so you can turn your house into the rave

00:33:15,369 --> 00:33:20,080
that you've always wanted generally what

00:33:18,820 --> 00:33:23,019
I do is I actually specialize in

00:33:20,080 --> 00:33:25,359
concurrency Pallo algorithms and unsafe

00:33:23,019 --> 00:33:27,609
code I think the life X is the only

00:33:25,359 --> 00:33:30,309
thing right don't have unsafe so I'm

00:33:27,609 --> 00:33:32,019
love to help you with your project so if

00:33:30,309 --> 00:33:39,460
you want some mentoring please come and

00:33:32,019 --> 00:33:42,009
talk to me about this stuff thank you hi

00:33:39,460 --> 00:33:45,159
I'm Kate Stewart and I'm with the Zephyr

00:33:42,009 --> 00:33:46,919
project and so one of the things were

00:33:45,159 --> 00:33:50,679
interested in and obviously is running

00:33:46,919 --> 00:33:51,940
on OS very lightweight OS and so I'm

00:33:50,679 --> 00:33:55,539
sort of curious is there any work being

00:33:51,940 --> 00:33:57,879
done on having a rust port rust standard

00:33:55,539 --> 00:34:00,700
library port into Zephyr to be running

00:33:57,879 --> 00:34:02,590
with it do you know of I'm not I'm not

00:34:00,700 --> 00:34:04,599
personally aware of as eff report off

00:34:02,590 --> 00:34:07,929
the top of my head but there could very

00:34:04,599 --> 00:34:09,429
well be one quietly being discussed or

00:34:07,929 --> 00:34:10,929
worked on online that I just don't

00:34:09,429 --> 00:34:12,579
happen to have seen yet because I

00:34:10,929 --> 00:34:14,649
haven't looked for it so I would

00:34:12,579 --> 00:34:16,899
strongly recommend both searching it and

00:34:14,649 --> 00:34:19,059
asking the embedded working group in

00:34:16,899 --> 00:34:21,460
their channel and asking around the

00:34:19,059 --> 00:34:24,909
Zephyr community because things are

00:34:21,460 --> 00:34:26,619
often just quietly not quite open yet

00:34:24,909 --> 00:34:29,349
because people aren't quite happy with

00:34:26,619 --> 00:34:32,190
them yet for quite some time before they

00:34:29,349 --> 00:34:38,559
become really public and easy to find

00:34:32,190 --> 00:34:42,309
Thanks all right it's more of a generic

00:34:38,559 --> 00:34:48,059
rust related question rather than IT

00:34:42,309 --> 00:34:53,109
project I'm afraid so I work for arm who

00:34:48,059 --> 00:34:56,349
create load of CPI P one of the issues

00:34:53,109 --> 00:35:01,299
that we have is engaging with the russ

00:34:56,349 --> 00:35:05,430
community to ensure the rust is properly

00:35:01,299 --> 00:35:08,280
ported supported ensuring that rust has

00:35:05,430 --> 00:35:10,660
support for all latest features and

00:35:08,280 --> 00:35:12,849
whiz-bang blinky things that we decide

00:35:10,660 --> 00:35:16,619
to throw in that our partners want to

00:35:12,849 --> 00:35:19,660
create whatever else do you have any

00:35:16,619 --> 00:35:23,380
recommendation suggestions pointers as

00:35:19,660 --> 00:35:25,779
to how we can facilitate the wider russ

00:35:23,380 --> 00:35:30,049
community much better

00:35:25,779 --> 00:35:32,539
absolutely so I would say that the core

00:35:30,049 --> 00:35:35,329
team is your best point of contact there

00:35:32,539 --> 00:35:37,460
and if you go to the core team and ask

00:35:35,329 --> 00:35:40,970
for their feedback on your current

00:35:37,460 --> 00:35:43,730
engagement with the community then they

00:35:40,970 --> 00:35:46,759
can probably point you exactly where you

00:35:43,730 --> 00:35:48,349
can help best there is a bit of a

00:35:46,759 --> 00:35:50,749
concern in that rest is a fully

00:35:48,349 --> 00:35:52,819
volunteer project some people are paid

00:35:50,749 --> 00:35:55,249
to work on rest but that's generally

00:35:52,819 --> 00:35:59,539
rest for their particular company's

00:35:55,249 --> 00:36:01,999
needs and so there's there's some

00:35:59,539 --> 00:36:05,720
ambiguity in your comment about whether

00:36:01,999 --> 00:36:07,759
or not you're expecting here's some

00:36:05,720 --> 00:36:10,630
hardware please implement all of the

00:36:07,759 --> 00:36:13,130
things for us if that's the case then

00:36:10,630 --> 00:36:14,509
making sure that there is something in

00:36:13,130 --> 00:36:17,839
it for the people doing the

00:36:14,509 --> 00:36:20,599
implementation can help a lot if that's

00:36:17,839 --> 00:36:23,809
if that's not the case just I think

00:36:20,599 --> 00:36:25,460
working working directly with the core

00:36:23,809 --> 00:36:27,109
team working with the infrastructure

00:36:25,460 --> 00:36:29,150
team if you're concerned about the test

00:36:27,109 --> 00:36:31,220
story for instance if you're like why

00:36:29,150 --> 00:36:31,819
aren't you why isn't this tier 1 why

00:36:31,220 --> 00:36:33,619
aren't you

00:36:31,819 --> 00:36:36,589
testing building and testing everything

00:36:33,619 --> 00:36:39,230
on it maybe it's we don't have the

00:36:36,589 --> 00:36:40,670
hardware because no one has provided us

00:36:39,230 --> 00:36:42,170
with hardware and/or no one's running

00:36:40,670 --> 00:36:44,239
the hardware or whatever that might be

00:36:42,170 --> 00:36:46,849
and whatever that answer is to the

00:36:44,239 --> 00:36:49,220
question what can we do to get this to a

00:36:46,849 --> 00:36:51,410
higher support tier and to contribute

00:36:49,220 --> 00:36:54,430
better they will be able to point to you

00:36:51,410 --> 00:36:57,859
in the best direction for that

00:36:54,430 --> 00:36:59,329
engagement and we could brainstorm later

00:36:57,859 --> 00:37:02,210
on about community involvement

00:36:59,329 --> 00:37:05,809
strategies about basically marketing

00:37:02,210 --> 00:37:08,809
your project maybe have a bet about

00:37:05,809 --> 00:37:11,869
better publicizing what can be done with

00:37:08,809 --> 00:37:13,609
it but let's continue for now I would be

00:37:11,869 --> 00:37:17,509
delighted to talk to you after about

00:37:13,609 --> 00:37:22,369
just ideas for how to make it better

00:37:17,509 --> 00:37:23,900
known hi great talk I just wanted to

00:37:22,369 --> 00:37:25,640
mention a big part of IOT is obviously

00:37:23,900 --> 00:37:28,730
the mobile applications to interact with

00:37:25,640 --> 00:37:31,700
those we've recently started using rust

00:37:28,730 --> 00:37:34,509
for iOS and Android in production and

00:37:31,700 --> 00:37:37,160
we've found it to be brilliant like the

00:37:34,509 --> 00:37:39,109
Android bindings and I had the iOS

00:37:37,160 --> 00:37:41,869
bindings just a

00:37:39,109 --> 00:37:43,519
so if you are making an IIT device

00:37:41,869 --> 00:37:46,430
consider using rust because then you can

00:37:43,519 --> 00:37:48,519
use rust for your device itself and also

00:37:46,430 --> 00:37:51,289
for the core parts of iOS and Android

00:37:48,519 --> 00:37:52,670
might save you some time fantastic

00:37:51,289 --> 00:37:56,180
absolutely thank you for that feedback

00:37:52,670 --> 00:38:01,039
we've got one night got lots of people

00:37:56,180 --> 00:38:02,900
good for it hi I I actually come from

00:38:01,039 --> 00:38:04,459
the other way I'm an embedded developer

00:38:02,900 --> 00:38:07,880
on microcontrollers dissing say

00:38:04,459 --> 00:38:09,769
and I'm wondering so there's obviously a

00:38:07,880 --> 00:38:11,930
way to foresee and Russell talk to each

00:38:09,769 --> 00:38:14,450
other but whether there is any plans or

00:38:11,930 --> 00:38:16,219
hopefully implementation to be also able

00:38:14,450 --> 00:38:18,559
to reuse all the tooling that's

00:38:16,219 --> 00:38:20,229
available for C because there's some

00:38:18,559 --> 00:38:23,959
really really nice things such as

00:38:20,229 --> 00:38:27,319
streaming trace to actually see all if

00:38:23,959 --> 00:38:30,769
your executions in one place and things

00:38:27,319 --> 00:38:32,660
like from if I'm not mistaken existing

00:38:30,769 --> 00:38:34,459
artists integration where you can see

00:38:32,660 --> 00:38:38,479
several threads and what are their call

00:38:34,459 --> 00:38:40,069
stacks are and also things like having a

00:38:38,479 --> 00:38:42,289
microcontroller that can support

00:38:40,069 --> 00:38:44,809
external memory interface so you have an

00:38:42,289 --> 00:38:46,819
internal SRAM an external DRAM which is

00:38:44,809 --> 00:38:51,859
slower and bigger and have being able to

00:38:46,819 --> 00:38:53,630
access those say yeah personally

00:38:51,859 --> 00:38:55,759
familiar with what the state of the art

00:38:53,630 --> 00:38:57,920
and that is however I would strongly

00:38:55,759 --> 00:39:00,949
recommend stopping by the rest embedded

00:38:57,920 --> 00:39:02,630
working groups channel and asking them

00:39:00,949 --> 00:39:04,160
what they're doing and what they want to

00:39:02,630 --> 00:39:06,410
do with that and they'll likely point

00:39:04,160 --> 00:39:08,150
you towards some people who are quietly

00:39:06,410 --> 00:39:11,589
working on it or quietly thinking about

00:39:08,150 --> 00:39:13,969
it thank you

00:39:11,589 --> 00:39:15,739
maybe it's partially overlapping with

00:39:13,969 --> 00:39:18,049
his question but what's the debug story

00:39:15,739 --> 00:39:20,390
right now because I used rust about one

00:39:18,049 --> 00:39:22,099
year ago for us Jas stuff and I got

00:39:20,390 --> 00:39:22,569
stuck into debugging is really really

00:39:22,099 --> 00:39:25,279
hard

00:39:22,569 --> 00:39:27,680
awesome Jes is also kind of new platform

00:39:25,279 --> 00:39:29,989
so it's not just rust being immature

00:39:27,680 --> 00:39:33,650
but what about you know embedded

00:39:29,989 --> 00:39:37,729
programming so yeah debugging is

00:39:33,650 --> 00:39:39,229
absolutely hard I don't know of a

00:39:37,729 --> 00:39:43,009
language in which you've been embedded

00:39:39,229 --> 00:39:44,449
debugging is necessarily easy if there's

00:39:43,009 --> 00:39:46,849
a language in which it's radically

00:39:44,449 --> 00:39:49,099
easier and they have a tooling story

00:39:46,849 --> 00:39:52,130
that makes it radically easier I'm

00:39:49,099 --> 00:39:52,560
pretty sure that the developers and

00:39:52,130 --> 00:39:54,000
myself

00:39:52,560 --> 00:39:58,290
would love to hear about how we could

00:39:54,000 --> 00:40:02,160
adopt that the debug story I mean you

00:39:58,290 --> 00:40:03,900
want I is that an answer up there ah yes

00:40:02,160 --> 00:40:06,210
what is your possible answer hmm

00:40:03,900 --> 00:40:08,820
I will sorry I'm really giving my

00:40:06,210 --> 00:40:10,410
volunteers their exercise so on embedded

00:40:08,820 --> 00:40:13,140
I've used a product called black magic

00:40:10,410 --> 00:40:14,370
Pro before which is basically it gives

00:40:13,140 --> 00:40:17,190
you a serial port to a JTAG interface

00:40:14,370 --> 00:40:18,900
and I've actually messed around a bit

00:40:17,190 --> 00:40:20,640
with using rust on that and you do get

00:40:18,900 --> 00:40:21,930
call stacks and you can put breakpoints

00:40:20,640 --> 00:40:23,430
and stuff like that on and you don't

00:40:21,930 --> 00:40:25,140
have to worry too much about LOD be

00:40:23,430 --> 00:40:26,640
talking to your device and stuff so I

00:40:25,140 --> 00:40:29,970
can recommend if you're using your

00:40:26,640 --> 00:40:32,760
cortex m0 or cortex m3 check out a black

00:40:29,970 --> 00:40:34,320
magic probe it's not amazing debugging

00:40:32,760 --> 00:40:36,210
but it will give you kind of the very

00:40:34,320 --> 00:40:39,180
basics of you know course tax install

00:40:36,210 --> 00:40:40,950
thank you for the suggestion and yeah

00:40:39,180 --> 00:40:45,360
the best tool is very likely to vary per

00:40:40,950 --> 00:40:54,720
platform and black magic is open-source

00:40:45,360 --> 00:40:57,320
thank you for that add-on hi I'm Wes I

00:40:54,720 --> 00:41:00,330
run a little project called read rust

00:40:57,320 --> 00:41:02,400
which collects blog posts from the Ross

00:41:00,330 --> 00:41:05,340
community and it's a bit of a future

00:41:02,400 --> 00:41:08,370
call for the participation but currently

00:41:05,340 --> 00:41:11,310
working on a version 2 that would let me

00:41:08,370 --> 00:41:13,950
recruit other people to help post the

00:41:11,310 --> 00:41:15,990
the articles and approve them so if

00:41:13,950 --> 00:41:17,880
anyone's keen to get involved I'm also

00:41:15,990 --> 00:41:20,070
working on this new version being based

00:41:17,880 --> 00:41:21,240
on it already uses the bunch of rust

00:41:20,070 --> 00:41:22,770
tools but the new version is going to be

00:41:21,240 --> 00:41:24,540
built there's a brass web server as well

00:41:22,770 --> 00:41:27,870
so there'll be some coding involved as

00:41:24,540 --> 00:41:29,490
well it's still early days so totally

00:41:27,870 --> 00:41:31,470
still a couple months off before I'd

00:41:29,490 --> 00:41:40,530
need extra people but yeah if anyone's

00:41:31,470 --> 00:41:41,310
interested comes see me fantastic I

00:41:40,530 --> 00:41:43,020
guess you

00:41:41,310 --> 00:41:45,690
the inspiration here so I've been using

00:41:43,020 --> 00:41:47,250
these Nordic based embedded sheets which

00:41:45,690 --> 00:41:50,580
is a Bluetooth low-energy chipset with

00:41:47,250 --> 00:41:52,530
an arm m4 embedded and I was interested

00:41:50,580 --> 00:41:53,910
to look at the rust IOT so I thought

00:41:52,530 --> 00:41:54,900
well maybe I can print it but I looked

00:41:53,910 --> 00:41:56,220
and there's actually a seemingly

00:41:54,900 --> 00:41:57,840
relatively mature project for it already

00:41:56,220 --> 00:41:58,920
so I guess what I'm excited to see is

00:41:57,840 --> 00:42:01,620
there's actually quite some mature

00:41:58,920 --> 00:42:03,060
ecosystem around rust embedded so yeah

00:42:01,620 --> 00:42:04,320
I'm gonna try it out and I guess the

00:42:03,060 --> 00:42:05,580
expression to others is even if you

00:42:04,320 --> 00:42:07,290
think it's more obscure maybe there's

00:42:05,580 --> 00:42:08,670
already stuff going on the rough space

00:42:07,290 --> 00:42:11,310
for it and you may not have to stuff

00:42:08,670 --> 00:42:13,020
from scratch yes absolutely thank you

00:42:11,310 --> 00:42:14,910
for that feedback because I've been

00:42:13,020 --> 00:42:16,410
surprised as well I'm like I've never

00:42:14,910 --> 00:42:19,670
even heard of this architecture and yet

00:42:16,410 --> 00:42:22,830
it's got robust rust things happening

00:42:19,670 --> 00:42:26,910
not particularly IOT related but I'm in

00:42:22,830 --> 00:42:29,490
the middle of writing some rust code for

00:42:26,910 --> 00:42:32,730
graph algorithms a port of an earlier C

00:42:29,490 --> 00:42:35,490
module with a particular emphasis on the

00:42:32,730 --> 00:42:38,430
fact that lots of problems involve

00:42:35,490 --> 00:42:39,810
standard graph algorithms but you don't

00:42:38,430 --> 00:42:42,300
usually want to change all your data

00:42:39,810 --> 00:42:45,140
structures into the form that most graph

00:42:42,300 --> 00:42:47,670
libraries want them in order to do that

00:42:45,140 --> 00:42:49,830
so if anyone wants to assist with that

00:42:47,670 --> 00:42:51,900
particularly if they know the sort of

00:42:49,830 --> 00:42:56,120
rustic idiom ways of doing things then

00:42:51,900 --> 00:42:59,280
that would be most appreciated fantastic

00:42:56,120 --> 00:43:07,590
it looks like we have time for one or

00:42:59,280 --> 00:43:10,770
two more anyone else up there all right

00:43:07,590 --> 00:43:13,110
not quite an IOT projects but it is

00:43:10,770 --> 00:43:16,410
embedded if anyone doesn't know these

00:43:13,110 --> 00:43:19,550
Sony cameras actually can run Android so

00:43:16,410 --> 00:43:23,100
what started out as an attempt at

00:43:19,550 --> 00:43:24,960
porting over the Google HDR app to try

00:43:23,100 --> 00:43:30,240
and get amazing photos out of it and

00:43:24,960 --> 00:43:34,350
then installing Instagram on that which

00:43:30,240 --> 00:43:36,150
I can post directly to anyone does I've

00:43:34,350 --> 00:43:38,870
been looking at playing around with

00:43:36,150 --> 00:43:42,120
computer vision with one of these and

00:43:38,870 --> 00:43:46,560
yeah I would talk to me later if you

00:43:42,120 --> 00:43:49,190
want to see where I'm at fantastic one

00:43:46,560 --> 00:43:49,190
down here as well

00:43:54,369 --> 00:44:04,989
No anais a project and something I

00:44:02,029 --> 00:44:11,420
haven't really done that much in a while

00:44:04,989 --> 00:44:14,450
is stuff to work try and make sort of a

00:44:11,420 --> 00:44:17,710
screenshot in slash a video recording

00:44:14,450 --> 00:44:23,869
thing in rust that we'll be able to

00:44:17,710 --> 00:44:25,940
catch frames to turn a presentation into

00:44:23,869 --> 00:44:28,690
a bunch of slides because you have

00:44:25,940 --> 00:44:32,749
transitions and more little things

00:44:28,690 --> 00:44:34,519
having the points come up which is hard

00:44:32,749 --> 00:44:36,559
to capture apart from screen shopping

00:44:34,519 --> 00:44:39,559
but I wanted to capture basically

00:44:36,559 --> 00:44:42,829
everything in the state to turn into a

00:44:39,559 --> 00:44:47,630
bunch of images with timestamps and when

00:44:42,829 --> 00:44:49,759
optimize it down and so it's in the

00:44:47,630 --> 00:44:53,660
state of it was working on Windows and

00:44:49,759 --> 00:44:55,970
then they realized but I'm not doing it

00:44:53,660 --> 00:45:01,970
well when it didn't work where it was

00:44:55,970 --> 00:45:03,499
that we wanting it to work yeah all

00:45:01,970 --> 00:45:05,210
right well it looks like we're just

00:45:03,499 --> 00:45:07,430
about at time thank you everybody for

00:45:05,210 --> 00:45:10,970
your feedback and your publication of

00:45:07,430 --> 00:45:14,779
your various rest and rest IRT projects

00:45:10,970 --> 00:45:16,640
so you can get these slides and notes at

00:45:14,779 --> 00:45:20,869
that link you can find me on Twitter or

00:45:16,640 --> 00:45:22,640
on IRC and I will be around we can do a

00:45:20,869 --> 00:45:25,989
rest-pause later if anyone wants a rest

00:45:22,640 --> 00:45:25,989

YouTube URL: https://www.youtube.com/watch?v=uCnnhMleoKA


