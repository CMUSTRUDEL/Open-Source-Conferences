Title: Rust: A Language for the Next 40 Years - Carol Nichols
Publication date: 2019-05-13
Playlist: Other Conferences 2019
Description: 
	Learn what makes the programming language Rust a unique technology, such as the memory safety guarantees that enable more people to write performant systems-level code. Hear about how Rust Editions evolve the language and the compiler without breaking existing code. See who’s trusting Rust for critical products today. Join us on Rust’s journey to the future.

Philly ETE 2019 Playlist: https://www.youtube.com/playlist?list=PL9oQ7yETvN10Lopbg81O_bwElm9grUkDB
On the Chariot Solutions site: http://chariotsolutions.com/screencasts/
Captions: 
	00:00:13,030 --> 00:00:18,520
so you are in the talk rust a language

00:00:16,119 --> 00:00:21,310
for the next forty years my name is

00:00:18,520 --> 00:00:24,369
Carol nickels or Golding it's

00:00:21,310 --> 00:00:26,050
short-circuits I will answer two nickels

00:00:24,369 --> 00:00:27,520
quicker but you can also call me Carol

00:00:26,050 --> 00:00:30,130
building if you want

00:00:27,520 --> 00:00:33,430
I'm Carol's ten cents on all the various

00:00:30,130 --> 00:00:36,160
platforms I have a lot of links in my

00:00:33,430 --> 00:00:38,410
slides so if you want to be able to

00:00:36,160 --> 00:00:40,510
follow up on references and check out

00:00:38,410 --> 00:00:43,480
some more things this short link will

00:00:40,510 --> 00:00:46,270
take you to a repo where there's link to

00:00:43,480 --> 00:00:51,700
view the slides on the web and the

00:00:46,270 --> 00:00:54,640
readme has just the links pulled out as

00:00:51,700 --> 00:00:56,200
sort of alluded to in the intro I'm the

00:00:54,640 --> 00:00:58,180
co-author of the rest programming

00:00:56,200 --> 00:01:01,059
language book which is available for

00:00:58,180 --> 00:01:04,989
free online and available in print from

00:01:01,059 --> 00:01:07,899
no starch press I'm also a co-author on

00:01:04,989 --> 00:01:09,759
a Manning live video series called

00:01:07,899 --> 00:01:13,180
rusted motion that's in early access

00:01:09,759 --> 00:01:17,650
right now and thanks to Manning I have

00:01:13,180 --> 00:01:19,990
three codes for free access to this rest

00:01:17,650 --> 00:01:22,450
in motion so the favorite my favorite

00:01:19,990 --> 00:01:24,729
three questions are going to get access

00:01:22,450 --> 00:01:31,689
to this so please ask wonderful

00:01:24,729 --> 00:01:36,880
questions on the slide slide Oh question

00:01:31,689 --> 00:01:39,400
asking platform I am also a co-founder

00:01:36,880 --> 00:01:44,680
of integer 32 the world's first rust

00:01:39,400 --> 00:01:48,009
consulting company and I am an organizer

00:01:44,680 --> 00:01:49,329
of rust belt rust a regional rust

00:01:48,009 --> 00:01:51,850
conference this year we're going to be

00:01:49,329 --> 00:01:56,380
in Dayton Ohio on October 18th and 19th

00:01:51,850 --> 00:01:58,840
and I'm on the rust core team so if you

00:01:56,380 --> 00:02:02,770
were hoping for an objective unbiased

00:01:58,840 --> 00:02:07,810
look at rust you're not gonna get that

00:02:02,770 --> 00:02:08,350
from this talk I clearly have a slant

00:02:07,810 --> 00:02:10,720
here

00:02:08,350 --> 00:02:13,090
I love rust so much that my favorite

00:02:10,720 --> 00:02:16,180
hockey player is two-time Stanley Cup

00:02:13,090 --> 00:02:18,340
winning champion Brian rust from the

00:02:16,180 --> 00:02:19,959
Pittsburgh Penguins and yes you may

00:02:18,340 --> 00:02:20,900
throw tomatoes at me or batteries or

00:02:19,959 --> 00:02:24,349
whatever it is

00:02:20,900 --> 00:02:26,950
that you do here in Philadelphia I could

00:02:24,349 --> 00:02:28,970
take it alright so in this talk today

00:02:26,950 --> 00:02:30,409
we're gonna talk a little bit about the

00:02:28,970 --> 00:02:32,840
railroad industry but you weren't

00:02:30,409 --> 00:02:35,060
expecting that but we are we're gonna

00:02:32,840 --> 00:02:37,610
talk about C we're gonna talk about rust

00:02:35,060 --> 00:02:39,709
and we're going to talk about what the

00:02:37,610 --> 00:02:43,640
software industry can learn from the

00:02:39,709 --> 00:02:46,819
railroad industry so a little railroad

00:02:43,640 --> 00:02:48,349
industry history commercial railroads in

00:02:46,819 --> 00:02:51,739
the United States started being built

00:02:48,349 --> 00:02:53,540
around 1830 and trains are really great

00:02:51,739 --> 00:02:55,700
they let you get across this huge

00:02:53,540 --> 00:02:58,940
country of ours a lot faster than things

00:02:55,700 --> 00:03:03,290
like stagecoaches and they really took

00:02:58,940 --> 00:03:06,190
off built lots of lines of Braille all

00:03:03,290 --> 00:03:08,720
around the country really fast but as

00:03:06,190 --> 00:03:12,319
the miles of rail and as the train trips

00:03:08,720 --> 00:03:15,650
grew injuries and deaths also grew it

00:03:12,319 --> 00:03:17,780
turns out that once you get a big train

00:03:15,650 --> 00:03:22,129
moving it's kind of hard to get it to

00:03:17,780 --> 00:03:23,989
stop again and there were lots of

00:03:22,129 --> 00:03:27,230
collisions there were lots of accidents

00:03:23,989 --> 00:03:29,739
and one of the most dangerous jobs on

00:03:27,230 --> 00:03:33,560
the railroads was that of the brake man

00:03:29,739 --> 00:03:37,549
because the way you used to have to get

00:03:33,560 --> 00:03:39,290
trains to stop is someone the engineer

00:03:37,549 --> 00:03:42,010
would blow a certain signal with the

00:03:39,290 --> 00:03:44,359
whistle that he wanted to stop and then

00:03:42,010 --> 00:03:47,540
people would have to go off on the top

00:03:44,359 --> 00:03:50,269
of each car and turn this wheel to put

00:03:47,540 --> 00:03:52,910
the brakes on and then move to the next

00:03:50,269 --> 00:03:55,699
car and eventually the train would

00:03:52,910 --> 00:03:58,579
slowly come to a stop as all the brakes

00:03:55,699 --> 00:04:03,349
were applied but this wasn't really an

00:03:58,579 --> 00:04:05,209
exact science so if at best case if this

00:04:03,349 --> 00:04:07,760
didn't go well you would miss the

00:04:05,209 --> 00:04:10,400
station you were trying to stop at worst

00:04:07,760 --> 00:04:12,500
case if you needed to stop in a hurry

00:04:10,400 --> 00:04:17,180
probably couldn't and you there were

00:04:12,500 --> 00:04:18,859
collisions and accidents and this job

00:04:17,180 --> 00:04:22,099
being on top of the train when it was

00:04:18,859 --> 00:04:24,740
rainy or icy it's pretty dangerous and a

00:04:22,099 --> 00:04:27,440
lot of brake men would fell to fall off

00:04:24,740 --> 00:04:33,020
the train and be killed this was a this

00:04:27,440 --> 00:04:34,400
is the thousands of brakeman died every

00:04:33,020 --> 00:04:36,530
year this is second only to

00:04:34,400 --> 00:04:39,460
mining as the most dangerous career in

00:04:36,530 --> 00:04:39,460
the eighteen hundred's

00:04:40,000 --> 00:04:48,190
enter George Westinghouse a an amazing

00:04:44,150 --> 00:04:53,120
Pittsburgher he invented lots of things

00:04:48,190 --> 00:04:56,900
was part of making electricity viable

00:04:53,120 --> 00:05:00,880
and and commercially available and in

00:04:56,900 --> 00:05:03,320
1869 he invented the first air brake

00:05:00,880 --> 00:05:05,000
there have been improvements made over

00:05:03,320 --> 00:05:08,120
the years but essentially his air brake

00:05:05,000 --> 00:05:10,789
is what trains use today the way air

00:05:08,120 --> 00:05:14,600
brakes work are that they're controlled

00:05:10,789 --> 00:05:18,020
by compressed air rather than a physical

00:05:14,600 --> 00:05:22,070
wheel on top the car there's a control

00:05:18,020 --> 00:05:24,199
up in front for the engineer to turn the

00:05:22,070 --> 00:05:28,669
brakes on and off so they don't have to

00:05:24,199 --> 00:05:32,000
use the whistle to communicate all the

00:05:28,669 --> 00:05:33,800
cars are connected so that when the

00:05:32,000 --> 00:05:36,400
engineer turns the brakes on all of the

00:05:33,800 --> 00:05:41,060
cars start breaking all the same time

00:05:36,400 --> 00:05:43,610
and a later failsafe was added so that

00:05:41,060 --> 00:05:46,400
when there isn't pressure to each car

00:05:43,610 --> 00:05:49,490
through this connection the brakes are

00:05:46,400 --> 00:05:50,960
on so that this is safe by default you

00:05:49,490 --> 00:05:53,330
would have to apply the pressure to turn

00:05:50,960 --> 00:05:54,830
the brakes off and get the car moving so

00:05:53,330 --> 00:05:57,110
if something if all the Scotch is

00:05:54,830 --> 00:06:01,030
connected the Train would would come to

00:05:57,110 --> 00:06:03,889
a stop instead of continuing to go and

00:06:01,030 --> 00:06:06,770
this system was a lot more complex than

00:06:03,889 --> 00:06:09,729
the hand brakes and there was some

00:06:06,770 --> 00:06:13,659
skepticism this was a quote from

00:06:09,729 --> 00:06:16,729
Vanderbilt who was the guy behind

00:06:13,659 --> 00:06:19,310
Vanderbilt University eventually but he

00:06:16,729 --> 00:06:22,940
he couldn't believe that that error was

00:06:19,310 --> 00:06:24,919
going to be what stops trains but they

00:06:22,940 --> 00:06:28,070
did a lot of public tests a lot of

00:06:24,919 --> 00:06:31,430
demonstrations that involved people

00:06:28,070 --> 00:06:33,320
riding in train cars with like pillows

00:06:31,430 --> 00:06:35,060
everywhere testing all these sorts of

00:06:33,320 --> 00:06:36,830
different kinds of brakes and like

00:06:35,060 --> 00:06:38,180
running into the wall is because when

00:06:36,830 --> 00:06:40,580
different kinds of brakes didn't work

00:06:38,180 --> 00:06:42,860
but the air brakes were passing all

00:06:40,580 --> 00:06:45,050
these public tests and there were a lot

00:06:42,860 --> 00:06:48,460
safer and a lot better at getting the

00:06:45,050 --> 00:06:51,740
trains to stop then the hand brakes were

00:06:48,460 --> 00:06:53,870
railroads are adopted these four

00:06:51,740 --> 00:06:56,300
passenger trains pretty quickly because

00:06:53,870 --> 00:06:59,530
consumers demanded it this is an

00:06:56,300 --> 00:07:03,229
advertisement for a particular train and

00:06:59,530 --> 00:07:04,610
the this yellow part here says that the

00:07:03,229 --> 00:07:06,470
Swift operation of these nightly

00:07:04,610 --> 00:07:08,630
carriers is safeguarded by Westinghouse

00:07:06,470 --> 00:07:12,590
air brakes so this is something that the

00:07:08,630 --> 00:07:13,940
market demanded that that they there

00:07:12,590 --> 00:07:15,470
were people who were scared to ride

00:07:13,940 --> 00:07:17,150
trains because they couldn't stop but

00:07:15,470 --> 00:07:18,319
these air brakes gave people the

00:07:17,150 --> 00:07:19,330
confidence that they could ride the

00:07:18,319 --> 00:07:22,880
train safely

00:07:19,330 --> 00:07:25,250
however on freight trains it took a lot

00:07:22,880 --> 00:07:30,620
longer for these air wrecks to be

00:07:25,250 --> 00:07:34,479
adopted and there was this person named

00:07:30,620 --> 00:07:37,039
coffin who was a big advocate for

00:07:34,479 --> 00:07:40,039
mandating these air brakes be used on

00:07:37,039 --> 00:07:42,560
all trains and he worked for the Iowa

00:07:40,039 --> 00:07:44,810
Railroad Commission and when he started

00:07:42,560 --> 00:07:47,560
he said that the people on the

00:07:44,810 --> 00:07:49,789
Commission just kind of thought that

00:07:47,560 --> 00:07:53,000
this was the way it was

00:07:49,789 --> 00:07:55,699
trains are dangerous and brakeman were

00:07:53,000 --> 00:07:57,470
going to die so there wasn't really much

00:07:55,699 --> 00:08:03,080
we could do that this is just how things

00:07:57,470 --> 00:08:05,570
were but he a coffin got kept getting

00:08:03,080 --> 00:08:08,659
all these reports about brakeman being

00:08:05,570 --> 00:08:09,979
killed and was like no this is these are

00:08:08,659 --> 00:08:12,590
all the same cause we have to do

00:08:09,979 --> 00:08:14,570
something about this so he did a lot of

00:08:12,590 --> 00:08:17,659
advocacy there's this there's

00:08:14,570 --> 00:08:19,550
transcripts of a Senate hearing for the

00:08:17,659 --> 00:08:22,250
run the Interstate Commerce Committee

00:08:19,550 --> 00:08:25,610
that I just find riveting I like reading

00:08:22,250 --> 00:08:28,880
these Senate transcripts from 1890 and

00:08:25,610 --> 00:08:31,490
they're amazing coffin had a lot to say

00:08:28,880 --> 00:08:35,390
in favor of mandating air brakes on all

00:08:31,490 --> 00:08:38,209
trains the industry people were didn't

00:08:35,390 --> 00:08:42,440
want to be regulated so they had a lot

00:08:38,209 --> 00:08:44,420
of interesting arguments they they

00:08:42,440 --> 00:08:47,180
didn't want to pay to add these air

00:08:44,420 --> 00:08:50,089
brakes to all their trains they thought

00:08:47,180 --> 00:08:53,779
that brakeman were kind of expendable

00:08:50,089 --> 00:08:55,880
and cheaper which is terrible they were

00:08:53,779 --> 00:08:58,760
like the air brakes are still gonna fail

00:08:55,880 --> 00:09:00,140
sometimes the like it doesn't matter the

00:08:58,760 --> 00:09:02,560
hand brakes fail the air brakes are also

00:09:00,140 --> 00:09:05,990
going to fail so why so why should we

00:09:02,560 --> 00:09:08,690
they simultaneously made two arguments

00:09:05,990 --> 00:09:10,670
they said we are already innovating

00:09:08,690 --> 00:09:12,080
without legislation we are testing new

00:09:10,670 --> 00:09:14,480
things all the time to improve the

00:09:12,080 --> 00:09:16,340
safety of the Train if you if you

00:09:14,480 --> 00:09:18,950
regulate that there's some minimum

00:09:16,340 --> 00:09:20,150
standard we're gonna adopt the thing

00:09:18,950 --> 00:09:22,130
that'll meet the law and we're gonna

00:09:20,150 --> 00:09:24,830
stop innovating so that was one argument

00:09:22,130 --> 00:09:29,360
in like the next breath this guy at so

00:09:24,830 --> 00:09:31,040
liberating testimony said and what if

00:09:29,360 --> 00:09:33,500
something better comes along and we've

00:09:31,040 --> 00:09:35,750
already have all this sunk costs into

00:09:33,500 --> 00:09:38,390
these air brakes it's like wait a second

00:09:35,750 --> 00:09:39,830
wait are you saying you're gonna keep

00:09:38,390 --> 00:09:41,630
innovating are you saying you're gonna

00:09:39,830 --> 00:09:43,610
stop innovating because now you're

00:09:41,630 --> 00:09:46,690
saying what we're gonna happen they

00:09:43,610 --> 00:09:49,160
really just didn't want to be regulated

00:09:46,690 --> 00:09:50,540
they said they have other means they

00:09:49,160 --> 00:09:52,850
have to pay for they can't possibly

00:09:50,540 --> 00:09:53,990
afford these they said you should have

00:09:52,850 --> 00:09:56,900
regulated this twenty five or thirty

00:09:53,990 --> 00:09:59,570
years ago all sorts of things my

00:09:56,900 --> 00:10:01,040
favorite my favorite objection from the

00:09:59,570 --> 00:10:03,770
president of the Pennsylvania Railroad

00:10:01,040 --> 00:10:05,690
Company was are you're gonna regulate

00:10:03,770 --> 00:10:09,200
the trains what's next are you gonna

00:10:05,690 --> 00:10:10,490
regulate the bridges it's like yes

00:10:09,200 --> 00:10:12,650
please

00:10:10,490 --> 00:10:19,220
we want the bridges to be safe too

00:10:12,650 --> 00:10:22,270
actually so yeah it turns out that the

00:10:19,220 --> 00:10:26,480
US railroad safety appliance Act passed

00:10:22,270 --> 00:10:29,210
Congress in 1893 mandated the use of air

00:10:26,480 --> 00:10:32,990
brakes and standard couplers to connect

00:10:29,210 --> 00:10:36,170
the trans together in 1900 it was fully

00:10:32,990 --> 00:10:38,270
enforced and all trains whether a

00:10:36,170 --> 00:10:40,220
passenger freight had to be using these

00:10:38,270 --> 00:10:44,510
safety devices and accidents and deaths

00:10:40,220 --> 00:10:45,650
of both people being run into both

00:10:44,510 --> 00:10:48,520
people and things being run into by

00:10:45,650 --> 00:10:52,790
trains and brakeman operating the trains

00:10:48,520 --> 00:10:56,950
went way down this helped a whole lot it

00:10:52,790 --> 00:10:59,840
wasn't perfect but it was way better

00:10:56,950 --> 00:11:02,710
okay that was your railroad history

00:10:59,840 --> 00:11:02,710
lesson

00:11:02,790 --> 00:11:09,580
so now we're gonna talk a little bit

00:11:04,630 --> 00:11:13,029
about C so why might companies choose C

00:11:09,580 --> 00:11:18,010
uh who-who works at a company who has Z

00:11:13,029 --> 00:11:21,519
code in production today okay yeah good

00:11:18,010 --> 00:11:23,500
all right you you might you probably

00:11:21,519 --> 00:11:26,740
have a variety reasons why you're doing

00:11:23,500 --> 00:11:29,920
that it's a proven solution that has

00:11:26,740 --> 00:11:31,839
worked for 40 years it's fast it has

00:11:29,920 --> 00:11:33,399
very little overhead it's kind of close

00:11:31,839 --> 00:11:37,500
to the Machine close to the assembly

00:11:33,399 --> 00:11:39,760
language it uses very little resources

00:11:37,500 --> 00:11:41,560
there's a C compiler to target just

00:11:39,760 --> 00:11:45,610
about any sort of platform you might

00:11:41,560 --> 00:11:47,860
want to run on the language is simple

00:11:45,610 --> 00:11:49,959
there's not a whole lot of syntax to

00:11:47,860 --> 00:11:52,360
learn I would argue that it's a little

00:11:49,959 --> 00:11:54,790
bit deceptively simple because there's a

00:11:52,360 --> 00:11:59,320
lot of interesting things that C code

00:11:54,790 --> 00:12:01,120
can do you might have a lot of existing

00:11:59,320 --> 00:12:04,510
C code or you might want to interface

00:12:01,120 --> 00:12:07,920
with existing C code that makes it easy

00:12:04,510 --> 00:12:10,630
means using C would make that easier and

00:12:07,920 --> 00:12:13,180
C doesn't really change a whole lot and

00:12:10,630 --> 00:12:16,779
enterprise software the field moves

00:12:13,180 --> 00:12:18,910
rather slowly and you don't want to have

00:12:16,779 --> 00:12:20,920
lots of parts changing out from

00:12:18,910 --> 00:12:25,779
underneath you and having your code

00:12:20,920 --> 00:12:28,000
become obsolete so but in order to get

00:12:25,779 --> 00:12:31,270
all these advantages you have to agree

00:12:28,000 --> 00:12:35,680
to what I see as a huge disadvantage

00:12:31,270 --> 00:12:39,130
that outweighs all of that is that C has

00:12:35,680 --> 00:12:42,550
all these memory safety problems it's

00:12:39,130 --> 00:12:46,209
not memory safe these problems include

00:12:42,550 --> 00:12:49,089
use after free double free memory leaks

00:12:46,209 --> 00:12:53,649
buffer over reads and over writes no

00:12:49,089 --> 00:12:56,980
pointers databases oh my this is just a

00:12:53,649 --> 00:13:01,480
lot of problems that you have to sign on

00:12:56,980 --> 00:13:03,880
to when you are shipping C in production

00:13:01,480 --> 00:13:05,980
and I'm sure those of you who have seen

00:13:03,880 --> 00:13:09,449
production can tell lots of stories

00:13:05,980 --> 00:13:14,260
about problems caused by all of these

00:13:09,449 --> 00:13:15,500
and a lot of people say well it's you

00:13:14,260 --> 00:13:17,720
just be more careful

00:13:15,500 --> 00:13:20,450
then we can avoid these problems it's

00:13:17,720 --> 00:13:22,760
not a matter of being more careful we're

00:13:20,450 --> 00:13:25,610
in it's the experience in past 40 years

00:13:22,760 --> 00:13:29,120
has shown we're not capable of being

00:13:25,610 --> 00:13:32,720
careful enough there is a vulnerability

00:13:29,120 --> 00:13:35,050
called stage fright in Android and this

00:13:32,720 --> 00:13:37,970
blog post was illustrating some C code

00:13:35,050 --> 00:13:41,390
to try and explain what the root cause

00:13:37,970 --> 00:13:42,590
of stage fright was and - he said you'd

00:13:41,390 --> 00:13:45,250
have to be more careful than the

00:13:42,590 --> 00:13:47,540
entirety of the Android security team

00:13:45,250 --> 00:13:50,390
every C developer shipping code

00:13:47,540 --> 00:13:54,350
impression has to be more careful than

00:13:50,390 --> 00:13:58,070
that there was a great presentation and

00:13:54,350 --> 00:14:01,640
the post about Microsoft did some

00:13:58,070 --> 00:14:05,150
studying of the problems that they had

00:14:01,640 --> 00:14:08,300
to do issue security updates for over

00:14:05,150 --> 00:14:11,050
the last 12 years about 70% of them were

00:14:08,300 --> 00:14:13,880
due to memory safety problems

00:14:11,050 --> 00:14:17,350
we're being you'd have to be more

00:14:13,880 --> 00:14:19,940
careful than the Microsoft security team

00:14:17,350 --> 00:14:22,880
there have been some efforts to make C

00:14:19,940 --> 00:14:26,050
safer there are tools like valgrind

00:14:22,880 --> 00:14:29,270
there's tools like address sanitizer

00:14:26,050 --> 00:14:31,850
undefined behavior sanitizers I found

00:14:29,270 --> 00:14:34,690
this tool called IKOS that does abstract

00:14:31,850 --> 00:14:37,930
interpretation as a static static

00:14:34,690 --> 00:14:40,190
analysis it's from NASA so you'd have

00:14:37,930 --> 00:14:44,900
passive has a really rigorous

00:14:40,190 --> 00:14:47,900
engineering discipline so if that's the

00:14:44,900 --> 00:14:49,760
kind of investment you want to make you

00:14:47,900 --> 00:14:53,210
can check out tools like that there are

00:14:49,760 --> 00:14:57,050
the misra guidelines all of these kind

00:14:53,210 --> 00:14:58,490
of strike me as things you do after the

00:14:57,050 --> 00:15:03,530
fact you write the code first and then

00:14:58,490 --> 00:15:05,120
you try and make it safe which you have

00:15:03,530 --> 00:15:06,890
to make sure you do those things you

00:15:05,120 --> 00:15:08,030
can't forever forget you have to build

00:15:06,890 --> 00:15:09,530
them in the processes you have to

00:15:08,030 --> 00:15:13,010
allocate time to do that and fix the

00:15:09,530 --> 00:15:17,030
problems you find it seems like kind of

00:15:13,010 --> 00:15:22,120
patching it after the fact there are

00:15:17,030 --> 00:15:22,120
some varieties of C people are creating

00:15:22,660 --> 00:15:28,790
none of these have really caught on much

00:15:26,180 --> 00:15:32,000
you're still writing C that has

00:15:28,790 --> 00:15:33,530
very little abstractions you have to

00:15:32,000 --> 00:15:35,360
reinvent the wheel all the time you

00:15:33,530 --> 00:15:37,280
don't have modern tools that go with it

00:15:35,360 --> 00:15:40,900
and if you're gonna be switching

00:15:37,280 --> 00:15:44,180
languages anyway I advocate that you

00:15:40,900 --> 00:15:47,090
look at all your options and of course

00:15:44,180 --> 00:15:49,370
they're C++ which improves some things

00:15:47,090 --> 00:15:51,830
by not everything there's still a lot of

00:15:49,370 --> 00:15:56,140
undefined behavior there's still a lot

00:15:51,830 --> 00:15:57,950
of pointer problems you can get into

00:15:56,140 --> 00:16:04,040
multi-threaded programming is still a

00:15:57,950 --> 00:16:08,180
big problem in C++ so what can we do

00:16:04,040 --> 00:16:14,720
about this and that brings us to the

00:16:08,180 --> 00:16:18,020
Russ part so Russ is a language out of

00:16:14,720 --> 00:16:20,150
Mozilla research it's trying to learn

00:16:18,020 --> 00:16:22,780
from the mistakes of C and bring in

00:16:20,150 --> 00:16:26,270
ideas from a bunch of other languages

00:16:22,780 --> 00:16:28,910
too I see it as moving our industry

00:16:26,270 --> 00:16:32,060
forward and trying not to repeat the

00:16:28,910 --> 00:16:35,870
same mistakes over and over again I have

00:16:32,060 --> 00:16:41,240
five reasons why I think Russ is ready

00:16:35,870 --> 00:16:44,420
to last as long as C has the first

00:16:41,240 --> 00:16:47,570
reason is that it fixes these memory

00:16:44,420 --> 00:16:51,500
safety problems it's it's an improvement

00:16:47,570 --> 00:16:56,000
upon the status quo it does this through

00:16:51,500 --> 00:16:58,370
a system of ownership and borrowing and

00:16:56,000 --> 00:17:01,160
I'm going to show some examples of how

00:16:58,370 --> 00:17:05,360
this works this is some rest code it's a

00:17:01,160 --> 00:17:08,390
main function that creates a string on

00:17:05,360 --> 00:17:12,380
the heap that we can grow and change in

00:17:08,390 --> 00:17:16,100
size the owner of that memory is this

00:17:12,380 --> 00:17:19,220
variable X and when that owner goes out

00:17:16,100 --> 00:17:22,550
of scope that's when the heap memory it

00:17:19,220 --> 00:17:24,740
gets cleaned up automatically rust kind

00:17:22,550 --> 00:17:26,870
of inserts a looks at this code I was

00:17:24,740 --> 00:17:30,410
compiling inserts a statement at compile

00:17:26,870 --> 00:17:34,210
time that at the end of main that cleans

00:17:30,410 --> 00:17:38,780
up that memory so we don't have to write

00:17:34,210 --> 00:17:40,280
free free the memory that X manually but

00:17:38,780 --> 00:17:41,880
there's also not a garbage collector

00:17:40,280 --> 00:17:45,360
running at runtime this is all

00:17:41,880 --> 00:17:47,040
compile-time this is another example in

00:17:45,360 --> 00:17:51,540
this example we've got the same string

00:17:47,040 --> 00:17:56,880
in X then we say let y equals 2x and we

00:17:51,540 --> 00:18:00,650
try to print out X this line here moves

00:17:56,880 --> 00:18:05,730
ownership of the string from X to Y and

00:18:00,650 --> 00:18:09,030
this code does not compile because we're

00:18:05,730 --> 00:18:12,360
trying to use X again after we've moved

00:18:09,030 --> 00:18:16,560
it into y so we see this data still only

00:18:12,360 --> 00:18:19,410
has one owner after that point we've

00:18:16,560 --> 00:18:22,230
moved it into y Y we'll clean that up

00:18:19,410 --> 00:18:24,060
and X note is no longer valid and we're

00:18:22,230 --> 00:18:26,550
no longer allowed to use it after we've

00:18:24,060 --> 00:18:30,380
moved it so we don't have double three

00:18:26,550 --> 00:18:30,380
problems and we can't use after free

00:18:30,710 --> 00:18:39,090
this code instead of moving ownership

00:18:34,460 --> 00:18:42,660
this borrows Y is a an immutable borrow

00:18:39,090 --> 00:18:45,780
of X it's allowed to read the the data

00:18:42,660 --> 00:18:47,790
that X owns but X is still responsible

00:18:45,780 --> 00:18:50,490
for cleaning up the memory at the end of

00:18:47,790 --> 00:18:53,790
the function and this code compiles and

00:18:50,490 --> 00:19:00,330
we're allowed to read using either X or

00:18:53,790 --> 00:19:03,870
Y in this example we are trying to

00:19:00,330 --> 00:19:07,320
create a dangling pointer we have an

00:19:03,870 --> 00:19:10,590
inner scope and we're trying to return a

00:19:07,320 --> 00:19:14,940
reference to heap data from that inner

00:19:10,590 --> 00:19:16,770
scope the problem is that the way rust

00:19:14,940 --> 00:19:18,330
ownership works X is going to get

00:19:16,770 --> 00:19:21,470
cleaned up at the end of that inner

00:19:18,330 --> 00:19:24,660
scope so this code doesn't compile

00:19:21,470 --> 00:19:26,550
because we're trying to use the

00:19:24,660 --> 00:19:28,680
reference after that data has been

00:19:26,550 --> 00:19:32,970
cleaned up and rust can see that at

00:19:28,680 --> 00:19:39,420
compile time and doesn't let us run this

00:19:32,970 --> 00:19:41,820
code because X gets cleaned up rust has

00:19:39,420 --> 00:19:44,790
a lot of other safety mechanisms that I

00:19:41,820 --> 00:19:46,800
don't have time to get into fully one of

00:19:44,790 --> 00:19:51,170
the rules about references is that you

00:19:46,800 --> 00:19:56,019
can have either one mutable changeable

00:19:51,170 --> 00:19:59,139
reference at a time or you can have many

00:19:56,019 --> 00:20:03,070
immutable references for reading at one

00:19:59,139 --> 00:20:05,799
time so this prevents databases so that

00:20:03,070 --> 00:20:09,669
you can't change a value while someone

00:20:05,799 --> 00:20:14,039
else is trying to read it there are no

00:20:09,669 --> 00:20:17,350
no pointers there's the option type that

00:20:14,039 --> 00:20:20,559
represents either something and holds a

00:20:17,350 --> 00:20:23,499
value or there's none the none value and

00:20:20,559 --> 00:20:28,690
the compiler makes sure you handle both

00:20:23,499 --> 00:20:31,570
some or none at compile time out of

00:20:28,690 --> 00:20:34,690
balance array axises or data structure

00:20:31,570 --> 00:20:36,429
accesses at run time it just stops the

00:20:34,690 --> 00:20:39,159
program immediately and doesn't let you

00:20:36,429 --> 00:20:42,429
continue with invalid data that isn't

00:20:39,159 --> 00:20:44,470
part of your data structure the

00:20:42,429 --> 00:20:46,149
ownership rules apply across multiple

00:20:44,470 --> 00:20:49,509
threads there's parts of the type system

00:20:46,149 --> 00:20:52,239
that allow you to express transferring

00:20:49,509 --> 00:20:52,720
ownership or borrowing across multiple

00:20:52,239 --> 00:20:56,409
threads

00:20:52,720 --> 00:20:59,619
so now programming parallel or

00:20:56,409 --> 00:21:01,330
concurrent programs is is checked at

00:20:59,619 --> 00:21:06,070
compile time that you don't have data

00:21:01,330 --> 00:21:07,899
races across threads Jessica this

00:21:06,070 --> 00:21:10,529
morning said a neat word that I hadn't

00:21:07,899 --> 00:21:13,960
heard before which is the person bite

00:21:10,529 --> 00:21:17,649
it's what you can keep in your head all

00:21:13,960 --> 00:21:19,929
at one time and trying to keep all these

00:21:17,649 --> 00:21:22,179
rules and keep make sure you're doing

00:21:19,929 --> 00:21:27,009
all these things right in your head with

00:21:22,179 --> 00:21:29,859
C is really tedious and as we've seen is

00:21:27,009 --> 00:21:31,809
error-prone it's it's too much for one

00:21:29,859 --> 00:21:37,090
person to hold your head in addition to

00:21:31,809 --> 00:21:39,279
your problem domain is and but there's

00:21:37,090 --> 00:21:41,529
someone who's really good at keeping

00:21:39,279 --> 00:21:42,700
track of tedious things and making sure

00:21:41,529 --> 00:21:47,070
that they're right every single time

00:21:42,700 --> 00:21:49,509
it's our computers so I see rust as

00:21:47,070 --> 00:21:53,019
making the computer take care of all

00:21:49,509 --> 00:21:55,570
that tedious tracking of whether the

00:21:53,019 --> 00:21:57,249
memory accesses are right or not and I

00:21:55,570 --> 00:21:58,509
can forget about that the compilers

00:21:57,249 --> 00:22:00,639
gonna tell me when I get it wrong and I

00:21:58,509 --> 00:22:03,820
have to go fix that yeah but if my comm

00:22:00,639 --> 00:22:07,359
compiles I I don't have to worry that I

00:22:03,820 --> 00:22:09,160
that I missed someplace and I can just

00:22:07,359 --> 00:22:12,160
concentrate on my domain

00:22:09,160 --> 00:22:15,430
and this is the second reason I think

00:22:12,160 --> 00:22:18,040
Russ is is going to continue to grow and

00:22:15,430 --> 00:22:20,170
to last for the next 40 years is that

00:22:18,040 --> 00:22:22,660
this makes love level assistance

00:22:20,170 --> 00:22:24,940
programming code something that everyone

00:22:22,660 --> 00:22:27,490
is capable of doing not people who have

00:22:24,940 --> 00:22:29,860
extremely large person bite capabilities

00:22:27,490 --> 00:22:34,120
to hold all this memory access in their

00:22:29,860 --> 00:22:36,220
head as well as the domain which I'm not

00:22:34,120 --> 00:22:38,350
sure that anyone actually exists because

00:22:36,220 --> 00:22:41,950
of the problems we see but more people

00:22:38,350 --> 00:22:45,940
can program safe systems level code with

00:22:41,950 --> 00:22:49,240
rust I do have a caveat there is an

00:22:45,940 --> 00:22:52,210
escape hatch it's the unsafe keyword it

00:22:49,240 --> 00:22:55,060
lets you opt-out of not all of Russ

00:22:52,210 --> 00:23:00,010
safety checks it lets you do a few very

00:22:55,060 --> 00:23:01,650
specific things e and by putting unsafe

00:23:00,010 --> 00:23:07,030
around some of your code you're saying

00:23:01,650 --> 00:23:09,310
okay compiler I understand that you

00:23:07,030 --> 00:23:12,610
can't ensure that this code is going to

00:23:09,310 --> 00:23:14,620
be safe every single time I as a person

00:23:12,610 --> 00:23:16,720
I'm going to audit this specific code

00:23:14,620 --> 00:23:21,730
and I will make sure that I'm following

00:23:16,720 --> 00:23:24,960
the Murray rules and this is useful in

00:23:21,730 --> 00:23:28,420
certain performance cases when you're

00:23:24,960 --> 00:23:30,250
trying to express certain pointer

00:23:28,420 --> 00:23:31,900
arithmetic when you're trying to call to

00:23:30,250 --> 00:23:34,930
external code that the compiler can't

00:23:31,900 --> 00:23:36,400
possibly know anything about so as and

00:23:34,930 --> 00:23:39,970
as long as you don't put your entire

00:23:36,400 --> 00:23:43,200
program in an unsafe block what I like

00:23:39,970 --> 00:23:46,570
about this is that when if you have a

00:23:43,200 --> 00:23:48,880
seg fault or memory access problem at

00:23:46,570 --> 00:23:50,920
runtime you know it came from one of

00:23:48,880 --> 00:23:53,260
those unsafe blocks it's like hey look

00:23:50,920 --> 00:23:55,090
over here this is probably where the

00:23:53,260 --> 00:23:56,950
memory problem came from because the

00:23:55,090 --> 00:23:59,290
compiler didn't check this part so

00:23:56,950 --> 00:24:02,170
you've you've lessened the places you

00:23:59,290 --> 00:24:09,010
have to look to debug to figure out

00:24:02,170 --> 00:24:11,440
those problems I also think that this

00:24:09,010 --> 00:24:13,390
this unsafe keyword doesn't invalidate

00:24:11,440 --> 00:24:15,580
things because this is this is opting

00:24:13,390 --> 00:24:21,010
out of the safety checks rather than

00:24:15,580 --> 00:24:22,900
opting into them so as opposed to the

00:24:21,010 --> 00:24:25,300
the sanitizers that you have to

00:24:22,900 --> 00:24:30,640
remember to run after all the changes to

00:24:25,300 --> 00:24:33,190
your code this is this is the default is

00:24:30,640 --> 00:24:36,850
too bright safe code and you can opt out

00:24:33,190 --> 00:24:39,630
of it if you need to if you want more

00:24:36,850 --> 00:24:42,790
information on writing unsafe code

00:24:39,630 --> 00:24:44,440
there's this great talk for building an

00:24:42,790 --> 00:24:46,660
unsafe foundation the other neat thing

00:24:44,440 --> 00:24:49,600
is you can build safe abstractions out

00:24:46,660 --> 00:24:54,030
of unsafe code and there's a whole book

00:24:49,600 --> 00:24:54,030
on unsafe code called the Resta nomicon

00:24:56,940 --> 00:25:04,330
like air breaks sometimes don't stop a

00:25:00,220 --> 00:25:07,000
train rust doesn't prevent all problems

00:25:04,330 --> 00:25:09,610
you might have a software it does not

00:25:07,000 --> 00:25:12,040
prevent you from having logic bugs it

00:25:09,610 --> 00:25:13,660
can't tell that you meant to tell the

00:25:12,040 --> 00:25:15,610
program to do one thing and it's

00:25:13,660 --> 00:25:18,040
actually doing another so you stole the

00:25:15,610 --> 00:25:22,180
need things like tests and you still

00:25:18,040 --> 00:25:24,610
need to write things like buzzers but by

00:25:22,180 --> 00:25:27,220
choosing to use rust you're getting

00:25:24,610 --> 00:25:30,970
memory safety you're not going to have

00:25:27,220 --> 00:25:33,070
all those problems that C has so let's

00:25:30,970 --> 00:25:35,410
go back through the reasons that you

00:25:33,070 --> 00:25:36,790
might choose C and C what we're trading

00:25:35,410 --> 00:25:40,300
off because there's always trade-offs

00:25:36,790 --> 00:25:44,250
and in any sort of decision you might

00:25:40,300 --> 00:25:47,490
make performance Russ is on the order of

00:25:44,250 --> 00:25:49,710
C's performance there aren't the the

00:25:47,490 --> 00:25:51,820
additional checks that Russ does are

00:25:49,710 --> 00:25:54,280
mostly at compile time

00:25:51,820 --> 00:25:57,490
there isn't a garbage collector it isn't

00:25:54,280 --> 00:26:01,330
checking much at run time you can still

00:25:57,490 --> 00:26:03,100
get we have the goal of having zero cost

00:26:01,330 --> 00:26:06,430
abstractions which means that the

00:26:03,100 --> 00:26:08,920
abstractions you use our compiled down

00:26:06,430 --> 00:26:11,430
to code that you could not write better

00:26:08,920 --> 00:26:14,590
by hand of course there are always

00:26:11,430 --> 00:26:16,030
things we can improve on but zero cost

00:26:14,590 --> 00:26:18,940
abstractions are what we're aiming for

00:26:16,030 --> 00:26:21,760
we're hoping that rust will perform as

00:26:18,940 --> 00:26:25,210
well as C in the situations you want to

00:26:21,760 --> 00:26:29,260
use it portability

00:26:25,210 --> 00:26:32,470
Russ compiles to LVM intermediate

00:26:29,260 --> 00:26:34,450
representation so you can write rust and

00:26:32,470 --> 00:26:36,430
compile it for any platform that ll be

00:26:34,450 --> 00:26:38,680
I'm Ken

00:26:36,430 --> 00:26:41,740
there are C compilers that target

00:26:38,680 --> 00:26:44,740
platforms that LVM doesn't there could

00:26:41,740 --> 00:26:47,380
be a non LOV M back-end for us there

00:26:44,740 --> 00:26:49,000
isn't one yet there isn't I reason that

00:26:47,380 --> 00:26:52,420
why there couldn't be other than people

00:26:49,000 --> 00:26:54,940
putting in the work so if you need to

00:26:52,420 --> 00:26:56,920
write code for one of the platforms that

00:26:54,940 --> 00:27:00,040
Russ doesn't support that could be a

00:26:56,920 --> 00:27:03,430
deal-breaker for you but we do support a

00:27:00,040 --> 00:27:07,270
lot of platforms so this one is a little

00:27:03,430 --> 00:27:10,540
bit of both the big downside is rust is

00:27:07,270 --> 00:27:14,370
more complex and we are trying all the

00:27:10,540 --> 00:27:17,320
time to lessen the learning curve

00:27:14,370 --> 00:27:20,020
through books and video courses and and

00:27:17,320 --> 00:27:22,300
various learning materials there's

00:27:20,020 --> 00:27:26,500
definitely more features and syntax and

00:27:22,300 --> 00:27:29,050
C but we're trying to express complex

00:27:26,500 --> 00:27:32,170
ideas such that the compiler can

00:27:29,050 --> 00:27:36,610
understand them and that that does take

00:27:32,170 --> 00:27:41,080
more syntax and more complexity to

00:27:36,610 --> 00:27:43,120
express if you have legacy code a neat

00:27:41,080 --> 00:27:46,120
thing is that you can write extern

00:27:43,120 --> 00:27:49,360
functions that let you call C from rust

00:27:46,120 --> 00:27:51,730
and rust from C and a lot of languages

00:27:49,360 --> 00:27:56,290
also have a way to interface with C so

00:27:51,730 --> 00:27:59,730
you can use that so to say call rust

00:27:56,290 --> 00:28:03,820
from Python or call Ruby from rust I

00:27:59,730 --> 00:28:06,820
actually have a whole talk on porting a

00:28:03,820 --> 00:28:09,070
library the softly compression library

00:28:06,820 --> 00:28:10,120
that was written C porting it to rust

00:28:09,070 --> 00:28:12,400
function by function

00:28:10,120 --> 00:28:16,540
keeping it compiling and passing tests

00:28:12,400 --> 00:28:18,820
at every commit and the thing I like

00:28:16,540 --> 00:28:20,860
about this technique is that you don't

00:28:18,820 --> 00:28:22,330
even have to finish you don't have to

00:28:20,860 --> 00:28:25,600
convert the whole thing to rest to see

00:28:22,330 --> 00:28:28,210
benefit you could convert just the parts

00:28:25,600 --> 00:28:31,510
that change the most the parts that

00:28:28,210 --> 00:28:33,490
happen most bugs and you could set it

00:28:31,510 --> 00:28:35,800
aside for a while if you have other high

00:28:33,490 --> 00:28:37,630
priority things to work on but you still

00:28:35,800 --> 00:28:40,720
get those benefits along the way of

00:28:37,630 --> 00:28:43,270
converting little pieces to rust so you

00:28:40,720 --> 00:28:47,170
don't have to rewrite all of your stuff

00:28:43,270 --> 00:28:48,270
in rust to see benefits stability is one

00:28:47,170 --> 00:28:50,080
I want to spend a little more time on

00:28:48,270 --> 00:28:52,179
there is a new

00:28:50,080 --> 00:28:55,630
version of rust that comes out every six

00:28:52,179 --> 00:28:58,929
weeks we have a train really small sort

00:28:55,630 --> 00:29:00,940
of like Firefox and Chrome do so you

00:28:58,929 --> 00:29:02,850
might think that Russ is really unstable

00:29:00,940 --> 00:29:05,260
and it's gonna change all the time but

00:29:02,850 --> 00:29:07,090
we have really strong backwards

00:29:05,260 --> 00:29:11,320
compatibility guarantees we've committed

00:29:07,090 --> 00:29:14,140
to rust 100 came out in May 2015 so

00:29:11,320 --> 00:29:17,049
we've been stable and shipping stable

00:29:14,140 --> 00:29:21,039
codes every six weeks since then there

00:29:17,049 --> 00:29:22,570
is we do have a little bit of an out

00:29:21,039 --> 00:29:24,100
we've given ourselves we reserve the

00:29:22,570 --> 00:29:25,510
right to fixing piler bugs patch safety

00:29:24,100 --> 00:29:26,889
holes and change type in France in ways

00:29:25,510 --> 00:29:29,049
that occasionally require a new type of

00:29:26,889 --> 00:29:30,100
annotations we do not expect any of

00:29:29,049 --> 00:29:32,350
these changes cause headaches when

00:29:30,100 --> 00:29:35,919
upgrading rust so we can fix our own

00:29:32,350 --> 00:29:38,440
bugs in practice what this is meant we

00:29:35,919 --> 00:29:41,679
we run a survey every year in the 2018

00:29:38,440 --> 00:29:44,320
survey we had a question that said has

00:29:41,679 --> 00:29:46,240
upgrading broken your code and ninety

00:29:44,320 --> 00:29:50,919
two point six percent of people have

00:29:46,240 --> 00:29:52,659
said no it has not broken your code this

00:29:50,919 --> 00:29:53,769
question I feel like we need to change

00:29:52,659 --> 00:29:56,580
the wording of it a little bit because

00:29:53,769 --> 00:30:00,100
it doesn't really distinguish between

00:29:56,580 --> 00:30:01,809
breaking compilation which is what our

00:30:00,100 --> 00:30:05,159
stability guarantees are really about

00:30:01,809 --> 00:30:07,990
versus breaking runtime behavior or

00:30:05,159 --> 00:30:10,149
slowing down your code at runtime or

00:30:07,990 --> 00:30:13,809
speeding it up you don't you broken it

00:30:10,149 --> 00:30:15,519
in that way and I'd like to I'd like to

00:30:13,809 --> 00:30:16,960
be able to get into those problems a

00:30:15,519 --> 00:30:19,919
little bit more and see how we're really

00:30:16,960 --> 00:30:25,960
doing on our compiled time

00:30:19,919 --> 00:30:28,889
stability guarantees another part that I

00:30:25,960 --> 00:30:32,500
think part of our stability story that

00:30:28,889 --> 00:30:35,289
will let us last for 40 years is that we

00:30:32,500 --> 00:30:38,620
have a goal of stability without

00:30:35,289 --> 00:30:41,649
stagnation we want to be able to evolve

00:30:38,620 --> 00:30:43,929
rust to learn from our own mistakes to

00:30:41,649 --> 00:30:46,600
make the language easier to use and to

00:30:43,929 --> 00:30:49,139
learn while still not breaking our

00:30:46,600 --> 00:30:53,049
backwards compatibility guarantees and

00:30:49,139 --> 00:30:56,610
the mechanism that rust we've designed

00:30:53,049 --> 00:30:59,799
to use in rust is called additions and

00:30:56,610 --> 00:31:02,110
this is a link to a detailed

00:30:59,799 --> 00:31:03,800
specification of what additions are I'm

00:31:02,110 --> 00:31:09,140
gonna go over the hi love

00:31:03,800 --> 00:31:10,700
idea mainly they are opt-in about every

00:31:09,140 --> 00:31:14,390
three years is what we're thinking we've

00:31:10,700 --> 00:31:17,450
just made Russ 2018 edition and the

00:31:14,390 --> 00:31:19,610
original edition of Russ is 2015 so we

00:31:17,450 --> 00:31:24,740
have two editions right now what they

00:31:19,610 --> 00:31:26,090
are is it the biggest the biggest change

00:31:24,740 --> 00:31:28,490
we want to make that's not backwards

00:31:26,090 --> 00:31:30,710
compatible is adding new keywords for

00:31:28,490 --> 00:31:33,290
adding new features so for instance

00:31:30,710 --> 00:31:37,550
we're going to be adding asynchronous

00:31:33,290 --> 00:31:39,890
functions to Russ the language soon and

00:31:37,550 --> 00:31:42,620
we wanted the async keyword to be able

00:31:39,890 --> 00:31:45,290
to do that but your existing code might

00:31:42,620 --> 00:31:47,480
have function async so if we added that

00:31:45,290 --> 00:31:51,050
of the keyword your function would no

00:31:47,480 --> 00:31:54,980
longer be a valid bus function so we

00:31:51,050 --> 00:31:57,860
added this idea of additions so that if

00:31:54,980 --> 00:32:01,130
you opt in to treating your code as Russ

00:31:57,860 --> 00:32:03,740
28:18 edition code then async would be a

00:32:01,130 --> 00:32:07,190
keyword but if you did nothing to your

00:32:03,740 --> 00:32:09,710
code upgraded your compiler it would

00:32:07,190 --> 00:32:12,410
still treat it as rust 2015 edition code

00:32:09,710 --> 00:32:16,850
and it would continue to treat async as

00:32:12,410 --> 00:32:19,010
not a keyword and can you could compile

00:32:16,850 --> 00:32:21,350
your code when I first heard of this

00:32:19,010 --> 00:32:22,910
idea I thought it sounded terrible from

00:32:21,350 --> 00:32:26,000
a compiler maintenance point of view you

00:32:22,910 --> 00:32:28,270
have to maintain two ways to use every

00:32:26,000 --> 00:32:31,550
feature forever because we wanted to

00:32:28,270 --> 00:32:35,200
commit to all editions being supported

00:32:31,550 --> 00:32:38,150
forever but it's actually not that bad

00:32:35,200 --> 00:32:40,420
the way editions way the compiler works

00:32:38,150 --> 00:32:43,310
today is you have your Russ source code

00:32:40,420 --> 00:32:46,280
the compiler turns it into a high level

00:32:43,310 --> 00:32:48,610
intermediate representation and then

00:32:46,280 --> 00:32:52,910
turns it into mid level intermediate

00:32:48,610 --> 00:32:55,610
representation then turns it into LLVM

00:32:52,910 --> 00:32:58,670
intermediate representation and LLVM

00:32:55,610 --> 00:33:01,040
turns it into machine code a lot of the

00:32:58,670 --> 00:33:03,170
complex analysis that the compiler does

00:33:01,040 --> 00:33:05,630
such as borrow checking optimizations

00:33:03,170 --> 00:33:07,550
and code generation happen at this

00:33:05,630 --> 00:33:11,120
mirror this mid level intermediate

00:33:07,550 --> 00:33:14,120
representation level the way additions

00:33:11,120 --> 00:33:17,150
have been implemented is that they're

00:33:14,120 --> 00:33:18,830
kind of at the surface level they

00:33:17,150 --> 00:33:21,320
affect the code the source code that

00:33:18,830 --> 00:33:24,050
you'll write and they affect the high

00:33:21,320 --> 00:33:25,730
level intermediate representation but

00:33:24,050 --> 00:33:29,030
once you get to the mid level

00:33:25,730 --> 00:33:31,280
representation it the mid level stuff is

00:33:29,030 --> 00:33:35,450
all the same whether it would no matter

00:33:31,280 --> 00:33:37,640
which Edition you came from so all this

00:33:35,450 --> 00:33:40,250
complex analysis code can stay the same

00:33:37,640 --> 00:33:44,390
for both editions and it's only the the

00:33:40,250 --> 00:33:51,679
first part of this conversion that is an

00:33:44,390 --> 00:33:56,000
a maintenance burden this because -

00:33:51,679 --> 00:33:58,580
because the compiler understands both

00:33:56,000 --> 00:34:02,780
editions and multiple editions once we

00:33:58,580 --> 00:34:05,780
have more and can compile 2015 code or

00:34:02,780 --> 00:34:09,590
2018 code that means we're not going to

00:34:05,780 --> 00:34:12,620
have an ecosystem split Russ Russ 2015

00:34:09,590 --> 00:34:17,179
project can depend on a project written

00:34:12,620 --> 00:34:19,220
using Russ 2018 idioms and vice versa so

00:34:17,179 --> 00:34:21,649
it doesn't matter if all your

00:34:19,220 --> 00:34:24,530
dependencies have opted in or not the

00:34:21,649 --> 00:34:29,419
same compiler can understand either code

00:34:24,530 --> 00:34:31,520
and can compile it all together and the

00:34:29,419 --> 00:34:34,129
important things about this is that you

00:34:31,520 --> 00:34:36,500
get to pick when you decide to change

00:34:34,129 --> 00:34:38,419
which Edition you want to use you can

00:34:36,500 --> 00:34:41,149
keep upgrading your compiler every six

00:34:38,419 --> 00:34:43,280
weeks but you don't have to switch on

00:34:41,149 --> 00:34:46,190
that flag to change the idioms until you

00:34:43,280 --> 00:34:49,280
decide the benefits outweigh the cost of

00:34:46,190 --> 00:34:53,780
upgrading and never is a totally valid

00:34:49,280 --> 00:34:57,580
choice we plan to support Russ 28 2015

00:34:53,780 --> 00:35:01,700
edition code for as long as rust exists

00:34:57,580 --> 00:35:03,890
in order to decrease the burden of

00:35:01,700 --> 00:35:06,760
switching editions we also have a tool

00:35:03,890 --> 00:35:10,520
call it Russ fix that for as many

00:35:06,760 --> 00:35:13,220
changes that we can do automatically it

00:35:10,520 --> 00:35:14,750
will apply those changes and fix up your

00:35:13,220 --> 00:35:17,120
code and move you to the new edition

00:35:14,750 --> 00:35:18,470
automatically so we're trying to if you

00:35:17,120 --> 00:35:20,480
do want to switch to the new edition

00:35:18,470 --> 00:35:25,760
we're trying to make that as painless as

00:35:20,480 --> 00:35:28,790
possible also the editions concept I am

00:35:25,760 --> 00:35:30,410
confident that with using this to evolve

00:35:28,790 --> 00:35:30,850
the language means we're never going to

00:35:30,410 --> 00:35:33,060
have

00:35:30,850 --> 00:35:34,270
rust you oh we're not going to break

00:35:33,060 --> 00:35:39,460
backwards-compatibility

00:35:34,270 --> 00:35:43,540
so we hope to be as stable as c is for

00:35:39,460 --> 00:35:45,370
the next four years we do have a lot of

00:35:43,540 --> 00:35:47,620
things that aren't done yet with rust

00:35:45,370 --> 00:35:50,310
that might prevent you from using it in

00:35:47,620 --> 00:35:53,320
your company we don't have a standard

00:35:50,310 --> 00:35:55,420
that's going to take a long time and a

00:35:53,320 --> 00:35:57,670
lot of work we do want to get there

00:35:55,420 --> 00:36:00,880
someday but it was years and years

00:35:57,670 --> 00:36:03,460
before C has a standard so we do want to

00:36:00,880 --> 00:36:04,930
get there but we're not there yet we

00:36:03,460 --> 00:36:08,350
don't have a certified compiler that

00:36:04,930 --> 00:36:10,300
will matter in some industries we do

00:36:08,350 --> 00:36:13,960
want to have a long term support release

00:36:10,300 --> 00:36:16,060
that gets things like security fixes and

00:36:13,960 --> 00:36:17,950
certain bug fixes we don't have a policy

00:36:16,060 --> 00:36:21,760
for that yet

00:36:17,950 --> 00:36:24,070
cargo is the build tool that rust kind

00:36:21,760 --> 00:36:27,010
of expects you to use if you you don't

00:36:24,070 --> 00:36:28,660
use that it gets a little hard to tinker

00:36:27,010 --> 00:36:31,030
with and some companies have build

00:36:28,660 --> 00:36:35,500
systems that everything needs to feed

00:36:31,030 --> 00:36:39,610
into and we have work to do to make

00:36:35,500 --> 00:36:43,120
cargo fit into build systems that are if

00:36:39,610 --> 00:36:45,640
you have we have an open-source package

00:36:43,120 --> 00:36:48,490
registry for open source code we don't

00:36:45,640 --> 00:36:50,260
have good solutions for libraries that

00:36:48,490 --> 00:36:53,530
you might want to keep private only

00:36:50,260 --> 00:36:55,270
share within your company and the

00:36:53,530 --> 00:36:57,670
ecosystem is still growing

00:36:55,270 --> 00:36:59,410
so there might not be a library for

00:36:57,670 --> 00:37:02,410
everything you might want to do in rust

00:36:59,410 --> 00:37:05,850
yet but these are all things we're

00:37:02,410 --> 00:37:08,170
working on and we hope to get there soon

00:37:05,850 --> 00:37:12,280
another reason I think we're going to

00:37:08,170 --> 00:37:14,230
last is that there are today a number of

00:37:12,280 --> 00:37:17,440
large enterprise software companies

00:37:14,230 --> 00:37:21,190
using rusts and they've invested their

00:37:17,440 --> 00:37:23,530
products in rust so they're invested in

00:37:21,190 --> 00:37:26,410
rusts future the biggest one of course

00:37:23,530 --> 00:37:29,470
is Mozilla he heard of the Firefox

00:37:26,410 --> 00:37:32,410
quantum release a while ago where

00:37:29,470 --> 00:37:35,430
Firefox got a lot faster one big reason

00:37:32,410 --> 00:37:38,440
of that was a big component

00:37:35,430 --> 00:37:41,290
got that was rewritten in rust were

00:37:38,440 --> 00:37:44,140
shipped with that the component was the

00:37:41,290 --> 00:37:47,500
CSS rendering that can

00:37:44,140 --> 00:37:50,680
now render all the CSS properties in

00:37:47,500 --> 00:37:54,370
your page in parallel and they did some

00:37:50,680 --> 00:37:56,970
analysis of the security bugs in this

00:37:54,370 --> 00:37:59,800
component that was written in C++ and

00:37:56,970 --> 00:38:00,310
found that since the beginning of

00:37:59,800 --> 00:38:03,460
Firefox

00:38:00,310 --> 00:38:07,270
there were 69 security bugs in this CSS

00:38:03,460 --> 00:38:08,740
component if they could have gone back

00:38:07,270 --> 00:38:11,050
in time than written in rust from the

00:38:08,740 --> 00:38:15,610
beginning rust would have prevented 51

00:38:11,050 --> 00:38:17,770
of those which is about 3/4 of them so I

00:38:15,610 --> 00:38:22,120
think that's a pretty good improvement

00:38:17,770 --> 00:38:28,420
on the security and of this Firefox of

00:38:22,120 --> 00:38:30,490
honey and the speed increase - if you

00:38:28,420 --> 00:38:32,290
know patio 11 on Twitter Patrick

00:38:30,490 --> 00:38:34,870
McKenzie he has this word he likes to

00:38:32,290 --> 00:38:36,700
say a Bama goo book soft and it

00:38:34,870 --> 00:38:40,720
represents a number of big software

00:38:36,700 --> 00:38:43,720
companies Apple I don't know of any

00:38:40,720 --> 00:38:46,090
public uses of rust at Apple

00:38:43,720 --> 00:38:49,090
they have Swift which actually is really

00:38:46,090 --> 00:38:52,180
similar to rust I was in the Swift talk

00:38:49,090 --> 00:38:54,970
earlier and they have a lot of the same

00:38:52,180 --> 00:38:56,980
problems and a lot of trying to solve

00:38:54,970 --> 00:38:58,870
the same problems that rust is but use

00:38:56,980 --> 00:39:00,100
different words for it so I was like

00:38:58,870 --> 00:39:02,800
sitting there trying to translate him

00:39:00,100 --> 00:39:04,660
like ah stats oh oh they're hitting the

00:39:02,800 --> 00:39:07,810
same problem that we are they're really

00:39:04,660 --> 00:39:09,780
similar and there is cross-pollination

00:39:07,810 --> 00:39:12,430
there

00:39:09,780 --> 00:39:13,600
so we're I hope there's more in the

00:39:12,430 --> 00:39:15,780
future and we can both learn from each

00:39:13,600 --> 00:39:15,780
other

00:39:16,410 --> 00:39:22,660
Amazon is the Amma part of this and they

00:39:20,710 --> 00:39:27,430
recently announced their fire cracker

00:39:22,660 --> 00:39:29,920
micro VM Google is also kind of

00:39:27,430 --> 00:39:31,690
secretive they have this fuchsia

00:39:29,920 --> 00:39:33,010
operating system project that they

00:39:31,690 --> 00:39:35,860
haven't really said what it's for yet

00:39:33,010 --> 00:39:38,380
but the code for it is like on the

00:39:35,860 --> 00:39:42,910
internet and you know open source and

00:39:38,380 --> 00:39:46,960
there's parts that in rust facebook has

00:39:42,910 --> 00:39:54,900
the Mononoke mercurial server to manage

00:39:46,960 --> 00:39:58,090
their huge mercurial mono repo that the

00:39:54,900 --> 00:40:00,810
canonical implementation of mercurial

00:39:58,090 --> 00:40:05,260
couldn't handle it fast enough and

00:40:00,810 --> 00:40:08,500
Microsoft announced they have this IOT

00:40:05,260 --> 00:40:11,020
edge platform that does analytics like

00:40:08,500 --> 00:40:14,440
on IOT devices and then sends the

00:40:11,020 --> 00:40:16,210
results to server so that's a Pam a GU

00:40:14,440 --> 00:40:20,860
box off we've got four out of five of

00:40:16,210 --> 00:40:22,420
those using rest publicly the fifth

00:40:20,860 --> 00:40:27,670
reason that I think we're set up to last

00:40:22,420 --> 00:40:32,530
is our project governance like the

00:40:27,670 --> 00:40:33,910
trains the adoption of this is not only

00:40:32,530 --> 00:40:36,670
for the technical reasons there's also

00:40:33,910 --> 00:40:39,940
political reasons and I think we are

00:40:36,670 --> 00:40:41,950
we're building a good foundation here we

00:40:39,940 --> 00:40:43,300
don't have a be DFL a benevolent

00:40:41,950 --> 00:40:47,350
dictator for life there's not just one

00:40:43,300 --> 00:40:50,290
person making final decisions on on rust

00:40:47,350 --> 00:40:52,470
we have a number of teams and working

00:40:50,290 --> 00:40:54,340
groups made up of multiple people

00:40:52,470 --> 00:40:58,120
responsible for different parts of

00:40:54,340 --> 00:41:00,670
language and we have a lot of different

00:40:58,120 --> 00:41:02,950
people represented on those teams and

00:41:00,670 --> 00:41:05,860
working groups we have programming

00:41:02,950 --> 00:41:09,100
language theorists people with PhDs and

00:41:05,860 --> 00:41:11,950
programming languages we have people

00:41:09,100 --> 00:41:15,460
using rust for a product for a company

00:41:11,950 --> 00:41:17,410
we have people using rust for fun we

00:41:15,460 --> 00:41:20,350
have people who come from the low level

00:41:17,410 --> 00:41:22,150
languages like C and C++ we have people

00:41:20,350 --> 00:41:25,630
from high level languages like I come

00:41:22,150 --> 00:41:27,580
from Ruby and in our surveys Python is

00:41:25,630 --> 00:41:31,090
consistently the number one language

00:41:27,580 --> 00:41:32,800
that people come to rust from and if

00:41:31,090 --> 00:41:35,440
there's people from functional languages

00:41:32,800 --> 00:41:40,060
like Haskell that bring a lot of the

00:41:35,440 --> 00:41:43,390
functional influence interests and our

00:41:40,060 --> 00:41:45,310
big decisions are made in public by AI

00:41:43,390 --> 00:41:48,640
system of requests for comments

00:41:45,310 --> 00:41:50,440
proposals that everyone can see and the

00:41:48,640 --> 00:41:53,950
teams responsible for making the final

00:41:50,440 --> 00:41:57,460
decision state their reasoning in public

00:41:53,950 --> 00:41:59,770
on these RFC's so while we might not

00:41:57,460 --> 00:42:02,590
make a decision on something in the

00:41:59,770 --> 00:42:04,330
exact way you might want our our hope is

00:42:02,590 --> 00:42:06,580
that you'll at least understand why

00:42:04,330 --> 00:42:10,920
we're making those decisions and feel

00:42:06,580 --> 00:42:10,920
like we have heard your point of view

00:42:11,200 --> 00:42:15,640
I feel really strongly that as an

00:42:14,349 --> 00:42:20,470
open-source person that this is

00:42:15,640 --> 00:42:22,960
important that this isn't driven Rus

00:42:20,470 --> 00:42:26,140
direction is not driven by a corporate

00:42:22,960 --> 00:42:27,790
closed entity making decisions in secret

00:42:26,140 --> 00:42:29,680
that you have no idea why they're doing

00:42:27,790 --> 00:42:33,010
and we're not going to take it in some

00:42:29,680 --> 00:42:34,059
surprising direction if we do you'll if

00:42:33,010 --> 00:42:36,280
we do take it in a different direction

00:42:34,059 --> 00:42:39,520
you'll know that we're doing it you'll

00:42:36,280 --> 00:42:41,349
be able to see us do that another big

00:42:39,520 --> 00:42:43,059
you think part of our governance is that

00:42:41,349 --> 00:42:46,569
we have a code of conduct and have since

00:42:43,059 --> 00:42:48,010
the language was open-source and I loved

00:42:46,569 --> 00:42:49,599
that this has been since the beginning

00:42:48,010 --> 00:42:51,369
so we don't have to have the argument

00:42:49,599 --> 00:42:53,290
about whether we should adopt one or not

00:42:51,369 --> 00:42:55,299
that decision has already been made we

00:42:53,290 --> 00:42:58,420
have one we are trying to make a

00:42:55,299 --> 00:43:02,829
professional space for professionals to

00:42:58,420 --> 00:43:05,710
work on technology and without problems

00:43:02,829 --> 00:43:07,150
we're not perfect but we are trying

00:43:05,710 --> 00:43:10,000
you're acknowledging that there are

00:43:07,150 --> 00:43:13,500
problems that we need to be handling to

00:43:10,000 --> 00:43:18,339
make rust a welcoming place for everyone

00:43:13,500 --> 00:43:20,770
so just to sum up these are my five

00:43:18,339 --> 00:43:26,049
reasons why I think Russ is going to be

00:43:20,770 --> 00:43:27,670
able to last the next four years and now

00:43:26,049 --> 00:43:30,069
we're going to talk a little bit more

00:43:27,670 --> 00:43:34,390
about the railroad industry and how that

00:43:30,069 --> 00:43:37,920
relates to what we're doing today

00:43:34,390 --> 00:43:40,630
this the software industry has a

00:43:37,920 --> 00:43:43,359
reputation for being a little bit

00:43:40,630 --> 00:43:47,309
arrogant we think we can do things

00:43:43,359 --> 00:43:50,619
better than other fields have done them

00:43:47,309 --> 00:43:52,720
there's the time that a software company

00:43:50,619 --> 00:43:55,240
thought they could do juice better than

00:43:52,720 --> 00:43:57,430
other people and actually didn't work

00:43:55,240 --> 00:44:01,780
any better than squeezing juice packet

00:43:57,430 --> 00:44:08,950
by hand there was the time that lift

00:44:01,780 --> 00:44:12,520
reinvented the bus and there's the time

00:44:08,950 --> 00:44:15,010
that there were people stuck in a cave

00:44:12,520 --> 00:44:16,920
and Elon Musk thought he could do cave

00:44:15,010 --> 00:44:20,020
rescues better than the people who

00:44:16,920 --> 00:44:21,190
specialized in that sort of thing so so

00:44:20,020 --> 00:44:22,660
we think we're better than other

00:44:21,190 --> 00:44:24,610
industries if you just add a little

00:44:22,660 --> 00:44:25,990
software we can totally fix these long

00:44:24,610 --> 00:44:31,030
standing problems that other industries

00:44:25,990 --> 00:44:32,620
have had were so much better I think I

00:44:31,030 --> 00:44:34,390
think we have to we have to work to

00:44:32,620 --> 00:44:39,100
prove it if we if we actually are better

00:44:34,390 --> 00:44:42,040
we need to show that we're better and we

00:44:39,100 --> 00:44:44,890
binding regulation to do this but

00:44:42,040 --> 00:44:47,020
there's a problem is that it's it's

00:44:44,890 --> 00:44:49,930
pretty easy for everyone to understand

00:44:47,020 --> 00:44:50,680
that if you can't stop a train people

00:44:49,930 --> 00:44:52,660
are gonna get hurt

00:44:50,680 --> 00:44:54,640
people are gonna kill pretty uneasy to

00:44:52,660 --> 00:44:57,070
understand that being on top of a moving

00:44:54,640 --> 00:45:01,360
train in any weather is a dangerous

00:44:57,070 --> 00:45:04,690
thing but it's it's not easy to

00:45:01,360 --> 00:45:08,860
understand what what memory on safety

00:45:04,690 --> 00:45:11,460
even is and it's not easy even easy for

00:45:08,860 --> 00:45:16,690
us to see what the effects of that are

00:45:11,460 --> 00:45:20,410
so like I'm trying to imagine the the

00:45:16,690 --> 00:45:23,350
Senate transcripts from reading that in

00:45:20,410 --> 00:45:26,650
the future from now of software people

00:45:23,350 --> 00:45:29,920
trying to explain memory on safety to

00:45:26,650 --> 00:45:33,940
senators and it's terrible it's I don't

00:45:29,920 --> 00:45:35,800
see this going well so I don't think I

00:45:33,940 --> 00:45:38,650
don't think government is going to

00:45:35,800 --> 00:45:42,730
improve the safety of software but I

00:45:38,650 --> 00:45:46,720
think we can improve ourselves we can be

00:45:42,730 --> 00:45:49,590
our own improved informed consumers that

00:45:46,720 --> 00:45:52,180
demand that our dependencies are safer

00:45:49,590 --> 00:45:55,000
before we incorporate them into our

00:45:52,180 --> 00:45:58,270
software because we understand our own

00:45:55,000 --> 00:46:02,380
problems that is the part that we can

00:45:58,270 --> 00:46:06,780
show that we are better the railroad

00:46:02,380 --> 00:46:08,950
industry got really started in 1830

00:46:06,780 --> 00:46:13,390
Westinghouse invented the air brake in

00:46:08,950 --> 00:46:18,100
1869 and then everyone was using it by

00:46:13,390 --> 00:46:23,620
1900 so this is about 80 years you know

00:46:18,100 --> 00:46:27,040
no that's not right 7 years about 40

00:46:23,620 --> 00:46:31,480
years to invent a safer thing about 30

00:46:27,040 --> 00:46:34,090
years for people to start using it rust

00:46:31,480 --> 00:46:37,790
became stable in 2015 I'm arguing that

00:46:34,090 --> 00:46:39,620
that is a better safer sea

00:46:37,790 --> 00:46:43,610
I don't know how long it's gonna take us

00:46:39,620 --> 00:46:46,040
to adopt something that's memory safe

00:46:43,610 --> 00:46:48,410
can we do better than the railroad

00:46:46,040 --> 00:46:51,470
industry I don't know

00:46:48,410 --> 00:46:55,450
I want us to be better I'm not sure if

00:46:51,470 --> 00:46:55,450
we are better I hope that we're better

00:46:55,690 --> 00:47:00,170
all right that's that's most of my

00:46:58,370 --> 00:47:03,170
arguments if you're still feeling a

00:47:00,170 --> 00:47:06,740
little skeptical that's totally fine I'm

00:47:03,170 --> 00:47:08,960
I'm willing to be wrong I I am willing

00:47:06,740 --> 00:47:12,230
for us and to not be the solution as

00:47:08,960 --> 00:47:14,180
long as we do something let's just do

00:47:12,230 --> 00:47:15,830
something to fix these memory safety

00:47:14,180 --> 00:47:19,880
problems that keep happening over and

00:47:15,830 --> 00:47:20,840
over and over again maybe maybe it's not

00:47:19,880 --> 00:47:21,590
gonna be rushed maybe there's something

00:47:20,840 --> 00:47:25,730
better than rest

00:47:21,590 --> 00:47:29,330
maybe it's sake dick go to the next talk

00:47:25,730 --> 00:47:31,160
I'm pleading fortitude maybe maybe it's

00:47:29,330 --> 00:47:33,890
go there's a go talk tomorrow

00:47:31,160 --> 00:47:34,940
or maybe maybe it's all of them maybe

00:47:33,890 --> 00:47:37,130
it's there's not gonna be one

00:47:34,940 --> 00:47:37,970
replacement maybe there's different

00:47:37,130 --> 00:47:40,520
replacements that are better for

00:47:37,970 --> 00:47:42,470
different situations that's fine I'm

00:47:40,520 --> 00:47:45,140
totally okay with that you don't have to

00:47:42,470 --> 00:47:47,420
choose rest I just I just want us to

00:47:45,140 --> 00:47:52,390
stop making the same mistakes over and

00:47:47,420 --> 00:47:52,390
over again let's make some new mistakes

00:47:53,520 --> 00:47:59,090
[Applause]

00:47:54,350 --> 00:48:02,349
[Music]

00:47:59,090 --> 00:48:02,349
[Applause]

00:48:02,820 --> 00:48:09,100
okay again this is the link to my slides

00:48:06,550 --> 00:48:10,260
and links that I reference i'm carol's

00:48:09,100 --> 00:48:13,540
ten cents

00:48:10,260 --> 00:48:15,550
there's a code for everyone to have that

00:48:13,540 --> 00:48:17,230
will get you 40% off anything I'm

00:48:15,550 --> 00:48:17,560
Manning calm and that code is right

00:48:17,230 --> 00:48:19,900
there

00:48:17,560 --> 00:48:22,060
and I would like to thank my test

00:48:19,900 --> 00:48:24,340
audience my daughter Vivian and my cat

00:48:22,060 --> 00:48:28,960
baby they were very patient provide

00:48:24,340 --> 00:48:31,900
valuable feedback okay let's see what

00:48:28,960 --> 00:48:43,600
questions we have let me stop mirroring

00:48:31,900 --> 00:48:47,770
here or start marine weather okay where

00:48:43,600 --> 00:48:50,910
are my questions okay let's see which

00:48:47,770 --> 00:48:50,910
ones I like best

00:49:05,790 --> 00:49:13,119
okay let's do what's with the name rust

00:49:10,359 --> 00:49:18,280
there's there's multiple stories here

00:49:13,119 --> 00:49:20,950
the people who started rust enjoyed

00:49:18,280 --> 00:49:24,910
riding bicycles and bicycles often have

00:49:20,950 --> 00:49:28,630
to deal with rust the logo our logo is

00:49:24,910 --> 00:49:32,200
kind of a bicycle gear there's also a

00:49:28,630 --> 00:49:36,720
fungus called rust that grows on wheat

00:49:32,200 --> 00:49:39,400
sometimes that is a potential

00:49:36,720 --> 00:49:43,809
inspiration that has been suggested as

00:49:39,400 --> 00:49:48,220
why why rust I like to think of it as

00:49:43,809 --> 00:49:49,450
something something something stable

00:49:48,220 --> 00:49:53,319
something that has been around a long

00:49:49,450 --> 00:49:54,910
time a stable strong coating on the

00:49:53,319 --> 00:49:58,270
outside there's actually this Corten

00:49:54,910 --> 00:50:00,700
steel the u.s. steel tower in Pittsburgh

00:49:58,270 --> 00:50:03,790
has built out of it it's steel that is

00:50:00,700 --> 00:50:06,130
meant to rust on purpose to protect it

00:50:03,790 --> 00:50:09,790
instead of paint so I like thinking of

00:50:06,130 --> 00:50:11,920
Corten steel so partha I liked your

00:50:09,790 --> 00:50:17,369
question if you are still here I have an

00:50:11,920 --> 00:50:18,579
envelope for you there yeah thank you

00:50:17,369 --> 00:50:20,589
okay

00:50:18,579 --> 00:50:23,680
why would you recommend rust Oberg oh I

00:50:20,589 --> 00:50:25,630
also like this question so anonymous who

00:50:23,680 --> 00:50:29,589
asked this if you would make your way to

00:50:25,630 --> 00:50:31,059
the front while I'm answering there are

00:50:29,589 --> 00:50:33,490
a couple of big differences in rust and

00:50:31,059 --> 00:50:37,630
go there actually is aiming for slightly

00:50:33,490 --> 00:50:38,920
different spaces I they I think they get

00:50:37,630 --> 00:50:40,390
compared a lot because they came out

00:50:38,920 --> 00:50:43,960
around the same time and they're both

00:50:40,390 --> 00:50:46,059
aiming to be kind of C++ alternatives go

00:50:43,960 --> 00:50:49,000
has a garbage collector which might be a

00:50:46,059 --> 00:50:51,210
deal breaker in your application so if

00:50:49,000 --> 00:50:53,920
you can't have something at runtime

00:50:51,210 --> 00:50:58,329
using resources then I would recommend

00:50:53,920 --> 00:51:00,790
rust if you're trying to interface with

00:50:58,329 --> 00:51:05,980
Google products I think go is probably

00:51:00,790 --> 00:51:09,220
going to be a really smooth way to have

00:51:05,980 --> 00:51:11,940
everything all in the same language for

00:51:09,220 --> 00:51:11,940
simplicity purposes

00:51:14,120 --> 00:51:23,540
and like hmm yeah III think you should

00:51:21,770 --> 00:51:26,000
check them both out and you should make

00:51:23,540 --> 00:51:27,920
I think one of them is going to resonate

00:51:26,000 --> 00:51:30,800
with you over the other so I think you

00:51:27,920 --> 00:51:34,600
should do some intro programming in both

00:51:30,800 --> 00:51:37,430
of them and and make your own choice so

00:51:34,600 --> 00:51:41,720
is someone going to fess up to asking

00:51:37,430 --> 00:51:44,240
that question for a free code no okay

00:51:41,720 --> 00:51:47,810
all right arguably one of the reasons

00:51:44,240 --> 00:51:49,730
for choosing C these days is a great IDE

00:51:47,810 --> 00:51:51,650
support does the rest have solid IV

00:51:49,730 --> 00:51:54,050
integration we're working on it this is

00:51:51,650 --> 00:51:58,760
another one of those things that we know

00:51:54,050 --> 00:52:00,230
we need to do better at we there's this

00:51:58,760 --> 00:52:02,660
thing called the language server

00:52:00,230 --> 00:52:05,540
protocol that is trying to standardize

00:52:02,660 --> 00:52:08,300
the way that languages can talk to II's

00:52:05,540 --> 00:52:10,070
and tell the IDE things about the code

00:52:08,300 --> 00:52:13,220
and we have an implementation that does

00:52:10,070 --> 00:52:20,480
code completion inline errors jump to

00:52:13,220 --> 00:52:22,340
definition and BS code has had the best

00:52:20,480 --> 00:52:24,530
maintained plug-in that uses the

00:52:22,340 --> 00:52:28,970
language server protocol IntelliJ also

00:52:24,530 --> 00:52:32,660
has a pretty good rust support I'm I so

00:52:28,970 --> 00:52:35,060
I did Ruby before bus and there and I

00:52:32,660 --> 00:52:37,850
love the book working effectively with

00:52:35,060 --> 00:52:39,020
legacy code by Michael feathers and but

00:52:37,850 --> 00:52:41,150
in that book he talks a lot about

00:52:39,020 --> 00:52:44,410
leaning on your tools using your ID

00:52:41,150 --> 00:52:46,730
using automatic refactorings and in Ruby

00:52:44,410 --> 00:52:48,200
because of all the meta programming and

00:52:46,730 --> 00:52:51,080
like you didn't take a string and run it

00:52:48,200 --> 00:52:52,700
as a function and you just you can't use

00:52:51,080 --> 00:52:54,530
some of those tools because you can't be

00:52:52,700 --> 00:52:56,300
sure that you caught everywhere that

00:52:54,530 --> 00:52:58,970
that function is called because it might

00:52:56,300 --> 00:53:04,190
be called dynamically from something so

00:52:58,970 --> 00:53:05,900
I had a lot of jealousy for ie tools

00:53:04,190 --> 00:53:07,910
while I was writing Ruby and I'm looking

00:53:05,900 --> 00:53:10,400
forward to the days that we have those

00:53:07,910 --> 00:53:13,280
tools for rust they're not there yet but

00:53:10,400 --> 00:53:17,080
they're there more possible to make than

00:53:13,280 --> 00:53:21,690
they are in Ruby so does anyone want to

00:53:17,080 --> 00:53:24,420
claim that question thank you very much

00:53:21,690 --> 00:53:27,250
[Music]

00:53:24,420 --> 00:53:34,000
okay let's see what other question I

00:53:27,250 --> 00:53:45,970
like um hmm latest question that's very

00:53:34,000 --> 00:53:48,359
good question oh okay

00:53:45,970 --> 00:53:52,359
this is this is a good question I

00:53:48,359 --> 00:53:56,109
mentioned a new async in 2018 magician

00:53:52,359 --> 00:53:58,210
and the it's async already in the 2015

00:53:56,109 --> 00:54:01,029
mission it's actually in neither Edition

00:53:58,210 --> 00:54:01,750
right now when we created the 2018

00:54:01,029 --> 00:54:04,119
magician

00:54:01,750 --> 00:54:06,849
we just reserved the keyword for async

00:54:04,119 --> 00:54:09,910
and we wanted to have a sync support

00:54:06,849 --> 00:54:14,500
done by the time we shipped the Edition

00:54:09,910 --> 00:54:15,250
but it's it's not it's not done people

00:54:14,500 --> 00:54:18,039
are working on it right now

00:54:15,250 --> 00:54:20,589
there's a lot of open discussion on the

00:54:18,039 --> 00:54:22,359
RFC's about the exact syntax the exact

00:54:20,589 --> 00:54:26,259
way it's gonna work so if you're

00:54:22,359 --> 00:54:29,740
interested you can go check that out but

00:54:26,259 --> 00:54:32,079
it's is not an either and if once it is

00:54:29,740 --> 00:54:34,390
done it will probably be available in

00:54:32,079 --> 00:54:37,029
both it's just that the syntax in Rus

00:54:34,390 --> 00:54:38,940
2015 isn't is not going to use a key

00:54:37,029 --> 00:54:43,509
word so it's not going to be as nice as

00:54:38,940 --> 00:54:46,720
syntax as it will be in Rus 2018 so who

00:54:43,509 --> 00:54:50,380
asks the async question all right

00:54:46,720 --> 00:54:52,230
then that is all the codes I have and I

00:54:50,380 --> 00:54:54,560
think I'm just about out of time so

00:54:52,230 --> 00:54:59,530
thank you very much for having me

00:54:54,560 --> 00:54:59,530
[Applause]

00:55:04,890 --> 00:55:06,950

YouTube URL: https://www.youtube.com/watch?v=A3AdN7U24iU


