Title: Rust: A Language for the Next 40 Years - Carol Nichols
Publication date: 2019-05-13
Playlist: Other Conferences 2019
Description: 
	Learn what makes the programming language Rust a unique technology, such as the memory safety guarantees that enable more people to write performant systems-level code. Hear about how Rust Editions evolve the language and the compiler without breaking existing code. See whoâ€™s trusting Rust for critical products today. Join us on Rustâ€™s journey to the future.

Philly ETE 2019 Playlist: https://www.youtube.com/playlist?list=PL9oQ7yETvN10Lopbg81O_bwElm9grUkDB
On the Chariot Solutions site: http://chariotsolutions.com/screencasts/
Captions: 
	00:00:13,030 --> 00:00:18,520
so you are in the talk rust a language

00:00:16,119 --> 00:00:21,310
for the next forty years my name is

00:00:18,520 --> 00:00:24,369
Carol nickels or Golding it's

00:00:21,310 --> 00:00:26,050
short-circuits I will answer two nickels

00:00:24,369 --> 00:00:27,520
quicker but you can also call me Carol

00:00:26,050 --> 00:00:30,130
building if you want

00:00:27,520 --> 00:00:33,430
I'm Carol's ten cents on all the various

00:00:30,130 --> 00:00:36,160
platforms I have a lot of links in my

00:00:33,430 --> 00:00:38,410
slides so if you want to be able to

00:00:36,160 --> 00:00:40,510
follow up on references and check out

00:00:38,410 --> 00:00:43,480
some more things this short link will

00:00:40,510 --> 00:00:46,270
take you to a repo where there's link to

00:00:43,480 --> 00:00:51,700
view the slides on the web and the

00:00:46,270 --> 00:00:54,640
readme has just the links pulled out as

00:00:51,700 --> 00:00:56,200
sort of alluded to in the intro I'm the

00:00:54,640 --> 00:00:58,180
co-author of the rest programming

00:00:56,200 --> 00:01:01,059
language book which is available for

00:00:58,180 --> 00:01:04,989
free online and available in print from

00:01:01,059 --> 00:01:07,899
no starch press I'm also a co-author on

00:01:04,989 --> 00:01:09,759
a Manning live video series called

00:01:07,899 --> 00:01:13,180
rusted motion that's in early access

00:01:09,759 --> 00:01:17,650
right now and thanks to Manning I have

00:01:13,180 --> 00:01:19,990
three codes for free access to this rest

00:01:17,650 --> 00:01:22,450
in motion so the favorite my favorite

00:01:19,990 --> 00:01:24,729
three questions are going to get access

00:01:22,450 --> 00:01:31,689
to this so please ask wonderful

00:01:24,729 --> 00:01:36,880
questions on the slide slide Oh question

00:01:31,689 --> 00:01:39,400
asking platform I am also a co-founder

00:01:36,880 --> 00:01:44,680
of integer 32 the world's first rust

00:01:39,400 --> 00:01:48,009
consulting company and I am an organizer

00:01:44,680 --> 00:01:49,329
of rust belt rust a regional rust

00:01:48,009 --> 00:01:51,850
conference this year we're going to be

00:01:49,329 --> 00:01:56,380
in Dayton Ohio on October 18th and 19th

00:01:51,850 --> 00:01:58,840
and I'm on the rust core team so if you

00:01:56,380 --> 00:02:02,770
were hoping for an objective unbiased

00:01:58,840 --> 00:02:07,810
look at rust you're not gonna get that

00:02:02,770 --> 00:02:08,350
from this talk I clearly have a slant

00:02:07,810 --> 00:02:10,720
here

00:02:08,350 --> 00:02:13,090
I love rust so much that my favorite

00:02:10,720 --> 00:02:16,180
hockey player is two-time Stanley Cup

00:02:13,090 --> 00:02:18,340
winning champion Brian rust from the

00:02:16,180 --> 00:02:19,959
Pittsburgh Penguins and yes you may

00:02:18,340 --> 00:02:20,900
throw tomatoes at me or batteries or

00:02:19,959 --> 00:02:24,349
whatever it is

00:02:20,900 --> 00:02:26,950
that you do here in Philadelphia I could

00:02:24,349 --> 00:02:28,970
take it alright so in this talk today

00:02:26,950 --> 00:02:30,409
we're gonna talk a little bit about the

00:02:28,970 --> 00:02:32,840
railroad industry but you weren't

00:02:30,409 --> 00:02:35,060
expecting that but we are we're gonna

00:02:32,840 --> 00:02:37,610
talk about C we're gonna talk about rust

00:02:35,060 --> 00:02:39,709
and we're going to talk about what the

00:02:37,610 --> 00:02:43,640
software industry can learn from the

00:02:39,709 --> 00:02:46,819
railroad industry so a little railroad

00:02:43,640 --> 00:02:48,349
industry history commercial railroads in

00:02:46,819 --> 00:02:51,739
the United States started being built

00:02:48,349 --> 00:02:53,540
around 1830 and trains are really great

00:02:51,739 --> 00:02:55,700
they let you get across this huge

00:02:53,540 --> 00:02:58,940
country of ours a lot faster than things

00:02:55,700 --> 00:03:03,290
like stagecoaches and they really took

00:02:58,940 --> 00:03:06,190
off built lots of lines of Braille all

00:03:03,290 --> 00:03:08,720
around the country really fast but as

00:03:06,190 --> 00:03:12,319
the miles of rail and as the train trips

00:03:08,720 --> 00:03:15,650
grew injuries and deaths also grew it

00:03:12,319 --> 00:03:17,780
turns out that once you get a big train

00:03:15,650 --> 00:03:22,129
moving it's kind of hard to get it to

00:03:17,780 --> 00:03:23,989
stop again and there were lots of

00:03:22,129 --> 00:03:27,230
collisions there were lots of accidents

00:03:23,989 --> 00:03:29,739
and one of the most dangerous jobs on

00:03:27,230 --> 00:03:33,560
the railroads was that of the brake man

00:03:29,739 --> 00:03:37,549
because the way you used to have to get

00:03:33,560 --> 00:03:39,290
trains to stop is someone the engineer

00:03:37,549 --> 00:03:42,010
would blow a certain signal with the

00:03:39,290 --> 00:03:44,359
whistle that he wanted to stop and then

00:03:42,010 --> 00:03:47,540
people would have to go off on the top

00:03:44,359 --> 00:03:50,269
of each car and turn this wheel to put

00:03:47,540 --> 00:03:52,910
the brakes on and then move to the next

00:03:50,269 --> 00:03:55,699
car and eventually the train would

00:03:52,910 --> 00:03:58,579
slowly come to a stop as all the brakes

00:03:55,699 --> 00:04:03,349
were applied but this wasn't really an

00:03:58,579 --> 00:04:05,209
exact science so if at best case if this

00:04:03,349 --> 00:04:07,760
didn't go well you would miss the

00:04:05,209 --> 00:04:10,400
station you were trying to stop at worst

00:04:07,760 --> 00:04:12,500
case if you needed to stop in a hurry

00:04:10,400 --> 00:04:17,180
probably couldn't and you there were

00:04:12,500 --> 00:04:18,859
collisions and accidents and this job

00:04:17,180 --> 00:04:22,099
being on top of the train when it was

00:04:18,859 --> 00:04:24,740
rainy or icy it's pretty dangerous and a

00:04:22,099 --> 00:04:27,440
lot of brake men would fell to fall off

00:04:24,740 --> 00:04:33,020
the train and be killed this was a this

00:04:27,440 --> 00:04:34,400
is the thousands of brakeman died every

00:04:33,020 --> 00:04:36,530
year this is second only to

00:04:34,400 --> 00:04:39,460
mining as the most dangerous career in

00:04:36,530 --> 00:04:39,460
the eighteen hundred's

00:04:40,000 --> 00:04:48,190
enter George Westinghouse a an amazing

00:04:44,150 --> 00:04:53,120
Pittsburgher he invented lots of things

00:04:48,190 --> 00:04:56,900
was part of making electricity viable

00:04:53,120 --> 00:05:00,880
and and commercially available and in

00:04:56,900 --> 00:05:03,320
1869 he invented the first air brake

00:05:00,880 --> 00:05:05,000
there have been improvements made over

00:05:03,320 --> 00:05:08,120
the years but essentially his air brake

00:05:05,000 --> 00:05:10,789
is what trains use today the way air

00:05:08,120 --> 00:05:14,600
brakes work are that they're controlled

00:05:10,789 --> 00:05:18,020
by compressed air rather than a physical

00:05:14,600 --> 00:05:22,070
wheel on top the car there's a control

00:05:18,020 --> 00:05:24,199
up in front for the engineer to turn the

00:05:22,070 --> 00:05:28,669
brakes on and off so they don't have to

00:05:24,199 --> 00:05:32,000
use the whistle to communicate all the

00:05:28,669 --> 00:05:33,800
cars are connected so that when the

00:05:32,000 --> 00:05:36,400
engineer turns the brakes on all of the

00:05:33,800 --> 00:05:41,060
cars start breaking all the same time

00:05:36,400 --> 00:05:43,610
and a later failsafe was added so that

00:05:41,060 --> 00:05:46,400
when there isn't pressure to each car

00:05:43,610 --> 00:05:49,490
through this connection the brakes are

00:05:46,400 --> 00:05:50,960
on so that this is safe by default you

00:05:49,490 --> 00:05:53,330
would have to apply the pressure to turn

00:05:50,960 --> 00:05:54,830
the brakes off and get the car moving so

00:05:53,330 --> 00:05:57,110
if something if all the Scotch is

00:05:54,830 --> 00:06:01,030
connected the Train would would come to

00:05:57,110 --> 00:06:03,889
a stop instead of continuing to go and

00:06:01,030 --> 00:06:06,770
this system was a lot more complex than

00:06:03,889 --> 00:06:09,729
the hand brakes and there was some

00:06:06,770 --> 00:06:13,659
skepticism this was a quote from

00:06:09,729 --> 00:06:16,729
Vanderbilt who was the guy behind

00:06:13,659 --> 00:06:19,310
Vanderbilt University eventually but he

00:06:16,729 --> 00:06:22,940
he couldn't believe that that error was

00:06:19,310 --> 00:06:24,919
going to be what stops trains but they

00:06:22,940 --> 00:06:28,070
did a lot of public tests a lot of

00:06:24,919 --> 00:06:31,430
demonstrations that involved people

00:06:28,070 --> 00:06:33,320
riding in train cars with like pillows

00:06:31,430 --> 00:06:35,060
everywhere testing all these sorts of

00:06:33,320 --> 00:06:36,830
different kinds of brakes and like

00:06:35,060 --> 00:06:38,180
running into the wall is because when

00:06:36,830 --> 00:06:40,580
different kinds of brakes didn't work

00:06:38,180 --> 00:06:42,860
but the air brakes were passing all

00:06:40,580 --> 00:06:45,050
these public tests and there were a lot

00:06:42,860 --> 00:06:48,460
safer and a lot better at getting the

00:06:45,050 --> 00:06:51,740
trains to stop then the hand brakes were

00:06:48,460 --> 00:06:53,870
railroads are adopted these four

00:06:51,740 --> 00:06:56,300
passenger trains pretty quickly because

00:06:53,870 --> 00:06:59,530
consumers demanded it this is an

00:06:56,300 --> 00:07:03,229
advertisement for a particular train and

00:06:59,530 --> 00:07:04,610
the this yellow part here says that the

00:07:03,229 --> 00:07:06,470
Swift operation of these nightly

00:07:04,610 --> 00:07:08,630
carriers is safeguarded by Westinghouse

00:07:06,470 --> 00:07:12,590
air brakes so this is something that the

00:07:08,630 --> 00:07:13,940
market demanded that that they there

00:07:12,590 --> 00:07:15,470
were people who were scared to ride

00:07:13,940 --> 00:07:17,150
trains because they couldn't stop but

00:07:15,470 --> 00:07:18,319
these air brakes gave people the

00:07:17,150 --> 00:07:19,330
confidence that they could ride the

00:07:18,319 --> 00:07:22,880
train safely

00:07:19,330 --> 00:07:25,250
however on freight trains it took a lot

00:07:22,880 --> 00:07:30,620
longer for these air wrecks to be

00:07:25,250 --> 00:07:34,479
adopted and there was this person named

00:07:30,620 --> 00:07:37,039
coffin who was a big advocate for

00:07:34,479 --> 00:07:40,039
mandating these air brakes be used on

00:07:37,039 --> 00:07:42,560
all trains and he worked for the Iowa

00:07:40,039 --> 00:07:44,810
Railroad Commission and when he started

00:07:42,560 --> 00:07:47,560
he said that the people on the

00:07:44,810 --> 00:07:49,789
Commission just kind of thought that

00:07:47,560 --> 00:07:53,000
this was the way it was

00:07:49,789 --> 00:07:55,699
trains are dangerous and brakeman were

00:07:53,000 --> 00:07:57,470
going to die so there wasn't really much

00:07:55,699 --> 00:08:03,080
we could do that this is just how things

00:07:57,470 --> 00:08:05,570
were but he a coffin got kept getting

00:08:03,080 --> 00:08:08,659
all these reports about brakeman being

00:08:05,570 --> 00:08:09,979
killed and was like no this is these are

00:08:08,659 --> 00:08:12,590
all the same cause we have to do

00:08:09,979 --> 00:08:14,570
something about this so he did a lot of

00:08:12,590 --> 00:08:17,659
advocacy there's this there's

00:08:14,570 --> 00:08:19,550
transcripts of a Senate hearing for the

00:08:17,659 --> 00:08:22,250
run the Interstate Commerce Committee

00:08:19,550 --> 00:08:25,610
that I just find riveting I like reading

00:08:22,250 --> 00:08:28,880
these Senate transcripts from 1890 and

00:08:25,610 --> 00:08:31,490
they're amazing coffin had a lot to say

00:08:28,880 --> 00:08:35,390
in favor of mandating air brakes on all

00:08:31,490 --> 00:08:38,209
trains the industry people were didn't

00:08:35,390 --> 00:08:42,440
want to be regulated so they had a lot

00:08:38,209 --> 00:08:44,420
of interesting arguments they they

00:08:42,440 --> 00:08:47,180
didn't want to pay to add these air

00:08:44,420 --> 00:08:50,089
brakes to all their trains they thought

00:08:47,180 --> 00:08:53,779
that brakeman were kind of expendable

00:08:50,089 --> 00:08:55,880
and cheaper which is terrible they were

00:08:53,779 --> 00:08:58,760
like the air brakes are still gonna fail

00:08:55,880 --> 00:09:00,140
sometimes the like it doesn't matter the

00:08:58,760 --> 00:09:02,560
hand brakes fail the air brakes are also

00:09:00,140 --> 00:09:05,990
going to fail so why so why should we

00:09:02,560 --> 00:09:08,690
they simultaneously made two arguments

00:09:05,990 --> 00:09:10,670
they said we are already innovating

00:09:08,690 --> 00:09:12,080
without legislation we are testing new

00:09:10,670 --> 00:09:14,480
things all the time to improve the

00:09:12,080 --> 00:09:16,340
safety of the Train if you if you

00:09:14,480 --> 00:09:18,950
regulate that there's some minimum

00:09:16,340 --> 00:09:20,150
standard we're gonna adopt the thing

00:09:18,950 --> 00:09:22,130
that'll meet the law and we're gonna

00:09:20,150 --> 00:09:24,830
stop innovating so that was one argument

00:09:22,130 --> 00:09:29,360
in like the next breath this guy at so

00:09:24,830 --> 00:09:31,040
liberating testimony said and what if

00:09:29,360 --> 00:09:33,500
something better comes along and we've

00:09:31,040 --> 00:09:35,750
already have all this sunk costs into

00:09:33,500 --> 00:09:38,390
these air brakes it's like wait a second

00:09:35,750 --> 00:09:39,830
wait are you saying you're gonna keep

00:09:38,390 --> 00:09:41,630
innovating are you saying you're gonna

00:09:39,830 --> 00:09:43,610
stop innovating because now you're

00:09:41,630 --> 00:09:46,690
saying what we're gonna happen they

00:09:43,610 --> 00:09:49,160
really just didn't want to be regulated

00:09:46,690 --> 00:09:50,540
they said they have other means they

00:09:49,160 --> 00:09:52,850
have to pay for they can't possibly

00:09:50,540 --> 00:09:53,990
afford these they said you should have

00:09:52,850 --> 00:09:56,900
regulated this twenty five or thirty

00:09:53,990 --> 00:09:59,570
years ago all sorts of things my

00:09:56,900 --> 00:10:01,040
favorite my favorite objection from the

00:09:59,570 --> 00:10:03,770
president of the Pennsylvania Railroad

00:10:01,040 --> 00:10:05,690
Company was are you're gonna regulate

00:10:03,770 --> 00:10:09,200
the trains what's next are you gonna

00:10:05,690 --> 00:10:10,490
regulate the bridges it's like yes

00:10:09,200 --> 00:10:12,650
please

00:10:10,490 --> 00:10:19,220
we want the bridges to be safe too

00:10:12,650 --> 00:10:22,270
actually so yeah it turns out that the

00:10:19,220 --> 00:10:26,480
US railroad safety appliance Act passed

00:10:22,270 --> 00:10:29,210
Congress in 1893 mandated the use of air

00:10:26,480 --> 00:10:32,990
brakes and standard couplers to connect

00:10:29,210 --> 00:10:36,170
the trans together in 1900 it was fully

00:10:32,990 --> 00:10:38,270
enforced and all trains whether a

00:10:36,170 --> 00:10:40,220
passenger freight had to be using these

00:10:38,270 --> 00:10:44,510
safety devices and accidents and deaths

00:10:40,220 --> 00:10:45,650
of both people being run into both

00:10:44,510 --> 00:10:48,520
people and things being run into by

00:10:45,650 --> 00:10:52,790
trains and brakeman operating the trains

00:10:48,520 --> 00:10:56,950
went way down this helped a whole lot it

00:10:52,790 --> 00:10:59,840
wasn't perfect but it was way better

00:10:56,950 --> 00:11:02,710
okay that was your railroad history

00:10:59,840 --> 00:11:02,710
lesson

00:11:02,790 --> 00:11:09,580
so now we're gonna talk a little bit

00:11:04,630 --> 00:11:13,029
about C so why might companies choose C

00:11:09,580 --> 00:11:18,010
uh who-who works at a company who has Z

00:11:13,029 --> 00:11:21,519
code in production today okay yeah good

00:11:18,010 --> 00:11:23,500
all right you you might you probably

00:11:21,519 --> 00:11:26,740
have a variety reasons why you're doing

00:11:23,500 --> 00:11:29,920
that it's a proven solution that has

00:11:26,740 --> 00:11:31,839
worked for 40 years it's fast it has

00:11:29,920 --> 00:11:33,399
very little overhead it's kind of close

00:11:31,839 --> 00:11:37,500
to the Machine close to the assembly

00:11:33,399 --> 00:11:39,760
language it uses very little resources

00:11:37,500 --> 00:11:41,560
there's a C compiler to target just

00:11:39,760 --> 00:11:45,610
about any sort of platform you might

00:11:41,560 --> 00:11:47,860
want to run on the language is simple

00:11:45,610 --> 00:11:49,959
there's not a whole lot of syntax to

00:11:47,860 --> 00:11:52,360
learn I would argue that it's a little

00:11:49,959 --> 00:11:54,790
bit deceptively simple because there's a

00:11:52,360 --> 00:11:59,320
lot of interesting things that C code

00:11:54,790 --> 00:12:01,120
can do you might have a lot of existing

00:11:59,320 --> 00:12:04,510
C code or you might want to interface

00:12:01,120 --> 00:12:07,920
with existing C code that makes it easy

00:12:04,510 --> 00:12:10,630
means using C would make that easier and

00:12:07,920 --> 00:12:13,180
C doesn't really change a whole lot and

00:12:10,630 --> 00:12:16,779
enterprise software the field moves

00:12:13,180 --> 00:12:18,910
rather slowly and you don't want to have

00:12:16,779 --> 00:12:20,920
lots of parts changing out from

00:12:18,910 --> 00:12:25,779
underneath you and having your code

00:12:20,920 --> 00:12:28,000
become obsolete so but in order to get

00:12:25,779 --> 00:12:31,270
all these advantages you have to agree

00:12:28,000 --> 00:12:35,680
to what I see as a huge disadvantage

00:12:31,270 --> 00:12:39,130
that outweighs all of that is that C has

00:12:35,680 --> 00:12:42,550
all these memory safety problems it's

00:12:39,130 --> 00:12:46,209
not memory safe these problems include

00:12:42,550 --> 00:12:49,089
use after free double free memory leaks

00:12:46,209 --> 00:12:53,649
buffer over reads and over writes no

00:12:49,089 --> 00:12:56,980
pointers databases oh my this is just a

00:12:53,649 --> 00:13:01,480
lot of problems that you have to sign on

00:12:56,980 --> 00:13:03,880
to when you are shipping C in production

00:13:01,480 --> 00:13:05,980
and I'm sure those of you who have seen

00:13:03,880 --> 00:13:09,449
production can tell lots of stories

00:13:05,980 --> 00:13:14,260
about problems caused by all of these

00:13:09,449 --> 00:13:15,500
and a lot of people say well it's you

00:13:14,260 --> 00:13:17,720
just be more careful

00:13:15,500 --> 00:13:20,450
then we can avoid these problems it's

00:13:17,720 --> 00:13:22,760
not a matter of being more careful we're

00:13:20,450 --> 00:13:25,610
in it's the experience in past 40 years

00:13:22,760 --> 00:13:29,120
has shown we're not capable of being

00:13:25,610 --> 00:13:32,720
careful enough there is a vulnerability

00:13:29,120 --> 00:13:35,050
called stage fright in Android and this

00:13:32,720 --> 00:13:37,970
blog post was illustrating some C code

00:13:35,050 --> 00:13:41,390
to try and explain what the root cause

00:13:37,970 --> 00:13:42,590
of stage fright was and - he said you'd

00:13:41,390 --> 00:13:45,250
have to be more careful than the

00:13:42,590 --> 00:13:47,540
entirety of the Android security team

00:13:45,250 --> 00:13:50,390
every C developer shipping code

00:13:47,540 --> 00:13:54,350
impression has to be more careful than

00:13:50,390 --> 00:13:58,070
that there was a great presentation and

00:13:54,350 --> 00:14:01,640
the post about Microsoft did some

00:13:58,070 --> 00:14:05,150
studying of the problems that they had

00:14:01,640 --> 00:14:08,300
to do issue security updates for over

00:14:05,150 --> 00:14:11,050
the last 12 years about 70% of them were

00:14:08,300 --> 00:14:13,880
due to memory safety problems

00:14:11,050 --> 00:14:17,350
we're being you'd have to be more

00:14:13,880 --> 00:14:19,940
careful than the Microsoft security team

00:14:17,350 --> 00:14:22,880
there have been some efforts to make C

00:14:19,940 --> 00:14:26,050
safer there are tools like valgrind

00:14:22,880 --> 00:14:29,270
there's tools like address sanitizer

00:14:26,050 --> 00:14:31,850
undefined behavior sanitizers I found

00:14:29,270 --> 00:14:34,690
this tool called IKOS that does abstract

00:14:31,850 --> 00:14:37,930
interpretation as a static static

00:14:34,690 --> 00:14:40,190
analysis it's from NASA so you'd have

00:14:37,930 --> 00:14:44,900
passive has a really rigorous

00:14:40,190 --> 00:14:47,900
engineering discipline so if that's the

00:14:44,900 --> 00:14:49,760
kind of investment you want to make you

00:14:47,900 --> 00:14:53,210
can check out tools like that there are

00:14:49,760 --> 00:14:57,050
the misra guidelines all of these kind

00:14:53,210 --> 00:14:58,490
of strike me as things you do after the

00:14:57,050 --> 00:15:03,530
fact you write the code first and then

00:14:58,490 --> 00:15:05,120
you try and make it safe which you have

00:15:03,530 --> 00:15:06,890
to make sure you do those things you

00:15:05,120 --> 00:15:08,030
can't forever forget you have to build

00:15:06,890 --> 00:15:09,530
them in the processes you have to

00:15:08,030 --> 00:15:13,010
allocate time to do that and fix the

00:15:09,530 --> 00:15:17,030
problems you find it seems like kind of

00:15:13,010 --> 00:15:22,120
patching it after the fact there are

00:15:17,030 --> 00:15:22,120
some varieties of C people are creating

00:15:22,660 --> 00:15:28,790
none of these have really caught on much

00:15:26,180 --> 00:15:32,000
you're still writing C that has

00:15:28,790 --> 00:15:33,530
very little abstractions you have to

00:15:32,000 --> 00:15:35,360
reinvent the wheel all the time you

00:15:33,530 --> 00:15:37,280
don't have modern tools that go with it

00:15:35,360 --> 00:15:40,900
and if you're gonna be switching

00:15:37,280 --> 00:15:44,180
languages anyway I advocate that you

00:15:40,900 --> 00:15:47,090
look at all your options and of course

00:15:44,180 --> 00:15:49,370
they're C++ which improves some things

00:15:47,090 --> 00:15:51,830
by not everything there's still a lot of

00:15:49,370 --> 00:15:56,140
undefined behavior there's still a lot

00:15:51,830 --> 00:15:57,950
of pointer problems you can get into

00:15:56,140 --> 00:16:04,040
multi-threaded programming is still a

00:15:57,950 --> 00:16:08,180
big problem in C++ so what can we do

00:16:04,040 --> 00:16:14,720
about this and that brings us to the

00:16:08,180 --> 00:16:18,020
Russ part so Russ is a language out of

00:16:14,720 --> 00:16:20,150
Mozilla research it's trying to learn

00:16:18,020 --> 00:16:22,780
from the mistakes of C and bring in

00:16:20,150 --> 00:16:26,270
ideas from a bunch of other languages

00:16:22,780 --> 00:16:28,910
too I see it as moving our industry

00:16:26,270 --> 00:16:32,060
forward and trying not to repeat the

00:16:28,910 --> 00:16:35,870
same mistakes over and over again I have

00:16:32,060 --> 00:16:41,240
five reasons why I think Russ is ready

00:16:35,870 --> 00:16:44,420
to last as long as C has the first

00:16:41,240 --> 00:16:47,570
reason is that it fixes these memory

00:16:44,420 --> 00:16:51,500
safety problems it's it's an improvement

00:16:47,570 --> 00:16:56,000
upon the status quo it does this through

00:16:51,500 --> 00:16:58,370
a system of ownership and borrowing and

00:16:56,000 --> 00:17:01,160
I'm going to show some examples of how

00:16:58,370 --> 00:17:05,360
this works this is some rest code it's a

00:17:01,160 --> 00:17:08,390
main function that creates a string on

00:17:05,360 --> 00:17:12,380
the heap that we can grow and change in

00:17:08,390 --> 00:17:16,100
size the owner of that memory is this

00:17:12,380 --> 00:17:19,220
variable X and when that owner goes out

00:17:16,100 --> 00:17:22,550
of scope that's when the heap memory it

00:17:19,220 --> 00:17:24,740
gets cleaned up automatically rust kind

00:17:22,550 --> 00:17:26,870
of inserts a looks at this code I was

00:17:24,740 --> 00:17:30,410
compiling inserts a statement at compile

00:17:26,870 --> 00:17:34,210
time that at the end of main that cleans

00:17:30,410 --> 00:17:38,780
up that memory so we don't have to write

00:17:34,210 --> 00:17:40,280
free free the memory that X manually but

00:17:38,780 --> 00:17:41,880
there's also not a garbage collector

00:17:40,280 --> 00:17:45,360
running at runtime this is all

00:17:41,880 --> 00:17:47,040
compile-time this is another example in

00:17:45,360 --> 00:17:51,540
this example we've got the same string

00:17:47,040 --> 00:17:56,880
in X then we say let y equals 2x and we

00:17:51,540 --> 00:18:00,650
try to print out X this line here moves

00:17:56,880 --> 00:18:05,730
ownership of the string from X to Y and

00:18:00,650 --> 00:18:09,030
this code does not compile because we're

00:18:05,730 --> 00:18:12,360
trying to use X again after we've moved

00:18:09,030 --> 00:18:16,560
it into y so we see this data still only

00:18:12,360 --> 00:18:19,410
has one owner after that point we've

00:18:16,560 --> 00:18:22,230
moved it into y Y we'll clean that up

00:18:19,410 --> 00:18:24,060
and X note is no longer valid and we're

00:18:22,230 --> 00:18:26,550
no longer allowed to use it after we've

00:18:24,060 --> 00:18:30,380
moved it so we don't have double three

00:18:26,550 --> 00:18:30,380
problems and we can't use after free

00:18:30,710 --> 00:18:39,090
this code instead of moving ownership

00:18:34,460 --> 00:18:42,660
this borrows Y is a an immutable borrow

00:18:39,090 --> 00:18:45,780
of X it's allowed to read the the data

00:18:42,660 --> 00:18:47,790
that X owns but X is still responsible

00:18:45,780 --> 00:18:50,490
for cleaning up the memory at the end of

00:18:47,790 --> 00:18:53,790
the function and this code compiles and

00:18:50,490 --> 00:19:00,330
we're allowed to read using either X or

00:18:53,790 --> 00:19:03,870
Y in this example we are trying to

00:19:00,330 --> 00:19:07,320
create a dangling pointer we have an

00:19:03,870 --> 00:19:10,590
inner scope and we're trying to return a

00:19:07,320 --> 00:19:14,940
reference to heap data from that inner

00:19:10,590 --> 00:19:16,770
scope the problem is that the way rust

00:19:14,940 --> 00:19:18,330
ownership works X is going to get

00:19:16,770 --> 00:19:21,470
cleaned up at the end of that inner

00:19:18,330 --> 00:19:24,660
scope so this code doesn't compile

00:19:21,470 --> 00:19:26,550
because we're trying to use the

00:19:24,660 --> 00:19:28,680
reference after that data has been

00:19:26,550 --> 00:19:32,970
cleaned up and rust can see that at

00:19:28,680 --> 00:19:39,420
compile time and doesn't let us run this

00:19:32,970 --> 00:19:41,820
code because X gets cleaned up rust has

00:19:39,420 --> 00:19:44,790
a lot of other safety mechanisms that I

00:19:41,820 --> 00:19:46,800
don't have time to get into fully one of

00:19:44,790 --> 00:19:51,170
the rules about references is that you

00:19:46,800 --> 00:19:56,019
can have either one mutable changeable

00:19:51,170 --> 00:19:59,139
reference at a time or you can have many

00:19:56,019 --> 00:20:03,070
immutable references for reading at one

00:19:59,139 --> 00:20:05,799
time so this prevents databases so that

00:20:03,070 --> 00:20:09,669
you can't change a value while someone

00:20:05,799 --> 00:20:14,039
else is trying to read it there are no

00:20:09,669 --> 00:20:17,350
no pointers there's the option type that

00:20:14,039 --> 00:20:20,559
represents either something and holds a

00:20:17,350 --> 00:20:23,499
value or there's none the none value and

00:20:20,559 --> 00:20:28,690
the compiler makes sure you handle both

00:20:23,499 --> 00:20:31,570
some or none at compile time out of

00:20:28,690 --> 00:20:34,690
balance array axises or data structure

00:20:31,570 --> 00:20:36,429
accesses at run time it just stops the

00:20:34,690 --> 00:20:39,159
program immediately and doesn't let you

00:20:36,429 --> 00:20:42,429
continue with invalid data that isn't

00:20:39,159 --> 00:20:44,470
part of your data structure the

00:20:42,429 --> 00:20:46,149
ownership rules apply across multiple

00:20:44,470 --> 00:20:49,509
threads there's parts of the type system

00:20:46,149 --> 00:20:52,239
that allow you to express transferring

00:20:49,509 --> 00:20:52,720
ownership or borrowing across multiple

00:20:52,239 --> 00:20:56,409
threads

00:20:52,720 --> 00:20:59,619
so now programming parallel or

00:20:56,409 --> 00:21:01,330
concurrent programs is is checked at

00:20:59,619 --> 00:21:06,070
compile time that you don't have data

00:21:01,330 --> 00:21:07,899
races across threads Jessica this

00:21:06,070 --> 00:21:10,529
morning said a neat word that I hadn't

00:21:07,899 --> 00:21:13,960
heard before which is the person bite

00:21:10,529 --> 00:21:17,649
it's what you can keep in your head all

00:21:13,960 --> 00:21:19,929
at one time and trying to keep all these

00:21:17,649 --> 00:21:22,179
rules and keep make sure you're doing

00:21:19,929 --> 00:21:27,009
all these things right in your head with

00:21:22,179 --> 00:21:29,859
C is really tedious and as we've seen is

00:21:27,009 --> 00:21:31,809
error-prone it's it's too much for one

00:21:29,859 --> 00:21:37,090
person to hold your head in addition to

00:21:31,809 --> 00:21:39,279
your problem domain is and but there's

00:21:37,090 --> 00:21:41,529
someone who's really good at keeping

00:21:39,279 --> 00:21:42,700
track of tedious things and making sure

00:21:41,529 --> 00:21:47,070
that they're right every single time

00:21:42,700 --> 00:21:49,509
it's our computers so I see rust as

00:21:47,070 --> 00:21:53,019
making the computer take care of all

00:21:49,509 --> 00:21:55,570
that tedious tracking of whether the

00:21:53,019 --> 00:21:57,249
memory accesses are right or not and I

00:21:55,570 --> 00:21:58,509
can forget about that the compilers

00:21:57,249 --> 00:22:00,639
gonna tell me when I get it wrong and I

00:21:58,509 --> 00:22:03,820
have to go fix that yeah but if my comm

00:22:00,639 --> 00:22:07,359
compiles I I don't have to worry that I

00:22:03,820 --> 00:22:09,160
that I missed someplace and I can just

00:22:07,359 --> 00:22:12,160
concentrate on my domain

00:22:09,160 --> 00:22:15,430
and this is the second reason I think

00:22:12,160 --> 00:22:18,040
Russ is is going to continue to grow and

00:22:15,430 --> 00:22:20,170
to last for the next 40 years is that

00:22:18,040 --> 00:22:22,660
this makes love level assistance

00:22:20,170 --> 00:22:24,940
programming code something that everyone

00:22:22,660 --> 00:22:27,490
is capable of doing not people who have

00:22:24,940 --> 00:22:29,860
extremely large person bite capabilities

00:22:27,490 --> 00:22:34,120
to hold all this memory access in their

00:22:29,860 --> 00:22:36,220
head as well as the domain which I'm not

00:22:34,120 --> 00:22:38,350
sure that anyone actually exists because

00:22:36,220 --> 00:22:41,950
of the problems we see but more people

00:22:38,350 --> 00:22:45,940
can program safe systems level code with

00:22:41,950 --> 00:22:49,240
rust I do have a caveat there is an

00:22:45,940 --> 00:22:52,210
escape hatch it's the unsafe keyword it

00:22:49,240 --> 00:22:55,060
lets you opt-out of not all of Russ

00:22:52,210 --> 00:23:00,010
safety checks it lets you do a few very

00:22:55,060 --> 00:23:01,650
specific things e and by putting unsafe

00:23:00,010 --> 00:23:07,030
around some of your code you're saying

00:23:01,650 --> 00:23:09,310
okay compiler I understand that you

00:23:07,030 --> 00:23:12,610
can't ensure that this code is going to

00:23:09,310 --> 00:23:14,620
be safe every single time I as a person

00:23:12,610 --> 00:23:16,720
I'm going to audit this specific code

00:23:14,620 --> 00:23:21,730
and I will make sure that I'm following

00:23:16,720 --> 00:23:24,960
the Murray rules and this is useful in

00:23:21,730 --> 00:23:28,420
certain performance cases when you're

00:23:24,960 --> 00:23:30,250
trying to express certain pointer

00:23:28,420 --> 00:23:31,900
arithmetic when you're trying to call to

00:23:30,250 --> 00:23:34,930
external code that the compiler can't

00:23:31,900 --> 00:23:36,400
possibly know anything about so as and

00:23:34,930 --> 00:23:39,970
as long as you don't put your entire

00:23:36,400 --> 00:23:43,200
program in an unsafe block what I like

00:23:39,970 --> 00:23:46,570
about this is that when if you have a

00:23:43,200 --> 00:23:48,880
seg fault or memory access problem at

00:23:46,570 --> 00:23:50,920
runtime you know it came from one of

00:23:48,880 --> 00:23:53,260
those unsafe blocks it's like hey look

00:23:50,920 --> 00:23:55,090
over here this is probably where the

00:23:53,260 --> 00:23:56,950
memory problem came from because the

00:23:55,090 --> 00:23:59,290
compiler didn't check this part so

00:23:56,950 --> 00:24:02,170
you've you've lessened the places you

00:23:59,290 --> 00:24:09,010
have to look to debug to figure out

00:24:02,170 --> 00:24:11,440
those problems I also think that this

00:24:09,010 --> 00:24:13,390
this unsafe keyword doesn't invalidate

00:24:11,440 --> 00:24:15,580
things because this is this is opting

00:24:13,390 --> 00:24:21,010
out of the safety checks rather than

00:24:15,580 --> 00:24:22,900
opting into them so as opposed to the

00:24:21,010 --> 00:24:25,300
the sanitizers that you have to

00:24:22,900 --> 00:24:30,640
remember to run after all the changes to

00:24:25,300 --> 00:24:33,190
your code this is this is the default is

00:24:30,640 --> 00:24:36,850
too bright safe code and you can opt out

00:24:33,190 --> 00:24:39,630
of it if you need to if you want more

00:24:36,850 --> 00:24:42,790
information on writing unsafe code

00:24:39,630 --> 00:24:44,440
there's this great talk for building an

00:24:42,790 --> 00:24:46,660
unsafe foundation the other neat thing

00:24:44,440 --> 00:24:49,600
is you can build safe abstractions out

00:24:46,660 --> 00:24:54,030
of unsafe code and there's a whole book

00:24:49,600 --> 00:24:54,030
on unsafe code called the Resta nomicon

00:24:56,940 --> 00:25:04,330
like air breaks sometimes don't stop a

00:25:00,220 --> 00:25:07,000
train rust doesn't prevent all problems

00:25:04,330 --> 00:25:09,610
you might have a software it does not

00:25:07,000 --> 00:25:12,040
prevent you from having logic bugs it

00:25:09,610 --> 00:25:13,660
can't tell that you meant to tell the

00:25:12,040 --> 00:25:15,610
program to do one thing and it's

00:25:13,660 --> 00:25:18,040
actually doing another so you stole the

00:25:15,610 --> 00:25:22,180
need things like tests and you still

00:25:18,040 --> 00:25:24,610
need to write things like buzzers but by

00:25:22,180 --> 00:25:27,220
choosing to use rust you're getting

00:25:24,610 --> 00:25:30,970
memory safety you're not going to have

00:25:27,220 --> 00:25:33,070
all those problems that C has so let's

00:25:30,970 --> 00:25:35,410
go back through the reasons that you

00:25:33,070 --> 00:25:36,790
might choose C and C what we're trading

00:25:35,410 --> 00:25:40,300
off because there's always trade-offs

00:25:36,790 --> 00:25:44,250
and in any sort of decision you might

00:25:40,300 --> 00:25:47,490
make performance Russ is on the order of

00:25:44,250 --> 00:25:49,710
C's performance there aren't the the

00:25:47,490 --> 00:25:51,820
additional checks that Russ does are

00:25:49,710 --> 00:25:54,280
mostly at compile time

00:25:51,820 --> 00:25:57,490
there isn't a garbage collector it isn't

00:25:54,280 --> 00:26:01,330
checking much at run time you can still

00:25:57,490 --> 00:26:03,100
get we have the goal of having zero cost

00:26:01,330 --> 00:26:06,430
abstractions which means that the

00:26:03,100 --> 00:26:08,920
abstractions you use our compiled down

00:26:06,430 --> 00:26:11,430
to code that you could not write better

00:26:08,920 --> 00:26:14,590
by hand of course there are always

00:26:11,430 --> 00:26:16,030
things we can improve on but zero cost

00:26:14,590 --> 00:26:18,940
abstractions are what we're aiming for

00:26:16,030 --> 00:26:21,760
we're hoping that rust will perform as

00:26:18,940 --> 00:26:25,210
well as C in the situations you want to

00:26:21,760 --> 00:26:29,260
use it portability

00:26:25,210 --> 00:26:32,470
Russ compiles to LVM intermediate

00:26:29,260 --> 00:26:34,450
representation so you can write rust and

00:26:32,470 --> 00:26:36,430
compile it for any platform that ll be

00:26:34,450 --> 00:26:38,680
I'm Ken

00:26:36,430 --> 00:26:41,740
there are C compilers that target

00:26:38,680 --> 00:26:44,740
platforms that LVM doesn't there could

00:26:41,740 --> 00:26:47,380
be a non LOV M back-end for us there

00:26:44,740 --> 00:26:49,000
isn't one yet there isn't I reason that

00:26:47,380 --> 00:26:52,420
why there couldn't be other than people

00:26:49,000 --> 00:26:54,940
putting in the work so if you need to

00:26:52,420 --> 00:26:56,920
write code for one of the platforms that

00:26:54,940 --> 00:27:00,040
Russ doesn't support that could be a

00:26:56,920 --> 00:27:03,430
deal-breaker for you but we do support a

00:27:00,040 --> 00:27:07,270
lot of platforms so this one is a little

00:27:03,430 --> 00:27:10,540
bit of both the big downside is rust is

00:27:07,270 --> 00:27:14,370
more complex and we are trying all the

00:27:10,540 --> 00:27:17,320
time to lessen the learning curve

00:27:14,370 --> 00:27:20,020
through books and video courses and and

00:27:17,320 --> 00:27:22,300
various learning materials there's

00:27:20,020 --> 00:27:26,500
definitely more features and syntax and

00:27:22,300 --> 00:27:29,050
C but we're trying to express complex

00:27:26,500 --> 00:27:32,170
ideas such that the compiler can

00:27:29,050 --> 00:27:36,610
understand them and that that does take

00:27:32,170 --> 00:27:41,080
more syntax and more complexity to

00:27:36,610 --> 00:27:43,120
express if you have legacy code a neat

00:27:41,080 --> 00:27:46,120
thing is that you can write extern

00:27:43,120 --> 00:27:49,360
functions that let you call C from rust

00:27:46,120 --> 00:27:51,730
and rust from C and a lot of languages

00:27:49,360 --> 00:27:56,290
also have a way to interface with C so

00:27:51,730 --> 00:27:59,730
you can use that so to say call rust

00:27:56,290 --> 00:28:03,820
from Python or call Ruby from rust I

00:27:59,730 --> 00:28:06,820
actually have a whole talk on porting a

00:28:03,820 --> 00:28:09,070
library the softly compression library

00:28:06,820 --> 00:28:10,120
that was written C porting it to rust

00:28:09,070 --> 00:28:12,400
function by function

00:28:10,120 --> 00:28:16,540
keeping it compiling and passing tests

00:28:12,400 --> 00:28:18,820
at every commit and the thing I like

00:28:16,540 --> 00:28:20,860
about this technique is that you don't

00:28:18,820 --> 00:28:22,330
even have to finish you don't have to

00:28:20,860 --> 00:28:25,600
convert the whole thing to rest to see

00:28:22,330 --> 00:28:28,210
benefit you could convert just the parts

00:28:25,600 --> 00:28:31,510
that change the most the parts that

00:28:28,210 --> 00:28:33,490
happen most bugs and you could set it

00:28:31,510 --> 00:28:35,800
aside for a while if you have other high

00:28:33,490 --> 00:28:37,630
priority things to work on but you still

00:28:35,800 --> 00:28:40,720
get those benefits along the way of

00:28:37,630 --> 00:28:43,270
converting little pieces to rust so you

00:28:40,720 --> 00:28:47,170
don't have to rewrite all of your stuff

00:28:43,270 --> 00:28:48,270
in rust to see benefits stability is one

00:28:47,170 --> 00:28:50,080
I want to spend a little more time on

00:28:48,270 --> 00:28:52,179
there is a new

00:28:50,080 --> 00:28:55,630
version of rust that comes out every six

00:28:52,179 --> 00:28:58,929
weeks we have a train really small sort

00:28:55,630 --> 00:29:00,940
of like Firefox and Chrome do so you

00:28:58,929 --> 00:29:02,850
might think that Russ is really unstable

00:29:00,940 --> 00:29:05,260
and it's gonna change all the time but

00:29:02,850 --> 00:29:07,090
we have really strong backwards

00:29:05,260 --> 00:29:11,320
compatibility guarantees we've committed

00:29:07,090 --> 00:29:14,140
to rust 100 came out in May 2015 so

00:29:11,320 --> 00:29:17,049
we've been stable and shipping stable

00:29:14,140 --> 00:29:21,039
codes every six weeks since then there

00:29:17,049 --> 00:29:22,570
is we do have a little bit of an out

00:29:21,039 --> 00:29:24,100
we've given ourselves we reserve the

00:29:22,570 --> 00:29:25,510
right to fixing piler bugs patch safety

00:29:24,100 --> 00:29:26,889
holes and change type in France in ways

00:29:25,510 --> 00:29:29,049
that occasionally require a new type of

00:29:26,889 --> 00:29:30,100
annotations we do not expect any of

00:29:29,049 --> 00:29:32,350
these changes cause headaches when

00:29:30,100 --> 00:29:35,919
upgrading rust so we can fix our own

00:29:32,350 --> 00:29:38,440
bugs in practice what this is meant we

00:29:35,919 --> 00:29:41,679
we run a survey every year in the 2018

00:29:38,440 --> 00:29:44,320
survey we had a question that said has

00:29:41,679 --> 00:29:46,240
upgrading broken your code and ninety

00:29:44,320 --> 00:29:50,919
two point six percent of people have

00:29:46,240 --> 00:29:52,659
said no it has not broken your code this

00:29:50,919 --> 00:29:53,769
question I feel like we need to change

00:29:52,659 --> 00:29:56,580
the wording of it a little bit because

00:29:53,769 --> 00:30:00,100
it doesn't really distinguish between

00:29:56,580 --> 00:30:01,809
breaking compilation which is what our

00:30:00,100 --> 00:30:05,159
stability guarantees are really about

00:30:01,809 --> 00:30:07,990
versus breaking runtime behavior or

00:30:05,159 --> 00:30:10,149
slowing down your code at runtime or

00:30:07,990 --> 00:30:13,809
speeding it up you don't you broken it

00:30:10,149 --> 00:30:15,519
in that way and I'd like to I'd like to

00:30:13,809 --> 00:30:16,960
be able to get into those problems a

00:30:15,519 --> 00:30:19,919
little bit more and see how we're really

00:30:16,960 --> 00:30:25,960
doing on our compiled time

00:30:19,919 --> 00:30:28,889
stability guarantees another part that I

00:30:25,960 --> 00:30:32,500
think part of our stability story that

00:30:28,889 --> 00:30:35,289
will let us last for 40 years is that we

00:30:32,500 --> 00:30:38,620
have a goal of stability without

00:30:35,289 --> 00:30:41,649
stagnation we want to be able to evolve

00:30:38,620 --> 00:30:43,929
rust to learn from our own mistakes to

00:30:41,649 --> 00:30:46,600
make the language easier to use and to

00:30:43,929 --> 00:30:49,139
learn while still not breaking our

00:30:46,600 --> 00:30:53,049
backwards compatibility guarantees and

00:30:49,139 --> 00:30:56,610
the mechanism that rust we've designed

00:30:53,049 --> 00:30:59,799
to use in rust is called additions and

00:30:56,610 --> 00:31:02,110
this is a link to a detailed

00:30:59,799 --> 00:31:03,800
specification of what additions are I'm

00:31:02,110 --> 00:31:09,140
gonna go over the hi love

00:31:03,800 --> 00:31:10,700
idea mainly they are opt-in about every

00:31:09,140 --> 00:31:14,390
three years is what we're thinking we've

00:31:10,700 --> 00:31:17,450
just made Russ 2018 edition and the

00:31:14,390 --> 00:31:19,610
original edition of Russ is 2015 so we

00:31:17,450 --> 00:31:24,740
have two editions right now what they

00:31:19,610 --> 00:31:26,090
are is it the biggest the biggest change

00:31:24,740 --> 00:31:28,490
we want to make that's not backwards

00:31:26,090 --> 00:31:30,710
compatible is adding new keywords for

00:31:28,490 --> 00:31:33,290
adding new features so for instance

00:31:30,710 --> 00:31:37,550
we're going to be adding asynchronous

00:31:33,290 --> 00:31:39,890
functions to Russ the language soon and

00:31:37,550 --> 00:31:42,620
we wanted the async keyword to be able

00:31:39,890 --> 00:31:45,290
to do that but your existing code might

00:31:42,620 --> 00:31:47,480
have function async so if we added that

00:31:45,290 --> 00:31:51,050
of the keyword your function would no

00:31:47,480 --> 00:31:54,980
longer be a valid bus function so we

00:31:51,050 --> 00:31:57,860
added this idea of additions so that if

00:31:54,980 --> 00:32:01,130
you opt in to treating your code as Russ

00:31:57,860 --> 00:32:03,740
28:18 edition code then async would be a

00:32:01,130 --> 00:32:07,190
keyword but if you did nothing to your

00:32:03,740 --> 00:32:09,710
code upgraded your compiler it would

00:32:07,190 --> 00:32:12,410
still treat it as rust 2015 edition code

00:32:09,710 --> 00:32:16,850
and it would continue to treat async as

00:32:12,410 --> 00:32:19,010
not a keyword and can you could compile

00:32:16,850 --> 00:32:21,350
your code when I first heard of this

00:32:19,010 --> 00:32:22,910
idea I thought it sounded terrible from

00:32:21,350 --> 00:32:26,000
a compiler maintenance point of view you

00:32:22,910 --> 00:32:28,270
have to maintain two ways to use every

00:32:26,000 --> 00:32:31,550
feature forever because we wanted to

00:32:28,270 --> 00:32:35,200
commit to all editions being supported

00:32:31,550 --> 00:32:38,150
forever but it's actually not that bad

00:32:35,200 --> 00:32:40,420
the way editions way the compiler works

00:32:38,150 --> 00:32:43,310
today is you have your Russ source code

00:32:40,420 --> 00:32:46,280
the compiler turns it into a high level

00:32:43,310 --> 00:32:48,610
intermediate representation and then

00:32:46,280 --> 00:32:52,910
turns it into mid level intermediate

00:32:48,610 --> 00:32:55,610
representation then turns it into LLVM

00:32:52,910 --> 00:32:58,670
intermediate representation and LLVM

00:32:55,610 --> 00:33:01,040
turns it into machine code a lot of the

00:32:58,670 --> 00:33:03,170
complex analysis that the compiler does

00:33:01,040 --> 00:33:05,630
such as borrow checking optimizations

00:33:03,170 --> 00:33:07,550
and code generation happen at this

00:33:05,630 --> 00:33:11,120
mirror this mid level intermediate

00:33:07,550 --> 00:33:14,120
representation level the way additions

00:33:11,120 --> 00:33:17,150
have been implemented is that they're

00:33:14,120 --> 00:33:18,830
kind of at the surface level they

00:33:17,150 --> 00:33:21,320
affect the code the source code that

00:33:18,830 --> 00:33:24,050
you'll write and they affect the high

00:33:21,320 --> 00:33:25,730
level intermediate representation but

00:33:24,050 --> 00:33:29,030
once you get to the mid level

00:33:25,730 --> 00:33:31,280
representation it the mid level stuff is

00:33:29,030 --> 00:33:35,450
all the same whether it would no matter

00:33:31,280 --> 00:33:37,640
which Edition you came from so all this

00:33:35,450 --> 00:33:40,250
complex analysis code can stay the same

00:33:37,640 --> 00:33:44,390
for both editions and it's only the the

00:33:40,250 --> 00:33:51,679
first part of this conversion that is an

00:33:44,390 --> 00:33:56,000
a maintenance burden this because -

00:33:51,679 --> 00:33:58,580
because the compiler understands both

00:33:56,000 --> 00:34:02,780
editions and multiple editions once we

00:33:58,580 --> 00:34:05,780
have more and can compile 2015 code or

00:34:02,780 --> 00:34:09,590
2018 code that means we're not going to

00:34:05,780 --> 00:34:12,620
have an ecosystem split Russ Russ 2015

00:34:09,590 --> 00:34:17,179
project can depend on a project written

00:34:12,620 --> 00:34:19,220
using Russ 2018 idioms and vice versa so

00:34:17,179 --> 00:34:21,649
it doesn't matter if all your

00:34:19,220 --> 00:34:24,530
dependencies have opted in or not the

00:34:21,649 --> 00:34:29,419
same compiler can understand either code

00:34:24,530 --> 00:34:31,520
and can compile it all together and the

00:34:29,419 --> 00:34:34,129
important things about this is that you

00:34:31,520 --> 00:34:36,500
get to pick when you decide to change

00:34:34,129 --> 00:34:38,419
which Edition you want to use you can

00:34:36,500 --> 00:34:41,149
keep upgrading your compiler every six

00:34:38,419 --> 00:34:43,280
weeks but you don't have to switch on

00:34:41,149 --> 00:34:46,190
that flag to change the idioms until you

00:34:43,280 --> 00:34:49,280
decide the benefits outweigh the cost of

00:34:46,190 --> 00:34:53,780
upgrading and never is a totally valid

00:34:49,280 --> 00:34:57,580
choice we plan to support Russ 28 2015

00:34:53,780 --> 00:35:01,700
edition code for as long as rust exists

00:34:57,580 --> 00:35:03,890
in order to decrease the burden of

00:35:01,700 --> 00:35:06,760
switching editions we also have a tool

00:35:03,890 --> 00:35:10,520
call it Russ fix that for as many

00:35:06,760 --> 00:35:13,220
changes that we can do automatically it

00:35:10,520 --> 00:35:14,750
will apply those changes and fix up your

00:35:13,220 --> 00:35:17,120
code and move you to the new edition

00:35:14,750 --> 00:35:18,470
automatically so we're trying to if you

00:35:17,120 --> 00:35:20,480
do want to switch to the new edition

00:35:18,470 --> 00:35:25,760
we're trying to make that as painless as

00:35:20,480 --> 00:35:28,790
possible also the editions concept I am

00:35:25,760 --> 00:35:30,410
confident that with using this to evolve

00:35:28,790 --> 00:35:30,850
the language means we're never going to

00:35:30,410 --> 00:35:33,060
have

00:35:30,850 --> 00:35:34,270
rust you oh we're not going to break

00:35:33,060 --> 00:35:39,460
backwards-compatibility

00:35:34,270 --> 00:35:43,540
so we hope to be as stable as c is for

00:35:39,460 --> 00:35:45,370
the next four years we do have a lot of

00:35:43,540 --> 00:35:47,620
things that aren't done yet with rust

00:35:45,370 --> 00:35:50,310
that might prevent you from using it in

00:35:47,620 --> 00:35:53,320
your company we don't have a standard

00:35:50,310 --> 00:35:55,420
that's going to take a long time and a

00:35:53,320 --> 00:35:57,670
lot of work we do want to get there

00:35:55,420 --> 00:36:00,880
someday but it was years and years

00:35:57,670 --> 00:36:03,460
before C has a standard so we do want to

00:36:00,880 --> 00:36:04,930
get there but we're not there yet we

00:36:03,460 --> 00:36:08,350
don't have a certified compiler that

00:36:04,930 --> 00:36:10,300
will matter in some industries we do

00:36:08,350 --> 00:36:13,960
want to have a long term support release

00:36:10,300 --> 00:36:16,060
that gets things like security fixes and

00:36:13,960 --> 00:36:17,950
certain bug fixes we don't have a policy

00:36:16,060 --> 00:36:21,760
for that yet

00:36:17,950 --> 00:36:24,070
cargo is the build tool that rust kind

00:36:21,760 --> 00:36:27,010
of expects you to use if you you don't

00:36:24,070 --> 00:36:28,660
use that it gets a little hard to tinker

00:36:27,010 --> 00:36:31,030
with and some companies have build

00:36:28,660 --> 00:36:35,500
systems that everything needs to feed

00:36:31,030 --> 00:36:39,610
into and we have work to do to make

00:36:35,500 --> 00:36:43,120
cargo fit into build systems that are if

00:36:39,610 --> 00:36:45,640
you have we have an open-source package

00:36:43,120 --> 00:36:48,490
registry for open source code we don't

00:36:45,640 --> 00:36:50,260
have good solutions for libraries that

00:36:48,490 --> 00:36:53,530
you might want to keep private only

00:36:50,260 --> 00:36:55,270
share within your company and the

00:36:53,530 --> 00:36:57,670
ecosystem is still growing

00:36:55,270 --> 00:36:59,410
so there might not be a library for

00:36:57,670 --> 00:37:02,410
everything you might want to do in rust

00:36:59,410 --> 00:37:05,850
yet but these are all things we're

00:37:02,410 --> 00:37:08,170
working on and we hope to get there soon

00:37:05,850 --> 00:37:12,280
another reason I think we're going to

00:37:08,170 --> 00:37:14,230
last is that there are today a number of

00:37:12,280 --> 00:37:17,440
large enterprise software companies

00:37:14,230 --> 00:37:21,190
using rusts and they've invested their

00:37:17,440 --> 00:37:23,530
products in rust so they're invested in

00:37:21,190 --> 00:37:26,410
rusts future the biggest one of course

00:37:23,530 --> 00:37:29,470
is Mozilla he heard of the Firefox

00:37:26,410 --> 00:37:32,410
quantum release a while ago where

00:37:29,470 --> 00:37:35,430
Firefox got a lot faster one big reason

00:37:32,410 --> 00:37:38,440
of that was a big component

00:37:35,430 --> 00:37:41,290
got that was rewritten in rust were

00:37:38,440 --> 00:37:44,140
shipped with that the component was the

00:37:41,290 --> 00:37:47,500
CSS rendering that can

00:37:44,140 --> 00:37:50,680
now render all the CSS properties in

00:37:47,500 --> 00:37:54,370
your page in parallel and they did some

00:37:50,680 --> 00:37:56,970
analysis of the security bugs in this

00:37:54,370 --> 00:37:59,800
component that was written in C++ and

00:37:56,970 --> 00:38:00,310
found that since the beginning of

00:37:59,800 --> 00:38:03,460
Firefox

00:38:00,310 --> 00:38:07,270
there were 69 security bugs in this CSS

00:38:03,460 --> 00:38:08,740
component if they could have gone back

00:38:07,270 --> 00:38:11,050
in time than written in rust from the

00:38:08,740 --> 00:38:15,610
beginning rust would have prevented 51

00:38:11,050 --> 00:38:17,770
of those which is about 3/4 of them so I

00:38:15,610 --> 00:38:22,120
think that's a pretty good improvement

00:38:17,770 --> 00:38:28,420
on the security and of this Firefox of

00:38:22,120 --> 00:38:30,490
honey and the speed increase - if you

00:38:28,420 --> 00:38:32,290
know patio 11 on Twitter Patrick

00:38:30,490 --> 00:38:34,870
McKenzie he has this word he likes to

00:38:32,290 --> 00:38:36,700
say a Bama goo book soft and it

00:38:34,870 --> 00:38:40,720
represents a number of big software

00:38:36,700 --> 00:38:43,720
companies Apple I don't know of any

00:38:40,720 --> 00:38:46,090
public uses of rust at Apple

00:38:43,720 --> 00:38:49,090
they have Swift which actually is really

00:38:46,090 --> 00:38:52,180
similar to rust I was in the Swift talk

00:38:49,090 --> 00:38:54,970
earlier and they have a lot of the same

00:38:52,180 --> 00:38:56,980
problems and a lot of trying to solve

00:38:54,970 --> 00:38:58,870
the same problems that rust is but use

00:38:56,980 --> 00:39:00,100
different words for it so I was like

00:38:58,870 --> 00:39:02,800
sitting there trying to translate him

00:39:00,100 --> 00:39:04,660
like ah stats oh oh they're hitting the

00:39:02,800 --> 00:39:07,810
same problem that we are they're really

00:39:04,660 --> 00:39:09,780
similar and there is cross-pollination

00:39:07,810 --> 00:39:12,430
there

00:39:09,780 --> 00:39:13,600
so we're I hope there's more in the

00:39:12,430 --> 00:39:15,780
future and we can both learn from each

00:39:13,600 --> 00:39:15,780
other

00:39:16,410 --> 00:39:22,660
Amazon is the Amma part of this and they

00:39:20,710 --> 00:39:27,430
recently announced their fire cracker

00:39:22,660 --> 00:39:29,920
micro VM Google is also kind of

00:39:27,430 --> 00:39:31,690
secretive they have this fuchsia

00:39:29,920 --> 00:39:33,010
operating system project that they

00:39:31,690 --> 00:39:35,860
haven't really said what it's for yet

00:39:33,010 --> 00:39:38,380
but the code for it is like on the

00:39:35,860 --> 00:39:42,910
internet and you know open source and

00:39:38,380 --> 00:39:46,960
there's parts that in rust facebook has

00:39:42,910 --> 00:39:54,900
the Mononoke mercurial server to manage

00:39:46,960 --> 00:39:58,090
their huge mercurial mono repo that the

00:39:54,900 --> 00:40:00,810
canonical implementation of mercurial

00:39:58,090 --> 00:40:05,260
couldn't handle it fast enough and

00:40:00,810 --> 00:40:08,500
Microsoft announced they have this IOT

00:40:05,260 --> 00:40:11,020
edge platform that does analytics like

00:40:08,500 --> 00:40:14,440
on IOT devices and then sends the

00:40:11,020 --> 00:40:16,210
results to server so that's a Pam a GU

00:40:14,440 --> 00:40:20,860
box off we've got four out of five of

00:40:16,210 --> 00:40:22,420
those using rest publicly the fifth

00:40:20,860 --> 00:40:27,670
reason that I think we're set up to last

00:40:22,420 --> 00:40:32,530
is our project governance like the

00:40:27,670 --> 00:40:33,910
trains the adoption of this is not only

00:40:32,530 --> 00:40:36,670
for the technical reasons there's also

00:40:33,910 --> 00:40:39,940
political reasons and I think we are

00:40:36,670 --> 00:40:41,950
we're building a good foundation here we

00:40:39,940 --> 00:40:43,300
don't have a be DFL a benevolent

00:40:41,950 --> 00:40:47,350
dictator for life there's not just one

00:40:43,300 --> 00:40:50,290
person making final decisions on on rust

00:40:47,350 --> 00:40:52,470
we have a number of teams and working

00:40:50,290 --> 00:40:54,340
groups made up of multiple people

00:40:52,470 --> 00:40:58,120
responsible for different parts of

00:40:54,340 --> 00:41:00,670
language and we have a lot of different

00:40:58,120 --> 00:41:02,950
people represented on those teams and

00:41:00,670 --> 00:41:05,860
working groups we have programming

00:41:02,950 --> 00:41:09,100
language theorists people with PhDs and

00:41:05,860 --> 00:41:11,950
programming languages we have people

00:41:09,100 --> 00:41:15,460
using rust for a product for a company

00:41:11,950 --> 00:41:17,410
we have people using rust for fun we

00:41:15,460 --> 00:41:20,350
have people who come from the low level

00:41:17,410 --> 00:41:22,150
languages like C and C++ we have people

00:41:20,350 --> 00:41:25,630
from high level languages like I come

00:41:22,150 --> 00:41:27,580
from Ruby and in our surveys Python is

00:41:25,630 --> 00:41:31,090
consistently the number one language

00:41:27,580 --> 00:41:32,800
that people come to rust from and if

00:41:31,090 --> 00:41:35,440
there's people from functional languages

00:41:32,800 --> 00:41:40,060
like Haskell that bring a lot of the

00:41:35,440 --> 00:41:43,390
functional influence interests and our

00:41:40,060 --> 00:41:45,310
big decisions are made in public by AI

00:41:43,390 --> 00:41:48,640
system of requests for comments

00:41:45,310 --> 00:41:50,440
proposals that everyone can see and the

00:41:48,640 --> 00:41:53,950
teams responsible for making the final

00:41:50,440 --> 00:41:57,460
decision state their reasoning in public

00:41:53,950 --> 00:41:59,770
on these RFC's so while we might not

00:41:57,460 --> 00:42:02,590
make a decision on something in the

00:41:59,770 --> 00:42:04,330
exact way you might want our our hope is

00:42:02,590 --> 00:42:06,580
that you'll at least understand why

00:42:04,330 --> 00:42:10,920
we're making those decisions and feel

00:42:06,580 --> 00:42:10,920
like we have heard your point of view

00:42:11,200 --> 00:42:15,640
I feel really strongly that as an

00:42:14,349 --> 00:42:20,470
open-source person that this is

00:42:15,640 --> 00:42:22,960
important that this isn't driven Rus

00:42:20,470 --> 00:42:26,140
direction is not driven by a corporate

00:42:22,960 --> 00:42:27,790
closed entity making decisions in secret

00:42:26,140 --> 00:42:29,680
that you have no idea why they're doing

00:42:27,790 --> 00:42:33,010
and we're not going to take it in some

00:42:29,680 --> 00:42:34,059
surprising direction if we do you'll if

00:42:33,010 --> 00:42:36,280
we do take it in a different direction

00:42:34,059 --> 00:42:39,520
you'll know that we're doing it you'll

00:42:36,280 --> 00:42:41,349
be able to see us do that another big

00:42:39,520 --> 00:42:43,059
you think part of our governance is that

00:42:41,349 --> 00:42:46,569
we have a code of conduct and have since

00:42:43,059 --> 00:42:48,010
the language was open-source and I loved

00:42:46,569 --> 00:42:49,599
that this has been since the beginning

00:42:48,010 --> 00:42:51,369
so we don't have to have the argument

00:42:49,599 --> 00:42:53,290
about whether we should adopt one or not

00:42:51,369 --> 00:42:55,299
that decision has already been made we

00:42:53,290 --> 00:42:58,420
have one we are trying to make a

00:42:55,299 --> 00:43:02,829
professional space for professionals to

00:42:58,420 --> 00:43:05,710
work on technology and without problems

00:43:02,829 --> 00:43:07,150
we're not perfect but we are trying

00:43:05,710 --> 00:43:10,000
you're acknowledging that there are

00:43:07,150 --> 00:43:13,500
problems that we need to be handling to

00:43:10,000 --> 00:43:18,339
make rust a welcoming place for everyone

00:43:13,500 --> 00:43:20,770
so just to sum up these are my five

00:43:18,339 --> 00:43:26,049
reasons why I think Russ is going to be

00:43:20,770 --> 00:43:27,670
able to last the next four years and now

00:43:26,049 --> 00:43:30,069
we're going to talk a little bit more

00:43:27,670 --> 00:43:34,390
about the railroad industry and how that

00:43:30,069 --> 00:43:37,920
relates to what we're doing today

00:43:34,390 --> 00:43:40,630
this the software industry has a

00:43:37,920 --> 00:43:43,359
reputation for being a little bit

00:43:40,630 --> 00:43:47,309
arrogant we think we can do things

00:43:43,359 --> 00:43:50,619
better than other fields have done them

00:43:47,309 --> 00:43:52,720
there's the time that a software company

00:43:50,619 --> 00:43:55,240
thought they could do juice better than

00:43:52,720 --> 00:43:57,430
other people and actually didn't work

00:43:55,240 --> 00:44:01,780
any better than squeezing juice packet

00:43:57,430 --> 00:44:08,950
by hand there was the time that lift

00:44:01,780 --> 00:44:12,520
reinvented the bus and there's the time

00:44:08,950 --> 00:44:15,010
that there were people stuck in a cave

00:44:12,520 --> 00:44:16,920
and Elon Musk thought he could do cave

00:44:15,010 --> 00:44:20,020
rescues better than the people who

00:44:16,920 --> 00:44:21,190
specialized in that sort of thing so so

00:44:20,020 --> 00:44:22,660
we think we're better than other

00:44:21,190 --> 00:44:24,610
industries if you just add a little

00:44:22,660 --> 00:44:25,990
software we can totally fix these long

00:44:24,610 --> 00:44:31,030
standing problems that other industries

00:44:25,990 --> 00:44:32,620
have had were so much better I think I

00:44:31,030 --> 00:44:34,390
think we have to we have to work to

00:44:32,620 --> 00:44:39,100
prove it if we if we actually are better

00:44:34,390 --> 00:44:42,040
we need to show that we're better and we

00:44:39,100 --> 00:44:44,890
binding regulation to do this but

00:44:42,040 --> 00:44:47,020
there's a problem is that it's it's

00:44:44,890 --> 00:44:49,930
pretty easy for everyone to understand

00:44:47,020 --> 00:44:50,680
that if you can't stop a train people

00:44:49,930 --> 00:44:52,660
are gonna get hurt

00:44:50,680 --> 00:44:54,640
people are gonna kill pretty uneasy to

00:44:52,660 --> 00:44:57,070
understand that being on top of a moving

00:44:54,640 --> 00:45:01,360
train in any weather is a dangerous

00:44:57,070 --> 00:45:04,690
thing but it's it's not easy to

00:45:01,360 --> 00:45:08,860
understand what what memory on safety

00:45:04,690 --> 00:45:11,460
even is and it's not easy even easy for

00:45:08,860 --> 00:45:16,690
us to see what the effects of that are

00:45:11,460 --> 00:45:20,410
so like I'm trying to imagine the the

00:45:16,690 --> 00:45:23,350
Senate transcripts from reading that in

00:45:20,410 --> 00:45:26,650
the future from now of software people

00:45:23,350 --> 00:45:29,920
trying to explain memory on safety to

00:45:26,650 --> 00:45:33,940
senators and it's terrible it's I don't

00:45:29,920 --> 00:45:35,800
see this going well so I don't think I

00:45:33,940 --> 00:45:38,650
don't think government is going to

00:45:35,800 --> 00:45:42,730
improve the safety of software but I

00:45:38,650 --> 00:45:46,720
think we can improve ourselves we can be

00:45:42,730 --> 00:45:49,590
our own improved informed consumers that

00:45:46,720 --> 00:45:52,180
demand that our dependencies are safer

00:45:49,590 --> 00:45:55,000
before we incorporate them into our

00:45:52,180 --> 00:45:58,270
software because we understand our own

00:45:55,000 --> 00:46:02,380
problems that is the part that we can

00:45:58,270 --> 00:46:06,780
show that we are better the railroad

00:46:02,380 --> 00:46:08,950
industry got really started in 1830

00:46:06,780 --> 00:46:13,390
Westinghouse invented the air brake in

00:46:08,950 --> 00:46:18,100
1869 and then everyone was using it by

00:46:13,390 --> 00:46:23,620
1900 so this is about 80 years you know

00:46:18,100 --> 00:46:27,040
no that's not right 7 years about 40

00:46:23,620 --> 00:46:31,480
years to invent a safer thing about 30

00:46:27,040 --> 00:46:34,090
years for people to start using it rust

00:46:31,480 --> 00:46:37,790
became stable in 2015 I'm arguing that

00:46:34,090 --> 00:46:39,620
that is a better safer sea

00:46:37,790 --> 00:46:43,610
I don't know how long it's gonna take us

00:46:39,620 --> 00:46:46,040
to adopt something that's memory safe

00:46:43,610 --> 00:46:48,410
can we do better than the railroad

00:46:46,040 --> 00:46:51,470
industry I don't know

00:46:48,410 --> 00:46:55,450
I want us to be better I'm not sure if

00:46:51,470 --> 00:46:55,450
we are better I hope that we're better

00:46:55,690 --> 00:47:00,170
all right that's that's most of my

00:46:58,370 --> 00:47:03,170
arguments if you're still feeling a

00:47:00,170 --> 00:47:06,740
little skeptical that's totally fine I'm

00:47:03,170 --> 00:47:08,960
I'm willing to be wrong I I am willing

00:47:06,740 --> 00:47:12,230
for us and to not be the solution as

00:47:08,960 --> 00:47:14,180
long as we do something let's just do

00:47:12,230 --> 00:47:15,830
something to fix these memory safety

00:47:14,180 --> 00:47:19,880
problems that keep happening over and

00:47:15,830 --> 00:47:20,840
over and over again maybe maybe it's not

00:47:19,880 --> 00:47:21,590
gonna be rushed maybe there's something

00:47:20,840 --> 00:47:25,730
better than rest

00:47:21,590 --> 00:47:29,330
maybe it's sake dick go to the next talk

00:47:25,730 --> 00:47:31,160
I'm pleading fortitude maybe maybe it's

00:47:29,330 --> 00:47:33,890
go there's a go talk tomorrow

00:47:31,160 --> 00:47:34,940
or maybe maybe it's all of them maybe

00:47:33,890 --> 00:47:37,130
it's there's not gonna be one

00:47:34,940 --> 00:47:37,970
replacement maybe there's different

00:47:37,130 --> 00:47:40,520
replacements that are better for

00:47:37,970 --> 00:47:42,470
different situations that's fine I'm

00:47:40,520 --> 00:47:45,140
totally okay with that you don't have to

00:47:42,470 --> 00:47:47,420
choose rest I just I just want us to

00:47:45,140 --> 00:47:52,390
stop making the same mistakes over and

00:47:47,420 --> 00:47:52,390
over again let's make some new mistakes

00:47:53,520 --> 00:47:59,090
[Applause]

00:47:54,350 --> 00:48:02,349
[Music]

00:47:59,090 --> 00:48:02,349
[Applause]

00:48:02,820 --> 00:48:09,100
okay again this is the link to my slides

00:48:06,550 --> 00:48:10,260
and links that I reference i'm carol's

00:48:09,100 --> 00:48:13,540
ten cents

00:48:10,260 --> 00:48:15,550
there's a code for everyone to have that

00:48:13,540 --> 00:48:17,230
will get you 40% off anything I'm

00:48:15,550 --> 00:48:17,560
Manning calm and that code is right

00:48:17,230 --> 00:48:19,900
there

00:48:17,560 --> 00:48:22,060
and I would like to thank my test

00:48:19,900 --> 00:48:24,340
audience my daughter Vivian and my cat

00:48:22,060 --> 00:48:28,960
baby they were very patient provide

00:48:24,340 --> 00:48:31,900
valuable feedback okay let's see what

00:48:28,960 --> 00:48:43,600
questions we have let me stop mirroring

00:48:31,900 --> 00:48:47,770
here or start marine weather okay where

00:48:43,600 --> 00:48:50,910
are my questions okay let's see which

00:48:47,770 --> 00:48:50,910
ones I like best

00:49:05,790 --> 00:49:13,119
okay let's do what's with the name rust

00:49:10,359 --> 00:49:18,280
there's there's multiple stories here

00:49:13,119 --> 00:49:20,950
the people who started rust enjoyed

00:49:18,280 --> 00:49:24,910
riding bicycles and bicycles often have

00:49:20,950 --> 00:49:28,630
to deal with rust the logo our logo is

00:49:24,910 --> 00:49:32,200
kind of a bicycle gear there's also a

00:49:28,630 --> 00:49:36,720
fungus called rust that grows on wheat

00:49:32,200 --> 00:49:39,400
sometimes that is a potential

00:49:36,720 --> 00:49:43,809
inspiration that has been suggested as

00:49:39,400 --> 00:49:48,220
why why rust I like to think of it as

00:49:43,809 --> 00:49:49,450
something something something stable

00:49:48,220 --> 00:49:53,319
something that has been around a long

00:49:49,450 --> 00:49:54,910
time a stable strong coating on the

00:49:53,319 --> 00:49:58,270
outside there's actually this Corten

00:49:54,910 --> 00:50:00,700
steel the u.s. steel tower in Pittsburgh

00:49:58,270 --> 00:50:03,790
has built out of it it's steel that is

00:50:00,700 --> 00:50:06,130
meant to rust on purpose to protect it

00:50:03,790 --> 00:50:09,790
instead of paint so I like thinking of

00:50:06,130 --> 00:50:11,920
Corten steel so partha I liked your

00:50:09,790 --> 00:50:17,369
question if you are still here I have an

00:50:11,920 --> 00:50:18,579
envelope for you there yeah thank you

00:50:17,369 --> 00:50:20,589
okay

00:50:18,579 --> 00:50:23,680
why would you recommend rust Oberg oh I

00:50:20,589 --> 00:50:25,630
also like this question so anonymous who

00:50:23,680 --> 00:50:29,589
asked this if you would make your way to

00:50:25,630 --> 00:50:31,059
the front while I'm answering there are

00:50:29,589 --> 00:50:33,490
a couple of big differences in rust and

00:50:31,059 --> 00:50:37,630
go there actually is aiming for slightly

00:50:33,490 --> 00:50:38,920
different spaces I they I think they get

00:50:37,630 --> 00:50:40,390
compared a lot because they came out

00:50:38,920 --> 00:50:43,960
around the same time and they're both

00:50:40,390 --> 00:50:46,059
aiming to be kind of C++ alternatives go

00:50:43,960 --> 00:50:49,000
has a garbage collector which might be a

00:50:46,059 --> 00:50:51,210
deal breaker in your application so if

00:50:49,000 --> 00:50:53,920
you can't have something at runtime

00:50:51,210 --> 00:50:58,329
using resources then I would recommend

00:50:53,920 --> 00:51:00,790
rust if you're trying to interface with

00:50:58,329 --> 00:51:05,980
Google products I think go is probably

00:51:00,790 --> 00:51:09,220
going to be a really smooth way to have

00:51:05,980 --> 00:51:11,940
everything all in the same language for

00:51:09,220 --> 00:51:11,940
simplicity purposes

00:51:14,120 --> 00:51:23,540
and like hmm yeah III think you should

00:51:21,770 --> 00:51:26,000
check them both out and you should make

00:51:23,540 --> 00:51:27,920
I think one of them is going to resonate

00:51:26,000 --> 00:51:30,800
with you over the other so I think you

00:51:27,920 --> 00:51:34,600
should do some intro programming in both

00:51:30,800 --> 00:51:37,430
of them and and make your own choice so

00:51:34,600 --> 00:51:41,720
is someone going to fess up to asking

00:51:37,430 --> 00:51:44,240
that question for a free code no okay

00:51:41,720 --> 00:51:47,810
all right arguably one of the reasons

00:51:44,240 --> 00:51:49,730
for choosing C these days is a great IDE

00:51:47,810 --> 00:51:51,650
support does the rest have solid IV

00:51:49,730 --> 00:51:54,050
integration we're working on it this is

00:51:51,650 --> 00:51:58,760
another one of those things that we know

00:51:54,050 --> 00:52:00,230
we need to do better at we there's this

00:51:58,760 --> 00:52:02,660
thing called the language server

00:52:00,230 --> 00:52:05,540
protocol that is trying to standardize

00:52:02,660 --> 00:52:08,300
the way that languages can talk to II's

00:52:05,540 --> 00:52:10,070
and tell the IDE things about the code

00:52:08,300 --> 00:52:13,220
and we have an implementation that does

00:52:10,070 --> 00:52:20,480
code completion inline errors jump to

00:52:13,220 --> 00:52:22,340
definition and BS code has had the best

00:52:20,480 --> 00:52:24,530
maintained plug-in that uses the

00:52:22,340 --> 00:52:28,970
language server protocol IntelliJ also

00:52:24,530 --> 00:52:32,660
has a pretty good rust support I'm I so

00:52:28,970 --> 00:52:35,060
I did Ruby before bus and there and I

00:52:32,660 --> 00:52:37,850
love the book working effectively with

00:52:35,060 --> 00:52:39,020
legacy code by Michael feathers and but

00:52:37,850 --> 00:52:41,150
in that book he talks a lot about

00:52:39,020 --> 00:52:44,410
leaning on your tools using your ID

00:52:41,150 --> 00:52:46,730
using automatic refactorings and in Ruby

00:52:44,410 --> 00:52:48,200
because of all the meta programming and

00:52:46,730 --> 00:52:51,080
like you didn't take a string and run it

00:52:48,200 --> 00:52:52,700
as a function and you just you can't use

00:52:51,080 --> 00:52:54,530
some of those tools because you can't be

00:52:52,700 --> 00:52:56,300
sure that you caught everywhere that

00:52:54,530 --> 00:52:58,970
that function is called because it might

00:52:56,300 --> 00:53:04,190
be called dynamically from something so

00:52:58,970 --> 00:53:05,900
I had a lot of jealousy for ie tools

00:53:04,190 --> 00:53:07,910
while I was writing Ruby and I'm looking

00:53:05,900 --> 00:53:10,400
forward to the days that we have those

00:53:07,910 --> 00:53:13,280
tools for rust they're not there yet but

00:53:10,400 --> 00:53:17,080
they're there more possible to make than

00:53:13,280 --> 00:53:21,690
they are in Ruby so does anyone want to

00:53:17,080 --> 00:53:24,420
claim that question thank you very much

00:53:21,690 --> 00:53:27,250
[Music]

00:53:24,420 --> 00:53:34,000
okay let's see what other question I

00:53:27,250 --> 00:53:45,970
like um hmm latest question that's very

00:53:34,000 --> 00:53:48,359
good question oh okay

00:53:45,970 --> 00:53:52,359
this is this is a good question I

00:53:48,359 --> 00:53:56,109
mentioned a new async in 2018 magician

00:53:52,359 --> 00:53:58,210
and the it's async already in the 2015

00:53:56,109 --> 00:54:01,029
mission it's actually in neither Edition

00:53:58,210 --> 00:54:01,750
right now when we created the 2018

00:54:01,029 --> 00:54:04,119
magician

00:54:01,750 --> 00:54:06,849
we just reserved the keyword for async

00:54:04,119 --> 00:54:09,910
and we wanted to have a sync support

00:54:06,849 --> 00:54:14,500
done by the time we shipped the Edition

00:54:09,910 --> 00:54:15,250
but it's it's not it's not done people

00:54:14,500 --> 00:54:18,039
are working on it right now

00:54:15,250 --> 00:54:20,589
there's a lot of open discussion on the

00:54:18,039 --> 00:54:22,359
RFC's about the exact syntax the exact

00:54:20,589 --> 00:54:26,259
way it's gonna work so if you're

00:54:22,359 --> 00:54:29,740
interested you can go check that out but

00:54:26,259 --> 00:54:32,079
it's is not an either and if once it is

00:54:29,740 --> 00:54:34,390
done it will probably be available in

00:54:32,079 --> 00:54:37,029
both it's just that the syntax in Rus

00:54:34,390 --> 00:54:38,940
2015 isn't is not going to use a key

00:54:37,029 --> 00:54:43,509
word so it's not going to be as nice as

00:54:38,940 --> 00:54:46,720
syntax as it will be in Rus 2018 so who

00:54:43,509 --> 00:54:50,380
asks the async question all right

00:54:46,720 --> 00:54:52,230
then that is all the codes I have and I

00:54:50,380 --> 00:54:54,560
think I'm just about out of time so

00:54:52,230 --> 00:54:59,530
thank you very much for having me

00:54:54,560 --> 00:54:59,530
[Applause]

00:55:04,890 --> 00:55:06,950

YouTube URL: https://www.youtube.com/watch?v=A3AdN7U24iU


