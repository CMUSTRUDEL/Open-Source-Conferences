Title: Rust 2018: Access All Areas • Florian Gilcher • GOTO 2019
Publication date: 2019-08-16
Playlist: Other Conferences 2019
Description: 
	This presentation was recorded at GOTO Amsterdam 2019. #GOTOcon #GOTOams
http://gotoams.nl

Florian Gilcher - Founder of Ferrous Systems, Music Addict, Rubyist, Rust Trainer & Backend Programmer

ABSTRACT
2018 has seen a massive push towards improving Rust's usability. This comes both with ergonomics improvements, but also with stabilisation of a lot of use-case specific features.
Rust is now usable and is used on everything from bare metal microcontrollers over small IoT gateway systems up to server programming. It can be deployed on phones just as it can be deployed in your web browser through Webassembly (WASM). That makes the newest edition of Rust the only currently available memory-safe language that can be used in almost any contexts without the need of a runtime.
This talk gives you a tour of what is possible with just one language and just one compiler right now.
Finally, Rust 2018 includes a lot of ergonomics improvements like a better async/await-story and cleverer safety [...]

Download slides and read the full abstract here:
https://gotoams.nl/2019/sessions/751

https://twitter.com/GOTOamst
https://www.facebook.com/GOTOConference
https://www.linkedin.com/company/goto-
http://gotocon.com
#Rustlang #IoT #WebAssembly #WASM

Looking for a unique learning experience?
Attend the next GOTO Conference near you! Get your ticket at http://gotocon.com

SUBSCRIBE TO OUR CHANNEL - new videos posted almost daily.
https://www.youtube.com/user/GotoConferences/?sub_confirmation=1
Captions: 
	00:00:03,550 --> 00:00:07,840
[Music]

00:00:12,549 --> 00:00:21,230
thank you everyone so my talk is called

00:00:18,410 --> 00:00:22,730
roast access all areas because one of

00:00:21,230 --> 00:00:25,640
the big movements for the language last

00:00:22,730 --> 00:00:28,160
last year was we actually finalized the

00:00:25,640 --> 00:00:30,919
ability to deploy rust on basically any

00:00:28,160 --> 00:00:35,630
target theoretically talk about the

00:00:30,919 --> 00:00:38,149
practice in a second but first of all I

00:00:35,630 --> 00:00:42,079
have a word about doing off strong who

00:00:38,149 --> 00:00:44,030
was mentioned this morning because he

00:00:42,079 --> 00:00:48,350
has been very important for me I have

00:00:44,030 --> 00:00:50,089
read program yelling in 2009 and what I

00:00:48,350 --> 00:00:53,089
really liked in the book is how he

00:00:50,089 --> 00:00:56,239
insisted on how concepts strictly

00:00:53,089 --> 00:00:58,039
applied can solve problems in the case

00:00:56,239 --> 00:00:59,719
of air lying it's shared-nothing and

00:00:58,039 --> 00:01:01,460
message passing and how strictly

00:00:59,719 --> 00:01:03,800
applying them makes a lot of problems

00:01:01,460 --> 00:01:07,040
easier by relying on that the language

00:01:03,800 --> 00:01:08,390
always does this yeah that's kind of the

00:01:07,040 --> 00:01:11,540
point sometimes you have to invent a

00:01:08,390 --> 00:01:13,910
language for that and Russ comes pretty

00:01:11,540 --> 00:01:14,960
much out of the same way that if we want

00:01:13,910 --> 00:01:16,880
to solve a couple of fundamental

00:01:14,960 --> 00:01:19,190
problems we need to invent a new

00:01:16,880 --> 00:01:22,180
language for that instead of trying to

00:01:19,190 --> 00:01:25,370
paper over in the languages that we have

00:01:22,180 --> 00:01:27,050
so who you're mine i'm florian you can

00:01:25,370 --> 00:01:28,880
find me on twitter and on get up i have

00:01:27,050 --> 00:01:30,470
two companies one that runs

00:01:28,880 --> 00:01:32,870
infrastructure and another one that's

00:01:30,470 --> 00:01:35,570
called ferry systems which is rust

00:01:32,870 --> 00:01:38,120
consultancy I am a rust programmer and

00:01:35,570 --> 00:01:40,490
trainer you can find me on rust experts

00:01:38,120 --> 00:01:42,230
I'm also a mozillian sometimes people

00:01:40,490 --> 00:01:45,200
think because of my activity in the rust

00:01:42,230 --> 00:01:47,000
project I am employed at Mozilla that's

00:01:45,200 --> 00:01:48,860
not the case but people who are closely

00:01:47,000 --> 00:01:51,410
aligned with Mozilla's mission I usually

00:01:48,860 --> 00:01:53,090
called millions previously I did ten

00:01:51,410 --> 00:01:54,650
years of ruby community work so there

00:01:53,090 --> 00:01:56,270
was a point where people stopped

00:01:54,650 --> 00:01:58,970
referring to me as the Ruby person in

00:01:56,270 --> 00:02:01,430
Berlin and then moved to hey that's rust

00:01:58,970 --> 00:02:04,190
florian I personally started learning

00:02:01,430 --> 00:02:05,960
rust in 2013 mostly out of curiosity it

00:02:04,190 --> 00:02:08,899
was a new language it was still in

00:02:05,960 --> 00:02:11,269
research work and I co-founded the

00:02:08,899 --> 00:02:13,489
Berlin user group I then started

00:02:11,269 --> 00:02:15,590
organizing two of the larger stress

00:02:13,489 --> 00:02:18,040
conferences rust fest and oxidized conf

00:02:15,590 --> 00:02:20,740
witches and

00:02:18,040 --> 00:02:22,840
focused on embedded hardware and I'm a

00:02:20,740 --> 00:02:25,030
project member since 2015 most of the

00:02:22,840 --> 00:02:27,280
time the community team recently I

00:02:25,030 --> 00:02:29,830
started leading the website team I'm now

00:02:27,280 --> 00:02:31,870
in the core team as well and I've got a

00:02:29,830 --> 00:02:36,280
quick question to the room who here has

00:02:31,870 --> 00:02:37,840
been exposed to rust who has okay not so

00:02:36,280 --> 00:02:40,540
many people because I'm going to give

00:02:37,840 --> 00:02:42,100
you a detail of an explanation of what

00:02:40,540 --> 00:02:43,750
it is also I have a couple of

00:02:42,100 --> 00:02:46,090
endorsements I gave a talk about rust

00:02:43,750 --> 00:02:47,709
I'd go to 2017 and the best YouTube

00:02:46,090 --> 00:02:49,630
comment is I don't trust any programmer

00:02:47,709 --> 00:02:51,370
that deliberately uses Ruby and Java I

00:02:49,630 --> 00:02:53,680
guess I still use Ruby and Java for

00:02:51,370 --> 00:02:55,870
great effect so please if you don't

00:02:53,680 --> 00:02:56,620
immediately start using rust that's all

00:02:55,870 --> 00:03:00,060
fine

00:02:56,620 --> 00:03:02,320
there's tons of very good software out

00:03:00,060 --> 00:03:04,480
just quickly about the rust project I'm

00:03:02,320 --> 00:03:06,489
presenting the work of 180 team members

00:03:04,480 --> 00:03:08,050
and over 5,000 contributors over the

00:03:06,489 --> 00:03:09,310
last years and that's just the core

00:03:08,050 --> 00:03:10,840
repositories of the language

00:03:09,310 --> 00:03:13,660
culminating in a large release in

00:03:10,840 --> 00:03:15,700
December last year rust itself was

00:03:13,660 --> 00:03:17,500
released in May 3rd 2015 so we're

00:03:15,700 --> 00:03:21,280
talking about a language that's roughly

00:03:17,500 --> 00:03:23,799
four years old and a little bit older so

00:03:21,280 --> 00:03:25,720
what is rust our current claim is it's a

00:03:23,799 --> 00:03:30,640
language empowering everyone to build

00:03:25,720 --> 00:03:33,880
reliable and efficient software before

00:03:30,640 --> 00:03:35,769
the 2018 release we said well these

00:03:33,880 --> 00:03:39,070
three things that are important about

00:03:35,769 --> 00:03:42,940
rust first of all the language is safe

00:03:39,070 --> 00:03:44,350
second it's concurrent but it's fast the

00:03:42,940 --> 00:03:46,959
problem with that is those are the

00:03:44,350 --> 00:03:48,940
language level concerns also what is

00:03:46,959 --> 00:03:52,450
safe is something that people can have

00:03:48,940 --> 00:03:56,860
long twitter fights about and we changed

00:03:52,450 --> 00:03:58,570
that nowadays we say the three important

00:03:56,860 --> 00:04:02,440
parts of rust are performance

00:03:58,570 --> 00:04:05,380
reliability and productivity all of

00:04:02,440 --> 00:04:07,780
these three and a mission is to bring

00:04:05,380 --> 00:04:11,260
that to everyone it's literally in the

00:04:07,780 --> 00:04:13,480
claim so we need a language that scales

00:04:11,260 --> 00:04:16,510
up and down so it should work on small

00:04:13,480 --> 00:04:20,260
targets down to micro controllers up to

00:04:16,510 --> 00:04:24,070
server level targets big data

00:04:20,260 --> 00:04:25,930
applications databases so it must

00:04:24,070 --> 00:04:27,849
provide high abstractions and low

00:04:25,930 --> 00:04:28,660
abstractions also very cheap

00:04:27,849 --> 00:04:30,639
abstractions

00:04:28,660 --> 00:04:32,319
they must be useful but they must all

00:04:30,639 --> 00:04:33,879
to be picked through because if we want

00:04:32,319 --> 00:04:36,699
to work close to the hardware we

00:04:33,879 --> 00:04:38,800
sometimes need to rip them open and work

00:04:36,699 --> 00:04:40,210
with what we have on the inside and they

00:04:38,800 --> 00:04:42,669
should cost nothing

00:04:40,210 --> 00:04:44,529
the problem with the thing that's called

00:04:42,669 --> 00:04:46,060
zero cost abstraction is if you're

00:04:44,529 --> 00:04:48,099
talking about a zero cost abstraction

00:04:46,060 --> 00:04:49,330
what we mean is you couldn't hand code

00:04:48,099 --> 00:04:51,009
it better yourself

00:04:49,330 --> 00:04:53,469
we built you an abstraction that does

00:04:51,009 --> 00:04:56,289
the thing that is the most efficient if

00:04:53,469 --> 00:04:58,360
the abstraction does not do exactly what

00:04:56,289 --> 00:05:00,969
you need in that case it might still

00:04:58,360 --> 00:05:04,599
cost you something so maybe another

00:05:00,969 --> 00:05:07,180
approach is better but also um economics

00:05:04,599 --> 00:05:10,590
in care we have a unified tooling for

00:05:07,180 --> 00:05:13,719
all of those targets we have extense

00:05:10,590 --> 00:05:15,400
extensible tooling so if you need

00:05:13,719 --> 00:05:17,199
something for a specific use case you

00:05:15,400 --> 00:05:19,090
can plug into the current tooling and

00:05:17,199 --> 00:05:20,650
make it do what you want and we have a

00:05:19,090 --> 00:05:24,400
very strict backwards compatibility

00:05:20,650 --> 00:05:26,259
strategy so the program problems to

00:05:24,400 --> 00:05:28,930
solve that I want to talk about is

00:05:26,259 --> 00:05:30,879
memory safety and the stock resource

00:05:28,930 --> 00:05:33,069
consumption resource handling

00:05:30,879 --> 00:05:35,139
concurrency and parallelism dealing with

00:05:33,069 --> 00:05:38,889
external data resilience and integration

00:05:35,139 --> 00:05:41,860
into existing code let's get started the

00:05:38,889 --> 00:05:44,050
talk has in the title rust 2018 access

00:05:41,860 --> 00:05:46,180
all areas so just quickly clear up what

00:05:44,050 --> 00:05:49,770
rosters an ad is it's a new language

00:05:46,180 --> 00:05:52,750
profile to enable all of the above we

00:05:49,770 --> 00:05:54,909
shipped it in December 2018 it was not a

00:05:52,750 --> 00:05:57,849
breaking change the rust compiler still

00:05:54,909 --> 00:06:01,509
understands old rust and you can mix and

00:05:57,849 --> 00:06:03,460
match libraries just if you opt in to

00:06:01,509 --> 00:06:07,029
the new profile the language is a little

00:06:03,460 --> 00:06:09,669
bit more agronomic rust in itself is a c

00:06:07,029 --> 00:06:11,289
and c++ competitor as a language itself

00:06:09,669 --> 00:06:16,050
at lands somewhere in the middle that

00:06:11,289 --> 00:06:18,509
aesthetically memories safe and it has

00:06:16,050 --> 00:06:20,680
features that also make it compatible

00:06:18,509 --> 00:06:25,139
competitive with higher-level languages

00:06:20,680 --> 00:06:27,819
like Scala Java or for example also go

00:06:25,139 --> 00:06:29,589
from its model itself rust is a native

00:06:27,819 --> 00:06:32,199
programming language it's a values and

00:06:29,589 --> 00:06:35,560
function language much like C is and it

00:06:32,199 --> 00:06:37,120
comes with no notable runtime so it has

00:06:35,560 --> 00:06:38,439
no active runtime it has no garbage

00:06:37,120 --> 00:06:39,969
collector everything that I present in

00:06:38,439 --> 00:06:42,250
this talk is actually being resolved by

00:06:39,969 --> 00:06:44,800
the compiler at compile time and not

00:06:42,250 --> 00:06:46,300
during runtime still it is memory

00:06:44,800 --> 00:06:48,220
safe so it looks a little bit like a

00:06:46,300 --> 00:06:49,810
garbage collector language it is a

00:06:48,220 --> 00:06:51,849
generic language I wouldn't introduce

00:06:49,810 --> 00:06:56,229
that I assume everyone here was exposed

00:06:51,849 --> 00:06:58,419
to Java and I won't go into higher

00:06:56,229 --> 00:07:00,759
detail and that we use the same syntax

00:06:58,419 --> 00:07:02,770
so it should be kind of natural it has

00:07:00,759 --> 00:07:04,629
detailed error handling at no catchable

00:07:02,770 --> 00:07:06,789
exceptions it's a very very detailed

00:07:04,629 --> 00:07:08,830
language it's kind of like what if we

00:07:06,789 --> 00:07:12,669
had a language that's a nitpicker but in

00:07:08,830 --> 00:07:14,710
a good way we usually call the compiler

00:07:12,669 --> 00:07:19,509
complainer we might also call it an Iron

00:07:14,710 --> 00:07:24,370
Maiden so let's look at the code example

00:07:19,509 --> 00:07:26,229
quickly so he said rust is a structures

00:07:24,370 --> 00:07:30,699
and functions language so we have a data

00:07:26,229 --> 00:07:33,099
structure here with two integers inside

00:07:30,699 --> 00:07:35,680
exactly 32 bits so I know the size of it

00:07:33,099 --> 00:07:39,280
in memory so I can talk in rust about a

00:07:35,680 --> 00:07:40,120
directly about memory layout I can just

00:07:39,280 --> 00:07:43,930
construct it

00:07:40,120 --> 00:07:45,909
I can allocate it on the heap that works

00:07:43,930 --> 00:07:47,770
in rust by a special type that's called

00:07:45,909 --> 00:07:49,659
box with special types that heap

00:07:47,770 --> 00:07:51,460
allocate the rust is a language that

00:07:49,659 --> 00:07:53,770
differentiates between a stack and the

00:07:51,460 --> 00:07:56,500
heap but there's nothing more than I

00:07:53,770 --> 00:07:58,419
need to do what happens here is the

00:07:56,500 --> 00:07:59,979
moment this program ends it actually

00:07:58,419 --> 00:08:02,680
starts deallocating all of that memory

00:07:59,979 --> 00:08:04,110
and then quits the program and that

00:08:02,680 --> 00:08:06,580
works through a system called ownership

00:08:04,110 --> 00:08:09,460
and a value introduced and harrassed

00:08:06,580 --> 00:08:11,259
program is exclusively owned and this

00:08:09,460 --> 00:08:14,349
ownership can be moved so for example I

00:08:11,259 --> 00:08:16,389
can't capacit into a function but if for

00:08:14,349 --> 00:08:18,639
any reason this value runs out of scope

00:08:16,389 --> 00:08:21,159
it is dropped and this moment is clearly

00:08:18,639 --> 00:08:22,479
defined the moment is exactly here

00:08:21,159 --> 00:08:24,190
because that's the end of the scope

00:08:22,479 --> 00:08:26,139
that's the moment that the allocation

00:08:24,190 --> 00:08:28,330
happens so there's no garbage collection

00:08:26,139 --> 00:08:31,389
happening that might defer that it will

00:08:28,330 --> 00:08:33,940
actually happen at that point and that

00:08:31,389 --> 00:08:35,409
can be used for great effect one of the

00:08:33,940 --> 00:08:37,209
misunderstandings about ownership is

00:08:35,409 --> 00:08:39,969
that it's just for memory handling it is

00:08:37,209 --> 00:08:43,419
actually very very useful for any kind

00:08:39,969 --> 00:08:45,430
of resource handling so all rust values

00:08:43,419 --> 00:08:47,800
have a trackable region memory where

00:08:45,430 --> 00:08:49,540
they active and that means they can be

00:08:47,800 --> 00:08:51,660
used for resource management because I

00:08:49,540 --> 00:08:54,790
know when they become inactive and

00:08:51,660 --> 00:08:56,470
ownership manages resources memory is

00:08:54,790 --> 00:08:58,780
always one of them but it doesn't have

00:08:56,470 --> 00:09:02,920
to be one example for that is

00:08:58,780 --> 00:09:05,980
file so if I have a function that reads

00:09:02,920 --> 00:09:07,600
a file I just pass it as a path and I

00:09:05,980 --> 00:09:10,810
get a string back which is the contents

00:09:07,600 --> 00:09:13,210
of the file I'm talking about that

00:09:10,810 --> 00:09:15,370
resulting in a second

00:09:13,210 --> 00:09:16,780
I open the file and because I don't

00:09:15,370 --> 00:09:19,990
return the file I actually don't do

00:09:16,780 --> 00:09:23,620
anything after reading it the file will

00:09:19,990 --> 00:09:25,660
automatically be closed and that's kind

00:09:23,620 --> 00:09:27,880
of this resource handling semantics

00:09:25,660 --> 00:09:30,280
because I can attach to a file pointer

00:09:27,880 --> 00:09:34,000
oh if it runs out of scope also called

00:09:30,280 --> 00:09:38,770
closed on it the question mark here is

00:09:34,000 --> 00:09:41,880
our error handling operator just quickly

00:09:38,770 --> 00:09:46,300
about that result rust has no exceptions

00:09:41,880 --> 00:09:49,990
what we use is we use a result type that

00:09:46,300 --> 00:09:53,290
has in something that we call an enum it

00:09:49,990 --> 00:09:56,080
has two so-called variants okay an error

00:09:53,290 --> 00:09:58,570
which signal the thing that you want to

00:09:56,080 --> 00:10:00,280
do worked or it didn't and if it

00:09:58,570 --> 00:10:04,420
returned one of them from a function I

00:10:00,280 --> 00:10:06,430
actually asked the caller to before

00:10:04,420 --> 00:10:08,890
actually handling the data checking hey

00:10:06,430 --> 00:10:12,490
was it okay or do you actually have to

00:10:08,890 --> 00:10:14,230
handle an error so results are plain

00:10:12,490 --> 00:10:17,740
data like for example also in go or

00:10:14,230 --> 00:10:19,210
other languages what it dis allows me to

00:10:17,740 --> 00:10:20,350
do if I have another function the

00:10:19,210 --> 00:10:22,660
implementation is pretty unimportant

00:10:20,350 --> 00:10:25,570
that's print file and close but the

00:10:22,660 --> 00:10:27,880
important thing is it takes a file reads

00:10:25,570 --> 00:10:31,810
it fully and because it lets a drop out

00:10:27,880 --> 00:10:33,700
of scope it closes it so what happens if

00:10:31,810 --> 00:10:39,010
I try to furcal this function twice on a

00:10:33,700 --> 00:10:42,430
file what happens is I get an error what

00:10:39,010 --> 00:10:45,430
it tells me is oh you moved ownership

00:10:42,430 --> 00:10:48,160
you call the function on this piece of

00:10:45,430 --> 00:10:49,270
data gave away ownership and then you're

00:10:48,160 --> 00:10:51,930
trying to call it again that doesn't

00:10:49,270 --> 00:10:54,370
work because you don't own it anymore

00:10:51,930 --> 00:10:57,400
practically speaking what it just made

00:10:54,370 --> 00:10:59,650
sure is that the second time I call the

00:10:57,400 --> 00:11:02,640
I call this function it actually gets a

00:10:59,650 --> 00:11:04,900
valid file pointer if I wouldn't do that

00:11:02,640 --> 00:11:06,160
the first call to it would succeed

00:11:04,900 --> 00:11:07,690
because it can actually read from that

00:11:06,160 --> 00:11:10,420
file pointer close it in the end and the

00:11:07,690 --> 00:11:11,980
second call would not succeed because

00:11:10,420 --> 00:11:14,520
the file pointer has been accidentally

00:11:11,980 --> 00:11:14,520
closed in the me

00:11:15,610 --> 00:11:19,610
just as a comparison how that works in

00:11:17,959 --> 00:11:22,399
other languages I'm picking Ruby here

00:11:19,610 --> 00:11:25,670
because being an old term rubyist what

00:11:22,399 --> 00:11:28,970
Ruby has Ruby has a file API that uses a

00:11:25,670 --> 00:11:31,040
closure to make sure that if you call

00:11:28,970 --> 00:11:35,259
file open and you didn't then execute

00:11:31,040 --> 00:11:38,990
this closure it called closed in the end

00:11:35,259 --> 00:11:40,910
so they don't forget closing files and

00:11:38,990 --> 00:11:45,829
having dangling fine boil five points

00:11:40,910 --> 00:11:48,439
around that can be circumvented because

00:11:45,829 --> 00:11:50,689
what I can do is that can somehow

00:11:48,439 --> 00:11:52,819
because Ruby is a garbage collected

00:11:50,689 --> 00:11:55,879
language so I can take any amount of

00:11:52,819 --> 00:11:58,279
references on any kind of data so what I

00:11:55,879 --> 00:12:00,470
can do is I can do file open and intend

00:11:58,279 --> 00:12:05,079
say I want an iterator over each line of

00:12:00,470 --> 00:12:08,629
the file return that and oops that

00:12:05,079 --> 00:12:10,220
doesn't work because the definition of

00:12:08,629 --> 00:12:11,540
that closure was once the closure ends

00:12:10,220 --> 00:12:14,600
you close the file and then I'm trying

00:12:11,540 --> 00:12:16,040
to read from it bang this is obviously a

00:12:14,600 --> 00:12:19,879
simple example no one would write that

00:12:16,040 --> 00:12:21,529
but slice only have so much space that's

00:12:19,879 --> 00:12:23,480
also the annoying part of it if you run

00:12:21,529 --> 00:12:25,100
into such a bug it's usually a 1,000

00:12:23,480 --> 00:12:26,449
line code base and then it's hard to

00:12:25,100 --> 00:12:28,699
figure out where you had accidentally

00:12:26,449 --> 00:12:30,259
closed it so what happened we're

00:12:28,699 --> 00:12:31,610
referencing through the file through to

00:12:30,259 --> 00:12:33,139
the file through an iterator we moved

00:12:31,610 --> 00:12:36,110
the iterator out of scope the file was

00:12:33,139 --> 00:12:40,429
closed we try to iterate back let's try

00:12:36,110 --> 00:12:42,079
that in rust we can have a look at the

00:12:40,429 --> 00:12:45,050
book and it says hello rust has

00:12:42,079 --> 00:12:48,370
references and we can try to also get a

00:12:45,050 --> 00:12:52,160
similar situation where we set up a

00:12:48,370 --> 00:12:55,279
reader that references the file this is

00:12:52,160 --> 00:12:56,990
the referencing operator ampersand moot

00:12:55,279 --> 00:12:59,059
is a special kind of reference to which

00:12:56,990 --> 00:13:02,509
it can actually mutate the end I come to

00:12:59,059 --> 00:13:07,240
that and so you open that bufferedreader

00:13:02,509 --> 00:13:11,389
and then I'm returning the reader this

00:13:07,240 --> 00:13:13,790
actually doesn't work the compiler will

00:13:11,389 --> 00:13:15,860
tell me pretty clearly cannot return

00:13:13,790 --> 00:13:20,569
value referencing a local variable

00:13:15,860 --> 00:13:23,660
called file because with the rules that

00:13:20,569 --> 00:13:26,559
I laid out file must be closed by the

00:13:23,660 --> 00:13:26,559
end of this function

00:13:27,220 --> 00:13:31,730
so we're referencing the file through

00:13:29,870 --> 00:13:33,170
this reader kind of a similar pattern

00:13:31,730 --> 00:13:35,420
we're moving the read out of scope by

00:13:33,170 --> 00:13:40,130
returning the files closed scope ends

00:13:35,420 --> 00:13:42,560
the compiler Texas as illegal references

00:13:40,130 --> 00:13:46,700
in rust are subject to a system called

00:13:42,560 --> 00:13:48,860
borrowing references cannot outlive what

00:13:46,700 --> 00:13:52,910
they borrowed from so I always have to

00:13:48,860 --> 00:13:55,130
reference valid memory and mutable and

00:13:52,910 --> 00:13:57,080
immutable references cannot alia so I

00:13:55,130 --> 00:14:01,400
showed the m % loot there's also the

00:13:57,080 --> 00:14:04,550
ampersand reference which doesn't allow

00:14:01,400 --> 00:14:06,380
me to mutate through it and the

00:14:04,550 --> 00:14:08,270
important thing is if you have a mutable

00:14:06,380 --> 00:14:10,120
reference in rust you can also be

00:14:08,270 --> 00:14:12,830
guaranteed that it's the only one

00:14:10,120 --> 00:14:14,300
everywhere in the program so if you have

00:14:12,830 --> 00:14:15,820
a mutable reference there's no other

00:14:14,300 --> 00:14:20,620
part of the program that can actually

00:14:15,820 --> 00:14:23,570
currently even read that memory

00:14:20,620 --> 00:14:26,570
references are always valid much like in

00:14:23,570 --> 00:14:29,780
C++ and the interesting notion here is

00:14:26,570 --> 00:14:32,690
mutable state and rust is allowed shared

00:14:29,780 --> 00:14:36,350
state in rust is also allowed but shape

00:14:32,690 --> 00:14:37,820
mutable state is not allowed and that's

00:14:36,350 --> 00:14:40,910
the problem that we're usually running

00:14:37,820 --> 00:14:44,720
into in parallelism and concurrency and

00:14:40,910 --> 00:14:46,820
we're also seeing a thing here talking

00:14:44,720 --> 00:14:48,050
about illegal States files and rust are

00:14:46,820 --> 00:14:50,270
defined in such a way that they are

00:14:48,050 --> 00:14:53,330
always open if you have a file type it's

00:14:50,270 --> 00:14:55,280
always open so rust gives you methods to

00:14:53,330 --> 00:14:57,170
make illegal states it representable

00:14:55,280 --> 00:14:59,330
even if you want the file API that

00:14:57,170 --> 00:15:01,640
represents both open closed you have to

00:14:59,330 --> 00:15:04,040
use a different one that models these

00:15:01,640 --> 00:15:08,330
states appropriately and gives

00:15:04,040 --> 00:15:10,640
appropriate API in contrast to that the

00:15:08,330 --> 00:15:12,860
scope with closures approach that Ruby

00:15:10,640 --> 00:15:14,540
has and other languages have as well are

00:15:12,860 --> 00:15:18,430
just about not forgetting to call the

00:15:14,540 --> 00:15:20,870
close call on a file but they still have

00:15:18,430 --> 00:15:26,750
closed file pointers which are often not

00:15:20,870 --> 00:15:29,780
very useful so how do we get out of that

00:15:26,750 --> 00:15:33,290
it's actually pretty simple we changed

00:15:29,780 --> 00:15:35,990
this it used to be a moot file here we

00:15:33,290 --> 00:15:38,480
change this to file and don't reference

00:15:35,990 --> 00:15:39,810
the file what happens then the

00:15:38,480 --> 00:15:42,630
bufferedreader takes

00:15:39,810 --> 00:15:44,400
ownership of the file reps it builds a

00:15:42,630 --> 00:15:48,240
buffer around it and then I can both

00:15:44,400 --> 00:15:50,760
pass both back from it and then I can

00:15:48,240 --> 00:15:53,000
for example iterate over the lines print

00:15:50,760 --> 00:15:55,980
them out with line numbers or whatever

00:15:53,000 --> 00:15:58,260
so pretty often in rust that's something

00:15:55,980 --> 00:16:01,110
that people often run against if they

00:15:58,260 --> 00:16:02,640
can't make a reference valid properly

00:16:01,110 --> 00:16:04,230
they shouldn't reference but instead

00:16:02,640 --> 00:16:06,390
pass values around that's what we're

00:16:04,230 --> 00:16:08,040
doing here we came back from trying to

00:16:06,390 --> 00:16:12,900
pass out references to actually passing

00:16:08,040 --> 00:16:14,820
values around that's important here

00:16:12,900 --> 00:16:16,890
bufferedreader now owns the file so it's

00:16:14,820 --> 00:16:18,480
also the unique owner of the file so it

00:16:16,890 --> 00:16:20,100
can also be sure that no one else is

00:16:18,480 --> 00:16:24,630
currently referencing the file mutating

00:16:20,100 --> 00:16:27,060
it writing to it or whatever and that's

00:16:24,630 --> 00:16:28,950
a thing that happens pretty often in

00:16:27,060 --> 00:16:31,920
rust there's a lot of API is that come

00:16:28,950 --> 00:16:33,360
in three things owned borrowed mutiply

00:16:31,920 --> 00:16:36,810
borrowed these are the three things that

00:16:33,360 --> 00:16:38,640
you hear most about for example if you

00:16:36,810 --> 00:16:41,370
talk about iterators pretty simple

00:16:38,640 --> 00:16:45,360
concept I have a collection in this case

00:16:41,370 --> 00:16:46,830
a vector 1 2 3 and I want to iterate

00:16:45,360 --> 00:16:48,900
over it and there's three ways of

00:16:46,830 --> 00:16:51,540
actually doing it which is first of all

00:16:48,900 --> 00:16:53,040
the owned iterator we're still which

00:16:51,540 --> 00:16:54,780
again closes over the collection you

00:16:53,040 --> 00:16:56,940
completely forget what collection it was

00:16:54,780 --> 00:16:58,860
the only thing you get out is I can

00:16:56,940 --> 00:17:01,260
iterate over it and then you iterate

00:16:58,860 --> 00:17:03,480
over it and once the iterator drops

00:17:01,260 --> 00:17:06,810
everything they all the data that it

00:17:03,480 --> 00:17:09,780
closed over actually drops as well this

00:17:06,810 --> 00:17:12,949
is what it means to take ownership if it

00:17:09,780 --> 00:17:15,300
just call eater I will get the immutable

00:17:12,949 --> 00:17:17,550
borrowing iterators so I can borrow

00:17:15,300 --> 00:17:19,020
I can I can iterate over that lecture as

00:17:17,550 --> 00:17:20,640
much as I want I can actually get an

00:17:19,020 --> 00:17:22,319
infinite number of these iterators at

00:17:20,640 --> 00:17:24,630
the same time because they can all be

00:17:22,319 --> 00:17:27,270
sure that the data is not being

00:17:24,630 --> 00:17:30,900
manipulated and keeps at the same length

00:17:27,270 --> 00:17:32,730
and everything and I also have a mutable

00:17:30,900 --> 00:17:34,880
iterator or it can iterate over and a

00:17:32,730 --> 00:17:37,320
plus 1 to each of those numbers or

00:17:34,880 --> 00:17:39,120
whatever and they're the guarantee

00:17:37,320 --> 00:17:41,160
applies that if I have this iterator I

00:17:39,120 --> 00:17:43,679
know that I can mutate the collection

00:17:41,160 --> 00:17:45,960
but no one else can see it so there is

00:17:43,679 --> 00:17:49,350
no sharing of this mutable state at that

00:17:45,960 --> 00:17:52,140
moment so before that if I had immutable

00:17:49,350 --> 00:17:53,400
references or immutable iterators active

00:17:52,140 --> 00:17:55,170
I would have to

00:17:53,400 --> 00:18:01,080
remove them all before actually starting

00:17:55,170 --> 00:18:05,760
with us and this relates nicely to

00:18:01,080 --> 00:18:07,230
parallel processing so we have quite a

00:18:05,760 --> 00:18:09,510
number of great frameworks for parallel

00:18:07,230 --> 00:18:12,600
programming that also work on very very

00:18:09,510 --> 00:18:15,120
small devices they are mixable with

00:18:12,600 --> 00:18:17,190
concurrent approaches so we do allow

00:18:15,120 --> 00:18:19,530
parallel and concurrent programming in

00:18:17,190 --> 00:18:21,360
the same language but all that is safe

00:18:19,530 --> 00:18:24,450
from data races because data races

00:18:21,360 --> 00:18:26,010
happen in the moment where I can observe

00:18:24,450 --> 00:18:27,900
someone manipulating the memory

00:18:26,010 --> 00:18:30,200
basically the problem is I have an

00:18:27,900 --> 00:18:32,370
immutable reference I read it

00:18:30,200 --> 00:18:34,190
someone manipulates it and then I read

00:18:32,370 --> 00:18:36,450
it again and it's something different

00:18:34,190 --> 00:18:37,740
but I have an immutable reference what's

00:18:36,450 --> 00:18:39,930
that like

00:18:37,740 --> 00:18:42,720
the guarantee of an immutable reference

00:18:39,930 --> 00:18:44,430
in rust is the value that you're that

00:18:42,720 --> 00:18:50,070
you're referencing will never change why

00:18:44,430 --> 00:18:52,590
you have that reference and just to show

00:18:50,070 --> 00:18:57,660
how this works this is again the

00:18:52,590 --> 00:19:00,030
iterator API I have another collection

00:18:57,660 --> 00:19:03,660
of i-32 32-bit integers

00:19:00,030 --> 00:19:07,050
I just want to sum them all up I want to

00:19:03,660 --> 00:19:09,600
square them and then sum them all up if

00:19:07,050 --> 00:19:11,550
I want to do this in parallel there's

00:19:09,600 --> 00:19:13,640
actually a library that allows me to

00:19:11,550 --> 00:19:17,090
just say this iterator is now parallel

00:19:13,640 --> 00:19:20,190
put it on a thread pool start running it

00:19:17,090 --> 00:19:22,080
it's kind of boring isn't it it also

00:19:20,190 --> 00:19:23,640
gives a couple of additional options

00:19:22,080 --> 00:19:24,960
like this is the convenience option with

00:19:23,640 --> 00:19:27,480
a background thread pool where it will

00:19:24,960 --> 00:19:29,940
just be applied to you can also say I

00:19:27,480 --> 00:19:32,040
want a specific thread pool to be used

00:19:29,940 --> 00:19:34,710
or whatever so you always got the option

00:19:32,040 --> 00:19:37,620
to move out of those defaults but other

00:19:34,710 --> 00:19:40,580
than that that's currently yet I get to

00:19:37,620 --> 00:19:43,440
another detail of that in a second but

00:19:40,580 --> 00:19:48,440
currently if you want to parallelize

00:19:43,440 --> 00:19:50,550
Rusco that's very easy api is to do that

00:19:48,440 --> 00:19:52,650
there's two large libraries for doing

00:19:50,550 --> 00:19:53,940
that if you ever want to do but if

00:19:52,650 --> 00:19:56,940
that's the way you want to get started

00:19:53,940 --> 00:19:58,860
with rust-eze cross beam and raion cross

00:19:56,940 --> 00:20:01,830
beam are all the base types that you

00:19:58,860 --> 00:20:05,190
want for for any kind of parallel

00:20:01,830 --> 00:20:06,410
processing several several methods for

00:20:05,190 --> 00:20:09,230
mutex a offense

00:20:06,410 --> 00:20:11,420
and whatever wet pools rayon is the

00:20:09,230 --> 00:20:17,780
library that provides these parallel

00:20:11,420 --> 00:20:20,660
iterators quickly and easily if you talk

00:20:17,780 --> 00:20:23,300
about concurrent programming that is

00:20:20,660 --> 00:20:25,190
things like Erlang does it or for

00:20:23,300 --> 00:20:26,960
example no GS so you have an event

00:20:25,190 --> 00:20:33,470
reactor potentially on a single thread

00:20:26,960 --> 00:20:36,650
or on multiple threads where you don't

00:20:33,470 --> 00:20:38,630
have web-based scheduling but actually a

00:20:36,650 --> 00:20:41,420
cooperative scheduling between all the

00:20:38,630 --> 00:20:43,490
units we have that as well also a

00:20:41,420 --> 00:20:45,380
mixable with parallel approaches the

00:20:43,490 --> 00:20:48,190
other way around works as well also safe

00:20:45,380 --> 00:20:51,560
from data races

00:20:48,190 --> 00:20:54,890
what rust allows you to model is if you

00:20:51,560 --> 00:20:57,560
have any kind of concurrent unit say

00:20:54,890 --> 00:20:59,960
thread a task on the event reactor or

00:20:57,560 --> 00:21:03,980
whatever it allows you to model which

00:20:59,960 --> 00:21:08,720
part currently owns what data and that

00:21:03,980 --> 00:21:11,210
works independent of the concurrency of

00:21:08,720 --> 00:21:14,150
probably parallelism implementation that

00:21:11,210 --> 00:21:16,990
you're currently using I'll show how

00:21:14,150 --> 00:21:18,890
that works in a second currently

00:21:16,990 --> 00:21:21,320
concurrent programming in rust looks

00:21:18,890 --> 00:21:26,210
like this because it's completely based

00:21:21,320 --> 00:21:30,290
on standard rust API and anyone here

00:21:26,210 --> 00:21:35,120
doing JavaScript was promises yeah

00:21:30,290 --> 00:21:37,850
basically the same problem so we have we

00:21:35,120 --> 00:21:40,360
have a futures type or a promises type

00:21:37,850 --> 00:21:43,600
but the only thing we currently have is

00:21:40,360 --> 00:21:46,610
methods on it to combine them so

00:21:43,600 --> 00:21:52,580
actually each of these things in for

00:21:46,610 --> 00:21:55,670
each be to end and also here are small

00:21:52,580 --> 00:21:59,180
concurrent subunits and you need to know

00:21:55,670 --> 00:22:02,240
the actual names of what of these things

00:21:59,180 --> 00:22:04,250
are concurrent actions to understand

00:22:02,240 --> 00:22:05,840
what they do also you need to use these

00:22:04,250 --> 00:22:08,350
kind of combinators to combine them in

00:22:05,840 --> 00:22:11,960
the right way that works

00:22:08,350 --> 00:22:15,980
it's verbose and very error-prone which

00:22:11,960 --> 00:22:18,410
is actually what we are removing that or

00:22:15,980 --> 00:22:20,580
we're moving towards an async of eight

00:22:18,410 --> 00:22:25,860
syntax much like

00:22:20,580 --> 00:22:28,500
script hazard so you have a look at this

00:22:25,860 --> 00:22:31,230
you have this for each Combinator that

00:22:28,500 --> 00:22:36,690
takes a function that has a specific

00:22:31,230 --> 00:22:38,820
behavior how for each works this is

00:22:36,690 --> 00:22:43,919
actually going to be replaced by a while

00:22:38,820 --> 00:22:46,890
loop that just waits on like this is a

00:22:43,919 --> 00:22:48,360
small TCP server what it does is for

00:22:46,890 --> 00:22:49,830
every incoming connection or for the

00:22:48,360 --> 00:22:53,100
incoming connections always take the

00:22:49,830 --> 00:22:54,419
next one and wait for the next one

00:22:53,100 --> 00:22:58,230
that's the operation that it's doing

00:22:54,419 --> 00:23:00,929
here and explicitly spawn of every

00:22:58,230 --> 00:23:03,450
connection handling as a second task or

00:23:00,929 --> 00:23:06,960
as a as another task on our current

00:23:03,450 --> 00:23:09,210
event reactor you don't need to

00:23:06,960 --> 00:23:12,450
understand the full density of it it's

00:23:09,210 --> 00:23:17,610
just having a special syntax for this

00:23:12,450 --> 00:23:19,710
use case makes code much much easier to

00:23:17,610 --> 00:23:22,710
read the interesting thing about the

00:23:19,710 --> 00:23:23,940
async/await syntax again is you can pick

00:23:22,710 --> 00:23:26,730
the concurrency pattern that you're

00:23:23,940 --> 00:23:29,250
using and the nice thing about being

00:23:26,730 --> 00:23:30,870
able to pick the concurrency pattern and

00:23:29,250 --> 00:23:32,610
especially implementation is that you

00:23:30,870 --> 00:23:33,990
can choose the one that's right for the

00:23:32,610 --> 00:23:37,320
device that you're currently working on

00:23:33,990 --> 00:23:40,380
an event reactor that's working on a

00:23:37,320 --> 00:23:42,470
server can just waste a couple of

00:23:40,380 --> 00:23:46,019
megabytes of memory you don't care and

00:23:42,470 --> 00:23:47,929
just for performance reasons something

00:23:46,019 --> 00:23:51,000
that needs to work on a small device

00:23:47,929 --> 00:23:53,700
most obviously use an implementation

00:23:51,000 --> 00:23:57,419
that's much much simpler the async/await

00:23:53,700 --> 00:24:00,210
syntax in itself comes with no actual

00:23:57,419 --> 00:24:02,309
cost the only thing that comes with the

00:24:00,210 --> 00:24:04,110
cost is the actual reactor that you need

00:24:02,309 --> 00:24:05,610
that you need to use to drive it and

00:24:04,110 --> 00:24:07,950
that's pretty unique that we have a

00:24:05,610 --> 00:24:10,529
syntax that's independent of the library

00:24:07,950 --> 00:24:13,110
implementation that you're using so you

00:24:10,529 --> 00:24:14,850
wouldn't need to replace the runtime

00:24:13,110 --> 00:24:16,769
system or you wouldn't need to replace

00:24:14,850 --> 00:24:18,630
it have been the rust implementation

00:24:16,769 --> 00:24:22,799
that you're using what you replace is I

00:24:18,630 --> 00:24:24,899
choose different library from our our

00:24:22,799 --> 00:24:29,070
library host and then just use that one

00:24:24,899 --> 00:24:31,889
instead there's a couple of libraries

00:24:29,070 --> 00:24:34,050
ran this the most prolific one currently

00:24:31,889 --> 00:24:35,880
being active and actives web act

00:24:34,050 --> 00:24:38,580
is an actor framework much like our lang

00:24:35,880 --> 00:24:41,490
is an activist web is a web framework

00:24:38,580 --> 00:24:43,620
implemented in it these lower level ones

00:24:41,490 --> 00:24:45,540
there's two called Tokyo and Romeo which

00:24:43,620 --> 00:24:48,570
are just the bear reactors with a little

00:24:45,540 --> 00:24:49,770
bit of a platform on top and a thing

00:24:48,570 --> 00:24:51,900
that we're currently producing within

00:24:49,770 --> 00:24:53,430
the project rust async is our agent

00:24:51,900 --> 00:24:55,980
working group called runtime that

00:24:53,430 --> 00:24:59,940
actually puts a facade on top of on top

00:24:55,980 --> 00:25:01,770
of all of that to give you a unified

00:24:59,940 --> 00:25:04,770
interface for the most basic

00:25:01,770 --> 00:25:07,380
functionality there's a little bit of

00:25:04,770 --> 00:25:09,540
magic behind this every value in rust

00:25:07,380 --> 00:25:13,230
has two additional properties and those

00:25:09,540 --> 00:25:14,940
are send and sync sin means the data can

00:25:13,230 --> 00:25:17,430
be passed between concurrent units

00:25:14,940 --> 00:25:19,260
that's much like I could take a piece of

00:25:17,430 --> 00:25:21,780
data and can send it to another thread

00:25:19,260 --> 00:25:24,720
the first thread will not have it

00:25:21,780 --> 00:25:27,420
anymore the other one have it and suit

00:25:24,720 --> 00:25:30,390
means I can pass it between concurrent

00:25:27,420 --> 00:25:32,220
units and both properties are

00:25:30,390 --> 00:25:35,610
independent of power or the parallelism

00:25:32,220 --> 00:25:38,820
and the concurrency library news this is

00:25:35,610 --> 00:25:40,920
a motivating example for simplicity six

00:25:38,820 --> 00:25:43,340
I'm just going to use threads here but

00:25:40,920 --> 00:25:46,770
this also works in any other kind of

00:25:43,340 --> 00:25:48,660
situation so I have a counter classic

00:25:46,770 --> 00:25:51,140
counter problem I spawned three threads

00:25:48,660 --> 00:25:57,440
and I try to have a becau every of those

00:25:51,140 --> 00:26:00,630
count wants the problem is because

00:25:57,440 --> 00:26:02,850
counting on a processor is I read the

00:26:00,630 --> 00:26:04,500
data I manipulate it and I've read it

00:26:02,850 --> 00:26:07,130
again to memory there might be a race

00:26:04,500 --> 00:26:09,330
condition so programming is or

00:26:07,130 --> 00:26:13,020
multiplayer programming is one of the

00:26:09,330 --> 00:26:15,180
only ways to actually make 1 + 1 + 1 B 2

00:26:13,020 --> 00:26:18,210
and this is what happens here

00:26:15,180 --> 00:26:21,660
luckily Roz compiler actually tells me

00:26:18,210 --> 00:26:24,690
that that doesn't work in this case in

00:26:21,660 --> 00:26:27,090
the initial case tells me what the

00:26:24,690 --> 00:26:29,580
thread expects it actually wants to take

00:26:27,090 --> 00:26:31,200
ownership of all the data now the

00:26:29,580 --> 00:26:32,880
problem is I can only pass on ownership

00:26:31,200 --> 00:26:38,400
once but I want to throw this boundary

00:26:32,880 --> 00:26:41,070
that doesn't work it actually tells me

00:26:38,400 --> 00:26:43,920
here value moved into closure here in

00:26:41,070 --> 00:26:45,420
previous iteration of the loop so it

00:26:43,920 --> 00:26:47,630
understands that we iterate multiple

00:26:45,420 --> 00:26:49,700
times and it knows that the first time

00:26:47,630 --> 00:26:53,780
calling that's born the values already

00:26:49,700 --> 00:26:55,760
gone so what I need is actually multiple

00:26:53,780 --> 00:26:59,210
ownership and Russ provides ways of

00:26:55,760 --> 00:27:03,620
doing that through smart pointers much

00:26:59,210 --> 00:27:05,480
like in C++ or other languages and and a

00:27:03,620 --> 00:27:07,730
standard smart pointer and Russ is the

00:27:05,480 --> 00:27:13,160
rev counter if I want ref counting I can

00:27:07,730 --> 00:27:14,780
have ref counting I can construct a ref

00:27:13,160 --> 00:27:17,630
counted pointer around a piece of data

00:27:14,780 --> 00:27:20,630
this is the API how I get a new handle

00:27:17,630 --> 00:27:24,730
on that ref counter so I get a second

00:27:20,630 --> 00:27:29,120
reference and then that's right

00:27:24,730 --> 00:27:30,740
also doesn't work why because the

00:27:29,120 --> 00:27:33,320
standard ref Condor in rust is actually

00:27:30,740 --> 00:27:36,650
not synchronized so I might have the

00:27:33,320 --> 00:27:38,630
same problem just on the reference count

00:27:36,650 --> 00:27:40,640
instead of the actual data that I'm

00:27:38,630 --> 00:27:43,430
pointing to but Russ detects that tells

00:27:40,640 --> 00:27:46,850
me it cannot be sent between threads

00:27:43,430 --> 00:27:50,570
safely because it's not sent that's

00:27:46,850 --> 00:27:51,860
where that property comes from okay

00:27:50,570 --> 00:27:54,260
let's stick a little bit more through

00:27:51,860 --> 00:27:56,000
the API and figure out if there's a sunt

00:27:54,260 --> 00:27:58,630
ref counter yes there's a sink ref

00:27:56,000 --> 00:28:06,400
counter which is the AR see the atomic

00:27:58,630 --> 00:28:08,320
ref counter let's try that same API

00:28:06,400 --> 00:28:12,100
doesn't work

00:28:08,320 --> 00:28:16,390
can it assign data to an m % reference

00:28:12,100 --> 00:28:18,590
what's the problem the problem is I have

00:28:16,390 --> 00:28:23,120
multiple access points to that data

00:28:18,590 --> 00:28:25,070
through the AR C and then the borrowing

00:28:23,120 --> 00:28:26,270
rule applies again you cannot get a

00:28:25,070 --> 00:28:30,880
mutable reference out of that because

00:28:26,270 --> 00:28:36,110
there might be other people watching so

00:28:30,880 --> 00:28:37,670
the last thing I need is mutex because

00:28:36,110 --> 00:28:39,410
the mutex does exactly that that

00:28:37,670 --> 00:28:42,860
moderation it makes sure that there's

00:28:39,410 --> 00:28:44,800
always ever one part of the program

00:28:42,860 --> 00:28:50,510
currently holding a mutable reference

00:28:44,800 --> 00:28:53,750
that works and interestingly if you lock

00:28:50,510 --> 00:28:58,880
a mutex to get back is something called

00:28:53,750 --> 00:29:00,740
a mutex card which we presents hey you

00:28:58,880 --> 00:29:05,149
have currently locked the mutex

00:29:00,740 --> 00:29:06,980
and that one again as no empathy R is

00:29:05,149 --> 00:29:08,390
handled through ownership that means I

00:29:06,980 --> 00:29:09,830
don't actually have to think because

00:29:08,390 --> 00:29:15,110
it's a resource yeah your luck is a

00:29:09,830 --> 00:29:17,899
resource so I take a lock and I let it

00:29:15,110 --> 00:29:21,289
run out of scope here and the moment I

00:29:17,899 --> 00:29:22,970
let it run out of scope it gets

00:29:21,289 --> 00:29:27,500
immediately unlocked so I also kind of

00:29:22,970 --> 00:29:29,390
forget unlocking the mutex so the

00:29:27,500 --> 00:29:31,340
compiler has just guided me through a

00:29:29,390 --> 00:29:33,230
refactoring that usually it's pretty

00:29:31,340 --> 00:29:36,770
dangerous I take a single threaded piece

00:29:33,230 --> 00:29:38,539
of code and we write it as a

00:29:36,770 --> 00:29:40,159
multi-threaded piece of code I need to

00:29:38,539 --> 00:29:42,200
make sure that all the data that I

00:29:40,159 --> 00:29:44,149
access to is properly synchronized and

00:29:42,200 --> 00:29:45,860
has never been if it vanishes out of

00:29:44,149 --> 00:29:49,130
memory memory as long as people still

00:29:45,860 --> 00:29:49,940
needed classic parallel programming

00:29:49,130 --> 00:29:51,649
problem

00:29:49,940 --> 00:29:52,970
the vanishing out of memory is not a

00:29:51,649 --> 00:29:55,970
problem if they were working in a

00:29:52,970 --> 00:29:58,520
garbage collected language the one

00:29:55,970 --> 00:30:03,710
properly synchronizing is still a

00:29:58,520 --> 00:30:07,750
problem let's move on to a little more

00:30:03,710 --> 00:30:10,220
practical examples so Russ is used for

00:30:07,750 --> 00:30:13,159
actually a lot of CLI programs anyone

00:30:10,220 --> 00:30:15,190
here using BS code you ever use the

00:30:13,159 --> 00:30:19,730
search function you using a Russ program

00:30:15,190 --> 00:30:21,649
it's there's a certain sub community of

00:30:19,730 --> 00:30:23,539
the Russ community that wants to make

00:30:21,649 --> 00:30:26,929
string processing as fast as possible

00:30:23,539 --> 00:30:30,710
and this a lot a lot of outcome coming

00:30:26,929 --> 00:30:32,899
in these kind of areas so the nice thing

00:30:30,710 --> 00:30:34,279
about writing CLI programs in rust is

00:30:32,899 --> 00:30:37,370
similar to for example if you write them

00:30:34,279 --> 00:30:40,429
and go there shippable without having

00:30:37,370 --> 00:30:43,429
people to install a runtime pison to

00:30:40,429 --> 00:30:45,020
seven or whatever its memory conserving

00:30:43,429 --> 00:30:47,059
with a very a fast startup time because

00:30:45,020 --> 00:30:48,980
it doesn't come with a runtime um

00:30:47,059 --> 00:30:50,600
these libraries for a fast and

00:30:48,980 --> 00:30:54,710
convenient part is pretty often CLI

00:30:50,600 --> 00:30:57,620
programs I used too much to CSV files

00:30:54,710 --> 00:30:59,360
JSON files whatever and you have a free

00:30:57,620 --> 00:31:01,370
choice of concurrency patterns if you

00:30:59,360 --> 00:31:04,940
want to interact with a with an API in

00:31:01,370 --> 00:31:07,250
the backend probably you want a single

00:31:04,940 --> 00:31:08,570
if you just want to churn through a lot

00:31:07,250 --> 00:31:12,110
of data quickly you probably want a

00:31:08,570 --> 00:31:14,450
third Pole and ownership makes this it

00:31:12,110 --> 00:31:16,880
still resource management

00:31:14,450 --> 00:31:20,540
hang around those files making sure that

00:31:16,880 --> 00:31:22,250
for example all your all your back-end

00:31:20,540 --> 00:31:26,990
requests appropriately closed and

00:31:22,250 --> 00:31:29,240
whatever pretty easy but this also

00:31:26,990 --> 00:31:33,430
convenience is the Russ program language

00:31:29,240 --> 00:31:37,400
provide you which is it has ways to

00:31:33,430 --> 00:31:39,650
allow for structured cogeneration so for

00:31:37,400 --> 00:31:42,110
example this here is a struct but

00:31:39,650 --> 00:31:45,140
through a library called struck top we

00:31:42,110 --> 00:31:48,290
turn it into the definition of our CLI

00:31:45,140 --> 00:31:50,180
interface what the derive does it looks

00:31:48,290 --> 00:31:51,920
at the struct and says uh-huh there's a

00:31:50,180 --> 00:31:53,540
command-line argument called pattern it

00:31:51,920 --> 00:31:57,140
has to be a string it has to be present

00:31:53,540 --> 00:32:00,230
because there's no null in rust so that

00:31:57,140 --> 00:32:03,680
one has to be there this year is a past

00:32:00,230 --> 00:32:05,420
buff how do you get a past buff I can

00:32:03,680 --> 00:32:09,260
tell it actually pause it using a

00:32:05,420 --> 00:32:14,000
standard library functionality the usage

00:32:09,260 --> 00:32:15,680
is much like a previously described the

00:32:14,000 --> 00:32:17,780
same thing is used for serialization and

00:32:15,680 --> 00:32:18,920
deserialization there's a serialization

00:32:17,780 --> 00:32:23,140
and deserialization

00:32:18,920 --> 00:32:25,670
from serialization framework called 30

00:32:23,140 --> 00:32:28,100
which we can use in much the same way we

00:32:25,670 --> 00:32:30,410
can say we have a point XY we want to be

00:32:28,100 --> 00:32:35,510
abitt serializable and e serializable

00:32:30,410 --> 00:32:36,710
and then we can actually choose the

00:32:35,510 --> 00:32:38,660
format we want to see relies and

00:32:36,710 --> 00:32:42,140
deserialize at - that's independent of

00:32:38,660 --> 00:32:43,610
this machinery here and here we say we

00:32:42,140 --> 00:32:47,030
want to see you lies it into jason and

00:32:43,610 --> 00:32:49,370
back the nice thing here is this can

00:32:47,030 --> 00:32:50,930
error like reading a json file that

00:32:49,370 --> 00:32:52,700
might be incomplete might have

00:32:50,930 --> 00:32:59,330
additional fields might have less fields

00:32:52,700 --> 00:33:01,100
and so they it's there's always a result

00:32:59,330 --> 00:33:02,780
coming back so you need to check if that

00:33:01,100 --> 00:33:04,340
was actually with other data so it uses

00:33:02,780 --> 00:33:07,310
the type system to understand

00:33:04,340 --> 00:33:12,950
well did I even get a valid JSON file

00:33:07,310 --> 00:33:15,290
here all that can be configured just to

00:33:12,950 --> 00:33:17,270
be clear so what do you do if ax isn't

00:33:15,290 --> 00:33:20,720
present in this case I choose choose the

00:33:17,270 --> 00:33:22,460
default which is null and I also say

00:33:20,720 --> 00:33:25,930
please in my JSON format it's called

00:33:22,460 --> 00:33:25,930
point lower case so use that

00:33:27,800 --> 00:33:32,730
which naturally brings me somewhat down

00:33:30,660 --> 00:33:34,440
the stack a lot of these programs

00:33:32,730 --> 00:33:39,930
nowadays are actually deployed on small

00:33:34,440 --> 00:33:41,310
devices the first place to go to if I

00:33:39,930 --> 00:33:46,110
want to go smaller is usually embedded

00:33:41,310 --> 00:33:48,570
Linux my router my IOT gateway and

00:33:46,110 --> 00:33:50,910
Industry control system we have seen

00:33:48,570 --> 00:33:52,440
what's there it's people talking about

00:33:50,910 --> 00:33:54,840
putting it on cars and people

00:33:52,440 --> 00:33:57,000
researching on that so embedded Linux is

00:33:54,840 --> 00:33:58,980
at all the places there's always the

00:33:57,000 --> 00:34:00,540
conversation if embedded Linux a lot of

00:33:58,980 --> 00:34:01,950
people don't consider embedded Linux

00:34:00,540 --> 00:34:06,510
kind of embedded because it's a

00:34:01,950 --> 00:34:08,850
full-blown operating system still it has

00:34:06,510 --> 00:34:11,940
a lot of the it brings you into a lot of

00:34:08,850 --> 00:34:15,440
the problems that start with smaller

00:34:11,940 --> 00:34:17,490
devices the first one is cross compiling

00:34:15,440 --> 00:34:19,980
what's compiling isn't actually a

00:34:17,490 --> 00:34:21,900
language concern it is the language

00:34:19,980 --> 00:34:23,429
concern in the sense that our standard

00:34:21,900 --> 00:34:25,800
lip is written in a way that we want to

00:34:23,429 --> 00:34:29,280
make sure that we can support as many

00:34:25,800 --> 00:34:30,630
targets as possible and if the standard

00:34:29,280 --> 00:34:34,650
lip can't support it you can at least

00:34:30,630 --> 00:34:37,890
slice it in pieces where you can for

00:34:34,650 --> 00:34:41,060
example support parts of it so for

00:34:37,890 --> 00:34:44,160
example our memory allocation library is

00:34:41,060 --> 00:34:48,780
also available as a single library but

00:34:44,160 --> 00:34:51,000
the process itself is easy um we give

00:34:48,780 --> 00:34:54,210
you appropriate tooling and all tooling

00:34:51,000 --> 00:34:57,180
and rust is aware that something like

00:34:54,210 --> 00:34:59,430
cross compiling happens Russ stop is a

00:34:57,180 --> 00:35:01,740
tool that we use to manage what's

00:34:59,430 --> 00:35:03,990
compilers and choose the version that

00:35:01,740 --> 00:35:06,600
you want to have and but it's not just a

00:35:03,990 --> 00:35:10,740
version switcher it also for example

00:35:06,600 --> 00:35:13,290
manages targets for you so if I want to

00:35:10,740 --> 00:35:16,230
compile for a Arch Linux with a muzzle

00:35:13,290 --> 00:35:19,980
Lipsy I can just download that from

00:35:16,230 --> 00:35:22,590
actually our projects hosts and use

00:35:19,980 --> 00:35:25,830
cargo which is a build tool to build

00:35:22,590 --> 00:35:27,690
whatever we have over to one of those

00:35:25,830 --> 00:35:30,180
targets

00:35:27,690 --> 00:35:32,040
I need the platform linker and Lipsy

00:35:30,180 --> 00:35:34,410
available which is usually if I for

00:35:32,040 --> 00:35:37,680
example compile to was wrt I need to

00:35:34,410 --> 00:35:39,500
have the open wrt SDK in my path and I

00:35:37,680 --> 00:35:40,740
need to make sure that that is there

00:35:39,500 --> 00:35:43,290
still

00:35:40,740 --> 00:35:49,130
from our side the tooling is as complete

00:35:43,290 --> 00:35:53,160
as possible and further down the stack

00:35:49,130 --> 00:35:54,780
last year we finally unlocked running

00:35:53,160 --> 00:35:57,810
rust with all of those features that I

00:35:54,780 --> 00:36:01,050
just shown on bare metal embedded so

00:35:57,810 --> 00:36:03,480
tiny devices in RF controllers and all

00:36:01,050 --> 00:36:04,890
of these so that meant a lot of the

00:36:03,480 --> 00:36:06,869
stabilization of all lower level details

00:36:04,890 --> 00:36:08,490
replaceable error handlers how is the

00:36:06,869 --> 00:36:09,930
main function called I used that main

00:36:08,490 --> 00:36:11,400
function all the time but what's around

00:36:09,930 --> 00:36:13,320
the main function what happens when the

00:36:11,400 --> 00:36:15,359
program quits most people don't care

00:36:13,320 --> 00:36:18,750
people on bare metal devices actually

00:36:15,359 --> 00:36:20,310
care so it gives you great support for

00:36:18,750 --> 00:36:23,130
all of these safe patterns on embedded

00:36:20,310 --> 00:36:25,140
devices it relies on the existing

00:36:23,130 --> 00:36:27,930
tooling it should be considered young

00:36:25,140 --> 00:36:30,000
but solid like it is done we have

00:36:27,930 --> 00:36:32,670
backwards compatibility now so we can

00:36:30,000 --> 00:36:33,990
start writing libraries this is what it

00:36:32,670 --> 00:36:37,410
looks like if you just want a simple

00:36:33,990 --> 00:36:40,140
program the important thing here is it

00:36:37,410 --> 00:36:41,609
is a no main program so it actually

00:36:40,140 --> 00:36:43,650
doesn't have a main function we're gonna

00:36:41,609 --> 00:36:46,320
write that all ourselves it doesn't use

00:36:43,650 --> 00:36:49,589
the standard lead it uses an external

00:36:46,320 --> 00:36:53,310
crate for in this case supporting

00:36:49,589 --> 00:36:55,380
cortex-m processors the RT is this is

00:36:53,310 --> 00:36:57,990
the runtime for a cortex-m processor so

00:36:55,380 --> 00:37:02,970
we won't actually boot and finish the

00:36:57,990 --> 00:37:05,070
processor if you want to and it writes

00:37:02,970 --> 00:37:06,690
at the main function and marks this as

00:37:05,070 --> 00:37:09,810
entry here we're using cogeneration

00:37:06,690 --> 00:37:12,630
again through this attribute to actually

00:37:09,810 --> 00:37:15,750
set up do the set up off this is how you

00:37:12,630 --> 00:37:16,950
actually start the board and this is how

00:37:15,750 --> 00:37:18,540
you shut down the board and everything

00:37:16,950 --> 00:37:19,800
will be generated for you and then it

00:37:18,540 --> 00:37:21,990
will be called into that main function

00:37:19,800 --> 00:37:24,150
this does it just loops just does

00:37:21,990 --> 00:37:32,010
nothing so the machine works but it does

00:37:24,150 --> 00:37:33,690
nothing let's keep that um but we're

00:37:32,010 --> 00:37:35,250
still using Rustom antics there and

00:37:33,690 --> 00:37:37,760
especially the embedded working group

00:37:35,250 --> 00:37:40,830
has come up with a lot of interesting

00:37:37,760 --> 00:37:42,810
usages off for example mapping a device

00:37:40,830 --> 00:37:45,150
access to ownership because I have the

00:37:42,810 --> 00:37:46,950
same problem again I don't want to the

00:37:45,150 --> 00:37:48,150
two parts of the program to use the same

00:37:46,950 --> 00:37:49,290
port at the same time that's an

00:37:48,150 --> 00:37:51,780
ownership problem I want unique

00:37:49,290 --> 00:37:53,430
ownership it uses these metaprogramming

00:37:51,780 --> 00:37:54,240
facilities that we provide for

00:37:53,430 --> 00:37:57,090
convenience

00:37:54,240 --> 00:37:58,619
like being able to mark and function as

00:37:57,090 --> 00:38:01,440
an entry point and then having all the

00:37:58,619 --> 00:38:03,180
code around it be generated but have

00:38:01,440 --> 00:38:06,180
that pluggable if I ever want to replace

00:38:03,180 --> 00:38:08,820
that the resulting code just to be clear

00:38:06,180 --> 00:38:12,869
is board specific in this case so this

00:38:08,820 --> 00:38:14,550
needs to run on an cortex-m your options

00:38:12,869 --> 00:38:17,220
there you can directly use a board

00:38:14,550 --> 00:38:18,600
package so we have a list of supported

00:38:17,220 --> 00:38:24,660
boards in the rest embedded working

00:38:18,600 --> 00:38:27,750
group you can use RTFM which is a small

00:38:24,660 --> 00:38:31,890
real-time scheduler for small devices

00:38:27,750 --> 00:38:34,890
and a framework to build safe devices

00:38:31,890 --> 00:38:36,869
there or you can use a full embedded

00:38:34,890 --> 00:38:40,140
operating system with built in rust

00:38:36,869 --> 00:38:42,560
which is Taco S or if you actually need

00:38:40,140 --> 00:38:45,510
full support for the board and you can't

00:38:42,560 --> 00:38:46,650
fill the holes yourself currently but

00:38:45,510 --> 00:38:49,350
you want to write in a trust you can

00:38:46,650 --> 00:38:53,119
just use a C based operating system and

00:38:49,350 --> 00:38:53,119
like riot and use that one

00:38:53,450 --> 00:39:01,590
the final thing that's missing for that

00:38:56,160 --> 00:39:06,000
is rust can use can be used to interact

00:39:01,590 --> 00:39:07,800
with C and C++ just if it were C so for

00:39:06,000 --> 00:39:09,930
example you can generate static and

00:39:07,800 --> 00:39:12,270
dynamic libraries which provide you

00:39:09,930 --> 00:39:14,190
punctual speed-up of larger programs or

00:39:12,270 --> 00:39:16,109
if you have a device driver that's in C

00:39:14,190 --> 00:39:18,030
that you don't want to rewrite in rust

00:39:16,109 --> 00:39:22,890
you can just call into that device

00:39:18,030 --> 00:39:26,220
driver and use that one it is also often

00:39:22,890 --> 00:39:27,690
used for example in mobile use cases so

00:39:26,220 --> 00:39:30,540
if you want to deploy something on

00:39:27,690 --> 00:39:32,450
multiple smartphones and we're usually C

00:39:30,540 --> 00:39:36,020
was used you can just use rust instead

00:39:32,450 --> 00:39:38,550
I'm not going to go into detail here

00:39:36,020 --> 00:39:40,380
basically what it ends up with is we can

00:39:38,550 --> 00:39:42,600
generate libraries that externally look

00:39:40,380 --> 00:39:45,900
like they are C library and then you

00:39:42,600 --> 00:39:49,050
reuse all the facilities that we have so

00:39:45,900 --> 00:39:51,000
for example this is a piece of Ruby code

00:39:49,050 --> 00:39:54,920
that would use the previews library as

00:39:51,000 --> 00:39:58,770
the dynamic library just loaded and

00:39:54,920 --> 00:40:01,740
allocate data allocate data through that

00:39:58,770 --> 00:40:06,660
library instead so we can use rust as a

00:40:01,740 --> 00:40:08,040
memory safe C replacement so in the

00:40:06,660 --> 00:40:10,200
cases where you would usually

00:40:08,040 --> 00:40:11,790
simple use the dynamic language then say

00:40:10,200 --> 00:40:15,060
well we would write rewrite it and see

00:40:11,790 --> 00:40:16,710
if it becomes slow but then you suddenly

00:40:15,060 --> 00:40:18,240
through all the memories safety that I

00:40:16,710 --> 00:40:20,250
made emmaandemma clang which gives you

00:40:18,240 --> 00:40:25,230
out of the window if you use rust

00:40:20,250 --> 00:40:28,140
instead that works as well this

00:40:25,230 --> 00:40:30,350
generators for that so if you don't want

00:40:28,140 --> 00:40:32,580
to handwrite all of these you can use

00:40:30,350 --> 00:40:34,470
generators for going from rust program

00:40:32,580 --> 00:40:36,960
to C header from a C header to rust

00:40:34,470 --> 00:40:39,080
bindings they specialized tools just for

00:40:36,960 --> 00:40:41,700
Python Ruby and node to make this

00:40:39,080 --> 00:40:44,070
conversation less rote and actually just

00:40:41,700 --> 00:40:45,360
auto-generated can also use a rust

00:40:44,070 --> 00:40:48,060
program to for example composite of

00:40:45,360 --> 00:40:50,790
Awesome because of time are actually not

00:40:48,060 --> 00:40:52,470
going to talk about was omits pretty

00:40:50,790 --> 00:40:55,260
much the same it's a shared library by a

00:40:52,470 --> 00:41:01,050
different name can talk to me about that

00:40:55,260 --> 00:41:02,910
later what's missing especially when

00:41:01,050 --> 00:41:04,830
we're talking about bare metal is safety

00:41:02,910 --> 00:41:07,710
critical use cases we have currently no

00:41:04,830 --> 00:41:09,150
certified compiler but we have recently

00:41:07,710 --> 00:41:12,240
started a project called sealed rust

00:41:09,150 --> 00:41:14,310
that attempts to bring certification of

00:41:12,240 --> 00:41:15,990
rust on track the problem being the

00:41:14,310 --> 00:41:17,570
language moves forward so we need to at

00:41:15,990 --> 00:41:20,850
some point decide okay we're going to

00:41:17,570 --> 00:41:22,500
take a little piece of that or going to

00:41:20,850 --> 00:41:24,120
take the current version and try to get

00:41:22,500 --> 00:41:26,730
it certified and actually keep it stable

00:41:24,120 --> 00:41:29,490
and supported for users that actually

00:41:26,730 --> 00:41:37,950
need that what we got that on track

00:41:29,490 --> 00:41:42,780
that's a multi yeah so let's go back to

00:41:37,950 --> 00:41:43,980
these claims of performance and so we

00:41:42,780 --> 00:41:48,060
have a language that's as fast as C and

00:41:43,980 --> 00:41:50,580
C++ with safety while doing the fasting

00:41:48,060 --> 00:41:55,320
and abstractions with almost no overhead

00:41:50,580 --> 00:41:58,680
or no overhead but also a language that

00:41:55,320 --> 00:42:02,700
cares about reliability by letting you

00:41:58,680 --> 00:42:06,390
express abstract concepts making making

00:42:02,700 --> 00:42:07,800
illegal states inexpressible and with

00:42:06,390 --> 00:42:09,900
type level support for resource

00:42:07,800 --> 00:42:12,600
management and for productivity

00:42:09,900 --> 00:42:15,180
we have great tooling we check that

00:42:12,600 --> 00:42:17,400
every year people user you give us four

00:42:15,180 --> 00:42:19,350
to five out of five stars we have a good

00:42:17,400 --> 00:42:20,310
documentation can find that on our

00:42:19,350 --> 00:42:21,810
website

00:42:20,310 --> 00:42:24,450
rustling dork slash learn

00:42:21,810 --> 00:42:26,100
actually we have extensive docs we have

00:42:24,450 --> 00:42:27,900
nine books written on all of these

00:42:26,100 --> 00:42:29,160
special use cases so there's an there's

00:42:27,900 --> 00:42:34,500
a book on the language there's a book

00:42:29,160 --> 00:42:36,180
embedded specifically and we actually

00:42:34,500 --> 00:42:38,370
have a language it's hard to present

00:42:36,180 --> 00:42:41,760
that's well feasible for performance

00:42:38,370 --> 00:42:43,770
refactoring so you can just do things a

00:42:41,760 --> 00:42:45,870
little wasteful and then after it works

00:42:43,770 --> 00:42:50,070
start refactoring to making to using

00:42:45,870 --> 00:42:54,630
more performant techniques so does that

00:42:50,070 --> 00:42:56,840
work we're seeing rust used in many many

00:42:54,630 --> 00:43:00,450
ways and interestingly we got roughly

00:42:56,840 --> 00:43:02,400
33% in flux so a third from functional

00:43:00,450 --> 00:43:04,290
language dynamic languages and systems

00:43:02,400 --> 00:43:06,270
programming so people are coming from

00:43:04,290 --> 00:43:08,390
all like off the stack down the stack

00:43:06,270 --> 00:43:10,320
from all areas into the rest project

00:43:08,390 --> 00:43:13,440
because they seeing that there's finally

00:43:10,320 --> 00:43:15,420
a language that they can kind of amend

00:43:13,440 --> 00:43:17,100
to the use cases easily and it's well

00:43:15,420 --> 00:43:18,480
supported and they can get stuff

00:43:17,100 --> 00:43:20,610
committed to the tooling to actually

00:43:18,480 --> 00:43:25,410
support that without working off the

00:43:20,610 --> 00:43:27,810
little language community also one thing

00:43:25,410 --> 00:43:30,690
you should consider I'm actually not

00:43:27,810 --> 00:43:33,000
asking you to switch languages that's I

00:43:30,690 --> 00:43:36,060
think there's a huge problem that if we

00:43:33,000 --> 00:43:37,770
bring new languages on the table many

00:43:36,060 --> 00:43:39,210
people are like oh my god I need to get

00:43:37,770 --> 00:43:40,470
everyone retrained and all the stuff

00:43:39,210 --> 00:43:44,010
rewritten no that's actually not the

00:43:40,470 --> 00:43:46,440
case this is why we offer these things

00:43:44,010 --> 00:43:48,750
like you can rewrite a small piece of it

00:43:46,440 --> 00:43:52,320
and then use rust as a shade library or

00:43:48,750 --> 00:43:54,510
you can integrate it bringing another

00:43:52,320 --> 00:43:56,100
tool to the belts on an organization

00:43:54,510 --> 00:43:58,380
level it's much cheaper than actually

00:43:56,100 --> 00:44:00,450
like rooting for bringing the old stuff

00:43:58,380 --> 00:44:02,040
out that's important to consider and

00:44:00,450 --> 00:44:03,660
rust is a tool that you can actually use

00:44:02,040 --> 00:44:05,940
everywhere so it's a very useful tool to

00:44:03,660 --> 00:44:09,120
have might not be the thing that you use

00:44:05,940 --> 00:44:11,970
everywhere but for example with you if

00:44:09,120 --> 00:44:13,560
you are working for example in the IOT

00:44:11,970 --> 00:44:15,960
sector it's one of the rare languages

00:44:13,560 --> 00:44:17,850
that can actually cover all of all of

00:44:15,960 --> 00:44:21,660
the use cases that you have form small

00:44:17,850 --> 00:44:23,100
devices up to your service systems so

00:44:21,660 --> 00:44:24,420
the conclusion is rust is the language

00:44:23,100 --> 00:44:26,310
of wealth shows and compiled some

00:44:24,420 --> 00:44:28,890
guarantees and simple runtime semantics

00:44:26,310 --> 00:44:30,360
that'll and this simplicity is important

00:44:28,890 --> 00:44:32,820
because that allows you to use it in any

00:44:30,360 --> 00:44:34,770
area of your product because you can

00:44:32,820 --> 00:44:36,190
build on these simple semantics towards

00:44:34,770 --> 00:44:37,750
the thing that you're actually

00:44:36,190 --> 00:44:40,690
instead of dragging all of those

00:44:37,750 --> 00:44:42,780
semantics in in the first place so thank

00:44:40,690 --> 00:44:42,780
you

00:44:43,780 --> 00:44:49,940

YouTube URL: https://www.youtube.com/watch?v=sCSfyQYDImM


