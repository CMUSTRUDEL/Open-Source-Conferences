Title: Rust, WebAssembly, and the future of Serverless by Steve Klabnik
Publication date: 2019-10-09
Playlist: Other Conferences 2019
Description: 
	A lot of things have been said about WebAssembly inside of the browser; after all, that's why it was originally created. But a new case is emerging as well, and that's WebAssembly on the server. More specifically, we're seeing a rise of support for WebAssembly in serverless application platforms, combining two brand-new technologies together. We're also seeing a lot of growth of the Rust programming language, and its close alignment with WebAssembly. In this talk, Steve will talk about Rust, WebAssembly, serverless technologies, and how it all fits together.

A talk from Full Stack Fest 2019. 

Full Stack Fest is a conference held by Codegram. We've been running development conferences since 2012 with a goal in mind: Inspiring our audience by putting together the best speakers & talks at a privileged location in the beautiful Barcelona area.

Head over to https://conferences.codegram.com/ for an overview of our conferences and to watch all talks. Visit https://www.codegram.com/blog/ to learn more from our team on related topics.
Captions: 
	00:00:00,030 --> 00:00:04,920
hi everyone I'm Steve I used to joke

00:00:03,330 --> 00:00:06,960
that now that I use Windows projectors

00:00:04,920 --> 00:00:09,929
just work but uh projectors never work

00:00:06,960 --> 00:00:11,700
no matter what you're doing so this is a

00:00:09,929 --> 00:00:15,089
talk called rust web assembly in the

00:00:11,700 --> 00:00:17,279
future of service it's kind of like

00:00:15,089 --> 00:00:20,130
buzzword bingo a little bit like who got

00:00:17,279 --> 00:00:21,600
bingo all these terms in one talk but uh

00:00:20,130 --> 00:00:23,430
we're talking about how all these three

00:00:21,600 --> 00:00:25,560
things like fit together and where I see

00:00:23,430 --> 00:00:27,330
some of the stuff in this space going I

00:00:25,560 --> 00:00:30,060
got the idea from this talk when I saw

00:00:27,330 --> 00:00:31,740
this tweet because I saw this tweet and

00:00:30,060 --> 00:00:33,480
said this makes perfect sense and then

00:00:31,740 --> 00:00:36,059
everyone else I showed it to said what

00:00:33,480 --> 00:00:37,800
is what are you talking about and so in

00:00:36,059 --> 00:00:39,690
some ways this talk is like an extended

00:00:37,800 --> 00:00:42,899
explanation of this tweet in some ways

00:00:39,690 --> 00:00:43,200
from my perspective since the solomon

00:00:42,899 --> 00:00:45,510
hikes

00:00:43,200 --> 00:00:47,280
who co-founded docker will talk a little

00:00:45,510 --> 00:00:49,530
bit more about that later but he says if

00:00:47,280 --> 00:00:51,030
wasum and huazi existed in 2008 we

00:00:49,530 --> 00:00:52,920
wouldn't have needed to create docker

00:00:51,030 --> 00:00:54,690
that's how important it is like

00:00:52,920 --> 00:00:57,000
webassembly would replace docker and

00:00:54,690 --> 00:00:59,129
that was very confusing to a lot of

00:00:57,000 --> 00:01:00,449
people and so that's sort of like the

00:00:59,129 --> 00:01:08,159
high-level topic of what we're gonna

00:01:00,449 --> 00:01:09,780
talk about but first rust so rust is a

00:01:08,159 --> 00:01:11,909
programming language and we've iterated

00:01:09,780 --> 00:01:13,710
a lot on this slogan and the latest

00:01:11,909 --> 00:01:15,270
version of this slogan is a programming

00:01:13,710 --> 00:01:17,180
language that's empowering everyone to

00:01:15,270 --> 00:01:19,979
build reliable and efficient software

00:01:17,180 --> 00:01:21,840
you may have seen a previous logo slogan

00:01:19,979 --> 00:01:23,100
involving threading and memory safety

00:01:21,840 --> 00:01:24,540
and stuff but that was even more

00:01:23,100 --> 00:01:26,340
buzzword bingo EE than the title of his

00:01:24,540 --> 00:01:28,979
talk and this is like really gets to the

00:01:26,340 --> 00:01:30,180
guts of what rust is about rust is a a

00:01:28,979 --> 00:01:32,850
programming language that lets you build

00:01:30,180 --> 00:01:36,390
stuff that is as low or as high level as

00:01:32,850 --> 00:01:39,270
you want and is incredibly fast and like

00:01:36,390 --> 00:01:40,200
resource-efficient a lot of people and

00:01:39,270 --> 00:01:42,150
like the way that we've talked about

00:01:40,200 --> 00:01:43,290
rust in the past I'm on the rust core

00:01:42,150 --> 00:01:45,540
team by the way I guess I didn't say

00:01:43,290 --> 00:01:47,549
that earlier but uh the way that we talk

00:01:45,540 --> 00:01:50,490
about rust in the past tended to be as a

00:01:47,549 --> 00:01:51,960
C++ replacement because the intention

00:01:50,490 --> 00:01:56,040
like the reason rust got made in the

00:01:51,960 --> 00:01:58,079
first place was at Mozilla so Firefox is

00:01:56,040 --> 00:01:59,490
a great piece of software but has

00:01:58,079 --> 00:02:01,320
security vulnerabilities like any

00:01:59,490 --> 00:02:02,909
browser does and it turns out that a

00:02:01,320 --> 00:02:05,100
significant number of them like over

00:02:02,909 --> 00:02:07,619
half were due to a thing called memory

00:02:05,100 --> 00:02:11,510
unsafe T which basically means you use

00:02:07,619 --> 00:02:13,970
C++ wrong and so if you make a mistake

00:02:11,510 --> 00:02:15,500
bad things happen and when you have a

00:02:13,970 --> 00:02:17,000
web browser that's deployed hundreds of

00:02:15,500 --> 00:02:20,120
millions of people you have not only

00:02:17,000 --> 00:02:21,110
like a responsibility as a product but

00:02:20,120 --> 00:02:22,700
you almost have this ethical

00:02:21,110 --> 00:02:24,739
responsibility to make sure that your

00:02:22,700 --> 00:02:26,720
your code is like actually safe for

00:02:24,739 --> 00:02:28,459
people like web browsers are the kind of

00:02:26,720 --> 00:02:30,590
things that like nation-states want to

00:02:28,459 --> 00:02:32,359
attack and you want to make sure that

00:02:30,590 --> 00:02:34,549
people are safe and protected on the web

00:02:32,359 --> 00:02:36,230
and so the idea was what if we could

00:02:34,549 --> 00:02:38,720
make a language that would be able to be

00:02:36,230 --> 00:02:40,700
as efficient as C or C++ but not

00:02:38,720 --> 00:02:43,879
actually as dangerous I have a couple

00:02:40,700 --> 00:02:47,989
more slides on this topic basically rust

00:02:43,879 --> 00:02:50,720
is for when you you gotta go fast this

00:02:47,989 --> 00:02:54,019
is Sonic the Hedgehog drawn very poorly

00:02:50,720 --> 00:02:55,670
so like traditionally when you think

00:02:54,019 --> 00:02:58,459
about programming languages there's sort

00:02:55,670 --> 00:03:00,500
of this AK C that people talk about and

00:02:58,459 --> 00:03:03,139
so there's sort of like speed on one

00:03:00,500 --> 00:03:05,569
side and then safety on the other and by

00:03:03,139 --> 00:03:07,099
safety we basically mean the like what I

00:03:05,569 --> 00:03:09,170
was talking about before if you use a

00:03:07,099 --> 00:03:11,090
pointer and use it wrong then your

00:03:09,170 --> 00:03:14,900
entire world comes crashing down hackers

00:03:11,090 --> 00:03:16,790
steal all your Bitcoin did you know send

00:03:14,900 --> 00:03:19,609
emails that are fake like all that kind

00:03:16,790 --> 00:03:21,579
of bad terrible stuff and so a lot of

00:03:19,609 --> 00:03:24,139
programming languages used to be

00:03:21,579 --> 00:03:25,940
incredibly on the speed side and did not

00:03:24,139 --> 00:03:27,769
care at all about the safety and that's

00:03:25,940 --> 00:03:30,650
because computers were significantly

00:03:27,769 --> 00:03:32,900
worse than they are now we needed the

00:03:30,650 --> 00:03:34,489
speed because computers were slow and so

00:03:32,900 --> 00:03:36,650
like the only thing that you could do

00:03:34,489 --> 00:03:38,540
was try to eat every single bit of power

00:03:36,650 --> 00:03:40,790
out of your hardware if you've ever

00:03:38,540 --> 00:03:42,560
looked into like how Nintendo games are

00:03:40,790 --> 00:03:44,510
made for example the amount of tricks

00:03:42,560 --> 00:03:46,250
and like stuff that they do is really

00:03:44,510 --> 00:03:47,720
amazing and if you look at like original

00:03:46,250 --> 00:03:49,010
games versus the games that came out at

00:03:47,720 --> 00:03:50,629
the end of the consoles life cycle

00:03:49,010 --> 00:03:52,220
you'll see that as they learn more and

00:03:50,629 --> 00:03:54,949
more tricks they were able to get more

00:03:52,220 --> 00:03:56,120
and more power and the games look better

00:03:54,949 --> 00:03:58,430
and this has been true it's like

00:03:56,120 --> 00:04:00,650
hardware in general there's a very

00:03:58,430 --> 00:04:04,190
famous Usenet thread does anyone

00:04:00,650 --> 00:04:06,129
remember Usenet cool some people do you

00:04:04,190 --> 00:04:08,780
stat was like Twitter but over email

00:04:06,129 --> 00:04:12,620
which is a terrible terrible description

00:04:08,780 --> 00:04:15,709
but there was an old thread a long ago

00:04:12,620 --> 00:04:17,299
between Linus Torvalds and Andy

00:04:15,709 --> 00:04:19,190
Tannenbaum a very famous operating

00:04:17,299 --> 00:04:20,719
system professor and they were arguing

00:04:19,190 --> 00:04:22,350
about like the Linux kernel and its

00:04:20,719 --> 00:04:24,690
architectures or whatever

00:04:22,350 --> 00:04:27,300
this is like a famous flame war like

00:04:24,690 --> 00:04:29,970
back in the day and as one part of it

00:04:27,300 --> 00:04:31,500
there was a description of like pretty

00:04:29,970 --> 00:04:33,870
soon we're gonna have computers that can

00:04:31,500 --> 00:04:34,590
do like 400,000 operations per second or

00:04:33,870 --> 00:04:36,240
something like this

00:04:34,590 --> 00:04:37,710
and so I looked up like what my iPhone

00:04:36,240 --> 00:04:39,449
was at the time I did this a couple

00:04:37,710 --> 00:04:42,259
years ago so it was like an iPhone 6 or

00:04:39,449 --> 00:04:44,370
7 and it was like the iPhone had like

00:04:42,259 --> 00:04:45,690
seven or eight orders of magnitude more

00:04:44,370 --> 00:04:47,250
speed than the computers that they were

00:04:45,690 --> 00:04:48,720
talking about back then I was like this

00:04:47,250 --> 00:04:50,729
this thing I'm looking this up on is

00:04:48,720 --> 00:04:53,370
like far more powerful and so as we've

00:04:50,729 --> 00:04:55,880
gained like not as much need for speed

00:04:53,370 --> 00:04:58,860
people have focused more on safety so

00:04:55,880 --> 00:05:01,020
1995 was like an amazing year for

00:04:58,860 --> 00:05:03,360
programming languages Java and

00:05:01,020 --> 00:05:04,889
JavaScript and I believe Python and Ruby

00:05:03,360 --> 00:05:07,410
like almost predict ones a little

00:05:04,889 --> 00:05:08,220
earlier was Ruby all came out in 1995 I

00:05:07,410 --> 00:05:09,210
don't know what they're putting in the

00:05:08,220 --> 00:05:10,380
drinking water but it was like an

00:05:09,210 --> 00:05:12,870
amazing time for programming language

00:05:10,380 --> 00:05:14,940
design and one of the things that came

00:05:12,870 --> 00:05:16,740
out of this sort of like era and this is

00:05:14,940 --> 00:05:18,599
even true of C at the time is like

00:05:16,740 --> 00:05:19,880
assembly is too dangerous so let's build

00:05:18,599 --> 00:05:22,440
this programming language called C

00:05:19,880 --> 00:05:23,699
because it's like a higher level and

00:05:22,440 --> 00:05:26,729
easier to use and you'll make less

00:05:23,699 --> 00:05:29,340
mistakes and so we've been like trying

00:05:26,729 --> 00:05:30,900
to add safety on top through programming

00:05:29,340 --> 00:05:32,070
language design to make it easier for

00:05:30,900 --> 00:05:33,720
you to write programs that are correct

00:05:32,070 --> 00:05:36,330
and harder to write programs that are

00:05:33,720 --> 00:05:38,820
incorrect and so a lot of this early

00:05:36,330 --> 00:05:40,139
focus and you know the research that

00:05:38,820 --> 00:05:42,750
happened on garbage collection for

00:05:40,139 --> 00:05:44,669
example garbage collection handles a lot

00:05:42,750 --> 00:05:47,039
of these sort of areas around memory

00:05:44,669 --> 00:05:48,900
where you no longer have control over

00:05:47,039 --> 00:05:51,090
how memory is allocated or D allocated

00:05:48,900 --> 00:05:52,800
the language does it for you via the

00:05:51,090 --> 00:05:54,180
runtime and so you don't have to think

00:05:52,800 --> 00:05:55,979
about it and the problem there is that

00:05:54,180 --> 00:05:57,719
it's much slower than a language that

00:05:55,979 --> 00:06:01,560
this is not so we have this trade-off

00:05:57,719 --> 00:06:03,360
between speed and safety and you know I

00:06:01,560 --> 00:06:04,979
like to pick on Ruby because I worked on

00:06:03,360 --> 00:06:07,139
Ruby for years I love Ruby I have a ruby

00:06:04,979 --> 00:06:08,969
tattoo so I managed to use Ruby as my

00:06:07,139 --> 00:06:11,340
stand-in slow garbage-collected language

00:06:08,969 --> 00:06:12,659
in this talk but like we sort of had

00:06:11,340 --> 00:06:14,340
this dichotomy where it's like yeah you

00:06:12,659 --> 00:06:16,560
can either use a language that's nice to

00:06:14,340 --> 00:06:18,599
use and easy but also extremely

00:06:16,560 --> 00:06:20,669
inefficient or you can use something

00:06:18,599 --> 00:06:21,990
that's very very fast and very very

00:06:20,669 --> 00:06:25,949
dangerous

00:06:21,990 --> 00:06:29,550
and so like rust came along and said why

00:06:25,949 --> 00:06:31,469
can't we actually have both and the

00:06:29,550 --> 00:06:31,919
answer is because everything is always a

00:06:31,469 --> 00:06:34,020
trade-off

00:06:31,919 --> 00:06:35,670
so rust is like haha we have speed and

00:06:34,020 --> 00:06:37,740
safety but the thing is is

00:06:35,670 --> 00:06:39,570
that you're always paying somehow and so

00:06:37,740 --> 00:06:42,540
the answer in rust case is it's more

00:06:39,570 --> 00:06:44,010
difficult to learn and there is a lot of

00:06:42,540 --> 00:06:45,690
like slower compilation you get a lot of

00:06:44,010 --> 00:06:48,000
compiler errors because the compiler is

00:06:45,690 --> 00:06:49,800
very strict and so it takes a little

00:06:48,000 --> 00:06:51,410
more time to get going it with rust than

00:06:49,800 --> 00:06:53,490
it does with something like JavaScript

00:06:51,410 --> 00:06:54,690
so there's always a trade off somewhere

00:06:53,490 --> 00:06:56,010
whenever somebody has a slide and

00:06:54,690 --> 00:06:57,030
they're like look at these two bad

00:06:56,010 --> 00:06:58,440
things but I have something that's

00:06:57,030 --> 00:06:59,580
better than both of them like if they

00:06:58,440 --> 00:07:01,080
don't tell you why that's also bad

00:06:59,580 --> 00:07:04,260
they're just lying to you probably by

00:07:01,080 --> 00:07:05,880
omission and so this is actually like a

00:07:04,260 --> 00:07:07,770
really significant problem across a lot

00:07:05,880 --> 00:07:09,300
of software this idea of safety and

00:07:07,770 --> 00:07:10,820
people keep reaching because there are

00:07:09,300 --> 00:07:12,960
applications that still do need speed

00:07:10,820 --> 00:07:15,030
people keep reaching for languages that

00:07:12,960 --> 00:07:19,230
are memory unsafe so this is a chart put

00:07:15,030 --> 00:07:21,150
out by Microsoft and it shows security

00:07:19,230 --> 00:07:22,740
vulnerabilities across all Microsoft

00:07:21,150 --> 00:07:25,080
products so this is not about a

00:07:22,740 --> 00:07:27,090
particular language this is everything

00:07:25,080 --> 00:07:29,550
Microsoft has ever done and you can see

00:07:27,090 --> 00:07:32,130
it goes from 2006 to 2008 een and it

00:07:29,550 --> 00:07:33,900
shows what percentage of security

00:07:32,130 --> 00:07:36,600
vulnerabilities in Microsoft products

00:07:33,900 --> 00:07:39,390
happen due to memory on safety issues

00:07:36,600 --> 00:07:41,850
and the dark blue is memory safety

00:07:39,390 --> 00:07:43,830
issues and the blue is all other issues

00:07:41,850 --> 00:07:45,840
combined and what's interesting and

00:07:43,830 --> 00:07:49,920
weird about this is that it's basically

00:07:45,840 --> 00:07:52,050
been at 70% across this decade plus of

00:07:49,920 --> 00:07:53,640
time roughly obviously a little more

00:07:52,050 --> 00:07:57,120
sometimes a little less sometimes but

00:07:53,640 --> 00:07:58,980
basically about 70% and so the idea of

00:07:57,120 --> 00:08:01,740
rust is like what if you could just

00:07:58,980 --> 00:08:03,420
eliminate seven roughly 70% of your

00:08:01,740 --> 00:08:05,760
security security vulnerabilities like

00:08:03,420 --> 00:08:07,350
straight off the top and it's important

00:08:05,760 --> 00:08:08,670
to note like the a lot of people saw

00:08:07,350 --> 00:08:11,280
this chart and thought that this was

00:08:08,670 --> 00:08:12,870
like against C or C++ but that's also

00:08:11,280 --> 00:08:15,810
not necessarily strictly speaking true

00:08:12,870 --> 00:08:18,360
like in a dynamic language like you know

00:08:15,810 --> 00:08:19,890
Ruby or JavaScript or Python we often

00:08:18,360 --> 00:08:23,040
reach out to lower-level languages for

00:08:19,890 --> 00:08:24,480
speed like node is written in C++ and so

00:08:23,040 --> 00:08:26,310
if you're calling into nodes native

00:08:24,480 --> 00:08:27,390
api's just because you're using a

00:08:26,310 --> 00:08:28,860
language that's garbage collected

00:08:27,390 --> 00:08:30,630
doesn't mean that the language itself is

00:08:28,860 --> 00:08:32,490
implemented in something that is and so

00:08:30,630 --> 00:08:34,860
you can have these kinds of issues even

00:08:32,490 --> 00:08:37,229
in languages that are normally safe

00:08:34,860 --> 00:08:39,300
because of the implementation and so

00:08:37,229 --> 00:08:41,550
this is kind of like the idea there's a

00:08:39,300 --> 00:08:43,530
really great series of web comics that

00:08:41,550 --> 00:08:45,360
showed programming languages represented

00:08:43,530 --> 00:08:47,040
by various kinds of people and this is

00:08:45,360 --> 00:08:49,230
the one that they did for rust it says

00:08:47,040 --> 00:08:51,840
I'll be your designated driver tonight

00:08:49,230 --> 00:08:53,550
and the speech rule says we know uh and

00:08:51,840 --> 00:08:55,140
the second was is don't talk while

00:08:53,550 --> 00:08:58,950
eating cuz you could choke and die ha ha

00:08:55,140 --> 00:09:00,990
ha so she's got this like really strong

00:08:58,950 --> 00:09:03,840
armor because this is like a thing that

00:09:00,990 --> 00:09:05,580
we particularly care about and so I

00:09:03,840 --> 00:09:07,290
always find this really funny I have

00:09:05,580 --> 00:09:09,180
links at the end I'm gonna make a lot of

00:09:07,290 --> 00:09:10,410
references to this talks and rather than

00:09:09,180 --> 00:09:11,820
put them on the individual slides I

00:09:10,410 --> 00:09:13,230
shoved them all at the end so I have a

00:09:11,820 --> 00:09:14,820
link to the comic and all the other

00:09:13,230 --> 00:09:16,530
stuff I'm reversing I have links at the

00:09:14,820 --> 00:09:18,780
end but if you check it out it's really

00:09:16,530 --> 00:09:24,840
really funny she did like 10 or 15

00:09:18,780 --> 00:09:26,070
languages I think okay so I mentioned

00:09:24,840 --> 00:09:27,870
this stuff about garbage collector isn't

00:09:26,070 --> 00:09:29,010
like node and stuff but like let's get a

00:09:27,870 --> 00:09:31,080
little bit more into what exactly that

00:09:29,010 --> 00:09:32,820
means so there's this concept called a

00:09:31,080 --> 00:09:35,250
runtime and it's one of the most

00:09:32,820 --> 00:09:36,420
overloaded used like words in computer

00:09:35,250 --> 00:09:37,410
science and in programming languages

00:09:36,420 --> 00:09:39,240
because they mean a ton of different

00:09:37,410 --> 00:09:41,250
things lots of people say that languages

00:09:39,240 --> 00:09:43,590
like C and C++ have no runtime and

00:09:41,250 --> 00:09:45,360
languages like Ruby JavaScript and

00:09:43,590 --> 00:09:46,670
Python have a runtime but there's

00:09:45,360 --> 00:09:48,330
actually not strictly speaking true

00:09:46,670 --> 00:09:50,640
assembly is the only language that

00:09:48,330 --> 00:09:53,400
doesn't have a runtime C and C++ and

00:09:50,640 --> 00:09:55,350
rusts like have a small runtime so I

00:09:53,400 --> 00:09:58,410
have like the great the light gray is

00:09:55,350 --> 00:10:01,170
like your code and the the dark gray is

00:09:58,410 --> 00:10:02,400
the the runtime code and what this means

00:10:01,170 --> 00:10:04,050
is the stuff that your programming

00:10:02,400 --> 00:10:07,110
language puts into your programs that

00:10:04,050 --> 00:10:09,450
you didn't actually write and so like

00:10:07,110 --> 00:10:11,340
with JavaScript you get all a v8 like if

00:10:09,450 --> 00:10:13,230
you build a node program like you have

00:10:11,340 --> 00:10:14,700
v8 and all the rest of node and that

00:10:13,230 --> 00:10:16,770
takes up a significant amount of the

00:10:14,700 --> 00:10:18,330
total space of your program outside of

00:10:16,770 --> 00:10:21,060
just the code that you actually like

00:10:18,330 --> 00:10:23,370
wrote and so we we tend to say that

00:10:21,060 --> 00:10:25,650
those are like big runtime or like has a

00:10:23,370 --> 00:10:27,960
runtime languages and stuff like

00:10:25,650 --> 00:10:29,010
assembly and you know rust have like no

00:10:27,960 --> 00:10:31,260
runtime even though it's like

00:10:29,010 --> 00:10:33,030
technically they're not true it's like

00:10:31,260 --> 00:10:35,190
almost true for languages like rust and

00:10:33,030 --> 00:10:36,510
so this is interesting for a number of

00:10:35,190 --> 00:10:39,090
different reasons but I'm not gonna

00:10:36,510 --> 00:10:42,900
really super explain why right the

00:10:39,090 --> 00:10:47,670
second I'll get there

00:10:42,900 --> 00:10:50,280
I mentioned compiler errors because rust

00:10:47,670 --> 00:10:51,180
really wants to be helpful and like the

00:10:50,280 --> 00:10:53,670
part of that the first part of the

00:10:51,180 --> 00:10:55,200
slogan was empowering everyone right so

00:10:53,670 --> 00:10:56,970
we wanted to make sure that we had the

00:10:55,200 --> 00:10:59,280
ability to help people write good

00:10:56,970 --> 00:11:00,900
software so we vested a lot of time into

00:10:59,280 --> 00:11:01,769
good error messages so here's an example

00:11:00,900 --> 00:11:04,980
some rust Co

00:11:01,769 --> 00:11:07,170
where we declare a variable Y but we

00:11:04,980 --> 00:11:09,329
never give it a value but then we try to

00:11:07,170 --> 00:11:11,459
pass a mutable reference to it to this

00:11:09,329 --> 00:11:14,489
function add 1 which will takes a

00:11:11,459 --> 00:11:17,189
reference to a 32-bit integer and adds 1

00:11:14,489 --> 00:11:19,410
to the number this is a problem because

00:11:17,189 --> 00:11:21,629
we never gave an initial value for y and

00:11:19,410 --> 00:11:23,399
so this number could be anything it's

00:11:21,629 --> 00:11:25,889
just garbage memory and if you wrote

00:11:23,399 --> 00:11:27,989
this C programs that wrote the similar

00:11:25,889 --> 00:11:29,730
thing would compile I believe recent

00:11:27,989 --> 00:11:31,410
compilers have some Diagnostics for

00:11:29,730 --> 00:11:32,790
simple cases like this but rust will

00:11:31,410 --> 00:11:34,619
always check and so here's an example of

00:11:32,790 --> 00:11:36,929
an error it says hey you have a possibly

00:11:34,619 --> 00:11:38,399
uninitialized variable Y and you used it

00:11:36,929 --> 00:11:39,239
when you passed it to add one so you

00:11:38,399 --> 00:11:41,369
can't do that

00:11:39,239 --> 00:11:42,899
please don't and so there's sort of a

00:11:41,369 --> 00:11:44,519
running joke that's like what's the

00:11:42,899 --> 00:11:46,049
answer to every single rust programming

00:11:44,519 --> 00:11:48,899
question and answer is compiler error

00:11:46,049 --> 00:11:50,549
like has it really like enforces this

00:11:48,899 --> 00:11:52,529
kind of discipline on you but eventually

00:11:50,549 --> 00:11:53,819
you sort of once you get like a feel for

00:11:52,529 --> 00:11:55,350
it it almost feels like a pair

00:11:53,819 --> 00:11:57,239
programmer it's double checking your

00:11:55,350 --> 00:11:58,709
work behind your back and that means you

00:11:57,239 --> 00:11:59,939
can be really confident that even when

00:11:58,709 --> 00:12:02,399
you're writing really low-level code

00:11:59,939 --> 00:12:04,319
that needs to go very fast rust has your

00:12:02,399 --> 00:12:06,149
back and that means that you can do

00:12:04,319 --> 00:12:07,589
really really awesome and complicated

00:12:06,149 --> 00:12:10,139
things and that's a really important

00:12:07,589 --> 00:12:11,999
part of of rust and it's why we've seen

00:12:10,139 --> 00:12:13,829
a lot of people like I came from the

00:12:11,999 --> 00:12:15,329
Ruby world we have a lot of Java Script

00:12:13,829 --> 00:12:17,369
people in rust now and they would have

00:12:15,329 --> 00:12:18,660
never used C or C++ because they know

00:12:17,369 --> 00:12:21,600
that they don't know a lot about these

00:12:18,660 --> 00:12:24,809
things and the consequences are dire and

00:12:21,600 --> 00:12:26,819
so like by like ironically by making the

00:12:24,809 --> 00:12:28,499
language a little harder to use we help

00:12:26,819 --> 00:12:30,509
people learn these kinds of things and

00:12:28,499 --> 00:12:31,589
write software that's reliable even if

00:12:30,509 --> 00:12:33,029
they don't have like low-level

00:12:31,589 --> 00:12:34,829
programming experience and so we're sort

00:12:33,029 --> 00:12:37,079
of expanding the audience for people

00:12:34,829 --> 00:12:38,249
that are able to write you know anything

00:12:37,079 --> 00:12:39,569
down the stack like you can write an

00:12:38,249 --> 00:12:41,490
operating system in rust and there are

00:12:39,569 --> 00:12:45,449
several people who have done so and

00:12:41,490 --> 00:12:48,149
that's really cool alright enough about

00:12:45,449 --> 00:12:58,350
rust for now let's move on to part 2

00:12:48,149 --> 00:13:00,089
which is web assembly as the web is like

00:12:58,350 --> 00:13:01,860
grown like originally you know the web

00:13:00,089 --> 00:13:03,629
just had these very basic static

00:13:01,860 --> 00:13:05,519
documents but we weren't really happy

00:13:03,629 --> 00:13:08,819
with just having some text on a page and

00:13:05,519 --> 00:13:12,149
so CSS came along and allowed us to

00:13:08,819 --> 00:13:13,709
style our web pages and then JavaScript

00:13:12,149 --> 00:13:14,980
comes along and allows us to add code

00:13:13,709 --> 00:13:16,750
see those web pages

00:13:14,980 --> 00:13:19,180
and so even in the earliest days of the

00:13:16,750 --> 00:13:21,970
web we were more ambitious than just

00:13:19,180 --> 00:13:23,139
purely documents it's only been more

00:13:21,970 --> 00:13:25,930
recently than we've been tried to be

00:13:23,139 --> 00:13:28,570
truly ambitious but like you know going

00:13:25,930 --> 00:13:31,300
from plain text to like some amount of

00:13:28,570 --> 00:13:33,339
fanciness was definitely an aspect of

00:13:31,300 --> 00:13:34,930
this and it's because like the web is a

00:13:33,339 --> 00:13:36,670
platform that connects everybody in the

00:13:34,930 --> 00:13:39,610
world as I believe sarah said at the end

00:13:36,670 --> 00:13:41,740
of her talk yesterday and so you know we

00:13:39,610 --> 00:13:43,300
want to be able to connect other people

00:13:41,740 --> 00:13:45,519
and share experiences and build more

00:13:43,300 --> 00:13:47,139
cool and interesting things and so in

00:13:45,519 --> 00:13:48,550
order to do that we need to be ambitious

00:13:47,139 --> 00:13:51,850
with what the web platform actually

00:13:48,550 --> 00:13:53,649
allows us to do and over the last you

00:13:51,850 --> 00:13:56,620
know decade or maybe even 15 years at

00:13:53,649 --> 00:13:59,350
this point kind of field we've been like

00:13:56,620 --> 00:14:01,149
significantly expanding what the web can

00:13:59,350 --> 00:14:03,430
actually do as a platform and that's

00:14:01,149 --> 00:14:04,690
because we all love the web and we're

00:14:03,430 --> 00:14:06,190
trying to push it forward that's like

00:14:04,690 --> 00:14:08,139
kind of in some degrees like a large

00:14:06,190 --> 00:14:10,149
part of this conference right and we've

00:14:08,139 --> 00:14:12,220
seen a lot of great talks over this

00:14:10,149 --> 00:14:14,560
conference about different ways in which

00:14:12,220 --> 00:14:16,089
people are trying to push the web to its

00:14:14,560 --> 00:14:18,010
limits and make it do things that it's

00:14:16,089 --> 00:14:19,870
never been able to do before and so

00:14:18,010 --> 00:14:21,790
we've sort of like leaned into this idea

00:14:19,870 --> 00:14:24,519
that like the web should be everything

00:14:21,790 --> 00:14:26,769
to all people it's it's kind of ironic

00:14:24,519 --> 00:14:29,470
actually that the Apple iPhone store

00:14:26,769 --> 00:14:31,449
exists because originally when it came

00:14:29,470 --> 00:14:33,610
out there was no way to make apps for

00:14:31,449 --> 00:14:36,579
the iPhone and Steve Jobs his answer was

00:14:33,610 --> 00:14:38,199
you should make web apps instead and we

00:14:36,579 --> 00:14:40,149
weren't ambitious enough and people were

00:14:38,199 --> 00:14:41,529
not able to make web apps and so then

00:14:40,149 --> 00:14:42,819
they caved in and said fine we'll make

00:14:41,529 --> 00:14:44,800
an app store and give you a way to write

00:14:42,819 --> 00:14:47,620
Mac apps and now that's like the great

00:14:44,800 --> 00:14:49,089
battle of like Native versus the web but

00:14:47,620 --> 00:14:51,279
like we actually were winning at the

00:14:49,089 --> 00:14:53,709
start we just think a lot of people like

00:14:51,279 --> 00:14:55,630
forget that like the app store wasn't

00:14:53,709 --> 00:14:57,490
like created by Apple to destroy the web

00:14:55,630 --> 00:15:00,250
like Apple try to tell us to use the web

00:14:57,490 --> 00:15:03,250
and we just didn't so they said okay and

00:15:00,250 --> 00:15:05,380
so we've been like ever so slowly like

00:15:03,250 --> 00:15:06,639
building up these capabilities and it's

00:15:05,380 --> 00:15:11,110
fantastic that you can do like

00:15:06,639 --> 00:15:12,430
animations and VR and like web USB is

00:15:11,110 --> 00:15:14,740
like a spec that I'm always like a big

00:15:12,430 --> 00:15:16,690
fan of just conceptually like access

00:15:14,740 --> 00:15:18,160
your USB Drive from website like that

00:15:16,690 --> 00:15:19,120
like sounds really cool and like lets

00:15:18,160 --> 00:15:22,540
you do all sorts of things that you

00:15:19,120 --> 00:15:25,660
would not be able to do before but yeah

00:15:22,540 --> 00:15:27,310
we have to be ambitious and so a long

00:15:25,660 --> 00:15:28,570
time ago there was this project that

00:15:27,310 --> 00:15:30,880
came out of Mozilla called as

00:15:28,570 --> 00:15:32,920
jas and it was one of the first attempts

00:15:30,880 --> 00:15:36,040
to make the web more ambitious in a

00:15:32,920 --> 00:15:38,650
specific sort of way this described as

00:15:36,040 --> 00:15:42,310
an extraordinarily optimizable low-level

00:15:38,650 --> 00:15:44,500
subset of JavaScript and basically what

00:15:42,310 --> 00:15:46,030
happened was the folks at Mozilla had

00:15:44,500 --> 00:15:47,980
seen that people were doing like

00:15:46,030 --> 00:15:49,630
compiled to JavaScript languages and

00:15:47,980 --> 00:15:53,080
there were a ton of them and there still

00:15:49,630 --> 00:15:54,850
are a ton of them and so they realized

00:15:53,080 --> 00:15:56,830
that like JavaScript had often become

00:15:54,850 --> 00:15:58,780
this like compiled target I mean even if

00:15:56,830 --> 00:16:00,580
you write plain JavaScript today if you

00:15:58,780 --> 00:16:02,170
have babel and web pack installed like

00:16:00,580 --> 00:16:04,570
it's gonna compile your JavaScript into

00:16:02,170 --> 00:16:06,370
other JavaScript and so like even people

00:16:04,570 --> 00:16:08,290
that write regular JavaScript today are

00:16:06,370 --> 00:16:10,480
often compiling it into other JavaScript

00:16:08,290 --> 00:16:13,570
for backwards compatibility reasons and

00:16:10,480 --> 00:16:15,490
so the idea was what if we could take

00:16:13,570 --> 00:16:18,460
that what we know about how browsers

00:16:15,490 --> 00:16:20,500
optimized javascript and then figure out

00:16:18,460 --> 00:16:22,690
what parts are easily optimizable and

00:16:20,500 --> 00:16:25,690
then give people the ability to compile

00:16:22,690 --> 00:16:27,520
their code into that optimizable form we

00:16:25,690 --> 00:16:29,410
could make really amazing things and

00:16:27,520 --> 00:16:32,170
since it's still a subset of JavaScript

00:16:29,410 --> 00:16:34,540
it's just JavaScript it would still work

00:16:32,170 --> 00:16:36,280
even if it was not highly optimized it

00:16:34,540 --> 00:16:38,080
just might be slower and so this is a

00:16:36,280 --> 00:16:39,670
really interesting idea because like a

00:16:38,080 --> 00:16:42,580
lot of times when you try to expand

00:16:39,670 --> 00:16:44,320
things you only let the people who like

00:16:42,580 --> 00:16:46,060
are able to use the new things use it

00:16:44,320 --> 00:16:48,160
and it's hard to gain traction and the

00:16:46,060 --> 00:16:50,320
idea here was to sort of you know

00:16:48,160 --> 00:16:52,450
instead of like making a whole new way

00:16:50,320 --> 00:16:54,190
of writing web apps on the web like

00:16:52,450 --> 00:16:56,320
putting a new language in the browser

00:16:54,190 --> 00:16:58,840
for example why not just keep using

00:16:56,320 --> 00:17:00,160
javascript why put a new language in the

00:16:58,840 --> 00:17:02,080
browser when you could compile that

00:17:00,160 --> 00:17:04,390
language to JavaScript if we could make

00:17:02,080 --> 00:17:06,880
that process more efficient and so this

00:17:04,390 --> 00:17:09,280
is sort of what Adam Jess tried to and

00:17:06,880 --> 00:17:12,160
largely succeeded at doing here's an

00:17:09,280 --> 00:17:15,220
example of some Azzam j/s javascript

00:17:12,160 --> 00:17:17,589
code so this is a function called

00:17:15,220 --> 00:17:20,410
compiled calculation it calls out to two

00:17:17,589 --> 00:17:22,720
functions F and G and it Orr's them with

00:17:20,410 --> 00:17:23,800
zero this is a bitwise or know if you've

00:17:22,720 --> 00:17:27,490
ever seen or use this in JavaScript

00:17:23,800 --> 00:17:30,760
before and then it returns those two

00:17:27,490 --> 00:17:32,710
numbers also ordered with zero and the

00:17:30,760 --> 00:17:34,420
the comments here is like X is a 32-bit

00:17:32,710 --> 00:17:36,220
value and so is Y and this will do a

00:17:34,420 --> 00:17:38,410
32-bit edition if you know anything

00:17:36,220 --> 00:17:39,850
about bitwise or which I would forgive

00:17:38,410 --> 00:17:41,559
you if you don't because it's really

00:17:39,850 --> 00:17:43,210
boring basic

00:17:41,559 --> 00:17:45,999
this doesn't do anything you're saying

00:17:43,210 --> 00:17:49,120
like you know to or every single one

00:17:45,999 --> 00:17:51,580
with zero and so one or zero is one and

00:17:49,120 --> 00:17:53,830
zero or zero is zero so the numbers stay

00:17:51,580 --> 00:17:57,549
the same so this looks to human like a

00:17:53,830 --> 00:18:00,850
no op but it's not actually no op

00:17:57,549 --> 00:18:02,440
because of the specification you can

00:18:00,850 --> 00:18:04,090
really get deep into the weeds with

00:18:02,440 --> 00:18:05,559
specs and a lot of people like to

00:18:04,090 --> 00:18:07,269
include myself including people who

00:18:05,559 --> 00:18:08,769
design programming languages and it

00:18:07,269 --> 00:18:12,490
turns out that this actually is

00:18:08,769 --> 00:18:13,840
guaranteed to be a 32-bit integer not

00:18:12,490 --> 00:18:15,549
actually a floating-point number

00:18:13,840 --> 00:18:17,860
even though JavaScript does not have

00:18:15,549 --> 00:18:19,629
floating-point numbers so you would

00:18:17,860 --> 00:18:22,570
maybe write this code like this but this

00:18:19,629 --> 00:18:24,820
code which is semantically equivalent to

00:18:22,570 --> 00:18:28,480
the previous code is actually like

00:18:24,820 --> 00:18:29,830
slower and by now you know JavaScript

00:18:28,480 --> 00:18:31,119
engines have gotten fast enough that

00:18:29,830 --> 00:18:33,369
sometimes they'll do this on their own

00:18:31,119 --> 00:18:35,499
but like basically integers are faster

00:18:33,369 --> 00:18:37,389
than floats the only type of numbers and

00:18:35,499 --> 00:18:40,269
JavaScript are floats

00:18:37,389 --> 00:18:44,529
so this naively would use a float and so

00:18:40,269 --> 00:18:47,529
it would be slower the reason why is in

00:18:44,529 --> 00:18:49,720
the spec so this is a link well not a

00:18:47,529 --> 00:18:51,399
link but like part of the part of the

00:18:49,720 --> 00:18:53,649
spec that makes this happen

00:18:51,399 --> 00:18:55,809
from the ACMA script standard and it

00:18:53,649 --> 00:18:58,059
says that all of the boolean operators

00:18:55,809 --> 00:19:00,460
where like a at B where E is one of the

00:18:58,059 --> 00:19:03,940
bitwise operators so like the the or

00:19:00,460 --> 00:19:06,279
that we saw before it does this and so

00:19:03,940 --> 00:19:07,960
it first gives you the result of

00:19:06,279 --> 00:19:10,509
evaluating the thing on the left and

00:19:07,960 --> 00:19:12,009
then it does the evaluates the thing on

00:19:10,509 --> 00:19:14,919
the right and then it converts them into

00:19:12,009 --> 00:19:17,379
32-bit integers and then results in a

00:19:14,919 --> 00:19:18,850
32-bit integer so like inside the

00:19:17,379 --> 00:19:20,559
JavaScript virtual machine even though

00:19:18,850 --> 00:19:24,460
you can't use integers in JavaScript

00:19:20,559 --> 00:19:26,440
JavaScript has integers and so this is

00:19:24,460 --> 00:19:29,289
like a weird hack that lets you sort of

00:19:26,440 --> 00:19:31,029
like abuse the semantics to get integers

00:19:29,289 --> 00:19:32,470
and JavaScript even though I mean big

00:19:31,029 --> 00:19:35,289
int is coming but it's not here yet and

00:19:32,470 --> 00:19:37,090
big int is different than this to get

00:19:35,289 --> 00:19:38,200
integers in a language doesn't have any

00:19:37,090 --> 00:19:39,970
which is like kind of wild when you

00:19:38,200 --> 00:19:41,950
think about it and it's not super

00:19:39,970 --> 00:19:43,990
surprising that there's some of the

00:19:41,950 --> 00:19:45,789
folks who were on tc39 that came up with

00:19:43,990 --> 00:19:46,899
this idea of Azzam j/s because there are

00:19:45,789 --> 00:19:49,450
the people that know this kind of stuff

00:19:46,899 --> 00:19:51,549
like I didn't know this at all

00:19:49,450 --> 00:19:53,619
but you're sort of like it's not like

00:19:51,549 --> 00:19:55,140
abusing the spec exactly because it's

00:19:53,619 --> 00:19:57,150
following what the specs

00:19:55,140 --> 00:20:00,170
but it's just like in an unusual way you

00:19:57,150 --> 00:20:02,250
wouldn't determine like on your own and

00:20:00,170 --> 00:20:03,810
you don't have to think about this

00:20:02,250 --> 00:20:06,210
because that's the whole point of this

00:20:03,810 --> 00:20:07,920
compilation process the idea is that you

00:20:06,210 --> 00:20:09,570
write the code that looks like this and

00:20:07,920 --> 00:20:11,880
then maybe it would compile it into

00:20:09,570 --> 00:20:13,020
something that looks like this and so

00:20:11,880 --> 00:20:17,910
that would like let you be able to do

00:20:13,020 --> 00:20:19,530
these kind of things so this resulted in

00:20:17,910 --> 00:20:20,970
this demo I don't know if any remembers

00:20:19,530 --> 00:20:22,440
this this screenshot was a little blurry

00:20:20,970 --> 00:20:23,700
I'm sorry about that

00:20:22,440 --> 00:20:25,230
which is like unfortunate given that

00:20:23,700 --> 00:20:26,670
it's like a graphics demonstration but

00:20:25,230 --> 00:20:28,230
also this like a long time ago so these

00:20:26,670 --> 00:20:30,450
graphics are not as impressive anymore

00:20:28,230 --> 00:20:32,460
but like I remember loading this page up

00:20:30,450 --> 00:20:34,590
in my web browser and this is the Unreal

00:20:32,460 --> 00:20:36,540
Engine it's a couple million lines of

00:20:34,590 --> 00:20:39,420
C++ code and at the time this is like

00:20:36,540 --> 00:20:41,610
hyper cutting-edge graphics and I could

00:20:39,420 --> 00:20:44,220
like walk around in this medieval town

00:20:41,610 --> 00:20:44,940
in my web browser and I was like holy

00:20:44,220 --> 00:20:46,920
crap

00:20:44,940 --> 00:20:48,900
like this is amazing and it took like I

00:20:46,920 --> 00:20:51,480
think it was around a week of folks from

00:20:48,900 --> 00:20:53,790
unreal and Mozilla compiling the Unreal

00:20:51,480 --> 00:20:55,080
Engine 2 Azzam j/s and being able to run

00:20:53,790 --> 00:20:58,680
it in Firefox and you would get this

00:20:55,080 --> 00:21:00,600
kind of like rich 3d and it performed

00:20:58,680 --> 00:21:02,670
like surprisingly well and this is like

00:21:00,600 --> 00:21:04,650
really cool and this is where I first

00:21:02,670 --> 00:21:07,050
personally like became convinced that

00:21:04,650 --> 00:21:09,570
making the web ambitious was like really

00:21:07,050 --> 00:21:10,980
important and a good idea because like I

00:21:09,570 --> 00:21:12,630
was like wow once you could do like 3d

00:21:10,980 --> 00:21:14,280
games on the web like the web can do

00:21:12,630 --> 00:21:16,770
anything like 3d games are one of the

00:21:14,280 --> 00:21:20,010
most CPU intensive things that you can

00:21:16,770 --> 00:21:21,420
possibly do at least in my opinion at

00:21:20,010 --> 00:21:26,250
the time and so I thought this was like

00:21:21,420 --> 00:21:27,660
extremely extremely impressive but MJS

00:21:26,250 --> 00:21:30,270
was not the end of the story which is

00:21:27,660 --> 00:21:32,880
why this talk is not about atoms yes it

00:21:30,270 --> 00:21:34,950
turns out that while azzam j/s worked it

00:21:32,880 --> 00:21:37,140
also sort of didn't and what I mean by

00:21:34,950 --> 00:21:40,860
didn't is that we could actually do

00:21:37,140 --> 00:21:42,630
better the fact that as i'm jess was

00:21:40,860 --> 00:21:44,730
javascript was really good for

00:21:42,630 --> 00:21:47,370
compatibility reasons but it also had

00:21:44,730 --> 00:21:50,610
some limitations it's still JavaScript

00:21:47,370 --> 00:21:53,220
so it still requires the the interpreter

00:21:50,610 --> 00:21:55,140
to like parse all of the JavaScript code

00:21:53,220 --> 00:21:57,270
it's a little more verbose if you notice

00:21:55,140 --> 00:21:59,310
we added those or zeroes so actually it

00:21:57,270 --> 00:22:01,140
could sometimes be larger and like we're

00:21:59,310 --> 00:22:03,180
all trying to remove reduce our bundle

00:22:01,140 --> 00:22:04,650
sizes right so like the idea that you

00:22:03,180 --> 00:22:08,640
make something bigger is like also a

00:22:04,650 --> 00:22:10,559
problem and like all that time was like

00:22:08,640 --> 00:22:11,970
of compiling the code and like doing all

00:22:10,559 --> 00:22:13,919
this stuff was strictly speaking

00:22:11,970 --> 00:22:15,690
unnecessary and it was limiting this

00:22:13,919 --> 00:22:19,490
speed that asthma Jess could do well it

00:22:15,690 --> 00:22:23,399
was faster we could get even faster so

00:22:19,490 --> 00:22:24,570
interweb assembly after azzam j/s proved

00:22:23,399 --> 00:22:27,929
that doing this kind of thing was

00:22:24,570 --> 00:22:29,909
possible on the web in like a miracle of

00:22:27,929 --> 00:22:32,070
standards that never actually happens

00:22:29,909 --> 00:22:33,990
ever everyone got together and like

00:22:32,070 --> 00:22:37,169
agreed on something

00:22:33,990 --> 00:22:38,669
and so we ended up with web assembly and

00:22:37,169 --> 00:22:41,309
web assembly is this kind of like

00:22:38,669 --> 00:22:43,019
spiritual successor to Azzam Jess but

00:22:41,309 --> 00:22:44,730
it's sort of like what if it wasn't a

00:22:43,019 --> 00:22:46,440
terrible hack but it was like something

00:22:44,730 --> 00:22:47,669
we all planned out together and like

00:22:46,440 --> 00:22:54,210
made sure that it was good from the

00:22:47,669 --> 00:22:56,789
start and so to give you an idea of like

00:22:54,210 --> 00:22:59,760
why this is an awesome jeaious version

00:22:56,789 --> 00:23:01,679
of the Fibonacci function you also

00:22:59,760 --> 00:23:02,940
notice this interesting string used as

00:23:01,679 --> 00:23:04,950
'm at the top this is another

00:23:02,940 --> 00:23:06,720
interesting failure slash success of

00:23:04,950 --> 00:23:08,730
assam chess and that originally the

00:23:06,720 --> 00:23:10,860
folks thought that browsers would read

00:23:08,730 --> 00:23:12,809
this string and go like oh this is as

00:23:10,860 --> 00:23:14,010
I'm Jes and turn into a super faster

00:23:12,809 --> 00:23:15,960
compiler instead of the regular

00:23:14,010 --> 00:23:17,909
JavaScript compiler but the folks at

00:23:15,960 --> 00:23:19,889
Chrome were like why don't we just make

00:23:17,909 --> 00:23:21,330
JavaScript faster in general and we'll

00:23:19,889 --> 00:23:23,960
just ignore it and so they actually

00:23:21,330 --> 00:23:25,919
never implemented as MJ has specific

00:23:23,960 --> 00:23:28,799
optimizations they just made JavaScript

00:23:25,919 --> 00:23:31,679
faster and then it worked so well but

00:23:28,799 --> 00:23:33,240
anyway so like so you can see all these

00:23:31,679 --> 00:23:36,450
or zeros here in this Fibonacci function

00:23:33,240 --> 00:23:39,630
and you can see that its top is 185

00:23:36,450 --> 00:23:40,830
bytes in size that's how big this code

00:23:39,630 --> 00:23:43,769
would be if you send it over the wire

00:23:40,830 --> 00:23:45,210
not that big but if you look at the web

00:23:43,769 --> 00:23:47,370
assembly code down here at the bottom

00:23:45,210 --> 00:23:49,289
and yes it's almost all boxes because

00:23:47,370 --> 00:23:52,350
it's not actually it gets binary code

00:23:49,289 --> 00:23:54,659
like Azzam jss binary so sorry web

00:23:52,350 --> 00:23:56,370
assembly is binary so like it doesn't

00:23:54,659 --> 00:23:58,620
really render here but the point is the

00:23:56,370 --> 00:24:00,870
equivalent Fibonacci function written in

00:23:58,620 --> 00:24:02,519
web assembly ends up being 62 bytes and

00:24:00,870 --> 00:24:04,380
so this is much smaller and more compact

00:24:02,519 --> 00:24:06,179
which means that you're not sending as

00:24:04,380 --> 00:24:08,220
much data over the wire which means your

00:24:06,179 --> 00:24:11,039
pages load faster it also is

00:24:08,220 --> 00:24:12,330
significantly easier to parse because of

00:24:11,039 --> 00:24:13,769
the fact that it's binary and so it's

00:24:12,330 --> 00:24:15,389
much faster than parsing a real

00:24:13,769 --> 00:24:17,250
programming language like JavaScript and

00:24:15,389 --> 00:24:19,320
so that also like significantly adds on

00:24:17,250 --> 00:24:21,899
to these kinds of like speeds so it's

00:24:19,320 --> 00:24:22,440
smaller and faster and you know you

00:24:21,899 --> 00:24:24,509
don't write this

00:24:22,440 --> 00:24:27,419
my hands will get into there in a minute

00:24:24,509 --> 00:24:29,879
but this is an image from Lynne Clark

00:24:27,419 --> 00:24:31,139
who gave a great talk yesterday she does

00:24:29,879 --> 00:24:33,120
these code cartoons that are that are

00:24:31,139 --> 00:24:35,370
awesome and so I wanted to use one of

00:24:33,120 --> 00:24:36,990
them the idea is you don't run we don't

00:24:35,370 --> 00:24:39,870
write web assembly by hand although you

00:24:36,990 --> 00:24:46,259
can there's the web assembly text format

00:24:39,870 --> 00:24:48,690
or what and you instead would mostly

00:24:46,259 --> 00:24:51,179
write other languages and then compile

00:24:48,690 --> 00:24:53,009
them into some in this case like lov Mir

00:24:51,179 --> 00:24:55,350
in this example but like the point is

00:24:53,009 --> 00:24:56,970
you compile them to web assembly instead

00:24:55,350 --> 00:24:59,940
of writing the web assembly format

00:24:56,970 --> 00:25:01,710
yourself and so the idea was that you no

00:24:59,940 --> 00:25:03,450
longer needed to like only write

00:25:01,710 --> 00:25:05,490
JavaScript you can write other languages

00:25:03,450 --> 00:25:08,309
as well and they would be able to like

00:25:05,490 --> 00:25:12,000
work inside of your browser and that's

00:25:08,309 --> 00:25:14,759
like really really cool the wisdom like

00:25:12,000 --> 00:25:17,220
1.0 release like the MVP shipped a

00:25:14,759 --> 00:25:21,509
little while ago actually and so if you

00:25:17,220 --> 00:25:23,429
look on cannot use its 87 point 42% of

00:25:21,509 --> 00:25:28,169
browsers today support web assembly

00:25:23,429 --> 00:25:30,240
natively so if you need to use old ie

00:25:28,169 --> 00:25:32,460
not edge that's actually the biggest

00:25:30,240 --> 00:25:35,700
holdout so like you can as long as you

00:25:32,460 --> 00:25:37,769
don't need old IE then you can use wesam

00:25:35,700 --> 00:25:40,049
basically I guess if you care about

00:25:37,769 --> 00:25:42,179
Opera Mini maybe that also matters to

00:25:40,049 --> 00:25:44,279
you too but like basically all modern

00:25:42,179 --> 00:25:47,039
browsers all have good web assembly

00:25:44,279 --> 00:25:48,929
support at the moment and and so it's

00:25:47,039 --> 00:25:50,850
like surprisingly accessible even though

00:25:48,929 --> 00:25:53,370
you know you may not have realized that

00:25:50,850 --> 00:25:53,929
it's actually started shipping that's

00:25:53,370 --> 00:25:57,629
really cool

00:25:53,929 --> 00:26:01,259
there was a joke made by our a great MC

00:25:57,629 --> 00:26:02,850
yesterday but uh this is sort of related

00:26:01,259 --> 00:26:04,350
but not entirely the same thing but like

00:26:02,850 --> 00:26:05,879
one funny thing that like why some

00:26:04,350 --> 00:26:06,990
people say all the time is web assembly

00:26:05,879 --> 00:26:09,809
is like a funny name because it's

00:26:06,990 --> 00:26:11,250
neither web nor assembly actually it's

00:26:09,809 --> 00:26:13,799
not an assembly language it's a binary

00:26:11,250 --> 00:26:15,600
format and while it was born out of the

00:26:13,799 --> 00:26:19,769
web it's actually significantly broader

00:26:15,600 --> 00:26:21,809
than the web is it was designed in a way

00:26:19,769 --> 00:26:24,000
that liked it actually the spec says

00:26:21,809 --> 00:26:25,649
nothing about the web or web browsers it

00:26:24,000 --> 00:26:28,230
describes how web assembly code

00:26:25,649 --> 00:26:29,700
interacts with a host environment and so

00:26:28,230 --> 00:26:31,320
the normal host environments are

00:26:29,700 --> 00:26:33,570
browsers you can write other host

00:26:31,320 --> 00:26:35,190
environments to be able to put it in

00:26:33,570 --> 00:26:36,860
whatever you want

00:26:35,190 --> 00:26:41,909
[Music]

00:26:36,860 --> 00:26:43,019
so this is a talk that's amazing it's

00:26:41,909 --> 00:26:44,669
called the birth and death of

00:26:43,019 --> 00:26:47,999
JavaScript's by Gary Bernhardt has

00:26:44,669 --> 00:26:49,740
anyone seen this talk cool I was lucky

00:26:47,999 --> 00:26:52,139
enough to see this talk live and it like

00:26:49,740 --> 00:26:53,850
blew my mind it happened when Azzam Jess

00:26:52,139 --> 00:26:55,289
existed and before webassembly it

00:26:53,850 --> 00:26:58,440
existed so it's a little different now

00:26:55,289 --> 00:27:01,080
but it's it's a fake talk set in like

00:26:58,440 --> 00:27:03,299
the year 2050 talking about the history

00:27:01,080 --> 00:27:07,139
of JavaScript since the early 2000s til

00:27:03,299 --> 00:27:09,149
now and so he talks about how once you

00:27:07,139 --> 00:27:10,679
couldn't file programs into what he

00:27:09,149 --> 00:27:12,389
called metal which is basically what web

00:27:10,679 --> 00:27:14,519
assembly is you would be able to say

00:27:12,389 --> 00:27:16,559
like if you can compile a program then

00:27:14,519 --> 00:27:18,419
you can compile like anything because

00:27:16,559 --> 00:27:20,610
compilers are great so what if we would

00:27:18,419 --> 00:27:22,440
compile our browser to web assembly and

00:27:20,610 --> 00:27:24,840
so this is a screenshot of running

00:27:22,440 --> 00:27:29,129
inside of chrome running inside of

00:27:24,840 --> 00:27:30,720
firefox is the idea and like you may

00:27:29,129 --> 00:27:32,249
think this is ridiculous and it is kind

00:27:30,720 --> 00:27:34,139
of ridiculous and I laughed when I saw

00:27:32,249 --> 00:27:35,549
it but I I've been telling Gary that

00:27:34,139 --> 00:27:37,350
like over the last couple years that

00:27:35,549 --> 00:27:38,490
like his like sort of nightmare has been

00:27:37,350 --> 00:27:40,559
my dream and I've been trying to make

00:27:38,490 --> 00:27:42,899
this actually happen and I didn't end up

00:27:40,559 --> 00:27:45,749
making this happen but my ex colleague

00:27:42,899 --> 00:27:47,879
Dan Cala had managed to compile DOSBox

00:27:45,749 --> 00:27:50,399
to wasm and then load up Netscape

00:27:47,879 --> 00:27:52,139
Navigator inside of DOSBox inside of

00:27:50,399 --> 00:27:53,549
Firefox so like if you thought that

00:27:52,139 --> 00:27:54,929
previous slide was ridiculous like this

00:27:53,549 --> 00:27:56,580
is actually like a year old like it's

00:27:54,929 --> 00:28:00,269
already happened like we're past that

00:27:56,580 --> 00:28:01,230
point now maybe you'd want to browse the

00:28:00,269 --> 00:28:03,269
web at something better than original

00:28:01,230 --> 00:28:04,559
Netscape Navigator possibly so it's not

00:28:03,269 --> 00:28:05,990
like we have chrome inside of Firefox

00:28:04,559 --> 00:28:08,789
yet but like the point is is that like

00:28:05,990 --> 00:28:10,470
conceptually this works obviously

00:28:08,789 --> 00:28:13,289
there's some fine details to work out

00:28:10,470 --> 00:28:16,490
here but like it is a thing that is real

00:28:13,289 --> 00:28:20,039
and has occurred already in the world

00:28:16,490 --> 00:28:23,850
all right so I pick it up a little bit

00:28:20,039 --> 00:28:24,899
rust and webassembly this is part 2.1 so

00:28:23,850 --> 00:28:27,690
I talked a little bit rust and talked

00:28:24,899 --> 00:28:31,350
about azzam so we we showed this code

00:28:27,690 --> 00:28:33,450
earlier with the like as MJS and the web

00:28:31,350 --> 00:28:35,340
assembly but one of the reasons why this

00:28:33,450 --> 00:28:36,840
Azzam j/s is so small is because it

00:28:35,340 --> 00:28:38,159
basically only uses like language

00:28:36,840 --> 00:28:41,759
primitives and doesn't really use

00:28:38,159 --> 00:28:43,769
anything from the language itself this

00:28:41,759 --> 00:28:45,450
is an example of assembly script which

00:28:43,769 --> 00:28:47,070
is a subset of typescript to the

00:28:45,450 --> 00:28:47,670
compiles to web assembly and it's a more

00:28:47,070 --> 00:28:50,370
complicated

00:28:47,670 --> 00:28:52,500
example this involves giving you 64-bit

00:28:50,370 --> 00:28:53,670
integers in JavaScript by writing a

00:28:52,500 --> 00:28:55,410
library that implements them in

00:28:53,670 --> 00:28:59,600
typescript or whatever and so it's six

00:28:55,410 --> 00:29:02,340
kilobytes of source code and typescript

00:28:59,600 --> 00:29:05,850
but like as we talked about before with

00:29:02,340 --> 00:29:07,800
runtimes like assembly a web assembly

00:29:05,850 --> 00:29:09,360
doesn't give you a runtime so if you use

00:29:07,800 --> 00:29:10,710
a language that has a runtime you have

00:29:09,360 --> 00:29:12,930
to bring it along with you

00:29:10,710 --> 00:29:14,430
so like language is like rust having a

00:29:12,930 --> 00:29:15,930
small runtime means that their web

00:29:14,430 --> 00:29:17,610
assembly code is very small but

00:29:15,930 --> 00:29:18,870
languages with larger runtime like

00:29:17,610 --> 00:29:20,940
typescript

00:29:18,870 --> 00:29:22,860
although the assembly script runtime is

00:29:20,940 --> 00:29:24,930
relatively small but language like

00:29:22,860 --> 00:29:26,940
Python or Ruby or go you have to bring

00:29:24,930 --> 00:29:28,320
the entire runtime along with you and so

00:29:26,940 --> 00:29:30,510
it creates bundles that are much larger

00:29:28,320 --> 00:29:32,850
and it's harder to make them smaller due

00:29:30,510 --> 00:29:35,250
to the the runtime being necessary for

00:29:32,850 --> 00:29:37,890
the language to actually work and so in

00:29:35,250 --> 00:29:40,230
this example the assembly scripts like

00:29:37,890 --> 00:29:41,730
generated code is actually much larger

00:29:40,230 --> 00:29:43,260
because you have to include the assembly

00:29:41,730 --> 00:29:44,430
script runtime and I should mention they

00:29:43,260 --> 00:29:47,340
actually give you options for different

00:29:44,430 --> 00:29:48,990
runtimes and so you can do like a always

00:29:47,340 --> 00:29:50,730
leak memory and don't include a GC

00:29:48,990 --> 00:29:52,590
runtime which is used for some things

00:29:50,730 --> 00:29:54,150
but like reduces the size and they put a

00:29:52,590 --> 00:29:56,220
lot of work into making it more usable

00:29:54,150 --> 00:29:57,720
so it adds about two kilobytes on to

00:29:56,220 --> 00:30:01,380
your binary which is definitely not bad

00:29:57,720 --> 00:30:03,330
but it's always an extra 2k so we saw

00:30:01,380 --> 00:30:05,580
this opportunity with rust and web

00:30:03,330 --> 00:30:09,990
assembly becoming a bigger thing and a

00:30:05,580 --> 00:30:11,490
year and a half ago in in in 2018 we

00:30:09,990 --> 00:30:13,140
decided to start a web assembly working

00:30:11,490 --> 00:30:14,550
group and they've been producing amazing

00:30:13,140 --> 00:30:17,340
tooling around rust

00:30:14,550 --> 00:30:19,560
there's the wasm Biogen project it was

00:30:17,340 --> 00:30:21,420
implemented by them the wise impact

00:30:19,560 --> 00:30:22,680
project that's been implemented by the

00:30:21,420 --> 00:30:24,090
working group and a bunch of other

00:30:22,680 --> 00:30:26,280
really interesting tools around web

00:30:24,090 --> 00:30:28,290
assembly because we really believed that

00:30:26,280 --> 00:30:29,670
like web assembly is a cool part of the

00:30:28,290 --> 00:30:31,620
future and we want Russ to be a part of

00:30:29,670 --> 00:30:32,880
it and so it's generally considered that

00:30:31,620 --> 00:30:34,860
rust has the best-in-class

00:30:32,880 --> 00:30:36,060
tooling for building web assembly stuff

00:30:34,860 --> 00:30:40,230
and so they've been working together

00:30:36,060 --> 00:30:43,890
like for a while on these things part

00:30:40,230 --> 00:30:46,620
three service I really mentioned

00:30:43,890 --> 00:30:48,990
anything about like servers or stuff

00:30:46,620 --> 00:30:50,790
this is the joke that was made by our MC

00:30:48,990 --> 00:30:51,990
yesterday and point out very aptly like

00:30:50,790 --> 00:30:53,100
the problem we talked about server list

00:30:51,990 --> 00:30:55,050
is everybody's like there's still

00:30:53,100 --> 00:30:57,630
servers and server lists ahahah like

00:30:55,050 --> 00:30:59,580
yeah ok we get it look it's not funny or

00:30:57,630 --> 00:31:01,029
insightful actually I'm not gonna

00:30:59,580 --> 00:31:02,949
explain to you why server list is import

00:31:01,029 --> 00:31:04,179
why it's cool because I already had so

00:31:02,949 --> 00:31:05,889
many things in this talk that I could

00:31:04,179 --> 00:31:06,969
not fit it into the time I'm assuming

00:31:05,889 --> 00:31:08,439
that the people this conference already

00:31:06,969 --> 00:31:10,029
knows stuff about server list and so I'm

00:31:08,439 --> 00:31:11,859
not gonna explain like all the details

00:31:10,029 --> 00:31:13,479
here there's a bunch of other talks

00:31:11,859 --> 00:31:15,419
about that including at this conference

00:31:13,479 --> 00:31:18,179
but I do want to talk a little bit about

00:31:15,419 --> 00:31:20,529
some parts of serverless

00:31:18,179 --> 00:31:23,259
this is one of many charts you can find

00:31:20,529 --> 00:31:24,759
online about a history of the cloud and

00:31:23,259 --> 00:31:27,489
how we went from like the data center

00:31:24,759 --> 00:31:28,869
and VPS is to infrastructures of service

00:31:27,489 --> 00:31:30,399
then platform as a service and now

00:31:28,869 --> 00:31:32,349
serverless we talked about this

00:31:30,399 --> 00:31:34,359
progression but the interesting thing I

00:31:32,349 --> 00:31:36,099
think is that most people forget or

00:31:34,359 --> 00:31:38,889
didn't notice that there's actually a

00:31:36,099 --> 00:31:41,289
really subtle shift that's going on here

00:31:38,889 --> 00:31:42,879
and it happens in between this

00:31:41,289 --> 00:31:45,969
infrastructure as a service and platform

00:31:42,879 --> 00:31:48,579
as a service idea and that's because of

00:31:45,969 --> 00:31:50,169
this question what API does your hosting

00:31:48,579 --> 00:31:51,909
platform offer and I think when most

00:31:50,169 --> 00:31:54,759
people think of API is they think of

00:31:51,909 --> 00:31:57,519
like some sort of web hook thing but I

00:31:54,759 --> 00:31:59,739
mean like a platform that gives you the

00:31:57,519 --> 00:32:01,269
ability to host your code needs you to

00:31:59,739 --> 00:32:07,599
have some sort of interface that you can

00:32:01,269 --> 00:32:12,579
your code runs against and so like in

00:32:07,599 --> 00:32:14,559
the data center and an IAS UNIX was the

00:32:12,579 --> 00:32:17,139
API often there's windows and stuff -

00:32:14,559 --> 00:32:18,519
like UNIX was the API they offered you

00:32:17,139 --> 00:32:20,229
which means you could do whatever you

00:32:18,519 --> 00:32:21,729
wanted because most programs like ran on

00:32:20,229 --> 00:32:23,079
UNIX but that was basically if you

00:32:21,729 --> 00:32:24,789
interface between you and the cloud

00:32:23,079 --> 00:32:26,379
provider they would say I'm going to

00:32:24,789 --> 00:32:28,179
give you a piece of hardware or a

00:32:26,379 --> 00:32:29,829
virtual hardware and it's got an

00:32:28,179 --> 00:32:31,569
operating system on it and you can SSH

00:32:29,829 --> 00:32:33,189
in and like do whatever you want like

00:32:31,569 --> 00:32:34,719
you can interact with it that way and a

00:32:33,189 --> 00:32:38,169
lot of people don't think about UNIX as

00:32:34,719 --> 00:32:40,389
being the API but it was and and this is

00:32:38,169 --> 00:32:42,729
the shift because between iis and we

00:32:40,389 --> 00:32:45,549
went to platforms as a service it now

00:32:42,729 --> 00:32:47,769
meant that at your application and what

00:32:45,549 --> 00:32:49,689
you wrote it in became the api between

00:32:47,769 --> 00:32:51,039
you and the hosting provider took me a

00:32:49,689 --> 00:32:53,919
little while to dig up this next slide

00:32:51,039 --> 00:32:57,059
but uh oh yes

00:32:53,919 --> 00:33:00,309
this is Heroku is like original web page

00:32:57,059 --> 00:33:02,529
this is in October of 2008 you notice

00:33:00,309 --> 00:33:04,689
the good beta tag up there on the left

00:33:02,529 --> 00:33:08,079
like this is like prime like web 2.0

00:33:04,689 --> 00:33:11,109
like awesomeness of web design but it's

00:33:08,079 --> 00:33:12,729
a Ruby on Rails platform originally with

00:33:11,109 --> 00:33:13,900
Heroku like you couldn't run whatever

00:33:12,729 --> 00:33:16,150
stuff you wanted

00:33:13,900 --> 00:33:17,890
you could only run rails applications

00:33:16,150 --> 00:33:19,240
and that's because the idea with the

00:33:17,890 --> 00:33:20,830
platform as-a-service is that you would

00:33:19,240 --> 00:33:22,450
just upload your app and you would never

00:33:20,830 --> 00:33:24,130
associate you to a server anywhere and

00:33:22,450 --> 00:33:26,140
des would figure out all the details and

00:33:24,130 --> 00:33:28,330
that meant that the server provider had

00:33:26,140 --> 00:33:30,400
to provide an API if you will for every

00:33:28,330 --> 00:33:32,140
single kind of application that you

00:33:30,400 --> 00:33:34,059
wanted to run and that meant that that

00:33:32,140 --> 00:33:36,130
was like more difficult because they

00:33:34,059 --> 00:33:37,780
couldn't just support rails only and as

00:33:36,130 --> 00:33:38,890
they grew they added other languages and

00:33:37,780 --> 00:33:40,780
did other things and so did all the

00:33:38,890 --> 00:33:43,180
other providers but I think this shift

00:33:40,780 --> 00:33:44,950
between opera giving a general OS and

00:33:43,180 --> 00:33:48,240
giving an application specific thing is

00:33:44,950 --> 00:33:51,010
like more significant than we think

00:33:48,240 --> 00:33:52,780
yeah is the rails platform there was

00:33:51,010 --> 00:33:54,610
this company called doc cloud that

00:33:52,780 --> 00:33:56,080
existed around this time this logo is

00:33:54,610 --> 00:33:57,550
also fuzzy because almost all their

00:33:56,080 --> 00:34:00,760
stuff has been like scraped from the web

00:33:57,550 --> 00:34:02,410
at this point they were a similar Heroku

00:34:00,760 --> 00:34:03,880
ish provider but they were one of the

00:34:02,410 --> 00:34:05,920
first that I personally remember that

00:34:03,880 --> 00:34:07,660
offered the ability for you to use more

00:34:05,920 --> 00:34:09,159
than just one particular kind of thing

00:34:07,660 --> 00:34:10,780
and that's because they were working on

00:34:09,159 --> 00:34:14,770
this technology but you may have heard

00:34:10,780 --> 00:34:16,179
of called docker they ended up open

00:34:14,770 --> 00:34:17,830
sourcing docker and then their business

00:34:16,179 --> 00:34:19,270
imploded because it was open source I

00:34:17,830 --> 00:34:21,879
guess I'm not totally sure if that's

00:34:19,270 --> 00:34:23,110
true but like it doc cloud morphed into

00:34:21,879 --> 00:34:25,000
docker and that's why I couldn't find

00:34:23,110 --> 00:34:26,200
their logo it had to dig really hard

00:34:25,000 --> 00:34:27,730
because it was like difficult because

00:34:26,200 --> 00:34:28,780
their websites gone and our crafted

00:34:27,730 --> 00:34:32,290
organ doesn't have it either which is

00:34:28,780 --> 00:34:34,780
strange but anyway docker gave these

00:34:32,290 --> 00:34:37,330
platforms the ability to again offer an

00:34:34,780 --> 00:34:38,740
operating system as the like unit that

00:34:37,330 --> 00:34:40,960
you would be able to give to the

00:34:38,740 --> 00:34:42,190
platform as its API so that you now be

00:34:40,960 --> 00:34:44,139
able to support all kinds of other

00:34:42,190 --> 00:34:46,750
things and that's when we get tools like

00:34:44,139 --> 00:34:49,270
kubernetes and all these other sort of

00:34:46,750 --> 00:34:51,460
aspects and so instead of us having the

00:34:49,270 --> 00:34:53,590
platform specific api's for each

00:34:51,460 --> 00:34:55,810
particular language a runtime we instead

00:34:53,590 --> 00:34:58,210
had docker and you would just run a

00:34:55,810 --> 00:34:58,920
bunch of containers everywhere instead

00:34:58,210 --> 00:35:01,420
of you know

00:34:58,920 --> 00:35:03,370
SSH into a server or like uploading your

00:35:01,420 --> 00:35:04,690
application specific thing the platform

00:35:03,370 --> 00:35:06,460
would essentially implement docker

00:35:04,690 --> 00:35:07,810
containers and you would hand them a

00:35:06,460 --> 00:35:09,670
container with whatever you wanted in it

00:35:07,810 --> 00:35:12,550
and then you could do anything and this

00:35:09,670 --> 00:35:14,650
became this made things much easier all

00:35:12,550 --> 00:35:15,760
right I'm almost done I have one little

00:35:14,650 --> 00:35:17,980
last bit here and that's about the

00:35:15,760 --> 00:35:19,390
future of serverless I'm gonna blow

00:35:17,980 --> 00:35:21,010
through it because I know that you all

00:35:19,390 --> 00:35:23,020
have lunch next so I don't wanna hold

00:35:21,010 --> 00:35:25,240
you too hard so docker is a container

00:35:23,020 --> 00:35:27,770
but you know what else is like a form of

00:35:25,240 --> 00:35:30,380
container a web browser

00:35:27,770 --> 00:35:31,790
uh it turns out that you download and

00:35:30,380 --> 00:35:33,530
run arbitrary code from arbitrary

00:35:31,790 --> 00:35:35,900
sources every single day I'm doing it

00:35:33,530 --> 00:35:38,510
right now in Google Docs to make this

00:35:35,900 --> 00:35:40,310
presentation and so like it turns out

00:35:38,510 --> 00:35:42,380
that if you squint hard enough these are

00:35:40,310 --> 00:35:44,240
almost the same thing like we had this

00:35:42,380 --> 00:35:46,400
particular diagram before this is the

00:35:44,240 --> 00:35:48,080
same diagram as that docker diagram

00:35:46,400 --> 00:35:50,120
earlier where you make a dr. container

00:35:48,080 --> 00:35:53,120
and you upload it to the servers you can

00:35:50,120 --> 00:35:54,890
write web assembly and like it's almost

00:35:53,120 --> 00:35:56,330
the same thing stalker which gives us

00:35:54,890 --> 00:35:58,160
back to that original tweet if we had

00:35:56,330 --> 00:35:59,390
had a runtime that was isolated then

00:35:58,160 --> 00:36:00,980
these hosting providers could have

00:35:59,390 --> 00:36:02,900
offered an abstracted way to run

00:36:00,980 --> 00:36:04,730
whatever code you wanted without like

00:36:02,900 --> 00:36:07,490
needing to you know do this all this

00:36:04,730 --> 00:36:09,140
isolation stuff themselves and so this

00:36:07,490 --> 00:36:10,940
also referenced the original tweet is

00:36:09,140 --> 00:36:12,830
y'see which is the sort of extension to

00:36:10,940 --> 00:36:14,510
wisdom and if you want to learn more

00:36:12,830 --> 00:36:16,190
about huazi I suggest that you get in

00:36:14,510 --> 00:36:17,870
your nearest local time machine and go

00:36:16,190 --> 00:36:20,840
back to yesterday and watch Lin's talk

00:36:17,870 --> 00:36:21,980
on huazi us sadly she's not after me so

00:36:20,840 --> 00:36:23,720
I can't tell you to go to it but if you

00:36:21,980 --> 00:36:25,820
saw it she went into the details of what

00:36:23,720 --> 00:36:27,440
was he is and all these things but I'm

00:36:25,820 --> 00:36:29,180
not gonna get into that super deep I'm

00:36:27,440 --> 00:36:30,890
just gonna say that a huazi lets you

00:36:29,180 --> 00:36:32,270
sort of like break out of the sandbox in

00:36:30,890 --> 00:36:34,040
a controlled way so it gives you access

00:36:32,270 --> 00:36:35,630
to things like the file system but also

00:36:34,040 --> 00:36:38,150
lets you control what kinds of things

00:36:35,630 --> 00:36:40,610
the application is allowed to do and so

00:36:38,150 --> 00:36:41,690
this combines with the last topic I want

00:36:40,610 --> 00:36:44,330
to talk about today which is edge

00:36:41,690 --> 00:36:46,370
computing I work at CloudFlare but this

00:36:44,330 --> 00:36:48,200
is not a cloud player product pitch this

00:36:46,370 --> 00:36:50,570
is also a thing that fastly is doing so

00:36:48,200 --> 00:36:51,830
you know but this is like a trend that's

00:36:50,570 --> 00:36:53,000
been happening lately that I don't think

00:36:51,830 --> 00:36:55,760
a lot of people are also appreciating

00:36:53,000 --> 00:36:58,490
the server this world here's an ax list

00:36:55,760 --> 00:37:00,710
of AWS locations there are 69 of them

00:36:58,490 --> 00:37:02,990
according to a double uses website and

00:37:00,710 --> 00:37:05,150
they're planning on some more so if you

00:37:02,990 --> 00:37:06,920
are a user say you're in West Africa and

00:37:05,150 --> 00:37:08,900
you want to use something that's on AWS

00:37:06,920 --> 00:37:10,870
then you've got a long way to go to get

00:37:08,900 --> 00:37:12,980
to wherever your code is actually hosted

00:37:10,870 --> 00:37:15,620
but if you look at the networks of

00:37:12,980 --> 00:37:17,510
people like fastly or like CloudFlare

00:37:15,620 --> 00:37:20,630
there's significantly more locations

00:37:17,510 --> 00:37:21,650
around the world and that's because they

00:37:20,630 --> 00:37:24,260
were trying to build a global network

00:37:21,650 --> 00:37:25,220
for CDN and security purposes and they

00:37:24,260 --> 00:37:27,590
weren't trying to build a bunch of

00:37:25,220 --> 00:37:28,760
server farms but like both of these are

00:37:27,590 --> 00:37:30,170
basically giant buildings with a bunch

00:37:28,760 --> 00:37:31,760
of computers in them so at some point

00:37:30,170 --> 00:37:33,440
cloud flare and fastly both kind of

00:37:31,760 --> 00:37:34,700
realized hey we sort of have a bunch of

00:37:33,440 --> 00:37:37,730
server farms and we have a lot more of

00:37:34,700 --> 00:37:39,710
them than AWS does and so there was this

00:37:37,730 --> 00:37:40,910
old slogan in Java times called write

00:37:39,710 --> 00:37:42,500
once run any

00:37:40,910 --> 00:37:43,910
we're and that meant that your code was

00:37:42,500 --> 00:37:45,830
platform-agnostic and so you could run

00:37:43,910 --> 00:37:48,110
it on any part that you wanted but uh

00:37:45,830 --> 00:37:50,540
this is like write once run anywhere

00:37:48,110 --> 00:37:52,460
like in a physical sense like you write

00:37:50,540 --> 00:37:54,320
your code one time and you deploy it to

00:37:52,460 --> 00:37:56,600
all of these things simultaneously

00:37:54,320 --> 00:37:58,520
so in AWS model it gets deployed to the

00:37:56,600 --> 00:38:01,460
particular locations that you want to

00:37:58,520 --> 00:38:02,780
and pay for but in in this world you

00:38:01,460 --> 00:38:05,240
just write your code once and it goes to

00:38:02,780 --> 00:38:07,040
the edge of every single node in both of

00:38:05,240 --> 00:38:09,410
these companies networks and you can

00:38:07,040 --> 00:38:11,900
also sort of do this with lambda at edge

00:38:09,410 --> 00:38:14,360
which runs a subset of lambda on cloud

00:38:11,900 --> 00:38:15,830
fronts so AWS is also doing this too I

00:38:14,360 --> 00:38:17,570
just don't think they're pushing this is

00:38:15,830 --> 00:38:19,310
hard but what's enable this to happen

00:38:17,570 --> 00:38:20,750
with these smaller companies like clouds

00:38:19,310 --> 00:38:23,360
layer and fastly are not the size fate

00:38:20,750 --> 00:38:25,250
of us at all is due to web assembly and

00:38:23,360 --> 00:38:26,540
so instead of having to build out all

00:38:25,250 --> 00:38:28,040
the separate runtimes for these

00:38:26,540 --> 00:38:30,680
different features they're letting you

00:38:28,040 --> 00:38:33,170
run web assembly code on the edge and so

00:38:30,680 --> 00:38:34,640
fast these things called terrarium and

00:38:33,170 --> 00:38:36,740
ours is called cloud flower workers and

00:38:34,640 --> 00:38:38,150
effectively you're able to like write

00:38:36,740 --> 00:38:39,830
your code and whatever you want compile

00:38:38,150 --> 00:38:42,980
it to Azzam and then run it everywhere

00:38:39,830 --> 00:38:44,660
all over the world but to tie these all

00:38:42,980 --> 00:38:46,250
things together what's interesting about

00:38:44,660 --> 00:38:47,510
this is that the cause of all that work

00:38:46,250 --> 00:38:49,790
that we've been putting in with rust to

00:38:47,510 --> 00:38:51,980
make web assembly tooling awesome the

00:38:49,790 --> 00:38:53,630
run time that they use it fastly called

00:38:51,980 --> 00:38:55,280
loose it and a lot of our tooling

00:38:53,630 --> 00:38:57,970
Wrangler is the command line app to let

00:38:55,280 --> 00:39:00,590
you build stuff for for cloud fleurs

00:38:57,970 --> 00:39:02,120
products these are all written in rust

00:39:00,590 --> 00:39:04,100
and we're seeing an increasing amount of

00:39:02,120 --> 00:39:05,600
stuff around the web assembly space be

00:39:04,100 --> 00:39:06,920
implemented in rust cause rust already

00:39:05,600 --> 00:39:09,050
has these tools so it makes it easier to

00:39:06,920 --> 00:39:11,690
build stuff and and all that stuff is

00:39:09,050 --> 00:39:13,580
there so that's that's why the the rust

00:39:11,690 --> 00:39:14,810
tie-ins this kind of like how all these

00:39:13,580 --> 00:39:17,420
random things are sort of coming

00:39:14,810 --> 00:39:19,520
together these are the takeaways from my

00:39:17,420 --> 00:39:22,690
talk if you will the first one is that

00:39:19,520 --> 00:39:25,640
rusts loves web assembly and vice versa

00:39:22,690 --> 00:39:26,990
wasm and server lists are thinking about

00:39:25,640 --> 00:39:28,700
I'm not sure this is a thing that's

00:39:26,990 --> 00:39:30,200
actually going to happen happen but

00:39:28,700 --> 00:39:32,090
we're trying to make it happen this is

00:39:30,200 --> 00:39:33,470
one possible future I'd be lying if I

00:39:32,090 --> 00:39:34,850
could tell you that I knew the future

00:39:33,470 --> 00:39:36,680
for sure but this is an interesting

00:39:34,850 --> 00:39:38,150
thing that I'm seeing happen and I think

00:39:36,680 --> 00:39:39,470
is gonna be more significant and then

00:39:38,150 --> 00:39:41,030
finally edge compute is like a cool idea

00:39:39,470 --> 00:39:42,710
and you should check it out and I think

00:39:41,030 --> 00:39:44,000
that it's a really interesting extension

00:39:42,710 --> 00:39:45,460
of the serverless model that we've been

00:39:44,000 --> 00:39:48,710
all been using for last couple years

00:39:45,460 --> 00:39:54,550
thank you so much and please enjoy lunch

00:39:48,710 --> 00:39:54,550

YouTube URL: https://www.youtube.com/watch?v=CMB6AlE1QuI


