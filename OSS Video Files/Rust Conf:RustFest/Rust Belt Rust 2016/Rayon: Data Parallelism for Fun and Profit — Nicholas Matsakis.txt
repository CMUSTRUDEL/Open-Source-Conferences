Title: Rayon: Data Parallelism for Fun and Profit â€” Nicholas Matsakis
Publication date: 2017-10-25
Playlist: Rust Belt Rust 2016
Description: 
	Materials for this talk are available at https://speakerdeck.com/nikomatsakis/rayon-rust-belt-rust

Rayon is a convenient library for adding parallelism into Rust programs. Rayon allows you to easily convert for loops using iterators to run in parallel, as well as recursive functions. Under the covers, Rayon uses work-stealing to dynamically balance your parallel processing, allowing it to scale gracefully to different numbers or processors and a diverse range of workloads. Best of all, thanks to Rust's ownership and borrowing sytem, using Rayon is guaranteed not to add data races to your programs. This talk will summarize how you can use Rayon in your own programs, as well as lifting the covers to show how Rayon itself is implemented.

http://www.rust-belt-rust.com/
Captions: 
	00:00:06,670 --> 00:00:15,590
okay all right so earlier we were

00:00:13,820 --> 00:00:17,540
talking about rust in 2017 and

00:00:15,590 --> 00:00:19,580
everything and that's kind of what I do

00:00:17,540 --> 00:00:22,220
during the day but this is what I do for

00:00:19,580 --> 00:00:24,380
fun so I want to talk a little bit about

00:00:22,220 --> 00:00:26,920
rayon which is this library that I've

00:00:24,380 --> 00:00:30,769
been hacking on on and off for a while

00:00:26,920 --> 00:00:33,680
the idea of rayon is I want to make it

00:00:30,769 --> 00:00:35,629
easy for you to add parallelism into

00:00:33,680 --> 00:00:38,629
your code and specifically I want to

00:00:35,629 --> 00:00:40,580
make it really easy for you to take kind

00:00:38,629 --> 00:00:42,979
of for loops or iterators that you were

00:00:40,580 --> 00:00:44,059
doing and make them run in parallel and

00:00:42,979 --> 00:00:46,489
so some function that took too long

00:00:44,059 --> 00:00:50,540
should take less time and people often

00:00:46,489 --> 00:00:52,100
call that data parallelism and so if you

00:00:50,540 --> 00:00:54,739
look at this piece of code right this is

00:00:52,100 --> 00:00:57,170
a sequential loop using iterators to

00:00:54,739 --> 00:00:59,239
load a bunch of images off the disk and

00:00:57,170 --> 00:01:01,309
so probably many people here are

00:00:59,239 --> 00:01:03,470
familiar with iterators but the basic

00:01:01,309 --> 00:01:06,350
idea is right you have to start with in

00:01:03,470 --> 00:01:08,450
this case a slice so like an array of

00:01:06,350 --> 00:01:10,940
paths and we're gonna create an iterator

00:01:08,450 --> 00:01:12,710
and that's a little thing that it

00:01:10,940 --> 00:01:14,840
doesn't actually do anything yet it lets

00:01:12,710 --> 00:01:16,370
me build up something that describes

00:01:14,840 --> 00:01:17,870
what to do when I actually do the loop

00:01:16,370 --> 00:01:19,130
right so initially I have just this

00:01:17,870 --> 00:01:21,260
blanket iterator that would just be

00:01:19,130 --> 00:01:23,510
saying okay go up and give me one path

00:01:21,260 --> 00:01:25,400
give me each path as I go through and

00:01:23,510 --> 00:01:27,110
then I'm gonna call map and what that

00:01:25,400 --> 00:01:28,580
says it's kind of for each path I'm

00:01:27,110 --> 00:01:31,550
gonna invoke this function which is

00:01:28,580 --> 00:01:32,900
gonna call image load so I had paths now

00:01:31,550 --> 00:01:34,730
I'm gonna have actually images loaded

00:01:32,900 --> 00:01:36,050
off the disk but I still haven't done

00:01:34,730 --> 00:01:37,550
anything yet I'm still just building an

00:01:36,050 --> 00:01:39,740
iterator describing what I will do

00:01:37,550 --> 00:01:41,720
they're kind of lazy like that right and

00:01:39,740 --> 00:01:44,420
here when I call collect that's when the

00:01:41,720 --> 00:01:46,970
actual iteration happens so it starts to

00:01:44,420 --> 00:01:49,610
iterate through for each path it's gonna

00:01:46,970 --> 00:01:51,800
call image load and we'll end up with a

00:01:49,610 --> 00:01:53,750
set of images which will store into a

00:01:51,800 --> 00:01:55,550
vector and we figure out that we want a

00:01:53,750 --> 00:01:57,710
vector because that's the return type of

00:01:55,550 --> 00:02:00,140
this function so what I'd like you to be

00:01:57,710 --> 00:02:02,210
able to do is say well loading an image

00:02:00,140 --> 00:02:04,670
is something that I could easily do in

00:02:02,210 --> 00:02:08,299
parallel so why don't I just do that by

00:02:04,670 --> 00:02:09,470
changing a dirted operator and ideally

00:02:08,299 --> 00:02:11,299
that's all you have to do and in fact

00:02:09,470 --> 00:02:12,830
which way on that is all you have to do

00:02:11,299 --> 00:02:16,819
except you have to add one import that I

00:02:12,830 --> 00:02:18,260
didn't show use rayon quaalude star so

00:02:16,819 --> 00:02:20,390
that's pretty cool all right

00:02:18,260 --> 00:02:22,010
and you can now load a full directory of

00:02:20,390 --> 00:02:24,530
images and it'll go a little bit faster

00:02:22,010 --> 00:02:25,819
but there are a lot of languages

00:02:24,530 --> 00:02:28,489
actually that will let you do things

00:02:25,819 --> 00:02:30,799
like this but one of the catches is you

00:02:28,489 --> 00:02:32,599
have to know that it's safe to do it in

00:02:30,799 --> 00:02:34,069
parallel right it's very easy to think

00:02:32,599 --> 00:02:36,049
something safe to do in parallel but

00:02:34,069 --> 00:02:37,910
actually maybe you'll get different

00:02:36,049 --> 00:02:39,860
surprising results where your program

00:02:37,910 --> 00:02:42,650
doesn't work so here's an example of

00:02:39,860 --> 00:02:44,390
something you might have done you might

00:02:42,650 --> 00:02:46,400
have had a little counter and you were

00:02:44,390 --> 00:02:49,040
trying to track here you go this is what

00:02:46,400 --> 00:02:50,480
I added right choice trying to track how

00:02:49,040 --> 00:02:52,250
many ping files you had as you went

00:02:50,480 --> 00:02:53,480
through so you have a counter and you

00:02:52,250 --> 00:02:55,280
add one to it as you go

00:02:53,480 --> 00:02:57,290
that seems fine that was fine in

00:02:55,280 --> 00:02:59,420
sequential code but if you try to do

00:02:57,290 --> 00:03:02,030
this in parallel it's not so good and

00:02:59,420 --> 00:03:03,890
the problem is that you have what's

00:03:02,030 --> 00:03:06,079
called a data race and really what

00:03:03,890 --> 00:03:07,879
happens is kind of a simple way to think

00:03:06,079 --> 00:03:09,500
about it is that adding a number is a

00:03:07,879 --> 00:03:11,150
three-step operation right I have to

00:03:09,500 --> 00:03:13,519
load the first the number out of memory

00:03:11,150 --> 00:03:15,290
add one to it and then put it back and

00:03:13,519 --> 00:03:16,879
if you have two threads doing that they

00:03:15,290 --> 00:03:19,609
might both load up the number and they

00:03:16,879 --> 00:03:20,810
both say let's say C 0 they both add 1

00:03:19,609 --> 00:03:23,150
they both have one now and they both

00:03:20,810 --> 00:03:25,280
store one we should have two but we only

00:03:23,150 --> 00:03:26,989
have one is the total count and what's

00:03:25,280 --> 00:03:29,510
kind of nasty about these bugs is that a

00:03:26,989 --> 00:03:31,579
lot of times they don't show up very

00:03:29,510 --> 00:03:34,040
consistently right so it might work just

00:03:31,579 --> 00:03:35,239
fine on your computer maybe you only

00:03:34,040 --> 00:03:38,000
have two cores or something and they

00:03:35,239 --> 00:03:39,169
rarely conflict but once in a while or

00:03:38,000 --> 00:03:42,919
maybe you have a big directory of full

00:03:39,169 --> 00:03:46,099
of images and so the right count is 1556

00:03:42,919 --> 00:03:47,180
and your count is 1442 and of course you

00:03:46,099 --> 00:03:48,260
didn't actually count them by hand so

00:03:47,180 --> 00:03:50,540
you don't know that it's wrong and your

00:03:48,260 --> 00:03:52,310
program just keeps going right but in

00:03:50,540 --> 00:03:54,829
rest if we use beyond what will happen

00:03:52,310 --> 00:03:58,489
is we just won't compile it all right so

00:03:54,829 --> 00:04:00,500
the goal is kind of when you add this

00:03:58,489 --> 00:04:02,209
part it or not only should it work in

00:04:00,500 --> 00:04:03,760
parallel and hopefully run faster if you

00:04:02,209 --> 00:04:06,470
have enough work to make it worthwhile

00:04:03,760 --> 00:04:08,510
but in case there is actually a problem

00:04:06,470 --> 00:04:10,519
it should let you know right so don't

00:04:08,510 --> 00:04:12,889
just go and do the wrong thing and there

00:04:10,519 --> 00:04:14,959
was a fun blog post not written by me

00:04:12,889 --> 00:04:17,209
that kind of went into this or someone

00:04:14,959 --> 00:04:18,410
added in Rayong and they got some errors

00:04:17,209 --> 00:04:20,570
and when they traced it out it turned

00:04:18,410 --> 00:04:22,250
out that there was basically this same

00:04:20,570 --> 00:04:24,050
bug I just showed you where a counter

00:04:22,250 --> 00:04:25,699
was getting incremented but it wasn't

00:04:24,050 --> 00:04:27,349
like in one function and easy to see it

00:04:25,699 --> 00:04:28,490
was spread apart several modules and it

00:04:27,349 --> 00:04:30,710
would have taken them forever to track

00:04:28,490 --> 00:04:31,920
it down but it just didn't happen at all

00:04:30,710 --> 00:04:33,690
in the first place

00:04:31,920 --> 00:04:35,070
they weren't happy about that and I was

00:04:33,690 --> 00:04:38,760
happy because they wrote a cool blog

00:04:35,070 --> 00:04:41,690
post so this is the structure of rayon

00:04:38,760 --> 00:04:44,580
and it's also the structure of my talk

00:04:41,690 --> 00:04:46,260
rands kind of broken up into several

00:04:44,580 --> 00:04:47,640
layers right there are these parallel

00:04:46,260 --> 00:04:50,070
iterators that I just showed you and

00:04:47,640 --> 00:04:52,680
those are actually essentially all safe

00:04:50,070 --> 00:04:54,990
code they're like a library written on

00:04:52,680 --> 00:04:59,190
top of a more fundamental abstraction

00:04:54,990 --> 00:05:01,590
and that's called join and join offers

00:04:59,190 --> 00:05:03,030
up a safe interface that lets you

00:05:01,590 --> 00:05:05,610
essentially start two threads as we'll

00:05:03,030 --> 00:05:08,400
see but internally it's implemented with

00:05:05,610 --> 00:05:09,570
unsafe code and it uses this technique

00:05:08,400 --> 00:05:11,820
called work-stealing we'll talk about

00:05:09,570 --> 00:05:13,050
and that's based on this thread pool

00:05:11,820 --> 00:05:15,390
that's kind of the underlying bit of

00:05:13,050 --> 00:05:17,340
code so I'm gonna start talking about

00:05:15,390 --> 00:05:18,840
parallel iterators so I'll show you how

00:05:17,340 --> 00:05:20,970
you can use them and some of the things

00:05:18,840 --> 00:05:24,090
to be aware of then talk about join and

00:05:20,970 --> 00:05:25,860
how it works and talk a little bit about

00:05:24,090 --> 00:05:30,230
how the thread pool manages to do load

00:05:25,860 --> 00:05:32,970
balancing and stuff like that so okay

00:05:30,230 --> 00:05:34,920
sequential iterators we saw these are

00:05:32,970 --> 00:05:38,460
like normal iterators right the basic

00:05:34,920 --> 00:05:39,720
idea the basic reason that sequential

00:05:38,460 --> 00:05:41,220
and parallel is not always the same is

00:05:39,720 --> 00:05:43,020
that sequential goes from left to right

00:05:41,220 --> 00:05:45,300
all the time right

00:05:43,020 --> 00:05:47,430
but in parallel the whole point is we

00:05:45,300 --> 00:05:49,470
want to process in any order and

00:05:47,430 --> 00:05:51,150
sometimes more than one at a time right

00:05:49,470 --> 00:05:53,640
and that means that some things that we

00:05:51,150 --> 00:05:55,350
used to do just don't make sense in that

00:05:53,640 --> 00:05:57,120
setting right so ideally would always be

00:05:55,350 --> 00:06:00,150
as simple as changing dot iterative part

00:05:57,120 --> 00:06:01,740
to dot parter but it's not always quite

00:06:00,150 --> 00:06:06,870
that simple there are a few things that

00:06:01,740 --> 00:06:08,700
might lead to two surprises the first

00:06:06,870 --> 00:06:13,050
one we already saw which is that you

00:06:08,700 --> 00:06:14,910
can't really mutate shared state in

00:06:13,050 --> 00:06:16,050
these two videos because as we saw like

00:06:14,910 --> 00:06:19,110
when you try to both increment a counter

00:06:16,050 --> 00:06:20,460
you might get confused and another

00:06:19,110 --> 00:06:22,260
problem is that some of the iterator

00:06:20,460 --> 00:06:25,200
combinators actually just don't make

00:06:22,260 --> 00:06:27,450
sense in parallel at all like fold as

00:06:25,200 --> 00:06:28,590
we'll see and so we have to do different

00:06:27,450 --> 00:06:31,320
combinators that work a little bit

00:06:28,590 --> 00:06:33,360
differently and finally this is a spare

00:06:31,320 --> 00:06:34,740
time project a lot of times things would

00:06:33,360 --> 00:06:35,550
be just fine but nobody got around to

00:06:34,740 --> 00:06:38,180
implementing them yet

00:06:35,550 --> 00:06:41,590
so you know PR is welcome

00:06:38,180 --> 00:06:44,150
but it's a it's a work in progress right

00:06:41,590 --> 00:06:46,160
so let's come back to this first one

00:06:44,150 --> 00:06:48,770
about shared state this was my example I

00:06:46,160 --> 00:06:51,320
showed you before where you have this

00:06:48,770 --> 00:06:54,380
counter and I said it's bad because

00:06:51,320 --> 00:06:56,539
you're gonna be incrementing it in two

00:06:54,380 --> 00:06:58,580
different threads and we don't want to

00:06:56,539 --> 00:07:00,680
do that and you might infer from this

00:06:58,580 --> 00:07:02,630
that maybe you can't do any mutation at

00:07:00,680 --> 00:07:04,550
all when you're doing parallel iteration

00:07:02,630 --> 00:07:06,050
and a lot of people I think equate these

00:07:04,550 --> 00:07:08,060
sort of things they said well if I'm

00:07:06,050 --> 00:07:09,500
gonna do parallel iteration I really

00:07:08,060 --> 00:07:11,210
need or a parallel work I really need a

00:07:09,500 --> 00:07:12,919
functional approach I can't do any

00:07:11,210 --> 00:07:15,979
mutation and so on that's not really

00:07:12,919 --> 00:07:17,810
true it is helpful but it is perfectly

00:07:15,979 --> 00:07:19,940
fine to mutate in parallel as long as

00:07:17,810 --> 00:07:21,710
you're mutating different things right

00:07:19,940 --> 00:07:24,320
so here's an example where I have a

00:07:21,710 --> 00:07:28,370
function that has a mutable slice of

00:07:24,320 --> 00:07:30,229
integers which it goes over and this is

00:07:28,370 --> 00:07:32,539
still sequential of course and it's

00:07:30,229 --> 00:07:34,250
calling it ER mute so if you haven't

00:07:32,539 --> 00:07:35,750
used it ER ators too much the difference

00:07:34,250 --> 00:07:38,150
between it ER and inter mute is that it

00:07:35,750 --> 00:07:40,009
ER mute gives you a mutable reference

00:07:38,150 --> 00:07:42,020
into the elements so you can kind of

00:07:40,009 --> 00:07:46,190
change them as you iterate over them in

00:07:42,020 --> 00:07:48,260
place right so here this variable C is

00:07:46,190 --> 00:07:49,820
going to be basically first a reference

00:07:48,260 --> 00:07:51,740
to the first thing in the slice then the

00:07:49,820 --> 00:07:54,620
second one and the third one and so on

00:07:51,740 --> 00:07:57,050
and so for each one we're gonna

00:07:54,620 --> 00:07:59,120
increment it so effectively when we give

00:07:57,050 --> 00:08:02,690
this as input a slice that has like 0 1

00:07:59,120 --> 00:08:05,000
2 3 4 will get output 1 2 3 4 5 right

00:08:02,690 --> 00:08:07,009
everything up by 1 and we can do this in

00:08:05,000 --> 00:08:09,470
parallel there's no problem it looks a

00:08:07,009 --> 00:08:11,449
little bit different but not too much of

00:08:09,470 --> 00:08:14,060
course we do pirate or mute to go into

00:08:11,449 --> 00:08:16,250
the parallel mode and then we have to do

00:08:14,060 --> 00:08:18,320
this dot for each that's because for in

00:08:16,250 --> 00:08:20,000
rest is like the sequential syntax it's

00:08:18,320 --> 00:08:21,860
kind of built into the language so we

00:08:20,000 --> 00:08:24,110
use for each instead so that I can

00:08:21,860 --> 00:08:26,360
actually run it in parallel but

00:08:24,110 --> 00:08:28,460
essentially it's the same idea right

00:08:26,360 --> 00:08:30,169
we're gonna call this closure for all

00:08:28,460 --> 00:08:32,539
the things in parallel and it has a

00:08:30,169 --> 00:08:34,099
reference C pointing into the array and

00:08:32,539 --> 00:08:36,440
it can increment so this is exactly

00:08:34,099 --> 00:08:38,810
equivalent right and the key point is

00:08:36,440 --> 00:08:40,399
the data was not shared between the

00:08:38,810 --> 00:08:42,880
iterations the data we were going to

00:08:40,399 --> 00:08:45,350
mutate so sometimes that will be because

00:08:42,880 --> 00:08:47,209
we've used something like para term ute

00:08:45,350 --> 00:08:49,790
that's kind of subdividing an array into

00:08:47,209 --> 00:08:51,440
lots of disjoint mutable pieces each one

00:08:49,790 --> 00:08:52,100
separate and sometimes it might be

00:08:51,440 --> 00:08:55,459
because

00:08:52,100 --> 00:08:56,750
you've just got immutable well I'm not

00:08:55,459 --> 00:08:58,190
so much with parallel iterators but more

00:08:56,750 --> 00:09:00,079
if you were using join which lets you

00:08:58,190 --> 00:09:01,670
start two threads you might have some

00:09:00,079 --> 00:09:02,930
mutable data that goes to one thread and

00:09:01,670 --> 00:09:04,579
other immutable data that goes to the

00:09:02,930 --> 00:09:06,079
other and that's perfectly fine as long

00:09:04,579 --> 00:09:10,699
as the same mutable data doesn't try to

00:09:06,079 --> 00:09:13,279
go to both right so okay that's good but

00:09:10,699 --> 00:09:15,529
how could I in Christ ill want to count

00:09:13,279 --> 00:09:17,089
all the pings in my directory right

00:09:15,529 --> 00:09:18,649
I don't and how can I actually do that

00:09:17,089 --> 00:09:21,350
there are a couple ways you could do it

00:09:18,649 --> 00:09:22,850
one way might be you might split this

00:09:21,350 --> 00:09:24,980
loop up instead of doing everything in

00:09:22,850 --> 00:09:30,019
one walk over the list of pads you might

00:09:24,980 --> 00:09:32,120
do two so here you would have this first

00:09:30,019 --> 00:09:34,940
pass where you iterate over the paths

00:09:32,120 --> 00:09:38,089
and we filter out so we just select only

00:09:34,940 --> 00:09:39,829
the pads that end in ping and then we

00:09:38,089 --> 00:09:41,269
call dot map to convert each one of

00:09:39,829 --> 00:09:44,000
those to the number one and then we add

00:09:41,269 --> 00:09:45,709
up all the numbers ones you could also

00:09:44,000 --> 00:09:46,910
call dot count except that I hadn't

00:09:45,709 --> 00:09:49,069
implemented it when I made these slides

00:09:46,910 --> 00:09:50,810
but I recently opened a PR this morning

00:09:49,069 --> 00:09:54,079
so I was like this is ridiculous we

00:09:50,810 --> 00:09:56,810
should have that count so in a few days

00:09:54,079 --> 00:09:58,850
maybe you can so that would be one way

00:09:56,810 --> 00:10:02,810
to do it and there is actually another

00:09:58,850 --> 00:10:04,370
way right and but this way is a little

00:10:02,810 --> 00:10:05,779
bit sneaky err and I actually don't

00:10:04,370 --> 00:10:09,440
probably recommend you do it this way

00:10:05,779 --> 00:10:11,480
but it's interesting to know about the

00:10:09,440 --> 00:10:14,839
standard library offers these cool types

00:10:11,480 --> 00:10:16,639
called atomic types and they're they're

00:10:14,839 --> 00:10:18,889
hidden deep in this foreboding path

00:10:16,639 --> 00:10:21,170
hierarchy what they let you do is

00:10:18,889 --> 00:10:24,410
actually have mutable state that is

00:10:21,170 --> 00:10:25,970
shared between threads right and so in

00:10:24,410 --> 00:10:28,850
this case we'll be using something

00:10:25,970 --> 00:10:30,860
called atomic you size right and we can

00:10:28,850 --> 00:10:33,709
make it like this so let pings equals

00:10:30,860 --> 00:10:36,529
atomic you size new 0 and now pings is

00:10:33,709 --> 00:10:38,449
going to be also still an integer but

00:10:36,529 --> 00:10:40,370
it's one that we can only access through

00:10:38,449 --> 00:10:42,500
the atomic you size API in the atomic

00:10:40,370 --> 00:10:44,209
you size API is kind of special because

00:10:42,500 --> 00:10:45,920
since when I told you that normally when

00:10:44,209 --> 00:10:48,290
you increment things it's a three-step

00:10:45,920 --> 00:10:50,240
process where you read the value add 1

00:10:48,290 --> 00:10:51,889
and write it back atomic you size makes

00:10:50,240 --> 00:10:54,980
sure that all of those steps are done

00:10:51,889 --> 00:10:58,939
without anybody else interrupting you so

00:10:54,980 --> 00:11:00,139
you can add to too many threads can add

00:10:58,939 --> 00:11:02,839
to the counter of safely without

00:11:00,139 --> 00:11:05,220
stepping on one another's toes alright

00:11:02,839 --> 00:11:06,750
so we can change this codes instead of

00:11:05,220 --> 00:11:08,970
Ping's plus equals one now I get to

00:11:06,750 --> 00:11:12,509
write things that fetch add one ordering

00:11:08,970 --> 00:11:13,920
sequentially consistent I another thing

00:11:12,509 --> 00:11:15,269
I strongly recommend is that you at

00:11:13,920 --> 00:11:16,709
least start with the sequentially

00:11:15,269 --> 00:11:18,199
consistent ordering especially if you

00:11:16,709 --> 00:11:20,160
don't know what I'm what that means

00:11:18,199 --> 00:11:25,949
basically that means things work like

00:11:20,160 --> 00:11:28,519
you expect them to and so what this will

00:11:25,949 --> 00:11:30,959
do is this will exactly like before so

00:11:28,519 --> 00:11:32,970
when in the sequential code pings was a

00:11:30,959 --> 00:11:36,930
counter that was kind of saying how many

00:11:32,970 --> 00:11:39,120
pings had I seen so far right and when I

00:11:36,930 --> 00:11:40,709
should I mean when I go back to the old

00:11:39,120 --> 00:11:42,449
version here where I broke pings out

00:11:40,709 --> 00:11:43,829
into a separate loop that was a little

00:11:42,449 --> 00:11:45,300
bit different right because now pings

00:11:43,829 --> 00:11:48,860
wasn't the counter of how many I'd seen

00:11:45,300 --> 00:11:50,879
so far it's a count of the total number

00:11:48,860 --> 00:11:52,920
so if we want to go back to how many

00:11:50,879 --> 00:11:55,290
we've seen so far we can use atomic you

00:11:52,920 --> 00:11:57,209
size so now again pings is representing

00:11:55,290 --> 00:11:58,740
how many have I seen so far but unlike

00:11:57,209 --> 00:12:00,180
in the sequential case that's not an

00:11:58,740 --> 00:12:02,730
easy thing to think about

00:12:00,180 --> 00:12:04,290
right before it was oh it didn't in the

00:12:02,730 --> 00:12:05,459
sequential case it didn't change as we

00:12:04,290 --> 00:12:06,959
were going because it was just all the

00:12:05,459 --> 00:12:08,579
people to the left and they were waiting

00:12:06,959 --> 00:12:10,769
for me but here there might be other

00:12:08,579 --> 00:12:13,470
people going at the same time so every

00:12:10,769 --> 00:12:14,670
time I read pins even in two lines right

00:12:13,470 --> 00:12:17,129
next to each other I might get different

00:12:14,670 --> 00:12:18,899
values right and that's why I suggest

00:12:17,129 --> 00:12:20,759
that that's why I say that you can do

00:12:18,899 --> 00:12:22,589
this if you want to have a counter that

00:12:20,759 --> 00:12:23,910
you're incrementing but you know use it

00:12:22,589 --> 00:12:26,819
at your own risk because it's very easy

00:12:23,910 --> 00:12:28,170
to forget that two lines right next to

00:12:26,819 --> 00:12:30,480
each other can get interrupted by other

00:12:28,170 --> 00:12:32,220
operations so another thing you could do

00:12:30,480 --> 00:12:35,309
is use a mutex of integer and so forth

00:12:32,220 --> 00:12:39,180
but I think at that point it's over

00:12:35,309 --> 00:12:40,980
overkill for this example let's say any

00:12:39,180 --> 00:12:43,050
case the main thing is there are these

00:12:40,980 --> 00:12:44,370
Atomics so you can do writes if you

00:12:43,050 --> 00:12:45,990
really want to but you have to be aware

00:12:44,370 --> 00:12:47,309
this is where if you don't use the

00:12:45,990 --> 00:12:49,769
tommix essentially your code should

00:12:47,309 --> 00:12:51,300
either compile and do pretty much the

00:12:49,769 --> 00:12:53,040
same thing or not compile for some

00:12:51,300 --> 00:12:54,329
reason for use Atomics it starts to be

00:12:53,040 --> 00:12:55,379
that it could compile but acting in

00:12:54,329 --> 00:12:56,579
quite different ways because you've

00:12:55,379 --> 00:13:03,029
added all the lot of threads into the

00:12:56,579 --> 00:13:05,329
system um so that's that's shared State

00:13:03,029 --> 00:13:08,250
I also mentioned that some Combinator's

00:13:05,329 --> 00:13:10,379
just don't make sense in parallel and

00:13:08,250 --> 00:13:12,839
here's an example of one so this is a

00:13:10,379 --> 00:13:14,370
sequential loop standard iterators and

00:13:12,839 --> 00:13:16,960
it's doing this thing called a dot

00:13:14,370 --> 00:13:20,620
product which you may remember from math

00:13:16,960 --> 00:13:23,050
I didn't but I like to use it anyway

00:13:20,620 --> 00:13:24,970
like I remember the name right so

00:13:23,050 --> 00:13:26,920
basically what a dot product does it

00:13:24,970 --> 00:13:28,840
takes two big vectors of numbers that

00:13:26,920 --> 00:13:31,210
are the same length and it walks over

00:13:28,840 --> 00:13:33,070
them in lockstep right so we might start

00:13:31,210 --> 00:13:34,840
with the three and the two from these

00:13:33,070 --> 00:13:37,630
two vectors we multiply them together

00:13:34,840 --> 00:13:39,940
that's what this map is and that gives

00:13:37,630 --> 00:13:42,340
us a number like here six that's the

00:13:39,940 --> 00:13:45,310
product of the two and then we add up

00:13:42,340 --> 00:13:47,920
all those products and we can do that ad

00:13:45,310 --> 00:13:49,390
we could call dot sum but this is what

00:13:47,920 --> 00:13:51,400
dots um does is actually just called bat

00:13:49,390 --> 00:13:53,650
fold so we can use this operation called

00:13:51,400 --> 00:13:55,570
fold and what a full does is it has like

00:13:53,650 --> 00:13:57,190
an accumulator and then the thing that

00:13:55,570 --> 00:13:58,960
keeps getting accumulated in with this

00:13:57,190 --> 00:14:00,970
closure in operation so in this case

00:13:58,960 --> 00:14:03,130
we'll be accumulating by adding alright

00:14:00,970 --> 00:14:04,690
so we start out with zero that's the

00:14:03,130 --> 00:14:06,400
initial value of our accumulator and

00:14:04,690 --> 00:14:07,810
then we take six and we add them

00:14:06,400 --> 00:14:10,840
together and that's our new accumulator

00:14:07,810 --> 00:14:13,900
so the sum so far is six and then we

00:14:10,840 --> 00:14:16,270
would go to the next item here we have

00:14:13,900 --> 00:14:19,000
two and one we multiply them we add it

00:14:16,270 --> 00:14:20,050
in our number change to eight and we can

00:14:19,000 --> 00:14:22,210
kind of keep doing this and we'll

00:14:20,050 --> 00:14:25,150
eventually if I typed it in my computer

00:14:22,210 --> 00:14:27,160
right we'll get 82 right that's our dot

00:14:25,150 --> 00:14:29,110
product and you can see that this is

00:14:27,160 --> 00:14:31,630
this fold operation is very sequential

00:14:29,110 --> 00:14:33,520
it said start with an accumulator take

00:14:31,630 --> 00:14:35,830
the next item put it in take the next

00:14:33,520 --> 00:14:38,410
item put it in it doesn't really make

00:14:35,830 --> 00:14:40,750
sense to paralyze it so if you go in

00:14:38,410 --> 00:14:42,340
parallel there is something that you can

00:14:40,750 --> 00:14:43,510
use to do parallel sums but it works a

00:14:42,340 --> 00:14:45,280
little differently and so I gave it a

00:14:43,510 --> 00:14:47,230
different name to kind of warn you so

00:14:45,280 --> 00:14:49,030
this is another case of the code won't

00:14:47,230 --> 00:14:51,910
compile if it wouldn't do kind of the

00:14:49,030 --> 00:14:54,460
same thing so this thing is called

00:14:51,910 --> 00:14:57,040
reduce and reduce kind of works like

00:14:54,460 --> 00:14:59,050
fold except that instead of starting

00:14:57,040 --> 00:15:01,750
from the left and going to the right it

00:14:59,050 --> 00:15:04,320
essentially breaks your your list into

00:15:01,750 --> 00:15:06,040
little pieces independent pieces and

00:15:04,320 --> 00:15:07,270
rayon will figure out kind of

00:15:06,040 --> 00:15:09,880
automatically how big these pieces

00:15:07,270 --> 00:15:11,140
should be or try to write and it will do

00:15:09,880 --> 00:15:13,300
them all in parallel with one another

00:15:11,140 --> 00:15:15,430
and within any individual piece you're

00:15:13,300 --> 00:15:17,410
essentially doing a fold alright so we

00:15:15,430 --> 00:15:19,630
might start we have now here three

00:15:17,410 --> 00:15:22,240
chunks and we can compute three partial

00:15:19,630 --> 00:15:24,010
sums we have twenty for the first four

00:15:22,240 --> 00:15:27,040
and then 19 for the next four and then

00:15:24,010 --> 00:15:28,390
43 for the last three and now that's

00:15:27,040 --> 00:15:30,160
good and then we have to combine those

00:15:28,390 --> 00:15:30,490
partial sums to get the total sum over

00:15:30,160 --> 00:15:32,380
the whole

00:15:30,490 --> 00:15:35,200
thing right so then we would add 20 in

00:15:32,380 --> 00:15:37,390
nineteen and we get 39 and we add in 43

00:15:35,200 --> 00:15:38,770
and we get 82 you can see this worked a

00:15:37,390 --> 00:15:40,930
little bit differently not only did it

00:15:38,770 --> 00:15:42,820
not go from left to right but one other

00:15:40,930 --> 00:15:46,270
more subtle difference was that this

00:15:42,820 --> 00:15:48,850
closure the a plus B in the fold case

00:15:46,270 --> 00:15:50,860
the B value was always something coming

00:15:48,850 --> 00:15:52,510
out of the iterator and a was always the

00:15:50,860 --> 00:15:53,560
accumulator so they could even have

00:15:52,510 --> 00:15:55,480
different types they don't have to be

00:15:53,560 --> 00:15:59,170
the same sort of value in the reduce

00:15:55,480 --> 00:16:01,180
case the a plus B the a and B can

00:15:59,170 --> 00:16:02,410
sometimes be things one is an

00:16:01,180 --> 00:16:03,880
accumulator and one is a thing you're

00:16:02,410 --> 00:16:06,040
iterating over that's when you're

00:16:03,880 --> 00:16:08,410
computing that first row but then after

00:16:06,040 --> 00:16:10,360
that the a plus B the a might be 20 and

00:16:08,410 --> 00:16:11,740
the B might be 19 those are partial sums

00:16:10,360 --> 00:16:14,080
they never appeared in our iterator

00:16:11,740 --> 00:16:15,730
right so the types have to be the same

00:16:14,080 --> 00:16:17,649
and so that kind of shows up in the

00:16:15,730 --> 00:16:20,740
signature so we essentially reduce

00:16:17,649 --> 00:16:22,240
probably most folds that you do in

00:16:20,740 --> 00:16:24,010
practice reduce probably works just fine

00:16:22,240 --> 00:16:25,390
but not all I need to be a little

00:16:24,010 --> 00:16:27,490
careful you particularly want

00:16:25,390 --> 00:16:29,020
I think it's commutative operations or

00:16:27,490 --> 00:16:30,339
maybe it's associative associative the

00:16:29,020 --> 00:16:35,170
ones that you can change the parentheses

00:16:30,339 --> 00:16:38,860
I always get them mixed up okay so in

00:16:35,170 --> 00:16:40,839
summary parallel iterators are basically

00:16:38,860 --> 00:16:42,760
mostly like normal iterators but you

00:16:40,839 --> 00:16:44,230
can't mutate shared state and you have

00:16:42,760 --> 00:16:45,940
to watch out for some operations that

00:16:44,230 --> 00:16:48,640
are just a little different so another

00:16:45,940 --> 00:16:50,500
example is find right fine finds in a

00:16:48,640 --> 00:16:52,720
sequential iterator the first thing that

00:16:50,500 --> 00:16:54,490
matches some predicate and in parallel

00:16:52,720 --> 00:16:55,570
of course you don't want to find the

00:16:54,490 --> 00:16:57,220
first thing you want to find something

00:16:55,570 --> 00:17:01,360
because they're gonna be searching all

00:16:57,220 --> 00:17:03,850
over you might depends what you want so

00:17:01,360 --> 00:17:05,410
the goal is that for the most part rust

00:17:03,850 --> 00:17:07,660
and the design of rayon will protect you

00:17:05,410 --> 00:17:09,790
from surprises by saying if it compiles

00:17:07,660 --> 00:17:12,069
it should kind of work like you expects

00:17:09,790 --> 00:17:15,339
and otherwise B you'll try to do it you

00:17:12,069 --> 00:17:16,809
may have to make some small changes all

00:17:15,339 --> 00:17:19,000
right so that's how parallel iterators

00:17:16,809 --> 00:17:20,800
work and what I want to do now is take a

00:17:19,000 --> 00:17:22,179
step down and look at how they're

00:17:20,800 --> 00:17:25,270
actually implemented and how the thread

00:17:22,179 --> 00:17:26,800
pool works so the core operation in

00:17:25,270 --> 00:17:29,020
rayon is actually this thing called join

00:17:26,800 --> 00:17:33,220
and what join does is it takes two

00:17:29,020 --> 00:17:35,530
closures and essentially potentially

00:17:33,220 --> 00:17:37,809
executes them in parallel waits for

00:17:35,530 --> 00:17:41,110
those two threads to finish and then

00:17:37,809 --> 00:17:43,419
returns back to you right so the idea is

00:17:41,110 --> 00:17:44,230
that you should add join wherever

00:17:43,419 --> 00:17:46,840
parallelism

00:17:44,230 --> 00:17:48,190
might make sense wherever it's possible

00:17:46,840 --> 00:17:50,140
to do safely so where these things are

00:17:48,190 --> 00:17:53,230
not accessing shared mutable state

00:17:50,140 --> 00:17:55,510
essentially and then rayon will decide

00:17:53,230 --> 00:17:57,010
when it thinks it actually will be

00:17:55,510 --> 00:17:58,950
profitable when your code will actually

00:17:57,010 --> 00:18:01,809
go faster because if you think about it

00:17:58,950 --> 00:18:03,100
you don't even know you your code may

00:18:01,809 --> 00:18:04,390
run you don't know how many cores are on

00:18:03,100 --> 00:18:05,890
that machine you don't know if they're

00:18:04,390 --> 00:18:07,870
playing an mp3 in the background that's

00:18:05,890 --> 00:18:09,190
taking up one of the cores or not it's

00:18:07,870 --> 00:18:11,049
hard for you to judge just how many

00:18:09,190 --> 00:18:12,850
threads do you want so a rayon tries to

00:18:11,049 --> 00:18:15,490
do is look dynamically using these

00:18:12,850 --> 00:18:17,200
schemes and figure out how many threads

00:18:15,490 --> 00:18:19,960
when it makes sense to split work and so

00:18:17,200 --> 00:18:21,700
on so you might wonder like okay that

00:18:19,960 --> 00:18:23,230
join makes sense and parallel iterators

00:18:21,700 --> 00:18:24,370
make sense but how do i how would I ever

00:18:23,230 --> 00:18:26,320
get between them they seem pretty

00:18:24,370 --> 00:18:27,820
different well the way it works is

00:18:26,320 --> 00:18:29,620
basically something called divide and

00:18:27,820 --> 00:18:31,690
conquer which is this common strategy we

00:18:29,620 --> 00:18:34,000
can use a lot so basically a parallel

00:18:31,690 --> 00:18:35,559
iterator starts out and says I have a

00:18:34,000 --> 00:18:37,870
big pool of work to do I have to go over

00:18:35,559 --> 00:18:40,179
all of these paths so that's like my

00:18:37,870 --> 00:18:42,130
first job and I also have this tool

00:18:40,179 --> 00:18:43,929
joins what I'm gonna do is make my work

00:18:42,130 --> 00:18:46,000
easier I'm gonna divide the list of

00:18:43,929 --> 00:18:47,559
paths into halves and then I'm gonna

00:18:46,000 --> 00:18:49,210
spawn with join two different threads

00:18:47,559 --> 00:18:53,020
one to do the left half and one to do

00:18:49,210 --> 00:18:54,669
the right half okay so then when the

00:18:53,020 --> 00:18:55,929
left half thread starts up it says okay

00:18:54,669 --> 00:18:57,790
well I still have a lot I still have six

00:18:55,929 --> 00:19:00,070
paths to go I'm gonna split these into 2

00:18:57,790 --> 00:19:02,650
1 4 3 1 4 3 and I'll use join to go like

00:19:00,070 --> 00:19:04,090
fork them off and this kind of repeats

00:19:02,650 --> 00:19:06,280
right the right hand side will do the

00:19:04,090 --> 00:19:07,840
same will keep going until we have what

00:19:06,280 --> 00:19:08,470
seems to be a sufficiently small amount

00:19:07,840 --> 00:19:10,750
of work to do

00:19:08,470 --> 00:19:12,940
maybe it's 1 maybe it's a little more

00:19:10,750 --> 00:19:14,700
and then we'll actually execute the

00:19:12,940 --> 00:19:18,130
iterator just sequentially like normal

00:19:14,700 --> 00:19:20,650
so here this first job would actually

00:19:18,130 --> 00:19:22,690
call image loaded paths of 0 effectively

00:19:20,650 --> 00:19:24,370
and the second job would load image

00:19:22,690 --> 00:19:30,580
loaded paths of 1 right and then this

00:19:24,370 --> 00:19:32,860
would filter back up now I said that

00:19:30,580 --> 00:19:34,929
join doesn't always start new threads

00:19:32,860 --> 00:19:36,160
right so conceptually I'm kind of

00:19:34,929 --> 00:19:38,380
starting new threads and it's always

00:19:36,160 --> 00:19:41,020
safe to do so but how is it really

00:19:38,380 --> 00:19:43,990
implemented at runtime the idea is that

00:19:41,020 --> 00:19:47,140
we wind up having one thread roughly per

00:19:43,990 --> 00:19:49,179
CPU in your system and those are the

00:19:47,140 --> 00:19:50,500
worker threads and then we have those

00:19:49,179 --> 00:19:52,240
things those things that go to join

00:19:50,500 --> 00:19:53,950
those are called tasks and we're gonna

00:19:52,240 --> 00:19:55,809
kind of multiplex them we're gonna have

00:19:53,950 --> 00:19:57,940
the worker threads share that pool of

00:19:55,809 --> 00:19:58,360
tasks that are available and do as much

00:19:57,940 --> 00:19:59,680
work as

00:19:58,360 --> 00:20:01,750
they can when they can and we're using a

00:19:59,680 --> 00:20:03,670
technique called work-stealing which was

00:20:01,750 --> 00:20:05,380
I think pioneered and invented by the

00:20:03,670 --> 00:20:08,200
people who did soap but it was at least

00:20:05,380 --> 00:20:08,950
popularized by them silk is a project

00:20:08,200 --> 00:20:10,900
out of MIT

00:20:08,950 --> 00:20:14,610
the name rayon is because it's a fake

00:20:10,900 --> 00:20:17,380
silk in case you were curious and so

00:20:14,610 --> 00:20:19,240
what how does that work well it's

00:20:17,380 --> 00:20:20,500
basically like this every thread has a

00:20:19,240 --> 00:20:21,880
little list of work to do

00:20:20,500 --> 00:20:25,420
which is called a double-ended queue

00:20:21,880 --> 00:20:27,010
here I just work queue so those thread

00:20:25,420 --> 00:20:29,890
might start out with a job like process

00:20:27,010 --> 00:20:32,080
the whole array from 0 to 22 and so it's

00:20:29,890 --> 00:20:33,400
gonna split that and call join and what

00:20:32,080 --> 00:20:35,020
join does is it takes one of those

00:20:33,400 --> 00:20:37,600
closures and sticks it on this list of

00:20:35,020 --> 00:20:39,310
work to do later that will be 15 to 22

00:20:37,600 --> 00:20:40,540
and then it just starts right in on the

00:20:39,310 --> 00:20:43,510
on the other one just calls it like

00:20:40,540 --> 00:20:46,600
normal so now 0 to 15 is executing and

00:20:43,510 --> 00:20:47,860
this will again split and we'll put one

00:20:46,600 --> 00:20:50,320
on the queue for later and we'll do this

00:20:47,860 --> 00:20:52,450
0 to 1 and maybe we'll finish that job

00:20:50,320 --> 00:20:54,160
right and then what do we do when we

00:20:52,450 --> 00:20:56,110
finished a job is we go back to our list

00:20:54,160 --> 00:20:57,610
of stuff to do later and we take the

00:20:56,110 --> 00:20:59,890
thing off the top the most recent thing

00:20:57,610 --> 00:21:02,650
so we'll go over here and start doing 1

00:20:59,890 --> 00:21:05,530
to 15 right and that's kind of thread a

00:21:02,650 --> 00:21:07,000
but thread B is just sitting around

00:21:05,530 --> 00:21:08,740
twiddling its thumbs and nothing to do

00:21:07,000 --> 00:21:10,840
and threads don't like to be idle

00:21:08,740 --> 00:21:13,060
so what thread B will do is say I'm

00:21:10,840 --> 00:21:14,950
gonna go look for work to do and it goes

00:21:13,060 --> 00:21:16,180
when it has nothing else to do it goes

00:21:14,950 --> 00:21:18,340
and looks at other threads to see if

00:21:16,180 --> 00:21:20,170
they have any work on their list that

00:21:18,340 --> 00:21:22,570
they haven't started yet and we call

00:21:20,170 --> 00:21:23,890
that work stealing right it's kind of a

00:21:22,570 --> 00:21:25,990
funny term because it's like a thief

00:21:23,890 --> 00:21:28,030
breaks into your house and says look

00:21:25,990 --> 00:21:29,860
this guy's a pile of wonder dirty dishes

00:21:28,030 --> 00:21:33,880
I'm gonna start doing those I'll be

00:21:29,860 --> 00:21:35,620
helpful so you know it's a nice thing so

00:21:33,880 --> 00:21:39,220
the thread becomes in Steel's 15 to 22

00:21:35,620 --> 00:21:40,690
to help thread AAA out and thread B then

00:21:39,220 --> 00:21:43,360
does basically the same thing it splits

00:21:40,690 --> 00:21:46,090
it up into two jobs puts one on its list

00:21:43,360 --> 00:21:47,950
of work to do later and goes in does it

00:21:46,090 --> 00:21:51,130
again it goes down the left side and

00:21:47,950 --> 00:21:53,590
here it actually finishes a work item so

00:21:51,130 --> 00:21:54,850
it does exactly what thread a did pulls

00:21:53,590 --> 00:21:57,040
off the top thing on its queue and

00:21:54,850 --> 00:21:59,170
starts doing that but meanwhile while

00:21:57,040 --> 00:22:00,520
thread B is doing all that stuff thread

00:21:59,170 --> 00:22:03,130
a is probably finished with the work it

00:22:00,520 --> 00:22:05,290
was doing so it's gonna come back and

00:22:03,130 --> 00:22:07,980
try to go to this next thing that was on

00:22:05,290 --> 00:22:10,630
its queue right only that got stolen so

00:22:07,980 --> 00:22:11,770
that's not really left for us to do so

00:22:10,630 --> 00:22:14,290
now thread a has nothing

00:22:11,770 --> 00:22:15,640
do so what does it do well it goes and

00:22:14,290 --> 00:22:17,350
tries to steal back so this is like I

00:22:15,640 --> 00:22:18,850
come home I find the thief and I say oh

00:22:17,350 --> 00:22:20,230
hey give me that pot while you do the

00:22:18,850 --> 00:22:22,200
dishes that's great I'll take care of

00:22:20,230 --> 00:22:24,460
that one so we're all working together

00:22:22,200 --> 00:22:25,150
everybody's stealing back back and forth

00:22:24,460 --> 00:22:27,640
from one another

00:22:25,150 --> 00:22:29,590
and I take eighteen to twenty-two off of

00:22:27,640 --> 00:22:31,300
thread B's Q and if a day starts

00:22:29,590 --> 00:22:33,490
processing it right and in this way we

00:22:31,300 --> 00:22:36,280
kind of split up the pool and whenever

00:22:33,490 --> 00:22:38,500
someone is idle they go fill in and help

00:22:36,280 --> 00:22:40,840
somebody else out right and the cool

00:22:38,500 --> 00:22:43,090
thing is if some of these tasks may take

00:22:40,840 --> 00:22:44,980
more time than others right sometimes

00:22:43,090 --> 00:22:46,060
they're very uniform like add one to

00:22:44,980 --> 00:22:48,100
every unit or that's gonna take about

00:22:46,060 --> 00:22:50,050
the same time but while loading an image

00:22:48,100 --> 00:22:51,460
if the images of different sizes maybe

00:22:50,050 --> 00:22:53,380
one image takes a really long time and

00:22:51,460 --> 00:22:54,970
the rest are really fast that's okay

00:22:53,380 --> 00:22:56,620
because if thread a gets stuck doing one

00:22:54,970 --> 00:22:58,690
image that B can just keep stealing work

00:22:56,620 --> 00:23:04,960
and it's fine right it'll kind of fill

00:22:58,690 --> 00:23:06,550
in so that's the basic idea and there

00:23:04,960 --> 00:23:08,110
are ways to make it better for example

00:23:06,550 --> 00:23:09,490
there was a recent PR that I thought was

00:23:08,110 --> 00:23:11,770
really cool so I wanted to highlight

00:23:09,490 --> 00:23:15,130
this was Josh stone or COO VIPRE his

00:23:11,770 --> 00:23:16,660
contribution that basically refines that

00:23:15,130 --> 00:23:18,400
idea by also being a little bit more

00:23:16,660 --> 00:23:20,980
concerned by being careful about when to

00:23:18,400 --> 00:23:23,740
actually join so it uses tricks like

00:23:20,980 --> 00:23:25,210
trying to gauge is there likely to be

00:23:23,740 --> 00:23:26,950
anyone who's going to steal this work

00:23:25,210 --> 00:23:28,180
because if not I won't bother to join

00:23:26,950 --> 00:23:30,220
because that takes a little extra time

00:23:28,180 --> 00:23:31,390
and so there are there any ways to make

00:23:30,220 --> 00:23:36,520
this better and I'm sure it can get

00:23:31,390 --> 00:23:37,840
better still but that about sums it up

00:23:36,520 --> 00:23:40,180
that's really most of the big ideas in

00:23:37,840 --> 00:23:41,620
ran right so essentially we have the

00:23:40,180 --> 00:23:44,260
parallel iterators and the join and

00:23:41,620 --> 00:23:46,030
together using these we can kind of

00:23:44,260 --> 00:23:47,560
easily add parallelism into our programs

00:23:46,030 --> 00:23:49,060
sometimes just because it's cool

00:23:47,560 --> 00:23:52,240
sometimes because it's actually running

00:23:49,060 --> 00:23:54,010
slowly and there's a bunch of different

00:23:52,240 --> 00:23:55,480
API is available so there's actually a

00:23:54,010 --> 00:23:58,030
third API I didn't have time to talk

00:23:55,480 --> 00:24:00,160
about called scope that is sometimes

00:23:58,030 --> 00:24:02,140
kind of an alternative to join it's good

00:24:00,160 --> 00:24:03,400
for other situations it's kind of nice

00:24:02,140 --> 00:24:06,280
to read the library and figure out which

00:24:03,400 --> 00:24:07,600
is the best for your particular task and

00:24:06,280 --> 00:24:10,660
there's a lot of cool directions that we

00:24:07,600 --> 00:24:13,480
can take this of course can always have

00:24:10,660 --> 00:24:15,190
more iterators but there's also I think

00:24:13,480 --> 00:24:18,120
it should be possible to do things like

00:24:15,190 --> 00:24:20,130
automatically convert to symbiotes

00:24:18,120 --> 00:24:21,690
and integrate nice data structures like

00:24:20,130 --> 00:24:22,890
persistent trees and maybe factor out

00:24:21,690 --> 00:24:25,169
this thread pool into something that

00:24:22,890 --> 00:24:27,419
lots of projects could use not just

00:24:25,169 --> 00:24:30,620
rayon so I'm excited to see where the

00:24:27,419 --> 00:24:30,620
future goes thanks everybody

00:24:36,770 --> 00:24:38,830

YouTube URL: https://www.youtube.com/watch?v=gof_OEv71Aw


