Title: Integrating some Rust in VLC media player â€” Geoffroy Couprie
Publication date: 2017-10-25
Playlist: Rust Belt Rust 2016
Description: 
	Materials for this talk are available at http://dev.unhandledexpression.com/slides/rust-belt-rust-2016/vlc/

VLC media player has a nice goal for users: handle almost any file or protocol you throw at it. Unfortunately, this results in a lot of parser vulnerabilities, because most of the parsing code is handwritten in C. By leveraging Rust and the nom parser combinators library, could we replace some security critical parts of VLC?

http://www.rust-belt-rust.com
Captions: 
	00:00:05,590 --> 00:00:10,690
I'm so far I'm rehab G to be here in

00:00:08,110 --> 00:00:12,910
Pittsburgh's my first time in Pittsburgh

00:00:10,690 --> 00:00:16,420
I've but the project that's been going

00:00:12,910 --> 00:00:19,810
on my life like some time now and was

00:00:16,420 --> 00:00:21,820
the reason I initially came to worst so

00:00:19,810 --> 00:00:25,570
I'm pretty pretty excited to talk to you

00:00:21,820 --> 00:00:27,460
about that so hope you think I work at

00:00:25,570 --> 00:00:32,529
clever cloud which is a French but from

00:00:27,460 --> 00:00:35,050
a service hosting company so it's just

00:00:32,529 --> 00:00:37,929
kind of like a Roku and others you get

00:00:35,050 --> 00:00:40,059
push your card it runs we we've been

00:00:37,929 --> 00:00:42,339
doing some rest a lot these past few

00:00:40,059 --> 00:00:44,739
months we have actually a lot of code in

00:00:42,339 --> 00:00:47,050
production that's using rust we have

00:00:44,739 --> 00:00:49,510
replaced big parts of the infrastructure

00:00:47,050 --> 00:00:52,749
and I'm really happy to announce that

00:00:49,510 --> 00:00:56,710
now you can deploy rust application on

00:00:52,749 --> 00:01:00,010
our platform so it's just basically a

00:00:56,710 --> 00:01:01,899
Calculon on the cloud push on as many

00:01:00,010 --> 00:01:02,350
instances you want it's inverted

00:01:01,899 --> 00:01:05,530
machines

00:01:02,350 --> 00:01:06,880
it works with stable and I tested it

00:01:05,530 --> 00:01:09,729
this morning it was really really cool

00:01:06,880 --> 00:01:12,280
to use so I'm really really excited

00:01:09,729 --> 00:01:13,899
about that because like it takes some

00:01:12,280 --> 00:01:16,899
time to support new platform and like

00:01:13,899 --> 00:01:21,460
rust was so easy to get there it's

00:01:16,899 --> 00:01:24,759
amazing so let's talk about this little

00:01:21,460 --> 00:01:29,110
project but I realize which I worked for

00:01:24,759 --> 00:01:33,719
for a few years so Videoland makes VLC

00:01:29,110 --> 00:01:37,270
media player which is a media player and

00:01:33,719 --> 00:01:40,420
the idea of VLC is basically you drag

00:01:37,270 --> 00:01:42,250
and drop any file and it will work it

00:01:40,420 --> 00:01:48,820
should work with like almost any format

00:01:42,250 --> 00:01:52,659
HTTP FTP as input or file and before MKV

00:01:48,820 --> 00:01:54,369
in any codec anything it should work so

00:01:52,659 --> 00:01:57,609
it's a pretty big goal but it kind of

00:01:54,369 --> 00:01:59,890
works but doesn't issue that when you

00:01:57,609 --> 00:02:02,890
try to handle like as many foremast

00:01:59,890 --> 00:02:06,549
formats as existing so as our existing

00:02:02,890 --> 00:02:08,649
that you got vulnerabilities like so

00:02:06,549 --> 00:02:12,790
those are a few months we got in the

00:02:08,649 --> 00:02:14,500
past few years the mp4 dimacs mp4 path

00:02:12,790 --> 00:02:15,610
is very interesting because like it's

00:02:14,500 --> 00:02:18,460
not

00:02:15,610 --> 00:02:20,080
not like very complex as a format but

00:02:18,460 --> 00:02:22,450
like this is very very ambiguous very

00:02:20,080 --> 00:02:28,690
hard to get right because there are lots

00:02:22,450 --> 00:02:32,830
of competing implementations so VLC is

00:02:28,690 --> 00:02:35,590
made in C it's like 100,000 of lines of

00:02:32,830 --> 00:02:39,840
C everywhere and all this all the

00:02:35,590 --> 00:02:42,670
passing code is written in C so we get

00:02:39,840 --> 00:02:45,190
manual passes where people just try to

00:02:42,670 --> 00:02:47,920
interpret the specification do pointer

00:02:45,190 --> 00:02:50,410
arithmetic by hand we have formats that

00:02:47,920 --> 00:02:54,580
are very very ambiguous very complex to

00:02:50,410 --> 00:02:56,290
get right and so at some point I thought

00:02:54,580 --> 00:02:59,290
maybe there was a better solution for

00:02:56,290 --> 00:03:01,360
writing pathos in VLC and make the whole

00:02:59,290 --> 00:03:03,760
application safer so that way that's why

00:03:01,360 --> 00:03:04,540
I went looking for something like you

00:03:03,760 --> 00:03:07,239
see where I'm going

00:03:04,540 --> 00:03:09,280
I wanted something that's memory safe in

00:03:07,239 --> 00:03:12,310
which you can write correct correct code

00:03:09,280 --> 00:03:14,020
easily and that you can embed in C

00:03:12,310 --> 00:03:16,090
because otherwise I'd like yeah I tried

00:03:14,020 --> 00:03:17,770
to propose Haskell at some point and

00:03:16,090 --> 00:03:19,600
thus it was not a good idea to have a

00:03:17,770 --> 00:03:25,930
garbage collected language in media

00:03:19,600 --> 00:03:29,080
replication and that can work in

00:03:25,930 --> 00:03:30,310
streaming like you got data coming and

00:03:29,080 --> 00:03:32,950
coming and coming and you have to pass

00:03:30,310 --> 00:03:35,019
that very very fast because if you've

00:03:32,950 --> 00:03:39,610
not like blocked the rest of the

00:03:35,019 --> 00:03:43,090
decoding so already have one thing we

00:03:39,610 --> 00:03:47,290
have memory safe stuff can we get like

00:03:43,090 --> 00:03:48,820
good passes with rust well yes but I

00:03:47,290 --> 00:03:52,120
don't know if you've been going to the

00:03:48,820 --> 00:03:54,670
fanzine workshop yesterday but like even

00:03:52,120 --> 00:03:56,320
if you use rust you will get crashes in

00:03:54,670 --> 00:03:59,590
parser when you write manual passes

00:03:56,320 --> 00:04:01,570
because it's still hard to get right so

00:03:59,590 --> 00:04:04,680
that's why I started to work on this

00:04:01,570 --> 00:04:04,680
little project called Nam

00:04:04,930 --> 00:04:11,300
with the idea that it should be easy to

00:04:08,540 --> 00:04:11,830
write a good passer and should be a fun

00:04:11,300 --> 00:04:16,370
process

00:04:11,830 --> 00:04:18,560
so none basically is to fix it's it's

00:04:16,370 --> 00:04:21,200
the approach passing called the passer

00:04:18,560 --> 00:04:24,350
combinators the idea is that you have a

00:04:21,200 --> 00:04:26,990
lot of small functions a very very small

00:04:24,350 --> 00:04:29,570
rate testable like you can you test any

00:04:26,990 --> 00:04:33,139
part of your parser and you combine them

00:04:29,570 --> 00:04:35,450
in larger parser in larger recognizer

00:04:33,139 --> 00:04:39,290
and then you get like the whole format

00:04:35,450 --> 00:04:41,960
and to do that right there are different

00:04:39,290 --> 00:04:44,300
approaches to passing in rows and long

00:04:41,960 --> 00:04:46,820
story short when I started Russ was very

00:04:44,300 --> 00:04:48,650
very young and macros were very good

00:04:46,820 --> 00:04:52,160
solution for that and I think they are

00:04:48,650 --> 00:04:57,460
still but you will you will see how we

00:04:52,160 --> 00:05:00,530
really can get so basically rust none

00:04:57,460 --> 00:05:03,080
those are just functions one attack an

00:05:00,530 --> 00:05:05,630
input type an output type and rare type

00:05:03,080 --> 00:05:09,200
and when you get input into a function

00:05:05,630 --> 00:05:11,990
it will get ever incomplete to say okay

00:05:09,200 --> 00:05:14,240
I need more data which is very useful

00:05:11,990 --> 00:05:15,650
when you're doing streaming like maybe

00:05:14,240 --> 00:05:21,169
you need to fill up the buffer a bit

00:05:15,650 --> 00:05:23,180
more no Don contains the remaining input

00:05:21,169 --> 00:05:25,580
what has not been consumed and the

00:05:23,180 --> 00:05:28,460
output beta so it's it's really simple

00:05:25,580 --> 00:05:30,620
all the non passers at this format this

00:05:28,460 --> 00:05:33,110
is why I can combine them very easy

00:05:30,620 --> 00:05:36,080
because they all follow the same the

00:05:33,110 --> 00:05:40,220
same type so yeah

00:05:36,080 --> 00:05:44,260
macros are hard right yeah not so much

00:05:40,220 --> 00:05:47,330
this is a posture that will recognize

00:05:44,260 --> 00:05:50,960
alphabetic characters that terminate it

00:05:47,330 --> 00:05:54,380
by digit characters and will return the

00:05:50,960 --> 00:05:57,080
Alpha we are focused so and this

00:05:54,380 --> 00:05:58,820
will make a function that takes byte

00:05:57,080 --> 00:06:02,060
slices input and returns the backdrops

00:05:58,820 --> 00:06:04,880
so it's quite easy to write when you

00:06:02,060 --> 00:06:08,419
expand that the macro generate a

00:06:04,880 --> 00:06:10,910
function that takes as I said as input

00:06:08,419 --> 00:06:13,280
bytes lights as output with the same

00:06:10,910 --> 00:06:17,190
lifetime and everything so like I only

00:06:13,280 --> 00:06:21,290
get slice of the input data I don't

00:06:17,190 --> 00:06:24,090
anything could be passing fast and

00:06:21,290 --> 00:06:28,380
basically it's just a big list of

00:06:24,090 --> 00:06:31,350
pattern matching so it's not so bad

00:06:28,380 --> 00:06:35,490
right well actually it looks not like

00:06:31,350 --> 00:06:39,810
that but it's not that bad as well just

00:06:35,490 --> 00:06:44,370
need to be a bit more explicit in the

00:06:39,810 --> 00:06:46,890
way it does the pattern matching lots of

00:06:44,370 --> 00:06:49,290
interesting features so it works on my

00:06:46,890 --> 00:06:52,020
slides it was all strings on bitstreams

00:06:49,290 --> 00:06:57,810
so like you have a format that marks

00:06:52,020 --> 00:07:00,900
like on an even underlined size of a bit

00:06:57,810 --> 00:07:04,040
like someone asked few weeks ago I want

00:07:00,900 --> 00:07:09,240
to pass a list of eleven bit integers

00:07:04,040 --> 00:07:11,400
yeah Bitcoin okay and you have the

00:07:09,240 --> 00:07:15,330
combinators so like there was just

00:07:11,400 --> 00:07:17,340
before terminated pass the first thing

00:07:15,330 --> 00:07:20,040
pass the second return results for the

00:07:17,340 --> 00:07:22,500
first and there are lots of different

00:07:20,040 --> 00:07:24,330
communities like many we try to apply

00:07:22,500 --> 00:07:28,410
again and again and again and return a

00:07:24,330 --> 00:07:31,160
vector of the results pair will generate

00:07:28,410 --> 00:07:36,210
a topper with first result second result

00:07:31,160 --> 00:07:38,850
peak will recon will take will type a

00:07:36,210 --> 00:07:40,890
cell on the input see if it works

00:07:38,850 --> 00:07:42,600
correctly but will not consume anything

00:07:40,890 --> 00:07:44,430
just takes a look at the data and say

00:07:42,600 --> 00:07:47,160
okay it's alright it's what I reckon

00:07:44,430 --> 00:07:51,210
like I use the regex crate so you can

00:07:47,160 --> 00:07:53,100
put reg X in some passes and there's

00:07:51,210 --> 00:07:55,970
some pretty cool error management stuff

00:07:53,100 --> 00:07:55,970
so like

00:08:08,630 --> 00:08:13,380
which one

00:08:11,610 --> 00:08:19,320
so this is something you can do in none

00:08:13,380 --> 00:08:22,680
and it's really really usable it works

00:08:19,320 --> 00:08:24,780
on all reservations no sense tax

00:08:22,680 --> 00:08:26,610
expansion no no in portrait I would have

00:08:24,780 --> 00:08:30,830
really liked to have in portrayed when I

00:08:26,610 --> 00:08:34,620
starting Nam but it was I don't know

00:08:30,830 --> 00:08:38,010
0.89 it was very variable

00:08:34,620 --> 00:08:41,070
there's no STD it can walk on par with

00:08:38,010 --> 00:08:43,650
see passers like if you want you can

00:08:41,070 --> 00:08:46,440
micro optimize your passer and it will

00:08:43,650 --> 00:08:47,730
still be safe and it can be as fast as

00:08:46,440 --> 00:08:49,560
sea basses it's really really

00:08:47,730 --> 00:08:51,570
interesting to do that it works with

00:08:49,560 --> 00:08:55,550
doing and as I say it's just function

00:08:51,570 --> 00:09:00,630
you can write your own Jersey now I'm

00:08:55,550 --> 00:09:02,070
doing non 2.0 I'm breaking a lot of

00:09:00,630 --> 00:09:05,460
stuff and I'm doing a lot of features

00:09:02,070 --> 00:09:09,030
white space passing so you just rubbed

00:09:05,460 --> 00:09:11,550
with WS mackerel and it will interspace

00:09:09,030 --> 00:09:14,220
space passes between everything so this

00:09:11,550 --> 00:09:17,340
is for JSON parser so it will try to

00:09:14,220 --> 00:09:18,930
pass space then a string then a space

00:09:17,340 --> 00:09:21,180
then a tag and a space then the value

00:09:18,930 --> 00:09:22,980
then a space and you don't have to write

00:09:21,180 --> 00:09:24,480
space everywhere because it was really

00:09:22,980 --> 00:09:27,120
really annoying to do so now it's

00:09:24,480 --> 00:09:29,460
automatic with that there's a

00:09:27,120 --> 00:09:31,140
permutation passer so you have a list of

00:09:29,460 --> 00:09:34,890
passer and you can apply them in any

00:09:31,140 --> 00:09:37,200
order as long as all of the results are

00:09:34,890 --> 00:09:39,210
there and it will return the result in

00:09:37,200 --> 00:09:40,530
the order you're specified them so it's

00:09:39,210 --> 00:09:44,820
really really cool to use for some

00:09:40,530 --> 00:09:46,680
formats like PNG and just a new syntax

00:09:44,820 --> 00:09:48,990
for those who use known before there's

00:09:46,680 --> 00:09:51,210
the change stuff which is very ugly to

00:09:48,990 --> 00:09:54,510
apply passes in sequence so I have do

00:09:51,210 --> 00:09:56,790
pass which can apply passer take the

00:09:54,510 --> 00:09:58,830
result of passer on storage in variable

00:09:56,790 --> 00:10:03,150
that's usable elsewhere and that you can

00:09:58,830 --> 00:10:06,960
even return so here we recognize the 42

00:10:03,150 --> 00:10:10,260
integer and then we take the the length

00:10:06,960 --> 00:10:13,240
which is a Nunavut and we take that many

00:10:10,260 --> 00:10:15,189
bytes and we turn those bytes it's

00:10:13,240 --> 00:10:16,990
very common pattern in binary formats to

00:10:15,189 --> 00:10:18,730
have a tag that you recognize and then

00:10:16,990 --> 00:10:22,720
the length and then how many bytes you

00:10:18,730 --> 00:10:25,480
have to take and after that a few thing

00:10:22,720 --> 00:10:28,449
we have custom input types so no more

00:10:25,480 --> 00:10:29,829
bytes slice or string limits you can do

00:10:28,449 --> 00:10:31,480
that on anything else and like you can

00:10:29,829 --> 00:10:33,850
walk with Rob's where you have a

00:10:31,480 --> 00:10:36,069
structure that has a contiguous buffer

00:10:33,850 --> 00:10:39,069
abstraction but this is really a lot of

00:10:36,069 --> 00:10:41,800
different buffers so none can work with

00:10:39,069 --> 00:10:51,850
that and we can do some pretty vector

00:10:41,800 --> 00:10:54,399
stuff with this big big performance gain

00:10:51,850 --> 00:10:55,959
for some passers because I simplified

00:10:54,399 --> 00:10:58,449
you your management if you don't need to

00:10:55,959 --> 00:11:01,749
do it all of the interesting stuff where

00:10:58,449 --> 00:11:03,519
you want to know exactly which path

00:11:01,749 --> 00:11:06,249
circuit which part of the input most

00:11:03,519 --> 00:11:08,410
people run between that so I got a

00:11:06,249 --> 00:11:11,980
really simple way to get fast opposite

00:11:08,410 --> 00:11:16,899
so let's get back to the mid of the

00:11:11,980 --> 00:11:20,410
problem VLC so do you know how a media

00:11:16,899 --> 00:11:24,490
player works basically there's a common

00:11:20,410 --> 00:11:26,709
pattern of the type you have the access

00:11:24,490 --> 00:11:29,889
you get a file you open the file or you

00:11:26,709 --> 00:11:32,369
open network feed you pass through the

00:11:29,889 --> 00:11:35,619
d-max Audrey mixers are the passes and

00:11:32,369 --> 00:11:37,569
you send you get multiple streams like

00:11:35,619 --> 00:11:40,149
an audio stream a video stream a

00:11:37,569 --> 00:11:42,009
subtitle or anything else and you send

00:11:40,149 --> 00:11:44,649
them to the colors the decoders will

00:11:42,009 --> 00:11:47,170
generate data that can be filtered like

00:11:44,649 --> 00:11:51,009
you can have post processing stuff on

00:11:47,170 --> 00:11:54,549
the video field grayscale or even

00:11:51,009 --> 00:11:56,439
scaling exactly if they can see then you

00:11:54,549 --> 00:11:59,829
send them to the output of your machine

00:11:56,439 --> 00:12:03,759
or we encode and you can max the stream

00:11:59,829 --> 00:12:07,269
back to another file on network feed and

00:12:03,759 --> 00:12:09,459
you can send send that back and most

00:12:07,269 --> 00:12:13,509
media players work like this with just a

00:12:09,459 --> 00:12:15,459
pipe of stuff the hard thing in that is

00:12:13,509 --> 00:12:17,410
synchronizing everything like you have

00:12:15,459 --> 00:12:19,569
the audio and the video on the subtitle

00:12:17,410 --> 00:12:22,299
stream and they all go at the same time

00:12:19,569 --> 00:12:25,150
but they don't record as fast like it's

00:12:22,299 --> 00:12:26,589
faster to decode audio and video

00:12:25,150 --> 00:12:28,930
and in the end you have to get

00:12:26,589 --> 00:12:31,270
everything at the same time when you

00:12:28,930 --> 00:12:33,570
present to the user sometimes we get

00:12:31,270 --> 00:12:38,170
that right sometimes we don't

00:12:33,570 --> 00:12:41,920
so the way VMC is made is you have

00:12:38,170 --> 00:12:47,980
applications like VLC the LMC which is

00:12:41,920 --> 00:12:51,310
video editing software the calling to

00:12:47,980 --> 00:12:54,940
Libby LC which is nice usable interface

00:12:51,310 --> 00:12:57,279
to build media players and DiBiase Co is

00:12:54,940 --> 00:13:00,640
the manager which does everything like

00:12:57,279 --> 00:13:03,339
load modules provide IO access

00:13:00,640 --> 00:13:06,120
synchronizing everything and all the

00:13:03,339 --> 00:13:10,150
modules link to EBL secure for common

00:13:06,120 --> 00:13:12,970
features they are all DLL like VLC

00:13:10,150 --> 00:13:15,640
reveal secure and all of the VLC modules

00:13:12,970 --> 00:13:17,050
they all dynamic libraries and the

00:13:15,640 --> 00:13:20,529
modules link to the basic of all the

00:13:17,050 --> 00:13:23,200
features and in VLC Co loads all of the

00:13:20,529 --> 00:13:25,210
library to see how they work so it

00:13:23,200 --> 00:13:28,900
seemed to make a module in Rus we have

00:13:25,210 --> 00:13:34,270
to do like a bit of dance with the way

00:13:28,900 --> 00:13:36,870
dll's are loaded a module so is the

00:13:34,270 --> 00:13:39,180
nine-minute library loaded by a VLC go

00:13:36,870 --> 00:13:41,890
they have to expose free functions

00:13:39,180 --> 00:13:44,650
because like BB scope just try to load

00:13:41,890 --> 00:13:46,900
library take that function call it it

00:13:44,650 --> 00:13:50,650
exposed some metadata on the whole on

00:13:46,900 --> 00:13:53,980
the module and then it knows what the

00:13:50,650 --> 00:13:57,279
module can do so the plan the plan to

00:13:53,980 --> 00:14:02,560
start passing stuff with rust in VLC is

00:13:57,279 --> 00:14:05,410
to make a DLL in rust that act just like

00:14:02,560 --> 00:14:07,450
a CDL you can load directly in the

00:14:05,410 --> 00:14:11,050
program that can build with cargo and

00:14:07,450 --> 00:14:11,850
that will work just like a similar in

00:14:11,050 --> 00:14:15,880
VLC

00:14:11,850 --> 00:14:18,220
so take the headers reproduce the stuff

00:14:15,880 --> 00:14:20,860
we need linked with VLC Co get the

00:14:18,220 --> 00:14:21,570
functions we need reproduce the module

00:14:20,860 --> 00:14:23,920
serve

00:14:21,570 --> 00:14:27,220
start writing the parser because that's

00:14:23,920 --> 00:14:29,610
kind of why I'm here and the world start

00:14:27,220 --> 00:14:29,610
passing stuff

00:14:30,310 --> 00:14:37,839
so VLC is written in C with the VLC

00:14:34,839 --> 00:14:40,480
comment member this kind of macro stuff

00:14:37,839 --> 00:14:43,959
in C we always come back to macros I

00:14:40,480 --> 00:14:49,360
think and this kind of object like

00:14:43,959 --> 00:14:51,610
interface in VLC where there's a command

00:14:49,360 --> 00:14:54,250
in a written stuff so very common

00:14:51,610 --> 00:15:00,700
numbers see that like I inherit some

00:14:54,250 --> 00:15:02,470
attributes from the VLC object lots of

00:15:00,700 --> 00:15:04,390
things that have can be a bit hard to

00:15:02,470 --> 00:15:06,880
represent like the Union types and

00:15:04,390 --> 00:15:08,459
misdeeds vectors and everything so the

00:15:06,880 --> 00:15:14,980
first thing you have to do is try to

00:15:08,459 --> 00:15:16,870
write that in rust so if you were at

00:15:14,980 --> 00:15:20,200
first when I was talking about that I

00:15:16,870 --> 00:15:24,700
said bind JNT just failed on the VLC

00:15:20,200 --> 00:15:27,070
headers since then I tried with several

00:15:24,700 --> 00:15:29,110
Benjen and it's able to under the VLC

00:15:27,070 --> 00:15:31,000
other so as I'll soon be able to

00:15:29,110 --> 00:15:32,800
generate the whole bindings like that

00:15:31,000 --> 00:15:35,529
we've been joined it should be a lot

00:15:32,800 --> 00:15:39,570
easier to do but in the meantime I wrote

00:15:35,529 --> 00:15:42,910
those by hand basically you knew make

00:15:39,570 --> 00:15:45,640
rust tracks that kind of act like see

00:15:42,910 --> 00:15:48,250
spots with pointers everywhere and you

00:15:45,640 --> 00:15:51,279
try to make that a bit safer so you

00:15:48,250 --> 00:15:54,040
import functions like this one to take a

00:15:51,279 --> 00:15:57,730
stream and get a better of a specific

00:15:54,040 --> 00:16:00,700
size you wrap those in functions that

00:15:57,730 --> 00:16:02,649
you can use from rust correctly you want

00:16:00,700 --> 00:16:05,980
when you try to do Fi you want to

00:16:02,649 --> 00:16:08,200
isolate all of the unsafe part because

00:16:05,980 --> 00:16:13,420
you don't want to sprinkle unsafe

00:16:08,200 --> 00:16:15,190
everywhere new card so a bit of work to

00:16:13,420 --> 00:16:17,140
get the FFI running like all of the

00:16:15,190 --> 00:16:19,570
structures I need he was like a stream T

00:16:17,140 --> 00:16:23,589
reference another stroke with reference

00:16:19,570 --> 00:16:25,990
another field like you saw in there that

00:16:23,589 --> 00:16:27,910
if I want to have the Vyasa black tea I

00:16:25,990 --> 00:16:29,800
need to know if I want to have the

00:16:27,910 --> 00:16:33,070
democracy I need to have the live VLC ot

00:16:29,800 --> 00:16:36,120
the VLC object etc so lots of

00:16:33,070 --> 00:16:36,120
preliminary work

00:16:36,440 --> 00:16:43,500
and then we can start writing our model

00:16:40,709 --> 00:16:46,980
we have to interface we can import code

00:16:43,500 --> 00:16:54,180
and this is how you declare module in

00:16:46,980 --> 00:16:56,430
VLC again it's macro to say okay this is

00:16:54,180 --> 00:16:58,290
the name of my module this is what it

00:16:56,430 --> 00:17:01,620
can do it can take an input stuff and

00:16:58,290 --> 00:17:03,240
you can pass it and here are two

00:17:01,620 --> 00:17:05,640
functions open and close that you can

00:17:03,240 --> 00:17:09,630
use to interact with that module and

00:17:05,640 --> 00:17:11,819
Libby article just takes that and loads

00:17:09,630 --> 00:17:15,350
the module afterwards knows what to do

00:17:11,819 --> 00:17:19,199
with that module so when you expand that

00:17:15,350 --> 00:17:23,670
it's got some seeker that's bit annoying

00:17:19,199 --> 00:17:25,079
to write so yeah it's basically it's

00:17:23,670 --> 00:17:28,650
just writing code let's just write that

00:17:25,079 --> 00:17:34,910
in rust it's it's easy to write it's

00:17:28,650 --> 00:17:38,880
very very easy to read right no wait

00:17:34,910 --> 00:17:40,470
macro that stuff yeah yeah I think

00:17:38,880 --> 00:17:43,830
there's a common theme there that I

00:17:40,470 --> 00:17:47,580
really like micros I can help you in

00:17:43,830 --> 00:17:50,340
that case it's really useful to do so

00:17:47,580 --> 00:17:53,970
you see I declare the function VLC entry

00:17:50,340 --> 00:18:01,020
like the way it's done in C you have the

00:17:53,970 --> 00:18:04,020
VLC entry function there okay so this is

00:18:01,020 --> 00:18:08,400
how the Lib you see the VLC module will

00:18:04,020 --> 00:18:12,120
be loaded and from there okay you can

00:18:08,400 --> 00:18:14,910
start passing stuff flash video it's a

00:18:12,120 --> 00:18:16,950
format that's very simple like he took

00:18:14,910 --> 00:18:21,059
me like less than two hours to write

00:18:16,950 --> 00:18:24,679
most of the format got audio video a few

00:18:21,059 --> 00:18:26,820
codecs that are mostly outdated and

00:18:24,679 --> 00:18:31,230
here's the beginning of the format like

00:18:26,820 --> 00:18:34,080
you have F and V Charles at the

00:18:31,230 --> 00:18:35,669
beginning then a version number then

00:18:34,080 --> 00:18:39,000
some flags to indicate if you have audio

00:18:35,669 --> 00:18:42,690
video and enough set that indicates when

00:18:39,000 --> 00:18:45,030
the video and audio streams start in the

00:18:42,690 --> 00:18:47,789
file it's interesting because like you

00:18:45,030 --> 00:18:49,950
can have the headers and a queue

00:18:47,789 --> 00:18:52,109
set points to verify in the file and you

00:18:49,950 --> 00:18:54,239
can like hide some stuff between the

00:18:52,109 --> 00:18:58,249
header on the data and there has been

00:18:54,239 --> 00:18:58,249
some very funny stuff doesn't like that

00:18:58,369 --> 00:19:06,600
so yeah I said earlier okay

00:19:03,629 --> 00:19:09,210
there was change in number one now we

00:19:06,600 --> 00:19:15,210
have do pass which is a bit easier to

00:19:09,210 --> 00:19:18,059
use so we will see when gets a file it

00:19:15,210 --> 00:19:20,489
will try to call your open method in

00:19:18,059 --> 00:19:24,720
your dem excel and say okay I have some

00:19:20,489 --> 00:19:26,609
data tell me if you can pass that so the

00:19:24,720 --> 00:19:29,340
first thing is you do a stream pick you

00:19:26,609 --> 00:19:31,739
get okay I need 9 bytes from the

00:19:29,340 --> 00:19:33,869
beginning of the data and I will tell

00:19:31,739 --> 00:19:36,409
you if it's something I can pass and

00:19:33,869 --> 00:19:39,799
then I can I could I call on that slice

00:19:36,409 --> 00:19:44,009
the header function that we just

00:19:39,799 --> 00:19:47,039
designed here and if it passed correctly

00:19:44,009 --> 00:19:49,859
it returns a header and we can say to

00:19:47,039 --> 00:19:52,229
the file okay now I know and I can be I

00:19:49,859 --> 00:19:55,249
can pass that stuff and we do a stream

00:19:52,229 --> 00:19:57,720
seek to go to the offset we don't so

00:19:55,249 --> 00:20:00,479
it's very easy to interact with us like

00:19:57,720 --> 00:20:03,389
that and so since we know we can be the

00:20:00,479 --> 00:20:07,109
D mixer for that we pass the d-max

00:20:03,389 --> 00:20:08,849
and control functions to VLC to say okay

00:20:07,109 --> 00:20:10,919
these those are the callbacks you need

00:20:08,849 --> 00:20:14,359
to use so call me again and again and

00:20:10,919 --> 00:20:18,090
again until I've passed all of the data

00:20:14,359 --> 00:20:20,700
so when you reach that offset most of

00:20:18,090 --> 00:20:23,249
the video formats they have multiple

00:20:20,700 --> 00:20:25,499
streams in multiple blocks like one

00:20:23,249 --> 00:20:27,179
block of audio one block of video and

00:20:25,499 --> 00:20:28,859
block of subtitles data that will be

00:20:27,179 --> 00:20:32,249
interspersed depending on how the

00:20:28,859 --> 00:20:36,269
encoder did the stuff like there's

00:20:32,249 --> 00:20:38,009
something for mp4 files where if you

00:20:36,269 --> 00:20:40,559
took a look at the the way people were

00:20:38,009 --> 00:20:43,080
writing them at the beginning they put

00:20:40,559 --> 00:20:45,359
just at the end of the file the header

00:20:43,080 --> 00:20:47,399
you need to see so you have to go to the

00:20:45,359 --> 00:20:50,099
end of the stream to do anything and now

00:20:47,399 --> 00:20:51,809
they saw that you can mess with the spec

00:20:50,099 --> 00:20:53,369
and put that header just at the

00:20:51,809 --> 00:20:58,409
beginning of the file and it will not

00:20:53,369 --> 00:21:00,179
work on anybody and so lots of various

00:20:58,409 --> 00:21:01,290
stuff in video format like everybody has

00:21:00,179 --> 00:21:03,960
good ideas about

00:21:01,290 --> 00:21:08,550
how video format should be and they're

00:21:03,960 --> 00:21:10,050
all wrong basically like yeah I can't

00:21:08,550 --> 00:21:12,120
criticize anything but like if I design

00:21:10,050 --> 00:21:19,370
my own I do some something shitty as

00:21:12,120 --> 00:21:19,370
well so yeah something interesting there

00:21:21,920 --> 00:21:28,200
and I put it in the box and I'll be

00:21:25,020 --> 00:21:31,320
given back that structure when when I'm

00:21:28,200 --> 00:21:34,340
called afterwards because I cannot want

00:21:31,320 --> 00:21:37,260
to store some data for my D mixer and

00:21:34,340 --> 00:21:42,630
this is the way I can interact with VDC

00:21:37,260 --> 00:21:45,540
so when I get to the first block ID code

00:21:42,630 --> 00:21:48,180
a tag let's say okay so do is video or

00:21:45,540 --> 00:21:49,770
script and I have the size of the data

00:21:48,180 --> 00:21:52,050
and a few things like a timestamp

00:21:49,770 --> 00:21:54,690
indicates when I need to present that

00:21:52,050 --> 00:21:57,000
part of the data so if it's to do it's

00:21:54,690 --> 00:21:59,610
that second one and it's if it's audio

00:21:57,000 --> 00:22:02,930
it's a bit at second one I know I have

00:21:59,610 --> 00:22:07,710
to present both them at the same time

00:22:02,930 --> 00:22:10,980
okay so I declare my D max function

00:22:07,710 --> 00:22:13,980
which is kind of the way you would do it

00:22:10,980 --> 00:22:17,370
in C I'll read my header so it's 15

00:22:13,980 --> 00:22:19,020
bucks if I have 4 bytes I know it's at

00:22:17,370 --> 00:22:23,250
the end of the stream because I have

00:22:19,020 --> 00:22:29,220
just a beginning saying the the tag type

00:22:23,250 --> 00:22:33,720
and the size and then I will try to pass

00:22:29,220 --> 00:22:37,650
everything so this is how audio had a

00:22:33,720 --> 00:22:39,570
box like so you would have the in the

00:22:37,650 --> 00:22:41,400
tag you have first the type then the

00:22:39,570 --> 00:22:44,670
data size and everything and then you

00:22:41,400 --> 00:22:47,460
have the the format specific data for

00:22:44,670 --> 00:22:49,260
the audio it is one byte and says the

00:22:47,460 --> 00:22:55,190
kind of codec you are of the size and

00:22:49,260 --> 00:22:55,190
everything so bitstream passing in Nam

00:22:58,790 --> 00:23:04,910
Constanza to buy slice under an index

00:23:01,160 --> 00:23:12,710
and you go through that thing so then

00:23:04,910 --> 00:23:19,100
you take you take Bobby's audio codec is

00:23:12,710 --> 00:23:21,950
it it is and then you use that so you do

00:23:19,100 --> 00:23:25,010
you take one bite with stream read and

00:23:21,950 --> 00:23:29,120
then you pass and then you have enough

00:23:25,010 --> 00:23:33,290
data to know okay of this this block of

00:23:29,120 --> 00:23:37,760
data size minus one that contains audio

00:23:33,290 --> 00:23:41,060
data that I can put push to VLC so the

00:23:37,760 --> 00:23:45,950
interesting thing in there is rest never

00:23:41,060 --> 00:23:48,410
owns the data like I can ask VLC for

00:23:45,950 --> 00:23:51,320
some data but I don't manage its

00:23:48,410 --> 00:23:53,360
lifetime I'm not the one allocating and

00:23:51,320 --> 00:23:56,300
not the one DL okay team I'm just

00:23:53,360 --> 00:23:58,700
borrowing data from C and trying to not

00:23:56,300 --> 00:24:00,230
break stuff it's very important because

00:23:58,700 --> 00:24:03,110
like most of the time when you interact

00:24:00,230 --> 00:24:06,890
with C code the C code thinks it knows

00:24:03,110 --> 00:24:10,910
better I don't agree with that but we

00:24:06,890 --> 00:24:15,110
have to play nice so don't worry about

00:24:10,910 --> 00:24:17,930
the unsafe stuff it's because there are

00:24:15,110 --> 00:24:22,160
some functions that take V a list VAR

00:24:17,930 --> 00:24:26,060
args stuff and we had to miss a bit with

00:24:22,160 --> 00:24:29,110
how function very clear in inverse so

00:24:26,060 --> 00:24:33,500
this is very simple because like in that

00:24:29,110 --> 00:24:36,500
posture I only read the letters I take

00:24:33,500 --> 00:24:36,740
the file header or a jump to the next

00:24:36,500 --> 00:24:40,040
block

00:24:36,740 --> 00:24:43,130
I get the block header which is like 10

00:24:40,040 --> 00:24:45,200
bytes if it's audio and then I say okay

00:24:43,130 --> 00:24:47,840
there's this much later you can use and

00:24:45,200 --> 00:24:51,710
I'll be cold again with the next block

00:24:47,840 --> 00:24:54,560
so I never read much data we've known in

00:24:51,710 --> 00:24:58,280
this so it's it's quite quite fast so

00:24:54,560 --> 00:25:01,050
don't take no for it I will show that it

00:24:58,280 --> 00:25:09,840
works okay

00:25:01,050 --> 00:25:17,790
so I really like that shift okay maybe

00:25:09,840 --> 00:25:20,640
I'll be able to that uh yeah the thing

00:25:17,790 --> 00:25:28,410
is the more you see that chief the more

00:25:20,640 --> 00:25:30,510
it's funny okay okay stop really so yeah

00:25:28,410 --> 00:25:34,520
I will just build and launch and run and

00:25:30,510 --> 00:25:40,950
copy that in the in a VNC installation I

00:25:34,520 --> 00:25:45,810
get it's very hold advertisement for

00:25:40,950 --> 00:25:49,070
Zenda in different V and you see that

00:25:45,810 --> 00:25:55,790
it's decoded with the rest plug in there

00:25:49,070 --> 00:26:03,110
yeah the graphics are pretty outdated so

00:25:55,790 --> 00:26:03,110
yeah this is Russ this is Russ in VLC

00:26:05,920 --> 00:26:14,620
like so it's shrinking because like I've

00:26:10,150 --> 00:26:18,850
been spinning okay stop watching the

00:26:14,620 --> 00:26:21,520
drift but spend so much time trying to

00:26:18,850 --> 00:26:24,160
pass stuff I'm trying to work to talk to

00:26:21,520 --> 00:26:26,200
see and everything and then it works in

00:26:24,160 --> 00:26:28,000
viously the first time you get the video

00:26:26,200 --> 00:26:31,450
to launch it's such a good feeling

00:26:28,000 --> 00:26:33,370
really but yeah now I have to integrate

00:26:31,450 --> 00:26:35,530
that really in VLC because it was just

00:26:33,370 --> 00:26:37,660
an applicant that I built separately

00:26:35,530 --> 00:26:42,580
that cough I'd just in a village

00:26:37,660 --> 00:26:43,900
installation so now the bid system can

00:26:42,580 --> 00:26:46,180
we build something with other tools

00:26:43,900 --> 00:26:48,670
because cargo thinks it knows better how

00:26:46,180 --> 00:26:50,980
to build everything and I think it's

00:26:48,670 --> 00:26:55,900
right but the other tools know better

00:26:50,980 --> 00:26:59,530
and you have to play nice again so how

00:26:55,900 --> 00:27:01,450
does it look first you have to check if

00:26:59,530 --> 00:27:03,700
you add there's a cargo and recei so

00:27:01,450 --> 00:27:05,680
this is auto calm stuff it's pretty nice

00:27:03,700 --> 00:27:07,870
I did not like that I'll really bad bad

00:27:05,680 --> 00:27:11,650
with the auto tools but it's alright

00:27:07,870 --> 00:27:16,090
and then the idea is that you don't

00:27:11,650 --> 00:27:18,220
build the dinamica by yourself you build

00:27:16,090 --> 00:27:20,590
an object file the rust plug-in dot oh

00:27:18,220 --> 00:27:22,630
because there's also leak tool which

00:27:20,590 --> 00:27:25,480
knows better than you how to build a

00:27:22,630 --> 00:27:28,180
dynamic library like taco nozzle to be

00:27:25,480 --> 00:27:31,090
library for Windows Mac Linux and don't

00:27:28,180 --> 00:27:33,160
care it works but play nice with the

00:27:31,090 --> 00:27:34,990
build system play nice with C play nice

00:27:33,160 --> 00:27:38,380
with the interface play nice with the Fi

00:27:34,990 --> 00:27:40,810
and it's snowing but like rust makes it

00:27:38,380 --> 00:27:44,980
kind of easy to do so I'm really happy

00:27:40,810 --> 00:27:47,650
with that and this so yeah the build

00:27:44,980 --> 00:27:50,080
system is the biggest issue the unsafe

00:27:47,650 --> 00:27:52,090
API is you can walk around them and then

00:27:50,080 --> 00:27:54,910
get really nice code to use when you do

00:27:52,090 --> 00:27:57,580
f5 the parser is the years pass and

00:27:54,910 --> 00:28:00,160
write is does not really need to be fast

00:27:57,580 --> 00:28:01,960
because like video decoding is so much

00:28:00,160 --> 00:28:04,720
slower than passing that you really

00:28:01,960 --> 00:28:07,540
don't care about that and remember that

00:28:04,720 --> 00:28:10,690
you you have to be a nice citizen you

00:28:07,540 --> 00:28:12,520
you not a new around you're using

00:28:10,690 --> 00:28:15,910
someone else's data so you have to be

00:28:12,520 --> 00:28:18,250
nice with the way the C handles it so

00:28:15,910 --> 00:28:18,530
from now your figs I have to do I have

00:28:18,250 --> 00:28:20,990
to

00:28:18,530 --> 00:28:23,090
so he ought to seek in a fight like move

00:28:20,990 --> 00:28:26,240
back and forth on every frame I have to

00:28:23,090 --> 00:28:28,400
put it back in the VSC repository I can

00:28:26,240 --> 00:28:29,600
build it now inside VLC so it's quite

00:28:28,400 --> 00:28:31,490
cool

00:28:29,600 --> 00:28:32,420
Pradhan Dignam dependency will be

00:28:31,490 --> 00:28:35,420
something that's very interesting

00:28:32,420 --> 00:28:37,580
because we've you'll see we have this

00:28:35,420 --> 00:28:39,470
bigger time with all of the libraries we

00:28:37,580 --> 00:28:43,040
need and so for rust I'd like to have

00:28:39,470 --> 00:28:45,110
that as well and then to complete the

00:28:43,040 --> 00:28:46,700
imports I have to play it again a bit

00:28:45,110 --> 00:28:49,550
with my engine and we'll be able to

00:28:46,700 --> 00:28:52,460
replace some plugins some of you see

00:28:49,550 --> 00:28:55,910
plugins if we've rust and like you can

00:28:52,460 --> 00:28:58,430
do that with NEC project it's easy to

00:28:55,910 --> 00:29:02,380
replace a c project file by file but

00:28:58,430 --> 00:29:05,600
easy for different reasons different

00:29:02,380 --> 00:29:10,580
definitions of easy but it's doable it's

00:29:05,600 --> 00:29:13,310
really doable so few people that helped

00:29:10,580 --> 00:29:15,620
me Jim kamas maybe you talked to him

00:29:13,310 --> 00:29:17,270
about documentation we can battle who

00:29:15,620 --> 00:29:19,520
walks at Lee baby

00:29:17,270 --> 00:29:23,360
q under Lee baby project and there will

00:29:19,520 --> 00:29:25,100
help me making this so thank you

00:29:23,360 --> 00:29:32,870
there's everything you need if you want

00:29:25,100 --> 00:29:35,900
to make your own module play with rust

00:29:32,870 --> 00:29:38,860
play with C de Poissy in production it's

00:29:35,900 --> 00:29:42,460
called these people rust in production

00:29:38,860 --> 00:29:45,440
do not deploy C in production please

00:29:42,460 --> 00:29:48,070
because then I have to break it okay

00:29:45,440 --> 00:29:48,070

YouTube URL: https://www.youtube.com/watch?v=egu_0reiq7s


