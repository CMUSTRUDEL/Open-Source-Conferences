Title: Building Little Languages with Rust â€” Arcady Goldmints Orlov
Publication date: 2017-10-25
Playlist: Rust Belt Rust 2016
Description: 
	Materials for this talk are available at http://teapotahedron.com/littlelangs.pdf

Languages are an underrated tool for solving engineering problems, in part because creating them has been difficult. Rust's unique combination of features make it an excellent language for writing compilers ranging from the Rust compiler itself to small domain specific languages. This talk will describe the implementation of a compiler for a query language for protocol buffers and how much easier it is to write one in Rust compared to C.

http://www.rust-belt-rust.com
Captions: 
	00:00:05,490 --> 00:00:11,789
hi I'm here to talk about building

00:00:08,639 --> 00:00:13,260
little languages so first obvious

00:00:11,789 --> 00:00:17,460
question is what is a little language

00:00:13,260 --> 00:00:20,310
well it's not a big language like rust

00:00:17,460 --> 00:00:23,029
it's usually something small and simple

00:00:20,310 --> 00:00:25,199
for some specific problem where it is

00:00:23,029 --> 00:00:27,119
designed just to solve that problem

00:00:25,199 --> 00:00:30,810
really well hopefully not

00:00:27,119 --> 00:00:34,440
turing-complete you know often used in

00:00:30,810 --> 00:00:37,170
other languages often interpreted or

00:00:34,440 --> 00:00:39,600
somehow otherwise not compiled to

00:00:37,170 --> 00:00:40,260
machine code you know your configuration

00:00:39,600 --> 00:00:42,210
files

00:00:40,260 --> 00:00:46,019
hopefully not turing-complete hopefully

00:00:42,210 --> 00:00:50,430
not like sent mail CSS as another

00:00:46,019 --> 00:00:53,070
example you know relatively simple often

00:00:50,430 --> 00:00:56,100
in combination with other languages your

00:00:53,070 --> 00:01:00,600
query languages often little languages

00:00:56,100 --> 00:01:03,540
though SQL gets pretty big templating

00:01:00,600 --> 00:01:06,780
languages and you know there's kind of a

00:01:03,540 --> 00:01:09,119
spectrum between big and little so my

00:01:06,780 --> 00:01:13,500
particular little language that I built

00:01:09,119 --> 00:01:18,030
was motivated by the specific example of

00:01:13,500 --> 00:01:20,039
transit data so in addition to being a

00:01:18,030 --> 00:01:22,530
rust enthusiast time at transit

00:01:20,039 --> 00:01:23,850
enthusiasts and I like to know all sorts

00:01:22,530 --> 00:01:28,850
of obscure facts about the transit

00:01:23,850 --> 00:01:31,229
system in my hometown of Boston and

00:01:28,850 --> 00:01:35,130
fortunately the transit agency in Boston

00:01:31,229 --> 00:01:37,439
publishes all sorts of data in open

00:01:35,130 --> 00:01:39,659
formats including real-time locations

00:01:37,439 --> 00:01:41,670
for all the buses and trains so you can

00:01:39,659 --> 00:01:43,499
see where everything is and they

00:01:41,670 --> 00:01:46,350
published this in protocol buffer format

00:01:43,499 --> 00:01:49,829
you just download it from a URL it gets

00:01:46,350 --> 00:01:51,780
updated every 30 seconds and of course I

00:01:49,829 --> 00:01:53,789
have a script set up on my little rented

00:01:51,780 --> 00:01:55,619
server out on the Internet's to go and

00:01:53,789 --> 00:01:57,749
download this data every 30 seconds and

00:01:55,619 --> 00:01:59,670
keep a giant archive so I can go back

00:01:57,749 --> 00:02:02,579
and see how things were working during

00:01:59,670 --> 00:02:05,219
the terrible snowstorm well in theory I

00:02:02,579 --> 00:02:08,940
still have to actually have some tools

00:02:05,219 --> 00:02:10,440
for dealing with this data and part of

00:02:08,940 --> 00:02:11,850
the problem is that it's a lot of data

00:02:10,440 --> 00:02:14,130
you can't just you know you can just

00:02:11,850 --> 00:02:16,020
stick it in a database but it's like 200

00:02:14,130 --> 00:02:17,230
megabytes a day a year's worth starts to

00:02:16,020 --> 00:02:20,230
add up for my

00:02:17,230 --> 00:02:21,849
cheap rented server on the Internet so I

00:02:20,230 --> 00:02:24,400
just store it the cheap way which is

00:02:21,849 --> 00:02:27,430
concatenated and exept compress is

00:02:24,400 --> 00:02:29,410
really well but there's not really a

00:02:27,430 --> 00:02:31,180
good way to search through it so I

00:02:29,410 --> 00:02:36,910
figure I'll just build my own little

00:02:31,180 --> 00:02:38,950
search tool and the way to do that is

00:02:36,910 --> 00:02:41,739
the build a little query language that

00:02:38,950 --> 00:02:47,650
lets me find out for example where is

00:02:41,739 --> 00:02:49,450
boss five thousand one and protocol

00:02:47,650 --> 00:02:53,049
buffers in case you don't know they're

00:02:49,450 --> 00:02:55,209
like a binary format they're the data

00:02:53,049 --> 00:02:58,959
model was kind of like your JSON or

00:02:55,209 --> 00:03:04,750
whatever it has structures it has arrays

00:02:58,959 --> 00:03:06,370
it has fields and messages and so

00:03:04,750 --> 00:03:08,440
there's other similar formats with other

00:03:06,370 --> 00:03:12,730
similar query language XPath was kind of

00:03:08,440 --> 00:03:15,069
an inspiration in some way and there's

00:03:12,730 --> 00:03:21,850
just you know a basic example of what it

00:03:15,069 --> 00:03:24,810
looks like and so getting a little bit

00:03:21,850 --> 00:03:27,850
more into what is behind the language

00:03:24,810 --> 00:03:29,410
there's sort of different parts that you

00:03:27,850 --> 00:03:32,139
have to go through my language has a

00:03:29,410 --> 00:03:34,810
parser every language has to have a

00:03:32,139 --> 00:03:38,290
parse or more or less which reads these

00:03:34,810 --> 00:03:41,340
expressions and then produces a parse

00:03:38,290 --> 00:03:43,780
tree and then because protocol buffers

00:03:41,340 --> 00:03:45,400
actually have a pretty well-defined

00:03:43,780 --> 00:03:47,170
schema and it tells you what type all

00:03:45,400 --> 00:03:49,750
the parts of the message are supposed to

00:03:47,170 --> 00:03:53,400
be and so on there's actually a type

00:03:49,750 --> 00:03:55,930
checker very very simple type checker

00:03:53,400 --> 00:03:58,450
but it's there nonetheless and then the

00:03:55,930 --> 00:03:59,980
actual evaluator that actually takes

00:03:58,450 --> 00:04:01,630
that expression and runs it against my

00:03:59,980 --> 00:04:04,480
giant archive of a year's worth of bus

00:04:01,630 --> 00:04:06,700
data and spits out the little subset

00:04:04,480 --> 00:04:08,019
that talks about just that one bus that

00:04:06,700 --> 00:04:11,079
I'm interested in because it's the shiny

00:04:08,019 --> 00:04:12,579
new hydrogen fuel cell bus that we've

00:04:11,079 --> 00:04:15,239
been waiting for for a year and we want

00:04:12,579 --> 00:04:15,239
to know where it is

00:04:17,350 --> 00:04:23,920
so parser you heard in the previous talk

00:04:22,180 --> 00:04:26,790
about how there are these awesome tools

00:04:23,920 --> 00:04:31,080
for building parsers I just built my own

00:04:26,790 --> 00:04:35,350
it ended up not being that complicated

00:04:31,080 --> 00:04:37,450
you know you just take it just reads

00:04:35,350 --> 00:04:40,990
through the string and either

00:04:37,450 --> 00:04:43,570
successfully matches it and returns some

00:04:40,990 --> 00:04:47,790
successful result and the remainder of

00:04:43,570 --> 00:04:50,140
the string that it didn't parse or it

00:04:47,790 --> 00:04:52,870
you know fails the parse it returns an

00:04:50,140 --> 00:04:57,340
error and then maybe you'll get a parse

00:04:52,870 --> 00:04:59,890
error and the parser reads this

00:04:57,340 --> 00:05:02,200
expression you know the string that in

00:04:59,890 --> 00:05:05,950
the earlier slide returns a parse tree

00:05:02,200 --> 00:05:09,310
and that gets fed into the next section

00:05:05,950 --> 00:05:13,030
which is the type checker so the parse

00:05:09,310 --> 00:05:17,710
tree is literally just like a struct

00:05:13,030 --> 00:05:19,870
tree of strings and more or less and now

00:05:17,710 --> 00:05:22,450
we have to make sure that all the actual

00:05:19,870 --> 00:05:24,220
words in there like the you know entity

00:05:22,450 --> 00:05:25,840
dot vehicle that you saw earlier that

00:05:24,220 --> 00:05:31,300
there are actual messages that are

00:05:25,840 --> 00:05:35,110
defined for this and so these

00:05:31,300 --> 00:05:37,930
definitions are in this description file

00:05:35,110 --> 00:05:39,250
that Google ships and fortunately Google

00:05:37,930 --> 00:05:41,680
ships a whole bunch of tools to deal

00:05:39,250 --> 00:05:44,860
with protocol buffers unfortunately none

00:05:41,680 --> 00:05:47,710
of them are really designed with rust in

00:05:44,860 --> 00:05:49,990
mind fortunately there are tools that

00:05:47,710 --> 00:05:52,210
are designed with C in mind and also

00:05:49,990 --> 00:05:54,270
fortunately rust is pretty good at

00:05:52,210 --> 00:05:58,080
talking to sea

00:05:54,270 --> 00:06:02,830
so actually what I ended up doing is

00:05:58,080 --> 00:06:04,960
using the C tools they produce a C file

00:06:02,830 --> 00:06:07,360
from this description of what this

00:06:04,960 --> 00:06:10,960
transit data format is supposed to be

00:06:07,360 --> 00:06:14,350
like that I compile that into an Esso

00:06:10,960 --> 00:06:17,560
shared library and then just load that

00:06:14,350 --> 00:06:21,070
from rust and have a little FFI wrapper

00:06:17,560 --> 00:06:23,210
around it that lets me use this C code

00:06:21,070 --> 00:06:26,750
generated by this Google tool directly

00:06:23,210 --> 00:06:28,520
from rust and that lets me get at you

00:06:26,750 --> 00:06:31,370
know what you know what are the valid

00:06:28,520 --> 00:06:35,470
field names what are the data types for

00:06:31,370 --> 00:06:37,960
those things are the expressions that

00:06:35,470 --> 00:06:41,539
that were entered in that you know

00:06:37,960 --> 00:06:44,960
original thing that were parsing or they

00:06:41,539 --> 00:06:48,500
like valid and so the type checker does

00:06:44,960 --> 00:06:53,240
that and then returns a sort of more

00:06:48,500 --> 00:06:56,240
refined version of the tree to the next

00:06:53,240 --> 00:07:03,410
stage which actually executes sort of

00:06:56,240 --> 00:07:07,750
execute that and this also has some

00:07:03,410 --> 00:07:12,380
other also takes advantage of some other

00:07:07,750 --> 00:07:15,889
things that rust is pretty good at which

00:07:12,380 --> 00:07:20,659
is the iterators which are a wonderful

00:07:15,889 --> 00:07:25,069
wonderful feature and make it you know

00:07:20,659 --> 00:07:27,289
make it very easy to sort of build build

00:07:25,069 --> 00:07:29,060
things on top of and the way this

00:07:27,289 --> 00:07:32,240
evaluator works is it basically I built

00:07:29,060 --> 00:07:36,860
a little iterator type that will take

00:07:32,240 --> 00:07:38,930
some generic input actually something

00:07:36,860 --> 00:07:42,650
that implements a specific type of trade

00:07:38,930 --> 00:07:45,710
and then basically return successive

00:07:42,650 --> 00:07:49,789
protocol buff messengers messages out of

00:07:45,710 --> 00:07:51,979
that and then you just run you know run

00:07:49,789 --> 00:07:56,180
the sort of expression and see if it

00:07:51,979 --> 00:07:58,190
matches and the code for that turns out

00:07:56,180 --> 00:08:00,310
to be surprisingly compact because of

00:07:58,190 --> 00:08:03,800
the powerful abstractions that rust has

00:08:00,310 --> 00:08:08,780
so this is the actual code for the

00:08:03,800 --> 00:08:11,659
actual evaluator constructs this it

00:08:08,780 --> 00:08:16,300
iterator and then it just filters and C

00:08:11,659 --> 00:08:22,370
C's does this you know does this message

00:08:16,300 --> 00:08:25,909
match the tag does it match the filter

00:08:22,370 --> 00:08:27,650
expression and then if it is well call

00:08:25,909 --> 00:08:31,659
the callback and if

00:08:27,650 --> 00:08:34,940
and if it doesn't and we still have more

00:08:31,659 --> 00:08:38,599
sort of messages more expressions to

00:08:34,940 --> 00:08:42,890
check then you know recur and go deeper

00:08:38,599 --> 00:08:48,980
and check if it continues to match and

00:08:42,890 --> 00:08:50,600
this is actually so the actual some of

00:08:48,980 --> 00:08:53,080
the backstory of this is that I actually

00:08:50,600 --> 00:08:55,339
originally started writing this in C and

00:08:53,080 --> 00:08:57,470
I desperately wanted to write it and

00:08:55,339 --> 00:09:00,950
rust but unfortunately Russ didn't run

00:08:57,470 --> 00:09:02,510
or the standard compiler didn't have a

00:09:00,950 --> 00:09:06,950
version from my computer which is this

00:09:02,510 --> 00:09:08,420
lovely little arm thing and I started

00:09:06,950 --> 00:09:11,390
writing it and see they actually

00:09:08,420 --> 00:09:12,860
released the arm build an official arm

00:09:11,390 --> 00:09:17,089
build of the compiler like two days

00:09:12,860 --> 00:09:18,560
after I did that and then I kept going

00:09:17,089 --> 00:09:20,390
with C regardless I got very very

00:09:18,560 --> 00:09:26,750
frustrated the code got very big and

00:09:20,390 --> 00:09:28,040
confusing and then eventually I got so

00:09:26,750 --> 00:09:30,980
frustrated that I rewrote the whole

00:09:28,040 --> 00:09:38,270
thing in rust and it ended up being much

00:09:30,980 --> 00:09:43,010
much more compact so I guess the things

00:09:38,270 --> 00:09:45,620
that I learned from all of that rust is

00:09:43,010 --> 00:09:48,320
great for writing compilers not really

00:09:45,620 --> 00:09:50,839
surprising I mean the first really big

00:09:48,320 --> 00:09:54,230
program written in rust was the Rost

00:09:50,839 --> 00:09:56,240
compiler so that was sort of the guiding

00:09:54,230 --> 00:09:58,910
force behind a lot of the way the

00:09:56,240 --> 00:10:00,110
language was designed and so it was

00:09:58,910 --> 00:10:05,000
designed pretty well for writing

00:10:00,110 --> 00:10:07,880
compilers you know things like the data

00:10:05,000 --> 00:10:10,670
types the way the enums work the way you

00:10:07,880 --> 00:10:15,650
have match statements that basically

00:10:10,670 --> 00:10:18,260
what you need to write a compiler rusts

00:10:15,650 --> 00:10:21,430
FFI makes it really easy to reuse C code

00:10:18,260 --> 00:10:26,660
it would have been a lot harder to

00:10:21,430 --> 00:10:28,730
actually get all of these

00:10:26,660 --> 00:10:30,170
descriptions of like what the messages

00:10:28,730 --> 00:10:32,839
are supposed to be like and actually

00:10:30,170 --> 00:10:36,079
basically write my own compiler for that

00:10:32,839 --> 00:10:38,420
format as well and get all the data out

00:10:36,079 --> 00:10:40,940
of the sort of published standard or

00:10:38,420 --> 00:10:43,420
have to basically code it up by hand and

00:10:40,940 --> 00:10:48,850
that would only work for transit data

00:10:43,420 --> 00:10:52,240
but thanks to relatively easy FFI I

00:10:48,850 --> 00:10:56,240
could just reuse all of that stuff and

00:10:52,240 --> 00:10:58,610
wrap it in Nice safe interfaces and rust

00:10:56,240 --> 00:11:06,019
is great for building composable

00:10:58,610 --> 00:11:11,000
abstractions so the iterators were sort

00:11:06,019 --> 00:11:15,769
of very very efficient and made it very

00:11:11,000 --> 00:11:20,540
easy to write this sort of going back

00:11:15,769 --> 00:11:23,240
going back to the code filter the filter

00:11:20,540 --> 00:11:27,050
you know is a trait and you just write

00:11:23,240 --> 00:11:29,750
some rated implementation for it and you

00:11:27,050 --> 00:11:31,910
have some you know that's eval function

00:11:29,750 --> 00:11:33,709
that you can implement for different

00:11:31,910 --> 00:11:36,259
types of trait of different types of

00:11:33,709 --> 00:11:37,699
filters makes it very easy to write this

00:11:36,259 --> 00:11:39,319
particular code and then you don't have

00:11:37,699 --> 00:11:44,540
a giant like switch statement like you

00:11:39,319 --> 00:11:49,819
would if you were doing C so that makes

00:11:44,540 --> 00:11:52,569
it more compact and yeah rust is

00:11:49,819 --> 00:11:52,569
generally great

00:11:54,440 --> 00:12:00,630
and I guess the conclusion is little

00:11:58,920 --> 00:12:03,450
languages are really not that hard you

00:12:00,630 --> 00:12:07,890
shouldn't be afraid if you see a problem

00:12:03,450 --> 00:12:12,420
where it's applicable to go and write

00:12:07,890 --> 00:12:15,060
your own and you know I would encourage

00:12:12,420 --> 00:12:18,630
you to do so I feel like there's been

00:12:15,060 --> 00:12:21,750
this huge sort of Renaissance of new

00:12:18,630 --> 00:12:24,210
languages big like crossed and little

00:12:21,750 --> 00:12:27,180
like all the other things that people do

00:12:24,210 --> 00:12:31,800
so I would encourage you to go and build

00:12:27,180 --> 00:12:38,550
your own and you know you can go look at

00:12:31,800 --> 00:12:43,200
my code up on the Internet's and I guess

00:12:38,550 --> 00:12:46,160
I'm a little bit out of ideas but you

00:12:43,200 --> 00:12:46,160
guys have any questions

00:12:48,240 --> 00:13:09,130
anyone comments after you had an initial

00:13:05,860 --> 00:13:11,260
I'm assuming you wanting to be able to

00:13:09,130 --> 00:13:13,870
see things do things you had an initial

00:13:11,260 --> 00:13:15,790
foundation that you have expanded on

00:13:13,870 --> 00:13:18,820
added features to after you had the

00:13:15,790 --> 00:13:22,320
general framework in place during that

00:13:18,820 --> 00:13:25,779
expansion were there any points in which

00:13:22,320 --> 00:13:31,209
you wanted to do something that rust

00:13:25,779 --> 00:13:36,730
wasn't giving you a very good question

00:13:31,209 --> 00:13:39,070
so one of I mean there were ultimately I

00:13:36,730 --> 00:13:41,800
managed to successfully battle rust and

00:13:39,070 --> 00:13:44,860
get what I wanted but there were

00:13:41,800 --> 00:13:46,180
definitely moments of like difficulty

00:13:44,860 --> 00:13:48,010
and like battling with the borrow

00:13:46,180 --> 00:13:51,339
checker and sort of transitioning it

00:13:48,010 --> 00:13:53,350
from Oh will parse this message out of a

00:13:51,339 --> 00:13:55,000
buffer - oh let's build a streaming

00:13:53,350 --> 00:13:57,820
interface and I have all sorts of clever

00:13:55,000 --> 00:14:02,589
ideas for how to do that and then sort

00:13:57,820 --> 00:14:04,029
of fighting the system and fighting the

00:14:02,589 --> 00:14:06,899
borrowed checker when it wouldn't let me

00:14:04,029 --> 00:14:08,980
do what I want and then having to take a

00:14:06,899 --> 00:14:10,480
two-week break for various other reasons

00:14:08,980 --> 00:14:13,029
and then coming back and being like oh

00:14:10,480 --> 00:14:15,880
I'm missing a pair of curly braces that

00:14:13,029 --> 00:14:19,510
completely solves all my problems so I'm

00:14:15,880 --> 00:14:20,920
kind of looking forward to things like

00:14:19,510 --> 00:14:22,329
non lexical lifetimes that will

00:14:20,920 --> 00:14:24,390
hopefully make these things a little bit

00:14:22,329 --> 00:14:24,390
easier

00:14:30,970 --> 00:14:33,720
anyone else

00:14:35,089 --> 00:14:38,709

YouTube URL: https://www.youtube.com/watch?v=Lr_zxxdLrOk


