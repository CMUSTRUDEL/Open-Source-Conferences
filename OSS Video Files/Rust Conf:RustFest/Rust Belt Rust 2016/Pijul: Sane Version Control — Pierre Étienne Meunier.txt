Title: Pijul: Sane Version Control — Pierre Étienne Meunier
Publication date: 2017-10-25
Playlist: Rust Belt Rust 2016
Description: 
	This talk is about a new distributed version control system written in Rust, based on category theory to define conflicts properly, but nevertheless as fast as even the fastest competitors. Its main distinctive feature is to implement the naive intuition of how distributed version control system should work: a branch in a repository is just an (unordered) set of patches. This makes it really easy to use, which we believe has the potential to help beginners collaborate with others, and get non-programmers use version control for their work. Our tool can also simplifying the workflows of big projects, especially since it handles big codebases faster than others. Moreover, the solid theory means it is easy to understand and predict what it does, which makes it easy to script and reuse in other projects.

While previous systems based on this idea failed to compete in speed with the more widely-used tools out there, we invented a new data structure to efficiently handle asynchronous parallel contributions to a repository. We believe our construction of this datastructure can be reused in other contexts, especially since Rust is really well-suited to parallel computing. This talk will explain the architecture of the software, and what made Rust the best tool for writing it. We'll also talk about a few open problems, both about the theory and the implementation.

http://www.rust-belt-rust.com/
Captions: 
	00:00:04,670 --> 00:00:09,990
all right thanks Dean thanks everyone

00:00:07,439 --> 00:00:13,080
this is my first software a conference

00:00:09,990 --> 00:00:14,250
ever simple little impressed or I'm

00:00:13,080 --> 00:00:16,099
going to talk about the project I've

00:00:14,250 --> 00:00:18,840
been working on for about a year now

00:00:16,099 --> 00:00:21,599
it's called people from the name of the

00:00:18,840 --> 00:00:23,880
Spanish bird it's we're trying to do

00:00:21,599 --> 00:00:26,160
same version control and by saying like

00:00:23,880 --> 00:00:28,500
I'm going to like this talk mostly about

00:00:26,160 --> 00:00:31,559
what sane means and what vertical should

00:00:28,500 --> 00:00:34,290
be like so it all started because I was

00:00:31,559 --> 00:00:35,940
trying to surf long Baker my coop in

00:00:34,290 --> 00:00:38,250
this project myself we're trying to

00:00:35,940 --> 00:00:41,219
convince our co-authors and an academic

00:00:38,250 --> 00:00:44,789
paper to use version control instead of

00:00:41,219 --> 00:00:47,609
just emails and like like reserving

00:00:44,789 --> 00:00:52,260
files for a week and analytic file right

00:00:47,609 --> 00:00:53,789
so so but well flow happens to be one of

00:00:52,260 --> 00:00:56,460
the core darks developers which is a

00:00:53,789 --> 00:00:59,069
like rather old ish version control

00:00:56,460 --> 00:01:02,909
system and so we couldn't really

00:00:59,069 --> 00:01:04,680
convince him to use anything else so we

00:01:02,909 --> 00:01:06,510
try to convince our co-authors to start

00:01:04,680 --> 00:01:10,790
installing darks and windows and then

00:01:06,510 --> 00:01:12,960
like setting up SSH keys and pushing to

00:01:10,790 --> 00:01:15,810
pushing patches and pulling stuff and

00:01:12,960 --> 00:01:18,480
that didn't really work out so well also

00:01:15,810 --> 00:01:21,380
turns out it's darks has performance

00:01:18,480 --> 00:01:24,420
problems and get as simplicity problems

00:01:21,380 --> 00:01:25,770
so well I wasn't really easy to do

00:01:24,420 --> 00:01:27,390
anything about this and that's pretty

00:01:25,770 --> 00:01:30,030
much the situation with vertical roll

00:01:27,390 --> 00:01:31,980
today like most people most non hackers

00:01:30,030 --> 00:01:35,610
don't even use it so it's write widely

00:01:31,980 --> 00:01:37,950
regardless of hackers thing most people

00:01:35,610 --> 00:01:40,080
like use extremely basic version

00:01:37,950 --> 00:01:42,900
cultural even like top like world

00:01:40,080 --> 00:01:46,410
experts in in computer science still use

00:01:42,900 --> 00:01:49,260
like fight locking in emails and that

00:01:46,410 --> 00:01:53,340
makes us lose a significant amount of

00:01:49,260 --> 00:01:55,650
data and or time and even the situation

00:01:53,340 --> 00:01:57,380
with programmers and sorry say isn't

00:01:55,650 --> 00:01:59,400
much better because like as soon as

00:01:57,380 --> 00:02:02,670
distributed version controls for

00:01:59,400 --> 00:02:05,130
invented their like if they were so

00:02:02,670 --> 00:02:07,110
complicated and hard to use that like

00:02:05,130 --> 00:02:09,929
business is even started to resent

00:02:07,110 --> 00:02:11,519
relies them and use the use the use them

00:02:09,929 --> 00:02:16,410
in a centralized way in order to master

00:02:11,519 --> 00:02:19,520
the Beast and

00:02:16,410 --> 00:02:22,350
Pramod this functional programming as

00:02:19,520 --> 00:02:24,900
finally convincing people that they can

00:02:22,350 --> 00:02:26,580
really tackle everything like all feel

00:02:24,900 --> 00:02:29,010
the computer science that were that were

00:02:26,580 --> 00:02:32,070
previously regarded as like elite field

00:02:29,010 --> 00:02:36,150
just like Ashley showed us for operating

00:02:32,070 --> 00:02:38,430
systems we're trying to replace C++ with

00:02:36,150 --> 00:02:40,320
rust recently also JavaScript it's like

00:02:38,430 --> 00:02:43,440
it's trying trying to get replaced by

00:02:40,320 --> 00:02:44,880
Elm package managers and Linux

00:02:43,440 --> 00:02:47,520
distributions are getting replaced by

00:02:44,880 --> 00:02:50,340
like nicks it's not widely accepted so

00:02:47,520 --> 00:02:52,710
far but and so these talks about letting

00:02:50,340 --> 00:02:54,560
adenine other functional tool to that

00:02:52,710 --> 00:02:58,290
collection and it's called

00:02:54,560 --> 00:03:00,420
we start out to replace gets probably

00:02:58,290 --> 00:03:04,710
this goal is as ambitious as for us to

00:03:00,420 --> 00:03:08,010
replace it C++ or maybe more but but

00:03:04,710 --> 00:03:11,250
anyway so before starting this talk I

00:03:08,010 --> 00:03:13,500
just want you all to like get give some

00:03:11,250 --> 00:03:15,810
basic concepts about what I well I think

00:03:13,500 --> 00:03:17,490
functional programming is so most people

00:03:15,810 --> 00:03:19,280
have their own definition feel free to

00:03:17,490 --> 00:03:21,660
agree or not with this so I think

00:03:19,280 --> 00:03:23,640
functional so by what I like in

00:03:21,660 --> 00:03:25,770
functional languages like rust is that

00:03:23,640 --> 00:03:29,370
there are static types so we don't like

00:03:25,770 --> 00:03:31,380
we can reason about code easily there's

00:03:29,370 --> 00:03:34,080
fine control of immutability it's like

00:03:31,380 --> 00:03:35,940
we're not mutating some some states all

00:03:34,080 --> 00:03:39,750
the time we're just thinking about

00:03:35,940 --> 00:03:42,000
transforms and stuff in functions most

00:03:39,750 --> 00:03:43,410
operations are atomic which is what most

00:03:42,000 --> 00:03:45,780
people use when they use like any

00:03:43,410 --> 00:03:47,340
software at all and it's something

00:03:45,780 --> 00:03:50,190
that's not really happening in most most

00:03:47,340 --> 00:03:52,140
software Mo's tools and we also like

00:03:50,190 --> 00:03:54,930
memory safe seaweed we don't want like

00:03:52,140 --> 00:03:57,239
you just corrupt our back hand or

00:03:54,930 --> 00:03:58,470
correct our storage our files or

00:03:57,239 --> 00:04:00,959
something we don't want to lose data

00:03:58,470 --> 00:04:05,100
just because we're using it like using

00:04:00,959 --> 00:04:08,430
types in the wrong way so how does that

00:04:05,100 --> 00:04:11,220
apply to has there any beneficial to

00:04:08,430 --> 00:04:13,080
version control well because the way we

00:04:11,220 --> 00:04:16,130
use version call today has mostly about

00:04:13,080 --> 00:04:17,540
States we're talking about comets

00:04:16,130 --> 00:04:19,340
if we use gifts we're talking about

00:04:17,540 --> 00:04:20,980
comments and coming so state fool

00:04:19,340 --> 00:04:23,930
they're just basically a hash like a

00:04:20,980 --> 00:04:25,430
patch to like make it easier to expect

00:04:23,930 --> 00:04:27,650
but it's just in optimizations just to

00:04:25,430 --> 00:04:29,900
make it easier to store and and their

00:04:27,650 --> 00:04:31,610
hash of the whole state the repository

00:04:29,900 --> 00:04:33,980
that's where the comment is and will you

00:04:31,610 --> 00:04:36,530
commit something you just advance the

00:04:33,980 --> 00:04:39,740
head of the repository bye-bye one small

00:04:36,530 --> 00:04:41,150
notch and you has to all state of the

00:04:39,740 --> 00:04:43,490
repository that's the name of your new

00:04:41,150 --> 00:04:45,560
new comment and that's quite different

00:04:43,490 --> 00:04:46,840
from patches so patches are all about

00:04:45,560 --> 00:04:50,000
transforms they are all about like

00:04:46,840 --> 00:04:51,320
bringing like any stays like applying

00:04:50,000 --> 00:04:53,030
when you apply a patch you can basically

00:04:51,320 --> 00:04:54,620
apply a patch to a file and it's like

00:04:53,030 --> 00:04:57,170
that's what most people think um it's

00:04:54,620 --> 00:04:58,520
our with the first first discover guess

00:04:57,170 --> 00:05:01,640
but but then they realize it's not

00:04:58,520 --> 00:05:04,760
that's not the case and so this can have

00:05:01,640 --> 00:05:06,740
major benefits like for instance in like

00:05:04,760 --> 00:05:09,410
any system that uses three-way merge

00:05:06,740 --> 00:05:13,280
such as like git mercurial lesbian CVS

00:05:09,410 --> 00:05:15,470
and like most others they don't have

00:05:13,280 --> 00:05:17,600
that really cool property that we call

00:05:15,470 --> 00:05:20,270
the sensitivity in algebra and that

00:05:17,600 --> 00:05:22,400
property is the following so if you have

00:05:20,270 --> 00:05:24,020
two of two people at least in Bob and

00:05:22,400 --> 00:05:25,570
you're not really good communication

00:05:24,020 --> 00:05:29,240
right you're a couple

00:05:25,570 --> 00:05:31,220
well at least bride's like the red patch

00:05:29,240 --> 00:05:32,810
here and Bob in thrall that writes that

00:05:31,220 --> 00:05:35,870
like first a blue patch and then a great

00:05:32,810 --> 00:05:37,850
green patch well depending on the order

00:05:35,870 --> 00:05:39,290
in which you merge things depending on

00:05:37,850 --> 00:05:40,940
what like your merge strategy you might

00:05:39,290 --> 00:05:43,850
get different results in three-way merge

00:05:40,940 --> 00:05:47,600
like if the patch are exactly the same I

00:05:43,850 --> 00:05:49,280
like first I try to merge the blue patch

00:05:47,600 --> 00:05:51,710
first and then the green patch

00:05:49,280 --> 00:05:54,620
I might guess in get sometimes I might

00:05:51,710 --> 00:05:56,990
get different results then if I do the

00:05:54,620 --> 00:05:59,540
other you have a theme like on the image

00:05:56,990 --> 00:06:01,430
on the top if I merge the two branches I

00:05:59,540 --> 00:06:03,590
may get one result and if I merge the

00:06:01,430 --> 00:06:05,690
two like the exact same patches and they

00:06:03,590 --> 00:06:07,130
are not conflicting they are not like

00:06:05,690 --> 00:06:08,780
they are not weird the situation like

00:06:07,130 --> 00:06:11,120
you're dealing they're really different

00:06:08,780 --> 00:06:13,250
parts of the file sometimes

00:06:11,120 --> 00:06:16,100
Bob's patches might get merged in parts

00:06:13,250 --> 00:06:18,040
of the files is never seen and when you

00:06:16,100 --> 00:06:20,570
consider applying tools like that to

00:06:18,040 --> 00:06:23,030
like highly sensitive code such that

00:06:20,570 --> 00:06:25,250
it's like cryptography libraries it's

00:06:23,030 --> 00:06:29,000
kind of scary but it's like what

00:06:25,250 --> 00:06:31,860
everyone does and so

00:06:29,000 --> 00:06:33,900
so what's even worse is that you can

00:06:31,860 --> 00:06:35,670
actually you can actually tell when this

00:06:33,900 --> 00:06:38,070
hits you like if you're a gates user and

00:06:35,670 --> 00:06:39,630
this happened to you there's no way it

00:06:38,070 --> 00:06:42,690
doesn't wait to tell get says yeah I've

00:06:39,630 --> 00:06:45,150
merged it's fine it works and you don't

00:06:42,690 --> 00:06:46,560
you don't notice it maybe it maybe it

00:06:45,150 --> 00:06:49,170
even complies like there are real-world

00:06:46,560 --> 00:06:50,760
examples of this this thing it's not

00:06:49,170 --> 00:06:52,610
just an implementation bug that can be

00:06:50,760 --> 00:06:56,030
worked around it's like a fundamental

00:06:52,610 --> 00:06:59,730
problem in the three-way merge algorithm

00:06:56,030 --> 00:07:03,120
all right so we're we're not the first

00:06:59,730 --> 00:07:04,830
ones to believe this is wrong there was

00:07:03,120 --> 00:07:07,110
another version called system I talked

00:07:04,830 --> 00:07:09,360
about in my intro slide which was called

00:07:07,110 --> 00:07:13,890
darks it's still still called darks by

00:07:09,360 --> 00:07:17,040
the way so they so they are their main

00:07:13,890 --> 00:07:19,260
their main principle is that you say two

00:07:17,040 --> 00:07:20,910
patches are okayed of like fighting with

00:07:19,260 --> 00:07:22,860
each other down conflicts if they

00:07:20,910 --> 00:07:24,030
commute so with that that means it's

00:07:22,860 --> 00:07:26,370
simply that you can apply them in the

00:07:24,030 --> 00:07:28,350
order well then you're like oh they

00:07:26,370 --> 00:07:31,950
almost commute it's not exactly like if

00:07:28,350 --> 00:07:33,840
for you would like do W RL into algebra

00:07:31,950 --> 00:07:35,940
it's not really commuting because you

00:07:33,840 --> 00:07:38,390
sometimes you may have to change the

00:07:35,940 --> 00:07:41,850
like line numbers like for instance if

00:07:38,390 --> 00:07:44,700
Bob at the line called which containing

00:07:41,850 --> 00:07:48,000
just F and main and slang one and at

00:07:44,700 --> 00:07:50,640
least adds a line that like line 10

00:07:48,000 --> 00:07:52,350
saying println hello world when you

00:07:50,640 --> 00:07:55,740
merge them well you might have to merge

00:07:52,350 --> 00:07:58,080
at least Elise's line after Bob's line

00:07:55,740 --> 00:08:00,630
at line 11 instead of 10 but that's what

00:07:58,080 --> 00:08:02,340
that's kind of commuting anyway so

00:08:00,630 --> 00:08:04,530
that's our that's the situation with

00:08:02,340 --> 00:08:06,600
darks when it commutes it's fine

00:08:04,530 --> 00:08:08,250
what if it doesn't commute which happens

00:08:06,600 --> 00:08:11,070
sometimes well it's an under commanded

00:08:08,250 --> 00:08:14,220
part the algorithm so no one really

00:08:11,070 --> 00:08:16,320
knows what it does flow home my

00:08:14,220 --> 00:08:18,480
co-author on people is one of the core

00:08:16,320 --> 00:08:20,100
darks developers and he told me like I

00:08:18,480 --> 00:08:22,440
was pretty confident in darks before

00:08:20,100 --> 00:08:24,030
they told me at some point yeah

00:08:22,440 --> 00:08:26,010
we have no absolutely no clue what it

00:08:24,030 --> 00:08:28,680
does it seems to work most of the time

00:08:26,010 --> 00:08:31,170
it's like it's highlights conflicts but

00:08:28,680 --> 00:08:33,060
we don't really know other than that so

00:08:31,170 --> 00:08:34,860
that praises obviously issues about

00:08:33,060 --> 00:08:37,650
correctness so the situation with darks

00:08:34,860 --> 00:08:39,720
not much much better than we were kids

00:08:37,650 --> 00:08:41,250
well at least highlights complex and

00:08:39,720 --> 00:08:44,240
warns the user about complex

00:08:41,250 --> 00:08:46,709
but then what it does no one knows

00:08:44,240 --> 00:08:48,720
another problem is slightly bigger

00:08:46,709 --> 00:08:50,730
that's the main reason why darks was in

00:08:48,720 --> 00:08:53,189
but I've been done even though it came

00:08:50,730 --> 00:08:55,439
before before get is that it sometimes

00:08:53,189 --> 00:08:56,910
exponentially slow so exponentially slow

00:08:55,439 --> 00:09:00,269
in the size of history number of patches

00:08:56,910 --> 00:09:02,850
in their position and so that some

00:09:00,269 --> 00:09:05,279
people to device the like merge over

00:09:02,850 --> 00:09:07,170
that we can work through where you like

00:09:05,279 --> 00:09:09,209
try to synchronize all the patches you

00:09:07,170 --> 00:09:12,000
made during the week and instead of

00:09:09,209 --> 00:09:14,519
synchronizing like while you're working

00:09:12,000 --> 00:09:17,129
on it you're just like waiting for

00:09:14,519 --> 00:09:19,500
Friday night to arrive start to merge

00:09:17,129 --> 00:09:20,970
like booster patches and well hopefully

00:09:19,500 --> 00:09:21,480
by Monday morning when you come back to

00:09:20,970 --> 00:09:23,100
office

00:09:21,480 --> 00:09:29,100
well the patches are merged but

00:09:23,100 --> 00:09:31,259
sometimes not so this is this is no this

00:09:29,100 --> 00:09:33,269
makes it kind of like not really

00:09:31,259 --> 00:09:35,129
acceptable and this is also one of the

00:09:33,269 --> 00:09:37,139
reasons why we could not convince our

00:09:35,129 --> 00:09:37,980
colleagues to out to use it because they

00:09:37,139 --> 00:09:40,259
tried to use it

00:09:37,980 --> 00:09:41,939
naively thought yeah well patches well

00:09:40,259 --> 00:09:43,470
we cannot understand what they are so

00:09:41,939 --> 00:09:46,170
let's try to push about bunch of patches

00:09:43,470 --> 00:09:49,579
repository and well they were surprised

00:09:46,170 --> 00:09:52,589
to have to wait for like half an hour

00:09:49,579 --> 00:09:54,389
merge so it's not usually like that like

00:09:52,589 --> 00:09:57,000
when we write we're developing people

00:09:54,389 --> 00:09:58,740
were using darks to develop it and it's

00:09:57,000 --> 00:10:00,360
like we've never had we've never ever

00:09:58,740 --> 00:10:02,100
runs you that's brought that problem but

00:10:00,360 --> 00:10:03,870
that's also because we're like we know

00:10:02,100 --> 00:10:05,879
how it works we know what the drawbacks

00:10:03,870 --> 00:10:08,610
are we know when the exponentially is

00:10:05,879 --> 00:10:09,930
slow merges happen so but that's not

00:10:08,610 --> 00:10:13,220
acceptable like that it's it's not like

00:10:09,930 --> 00:10:17,100
I wouldn't recommend it to anyone and

00:10:13,220 --> 00:10:19,769
that's where people comes in so we try

00:10:17,100 --> 00:10:23,069
to after our day trying to convince our

00:10:19,769 --> 00:10:25,290
colleagues to use this we just like grab

00:10:23,069 --> 00:10:28,740
grab a beer and started discussing about

00:10:25,290 --> 00:10:31,980
like the here if patchy is what which

00:10:28,740 --> 00:10:34,259
could be like what what good way would

00:10:31,980 --> 00:10:36,149
be like you have a cool patch algebra we

00:10:34,259 --> 00:10:38,819
could use and that would be simple and

00:10:36,149 --> 00:10:40,230
easy to use and that's where we're

00:10:38,819 --> 00:10:42,149
starting to learning about category

00:10:40,230 --> 00:10:44,610
theory so we don't exactly started

00:10:42,149 --> 00:10:46,829
learning learning it back then because

00:10:44,610 --> 00:10:49,110
it's a kind of it's now it's not the

00:10:46,829 --> 00:10:51,540
easiest theory on earth on earth but

00:10:49,110 --> 00:10:53,009
well so whether it is what it is

00:10:51,540 --> 00:10:54,259
basically it's a general theory of

00:10:53,009 --> 00:10:57,379
transformations

00:10:54,259 --> 00:10:59,629
of things so clearly theorists like to

00:10:57,379 --> 00:11:01,759
see it as like the general theory of

00:10:59,629 --> 00:11:04,609
everything the there are numerous

00:11:01,759 --> 00:11:06,649
attempts to rewrite all mathematics in a

00:11:04,609 --> 00:11:08,809
categorical language and I think it's

00:11:06,649 --> 00:11:13,609
pretty successful except that no one can

00:11:08,809 --> 00:11:15,229
understand this so it's already well

00:11:13,609 --> 00:11:18,100
written we have all mathematics in there

00:11:15,229 --> 00:11:20,779
but no one knows what it does all right

00:11:18,100 --> 00:11:23,389
so but it's pretty good for us though

00:11:20,779 --> 00:11:25,220
because it's a so we're trying to talk

00:11:23,389 --> 00:11:28,519
about changes and files and this is a

00:11:25,220 --> 00:11:30,529
theory of changes of on things so one

00:11:28,519 --> 00:11:33,199
particularly cool concept so this you

00:11:30,529 --> 00:11:35,149
can you see all like I I should like

00:11:33,199 --> 00:11:36,859
these things in darks these are

00:11:35,149 --> 00:11:40,039
commutative diagrams and category

00:11:36,859 --> 00:11:42,049
theories try like drawing them basically

00:11:40,039 --> 00:11:43,939
all day long if several colleagues

00:11:42,049 --> 00:11:46,519
working mates they have their whiteboard

00:11:43,939 --> 00:11:48,919
through that these diagrams sometimes in

00:11:46,519 --> 00:11:50,600
3d sometimes it like we are interleaved

00:11:48,919 --> 00:11:52,899
arrows and no one knows but what they

00:11:50,600 --> 00:11:55,929
are doing because they're yeah they're

00:11:52,899 --> 00:12:00,350
talking about transformations on things

00:11:55,929 --> 00:12:02,480
all right so in particular when very

00:12:00,350 --> 00:12:07,029
cool concepts of category theory is the

00:12:02,480 --> 00:12:09,949
concept of push out so push have is a

00:12:07,029 --> 00:12:11,779
depreciated of two patches is like for

00:12:09,949 --> 00:12:14,899
in our particular case the push out of

00:12:11,779 --> 00:12:16,759
two patches would be a file such that no

00:12:14,899 --> 00:12:19,100
matter what you do after these two

00:12:16,759 --> 00:12:21,649
patches that yield the common States

00:12:19,100 --> 00:12:23,809
like a common file so if at least in Bob

00:12:21,649 --> 00:12:25,759
write some stuff and then later they can

00:12:23,809 --> 00:12:26,149
find some patches to agree in a common

00:12:25,759 --> 00:12:29,839
file

00:12:26,149 --> 00:12:31,429
well the via star here is a we call it

00:12:29,839 --> 00:12:33,439
the push out if you can reach the car

00:12:31,429 --> 00:12:38,139
you can reach any common state state in

00:12:33,439 --> 00:12:41,959
the future from that star that clear

00:12:38,139 --> 00:12:43,850
alright so anything you can do to reach

00:12:41,959 --> 00:12:45,350
common stage you can also reach it from

00:12:43,850 --> 00:12:48,169
the Prashad so that means the push out

00:12:45,350 --> 00:12:50,629
is kind of a minimal common state that

00:12:48,169 --> 00:12:52,339
can be like that you that you really

00:12:50,629 --> 00:12:53,899
need to reach leg and it's really watch

00:12:52,339 --> 00:12:55,850
what we want in a version control system

00:12:53,899 --> 00:12:57,439
we really want push out we want minimum

00:12:55,850 --> 00:12:59,959
common states that any further

00:12:57,439 --> 00:13:02,659
developments any further work in the

00:12:59,959 --> 00:13:04,630
repository can also be reached from that

00:13:02,659 --> 00:13:10,090
common States that's what a merge

00:13:04,630 --> 00:13:12,880
really is and it's it's it's it's so the

00:13:10,090 --> 00:13:15,040
run problem is that it's not the case at

00:13:12,880 --> 00:13:17,080
all categories have push outs have all -

00:13:15,040 --> 00:13:19,930
shouts like we see that like the

00:13:17,080 --> 00:13:22,570
translation of that in English is it's

00:13:19,930 --> 00:13:24,580
not clear than any editing any - of any

00:13:22,570 --> 00:13:27,250
couple of editing operations on a file

00:13:24,580 --> 00:13:28,750
will always be merge about like

00:13:27,250 --> 00:13:31,530
sometimes we have conflicts we all know

00:13:28,750 --> 00:13:34,240
like most programmers know bits are in

00:13:31,530 --> 00:13:36,760
conflicts so it's not the case that

00:13:34,240 --> 00:13:39,190
tries have piles and patches have old -

00:13:36,760 --> 00:13:41,770
shouts but what's cool but category

00:13:39,190 --> 00:13:45,610
theory is that there's a solution you

00:13:41,770 --> 00:13:48,220
just need to dig into them like pretty

00:13:45,610 --> 00:13:51,150
big books of like abstract diagrams that

00:13:48,220 --> 00:13:53,380
I don't fit in but then you can

00:13:51,150 --> 00:13:55,180
ultimately find something called the

00:13:53,380 --> 00:13:57,480
free conservative code completion of a

00:13:55,180 --> 00:14:00,760
category and that's a way to

00:13:57,480 --> 00:14:03,430
artificially add all push outs into the

00:14:00,760 --> 00:14:05,650
category so that means when you when you

00:14:03,430 --> 00:14:07,960
have a category of files and passes

00:14:05,650 --> 00:14:10,530
between files the free conservative code

00:14:07,960 --> 00:14:14,650
completion is a construction that will

00:14:10,530 --> 00:14:18,520
automatically give you a category like a

00:14:14,650 --> 00:14:20,860
generalized generalization of files so

00:14:18,520 --> 00:14:24,880
that's like that generalization will

00:14:20,860 --> 00:14:26,860
have all push outs so in people if we

00:14:24,880 --> 00:14:29,850
translate it into like files and patches

00:14:26,860 --> 00:14:32,140
for instance if Bob adds the line

00:14:29,850 --> 00:14:34,510
country like saying just print a line

00:14:32,140 --> 00:14:36,550
Bob and at least at the lines in just

00:14:34,510 --> 00:14:39,370
print a line at least when they merge

00:14:36,550 --> 00:14:43,150
that in people what they get is just a

00:14:39,370 --> 00:14:46,270
graph of lines where the two lines are

00:14:43,150 --> 00:14:48,070
added they're not comparable if not yet

00:14:46,270 --> 00:14:49,750
said what like how they should compare

00:14:48,070 --> 00:14:52,150
and how they they should relate to each

00:14:49,750 --> 00:14:53,770
other in the file you may be at least is

00:14:52,150 --> 00:14:55,510
write anybody's right maybe you're both

00:14:53,770 --> 00:14:56,110
right maybe they're both right but in a

00:14:55,510 --> 00:14:58,600
different order

00:14:56,110 --> 00:15:01,090
you don't mean oh that's a conflict and

00:14:58,600 --> 00:15:03,330
so what that theory or the category

00:15:01,090 --> 00:15:05,590
theory gives you here as a

00:15:03,330 --> 00:15:08,200
generalization of files its which is

00:15:05,590 --> 00:15:11,800
well in most cases a little more complex

00:15:08,200 --> 00:15:13,810
that gets more the the benefits for a

00:15:11,800 --> 00:15:15,760
three lines file or maybe not obvious

00:15:13,810 --> 00:15:17,800
but when files get really large it's

00:15:15,760 --> 00:15:21,490
it's really great to have that sound

00:15:17,800 --> 00:15:22,899
theory that backs you up and right so

00:15:21,490 --> 00:15:29,050
that's that's what people is about

00:15:22,899 --> 00:15:31,959
that's that's how it works so I want to

00:15:29,050 --> 00:15:34,029
say before moving on that this is quite

00:15:31,959 --> 00:15:36,970
different from see our LEDs sociology's

00:15:34,029 --> 00:15:39,640
are conflict-free replicated data types

00:15:36,970 --> 00:15:41,410
and people is more like conflict

00:15:39,640 --> 00:15:42,880
tolerant replicated data types so we're

00:15:41,410 --> 00:15:44,950
not resolving all the conflicts all the

00:15:42,880 --> 00:15:48,010
time we're just rather than that we're

00:15:44,950 --> 00:15:50,079
just like accepting conflicts as part of

00:15:48,010 --> 00:15:51,790
the system like the data structure can

00:15:50,079 --> 00:15:53,350
handle like it can it can represent

00:15:51,790 --> 00:15:55,570
conflicts doesn't have to resolve them

00:15:53,350 --> 00:15:57,490
all the time and so that's what makes it

00:15:55,570 --> 00:15:59,410
fast that's what makes people really

00:15:57,490 --> 00:16:00,850
fast because you can apply many patches

00:15:59,410 --> 00:16:02,680
they are conflicting but that's alright

00:16:00,850 --> 00:16:04,420
and then once you are done applying a

00:16:02,680 --> 00:16:06,130
bunch of patches you're you can just

00:16:04,420 --> 00:16:09,220
like detect conflicts and I'll put the

00:16:06,130 --> 00:16:11,470
files and that's it so what what would

00:16:09,220 --> 00:16:13,149
the situation be with theologies if we

00:16:11,470 --> 00:16:16,209
were trying to apply your leans to this

00:16:13,149 --> 00:16:18,760
problem of like merging patches well in

00:16:16,209 --> 00:16:21,130
theory oddities you need to always order

00:16:18,760 --> 00:16:22,930
so the way it gets real complex is by

00:16:21,130 --> 00:16:24,910
ordering all operation determine

00:16:22,930 --> 00:16:26,709
deterministically so it finds whatever

00:16:24,910 --> 00:16:29,110
solution like whatever deterministic

00:16:26,709 --> 00:16:31,690
merge algorithm they can find to like

00:16:29,110 --> 00:16:33,880
just order order things all their

00:16:31,690 --> 00:16:35,440
operations in an arbitrary but

00:16:33,880 --> 00:16:38,020
deterministic order like for instance we

00:16:35,440 --> 00:16:40,290
can have a rule same lease Elisa's

00:16:38,020 --> 00:16:43,029
patches always can always come first and

00:16:40,290 --> 00:16:45,579
when there are two conflicting patches

00:16:43,029 --> 00:16:47,910
from at least I'll just take like take

00:16:45,579 --> 00:16:50,829
them in alphabetical order for instance

00:16:47,910 --> 00:16:54,040
and so you know in our case that would

00:16:50,829 --> 00:16:56,050
like lead to the following file like two

00:16:54,040 --> 00:16:58,870
lines one saying print a line at least

00:16:56,050 --> 00:17:00,399
one same printer and Bob and the user

00:16:58,870 --> 00:17:02,949
would barely see anything they would be

00:17:00,399 --> 00:17:05,709
like yeah that's that's it the merge has

00:17:02,949 --> 00:17:07,720
succeeded but that doesn't that isn't

00:17:05,709 --> 00:17:09,189
really right because that like it the

00:17:07,720 --> 00:17:10,720
user should that be we at least be

00:17:09,189 --> 00:17:15,490
warned that there's a conflict and they

00:17:10,720 --> 00:17:18,370
should do something about it all right

00:17:15,490 --> 00:17:20,679
so the end result of that it's well the

00:17:18,370 --> 00:17:22,480
fury is a slightly more complicated in

00:17:20,679 --> 00:17:25,569
what I've explained but not much more

00:17:22,480 --> 00:17:27,309
the result of that is that we developed

00:17:25,569 --> 00:17:29,679
a sound theory of fashions

00:17:27,309 --> 00:17:30,620
sound the giraffe patches it has the

00:17:29,679 --> 00:17:33,260
following

00:17:30,620 --> 00:17:35,360
very cool properties so bear with me for

00:17:33,260 --> 00:17:39,980
a moment what I'm right like saying

00:17:35,360 --> 00:17:42,260
these like bad words so they're the the

00:17:39,980 --> 00:17:43,220
fury is like the or algebra is

00:17:42,260 --> 00:17:45,289
commutative

00:17:43,220 --> 00:17:46,730
it means you can like if pet cheese

00:17:45,289 --> 00:17:49,490
don't depend on each other you can apply

00:17:46,730 --> 00:17:51,200
them in any order so that's that's what

00:17:49,490 --> 00:17:54,020
you would expect from that cheese right

00:17:51,200 --> 00:17:55,669
it's associative so we resolved the

00:17:54,020 --> 00:17:58,100
initial the initial problem and started

00:17:55,669 --> 00:18:00,919
this talk with so you can you can

00:17:58,100 --> 00:18:03,020
basically like no matter how you merge

00:18:00,919 --> 00:18:04,970
patches if the merge is right like

00:18:03,020 --> 00:18:06,679
there's only one solution to merge and

00:18:04,970 --> 00:18:08,990
you're not you're like you're not

00:18:06,679 --> 00:18:10,880
getting into trouble like by you're

00:18:08,990 --> 00:18:12,890
never like do you're never doing what

00:18:10,880 --> 00:18:14,630
get does which is like merging things

00:18:12,890 --> 00:18:17,539
from Bob in parts of the fight is never

00:18:14,630 --> 00:18:20,630
seen that's what associativity is about

00:18:17,539 --> 00:18:22,669
and also one very cool property is that

00:18:20,630 --> 00:18:24,350
all past is about semantic inverse which

00:18:22,669 --> 00:18:27,169
means when you're when you've read in a

00:18:24,350 --> 00:18:30,529
patch you can you can derive in other

00:18:27,169 --> 00:18:32,929
patch permits that has the like the

00:18:30,529 --> 00:18:35,210
opposite effects and then like push it

00:18:32,929 --> 00:18:37,070
to other predators you cancel previous

00:18:35,210 --> 00:18:38,210
patches the thing is you can since you

00:18:37,070 --> 00:18:40,730
can it's it's all commits all

00:18:38,210 --> 00:18:42,919
commutative so you can basically compute

00:18:40,730 --> 00:18:48,529
an inverse for pets you boost like 1,000

00:18:42,919 --> 00:18:50,419
patches ago and it all just works and it

00:18:48,529 --> 00:18:53,899
it does even better than just working

00:18:50,419 --> 00:18:55,610
it's also pretty fast so merging and

00:18:53,899 --> 00:18:57,770
applying patches it's basically the same

00:18:55,610 --> 00:19:00,440
operation in our system

00:18:57,770 --> 00:19:02,210
well it's possibly the last complicated

00:19:00,440 --> 00:19:04,669
slide I've written like there I'll move

00:19:02,210 --> 00:19:06,409
on to like easier stuff after that so

00:19:04,669 --> 00:19:08,390
our complexity for people we know

00:19:06,409 --> 00:19:11,149
complexity here our complexity is like

00:19:08,390 --> 00:19:12,620
linear inside of the patch and the guy

00:19:11,149 --> 00:19:15,289
with make in the size of history so it's

00:19:12,620 --> 00:19:17,330
like it doesn't like you can have an

00:19:15,289 --> 00:19:19,399
arbitrarily big history it's not it

00:19:17,330 --> 00:19:21,409
doesn't really matter like you can you

00:19:19,399 --> 00:19:24,020
can apply the new patch your new patch P

00:19:21,409 --> 00:19:25,820
after an arbitrary alerts arbitrarily

00:19:24,020 --> 00:19:28,460
large number of patches it doesn't

00:19:25,820 --> 00:19:32,659
matter it always works the same like

00:19:28,460 --> 00:19:34,250
almost and this is this is actually that

00:19:32,659 --> 00:19:36,110
was surprising to us but it's actually

00:19:34,250 --> 00:19:39,200
better than three-way merge which also

00:19:36,110 --> 00:19:41,300
adds in a like square factor of the size

00:19:39,200 --> 00:19:44,030
of the file

00:19:41,300 --> 00:19:46,370
that's actually really also observed

00:19:44,030 --> 00:19:48,050
that in real world cases where we're

00:19:46,370 --> 00:19:50,150
trying to benchmark like in early stages

00:19:48,050 --> 00:19:52,730
of our development we were trying to

00:19:50,150 --> 00:19:57,730
burnish mark it against like really fast

00:19:52,730 --> 00:20:00,620
competitors such as yet and as file size

00:19:57,730 --> 00:20:02,900
increase we not we actually noticed the

00:20:00,620 --> 00:20:05,330
difference in performance to the point

00:20:02,900 --> 00:20:07,970
that people who was actually faster and

00:20:05,330 --> 00:20:10,250
get when merging really large patches on

00:20:07,970 --> 00:20:17,090
really large price which I'm not really

00:20:10,250 --> 00:20:19,130
sure is a real-world case but anyway and

00:20:17,090 --> 00:20:21,410
so that brings me to the last part of

00:20:19,130 --> 00:20:23,240
this talk so why what made Russ a cool

00:20:21,410 --> 00:20:24,710
tool to work with what did we like and

00:20:23,240 --> 00:20:28,130
rust and how it helped us build this

00:20:24,710 --> 00:20:30,880
this cool new system so one thing is

00:20:28,130 --> 00:20:33,470
we're working on our algorithms

00:20:30,880 --> 00:20:34,790
mathematical objects and that means we

00:20:33,470 --> 00:20:37,010
need types we need to be able to reason

00:20:34,790 --> 00:20:39,740
about our code and that's very important

00:20:37,010 --> 00:20:41,060
to us like we couldn't really like we

00:20:39,740 --> 00:20:42,950
want to develop a sound theory of

00:20:41,060 --> 00:20:45,620
patches and we couldn't like the

00:20:42,950 --> 00:20:49,010
implement it and then rely on like our

00:20:45,620 --> 00:20:50,930
intuition to build correct CC Curcio C++

00:20:49,010 --> 00:20:53,630
code that would be like yeah maybe the

00:20:50,930 --> 00:20:56,240
theory is correct then what about the

00:20:53,630 --> 00:21:00,800
implementation so because we have types

00:20:56,240 --> 00:21:03,410
and rust that makes it easy to do so but

00:21:00,800 --> 00:21:06,560
we also want to be fast like as I said

00:21:03,410 --> 00:21:08,330
like the complexity theory stuff tells

00:21:06,560 --> 00:21:10,010
us that we have the we have the

00:21:08,330 --> 00:21:11,660
potential to become faster than gates

00:21:10,010 --> 00:21:14,780
and we really want to exploit that

00:21:11,660 --> 00:21:16,850
potential and we really want to to have

00:21:14,780 --> 00:21:19,670
like to be as fast as we can and rust

00:21:16,850 --> 00:21:22,490
that I was also asked to do that because

00:21:19,670 --> 00:21:25,640
we can add like we can use a like fast

00:21:22,490 --> 00:21:30,020
back hands we can add like roll pointers

00:21:25,640 --> 00:21:31,130
to like the parameter memory like I'm

00:21:30,020 --> 00:21:33,530
Maps and what now

00:21:31,130 --> 00:21:34,910
that's really cool and that wasn't the

00:21:33,530 --> 00:21:37,850
case in the early prototypes that were

00:21:34,910 --> 00:21:40,520
really not in other languages but also

00:21:37,850 --> 00:21:41,900
more maybe more importantly so we

00:21:40,520 --> 00:21:44,540
started doing that because we couldn't

00:21:41,900 --> 00:21:47,960
convince Windows users to install dark

00:21:44,540 --> 00:21:49,430
cinder machines and and that's and and

00:21:47,960 --> 00:21:51,350
our goal was to be as inclusive as

00:21:49,430 --> 00:21:54,080
possible was to like green version

00:21:51,350 --> 00:21:54,680
control to everyone but we cannot really

00:21:54,080 --> 00:21:56,150
do that if

00:21:54,680 --> 00:21:58,010
can only tell you a small portion of

00:21:56,150 --> 00:22:01,460
computer users which are like expert

00:21:58,010 --> 00:22:03,740
Linux users and so what we really loved

00:22:01,460 --> 00:22:06,560
in rust is that we can write clients and

00:22:03,740 --> 00:22:08,180
servers for real word protocols so I had

00:22:06,560 --> 00:22:10,400
to write some of that myself but it was

00:22:08,180 --> 00:22:12,530
actually quite pleasant right but also

00:22:10,400 --> 00:22:15,470
yeah there was a there's a Lord unit an

00:22:12,530 --> 00:22:19,490
HTTP stack working out pretty well and I

00:22:15,470 --> 00:22:21,620
wrote the message library alright and so

00:22:19,490 --> 00:22:23,870
we finally got Windows support and so

00:22:21,620 --> 00:22:25,300
I'd like to thank the rust developers

00:22:23,870 --> 00:22:29,930
for that that's that's really awesome

00:22:25,300 --> 00:22:32,210
thanks ok so as part of like what needed

00:22:29,930 --> 00:22:33,500
to be Bradon because rust pretty young

00:22:32,210 --> 00:22:36,380
language there aren't that many

00:22:33,500 --> 00:22:40,850
libraries so there are I just wanted to

00:22:36,380 --> 00:22:43,640
conclude with two really hard things

00:22:40,850 --> 00:22:46,100
like two really two things that I really

00:22:43,640 --> 00:22:47,930
did didn't put didn't think I would have

00:22:46,100 --> 00:22:52,220
to write when I when I started its

00:22:47,930 --> 00:22:53,870
projects so when as a as a project that

00:22:52,220 --> 00:22:56,650
I call sonically I'll just finish word

00:22:53,870 --> 00:22:59,360
for dictionary there was infinite time

00:22:56,650 --> 00:23:02,750
well security has a transactional on

00:22:59,360 --> 00:23:04,790
this b3 with like many others like LM DB

00:23:02,750 --> 00:23:06,500
if you know an MV like many other

00:23:04,790 --> 00:23:10,100
database backends but it's particularly

00:23:06,500 --> 00:23:12,500
is that it has a fork operation that

00:23:10,100 --> 00:23:13,460
trends in logarithmic time like a fast

00:23:12,500 --> 00:23:15,500
for corporation

00:23:13,460 --> 00:23:19,310
so for cooperation means you can clone

00:23:15,500 --> 00:23:21,760
the database in like log log in time and

00:23:19,310 --> 00:23:25,760
then have two copies of the database

00:23:21,760 --> 00:23:27,790
behave as two different databases so I

00:23:25,760 --> 00:23:30,470
needed that to implement branches and

00:23:27,790 --> 00:23:33,050
still work in progress because it's

00:23:30,470 --> 00:23:34,580
really hard to do I'm coming back to it

00:23:33,050 --> 00:23:38,060
in a minute

00:23:34,580 --> 00:23:41,660
and then there's a another bacterial

00:23:38,060 --> 00:23:43,670
agent just like crossed fingers like I

00:23:41,660 --> 00:23:45,560
crossed it's called fresh it's nested

00:23:43,670 --> 00:23:49,250
current and server library they wrote

00:23:45,560 --> 00:23:51,740
it's it's been made like it's really

00:23:49,250 --> 00:23:53,960
entirely in rust and it's been it's

00:23:51,740 --> 00:23:56,030
gotten rid of all unsafe blocks two

00:23:53,960 --> 00:23:58,960
weeks ago thanks to our brian smith

00:23:56,030 --> 00:23:58,960
who's not

00:23:59,090 --> 00:24:04,650
okay so the trickiest parts the

00:24:02,670 --> 00:24:09,120
trickiest thing that I had to do in

00:24:04,650 --> 00:24:12,030
where this is sanic area so why was it

00:24:09,120 --> 00:24:13,860
tricky well because rust always wants to

00:24:12,030 --> 00:24:15,960
free everything before the program

00:24:13,860 --> 00:24:17,430
closes and when you're writing a

00:24:15,960 --> 00:24:19,470
database back-end it doesn't really

00:24:17,430 --> 00:24:21,570
sound right you won't like something to

00:24:19,470 --> 00:24:23,340
remain on disk after the program closes

00:24:21,570 --> 00:24:27,240
so that was really hard so you have to

00:24:23,340 --> 00:24:28,920
do like manual memory management you're

00:24:27,240 --> 00:24:30,480
like--you're yourself and that's not

00:24:28,920 --> 00:24:34,860
really when you're used to a functional

00:24:30,480 --> 00:24:36,600
programming high scale or cameras like

00:24:34,860 --> 00:24:40,710
coming back to manual memory management

00:24:36,600 --> 00:24:43,920
isn't free Pleasants so how does it work

00:24:40,710 --> 00:24:46,650
so I'm going to explain anyway how rust

00:24:43,920 --> 00:24:49,080
helped us do that so how does it work

00:24:46,650 --> 00:24:52,110
it's just not going to be very technical

00:24:49,080 --> 00:24:54,990
here but like most database and Giants

00:24:52,110 --> 00:24:57,240
are like sorry some cool database is

00:24:54,990 --> 00:24:59,820
enjoying that I liked are based on be

00:24:57,240 --> 00:25:03,060
trees so B trees are basically like

00:24:59,820 --> 00:25:05,820
trees made of blocks in each block yours

00:25:03,060 --> 00:25:07,320
there are like ordered elements there's

00:25:05,820 --> 00:25:09,990
no word list of elements there's a

00:25:07,320 --> 00:25:12,000
constant number of elements and between

00:25:09,990 --> 00:25:14,010
these elements you have pointers to

00:25:12,000 --> 00:25:16,950
other other blocks to children blocks

00:25:14,010 --> 00:25:18,780
and it's so insertion happens it

00:25:16,950 --> 00:25:20,580
believes and then while the blocks plate

00:25:18,780 --> 00:25:22,140
when they're gonna get too big but

00:25:20,580 --> 00:25:24,450
that's well that's how B trees work

00:25:22,140 --> 00:25:27,390
there's a good B tree library in the

00:25:24,450 --> 00:25:29,670
standard brush library so now that's

00:25:27,390 --> 00:25:32,010
cool but we can actually use it to like

00:25:29,670 --> 00:25:33,510
it doesn't allocate inside the files so

00:25:32,010 --> 00:25:35,430
yeah it's allocates the program's memory

00:25:33,510 --> 00:25:37,590
so we have to write a like a different

00:25:35,430 --> 00:25:41,070
like a new library for B trees that

00:25:37,590 --> 00:25:42,890
would work in files and so the main

00:25:41,070 --> 00:25:48,090
thing I've wish I knew when I started

00:25:42,890 --> 00:25:49,560
writing that as about iterators so wait

00:25:48,090 --> 00:25:51,900
I'm coming back to it so when when

00:25:49,560 --> 00:25:55,230
sometimes in B trees you have to merge

00:25:51,900 --> 00:25:57,690
blocks when they're when they get to

00:25:55,230 --> 00:26:02,040
like well when they get to like under

00:25:57,690 --> 00:26:03,840
fool we have to merge them and something

00:26:02,040 --> 00:26:06,180
I wasn't doing in the beginning because

00:26:03,840 --> 00:26:08,280
like since since I was doing manual

00:26:06,180 --> 00:26:09,850
memory management I figured I could like

00:26:08,280 --> 00:26:11,620
like the root

00:26:09,850 --> 00:26:14,049
habits came back and I was like okay

00:26:11,620 --> 00:26:16,120
let's do manual like manual stuff roll

00:26:14,049 --> 00:26:17,500
pointers and manual things and that's

00:26:16,120 --> 00:26:20,049
not really the right solution Rus

00:26:17,500 --> 00:26:23,289
because you can use like cool right

00:26:20,049 --> 00:26:25,660
things anyway even if you have to roll

00:26:23,289 --> 00:26:28,000
pointers so main thing I've learned

00:26:25,660 --> 00:26:31,360
while doing this is iterators and how to

00:26:28,000 --> 00:26:33,460
use them so merging pages like merging

00:26:31,360 --> 00:26:34,150
blocks like this can be done in the

00:26:33,460 --> 00:26:36,309
following way

00:26:34,150 --> 00:26:38,260
so if right you're basically right in

00:26:36,309 --> 00:26:41,049
each other like two iterators one for

00:26:38,260 --> 00:26:43,929
each page there will like give you yield

00:26:41,049 --> 00:26:45,400
like all elements all successive

00:26:43,929 --> 00:26:47,350
elements in the two pages and you can

00:26:45,400 --> 00:26:49,240
then chain them and add other elements

00:26:47,350 --> 00:26:51,059
in the middle that's exactly what you

00:26:49,240 --> 00:26:53,620
want to do with your merchant pages and

00:26:51,059 --> 00:26:56,140
well deletions and B trees are usually

00:26:53,620 --> 00:26:59,679
pretty tricky and that allows you to our

00:26:56,140 --> 00:27:02,260
get tested really easily and so the main

00:26:59,679 --> 00:27:05,770
reason why I've why I really like this

00:27:02,260 --> 00:27:07,809
is that when you're prototyping usually

00:27:05,770 --> 00:27:09,669
your your head is kind of in a messy

00:27:07,809 --> 00:27:11,590
state and you really don't know what

00:27:09,669 --> 00:27:13,270
you're going to so most of the lines

00:27:11,590 --> 00:27:14,830
you're writing will be deleted in the

00:27:13,270 --> 00:27:18,480
end and you really don't know how to

00:27:14,830 --> 00:27:22,620
proceed what to do and so this kind of

00:27:18,480 --> 00:27:25,450
hurry concise and and short sorts of

00:27:22,620 --> 00:27:27,820
statements allow you to uh to get that

00:27:25,450 --> 00:27:29,320
phase and get like production ready code

00:27:27,820 --> 00:27:32,980
much much faster because the prototype

00:27:29,320 --> 00:27:35,860
start working much much faster another

00:27:32,980 --> 00:27:37,750
thing is that I've learned is that well

00:27:35,860 --> 00:27:39,669
then I was like oh yeah

00:27:37,750 --> 00:27:41,559
so we can have saved I've tried like we

00:27:39,669 --> 00:27:43,600
can have cool attractions anyway so then

00:27:41,559 --> 00:27:45,250
there has Carol reflexes came back and I

00:27:43,600 --> 00:27:47,140
was like oh yeah let's do recursion

00:27:45,250 --> 00:27:48,850
let's put in record recursion everywhere

00:27:47,140 --> 00:27:51,580
and one thing I've learned is that it's

00:27:48,850 --> 00:27:54,010
not always so in Russ you can't you can

00:27:51,580 --> 00:27:56,020
write very concise code but the

00:27:54,010 --> 00:27:59,620
recursive way is not as surely the most

00:27:56,020 --> 00:28:01,539
concise you can do so in sanik area for

00:27:59,620 --> 00:28:03,340
instance sometimes we need so it's on

00:28:01,539 --> 00:28:05,020
these cried so there's a every time you

00:28:03,340 --> 00:28:07,780
load something from this from this kit

00:28:05,020 --> 00:28:10,179
like cost you a lot so you want to avoid

00:28:07,780 --> 00:28:11,650
like do you avoid doing that at all cost

00:28:10,179 --> 00:28:14,080
like and any time you can avoid loading

00:28:11,650 --> 00:28:15,640
your page it's a map right so anytime

00:28:14,080 --> 00:28:17,590
you can avoid loading your page to the

00:28:15,640 --> 00:28:19,980
program's memory you won't really want

00:28:17,590 --> 00:28:19,980
to avoid it

00:28:20,500 --> 00:28:26,320
and so in order to do that the solutions

00:28:23,890 --> 00:28:28,630
that will do things lazily so we're

00:28:26,320 --> 00:28:31,180
instead of deleting something or adding

00:28:28,630 --> 00:28:33,670
like I think new element to the sabitri

00:28:31,180 --> 00:28:36,520
what we're doing is just like we're

00:28:33,670 --> 00:28:38,020
doing it lazily that means we're we're

00:28:36,520 --> 00:28:40,810
just saying well next time you want to

00:28:38,020 --> 00:28:42,520
do something you have to copy too you

00:28:40,810 --> 00:28:44,470
have to copy the page and update

00:28:42,520 --> 00:28:46,150
everything but just at the time of doing

00:28:44,470 --> 00:28:47,320
it not right now because we we don't

00:28:46,150 --> 00:28:49,030
really know what we're going through

00:28:47,320 --> 00:28:52,150
this page maybe we will merge it maybe

00:28:49,030 --> 00:28:56,530
we'll drop it and it would be a huge

00:28:52,150 --> 00:28:59,650
waste of time to copy it and then edit

00:28:56,530 --> 00:29:01,600
it or or copy it and then merge it that

00:28:59,650 --> 00:29:06,310
would be like we would have to copy the

00:29:01,600 --> 00:29:08,410
page twice instead of just once so in

00:29:06,310 --> 00:29:10,600
order to do that we need to have like

00:29:08,410 --> 00:29:12,670
write actually something that looks like

00:29:10,600 --> 00:29:15,160
a recursive function well we just have

00:29:12,670 --> 00:29:17,590
to the that function which we have

00:29:15,160 --> 00:29:20,230
access to several consecutive elements

00:29:17,590 --> 00:29:21,760
in the programs call stack and that's

00:29:20,230 --> 00:29:24,700
not really easy when you're writing a

00:29:21,760 --> 00:29:26,230
like writing it's really recursively so

00:29:24,700 --> 00:29:30,550
the way it's done actually at the moment

00:29:26,230 --> 00:29:32,860
it's there's a fake call stack it's just

00:29:30,550 --> 00:29:35,920
basically an array and the fact that B

00:29:32,860 --> 00:29:37,120
trees are well balanced means that there

00:29:35,920 --> 00:29:39,820
are not actually they're not actually

00:29:37,120 --> 00:29:41,800
going to eat up the world memory of the

00:29:39,820 --> 00:29:44,170
computer so you know that the the the

00:29:41,800 --> 00:29:45,580
death is not going to be larger than 64

00:29:44,170 --> 00:29:48,550
so you can allocate an array on the

00:29:45,580 --> 00:29:50,680
stack and and write like how does fall

00:29:48,550 --> 00:29:54,910
off a stack pointer so you're basically

00:29:50,680 --> 00:29:56,470
simulating the program stack and so that

00:29:54,910 --> 00:29:57,940
these are the two main things I wish I

00:29:56,470 --> 00:30:00,910
knew when I started writing something

00:29:57,940 --> 00:30:02,410
yeah so just why do thank you

00:30:00,910 --> 00:30:04,090
especially you're a spell trust

00:30:02,410 --> 00:30:06,190
organizers this conference is awesome

00:30:04,090 --> 00:30:07,480
we're really enjoying us and if you have

00:30:06,190 --> 00:30:08,960
questions I'm really happy you're

00:30:07,480 --> 00:30:15,579
answering Thanks

00:30:08,960 --> 00:30:15,579

YouTube URL: https://www.youtube.com/watch?v=o0ooKVikV3c


