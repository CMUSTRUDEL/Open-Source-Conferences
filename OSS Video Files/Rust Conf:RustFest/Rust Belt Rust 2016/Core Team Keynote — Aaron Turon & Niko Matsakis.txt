Title: Core Team Keynote â€” Aaron Turon & Niko Matsakis
Publication date: 2017-10-25
Playlist: Rust Belt Rust 2016
Description: 
	Aaron and Niko will deliver an update on the state of all things Rust. You don't want to miss it!

http://www.rust-belt-rust.com/
Captions: 
	00:00:06,410 --> 00:00:15,690
alright well while we're waiting I just

00:00:12,719 --> 00:00:17,430
wanted to say this has been a pretty

00:00:15,690 --> 00:00:18,630
exciting year for us so I'm gonna talk a

00:00:17,430 --> 00:00:21,570
little bit about some of the technical

00:00:18,630 --> 00:00:23,730
stuff but you know just looking alone at

00:00:21,570 --> 00:00:26,730
the set of conferences so we had last

00:00:23,730 --> 00:00:29,250
year we had Russ camp this year we had

00:00:26,730 --> 00:00:31,200
rust comp rust fast in Berlin and now we

00:00:29,250 --> 00:00:32,399
have Russ Bell dress so I'm pretty

00:00:31,200 --> 00:00:33,570
excited about that and I want to thank

00:00:32,399 --> 00:00:35,010
you guys for coming and thanks to all

00:00:33,570 --> 00:00:37,710
the organizers and the sponsors for

00:00:35,010 --> 00:00:38,330
making this happen so I'm just gonna do

00:00:37,710 --> 00:00:45,540
this myself

00:00:38,330 --> 00:00:45,540
[Applause]

00:00:56,720 --> 00:01:00,610
maybe we got a resynchronize or

00:00:58,370 --> 00:01:00,610
something

00:01:06,420 --> 00:01:14,189
okay alright so we're gonna talk this

00:01:10,170 --> 00:01:16,740
we're gonna talk mostly about rust in

00:01:14,189 --> 00:01:19,020
2017 but I want to start by looking a

00:01:16,740 --> 00:01:22,140
little bit about what's happened in 2016

00:01:19,020 --> 00:01:25,310
or really since about May 2015 which was

00:01:22,140 --> 00:01:28,830
rust 1.0 and if you remember think back

00:01:25,310 --> 00:01:30,659
at that time we kind of just announced

00:01:28,830 --> 00:01:33,030
that we were gonna be stable and we had

00:01:30,659 --> 00:01:35,340
a pretty small but you know solid and

00:01:33,030 --> 00:01:37,259
respectable API surface available but in

00:01:35,340 --> 00:01:39,360
the meantime the standard library has

00:01:37,259 --> 00:01:41,909
really fleshed out and we've gotten over

00:01:39,360 --> 00:01:44,580
175 new features probably more this is

00:01:41,909 --> 00:01:47,100
and also a much bigger crate i/o

00:01:44,580 --> 00:01:48,750
ecosystem and so forth and so you can do

00:01:47,100 --> 00:01:50,610
a lot more with stable rest now than you

00:01:48,750 --> 00:01:52,799
could then and we've also had a lot of

00:01:50,610 --> 00:01:54,690
exciting language features that are been

00:01:52,799 --> 00:01:57,209
implemented and worked out and special

00:01:54,690 --> 00:01:58,799
aspect and are now coming kind of

00:01:57,209 --> 00:02:00,869
starting to become available and stable

00:01:58,799 --> 00:02:03,690
right about now so specialization and

00:02:00,869 --> 00:02:04,979
infiltrate are available on nightly the

00:02:03,690 --> 00:02:06,390
question mark operator was just

00:02:04,979 --> 00:02:08,549
specialized I think it'll be in the next

00:02:06,390 --> 00:02:10,080
release if not the one after that and

00:02:08,549 --> 00:02:11,970
we're gonna soon have custom derives

00:02:10,080 --> 00:02:13,739
that you can do things like derive use

00:02:11,970 --> 00:02:15,959
Saturday unstable and so forth which has

00:02:13,739 --> 00:02:16,500
been a really popular big feature

00:02:15,959 --> 00:02:18,420
request

00:02:16,500 --> 00:02:20,370
we've also done a lot of work re

00:02:18,420 --> 00:02:21,600
architecting the compiler laying the

00:02:20,370 --> 00:02:24,269
groundwork for some of the stuff that

00:02:21,600 --> 00:02:27,060
we're going to talk about now for 2017

00:02:24,269 --> 00:02:30,600
so we've done a completely new IR which

00:02:27,060 --> 00:02:31,890
was a big effort and especially have a

00:02:30,600 --> 00:02:34,140
big community effort which is really

00:02:31,890 --> 00:02:35,970
exciting and that allowed us to do some

00:02:34,140 --> 00:02:38,040
long-standing optimizations to our code

00:02:35,970 --> 00:02:39,359
generation incremental compilation is

00:02:38,040 --> 00:02:41,630
starting to work hopefully in the next

00:02:39,359 --> 00:02:43,950
few months we'll have it really in use

00:02:41,630 --> 00:02:46,140
for the first for the first time and

00:02:43,950 --> 00:02:48,690
also we have a brand new error message

00:02:46,140 --> 00:02:50,579
output which I think many of you have

00:02:48,690 --> 00:02:52,530
experienced that makes there is much

00:02:50,579 --> 00:02:55,049
easier to follow and so forth and

00:02:52,530 --> 00:02:57,510
finally we're now working much more

00:02:55,049 --> 00:02:59,250
stable e on much more platforms right so

00:02:57,510 --> 00:03:01,170
a Windows support is much better you can

00:02:59,250 --> 00:03:03,630
target Musil which lets you deploy your

00:03:01,170 --> 00:03:05,940
binaries to any Linux ever or whatever

00:03:03,630 --> 00:03:08,489
something like that and then you have

00:03:05,940 --> 00:03:10,620
rust up to easily switch between them so

00:03:08,489 --> 00:03:12,660
that's really cool but moreover we've

00:03:10,620 --> 00:03:14,849
done all these things without totally

00:03:12,660 --> 00:03:16,709
messing up rust it turns out people

00:03:14,849 --> 00:03:17,709
still really like it we hope to keep

00:03:16,709 --> 00:03:19,510
that up so

00:03:17,709 --> 00:03:21,069
we're pretty proud of the fact that you

00:03:19,510 --> 00:03:22,870
know we came in top on this survey with

00:03:21,069 --> 00:03:27,099
79 percent of people who use Russ

00:03:22,870 --> 00:03:29,019
still want to use rust and that's

00:03:27,099 --> 00:03:31,930
basically the kind of numbers we like to

00:03:29,019 --> 00:03:33,250
see but not only do we have people who

00:03:31,930 --> 00:03:35,170
are surveyed but we've also had a lot of

00:03:33,250 --> 00:03:37,239
adoption coming out of industry as well

00:03:35,170 --> 00:03:39,819
so this is a little video of our friends

00:03:37,239 --> 00:03:41,939
page as of a little while back and I'm

00:03:39,819 --> 00:03:43,930
kind of awkwardly scrolling through it

00:03:41,939 --> 00:03:45,189
I'd like to know how to do this better

00:03:43,930 --> 00:03:50,709
someone should really talk to me about

00:03:45,189 --> 00:03:52,720
it but there you go and I think there

00:03:50,709 --> 00:03:56,560
were 35 or 36 companies there at the

00:03:52,720 --> 00:03:57,819
time and now finally there's also just

00:03:56,560 --> 00:04:00,010
been an explosion in meetups and

00:03:57,819 --> 00:04:02,079
conferences as I already mentioned so we

00:04:00,010 --> 00:04:03,879
have something like 80 meetups around

00:04:02,079 --> 00:04:06,969
the world with thousands and thousands

00:04:03,879 --> 00:04:07,989
of members sure meeting regularly so

00:04:06,969 --> 00:04:09,969
very cool

00:04:07,989 --> 00:04:14,769
I'm gonna hand it over to Aaron now to

00:04:09,969 --> 00:04:16,239
talk about 2017 thanks Nico yeah and I

00:04:14,769 --> 00:04:17,949
just I want to say in terms of other

00:04:16,239 --> 00:04:20,019
things that we've managed to not mess up

00:04:17,949 --> 00:04:22,570
I think one of the most exciting aspects

00:04:20,019 --> 00:04:24,430
is the rust community so we heard with

00:04:22,570 --> 00:04:26,080
the opening yesterday about the

00:04:24,430 --> 00:04:27,820
importance of being welcoming and I

00:04:26,080 --> 00:04:29,919
think as the community has grown I've

00:04:27,820 --> 00:04:31,900
been extremely encouraged to see that

00:04:29,919 --> 00:04:33,849
it's keeping all of these values central

00:04:31,900 --> 00:04:36,610
which is pretty amazing so keep up the

00:04:33,849 --> 00:04:39,820
good work okay but now time for some

00:04:36,610 --> 00:04:41,860
prognostication so everybody's eager to

00:04:39,820 --> 00:04:43,599
hear you know what are our plans for the

00:04:41,860 --> 00:04:45,729
next year and one of the nice things

00:04:43,599 --> 00:04:48,220
about doing development in the open as

00:04:45,729 --> 00:04:49,509
we do with rust is that we get to talk

00:04:48,220 --> 00:04:51,400
about this all as a community and

00:04:49,509 --> 00:04:53,199
actually chart out a course together so

00:04:51,400 --> 00:04:55,210
we don't in fact need a crystal ball to

00:04:53,199 --> 00:04:58,659
figure out where rust is headed we're

00:04:55,210 --> 00:05:01,449
gonna do it together so if you've been

00:04:58,659 --> 00:05:02,830
following rust and development in the

00:05:01,449 --> 00:05:04,419
last couple months you might have heard

00:05:02,830 --> 00:05:05,740
about a new process that we're rolling

00:05:04,419 --> 00:05:08,259
out starting in

00:05:05,740 --> 00:05:10,990
18 which is to actually have a formal

00:05:08,259 --> 00:05:14,199
roadmap for the language right so the

00:05:10,990 --> 00:05:16,990
idea is every year we will go through

00:05:14,199 --> 00:05:20,380
this exercise as a community will gather

00:05:16,990 --> 00:05:22,630
data to sort of figure out where the key

00:05:20,380 --> 00:05:23,530
problems are what kinds of things we

00:05:22,630 --> 00:05:25,300
want to solve with the language that

00:05:23,530 --> 00:05:27,789
year and then we'll work together to

00:05:25,300 --> 00:05:29,259
come up with some basic goals things

00:05:27,789 --> 00:05:34,180
that we want to achieve as a community

00:05:29,259 --> 00:05:36,819
in that year so in terms of you know

00:05:34,180 --> 00:05:38,949
discovering problems we have a few

00:05:36,819 --> 00:05:41,259
different ways of gathering that data so

00:05:38,949 --> 00:05:42,789
we sent out a survey which I'll talk

00:05:41,259 --> 00:05:44,710
about a bit later

00:05:42,789 --> 00:05:46,990
we've also the community team has been

00:05:44,710 --> 00:05:48,880
reaching out to companies that are using

00:05:46,990 --> 00:05:50,770
rest or want to use rust to figure out

00:05:48,880 --> 00:05:53,110
where their problems are where they'd

00:05:50,770 --> 00:05:54,970
like to see rust grow and of course we

00:05:53,110 --> 00:05:57,789
just have you know conversations amongst

00:05:54,970 --> 00:06:00,669
ourselves as as a community as we're

00:05:57,789 --> 00:06:02,500
doing outreach and so on so once we've

00:06:00,669 --> 00:06:05,349
got these problems laid out that we want

00:06:02,500 --> 00:06:07,389
to solve then we need to execute and so

00:06:05,349 --> 00:06:09,280
the idea is gonna be that every six

00:06:07,389 --> 00:06:11,770
weeks which is synchronised with our

00:06:09,280 --> 00:06:14,860
release cycle the various rust teams

00:06:11,770 --> 00:06:17,259
will sort of do a sprint so they lay out

00:06:14,860 --> 00:06:20,530
in this six weeks what are we going to

00:06:17,259 --> 00:06:22,360
do to move the ball forward on these

00:06:20,530 --> 00:06:24,460
yearly goals that we've laid out right

00:06:22,360 --> 00:06:25,990
and this is really exciting because I

00:06:24,460 --> 00:06:27,729
think I've heard from a lot of people

00:06:25,990 --> 00:06:29,830
you know there's so much going on in

00:06:27,729 --> 00:06:31,570
rust it's really hard to tell you know

00:06:29,830 --> 00:06:33,130
to sort of keep on top of it and it held

00:06:31,570 --> 00:06:35,889
what are the most important stuff right

00:06:33,130 --> 00:06:37,389
so these yearly goals are the most

00:06:35,889 --> 00:06:38,949
important things we're targeting but

00:06:37,389 --> 00:06:40,810
then these six week Sprint's give you a

00:06:38,949 --> 00:06:43,630
sense for you know if I want to get

00:06:40,810 --> 00:06:45,400
involved as I volunteer where do I go

00:06:43,630 --> 00:06:47,919
how can I actually help out with these

00:06:45,400 --> 00:06:49,930
efforts so all of that will be surface

00:06:47,919 --> 00:06:52,770
probably and github some easy to find

00:06:49,930 --> 00:06:55,110
way and that'll be starting in 2017

00:06:52,770 --> 00:06:58,289
and then fine the final piece of this

00:06:55,110 --> 00:07:00,060
which I think is really important is we

00:06:58,289 --> 00:07:02,639
want to tell this story to the broader

00:07:00,060 --> 00:07:04,139
world right so you know if we as a

00:07:02,639 --> 00:07:05,849
community have a hard time following

00:07:04,139 --> 00:07:07,169
everything that's happening in rust and

00:07:05,849 --> 00:07:09,090
the people outside of this community

00:07:07,169 --> 00:07:11,610
have an even harder time what's you know

00:07:09,090 --> 00:07:13,770
following the story of rust so the idea

00:07:11,610 --> 00:07:15,690
here is at the end of the year and when

00:07:13,770 --> 00:07:18,150
we finished this process we put together

00:07:15,690 --> 00:07:19,710
a big retrospective that says as a

00:07:18,150 --> 00:07:21,449
community you know what did we do what

00:07:19,710 --> 00:07:23,310
was the story of rust this year how did

00:07:21,449 --> 00:07:25,500
it evolve what is the state of our

00:07:23,310 --> 00:07:27,810
ecosystem how do you dive into rust and

00:07:25,500 --> 00:07:30,000
so you know on yearly increments the

00:07:27,810 --> 00:07:31,919
world gets to hear about rusts evolution

00:07:30,000 --> 00:07:34,229
in a very clear way so I'm really

00:07:31,919 --> 00:07:35,789
excited about this process and we've

00:07:34,229 --> 00:07:38,400
already started taking a number of steps

00:07:35,789 --> 00:07:40,080
toward it okay so with that overview let

00:07:38,400 --> 00:07:43,860
me dive into a little bit more of the

00:07:40,080 --> 00:07:47,310
specifics so I mentioned you know that

00:07:43,860 --> 00:07:49,319
we sent out a survey and got actually

00:07:47,310 --> 00:07:50,909
tremendous response to it more than I

00:07:49,319 --> 00:07:53,430
think any of us anticipated so we had

00:07:50,909 --> 00:07:56,669
over 3,000 respondents to the survey and

00:07:53,430 --> 00:07:59,190
the survey was targeted at both people

00:07:56,669 --> 00:08:00,900
who currently use rust have used rust in

00:07:59,190 --> 00:08:02,310
the past but are no longer using it or

00:08:00,900 --> 00:08:04,110
people who've never used rust right we

00:08:02,310 --> 00:08:06,180
were interested to hear from all of

00:08:04,110 --> 00:08:07,919
those different camps so the chart at

00:08:06,180 --> 00:08:09,690
the bottom you know shows basically

00:08:07,919 --> 00:08:12,150
people the breakdown and people actively

00:08:09,690 --> 00:08:14,070
using rust versus not so about a third

00:08:12,150 --> 00:08:16,469
of the respondents are not using rust

00:08:14,070 --> 00:08:17,909
which is great that's that gives us a

00:08:16,469 --> 00:08:20,820
lot of insight into what it's gonna take

00:08:17,909 --> 00:08:22,139
to grow rusts adoption you know what are

00:08:20,820 --> 00:08:25,680
the blockers to people actually picking

00:08:22,139 --> 00:08:27,900
it up okay so what what did we hear out

00:08:25,680 --> 00:08:32,370
of this survey so we got a number of

00:08:27,900 --> 00:08:34,500
challenges by far the clearest cut one

00:08:32,370 --> 00:08:36,149
is that rust has a steep learning curve

00:08:34,500 --> 00:08:37,800
I don't think this comes as a surprise

00:08:36,149 --> 00:08:40,380
to anybody in this room that's

00:08:37,800 --> 00:08:42,450
definitely you know part of the the meme

00:08:40,380 --> 00:08:45,000
around rust right now and the feeling

00:08:42,450 --> 00:08:47,010
generally is it's worth it right you get

00:08:45,000 --> 00:08:49,380
through those couple of weeks fighting

00:08:47,010 --> 00:08:51,240
the borrow checker it's hard but then

00:08:49,380 --> 00:08:53,579
once you're over that hump it's worth it

00:08:51,240 --> 00:08:55,779
right but how many people do we end up

00:08:53,579 --> 00:09:00,699
losing in those first couple of weeks

00:08:55,779 --> 00:09:01,779
right can we fix this okay so that one

00:09:00,699 --> 00:09:04,329
in four respondents talked about the

00:09:01,779 --> 00:09:06,610
learning curve again unsurprisingly

00:09:04,329 --> 00:09:08,079
given how early we are in the language

00:09:06,610 --> 00:09:10,149
development a lot of people are talking

00:09:08,079 --> 00:09:12,279
about rust doesn't have enough libraries

00:09:10,149 --> 00:09:14,199
it's not covering my needs right so this

00:09:12,279 --> 00:09:16,180
is this is expected but it's good to see

00:09:14,199 --> 00:09:18,639
it sort of quantitatively showing up in

00:09:16,180 --> 00:09:20,019
the survey and then on a similar note a

00:09:18,639 --> 00:09:22,029
lot of people talked about just the

00:09:20,019 --> 00:09:23,100
general maturity of the language the

00:09:22,029 --> 00:09:25,209
tooling and so on

00:09:23,100 --> 00:09:26,829
wanting rust to be more mature before

00:09:25,209 --> 00:09:30,639
they felt comfortable trying to use it

00:09:26,829 --> 00:09:33,579
in production for example okay next one

00:09:30,639 --> 00:09:35,040
came as I think a surprise to many of

00:09:33,579 --> 00:09:39,759
the core developers since we're all

00:09:35,040 --> 00:09:42,819
Emacs users at least the proper ones but

00:09:39,759 --> 00:09:46,029
it turns out a lot of people love II's a

00:09:42,819 --> 00:09:47,769
lot of people depend on IDs for their

00:09:46,029 --> 00:09:49,809
core workflow a lot of companies

00:09:47,769 --> 00:09:52,120
basically across the board use IDs and

00:09:49,809 --> 00:09:53,829
so for many people it's just a total

00:09:52,120 --> 00:09:55,959
non-starter to say pick up this language

00:09:53,829 --> 00:09:58,569
that doesn't have a good IDE experience

00:09:55,959 --> 00:10:00,490
and so they're you know that was

00:09:58,569 --> 00:10:02,920
mentioned in one in nineteen respondents

00:10:00,490 --> 00:10:05,699
overall but I think most importantly if

00:10:02,920 --> 00:10:08,110
you look at that you know third chunk of

00:10:05,699 --> 00:10:11,410
people who aren't actually using Rusted

00:10:08,110 --> 00:10:13,269
a one-in-four cited ITES as an important

00:10:11,410 --> 00:10:16,689
reason right so this is this is a huge

00:10:13,269 --> 00:10:19,089
challenge and then everybody knows the

00:10:16,689 --> 00:10:21,069
compiler could be a little faster and

00:10:19,089 --> 00:10:22,540
this is especially important as you do

00:10:21,069 --> 00:10:24,430
try to use rest in production it's the

00:10:22,540 --> 00:10:28,240
number one complaint we hear from all of

00:10:24,430 --> 00:10:30,279
our production users so I don't think

00:10:28,240 --> 00:10:33,730
any of these challenges come as a great

00:10:30,279 --> 00:10:37,029
surprise but I think there are some

00:10:33,730 --> 00:10:40,029
interesting themes here right so if you

00:10:37,029 --> 00:10:43,029
you know or like Nikko or me you're you

00:10:40,029 --> 00:10:44,319
know sort of bred to do language design

00:10:43,029 --> 00:10:46,149
right would come from this academic

00:10:44,319 --> 00:10:47,679
background and so we're eager to like

00:10:46,149 --> 00:10:48,910
build more language features and make

00:10:47,679 --> 00:10:51,429
the language richer and so on it's very

00:10:48,910 --> 00:10:52,959
tempting to focus on that stuff but

00:10:51,429 --> 00:10:56,499
really none of these challenges are

00:10:52,959 --> 00:10:58,420
about making the language nicer you know

00:10:56,499 --> 00:11:00,459
from like academic design perspective

00:10:58,420 --> 00:11:03,370
what they're really all about is

00:11:00,459 --> 00:11:05,679
productivity people want to people see

00:11:03,370 --> 00:11:07,240
the potential value in rust but they're

00:11:05,679 --> 00:11:09,160
worried about being productive

00:11:07,240 --> 00:11:10,720
they're worried about learning it

00:11:09,160 --> 00:11:12,819
quickly they're wearing worried about

00:11:10,720 --> 00:11:14,589
you know mature libraries that have

00:11:12,819 --> 00:11:17,470
their backdoor IDs that may make them

00:11:14,589 --> 00:11:19,209
productive right so there are a lot of

00:11:17,470 --> 00:11:22,149
different ways to think about

00:11:19,209 --> 00:11:24,339
productivity right so here I just have a

00:11:22,149 --> 00:11:27,160
few different questions that are related

00:11:24,339 --> 00:11:29,259
to productivity and you know I don't

00:11:27,160 --> 00:11:30,639
want to say that rust is completely

00:11:29,259 --> 00:11:33,850
unproductive I mean some of these things

00:11:30,639 --> 00:11:37,660
we actually do really well right so if

00:11:33,850 --> 00:11:39,759
you want to write correct code rust is a

00:11:37,660 --> 00:11:41,139
very productive way to do that compared

00:11:39,759 --> 00:11:43,449
to a lot of other languages right

00:11:41,139 --> 00:11:45,490
because it the compiler has your back

00:11:43,449 --> 00:11:47,079
across you know so many different issues

00:11:45,490 --> 00:11:49,540
the standard library is built very

00:11:47,079 --> 00:11:51,879
carefully to guide you to the the right

00:11:49,540 --> 00:11:53,740
kinds of patterns right similarly if you

00:11:51,879 --> 00:11:55,389
want to write code that's fast rust is a

00:11:53,740 --> 00:11:57,730
much more productive way to do that than

00:11:55,389 --> 00:11:59,619
many other languages okay so so we get

00:11:57,730 --> 00:12:01,449
some of that right but then some of

00:11:59,619 --> 00:12:04,209
these other questions don't really sound

00:12:01,449 --> 00:12:06,160
like rust today right how quickly can I

00:12:04,209 --> 00:12:07,869
start writing real code well there's

00:12:06,160 --> 00:12:09,429
that learning curve with the borrow

00:12:07,869 --> 00:12:12,220
checker that we all sort of are familiar

00:12:09,429 --> 00:12:14,290
with if you're you know at a company

00:12:12,220 --> 00:12:15,970
that wants to start spinning up use of

00:12:14,290 --> 00:12:18,970
rust how long is it gonna take you to

00:12:15,970 --> 00:12:21,730
train up a team right can you use rust

00:12:18,970 --> 00:12:23,199
to prototype does that make sense all

00:12:21,730 --> 00:12:25,569
right so I think these are really

00:12:23,199 --> 00:12:28,629
important questions for driving rust

00:12:25,569 --> 00:12:31,149
adoption and I think it's tempting to

00:12:28,629 --> 00:12:33,939
imagine that rust is just inherently

00:12:31,149 --> 00:12:36,100
going to be bad at these things compared

00:12:33,939 --> 00:12:38,559
to some of the others right because rust

00:12:36,100 --> 00:12:41,410
has this emphasis on safety on

00:12:38,559 --> 00:12:43,119
reliability on performance and so it's

00:12:41,410 --> 00:12:44,589
easy to think that well those things

00:12:43,119 --> 00:12:47,170
fundamentally come at a cost

00:12:44,589 --> 00:12:49,839
right that it's gonna be harder it's

00:12:47,170 --> 00:12:51,339
going to be slower right so you might

00:12:49,839 --> 00:12:54,579
think that this is this is just an

00:12:51,339 --> 00:12:55,899
inherent trade-off but I want to tell

00:12:54,579 --> 00:12:59,319
you something about trade-offs alright

00:12:55,899 --> 00:13:02,350
so here's a slide from last year's rust

00:12:59,319 --> 00:13:04,990
camp where we tried to really articulate

00:13:02,350 --> 00:13:07,390
what rust 1.0 represented what were the

00:13:04,990 --> 00:13:10,540
some of the core ideas behind rusts

00:13:07,390 --> 00:13:13,510
and the theme here each and every one of

00:13:10,540 --> 00:13:15,940
these lines is talking about what seems

00:13:13,510 --> 00:13:18,910
to be a fundamental trade-off that rust

00:13:15,940 --> 00:13:21,520
overcomes right so you might think that

00:13:18,910 --> 00:13:23,500
if you want safety in a language you

00:13:21,520 --> 00:13:25,330
have to have a garbage collector Russ

00:13:23,500 --> 00:13:28,270
says no actually you can have both at

00:13:25,330 --> 00:13:29,410
the same time you might think that if

00:13:28,270 --> 00:13:31,090
you want to do concurrent programming

00:13:29,410 --> 00:13:33,820
you're gonna have to cope with databases

00:13:31,090 --> 00:13:36,220
and Russ says no actually we can do both

00:13:33,820 --> 00:13:38,110
at the same time right and so the

00:13:36,220 --> 00:13:40,690
overall message is that as a community

00:13:38,110 --> 00:13:42,520
we're actually really good at rethinking

00:13:40,690 --> 00:13:43,750
these trade-offs at overcoming them we

00:13:42,520 --> 00:13:46,780
know how to have our cake and eat it too

00:13:43,750 --> 00:13:49,780
and so I think the challenge of this

00:13:46,780 --> 00:13:52,390
year for rust is to start thinking about

00:13:49,780 --> 00:13:55,420
productivity as a core value of rust

00:13:52,390 --> 00:13:59,110
that's on the same level as speed and

00:13:55,420 --> 00:14:01,450
reliability right so I want personally

00:13:59,110 --> 00:14:03,220
at the end of 2017 to be able to claim

00:14:01,450 --> 00:14:05,290
this as a slogan that really applies to

00:14:03,220 --> 00:14:06,700
rusts and I think we're well positioned

00:14:05,290 --> 00:14:10,060
to start overcoming some of these

00:14:06,700 --> 00:14:11,830
trade-offs so with that said the rest of

00:14:10,060 --> 00:14:14,200
this talk what we're gonna do is look at

00:14:11,830 --> 00:14:17,140
each of the areas of development in rust

00:14:14,200 --> 00:14:20,170
each of this sort of teams within rust

00:14:17,140 --> 00:14:22,450
and think about how those teams can can

00:14:20,170 --> 00:14:24,670
contribute basically to the push toward

00:14:22,450 --> 00:14:27,000
productivity the rest starting with the

00:14:24,670 --> 00:14:27,000
language

00:14:27,450 --> 00:14:32,580
all right so let's see so we want to

00:14:29,940 --> 00:14:35,310
talk about what changes should we think

00:14:32,580 --> 00:14:36,840
about for the language in order to

00:14:35,310 --> 00:14:39,030
really focus on productivity and as

00:14:36,840 --> 00:14:39,930
Aaron said I think a lot of times when

00:14:39,030 --> 00:14:42,840
we think about the language we think

00:14:39,930 --> 00:14:44,610
about major new features but there might

00:14:42,840 --> 00:14:46,110
be some kind of different ways we can

00:14:44,610 --> 00:14:49,710
look at it different places we can tweak

00:14:46,110 --> 00:14:52,740
and if we look what does rust do really

00:14:49,710 --> 00:14:54,810
well today there is a lot that we do

00:14:52,740 --> 00:14:56,280
great right and I think you can say what

00:14:54,810 --> 00:14:58,470
do people really like using about rust

00:14:56,280 --> 00:15:00,390
in terms of what I like using about rust

00:14:58,470 --> 00:15:02,910
is this sort of feeling I get that like

00:15:00,390 --> 00:15:04,260
galactic power right I can just throw

00:15:02,910 --> 00:15:06,090
out a few lines and I'm like a magician

00:15:04,260 --> 00:15:08,130
and I just kind of say what I want and I

00:15:06,090 --> 00:15:09,540
get not only is the code kind of pretty

00:15:08,130 --> 00:15:12,390
and does what I wanted to say pretty

00:15:09,540 --> 00:15:13,680
concise but it also actually executes

00:15:12,390 --> 00:15:16,110
really fast I don't have to go rewrite

00:15:13,680 --> 00:15:17,850
it later to do it the fast way or

00:15:16,110 --> 00:15:19,530
something like that right so I can write

00:15:17,850 --> 00:15:23,790
an iterator that finds the longest line

00:15:19,530 --> 00:15:25,440
and and it works I can make that

00:15:23,790 --> 00:15:29,220
iterator run in parallel using round

00:15:25,440 --> 00:15:31,230
which I'll talk about later um or you

00:15:29,220 --> 00:15:33,030
know using some of this upcoming futures

00:15:31,230 --> 00:15:36,240
and Tokyo work

00:15:33,030 --> 00:15:38,280
I could send RPC requests to servers and

00:15:36,240 --> 00:15:41,070
get responses and have all of that be

00:15:38,280 --> 00:15:42,810
handled both simply but also efficiently

00:15:41,070 --> 00:15:43,860
all right and if we look at this chart

00:15:42,810 --> 00:15:46,110
you can kind of see what I mean by

00:15:43,860 --> 00:15:47,460
efficiently this comes from I think it

00:15:46,110 --> 00:15:50,010
was Aaron's blog post right there named

00:15:47,460 --> 00:15:52,800
Alex's blog post a while back measuring

00:15:50,010 --> 00:15:54,090
the performance of hello world requests

00:15:52,800 --> 00:15:55,620
on the server so kind of a baseline

00:15:54,090 --> 00:15:57,900
performance how many requests can you

00:15:55,620 --> 00:16:00,600
process per second and we see that rust

00:15:57,900 --> 00:16:02,580
comes in here right the biggest bar but

00:16:00,600 --> 00:16:04,560
if you think back to before there was

00:16:02,580 --> 00:16:06,480
rust and you were to say here's a chart

00:16:04,560 --> 00:16:07,830
of different servers and I can tell you

00:16:06,480 --> 00:16:09,150
that one of them is implemented in the

00:16:07,830 --> 00:16:11,400
language with the strongest safety

00:16:09,150 --> 00:16:14,160
guarantees using abstractions all the

00:16:11,400 --> 00:16:15,840
way down to the as far down as we could

00:16:14,160 --> 00:16:17,520
get them kind of in the most idiomatic

00:16:15,840 --> 00:16:19,470
style you probably wouldn't have guessed

00:16:17,520 --> 00:16:20,490
oh it must be the fastest one you would

00:16:19,470 --> 00:16:23,040
have thought oh that's the one down

00:16:20,490 --> 00:16:24,810
there that's the slow one but it's not

00:16:23,040 --> 00:16:27,000
the case right we turned that that trade

00:16:24,810 --> 00:16:30,240
off and just kind of made it go away

00:16:27,000 --> 00:16:33,600
and I think that that emphasis on things

00:16:30,240 --> 00:16:36,390
being reliable and fast you can see it

00:16:33,600 --> 00:16:37,830
even in small fragments of Rusco and its

00:16:36,390 --> 00:16:40,530
really nice so here's a little bit of

00:16:37,830 --> 00:16:42,030
Russ code a kind of simplistic one it

00:16:40,530 --> 00:16:44,190
takes a name and prints it out it says

00:16:42,030 --> 00:16:46,920
it greets the user by name right but

00:16:44,190 --> 00:16:48,690
even here you see that okay maybe the

00:16:46,920 --> 00:16:50,460
user has declined to provide a name or

00:16:48,690 --> 00:16:52,530
we don't have one so to represent that

00:16:50,460 --> 00:16:54,360
we use an option type instead of like a

00:16:52,530 --> 00:16:55,650
null pointer and that means that when we

00:16:54,360 --> 00:16:57,300
match on it we have to remember to

00:16:55,650 --> 00:17:00,510
handle this case that's nice

00:16:57,300 --> 00:17:03,360
so now we will not just throw an

00:17:00,510 --> 00:17:06,120
exception or something right and we also

00:17:03,360 --> 00:17:08,010
have up here we see that this is

00:17:06,120 --> 00:17:09,180
actually a reference to an option which

00:17:08,010 --> 00:17:10,980
is part of the ownership and borrowing

00:17:09,180 --> 00:17:14,130
system that lets us have data race

00:17:10,980 --> 00:17:15,750
freedom and lets us have not need to

00:17:14,130 --> 00:17:17,490
give the garbage collector to get safety

00:17:15,750 --> 00:17:19,110
so this is really cool and I could

00:17:17,490 --> 00:17:21,650
submit this code to the compiler and run

00:17:19,110 --> 00:17:24,449
it but I'm gonna have a slight problem

00:17:21,650 --> 00:17:27,690
alright there's this is error and it's a

00:17:24,449 --> 00:17:30,090
little bit irritating but it's it's okay

00:17:27,690 --> 00:17:31,860
we're experienced rest users mismatched

00:17:30,090 --> 00:17:35,160
types I know what to do

00:17:31,860 --> 00:17:37,470
the problem is right here I was matching

00:17:35,160 --> 00:17:38,940
on a name and treating it like it's an

00:17:37,470 --> 00:17:41,250
option but it's actually a reference to

00:17:38,940 --> 00:17:42,630
an option so I need a star so that I can

00:17:41,250 --> 00:17:45,150
match on what the reference refers to

00:17:42,630 --> 00:17:48,960
right no problem I'm gonna compile it

00:17:45,150 --> 00:17:50,970
now and now it's gonna work another

00:17:48,960 --> 00:17:52,980
problem okay that's a little annoying

00:17:50,970 --> 00:17:55,770
but I know what it is

00:17:52,980 --> 00:17:58,980
I can't move out of borrowed content the

00:17:55,770 --> 00:18:00,960
problem is here when I say some of n I'm

00:17:58,980 --> 00:18:03,180
taking ownership of the string that's

00:18:00,960 --> 00:18:04,830
inside the option but I've only borrowed

00:18:03,180 --> 00:18:06,240
this option I can't take ownership of

00:18:04,830 --> 00:18:08,610
something I borrowed so I have to put

00:18:06,240 --> 00:18:10,050
ref to kind of tell the compiler no I

00:18:08,610 --> 00:18:12,120
want to borrow the string that's inside

00:18:10,050 --> 00:18:14,190
the option and now my code is gonna work

00:18:12,120 --> 00:18:16,170
right and this is something that

00:18:14,190 --> 00:18:18,750
probably every experience bus program

00:18:16,170 --> 00:18:20,310
has experienced on a daily basis and

00:18:18,750 --> 00:18:22,110
it's not that big a deal when you kind

00:18:20,310 --> 00:18:23,970
of know the rules or it can feel like

00:18:22,110 --> 00:18:25,620
it's not that big a deal but if you're

00:18:23,970 --> 00:18:28,590
coming new to rest it's a whole other

00:18:25,620 --> 00:18:30,240
story right this is like possibly enough

00:18:28,590 --> 00:18:31,560
to say I can't even print a string on

00:18:30,240 --> 00:18:33,380
the screen with this language that's it

00:18:31,560 --> 00:18:37,000
I'm gonna go

00:18:33,380 --> 00:18:39,350
cohdon something else right and that's

00:18:37,000 --> 00:18:40,610
kind of what we'd like to change but the

00:18:39,350 --> 00:18:42,710
interesting thing about this is that if

00:18:40,610 --> 00:18:44,330
we can improve this and do it in the

00:18:42,710 --> 00:18:45,560
right way it's gonna benefit everyone

00:18:44,330 --> 00:18:47,570
right because even the experienced users

00:18:45,560 --> 00:18:51,830
also encountered this we've just kind of

00:18:47,570 --> 00:18:53,240
learned to move past it there are a

00:18:51,830 --> 00:18:55,910
bunch of examples that kind of fit in

00:18:53,240 --> 00:18:57,650
this mold right one that comes up a lot

00:18:55,910 --> 00:19:01,040
is handling how we handle string

00:18:57,650 --> 00:19:03,740
literals which is a very kind of

00:19:01,040 --> 00:19:05,180
accurate way to model how they work but

00:19:03,740 --> 00:19:06,590
in particular there are two string types

00:19:05,180 --> 00:19:08,330
right a string literal is statically

00:19:06,590 --> 00:19:09,800
allocated in the binary so it has a

00:19:08,330 --> 00:19:11,660
different type because it doesn't need

00:19:09,800 --> 00:19:13,700
to be freed it's an ampersand store

00:19:11,660 --> 00:19:15,710
versus capital string that represents a

00:19:13,700 --> 00:19:17,630
heap-allocated string buffer but the

00:19:15,710 --> 00:19:19,070
problem the end effect is when I write a

00:19:17,630 --> 00:19:21,560
little hollow world program like this

00:19:19,070 --> 00:19:22,970
you know I get this error right away and

00:19:21,560 --> 00:19:24,890
it has a lot of kind of confusing

00:19:22,970 --> 00:19:26,780
components to it and it might be enough

00:19:24,890 --> 00:19:28,370
to turn people off and I know that when

00:19:26,780 --> 00:19:30,110
I do tutorials this is literally the

00:19:28,370 --> 00:19:32,330
first thing I do right I said let's talk

00:19:30,110 --> 00:19:35,510
about hello world so that we can all get

00:19:32,330 --> 00:19:38,810
past the string thing and go on and

00:19:35,510 --> 00:19:40,040
that's a little unfortunate and there's

00:19:38,810 --> 00:19:41,480
another example that comes up a lot

00:19:40,040 --> 00:19:43,160
which has to do with the borrowing

00:19:41,480 --> 00:19:45,110
system all right so here I have a

00:19:43,160 --> 00:19:46,880
mutable reference to a map and I'm

00:19:45,110 --> 00:19:49,580
looking up a key in it and I'm doing

00:19:46,880 --> 00:19:52,130
something with this key and so long as

00:19:49,580 --> 00:19:53,870
I'm in this branch where I found it the

00:19:52,130 --> 00:19:55,850
the value in the map I have a reference

00:19:53,870 --> 00:19:57,770
in to the map the compiler is gonna

00:19:55,850 --> 00:19:59,330
prevent me from trying to mutate the map

00:19:57,770 --> 00:20:00,650
like insert new keys and that's a good

00:19:59,330 --> 00:20:03,020
thing because if I did that I'd probably

00:20:00,650 --> 00:20:04,700
crash my program and that kind of makes

00:20:03,020 --> 00:20:07,040
sense it's borrowed when it's borrowed I

00:20:04,700 --> 00:20:09,110
can't mutate it however on this other

00:20:07,040 --> 00:20:13,400
branch where there was nothing in the

00:20:09,110 --> 00:20:16,460
map I also can't mutate the map right

00:20:13,400 --> 00:20:18,620
and you get an error like this one and

00:20:16,460 --> 00:20:20,030
the problem here is not that there's a

00:20:18,620 --> 00:20:21,680
fundamental thing it's that the compiler

00:20:20,030 --> 00:20:23,030
is kind of over approximating it's not

00:20:21,680 --> 00:20:25,400
smart enough to realize oh on this

00:20:23,030 --> 00:20:27,470
branch there actually isn't any the map

00:20:25,400 --> 00:20:28,820
isn't really borrowed now this is sort

00:20:27,470 --> 00:20:30,440
of interesting because this constraint

00:20:28,820 --> 00:20:32,060
led us to some really cool API is like

00:20:30,440 --> 00:20:35,480
entry so I'm sort of happy it was there

00:20:32,060 --> 00:20:36,770
but I think it's time for it to go and a

00:20:35,480 --> 00:20:40,580
lot of the refactoring that we've done

00:20:36,770 --> 00:20:42,620
will make that possible so these little

00:20:40,580 --> 00:20:43,940
things that kind of add up right and

00:20:42,620 --> 00:20:44,850
there's a list this is some things I've

00:20:43,940 --> 00:20:47,700
heard about like

00:20:44,850 --> 00:20:49,650
about other things and in all of these

00:20:47,700 --> 00:20:52,260
cases I want to emphasize it's not that

00:20:49,650 --> 00:20:54,180
we just sort of didn't think about it

00:20:52,260 --> 00:20:55,590
or we made it harder on purpose or I

00:20:54,180 --> 00:20:57,330
don't know what but there's a real

00:20:55,590 --> 00:20:58,200
technical trade-offs involved right and

00:20:57,330 --> 00:21:01,020
it seems like there's like this

00:20:58,200 --> 00:21:03,120
tug-of-war between can we get precision

00:21:01,020 --> 00:21:06,240
and explicitness so that you don't make

00:21:03,120 --> 00:21:08,070
mistakes or can we make it easy but then

00:21:06,240 --> 00:21:09,840
maybe it's gonna be slow and so what we

00:21:08,070 --> 00:21:11,850
need to do when we think about these is

00:21:09,840 --> 00:21:13,380
not just say oh that's paper over it

00:21:11,850 --> 00:21:15,180
with some have a compiler or insert a

00:21:13,380 --> 00:21:16,860
bunch of coercion x' that are gonna

00:21:15,180 --> 00:21:19,140
allocate memory everywhere and kind of

00:21:16,860 --> 00:21:20,880
turn it into lose some of the great

00:21:19,140 --> 00:21:23,010
things about rust we need to find ways

00:21:20,880 --> 00:21:25,080
to preserve those things and solve these

00:21:23,010 --> 00:21:26,940
dilemmas right figure out where is it

00:21:25,080 --> 00:21:29,700
most important to keep the explicitness

00:21:26,940 --> 00:21:31,890
and where can we let it go and then

00:21:29,700 --> 00:21:35,430
we'll have like this happy dog running

00:21:31,890 --> 00:21:36,810
down this beach and so if we look there

00:21:35,430 --> 00:21:38,850
are a bunch of examples where we've done

00:21:36,810 --> 00:21:40,680
this successfully I think in the

00:21:38,850 --> 00:21:43,230
language and one of my favorites is the

00:21:40,680 --> 00:21:44,550
closure designer and that's partly

00:21:43,230 --> 00:21:46,560
because it was the first thing I worked

00:21:44,550 --> 00:21:47,730
on and rust five years ago and I'm still

00:21:46,560 --> 00:21:49,700
working on it

00:21:47,730 --> 00:21:52,350
or was until about a year ago and now

00:21:49,700 --> 00:21:54,120
that's a nice feeling it worked out

00:21:52,350 --> 00:21:55,950
pretty well right so closures are like

00:21:54,120 --> 00:21:57,330
this fundamental building block

00:21:55,950 --> 00:21:59,100
if you look here every one of these

00:21:57,330 --> 00:22:01,110
examples I gave you involved a closure

00:21:59,100 --> 00:22:04,320
or somewhere right and sometimes more

00:22:01,110 --> 00:22:05,850
than one and there's actually a pretty

00:22:04,320 --> 00:22:07,380
sophisticated model behind the scenes

00:22:05,850 --> 00:22:08,610
because closures have to accommodate all

00:22:07,380 --> 00:22:11,850
these use cases they have to work for

00:22:08,610 --> 00:22:13,320
sequential iterators parallel iterators

00:22:11,850 --> 00:22:15,240
which have different constraints because

00:22:13,320 --> 00:22:16,800
you have to prevent data races also work

00:22:15,240 --> 00:22:18,030
for futures which are again a different

00:22:16,800 --> 00:22:19,560
thing because you're kind of rolling up

00:22:18,030 --> 00:22:21,450
your stack frames and moving things into

00:22:19,560 --> 00:22:24,030
the heap and accommodating all of this

00:22:21,450 --> 00:22:26,370
with one abstraction took us a while and

00:22:24,030 --> 00:22:28,590
I think we did a really good job because

00:22:26,370 --> 00:22:30,000
using it feels very natural you sort of

00:22:28,590 --> 00:22:31,230
aren't aware of all the complexities

00:22:30,000 --> 00:22:35,160
necessarily when you just use these

00:22:31,230 --> 00:22:37,170
api's so for example here when I use a

00:22:35,160 --> 00:22:40,260
variable in a closure that comes from my

00:22:37,170 --> 00:22:41,820
surrounding environment the compiler

00:22:40,260 --> 00:22:43,830
actually has to decide am I gonna is

00:22:41,820 --> 00:22:45,720
that going to be a borrow a mutable

00:22:43,830 --> 00:22:47,280
borrow or is it taking ownership of this

00:22:45,720 --> 00:22:49,260
variable and the way it does that is by

00:22:47,280 --> 00:22:50,640
looking at how the variables used right

00:22:49,260 --> 00:22:52,500
so we can see well if you're going to

00:22:50,640 --> 00:22:53,799
call right string right string is going

00:22:52,500 --> 00:22:55,779
to need ownership of myself

00:22:53,799 --> 00:22:57,399
it that implies then that the closure

00:22:55,779 --> 00:22:59,499
must own my socket so that it can kind

00:22:57,399 --> 00:23:01,389
of thread the ownership through and that

00:22:59,499 --> 00:23:02,950
that just winds up feeling very natural

00:23:01,389 --> 00:23:05,289
you didn't have to write any annotations

00:23:02,950 --> 00:23:07,299
but you haven't actually removed

00:23:05,289 --> 00:23:08,679
explicitness from the program right you

00:23:07,299 --> 00:23:10,330
just didn't have to repeat yourself

00:23:08,679 --> 00:23:12,789
essentially the information was already

00:23:10,330 --> 00:23:14,200
there and I think we can apply similar

00:23:12,789 --> 00:23:16,929
principles to a lot of these examples

00:23:14,200 --> 00:23:19,480
right so in terms of this match example

00:23:16,929 --> 00:23:21,220
you could imagine that we automatically

00:23:19,480 --> 00:23:22,659
skip past references because there's

00:23:21,220 --> 00:23:24,039
really nothing else you can do but do

00:23:22,659 --> 00:23:26,799
you reference them when you match on

00:23:24,039 --> 00:23:28,480
them and then if we encounter this this

00:23:26,799 --> 00:23:30,190
variable and we can see how is it used

00:23:28,480 --> 00:23:33,970
and make the decision then is it going

00:23:30,190 --> 00:23:35,200
to be a reference or not so here we

00:23:33,970 --> 00:23:38,499
would just be printing it so we don't

00:23:35,200 --> 00:23:41,649
need ownership similarly we can make the

00:23:38,499 --> 00:23:43,059
capital string type potentially able to

00:23:41,649 --> 00:23:45,429
handle and understand the data might

00:23:43,059 --> 00:23:47,980
live might not need to be freed and then

00:23:45,429 --> 00:23:50,710
we can support coercion and just have

00:23:47,980 --> 00:23:52,690
this code work right and similarly down

00:23:50,710 --> 00:23:54,129
here we're already well underway here

00:23:52,690 --> 00:23:56,109
but we can make the compiler better able

00:23:54,129 --> 00:23:58,570
to understand control flow so that we

00:23:56,109 --> 00:24:00,369
can do inserts and so on and if we do

00:23:58,570 --> 00:24:02,080
this each of these little things may not

00:24:00,369 --> 00:24:03,669
be that big a deal but the end feeling

00:24:02,080 --> 00:24:05,559
me that the language feels very

00:24:03,669 --> 00:24:07,029
different overall right and the

00:24:05,559 --> 00:24:08,109
productivity the feeling of productivity

00:24:07,029 --> 00:24:09,669
I think will be sick stamps Lee

00:24:08,109 --> 00:24:12,970
increased not just the feeling I guess

00:24:09,669 --> 00:24:15,580
also the reality of it and so that's my

00:24:12,970 --> 00:24:17,889
my kind of overarching goal here is not

00:24:15,580 --> 00:24:19,059
necessarily any one of these changes but

00:24:17,889 --> 00:24:20,470
the idea that when we think about

00:24:19,059 --> 00:24:21,850
language changes let's not only think

00:24:20,470 --> 00:24:23,350
about how we can extend the language to

00:24:21,850 --> 00:24:26,019
do new things but how we can do all the

00:24:23,350 --> 00:24:30,519
things we do now better and easier and

00:24:26,019 --> 00:24:34,539
more productively fine well thanks Nico

00:24:30,519 --> 00:24:36,700
okay so what about libraries what does

00:24:34,539 --> 00:24:39,700
it mean for Russ libraries to be

00:24:36,700 --> 00:24:43,149
productive so I think taking a very

00:24:39,700 --> 00:24:46,090
broad view it's pretty simple right

00:24:43,149 --> 00:24:50,049
we need libraries for sort of common

00:24:46,090 --> 00:24:51,249
tasks that come up a lot to exist that's

00:24:50,049 --> 00:24:53,859
being out there somewhere

00:24:51,249 --> 00:24:56,350
they should be findable right you should

00:24:53,859 --> 00:24:57,940
be able to search for them and easily

00:24:56,350 --> 00:25:00,399
find your way through crates i/o or some

00:24:57,940 --> 00:25:02,619
other way and those libraries should be

00:25:00,399 --> 00:25:04,419
of high quality right if you're gonna be

00:25:02,619 --> 00:25:05,970
productive you need those libraries to

00:25:04,419 --> 00:25:07,080
actually work well

00:25:05,970 --> 00:25:08,640
of course I'm thinking of quality here

00:25:07,080 --> 00:25:10,670
in the same terms as what we were saying

00:25:08,640 --> 00:25:13,830
before so fast reliable and productive

00:25:10,670 --> 00:25:16,440
so that's a fairly simple overarching

00:25:13,830 --> 00:25:18,420
goal but what does it mean as a

00:25:16,440 --> 00:25:22,530
community to sort of focus on these

00:25:18,420 --> 00:25:24,440
three improvements so first of all let's

00:25:22,530 --> 00:25:28,830
talk about actually building libraries

00:25:24,440 --> 00:25:31,130
right so I think people generally know

00:25:28,830 --> 00:25:33,480
that rust standard library has taken

00:25:31,130 --> 00:25:35,070
minimalistic approach for a lot of

00:25:33,480 --> 00:25:38,460
reasons right so it's not really a

00:25:35,070 --> 00:25:40,610
batteries included style of a standard

00:25:38,460 --> 00:25:43,350
library and that's okay because we have

00:25:40,610 --> 00:25:45,390
great tooling with cargo and crates i/o

00:25:43,350 --> 00:25:47,760
so it's very easy to pull in lots of

00:25:45,390 --> 00:25:49,200
external libraries but those batteries

00:25:47,760 --> 00:25:51,000
even if they're not included in the

00:25:49,200 --> 00:25:52,890
standard library they do need to exist

00:25:51,000 --> 00:25:54,330
somewhere all right so the first thing I

00:25:52,890 --> 00:25:57,270
think we need to do as a community is

00:25:54,330 --> 00:25:59,850
figure out where the key gaps are and we

00:25:57,270 --> 00:26:02,010
can use things like the survey data or

00:25:59,850 --> 00:26:04,050
we can go look at you know other

00:26:02,010 --> 00:26:05,940
languages and sort of take the cross

00:26:04,050 --> 00:26:07,890
section of their batteries included

00:26:05,940 --> 00:26:10,260
standard libraries and so on

00:26:07,890 --> 00:26:12,480
so here are just a few ideas I think for

00:26:10,260 --> 00:26:15,210
some of the most obvious targets for

00:26:12,480 --> 00:26:16,980
this year so rust on the server has sort

00:26:15,210 --> 00:26:18,930
of already come up with with Tokyo and

00:26:16,980 --> 00:26:20,610
futures that work is well underway I

00:26:18,930 --> 00:26:22,950
think that's gonna be really important

00:26:20,610 --> 00:26:25,320
for production uses of rust but there's

00:26:22,950 --> 00:26:27,870
more work we can do on rust concurrency

00:26:25,320 --> 00:26:29,910
story really bringing it to fruition as

00:26:27,870 --> 00:26:32,550
well as a number of other areas all

00:26:29,910 --> 00:26:35,400
right so I think the the library team

00:26:32,550 --> 00:26:36,840
can sort of act as a coordinator between

00:26:35,400 --> 00:26:39,210
different sub communities working on

00:26:36,840 --> 00:26:42,060
these different areas and try to pull

00:26:39,210 --> 00:26:44,130
everybody together to to really you know

00:26:42,060 --> 00:26:48,870
bland 1.0 level libraries and a lot of

00:26:44,130 --> 00:26:50,520
these areas okay so so that would be

00:26:48,870 --> 00:26:52,140
sort of the first bullet actually making

00:26:50,520 --> 00:26:55,290
sure that libraries exist what about

00:26:52,140 --> 00:26:58,530
finding them so library discoverability

00:26:55,290 --> 00:27:00,390
is a little bit tricky because you want

00:26:58,530 --> 00:27:03,150
it to be easy to find the best libraries

00:27:00,390 --> 00:27:05,820
for a given task but defining what best

00:27:03,150 --> 00:27:09,270
means is obviously pretty subjective and

00:27:05,820 --> 00:27:11,930
there's a risk that you lock in sort of

00:27:09,270 --> 00:27:14,400
first-movers like the earliest library

00:27:11,930 --> 00:27:16,710
becomes the one that the search site

00:27:14,400 --> 00:27:17,580
gives you on the top and you sort of

00:27:16,710 --> 00:27:19,860
just Riaan

00:27:17,580 --> 00:27:22,400
it's status even though better libraries

00:27:19,860 --> 00:27:24,660
are coming down the pipe right so

00:27:22,400 --> 00:27:26,370
defining what it means to be best and

00:27:24,660 --> 00:27:28,500
and coming up with good metrics for

00:27:26,370 --> 00:27:30,510
search is really hard but I think it's

00:27:28,500 --> 00:27:31,950
really important for people to be able

00:27:30,510 --> 00:27:34,950
to find these high quality libraries

00:27:31,950 --> 00:27:37,560
easily so one thing we've been taking as

00:27:34,950 --> 00:27:39,840
some potential inspiration here is the

00:27:37,560 --> 00:27:41,970
ember ecosystem so there's a site called

00:27:39,840 --> 00:27:44,820
ember observer that has very carefully

00:27:41,970 --> 00:27:46,680
set up a bunch of metrics some objective

00:27:44,820 --> 00:27:49,140
things like you know downloads or github

00:27:46,680 --> 00:27:51,870
stars and then some more subjective

00:27:49,140 --> 00:27:53,850
things like actual curated reviews of

00:27:51,870 --> 00:27:54,930
libraries so I think we could do

00:27:53,850 --> 00:27:58,140
something similar to this

00:27:54,930 --> 00:28:00,180
within Craig's i/o similarly there's

00:27:58,140 --> 00:28:02,700
actually been work in the rust ecosystem

00:28:00,180 --> 00:28:04,020
to categorize libraries into different

00:28:02,700 --> 00:28:06,000
domains and I think we could put that

00:28:04,020 --> 00:28:07,740
together with a ranking system to make

00:28:06,000 --> 00:28:08,660
it much easier to find libraries for a

00:28:07,740 --> 00:28:11,850
given task

00:28:08,660 --> 00:28:13,440
what about quality so I think there are

00:28:11,850 --> 00:28:15,630
some steps we can take to improve

00:28:13,440 --> 00:28:18,120
quality across the board you may have

00:28:15,630 --> 00:28:21,090
seen the docs RS website that already

00:28:18,120 --> 00:28:23,160
came out which automatically provides

00:28:21,090 --> 00:28:24,930
documentation in a central place for

00:28:23,160 --> 00:28:27,060
everything on crates i/o this has been

00:28:24,930 --> 00:28:28,590
amazing for the ecosystem but there's

00:28:27,060 --> 00:28:30,780
more work we can do to improve the

00:28:28,590 --> 00:28:34,800
documentation experience another thing

00:28:30,780 --> 00:28:36,690
we can do is make it easier for projects

00:28:34,800 --> 00:28:40,740
to set up CI for example as part of

00:28:36,690 --> 00:28:43,710
cargo new or provide more elaborate

00:28:40,740 --> 00:28:45,170
testing framework so right now we have

00:28:43,710 --> 00:28:50,610
some built in testing and benchmarking

00:28:45,170 --> 00:28:52,080
in the rest in cargo but it's unstable

00:28:50,610 --> 00:28:53,970
and you can't actually build out new

00:28:52,080 --> 00:28:57,330
testing frameworks so we'd like to

00:28:53,970 --> 00:29:00,270
improve that as well and then finally

00:28:57,330 --> 00:29:03,750
we're we're looking at some sort of

00:29:00,270 --> 00:29:06,060
efforts to figure out how best to write

00:29:03,750 --> 00:29:08,580
unsafe code which is really crucial for

00:29:06,060 --> 00:29:10,430
these lower level libraries that are

00:29:08,580 --> 00:29:13,080
sort of the foundations of the ecosystem

00:29:10,430 --> 00:29:14,400
so giving guidelines to libraries offers

00:29:13,080 --> 00:29:17,310
us to how to do this

00:29:14,400 --> 00:29:19,440
is gonna be hugely important all right

00:29:17,310 --> 00:29:20,640
so um sort of being aware of time I'm

00:29:19,440 --> 00:29:22,410
going to skip ahead a little bit quicker

00:29:20,640 --> 00:29:24,570
here so that that was sort of the

00:29:22,410 --> 00:29:26,190
library story I think there's it's a big

00:29:24,570 --> 00:29:28,380
space there's a lot we can do

00:29:26,190 --> 00:29:30,630
but tooling is also extremely important

00:29:28,380 --> 00:29:34,080
and I think there's a lot to say about

00:29:30,630 --> 00:29:35,730
the tooling story but for today we're

00:29:34,080 --> 00:29:37,290
gonna focus on that most important

00:29:35,730 --> 00:29:38,550
bullet we saw from from the challenges

00:29:37,290 --> 00:29:42,660
which is the IDE

00:29:38,550 --> 00:29:44,190
experience so rust has made some

00:29:42,660 --> 00:29:46,320
progress on this front over the last

00:29:44,190 --> 00:29:48,900
year I'm probably a lot of you are

00:29:46,320 --> 00:29:50,280
familiar with or reviews racer which is

00:29:48,900 --> 00:29:52,160
you know a tool that can do things like

00:29:50,280 --> 00:29:56,700
autocomplete and a number of editors

00:29:52,160 --> 00:29:59,040
racer is really cool it's very fast but

00:29:56,700 --> 00:30:00,480
it works totally independently of the

00:29:59,040 --> 00:30:03,480
compiler right so this is based on

00:30:00,480 --> 00:30:05,190
heuristics and its own you know means of

00:30:03,480 --> 00:30:08,220
parsing out the programs that you're

00:30:05,190 --> 00:30:11,160
writing and but yeah but it covers

00:30:08,220 --> 00:30:14,130
autocomplete it coexists with lots of

00:30:11,160 --> 00:30:18,630
existing editors like Emax and Emin and

00:30:14,130 --> 00:30:20,640
so on there's also a rapidly maturing

00:30:18,630 --> 00:30:22,260
plugin for IntelliJ

00:30:20,640 --> 00:30:25,590
which takes a similar approach so

00:30:22,260 --> 00:30:27,930
IntelliJ in general has a very rich

00:30:25,590 --> 00:30:29,730
toolkit for building up IDs around

00:30:27,930 --> 00:30:32,010
languages but they're also sort of

00:30:29,730 --> 00:30:35,010
building their own compiler and in a

00:30:32,010 --> 00:30:36,840
sense right so that that allows them to

00:30:35,010 --> 00:30:38,580
get up to speed very quickly but I think

00:30:36,840 --> 00:30:40,320
in both cases you're somewhat limited in

00:30:38,580 --> 00:30:41,700
what you can do in terms of getting very

00:30:40,320 --> 00:30:43,650
precise information out of the RUS

00:30:41,700 --> 00:30:46,830
compiler so one of the things we're

00:30:43,650 --> 00:30:48,270
interested in exploring is a strategy

00:30:46,830 --> 00:30:50,340
that allows us to bring the compiler

00:30:48,270 --> 00:30:54,300
into the picture right so the idea the

00:30:50,340 --> 00:30:55,920
idea here is we have some IDE or editor

00:30:54,300 --> 00:30:57,900
sitting out there that's talking via

00:30:55,920 --> 00:30:59,550
some protocol to a central language

00:30:57,900 --> 00:31:02,520
service the Russ language service and

00:30:59,550 --> 00:31:04,200
that Russ language service is you know

00:31:02,520 --> 00:31:06,780
just a process running in the background

00:31:04,200 --> 00:31:08,430
that sort of knows something about your

00:31:06,780 --> 00:31:10,170
code and it's keeping things up to date

00:31:08,430 --> 00:31:12,930
and can answer questions from the IDS

00:31:10,170 --> 00:31:14,430
then that language service on the back

00:31:12,930 --> 00:31:16,650
end might be talking to things like

00:31:14,430 --> 00:31:18,180
racer to get answers quickly or it might

00:31:16,650 --> 00:31:21,330
be talking to the compiler to get things

00:31:18,180 --> 00:31:22,770
more precise so you know I think the

00:31:21,330 --> 00:31:23,370
best way to explain this is to actually

00:31:22,770 --> 00:31:25,740
show it

00:31:23,370 --> 00:31:28,410
you in action so actually this tool

00:31:25,740 --> 00:31:29,490
recently hit alpha Jonathan and Nick

00:31:28,410 --> 00:31:30,750
have been working on it a lot so

00:31:29,490 --> 00:31:33,590
Jonathan is going to come up and show

00:31:30,750 --> 00:31:33,590
you what it can do today

00:31:41,200 --> 00:31:47,940
in Congress out of time because I know

00:31:42,880 --> 00:31:51,220
what I think we're already over time so

00:31:47,940 --> 00:31:53,950
so this is it's not even healthier this

00:31:51,220 --> 00:31:55,270
is pre-alpha a truss cough just how

00:31:53,950 --> 00:31:58,540
quickly how many how many people with

00:31:55,270 --> 00:32:00,190
the rough call okay it's great so this

00:31:58,540 --> 00:32:03,520
first time that all of you may have seen

00:32:00,190 --> 00:32:05,620
this Russ cough we showed a demo of what

00:32:03,520 --> 00:32:09,220
this would be like this is the actual

00:32:05,620 --> 00:32:11,650
RLS running now so I can hover and when

00:32:09,220 --> 00:32:13,990
I hover I get type information this is

00:32:11,650 --> 00:32:16,120
again getting fed because we got racer

00:32:13,990 --> 00:32:17,560
and we have the compiler giving us these

00:32:16,120 --> 00:32:20,440
data sources and we can mix them

00:32:17,560 --> 00:32:22,390
together if we miss type something it

00:32:20,440 --> 00:32:23,380
comes back and says that's an error and

00:32:22,390 --> 00:32:27,280
if I hover the error

00:32:23,380 --> 00:32:29,350
it gives me what the error is and

00:32:27,280 --> 00:32:30,640
because it's pre-alpha we got all kinds

00:32:29,350 --> 00:32:34,690
of like little warnings but don't worry

00:32:30,640 --> 00:32:36,520
about that we can do you know like a

00:32:34,690 --> 00:32:39,820
final references I can see all the

00:32:36,520 --> 00:32:41,860
places that this thing is defined and

00:32:39,820 --> 00:32:44,500
used and if I have all of those

00:32:41,860 --> 00:32:46,300
locations that's awesome we can also do

00:32:44,500 --> 00:32:48,100
things like renaming we have perfect

00:32:46,300 --> 00:32:50,290
knowledge so if I wanted to call this

00:32:48,100 --> 00:32:53,110
position instead you see all the

00:32:50,290 --> 00:32:55,690
position paws became position but notice

00:32:53,110 --> 00:32:58,780
it's not textual so POS still say the

00:32:55,690 --> 00:33:01,510
same so we know exactly where that

00:32:58,780 --> 00:33:03,370
symbol is being used and we quickly

00:33:01,510 --> 00:33:05,200
again I know cognizant of time but I

00:33:03,370 --> 00:33:08,200
just want to show this real quick this

00:33:05,200 --> 00:33:11,410
is the cool power of open source so we

00:33:08,200 --> 00:33:12,970
did the RLS it worked on our laptops and

00:33:11,410 --> 00:33:14,770
we kind of put it out in the world and

00:33:12,970 --> 00:33:16,990
then let other people start banging on

00:33:14,770 --> 00:33:18,700
it and they've already ported it to

00:33:16,990 --> 00:33:21,760
Windows and have it working in Windows

00:33:18,700 --> 00:33:24,280
so this is the same experience that you

00:33:21,760 --> 00:33:27,570
have in the Linux and OS 10 world but

00:33:24,280 --> 00:33:27,570
now ported so it works in Windows

00:33:28,160 --> 00:33:36,279
[Applause]

00:33:42,229 --> 00:33:46,409
this is the most important part of the

00:33:44,460 --> 00:33:49,019
talk because this beautiful image is

00:33:46,409 --> 00:33:52,619
actually a fungus and it's the rust

00:33:49,019 --> 00:33:54,629
fungus which i think is a wonderful

00:33:52,619 --> 00:33:56,190
thing I didn't realize how how kind of

00:33:54,629 --> 00:33:59,009
attracted it would be when I went

00:33:56,190 --> 00:34:00,539
looking for it so there are a bunch of

00:33:59,009 --> 00:34:02,940
other teams and a lot of other efforts

00:34:00,539 --> 00:34:05,219
we focused on the language the libraries

00:34:02,940 --> 00:34:06,839
and the IDS sort of technical side but

00:34:05,219 --> 00:34:09,389
there's a lot of other things right we

00:34:06,839 --> 00:34:10,829
need one really important way to bring

00:34:09,389 --> 00:34:13,529
people up to speed is to focus on

00:34:10,829 --> 00:34:17,250
documentation and helping them learn in

00:34:13,529 --> 00:34:18,809
this side and similarly so the docs team

00:34:17,250 --> 00:34:20,940
is working on a kind of new approach to

00:34:18,809 --> 00:34:22,319
the book after having had some more

00:34:20,940 --> 00:34:24,119
experience with how people learn rust

00:34:22,319 --> 00:34:25,319
best and then we have the community team

00:34:24,119 --> 00:34:27,149
kind of collecting link learning

00:34:25,319 --> 00:34:28,260
materials working on rust bridge which I

00:34:27,149 --> 00:34:30,929
think we heard mentioned the number of

00:34:28,260 --> 00:34:32,520
times earlier and that's some in

00:34:30,929 --> 00:34:34,379
progress and of course the compiler team

00:34:32,520 --> 00:34:36,659
is trying to make all these technical

00:34:34,379 --> 00:34:38,700
things come to beat and make it go

00:34:36,659 --> 00:34:42,200
faster and have fewer bugs always a good

00:34:38,700 --> 00:34:45,000
thing so with that I'm gonna leave you

00:34:42,200 --> 00:34:47,460
just remember the slogan fast reliable

00:34:45,000 --> 00:34:48,340
productive pick three so thank you guys

00:34:47,460 --> 00:34:51,669
very much

00:34:48,340 --> 00:34:51,669

YouTube URL: https://www.youtube.com/watch?v=-XVIKSm8Rwg


