Title: Pest: Building a Language Server. Victor Lopez
Publication date: 2019-02-06
Playlist: RustRush 2018
Description: 
	Victor is a Brazilian ERP developer who currently works in Russia for the localization of a product. In his free time, he's a Rust enthusiast who aims to bring more companies to its benefits.

To build a language server, we need a very robust parser and some efficient JSON/RPC framework.
To achieve that, I used Pest (PEG-based) with a big TDD coverage for the parser, and Parity’s solution for the JSON/RPC interface.
Currently, I’m on beta; I expect to achieve a base of 10k users.
Captions: 
	00:00:02,600 --> 00:00:08,690
hello my name is Victor Lopez I work as

00:00:05,840 --> 00:00:10,520
a developer for the localization of our

00:00:08,690 --> 00:00:12,320
enterprise search planning software I'm

00:00:10,520 --> 00:00:14,660
going to talk today about the process of

00:00:12,320 --> 00:00:17,630
developing a language server with the

00:00:14,660 --> 00:00:19,790
Russ language so the main topics will be

00:00:17,630 --> 00:00:21,950
a first the describe briefly the

00:00:19,790 --> 00:00:23,720
language server protocol general talk

00:00:21,950 --> 00:00:26,059
about the rust language server that's

00:00:23,720 --> 00:00:28,610
one implementation of it and then I'm

00:00:26,059 --> 00:00:31,669
going to talk why I choose rust and how

00:00:28,610 --> 00:00:36,200
the process of developing this solution

00:00:31,669 --> 00:00:39,230
with rust so first what's the problem I

00:00:36,200 --> 00:00:42,280
had I have a proprietary language called

00:00:39,230 --> 00:00:45,530
adv pl it's a property of Toto's and

00:00:42,280 --> 00:00:47,780
it's consolidating in latin america but

00:00:45,530 --> 00:00:49,700
we're bringing a solution to russia and

00:00:47,780 --> 00:00:51,320
we don't have developers with it so we

00:00:49,700 --> 00:00:53,480
need to provide a solution that will

00:00:51,320 --> 00:00:55,400
support these developers and that this

00:00:53,480 --> 00:00:58,400
solution should provide the possibility

00:00:55,400 --> 00:01:00,350
to integrate with external components

00:00:58,400 --> 00:01:02,149
like the one application server that

00:01:00,350 --> 00:01:05,360
will communicate with some object

00:01:02,149 --> 00:01:07,220
storage the current protocol we are

00:01:05,360 --> 00:01:09,350
using for this communication is rest but

00:01:07,220 --> 00:01:11,300
could be any we can just implement on

00:01:09,350 --> 00:01:14,090
the language server and extend it and

00:01:11,300 --> 00:01:15,409
also check on the database so Mattamy

00:01:14,090 --> 00:01:18,620
information about the process of

00:01:15,409 --> 00:01:22,940
development this was the challenge and

00:01:18,620 --> 00:01:24,740
also we work with multiple IDs we have

00:01:22,940 --> 00:01:27,530
one Eclipse based IDE

00:01:24,740 --> 00:01:31,040
let's call TDs and one extension if yes

00:01:27,530 --> 00:01:32,530
code so for these we cannot for every

00:01:31,040 --> 00:01:35,840
implementation of the language server

00:01:32,530 --> 00:01:38,890
make one additional requirements on the

00:01:35,840 --> 00:01:40,850
solution for the language support and

00:01:38,890 --> 00:01:42,590
also the last challenge is the

00:01:40,850 --> 00:01:45,740
interaction with external objects it

00:01:42,590 --> 00:01:47,150
should be easily implemented and we can

00:01:45,740 --> 00:01:50,150
achieve this with the language server

00:01:47,150 --> 00:01:51,530
also the language server protocol whites

00:01:50,150 --> 00:01:54,680
good

00:01:51,530 --> 00:01:57,770
it's totally agnostic if we talk about

00:01:54,680 --> 00:02:01,040
the editor we are using so it means that

00:01:57,770 --> 00:02:02,990
it will work with VI with vyas code with

00:02:01,040 --> 00:02:06,799
Eclipse or whatever supports this

00:02:02,990 --> 00:02:11,209
protocol and the definition is open and

00:02:06,799 --> 00:02:13,159
very clear so it's open source work it's

00:02:11,209 --> 00:02:15,630
a very very booster nowadays that a lot

00:02:13,159 --> 00:02:18,240
of people is using so we have

00:02:15,630 --> 00:02:20,400
some fairly good results with it and I'd

00:02:18,240 --> 00:02:22,770
broadly use it though we have the major

00:02:20,400 --> 00:02:25,860
languages using this protocol for their

00:02:22,770 --> 00:02:27,960
implementations and with these we have a

00:02:25,860 --> 00:02:29,340
lot of situations already covered so it

00:02:27,960 --> 00:02:31,470
can count on this framework

00:02:29,340 --> 00:02:32,760
it's totally extensible design aesthetic

00:02:31,470 --> 00:02:34,910
see we have with this particular

00:02:32,760 --> 00:02:37,860
implementation to extend these

00:02:34,910 --> 00:02:40,530
functionalities to integration with

00:02:37,860 --> 00:02:42,450
other services and we have the classical

00:02:40,530 --> 00:02:45,210
M times n problem for the language

00:02:42,450 --> 00:02:47,310
support development it means that like

00:02:45,210 --> 00:02:49,290
if you have a given language you provide

00:02:47,310 --> 00:02:51,390
a functionality to support this language

00:02:49,290 --> 00:02:52,740
you have simple amenities functionality

00:02:51,390 --> 00:02:54,690
for the number of registers they are

00:02:52,740 --> 00:02:55,740
going to use instead with the language

00:02:54,690 --> 00:02:58,170
server you just implement the

00:02:55,740 --> 00:03:04,730
functionality I'm going to give a very

00:02:58,170 --> 00:03:04,730
quick demo on how it's working

00:03:09,750 --> 00:03:16,959
no here so here on the Left I have an

00:03:13,990 --> 00:03:22,390
implementation for the vs quote and on

00:03:16,959 --> 00:03:24,160
the right I'll show are the output that

00:03:22,390 --> 00:03:32,320
goes to the language server for every

00:03:24,160 --> 00:03:37,200
request we make second so I'm just going

00:03:32,320 --> 00:03:37,200
to tail the language server log

00:03:49,280 --> 00:03:51,310
ah

00:03:57,890 --> 00:04:02,720
okay and on the right I'm going to

00:04:00,680 --> 00:04:04,610
perform some operations with it so we're

00:04:02,720 --> 00:04:06,740
going to see for every operation perform

00:04:04,610 --> 00:04:09,230
that ID a communication based on the

00:04:06,740 --> 00:04:11,590
JSON RPC protocol to the language server

00:04:09,230 --> 00:04:13,990
I'm just dumping the information on the

00:04:11,590 --> 00:04:19,579
terminal so here we have the however

00:04:13,990 --> 00:04:22,180
some linting with I'm doing crashing the

00:04:19,579 --> 00:04:27,190
users to use single quotes in this case

00:04:22,180 --> 00:04:27,190
if we for example create a new file

00:04:27,730 --> 00:04:38,750
let's put the languages this one and I'm

00:04:35,870 --> 00:04:40,970
going to write here the classical hello

00:04:38,750 --> 00:04:49,100
world we can see all the interactions of

00:04:40,970 --> 00:04:50,840
the user with the IDE like being

00:04:49,100 --> 00:04:57,370
outputted on the server so going back to

00:04:50,840 --> 00:05:00,970
the presentation I will show briefly the

00:04:57,370 --> 00:05:00,970
architecture of this solution

00:05:07,590 --> 00:05:10,850
okay and just close

00:05:19,790 --> 00:05:24,249
so

00:05:21,879 --> 00:05:26,979
about that texture it's on the right

00:05:24,249 --> 00:05:28,649
it's every finger Jesus anticipated so

00:05:26,979 --> 00:05:30,999
for every interaction as I show to you

00:05:28,649 --> 00:05:33,039
we will send a request that language

00:05:30,999 --> 00:05:35,469
server and do expect a response if the

00:05:33,039 --> 00:05:37,779
request type is request or you can just

00:05:35,469 --> 00:05:39,789
work with notifications I quit foolin a

00:05:37,779 --> 00:05:41,050
file we expect no answer from the

00:05:39,789 --> 00:05:43,869
language server so it's a notification

00:05:41,050 --> 00:05:46,029
and if we ask for the command like the

00:05:43,869 --> 00:05:50,949
LinkedIn command we should expect one

00:05:46,029 --> 00:05:53,619
response language server who is using I

00:05:50,949 --> 00:05:56,830
bet all of you know at least two or

00:05:53,619 --> 00:05:59,830
three of these logos we have some very

00:05:56,830 --> 00:06:02,229
big implementations for this protocol

00:05:59,830 --> 00:06:06,039
like either for the editors like VI

00:06:02,229 --> 00:06:08,319
jetbrains or Eclipse Foundation and on

00:06:06,039 --> 00:06:13,059
the right we have the rust language we

00:06:08,319 --> 00:06:15,069
have the C++ Java go and so on about the

00:06:13,059 --> 00:06:18,819
the perspective for the language server

00:06:15,069 --> 00:06:22,179
protocol we see these as a possibility

00:06:18,819 --> 00:06:24,550
of bringing every of the support of

00:06:22,179 --> 00:06:26,079
languages as a service in this example I

00:06:24,550 --> 00:06:29,079
have one implementation for eclipse

00:06:26,079 --> 00:06:32,229
that's called che they support on the

00:06:29,079 --> 00:06:34,289
browser fully idea for ID you can easily

00:06:32,229 --> 00:06:38,499
implement our language support on these

00:06:34,289 --> 00:06:41,499
with the protocol if you just provide

00:06:38,499 --> 00:06:43,360
this extension Sudan so you have a fully

00:06:41,499 --> 00:06:46,180
integrated environment you can debug you

00:06:43,360 --> 00:06:48,599
can communicate with external services

00:06:46,180 --> 00:06:51,969
you can run tests with some daugher

00:06:48,599 --> 00:06:54,459
so it's quite powerful and it's

00:06:51,969 --> 00:06:55,899
currently available we also have the

00:06:54,459 --> 00:06:57,069
possibility of using some language

00:06:55,899 --> 00:06:58,569
telemetry

00:06:57,069 --> 00:06:59,949
this means that if we are going to

00:06:58,569 --> 00:07:01,539
change the behavior of that language

00:06:59,949 --> 00:07:04,860
like for us for example we're

00:07:01,539 --> 00:07:08,379
introducing the 2018 rust with some

00:07:04,860 --> 00:07:10,419
breaking changes like the async keyword

00:07:08,379 --> 00:07:12,819
we could understand that which projects

00:07:10,419 --> 00:07:15,669
are using this keyword and somehow

00:07:12,819 --> 00:07:17,589
interacts with this problem we also have

00:07:15,669 --> 00:07:20,409
some possibilities on CI that we have

00:07:17,589 --> 00:07:22,839
the current paradigmatic bases but we

00:07:20,409 --> 00:07:27,369
could interact with some for example

00:07:22,839 --> 00:07:29,079
static certain analysis and also we have

00:07:27,369 --> 00:07:31,599
the possibility of using some of the

00:07:29,079 --> 00:07:33,339
main specific languages to implement

00:07:31,599 --> 00:07:35,260
language server certain so not only for

00:07:33,339 --> 00:07:39,390
the developers

00:07:35,260 --> 00:07:41,920
systems but we could also specify the

00:07:39,390 --> 00:07:46,680
documentation of a company or any other

00:07:41,920 --> 00:07:46,680
even natural language with these support

00:07:47,310 --> 00:07:53,620
here we have one implementation Russ

00:07:50,200 --> 00:07:56,320
that's very good they presented these on

00:07:53,620 --> 00:07:58,600
Russ conference of 2016

00:07:56,320 --> 00:08:02,710
it's called zai I really like it because

00:07:58,600 --> 00:08:04,720
I'm big fan of the ISO somehow have

00:08:02,710 --> 00:08:06,310
these are match on the name it's fully

00:08:04,720 --> 00:08:08,200
implemented in rust and they only

00:08:06,310 --> 00:08:12,090
implemented the the back end

00:08:08,200 --> 00:08:15,550
it's a somehow supported by Google and

00:08:12,090 --> 00:08:17,680
open-source as well and they have one

00:08:15,550 --> 00:08:20,950
very strong pilot that's the performance

00:08:17,680 --> 00:08:24,040
so everything is a synchronous or on the

00:08:20,950 --> 00:08:27,580
base of these particular backends it's

00:08:24,040 --> 00:08:29,920
fully open source and it's there are

00:08:27,580 --> 00:08:32,710
some demonstrations on the github of

00:08:29,920 --> 00:08:34,750
these editor about the speed they can

00:08:32,710 --> 00:08:37,000
achieve alacrity alacrity is another

00:08:34,750 --> 00:08:39,790
Russ implementation for terminals uses

00:08:37,000 --> 00:08:42,010
GPU and it's fairly very good as well

00:08:39,790 --> 00:08:43,810
and we have also one brass

00:08:42,010 --> 00:08:46,120
implementation for the front end that

00:08:43,810 --> 00:08:50,140
will communicate with this editor

00:08:46,120 --> 00:08:54,280
that's called DXi it's based on getting

00:08:50,140 --> 00:08:56,260
care and also open source the github is

00:08:54,280 --> 00:09:01,570
there for the ones who are curious about

00:08:56,260 --> 00:09:05,050
this so as for the major supported

00:09:01,570 --> 00:09:07,570
editors for the rest language server now

00:09:05,050 --> 00:09:10,090
we have one resource called our we IDE

00:09:07,570 --> 00:09:11,560
yet for the ones that are familiar of

00:09:10,090 --> 00:09:13,570
the russ community we know that are

00:09:11,560 --> 00:09:16,570
several resources like this like are we

00:09:13,570 --> 00:09:18,670
game yet are we were yet and this is for

00:09:16,570 --> 00:09:21,360
IDs we have a follow up of the

00:09:18,670 --> 00:09:23,410
functionalities of the editors there and

00:09:21,360 --> 00:09:24,850
what are the expected are

00:09:23,410 --> 00:09:26,560
implementations and so on

00:09:24,850 --> 00:09:29,470
it's quite interesting for the ones who

00:09:26,560 --> 00:09:31,480
take a look my personal selection for

00:09:29,470 --> 00:09:33,310
the major players is that I Eclipse the

00:09:31,480 --> 00:09:35,890
corrosion that they provide the support

00:09:33,310 --> 00:09:39,940
for rust of yes code also have some set

00:09:35,890 --> 00:09:42,190
of extensions VI they also have a fairly

00:09:39,940 --> 00:09:44,710
good support it's my choice and

00:09:42,190 --> 00:09:47,770
JetBrains they are not the language at

00:09:44,710 --> 00:09:48,620
the rust language server user but they

00:09:47,770 --> 00:09:51,080
are implements

00:09:48,620 --> 00:09:53,360
support of their own to this language so

00:09:51,080 --> 00:09:57,380
this was their decision I flagged here

00:09:53,360 --> 00:09:59,000
as a not RLS user but there it's fair to

00:09:57,380 --> 00:10:02,230
mention them because I have a lot of

00:09:59,000 --> 00:10:06,290
users and it's a major player absolutely

00:10:02,230 --> 00:10:10,060
for the completion we have the racer

00:10:06,290 --> 00:10:12,740
it's an implementation to provide

00:10:10,060 --> 00:10:14,630
completion and work in parallel with the

00:10:12,740 --> 00:10:16,910
language server so they both will work

00:10:14,630 --> 00:10:20,030
very to a very well together especially

00:10:16,910 --> 00:10:23,150
for the new Bing implementation

00:10:20,030 --> 00:10:24,980
immigrants and also we have the github

00:10:23,150 --> 00:10:27,350
that's open source for the language

00:10:24,980 --> 00:10:30,170
server itself it's always on the

00:10:27,350 --> 00:10:32,720
bleeding edge so they follow everything

00:10:30,170 --> 00:10:36,880
that's new on rust and it's working

00:10:32,720 --> 00:10:39,830
currently on a very stable state a

00:10:36,880 --> 00:10:42,170
recommended set up for beginners in

00:10:39,830 --> 00:10:45,190
openness vest code with the set of

00:10:42,170 --> 00:10:49,150
extensions I highlighted there is a

00:10:45,190 --> 00:10:53,810
fairly the same as in the are we ID yet

00:10:49,150 --> 00:10:56,840
and for VI users I use particular this

00:10:53,810 --> 00:10:59,750
set of extensions that you could easily

00:10:56,840 --> 00:11:02,750
start with I don't know bundle or any

00:10:59,750 --> 00:11:04,700
other installer and they will provide a

00:11:02,750 --> 00:11:08,840
very good environment for you to develop

00:11:04,700 --> 00:11:11,240
your your solutions about the rest

00:11:08,840 --> 00:11:14,390
language server how to collaborate they

00:11:11,240 --> 00:11:18,740
follow a very normal community approach

00:11:14,390 --> 00:11:20,690
to bring maintainer Xand people who are

00:11:18,740 --> 00:11:22,400
willing to contribute and for the ones

00:11:20,690 --> 00:11:25,100
who are beginning with rust there is

00:11:22,400 --> 00:11:27,350
also always the good first issue labels

00:11:25,100 --> 00:11:28,820
that are based on some analysis of the

00:11:27,350 --> 00:11:31,190
community some issues that could be

00:11:28,820 --> 00:11:34,010
easily understandable for newcomers and

00:11:31,190 --> 00:11:37,250
they can check on on these particular

00:11:34,010 --> 00:11:38,900
subjects we also have the vs code the

00:11:37,250 --> 00:11:42,110
extension that's also open source so you

00:11:38,900 --> 00:11:44,180
can just fork the repository and start

00:11:42,110 --> 00:11:46,730
to work with it and the problem about

00:11:44,180 --> 00:11:50,450
the rust language server that we don't

00:11:46,730 --> 00:11:52,010
have a huge test coverage so if somebody

00:11:50,450 --> 00:11:53,780
wants to contribute with that and

00:11:52,010 --> 00:11:56,240
implement some test coverage will be

00:11:53,780 --> 00:11:57,860
awesome as well and of course we can

00:11:56,240 --> 00:11:59,480
bring additional clients for every

00:11:57,860 --> 00:12:00,920
client we need to have an implementation

00:11:59,480 --> 00:12:02,660
that will communicate with the language

00:12:00,920 --> 00:12:04,430
server so in this case

00:12:02,660 --> 00:12:06,350
if you have a particular editor that's

00:12:04,430 --> 00:12:08,000
not currently covered you can just

00:12:06,350 --> 00:12:10,759
implement additional clients and you'll

00:12:08,000 --> 00:12:12,500
be very helpful and if you just use and

00:12:10,759 --> 00:12:17,240
report issues you'll find you also be

00:12:12,500 --> 00:12:19,910
helping so these are the key ways to

00:12:17,240 --> 00:12:23,329
collaborate on a helpful way with the

00:12:19,910 --> 00:12:27,529
community so first of all why trust to

00:12:23,329 --> 00:12:29,899
develop this solution performance it's

00:12:27,529 --> 00:12:32,389
the strong points that everyone how is

00:12:29,899 --> 00:12:35,509
talk about rust and I'm going to show a

00:12:32,389 --> 00:12:37,639
quick demonstration to some proof of

00:12:35,509 --> 00:12:41,660
concept I made to define that this is

00:12:37,639 --> 00:12:45,019
actually okay for what I expect

00:12:41,660 --> 00:12:46,910
it's cross-platform so you I don't have

00:12:45,019 --> 00:12:50,329
to change the code to make it available

00:12:46,910 --> 00:12:52,519
for the Mac for Linux for Windows or

00:12:50,329 --> 00:12:54,620
whatever so it's very very simple to

00:12:52,519 --> 00:12:57,110
make this cross-platform support it's

00:12:54,620 --> 00:12:58,790
sort of the box and this was also

00:12:57,110 --> 00:13:01,220
another very strong reason if I'm

00:12:58,790 --> 00:13:04,490
talking about providing support for

00:13:01,220 --> 00:13:06,920
different counters for different editors

00:13:04,490 --> 00:13:09,139
we need to be cross-platform safe eating

00:13:06,920 --> 00:13:12,769
is also another very strong point for us

00:13:09,139 --> 00:13:16,639
so we I had I never found any weird

00:13:12,769 --> 00:13:19,130
memory problems so it's a fairly good

00:13:16,639 --> 00:13:21,319
point as well and one of the most

00:13:19,130 --> 00:13:24,139
important is that modern technologies

00:13:21,319 --> 00:13:26,060
friendly this means that I have this

00:13:24,139 --> 00:13:29,569
idea of bringing the community together

00:13:26,060 --> 00:13:31,670
to provide some linting rules and some

00:13:29,569 --> 00:13:33,920
solutions that we actually require some

00:13:31,670 --> 00:13:36,319
involvement of the community we talked

00:13:33,920 --> 00:13:38,899
previously about the webassembly a

00:13:36,319 --> 00:13:41,449
solution and I developed a parser that

00:13:38,899 --> 00:13:46,040
will work out of the bottle on any

00:13:41,449 --> 00:13:47,959
browser any modern browser and this is

00:13:46,040 --> 00:13:50,509
one of the possibilities we have with

00:13:47,959 --> 00:13:53,860
rust so out of the box they can provide

00:13:50,509 --> 00:13:57,860
this type of support and follow any

00:13:53,860 --> 00:13:59,540
modern technology and are perishing we

00:13:57,860 --> 00:14:02,240
have available pest framework that used

00:13:59,540 --> 00:14:04,850
some back grammars I will talk a little

00:14:02,240 --> 00:14:07,610
bit about it later and we have one ready

00:14:04,850 --> 00:14:11,389
crate called a language server types

00:14:07,610 --> 00:14:13,720
they will provide the specified types

00:14:11,389 --> 00:14:16,460
for the language server communication

00:14:13,720 --> 00:14:19,790
also out-of-the-box so it's a

00:14:16,460 --> 00:14:22,130
very simple - to be at the plate with

00:14:19,790 --> 00:14:23,690
the implementation I found out one

00:14:22,130 --> 00:14:27,950
little bug with that Eclipse integration

00:14:23,690 --> 00:14:30,860
based on the this language type based on

00:14:27,950 --> 00:14:32,900
some requires do not require the fusion

00:14:30,860 --> 00:14:39,980
it was very very simple to use this as a

00:14:32,900 --> 00:14:41,630
base to the carnet so here I have the

00:14:39,980 --> 00:14:44,480
proof of concept I talking about I

00:14:41,630 --> 00:14:47,180
develop it a any cooing solution it's a

00:14:44,480 --> 00:14:49,570
classical mathematical problem that they

00:14:47,180 --> 00:14:52,430
have some fairly extensive

00:14:49,570 --> 00:14:54,200
computational power required so I'm

00:14:52,430 --> 00:15:00,550
going to give a very simple example here

00:14:54,200 --> 00:15:04,040
I'm going to set I don't know 15 rows

00:15:00,550 --> 00:15:09,110
Queen and I'm going to ask them to solve

00:15:04,040 --> 00:15:11,150
this so like very first time we can

00:15:09,110 --> 00:15:15,080
solve a complex problem like in ten of

00:15:11,150 --> 00:15:16,810
time like I say and this is what the

00:15:15,080 --> 00:15:19,190
proof of concept that's up for a

00:15:16,810 --> 00:15:21,170
computational power that I required to

00:15:19,190 --> 00:15:23,780
make these language server and parsing

00:15:21,170 --> 00:15:28,250
online available I could easily fix with

00:15:23,780 --> 00:15:31,130
this so implemented as well sort of

00:15:28,250 --> 00:15:32,990
compiler that's browser based is totally

00:15:31,130 --> 00:15:35,080
web assembly based is open source for

00:15:32,990 --> 00:15:37,640
the ones which want to take a look and

00:15:35,080 --> 00:15:38,960
here for example I have one expression I

00:15:37,640 --> 00:15:41,750
will just parse it

00:15:38,960 --> 00:15:50,750
let me introduce air hold on the syntax

00:15:41,750 --> 00:15:53,000
something like this okay so for example

00:15:50,750 --> 00:15:56,000
for once you produce a compilation

00:15:53,000 --> 00:15:57,650
waiver there will be the the parsonage

00:15:56,000 --> 00:16:00,920
post that these are character is not

00:15:57,650 --> 00:16:01,340
expected on that position and I if I fix

00:16:00,920 --> 00:16:04,280
it

00:16:01,340 --> 00:16:06,140
I have the full parts entry under the

00:16:04,280 --> 00:16:08,060
right so this works very fast as well

00:16:06,140 --> 00:16:10,420
and totally browser bases currently I'm

00:16:08,060 --> 00:16:10,420
offline

00:16:15,870 --> 00:16:25,360
so going back to the slide so this is

00:16:21,579 --> 00:16:29,980
why I choose rust so why why the best

00:16:25,360 --> 00:16:31,540
framework white Pegram ours we have open

00:16:29,980 --> 00:16:33,699
search solution as well the best

00:16:31,540 --> 00:16:36,850
framework for the development of parsers

00:16:33,699 --> 00:16:40,569
it's a it's on a very stable stage now

00:16:36,850 --> 00:16:43,839
and for the research demanding operation

00:16:40,569 --> 00:16:46,449
of Part C sources I have some examples

00:16:43,839 --> 00:16:48,699
like the one I showed before it's like

00:16:46,449 --> 00:16:50,410
two thousand and five hundred lines I

00:16:48,699 --> 00:16:53,199
have others with ten thousand lines so

00:16:50,410 --> 00:16:54,670
this should be parse it fast and I can

00:16:53,199 --> 00:16:57,689
achieve these before a less than one

00:16:54,670 --> 00:17:01,600
second of parsing time I can show later

00:16:57,689 --> 00:17:03,189
it's a fairly good number for the user

00:17:01,600 --> 00:17:04,870
interaction so if we're talking about a

00:17:03,189 --> 00:17:08,740
complex operation with fuser

00:17:04,870 --> 00:17:12,490
and we parse in less than one second

00:17:08,740 --> 00:17:15,150
it's a good result we could grant that

00:17:12,490 --> 00:17:19,630
we have these features we've passed

00:17:15,150 --> 00:17:21,699
based on a grammar development and these

00:17:19,630 --> 00:17:23,459
grammars the pec grammars that this

00:17:21,699 --> 00:17:25,839
framework provides they are always

00:17:23,459 --> 00:17:27,429
well-formed so I have some validations

00:17:25,839 --> 00:17:29,320
on best for the development of the

00:17:27,429 --> 00:17:32,049
grammar that will predict some left

00:17:29,320 --> 00:17:34,150
recursion problems when you are in

00:17:32,049 --> 00:17:37,330
development time you do not waste time

00:17:34,150 --> 00:17:42,030
in production to fix these very common

00:17:37,330 --> 00:17:44,500
problems also safety is another another

00:17:42,030 --> 00:17:46,360
topic for this one another plus one for

00:17:44,500 --> 00:17:50,200
this one and also modern technologies

00:17:46,360 --> 00:17:52,240
friendly these type of this framework in

00:17:50,200 --> 00:17:54,730
particular because of the Pegram our

00:17:52,240 --> 00:17:56,500
structure it's very good two parts code

00:17:54,730 --> 00:17:58,030
but not good two parts some natural

00:17:56,500 --> 00:18:00,820
language so if we're talking about

00:17:58,030 --> 00:18:03,549
developing a domain language that's

00:18:00,820 --> 00:18:05,710
somehow close to natural language this

00:18:03,549 --> 00:18:09,400
is not your solution I've put on the

00:18:05,710 --> 00:18:11,289
right simple graphic about the

00:18:09,400 --> 00:18:14,169
performance of pests compared to gnome

00:18:11,289 --> 00:18:17,049
and third normal cells are very well

00:18:14,169 --> 00:18:19,929
consolidated libraries in rust as well

00:18:17,049 --> 00:18:23,320
and this is the amount of megabytes we

00:18:19,929 --> 00:18:26,559
can our parts per second of JSON data

00:18:23,320 --> 00:18:28,180
gnome is very very efficient but they

00:18:26,559 --> 00:18:30,730
are not grammar based so

00:18:28,180 --> 00:18:33,370
all these solutions that I want to

00:18:30,730 --> 00:18:36,280
provide natural will not be available

00:18:33,370 --> 00:18:38,350
because I have to develop the parsing

00:18:36,280 --> 00:18:41,860
from scratch something like that

00:18:38,350 --> 00:18:45,370
so Nome has a fairly good parsing time

00:18:41,860 --> 00:18:48,610
and pass with the grammar base the

00:18:45,370 --> 00:18:51,730
development can achieve a reasonably

00:18:48,610 --> 00:18:54,490
good number comparing to Nome we have

00:18:51,730 --> 00:18:55,900
like almost 200 megabytes per second

00:18:54,490 --> 00:19:01,180
when we're parsing JSON with this

00:18:55,900 --> 00:19:06,120
framework the challenges of using this

00:19:01,180 --> 00:19:08,770
best framework that I face it I have the

00:19:06,120 --> 00:19:10,300
multi-threading problem so most of the

00:19:08,770 --> 00:19:13,180
things with the language server is a

00:19:10,300 --> 00:19:15,340
synchronous and unfortunately we don't

00:19:13,180 --> 00:19:17,740
have the sentencing implementation for

00:19:15,340 --> 00:19:19,960
pets on the current state I honestly

00:19:17,740 --> 00:19:23,800
expect this to be implemented on the

00:19:19,960 --> 00:19:27,280
rows 2018 with the new features but

00:19:23,800 --> 00:19:31,870
anyway the way I had to fix this

00:19:27,280 --> 00:19:36,670
particular problem is to use some arcane

00:19:31,870 --> 00:19:39,490
mutex to axis the parse entry on the

00:19:36,670 --> 00:19:40,810
main thread so this was the way and it's

00:19:39,490 --> 00:19:42,520
not a big problem since we're not

00:19:40,810 --> 00:19:44,740
talking about different developers

00:19:42,520 --> 00:19:47,830
accessing the same resource we not have

00:19:44,740 --> 00:19:49,720
concurrency problems there and we have

00:19:47,830 --> 00:19:52,030
an implementation from the pest

00:19:49,720 --> 00:19:54,310
framework that's called a St the github

00:19:52,030 --> 00:19:58,690
is there and they are using generic

00:19:54,310 --> 00:20:01,240
types to implement their parser this

00:19:58,690 --> 00:20:04,090
means that we could use easily implement

00:20:01,240 --> 00:20:07,480
the standard SiC implementations on our

00:20:04,090 --> 00:20:09,570
types after this table I'm currently not

00:20:07,480 --> 00:20:14,710
using because it's a very recent

00:20:09,570 --> 00:20:17,470
initiative so I will finish my work with

00:20:14,710 --> 00:20:19,960
them native pests but there is also this

00:20:17,470 --> 00:20:23,160
possibility if multi-threading is a big

00:20:19,960 --> 00:20:26,560
thing for you you can go to this ast

00:20:23,160 --> 00:20:28,900
implementation for the development of

00:20:26,560 --> 00:20:30,550
the grammar if you're going to develop a

00:20:28,900 --> 00:20:32,710
grammar you should expect a proportion

00:20:30,550 --> 00:20:36,220
like this one this is my keys

00:20:32,710 --> 00:20:40,240
I have 400 lines of grammar and I have

00:20:36,220 --> 00:20:41,950
4,000 lines of our testing of tdg white

00:20:40,240 --> 00:20:45,130
EDD it's very difficult

00:20:41,950 --> 00:20:48,309
to debug one grammar at least for the

00:20:45,130 --> 00:20:50,860
past we have a set of macros that's

00:20:48,309 --> 00:20:55,149
based on this other language that's the

00:20:50,860 --> 00:20:57,100
syntax for the best grammar and this is

00:20:55,149 --> 00:21:00,120
this was taking a lot of time so I

00:20:57,100 --> 00:21:03,340
decided to take the TDD approach and if

00:21:00,120 --> 00:21:06,279
you expect you to achieve a result you

00:21:03,340 --> 00:21:11,080
should expect the proportion similar to

00:21:06,279 --> 00:21:12,700
that in order for planning so I pointed

00:21:11,080 --> 00:21:15,179
here that we don't have cleared the

00:21:12,700 --> 00:21:17,519
bugging procedures for the parsing and

00:21:15,179 --> 00:21:22,450
this will be one of the challenges

00:21:17,519 --> 00:21:26,110
certainly you face so about the

00:21:22,450 --> 00:21:28,360
execution of the development all the

00:21:26,110 --> 00:21:31,360
communication between the editor and the

00:21:28,360 --> 00:21:33,970
language server will send some G's RPC

00:21:31,360 --> 00:21:36,970
pro requests to the server and it will

00:21:33,970 --> 00:21:39,730
have to manage the data so for every

00:21:36,970 --> 00:21:42,720
character change for every document to

00:21:39,730 --> 00:21:45,460
open or any other interaction the

00:21:42,720 --> 00:21:47,919
editorial just sends the contents of

00:21:45,460 --> 00:21:49,720
these changed data to the language

00:21:47,919 --> 00:21:52,419
server and it will have to store it

00:21:49,720 --> 00:21:55,240
internally the contents of the sources

00:21:52,419 --> 00:21:57,730
you are working with this means that you

00:21:55,240 --> 00:22:00,519
need to have some sort of implementation

00:21:57,730 --> 00:22:02,440
for the virtual file server that will be

00:22:00,519 --> 00:22:04,510
in memory if we're talking about always

00:22:02,440 --> 00:22:05,769
parsing data from disk this is absurd

00:22:04,510 --> 00:22:08,019
because takes a lot of time and

00:22:05,769 --> 00:22:10,179
resources so it's mandatory that you

00:22:08,019 --> 00:22:12,490
have some memory control for this and we

00:22:10,179 --> 00:22:15,580
have the rest language server a solution

00:22:12,490 --> 00:22:17,980
for that already it's done for us it's a

00:22:15,580 --> 00:22:21,279
video file server the github is right

00:22:17,980 --> 00:22:23,250
there it's fairly stable as well and you

00:22:21,279 --> 00:22:26,740
can use this as a base for your

00:22:23,250 --> 00:22:30,090
implementation about the desire PC

00:22:26,740 --> 00:22:33,850
communication I use it the parity tech

00:22:30,090 --> 00:22:36,970
solution we have the JSON RPC protocol

00:22:33,850 --> 00:22:39,279
implemented there and it works very very

00:22:36,970 --> 00:22:41,980
well too I never had problems with it

00:22:39,279 --> 00:22:44,500
and they have several server

00:22:41,980 --> 00:22:48,130
implementations so they have some RPC

00:22:44,500 --> 00:22:50,289
some ACP I myself used stdio

00:22:48,130 --> 00:22:52,210
that's fairly supported by any

00:22:50,289 --> 00:22:53,980
environment we were talking about but

00:22:52,210 --> 00:22:55,490
they also have some other possibilities

00:22:53,980 --> 00:22:57,559
for you in case you need

00:22:55,490 --> 00:23:00,590
and there's some general guidelines I

00:22:57,559 --> 00:23:03,559
follow it to achieve the result any

00:23:00,590 --> 00:23:05,660
change on the test of the parcel will

00:23:03,559 --> 00:23:11,390
increment the major version this means

00:23:05,660 --> 00:23:15,290
that we can on us reliable way counts

00:23:11,390 --> 00:23:17,630
that the parser will always produce the

00:23:15,290 --> 00:23:19,700
same tree on that deterministic way for

00:23:17,630 --> 00:23:20,809
a given version this is important for

00:23:19,700 --> 00:23:25,370
and when you're talking about our

00:23:20,809 --> 00:23:27,980
lynching rules and effort if you want to

00:23:25,370 --> 00:23:31,040
develop some strong linking rules will

00:23:27,980 --> 00:23:32,750
depend on some community interaction may

00:23:31,040 --> 00:23:35,770
be those who just rules maybe there will

00:23:32,750 --> 00:23:38,600
suggest some analysis of your source and

00:23:35,770 --> 00:23:42,380
if you have different parties for the

00:23:38,600 --> 00:23:47,960
same version it's totally not possible

00:23:42,380 --> 00:23:51,020
to to consider this so this actually

00:23:47,960 --> 00:23:52,910
follows the TDD idea so any change on

00:23:51,020 --> 00:23:54,980
the test we will increment the major

00:23:52,910 --> 00:23:58,670
version when we imply some possible

00:23:54,980 --> 00:24:01,540
breaking changes and we also require a

00:23:58,670 --> 00:24:03,800
very good very strong participation of

00:24:01,540 --> 00:24:08,960
the community when we are talking about

00:24:03,800 --> 00:24:11,540
the linker rules this means that for my

00:24:08,960 --> 00:24:15,290
particular implementation I'm using some

00:24:11,540 --> 00:24:17,150
voting systems to integrate the contents

00:24:15,290 --> 00:24:19,520
of the rules like the developers can

00:24:17,150 --> 00:24:22,429
give a plus one minus one for a given

00:24:19,520 --> 00:24:25,070
rule and based on this information we

00:24:22,429 --> 00:24:26,330
can define what's being accepted and

00:24:25,070 --> 00:24:28,820
what's not being accepted by the

00:24:26,330 --> 00:24:30,830
community like these needs is usually

00:24:28,820 --> 00:24:32,809
struggle with developers so maybe there

00:24:30,830 --> 00:24:34,850
will not be very popular some rules but

00:24:32,809 --> 00:24:37,100
anyway for the ones that make sense we

00:24:34,850 --> 00:24:38,809
can have a distant feedback with the of

00:24:37,100 --> 00:24:40,460
the community since we're talking about

00:24:38,809 --> 00:24:44,150
the language services can communicate

00:24:40,460 --> 00:24:47,990
with any any gnomes web services very

00:24:44,150 --> 00:24:50,120
very easy to achieve that so here I

00:24:47,990 --> 00:24:52,370
prepared some set of useful links for

00:24:50,120 --> 00:24:55,340
the for the ones who are curious about

00:24:52,370 --> 00:24:57,140
this implementation the first is a

00:24:55,340 --> 00:24:59,360
Geetha that I used to communicate with

00:24:57,140 --> 00:25:02,000
some guys that are participating with me

00:24:59,360 --> 00:25:04,580
on the development and the second is the

00:25:02,000 --> 00:25:07,820
implementation with web apps web

00:25:04,580 --> 00:25:09,270
assembly that I showed previously of

00:25:07,820 --> 00:25:12,779
browser parsing

00:25:09,270 --> 00:25:15,390
the Ford is the best website resources

00:25:12,779 --> 00:25:17,460
there you can find a very small book

00:25:15,390 --> 00:25:20,610
that we will somehow describe how you

00:25:17,460 --> 00:25:23,039
can develop with this framework language

00:25:20,610 --> 00:25:24,570
specification that's a fairly important

00:25:23,039 --> 00:25:27,529
resource if we're talking about

00:25:24,570 --> 00:25:31,409
developing this and of course that we ID

00:25:27,529 --> 00:25:33,929
the language server github and the G's

00:25:31,409 --> 00:25:36,000
or PC from Part C tech implementation

00:25:33,929 --> 00:25:40,409
it's also open source and you can use

00:25:36,000 --> 00:25:43,649
these as a reference so in case you want

00:25:40,409 --> 00:25:45,240
to consult a to understand better how

00:25:43,649 --> 00:25:48,270
the communication for language service

00:25:45,240 --> 00:25:51,870
is working you cannot check these dis

00:25:48,270 --> 00:25:53,940
contents that's pretty much it thank you

00:25:51,870 --> 00:25:56,370
very much for the participation and I'm

00:25:53,940 --> 00:25:58,980
going to be available on the lunch order

00:25:56,370 --> 00:26:04,150
around there for any questions you may

00:25:58,980 --> 00:26:07,029
eventually have Thank You Victor

00:26:04,150 --> 00:26:07,029

YouTube URL: https://www.youtube.com/watch?v=nPx2wbbykfs


