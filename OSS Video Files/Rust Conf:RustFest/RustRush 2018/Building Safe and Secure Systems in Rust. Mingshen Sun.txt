Title: Building Safe and Secure Systems in Rust. Mingshen Sun
Publication date: 2019-02-06
Playlist: RustRush 2018
Description: 
	Mingshen Sun is a senior security researcher of Baidu X-Lab at Baidu USA. He received his Ph.D. degree in Computer Science and Engineering from The Chinese University of Hong Kong. His interests lie in solving real-world security problems related to system, mobile, IoT devices and cars. He maintains and actively contributes to several open source projects in Rust such as the MesaLock Linux project, MesaPy, and YogCrypt.

Rust is designed to be a system programming language which is fast and guarantees memory safety. However, building safe and secure systems is not simply using Rust to rewrite existing code. Still, there are many challenges such as the Rust language, unsafe Rust, foreign function interface (FFI), and designing systems with a hybrid memory model. In this talk, we will discuss some challenges in the view of security. We will demonstrate the challenges and lesson learned by using some real-world case studies. Finally, we will raise some open questions, initial ideas, and possible solutions.
Captions: 
	00:00:02,710 --> 00:00:11,929
welcome mention thank you thank you for

00:00:09,469 --> 00:00:15,410
introduction and thank you for attending

00:00:11,929 --> 00:00:17,270
my talk and this talk today we're

00:00:15,410 --> 00:00:20,599
talking about the build safe and secure

00:00:17,270 --> 00:00:24,040
system in rust and before that let me

00:00:20,599 --> 00:00:27,649
introduce myself and I'm the security

00:00:24,040 --> 00:00:30,200
researcher in by 2x live in California

00:00:27,649 --> 00:00:32,599
USA and basically I'm doing some

00:00:30,200 --> 00:00:35,590
research on system security mobile

00:00:32,599 --> 00:00:39,260
security IOT security and a car hacking

00:00:35,590 --> 00:00:42,530
I'm enhanced open source project like

00:00:39,260 --> 00:00:46,520
master lock Linux mess apart entered and

00:00:42,530 --> 00:00:49,700
passed for iOS so and and you can check

00:00:46,520 --> 00:00:56,090
out that repository in the my kid hub

00:00:49,700 --> 00:00:58,910
and my website and the brief

00:00:56,090 --> 00:01:02,380
introduction about by 2x live and the

00:00:58,910 --> 00:01:07,790
bad bad wax lab is research lab in

00:01:02,380 --> 00:01:12,320
California and we do we have a lot of

00:01:07,790 --> 00:01:16,070
people like 200 of our people but we are

00:01:12,320 --> 00:01:19,880
for the research lab is there about 20

00:01:16,070 --> 00:01:22,540
people most of them from the academia

00:01:19,880 --> 00:01:27,770
gap background so we do some system

00:01:22,540 --> 00:01:29,900
research in like fuzzing testing and the

00:01:27,770 --> 00:01:32,360
autonomous driving security of

00:01:29,900 --> 00:01:35,720
autonomous driving car and the memory

00:01:32,360 --> 00:01:38,150
safe programming language and program

00:01:35,720 --> 00:01:42,830
analysis like dynamic analysis and

00:01:38,150 --> 00:01:44,810
static analysis ok and we have a lot

00:01:42,830 --> 00:01:46,040
open source project I will talk about

00:01:44,810 --> 00:01:50,740
that later

00:01:46,040 --> 00:01:55,600
so the outline of today is we know that

00:01:50,740 --> 00:02:00,049
Rus providers safe and secure building

00:01:55,600 --> 00:02:02,390
programming language and when we used R

00:02:00,049 --> 00:02:05,630
Us to build this system there are some

00:02:02,390 --> 00:02:08,539
challenges and lessons learned and some

00:02:05,630 --> 00:02:11,209
open questions you are raised this

00:02:08,539 --> 00:02:15,000
challenge license and open questions you

00:02:11,209 --> 00:02:20,490
know security researchers perspective

00:02:15,000 --> 00:02:24,650
and all from the one paper it is called

00:02:20,490 --> 00:02:30,330
eternal war in memory as in published in

00:02:24,650 --> 00:02:33,600
2013 and the mmm

00:02:30,330 --> 00:02:38,910
the figure may be too small but I will

00:02:33,600 --> 00:02:41,880
point out is all of the memory issues is

00:02:38,910 --> 00:02:44,670
beginning from - the first one is making

00:02:41,880 --> 00:02:47,550
our pointer go Autobahn and second the

00:02:44,670 --> 00:02:50,720
makeup only become dangling so what a

00:02:47,550 --> 00:02:55,320
rush I want to solve is this whole

00:02:50,720 --> 00:02:57,360
issues which is memory safety for the

00:02:55,320 --> 00:03:00,320
years the security researcher actually

00:02:57,360 --> 00:03:03,660
doing a lot work on the memory safety

00:03:00,320 --> 00:03:07,290
for example he was programming lattices

00:03:03,660 --> 00:03:10,020
like symbolic seclusion Ackley is one of

00:03:07,290 --> 00:03:13,500
the famous stimuli secure insist

00:03:10,020 --> 00:03:15,870
platform and like memory check in

00:03:13,500 --> 00:03:18,360
virtual machine valgrind and the

00:03:15,870 --> 00:03:20,280
compiler instrumentation a solution

00:03:18,360 --> 00:03:23,820
addressed and advisor

00:03:20,280 --> 00:03:26,910
there are a lot fastening system AFL

00:03:23,820 --> 00:03:29,989
leap phaser and also a lot for

00:03:26,910 --> 00:03:34,260
modification system like seahorse mark

00:03:29,989 --> 00:03:37,260
trusting soft and so on so forth we do a

00:03:34,260 --> 00:03:41,220
lot of things to mitigate our memory

00:03:37,260 --> 00:03:44,510
corruption errors but for now we know

00:03:41,220 --> 00:03:49,549
that rust can provide memory safety and

00:03:44,510 --> 00:03:54,120
better concurrency so right now in the

00:03:49,549 --> 00:03:56,610
current this decades we have go and rest

00:03:54,120 --> 00:03:59,220
others safe programming languages and

00:03:56,610 --> 00:04:04,650
the save the basically means memory

00:03:59,220 --> 00:04:06,810
safety and for in this talk I mean a

00:04:04,650 --> 00:04:09,450
safe building a safe and a secure system

00:04:06,810 --> 00:04:12,930
in rust a safe means memory safe access

00:04:09,450 --> 00:04:15,299
and the safe concurrency for security I

00:04:12,930 --> 00:04:18,090
mean our lives one abilities and a

00:04:15,299 --> 00:04:20,760
reduced attack surface so we want to

00:04:18,090 --> 00:04:25,950
build a system with safe memory safety

00:04:20,760 --> 00:04:28,570
and reduce attack services so how what

00:04:25,950 --> 00:04:31,030
what what we have done

00:04:28,570 --> 00:04:34,270
we have operating system like tacos

00:04:31,030 --> 00:04:37,560
Redux or a street near us and the rest

00:04:34,270 --> 00:04:42,580
compiler written in rust and the last

00:04:37,560 --> 00:04:46,030
like networking services d-nice deal and

00:04:42,580 --> 00:04:49,390
TRS library and some web server and

00:04:46,030 --> 00:04:54,160
database and the browser like servo and

00:04:49,390 --> 00:04:58,300
the CSS engine and the for bi do bi do

00:04:54,160 --> 00:05:00,940
did a lot working last we have like one

00:04:58,300 --> 00:05:03,520
two three four five projects written

00:05:00,940 --> 00:05:06,130
rust why is the master lock Linux as a

00:05:03,520 --> 00:05:09,340
memory safe Linux distribution we

00:05:06,130 --> 00:05:13,150
actually write out the user space to box

00:05:09,340 --> 00:05:15,520
like a busy provided as a basic box in

00:05:13,150 --> 00:05:18,760
rust it's called master box is a

00:05:15,520 --> 00:05:22,360
collection of system utility rittany

00:05:18,760 --> 00:05:25,420
rust and master link is a memory civ and

00:05:22,360 --> 00:05:28,510
the OpenSSL compatible a TRS library and

00:05:25,420 --> 00:05:32,260
the evening I already have a talk in

00:05:28,510 --> 00:05:36,130
rust faster this year two web months ago

00:05:32,260 --> 00:05:38,920
and the master pile security and fast

00:05:36,130 --> 00:05:43,860
pison based on pipe high and the way rip

00:05:38,920 --> 00:05:48,490
we replace some say encode to rust and

00:05:43,860 --> 00:05:54,720
glue rust and the pipe hi the last one

00:05:48,490 --> 00:05:58,180
is rustic STX SDK as GX is Intel feature

00:05:54,720 --> 00:05:59,590
to provide a secure execution

00:05:58,180 --> 00:06:02,770
environment trusted a high security

00:05:59,590 --> 00:06:05,440
environment and we modify our last

00:06:02,770 --> 00:06:09,010
standard library and put it into the

00:06:05,440 --> 00:06:11,410
Intel SGX so that I can write I see

00:06:09,010 --> 00:06:15,270
actually include in rust and there are

00:06:11,410 --> 00:06:19,420
many more project will be open source

00:06:15,270 --> 00:06:21,520
next year okay let me talk the

00:06:19,420 --> 00:06:25,210
challenges lesson learn and open

00:06:21,520 --> 00:06:28,840
questions okay when way to this project

00:06:25,210 --> 00:06:33,230
we faced many challenges the first one

00:06:28,840 --> 00:06:36,860
is a rust language and ecosystem itself

00:06:33,230 --> 00:06:39,760
you know Russ language involved pretty

00:06:36,860 --> 00:06:44,200
fast and we need to keep track of the

00:06:39,760 --> 00:06:45,650
RFC the nightly rest the whole ecosystem

00:06:44,200 --> 00:06:48,770
right

00:06:45,650 --> 00:06:53,240
there's a lot of create new created on

00:06:48,770 --> 00:06:56,930
the Chris IO and sometimes of worry

00:06:53,240 --> 00:07:00,710
stable and very popular create there's

00:06:56,930 --> 00:07:06,050
suddenly no one maintain it and the the

00:07:00,710 --> 00:07:11,680
author is is I don't know some crazy

00:07:06,050 --> 00:07:11,680
author is lost and also the answer frost

00:07:12,010 --> 00:07:18,820
for the high-level development we don't

00:07:14,930 --> 00:07:22,460
care we don't use as if right but if you

00:07:18,820 --> 00:07:26,660
do some system programming eventually

00:07:22,460 --> 00:07:29,660
you will use as say for us to do to get

00:07:26,660 --> 00:07:32,350
better performance to talk about the

00:07:29,660 --> 00:07:35,780
tech drivers that like the memory

00:07:32,350 --> 00:07:39,590
directly so you need to use I see frost

00:07:35,780 --> 00:07:43,790
and the third why is the foreign

00:07:39,590 --> 00:07:48,050
function interface FFI right if you want

00:07:43,790 --> 00:07:50,510
to build a very big system you have to

00:07:48,050 --> 00:07:54,440
use many programming language not just

00:07:50,510 --> 00:07:59,660
rust itself you have to see simple parts

00:07:54,440 --> 00:08:01,760
of hyacinth and rust so the interface

00:07:59,660 --> 00:08:04,850
between the difference between different

00:08:01,760 --> 00:08:07,010
languages the a big problem

00:08:04,850 --> 00:08:10,870
you need to keep the memory safety

00:08:07,010 --> 00:08:14,720
between the scope of the different

00:08:10,870 --> 00:08:17,240
languages and the last one is what I

00:08:14,720 --> 00:08:21,320
mean the challenges in hybrid memory

00:08:17,240 --> 00:08:23,600
model that means different language have

00:08:21,320 --> 00:08:27,410
different memory model like say you need

00:08:23,600 --> 00:08:31,810
to manually chop some memory but in rust

00:08:27,410 --> 00:08:36,740
there's there's no cabbage tractor and

00:08:31,810 --> 00:08:39,530
in Java in tiesm there's a global lock

00:08:36,740 --> 00:08:41,270
to - cabbage correction so there are

00:08:39,530 --> 00:08:44,150
many challenges in the hybrid memory

00:08:41,270 --> 00:08:46,290
model but in this talk and many folk

00:08:44,150 --> 00:08:50,670
song and see frost

00:08:46,290 --> 00:08:53,190
so I said what is unsafe rust and when

00:08:50,670 --> 00:08:56,190
you read the document there's one

00:08:53,190 --> 00:08:59,660
chapter in the other one of the ones the

00:08:56,190 --> 00:09:04,080
features and it is as if rust

00:08:59,660 --> 00:09:06,600
what is unsafe roster now we know that

00:09:04,080 --> 00:09:08,970
all the code we discussed about the

00:09:06,600 --> 00:09:12,180
memory safety concurrence saved

00:09:08,970 --> 00:09:15,690
concurrently is guaranteed by safe rust

00:09:12,180 --> 00:09:19,140
and however rust has a second language

00:09:15,690 --> 00:09:21,720
hiding inside it it is called as we fast

00:09:19,140 --> 00:09:25,650
it doesn't enforce this memory safety

00:09:21,720 --> 00:09:29,700
guarantees and if this works just like

00:09:25,650 --> 00:09:32,730
regular rust but gives you extra powers

00:09:29,700 --> 00:09:35,430
there are four extra powers we will look

00:09:32,730 --> 00:09:38,000
at it first why is the reference or raw

00:09:35,430 --> 00:09:40,920
point her so that's where dangerous

00:09:38,000 --> 00:09:43,800
second one access modifier multiple

00:09:40,920 --> 00:09:46,500
static variables so you know there's

00:09:43,800 --> 00:09:49,140
some concurrency issues if you do the

00:09:46,500 --> 00:09:52,320
second one third Cohen NC functional

00:09:49,140 --> 00:09:55,410
measured force employment and safe treat

00:09:52,320 --> 00:09:58,800
so let's see the first one differ at

00:09:55,410 --> 00:10:01,890
first the reference the raw pointer so

00:09:58,800 --> 00:10:05,130
this is an simple example you can do

00:10:01,890 --> 00:10:07,530
reference one two three four in the

00:10:05,130 --> 00:10:10,530
memory and get the value of the memory

00:10:07,530 --> 00:10:13,320
so in this case you can read and write

00:10:10,530 --> 00:10:18,030
arbitrary memory address right so that's

00:10:13,320 --> 00:10:20,780
the big security issues for icy Frost

00:10:18,030 --> 00:10:23,670
the second way is access to modify

00:10:20,780 --> 00:10:28,320
multiple static variable so for this

00:10:23,670 --> 00:10:31,440
case you can use like the unsafe to

00:10:28,320 --> 00:10:34,170
print the counter and to increase the

00:10:31,440 --> 00:10:37,380
counter the country is actually a static

00:10:34,170 --> 00:10:40,650
global variable so this will cause it

00:10:37,380 --> 00:10:44,490
erases the third way is you can call the

00:10:40,650 --> 00:10:46,710
ANSI function or method for this case

00:10:44,490 --> 00:10:48,960
you have what internals as a function

00:10:46,710 --> 00:10:52,710
and in the main function you can call

00:10:48,960 --> 00:10:55,290
the dangerous function as a function so

00:10:52,710 --> 00:10:57,600
this is answer if calling an unsafe

00:10:55,290 --> 00:10:58,950
function may cause and defined behavior

00:10:57,600 --> 00:11:00,570
if the if

00:10:58,950 --> 00:11:06,329
and say function is not properly

00:11:00,570 --> 00:11:08,490
implemented right the third one is is to

00:11:06,329 --> 00:11:12,959
call I say functional method like

00:11:08,490 --> 00:11:16,889
external function so we'll use some FFI

00:11:12,959 --> 00:11:20,550
to call C code to use C API to call sick

00:11:16,889 --> 00:11:24,269
zip access code called pison sometimes

00:11:20,550 --> 00:11:26,070
you need to use unsafe so calling

00:11:24,269 --> 00:11:29,040
external function may cause and defense

00:11:26,070 --> 00:11:31,470
behavior right because you are in rust

00:11:29,040 --> 00:11:33,449
you'll call some sicko the C code can do

00:11:31,470 --> 00:11:36,630
anything they want they can manipulate

00:11:33,449 --> 00:11:42,029
the memory they want so it will cause

00:11:36,630 --> 00:11:44,850
some identify behaviors so so what I

00:11:42,029 --> 00:11:46,079
want mention is that some developers may

00:11:44,850 --> 00:11:49,380
say it's okay

00:11:46,079 --> 00:11:52,350
at least you explicitly type the as if

00:11:49,380 --> 00:11:54,389
keyword in the source code right and you

00:11:52,350 --> 00:11:57,480
can search and see if in the source code

00:11:54,389 --> 00:11:59,220
to see whether it is safe or not but

00:11:57,480 --> 00:12:02,250
what I mean

00:11:59,220 --> 00:12:04,890
it is wrong because as we called GUI

00:12:02,250 --> 00:12:09,269
click included in the dependent

00:12:04,890 --> 00:12:12,060
libraries so when you look at the safety

00:12:09,269 --> 00:12:15,120
of our create did you review the source

00:12:12,060 --> 00:12:21,170
code of all the dependencies it's not

00:12:15,120 --> 00:12:25,279
that easy right for Rusted libraries

00:12:21,170 --> 00:12:29,790
it's always involved like hundred

00:12:25,279 --> 00:12:33,540
dependencies so it's difficult to review

00:12:29,790 --> 00:12:35,610
also a zip code so that's what had been

00:12:33,540 --> 00:12:39,930
asked if it's organ or stick for

00:12:35,610 --> 00:12:42,899
developers so this is an example if we

00:12:39,930 --> 00:12:46,620
have a library have a dangerous function

00:12:42,899 --> 00:12:50,220
which is to dereference a memory pointer

00:12:46,620 --> 00:12:53,130
and actually we provide this as if

00:12:50,220 --> 00:12:55,920
dangerous function as a safe function we

00:12:53,130 --> 00:12:58,769
provide this API to developers so

00:12:55,920 --> 00:13:01,620
developer uses safe function to call

00:12:58,769 --> 00:13:04,589
some they think it is safe but actually

00:13:01,620 --> 00:13:08,010
is not safe it it may have some

00:13:04,589 --> 00:13:11,790
undefined behavior here so that's what I

00:13:08,010 --> 00:13:12,800
mean and as if it's an agnostic so some

00:13:11,790 --> 00:13:16,190
libraries include

00:13:12,800 --> 00:13:20,510
stana libraries I rap and safe cold and

00:13:16,190 --> 00:13:23,420
sweet spot is a functions so it's

00:13:20,510 --> 00:13:26,779
difficult to if you'll find a bug in

00:13:23,420 --> 00:13:31,040
your code it's difficult to debug it

00:13:26,779 --> 00:13:35,420
right because the as if the anti fight

00:13:31,040 --> 00:13:39,740
behavior is origin from some deep very

00:13:35,420 --> 00:13:44,649
deep or create insider dependency so one

00:13:39,740 --> 00:13:48,200
case study is I'll show I'm sure is a

00:13:44,649 --> 00:13:51,200
modern shell and the written in last and

00:13:48,200 --> 00:13:53,260
this is inter that is the introduction

00:13:51,200 --> 00:13:56,870
of iron shell in their in their

00:13:53,260 --> 00:13:58,940
documentation it is writing entirely in

00:13:56,870 --> 00:14:02,240
rust which is greatly increased overall

00:13:58,940 --> 00:14:05,450
in quality and security of the show yes

00:14:02,240 --> 00:14:09,760
it is true it is written entirely in

00:14:05,450 --> 00:14:13,970
rust but actually when you are analyzed

00:14:09,760 --> 00:14:17,510
dependency is not true so you can use

00:14:13,970 --> 00:14:21,709
caco3 and to print out all the

00:14:17,510 --> 00:14:26,230
dependency this is root node is the iron

00:14:21,709 --> 00:14:30,980
shot and a diamond some deep sea so

00:14:26,230 --> 00:14:34,790
every rise to create if you want to run

00:14:30,980 --> 00:14:36,529
on Linux it is if you want to use

00:14:34,790 --> 00:14:39,350
standard library it depends on deep

00:14:36,529 --> 00:14:42,589
sleep eventually and also there is a

00:14:39,350 --> 00:14:46,220
creek called decimal and this decimal is

00:14:42,589 --> 00:14:51,740
also a sea library and is where rapid

00:14:46,220 --> 00:14:55,370
eyes rest api to iron shop and you may

00:14:51,740 --> 00:14:59,050
look at there some batteries - sis and

00:14:55,370 --> 00:15:01,730
leap loading so leap loading hello some

00:14:59,050 --> 00:15:05,089
external library dynamically in the

00:15:01,730 --> 00:15:07,970
memory space and the call to count the

00:15:05,089 --> 00:15:11,120
unassembled Cal symbol and called a CC

00:15:07,970 --> 00:15:15,519
function so this creates our dangerous

00:15:11,120 --> 00:15:19,370
is not written in rust and it will

00:15:15,519 --> 00:15:24,199
introduce some may introduce some and

00:15:19,370 --> 00:15:25,190
and if I behavior so how to find out

00:15:24,199 --> 00:15:30,200
this

00:15:25,190 --> 00:15:32,780
create you can use color creed to print

00:15:30,200 --> 00:15:35,320
dependent ministry tree and the review

00:15:32,780 --> 00:15:38,350
of them and you can also print out

00:15:35,320 --> 00:15:43,580
verbose they print out the compelling

00:15:38,350 --> 00:15:46,730
compilation process and you can see here

00:15:43,580 --> 00:15:51,350
it'll link it first compiled the decimal

00:15:46,730 --> 00:15:54,350
64 dossier and the link 8 later

00:15:51,350 --> 00:15:59,210
although the I did find some bugs in

00:15:54,350 --> 00:16:02,480
decimal 64 Dorsey but actually a lot of

00:15:59,210 --> 00:16:07,910
raster create depends on this see

00:16:02,480 --> 00:16:12,410
library another case study is from Ross

00:16:07,910 --> 00:16:15,140
ql r SQL is Ross library providing

00:16:12,410 --> 00:16:19,010
secure light related the api's it's

00:16:15,140 --> 00:16:22,580
actually a API wrapper of SS q CQ

00:16:19,010 --> 00:16:26,840
lighter written in C and there's a lot

00:16:22,580 --> 00:16:30,800
depends depend on rescue L and two

00:16:26,840 --> 00:16:33,380
hundred dollars per day and mmm actually

00:16:30,800 --> 00:16:40,390
there's some memory corruption issue in

00:16:33,380 --> 00:16:45,680
rust SQL library which why we tried CVE

00:16:40,390 --> 00:16:50,570
2017 to set 69 and one is a type

00:16:45,680 --> 00:16:52,730
confusion bug in SQLite and we can

00:16:50,570 --> 00:16:55,910
easily figure this bug in our SQL

00:16:52,730 --> 00:17:00,920
because it depends on this library right

00:16:55,910 --> 00:17:04,280
and so you can simply write this kind of

00:17:00,920 --> 00:17:07,550
code in rust and the right it will have

00:17:04,280 --> 00:17:11,420
a segmentation fault so it's already

00:17:07,550 --> 00:17:14,650
patched because the mainstream secured

00:17:11,420 --> 00:17:19,370
light already fix this bug and but the

00:17:14,650 --> 00:17:23,180
last rescue point out pointing to a

00:17:19,370 --> 00:17:27,829
world version of secure lat and they

00:17:23,180 --> 00:17:30,260
upgrade the secure line right now okay

00:17:27,829 --> 00:17:32,870
we do some static

00:17:30,260 --> 00:17:38,040
statistic analysis reflect all the

00:17:32,870 --> 00:17:40,170
create libraries increase at all

00:17:38,040 --> 00:17:44,280
this year in the beginning of this

00:17:40,170 --> 00:17:48,480
series about ten ten thousand thousand

00:17:44,280 --> 00:17:51,120
raster libraries and total 200 million

00:17:48,480 --> 00:17:54,300
public downloads and we do two studies

00:17:51,120 --> 00:17:57,870
first way is you read use usage of

00:17:54,300 --> 00:18:00,900
external C&S a practice library we want

00:17:57,870 --> 00:18:03,870
to see how many cnc prepare every is

00:18:00,900 --> 00:18:06,000
used in discrete and the second one is

00:18:03,870 --> 00:18:08,820
we want to find out the usage of the

00:18:06,000 --> 00:18:16,050
rest keywords okay let's see the first

00:18:08,820 --> 00:18:21,840
one we we try our best to compile all

00:18:16,050 --> 00:18:24,780
the crease and dump the compilation logs

00:18:21,840 --> 00:18:28,860
and to see whether it links like some

00:18:24,780 --> 00:18:31,650
external libraries this is a result the

00:18:28,860 --> 00:18:34,410
most popular mode the two popular

00:18:31,650 --> 00:18:37,230
external library is sleep crypto and the

00:18:34,410 --> 00:18:42,900
device itself so because we don't have a

00:18:37,230 --> 00:18:46,140
rest we have a rusty ice library called

00:18:42,900 --> 00:18:49,440
Russell's but I don't know why a lot of

00:18:46,140 --> 00:18:53,730
rustic read only use open SSL for that

00:18:49,440 --> 00:18:58,080
gesture is connection and for others the

00:18:53,730 --> 00:19:01,950
batteries rink or enhanced open stream

00:18:58,080 --> 00:19:06,270
and the mini see see helper D is a

00:19:01,950 --> 00:19:08,580
dynamic library and helpers curl

00:19:06,270 --> 00:19:13,170
and they when you look at this leverage

00:19:08,580 --> 00:19:16,950
a lot of the crypto libraries and some

00:19:13,170 --> 00:19:26,280
of them zip libraries minis aces zip

00:19:16,950 --> 00:19:28,560
libraries of them see and some of the

00:19:26,280 --> 00:19:32,790
libraries like open SSL there are some

00:19:28,560 --> 00:19:38,130
haste that history in years ago

00:19:32,790 --> 00:19:41,520
heartbleed bugs in open SSL so when you

00:19:38,130 --> 00:19:44,010
use rust crate you need to if you care

00:19:41,520 --> 00:19:49,320
about security you have to look at the

00:19:44,010 --> 00:19:51,870
external libraries okay so how many a

00:19:49,320 --> 00:19:55,740
zip code is just three thousand out

00:19:51,870 --> 00:20:01,730
of ten rust libraries condense and safe

00:19:55,740 --> 00:20:06,420
code and there are 14 fouls in total

00:20:01,730 --> 00:20:09,059
contents and safe code and there's 600

00:20:06,420 --> 00:20:14,460
thousand lines of code and contains a

00:20:09,059 --> 00:20:20,480
zip code and know what happens we have

00:20:14,460 --> 00:20:24,929
learned we we use some create and we've

00:20:20,480 --> 00:20:27,530
found some bugs in some some some of our

00:20:24,929 --> 00:20:31,500
external libraries this park is called

00:20:27,530 --> 00:20:34,590
accosted by the unsafe code and I see

00:20:31,500 --> 00:20:38,300
the first one the first one is not one

00:20:34,590 --> 00:20:43,110
fun than us but it's a zip code in an

00:20:38,300 --> 00:20:46,110
XML library this library is called as XD

00:20:43,110 --> 00:20:49,620
document and you can see from the title

00:20:46,110 --> 00:20:54,990
it is used after three when passing the

00:20:49,620 --> 00:20:58,500
XML document so this back is from the PI

00:20:54,990 --> 00:21:03,420
or faster it will randomly generate some

00:20:58,500 --> 00:21:07,950
XML code and feed through the XML parser

00:21:03,420 --> 00:21:10,679
written in rust and suddenly the car you

00:21:07,950 --> 00:21:13,500
said free so when you look at this issue

00:21:10,679 --> 00:21:18,390
it's a old Israel all the issue about

00:21:13,500 --> 00:21:23,340
two years ago and it is SL water and

00:21:18,390 --> 00:21:26,790
safe code and the second one is the

00:21:23,340 --> 00:21:30,870
popular series in western libraries so

00:21:26,790 --> 00:21:36,440
there are two there are actually three a

00:21:30,870 --> 00:21:39,450
CBE in rust itself two of them is

00:21:36,440 --> 00:21:43,080
standard library the first one is a

00:21:39,450 --> 00:21:47,700
buffer overflow herbal tea in Senna

00:21:43,080 --> 00:21:50,070
library back DQ and for this function

00:21:47,700 --> 00:21:57,950
and you look at the poor request issue

00:21:50,070 --> 00:22:01,980
and the fix you may find out the the

00:21:57,950 --> 00:22:05,320
cost of this issue is a line of and safe

00:22:01,980 --> 00:22:08,769
code but the fix is not

00:22:05,320 --> 00:22:14,740
inside the unsafe code so what we learn

00:22:08,769 --> 00:22:17,950
is that and not the the as if is not

00:22:14,740 --> 00:22:21,460
customized as you code itself it will

00:22:17,950 --> 00:22:23,919
propagate to other safe code because

00:22:21,460 --> 00:22:26,830
there's something data dependency

00:22:23,919 --> 00:22:30,600
between the safe code and unsafe code so

00:22:26,830 --> 00:22:34,090
eventually if you don't if you don't

00:22:30,600 --> 00:22:37,059
carefully implement some unsafe code the

00:22:34,090 --> 00:22:42,519
ice safety will propagate with some safe

00:22:37,059 --> 00:22:45,820
zip code so the second back is the

00:22:42,519 --> 00:22:48,899
standard library string repeat contents

00:22:45,820 --> 00:22:53,039
and so-called relight song Pro

00:22:48,899 --> 00:22:57,519
pre-allocated vector having the capacity

00:22:53,039 --> 00:23:03,789
calculated earlier so this issue is

00:22:57,519 --> 00:23:07,600
pretty complicated and I would say it's

00:23:03,789 --> 00:23:11,799
not easy to stand out fix and defend out

00:23:07,600 --> 00:23:14,649
the reason of this back but when you

00:23:11,799 --> 00:23:17,799
look at this bag we eventually found out

00:23:14,649 --> 00:23:23,799
it is a cost buyer a zip code so this

00:23:17,799 --> 00:23:24,429
the lessons we learn in civvy in Rastan

00:23:23,799 --> 00:23:28,620
the library

00:23:24,429 --> 00:23:33,159
another one is answering at Arctic's

00:23:28,620 --> 00:23:36,100
octaves is a web framework and it's very

00:23:33,159 --> 00:23:38,019
popular but when you look at it we'll

00:23:36,100 --> 00:23:40,809
check the issue we will find this issue

00:23:38,019 --> 00:23:46,210
is very interesting it's a hands-on user

00:23:40,809 --> 00:23:50,289
of as if in AP is so I highlight this

00:23:46,210 --> 00:23:54,519
issue here right now the artist swipe

00:23:50,289 --> 00:23:57,610
call contains hundreds plus uses of

00:23:54,519 --> 00:24:01,090
unsafe presumably this is order of

00:23:57,610 --> 00:24:05,379
achieved to best possible performance in

00:24:01,090 --> 00:24:09,429
Hall Pass in the code but can be reduced

00:24:05,379 --> 00:24:15,220
and safe but remain the performance

00:24:09,429 --> 00:24:18,240
gains and seen hey come up and look at

00:24:15,220 --> 00:24:22,140
the a zip code and

00:24:18,240 --> 00:24:24,600
said I suspect most of this code can be

00:24:22,140 --> 00:24:28,110
made safe there's no performance

00:24:24,600 --> 00:24:34,170
guarantee just we risk constructing same

00:24:28,110 --> 00:24:37,730
things so scene reveal all the acid lies

00:24:34,170 --> 00:24:41,670
and the reconstructed code and remove

00:24:37,730 --> 00:24:44,610
most of the unsafe so at last the last

00:24:41,670 --> 00:24:49,290
it's not a last week the comments in the

00:24:44,610 --> 00:24:52,670
issue last week artist web has over 120

00:24:49,290 --> 00:24:57,900
unsafe as of today all encounters 38

00:24:52,670 --> 00:25:02,880
okay so what this like what is a case

00:24:57,900 --> 00:25:05,460
tell us mmm sometimes you carefully

00:25:02,880 --> 00:25:08,550
design your auditor structure you can

00:25:05,460 --> 00:25:14,040
avoid the ANSI but remain remain the

00:25:08,550 --> 00:25:18,860
performance guarantee so when you want

00:25:14,040 --> 00:25:21,410
to use as if to work from some compiler

00:25:18,860 --> 00:25:25,320
compilation errors think carefully

00:25:21,410 --> 00:25:29,910
cuz we will we may even to do some

00:25:25,320 --> 00:25:32,880
unsafe and into your code and maybe if

00:25:29,910 --> 00:25:36,780
what you want to gain the performance is

00:25:32,880 --> 00:25:41,520
not it's not the only way to use and

00:25:36,780 --> 00:25:43,679
safe code ok so the last one is FFI

00:25:41,520 --> 00:25:45,840
foreign language interface you know a

00:25:43,679 --> 00:25:51,660
library called minis a oxidised

00:25:45,840 --> 00:25:56,400
oq time for this library it is back in

00:25:51,660 --> 00:25:58,679
of rust back in of flea - and there are

00:25:56,400 --> 00:26:01,710
two backends the first way is many say

00:25:58,679 --> 00:26:06,090
mini say is written in c and someone

00:26:01,710 --> 00:26:10,710
will write the mini z and called mini z

00:26:06,090 --> 00:26:14,809
oxidized library and this library is

00:26:10,710 --> 00:26:18,809
also used to buy our tyson

00:26:14,809 --> 00:26:22,650
implementation so i found out that the

00:26:18,809 --> 00:26:25,800
there's a tab confusion in the capi of

00:26:22,650 --> 00:26:30,090
this library this means this means that

00:26:25,800 --> 00:26:31,299
when you the inflated state and the

00:26:30,090 --> 00:26:33,759
deflate come

00:26:31,299 --> 00:26:35,259
compressor state constructor not

00:26:33,759 --> 00:26:37,539
consistent

00:26:35,259 --> 00:26:40,179
it will cause a tap confusion confusion

00:26:37,539 --> 00:26:43,360
issue when calling deflate with the

00:26:40,179 --> 00:26:46,320
inflated stream using the capi resulting

00:26:43,360 --> 00:26:49,840
a double free crash for this case is

00:26:46,320 --> 00:26:53,889
isn't it's different because for this

00:26:49,840 --> 00:26:56,919
library not just to provide the rest api

00:26:53,889 --> 00:27:02,289
to rust developer it also provides c

00:26:56,919 --> 00:27:07,269
compatible api for C developers so the

00:27:02,289 --> 00:27:11,230
the they also want to provide a safe zip

00:27:07,269 --> 00:27:14,019
library for not just a rust developer

00:27:11,230 --> 00:27:18,549
but for CNC prefers to be a developer

00:27:14,019 --> 00:27:22,600
but the problem is that you cannot

00:27:18,549 --> 00:27:27,450
control the data provided by say side

00:27:22,600 --> 00:27:33,009
right you can provide the malicious

00:27:27,450 --> 00:27:39,249
memories memory space to the rest for

00:27:33,009 --> 00:27:44,200
this one is it's a popular pattern for

00:27:39,249 --> 00:27:48,460
in C you use the API to create memory

00:27:44,200 --> 00:27:50,889
and like OpenSSL meaning they they do

00:27:48,460 --> 00:27:53,619
the same you call first called api

00:27:50,889 --> 00:27:56,320
called initialize the initialized api

00:27:53,619 --> 00:27:59,350
will give you a memory and the second

00:27:56,320 --> 00:28:04,480
you use this memory memory as a context

00:27:59,350 --> 00:28:08,769
and the second api for example zip it

00:28:04,480 --> 00:28:12,730
will provide this context memory to that

00:28:08,769 --> 00:28:16,090
api to do some zip and unzip at last you

00:28:12,730 --> 00:28:21,429
need to end you need to deallocate the

00:28:16,090 --> 00:28:24,309
context but for this case it's not that

00:28:21,429 --> 00:28:27,730
easy to handle in rust because rust

00:28:24,309 --> 00:28:31,830
maintained their own memory allocation

00:28:27,730 --> 00:28:35,139
de-allocation if we want to provide the

00:28:31,830 --> 00:28:38,230
memory even if we want to allocate the

00:28:35,139 --> 00:28:41,379
memory inside russ and gave this memory

00:28:38,230 --> 00:28:44,289
to outside to see and later the

00:28:41,379 --> 00:28:45,519
allocated is memory inside the rust it's

00:28:44,289 --> 00:28:50,360
pretty difficult

00:28:45,519 --> 00:28:53,630
design our safe capi because sometimes

00:28:50,360 --> 00:28:56,299
you there's something wrong in Seaside

00:28:53,630 --> 00:28:59,149
and there will be a malicious structure

00:28:56,299 --> 00:29:03,649
provided to you you if you D allocate

00:28:59,149 --> 00:29:06,049
that like point like a non pointer so

00:29:03,649 --> 00:29:09,169
there will be a non point of our

00:29:06,049 --> 00:29:12,429
dereference and for this package so

00:29:09,169 --> 00:29:16,880
double free crash and for this part

00:29:12,429 --> 00:29:22,059
actually working with author to find out

00:29:16,880 --> 00:29:28,370
a good way to fix this type of confusion

00:29:22,059 --> 00:29:32,299
issue and we actually there are many

00:29:28,370 --> 00:29:35,870
discussion with the officer we just

00:29:32,299 --> 00:29:38,539
found a good solution to solve this

00:29:35,870 --> 00:29:43,700
issue but it's quite difficult to read

00:29:38,539 --> 00:29:51,700
this kind of API okay this is a four

00:29:43,700 --> 00:29:56,269
lessons so for the rest community do we

00:29:51,700 --> 00:30:00,559
care about security yes right it's not

00:29:56,269 --> 00:30:05,269
about raster programming language itself

00:30:00,559 --> 00:30:07,220
it's about the rest code for example in

00:30:05,269 --> 00:30:10,610
the latest the website there's a rad

00:30:07,220 --> 00:30:13,580
security policy and it defines how to

00:30:10,610 --> 00:30:17,120
report backs of rust and a library and

00:30:13,580 --> 00:30:20,960
rust compiler and the whole process the

00:30:17,120 --> 00:30:22,730
hope policy and the second is a google

00:30:20,960 --> 00:30:25,909
group called roster security

00:30:22,730 --> 00:30:28,610
announcement and there are only several

00:30:25,909 --> 00:30:30,830
civilian Osment in this group right now

00:30:28,610 --> 00:30:34,220
and the third one called

00:30:30,830 --> 00:30:38,509
rust ii would add weather advisory

00:30:34,220 --> 00:30:43,789
database for this database it contains

00:30:38,509 --> 00:30:48,710
some like memory issue backs of crease

00:30:43,789 --> 00:30:51,919
and later you can use cargo audit audit

00:30:48,710 --> 00:30:54,679
all your dependencies if this dependency

00:30:51,919 --> 00:30:58,610
contains some security issue inside the

00:30:54,679 --> 00:31:03,860
database so if you find out some

00:30:58,610 --> 00:31:06,799
crash and like double free and the tab

00:31:03,860 --> 00:31:11,210
confusion so and so forth this kind of

00:31:06,799 --> 00:31:16,250
back please report to drastic advisory

00:31:11,210 --> 00:31:19,279
database the last way rustic-y called

00:31:16,250 --> 00:31:21,529
the working group and this working group

00:31:19,279 --> 00:31:25,940
when they focus on how to improve the

00:31:21,529 --> 00:31:29,029
security secure code and also there are

00:31:25,940 --> 00:31:35,000
a project called the rust fast project

00:31:29,029 --> 00:31:37,850
and fast fast is a good tool for testing

00:31:35,000 --> 00:31:40,760
and the ACS out also good to to fund

00:31:37,850 --> 00:31:44,240
some security or world bilities we would

00:31:40,760 --> 00:31:46,460
talk about later so there are certain

00:31:44,240 --> 00:31:53,889
open questions we after talking about

00:31:46,460 --> 00:31:58,159
this lessons and one questions is can be

00:31:53,889 --> 00:32:00,169
translated say to rust automatically and

00:31:58,159 --> 00:32:04,720
currently there are one project called

00:32:00,169 --> 00:32:08,120
c2 rust is successfully can successfully

00:32:04,720 --> 00:32:11,899
translate say to rust but all the rust

00:32:08,120 --> 00:32:15,590
is as if rust you can the question is

00:32:11,899 --> 00:32:19,279
can we use some static analysis method

00:32:15,590 --> 00:32:21,679
to reduce sensitive rust and the second

00:32:19,279 --> 00:32:25,159
one is safety and security in rust

00:32:21,679 --> 00:32:28,880
compiler and the standard library for

00:32:25,159 --> 00:32:32,059
this open questions is is about the

00:32:28,880 --> 00:32:35,120
compiler itself when you look at the

00:32:32,059 --> 00:32:39,580
issue of compiler there's a label called

00:32:35,120 --> 00:32:43,130
and soundness and there's a bomb emoji

00:32:39,580 --> 00:32:48,470
beside on Sundays so so there's a

00:32:43,130 --> 00:32:52,330
problem of rust compiler in for example

00:32:48,470 --> 00:32:57,320
in nightly someone introduced new syntax

00:32:52,330 --> 00:32:59,779
the rust compiler itself failed to check

00:32:57,320 --> 00:33:02,559
the memory safety of the code the

00:32:59,779 --> 00:33:05,990
borrowed checker failed to check some

00:33:02,559 --> 00:33:08,620
unsafe code so this is called an Sundays

00:33:05,990 --> 00:33:13,960
in the US compiler so

00:33:08,620 --> 00:33:17,169
there will if you occurs about this park

00:33:13,960 --> 00:33:19,390
you can search as soon as in the wrath

00:33:17,169 --> 00:33:21,809
compiler issue and this is very

00:33:19,390 --> 00:33:25,929
interesting and it's very interesting to

00:33:21,809 --> 00:33:28,330
fix this back because it will be such a

00:33:25,929 --> 00:33:30,760
will introduce some legacy problem and

00:33:28,330 --> 00:33:34,750
the second one is standard library

00:33:30,760 --> 00:33:37,980
issues for example the to see Vee in

00:33:34,750 --> 00:33:42,640
last standard library and there are many

00:33:37,980 --> 00:33:45,700
private in C and C practice how to

00:33:42,640 --> 00:33:50,950
ensure the city of standard libraries so

00:33:45,700 --> 00:33:52,929
can be used that methodology to to go

00:33:50,950 --> 00:33:56,830
through of standard library and the make

00:33:52,929 --> 00:34:01,059
sure it is safe and the third one is

00:33:56,830 --> 00:34:04,929
unsafe trust code analysis so there are

00:34:01,059 --> 00:34:10,000
a lot of code analysis tools method from

00:34:04,929 --> 00:34:16,780
industry and academia and how to do this

00:34:10,000 --> 00:34:20,320
code analysis is is I would say it is

00:34:16,780 --> 00:34:23,470
simpler than doing code analysis in C

00:34:20,320 --> 00:34:26,980
and C practice right because for us

00:34:23,470 --> 00:34:31,690
there is no aliasing problem so it's

00:34:26,980 --> 00:34:35,740
easy to to do some to apply some simple

00:34:31,690 --> 00:34:40,889
code analysis algorithm and also for

00:34:35,740 --> 00:34:44,440
dynamic analysis rust there's a middle

00:34:40,889 --> 00:34:48,580
middle level IR and someone read a

00:34:44,440 --> 00:34:52,349
middle level are executed interpreter

00:34:48,580 --> 00:34:56,679
you can write some plugins and some

00:34:52,349 --> 00:35:00,490
iteration on the under the interpreter

00:34:56,679 --> 00:35:03,070
to check the code dynamically and the

00:35:00,490 --> 00:35:06,550
force came into some sandbox and

00:35:03,070 --> 00:35:08,190
isolation on unsafe code so this is a

00:35:06,550 --> 00:35:10,810
big question

00:35:08,190 --> 00:35:14,339
it's not about engineering it's about

00:35:10,810 --> 00:35:19,540
like academic research

00:35:14,339 --> 00:35:21,720
Koskov a cause rust code is because it's

00:35:19,540 --> 00:35:24,480
as if we want we don't

00:35:21,720 --> 00:35:28,080
cannot guarantee the safety but a

00:35:24,480 --> 00:35:30,740
compiler can we do some sandbox and make

00:35:28,080 --> 00:35:34,580
sure the memory shared between the

00:35:30,740 --> 00:35:39,690
active and the safe can be easily

00:35:34,580 --> 00:35:43,650
decoupled the last last released one is

00:35:39,690 --> 00:35:47,580
a formal verification there are a lot of

00:35:43,650 --> 00:35:52,320
tools to formally verify C and the C PAP

00:35:47,580 --> 00:35:55,109
has and can we do it in rust last ones

00:35:52,320 --> 00:35:57,810
memory safety crossbow responder is for

00:35:55,109 --> 00:36:01,380
example between C and the rest between

00:35:57,810 --> 00:36:04,050
Java and rest and personalized for all

00:36:01,380 --> 00:36:05,040
of these questions there's a lot of

00:36:04,050 --> 00:36:09,119
pre-work

00:36:05,040 --> 00:36:11,400
mentioned mentioned in the academic so

00:36:09,119 --> 00:36:14,400
there's a lot of papers talking about

00:36:11,400 --> 00:36:17,520
like for example memory sift across the

00:36:14,400 --> 00:36:22,670
web we're sponsoring a lot of papers are

00:36:17,520 --> 00:36:27,359
doing between Java and C is called gni

00:36:22,670 --> 00:36:31,650
how to ensure the jhene aiko days safe

00:36:27,359 --> 00:36:37,820
and formal verification there's some

00:36:31,650 --> 00:36:44,130
work on formally verified a LVM aha so

00:36:37,820 --> 00:36:45,960
this work a lot work from academic there

00:36:44,130 --> 00:36:48,270
are some existing project I want to

00:36:45,960 --> 00:36:51,330
introduce to you for the formal

00:36:48,270 --> 00:36:56,250
verification the first verification to

00:36:51,330 --> 00:36:59,220
of rust is called a rasp out and you can

00:36:56,250 --> 00:37:01,830
use caulk to formulate verify some

00:36:59,220 --> 00:37:05,000
rastko to manually write in some

00:37:01,830 --> 00:37:12,000
precondition a post condition and also

00:37:05,000 --> 00:37:14,820
there's tool called if there's a tool to

00:37:12,000 --> 00:37:18,240
formerly worth iris program use Mac and

00:37:14,820 --> 00:37:22,080
thus Mac is formal verification

00:37:18,240 --> 00:37:26,040
framework based on our VM so for this

00:37:22,080 --> 00:37:32,190
one there's a paper online so for this

00:37:26,040 --> 00:37:35,570
one what they do is to reduce the gap

00:37:32,190 --> 00:37:40,070
between the romantic or and the

00:37:35,570 --> 00:37:47,320
I are so for example the rascal powder

00:37:40,070 --> 00:37:51,740
will count will pack 2 - I ate in one I

00:37:47,320 --> 00:37:59,360
succeed in our way I are so for this

00:37:51,740 --> 00:38:02,110
work the outer glue this gap and do four

00:37:59,360 --> 00:38:05,750
more application on raster program and

00:38:02,110 --> 00:38:11,690
the third one is called rata C and this

00:38:05,750 --> 00:38:15,140
is the latest work way by the work ways

00:38:11,690 --> 00:38:20,240
until national technology University in

00:38:15,140 --> 00:38:22,850
Singapore and what we do is - we want to

00:38:20,240 --> 00:38:24,680
keep the semantics of the rest and do

00:38:22,850 --> 00:38:31,700
for more verification automatically

00:38:24,680 --> 00:38:36,770
basalt with limited many menu menu

00:38:31,700 --> 00:38:39,410
access it compared to rest about view we

00:38:36,770 --> 00:38:42,830
need to write the clock preconditions

00:38:39,410 --> 00:38:45,620
and there are also other formal

00:38:42,830 --> 00:38:49,520
application framework like C horn is

00:38:45,620 --> 00:38:53,120
also open source academic project and it

00:38:49,520 --> 00:38:56,420
is also based on Alabama ir and we tried

00:38:53,120 --> 00:39:01,520
to use this tool to former fi some

00:38:56,420 --> 00:39:06,200
raster code and export ir and the verify

00:39:01,520 --> 00:39:08,890
see how is it works it works and in some

00:39:06,200 --> 00:39:12,590
work to build the gap between air and

00:39:08,890 --> 00:39:15,980
another framework

00:39:12,590 --> 00:39:19,000
so besides from replication for passing

00:39:15,980 --> 00:39:25,010
there are some fastening project called

00:39:19,000 --> 00:39:29,210
someone and have already bring a FL home

00:39:25,010 --> 00:39:33,980
fast a family professor to rust project

00:39:29,210 --> 00:39:37,040
so a lot of rust create use rust protect

00:39:33,980 --> 00:39:40,730
to do some fasten to make sure there's

00:39:37,040 --> 00:39:43,760
no and intentionally and wrap and

00:39:40,730 --> 00:39:47,470
there's no memory safety issues so

00:39:43,760 --> 00:39:52,040
there's a page called trophy case and

00:39:47,470 --> 00:39:58,130
there's a big table list that the backs

00:39:52,040 --> 00:40:01,660
found by the father so for the code

00:39:58,130 --> 00:40:05,600
analysis there's a project called memory

00:40:01,660 --> 00:40:08,030
memory so is a interpreter of the rest

00:40:05,600 --> 00:40:12,350
middle level in the mini presentation

00:40:08,030 --> 00:40:15,020
Mir and this mirror is dynamic code

00:40:12,350 --> 00:40:19,490
analysis tools it can find out about

00:40:15,020 --> 00:40:22,130
memory access and use are free and it

00:40:19,490 --> 00:40:25,310
have fun imagine use initialize data and

00:40:22,130 --> 00:40:31,460
some other memory city issues but for

00:40:25,310 --> 00:40:34,040
this to is dynamic code analysis and for

00:40:31,460 --> 00:40:37,490
static code analysis I'd I haven't heard

00:40:34,040 --> 00:40:41,660
some tools to do that but if you heard

00:40:37,490 --> 00:40:43,900
come and talk to me and other tools this

00:40:41,660 --> 00:40:47,470
Y is called cago gagger

00:40:43,900 --> 00:40:53,450
for this tool it will print out all the

00:40:47,470 --> 00:40:56,870
unsafe code of your dependencies and it

00:40:53,450 --> 00:41:00,700
is useful sometimes when you want to

00:40:56,870 --> 00:41:05,180
have create a highly reliable and secure

00:41:00,700 --> 00:41:07,910
code and the in the in in no company if

00:41:05,180 --> 00:41:09,980
you want to review all the code of

00:41:07,910 --> 00:41:15,160
dependency you can use this code to

00:41:09,980 --> 00:41:19,790
print out order and safety code okay so

00:41:15,160 --> 00:41:22,970
speaking about the academic papers so

00:41:19,790 --> 00:41:25,550
I'm from academic and I read a lot of

00:41:22,970 --> 00:41:28,310
papers of programming language code

00:41:25,550 --> 00:41:32,290
analysis and security so actually I

00:41:28,310 --> 00:41:36,140
summarized some papers about rust and

00:41:32,290 --> 00:41:41,260
create a link if you are interested to

00:41:36,140 --> 00:41:45,290
read some papers in academic so you can

00:41:41,260 --> 00:41:50,510
you can fend off and some papers in C

00:41:45,290 --> 00:41:53,780
stink okay to conclude this talk I first

00:41:50,510 --> 00:41:56,240
talked up briefly talk about the

00:41:53,780 --> 00:41:59,869
rust and how do you start to build safe

00:41:56,240 --> 00:42:01,940
and secure system and also I I want to

00:41:59,869 --> 00:42:06,470
raise some challenges and license

00:42:01,940 --> 00:42:13,130
learned and open questions so the melody

00:42:06,470 --> 00:42:15,440
goes office talk to want to raise one to

00:42:13,130 --> 00:42:18,530
raise a concern of the security

00:42:15,440 --> 00:42:26,320
researchers you have to look carefully

00:42:18,530 --> 00:42:29,660
of the roster code and I mainly want to

00:42:26,320 --> 00:42:33,140
reset if you have time to look at code

00:42:29,660 --> 00:42:37,490
analysis and implement some static

00:42:33,140 --> 00:42:40,849
analysis tool for rust and come up some

00:42:37,490 --> 00:42:44,630
good ideas to sandbox and isolated isof

00:42:40,849 --> 00:42:47,900
code so on that's without that said

00:42:44,630 --> 00:42:51,510
let's that's all that's my talk so any

00:42:47,900 --> 00:42:55,670
questions you can ask

00:42:51,510 --> 00:42:58,550
[Applause]

00:42:55,670 --> 00:43:10,960
we have time for one or maybe two

00:42:58,550 --> 00:43:17,690
questions I you have mentioned that

00:43:10,960 --> 00:43:20,270
problem in mini-z library when you get a

00:43:17,690 --> 00:43:23,420
malicious pointer from the seaside and

00:43:20,270 --> 00:43:25,280
you told that you find this solution

00:43:23,420 --> 00:43:33,050
could you please describe it a little

00:43:25,280 --> 00:43:38,030
yeah basically there are many many

00:43:33,050 --> 00:43:42,110
solutions to avoid this issue and for

00:43:38,030 --> 00:43:47,870
this case what we want to do is to make

00:43:42,110 --> 00:43:52,010
sure the actually way you can think

00:43:47,870 --> 00:43:55,730
about the whole memory we have a TAC two

00:43:52,010 --> 00:43:58,750
TAC the the memory region to attack the

00:43:55,730 --> 00:44:02,510
structure the tech the pointer if it is

00:43:58,750 --> 00:44:10,580
zip context it is zip context or it is

00:44:02,510 --> 00:44:15,400
unzip context so if you pass wrong or

00:44:10,580 --> 00:44:19,970
malicious context you will panic of

00:44:15,400 --> 00:44:24,110
report of field so that's one solution

00:44:19,970 --> 00:44:27,380
is not worried graceful and there are

00:44:24,110 --> 00:44:33,100
other solutions like you can use hash

00:44:27,380 --> 00:44:36,190
you can use tagging of the memory and

00:44:33,100 --> 00:44:40,310
actually in optimally so memory hacking

00:44:36,190 --> 00:44:46,370
you can use this method to tag all the

00:44:40,310 --> 00:44:49,760
memory from rust to see and you can

00:44:46,370 --> 00:44:52,490
check the tagging of that memory in rust

00:44:49,760 --> 00:44:54,910
and to see whether it is malicious or

00:44:52,490 --> 00:44:54,910

YouTube URL: https://www.youtube.com/watch?v=Bja9--oD9Mo


