Title: Rustâ€™s approach of getting things right. Pascal Hertleif
Publication date: 2019-02-06
Playlist: RustRush 2018
Description: 
	Pascal is the lead of CLI Working Group in Rust project. He's author and contributor of many Rust crates. Pascal also is co-organizer of Rust Cologne meetup.

This is a talk on how Rust doesn't invent a lot of new stuff. Rust itself isn't a new invention, really. It borrowed (pun intended!) a lot from Cyclone and ATS. And that set the tone for the community. Don't let "Not Invented Here" rule your decisions. Instead, take something academic, or something good but unergonomic, or something just not widely known, adapt it for mainstream - and it's golden!
Captions: 
	00:00:02,590 --> 00:00:08,559
yeah thank y'all for coming I hope you

00:00:04,990 --> 00:00:11,259
are still awake somehow I'm super tired

00:00:08,559 --> 00:00:15,490
so I'm sorry if I'm not moving around a

00:00:11,259 --> 00:00:18,070
lot today so today I want to talk to you

00:00:15,490 --> 00:00:21,370
about what I consider to be a rust

00:00:18,070 --> 00:00:22,330
approach of getting things right but

00:00:21,370 --> 00:00:25,180
first things first

00:00:22,330 --> 00:00:27,280
my name is Pascal hard life and countly

00:00:25,180 --> 00:00:31,990
involved in the dev tools team of the

00:00:27,280 --> 00:00:34,870
Ross project so if you have ideas or

00:00:31,990 --> 00:00:37,539
issues with any tooling around Russ

00:00:34,870 --> 00:00:39,969
please talk to me also this year I've

00:00:37,539 --> 00:00:42,760
been managing the still I work in group

00:00:39,969 --> 00:00:45,489
which currently is trying to make

00:00:42,760 --> 00:00:48,249
commands and applications really really

00:00:45,489 --> 00:00:49,780
easy to develop and rust if you've tried

00:00:48,249 --> 00:00:51,909
to write a commercial application and

00:00:49,780 --> 00:00:55,359
rust and had some idea so issues there

00:00:51,909 --> 00:00:57,100
as well please come talk to me too on

00:00:55,359 --> 00:01:02,800
the internet you can find me on these

00:00:57,100 --> 00:01:03,219
URLs and with that let's get right into

00:01:02,800 --> 00:01:08,439
it

00:01:03,219 --> 00:01:11,590
so the Torx title is how rust managed to

00:01:08,439 --> 00:01:16,180
get things right which is pretty

00:01:11,590 --> 00:01:19,149
presumptuous and well you may be asking

00:01:16,180 --> 00:01:23,140
yourself what was I thinking like how

00:01:19,149 --> 00:01:25,000
can this random dude on stage deliver a

00:01:23,140 --> 00:01:28,060
talk on how to actually write at the

00:01:25,000 --> 00:01:30,340
perfect program and well I'm sorry to

00:01:28,060 --> 00:01:32,950
disappoint that's not why I'm here I'm

00:01:30,340 --> 00:01:36,909
not going to give a very technical talk

00:01:32,950 --> 00:01:39,820
at all and it's not going to contain any

00:01:36,909 --> 00:01:42,579
code what I instead want to talk to you

00:01:39,820 --> 00:01:47,439
about this basically a bunch of cool

00:01:42,579 --> 00:01:52,479
projects and how they manage to become

00:01:47,439 --> 00:01:55,149
really really ambitious projects that

00:01:52,479 --> 00:01:56,039
presents the rust community in a very

00:01:55,149 --> 00:02:02,439
good way

00:01:56,039 --> 00:02:05,439
so why gives this talk now Russ is still

00:02:02,439 --> 00:02:08,789
pretty young even though we just had

00:02:05,439 --> 00:02:11,830
like this big release of rust 2018 and

00:02:08,789 --> 00:02:14,290
it seems like we have figured out what

00:02:11,830 --> 00:02:16,420
Russ is supposed to do and how good

00:02:14,290 --> 00:02:18,700
code is supposed to look like I am

00:02:16,420 --> 00:02:22,180
pretty sure that we still have a lot to

00:02:18,700 --> 00:02:27,189
learn and a lot to gain from continuing

00:02:22,180 --> 00:02:30,010
to learn discover new ideas so to go

00:02:27,189 --> 00:02:35,019
even one step further back I want to ask

00:02:30,010 --> 00:02:37,810
what is rust and previously on the rust

00:02:35,019 --> 00:02:39,609
website it says it's systems programming

00:02:37,810 --> 00:02:41,769
language that runs blazingly fast to run

00:02:39,609 --> 00:02:44,829
sec volts and current ease thread safety

00:02:41,769 --> 00:02:48,239
and you probably have read that at some

00:02:44,829 --> 00:02:50,799
point in your life and felt like cool

00:02:48,239 --> 00:02:52,389
really cool like this is a bunch of cool

00:02:50,799 --> 00:02:55,750
features but what does it actually do

00:02:52,389 --> 00:02:59,290
from me the current version of the rust

00:02:55,750 --> 00:03:01,930
website changes the slogan to be a bit

00:02:59,290 --> 00:03:05,079
indifferent going into a different

00:03:01,930 --> 00:03:08,230
direction it's right now says beneath

00:03:05,079 --> 00:03:10,389
the rust logo it's empowering everyone

00:03:08,230 --> 00:03:13,900
to build reliable and efficient software

00:03:10,389 --> 00:03:16,419
this is less of a feature list and it

00:03:13,900 --> 00:03:19,000
tells you how rust helps you yourself

00:03:16,419 --> 00:03:21,430
and really finds this to be a very good

00:03:19,000 --> 00:03:24,819
way to describe what Russ is about but

00:03:21,430 --> 00:03:27,250
as always in talks you should not

00:03:24,819 --> 00:03:30,310
present two points you should always go

00:03:27,250 --> 00:03:33,729
for Lexie tree factor of three points

00:03:30,310 --> 00:03:36,669
and I asked well what is another

00:03:33,729 --> 00:03:39,280
interesting idea to describe rust and I

00:03:36,669 --> 00:03:41,889
went back to the past and looked at how

00:03:39,280 --> 00:03:44,019
the inventor of rust first described

00:03:41,889 --> 00:03:49,209
what the programming language was about

00:03:44,019 --> 00:03:52,269
and he said rust is technology from the

00:03:49,209 --> 00:03:56,550
past come to save the future from itself

00:03:52,269 --> 00:03:58,740
and you may be like what

00:03:56,550 --> 00:04:02,700
like what did great and even mean by

00:03:58,740 --> 00:04:05,400
that okay okay fine surprisingly enough

00:04:02,700 --> 00:04:08,670
he goes on in this email announcing this

00:04:05,400 --> 00:04:10,920
new programming language and he said

00:04:08,670 --> 00:04:13,080
like well there are a lot of older

00:04:10,920 --> 00:04:14,910
languages that do very cool stuff and

00:04:13,080 --> 00:04:17,820
new languages that are more simplistic

00:04:14,910 --> 00:04:21,209
and somehow we we keep forgetting

00:04:17,820 --> 00:04:23,190
already learned lessons and I felt like

00:04:21,209 --> 00:04:27,210
this is something I wanted to give a

00:04:23,190 --> 00:04:29,340
talk about so I have this promise that

00:04:27,210 --> 00:04:32,370
the Russ community is really good at

00:04:29,340 --> 00:04:34,340
looking at prior art and if you're not

00:04:32,370 --> 00:04:38,100
familiar with the phrase in English

00:04:34,340 --> 00:04:39,810
prior art is recalling to the capito all

00:04:38,100 --> 00:04:42,500
the information that has been made

00:04:39,810 --> 00:04:45,630
available to the public in any form

00:04:42,500 --> 00:04:47,880
before a given date that might be

00:04:45,630 --> 00:04:49,760
relevant to a patents claim of

00:04:47,880 --> 00:04:52,350
originality

00:04:49,760 --> 00:04:54,530
so it's from patent law basically like

00:04:52,350 --> 00:04:56,910
if you wanted to invent some new

00:04:54,530 --> 00:04:58,560
technology and had to prove to the

00:04:56,910 --> 00:05:02,310
Patent Office that this is actually

00:04:58,560 --> 00:05:06,690
original art you had to also look at

00:05:02,310 --> 00:05:08,760
prior art okay but luckily enough we are

00:05:06,690 --> 00:05:11,100
dealing with software and aside from

00:05:08,760 --> 00:05:15,330
some weird patent cases around software

00:05:11,100 --> 00:05:17,520
we often have like access to cool

00:05:15,330 --> 00:05:20,280
research material open-source

00:05:17,520 --> 00:05:23,850
implementations and the bunch of

00:05:20,280 --> 00:05:25,830
different ways to figure out how someone

00:05:23,850 --> 00:05:29,760
else tried to solve this problem we are

00:05:25,830 --> 00:05:32,550
looking at and you may have heard of

00:05:29,760 --> 00:05:37,070
this quote by Picasso who said good

00:05:32,550 --> 00:05:39,450
artists copy great artists steal and

00:05:37,070 --> 00:05:41,340
luckily like stealing and software is

00:05:39,450 --> 00:05:42,690
very different from stealing in the real

00:05:41,340 --> 00:05:44,340
world because you're not taking

00:05:42,690 --> 00:05:47,730
something away you're only making a copy

00:05:44,340 --> 00:05:52,020
after all which is good because we can

00:05:47,730 --> 00:05:53,220
improve everything and not just swap one

00:05:52,020 --> 00:05:57,600
thing for another

00:05:53,220 --> 00:06:02,250
so we don't have to reinvent everything

00:05:57,600 --> 00:06:04,770
we can check out existing ideas and try

00:06:02,250 --> 00:06:08,270
to come up with ways that they might

00:06:04,770 --> 00:06:10,080
make sense in our current new context

00:06:08,270 --> 00:06:13,050
because you might

00:06:10,080 --> 00:06:15,810
also feel familiar with this idea of

00:06:13,050 --> 00:06:20,819
some person on a team who looks at a

00:06:15,810 --> 00:06:23,639
problem and and they go away for some

00:06:20,819 --> 00:06:26,819
time and they show up a week later and

00:06:23,639 --> 00:06:28,770
say okay I've solved it and you have no

00:06:26,819 --> 00:06:30,960
idea what happened like apparently they

00:06:28,770 --> 00:06:34,169
sat down in some empty room and like

00:06:30,960 --> 00:06:36,090
figure it out all on themselves and for

00:06:34,169 --> 00:06:37,770
some domain-specific problems like if

00:06:36,090 --> 00:06:39,569
you have a very specific business case

00:06:37,770 --> 00:06:42,449
this is a totally fine approach it might

00:06:39,569 --> 00:06:45,360
even be the best approach because after

00:06:42,449 --> 00:06:48,180
all your business should try to do some

00:06:45,360 --> 00:06:50,129
original stuff but there are a lot of

00:06:48,180 --> 00:06:53,090
general concepts we can actually try to

00:06:50,129 --> 00:06:57,330
improve and four general concepts it

00:06:53,090 --> 00:07:01,889
tries it is a good idea to to get rid of

00:06:57,330 --> 00:07:06,629
this approach of not looking sideways we

00:07:01,889 --> 00:07:08,219
can often times try to not say okay this

00:07:06,629 --> 00:07:11,219
is bad because it's not invented here

00:07:08,219 --> 00:07:15,259
and say this is good because we know all

00:07:11,219 --> 00:07:18,840
the facts and all the projects around us

00:07:15,259 --> 00:07:21,150
and also this is not rewrite it in

00:07:18,840 --> 00:07:23,729
Rostock because you might be saying okay

00:07:21,150 --> 00:07:27,659
fine I've looked at this implementation

00:07:23,729 --> 00:07:29,099
here and it's in C so I rewrote the

00:07:27,659 --> 00:07:31,740
exact same thing in Ross and now it's

00:07:29,099 --> 00:07:35,430
good no that's not what I'm saying

00:07:31,740 --> 00:07:37,710
either and it's supposed to be talks

00:07:35,430 --> 00:07:40,979
where I am convincing you to be curious

00:07:37,710 --> 00:07:43,409
and try out weird science and I hope I

00:07:40,979 --> 00:07:47,849
managed to at least feature interest in

00:07:43,409 --> 00:07:51,270
some of it okay okay okay let's settle

00:07:47,849 --> 00:07:55,919
down and be actual and look at concrete

00:07:51,270 --> 00:07:56,819
issues for example you know that the

00:07:55,919 --> 00:08:01,440
borrowed checker

00:07:56,819 --> 00:08:05,370
likes this concept of having ownership

00:08:01,440 --> 00:08:07,590
and borrows inside the type system this

00:08:05,370 --> 00:08:09,840
is one of rusts main selling points

00:08:07,590 --> 00:08:12,779
because the problem it tries to solve is

00:08:09,840 --> 00:08:15,960
that we want to have high-performance

00:08:12,779 --> 00:08:20,969
code but don't want to have memory

00:08:15,960 --> 00:08:23,290
safety issues and most people are saying

00:08:20,969 --> 00:08:25,750
have only ever been

00:08:23,290 --> 00:08:28,750
this concept of ownership and borrowing

00:08:25,750 --> 00:08:31,570
by rust but it's actually not rusts own

00:08:28,750 --> 00:08:35,260
invention in fact there was also prior

00:08:31,570 --> 00:08:36,640
art for that you might have seen in the

00:08:35,260 --> 00:08:39,280
description of the storks that I

00:08:36,640 --> 00:08:43,419
mentioned cyclone and cyclone is

00:08:39,280 --> 00:08:46,690
actually an interesting language like

00:08:43,419 --> 00:08:49,960
it's supposed to be a safe sea which has

00:08:46,690 --> 00:08:52,180
some interesting alternative pointer

00:08:49,960 --> 00:08:56,620
types for example pointers that are

00:08:52,180 --> 00:08:59,170
proven never to be now and it arises by

00:08:56,620 --> 00:08:59,680
doing region analysis it's really

00:08:59,170 --> 00:09:02,520
interesting

00:08:59,680 --> 00:09:06,250
it was developed at AT&T Labs in 2002

00:09:02,520 --> 00:09:10,120
but looking at your faces you've not

00:09:06,250 --> 00:09:13,810
heard of it why is that okay

00:09:10,120 --> 00:09:17,890
another interesting interesting weird

00:09:13,810 --> 00:09:23,170
language is 80s this is one of those

00:09:17,890 --> 00:09:25,870
languages that is an alien spy out like

00:09:23,170 --> 00:09:30,070
if you've ever used a camel did you know

00:09:25,870 --> 00:09:32,260
how it might behave and the one thing

00:09:30,070 --> 00:09:34,840
that sets this language apart is that it

00:09:32,260 --> 00:09:38,050
had a built in Siri improver basically

00:09:34,840 --> 00:09:40,060
the type system was not very very

00:09:38,050 --> 00:09:42,520
powerful though actually being able to

00:09:40,060 --> 00:09:45,370
proof your programs so it went all in

00:09:42,520 --> 00:09:47,800
and said okay if we have a type system

00:09:45,370 --> 00:09:50,740
that's powerful enough to prove like the

00:09:47,800 --> 00:09:53,230
absence of buffer overflows we can have

00:09:50,740 --> 00:09:57,100
a safe programming language too and

00:09:53,230 --> 00:09:59,200
funnily enough it was really fast like

00:09:57,100 --> 00:10:02,680
there are some simplistic benchmarks

00:09:59,200 --> 00:10:04,450
where it runs as fast as C because all

00:10:02,680 --> 00:10:08,700
the checking is done at compile time

00:10:04,450 --> 00:10:14,680
which is something a trust also does and

00:10:08,700 --> 00:10:17,350
I've found this great quote from Philip

00:10:14,680 --> 00:10:19,900
Butler who is a professor of theoretical

00:10:17,350 --> 00:10:23,890
computer science at the University of

00:10:19,900 --> 00:10:25,840
adding rows and he said logicians

00:10:23,890 --> 00:10:28,570
usually gets there before computer

00:10:25,840 --> 00:10:30,730
scientists and it's funny because he is

00:10:28,570 --> 00:10:34,120
a computer scientist and one other

00:10:30,730 --> 00:10:35,740
interesting field you could look at when

00:10:34,120 --> 00:10:36,310
thinking officers where where does the

00:10:35,740 --> 00:10:40,360
burrow check

00:10:36,310 --> 00:10:43,210
from is f-fine logic and the idea is

00:10:40,360 --> 00:10:46,630
like in the 50s or 60s people try to

00:10:43,210 --> 00:10:49,720
figure out logic in the sense of what

00:10:46,630 --> 00:10:52,270
can we do with it but in the 1770s say

00:10:49,720 --> 00:10:55,450
they went a bit further and this concept

00:10:52,270 --> 00:10:59,470
of linear logic was first presented so

00:10:55,450 --> 00:11:04,089
just as a quick recap regular programs

00:10:59,470 --> 00:11:08,170
don't restrict how many times you use a

00:11:04,089 --> 00:11:11,710
resource linear logic says ok you can

00:11:08,170 --> 00:11:14,350
use every resource exactly once it's a

00:11:11,710 --> 00:11:18,000
bit hard to make a programming language

00:11:14,350 --> 00:11:21,190
where you can use things only once so a

00:11:18,000 --> 00:11:24,880
weaker version of that is FN logic which

00:11:21,190 --> 00:11:29,170
says ok it can't be used more than once

00:11:24,880 --> 00:11:30,760
you can still forget stuff and there's

00:11:29,170 --> 00:11:32,830
also relevant logic just as a

00:11:30,760 --> 00:11:35,170
counterpoint which says ok it must be

00:11:32,830 --> 00:11:38,140
used at least once tells this symmetry

00:11:35,170 --> 00:11:39,910
and people have been trying to figure

00:11:38,140 --> 00:11:41,650
out like how to make a programming

00:11:39,910 --> 00:11:44,290
language that uses these concepts from

00:11:41,650 --> 00:11:49,660
logic from like 50 40 or 50 years ago

00:11:44,290 --> 00:11:51,430
and it is hard one paper from 2000

00:11:49,660 --> 00:11:56,470
presented this functional programming

00:11:51,430 --> 00:11:58,240
language called lambda la and its main

00:11:56,470 --> 00:12:02,370
property was that there was a subset of

00:11:58,240 --> 00:12:09,060
it that is typed so that a let me quote

00:12:02,370 --> 00:12:11,710
polymorphic formulas of into e in

00:12:09,060 --> 00:12:14,680
heuristic light affine logic are

00:12:11,710 --> 00:12:18,160
available so basically you can use FN

00:12:14,680 --> 00:12:21,100
logic to express programs in this

00:12:18,160 --> 00:12:22,660
language but I'm not even able to really

00:12:21,100 --> 00:12:28,180
pronounce what's the abstract is about

00:12:22,660 --> 00:12:31,060
so maybe it's not as approachable as we

00:12:28,180 --> 00:12:35,050
want it to be that's basically the main

00:12:31,060 --> 00:12:38,770
point of the section like rust finally

00:12:35,050 --> 00:12:41,200
had this brilliant idea how to present

00:12:38,770 --> 00:12:43,360
all these concepts on most of these

00:12:41,200 --> 00:12:45,700
concepts in a way that is actually

00:12:43,360 --> 00:12:47,580
accessible to all of us like we are

00:12:45,700 --> 00:12:49,720
sitting here because this is accessible

00:12:47,580 --> 00:12:52,060
if this was still like

00:12:49,720 --> 00:12:57,269
la la I'm pretty sure this room would

00:12:52,060 --> 00:12:59,949
not be as full and also very interesting

00:12:57,269 --> 00:13:02,439
it's not just about approachability but

00:12:59,949 --> 00:13:07,870
it's also about adapting these concepts

00:13:02,439 --> 00:13:10,600
to the context we are in like we need to

00:13:07,870 --> 00:13:13,180
make this work in a pragmatic way that

00:13:10,600 --> 00:13:16,060
solves our problems today we want to

00:13:13,180 --> 00:13:18,819
have memory safety and high performance

00:13:16,060 --> 00:13:22,750
and we want to have it right now rather

00:13:18,819 --> 00:13:24,910
than in 25 years so one of the main

00:13:22,750 --> 00:13:26,709
issues with first releases of rust was

00:13:24,910 --> 00:13:28,209
that people said okay so this find this

00:13:26,709 --> 00:13:30,699
an interesting time system but I can

00:13:28,209 --> 00:13:32,889
basically come up with a program in five

00:13:30,699 --> 00:13:34,449
minutes and the program is totally valid

00:13:32,889 --> 00:13:35,920
and I can tell you how well it is

00:13:34,449 --> 00:13:38,170
actually is and the compiler still

00:13:35,920 --> 00:13:39,790
rejects it so the original

00:13:38,170 --> 00:13:42,160
implementation of this borrowed checker

00:13:39,790 --> 00:13:44,949
system didn't understand all the valid

00:13:42,160 --> 00:13:46,930
programs and it actually took us three

00:13:44,949 --> 00:13:50,920
years to finally land the next big

00:13:46,930 --> 00:13:53,470
iteration of these concepts and this is

00:13:50,920 --> 00:13:55,029
basically the non lexical lifetimes you

00:13:53,470 --> 00:13:57,610
may have heard about and which are now

00:13:55,029 --> 00:14:01,240
and enabled by default in the 2018

00:13:57,610 --> 00:14:03,009
Edition but still this is adapted for

00:14:01,240 --> 00:14:05,079
the current context and adapted for the

00:14:03,009 --> 00:14:09,279
usage patterns that have evolved in the

00:14:05,079 --> 00:14:12,399
last three years but it's not the end by

00:14:09,279 --> 00:14:14,620
far like I still can show your programs

00:14:12,399 --> 00:14:16,750
where you're trying to borrow parts of a

00:14:14,620 --> 00:14:18,250
struct and the comparison no you can't

00:14:16,750 --> 00:14:20,350
because another parts already borrowed

00:14:18,250 --> 00:14:21,970
natively or where you're trying to have

00:14:20,350 --> 00:14:23,949
structs that reference parts of

00:14:21,970 --> 00:14:27,490
themselves it's not easily expressible

00:14:23,949 --> 00:14:29,050
right now okay this is quite your

00:14:27,490 --> 00:14:30,639
article and you might be wondering like

00:14:29,050 --> 00:14:33,009
am I going to talk about compiler

00:14:30,639 --> 00:14:36,660
internals now so I'm gonna stop at this

00:14:33,009 --> 00:14:40,269
point and actually talk about a very

00:14:36,660 --> 00:14:42,819
pragmatic example because there is a

00:14:40,269 --> 00:14:45,160
program called rip grep which is a super

00:14:42,819 --> 00:14:48,250
fast competitor to grep and Silver

00:14:45,160 --> 00:14:51,009
Surfer AG you may have heard of it and

00:14:48,250 --> 00:14:53,050
if you've ever used Visual Studio code

00:14:51,009 --> 00:14:54,639
editor you've probably also used its

00:14:53,050 --> 00:14:59,559
search function which is based on rip

00:14:54,639 --> 00:15:03,430
grab the main feature that sets this

00:14:59,559 --> 00:15:07,120
program apart from other implementations

00:15:03,430 --> 00:15:09,870
that it uses rack excrete instead of for

00:15:07,120 --> 00:15:12,940
example compatible racks expressions and

00:15:09,870 --> 00:15:16,330
it's been the same also so will it make

00:15:12,940 --> 00:15:19,930
sense but I had a look and it's really

00:15:16,330 --> 00:15:25,209
interesting like what needed to be done

00:15:19,930 --> 00:15:28,360
to make this highlight of Ross

00:15:25,209 --> 00:15:33,339
accomplishments so the prior art for the

00:15:28,360 --> 00:15:35,740
regex great itself is the Pike VM which

00:15:33,339 --> 00:15:39,000
is basically a description of how you

00:15:35,740 --> 00:15:42,190
use deterministic finite or ten items to

00:15:39,000 --> 00:15:44,410
run regular expressions very computer

00:15:42,190 --> 00:15:46,540
science scene but still this wasn't

00:15:44,410 --> 00:15:49,270
enough like this is one thing that

00:15:46,540 --> 00:15:51,760
grabbed also does and it's fine but it's

00:15:49,270 --> 00:15:53,920
not what makes it fast what makes it

00:15:51,760 --> 00:15:55,959
fast is that it goes on and looks at

00:15:53,920 --> 00:15:58,420
other algorithms that have been

00:15:55,959 --> 00:16:01,540
discovered 50 years ago for example

00:15:58,420 --> 00:16:06,779
bye-bye and more and a ho and Korsak who

00:16:01,540 --> 00:16:10,600
try to come up with ideas on how to find

00:16:06,779 --> 00:16:14,410
matches on literals in strings very fast

00:16:10,600 --> 00:16:16,660
and it goes on and also adds like a lazy

00:16:14,410 --> 00:16:19,560
finite state machine on top of the pike

00:16:16,660 --> 00:16:22,360
VM to make it more memory efficient

00:16:19,560 --> 00:16:23,890
because otherwise you could easily come

00:16:22,360 --> 00:16:28,060
up with a regular expressions that is

00:16:23,890 --> 00:16:30,160
super slow and then most interesting to

00:16:28,060 --> 00:16:32,260
me was that it also includes an

00:16:30,160 --> 00:16:35,050
algorithm that is not available in any

00:16:32,260 --> 00:16:37,540
academic publication I have found which

00:16:35,050 --> 00:16:40,300
is just called Teddy from Intel's hyper

00:16:37,540 --> 00:16:42,640
scan project and it uses simply

00:16:40,300 --> 00:16:45,580
instructions to speed ups as sub string

00:16:42,640 --> 00:16:49,360
matching even more so the author of the

00:16:45,580 --> 00:16:51,430
right leg straight you may have known

00:16:49,360 --> 00:16:54,070
you may know the github handle burn

00:16:51,430 --> 00:16:56,079
sushi he looked at all these

00:16:54,070 --> 00:16:59,260
implementations and all these different

00:16:56,079 --> 00:17:01,540
approaches and tried to come up with a

00:16:59,260 --> 00:17:04,720
way to make them work and what he did

00:17:01,540 --> 00:17:07,750
was bring it all together this is why

00:17:04,720 --> 00:17:12,040
this is an amazing compilations of tools

00:17:07,750 --> 00:17:15,310
and wire grabs so popular and also like

00:17:12,040 --> 00:17:18,040
when these ideas were first proposed

00:17:15,310 --> 00:17:20,710
they were proposed to work on bytes but

00:17:18,040 --> 00:17:23,230
actually the world has changed a bit and

00:17:20,710 --> 00:17:25,870
if you've ever used grab to search for

00:17:23,230 --> 00:17:27,670
an emoji you might have negative seeing

00:17:25,870 --> 00:17:30,250
that that actually doesn't really work

00:17:27,670 --> 00:17:32,530
except if you pass like weird parameters

00:17:30,250 --> 00:17:35,200
to opt into another matching algorithm

00:17:32,530 --> 00:17:38,830
so what is a regex crate and rook club

00:17:35,200 --> 00:17:43,450
also do is support Unicode out of the

00:17:38,830 --> 00:17:46,060
box at no performance in a decrease

00:17:43,450 --> 00:17:49,030
basically like this is also just

00:17:46,060 --> 00:17:49,750
supported so it works in 2018 as you

00:17:49,030 --> 00:17:54,550
expect it to

00:17:49,750 --> 00:17:56,590
and also it's highly concurrent because

00:17:54,550 --> 00:18:01,630
it's still 2018 and we have multiple

00:17:56,590 --> 00:18:04,060
cores and want to use all of them okay

00:18:01,630 --> 00:18:06,100
so far we've seen like two big examples

00:18:04,060 --> 00:18:08,620
like this command line application and

00:18:06,100 --> 00:18:11,080
service compiler but you might also be

00:18:08,620 --> 00:18:12,640
wondering like okay fine and I'm going

00:18:11,080 --> 00:18:13,090
to talk about how to write rip crap

00:18:12,640 --> 00:18:18,400
again

00:18:13,090 --> 00:18:21,280
no actually what I'm also trying to tell

00:18:18,400 --> 00:18:23,980
except that it just adds on to the stuff

00:18:21,280 --> 00:18:26,970
I want to tell is that you don't have to

00:18:23,980 --> 00:18:30,430
think big you can just look at small

00:18:26,970 --> 00:18:33,040
interesting pieces of code and wonder

00:18:30,430 --> 00:18:35,470
can I make this better and actually if

00:18:33,040 --> 00:18:37,720
you look at the implementation of sword

00:18:35,470 --> 00:18:40,000
in the roster standard library the

00:18:37,720 --> 00:18:44,190
reason why it is like it is today is

00:18:40,000 --> 00:18:47,890
because step yarn levena has said okay

00:18:44,190 --> 00:18:50,020
this is a code it's actually like really

00:18:47,890 --> 00:18:51,790
short like 200 lines of code and I'm

00:18:50,020 --> 00:18:53,170
pretty sure I can do better like he

00:18:51,790 --> 00:18:56,140
looked at the sort implementation and

00:18:53,170 --> 00:18:57,970
said yes I can do better and I talked to

00:18:56,140 --> 00:19:00,310
him and it was quite interesting this

00:18:57,970 --> 00:19:02,110
was not the story I wanted to talk to

00:19:00,310 --> 00:19:05,800
him about but when he mentioned it I was

00:19:02,110 --> 00:19:08,920
really curious he because he said he was

00:19:05,800 --> 00:19:10,780
doing it just out of curiosity there's

00:19:08,920 --> 00:19:13,510
no other reason as he was wondering how

00:19:10,780 --> 00:19:17,140
can how does it work and maybe I can do

00:19:13,510 --> 00:19:22,030
better and it's really really powerful

00:19:17,140 --> 00:19:24,880
and what he looked at was the current

00:19:22,030 --> 00:19:27,400
implementation different versions of nor

00:19:24,880 --> 00:19:28,460
sort and other languages and standard

00:19:27,400 --> 00:19:30,650
libraries

00:19:28,460 --> 00:19:32,630
brach thought was also kind of an odd

00:19:30,650 --> 00:19:34,910
Tim sort which worked

00:19:32,630 --> 00:19:38,630
similarly to much thought but not really

00:19:34,910 --> 00:19:40,550
and just have a look at this pull

00:19:38,630 --> 00:19:45,020
request on the roster net Lavery to see

00:19:40,550 --> 00:19:48,560
like a huge bunch of paragraphs just

00:19:45,020 --> 00:19:52,520
iterating on how which write-off was

00:19:48,560 --> 00:19:54,080
made and why he looked at all these

00:19:52,520 --> 00:19:55,880
different implementations and what he

00:19:54,080 --> 00:19:58,910
actually settled on because what we

00:19:55,880 --> 00:20:00,620
settled on was pragmatism basically

00:19:58,910 --> 00:20:05,000
implemented in the way of cash

00:20:00,620 --> 00:20:07,850
efficiency because this is how CPUs work

00:20:05,000 --> 00:20:11,690
today if you have very efficient caches

00:20:07,850 --> 00:20:15,530
you're probably really fast another very

00:20:11,690 --> 00:20:17,840
interesting approach to this is to look

00:20:15,530 --> 00:20:20,570
at the community side because this story

00:20:17,840 --> 00:20:23,510
have just told is not just my story but

00:20:20,570 --> 00:20:26,690
it's actually the story of Falls JP on

00:20:23,510 --> 00:20:28,580
first made a public trust trust like he

00:20:26,690 --> 00:20:31,910
showed up and nature's latest

00:20:28,580 --> 00:20:36,110
improvement to the sorting function just

00:20:31,910 --> 00:20:38,710
like that it's not much code but it's

00:20:36,110 --> 00:20:41,030
still like if this is the first

00:20:38,710 --> 00:20:44,240
interaction with the community it could

00:20:41,030 --> 00:20:46,130
go all all the different ways like he is

00:20:44,240 --> 00:20:48,760
changing the standard Larry people might

00:20:46,130 --> 00:20:51,800
get upset they might be trade-offs that

00:20:48,760 --> 00:20:54,470
no one knows about they might just be no

00:20:51,800 --> 00:20:57,110
one's there to review it actually it

00:20:54,470 --> 00:20:59,240
took just three days to get this into

00:20:57,110 --> 00:21:02,750
the standard library and this is super

00:20:59,240 --> 00:21:04,730
super important because if we as a

00:21:02,750 --> 00:21:07,370
community are transparent and open to

00:21:04,730 --> 00:21:07,880
change and looking at other people's

00:21:07,370 --> 00:21:10,910
work

00:21:07,880 --> 00:21:12,950
we should also be open to looking at

00:21:10,910 --> 00:21:15,710
when other people propose changes to our

00:21:12,950 --> 00:21:17,390
work and this is super good because

00:21:15,710 --> 00:21:20,090
nowadays debian is super active in the

00:21:17,390 --> 00:21:23,750
community and basically the next thing I

00:21:20,090 --> 00:21:26,120
did was open an hour of C to propose to

00:21:23,750 --> 00:21:28,190
add the salt unstable version to the

00:21:26,120 --> 00:21:30,830
standard of so sorting to the standard

00:21:28,190 --> 00:21:33,020
library which is now available and also

00:21:30,830 --> 00:21:35,920
way way faster than any other

00:21:33,020 --> 00:21:40,160
implementation I've seen so far

00:21:35,920 --> 00:21:42,260
okay now I've planted three examples and

00:21:40,160 --> 00:21:44,690
you might still be wondering

00:21:42,260 --> 00:21:49,450
find what does it actually help me to

00:21:44,690 --> 00:21:52,070
now and what I'm saying is you should

00:21:49,450 --> 00:21:56,150
try to find inspiration for your

00:21:52,070 --> 00:22:00,740
problems in other fields in other

00:21:56,150 --> 00:22:02,360
ecosystems and see that there are a lot

00:22:00,740 --> 00:22:04,160
of people out there who are trying to

00:22:02,360 --> 00:22:06,830
solve similar problems and maybe you can

00:22:04,160 --> 00:22:08,350
find inspirations there so other

00:22:06,830 --> 00:22:10,910
ecosystems

00:22:08,350 --> 00:22:13,610
I've been iterating on step beyond story

00:22:10,910 --> 00:22:16,510
it's for a while now and I'm actually

00:22:13,610 --> 00:22:19,580
going to tell it a bit longer because

00:22:16,510 --> 00:22:22,190
one of the most interesting Crites I

00:22:19,580 --> 00:22:25,460
have seen in the last year was that

00:22:22,190 --> 00:22:28,340
cross beam channel has been really

00:22:25,460 --> 00:22:29,810
really burnt up like it's an improvement

00:22:28,340 --> 00:22:32,570
on the channels in the standard library

00:22:29,810 --> 00:22:35,840
which is basically a multiple producer

00:22:32,570 --> 00:22:38,300
but single consumer channel system which

00:22:35,840 --> 00:22:41,450
has for a long time had an unstable

00:22:38,300 --> 00:22:43,880
select macro to to select over multiple

00:22:41,450 --> 00:22:47,330
channels but it wasn't really powerful

00:22:43,880 --> 00:22:50,900
and the idea was cross beam channel was

00:22:47,330 --> 00:22:54,260
to basically put a very good alternative

00:22:50,900 --> 00:22:57,140
out there cross beam channel is

00:22:54,260 --> 00:22:59,600
available outbound in a bounded and

00:22:57,140 --> 00:23:02,540
unbounded way it's a multi producer and

00:22:59,600 --> 00:23:06,020
multiple consumer channel and it has a

00:23:02,540 --> 00:23:08,000
very nice Select macro so what this

00:23:06,020 --> 00:23:10,970
enabled us to do is basically have a

00:23:08,000 --> 00:23:13,940
library implementation of what other

00:23:10,970 --> 00:23:15,940
languages have in their core language

00:23:13,940 --> 00:23:20,720
system and that's not by accident

00:23:15,940 --> 00:23:23,150
because this was developed by taking

00:23:20,720 --> 00:23:25,490
inspiration directly from what the go

00:23:23,150 --> 00:23:28,450
developers have been doing for the last

00:23:25,490 --> 00:23:30,230
eight years or so at that point

00:23:28,450 --> 00:23:33,410
basically there was a very interesting

00:23:30,230 --> 00:23:36,440
design document from 2014 which iterates

00:23:33,410 --> 00:23:39,680
all the points that the go developers

00:23:36,440 --> 00:23:42,770
looked at to come up with the design

00:23:39,680 --> 00:23:45,740
they chose and the developers of

00:23:42,770 --> 00:23:49,250
crossbeam Channel among others Geoff

00:23:45,740 --> 00:23:51,170
Young looked at this and could tell ok

00:23:49,250 --> 00:23:53,960
this is a trade off we also want to do

00:23:51,170 --> 00:23:55,149
and also decide like this is not

00:23:53,960 --> 00:23:57,669
something that fits in

00:23:55,149 --> 00:24:00,759
to the rust systems of LEDs right now

00:23:57,669 --> 00:24:04,210
and the main idea was to avoid lock

00:24:00,759 --> 00:24:06,700
contention and this sounds super easy

00:24:04,210 --> 00:24:09,190
like it's like three words that boils

00:24:06,700 --> 00:24:12,789
down why these channels are fast avoid

00:24:09,190 --> 00:24:14,499
lock contention but it's it's very hard

00:24:12,789 --> 00:24:17,799
to get Terrance this document was super

00:24:14,499 --> 00:24:20,710
helpful and basically what we have right

00:24:17,799 --> 00:24:23,769
now is a fully featured implementation

00:24:20,710 --> 00:24:26,379
of a channel system in a library just

00:24:23,769 --> 00:24:29,139
sitting somewhere and people can use it

00:24:26,379 --> 00:24:32,979
like the language doesn't really block

00:24:29,139 --> 00:24:34,649
you in a way that you say okay I want to

00:24:32,979 --> 00:24:37,299
have this but now I need to get

00:24:34,649 --> 00:24:41,019
knowledge of how the compiler works to

00:24:37,299 --> 00:24:44,080
make it happen you can try and implement

00:24:41,019 --> 00:24:48,159
a lot of stuff just integrate somewhere

00:24:44,080 --> 00:24:49,779
and this is so powerful that let us talk

00:24:48,159 --> 00:24:52,409
about adding this to the standard

00:24:49,779 --> 00:24:55,029
library itself because this is like

00:24:52,409 --> 00:24:57,099
happening years after the standard

00:24:55,029 --> 00:24:58,889
library implementation and a lot of

00:24:57,099 --> 00:25:03,070
stuff has been learned in that time

00:24:58,889 --> 00:25:05,049
similarly there are two more crates I

00:25:03,070 --> 00:25:07,419
want to talk about the first one is

00:25:05,049 --> 00:25:11,139
parking lot and the other one is hash

00:25:07,419 --> 00:25:14,529
brown so parking lot is a set of

00:25:11,139 --> 00:25:17,379
synchronization primitives as like music

00:25:14,529 --> 00:25:20,259
mutexes and readwrite locks but it's

00:25:17,379 --> 00:25:23,080
implemented in user space and it's also

00:25:20,259 --> 00:25:26,649
not a new invention it's taken basically

00:25:23,080 --> 00:25:29,849
directly from the library that WebKit

00:25:26,649 --> 00:25:33,489
uses internally which has a funny name

00:25:29,849 --> 00:25:35,169
WTF because it's a WebKit framework or

00:25:33,489 --> 00:25:38,589
what technology from like I don't know

00:25:35,169 --> 00:25:42,219
WTF that's how I remember it

00:25:38,589 --> 00:25:44,289
and the other one is hash brown so there

00:25:42,219 --> 00:25:48,009
was his talk a year ago with C++ conf

00:25:44,289 --> 00:25:50,019
from someone from Google who presented

00:25:48,009 --> 00:25:53,830
an alternative hash table implementation

00:25:50,019 --> 00:25:57,129
and it turns out this thing called Swiss

00:25:53,830 --> 00:25:59,769
table is super super efficient it uses

00:25:57,129 --> 00:26:04,659
way less lookups and way less

00:25:59,769 --> 00:26:06,579
instructions for a key lookup than any

00:26:04,659 --> 00:26:08,870
other implementation I have seen at

00:26:06,579 --> 00:26:12,080
least and it works by using

00:26:08,870 --> 00:26:14,990
the instructions and clever packaging in

00:26:12,080 --> 00:26:18,350
memory and hashbrown is a rust

00:26:14,990 --> 00:26:22,070
implementation of exactly this hash

00:26:18,350 --> 00:26:24,320
table and there are two PRS open right

00:26:22,070 --> 00:26:26,630
now the first one is about putting

00:26:24,320 --> 00:26:29,030
packing a lot into the roster netlibrary

00:26:26,630 --> 00:26:30,620
and the other one is about replacing the

00:26:29,030 --> 00:26:32,990
current hash table we have a rust

00:26:30,620 --> 00:26:35,300
standard library with hash brown and

00:26:32,990 --> 00:26:40,420
this is only possible because they work

00:26:35,300 --> 00:26:43,340
or can work as drop-in replacements so a

00:26:40,420 --> 00:26:46,220
super-powerful way to improve our

00:26:43,340 --> 00:26:49,970
language and echo system is to be able

00:26:46,220 --> 00:26:53,090
to come up with ways that we can just

00:26:49,970 --> 00:26:56,480
switch out and improve continuously over

00:26:53,090 --> 00:26:59,870
time so these were all examples taken

00:26:56,480 --> 00:27:03,860
from other ecosystems other languages

00:26:59,870 --> 00:27:08,210
and other companies basically those one

00:27:03,860 --> 00:27:10,190
other source of inspiration that's a bit

00:27:08,210 --> 00:27:14,690
more difficult to get into your and that

00:27:10,190 --> 00:27:16,580
is academia just a quick show of hands

00:27:14,690 --> 00:27:20,210
how many of you studied something

00:27:16,580 --> 00:27:23,840
related to computer science okay that's

00:27:20,210 --> 00:27:27,730
that's quite a lot like 60% and how many

00:27:23,840 --> 00:27:30,080
of you like reading academic papers

00:27:27,730 --> 00:27:31,670
let's still the good number not not as

00:27:30,080 --> 00:27:36,440
many that's still a still a good number

00:27:31,670 --> 00:27:40,040
and it's it's you've probably figured

00:27:36,440 --> 00:27:42,410
out somehow how to get into paper and

00:27:40,040 --> 00:27:44,750
how to read papers and how to actually

00:27:42,410 --> 00:27:48,440
figure out where to get papers but most

00:27:44,750 --> 00:27:50,840
people have not which is quite sad so

00:27:48,440 --> 00:27:53,570
this whole resource is not the way for

00:27:50,840 --> 00:27:59,210
them or for some of you actually I don't

00:27:53,570 --> 00:28:01,190
know I talked to someone who had a very

00:27:59,210 --> 00:28:04,790
interesting point to make

00:28:01,190 --> 00:28:07,010
Tyler Neely told me that so many awesome

00:28:04,790 --> 00:28:08,990
engineering projects are basically just

00:28:07,010 --> 00:28:11,540
out there that can be pulled off by just

00:28:08,990 --> 00:28:13,540
taking a quick look at where the current

00:28:11,540 --> 00:28:16,790
research is at in a particular field

00:28:13,540 --> 00:28:21,110
because often the implementations are

00:28:16,790 --> 00:28:22,520
lagging behind by several decades so if

00:28:21,110 --> 00:28:24,830
you enjoy reading papers

00:28:22,520 --> 00:28:26,420
one idea would be to just read more of

00:28:24,830 --> 00:28:31,550
those and try to implement the best

00:28:26,420 --> 00:28:33,470
ideas and just because I didn't know how

00:28:31,550 --> 00:28:36,860
many of you had any academic background

00:28:33,470 --> 00:28:38,540
and I still really don't I wanted to

00:28:36,860 --> 00:28:41,060
also point out where to find some

00:28:38,540 --> 00:28:42,920
interesting papers because for me it was

00:28:41,060 --> 00:28:45,740
really really hard to get into this

00:28:42,920 --> 00:28:48,470
mindset of actually doing is that in my

00:28:45,740 --> 00:28:51,890
free time and finding stuff that was

00:28:48,470 --> 00:28:54,980
worse like spending half a day just

00:28:51,890 --> 00:28:58,280
trying to comprehend something so two

00:28:54,980 --> 00:29:00,470
interesting resources I have papers we

00:28:58,280 --> 00:29:04,160
laugh which is papers we love dark and

00:29:00,470 --> 00:29:09,230
the other one is an interesting block of

00:29:04,160 --> 00:29:12,790
the morning paper it's both about

00:29:09,230 --> 00:29:16,040
presenting papers that are somewhat

00:29:12,790 --> 00:29:19,190
approachable but still weird enough that

00:29:16,040 --> 00:29:23,450
they are not like published in regular

00:29:19,190 --> 00:29:26,950
newspapers or on Hacker News and just

00:29:23,450 --> 00:29:29,900
like my approach to reading papers is

00:29:26,950 --> 00:29:31,790
quite simplistic actually I try to read

00:29:29,900 --> 00:29:33,350
like the abstract figure out this is

00:29:31,790 --> 00:29:35,480
something I could actually identify with

00:29:33,350 --> 00:29:38,060
and this is interesting to anything that

00:29:35,480 --> 00:29:40,970
might be interesting to me

00:29:38,060 --> 00:29:42,380
and another little conclusion just to

00:29:40,970 --> 00:29:47,390
figure out if they have managed to do

00:29:42,380 --> 00:29:49,910
something of value and that allows me to

00:29:47,390 --> 00:29:51,830
basically read everything papers we

00:29:49,910 --> 00:29:55,580
laugh or the morning paper publishes in

00:29:51,830 --> 00:30:01,400
like two minutes and then sort out like

00:29:55,580 --> 00:30:06,220
90% but still this is 90 percent papers

00:30:01,400 --> 00:30:10,070
I've no knowledge actually exists and

00:30:06,220 --> 00:30:12,230
actually I'm not alone because I talk to

00:30:10,070 --> 00:30:15,770
Jeffrey Cory you may have known I know

00:30:12,230 --> 00:30:18,380
him from the non-passing library and he

00:30:15,770 --> 00:30:21,560
told me like most of the things he reads

00:30:18,380 --> 00:30:25,280
have no useful application whatsoever

00:30:21,560 --> 00:30:29,990
for him and the funny thing is though

00:30:25,280 --> 00:30:32,660
that he often finds himself years later

00:30:29,990 --> 00:30:35,600
looking back at what he read and says

00:30:32,660 --> 00:30:35,930
like oh I totally misjudged or I totally

00:30:35,600 --> 00:30:39,350
did

00:30:35,930 --> 00:30:44,840
know what this could do from in land but

00:30:39,350 --> 00:30:46,670
I do know how so can you act like a

00:30:44,840 --> 00:30:49,400
machine that just consumes research

00:30:46,670 --> 00:30:51,140
papers and splits out awesome Russ

00:30:49,400 --> 00:30:53,480
projects yeah probably not

00:30:51,140 --> 00:30:57,200
this is not how people are actually

00:30:53,480 --> 00:31:00,800
research work but you can try to look at

00:30:57,200 --> 00:31:05,450
more sources of inspiration and try to

00:31:00,800 --> 00:31:07,490
look at it from a perspective of how can

00:31:05,450 --> 00:31:10,340
I make this more practical like how can

00:31:07,490 --> 00:31:12,740
actually apply this to my life how can i

00:31:10,340 --> 00:31:14,660
when what your life but probably your

00:31:12,740 --> 00:31:16,130
code or your work I don't know maybe

00:31:14,660 --> 00:31:20,410
also your life if you're really

00:31:16,130 --> 00:31:23,630
passionate about it you can ask yourself

00:31:20,410 --> 00:31:25,820
can we can we reach just this bit more

00:31:23,630 --> 00:31:27,770
further is what we're doing right now

00:31:25,820 --> 00:31:29,450
actually the best approach or is someone

00:31:27,770 --> 00:31:33,910
out there who had like this brilliant

00:31:29,450 --> 00:31:36,260
idea and nobody really made it happen

00:31:33,910 --> 00:31:39,650
because I'm pretty sure the terrorists a

00:31:36,260 --> 00:31:43,070
lot of research that still just needs to

00:31:39,650 --> 00:31:46,430
be rediscovered and this is a quote from

00:31:43,070 --> 00:31:49,370
step beyond as you can see and he asked

00:31:46,430 --> 00:31:52,220
another question can we can we bend the

00:31:49,370 --> 00:31:54,950
curve somewhere like can we look at all

00:31:52,220 --> 00:31:57,800
the trade-offs that exists right now and

00:31:54,950 --> 00:32:01,850
can we try to tweak them like just a

00:31:57,800 --> 00:32:04,910
little bit this is is enough and this

00:32:01,850 --> 00:32:07,070
resonates with me as someone who has

00:32:04,910 --> 00:32:09,800
been in the rust community for four

00:32:07,070 --> 00:32:11,780
years because rust is all about like

00:32:09,800 --> 00:32:14,990
overcoming these traditional trade offs

00:32:11,780 --> 00:32:17,060
like you know is this like crazy points

00:32:14,990 --> 00:32:20,180
of memory safety without garbage

00:32:17,060 --> 00:32:21,590
collection it's it's happening and stuff

00:32:20,180 --> 00:32:24,860
like abstractions are over here this is

00:32:21,590 --> 00:32:27,770
the selling points let me try to use to

00:32:24,860 --> 00:32:29,810
convince people to use rust and this

00:32:27,770 --> 00:32:31,910
bending the curve doesn't just have to

00:32:29,810 --> 00:32:36,740
be like language features it can also be

00:32:31,910 --> 00:32:42,320
the implementation of weird but very

00:32:36,740 --> 00:32:44,930
useful other approaches like if we could

00:32:42,320 --> 00:32:47,990
just come up with some academic approach

00:32:44,930 --> 00:32:49,220
and putting it into like a non

00:32:47,990 --> 00:32:54,650
intimidating version

00:32:49,220 --> 00:32:57,260
of itself like if we look at if we look

00:32:54,650 --> 00:32:59,510
at what the academic publication of the

00:32:57,260 --> 00:33:01,130
Swiss table hashing would look like

00:32:59,510 --> 00:33:06,830
it'll probably be quite intimidating

00:33:01,130 --> 00:33:09,169
like the Robin Hood hashing paper was

00:33:06,830 --> 00:33:12,080
really really good and really really

00:33:09,169 --> 00:33:15,020
intimidating and I know it because I

00:33:12,080 --> 00:33:16,460
walked like it took me like two years to

00:33:15,020 --> 00:33:20,630
actually get to the point where I tried

00:33:16,460 --> 00:33:23,600
to read it and well it didn't really

00:33:20,630 --> 00:33:27,830
help me in my life so far but it was

00:33:23,600 --> 00:33:30,049
interesting and if I had been in this

00:33:27,830 --> 00:33:31,730
position ten years earlier I might have

00:33:30,049 --> 00:33:35,720
been the guy who actually sat down and

00:33:31,730 --> 00:33:38,210
said why the second a rusty needs her

00:33:35,720 --> 00:33:40,159
hashing like like a hashmap

00:33:38,210 --> 00:33:42,020
implementation I've seen this paper I

00:33:40,159 --> 00:33:44,570
could sit down and actually try to make

00:33:42,020 --> 00:33:47,150
this usable and basically the current

00:33:44,570 --> 00:33:49,730
hashmap implementation of rust is using

00:33:47,150 --> 00:33:54,320
Robin Hood hashing so if we can make

00:33:49,730 --> 00:33:56,030
this weird other idea into a non

00:33:54,320 --> 00:33:59,090
intimidating version of itself it's

00:33:56,030 --> 00:34:01,760
actually usable and package it in a way

00:33:59,090 --> 00:34:05,179
that's usable the rust programmers we

00:34:01,760 --> 00:34:08,389
have basically made a big contribution

00:34:05,179 --> 00:34:11,149
to what Russ programming lukla looks

00:34:08,389 --> 00:34:19,639
like because this is bending the curve

00:34:11,149 --> 00:34:22,599
somewhere okay just one more story this

00:34:19,639 --> 00:34:25,639
about Greene's rights because not every

00:34:22,599 --> 00:34:29,210
story needs to have him happy have their

00:34:25,639 --> 00:34:33,080
happy end right in in 2014

00:34:29,210 --> 00:34:35,450
rust had greens rats like something like

00:34:33,080 --> 00:34:38,240
go routines or something like no joyous

00:34:35,450 --> 00:34:40,639
event loop it was actually using lip UV

00:34:38,240 --> 00:34:44,929
which is what nose note used at the time

00:34:40,639 --> 00:34:48,349
too and this allowed rust to have a

00:34:44,929 --> 00:34:52,490
single in 2014 it was actually quite

00:34:48,349 --> 00:34:54,290
good at least it was usable and late

00:34:52,490 --> 00:34:56,869
they removed it like they they they went

00:34:54,290 --> 00:35:00,680
ahead and said like yeah no you're not

00:34:56,869 --> 00:35:02,810
going to do it which was way before rust

00:35:00,680 --> 00:35:07,100
wondered oh but still like a very

00:35:02,810 --> 00:35:09,740
decision and why would they do that well

00:35:07,100 --> 00:35:12,350
I would say is look at an implementation

00:35:09,740 --> 00:35:14,690
that has a Sanjaya which is a problem

00:35:12,350 --> 00:35:18,650
that we are still in the process of

00:35:14,690 --> 00:35:23,270
figuring out today and just remove a

00:35:18,650 --> 00:35:25,430
good implementation of it and well I'm

00:35:23,270 --> 00:35:29,210
not gonna spoil it Katrina's keynote

00:35:25,430 --> 00:35:33,110
it's later today but the the idea why

00:35:29,210 --> 00:35:35,360
they removed it was because not because

00:35:33,110 --> 00:35:38,060
it was the easy thing to do but because

00:35:35,360 --> 00:35:40,850
they wanted to have the payoffs in the

00:35:38,060 --> 00:35:44,620
long run they wanted to make the rest

00:35:40,850 --> 00:35:49,010
team tried to figure out how to make

00:35:44,620 --> 00:35:51,440
more stuff work how to have less

00:35:49,010 --> 00:35:54,080
trade-offs because you can implement a

00:35:51,440 --> 00:35:56,810
single without greens rats and if you do

00:35:54,080 --> 00:35:59,930
so you have no runtime that you can

00:35:56,810 --> 00:36:05,030
support embedded systems which is a huge

00:35:59,930 --> 00:36:11,630
thing and I'm pretty sure it's actually

00:36:05,030 --> 00:36:13,250
like going to be very ok so it's ok to

00:36:11,630 --> 00:36:14,690
iterate on ideas actually the first

00:36:13,250 --> 00:36:18,890
version of anything doesn't have to be

00:36:14,690 --> 00:36:21,050
perfect if you have the ability to say

00:36:18,890 --> 00:36:25,790
ok we are going to change it or upgrade

00:36:21,050 --> 00:36:29,450
it later on it's ok if the first version

00:36:25,790 --> 00:36:30,950
is complicated if you actually recognize

00:36:29,450 --> 00:36:33,260
that it's too complicated

00:36:30,950 --> 00:36:36,680
it's ok if it's weird or not a good fit

00:36:33,260 --> 00:36:38,510
if you recognize this and it's also ok

00:36:36,680 --> 00:36:40,340
if it's not powerful enough if you know

00:36:38,510 --> 00:36:43,880
what features you need to add to make it

00:36:40,340 --> 00:36:44,950
work this is basically why rust has so

00:36:43,880 --> 00:36:48,560
many

00:36:44,950 --> 00:36:51,050
unstable features that are labeled

00:36:48,560 --> 00:36:52,490
unstable because I don't want to

00:36:51,050 --> 00:36:56,690
stabilize them right now because I

00:36:52,490 --> 00:36:59,080
figure that they still know how to do it

00:36:56,690 --> 00:37:03,590
better and they can't do it if they

00:36:59,080 --> 00:37:06,530
figure if they settle on a precise

00:37:03,590 --> 00:37:08,840
definition today the ability that we can

00:37:06,530 --> 00:37:11,750
that we have that we can change the

00:37:08,840 --> 00:37:16,010
implementation of hash tables today is a

00:37:11,750 --> 00:37:16,760
very very good one like C++ can't really

00:37:16,010 --> 00:37:18,589
do this right

00:37:16,760 --> 00:37:20,510
even if they wanted to relax the

00:37:18,589 --> 00:37:22,640
Google's the Swiss table is actually

00:37:20,510 --> 00:37:24,520
implemented in a C++ library but it

00:37:22,640 --> 00:37:26,960
couldn't become the standard library

00:37:24,520 --> 00:37:29,500
because it's the totally different API

00:37:26,960 --> 00:37:34,339
and it has to be a totally different API

00:37:29,500 --> 00:37:38,270
so the first version must or may not be

00:37:34,339 --> 00:37:46,640
perfect and that's totally okay because

00:37:38,270 --> 00:37:50,109
after all rust is maybe just this one

00:37:46,640 --> 00:37:53,540
thing where key we can try to improve

00:37:50,109 --> 00:37:55,700
just to write as aspects may be rust can

00:37:53,540 --> 00:37:57,530
be this one step gem called fertile

00:37:55,700 --> 00:38:02,680
ground for growing food stuff maybe we

00:37:57,530 --> 00:38:06,619
can try to do very ambitious things and

00:38:02,680 --> 00:38:11,030
to recap the talk at this point and to

00:38:06,619 --> 00:38:12,530
come to some conclusion I'm pretty sure

00:38:11,030 --> 00:38:13,070
that rust is in a very good place right

00:38:12,530 --> 00:38:17,000
now

00:38:13,070 --> 00:38:22,190
and we can do ambitious things and to do

00:38:17,000 --> 00:38:24,319
so I'm proposing three ideas the first

00:38:22,190 --> 00:38:27,500
one is just to be curious like to look

00:38:24,319 --> 00:38:30,440
behind the curtain like to see there is

00:38:27,500 --> 00:38:33,589
an implementation of how slices can be

00:38:30,440 --> 00:38:34,450
sorted and figure out that we can do

00:38:33,589 --> 00:38:37,010
better

00:38:34,450 --> 00:38:40,430
maybe not sorting right now because it's

00:38:37,010 --> 00:38:42,920
very good but some other aspect and we

00:38:40,430 --> 00:38:45,349
should try to bend this curve of

00:38:42,920 --> 00:38:48,170
features and trade-offs we should try to

00:38:45,349 --> 00:38:50,900
look at what's convenient right now and

00:38:48,170 --> 00:38:53,300
what's difficult and try to just make

00:38:50,900 --> 00:38:57,319
one more difficult also saying also

00:38:53,300 --> 00:38:59,660
convenient and last but not least we

00:38:57,319 --> 00:39:02,119
should also help other people discover

00:38:59,660 --> 00:39:04,579
or simple things like I'm pretty sure I

00:39:02,119 --> 00:39:07,910
don't have time this year to do anything

00:39:04,579 --> 00:39:09,079
very ambitious but maybe I just came

00:39:07,910 --> 00:39:10,579
across something that's really

00:39:09,079 --> 00:39:14,450
interesting and I can talk to you about

00:39:10,579 --> 00:39:16,490
it and also just to recap the other

00:39:14,450 --> 00:39:20,210
point where to look for inspiration

00:39:16,490 --> 00:39:24,650
the first one is other ecosystems of

00:39:20,210 --> 00:39:26,930
similar fields like if you have an issue

00:39:24,650 --> 00:39:28,970
you want to solve right now and you see

00:39:26,930 --> 00:39:32,130
there's a Java implementation

00:39:28,970 --> 00:39:34,740
please don't say it's in Java I'm not

00:39:32,130 --> 00:39:38,369
gonna look at it please say okay

00:39:34,740 --> 00:39:41,070
interesting they had probably like some

00:39:38,369 --> 00:39:44,160
time to come up with with a solution and

00:39:41,070 --> 00:39:47,460
apparently it works I'm gonna try to

00:39:44,160 --> 00:39:50,570
understand what's I meant by it and the

00:39:47,460 --> 00:39:52,800
second point was academia and trying to

00:39:50,570 --> 00:39:55,770
see that there was a lot of research out

00:39:52,800 --> 00:39:59,700
there that has not been made accessible

00:39:55,770 --> 00:40:01,890
to the public which is really sad but

00:39:59,700 --> 00:40:04,500
also maybe some completely different

00:40:01,890 --> 00:40:06,180
areas I'm not saying this is a solution

00:40:04,500 --> 00:40:09,090
for everything I can't give you like

00:40:06,180 --> 00:40:11,340
this package deal of how to figure out

00:40:09,090 --> 00:40:16,090
cool stuff you should try to find your

00:40:11,340 --> 00:40:21,210
own thank you very much

00:40:16,090 --> 00:40:21,210

YouTube URL: https://www.youtube.com/watch?v=exgAKU686cg


