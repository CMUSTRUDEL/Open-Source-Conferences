Title: Transparent proofs of data records in blockchain. Roman Shirochenko
Publication date: 2019-02-06
Playlist: RustRush 2018
Description: 
	Roman is a Rust programmer at Bitfury, he leads the Exonum Russia team. They develop blockchain applications built on the Exonum. He has experience in building and integration of enterprise and government blockchain solutions.

Exonum is a blockchain framework developed in Rust that allows building secure permissioned blockchain applications. Blockchain, as a technology that expands the capabilities of distributed databases, implies the possibility of auditing or validating stored information.
Exonum provides a “proofs mechanism”, based on cryptographic commitments via Merkle / Merkle Patricia trees. This mechanism allows verifying that a response from the full node has been really authorized by a supermajority of validators.
The talk will present how we develop the merkelized collections in Exonum and the tools to provide data auditability functionality for the web applications integration. The talk will be based on the auction blockchain application example.
Captions: 
	00:00:03,550 --> 00:00:08,710
my name is Herman I'm working in this

00:00:06,189 --> 00:00:11,110
fury especially I'm working in on

00:00:08,710 --> 00:00:13,450
excellent project economies framework

00:00:11,110 --> 00:00:16,720
for building private blockchains and

00:00:13,450 --> 00:00:18,820
especially I suppose developing book

00:00:16,720 --> 00:00:21,400
chain application based on the exonym I

00:00:18,820 --> 00:00:22,900
have a question for our audience how

00:00:21,400 --> 00:00:25,060
many did you have experience with

00:00:22,900 --> 00:00:28,660
blockchain or any related technologies

00:00:25,060 --> 00:00:32,800
please raise your hands okay nice it's

00:00:28,660 --> 00:00:36,010
cool so I'm gonna address the problem

00:00:32,800 --> 00:00:39,100
with my presentation today okay we have

00:00:36,010 --> 00:00:43,510
IT system we have block J but how we

00:00:39,100 --> 00:00:45,550
gonna provide the final user the proof

00:00:43,510 --> 00:00:48,940
that the data is actually stored in this

00:00:45,550 --> 00:00:51,399
block chain that the data is have the

00:00:48,940 --> 00:00:55,059
same state as it was before when the

00:00:51,399 --> 00:00:57,190
transaction was recorded and I'm going

00:00:55,059 --> 00:01:00,159
to explain how we did and solve this

00:00:57,190 --> 00:01:04,330
problem with our solution in this

00:01:00,159 --> 00:01:06,070
acronym a couple words about the company

00:01:04,330 --> 00:01:09,820
so book bitfury

00:01:06,070 --> 00:01:13,329
it's a global blockchain company we

00:01:09,820 --> 00:01:15,250
started as a hardware company we started

00:01:13,329 --> 00:01:17,409
with the mining then we open this valve

00:01:15,250 --> 00:01:20,200
software branch now we have three

00:01:17,409 --> 00:01:22,180
products the first is exonym it's a

00:01:20,200 --> 00:01:26,110
framework for building private

00:01:22,180 --> 00:01:30,579
blockchains the second is a pitch it's

00:01:26,110 --> 00:01:33,340
actually a lightning wallet that allow

00:01:30,579 --> 00:01:36,549
to make a Bitcoin transaction from make

00:01:33,340 --> 00:01:39,369
we'd make it faster and cheaper and the

00:01:36,549 --> 00:01:43,750
sort is crystal this is to for making a

00:01:39,369 --> 00:01:47,170
fist occasion in the Queen let's move on

00:01:43,750 --> 00:01:49,929
to exonym the first part I will explain

00:01:47,170 --> 00:01:53,950
a little bit what its exam is and what

00:01:49,929 --> 00:01:58,450
it's like many future we have the second

00:01:53,950 --> 00:02:00,729
part would be I've explained what is the

00:01:58,450 --> 00:02:03,999
proof is a little bit theory part and

00:02:00,729 --> 00:02:06,070
how we implement it in our in in code in

00:02:03,999 --> 00:02:11,760
our solution and the third part will be

00:02:06,070 --> 00:02:15,640
demo so the exam it's open source before

00:02:11,760 --> 00:02:16,750
framework for prefer private chains what

00:02:15,640 --> 00:02:20,920
Spri book

00:02:16,750 --> 00:02:23,680
so it's usually the book change that can

00:02:20,920 --> 00:02:26,140
be used between some organizations

00:02:23,680 --> 00:02:28,810
usually some organizations have like the

00:02:26,140 --> 00:02:33,940
shirt business process and they want to

00:02:28,810 --> 00:02:35,830
share the data also and this our greens

00:02:33,940 --> 00:02:38,200
each organization usually don't trust

00:02:35,830 --> 00:02:42,160
each other but they need to exchange it

00:02:38,200 --> 00:02:45,520
by beta so in this case is pride

00:02:42,160 --> 00:02:48,370
watching can be useful X on them so it's

00:02:45,520 --> 00:02:52,750
already on point source for about 1/2

00:02:48,370 --> 00:02:55,510
year about 30 developers working on this

00:02:52,750 --> 00:03:00,489
project and most and mostly it's a rat

00:02:55,510 --> 00:03:03,310
developers and so it's it's a purely

00:03:00,489 --> 00:03:07,330
Liberty and business but business logic

00:03:03,310 --> 00:03:11,650
it's up on the developers who who trying

00:03:07,330 --> 00:03:13,470
to build something on top agonal as the

00:03:11,650 --> 00:03:18,519
consensus we using TIF district

00:03:13,470 --> 00:03:22,239
consensus this allows will rebuild it

00:03:18,519 --> 00:03:25,750
ourselves its allows to to show the

00:03:22,239 --> 00:03:30,840
speed of transaction processing cup 5000

00:03:25,750 --> 00:03:34,450
and the lintons it's about zero point

00:03:30,840 --> 00:03:36,820
zero point five seconds it's mostly for

00:03:34,450 --> 00:03:39,610
for the network delays plus it's for

00:03:36,820 --> 00:03:42,430
block issuing and with using standard

00:03:39,610 --> 00:03:49,630
algorithms that everyone using in

00:03:42,430 --> 00:03:51,730
industry we also develop the technology

00:03:49,630 --> 00:03:54,579
anchoring when it's useful for for

00:03:51,730 --> 00:03:56,970
example we have four nodes and we have

00:03:54,579 --> 00:03:59,880
be 50 consensus with three nodes and

00:03:56,970 --> 00:04:05,890
it's it can be happen the three nodes

00:03:59,880 --> 00:04:09,579
can agree to like to check the first the

00:04:05,890 --> 00:04:12,220
first nodes and so what what the first

00:04:09,579 --> 00:04:13,989
node can be doing in this case so for

00:04:12,220 --> 00:04:16,450
this case we introduced anchoring

00:04:13,989 --> 00:04:19,570
technology what is what's it actually do

00:04:16,450 --> 00:04:21,910
so we get the hash of the block and for

00:04:19,570 --> 00:04:24,130
example each one thousands of the blocks

00:04:21,910 --> 00:04:28,900
we are publishing this information to

00:04:24,130 --> 00:04:30,300
public blockchain network especially we

00:04:28,900 --> 00:04:34,120
have publishing

00:04:30,300 --> 00:04:39,159
the data to Bitcoin as it like the most

00:04:34,120 --> 00:04:41,650
secure solution nowadays also we have

00:04:39,159 --> 00:04:45,280
the light client so actually it's a

00:04:41,650 --> 00:04:47,979
JavaScript JavaScript library this

00:04:45,280 --> 00:04:51,879
allows to make easy integration for web

00:04:47,979 --> 00:04:55,810
applications it has all built-in

00:04:51,879 --> 00:04:57,940
functionality for make for forming

00:04:55,810 --> 00:05:04,840
transaction for my data audition and

00:04:57,940 --> 00:05:07,780
also to make anchoring modification like

00:05:04,840 --> 00:05:09,909
we have their own their own model of our

00:05:07,780 --> 00:05:12,960
nodes we have actually three types of

00:05:09,909 --> 00:05:16,030
the nodes the first node is validator

00:05:12,960 --> 00:05:19,210
it's the node who store the whole copy

00:05:16,030 --> 00:05:22,240
of the data and also its then these

00:05:19,210 --> 00:05:25,240
nodes is involved in the consensus also

00:05:22,240 --> 00:05:27,909
we have our dieter node so it's not

00:05:25,240 --> 00:05:30,819
quite the same as validator but it's not

00:05:27,909 --> 00:05:33,159
involved in the consensus and decline a

00:05:30,819 --> 00:05:37,060
light client so usually it's sitting

00:05:33,159 --> 00:05:40,810
duration integration part it's do not

00:05:37,060 --> 00:05:42,699
store any information from my notes but

00:05:40,810 --> 00:05:46,000
it's have all the functionality to get

00:05:42,699 --> 00:05:49,509
the proofs and to to the calculator all

00:05:46,000 --> 00:05:51,340
the proform on their site so usually on

00:05:49,509 --> 00:05:54,909
this site we are using our javascript

00:05:51,340 --> 00:05:58,300
javascript library ok let's move on to

00:05:54,909 --> 00:06:02,680
cryptographic proofs firstly I will

00:05:58,300 --> 00:06:04,840
start lives with theory and then just it

00:06:02,680 --> 00:06:08,800
will be more closer to the Colton to the

00:06:04,840 --> 00:06:11,919
our solution the first our exam storage

00:06:08,800 --> 00:06:15,729
based on the rocks GB so second beta key

00:06:11,919 --> 00:06:18,099
value storage we as a collection we have

00:06:15,729 --> 00:06:21,879
the usual position collections it's list

00:06:18,099 --> 00:06:23,800
is a map it's set and also on top of it

00:06:21,879 --> 00:06:26,110
we have some mechanised collections it's

00:06:23,800 --> 00:06:29,650
we called proof appendix and proof list

00:06:26,110 --> 00:06:31,690
index the about this collection I will

00:06:29,650 --> 00:06:35,259
talk a little bit later and also in the

00:06:31,690 --> 00:06:39,940
storage we store our transaction lock

00:06:35,259 --> 00:06:42,669
what actually is mock Chinese rocks DB

00:06:39,940 --> 00:06:43,789
sauce as I said earlier it's a key value

00:06:42,669 --> 00:06:46,430
storage

00:06:43,789 --> 00:06:50,089
the key and the values are stored as

00:06:46,430 --> 00:06:58,339
byte arrays and the keys are ordered

00:06:50,089 --> 00:07:01,669
based on the key value score as I said

00:06:58,339 --> 00:07:04,009
earlier we had visualized collections

00:07:01,669 --> 00:07:06,830
it's proof map index and proof list

00:07:04,009 --> 00:07:09,909
index and this actually collections

00:07:06,830 --> 00:07:16,699
based on on mere cro3

00:07:09,909 --> 00:07:20,899
data data collections so what what we

00:07:16,699 --> 00:07:24,800
are using using this for the first deal

00:07:20,899 --> 00:07:28,939
for the audition - to calculate the pass

00:07:24,800 --> 00:07:31,610
all of the data from the database and

00:07:28,939 --> 00:07:35,449
the second for for consensus for

00:07:31,610 --> 00:07:38,270
synchronization of the data this is how

00:07:35,449 --> 00:07:46,699
picture how the data is storing in our

00:07:38,270 --> 00:07:50,240
database so even here we can see this

00:07:46,699 --> 00:07:53,569
will be our tables that presented as

00:07:50,240 --> 00:07:58,099
Merkle trees for example this one will

00:07:53,569 --> 00:08:00,439
be at the table with name time stamping

00:07:58,099 --> 00:08:04,759
this will be some another tables let's

00:08:00,439 --> 00:08:07,430
code users and then as we as we have the

00:08:04,759 --> 00:08:09,770
mirco - the describe all the information

00:08:07,430 --> 00:08:12,819
of the table we can collect the whole

00:08:09,770 --> 00:08:18,889
the one common table or common three

00:08:12,819 --> 00:08:21,529
that from this tree we can calculate the

00:08:18,889 --> 00:08:24,849
the Merkle tree of this yucca root of

00:08:21,529 --> 00:08:27,919
the tree we will call it state hash and

00:08:24,849 --> 00:08:30,830
then we will publish it in block header

00:08:27,919 --> 00:08:33,079
and then this block hash we can also use

00:08:30,830 --> 00:08:40,579
it for anchoring to publish the keys in

00:08:33,079 --> 00:08:46,190
Bitcoin network so how the macro tree is

00:08:40,579 --> 00:08:48,980
looking looks for look so it's a

00:08:46,190 --> 00:08:50,839
particular it's a tree in the leaf we

00:08:48,980 --> 00:08:53,240
have the data and in the branch we have

00:08:50,839 --> 00:08:56,000
the hashes that calculated pair by pair

00:08:53,240 --> 00:08:57,230
from the trees and on the top we receive

00:08:56,000 --> 00:09:03,470
the mark of protest

00:08:57,230 --> 00:09:06,680
that allow us to describe the data how

00:09:03,470 --> 00:09:09,200
to encode this data in our database so

00:09:06,680 --> 00:09:21,380
we are used as a key value storage for

00:09:09,200 --> 00:09:26,090
the key we are using okay so for the key

00:09:21,380 --> 00:09:30,200
we have been encode the key so we need

00:09:26,090 --> 00:09:33,350
to encode our tree with some indexes so

00:09:30,200 --> 00:09:36,140
how do we encode itself the key consists

00:09:33,350 --> 00:09:39,440
with hate in index the head it's the

00:09:36,140 --> 00:09:40,820
head of the of the tree and the index is

00:09:39,440 --> 00:09:45,320
the position like if we called

00:09:40,820 --> 00:09:48,200
horizontal key in the tree this is some

00:09:45,320 --> 00:09:50,800
kind of example how how some values will

00:09:48,200 --> 00:09:55,640
be stored in the day in the table and

00:09:50,800 --> 00:09:57,890
let's move to the proofs so this is a

00:09:55,640 --> 00:10:02,360
simple example we have a very small tree

00:09:57,890 --> 00:10:05,840
and we want let's pretend that this case

00:10:02,360 --> 00:10:08,390
and user want to know what is path what

00:10:05,840 --> 00:10:11,090
is the proof pass for this value and for

00:10:08,390 --> 00:10:13,700
this value so the actual path will be

00:10:11,090 --> 00:10:20,270
like for this value will be like here

00:10:13,700 --> 00:10:22,970
and for this value will be like here we

00:10:20,270 --> 00:10:25,070
will encode it as a JSON file and this

00:10:22,970 --> 00:10:27,680
JSON file we can send to the to the

00:10:25,070 --> 00:10:32,680
client and the client on on on his side

00:10:27,680 --> 00:10:36,860
can calculate but he found the state and

00:10:32,680 --> 00:10:41,660
compared with the state that writen in

00:10:36,860 --> 00:10:43,430
block chain for the proof appendix we'll

00:10:41,660 --> 00:10:46,850
use a little bit different data

00:10:43,430 --> 00:10:51,410
structure it's murkrow Patricia tree

00:10:46,850 --> 00:10:55,850
it's based on the radix tree and so how

00:10:51,410 --> 00:10:59,060
how let's just remember how radix 3

00:10:55,850 --> 00:11:00,770
walks we have some index and based on

00:10:59,060 --> 00:11:04,090
similarity index we are building the

00:11:00,770 --> 00:11:09,260
tree for example if I want to search the

00:11:04,090 --> 00:11:11,000
values that encoded with index Romain we

00:11:09,260 --> 00:11:13,100
will follow this path

00:11:11,000 --> 00:11:16,129
and on this path we will have some

00:11:13,100 --> 00:11:19,189
similarities and this we can find these

00:11:16,129 --> 00:11:22,009
switches for Mirko

00:11:19,189 --> 00:11:25,490
we're like former competition trivia as

00:11:22,009 --> 00:11:27,879
a for index we're using hash and if the

00:11:25,490 --> 00:11:31,339
mechanism will be kind of the same but

00:11:27,879 --> 00:11:37,610
for like for the index will be using

00:11:31,339 --> 00:11:40,339
hashes again let's do it it's return to

00:11:37,610 --> 00:11:42,860
the like for our pictures we have our

00:11:40,339 --> 00:11:45,350
database and the user now I want to

00:11:42,860 --> 00:11:48,949
request so we have like working system

00:11:45,350 --> 00:11:50,660
and the user won't want to like through

00:11:48,949 --> 00:11:54,230
the web client want to request the proof

00:11:50,660 --> 00:11:58,129
his has some record and he want to get

00:11:54,230 --> 00:12:02,779
the whole proof how his data record

00:11:58,129 --> 00:12:07,160
stored in database this is how it will

00:12:02,779 --> 00:12:11,389
be looked for look wow so for example

00:12:07,160 --> 00:12:16,879
I'm asking for for the data with ID Bob

00:12:11,389 --> 00:12:20,420
and the proof the full proof pass will

00:12:16,879 --> 00:12:22,790
be like here so we will follow the pass

00:12:20,420 --> 00:12:26,240
in time stamps tables then we'll fold

00:12:22,790 --> 00:12:29,769
the past means in our common state hash

00:12:26,240 --> 00:12:32,870
table and also we want to receive some

00:12:29,769 --> 00:12:38,480
information from the blockchain related

00:12:32,870 --> 00:12:41,089
to the blockchain now it's part for the

00:12:38,480 --> 00:12:43,610
demo but firstly I won't quickly go

00:12:41,089 --> 00:12:45,589
through the code of our application the

00:12:43,610 --> 00:12:47,509
demo will be based on the simple

00:12:45,589 --> 00:12:50,930
application is time step we called time

00:12:47,509 --> 00:12:54,319
stamping so basically housework we have

00:12:50,930 --> 00:12:56,240
file alkalis the hash of the file and we

00:12:54,319 --> 00:12:59,180
put in we have write it in the

00:12:56,240 --> 00:13:02,600
blockchain why we need for we need to

00:12:59,180 --> 00:13:05,809
make a proof that this the this file has

00:13:02,600 --> 00:13:12,740
has like the same the particular state

00:13:05,809 --> 00:13:14,809
in the particular time firstly we say we

00:13:12,740 --> 00:13:20,889
are forming our transaction it's hope

00:13:14,809 --> 00:13:20,889
Jason and we are sending it to our node

00:13:22,360 --> 00:13:32,620
then the note have Dino has a REST API

00:13:27,940 --> 00:13:35,649
Handler and here we go so what we will

00:13:32,620 --> 00:13:38,470
do so we all calculate the hash of our

00:13:35,649 --> 00:13:40,899
input transaction then we will send this

00:13:38,470 --> 00:13:44,890
information to peer-to-peer network and

00:13:40,899 --> 00:13:50,730
we will response with the hash of this

00:13:44,890 --> 00:13:57,490
transaction here we are describing our

00:13:50,730 --> 00:14:00,279
transaction and this is our business

00:13:57,490 --> 00:14:03,930
logic what we will do without injection

00:14:00,279 --> 00:14:06,700
first we will verify our transaction and

00:14:03,930 --> 00:14:10,060
the second we will do some execution

00:14:06,700 --> 00:14:13,209
code here we will call our database

00:14:10,060 --> 00:14:15,940
checking that this is a new record and

00:14:13,209 --> 00:14:21,490
then we are writing this worker to the

00:14:15,940 --> 00:14:25,510
database and this how we will describe

00:14:21,490 --> 00:14:28,690
our database here we can see our proof

00:14:25,510 --> 00:14:32,500
appendix and we call our table this time

00:14:28,690 --> 00:14:35,470
Stimac timestamps and this is auxiliary

00:14:32,500 --> 00:14:41,610
function to add to write our data to

00:14:35,470 --> 00:14:41,610
database let's move on to demo

00:14:43,829 --> 00:14:49,649
ok first I need to stop presentation

00:15:05,040 --> 00:15:13,880
case I'm checking up Robles okay let's

00:15:11,160 --> 00:15:13,880
work like this

00:15:25,970 --> 00:15:37,730
so first I start there the note I know

00:15:34,320 --> 00:15:37,730
it's not gonna work in this way

00:15:51,630 --> 00:15:57,560
no it's working okay

00:16:00,850 --> 00:16:07,689
so I have started the note it's started

00:16:04,029 --> 00:16:11,429
to work then I will start my web

00:16:07,689 --> 00:16:15,970
application then I will go to my

00:16:11,429 --> 00:16:20,139
application the interface is quite

00:16:15,970 --> 00:16:22,869
simple so what I can do from this web

00:16:20,139 --> 00:16:27,009
application I can upload my file I'll

00:16:22,869 --> 00:16:29,319
write some metadata and send this

00:16:27,009 --> 00:16:35,769
information to block chain so we can

00:16:29,319 --> 00:16:38,410
follow the transactions and check check

00:16:35,769 --> 00:16:40,839
house was stored in Bob chain you can

00:16:38,410 --> 00:16:46,299
see that it's stored in this particular

00:16:40,839 --> 00:16:52,529
block and let's I need to upload a

00:16:46,299 --> 00:16:52,529
little bit more files in the file tool

00:16:57,550 --> 00:17:09,130
by all three okay now we have this file

00:17:01,420 --> 00:17:11,530
and I'm going to search for this file in

00:17:09,130 --> 00:17:12,870
my interface and then when I call this

00:17:11,530 --> 00:17:16,870
search

00:17:12,870 --> 00:17:20,650
actually I'm called the API demo input

00:17:16,870 --> 00:17:24,670
and the it VPA input provide this type

00:17:20,650 --> 00:17:28,060
of information so what we have here we

00:17:24,670 --> 00:17:31,300
have our information about who was

00:17:28,060 --> 00:17:34,380
called for this for this transaction we

00:17:31,300 --> 00:17:39,700
would then we will have the information

00:17:34,380 --> 00:17:43,000
about our state hash table and we can

00:17:39,700 --> 00:17:45,610
see here the proof pass how we can find

00:17:43,000 --> 00:17:51,070
this information this is an affirmation

00:17:45,610 --> 00:17:53,800
is it's information about our table so

00:17:51,070 --> 00:17:56,680
we are storing our table and in our lake

00:17:53,800 --> 00:17:59,650
state hash table state hash tree and

00:17:56,680 --> 00:18:04,110
this is a proof how we will search how

00:17:59,650 --> 00:18:09,040
we search this table and then we have

00:18:04,110 --> 00:18:12,760
then we have our time step proof this is

00:18:09,040 --> 00:18:16,780
for the value that we uphold it and this

00:18:12,760 --> 00:18:18,540
is a proof pass how it was stored in the

00:18:16,780 --> 00:18:24,480
tree

00:18:18,540 --> 00:18:24,480
let's okay

00:18:24,660 --> 00:18:29,760
so what's happening on the front end

00:18:27,490 --> 00:18:29,760
side

00:18:37,540 --> 00:18:45,760
so when he called the search button we

00:18:40,990 --> 00:18:48,940
called we called this part of cold so we

00:18:45,760 --> 00:18:51,870
can see is the the we call decent point

00:18:48,940 --> 00:18:54,760
that I showed short just previously

00:18:51,870 --> 00:18:56,170
first of you we are finding the block so

00:18:54,760 --> 00:18:57,700
we are getting information with free

00:18:56,170 --> 00:19:01,780
Commission checking that this was okay

00:18:57,700 --> 00:19:05,800
and it was signed clearly then we are

00:19:01,780 --> 00:19:09,130
looking for our table in our state hash

00:19:05,800 --> 00:19:14,830
table and we are want to be sure that

00:19:09,130 --> 00:19:17,050
it's we are tracking this table and and

00:19:14,830 --> 00:19:20,670
then we are looking for our record

00:19:17,050 --> 00:19:24,670
record actually in timestamp table and

00:19:20,670 --> 00:19:25,650
checking our three pass on the

00:19:24,670 --> 00:19:28,720
client-side

00:19:25,650 --> 00:19:35,170
if everything okay we will return our

00:19:28,720 --> 00:19:39,730
data how do you look like on them on the

00:19:35,170 --> 00:19:43,870
exonym on the back hand side we are

00:19:39,730 --> 00:19:48,310
getting this is our database so we are

00:19:43,870 --> 00:19:51,460
firstly requesting the information from

00:19:48,310 --> 00:19:53,500
the database about our last block then

00:19:51,460 --> 00:19:55,990
we are equating information about our

00:19:53,500 --> 00:19:58,270
blocks and pre chemists and then we

00:19:55,990 --> 00:20:03,280
equate requesting our proofs for this

00:19:58,270 --> 00:20:07,920
table and then we are returning on this

00:20:03,280 --> 00:20:07,920
information for for our Clyde

00:20:09,160 --> 00:20:18,700
okay so let's return to presentation so

00:20:16,450 --> 00:20:21,660
as a conclusion I can say so the

00:20:18,700 --> 00:20:26,290
mechanized collections can provide our

00:20:21,660 --> 00:20:28,990
mechanism to to build like the data that

00:20:26,290 --> 00:20:33,790
the client can be checked on on his side

00:20:28,990 --> 00:20:36,280
and also I showed how we build this

00:20:33,790 --> 00:20:39,510
approach in our solution specially with

00:20:36,280 --> 00:20:39,510
white clay and in Zaandam

00:20:39,840 --> 00:20:45,450
thank you for attention

00:20:41,710 --> 00:20:45,450
I'm ready to answering for your question

00:20:47,420 --> 00:20:54,750
[Applause]

00:20:50,660 --> 00:20:57,360
you mentioned the PFT protocol what do

00:20:54,750 --> 00:20:59,360
you use is it something that you can

00:20:57,360 --> 00:21:03,750
pick any or do you have one

00:20:59,360 --> 00:21:05,460
implementation from you thank you for a

00:21:03,750 --> 00:21:08,420
question special we're using pbft

00:21:05,460 --> 00:21:11,550
algorithm it's complimented bar i'll

00:21:08,420 --> 00:21:14,910
ourselves so it's not based on some open

00:21:11,550 --> 00:21:17,280
source library but as they're like the

00:21:14,910 --> 00:21:20,250
folds on open source you can go to

00:21:17,280 --> 00:21:20,910
github and check our ability ssin okay

00:21:20,250 --> 00:21:22,860
thank you

00:21:20,910 --> 00:21:26,570
are you planning on introducing

00:21:22,860 --> 00:21:29,850
anchoring to other large blockchain

00:21:26,570 --> 00:21:34,310
introducing excuse me anchoring to other

00:21:29,850 --> 00:21:41,310
large block chains other than Bitcoin so

00:21:34,310 --> 00:21:43,710
um yeah we have we have the plans but by

00:21:41,310 --> 00:21:46,500
now like all like our business

00:21:43,710 --> 00:21:49,740
requirements was was was fully like

00:21:46,500 --> 00:21:52,320
closed by or but the Bitcoin and it was

00:21:49,740 --> 00:21:55,440
by this moment it was quite enough and

00:21:52,320 --> 00:21:58,640
this way and also we were quite big

00:21:55,440 --> 00:22:03,030
support the Bitcoin network this wired

00:21:58,640 --> 00:22:05,670
but also like this this also like open

00:22:03,030 --> 00:22:09,240
sourced and is quite easier to switch to

00:22:05,670 --> 00:22:11,690
another upon block chains okay thank you

00:22:09,240 --> 00:22:11,690
for attention

00:22:11,800 --> 00:22:16,290

YouTube URL: https://www.youtube.com/watch?v=IiOwDBbtQtI


