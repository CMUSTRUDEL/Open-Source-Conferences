Title: Beyond blockchain: PARSEC, bringing consensus to the next level with Rust Pierre Chevalier
Publication date: 2019-02-06
Playlist: RustRush 2018
Description: 
	Rust programmer and leader of the Routing team at Maidsafe, Pierre Chevalier participated in the invention of PARSEC: a next generation consensus protocol and is now overseeing its development in the open, in Rust.

Invented in 2018, PARSEC is a revolutionary algorithm that has the potential to disrupt the blockchain by offering a scalable, mathematically proven alternative for trustless consensus. It is open-source and written in rust. Co-inventor Pierre will blow your socks off by explaining its ins and outs.
Captions: 
	00:00:02,590 --> 00:00:08,889
hi everyone so I'm Pierre Chevalier I

00:00:06,670 --> 00:00:12,490
work for made safe I've been working

00:00:08,889 --> 00:00:15,160
here for a bit under a year and since

00:00:12,490 --> 00:00:18,700
I've joined I've been working on parsec

00:00:15,160 --> 00:00:20,440
which is our consensus protocol I was

00:00:18,700 --> 00:00:22,750
involved in the since the early stages

00:00:20,440 --> 00:00:25,120
of design and now I'm leading the team

00:00:22,750 --> 00:00:27,460
that's developing it and bring it to

00:00:25,120 --> 00:00:30,370
production so today that's what my talk

00:00:27,460 --> 00:00:32,469
is going to be about but if you don't

00:00:30,370 --> 00:00:35,980
know what the safe network is the

00:00:32,469 --> 00:00:37,390
one-line version is it's a data and

00:00:35,980 --> 00:00:39,519
communications network

00:00:37,390 --> 00:00:42,280
that's decentralized and encrypted and

00:00:39,519 --> 00:00:45,100
the reason we are building that is to

00:00:42,280 --> 00:00:46,870
give back to everyone the privacy

00:00:45,100 --> 00:00:52,359
security and freedom that they've lost

00:00:46,870 --> 00:00:54,579
in today's internet so the title of this

00:00:52,359 --> 00:00:56,710
talk is beyond blockchain Pathak

00:00:54,579 --> 00:00:59,319
bringing consensus to the next level

00:00:56,710 --> 00:01:01,569
with rust and because I'm lazy the plan

00:00:59,319 --> 00:01:06,520
is going to be tackle each section of

00:01:01,569 --> 00:01:09,399
the title one by one so why do I say be

00:01:06,520 --> 00:01:12,820
on blockchain what do I mean well no

00:01:09,399 --> 00:01:14,770
we're in late 2018 so I'm guessing that

00:01:12,820 --> 00:01:17,229
everyone has heard of blockchain and

00:01:14,770 --> 00:01:20,380
maybe some of the connotations it has

00:01:17,229 --> 00:01:22,530
are not very good anymore maybe when I

00:01:20,380 --> 00:01:25,299
say blockchain you think it's a buzzword

00:01:22,530 --> 00:01:27,009
maybe you think there are tons of high

00:01:25,299 --> 00:01:30,329
volatility assets which I would wait to

00:01:27,009 --> 00:01:33,130
lose your mortgage maybe you're thinking

00:01:30,329 --> 00:01:35,829
some projects are subpar in quality

00:01:33,130 --> 00:01:36,969
maybe you're thinking a lot of actors in

00:01:35,829 --> 00:01:39,609
the blockchain space are just

00:01:36,969 --> 00:01:41,710
straight-up scammers maybe you're

00:01:39,609 --> 00:01:45,810
thinking pop and dumps etc there are

00:01:41,710 --> 00:01:49,990
lots of negative connotations that have

00:01:45,810 --> 00:01:51,700
risen in the last few years but I'd like

00:01:49,990 --> 00:01:53,979
for you to remember what you thought of

00:01:51,700 --> 00:01:57,399
blockchain when you discovered the

00:01:53,979 --> 00:01:59,499
concept like for instance when you first

00:01:57,399 --> 00:02:02,799
read the Bitcoin white paper whenever

00:01:59,499 --> 00:02:06,609
that was and when I think of blockchain

00:02:02,799 --> 00:02:09,640
I remember that on the basis it was one

00:02:06,609 --> 00:02:11,890
simple and elegant idea that could be

00:02:09,640 --> 00:02:14,770
expressed in only a short white paper

00:02:11,890 --> 00:02:17,380
only nine pages mostly plain English

00:02:14,770 --> 00:02:21,520
barely any maths pictures in there in

00:02:17,380 --> 00:02:24,580
the nine pages and with that white paper

00:02:21,520 --> 00:02:26,620
we had a way to remove the need for

00:02:24,580 --> 00:02:28,600
trust in money in the issuance of

00:02:26,620 --> 00:02:33,190
currency and in validating transactions

00:02:28,600 --> 00:02:37,360
and so that idea was extremely powerful

00:02:33,190 --> 00:02:39,610
it it allowed us from system while you

00:02:37,360 --> 00:02:43,270
need it if you wanted to send cash

00:02:39,610 --> 00:02:45,490
electronically to trust some third party

00:02:43,270 --> 00:02:47,320
then you could just have two people on

00:02:45,490 --> 00:02:49,930
other sides of the planet don't know the

00:02:47,320 --> 00:02:51,610
piece of software it runs some protocol

00:02:49,930 --> 00:02:55,510
and the exchange money and it's nobody's

00:02:51,610 --> 00:02:59,230
business so for that reason blockchain

00:02:55,510 --> 00:03:02,920
became kind of a breaking change in in

00:02:59,230 --> 00:03:04,300
society and that's why then there has

00:03:02,920 --> 00:03:06,100
been all the success and all the

00:03:04,300 --> 00:03:08,980
negative consequences of the success as

00:03:06,100 --> 00:03:10,450
well and so the big idea behind

00:03:08,980 --> 00:03:14,170
blockchain of course was the proof of

00:03:10,450 --> 00:03:16,540
work which acts partly as a consensus

00:03:14,170 --> 00:03:20,260
mechanism so it's sort of the double

00:03:16,540 --> 00:03:23,770
span problem with proof of work you can

00:03:20,260 --> 00:03:26,230
know that someone is not spending the

00:03:23,770 --> 00:03:27,910
same money twice and another aspect of

00:03:26,230 --> 00:03:31,960
proof of work is that it's a civil

00:03:27,910 --> 00:03:34,660
mechanism so if you want to do anything

00:03:31,960 --> 00:03:37,900
malicious on a blockchain if you try to

00:03:34,660 --> 00:03:39,550
spawn a hundred thousand a million fake

00:03:37,900 --> 00:03:41,680
identities it doesn't change anything

00:03:39,550 --> 00:03:43,690
because you need the harsh right to

00:03:41,680 --> 00:03:47,230
control over half the half rate of the

00:03:43,690 --> 00:03:50,170
network so that was kind of the the big

00:03:47,230 --> 00:03:51,910
innovation now why am I even speaking

00:03:50,170 --> 00:03:54,040
about blockchain it's a bit cheeky

00:03:51,910 --> 00:03:56,230
because what we do at made safe is not

00:03:54,040 --> 00:03:59,350
blob chain based has no gluten anywhere

00:03:56,230 --> 00:04:03,250
but it's just as an introduction of how

00:03:59,350 --> 00:04:07,300
simple math can just have big societal

00:04:03,250 --> 00:04:09,520
impacts and while blockchain was being

00:04:07,300 --> 00:04:12,400
worked on so the white paper the beacon

00:04:09,520 --> 00:04:16,299
white paper was released in 2008 already

00:04:12,400 --> 00:04:19,120
since 2006 in Scotland a man called

00:04:16,299 --> 00:04:21,220
David Ervine had been thinking of

00:04:19,120 --> 00:04:23,260
similar problems in a different space

00:04:21,220 --> 00:04:26,440
and the question he was trying to answer

00:04:23,260 --> 00:04:27,750
is how can we remove trust from the

00:04:26,440 --> 00:04:29,010
internet

00:04:27,750 --> 00:04:30,540
and turns out that's a bit more

00:04:29,010 --> 00:04:33,000
complicated than removing trust in

00:04:30,540 --> 00:04:35,280
finance because you've got many layers

00:04:33,000 --> 00:04:36,810
to the internet from DNS from

00:04:35,280 --> 00:04:40,260
peer-to-peer connection also a

00:04:36,810 --> 00:04:43,020
connection layer there is many many

00:04:40,260 --> 00:04:45,720
parts to this problem but the

00:04:43,020 --> 00:04:50,190
fundamental thing you need to do is to

00:04:45,720 --> 00:04:52,440
remove the server the server is a place

00:04:50,190 --> 00:04:54,690
where the NSA can put a prism and

00:04:52,440 --> 00:04:57,540
because all your data transits by these

00:04:54,690 --> 00:04:59,850
big data centers they can see everything

00:04:57,540 --> 00:05:01,830
that you're doing and it's a place

00:04:59,850 --> 00:05:03,990
that's a honeypot for all kinds of

00:05:01,830 --> 00:05:09,300
hackers to take down and to get access

00:05:03,990 --> 00:05:13,770
to your data so by removing the server

00:05:09,300 --> 00:05:15,990
and by creating this network we which we

00:05:13,770 --> 00:05:18,900
call the safe Network we want to project

00:05:15,990 --> 00:05:22,860
you procure secure access for everyone

00:05:18,900 --> 00:05:25,130
that's what safe stands for but of

00:05:22,860 --> 00:05:28,290
course if you remove the server you need

00:05:25,130 --> 00:05:29,820
some way to get for instance if you if

00:05:28,290 --> 00:05:31,650
you want to request data from the

00:05:29,820 --> 00:05:33,360
network you need some way to get that

00:05:31,650 --> 00:05:36,240
data back but without the trust in a

00:05:33,360 --> 00:05:38,340
server and so that first comes in the

00:05:36,240 --> 00:05:41,370
form of a number of servers cooperating

00:05:38,340 --> 00:05:44,930
together reaching consensus and what you

00:05:41,370 --> 00:05:47,040
rely on is that a fraction of these

00:05:44,930 --> 00:05:50,520
computers is honest a big enough

00:05:47,040 --> 00:05:52,020
fraction is honest so yeah the safe

00:05:50,520 --> 00:05:54,600
Network were trying to build a network

00:05:52,020 --> 00:05:58,740
for humans based on human values such as

00:05:54,600 --> 00:06:01,200
respecting your privacy and network

00:05:58,740 --> 00:06:03,240
that's built in collaboration so made

00:06:01,200 --> 00:06:05,700
safe is currently the company that's

00:06:03,240 --> 00:06:08,070
working on the project but it's also

00:06:05,700 --> 00:06:10,290
open source and we invite everyone to

00:06:08,070 --> 00:06:13,470
participate in building this thing as

00:06:10,290 --> 00:06:18,030
well if it succeeds it kind of bigger

00:06:13,470 --> 00:06:21,030
than a company or an individual so yeah

00:06:18,030 --> 00:06:23,729
the safe network has many parts to it

00:06:21,030 --> 00:06:26,130
one part is actually called cross

00:06:23,729 --> 00:06:28,320
connections in rust which is a bit

00:06:26,130 --> 00:06:32,970
similar to Olympia to P that Pierre gave

00:06:28,320 --> 00:06:35,460
a talk about before but anyway so if you

00:06:32,970 --> 00:06:37,349
want to learn about all these parts of

00:06:35,460 --> 00:06:39,990
the safe network I'd recommend you check

00:06:37,349 --> 00:06:41,490
out our website safe Network the tech

00:06:39,990 --> 00:06:47,850
and from knowing I'm gonna be focusing

00:06:41,490 --> 00:06:50,100
on parsec in this talk so parsec is a

00:06:47,850 --> 00:06:52,740
consensus protocol so I'll just give you

00:06:50,100 --> 00:06:55,470
a one-liner about the consensus protocol

00:06:52,740 --> 00:06:58,800
you've got a number of computers that

00:06:55,470 --> 00:07:01,940
see things happening and they need to

00:06:58,800 --> 00:07:04,890
decide on the order in which they happen

00:07:01,940 --> 00:07:07,560
so everyone could propose an order but

00:07:04,890 --> 00:07:09,270
because of latency and stuff they could

00:07:07,560 --> 00:07:12,090
see things genuinely in different ways

00:07:09,270 --> 00:07:15,210
and then it's Byzantine fault or event

00:07:12,090 --> 00:07:19,140
if it is resilient to malicious actors

00:07:15,210 --> 00:07:22,260
trying to break the protocol while one s

00:07:19,140 --> 00:07:26,010
not the trying to agree on the next

00:07:22,260 --> 00:07:29,160
value so for all uses in the safe

00:07:26,010 --> 00:07:31,950
Network we needed a consensus protocol

00:07:29,160 --> 00:07:35,850
that was asynchronous because we want to

00:07:31,950 --> 00:07:38,760
do we want to do internet scale thing so

00:07:35,850 --> 00:07:41,280
you'd have no guarantee about latency in

00:07:38,760 --> 00:07:43,440
any case you could have all kinds of

00:07:41,280 --> 00:07:46,440
weird things so if you rely on timing

00:07:43,440 --> 00:07:49,560
you are likely to introduce security

00:07:46,440 --> 00:07:51,870
vulnerabilities for later we wanted

00:07:49,560 --> 00:07:55,410
something that's scalable again internet

00:07:51,870 --> 00:07:59,310
scale so something that's permissionless

00:07:55,410 --> 00:08:01,560
so on one hand it means being resilient

00:07:59,310 --> 00:08:03,900
to malice and on another hand it means

00:08:01,560 --> 00:08:05,780
being able to accommodate nodes joining

00:08:03,900 --> 00:08:08,880
and leaving the

00:08:05,780 --> 00:08:12,030
section of the network while consensus

00:08:08,880 --> 00:08:13,890
is happening of course we wanted it to

00:08:12,030 --> 00:08:16,530
be open source because the entire safe

00:08:13,890 --> 00:08:20,400
network the entire stack is a number of

00:08:16,530 --> 00:08:23,070
open source modules and that's why it's

00:08:20,400 --> 00:08:26,070
intended and we wanted it to be simple

00:08:23,070 --> 00:08:28,680
not only because of maths no BISM

00:08:26,070 --> 00:08:31,830
although that's a part of it but also

00:08:28,680 --> 00:08:33,930
because simplicity in an algorithm means

00:08:31,830 --> 00:08:36,060
security because it means that other

00:08:33,930 --> 00:08:37,710
people can review the algorithm and they

00:08:36,060 --> 00:08:40,320
can convince themselves it's correct and

00:08:37,710 --> 00:08:44,580
you don't have to like have some kind of

00:08:40,320 --> 00:08:48,540
weird loopholes in the middle so now

00:08:44,580 --> 00:08:50,780
I'll explain how parsec works but first

00:08:48,540 --> 00:08:53,640
I'll give you the recipe ahead of time

00:08:50,780 --> 00:08:56,310
so recipe first you use gossip

00:08:53,640 --> 00:09:00,000
then you build a directed acyclic graph

00:08:56,310 --> 00:09:02,339
of your basic communications then we'll

00:09:00,000 --> 00:09:05,579
define the concept of an observer and

00:09:02,339 --> 00:09:10,560
with this concept of an observer you can

00:09:05,579 --> 00:09:13,589
reduce the problem of general Valentine

00:09:10,560 --> 00:09:16,019
fault-tolerant protocol to a simpler

00:09:13,589 --> 00:09:17,850
problem I'm not going to tell you which

00:09:16,019 --> 00:09:19,740
simpler problem yet because as you can

00:09:17,850 --> 00:09:21,019
just leave the room and speaking to know

00:09:19,740 --> 00:09:24,660
what

00:09:21,019 --> 00:09:27,709
so first gossip gossip is a way of

00:09:24,660 --> 00:09:31,320
communicating in a network that's both

00:09:27,709 --> 00:09:33,240
efficient and resilient so I will give

00:09:31,320 --> 00:09:35,010
you two examples of what what's an

00:09:33,240 --> 00:09:36,690
efficient way what's a resilient way and

00:09:35,010 --> 00:09:39,660
then sure why gossip is a good middle

00:09:36,690 --> 00:09:42,000
ground so an efficient way to

00:09:39,660 --> 00:09:43,620
communicate between nodes is everyone

00:09:42,000 --> 00:09:46,019
sits in a circle everyone communicates

00:09:43,620 --> 00:09:48,240
data to the node on the right until

00:09:46,019 --> 00:09:50,579
everyone has seen the data and the cost

00:09:48,240 --> 00:09:54,300
of this is n communications to share a

00:09:50,579 --> 00:09:56,880
message between n nodes so that's very

00:09:54,300 --> 00:10:00,060
efficient however if any node stops

00:09:56,880 --> 00:10:03,600
playing ball the message will be lost so

00:10:00,060 --> 00:10:05,579
it's absolutely not resilient a way to

00:10:03,600 --> 00:10:07,920
communicate information in a network

00:10:05,579 --> 00:10:09,690
that's resilient is broadcast so that n

00:10:07,920 --> 00:10:11,519
nodes all send all the information they

00:10:09,690 --> 00:10:14,070
know to everyone but then the cost of

00:10:11,519 --> 00:10:16,949
propagating a message between n nodes is

00:10:14,070 --> 00:10:20,399
N squared which is not efficient so

00:10:16,949 --> 00:10:24,029
gossip is a middle ground where nodes

00:10:20,399 --> 00:10:26,399
just send data randomly to a node every

00:10:24,029 --> 00:10:29,810
now and then and it turns out with that

00:10:26,399 --> 00:10:34,589
randomness the the property you get is

00:10:29,810 --> 00:10:36,990
messages get propagated in n log n like

00:10:34,589 --> 00:10:38,699
n being the number of nodes and on

00:10:36,990 --> 00:10:41,670
another hand you're very resilient

00:10:38,699 --> 00:10:44,070
because malicious nodes don't know who

00:10:41,670 --> 00:10:48,000
to hinder or like who to target if they

00:10:44,070 --> 00:10:49,769
want to stop you communicating and so

00:10:48,000 --> 00:10:52,709
statistically it will always make its

00:10:49,769 --> 00:10:55,760
way through anyway they cannot just stop

00:10:52,709 --> 00:10:55,760
everyone at the same time

00:11:00,990 --> 00:11:08,560
okay so so in PASOK the nodes

00:11:05,710 --> 00:11:10,750
communicate through gossip and that

00:11:08,560 --> 00:11:13,300
allows them to build an a gossip graph

00:11:10,750 --> 00:11:14,890
so that's a directed acyclic graph that

00:11:13,300 --> 00:11:18,400
records the communications that happened

00:11:14,890 --> 00:11:20,560
in the network and then two to reach

00:11:18,400 --> 00:11:23,140
agreement on the next value the question

00:11:20,560 --> 00:11:25,270
is going to be from looking at what I

00:11:23,140 --> 00:11:26,980
see of the gossip graph what's the next

00:11:25,270 --> 00:11:29,830
value and if I do this I want for

00:11:26,980 --> 00:11:32,110
everyone else to see the same thing so

00:11:29,830 --> 00:11:34,180
gossip graph let's take an example

00:11:32,110 --> 00:11:36,280
because it's easier to visualize than

00:11:34,180 --> 00:11:38,170
explained in the abstract we've got four

00:11:36,280 --> 00:11:41,290
nodes here called Alice Bob Carol and

00:11:38,170 --> 00:11:44,980
Dave and when things happen in the

00:11:41,290 --> 00:11:47,410
network nodes will create an event a

00:11:44,980 --> 00:11:49,600
gossip event to record that something

00:11:47,410 --> 00:11:52,120
happened so an example of this is

00:11:49,600 --> 00:11:55,690
another node wants to join these four

00:11:52,120 --> 00:11:58,090
nodes and issues a message and say Bob

00:11:55,690 --> 00:11:59,740
sees this message and so he records that

00:11:58,090 --> 00:12:02,280
in creating a gossip event that says

00:11:59,740 --> 00:12:06,240
okay say everyone's to join the party

00:12:02,280 --> 00:12:08,530
and then like because it's gossip

00:12:06,240 --> 00:12:11,170
someone will randomly pick someone else

00:12:08,530 --> 00:12:13,930
to communicate here Bob picks Carol and

00:12:11,170 --> 00:12:17,170
when Carol receives this communication

00:12:13,930 --> 00:12:19,420
so Bob sends her his what he knows of

00:12:17,170 --> 00:12:21,910
the bottom graph at the moment and she

00:12:19,420 --> 00:12:24,400
creates a gossip event that has the hush

00:12:21,910 --> 00:12:29,290
of what he sent her and the hush of her

00:12:24,400 --> 00:12:32,860
oldest event and say no maybe Bob picks

00:12:29,290 --> 00:12:34,900
Alice maybe Alice speaks Bob again and

00:12:32,860 --> 00:12:38,590
you can communicate like this randomly

00:12:34,900 --> 00:12:40,300
and build a bit of a graph so this is

00:12:38,590 --> 00:12:42,370
just big enough to show a few concepts

00:12:40,300 --> 00:12:46,450
and defend the concept of observer so

00:12:42,370 --> 00:12:48,220
I'm gonna stop here just for explaining

00:12:46,450 --> 00:12:51,190
concepts in the next few slides I'm

00:12:48,220 --> 00:12:53,920
giving a name to the gossip events so

00:12:51,190 --> 00:12:56,350
I'm naming them from the initial of the

00:12:53,920 --> 00:12:58,900
node and then 0 1 2 going up in the

00:12:56,350 --> 00:13:02,890
graph so the oldest one is a 0 0 does

00:12:58,900 --> 00:13:04,420
run by Alice for instance so no we want

00:13:02,890 --> 00:13:06,040
to defend the concept of observer

00:13:04,420 --> 00:13:10,510
because you'll see that it allows to

00:13:06,040 --> 00:13:13,060
simplify the problem of a BFG or Besant

00:13:10,510 --> 00:13:15,400
and forth around protocol

00:13:13,060 --> 00:13:20,590
and we'll start by defining the concept

00:13:15,400 --> 00:13:23,770
of seeing so well the very simplest way

00:13:20,590 --> 00:13:25,690
possible and so seeing is a relationship

00:13:23,770 --> 00:13:27,610
between to gossip events and the very

00:13:25,690 --> 00:13:29,620
simplest way a gossip event can see

00:13:27,610 --> 00:13:31,240
another gossip event if is if the other

00:13:29,620 --> 00:13:33,040
gossip event is itself

00:13:31,240 --> 00:13:36,910
so each gossip event sees itself and

00:13:33,040 --> 00:13:39,880
then the next simplest way is if the

00:13:36,910 --> 00:13:43,840
other gossip event is a self parent or

00:13:39,880 --> 00:13:47,710
another parent so for instance here a1 C

00:13:43,840 --> 00:13:50,230
is C 0 because C 0 is the other parent

00:13:47,710 --> 00:13:53,440
of a 1 so the other parent is the del

00:13:50,230 --> 00:13:57,370
diagonal relationships in this graph and

00:13:53,440 --> 00:14:01,690
then it's transitive so for instance C 2

00:13:57,370 --> 00:14:05,170
C is B 0 because basically B 0 is an

00:14:01,690 --> 00:14:06,760
ancestor of C 2 in this graph but

00:14:05,170 --> 00:14:08,560
currently I've just defined the notion

00:14:06,760 --> 00:14:11,410
of being an ancestor in a directed

00:14:08,560 --> 00:14:13,600
acyclic graph and where there is a

00:14:11,410 --> 00:14:18,730
difference with the concept of seeing is

00:14:13,600 --> 00:14:21,700
in the case of Forks so a fork is if a

00:14:18,730 --> 00:14:24,250
node creates it's like a double span

00:14:21,700 --> 00:14:29,020
basically if a knot creates to gossip

00:14:24,250 --> 00:14:34,120
events that have the same self parent

00:14:29,020 --> 00:14:36,670
and this is malicious behavior so it it

00:14:34,120 --> 00:14:38,230
should not happen by Honus nodes but it

00:14:36,670 --> 00:14:41,290
can happen because we're in Byzantine

00:14:38,230 --> 00:14:45,280
setting and so the definition of seeing

00:14:41,290 --> 00:14:47,710
changes in in this case just a little

00:14:45,280 --> 00:14:50,440
side note all the nodes are signed

00:14:47,710 --> 00:14:52,420
cryptographically by the authors so that

00:14:50,440 --> 00:14:55,030
you cannot pretend that someone else did

00:14:52,420 --> 00:14:57,100
a fork if you do a fork you are signing

00:14:55,030 --> 00:14:59,350
both sides of the fog so it can be

00:14:57,100 --> 00:15:01,740
proven that you're misbehaving so you'll

00:14:59,350 --> 00:15:06,250
be taken care of later but still the

00:15:01,740 --> 00:15:09,790
protocol must handle this so if we take

00:15:06,250 --> 00:15:13,839
the event d1 it sees the event c1 Prime

00:15:09,790 --> 00:15:15,490
in this fork because a way to see it is

00:15:13,839 --> 00:15:19,750
that D 1 cannot be aware of the other

00:15:15,490 --> 00:15:24,310
side of the fork so it's just the normal

00:15:19,750 --> 00:15:26,470
rules but if an event can let's say see

00:15:24,310 --> 00:15:28,810
both sides of a fork then

00:15:26,470 --> 00:15:31,600
it doesn't see any event created by the

00:15:28,810 --> 00:15:36,220
author of the fog so the event detail

00:15:31,600 --> 00:15:38,800
here doesn't see c1 or c1 prime or c2 or

00:15:36,220 --> 00:15:40,930
any event created by Carroll because

00:15:38,800 --> 00:15:44,080
it's kind of aware that there is a fog

00:15:40,930 --> 00:15:47,800
so the reason we define seeing like this

00:15:44,080 --> 00:15:50,200
is that it reduces the power of a

00:15:47,800 --> 00:15:52,510
malicious individual by forking now all

00:15:50,200 --> 00:15:56,020
they can do by forking is undo a bit of

00:15:52,510 --> 00:15:58,060
the past whereas if you don't have these

00:15:56,020 --> 00:15:59,380
kind of rules they can just pretend that

00:15:58,060 --> 00:16:02,470
all kinds of history happened and

00:15:59,380 --> 00:16:06,490
confuse everyone so this is better but

00:16:02,470 --> 00:16:09,670
it's still not great because like if you

00:16:06,490 --> 00:16:14,590
can undo what people see in the future

00:16:09,670 --> 00:16:16,600
how do you reach agreement so I'll take

00:16:14,590 --> 00:16:19,570
a little sidestep to define a

00:16:16,600 --> 00:16:22,180
supermajority it's just more than 2/3 of

00:16:19,570 --> 00:16:25,420
the nodes in the network I don't know if

00:16:22,180 --> 00:16:30,040
I've précised it but the fault tolerance

00:16:25,420 --> 00:16:31,960
of PASOK is 1/3 of the nodes or less

00:16:30,040 --> 00:16:34,900
than 1/3 of the nodes can be malicious

00:16:31,960 --> 00:16:38,110
at the same time in one network and

00:16:34,900 --> 00:16:41,610
that's actually proven it's been proven

00:16:38,110 --> 00:16:44,500
for decades to be the best theoretical

00:16:41,610 --> 00:16:48,520
Besant and resilience consensus protocol

00:16:44,500 --> 00:16:52,300
can have so the super majority being 2/3

00:16:48,520 --> 00:16:55,740
is related to this 1/3 but it's got two

00:16:52,300 --> 00:16:58,450
properties one is that super majority

00:16:55,740 --> 00:17:02,620
always contains a majority of harness

00:16:58,450 --> 00:17:05,860
nodes and two super majorities always

00:17:02,620 --> 00:17:09,130
have a whole nest node in common so this

00:17:05,860 --> 00:17:12,819
is going to be useful for the next

00:17:09,130 --> 00:17:14,890
concept which is strongly seeing so

00:17:12,819 --> 00:17:16,959
we've seen that scene allows malicious

00:17:14,890 --> 00:17:19,180
nodes to undo the history in the future

00:17:16,959 --> 00:17:24,490
strongly thing is a step towards

00:17:19,180 --> 00:17:26,140
removing this problem so the definition

00:17:24,490 --> 00:17:29,020
false from leasing battle for 18

00:17:26,140 --> 00:17:33,160
examples because it's easier is an event

00:17:29,020 --> 00:17:35,620
say X strongly sees an event Y if it can

00:17:33,160 --> 00:17:39,100
see events created by a super majority

00:17:35,620 --> 00:17:40,120
of nodes that can see about Y but let's

00:17:39,100 --> 00:17:44,500
look at an example

00:17:40,120 --> 00:17:47,470
so I claim that a1 strongly sees b0 and

00:17:44,500 --> 00:17:49,720
the reason is that a one sees for

00:17:47,470 --> 00:17:52,690
instance a zero that's created by Alice

00:17:49,720 --> 00:17:54,850
B zero that's created by Bob and C zero

00:17:52,690 --> 00:17:57,580
that's created by Karl and all of these

00:17:54,850 --> 00:17:59,680
see V zero and these are three out of

00:17:57,580 --> 00:18:03,720
four which is over two thirds so it's a

00:17:59,680 --> 00:18:07,020
supermajority so a1 strongly sees b0

00:18:03,720 --> 00:18:11,140
giving you one different example just to

00:18:07,020 --> 00:18:13,510
so say d1 strongly sees a zero and if

00:18:11,140 --> 00:18:15,130
you see in this case d1 can see events

00:18:13,510 --> 00:18:18,490
created by all of the nodes which is

00:18:15,130 --> 00:18:25,750
definitely more than 2/3 that CD 0 so a

00:18:18,490 --> 00:18:28,450
0 sorry so d1 strongly sees a 0 and just

00:18:25,750 --> 00:18:30,040
to really drive the point home an

00:18:28,450 --> 00:18:30,550
example where strong leasing does not

00:18:30,040 --> 00:18:34,030
happen

00:18:30,550 --> 00:18:36,250
a 2 does not strongly see a 0 and the

00:18:34,030 --> 00:18:38,860
reason is that a 2 only sees events

00:18:36,250 --> 00:18:44,100
created by Alice and Bob which is half

00:18:38,860 --> 00:18:47,680
the network which is less than 2/3 so

00:18:44,100 --> 00:18:50,350
the reason we bother them define this

00:18:47,680 --> 00:18:52,840
strongly saying is because if we get

00:18:50,350 --> 00:18:56,350
this nice property if an event X

00:18:52,840 --> 00:18:59,050
strongly sees an event y no other event

00:18:56,350 --> 00:19:01,750
can strongly see an event by wise

00:18:59,050 --> 00:19:04,060
creator that's on another branch of a

00:19:01,750 --> 00:19:06,790
fork so this kind of solves the problem

00:19:04,060 --> 00:19:09,550
with undoing history in the future and

00:19:06,790 --> 00:19:11,950
I've been promising to defend the

00:19:09,550 --> 00:19:16,270
concept of observers we're almost there

00:19:11,950 --> 00:19:17,980
but first interesting event so we want

00:19:16,270 --> 00:19:23,230
to reach consensus on something some

00:19:17,980 --> 00:19:27,220
data which were really and this data is

00:19:23,230 --> 00:19:28,990
going to be contained in the graph so

00:19:27,220 --> 00:19:31,150
for instance I told you at the beginning

00:19:28,990 --> 00:19:34,150
Bob recorded something he saw in the

00:19:31,150 --> 00:19:35,740
network in one gossip event but some

00:19:34,150 --> 00:19:39,220
gossip events will just record that

00:19:35,740 --> 00:19:41,530
communication happened so to kind of

00:19:39,220 --> 00:19:44,980
it's not even necessary to do it but we

00:19:41,530 --> 00:19:47,500
reduce the the gossip events we care

00:19:44,980 --> 00:19:49,420
about for the purpose of consensus to

00:19:47,500 --> 00:19:51,310
stuff that we call interesting events

00:19:49,420 --> 00:19:53,470
and for instance it could be gossip

00:19:51,310 --> 00:19:53,799
events that contain data or it could be

00:19:53,470 --> 00:19:56,129
more

00:19:53,799 --> 00:20:00,159
flex rules you can define it as you want

00:19:56,129 --> 00:20:03,190
but then reaching consensus based on

00:20:00,159 --> 00:20:06,549
looking at the gossip graph is going to

00:20:03,190 --> 00:20:09,279
be peeking one of the interesting events

00:20:06,549 --> 00:20:10,929
proposed for the next and say this is

00:20:09,279 --> 00:20:13,690
the next and when you do this you need

00:20:10,929 --> 00:20:16,330
to be sure that other knots do this - so

00:20:13,690 --> 00:20:19,899
I've been showing you this versa graph

00:20:16,330 --> 00:20:22,509
from God's eye but you need to realize

00:20:19,899 --> 00:20:24,249
that each node has their own version of

00:20:22,509 --> 00:20:26,440
the gossip graph that could be

00:20:24,249 --> 00:20:28,149
completely out of sync by I don't know

00:20:26,440 --> 00:20:31,779
generations and generations of gossip

00:20:28,149 --> 00:20:33,309
events and so yeah they don't have this

00:20:31,779 --> 00:20:35,559
good view they don't all have the same

00:20:33,309 --> 00:20:37,539
gossip graph oil consensus would already

00:20:35,559 --> 00:20:39,100
be solved so they have their version of

00:20:37,539 --> 00:20:41,109
the basic graph and they need to pick

00:20:39,100 --> 00:20:42,940
the next event so that any version of

00:20:41,109 --> 00:20:47,820
the gossip graph by other nodes will

00:20:42,940 --> 00:20:50,169
reach the same conclusion so now the

00:20:47,820 --> 00:20:55,739
concept of observers which have been

00:20:50,169 --> 00:20:58,889
touting so the technical definition is

00:20:55,739 --> 00:21:01,539
gossip event that strongly sees

00:20:58,889 --> 00:21:04,239
interesting gossip events proposed by

00:21:01,539 --> 00:21:07,059
your super majority of nodes and because

00:21:04,239 --> 00:21:09,940
it can be a bit abstract I'm gonna image

00:21:07,059 --> 00:21:12,460
again so you've already seen that a two

00:21:09,940 --> 00:21:15,039
does not strongly see a zero so in this

00:21:12,460 --> 00:21:17,379
example I'm saying that a 0 B 0 C 0 and

00:21:15,039 --> 00:21:21,629
D 0 are all interesting events and we're

00:21:17,379 --> 00:21:26,200
looking for is a to an observer or not

00:21:21,629 --> 00:21:29,230
okay so a to strongly sees B 0 you can

00:21:26,200 --> 00:21:33,100
just see that like the the blue path

00:21:29,230 --> 00:21:36,970
covers all the not be too strongly CC 0

00:21:33,100 --> 00:21:38,799
and B too strongly C's DS 0 so bit who

00:21:36,970 --> 00:21:42,190
strongly sees three of the four

00:21:38,799 --> 00:21:46,359
interesting events and that's the super

00:21:42,190 --> 00:21:53,350
majority so that makes the event a to an

00:21:46,359 --> 00:21:55,629
observer and know we are able to do

00:21:53,350 --> 00:22:00,909
something nice with this definition of

00:21:55,629 --> 00:22:02,769
observer you can see the fact that the

00:22:00,909 --> 00:22:05,710
observer strongly sees a specific

00:22:02,769 --> 00:22:07,030
interesting event as a vote of

00:22:05,710 --> 00:22:10,030
confidence

00:22:07,030 --> 00:22:13,990
this interesting event no interesting

00:22:10,030 --> 00:22:17,560
event on a fork of this one will be

00:22:13,990 --> 00:22:20,230
strongly seen by anyone so what this

00:22:17,560 --> 00:22:25,090
says is basically that at the time of

00:22:20,230 --> 00:22:27,310
event a to Alice knows that V 0 C 0 and

00:22:25,090 --> 00:22:29,550
G 0 will eventually be strongly seen by

00:22:27,310 --> 00:22:35,200
other nodes but it doesn't know for a 0

00:22:29,550 --> 00:22:41,110
and then you can use this as the input

00:22:35,200 --> 00:22:42,460
to Mehta election so the meta election

00:22:41,110 --> 00:22:44,800
it's going to be some kind of vote

00:22:42,460 --> 00:22:46,510
between the members of the section where

00:22:44,800 --> 00:22:49,510
each observer is going to answer the

00:22:46,510 --> 00:22:51,580
question do I strongly see this specific

00:22:49,510 --> 00:22:53,020
interesting event or rather do I

00:22:51,580 --> 00:22:55,420
strongly see an interesting event

00:22:53,020 --> 00:22:57,910
created by Alice and then there is

00:22:55,420 --> 00:22:59,800
another one that goes do I strongly see

00:22:57,910 --> 00:23:01,750
an interesting event created by Bob and

00:22:59,800 --> 00:23:04,770
it covers all the nodes so there are as

00:23:01,750 --> 00:23:08,320
many meta elections as there are nodes

00:23:04,770 --> 00:23:12,850
and so the answer to this question is a

00:23:08,320 --> 00:23:16,470
binary value is yes or no and it turns

00:23:12,850 --> 00:23:19,540
out the Green on the binary value is

00:23:16,470 --> 00:23:22,090
simpler than agreeing on arbitrary data

00:23:19,540 --> 00:23:24,040
on the order of a literary data and

00:23:22,090 --> 00:23:27,310
that's called a binary value consensus

00:23:24,040 --> 00:23:29,260
and in fact it's so much simpler that

00:23:27,310 --> 00:23:32,740
there is actually a pretty nice way to

00:23:29,260 --> 00:23:37,180
do it that was already in the literature

00:23:32,740 --> 00:23:39,430
for a few years and this way is it's

00:23:37,180 --> 00:23:41,800
this white paper signature free

00:23:39,430 --> 00:23:45,060
asynchronous Byzantine consensus with

00:23:41,800 --> 00:23:48,190
less than a third of 40 nodes and

00:23:45,060 --> 00:23:50,080
complexity N squared so now if you've

00:23:48,190 --> 00:23:53,670
been following the complexity N squared

00:23:50,080 --> 00:23:58,000
must make you a bit uncomfortable but

00:23:53,670 --> 00:24:01,450
the the describe the binary consensus

00:23:58,000 --> 00:24:03,660
protocol in a context of broadcast so

00:24:01,450 --> 00:24:05,650
what we did is simply take the same

00:24:03,660 --> 00:24:07,780
fundamentals and fold them to the

00:24:05,650 --> 00:24:11,140
context of gossip and so then you can

00:24:07,780 --> 00:24:13,150
get nodes to agree on which nodes should

00:24:11,140 --> 00:24:15,940
be considered for the next interesting

00:24:13,150 --> 00:24:18,760
event and then tiebreaking this is easy

00:24:15,940 --> 00:24:19,650
for instance if they have everyone says

00:24:18,760 --> 00:24:21,210
Bob Carol

00:24:19,650 --> 00:24:23,070
and they should suggest the next

00:24:21,210 --> 00:24:25,320
interesting event if everyone agrees on

00:24:23,070 --> 00:24:26,900
that then you can just pick the one with

00:24:25,320 --> 00:24:34,140
the biggest hash or some random

00:24:26,900 --> 00:24:36,900
tiebreaking rule so so we used this

00:24:34,140 --> 00:24:40,250
solution for binary agreement with an

00:24:36,900 --> 00:24:44,280
adaptation of moving it to gossip and

00:24:40,250 --> 00:24:48,210
another adaptation which is that this

00:24:44,280 --> 00:24:51,870
paper was not so simple because of one

00:24:48,210 --> 00:24:56,010
step called the common coin and the

00:24:51,870 --> 00:25:00,660
common coin is a primitive basically

00:24:56,010 --> 00:25:02,420
it's like all the nodes flip coin and

00:25:00,660 --> 00:25:05,550
the outcome is random and unpredictable

00:25:02,420 --> 00:25:08,460
but they all get the same one and turns

00:25:05,550 --> 00:25:10,350
out that's not an easy construct to make

00:25:08,460 --> 00:25:12,240
you need something like distributed key

00:25:10,350 --> 00:25:13,890
generations and then it becomes

00:25:12,240 --> 00:25:16,830
expensive to add nodes to the network so

00:25:13,890 --> 00:25:20,190
anyway it's just not that simple so we

00:25:16,830 --> 00:25:21,960
used an idea from a paper from Silvio

00:25:20,190 --> 00:25:24,390
McCauley from Al Gore and called

00:25:21,960 --> 00:25:27,990
Byzantine agreement material which was

00:25:24,390 --> 00:25:30,240
released actually just before palace act

00:25:27,990 --> 00:25:32,460
like we saw this and we were looking at

00:25:30,240 --> 00:25:35,220
how do we do a good common coin and we

00:25:32,460 --> 00:25:37,170
were like okay this is better so we

00:25:35,220 --> 00:25:40,140
we've got a concrete cone instead of the

00:25:37,170 --> 00:25:42,960
common coin and with these components

00:25:40,140 --> 00:25:47,070
the problem of consensus protocol is

00:25:42,960 --> 00:25:52,679
solved for us and the properties we get

00:25:47,070 --> 00:25:55,440
is asynchronous ish so the real

00:25:52,679 --> 00:25:57,240
definition of a synchronous is that the

00:25:55,440 --> 00:25:59,130
adversary can convert the order of

00:25:57,240 --> 00:26:02,640
delivery of any message in the network

00:25:59,130 --> 00:26:05,550
and that's so strong and so that

00:26:02,640 --> 00:26:08,040
shouldn't affect liveness so it means

00:26:05,550 --> 00:26:11,090
the protocol should still always give a

00:26:08,040 --> 00:26:13,860
result and there is one step in our

00:26:11,090 --> 00:26:15,750
protocol that is not theoretically

00:26:13,860 --> 00:26:19,440
asynchronous and that's the way we

00:26:15,750 --> 00:26:21,720
defined a concrete coin although caveat

00:26:19,440 --> 00:26:23,250
we think we can fix that we are just

00:26:21,720 --> 00:26:25,260
currently focused on implementing the

00:26:23,250 --> 00:26:27,300
white paper we've written and then we'll

00:26:25,260 --> 00:26:30,150
go back into it and try to fix it and

00:26:27,300 --> 00:26:31,429
other caveat we think that the way we

00:26:30,150 --> 00:26:33,299
defined our concrete coin is

00:26:31,429 --> 00:26:37,169
sufficiently asynchronous

00:26:33,299 --> 00:26:38,369
in practice for the four purposes but of

00:26:37,169 --> 00:26:41,539
course we are going to have to test that

00:26:38,369 --> 00:26:45,600
if we don't find a truly asynchronous

00:26:41,539 --> 00:26:47,970
academically solution okay we get

00:26:45,600 --> 00:26:50,519
scalability because complexity is n log

00:26:47,970 --> 00:26:53,279
n which is so n log n to reach a

00:26:50,519 --> 00:26:57,629
decision which is the same as kind of an

00:26:53,279 --> 00:27:02,039
optimal complexity for communicating in

00:26:57,629 --> 00:27:03,989
a resilient manner it works in a

00:27:02,039 --> 00:27:07,320
permissionless setting so it's resilient

00:27:03,989 --> 00:27:10,470
to a third - one of malicious nodes and

00:27:07,320 --> 00:27:12,570
nodes can be added and removed from the

00:27:10,470 --> 00:27:14,909
network the way this is done is

00:27:12,570 --> 00:27:16,649
basically by reaching consensus on who

00:27:14,909 --> 00:27:18,210
gets added and who gets removed so you

00:27:16,649 --> 00:27:21,809
know everyone is added and removed in

00:27:18,210 --> 00:27:24,960
the same order it's open source

00:27:21,809 --> 00:27:27,840
the code is gplv3 with linking exception

00:27:24,960 --> 00:27:31,200
and then all the interface layer of our

00:27:27,840 --> 00:27:33,480
libraries in the safe network is MIT so

00:27:31,200 --> 00:27:37,320
the low-level stuff is gplv3 with

00:27:33,480 --> 00:27:40,049
linking exception and it's simple

00:27:37,320 --> 00:27:41,340
because we could remove the stuff like

00:27:40,049 --> 00:27:43,230
distributed key generation and

00:27:41,340 --> 00:27:45,109
everything so the primitives behind this

00:27:43,230 --> 00:27:47,759
is like house cryptographic signatures

00:27:45,109 --> 00:27:50,519
and then a directed acyclic graph and

00:27:47,759 --> 00:27:52,830
follow some protocol so for consensus

00:27:50,519 --> 00:27:57,059
protocol it's about as simple as

00:27:52,830 --> 00:28:01,320
anything I've seen at least and no to

00:27:57,059 --> 00:28:03,539
the next bit of my talk which is the one

00:28:01,320 --> 00:28:06,269
that may interest you a bit more with

00:28:03,539 --> 00:28:07,850
rust so why do we use rusts what do we

00:28:06,269 --> 00:28:11,759
like in rust

00:28:07,850 --> 00:28:15,559
well first made safe switched to rust in

00:28:11,759 --> 00:28:19,769
2015 when it became stable so we used to

00:28:15,559 --> 00:28:24,749
have stuff in C++ but really we want

00:28:19,769 --> 00:28:26,669
speed and security and in C++ you can

00:28:24,749 --> 00:28:28,259
get speed it's not too hard but to get

00:28:26,669 --> 00:28:32,730
security you need to work really really

00:28:28,259 --> 00:28:35,159
hard so with rust we just got the try

00:28:32,730 --> 00:28:37,109
factor that's advertised speed security

00:28:35,159 --> 00:28:39,929
concurrency and so that's the same

00:28:37,109 --> 00:28:42,809
reason most projects piecrust

00:28:39,929 --> 00:28:47,210
but what I want to go into a bit more

00:28:42,809 --> 00:28:50,820
depth is well by using rust for fear

00:28:47,210 --> 00:28:52,680
what we the little things that we

00:28:50,820 --> 00:28:56,310
noticed that are really nice and that

00:28:52,680 --> 00:28:59,700
built the entire rust ecosystem and it

00:28:56,310 --> 00:29:01,530
starts with an ozone community that that

00:28:59,700 --> 00:29:05,000
meets in this kind of meetups and that's

00:29:01,530 --> 00:29:07,200
great and that paused the language that

00:29:05,000 --> 00:29:09,530
distributes religious tons of cool

00:29:07,200 --> 00:29:13,500
libraries for all kinds of things that

00:29:09,530 --> 00:29:15,840
does amazing tools and in fact we're

00:29:13,500 --> 00:29:17,490
such fans of the way the Ross community

00:29:15,840 --> 00:29:19,890
works at made safe that we've even

00:29:17,490 --> 00:29:22,350
adapted the request for comments process

00:29:19,890 --> 00:29:24,270
from worst to the same network so that

00:29:22,350 --> 00:29:31,230
all community can help us design or

00:29:24,270 --> 00:29:33,390
network in the same way and with one of

00:29:31,230 --> 00:29:35,580
the reasons the community in rust is so

00:29:33,390 --> 00:29:38,340
welcoming is that it's an active effort

00:29:35,580 --> 00:29:41,370
if you check the code of conduct the

00:29:38,340 --> 00:29:42,870
very first bullet point in their face we

00:29:41,370 --> 00:29:45,120
are committed to providing a friendly

00:29:42,870 --> 00:29:47,400
safe and welcoming environment for all

00:29:45,120 --> 00:29:51,540
regardless of level of experience and

00:29:47,400 --> 00:29:53,790
other characteristics and that's exactly

00:29:51,540 --> 00:29:55,920
how we feel at made safe in fact with

00:29:53,790 --> 00:29:59,040
the safe network which is secured access

00:29:55,920 --> 00:30:02,490
for everyone we want to provide security

00:29:59,040 --> 00:30:05,850
for everyone and that means not only

00:30:02,490 --> 00:30:08,460
people who are able to do encryption and

00:30:05,850 --> 00:30:10,380
be smart with how they use the internet

00:30:08,460 --> 00:30:12,420
the idea is to give security and privacy

00:30:10,380 --> 00:30:17,250
to your grandmother to someone who is

00:30:12,420 --> 00:30:20,760
not tech savvy at all so this awesome

00:30:17,250 --> 00:30:22,680
community builds awesome tools and it's

00:30:20,760 --> 00:30:25,290
really nice that I'm doing this talk now

00:30:22,680 --> 00:30:27,570
after the 6th of December because you

00:30:25,290 --> 00:30:30,000
can just rest up component add key

00:30:27,570 --> 00:30:32,040
Pyrrhus format and RLS without preview

00:30:30,000 --> 00:30:36,120
without using somewhere nightly like we

00:30:32,040 --> 00:30:36,420
used to have to and basically in a few

00:30:36,120 --> 00:30:40,050
words

00:30:36,420 --> 00:30:42,090
Clippy gives you like the community

00:30:40,050 --> 00:30:45,270
reviewing your code live while you're

00:30:42,090 --> 00:30:48,150
writing it Russ format means that when

00:30:45,270 --> 00:30:50,220
you check any code in any crate you can

00:30:48,150 --> 00:30:51,990
not be ticked by the weather in turn

00:30:50,220 --> 00:30:54,240
dark road because you're just used to

00:30:51,990 --> 00:30:56,040
this format style and the rest language

00:30:54,240 --> 00:30:58,540
server means that the VM versus Emacs

00:30:56,040 --> 00:31:00,760
war is over because

00:30:58,540 --> 00:31:03,570
everyone won everyone can have the nice

00:31:00,760 --> 00:31:07,330
tools whatever your text editor is so

00:31:03,570 --> 00:31:09,760
love 2018 if you're not using Clippy and

00:31:07,330 --> 00:31:15,070
res format to fail your CI do it it's

00:31:09,760 --> 00:31:19,750
really nice it just removes worries so

00:31:15,070 --> 00:31:22,540
now to finish this talk I'm gonna so a

00:31:19,750 --> 00:31:25,960
few ways that the rest echo system helps

00:31:22,540 --> 00:31:28,780
us achieve security security and then

00:31:25,960 --> 00:31:30,480
performance so in terms of security of

00:31:28,780 --> 00:31:34,270
course it starts at the board checker

00:31:30,480 --> 00:31:38,440
unlike in C++ you cannot easily shoot

00:31:34,270 --> 00:31:42,250
yourself in the foot with memory so the

00:31:38,440 --> 00:31:45,340
just that makes it leagues a way of for

00:31:42,250 --> 00:31:47,170
instance C++ but once you've got that

00:31:45,340 --> 00:31:51,850
and once for instance

00:31:47,170 --> 00:31:56,170
Clippy has got your non idiomatic letter

00:31:51,850 --> 00:31:59,140
logical mistakes you need to do testing

00:31:56,170 --> 00:32:02,290
and so I will show you three ways we do

00:31:59,140 --> 00:32:04,540
testing for parsec which I think are

00:32:02,290 --> 00:32:06,330
pretty cool and so if you if you want to

00:32:04,540 --> 00:32:11,440
look into the ways it's pretty nice so

00:32:06,330 --> 00:32:13,090
as I've just kind of described parsec

00:32:11,440 --> 00:32:15,940
you may have seen that we like to think

00:32:13,090 --> 00:32:19,240
of things in terms of graphs and a good

00:32:15,940 --> 00:32:21,850
way to visualize graph graphs is in the

00:32:19,240 --> 00:32:25,960
dot format so that you can generate

00:32:21,850 --> 00:32:27,910
images like this from it so with the dot

00:32:25,960 --> 00:32:30,190
format you can express relationship for

00:32:27,910 --> 00:32:32,500
instance here you say there is a

00:32:30,190 --> 00:32:35,530
relationship between a 0 and a 1 which

00:32:32,500 --> 00:32:37,840
is like a 0 is a self front of a 1 and

00:32:35,530 --> 00:32:39,310
you can then generate this image that

00:32:37,840 --> 00:32:46,120
just gives you the graph of what

00:32:39,310 --> 00:32:49,660
happened in the network so we have our

00:32:46,120 --> 00:32:51,610
code output this graph where in some

00:32:49,660 --> 00:32:55,720
cases for instance when running tests or

00:32:51,610 --> 00:32:58,420
when running the example and we can then

00:32:55,720 --> 00:33:00,280
pass these graphs from dot format back

00:32:58,420 --> 00:33:03,250
into the data structures were used to

00:33:00,280 --> 00:33:05,590
and for that we use pong it's not the

00:33:03,250 --> 00:33:09,070
only one but it's a parser framework

00:33:05,590 --> 00:33:11,410
which makes you able to pass this kind

00:33:09,070 --> 00:33:12,429
of non quite standard thing it's not

00:33:11,410 --> 00:33:17,860
JSON is it

00:33:12,429 --> 00:33:19,869
dot graph in a pretty concise way and so

00:33:17,860 --> 00:33:22,990
that allows us to write tests like this

00:33:19,869 --> 00:33:26,499
functional test where we can say pass

00:33:22,990 --> 00:33:29,369
this dot file that I may have generated

00:33:26,499 --> 00:33:32,769
and then tweaked a few things then

00:33:29,369 --> 00:33:36,190
construct a parsec which is all main

00:33:32,769 --> 00:33:38,860
data structure and check that some

00:33:36,190 --> 00:33:40,779
invariants on this parsec hold and you

00:33:38,860 --> 00:33:42,220
can also do password dot graph and then

00:33:40,779 --> 00:33:44,590
have that's going to be my starting

00:33:42,220 --> 00:33:46,059
point have some nodes communicate check

00:33:44,590 --> 00:33:47,409
that the invariants hold have some

00:33:46,059 --> 00:33:50,080
models communicate check that the

00:33:47,409 --> 00:33:52,240
invariants hold etc so that's a great

00:33:50,080 --> 00:33:56,129
way if you have one scenario that you

00:33:52,240 --> 00:33:58,539
think might break your code you just

00:33:56,129 --> 00:34:02,350
basically it's easy to sketch it in dot

00:33:58,539 --> 00:34:06,190
graph and write a test this way but we

00:34:02,350 --> 00:34:09,359
can go one level more powerful by being

00:34:06,190 --> 00:34:13,329
more generic and adding some random so

00:34:09,359 --> 00:34:16,710
we have integration tests that function

00:34:13,329 --> 00:34:21,849
on the circuit testing basis where we

00:34:16,710 --> 00:34:26,919
described ourselves a way to represent a

00:34:21,849 --> 00:34:29,919
path back graph so for instance you

00:34:26,919 --> 00:34:32,829
don't have to say a 0 then a 1 then a 2

00:34:29,919 --> 00:34:36,609
and a specific order of events you can

00:34:32,829 --> 00:34:38,440
just say I want to start with two nodes

00:34:36,609 --> 00:34:39,460
so in this case I'm constructing

00:34:38,440 --> 00:34:42,819
schedule options

00:34:39,460 --> 00:34:44,230
janessa size two and place to add 8 so

00:34:42,819 --> 00:34:46,780
that's like I'm starting with two nodes

00:34:44,230 --> 00:34:50,859
and I want to add add 8 nodes to this

00:34:46,780 --> 00:34:52,240
network and these can be generated in

00:34:50,859 --> 00:34:54,040
many ways there are many ways to go see

00:34:52,240 --> 00:34:55,419
if it's random so it can show there are

00:34:54,040 --> 00:34:58,990
many ways to go see if that will do this

00:34:55,419 --> 00:35:01,869
and when we run this test with this

00:34:58,990 --> 00:35:05,230
executive catcher it will just generate

00:35:01,869 --> 00:35:07,210
one of these ways randomly and run it

00:35:05,230 --> 00:35:09,520
and that means we can run it thousands

00:35:07,210 --> 00:35:11,680
and thousands of times and of course in

00:35:09,520 --> 00:35:14,079
this execute schedules we can test many

00:35:11,680 --> 00:35:16,329
many invariants and a nice thing with

00:35:14,079 --> 00:35:18,250
this is as well that if we realize that

00:35:16,329 --> 00:35:20,230
we have one more environment we want to

00:35:18,250 --> 00:35:23,349
enforce we can add it in one place and

00:35:20,230 --> 00:35:25,660
all our integration tests get to check

00:35:23,349 --> 00:35:27,700
that invariant whether the add node

00:35:25,660 --> 00:35:31,000
move notes do both or do all kinds of

00:35:27,700 --> 00:35:33,369
things like this and so going from

00:35:31,000 --> 00:35:35,440
functional testing to integration

00:35:33,369 --> 00:35:39,760
testing we catch the bugs we don't

00:35:35,440 --> 00:35:43,059
expect but there is one more layer of

00:35:39,760 --> 00:35:46,510
Awesomeness which is using proc tests

00:35:43,059 --> 00:35:48,339
for property testing and it kind of uses

00:35:46,510 --> 00:35:51,579
some of the same concepts as the sock

00:35:48,339 --> 00:35:54,640
testing except instead of describing a

00:35:51,579 --> 00:35:57,130
scenario as in I start with two nodes

00:35:54,640 --> 00:35:59,589
and add add eight I just say you could

00:35:57,130 --> 00:36:01,390
start with any number of nodes between I

00:35:59,589 --> 00:36:04,270
don't know four in ten whatever you

00:36:01,390 --> 00:36:07,750
could add any number of nodes and the

00:36:04,270 --> 00:36:12,099
property testing framework will try to

00:36:07,750 --> 00:36:14,380
generate for you the the problem that's

00:36:12,099 --> 00:36:16,119
the most likely to find a bug in your

00:36:14,380 --> 00:36:18,390
code so it's going to try to run the

00:36:16,119 --> 00:36:22,089
most complex problem it can think of and

00:36:18,390 --> 00:36:25,420
if that breaks it will then dial back

00:36:22,089 --> 00:36:28,390
all the ways it has and try to find the

00:36:25,420 --> 00:36:30,849
smallest way to break your test based on

00:36:28,390 --> 00:36:34,029
this so that's something actually learnt

00:36:30,849 --> 00:36:35,680
about at the Russ fest in Paris and we

00:36:34,029 --> 00:36:37,839
were like ok we want this it's really

00:36:35,680 --> 00:36:39,640
really cool it's not that hard to do you

00:36:37,839 --> 00:36:41,529
just need to have this kind of

00:36:39,640 --> 00:36:44,349
declarative way of specifying your

00:36:41,529 --> 00:36:46,319
problems and then it's a bit of

00:36:44,349 --> 00:36:49,359
boilerplate but it's not too bad

00:36:46,319 --> 00:36:51,700
and turns out this first doesn't catch

00:36:49,359 --> 00:36:53,829
many bugs because most of the bugs are

00:36:51,700 --> 00:36:55,180
caught before at the sub testing level

00:36:53,829 --> 00:36:58,210
if they haven't been caught at the

00:36:55,180 --> 00:37:00,520
functional testing but since we created

00:36:58,210 --> 00:37:03,160
this a few months ago it got two bugs

00:37:00,520 --> 00:37:05,349
and these bugs had made it through

00:37:03,160 --> 00:37:07,690
thousands of iterations of sock testing

00:37:05,349 --> 00:37:10,299
and so for these two bugs it's

00:37:07,690 --> 00:37:13,390
definitely worth the Ricoh - it took us

00:37:10,299 --> 00:37:16,420
to set it up because these are the bugs

00:37:13,390 --> 00:37:18,960
that you never catch and end up in

00:37:16,420 --> 00:37:21,160
production so I would strongly recommend

00:37:18,960 --> 00:37:25,270
playing with protests if you're so

00:37:21,160 --> 00:37:28,390
inclined so these so basically with

00:37:25,270 --> 00:37:30,549
these between like the compiler Clippy

00:37:28,390 --> 00:37:33,069
and the different ways you can test with

00:37:30,549 --> 00:37:35,890
rust you can have even more security

00:37:33,069 --> 00:37:38,859
than what you get by default with just

00:37:35,890 --> 00:37:41,060
the compiler and another aspect of

00:37:38,859 --> 00:37:44,609
course

00:37:41,060 --> 00:37:46,380
rust school stuff is performance and how

00:37:44,609 --> 00:37:48,270
do you get performance you don't just

00:37:46,380 --> 00:37:50,490
write good and it's fast you need to

00:37:48,270 --> 00:37:56,430
measure see where the bottlenecks and

00:37:50,490 --> 00:37:58,500
fix them and the it's cool that inversed

00:37:56,430 --> 00:38:00,540
like in other languages you can do flame

00:37:58,500 --> 00:38:02,480
graphs you can generate flame graphs so

00:38:00,540 --> 00:38:04,650
that's a very easy way to spot

00:38:02,480 --> 00:38:06,030
bottlenecks in your code for instance I

00:38:04,650 --> 00:38:12,600
can tell you right now looking at this

00:38:06,030 --> 00:38:16,710
graph that this is a bottleneck so you

00:38:12,600 --> 00:38:19,020
can like it's nice that in 2018 in worst

00:38:16,710 --> 00:38:22,230
you've got the tooling like one of the

00:38:19,020 --> 00:38:24,869
things that held rows back when it was

00:38:22,230 --> 00:38:27,300
very young was tooling was hard but now

00:38:24,869 --> 00:38:30,359
you get the tools so you can profile

00:38:27,300 --> 00:38:31,680
your code properly and once you fix the

00:38:30,359 --> 00:38:35,520
regression you don't want it to come

00:38:31,680 --> 00:38:39,150
back so you do benchmarking and for that

00:38:35,520 --> 00:38:41,460
we use the criterion crate which is

00:38:39,150 --> 00:38:43,770
pretty nice you basically just run

00:38:41,460 --> 00:38:46,619
carbon bench and it generates these

00:38:43,770 --> 00:38:49,650
little statistical things for you for

00:38:46,619 --> 00:38:51,150
instance this particular fix made of 40

00:38:49,650 --> 00:38:53,010
percent improvement on that particular

00:38:51,150 --> 00:38:54,840
benchmark and that's something that was

00:38:53,010 --> 00:38:57,060
actually pushed to PASOK last week I

00:38:54,840 --> 00:39:00,210
just got the latest instance of that

00:38:57,060 --> 00:39:05,100
because currently we are deep s amazing

00:39:00,210 --> 00:39:07,190
awkward so that's it for me thanks very

00:39:05,100 --> 00:39:07,190
much

00:39:08,050 --> 00:39:25,770
[Applause]

00:39:11,450 --> 00:39:28,440
any questions go for it somewhere in the

00:39:25,770 --> 00:39:32,490
middle you said that you distinguish

00:39:28,440 --> 00:39:36,510
between a strong and non strong scene

00:39:32,490 --> 00:39:39,930
relation but based on what size of

00:39:36,510 --> 00:39:42,750
amount of nodes I mean if you if you

00:39:39,930 --> 00:39:45,330
start it like with 10 nodes and you lose

00:39:42,750 --> 00:39:47,640
connection to like seven of them and you

00:39:45,330 --> 00:39:50,580
decided that like super majority is

00:39:47,640 --> 00:39:52,740
based on size of three so so how you

00:39:50,580 --> 00:39:54,930
define the size so you asking me about

00:39:52,740 --> 00:39:58,050
basically how we do dynamic membership I

00:39:54,930 --> 00:40:01,800
just get a graphic example the set of

00:39:58,050 --> 00:40:04,349
valid voters between quotes is known at

00:40:01,800 --> 00:40:05,910
every time during the process okay so

00:40:04,349 --> 00:40:08,520
let's start at the stage where we know

00:40:05,910 --> 00:40:11,720
the set of valid voters and then say or

00:40:08,520 --> 00:40:14,250
not wants to join the network they will

00:40:11,720 --> 00:40:16,320
nug everyone in the network saying hey

00:40:14,250 --> 00:40:18,240
can I join how can I join and everyone

00:40:16,320 --> 00:40:20,970
will create an interesting event that

00:40:18,240 --> 00:40:24,180
says okay this mod want to join so at

00:40:20,970 --> 00:40:26,040
the end like at the time each of them it

00:40:24,180 --> 00:40:29,070
could be a different time but at the

00:40:26,040 --> 00:40:31,349
time say Alice realizes that Eric wants

00:40:29,070 --> 00:40:33,420
to join the network then from her point

00:40:31,349 --> 00:40:38,250
of view eric is a valid voter from that

00:40:33,420 --> 00:40:40,680
point forward and same for not living so

00:40:38,250 --> 00:40:42,359
you maintain the invariant of everyone

00:40:40,680 --> 00:40:44,760
knows who's a valued member of the

00:40:42,359 --> 00:40:48,089
network at the time even though it's not

00:40:44,760 --> 00:40:55,080
time it's just in the asynchronous way

00:40:48,089 --> 00:40:58,410
it works okay yes thank you thank you

00:40:55,080 --> 00:41:01,470
for your talk I'd like to ask about the

00:40:58,410 --> 00:41:04,260
nature of the technology that is pretty

00:41:01,470 --> 00:41:08,369
similar to yours so may you summarize

00:41:04,260 --> 00:41:09,540
the differences if any to the hash graph

00:41:08,369 --> 00:41:13,230
you know it right

00:41:09,540 --> 00:41:15,150
yeah well okay so the part about seeing

00:41:13,230 --> 00:41:17,640
and strongly seeing is similar with hash

00:41:15,150 --> 00:41:19,890
graph and the idea of being wedged on a

00:41:17,640 --> 00:41:21,800
gossip graph let's say of a graph of a

00:41:19,890 --> 00:41:24,080
directed acyclic graph of cosecant

00:41:21,800 --> 00:41:26,300
occations but after that it's different

00:41:24,080 --> 00:41:27,620
everything is different so I don't

00:41:26,300 --> 00:41:30,700
remember exactly how they do it but they

00:41:27,620 --> 00:41:34,010
have witnesses and famous witnesses and

00:41:30,700 --> 00:41:36,230
the entire thing about this is is

00:41:34,010 --> 00:41:39,970
different well so what we do is

00:41:36,230 --> 00:41:41,630
basically reduce the problem to binary

00:41:39,970 --> 00:41:42,920
agreement

00:41:41,630 --> 00:41:45,580
they don't do that they have a

00:41:42,920 --> 00:41:49,460
completely different way of doing it and

00:41:45,580 --> 00:41:53,480
one thing where we are ahead of hosh

00:41:49,460 --> 00:41:59,270
graph in terms of our features is that

00:41:53,480 --> 00:42:00,860
they actually say well okay I don't but

00:41:59,270 --> 00:42:03,440
basically there is a part in the white

00:42:00,860 --> 00:42:05,180
paper where they say all and if you and

00:42:03,440 --> 00:42:07,480
this is not theoretically asynchronous

00:42:05,180 --> 00:42:11,030
but you can just use a common coin and

00:42:07,480 --> 00:42:13,970
that kind of shady because just use a

00:42:11,030 --> 00:42:15,350
common coin is actually not easy and if

00:42:13,970 --> 00:42:17,570
you don't do that you are not quite a

00:42:15,350 --> 00:42:19,100
synchronous so with our concrete coin we

00:42:17,570 --> 00:42:20,900
will step closer to being fully

00:42:19,100 --> 00:42:22,930
asynchronous or they are not fully there

00:42:20,900 --> 00:42:22,930

YouTube URL: https://www.youtube.com/watch?v=J38JcMJvYto


