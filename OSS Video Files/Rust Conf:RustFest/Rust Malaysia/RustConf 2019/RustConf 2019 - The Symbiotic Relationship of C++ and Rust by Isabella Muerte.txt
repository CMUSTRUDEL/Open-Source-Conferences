Title: RustConf 2019 - The Symbiotic Relationship of C++ and Rust by Isabella Muerte
Publication date: 2019-09-19
Playlist: RustConf 2019
Description: 
	RustConf 2019 - The Symbiotic Relationship of C++ and Rust by Isabella Muerte

For better or worse, Rust and C++ have a shared future ahead of them. C++ will affect the design of Rust, and so too will Rust affect the design of C++. Rust's future is most likely the same path as C++, but what does that mean exactly? In this talk, we'll learn about the evolution of these languages, how much they have in common, the power their respective communities have to shape them, and the responsibility these communities have to each other.
Captions: 
	                              [Music]                               all right cool so as was briefly                               mentioned we're gonna talk about C++ and                               rest today so just so you all know who I                               am I missing Marte and I'm a C++ bruja I                               do a lot of dark magic stuff with C++ if                               you know me personally than you know                               that I do some really cursed things I'm                               an aspirant row station so I do do a bit                                of rust on the side not my day job also                                don't really contribute to a lot of                                projects that's because I'm busy because                                as of lately I've become a bit of a sea                                make war criminal so um I do some really                                disgusting things in seeming as of late                                you could also make the argument that                                I'm not a C++ programmer anymore                                I was seeming program that just happens                                to those people see what's plus I                                promise not to talk about C make today I                                did that at the roscoff last year and at                                one point someone just kind of walked                                away a little little like depersonalized                                disassociating like I just wish I didn't                                know any of what you just told me and                                then Michael made this tweet the other                                day it's been zero days since I had a                                truly cursed idea and that's pretty                                accurate representation I care a lot                                about developer workflows build tools                                making it's that you have to type lessee                                or computer cuz the more we type the                                heart higher a chance of having                                arthritis as we get older increases                                I also currently hold the record for                                most papers submitted to a single C++                                sustainers meeting um that was                                completely by accident my name was on                                   papers I don't think anyone's gonna                                break that anytime soon                                so just just to give you an idea that I                                do care abouts people suppose a little                                bit I started teach myself see what                                suppose about                                                        the build system don't learn how to                                program by writing in the build system                                if you have a friend that is like I'm                                thinking of writing a build system tell                                them not to care about your friends and                                the people around you                                I've been pay attention to rest for a                                while as Steve kind of made made mention                                of                                                                      know the the old tilde T back when tilde                                T and at T were still a thing this was                                before the borrowed checker and when I                                think everything was still either like                                equivalent to a unique pointer or a                                shared pointer in this equals plus side                                and iterators were still more Ruby like                                so the the current stream iterator                                implementation that has been used since                                you know forever                                wasn't really a thing so that's my                                Twitter that's my github yes it is                                slurps mad rips I can go into the story                                of why I chose that username in                                         let's not right now and I also just want                                to set up some some boundaries real                                quick so you know any questions                                let's look until after the talk if we                                don't have time for questions you can                                speak to me in person outside I won't                                actually sit off to the side here I'll                                actually physically walk out just so                                that we can give more people space up                                here for the next talk and lastly you                                can always tweet a question to me with                                that hashtag                                                            actually checked this hashtag every                                couple of every couple of weeks because                                you know maybe you're watching this at                                home maybe you had a question that you                                wanted to ask me forgot about it then                                remembered it on the way home after the                                conference this allows you to ask that                                question I will respond to it                                you can also at me but by using this                                hashtag other people can also see what                                questions you yourselves have asked so a                                couple extra talks that I suggest all of                                you go and watch at some point after                                this conference and after this talks to                                you can kind of get a better idea we                                only have                                                             the elsewhere memory talk by Neil                                Douglas I'm from ACC u                                                 talk on JavaScript considered useful and                                then the tragedy of systemd by Ben o                                 rice I'm pretty sure I just murdered his                                 first name there but these these three                                 talks I've been watching pretty pretty                                 regularly because they they cover a wide                                 variety of different things from the                                 super suppose abstract machine to                                 community related things as well as even                                 standardization in the case of Jen's                                 talk and we're going to talk a little                                 bit about each of the things that is                                 that are in these talks but in reference                                 to super supposin dress today so as I                                 said you know why are we here so I think                                 they're gonna be super so much gonna be                                 living side by side for quite a long                                 time if only because contracts with you                                 know various industries exist there are                                 people that are still running seek                                 until                                                                 she's gonna live that long C++ will                                 definitely live as long because                                 currently the C Standards Committee                                 Charter says that they are to keep                                 basically in lockstep with C++ and to                                 make sure that C stays compatible in C++                                 rather than what used to be the other                                 way around                                 Russ also is not going anywhere I think                                 it has too much momentum at this point                                 it is technically a                                                      so you know it's it's old enough to                                 curse at me and tell me I'm bad at                                 counter-strike online C++ is kind of                                 like the                                                               that used to play quake in                                         whatever so you know neither of us are                                 going anywhere anytime soon and we might                                 as well work together to learn from each                                 other's mistakes there's a lot of stuff                                 involved with tooling with optimizations                                 that we can learn from and you know                                 while be honest used to creative C++                                 might say other languages are copying                                 C++ there are people on the Standards                                 Committee it for super suppose that are                                 looking at what Russ does for                                 optimizations for language futures and                                 we are borrowing from them I've                                 submitted quite a few papers in                                 regarding that so just to give you an                                 idea of like how similar with languages                                 are we've got a you know a lot of stuff                                 that is similar but our terminology is                                 starting to drift kind of like you know                                 how you know the Romance language is                                 drifted and if you speak Spanish you can                                 kind of understand Italian and if you                                 speak a tell you can kind of understand                                 Spanish you know there's a lot of                                 similarities there and we're both kind                                 of trapped trying to express high-level                                 concepts for machine code and rust                                 doesn't have an abstract machine C++                                 does and our abstract machine is                                 basically the pdp-                                   and if something can't meet that then                                 it's not really an abstract machine it's                                 kind of a shame but rust does have to                                 meet a lot of the stuff that C++ does                                 because by using LLVM you're stuck with                                 our memory model and if in the future                                 and Vidya says we'll adopt the rust                                 memory model over C++ then we'll have to                                 follow you know your direction of things                                 but I don't think that's gonna be                                 happening time soon unfortunately or                                 fortunately so here's some code                                 differences here so you know Russ has                                 let we have auto I didn't put Auto Const                                 because you don't want an auto Const                                 our value reference and that's what's                                 not you know what let's just not get                                 into that part of the language it's kind                                 of a landmine rust has the turbo fish we                                 have both the apologize I used Furyk                                 hoes that's why it looks like in diamond                                 there as well as the scope template                                 syntax the the form of that we used less                                 nowadays we're relaxing type name and so                                 usage and sneaking right in generic code                                 easier to also means that this kind of                                 you know cool scope template thing is                                 disappearing the if let's some or if let                                 you know some value expression is kind                                 of equivalent if Auto x equals some                                 boolean expression and moving into more                                 literals in C++ twenty we still have to                                 write using this stupid macro from C's C                                 stood int in                                                           actual in                                                           paper I'm writing we can we will                                 actually able to write the same thing                                 that rust has and that is actually a                                 library feature a language feature                                 because we're so cursed we said hey what                                 if anyone could just write whatever                                 suffix literal they wanted for a given                                 built in tight and someone said yeah                                 that sounds cool our integer separators                                 are a bit different                                 rust has borrowed from a variety of the                                 languages Python Ruby I think pearl may                                 be but a lot of people are moving in                                 this direction of you know that using                                 the underscores as a digit separator we                                 chose the single quote in C++ because it                                 kind of mimics this the choice of a                                 period or comma without us having to get                                 into localization issues I personally                                 believe that the C++ one is a little                                 better and I've also seen people writing                                 integers out in actual like papers using                                 the C++ syntax instead of the                                 underscored version I think in academic                                 papers you'll see that C++ form more                                 even if the paper has nothing to do with                                 C++ both people some Russ can overload                                 some operators I found out last night                                 that you can over                                 overload the not operator in rust and we                                 can also do that in C++ so hey we both                                 have a really bad decision that's great                                 rust moves are equivalent to a new                                 concept that we're trying to try out in                                 C++ which is called relocation our moves                                 are kind of just a tag on the type                                 system so when you have an R value                                 reference and you've moved something                                 into a function that does not mean that                                 the data has been moved from where as in                                 rust moving from something implies                                 destruction relocation might be an                                 optimization that comes in the future                                 we're still trying to even figure out                                 the basics Amann --tx of it it's gonna                                 be a long road we probably won't see it                                 in actual practice until                                               has working groups we have study groups                                 they're both kind of the same anyone can                                 participate in a study group in C++                                 anyone can participate in a working                                 group you still have to book you know                                 approach both of good faith arguments                                 and that's a like I said we don't have                                 enough time unfortunately so apologies                                 so also technically speaking this code                                 that you see here this could be valid                                 C++ or rest code those of you that are                                 familiar C++ might have figured out                                 already what I'm doing here which is you                                 just start to fine let to auto and                                 you're on your way I already discussed                                 the the memory model stuff and Neil's                                 talked about the abstract machine it's                                 very interesting if it's actually about                                 two hours but it is extremely                                 interesting talk because it kind of                                 gives you an idea of where the hardware                                 that we currently use today comes from                                 where it's going to and the limitations                                 that we have to deal with because you                                 know you could have a high level                                 language that could do everything but if                                 you know the CPU is gonna be flipping                                 bits behind your back and you don't know                                 about it that's gonna cause problems for                                 you of course we also have our                                 differences we're not going to talk                                 about defaults okay I we already know                                 about it's like a dead mean right like                                 rewrite it in rust dead meme talking                                 about cost as default and mutability                                 also a dead meme I don't want to talk                                 about it let's talk about lifetime                                 semantics we're gonna talk about                                 concepts and traits because they're very                                 similar but very different this is just                                 what I'm calling this right now the                                 execution context boundary this isn't a                                 thing that we have a term for in either                                 community yet but it is something that's                                 gonna be coming out because of changes                                 those plus                                                               is I'm sure you're all aware it's baked                                 into the language otherwise you wouldn't                                 have a you know a lifetime you know                                 syntax to represent it most of the time                                 this this concept of lifetime ownership                                 and stuff like that can be mapped to                                 existing api's from foreign languages so                                 see if you're trying to call into C++ in                                 some way and you figured out how to                                 generate the correct symbol for it sure                                 even there and custom semantics do break                                 down though when you get into stuff like                                 objective-c or OpenCL and yes from an                                 optimization perspective you do not want                                 to always be retaining and releasing                                 these but at the same time sometimes                                 it's nice to just take someone's really                                 garbage objective-c code and then to                                 just copy it into your own code and not                                 have to change as much C++ lifetime                                 semantics oh we don't have any no we                                 literally do not and everything                                 involving unique pointers shared pointer                                 all of this stuff has is defined by the                                 library portion of the standard so the                                 the language doesn't have a concept of a                                 unique pointer of ownership and                                 releasing ownership of you know                                 incremental counts and dereference                                 counts and all that other stuff or sorry                                 decrement accounts but as so as I said                                 everything's library to find mostly                                 obviously value semantics destructors                                 and stuff like that those are at the                                 language level both languages have this                                 constant of D res I'm not gonna use are                                 aii because one it's a terrible terrible                                 acronym it's impossible pronounced right                                 it sounds like a bread if you just say                                 it out loud                                 whereas d res you can make a joke about                                 Tron and everyone's gonna understand it                                 like immediately right and yes I know a                                 drop does not imply a destructor it                                 could be a scope based resource but de                                 res de sounds cooler                                 as an example retain pointer this is a                                 type I've been working on so retain                                 pointer I first wrote it                                 the proposal for it in a night in                                      because this is a type that is meant to                                 you know work with C api's like you know                                 open                                 Seattle or Objective C because Objective                                 C is AC runtime it's meant to work with                                 you know calm and DirectX and some parts                                 of the the Emoto framework web browsers                                 have implementations of retained pointer                                 inside of them                                 Safari specifically inside of the WebKit                                 tool framework which is namespace as WTF                                 has a type called retain pointer as it                                 turns out I did not notice when I wrote                                 the paper and then also it's useful for                                 implementing a sync API it's basically                                 stood future stood shared pointer stood                                 weak pointer it's an exception pointer                                 and listed retain corner itself all of                                 these can be implemented with retained                                 pointer on the rough side if you had an                                 equivalent to retain pointer you would                                 be able to implement both RC and arc in                                 terms of a retain pointers this is a                                 very low-level type and introduces this                                 concept of adoption right we have we                                 have the concept of extending a lifetime                                 of a type we had the concept of                                 ownership of a type but we do not have a                                 concept of ace a value has come in from                                 some boundary that we do not know where                                 it might come from exactly we just know                                 that it has come in from a function and                                 we want to be able to use that type for                                 a brief period and eventually kick it                                 out of our house                                 so kind of like adoption but not maybe                                 not the best term in that case I guess                                 so so this this type is there's a                                 someone on Twitter whose name is Arvid                                 Gerstmann he is a bit of a firebrand and                                 in that he disagrees with everything                                 that's people suppose committee does and                                 says this is just over complicated I                                 don't care about this so neither should                                 you but after I presented this this                                 updated version of retained pointer in                                                                                                          I've implemented this six times in my                                 code base I'm replacing it with this and                                 if Arvid says this is a good idea for                                 the C++ standard library to have then                                 maybe you're onto something so let's                                 talk about resources concepts for quick                                 so rust traits are maximally constrained                                 right if if a type does not mention what                                 traits it uses you can't call any member                                 functions on that right whereas in C++                                 they're minimally constraining C++ says                                 this type has to meet the basics of this                                 interface other than that go                                 wild I don't care if this function                                 doesn't exist if I have to do a lookup                                 later you might get an error there and                                 so more work has to go into a concept to                                 make sure that the minimum interface is                                 being met and we're gonna also discuss                                 briefly so they are now I had to add                                 this literally five minutes ago special                                 members which are constructors                                 destructors kind of constructors                                 assignment or now follow the best fit                                 model as of Cologne which was back in                                 June and as an example here here's a                                 cost expert optional implementation                                 where the destructor that is trivially                                 defaulted there will be used if the                                 given T which is destructible is also                                 trivially destructible if it is not then                                 we have to reset the optional on                                 destruction does that does that make                                 sense like I know this it's a it's a                                 mouthful but the semantics for this are                                 basically why we did this because we can                                 use this on member functions as well and                                 suppose to us so let's look at using a                                 concept so this is this is some garbage                                 code here and I apologize but this is                                 just the best way I was able to                                 implement this and this is basically to                                 say if a type has an element type def or                                 if it has a pointer type def I want to                                 get that out of it and use that as a                                 storage value and so this is a slightly                                 regular type because unfortunately we                                 have the concept of a regular and semi                                 regular type but for that to be true                                 something has to be copyable not only                                 movable as a minimum we also decided at                                 cologne to change all of these names to                                 a snake case instead of the upper cased                                 form and I didn't feel relighting in any                                 of this code so you're just gonna have                                 to deal with it so here's a pointer like                                 type this is for our smart pointer                                 interfaces right so you can get it you                                 can cast it to a bull explicitly you can                                 reset it you can reset it with an                                 instance of the pointer type internally                                 hence the pointer type of T which we saw                                 two slides up we're not gonna get into                                 this explicitly here but you'll also                                 notice on this line right here we're                                 checking to see if you can call the                                 arrow operator directly as a                                 function rather than calling the arrow                                 because that's a thing we can also do in                                 C++ isn't that a nightmare but here's                                 here's a handle right this handle can                                 implement any kind of ownership model as                                 long as that ownership is defined by                                 this pointer like storage type and as an                                 example here we can have a unique handle                                 we can have a shared handle we can have                                 a retained handle we can also have a                                 viewed handle and you wouldn't hold this                                 as a member inside of a class you would                                 actually inherit from this in C++ this                                 is basically a mixin type and as an                                 example if we use the Android NDK as an                                 example here we have a simple enum class                                 with an orientation and here's a                                 configuration type now there's a lot of                                 code here the important part here is                                 that we just inherit from it and in our                                 constructor we that is copying we have                                 to call this a configuration copy thing                                 use this other thing called out pointer                                 let's not get into that part that's not                                 what matters what matters though is                                 you'll notice this class does a whole                                 bunch of stuff you can reset with it you                                 can cast a tooling you can check to see                                 if it is a valid configuration or not                                 that is I think really powerful and C++                                 is that we do have the ability to have                                 mix-ins that also then expand the                                 lifetime                                 semantics of whatever it is trying to                                 make C's need to manage so and in seven                                 slides we described a per type opt in                                 for lifetime semantics you can have a                                 non owning handle you can have a                                 retained handle a shared handle or a                                 unique handle and that's just with                                 concepts implementing that without                                 concepts absolutely a nightmare and                                 there's a whole bunch of side effects                                 that I don't want to get into but I                                 think that's a very powerful part of C++                                 here we can also extend this by                                 implementing other pointer like types so                                 hazard pointer which is meant more for                                 concurrency related stuff boost offset                                 pointer which is a an optimization for                                 shared memory operations and even if you                                 wanted to have some weird pointer and to                                 like go and you were binding code with C                                 go you would be able to use this as well                                 the execution context boundary is                                 basically this idea of executing code at                                 compile time versus runtime I believe                                 all                                 was discussing this in their talk I                                 missed that talk because I was trying to                                 finish up a few slides I apologize for                                 that but cautionary sources context                                 parent constant eval is basically where                                 we're getting into this supercilious has                                 explored this a lot more areas our                                 compilers are trying to implement                                 bytecode interpreters for context for                                 just for Speed purposes so in C++                                    we're getting cost eval cost in it and                                 we still have cost expert we're not                                 going to talk about constant it it is a                                 terrible keyword with one specific use a                                 lot of people don't understand its                                 meaning I am one of those people so I                                 can't explain it even if I wanted to                                 functions our runtime by default as they                                 are in rust constant Val means it can                                 only execute at compile time and in a                                 compile time context so if you try to                                 you know return a function from main the                                 function will still execute a compile                                 time but then the value that is returned                                 will be stored and then returned in a                                 runtime context cost expert is sometimes                                 at compile time and this is where the                                 bridge concept of a bridge between these                                 two boundaries for execution context                                 comes in we can now detect and see what                                 suppose                                                                 a Const expert context or not and then                                 change our code dependent on that and                                 C++                                                                 expert Cindy semantics because at ca√±o                                 compile time we just do what it would                                 normally do in a non efficient way and                                 at compile time we can actually insert                                 assembly instructions right I think that                                 that's extremely powerful and allows you                                 to also check to see like ok because a                                 contact sport function cannot invoke                                 undefined behavior you can kind of check                                 your stuff with static assert at compile                                 time and allow the you know the the type                                 system to kick it into place we also                                 support virtual cost expert which yes                                 this is terrifying because if you think                                 about it means that you can have a                                 virtual cost expert destructor so we can                                 have compiled time polymorphism in the                                                                                                    virtual functions and public inheritance                                 and yes this also supports virtual base                                 classes so if you remember                                 that massive slide that everyone just                                 like gasped and horror at the closing                                 Hina                                 last year that had a million virtual                                 base classes that could technically be                                 done at compile time as well that said                                 though if we can do any of this I think                                 rust can do it too                                 I again not that part specifically I                                 should note but just the ability to have                                 like a dying trait be compiled time I                                 think is something that could                                 potentially be in rust future wouldn't                                 obviously be a Dyne trait I'd probably                                 be a constant dying trait but that it's                                 something I think is definitely possible                                 maybe not right now                                 I'm not gonna write the proposal I have                                 too many things going on in my life                                 right now I have seventeen papers you                                 need to get through the C++ standard so                                 we're gonna talk about something here                                 we're gonna be switching gears right the                                 technical part of this talk is over with                                 and this is we're gonna be leading into                                 this very slowly it's just let it build                                 up I promise we'll be over with it soon                                 so in battle Rises talk he mentions that                                 the FreeBSD community was telling those                                 unhappy with system D to come to FreeBSD                                 right and this is a problem because                                 system DS creator even if he is an                                 abrasive person even if you don't like                                 him I don't think he deserves death                                 threats and if these are the same people                                 that are then going into the FreeBSD                                 community that is a problem and those                                 are not the people you want in a                                 community right you don't want to find                                 out that oh this speaker at a conference                                 sent a death threat to someone that                                 maintains a C++ compiler and also know                                 they're running rust kind of like this                                 sort of thing that happened here saying                                 that the people in charge of C++ are                                 idiots and that it is academic                                 masturbation is not gonna win any points                                 with anyone and furthermore saying oh we                                 should try to get game developers to                                 come to rust as one gonna make everyone                                 here have an aneurysm when you have to                                 see all the unsafe code they're gonna                                 write because they're gonna use the                                 unsafe key word trust me I've already                                 seen some of the code that's out there                                 and also you don't want this kind of                                 person to be talking to people in                                 general right like                                 do you do you want to have a                                 conversation with this is like oh this                                 is a tweet from a dude that has written                                 a book on physics in C++ and using it                                 over the network and and he lost his                                 absolute mind at me I also wanted to                                 show a few tweets from the VP of                                 Technology activision but he blocked me                                 on Twitter when I said the game                                 companies that make billions of dollars                                 should maybe pay their employees a valid                                 salary and maybe they could just send                                 representatives to C++ if they're that                                 upset about it                                 so you know I and also I don't I don't                                 think you want people like this in your                                 milieu right in your general social                                 environment and if we start to see other                                 implementations arise you may not have a                                 choice but to interact with them right                                 just because the rust community right                                 now has a code of conduct and just                                 because the rust subreddit has a code of                                 conduct does not mean that an                                 alternative implementation of rust has                                 to follow those same code of conduct                                 rules and that kind of brings this into                                 the concept of standard versus                                 specifications so all standards are a                                 specification but not all specifications                                 are a standard especially if they only                                 apply to single product right if there                                 was a specification for the rust                                 compiler that would just be a                                 specification for what the rust compiler                                 can and cannot do it does not imply that                                 if I write my own rust compiler that I                                 have to implement every part of said                                 specification thus there could be a                                 standard rust in the future where bar or                                 CK is not a part of that right and                                 that's one of those powerful parts of                                 the rust compiler but it is not part of                                 the language the borrowed checker is                                 just a static analysis tool it is not                                 baked into the language itself and yeah                                 that's terrifying but we're gonna put                                 that aside for now okay we're not gonna                                 actually bring this up again so in                                 Siebel suppose we're limited to the                                 rules of high school ISO actually has                                 this hard rule of five years is them is                                 the minimum at a time or the maximum                                 amount of time you are allowed to                                 release sustainer between so the fact                                 that we're doing it every three years in                                 C++ we're kind of breaking the rules                                 and rust is limited to the laws of the                                 United States under which Missoula                                 operates right if they say you cannot                                 provide software to someone in Iran                                 right then all of Iran cannot use rust I                                 could technically hand a USB Drive to                                 someone from Germany and then that                                 person could hand it to someone from                                 Iran but I can't know about that at all                                 this is where things start to get like                                 really hairy in general ISO draws its                                 authority from multiple nations each                                 backed by treaties international                                 trademark laws in some case they use                                 their military to enforce these laws and                                 by owning the content found as documents                                 so C++ the the working group                                        Standards Committee we don't own the C++                                 standard the ISO you know organization                                 owns it                                 ISO organization ATM machine so it's so                                 there's this concept of a standard plate                                 of spaghetti right a plate of spaghetti                                 against which you could technically                                 judge all other you know plates of                                 spaghetti and if something doesn't meet                                 that standard plate of spaghetti it can                                 be deemed subpar so there is in fact a                                 minimum amount of you know cooked                                 spaghetti that you can meet and ISO owns                                 the copyright and Trademark for said                                 document membership access to I so by                                 the way changes per country in the                                 United States its twenty two hundred                                 dollars a year you can also get some of                                 that money just made to disappear or                                 that requirement to disappear if you                                 make less than three million dollars as                                 a result United States national body for                                 ISO is massive we have tons of companies                                 that are not based in the United States                                 because it's just easier to join the                                 u.s. one than it is to join their own                                 countries ECMA is an alternative                                 organization to ISO and draws its                                 authority from the same sources except                                 it's based out of Switzerland but                                 corporations have as much of a say                                 there's a national body if Google pay                                 $                                                                 standards body pay $                                                    equal say it's also prohibitively                                 expensive I think the the minimum amount                                 of money you need to pay per year for                                 voting rights is                                                       whatever their currency is I don't care                                 I don't pay attention to that stuff so                                 Mozilla draws its authority from Unitas                                 its corporate laws such as intellectual                                 property laws that can be used to                                 threaten permanent destitution to anyone                                 violating them if a court scene Dean's                                 and someone has violated these laws                                 right if a judge says yes you were in                                 violation of this intellectual property                                 and as a result I'm going to fine you                                 $                                                                      line with these rules that can seriously                                 limit your future and currently Chelsea                                 Manning is I believe paying $                                            for refusing to testify in front of a                                 grand jury she could use some help                                 financially by the way and in the above                                 cases a person does not have the power                                 to say something right without some                                 labor derived reason right so if                                 something isn't for work then change the                                 simple supposed to right rust might be                                 dismissed right if I'm not doing it for                                 a project then you can just ignore my                                 changes this takes power away from users                                 and replaces it with submission to                                 Authority also I'm sorry I'm getting the                                 note that I need to speed up here and                                 basically wrap up so I'm gonna skip                                 ahead here and the the thing I'm trying                                 to get out here I guess is that can get                                 to a lot of this stuff and try it so                                 hard got so far to the end didn't even                                 matter so I guess the thing I'm trying                                 to say is that I don't want rust to                                 standardize I think that trying to force                                 it into an organization that has to be                                 backed by a nation state to enforce it                                 is a mistake and what rust really needs                                 is some kind of informal body to well so                                 by the way I'm an anarchist I don't have                                 all the answers and apparently neither                                 do I have the time to finish this up so                                 we're gonna yeah so so if in a formal                                 body for a formal standard does not                                 exist I don't know if it could exist and                                 how you would even force any of these                                 things it's very difficult to talk about                                 this stuff and this is something that I                                 would rather have had a lot more time to                                 get to this point maybe I should have                                 pushed it further up in the talk and you                                 know y'all have responsible yourselves                                 in your communities well since the                                 industry's we're working and I guess                                 just gonna close this talk up with this                                 you know if if you want to hide horse                                 and fight prevent major catastrophe and                                 you managed to have to feel pain er be                                 alone that's not language evangelism                                 that's language Evangelion ISM and I'm                                 sorry that this talk ended up going over                                 the time here I guess we're out of time                                 yeah so I will be putting these slides                                 up on github so feel free to check that                                 out later and if you want to actually                                 have the important part of the talk that                                 I wanted to get to which is please don't                                 make a standard that has to close off                                 access to the current milieu that is in                                 this room that is if this conference                                 that is at other conferences and                                 requires people to pay to to vote I                                 highly suggest that you you look into                                 alternatives even if they don't exist                                 yet even if you have to make something                                 new                                 [Applause]                                 [Music]                                 you
YouTube URL: https://www.youtube.com/watch?v=nqvGoDvQTRs


