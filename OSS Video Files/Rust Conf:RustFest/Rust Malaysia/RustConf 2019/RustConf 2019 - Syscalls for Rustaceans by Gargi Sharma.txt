Title: RustConf 2019 - Syscalls for Rustaceans by Gargi Sharma
Publication date: 2019-09-19
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Syscalls for Rustaceans by Gargi Sharma

Even if you haven't used Rust's nix package, and have just written println!("Hello, World!"), you have most certainly used syscalls. Syscalls are an interface between the operating system and a user program.

strace can be used to debug git performance issues, examining internals of closed source programs, sandboxing programs and is a powerful debugging tool under your arsenal. This talk explains what syscalls are, how they work, how you can track them using strace and how you can write your own syscall tracer (strace) in Rust!
Captions: 
	                              [Music]                               hi everyone my name is Carly and I'm                               going to be talking about just cause                               fire stations oh sorry I forgot that now                               I don't need to speak up in war yeah                               yeah and if you want to follow the                               slides alone here's the link and yeah                               let's get started so before I even begin                               to talk about system cuz I want to talk                                about what it means to be a systems                                programming language so it's a term you                                hear a lot in contacts with drastic                                trust is a new systems programming                                language and but what makes a                                programming language a systems                                programming language and what makes C                                and C++ and Rus good candidates first                                essential gaming languages where it says                                Python and Perl and not so good                                candidates for assistance programming                                languages so only take us to take us to                                a tray of history and talk about                                evolution assistance regarding languages                                so the two things that I will be                                sticking to in this talk will be what                                does it mean to be assessing programming                                language what makes trust a good                                candidate for systems programming                                language and third is learning about                                system calls and writing your first                                programming our first system for a                                German trust if you haven't written it                                already and to empower people to write                                more systems programs in rust so my                                research tells me that the first time                                systems the systems program term was                                coined was in                                                          where we where we were improving on                                assembly and the author of this paper                                consistent programming language defined                                assistant program as an integrated set                                of sub programs in exceeding some                                threshold of size of complexity so some                                examples of such systems would be like                                simulator                                or time-sharing systems information                                management systems and then the author                                goes on to define what system program is                                so a system program is defeated likely                                to be used to support other software                                programs so I'm system so this this                                system program can be an application in                                itself or it can be used to support                                something else for example the operating                                system is written in like some systems                                programming language like C provides so                                if you want to read or read from a write                                to files on disk the operating system                                would provide you the functionality to                                do this it makes sure you have sorry it                                makes sure you have programs to access                                permissions to handle multiple files of                                accessing files and loading blocks into                                memory and so on so it is likely to be                                continuously evolving so it is in                                contrast with the systems of nineteen                                seventies where you had one shot one                                shot solution using an application                                rather than continuously evolving o                                canonist e evolving systems so oh sorry                                the key idea in this paper is                                descriptive so defining a system but the                                but the key idea in this paper is                                prescriptive so separating the                                separating the language at the time                                assembly from Fortran which was more                                higher level so a language which can be                                used without undue concern for bit                                twiddling which can be used to design                                and write more systems without                                unnecessary overhead on our resources                                and the last paper from                                               program was the paper consistent                                programming but Donovan so the first                                time we had computers we dealt with them                                using on and off switches and then we                                wanted to do more complicated things                                like if I have Y which is                                              to calculate X which is                                                 I do that                                so present-day programs cannot                                understand these without the aid of                                systems programs like microprocessors                                and compilers and assemblers and etc so                                to make computers better adapted to the                                needs of the user we need systems                                program is what the paper said in                                     and then in the                                                 researchers saw systems systems                                 programming languages in contrast with                                 assembly programming there was something                                 no good tools to build but both systems                                 however in the mid                                                     of scripting like guys a dynamically                                 type scripting languages so bash                                 languages like Perl Python Adobe you                                 gain steam and make make made their way                                 to the works through the mainstream and                                 systems programming languages were                                 designed to burn more primitive computer                                 elements versus scripting languages were                                 designed for gluing so you can separate                                 scripting languages and systems                                 languages on technically you can                                 separate them on the access of type                                 safety versus if you were to step up                                 separate them on the access on on the                                 basis of design you can say that systems                                 languages are programming languages are                                 designed to build more complicated                                 software versus scripting languages are                                 designed to glue those cars do glue                                 those components together and so in                                      stubborn                                                           nice flirt so massive resources were put                                 into Java Justin building just-in-time                                 compilers for JavaScript like create or                                 patent spare time and their performance                                 is not better but if not better                                 almost as competitive to C and C++ and                                 draw box was able to burn its large and                                 scalable system and just fight on chess                                 trip is he stood under yeah Showtime and                                 Georgia new eyes with in in billion of                                 web pages and there was gradual typing                                 in JavaScript and Python which enables                                 people to transition from prototype to                                 production code and large-scale                                 distributed systems languages like go                                 and go etc say go etcetera put in                                 resources so that garbage collector                                 languages also perform well                                 so which are leads all of this leads us                                 to what does it mean to be a system for                                 learning language today so languages in                                 the category of C and C++ and rust in D                                 are distinguished in the terms of the                                 level of abstraction they provide you                                 from the machine so the languages expose                                 the details of underlying hardware like                                 memory allocation layout etc so when you                                 have a efficiency problem is it in your                                 part to eliminate the bottleneck so the                                 wonderful part about these languages is                                 that they provide you confidence so if                                 you have a statically typed language and                                 you say this language gives me the                                 confidence that if I'm adding these two                                 integers and you get a result which is                                 an integer the same way these languages                                 give you the confidence that if I'm                                 executing this instruction and a machine                                 then it will work exactly as I wanted to                                 so lower level programmers should seek                                 you understand how the system design                                 could be adapted to the reality of                                 modern-day hardware and                                 something-something rust does really                                 well is that it takes the ideas of the                                 functional programming and and                                 lower-level problems like futures and                                 type safety of course and uses them I                                 uses them to make the language better                                 and we should also consider the added                                 benefits of using our switches it                                 provide which are enabled for us types                                 establishes static information for                                 control and safe showers of pointillist                                 data structures and software fault                                 isolation and with that with with the                                 history of the sensor having languages                                 and where we stand today I want to jump                                 into the next part of this talk which is                                 oh sorry before that you can throw                                 everything I've said out of the windows                                 and systems programming is when you                                 spend more time looking at the man                                 spacious than reading so with that I                                 want to jump on to the next part of my                                 talk which is writing our own s tres um                                 so for this I hope to empower you to                                 like your own s tres are even more                                 complicated systems Perkins so let's say                                 you have a user program and user process                                 and you want to do something that that                                 seems as trivial as reading from a file                                 but it's your operating system has the                                 necessary privileges to read the file it                                 has to find a scripture and it has the                                 it has the it had and it has the                                 location of the file and you want to                                 read this file but you have to talk to                                 the operating system to do that so who                                 you got a car system cars                                 so you can think of system cars as an                                 interface between your operating system                                 and user program or you can think of as                                 an API that is given by the operating                                 system to you for you to use and there's                                 like around                                                             not so if though I write esoteric and                                 some of them are very common so some of                                 the common ones for like file access a                                 create read write open and close so I                                 included create here because one can                                 Thompson was asked if he had any regrets                                 about Unix                                 he said I wish I had named let's see Rea                                 te and not G and which is also this                                 system guy is obsolete now because if                                 open but I included it for that Chuck so                                 and the net more system con so for the                                 process control if you want to wait for                                 a process you can use rater a PID if you                                 want a killer process you are you would                                 use kill if you want to spawn another                                 process you would use for it and for                                 network access you have socket when you                                 wanna create a socket get suck suck it                                 get suck obd when you want to set or get                                 the options in a socket or anyone listen                                 to a sake when he's listen so what                                 happens when assistant occur is that say                                 we want to read from a file so the user                                 program would push the number of bytes                                 it wants to read push the buffer which                                 is the address of where it wants the                                 result of the reader to be stored and                                 the file descriptor into registers and                                 it will call feed and then it gives you                                 a library procedure which will put the                                 code for the system call in a register                                 so each system called has a number                                 associated with it for example either                                   openness                                                                code in the register and the sign                                 up to the kernel and then now there is a                                 context switch and you go to the kernel                                 the kernel will go and look into the                                 register for what what side so when you                                 send a chap you send a chopper with a                                 number so that number is the number of                                 the system call and in the operating                                 system there's an array where like the                                 current goes are you son                                              Street so it go and look into the                                 registers of like what file I have to                                 read and where I have to store the                                 result of the read and once the kernel                                 does that it's written there's another                                 context switch back to the library                                 procedure and finally to the user                                 program so one thing to note is that                                 system calls are fairly expensive you                                 have two context switches involved yeah                                 so making a system cut is you have a                                 register where you would have the file                                 descriptor stored at register where you                                 have the buffer stored and the register                                 with the count of bytes that are that                                 are QB that oh dad for example so you                                 set up a register with the system card                                 number and parametres you send a trap to                                 the kernel and you get the result stone                                 in the register but the good thing is we                                 don't have to do it oops we don't have                                 to do any of this because UNIX provides                                 us with a library called MC which is a C                                 library and the problem that we must                                 respect our is however this array is                                 that it has it has our King types so it                                 gives you white pointers a lot of white                                 pointers that you'd have to use oh but                                 it's the only API so that's cool so we                                 so now that we have an idea of what                                 happens when assist occurs and how do                                 you make assess color I want to jump on                                 what's what is as trace so X traces are                                 the nasty buggin you                                 which allows you to debug the source                                 programs for example if you have and it                                 allows you to identify it allows you to                                 identify body locks in the program so we                                 already know that system calls are                                 expensive so if you have a program and                                 what you have optimize it for its                                 performance then you see that it's                                 making more open calls than you thought                                 it would you can go and optimize s trace                                 or tell you how many open system costs                                 that your program is making and I can go                                 and up demonstrate that and it's also                                 invaluable when you have closed source                                 program you can't just go and attach gdb                                 and say oh please stop at like                                    because you don't know what's it like                                    so in that case if you have a cursors                                 program which has which you thought was                                 oh it's not working like you wished it                                 would and you you go and see the s trace                                 for it and it's opening X instead of                                 opening why he kept us trace will tell                                 you that so if I have a very so prepare                                 yourself for the record and I see the a                                 straight out portrayed I'm not sure if                                 it's visible but I will still see what                                 it is so it has it first has an exact                                 system code which is executing my script                                 and then it has a break and access and M                                 map and so on and it lists all the                                 system codes that are made in that order                                 and if I have our s trees - C which will                                 tell me the count of all the system                                 calls that were made so I have                                           comes to read a                                                      tell me oh this isn't calls that were                                 made which is pretty honey um so that's                                 the laughs now it's the last part of                                 myself wishes we will write our own s                                 trace so we need three things to write                                 our own s trace one is we need to know                                 how to observe another process which is                                 an important part because we want to                                 find out how many                                 some colace other process is making                                 second is how to trap assistant go once                                 we know that we have a process how do we                                 know that it's making a system card and                                 the third is once we know that system                                 call is being made                                 that's right sure but now you want to                                 look at the registers to see what's                                 happening or like what system code was                                 made because the register is the value                                 of the system code so how do we observe                                 another process who have system costs to                                 the rescue again                                 PJ's so PJ's is a not a POSIX system                                 card which means it has different                                 behaviors and different operating                                 systems but for Linux we have PJs so you                                 have a tracer and a Tracey and what PJ's                                 allows you to do is observe uncontrolled                                 execution of this other process which is                                 very shady because you can go and change                                 the dredge esters of this another                                 problem this other process and do                                 malicious things but the good thing is                                 that if you want to observe another                                 process this other process has to give                                 you explicit permission that yes I want                                 to be traced and the second is if you                                 want to chase this other process you                                 need to be in the parent namespace of                                 this process so the first line of this                                 code is the process giving me explicit                                 permission to trace it and the second is                                 me spawning this process so that I can                                 be in the parent name space of the                                 process and the next is the next thing                                 we care about is how to chop the system                                 code so P traits do the rescue again so                                 every time the process that we are                                 tracing makes the system call a sig shop                                 is sent to the tracer and then execution                                 stops so you can go and check the                                 register if you want to and you wait on                                 this process so you will stop every time                                 a sick trap is send so Peters do the                                 rescue again it has a flag called Pete                                 racism car which means that every time a                                 system cars called a sec traffic Mizpah                                 would be would be a sick trap would be                                 sent and you can stop and inspect the                                 registers or arguments to the system                                 call if you wish to and then you can                                 start race so this will happen in a loop                                 so you can resume resume your process                                 again and then the next time a system                                 happens you stop again and you can                                 inspect the arguments again and so on                                 and then the last is how to fetch a sir                                 values which is again features it's                                 amazing you know Sophie trace has a flag                                 called P trace underscore cash registers                                 which will get you all the registers but                                 once you get all the registers you know                                 you have to know which register stores                                 which value so I found out through                                 googling that the other extra gesture                                 stores the value of this stores the                                 number of the system car so you can use                                 that to find out what system code was                                 made and you know I have a demo so I                                 have a simple program because I some                                 people see you cool I have a simple                                 program cough hello Josh Roscoe and in                                 this and I have another yes five                                 restores are the three thirty two sister                                 thinks so zero is read and then one is                                 dried and two is open I shouldn't make a                                 trade yeah and then in this main program                                 I have like a function code get                                 registers which will get me the                                 registers and then I                                 the the child allows the parent to trace                                 it and I spun the process and in this                                 loop I will get the registers and map                                 the system call names and insert in the                                 milk and if I want to run s trace on                                 hello oops sorry yeah then it says the                                 Raskin and telling me that Oh sounds was                                 gone nine times and F start with seven                                 times and readers cut seven times which                                 is pretty neat yeah so in conclusion I                                 want to say say in conclusion I want to                                 say that trust is very empowering and                                 it's so much cooler than C or C++                                 because because it follows the ax - that                                 like if it compiles                                 it will work which is which is not true                                 for C or C++ at R and if you were doing                                 this you would have to do memory                                 allocation and other things which are                                 hard and scary for new people yeah so                                 and I would like to give it a minor that                                 systems things are not hard at all                                 if they are explained well and I made                                 more accessible to more people it's like                                 if you think about networking it seems                                 very hard because it has all these                                 intimidating concepts but then it's like                                 the core concepts are like IP addresses                                 and first cetera and once you understand                                 though you can do that thank you so much                                 also I want to give a shout out to a                                 shallow Hardy Taylor Kerry and with you                                 Harris ho Steven Steven for helping me                                 with the stock and thank you so much                                 [Applause]                                 [Music]
YouTube URL: https://www.youtube.com/watch?v=QP8XtsjRdUA


