Title: RustConf 2019 - Closing Keynote by Lin Clark
Publication date: 2019-09-19
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Closing Keynote by Lin Clark
Captions: 
	                              [Music]                               I'm Lynn Clark and I make code cartoons                               and they also work at Mozilla and                               advance development and today I'm gonna                               be talking about a possible future for                               rust and the impact it could have on the                               programming world I have to say it was                               quite an honor when I was asked to                               keynote this conference you know of                                course it's always an honor when you're                                asked a keynote a conference but that's                                not why I'm talking about here it was an                                honor to be asked specifically to                                keynote ruskov and that's because of                                what rust has done and what rust means                                what I'm talking about is that rust is                                really a leader in a whole new                                generation of programming languages and                                programming language communities is                                truly transformative is transforming the                                conversations we can have about what's                                possible now I'm sure that many of you                                are aware of some of the things I'm                                referencing here                                so the most well-known of these of                                course is how rust is ushering in a                                whole new way of thinking about systems                                programming and the impact of this is                                visible in a lot of different places one                                recent example is the series of blog                                posts that Microsoft put out you know in                                these posts they say if only the                                developers could have all of the memory                                security guarantees of language                                languages like dotnet c-sharp combined                                with the efficiencies of C++                                maybe we can with rust and they go on to                                say rather than providing guidance and                                tools for addressing flaws we should                                strive to prevent the developer from                                introducing the flaws in the first place                                so we have one of the world's finest                                tool manufacturers saying do we really                                need to build tools for this at all what                                if we can make developers lives easier                                without having to resort to tooling and                                we have them asserting that rust has                                opened up a different more desirable                                possible future even if it were just for                                that rust would be an incredibly                                impactful language blazing a new trail                                for other languages to follow but it's                                not just that rust has also blazed a                                trail on a completely different front                                and this one has more to do with                                technology's intersection with social                                issues from the early days rusts core                                leadership understood that there was a                                problem with the way that our language                                communities work they understood that if                                you looked around and saw faces you saw                                people that only looked like you that                                that meant that there was a flaw in the                                system a flaw that was keeping other                                people from having the same                                opportunities and reaching their full                                potential and these leaders were very                                public and very vocal about the fact                                that they didn't think the                                responsibility for solving these                                problems lay on the shoulders of those                                most affected by them but instead they                                themselves intended to work towards                                fixing these problems and this is one                                aspect of rusts leadership that has                                affected me quite personally when you                                come from an underrepresented group in                                tech it can feel like you're swimming in                                a sea of unconscious bias and sometimes                                outward aggression and seeing a beacon                                seeing people waving a flag saying that                                they're going to make space for you to                                join them that can be the difference                                between leaving Tech and finding a                                future in it and I know this feeling                                this is where things were for me when I                                first heard about rust and seeing those                                rust leaders seeing them waving this                                flag of inclusion gave me a place to                                swim towards and that was actually a big                                part of me taking the job at Mozilla                                knowing that I was gonna be working at                                the same company as a lot of the people                                that were waving this flag so I swam in                                that direction I started working at                                Mozilla I wasn't working closely with                                the rust team at that time but I wanted                                to move in that direction so after about                                a year I started thinking about how I                                 could do that and it turned out that                                 starting on that path would be a                                 defining moment for me even though it I                                 didn't end up exactly where I expected                                 to be I was coming from a role that                                 dealt mostly with web technology so I                                 figured the best entry point for me with                                 rust would be web web assembly the first                                 most rudimentary support for rust                                 compiled                                 assembly had landed at that point and so                                 I started playing around with that not                                 long after I started down that path I                                 ran into a pivotal character in this                                 story and that's Luke Wagner now if you                                 don't know him he's the person that had                                 the key insight that led to as in Jay s                                 and he was also a major driving force in                                 turning webs as in chase into                                 webassembly                                 so he's a co-creator of webassembly he's                                 also something of a nerd sniping expert                                 anyone who's worked with Luke can tell                                 you how great he is at getting you                                 excited about his ideas and making you                                 really want to work to drive them with                                 him so I got a little bit waylaid on my                                 journey and I ended up not getting all                                 the way to rust but ending up somewhere                                 rust adjacent but as I was preparing                                 this talk I realized that's actually                                 given me a really great vantage point to                                 see another place where rust is starting                                 to blaze a trail and that's because                                 since those early days when I was first                                 playing around with rust compiled to                                 webassembly                                 rust has developed top-notch support for                                 webassembly the experience is so good                                 it's widely considered to be the best                                 tool chain around for compiling to                                 webassembly                                 and it's not just that rust has a great                                 implementation rust is also informing                                 the specification actively participating                                 in shaping the future of webassembly a                                 big part of this is a project called                                 wasm bind gen this project was created                                 to make it easier for rust code that was                                 compiled to webassembly to interoperate                                 with JavaScript and web api's because at                                 least up until now web assembly has only                                 been able to talk in numbers if you had                                 anything more complex so you know                                 something that you wouldn't even think                                 of being that complex a string that                                 wouldn't work you couldn't actually pass                                 that back and forth you'd have to write                                 all this glue code in between to encode                                 and decode this string so Luke expert                                 nerd sniper that he is found some folks                                 to work with him to sort out this                                 problem                                 he explained a few rough ideas so to                                 people you might know Alex Crichton and                                 Nix                                 Jerald and this was how wise invention                                 was born a provided really ergonomic yet                                 performance it allows a Russ programmer                                 to stay at a high level using high level                                 types when talking to JavaScript into                                 web api's despite web assemblies minimal                                 type system so it showed what was                                 possible and there started to be this                                 virtuous cycle with web assembly                                 proposals around interoperability                                 influencing wise and bind gen and woz                                 and bind gen influencing those proposals                                 and with this virtuous cycle this is                                 becoming a much bigger much more                                 impactful thing it's moved past just                                 interoperability with the web platform                                 and onto interoperability with all of                                 the things so one example you know you                                 could run a web assembly module using                                 rich api's with high-level types to talk                                 to Python or Ruby or PHP when they're                                 running in their own runtimes and then                                 you could turn around and take that same                                 module and use it to directly talk to                                 the host or to the operating system                                 using the same high-level types even                                 though the types of that operating                                 system understands are different from                                 the types that Python understands and                                 then you could use those same high-level                                 api's when talking to a web assembly                                 module compiled from a different source                                 language for example you could have one                                 that's compiles from go interoperating                                 with one that's compiled from rust why                                 would you want to do this why would you                                 want to use it as a web assembly module                                 in all of these different contexts well                                 there are a few reasons if your app is                                 in a scripting language like Python then                                 what would something could be much                                 faster you could get near native                                 performance without the hassle of                                 compiling a native extension if your app                                 is in a lower level language like C++                                 then web assembly can give you                                 lightweight sandboxing the module can't                                 access memory or other resources unless                                 they've been directly handed to it so                                 this can make reusing code more secure                                 and for both scripting and lower-level                                 languages being able to reuse code from                                 any language ecosystem without having to                                 rewrite it in your own layer                                 which can help you move faster and can                                 ease your maintenance costs and this is                                 an area where rust is really primed to                                 take the lead and set an example for                                 other languages why is this well it's                                 for a couple of reasons                                 rust already has really a really good                                 story around code reuse with affordances                                 like the module system and creci√≥ and it                                 already does have what's widely                                 considered to be the best tool chain for                                 compiling to web assembly so rust could                                 blaze a trail here and I know that I for                                 one would really like to see that I'd                                 like to see rust bring those technical                                 values and those social values to a much                                 broader community to the union of all of                                 these language communities so I'm going                                 to explain the proposal in more depth                                 and I hope that this helps you all think                                 through what kind of impact rust can                                 have here now there may be some things                                 in this explanation that our review for                                 you but I like to make sure that                                 everybody's on the same page so please                                 bear with me for those parts first I'll                                 start by explaining the initial problem                                 that both the specification and wasum                                 bind gen we're trying to solve and then                                 I'll talk about the larger problem that                                 they've moved on to since then so like I                                 am in like I mentioned the initial                                 problem was a more tractable one                                 how can webassembly interact with the                                 web platform using high-level types now                                 this still isn't a tiny problem web api                                 parameters and return values can be lots                                 and lots of different types so it could                                 be hard to manually create mappings for                                 these types to simplify things there's a                                 standard way to talk about the structure                                 of these types which is called web IDL                                 and you can actually do a pretty                                 straightforward mapping between web IDL                                 and the types in other languages like                                 JavaScript so here we have an obvious                                 solution just create a mapping from web                                 assembly to web IDL just as there is for                                 JavaScript but that's not as                                 straightforward as it may seem for                                 simple web ideal types like boolean and                                 unsigned long they're clear mappings                                 from web assemblies numbers to web ideal                                 but for the most part web web                                 keep parameters are more complex types                                 so for example an API might take a                                 dictionary which is basically an object                                 with properties or a sequence which is                                 basically an array to have a                                 straightforward mapping between                                 webassembly types and these web IDL                                 types we need to add some higher-level                                 types to web assembly and we actually                                 are doing that with the GC proposal with                                 that web assembly modules we'll be able                                 to create GC objects things like structs                                 and arrays and those will be you know                                 you'll be able to map those to the more                                 complex web ideal types but if the only                                 way to interoperate with these web api                                 is through GC objects that makes life                                 harder for languages like rust and c++                                 that wouldn't use GC objects otherwise                                 whenever that code interoperates with a                                 web api would have to create a new GC                                 object and copy values from its linear                                 memory into that object but we want to                                 be just as easy for languages that use                                 linear memory like Russ and C++ to call                                 web IP eyes as languages that use the                                 browser's built-in GC so we need a way                                 to create a mapping between objects and                                 linear memory and web IDL types as well                                 there's another problem here though each                                 of these languages these linear memory                                 languages represents things differently                                 in their linear memory and we can't just                                 pick one languages representation                                 because that would make things less                                 efficient for the other languages but                                 even though the exact layout and memory                                 for these is often different there are                                 some abstract concepts that are they                                 usually share in common so for example                                 for Strings the language often has a                                 pointer to the offset in memory and a                                 number indicating the length so this                                 means that we could reduce this string                                 down to a type that webassembly does                                 understand                                                              code this mapping into the engine just                                 like the JavaScript to what ID l                                         know we could say that if this web api                                 is taking a string and i pass two                                 numbers just figure out what to do from                                 there but there's another problem here                                 webassembly is a type checked language                                 to keep things secure the engine has to                                 check that the calling code is passing                                 in the right types the ones at the                                 colleagues backs and this is because                                 there are ways for attackers to exploit                                 type mismatches and make the engine do                                 things that's not supposed to do so if                                 you're calling something that takes a                                 string and try to pass an integer to it                                 the engines gonna yell at you and it                                 should yell at you so we need a way for                                 a module to explicitly tell the engine                                 something like I know document create                                 element I know that that takes a string                                 but when I call it I'm gonna pass you                                 two integers now use these to create a                                 Dom string from my linear memory and                                 this is what an early version of the                                 proposal did it gave a web assembly                                 module a way to map between the types                                 that it uses and web ideal types                                 now these mappings aren't hard-coded in                                 the engine                                 instead the module comes with his own                                 little booklet of mappings so get this                                 gives the module a way to say to the                                 engine for this function do the type                                 checking as if these two integers we're                                 a string the fact that this book that                                 comes with the module is useful for                                 another reason though sometimes a module                                 that would usually store its strings in                                 linear memory will want to use a GC type                                 in a particular case so for example if                                 the module got something from Jas and                                 just wants to pass it to a Web API so                                 modules need to be able to choose on a                                 function by function or even an argument                                 by argument basis how different types                                 should be handled and since the mapping                                 is provided by the module it can be                                 custom tailored for that module so how                                 do we generate this booklet well the                                 compiler takes care of that for you it                                 adds a custom section to the web                                 assembly module so for many language                                 toolchains the programmer doesn't have                                 to do very much work at all so for                                 example let's take a look at how the RUS                                 tool chain handles this for one of those                                 simplest cases where you're passing a                                 string into the alert function the                                 programmer just has to tell the compiler                                 to include this function in the booklet                                 using the annotation wise and bind gen                                 by default                                 the compiler will treat this as a linear                                 memory string                                 and add it the right mapping for that                                 and if you wanted it to be some other                                 kind of string you could add a little                                 bit more to that annotation so with this                                 we're able to provide really expressive                                 mappings between a web assembly modules                                 types and web ideal types and we didn't                                 have to make any kinds of compromises on                                 what kinds of languages we support it's                                 possible to have all different kinds of                                 languages compiling to web assembly and                                 all of them can map their types to web                                 ideal types whether the language uses                                 linear memory or GC objects or both once                                 we stepped back and looked at the                                 solution we realized there's actually a                                 solution to the bigger hairier problem                                 here and here's where we get back to                                 that much larger potential for impact I                                 was talking about before is there a                                 feasible way for web assembly to talk to                                 all of these different things using all                                 these different type systems let's look                                 at the options like I talked about                                 before you could try to create mappings                                 like the js                                                              for each language you have to create a                                 specific mapping and the engine would                                 have to explicitly support all of these                                 mappings and update them as the language                                 on either side changes and this creates                                 a real mess this is kind of how early                                 compilers were designed you know there                                 was a pipeline from each source language                                 teach machine code language I talked                                 about this more in one of my early posts                                 about web assembly so you may have seen                                 this image there before we don't want                                 something that's complicated we want it                                 possible for all different kinds of                                 languages and platforms to talk to each                                 other but we want it to be scalable as                                 well so we need a different way to do                                 this more like modern-day compiler                                 architectures these have a split between                                 the front end and the back end the front                                 end goes from the source language to an                                 abstract intermediate representation or                                 IR and then the back end goes from that                                 IR to the target machine code this is                                 where the insight from web IDL comes in                                 when you squint at it web al kind of                                 looks like an IR now Y by dl is pretty                                 specific to the web                                 and there are lots of use cases for                                 webassembly outside of the web so what                                 my deal itself isn't really great ir for                                 us to use but what have you just used                                 web IDL is inspiration and create a new                                 set of abstract types this is how we got                                 to the web assembly interface types                                 proposal these types aren't concrete                                 types they aren't like the inch                                          the float                                                                are no operations on them in web                                 assembly so for example we won't be                                 adding any string concatenation                                 operations to web assembly instead all                                 operations are performed on the concrete                                 types on either side there's one key                                 point that makes us possible with                                 interface types the two sides aren't                                 trying to share a representation instead                                 the default is to copy values between                                 one side and the other side so this                                 makes a lot easier for a single module                                 to talk to many different languages                                 because it decouples them in some cases                                 like the browser the mapping from the                                 interface types of the hosts concrete                                 types will be baked into the engine so                                 one set of mappings will be baked in at                                 compile time and the other is handed to                                 the engine at load time but in other                                 cases when you have two web assembly                                 modules that are talking to each other                                 they'll both send down a little booklet                                 they both have that booklet that maps                                 their types to the abstract types the                                 interface types now one thing I forgot                                 to mention here is that these the                                 instructions that use for defining these                                 are actually declarative you know use                                 instructions but there's no loops or                                 other control flow mechanisms that would                                 turn this into a turing-complete                                 instruction set so what do these                                 instructions look like well before I get                                 into that I should say this proposal                                 still under development so the what I'm                                 showing you here is very likely to                                 change before it's all said and done and                                 also this is all handled by the compiler                                 so even when this proposal is finalized                                 you'll only need to know what                                 annotations your tool chain expects to                                 be in your source code you won't                                 actually need to know how this works                                 under the covers but the details of this                                 proposal are pretty neat so I'm going to                                 show you the current thinking so let's                                 say we want to take a function that                                 return a string except webassembly                                 doesn't have strings so it returns to                                 integers what we would do in our mapping                                 is say call export so this would call                                 that function and put the two integers                                 on the stack and then we would use                                 memory to string so that instruction                                 tells the engine to use these two                                 integers to take the bytes from linear                                 memory and turn it into the abstract                                 string the immediate value there the mem                                 that tells the engine which memory                                 object to operate on and then the engine                                 pops off those two integers and uses                                 them to find the string in there and it                                 creates the abstract string which is                                 basically just a sequence of Ko points                                 and then that's ready to be translated                                 into the concrete type on the other side                                 what does this look like in Reverse like                                 if we were trying to take a string as                                 parameter in that case we'd use string                                 to memory so this would go from the                                 abstract string to the concrete string                                 type in our linear memory so we do an                                 are get to put a reference to the                                 abstract string on the stack and then we                                 would call string to memory and the                                 first immediate here does the same thing                                 that the memory to string                                                you what memory to operate on and then                                 the second tells the engine which                                 allocator function to use when                                 allocating the bytes here so this is how                                 the declarative mapping works and                                 there's a really nice side effect to it                                 being declarative the engine can see                                 when the translation is actually                                 unnecessary                                                            on either side are already using the                                 same type and then the engine can skip a                                 lot of the steps in between so that's                                 how all of this works under the hood but                                 if you want to use this you actually                                 don't need to know any of that                                 the proposal really makes this whole                                 experience pretty seamless so now I want                                 to show you that and again I should warn                                 you like I said before early stage                                 proposal that means that things are                                 changing rapidly and you should not use                                 this in production but if you want to                                 start playing with it we've implemented                                 this across the tool chain from                                 production to consumption consumption so                                 in the RUS tool chain in passive bind                                 gen and in the web assembly runtime                                 we'll a some time and since people on                                 our team are maintainer zhan all                                 these tools and we also are working on                                 the standardization itself we can keep                                 up with the standard as it develops even                                 though all of these parts will continue                                 changing we're synchronizing the changes                                 so as long as you're using up-to-date                                 versions of all of these                                 you shouldn't have things breaking on                                 you too much so now on to the demo and I                                 have to say I have a healthy fear of the                                 demo gods so these are actually all                                 recorded to show of how this works we                                 need a web assembly module that uses                                 interface types so let's go ahead and                                 make one and since I've been talking                                 about strings so much I'll use one that                                 takes strings and return strings so a                                 markdown parser and since I'm not this                                 modules author I'll do this by wrapping                                 functionality with the functionality of                                 this module with my own module so I'll                                 create a render function and that uses                                 string types and annotate it with the                                 blossom blind Jen macro and this is all                                 the magic it knows how the the various                                 string types in rust should be matched                                 to the webassembly string type and then                                 I'll compile it using wasum pack and the                                 woz and interface types lag which is                                 needed right now because this is                                 experimental so this gives us that                                 single wasm file that we can use in all                                 of these different environments for our                                 first environment let's try something                                 like pure web assembly this is a                                 standalone runtime so I'll download                                 class some time from while some time                                 talk to F and then we can run this                                 module and pass it a markdown string and                                 you see if the web assembly module took                                 that markdown string and returned to the                                 HTML string even though the runtime                                 doesn't know anything about how rough                                 strings work they were able to                                 communicate with each other using these                                 high-level types so that was easy and                                 straightforward but what about Python                                 can we use this markdown parser there                                 yes we can and we might want to for the                                 speed                                 to do this we download the West and time                                 extension and this makes it possible for                                 Python modules to call webassembly                                 functions and then all I need to do is                                 import the extension and the markdown                                 module and then I can call the render                                 function now we can run this and again                                 it works the types were different this                                 time we're passing in Python values but                                 it still just works and this is because                                 of that magic of interface types the                                 same file runs in the same way we can                                 also use the same web assembly module                                 and rust one reason you'd want to use                                 the web assembly module here is for                                 lightweight sandboxing that I was                                 talking about before you know this                                 isolates this third-party code from the                                 rest of your application so let's look                                 at how this works so we add while some                                 time rust as a dependency and this does                                 the same thing as the Python extension                                 and then in the main file we add the                                 Oise and time rust macro and then add a                                 trait and we're gonna add a render                                 method as part of that tree but we won't                                 add an implementation here where you                                 might expect it instead the web assembly                                 module is going to be that                                 implementation so the macro just wires                                 that up for us it also adds in other                                 methods on that trait like load file                                 which instantiates a web assembly module                                 from a file so in the main function                                 we'll call low file to instantiate the                                 module and then we'll call render and                                 something that's important to note here                                 the result is actually strongly typed so                                 it can be used exactly in the same way                                 as a natively compiled version of this                                 functionality so now let's use cargo to                                 run it and again it just works except                                 with a different environment using                                 different types now this might not seem                                 impressive since we compiled the                                 original version from rust but it would                                 work just as seamlessly even if this                                 were compiled from go receive plus plus                                 as long as                                 module was using interface types so                                 where else can we make this work I don't                                 have enough time to show you but it                                 already works in node and the web as                                 well through Watson behind Chen and                                 that's the same what Russ module                                 compiled to web assembly and we're using                                 it the same rich API and types to talk                                 to five wildly different runtimes and                                 languages and those are just a few                                 examples there's no reason this can't                                 work in other languages and other                                 runtimes many more of them so I hope                                 this helps illuminate the potential here                                 the potential for us to bring the many                                 things that have made it so impactful                                 the technical values and the social                                 values directly to the rest of the                                 programming world because that is a                                 possible future now and I know it's a                                 future that many of us would like to see                                 I want to thank the people who have been                                 working on this the folks they've been                                 working on the specification and a huge                                 thanks to the folks that worked on the                                 demo they did a tremendous job                                 incorporating web assembly into all of                                 these environments and they also are                                 very involved in all of the rust and web                                 assembly work so if you want to learn                                 more about how you can incorporate web                                 assembly into another language or                                 runtime they're definitely good people                                 to talk to I also want to thank my                                 fantastic collaborators till Schneider                                   and Luc Wagner for their invaluable                                 input on both the talk in the post                                 around this and thank you all for                                 listening                                 [Applause]                                 [Music]                                 you
YouTube URL: https://www.youtube.com/watch?v=VlIydW5Fojw


