Title: RustConf 2019 - The Rust 2018 Module System by Josh Triplett
Publication date: 2019-09-19
Playlist: RustConf 2019
Description: 
	RustConf 2019 - The Rust 2018 Module System by Josh Triplett

The Rust 2018 edition, as one of its flagship highlights, introduced a new module system, aimed to simplify the use of modules and crates for everyone. This talk will provide full documentation and exploration of the new module system, including motivations and mode of thinking, the practical impact of changes, and future enhancements in progress.

Whether you've had difficulties with modules in the past, or you're an experienced module user who wants to understand all the corners of the new system, come find out the present and future of modules in Rust!
Captions: 
	                              [Music]                               thanks for the introduction all right so                               yeah I'm gonna be telling you a little                               bit about the Russ                                                  but to build up to that I want to give a                               little bit of history about both myself                               and how I came to be giving this                               particular talk and what other types of                               things I want to be covering with it so                                I first got involved with rust a while                                before the first rust comp here in                                Portland three years ago and I gave a                                talk at that first rust conf called in                                order to form a more perfect union                                because I've been working on c-style                                unions for rust I work I got those                                contributed as part of an RFC so that I                                could support building virtual machines                                based on Linux and the dev KBM interface                                and this was something I was really                                excited about it did eventually get                                merged and released and there are now                                many virtual machines based on rust                                which I'm incredibly excited                                enthusiastic about but that talk was not                                just about a specific language feature                                that talk was also about how we build a                                more perfect rust through the RFC system                                it was a case study on the RFC process                                how we evolved rust and how we interact                                with the rust community I love the rest                                community it's incredibly fun incredibly                                energizing to work with it is the most                                fun open-source community I've ever                                worked with and as a result of that talk                                and other work that I've been doing I                                ended up getting involved with the rust                                language team and later the rust cargo                                team and from that perspective I'd like                                to tell you about the new module system                                that was developed for the rust                                     edition but as before that's not the                                only thing this talk is about it's                                really about how the language team works                                what the processes are behind the scenes                                what it's like to be in the room where                                it happens                                and the so I want to go into some more                                detail about how we iterate on a                                solution and how over a couple of years                                we managed to develop this module system                                starting from I think there's a problem                                here so not long after I got involved                                there was an effort called the                                ergonomics initiative that was aiming to                                try to provide further simplicity for                                the                                language as well as a measure of                                consistency how can we not just add                                things to the language but how do we                                improve what we have how do we simplify                                what we have and make it a lot more                                usable for people so in January                                        started having some interesting                                discussions about the module system one                                of the members of the language team made                                a blog post talking about the usability                                of the module system what problems they                                saw that kicked off a whole bunch of                                discussion many other people made posts                                and discussions and how to offline                                conversations and we started discussing                                well what do we use modules for what                                purpose should they serve and how do we                                want them to work so I want to give a                                little bit of overview of how Rus                                modules work and what style they form                                starting with the Rus                                                   so that I can contrast that a little bit                                so a bit of review for anyone who                                doesn't already know                                rust in rust terminology a module is one                                organizational unit of code often but                                not always corresponding to one source                                file in rust and a crate is a library or                                a group of modules that is used as a                                reusable library within the rust                                ecosystem so the other piece of                                terminology and syntax that I need to                                introduce if you haven't seen it before                                is that rust modules can correspond                                precisely to a file you can say mod                                example semicolon and you will get a                                module from example RS but you can also                                say mod example and then put curly                                braces and you can inline the contents                                of a module this is really useful if                                you're just using them as a local                                organization tool within a large file                                 they're also really useful if you're                                 trying to give examples on slides and                                 don't want to say this is part of this                                 file and this is part of this file so                                 with that in mind here's what normal use                                 of some rust dependencies look like this                                 is using the command line argument                                 parser clap in cargo Tamil which is this                                 is the only time I'll be showing this                                 part you add I want to use this version                                 of this crate it will automatically get                                 pulled in by cargo and then somewhere in                                 your main                                 or your main library you can say I have                                 this external crate named clap and I                                 want to use potentially this thing in it                                 without having to give the full path to                                 it then I could define a function that                                 uses pieces of it so I could reference                                 clap app or I can reference just argh                                 after I've said use clap argh so this is                                 the                                                                    it works when you're in the top level                                 module main dot RS or libbed RS                                 depending on if your program or a                                 library and most crates start with just                                 one module they start out building                                 things up from scratch they do some                                 interesting stuff they put it in main                                 they put it in Lib and everything works                                 nice and simple and the problem is that                                 paths for crates as among many other                                 things worked differently once you                                 created sub modules which made it harder                                 for people to introduce modularity into                                 their program they start building                                 something with a single module they add                                 more modules and suddenly they run                                 headlong into the brick wall of I didn't                                 know about this part of the language so                                 if I define a sub module say I want to                                 move argument parsing all off to                                 somewhere else in the program then use                                 looks the same I still use clap : : argh                                 but the usage suddenly I have to say : :                                 clap : : app if I want to reference it                                 if I try if I leave that out I get a                                 compile-time error saying well I don't                                 know what clap is even though you can                                 use clap you can't reference clap so                                 this was really confusing to a lot of                                 people and it was especially confusing                                 because you didn't hit it until you                                 introduced sub modules another problem                                 is that paths for sub modules themselves                                 also worked differently in sub modules                                 when you've organized your program                                 referencing pieces of that program from                                 other pieces of your program works                                 differently depending on where you're                                 doing it from so let's say I defined                                 this module this small module that                                 defines a few public structures s                                       s                                                                      and then I can name s                                                   I could use it as the type of Arg                                        can directly name something if I'm only                                 going to reference it once for example M                                 : : s                                                                   module                                 and I still reference arguments by                                 saying em : : s - in argh - here but                                 notice that I have to say self : : m : :                                 s                                                                probably going to stop sounding like an                                 English word so forgive me in advance                                 for you know your brain for the                                 following hour the the problem again                                 with this is this is unexpected you get                                 an error saying I don't know what M is                                 you stare at it you're like M is that                                 thing I just defined and told you about                                 you should understand this so these are                                 the types of inconsistencies that we saw                                 when saying why does the rust                                      module system work the way that it does                                 and these introduced big surprises when                                 you add modules to an existing one file                                 project there were also many other                                 improvements that we wanted to make out                                 of this system and I'll talk about some                                 of those later but I also want to take a                                 moment here and say this is again not                                 just to talk about how we wanted to fix                                 the module system this is also a talk                                 about development and consensus                                 processes and how we reached the                                 successful module system so let's look                                 at the requirements we have so far first                                 of all we said you really shouldn't have                                 to say extern crate it's a little                                 redundant when you look at that first                                 example you had define it in cargo tamil                                 ad extern crate and then use it or                                 reference it that's three places that                                 you have to name it well one of those is                                 actually using it and one of those is                                 saying where it's version is so those                                 are clearly required extern crate just                                 feels redundant in that regard                                 so we said you shouldn't have to do that                                 we also said that you should have the                                 same syntax in the top-level module and                                 in sub modules I should say I'm glossing                                 a little bit over the requirements here                                 of these are kind of what we eventually                                 figured out the requirements were but                                 this is about what we ended up at that                                 these were the most important things we                                 wanted the same syntax whether you were                                 in main dot RS or two levels down or                                 three levels down so this led to some                                 very extensive discussion in language                                 team meetings many times over we have                                 regular weekly video calls with all of                                 the members of the language team we had                                 discussions on the in rusty internals                                 forum which is a discourse instance we                                 had discussions on                                 Dischord the chat service and a number                                 of in-person discussions and pretty much                                 anywhere else we were talking about                                 things this was one of our top topics to                                 go through we also debated things like                                 should you have to reference external                                 crates especially with extern : : or                                 should you reference your own crate                                 specially we were trying to figure out                                 what is the unusual case and what is the                                 common case and we kept going back and                                 forth because it felt like if you're                                 going to be consistent about paths one                                 of these would have to be qualified                                 somehow and one of them wouldn't so this                                 resulted in a series of not one not two                                 but three separate RFC's trying to get                                 this right the first two were closed the                                 third one had eventually reached an                                 approach that we all had a rough                                 consensus on so the approach is what we                                 later came to call anchored use paths we                                 didn't name it at first for much the                                 same reason that rust                                             originally called rust                                                   to distinguish it from rust                                             eventually called it anchored use paths                                 and the idea was that use paths always                                 had to start with something that                                 reference to crate either a crate name                                 like clap : : or rayon : : or your own                                 current crate in which case they would                                 be crate : : or you could still use self                                 if you wanted to use relative names but                                 you didn't have to or you could use                                 super to reference the parent module                                 which was really common when writing                                 things like mod tests let me pull in                                 things from super in order to test them                                 so we finally had language team                                 consensus on this RFC                                                   clarity and that's exactly what it was                                 trying to provide is clear up a bunch of                                 the confusion around how do you                                 reference pads                                 it wasn't however not fully satisfying                                 exactly it had a fairly mixed community                                 reaction and there was something about                                 reading through it and dealing with it                                 that felt kind of okay this technically                                 meets all the requirements but so to                                 best sum up what we later realized the                                 issue with it was I want to use a post                                 that Aaron Turin used to describe the                                 module system as proposed he said these                                 situations meaning dealing with sub                                 modules are particularly bad                                 in rust                                                             without self : : a top-level module but                                 not elsewhere the rust                                                design helps by making the code not work                                 anywhere okay technically that's a                                 consistency uh it also would have                                 required changing most existing rust                                 code out there to change how it                                 referenced modules rust fix would have                                 potentially helped with this and it                                 would have been essential to have that                                 available but none of us were wildly                                 excited about what felt like it would be                                 the most invasive rust                                             please go change all your programs to                                 use this new module system so around                                 June ich of                                                            in those months Aaron and I had a                                 discussion on discord that amounted to                                 okay this is where we ended up this is                                 the consensus we had could we talk about                                 how we got there and why we couldn't                                 judge it was one of those like are we                                 really here is this really what we're                                 about to do kinds of conversations and                                 to look over it we talked about well                                 what are the additional requirements                                 would really love to have if we could                                 and what we said was that the new                                 requirements were we'd like to have                                 uniform paths between use and between                                 expressions so that the same path that                                 you can use anywhere in your program to                                 reference a module or a crate you could                                 always take that path and hoist it up to                                 a use declaration so if you can write a                                 : : b : : C you should always be able to                                 use a colon colon B colon colon C and                                 then just write C it's a very nice                                 property when you're used to like IDE                                 refactoring tools and similarly you feel                                 like this name should look the same as                                 this name and then I just shortened this                                 name so with that in mind we also wanted                                 something that was compatible with the                                 majority of rust                                                        said this addition should be an                                 opportunity to have new features and                                 exciting new things and not worry that                                 we are breaking things but at the same                                 time we shouldn't gratuitously break                                 everything if we can help it so the                                 concept here was one of uniform path                                 resolution the idea was you could check                                 a series of things and                                 whenever you name an identifier name a                                 path you would first check whatever was                                 in the local scope the whole while I                                 just told you what mod iam is then check                                 crates that you have available and check                                 the preload which is where we put things                                 that are automatically in scope that you                                 can always name like option and result                                 so here is some rust                                                                                                         we define those same two struts in a sub                                 sub module we can just use em : : sub s                                  and it works and we can also name em :                                 Co and s                                                               you're gonna use or in argument but we                                 can also do the same thing for crates we                                 can use clap : : argh that still looks                                 for a crate name in the previous                                 proposal this would have required                                 potentially naming it explicitly or you                                 would have needed something to reference                                 the previous case one or the other case                                 would have had to have been decorated                                 somehow to be unambiguous and you can                                 also reference crate names in                                 expressions like this clap : : app no                                 matter where you are in the program that                                 will always work if you have clap in use                                 so this does introduce a kind of search                                 ambiguity it's effectively saying well                                 I'm going to do the right thing when I                                 see a name like clap do you have a local                                 variable named clap or do you have a                                 crate named clap but it's only ambiguous                                 if a name in scope conflicts with an                                 extern crate name that's not a situation                                 that comes up that often it does happen                                 sometimes but there's a way to                                 disambiguate that and then in the end if                                 you have an ambiguous case I've got the                                 same name for a crate and a module in a                                 variable then I can disambiguate it I                                 can still write crate : : to reference                                 my own top-level names I can still use                                 self to reference my own module level                                 names or I can still use just leading :                                 : to say no really it's a an external                                 crate so by this time we had two                                 proposals on the table we had this                                 solution which you were calling uniform                                 paths and we had anchored use paths so                                 we had some discussion about how those                                 worked and the biggest thing we found                                 was that there was some                                 reluctance towards a new round of debate                                 on this we had gone through the better                                 part of a year and a half worth of                                 talking about this and we had found                                 something where everybody seemed more or                                 less happy with it it was not exactly                                 satisfying but it was kind of                                 satisficing it met all the requirements                                 and so people were not excited about the                                 idea of wait we're talking about this                                 again on top of that there was some very                                 reasonable technical considerations with                                 this new proposal that didn't apply to                                 the old one they amounted to don't                                 meddle with name resolution for his                                 subtle and quick to anger everybody who                                 had touched that area of the compiler                                 understood very well that it was very                                 subtle and when you messed with it it                                 would mostly work and then you'd have                                 corner cases after corner cases after                                 corner cases and so people were very                                 hesitant to adopt a solution that                                 effectively said well if we just made                                 the compiler smarter and finally there                                 were actually some meaningful                                 differences in the core values and                                 preferences among members of the                                 language team I don't want to suggest                                 that this was a case of oh this solution                                 was obviously better and it just had                                 technical limitations and maybe we                                 didn't want to reopen old wounds there                                 are meaningful differences here not                                 everybody is happy with the idea of                                 let's figure out in a well-defined order                                 how to handle ambiguity where this might                                 mean this or it might mean that the                                 thought was well the compiler can do                                 that what if the programmer wants to be                                 able to do that and say I want to know                                 looking at a path what it is                                 unambiguously all the time and that was                                 a reasonable request and it was a                                 different request it was a different set                                 of goals different set of values where                                 they were saying well why are we                                 optimizing for writing code maybe we                                 should be optimizing for a reading code                                 and that's a reasonable statement and                                 people disagreed on how to implement                                 that so all that by way of saying this                                 was one of our and the language team one                                 of our first major heavy ideological                                 differences heavy bits of this is really                                 kind of stressful to debate over how do                                 we reach a consensus it seems like we're                                 deadlocked that kind of thing there have                                 been                                 in the past if anybody wants to look at                                 the history of the question mark                                 operator there's a long and storied                                 history there and that one was also                                 heavily like community consensus and                                 whether everybody was in favor of it but                                 this was one of the first ones where the                                 language team itself was heavily divided                                 and debating and trying to figure out                                 what is the best answer for rust and the                                 community so as part of moving forward                                 on this we first of all tried to make                                 sure well can we actually do this and so                                 I've got credits at the end in detail                                 but a couple of folks sat down and                                 actually wrote a prototype                                 implementation of this they said yes we                                 can do this here's how it works try it                                 out experiment with it see how it feels                                 so there was a successful technical                                 implementation of the new proposal which                                 then meant hey you can sit there on play                                 and play in nightly and figure out what                                 we want it to look like we went ahead                                 and tried it out on nightly and said                                 let's see how these implementations work                                 because the critical point is which one                                 do we choose to stabilize we looked for                                 feedback from the community there were                                 several polls but more importantly not                                 just numeric and quantitative questions                                 but more what do people think what are                                 other people's values what are other                                 people's arguments for it it's not                                 helpful to have                                                         like this and                                                            it's extremely helpful to have four                                 people say here's why I prefer this                                 alternative or here's why my code would                                 look better with this alternative that                                 kind of thing as more of a qualitative                                 helped me understand what your                                 preferences are that's the kind of thing                                 that was extremely helpful to see when                                 we're trying to figure out what                                 arguments aren't we seeing what balance                                 aren't we seeing beyond that we found                                 that we were doing a lot of careful                                 discussion and introspection on what                                 these core values that we had are that                                 there's an argument or tactic where you                                 can say all right let's step back for a                                 moment let's both figure out what our                                 values are that are causing us to get                                 very attached to what our solution is                                 let's figure out what the other person's                                 values are well enough that we can                                 explain it back to them and they're like                                 yeah that's what we believe                                 and if you can't get at least that far                                 then you're not going to be able to have                                 a good clear discussion about it you're                                 just disagreeing and so we had a lot of                                 very careful conversations like that                                 where we wrote up documents we wrote up                                 a Dropbox paper document where everyone                                 wrote separately what their views were                                 but then went through everyone else's                                 and we discussed what those were and                                 trying to understand where work where                                 each other are coming from and that                                 helped hugely so in the meantime we went                                 ahead and released                                                    with a compromise solution we said okay                                 these two are actually very similar and                                 the main issue they have is when you                                 have ambiguity one of them would say you                                 must disambiguate it like this and the                                 other would say here's how we resolve it                                 so we effectively made that an error and                                 said you can't hit the case where these                                 two systems differ you have to use                                 something that's compatible with both                                 and that allowed us to defer a little                                 bit longer figuring out what the correct                                 answer was it's again not wildly                                 satisfying but it's worth noting that                                 even critically important and very heavy                                 features like this still wait for the                                 next train if they're not ready in time                                 there is no pass for oh you're on the                                 language team so we'll sneak something                                 in in time we very much said let's wait                                 a release we're not ready to make this                                 call yet so I mentioned we                                 collaboratively wrote a document about                                 both alternatives we explored down both                                 paths very extensively had some very                                 excellent discussions where people it is                                 incredibly rare to see people genuinely                                 change their mind on something that they                                 felt very strongly about and it was an                                 impressive sight to see on several                                 counts so we ended up making the                                 decision shortly thereafter and we                                 finished up the uniform pads                                 implementation in                                              discussion had wrapped up in that form                                 but it's worth noting that one of the                                 reasons I'm giving this talk is that                                 because it was iterating so quickly                                 because it was going through all of                                 these decision processes the final                                 version of this implementation is not                                 exactly what was documented in the                                 original RFC for path clarity                                 and the new version of what was                                 implemented was effectively defined by                                 the compiler for                                                     written documentation and then we went                                 back and wrote some more of the                                 documentation later and so part of the                                 point of this talk was to say here's how                                 we got there and here's what we ended up                                 with so I want to go through a few more                                 of the technical details that I had                                 skipped past earlier to make sure that I                                 would go all through all of the                                 decision-making process and values so                                 with that in mind some of the other                                 items that we looked at were how to                                 handle macros this was actually handled                                 through a somewhat separate process in                                 separate RFC's but it was part of the                                 same unifying theory for a module system                                 in rust                                                               way to export and then use macros so if                                 you want to use one of these macros like                                 crate name or crate authors from Clapp                                 then you use macro use extern crate clap                                 which will import effectively import                                 star from clap if it's a macro and then                                 all of those macros are just directly in                                 scope and you use them unqualified                                 there's no way to qualify them there's                                 no way to limit which ones you grab and                                 so this is what you ended up with this                                 is the only way you can pull in and be                                 modular about macros in rust                                          can actually use a macro exactly like                                 any other name if you're using it from                                 an external crate there's some corner                                 cases that I won't go into involving                                 local modules in your own crate and                                 we're hoping to fix those someday but in                                 the meantime you could just use clap                                 colon colon crate name and then use                                 crate name as a macro just like crate                                 name was any other kind of name you                                 could also just reference a macro with a                                 scoped name in case you didn't want to                                 pull it in by name you just wanted to                                 use it where it was so macro pads now                                 work more or less like function pads and                                 again unification and simplification we                                 added something new to the language but                                 we did so in a way to make the language                                 as orthogonal as possible so that it                                 worked the same way and you didn't need                                 to learn the rule for functions and then                                 the learn the rule for macros just like                                 you didn't have to learn the rule for                                 use statements and then the rule for                                 expressions the                                 couple other changes you can now have                                 food RS and a sub-module foo slash bar                                 RS you no longer have to write foo slash                                 mod RS mod RS was similar to dunder and                                 net dot pie if you're familiar with that                                 in Python or otherwise this is the                                 module that represents the parent module                                 previously there were some ambiguities                                 here and you had to always use mod dot                                 RS if you had sub modules which meant                                 with you want to add a sub-module you                                 have to move food RS and people also                                 observed that if you had an open in an                                 editor you'd have a lot of files named                                 mod RS and you'd have to see where they                                 were so this is a little cleanup that is                                 just quality of life improvements one                                 other item was we started seeing well                                 why else are people using X turn crate                                 we wanted to deal with macros so we                                 needed a way to substitute for macro use                                 we also needed to deal with crate                                 renaming people could do extern crate                                 foo as bar and then reference the crate                                 as bar everywhere else so we ended up                                 with a new feature in cargo that allowed                                 you to say hey I'm using the crate bar                                 but I'm sorry I'm using the name bar but                                 it's really the package named foo so go                                 get the package foo with this version                                 and then name it bar in my program                                 throughout so this was the replacement                                 for extern crate foo as bar and that was                                 kind of the last you have to use                                 external a                                 if you're using no standard or no core                                 then there are some cases where you need                                 to reference standard or core with                                 extern crate but because those are a lot                                 less common those didn't get addressed                                 quite yet but this effectively meant the                                 normal most normal programs did not need                                 to use extra and crate so a few other                                 bits of future work that come from the                                 nature of let's pull things out and do                                 the minimal step that we can in order to                                 bypass controversy and avoid bundling                                    different things into an amalgam that                                 will never pass we talked about what                                 passo possible future work were a lot of                                 people really don't like having to write                                 mod statements writing mod example in                                 order to kind of mount example dot RS                                 into the names                                 face and so there was a lot of                                 discussion that you could implicitly                                 assume mod example whenever you had an                                 example RS there are some corner cases                                 here there are issues like well what if                                 I had a local temporary file I was                                 playing with and I don't want it to be                                 compiled that kind of thing so this was                                 separated out due to controversy but                                 there's still interest in revisiting it                                 at some point in the future when there                                 is the appetite to look at the module                                 system again the other was that you're                                 from you're probably familiar with the                                 pub visibility and this is exported I'm                                 allowed to use it from outside the                                 module or crate as well as anything you                                 don't mark as probably as private the                                 one that people don't often know about                                 is you can write pub parenthesis crate                                 and this is effectively protected inside                                 my crate but and outside the module you                                 can use this but I can't use it outside                                 the crate so there was a proposal to                                 make this easier to use by defining a                                 new visibility named crate rather than                                 pub crate you could just write crate                                 you're saying instead of a pub type this                                 is a crate type so it had a kind of                                 logical flow to it it was separated out                                 due to a bunch of dude primarily to one                                 corner case that we'd seen where it's a                                 little ambiguous and we weren't very                                 satisfied making the call there were                                 some other reasons as well but the                                 biggest one was this if I write a struct                                 a parentheses tuple struct that has                                 crate colon colon T does that mean the                                 type T that is at the top level of my                                 crate where crate is a scope or does                                 that mean a type colon colon T that is                                 named elsewhere that has visibility                                 crate so this was a delightful little                                 ambiguity that resolving this would have                                 required either defining one or the                                 other to be what happens or having a                                 rule that says you must disambiguate and                                 we won't allow either one of them but                                 again there is still interest in                                 simplifying the use of the pub crate                                 visibility and so what form that will                                 take in the future I don't know so I                                 wanted to take this time to kind of                                 reflect on difficult decisions this was                                 one of the first major ideological                                 disagree                                 so we had to work our way through but                                 they're going to be and have been many                                 more overtime I'm going to very briefly                                 mention async/await for example where                                 there was a lot of controversy on what                                 the right syntax was many many people                                 said we definitely need this feature we                                 need to settle on some syntax for this                                 feature there were in fact almost three                                 camps here of people who wanted prefix                                 people who wanted postfix and people who                                 want something real soon now please and                                 I'm not joking those were the three                                 camps and so there was a lot of                                 discussion about this it did finally get                                 stabilized for                                                          last few days in fact so that is awesome                                 I'm so glad to see yesterday people                                 actively using the new async/await                                 syntax from nightly in a training class                                 about async/await so that's incredibly                                 exciting but again this is the kind of                                 thing that took a lot of discussion a                                 lot of very careful working through of                                 well what is it about this in text you                                 let you like what is it about the syntax                                 that you like everybody's trying to                                 build a good language nobody's trying to                                 sabotage a language and remembering that                                 and moving forward and saying how do we                                 get to the best solution ended up                                 allowing us to reach something that                                 everybody was either thrilled with happy                                 with or could otherwise live with moving                                 forward with without causing any of the                                 problems that people were concerned                                 about with other syntaxes so I want to                                 sum this up with a few different points                                 first of all I would encourage people to                                 beware of satisficing solutions cases                                 where yes you've technically met all the                                 requirements you've technically done                                 everything you need to do but nobody's                                 really happy with it and so when this                                 happens sometimes it really is something                                 where you're balancing so many                                 conflicting values you just cannot make                                 everybody happy at the same time there                                 was a degree to which the module system                                 was in that state and then we ended up                                 coming up with a new solution that made                                 the vast majority of people much happier                                 than anything we'd seen yet so far so a                                 satisficing solution might be a sign                                 that you need to look more closely for                                 other potential                                 Avenues another is to raise issues very                                 early no matter how much you declare                                 something as interim or experimental                                 people will get attached to it some                                 people got attached to a weight bang the                                 macro like syntax and said oh I thought                                 that was what we were stabilizing and                                 the same thing goes for a lot for many                                 other cases where once you've gotten                                 something down the path - it looks like                                 this is what I can use in nightly then                                 people will get attached to it                                 I always introspect on what values your                                 opinion is based on if you have                                 disagreements and it's worth going one                                 level lower and saying what is it that                                 makes you attached to this what is it                                 that makes it important to you why do                                 you consider this solution bad and can                                 you define what bad means and that                                 includes your own values which this is a                                 challenging thing to do to realize okay                                 I feel really strongly about this why do                                 I feel really strongly about this can I                                 explain that to somebody who's not                                 inside my head                                 then once you know what those values are                                 you can turn it even a disagreement into                                 a collaboration of saying all right                                 let's look at those values how best can                                 we satisfy those values do we all agree                                 what those values are and can we find a                                 common shared set that we can satisfy                                 all of and in general I would encourage                                 people to seek satisfying rather than                                 satisficing solutions were ever even                                 remotely possible so I want to end with                                 a couple of acknowledgments Aaron on the                                 language team formerly on the language                                 team has been incredibly helpful in                                 formulating a lot of these ideas he                                 wrote several really good blog posts on                                 consensus and decision-making                                 Eddie B Kramer TJ and Petra chenkov as                                 well as a host of other people were                                 critical in making the new module system                                 work getting it implemented debugging at                                 all sorts of other issues that I am                                 probably forgetting some people as well                                 as the entire rust language team which                                 has been extraordinary to work with and                                 again the incredible rest community so                                 with that thank you I'm available by                                 email and on Twitter and it's been                                 wonderful talking to you                                 [Applause]                                 [Music]
YouTube URL: https://www.youtube.com/watch?v=_PEDY0E1qaQ


