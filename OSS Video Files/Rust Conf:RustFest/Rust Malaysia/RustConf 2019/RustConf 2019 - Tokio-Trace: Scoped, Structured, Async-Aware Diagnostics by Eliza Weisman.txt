Title: RustConf 2019 - Tokio-Trace: Scoped, Structured, Async-Aware Diagnostics by Eliza Weisman
Publication date: 2019-09-19
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Tokio-Trace: Scoped, Structured, Async-Aware Diagnostics by Eliza Weisman

tokio-trace is a new set of Rust libraries that provide primitives for recording scoped, structured, and async-aware diagnostics. Unlike traditional logging, tokio-trace emits structured diagnostics that model the contextual and causal relationships between between events. tokio-trace was designed by the tokio project to solve problems with logging in asynchronous applications, but may be used in any Rust codebase. This talk presents the motivation and influences behind tokio-trace, introduces its core concepts, and demonstrates how it can be used.
Captions: 
	                              [Music]                               hello Russ Kahn                               how are we feeling tonight okay so I                               have a couple of Corrections that I need                               to make before we can continue some of                               you may have seen on the program that it                               says that this talk is about Tokyo Trace                               that's a lot this talk is not about                               Tokyo Trace we've renamed the library                                it's called tracing now it dis happened                                after the light conference materials and                                the the programs and stuff were printed                                so here's your here's my first                                announcement of this it's it's not                                called tokyo trice anymore also it may                                upset in my speaker bio that i have two                                awful cats I regret my statement I only                                have one awful cat I have two cats but                                only one of them is awful and I hope all                                of you got the joke with the title music                                right that this talk is about logging                                and that was Kenny logging shout out to                                Adam filter who made that fun first so                                this is a talk about tracing not tokyo                                trace tracing is a set of libraries that                                provide a framework for adding scoped                                structured and async aware diagnostics                                to rust programs so most of you are                                probably wondering why am i the most                                important logging thought leader right                                so my name is Eliza Wiseman I'm a system                                software engineer at a company called                                buoyant in San Francisco we make linker                                D the surface mesh for cloud native                                applications I've been writing rust for                                since                                                                   remember how long I've been writing rust                                since                                                        professionally for over two years and I                                am a core contributor to the Tokyo Tower                                and linker D to open source projects                                some of you have probably also seen my                                Twitter where I make bad programming                                jokes and post pictures of my cats cool                                so I guess the question really is why                                did I make another logging library right                                we already have a pretty robust                                ecosystem in rust around logging there's                                the log crate there's n vlogger and fern                                and so on                                so this is supposed to make my slide go                                oh there we go                                okay so right I I first of all I don't                                like to call it logging I like to call                                it GNU slash logging cool okay so I in                                my speaker notes it says like pause for                                laughter and so I I'm really glad that                                there was laughter yeah so that was a                                joke but I I don't like to call it                                logging I like to call it in process                                tracing and this is like a big very                                buzzword sounding name but we're gonna                                talk a little bit more later about what                                that actually means                                but to talk about the motivations for                                why I made another not vlogging library                                I have to ask some questions to the                                audience how many of you are using                                futures or now async/await show of hands                                okay that's a respectable number and are                                you like logging in those futures at all                                and does this make sense                                like you get something out of this                                that's readable any of you not really                                okay cool that's about what I thought a                                sync is hard there's supposed to be a                                posture laughter here but I guess you                                guys are just like so sad about this                                that but if you're writing any kind of                                like high-performance Network                                application or network library you need                                to use some kind of asynchronous                                programming if um but it presents some                                really unique challenges for Diagnostics                                especially when we're executing                                asynchronously the execution of the                                program is multiplex to cross different                                tasks and when they require something                                from input/output or they require                                something from another task instead of                                blocking the thread those tasks yield                                right and then we start executing                                another task and this is really good                                because it lets us like use all of our                                CPU time saturate the Nick whatever the                                bottleneck is but the problem is that                                because of this we can no longer really                                rely on events happening in order if we                                if we're logging in these asynchronous                                 tasks those log messages come out                                 interleaved or we see different contexts                                 all logging information that might be                                 very similar and we can easily trace                                 what's going on                                 between those log records by looking at                                 the order in which they were displayed                                 so how do we get good usable Diagnostics                                 from asynchronous systems I'm going to                                 touch on three what I see is the big                                 pillars that we require if we want to                                 have like Diagnostics                                 in asynchronous systems that make sense                                 we need to capture context causality and                                 we want some form of structure so                                 context when we record that some event                                 has occurred we don't just need to know                                 where it happened in the source code                                 which our existing logging tools are                                 very good at so they have like                                 information about line numbers modules                                 files and that's all great but it                                 doesn't really tell us the runtime                                 context in which some event that was                                 recorded occurred in so for example if                                 we have some HTTP server that's                                 processing requests that context might                                 include things like what client did this                                 request come from                                 what were their requests HTTP method                                 what was its path                                 what were the headers on that request                                 and in synchronous code so not async we                                 can infer that context by looking at log                                 messages in order right if we see                                 excepted request from this IP and then                                 parsed a request with these headers                                 after each other then we know oh this is                                 the IP that sent their request but in                                 async code where we're switching between                                 these multiplex tasks based on readiness                                 of i/o and other resources we switch                                 between those contacts very rapidly and                                 we can't really rely on the ordering of                                 log messages to determine context second                                 we care about causality                                 there's complex chains of cause and                                 effect in these asynchronous systems if                                 I have some tasks that are running in                                 the background like a DNS lookup or a                                 database connection or something what                                 caused them to start what caused those                                 tasks to perform certain work and so on                                 we can't rely on log ordering to                                 determine this kind of causality either                                 so we need to record it explicitly                                 finally it's helpful to have structured                                 Diagnostics                                 traditional logging is based on human                                 readable textual messages                                 we prefer Diagnostics though that are                                 machine-readable so that we can interact                                 with them programmatically sure you can                                 increment you can programmatically                                 interact with unstructured logs if you                                 use AA core grap but it's not good you                                 know if anyone uses tracing after this                                 talk and you ever have to grep through a                                 log again you can come to my house and                                 tell me this I will give you $                                           record type data as type values and you                                 can interact with that as type data so                                 tracing tracing is a framework for                                 instrumenting rust programs with                                 contextual causal and structured                                 Diagnostics as I said before it used to                                 be called Tokyo trace but it's not                                 called that anymore tracing is part of                                 the Tokyo project so it's maintained by                                 the people who brought you to Tokyo it                                 doesn't require the Tokyo runtime so you                                 can use it in synchronous programs you                                 can use tracing in asynchronous programs                                 that are using Tokyo you can use in an                                 asynchronous programs that are using                                 other runtimes you can use it in Waze                                 improbably you can use it on on bare                                 metal with no standard with some caveats                                 you know ask me after class if this                                 matters to you so I'm going to take a                                 minute here and I'm going to switch                                 gears so we're gonna look at a very                                 quick demo okay so                                 and in this demo I am running a web                                 server and this web server implements an                                 endpoint where you send HTTP requests                                 where the path of those requests is a                                 single ASCII character and then we                                 implement something called character                                 duplication as a service we send you a                                 response where the body of that response                                 is that character duplicated a number of                                 times equal to the received content                                 length header so you know this is like                                 very important that like because                                 web-scale like we have to do this as a                                 micro service and and this is absolutely                                 mission-critical right so but we happen                                 to know that we're experiencing an                                 elevated error rate in this service and                                 so we're looking at these logs and as                                 you see it's logging everything that's                                 happening and this is scrolling really                                 fast it's really hard to actually figure                                 out what's going on here even though                                 we're recording all of this information                                 so we have very rich verbose Diagnostics                                 um the example server is hooked up to a                                 load generator that's just like feeding                                 requests into it and sometimes those                                 requests are failing so we're gonna                                 figure out why those requests are                                 failing something we can do is that the                                 example server I've added a little admin                                 endpoint where you can you can send a                                 post request and you can set a new                                 filter that's used to reconfigure what                                 tracing events are recorded so what we                                 can do is we can start out by curl dash                                 D and if you're familiar with the end                                 vlogger crate you might recognize this                                 syntax we're gonna look at the lo                                 generator only                                 okay so we've dynamically reconfigured                                 our Diagnostics so we're only looking at                                 the load generator and here we see that                                 the contexts in which these events are                                 occurring it's being recorded with data                                 about the request in which these errors                                 are occurring so we have our four                                 hundred errors                                 therefore oh fours and we have our                                     errors looking at the                                                  there's this request path field and for                                 the                                                                                                                                       determine that okay the                                                 the spec for this example app is that                                 you send a path with the single ASCII                                 character the load generators failing to                                 do that so the server is returning at                                                                                                          are worrying so we want to look at the                                 Diagnostics from the server to figure                                 out what's causing those                                                cool thing that we can do that you can't                                 do with traditional unstructured logging                                 is that if we go back to curl and we                                 send a new request and this request that                                 we're gonna send it's going to be a                                 little fancier so this syntax is a                                 superset of n vlogers filtering syntax                                 right where you have these pairs of log                                 targets and then verbosity levels I                                 don't call them log levels because this                                 isn't logging right so we're gonna                                 introduce some new syntax now we have                                 these square brackets and the square                                 brackets indicate that we want to filter                                 on a dynamic context this is one of the                                 things that you have to do when you're                                 adding a superset of an existing syntax                                 is you have to add weird characters to                                 it                                 there's an entire programming language                                 that's called Objective C                                 yeah so all right so we're going to set                                 this new filter and the filter we're                                 gonna set is we care about field values                                 so these structured data on the span                                 context in which events are occurring                                 and that's what the curly braces mean we                                 care about a field and its value and                                 specifically what we want is the field                                 req or for request dot path and we want                                 it to have the value /z and you'll see i                                 have to escape the quotes here because                                 my terminal but all I'm saying here is I                                 want to see any requests whose path was                                 Z I want to see the context where that                                 event is being handled but I want to see                                 all the Diagnostics in that context so I                                 send that request look at that so we can                                 now we're now seeing the entire life                                 span of these requests right we see                                 where the server is receiving the                                 request we see the headers there then we                                 see that we're handling the request with                                 a handler and then we see this error                                 that's being logged at a very high                                 verbosity level that I don't like this                                 letter and we're replying with the                                     okay so we found the bug it's not it's                                 not a good bug I put it there on purpose                                 but you see here how we can trace the                                 entire lifespan of this request and we                                 can only look at requests that match                                 this filter and even though this server                                 is under really high load and lots of                                 other stuff is going on here we've cut                                 out all of them noise and we're looking                                 only at these contexts that we care                                 about so that's a demo of the power of                                 what we can do with this kind of                                 structured diagnostics I am going to go                                 back now to my slides is this are we                                 looking at the right slides okay and                                 demo all right so how does this tracing                                 thing how does it actually work right                                 you saw a cool demo everyone was wowed                                 weed and odd how do we do this what's                                 actually happening here what did I mean                                 when I                                 in process tracing are any of you                                 familiar with distributed tracing                                 technologies like open tracing open                                 telemetry Zipkin Jaeger so these are                                 diagnostic tools for distributed systems                                 since I only see a couple of hands I'm                                 gonna just explain very briefly these                                 tools are for diagnosing distributed                                 systems they are designed to allow you                                 to track contexts as they move between                                 nodes in a distributed system so you                                 have requests to one server that cause                                 requests to another server and the way                                 this works is we propagate some headers                                 and those headers have an identifier                                 that identifies a context called a span                                 and the insight behind the tracing crate                                 not tracing the concept sorry it's a                                 dictionary word I know that we can have                                 collisions with these is that                                 asynchronous programs are kind of                                 analogous to distributed systems writ                                 small right an asynchronous application                                 in rust has concurrently running tasks                                 that are communicating through message                                 passing message passing is asynchronous                                 it's fallible so it's a really thin                                 network I mean the network is worse                                 right it's even more asynchronous and                                 it's even more fallible but it's a                                 similar concept the only difference is                                 that now everything is running in the                                 same address space so we can apply the                                 same ideas that we use for tracing in                                 distributed systems to tracing an                                 asynchronous systems running in a single                                 process so we introduced some core                                 primitives in tracing and our core                                 parameters are called spans and events                                 water spans a span represents a period                                 of time in the execution of a program it                                 has a time when it starts and a time                                 when it ends so it's the time period                                 between those two points spans also can                                 be entered and exited in tracing                                 independently from being created and                                 ending and we can enter and exit them                                 multiple times                                 this is how we track the asynchronous                                 execution that moves between tasks                                 context and a task might be executed                                 within that context for a period of time                                 and we yield we execute some other tasks                                 we yield we execute some other tasks                                 right and over the lifetime of a task it                                 might be entered multiple times so we                                 can record both how long the task                                 existed for and how long it was being                                 actively driven or executed we also can                                 separate between just the existence of                                 this thing and when we're in the context                                 of that work right then here's how we                                 make a span we have the span macro you                                 get back this span object and here we're                                 creating a span called migrate span then                                 we have an enter method on the span                                 object and that gives you back an ra íí-                                 guard so you can scope the entry of a                                 span to a stack frame or inside of a                                 scope in a function and as long as you                                 hold this guard you are considered to be                                 executing inside this span when you drop                                 the guard you exit the span right we                                 also have kind of a fun tool which is                                 this instrument procedural macro it's an                                 attribute that you can put on a function                                 and when you call that function you                                 create a span for that function and it                                 records all of the arguments to the                                 function and it works on async functions                                 and so async functions do sugar right to                                 a future that's driven when you await                                 the the return type from the async                                 function and so that returned future is                                 instrumented so that when we pull that                                 future we enter that span when we stop                                 pulling the future we exit the span and                                 that span can persist as long as the                                 future that is returned by the async                                 function consists or exists then we have                                 a concept of events events are singular                                 moments in time and they're basically                                 just it's a log record but it's more                                 structured than a log record we can add                                 these structured fields to them their                                 key value pairs and tracing subscribers                                 can consume these pairs as a subtype of                                 rough or a subset of rusts primitives so                                 there are some primitives that we know                                 about like strings integers and so on                                 and you can interact with them as those                                 types instead of as oh it's a string                                 cool I have a                                 big string with a bunch of like stuff in                                 it great I can't deal with that you need                                 grip right so you don't need grip                                 because we have structured fields and of                                 type values and then we have this                                 component called a subscriber a                                 subscriber is the interface for a                                 component that collects trace data it's                                 basically like a logger right but you                                 know in the log crate there's a log                                 trait and the log trade has like two                                 methods on it subscriber has a few more                                 methods because it does a lot more than                                 a logger but it's the same thing in that                                 it's the main extension point for                                 tracing and it actually collects the                                 data that's emitted so libraries can                                 provide subscriber implementations that                                 do all kinds of different stuff like                                 recording metrics printing logs to                                 standard out whatever so how do we                                 actually use this thing right I'm gonna                                 work through a little example this                                 example is drawn from a very important                                 domain which is yak shaving some of you                                 may have seen the version of this talk                                 that I gave it a Russ meet-up in San                                 Francisco where I had a slide much like                                 this one I've since been informed I told                                 you I had a few corrections to make I've                                 since been informed that the animal on                                 that slide was a yak or was not a yak it                                 was a cow Google images mislead me this                                 animal is the yak I have it on good                                 authority so I take feedback from anyone                                 in the audience and somebody told me                                 this is not a yak so I fixed it here's a                                 real yet so we're shaving some yaks                                 right looping over some yaks and shaving                                 them but let's say we're shaving those                                 yaks                                 asynchronously right so this shaved yak                                 function is asynchronous it's returning                                 a future it could be an async FN or it                                 could just be a function that returns a                                 future it doesn't really matter so we're                                 looping over these yaks we're spawning a                                 task to shave that yak so we create this                                 span called Shaving yaks this is where                                 we're gonna do all of the work of                                 Shaving these yaks we can annotate it                                 with whatever contextual information we                                 want like say number of you actually                                 were shaving and then we enter that span                                 that indicates we're executing in the                                 context of shaving these yaks and we                                 have this enter guard that keeps us in                                 the span                                 and then we loop over the ax you know                                 okay                                 so then every time we iterate that loop                                 for a new yak we can create a span again                                 it's called shave here and it records                                 the current yak and the shaving span is                                 a child of this span where we're shaving                                 all the acts so it inherits that context                                 so this span inherits the yak count from                                 its parent and it adds the span that's                                 the app that's currently being shaved so                                 we have this instrument Combinator this                                 attaches a span to a future so whenever                                 we pull this future that's shaving the                                 Yak we entered that span when we                                 finished pulling it we exit right and we                                 can also put that on a sync blocks so                                 here now we're also recording an event                                 after we finished shaving the Yak we                                 call shaved yak we await the result we                                 debug is logging in the debug level do                                 we shape that yak turn okay we spawn                                 this async block and the instrumented                                 with the span we're reshaping that yeah                                 so again this debug message inherits the                                 Yak that we're shaving the current yak                                 and it inherits yeah count and so on we                                 have this tree of scopes in our program                                 to represent the context in which we're                                 executing finally okay so we can like                                 match on that and we have either an                                 error or we don't have an error we                                 record that there was an error or we                                 record that there wasn't an error and                                 we're recording this error as a                                 structured value so actually as an                                 instance of the standard error error                                 type in the standard library so we're                                 not just printing it or formatting it to                                 a string the tracing subscriber can                                 actually go oh this is an error it's a                                 like dine error we can downcast it we                                 can look at its source we can you format                                 it with debug we can format it with                                 display when the standard library adds                                 back traces to errors we can look at its                                 back trace so on and so forth right it's                                 actually a typed object it's a rust                                 struct or a rust raid object that we can                                 interact with again we don't need to                                 record anything about like what yak are                                 we saving how many acts are we saving in                                 these individual events because they                                 inherit that from the span context in                                 which they occur great so it also works                                 very nicely with the log crate one way                                 in which it works nicely is that our                                 macros are a superset of the log crates                                 macros so if this compiles right here                                 I'm using log and then I'm logging if I                                 want to switch to tracing in my my                                 application right                                 oh sorry do you see the difference use                                 log use tracing same syntax we have                                 other syntax for doing more things like                                 creating these structured fields that                                 log only just now has a concept of but                                 it's macros don't I'll get into that                                 later but you get you have a super set                                 of log syntax so if you want to migrate                                 you can just drop in tracing and then                                 you can go back and add more structured                                 information more spans whatever but it's                                 very easy to adopt and then you can                                 incrementally roll it out we also have                                 adapters they let you record log records                                 as tracing events and tracing events as                                 log records so if you have a dependency                                 that emits log records you can record                                 them as tracing events that are within                                 that span hierarchy even though the                                 dependency doesn't know about tracing                                 similarly if you have a library that                                 many people depend on some of them are                                 using tracing some we're using log we                                 have a feature that when you enable it                                 all of the tracing macros also emit log                                 records so your users who depend on log                                 records being there will still have                                 their log records finally any runtime                                 instrumentation has performance costs                                 right you were doing something to record                                 this data that you otherwise would not                                 be doing you can't get away from that                                 there's no such thing as a free lunch                                 but tracings goal is to ensure that you                                 only pay for what you eat when you know                                 there is it's not a free lunch but you                                 you don't have to pay for the whole                                 lunch you just pay for the parts that                                 you want                                 we have tried really really hard to                                 design these api's to ensure that there                                 are no costs that you pay that you're                                 not actually using so what does that                                 mean first of all we when any                                 instrumentation is disabled like the                                 filtering that we were doing in the demo                                 we've made sure that is basically free                                 to                                 that there's like one atomic load and a                                 branch so it's not free free but it's                                 close it's about the same cost to                                 skipping and disabled log line in the                                 log crate we cache the evaluation of                                 filters so that if you have like a regex                                 that determines if something is enabled                                 you don't have to like run the regex                                 over and over and over for the same                                 thing so we've optimized this a lot                                 we've also designed the subscriber API                                 to ensure that you don't pay cost by                                 default so depending on the use case a                                 subscriber that's recording trace events                                 might do a lot of different things if                                 you're doing time profiling and there's                                 a crate that does time profiling on top                                 of tracing you need to make sis calls to                                 get timestamps if you're logging with                                 timestamps you need to make sis calls to                                 get timestamps but if you don't need                                 those timestamps you don't need to make                                 that Cisco write to get that timestamp                                 if you want to track persistent data you                                 have to allocate but if you don't need                                 that persistent data you don't have to                                 allocate right and so tracing doesn't do                                 any of those things the subscriber can                                 make the Syst calls the subscriber can                                 allocate the storage if it needs to for                                 the specific behavior that it implements                                 tracing itself will never do those                                 things finally it's worth noting that                                 we're really trying to bootstrap a whole                                 ecosystem of libraries here they're the                                 core crates there's tracing core and                                 tracing which are like the facade layer                                 that you actually depend on that makes                                 everything work but on top of that we                                 have to actually implement these                                 subscribers that have different                                 behaviors for example we have a tracing                                 format crate which is what I was using                                 in the demo and it implements logging                                 trace events to the console but there's                                 all kinds of other things you can do                                 like metrics or with time profiling john                                 geng set has a tracing timing crate that                                 allows you to do like histograms of how                                 long a span takes to execute which i                                 think is very cool but there's a lot of                                 other really neat stuff we can build to                                 consume this unified layer of                                 instrumentation to output any kind of                                 diagnostics that we want and there's a                                 lot of stuff we can build using this and                                 i think i probably have only thought of                                 like                                 any amount of it so I'd really like to                                 see what everyone else can come up with                                 so here's how you can get involved it's                                 on crates do all of the core crates are                                 and we have a github repository in the                                 Tokyo organization that has all of the                                 like core tracing and you know we also                                 have a discussion group on git er and so                                 on and so forth                                 so please if you're interested open a                                 pull request or an issue if there's                                 something you want to see I love to get                                 issues                                 I love feature requests and if anyone                                 actually wants to write those features                                 they can do that too that would be great                                 but so please check it out try it out                                 and we would love to hear from you                                 here's some links if you have any                                 questions reach out to me after class                                 here's my email address on my Twitter                                 and you can get the slides from my                                 website or I think they're on the rest                                 conf website so you don't have to like                                 keep taking pictures like I see people                                 keep doing this is the only slide you                                 need to take a picture of I should have                                 told you that at the beginning there's a                                 blog post I wrote on tracing that                                 reproduces a lot of the same content                                 from this talk or please reach out to me                                 whenever you you like if you have any                                 questions Thanks                                 [Applause]                                 [Music]                                 you
YouTube URL: https://www.youtube.com/watch?v=engm2Wqfgjk


