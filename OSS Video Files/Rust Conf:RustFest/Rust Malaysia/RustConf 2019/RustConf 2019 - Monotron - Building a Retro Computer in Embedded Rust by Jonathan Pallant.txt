Title: RustConf 2019 - Monotron - Building a Retro Computer in Embedded Rust by Jonathan Pallant
Publication date: 2019-09-19
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Monotron - Building a Retro Computer in Embedded Rust by Jonathan Pallant

I missed the simplicity of computers like the C64 and the Apple II and I wondered if I could recreate something like that, but using the inexpensive Cortex-M development board I had lying around on my desk. Can you generate VGA without a video chip? Can you render text without enough RAM to hold a bitmap framebuffer? Can I work out how to decode signals from a PS/2 keyboard? What about SD card support? What about audio output? A real-time clock? MIDI?! Parallel Printer support?!!

I will outline the story of my ongoing obsession to cram as much functionality as possible into 256 KiB of Flash and 32 KiB of SRAM, using the power of Rust to build re-usable, testable components along the way.
Captions: 
	                              [Music]                               they said would you like some would you                               like some music to kick off said yeah                               it's some                                                           set the scene for this as you could see                               fairly retro themed talk I've seen some                               really beautiful slide shows today I                               don't want you to underestimate the                               amount of effort required in making                                slides look this bad so you're welcome                                yeah with a clock so I got the                                timekeeping going on yeah we'll see how                                that works out so yeah so my name is                                Jonathan I'm here to talk about embedded                                rust and this crazy project I've been on                                for about                                                         monotron and we'll see what that's                                spiraled into so first some some                                introductions so you can find all of my                                code on github where I am the J pista I                                tweet a lot these days but I came to                                Twitter relatively light so on Twitter                                I am the real JP ster because somebody                                took the JP stir before me don't ask                                that person rust questions because I'm                                pretty sure they they can't help you can                                find cryptographic proofs that prove I                                am who I say I am at key based which is                                a great service recommend you check it                                out and I belong to the rust embedded                                working group and you can find all of                                the embedded working group materials on                                github the slash rust embedded check it                                out some great stuff on there we've got                                a number of books that are embedded                                related and a whole bunch of other                                material so have a look so what are we                                going to talk about today well this is a                                talk in three parts I guess so we're                                gonna talk a little bit about embedded                                rust and what makes embedded rust                                different to normal                                rust programming we're going to talk                                about this project which I built to sort                                of demonstrate embedded rust and act as                                an example of of what you can do and                                then fingers crossed we might be able to                                put together a little demo for you no                                promises it's always a bit tricky with                                with AV set ups as you see well but what                                we've got here is pretty experimental                                but we're see what we can do so I think                                you'll find that is the highest fidelity                                version of the the rust logo you'll see                                all day so I came to the Ross project                                it's always around                                the one point one pick one one point two                                I think it's actually I took a week off                                work with the flu and I was stuck in bed                                and unable to move and I had nothing to                                do was watched all the TV I could manage                                so someone to work have been going on                                about this language and said you know                                it's interesting it does good stuff and                                within a couple of days having never                                picked up the language before I'd                                written a functional web server that                                could sort of parse HTTP requests there                                was like okay yeah there was a                                professional C programmer I was sort of                                falling over these foot guns all the                                time all these things that are really                                easy to get wrong and I'd spent a lot of                                my professional life building up these                                processes to deal with these things that                                are really easy to get wrong and                                suddenly there's a language it's like                                now we've we've taken care of that for                                you you can go and concentrate on the                                more interesting aspects of programming                                and so yep fell completely in love with                                the language and I've been getting more                                and more involved in in the embedded                                side so the embedded working group again                                I think we agree that's a great quality                                logo incidentally there is a there is a                                tool you can download called Rex paint                                it is an ASCII art painting tool your                                palette of brushes is basically the set                                of ASCII characters and then you can                                draw with them and do lines and                                rectangles and so on yeah it's a                                real-time sync so if you're like me                                maybe maybe avoid that so the rust                                embedded working group formed oh gosh                                maybe about two years ago I can't                                remember now and it started out with                                about five or six of us and we'd get                                together once a week or every so often                                 just to chat about and what we've been                                 working on and it's it's spiraled                                 especially with the rust                                               we put a lot of effort into making                                 embedded rust work on stable on a number                                 of different targets and now I think                                 there's you know well over a hundred                                 people involved we get together once a                                 week on a Tuesday and we chat on matrix                                 recently had to switch from IRC to                                 matrix so there's a whole bunch of fun                                 for you and yeah we've written a bunch                                 of support crates of the different                                 boards which I'll talk about we've                                 written a couple of books one is an                                 introduction to embedded systems                                 that happens to use rust and one is a                                 book for people who already know                                 embedded systems and it teaches them the                                 the rust specific bits and then there's                                 a third book called the embedded nomicon                                 which is all the deep dark and scary                                 bits of rust we've written so you don't                                 have to actually you know get these                                 chips to to boot in the absence of an                                 operating system as I say so it will all                                 that stuff's don't github so go check it                                 out so if you want to do embedded rust                                 what what do you need and what I guess                                 what do I mean by embedded rusts so I                                 mean you're running on a platform that                                 doesn't have an operating system you                                 could say that running rust on a                                 Raspberry Pi is embedded and for some                                 people that is a resource-constrained                                 platform but I think when I talk about                                 embedded rust you're talking about                                 systems that don't have an operating                                 system or if they do it's a really                                 simple artist and they've got memory                                 measured in the in the kilobytes rather                                 than the megabytes so if you want to to                                 write some embedded rust code for a                                 specific chip and there are an awful lot                                 of chips out there you need a few things                                 so first of all you need LLVM to be able                                 to generate machine code for your target                                 it has a bunch of CPU architectures                                 built in and there are there are more                                 being added so we're aware there's a                                 fork for the Atmel AVR series so what                                 happened was somebody took LLVM and they                                 forked it to add AVR support and then                                 the rust team took LLVM and forked it                                 for their thing and then someone just                                 needs to like zip the two forks together                                 and that's a that's a work in progress                                 but there are a number of platforms                                 where the support is all all sorted out                                 so once you've got an LLVM back-end you                                 have to tell rust c to which will then                                 tell LLVM how to generate code just                                 because it knows how to generate I know                                 for example x                                                           enough you need to know the rules about                                 how big the integers should be and how                                 much stack space you allocate in in                                 various places so that's the thing                                 called a target file you can supply your                                 own if you're in an experimental                                 platform you might find someone                                 has a JSON file in the tree and that                                 contains all of the information but                                 eventually that will get merged into the                                 compiler source code and it becomes a                                 built-in target the next thing you need                                 really is a precompiled Lib core core is                                 the subset of of standard we can't run                                 standard because we don't have an                                 operating system we don't have threads                                 and file systems and all that nice stuff                                 so we're stuck with core which is sort                                 of the basic subset you can compile your                                 own core but as far as I know it's still                                 the case that compiling core requires                                 nightly which is not ideal if you're                                 trying to build a stable system using                                 the stable compiler is better so the                                 solution was to ship precompiled core                                 libraries so if you use rust up target                                 list it will show you a whole bunch of                                 targets where you've got precompiled                                 standard libraries if you search for the                                 word none in there that shows you the                                 embedded ones and we've got cortex m                                  arm cortex-m ARM Cortex R and some risk                                 v                                                                     the moment so those binaries are pre                                 compiled and they're shipped out to                                 everyone through rust ups so getting set                                 up for a sort of a standard cortex-m                                 system is super simple you just need                                 rust up and then that will that can pull                                 in everything else you need so let's                                 have a look at an example of why I think                                 rust is really powerful on                                 microcontrollers the classic example is                                 you're doing you need to disable                                 interrupts to perform some operation                                 perhaps you've got some shared mutable                                 states that stuff we all think is really                                 scary when turns are embedded hardware                                 is just a giant ball of mutable shared                                 state that's just what it is so yeah                                 when you need to disable interrupts in C                                 you might have a function disable                                 interrupts so I'm gonna do a bunch of                                 stuff I'm going to turn the interrupts                                 back on again afterwards it's really                                 easy to return early and then never get                                 to the re-enable line at the bottom or                                 you could forget to re-enable and you                                 know the compiler won't check that                                 you've got the got the right cause then                                 well we can use closures you know you                                 don't need an operating system to use a                                 closure so here we've got a function                                 called free and it operates                                 some executes some function in an in an                                 interrupt free environment so it's gonna                                 disable interrupts with the prime ask                                 module it's really good so we're gonna                                 get the current interrupts state with                                 prime ask we're gonna disabled we're                                 gonna call our closure giving it this                                 magic critical section object the                                 critical section object basically acts                                 as a proof that you are in a state where                                 interrupts have been disabled stops                                 people calling functions outside of that                                 state that's an unsafe thing to create                                 we're unsafe means don't worry compiler                                 I've got this that would be a fairly                                 lengthy key words if I'm honest so I can                                 see why they went with unsafe but yeah                                 he said to the pilot don't worry I've                                 got this make me a critical section                                 because I know I've got interrupts                                 disabled and no matter what happens in                                 function f you know if it returns early                                 whatever it doesn't like its arguments                                 you will always reenable the interrupts                                 afterwards so there's a whole bunch of                                 stuff now I don't have to worry about I                                 don't have to worry that I've got these                                 things matched up and that's that's                                 super powerful but so another example                                 doing memory mapped i/o the cute thing                                 here so this is for an object called a                                 cache and branch predictor embedded                                 systems are full of really really                                 forgetful forgettable names so the CBP                                 is the cache and branch predictor the                                 important thing is this struct is                                   sized and then the the address of the                                 peripheral in memory is is produced                                 through the through the D ref system so                                 ii guess it's really efficient and then                                 the compiler just in lines a whole bunch                                 of stuff but basically i'm saying we can                                 access the the hardware the serial ports                                 the low-level stuff in the chip we can                                 we can access it in in a nice fashion so                                 the projects you you work on it is sort                                 of a built in inner stack so at the top                                 there's this thing you're writing the                                 application the game that a little                                 widget demo whatever it is so that sits                                 at the top and underneath you've                                 probably got what we call a board                                 Support Package so this will be a crate                                 someone has written that describes the                                 board you're running on it might be a                                 commercial board you can buy maybe an ST                                 micro discovery board there'll be a                                 crate that says                                 okay I've got three LEDs and I've got                                 two buttons and you can call button one                                 is pressed returns a true or false so                                 basically just sets up a bunch of stuff                                 related to how your board is configured                                 which pins are connected to which                                 interesting things below that we have a                                 hardware abstraction layer so the                                 embedded working group have put a lot of                                 effort into making for example an ST                                 micro serial port look and feel like a                                 Texas Instruments serial port or maybe a                                 serial port on your Linux laptop these                                 see reports all do the same thing but at                                 the hardware level they look very                                 different and in C it's very tricky to                                 come up with a uniform implementation                                 you end up in very vendor specific                                 places so here we've said no we're gonna                                 have a standard implementation of a                                 serial port as a trait you can read a                                 bytes you can write a byte and then if                                 we implement that for a whole bunch of                                 different chips your code is now                                 portable you can run it on SD micro you                                 can run it on Texas Instruments and                                 that's what the hardware abstraction                                 layer is about and then below that we                                 have some auto-generated code we can                                 take manufacturer definition files that                                 say we have a you are peripheral here it                                 has these registers that these addresses                                 with these fields that these fields have                                 these meanings there's a lot of stuff to                                 read in the datasheet I mean I've seen                                 data sheets that are                                                     to convert that into Russ code is pretty                                 tedious to do it by hand the the files                                 we get aren't perfect but it's a pretty                                 good start until we we also generate                                 this this sort of access layer which is                                 how we get to the to the hardware and                                 finally you need something for the                                 specific architecture so these chips                                 have a process by which they boot up and                                 start running and we've got code                                 certainly for cortex em and cortex are                                 that that do that for you so you don't                                 have to worry but so that's the sort of                                 the bottom layer right so let's talk                                 about this project I've been working on                                 some of you may remember the Commodore                                                                    yeah I'm just about old enough to                                 remember that yeah a bit of basic you                                 never thought you'd come to a rust                                 conference and see basic up on there up                                 on the sides so this is where I got into                                 embedded computing I had my Commodore                                    I was terrible at playing games so I'd                                 plug stuff in the little connector at                                 the back and I'd write peaks and pokes                                 that we can                                 turn motors on and do that stuff so                                 that's where I love this sort of                                 interactivity where I do a thing and                                 then physical real stuff happens and                                 recently last year I wasn't enjoying my                                 job I wanted a side project I was really                                 getting into rust and I thought well                                 maybe I can recreate some of that sort                                 of                                                                     limited platform and I think there's a                                 lot of art to be found in extracting a                                 lot from from very little so what did I                                 want to do well yeah I needed this this                                 distraction the problem the challenge I                                 set myself was can i generate video can                                 I get a picture up on a monitor using a                                 microcontroller that's not designed to                                 do that and then if I can do that how                                 much more can you get in what can you                                 get out of one of these tiny processes                                 so the first board I looked at was at a                                 wonderful photograph I think you'll                                 agree it's a board called the St                                 stm                                                                  naming things in the embedded world but                                 this board comes with like a four inch                                 LCD on the front and you get a fairly                                 powerful processor runs at a couple                                 hundred megahertz a big I could have                                 done the project on this board it would                                 have worked but it already came with a                                 screen so generating video is like a                                 solved problem it's got built-in video                                 accelerators that do this work for me                                 and yeah using them would have been                                 interesting but it's too easy so I use                                 this board instead this is the Texas                                 Instruments TVC launch pad it's quite                                 nice because it contains two processors                                 the one at the top does USB serial                                 conversion and is a flash programmer and                                 JTAG tool so you can just plug it in via                                 USB and that's all you need to reprogram                                 the board and then the top chip actually                                 reprograms the the chip in the middle                                 we've got a cortex-m that runs at                                    megahertz                                 we've got                                                                                                                        so that is incidentally not enough RAM                                 to hold an entire picture at a                                 resolution that you're looking at                                 up on the up on the screen so what can                                 we do so to generate analog video how                                 does this work well in the olden days                                 you had electron guns and yeah in the                                 olden days when kids watch TV they sat                                 in front of a particle accelerator which                                 fired electrons at their face and made                                 special chemicals glow kids these days                                 don't believe it                                 but this electron gun swings from left                                 to right lighting up the screen as it                                 goes and that's basically how the video                                 signal works you generate a picture by                                 sending each horizontal line you need to                                 get the timing correct the pixels are                                 sent out from left to right then there's                                 a bit of a gap while you wait for the                                 gun to move back to the the other side                                 of the screen and then you got these                                 sort of blanking areas at the bottom and                                 they're on the side so when it comes to                                 generating VGA video and I went with VGA                                 because what you see as the the numbers                                 work out a bit nicer but VGA monitors                                 are kind of easier to come by like I can                                 feed VGA into inter systems like this                                 there's an amazing website you should                                 check it out called tiny VGA it's really                                 good so there's a bunch of different                                 standards a different set of resolutions                                 that are specified the standard VGA                                 resolution                                                           seven five megahertz I've got an                                    megahertz clock that is not going to                                 divide out there is no number I can no                                 integer I can divide                                                     five point one seven five that's going                                 to be a nightmare                                 standard bios text mode or the text mode                                 using DOS turns out is this resolution                                                                                                         not going to be able to generate that so                                 I kept going through the list the next                                 one                                                                      a pixel clock of                                                      there are                                                             per second and if you can generate them                                 at that rate you will generate a signal                                 that any standard VGA monitor will will                                 connect to and so that's the that's the                                 system I built now I said before we're                                 using VGA well VGA is a is a color                                 standard in mono world you just                                 basically send a voltage                                 to the monitor and the bigger the                                 voltage the brighter the dot and I go                                 see from black to white and then there's                                 a little period on the left where it                                 goes negative for a little while and                                 that just tells the monitor where the                                 edges are so it knows how to line the                                 picture up in in color world we have a                                 red channel a green channel on a blue                                 channel and then by mixing those                                 together if you have analog levels maybe                                 eight bits for each that's where you get                                 your                                                                    be lucky if I could just turn them on or                                 off which gives me about eight choices                                 of color but that's that's what we have                                 to do and then - because I said we don't                                 have enough RAM to generate the picture                                 what we're gonna need to do is store                                 basically a font which has on or off so                                 you have your pixels on or off and then                                 call it maybe foreground and background                                 and then I click and pick two colors so                                 I could set my foreground to green and                                 my background black and it would look                                 like this but if I set my foreground to                                 white my background to blue it would                                 look different so then all I need to                                 store in memory is just I'm using a                                 copyright character at this location and                                 I want it blue and white or black and                                 green and that uses much much less                                 memory than trying to store the color of                                 every single pixel in RAM because we                                 haven't got enough RAM for that the                                 downside is as the screen gets drawn I                                 have to look up the character in the                                 font and then apply the color                                 transformation to color all the pixels                                 and then get the pixels chucked out I                                 actually run the video at half speed so                                 I'm only running a                                                       does mean I only have                                                    pixel that's quite a lot of work to do                                 to get each pixel sent out of this                                 system in only                                                         fairly tall order so that it's not a                                 terribly readable example I get that but                                 basically we're just saying I have my my                                 array of characters and colors in a line                                 I can issue I can iterate through that I                                 have to do some funky pointer arithmetic                                 because I can't afford the bounds check                                 because I've only got four clock cycles                                 per pixel so there's a bit of funky                                 pointer arithmetic in there                                 but spoilers this works this code will                                 run fast enough on this chip to generate                                 actual video the the color lookup it                                 turns out if you do it as like a match                                 or a some kind of statement like that or                                 a bunch of if statements takes way too                                 long the the solution and it took a long                                 while to work this out the solution is                                 to blow                                                            massive color lookup table so I take the                                 eight bits I want to color and then the                                 two colors are chosen well that gives me                                                                                                      with                                                                     is the red set of pixels the green set                                 of pixels and the blue set of pixels and                                 some padding so it takes up                                            means I can go from foreground and                                 background color to red green and blue                                 in only a couple of clock cycles which                                 is really powerful without that it so                                 the reason it's called the monotron was                                 because for ages it only did black and                                 white I guess I should rename it now but                                 yeah we can we can do color interesting                                 from with the timing if you don't get                                 the red green and the blue completely                                 aligned you get these sort of weird                                 fringing effects it's actually                                 impossible to get this CPU to to start                                 the red the green and the blue                                 simultaneously I'm using a special                                 peripheral here called the SPI bus I'm                                 using three of them you can't start them                                 at the same time they need different                                 memory rights and it's impossible to do                                 to memory rights at the same time and                                 for ages this stumped me it turns out                                 what you can do is you start the red                                 channel early and then you use a bunch                                 of no-ops to just slow the processor                                 down just enough until the exact moment                                 you've transmitted eight bits of red and                                 then you can start the green and then                                 you have a bunch more no-ops and then                                 you can start the blue and then it all                                 ends up in phase yeah that that took                                 some batiks i'm doing so how does the                                 the memory now look what I've got I've                                 got a flash ROM I think of that as sort                                 of a ROM in a sort of typical home give                                 you two cents and I've got Ram                                 get the various sections it's like                                 compiling code for any other platform                                 really you know if you were writing C                                 code you'd be familiar with all of these                                 sections the data section gets copied                                 from flash to RAM on on start up on my                                 interrupt vectors at the bottom so once                                 I got this system I said well I mean                                 it's fine I can make pretty pictures                                 appear but I wish it was a computer I                                 could use I want to be able to install                                 applications I want to load an                                 application in use it and then when I                                 turn the computer off and on again                                 the applications gone because you know                                 that's how these systems are I like from                                 the the                                                              your application to talk to this sort of                                 ramen this sort of kernel like built you                                 need an interface so the system I                                 designed was basically when you load a                                 program into RAM you get the top                                        play with the bottom                                                   system the first word in in your                                 application space should be a function                                 pointer and then if you put your code in                                 Ram the kernel will look at that treat                                 it as a function pointer jump to it                                 don't care what you do with the rest of                                 the RAM that's your business but what I                                 will give you is a structure full of                                 function pointers and those function                                 pointers are how your application can                                 ask the kernel to do things like draw on                                 the screen or in various other                                 operations and then I've spent a long                                 time thinking about what should the sort                                 of system calls look like I think maybe                                 they should look like CPM maybe they                                 should look like ms-dos maybe they                                 should look like POSIX I haven't really                                 got a good answer for that they sort of                                 a bit of a mismatch at the moment but we                                 can do things like have seni one pressed                                 a key on the keyboard so you can connect                                 up maybe a serial interface and you                                 could type some some text into your                                 computer wait for the wait full verticle                                 blank interval so that's wait till the                                 screen has finished redrawing because if                                 you try and draw on the screen you try                                 and modify the contents of screen memory                                 while it's drawing you get sort of weird                                 tearing effect so it's probably best to                                 wait at the bottom of the screen before                                 you update a bunch of stuff you know                                 maybe if you had fonts port you could                                 change fonts that sort of thing wouldn't                                 be cool if out of joystick interface                                 yeah because then you could play like                                 simple games would be interesting so                                 that's sort of the project in a nutshell                                 I can say at this point there is a PCB                                 I've got one here you can grab me in the                                 hallway track and have a look it started                                 out as a bit very bored it's a bit                                 unreliable so there is a PCB there's                                 gonna be a rev - because it has bugs but                                 it's got serial ports on it it's got a                                 clock and you used a clock in in the                                 slide here show that off so what else we                                 got we've got a printer port would that                                 be interesting if you could print it as                                 a printer port on the PCB haven't worked                                 out how to make it work yet I need to go                                 and do some research on how the hell                                 printers work and there's some more                                 right so that's the end of the slides                                 who wants to see a demo                                 okay so I did say that making slides                                 look this bad is remarkably difficult                                 I'm gonna be honest with you the laptop                                 is a is still in the bag                                 the computer itself is                                 [Applause]                                 so we've got a computer to play with and                                 I've got about five minutes and I've                                 lost my clock so I'm probably gonna run                                 over and I apologize in advance so                                 wouldn't it be fun if we had a disk                                 drive so we could load programs we have                                 a disk drive with fat                                                   can read from an SD card I can just pull                                 the card out shove it in the laptop                                 I've got programs on disks that I can                                 load into RAM and then execute so if you                                 want to I know maybe you want to do some                                 programming so we can do load tiny bars                                 don't we have basic so this is basic for                                 the                                                                 managed to hook the C program up with my                                 rust crate that contains all of my all                                 of my system calls so yeah we can do you                                 know it's got to be done I can't bring                                 up a basic program and not type this so                                 there's that                                 [Applause]                                 so that the screen is redrawing every                                 line there are thirty seven thousand                                 five hundred lines per second                                 effectively if you take the sixty Hertz                                 times it by the the six hundred plus the                                 blanking interval well it's a tiny bit                                 of CPU left at the end of the line maybe                                 you could get it to I don't know                                 generate a beep that'll be interesting                                 wouldn't it maybe in fact you could you                                 could use the the MIDI interface so I                                 apologize because I am not a musician                                 but I do happen to have a mini keyboard                                 with me                                 [Music]                                 so it if you are a musician feel free to                                 come and grab me later we can set this                                 up a little set of speakers as I say I                                 can't really play music but you know we                                 can we can do that what else have we got                                 we've got a joystick so maybe to finish                                 up we're gonna play we're gonna play a                                 little game some of you have seen it up                                 there before we go into that you're                                 about to see an effect in the title                                 screen and I just want to explain a                                 little bit about how that works when I'm                                 drawing the video lines I have to work                                 out what's on each line of text based on                                 where I am on the screen it turns out                                 just because you're in line                                             mean you have to draw the pixels that                                 should be on line                                                     have a little mapping table inserted in                                 the front which allows you to move any                                 line to anywhere else on the screen                                 which lets you do this kind of effect                                 which is kind of fun so you can see how                                 this sort of thing might be useful for                                 sort of scrolling scrolling backgrounds                                 or things like that so let's let's fire                                 this up so this might be loud so I'm                                 just going to warm that just the a/v guy                                 run                                 yeah I was really impressed with this                                 tune because I wrote it on an aeroplane                                 by typing in the frequencies into the                                 source code and then afterwards my wife                                 said why does your computer keep playing                                 bulbs the Builder classic British kids                                 TV show seem familiar so to finish up                                 I'm gonna have a click bash on snake                                 every time I eat an apple I would like                                 you to whoop and cheer because it's                                 really not very easy and then when I                                 eventually come to my terminal demise                                 and eat my own tail that will be the end                                 of it so thank you very much let's let's                                 give this a go all right                                 oh yeah come on ten points                                 the mall right so that the more I eat                                 the faster it goes so we really won't be                                 here all day don't worry oh yeah we                                 getting quicker okay thank a very much                                 everyone thank you                                 [Applause]                                 [Music]
YouTube URL: https://www.youtube.com/watch?v=IArQf7TX1D4


