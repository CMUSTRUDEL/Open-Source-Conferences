Title: RustConf 2019 - Taking Constant Evaluation to the Limit by Oliver Schneider
Publication date: 2019-09-19
Playlist: RustConf 2019
Description: 
	RustConf 2019 - Taking Constant Evaluation to the Limit by Oliver Schneider

Have you ever wanted to write a static with a complex initial value? Are you programming microcontrollers? Do you want to run as little code as possible at runtime or are you trying to reduce your memory footprint? If you answered yes to any of these questions, then you probably want to evaluate all-the-thingsâ„¢ at compile-time with a constant evaluator.

This talk will focus on explaining the inner workings of the new theoretically unrestricted constant evaluator in rustc (nicknamed Miri for "MIR interpreter") and give a short outlook on the future features Miri will enable in the Rust language.
Captions: 
	                              [Music]                               hi everyone I'm oli so you might have                               seen this logo that's me and I work for                               kasnian so we take security research                               like multi-party computation and                               homomorphic crypto and like put it into                               products that actually protect your                               privacy so yeah trying to do cool stuff                               here anyway you're here for constables                                oh stop talking about me why constable                                well I guess everybody has used                                constables somewhere maybe for an array                                links or something                                so usually use constable to save                                resources you want to make sure that                                something happens at compile time                                instead of at runtime so he just like                                especially if I'm embedded you don't                                have many resources at all so you don't                                really want to use them up other things                                that he can do is like you can reduce                                some types of some trickery like                                sometimes you end up like working around                                weird weird things so you're working                                with the system to get it to do like the                                type system get something to do that you                                want to do but it's very hard to do so                                you're doing like weird tricks and it                                just gets annoying so constable saves                                you from that because it just allows you                                to write stuff in real rest code so it                                can do whatever you you were previously                                doing comp in complex ways also you can                                prove constraints at compile time so you                                can make your program secure by ensuring                                that some things that simply check the                                compile time error out at compile time                                and most importantly because we can                                that's my reason so there's a bunch of                                levels of constant evaluation that you                                can get at so there's like the                                omnipotent level you know it is from                                scripting languages you have an invalid                                function you can just involve anything                                and you get a result from it and you can                                just use that at compile time and then                                use the values and the during                                compilation so that's like omnipotent                                like in crazy levels because you can do                                anything in there you can open that for                                connections and like connect to whatever                                database somewhere and then do weird                                stuff on the internet that's not what                                you should do it in console but you                                could then use restricted omnipotent                                which is like well you're not allowed to                                do network to the internet because                                that's kind of yeah weird so let's not                                do that                                and then there's inherently limited                                which is basically a glorified                                calculator and allows you just to like                                compute some values and                                and so we are right now at be very                                restricted omnipotent so big shout out                                to Scott Olsen who wrote the so called                                Mira Mira interpreter which is the BAE                                thing that we are using in Constable in                                rusty it is basically all-powerful it is                                a virtual machine interpreting rest code                                it is a virtual machine in all of the                                definition of a virtual machine you can                                run anything in there theoretically and                                we want to go to restricted omnipotent                                so we want to keep some restrictions                                around we don't want to run anything to                                be possible at compile time and there's                                a bunch of reasons for that so first of                                all soundness if you allow anything at                                compile time you get some weird issues                                where like you compute a value over                                there and you compute it over there and                                it's suddenly not the same value even                                though like the logic is entirely the                                same this happens for example if you                                have random number generators as like at                                compile time that's a bad idea                                then again though that all boils down                                basically to determinism you want your                                constants to always be the same thing so                                if you have a constant and you look at                                it and you look at it later again it                                should still be the same constant and                                finally like for us implementing                                constant evaluators we don't want this                                to get more complex entities it's like                                already a thousand lines of code inside                                a rest compiler that's pretty big for                                just a constant evaluator but we'll get                                 to that later so we want some                                 restrictions for example we don't want                                 mutation of global state mutation of                                 global state essentially boils down to                                 random number generators because you can                                 have some global variable and you're                                 mutating like you're accessing definite                                 differend them or something getting                                 random numbers whatnot mutating global                                 state is a bad idea because you get like                                 the initializer in another sized                                 initialization order problem that you                                 know from other languages so yeah no                                 global state we don't want any non                                 determinism so you're not allowed to get                                 check the bytes from some pointers                                 because like pointers to some things in                                 memory like they'd change the address                                 between compilation                                 and the order is not defined that the                                 actual addresses are not defined so we                                 don't really want that kind of things                                 and we also don't want Cindy again back                                 because it's very complex to implement                                 like thousands and thousands of similar                                 instructions so there are some                                 restrictions that we just want to keep                                 around and we have to work around those                                 but we have loads of unnecessary                                 restrictions so one thing I often get is                                 like why can't I have like new I mean                                 BEC new doesn't even allocate it doesn't                                 do anything it's like just like create                                 some vector that has no element so why                                 can't I have this well there are some                                 problems with with that because                                 internally it uses things that are a                                 little bit more complex than doing                                 nothing                                 and those little bit more complex things                                 they aren't really possible right now so                                 but we're working on that there's no                                 Canarsie for that then another thing is                                 box new vector so anything that kind of                                 like needs to heap so we want heap                                 during conservation I'll get to that                                 later and explain in detail how that is                                 happening because it's actually a very                                 hot topic because C++ just got heap                                 during constable                                                     yeah so loops and if conditions so any                                 kind of branching we can't do right now                                 and we want to get rid of them and cool                                 update yesterday morning and you pull                                 request was open that actually will help                                 us get there and another one is in the                                 work so I'm pretty positive we can have                                 this in the next month well reverie                                 unstably and not for anybody using it                                 unstable but like it'll work at least                                 then calling trade methods you cannot                                 call a trade method in constable right                                 now we have concept and since the                                      edition so you can define your own                                 consequence but you cannot call trade                                 methods you did there's no way to                                 specify those bounds so there's an open                                 RFC for that and yeah once we have that                                 and we can implement it and then we'll                                 have that so this is work in progress                                 but we're getting there                                 format a space Atika lamination of                                 everything that you saw above so we need                                 trade methods we need if we need loop                                 and we need heap allocations and then                                 you will be able to call format and when                                 you can call format you can basically                                 like end up using like all                                 thirty because that just uses the same                                 stuff so my goal is personally to get                                 Sri at compile time so you take like a                                 configuration file for like a Tamil file                                 on your source and then you run it                                 through surly at compile time and you                                 get struck at compile time with all your                                 configuration and you get an error at                                 compile time telling you that the file                                 was bad instead of like getting it                                 during run time and having your product                                 crashed somewhere so the last                                 restriction that is basically                                 unnecessary is that we're not really                                 allowing you to do I'm safe right now                                 you can do unsafe but only if the unsafe                                 contains nothing that is actually unsafe                                 I'll get to unsafe later                                 ant if is pretty cool during comfortable                                 and yeah I have some examples what we're                                 gonna do there but everybody here                                 probably came here not to hear what you                                 can't do you want to hear what's gonna                                 happen how it's gonna happen and so                                 let's continue things that like aren't                                 constable but well they are now so                                 Siouxland just got constable like                                 yesterday it's not nor yet but like it's                                 working and so it's empty and all these                                 kinds of functions so Stephan standard                                 Larry is getting constable all the time                                 basically if you want something to be                                 canceled I'll just open it an issue                                 about it and like we'll we'll fix it                                 like most of the things can be constable                                 nowadays so conce offense so we can just                                 do that so panic panic is constant and                                 it's pretty useless because you don't                                 know if so it's just gonna panic at                                 content all the time which is an error                                 but like hey it works you can have let                                 let moot so you can actually like write                                 some pretty linear code and you can have                                 to be structuring in there so you can                                 create things and destructured them                                 again and so on so that works and                                 there's all kinds of functions on you to                                 your triplet integers that are constant                                 now so you you have like overflowing and                                 wrapping operations you're like what's                                 it count zeros count ones whatever like                                 there's loads of operations on integers                                 that are now consonant and you can use                                 them and there's probably more that we                                 could make constant so if there's                                 something you're missing just open an                                 issue about it if if you're telling us                                 about it then we can probably fix it but                                 most of                                 but probably a lot of people really want                                 is pointer offset from you may ask why                                 do you want that if you were to offset                                 off its like to calculate the offset of                                 a field instruct to the base of the                                 track so you may wonder why you need                                 that well it is used in so many kinds of                                 abstractions where you're doing some                                 some neat hackery at compile time and                                 this feature is constant now and we can                                 use it again on nightly obviously but                                 like it works so these are kind of                                 things like library wise that we get but                                 there's more than that you can basically                                 end up making anything Const of n like                                 literally you pointed it and we can make                                 it constant there's very few things that                                 we can I give you restrictions earlier                                 everything outside is restrictions make                                 it constant tell us about it if you want                                 it will make it constant so what kind of                                 stuff is being happening as console fans                                 now I already told you about looping if                                 there's accepted RC for that so this is                                 just like implementation work and it's                                 happening right now so there's some open                                 RFC's which give us like calling trade                                 methods and vacuu and so on and this is                                 gonna happen sometimes tuners I guess we                                 don't have an RC it for heap allocations                                 once we have CR RC through for for trade                                 methods then we'll go to the heap                                 allocations and with HEPA locations                                 people can start doing all kinds of                                 crazy things you can start allocating                                 graphs at compile time and just putting                                 them in a static and you have them                                 available later and the computation is                                 like all happening at compile time or                                 perfect hashmaps well you computer                                 perfect hash map at compile time right                                 now this is all like procedural macros                                 and all kinds of other black magic but                                 then you can just run your normal code                                 that you would run at runtime just run                                 it at compile time put in a static and                                 you're done and of course I already                                 talked about unsafe C unsafe shenanigans                                 and there's lots of fun section again so                                 there's super super fun but before we go                                 into all of these details let's give an                                 example about heap allocations because                                 he fell occasions especially in the                                 presence of C++ getting isn't                                        very hot topic so                                 keep allocations have lots of curious                                 problems most of them boiled down to                                 this you have a constant and that                                 constant is of type string however you                                 get that constant I don't care like it's                                 you somehow compute a constant and then                                 you use that constant you say let x                                 equals foo and then at some point                                 through X is being dropped your honor                                 let's go up you drop it explicitly                                 whatever the question is what happens at                                 this assignment like x equals foo                                 usually when we didn't have heap                                 allocations that was always a very                                 simple solution we just bit copy the                                 constant into X and then we have the                                 value right there but if we bit copy the                                 constant string object we are referring                                 to a static heap allocation this is like                                 in static memory this is this is in your                                 in your data section somewhere where you                                 can't get it back out it isn't you can't                                 D allocate it it was never allocated                                 this just exists like a static would be                                 like calling free on a static as like                                 undefined behavior so this is illegal                                 code we can't have this so the question                                 is what kind of things are K and what                                 kind of things are not okay and this is                                 what the we could we were able to take a                                 lot of information out of the C++                                 discussions about heap allocations in                                 C++ this is illegal you're not even                                 allowed to compile the Const definition                                 so it becomes foo string is jut not                                 legal and we are not going to make it                                 legal either because it has this obvious                                 problem here so what kind of things are                                 okay so as I showed you the first thing                                 is bad but if you put the thing behind a                                 reference suddenly it's okay because you                                 can't move out of a reference and rest                                 so anything behind a reference even if                                 there's heap allocations in there                                 it's basically fine you can just access                                 this as and you can't move out of it you                                 need to clone it and once you clone it                                 you create a new heap allocation and                                 everything is fine there's there's no                                 problems there and even if you convert                                 this too                                 it's no problem because then it's just a                                 it doesn't even show you that there's a                                 heap allocation there and you can't move                                 out of it anyway and any kind of other                                 non heap types so if you have integers                                 or                                 custom structs or slit that don't have                                 heap in there you can just put them                                 directly in a constant and everything                                 stays fine so this kind of setting where                                 is something behind the reference it's                                 okay and something not behind the                                 references but may be problematic maybe                                 it reminds you of anything like it took                                 us like two weeks to figure this out                                 when we were like like sitting there and                                 just discussing the whole time about all                                 of this heap stuff and at some point                                 somebody noticed well it's almost like                                 sentencing it's like not quite                                 sentencing but like we could create two                                 new traits one is Const                                 which means you're allowed to put it in                                 a constant and the other thing is                                 concept safe which means if it's behind                                 a reference then you could put it in a                                 constant so the ideas will create the                                 system and we'll just do an unsafe                                 employ constructs a four-string because                                 we'll say we checked we check the                                 implementation our string and we are                                 sure we are very very sure you allow to                                 put it behind the reference because once                                 it's behind a reference the only thing                                 you can do is clone it or turn it and                                 just roll and just like work with the                                 slice but like you can't do anything                                 more than that so we have a system                                 forward here and now comes the                                 difference to C++ we are allowed to put                                 heap allocations into constants as long                                 as they are protected somehow behind                                 references or something else and in C++                                 they decided it's too dangerous we can't                                 do it as because we can't possibly ever                                 check that this will work out so the                                 only time you can use heap allocations                                 in C++ is during your computation                                 compilation but the final product does                                 not have any heap pointers even if you                                 converted to an ampersand STR your if                                 you do the same thing in C++ if it's a                                 child pointer that came somewhere from a                                 heap allocation you're not allowed to do                                 that it's just forbidden but in rest we                                 can do this because we have our awesome                                 type system that has stuff like                                 sentencing that we can now reuse for                                 this kind of setting                                 so we'll be able to do a lot more and we                                 can do it safely we can do it completely                                 safely as the user will never have to                                 worry about it if it compiles it's fine                                 to do                                 and here's the example which will make                                 all of this possible if it's concept                                 safe this is the T bound consular safe                                 here then you can make it con safe if                                 you put it behind a reference so                                 everything is being done for you as a                                 user will never actually have to touch                                 this is all happening in the standard                                 library will expose it like send and                                 swings so if you're doing some your own                                 shenanigans you can just implement the                                 appropriate unsafe trades and you'll be                                 fine and so yeah we have a system now to                                 get heap allocations there and this                                 system it doesn't look very complex                                 it isn't very complex and we are pretty                                 positive we can get this through maybe                                 in the next year that at least you have                                 an on lightly and so we're not playing                                 catch-up to C++ here anymore we are like                                 on the racetrack just taking over not                                 having taking over yet but like we're                                 there okay so keep allocations now we're                                 coming to unsafe unsafe is awesome                                 because unsafe gives you a compile time                                 undefined behavior the best thing I love                                 it                                 so indifferent behavior isn't really                                 that problematic at compile-time because                                 you just get an error but sometimes you                                 don't get an error because we are not                                 like we did we haven't taught self the                                 halting problem yet so you can't really                                 figure out if it is really undefined                                 behavior so what we're doing is like we                                 reserve the right if you do anything                                 behavior we'll just break your code in                                 the future but by breaking code I mean                                 like will emit an error later so don't                                 do undefined behavior it's not a good                                 idea for example what is undefined                                 behavior well give a boolean let's take                                 the Y first you have a boolean and you                                 transmute a                                                              representation is only allowed to be                                 either                                                           undefined behavior because a bool with                                 number                                                                   value it makes no sense or if you cast a                                 an integer to a row pointer and then the                                 reference that and                                                    okay if you're like on embedded and                                 you're giving like the address of some                                 hardware thingy but at compile time like                                 what is on the address                                                  what am I supposed to do is a compiler                                 developer like there's nothing there so                                 these kind of things are undefined                                 behavior there's lots more about like                                 well all kinds of under sign to find                                 behavior that you already know but like                                 if you do any of these things                                 they were like League if you compile                                 time error telling you exactly why                                 you're screwed up so you can actually                                 use this a little bit to play around                                 with undefined behavior to see like the                                 boundaries of what what console I can do                                 there's lots of fun things to do there                                 so if other things are not                                         behavior but like you still need an say                                 for for example here we create a                                 reference to the number                                               that to a row pointer and put that in a                                 constant and then from another constant                                 we dereference that raw pointer and this                                 operation is basically the same                                 operation we had in the previous slide                                 where we would be referencing a pointer                                 that was actually just an integer                                 address but here it's an actual address                                 it's an address to the number                                    somewhere in the stack and                                 in a static memory and we can be                                 referenced at totally fine                                 so the dereference operation is                                 something we really want a compile time                                 because people will be able to do these                                 nice three mannequins so to do you be or                                 not to be that is the question and the                                 problem is there are much stricter rules                                 at compile time because we just really                                 can't figure out what you're doing here                                 like if you put this pineapple variable                                 and puff pizza stuff will happen that's                                 not good so for example we are doing the                                 same thing we did earlier we take an                                 address to your statically allocated                                    convert it to a row pointer convert it                                 to you size and then we divide that you                                 size by                                                               like we don't have addresses at compile                                 time there's no memory like what is                                 dividing like magical address of                                 something bit by                                                       like okay we could add like symbol                                 symbolic executors and all kind of set                                 solvers and whatnot and go crazy but                                 like do we really want that like this is                                 probably not a good idea anyway so and                                 I'm not talking about a pineapple of                                 pizza I like that so sometimes we have                                 less stricter rules at compile time too                                 so we don't have any concrete rules                                 about the alignment at compile time you                                 can just do weird alignment thing so if                                 you have like an array of you eight                                 bytes and you convert that to you                                    like an array of just you eight can be                                 anywhere in your memory it doesn't have                                 to be aligned it just definitely has not                                 to be aligned like you                                                aligned and if you do this code at                                 runtime                                 that's only fine behavior if you do this                                 at compile time it'll compile but we                                 reserve the right to break your code in                                 the future because you're doing                                 undefined behavior so they are very                                 careful rules what you can actually do                                 and you can do more things like you can                                 do an undefined behavior at compile time                                 we might not catch it but it gives you                                 the right to do all these kinds of cool                                 things if you're just as careful as you                                 should be at at runtime so summarizing                                 we don't really have                                 in limits but we are restricting                                 ourselves on purpose just to stay sane                                 because at some point like we we don't                                 want to put all this complexity on users                                 because that's what lots Rus is all                                 about taking away to complexity making                                 the same for everyone to work with code                                 and we want to do the same thing for                                 constable and there's lots of work                                 happening right now to make everything                                 easier for you so don't have to write                                 any complex trickeries to get stuff to                                 work at compile time so just write                                 normal rust code just execute the same                                 thing at runtime at compile time and                                 you'll be all happy many features that                                 somebody might want need a load look                                 like small base features so there's lots                                 of work that's happening where it's like                                 we're implementing three base features                                 just to get one major feature so example                                 as I said                                                          allocations we need if we need loop we                                 need traits the others even four so yeah                                 and what do we actually need as more                                 people telling us what they want to do                                 at compile time as like so we can                                 prioritize there's so many things we can                                 do but like there's very few issues                                 opened actually about people wanting                                 something to become stiff and so that's                                 my call to you Oh more issues telling us                                 to do stuff at constant at all time yeah                                 so this is basically everything I had                                 prepared but I have a small appendix                                 because people were telling me of the                                 last few days all kinds of stuff that                                 they are already interested in so I                                 prepared a few small things this one is                                 a compiler flag you can add this flag to                                 a compiler and it will simply take off                                 the guardrails like it'll just be like                                 okay sorry I'll stop trying to be sound                                 just just I try to run everything that                                 you give me and you can do loops and                                 there you can do if you can do end amout                                 of stuff and it's a very bad idea we're                                 using it just for internal testing never                                 use this in production never ever some                                 of the tests that we have actually error                                 out no panic actually because you're                                 doing something unsound that the                                 compiler just doesn't understand so yeah                                 don't try this know them but if you want                                 to play around with the kanji value and                                 see how far it can go use it                                 I want to shout out to add aesthetic                                 assertions grade if you want to check                                 something at compile time you use the                                 static a surgeon's grade it basically                                 that's this weird trick and some other                                 way so if you want to check if a boolean                                 is true and error out otherwise at                                 compile time what you do is you create                                 an array of one element you convert the                                 boolean to you size and you need index                                 another one element array if the boolean                                 is zero you get something if your bully                                 is not zero you panic and panning at the                                 compile time compile time error                                 wonderful so we have static surgeons use                                 it it'll get better better error                                 messages and so on once we are                                 developing more things at a complaint in                                 the compiler but I've been told that                                 it's gonna go as                                                        assertions great so you can use it and                                 it won't change its API                                 we're just improving the Diagnostics                                 that you are getting so you can just use                                 it everywhere and now a final small                                 anecdote so you can compute the                                 Fibonacci sequence at compile time                                 unstable but you'll get a compile time                                 error or two and a compiler error will                                 tell you the Fibonacci number that's                                 being computed                                 so this program uses wire loops it loses                                 if conditions and so I yeah you don't                                 really want to use that but what we it's                                 doing its computing the length and a                                 Fibonacci number and using it as the                                 lengths of the type of the underscore                                 variable here and then assigning an                                 array of the links for t                                                a type mismatch ever before that you get                                 an unlimited expression type that's the                                 error that Eric actually gonna error out                                 but we also get some it's net type error                                 and there you can see it correctly                                 computed at                                                            are allowed died                                 [Applause]                                 yeah so that's it from me for today if                                 you have any questions just grab me at a                                 rest of the day and also be here for the                                 in place tomorrow                                 two days ago somebody had a problem they                                 wanted a fixed and constant valuator the                                 pr is open now so just come to me we can                                 usually do this very quickly because                                 many things I just don't know about                                 don't work and they often can be fixed                                 pretty quickly so yeah thanks for being                                 here and                                 [Applause]                                 [Music]
YouTube URL: https://www.youtube.com/watch?v=SOfq0aqQZf8


