Title: RustFest Rome 2018 -  Neal Walfield: Sequoia: A New OpenPGP Implementation in Rust
Publication date: 2018-11-24
Playlist: RustFest Rome 2018
Description: 
	OpenPGP is best known for its use in email encryption. But, OpenPGP is, perhaps more importantly, used to secure software updates, sign commits, and protect backups.
Historically, OpenPGP has been hard for both end-users and developers to use--we know, we actually worked on GnuPG! In Sequoia, we are trying to change that. Sequoia is a new OpenPGP implementation that places as much emphasis on usability as on security.
Sequoia is also written in Rust. This talk will focus on the challenges that we've faced using Rust--infinite types, streaming iterators, designing a clean API--and our solutions.

https://rome.rustfest.eu/sessions/sequoia
https://media.ccc.de/v/rustfest-rome-6-sequoia
Captions: 
	00:00:04,540 --> 00:00:09,820
for that introduction today I'm here to

00:00:07,390 --> 00:00:12,370
talk about Sequoia which is a new open

00:00:09,820 --> 00:00:14,139
PGP implementation most people when they

00:00:12,370 --> 00:00:18,490
hear open PGP they think about canoe PG

00:00:14,139 --> 00:00:20,349
and we've learned from that and we have

00:00:18,490 --> 00:00:22,630
a new implementation and it's in rust

00:00:20,349 --> 00:00:26,500
and I want to tell you about some of our

00:00:22,630 --> 00:00:29,800
experiences trying to implement open PGP

00:00:26,500 --> 00:00:32,050
in rust and this talk is actually done

00:00:29,800 --> 00:00:35,950
with my colleague Eustace winter who's

00:00:32,050 --> 00:00:39,580
down there and it's a from both of us

00:00:35,950 --> 00:00:42,250
basically so Sequoia what is Sequoia the

00:00:39,580 --> 00:00:44,860
first commit was done in October 16th

00:00:42,250 --> 00:00:49,270
2017 so the project is just over a year

00:00:44,860 --> 00:00:50,970
old and we decided to do a new open PGP

00:00:49,270 --> 00:00:54,490
implementation for a number of reasons

00:00:50,970 --> 00:00:56,560
but kind of the primary motivator was

00:00:54,490 --> 00:00:59,560
based on our experience using a new PG

00:00:56,560 --> 00:01:02,260
so we actually hacked on canoe PT for

00:00:59,560 --> 00:01:03,700
several years and we discovered that

00:01:02,260 --> 00:01:07,240
canoe PT is actually kind of hard to

00:01:03,700 --> 00:01:10,600
modify the project itself is now 21

00:01:07,240 --> 00:01:13,690
almost 22 years old the code has grown

00:01:10,600 --> 00:01:15,909
organically there aren't that many unit

00:01:13,690 --> 00:01:17,920
tests and one thing we observed that

00:01:15,909 --> 00:01:22,210
there's a lot of tight component

00:01:17,920 --> 00:01:24,900
coupling talking to developers we've

00:01:22,210 --> 00:01:27,190
discovered that canoe PG API isn't so

00:01:24,900 --> 00:01:28,960
easy to use there they're unsatisfied

00:01:27,190 --> 00:01:30,760
with it it doesn't do exactly what they

00:01:28,960 --> 00:01:33,490
want and they end up writing a lot of

00:01:30,760 --> 00:01:36,100
code in order to work around the new

00:01:33,490 --> 00:01:40,150
peachy's idea of how things should be

00:01:36,100 --> 00:01:41,920
done and one of the major reasons we

00:01:40,150 --> 00:01:43,680
decided to use rust is its safety

00:01:41,920 --> 00:01:47,260
properties and particular memory safety

00:01:43,680 --> 00:01:50,320
so we thought it was irresponsible to do

00:01:47,260 --> 00:01:52,659
a new security sensitive tool and a

00:01:50,320 --> 00:01:55,479
language that didn't offer the type of

00:01:52,659 --> 00:01:56,890
things that rust offered and finally

00:01:55,479 --> 00:01:59,409
there was a non-technical reason to

00:01:56,890 --> 00:02:01,720
consider doing a new open PGP

00:01:59,409 --> 00:02:05,020
implementation and that's because canoe

00:02:01,720 --> 00:02:07,060
PG is under the GPL and unfortunately

00:02:05,020 --> 00:02:12,579
you can't use GPL software in the iOS

00:02:07,060 --> 00:02:13,989
store or the iOS App Store so who are we

00:02:12,579 --> 00:02:15,489
who's working on this project there's

00:02:13,989 --> 00:02:16,819
three of us who are working on it more

00:02:15,489 --> 00:02:19,040
or less full-time

00:02:16,819 --> 00:02:22,099
and they're down here so just this and

00:02:19,040 --> 00:02:24,019
also Kai and we all were former new PG

00:02:22,099 --> 00:02:27,230
developers we worked there for two two

00:02:24,019 --> 00:02:29,510
and a half years and since the fall of

00:02:27,230 --> 00:02:32,090
2017 so since the project started

00:02:29,510 --> 00:02:34,549
we've been at pep and pep stands for a

00:02:32,090 --> 00:02:36,920
pretty easy privacy and pep is working

00:02:34,549 --> 00:02:41,659
on tools to make in particular email

00:02:36,920 --> 00:02:44,359
encryption easy to use for everyone our

00:02:41,659 --> 00:02:47,620
funding comes primarily from pep which

00:02:44,359 --> 00:02:50,450
is there's a company aspect and also a

00:02:47,620 --> 00:02:52,750
foundation and the wall hall and staff

00:02:50,450 --> 00:02:55,540
dome is also providing some funding and

00:02:52,750 --> 00:02:58,669
one thing that we hope to do in the

00:02:55,540 --> 00:03:00,859
middle term is actually diversify our

00:02:58,669 --> 00:03:03,230
funding base so we're all at the pep

00:03:00,859 --> 00:03:04,639
foundation and it'll be nice if there

00:03:03,230 --> 00:03:09,199
were other organizations involved as

00:03:04,639 --> 00:03:11,659
well so that's my introduction to

00:03:09,199 --> 00:03:13,519
Sequoia but what is open PGP so I've

00:03:11,659 --> 00:03:15,560
talked to a few people here today and

00:03:13,519 --> 00:03:16,669
although many people know about can UPG

00:03:15,560 --> 00:03:18,409
there are some people who aren't that

00:03:16,669 --> 00:03:21,590
familiar with it so I want to give you a

00:03:18,409 --> 00:03:25,489
very brief introduction it's a standard

00:03:21,590 --> 00:03:29,090
for encryption data authentication and

00:03:25,489 --> 00:03:32,439
integrity and the standard is was

00:03:29,090 --> 00:03:35,959
produced by the IETF RFC 4880 and

00:03:32,439 --> 00:03:38,659
although people associate open PGP with

00:03:35,959 --> 00:03:41,000
email it's not just for email use for

00:03:38,659 --> 00:03:42,439
lots of things and it's actually a core

00:03:41,000 --> 00:03:44,900
part of the internet so it's used for

00:03:42,439 --> 00:03:47,030
package signing whenever you download a

00:03:44,900 --> 00:03:49,099
package from a Debian archive apt

00:03:47,030 --> 00:03:51,590
automatically checks to make sure that

00:03:49,099 --> 00:03:53,299
the signature is good commit signing

00:03:51,590 --> 00:03:56,150
document signing backups archives

00:03:53,299 --> 00:03:56,659
encrypted storage in the cloud encrypted

00:03:56,150 --> 00:03:59,389
sneakernet

00:03:56,659 --> 00:04:01,459
so if you have a USB stick and you want

00:03:59,389 --> 00:04:04,219
to encrypt some files then bring them

00:04:01,459 --> 00:04:06,590
someplace else you can't use something

00:04:04,219 --> 00:04:08,449
like signal for that you need something

00:04:06,590 --> 00:04:10,579
like a new key chain there are password

00:04:08,449 --> 00:04:13,039
managers that use open PGP you can do

00:04:10,579 --> 00:04:15,549
remote authentication using open PGP so

00:04:13,039 --> 00:04:18,709
it's a very general purpose standard and

00:04:15,549 --> 00:04:20,959
it's a packet based format so an open

00:04:18,709 --> 00:04:23,630
PGP message is composed of a number of

00:04:20,959 --> 00:04:25,820
packets in a certain sense you can

00:04:23,630 --> 00:04:29,440
compose them in an arbitrary manner but

00:04:25,820 --> 00:04:32,230
the standard specifies a grammar so

00:04:29,440 --> 00:04:34,990
it's not as flexible as many people make

00:04:32,230 --> 00:04:36,790
it out to be when you have some data

00:04:34,990 --> 00:04:38,320
that you want to encrypt of something

00:04:36,790 --> 00:04:40,480
you first pack it into a container

00:04:38,320 --> 00:04:42,130
called a literal data packet if you want

00:04:40,480 --> 00:04:44,530
to sign it then you actually use two

00:04:42,130 --> 00:04:46,960
packets a signature and a one-pass

00:04:44,530 --> 00:04:48,400
signature packet and the reason that you

00:04:46,960 --> 00:04:52,300
have two things is that it allows

00:04:48,400 --> 00:04:54,400
streaming operations so open PGP is not

00:04:52,300 --> 00:04:56,770
only used for email it's used for

00:04:54,400 --> 00:04:58,450
backups as I said before backups can be

00:04:56,770 --> 00:05:02,170
gigabytes or even terabytes large

00:04:58,450 --> 00:05:03,990
obviously doesn't fit in memory and so

00:05:02,170 --> 00:05:06,190
somehow you have to be able to stream it

00:05:03,990 --> 00:05:07,600
not only when you're doing the

00:05:06,190 --> 00:05:10,990
verification process but also when

00:05:07,600 --> 00:05:14,320
you're generating it and this enables

00:05:10,990 --> 00:05:16,420
that streaming mechanism there's a

00:05:14,320 --> 00:05:18,040
compression container a so-called Sipe

00:05:16,420 --> 00:05:20,440
container which is stands for

00:05:18,040 --> 00:05:23,050
symmetrically encrypted data packet so

00:05:20,440 --> 00:05:25,090
like most crypto schemes you don't use

00:05:23,050 --> 00:05:28,510
public key encryption to encrypt large

00:05:25,090 --> 00:05:30,400
amounts of data you generate a session

00:05:28,510 --> 00:05:32,440
key you use something like a EES to

00:05:30,400 --> 00:05:34,480
encrypt the bulk data and then you only

00:05:32,440 --> 00:05:36,010
encrypt the session key using the very

00:05:34,480 --> 00:05:38,830
slow and expensive public key

00:05:36,010 --> 00:05:41,800
cryptography so let's look at an open

00:05:38,830 --> 00:05:43,870
PGP message in detail let's say we want

00:05:41,800 --> 00:05:46,960
to say hello to someone so we take our

00:05:43,870 --> 00:05:49,600
data and we encapsulate it in an open

00:05:46,960 --> 00:05:51,340
PGP packet in particular a literal data

00:05:49,600 --> 00:05:53,530
packet so now we don't just have some

00:05:51,340 --> 00:05:56,560
random data it has a format there's this

00:05:53,530 --> 00:05:58,300
container format literal data and then

00:05:56,560 --> 00:06:00,160
we want to sign it so we stick this one

00:05:58,300 --> 00:06:02,380
path signature in the front and the

00:06:00,160 --> 00:06:04,480
signature at the end and then we encrypt

00:06:02,380 --> 00:06:06,610
it we put the whole thing in a cite

00:06:04,480 --> 00:06:09,460
container and at the front we have the

00:06:06,610 --> 00:06:11,919
PK Esk which is used for containing the

00:06:09,460 --> 00:06:13,840
encrypted session key and if you think

00:06:11,919 --> 00:06:16,090
about what I just described it functions

00:06:13,840 --> 00:06:19,840
a little bit like a pipe so you take

00:06:16,090 --> 00:06:22,720
your data you pipe it through a literal

00:06:19,840 --> 00:06:24,880
data container type thing you pipe that

00:06:22,720 --> 00:06:27,910
into a significant generation type thing

00:06:24,880 --> 00:06:31,690
and you pipe that into a encryption type

00:06:27,910 --> 00:06:33,700
thing and by the way open PGP messages

00:06:31,690 --> 00:06:35,800
are also used for key exchange so if you

00:06:33,700 --> 00:06:38,560
want to send somebody a key like your

00:06:35,800 --> 00:06:40,660
key in particular you would also use an

00:06:38,560 --> 00:06:43,030
open PGP message and there's a public

00:06:40,660 --> 00:06:44,650
key packet a public sub key packet

00:06:43,030 --> 00:06:48,460
user ID pack and a bunch of others that

00:06:44,650 --> 00:06:50,350
aren't quite so important so that's an

00:06:48,460 --> 00:06:52,480
introduction to open PGP and now I want

00:06:50,350 --> 00:06:53,530
to get into our implementation and I

00:06:52,480 --> 00:06:55,150
don't want to show you too much of our

00:06:53,530 --> 00:06:58,240
API but what I want to show you instead

00:06:55,150 --> 00:07:01,990
is sort of the challenges that we faced

00:06:58,240 --> 00:07:04,270
trying to implement Sequoia in rust and

00:07:01,990 --> 00:07:06,160
there are five major challenges that we

00:07:04,270 --> 00:07:08,080
encountered and then I'm going to

00:07:06,160 --> 00:07:10,900
present today so we have this this

00:07:08,080 --> 00:07:11,650
pipeline that we want to process and you

00:07:10,900 --> 00:07:13,600
can imagine that you have the

00:07:11,650 --> 00:07:14,920
application on top and it's reading from

00:07:13,600 --> 00:07:17,470
some sort of reader so you have IO

00:07:14,920 --> 00:07:19,300
reader so we can actually because it

00:07:17,470 --> 00:07:23,260
looks like a pipeline create a stack of

00:07:19,300 --> 00:07:25,240
readers now the hashed reader which is

00:07:23,260 --> 00:07:27,880
used for generating the signature isn't

00:07:25,240 --> 00:07:30,010
technically transforming the data but it

00:07:27,880 --> 00:07:32,820
is doing some sort of computations and

00:07:30,010 --> 00:07:36,160
so visualizing it as a pipe is still

00:07:32,820 --> 00:07:37,300
useful conceptually and here we see that

00:07:36,160 --> 00:07:39,430
there are kind of three elements in our

00:07:37,300 --> 00:07:40,360
pipe but in practice there are other

00:07:39,430 --> 00:07:42,460
things that you're worried about

00:07:40,360 --> 00:07:45,580
for instance framing so you want to

00:07:42,460 --> 00:07:48,550
enforce packet boundaries open PGP has

00:07:45,580 --> 00:07:51,250
the idea of a chunk encoding scheme like

00:07:48,550 --> 00:07:54,700
in HTTP and these things somehow some

00:07:51,250 --> 00:07:57,850
have to be dealt with as well and using

00:07:54,700 --> 00:07:59,770
this type of pipeline idea is natural

00:07:57,850 --> 00:08:01,900
and it offers a nice separation of

00:07:59,770 --> 00:08:05,590
concerns while still preserving this

00:08:01,900 --> 00:08:09,190
idea of streaming process streamed

00:08:05,590 --> 00:08:11,110
processing so the first thing that you

00:08:09,190 --> 00:08:13,060
do when you start using open PGP or

00:08:11,110 --> 00:08:15,340
start writing an open PGP implementation

00:08:13,060 --> 00:08:17,860
is that you want to somehow parse a

00:08:15,340 --> 00:08:20,440
message and before coming up with some

00:08:17,860 --> 00:08:23,050
sort of crazy API the message looks a

00:08:20,440 --> 00:08:25,810
little bit like a tree so you kind of

00:08:23,050 --> 00:08:27,370
start implementing a parser you do a

00:08:25,810 --> 00:08:29,500
depth-first traversal of the open PGP

00:08:27,370 --> 00:08:31,510
message this looks a little bit like the

00:08:29,500 --> 00:08:34,240
visitor pattern and it basically all

00:08:31,510 --> 00:08:35,740
happens on the stack and when you visit

00:08:34,240 --> 00:08:38,860
each packet then you can imagine calling

00:08:35,740 --> 00:08:39,520
some sort of callback so here's the

00:08:38,860 --> 00:08:42,760
basic idea

00:08:39,520 --> 00:08:43,900
we have a compressed data packet and at

00:08:42,760 --> 00:08:47,380
the very top we have a parse function

00:08:43,900 --> 00:08:50,410
and we read the the algorithm we

00:08:47,380 --> 00:08:52,750
generate a compressed packets and push

00:08:50,410 --> 00:08:55,960
the filter on to our reader stack and

00:08:52,750 --> 00:08:56,810
then we call parse which is our

00:08:55,960 --> 00:09:01,130
general-purpose

00:08:56,810 --> 00:09:03,830
Luxor for processing any packet because

00:09:01,130 --> 00:09:08,300
a compressed packet can contain any

00:09:03,830 --> 00:09:10,850
other type of packet when you try to

00:09:08,300 --> 00:09:12,950
compile that Russ complains it says

00:09:10,850 --> 00:09:15,260
you've reached the recursion limit while

00:09:12,950 --> 00:09:18,410
instantiating there's really really

00:09:15,260 --> 00:09:23,330
really long pipe types so what happened

00:09:18,410 --> 00:09:25,670
there well it turns out that rust isn't

00:09:23,330 --> 00:09:31,070
able to recognize base cases when you do

00:09:25,670 --> 00:09:34,130
an recursion with the type system and we

00:09:31,070 --> 00:09:37,100
have the generic parser calling the

00:09:34,130 --> 00:09:39,620
compressed data packet parser which in

00:09:37,100 --> 00:09:43,220
turn calls the generic parser and so we

00:09:39,620 --> 00:09:44,690
get that really long type and there's

00:09:43,220 --> 00:09:47,330
kind of the obvious thing which is that

00:09:44,690 --> 00:09:49,790
well okay we we need to articulate a

00:09:47,330 --> 00:09:52,270
base case but we can't tell the compiler

00:09:49,790 --> 00:09:55,070
that there's no way to express that in

00:09:52,270 --> 00:09:56,630
rust right now but there's also this

00:09:55,070 --> 00:09:58,820
other aspect which is kind of

00:09:56,630 --> 00:10:00,740
interesting and insightful I think which

00:09:58,820 --> 00:10:02,810
is that generics can result in a lot of

00:10:00,740 --> 00:10:04,640
kind of invisible types that maybe you

00:10:02,810 --> 00:10:07,720
don't actually need in practice because

00:10:04,640 --> 00:10:10,520
in general nobody's going to create 16

00:10:07,720 --> 00:10:12,020
levels of compression containers it's

00:10:10,520 --> 00:10:15,080
just going to make your message bigger

00:10:12,020 --> 00:10:18,140
and bigger and in order to work around

00:10:15,080 --> 00:10:19,760
this you need to use dynamic dispatch

00:10:18,140 --> 00:10:22,070
and so if you've been in the rest

00:10:19,760 --> 00:10:24,740
community and when you start learning

00:10:22,070 --> 00:10:25,850
rust you hear action erics generics they

00:10:24,740 --> 00:10:28,460
solve all your problems and they're

00:10:25,850 --> 00:10:31,220
super fast but you really do sometimes

00:10:28,460 --> 00:10:36,470
want dynamic dispatch and avoiding

00:10:31,220 --> 00:10:38,000
boxing is oftentimes completely

00:10:36,470 --> 00:10:42,560
unnecessary and only results in more

00:10:38,000 --> 00:10:45,020
problems so we need to think about a

00:10:42,560 --> 00:10:46,070
different way to do the parsing and we

00:10:45,020 --> 00:10:47,900
want to use some sort of dynamic

00:10:46,070 --> 00:10:51,950
dispatch in order to create these

00:10:47,900 --> 00:10:55,970
filters so we create a generic reader

00:10:51,950 --> 00:10:57,920
stack so what that means is that we're

00:10:55,970 --> 00:10:59,000
operating on some sort of reader and we

00:10:57,920 --> 00:11:02,750
don't actually know what the concrete

00:10:59,000 --> 00:11:05,089
type is and then we're done parsing it

00:11:02,750 --> 00:11:07,610
and we need to pop off the current

00:11:05,089 --> 00:11:10,790
container and continue working

00:11:07,610 --> 00:11:12,920
so we need something like into inner but

00:11:10,790 --> 00:11:15,170
due to type erasure we don't actually

00:11:12,920 --> 00:11:16,700
know what the concrete type is right we

00:11:15,170 --> 00:11:20,089
have some sort of dynamic dispatch going

00:11:16,700 --> 00:11:22,339
on so how can we recover the inner so if

00:11:20,089 --> 00:11:24,440
you've looked at a bunch of rust types

00:11:22,339 --> 00:11:26,870
that do this the type of encapsulation

00:11:24,440 --> 00:11:29,390
then the into in our method is usually

00:11:26,870 --> 00:11:31,370
implemented on the concrete type but we

00:11:29,390 --> 00:11:33,470
needed for trait objects but trait

00:11:31,370 --> 00:11:35,630
objects are unsigned right when you

00:11:33,470 --> 00:11:37,850
think into inner you consume the object

00:11:35,630 --> 00:11:41,810
and then you give back the inner thing

00:11:37,850 --> 00:11:45,440
and if trait objects aren't size and you

00:11:41,810 --> 00:11:48,050
can't actually pass self because self

00:11:45,440 --> 00:11:50,660
has to be saved well it turns out that

00:11:48,050 --> 00:11:52,519
there's a fourth variant of the self

00:11:50,660 --> 00:11:54,560
argument so you can have self with it

00:11:52,519 --> 00:11:58,070
just a normal reference a mutable

00:11:54,560 --> 00:12:01,339
reference or an old one or you can have

00:11:58,070 --> 00:12:04,480
a boxed self so this is a discovery that

00:12:01,339 --> 00:12:06,410
I found after looking at the

00:12:04,480 --> 00:12:10,850
documentation for a long time and

00:12:06,410 --> 00:12:12,260
chatting on IRC and it was a very

00:12:10,850 --> 00:12:14,149
insightful thing for me and I hope it's

00:12:12,260 --> 00:12:16,519
also a little bit insightful for you so

00:12:14,149 --> 00:12:18,740
we go ahead and we take self and it's a

00:12:16,519 --> 00:12:23,149
box and now we can work with our trade

00:12:18,740 --> 00:12:24,860
object and in this particular API we

00:12:23,149 --> 00:12:27,860
don't just return the inner we turn an

00:12:24,860 --> 00:12:30,050
option inner and this is needed in order

00:12:27,860 --> 00:12:31,910
to handle the recursion base case where

00:12:30,050 --> 00:12:36,199
you're reading for instance from a file

00:12:31,910 --> 00:12:38,870
and of course a file has no inner but

00:12:36,199 --> 00:12:41,089
working with box objects is ugly right

00:12:38,870 --> 00:12:42,829
I'm asking that you have a reader and

00:12:41,089 --> 00:12:45,920
it's on the stack why do you have to box

00:12:42,829 --> 00:12:48,949
it if it's just on the stack so if all

00:12:45,920 --> 00:12:51,829
of your API require is boxed reader or

00:12:48,949 --> 00:12:53,870
bufferedreader as we call it then you're

00:12:51,829 --> 00:12:57,339
doing this boxing and unboxing and it's

00:12:53,870 --> 00:13:00,170
just kind of it's not terribly agronomic

00:12:57,339 --> 00:13:01,820
you can use a transparent forwarder so

00:13:00,170 --> 00:13:05,300
you do implement bufferedreader for

00:13:01,820 --> 00:13:08,990
boxed bufferedreader and then you take

00:13:05,300 --> 00:13:10,370
self you do as ref as a ref is a neat

00:13:08,990 --> 00:13:13,010
little function that takes a box and

00:13:10,370 --> 00:13:15,740
turns it into a reference and that you

00:13:13,010 --> 00:13:17,480
can call the actual method that you want

00:13:15,740 --> 00:13:19,100
to call on the inner thing or not in the

00:13:17,480 --> 00:13:21,710
inner thing but on the

00:13:19,100 --> 00:13:24,950
box thing and this happens without

00:13:21,710 --> 00:13:27,320
actually having a concrete type it's all

00:13:24,950 --> 00:13:29,060
dynamic dispatch and so now we can pass

00:13:27,320 --> 00:13:30,770
a box bufferedreader wherever a

00:13:29,060 --> 00:13:32,840
bufferedreader is needed which means

00:13:30,770 --> 00:13:34,760
that we can simplify our API right

00:13:32,840 --> 00:13:36,650
because our API doesn't say boxed

00:13:34,760 --> 00:13:38,210
buffered reader says bufferedreader and

00:13:36,650 --> 00:13:39,800
if we have a box buffer drita we just

00:13:38,210 --> 00:13:42,490
pass it in and we can also pass in

00:13:39,800 --> 00:13:47,450
normal buffered readers so that's cool

00:13:42,490 --> 00:13:48,920
but it creates a linked list so let's

00:13:47,450 --> 00:13:50,840
look at our API a little bit more

00:13:48,920 --> 00:13:53,150
closely we have a new method which we

00:13:50,840 --> 00:13:55,460
use for constructing in this case a

00:13:53,150 --> 00:13:57,020
bufferedreader limiter which is used to

00:13:55,460 --> 00:14:00,610
make sure that you can only read so many

00:13:57,020 --> 00:14:04,220
bytes from a particular buffered reader

00:14:00,610 --> 00:14:05,660
so we pass in a reader and since we have

00:14:04,220 --> 00:14:07,990
this nice transparent florid or we can

00:14:05,660 --> 00:14:10,670
also passed in a boxed buffered reader

00:14:07,990 --> 00:14:13,640
and then we have into inner well into an

00:14:10,670 --> 00:14:15,320
ER take the box self and returns the

00:14:13,640 --> 00:14:19,250
inner self now the inner self is an R

00:14:15,320 --> 00:14:22,730
and R is a bufferedreader or something

00:14:19,250 --> 00:14:24,350
an implement bufferedreader and due to

00:14:22,730 --> 00:14:27,650
the return type we're forced to box it

00:14:24,350 --> 00:14:31,190
so we have to do box R but if R happened

00:14:27,650 --> 00:14:34,760
to be already boxed we now have two

00:14:31,190 --> 00:14:36,170
boxes and if you pop things on the stack

00:14:34,760 --> 00:14:37,550
and then pop them off and pop something

00:14:36,170 --> 00:14:39,070
else in the stack and pop it off and you

00:14:37,550 --> 00:14:44,000
do that a whole bunch of times

00:14:39,070 --> 00:14:47,360
you now have n boxes so you have this

00:14:44,000 --> 00:14:49,010
enormous link list and we actually

00:14:47,360 --> 00:14:51,620
discovered this bug when we were trying

00:14:49,010 --> 00:14:53,360
to parse the whole sks dump so we were

00:14:51,620 --> 00:14:56,000
going really fast we're doing about 1.5

00:14:53,360 --> 00:14:57,500
million packets per second and then

00:14:56,000 --> 00:15:00,950
after 10 seconds we were down to a half

00:14:57,500 --> 00:15:02,510
a million packets and after 20 seconds

00:15:00,950 --> 00:15:05,330
we were down to a few thousand packets

00:15:02,510 --> 00:15:06,770
per second and useless took a look and

00:15:05,330 --> 00:15:08,570
try to figure out what's going on and

00:15:06,770 --> 00:15:10,880
then realized that we created this

00:15:08,570 --> 00:15:13,490
enormous link list that had millions of

00:15:10,880 --> 00:15:15,460
elements in it so that was slow

00:15:13,490 --> 00:15:18,050
completely blew the cache and we

00:15:15,460 --> 00:15:20,900
realized that we had to change the API

00:15:18,050 --> 00:15:22,430
so that was a fortunate thing which was

00:15:20,900 --> 00:15:25,520
a consequence of this kind of type of

00:15:22,430 --> 00:15:30,920
ratio and one of the organ Amba CASP x

00:15:25,520 --> 00:15:32,600
of rusts right so there are still kind

00:15:30,920 --> 00:15:35,389
of these these edges there even

00:15:32,600 --> 00:15:39,019
they offer this amazing amount of

00:15:35,389 --> 00:15:40,190
convenience so now we have our

00:15:39,019 --> 00:15:41,810
bufferedreader interface how are we

00:15:40,190 --> 00:15:43,399
gonna do a better parser interface

00:15:41,810 --> 00:15:45,680
because this visitor pattern is just not

00:15:43,399 --> 00:15:48,170
what we want right that we don't want to

00:15:45,680 --> 00:15:51,500
use callbacks it's not rust like we want

00:15:48,170 --> 00:15:53,709
to get a radar-like API and as I already

00:15:51,500 --> 00:15:56,360
said it's very important that our API

00:15:53,709 --> 00:15:58,519
supports streaming because we want to be

00:15:56,360 --> 00:16:02,089
able to parse this these parse these big

00:15:58,519 --> 00:16:03,860
messages so how do we do an iterator

00:16:02,089 --> 00:16:05,930
interface well what if we just use the

00:16:03,860 --> 00:16:07,930
iterator interface that russ provides it

00:16:05,930 --> 00:16:11,360
would look like this

00:16:07,930 --> 00:16:13,970
we'd instantiate instantiate a packet

00:16:11,360 --> 00:16:17,600
parser given some underlying reader like

00:16:13,970 --> 00:16:21,529
a file and then we call it err and we

00:16:17,600 --> 00:16:23,360
iterate all of the data now we want to

00:16:21,529 --> 00:16:24,920
support streaming and we have our

00:16:23,360 --> 00:16:28,610
literal data packet so we want to copy

00:16:24,920 --> 00:16:30,170
it out to say standard out well if we're

00:16:28,610 --> 00:16:32,240
working with the packet itself the thing

00:16:30,170 --> 00:16:35,060
that the iterator returned we can't

00:16:32,240 --> 00:16:37,730
actually do that because the thing that

00:16:35,060 --> 00:16:41,420
was actually returned has no reference

00:16:37,730 --> 00:16:43,459
to the packet parser anymore right so

00:16:41,420 --> 00:16:46,910
the the reader that we have is in the

00:16:43,459 --> 00:16:48,740
packet parser but the item that we got

00:16:46,910 --> 00:16:51,170
back from the iterator has no connection

00:16:48,740 --> 00:16:54,250
to the packet parser anymore so we can

00:16:51,170 --> 00:16:58,220
only return fully processed packets

00:16:54,250 --> 00:16:59,689
that's not good for streaming operations

00:16:58,220 --> 00:17:01,639
we'd have to read everything into memory

00:16:59,689 --> 00:17:08,449
so the alternative is that we go ahead

00:17:01,639 --> 00:17:09,980
and pass the reader in the iterator with

00:17:08,449 --> 00:17:11,360
for instance a reference well it turns

00:17:09,980 --> 00:17:12,620
out you can't do that due to lifetimes

00:17:11,360 --> 00:17:15,350
because you could have multiple items

00:17:12,620 --> 00:17:16,730
that are alive at the same time and we

00:17:15,350 --> 00:17:17,839
definitely require a mutable reference

00:17:16,730 --> 00:17:18,770
right because we're reading from a file

00:17:17,839 --> 00:17:25,120
so we have to do some sort of

00:17:18,770 --> 00:17:27,980
adjustments on the cursor so the

00:17:25,120 --> 00:17:32,120
iterator API just doesn't provide what

00:17:27,980 --> 00:17:34,159
we want and the other problem is that we

00:17:32,120 --> 00:17:36,440
kind of want to preserve the structure

00:17:34,159 --> 00:17:39,080
of the open PGP message right it looks

00:17:36,440 --> 00:17:40,400
like a tree and using the iterator it

00:17:39,080 --> 00:17:42,110
effectively flattens the whole tree

00:17:40,400 --> 00:17:44,030
structure so that's a little bit sad

00:17:42,110 --> 00:17:45,590
that we lost out information there are

00:17:44,030 --> 00:17:49,640
ways to recover it but

00:17:45,590 --> 00:17:52,250
it's just a side observation so how can

00:17:49,640 --> 00:17:53,650
we create an iterator like API that

00:17:52,250 --> 00:17:55,669
still supports all of our requirements

00:17:53,650 --> 00:18:02,690
well this is what we came up with in the

00:17:55,669 --> 00:18:05,929
end we use a while let and we have a

00:18:02,690 --> 00:18:10,340
type called PPR or a packet parser

00:18:05,929 --> 00:18:12,080
result and the packet parser result

00:18:10,340 --> 00:18:14,779
contains the packet that we're currently

00:18:12,080 --> 00:18:17,230
parsing so we're still able to do

00:18:14,779 --> 00:18:20,720
streaming operations on the current

00:18:17,230 --> 00:18:23,419
packet and then when we're done doing

00:18:20,720 --> 00:18:26,390
the streaming operations we get the next

00:18:23,419 --> 00:18:28,460
object and at the same time the packet

00:18:26,390 --> 00:18:30,440
parser returns the item that we're

00:18:28,460 --> 00:18:33,890
currently working on and now we own the

00:18:30,440 --> 00:18:36,230
item so we can go ahead and squirrel it

00:18:33,890 --> 00:18:37,640
away and a vector if we want which you

00:18:36,230 --> 00:18:40,760
sometimes want to do when you have for

00:18:37,640 --> 00:18:43,399
instance the PKS Kay what we can just

00:18:40,760 --> 00:18:44,720
throw it away so they're kind of three

00:18:43,399 --> 00:18:47,240
phases the first phase is where we do

00:18:44,720 --> 00:18:49,309
the streaming then we have the next

00:18:47,240 --> 00:18:53,390
phase and then we have the phase where

00:18:49,309 --> 00:18:56,690
we actually own the packet and here

00:18:53,390 --> 00:19:00,140
we're using PP recurse to get the next

00:18:56,690 --> 00:19:01,309
packet and so you're at a container

00:19:00,140 --> 00:19:03,080
boundary for instance you have a

00:19:01,309 --> 00:19:05,360
compression container when you use

00:19:03,080 --> 00:19:08,559
recurse it steps into the container and

00:19:05,360 --> 00:19:10,880
gets the next packet but if you use next

00:19:08,559 --> 00:19:13,100
it treats the container as if it were

00:19:10,880 --> 00:19:17,120
cast an opaque packet and moves to the

00:19:13,100 --> 00:19:23,600
next thing in the tree so the sibling or

00:19:17,120 --> 00:19:25,640
a potential uncle or ons the next

00:19:23,600 --> 00:19:29,059
challenge that we had was dealing with

00:19:25,640 --> 00:19:32,990
callbacks that saves state so what do

00:19:29,059 --> 00:19:34,669
you have a callback sometimes you want

00:19:32,990 --> 00:19:39,020
to collect some statistics for instance

00:19:34,669 --> 00:19:41,390
so you want to do some processing or you

00:19:39,020 --> 00:19:43,039
somehow need to return a result and it's

00:19:41,390 --> 00:19:47,390
inconvenient to kind of return it via

00:19:43,039 --> 00:19:50,179
the callbacks result and see you do this

00:19:47,390 --> 00:19:52,580
using a cookie so here we have a

00:19:50,179 --> 00:19:55,640
callback state at the top with cues of

00:19:52,580 --> 00:19:58,750
structure then we have our actual

00:19:55,640 --> 00:20:00,820
callback so the thing that our

00:19:58,750 --> 00:20:03,580
function is going to call and it takes

00:20:00,820 --> 00:20:06,970
the cookie then we convert this void

00:20:03,580 --> 00:20:08,260
pointer into our actual cookies type we

00:20:06,970 --> 00:20:09,700
can do whatever type of processing we

00:20:08,260 --> 00:20:15,160
want we save our information in there

00:20:09,700 --> 00:20:17,620
and then when the function returns our

00:20:15,160 --> 00:20:20,290
state here at the bottom is filled with

00:20:17,620 --> 00:20:25,090
whatever the callback insert it into the

00:20:20,290 --> 00:20:28,630
cookie now that's the idiomatic way to

00:20:25,090 --> 00:20:30,400
do that and see button rust that's hard

00:20:28,630 --> 00:20:33,820
to do because you wouldn't need a

00:20:30,400 --> 00:20:37,990
mutable reference and all of a sudden

00:20:33,820 --> 00:20:41,890
you get some sort of crazy errors from

00:20:37,990 --> 00:20:44,160
rusts bar or checker and it doesn't work

00:20:41,890 --> 00:20:46,780
out so nicely so what can we do instead

00:20:44,160 --> 00:20:48,580
well in rust you don't need to use a

00:20:46,780 --> 00:20:51,220
cookie you can use a trait because a

00:20:48,580 --> 00:20:54,040
trait can transparently encapsulate

00:20:51,220 --> 00:20:57,750
whatever type of state you want so here

00:20:54,040 --> 00:21:00,970
we have a so-called callback helper

00:20:57,750 --> 00:21:03,400
which has a function signature in it

00:21:00,970 --> 00:21:05,440
called callback and it has no cookie in

00:21:03,400 --> 00:21:08,380
it right this is the thing that the

00:21:05,440 --> 00:21:11,380
function is going to call and then we

00:21:08,380 --> 00:21:14,410
implement this trait for our own type so

00:21:11,380 --> 00:21:16,060
for our cookie so here we have a struck

00:21:14,410 --> 00:21:19,990
callback and we can insert whatever

00:21:16,060 --> 00:21:24,330
fields we want in there and then when

00:21:19,990 --> 00:21:24,330
our function down here at the bottom

00:21:24,450 --> 00:21:29,140
wants to invoke the callback we pass it

00:21:27,700 --> 00:21:31,360
the structure which implements the trait

00:21:29,140 --> 00:21:33,700
and then the callback calls that

00:21:31,360 --> 00:21:36,520
particular method and it works

00:21:33,700 --> 00:21:38,020
beautifully and there's no sort of

00:21:36,520 --> 00:21:39,190
playing with the type system or fighting

00:21:38,020 --> 00:21:44,050
with the borrower checker it's it's very

00:21:39,190 --> 00:21:46,120
natural and when you see this it is kind

00:21:44,050 --> 00:21:48,280
of obvious oh yeah that's an easy way to

00:21:46,120 --> 00:21:54,790
do it but it took us a while to figure

00:21:48,280 --> 00:21:58,920
out that pattern in sequoia we use

00:21:54,790 --> 00:22:02,020
failure which is a very nice trait and

00:21:58,920 --> 00:22:04,840
we also use general-purpose traits like

00:22:02,020 --> 00:22:07,080
IO read and we want our consumers to be

00:22:04,840 --> 00:22:09,429
able to get our rich errors somehow and

00:22:07,080 --> 00:22:12,280
you want to be able to smuggle out these

00:22:09,429 --> 00:22:15,040
failures somehow via IO error

00:22:12,280 --> 00:22:18,640
you can use this or do this using

00:22:15,040 --> 00:22:21,130
failure compat so here I have an example

00:22:18,640 --> 00:22:24,820
of how you can do this we do a little

00:22:21,130 --> 00:22:26,410
bit of down casting and either we have

00:22:24,820 --> 00:22:28,810
an i/o error or maybe we have a failure

00:22:26,410 --> 00:22:30,550
and then we can do some sort of

00:22:28,810 --> 00:22:35,740
conversion it's all a little bit magic

00:22:30,550 --> 00:22:37,480
and then you can recover it from here we

00:22:35,740 --> 00:22:42,310
have IO copy we got our result we do a

00:22:37,480 --> 00:22:44,320
map error we can recover our failure or

00:22:42,310 --> 00:22:48,780
if we have a plain IO error we get to

00:22:44,320 --> 00:22:52,600
play an IO error back verifier is our

00:22:48,780 --> 00:22:54,460
custom reader that supports the failure

00:22:52,600 --> 00:22:56,140
interface and of course I'll copy

00:22:54,460 --> 00:22:59,050
doesn't but still we're able to somehow

00:22:56,140 --> 00:23:01,240
get it back we've opened up a an issue

00:22:59,050 --> 00:23:03,130
and provided a at least partial solution

00:23:01,240 --> 00:23:05,140
for the failure crate and we hope that

00:23:03,130 --> 00:23:08,470
without boats we'll we'll take a look at

00:23:05,140 --> 00:23:11,350
it eventually so using this pattern

00:23:08,470 --> 00:23:13,810
you're still able to use these rich

00:23:11,350 --> 00:23:17,200
errors that you have or work with them

00:23:13,810 --> 00:23:20,680
even though the current API doesn't

00:23:17,200 --> 00:23:22,380
quite support them so those are the

00:23:20,680 --> 00:23:24,100
matrix challenges that we faced and

00:23:22,380 --> 00:23:28,030
maybe I've kind of piqued your interest

00:23:24,100 --> 00:23:28,780
in Sequoia so I'm going to tell you a

00:23:28,030 --> 00:23:31,180
little bit about it

00:23:28,780 --> 00:23:35,740
Sequoia is low-level API is about 98%

00:23:31,180 --> 00:23:40,360
feature complete it includes a CFO fie

00:23:35,740 --> 00:23:42,930
as part of developing Sequoia we ported

00:23:40,360 --> 00:23:45,070
a number of applications to Sequoia

00:23:42,930 --> 00:23:49,390
including the pep engine which is where

00:23:45,070 --> 00:23:50,500
I work and one thing we found is even

00:23:49,390 --> 00:23:53,230
though we've only implemented a

00:23:50,500 --> 00:23:56,050
low-level API so far it only requires

00:23:53,230 --> 00:24:00,790
about a 60% only requires 60% as much

00:23:56,050 --> 00:24:03,760
code as the version of pep using GPG so

00:24:00,790 --> 00:24:06,490
we're particularly pleased about that we

00:24:03,760 --> 00:24:09,430
also have a QT TV replacement which is

00:24:06,490 --> 00:24:12,010
the tool that for instance apt uses to

00:24:09,430 --> 00:24:13,660
verify packages we have a new key server

00:24:12,010 --> 00:24:15,940
implementation that Kai has worked on

00:24:13,660 --> 00:24:18,040
and we've done experiments porting other

00:24:15,940 --> 00:24:21,310
software so it's been very important to

00:24:18,040 --> 00:24:24,460
us to get lots of experience with the

00:24:21,310 --> 00:24:27,030
API before we do a release and our first

00:24:24,460 --> 00:24:27,030
release was

00:24:27,330 --> 00:24:34,179
well it's still compiling but I'm gonna

00:24:30,070 --> 00:24:36,640
upload it really soon now okay so we're

00:24:34,179 --> 00:24:38,950
gonna release within the minute by the

00:24:36,640 --> 00:24:40,390
end of the talk so this is one of these

00:24:38,950 --> 00:24:41,360
live demos right except you're doing a

00:24:40,390 --> 00:24:49,210
release

00:24:41,360 --> 00:24:51,679
[Applause]

00:24:49,210 --> 00:24:53,360
and if you're interested you're welcome

00:24:51,679 --> 00:24:55,280
to join us and in fact we're hiring

00:24:53,360 --> 00:24:57,170
people so we're looking for people that

00:24:55,280 --> 00:24:59,960
have Android and iOS experience not just

00:24:57,170 --> 00:25:02,000
to do ports to Android and iOS but to

00:24:59,960 --> 00:25:05,780
help with a more tighter integration in

00:25:02,000 --> 00:25:08,380
the future so Sequoia is this new

00:25:05,780 --> 00:25:11,720
awesome we think open PGP implementation

00:25:08,380 --> 00:25:14,840
our focus is on user centric development

00:25:11,720 --> 00:25:17,150
and a strong focus on security we try to

00:25:14,840 --> 00:25:19,100
be really portable and highly integrated

00:25:17,150 --> 00:25:20,690
with the environment so not just

00:25:19,100 --> 00:25:23,090
thinking about how things ought to be

00:25:20,690 --> 00:25:25,820
done but using the services that the

00:25:23,090 --> 00:25:27,950
host OS provides so for instance on iOS

00:25:25,820 --> 00:25:31,130
we want to use the trusted uncle' if we

00:25:27,950 --> 00:25:32,080
want to use systemd on on linux when

00:25:31,130 --> 00:25:35,090
it's there

00:25:32,080 --> 00:25:38,419
our low-level API is already very usable

00:25:35,090 --> 00:25:40,910
and if you have a package within a

00:25:38,419 --> 00:25:44,740
couple of minutes you'll be able to add

00:25:40,910 --> 00:25:47,510
a dependency to sequoia - open PGP and

00:25:44,740 --> 00:25:49,850
integrate Sequoia into your project we

00:25:47,510 --> 00:25:52,250
are on freenode in the Sequoia channel

00:25:49,850 --> 00:25:56,990
we have a mailing list and you can find

00:25:52,250 --> 00:26:07,660
our source code on git lab thank you

00:25:56,990 --> 00:26:07,660
[Applause]

00:26:10,220 --> 00:26:21,029
okay time for some questions yeah I know

00:26:18,509 --> 00:26:29,190
it's hard they're the topic but you can

00:26:21,029 --> 00:26:31,529
make it yes so um I was wondering if

00:26:29,190 --> 00:26:34,200
you're trying to fill in a void also

00:26:31,529 --> 00:26:37,649
that is currently with GPG at least last

00:26:34,200 --> 00:26:40,980
time I checked for having an secure and

00:26:37,649 --> 00:26:43,970
easy to use API to interface with this

00:26:40,980 --> 00:26:46,889
sort of functionality from a code

00:26:43,970 --> 00:26:49,200
directly as far as I know GPG only

00:26:46,889 --> 00:26:51,509
encourages like wrapped command-line use

00:26:49,200 --> 00:26:54,869
but mostly and not like direct

00:26:51,509 --> 00:26:57,960
interfacing with this stuff saticon I'm

00:26:54,869 --> 00:27:00,929
sorry at all so there is a library that

00:26:57,960 --> 00:27:02,850
qpq provides called keep eg me and it's

00:27:00,929 --> 00:27:04,529
a C library and they're also wrappers

00:27:02,850 --> 00:27:07,200
for other languages now in the

00:27:04,529 --> 00:27:10,649
background it is indeed calling out to

00:27:07,200 --> 00:27:12,179
the GP key command line tool and this

00:27:10,649 --> 00:27:15,149
isn't necessarily a bad thing because

00:27:12,179 --> 00:27:16,980
you should kind of be happy that you

00:27:15,149 --> 00:27:18,600
have process separation so you might

00:27:16,980 --> 00:27:22,139
have heard of heartbleed which is in

00:27:18,600 --> 00:27:24,359
open SSL bug and one of the reasons that

00:27:22,139 --> 00:27:26,039
hot lead occurred was because the

00:27:24,359 --> 00:27:28,799
private keys were held in the same

00:27:26,039 --> 00:27:31,109
memory as the process so there was an

00:27:28,799 --> 00:27:34,289
error in whatever daemon you happen to

00:27:31,109 --> 00:27:36,899
have and it was able to arbitrary reads

00:27:34,289 --> 00:27:38,759
it reads out the private key and now

00:27:36,899 --> 00:27:41,519
you're screwed if you have this process

00:27:38,759 --> 00:27:44,340
separation it's not ironclad right no

00:27:41,519 --> 00:27:46,169
security provides protection from

00:27:44,340 --> 00:27:50,059
everything but it does provide you

00:27:46,169 --> 00:27:52,619
protection from those types of errors so

00:27:50,059 --> 00:27:55,679
doing this type of separation is

00:27:52,619 --> 00:27:58,609
sensible one of the issues that we have

00:27:55,679 --> 00:28:03,269
with this approach is that keep Akemi

00:27:58,609 --> 00:28:07,440
offers a subset of the API that GPC

00:28:03,269 --> 00:28:09,929
supports and one consequence of this is

00:28:07,440 --> 00:28:11,609
that people start using GPT me they

00:28:09,929 --> 00:28:13,149
think all this is a nice library maybe

00:28:11,609 --> 00:28:14,830
and

00:28:13,149 --> 00:28:17,499
they encounter is something that they

00:28:14,830 --> 00:28:19,509
can't do with qpg me but they can do on

00:28:17,499 --> 00:28:21,879
the command line and say okay well then

00:28:19,509 --> 00:28:23,679
I'll just shell out to keep EG because

00:28:21,879 --> 00:28:26,289
it can do it on the command line and

00:28:23,679 --> 00:28:29,349
they write all of this infrastructure to

00:28:26,289 --> 00:28:31,239
shell out parse the output and then they

00:28:29,349 --> 00:28:32,859
think well wait why am I using CPC me

00:28:31,239 --> 00:28:35,139
when I already have this infrastructure

00:28:32,859 --> 00:28:37,899
to shell out and so we're taking the

00:28:35,139 --> 00:28:41,769
library first approach and command line

00:28:37,899 --> 00:28:46,299
second so Sequoia is firstly a library

00:28:41,769 --> 00:28:49,029
or a crate and the rest sense and all of

00:28:46,299 --> 00:28:52,599
the in all of the functionalities

00:28:49,029 --> 00:28:54,759
exposed via a libraries API we also

00:28:52,599 --> 00:28:56,349
provide a command-line tool and the

00:28:54,759 --> 00:28:58,899
command-line tool uses the library

00:28:56,349 --> 00:29:04,289
directly and provides a subset of the

00:28:58,899 --> 00:29:04,289
libraries API alright thank you

00:29:11,180 --> 00:29:29,330
one more can you give us a fingerprint

00:29:20,600 --> 00:29:30,920
of your signing key please okay then I

00:29:29,330 --> 00:29:35,480
have a real question which is the web

00:29:30,920 --> 00:29:39,280
plan for either the gbg agent or the gbg

00:29:35,480 --> 00:29:46,040
card itself like talking to the tokens

00:29:39,280 --> 00:29:50,930
so this is my signing key and my main

00:29:46,040 --> 00:29:53,240
key is up here so in terms of talking to

00:29:50,930 --> 00:29:56,900
GPG agent from Sequoia we haven't

00:29:53,240 --> 00:29:59,060
implemented that support but if you

00:29:56,900 --> 00:30:03,980
think about GPG agent as being similar

00:29:59,060 --> 00:30:05,660
to a smart card then it's not difficult

00:30:03,980 --> 00:30:07,970
to imagine that once we have smart card

00:30:05,660 --> 00:30:09,440
support interfacing with the TPP should

00:30:07,970 --> 00:30:11,750
be or keeping keys agent should be

00:30:09,440 --> 00:30:16,070
relatively easy one of the difficulties

00:30:11,750 --> 00:30:21,110
there is that GPG G's agent uses a sort

00:30:16,070 --> 00:30:23,630
of proprietary way of generating the

00:30:21,110 --> 00:30:26,360
fingerprint so instead of using open PGP

00:30:23,630 --> 00:30:28,670
s fingerprint since QP g also supports

00:30:26,360 --> 00:30:30,590
s/mime it has what's called a key grip

00:30:28,670 --> 00:30:32,330
and a key grip is generated using s

00:30:30,590 --> 00:30:34,370
expressions and then taking the sha of

00:30:32,330 --> 00:30:36,470
the X expression so it's kind of ugly

00:30:34,370 --> 00:30:40,340
and you have to generate the X

00:30:36,470 --> 00:30:43,190
expression in the exact right way so

00:30:40,340 --> 00:30:45,800
it's we took a look at it as a way of

00:30:43,190 --> 00:30:47,780
getting early support for doing private

00:30:45,800 --> 00:30:49,550
key operations and decided that to be

00:30:47,780 --> 00:30:51,530
actually just easier to implement the

00:30:49,550 --> 00:30:54,260
crypto ourselves or not actually the

00:30:51,530 --> 00:30:56,240
crypto stuff but the using the low-level

00:30:54,260 --> 00:30:59,210
primitives and so that's what we did but

00:30:56,240 --> 00:31:02,450
for practical reasons it does make sense

00:30:59,210 --> 00:31:04,850
to consider interfacing with the Qt

00:31:02,450 --> 00:31:08,270
agents and there is an issue in our

00:31:04,850 --> 00:31:12,320
issue tracker and maybe we'll do that

00:31:08,270 --> 00:31:15,100
actually we'll probably do that okay

00:31:12,320 --> 00:31:23,160
thanks Neal thank you

00:31:15,100 --> 00:31:23,160

YouTube URL: https://www.youtube.com/watch?v=X0CoMREirrI


