Title: RustFest Rome 2018 -  Ryan Levick: Oh Boy! Creating a Game Boy Emulator in Rust
Publication date: 2018-11-24
Playlist: RustFest Rome 2018
Description: 
	The magical thing about Rust is its ability to remove the fear of learning new things. My journey with Rust has led me to the world of hardware emulators - specifically old gaming machines from the 80s and 90s. Join me as we explore what it takes to implement a fully working Game Boy emulator. We'll take a look at the ins and outs of this 30 year old gaming wonder, learning a lot along the way about how computers and Rust work! By the end we'll have our emulator running in a web browser, a window on our Desktop and even a mobile phone!

https://rome.rustfest.eu/sessions/gameboy-emulator
https://media.ccc.de/v/rustfest-rome-3-gameboy-emulator
Captions: 
	00:00:05,930 --> 00:00:12,929
hi can everyone hear me yes cool

00:00:10,740 --> 00:00:16,349
just wave if you can't hear me at some

00:00:12,929 --> 00:00:17,270
time during the talk alright let's get

00:00:16,349 --> 00:00:21,359
started

00:00:17,270 --> 00:00:29,820
so I'm Ryan Levesque you can find me at

00:00:21,359 --> 00:00:31,980
Aichi ankles on on twitter and today I'm

00:00:29,820 --> 00:00:36,989
gonna be talking about creating a

00:00:31,980 --> 00:00:43,710
Gameboy emulator and rust I touched

00:00:36,989 --> 00:00:45,210
something cool it's back alright so the

00:00:43,710 --> 00:00:48,600
first thing we have to talk about is

00:00:45,210 --> 00:00:51,090
what is emulation hopefully everybody is

00:00:48,600 --> 00:00:55,200
familiar with this thing this is the

00:00:51,090 --> 00:00:58,800
original Gameboy from like 1989 and the

00:00:55,200 --> 00:01:02,280
goal of emulation is to basically create

00:00:58,800 --> 00:01:03,899
this piece of hardware in software but

00:01:02,280 --> 00:01:05,850
before we get into the details of how to

00:01:03,899 --> 00:01:10,260
do that I'd like to talk a little bit

00:01:05,850 --> 00:01:12,479
about my story so I'm a web programmer

00:01:10,260 --> 00:01:14,010
originally mostly working on the backend

00:01:12,479 --> 00:01:16,650
I've also done a lot of front-end

00:01:14,010 --> 00:01:17,840
development I studied marketing so I

00:01:16,650 --> 00:01:20,850
don't have a computer science background

00:01:17,840 --> 00:01:23,460
so basically what I want to tell you

00:01:20,850 --> 00:01:25,409
with all of this is I'm not any kind of

00:01:23,460 --> 00:01:27,210
genius it's when I first started working

00:01:25,409 --> 00:01:30,000
on emulation I thought this is probably

00:01:27,210 --> 00:01:31,860
a very hard problem it's not really so I

00:01:30,000 --> 00:01:34,470
encourage all of you to take a look at

00:01:31,860 --> 00:01:35,790
it because it's a lot of fun and at the

00:01:34,470 --> 00:01:39,750
end you get to play games which is

00:01:35,790 --> 00:01:41,369
pretty cool so the first thing that when

00:01:39,750 --> 00:01:43,470
I started on my journey was kind of

00:01:41,369 --> 00:01:44,970
looking for what can I emulate I want to

00:01:43,470 --> 00:01:47,670
create an emulator because it sounds

00:01:44,970 --> 00:01:49,229
like a cool project what should I start

00:01:47,670 --> 00:01:51,509
with when I thought maybe I start with a

00:01:49,229 --> 00:01:54,060
Nintendo 64 because I played that as a

00:01:51,509 --> 00:01:55,979
kid or a Playstation well those were

00:01:54,060 --> 00:01:58,710
kind of hard so let's start a little bit

00:01:55,979 --> 00:02:00,780
simple and I started with the chip 8 and

00:01:58,710 --> 00:02:04,110
if anybody is not familiar with the chip

00:02:00,780 --> 00:02:06,600
8 it's a computer from the 1970s very

00:02:04,110 --> 00:02:08,100
simple kind of looked like this when you

00:02:06,600 --> 00:02:09,869
were playing with it can play things

00:02:08,100 --> 00:02:11,910
like pong and breakout and stuff like

00:02:09,869 --> 00:02:13,200
that and two very simple architectures

00:02:11,910 --> 00:02:15,270
so if you want to start with something

00:02:13,200 --> 00:02:17,130
and the game boy seems like a little bit

00:02:15,270 --> 00:02:19,980
a big leap for you I would suggest

00:02:17,130 --> 00:02:21,660
starting with the chip8 first so now

00:02:19,980 --> 00:02:23,520
that we have that covered what do we

00:02:21,660 --> 00:02:26,610
actually have to do to emulate the

00:02:23,520 --> 00:02:29,730
Gameboy and there are a couple of major

00:02:26,610 --> 00:02:31,380
parts to emulation for instance we have

00:02:29,730 --> 00:02:34,050
the CPU which is kind of like the brains

00:02:31,380 --> 00:02:35,790
of the of the computer we have memory we

00:02:34,050 --> 00:02:37,620
have graphics and we have a whole bunch

00:02:35,790 --> 00:02:40,110
more that I won't even touch on like

00:02:37,620 --> 00:02:41,460
sound input stuff like that and

00:02:40,110 --> 00:02:45,780
unfortunately this is only 30 minutes

00:02:41,460 --> 00:02:49,530
long and I'm not that good so so this is

00:02:45,780 --> 00:02:51,570
going to be our goal for today is to get

00:02:49,530 --> 00:02:53,790
this working this is the when you turn

00:02:51,570 --> 00:02:56,460
on the Gameboy the Nintendo logo Scrolls

00:02:53,790 --> 00:02:58,740
down we won't get to the digging

00:02:56,460 --> 00:03:00,540
unfortunately because that's sound but

00:02:58,740 --> 00:03:03,870
I'll leave that up to you as some

00:03:00,540 --> 00:03:05,730
homework so let's start kind of at the

00:03:03,870 --> 00:03:07,350
top of the stack the thing that you as

00:03:05,730 --> 00:03:09,570
the player get to see will start with

00:03:07,350 --> 00:03:11,550
graphics and the first thing that we

00:03:09,570 --> 00:03:15,690
have to talk about is the tiling system

00:03:11,550 --> 00:03:18,420
so when you look at the background of

00:03:15,690 --> 00:03:21,600
the game what you'll actually be looking

00:03:18,420 --> 00:03:23,280
at is a grouping of tiles so the game

00:03:21,600 --> 00:03:26,250
boy does not manipulate pixel by pixel

00:03:23,280 --> 00:03:28,290
but rather creates these 8 by 8 pixel

00:03:26,250 --> 00:03:31,410
tiles and then you arrange those 8 by 8

00:03:28,290 --> 00:03:34,050
pixel tiles on the screen and so here on

00:03:31,410 --> 00:03:36,150
the Left we can see the tiles set which

00:03:34,050 --> 00:03:37,770
is kind of your your 8 by 8 tiles that

00:03:36,150 --> 00:03:39,600
you can use as building blocks to build

00:03:37,770 --> 00:03:42,000
your graphics and then on the right is

00:03:39,600 --> 00:03:45,000
the background and you basically just

00:03:42,000 --> 00:03:46,800
map tile to some place on the background

00:03:45,000 --> 00:03:48,450
so let's take a little bit closer and

00:03:46,800 --> 00:03:50,490
look at that we'll kind of zoom in on

00:03:48,450 --> 00:03:52,380
one part of the tile set and some

00:03:50,490 --> 00:03:55,290
corresponding pieces interesting pieces

00:03:52,380 --> 00:03:57,540
of the background so you can see what

00:03:55,290 --> 00:04:00,060
the tile set looks like it's just kind

00:03:57,540 --> 00:04:02,010
of these these 8 by 8 pixel junks right

00:04:00,060 --> 00:04:04,560
here and they're usually in memory

00:04:02,010 --> 00:04:08,550
numbered 0 2 in this case

00:04:04,560 --> 00:04:10,050
47 there's around 300 of them and so

00:04:08,550 --> 00:04:12,930
that you know literally go through

00:04:10,050 --> 00:04:16,470
memory the first tile in this tile set

00:04:12,930 --> 00:04:18,720
happens to be all white pixels then

00:04:16,470 --> 00:04:20,850
after that it's the kind of top left of

00:04:18,720 --> 00:04:23,100
the end and so on and then what we're

00:04:20,850 --> 00:04:24,480
going to do is in our background we're

00:04:23,100 --> 00:04:27,660
going to

00:04:24,480 --> 00:04:29,850
map from a tile to a place in the

00:04:27,660 --> 00:04:32,640
background so the first square there is

00:04:29,850 --> 00:04:35,550
going to be tile one to the very right

00:04:32,640 --> 00:04:38,820
you see the little like are on the top

00:04:35,550 --> 00:04:41,460
there that's tile 25 below that is tile

00:04:38,820 --> 00:04:43,590
zero so we're mapping from tiles and art

00:04:41,460 --> 00:04:45,780
and our tile set to the actual

00:04:43,590 --> 00:04:47,910
background so if you take a look at

00:04:45,780 --> 00:04:50,010
something like this this is Tetris right

00:04:47,910 --> 00:04:52,460
here and a very poorly played game of

00:04:50,010 --> 00:04:55,230
Tetris that's my fault sorry about that

00:04:52,460 --> 00:04:56,640
you can see we have a tile set which is

00:04:55,230 --> 00:04:58,920
much more complicated than intend to

00:04:56,640 --> 00:05:01,890
logo one that has all kinds of things in

00:04:58,920 --> 00:05:04,650
it and the background is just kind of

00:05:01,890 --> 00:05:05,940
composed of all of those tiles and we

00:05:04,650 --> 00:05:07,350
just need to know this and be able to

00:05:05,940 --> 00:05:09,180
emulate this it's not our job to

00:05:07,350 --> 00:05:11,100
actually do the composition that's the

00:05:09,180 --> 00:05:13,230
programmers job and you know we're not

00:05:11,100 --> 00:05:16,230
the game programmer we're just allowing

00:05:13,230 --> 00:05:18,080
the game to actually do that you might

00:05:16,230 --> 00:05:20,730
be asking though wait a second

00:05:18,080 --> 00:05:23,910
when we look at the tetris thing we've

00:05:20,730 --> 00:05:25,980
got all this white space next to the

00:05:23,910 --> 00:05:28,530
actual game what's going on with that

00:05:25,980 --> 00:05:30,720
and the answer is is that the background

00:05:28,530 --> 00:05:33,240
is actually much larger than the display

00:05:30,720 --> 00:05:35,670
sri and on the device itself so what we

00:05:33,240 --> 00:05:37,980
have to do is also emulate a viewport on

00:05:35,670 --> 00:05:39,420
top of that window and you can look what

00:05:37,980 --> 00:05:42,900
that looks like when you're actually

00:05:39,420 --> 00:05:44,580
scrolling the Nintendo logo so the I was

00:05:42,900 --> 00:05:46,200
amazed when I first saw this it turns

00:05:44,580 --> 00:05:48,810
out that the Nintendo logo isn't

00:05:46,200 --> 00:05:55,140
actually scrolling down but the viewport

00:05:48,810 --> 00:05:56,910
is scrolling up which so let's let's

00:05:55,140 --> 00:05:58,410
dive into a little bit of code and again

00:05:56,910 --> 00:05:59,700
this is gonna be high level because

00:05:58,410 --> 00:06:01,470
unfortunately we only have 30 minutes

00:05:59,700 --> 00:06:03,720
but it should give you a rough idea of

00:06:01,470 --> 00:06:06,120
how you could model this and rust so

00:06:03,720 --> 00:06:07,920
here we have a GPU struct and we're

00:06:06,120 --> 00:06:10,470
gonna have something like a tile set and

00:06:07,920 --> 00:06:12,870
it's going to be again 384 tiles and

00:06:10,470 --> 00:06:14,760
these tiles are just 8 by 8 pixels so

00:06:12,870 --> 00:06:18,870
it's kind of you can think of it as a

00:06:14,760 --> 00:06:21,240
you know a an array for instance and

00:06:18,870 --> 00:06:23,280
then we have video RAM and that is that

00:06:21,240 --> 00:06:24,870
includes things like our background I'm

00:06:23,280 --> 00:06:27,210
gonna also include things like sprites

00:06:24,870 --> 00:06:29,970
and stuff like that but for now it's

00:06:27,210 --> 00:06:32,160
just the background and then the last

00:06:29,970 --> 00:06:34,650
thing is our canvas buffer and what that

00:06:32,160 --> 00:06:36,510
is going to be is just what we're going

00:06:34,650 --> 00:06:38,220
to take from the tile set and the video

00:06:36,510 --> 00:06:40,980
RAM and compose them together to

00:06:38,220 --> 00:06:42,870
actually display it onto the screen so

00:06:40,980 --> 00:06:44,880
the tile set is something that the game

00:06:42,870 --> 00:06:46,890
codes that your your emulator is running

00:06:44,880 --> 00:06:48,510
woman if you like the video Ram is also

00:06:46,890 --> 00:06:50,370
something the game code will manipulate

00:06:48,510 --> 00:06:52,770
but the canvas buffer is something that

00:06:50,370 --> 00:06:54,390
we in the background are manipulating so

00:06:52,770 --> 00:07:00,420
that we display something actually to

00:06:54,390 --> 00:07:01,920
the user of our emulator so now that we

00:07:00,420 --> 00:07:04,380
have kind of a rough idea of how you

00:07:01,920 --> 00:07:05,940
might model graphics and only a

00:07:04,380 --> 00:07:08,640
high-level one let's talk a little bit

00:07:05,940 --> 00:07:12,450
about memory so it's important to

00:07:08,640 --> 00:07:16,680
remember that memory is just one very

00:07:12,450 --> 00:07:19,500
very long array and it's full of bytes

00:07:16,680 --> 00:07:21,120
that's all it is so if you're thinking

00:07:19,500 --> 00:07:23,340
about how this is very very complicated

00:07:21,120 --> 00:07:26,190
it's not it's really just an array and

00:07:23,340 --> 00:07:28,830
it has unsigned 8-bit integers in it and

00:07:26,190 --> 00:07:31,860
that's it and it's really the clever use

00:07:28,830 --> 00:07:34,020
of game code people much smarter than

00:07:31,860 --> 00:07:36,030
myself in the 80s and the 90s

00:07:34,020 --> 00:07:37,980
who created these games to manipulate

00:07:36,030 --> 00:07:39,480
that long array of bytes that are

00:07:37,980 --> 00:07:42,450
actually doing the cool stuff that you

00:07:39,480 --> 00:07:44,850
see on the screen so let's take a little

00:07:42,450 --> 00:07:47,310
bit closer of a look at the memory map

00:07:44,850 --> 00:07:49,740
that we have what is this array of bytes

00:07:47,310 --> 00:07:51,990
actually contain well the first half of

00:07:49,740 --> 00:07:53,850
it is ROM code that's kind of the code

00:07:51,990 --> 00:07:56,370
that gets run automatically by the game

00:07:53,850 --> 00:07:58,290
boy it's a boot up it also includes your

00:07:56,370 --> 00:08:00,390
game cartridge code so when you stick a

00:07:58,290 --> 00:08:02,490
cartridge into the game boy that move

00:08:00,390 --> 00:08:04,950
the game boy automatically moves the

00:08:02,490 --> 00:08:08,580
game cartridge code into this first half

00:08:04,950 --> 00:08:12,000
of your long ray and we also have video

00:08:08,580 --> 00:08:14,040
RAM here and you can think of we're kind

00:08:12,000 --> 00:08:17,610
of already emulating and that inside of

00:08:14,040 --> 00:08:19,290
our with our GPU struct so that's taken

00:08:17,610 --> 00:08:22,560
care of there we have work RAM that's

00:08:19,290 --> 00:08:23,880
RAM that the game can use to kind of do

00:08:22,560 --> 00:08:25,410
whatever it needs to do and we have

00:08:23,880 --> 00:08:29,310
other stuff as well that I'm not getting

00:08:25,410 --> 00:08:31,820
to so places to define what the window

00:08:29,310 --> 00:08:37,140
sizes and things like that

00:08:31,820 --> 00:08:39,090
but we will get to that today so you can

00:08:37,140 --> 00:08:41,310
imagine that we would have a struct

00:08:39,090 --> 00:08:43,620
called memory bus and that memory bus

00:08:41,310 --> 00:08:46,020
contains that super long array and it's

00:08:43,620 --> 00:08:47,730
actually again just an array of unsigned

00:08:46,020 --> 00:08:51,190
8-bit integers that's 0

00:08:47,730 --> 00:08:53,800
fffff long and that's how much memory

00:08:51,190 --> 00:08:55,420
the Gameboy had it's actually not how

00:08:53,800 --> 00:08:58,230
much memory the Gameboy had is how much

00:08:55,420 --> 00:09:01,540
the Gameboy could address in memory so

00:08:58,230 --> 00:09:04,870
an address space of 16 bits if that

00:09:01,540 --> 00:09:09,190
makes sense and of course we have our

00:09:04,870 --> 00:09:11,200
GPU along with that and so when we're

00:09:09,190 --> 00:09:13,270
implementing our memory bus you might

00:09:11,200 --> 00:09:15,430
want to have a function for instance

00:09:13,270 --> 00:09:18,100
called read byte and what does that read

00:09:15,430 --> 00:09:21,160
byte do it takes an address which is a

00:09:18,100 --> 00:09:23,680
unsigned 16-bit integer and it returns

00:09:21,160 --> 00:09:25,120
back to bite at that address and we'll

00:09:23,680 --> 00:09:27,400
have to do a little bit of logic here

00:09:25,120 --> 00:09:29,920
like okay if the address is greater than

00:09:27,400 --> 00:09:31,990
the beginning of video RAM but less than

00:09:29,920 --> 00:09:35,020
the end of video RAM let's go ahead and

00:09:31,990 --> 00:09:37,270
read from our GPU Ram and otherwise

00:09:35,020 --> 00:09:40,540
we'll go ahead and read from that very

00:09:37,270 --> 00:09:42,370
long array instead and actually when we

00:09:40,540 --> 00:09:44,020
add more and more subsystems like sound

00:09:42,370 --> 00:09:46,690
and things like that we're just gonna

00:09:44,020 --> 00:09:49,060
have a big old like if-else or match

00:09:46,690 --> 00:09:50,440
statement that basically says okay if

00:09:49,060 --> 00:09:52,270
it's this part of memory go to this

00:09:50,440 --> 00:09:54,820
subsystem if it's this part of memory go

00:09:52,270 --> 00:09:59,020
to that subsystem and and that's how it

00:09:54,820 --> 00:10:02,530
works and lastly what we're going to

00:09:59,020 --> 00:10:05,170
have then is the CPU so the kind of

00:10:02,530 --> 00:10:07,030
overarching brains of the computer and

00:10:05,170 --> 00:10:10,990
that holds on to the bus so the CPU can

00:10:07,030 --> 00:10:13,300
talked through the bus to the GPU but

00:10:10,990 --> 00:10:14,980
the CPU has one more thing along with it

00:10:13,300 --> 00:10:16,870
it has something called a program

00:10:14,980 --> 00:10:18,910
counter and what the program counter

00:10:16,870 --> 00:10:20,500
does is it's basically just a number

00:10:18,910 --> 00:10:23,110
that indicates where in memory you're

00:10:20,500 --> 00:10:24,490
currently executing so we can take a

00:10:23,110 --> 00:10:27,160
look at the program counter here

00:10:24,490 --> 00:10:30,670
currently our program counter is set to

00:10:27,160 --> 00:10:33,310
0 if we go ahead and execute that

00:10:30,670 --> 00:10:37,590
instruction at 0 and move forward it

00:10:33,310 --> 00:10:41,200
will jump to instruction at address 2

00:10:37,590 --> 00:10:43,150
then it jumps to address 4 maybe it then

00:10:41,200 --> 00:10:45,280
you know that instruction is a jump and

00:10:43,150 --> 00:10:47,680
it jumps over to address 9 and maybe

00:10:45,280 --> 00:10:49,060
then it jumps to address 19 and that's

00:10:47,680 --> 00:10:50,800
all you're doing is keeping track of

00:10:49,060 --> 00:10:52,480
what is the currently execute an

00:10:50,800 --> 00:10:54,220
instruction and we'll look at what

00:10:52,480 --> 00:10:56,890
executing instructions actually looks

00:10:54,220 --> 00:10:58,660
like in a second so now we know ok our

00:10:56,890 --> 00:11:00,840
struct our CPU struct is pretty simple

00:10:58,660 --> 00:11:04,610
it's got a program counter and

00:11:00,840 --> 00:11:07,110
got a memory bus and that's about it so

00:11:04,610 --> 00:11:09,660
that's great let's take a little bit

00:11:07,110 --> 00:11:11,220
closer look at the CPU itself and the

00:11:09,660 --> 00:11:13,050
first thing that we need to look at is

00:11:11,220 --> 00:11:15,480
instruction so we have our program

00:11:13,050 --> 00:11:17,780
counter we're reading a byte and from

00:11:15,480 --> 00:11:20,820
memory of an instruction that we want to

00:11:17,780 --> 00:11:22,680
execute but what we probably want to do

00:11:20,820 --> 00:11:25,680
is interpret that by as an actual

00:11:22,680 --> 00:11:28,710
instruction so we have this in this

00:11:25,680 --> 00:11:31,080
function called from byte on our on an

00:11:28,710 --> 00:11:34,920
instruction struct or an instruction

00:11:31,080 --> 00:11:37,470
enum and what from guide does is take

00:11:34,920 --> 00:11:43,470
that the unsigned 8-bit integer and

00:11:37,470 --> 00:11:48,390
decodes it as an instruction so for

00:11:43,470 --> 00:11:52,560
instance 0 X 0 2 decodes as an increment

00:11:48,390 --> 00:11:54,210
on the BC target so that's just what

00:11:52,560 --> 00:11:55,830
what it is it's just an instruction

00:11:54,210 --> 00:12:01,140
we'll look at it specifically some

00:11:55,830 --> 00:12:02,850
instructions that we have so that now

00:12:01,140 --> 00:12:04,500
that we have instructions what we need

00:12:02,850 --> 00:12:05,970
to do is go ahead and execute them so

00:12:04,500 --> 00:12:08,300
we're going to look at this step

00:12:05,970 --> 00:12:12,060
function on the CPU that goes ahead and

00:12:08,300 --> 00:12:13,800
execute instructions and the way that an

00:12:12,060 --> 00:12:15,960
emulator works the way that a CPU works

00:12:13,800 --> 00:12:19,110
is it basically just loops infinitely

00:12:15,960 --> 00:12:21,630
and call step executing one instruction

00:12:19,110 --> 00:12:23,670
at a time going to the next and going

00:12:21,630 --> 00:12:25,530
going going going going forever and ever

00:12:23,670 --> 00:12:30,720
and ever unless the program calls halt

00:12:25,530 --> 00:12:33,270
or the Gameboy explodes or whatever so

00:12:30,720 --> 00:12:36,120
the first thing and our step instruction

00:12:33,270 --> 00:12:37,320
is just it's going to our step function

00:12:36,120 --> 00:12:40,680
is it's going to take beautiful

00:12:37,320 --> 00:12:45,330
beautiful reference itself it's then

00:12:40,680 --> 00:12:48,150
going to read a byte from the bus at the

00:12:45,330 --> 00:12:51,090
program counter it's then going to

00:12:48,150 --> 00:12:52,530
decode that byte as an instruction okay

00:12:51,090 --> 00:12:54,600
so we have an instruction now that's

00:12:52,530 --> 00:12:57,120
great we're going to execute that

00:12:54,600 --> 00:12:58,950
instruction and the execution what it's

00:12:57,120 --> 00:13:01,080
going to do is return us back the next

00:12:58,950 --> 00:13:05,400
program counter that we're at so for

00:13:01,080 --> 00:13:07,800
most instruction that's probably to two

00:13:05,400 --> 00:13:10,020
bytes further on in memory but if it's a

00:13:07,800 --> 00:13:12,900
jump that could be literally anywhere it

00:13:10,020 --> 00:13:14,130
can jump to anywhere in memory and of

00:13:12,900 --> 00:13:16,560
course then we're going to set

00:13:14,130 --> 00:13:21,510
the program counter to that next program

00:13:16,560 --> 00:13:24,540
country okay so now that we understand

00:13:21,510 --> 00:13:27,090
how how things get executed let's talk a

00:13:24,540 --> 00:13:29,400
little bit about registers and what

00:13:27,090 --> 00:13:31,740
registers are are the kind of smallest

00:13:29,400 --> 00:13:33,560
pieces of memory that we have inside of

00:13:31,740 --> 00:13:36,630
of the computer they're little tiny

00:13:33,560 --> 00:13:39,150
unsigned 8-bit integers that's it right

00:13:36,630 --> 00:13:41,370
next right on the CPU and that's what

00:13:39,150 --> 00:13:44,250
the CPU actually ends up manipulating so

00:13:41,370 --> 00:13:46,320
the CPU can fetch things so memory I can

00:13:44,250 --> 00:13:48,120
do something to the contents of a

00:13:46,320 --> 00:13:51,510
register and then it can write back out

00:13:48,120 --> 00:13:54,390
to memory and really that's about all it

00:13:51,510 --> 00:13:55,860
can do so our CPU instruction execution

00:13:54,390 --> 00:13:58,250
is actually pretty simple it's going to

00:13:55,860 --> 00:14:01,710
be just some simple math operations and

00:13:58,250 --> 00:14:03,570
so these things might look like this and

00:14:01,710 --> 00:14:04,980
we might we might go ahead and model it

00:14:03,570 --> 00:14:07,050
like this this is pretty straightforward

00:14:04,980 --> 00:14:08,790
we have a register struct it's got an

00:14:07,050 --> 00:14:11,100
unsigned 8-bit integer for each of our

00:14:08,790 --> 00:14:14,550
our registers that happen to be called

00:14:11,100 --> 00:14:16,200
ABCDE F H and L that's just the way that

00:14:14,550 --> 00:14:20,820
they were called it's not because I

00:14:16,200 --> 00:14:21,960
can't name things and so our CPU looks a

00:14:20,820 --> 00:14:26,130
little bit different now right

00:14:21,960 --> 00:14:27,870
it just has registers on it and let's

00:14:26,130 --> 00:14:29,880
take a look specifically at some

00:14:27,870 --> 00:14:32,940
instructions that might we might want to

00:14:29,880 --> 00:14:35,250
execute so we're going to look at one

00:14:32,940 --> 00:14:38,580
instruction it's the add instruction

00:14:35,250 --> 00:14:40,200
it's pretty straightforward and it has a

00:14:38,580 --> 00:14:42,210
couple of targets and what the add

00:14:40,200 --> 00:14:44,790
instruction will do is it looks at the

00:14:42,210 --> 00:14:47,520
target so if the target let's say is D

00:14:44,790 --> 00:14:49,620
register D it will take the contents of

00:14:47,520 --> 00:14:51,750
register D it will add it to the

00:14:49,620 --> 00:14:54,300
contents of register a and then it will

00:14:51,750 --> 00:14:55,710
store it back into register a and so no

00:14:54,300 --> 00:14:58,260
matter what the target is it just takes

00:14:55,710 --> 00:15:00,120
it puts it adds it with the register a

00:14:58,260 --> 00:15:01,680
and then writes it back into register a

00:15:00,120 --> 00:15:04,320
and if you're thinking that sounds

00:15:01,680 --> 00:15:08,010
pretty simple it is it's like one line

00:15:04,320 --> 00:15:12,360
of code so what we have to do now is

00:15:08,010 --> 00:15:14,370
actually execute our instruction so what

00:15:12,360 --> 00:15:15,990
we're going to look at here is execute

00:15:14,370 --> 00:15:17,460
on the CPU and it's going to take a

00:15:15,990 --> 00:15:18,660
mutable reference itself and an

00:15:17,460 --> 00:15:22,290
instruction that's going to actually

00:15:18,660 --> 00:15:23,820
execute the instruction and so first it

00:15:22,290 --> 00:15:26,190
needs to figure out what instruction

00:15:23,820 --> 00:15:27,360
it's dealing with right so we match on

00:15:26,190 --> 00:15:30,059
the instruction and in this

00:15:27,360 --> 00:15:32,879
we're gonna if it happens to be an add

00:15:30,059 --> 00:15:36,799
instruction and the target is the C

00:15:32,879 --> 00:15:39,899
register what we're going to do then is

00:15:36,799 --> 00:15:41,639
take the value and I just notice now we

00:15:39,899 --> 00:15:44,910
don't have the value we get the value

00:15:41,639 --> 00:15:47,309
from the C register we write it we wrap

00:15:44,910 --> 00:15:49,019
wrapping add to register a and what

00:15:47,309 --> 00:15:52,619
wrapping ad does is it just make sure

00:15:49,019 --> 00:15:54,720
that the if it goes above 255 which is

00:15:52,619 --> 00:15:57,179
the maximum that unsigned 8-bit integer

00:15:54,720 --> 00:15:58,379
can represent it just wraps around to 0

00:15:57,179 --> 00:16:00,209
again and goes from there

00:15:58,379 --> 00:16:04,319
and we're going to then write that back

00:16:00,209 --> 00:16:06,329
into register a pretty simple and so we

00:16:04,319 --> 00:16:09,720
have a whole bunch of instructions here

00:16:06,329 --> 00:16:12,059
we've got add sub bitwise and bitwise or

00:16:09,720 --> 00:16:14,309
but what is X or maybe if you're

00:16:12,059 --> 00:16:16,529
familiar with bitwise and struct like

00:16:14,309 --> 00:16:16,769
bitwise operations you know what these

00:16:16,529 --> 00:16:19,350
are

00:16:16,769 --> 00:16:21,269
if not they're pretty easy to learn you

00:16:19,350 --> 00:16:23,879
have Inc which adds 1 to something deck

00:16:21,269 --> 00:16:26,999
which takes one away and some more and

00:16:23,879 --> 00:16:28,949
this is by no means exhaustive so when

00:16:26,999 --> 00:16:30,329
you're writing an emulator this is

00:16:28,949 --> 00:16:31,589
probably the most boring part of the

00:16:30,329 --> 00:16:33,749
entire thing because you're just going

00:16:31,589 --> 00:16:36,029
to be doing this for like 200

00:16:33,749 --> 00:16:38,579
instructions but it gets much more fun

00:16:36,029 --> 00:16:41,610
after that so the last thing we're gonna

00:16:38,579 --> 00:16:43,949
do today is make it run and in order to

00:16:41,610 --> 00:16:46,559
do that I'm gonna use a crate called

00:16:43,949 --> 00:16:48,360
Russ mini FB and what this allows you to

00:16:46,559 --> 00:16:49,889
do is it gives you a window and it gives

00:16:48,360 --> 00:16:53,040
you something called a frame buffer

00:16:49,889 --> 00:16:54,959
which again is just a big array of bytes

00:16:53,040 --> 00:16:57,269
that you can write to and it will

00:16:54,959 --> 00:17:00,749
display those bytes on the screen so you

00:16:57,269 --> 00:17:03,480
can write to it if you write you know 12

00:17:00,749 --> 00:17:03,809
to the first byte there or the first 3

00:17:03,480 --> 00:17:06,449
bytes

00:17:03,809 --> 00:17:08,459
it displays that pixel to the screen and

00:17:06,449 --> 00:17:10,319
so it allows us to easily get up and

00:17:08,459 --> 00:17:13,019
running and write something write an

00:17:10,319 --> 00:17:14,880
actual window so this is a big chunk of

00:17:13,019 --> 00:17:18,240
code that we've got to get working the

00:17:14,880 --> 00:17:21,480
first line here is it takes a CPU and it

00:17:18,240 --> 00:17:23,850
takes a window and we're gonna get some

00:17:21,480 --> 00:17:26,909
stuff set up here so we have our window

00:17:23,850 --> 00:17:28,889
buffer that we're going to write to we

00:17:26,909 --> 00:17:31,139
have some housekeeping for how many

00:17:28,889 --> 00:17:34,470
cycles of the CPU how many times we've

00:17:31,139 --> 00:17:37,590
run the the run function and we have

00:17:34,470 --> 00:17:40,139
some timing stuff so what what is right

00:17:37,590 --> 00:17:40,830
now and basically we're gonna be running

00:17:40,139 --> 00:17:43,500
this code

00:17:40,830 --> 00:17:45,539
forever while the windows open and while

00:17:43,500 --> 00:17:48,360
you didn't hit the Escape key it sounds

00:17:45,539 --> 00:17:50,700
pretty good and so the first thing we do

00:17:48,360 --> 00:17:53,789
is do some time tracking to see okay how

00:17:50,700 --> 00:17:57,570
much time has passed since we last we're

00:17:53,789 --> 00:17:59,250
here and then we kind of right now back

00:17:57,570 --> 00:18:01,350
into the now function so we've just

00:17:59,250 --> 00:18:04,140
trying to keep track of how much time

00:18:01,350 --> 00:18:06,659
has passed since the last time then we

00:18:04,140 --> 00:18:09,360
go ahead and call run on the CPU when we

00:18:06,659 --> 00:18:11,220
pass in this time Delta and the CPU just

00:18:09,360 --> 00:18:13,470
knows how many instructions how many

00:18:11,220 --> 00:18:15,269
times to call step for that amount of

00:18:13,470 --> 00:18:16,919
time and the game boy has a very well

00:18:15,269 --> 00:18:19,799
specified amount of time that it's

00:18:16,919 --> 00:18:23,549
allowed to run and we get back how many

00:18:19,799 --> 00:18:25,559
cycles have actually passed how many

00:18:23,549 --> 00:18:29,370
cycles have been run and we add that to

00:18:25,559 --> 00:18:31,169
our cycles elapsed and frame and what we

00:18:29,370 --> 00:18:35,100
do there is we just check okay have we

00:18:31,169 --> 00:18:37,799
run more cycles then should happen and

00:18:35,100 --> 00:18:39,899
one frame and by frame I mean showing

00:18:37,799 --> 00:18:45,059
something to the user and that happens

00:18:39,899 --> 00:18:47,700
30 seconds 30 times per second and if we

00:18:45,059 --> 00:18:50,490
if we have then we go ahead and copy our

00:18:47,700 --> 00:18:52,529
pixel buffer from our GPU that we had

00:18:50,490 --> 00:18:54,929
and we put it into our window buffer and

00:18:52,529 --> 00:18:57,000
then we write it to our window and then

00:18:54,929 --> 00:18:59,370
we reset the cycles elapse and frame and

00:18:57,000 --> 00:19:02,130
this will just display the thing to the

00:18:59,370 --> 00:19:03,750
user pretty straightforward and

00:19:02,130 --> 00:19:06,149
otherwise we sleep for a little while

00:19:03,750 --> 00:19:08,789
because rust is so fast and your

00:19:06,149 --> 00:19:10,769
computer is so much faster than then a

00:19:08,789 --> 00:19:12,269
gameboy was that if you don't do that it

00:19:10,769 --> 00:19:15,779
will just explode because it can't

00:19:12,269 --> 00:19:17,159
handle it and if we do that we did it we

00:19:15,779 --> 00:19:20,120
have accomplished something so give

00:19:17,159 --> 00:19:20,120
ourselves a round of applause

00:19:23,120 --> 00:19:27,750
so we should all feel pretty proud of

00:19:25,230 --> 00:19:29,970
ourselves today but admittedly I might

00:19:27,750 --> 00:19:32,549
have skipped over a couple of things it

00:19:29,970 --> 00:19:34,529
wasn't exactly an exhaustive review of

00:19:32,549 --> 00:19:36,480
how to do this so you might be wondering

00:19:34,529 --> 00:19:37,559
okay I'm going to go home and I want to

00:19:36,480 --> 00:19:39,960
try this out for myself

00:19:37,559 --> 00:19:43,110
what are some resources that I can do to

00:19:39,960 --> 00:19:45,870
go ahead and get better at this one of

00:19:43,110 --> 00:19:48,390
the first ones here is a talk by Mickey

00:19:45,870 --> 00:19:50,010
eyelet which is a talk called the

00:19:48,390 --> 00:19:52,409
ultimate game boy talk and it really

00:19:50,010 --> 00:19:54,990
goes into super technical depth very

00:19:52,409 --> 00:19:56,700
fast much faster than I talked about the

00:19:54,990 --> 00:19:58,500
game boy and so if you want to just get

00:19:56,700 --> 00:20:02,130
a whirlwind tour of the technical

00:19:58,500 --> 00:20:03,419
aspects of a game boy go for this the

00:20:02,130 --> 00:20:05,549
next one is something called the pan

00:20:03,419 --> 00:20:08,520
docks these are really thorough

00:20:05,549 --> 00:20:11,100
technical documentation on on the game

00:20:08,520 --> 00:20:13,740
boy and it's really great if you have a

00:20:11,100 --> 00:20:16,470
question more than likely if you can't

00:20:13,740 --> 00:20:18,299
find it here you probably won't find it

00:20:16,470 --> 00:20:20,640
unless you'll find a random blog post

00:20:18,299 --> 00:20:23,970
somewhere online so this is a really

00:20:20,640 --> 00:20:26,460
good first stop the next one is what how

00:20:23,970 --> 00:20:28,200
I got started was reading this blog post

00:20:26,460 --> 00:20:32,190
series called game boy emulation in

00:20:28,200 --> 00:20:34,559
JavaScript and its really great it's not

00:20:32,190 --> 00:20:36,440
in rust obviously but if you're familiar

00:20:34,559 --> 00:20:38,700
with JavaScript it's good to kind of

00:20:36,440 --> 00:20:40,049
read through this and get an idea of how

00:20:38,700 --> 00:20:42,570
you might model it in JavaScript at

00:20:40,049 --> 00:20:48,899
least then if you're looking for

00:20:42,570 --> 00:20:53,220
something more rusty we have a repo here

00:20:48,899 --> 00:20:54,750
that implements a game boy in rust and

00:20:53,220 --> 00:20:58,200
the great thing about this is that it's

00:20:54,750 --> 00:21:00,450
meant to be extremely accurate so if you

00:20:58,200 --> 00:21:02,640
have any questions about how you should

00:21:00,450 --> 00:21:05,520
be emulating a game boy you should look

00:21:02,640 --> 00:21:06,990
here because the the awesome thing about

00:21:05,520 --> 00:21:10,860
this project is they have literally

00:21:06,990 --> 00:21:13,169
taken a physical game boy created test

00:21:10,860 --> 00:21:15,929
drums for it stuck them into the game

00:21:13,169 --> 00:21:17,429
boy tried it out doing weird things that

00:21:15,929 --> 00:21:19,620
no one would ever consider to do in an

00:21:17,429 --> 00:21:21,870
actual game and see what happens and

00:21:19,620 --> 00:21:23,490
then they emulate that inside of it so

00:21:21,870 --> 00:21:26,669
not only will this thing easily run

00:21:23,490 --> 00:21:28,860
Tetris Pokemon whatever you want it will

00:21:26,669 --> 00:21:31,380
also run any program that you happen to

00:21:28,860 --> 00:21:34,320
write and game boy assembly as well

00:21:31,380 --> 00:21:37,399
because it's as accurate it tries to be

00:21:34,320 --> 00:21:37,399
as accurate as it possibly

00:21:38,659 --> 00:21:45,149
so really what it comes down to is this

00:21:42,720 --> 00:21:47,039
was all kind of a pain for me there's a

00:21:45,149 --> 00:21:49,080
lot of I kind of gave you the shortcut

00:21:47,039 --> 00:21:52,230
on resources here of where to go if you

00:21:49,080 --> 00:21:54,509
if you need to find things but it took

00:21:52,230 --> 00:21:56,759
me a long time to find those sites those

00:21:54,509 --> 00:22:00,480
are by no means everything that you will

00:21:56,759 --> 00:22:02,519
need to implement this but just because

00:22:00,480 --> 00:22:05,100
it was a pain for me doesn't mean it has

00:22:02,519 --> 00:22:07,019
to be a pain for you what's exciting

00:22:05,100 --> 00:22:09,029
about emulating a Game Boy is not trying

00:22:07,019 --> 00:22:10,769
to find documentation online that's the

00:22:09,029 --> 00:22:12,989
bad part about building a Game Boy

00:22:10,769 --> 00:22:15,840
emulator the exciting part is actually

00:22:12,989 --> 00:22:18,989
building it and so with that what I've

00:22:15,840 --> 00:22:20,399
gone ahead is created a book because

00:22:18,989 --> 00:22:23,489
that's what we do in the rest community

00:22:20,399 --> 00:22:26,940
about how to build a Game Boy emulator

00:22:23,489 --> 00:22:30,720
and rust and what this is is really

00:22:26,940 --> 00:22:32,730
tries to be the the resource for being

00:22:30,720 --> 00:22:35,429
able to build a Game Boy emulator and

00:22:32,730 --> 00:22:37,559
Russ and it goes much much slower than I

00:22:35,429 --> 00:22:39,509
did today and run a much more detail and

00:22:37,559 --> 00:22:42,059
the great thing about writing it and

00:22:39,509 --> 00:22:44,309
rust as well is that you can compile it

00:22:42,059 --> 00:22:46,879
to web assembly and so I did that and I

00:22:44,309 --> 00:22:50,090
built myself a nice little Gameboy and

00:22:46,879 --> 00:22:52,289
thing here it's got some really great

00:22:50,090 --> 00:22:54,659
debugging tools and there's more of this

00:22:52,289 --> 00:22:56,399
to come as well so if you're interested

00:22:54,659 --> 00:22:58,169
if this looks really cool to you and you

00:22:56,399 --> 00:23:00,539
want to help out to make something very

00:22:58,169 --> 00:23:02,899
accessible so that other people can

00:23:00,539 --> 00:23:07,289
build game boys and have fun with them

00:23:02,899 --> 00:23:08,050
then I say let's learn together thank

00:23:07,289 --> 00:23:22,309
you

00:23:08,050 --> 00:23:22,309
[Applause]

00:23:22,780 --> 00:23:30,460
questions I guess you have some to

00:23:27,679 --> 00:23:30,460
maximum okay

00:23:38,500 --> 00:23:42,679
other than writing a book do you have

00:23:40,790 --> 00:23:46,550
like a gita bleep or something like that

00:23:42,679 --> 00:23:50,840
with the code for your emulator yes I do

00:23:46,550 --> 00:23:55,429
so it's github.com /r I'll EV ry le v /

00:23:50,840 --> 00:23:58,130
dmg 0 1 dmg 0 1 was the code name for

00:23:55,429 --> 00:23:59,690
the game boy so if you forget it just go

00:23:58,130 --> 00:24:01,400
to the Wikipedia page and look up what

00:23:59,690 --> 00:24:03,050
the code name for the game boy was while

00:24:01,400 --> 00:24:05,120
they were developing it you you'll be

00:24:03,050 --> 00:24:08,390
able to remember it but yeah I have the

00:24:05,120 --> 00:24:10,429
code there the emulator is this is

00:24:08,390 --> 00:24:12,350
actually my second attempt at writing

00:24:10,429 --> 00:24:16,429
the emulator the first attempt I did was

00:24:12,350 --> 00:24:19,010
in typescript and that one is a bit

00:24:16,429 --> 00:24:22,010
further along so the one currently can

00:24:19,010 --> 00:24:24,080
only run test roms it can't yet run

00:24:22,010 --> 00:24:25,940
tetris but i'm like very close to being

00:24:24,080 --> 00:24:28,010
able to do that and since I've already

00:24:25,940 --> 00:24:29,690
done it if you want to do it yourself

00:24:28,010 --> 00:24:31,880
and need my help I would be more than

00:24:29,690 --> 00:24:34,610
happy to take you through and we can get

00:24:31,880 --> 00:24:38,500
it running tetris which is quite a lot

00:24:34,610 --> 00:24:38,500
of fun thank you very much

00:24:50,330 --> 00:24:56,179
yeah I great doc so I have a kind of

00:24:54,679 --> 00:24:58,460
useless question

00:24:56,179 --> 00:24:59,809
have you tried like optimizing the

00:24:58,460 --> 00:25:03,260
performance of this and then removing

00:24:59,809 --> 00:25:07,700
the you know this whole time to see how

00:25:03,260 --> 00:25:11,330
how fast can you like and you know time

00:25:07,700 --> 00:25:13,460
rub the Gameboy game I have not tried to

00:25:11,330 --> 00:25:16,010
optimize it but I have I made before

00:25:13,460 --> 00:25:19,850
when I first ran I wrote that run code I

00:25:16,010 --> 00:25:22,309
didn't have the sleep in there and it it

00:25:19,850 --> 00:25:25,010
goes really fast so you will see things

00:25:22,309 --> 00:25:27,500
like the the screen just kind of going

00:25:25,010 --> 00:25:29,240
and then and then eventually it just

00:25:27,500 --> 00:25:32,210
kind of gets out of sync and stuff like

00:25:29,240 --> 00:25:34,130
that and yeah you need to you need to

00:25:32,210 --> 00:25:43,669
slow it down for it to be usable in any

00:25:34,130 --> 00:25:46,279
way ok then if we don't have any

00:25:43,669 --> 00:25:50,350
questions I test the microphone -

00:25:46,279 --> 00:25:50,350

YouTube URL: https://www.youtube.com/watch?v=B7seNuQncvU


