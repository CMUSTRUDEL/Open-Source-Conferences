Title: RustFest Rome 2018 -  Tshepang Lekhonkhobe: Behind The Scenes Of Producing An Executable
Publication date: 2018-11-24
Playlist: RustFest Rome 2018
Description: 
	If it's a mystery what actually goes on when you do a 'cargo run', then this talk is for you. It explores the sequence of steps taken to get to a working executable, from high-level code, to machine code, and what happens in-between. We'll do a simple example and see what each representation looks like, while touching on the steps in-between. In the end, we'll look at the generated RISC-V assembly.

https://rome.rustfest.eu/sessions/behind-the-scenes-of-producing-an-executable
https://media.ccc.de/v/rustfest-rome-8-behind-the-scenes-of-producing-an-executable
Captions: 
	00:00:04,990 --> 00:00:16,220
hi my name is Japan like they said so

00:00:12,730 --> 00:00:20,210
I'm going to talk about the steps that

00:00:16,220 --> 00:00:27,939
are taken when you build a was

00:00:20,210 --> 00:00:33,050
executable and I must be it was okay I

00:00:27,939 --> 00:00:34,309
proposed this talk knowing that it was a

00:00:33,050 --> 00:00:41,900
rather ambitious because I've never

00:00:34,309 --> 00:00:45,260
worked on a compiler before so and at

00:00:41,900 --> 00:00:47,299
this point if if I get any of the

00:00:45,260 --> 00:00:48,949
details right it would be good if some

00:00:47,299 --> 00:00:51,350
of the money illegible people can

00:00:48,949 --> 00:00:57,409
approach me afterwards but otherwise

00:00:51,350 --> 00:00:59,989
just a bit of a disclaimer so um anyways

00:00:57,409 --> 00:01:02,150
interestingly I just wanted to imagine

00:00:59,989 --> 00:01:05,089
it as I met I met two people yesterday

00:01:02,150 --> 00:01:09,710
actually were like let's say we are hit

00:01:05,089 --> 00:01:12,289
I met somebody who works on a v8 oh well

00:01:09,710 --> 00:01:14,149
who used to work on a v8 engine with the

00:01:12,289 --> 00:01:16,430
Google team another one was a micro as

00:01:14,149 --> 00:01:17,719
expeditious quite interesting because

00:01:16,430 --> 00:01:19,219
they were talking about some of the

00:01:17,719 --> 00:01:21,469
steps like wow actually those are the

00:01:19,219 --> 00:01:28,340
people who should actually give that

00:01:21,469 --> 00:01:32,810
talk but anyways anyways um about me I

00:01:28,340 --> 00:01:37,939
did some I studied electronics formally

00:01:32,810 --> 00:01:40,729
and I was a pattern friend for a while

00:01:37,939 --> 00:01:43,479
but now for some reason I chose honest I

00:01:40,729 --> 00:01:45,649
actually don't even remember why but

00:01:43,479 --> 00:01:49,340
actually quite dangerous I think it's

00:01:45,649 --> 00:01:52,789
very very well designed yeah I work for

00:01:49,340 --> 00:01:57,920
a small team I work for a small team in

00:01:52,789 --> 00:02:01,090
Johnny's back we actually we built yeah

00:01:57,920 --> 00:02:04,520
we bought distributed that framework

00:02:01,090 --> 00:02:07,399
yeah so and would actually be

00:02:04,520 --> 00:02:10,580
interesting to know what other companies

00:02:07,399 --> 00:02:12,739
on the continuous do something like this

00:02:10,580 --> 00:02:16,459
where they actually have full time as

00:02:12,739 --> 00:02:18,380
developers waking waking on in

00:02:16,459 --> 00:02:22,890
production so

00:02:18,380 --> 00:02:25,800
yeah anyways yeah let's let's get to the

00:02:22,890 --> 00:02:30,180
actual leader steps so this is sort of

00:02:25,800 --> 00:02:34,650
an overview this is this is what happens

00:02:30,180 --> 00:02:40,170
when you actually get to to produce a

00:02:34,650 --> 00:02:42,540
working executable like if you look at

00:02:40,170 --> 00:02:46,230
that the first step is a chalupa sing

00:02:42,540 --> 00:02:47,550
the source code and then when you pass

00:02:46,230 --> 00:02:49,710
this is called you produce what is

00:02:47,550 --> 00:02:56,100
called an ast is called an app's

00:02:49,710 --> 00:02:58,080
abstract abstract syntax a3 and the

00:02:56,100 --> 00:03:00,270
second step there is ast processing

00:02:58,080 --> 00:03:03,570
actually don't know what the correct

00:03:00,270 --> 00:03:04,980
term for what is I'm gonna show you

00:03:03,570 --> 00:03:07,340
what's going on literally with a EST

00:03:04,980 --> 00:03:10,230
process but i don't know what is there

00:03:07,340 --> 00:03:12,480
the normal the normal name for the steps

00:03:10,230 --> 00:03:16,050
in work but somebody can tell me a bit

00:03:12,480 --> 00:03:18,270
later and anyways so this there's a few

00:03:16,050 --> 00:03:21,960
steps they're lowering hir type-checking

00:03:18,270 --> 00:03:26,280
lower into mir bar checking translation

00:03:21,960 --> 00:03:31,890
to LLVM i our code generation linking

00:03:26,280 --> 00:03:40,140
will get to two others so first step is

00:03:31,890 --> 00:03:42,600
passing so with passing the source code

00:03:40,140 --> 00:03:44,310
is turned into something like a it's

00:03:42,600 --> 00:03:46,290
like a meaningful structure so it just

00:03:44,310 --> 00:03:48,060
takes basically ticks or raw text and

00:03:46,290 --> 00:03:54,060
then turns into something meaningful

00:03:48,060 --> 00:03:55,830
which is called the est and example it

00:03:54,060 --> 00:04:00,570
creates it creates a bunch of paths

00:03:55,830 --> 00:04:02,760
called tokens and this is just a few

00:04:00,570 --> 00:04:04,680
examples they may see you start feel the

00:04:02,760 --> 00:04:06,420
weight loss blog or whatever that's

00:04:04,680 --> 00:04:10,440
there's actually like a bunch of them

00:04:06,420 --> 00:04:11,640
like dozens and what you see there

00:04:10,440 --> 00:04:16,020
what's everything there is actually

00:04:11,640 --> 00:04:17,850
types type names in the compiler which

00:04:16,020 --> 00:04:19,530
is like is they actually and internal

00:04:17,850 --> 00:04:21,540
details they can change anytime nobody

00:04:19,530 --> 00:04:22,950
should rely on this kind of code but he

00:04:21,540 --> 00:04:27,500
has that kind of does that I came across

00:04:22,950 --> 00:04:30,009
as I was looking at this and yeah okay

00:04:27,500 --> 00:04:33,449
so we're done with

00:04:30,009 --> 00:04:37,419
passing and then we get to ast

00:04:33,449 --> 00:04:39,669
processing so there's a bunch of ones

00:04:37,419 --> 00:04:42,149
once you actually have that est this

00:04:39,669 --> 00:04:45,839
there are things that you do to it

00:04:42,149 --> 00:04:48,430
example is code elimination and then

00:04:45,839 --> 00:04:50,490
we'll get to we'll get to those and then

00:04:48,430 --> 00:04:54,969
macro expansion name resolution

00:04:50,490 --> 00:04:58,930
note that this that they that they are

00:04:54,969 --> 00:05:01,360
not necessarily sequential is in one

00:04:58,930 --> 00:05:02,800
happens and then one like like you don't

00:05:01,360 --> 00:05:04,300
do code elimination and then make all

00:05:02,800 --> 00:05:06,550
expansion and then name resolution like

00:05:04,300 --> 00:05:07,839
they are sort of interchangeable so you

00:05:06,550 --> 00:05:13,300
actually have to look at the code to

00:05:07,839 --> 00:05:16,830
know exactly what the steps are yeah so

00:05:13,300 --> 00:05:20,770
talking about code elimination this is

00:05:16,830 --> 00:05:24,819
if we ever see C++ background this is

00:05:20,770 --> 00:05:26,379
where they if devs they're like it's

00:05:24,819 --> 00:05:30,249
like an equivalent of if there's away

00:05:26,379 --> 00:05:33,399
yeah this is quote what is that they

00:05:30,249 --> 00:05:37,330
call it code conditional conditional

00:05:33,399 --> 00:05:39,879
compilation so that is why I know C plus

00:05:37,330 --> 00:05:44,080
C C++ you get your if there's and things

00:05:39,879 --> 00:05:46,839
like that so it is nice because code

00:05:44,080 --> 00:05:49,120
conditional compilation is nice because

00:05:46,839 --> 00:05:50,949
you can keep everything in you know one

00:05:49,120 --> 00:05:53,979
code base you don't have to have okay

00:05:50,949 --> 00:05:55,360
this this part is actually for for the

00:05:53,979 --> 00:05:56,800
sake texture this part is another

00:05:55,360 --> 00:06:01,180
catechol you can just have them in the

00:05:56,800 --> 00:06:03,129
one which simplifies I guess debugging

00:06:01,180 --> 00:06:08,740
it's also nice event since that I

00:06:03,129 --> 00:06:12,339
related I in in one place yeah and he

00:06:08,740 --> 00:06:15,580
has an example of conditional

00:06:12,339 --> 00:06:19,330
compilation where you do use a CFG as an

00:06:15,580 --> 00:06:25,899
example where you want to compare code

00:06:19,330 --> 00:06:30,339
for for Windows in in in such a case

00:06:25,899 --> 00:06:34,330
okay let's just look at an example this

00:06:30,339 --> 00:06:39,009
is an example from some code that I

00:06:34,330 --> 00:06:42,399
actually wrote from some great so what

00:06:39,009 --> 00:06:43,490
you'll see that is that you see that's a

00:06:42,399 --> 00:06:47,699
one line day

00:06:43,490 --> 00:06:49,530
that second line this is CFG windows it

00:06:47,699 --> 00:06:52,469
means that unseat em in a valance is a

00:06:49,530 --> 00:06:54,360
patent rep will not compile on Linux so

00:06:52,469 --> 00:06:55,889
whenever whenever you build this Felina

00:06:54,360 --> 00:06:58,889
it's not compile only nice about compare

00:06:55,889 --> 00:07:02,939
for Linux because remember we have cross

00:06:58,889 --> 00:07:05,969
compilation so what's happening there is

00:07:02,939 --> 00:07:08,069
that when you compile for Linux is going

00:07:05,969 --> 00:07:12,509
to be like that that code does not exist

00:07:08,069 --> 00:07:15,000
that and see them so it's only it's only

00:07:12,509 --> 00:07:17,370
useful for Windows so the reason

00:07:15,000 --> 00:07:19,319
actually did this is to add color

00:07:17,370 --> 00:07:21,599
support for Windows is like by default

00:07:19,319 --> 00:07:23,699
Indian you don't actually get color out

00:07:21,599 --> 00:07:25,020
of it so you have to do it feels like a

00:07:23,699 --> 00:07:27,509
hack actually you have to do something

00:07:25,020 --> 00:07:31,319
like this because you know that's quite

00:07:27,509 --> 00:07:35,219
different from UNIX right anyways moving

00:07:31,319 --> 00:07:38,190
on and then remember just a few steps

00:07:35,219 --> 00:07:44,189
this now macro expansion which is kind

00:07:38,190 --> 00:07:47,940
of a it's kind of a big topic so I the

00:07:44,189 --> 00:07:52,289
three forms that I came across there's a

00:07:47,940 --> 00:07:56,900
derive which is which is one example of

00:07:52,289 --> 00:07:59,490
a derive macro is when you want to

00:07:56,900 --> 00:08:03,060
automatically print out the debug

00:07:59,490 --> 00:08:05,639
information from your from your code so

00:08:03,060 --> 00:08:07,620
all you do you just do for example a

00:08:05,639 --> 00:08:10,529
derive debug and then whenever you print

00:08:07,620 --> 00:08:12,330
line that and then tell it to give you

00:08:10,529 --> 00:08:15,000
back information you get all of these

00:08:12,330 --> 00:08:17,219
things for free that is one example and

00:08:15,000 --> 00:08:20,759
then you get the second example which is

00:08:17,219 --> 00:08:23,520
function like this one is quite common

00:08:20,759 --> 00:08:26,580
everybody comes across it big example is

00:08:23,520 --> 00:08:29,960
the print line that's a that's also a

00:08:26,580 --> 00:08:34,440
macro and then years of the attribute

00:08:29,960 --> 00:08:36,959
the attribute form wishes I Encarta yet

00:08:34,440 --> 00:08:42,180
when I write code with dot which I'm

00:08:36,959 --> 00:08:43,709
actually a fan of struct is is is a

00:08:42,180 --> 00:08:48,600
crate that's actually built on top of

00:08:43,709 --> 00:08:51,190
clip which does a command line passing

00:08:48,600 --> 00:08:54,129
command line interface passing

00:08:51,190 --> 00:08:56,589
anyways so here's an example of a maker

00:08:54,129 --> 00:09:01,389
expansion so you have an asset yeah I

00:08:56,589 --> 00:09:03,970
said as idq that's this actually makes

00:09:01,389 --> 00:09:05,079
you a good penny for example if if your

00:09:03,970 --> 00:09:07,870
things are not the things that you are

00:09:05,079 --> 00:09:11,620
comparing are not equal so this one will

00:09:07,870 --> 00:09:13,240
definitely succeed because we all know

00:09:11,620 --> 00:09:19,930
and believe that the one equals one

00:09:13,240 --> 00:09:21,339
right so anyways and then this is this

00:09:19,930 --> 00:09:25,329
is actually what happens

00:09:21,339 --> 00:09:27,610
so macro expansion takes that bit of

00:09:25,329 --> 00:09:30,209
code and then creates this and this is

00:09:27,610 --> 00:09:35,170
actually just a snippet of it is quite

00:09:30,209 --> 00:09:38,110
it's quite it makes it quite hard to

00:09:35,170 --> 00:09:39,550
read right but yeah this is this was

00:09:38,110 --> 00:09:41,290
given you can try to make sense of

00:09:39,550 --> 00:09:43,629
what's happening like you can see there

00:09:41,290 --> 00:09:45,339
for example it's a match statement

00:09:43,629 --> 00:09:49,449
you're comparing left and right we lose

00:09:45,339 --> 00:09:51,430
and it's going to panic with a message

00:09:49,449 --> 00:09:56,139
with that message that you see a session

00:09:51,430 --> 00:09:59,769
failed if if there's problems right if

00:09:56,139 --> 00:10:03,339
both sides are not equal anyways moving

00:09:59,769 --> 00:10:07,420
on to with with macro expansion here's

00:10:03,339 --> 00:10:10,720
an example from struck table you see you

00:10:07,420 --> 00:10:14,170
get simple nice code like that that

00:10:10,720 --> 00:10:16,540
actually gets degenerated into this this

00:10:14,170 --> 00:10:17,980
is sort of beautified because the stuff

00:10:16,540 --> 00:10:20,639
is so low is all over the place so I

00:10:17,980 --> 00:10:24,160
just put it together for readability so

00:10:20,639 --> 00:10:26,740
basically the u.s. you are telling it to

00:10:24,160 --> 00:10:29,019
accept their long option and long option

00:10:26,740 --> 00:10:31,470
is that is that thing in command line

00:10:29,019 --> 00:10:33,759
interfaces where you do like a dash dash

00:10:31,470 --> 00:10:37,029
so if you're going to give the command

00:10:33,759 --> 00:10:41,949
for example black command dash dash

00:10:37,029 --> 00:10:43,720
ignorant rect and then you basically

00:10:41,949 --> 00:10:45,189
create that the variable called ignorant

00:10:43,720 --> 00:10:46,329
right and then this is this the one

00:10:45,189 --> 00:10:47,740
that's going to tell you that it's

00:10:46,329 --> 00:10:49,809
actually defined on the command line and

00:10:47,740 --> 00:10:53,230
then you can act on it and that's they

00:10:49,809 --> 00:10:54,959
helped string and then this is pretty

00:10:53,230 --> 00:10:59,800
much the good that degenerates

00:10:54,959 --> 00:11:03,220
she's quite less comfortable to type but

00:10:59,800 --> 00:11:04,550
ladies so yeah this is a macro expansion

00:11:03,220 --> 00:11:07,339
those are just small

00:11:04,550 --> 00:11:11,990
examples of what's a penny and K so this

00:11:07,339 --> 00:11:16,600
is another another step it's called a

00:11:11,990 --> 00:11:19,940
name resolution so that allows you to do

00:11:16,600 --> 00:11:22,190
to use the same names for like multiple

00:11:19,940 --> 00:11:24,350
things like things are not that are not

00:11:22,190 --> 00:11:28,700
the table same type like this is pretty

00:11:24,350 --> 00:11:32,209
much for convenience I mean if you take

00:11:28,700 --> 00:11:34,579
a look at that example you see we use

00:11:32,209 --> 00:11:37,130
the same name X for multiple things we

00:11:34,579 --> 00:11:42,230
make we we create a type called X and

00:11:37,130 --> 00:11:44,630
then we also and then we create a

00:11:42,230 --> 00:11:47,660
variable called X as well that will

00:11:44,630 --> 00:11:49,519
actually compare so what name the

00:11:47,660 --> 00:11:51,920
resolution does it that it looks at that

00:11:49,519 --> 00:11:53,600
code and then notices that they are

00:11:51,920 --> 00:11:55,760
actually not the same thing so it's

00:11:53,600 --> 00:12:00,290
gonna give them different names that's

00:11:55,760 --> 00:12:01,730
that's pretty much what it does actually

00:12:00,290 --> 00:12:06,200
took this example from the compiler

00:12:01,730 --> 00:12:07,240
guide it's called the rusty guide or

00:12:06,200 --> 00:12:09,980
something like that okay

00:12:07,240 --> 00:12:12,110
so it does they're also variable

00:12:09,980 --> 00:12:14,870
shadowing you know what whatever you

00:12:12,110 --> 00:12:17,209
doing this is you can for example add on

00:12:14,870 --> 00:12:19,970
to that and say let Y is equals to

00:12:17,209 --> 00:12:22,070
whatever type or even the same type or

00:12:19,970 --> 00:12:24,380
whatever and then the compiler accept it

00:12:22,070 --> 00:12:26,750
accepts it so it handles cases like that

00:12:24,380 --> 00:12:29,300
some not on languages can handle that by

00:12:26,750 --> 00:12:32,779
the way which I find quite convenient

00:12:29,300 --> 00:12:34,160
and then it'll also do things because it

00:12:32,779 --> 00:12:37,730
knows about names it's going to do

00:12:34,160 --> 00:12:40,339
things like typo type of fixes like it

00:12:37,730 --> 00:12:42,920
can tell if your variable name is maybe

00:12:40,339 --> 00:12:44,180
too close to another one that this in

00:12:42,920 --> 00:12:46,190
scope and then it's going to give you

00:12:44,180 --> 00:12:49,190
that and then it also gives you

00:12:46,190 --> 00:12:52,820
suggestions for trace too important if

00:12:49,190 --> 00:12:53,990
sin if sin however has a message how

00:12:52,820 --> 00:12:56,060
good they are they actually give you

00:12:53,990 --> 00:12:58,160
those kinds of suggestions like when you

00:12:56,060 --> 00:13:00,740
try to use that type but you don't

00:12:58,160 --> 00:13:03,350
actually have a trait of it that defines

00:13:00,740 --> 00:13:05,870
that type yeah you don't have that the

00:13:03,350 --> 00:13:08,000
trait that it defines a type in scope so

00:13:05,870 --> 00:13:13,000
it will give you such a sense for that

00:13:08,000 --> 00:13:17,720
witches which is quite cool okay anyways

00:13:13,000 --> 00:13:18,420
moving on so from the ast there is a

00:13:17,720 --> 00:13:23,130
step

00:13:18,420 --> 00:13:26,100
called lowering anyways what is what it

00:13:23,130 --> 00:13:28,019
does it Louis - HHI here is a high level

00:13:26,100 --> 00:13:31,200
intermediate representation of the

00:13:28,019 --> 00:13:34,980
compiler so it sort of takes your ass

00:13:31,200 --> 00:13:37,230
your ass coat and then removes all of

00:13:34,980 --> 00:13:37,980
the conveniences all of the sugar and

00:13:37,230 --> 00:13:40,860
things like that

00:13:37,980 --> 00:13:43,970
and then it takes it into a sort of a

00:13:40,860 --> 00:13:52,230
raw form which is easier to process for

00:13:43,970 --> 00:13:53,820
for your compiler so um yeah so yeah

00:13:52,230 --> 00:13:56,760
like I said yeah the EEOC's converting

00:13:53,820 --> 00:13:59,100
to at each other and then HR is also a

00:13:56,760 --> 00:14:01,320
type type checking is quite important

00:13:59,100 --> 00:14:03,720
type checking happens because yeah it's

00:14:01,320 --> 00:14:08,070
easier to work on something a more

00:14:03,720 --> 00:14:11,310
simple representation so these are just

00:14:08,070 --> 00:14:15,089
the commands if you wanted to see the

00:14:11,310 --> 00:14:17,459
output of what each hir looks like that

00:14:15,089 --> 00:14:22,560
is the that's what the commands look

00:14:17,459 --> 00:14:26,370
like so you'll give it you go into your

00:14:22,560 --> 00:14:28,560
crit direct variant and run that hir and

00:14:26,370 --> 00:14:30,839
you later see what the output actually

00:14:28,560 --> 00:14:34,620
looks like like I don't know why they

00:14:30,839 --> 00:14:36,779
use the name and pretty actually and I

00:14:34,620 --> 00:14:38,910
don't think it has to do with they look

00:14:36,779 --> 00:14:45,540
up the code that's it's it's quite

00:14:38,910 --> 00:14:49,550
curious anyways moving on I wanna

00:14:45,540 --> 00:14:52,680
digress just a little bit and talk about

00:14:49,550 --> 00:14:56,250
Rick's risk v this wife is a target that

00:14:52,680 --> 00:14:59,220
I chose for for the output of the code

00:14:56,250 --> 00:15:04,680
cause I wanted to learn a bit more about

00:14:59,220 --> 00:15:07,050
it it's actually a new is a is a is is

00:15:04,680 --> 00:15:09,480
actually an instruction set architecture

00:15:07,050 --> 00:15:12,660
is a is like an example of it I say I

00:15:09,480 --> 00:15:16,050
think the most famous is x86 and you

00:15:12,660 --> 00:15:18,630
also have um so his life is like a sort

00:15:16,050 --> 00:15:21,620
of a newborn competitor in the effort so

00:15:18,630 --> 00:15:24,149
I find it nice because I like the well

00:15:21,620 --> 00:15:27,269
reading the motivation for it actually

00:15:24,149 --> 00:15:30,000
the design is is good and the people

00:15:27,269 --> 00:15:31,120
actually learn from them from issues in

00:15:30,000 --> 00:15:34,930
the design of the

00:15:31,120 --> 00:15:39,610
a native ASA's so which is cool it's

00:15:34,930 --> 00:15:42,190
also it's also libera so you don't have

00:15:39,610 --> 00:15:45,490
to pay royalties and licensing fees and

00:15:42,190 --> 00:15:46,930
turns like that to use it which is which

00:15:45,490 --> 00:15:49,540
is actually cool it allows because

00:15:46,930 --> 00:15:52,029
because it allows it allows a lot of

00:15:49,540 --> 00:15:53,500
people well you must be motivated right

00:15:52,029 --> 00:15:58,029
but it allows a lot of people to

00:15:53,500 --> 00:16:01,240
actually participate in process I design

00:15:58,029 --> 00:16:03,850
wish wish normal you actually have to

00:16:01,240 --> 00:16:06,670
pay a hefty fee or whatever to to be

00:16:03,850 --> 00:16:08,440
able to do it so which you know so fast

00:16:06,670 --> 00:16:11,260
does it so fastest innovation right I

00:16:08,440 --> 00:16:13,150
mean if you look at open source for

00:16:11,260 --> 00:16:15,010
example which which was an inspiration

00:16:13,150 --> 00:16:20,190
for me part of the inspiration of making

00:16:15,010 --> 00:16:25,779
it open so I wondered also to note that

00:16:20,190 --> 00:16:28,420
there is of course for Ares 5 but it

00:16:25,779 --> 00:16:30,360
doesn't have Lipstadt support so you

00:16:28,420 --> 00:16:33,130
won't be able for example to run it on

00:16:30,360 --> 00:16:39,360
one Linux so it's all pay metal at the

00:16:33,130 --> 00:16:42,339
moment ok so sort of an intro to Ritz 5

00:16:39,360 --> 00:16:48,670
there's three basic forms so there's a

00:16:42,339 --> 00:16:49,470
32 bits it 4-bit 128 bit and yeah those

00:16:48,670 --> 00:16:52,120
are called

00:16:49,470 --> 00:16:57,430
instruction sets basil base instruction

00:16:52,120 --> 00:17:01,360
sets these are these are the things that

00:16:57,430 --> 00:17:03,459
that you have to implement for it to be

00:17:01,360 --> 00:17:05,949
called the rig's Ares 5 because there's

00:17:03,459 --> 00:17:07,990
actually a standard out there and then

00:17:05,949 --> 00:17:09,760
everything else is it's a modular design

00:17:07,990 --> 00:17:11,470
so everything else is optional

00:17:09,760 --> 00:17:13,959
you only need to implement distance and

00:17:11,470 --> 00:17:16,569
everything else for example you can you

00:17:13,959 --> 00:17:18,370
can actually simulate it if you if you

00:17:16,569 --> 00:17:20,319
want the more abilities you know like

00:17:18,370 --> 00:17:23,490
for example multiplication a turns like

00:17:20,319 --> 00:17:26,410
that so anyway so this instruction

00:17:23,490 --> 00:17:28,480
provides some basic things like memory

00:17:26,410 --> 00:17:30,370
reads writes these are actually assembly

00:17:28,480 --> 00:17:32,530
instructions simple arithmetic as

00:17:30,370 --> 00:17:36,340
additional attraction logical operations

00:17:32,530 --> 00:17:38,800
like your ends and O's and then

00:17:36,340 --> 00:17:40,179
branching branching is like jumping to

00:17:38,800 --> 00:17:42,580
other instructions because you can just

00:17:40,179 --> 00:17:46,350
have sequential code right I mean how do

00:17:42,580 --> 00:17:46,350
you do mix so

00:17:47,670 --> 00:17:57,640
so anyways the difference between the

00:17:53,309 --> 00:17:59,530
three you'll find that like cc-64 the

00:17:57,640 --> 00:18:01,180
64-bit version will have a bit more

00:17:59,530 --> 00:18:04,480
instructions which allow it to operate

00:18:01,180 --> 00:18:07,750
on bigger they similarly through 120

00:18:04,480 --> 00:18:12,610
that's the basic difference and then and

00:18:07,750 --> 00:18:13,270
then finally so like I said last the

00:18:12,610 --> 00:18:16,240
supports

00:18:13,270 --> 00:18:19,210
there is five target and there's

00:18:16,240 --> 00:18:23,530
actually two of them which is that there

00:18:19,210 --> 00:18:26,559
is at least 80 - I'm a crispy 32 imc and

00:18:23,530 --> 00:18:31,240
then those are some of the explanations

00:18:26,559 --> 00:18:36,640
so I is that base 1mm is a multiply and

00:18:31,240 --> 00:18:40,210
a is atomic C compressed so so again

00:18:36,640 --> 00:18:42,880
what what this means is that it allows

00:18:40,210 --> 00:18:44,650
you an option that would be for example

00:18:42,880 --> 00:18:48,760
if you wanted to build a processor that

00:18:44,650 --> 00:18:50,860
way you don't care about floating points

00:18:48,760 --> 00:18:53,110
which by the way does not support

00:18:50,860 --> 00:18:55,480
because that one would be F would be a

00:18:53,110 --> 00:18:56,950
big F if you don't care about routine

00:18:55,480 --> 00:18:58,510
when you just broke your processor you

00:18:56,950 --> 00:19:00,130
don't have to rely on somebody built an

00:18:58,510 --> 00:19:02,950
entire processors and you only did meet

00:19:00,130 --> 00:19:06,840
a little only a small part of it or

00:19:02,950 --> 00:19:06,840
something like that so

00:19:10,720 --> 00:19:16,210
yeah okay anyways let's just look at a

00:19:14,230 --> 00:19:19,810
little bit of good this is my this is

00:19:16,210 --> 00:19:21,880
just some poor code that I want to use

00:19:19,810 --> 00:19:26,680
so you can actually have a look at some

00:19:21,880 --> 00:19:29,380
of the some of the output yeah I choose

00:19:26,680 --> 00:19:32,710
something simple because the output at

00:19:29,380 --> 00:19:34,840
those intermediate and final expanded

00:19:32,710 --> 00:19:37,030
layers is actually quite ridiculous it's

00:19:34,840 --> 00:19:39,580
hot it's actually quite hard to read so

00:19:37,030 --> 00:19:44,020
it makes appreciate using a high level

00:19:39,580 --> 00:19:46,300
language because yeah it's it's it's

00:19:44,020 --> 00:19:48,370
it's quite a bit so anyways because even

00:19:46,300 --> 00:19:55,750
the small example is quite it's quite

00:19:48,370 --> 00:19:59,980
it's quite big okay so anyways so that

00:19:55,750 --> 00:20:02,890
is that this example each our output for

00:19:59,980 --> 00:20:05,020
example you'll see that it added a

00:20:02,890 --> 00:20:07,210
little bit of code you know like for

00:20:05,020 --> 00:20:09,190
example the prelude which you normally

00:20:07,210 --> 00:20:12,100
don't see which is a actually own Venus

00:20:09,190 --> 00:20:14,500
that Roz gives you but what atomically

00:20:12,100 --> 00:20:17,460
added they all see great Co for example

00:20:14,500 --> 00:20:21,100
we we can access the the core library

00:20:17,460 --> 00:20:25,380
compiler burdens which gives you some

00:20:21,100 --> 00:20:28,960
nice features anyway so what happens

00:20:25,380 --> 00:20:32,800
during the each error stage you get

00:20:28,960 --> 00:20:37,690
impedances like type type inference type

00:20:32,800 --> 00:20:39,820
checking trade resolution so yeah the

00:20:37,690 --> 00:20:42,540
list is not comprehensive to see three

00:20:39,820 --> 00:20:45,670
detail you actually have to look at the

00:20:42,540 --> 00:20:49,930
at the HAART which is like super super

00:20:45,670 --> 00:20:52,360
detailed and then we'll ever look no

00:20:49,930 --> 00:20:53,170
actually no we wonder will give us it

00:20:52,360 --> 00:20:58,600
was way too big

00:20:53,170 --> 00:21:02,410
and anyways skipping oh yeah again

00:20:58,600 --> 00:21:04,600
that's that just the the the comment if

00:21:02,410 --> 00:21:07,150
you wanted to actually have a look at

00:21:04,600 --> 00:21:10,840
the diamond it's quite messy but this

00:21:07,150 --> 00:21:15,040
sort of gives you some insight into into

00:21:10,840 --> 00:21:18,040
how things are broken up so anyways mmm

00:21:15,040 --> 00:21:21,310
so the next step is that the HAR

00:21:18,040 --> 00:21:24,340
is tenth into what is called the mir

00:21:21,310 --> 00:21:30,720
which is medium because it says between

00:21:24,340 --> 00:21:33,840
the hir and LLVM IR IR is also

00:21:30,720 --> 00:21:38,170
intermediate representation which is how

00:21:33,840 --> 00:21:40,600
the LLVM represents the causes like sort

00:21:38,170 --> 00:21:47,410
of the lowest level so there's like a

00:21:40,600 --> 00:21:49,510
medium so that's also it's also the the

00:21:47,410 --> 00:21:52,750
concept I also simplified even further

00:21:49,510 --> 00:21:54,730
here where for example your matches are

00:21:52,750 --> 00:21:57,010
removed and your loops are moves and

00:21:54,730 --> 00:21:58,920
then you use you have to use a co2 for

00:21:57,010 --> 00:22:02,730
example which is actually closer to what

00:21:58,920 --> 00:22:07,260
how assembly actually represents it

00:22:02,730 --> 00:22:09,970
anyway so what what happens on Mir

00:22:07,260 --> 00:22:11,860
something quite important actually which

00:22:09,970 --> 00:22:14,440
is Bora checking which is like a pretty

00:22:11,860 --> 00:22:17,140
critical part of what makes us special

00:22:14,440 --> 00:22:19,960
right away you actually do many memory

00:22:17,140 --> 00:22:22,540
management but at compile time so that

00:22:19,960 --> 00:22:25,660
gives you save time and there's a few

00:22:22,540 --> 00:22:27,460
things that it checks for like

00:22:25,660 --> 00:22:29,920
wherever's can be used an initialized or

00:22:27,460 --> 00:22:33,970
whatever right and what else it does

00:22:29,920 --> 00:22:36,180
some some pre optimization so that LLVM

00:22:33,970 --> 00:22:39,160
will have an easier time actually doing

00:22:36,180 --> 00:22:41,350
doing its own optimization because it

00:22:39,160 --> 00:22:43,360
understands because it's a raster itit

00:22:41,350 --> 00:22:46,450
understands itself modern trust modern

00:22:43,360 --> 00:22:51,850
LLVM with well so yeah the output is

00:22:46,450 --> 00:22:55,270
LLVM ir and then that this example that

00:22:51,850 --> 00:22:58,270
is example of what Mir output looks like

00:22:55,270 --> 00:23:00,970
which is you can tell they're the

00:22:58,270 --> 00:23:05,020
interesting one is actually that vb0

00:23:00,970 --> 00:23:06,760
block where you'll see if you have a

00:23:05,020 --> 00:23:09,070
look there underscore and underscore and

00:23:06,760 --> 00:23:11,170
is actually your argument then what you

00:23:09,070 --> 00:23:14,920
do that check multiplication you

00:23:11,170 --> 00:23:16,690
multiply that to entry and then there's

00:23:14,920 --> 00:23:18,130
some magical acid that inside that for

00:23:16,690 --> 00:23:21,070
you for buffalo checking enters like

00:23:18,130 --> 00:23:25,300
that so there we go and then this is

00:23:21,070 --> 00:23:28,570
just simple l olivia i our output it is

00:23:25,300 --> 00:23:31,170
quite massive so I only choose a more

00:23:28,570 --> 00:23:33,370
sort of meaningful example which is

00:23:31,170 --> 00:23:37,270
represents what happens there if you see

00:23:33,370 --> 00:23:41,350
that as there's a multiply they happy

00:23:37,270 --> 00:23:43,240
and I don't know what extract they lose

00:23:41,350 --> 00:23:46,480
the Oz and all of that it's a whole I

00:23:43,240 --> 00:23:49,180
think it's a whole talk by itself but

00:23:46,480 --> 00:23:51,690
yeah that's just interesting looking at

00:23:49,180 --> 00:23:54,820
what it looks like and then finally

00:23:51,690 --> 00:24:00,340
we're almost family finally you get to

00:23:54,820 --> 00:24:06,360
see what the assembly looks like so if

00:24:00,340 --> 00:24:08,770
you look at Maine they you'll see I

00:24:06,360 --> 00:24:10,120
should have put some example could yes

00:24:08,770 --> 00:24:15,610
you'll see that I was I was actually

00:24:10,120 --> 00:24:18,760
giving 1983 which is a bit rare in

00:24:15,610 --> 00:24:22,120
number and remember was our if I was

00:24:18,760 --> 00:24:24,640
actually giving it it was an argument to

00:24:22,120 --> 00:24:27,420
a function call and then the this words

00:24:24,640 --> 00:24:32,050
opinion so basically take 1983 put it in

00:24:27,420 --> 00:24:34,480
an original called a zero and then

00:24:32,050 --> 00:24:38,800
you'll see that after that you actually

00:24:34,480 --> 00:24:40,480
call a function called square and then

00:24:38,800 --> 00:24:43,780
if you ignore some of those things

00:24:40,480 --> 00:24:45,220
you'll see the instruction called mu L

00:24:43,780 --> 00:24:49,480
that's where the multiply actually

00:24:45,220 --> 00:24:52,360
happens so remember that a 0 a 0 is just

00:24:49,480 --> 00:24:57,610
is just 1 right what what what that does

00:24:52,360 --> 00:24:59,740
is that into register called a 1 put put

00:24:57,610 --> 00:25:04,120
the result of the multiplication of this

00:24:59,740 --> 00:25:07,000
to register services a 0 and a 0 at 1983

00:25:04,120 --> 00:25:09,580
and you can ignore the rest of the

00:25:07,000 --> 00:25:13,930
detail generated assembly was like 120

00:25:09,580 --> 00:25:16,380
lines and yeah note that that didn't go

00:25:13,930 --> 00:25:19,480
as far as doing optimized code because

00:25:16,380 --> 00:25:21,400
that part I don't know I don't I don't

00:25:19,480 --> 00:25:25,930
understand the steps I thought ok no I

00:25:21,400 --> 00:25:29,980
will ignore it anyways so the very final

00:25:25,930 --> 00:25:32,680
step is actually that LLVM takes the via

00:25:29,980 --> 00:25:35,470
takes that quote generates binaries and

00:25:32,680 --> 00:25:38,400
then in the end it actually does the

00:25:35,470 --> 00:25:40,150
linking way it takes all of the various

00:25:38,400 --> 00:25:42,670
dependencies and has like the visual

00:25:40,150 --> 00:25:45,820
there were dozens even even with a test

00:25:42,670 --> 00:25:50,200
for small examples and then finally

00:25:45,820 --> 00:25:50,680
produces an executable and know that

00:25:50,200 --> 00:25:53,710
this is

00:25:50,680 --> 00:25:56,130
not the only one is not unique rust I'm

00:25:53,710 --> 00:25:58,810
not sure if it does it now but you'd

00:25:56,130 --> 00:26:00,760
with examples that I played with you

00:25:58,810 --> 00:26:04,570
would you would need actually need a

00:26:00,760 --> 00:26:12,940
link by link uh from the canoe to tool

00:26:04,570 --> 00:26:18,490
chain which is binary details so so yeah

00:26:12,940 --> 00:26:20,520
thanks I was good it was it was sort of

00:26:18,490 --> 00:26:23,230
easy to lend distance because they say

00:26:20,520 --> 00:26:25,720
that's a guide it's a rustic guide

00:26:23,230 --> 00:26:27,400
wishes which is actually a new project

00:26:25,720 --> 00:26:31,030
this I think it was introduced this year

00:26:27,400 --> 00:26:34,720
so Allen sometimes they and I wanted to

00:26:31,030 --> 00:26:36,640
also give special thanks to respect

00:26:34,720 --> 00:26:40,920
Paris for inspiring me to give a talk

00:26:36,640 --> 00:26:44,220
and Russ team is amazing of course and

00:26:40,920 --> 00:26:48,010
yeah and then rust intense lights

00:26:44,220 --> 00:26:50,230
thanks for to Steve for actually

00:26:48,010 --> 00:26:55,710
produced that cause yeah it helped with

00:26:50,230 --> 00:26:59,609
my doing the presentation thanks

00:26:55,710 --> 00:26:59,609
[Applause]

00:27:01,300 --> 00:27:07,670
okay sorry we don't have time for

00:27:03,950 --> 00:27:11,300
questions now because we just delayed a

00:27:07,670 --> 00:27:13,550
little bit so if you have any more

00:27:11,300 --> 00:27:16,850
questions you can find him at the coffee

00:27:13,550 --> 00:27:18,710
break probably and so please help

00:27:16,850 --> 00:27:21,410
yourself have some coffee has eat

00:27:18,710 --> 00:27:24,529
something and thanks

00:27:21,410 --> 00:27:24,529

YouTube URL: https://www.youtube.com/watch?v=EZHnzTk8YaU


