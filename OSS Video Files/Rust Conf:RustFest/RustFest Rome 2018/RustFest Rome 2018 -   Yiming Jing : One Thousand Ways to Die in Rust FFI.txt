Title: RustFest Rome 2018 -   Yiming Jing : One Thousand Ways to Die in Rust FFI
Publication date: 2018-11-24
Playlist: RustFest Rome 2018
Description: 
	Efficient FFI bindings are one of the core features of Rust; however dereferencing raw pointers, conversion between Rust and C types, memory allocation, ..., all could possibly go wrong in FFI code and undermine the memory safety guarantee of Rust. The Rustonomicon and a few previous talks at RustFest discuss the topic of Rust FFI; but overlook the challenges in writing correct and safe FFI code. In this talk, we discuss a taxonomy of common pitfalls in Rust FFI with real-world examples. Moreover, we will review relevant principles and share our approach to effectively avoid the pitfalls.

https://rome.rustfest.eu/sessions/one-thousand-ways-to-die-in-rust-ffi
https://media.ccc.de/v/rustfest-rome-9-one-thousand-ways-to-die-in-rust-ffi
Captions: 
	00:00:04,590 --> 00:00:10,599
I know ever

00:00:07,610 --> 00:00:14,389
[Applause]

00:00:10,599 --> 00:00:17,720
so our next speaker is Eamon Jean

00:00:14,389 --> 00:00:22,220
he works for by do and today he will

00:00:17,720 --> 00:00:26,059
tells us about the how to interface rust

00:00:22,220 --> 00:00:28,329
with C pitfalls problems how to solve

00:00:26,059 --> 00:00:30,669
them how to overcome them because

00:00:28,329 --> 00:00:32,689
documentation is one thing but

00:00:30,669 --> 00:00:52,490
experience is something else

00:00:32,689 --> 00:00:55,820
so please welcome basically talk about

00:00:52,490 --> 00:00:58,610
the lessons the experiences we gain when

00:00:55,820 --> 00:01:00,320
we try to rust a vehicle in our in our

00:00:58,610 --> 00:01:04,250
open source programs every in production

00:01:00,320 --> 00:01:07,130
so my name is even change am security

00:01:04,250 --> 00:01:09,799
scientist engineer at by 2x lab so I'm

00:01:07,130 --> 00:01:13,429
also the author of missile ink basically

00:01:09,799 --> 00:01:16,490
missile ink is a test library providing

00:01:13,429 --> 00:01:17,329
open SSL compatible CIPS for rusty RS or

00:01:16,490 --> 00:01:19,939
Russells

00:01:17,329 --> 00:01:22,759
so with Missa link we can bring rust

00:01:19,939 --> 00:01:25,069
into many places where open SL and C

00:01:22,759 --> 00:01:27,859
used to dominate of example Android a

00:01:25,069 --> 00:01:30,049
lot of places and why do we have

00:01:27,859 --> 00:01:33,530
deployed miss a link in our applications

00:01:30,049 --> 00:01:36,380
running on Android powered smart TVs as

00:01:33,530 --> 00:01:39,409
of now from from my college I heard that

00:01:36,380 --> 00:01:42,259
mr. Bing has accumulated about more than

00:01:39,409 --> 00:01:46,279
4.4 million monthly active users and its

00:01:42,259 --> 00:01:49,399
rapid growing it's growing very fast and

00:01:46,279 --> 00:01:51,770
in August we managed to to contribute

00:01:49,399 --> 00:01:54,590
code to the curve project so meta link

00:01:51,770 --> 00:01:57,590
is currently one of leap curves 12 POS

00:01:54,590 --> 00:02:01,310
backends and it is also one of the seven

00:01:57,590 --> 00:02:04,060
beckons that support geometry and it is

00:02:01,310 --> 00:02:10,340
the only one which is retaining rusty

00:02:04,060 --> 00:02:12,530
and speaking of our X lab so we are a

00:02:10,340 --> 00:02:15,650
research lab based in California United

00:02:12,530 --> 00:02:17,150
States and for bi do bi do is the second

00:02:15,650 --> 00:02:20,030
largest search engine in the world and

00:02:17,150 --> 00:02:22,760
the biggest wine China entered app is

00:02:20,030 --> 00:02:25,849
led by our chief security

00:02:22,760 --> 00:02:29,659
Oh links way and he's a big fan of

00:02:25,849 --> 00:02:32,540
memory safety languages like rust and we

00:02:29,659 --> 00:02:34,819
have several open source projects which

00:02:32,540 --> 00:02:37,099
is a which are implemented by memories

00:02:34,819 --> 00:02:39,580
of languages including rastko and our

00:02:37,099 --> 00:02:43,250
Python and mr. Ling is just one of them

00:02:39,580 --> 00:02:44,989
and if you were a trust first Paris

00:02:43,250 --> 00:02:48,260
earlier this year you may have seen our

00:02:44,989 --> 00:02:51,170
work about bringing in hell as gx2 the

00:02:48,260 --> 00:02:53,659
rust ecosystem so which is the rust SGX

00:02:51,170 --> 00:02:56,440
production here in the first row oh and

00:02:53,659 --> 00:02:56,440
the second one from the left

00:02:56,560 --> 00:03:01,459
so in today's talk I'm gonna I'm gonna

00:02:59,780 --> 00:03:03,799
share with you the experiences the

00:03:01,459 --> 00:03:06,349
pitfalls in the lessons we learned when

00:03:03,799 --> 00:03:10,970
we implement open cells ap is in mr.

00:03:06,349 --> 00:03:13,549
link with 100% Russ code so first we'll

00:03:10,970 --> 00:03:16,040
start from a simple hello world F of

00:03:13,549 --> 00:03:18,890
example and see how it ends in a

00:03:16,040 --> 00:03:21,079
disaster mani box so then I'm gonna

00:03:18,890 --> 00:03:22,129
cover Tim patterns and anti patterns in

00:03:21,079 --> 00:03:25,160
writing idiomatic

00:03:22,129 --> 00:03:28,609
fi code and finally a quick recap and

00:03:25,160 --> 00:03:30,590
future work so through our code is a

00:03:28,609 --> 00:03:32,239
code examples in this talk if you've

00:03:30,590 --> 00:03:34,099
seen a green checkmark then it means

00:03:32,239 --> 00:03:37,099
this is a good pattern and we recommend

00:03:34,099 --> 00:03:39,349
using that and if you see a red cross

00:03:37,099 --> 00:03:42,290
mark then it means it is an antibody and

00:03:39,349 --> 00:03:44,959
a pattern it's not good news and one

00:03:42,290 --> 00:03:46,700
song means a pattern we suggest to use

00:03:44,959 --> 00:03:48,349
with culturing because it may involve

00:03:46,700 --> 00:03:52,730
some unsafe code and some assumptions

00:03:48,349 --> 00:03:56,269
you must be aware of if I use it so I

00:03:52,730 --> 00:03:57,889
start so this is a hard were example

00:03:56,269 --> 00:04:00,950
from the Russ programming language book

00:03:57,889 --> 00:04:03,680
of the textbook so what it does is very

00:04:00,950 --> 00:04:07,660
simple so it converts or I mean let me

00:04:03,680 --> 00:04:07,660
zoom in so in case you can't see it so

00:04:07,870 --> 00:04:15,049
what it does it is to convert a string

00:04:10,519 --> 00:04:17,660
literal which is her or us here to some

00:04:15,049 --> 00:04:20,599
errors to a reminder so the string can

00:04:17,660 --> 00:04:22,849
can be used by some external C code so

00:04:20,599 --> 00:04:24,560
the no mango Domingo attribute here

00:04:22,849 --> 00:04:26,660
turns off with Ross name mangling so

00:04:24,560 --> 00:04:29,000
this function can be exported and it

00:04:26,660 --> 00:04:31,159
makes the linker happy so it works

00:04:29,000 --> 00:04:32,360
pretty well but this function just says

00:04:31,159 --> 00:04:35,599
hello too

00:04:32,360 --> 00:04:37,810
only so here so what do you want a

00:04:35,599 --> 00:04:45,830
function to say hello to more languages

00:04:37,810 --> 00:04:47,960
so we got this one this is we just add

00:04:45,830 --> 00:04:52,430
another parameter called who enter our

00:04:47,960 --> 00:04:56,060
PDR which which is applying her to a

00:04:52,430 --> 00:04:59,090
string in C you can put maybe Python

00:04:56,060 --> 00:05:02,870
maybe go here to pass it to a tourist

00:04:59,090 --> 00:05:05,210
function and this function body consists

00:05:02,870 --> 00:05:07,969
of only two essentially two lines of

00:05:05,210 --> 00:05:10,520
code if we put the breakfast on the same

00:05:07,969 --> 00:05:14,930
line so the first line converts the

00:05:10,520 --> 00:05:17,930
pointer to cscr and we can were the cstr

00:05:14,930 --> 00:05:20,779
to a row string Russ STR and we use the

00:05:17,930 --> 00:05:24,560
format macro to to concatenate hello

00:05:20,779 --> 00:05:27,770
with the with with the input and we

00:05:24,560 --> 00:05:30,199
return it as a pack so this function has

00:05:27,770 --> 00:05:32,240
several box in this dead simple to

00:05:30,199 --> 00:05:33,770
launch the code so maybe let's just

00:05:32,240 --> 00:05:35,979
spend a few second to see if we can find

00:05:33,770 --> 00:05:35,979
out

00:05:41,780 --> 00:05:48,360
okay so um maybe you can guess I'll put

00:05:45,750 --> 00:05:53,670
five Red Cross Monsieur so at least five

00:05:48,360 --> 00:05:56,250
bucks so first um you have notice the

00:05:53,670 --> 00:05:57,810
pointer we have in a check if the

00:05:56,250 --> 00:06:01,140
partner is no partner so that's the

00:05:57,810 --> 00:06:05,520
first one and the second one the unwrap

00:06:01,140 --> 00:06:07,590
here may panic and as you know if you

00:06:05,520 --> 00:06:11,190
function panics if your trigger is like

00:06:07,590 --> 00:06:13,200
unwinding and if the stack a once across

00:06:11,190 --> 00:06:17,100
an FFA boundary then it is totally and

00:06:13,200 --> 00:06:20,430
even be able and the third one the

00:06:17,100 --> 00:06:27,990
format mackerel here eric is a a string

00:06:20,430 --> 00:06:29,730
on the heap but but string would be

00:06:27,990 --> 00:06:33,420
otoscope immunity after the function

00:06:29,730 --> 00:06:37,260
returns so the return pointer is is

00:06:33,420 --> 00:06:45,000
actually a dangling pointer and as a lot

00:06:37,260 --> 00:06:48,110
11 returns a pointer of every star

00:06:45,000 --> 00:06:50,790
constant u8 but here's the tricky thing

00:06:48,110 --> 00:06:53,040
we want the function to return a star

00:06:50,790 --> 00:06:56,310
counts to see underscore char which is a

00:06:53,040 --> 00:06:59,520
type defined in the leap secret but this

00:06:56,310 --> 00:07:02,280
one CNS Kochhar could either be you 808

00:06:59,520 --> 00:07:03,840
depending on the target platform so on

00:07:02,280 --> 00:07:10,230
different platforms this could possibly

00:07:03,840 --> 00:07:13,170
happen mismatch and finally because a c

00:07:10,230 --> 00:07:15,150
string is a is an array of ice which

00:07:13,170 --> 00:07:19,770
terminates with a knock f3 at the end

00:07:15,150 --> 00:07:21,900
and as you can tell from here this

00:07:19,770 --> 00:07:23,940
string is now terminated with an open up

00:07:21,900 --> 00:07:25,860
header so obviously it doesn't return a

00:07:23,940 --> 00:07:27,960
valley the C string fine

00:07:25,860 --> 00:07:32,370
so basically five bucks here in this

00:07:27,960 --> 00:07:34,380
testing go to Alaska so you can see it's

00:07:32,370 --> 00:07:36,960
not that easy to write a correct

00:07:34,380 --> 00:07:39,030
rastafari code so next in the remaining

00:07:36,960 --> 00:07:42,420
remainder of this talk I'll be covering

00:07:39,030 --> 00:07:45,750
ten tips we gained when we write rosetta

00:07:42,420 --> 00:07:47,300
code so the first one point pointers

00:07:45,750 --> 00:07:50,070
anti checks so on top of everything

00:07:47,300 --> 00:07:51,820
always check for non-hunters so it's not

00:07:50,070 --> 00:07:56,560
just for us is for every language

00:07:51,820 --> 00:07:58,600
like Lexi maybe Evie has a point so for

00:07:56,560 --> 00:08:01,720
this one I don't see more about checking

00:07:58,600 --> 00:08:04,270
ok pointers so when we implement a

00:08:01,720 --> 00:08:06,190
missile links EAP is it is quite common

00:08:04,270 --> 00:08:08,860
that we generated an opaque pointer in

00:08:06,190 --> 00:08:15,420
Rus code and pass it to the corner in C

00:08:08,860 --> 00:08:19,150
for example the Umizoomi

00:08:15,420 --> 00:08:22,500
so the SL city x1 this type is an

00:08:19,150 --> 00:08:25,150
example of such pointers miss a link

00:08:22,500 --> 00:08:27,490
when the car in C uses this opaque

00:08:25,150 --> 00:08:35,680
pointer for example as in parameter of

00:08:27,490 --> 00:08:37,690
as a rate different here it is our

00:08:35,680 --> 00:08:40,930
responsibility to check if the pointer

00:08:37,690 --> 00:08:43,180
is indeed what the rascal degenerate for

00:08:40,930 --> 00:08:45,550
because the C part of the C code may may

00:08:43,180 --> 00:08:47,340
just that may make just can't cut the

00:08:45,550 --> 00:08:50,170
pointer to some sometimes we don't know

00:08:47,340 --> 00:08:54,460
so here the point is that we introduce

00:08:50,170 --> 00:08:57,700
magic bytes photos on here I use a you

00:08:54,460 --> 00:09:01,030
32 as the Metro bytes we use the Metro

00:08:57,700 --> 00:09:03,010
pass as type identifiers so such metric

00:09:01,030 --> 00:09:05,250
bars are used for every W miss I think

00:09:03,010 --> 00:09:08,200
that we may generate a key point as well

00:09:05,250 --> 00:09:13,660
we also add a treat called opaque point

00:09:08,200 --> 00:09:15,700
guard and for each type that we generate

00:09:13,660 --> 00:09:18,400
a big point is for we implement this

00:09:15,700 --> 00:09:21,300
treat for them and we also assign a

00:09:18,400 --> 00:09:24,100
different metric number for example here

00:09:21,300 --> 00:09:26,680
the number can be anything it can be a

00:09:24,100 --> 00:09:29,550
USERRA - it can be an array of you a

00:09:26,680 --> 00:09:32,710
device it can be anything you like and

00:09:29,550 --> 00:09:34,540
you can you can you can assign it maybe

00:09:32,710 --> 00:09:37,810
it's dirty trust in the function so as a

00:09:34,540 --> 00:09:42,310
as a constant it miss a link we do it or

00:09:37,810 --> 00:09:45,130
differently we initialize this this this

00:09:42,310 --> 00:09:47,680
magic bytes or with a random function so

00:09:45,130 --> 00:09:50,710
when your libraries web start so

00:09:47,680 --> 00:09:52,840
basically every time you run your to our

00:09:50,710 --> 00:09:56,830
code the measurement will be different

00:09:52,840 --> 00:09:59,590
so increase it Ingrid some difficulty

00:09:56,830 --> 00:10:01,540
for some bad guys to reverse-engineer

00:09:59,590 --> 00:10:02,950
our code and to do something bad with

00:10:01,540 --> 00:10:07,550
the

00:10:02,950 --> 00:10:09,770
so or all the magic by scary type of

00:10:07,550 --> 00:10:12,350
information so we didn't lose it when we

00:10:09,770 --> 00:10:14,240
pass a row behind rusi in that fear when

00:10:12,350 --> 00:10:15,890
because of the the raw parent doesn't

00:10:14,240 --> 00:10:17,930
because the sea can do anything to the

00:10:15,890 --> 00:10:19,730
fire and when the sea pointer is passed

00:10:17,930 --> 00:10:21,230
back to Rosco we can check the metal

00:10:19,730 --> 00:10:28,810
parts to make sure that it is indeed

00:10:21,230 --> 00:10:28,810
what we generally form and for this one

00:10:29,740 --> 00:10:35,050
so tip tip is about type conversion this

00:10:33,920 --> 00:10:37,160
is one of the most common mistakes

00:10:35,050 --> 00:10:39,440
rusted rings are very different from C

00:10:37,160 --> 00:10:42,230
strings so C string are now terminated

00:10:39,440 --> 00:10:44,630
erase advice while rostrums our unicode

00:10:42,230 --> 00:10:48,680
encoded bytes so the good thing is that

00:10:44,630 --> 00:10:52,250
rust provides the cstr to handle

00:10:48,680 --> 00:10:56,600
conversion so the bad thing is that from

00:10:52,250 --> 00:10:59,060
a nascar PDR here it only does that the

00:10:56,600 --> 00:11:02,510
row pointer has input but if you recall

00:10:59,060 --> 00:11:07,070
in see if example like strncpy it also

00:11:02,510 --> 00:11:09,020
has a parameter of lens this is because

00:11:07,070 --> 00:11:10,610
front underscore PTR internally

00:11:09,020 --> 00:11:12,980
calculates the length of the string

00:11:10,610 --> 00:11:16,370
using STR Leon if you check the South's

00:11:12,980 --> 00:11:18,500
coddle you see so in some cases if the

00:11:16,370 --> 00:11:20,930
input stream the pointer here if the

00:11:18,500 --> 00:11:23,930
input is not properly terminated at a

00:11:20,930 --> 00:11:26,000
right position so you may you may you

00:11:23,930 --> 00:11:28,970
may you may you may incur some other

00:11:26,000 --> 00:11:30,680
burn rate so as I suggest here using the

00:11:28,970 --> 00:11:32,360
warning sign additional checks may be

00:11:30,680 --> 00:11:33,770
needed to verify if the C students

00:11:32,360 --> 00:11:36,080
probably terminated our read price

00:11:33,770 --> 00:11:40,850
so otherwise you will think you will get

00:11:36,080 --> 00:11:43,700
an Autobahn read and here's the another

00:11:40,850 --> 00:11:46,010
one I just mentioned before about the

00:11:43,700 --> 00:11:48,590
leap secret it is either IAT go eight

00:11:46,010 --> 00:11:52,670
depending on the target so in some

00:11:48,590 --> 00:11:55,430
platforms follow on x86 platform a CI

00:11:52,670 --> 00:11:58,790
new supercar is i8 but on arm platforms

00:11:55,430 --> 00:12:00,680
it is u8 so the solution is to implement

00:11:58,790 --> 00:12:03,440
to where runs of the function so for you

00:12:00,680 --> 00:12:05,360
18 I ate a copy another solution is to

00:12:03,440 --> 00:12:09,670
cast a slice with the help of raw

00:12:05,360 --> 00:12:09,670
pointers with the Panna here

00:12:10,250 --> 00:12:15,740
this pattern is recommended in the

00:12:12,350 --> 00:12:18,920
documents of STD kong-kong ma'am :

00:12:15,740 --> 00:12:22,880
contrast need without using transmitter

00:12:18,920 --> 00:12:25,160
you can also do it as well tip story is

00:12:22,880 --> 00:12:28,310
about getting see pointers from rust

00:12:25,160 --> 00:12:30,260
rings and rust outlets so we know that

00:12:28,310 --> 00:12:32,030
references carry lifetimes so the bar

00:12:30,260 --> 00:12:34,790
checker can check the life times for us

00:12:32,030 --> 00:12:36,590
but roll pointers are different so we

00:12:34,790 --> 00:12:39,920
must make sure our arrival always

00:12:36,590 --> 00:12:42,260
outlive is pointers so for constant

00:12:39,920 --> 00:12:44,780
strings literals in maze a link of a

00:12:42,260 --> 00:12:48,080
lesson like this one we represent the

00:12:44,780 --> 00:12:50,090
master he you a slices and we manually

00:12:48,080 --> 00:12:54,650
add an altimeter at the end like this

00:12:50,090 --> 00:12:57,770
one so the so the arrival are always

00:12:54,650 --> 00:12:59,450
alpha Dave the pointer and four strings

00:12:57,770 --> 00:13:01,640
with a shorter lifetime for example

00:12:59,450 --> 00:13:04,220
local variables C string is a better way

00:13:01,640 --> 00:13:06,020
to do so in cruising now terminate a

00:13:04,220 --> 00:13:10,220
copy on the heap and then we can lick a

00:13:06,020 --> 00:13:12,650
pointer with Inter all but this but in

00:13:10,220 --> 00:13:16,010
the this approach may leak memory so if

00:13:12,650 --> 00:13:21,080
the leak string is not free later we

00:13:16,010 --> 00:13:24,620
will know later in in our talk in

00:13:21,080 --> 00:13:26,900
forgetting C pointers for us objects the

00:13:24,620 --> 00:13:29,030
similar rule applies a variable must

00:13:26,900 --> 00:13:32,000
outlive aspires otherwise you get a

00:13:29,030 --> 00:13:34,850
dangling pointer so in example here we

00:13:32,000 --> 00:13:38,210
are casting a reference as a row pointer

00:13:34,850 --> 00:13:40,250
and use the pointer as a return value so

00:13:38,210 --> 00:13:42,530
ban is bad

00:13:40,250 --> 00:13:43,940
so because the food does not out little

00:13:42,530 --> 00:13:45,920
pony or you got a full

00:13:43,940 --> 00:13:48,980
underscore PDR you've got a tangle

00:13:45,920 --> 00:13:52,520
planet here so what we do in measuring

00:13:48,980 --> 00:13:56,180
is we frequently use box into wrong to

00:13:52,520 --> 00:13:59,900
link a pointer transferred ownership

00:13:56,180 --> 00:14:03,770
from from Russ to see who is into wrong

00:13:59,900 --> 00:14:06,080
so then we so in C code we pass the

00:14:03,770 --> 00:14:11,200
pointer back to Russ and we reverse the

00:14:06,080 --> 00:14:13,570
role pointer and to our self again

00:14:11,200 --> 00:14:16,760
looking for is a very interesting case

00:14:13,570 --> 00:14:21,380
the calm is not visible here actually is

00:14:16,760 --> 00:14:22,930
it's the part of active and active slab

00:14:21,380 --> 00:14:27,839
you've ever heard of it

00:14:22,930 --> 00:14:31,630
issue 289 so some someone complains that

00:14:27,839 --> 00:14:36,279
a lot of bad patterns were use in a in

00:14:31,630 --> 00:14:39,220
active app focus focus on me like this

00:14:36,279 --> 00:14:43,360
so we declare foo which is can hit a

00:14:39,220 --> 00:14:46,420
string and we define immutable I mean

00:14:43,360 --> 00:14:50,620
horrible here phille here and we use

00:14:46,420 --> 00:14:53,110
this kind of trick unsafe you you cast

00:14:50,620 --> 00:14:55,810
the you cast a reference as a circles

00:14:53,110 --> 00:14:58,899
pointer and Costigan's as a star mute

00:14:55,810 --> 00:15:03,540
pointer and dereference it you get

00:14:58,899 --> 00:15:03,540
immutable reference and you can just

00:15:07,170 --> 00:15:22,240
don't do it yeah so there's cell and rev

00:15:13,600 --> 00:15:23,980
sale to help you to use this one memory

00:15:22,240 --> 00:15:27,640
allocation and de-allocation

00:15:23,980 --> 00:15:30,220
for tips 5 so that read if they if you

00:15:27,640 --> 00:15:32,370
handle them improperly in unsafe arras

00:15:30,220 --> 00:15:36,100
so they may cause a lot of problems

00:15:32,370 --> 00:15:38,230
memory leaks and dangling pointers so in

00:15:36,100 --> 00:15:40,630
say frost code the boat record usually

00:15:38,230 --> 00:15:41,230
identifies and prevents more than 99% of

00:15:40,630 --> 00:15:44,050
memory box

00:15:41,230 --> 00:15:45,880
but if unsafe ross code and row pointer

00:15:44,050 --> 00:15:49,930
is kicking so things start to get very

00:15:45,880 --> 00:15:53,080
complicated and a special culture so

00:15:49,930 --> 00:15:55,209
here was show an exhaustive list of

00:15:53,080 --> 00:16:03,250
things that needs your attention for

00:15:55,209 --> 00:16:05,680
example the for many micro RC and a RC

00:16:03,250 --> 00:16:09,520
are also on the peep and otoscope

00:16:05,680 --> 00:16:12,760
marbles are also implicitly allocated so

00:16:09,520 --> 00:16:14,920
the last one into raw needs some debate

00:16:12,760 --> 00:16:16,959
our discussion so we know that the box

00:16:14,920 --> 00:16:21,220
into raw can be used to leak a pointer

00:16:16,959 --> 00:16:25,329
so the question is can we call into raw

00:16:21,220 --> 00:16:27,640
in ross and free in NC so if Ross and C

00:16:25,329 --> 00:16:30,360
use different memory alligators like a

00:16:27,640 --> 00:16:32,670
few months ago before global

00:16:30,360 --> 00:16:35,220
a dog is stabilized so the answer is

00:16:32,670 --> 00:16:37,140
definitely no because your your systemic

00:16:35,220 --> 00:16:40,350
trader and Ross the tree melaka main

00:16:37,140 --> 00:16:42,779
they don't share information in general

00:16:40,350 --> 00:16:45,180
we also don't recommend doing so because

00:16:42,779 --> 00:16:47,670
we think the best way is to advocate in

00:16:45,180 --> 00:16:50,850
Ross and B I can rust and arrogancy and

00:16:47,670 --> 00:16:52,740
the Arcadian C so rough and C are two

00:16:50,850 --> 00:16:57,300
separate world only they communicate

00:16:52,740 --> 00:16:59,820
with the FFI interface and tip six is

00:16:57,300 --> 00:17:01,140
about panics in Fri code basically was

00:16:59,820 --> 00:17:02,700
the bad thing is that a panics may

00:17:01,140 --> 00:17:04,709
trigger take on winding and unwinding

00:17:02,700 --> 00:17:08,939
past the boundaries and different

00:17:04,709 --> 00:17:12,449
behavior so the suggestion in the

00:17:08,939 --> 00:17:14,400
documents is to use catch a wine to

00:17:12,449 --> 00:17:17,309
catch the steak and wine ahead of

00:17:14,400 --> 00:17:20,640
honorees enemies are linked we also used

00:17:17,309 --> 00:17:23,130
rustic air handling a pattern along with

00:17:20,640 --> 00:17:26,819
missing links internal air q to handle

00:17:23,130 --> 00:17:28,799
this kind of panics so despite that we

00:17:26,819 --> 00:17:30,990
can catch and stop second winding using

00:17:28,799 --> 00:17:33,240
catch unwind it doesn't mean that we can

00:17:30,990 --> 00:17:36,600
just let our rascal panic

00:17:33,240 --> 00:17:38,970
panics are kind of good for in terms of

00:17:36,600 --> 00:17:41,100
preventing undefined behaviors but

00:17:38,970 --> 00:17:44,280
paintings also have a negative impact on

00:17:41,100 --> 00:17:46,650
user exchanges so in missile inka we

00:17:44,280 --> 00:17:49,559
always prefer to write some robust panic

00:17:46,650 --> 00:17:51,120
free dress code so these are the scenes

00:17:49,559 --> 00:17:53,940
that may panic at runtime

00:17:51,120 --> 00:17:57,090
for example ref cell panics if the

00:17:53,940 --> 00:17:58,890
dynamic power checking fails panics if

00:17:57,090 --> 00:18:03,600
the sizes of the source and destination

00:17:58,890 --> 00:18:08,130
slices don't match the unreachable Metro

00:18:03,600 --> 00:18:09,690
also panics is enriched and then dynamic

00:18:08,130 --> 00:18:11,850
overflow checks also manning if it's

00:18:09,690 --> 00:18:14,100
turned on by default it is off its or

00:18:11,850 --> 00:18:17,580
tries to turn on or turn it on or off or

00:18:14,100 --> 00:18:19,410
not so also to vote for its dependencies

00:18:17,580 --> 00:18:21,210
and callback functions because you don't

00:18:19,410 --> 00:18:24,169
know if they are panic free or not so

00:18:21,210 --> 00:18:24,169
really be careful

00:18:24,290 --> 00:18:29,880
tip 7 is about converting fail

00:18:27,030 --> 00:18:35,419
descriptors so we are talking about a

00:18:29,880 --> 00:18:35,419
CNS current and the leap C Konkan file

00:18:35,590 --> 00:18:42,919
absolutely in rust you can use the from

00:18:40,460 --> 00:18:46,940
raw RFDS or a toggle here or from raw

00:18:42,919 --> 00:18:48,980
idly at least for eunuchs to convert a

00:18:46,940 --> 00:18:53,090
file descriptor into rust objects like

00:18:48,980 --> 00:18:55,460
file or TCP stream but promise that this

00:18:53,090 --> 00:18:59,480
function usually doesn't validate the

00:18:55,460 --> 00:19:01,070
file descriptors so we don't know if

00:18:59,480 --> 00:19:02,809
they'll file well 30 superior is good

00:19:01,070 --> 00:19:05,659
until a later operation return some

00:19:02,809 --> 00:19:08,389
errors maybe maybe sake cannot be

00:19:05,659 --> 00:19:10,279
connected so what we suggest here is

00:19:08,389 --> 00:19:13,190
we've annotated in the affair descriptor

00:19:10,279 --> 00:19:16,460
with sleep C's F cntl so we can know if

00:19:13,190 --> 00:19:19,220
the Faris Twitter really exists it is

00:19:16,460 --> 00:19:22,399
varied or not and for the leap

00:19:19,220 --> 00:19:25,580
cease-fire pointers because rust in rus

00:19:22,399 --> 00:19:29,000
STD do not have such times so we still

00:19:25,580 --> 00:19:31,669
have to use the unsafely PC using FD

00:19:29,000 --> 00:19:35,679
open and phone number we can convert a

00:19:31,669 --> 00:19:41,750
file pointer to integer for this hunter

00:19:35,679 --> 00:19:43,190
and tip 8 is about copying data from C

00:19:41,750 --> 00:19:48,080
into rust so basically we have three

00:19:43,190 --> 00:19:52,100
approves or to do so first it can we can

00:19:48,080 --> 00:19:54,679
use the lips as we did in C we use mem

00:19:52,100 --> 00:19:57,259
copy and move it works Andrew cross is

00:19:54,679 --> 00:20:00,200
not the rustic way to do it

00:19:57,259 --> 00:20:02,330
the second approach we use the PTR can

00:20:00,200 --> 00:20:04,669
come copy narrow lapping it also works

00:20:02,330 --> 00:20:08,600
it is certainly semantically equivalent

00:20:04,669 --> 00:20:10,279
to a mem copy in C but personally as you

00:20:08,600 --> 00:20:14,330
prefer the third one using a combination

00:20:10,279 --> 00:20:18,470
of PTR can come from Roper's plus slice

00:20:14,330 --> 00:20:21,230
kanakam copy from size the reason is so

00:20:18,470 --> 00:20:23,330
using from reports you can get a slice

00:20:21,230 --> 00:20:25,159
and you got a chance to validate the

00:20:23,330 --> 00:20:27,710
buffer before you do some further

00:20:25,159 --> 00:20:30,830
actions on it for example if you are

00:20:27,710 --> 00:20:34,279
referencing a pointer which is a C

00:20:30,830 --> 00:20:37,250
string so by from using from reports you

00:20:34,279 --> 00:20:38,809
got you a slice you can check if the the

00:20:37,250 --> 00:20:42,769
buffer is terminated with the null

00:20:38,809 --> 00:20:44,980
character at the end and using copy from

00:20:42,769 --> 00:20:46,679
slice you get a free

00:20:44,980 --> 00:20:49,360
you get a free boundary checking because

00:20:46,679 --> 00:20:50,860
copy forms the lives of you check the

00:20:49,360 --> 00:20:53,169
lens of the source and destination

00:20:50,860 --> 00:20:57,190
slices if they match your didn't match

00:20:53,169 --> 00:20:59,710
either panic so are all using the third

00:20:57,190 --> 00:21:04,450
approach we can mock intro and also free

00:20:59,710 --> 00:21:07,059
secrete checks this is the one is the

00:21:04,450 --> 00:21:12,760
most interesting one about converting

00:21:07,059 --> 00:21:15,640
see in arms to Russ announced see and

00:21:12,760 --> 00:21:17,890
Russ see seen arms are nothing like rose

00:21:15,640 --> 00:21:20,679
in arms this fight Russ approach this

00:21:17,890 --> 00:21:24,520
Tao in amps so Russ in arms are

00:21:20,679 --> 00:21:27,640
essentially a range of integers where

00:21:24,520 --> 00:21:29,140
you can now define duplicate values but

00:21:27,640 --> 00:21:31,240
in C because they are just simply

00:21:29,140 --> 00:21:33,280
integers you can do so very easily for

00:21:31,240 --> 00:21:36,010
example you can see I have a lab or

00:21:33,280 --> 00:21:38,640
default equal to two also level high is

00:21:36,010 --> 00:21:43,090
2 but in Russ you just cannot do it

00:21:38,640 --> 00:21:44,790
because because in Russ Russ in amps are

00:21:43,090 --> 00:21:47,860
a range of numbers

00:21:44,790 --> 00:21:51,280
noting values around so the workaround

00:21:47,860 --> 00:21:55,179
to this problem is to use difference in

00:21:51,280 --> 00:21:57,850
header files this header file so we use

00:21:55,179 --> 00:22:00,549
the preprocessor Marco to define level

00:21:57,850 --> 00:22:05,169
default to live a high so we can kind of

00:22:00,549 --> 00:22:08,710
bypass this problem a missile Inc this

00:22:05,169 --> 00:22:10,390
one because as I said see in arms are

00:22:08,710 --> 00:22:13,500
just integers so if you are trying to

00:22:10,390 --> 00:22:16,809
convert a signal through a rusty knob

00:22:13,500 --> 00:22:22,150
don't use to Neos transmitted because if

00:22:16,809 --> 00:22:24,790
you don't if you transmit a integer to a

00:22:22,150 --> 00:22:27,520
rusty now you may encounter some kind of

00:22:24,790 --> 00:22:32,049
undefined behavior so if the value is

00:22:27,520 --> 00:22:34,900
not in the range of the racino so what

00:22:32,049 --> 00:22:38,710
we do in missile Inc is we use the from

00:22:34,900 --> 00:22:41,620
in to treat to check if the value is in

00:22:38,710 --> 00:22:46,000
the range so it is not oh it is level

00:22:41,620 --> 00:22:48,220
and defined here so always validate a

00:22:46,000 --> 00:22:51,700
see now before you convert it into a

00:22:48,220 --> 00:22:55,630
Rossy now and this one is pretty

00:22:51,700 --> 00:22:58,210
interesting I will share with you so mr.

00:22:55,630 --> 00:23:01,990
Lincoln mr. linghu we sometimes need to

00:22:58,210 --> 00:23:04,900
starter pointers for some for some names

00:23:01,990 --> 00:23:07,870
for some named names on of some in a

00:23:04,900 --> 00:23:10,270
morons in Rus we can do it easily with

00:23:07,870 --> 00:23:12,520
the gravity back and we can use

00:23:10,270 --> 00:23:14,800
something like this format a column

00:23:12,520 --> 00:23:17,610
question mark to get a name of the

00:23:14,800 --> 00:23:19,900
variant for example congressional Davos

00:23:17,610 --> 00:23:23,710
like level high and I below and never

00:23:19,900 --> 00:23:26,830
level before something like that but in

00:23:23,710 --> 00:23:29,980
but not to leak a pointer of it is very

00:23:26,830 --> 00:23:30,640
hard to do so so we actually struggled

00:23:29,980 --> 00:23:32,950
quite a lot

00:23:30,640 --> 00:23:35,710
we have several attempts so the first

00:23:32,950 --> 00:23:37,600
time that we just used the formatter it

00:23:35,710 --> 00:23:39,840
Erick's the string on heap and we turn

00:23:37,600 --> 00:23:42,550
pointer and we cast it as a row pointer

00:23:39,840 --> 00:23:45,520
but as I have said in tip two and five

00:23:42,550 --> 00:23:48,040
is not right because the the archive

00:23:45,520 --> 00:23:50,740
string does not outlive the pointer so

00:23:48,040 --> 00:23:53,530
basically Katanga pointer gear so in our

00:23:50,740 --> 00:23:55,510
second attempt we learn something from

00:23:53,530 --> 00:24:00,160
our mistakes so we start with you see

00:23:55,510 --> 00:24:01,540
string so the string is probably

00:24:00,160 --> 00:24:03,610
terminated with a null character or at

00:24:01,540 --> 00:24:07,240
the end and we enter app and we

00:24:03,610 --> 00:24:11,200
intervallic a pointer big burner so now

00:24:07,240 --> 00:24:13,210
the pointer has a longer lifetime but I

00:24:11,200 --> 00:24:15,910
would say it works but it Eric's memory

00:24:13,210 --> 00:24:18,850
on the heap so it may lead to some

00:24:15,910 --> 00:24:23,920
memory memory leaks so please see our

00:24:18,850 --> 00:24:25,900
tip 5 & 6 for we find it's very hard to

00:24:23,920 --> 00:24:28,510
do so and finally we came up with our

00:24:25,900 --> 00:24:31,480
own crate with procedural macros and

00:24:28,510 --> 00:24:38,500
custom derived so find our create on

00:24:31,480 --> 00:24:40,270
Chris Nile and it's pretty easy and here

00:24:38,500 --> 00:24:42,760
are some external tools we find pretty

00:24:40,270 --> 00:24:44,830
useful when we write a truss I've our

00:24:42,760 --> 00:24:46,960
rows FFI code please give it a try and

00:24:44,830 --> 00:24:48,790
see if they fit our needs so for example

00:24:46,960 --> 00:24:51,220
I always use whatwind to find memory

00:24:48,790 --> 00:24:54,220
leaks caused by improper use of box into

00:24:51,220 --> 00:24:55,990
raw and cargo clip is lin's often give

00:24:54,220 --> 00:24:58,810
me surprises about writing idiomatic

00:24:55,990 --> 00:25:02,500
russ code and also it helps me avoid

00:24:58,810 --> 00:25:05,410
some unnecessary unsafe code and some

00:25:02,500 --> 00:25:06,100
acknowledgement on the materials i found

00:25:05,410 --> 00:25:08,770
pretty helpful

00:25:06,100 --> 00:25:10,070
so the Rustom on our roster nomicon is

00:25:08,770 --> 00:25:12,920
definitely must read

00:25:10,070 --> 00:25:15,200
and micro bronze alpha trole fi book

00:25:12,920 --> 00:25:17,960
press me a useful insights into error

00:25:15,200 --> 00:25:20,300
handling in Ross and Z and also some

00:25:17,960 --> 00:25:23,600
tips about integrating cargo into the

00:25:20,300 --> 00:25:25,280
sea maker build system and my things

00:25:23,600 --> 00:25:27,500
also go to the previous talk on R as

00:25:25,280 --> 00:25:31,340
fast and Russ conf so many acts and

00:25:27,500 --> 00:25:35,480
talks on this topic so a quick recap so

00:25:31,340 --> 00:25:37,880
tip points about checking on pointers we

00:25:35,480 --> 00:25:39,440
use some magic buys as toilet and fire

00:25:37,880 --> 00:25:42,530
to do so

00:25:39,440 --> 00:25:44,510
tip 2 is about converting converting

00:25:42,530 --> 00:25:46,910
between commercial between C and Ross

00:25:44,510 --> 00:25:49,130
types so we mentioned about strings and

00:25:46,910 --> 00:25:51,650
tip stories about cutting a see pointers

00:25:49,130 --> 00:25:55,100
fall from Ross objects like strings or

00:25:51,650 --> 00:25:57,770
some anything like anything and he for

00:25:55,100 --> 00:25:59,000
portable pointers not for bypassing the

00:25:57,770 --> 00:26:01,940
protractor I showed you a counter

00:25:59,000 --> 00:26:03,110
example so do not do that and he first

00:26:01,940 --> 00:26:04,850
bought memory allocation and

00:26:03,110 --> 00:26:09,320
de-allocation something bad can happen

00:26:04,850 --> 00:26:13,130
if you are not aware of it and also fi

00:26:09,320 --> 00:26:14,450
code virtual panics because unwinding

00:26:13,130 --> 00:26:17,180
past the boundary is the undefined

00:26:14,450 --> 00:26:20,000
behavior and tip 7 is about converting

00:26:17,180 --> 00:26:23,030
file descriptors like integers or lipsi

00:26:20,000 --> 00:26:25,310
con-com firefighters tip 8 is about

00:26:23,030 --> 00:26:27,590
copying data from C into Ron's I showed

00:26:25,310 --> 00:26:30,470
you three master to do the two so and a

00:26:27,590 --> 00:26:32,330
person I prefer to serve on and now is

00:26:30,470 --> 00:26:35,980
about converting C nouns into rust and

00:26:32,330 --> 00:26:35,980
file wines by external tools

00:26:36,250 --> 00:26:41,370
this is it young since well since all

00:26:38,710 --> 00:26:41,370
coming to my top

00:26:43,240 --> 00:26:53,940
[Applause]

00:27:03,309 --> 00:27:09,930
oh yeah

00:27:07,330 --> 00:27:09,930
okay

00:27:17,249 --> 00:27:20,369
okay house

00:27:32,140 --> 00:27:35,140
nope

00:27:42,290 --> 00:27:58,020
okay okay sorry for that do we have any

00:27:47,220 --> 00:28:02,160
questions right there we'll have any

00:27:58,020 --> 00:28:07,280
tips for handling see libraries that

00:28:02,160 --> 00:28:12,380
internal use static mutable state

00:28:07,280 --> 00:28:15,720
whether do have any ideas about how to

00:28:12,380 --> 00:28:19,010
create FSI bindings to libraries that

00:28:15,720 --> 00:28:23,190
internally have static mutable state

00:28:19,010 --> 00:28:25,980
because I actually have such use case

00:28:23,190 --> 00:28:29,700
that I use library that has static

00:28:25,980 --> 00:28:32,310
mutable state and know that it's tough

00:28:29,700 --> 00:28:37,080
to do in rust so whether you have any

00:28:32,310 --> 00:28:39,930
advice on this I don't know if such

00:28:37,080 --> 00:28:43,140
crews exist I know some good ones like

00:28:39,930 --> 00:28:45,150
is the FFI and and also like C pungent

00:28:43,140 --> 00:28:49,620
price a good example of automatic doing

00:28:45,150 --> 00:28:57,630
so I don't yet but I we are still in on

00:28:49,620 --> 00:29:01,010
instruction thank you other questions

00:28:57,630 --> 00:29:01,010
there were there's a hand over there

00:29:05,630 --> 00:29:12,920
thank you for the talk I'm interested to

00:29:09,390 --> 00:29:16,100
know your ideas on how you handle errors

00:29:12,920 --> 00:29:19,530
across the FFI for example when you

00:29:16,100 --> 00:29:22,130
dealing with the seco that is using like

00:29:19,530 --> 00:29:25,410
status code and how you convert about to

00:29:22,130 --> 00:29:27,120
like proper rust errors and also if

00:29:25,410 --> 00:29:30,570
you're doing the other way around if you

00:29:27,120 --> 00:29:34,830
have something that's calling rust via

00:29:30,570 --> 00:29:37,770
FFI how would you handle our ross the

00:29:34,830 --> 00:29:41,940
side we have investing we have several

00:29:37,770 --> 00:29:44,700
macros to help you turn rust result to

00:29:41,940 --> 00:29:46,740
some like sierra code because Owens's

00:29:44,700 --> 00:29:49,620
they all use error codes visitor

00:29:46,740 --> 00:29:52,080
integers but arras has is results and

00:29:49,620 --> 00:29:54,600
also some errors and failures this kind

00:29:52,080 --> 00:29:55,350
of error handling creates so basically

00:29:54,600 --> 00:29:59,309
at a boundary

00:29:55,350 --> 00:30:00,929
we convert them between from rust to see

00:29:59,309 --> 00:30:03,860
as I said I have a matter of doing so

00:30:00,929 --> 00:30:06,270
and from Caesar rust we define a few

00:30:03,860 --> 00:30:09,390
from and in two traits implementations

00:30:06,270 --> 00:30:14,299
to convert the sea-air numbers to some

00:30:09,390 --> 00:30:14,299
rust errors so been used to thank you

00:30:17,090 --> 00:30:20,660
other question

00:30:24,310 --> 00:30:30,720
okay okay okay we're done yeah thank you

00:30:29,110 --> 00:30:34,339
thank you thank you

00:30:30,720 --> 00:30:34,339

YouTube URL: https://www.youtube.com/watch?v=kGj-Fxg5txQ


