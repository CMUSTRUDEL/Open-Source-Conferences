Title: RustFest Rome 2018 -  Adam Kelly: Rust, For Science!
Publication date: 2018-11-24
Playlist: RustFest Rome 2018
Description: 
	Rust seems like a perfect candidate for scientific computing, building fast and efficient algorithms for scientific research and data science, but why isn't it there yet? Explore the state of scientific computing in Rust, from where it shines to it falls down, to where we can improve as a community, and learn about Rust in an area that has so much potential.

https://rome.rustfest.eu/sessions/rust-for-science
https://media.ccc.de/v/rustfest-rome-4-rust-for-science
Captions: 
	00:00:04,850 --> 00:00:10,379
I'm going to be talking about using rust

00:00:07,350 --> 00:00:11,910
for scientific programming so I'm gonna

00:00:10,379 --> 00:00:13,410
be talking about what makes rust a good

00:00:11,910 --> 00:00:15,750
language to use for scientific computing

00:00:13,410 --> 00:00:17,700
some interesting stuff we can do in rust

00:00:15,750 --> 00:00:20,430
and finally some sort of areas we can

00:00:17,700 --> 00:00:21,750
improve on so my name is Adam if you

00:00:20,430 --> 00:00:24,689
want to follow me on Twitter or github

00:00:21,750 --> 00:00:26,309
my names up there so I want to start out

00:00:24,689 --> 00:00:29,160
with what scientific computing actually

00:00:26,309 --> 00:00:31,200
is so when we talk about scientific

00:00:29,160 --> 00:00:33,210
computing we're referring to the tools

00:00:31,200 --> 00:00:35,340
and techniques and algorithms that are

00:00:33,210 --> 00:00:37,109
needed to solve the problems that you

00:00:35,340 --> 00:00:38,969
come across and maths and engineering

00:00:37,109 --> 00:00:40,649
and in science and you could sort of

00:00:38,969 --> 00:00:42,149
break this up into a few parts so it's

00:00:40,649 --> 00:00:44,429
going to be things like numerical

00:00:42,149 --> 00:00:55,379
analysis and simulation so that's gonna

00:00:44,429 --> 00:01:04,500
be sorry so in American analysis the

00:00:55,379 --> 00:01:06,750
simulation things like okay so things

00:01:04,500 --> 00:01:08,400
like simulating physical systems doing

00:01:06,750 --> 00:01:10,740
sort of high performance computing on

00:01:08,400 --> 00:01:12,720
supercomputers clusters multi-threaded

00:01:10,740 --> 00:01:13,680
programming and then data science so

00:01:12,720 --> 00:01:16,140
that's like you know statistical

00:01:13,680 --> 00:01:17,820
analysis machine learning so I'm really

00:01:16,140 --> 00:01:20,010
going to be more talking about the first

00:01:17,820 --> 00:01:22,620
two because data analysis is completely

00:01:20,010 --> 00:01:24,420
different sort of thing so if you look

00:01:22,620 --> 00:01:26,700
at how scientific software usually gets

00:01:24,420 --> 00:01:29,190
developed it usually follows this sort

00:01:26,700 --> 00:01:31,350
of process so they usually starts out

00:01:29,190 --> 00:01:33,450
with an implementation need or an idea

00:01:31,350 --> 00:01:35,190
so that could be you have a new idea for

00:01:33,450 --> 00:01:36,690
an algorithm you need to just run a

00:01:35,190 --> 00:01:39,150
calculation or you have to re-implement

00:01:36,690 --> 00:01:41,130
something from a paper and it usually

00:01:39,150 --> 00:01:42,900
goes from there you might then go to a

00:01:41,130 --> 00:01:44,580
higher-level language like Python and

00:01:42,900 --> 00:01:48,030
then you'll probably implement something

00:01:44,580 --> 00:01:51,600
there so Python is usually chosen first

00:01:48,030 --> 00:01:53,130
or MATLAB or any other any of those sort

00:01:51,600 --> 00:01:54,990
of language is chosen first because

00:01:53,130 --> 00:01:57,390
first of all because it's easy it's very

00:01:54,990 --> 00:01:59,490
easy to get started most of the people

00:01:57,390 --> 00:02:02,160
that do this sort of programming aren't

00:01:59,490 --> 00:02:03,810
computer scientists they're physics

00:02:02,160 --> 00:02:06,300
students math students people are just

00:02:03,810 --> 00:02:08,099
interested and you probably wouldn't

00:02:06,300 --> 00:02:10,050
have that big much of a programming

00:02:08,099 --> 00:02:12,719
background and higher-level languages

00:02:10,050 --> 00:02:15,060
make it quite easy to get started so you

00:02:12,719 --> 00:02:17,610
might write your prototype and then you

00:02:15,060 --> 00:02:19,440
go you see oh I can improve my

00:02:17,610 --> 00:02:20,910
a little bit and you go back you write a

00:02:19,440 --> 00:02:22,890
little bit more and then you might

00:02:20,910 --> 00:02:24,810
realize that oh there's this really big

00:02:22,890 --> 00:02:26,610
part that's bottlenecking all my code I

00:02:24,810 --> 00:02:28,620
need to then go and rewrite that in a

00:02:26,610 --> 00:02:30,660
lower level language and that usually

00:02:28,620 --> 00:02:33,150
boils down to rewriting it and C and C++

00:02:30,660 --> 00:02:34,680
and it's usually for like two reasons

00:02:33,150 --> 00:02:37,020
it's usually one because of just

00:02:34,680 --> 00:02:39,420
tradition because well science doesn't

00:02:37,020 --> 00:02:42,300
move quite as quickly as programming

00:02:39,420 --> 00:02:44,310
doors and well C++ is used a lot already

00:02:42,300 --> 00:02:46,770
and so you might just use that already

00:02:44,310 --> 00:02:49,410
and there's also tools for ecosystems

00:02:46,770 --> 00:02:51,360
libraries there already so it usually

00:02:49,410 --> 00:02:53,100
goes into writing that sort of thing and

00:02:51,360 --> 00:02:54,900
then after that it could be benchmarking

00:02:53,100 --> 00:02:57,360
publishing a paper just publishing the

00:02:54,900 --> 00:02:59,280
software whatever but it's mainly that

00:02:57,360 --> 00:03:01,709
stuff there the rewriting step is where

00:02:59,280 --> 00:03:06,420
rust would come in so let's see if I can

00:03:01,709 --> 00:03:09,030
change this so there is a few problems

00:03:06,420 --> 00:03:11,280
with just going and rewriting a big

00:03:09,030 --> 00:03:12,150
section of your code in C++ especially

00:03:11,280 --> 00:03:22,019
if you don't have that much experience

00:03:12,150 --> 00:03:24,720
oh there you go so first of all it's

00:03:22,019 --> 00:03:26,910
harder to debug this sort of code so if

00:03:24,720 --> 00:03:28,860
you don't have a lot of experience it's

00:03:26,910 --> 00:03:31,170
very easy to do a sort of guess and

00:03:28,860 --> 00:03:32,430
check approach to programming so you

00:03:31,170 --> 00:03:34,080
write a little bit and then you might

00:03:32,430 --> 00:03:35,880
you know open up a raffle see if it

00:03:34,080 --> 00:03:37,739
works and you might create a new file

00:03:35,880 --> 00:03:38,940
just try and run it so it's not the sort

00:03:37,739 --> 00:03:41,670
of things that you might normally do

00:03:38,940 --> 00:03:43,410
where you might write tests or any of

00:03:41,670 --> 00:03:44,790
that sort of thing and that's a lot

00:03:43,410 --> 00:03:47,040
harder to do when you use a language

00:03:44,790 --> 00:03:48,840
like C or suddenly you have to compile

00:03:47,040 --> 00:03:51,120
because it's not as quick you can't just

00:03:48,840 --> 00:03:53,580
iterate as fast and it's also going to

00:03:51,120 --> 00:03:55,530
be harder to learn so if you pick up a

00:03:53,580 --> 00:03:57,180
language like Python it's very easy to

00:03:55,530 --> 00:03:58,739
just you know go TextEdit here and put

00:03:57,180 --> 00:04:00,540
in stuff you don't really need that much

00:03:58,739 --> 00:04:02,489
background knowledge whereas if you're

00:04:00,540 --> 00:04:03,690
writing in a lower-level language you

00:04:02,489 --> 00:04:05,970
have to know a little bit more about

00:04:03,690 --> 00:04:09,030
well memory and how things actually work

00:04:05,970 --> 00:04:10,230
and referencing things and you've got to

00:04:09,030 --> 00:04:12,420
sort of have a fairly good idea

00:04:10,230 --> 00:04:15,209
especially if you're trying to well get

00:04:12,420 --> 00:04:17,040
well performing code and that ties into

00:04:15,209 --> 00:04:19,919
the next bit which is it's very easy to

00:04:17,040 --> 00:04:21,359
write bad code so it's very easy to

00:04:19,919 --> 00:04:23,250
write code that's not going to be memory

00:04:21,359 --> 00:04:24,780
safe it's gonna have all sorts of issues

00:04:23,250 --> 00:04:27,000
that you wouldn't come across in

00:04:24,780 --> 00:04:28,919
languages like MATLAB which is like race

00:04:27,000 --> 00:04:30,060
conditions like you might not know that

00:04:28,919 --> 00:04:31,139
this sort of thing could even be an

00:04:30,060 --> 00:04:33,389
issue

00:04:31,139 --> 00:04:35,009
it's very easy to do that so it's this

00:04:33,389 --> 00:04:39,090
sort of place where rust can actually

00:04:35,009 --> 00:04:42,210
help out so let's see so for example if

00:04:39,090 --> 00:04:44,279
we want to do something like testing so

00:04:42,210 --> 00:04:46,919
here is a function it just does a

00:04:44,279 --> 00:04:48,330
factorial so if I was writing this in

00:04:46,919 --> 00:04:50,310
Python and I just wanted to see if it

00:04:48,330 --> 00:04:51,990
work I'd probably just go I'd open up

00:04:50,310 --> 00:04:53,550
the Python interpreter and I just type

00:04:51,990 --> 00:04:56,129
in a few things and see if it matches up

00:04:53,550 --> 00:04:57,719
where is it's not usually that easy to

00:04:56,129 --> 00:04:59,639
do especially if you have to keep trying

00:04:57,719 --> 00:05:01,949
to do that whereas a language like Ross

00:04:59,639 --> 00:05:04,080
you can just well add a test because

00:05:01,949 --> 00:05:05,400
it's built into the language so it's

00:05:04,080 --> 00:05:08,069
those sort of things that become really

00:05:05,400 --> 00:05:10,110
really easy and also for the writing

00:05:08,069 --> 00:05:12,419
better code Russ does a lot of sort of

00:05:10,110 --> 00:05:14,669
what guarantees but also a lot of

00:05:12,419 --> 00:05:16,650
features that make it a lazier so here's

00:05:14,669 --> 00:05:19,080
a piece of code but this might not be

00:05:16,650 --> 00:05:21,270
the best way to write this out so tools

00:05:19,080 --> 00:05:23,729
like Clippy and the linters will sort of

00:05:21,270 --> 00:05:24,870
say oh well you can actually see where

00:05:23,729 --> 00:05:27,000
you're trying to iterate through that

00:05:24,870 --> 00:05:28,770
well that's actually an iterable so you

00:05:27,000 --> 00:05:30,300
can go and you can rewrite this a little

00:05:28,770 --> 00:05:33,330
bit differently and that will improve

00:05:30,300 --> 00:05:35,159
your code in the long run so it's

00:05:33,330 --> 00:05:36,990
there's loads of features and Russell I

00:05:35,159 --> 00:05:38,550
could help this well things like the

00:05:36,990 --> 00:05:39,900
memory and thread safety so that's not

00:05:38,550 --> 00:05:41,639
something you have to learn or think

00:05:39,900 --> 00:05:44,339
about things like the built-in

00:05:41,639 --> 00:05:46,349
benchmarking built-in documentation

00:05:44,339 --> 00:05:48,419
built-in dependencies all things that

00:05:46,349 --> 00:05:50,460
are hard enough to get set up in

00:05:48,419 --> 00:05:51,839
languages like C and C++ especially if

00:05:50,460 --> 00:05:53,879
you don't have that much experience and

00:05:51,839 --> 00:05:55,469
then things like well there's a lot of

00:05:53,879 --> 00:05:58,229
good libraries and roasts there's

00:05:55,469 --> 00:05:59,520
integration like great FFI support and

00:05:58,229 --> 00:06:01,889
then also other features like web

00:05:59,520 --> 00:06:04,229
assembly so gonna look a little bit more

00:06:01,889 --> 00:06:07,949
specifically so let's look at

00:06:04,229 --> 00:06:10,439
multi-threading so if I want to do some

00:06:07,949 --> 00:06:12,870
sort of algorithm here is of numerical

00:06:10,439 --> 00:06:15,210
integration or a very simplified version

00:06:12,870 --> 00:06:16,889
but basically we're just sort of trying

00:06:15,210 --> 00:06:19,259
to calculate the area under a function

00:06:16,889 --> 00:06:21,149
but it mainly comes down to a loop there

00:06:19,259 --> 00:06:23,099
we're just summing things up so this is

00:06:21,149 --> 00:06:24,449
exactly the type of thing that you might

00:06:23,099 --> 00:06:27,569
come across and you might want to

00:06:24,449 --> 00:06:29,279
parallel eyes and tools and rust can

00:06:27,569 --> 00:06:31,830
make that really easy for example we can

00:06:29,279 --> 00:06:33,899
just take the Ray on crash we put it in

00:06:31,830 --> 00:06:35,310
our cargo tunnel and then we just import

00:06:33,899 --> 00:06:37,529
it and we don't have to think about well

00:06:35,310 --> 00:06:39,509
trying to find the libraries and trying

00:06:37,529 --> 00:06:41,639
to add compiler flags and fixing or make

00:06:39,509 --> 00:06:43,229
files or you can just go and you can

00:06:41,639 --> 00:06:45,160
just rewrite your function and it works

00:06:43,229 --> 00:06:47,440
pretty well it's pretty readable

00:06:45,160 --> 00:06:51,160
you don't have that much extra

00:06:47,440 --> 00:06:53,190
complexity that comes with it and then

00:06:51,160 --> 00:06:55,060
there's also other stuff like we can

00:06:53,190 --> 00:06:56,800
that was obviously like built-in

00:06:55,060 --> 00:06:58,990
threading libraries we can integrate

00:06:56,800 --> 00:07:01,150
with other C libraries such as open CL

00:06:58,990 --> 00:07:04,120
we can do things like integrating array

00:07:01,150 --> 00:07:05,830
fire or like linear algebra systems and

00:07:04,120 --> 00:07:09,610
then sort of row specific stuff like

00:07:05,830 --> 00:07:12,760
cross P so another thing is as I said

00:07:09,610 --> 00:07:14,590
integration with other tools so in the

00:07:12,760 --> 00:07:17,440
scientific community there's are a lot

00:07:14,590 --> 00:07:19,210
of very well implemented pre-existing

00:07:17,440 --> 00:07:21,100
tools and there's no real point in

00:07:19,210 --> 00:07:22,750
rewriting things from the ground up when

00:07:21,100 --> 00:07:25,360
they've already been well optimized

00:07:22,750 --> 00:07:27,700
really really heavily so for example

00:07:25,360 --> 00:07:30,340
let's say I want to run some code in

00:07:27,700 --> 00:07:32,800
parallel on a supercomputer or a cluster

00:07:30,340 --> 00:07:34,930
or a group of machines the usual way you

00:07:32,800 --> 00:07:37,540
do that is with MPI message passing

00:07:34,930 --> 00:07:40,240
interface and this is basically just a C

00:07:37,540 --> 00:07:43,420
specification for pretty much a library

00:07:40,240 --> 00:07:44,590
well every computer that runs this would

00:07:43,420 --> 00:07:46,300
probably have a different version and

00:07:44,590 --> 00:07:47,920
they're pretty heavily optimized for the

00:07:46,300 --> 00:07:49,690
hardware so it's not gonna be something

00:07:47,920 --> 00:07:51,670
you want to rewrite but it is something

00:07:49,690 --> 00:07:54,220
you can still used through rust so

00:07:51,670 --> 00:07:56,890
here's what I'd have to write in C so

00:07:54,220 --> 00:07:59,590
it's just taken straight out of an

00:07:56,890 --> 00:08:02,860
example but I can go in rust I can just

00:07:59,590 --> 00:08:03,940
import a library and then I can well run

00:08:02,860 --> 00:08:07,360
it write it and rust and it runs

00:08:03,940 --> 00:08:09,040
perfectly well and it's the same for a

00:08:07,360 --> 00:08:10,510
lot of other C libraries there's a lot

00:08:09,040 --> 00:08:12,910
of binding crates that are already there

00:08:10,510 --> 00:08:15,370
it's really easy to create new ones with

00:08:12,910 --> 00:08:17,710
tools like well bind gen and there's

00:08:15,370 --> 00:08:20,520
also things like web assembly which are

00:08:17,710 --> 00:08:22,570
allow us to do stuff on the web so

00:08:20,520 --> 00:08:23,860
there's a lot of other interesting

00:08:22,570 --> 00:08:27,280
features as well I mentioned web

00:08:23,860 --> 00:08:29,980
assembly so let's say I have a piece of

00:08:27,280 --> 00:08:33,690
code so I'm gonna run something here

00:08:29,980 --> 00:08:33,690
this is a

00:08:36,780 --> 00:08:44,650
you know anyway so it's a it's a

00:08:42,640 --> 00:08:46,210
simulation of a double pendulum you

00:08:44,650 --> 00:08:47,440
might have seen it but you can sort of

00:08:46,210 --> 00:08:49,270
break it up into two parts

00:08:47,440 --> 00:08:51,100
there was the simulation part which is

00:08:49,270 --> 00:08:52,570
written in rust and then there's also

00:08:51,100 --> 00:08:54,640
supposed to be a graphics part but I

00:08:52,570 --> 00:08:57,370
clearly made a mistake somewhere but

00:08:54,640 --> 00:09:00,130
they're separate so I don't have that

00:08:57,370 --> 00:09:01,990
it's not that closely coupled so it

00:09:00,130 --> 00:09:04,300
means I can go I can just take that rust

00:09:01,990 --> 00:09:06,370
code and I can take it there I can

00:09:04,300 --> 00:09:08,890
compile it to web assembly and then I

00:09:06,370 --> 00:09:11,620
can well run it in the web with the

00:09:08,890 --> 00:09:13,060
browser and then we can get skip

00:09:11,620 --> 00:09:15,160
something we can get something that we

00:09:13,060 --> 00:09:18,580
can actually run so hopefully this will

00:09:15,160 --> 00:09:20,110
actually work there so that's what it's

00:09:18,580 --> 00:09:21,700
supposed to look like I'm not in the

00:09:20,110 --> 00:09:23,770
browser so it's the same code that I

00:09:21,700 --> 00:09:25,420
could run on my computer really quickly

00:09:23,770 --> 00:09:26,950
and I can run in the browser as well and

00:09:25,420 --> 00:09:28,570
that has a lot of applications

00:09:26,950 --> 00:09:30,040
especially in places where you might

00:09:28,570 --> 00:09:31,990
want to share your code you might want

00:09:30,040 --> 00:09:37,570
to share a simulation and you still

00:09:31,990 --> 00:09:39,400
don't lose that much speed so if you've

00:09:37,570 --> 00:09:40,990
ever done any sort of scientific

00:09:39,400 --> 00:09:43,810
programming you've probably seen Jupiter

00:09:40,990 --> 00:09:46,570
notebooks it's a way where you can in

00:09:43,810 --> 00:09:48,310
your browser connect to well the

00:09:46,570 --> 00:09:50,320
terminal in your computer and you can

00:09:48,310 --> 00:09:52,000
run code and you can see the output and

00:09:50,320 --> 00:09:54,250
it's something that's very very useful

00:09:52,000 --> 00:09:56,080
for doing a lot of programming in this

00:09:54,250 --> 00:09:57,970
sort of environment so there's been a

00:09:56,080 --> 00:10:00,100
lot of efforts and Rost I think I've

00:09:57,970 --> 00:10:02,230
seen at least three crates but a lot of

00:10:00,100 --> 00:10:05,100
them get some discontinued like oh well

00:10:02,230 --> 00:10:07,390
there was this certain change in rust

00:10:05,100 --> 00:10:09,580
1.16 and now we can't use it unless

00:10:07,390 --> 00:10:12,070
you're on the nightly compiler from that

00:10:09,580 --> 00:10:14,020
exact day or they just don't get

00:10:12,070 --> 00:10:15,910
maintained but there is a project that

00:10:14,020 --> 00:10:21,970
came out not that long ago under the

00:10:15,910 --> 00:10:24,970
Google Organization and it's e e CX or

00:10:21,970 --> 00:10:27,700
and it allows us that we can do jupiter

00:10:24,970 --> 00:10:29,620
notebooks using rust so for example here

00:10:27,700 --> 00:10:32,170
it is of doing Fibonacci numbers

00:10:29,620 --> 00:10:33,760
computing them and well it doesn't work

00:10:32,170 --> 00:10:35,740
perfectly like it doesn't run on Mac it

00:10:33,760 --> 00:10:37,600
doesn't run on Windows you can't kill it

00:10:35,740 --> 00:10:38,800
halfway through or it won't run but it's

00:10:37,600 --> 00:10:40,570
the type of thing that is being

00:10:38,800 --> 00:10:44,320
developed in rust that you will be able

00:10:40,570 --> 00:10:46,240
to use hopefully at some point so and

00:10:44,320 --> 00:10:47,950
that gives other things like a raffle

00:10:46,240 --> 00:10:48,450
which means you can do those sort of

00:10:47,950 --> 00:10:50,820
quicker

00:10:48,450 --> 00:10:52,740
valuations of a few things were and also

00:10:50,820 --> 00:10:56,520
well stuff you can bring it to your own

00:10:52,740 --> 00:10:57,990
code so Ross seems like a really pretty

00:10:56,520 --> 00:11:01,140
good option for doing this sort of

00:10:57,990 --> 00:11:03,990
programming but it has a lot of issues

00:11:01,140 --> 00:11:05,640
as well the main reason why you wouldn't

00:11:03,990 --> 00:11:08,790
pick Ross to do this sort of thing would

00:11:05,640 --> 00:11:10,230
probably be the ecosystem it's something

00:11:08,790 --> 00:11:11,430
that you probably look at very closely

00:11:10,230 --> 00:11:12,690
when you're trying to choose your

00:11:11,430 --> 00:11:14,130
language and you probably just want to

00:11:12,690 --> 00:11:17,310
use the tools that are available already

00:11:14,130 --> 00:11:19,620
and well it is nice that we have a lot

00:11:17,310 --> 00:11:21,300
of binding sprites and stuff if a lot of

00:11:19,620 --> 00:11:23,340
the time it's just more convenient to

00:11:21,300 --> 00:11:25,380
take someone else's code they wrote and

00:11:23,340 --> 00:11:26,610
see and then just you know put in your

00:11:25,380 --> 00:11:28,050
other bits and then you don't actually

00:11:26,610 --> 00:11:29,070
even have to write it from scratch and

00:11:28,050 --> 00:11:31,350
you're not thinking about your make

00:11:29,070 --> 00:11:33,570
files because your advisor already did

00:11:31,350 --> 00:11:36,570
it for you so it's those sort of things

00:11:33,570 --> 00:11:38,460
that really aren't the best for someone

00:11:36,570 --> 00:11:40,560
new coming you to roast when you're like

00:11:38,460 --> 00:11:42,870
okay there's a lot of libraries which

00:11:40,560 --> 00:11:45,270
don't really have every feature or they

00:11:42,870 --> 00:11:46,770
have the core but that specific thing

00:11:45,270 --> 00:11:48,870
you need to do just isn't implemented

00:11:46,770 --> 00:11:50,880
yet and that can be a real barrier to

00:11:48,870 --> 00:11:52,530
entry as well as sometimes there's this

00:11:50,880 --> 00:11:53,970
perception that roast is just for

00:11:52,530 --> 00:11:55,890
systems programming or that it's a

00:11:53,970 --> 00:11:57,870
difficult language which isn't really

00:11:55,890 --> 00:12:00,090
the case but that can be a little bit of

00:11:57,870 --> 00:12:04,160
a barrier as well so I think that's all

00:12:00,090 --> 00:12:04,160
I have time for so thank you

00:12:10,950 --> 00:12:18,050
[Applause]

00:12:14,390 --> 00:12:18,050
any questions

00:12:27,660 --> 00:12:32,830
so what's your opinion on sort of

00:12:31,180 --> 00:12:35,020
bridging the gap between performance and

00:12:32,830 --> 00:12:37,450
readability with languages which sort of

00:12:35,020 --> 00:12:40,570
aim for both and for a more for a syntax

00:12:37,450 --> 00:12:42,250
more similar to math like Julia and do

00:12:40,570 --> 00:12:43,720
you think there's a future there in like

00:12:42,250 --> 00:12:46,630
the Russ community generally speaking

00:12:43,720 --> 00:12:49,240
building tools that bind to julia code

00:12:46,630 --> 00:12:51,520
similarly to how you have let's say the

00:12:49,240 --> 00:12:53,740
non by stuff or like the stuff built on

00:12:51,520 --> 00:12:57,640
top of it that's a lot of C++ code and

00:12:53,740 --> 00:13:11,170
essentially helping make scientific

00:12:57,640 --> 00:13:13,480
computing fast in Python is there like a

00:13:11,170 --> 00:13:15,250
future sort of Julia Russ collaboration

00:13:13,480 --> 00:13:16,720
would you see as being very fruitful

00:13:15,250 --> 00:13:20,140
because both of the languages are young

00:13:16,720 --> 00:13:21,490
and Julia essentially aims at more speed

00:13:20,140 --> 00:13:26,230
and readability in the scientific

00:13:21,490 --> 00:13:28,090
computing community more or less it's

00:13:26,230 --> 00:13:30,310
sort of said I would the implement with

00:13:28,090 --> 00:13:33,370
the idea that you could not sacrifice

00:13:30,310 --> 00:13:37,120
either so yes sort of a Python low-level

00:13:33,370 --> 00:13:39,640
fast running code hybrid but gee Julia

00:13:37,120 --> 00:13:42,730
has those same FFI features that roast

00:13:39,640 --> 00:13:44,170
has so you can import the code as you

00:13:42,730 --> 00:13:46,840
would normally with any other language

00:13:44,170 --> 00:13:48,700
into Julia and I I'm not sure if there

00:13:46,840 --> 00:13:50,620
are any specific crates for doing the

00:13:48,700 --> 00:13:52,860
sort of both ways the same way you can

00:13:50,620 --> 00:13:55,870
do where it creates like PI o 3 for

00:13:52,860 --> 00:13:57,480
Python or neon for a node but it's

00:13:55,870 --> 00:14:00,730
definitely something you could do and

00:13:57,480 --> 00:14:01,090
there's obviously a place for that sort

00:14:00,730 --> 00:14:02,530
of thing

00:14:01,090 --> 00:14:04,510
I've really done that much with Julia

00:14:02,530 --> 00:14:07,930
but I know it's definitely possible to

00:14:04,510 --> 00:14:10,320
integrate rosco with it all right more

00:14:07,930 --> 00:14:10,320
questions

00:14:27,420 --> 00:14:33,070
and we don't you don't choice the

00:14:30,640 --> 00:14:36,910
Fortran for a multi-level

00:14:33,070 --> 00:14:39,520
paralyzer on the CPU and GPU because of

00:14:36,910 --> 00:14:48,880
photon in Abbas speed-up well in this

00:14:39,520 --> 00:14:51,400
case you know the better

00:14:48,880 --> 00:14:53,560
yeah Fortran is sort of weird you don't

00:14:51,400 --> 00:14:55,510
really see it that much anywhere apart

00:14:53,560 --> 00:14:56,920
from in science there's a lot of really

00:14:55,510 --> 00:15:00,060
big libraries that are written in

00:14:56,920 --> 00:15:02,590
Fortran there's the real problem is why

00:15:00,060 --> 00:15:04,720
some someone wouldn't pick up for Tron

00:15:02,590 --> 00:15:06,790
to write something new would be there's

00:15:04,720 --> 00:15:08,980
it's not really modern there's not

00:15:06,790 --> 00:15:10,960
really a lot of resources for learning

00:15:08,980 --> 00:15:13,060
it and as I said before most of the

00:15:10,960 --> 00:15:15,130
people that are going into this sort of

00:15:13,060 --> 00:15:16,510
computing wouldn't have done that much

00:15:15,130 --> 00:15:19,420
computer science they might have done

00:15:16,510 --> 00:15:21,160
one class or two classes in school to

00:15:19,420 --> 00:15:23,620
like learn this sort of thing and

00:15:21,160 --> 00:15:25,600
usually Fortran isn't chosen that much

00:15:23,620 --> 00:15:27,220
it is chosen but it's not chosen that

00:15:25,600 --> 00:15:29,140
much and it's especially hard to sort of

00:15:27,220 --> 00:15:31,210
get started with because there's not the

00:15:29,140 --> 00:15:34,200
same resources and community that would

00:15:31,210 --> 00:15:43,290
be even wet languages like C and C++

00:15:34,200 --> 00:15:53,600
okay thank you any other

00:15:43,290 --> 00:15:56,730
we have time for one more question okay

00:15:53,600 --> 00:15:59,989
then it's done thank you very much Adam

00:15:56,730 --> 00:15:59,989

YouTube URL: https://www.youtube.com/watch?v=mlqxTfpF9Q4


