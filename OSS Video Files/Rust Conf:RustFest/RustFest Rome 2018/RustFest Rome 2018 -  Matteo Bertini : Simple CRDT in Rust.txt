Title: RustFest Rome 2018 -  Matteo Bertini : Simple CRDT in Rust
Publication date: 2018-11-24
Playlist: RustFest Rome 2018
Description: 
	A conflict-free replicated data type (CRDT) is a data structure that can be replicated, each replica can be updated independently and it is always mathematically possible to merge the replicas back without conflicts. The simplest CRDT is an _append only_ Set, where the _merge_ is the Set union, building upon this idea we can compose more complex data types. In this talk we will explore how to implement a `cli` for a CRDT shopping list, see how Traits are emerging during the code evolution, use cargo to include some useful crates with no pain, and document the code with runnable examples.

https://rome.rustfest.eu/sessions/simple-crdt-in-rust
https://media.ccc.de/v/rustfest-rome-10-simple-crdt-in-rust
Captions: 
	00:00:04,910 --> 00:00:11,700
okay my name is Matteo Marini

00:00:08,580 --> 00:00:14,099
I work for SS doctor and our work in

00:00:11,700 --> 00:00:21,539
Florence and here to talk you about

00:00:14,099 --> 00:00:25,710
simple charity in in Rus so the economy

00:00:21,539 --> 00:00:31,140
is already being funded completely

00:00:25,710 --> 00:00:37,079
related data types enough data type that

00:00:31,140 --> 00:00:39,239
can its thing to be replicated in and as

00:00:37,079 --> 00:00:42,890
a property that you are free to update

00:00:39,239 --> 00:00:46,410
the replica without coordination and

00:00:42,890 --> 00:00:48,450
eventually when you need some uniform

00:00:46,410 --> 00:00:53,280
you or your state you can merge all

00:00:48,450 --> 00:00:59,149
these replicas together and convert to

00:00:53,280 --> 00:01:01,590
some unique state and why are this

00:00:59,149 --> 00:01:03,989
interesting they are interesting for

00:01:01,590 --> 00:01:07,790
these properties and they're interesting

00:01:03,989 --> 00:01:12,570
also because some piece of software is

00:01:07,790 --> 00:01:22,560
using them so if like you can find them

00:01:12,570 --> 00:01:24,900
implemented in the sig text engine is

00:01:22,560 --> 00:01:27,210
the reason why I started to look about

00:01:24,900 --> 00:01:29,850
this stuff because in the implementation

00:01:27,210 --> 00:01:35,610
of the shortest acting these kind of

00:01:29,850 --> 00:01:39,450
thoughts are used a lot so disciplining

00:01:35,610 --> 00:01:42,869
is in fact double we have to kind of

00:01:39,450 --> 00:01:47,310
these data types we have the state-based

00:01:42,869 --> 00:01:49,290
one where C stands for convergent and in

00:01:47,310 --> 00:01:52,229
this kind of implementation and

00:01:49,290 --> 00:01:56,600
reasoning we are moving the states all

00:01:52,229 --> 00:01:59,790
the state and merging the state and the

00:01:56,600 --> 00:02:03,360
operation based was distance or

00:01:59,790 --> 00:02:06,930
commutative in that kind of limitation

00:02:03,360 --> 00:02:11,430
we are moving on the operation but they

00:02:06,930 --> 00:02:14,160
are formal equivalence and the first one

00:02:11,430 --> 00:02:16,530
is a bit easier to think about so we

00:02:14,160 --> 00:02:19,350
will try to

00:02:16,530 --> 00:02:24,990
start something about them to some

00:02:19,350 --> 00:02:27,360
example so let's dive in let's think

00:02:24,990 --> 00:02:31,740
about a little problem we have a

00:02:27,360 --> 00:02:33,480
start-up we are starting to our new

00:02:31,740 --> 00:02:36,720
application we are building our

00:02:33,480 --> 00:02:38,850
chartered shopping list we'd like to

00:02:36,720 --> 00:02:41,819
have all the cool properties some kind

00:02:38,850 --> 00:02:44,850
of application must have now so we'd

00:02:41,819 --> 00:02:47,489
like your work is connected to merge in

00:02:44,850 --> 00:02:50,580
some interesting way when we the network

00:02:47,489 --> 00:02:53,130
here is there but we will soon end up

00:02:50,580 --> 00:02:56,100
with some kind of conflicts because our

00:02:53,130 --> 00:02:58,920
Li we decided to literally take the list

00:02:56,100 --> 00:03:01,290
as the structure and the order is

00:02:58,920 --> 00:03:04,680
something that is creating got some

00:03:01,290 --> 00:03:08,989
problem so we can make a step back and

00:03:04,680 --> 00:03:12,930
say okay in fact the set can be enough

00:03:08,989 --> 00:03:15,870
our shopping and this is the first

00:03:12,930 --> 00:03:19,019
intuition about reality not every data

00:03:15,870 --> 00:03:21,390
type is valid reality you cannot

00:03:19,019 --> 00:03:24,900
implement all the interesting features

00:03:21,390 --> 00:03:28,290
you'd like to implement if you for other

00:03:24,900 --> 00:03:31,440
types but some of the data types are

00:03:28,290 --> 00:03:38,280
policy oddity and for them you have all

00:03:31,440 --> 00:03:41,640
that good properties so we have this set

00:03:38,280 --> 00:03:44,459
and we start thinking okay I cannot pass

00:03:41,640 --> 00:03:48,420
that my said my wife cannot paste my set

00:03:44,459 --> 00:03:51,510
I can find that set Union is some kind

00:03:48,420 --> 00:03:54,930
of valid way to merge them and what I

00:03:51,510 --> 00:03:57,870
have created is something called its I

00:03:54,930 --> 00:04:01,820
grow only set the set that can only grow

00:03:57,870 --> 00:04:05,150
because our operation needs update is

00:04:01,820 --> 00:04:09,239
our update operation is adding stuff and

00:04:05,150 --> 00:04:12,560
adding may only grow or if the item is

00:04:09,239 --> 00:04:16,829
already there let certain change it and

00:04:12,560 --> 00:04:19,049
the merge operation is Union and I am

00:04:16,829 --> 00:04:22,640
not losing anything when I'm doing Union

00:04:19,049 --> 00:04:26,669
and so I'm quite happy with the solution

00:04:22,640 --> 00:04:29,190
in rust I can implement this as a simple

00:04:26,669 --> 00:04:33,030
themed wrapper around

00:04:29,190 --> 00:04:37,080
and ash that I will add my value that it

00:04:33,030 --> 00:04:40,260
is an Alice four string this time to my

00:04:37,080 --> 00:04:42,480
set the update is local and requires no

00:04:40,260 --> 00:04:47,490
coordination and whenever I need to

00:04:42,480 --> 00:04:51,050
merge with some other state I will have

00:04:47,490 --> 00:04:53,310
a reference of the same type and return

00:04:51,050 --> 00:04:56,640
we are not mutating here we're returning

00:04:53,310 --> 00:04:59,550
a new copy but that is we are returning

00:04:56,640 --> 00:05:00,680
and you type any resistance of the same

00:04:59,550 --> 00:05:05,670
type

00:05:00,680 --> 00:05:09,410
here is another intuition about CID keys

00:05:05,670 --> 00:05:12,480
both the add the update operation and

00:05:09,410 --> 00:05:15,480
the merge operation are growing

00:05:12,480 --> 00:05:17,250
inflating are not shrinking our data set

00:05:15,480 --> 00:05:20,070
and this is something that we must

00:05:17,250 --> 00:05:22,590
ensure when we are developing some this

00:05:20,070 --> 00:05:24,780
kind of data types and the merge

00:05:22,590 --> 00:05:27,030
operation has other cool properties

00:05:24,780 --> 00:05:29,010
because we can merge our would be or be

00:05:27,030 --> 00:05:31,710
with our and the result is the same if

00:05:29,010 --> 00:05:33,990
we have more than two items we can merge

00:05:31,710 --> 00:05:36,210
them in whatever order we like and

00:05:33,990 --> 00:05:39,690
result the same and we can merge our

00:05:36,210 --> 00:05:43,650
with our again and result is our and is

00:05:39,690 --> 00:05:47,490
as properties that must hold for C

00:05:43,650 --> 00:05:50,340
oddities and here kickin another cool

00:05:47,490 --> 00:05:52,380
aspect of these tough types whenever you

00:05:50,340 --> 00:05:56,040
build something that works that is

00:05:52,380 --> 00:05:58,650
verified you can compose these small

00:05:56,040 --> 00:06:01,200
pieces together to build something more

00:05:58,650 --> 00:06:05,220
interesting we had a set that can only

00:06:01,200 --> 00:06:07,980
grow we can take two of these sets that

00:06:05,220 --> 00:06:10,140
are allowed to grow and compose them in

00:06:07,980 --> 00:06:12,960
what is called a two-phase set we will

00:06:10,140 --> 00:06:15,780
have the set of the other staff and the

00:06:12,960 --> 00:06:20,580
set of the remove s star both of them

00:06:15,780 --> 00:06:24,300
are growing our merge function that is

00:06:20,580 --> 00:06:26,720
now appeared appearing as a tree is

00:06:24,300 --> 00:06:30,300
simply for boarding the merge two hours

00:06:26,720 --> 00:06:32,310
subfields but now we have to do

00:06:30,300 --> 00:06:36,570
something more before the grow only set

00:06:32,310 --> 00:06:39,900
the action to the query we are doing on

00:06:36,570 --> 00:06:40,860
the set was simply having all the items

00:06:39,900 --> 00:06:43,740
back

00:06:40,860 --> 00:06:47,159
this time we have to do some kind of

00:06:43,740 --> 00:06:47,849
operation we have the stuff we added to

00:06:47,159 --> 00:06:51,000
the list

00:06:47,849 --> 00:06:53,759
we added pasta we added pistol if I bite

00:06:51,000 --> 00:06:56,310
pasta I put it in the remove it set and

00:06:53,759 --> 00:07:01,319
then I take the set difference

00:06:56,310 --> 00:07:03,300
I have only pistol left by but it's not

00:07:01,319 --> 00:07:06,599
yet enough for our shopping list because

00:07:03,300 --> 00:07:09,120
if I buy pasta if I add pasta I bypassed

00:07:06,599 --> 00:07:12,300
I cannot have pasta anymore and this is

00:07:09,120 --> 00:07:17,819
that problem so let's introduce another

00:07:12,300 --> 00:07:21,270
trick about CIT the tag trick we have

00:07:17,819 --> 00:07:26,129
the simple string value our item was

00:07:21,270 --> 00:07:27,389
simply string this time our item is at a

00:07:26,129 --> 00:07:29,969
poll of two items

00:07:27,389 --> 00:07:33,150
the first one is some kind of unique tag

00:07:29,969 --> 00:07:36,689
this time simply a string but usually we

00:07:33,150 --> 00:07:39,210
are going to make to add to the item to

00:07:36,689 --> 00:07:42,060
the tag some more metadata usually you

00:07:39,210 --> 00:07:44,490
will have some kind of counter some kind

00:07:42,060 --> 00:07:47,279
of timestamp we know we cannot use it to

00:07:44,490 --> 00:07:51,690
order think because they are originated

00:07:47,279 --> 00:07:54,180
from different devices but we are only

00:07:51,690 --> 00:07:58,500
using these times m to make something

00:07:54,180 --> 00:08:00,539
unique than some device ID or user ID or

00:07:58,500 --> 00:08:03,120
stuff like that just to show something

00:08:00,539 --> 00:08:05,460
interesting to the user the important

00:08:03,120 --> 00:08:11,189
thing is that is unique and then the

00:08:05,460 --> 00:08:13,620
value what user care about again we can

00:08:11,189 --> 00:08:16,009
use composition we are doing what is

00:08:13,620 --> 00:08:19,169
called and observer to remove set

00:08:16,009 --> 00:08:23,419
building upon our to face set before

00:08:19,169 --> 00:08:27,719
that was it set with two Rolly set and

00:08:23,419 --> 00:08:30,120
modify a bit our API or at least our API

00:08:27,719 --> 00:08:32,490
is almost the same when we are going to

00:08:30,120 --> 00:08:35,669
add we are taking the value this time is

00:08:32,490 --> 00:08:39,329
again string we are generating some kind

00:08:35,669 --> 00:08:42,620
of new unique tag and we are adding the

00:08:39,329 --> 00:08:46,890
couple the support to the to the set

00:08:42,620 --> 00:08:49,290
whenever we are going to query we are

00:08:46,890 --> 00:08:54,120
going to under create it we are going to

00:08:49,290 --> 00:08:56,279
ask our sub field the items with

00:08:54,120 --> 00:08:58,380
for us the difference and we are going

00:08:56,279 --> 00:09:01,620
to show the user only the second part

00:08:58,380 --> 00:09:04,800
here is another intuition about CIT most

00:09:01,620 --> 00:09:07,740
of time your state is more complex than

00:09:04,800 --> 00:09:11,010
what you want to show to your user the

00:09:07,740 --> 00:09:16,170
state is some kind of implementation

00:09:11,010 --> 00:09:19,650
detail of your data type you use a clean

00:09:16,170 --> 00:09:22,890
only on about a part of it and what

00:09:19,650 --> 00:09:26,310
change it what we are introducing is the

00:09:22,890 --> 00:09:30,300
strategy we are using to avoid conflicts

00:09:26,310 --> 00:09:32,730
and this time we use this kind of

00:09:30,300 --> 00:09:35,370
strategy whenever we are going to remove

00:09:32,730 --> 00:09:39,570
something we're going to remove only

00:09:35,370 --> 00:09:43,170
something that we can locally observe so

00:09:39,570 --> 00:09:46,279
for example if I added pasta it will be

00:09:43,170 --> 00:09:49,890
implicitly target as pasta Matteo

00:09:46,279 --> 00:09:53,160
whenever I am removing pasta I will look

00:09:49,890 --> 00:10:01,130
up in my other set I will look only for

00:09:53,160 --> 00:10:04,110
the user facing part of the value I will

00:10:01,130 --> 00:10:07,470
add to the remove it set all the

00:10:04,110 --> 00:10:12,360
matching tuples with all the matching

00:10:07,470 --> 00:10:15,150
tax I find locally in my added set if

00:10:12,360 --> 00:10:18,930
before we merge before I am removing

00:10:15,150 --> 00:10:21,750
something someone else added again pasta

00:10:18,930 --> 00:10:25,350
to our shared set whenever we merge I

00:10:21,750 --> 00:10:27,390
will see popping up again pasta and if I

00:10:25,350 --> 00:10:29,550
add some intelligent metadata I can show

00:10:27,390 --> 00:10:32,970
that Giovanni added the pasta

00:10:29,550 --> 00:10:35,790
whenever when index time I was buying it

00:10:32,970 --> 00:10:40,050
or one hour later or whatever and I can

00:10:35,790 --> 00:10:45,150
decide to call him or to do something

00:10:40,050 --> 00:10:49,529
reasonable this is up to the problem we

00:10:45,150 --> 00:10:53,880
are facing we have used this is what is

00:10:49,529 --> 00:10:56,910
called ad win strategy we can apply some

00:10:53,880 --> 00:11:00,300
remove win strategy or some other

00:10:56,910 --> 00:11:04,350
strategy but it's up to the problem what

00:11:00,300 --> 00:11:06,610
you want is to avoid conflicts and to

00:11:04,350 --> 00:11:10,209
apply the same algorithm all

00:11:06,610 --> 00:11:15,730
your instances of the coat brands around

00:11:10,209 --> 00:11:19,990
your dust types so some try around tweet

00:11:15,730 --> 00:11:22,540
imagine from this journey we have an

00:11:19,990 --> 00:11:26,440
implicit one or second simplicity we had

00:11:22,540 --> 00:11:29,860
only the function add and remove that

00:11:26,440 --> 00:11:33,010
were taking directly value we can had

00:11:29,860 --> 00:11:36,339
some kind of update trait working on

00:11:33,010 --> 00:11:39,940
some kind of a Newman and enforce what

00:11:36,339 --> 00:11:44,019
we said before so that after an update

00:11:39,940 --> 00:11:47,140
our state must grow our state in fact

00:11:44,019 --> 00:11:52,450
can be forced to implement partial older

00:11:47,140 --> 00:11:57,519
just to check that some order is a what

00:11:52,450 --> 00:12:00,089
the theory asked us is verified then we

00:11:57,519 --> 00:12:04,510
have the merge trait that operated on

00:12:00,089 --> 00:12:09,880
the same type is closed so I am working

00:12:04,510 --> 00:12:12,010
on our server to remove set merging only

00:12:09,880 --> 00:12:17,680
with the same type and returning same

00:12:12,010 --> 00:12:20,560
type and we can see with you can find

00:12:17,680 --> 00:12:23,649
the formal verification but we can

00:12:20,560 --> 00:12:27,160
intuitively accept that Union is valid

00:12:23,649 --> 00:12:32,529
merge operation for sets and the maximum

00:12:27,160 --> 00:12:35,560
is valid merge operation for numbers and

00:12:32,529 --> 00:12:37,930
then a query trait whenever we are going

00:12:35,560 --> 00:12:40,600
to ask something to our data structure

00:12:37,930 --> 00:12:45,010
we must implement it straight so that we

00:12:40,600 --> 00:12:48,040
can explicitly declare what is the sub

00:12:45,010 --> 00:12:50,440
part of the state we'd like to show or

00:12:48,040 --> 00:12:52,949
we can also generate something on the

00:12:50,440 --> 00:12:56,649
flight Buzzard on what's inside state

00:12:52,949 --> 00:12:59,050
and then it trait was hidden before

00:12:56,649 --> 00:13:02,290
because we had some kind of an animal a

00:12:59,050 --> 00:13:05,649
unique tag generator usually your tab

00:13:02,290 --> 00:13:07,750
will like to we likely introspect your

00:13:05,649 --> 00:13:12,130
local state and generally it's some kind

00:13:07,750 --> 00:13:15,010
of next tag for some kind of order we

00:13:12,130 --> 00:13:18,070
like to have and so here the

00:13:15,010 --> 00:13:21,970
reference to the self and again this is

00:13:18,070 --> 00:13:29,440
local and you can do you can evolve your

00:13:21,970 --> 00:13:32,440
state without coordination so in the

00:13:29,440 --> 00:13:36,010
abstract I talked about clean I have not

00:13:32,440 --> 00:13:41,710
time to show you here but it's on the

00:13:36,010 --> 00:13:45,250
wrapper and just to thank some creates i

00:13:41,710 --> 00:13:47,680
used cloud plans truck top are fantastic

00:13:45,250 --> 00:13:50,530
and not in this project but quickly is

00:13:47,680 --> 00:13:54,670
very neat use i used some other common

00:13:50,530 --> 00:13:57,310
line tools and here's some references

00:13:54,670 --> 00:14:01,020
the first one if you have time it's very

00:13:57,310 --> 00:14:03,880
interesting it's one hour and stuff long

00:14:01,020 --> 00:14:06,130
video from marcia pedo it was one of the

00:14:03,880 --> 00:14:10,000
name behind these data types it will eat

00:14:06,130 --> 00:14:15,030
reduce the theory behind them eventually

00:14:10,000 --> 00:14:18,600
consistent all the theory about

00:14:15,030 --> 00:14:21,070
eventually event well consistency and

00:14:18,600 --> 00:14:24,640
here is the paper that will introduce

00:14:21,070 --> 00:14:27,610
you a lot of data types that are

00:14:24,640 --> 00:14:31,600
verified to be capt you can use you can

00:14:27,610 --> 00:14:34,180
find sets counters registers and then

00:14:31,600 --> 00:14:36,310
you can build upon them graphs and if

00:14:34,180 --> 00:14:40,210
you are brave enough you can reach the

00:14:36,310 --> 00:14:47,260
collaborative in text edit or state at

00:14:40,210 --> 00:14:49,200
the end and if you like to dip on the on

00:14:47,260 --> 00:14:52,690
death aspect

00:14:49,200 --> 00:14:54,970
inside the exceed that documentation is

00:14:52,690 --> 00:14:57,370
there is a series of blog post now

00:14:54,970 --> 00:15:01,030
groupid in the documentation that will

00:14:57,370 --> 00:15:03,490
explore all the trade off and all the

00:15:01,030 --> 00:15:07,200
problems you may find if you'd like to

00:15:03,490 --> 00:15:10,540
take from the toy level to something

00:15:07,200 --> 00:15:13,120
derivative deliverable because here we

00:15:10,540 --> 00:15:15,460
are moving all the state when the state

00:15:13,120 --> 00:15:17,290
starts growing you have to find some

00:15:15,460 --> 00:15:19,630
compromise you'd like to move less and

00:15:17,290 --> 00:15:22,780
you like perhaps to forget something

00:15:19,630 --> 00:15:27,190
from the very very old past and you have

00:15:22,780 --> 00:15:28,720
to find some compromises about this here

00:15:27,190 --> 00:15:31,810
is

00:15:28,720 --> 00:15:36,190
my code you can find is very educational

00:15:31,810 --> 00:15:40,750
is you can find it from the steps from

00:15:36,190 --> 00:15:42,850
simple append-only set to the observer

00:15:40,750 --> 00:15:46,029
to remove set till a generic

00:15:42,850 --> 00:15:49,930
implementation this is quite long if you

00:15:46,029 --> 00:15:52,149
want to require all of the parts

00:15:49,930 --> 00:15:57,279
Tahlequah as stuff you are required to

00:15:52,149 --> 00:16:01,029
and if you do something like that or if

00:15:57,279 --> 00:16:04,569
you do what the author or a capt did we

00:16:01,029 --> 00:16:06,430
can fire again or your check and

00:16:04,569 --> 00:16:12,519
requirements something like quick check

00:16:06,430 --> 00:16:15,639
and have some kind of be sure that your

00:16:12,519 --> 00:16:17,170
code is respecting the rules and there

00:16:15,639 --> 00:16:24,370
are a lot of implementation in other

00:16:17,170 --> 00:16:26,589
languages you can look at so what I am

00:16:24,370 --> 00:16:31,240
suggesting it's it's not black magic

00:16:26,589 --> 00:16:33,880
it's quite the paper are not so easy to

00:16:31,240 --> 00:16:37,600
read but if you are accepting something

00:16:33,880 --> 00:16:41,709
by intuition and not going deep in same

00:16:37,600 --> 00:16:44,290
a lot eyes connected join stuff that you

00:16:41,709 --> 00:16:46,689
may perhaps know if you are

00:16:44,290 --> 00:16:51,329
mathematician you can be something

00:16:46,689 --> 00:16:51,329
interesting with acidity thank you

00:16:57,090 --> 00:17:04,110
okay Thank You Matteo maybe we have time

00:17:00,610 --> 00:17:04,110
for a couple of questions

00:17:12,329 --> 00:17:25,030
sorry so maybe that's not the point of

00:17:22,209 --> 00:17:29,590
the talk but I saw a lot of high level

00:17:25,030 --> 00:17:31,570
structures used like hash map and I

00:17:29,590 --> 00:17:38,530
immediately thought about performance

00:17:31,570 --> 00:17:40,630
concerns so what are the solutions so if

00:17:38,530 --> 00:17:43,720
you'd like to deepen those performance

00:17:40,630 --> 00:17:48,760
problems perhaps the rope series is what

00:17:43,720 --> 00:17:51,250
it's like because is the trade-off is

00:17:48,760 --> 00:17:53,260
between something you can easily use and

00:17:51,250 --> 00:17:56,110
something that is usable in reality with

00:17:53,260 --> 00:17:59,110
big text files and the Rope is using for

00:17:56,110 --> 00:18:02,980
the text editor are a bit complex stuff

00:17:59,110 --> 00:18:06,250
and so he found a lot of good

00:18:02,980 --> 00:18:08,590
implementation solution for while

00:18:06,250 --> 00:18:12,660
maintaining these kind of properties but

00:18:08,590 --> 00:18:16,410
it's something that you can find on your

00:18:12,660 --> 00:18:16,410
exact problem maybe

00:18:19,920 --> 00:18:23,760
okay others

00:18:29,520 --> 00:18:34,220

YouTube URL: https://www.youtube.com/watch?v=CPbhrPPI1Xw


