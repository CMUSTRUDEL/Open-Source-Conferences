Title: RustFest Rome 2018 -  Pascal Hertleif: Declarative programming in Rust
Publication date: 2018-11-25
Playlist: RustFest Rome 2018
Description: 
	One of the secret ingredients in many successful, big code bases is that they found a good level of abstraction. One helpful technique is to write declarative code: You describe "what" you want to do, but don't mix it with the "how". While this is not specific to Rust, the language and its ecosystem help us write declarative code. This talk will go over some examples, covering famous crates and APIs as well as more obscure ones, to then dive into ways to use this to your advantage in your own code.

https://rome.rustfest.eu/sessions/declarative-programming-in-rust
https://media.ccc.de/v/rustfest-rome-5-declarative-programming-in-rust
Captions: 
	00:00:04,310 --> 00:00:10,500
yeah today I'm here to talk to you about

00:00:07,589 --> 00:00:12,269
the cloud of programming and after

00:00:10,500 --> 00:00:13,590
Eric's perfect introduction I really

00:00:12,269 --> 00:00:16,289
don't have to introduce myself anymore

00:00:13,590 --> 00:00:19,080
it seems and but I've been working with

00:00:16,289 --> 00:00:20,400
rust since early 2014 and I've been

00:00:19,080 --> 00:00:22,859
loving every minute of it

00:00:20,400 --> 00:00:26,010
right now I'm mostly concerned with

00:00:22,859 --> 00:00:30,500
making CLI tools in rust really amazing

00:00:26,010 --> 00:00:33,809
and also if you happen to be in Cologne

00:00:30,500 --> 00:00:35,730
you should come to Ronnie down you can

00:00:33,809 --> 00:00:40,140
find me on the on the internet on deuce

00:00:35,730 --> 00:00:42,559
addresses and with that let's start at

00:00:40,140 --> 00:00:42,559
the beginning

00:00:42,590 --> 00:00:53,070
the very very beginning what is a

00:00:48,750 --> 00:00:56,670
computer program let's think about that

00:00:53,070 --> 00:00:57,960
for a minute now okay fine so to make a

00:00:56,670 --> 00:01:02,870
program work you basically have to tell

00:00:57,960 --> 00:01:06,119
the computer what to do step by step

00:01:02,870 --> 00:01:08,970
step by very tiny step so this is

00:01:06,119 --> 00:01:11,729
imperative this is literally called

00:01:08,970 --> 00:01:14,640
imperative programming and if you do

00:01:11,729 --> 00:01:16,770
enough of this it's very hard to reason

00:01:14,640 --> 00:01:19,830
about the general behavior of your

00:01:16,770 --> 00:01:23,340
program but you might be saying where

00:01:19,830 --> 00:01:26,070
this rust fest a lot of assembly camp so

00:01:23,340 --> 00:01:28,080
what are you even talking about if

00:01:26,070 --> 00:01:29,790
you're here for assembly this is not the

00:01:28,080 --> 00:01:32,970
talk for you I'm so sorry

00:01:29,790 --> 00:01:35,369
but the common theme was my talks said

00:01:32,970 --> 00:01:37,549
I'll at some point drift off and talk

00:01:35,369 --> 00:01:41,460
about what maintainable code looks like

00:01:37,549 --> 00:01:44,369
and that's always having maintainable

00:01:41,460 --> 00:01:48,869
code it's in hiring demand but it's also

00:01:44,369 --> 00:01:50,340
very hard to get there so the question

00:01:48,869 --> 00:01:53,250
you need to ask yourself this is my code

00:01:50,340 --> 00:01:56,130
maintainable and this is a good question

00:01:53,250 --> 00:01:58,469
and I have some more questions first off

00:01:56,130 --> 00:02:01,979
like how much do you need to read to

00:01:58,469 --> 00:02:04,740
understand what is going on but also how

00:02:01,979 --> 00:02:08,429
much do you need to write to make a

00:02:04,740 --> 00:02:12,390
change in your program code and last but

00:02:08,429 --> 00:02:13,650
not least how easy is it to identify the

00:02:12,390 --> 00:02:15,659
core concepts of

00:02:13,650 --> 00:02:19,500
what's going on these are very generic

00:02:15,659 --> 00:02:21,269
questions I know and they apply to

00:02:19,500 --> 00:02:24,090
basically every piece of code you've

00:02:21,269 --> 00:02:26,670
ever written I think so what does it

00:02:24,090 --> 00:02:28,260
actually have to do with this talk

00:02:26,670 --> 00:02:31,650
because the talk is declarative

00:02:28,260 --> 00:02:33,750
programming so let's define this and as

00:02:31,650 --> 00:02:35,400
always when I need to find the

00:02:33,750 --> 00:02:37,439
definition of something I go to the

00:02:35,400 --> 00:02:39,450
Kapiti I write wikipedia tells me that

00:02:37,439 --> 00:02:41,189
the cloud of program is often defined as

00:02:39,450 --> 00:02:47,760
any style of programming that is not in

00:02:41,189 --> 00:02:51,659
person it's that's true okay not really

00:02:47,760 --> 00:02:53,579
helpful the Wikipedia page goes on and

00:02:51,659 --> 00:02:55,530
talks about some examples from the

00:02:53,579 --> 00:02:59,579
client of programming for example HTML

00:02:55,530 --> 00:03:04,530
or regular expressions or sequel but

00:02:59,579 --> 00:03:07,500
also high school and Prolog headful yeah

00:03:04,530 --> 00:03:13,319
okay okay fine but what is it really

00:03:07,500 --> 00:03:17,579
about I'd summarize it as it's about the

00:03:13,319 --> 00:03:20,669
what instead of the how the idea is that

00:03:17,579 --> 00:03:23,400
you don't write all the steps on how to

00:03:20,669 --> 00:03:25,470
get somewhere but instead you try to

00:03:23,400 --> 00:03:27,299
express what you want to accomplish and

00:03:25,470 --> 00:03:31,650
basically if your computer do stuff for

00:03:27,299 --> 00:03:36,180
you which is nice and you might be

00:03:31,650 --> 00:03:37,730
wondering how okay so the few steps you

00:03:36,180 --> 00:03:42,299
might want to take is to identify

00:03:37,730 --> 00:03:46,590
concepts that your program is about and

00:03:42,299 --> 00:03:49,859
you try to extract their behavior you

00:03:46,590 --> 00:03:51,780
abstract over control flow that means

00:03:49,859 --> 00:03:54,449
you have in your editor with syntax

00:03:51,780 --> 00:03:57,449
highlighting less of those colorful key

00:03:54,449 --> 00:04:01,319
words and more expressive function names

00:03:57,449 --> 00:04:02,639
and in the end you hope to be able to

00:04:01,319 --> 00:04:06,150
compose your application application

00:04:02,639 --> 00:04:08,040
from smaller parts okay okay I'm fine I

00:04:06,150 --> 00:04:10,139
know what you're saying can get to the

00:04:08,040 --> 00:04:14,579
point what does it actually have to do

00:04:10,139 --> 00:04:16,919
with rust the super abstract like okay

00:04:14,579 --> 00:04:18,750
how do I apply this and this is very

00:04:16,919 --> 00:04:21,329
good question because this is actually

00:04:18,750 --> 00:04:23,039
about introducing abstractions and if

00:04:21,329 --> 00:04:25,620
they're right you end up as code that's

00:04:23,039 --> 00:04:27,480
easier to reason about and declarative

00:04:25,620 --> 00:04:31,380
code in rust okay fine

00:04:27,480 --> 00:04:33,740
so as the cloud of code is ever saying

00:04:31,380 --> 00:04:37,470
but imperative code apparently and rust

00:04:33,740 --> 00:04:41,250
is totally able to give you all the

00:04:37,470 --> 00:04:43,230
emotive needs you ever need to have you

00:04:41,250 --> 00:04:45,540
might be wondering okay if this is a

00:04:43,230 --> 00:04:47,400
functional construct and I'm going to

00:04:45,540 --> 00:04:51,240
talk about functional programming now

00:04:47,400 --> 00:04:53,370
and I am sad to say I'm not because rust

00:04:51,240 --> 00:04:55,620
to me is very pragmatic in that it has

00:04:53,370 --> 00:04:57,390
functional elements that allows you to

00:04:55,620 --> 00:04:59,490
write very functional looking code but

00:04:57,390 --> 00:05:02,490
it also allows you to embrace mutability

00:04:59,490 --> 00:05:06,810
and write imperative code if you so

00:05:02,490 --> 00:05:08,640
desire and I leave it to the experts to

00:05:06,810 --> 00:05:11,520
say if rust is actually a functional

00:05:08,640 --> 00:05:13,170
programming language but I want to talk

00:05:11,520 --> 00:05:16,830
to you about how rust is able to

00:05:13,170 --> 00:05:18,510
abstract over ideas and in fact one of

00:05:16,830 --> 00:05:21,000
the selling points of rust is to have a

00:05:18,510 --> 00:05:23,370
zero cost abstractions which basically

00:05:21,000 --> 00:05:27,150
talks about the runtime cost of having

00:05:23,370 --> 00:05:30,060
abstractions that means you can write

00:05:27,150 --> 00:05:31,680
abstract high level code and if you need

00:05:30,060 --> 00:05:33,900
it to be high-performance code as well

00:05:31,680 --> 00:05:35,250
you don't have to drop down to a lower

00:05:33,900 --> 00:05:37,740
level and write it in an imperative

00:05:35,250 --> 00:05:39,750
style instead russ tries to give you

00:05:37,740 --> 00:05:42,510
high performance code with high

00:05:39,750 --> 00:05:44,280
abstraction and this talk will be by

00:05:42,510 --> 00:05:46,230
example because it's a short talk and

00:05:44,280 --> 00:05:49,650
i've also been talking for six minutes

00:05:46,230 --> 00:05:51,780
already and i can't possibly give you a

00:05:49,650 --> 00:05:55,350
recipe to turn on your code into better

00:05:51,780 --> 00:05:57,090
code at least not in this talk and i

00:05:55,350 --> 00:06:01,470
hope to give you some examples in its

00:05:57,090 --> 00:06:07,590
value so let's start with something

00:06:01,470 --> 00:06:09,720
simple and that was loose in every piece

00:06:07,590 --> 00:06:11,100
of code I've ever touched at some points

00:06:09,720 --> 00:06:15,030
there was a loop over a collection of

00:06:11,100 --> 00:06:18,720
items and this looks like a good example

00:06:15,030 --> 00:06:20,700
to me let's have a list of items I'm

00:06:18,720 --> 00:06:24,930
going with Latin here because we are

00:06:20,700 --> 00:06:27,630
wrong and fubar is so over and the idea

00:06:24,930 --> 00:06:31,040
is to find the first element that ends

00:06:27,630 --> 00:06:36,060
with a character n so we loop over our

00:06:31,040 --> 00:06:39,000
vector and we go from the zeros item up

00:06:36,060 --> 00:06:41,430
to the last item it's defined by the

00:06:39,000 --> 00:06:44,190
length of the vector and you

00:06:41,430 --> 00:06:46,889
certain happens to end with name return

00:06:44,190 --> 00:06:51,120
some and the content of sediment

00:06:46,889 --> 00:06:53,940
otherwise return none okay this is

00:06:51,120 --> 00:06:55,500
simply enough it's actually easy to read

00:06:53,940 --> 00:06:58,050
and if you're used to the style it's

00:06:55,500 --> 00:07:01,830
very very common and you wouldn't

00:06:58,050 --> 00:07:04,830
question it but in the real world we

00:07:01,830 --> 00:07:06,900
have gonna have some problems for

00:07:04,830 --> 00:07:09,690
example there are new requirements it

00:07:06,900 --> 00:07:11,669
just happened to turn up one day imagine

00:07:09,690 --> 00:07:13,470
you're going into the office Monday

00:07:11,669 --> 00:07:15,960
morning and your boss tells you ok

00:07:13,470 --> 00:07:17,750
you've been doing this code it's fine

00:07:15,960 --> 00:07:21,330
it's working but now you need to have

00:07:17,750 --> 00:07:24,030
something that finds the fifth five the

00:07:21,330 --> 00:07:26,100
five elements that end with em so you're

00:07:24,030 --> 00:07:29,550
gonna extend this piece of code and you

00:07:26,100 --> 00:07:32,789
add a mutable result to it and to push

00:07:29,550 --> 00:07:37,160
items into it and also you try to only

00:07:32,789 --> 00:07:41,250
go up to five elements so this if is

00:07:37,160 --> 00:07:44,550
pretty much twice the size and in the

00:07:41,250 --> 00:07:46,760
end you can return the result okay this

00:07:44,550 --> 00:07:50,400
is still easy to reason about

00:07:46,760 --> 00:07:52,949
it's count that fits on a slide so I'd

00:07:50,400 --> 00:07:54,870
say it's fine you can read it and you

00:07:52,949 --> 00:07:57,870
know what's going on but there are some

00:07:54,870 --> 00:08:02,070
nuances for example the very important

00:07:57,870 --> 00:08:04,139
piece is the five and less than or equal

00:08:02,070 --> 00:08:06,060
and actually the font I chose has a

00:08:04,139 --> 00:08:07,889
ligature for it so it's actually lesser

00:08:06,060 --> 00:08:11,520
or equal sign but in your code it might

00:08:07,889 --> 00:08:12,720
not look like this and the five right in

00:08:11,520 --> 00:08:15,659
the middle is basically the new

00:08:12,720 --> 00:08:19,010
requirement but for some reason it's

00:08:15,659 --> 00:08:23,659
right in the middle and not just visible

00:08:19,010 --> 00:08:26,669
okay okay what's an alternative approach

00:08:23,659 --> 00:08:28,650
your target of approach is to use

00:08:26,669 --> 00:08:30,060
iterators and if you've written rust

00:08:28,650 --> 00:08:32,099
you've probably also come across

00:08:30,060 --> 00:08:36,150
iterators because in receiver will come

00:08:32,099 --> 00:08:41,580
and the advantage of this snippet of

00:08:36,150 --> 00:08:44,370
code is that the core concepts are right

00:08:41,580 --> 00:08:47,880
there in the method names you filter for

00:08:44,370 --> 00:08:51,660
items that end with nan you take five of

00:08:47,880 --> 00:08:54,670
them and you collect them I know I've

00:08:51,660 --> 00:08:56,700
committed some type annotations but

00:08:54,670 --> 00:09:01,120
this will work in the right context

00:08:56,700 --> 00:09:05,140
actually this is faster than the Luke

00:09:01,120 --> 00:09:07,420
we've just seen because the Luke I wrote

00:09:05,140 --> 00:09:09,790
behind that I totally forgot that after

00:09:07,420 --> 00:09:12,720
I've already collected five elements I

00:09:09,790 --> 00:09:15,670
can just stop and do an early return

00:09:12,720 --> 00:09:17,500
okay it stupid mistake but it's Monday

00:09:15,670 --> 00:09:21,520
morning right I totally forgot about it

00:09:17,500 --> 00:09:35,350
and this code just it's way slower than

00:09:21,520 --> 00:09:36,700
I actually needed to have it see so for

00:09:35,350 --> 00:09:39,070
the live stream he pointed out that I'm

00:09:36,700 --> 00:09:42,370
taking six elements because I'm not able

00:09:39,070 --> 00:09:45,790
to count but like I said Monday morning

00:09:42,370 --> 00:09:47,350
this is a great example of how iterators

00:09:45,790 --> 00:09:49,510
can save me because I don't have to

00:09:47,350 --> 00:09:53,790
count you can just like take five

00:09:49,510 --> 00:09:55,000
elements and it's good to go yeah nice

00:09:53,790 --> 00:09:59,230
okay

00:09:55,000 --> 00:10:01,660
okay wasn't actually expecting that good

00:09:59,230 --> 00:10:04,240
but what what have we done in general

00:10:01,660 --> 00:10:08,430
we've abstracted over this control flow

00:10:04,240 --> 00:10:11,730
of looping and conditioning and

00:10:08,430 --> 00:10:14,850
basically just create our intent on

00:10:11,730 --> 00:10:17,770
filtering and checking five elements

00:10:14,850 --> 00:10:21,970
also note that this is an abstraction

00:10:17,770 --> 00:10:23,950
that is pretty pretty powerful I have

00:10:21,970 --> 00:10:26,590
omitted to type annotations for one

00:10:23,950 --> 00:10:28,720
reason specifically and that is I don't

00:10:26,590 --> 00:10:30,550
care that this is a vector and I don't

00:10:28,720 --> 00:10:33,790
care what I'm collecting into this could

00:10:30,550 --> 00:10:39,190
be hash sets I don't mind it's super

00:10:33,790 --> 00:10:41,950
generic actually and this makes sense if

00:10:39,190 --> 00:10:45,490
you have a chain of iterator calls and

00:10:41,950 --> 00:10:49,360
it's all good but it also makes sense if

00:10:45,490 --> 00:10:52,390
you are looking for just one condition

00:10:49,360 --> 00:10:55,840
in an iteration for example there is an

00:10:52,390 --> 00:10:58,360
any method that you can use to just

00:10:55,840 --> 00:11:00,460
check hey is there any element in my

00:10:58,360 --> 00:11:02,200
list and you don't have to write a for

00:11:00,460 --> 00:11:04,060
loop and you don't have to write a

00:11:02,200 --> 00:11:05,800
condition in it you can just say any

00:11:04,060 --> 00:11:07,360
because what you want is subjective

00:11:05,800 --> 00:11:08,670
selves and the element it's very very

00:11:07,360 --> 00:11:12,520
expressive

00:11:08,670 --> 00:11:16,000
okay that's it for iterators let's look

00:11:12,520 --> 00:11:19,600
at another example and this is about

00:11:16,000 --> 00:11:23,050
pausing Jason because Jason is a very

00:11:19,600 --> 00:11:28,240
simple format you could say okay I don't

00:11:23,050 --> 00:11:31,000
have to do any complicated things maybe

00:11:28,240 --> 00:11:33,310
I don't know so you know there are 30

00:11:31,000 --> 00:11:35,620
Jason and you know it has a value type

00:11:33,310 --> 00:11:36,940
and you know if I have a string that

00:11:35,620 --> 00:11:40,330
looks like Jason I hope this is

00:11:36,940 --> 00:11:43,270
formatted correctly I can get a value

00:11:40,330 --> 00:11:46,300
out of it probably and if there is some

00:11:43,270 --> 00:11:47,080
value a that happens to be a number I

00:11:46,300 --> 00:11:51,730
can print it

00:11:47,080 --> 00:11:54,300
okay easy enough but next Monday arrives

00:11:51,730 --> 00:11:56,920
next requirements arrive and actually

00:11:54,300 --> 00:11:57,370
yes this structure actually has three

00:11:56,920 --> 00:12:00,670
fields

00:11:57,370 --> 00:12:03,310
and we need to deal with this and of

00:12:00,670 --> 00:12:05,200
course this is rust we know we can write

00:12:03,310 --> 00:12:08,440
data types so we write our structure

00:12:05,200 --> 00:12:12,279
called response and say this has three

00:12:08,440 --> 00:12:14,620
fields and so we continue to write our

00:12:12,279 --> 00:12:20,649
code as we've been doing it for the last

00:12:14,620 --> 00:12:22,890
week and the difference is that it got a

00:12:20,649 --> 00:12:25,990
bit longer

00:12:22,890 --> 00:12:28,270
yeah and it's basically all the same the

00:12:25,990 --> 00:12:32,940
only thing that changes is this

00:12:28,270 --> 00:12:34,480
character and then we have our response

00:12:32,940 --> 00:12:38,020
easy enough right

00:12:34,480 --> 00:12:40,000
but a bit boring okay this looks like

00:12:38,020 --> 00:12:42,130
it's pretty pretty repetitive and not

00:12:40,000 --> 00:12:46,120
specific to the actual problem we have

00:12:42,130 --> 00:12:48,850
that is dealing with our response Russ

00:12:46,120 --> 00:12:52,480
gives us a very neat feature and that is

00:12:48,850 --> 00:12:56,350
procedural macros and especially derive

00:12:52,480 --> 00:12:58,300
macros so as you may have seen in Sirte

00:12:56,350 --> 00:13:00,910
code you can just say derive to

00:12:58,300 --> 00:13:03,220
serialize and all this boilerplate codes

00:13:00,910 --> 00:13:06,220
is a repetitive piece of code that we've

00:13:03,220 --> 00:13:09,310
just seen gets generated and in fact

00:13:06,220 --> 00:13:12,130
this is same as a loop also faster

00:13:09,310 --> 00:13:14,380
because there is no value that needs to

00:13:12,130 --> 00:13:17,860
be allocated and filled with generic

00:13:14,380 --> 00:13:20,480
JSON data and it even has better errors

00:13:17,860 --> 00:13:22,820
too okay

00:13:20,480 --> 00:13:25,370
a bit of a pet peeve of mine this year

00:13:22,820 --> 00:13:27,889
has been command line applications so I

00:13:25,370 --> 00:13:31,310
couldn't go without writing or talking

00:13:27,889 --> 00:13:36,440
about command line arguments the core

00:13:31,310 --> 00:13:40,639
concept and so imagine you have programs

00:13:36,440 --> 00:13:42,019
that it's named tool for some reason

00:13:40,639 --> 00:13:46,190
because I'm bad at coming up with

00:13:42,019 --> 00:13:49,579
project names apparently and it takes an

00:13:46,190 --> 00:13:53,630
input file name and an output file name

00:13:49,579 --> 00:13:56,300
and it does some weird stuff with this

00:13:53,630 --> 00:14:00,110
file and rides it to the output cool

00:13:56,300 --> 00:14:03,199
that's easy using the standard library

00:14:00,110 --> 00:14:05,029
you can just say stood and arcs and I

00:14:03,199 --> 00:14:08,449
get an iterator over my command

00:14:05,029 --> 00:14:10,880
arguments the first one I choose is

00:14:08,449 --> 00:14:13,600
wrong I just realized the first one is

00:14:10,880 --> 00:14:16,970
actually the name tool but never mind

00:14:13,600 --> 00:14:19,070
the first one in this case in this very

00:14:16,970 --> 00:14:21,740
specific case where a stood and works

00:14:19,070 --> 00:14:26,630
differently is the input and the next

00:14:21,740 --> 00:14:29,510
one is the output cool you may have seen

00:14:26,630 --> 00:14:30,920
this pattern and let I'm now going to

00:14:29,510 --> 00:14:33,230
tell you that there are new requirements

00:14:30,920 --> 00:14:35,510
and two requirement is that this is not

00:14:33,230 --> 00:14:38,569
how command line tools should work they

00:14:35,510 --> 00:14:42,050
should also take flags like - OH -

00:14:38,569 --> 00:14:44,389
specify the output file but don't worry

00:14:42,050 --> 00:14:47,959
there's a crate for that it's called get

00:14:44,389 --> 00:14:50,779
out and it allows you to write some easy

00:14:47,959 --> 00:14:53,959
enough code so you can specify an opt

00:14:50,779 --> 00:14:56,990
opt whatever that is not an option I

00:14:53,959 --> 00:14:58,910
don't know but it's on opt and it's

00:14:56,990 --> 00:15:01,399
called oh and it sets your output file

00:14:58,910 --> 00:15:02,750
name this is from the documentation I'm

00:15:01,399 --> 00:15:07,639
not kidding

00:15:02,750 --> 00:15:10,279
and it's ok it works for this specific

00:15:07,639 --> 00:15:12,260
case and it's not that much code I

00:15:10,279 --> 00:15:17,389
teased a bit with the scrolling but it's

00:15:12,260 --> 00:15:20,089
it's ok you can do this so we may have

00:15:17,389 --> 00:15:23,990
to ask ourselves how much do you need to

00:15:20,089 --> 00:15:25,420
read it's ok how much you need to write

00:15:23,990 --> 00:15:29,329
to make a change

00:15:25,420 --> 00:15:31,850
actually this right get-ups has nice

00:15:29,329 --> 00:15:33,150
abstraction you can write many ourselves

00:15:31,850 --> 00:15:36,120
up tops and a

00:15:33,150 --> 00:15:41,190
opt thingies and you can basically build

00:15:36,120 --> 00:15:43,290
up your command line to it but how easy

00:15:41,190 --> 00:15:46,880
is it to reason about what's actually

00:15:43,290 --> 00:15:51,870
happening there I don't know it's a bit

00:15:46,880 --> 00:15:53,490
it's not very expressive but okay let's

00:15:51,870 --> 00:15:56,430
look at the NASA crate that also

00:15:53,490 --> 00:15:58,830
implements an abstraction over command

00:15:56,430 --> 00:16:03,230
line arguments which is called clap and

00:15:58,830 --> 00:16:08,310
you may have heard of it it gives you

00:16:03,230 --> 00:16:11,040
the possibility to write down what your

00:16:08,310 --> 00:16:14,340
application should look like basically

00:16:11,040 --> 00:16:18,150
it's there is a type hood app that's a

00:16:14,340 --> 00:16:21,720
type called arc and you can compose an

00:16:18,150 --> 00:16:24,660
app with arguments this also includes

00:16:21,720 --> 00:16:27,470
documentation and it's very very

00:16:24,660 --> 00:16:30,030
expressive because all this methods

00:16:27,470 --> 00:16:32,880
allow you to express precisely what you

00:16:30,030 --> 00:16:36,030
want your application to look like very

00:16:32,880 --> 00:16:37,710
nice if you run this with - - help you

00:16:36,030 --> 00:16:39,120
get a nice help message if you run it

00:16:37,710 --> 00:16:39,540
with - - version you get a version

00:16:39,120 --> 00:16:41,640
number

00:16:39,540 --> 00:16:44,160
this is abstracted right for you because

00:16:41,640 --> 00:16:48,690
it's always assignments you don't have

00:16:44,160 --> 00:16:54,170
to write this code by yourself but this

00:16:48,690 --> 00:16:56,970
too has one bit of an issue and that is

00:16:54,170 --> 00:17:01,680
similar to our days in case before now

00:16:56,970 --> 00:17:04,920
we're looking at some values of our

00:17:01,680 --> 00:17:07,350
arguments and we're going to deal with

00:17:04,920 --> 00:17:12,089
the data inside and we have to do this

00:17:07,350 --> 00:17:14,550
by ourselves interesting maybe we can do

00:17:12,089 --> 00:17:18,209
something similar - were studied it and

00:17:14,550 --> 00:17:19,880
yeah we can because isn't commands and

00:17:18,209 --> 00:17:23,430
arguments just to take the structure -

00:17:19,880 --> 00:17:25,980
in fact those library called struct up

00:17:23,430 --> 00:17:27,810
which you may have also heard of and it

00:17:25,980 --> 00:17:29,820
allows you to describe your command-line

00:17:27,810 --> 00:17:31,890
arguments as a structure and derive

00:17:29,820 --> 00:17:35,910
basically all the code we've seen before

00:17:31,890 --> 00:17:41,670
including using the documents for health

00:17:35,910 --> 00:17:43,680
messages ok ok I've talked quite a lot

00:17:41,670 --> 00:17:45,990
about procedural macros and derive

00:17:43,680 --> 00:17:46,820
macros but I also want to touch on

00:17:45,990 --> 00:17:49,190
another subject

00:17:46,820 --> 00:17:52,549
because this is not to talk about macros

00:17:49,190 --> 00:17:57,169
even though it may seem like it this is

00:17:52,549 --> 00:17:59,330
a talk about abstraction and this

00:17:57,169 --> 00:18:02,630
requires me to use the scary-looking

00:17:59,330 --> 00:18:05,690
headline I guess and to make this

00:18:02,630 --> 00:18:12,620
crescendo of increasing complexity an

00:18:05,690 --> 00:18:16,460
example it's usable and what I'm trying

00:18:12,620 --> 00:18:20,570
to get at is we write generic functions

00:18:16,460 --> 00:18:22,970
and our generic functions can use

00:18:20,570 --> 00:18:28,250
concrete types to declare what to do the

00:18:22,970 --> 00:18:32,059
walls a very nice example I've recently

00:18:28,250 --> 00:18:34,789
rediscovered so to say is in web

00:18:32,059 --> 00:18:39,500
frameworks I know there are many web

00:18:34,789 --> 00:18:42,379
frameworks also for us but let's imagine

00:18:39,500 --> 00:18:45,440
there is a very very generic one and a

00:18:42,379 --> 00:18:51,649
very simple one not generic in the scans

00:18:45,440 --> 00:18:53,149
and it's a framework where you specify a

00:18:51,649 --> 00:18:57,019
function that takes a request and

00:18:53,149 --> 00:19:00,980
returns a response simply enough and our

00:18:57,019 --> 00:19:03,110
request happens to contain a body of

00:19:00,980 --> 00:19:06,919
JSON data and we want to get in name

00:19:03,110 --> 00:19:08,299
filled out this looks like basically the

00:19:06,919 --> 00:19:11,269
same code we've seen in the earlier

00:19:08,299 --> 00:19:16,840
example except a few also choosing the

00:19:11,269 --> 00:19:21,080
name nobody if there is nobody okay so

00:19:16,840 --> 00:19:22,700
this is actually already quite good but

00:19:21,080 --> 00:19:26,059
you might be wondering if we've

00:19:22,700 --> 00:19:30,049
previously managed to get rid of this

00:19:26,059 --> 00:19:31,700
rising value may we can get rid of it in

00:19:30,049 --> 00:19:35,000
this case too

00:19:31,700 --> 00:19:40,039
and actually we can go one step further

00:19:35,000 --> 00:19:43,970
because C Rica's body doesn't have to be

00:19:40,039 --> 00:19:47,899
tracing for metal at all and that we are

00:19:43,970 --> 00:19:51,950
taking the Rica's body and dealing with

00:19:47,899 --> 00:19:53,600
it as if it were jason is something that

00:19:51,950 --> 00:19:57,620
we spent two lines about and actually

00:19:53,600 --> 00:19:59,539
maybe also a third line but we don't

00:19:57,620 --> 00:20:00,110
have to because our generic function

00:19:59,539 --> 00:20:03,490
could

00:20:00,110 --> 00:20:07,760
not only take a request but maybe also

00:20:03,490 --> 00:20:11,150
some other type that tells us what we

00:20:07,760 --> 00:20:14,990
actually want from our request and the

00:20:11,150 --> 00:20:18,470
idea is that this Jason type here is a

00:20:14,990 --> 00:20:20,840
type that implements for example a trade

00:20:18,470 --> 00:20:22,820
called from request and when our

00:20:20,840 --> 00:20:26,480
framework calls it it gives it a request

00:20:22,820 --> 00:20:30,230
and the type size okay this request I'm

00:20:26,480 --> 00:20:35,150
gonna pass of Jason and the login data

00:20:30,230 --> 00:20:38,000
type defines what kind of structure we

00:20:35,150 --> 00:20:40,450
wants us Jason to parse into this allows

00:20:38,000 --> 00:20:42,530
you to express what data you want

00:20:40,450 --> 00:20:43,760
extracted from the request without

00:20:42,530 --> 00:20:46,880
having to do it yourself

00:20:43,760 --> 00:20:50,330
and this also composes quite nicely

00:20:46,880 --> 00:20:53,960
because you can say I now have a type

00:20:50,330 --> 00:20:55,910
that is Jason or from data or I can have

00:20:53,960 --> 00:20:59,390
two types it's actually a tuple of a

00:20:55,910 --> 00:21:03,190
query string and Jason powered and maybe

00:20:59,390 --> 00:21:07,730
also the path of the URL this is

00:21:03,190 --> 00:21:11,140
something we should use more often this

00:21:07,730 --> 00:21:14,480
is it for examples but there's one more

00:21:11,140 --> 00:21:17,480
quite important topic I want to touch on

00:21:14,480 --> 00:21:21,049
and that is please be aware of the magic

00:21:17,480 --> 00:21:23,840
BJ of your code base and it turns out

00:21:21,049 --> 00:21:26,270
that and sufficiently high abstraction

00:21:23,840 --> 00:21:28,030
is indistinguishable from magic

00:21:26,270 --> 00:21:32,049
[Music]

00:21:28,030 --> 00:21:32,049
yeah and the next slide

00:21:41,090 --> 00:21:46,799
no I'm not going to touch on that so

00:21:43,830 --> 00:21:49,620
sorry let let's talk about what magic is

00:21:46,799 --> 00:21:54,120
actually in the scientific sense of

00:21:49,620 --> 00:21:57,059
course and let's define magic as code

00:21:54,120 --> 00:21:59,370
whose behavior is hard to predict or to

00:21:57,059 --> 00:22:02,900
remember because at least I am very

00:21:59,370 --> 00:22:05,610
forgetful like if you show me code and

00:22:02,900 --> 00:22:08,220
say I have written this like half a year

00:22:05,610 --> 00:22:11,610
ago I will have no idea what this is

00:22:08,220 --> 00:22:13,260
about so maybe it's also a good idea to

00:22:11,610 --> 00:22:15,780
write code that is so expressive that

00:22:13,260 --> 00:22:20,250
you don't have to remember it to make

00:22:15,780 --> 00:22:25,049
sense okay so what code could be hard to

00:22:20,250 --> 00:22:27,690
predict and familiar macros obviously

00:22:25,049 --> 00:22:30,780
people are a lot of people actually very

00:22:27,690 --> 00:22:36,450
fearful of using macros because they are

00:22:30,780 --> 00:22:38,970
magic this is a quote also very generic

00:22:36,450 --> 00:22:42,990
code and there are programming language

00:22:38,970 --> 00:22:45,540
that say okay it's a good idea to have

00:22:42,990 --> 00:22:48,660
generics but actually not in our use

00:22:45,540 --> 00:22:51,120
case and there's a very very solid

00:22:48,660 --> 00:22:54,500
argument because if you want to have

00:22:51,120 --> 00:22:58,080
correctable code that is easy to read

00:22:54,500 --> 00:23:00,150
that may not be as concise as you want

00:22:58,080 --> 00:23:04,169
it to be but that is easy to understand

00:23:00,150 --> 00:23:06,990
generics will probably hinder us but

00:23:04,169 --> 00:23:09,630
also like we've all been there like we

00:23:06,990 --> 00:23:11,309
have tried to write clever code but

00:23:09,630 --> 00:23:16,740
could you understand so clever code

00:23:11,309 --> 00:23:19,559
afterwards this is also magic and you

00:23:16,740 --> 00:23:21,780
can tell magic into science if you have

00:23:19,559 --> 00:23:25,169
the right tools for example if something

00:23:21,780 --> 00:23:28,830
like Iago expand will give you the

00:23:25,169 --> 00:23:31,679
output of what rust C will actually

00:23:28,830 --> 00:23:34,500
compile if it has expanded audio macros

00:23:31,679 --> 00:23:37,320
so for example this struct of example I

00:23:34,500 --> 00:23:40,590
gave you can paste it into your editor

00:23:37,320 --> 00:23:43,559
run cago expand and see how it generates

00:23:40,590 --> 00:23:45,059
clap code underneath codes that you

00:23:43,559 --> 00:23:46,890
didn't have to write but codes that will

00:23:45,059 --> 00:23:49,020
be there and codes that you can read if

00:23:46,890 --> 00:23:52,290
you want to

00:23:49,020 --> 00:23:54,840
sadly even the best tools will only move

00:23:52,290 --> 00:24:01,680
this complexity towards using the tool

00:23:54,840 --> 00:24:05,910
but not actually resolvers so I was

00:24:01,680 --> 00:24:10,500
wondering how can we be aware of this

00:24:05,910 --> 00:24:13,140
how can we come up with good ideas to

00:24:10,500 --> 00:24:14,670
write even more declarative and even

00:24:13,140 --> 00:24:18,600
more expressive and even more useful

00:24:14,670 --> 00:24:22,230
code and the next question obviously is

00:24:18,600 --> 00:24:24,180
how can we teach this how can we get a

00:24:22,230 --> 00:24:26,250
community to the point we are using

00:24:24,180 --> 00:24:27,120
iterators is so complex that you do not

00:24:26,250 --> 00:24:32,280
question it

00:24:27,120 --> 00:24:35,850
how can we use macros in a non-magical

00:24:32,280 --> 00:24:38,690
sense because they're our macros like

00:24:35,850 --> 00:24:41,550
Beck did you did you see I used the Veck

00:24:38,690 --> 00:24:44,070
macro now it doesn't really matter

00:24:41,550 --> 00:24:46,920
because it's very expressive you know

00:24:44,070 --> 00:24:49,950
the types come back the macros contract

00:24:46,920 --> 00:24:55,200
and to expect it to generate the vector

00:24:49,950 --> 00:25:00,870
this just works and so how can we

00:24:55,200 --> 00:25:04,530
actually teaches us so several

00:25:00,870 --> 00:25:06,840
approaches the first one is through

00:25:04,530 --> 00:25:08,700
interactive learning ya know it's the

00:25:06,840 --> 00:25:09,450
first this is an ambitious one applause

00:25:08,700 --> 00:25:13,080
I'm so sorry

00:25:09,450 --> 00:25:16,770
but I really like flippy lands and I

00:25:13,080 --> 00:25:19,050
know there was a lot of potential for

00:25:16,770 --> 00:25:23,070
writing even more clip islands for

00:25:19,050 --> 00:25:27,360
example there is one issue that happened

00:25:23,070 --> 00:25:30,540
to be open by me about linting for loops

00:25:27,360 --> 00:25:34,200
to suggest iterators for example this is

00:25:30,540 --> 00:25:35,640
the code snippet that uses any could

00:25:34,200 --> 00:25:37,830
have been a for loop with an if

00:25:35,640 --> 00:25:40,080
statement and the return Clippy code to

00:25:37,830 --> 00:25:44,720
texas and tell you hey if you want to

00:25:40,080 --> 00:25:44,720
write this in a more maybe

00:26:01,380 --> 00:27:31,680
you can already see okay yeah

00:27:38,730 --> 00:27:47,900
and I hope you've got some inspiration

00:27:43,200 --> 00:27:52,080
from it or at least some ideas on how to

00:27:47,900 --> 00:27:53,580
and maybe do something differently in

00:27:52,080 --> 00:28:10,310
your own code base or when you're

00:27:53,580 --> 00:28:13,590
writing code thank you so much okay

00:28:10,310 --> 00:28:27,300
thank you very much are the questions to

00:28:13,590 --> 00:28:29,490
Pascal do you think there is a conflict

00:28:27,300 --> 00:28:35,580
between declarative programming and the

00:28:29,490 --> 00:28:38,580
performance in memory consumption if I

00:28:35,580 --> 00:28:40,140
understood correctly performance

00:28:38,580 --> 00:28:44,220
implications of using declarative

00:28:40,140 --> 00:28:45,470
programming starts yes okay well it

00:28:44,220 --> 00:28:48,000
depends on what you're doing of course

00:28:45,470 --> 00:28:52,020
for example all the examples I showed

00:28:48,000 --> 00:28:54,330
using 30 and using iterators were

00:28:52,020 --> 00:28:58,500
actually faster because they did less

00:28:54,330 --> 00:29:00,330
work but writing this code manually in

00:28:58,500 --> 00:29:03,140
an imperative style would be very

00:29:00,330 --> 00:29:06,210
tedious you can of course do it and

00:29:03,140 --> 00:29:09,270
because on an assembly level everything

00:29:06,210 --> 00:29:13,110
is imperative you can optimize every

00:29:09,270 --> 00:29:17,400
program as an imperative level more

00:29:13,110 --> 00:29:20,360
rigorously than you would be able to if

00:29:17,400 --> 00:29:23,160
you have to trust some abstraction but I

00:29:20,360 --> 00:29:24,390
believe especially in rust we've managed

00:29:23,160 --> 00:29:27,000
to come up with some very good

00:29:24,390 --> 00:29:29,850
abstractions that boil down to being the

00:29:27,000 --> 00:29:33,680
exact same assembly as an imperative

00:29:29,850 --> 00:29:33,680
style for example using iterators

00:29:38,610 --> 00:29:50,440
any more questions it seems to me that

00:29:48,040 --> 00:29:53,530
sometimes declarative programming would

00:29:50,440 --> 00:29:55,330
almost require some additional magic for

00:29:53,530 --> 00:29:58,930
example when you did the take five and

00:29:55,330 --> 00:30:02,440
collect you know it's sort of it does

00:29:58,930 --> 00:30:04,690
say what to do and not how to do it but

00:30:02,440 --> 00:30:06,550
it's not sort of obvious what the

00:30:04,690 --> 00:30:08,710
resulting performance characteristics

00:30:06,550 --> 00:30:12,090
might be because you don't know how it

00:30:08,710 --> 00:30:16,120
accomplishes that task how do you

00:30:12,090 --> 00:30:20,470
performance - no it's fine

00:30:16,120 --> 00:30:23,050
the resulting performance you have to

00:30:20,470 --> 00:30:28,570
measure it to be very very certain of

00:30:23,050 --> 00:30:32,530
course but it happens to be the lazy to

00:30:28,570 --> 00:30:34,540
write as a very fast so in this case you

00:30:32,530 --> 00:30:37,990
will find that it's actually the same

00:30:34,540 --> 00:30:40,510
performance is writing volume and of

00:30:37,990 --> 00:30:44,020
course in the end you have to trust it

00:30:40,510 --> 00:30:48,580
or you have to measure it I'd always err

00:30:44,020 --> 00:30:50,740
on the side of measuring it but this

00:30:48,580 --> 00:30:54,280
magic you're talking about to make this

00:30:50,740 --> 00:31:03,070
fast is called rusty and we always

00:30:54,280 --> 00:31:15,040
already using it so yeah any more

00:31:03,070 --> 00:31:16,930
questions thank you for your talk you

00:31:15,040 --> 00:31:19,270
mentioned that sometimes you look at

00:31:16,930 --> 00:31:22,870
your old code and you wonder what you

00:31:19,270 --> 00:31:24,760
did there what are the measure what do

00:31:22,870 --> 00:31:26,950
you do then do you leave it like that or

00:31:24,760 --> 00:31:29,320
do you start rewriting it or are you

00:31:26,950 --> 00:31:35,370
putting memos for yourself for your

00:31:29,320 --> 00:31:35,370
future self do this better next time

00:31:37,440 --> 00:31:44,140
depends on when I wrote the code I

00:31:41,100 --> 00:31:46,150
started writing good commit messages at

00:31:44,140 --> 00:31:48,760
some point I realized that I couldn't

00:31:46,150 --> 00:31:50,970
remember what I wanted to do so I look

00:31:48,760 --> 00:31:56,140
at my commit messages and say oh yeah

00:31:50,970 --> 00:31:59,370
this what's what okay it works some of

00:31:56,140 --> 00:32:02,290
the time but you're right

00:31:59,370 --> 00:32:07,420
basically I have to read it I have to

00:32:02,290 --> 00:32:09,730
understand it and have to guess and this

00:32:07,420 --> 00:32:12,820
is the same for my own code as for

00:32:09,730 --> 00:32:14,679
everyone else's making better guesses

00:32:12,820 --> 00:32:17,050
and being more confident that these

00:32:14,679 --> 00:32:20,980
guesses about expected behavior are what

00:32:17,050 --> 00:32:22,960
you wanted to have is one of the

00:32:20,980 --> 00:32:25,330
advantages of having declarative code in

00:32:22,960 --> 00:32:31,179
my opinions but also read could commit

00:32:25,330 --> 00:32:36,120
messages all right

00:32:31,179 --> 00:32:36,120

YouTube URL: https://www.youtube.com/watch?v=0W20GPEqbcU


