Title: RustFest Rome 2018 -  Igor Matuszewski: Caging the SpiderMonkey - Ensuring safe JS bindings in Servo
Publication date: 2018-11-24
Playlist: RustFest Rome 2018
Description: 
	This talk will focus on some of the challenges encountered while working on integrating SpiderMonkey JavaScript engine with the Servo web browser engine (written in C++ and Rust, respectively). We will explore how Rust's rich type system made it possible to enforce many Servoâ€“SpiderMonkey interface rules and safety considerations at compile time and how a custom compiler plugin was developed to verify against project-specific errors at a language level.

https://rome.rustfest.eu/sessions/caging-the-spidermonkey
https://media.ccc.de/v/rustfest-rome-2-caging-the-spidermonkey
Captions: 
	00:00:05,040 --> 00:00:09,840
[Applause]

00:00:07,100 --> 00:00:11,700
sorry about the technical difficulties

00:00:09,840 --> 00:00:13,709
my name is digger Matthew chef Sookie

00:00:11,700 --> 00:00:16,049
and I'm a major or they are less however

00:00:13,709 --> 00:00:20,640
today I'd like to talk about something

00:00:16,049 --> 00:00:22,830
different which is integration server

00:00:20,640 --> 00:00:25,519
SpiderMonkey integration that I did as

00:00:22,830 --> 00:00:28,499
part of my bachelor thesis group project

00:00:25,519 --> 00:00:32,160
so this is the official poster pretty

00:00:28,499 --> 00:00:34,079
neat about my friend of mine and here

00:00:32,160 --> 00:00:35,340
I'd like to thank my colleagues we for

00:00:34,079 --> 00:00:37,800
my work on this project

00:00:35,340 --> 00:00:40,560
their names are listed below and also to

00:00:37,800 --> 00:00:48,990
Josh Mathews from the server team that

00:00:40,560 --> 00:00:51,690
was kind enough to be our mentor the aim

00:00:48,990 --> 00:00:53,070
of this tag is twofold the first one is

00:00:51,690 --> 00:00:55,440
to provide some insight into

00:00:53,070 --> 00:00:57,690
SpiderMonkey interns and its challenges

00:00:55,440 --> 00:01:00,480
and the second one is to explore how

00:00:57,690 --> 00:01:03,870
rust actually made the integration safer

00:01:00,480 --> 00:01:06,479
in the process so first I will introduce

00:01:03,870 --> 00:01:08,610
served when SpiderMonkey what it is and

00:01:06,479 --> 00:01:11,429
how garbage collection comes into play

00:01:08,610 --> 00:01:13,350
then we'll delve deeply deeper into

00:01:11,429 --> 00:01:15,960
garbage collection concerns and types

00:01:13,350 --> 00:01:18,090
that encapsulate them and finally we'll

00:01:15,960 --> 00:01:23,549
talk briefly about compiler plugin that

00:01:18,090 --> 00:01:24,929
helps us verify our custom logic so

00:01:23,549 --> 00:01:27,359
chances are you've probably heard about

00:01:24,929 --> 00:01:29,819
servo this is an experimental browser

00:01:27,359 --> 00:01:31,799
engine that's written in rust and it

00:01:29,819 --> 00:01:34,920
actually managed to bring some key tech

00:01:31,799 --> 00:01:37,859
components back to Firefox most notably

00:01:34,920 --> 00:01:41,880
stylo which is a CSS engine that's

00:01:37,859 --> 00:01:44,340
written in rust but pro-ukraine probably

00:01:41,880 --> 00:01:46,490
have not heard about SpiderMonkey which

00:01:44,340 --> 00:01:50,009
is a JavaScript engine that's written in

00:01:46,490 --> 00:01:54,990
C++ and right now with powers both servo

00:01:50,009 --> 00:01:57,600
and sorry servo and Firefox itself so

00:01:54,990 --> 00:02:00,389
the main reason we use rust is because

00:01:57,600 --> 00:02:02,399
it's memory safe so the question is the

00:02:00,389 --> 00:02:04,799
natural one when we sacrifice that

00:02:02,399 --> 00:02:07,409
memory safety when we integrate with C++

00:02:04,799 --> 00:02:09,810
library well it turns out we don't have

00:02:07,409 --> 00:02:12,060
to it is possible to doing and to encode

00:02:09,810 --> 00:02:13,100
any of the integration variants within

00:02:12,060 --> 00:02:17,330
rust type system

00:02:13,100 --> 00:02:19,360
alone now let's take a high-level

00:02:17,330 --> 00:02:22,520
overview on how the integration works

00:02:19,360 --> 00:02:24,620
now javascript was designed to interact

00:02:22,520 --> 00:02:27,980
with web browser although nowadays

00:02:24,620 --> 00:02:30,230
doesn't seem to care but it split so

00:02:27,980 --> 00:02:32,960
this means that web browsers exposed

00:02:30,230 --> 00:02:35,960
JavaScript interface that can be used to

00:02:32,960 --> 00:02:38,390
interact with them so let's take a look

00:02:35,960 --> 00:02:39,970
at a simple example of how flow of

00:02:38,390 --> 00:02:43,370
information may look like

00:02:39,970 --> 00:02:45,770
so imagine servo is given an HTML

00:02:43,370 --> 00:02:49,130
document that is given that is about to

00:02:45,770 --> 00:02:51,680
process so what it does is it extracts

00:02:49,130 --> 00:02:54,470
the script then it passes that script

00:02:51,680 --> 00:02:57,620
for evaluation to SpiderMonkey which

00:02:54,470 --> 00:02:59,930
does just that and then full circle back

00:02:57,620 --> 00:03:03,140
for every browser API call

00:02:59,930 --> 00:03:06,500
in this example console dot log after

00:03:03,140 --> 00:03:08,960
that server executes its internal logic

00:03:06,500 --> 00:03:13,370
and finally in this case prints a simple

00:03:08,960 --> 00:03:15,320
string on a console ok so let's talk

00:03:13,370 --> 00:03:18,080
about how garbage collection comes into

00:03:15,320 --> 00:03:20,690
play now JavaScript was designed as a

00:03:18,080 --> 00:03:22,730
dynamic language and in language as

00:03:20,690 --> 00:03:24,950
dynamic is that we can create objects

00:03:22,730 --> 00:03:28,490
left and right nest them in various

00:03:24,950 --> 00:03:30,260
hierarchies even cycles while the

00:03:28,490 --> 00:03:32,600
references to the objects must must

00:03:30,260 --> 00:03:34,550
still remain valid and we obviously can

00:03:32,600 --> 00:03:38,270
link memory for obvious performance

00:03:34,550 --> 00:03:41,450
reasons thus we must employ some form of

00:03:38,270 --> 00:03:43,070
automatic memory management this means

00:03:41,450 --> 00:03:45,440
that we don't have to worry about

00:03:43,070 --> 00:03:47,420
borrowed checker right we don't have to

00:03:45,440 --> 00:03:51,260
annotate our objects with lifetimes

00:03:47,420 --> 00:03:53,810
so it's all good but as it turns out

00:03:51,260 --> 00:03:56,780
maybe not so much because it is costly

00:03:53,810 --> 00:03:59,150
it's more complicated to do and incur

00:03:56,780 --> 00:04:02,960
some runtime overhead any sacrifice

00:03:59,150 --> 00:04:05,330
determinism in the process so in general

00:04:02,960 --> 00:04:06,890
there are many ways to do it garbage

00:04:05,330 --> 00:04:08,720
collection and their different

00:04:06,890 --> 00:04:12,560
algorithms and they can differ on

00:04:08,720 --> 00:04:12,980
various axes so we'll go into that in a

00:04:12,560 --> 00:04:15,290
moment

00:04:12,980 --> 00:04:17,359
but in our case spider monkey has a

00:04:15,290 --> 00:04:19,400
tracing garbage collector with

00:04:17,359 --> 00:04:22,760
incremental marking generational

00:04:19,400 --> 00:04:25,669
collection and compaction and while this

00:04:22,760 --> 00:04:26,250
dot while this does not tell us much

00:04:25,669 --> 00:04:28,320
like

00:04:26,250 --> 00:04:32,520
we'll try to go over through some of

00:04:28,320 --> 00:04:33,960
those as we go so first it will be good

00:04:32,520 --> 00:04:36,480
to define where the tracing garbage

00:04:33,960 --> 00:04:38,430
collector is so a tracing garbage

00:04:36,480 --> 00:04:40,560
collector what it does is it determines

00:04:38,430 --> 00:04:42,510
that an object is alive

00:04:40,560 --> 00:04:45,060
whether it is reachable by a chain of

00:04:42,510 --> 00:04:47,400
references to a certain set of root

00:04:45,060 --> 00:04:49,200
objects and the rest that are not

00:04:47,400 --> 00:04:54,510
reachable in this matter are treated as

00:04:49,200 --> 00:04:56,340
garbage and collected there are two ways

00:04:54,510 --> 00:04:58,560
most notably two ways to attain and

00:04:56,340 --> 00:05:01,110
identify those suit objects the first

00:04:58,560 --> 00:05:03,510
one is using stack Maps which is where

00:05:01,110 --> 00:05:05,850
the compiler emits specific metadata

00:05:03,510 --> 00:05:08,190
about each stack frame so then during

00:05:05,850 --> 00:05:10,620
the collection phase that can walk the

00:05:08,190 --> 00:05:13,560
stack and it can identify any GC pointer

00:05:10,620 --> 00:05:15,720
there well the other case is when the

00:05:13,560 --> 00:05:18,240
runtime maintains a dynamic collection

00:05:15,720 --> 00:05:20,520
of active roots so whenever we want to

00:05:18,240 --> 00:05:22,940
route an object we have to add a route

00:05:20,520 --> 00:05:25,470
to that collection

00:05:22,940 --> 00:05:28,050
SpiderMonkey uses the ladder which is a

00:05:25,470 --> 00:05:31,950
global stack of pointers to the rooted

00:05:28,050 --> 00:05:34,410
objects and to maintain that it actually

00:05:31,950 --> 00:05:37,080
introduces a stack allocated wrapper

00:05:34,410 --> 00:05:40,260
value that is capable of routing some

00:05:37,080 --> 00:05:45,240
sort of some set of primitive GC managed

00:05:40,260 --> 00:05:47,910
pointers some of them are listed here so

00:05:45,240 --> 00:05:50,729
it basically follows an rai pattern on

00:05:47,910 --> 00:05:53,340
construction it adds a DES pointer that

00:05:50,729 --> 00:05:56,820
it wraps around to the collection and on

00:05:53,340 --> 00:05:58,950
destruction it pops it up and it is

00:05:56,820 --> 00:06:01,500
common to implement these route

00:05:58,950 --> 00:06:03,690
collection as a linked list however it

00:06:01,500 --> 00:06:06,210
is worth noting that using a stack

00:06:03,690 --> 00:06:09,450
allocated value such as this the order

00:06:06,210 --> 00:06:11,580
of destruction will be in there will be

00:06:09,450 --> 00:06:14,400
reverse with relation to the order of

00:06:11,580 --> 00:06:17,430
initiation of those objects therefore we

00:06:14,400 --> 00:06:20,910
actually form a perfect stack so how it

00:06:17,430 --> 00:06:22,830
actually works is on construction we add

00:06:20,910 --> 00:06:25,860
the pointer to ourselves to the routing

00:06:22,830 --> 00:06:27,310
collection and we only need to store the

00:06:25,860 --> 00:06:29,620
previous value that was

00:06:27,310 --> 00:06:31,630
at the top of the stack and on

00:06:29,620 --> 00:06:33,790
destruction we only need to replace the

00:06:31,630 --> 00:06:34,810
current stack top with the previously

00:06:33,790 --> 00:06:37,450
cached values

00:06:34,810 --> 00:06:41,200
thus logically popping ourselves off the

00:06:37,450 --> 00:06:43,420
stack however it is sometimes

00:06:41,200 --> 00:06:45,190
undesirable to use that type for

00:06:43,420 --> 00:06:47,800
performance reasons or it's just

00:06:45,190 --> 00:06:49,570
straight-out impossible to use and to

00:06:47,800 --> 00:06:52,240
work around that another type is used

00:06:49,570 --> 00:06:54,730
and in this example this type is called

00:06:52,240 --> 00:06:56,440
Auto GC ruler so in spirit it is very

00:06:54,730 --> 00:06:59,230
similar to the previous type that I

00:06:56,440 --> 00:07:00,850
mentioned it uses the same global stack

00:06:59,230 --> 00:07:04,540
approach however it can't raise

00:07:00,850 --> 00:07:08,610
different things it is internally intact

00:07:04,540 --> 00:07:11,460
just like imagine it's like in rust enum

00:07:08,610 --> 00:07:15,040
that executes a different trace function

00:07:11,460 --> 00:07:17,650
depending on the type of the tag so for

00:07:15,040 --> 00:07:20,950
example it is capable of tracing a fixed

00:07:17,650 --> 00:07:23,200
length array of objects and it does that

00:07:20,950 --> 00:07:25,600
by using the type order array ruler

00:07:23,200 --> 00:07:28,090
which is a wrap around the outer GC

00:07:25,600 --> 00:07:30,390
ruler with a tag array and we can see

00:07:28,090 --> 00:07:33,760
how this is better than just using the

00:07:30,390 --> 00:07:35,800
Rooter wrappers before imagine we have a

00:07:33,760 --> 00:07:37,600
collection of multiple elements and

00:07:35,800 --> 00:07:41,440
previously would have to instantiate

00:07:37,600 --> 00:07:44,560
every rapper help type for every element

00:07:41,440 --> 00:07:47,320
and is structured itself while this is a

00:07:44,560 --> 00:07:50,290
constant time operation still it is

00:07:47,320 --> 00:07:52,690
actually more performant it stacks up so

00:07:50,290 --> 00:07:55,090
in this case we only add ourselves to

00:07:52,690 --> 00:07:58,290
stack once and with this we are able to

00:07:55,090 --> 00:08:00,880
trace through the entire collection

00:07:58,290 --> 00:08:02,620
another use case is to provide an

00:08:00,880 --> 00:08:05,470
extension point to the routing

00:08:02,620 --> 00:08:08,170
infrastructure there is a custom outer

00:08:05,470 --> 00:08:10,840
looter type with a custom tag that is

00:08:08,170 --> 00:08:12,670
actually virtually dispatched on

00:08:10,840 --> 00:08:16,180
dynamically dispatched on using the

00:08:12,670 --> 00:08:18,880
virtual trace function so it is

00:08:16,180 --> 00:08:23,140
convenient because in C++ what you can

00:08:18,880 --> 00:08:25,630
do is you can derive from the customary

00:08:23,140 --> 00:08:27,790
database class and an override the trace

00:08:25,630 --> 00:08:30,310
function yourself and with this

00:08:27,790 --> 00:08:32,860
instantly you will be registered in in

00:08:30,310 --> 00:08:34,870
the infrastructure that can still

00:08:32,860 --> 00:08:38,159
provide our own custom logic through the

00:08:34,870 --> 00:08:41,069
through this polymorphic function

00:08:38,159 --> 00:08:43,050
so being able to trace custom objects is

00:08:41,069 --> 00:08:47,750
very useful especially for a server

00:08:43,050 --> 00:08:50,940
which may not have access to typical C++

00:08:47,750 --> 00:08:54,959
manatees that are on the SpiderMonkey

00:08:50,940 --> 00:08:57,480
side so this will be our goal we want to

00:08:54,959 --> 00:08:59,279
create custom rooters and rust but still

00:08:57,480 --> 00:09:01,829
hook up into the dynamic tracing

00:08:59,279 --> 00:09:04,800
infrastructure that's over in C++ in

00:09:01,829 --> 00:09:07,680
SpiderMonkey but this is not as easy as

00:09:04,800 --> 00:09:11,819
it sounds we can actually very easily

00:09:07,680 --> 00:09:14,310
interact with C F Fi and rust but not as

00:09:11,819 --> 00:09:16,970
much when it comes to inherent C++

00:09:14,310 --> 00:09:20,339
semantics at a spiritual dispatch

00:09:16,970 --> 00:09:22,529
but server already uses bhaijan to

00:09:20,339 --> 00:09:24,240
create rust bindings to the spider

00:09:22,529 --> 00:09:26,819
monkey and it is capable of

00:09:24,240 --> 00:09:29,060
understanding some of the C++ so you may

00:09:26,819 --> 00:09:33,029
actually use that and try and emulate

00:09:29,060 --> 00:09:35,189
simple as plus polymorphism and rust so

00:09:33,029 --> 00:09:37,560
our goal is to create an object and rust

00:09:35,189 --> 00:09:41,670
and set it up so that the virtual

00:09:37,560 --> 00:09:44,430
function table is as expected by the C++

00:09:41,670 --> 00:09:46,290
side so on the left side we have a

00:09:44,430 --> 00:09:48,029
couple of definitions on the left side

00:09:46,290 --> 00:09:50,819
there's a simplified definition of the

00:09:48,029 --> 00:09:52,949
customer reader class and on the right

00:09:50,819 --> 00:09:55,290
side this is a corresponding structured

00:09:52,949 --> 00:09:58,050
data definition that's generated by bind

00:09:55,290 --> 00:10:00,149
gen we can also see that binding was

00:09:58,050 --> 00:10:03,389
capable of converting the implicit

00:10:00,149 --> 00:10:06,300
virtual function table that's in C++

00:10:03,389 --> 00:10:09,300
here we can see the trace function that

00:10:06,300 --> 00:10:10,920
corresponds to a simple function pointer

00:10:09,300 --> 00:10:15,569
and the V if they will ask created by

00:10:10,920 --> 00:10:18,480
binding so actually to implement this we

00:10:15,569 --> 00:10:21,870
define a special trait that aims to be

00:10:18,480 --> 00:10:25,559
to act just sort of a like custom out of

00:10:21,870 --> 00:10:27,509
lured base class and to do this we use a

00:10:25,559 --> 00:10:30,600
trick with an associated constant in a

00:10:27,509 --> 00:10:33,860
trait so the basic idea is to create a

00:10:30,600 --> 00:10:36,329
constant give table with explicitly

00:10:33,860 --> 00:10:39,180
instantiated pointers and in this case

00:10:36,329 --> 00:10:42,120
we initialize the corner to our rust

00:10:39,180 --> 00:10:44,360
method that's still unsaved an extern C

00:10:42,120 --> 00:10:47,399
because it directly interfaces with C

00:10:44,360 --> 00:10:49,199
however what it does is it fills us a

00:10:47,399 --> 00:10:50,700
bit with the implicit this pointer and

00:10:49,199 --> 00:10:53,910
what it does next is

00:10:50,700 --> 00:10:56,760
it calls the regular rust rate travÃ©s

00:10:53,910 --> 00:10:58,890
function and you can see here that this

00:10:56,760 --> 00:11:01,170
is just a regular self reference as you

00:10:58,890 --> 00:11:04,200
would expect in any rust go to their

00:11:01,170 --> 00:11:06,000
streets so the only thing that we need

00:11:04,200 --> 00:11:08,790
to do now is to implement this straight

00:11:06,000 --> 00:11:13,260
for the for a custom auto Rooter wrapper

00:11:08,790 --> 00:11:16,620
type and the interesting bit here is

00:11:13,260 --> 00:11:19,530
this we actually construct the object

00:11:16,620 --> 00:11:21,420
using the data layout that's generated

00:11:19,530 --> 00:11:23,940
by bind gen but here we actually

00:11:21,420 --> 00:11:27,510
instantiate the pointer to a v8 table

00:11:23,940 --> 00:11:30,690
just like in C++ to our associative

00:11:27,510 --> 00:11:32,700
constant and with this this is done just

00:11:30,690 --> 00:11:34,470
like in C++ where objects have an

00:11:32,700 --> 00:11:38,820
implicit pointer to virtual function

00:11:34,470 --> 00:11:41,190
tables and in this case when C++ will do

00:11:38,820 --> 00:11:42,960
a virtual dispatch it will go through

00:11:41,190 --> 00:11:48,810
this virtual function table that we

00:11:42,960 --> 00:11:51,360
defined over to our rust method but okay

00:11:48,810 --> 00:11:54,510
we fed our foundry to aviv tables and

00:11:51,360 --> 00:11:55,770
this actually works I can assure you but

00:11:54,510 --> 00:11:58,890
we actually need to route the data

00:11:55,770 --> 00:12:01,410
that's the part that's the whole point

00:11:58,890 --> 00:12:03,690
of it right so we cannot there's one

00:12:01,410 --> 00:12:06,480
problem we cannot directly translate the

00:12:03,690 --> 00:12:10,260
C++ semantics because C++ has

00:12:06,480 --> 00:12:13,290
constructors while rust does not so how

00:12:10,260 --> 00:12:15,390
it differs is C++ when it goes

00:12:13,290 --> 00:12:18,090
constructors it first allocates the

00:12:15,390 --> 00:12:19,890
memory where the object will be stored

00:12:18,090 --> 00:12:22,530
at and then it calls the constructor

00:12:19,890 --> 00:12:25,980
with the implicit this pointer pointing

00:12:22,530 --> 00:12:28,980
to that area that region of memory where

00:12:25,980 --> 00:12:30,570
the object will reside and rust we

00:12:28,980 --> 00:12:32,460
cannot do that we can only directly

00:12:30,570 --> 00:12:34,260
initialize values there is no way to

00:12:32,460 --> 00:12:39,420
insert any special hook when

00:12:34,260 --> 00:12:41,220
constructing the data so when we

00:12:39,420 --> 00:12:44,310
actually execute the constructors this

00:12:41,220 --> 00:12:46,590
is what allows us to economically insert

00:12:44,310 --> 00:12:50,100
the pointer to ourselves to direct route

00:12:46,590 --> 00:12:52,920
our value in a first place so our

00:12:50,100 --> 00:12:56,550
solution is to mimic stood sink musics

00:12:52,920 --> 00:12:59,550
API such that we'll have our custom

00:12:56,550 --> 00:13:01,050
outer neuter type which only we'll be

00:12:59,550 --> 00:13:04,260
wrapping around the

00:13:01,050 --> 00:13:06,269
it's object but we also have a custom

00:13:04,260 --> 00:13:09,000
out of regard type which serve as this

00:13:06,269 --> 00:13:11,310
in a safe reference type that internally

00:13:09,000 --> 00:13:15,029
borrows the underlying customer inner

00:13:11,310 --> 00:13:16,500
wrapper type so on top we have the

00:13:15,029 --> 00:13:19,040
simple definition for the customer

00:13:16,500 --> 00:13:22,560
reader in rust its rep receive and

00:13:19,040 --> 00:13:26,010
because it has the layout as expected by

00:13:22,560 --> 00:13:29,610
C++ and on the bottom we have a simple

00:13:26,010 --> 00:13:34,350
rust method for route that constructs

00:13:29,610 --> 00:13:36,810
the helper structure how our helper

00:13:34,350 --> 00:13:40,380
sorry our helper view structure that

00:13:36,810 --> 00:13:42,660
internally Boris ourselves so as long as

00:13:40,380 --> 00:13:44,880
this reference structure exists we

00:13:42,660 --> 00:13:47,399
cannot move the underlying data and

00:13:44,880 --> 00:13:49,680
memory and that's extremely important

00:13:47,399 --> 00:13:52,980
because when we add pointers to

00:13:49,680 --> 00:13:54,959
ourselves into the route stack we cannot

00:13:52,980 --> 00:13:57,329
move the pointer so I mean we cannot

00:13:54,959 --> 00:14:00,180
move the data around while the pointers

00:13:57,329 --> 00:14:02,970
are still registered and the global

00:14:00,180 --> 00:14:05,279
rootstock if we do that and we create

00:14:02,970 --> 00:14:08,240
dangling pointer then when the collector

00:14:05,279 --> 00:14:10,620
goes through the routes it will

00:14:08,240 --> 00:14:15,050
encounter a dangling pardon sure it

00:14:10,620 --> 00:14:15,050
crash so will violate memory safety here

00:14:15,170 --> 00:14:20,670
during you can see that during the

00:14:18,149 --> 00:14:22,860
construction we first use the unsafe

00:14:20,670 --> 00:14:26,310
function that registers the underlying

00:14:22,860 --> 00:14:28,320
raw pointer to the root stack and then

00:14:26,310 --> 00:14:30,390
we create this safe reference structure

00:14:28,320 --> 00:14:32,760
that actually internally borrows the

00:14:30,390 --> 00:14:34,740
underlying data and we can imagine drop

00:14:32,760 --> 00:14:37,110
is very similar I'll drop we call an

00:14:34,740 --> 00:14:39,480
same function that the reader that the

00:14:37,110 --> 00:14:44,209
registers are pointer from the read

00:14:39,480 --> 00:14:48,270
stack so a moveable types as this is an

00:14:44,209 --> 00:14:52,410
actual precise nice nice use case for

00:14:48,270 --> 00:14:54,600
pin racket types but the problem is we

00:14:52,410 --> 00:14:57,449
did this when the pin type was not

00:14:54,600 --> 00:15:01,800
worked on so we actually used the simple

00:14:57,449 --> 00:15:03,660
for a work round instead originally

00:15:01,800 --> 00:15:05,220
server wanted to support the custom

00:15:03,660 --> 00:15:07,199
outer Rudra infrastructure to use

00:15:05,220 --> 00:15:10,860
another type called second sequence

00:15:07,199 --> 00:15:12,180
ruler however the type on its own was

00:15:10,860 --> 00:15:16,320
not pretty on a citas

00:15:12,180 --> 00:15:18,240
site two routes generic global

00:15:16,320 --> 00:15:22,260
collection its use twelve different

00:15:18,240 --> 00:15:25,800
template instantiations so that's not

00:15:22,260 --> 00:15:28,220
really that's not strong right but

00:15:25,800 --> 00:15:30,690
thanks how to rust rates compose this is

00:15:28,220 --> 00:15:32,310
equivalent to those two trade

00:15:30,690 --> 00:15:34,080
implementations which is the

00:15:32,310 --> 00:15:37,080
implementation of tracing for option T

00:15:34,080 --> 00:15:39,839
and vector of T where you can actually

00:15:37,080 --> 00:15:42,000
implement the tracing logic for the

00:15:39,839 --> 00:15:44,459
generic element so at this point

00:15:42,000 --> 00:15:50,250
sequence Rudra basically boils down to a

00:15:44,459 --> 00:15:53,610
simple type alias now let's talk about

00:15:50,250 --> 00:15:57,060
write barriers so what is the write

00:15:53,610 --> 00:15:59,490
barrier in general barriers are a piece

00:15:57,060 --> 00:16:02,160
of logic that's executed to synchronize

00:15:59,490 --> 00:16:04,860
some internal state and in our case

00:16:02,160 --> 00:16:08,700
write barriers are exactly this but

00:16:04,860 --> 00:16:10,709
executed at the moment of write to an

00:16:08,700 --> 00:16:13,260
address that contains a GC managed

00:16:10,709 --> 00:16:15,540
reference and it is needed to maintain

00:16:13,260 --> 00:16:18,959
specific invariants for different kinds

00:16:15,540 --> 00:16:21,060
of garbage collections in fact we need

00:16:18,959 --> 00:16:23,580
quite three barriers for incremental

00:16:21,060 --> 00:16:25,560
marking and write post barriers for

00:16:23,580 --> 00:16:28,650
generational collection post barrier

00:16:25,560 --> 00:16:32,220
meaning we execute the logic after we do

00:16:28,650 --> 00:16:35,040
the right but currently server does not

00:16:32,220 --> 00:16:36,390
support the incremental marketing so

00:16:35,040 --> 00:16:39,180
we'll focus on the latter which is a

00:16:36,390 --> 00:16:42,089
generational collection but first a bit

00:16:39,180 --> 00:16:43,709
more about that and in practice it has

00:16:42,089 --> 00:16:46,709
been observed that most of the objects

00:16:43,709 --> 00:16:47,880
that are created are short-lived so what

00:16:46,709 --> 00:16:50,730
we can actually do with this knowledge

00:16:47,880 --> 00:16:53,220
as we can optimize our collection in

00:16:50,730 --> 00:16:55,440
SpiderMonkey we split we split the heap

00:16:53,220 --> 00:16:57,720
and two two and two nursery heap bandit

00:16:55,440 --> 00:17:00,300
anarchy and nursery heap is where the

00:16:57,720 --> 00:17:02,760
objects were the freshly allocated

00:17:00,300 --> 00:17:05,790
objects end up while the tenured heap is

00:17:02,760 --> 00:17:09,839
when the objects are moved to when these

00:17:05,790 --> 00:17:12,600
survive a collector pass this allows us

00:17:09,839 --> 00:17:15,449
to improve the collection phase by

00:17:12,600 --> 00:17:17,850
scanning only the nursery heap however

00:17:15,449 --> 00:17:20,490
there's a slight problem with that what

00:17:17,850 --> 00:17:24,839
if a tenured object points to an object

00:17:20,490 --> 00:17:25,600
and the nursery heap well we can imagine

00:17:24,839 --> 00:17:28,419
that this blows

00:17:25,600 --> 00:17:30,610
because when we can only scan the

00:17:28,419 --> 00:17:32,740
nursery can collect an object that's not

00:17:30,610 --> 00:17:35,500
referred there however it is still being

00:17:32,740 --> 00:17:39,520
pointed to from an object in the Tanyard

00:17:35,500 --> 00:17:42,789
key so the solution to that is that we

00:17:39,520 --> 00:17:45,000
want to track the pointers the values

00:17:42,789 --> 00:17:51,030
that are pointed to from the tenure heap

00:17:45,000 --> 00:17:54,130
that we sorry we want to keep track of

00:17:51,030 --> 00:17:57,669
the pointed to reference values in the

00:17:54,130 --> 00:17:58,990
nursery from the trainer key so in rust

00:17:57,669 --> 00:18:01,720
we'll do it as follows

00:17:58,990 --> 00:18:03,490
will create a GC method straight that

00:18:01,720 --> 00:18:06,309
aims to encapsulate all those white

00:18:03,490 --> 00:18:09,190
barriers concerns and we will then

00:18:06,309 --> 00:18:12,100
implement this for every row of GC

00:18:09,190 --> 00:18:14,049
matters pointer in this case it's worth

00:18:12,100 --> 00:18:17,590
noting that we have a post barrier

00:18:14,049 --> 00:18:20,470
method which takes an address where the

00:18:17,590 --> 00:18:22,360
reference was changed the value of the

00:18:20,470 --> 00:18:23,919
previous reference as well as the new

00:18:22,360 --> 00:18:27,039
one which allows us to successfully

00:18:23,919 --> 00:18:29,620
factor changes and for example in the

00:18:27,039 --> 00:18:32,980
case of just regular JS object we

00:18:29,620 --> 00:18:37,000
execute specific SpiderMonkey capi just

00:18:32,980 --> 00:18:39,730
like below but because of our write

00:18:37,000 --> 00:18:42,100
barrier we require every mutation to go

00:18:39,730 --> 00:18:45,460
through our specific set method called

00:18:42,100 --> 00:18:47,919
well set essentially the post barrier

00:18:45,460 --> 00:18:52,270
records the change of value at a given

00:18:47,919 --> 00:18:55,030
address as you can see here we invoke

00:18:52,270 --> 00:18:59,289
the post barrier method for the GC

00:18:55,030 --> 00:19:01,929
methods 70 now for the logic to be sound

00:18:59,289 --> 00:19:04,690
we also need to do the same during the

00:19:01,929 --> 00:19:05,740
drop execution well the heat preference

00:19:04,690 --> 00:19:08,080
goes out of scope

00:19:05,740 --> 00:19:11,110
SpiderMonkey will not know that the

00:19:08,080 --> 00:19:13,390
valley was validated now and it does not

00:19:11,110 --> 00:19:16,120
point to anything so what we need to do

00:19:13,390 --> 00:19:19,120
is we implicitly informed SpiderMonkey

00:19:16,120 --> 00:19:20,919
that the value was set to let's see a

00:19:19,120 --> 00:19:22,740
null pointer this clears reference to

00:19:20,919 --> 00:19:25,890
any valid pointer that we may have

00:19:22,740 --> 00:19:28,570
previously pointed to you

00:19:25,890 --> 00:19:30,760
similarly to routing SpiderMonkey

00:19:28,570 --> 00:19:32,890
requires for barrier references to be

00:19:30,760 --> 00:19:36,159
movable now this imposes some

00:19:32,890 --> 00:19:37,840
constraints for example this simple

00:19:36,159 --> 00:19:40,179
constructor like function

00:19:37,840 --> 00:19:44,140
memory unsafe and let's go through how

00:19:40,179 --> 00:19:48,940
why so first we stacked allocate our he

00:19:44,140 --> 00:19:51,549
proper then we call set which invokes

00:19:48,940 --> 00:19:55,630
opposed barrier taking the address of

00:19:51,549 --> 00:19:58,450
the stack allocated he proper but then

00:19:55,630 --> 00:20:00,640
we return this rapper value by move and

00:19:58,450 --> 00:20:02,770
that's problematic because we'll be more

00:20:00,640 --> 00:20:05,080
value in rust we don't call the drop

00:20:02,770 --> 00:20:07,419
method and so we want reset

00:20:05,080 --> 00:20:09,010
we won't inform SpiderMonkey that the

00:20:07,419 --> 00:20:10,049
references that the reference was

00:20:09,010 --> 00:20:12,309
invalidated

00:20:10,049 --> 00:20:14,260
moreover we won't invoke any

00:20:12,309 --> 00:20:17,260
construction logic when we move the

00:20:14,260 --> 00:20:20,140
value out so there will be a dangling

00:20:17,260 --> 00:20:23,110
wrapper type at a different address that

00:20:20,140 --> 00:20:25,299
still points to a may still point to a

00:20:23,110 --> 00:20:28,480
valid address in the nursery so that's

00:20:25,299 --> 00:20:30,309
bad and unsafe but an obvious

00:20:28,480 --> 00:20:34,570
improvement might be the box all the

00:20:30,309 --> 00:20:36,640
things to heap allocate first and in

00:20:34,570 --> 00:20:39,010
this case it works because heap

00:20:36,640 --> 00:20:42,399
allocation the memory allocation of the

00:20:39,010 --> 00:20:44,770
heap allocation of one change and here

00:20:42,399 --> 00:20:49,149
we can actually safely move the owning

00:20:44,770 --> 00:20:53,140
pointer around so we invoke set function

00:20:49,149 --> 00:20:55,929
on a heap allocated value and it will

00:20:53,140 --> 00:20:58,029
correctly point to the location on the

00:20:55,929 --> 00:21:02,590
heap as I'm saying that will not change

00:20:58,029 --> 00:21:04,390
thus making the function safe so this

00:21:02,590 --> 00:21:07,090
allowed us to fix some some of the

00:21:04,390 --> 00:21:08,799
unsafe T's in the code now this wrapper

00:21:07,090 --> 00:21:10,480
type was used mostly in tandem with

00:21:08,799 --> 00:21:13,690
another type called rooted feasible box

00:21:10,480 --> 00:21:16,179
which you may think of as the equivalent

00:21:13,690 --> 00:21:18,789
of the who the wrapper type but is it is

00:21:16,179 --> 00:21:21,730
dynamic it uses a linked list underneath

00:21:18,789 --> 00:21:25,000
it also acts like a box which is an

00:21:21,730 --> 00:21:27,340
owning pointer but because of this and

00:21:25,000 --> 00:21:29,409
thanks to rust ownership semantics we

00:21:27,340 --> 00:21:34,270
can actually consume the heap allocated

00:21:29,409 --> 00:21:36,760
value and use it to create to act as an

00:21:34,270 --> 00:21:39,130
as an owning pointer ourselves thus

00:21:36,760 --> 00:21:42,340
avoiding any run time penalty and

00:21:39,130 --> 00:21:44,549
reusing the allocation and it's safe at

00:21:42,340 --> 00:21:44,549
this point

00:21:44,780 --> 00:21:49,490
okay so at the ends were briefly talked

00:21:47,540 --> 00:21:52,640
about the compiler plugin that was

00:21:49,490 --> 00:21:56,330
developed this is used in a different

00:21:52,640 --> 00:22:00,560
context to route JS typed dominant VI

00:21:56,330 --> 00:22:03,110
objects now types change but the core

00:22:00,560 --> 00:22:06,260
principle stays the same we have a type

00:22:03,110 --> 00:22:09,860
DC manage pointers and dynamic routes as

00:22:06,260 --> 00:22:12,530
I was mentioning previously needless to

00:22:09,860 --> 00:22:15,590
say these DC manage values still need to

00:22:12,530 --> 00:22:18,230
be routed correctly to be used now to

00:22:15,590 --> 00:22:21,200
verify that we'll use a custom plugin

00:22:18,230 --> 00:22:23,720
this uses the plug-in register feature

00:22:21,200 --> 00:22:27,380
which allows us to register our own

00:22:23,720 --> 00:22:29,420
custom attributes Lince and Warren to

00:22:27,380 --> 00:22:31,820
perform the analysis we introduce two

00:22:29,420 --> 00:22:33,320
annotations they must route annotation

00:22:31,820 --> 00:22:35,780
and the allow unrelated interior

00:22:33,320 --> 00:22:38,390
annotation these annotations will be

00:22:35,780 --> 00:22:42,020
helpful with verifying the logic I want

00:22:38,390 --> 00:22:44,360
to and this is a simple code that

00:22:42,020 --> 00:22:46,330
reduces all this and as you can see it's

00:22:44,360 --> 00:22:51,410
no magic even though we interact with

00:22:46,330 --> 00:22:53,840
internals of the rest compiler so as I

00:22:51,410 --> 00:22:57,040
said before the goal is to verify that

00:22:53,840 --> 00:22:59,720
the objects are routed correctly now

00:22:57,040 --> 00:23:00,920
this can be done by imposing some

00:22:59,720 --> 00:23:04,640
certain set of rules

00:23:00,920 --> 00:23:07,460
first of all any data that has an

00:23:04,640 --> 00:23:10,370
internal data marked with must route

00:23:07,460 --> 00:23:12,980
must also be marked as must route itself

00:23:10,370 --> 00:23:16,210
so in other words this means that must

00:23:12,980 --> 00:23:19,460
treat attribute infects the other type

00:23:16,210 --> 00:23:22,310
secondly only objects that are that are

00:23:19,460 --> 00:23:25,310
marked with allow interior are safe to

00:23:22,310 --> 00:23:28,070
contain the mask which marked member

00:23:25,310 --> 00:23:29,990
data we also disallow creating mic

00:23:28,070 --> 00:23:32,240
objects with mass route on its stack

00:23:29,990 --> 00:23:35,420
because you can imagine a scenario where

00:23:32,240 --> 00:23:39,350
we store an unrooted reference to ADC

00:23:35,420 --> 00:23:41,180
matters object on the stack but then the

00:23:39,350 --> 00:23:43,690
garbage collector does it spats dozen

00:23:41,180 --> 00:23:48,580
validating the underlying object and

00:23:43,690 --> 00:23:51,590
similarly we also disallow to accept

00:23:48,580 --> 00:23:53,750
must route annotated objects as function

00:23:51,590 --> 00:23:55,740
arguments type because we'd like to have

00:23:53,750 --> 00:23:58,950
a guarantee that functions that

00:23:55,740 --> 00:24:02,179
arguments will be valid and rooted

00:23:58,950 --> 00:24:04,710
throughout the entire function call so

00:24:02,179 --> 00:24:08,340
simplifying we do this as this we invoke

00:24:04,710 --> 00:24:11,309
a specific special declare lint macro

00:24:08,340 --> 00:24:14,520
with a lint identifier and default

00:24:11,309 --> 00:24:17,250
severity then we need to implement these

00:24:14,520 --> 00:24:19,460
fussy internal traits now the

00:24:17,250 --> 00:24:23,460
interesting trade is the light lint pass

00:24:19,460 --> 00:24:26,309
it actually defines a set of

00:24:23,460 --> 00:24:29,520
verification logic that's executed for

00:24:26,309 --> 00:24:31,770
every item in our abstract syntax tree

00:24:29,520 --> 00:24:35,610
of our code but in this case we'd like

00:24:31,770 --> 00:24:37,320
to verify data definition so we'll use

00:24:35,610 --> 00:24:40,500
the check structure definition and check

00:24:37,320 --> 00:24:42,059
enum functions and also we like to

00:24:40,500 --> 00:24:44,760
verify function bodies and their

00:24:42,059 --> 00:24:47,309
argument types so you implement the

00:24:44,760 --> 00:24:50,160
check function call and you can

00:24:47,309 --> 00:24:52,410
implement any other call for any other

00:24:50,160 --> 00:24:55,890
item but these are by default lis

00:24:52,410 --> 00:24:57,630
implemented as Noah so you can only so

00:24:55,890 --> 00:25:01,050
you can implement only those that you

00:24:57,630 --> 00:25:03,600
need so simplifying a great deal here

00:25:01,050 --> 00:25:05,610
imagine and the check function method

00:25:03,600 --> 00:25:08,429
that we want to verify that these

00:25:05,610 --> 00:25:10,110
arguments have the function arguments

00:25:08,429 --> 00:25:14,100
are not of type that's marked with

00:25:10,110 --> 00:25:16,920
mustard so we can imagine that we have a

00:25:14,100 --> 00:25:18,720
helper type that checks all those

00:25:16,920 --> 00:25:24,000
necessary attributes because we have

00:25:18,720 --> 00:25:26,370
access to that by using tie type that

00:25:24,000 --> 00:25:28,559
actually checks if the value is safe to

00:25:26,370 --> 00:25:30,900
use or error in this case is an order

00:25:28,559 --> 00:25:33,000
which is not safe to be used and if

00:25:30,900 --> 00:25:35,429
that's the case we can omit our own

00:25:33,000 --> 00:25:37,590
custom errors using this Pantaloon api

00:25:35,429 --> 00:25:39,780
here we need to pass the identifier

00:25:37,590 --> 00:25:45,030
balance and also the range worthier

00:25:39,780 --> 00:25:48,210
occurs so consider this very simplistic

00:25:45,030 --> 00:25:49,050
example where we reuse the plugin that's

00:25:48,210 --> 00:25:51,390
used in servo

00:25:49,050 --> 00:25:52,590
we define a very simple structure that's

00:25:51,390 --> 00:25:56,550
marked with must route

00:25:52,590 --> 00:25:59,309
however down below we define a function

00:25:56,550 --> 00:26:01,320
that accepts an argument type that

00:25:59,309 --> 00:26:03,870
should be invalid and in this case we'd

00:26:01,320 --> 00:26:07,169
like to pick up the air and proceed to

00:26:03,870 --> 00:26:09,350
emit the appropriate error so if you run

00:26:07,169 --> 00:26:11,940
a cargo check on this code

00:26:09,350 --> 00:26:14,940
the compiler will actually pick up the

00:26:11,940 --> 00:26:20,480
air and the MIT there just like it would

00:26:14,940 --> 00:26:23,340
any other out there in the world and

00:26:20,480 --> 00:26:23,760
yeah that's all what I have to work

00:26:23,340 --> 00:26:34,740
today

00:26:23,760 --> 00:26:37,280
thanks for listening yeah question again

00:26:34,740 --> 00:26:37,280
yeah

00:26:43,070 --> 00:26:53,480
one question does anybody have a

00:26:46,170 --> 00:26:53,480
question okay

00:26:53,980 --> 00:26:57,039

YouTube URL: https://www.youtube.com/watch?v=5etttfaOcNI


