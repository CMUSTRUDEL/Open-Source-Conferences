Title: RustFest Rome 2018 -  Massimiliano Mantione: Fun with Rusty Robots
Publication date: 2018-11-24
Playlist: RustFest Rome 2018
Description: 
	Lately as a hobby I am participating to robotic competitions where autonomous robots fight according to various rules (usually speed races or Sumo fights). Lately I am putting Rust into every robot I program, from bare metal (arduino-like AVR and ARM Cortex-M), to Linux on higher level boards (Raspberry PI, Beaglebone), and even on a real time OS running on the Lego Mindstorm ARM-v5 CPU. In this talk I'll show embedded Rust programming in all of these environments, with a focus on getting things done!

https://rome.rustfest.eu/sessions/fun-with-rusty-robots
https://media.ccc.de/v/rustfest-rome-7-fun-with-rusty-robots
Captions: 
	00:00:04,710 --> 00:00:09,790
there you go so everybody please give a

00:00:07,440 --> 00:00:16,740
round of applause bus in the honor

00:00:09,790 --> 00:00:18,610
[Applause]

00:00:16,740 --> 00:00:22,390
good morning everyone

00:00:18,610 --> 00:00:25,660
am i near enough yes okay so I talked

00:00:22,390 --> 00:00:28,510
about rust on robots now something short

00:00:25,660 --> 00:00:30,369
about myself things I worked on I am

00:00:28,510 --> 00:00:32,110
mostly a compiler engineer i working on

00:00:30,369 --> 00:00:34,180
the monitors in time compiler for six

00:00:32,110 --> 00:00:37,090
years then in the Unity game engine for

00:00:34,180 --> 00:00:40,840
one year the v8 team in Google for one

00:00:37,090 --> 00:00:42,510
year and a half and now I do virtual

00:00:40,840 --> 00:00:46,660
reality on the web in hyper fair and

00:00:42,510 --> 00:00:49,590
it's fun but now let's talk about this

00:00:46,660 --> 00:00:52,809
talk first so I start telling stories

00:00:49,590 --> 00:00:55,539
about how I actually ended up using rust

00:00:52,809 --> 00:00:56,530
on robots because the story is important

00:00:55,539 --> 00:00:58,090
because so you understand the

00:00:56,530 --> 00:01:01,420
motivations what actually happened and

00:00:58,090 --> 00:01:03,399
I'll show a couple of examples and then

00:01:01,420 --> 00:01:05,590
I'll say something about what's special

00:01:03,399 --> 00:01:07,570
about rust on robots and it will be

00:01:05,590 --> 00:01:10,570
pretty simple because the software is

00:01:07,570 --> 00:01:13,210
very very simple and also because in the

00:01:10,570 --> 00:01:16,270
end me and grassed well it's not like

00:01:13,210 --> 00:01:18,280
that much so long ago I like the

00:01:16,270 --> 00:01:20,110
concepts that I like a time and I was

00:01:18,280 --> 00:01:22,960
feeling the learning curve you know

00:01:20,110 --> 00:01:24,790
borrowed checker anyone and so I just

00:01:22,960 --> 00:01:29,020
was watching rust from a distance that

00:01:24,790 --> 00:01:30,940
was it and then about robots and again I

00:01:29,020 --> 00:01:33,880
like at them in principle of course but

00:01:30,940 --> 00:01:36,850
again I like a time and then we saw a

00:01:33,880 --> 00:01:40,450
Lego sumo competition it was me and my

00:01:36,850 --> 00:01:41,740
son while also my wife he was 12 and it

00:01:40,450 --> 00:01:44,050
was love at first sight I mean it was

00:01:41,740 --> 00:01:45,520
really fun and so we started building

00:01:44,050 --> 00:01:47,620
our robot to compete in these

00:01:45,520 --> 00:01:49,150
competitions and to give some

00:01:47,620 --> 00:01:51,070
perspective I'm talking about hobby

00:01:49,150 --> 00:01:54,970
projects mostly done with Lego so

00:01:51,070 --> 00:01:56,380
essentially toys and for competitions

00:01:54,970 --> 00:01:58,480
which is fun because then you are forced

00:01:56,380 --> 00:02:00,040
to do them better so you are doing

00:01:58,480 --> 00:02:02,290
something simple but then you say oh

00:02:00,040 --> 00:02:03,840
crap I'm losing this match why and then

00:02:02,290 --> 00:02:05,830
you want to do something better and

00:02:03,840 --> 00:02:08,470
these competitions that I'm talking

00:02:05,830 --> 00:02:11,080
about is mostly sumo and line follower

00:02:08,470 --> 00:02:12,580
so a sumo match is something like this

00:02:11,080 --> 00:02:15,069
you've got two opponents on a small

00:02:12,580 --> 00:02:16,540
arena and they start and they are

00:02:15,069 --> 00:02:19,540
autonomous and they try to use a

00:02:16,540 --> 00:02:22,300
strategy to push the other out so this

00:02:19,540 --> 00:02:24,430
is what you should expect and the line

00:02:22,300 --> 00:02:26,410
follower is a small thing that follows a

00:02:24,430 --> 00:02:28,570
line you know and the goal is to do it

00:02:26,410 --> 00:02:28,900
fast so the one that wins is the one

00:02:28,570 --> 00:02:33,610
that

00:02:28,900 --> 00:02:36,610
it faster to that time it and now over

00:02:33,610 --> 00:02:40,239
the years we actually built a team

00:02:36,610 --> 00:02:41,980
because there's this guy here which is

00:02:40,239 --> 00:02:43,689
the most recent one he was winning

00:02:41,980 --> 00:02:45,609
competition all the time organizing one

00:02:43,689 --> 00:02:47,319
in Italy we participated to the one he

00:02:45,609 --> 00:02:50,950
was organizing then became friends and

00:02:47,319 --> 00:02:54,220
then there's my wife my son another

00:02:50,950 --> 00:02:57,159
father with his son this one is his son

00:02:54,220 --> 00:02:59,349
now another family join it and next week

00:02:57,159 --> 00:03:01,720
we will be in estonia tallinn for a

00:02:59,349 --> 00:03:05,980
gigantic event with hundreds of robots

00:03:01,720 --> 00:03:09,760
will be will be bringing 30 ourselves so

00:03:05,980 --> 00:03:10,959
we are really having a lot of fun so

00:03:09,760 --> 00:03:13,629
back to the story

00:03:10,959 --> 00:03:16,060
our first lego robot we had to program

00:03:13,629 --> 00:03:17,319
this thing and the Lego kit comes

00:03:16,060 --> 00:03:18,939
through the visual environment

00:03:17,319 --> 00:03:21,220
now the visual environment is fine for

00:03:18,939 --> 00:03:22,900
kids but it's very limiting when you

00:03:21,220 --> 00:03:24,549
want to do something more complex my kid

00:03:22,900 --> 00:03:25,870
understood that so we would intend to

00:03:24,549 --> 00:03:34,090
switch to a real programming language

00:03:25,870 --> 00:03:36,730
now the Lego thing runs Linux inside big

00:03:34,090 --> 00:03:38,349
like this it's big like this this is the

00:03:36,730 --> 00:03:44,799
mold completely small computer so it's

00:03:38,349 --> 00:03:46,810
Lego so runs Linux and there is an

00:03:44,799 --> 00:03:48,459
operating system which is easy three dad

00:03:46,810 --> 00:03:52,269
Evie three is the name of the CPU the

00:03:48,459 --> 00:03:55,120
the Lego kit and Evie three death is a

00:03:52,269 --> 00:03:56,889
debian part on this so you have a Debian

00:03:55,120 --> 00:03:59,440
you can SSH into it you can use whatever

00:03:56,889 --> 00:04:01,209
you want and our first language was no

00:03:59,440 --> 00:04:03,549
js' javascript because we wanted to keep

00:04:01,209 --> 00:04:06,099
it simple then that was problem with the

00:04:03,549 --> 00:04:08,769
libraries to switch to python and then

00:04:06,099 --> 00:04:11,620
the robot work it we qualified in our

00:04:08,769 --> 00:04:13,569
competition but we realized that it was

00:04:11,620 --> 00:04:18,070
not interacting properly I mean it was

00:04:13,569 --> 00:04:20,590
slow so I was blaming the language but

00:04:18,070 --> 00:04:23,500
in spite on I mean it's not fast we all

00:04:20,590 --> 00:04:28,110
roll so I didn't want to inflict memory

00:04:23,500 --> 00:04:28,110
management on to my son so I said okay

00:04:33,080 --> 00:04:39,420
so my idea was goal and goal and is a

00:04:37,170 --> 00:04:43,410
very simple as a language it's compiled

00:04:39,420 --> 00:04:45,540
to native code and it's working but

00:04:43,410 --> 00:04:49,410
somebody said let there be latency in

00:04:45,540 --> 00:04:50,820
the world and there was Latin si and the

00:04:49,410 --> 00:04:53,700
problem is that doing things takes time

00:04:50,820 --> 00:04:57,270
and time can be significant and our

00:04:53,700 --> 00:04:59,400
robots did not react in time so we built

00:04:57,270 --> 00:05:02,910
a Latin si tester now this latency

00:04:59,400 --> 00:05:05,160
tester has panels passing in front of a

00:05:02,910 --> 00:05:07,680
proximity sensors that drives a line

00:05:05,160 --> 00:05:09,240
that is censored by a sensor so the time

00:05:07,680 --> 00:05:11,700
it takes for the signal to propagate

00:05:09,240 --> 00:05:18,750
from these sensors to the actuator to be

00:05:11,700 --> 00:05:21,510
imperceivable and and react so this is a

00:05:18,750 --> 00:05:24,630
simulator of the latency that the robot

00:05:21,510 --> 00:05:27,000
is actually experiencing while working I

00:05:24,630 --> 00:05:28,530
had to be scientific because I really

00:05:27,000 --> 00:05:30,810
wanted to understand what was going on I

00:05:28,530 --> 00:05:32,430
mean this is obviously a toy but it

00:05:30,810 --> 00:05:35,880
served a purpose it was a scientific

00:05:32,430 --> 00:05:38,010
experiment and the problem was we

00:05:35,880 --> 00:05:41,640
measured something like 50 millisecond

00:05:38,010 --> 00:05:43,890
latency spikes is it much is it not much

00:05:41,640 --> 00:05:46,470
we are talking about hard real-time but

00:05:43,890 --> 00:05:48,870
what does it mean well hard real-time is

00:05:46,470 --> 00:05:51,480
not about performance by its own sake

00:05:48,870 --> 00:05:54,990
it's about time related correctness

00:05:51,480 --> 00:05:56,850
which means predictable latency and to

00:05:54,990 --> 00:05:59,130
give examples related to robotics

00:05:56,850 --> 00:06:03,240
think about a self-driving car on a

00:05:59,130 --> 00:06:07,260
highway a bit more than 100 km/h is 30

00:06:03,240 --> 00:06:10,620
meters per second and at this speed 100

00:06:07,260 --> 00:06:12,890
milliseconds is 3 meters so if by any

00:06:10,620 --> 00:06:16,590
means that software is 100 millimeter

00:06:12,890 --> 00:06:21,210
milliseconds late you lose 3 meters of

00:06:16,590 --> 00:06:23,940
rank which is not good probably I said

00:06:21,210 --> 00:06:25,890
ok this is a car what about our toys ok

00:06:23,940 --> 00:06:28,980
take a line follower robot let's say go

00:06:25,890 --> 00:06:32,910
doing 2 meters per second then 10

00:06:28,980 --> 00:06:35,640
milliseconds is 20 millimeters and since

00:06:32,910 --> 00:06:39,000
the line is smaller than 20 millimeters

00:06:35,640 --> 00:06:40,200
if you have a blind spot of 10

00:06:39,000 --> 00:06:43,230
milliseconds you

00:06:40,200 --> 00:06:45,930
just risk to miss a sharp turn and go

00:06:43,230 --> 00:06:47,670
out of the track so this is the kind of

00:06:45,930 --> 00:06:49,320
latency you should aim at generally

00:06:47,670 --> 00:06:53,100
millisecond or sub millisecond latency

00:06:49,320 --> 00:06:55,260
if you want to be serious now the root

00:06:53,100 --> 00:06:57,180
of the problem actually was not the

00:06:55,260 --> 00:06:59,130
language I was very conscious when I was

00:06:57,180 --> 00:07:00,600
writing go long I did essentially never

00:06:59,130 --> 00:07:03,330
did allocations the garbage collector

00:07:00,600 --> 00:07:05,610
wasn't there anyway so it was just

00:07:03,330 --> 00:07:08,610
machine code it was fast the problem was

00:07:05,610 --> 00:07:10,350
the OS so in that operating system it

00:07:08,610 --> 00:07:15,030
was a Linux kernel an ancient one

00:07:10,350 --> 00:07:18,270
without pre entity and there's this arm

00:07:15,030 --> 00:07:19,680
v5 chip which has a cache addressing

00:07:18,270 --> 00:07:20,970
scheme I don't want to dive into the

00:07:19,680 --> 00:07:23,220
details but the problem is a Tavi

00:07:20,970 --> 00:07:27,870
context which the operating system is

00:07:23,220 --> 00:07:29,570
forced to flash the whole cache which is

00:07:27,870 --> 00:07:33,000
painful

00:07:29,570 --> 00:07:35,790
so what can we do I say okay let's try a

00:07:33,000 --> 00:07:38,790
new operating system we found out there

00:07:35,790 --> 00:07:40,950
is this easy three RT which is a small

00:07:38,790 --> 00:07:44,970
real-time kernel that has been ported on

00:07:40,950 --> 00:07:47,400
the Lego brick by a Japanese team and it

00:07:44,970 --> 00:07:50,070
is there on the internet and it was

00:07:47,400 --> 00:07:52,740
amazing soup milliseconds max latencies

00:07:50,070 --> 00:07:55,290
and the event loop was running on more

00:07:52,740 --> 00:07:57,120
than 10 kilohertz so 10 times per

00:07:55,290 --> 00:07:58,530
millisecond you could measure things I

00:07:57,120 --> 00:08:00,180
mean we were extra happy the

00:07:58,530 --> 00:08:03,600
documentation was entirely in Japanese

00:08:00,180 --> 00:08:06,030
just tiny bits of English and the user

00:08:03,600 --> 00:08:08,790
code must be written in C there is no

00:08:06,030 --> 00:08:11,100
other SDK essentially so my son got sad

00:08:08,790 --> 00:08:12,630
because of the C language you know he

00:08:11,100 --> 00:08:14,490
was already very proficient in golang

00:08:12,630 --> 00:08:16,500
and said what's this mess you have to

00:08:14,490 --> 00:08:20,280
care about pointers the references what

00:08:16,500 --> 00:08:22,620
was this thing and so this is I said

00:08:20,280 --> 00:08:24,270
okay let's look at rust this was

00:08:22,620 --> 00:08:26,790
actually a perfect excuse for me for

00:08:24,270 --> 00:08:28,800
learning rust and it's actually a

00:08:26,790 --> 00:08:30,630
perfect fit because there is no GC the

00:08:28,800 --> 00:08:33,120
respirator latency there is high

00:08:30,630 --> 00:08:34,920
performance and it is perfect C ABI

00:08:33,120 --> 00:08:37,590
interoperability which means that it's a

00:08:34,920 --> 00:08:41,370
perfect drop-in replacement for C in

00:08:37,590 --> 00:08:44,730
essentially an environment so I started

00:08:41,370 --> 00:08:48,090
with baby steps I entered no STD land

00:08:44,730 --> 00:08:49,230
which means that you want to keep it as

00:08:48,090 --> 00:08:50,580
small you don't want to have

00:08:49,230 --> 00:08:53,550
dependencies I did not want to have

00:08:50,580 --> 00:08:53,820
memory allocation anyway because you

00:08:53,550 --> 00:08:55,290
know

00:08:53,820 --> 00:08:58,140
I'm your reason size reasons and

00:08:55,290 --> 00:08:59,940
everything so I selected the RFI target

00:08:58,140 --> 00:09:02,370
which is actually pretty well supported

00:08:59,940 --> 00:09:05,070
and the proof of concept was a single

00:09:02,370 --> 00:09:07,590
rest files compiled it directly with the

00:09:05,070 --> 00:09:09,720
compiler as see not even cargo and it

00:09:07,590 --> 00:09:12,510
was replacing a single C object file

00:09:09,720 --> 00:09:15,240
with one single function and link it

00:09:12,510 --> 00:09:16,560
together and well it working that was

00:09:15,240 --> 00:09:18,210
very simple you know a function that

00:09:16,560 --> 00:09:21,150
adds one to a number it's about his

00:09:18,210 --> 00:09:22,590
worker then I did the bulk of the job

00:09:21,150 --> 00:09:24,270
which was integrated that with the

00:09:22,590 --> 00:09:27,050
operating system that were a few small

00:09:24,270 --> 00:09:29,640
challenges like no simple Cisco ABI

00:09:27,050 --> 00:09:31,110
because this is quality I was this thing

00:09:29,640 --> 00:09:33,120
that was difficult to emulate in grass

00:09:31,110 --> 00:09:34,860
but then the solution is simply to wrap

00:09:33,120 --> 00:09:37,050
this is Cole I need would see functions

00:09:34,860 --> 00:09:39,690
and link on to them it's very simple to

00:09:37,050 --> 00:09:41,640
do then the binary file format for the

00:09:39,690 --> 00:09:44,160
executable was really tricky because it

00:09:41,640 --> 00:09:47,370
was an elf format but with a custom

00:09:44,160 --> 00:09:50,520
layout that they selected and so I just

00:09:47,370 --> 00:09:54,060
reused the C SDK linker script I changed

00:09:50,520 --> 00:09:55,890
nothing so impact is what I do is to

00:09:54,060 --> 00:09:59,910
compile my application create as a

00:09:55,890 --> 00:10:01,860
static library in rust and then have a C

00:09:59,910 --> 00:10:04,050
application in this operating system and

00:10:01,860 --> 00:10:05,790
Link the static library into that

00:10:04,050 --> 00:10:08,250
application providing essentially the

00:10:05,790 --> 00:10:09,660
main entry point so there is this

00:10:08,250 --> 00:10:11,550
application in this operating system

00:10:09,660 --> 00:10:14,640
that cause my main entry point in rust

00:10:11,550 --> 00:10:16,800
and from that point on is just rust land

00:10:14,640 --> 00:10:21,180
called him back into the library

00:10:16,800 --> 00:10:25,110
function in C it's pretty simple and he

00:10:21,180 --> 00:10:28,020
started working but working then linkit

00:10:25,110 --> 00:10:29,910
files became too big so it's something

00:10:28,020 --> 00:10:33,030
like 1 megabyte of code and I said why

00:10:29,910 --> 00:10:35,220
does it did 1 megabyte of code and then

00:10:33,030 --> 00:10:37,650
I tried various strategies with the

00:10:35,220 --> 00:10:39,210
linker to limit the scope of the code

00:10:37,650 --> 00:10:40,680
throwing away what was not needed but

00:10:39,210 --> 00:10:42,900
every time I touched the linking process

00:10:40,680 --> 00:10:45,300
as was backing the build it was very

00:10:42,900 --> 00:10:47,220
very hard to produce an executable file

00:10:45,300 --> 00:10:50,460
that was ok for that operating system to

00:10:47,220 --> 00:10:52,020
load then I said ok I have no other

00:10:50,460 --> 00:10:53,310
choice I'll reckon Polly beak or

00:10:52,020 --> 00:10:56,310
stripping things by hand

00:10:53,310 --> 00:11:00,120
I was really determinate to have it

00:10:56,310 --> 00:11:01,740
running and so I I started with sargo

00:11:00,120 --> 00:11:03,990
which is a tool that uses in embedded

00:11:01,740 --> 00:11:05,350
land but this is actually mostly a tall

00:11:03,990 --> 00:11:07,840
cover us in embedded

00:11:05,350 --> 00:11:10,990
and so robotics is an excuse to say

00:11:07,840 --> 00:11:13,330
embedded land and with sargo that were

00:11:10,990 --> 00:11:15,160
linking issues then I use it another

00:11:13,330 --> 00:11:17,440
tool which is called a cargo X build

00:11:15,160 --> 00:11:20,140
which is a plug into cargo that

00:11:17,440 --> 00:11:22,360
recompiles lib core and another couple

00:11:20,140 --> 00:11:25,510
of basic libraries on the fly for you

00:11:22,360 --> 00:11:27,340
for your target and the funny thing was

00:11:25,510 --> 00:11:29,800
that using this under compiling leap

00:11:27,340 --> 00:11:32,500
code on the fly solve it the issue

00:11:29,800 --> 00:11:36,310
magically it was half the size don't ask

00:11:32,500 --> 00:11:38,410
me why so it worked it which means now I

00:11:36,310 --> 00:11:42,540
want to show you something just

00:11:38,410 --> 00:11:42,540
concretely so that we have fun

00:11:59,930 --> 00:12:06,280
[Music]

00:12:02,110 --> 00:12:09,530
so I don't know how much this is visible

00:12:06,280 --> 00:12:12,350
but this thing is running rust code it

00:12:09,530 --> 00:12:16,250
has a small UI I can select another

00:12:12,350 --> 00:12:20,900
function and it is measuring the error

00:12:16,250 --> 00:12:34,310
of the sensor if I move it you maybe see

00:12:20,900 --> 00:12:35,540
that it is moving closer okay you see

00:12:34,310 --> 00:12:38,020
that there are numbers moving it's

00:12:35,540 --> 00:12:41,780
actually measuring the error on the line

00:12:38,020 --> 00:12:43,640
moving so this I cannot make it run

00:12:41,780 --> 00:12:49,970
because I don't have the track then

00:12:43,640 --> 00:12:52,310
there is this boy look at the strategy I

00:12:49,970 --> 00:12:57,230
can pick another strategy which is

00:12:52,310 --> 00:13:01,670
around and go to the center and I say

00:12:57,230 --> 00:13:03,590
prepare to run now it will start and it

00:13:01,670 --> 00:13:07,190
should execute the strategy and then

00:13:03,590 --> 00:13:21,880
look for an opponent in to one second

00:13:07,190 --> 00:13:25,970
start effect start again five seconds

00:13:21,880 --> 00:13:28,580
three two one go

00:13:25,970 --> 00:13:36,440
Circle look for opponent here is the

00:13:28,580 --> 00:13:41,360
opponent look for me now it actually saw

00:13:36,440 --> 00:13:46,100
me okay so you see it reacts it works

00:13:41,360 --> 00:13:47,630
and this is fast so it's a toy but it's

00:13:46,100 --> 00:13:53,559
been really fun

00:13:47,630 --> 00:13:53,559
[Applause]

00:14:00,360 --> 00:14:09,899
so now a different story

00:14:13,079 --> 00:14:17,740
okay so this one I'll cut it a bit

00:14:15,640 --> 00:14:23,470
shorter because it is a bit of a sad

00:14:17,740 --> 00:14:26,500
story other robot which is another toy

00:14:23,470 --> 00:14:31,570
this is preemies for kids it's a one

00:14:26,500 --> 00:14:34,600
robot per child platform and it's its

00:14:31,570 --> 00:14:36,430
main but it's Arduino side so an IVR CPU

00:14:34,600 --> 00:14:42,370
and we wanted to use this in a

00:14:36,430 --> 00:14:44,800
competition as well so I said okay let's

00:14:42,370 --> 00:14:48,010
use rest on that which means rest on AVR

00:14:44,800 --> 00:14:49,839
and the spoiler eyelid this does not

00:14:48,010 --> 00:14:51,399
really have a happy ending it doesn't

00:14:49,839 --> 00:14:54,430
fully work and they want just to tell

00:14:51,399 --> 00:14:55,959
you why so let's cut it short about the

00:14:54,430 --> 00:14:58,300
troublesome things I had to do to

00:14:55,959 --> 00:15:00,730
actually make it run so there were lots

00:14:58,300 --> 00:15:03,100
of us hardest you have to build your own

00:15:00,730 --> 00:15:06,430
wrath compiler from an unstable fork

00:15:03,100 --> 00:15:09,640
with an unstable LLVM fork and the build

00:15:06,430 --> 00:15:11,260
environment is sometimes critical I was

00:15:09,640 --> 00:15:14,529
looking for an environment more stable

00:15:11,260 --> 00:15:17,320
using a container then when I had it

00:15:14,529 --> 00:15:19,449
running the main library resumed at work

00:15:17,320 --> 00:15:21,880
and the dutiful thing that I wanted to

00:15:19,449 --> 00:15:28,300
use and so I rebuilt the compiler again

00:15:21,880 --> 00:15:31,570
and catching up in the end I had analog

00:15:28,300 --> 00:15:33,339
world again and when I had an a low word

00:15:31,570 --> 00:15:36,100
working I wanted to actually write code

00:15:33,339 --> 00:15:39,010
for robot and then I had ecosystem

00:15:36,100 --> 00:15:41,680
issues because essentially the basic

00:15:39,010 --> 00:15:44,079
instruction would work you had several

00:15:41,680 --> 00:15:45,370
part timers and I could use individual

00:15:44,079 --> 00:15:47,560
pins on the chip

00:15:45,370 --> 00:15:49,390
but the problem is anything else and

00:15:47,560 --> 00:15:50,709
then I'll talk about robot hardware so

00:15:49,390 --> 00:15:53,890
what do you what are you interacting

00:15:50,709 --> 00:15:56,500
with and if you just need to do simple

00:15:53,890 --> 00:15:58,420
readwrite on pins then it's simple so

00:15:56,500 --> 00:16:01,959
you just use the registers and you write

00:15:58,420 --> 00:16:04,510
to the pins and that's fine now if you

00:16:01,959 --> 00:16:07,750
if you have timers so you can generate

00:16:04,510 --> 00:16:08,920
square waves which is PWM to drive the

00:16:07,750 --> 00:16:12,129
continuous current mode

00:16:08,920 --> 00:16:14,049
and eventually service so that thing you

00:16:12,129 --> 00:16:16,079
can get it working in rust easily

00:16:14,049 --> 00:16:19,389
because it's just a few register right

00:16:16,079 --> 00:16:21,459
you had ooh our doer viewers so you have

00:16:19,389 --> 00:16:24,549
serial lines so eventually you could

00:16:21,459 --> 00:16:29,049
talk to smart sensors if they had a

00:16:24,549 --> 00:16:31,569
certain interface but however in this

00:16:29,049 --> 00:16:33,879
thing it is a real word thing this

00:16:31,569 --> 00:16:36,879
hardware it has motors and the button

00:16:33,879 --> 00:16:42,239
which are okay PWM and the single analog

00:16:36,879 --> 00:16:42,239
grid on a pin it has ultrasound sensors

00:16:46,470 --> 00:16:54,549
if I switch it on then you can see that

00:16:51,399 --> 00:16:58,389
it senses proximity this is an

00:16:54,549 --> 00:17:03,429
ultrasound sensor and it's easy to do

00:16:58,389 --> 00:17:06,970
because in the end is just a pin where

00:17:03,429 --> 00:17:09,669
you have to write a high signal to to

00:17:06,970 --> 00:17:11,860
push the sound and when you have to read

00:17:09,669 --> 00:17:13,839
the signal to end time the time it takes

00:17:11,860 --> 00:17:16,769
for the sound to come back so you have

00:17:13,839 --> 00:17:20,860
to time it but it's not hard

00:17:16,769 --> 00:17:22,269
the problem is anything else because for

00:17:20,860 --> 00:17:24,579
anything else you have to do what is

00:17:22,269 --> 00:17:26,980
called a bit banging anybody know what's

00:17:24,579 --> 00:17:28,960
been bit banging is is when you are

00:17:26,980 --> 00:17:32,200
actually implementing a protocol on a

00:17:28,960 --> 00:17:35,860
pin writing high and low bits on the pin

00:17:32,200 --> 00:17:39,250
by hand using code and the HB light on

00:17:35,860 --> 00:17:41,919
the thing works on a single pin for

00:17:39,250 --> 00:17:43,899
chula for to RGB LEDs and the protocol

00:17:41,919 --> 00:17:47,559
has something like 800 nano second

00:17:43,899 --> 00:17:49,990
perfusion pulses and the mainstream

00:17:47,559 --> 00:17:51,909
audio library Arduino library it

00:17:49,990 --> 00:17:54,039
essentially is a pile of macros and

00:17:51,909 --> 00:17:56,169
finely tuned inline assembly which only

00:17:54,039 --> 00:18:00,399
works because of the speed of the clock

00:17:56,169 --> 00:18:02,440
of the CPU and they're reading from the

00:18:00,399 --> 00:18:05,289
line sensor on the front is similar and

00:18:02,440 --> 00:18:07,450
the problem is that back trust writing

00:18:05,289 --> 00:18:09,130
this in rust is feasible you put in line

00:18:07,450 --> 00:18:12,659
assembly in rust with markers and

00:18:09,130 --> 00:18:15,789
everything but what is it's not pleasant

00:18:12,659 --> 00:18:19,419
so I decided well it's tricky I try to

00:18:15,789 --> 00:18:21,400
reuse the C code now mixing Russ and

00:18:19,419 --> 00:18:25,000
Arduino turned out to be incredibly hard

00:18:21,400 --> 00:18:27,610
I tried both ways so both taking an

00:18:25,000 --> 00:18:31,600
Arduino sketch with a rest lighter

00:18:27,610 --> 00:18:33,970
inside and a last application link in

00:18:31,600 --> 00:18:36,880
there we know library in both cases I

00:18:33,970 --> 00:18:41,680
had linking issues runtime issues not

00:18:36,880 --> 00:18:44,700
found symbols to large executable so I

00:18:41,680 --> 00:18:47,860
ended up saying ok it's just too hard

00:18:44,700 --> 00:18:50,410
now I'm just keeping my totus that Trust

00:18:47,860 --> 00:18:53,500
does work on AVR in this unstable branch

00:18:50,410 --> 00:18:55,570
it's still a bit painful to use the echo

00:18:53,500 --> 00:18:57,640
system is not there because an Arduino

00:18:55,570 --> 00:19:00,160
much of the value is the echo system you

00:18:57,640 --> 00:19:02,050
find libraries for everything and it

00:19:00,160 --> 00:19:04,450
helps a lot now if you want to start a

00:19:02,050 --> 00:19:06,160
rest project on Arduino think about it

00:19:04,450 --> 00:19:08,410
what do you want to do do you want to

00:19:06,160 --> 00:19:10,540
work on the platform or do you want to

00:19:08,410 --> 00:19:11,680
get something done because if you want

00:19:10,540 --> 00:19:13,630
to get something done you will have a

00:19:11,680 --> 00:19:15,850
lot to do that that's not the message

00:19:13,630 --> 00:19:17,740
it's not bad in itself you just need to

00:19:15,850 --> 00:19:21,010
know now see integration is probably

00:19:17,740 --> 00:19:21,810
beautiful but really tricky - maybe just

00:19:21,010 --> 00:19:24,400
for timing

00:19:21,810 --> 00:19:26,020
eventually rust AVR will be merged in

00:19:24,400 --> 00:19:26,590
mainline probably so maybe things will

00:19:26,020 --> 00:19:29,530
get better

00:19:26,590 --> 00:19:35,110
but for now is this so let's turn page

00:19:29,530 --> 00:19:38,200
and let's talk about for now I have told

00:19:35,110 --> 00:19:40,960
stories but what about trust

00:19:38,200 --> 00:19:44,800
so I use a trust what does it mean to

00:19:40,960 --> 00:19:50,350
use rust in these things and is it

00:19:44,800 --> 00:19:51,850
helping and well yes it does and the

00:19:50,350 --> 00:19:53,260
longer answer is it depends on how you

00:19:51,850 --> 00:19:58,120
structure your code and what you're

00:19:53,260 --> 00:20:00,700
after so the simplest way to write a

00:19:58,120 --> 00:20:03,220
logic for this thing is what people call

00:20:00,700 --> 00:20:06,430
the mega loop it's essentially a big

00:20:03,220 --> 00:20:11,680
loop that does read data from sensors

00:20:06,430 --> 00:20:14,350
think something and act on actuators do

00:20:11,680 --> 00:20:17,950
it again and you'll have to do it fast

00:20:14,350 --> 00:20:19,300
enough that it looks like real time this

00:20:17,950 --> 00:20:22,150
is what I was calling the event loop

00:20:19,300 --> 00:20:24,310
before this is the simplest possible

00:20:22,150 --> 00:20:27,730
approach is what actually Arduino

00:20:24,310 --> 00:20:29,890
encourages because it works it's very

00:20:27,730 --> 00:20:31,390
easy to reason about it's subtle

00:20:29,890 --> 00:20:34,330
imperative imperative of course that

00:20:31,390 --> 00:20:36,500
that's fine it's a small simple thing

00:20:34,330 --> 00:20:39,230
expand that it looks like this you know

00:20:36,500 --> 00:20:42,140
you had read that gives you data then

00:20:39,230 --> 00:20:44,950
think that takes the data takes probably

00:20:42,140 --> 00:20:48,980
a state and gives you the new state and

00:20:44,950 --> 00:20:51,290
commands to execute and then act that

00:20:48,980 --> 00:20:54,650
uses the commands to do things this is

00:20:51,290 --> 00:20:57,500
the main thing now you can write it more

00:20:54,650 --> 00:21:00,920
see like with the passing things by

00:20:57,500 --> 00:21:02,240
reference with mutations and in the end

00:21:00,920 --> 00:21:05,330
being realistic

00:21:02,240 --> 00:21:09,230
it ends up like this mutating things

00:21:05,330 --> 00:21:11,960
everywhere why because essentially when

00:21:09,230 --> 00:21:13,910
you everything is faithful because when

00:21:11,960 --> 00:21:16,130
you are reading data often you need to

00:21:13,910 --> 00:21:18,470
do timings because you need to measure

00:21:16,130 --> 00:21:21,050
the speed of things which means you need

00:21:18,470 --> 00:21:22,700
to remember the past values and the next

00:21:21,050 --> 00:21:25,480
ones and sometimes you are doing

00:21:22,700 --> 00:21:28,820
averages among values to taper off

00:21:25,480 --> 00:21:31,760
spikes or spools reads which means that

00:21:28,820 --> 00:21:34,010
the reading system is not stateless so

00:21:31,760 --> 00:21:37,880
it needs to have data in data out anyway

00:21:34,010 --> 00:21:40,390
and about the command system quite often

00:21:37,880 --> 00:21:43,100
you don't want to do all the possible

00:21:40,390 --> 00:21:45,530
activations every time you only want to

00:21:43,100 --> 00:21:47,510
change what changed for performance

00:21:45,530 --> 00:21:49,730
reasons especially on the graphical CV

00:21:47,510 --> 00:21:51,410
but sometimes also on physical things

00:21:49,730 --> 00:21:54,800
which means that you need to know the

00:21:51,410 --> 00:21:56,570
state of the thing now and compute what

00:21:54,800 --> 00:21:58,910
changes and only actuate will change it

00:21:56,570 --> 00:22:01,070
which means essentially every subsystem

00:21:58,910 --> 00:22:02,840
is stateful now you can think

00:22:01,070 --> 00:22:05,780
objectively nted and writing like this

00:22:02,840 --> 00:22:08,960
where we have this reader this state and

00:22:05,780 --> 00:22:12,440
this actuator which are stateful objects

00:22:08,960 --> 00:22:14,120
and then the data that that works is

00:22:12,440 --> 00:22:16,370
immutable actually so you take just the

00:22:14,120 --> 00:22:18,800
immutable data out of the reader pass

00:22:16,370 --> 00:22:21,230
that to the tinkerer that mutates the

00:22:18,800 --> 00:22:22,430
state but gives you an immutable command

00:22:21,230 --> 00:22:23,900
and then you give the command to the

00:22:22,430 --> 00:22:27,170
actuator this is one way to think about

00:22:23,900 --> 00:22:29,090
it all you can think in function observe

00:22:27,170 --> 00:22:30,560
the code you see this will not compile

00:22:29,090 --> 00:22:32,630
but you get the idea

00:22:30,560 --> 00:22:35,660
so essentially passing value backs on

00:22:32,630 --> 00:22:39,170
front every time and the funny thing is

00:22:35,660 --> 00:22:41,900
be happy because all these styles are

00:22:39,170 --> 00:22:43,820
fine is just your choice and the

00:22:41,900 --> 00:22:44,970
borrowed checker is helping you either

00:22:43,820 --> 00:22:46,799
way

00:22:44,970 --> 00:22:49,049
now the nice thing I showed you these

00:22:46,799 --> 00:22:49,679
different styles but plus gives you a

00:22:49,049 --> 00:22:52,769
choice

00:22:49,679 --> 00:22:54,210
you can either write code that well is

00:22:52,769 --> 00:22:56,749
not purely functional but say it's

00:22:54,210 --> 00:23:01,559
single function is a pure function and

00:22:56,749 --> 00:23:04,349
it actually probably quite likely since

00:23:01,559 --> 00:23:08,820
the compiler will do a lesion of the

00:23:04,349 --> 00:23:11,669
moves it will perform like C like code

00:23:08,820 --> 00:23:13,440
that is memory sharing so the code that

00:23:11,669 --> 00:23:15,210
I was showing before when you pass value

00:23:13,440 --> 00:23:18,119
in value out you pass the ownership the

00:23:15,210 --> 00:23:20,009
compiler is very likely to optimize the

00:23:18,119 --> 00:23:22,109
move out to say okay this is just this

00:23:20,009 --> 00:23:24,090
value so why should I have to copy it in

00:23:22,109 --> 00:23:26,039
and out so you write very high level

00:23:24,090 --> 00:23:30,119
code and the resulting machine code is

00:23:26,039 --> 00:23:32,399
high performance or you can say okay

00:23:30,119 --> 00:23:34,200
I've write it C style so I passed

00:23:32,399 --> 00:23:38,369
references all the time even mutable

00:23:34,200 --> 00:23:41,669
references but this C style code it is C

00:23:38,369 --> 00:23:43,619
style on the surface and in practice the

00:23:41,669 --> 00:23:46,049
borrow checker is enforcing that you

00:23:43,619 --> 00:23:49,139
don't do silly things so you can only

00:23:46,049 --> 00:23:51,090
mutate something one one one piece of

00:23:49,139 --> 00:23:54,359
code at a time you cannot share a

00:23:51,090 --> 00:23:56,700
mutable things and so on so in the end

00:23:54,359 --> 00:24:00,349
it doesn't really matter you pick your

00:23:56,700 --> 00:24:03,239
style and Trust is helping you now

00:24:00,349 --> 00:24:06,059
realistically the tinkerer function will

00:24:03,239 --> 00:24:08,340
become complex and becoming complex it

00:24:06,059 --> 00:24:10,830
will need to be materialized so you need

00:24:08,340 --> 00:24:13,919
to do some kind of splitting up there

00:24:10,830 --> 00:24:16,769
are several strategies to make this sync

00:24:13,919 --> 00:24:20,580
function it can be a very big match

00:24:16,769 --> 00:24:22,349
statement so or it can be a function

00:24:20,580 --> 00:24:23,999
pointer that changes from time to time

00:24:22,349 --> 00:24:26,609
so you actually are calling a different

00:24:23,999 --> 00:24:28,739
function from time to time all you can

00:24:26,609 --> 00:24:30,570
have many separated soup loops so you

00:24:28,739 --> 00:24:32,279
exhibit once you bloop to do an activity

00:24:30,570 --> 00:24:34,049
and another loop to do another activity

00:24:32,279 --> 00:24:37,830
and another loop to do another activity

00:24:34,049 --> 00:24:40,979
I tried probably all of them and you can

00:24:37,830 --> 00:24:44,190
just pick what you feel most sensible

00:24:40,979 --> 00:24:47,970
each one will work macros could help in

00:24:44,190 --> 00:24:50,129
the sub loops but again be happy because

00:24:47,970 --> 00:24:53,429
the rest type system is helping a lot

00:24:50,129 --> 00:24:55,379
what I found out is that the state can

00:24:53,429 --> 00:24:57,869
be an enum so it can have different

00:24:55,379 --> 00:24:58,680
shapes which means that according to

00:24:57,869 --> 00:25:01,350
what your robot

00:24:58,680 --> 00:25:04,200
doing to the context it is perfectly

00:25:01,350 --> 00:25:06,630
clear what kind of information it has in

00:25:04,200 --> 00:25:09,210
the state and what it can and cannot do

00:25:06,630 --> 00:25:11,310
on that so usually when you have a data

00:25:09,210 --> 00:25:12,960
structure in a language like C it is

00:25:11,310 --> 00:25:15,360
something like free form and memory

00:25:12,960 --> 00:25:17,100
representation so yes it is structured

00:25:15,360 --> 00:25:18,420
but in practice you can do whatever you

00:25:17,100 --> 00:25:21,690
want you have to be very disciplined

00:25:18,420 --> 00:25:24,180
while in rust if you design up front to

00:25:21,690 --> 00:25:27,300
the shape of your state then it's very

00:25:24,180 --> 00:25:29,910
hard to do mistake in the think function

00:25:27,300 --> 00:25:32,160
because you do pattern matching on the

00:25:29,910 --> 00:25:34,800
state and it's clear if it's either one

00:25:32,160 --> 00:25:38,220
thing or the other or the other it's

00:25:34,800 --> 00:25:39,900
really really hard to do mistakes as I

00:25:38,220 --> 00:25:42,060
said exhaustive pattern matching so it's

00:25:39,900 --> 00:25:47,330
in my opinion better than playing C or

00:25:42,060 --> 00:25:50,600
C++ so are we done and I say not really

00:25:47,330 --> 00:25:52,980
we still have this single mega loop and

00:25:50,600 --> 00:25:55,020
it means that the response time the

00:25:52,980 --> 00:25:55,830
latency is constrained by the loop

00:25:55,020 --> 00:25:58,440
complexity

00:25:55,830 --> 00:26:01,320
so essentially you process things at the

00:25:58,440 --> 00:26:03,480
speed of the loop if you wanted to

00:26:01,320 --> 00:26:08,340
process things at different speeds the

00:26:03,480 --> 00:26:10,290
code would be not so good and all the

00:26:08,340 --> 00:26:11,940
complexity is duty metal inside a single

00:26:10,290 --> 00:26:13,620
function it can be the composite

00:26:11,940 --> 00:26:16,980
hierarchically but in the end it's a

00:26:13,620 --> 00:26:20,100
single invocation now can we do better

00:26:16,980 --> 00:26:23,190
and the idea is that we would need a

00:26:20,100 --> 00:26:25,230
multitasking system however this means

00:26:23,190 --> 00:26:27,180
the scheduler under scheduler normally

00:26:25,230 --> 00:26:29,720
means overhead and you don't want

00:26:27,180 --> 00:26:32,160
overhead it's the small embedded system

00:26:29,720 --> 00:26:35,100
so and also it needs to be a real-time

00:26:32,160 --> 00:26:38,390
scheduler so it feels not bare metal

00:26:35,100 --> 00:26:41,760
anymore but there's this project called

00:26:38,390 --> 00:26:45,450
RTFM which would means real time for the

00:26:41,760 --> 00:26:47,190
masses I would like to thank her gap

00:26:45,450 --> 00:26:50,240
oratio I hope I pronounce the name well

00:26:47,190 --> 00:26:53,670
I met him in Paris and lustrous fast and

00:26:50,240 --> 00:26:55,740
this is a hardware scheduler so it's a

00:26:53,670 --> 00:26:58,860
rust library or framework or crate or

00:26:55,740 --> 00:27:00,840
whatever it's a crate and it's a

00:26:58,860 --> 00:27:03,930
hardware schedule that is interact Riven

00:27:00,840 --> 00:27:05,460
which means every task actually starts

00:27:03,930 --> 00:27:07,710
because of an interrupt the physical

00:27:05,460 --> 00:27:10,260
interrupts on the machine it runs to

00:27:07,710 --> 00:27:14,090
completion but they can overlap

00:27:10,260 --> 00:27:16,650
and the nice thing is that it has sub

00:27:14,090 --> 00:27:20,700
microsecond overhead because it's

00:27:16,650 --> 00:27:24,720
hardware level and it has Fearless

00:27:20,700 --> 00:27:26,610
concurrency because okay now a complete

00:27:24,720 --> 00:27:29,820
example remember this and bought this

00:27:26,610 --> 00:27:31,740
this robot with the ultrasound reading

00:27:29,820 --> 00:27:33,540
the ultrasound takes time you have to

00:27:31,740 --> 00:27:36,030
send the pools and wait for the reply

00:27:33,540 --> 00:27:37,560
what if you wanted to do something in

00:27:36,030 --> 00:27:40,410
the middle sometimes it takes something

00:27:37,560 --> 00:27:42,690
like one millisecond and health to wait

00:27:40,410 --> 00:27:45,660
for this echo I wanted to do something

00:27:42,690 --> 00:27:48,210
else so the idea would be I should fire

00:27:45,660 --> 00:27:50,040
an interrupt when I get the reply but

00:27:48,210 --> 00:27:52,890
then this means that the interrupt

00:27:50,040 --> 00:27:55,980
routine will have to mutate something

00:27:52,890 --> 00:28:00,960
that maybe I was using so this can get

00:27:55,980 --> 00:28:04,980
tricky and ok this this aside with voice

00:28:00,960 --> 00:28:07,920
and the magic of RTFM is that it uses

00:28:04,980 --> 00:28:11,040
the last type system and phantom markers

00:28:07,920 --> 00:28:13,500
which is I mean the values without sides

00:28:11,040 --> 00:28:15,330
but with particular types that are

00:28:13,500 --> 00:28:17,370
inserted in the data structure so that

00:28:15,330 --> 00:28:20,010
it can be markand with particular

00:28:17,370 --> 00:28:22,940
features and then essentially it will

00:28:20,010 --> 00:28:26,280
prove at compile time that there are no

00:28:22,940 --> 00:28:28,440
concurrency problems in the accesses

00:28:26,280 --> 00:28:30,990
which means that your interrupts will

00:28:28,440 --> 00:28:34,380
fire and will modify things and you will

00:28:30,990 --> 00:28:35,970
be okay and in my opinion this is very

00:28:34,380 --> 00:28:38,310
very nice magic that should be

00:28:35,970 --> 00:28:40,980
experimented more as far as I know right

00:28:38,310 --> 00:28:43,170
now it is only on armed contacts and and

00:28:40,980 --> 00:28:45,990
aware and Linux but that doesn't count

00:28:43,170 --> 00:28:48,570
and I'll explain why and this brings me

00:28:45,990 --> 00:28:50,550
to arm cortex-m this is where the real

00:28:48,570 --> 00:28:53,580
action is so I showed you toys on

00:28:50,550 --> 00:28:55,770
difficult platforms but if you want to

00:28:53,580 --> 00:28:57,600
do something about that just go here

00:28:55,770 --> 00:28:59,550
rath support is first-class it just

00:28:57,600 --> 00:29:02,730
works right now you don't even need

00:28:59,550 --> 00:29:04,560
another linker so the embedded link ship

00:29:02,730 --> 00:29:07,710
ad with rust will work for your embedded

00:29:04,560 --> 00:29:09,510
target and maybe it start with a tool

00:29:07,710 --> 00:29:11,610
called bobbing which is a common line to

00:29:09,510 --> 00:29:14,490
do compilation of projects but you can

00:29:11,610 --> 00:29:16,140
even do that without and what if you

00:29:14,490 --> 00:29:17,100
wanted to use Linux with your robots

00:29:16,140 --> 00:29:19,530
with rust

00:29:17,100 --> 00:29:22,290
well then rust support is perfect I mean

00:29:19,530 --> 00:29:24,120
it's the development experience is so

00:29:22,290 --> 00:29:27,060
easy it's just you

00:29:24,120 --> 00:29:28,770
host operating system on the target the

00:29:27,060 --> 00:29:30,480
problem is the real-time scheduler so at

00:29:28,770 --> 00:29:33,450
that point you will be either used priam

00:29:30,480 --> 00:29:36,510
30 and fight with Linux real-time a lot

00:29:33,450 --> 00:29:38,670
or stick to soft real-time another

00:29:36,510 --> 00:29:40,530
design could be put the hard real-time

00:29:38,670 --> 00:29:42,960
logic in a small embedded controller

00:29:40,530 --> 00:29:44,490
programmers with bare metal and if you

00:29:42,960 --> 00:29:46,770
have something fancy like image

00:29:44,490 --> 00:29:48,840
recognition sort whatever put that on a

00:29:46,770 --> 00:29:51,810
highlighter arm board like a Raspberry

00:29:48,840 --> 00:29:53,750
Pi and when you get data you feed the

00:29:51,810 --> 00:29:56,280
commands in real time with a serial line

00:29:53,750 --> 00:29:58,050
to do the real-time tasks and then

00:29:56,280 --> 00:30:03,510
probably this is a more sensible design

00:29:58,050 --> 00:30:06,930
in my opinion so to sum it up I say that

00:30:03,510 --> 00:30:08,640
rust on robots is greed it even runs on

00:30:06,930 --> 00:30:11,700
legal bricks right now which is amazing

00:30:08,640 --> 00:30:15,020
and the lag ones performs at least as

00:30:11,700 --> 00:30:20,880
well as C and the abstractions help you

00:30:15,020 --> 00:30:23,060
build better software that's all thanks

00:30:20,880 --> 00:30:23,060
a lot

00:30:26,030 --> 00:30:34,779
[Music]

00:30:29,820 --> 00:30:37,090
yeah yeah hold on one at a time so

00:30:34,779 --> 00:30:42,490
questions about how rust will kill all

00:30:37,090 --> 00:30:45,130
humans yeah thanks for the talk you

00:30:42,490 --> 00:30:47,049
didn't love rich research in how this

00:30:45,130 --> 00:30:49,210
all works with the compilers and crates

00:30:47,049 --> 00:30:51,490
and stuff it's 10 e resource where you

00:30:49,210 --> 00:30:55,870
wrote down all this so others can catch

00:30:51,490 --> 00:30:58,630
up to it ok unfortunately that's only

00:30:55,870 --> 00:31:01,590
destroyed because I did the research in

00:30:58,630 --> 00:31:04,389
a hurry because my real goal was not

00:31:01,590 --> 00:31:09,639
just this conference but the competition

00:31:04,389 --> 00:31:11,919
in one week so what I want to do is to

00:31:09,639 --> 00:31:13,809
publish most of the code that I brought

00:31:11,919 --> 00:31:16,570
so right now I work in a let's say a

00:31:13,809 --> 00:31:19,149
workspace we'd create all in the same

00:31:16,570 --> 00:31:21,399
repository I want to split the crate so

00:31:19,149 --> 00:31:23,649
that the the generic support platform

00:31:21,399 --> 00:31:25,870
support crates will be published and the

00:31:23,649 --> 00:31:28,059
robot code well not really because it

00:31:25,870 --> 00:31:30,370
doesn't make sense and also because the

00:31:28,059 --> 00:31:32,019
other members of my teams will just not

00:31:30,370 --> 00:31:34,779
be happy about it I probably share it

00:31:32,019 --> 00:31:37,600
but if anyway it's just robot specific

00:31:34,779 --> 00:31:39,639
code so probably what will happen is

00:31:37,600 --> 00:31:42,389
that I will do this split and publish

00:31:39,639 --> 00:31:42,389
the crates like that

00:31:47,970 --> 00:31:55,380
hi great talk were you able to get

00:31:51,350 --> 00:31:58,950
interrupts to work on a year we trust I

00:31:55,380 --> 00:32:02,370
didn't even try because the hardware

00:31:58,950 --> 00:32:06,540
platform that I was using essentially is

00:32:02,370 --> 00:32:08,730
has been designed for kids not for so it

00:32:06,540 --> 00:32:11,580
has the the things on the different on

00:32:08,730 --> 00:32:14,250
the wrong pins which means that I could

00:32:11,580 --> 00:32:17,610
not use this thing for the ultrasound

00:32:14,250 --> 00:32:20,190
and AVR is very limited limited anyway

00:32:17,610 --> 00:32:22,170
is that very small CPU so now I was

00:32:20,190 --> 00:32:23,760
thinking if you could if rust enables

00:32:22,170 --> 00:32:25,110
you to use interrupt service routines I

00:32:23,760 --> 00:32:27,540
have seen code that does it

00:32:25,110 --> 00:32:29,310
there is one attribute that you need to

00:32:27,540 --> 00:32:31,710
give to the function so that the

00:32:29,310 --> 00:32:34,860
function actually you know when you

00:32:31,710 --> 00:32:36,540
write something excellent see it's X and

00:32:34,860 --> 00:32:39,540
something and then the compiler

00:32:36,540 --> 00:32:41,550
understands that the ABI is interrupt

00:32:39,540 --> 00:32:48,420
service routine and then you can

00:32:41,550 --> 00:32:50,600
actually use it okay thank you no one

00:32:48,420 --> 00:32:50,600
else

00:32:53,020 --> 00:32:59,000
so how does your son feel about rust

00:32:55,820 --> 00:33:01,670
concurrency okay so initially he was

00:32:59,000 --> 00:33:02,330
scared because I was clear with him

00:33:01,670 --> 00:33:04,520
upfront

00:33:02,330 --> 00:33:07,340
I explained him the issue with memory

00:33:04,520 --> 00:33:10,700
management and the point that is was not

00:33:07,340 --> 00:33:13,520
exposed to see like errors but he had

00:33:10,700 --> 00:33:16,370
the borrowed checker and initially he

00:33:13,520 --> 00:33:18,350
was resisting because he said go long is

00:33:16,370 --> 00:33:20,750
so simple and in my opinion he's right

00:33:18,350 --> 00:33:22,840
by the way golang is exceptional as a

00:33:20,750 --> 00:33:25,880
programming language for the simplicity

00:33:22,840 --> 00:33:28,430
but right now as far as I know he is at

00:33:25,880 --> 00:33:34,100
home adapting the code of one robot to

00:33:28,430 --> 00:33:40,979
another robot in rust so that's it

00:33:34,100 --> 00:33:40,979
[Applause]

00:33:43,039 --> 00:33:57,899
there was another question there yes we

00:33:55,529 --> 00:34:05,690
have a yeah we can recover some time for

00:33:57,899 --> 00:34:08,220
questions um you said the there was

00:34:05,690 --> 00:34:09,599
sorry in your second last slide you're

00:34:08,220 --> 00:34:12,389
talking about the difficulties with

00:34:09,599 --> 00:34:14,399
preempt Archie um could you elaborate a

00:34:12,389 --> 00:34:16,530
little bit on that okay so the problem

00:34:14,399 --> 00:34:18,599
is that Linux is not a real-time

00:34:16,530 --> 00:34:20,669
operating system which means that

00:34:18,599 --> 00:34:22,200
sometimes you enter the kernel and

00:34:20,669 --> 00:34:25,560
though you have no idea when you will

00:34:22,200 --> 00:34:28,589
get out of it and as I said this is not

00:34:25,560 --> 00:34:31,440
good now over the over time there has

00:34:28,589 --> 00:34:33,780
been a patch maintain it over the kernel

00:34:31,440 --> 00:34:35,810
which is called the real-time patch that

00:34:33,780 --> 00:34:40,530
adds real-time features to the kernel

00:34:35,810 --> 00:34:43,409
bringing it to almost real-time status

00:34:40,530 --> 00:34:46,379
it is not perfect because it's not being

00:34:43,409 --> 00:34:49,530
designed from the start to do that but

00:34:46,379 --> 00:34:51,750
it's almost there I am aware of cases

00:34:49,530 --> 00:34:54,659
where person so if you have a raspberry

00:34:51,750 --> 00:34:57,210
pi a quad core one I know that people

00:34:54,659 --> 00:35:00,240
have essentially dedicated one core of

00:34:57,210 --> 00:35:02,640
the four to a single process that does

00:35:00,240 --> 00:35:05,790
nothing else that answering to

00:35:02,640 --> 00:35:07,500
interrupts from an SPI line and this in

00:35:05,790 --> 00:35:10,079
my opinion is a very very interesting

00:35:07,500 --> 00:35:12,450
concept so you have a very high level

00:35:10,079 --> 00:35:15,569
operating system on the other course you

00:35:12,450 --> 00:35:18,119
can even run a web server but on this

00:35:15,569 --> 00:35:20,250
score is essentially it's real time

00:35:18,119 --> 00:35:22,319
working on a single serial line now

00:35:20,250 --> 00:35:24,390
probably on this SPI you are going to

00:35:22,319 --> 00:35:26,460
talk to another CPU which is a real-time

00:35:24,390 --> 00:35:28,890
one which does the real thing but then

00:35:26,460 --> 00:35:31,020
it's it's sensible because you can write

00:35:28,890 --> 00:35:33,869
high-level logic like a webs web

00:35:31,020 --> 00:35:35,670
interaction server which is totally soft

00:35:33,869 --> 00:35:37,619
real-time you really don't care there

00:35:35,670 --> 00:35:39,839
but then you can interface with real

00:35:37,619 --> 00:35:43,790
things so that's the route I would take

00:35:39,839 --> 00:35:43,790
that could hang things

00:35:45,130 --> 00:35:51,630
well thank you very much be done here

00:35:47,869 --> 00:35:57,119
give a round of applause yeah

00:35:51,630 --> 00:35:57,119

YouTube URL: https://www.youtube.com/watch?v=bmQw5zIP8pA


