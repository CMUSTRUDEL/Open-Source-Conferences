Title: Async-Await WG: Niko + Taylor discuss region inferencer
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	cramertj and nikomatsakis discuss changes to the region inferencer to try and overcome some of the limitations from https://github.com/rust-lang/rust/issues/56238. In the process, we uncover some strangeness.

Paper doc:

https://paper.dropbox.com/doc/Multiple-Unrelated-Lifetimes-in-Existential-Types--AbbZKR~LigYmDVvXErd4OO0~Ag-AuCQq4Ewy39j8Hnj3n9Qg
Captions: 
	00:00:00,350 --> 00:00:13,530
okay recording started so yeah that's

00:00:04,940 --> 00:00:56,989
multiple abundant meeting with you here

00:00:13,530 --> 00:01:03,660
I guess I'll share it thing I've learned

00:00:56,989 --> 00:01:10,710
Firefox does not use the Windows

00:01:03,660 --> 00:01:17,310
notification system and therefore and

00:01:10,710 --> 00:01:18,930
sharing them to be no consumes it will

00:01:17,310 --> 00:01:21,930
display you unless you disable the no

00:01:18,930 --> 00:01:38,100
tikis display accordion for posterity

00:01:21,930 --> 00:01:49,229
which is usually not alright so what we

00:01:38,100 --> 00:01:51,299
want so basically I'm just talking the

00:01:49,229 --> 00:01:53,790
existing in terms of how this works for

00:01:51,299 --> 00:01:55,200
types um and and I'm trying to like

00:01:53,790 --> 00:01:55,829
relate it to how it should work for

00:01:55,200 --> 00:01:58,710
lifetimes

00:01:55,829 --> 00:02:01,920
so in particular there's this rule

00:01:58,710 --> 00:02:05,850
that's a little bit tricky which is that

00:02:01,920 --> 00:02:09,530
defining uses of existential types must

00:02:05,850 --> 00:02:09,530
leave all of their

00:02:11,700 --> 00:02:16,470
like all new generic in the type or they

00:02:15,000 --> 00:02:18,989
must be like fully wearing it because

00:02:16,470 --> 00:02:22,530
otherwise you don't know whether or not

00:02:18,989 --> 00:02:26,459
a particular parameter is used or not

00:02:22,530 --> 00:02:28,380
from in the central type right yes this

00:02:26,459 --> 00:02:34,410
is the difference higher were kind of

00:02:28,380 --> 00:02:35,519
unification and so the thing I was

00:02:34,410 --> 00:02:37,470
trying to write down that I was just

00:02:35,519 --> 00:02:39,930
getting to is that I think that this is

00:02:37,470 --> 00:02:45,540
murder actually four lifetimes because

00:02:39,930 --> 00:02:47,670
lifetimes also have subtyping yes and I

00:02:45,540 --> 00:02:50,340
was just trying to figure out like what

00:02:47,670 --> 00:02:53,430
things we like actually can and can't

00:02:50,340 --> 00:02:58,140
allow particular it seems like if you

00:02:53,430 --> 00:03:02,299
have so I think that the pattern

00:02:58,140 --> 00:03:02,299
unification constrained is actually not

00:03:02,470 --> 00:03:10,769
[Music]

00:03:07,549 --> 00:03:13,319
I agree something mid supporter what's

00:03:10,769 --> 00:03:15,780
going to that a little bit in async FN

00:03:13,319 --> 00:03:20,940
in particular we can like you can ignore

00:03:15,780 --> 00:03:21,600
this a little bit typeset that's gonna

00:03:20,940 --> 00:03:24,690
fall apart

00:03:21,600 --> 00:03:28,280
great cuz like in an async I've had me

00:03:24,690 --> 00:03:32,130
know that this is the only use like

00:03:28,280 --> 00:03:33,930
NSYNC FN use like must be a defining use

00:03:32,130 --> 00:03:34,950
and it doesn't make sense like it

00:03:33,930 --> 00:03:36,870
doesn't even make sense to talk about

00:03:34,950 --> 00:03:38,850
unused type parameters in that case

00:03:36,870 --> 00:03:42,510
right because the type typewriters that

00:03:38,850 --> 00:03:44,970
are in the single type exactly

00:03:42,510 --> 00:03:49,280
correspond to those that are on the

00:03:44,970 --> 00:03:51,840
function you're talking about the

00:03:49,280 --> 00:03:54,900
pattern unification that's great now or

00:03:51,840 --> 00:03:56,340
something right because because the it

00:03:54,900 --> 00:03:58,530
doesn't even it doesn't make sense good

00:03:56,340 --> 00:04:00,209
to have that constraint in async FN

00:03:58,530 --> 00:04:02,890
because there you know there is exactly

00:04:00,209 --> 00:04:09,910
one use of XS

00:04:02,890 --> 00:04:11,350
uses every lifetime that is inferred and

00:04:09,910 --> 00:04:14,860
if it doesn't you can just forget about

00:04:11,350 --> 00:04:16,299
them completely right I think it let's

00:04:14,860 --> 00:04:19,030
come back to it I think it makes sense

00:04:16,299 --> 00:04:21,670
but but the subtyping you're not wrong

00:04:19,030 --> 00:04:23,140
that the subtyping makes it I mean it's

00:04:21,670 --> 00:04:27,130
not that it makes it harder per se but

00:04:23,140 --> 00:04:30,400
it adds some extra fun because like we

00:04:27,130 --> 00:04:33,760
have can we sort of have think what you

00:04:30,400 --> 00:04:36,850
were going to get out was if I write

00:04:33,760 --> 00:04:39,280
about the constraint beat out live a and

00:04:36,850 --> 00:04:43,090
then that still gives like doesn't give

00:04:39,280 --> 00:05:06,400
me a defining you right because I could

00:04:43,090 --> 00:05:07,900
be meaning to curse so I think like if

00:05:06,400 --> 00:05:12,160
you're ignore they the infants problem

00:05:07,900 --> 00:05:14,950
for a second and subtyping isn't

00:05:12,160 --> 00:05:20,919
particularly problematic obviously

00:05:14,950 --> 00:05:26,290
because right there's some type phase in

00:05:20,919 --> 00:05:36,910
this case the gay into bingo and you

00:05:26,290 --> 00:05:39,220
know we can decide I think that the the

00:05:36,910 --> 00:05:40,660
way I was thinking about this we explain

00:05:39,220 --> 00:05:43,810
how our state and think it'll come to

00:05:40,660 --> 00:05:47,470
some topics I mean one thing is to back

00:05:43,810 --> 00:05:49,330
up the thing about not allow the pattern

00:05:47,470 --> 00:05:52,960
unification constraint the key point

00:05:49,330 --> 00:05:58,180
there is that we've basically refused to

00:05:52,960 --> 00:06:02,140
guess right like and I think that's the

00:05:58,180 --> 00:06:04,780
thing we have to preserve but I guess

00:06:02,140 --> 00:06:06,340
like my question is like freezing FN we

00:06:04,780 --> 00:06:08,740
kind of almost want different rules

00:06:06,340 --> 00:06:11,580
because b we can it you know it's fine

00:06:08,740 --> 00:06:11,580
to guess right

00:06:12,220 --> 00:06:18,380
because there because there's only one

00:06:14,360 --> 00:06:20,150
usage don't like if we if we get

00:06:18,380 --> 00:06:28,940
something and it like works for that

00:06:20,150 --> 00:06:30,620
usage it's fine like right that makes

00:06:28,940 --> 00:06:35,240
sense man we might want to do some more

00:06:30,620 --> 00:06:38,060
aggressive for cases I think that would

00:06:35,240 --> 00:06:40,190
apply also to infiltrate generally any

00:06:38,060 --> 00:06:44,600
case where we know there's one defining

00:06:40,190 --> 00:06:46,820
use but yeah it would prefer I guess I

00:06:44,600 --> 00:06:49,880
think we should think about where the

00:06:46,820 --> 00:06:58,340
guessing is and see if we with not doing

00:06:49,880 --> 00:07:08,900
it I mean the reason it seems to me that

00:06:58,340 --> 00:07:11,660
subtly makes it harder so there's two

00:07:08,900 --> 00:07:12,820
cases to me there's even even without

00:07:11,660 --> 00:07:16,700
that case

00:07:12,820 --> 00:07:21,670
even without the tonight too because you

00:07:16,700 --> 00:07:32,720
can have just go back to everyone

00:07:21,670 --> 00:07:51,290
yep we're gonna wind up with we will

00:07:32,720 --> 00:08:02,390
create a creative and then we will infer

00:07:51,290 --> 00:08:08,540
a constraint like yeah we're gonna infer

00:08:02,390 --> 00:08:13,120
I'm gonna say so this is the type of X

00:08:08,540 --> 00:08:16,130
gonna find it has to be a subtype of

00:08:13,120 --> 00:08:26,480
this P we're gonna infer that this must

00:08:16,130 --> 00:08:45,110
be interesting and take zero yep and

00:08:26,480 --> 00:08:51,760
we're going to infer and now our problem

00:08:45,110 --> 00:08:57,830
is we also know because of the

00:08:51,760 --> 00:09:00,290
constraints on just because of the

00:08:57,830 --> 00:09:05,690
general setup that takes zero has to be

00:09:00,290 --> 00:09:12,920
like you know to guarantee right yeah I

00:09:05,690 --> 00:09:17,590
guess we could throw into ecstatic yeah

00:09:12,920 --> 00:09:20,870
I guess I'll take I'm dr8 wait to get

00:09:17,590 --> 00:09:24,580
sorry I'm not very comfortable with to

00:09:20,870 --> 00:09:24,580
get the escaping into the wild like this

00:09:28,820 --> 00:09:31,859
[Music]

00:09:33,250 --> 00:09:46,610
so and these we don't have any yeah

00:09:43,250 --> 00:09:48,920
problem here is that like one problem we

00:09:46,610 --> 00:09:54,050
have for our current solver the way it

00:09:48,920 --> 00:09:57,880
works is that it tries to sort of start

00:09:54,050 --> 00:10:00,500
small and grow bigger but there's no

00:09:57,880 --> 00:10:02,870
there's kind of no constraint on to zero

00:10:00,500 --> 00:10:03,470
in to go and in well they're only this

00:10:02,870 --> 00:10:05,180
loud lives

00:10:03,470 --> 00:10:10,160
there's nothing worked to zero there's

00:10:05,180 --> 00:10:15,950
something else right that kind of comes

00:10:10,160 --> 00:10:16,910
because of this constraint yep so that's

00:10:15,950 --> 00:10:18,290
why we're getting started

00:10:16,910 --> 00:10:25,670
because we went we wanted to translate

00:10:18,290 --> 00:10:26,700
back to our lives but there and so what

00:10:25,670 --> 00:10:29,749
I was thinking is

00:10:26,700 --> 00:10:29,749
[Music]

00:10:30,050 --> 00:10:38,009
let me see

00:10:31,560 --> 00:10:39,420
so let's ignore that for a second so in

00:10:38,009 --> 00:10:41,060
terms of the pattern unification

00:10:39,420 --> 00:10:47,009
constraint I guess what you're saying is

00:10:41,060 --> 00:10:47,399
that like in this example the way it's

00:10:47,009 --> 00:10:49,050
set up

00:10:47,399 --> 00:10:52,009
we have only one solution to this

00:10:49,050 --> 00:10:55,980
problem just the tick's ero has to be 2k

00:10:52,009 --> 00:10:57,629
tippy has to be ticked and you can just

00:10:55,980 --> 00:10:59,129
sort of enumerate all the possibilities

00:10:57,629 --> 00:11:01,860
and see that that's the only one that

00:10:59,129 --> 00:11:04,439
works right right but if we add the

00:11:01,860 --> 00:11:06,240
subtyping into it or if we give a

00:11:04,439 --> 00:11:08,249
relationship which we took me in today

00:11:06,240 --> 00:11:11,339
and that wouldn't be true

00:11:08,249 --> 00:11:12,540
and we have some choice late that's not

00:11:11,339 --> 00:11:15,809
the place where you have multiple

00:11:12,540 --> 00:11:17,850
choices of whether or not to be has

00:11:15,809 --> 00:11:27,629
emulation to the problem at all right

00:11:17,850 --> 00:11:29,639
like you can choose to you could choose

00:11:27,629 --> 00:11:31,170
to be dub you to either tick static to

00:11:29,639 --> 00:11:33,259
be or Takei and it would make no

00:11:31,170 --> 00:11:38,189
difference

00:11:33,259 --> 00:11:42,300
you can choose tick tick 1 to be okay to

00:11:38,189 --> 00:12:22,670
be but not ecstatic it can be either

00:11:42,300 --> 00:12:25,980
today or ticks and one question good I

00:12:22,670 --> 00:12:28,370
mean do we ever clear so apart from the

00:12:25,980 --> 00:12:30,660
as you said leaving aside the book

00:12:28,370 --> 00:12:32,710
assuming we only know somehow there's

00:12:30,660 --> 00:12:36,099
only one defining use for the moment

00:12:32,710 --> 00:12:36,099
[Music]

00:12:38,470 --> 00:12:56,600
do we ever care how that's like suppose

00:12:44,959 --> 00:12:59,089
we picked it seems like we don't care it

00:12:56,600 --> 00:13:01,190
doesn't matter what we choose here like

00:12:59,089 --> 00:13:06,009
as long as it satisfies these music

00:13:01,190 --> 00:13:06,009
constraints our callers are not so

00:13:07,449 --> 00:13:12,709
basically nobody is that true it's

00:13:10,819 --> 00:13:16,100
probably true it could matter for

00:13:12,709 --> 00:13:18,560
something like I mean it is true if you

00:13:16,100 --> 00:13:21,290
go if you went to go add another

00:13:18,560 --> 00:13:28,100
function it's unclear which one you

00:13:21,290 --> 00:13:32,560
would allow right I think it's I think

00:13:28,100 --> 00:13:39,050
the caller might care even if they can't

00:13:32,560 --> 00:13:44,079
we might care because they can see

00:13:39,050 --> 00:13:46,310
whether it's sand or mud and because

00:13:44,079 --> 00:13:49,000
conditionally implement send based on

00:13:46,310 --> 00:13:54,170
whether or not the the second parameter

00:13:49,000 --> 00:13:58,220
lifetime perimeter was used possibly you

00:13:54,170 --> 00:14:02,720
could say you could maybe set up some

00:13:58,220 --> 00:14:04,130
scenario where picking one here's sort

00:14:02,720 --> 00:14:05,899
of that like the concrete type beliefs

00:14:04,130 --> 00:14:07,550
and technically we allow it to leap

00:14:05,899 --> 00:14:09,529
within the module so clearly it would

00:14:07,550 --> 00:14:11,029
like you would determine whether or not

00:14:09,529 --> 00:14:14,300
things in the module could compile

00:14:11,029 --> 00:14:16,040
because they would like it would be able

00:14:14,300 --> 00:14:20,930
to have visibility into that different

00:14:16,040 --> 00:14:25,160
distinction right so obviously if they

00:14:20,930 --> 00:14:26,269
have full visibility then take care but

00:14:25,160 --> 00:14:28,490
I was trying to figure out as if they

00:14:26,269 --> 00:14:34,069
and we have a partial disability but it

00:14:28,490 --> 00:14:35,600
seems like they probably care I mean I

00:14:34,069 --> 00:14:39,639
certainly think it's true that like they

00:14:35,600 --> 00:14:39,639
don't care in a sink a Faton

00:14:40,439 --> 00:14:48,069
it seems like a pretty young unlikely

00:14:45,220 --> 00:14:51,100
scenario that's gonna matter but I guess

00:14:48,069 --> 00:14:57,519
it but it's worth when an ecologist I

00:14:51,100 --> 00:14:59,259
guess it would be something like and I

00:14:57,519 --> 00:15:05,049
think what even it would be what could

00:14:59,259 --> 00:15:10,809
you put in I mean you could just do in

00:15:05,049 --> 00:15:24,069
pull where where foo is of tick tick a

00:15:10,809 --> 00:15:32,919
Takei right yeah so then then it would

00:15:24,069 --> 00:15:37,230
be like if we inferred right so that

00:15:32,919 --> 00:15:40,149
would that would affect infiltrate right

00:15:37,230 --> 00:15:41,919
and it would affect existential type but

00:15:40,149 --> 00:15:43,419
it won't affect a sink mmm because we

00:15:41,919 --> 00:15:49,869
know that stupid things like that

00:15:43,419 --> 00:15:51,129
hopefully don't exist not sure why it

00:15:49,869 --> 00:15:53,619
doesn't affect they seem different

00:15:51,129 --> 00:15:58,959
I mean I can't think of an instance in a

00:15:53,619 --> 00:16:02,069
sink FN where I mean if you had our that

00:15:58,959 --> 00:16:02,069
closes over a fool

00:16:03,179 --> 00:16:28,179
yeah I'm trying to think about how that

00:16:05,739 --> 00:16:30,519
would work maybe maybe you could yeah I

00:16:28,179 --> 00:16:33,449
mean just get rid of the food here right

00:16:30,519 --> 00:16:41,639
and then you just capture it

00:16:33,449 --> 00:16:41,639
yeah we know like you know XY

00:16:43,970 --> 00:17:01,380
yowzers X whatever right now it's part

00:16:57,269 --> 00:17:04,110
of the lunging right it's part of the

00:17:01,380 --> 00:17:08,510
type but also in this case you don't

00:17:04,110 --> 00:17:12,299
have to do like you're not having to

00:17:08,510 --> 00:17:14,370
this inference I guess because we know

00:17:12,299 --> 00:17:15,839
we know exactly what the parameters are

00:17:14,370 --> 00:17:20,839
being like parameters are being applied

00:17:15,839 --> 00:17:20,839
to the closure right is my point like

00:17:20,959 --> 00:17:26,130
like it's sort of special that there's

00:17:23,160 --> 00:17:33,110
like a unique exact choice of all of the

00:17:26,130 --> 00:17:37,049
parameters yeah anything else is like

00:17:33,110 --> 00:17:38,750
something some information being lost in

00:17:37,049 --> 00:17:41,640
the middle when we do the D sugaring

00:17:38,750 --> 00:17:49,559
like and then like trying to rediscover

00:17:41,640 --> 00:17:52,650
that information cuz like you agree that

00:17:49,559 --> 00:17:55,080
like like X here in this code like in

00:17:52,650 --> 00:18:03,030
normal rust that has an unambiguous type

00:17:55,080 --> 00:18:12,720
which is like foo of take a check B we

00:18:03,030 --> 00:18:14,370
don't okay which you will infer that he

00:18:12,720 --> 00:18:18,299
might infer it to me to get to people we

00:18:14,370 --> 00:18:22,110
might also infer how to send some reason

00:18:18,299 --> 00:18:27,929
to know something doesn't mean this is

00:18:22,110 --> 00:18:29,520
already a problem today why is this a

00:18:27,929 --> 00:18:30,470
problem unstable basically is my

00:18:29,520 --> 00:18:34,049
question

00:18:30,470 --> 00:18:36,929
is it not cuz I can why I can certainly

00:18:34,049 --> 00:18:39,980
return an infiltrate type that it

00:18:36,929 --> 00:18:46,970
references multiple lifetimes right oh

00:18:39,980 --> 00:18:46,970
but they have to have a relationship so

00:18:47,950 --> 00:18:52,420
and they must all outlive the same

00:18:49,750 --> 00:18:54,640
lifetime great but that's still not

00:18:52,420 --> 00:18:57,160
enough so there's the kind of whacky

00:18:54,640 --> 00:19:02,800
treatment which might be broken you know

00:18:57,160 --> 00:19:08,560
for generators like the captured pipes

00:19:02,800 --> 00:19:10,180
you kind of erased like plans yeah I'm

00:19:08,560 --> 00:19:17,440
gonna do this for clunkers too right

00:19:10,180 --> 00:19:27,130
please probably just wouldn't let's try

00:19:17,440 --> 00:19:37,750
it out so the situation would be

00:19:27,130 --> 00:19:56,740
something like is something I can't wait

00:19:37,750 --> 00:19:58,150
very usable I mean just yield oh well I

00:19:56,740 --> 00:20:00,610
can't write this code today because I

00:19:58,150 --> 00:20:03,100
can't have these two parameters right I

00:20:00,610 --> 00:20:04,720
mean there is a thing you can you I'm

00:20:03,100 --> 00:20:06,070
certain the thirties a thing you can

00:20:04,720 --> 00:20:08,970
write on stable today that also has this

00:20:06,070 --> 00:20:08,970
problem and I'm here

00:20:26,150 --> 00:20:32,589
[Music]

00:20:39,800 --> 00:20:42,859
[Music]

00:20:46,710 --> 00:21:02,549
I really wish been meeting sorry would

00:21:00,840 --> 00:21:09,659
be nice if we had made it look people

00:21:02,549 --> 00:21:13,669
stop we're always like taking a week I

00:21:09,659 --> 00:21:13,669
don't know it solves so many problems

00:21:17,570 --> 00:21:25,909
are you typing into a plate I'm typing

00:21:22,200 --> 00:21:25,909
into a play that I will chair and

00:21:33,810 --> 00:21:36,890
[Music]

00:22:42,850 --> 00:22:45,920
[Music]

00:23:03,200 --> 00:23:13,700
okay so you I'll show you what I'm

00:23:05,520 --> 00:23:13,700
thinking and let me share this big round

00:23:14,390 --> 00:23:34,890
okay yeah I put a link on the docks and

00:23:21,390 --> 00:23:39,179
like oh I need a plastic a take a life

00:23:34,890 --> 00:23:40,620
come on food in fur to work be a

00:23:39,179 --> 00:23:48,029
subtyping but it actually doesn't make

00:23:40,620 --> 00:23:51,960
complains that you're capturing to be I

00:23:48,029 --> 00:23:55,980
don't wants to gay there and not

00:23:51,960 --> 00:24:00,929
actually fails which is sort of

00:23:55,980 --> 00:24:02,640
interesting this one yeah

00:24:00,929 --> 00:24:04,830
which is which is sort of interesting

00:24:02,640 --> 00:24:06,059
because it's doing the captures lifetime

00:24:04,830 --> 00:24:08,100
that doesn't appear in bounds even

00:24:06,059 --> 00:24:12,929
though like it could do a subtyping

00:24:08,100 --> 00:24:23,610
coercion they would make it outlive the

00:24:12,929 --> 00:24:30,770
bounds yeah I wonder if like it might be

00:24:23,610 --> 00:24:35,549
because we remember if we make closures

00:24:30,770 --> 00:24:40,770
generic over birth they might be

00:24:35,549 --> 00:24:45,450
invariant or something there's some sort

00:24:40,770 --> 00:24:48,980
of crazy magic that's saving our bacon

00:24:45,450 --> 00:24:51,200
here so well

00:24:48,980 --> 00:24:57,490
Sears I'm right in principle it could

00:24:51,200 --> 00:24:57,490
have captured this to food today today

00:24:59,980 --> 00:25:05,380
and then we would have this problem that

00:25:05,410 --> 00:25:10,670
right you had to choose between two

00:25:07,820 --> 00:25:15,800
gating be educated a and depending on

00:25:10,670 --> 00:25:19,520
what it shows vitamin D Center and right

00:25:15,800 --> 00:25:22,220
now it happens not for reasons but it

00:25:19,520 --> 00:25:24,050
looks like it's very interesting that it

00:25:22,220 --> 00:25:37,640
we seeing with your daughters to K

00:25:24,050 --> 00:25:49,460
together suggests it almost one too yeah

00:25:37,640 --> 00:25:54,500
so how much we can do about why why do

00:25:49,460 --> 00:25:56,540
you return your closure I'm just having

00:25:54,500 --> 00:25:58,400
something that captured it but well yeah

00:25:56,540 --> 00:26:05,920
I think it is I think it is actually the

00:25:58,400 --> 00:26:05,920
closure issues the same sorry

00:26:07,300 --> 00:26:12,830
so I was like so I actually just need to

00:26:11,360 --> 00:26:17,660
change I'm gonna change it Zambia

00:26:12,830 --> 00:26:21,890
closure because I just made it I just

00:26:17,660 --> 00:26:23,840
made it return like that's like an

00:26:21,890 --> 00:26:30,080
explicit function to coerce both the

00:26:23,840 --> 00:26:36,050
lifetimes to be the same thing why the

00:26:30,080 --> 00:26:38,600
coach is trying to use something that

00:26:36,050 --> 00:27:14,810
captured it like Mikey right with this

00:26:38,600 --> 00:27:33,140
scenario right here it's not it's not

00:27:14,810 --> 00:27:45,110
actually the case then it meets the

00:27:33,140 --> 00:27:47,120
constraints that the actual constraint

00:27:45,110 --> 00:27:48,890
it's not it's not doing this because of

00:27:47,120 --> 00:27:50,510
the insulin function ray it's doing this

00:27:48,890 --> 00:27:56,930
because of the plastic a on the

00:27:50,510 --> 00:27:58,370
infiltrate yeah constraints generator

00:27:56,930 --> 00:28:03,500
from here happened to generate one that

00:27:58,370 --> 00:28:05,930
is that you give it a choice today when

00:28:03,500 --> 00:28:08,870
we're doing the infiltrate lifetime

00:28:05,930 --> 00:28:12,010
messiness we only give it a choice to

00:28:08,870 --> 00:28:16,570
pick like today or at ecstatic right

00:28:12,010 --> 00:28:16,570
allow it to choose any other lifetimes

00:28:18,640 --> 00:28:24,130
it's kind of hard to force it onto I

00:28:20,900 --> 00:28:24,130
think we could force it not to buy

00:28:27,310 --> 00:28:34,249
[Music]

00:28:43,310 --> 00:28:46,400
[Music]

00:28:52,130 --> 00:29:06,690
like in this case feet no matter what we

00:29:01,080 --> 00:29:08,250
do we actually know the code I mean so

00:29:06,690 --> 00:29:10,200
there's there's a broken thing here

00:29:08,250 --> 00:29:11,429
right which is that if we did the

00:29:10,200 --> 00:29:13,679
expansion that we were talking about

00:29:11,429 --> 00:29:17,490
temple tree to make it so you didn't

00:29:13,679 --> 00:29:19,980
need that captures hack then it would be

00:29:17,490 --> 00:29:22,559
allowed to capture Tech B and in if some

00:29:19,980 --> 00:29:38,190
would fail so that's like a breaking

00:29:22,559 --> 00:29:42,389
change because of this when you pass it

00:29:38,190 --> 00:29:44,130
to his send know probably that but it's

00:29:42,389 --> 00:29:46,769
not first to pick tickly just because it

00:29:44,130 --> 00:29:49,350
can write and here I think it would not

00:29:46,769 --> 00:29:53,639
it still would pick the minimal decide

00:29:49,350 --> 00:29:55,529
for instance why tonight I mean you

00:29:53,639 --> 00:29:58,980
could you could make the algorithm still

00:29:55,529 --> 00:30:01,289
prefer to K right but that's what I'm

00:29:58,980 --> 00:30:05,820
saying there's like arbitrary what it's

00:30:01,289 --> 00:30:07,799
choosing this yes at least have a

00:30:05,820 --> 00:30:12,389
selection and which one it chose would

00:30:07,799 --> 00:30:17,760
matter yes yeah it still has a sergeants

00:30:12,389 --> 00:30:20,610
way it just it picks them in yeah what

00:30:17,760 --> 00:30:23,730
would I guess what were changes that you

00:30:20,610 --> 00:30:29,149
might not have included this plus decay

00:30:23,730 --> 00:30:32,580
at all anyway that's another problem I

00:30:29,149 --> 00:30:36,659
agree that that like there might there's

00:30:32,580 --> 00:30:44,580
probably somewhere out situation here

00:30:36,659 --> 00:30:46,350
but trying to think even with the

00:30:44,580 --> 00:30:49,200
alternative of the plus today is the

00:30:46,350 --> 00:30:51,230
like in pole you know some treat generic

00:30:49,200 --> 00:30:56,720
on take a right

00:30:51,230 --> 00:30:56,720
[Music]

00:31:25,240 --> 00:31:28,299
[Music]

00:31:45,040 --> 00:31:48,190
[Music]

00:31:50,560 --> 00:31:53,660
[Music]

00:32:10,350 --> 00:32:13,590
[Music]

00:32:26,320 --> 00:32:30,110
now we get this error because we're

00:32:28,340 --> 00:32:42,290
forced to countries would be but we

00:32:30,110 --> 00:32:45,770
didn't come back sis there is something

00:32:42,290 --> 00:32:51,890
I mean the bottom line is we've already

00:32:45,770 --> 00:32:54,950
sort of encoded the idea that we yeah

00:32:51,890 --> 00:32:57,860
sometimes they're making choices some

00:32:54,950 --> 00:32:59,800
arbitrarily that are equivalent to the

00:32:57,860 --> 00:33:04,090
choice that would be forced to make here

00:32:59,800 --> 00:33:07,210
the only complication here the additives

00:33:04,090 --> 00:33:10,930
would have to do it fact that this one

00:33:07,210 --> 00:33:14,320
type variable in this case also in the

00:33:10,930 --> 00:33:18,630
ASIC effect we at least know it both set

00:33:14,320 --> 00:33:23,020
of constraints apply to the given title

00:33:18,630 --> 00:33:24,940
since they're from the people you don't

00:33:23,020 --> 00:33:27,850
know about the is send explain obviously

00:33:24,940 --> 00:33:30,400
but we know about from the define the

00:33:27,850 --> 00:33:32,650
definer was a single definer and it

00:33:30,400 --> 00:33:38,440
defines anything instead of constraints

00:33:32,650 --> 00:33:44,050
to which we defined yes but in the case

00:33:38,440 --> 00:33:49,600
where there's more than one function no

00:33:44,050 --> 00:33:52,320
one function has it would sort of matter

00:33:49,600 --> 00:34:04,270
which one first

00:33:52,320 --> 00:34:05,800
actually I mean he wanted it we had this

00:34:04,270 --> 00:34:08,680
idea that we wanted to leave it like

00:34:05,800 --> 00:34:14,200
every different independently came to

00:34:08,680 --> 00:34:16,420
the same just rolling down you open

00:34:14,200 --> 00:34:19,150
because this question came up more

00:34:16,420 --> 00:34:19,690
generally we were discussing it will

00:34:19,150 --> 00:34:28,270
trade you

00:34:19,690 --> 00:34:36,210
and yes the Sheridan lovely and now we

00:34:28,270 --> 00:34:40,960
know that I mean like what could happen

00:34:36,210 --> 00:34:43,840
you could imagine us saying okay to a

00:34:40,960 --> 00:34:44,980
local constraints that each one time if

00:34:43,840 --> 00:34:51,000
two functions come to different

00:34:44,980 --> 00:34:56,520
conclusions that's an error it sucks

00:34:51,000 --> 00:34:56,520
right but it's not undefined

00:34:57,810 --> 00:35:04,020
it's that they're independently

00:35:01,850 --> 00:35:05,790
we're gonna air a bit miss gunns thing

00:35:04,020 --> 00:35:09,170
is to get an error rather than sometimes

00:35:05,790 --> 00:35:23,040
getting air because sometimes the people

00:35:09,170 --> 00:35:25,380
you're always yes it was like like you

00:35:23,040 --> 00:35:29,520
could do some sort of like module local

00:35:25,380 --> 00:35:32,070
inference where each defining use was a

00:35:29,520 --> 00:35:34,920
like Hershel defining use right and you

00:35:32,070 --> 00:35:38,100
would combine all their various

00:35:34,920 --> 00:35:43,620
constraints together to infer the type I

00:35:38,100 --> 00:35:46,520
think that we kind of like today and

00:35:43,620 --> 00:35:53,060
kind of like backed away from that as a

00:35:46,520 --> 00:36:00,650
really scary thing compilation time

00:35:53,060 --> 00:36:02,360
implications it sort of requires I mean

00:36:00,650 --> 00:36:09,300
[Music]

00:36:02,360 --> 00:36:11,730
yeah James function a because Clinton a

00:36:09,300 --> 00:36:13,560
was sort of needed for constraint I

00:36:11,730 --> 00:36:15,420
wouldn't be function D it wouldn't be

00:36:13,560 --> 00:36:19,140
function D stops compiling it would be

00:36:15,420 --> 00:36:24,150
the model no longer has a solution for

00:36:19,140 --> 00:36:29,970
what the type is look like you might

00:36:24,150 --> 00:36:32,880
look like well it might be like function

00:36:29,970 --> 00:36:36,560
a specifies the title to be foo and

00:36:32,880 --> 00:36:39,510
function B requires that the type is

00:36:36,560 --> 00:36:41,720
later you change spontaneity to specify

00:36:39,510 --> 00:36:49,200
the type this card but now function the

00:36:41,720 --> 00:36:50,610
compiling it might appear to the it

00:36:49,200 --> 00:36:52,910
wouldn't be that function of you install

00:36:50,610 --> 00:36:55,350
compiling rate would be there's no

00:36:52,910 --> 00:36:59,010
logical solution to this problem

00:36:55,350 --> 00:37:02,280
yeah but the like this type is not

00:36:59,010 --> 00:37:03,810
saying I mean we could present it in

00:37:02,280 --> 00:37:06,050
various ways but the bottom line is

00:37:03,810 --> 00:37:06,050
funny

00:37:16,580 --> 00:37:29,190
like possibly probably there's always

00:37:22,650 --> 00:37:31,890
this wariness about like anyway I'm

00:37:29,190 --> 00:37:34,800
unsure about what how much to buy us

00:37:31,890 --> 00:37:37,310
your but regardless that's why we want

00:37:34,800 --> 00:37:42,180
to do it I don't actually consider that

00:37:37,310 --> 00:37:52,680
strong like I think that the elation

00:37:42,180 --> 00:38:05,820
planning stuff is true it doesn't

00:37:52,680 --> 00:38:08,480
actually like function generation

00:38:05,820 --> 00:38:12,390
[Music]

00:38:08,480 --> 00:38:15,930
because there's probably I think it's

00:38:12,390 --> 00:38:17,700
possible to have interactions where like

00:38:15,930 --> 00:38:21,180
there's some variable that's local to

00:38:17,700 --> 00:38:22,860
one function but you have to prove let's

00:38:21,180 --> 00:38:26,370
say that X there's two type variables

00:38:22,860 --> 00:38:28,800
one is the Titan one is X X some

00:38:26,370 --> 00:38:32,880
function but you have to prove that the

00:38:28,800 --> 00:38:36,420
hidden titanite school of X you say I

00:38:32,880 --> 00:38:41,600
mean then you can't there's sort of a

00:38:36,420 --> 00:38:44,520
and in fact or put another way

00:38:41,600 --> 00:38:47,660
digression about under why did principal

00:38:44,520 --> 00:38:47,660
you might have

00:38:50,870 --> 00:38:53,960
[Music]

00:38:57,600 --> 00:39:00,699
[Applause]

00:39:06,570 --> 00:39:16,470
and the problem is that's so we know

00:39:14,490 --> 00:39:17,820
what H is you don't know what HS it's

00:39:16,470 --> 00:39:22,290
already typed all the other things I

00:39:17,820 --> 00:39:28,800
think you wind up kind of mixing all the

00:39:22,290 --> 00:39:30,390
functions the function would like in

00:39:28,800 --> 00:39:33,120
between I was thinking about the

00:39:30,390 --> 00:39:35,250
functional time track and it would sort

00:39:33,120 --> 00:39:37,830
of export as a result of its time

00:39:35,250 --> 00:39:40,380
tracking the constraint that this

00:39:37,830 --> 00:39:43,410
existential type must implement iterator

00:39:40,380 --> 00:39:45,600
item is you know rush mode X right

00:39:43,410 --> 00:39:51,780
yeah but it doesn't do it first mark

00:39:45,600 --> 00:40:53,690
exits until in those are the ages that

00:39:51,780 --> 00:40:53,690
might be okay okay can i rein fence as

00:40:55,099 --> 00:40:59,849
cause otherwise it's ambiguous right I'm

00:40:57,960 --> 00:41:06,720
assuming that's not the thing you're

00:40:59,849 --> 00:41:13,770
interested in talking about not sure so

00:41:06,720 --> 00:41:15,869
just yeah that's what I meant it could

00:41:13,770 --> 00:41:20,579
be anything and we would just fail

00:41:15,869 --> 00:41:29,190
compilation right like knowing knowing

00:41:20,579 --> 00:41:31,589
that there's a next function yeah that's

00:41:29,190 --> 00:41:36,000
funny this is the same example what I'm

00:41:31,589 --> 00:41:40,680
thinking so right so now the question is

00:41:36,000 --> 00:41:44,130
like if for some reason you I don't know

00:41:40,680 --> 00:41:45,930
you could even have it be like this but

00:41:44,130 --> 00:41:47,700
this would sort of care age that

00:41:45,930 --> 00:41:49,460
wouldn't work don't have to be a case

00:41:47,700 --> 00:41:53,660
where you really don't know what H is

00:41:49,460 --> 00:41:53,660
that you want to prove something funny

00:41:53,839 --> 00:42:00,180
yes so some of my mind this code will

00:41:57,540 --> 00:42:02,460
compile and it would say it would you

00:42:00,180 --> 00:42:06,569
would output a bound that says like a

00:42:02,460 --> 00:42:12,990
requirement that says you know what is

00:42:06,569 --> 00:42:19,670
our type must implement no iterator

00:42:12,990 --> 00:42:19,670
reineck can I not type today item send

00:42:19,730 --> 00:42:28,970
sure and now this would I mean I think

00:42:25,530 --> 00:42:31,049
you're thinking about it correctly

00:42:28,970 --> 00:42:34,829
there's just different ways to implement

00:42:31,049 --> 00:42:36,750
that but one of the ways might be to mix

00:42:34,829 --> 00:42:39,599
all the context together the other might

00:42:36,750 --> 00:42:41,280
be to do something smart into this just

00:42:39,599 --> 00:42:45,089
the parts we've proven you discharged

00:42:41,280 --> 00:42:46,799
parts behind into reduce until they

00:42:45,089 --> 00:42:49,020
understand like what you learned and

00:42:46,799 --> 00:42:51,540
this binding it's just the main my main

00:42:49,020 --> 00:42:54,480
point is that it's not only a constraint

00:42:51,540 --> 00:42:56,790
on what the good type is but now we've

00:42:54,480 --> 00:42:59,309
also constrained then wherever it is

00:42:56,790 --> 00:43:00,660
it's by SS percent and that's like yeah

00:42:59,309 --> 00:43:03,920
we're complex constrain and they might

00:43:00,660 --> 00:43:03,920
be our hold of these things

00:43:06,190 --> 00:43:12,190
there are other things there it creates

00:43:10,120 --> 00:43:15,400
a potentially complicated sentence like

00:43:12,190 --> 00:43:17,980
module global greens right basically

00:43:15,400 --> 00:43:19,360
what it really is this these functions

00:43:17,980 --> 00:43:22,360
can inject additional module level

00:43:19,360 --> 00:43:25,060
verticals alright that's okay

00:43:22,360 --> 00:43:27,160
I think it's not anything we couldn't

00:43:25,060 --> 00:43:33,630
possibly in the other day um it would

00:43:27,160 --> 00:43:36,130
require us to get any case I personally

00:43:33,630 --> 00:43:40,930
the way we may have you may wind up

00:43:36,130 --> 00:43:45,340
having other reasons so it seems like

00:43:40,930 --> 00:43:47,470
we're coming back to our like ignoring

00:43:45,340 --> 00:43:56,920
module wide entrance which fortunately

00:43:47,470 --> 00:43:58,840
is unstable right now it seems like we

00:43:56,920 --> 00:44:04,120
are already locked into a world in which

00:43:58,840 --> 00:44:07,990
we pick a minimal solution this is a

00:44:04,120 --> 00:44:10,960
solution mean like for async FN I mean

00:44:07,990 --> 00:44:12,850
what it means is we've always had this

00:44:10,960 --> 00:44:15,190
principle that for every variable we try

00:44:12,850 --> 00:44:16,230
to find the smallest value that will

00:44:15,190 --> 00:44:20,560
suffice

00:44:16,230 --> 00:44:23,710
so by smallest I mean just using the

00:44:20,560 --> 00:44:26,770
definition a lifetime that covers the

00:44:23,710 --> 00:44:28,930
smallest amount of cover so if we have

00:44:26,770 --> 00:44:31,320
an ambiguity we choose the ambiguity

00:44:28,930 --> 00:44:33,880
that gives the smallest number like the

00:44:31,320 --> 00:44:37,210
smallest lifetime constraints what if

00:44:33,880 --> 00:44:40,000
there's a choice between two right there

00:44:37,210 --> 00:44:41,680
like personally doing another but you

00:44:40,000 --> 00:44:51,580
can do consistently you can't really get

00:44:41,680 --> 00:44:53,080
that very easily with you can so you can

00:44:51,580 --> 00:44:54,670
get that with named lifetimes for sure

00:44:53,080 --> 00:44:56,080
you say you can't get it really within a

00:44:54,670 --> 00:45:07,690
function behind it it's not in the old

00:44:56,080 --> 00:45:13,860
let's culture so you can have for

00:45:07,690 --> 00:45:13,860
example a setup like

00:45:15,279 --> 00:45:20,709
you have something to KR lives to be

00:45:22,359 --> 00:45:50,509
it's like a diamond set up so there's

00:45:25,459 --> 00:45:55,219
something like I'm gonna draw arrows so

00:45:50,509 --> 00:45:57,019
something like this right where that's

00:45:55,219 --> 00:46:14,289
clear what that's trying to do but the

00:45:57,019 --> 00:46:19,429
point being if you have to pick white

00:46:14,289 --> 00:46:30,169
which is the smallest today and succeed

00:46:19,429 --> 00:46:31,640
verse to sort of I'm sure you can get

00:46:30,169 --> 00:46:37,640
into these sort of situations what we do

00:46:31,640 --> 00:46:44,449
right now we have a notion this notion

00:46:37,640 --> 00:46:45,650
on the post post dominating which in

00:46:44,449 --> 00:46:47,749
this case would be sort of in the ER

00:46:45,650 --> 00:47:01,099
because there's no best choice but we

00:46:47,749 --> 00:47:03,529
look for things like it would be like if

00:47:01,099 --> 00:47:10,849
there were some something that was

00:47:03,529 --> 00:47:12,289
better than as we do sometimes to make

00:47:10,849 --> 00:47:15,009
this choice but until now it has never

00:47:12,289 --> 00:47:17,449
like been exposed to the outside world

00:47:15,009 --> 00:47:21,159
over sort of a phase one there was a

00:47:17,449 --> 00:47:24,919
period where we just sort of Higgins

00:47:21,159 --> 00:47:27,909
depending on the orderly process these

00:47:24,919 --> 00:47:27,909
in that was bad news

00:47:43,910 --> 00:47:47,020
[Music]

00:47:51,400 --> 00:47:54,570
[Music]

00:48:01,450 --> 00:48:04,500
[Music]

00:48:10,280 --> 00:48:13,359
[Music]

00:48:27,170 --> 00:48:31,479
[Music]

00:48:35,620 --> 00:48:38,679
[Music]

00:48:46,659 --> 00:48:56,079
I think in this case the arrow means the

00:48:50,019 --> 00:48:58,059
opposite of all this but see as you're

00:48:56,079 --> 00:49:01,299
trying to find the biggest thing will

00:48:58,059 --> 00:49:03,549
reverse the concept obviously um but so

00:49:01,299 --> 00:49:06,819
if you ask for what is the biggest thing

00:49:03,549 --> 00:49:11,499
of a and B here we get X or what is the

00:49:06,819 --> 00:49:17,459
upper bound which makes sense in this

00:49:11,499 --> 00:49:21,059
case we would also pick X even though

00:49:17,459 --> 00:49:24,429
there are sort of two choices

00:49:21,059 --> 00:49:30,759
these ones wouldn't also suffice but

00:49:24,429 --> 00:49:34,319
whether they're equally good we refuse

00:49:30,759 --> 00:49:36,410
to pick between them and said we promote

00:49:34,319 --> 00:49:38,490
you know

00:49:36,410 --> 00:49:45,720
it's case we would have known sir

00:49:38,490 --> 00:49:47,550
there's nobody so and I thought I didn't

00:49:45,720 --> 00:49:59,880
actually write through all of what we do

00:49:47,550 --> 00:50:16,110
if there is no like if a1 and b1 or

00:49:59,880 --> 00:50:18,570
equally good so we have this notion it's

00:50:16,110 --> 00:50:34,590
not as good here it's not exactly

00:50:18,570 --> 00:50:40,280
minimal in all cases just what you

00:50:34,590 --> 00:50:44,070
randomly into that one see what does

00:50:40,280 --> 00:50:45,870
here I guess no best choice this is

00:50:44,070 --> 00:50:48,570
called the zero is last one yeah

00:50:45,870 --> 00:50:51,000
seriously I didn't draw the diagram zero

00:50:48,570 --> 00:50:55,440
is less than the one is yours lesson 2 3

00:50:51,000 --> 00:51:02,520
is less than 1 3 is less than 2 so the

00:50:55,440 --> 00:51:21,960
full set of upper balances I guess they

00:51:02,520 --> 00:51:24,000
don't run but so I mean so I guess like

00:51:21,960 --> 00:51:26,460
so far what I'm going is that the first

00:51:24,000 --> 00:51:31,140
thing we should do is where there is an

00:51:26,460 --> 00:51:35,510
unambiguous choice of a a little life

00:51:31,140 --> 00:51:39,420
time just pick those

00:51:35,510 --> 00:51:41,340
yeah and otherwise we come up with

00:51:39,420 --> 00:51:48,420
something that is vaguely order

00:51:41,340 --> 00:51:50,130
dependent but not terrible it's it's

00:51:48,420 --> 00:51:54,060
depending on what it is is it's not

00:51:50,130 --> 00:51:59,190
monotonic but like adding in more

00:51:54,060 --> 00:52:01,580
constraints like giving more choices

00:51:59,190 --> 00:52:05,820
chemical and make it pick a worse

00:52:01,580 --> 00:52:07,350
solution yes even though in principle

00:52:05,820 --> 00:52:11,190
the old solution they had already done

00:52:07,350 --> 00:52:17,850
is still there it's not great but it's

00:52:11,190 --> 00:52:21,120
not not as bad as like but uh the yeah I

00:52:17,850 --> 00:52:22,680
mean I'm kind of debating about I but I

00:52:21,120 --> 00:52:24,600
had planned to say when we came in and

00:52:22,680 --> 00:52:25,260
ice that's probably just probably still

00:52:24,600 --> 00:52:30,230
a good idea

00:52:25,260 --> 00:52:30,230
I mean conservative if you said kick

00:52:30,260 --> 00:52:36,030
only try to only pick whether it's

00:52:32,910 --> 00:52:37,800
really only one choice but it seems like

00:52:36,030 --> 00:52:40,350
we're already kind of spot right in a

00:52:37,800 --> 00:52:45,660
world where we make some arbitrary

00:52:40,350 --> 00:52:50,790
choices you know and maybe we'll

00:52:45,660 --> 00:53:02,400
probably why not this hard not to get

00:52:50,790 --> 00:53:24,420
there because people don't write these

00:53:02,400 --> 00:53:26,040
equals I mean I feel like I don't make

00:53:24,420 --> 00:53:27,390
an accident here that will cause the

00:53:26,040 --> 00:53:30,780
language to be unsound

00:53:27,390 --> 00:53:32,910
I might cause something to not compile

00:53:30,780 --> 00:53:37,290
that we might have liked to have

00:53:32,910 --> 00:53:39,540
compiled but I think that's like the

00:53:37,290 --> 00:53:41,970
worst outcome right I guess the worst

00:53:39,540 --> 00:53:43,680
outcome is that we choose an

00:53:41,970 --> 00:53:45,990
unreasonable algorithm and then realize

00:53:43,680 --> 00:53:46,490
a rainbow and later and we can't go to

00:53:45,990 --> 00:53:49,540
the reefs

00:53:46,490 --> 00:53:54,980
one because it breaks someone's viscous

00:53:49,540 --> 00:53:56,690
yeah I mean I don't see how yeah I guess

00:53:54,980 --> 00:54:02,900
that's that's probably right there

00:53:56,690 --> 00:54:05,240
doesn't seem to be a actual like this is

00:54:02,900 --> 00:54:06,650
truly an bibulous there's no way for us

00:54:05,240 --> 00:54:09,590
to make the right choice all the time

00:54:06,650 --> 00:54:13,600
without yes can't know all the good

00:54:09,590 --> 00:54:21,200
space we have to solve in the future so

00:54:13,600 --> 00:54:32,840
it's sort of comforting no right choice

00:54:21,200 --> 00:54:36,440
right but also not the most comforting

00:54:32,840 --> 00:54:37,790
things in my life you won't break it too

00:54:36,440 --> 00:54:40,850
badly or let's put it this way whatever

00:54:37,790 --> 00:54:44,090
you bring you couldn't work there will

00:54:40,850 --> 00:54:50,450
be other than legs you'll whatever you

00:54:44,090 --> 00:54:50,930
break those other things to puppies you

00:54:50,450 --> 00:54:53,000
know what I mean

00:54:50,930 --> 00:54:55,640
every example if you break something or

00:54:53,000 --> 00:54:57,050
other algorithm must by definition also

00:54:55,640 --> 00:55:08,119
prints the things that you're going to

00:54:57,050 --> 00:55:31,010
work based yeah I think this is the way

00:55:08,119 --> 00:55:33,320
to make this example so I think this is

00:55:31,010 --> 00:55:34,820
kind of interesting right here so stick

00:55:33,320 --> 00:55:38,570
what's happening is so we're picking

00:55:34,820 --> 00:55:47,420
food today right but it's coercing after

00:55:38,570 --> 00:55:51,770
the function right well I think we

00:55:47,420 --> 00:55:54,890
realize I think that we actually not

00:55:51,770 --> 00:55:57,800
sure how does this revealing to go

00:55:54,890 --> 00:55:59,750
looking occurs to me that the

00:55:57,800 --> 00:56:02,450
the leaking about whether something is

00:55:59,750 --> 00:56:04,280
an arbitrator I guess we must reveal the

00:56:02,450 --> 00:56:06,290
title don't look how that's actually act

00:56:04,280 --> 00:56:08,600
but presumably at that point we know

00:56:06,290 --> 00:56:10,730
oh well today is whatever this lifetime

00:56:08,600 --> 00:56:16,760
is so we wind up getting the right

00:56:10,730 --> 00:56:19,010
constraint yep yeah but I think but I

00:56:16,760 --> 00:56:20,810
think in this case we it seems totally

00:56:19,010 --> 00:56:24,290
feasible that we could be choosing Takai

00:56:20,810 --> 00:56:26,780
in the body of foo and then doing the

00:56:24,290 --> 00:56:28,580
coercion main that's what I'm saying we

00:56:26,780 --> 00:56:31,280
are picking body we are picking today

00:56:28,580 --> 00:56:32,960
hear anything but then we are your

00:56:31,280 --> 00:56:36,710
because we know what today is

00:56:32,960 --> 00:56:42,370
essentially yep we substituted and we

00:56:36,710 --> 00:56:42,370
get it sort of works out and actually we

00:56:43,660 --> 00:56:48,680
[Music]

00:56:45,370 --> 00:56:54,460
all right so right so what should we

00:56:48,680 --> 00:56:56,720
actually to know to you but I think like

00:56:54,460 --> 00:57:01,700
it seems like we need to implement this

00:56:56,720 --> 00:57:08,300
in concentrated and so the way I had

00:57:01,700 --> 00:57:12,650
thought to implement it was going to

00:57:08,300 --> 00:57:13,610
give the way I had thought to plan I

00:57:12,650 --> 00:57:16,100
would indeed

00:57:13,610 --> 00:57:19,070
and although but only handle the only

00:57:16,100 --> 00:57:23,270
thing is this probably you can certainly

00:57:19,070 --> 00:57:27,320
look at the constraints on tick zero and

00:57:23,270 --> 00:57:30,110
you can say I have to be less than today

00:57:27,320 --> 00:57:31,610
only one of my things or it took a has

00:57:30,110 --> 00:57:35,570
to outlive me and only one of my things

00:57:31,610 --> 00:57:38,840
just to get I live with only one of

00:57:35,570 --> 00:57:44,270
these choices and therefore I can change

00:57:38,840 --> 00:57:49,340
this to an equality mystery yeah yeah I

00:57:44,270 --> 00:57:54,680
mean that won't work for if if it not if

00:57:49,340 --> 00:57:58,490
we knew that they are lipstick be it's

00:57:54,680 --> 00:58:00,650
gonna be ambiguous for this case because

00:57:58,490 --> 00:58:01,940
both yeah luckily I think most of the

00:58:00,650 --> 00:58:04,250
cases we're concerned about here

00:58:01,940 --> 00:58:09,010
actually fixing are alighted move all

00:58:04,250 --> 00:58:09,010
five homes in a sink offend her

00:58:10,700 --> 00:58:46,490
so the good news is it's basically an

00:59:28,850 --> 00:59:31,940
[Music]

00:59:46,550 --> 00:59:49,609
[Music]

01:00:03,619 --> 01:00:18,480
interesting case I mean it's only

01:00:13,140 --> 01:00:21,869
exactly sidestepping the same problem we

01:00:18,480 --> 01:00:24,329
just showed playground

01:00:21,869 --> 01:00:28,259
cuz if they were able to write it with

01:00:24,329 --> 01:00:32,309
infiltrating they may have been making

01:00:28,259 --> 01:00:36,150
some arbitrary direction you want to you

01:00:32,309 --> 01:00:44,609
stop to use capture taxes okay and

01:00:36,150 --> 01:00:51,170
sometimes that doesn't work let me again

01:00:44,609 --> 01:01:10,710
you can't pick between them to gcx

01:00:51,170 --> 01:01:17,400
I realized recently so so for our

01:01:10,710 --> 01:01:19,079
constraint like I'm not sure how to sort

01:01:17,400 --> 01:01:30,589
of usually see how to do this in the

01:01:19,079 --> 01:01:30,589
lexical solver and the idea is basically

01:01:33,560 --> 01:01:37,360
[Music]

01:01:48,650 --> 01:01:56,249
the problem is so this is the ambiguous

01:01:52,589 --> 01:01:59,420
base right so we're saying what would we

01:01:56,249 --> 01:02:07,609
do with the damn thing in this case I

01:01:59,420 --> 01:02:07,609
mean it seems like what we would do I

01:02:12,259 --> 01:02:24,390
guess if there were an ordering for me

01:02:20,029 --> 01:02:28,109
what I couldn't have anything you just

01:02:24,390 --> 01:02:30,299
said I was just thinking about what we

01:02:28,109 --> 01:02:31,079
would actually do if you wanted to do

01:02:30,299 --> 01:02:33,180
more than this

01:02:31,079 --> 01:02:36,000
it seems likely

01:02:33,180 --> 01:02:39,359
I mean we're kind out to just

01:02:36,000 --> 01:02:41,880
exhaustively and search around okay we

01:02:39,359 --> 01:02:50,940
could find minimal choices in interact

01:02:41,880 --> 01:03:14,940
with one another it's not fun like if

01:02:50,940 --> 01:03:17,760
you have six euro when we pick one my

01:03:14,940 --> 01:03:21,420
point is I'd prefer not to so I think we

01:03:17,760 --> 01:03:22,789
should stick with kiss we get that

01:03:21,420 --> 01:03:25,440
working

01:03:22,789 --> 01:03:28,049
we'll probably want to do is this is all

01:03:25,440 --> 01:03:35,099
coming back fire to change all of this

01:03:28,049 --> 01:03:50,569
region so list other lower level up

01:03:35,099 --> 01:03:55,319
stretch just to play games so alright

01:03:50,569 --> 01:03:56,430
let's go back to I don't know let's ask

01:03:55,319 --> 01:04:03,180
this question do you want to try to

01:03:56,430 --> 01:04:10,650
write this code do you want me to leave

01:04:03,180 --> 01:04:14,309
you some tips some advice would be

01:04:10,650 --> 01:04:25,609
helpful I think there's some question

01:04:14,309 --> 01:04:30,869
marks in my mind one of them is when I

01:04:25,609 --> 01:04:35,520
think in the Lexus over I feel like we

01:04:30,869 --> 01:04:43,109
could do this as a kind of creeped us by

01:04:35,520 --> 01:04:44,579
which I mean you could basically find go

01:04:43,109 --> 01:04:46,040
ahead and walk the grass for everything

01:04:44,579 --> 01:04:50,160
that is involved

01:04:46,040 --> 01:04:51,690
and then in the street we would kind of

01:04:50,160 --> 01:05:00,540
walk the graph to try to find the things

01:04:51,690 --> 01:05:02,010
that they're related and try to relate

01:05:00,540 --> 01:05:03,990
those to try to convert the in

01:05:02,010 --> 01:05:07,500
constraint of audience basically and

01:05:03,990 --> 01:05:13,350
then if it fails then we just ignore it

01:05:07,500 --> 01:05:19,020
otherwise be good quality you can just

01:05:13,350 --> 01:05:20,610
do that as a because doesn't seem to me

01:05:19,020 --> 01:05:24,270
the way that the software basically

01:05:20,610 --> 01:05:26,400
works rather in iterative phase where

01:05:24,270 --> 01:05:29,190
it's trying to each time it has an

01:05:26,400 --> 01:05:31,050
outlives relation the bigger one bigger

01:05:29,190 --> 01:05:33,450
big enough to be bigger than the smaller

01:05:31,050 --> 01:05:37,110
one and keep straight down until they're

01:05:33,450 --> 01:05:41,850
all solved but I don't know doesn't seem

01:05:37,110 --> 01:05:43,580
any value like letting that brand like

01:05:41,850 --> 01:05:57,350
it's not giving us any information

01:05:43,580 --> 01:05:57,350
available if you just another way to go

01:06:02,510 --> 01:06:07,050
it might also make sense is to wait or

01:06:05,250 --> 01:06:12,180
let it reach a fixed point so we know we

01:06:07,050 --> 01:06:15,090
look the smallest things and then and

01:06:12,180 --> 01:06:31,170
then apply to sound with refer those

01:06:15,090 --> 01:06:33,650
variables that all right let me think

01:06:31,170 --> 01:06:33,650
about these questions

01:06:43,400 --> 01:07:05,410

YouTube URL: https://www.youtube.com/watch?v=hlOxfkUDLPQ


