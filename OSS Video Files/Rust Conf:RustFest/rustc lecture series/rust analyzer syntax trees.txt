Title: rust analyzer syntax trees
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	@matklad walks us through how syntax trees are implemented in rust-analyzer.

Recorded 2019.02.26.
Captions: 
	00:00:00,469 --> 00:00:06,930
okay let's probably get started if

00:00:04,799 --> 00:00:13,290
anyone joins later there is a video

00:00:06,930 --> 00:00:17,039
recording okay so I'd like to talk about

00:00:13,290 --> 00:00:19,619
the current implementation of c63 North

00:00:17,039 --> 00:00:22,410
analyzer I think that like a lot of

00:00:19,619 --> 00:00:25,920
details should be changed to make it

00:00:22,410 --> 00:00:29,970
like more efficient etc but the general

00:00:25,920 --> 00:00:31,710
idea seems great to me why not because

00:00:29,970 --> 00:00:33,600
it's like a great idea but because other

00:00:31,710 --> 00:00:36,320
projects like crossly all suites are

00:00:33,600 --> 00:00:38,969
trying to use it so it seems like a

00:00:36,320 --> 00:00:40,440
reasonable reasonable theory that it

00:00:38,969 --> 00:00:42,870
should work for us as well but like

00:00:40,440 --> 00:00:46,050
macros can throw a wrench into the

00:00:42,870 --> 00:00:48,629
details I am actually an issue on rust

00:00:46,050 --> 00:00:51,239
and wiser repository about like

00:00:48,629 --> 00:00:53,489
finalizing the design of industries so

00:00:51,239 --> 00:00:56,340
if you have any thoughts after the

00:00:53,489 --> 00:01:00,960
meeting you probably should base the

00:00:56,340 --> 00:01:02,969
comments on this issue 862 currently

00:01:00,960 --> 00:01:05,489
position basically have a list of

00:01:02,969 --> 00:01:08,280
requirements and I'd like to briefly

00:01:05,489 --> 00:01:10,350
went through them to understand why I've

00:01:08,280 --> 00:01:15,420
been doing things the way we do them so

00:01:10,350 --> 00:01:18,299
the through primary becomes trains on

00:01:15,420 --> 00:01:20,189
the syntax tree the idea is is that the

00:01:18,299 --> 00:01:22,680
syntax tree must be faulted elegy

00:01:20,189 --> 00:01:26,189
impotent must maintain all

00:01:22,680 --> 00:01:32,150
whitespace and comments parentheses

00:01:26,189 --> 00:01:35,280
cetera et cetera et le like it should

00:01:32,150 --> 00:01:38,009
maintain them in a like more or less

00:01:35,280 --> 00:01:40,350
explicit form so that you can actually

00:01:38,009 --> 00:01:42,540
have a wide space now and you can like

00:01:40,350 --> 00:01:44,579
take a look at the knot to the left and

00:01:42,540 --> 00:01:47,070
not to the right like you could just

00:01:44,579 --> 00:01:48,149
store a source text alongside the tree

00:01:47,070 --> 00:01:50,700
and saying if this is a full fidelity

00:01:48,149 --> 00:01:53,070
implementation but if you have it won't

00:01:50,700 --> 00:01:56,310
be too useful for these basically

00:01:53,070 --> 00:01:59,219
important requirement is that the parse

00:01:56,310 --> 00:02:01,619
in itself must be our tolerance what I

00:01:59,219 --> 00:02:04,590
mean is that if you throw any valid

00:02:01,619 --> 00:02:07,020
would have a text at the parser it must

00:02:04,590 --> 00:02:08,970
produce some kind of a source tree which

00:02:07,020 --> 00:02:11,190
should be full fidelity and represent

00:02:08,970 --> 00:02:13,170
this like completely bare which detects

00:02:11,190 --> 00:02:16,739
Texas 100%

00:02:13,170 --> 00:02:18,959
et le person should also figure out

00:02:16,739 --> 00:02:22,290
fragments of red source code in these

00:02:18,959 --> 00:02:23,220
garbage texts and like produce

00:02:22,290 --> 00:02:26,310
best-effort

00:02:23,220 --> 00:02:28,950
synthetic story even if it doesn't match

00:02:26,310 --> 00:02:30,870
the gram of rust exactly what I mean is

00:02:28,950 --> 00:02:34,799
that like for example in Ross drama each

00:02:30,870 --> 00:02:37,319
truck must have a name but we must allow

00:02:34,799 --> 00:02:39,690
for syntax tree to have a struct which

00:02:37,319 --> 00:02:43,890
has no name it has just extract keyboard

00:02:39,690 --> 00:02:47,579
or maybe like a list of fields okay

00:02:43,890 --> 00:02:53,549
other requirements like probably less

00:02:47,579 --> 00:02:55,069
important but also quite important the

00:02:53,549 --> 00:02:58,040
interesting bit here is probably

00:02:55,069 --> 00:03:00,090
represent in a hygienic macro expansion

00:02:58,040 --> 00:03:02,700
because we certainly can imagine a

00:03:00,090 --> 00:03:04,739
situation and for example like we used

00:03:02,700 --> 00:03:07,409
once in 63 for macro expansion and

00:03:04,739 --> 00:03:10,409
various index 3 for actual any fishes

00:03:07,409 --> 00:03:13,079
but I fear at like it could roar but it

00:03:10,409 --> 00:03:14,760
would mean duplicated efforts etc so if

00:03:13,079 --> 00:03:16,500
we could use a single syntax tree to do

00:03:14,760 --> 00:03:18,269
like low level compiler rework like

00:03:16,500 --> 00:03:21,090
micro expansion and a resolution and

00:03:18,269 --> 00:03:25,260
like just ID full fidelity work that

00:03:21,090 --> 00:03:27,299
would be great and here another

00:03:25,260 --> 00:03:28,889
interesting bits that I need probably

00:03:27,299 --> 00:03:32,010
needs it's like not one half percent

00:03:28,889 --> 00:03:36,329
crucial but pretty important is like

00:03:32,010 --> 00:03:39,859
ability to use parent pointers and

00:03:36,329 --> 00:03:42,709
absolute offsets with the tree so

00:03:39,859 --> 00:03:46,230
because in a compiler you technically

00:03:42,709 --> 00:03:48,449
take a root node of some function or

00:03:46,230 --> 00:03:50,459
something else and like walk it in

00:03:48,449 --> 00:03:53,010
top-down manner and only expecting

00:03:50,459 --> 00:03:55,739
children in indeed at least start with

00:03:53,010 --> 00:03:59,190
an offset in a file and you locate a

00:03:55,739 --> 00:04:01,349
node at this offset and traverse the

00:03:59,190 --> 00:04:03,750
tree upwards to find like a function

00:04:01,349 --> 00:04:06,540
with this offset so like parent pointers

00:04:03,750 --> 00:04:09,419
are pretty important and can i push back

00:04:06,540 --> 00:04:11,609
on that just a little but I mean at

00:04:09,419 --> 00:04:13,139
least in the RLS for example like what

00:04:11,609 --> 00:04:16,079
you really want is the ability to find

00:04:13,139 --> 00:04:18,900
it the nodes that intersect a lion

00:04:16,079 --> 00:04:21,840
column right the end of the day a cursor

00:04:18,900 --> 00:04:23,130
position or something like that and the

00:04:21,840 --> 00:04:24,510
parent pointers are certainly one way to

00:04:23,130 --> 00:04:26,580
do it I mean I think we may want them

00:04:24,510 --> 00:04:28,889
anyway but like you

00:04:26,580 --> 00:04:30,720
also traverse the tree from the top and

00:04:28,889 --> 00:04:32,759
find the match rate and you may wind up

00:04:30,720 --> 00:04:35,310
doing that in order because you have to

00:04:32,759 --> 00:04:37,469
search you have to index it by offset

00:04:35,310 --> 00:04:39,330
anyway when you get a request in from

00:04:37,469 --> 00:04:43,949
the ID you get like this is the line in

00:04:39,330 --> 00:04:46,439
column right not here's a note yeah that

00:04:43,949 --> 00:04:48,659
could work as well basically like if you

00:04:46,439 --> 00:04:50,879
have information about offsets that

00:04:48,659 --> 00:04:53,219
basically isomorphic to have my parents

00:04:50,879 --> 00:04:55,800
a child relationship because like

00:04:53,219 --> 00:04:58,949
something is parent of something if the

00:04:55,800 --> 00:05:04,199
text offset is within the extent of the

00:04:58,949 --> 00:05:10,379
parent node so but like kind of partial

00:05:04,199 --> 00:05:12,120
processing it still useful to just take

00:05:10,379 --> 00:05:15,000
a look at the parts tracked and like to

00:05:12,120 --> 00:05:17,819
figure out what kind of node is it like

00:05:15,000 --> 00:05:20,879
for example okay so you have an offset

00:05:17,819 --> 00:05:24,120
and like you figured out that you are at

00:05:20,879 --> 00:05:26,370
the identifier and then you need to

00:05:24,120 --> 00:05:28,560
somehow I classify these identifiers it

00:05:26,370 --> 00:05:30,750
is like part of the pattern or is this

00:05:28,560 --> 00:05:34,469
expression or maybe like a Strathfield

00:05:30,750 --> 00:05:38,520
and looking at the parent in this sense

00:05:34,469 --> 00:05:40,110
is useful not crucial so it's like it

00:05:38,520 --> 00:05:43,580
must have category not him like

00:05:40,110 --> 00:05:46,680
absolutely must have a useful property

00:05:43,580 --> 00:05:47,879
yeah I guess I would just I feel like it

00:05:46,680 --> 00:05:49,229
is useful but not for the reason that

00:05:47,879 --> 00:05:52,589
you say isn't you want to kind of say

00:05:49,229 --> 00:05:53,819
like in order to yeah yeah you still

00:05:52,589 --> 00:05:55,770
have to search from the top to find

00:05:53,819 --> 00:05:57,389
where the cursor is but one it is just

00:05:55,770 --> 00:05:58,740
useful to be able to go to parents

00:05:57,389 --> 00:06:07,139
because then you have to pass up the

00:05:58,740 --> 00:06:09,930
whole yeah yeah that's true okay so yeah

00:06:07,139 --> 00:06:13,370
one more kind of model property is

00:06:09,930 --> 00:06:16,020
ability to do incremental parse and like

00:06:13,370 --> 00:06:18,270
incremental parsing what incremental

00:06:16,020 --> 00:06:21,270
person actually person algorithm which

00:06:18,270 --> 00:06:23,159
you can like rerun partial results but

00:06:21,270 --> 00:06:25,620
another part is like the actual syntax

00:06:23,159 --> 00:06:28,469
tree structure which you can modify in

00:06:25,620 --> 00:06:33,300
place instead of like constructing from

00:06:28,469 --> 00:06:36,930
the other pieces its I actually don't

00:06:33,300 --> 00:06:39,240
think that this is like it - really

00:06:36,930 --> 00:06:41,310
really crucially important thing because

00:06:39,240 --> 00:06:43,080
Arsen on the way you want usually to

00:06:41,310 --> 00:06:46,650
intrumental your bars on a single file

00:06:43,080 --> 00:06:47,009
and bars in a single file is it fast

00:06:46,650 --> 00:06:49,830
enough

00:06:47,009 --> 00:06:52,979
like it's like tens of milliseconds it's

00:06:49,830 --> 00:06:54,330
like not an extremely big delay but of

00:06:52,979 --> 00:06:56,370
course it's like would be more memory

00:06:54,330 --> 00:06:59,430
efficient and faster to just actually

00:06:56,370 --> 00:07:02,130
update the tree instead of reversing

00:06:59,430 --> 00:07:04,979
everything from scratch okay

00:07:02,130 --> 00:07:09,900
so that's a kind of like basic

00:07:04,979 --> 00:07:13,530
requirements let's take a look how seems

00:07:09,900 --> 00:07:18,780
extreme breathalyzer work to like keep

00:07:13,530 --> 00:07:22,110
these requirements the rough plan is

00:07:18,780 --> 00:07:24,720
first of all to work through the EPI

00:07:22,110 --> 00:07:27,599
like behind level public API ups index 3

00:07:24,720 --> 00:07:31,229
and then to go through the

00:07:27,599 --> 00:07:33,060
implementation of the data structure

00:07:31,229 --> 00:07:35,190
which powers this index degree which is

00:07:33,060 --> 00:07:37,830
basically the same data structure which

00:07:35,190 --> 00:07:41,550
is used in Rhossili or in Swift's new

00:07:37,830 --> 00:07:44,039
lips impacts and then to go through this

00:07:41,550 --> 00:07:45,479
incremental and error tolerant parson

00:07:44,039 --> 00:07:47,580
bit and maybe take a look at how we

00:07:45,479 --> 00:07:50,699
actually use industries inside of rust

00:07:47,580 --> 00:07:55,190
analyze okay so let's start with a

00:07:50,699 --> 00:07:57,719
public API so here we have an example

00:07:55,190 --> 00:08:02,820
through in which the some rust source

00:07:57,719 --> 00:08:05,940
code and we parse this stream into a

00:08:02,820 --> 00:08:10,919
syntax tree and kind of like one of

00:08:05,940 --> 00:08:13,800
course Department that I like to achieve

00:08:10,919 --> 00:08:15,960
is that person should be independent

00:08:13,800 --> 00:08:18,719
from the semantic knowledge to compile

00:08:15,960 --> 00:08:20,699
and but we should be able to parse some

00:08:18,719 --> 00:08:22,440
stream in isolation without creating

00:08:20,699 --> 00:08:25,139
like some kind of the compiler sessions

00:08:22,440 --> 00:08:29,219
cetera we certainly will need to add

00:08:25,139 --> 00:08:30,719
some kind of like addition 2018 or

00:08:29,219 --> 00:08:32,880
something like that to account for

00:08:30,719 --> 00:08:34,469
addition but I hope that like the

00:08:32,880 --> 00:08:38,880
addition is the single flag from the

00:08:34,469 --> 00:08:42,860
global state we need two R's files so

00:08:38,880 --> 00:08:46,709
what we get is actually source file

00:08:42,860 --> 00:08:49,810
struct which represents the ice-t node

00:08:46,709 --> 00:08:53,680
for the coal fire

00:08:49,810 --> 00:08:56,080
and due to the weight ownerships is we

00:08:53,680 --> 00:09:01,570
get actually a smart pointer to the

00:08:56,080 --> 00:09:04,000
source file so 3 Ark is like just it's

00:09:01,570 --> 00:09:06,720
like a usual art but it points will be

00:09:04,000 --> 00:09:08,620
whole tweet so it like you can imagine

00:09:06,720 --> 00:09:10,390
some kind of an application in

00:09:08,620 --> 00:09:12,640
raspberries and important the main

00:09:10,390 --> 00:09:14,770
object is always held behind an art

00:09:12,640 --> 00:09:16,960
pointer and so the code base polish

00:09:14,770 --> 00:09:18,700
interacts with either art of this thing

00:09:16,960 --> 00:09:21,029
all with the reference to this theme and

00:09:18,700 --> 00:09:24,040
it never seems like they shall bear

00:09:21,029 --> 00:09:29,190
thing this is what happens with industry

00:09:24,040 --> 00:09:29,190
you either see a reference to a node or

00:09:30,150 --> 00:09:36,240
twee arc of node and you never see burn

00:09:34,300 --> 00:09:42,820
on the self

00:09:36,240 --> 00:09:45,430
so all these ice-t nodes at like usual a

00:09:42,820 --> 00:09:48,400
pilot example in file we can iterate

00:09:45,430 --> 00:09:51,880
items where item can be like extract the

00:09:48,400 --> 00:09:57,130
functions etc so here's the list of

00:09:51,880 --> 00:09:59,230
items you can see inside the file and we

00:09:57,130 --> 00:10:01,450
can extract the particular items they

00:09:59,230 --> 00:10:04,360
like this was function definition and

00:10:01,450 --> 00:10:06,220
get the reference to it although we

00:10:04,360 --> 00:10:10,150
started with an old version of the file

00:10:06,220 --> 00:10:14,350
over tear also always yields a yields

00:10:10,150 --> 00:10:17,970
references we however can create an old

00:10:14,350 --> 00:10:20,530
version from references so this is like

00:10:17,970 --> 00:10:23,200
shared from with these problems it was

00:10:20,530 --> 00:10:25,150
plus you get a reference and you can get

00:10:23,200 --> 00:10:26,500
an old version of this reference which

00:10:25,150 --> 00:10:28,990
is the cheap reparation which does not

00:10:26,500 --> 00:10:35,260
clog that also fix tree but just bumps

00:10:28,990 --> 00:10:38,500
the arc counter for the to itself so you

00:10:35,260 --> 00:10:43,030
know we've got this function node we can

00:10:38,500 --> 00:10:45,760
inspect its name its body and we can get

00:10:43,030 --> 00:10:50,310
the expression from the bodies etcetera

00:10:45,760 --> 00:10:53,709
one thing to note here is that all these

00:10:50,310 --> 00:10:55,150
functions return options so although

00:10:53,709 --> 00:10:57,970
like the name of the function is

00:10:55,150 --> 00:11:00,270
mandatory it was drama here we get an

00:10:57,970 --> 00:11:03,240
option because

00:11:00,270 --> 00:11:12,270
syntax tree is able to represent partial

00:11:03,240 --> 00:11:14,670
notes and yes so here I have that I

00:11:12,270 --> 00:11:18,480
function without a name and in the

00:11:14,670 --> 00:11:21,420
syntax tree for a dysfunctional series

00:11:18,480 --> 00:11:24,270
append F not all the way the name and

00:11:21,420 --> 00:11:25,260
that's we so wait two things actually a

00:11:24,270 --> 00:11:27,630
couple things but let's start with the

00:11:25,260 --> 00:11:29,010
most recent what is this like wizardry

00:11:27,630 --> 00:11:30,959
that you're showing is here's some

00:11:29,010 --> 00:11:32,459
integration where you can see the parse

00:11:30,959 --> 00:11:35,010
tree or something yeah yeah this is

00:11:32,459 --> 00:11:37,980
basically the parse tree or the file I'm

00:11:35,010 --> 00:11:42,020
currently editing under stage of life

00:11:37,980 --> 00:11:46,230
and kind of cool and nice that is cool

00:11:42,020 --> 00:11:48,209
for the tree arc struct is this

00:11:46,230 --> 00:11:50,910
basically like an unsafely implemented

00:11:48,209 --> 00:11:52,800
thing that keeps the arc to the root and

00:11:50,910 --> 00:11:54,720
then has like a pointer to something

00:11:52,800 --> 00:11:57,959
that's owned transitively by the root

00:11:54,720 --> 00:11:59,910
set the idea yes we will go for the

00:11:57,959 --> 00:12:01,920
implementation like you know this a

00:11:59,910 --> 00:12:03,899
while yeah but like here the idea is

00:12:01,920 --> 00:12:05,640
it's a bit of unsafe code which i am not

00:12:03,899 --> 00:12:08,880
entirely sure is correct but i hope is

00:12:05,640 --> 00:12:13,170
correct or could be made correct sounds

00:12:08,880 --> 00:12:17,010
good okay yeah okay so we have we can

00:12:13,170 --> 00:12:19,260
inspect beads or tweeze and this iced

00:12:17,010 --> 00:12:21,180
tea name is also like not an insurance

00:12:19,260 --> 00:12:23,130
to english represent the name of action

00:12:21,180 --> 00:12:28,790
but an actual iced tea no with parent

00:12:23,130 --> 00:12:32,010
pointers offset register so like this

00:12:28,790 --> 00:12:35,399
shows how we can use like strut like ice

00:12:32,010 --> 00:12:40,470
team now knows we can also have like a

00:12:35,399 --> 00:12:43,440
nice API for an enum like ice-t note so

00:12:40,470 --> 00:12:47,730
for example here we got an expression

00:12:43,440 --> 00:12:50,459
for the block so this would be one plus

00:12:47,730 --> 00:12:53,190
one and we would like to know which kind

00:12:50,459 --> 00:12:56,730
of expression is this exactly so we call

00:12:53,190 --> 00:12:59,579
a head method and get back and and on

00:12:56,730 --> 00:13:04,110
with all there is kind of expressions we

00:12:59,579 --> 00:13:09,779
have this is like interesting feet and

00:13:04,110 --> 00:13:13,650
because we do not so I see directly as

00:13:09,779 --> 00:13:15,720
to your panels so you can't do

00:13:13,650 --> 00:13:18,000
nasty partial motion you can for example

00:13:15,720 --> 00:13:20,250
a directly writing much expression for

00:13:18,000 --> 00:13:22,800
an expression which is an addition where

00:13:20,250 --> 00:13:25,670
the left-hand side is a customer enter

00:13:22,800 --> 00:13:29,339
or select that you need to do this like

00:13:25,670 --> 00:13:32,700
one layer of motion at a time but you

00:13:29,339 --> 00:13:34,470
still can help these Russian and

00:13:32,700 --> 00:13:38,400
exhausted check and citrusy trap and

00:13:34,470 --> 00:13:40,200
what's cool about it is that it seems to

00:13:38,400 --> 00:13:43,020
me that when final presentation could

00:13:40,200 --> 00:13:45,450
actually be flexible there is an all

00:13:43,020 --> 00:13:46,110
these like expert current and up stored

00:13:45,450 --> 00:13:51,960
anywhere

00:13:46,110 --> 00:13:57,630
it is like route ratings on the fly yeah

00:13:51,960 --> 00:14:01,200
so this is basically all the API of be

00:13:57,630 --> 00:14:03,510
like x layer over ice-t where you can

00:14:01,200 --> 00:14:05,310
get no which is a particular type and if

00:14:03,510 --> 00:14:08,550
you some children or collection of

00:14:05,310 --> 00:14:11,550
children or it can be one of the kindest

00:14:08,550 --> 00:14:16,890
research there is also a so called

00:14:11,550 --> 00:14:19,470
untyped where for the ISDN where there

00:14:16,890 --> 00:14:27,560
is only a single type syntax node which

00:14:19,470 --> 00:14:30,180
can hold any note so by calling a

00:14:27,560 --> 00:14:33,510
simplex method we get a reference to the

00:14:30,180 --> 00:14:36,540
next node and like what's also kind of

00:14:33,510 --> 00:14:40,020
course representation is that this index

00:14:36,540 --> 00:14:45,600
node is basically exactly the same as

00:14:40,020 --> 00:14:48,810
the expression node we've got before so

00:14:45,600 --> 00:14:52,650
every type ice-t node is a transparent

00:14:48,810 --> 00:14:55,440
wrapper around the on x index node and

00:14:52,650 --> 00:14:57,510
what it says so it doesn't store any

00:14:55,440 --> 00:15:00,600
additional fields it'll cetera it only

00:14:57,510 --> 00:15:03,029
gives you study information about what

00:15:00,600 --> 00:15:06,000
kinds of fields are available for this

00:15:03,029 --> 00:15:07,740
index node so you actually can get a

00:15:06,000 --> 00:15:10,230
reference to a specs note from a

00:15:07,740 --> 00:15:13,290
reference to an expression due to the

00:15:10,230 --> 00:15:15,980
fact that this is marked as wrapper

00:15:13,290 --> 00:15:15,980
transparence

00:15:18,550 --> 00:15:24,200
yes oh this transparent beat is

00:15:21,230 --> 00:15:29,590
important and this unsafe Impala is also

00:15:24,200 --> 00:15:29,590
important to pass between the references

00:15:30,280 --> 00:15:36,350
we can also get in the opposite

00:15:33,830 --> 00:15:40,070
direction from the antique node2 typed

00:15:36,350 --> 00:15:42,940
note the cast operator but costs

00:15:40,070 --> 00:15:45,770
obviously returns an option because you

00:15:42,940 --> 00:15:51,440
don't know if it's not actually that's

00:15:45,770 --> 00:15:53,630
expression a lot and yeah the app cast

00:15:51,440 --> 00:16:00,050
also returns the references because this

00:15:53,630 --> 00:16:02,210
is not parenting the way the way cutting

00:16:00,050 --> 00:16:12,920
walk is that each team picks north

00:16:02,210 --> 00:16:16,190
towards so called syntax kind yeah so

00:16:12,920 --> 00:16:18,530
subscribe is giant annum which holds all

00:16:16,190 --> 00:16:21,380
the various type of syntax note rust

00:16:18,530 --> 00:16:24,710
chest it's both for tokens like

00:16:21,380 --> 00:16:28,070
parentheses curly braces etc and for

00:16:24,710 --> 00:16:37,460
like bigger things like if expression

00:16:28,070 --> 00:16:39,260
and expression cetera et cetera and the

00:16:37,460 --> 00:16:42,110
cast a curator basically checks that the

00:16:39,260 --> 00:16:44,390
kind of Angela ends index node much they

00:16:42,110 --> 00:16:47,870
study kind of the highest expression and

00:16:44,390 --> 00:16:56,150
then just has to stop or if it doesn't

00:16:47,870 --> 00:16:58,340
match it returns none yep so this Ross

00:16:56,150 --> 00:17:02,810
index contains a kind

00:16:58,340 --> 00:17:05,120
it contains text range and text range is

00:17:02,810 --> 00:17:07,070
actually an absolute range into the file

00:17:05,120 --> 00:17:08,780
so it's both a start offset and the end

00:17:07,070 --> 00:17:13,370
of self and this is the an interesting

00:17:08,780 --> 00:17:16,400
bit because the syntax does support

00:17:13,370 --> 00:17:19,220
incremental parsing and in Toronto a

00:17:16,400 --> 00:17:22,190
person and ability to store absolute

00:17:19,220 --> 00:17:24,620
offsets is like somewhat contradictory

00:17:22,190 --> 00:17:27,230
because when you modify

00:17:24,620 --> 00:17:27,950
part of the tree you have to fix all the

00:17:27,230 --> 00:17:30,380
above sets

00:17:27,950 --> 00:17:32,630
downstream and

00:17:30,380 --> 00:17:37,760
it actually is possible to do that and

00:17:32,630 --> 00:17:39,590
with like vlog and complexity if you use

00:17:37,760 --> 00:17:42,500
the clever implementation from Roslin

00:17:39,590 --> 00:17:45,200
and lives index we probably blow talk

00:17:42,500 --> 00:17:48,830
about a bit later but the general idea

00:17:45,200 --> 00:17:51,740
is that you calculate these ranges

00:17:48,830 --> 00:17:54,380
lately so if you haven't operated a

00:17:51,740 --> 00:17:56,630
particular range you haven't to update

00:17:54,380 --> 00:17:58,880
it and if you have to update the range

00:17:56,630 --> 00:18:02,390
you it means that you have colitis it

00:17:58,880 --> 00:18:04,460
and that means that like average time to

00:18:02,390 --> 00:18:07,340
update all the ranges is actually

00:18:04,460 --> 00:18:10,870
constant because you've spent some a lot

00:18:07,340 --> 00:18:16,179
of credit to calculate in those ranges

00:18:10,870 --> 00:18:18,830
yeah so it's not also like contains

00:18:16,179 --> 00:18:22,070
their full fidelity text of the note

00:18:18,830 --> 00:18:24,650
like exactly the sequence of bytes that

00:18:22,070 --> 00:18:27,200
it's that is in the source file

00:18:24,650 --> 00:18:31,070
it doesn't like contains literally a

00:18:27,200 --> 00:18:33,320
reference to a text but each token each

00:18:31,070 --> 00:18:36,049
leaf porting contains like a bit of text

00:18:33,320 --> 00:18:38,120
to distort them so you can get a text to

00:18:36,049 --> 00:18:39,909
the node by just walking all the talking

00:18:38,120 --> 00:18:43,760
stuff right

00:18:39,909 --> 00:18:46,789
it also contains this generic API for

00:18:43,760 --> 00:18:49,669
Jefferson tree you get you can get to

00:18:46,789 --> 00:18:52,640
the parent to be first child the next

00:18:49,669 --> 00:18:55,370
sibling and that allows you to get from

00:18:52,640 --> 00:18:58,250
any point to the tree to any other point

00:18:55,370 --> 00:19:00,950
of the tree and this is the kind of

00:18:58,250 --> 00:19:03,679
property that you can get from here to

00:19:00,950 --> 00:19:07,100
there which places like requirements on

00:19:03,679 --> 00:19:08,809
how the API might look like because it

00:19:07,100 --> 00:19:12,230
means that you need some kind of a

00:19:08,809 --> 00:19:16,490
shared ownership you can't draw you can

00:19:12,230 --> 00:19:19,010
hold a reference to a node inside the

00:19:16,490 --> 00:19:20,840
file and drop all other nodes because

00:19:19,010 --> 00:19:25,220
that would mean that part things would

00:19:20,840 --> 00:19:29,950
be invalidated in the current stop you

00:19:25,220 --> 00:19:29,950
also you always maintain the whole file

00:19:30,260 --> 00:19:37,309
okay so obviously using this like basic

00:19:32,990 --> 00:19:39,830
atomic methods you can build some nice

00:19:37,309 --> 00:19:41,900
services for example you can take all

00:19:39,830 --> 00:19:46,580
the ancestors of this expression node

00:19:41,900 --> 00:19:49,309
and find a function definition among

00:19:46,580 --> 00:19:52,010
those ancestors and here you can for

00:19:49,309 --> 00:19:54,860
example compare that yeah this function

00:19:52,010 --> 00:20:02,179
gets here is exactly the function we

00:19:54,860 --> 00:20:04,669
have started from over here we has also

00:20:02,179 --> 00:20:06,910
like siblings and a way to walk some

00:20:04,669 --> 00:20:06,910
tree

00:20:08,059 --> 00:20:12,650
it's interesting that yeah due to due to

00:20:10,970 --> 00:20:15,640
the fact that we have parent quarters we

00:20:12,650 --> 00:20:18,350
can actually implement what in a subtree

00:20:15,640 --> 00:20:20,480
using only constant amount of memory so

00:20:18,350 --> 00:20:23,150
you don't have to write a recursive

00:20:20,480 --> 00:20:26,140
traversal which maintains a stack you

00:20:23,150 --> 00:20:29,270
can do this in a single stack frame

00:20:26,140 --> 00:20:32,390
there's like a nice pre-order API which

00:20:29,270 --> 00:20:35,059
tells you hey we entered this node and

00:20:32,390 --> 00:20:38,240
then we left this now then it can be

00:20:35,059 --> 00:20:43,669
used to implement stop like printing a

00:20:38,240 --> 00:20:47,440
tree and yeah basically these three

00:20:43,669 --> 00:20:50,630
presentation is implemented using this

00:20:47,440 --> 00:20:56,450
pre-order method and enter live events

00:20:50,630 --> 00:20:58,549
used to maintain indentation and here we

00:20:56,450 --> 00:21:05,960
actually see that we have this white

00:20:58,549 --> 00:21:08,270
space now explicitly in between yeah so

00:21:05,960 --> 00:21:11,990
usually when you traverse between you

00:21:08,270 --> 00:21:13,940
want like some kind of an iced tea visit

00:21:11,990 --> 00:21:15,220
ever expression or visit every item or

00:21:13,940 --> 00:21:19,130
something like that

00:21:15,220 --> 00:21:21,980
in this two part just way you can do it

00:21:19,130 --> 00:21:23,210
is to using the cache method so here I

00:21:21,980 --> 00:21:27,919
would like to collect all the

00:21:23,210 --> 00:21:30,919
expressions so I get the raw syntax of

00:21:27,919 --> 00:21:35,179
the file and get all the descendant

00:21:30,919 --> 00:21:36,260
modes of the file and kill and cast an

00:21:35,179 --> 00:21:38,210
order to expression

00:21:36,260 --> 00:21:41,030
take on the ghost results the Poisson

00:21:38,210 --> 00:21:44,530
and you get Texas etcetera it's also

00:21:41,030 --> 00:21:48,380
possible to do a visitor style API

00:21:44,530 --> 00:21:51,410
it's possible to implement visitor as

00:21:48,380 --> 00:21:53,390
selling some trait which you have to

00:21:51,410 --> 00:21:57,800
implement which has all methods

00:21:53,390 --> 00:22:03,140
deposited but I kind of try to do this

00:21:57,800 --> 00:22:06,590
in a more cute way where you can write a

00:22:03,140 --> 00:22:10,370
time directed visitor so you write like

00:22:06,590 --> 00:22:13,010
I'd like to use F and F and used by a

00:22:10,370 --> 00:22:16,130
lambda which accents and F and you can

00:22:13,010 --> 00:22:21,640
do something about it so this is again

00:22:16,130 --> 00:22:24,530
works because each F and F

00:22:21,640 --> 00:22:27,260
now's its index kind

00:22:24,530 --> 00:22:29,690
so because the visitor knows that it has

00:22:27,260 --> 00:22:32,510
to walk a friend f it knows that it has

00:22:29,690 --> 00:22:36,580
to look at the node with this particular

00:22:32,510 --> 00:22:40,970
index kind and yeah it works

00:22:36,580 --> 00:22:45,080
so this so it's kind of like a builder

00:22:40,970 --> 00:22:47,870
pattern for visitors yes because you

00:22:45,080 --> 00:22:51,470
just think can supply it a lamp and it

00:22:47,870 --> 00:22:53,060
will figure out the types it's cute it's

00:22:51,470 --> 00:22:55,820
cute it's cute but like actually in

00:22:53,060 --> 00:22:58,340
practice it's not much better than just

00:22:55,820 --> 00:23:01,430
using casts because it's doesn't buy you

00:22:58,340 --> 00:23:03,650
a lot of type safety because you still

00:23:01,430 --> 00:23:06,770
get this like you get none in the fault

00:23:03,650 --> 00:23:10,160
case so just I in practice like

00:23:06,770 --> 00:23:12,740
tactically use custom yeah but yes it

00:23:10,160 --> 00:23:16,340
depends on many things here yeah but you

00:23:12,740 --> 00:23:18,110
can totally make life more type most

00:23:16,340 --> 00:23:20,090
strongly typed visitor where you have to

00:23:18,110 --> 00:23:20,800
under write each expression or something

00:23:20,090 --> 00:23:23,330
like that

00:23:20,800 --> 00:23:25,310
it's probably like actually not too

00:23:23,330 --> 00:23:28,220
important because the bulk of analysis

00:23:25,310 --> 00:23:30,020
does not actually operate on this syntax

00:23:28,220 --> 00:23:31,430
tree indirectly this is X 3 and this

00:23:30,020 --> 00:23:33,260
you're getting to more lower level

00:23:31,430 --> 00:23:34,210
visitation which we'll talk about

00:23:33,260 --> 00:23:38,090
shortly

00:23:34,210 --> 00:23:40,820
well not show me one talk about it ok so

00:23:38,090 --> 00:23:44,540
are there any questions about this high

00:23:40,820 --> 00:23:50,510
level API because we are going to dive

00:23:44,540 --> 00:23:51,830
into implementation right now okay so

00:23:50,510 --> 00:23:54,020
let's

00:23:51,830 --> 00:23:58,100
[Music]

00:23:54,020 --> 00:24:01,020
let's dive into implementation well

00:23:58,100 --> 00:24:06,840
first bit is what I've already shown you

00:24:01,020 --> 00:24:10,470
is that each index node is actually a

00:24:06,840 --> 00:24:17,550
wrapper around a rose index node and

00:24:10,470 --> 00:24:21,630
this actually is all generated from this

00:24:17,550 --> 00:24:24,090
data file in your own format so it's

00:24:21,630 --> 00:24:27,870
like just an interesting detail run

00:24:24,090 --> 00:24:32,340
being thrust object notation notation

00:24:27,870 --> 00:24:37,680
just examine on format and it's actually

00:24:32,340 --> 00:24:42,030
kind of pretty big files like 5,000

00:24:37,680 --> 00:24:47,450
lines of syntax nodes I'm glad I have

00:24:42,030 --> 00:24:50,520
not - right it's the hands okay so the

00:24:47,450 --> 00:24:52,970
implementation of the national data

00:24:50,520 --> 00:24:55,350
structure lives in the raw and crate and

00:24:52,970 --> 00:25:01,830
here's actual source code of their own

00:24:55,350 --> 00:25:04,850
crate the representation is to learn it

00:25:01,830 --> 00:25:08,430
contains many purely functional

00:25:04,850 --> 00:25:11,670
so-called green tree which does not

00:25:08,430 --> 00:25:15,420
store offset or parent pointers and it

00:25:11,670 --> 00:25:18,630
contains lazy layer of syntax node or

00:25:15,420 --> 00:25:20,850
red nodes which contains parent pointers

00:25:18,630 --> 00:25:23,520
and absolute offsets but is lightly

00:25:20,850 --> 00:25:27,480
populated so let's start with the green

00:25:23,520 --> 00:25:31,760
node it's not too interesting basically

00:25:27,480 --> 00:25:37,170
a green node is either a token which has

00:25:31,760 --> 00:25:40,860
text and syntax kind this chicken kind

00:25:37,170 --> 00:25:42,930
is what was super sky and rust analyzed

00:25:40,860 --> 00:25:46,620
because this liner is certain generic

00:25:42,930 --> 00:25:49,890
sperm tries on this parameter it also

00:25:46,620 --> 00:25:51,720
can be a branch and because this green

00:25:49,890 --> 00:25:54,450
node should be cheap navigable we are

00:25:51,720 --> 00:25:58,440
using art here so you can imagine like

00:25:54,450 --> 00:26:01,410
you can substitute a single child in

00:25:58,440 --> 00:26:03,690
some node and this will clone only some

00:26:01,410 --> 00:26:06,630
of nodes and nautical tree

00:26:03,690 --> 00:26:10,170
so the branch contains the total length

00:26:06,630 --> 00:26:13,020
which is a sum of length of children it

00:26:10,170 --> 00:26:16,140
also contains a current and it contains

00:26:13,020 --> 00:26:19,470
an array of children The Spectre

00:26:16,140 --> 00:26:27,800
presentation actually uses a cool trick

00:26:19,470 --> 00:26:31,250
with ll the trailing objects here in

00:26:27,800 --> 00:26:33,720
Swift this basically is a single

00:26:31,250 --> 00:26:36,300
allocation it's dynamically size type

00:26:33,720 --> 00:26:38,220
where children asked or just after we

00:26:36,300 --> 00:26:41,340
know that cell so there is no

00:26:38,220 --> 00:26:43,320
implementation and implementation of

00:26:41,340 --> 00:26:48,050
this trick yet but it could be probably

00:26:43,320 --> 00:26:50,750
edit once we had user defined is this so

00:26:48,050 --> 00:26:55,100
just be usual you've usable syntax tree

00:26:50,750 --> 00:26:58,980
nothing interesting here do we have

00:26:55,100 --> 00:27:00,810
methods to replace no I wonder well

00:26:58,980 --> 00:27:05,100
other methods for replacement but the

00:27:00,810 --> 00:27:07,740
promotion somewhere just to restate I

00:27:05,100 --> 00:27:10,650
think this is where you said the green

00:27:07,740 --> 00:27:12,660
tree kind of is the underlying tree it

00:27:10,650 --> 00:27:14,850
only has information and downward right

00:27:12,660 --> 00:27:17,370
like about its children so that they can

00:27:14,850 --> 00:27:20,100
be relocated and if incremental reports

00:27:17,370 --> 00:27:23,640
without yes be relocated it can also be

00:27:20,100 --> 00:27:25,560
shared about line between different file

00:27:23,640 --> 00:27:27,060
level twist so this is actually

00:27:25,560 --> 00:27:30,180
implemented but you can imagine that if

00:27:27,060 --> 00:27:33,450
you have the same one plus one in two

00:27:30,180 --> 00:27:35,730
places in the index three you can

00:27:33,450 --> 00:27:39,270
actually use the same green node for

00:27:35,730 --> 00:27:41,940
both instances of one plus one in other

00:27:39,270 --> 00:27:49,230
words green node nodes do not have

00:27:41,940 --> 00:27:51,480
identity yes yeah the syntax nodes have

00:27:49,230 --> 00:27:53,760
identity and here we are getting to this

00:27:51,480 --> 00:27:58,650
bit unsafe code which allows you for

00:27:53,760 --> 00:28:04,590
three are thing so that's not it

00:27:58,650 --> 00:28:07,700
tours a reference to a green node it

00:28:04,590 --> 00:28:13,410
also stores a reference to parents and

00:28:07,700 --> 00:28:17,820
stores a reference to the root of

00:28:13,410 --> 00:28:20,460
extreme and the idea is that all simple

00:28:17,820 --> 00:28:23,580
are owned by the root of a dream so when

00:28:20,460 --> 00:28:26,280
the room goes away all steps nodes go

00:28:23,580 --> 00:28:28,200
away and we must make sure that as long

00:28:26,280 --> 00:28:33,540
as we have a reference list index node

00:28:28,200 --> 00:28:36,740
the root itself is always alive the root

00:28:33,540 --> 00:28:40,140
itself is not aspects node it's just

00:28:36,740 --> 00:28:43,860
some special data structure which

00:28:40,140 --> 00:28:46,530
contains which owns the nose itself and

00:28:43,860 --> 00:28:48,810
here I use the arena's optimization

00:28:46,530 --> 00:28:50,960
Wednesday not a really crucial bit of

00:28:48,810 --> 00:28:54,000
the implementation and it also contains

00:28:50,960 --> 00:28:57,630
an arbitrary data structure which you

00:28:54,000 --> 00:29:02,280
can associate with into itself in rust

00:28:57,630 --> 00:29:05,250
analyzer I store syntax errors like the

00:29:02,280 --> 00:29:07,530
actual messages in these route data

00:29:05,250 --> 00:29:09,060
field but I actually now think that

00:29:07,530 --> 00:29:10,980
probably this is a bad design and they

00:29:09,060 --> 00:29:12,540
should be inspected or else would

00:29:10,980 --> 00:29:14,610
probably be stored completely separate

00:29:12,540 --> 00:29:16,620
from the tool itself like parsing

00:29:14,610 --> 00:29:20,070
process should produced at Paris index

00:29:16,620 --> 00:29:21,650
three and a set of errors that's

00:29:20,070 --> 00:29:28,800
probably not important

00:29:21,650 --> 00:29:32,120
okay so yeah the interesting bit here is

00:29:28,800 --> 00:29:37,820
of course laziness and this is the chief

00:29:32,120 --> 00:29:46,050
the this amazing out data structure so

00:29:37,820 --> 00:29:48,390
these lazy node is sort of an odd tear

00:29:46,050 --> 00:29:50,370
until you looked at it and when you

00:29:48,390 --> 00:29:53,040
looked into this place you know we

00:29:50,370 --> 00:29:54,690
actually allocate and you see the X node

00:29:53,040 --> 00:29:58,590
set up its parent doing notice it's

00:29:54,690 --> 00:30:01,500
route cetera this happens we get child

00:29:58,590 --> 00:30:04,620
map so if we want to get a child of

00:30:01,500 --> 00:30:06,900
index nodes we look at this lazy node

00:30:04,620 --> 00:30:11,130
and if it's nice to know it already

00:30:06,900 --> 00:30:15,780
exists we just return it otherwise we

00:30:11,130 --> 00:30:19,530
take the green child with the

00:30:15,780 --> 00:30:23,960
appropriate index and allocate a new

00:30:19,530 --> 00:30:27,690
child node and use index node child and

00:30:23,960 --> 00:30:31,730
here we can actually see parent pointer

00:30:27,690 --> 00:30:34,710
the start offset and all these other

00:30:31,730 --> 00:30:40,440
information which does not work with

00:30:34,710 --> 00:30:44,340
incremental repairs okay so it's lazy

00:30:40,440 --> 00:30:47,400
node is based on swap cell which kind of

00:30:44,340 --> 00:30:50,070
lazy cell which has some unsafe

00:30:47,400 --> 00:30:52,260
coordinate ability so that you can get

00:30:50,070 --> 00:31:01,230
either get value or initialize it with

00:30:52,260 --> 00:31:03,930
some much and the business is how do you

00:31:01,230 --> 00:31:08,360
actually maintain this invariant that as

00:31:03,930 --> 00:31:12,270
long as you have a sip X node you have

00:31:08,360 --> 00:31:17,640
root of its we alive as well there is

00:31:12,270 --> 00:31:20,280
where these three hours pipe comes in so

00:31:17,640 --> 00:31:23,910
our three arc is a type which stores a

00:31:20,280 --> 00:31:27,150
reference to a single node inside the

00:31:23,910 --> 00:31:28,910
tree so this inner is a pointer to the

00:31:27,150 --> 00:31:37,080
node inside the street not to the root

00:31:28,910 --> 00:31:39,810
but it also makes sure that when you

00:31:37,080 --> 00:31:43,770
create a tree art would actually bumps

00:31:39,810 --> 00:31:48,780
the arc pointer let me show this one

00:31:43,770 --> 00:31:52,860
yeah so here if we get have a reference

00:31:48,780 --> 00:31:56,340
to a node inside the tree we can wrap

00:31:52,860 --> 00:32:02,060
this node into an ownership business we

00:31:56,340 --> 00:32:06,300
are and to do that we manually bound the

00:32:02,060 --> 00:32:09,660
pointer to the tree itself and then we

00:32:06,300 --> 00:32:14,300
create a trigger elantra conversely in

00:32:09,660 --> 00:32:19,880
drop we decrement the counter and this

00:32:14,300 --> 00:32:19,880
could potentially drop the whole tree

00:32:23,380 --> 00:32:32,830
yeah so like the initial reference count

00:32:30,250 --> 00:32:35,260
of one we get in the new route method

00:32:32,830 --> 00:32:37,450
where we get a doing a green note which

00:32:35,260 --> 00:32:41,140
is like fully immutable blah blah blah

00:32:37,450 --> 00:32:43,570
note we get these arbitrary you specify

00:32:41,140 --> 00:32:46,929
data it's very pointer and we get a

00:32:43,570 --> 00:32:52,270
syntax note for these route so we first

00:32:46,929 --> 00:32:55,299
create a route we put it into an arc

00:32:52,270 --> 00:33:00,610
pointer so we get reference count one

00:32:55,299 --> 00:33:04,750
and we create three arc manually without

00:33:00,610 --> 00:33:07,990
bumping art the second time pointing to

00:33:04,750 --> 00:33:11,770
this red node instead and we also use

00:33:07,990 --> 00:33:20,110
some it ability to yeah to actually set

00:33:11,770 --> 00:33:24,520
up a parent pointer because why do we

00:33:20,110 --> 00:33:26,049
need point here yeah because we need

00:33:24,520 --> 00:33:34,080
parent pointer to the root because when

00:33:26,049 --> 00:33:38,350
we are allocating new child we have to

00:33:34,080 --> 00:33:40,539
yeah whatever allocation children or we

00:33:38,350 --> 00:33:46,179
have to ask the arena at the root to

00:33:40,539 --> 00:33:49,630
allocate the list of children so thing

00:33:46,179 --> 00:33:53,919
they're a bit of details here like why

00:33:49,630 --> 00:33:55,480
do we throw with text unit in swap Selma

00:33:53,919 --> 00:34:01,960
it probably not important in general

00:33:55,480 --> 00:34:06,789
idea hope is clear at this point yeah

00:34:01,960 --> 00:34:11,770
any questions here a slight question in

00:34:06,789 --> 00:34:15,340
the arena first of all like in this

00:34:11,770 --> 00:34:18,399
implementation I guess the so for

00:34:15,340 --> 00:34:21,490
allocating the memory for the trees from

00:34:18,399 --> 00:34:23,200
an arena or a partial like mix partly

00:34:21,490 --> 00:34:24,760
from the arena and partly from the heap

00:34:23,200 --> 00:34:27,760
like the arcs are kind of on the heap I

00:34:24,760 --> 00:34:32,020
guess so green nodes are always

00:34:27,760 --> 00:34:34,389
allocated on the heap and this next node

00:34:32,020 --> 00:34:34,960
are allocated on the arena because for

00:34:34,389 --> 00:34:35,990
green nodes

00:34:34,960 --> 00:34:38,570
I want the ability

00:34:35,990 --> 00:34:41,030
to take a subtree and drop us to the

00:34:38,570 --> 00:34:43,220
tree for this note I have to maintain

00:34:41,030 --> 00:34:46,310
the whole tree anyway because I want

00:34:43,220 --> 00:34:49,369
PowerPoint just to work so make sense to

00:34:46,310 --> 00:34:52,240
locate them on the arena when when

00:34:49,369 --> 00:34:56,720
there's an incremental update do you

00:34:52,240 --> 00:34:59,750
also do you trash the entire syntax note

00:34:56,720 --> 00:35:02,330
later because you know yeah for

00:34:59,750 --> 00:35:05,030
incremental updates the entire syntax

00:35:02,330 --> 00:35:09,530
not layer is trashed and this like this

00:35:05,030 --> 00:35:11,780
separation can actually be o4n like you

00:35:09,530 --> 00:35:15,109
can trust the whole syntax file but

00:35:11,780 --> 00:35:20,619
because to create this cross lyrics file

00:35:15,109 --> 00:35:20,619
you have to traverse it just that like

00:35:21,070 --> 00:35:27,890
average to constant update nevertheless

00:35:24,640 --> 00:35:33,440
like for example if user type something

00:35:27,890 --> 00:35:35,660
and you have inspected only the

00:35:33,440 --> 00:35:38,480
particular function to like do Sonic's

00:35:35,660 --> 00:35:40,880
coloring and then user type something

00:35:38,480 --> 00:35:42,770
else you don't have the false in text to

00:35:40,880 --> 00:35:44,089
layer in memory you have this next to

00:35:42,770 --> 00:35:48,130
layer only for this particular function

00:35:44,089 --> 00:35:51,290
so it's cheap to donate I'm like I'm not

00:35:48,130 --> 00:35:54,380
entirely sure about all this complexity

00:35:51,290 --> 00:35:58,250
is actually required because this

00:35:54,380 --> 00:36:00,560
incremental parsing is not a measuring

00:35:58,250 --> 00:36:04,490
scale because technically you read files

00:36:00,560 --> 00:36:06,500
once and they are never modified only

00:36:04,490 --> 00:36:09,849
small amount of files are modified and

00:36:06,500 --> 00:36:13,400
for that files like even from scratch

00:36:09,849 --> 00:36:15,890
from scratch a parson is not too costly

00:36:13,400 --> 00:36:17,900
but wasn't too difficult to implement

00:36:15,890 --> 00:36:22,160
and well why not

00:36:17,900 --> 00:36:24,290
and another thing is that I've talked

00:36:22,160 --> 00:36:26,780
about when I talk about Adams I was

00:36:24,290 --> 00:36:29,119
talking about you can't do nested

00:36:26,780 --> 00:36:30,980
atom-smashing but you can change the

00:36:29,119 --> 00:36:32,660
presentation of the tree and this is

00:36:30,980 --> 00:36:35,210
actually the place where we can take

00:36:32,660 --> 00:36:37,400
advantage of that we can imagine a

00:36:35,210 --> 00:36:39,980
second presentation of the

00:36:37,400 --> 00:36:42,440
implementation where you allocate above

00:36:39,980 --> 00:36:44,240
the green nodes and the next node in the

00:36:42,440 --> 00:36:46,070
single arena and maybe not

00:36:44,240 --> 00:36:48,200
than my green notes and six notes but

00:36:46,070 --> 00:36:50,540
some kind of a foot kind of like yellow

00:36:48,200 --> 00:36:55,040
node which is like eagerly computed blah

00:36:50,540 --> 00:36:58,339
blah blah now and you can the iced tea

00:36:55,040 --> 00:37:00,760
layer does not the IP of ice layer does

00:36:58,339 --> 00:37:03,470
not expose these underlying details

00:37:00,760 --> 00:37:05,690
right you might do that for like create

00:37:03,470 --> 00:37:11,630
soil content or something that you know

00:37:05,690 --> 00:37:13,430
will not be edited later yeah so well I

00:37:11,630 --> 00:37:16,910
have a few questions but I'm wondering

00:37:13,430 --> 00:37:18,020
um before I ask them because I think

00:37:16,910 --> 00:37:19,550
they might be better to leave til the

00:37:18,020 --> 00:37:21,710
end are you planning to present also

00:37:19,550 --> 00:37:23,060
other things built on top of this I

00:37:21,710 --> 00:37:28,330
remember we talked for example about

00:37:23,060 --> 00:37:36,230
like this higher level view on rust code

00:37:28,330 --> 00:37:36,830
yeah oh we are almost out of time well

00:37:36,230 --> 00:37:43,490
time flies

00:37:36,830 --> 00:37:47,619
yeah okay let me just briefly talk about

00:37:43,490 --> 00:37:52,400
the parson and tri-level stuff and maybe

00:37:47,619 --> 00:37:54,349
leave the questions to the tiger and I

00:37:52,400 --> 00:37:55,970
think it's better I think I'd be happy

00:37:54,349 --> 00:38:01,430
to ask the questions you know and zuly

00:37:55,970 --> 00:38:08,330
also if it comes to it yeah so about

00:38:01,430 --> 00:38:10,250
parsley like the cool thing about

00:38:08,330 --> 00:38:14,839
parsley is that actually it is

00:38:10,250 --> 00:38:17,599
independent from the index 3 so the

00:38:14,839 --> 00:38:20,990
syntax to itself lives in erasing back

00:38:17,599 --> 00:38:23,900
straight and parcel depends basically on

00:38:20,990 --> 00:38:28,670
nothing and it communicates with the

00:38:23,900 --> 00:38:32,000
rest of the analyzer using basically

00:38:28,670 --> 00:38:36,170
these two traits for rare token source

00:38:32,000 --> 00:38:38,170
and twisting and this kind of works nice

00:38:36,170 --> 00:38:41,660
with some type 3 presentation because

00:38:38,170 --> 00:38:44,030
three Scene is sometimes it says what

00:38:41,660 --> 00:38:45,890
like I have started this kind of syntax

00:38:44,030 --> 00:38:48,500
tree and not like a struct with this

00:38:45,890 --> 00:38:51,950
field or blah blah blah blah so it kind

00:38:48,500 --> 00:38:56,839
of works together nicely and parsing is

00:38:51,950 --> 00:39:02,119
not lis too interesting let me just

00:38:56,839 --> 00:39:08,809
we show how our calorie works do we have

00:39:02,119 --> 00:39:13,009
oh it's nominal here so here we see a

00:39:08,809 --> 00:39:15,799
crowd parson struct definition and first

00:39:13,009 --> 00:39:20,210
thing is that we have actually allowed

00:39:15,799 --> 00:39:22,940
struct to miss the name and strategy we

00:39:20,210 --> 00:39:27,849
use here is that if you are trying to

00:39:22,940 --> 00:39:32,809
parse the name and we see a token from

00:39:27,849 --> 00:39:36,049
this set we don't actually consume the

00:39:32,809 --> 00:39:41,839
next column so if we deftly start

00:39:36,049 --> 00:39:46,369
something and event rule so we see here

00:39:41,839 --> 00:39:49,999
that the function syntax node is

00:39:46,369 --> 00:39:52,190
presented completely correctly because

00:39:49,999 --> 00:39:53,269
often struck we haven't consumed this

00:39:52,190 --> 00:39:57,650
append token

00:39:53,269 --> 00:40:00,710
but if except translated like 92 winter

00:39:57,650 --> 00:40:02,900
currently is 92 as an error node so it

00:40:00,710 --> 00:40:06,410
is basically some heuristic to

00:40:02,900 --> 00:40:08,210
understand when we should see that token

00:40:06,410 --> 00:40:12,339
is mistyped or when the token is

00:40:08,210 --> 00:40:16,479
actually part of the next next time and

00:40:12,339 --> 00:40:22,130
another treat for our recovery is that

00:40:16,479 --> 00:40:25,809
when we are parsing list of things we

00:40:22,130 --> 00:40:28,910
basically just ignore all the errors and

00:40:25,809 --> 00:40:32,890
just skip tokens until we actually see

00:40:28,910 --> 00:40:36,499
the close brace so it allows us to

00:40:32,890 --> 00:40:39,130
otherwise errors and it does not matter

00:40:36,499 --> 00:40:42,099
what garbage I'll go into type here the

00:40:39,130 --> 00:40:44,930
syntax tree and then we left in light

00:40:42,099 --> 00:40:46,789
one questionnaire about that yeah I've

00:40:44,930 --> 00:40:49,009
thought about that strategy a lot it

00:40:46,789 --> 00:40:50,390
seems obvious but if you're missing a

00:40:49,009 --> 00:40:53,930
closing brace you could go very wrong

00:40:50,390 --> 00:40:56,960
right do you have some trick to like

00:40:53,930 --> 00:40:58,369
recover like if you encounter I don't

00:40:56,960 --> 00:41:00,680
know what looks like a new item

00:40:58,369 --> 00:41:02,749
no no basically you see yeah but when I

00:41:00,680 --> 00:41:05,450
am I didn't before some bracelet it's my

00:41:02,749 --> 00:41:07,240
light starts to morning when I erase it

00:41:05,450 --> 00:41:10,240
like everything

00:41:07,240 --> 00:41:12,310
Briggs but with proper methods it

00:41:10,240 --> 00:41:15,369
shouldn't be too important practice

00:41:12,310 --> 00:41:19,260
because the analysis time for a file

00:41:15,369 --> 00:41:21,760
should be like under a second under 13

00:41:19,260 --> 00:41:23,859
300 milliseconds Jelena

00:41:21,760 --> 00:41:25,270
I think like the the syntax highlighting

00:41:23,859 --> 00:41:28,780
actually provides a nice feedback for

00:41:25,270 --> 00:41:34,810
the user that like PS I didn't recognize

00:41:28,780 --> 00:41:36,700
this correctly yeah like instantly for

00:41:34,810 --> 00:41:42,609
person ever since like kind of a nice

00:41:36,700 --> 00:41:46,599
user experience right so let's see how

00:41:42,609 --> 00:41:54,880
we actually use parse them to do some

00:41:46,599 --> 00:41:58,359
analysis yeah so the trick is that we

00:41:54,880 --> 00:42:00,849
not actually using these tweets for

00:41:58,359 --> 00:42:03,490
analysis would be bad because twist or

00:42:00,849 --> 00:42:06,190
absolute offsets and absolute i

00:42:03,490 --> 00:42:08,440
destroyed by every edit so if you use

00:42:06,190 --> 00:42:12,099
this node as a saw ck you have to

00:42:08,440 --> 00:42:14,050
compute everything etc so when we want

00:42:12,099 --> 00:42:17,500
to do something in the tree we go the

00:42:14,050 --> 00:42:20,440
lowering process for example to type

00:42:17,500 --> 00:42:23,950
check function we lower a function

00:42:20,440 --> 00:42:27,099
syntax to this bad representation which

00:42:23,950 --> 00:42:30,550
contains expressions but in this like

00:42:27,099 --> 00:42:33,550
yes yes I'll presentation and here the

00:42:30,550 --> 00:42:39,160
expression is like actual an actual atom

00:42:33,550 --> 00:42:42,310
and it does not contain optional steps

00:42:39,160 --> 00:42:44,589
only each expression like if expression

00:42:42,310 --> 00:42:46,450
has condition and has a vent branch and

00:42:44,589 --> 00:42:50,220
they are not options but we allow

00:42:46,450 --> 00:42:55,420
special mission expression to express

00:42:50,220 --> 00:43:03,580
expressions mission some talk about my

00:42:55,420 --> 00:43:06,849
English yeah and we have

00:43:03,580 --> 00:43:06,849
[Music]

00:43:07,660 --> 00:43:13,760
basically a function which takes a

00:43:10,610 --> 00:43:17,690
syntax and I see PowerPoint etcetera

00:43:13,760 --> 00:43:19,510
etcetera and converts it to these anon

00:43:17,690 --> 00:43:24,940
based representation and just

00:43:19,510 --> 00:43:24,940
recursively what's the tree and

00:43:25,570 --> 00:43:33,020
allocates top on this idea Rena etc etc

00:43:29,180 --> 00:43:36,200
and what line is that because this

00:43:33,020 --> 00:43:38,810
representation does not contain offset

00:43:36,200 --> 00:43:41,750
super employers or stuff like that it is

00:43:38,810 --> 00:43:44,630
not it doesn't change when you type

00:43:41,750 --> 00:43:47,630
something before action so it is not

00:43:44,630 --> 00:43:49,190
validated and it probably also is more

00:43:47,630 --> 00:43:52,070
memory efficient because we don't store

00:43:49,190 --> 00:43:55,820
whitespace yes so we can take a syntax

00:43:52,070 --> 00:43:58,550
tree for a file convert all functions to

00:43:55,820 --> 00:44:01,820
this presentation and then we can throw

00:43:58,550 --> 00:44:03,380
away this in that stream and probably

00:44:01,820 --> 00:44:06,710
recreate the syntax to relate when they

00:44:03,380 --> 00:44:09,320
actually need them and to maintain the

00:44:06,710 --> 00:44:12,680
mapping between misrepresentation syntax

00:44:09,320 --> 00:44:15,700
tree we used so-called source map

00:44:12,680 --> 00:44:19,250
pattern where basically stole a hash map

00:44:15,700 --> 00:44:23,210
between these expressions and the syntax

00:44:19,250 --> 00:44:26,150
nodes in the original source tree

00:44:23,210 --> 00:44:28,040
although we don't stole the literal CX

00:44:26,150 --> 00:44:30,230
node because we want to be able to free

00:44:28,040 --> 00:44:32,060
the memory and if you stop is next node

00:44:30,230 --> 00:44:36,050
we store our pointer to the root of the

00:44:32,060 --> 00:44:39,110
trees with two basically and offset and

00:44:36,050 --> 00:44:41,210
a kind of a syntax now so we went

00:44:39,110 --> 00:44:44,180
actually but node we can create it by

00:44:41,210 --> 00:44:47,540
parsing the source again and walking

00:44:44,180 --> 00:44:49,700
between finding the offset yeah so

00:44:47,540 --> 00:44:52,030
that's basically everything I wanted to

00:44:49,700 --> 00:44:52,030
cover

00:44:56,740 --> 00:45:05,090
so this last first of all today we also

00:45:00,200 --> 00:45:07,730
have any other questions Frank but ok

00:45:05,090 --> 00:45:09,200
the last the last point of the design

00:45:07,730 --> 00:45:13,160
kind of gets out what I wanted to ask

00:45:09,200 --> 00:45:19,490
about which was none of the incremental

00:45:13,160 --> 00:45:21,080
story and it feels to me like hmm it's

00:45:19,490 --> 00:45:24,050
kind of a minor point in some sense but

00:45:21,080 --> 00:45:25,520
it feels like the the intermediate node

00:45:24,050 --> 00:45:28,220
which has to be rebuilt actually

00:45:25,520 --> 00:45:30,530
contains a lot more information than I

00:45:28,220 --> 00:45:33,740
suspect you need a lot of the time in

00:45:30,530 --> 00:45:36,560
the form of absolute offsets and so

00:45:33,740 --> 00:45:38,180
forth you need you need some way to get

00:45:36,560 --> 00:45:41,930
an absolute offset but it may not have

00:45:38,180 --> 00:45:43,070
to be like in the tree and I know their

00:45:41,930 --> 00:45:44,660
computer lays like so maybe it doesn't

00:45:43,070 --> 00:45:49,880
matter because you throw away the whole

00:45:44,660 --> 00:45:51,140
syntax tree but uh I don't know baby

00:45:49,880 --> 00:45:52,610
this isn't a specific question and I

00:45:51,140 --> 00:45:54,200
should try to write down a proposal or

00:45:52,610 --> 00:45:56,150
something but it feels to me like we

00:45:54,200 --> 00:45:57,410
could tune this essentially for first

00:45:56,150 --> 00:46:00,160
also like style to get better

00:45:57,410 --> 00:46:02,900
incremental be used across compilations

00:46:00,160 --> 00:46:04,340
but well let me come back let me forget

00:46:02,900 --> 00:46:07,040
that point for one second and dial back

00:46:04,340 --> 00:46:10,040
to the single biggest question I had

00:46:07,040 --> 00:46:12,740
which was one which is related which is

00:46:10,040 --> 00:46:14,780
that one part of your syntax tree had

00:46:12,740 --> 00:46:16,280
the premise that you can sort of get

00:46:14,780 --> 00:46:19,670
from any node in this index tree to any

00:46:16,280 --> 00:46:22,520
other node and that's not it seems to be

00:46:19,670 --> 00:46:25,010
obviously desirable in fact I think it

00:46:22,520 --> 00:46:27,170
has sense to nights and downsides like

00:46:25,010 --> 00:46:29,120
you might want to and specifically

00:46:27,170 --> 00:46:30,740
around incremental basically and what we

00:46:29,120 --> 00:46:34,430
might want to do instead is to make it

00:46:30,740 --> 00:46:37,220
so that it's more like a tree of trees

00:46:34,430 --> 00:46:39,680
or a forest or something the idea being

00:46:37,220 --> 00:46:41,720
that when I get the tree say for a

00:46:39,680 --> 00:46:44,540
particular item like a function in our

00:46:41,720 --> 00:46:46,070
struct yes I can navigate within that

00:46:44,540 --> 00:46:48,800
item freely but if I want to exit the

00:46:46,070 --> 00:46:51,200
item I have to go back to to the API to

00:46:48,800 --> 00:46:52,820
some extent I and the reason for that

00:46:51,200 --> 00:46:54,200
being that then we can track more

00:46:52,820 --> 00:46:55,370
closely which parts of the tree that you

00:46:54,200 --> 00:46:56,830
actually look at so when we do an

00:46:55,370 --> 00:46:59,630
incremental update we might see like

00:46:56,830 --> 00:47:01,280
indeed this imple like you never even

00:46:59,630 --> 00:47:03,580
looked at that impulse little carrots

00:47:01,280 --> 00:47:05,870
that had changed her this function so on

00:47:03,580 --> 00:47:08,960
and maybe that that kind of all comes

00:47:05,870 --> 00:47:12,020
out I guess through the expression I can

00:47:08,960 --> 00:47:14,000
later layers in this also mapping kind

00:47:12,020 --> 00:47:15,020
of achieved that same effect but it

00:47:14,000 --> 00:47:18,140
might be something we want to think

00:47:15,020 --> 00:47:19,760
about pushing earlier I think yeah

00:47:18,140 --> 00:47:22,609
probably my current thought is that

00:47:19,760 --> 00:47:24,859
these bodies mix patent representation

00:47:22,609 --> 00:47:27,440
gets you exactly bet you can inspect the

00:47:24,859 --> 00:47:29,750
body but you can't look outside of it

00:47:27,440 --> 00:47:33,280
and you have to have salsa database

00:47:29,750 --> 00:47:36,859
somewhere get the owner of this body and

00:47:33,280 --> 00:47:39,740
I think the idea is that like this

00:47:36,859 --> 00:47:41,920
syntax tree contains a special

00:47:39,740 --> 00:47:45,290
presentation as possible to make the

00:47:41,920 --> 00:47:47,060
writing IDE work migratory patterns as

00:47:45,290 --> 00:47:50,359
convenient as possible but that we are

00:47:47,060 --> 00:47:52,520
always eager to discard it in generally

00:47:50,359 --> 00:47:54,740
we should like build a syntax tree for a

00:47:52,520 --> 00:47:56,960
single file and then this carbon and

00:47:54,740 --> 00:47:58,640
Gillis industry for the next file this

00:47:56,960 --> 00:48:02,390
probably won't walk with matter

00:47:58,640 --> 00:48:07,010
expansion but probably if I could to

00:48:02,390 --> 00:48:09,680
some extent but I don't think that

00:48:07,010 --> 00:48:12,760
probably we can tweak this and move

00:48:09,680 --> 00:48:16,130
incremental beats closer to actual bars

00:48:12,760 --> 00:48:18,470
yeah I guess it seems okay it just seems

00:48:16,130 --> 00:48:25,490
like a little baked in inefficiency that

00:48:18,470 --> 00:48:26,930
is not obviously necessary or more even

00:48:25,490 --> 00:48:30,410
that much more convenient like we might

00:48:26,930 --> 00:48:31,520
instead say that we you know you have

00:48:30,410 --> 00:48:34,130
all that information that you have to

00:48:31,520 --> 00:48:36,020
sort of ask for it so that we don't it's

00:48:34,130 --> 00:48:37,970
kind of in some sense maybe moving some

00:48:36,020 --> 00:48:43,700
of that lazy rebuilding out from the

00:48:37,970 --> 00:48:46,040
unsafe code and into salsa yeah I'd like

00:48:43,700 --> 00:48:48,650
to kind of show a bit of code where I

00:48:46,040 --> 00:48:50,119
think this like ability to navigate to

00:48:48,650 --> 00:48:54,619
parse it some ships are easily

00:48:50,119 --> 00:48:58,430
especially important so this is a deed

00:48:54,619 --> 00:49:00,980
of completion infrastructure and the

00:48:58,430 --> 00:49:05,300
task of the beach is figuring out what

00:49:00,980 --> 00:49:10,430
we identifier at the position actually

00:49:05,300 --> 00:49:12,770
is about and so here we basically get

00:49:10,430 --> 00:49:15,710
estimate like hey we have an identified

00:49:12,770 --> 00:49:18,410
but let's look at the parent and if this

00:49:15,710 --> 00:49:22,339
is is if this happens to be a named

00:49:18,410 --> 00:49:25,099
field then we are inside

00:49:22,339 --> 00:49:30,640
of like struct it's wrong like this

00:49:25,099 --> 00:49:33,289
thing which type inside expression

00:49:30,640 --> 00:49:38,479
otherwise let's take a look at the

00:49:33,289 --> 00:49:41,329
ancestors and see here if we are at the

00:49:38,479 --> 00:49:46,059
top level in some sense or if we're

00:49:41,329 --> 00:49:54,589
inside a function best of stuff so this

00:49:46,059 --> 00:49:57,199
like I definitely feel that the day I

00:49:54,589 --> 00:50:01,039
was throwing in the Inca walkthrough is

00:49:57,199 --> 00:50:03,769
a useful model to the IDE

00:50:01,039 --> 00:50:05,900
because it's simple you just get parents

00:50:03,769 --> 00:50:09,410
children cetera et cetera the

00:50:05,900 --> 00:50:11,959
implementation totally change and it

00:50:09,410 --> 00:50:16,279
wouldn't be too bad if all of these

00:50:11,959 --> 00:50:19,369
functions will have to get the data base

00:50:16,279 --> 00:50:22,069
argument or something but would make it

00:50:19,369 --> 00:50:25,430
less nice and it actually would make

00:50:22,069 --> 00:50:26,989
these like less constrained because if

00:50:25,430 --> 00:50:31,400
you have a reference to salsa database

00:50:26,989 --> 00:50:32,839
you can get anywhere in the types in the

00:50:31,400 --> 00:50:35,299
matter of the setter etcetera

00:50:32,839 --> 00:50:38,449
she s image 3 is pretty much isolated

00:50:35,299 --> 00:50:40,910
from salsa so there's 0 semantic

00:50:38,449 --> 00:50:43,400
information missing between this kind of

00:50:40,910 --> 00:50:49,390
variable as well could be variable as

00:50:43,400 --> 00:51:03,049
well yeah that makes sense

00:50:49,390 --> 00:51:03,530
thanks I particularly another question

00:51:03,049 --> 00:51:06,680
what

00:51:03,530 --> 00:51:09,020
built atop this like I assume you don't

00:51:06,680 --> 00:51:10,520
have like some take on rust format or

00:51:09,020 --> 00:51:15,950
anything like that because that would be

00:51:10,520 --> 00:51:17,630
incredible but I'm basically trying to

00:51:15,950 --> 00:51:23,060
figure out how much have it would be

00:51:17,630 --> 00:51:24,770
interesting to see sort of examples

00:51:23,060 --> 00:51:28,400
where it was you know each of the case

00:51:24,770 --> 00:51:31,130
of capabilities was used what for head I

00:51:28,400 --> 00:51:33,620
have a certain like where for examples

00:51:31,130 --> 00:51:38,330
like for example one nice feature is

00:51:33,620 --> 00:51:40,700
that if I call giant Lions function in

00:51:38,330 --> 00:51:42,770
rust in Eliza it like actually removes

00:51:40,700 --> 00:51:55,490
these trailing comma for me because

00:51:42,770 --> 00:51:59,260
workshops industries actually yeah and

00:51:55,490 --> 00:52:02,020
here we actually use this capability of

00:51:59,260 --> 00:52:06,770
getting to the previous sibling and

00:52:02,020 --> 00:52:09,560
checking that this is a comma and the

00:52:06,770 --> 00:52:18,050
next node is a closing brace let's just

00:52:09,560 --> 00:52:22,390
remove this coma yep I want to build

00:52:18,050 --> 00:52:26,300
rust from the tree on top of these three

00:52:22,390 --> 00:52:28,870
so it's like this is actually why I am

00:52:26,300 --> 00:52:31,580
interested in nailing down this

00:52:28,870 --> 00:52:35,000
particular aspect of rust analyzing some

00:52:31,580 --> 00:52:37,430
oddity here because if we are final

00:52:35,000 --> 00:52:40,670
about the design of a syntax tree we can

00:52:37,430 --> 00:52:42,200
actually start building in stuff on top

00:52:40,670 --> 00:52:44,900
of this and we can start thinking about

00:52:42,200 --> 00:52:47,270
like how do we move recedes when you use

00:52:44,900 --> 00:52:51,010
these trees or something like that it

00:52:47,270 --> 00:52:53,420
sounds like somewhat isolated from my

00:52:51,010 --> 00:52:56,330
heart heart beats like name resolution

00:52:53,420 --> 00:52:58,910
on macro expansion like that

00:52:56,330 --> 00:53:01,700
yes foundational of course the biggest

00:52:58,910 --> 00:53:05,500
question here is how do we do micro

00:53:01,700 --> 00:53:12,160
expansion using these trees I have like

00:53:05,500 --> 00:53:15,309
some some draft what here wish

00:53:12,160 --> 00:53:17,500
I can actually take a talking tree and

00:53:15,309 --> 00:53:19,690
produce a nice team note without

00:53:17,500 --> 00:53:22,030
actually going via text representation

00:53:19,690 --> 00:53:25,480
because I have this like twisting token

00:53:22,030 --> 00:53:28,119
source version for parsing but doesn't

00:53:25,480 --> 00:53:31,900
for example handle hygiene - well like

00:53:28,119 --> 00:53:35,020
in this token representation each target

00:53:31,900 --> 00:53:38,859
has an identity but in this source tree

00:53:35,020 --> 00:53:41,440
because it only remembers tokens way

00:53:38,859 --> 00:53:44,230
like the text of the token I can't say

00:53:41,440 --> 00:53:46,740
that this name instruct came from this

00:53:44,230 --> 00:53:55,839
talk and it somehow has to be

00:53:46,740 --> 00:53:59,490
implemented elsewhere hmm I don't quite

00:53:55,839 --> 00:53:59,490
understand why you can't do that because

00:54:00,240 --> 00:54:05,770
you don't have a way that sort of splice

00:54:02,859 --> 00:54:07,750
the tokens to indicate that they came

00:54:05,770 --> 00:54:09,539
from another they were spliced and from

00:54:07,750 --> 00:54:12,309
somewhere else

00:54:09,539 --> 00:54:14,920
what I'm trying to say is that syntax

00:54:12,309 --> 00:54:18,130
tree currently does not contain any

00:54:14,920 --> 00:54:20,650
semantic information and hygiene isn't

00:54:18,130 --> 00:54:23,740
some cells not information we can either

00:54:20,650 --> 00:54:26,589
build hygiene into the tree itself or we

00:54:23,740 --> 00:54:28,660
can maintain an side table and I'm

00:54:26,589 --> 00:54:30,670
currently leading towards maintaining a

00:54:28,660 --> 00:54:35,829
side table for that but that needs to be

00:54:30,670 --> 00:54:37,859
implemented in general there's like it's

00:54:35,829 --> 00:54:41,230
not just about hygiene I mean generally

00:54:37,859 --> 00:54:44,170
the spins in rusty at least have a sort

00:54:41,230 --> 00:54:45,579
of extry - them right like a stack

00:54:44,170 --> 00:54:48,789
structure so that we can say things like

00:54:45,579 --> 00:54:50,319
we we use this internally to say things

00:54:48,789 --> 00:54:52,480
like we do sugar the for loop into a

00:54:50,319 --> 00:54:55,210
while loop but when you see this while

00:54:52,480 --> 00:54:57,250
loop like it's compiler generated from

00:54:55,210 --> 00:55:00,390
this original source do you have any

00:54:57,250 --> 00:55:02,770
notion of the left handling that kind of

00:55:00,390 --> 00:55:06,579
information would that also be a side

00:55:02,770 --> 00:55:11,200
table I guess yes so it's actually on

00:55:06,579 --> 00:55:16,930
the tree it's like called a token map

00:55:11,200 --> 00:55:18,910
and like it's not really works

00:55:16,930 --> 00:55:22,150
just some dropped code but the idea is

00:55:18,910 --> 00:55:26,180
that each token has an identity

00:55:22,150 --> 00:55:30,970
basically integer and we can for example

00:55:26,180 --> 00:55:33,920
map each token in the token tree to the

00:55:30,970 --> 00:55:37,780
source span where this token came from

00:55:33,920 --> 00:55:42,440
and kind of maintain that back but I

00:55:37,780 --> 00:55:44,750
don't have the general hand notion and I

00:55:42,440 --> 00:55:46,760
probably would like to avoid spicy

00:55:44,750 --> 00:55:48,050
because it seems to me that spans don't

00:55:46,760 --> 00:55:52,310
work quite well with incremental

00:55:48,050 --> 00:55:54,110
compilation idly kind of I will try it

00:55:52,310 --> 00:55:56,590
through my Intel and we'll find great

00:55:54,110 --> 00:55:58,370
babies like expression ID function ie

00:55:56,590 --> 00:55:59,990
something like that but for macro

00:55:58,370 --> 00:56:05,770
expansion here we need some kind of a

00:55:59,990 --> 00:56:08,510
more general martin between tokens okay

00:56:05,770 --> 00:56:13,970
this was super helpful thank you relax

00:56:08,510 --> 00:56:15,650
yeah yeah I probably like it probably

00:56:13,970 --> 00:56:19,910
shouldn't be on video that this is

00:56:15,650 --> 00:56:22,190
really based on the implementation of

00:56:19,910 --> 00:56:24,410
the Swift and Swift has a really wait

00:56:22,190 --> 00:56:26,240
with me explain in this red green stop

00:56:24,410 --> 00:56:28,490
so if you don't understand anything I

00:56:26,240 --> 00:56:30,260
was talking about it makes sense to read

00:56:28,490 --> 00:56:32,270
that first and then watch the video

00:56:30,260 --> 00:56:40,970
unfortunately it will be made of video

00:56:32,270 --> 00:56:43,180
so yeah cool oh sorry cut it here thanks

00:56:40,970 --> 00:56:43,180

YouTube URL: https://www.youtube.com/watch?v=DGAuLWdCCAI


