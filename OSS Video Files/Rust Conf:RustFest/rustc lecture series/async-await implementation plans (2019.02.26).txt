Title: async-await implementation plans (2019.02.26)
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	Meeting to discuss impl strategies for various outstanding async-await bugs.  

The Dropbox Paper doc that we were using is available here:

https://paper.dropbox.com/doc/2019.02.26-impl-discussion-notes--AYcSQHRnxOOCEjqwYjqmcUjmAg-5v4Q2n9cRn2KYgVyWMphQ
Captions: 
	00:00:00,500 --> 00:00:05,370
maybe we could first just say what the

00:00:03,959 --> 00:00:07,080
issues are so there was this like

00:00:05,370 --> 00:00:12,660
lifetime issues that was one of the key

00:00:07,080 --> 00:00:22,520
ones the async function should support

00:00:12,660 --> 00:00:22,520
multiple lifetimes I don't know

00:00:23,180 --> 00:00:34,079
lifetime issues no what was the other

00:00:30,210 --> 00:00:36,239
one five five three two four doesn't

00:00:34,079 --> 00:00:37,170
capture lifetimes of type parameters oh

00:00:36,239 --> 00:00:39,570
yeah

00:00:37,170 --> 00:00:44,730
if other lifetimes are present - if and

00:00:39,570 --> 00:00:46,200
I'm editing yeah so this is I mean this

00:00:44,730 --> 00:00:48,660
is the same issue rate of that it's

00:00:46,200 --> 00:00:50,489
adding plus whatever light and you had

00:00:48,660 --> 00:00:52,800
when our tight parameter might not

00:00:50,489 --> 00:00:55,489
necessarily outlive that lifetime these

00:00:52,800 --> 00:01:00,020
are all boil down to the same like our

00:00:55,489 --> 00:01:03,539
captures behavior for infiltrate isn't

00:01:00,020 --> 00:01:06,630
quite like when you add Plus take

00:01:03,539 --> 00:01:08,549
something isn't quite what you want here

00:01:06,630 --> 00:01:10,500
or at least like we want something

00:01:08,549 --> 00:01:13,470
that's more expressive than the naive

00:01:10,500 --> 00:01:17,580
version of that yeah can you just

00:01:13,470 --> 00:01:19,439
refresh my memory - sorry I know I have

00:01:17,580 --> 00:01:21,390
it right like if we have a nice - then

00:01:19,439 --> 00:01:26,640
let's talk about the disturbing has real

00:01:21,390 --> 00:01:28,729
punch mm-hmm so so currently what

00:01:26,640 --> 00:01:31,560
happens I'm writing on the paper dog

00:01:28,729 --> 00:01:33,420
currently what happens is that if

00:01:31,560 --> 00:01:36,840
there's a lifetime detected so if we

00:01:33,420 --> 00:01:39,450
have some async FN - let's say that we

00:01:36,840 --> 00:01:41,009
have one alleged lifetime in that so

00:01:39,450 --> 00:01:49,850
currently what that does is it turns

00:01:41,009 --> 00:01:56,610
this into FN 2 X n % you wait arrow

00:01:49,850 --> 00:01:58,920
imple future output equals thing + take

00:01:56,610 --> 00:02:01,469
underscore because it's picking up the

00:01:58,920 --> 00:02:07,649
it's seeing that tick underscore inside

00:02:01,469 --> 00:02:10,289
in right here right and it's copying

00:02:07,649 --> 00:02:14,420
that over about lifetime over into the

00:02:10,289 --> 00:02:20,040
output which is the wrong behavior

00:02:14,420 --> 00:02:22,140
like it's incorrect and an issue with

00:02:20,040 --> 00:02:23,940
high perimeters is that what you want is

00:02:22,140 --> 00:02:26,370
if you've got a tie parameter T here

00:02:23,940 --> 00:02:29,160
that is recognized

00:02:26,370 --> 00:02:31,440
before you go sorry but before you had X

00:02:29,160 --> 00:02:32,820
: you ate that did you mean and frontier

00:02:31,440 --> 00:02:36,270
right here

00:02:32,820 --> 00:02:43,230
like this yes sorry

00:02:36,270 --> 00:02:45,240
yeah okay yeah yeah and so the explicit

00:02:43,230 --> 00:02:48,420
lifetime is sort of the the worst

00:02:45,240 --> 00:02:51,110
version of this right which is more

00:02:48,420 --> 00:02:54,390
better depending on how you look at it

00:02:51,110 --> 00:02:56,400
and and what should be happening here

00:02:54,390 --> 00:03:02,040
right is that if we have this generic on

00:02:56,400 --> 00:03:04,260
T here if I add the T Jannard above what

00:03:02,040 --> 00:03:07,020
should happen is that our return type

00:03:04,260 --> 00:03:09,630
should be bounded by the lifetime of T

00:03:07,020 --> 00:03:13,140
and by the lifetime of take a so it

00:03:09,630 --> 00:03:15,330
should outlive no it should not live any

00:03:13,140 --> 00:03:17,370
type parameter or lifetime parameter it

00:03:15,330 --> 00:03:21,420
should live for the minimal intersection

00:03:17,370 --> 00:03:24,510
of all of those right but instead what

00:03:21,420 --> 00:03:30,870
happens is we just try and we do a dumb

00:03:24,510 --> 00:03:33,239
pass over the arguments in in the ast we

00:03:30,870 --> 00:03:35,489
count up we look for all the lifetimes

00:03:33,239 --> 00:03:37,440
and if there are multiple different

00:03:35,489 --> 00:03:39,600
lifetimes we give an error and if

00:03:37,440 --> 00:03:42,120
there's only one lifetime we just add it

00:03:39,600 --> 00:03:48,750
as a plus tick whatever that lifetime

00:03:42,120 --> 00:03:50,370
was it's a current behavior we look all

00:03:48,750 --> 00:03:53,880
the lifetime in the AST if there's

00:03:50,370 --> 00:03:56,959
exactly one we add it as a lifetime

00:03:53,880 --> 00:04:01,769
bound on the future

00:03:56,959 --> 00:04:03,450
yeah message clearly wrong yeah it's

00:04:01,769 --> 00:04:05,640
pretty clearly wrong but gets you like

00:04:03,450 --> 00:04:09,660
enough of the way that it mostly works

00:04:05,640 --> 00:04:10,920
sometimes some of the problem with T I

00:04:09,660 --> 00:04:13,320
think you just said it but I was

00:04:10,920 --> 00:04:14,580
temporarily distracted but is that T may

00:04:13,320 --> 00:04:18,450
or may not outlive today

00:04:14,580 --> 00:04:21,720
right exactly okay and so what you want

00:04:18,450 --> 00:04:23,580
is to actually like in in this case is

00:04:21,720 --> 00:04:26,280
you want to sort of introduce a new

00:04:23,580 --> 00:04:28,090
lifetime like I take async and you want

00:04:26,280 --> 00:04:31,199
to say that all type

00:04:28,090 --> 00:04:34,080
parameters outlive take a sink and all

00:04:31,199 --> 00:04:39,460
lifetimes that appear in the signature

00:04:34,080 --> 00:04:41,410
outlive take a sink right but but then

00:04:39,460 --> 00:04:44,290
you also have some more complicated

00:04:41,410 --> 00:04:46,419
interactions with alignment lifetimes

00:04:44,290 --> 00:04:48,669
because in order to provide that bound

00:04:46,419 --> 00:04:51,639
you need to give a name to each alighted

00:04:48,669 --> 00:04:53,590
lifetime let me know if I'm like

00:04:51,639 --> 00:04:56,290
skipping too far ahead of do you want me

00:04:53,590 --> 00:04:57,460
to write this in the notes no it's okay

00:04:56,290 --> 00:04:59,830
I'm just taking notes on what you said

00:04:57,460 --> 00:05:02,020
but so let's go back to the TK same

00:04:59,830 --> 00:05:03,100
thing so you're saying like sure I mean

00:05:02,020 --> 00:05:12,550
part of this problems that you're

00:05:03,100 --> 00:05:15,340
talking about are like yeah yeah okay

00:05:12,550 --> 00:05:17,440
part of what were like the challenge of

00:05:15,340 --> 00:05:20,710
well with the issue of alighted

00:05:17,440 --> 00:05:23,430
lifetimes that seems like fairly

00:05:20,710 --> 00:05:25,479
specific maybe all of this is to the

00:05:23,430 --> 00:05:27,639
details of how we're doing the lowering

00:05:25,479 --> 00:05:30,520
right yep

00:05:27,639 --> 00:05:35,669
I guess I'd rather first figure out like

00:05:30,520 --> 00:05:38,080
what we think the compiler should do

00:05:35,669 --> 00:05:40,360
kind of conceptually and then worry

00:05:38,080 --> 00:05:41,289
about the lowering problem but I guess

00:05:40,360 --> 00:05:47,680
this is the right answer

00:05:41,289 --> 00:05:51,690
it wants to be doing like some like you

00:05:47,680 --> 00:05:56,680
said introducing some sort of found that

00:05:51,690 --> 00:05:59,800
covers all the captured things um maybe

00:05:56,680 --> 00:06:02,880
because it's not the only solution here

00:05:59,800 --> 00:06:05,349
right in a sense there's no need for a

00:06:02,880 --> 00:06:09,360
in this particular case there's no real

00:06:05,349 --> 00:06:13,380
need for this plus to casing and some

00:06:09,360 --> 00:06:15,820
notion if we do sugar this all right

00:06:13,380 --> 00:06:19,870
hold on let's take sugar this one second

00:06:15,820 --> 00:06:21,190
- if we do sugar this - like I guess

00:06:19,870 --> 00:06:29,260
I'll use the excess starch n-type

00:06:21,190 --> 00:06:33,030
notation yeah yeah the problem to go the

00:06:29,260 --> 00:06:37,820
problem is our original one here

00:06:33,030 --> 00:06:42,470
Dipsy kind of looks

00:06:37,820 --> 00:06:45,380
or I'm sorry I'm trying to decide how to

00:06:42,470 --> 00:06:47,390
what I'm trying to say is we with what

00:06:45,380 --> 00:06:50,930
we could imagine lady if we were writing

00:06:47,390 --> 00:06:59,000
this fully t-shirt you could imagine

00:06:50,930 --> 00:07:01,280
something like this sorry just like here

00:06:59,000 --> 00:07:07,190
we go with some random floating window

00:07:01,280 --> 00:07:09,890
in the middle of my screen you write and

00:07:07,190 --> 00:07:13,010
there it during all those parameters and

00:07:09,890 --> 00:07:14,480
anyone have a bound of like future a you

00:07:13,010 --> 00:07:17,330
know output but it wouldn't have a

00:07:14,480 --> 00:07:20,810
lifetime bound in particular right and

00:07:17,330 --> 00:07:24,860
there's really no reason apart from some

00:07:20,810 --> 00:07:31,070
specifics of the D sugaring that we can

00:07:24,860 --> 00:07:32,330
see sugar to this right well I mean I

00:07:31,070 --> 00:07:35,510
don't know how much you want to get into

00:07:32,330 --> 00:07:37,910
the minutiae of it but the the type like

00:07:35,510 --> 00:07:44,930
the the revealing of the underlying type

00:07:37,910 --> 00:07:46,820
behavior is different right you're

00:07:44,930 --> 00:07:49,220
saying stuff which isn't implemented

00:07:46,820 --> 00:07:51,200
correctly like implemented properly like

00:07:49,220 --> 00:07:53,360
should be able to reveal its type within

00:07:51,200 --> 00:07:55,100
the module it's it's a little thing

00:07:53,360 --> 00:07:57,140
about how just in general existential

00:07:55,100 --> 00:07:59,630
type next to a function isn't the same

00:07:57,140 --> 00:08:01,730
it's actually you won't like a module

00:07:59,630 --> 00:08:04,610
surrounding the function and the

00:08:01,730 --> 00:08:07,070
existential type declaration right sorry

00:08:04,610 --> 00:08:08,240
I didn't mean quite that literally when

00:08:07,070 --> 00:08:11,210
I said to sugar but yes you're

00:08:08,240 --> 00:08:14,090
absolutely right there like but the sort

00:08:11,210 --> 00:08:16,700
of scope of foo is the function itself

00:08:14,090 --> 00:08:22,670
the defining scope or whatever yeah yeah

00:08:16,700 --> 00:08:24,770
exactly and then apart from that I think

00:08:22,670 --> 00:08:27,620
that that's right although I'm not sure

00:08:24,770 --> 00:08:29,570
I'm still I'm still stuck on exactly how

00:08:27,620 --> 00:08:32,960
you're imagining we would do alighted

00:08:29,570 --> 00:08:34,700
lifetimes here cuz like that that's the

00:08:32,960 --> 00:08:37,310
case that I get I'm getting like stuck

00:08:34,700 --> 00:08:39,460
on maybe maybe I'm like over focusing on

00:08:37,310 --> 00:08:39,460
that

00:08:39,820 --> 00:08:44,200
maybe I don't understand him so I don't

00:08:43,030 --> 00:08:45,220
really know what makes an alighted

00:08:44,200 --> 00:08:48,760
lifetime different from any other

00:08:45,220 --> 00:08:50,350
lifetime okay you're saying like I mean

00:08:48,760 --> 00:08:55,410
I know what makes them so tactically

00:08:50,350 --> 00:08:58,750
distinct all right we need like right

00:08:55,410 --> 00:09:02,830
this this lifetime here you're saying so

00:08:58,750 --> 00:09:04,750
but tic underscore isn't isn't the thing

00:09:02,830 --> 00:09:06,730
right tic underscore doesn't match all

00:09:04,750 --> 00:09:10,150
input lifetimes in the argument so like

00:09:06,730 --> 00:09:15,010
you can have multiple alighted right so

00:09:10,150 --> 00:09:16,990
if we had like two arguments right or if

00:09:15,010 --> 00:09:22,930
this is the if this was already sink

00:09:16,990 --> 00:09:30,310
oven yep yep and I think what I would

00:09:22,930 --> 00:09:32,020
expect is conceptually at least as I

00:09:30,310 --> 00:09:34,690
need to make this what is the actual

00:09:32,020 --> 00:09:41,100
syntax you're right here in full it's

00:09:34,690 --> 00:09:45,720
just it's just your return type yeah um

00:09:41,100 --> 00:09:45,720
module of the scoping issue of course

00:09:46,230 --> 00:09:54,430
yeah now I I think you're worried about

00:09:51,870 --> 00:09:57,460
like in the D string itself how do we

00:09:54,430 --> 00:09:59,050
introduce names for today and to be I'm

00:09:57,460 --> 00:10:01,330
not only worried about that but I'm

00:09:59,050 --> 00:10:02,680
worried about that I'm I'm still doing

00:10:01,330 --> 00:10:05,830
this behavior where I'm sort of

00:10:02,680 --> 00:10:10,390
implementing alighted lifetimes during

00:10:05,830 --> 00:10:13,480
during lowering in general right and and

00:10:10,390 --> 00:10:16,600
in that I have to also replicate all the

00:10:13,480 --> 00:10:19,150
errors that you would normally get via

00:10:16,600 --> 00:10:21,040
like alighted lifetimes in a function

00:10:19,150 --> 00:10:23,200
signature and things like that

00:10:21,040 --> 00:10:25,170
and I don't think that that will happen

00:10:23,200 --> 00:10:30,640
that I don't think that just falls out

00:10:25,170 --> 00:10:32,590
yeah okay so it feels like it feels like

00:10:30,640 --> 00:10:34,150
I wind up having a sort of second

00:10:32,590 --> 00:10:36,280
implementation of a lot of lifetimes

00:10:34,150 --> 00:10:38,020
right so let's push that on the stack

00:10:36,280 --> 00:10:41,080
for one second and we'll come back to it

00:10:38,020 --> 00:10:43,170
because I made my main question I think

00:10:41,080 --> 00:10:49,320
it is true though that apart from that

00:10:43,170 --> 00:10:52,810
there is no like if we had a nice scheme

00:10:49,320 --> 00:10:53,560
for doing this Laureen but basically you

00:10:52,810 --> 00:10:55,390
need some

00:10:53,560 --> 00:10:58,420
way to refer back to the alighted

00:10:55,390 --> 00:11:01,360
lifetime in the compiler they have a

00:10:58,420 --> 00:11:03,790
name right they'll get given individual

00:11:01,360 --> 00:11:05,830
indices anonymous zero and on this one

00:11:03,790 --> 00:11:07,990
the problem is that happiest later they

00:11:05,830 --> 00:11:11,110
get right so they get given they get

00:11:07,990 --> 00:11:13,240
given names during lifetime resolution

00:11:11,110 --> 00:11:17,820
right but I don't have any during

00:11:13,240 --> 00:11:23,560
lowering yep sort of anything have true

00:11:17,820 --> 00:11:27,580
well they have have node IDs remember I

00:11:23,560 --> 00:11:29,980
think we have some there is a lifetime

00:11:27,580 --> 00:11:32,740
name but lifetime name is just that

00:11:29,980 --> 00:11:37,720
there's like an underscore variant of it

00:11:32,740 --> 00:11:41,520
oh okay let's yeah that's fine just

00:11:37,720 --> 00:11:44,200
pretend they had names for a second okay

00:11:41,520 --> 00:11:46,540
yeah well so so adding names to them

00:11:44,200 --> 00:11:48,250
right here is just a matter of like we

00:11:46,540 --> 00:11:51,490
could just say you know tick and then

00:11:48,250 --> 00:11:53,350
space a lighted space lifetime well I

00:11:51,490 --> 00:11:54,970
didn't a sink lifetime one the light of

00:11:53,350 --> 00:11:58,420
the extinct lifetime two or something

00:11:54,970 --> 00:12:00,370
right right the problem is then the

00:11:58,420 --> 00:12:03,310
other problem you were like there was

00:12:00,370 --> 00:12:07,960
this bug we found right where because

00:12:03,310 --> 00:12:12,880
like if you do hmm if you do something

00:12:07,960 --> 00:12:15,910
like this there's a implicit to a static

00:12:12,880 --> 00:12:18,190
that gets added here all right and you

00:12:15,910 --> 00:12:20,770
weren't quite handling that logic

00:12:18,190 --> 00:12:22,510
correctly precisely because as you said

00:12:20,770 --> 00:12:24,760
you like we we creating

00:12:22,510 --> 00:12:26,740
that's like the whole dry problem we're

00:12:24,760 --> 00:12:28,420
trying to eliminate yeah I mean I was I

00:12:26,740 --> 00:12:30,100
was literally like just detecting that

00:12:28,420 --> 00:12:32,140
that was that was an alighted lifetime

00:12:30,100 --> 00:12:34,180
and sticking a tick underscore on the

00:12:32,140 --> 00:12:35,830
end and I think that we can like we can

00:12:34,180 --> 00:12:38,350
do better than that obviously now that I

00:12:35,830 --> 00:12:39,670
know what the actual like I didn't

00:12:38,350 --> 00:12:49,779
consider this case at all when I was

00:12:39,670 --> 00:12:52,240
writing that logic so right so so yeah

00:12:49,779 --> 00:12:54,310
so I guess to set what I would what I

00:12:52,240 --> 00:12:58,480
would like to do is I would like to

00:12:54,310 --> 00:13:00,580
lower to something like this yep already

00:12:58,480 --> 00:13:03,490
invoke future lowers to an existential

00:13:00,580 --> 00:13:06,160
type with a funky scope declaration

00:13:03,490 --> 00:13:07,350
right all right internally in the

00:13:06,160 --> 00:13:09,880
compiler we

00:13:07,350 --> 00:13:11,800
I'm using a vague sense of lower here

00:13:09,880 --> 00:13:13,570
but we handle it like that I don't know

00:13:11,800 --> 00:13:15,670
if yeah it's reflected in here yeah

00:13:13,570 --> 00:13:16,870
currently I'm currently I'm reusing a

00:13:15,670 --> 00:13:19,120
bunch of the machinery for how

00:13:16,870 --> 00:13:21,310
infiltrate actually gets lowered itself

00:13:19,120 --> 00:13:22,540
and so I'm passing it a set of bounds

00:13:21,310 --> 00:13:26,350
but you can imagine that I just

00:13:22,540 --> 00:13:30,640
duplicate that and bypass it right hmm

00:13:26,350 --> 00:13:33,399
and I would like I don't know what I

00:13:30,640 --> 00:13:34,839
would like to do about this a lighted

00:13:33,399 --> 00:13:39,370
lifetime situation but I know that what

00:13:34,839 --> 00:13:40,930
I don't want to do is like what you're

00:13:39,370 --> 00:13:43,450
saying we do now basically of like

00:13:40,930 --> 00:13:46,180
iterating through and giving them well

00:13:43,450 --> 00:13:47,320
it yeah I would like to look at the code

00:13:46,180 --> 00:13:52,089
and see can you figure out a better way

00:13:47,320 --> 00:13:53,740
to handle that I guess I guess that's

00:13:52,089 --> 00:13:58,180
what it comes down to that this this

00:13:53,740 --> 00:14:02,050
logic is such a mess though so maybe the

00:13:58,180 --> 00:14:04,060
answer is we can find some first I guess

00:14:02,050 --> 00:14:10,890
I have to remind myself how this even

00:14:04,060 --> 00:14:10,890
works so like when we lower a lifetime

00:14:14,130 --> 00:14:20,140
known as all these modes so it's awesome

00:14:17,740 --> 00:14:25,450
yeah there's the the in-band lifetime

00:14:20,140 --> 00:14:28,120
stuff that I'll throw in there and just

00:14:25,450 --> 00:14:28,660
blame me for all this mess this is not

00:14:28,120 --> 00:14:32,770
your fault

00:14:28,660 --> 00:14:35,140
I refuse to blame you for this I don't

00:14:32,770 --> 00:14:40,060
know who I blame maybe me and Eddie be

00:14:35,140 --> 00:14:40,810
collective all right just a comment I

00:14:40,060 --> 00:14:43,300
was looking for

00:14:40,810 --> 00:14:55,510
I remember reading this comment or

00:14:43,300 --> 00:14:59,010
writing this gun yeah I don't think

00:14:55,510 --> 00:15:06,279
you're this this is all my fault but

00:14:59,010 --> 00:15:08,920
sort of so right so here the problem I

00:15:06,279 --> 00:15:10,430
was trying to solve right okay so

00:15:08,920 --> 00:15:12,740
there's a couple times

00:15:10,430 --> 00:15:14,180
why am I gonna write them I'll just go

00:15:12,740 --> 00:15:15,560
read my notebook but none of you will be

00:15:14,180 --> 00:15:21,670
able to see it if I do that

00:15:15,560 --> 00:15:28,510
so there's like so like sidebar

00:15:21,670 --> 00:15:28,510
lifetimes in lowering so there's like

00:15:29,560 --> 00:15:37,940
lighted lifetimes here right which are

00:15:36,200 --> 00:15:43,820
slightly different from the lighted

00:15:37,940 --> 00:15:49,480
lifetimes here in that these walks of

00:15:43,820 --> 00:15:55,640
lower to a sort of implicit early bound

00:15:49,480 --> 00:16:04,700
perimeter on the in pole and this lowers

00:15:55,640 --> 00:16:08,450
to a late bound parameter on the

00:16:04,700 --> 00:16:15,020
function and I forget exactly actually

00:16:08,450 --> 00:16:17,300
sort of something-something so yeah and

00:16:15,020 --> 00:16:18,800
I guess I guess that when we're talking

00:16:17,300 --> 00:16:21,110
about the early versus late bound I'm

00:16:18,800 --> 00:16:23,060
assuming all this like actually being

00:16:21,110 --> 00:16:28,010
able to turbo fish lifetime arguments

00:16:23,060 --> 00:16:33,140
into a it into a async FN is just

00:16:28,010 --> 00:16:35,150
completely out of scope right is that

00:16:33,140 --> 00:16:38,380
that complicates this by a little mess

00:16:35,150 --> 00:16:41,360
right right turbo uh yeah I would

00:16:38,380 --> 00:16:45,560
presume for now we'll just ignore that

00:16:41,360 --> 00:16:47,720
whole problem seems like otherwise we

00:16:45,560 --> 00:16:51,530
have to worry about that they're all

00:16:47,720 --> 00:16:53,390
late bound right now so yeah so this is

00:16:51,530 --> 00:16:54,680
the thing I was sort of vaguely half

00:16:53,390 --> 00:16:57,940
remembering and I wanted to remember

00:16:54,680 --> 00:17:00,410
what it is so ever in the imple mode

00:16:57,940 --> 00:17:06,040
when we encounter a lifetime that is

00:17:00,410 --> 00:17:06,040
anonymous we

00:17:09,199 --> 00:17:14,040
elect fresh in being left him

00:17:11,459 --> 00:17:16,470
we basically make a fake name for it and

00:17:14,040 --> 00:17:18,839
we create a named lifetime that has this

00:17:16,470 --> 00:17:40,010
special here a lifetime name that means

00:17:18,839 --> 00:17:42,510
this was anonymous so it's alike and

00:17:40,010 --> 00:17:43,860
partly doing this walk for the video but

00:17:42,510 --> 00:17:50,520
more so I actually remember what the

00:17:43,860 --> 00:17:52,230
hell is going on right okay so a

00:17:50,520 --> 00:17:54,210
lifetime name in the here can be one of

00:17:52,230 --> 00:17:58,980
those things one of them is this fresh

00:17:54,210 --> 00:18:01,670
synthetic names what is this okay right

00:17:58,980 --> 00:18:09,540
so sometimes we make these fake names

00:18:01,670 --> 00:18:17,100
that don't really exist and it I guess

00:18:09,540 --> 00:18:19,260
certainly we could do that for right so

00:18:17,100 --> 00:18:21,420
I think okay this is coming back to me

00:18:19,260 --> 00:18:24,330
now so certainly we could do that for a

00:18:21,420 --> 00:18:26,400
lighted lifetime signatures in order to

00:18:24,330 --> 00:18:27,870
like these two gays would be of lifetime

00:18:26,400 --> 00:18:32,070
names of that category maybe that's what

00:18:27,870 --> 00:18:37,350
you're already doing when you do they

00:18:32,070 --> 00:18:39,720
think FN Laurie no okay well we could

00:18:37,350 --> 00:18:42,690
right now no right now it's incredibly

00:18:39,720 --> 00:18:48,900
stupid okay so we could use that but

00:18:42,690 --> 00:18:53,730
that doesn't solve the problem of the

00:18:48,900 --> 00:18:58,820
fact that mmm these defaults are handled

00:18:53,730 --> 00:19:01,740
somewhat differently however let's see

00:18:58,820 --> 00:19:03,300
so I mean I guess the question is really

00:19:01,740 --> 00:19:05,340
just like how complicated that that

00:19:03,300 --> 00:19:07,309
logic is because if it's like it's very

00:19:05,340 --> 00:19:10,110
simple it's probably worth just yeah but

00:19:07,309 --> 00:19:12,150
like it's like it seems like seems like

00:19:10,110 --> 00:19:13,320
maybe we could just like duplicate it

00:19:12,150 --> 00:19:15,120
and it wouldn't be that big of a deal

00:19:13,320 --> 00:19:16,860
but the fact that we kept finding edge

00:19:15,120 --> 00:19:18,300
cases that I didn't know about or didn't

00:19:16,860 --> 00:19:20,169
think to consider made me feel like

00:19:18,300 --> 00:19:24,460
maybe it was more complicated than I am

00:19:20,169 --> 00:19:27,669
I assumed yeah well you never know it's

00:19:24,460 --> 00:19:31,169
like is this the last educator or did

00:19:27,669 --> 00:19:33,639
you not yet get there right but I think

00:19:31,169 --> 00:19:35,230
trying to remember because I made a few

00:19:33,639 --> 00:19:37,869
versions there was at least one version

00:19:35,230 --> 00:19:39,249
where I moved this logic kind of into

00:19:37,869 --> 00:19:46,809
here Laureen but I think it looks like I

00:19:39,249 --> 00:19:51,850
ripped that out so I believe the only

00:19:46,809 --> 00:19:55,480
real special case is exactly okay yes

00:19:51,850 --> 00:19:58,509
so in fact right so what happens is in

00:19:55,480 --> 00:20:02,019
the case where we have a didn't rate we

00:19:58,509 --> 00:20:04,509
invoke this function delighted so yeah

00:20:02,019 --> 00:20:05,950
we invoke when when they find in a

00:20:04,509 --> 00:20:07,359
lighted lifetime we actually in try to

00:20:05,950 --> 00:20:09,340
invoke one of these more descriptive

00:20:07,359 --> 00:20:12,820
lifetimes that tells you about the exact

00:20:09,340 --> 00:20:14,440
scenario right I remember now okay so

00:20:12,820 --> 00:20:18,070
actually I have to handle the same exact

00:20:14,440 --> 00:20:22,749
thing like because and by I I mean this

00:20:18,070 --> 00:20:27,669
PR so when we were trying to add support

00:20:22,749 --> 00:20:30,309
for yes so this is all changed since the

00:20:27,669 --> 00:20:33,639
the lighted alighted lifetimes in imple

00:20:30,309 --> 00:20:36,190
header stuff became a thing right yeah

00:20:33,639 --> 00:20:40,440
and what I'm trying to say is like this

00:20:36,190 --> 00:20:45,460
that PR wants to do sugar like so right

00:20:40,440 --> 00:20:48,480
or right what happens that ampersand

00:20:45,460 --> 00:20:48,480
will do something different there but

00:20:49,499 --> 00:20:56,350
and it wants to do sugar this I don't

00:20:54,009 --> 00:21:05,549
know I think something like this if I

00:20:56,350 --> 00:21:08,289
remember correctly would be sugar too um

00:21:05,549 --> 00:21:11,619
maybe I can't remember if that gets

00:21:08,289 --> 00:21:14,799
inherited or not I took it doesn't the

00:21:11,619 --> 00:21:22,239
point is it has to know about this

00:21:14,799 --> 00:21:23,799
context as well and I think the way it

00:21:22,239 --> 00:21:27,480
does that is that when you have an

00:21:23,799 --> 00:21:30,230
alighted inbound here

00:21:27,480 --> 00:21:33,830
you'll notice me right is becoming

00:21:30,230 --> 00:21:37,190
exactly about precisely this situation

00:21:33,830 --> 00:21:40,260
we sort of bypass the logic

00:21:37,190 --> 00:21:46,020
we don't make a lifetime perimeter and

00:21:40,260 --> 00:21:49,370
we let it fall through not too much to

00:21:46,020 --> 00:21:51,660
get into the sidebar but is there a

00:21:49,370 --> 00:21:54,570
potential issue here right I remember

00:21:51,660 --> 00:21:59,160
trying to introduce a single-use name in

00:21:54,570 --> 00:22:00,540
lifetime lint but that would actually be

00:21:59,160 --> 00:22:04,380
incorrect here because if you had a

00:22:00,540 --> 00:22:09,360
plastic a that is actually doing

00:22:04,380 --> 00:22:12,380
something that is a right you would want

00:22:09,360 --> 00:22:23,190
to use tech underscore in that case I

00:22:12,380 --> 00:22:29,970
think okay yeah so I think we probably

00:22:23,190 --> 00:22:31,260
can if we in the same place like I think

00:22:29,970 --> 00:22:34,530
the way we probably want to handle this

00:22:31,260 --> 00:22:38,780
is actually two gurus a mode and

00:22:34,530 --> 00:22:40,560
anonymous life timer or something maybe

00:22:38,780 --> 00:22:42,870
least that's what that infrastructure

00:22:40,560 --> 00:22:45,150
was for and so we could imagine setting

00:22:42,870 --> 00:22:48,840
a mode such that then when we encounter

00:22:45,150 --> 00:22:50,780
the it may even be the same mode to

00:22:48,840 --> 00:22:53,550
create cram a term odiously

00:22:50,780 --> 00:22:59,070
kind of what we wanted to want to make

00:22:53,550 --> 00:23:02,840
named parameters for them so let's see

00:22:59,070 --> 00:23:02,840
where's the code that actually uses this

00:23:06,029 --> 00:23:14,200
oops just missed it but here this is the

00:23:12,070 --> 00:23:17,860
imple hair stuff right I think we want

00:23:14,200 --> 00:23:19,330
to kind of do this and then when we when

00:23:17,860 --> 00:23:27,519
we lower the function signature and we

00:23:19,330 --> 00:23:30,399
would get out of it well it I don't know

00:23:27,519 --> 00:23:34,440
something like this anyway and take the

00:23:30,399 --> 00:23:34,440
resulting things and put them into the

00:23:36,899 --> 00:23:49,389
okay yeah that seems probably okay yeah

00:23:48,190 --> 00:23:57,970
so if we did that we would solve this

00:23:49,389 --> 00:24:04,139
problem at least yeah having parents for

00:23:57,970 --> 00:24:04,139
the deaths in not present in the ASD

00:24:05,190 --> 00:24:10,190
[Music]

00:24:14,549 --> 00:24:26,529
probably yeah then I will know you got

00:24:18,190 --> 00:24:30,639
me trees did we do that cuz right now in

00:24:26,529 --> 00:24:32,679
a second and infiltrate I know that we

00:24:30,639 --> 00:24:35,590
we have like in the death collector

00:24:32,679 --> 00:24:42,129
there's like some dummy node IDs in the

00:24:35,590 --> 00:24:46,559
st that we passed over yeah I feel like

00:24:42,129 --> 00:24:49,570
I it looks like I kind of leveraged

00:24:46,559 --> 00:24:52,000
whatever you did do this in been my fur

00:24:49,570 --> 00:24:53,470
the same stuff so you use the same stuff

00:24:52,000 --> 00:24:56,799
that I used for Indian legend

00:24:53,470 --> 00:24:59,340
definitions yes okay that looks like

00:24:56,799 --> 00:24:59,340
what it's doing

00:25:03,890 --> 00:25:17,570
okay so a plan is something like we will

00:25:11,250 --> 00:25:20,130
use the anonymous lifetime or create

00:25:17,570 --> 00:25:23,970
maybe this logic introduced does is

00:25:20,130 --> 00:25:31,400
create parameter logic to create fresh

00:25:23,970 --> 00:25:41,160
names for the lighted lifetimes we will

00:25:31,400 --> 00:25:47,280
be sugar to a existential type that has

00:25:41,160 --> 00:25:51,720
a parameter for each lighted life time

00:25:47,280 --> 00:25:54,570
that appears the async FN signature this

00:25:51,720 --> 00:26:01,080
is sort of in contrast to the in pull

00:25:54,570 --> 00:26:07,890
the standard infiltrate behavior right

00:26:01,080 --> 00:26:09,420
which which is limited to those that

00:26:07,890 --> 00:26:15,300
actually appear

00:26:09,420 --> 00:26:20,790
I don't know how hard that would be that

00:26:15,300 --> 00:26:22,820
feels like the right thing does that

00:26:20,790 --> 00:26:54,380
make sense

00:26:22,820 --> 00:27:00,290
I can't remember that's implemented okay

00:26:54,380 --> 00:27:00,830
Taylor can tell yeah okay yeah I'm

00:27:00,290 --> 00:27:04,970
excited

00:27:00,830 --> 00:27:09,190
thank you so it's the next thing I like

00:27:04,970 --> 00:27:12,650
well I don't know what is the next thing

00:27:09,190 --> 00:27:15,110
one thing that I I have it's not

00:27:12,650 --> 00:27:18,560
directly on our list but you had that PR

00:27:15,110 --> 00:27:25,970
for getting rid of after straight or

00:27:18,560 --> 00:27:27,920
whatever existential yeah yeah I like to

00:27:25,970 --> 00:27:30,800
read he's just been bugging me about it

00:27:27,920 --> 00:27:32,360
because I opened the PR and then it was

00:27:30,800 --> 00:27:35,750
unsound and I kind of dropped on the

00:27:32,360 --> 00:27:38,060
floor yes I might work I thought that I

00:27:35,750 --> 00:27:39,500
had initially thought that talking

00:27:38,060 --> 00:27:41,690
through this problem we would sort of

00:27:39,500 --> 00:27:42,830
come to that problem but it we just sort

00:27:41,690 --> 00:27:48,140
of did it

00:27:42,830 --> 00:27:50,990
so yeah around by using exponential type

00:27:48,140 --> 00:27:53,990
rather than trying to do something with

00:27:50,990 --> 00:27:58,490
that right but I I feel like that's

00:27:53,990 --> 00:28:01,640
still something we should try to solve

00:27:58,490 --> 00:28:06,320
but yeah I mean I it's still a problem

00:28:01,640 --> 00:28:09,500
like it seems like I still think we

00:28:06,320 --> 00:28:12,670
should fix it it's just like if we can

00:28:09,500 --> 00:28:16,100
skip the infiltrate you sugaring of

00:28:12,670 --> 00:28:19,160
pasty sugaring of a stinking and dude do

00:28:16,100 --> 00:28:22,190
something that's based on the named

00:28:19,160 --> 00:28:24,590
existential instead I think that right

00:28:22,190 --> 00:28:26,930
that allows for it in its no nor a

00:28:24,590 --> 00:28:28,700
blocker freezing FM yeah that's kind of

00:28:26,930 --> 00:28:31,220
what I was asking is like is it a

00:28:28,700 --> 00:28:32,990
problem just for all the reasons it

00:28:31,220 --> 00:28:35,120
always was infiltrated or is there some

00:28:32,990 --> 00:28:36,480
other problem that it was addressing

00:28:35,120 --> 00:28:39,930
that we have an address

00:28:36,480 --> 00:28:42,930
the specific day seemed different you

00:28:39,930 --> 00:28:44,490
think away I don't think so I mean

00:28:42,930 --> 00:28:47,970
because because the whole issue is that

00:28:44,490 --> 00:28:50,880
we we didn't want a name like since

00:28:47,970 --> 00:28:53,880
today the only way to find a lifetime is

00:28:50,880 --> 00:28:56,660
to either comet as okay or to have it in

00:28:53,880 --> 00:29:02,550
a captures like a dummy capture straight

00:28:56,660 --> 00:29:04,680
yep that's part of the bounds and we we

00:29:02,550 --> 00:29:06,060
can sidestep that by just adding it

00:29:04,680 --> 00:29:07,410
directly to the parameters of the

00:29:06,060 --> 00:29:10,170
accidental type if we don't use the

00:29:07,410 --> 00:29:12,900
infiltrate lowering mechanisms yep so

00:29:10,170 --> 00:29:17,400
right so in some sense this okay so the

00:29:12,900 --> 00:29:19,980
issue with implicate today is you want

00:29:17,400 --> 00:29:24,450
to have a lifetime in the hidden type

00:29:19,980 --> 00:29:26,040
that is not part of the interface not

00:29:24,450 --> 00:29:28,920
part of the bound it is part of the

00:29:26,040 --> 00:29:33,570
interface just like well sorry it's not

00:29:28,920 --> 00:29:36,360
part of the I meant yeah I meant that I

00:29:33,570 --> 00:29:38,010
meant the interface of the returned

00:29:36,360 --> 00:29:50,040
value sort of only allowing people to

00:29:38,010 --> 00:29:51,870
use doesn't restrict what you can do

00:29:50,040 --> 00:29:57,180
with the return type beyond the existing

00:29:51,870 --> 00:29:59,580
lifetime that's used and of course you

00:29:57,180 --> 00:30:03,300
as a author could work around this with

00:29:59,580 --> 00:30:05,250
existential type today modulo like the

00:30:03,300 --> 00:30:06,840
definition become the scoping and all

00:30:05,250 --> 00:30:10,020
that stuff and what we're basically

00:30:06,840 --> 00:30:17,820
saying is we will make the async I found

00:30:10,020 --> 00:30:22,050
you just work around right okay that's

00:30:17,820 --> 00:30:23,520
convincing so that's good I can still

00:30:22,050 --> 00:30:25,830
talk to Alex reg about following up on

00:30:23,520 --> 00:30:28,980
that but it's nicely it's not it's

00:30:25,830 --> 00:30:31,260
probably not an async offender and then

00:30:28,980 --> 00:30:33,300
so one other key things that we

00:30:31,260 --> 00:30:36,690
identified as a potential like backpack

00:30:33,300 --> 00:30:39,120
hazard for async FN was this drop border

00:30:36,690 --> 00:30:40,230
issue and I think that that Lee I don't

00:30:39,120 --> 00:30:41,700
know what you think but I don't know

00:30:40,230 --> 00:30:44,970
that we really need to talk too much fun

00:30:41,700 --> 00:30:46,260
I think it's just like the lowering the

00:30:44,970 --> 00:30:48,900
disappearing and the function needs to

00:30:46,260 --> 00:30:49,650
change so that it actually like unbinds

00:30:48,900 --> 00:30:56,790
the

00:30:49,650 --> 00:30:59,280
the arguments inside of the the async

00:30:56,790 --> 00:31:03,380
the generated async block rather than

00:30:59,280 --> 00:31:11,120
having them be outside of a single block

00:31:03,380 --> 00:31:14,760
yeah I so here I can exhibit yeah I

00:31:11,120 --> 00:31:18,990
basically I agree it doesn't strike the

00:31:14,760 --> 00:31:24,270
example but I don't think it I think my

00:31:18,990 --> 00:31:26,010
feeling is I don't care okay I have an

00:31:24,270 --> 00:31:28,260
opinion I guess with the behavior I

00:31:26,010 --> 00:31:32,100
would expect but I don't have a strong

00:31:28,260 --> 00:31:33,990
opinion and I'm kind of happy to let you

00:31:32,100 --> 00:31:34,170
or votes or whomever make that judgment

00:31:33,990 --> 00:31:37,290
call

00:31:34,170 --> 00:31:38,540
and it seems like whichever way we go

00:31:37,290 --> 00:31:40,950
[Music]

00:31:38,540 --> 00:31:44,070
it's not really a question of how we

00:31:40,950 --> 00:31:56,610
would implement it right like that's

00:31:44,070 --> 00:31:57,900
fairly obvious right and I think the

00:31:56,610 --> 00:31:59,790
current behavior is actually what I

00:31:57,900 --> 00:32:03,179
would expect with this sniper you know

00:31:59,790 --> 00:32:04,800
oh you do well the only reason I would

00:32:03,179 --> 00:32:07,590
expect it is that when you get to these

00:32:04,800 --> 00:32:08,970
weird sort of edge cases I the way I

00:32:07,590 --> 00:32:10,950
usually think about how to figure them

00:32:08,970 --> 00:32:12,540
out is like let's define a canonical be

00:32:10,950 --> 00:32:13,590
sugar into the simpler thing and then I

00:32:12,540 --> 00:32:17,100
figure out what would happen in the

00:32:13,590 --> 00:32:19,440
simpler thing and this is like the

00:32:17,100 --> 00:32:22,020
current e sugar in sort of the canonical

00:32:19,440 --> 00:32:24,059
simple canonical d sugar so I could see

00:32:22,020 --> 00:32:25,260
how it would fall out from that but I

00:32:24,059 --> 00:32:27,330
haven't thought about it from the

00:32:25,260 --> 00:32:30,330
perspective of async FNS like a coherent

00:32:27,330 --> 00:32:38,840
feature like I can see why you might

00:32:30,330 --> 00:32:38,840
come to a distinct conclusion but right

00:32:40,000 --> 00:32:51,970
I guess some well I could go either way

00:32:48,490 --> 00:32:54,400
into those sorry go ahead

00:32:51,970 --> 00:32:57,340
no I'm just saying like they both seem

00:32:54,400 --> 00:33:00,160
fine you can make a case either way yeah

00:32:57,340 --> 00:33:05,760
so alright I think I think the confusing

00:33:00,160 --> 00:33:10,000
thing right is that the parameters drop

00:33:05,760 --> 00:33:13,000
in a different order then they would

00:33:10,000 --> 00:33:17,830
drop in an honest and defend right which

00:33:13,000 --> 00:33:21,850
isn't totally obvious agreed that's not

00:33:17,830 --> 00:33:28,540
great so one thing I'm wondering about

00:33:21,850 --> 00:33:32,640
is um five think you can sort of in a

00:33:28,540 --> 00:33:38,790
normal fm think of the semantics of

00:33:32,640 --> 00:33:38,790
patterns kind of like this yeah

00:33:40,110 --> 00:33:46,090
in which case it looks like what you're

00:33:43,540 --> 00:33:50,920
proposing is that an async FN would be

00:33:46,090 --> 00:33:54,790
sort of like this in which case it seems

00:33:50,920 --> 00:33:59,320
correct like in particular if you had

00:33:54,790 --> 00:34:00,760
like an underscore here I don't know I

00:33:59,320 --> 00:34:06,760
don't actually remember when this drops

00:34:00,760 --> 00:34:09,280
do you but which drops so underscore

00:34:06,760 --> 00:34:10,900
drops immediately but underscore like

00:34:09,280 --> 00:34:21,130
and then the name of something doesn't

00:34:10,900 --> 00:34:23,950
problem no that's just a finding so let

00:34:21,130 --> 00:34:26,620
underscore equal something because it is

00:34:23,950 --> 00:34:33,280
usually and usually but not always an

00:34:26,620 --> 00:34:35,740
immediate drop true for premise whatever

00:34:33,280 --> 00:34:37,810
bottom - I don't carry right it would be

00:34:35,740 --> 00:34:41,560
nice if we could tell a semi coherent

00:34:37,810 --> 00:34:43,780
story where like you can map function in

00:34:41,560 --> 00:34:47,380
a signif mm the core all the corner

00:34:43,780 --> 00:34:49,420
cases are on this - like the canonical D

00:34:47,380 --> 00:34:51,730
sugaring whatever it is so I think I

00:34:49,420 --> 00:34:52,760
think the motivating example for me is

00:34:51,730 --> 00:34:54,139
if you took in

00:34:52,760 --> 00:34:56,899
and like I don't know how many people do

00:34:54,139 --> 00:35:00,380
this like I can imagine you taking in an

00:34:56,899 --> 00:35:03,230
argument that's like a a scope to end

00:35:00,380 --> 00:35:05,030
when your function is over for example

00:35:03,230 --> 00:35:07,850
and then you binding it to like an

00:35:05,030 --> 00:35:10,730
underscore followed by name their

00:35:07,850 --> 00:35:12,290
pattern you know expecting when the

00:35:10,730 --> 00:35:13,940
function which is that thing will be

00:35:12,290 --> 00:35:15,200
dropped and then something will happen I

00:35:13,940 --> 00:35:17,300
can think of this to be this whole

00:35:15,200 --> 00:35:19,820
example for for example and like tracing

00:35:17,300 --> 00:35:22,250
functions like when you want it to time

00:35:19,820 --> 00:35:24,530
the necks q ssin of the function I know

00:35:22,250 --> 00:35:26,090
I'm like AB and variable will be dropped

00:35:24,530 --> 00:35:28,370
and then you know how long the function

00:35:26,090 --> 00:35:29,900
took of course that sort of a stupid

00:35:28,370 --> 00:35:33,920
thing to do and anything happen anyway

00:35:29,900 --> 00:35:36,380
but I'm convinced you're right it's

00:35:33,920 --> 00:35:39,020
totally counterintuitive that you have a

00:35:36,380 --> 00:35:40,850
name thing that you just don't happen to

00:35:39,020 --> 00:35:43,760
use that it's gonna drop in the

00:35:40,850 --> 00:35:45,770
beginning of your async offend when it

00:35:43,760 --> 00:35:49,160
would normally drop at the end of a

00:35:45,770 --> 00:35:52,660
normal event like that just seems wrong

00:35:49,160 --> 00:35:55,520
now that I think about a little more

00:35:52,660 --> 00:35:59,900
right so this is actually what I

00:35:55,520 --> 00:36:01,370
expected in a normal FN and it's

00:35:59,900 --> 00:36:05,000
actually consistent with the D sugaring

00:36:01,370 --> 00:36:08,150
I was showing you because that's not

00:36:05,000 --> 00:36:10,720
what I thought so the reason it's

00:36:08,150 --> 00:36:13,810
consistent with this D sugaring is if

00:36:10,720 --> 00:36:16,790
pattern is underscore this means ignore

00:36:13,810 --> 00:36:22,660
and so right basically the drop is when

00:36:16,790 --> 00:36:25,910
X goes out of scope which is here and

00:36:22,660 --> 00:36:27,500
the same would sort of be true erasing

00:36:25,910 --> 00:36:30,410
offender would go out of scope down here

00:36:27,500 --> 00:36:35,810
and that's for record like at the end of

00:36:30,410 --> 00:36:38,360
yep so okay it's all very annoying wait

00:36:35,810 --> 00:36:40,160
sorry it would go out of scope where

00:36:38,360 --> 00:36:43,370
you're saying they've to let D trigger

00:36:40,160 --> 00:36:44,990
the inside of an async move yes yes then

00:36:43,370 --> 00:36:49,310
if you have an underscore here it will

00:36:44,990 --> 00:36:52,600
drop like as you exit the async block

00:36:49,310 --> 00:36:55,250
sort of which means yeah like later

00:36:52,600 --> 00:36:58,780
whenever the function is done but not

00:36:55,250 --> 00:36:58,780
when the future is done

00:37:03,420 --> 00:37:09,460
sorry what you you do mean asked when

00:37:06,339 --> 00:37:12,460
the future is done and not when you're a

00:37:09,460 --> 00:37:14,470
sting function like the early version of

00:37:12,460 --> 00:37:16,809
it to produce a future has been

00:37:14,470 --> 00:37:23,529
completed yeah that's what I mean

00:37:16,809 --> 00:37:31,210
I mean if you're doing like yeah not

00:37:23,529 --> 00:37:35,079
wait sort of drops here yeah yeah

00:37:31,210 --> 00:37:39,910
that is what I would expect yeah it

00:37:35,079 --> 00:37:43,410
seems right we should change that cool I

00:37:39,910 --> 00:37:46,569
don't think that that doesn't even part

00:37:43,410 --> 00:37:48,249
know it openly seems hard the only

00:37:46,569 --> 00:37:52,660
reason I think it could be hard has to

00:37:48,249 --> 00:37:54,130
do with like complex patterns like we

00:37:52,660 --> 00:37:57,339
kind of do want to introduce it let me

00:37:54,130 --> 00:37:59,289
durable the Nardi sugaring right right

00:37:57,339 --> 00:38:01,329
and that's not hard it's just like a

00:37:59,289 --> 00:38:04,660
high genie question of I can make that

00:38:01,329 --> 00:38:06,670
an invisible name or something there's

00:38:04,660 --> 00:38:08,559
probably a right way to do it we can

00:38:06,670 --> 00:38:12,940
sort of cheat because we're in the here

00:38:08,559 --> 00:38:15,549
itself awesome yeah there fell toast

00:38:12,940 --> 00:38:16,869
well no that has other issues I was

00:38:15,549 --> 00:38:18,849
gonna say there's also an annoying

00:38:16,869 --> 00:38:21,940
question here on unsafe our values but

00:38:18,849 --> 00:38:24,369
that's just gonna break everything right

00:38:21,940 --> 00:38:27,880
basically I think we just want to make

00:38:24,369 --> 00:38:37,569
sure that if it works for all of these

00:38:27,880 --> 00:38:43,180
patterns and it's probably fine like if

00:38:37,569 --> 00:38:44,650
it works analogously to an FM who'd the

00:38:43,180 --> 00:38:45,849
actual bug was just for an unused

00:38:44,650 --> 00:38:47,559
variable and I'm kind of raising

00:38:45,849 --> 00:38:52,440
underscores should make sure to get that

00:38:47,559 --> 00:38:52,440
right - all right

00:38:54,099 --> 00:39:03,199
and there's probably some tests well

00:38:57,400 --> 00:39:05,059
yeah okay they're not somewhere is it is

00:39:03,199 --> 00:39:11,929
it only at the mirror level that we have

00:39:05,059 --> 00:39:15,109
a t-shirt Green happen pretty much okay

00:39:11,929 --> 00:39:22,519
that's sort of unfortunate it's annoying

00:39:15,109 --> 00:39:25,549
yes some part of me thinks that the here

00:39:22,519 --> 00:39:30,579
I got unconvinced by believe I'm not

00:39:25,549 --> 00:39:31,939
sure about the D sugaring around I mean

00:39:30,579 --> 00:39:33,559
it's okay

00:39:31,939 --> 00:39:35,089
we shouldn't get into this I'm not

00:39:33,559 --> 00:39:36,999
convinced we are doing all the t-shirt

00:39:35,089 --> 00:39:39,019
rings in all the right places like

00:39:36,999 --> 00:39:41,029
sometimes I think it would be easier if

00:39:39,019 --> 00:39:43,579
we instead of doing D sugaring as we

00:39:41,029 --> 00:39:48,409
entered here delayed to be sugaring

00:39:43,579 --> 00:39:51,679
until the enter mirror and extend the

00:39:48,409 --> 00:39:54,140
other parts the compiler or maybe change

00:39:51,679 --> 00:39:57,799
what the here is to be sort of a little

00:39:54,140 --> 00:40:02,419
closer to me right um doesn't matter but

00:39:57,799 --> 00:40:03,890
I've changing that basically so yeah I

00:40:02,419 --> 00:40:07,999
mean a bunch of the stuff that I've

00:40:03,890 --> 00:40:09,589
written like a bunch of the stuff that

00:40:07,999 --> 00:40:14,839
I've written like type track cares about

00:40:09,589 --> 00:40:18,669
it right there's a lot of cases layer B

00:40:14,839 --> 00:40:20,449
earlier than you have a mirror right

00:40:18,669 --> 00:40:36,829
yeah I'm not sure what I'm actually

00:40:20,449 --> 00:40:40,339
saying make sense I know a lot yeah so

00:40:36,829 --> 00:40:42,589
oh this is this de Bruyne thing yeah but

00:40:40,339 --> 00:40:43,549
I think this are actually you can scroll

00:40:42,589 --> 00:40:44,779
down to the bottom but I think this

00:40:43,549 --> 00:40:47,269
one's actually fix right now in

00:40:44,779 --> 00:40:49,249
playground and it just got reopening

00:40:47,269 --> 00:40:50,929
because the person one of the someone

00:40:49,249 --> 00:40:53,319
wanted us to add a regression test for

00:40:50,929 --> 00:40:59,239
it okay so that's easy

00:40:53,319 --> 00:41:00,949
yeah this is the drop thing this is the

00:40:59,239 --> 00:41:02,509
disallow async FN that one doesn't

00:41:00,949 --> 00:41:03,740
really take any discussion but it's the

00:41:02,509 --> 00:41:05,880
easy thing

00:41:03,740 --> 00:41:11,569
yeah there's already a pier for that

00:41:05,880 --> 00:41:11,569
even awesome okay

00:41:11,880 --> 00:41:17,510
[Music]

00:41:13,250 --> 00:41:20,640
this is like an error message problem

00:41:17,510 --> 00:41:22,650
yeah so the yield thing I think is just

00:41:20,640 --> 00:41:25,650
like I wasn't planning on spending any

00:41:22,650 --> 00:41:27,329
time on it before we go to a native

00:41:25,650 --> 00:41:30,859
syntax because it seems like a native

00:41:27,329 --> 00:41:35,030
syntax would just obviously fix it right

00:41:30,859 --> 00:41:35,030
which is probably the right attitude

00:41:36,829 --> 00:41:44,700
what is this so these are one of those

00:41:39,000 --> 00:41:50,670
infinite cycle bugs this is the bug

00:41:44,700 --> 00:41:53,579
about right but waiting inside a match

00:41:50,670 --> 00:41:57,180
block captures borrowed too eagerly so I

00:41:53,579 --> 00:42:01,170
think this is the thing I was saying I

00:41:57,180 --> 00:42:04,950
think this is an artifact of like before

00:42:01,170 --> 00:42:06,000
we even get to in a while we have to

00:42:04,950 --> 00:42:09,589
deal with some of this let me try to

00:42:06,000 --> 00:42:18,089
remember I just want to like proof

00:42:09,589 --> 00:42:24,029
verify that I'm not wrong I think for

00:42:18,089 --> 00:42:29,460
example here at the generator generate

00:42:24,029 --> 00:42:35,730
here's a puppy like when we try to prove

00:42:29,460 --> 00:42:39,510
an auto trade for what the name of

00:42:35,730 --> 00:42:42,619
anything is yeah you were saying there

00:42:39,510 --> 00:42:44,970
was some sort of like less smart logic

00:42:42,619 --> 00:42:50,069
all right I want to find that logic and

00:42:44,970 --> 00:42:52,230
think see if I'm correct but yeah

00:42:50,069 --> 00:42:53,940
because we used to do because I remember

00:42:52,230 --> 00:42:55,680
when talking about with any we used to

00:42:53,940 --> 00:42:58,109
do this whole like deferred obligations

00:42:55,680 --> 00:43:01,440
thing right where we would save up all

00:42:58,109 --> 00:43:05,849
of the lists of like infiltrate style

00:43:01,440 --> 00:43:08,130
stuff that needed to have implemented an

00:43:05,849 --> 00:43:10,470
auto trait and then we would sort of

00:43:08,130 --> 00:43:12,990
calculate assuming those are true are

00:43:10,470 --> 00:43:15,410
those true and if not we would we would

00:43:12,990 --> 00:43:15,410
fail

00:43:16,020 --> 00:43:22,450
this was you're talking about related to

00:43:18,700 --> 00:43:24,040
imitate right isn't it is generator

00:43:22,450 --> 00:43:26,200
stuff not in the same camp is this

00:43:24,040 --> 00:43:28,660
because we have to oh right because this

00:43:26,200 --> 00:43:30,190
is you don't have the the full type

00:43:28,660 --> 00:43:31,900
that's actually being generated until

00:43:30,190 --> 00:43:35,170
later because it happens during the

00:43:31,900 --> 00:43:37,380
mirror gee sugaring yeah yeah so

00:43:35,170 --> 00:43:40,570
somewhat different zone here sorry

00:43:37,380 --> 00:43:45,520
you're not like I was also thinking of

00:43:40,570 --> 00:43:47,500
that that old solution but I think so

00:43:45,520 --> 00:43:51,070
the in the this is the trade code and

00:43:47,500 --> 00:43:53,470
this when we see an auto in pole I think

00:43:51,070 --> 00:43:59,470
this function constituent types let's

00:43:53,470 --> 00:44:06,760
see for a generator okay calls up fart

00:43:59,470 --> 00:44:11,010
ice that's not very helpful which well

00:44:06,760 --> 00:44:14,650
in any case I'm 99% sure but let's see

00:44:11,010 --> 00:44:17,590
so this goes through right so the

00:44:14,650 --> 00:44:21,010
generator substance this is like the sub

00:44:17,590 --> 00:44:23,560
the substitutions applied to a generator

00:44:21,010 --> 00:44:26,020
type and they have various up four kinds

00:44:23,560 --> 00:44:31,540
and I think that those substitutions

00:44:26,020 --> 00:44:43,270
have to get generated somewhere in type

00:44:31,540 --> 00:44:50,020
check like here more or less and the

00:44:43,270 --> 00:44:52,089
problem where is it well I may have to

00:44:50,020 --> 00:44:55,749
take a little to this but I'm

00:44:52,089 --> 00:45:01,719
oh my god

00:44:55,749 --> 00:45:04,749
actually the problem is probably even I

00:45:01,719 --> 00:45:07,390
don't remember no it's too annoying to

00:45:04,749 --> 00:45:10,180
find coding somewhere there's some code

00:45:07,390 --> 00:45:12,489
they're like okay

00:45:10,180 --> 00:45:14,619
I that basically was trying to figure

00:45:12,489 --> 00:45:21,119
out what are all the temporaries that

00:45:14,619 --> 00:45:21,119
might have to be created in a generator

00:45:21,329 --> 00:45:28,239
he this looks like it yield in scope for

00:45:25,839 --> 00:45:30,130
it so I gave up and I'm searching on

00:45:28,239 --> 00:45:36,359
Emacs I'll bring it back over into

00:45:30,130 --> 00:45:36,359
something okay

00:45:37,559 --> 00:45:49,449
so right so I so there's this code

00:45:42,509 --> 00:45:55,209
called guess I could share money you

00:45:49,449 --> 00:45:57,579
next display yield in scope for

00:45:55,209 --> 00:46:03,160
expression and I think the job of this

00:45:57,579 --> 00:46:05,949
is to figure out if if we made a

00:46:03,160 --> 00:46:07,749
temporary for this expression would

00:46:05,949 --> 00:46:09,569
there be a yield sort of in the scope of

00:46:07,749 --> 00:46:16,179
that temporary in which case it might be

00:46:09,569 --> 00:46:19,179
live across the yield okay and uh but no

00:46:16,179 --> 00:46:26,920
we only use that we only use that in the

00:46:19,179 --> 00:46:30,640
borrowed check hmm I'll have to dig into

00:46:26,920 --> 00:46:32,469
this okay I'm pretty sure well me I sort

00:46:30,640 --> 00:46:35,769
of want to do that in an item payment

00:46:32,469 --> 00:46:37,689
let's come back to it but I'm pretty

00:46:35,769 --> 00:46:40,630
sure there's a problem here like it does

00:46:37,689 --> 00:46:41,949
seem kind of like we have to solve these

00:46:40,630 --> 00:46:44,769
problems before we built the mirror so

00:46:41,949 --> 00:46:53,210
there must be something exactly where

00:46:44,769 --> 00:46:58,220
that code is I'm not sure but

00:46:53,210 --> 00:47:02,990
it must be true that feels like it's not

00:46:58,220 --> 00:47:04,670
a blocker I mean III definitely don't

00:47:02,990 --> 00:47:06,589
think this is a blocker the only thing

00:47:04,670 --> 00:47:11,569
that would be a blocker is if it's gonna

00:47:06,589 --> 00:47:14,000
change in the future to be Dumber yeah

00:47:11,569 --> 00:47:15,799
that's probably gonna happen right

00:47:14,000 --> 00:47:21,349
because then we would potentially wind

00:47:15,799 --> 00:47:25,010
up finding things that should be non non

00:47:21,349 --> 00:47:29,119
sync or should be think but aren't in

00:47:25,010 --> 00:47:30,890
the future right or or or alternatively

00:47:29,119 --> 00:47:32,779
if they're somewhere today where this is

00:47:30,890 --> 00:47:35,990
actually incorrect to the point where

00:47:32,779 --> 00:47:39,380
it's unsound but I haven't found that

00:47:35,990 --> 00:47:41,660
yeah that's what I kind of wanna I would

00:47:39,380 --> 00:47:45,609
like to remember just I'm sure it's not

00:47:41,660 --> 00:47:48,770
totally stupid but I would like to

00:47:45,609 --> 00:47:52,099
remember so that we feel more confident

00:47:48,770 --> 00:47:53,450
so this particular bug this is just that

00:47:52,099 --> 00:47:55,299
we're not using the alighted lifetimes

00:47:53,450 --> 00:47:57,650
correctly and we already talked about

00:47:55,299 --> 00:48:00,980
like the figure we talked about with

00:47:57,650 --> 00:48:04,940
Fixodent yeah that's the same same thing

00:48:00,980 --> 00:48:07,730
for object objects safe or sorry objects

00:48:04,940 --> 00:48:09,980
this one oh right this this thing didn't

00:48:07,730 --> 00:48:17,450
send and send what happened it's closed

00:48:09,980 --> 00:48:23,210
oh okay it's been fixed works for me

00:48:17,450 --> 00:48:25,190
I bet I bet that was a bug that had to

00:48:23,210 --> 00:48:27,500
do with the work that Ariel did

00:48:25,190 --> 00:48:31,990
refactoring all of that I just got fixed

00:48:27,500 --> 00:48:31,990
and that's why we couldn't reproduce it

00:48:37,950 --> 00:49:00,849
okay it's for to guarding yeah I

00:48:59,259 --> 00:49:05,999
remember we messed with this and we had

00:49:00,849 --> 00:49:09,249
no idea what was going yeah I still come

00:49:05,999 --> 00:49:18,490
true is it cuz it only happen or it only

00:49:09,249 --> 00:49:20,920
happened if you just had if you just had

00:49:18,490 --> 00:49:42,549
oh never mind never mind I'm thinking of

00:49:20,920 --> 00:49:48,099
a different pocket I kind of this so my

00:49:42,549 --> 00:49:54,249
guess about this I'm gonna share I give

00:49:48,099 --> 00:50:01,269
up on Firefox for a second it's just not

00:49:54,249 --> 00:50:10,200
a good way to navigate to it I'll share

00:50:01,269 --> 00:50:12,670
this other thing so you see this right

00:50:10,200 --> 00:50:16,019
it's currently very tiny but I think I

00:50:12,670 --> 00:50:17,140
can fix that I probably make it bigger

00:50:16,019 --> 00:50:19,660
okay

00:50:17,140 --> 00:50:22,200
I'm sad no thanks I actually cannot

00:50:19,660 --> 00:50:26,079
figure out how to make you figure okay I

00:50:22,200 --> 00:50:29,559
don't for the hotkey is for that but

00:50:26,079 --> 00:50:31,390
it's not ctrl + I I thought it would be

00:50:29,559 --> 00:50:34,119
it appears not to be this is like

00:50:31,390 --> 00:50:37,150
Windows fw SL or whatever maybe it has

00:50:34,119 --> 00:50:38,710
some windows subsystem for linux like

00:50:37,150 --> 00:50:39,910
yeah i don't know

00:50:38,710 --> 00:50:45,579
none of these I probably have to like

00:50:39,910 --> 00:50:49,259
change the font sizes anyway so for

00:50:45,579 --> 00:50:49,259
generators which

00:50:49,630 --> 00:50:55,330
the like nonce whatever we call those

00:50:52,950 --> 00:50:59,050
the generators that like encapsulate

00:50:55,330 --> 00:51:03,760
borrows within them sharpened generators

00:50:59,050 --> 00:51:12,790
I guess there's let me see if I can

00:51:03,760 --> 00:51:18,280
remember this we handle them in a we

00:51:12,790 --> 00:51:22,000
handle them by you have like a a

00:51:18,280 --> 00:51:24,760
higher-ranked type somewhere or

00:51:22,000 --> 00:51:29,860
something where is this where is this

00:51:24,760 --> 00:51:34,330
code I'm trying to remember maybe it's

00:51:29,860 --> 00:51:34,780
what this witness thing is or this could

00:51:34,330 --> 00:51:36,430
be better

00:51:34,780 --> 00:51:39,940
every time I dive into one of these

00:51:36,430 --> 00:51:43,270
things I'm like why don't we write more

00:51:39,940 --> 00:51:46,870
dogs just like such a thing that should

00:51:43,270 --> 00:51:52,090
have been done you're in there we go

00:51:46,870 --> 00:51:54,570
generator witness so we have basically

00:51:52,090 --> 00:51:58,150
we have a type that's kind of like

00:51:54,570 --> 00:52:02,950
representing the inside and it has sort

00:51:58,150 --> 00:52:06,600
of a a region so if you had some borrow

00:52:02,950 --> 00:52:08,110
that you have to save across the

00:52:06,600 --> 00:52:10,300
needlepoint

00:52:08,110 --> 00:52:13,660
it doesn't have a lemon that's valid

00:52:10,300 --> 00:52:16,510
from outside the generator right yeah we

00:52:13,660 --> 00:52:18,010
represent that kind of like this it's

00:52:16,510 --> 00:52:19,480
not really for all it's more like an

00:52:18,010 --> 00:52:24,360
existential type like there's some

00:52:19,480 --> 00:52:31,630
lifetime take are right and I'm guessing

00:52:24,360 --> 00:52:37,290
that's so my hypothesis is that the the

00:52:31,630 --> 00:52:41,050
for all is coming from that existential

00:52:37,290 --> 00:52:42,970
like we're kind of saying we don't know

00:52:41,050 --> 00:52:46,740
what this lifetime is so you have to

00:52:42,970 --> 00:52:51,880
prove it for all lifetimes or something

00:52:46,740 --> 00:52:55,650
but I could be wrong I was just kind of

00:52:51,880 --> 00:52:55,650
trying to see where that might be true

00:52:59,020 --> 00:53:15,320
yeah so I don't know what that says no

00:53:13,400 --> 00:53:38,810
regions in the witness can refer to the

00:53:15,320 --> 00:53:41,180
binder outside the witness okay well so

00:53:38,810 --> 00:53:45,680
we could do two things here I could just

00:53:41,180 --> 00:53:47,270
debug this live with you all or I could

00:53:45,680 --> 00:53:49,370
do it on my other and pin UN's who look

00:53:47,270 --> 00:53:51,680
I hope quite know what's going on though

00:53:49,370 --> 00:53:57,380
but I would like to I feel like this is

00:53:51,680 --> 00:54:01,220
related to the I guess I would like to

00:53:57,380 --> 00:54:03,440
dig into this and the the capture

00:54:01,220 --> 00:54:04,730
borrows too eagerly which I suspect are

00:54:03,440 --> 00:54:05,960
kind of flowing through the same coat

00:54:04,730 --> 00:54:11,930
even though they're manifesting pretty

00:54:05,960 --> 00:54:15,290
differently would it help you to help

00:54:11,930 --> 00:54:17,750
other people while you're debugging to

00:54:15,290 --> 00:54:20,990
talk about it I mean I don't mind it's

00:54:17,750 --> 00:54:24,020
up to you more affecting for you to do

00:54:20,990 --> 00:54:33,020
it on your own no no it's kind of fun to

00:54:24,020 --> 00:54:36,040
have people I'm not all alone it might

00:54:33,020 --> 00:54:36,040
be kind of embarrassing

00:54:37,330 --> 00:54:46,070
I've lost all shame or all pride I don't

00:54:40,460 --> 00:54:47,510
know one of the other both so maybe

00:54:46,070 --> 00:54:48,980
we'll go through the rest of the list

00:54:47,510 --> 00:54:51,050
and just make sure there's nothing else

00:54:48,980 --> 00:54:54,370
that's like we can dig into more

00:54:51,050 --> 00:54:54,370
productively first a shark

00:55:03,900 --> 00:55:10,110
so right so there's some ice Lord on

00:55:07,450 --> 00:55:13,450
this did this get fixed too

00:55:10,110 --> 00:55:16,450
we fix one such to brainy ice yes it

00:55:13,450 --> 00:55:28,710
looks like you did okay well let's just

00:55:16,450 --> 00:55:28,710
make sure so we can just just break that

00:55:34,290 --> 00:55:39,520
the TLS problem we're basically not

00:55:36,880 --> 00:55:43,510
going to do anything here right I I

00:55:39,520 --> 00:55:44,950
don't have doesn't do particularly to me

00:55:43,510 --> 00:55:49,120
very urgent it anyway it's not a

00:55:44,950 --> 00:55:53,050
compiled from um I mean I guess if we

00:55:49,120 --> 00:56:02,020
had I mean it it's like okay it's urgent

00:55:53,050 --> 00:56:03,970
ish but it's not like urgent like no no

00:56:02,020 --> 00:56:06,130
stood a sink away it seems like

00:56:03,970 --> 00:56:07,960
something that can wait right that's

00:56:06,130 --> 00:56:11,050
what I mean it seems like a clearer like

00:56:07,960 --> 00:56:12,340
easily described line it's not something

00:56:11,050 --> 00:56:15,070
where people are gonna like run into it

00:56:12,340 --> 00:56:18,790
the second they do anything this is we

00:56:15,070 --> 00:56:26,640
already talked about this this we

00:56:18,790 --> 00:56:26,640
already talked about huge generators yep

00:56:27,540 --> 00:56:34,720
yeah I don't really know much about this

00:56:30,130 --> 00:56:36,580
um but I think you and Eddie had some

00:56:34,720 --> 00:56:38,920
clever ideas or something didn't you

00:56:36,580 --> 00:56:41,530
well we had one specific idea which sort

00:56:38,920 --> 00:56:43,810
of addresses a really common case here

00:56:41,530 --> 00:56:45,730
which is that you have a set of

00:56:43,810 --> 00:56:51,130
variables that are only live across

00:56:45,730 --> 00:56:53,820
exactly one yield and and the the logic

00:56:51,130 --> 00:56:56,740
for for unifying the storage for those

00:56:53,820 --> 00:56:59,440
seems a conceptually much much simpler

00:56:56,740 --> 00:57:02,560
than doing the sort of general problem

00:56:59,440 --> 00:57:05,020
of the like set intersection for all the

00:57:02,560 --> 00:57:08,650
variables that are alive across you know

00:57:05,020 --> 00:57:10,540
a set of yield points and you want to

00:57:08,650 --> 00:57:11,260
find the ones for which those sets are

00:57:10,540 --> 00:57:14,930
disjoint

00:57:11,260 --> 00:57:18,170
yes so basically find the variables that

00:57:14,930 --> 00:57:19,820
are never live across a yield and one of

00:57:18,170 --> 00:57:21,230
those you want to find the issue is

00:57:19,820 --> 00:57:28,250
finding the variables that are never

00:57:21,230 --> 00:57:29,450
live across the same yield I mean that's

00:57:28,250 --> 00:57:34,610
the general problem right

00:57:29,450 --> 00:57:36,380
no no so the the the this sorry going

00:57:34,610 --> 00:57:38,990
back so the variables that are never

00:57:36,380 --> 00:57:40,340
live across the yield don't have dark

00:57:38,990 --> 00:57:42,500
part of the problem because they're not

00:57:40,340 --> 00:57:47,660
stored in in the generator either way

00:57:42,500 --> 00:57:49,670
okay we're not back done it was slightly

00:57:47,660 --> 00:57:53,960
smarter than that unless they're moved

00:57:49,670 --> 00:57:55,760
in as captures right but but like no no

00:57:53,960 --> 00:57:58,850
two variables that are stored across a

00:57:55,760 --> 00:58:02,780
yield are ever stored in like in the

00:57:58,850 --> 00:58:04,820
same space no space is reused right and

00:58:02,780 --> 00:58:07,430
so I want to get like a sort of bare

00:58:04,820 --> 00:58:08,660
minimum amount of space for use so that

00:58:07,430 --> 00:58:12,170
when you're doing something stupid like

00:58:08,660 --> 00:58:15,670
do a do thing a then do thing B that the

00:58:12,170 --> 00:58:18,680
futures for a and B aren't always on

00:58:15,670 --> 00:58:20,870
like it's not strictly additive in terms

00:58:18,680 --> 00:58:24,140
of like your future is now a plus B plus

00:58:20,870 --> 00:58:28,640
C in size right it should only be like

00:58:24,140 --> 00:58:33,620
max ABC in size this way we're sending

00:58:28,640 --> 00:58:35,840
them so right exactly so the the quick

00:58:33,620 --> 00:58:39,620
thing is finding things that are alive

00:58:35,840 --> 00:58:41,510
across exactly one yield right and then

00:58:39,620 --> 00:58:43,250
and then just taking the ones that are

00:58:41,510 --> 00:58:46,310
alive across different yields and

00:58:43,250 --> 00:58:48,790
combining their space right or is the

00:58:46,310 --> 00:58:51,790
the thing that's more complicated is

00:58:48,790 --> 00:58:54,350
taking things that are alive across and

00:58:51,790 --> 00:58:56,390
yields and other things that are alive

00:58:54,350 --> 00:58:58,550
across and yields finding where those

00:58:56,390 --> 00:59:01,310
sets are the items for which those sets

00:58:58,550 --> 00:59:03,860
are disjoint and combining the air space

00:59:01,310 --> 00:59:05,390
right right it seems like one could do a

00:59:03,860 --> 00:59:08,300
sort of greedy bin packing algorithm

00:59:05,390 --> 00:59:11,540
prettiest ly but you're saying that's

00:59:08,300 --> 00:59:15,560
too expensive or something that was what

00:59:11,540 --> 00:59:18,230
Eddy told me what is that it's too

00:59:15,560 --> 00:59:21,110
expensive that when he did this before

00:59:18,230 --> 00:59:24,020
for because he did a similar thing as

00:59:21,110 --> 00:59:24,680
part of his like NR vo stuff although he

00:59:24,020 --> 00:59:27,859
did it in

00:59:24,680 --> 00:59:31,549
on a much like larger scale so I don't

00:59:27,859 --> 00:59:33,260
know if it would be I don't I don't know

00:59:31,549 --> 00:59:35,599
how how comparatively expensive of a

00:59:33,260 --> 00:59:37,190
boom beat but but he gave me the

00:59:35,599 --> 00:59:39,559
impression that it was prohibitively

00:59:37,190 --> 00:59:42,970
expensive to do that calculation even

00:59:39,559 --> 00:59:45,410
with the most greedy version of it I

00:59:42,970 --> 00:59:47,450
mean I'm certainly fine with doing this

00:59:45,410 --> 00:59:50,420
version and see how far it gets us it

00:59:47,450 --> 00:59:52,220
seems easy doesn't seem like it would

00:59:50,420 --> 00:59:55,700
make it harder to do it something better

00:59:52,220 --> 00:59:57,380
later if we want okay well I mean if you

00:59:55,700 --> 00:59:59,539
think that doing the better thing is

00:59:57,380 --> 01:00:01,970
like achievable I'm happy to explore

00:59:59,539 --> 01:00:03,170
that but it seems like I know I from

01:00:01,970 --> 01:00:04,279
talking with Eddie he's to be very

01:00:03,170 --> 01:00:06,730
skeptical that we would be able to

01:00:04,279 --> 01:00:09,529
implement something that was performing

01:00:06,730 --> 01:00:15,380
do the basic one now and go to the other

01:00:09,529 --> 01:00:19,579
one future yeah yeah I'm happy to defer

01:00:15,380 --> 01:00:22,490
to Eddie on this okay it would be a fun

01:00:19,579 --> 01:00:23,930
occasion to crack out you know yield ECL

01:00:22,490 --> 01:00:25,880
our textbook which I probably never

01:00:23,930 --> 01:00:28,490
opened one since undergraduate days I

01:00:25,880 --> 01:00:29,869
know right like I I was like I was

01:00:28,490 --> 01:00:31,880
really enjoying this cuz like oh it's

01:00:29,869 --> 01:00:35,109
like I'll goes like an actual well out

01:00:31,880 --> 01:00:37,819
goes problem like there's so where's

01:00:35,109 --> 01:00:44,720
this is actually the register allocation

01:00:37,819 --> 01:00:53,329
problem you find a quick hack that gives

01:00:44,720 --> 01:00:55,549
you a tea but you know said yeah no okay

01:00:53,329 --> 01:00:57,829
it seems like I mean just doing this

01:00:55,549 --> 01:00:59,990
already like lays the infrastructure to

01:00:57,829 --> 01:01:05,270
be smarter than later a problem or

01:00:59,990 --> 01:01:10,099
something yeah so now we have like three

01:01:05,270 --> 01:01:12,799
work items basically figuring out this

01:01:10,099 --> 01:01:16,329
anonymous lifetime stuff to drop order

01:01:12,799 --> 01:01:16,329
thing and the huge gap

01:01:16,950 --> 01:01:22,710
all right well do you all want to hang

01:01:20,850 --> 01:01:24,120
out and debug some problems feel free to

01:01:22,710 --> 01:01:25,080
drop off the call if you don't but I

01:01:24,120 --> 01:01:28,790
think that's what I'm going to do with

01:01:25,080 --> 01:01:28,790

YouTube URL: https://www.youtube.com/watch?v=xe2_whJWBC0


