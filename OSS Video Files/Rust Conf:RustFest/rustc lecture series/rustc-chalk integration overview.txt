Title: rustc-chalk integration overview
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	An overview of the plans for rustc-chalk integration and some brief coverage of how it works in the code itself.
Captions: 
	00:00:02,689 --> 00:00:11,780
okay so I was thinking about this I

00:00:09,080 --> 00:00:15,150
figured the best place to start

00:00:11,780 --> 00:00:17,900
he's probably a little bit higher level

00:00:15,150 --> 00:00:23,609
just to make sure we're on the same page

00:00:17,900 --> 00:00:30,410
about the overall diagrams and so on

00:00:23,609 --> 00:00:36,350
so let me try something wild and crazy

00:00:30,410 --> 00:00:39,809
share the whiteboard you see that

00:00:36,350 --> 00:00:47,129
something's happening oh yeah I see a

00:00:39,809 --> 00:00:51,719
pencil mice handy Wow if it's pants I

00:00:47,129 --> 00:00:52,140
know surface is very cool see how this

00:00:51,719 --> 00:01:01,109
works

00:00:52,140 --> 00:01:06,060
this is totally okay so so yeah I think

00:01:01,109 --> 00:01:08,700
there's like okay now think about what

00:01:06,060 --> 00:01:13,340
my boxes are gonna mean so first of all

00:01:08,700 --> 00:01:16,710
the there's kind of this interface here

00:01:13,340 --> 00:01:18,590
where hold on a minute this thing is no

00:01:16,710 --> 00:01:24,590
knowing place okay

00:01:18,590 --> 00:01:29,009
over here we have chalk X park engine

00:01:24,590 --> 00:01:32,340
and over here we have I'm gonna call it

00:01:29,009 --> 00:01:36,740
trait engine it's kind of a bad name

00:01:32,340 --> 00:01:41,369
maybe the fulfillment context is better

00:01:36,740 --> 00:01:45,170
but the idea is we're doing something on

00:01:41,369 --> 00:01:48,180
the left hand side in rust see basically

00:01:45,170 --> 00:01:51,869
and like for example doing a type check

00:01:48,180 --> 00:01:53,579
and when we're doing that type check we

00:01:51,869 --> 00:01:56,759
have this this data structure the

00:01:53,579 --> 00:01:58,320
fulfillment context that we used to have

00:01:56,759 --> 00:01:59,790
where we sort of it has two personal

00:01:58,320 --> 00:02:01,799
purposes on now so if we're in chalk

00:01:59,790 --> 00:02:04,200
mode what happens is as we go through

00:02:01,799 --> 00:02:07,229
the type shape we might find some goal

00:02:04,200 --> 00:02:09,899
we need to prove like that some type

00:02:07,229 --> 00:02:13,569
implements you know debug or whatever

00:02:09,899 --> 00:02:16,329
and what we'll do is we'll include that

00:02:13,569 --> 00:02:24,730
list so there's like a list of goals

00:02:16,329 --> 00:02:26,019
here goals and and there they're just

00:02:24,730 --> 00:02:28,480
goals that we have yet to prove

00:02:26,019 --> 00:02:31,780
basically and then at any given time we

00:02:28,480 --> 00:02:33,579
can do a we can go through this list and

00:02:31,780 --> 00:02:35,590
we'll try to prove them right and

00:02:33,579 --> 00:02:38,790
meanwhile on the other side we have the

00:02:35,590 --> 00:02:41,560
chalk engine and it's kind of a resident

00:02:38,790 --> 00:02:43,359
has some residents state that it

00:02:41,560 --> 00:02:45,489
maintains with like incremental state

00:02:43,359 --> 00:02:48,840
and the way that it works its basic

00:02:45,489 --> 00:02:53,290
interface is that you can submit to it a

00:02:48,840 --> 00:03:00,699
goal to prove and it's gonna give you

00:02:53,290 --> 00:03:04,060
back an iterator really so it's kind of

00:03:00,699 --> 00:03:05,530
lazy and each time you ask for the next

00:03:04,060 --> 00:03:07,780
answer it will run off and do as much

00:03:05,530 --> 00:03:11,349
computation as it needs to do to figure

00:03:07,780 --> 00:03:14,829
out the next answer and so the idea here

00:03:11,349 --> 00:03:18,129
is that if you ask if you submit a goal

00:03:14,829 --> 00:03:20,049
twice what actually happens is inside

00:03:18,129 --> 00:03:23,889
the chalk engine we maintain this thing

00:03:20,049 --> 00:03:26,409
called a table you maintain sort of one

00:03:23,889 --> 00:03:28,509
per canonical goal and that has all the

00:03:26,409 --> 00:03:32,319
answers we've found so far so if you ask

00:03:28,509 --> 00:03:35,109
for a gold price it'll be very fast to

00:03:32,319 --> 00:03:37,419
get your answers back at least up as far

00:03:35,109 --> 00:03:41,139
as the ones we've computed them is their

00:03:37,419 --> 00:03:43,060
cached on Nico just to clarify slightly

00:03:41,139 --> 00:03:46,359
when you're talking about answers here I

00:03:43,060 --> 00:03:50,530
assume you mean basically viable proofs

00:03:46,359 --> 00:03:51,599
that some type implement some trade or

00:03:50,530 --> 00:03:54,699
something like that

00:03:51,599 --> 00:03:56,530
not quite I mean that proof must exist

00:03:54,699 --> 00:03:58,689
we don't get it back to you directly

00:03:56,530 --> 00:04:02,790
okay what we give back to you is an

00:03:58,689 --> 00:04:10,449
assignment of the infant's variables

00:04:02,790 --> 00:04:12,250
that is known to be true for the most

00:04:10,449 --> 00:04:17,019
part it might have some region

00:04:12,250 --> 00:04:20,880
constraints and so on so if you asked

00:04:17,019 --> 00:04:24,070
like it is back of question mark TD

00:04:20,880 --> 00:04:26,830
letting debug we would give you back an

00:04:24,070 --> 00:04:28,810
answer like guess if T is

00:04:26,830 --> 00:04:31,630
I might be the first answer you get back

00:04:28,810 --> 00:04:33,490
mm and then you might ask well what's

00:04:31,630 --> 00:04:36,699
the next one and you might get yes 50 is

00:04:33,490 --> 00:04:39,580
I 32 and of course there's an infinite

00:04:36,699 --> 00:04:44,020
stream of answers in that case hopefully

00:04:39,580 --> 00:04:46,349
you won't keep pulling and we'll come to

00:04:44,020 --> 00:04:48,340
that in a second that's relevant here

00:04:46,349 --> 00:04:49,930
the way that it works somewhat

00:04:48,340 --> 00:04:52,270
internally is you know we would

00:04:49,930 --> 00:04:56,830
canonicalize that goal so it might be

00:04:52,270 --> 00:05:00,220
like this might be the back of question

00:04:56,830 --> 00:05:01,539
mark 0 implements debug this might be

00:05:00,220 --> 00:05:03,460
the table we made for that particular

00:05:01,539 --> 00:05:06,610
goal and then when we find our first

00:05:03,460 --> 00:05:09,940
answer we would add into it like 0 is

00:05:06,610 --> 00:05:13,509
your 32 and then your own sign 32

00:05:09,940 --> 00:05:15,340
whenever as we go through we always know

00:05:13,509 --> 00:05:16,930
how many answers there are so basically

00:05:15,340 --> 00:05:19,750
each of these iterators has like the

00:05:16,930 --> 00:05:21,490
table index internally in index to the

00:05:19,750 --> 00:05:23,650
table and index to the answer and as

00:05:21,490 --> 00:05:25,210
long as it's sort of already populated

00:05:23,650 --> 00:05:26,530
it's very cheap but we're getting a

00:05:25,210 --> 00:05:28,690
little further into how that works

00:05:26,530 --> 00:05:30,870
internally now but but my main point is

00:05:28,690 --> 00:05:33,820
that when you ask it for the next answer

00:05:30,870 --> 00:05:36,430
this table you know it will go off and

00:05:33,820 --> 00:05:41,280
do work so if it means it might say oh I

00:05:36,430 --> 00:05:45,190
have a rule that says for example that

00:05:41,280 --> 00:05:46,870
well the rule for vectors is or one

00:05:45,190 --> 00:05:49,810
possible value for question mark zero

00:05:46,870 --> 00:05:51,310
would be itself to be a vector so in

00:05:49,810 --> 00:05:55,750
that case we might instantiate it as a

00:05:51,310 --> 00:05:57,550
vexing question mark 1 and ask if those

00:05:55,750 --> 00:05:59,530
back of question mark 1 implemented bug

00:05:57,550 --> 00:06:01,719
when we can analyze that that's the same

00:05:59,530 --> 00:06:05,289
table so then we'd have like a recursive

00:06:01,719 --> 00:06:06,460
reference that's talking in the line in

00:06:05,289 --> 00:06:09,550
that case you would start to go through

00:06:06,460 --> 00:06:11,650
the answers again so we'd say ok yes the

00:06:09,550 --> 00:06:13,550
question mark 1 has to be 32 and you get

00:06:11,650 --> 00:06:15,900
back exactly things with you two but

00:06:13,550 --> 00:06:19,840
[Music]

00:06:15,900 --> 00:06:21,729
okay right so back on the rusty side

00:06:19,840 --> 00:06:23,169
we're basically or actually there's a

00:06:21,729 --> 00:06:25,060
little bit of a shim that goes in

00:06:23,169 --> 00:06:28,090
between the iterator and rusty itself

00:06:25,060 --> 00:06:30,880
and what this Shin does this is sort of

00:06:28,090 --> 00:06:31,659
the chalk shim I forget where it's

00:06:30,880 --> 00:06:33,789
implemented

00:06:31,659 --> 00:06:36,539
I think it's employed in the engine

00:06:33,789 --> 00:06:39,219
itself and what it does is it tries to

00:06:36,539 --> 00:06:40,340
so you don't do rusty doesn't directly

00:06:39,219 --> 00:06:44,690
interact with that

00:06:40,340 --> 00:06:46,070
rather rusty asks the shim to compute

00:06:44,690 --> 00:06:51,080
the answer on what the shim does is pull

00:06:46,070 --> 00:06:53,420
answers until it seems like the insert

00:06:51,080 --> 00:06:55,580
has gotten at all either we run out of

00:06:53,420 --> 00:06:59,180
answers or we've sort of generalized

00:06:55,580 --> 00:07:00,710
past the point of utility so so in this

00:06:59,180 --> 00:07:02,240
particular case for example if the

00:07:00,710 --> 00:07:03,860
question mark if the question was to vet

00:07:02,240 --> 00:07:06,560
does back of question marks new roads in

00:07:03,860 --> 00:07:08,960
that debug the shim would first pull out

00:07:06,560 --> 00:07:10,700
and get it answer yes if it's you 32 and

00:07:08,960 --> 00:07:12,530
then it might pull and get yes if it's I

00:07:10,700 --> 00:07:15,220
32 and then we would try to combine

00:07:12,530 --> 00:07:17,300
those answers into one substitution oh

00:07:15,220 --> 00:07:19,220
well now we got question right zero

00:07:17,300 --> 00:07:21,110
equals question mark zero like this is

00:07:19,220 --> 00:07:22,640
there's basically no common ground

00:07:21,110 --> 00:07:23,870
between these two answers there's no

00:07:22,640 --> 00:07:24,820
reason to pull for anymore and we're

00:07:23,870 --> 00:07:28,490
done

00:07:24,820 --> 00:07:30,020
and we do the engine is optimized around

00:07:28,490 --> 00:07:33,880
delivering what I've been calling a

00:07:30,020 --> 00:07:33,880
breadth-first search it's not literally

00:07:34,570 --> 00:07:38,540
actually if it is or not but there are

00:07:36,860 --> 00:07:40,340
various strategies the main point is is

00:07:38,540 --> 00:07:44,630
not depth-first so it tries to give you

00:07:40,340 --> 00:07:48,320
a variety of answers if they exist in

00:07:44,630 --> 00:07:49,640
order to help you reach this this this

00:07:48,320 --> 00:07:52,640
consolidation point so you could imagine

00:07:49,640 --> 00:07:54,860
it's sort of in a traditional Prolog

00:07:52,640 --> 00:07:56,690
engine it might be giving you like ever

00:07:54,860 --> 00:07:57,890
bigger bigger answers like vectors that

00:07:56,690 --> 00:07:59,150
go that's a fact of you through you

00:07:57,890 --> 00:08:00,650
before it ever went off to tell you oh

00:07:59,150 --> 00:08:07,580
and by the way it might not be effect at

00:08:00,650 --> 00:08:11,120
all that doesn't mean we can't take a

00:08:07,580 --> 00:08:13,370
long time to find an answer but we we

00:08:11,120 --> 00:08:15,620
are that's the main that's one of my

00:08:13,370 --> 00:08:17,690
main like things I think we'll want to

00:08:15,620 --> 00:08:20,510
play with is this search strategy to try

00:08:17,690 --> 00:08:25,970
to ensure that we're not getting lost as

00:08:20,510 --> 00:08:30,350
much as possible but usually we we do a

00:08:25,970 --> 00:08:32,810
pretty good job um so so right so back

00:08:30,350 --> 00:08:35,060
to rust that will dig more L to the

00:08:32,810 --> 00:08:38,200
chalk engine but yeah actually just okay

00:08:35,060 --> 00:08:41,240
just to clarify my orientation here so

00:08:38,200 --> 00:08:43,550
from the type checker in perspective I

00:08:41,240 --> 00:08:45,610
guess there are a few different things

00:08:43,550 --> 00:08:48,230
we might be trying to do like sometimes

00:08:45,610 --> 00:08:52,490
we may just be checking that's and

00:08:48,230 --> 00:08:53,420
already known type implements at rate in

00:08:52,490 --> 00:08:55,250
which case

00:08:53,420 --> 00:08:56,600
the answers are uninteresting we just

00:08:55,250 --> 00:08:58,400
want confirmation that the

00:08:56,600 --> 00:09:01,190
implementation exists and then other

00:08:58,400 --> 00:09:02,990
times we are maybe asking both that

00:09:01,190 --> 00:09:05,480
question but also there are parts of the

00:09:02,990 --> 00:09:07,480
type that are unknown and then we're

00:09:05,480 --> 00:09:10,220
we're trying to see basically whether

00:09:07,480 --> 00:09:13,010
given that this type has to implement

00:09:10,220 --> 00:09:15,950
this trait does the trade system

00:09:13,010 --> 00:09:19,730
determine that this unknown type must be

00:09:15,950 --> 00:09:22,160
high 32 or something right that is right

00:09:19,730 --> 00:09:23,720
that's right and so you can get back a

00:09:22,160 --> 00:09:26,300
variety of answers there right you could

00:09:23,720 --> 00:09:27,950
get back that it must be one specific

00:09:26,300 --> 00:09:29,600
thing or that it doesn't matter what it

00:09:27,950 --> 00:09:33,620
is but the type implements the trade

00:09:29,600 --> 00:09:35,600
would right okay so yeah cuz I'm just

00:09:33,620 --> 00:09:37,040
the the piece that was a little hazy in

00:09:35,600 --> 00:09:39,200
the description you just gave us like

00:09:37,040 --> 00:09:41,480
this shim that is actually dealing with

00:09:39,200 --> 00:09:43,790
the granular answers coming out of chalk

00:09:41,480 --> 00:09:45,620
I just want to check my understanding

00:09:43,790 --> 00:09:49,490
basically what that shim is doing is

00:09:45,620 --> 00:09:50,870
trying to determine how much information

00:09:49,490 --> 00:09:52,610
it can get from chocolate if the

00:09:50,870 --> 00:09:54,020
information is just yeah there's some

00:09:52,610 --> 00:09:56,570
implementation but it could be a lot of

00:09:54,020 --> 00:09:58,490
types or yes there is an implementation

00:09:56,570 --> 00:10:01,820
and furthermore it means that this

00:09:58,490 --> 00:10:04,760
unknown type must in fact be this type

00:10:01,820 --> 00:10:06,460
over here is that it's trying to get

00:10:04,760 --> 00:10:09,830
them trying to get as precise a

00:10:06,460 --> 00:10:14,270
substitution as it can mmm for the

00:10:09,830 --> 00:10:17,000
entrance variables and so it will acquit

00:10:14,270 --> 00:10:18,890
for example like let's suppose that the

00:10:17,000 --> 00:10:21,200
values you get back are not you 32 an

00:10:18,890 --> 00:10:23,510
i-32 but rather that give you 32 in fact

00:10:21,200 --> 00:10:25,250
the by 32 that point it would probably

00:10:23,510 --> 00:10:29,450
stop but it would tell you it's a Veck

00:10:25,250 --> 00:10:32,180
of something right right well no that's

00:10:29,450 --> 00:10:35,630
not quite true but it can tell you that

00:10:32,180 --> 00:10:37,550
and the way it would do that is it we

00:10:35,630 --> 00:10:39,770
have a little it has a way of pushing

00:10:37,550 --> 00:10:41,540
back into chocolate saying do you have

00:10:39,770 --> 00:10:43,820
any answers that invalidate exact of

00:10:41,540 --> 00:10:45,380
something that are like you you know you

00:10:43,820 --> 00:10:46,790
know what possible strands you might

00:10:45,380 --> 00:10:48,500
pull on that will give you more answers

00:10:46,790 --> 00:10:49,790
and those strands could give you an

00:10:48,500 --> 00:10:51,890
infinite list of answers but we can

00:10:49,790 --> 00:10:55,850
still sometimes constrain that they're

00:10:51,890 --> 00:10:56,240
all vex of something for so that's how

00:10:55,850 --> 00:10:58,010
that works

00:10:56,240 --> 00:10:59,750
I mean if it if it finds all the answers

00:10:58,010 --> 00:11:01,700
then it can easily be done but there

00:10:59,750 --> 00:11:05,210
even if there's an infinite range we can

00:11:01,700 --> 00:11:07,100
still sometimes say something and that's

00:11:05,210 --> 00:11:11,540
to model that sort of matches

00:11:07,100 --> 00:11:14,540
how rusty works today where we kind of

00:11:11,540 --> 00:11:15,800
commit we might commit to a nimble but

00:11:14,540 --> 00:11:19,640
not have fully processed the where

00:11:15,800 --> 00:11:21,890
clauses and they might potentially go

00:11:19,640 --> 00:11:23,090
forever but by just but but because we

00:11:21,890 --> 00:11:27,230
know there's only one in bull and it's

00:11:23,090 --> 00:11:28,370
for Veck of something that we know

00:11:27,230 --> 00:11:34,010
something already and we can make

00:11:28,370 --> 00:11:36,140
progress right that makes sense so yeah

00:11:34,010 --> 00:11:38,180
so that's how we handle that case anyway

00:11:36,140 --> 00:11:40,820
so that if if if all the types were

00:11:38,180 --> 00:11:42,740
known to begin with then the aggregators

00:11:40,820 --> 00:11:44,450
job is pretty easy because there's only

00:11:42,740 --> 00:11:46,820
one possible answer which is empty

00:11:44,450 --> 00:11:50,440
substitution so it's really a binary

00:11:46,820 --> 00:11:50,440
question then do I get an answer or not

00:11:51,190 --> 00:12:00,650
yep

00:11:52,990 --> 00:12:03,920
okay so I'll add one one other well I'm

00:12:00,650 --> 00:12:05,810
noting concerns one other concern I have

00:12:03,920 --> 00:12:07,430
with the current design that I think we

00:12:05,810 --> 00:12:11,480
can overcome but it'll take a little

00:12:07,430 --> 00:12:17,060
tweaking if it becomes a problem is that

00:12:11,480 --> 00:12:20,690
the I think become because of things

00:12:17,060 --> 00:12:22,730
like size bounds like it could be very

00:12:20,690 --> 00:12:25,850
common for us to get back an answer of I

00:12:22,730 --> 00:12:27,920
don't know yeah I think that would be

00:12:25,850 --> 00:12:29,930
there by far the most common answer so

00:12:27,920 --> 00:12:34,310
if you ask like if you have some in both

00:12:29,930 --> 00:12:37,730
for all T foo four venti and you asked

00:12:34,310 --> 00:12:39,530
us question mark zero implement foo we

00:12:37,730 --> 00:12:42,200
the answer is gonna be I don't know

00:12:39,530 --> 00:12:44,330
because we're not yet we know that it

00:12:42,200 --> 00:12:45,470
must be a vector of something or we

00:12:44,330 --> 00:12:46,550
don't know without knowing that that's

00:12:45,470 --> 00:12:51,340
something is we can't tell if that

00:12:46,550 --> 00:12:54,230
something is sized so we can't say yes

00:12:51,340 --> 00:12:55,850
but so what we could give back and I

00:12:54,230 --> 00:12:57,440
think we will if I unless I'm

00:12:55,850 --> 00:12:59,150
misremembering is well give back I don't

00:12:57,440 --> 00:13:00,830
know but whatever it is question mark

00:12:59,150 --> 00:13:02,840
zero has to be a back of something right

00:13:00,830 --> 00:13:04,360
so that so that means that the type

00:13:02,840 --> 00:13:06,470
checker can still make progress and

00:13:04,360 --> 00:13:07,960
infer that its effect of something but

00:13:06,470 --> 00:13:10,310
that goal will stay in our list

00:13:07,960 --> 00:13:12,440
yeah it's fully proven and the next time

00:13:10,310 --> 00:13:15,500
we come in we'll hopefully have more

00:13:12,440 --> 00:13:16,790
information about what about the types

00:13:15,500 --> 00:13:18,560
and so we'll end up at a different table

00:13:16,790 --> 00:13:19,580
because it'll be does that make sense

00:13:18,560 --> 00:13:21,290
yeah

00:13:19,580 --> 00:13:24,600
[Music]

00:13:21,290 --> 00:13:28,710
okay so right so this is the is the

00:13:24,600 --> 00:13:31,620
basic architecture and what I thought I

00:13:28,710 --> 00:13:37,440
would walk through a little bit is where

00:13:31,620 --> 00:13:38,640
the some of the bits of code are let me

00:13:37,440 --> 00:13:40,110
just say a little bit more about how the

00:13:38,640 --> 00:13:42,060
chalk engine integrates with us because

00:13:40,110 --> 00:13:44,700
it's important when when we go off to

00:13:42,060 --> 00:13:46,050
solve one of these tables the way that

00:13:44,700 --> 00:13:47,430
this works internally I mentioned

00:13:46,050 --> 00:13:50,430
already we have this notion of strands

00:13:47,430 --> 00:13:52,770
so the table has a list of answers it

00:13:50,430 --> 00:13:54,660
also has a list of strands which are

00:13:52,770 --> 00:13:58,170
basically kind of like co-routines so to

00:13:54,660 --> 00:14:00,870
speak they're like a part an answer that

00:13:58,170 --> 00:14:02,610
we're midway through solving but we

00:14:00,870 --> 00:14:06,900
haven't we still have some pending work

00:14:02,610 --> 00:14:08,850
left to do so it's basically a list of

00:14:06,900 --> 00:14:12,000
sub goals you have to solve and some

00:14:08,850 --> 00:14:17,400
other stuff and before you found a

00:14:12,000 --> 00:14:19,440
complete answer and the let's see oh

00:14:17,400 --> 00:14:23,250
yeah so when you when you first create a

00:14:19,440 --> 00:14:24,480
table like you have to you'll have no

00:14:23,250 --> 00:14:25,800
answers of course but you'll want to

00:14:24,480 --> 00:14:27,750
have a lot of strands and the strands

00:14:25,800 --> 00:14:32,220
would come from essentially all the

00:14:27,750 --> 00:14:33,570
impulse in the program that's not

00:14:32,220 --> 00:14:35,880
exactly true there's some other sources

00:14:33,570 --> 00:14:37,650
but it's kind of all what are all the

00:14:35,880 --> 00:14:40,350
ways I might prove something to be debug

00:14:37,650 --> 00:14:43,260
right um let me put them in my list so I

00:14:40,350 --> 00:14:52,070
can go eliminate them if they don't

00:14:43,260 --> 00:14:54,300
apply okay hold on so I'm trying to

00:14:52,070 --> 00:14:56,190
connect this back to my older

00:14:54,300 --> 00:14:58,800
understanding of chalk so we used to

00:14:56,190 --> 00:15:02,190
back in the old days there was some

00:14:58,800 --> 00:15:04,590
notion of like a program that was

00:15:02,190 --> 00:15:06,990
essentially like the lowering of the

00:15:04,590 --> 00:15:09,080
tray temples and you would ask talk for

00:15:06,990 --> 00:15:11,820
answers in reference to that program

00:15:09,080 --> 00:15:16,290
yeah it sounds like what you're saying

00:15:11,820 --> 00:15:18,990
here is each time you start looking for

00:15:16,290 --> 00:15:21,210
answers or yeah you start a new table

00:15:18,990 --> 00:15:25,640
for answers the first thing you do is

00:15:21,210 --> 00:15:29,870
dump in the contents of the program as

00:15:25,640 --> 00:15:32,990
possible proof strands to explore

00:15:29,870 --> 00:15:35,390
is that that's pretty much right I think

00:15:32,990 --> 00:15:38,540
if I remember I might be misremembering

00:15:35,390 --> 00:15:40,430
but based on what I was looking at look

00:15:38,540 --> 00:15:44,530
real fast I think the program is at a

00:15:40,430 --> 00:15:47,900
higher level in the chalk engine yeah it

00:15:44,530 --> 00:15:49,700
it only has we're gonna see it's a

00:15:47,900 --> 00:15:51,560
callback like it's when you instantiate

00:15:49,700 --> 00:15:53,690
this just library to give it a trait

00:15:51,560 --> 00:15:58,130
with some callbacks and one of the

00:15:53,690 --> 00:16:02,000
callbacks is give me all the program

00:15:58,130 --> 00:16:07,220
clauses that might be used to prove this

00:16:02,000 --> 00:16:09,350
gold there's an initial filtering step

00:16:07,220 --> 00:16:11,630
right it doesn't really know about

00:16:09,350 --> 00:16:14,570
traits per se right it just knows it has

00:16:11,630 --> 00:16:16,700
a goal to prove yeah yeah but but and

00:16:14,570 --> 00:16:19,850
your job is to give some superset of the

00:16:16,700 --> 00:16:21,430
applicable clauses and actually it

00:16:19,850 --> 00:16:24,800
doesn't matter you could give all

00:16:21,430 --> 00:16:25,970
clauses that exist and it'll find a job

00:16:24,800 --> 00:16:28,970
it'll be much less efficient because

00:16:25,970 --> 00:16:31,010
it's not really good you know it'll

00:16:28,970 --> 00:16:33,020
search them one by one the hope would be

00:16:31,010 --> 00:16:34,400
that you will take some you'll take as

00:16:33,020 --> 00:16:36,740
much information from the goal as you

00:16:34,400 --> 00:16:38,570
can to narrow that down so like a

00:16:36,740 --> 00:16:40,040
minimum you might look up the trait but

00:16:38,570 --> 00:16:43,430
you might also look at the type and say

00:16:40,040 --> 00:16:47,270
I already know it's a vector like I've

00:16:43,430 --> 00:16:49,220
hashed my impulse by the self type

00:16:47,270 --> 00:16:51,050
that's what we do in rusty today mm-hmm

00:16:49,220 --> 00:16:52,760
like not the full cell type but a little

00:16:51,050 --> 00:16:55,700
bit of the self tag just enough to like

00:16:52,760 --> 00:17:01,610
narrow it down said yeah and you might

00:16:55,700 --> 00:17:05,060
do that so I have a question so I don't

00:17:01,610 --> 00:17:09,890
know if you said this but oh oh is the

00:17:05,060 --> 00:17:12,050
talk engine interfacing with I bet

00:17:09,890 --> 00:17:13,670
that's today are we if we get T equals

00:17:12,050 --> 00:17:20,930
you 32 or are you feeding that into the

00:17:13,670 --> 00:17:26,840
inference context yes I would extend the

00:17:20,930 --> 00:17:29,090
set like replace existing type in plays

00:17:26,840 --> 00:17:32,840
the same role as the trait code in rusty

00:17:29,090 --> 00:17:35,270
today so there's there's a in and the

00:17:32,840 --> 00:17:39,710
rusty side there's in somewhere in

00:17:35,270 --> 00:17:42,050
inference context which is so when

00:17:39,710 --> 00:17:44,390
you're when you're doing type checking

00:17:42,050 --> 00:17:47,650
you have you sort of have a

00:17:44,390 --> 00:17:51,350
and you have an inference context and

00:17:47,650 --> 00:17:53,930
you you're gonna come up with something

00:17:51,350 --> 00:17:59,030
you need to prove and you're gonna sort

00:17:53,930 --> 00:18:00,650
of take some goal like all this in our

00:17:59,030 --> 00:18:04,910
example so I'll just keep using it let's

00:18:00,650 --> 00:18:06,530
call it question mark 32s debug all

00:18:04,910 --> 00:18:08,360
right and that's question mark 32 of

00:18:06,530 --> 00:18:12,500
course refers into the tables here and

00:18:08,360 --> 00:18:16,490
we're going to submit this goal to the

00:18:12,500 --> 00:18:17,630
to the trade engine which I think we

00:18:16,490 --> 00:18:18,950
also give it a reference to the

00:18:17,630 --> 00:18:21,080
inference context when we do that and

00:18:18,950 --> 00:18:23,210
it's gonna go and canonicalize that and

00:18:21,080 --> 00:18:24,440
turn that into like a stock to do that

00:18:23,210 --> 00:18:26,120
job doesn't know anything about my

00:18:24,440 --> 00:18:27,470
inference context it's because we've

00:18:26,120 --> 00:18:29,810
canonical I still be taking all the

00:18:27,470 --> 00:18:31,580
infant's variables and giving them you

00:18:29,810 --> 00:18:33,680
know or pull them out and given them a

00:18:31,580 --> 00:18:35,360
rendering sent it off and then chocolate

00:18:33,680 --> 00:18:37,340
give us back an answer and we'll sort of

00:18:35,360 --> 00:18:39,020
translate that answer back into the

00:18:37,340 --> 00:18:41,780
inference context and do the unification

00:18:39,020 --> 00:18:44,540
so as part of processing that goal we

00:18:41,780 --> 00:18:47,030
might figure out that question mark 32

00:18:44,540 --> 00:18:50,930
is you ins Frank and we would tell the

00:18:47,030 --> 00:18:52,790
inference context oh hey unify question

00:18:50,930 --> 00:18:58,850
mark 32 and they're not in the way that

00:18:52,790 --> 00:19:00,680
that happens well that can happen yeah

00:18:58,850 --> 00:19:01,820
no that's just right so the way

00:19:00,680 --> 00:19:03,440
basically what happens is that the

00:19:01,820 --> 00:19:06,950
iterator the aggregator this this

00:19:03,440 --> 00:19:09,400
iterator aggregator thing your well I

00:19:06,950 --> 00:19:15,320
think you can see my cursor public yeah

00:19:09,400 --> 00:19:17,120
will will give back a substitution right

00:19:15,320 --> 00:19:18,770
so it says oh the zero whatever what

00:19:17,120 --> 00:19:21,050
were you called because it gets back

00:19:18,770 --> 00:19:22,370
it's been given this request it has the

00:19:21,050 --> 00:19:28,070
canonical number and it'll get back a

00:19:22,370 --> 00:19:30,830
substitution like zero is you 32 I know

00:19:28,070 --> 00:19:32,690
that you know and then the trade engine

00:19:30,830 --> 00:19:34,430
will say okay well zero was question

00:19:32,690 --> 00:19:36,620
mark 32 initially that was the name that

00:19:34,430 --> 00:19:39,650
we at the original name we had for it so

00:19:36,620 --> 00:19:44,000
let me unify those two things that's how

00:19:39,650 --> 00:19:49,640
we get this and that only works for like

00:19:44,000 --> 00:19:50,840
certainty list of possible values right

00:19:49,640 --> 00:19:54,230
it has to be something you know for sure

00:19:50,840 --> 00:19:55,370
but we don't have to know that like I

00:19:54,230 --> 00:19:56,519
said you don't have to actually know

00:19:55,370 --> 00:19:59,159
that the whole thing is

00:19:56,519 --> 00:20:02,339
proven you only have to know that the

00:19:59,159 --> 00:20:04,889
only way to prove it would be no we

00:20:02,339 --> 00:20:06,239
might still not know whether well in

00:20:04,889 --> 00:20:07,559
this case because the full type is known

00:20:06,239 --> 00:20:10,049
we would most just know the answer but

00:20:07,559 --> 00:20:12,179
this this could be a substitution that

00:20:10,049 --> 00:20:13,229
itself includes new more variables and

00:20:12,179 --> 00:20:16,169
without knowing the value of those

00:20:13,229 --> 00:20:23,879
variables we don't know yet if the full

00:20:16,169 --> 00:20:25,709
result is done one last point on that so

00:20:23,879 --> 00:20:29,219
I know that there are sometimes ways of

00:20:25,709 --> 00:20:32,159
proving it took me more one more than

00:20:29,219 --> 00:20:36,079
one way to prove a given goal and that

00:20:32,159 --> 00:20:36,079
would give you a different unification

00:20:36,169 --> 00:20:44,969
how how do we prevent like the wrong

00:20:42,079 --> 00:20:47,099
unification from getting stuck in the

00:20:44,969 --> 00:20:49,109
infant's context yes so that's the role

00:20:47,099 --> 00:20:55,579
of this aggregator actually is its job

00:20:49,109 --> 00:20:55,579
is to pull enough answers that until

00:20:55,789 --> 00:21:00,239
either we've seen all the answers so we

00:20:58,349 --> 00:21:02,249
know when we're done basically and if

00:21:00,239 --> 00:21:04,559
we've seen all the answers then that's

00:21:02,249 --> 00:21:06,419
good or but they're basically three

00:21:04,559 --> 00:21:10,709
possible outcomes we've seen all the

00:21:06,419 --> 00:21:13,019
answers or we've general I guess just

00:21:10,709 --> 00:21:15,629
two or we've we've seen it we've

00:21:13,019 --> 00:21:17,759
generalized the result to something that

00:21:15,629 --> 00:21:20,969
none of the possible future answers

00:21:17,759 --> 00:21:22,320
would invalidate and the simplest way to

00:21:20,969 --> 00:21:24,029
do that is you've generalized it all the

00:21:22,320 --> 00:21:28,499
way to I learn nothing great in that

00:21:24,029 --> 00:21:29,579
case like or rather like that's how much

00:21:28,499 --> 00:21:31,079
I learned nothing yeah I guess I learned

00:21:29,579 --> 00:21:32,759
nothing so question Mike zero could be

00:21:31,079 --> 00:21:36,539
any type in that case whatever future

00:21:32,759 --> 00:21:39,389
answer we come up with clearly but

00:21:36,539 --> 00:21:41,700
sometimes we might learn and and the way

00:21:39,389 --> 00:21:43,649
that we and that's where I was saying

00:21:41,700 --> 00:21:46,529
earlier to Aaron that we sort of push

00:21:43,649 --> 00:21:48,209
back the as we go we're like thanks for

00:21:46,529 --> 00:21:49,679
the answers we've seen so far they had

00:21:48,209 --> 00:21:51,299
these parts in common and these parts

00:21:49,679 --> 00:21:53,070
were different and then we push that

00:21:51,299 --> 00:21:55,700
down and we say okay look at the answers

00:21:53,070 --> 00:21:58,619
you've got coming up do any of them

00:21:55,700 --> 00:22:03,869
potentially like essentially invalidate

00:21:58,619 --> 00:22:05,369
that in that case you if there's no then

00:22:03,869 --> 00:22:06,299
I can just sort of stop I don't need to

00:22:05,369 --> 00:22:08,099
pull the rest those answers because

00:22:06,299 --> 00:22:10,789
they're just gonna they're not going to

00:22:08,099 --> 00:22:10,789
add any new information

00:22:12,830 --> 00:22:21,090
so yeah I think yes okay so this is so

00:22:18,630 --> 00:22:23,490
the the chalk engine itself I guess I'll

00:22:21,090 --> 00:22:25,710
do a little bit more context since we're

00:22:23,490 --> 00:22:31,140
here I was just gonna say that it has

00:22:25,710 --> 00:22:34,169
its pretty generic it knows it's really

00:22:31,140 --> 00:22:35,970
just the the logic of like managing

00:22:34,169 --> 00:22:38,400
these tables and strands so it doesn't

00:22:35,970 --> 00:22:39,120
know it's kind of got some context we'll

00:22:38,400 --> 00:22:42,510
see you later

00:22:39,120 --> 00:22:43,950
it has like a bunch of associated types

00:22:42,510 --> 00:22:47,370
for everything from like what is the

00:22:43,950 --> 00:22:50,460
goal what is an environment there's a

00:22:47,370 --> 00:22:54,179
type all that stuff it does require some

00:22:50,460 --> 00:22:58,110
amount of it does bacon a few notions

00:22:54,179 --> 00:23:00,390
that are less specific like type um but

00:22:58,110 --> 00:23:01,980
it's pretty minimal and even type is

00:23:00,390 --> 00:23:03,750
really just it it just sort of says

00:23:01,980 --> 00:23:05,700
they'll have some callbacks like hey

00:23:03,750 --> 00:23:07,650
unify these two types tell me what

00:23:05,700 --> 00:23:16,460
happened I don't know I don't need to

00:23:07,650 --> 00:23:21,840
know what they're like made up of okay

00:23:16,460 --> 00:23:23,070
hmm all right any more questions on the

00:23:21,840 --> 00:23:30,480
big picture I think that's the whole

00:23:23,070 --> 00:23:33,809
picture so one that this is maybe not

00:23:30,480 --> 00:23:35,970
super relevant but just as a reminder so

00:23:33,809 --> 00:23:37,770
we have we have an inference context and

00:23:35,970 --> 00:23:42,750
then we have fulfillment contexts that

00:23:37,770 --> 00:23:44,370
refer back to it when do we create new

00:23:42,750 --> 00:23:48,299
fulfillment contexts like what's the

00:23:44,370 --> 00:23:51,030
serve life its base

00:23:48,299 --> 00:23:52,650
well you can't create them sort of

00:23:51,030 --> 00:23:56,820
anytime but it's basically one per

00:23:52,650 --> 00:23:59,640
function okay I think sometimes we might

00:23:56,820 --> 00:24:02,990
create sub fulfillment context within a

00:23:59,640 --> 00:24:05,250
function and that's okay

00:24:02,990 --> 00:24:07,080
okay really just a list of things we

00:24:05,250 --> 00:24:10,409
have to prove they're not they're not

00:24:07,080 --> 00:24:12,840
really any other state yeah okay so it

00:24:10,409 --> 00:24:15,539
sounds like firt from the perspective of

00:24:12,840 --> 00:24:18,570
chalk integration and so on we can just

00:24:15,539 --> 00:24:19,980
focus on the fulfillment context and

00:24:18,570 --> 00:24:22,250
like relationship back to the inference

00:24:19,980 --> 00:24:23,780
context it's not that interesting yeah

00:24:22,250 --> 00:24:25,010
and in particular there's a one-to-many

00:24:23,780 --> 00:24:25,700
relationship I guess that's the

00:24:25,010 --> 00:24:27,980
important part

00:24:25,700 --> 00:24:30,770
like they all share the same inference

00:24:27,980 --> 00:24:33,170
context might have you can have many

00:24:30,770 --> 00:24:35,360
fulfillment context that's sort of it's

00:24:33,170 --> 00:24:40,940
sort of okay the only problem is like if

00:24:35,360 --> 00:24:43,870
you know if you're just seeing whether

00:24:40,940 --> 00:24:46,130
something could be proven but you don't

00:24:43,870 --> 00:24:49,250
it has side effects on the infant's

00:24:46,130 --> 00:24:51,020
context that it's associated with so if

00:24:49,250 --> 00:24:52,400
that's not something that has to be true

00:24:51,020 --> 00:24:55,940
then it wouldn't be true that question

00:24:52,400 --> 00:24:57,170
r32 must be you int or whatever and you

00:24:55,940 --> 00:24:59,510
know the in other words you have to

00:24:57,170 --> 00:25:00,680
manage the side-effects as long as

00:24:59,510 --> 00:25:03,020
they're all things that have to be true

00:25:00,680 --> 00:25:05,600
that's fun okay just to clarify is there

00:25:03,020 --> 00:25:07,220
one truck engine curve for Finland

00:25:05,600 --> 00:25:08,570
context or preference you know there's

00:25:07,220 --> 00:25:12,110
one truck engine for the whole

00:25:08,570 --> 00:25:16,340
compilation so that's a big improve it's

00:25:12,110 --> 00:25:17,900
a big point is that anybody that has to

00:25:16,340 --> 00:25:19,720
prove that a vector is debug ghost at

00:25:17,900 --> 00:25:23,090
the same table no matter what function

00:25:19,720 --> 00:25:25,250
they're working under the only sort of

00:25:23,090 --> 00:25:27,560
problem or they were only difficulty is

00:25:25,250 --> 00:25:29,270
I didn't show it but part of this goal

00:25:27,560 --> 00:25:31,280
is also the environment so it's also the

00:25:29,270 --> 00:25:34,700
where clauses that are in scope roughly

00:25:31,280 --> 00:25:37,520
speaking however in my measurements I

00:25:34,700 --> 00:25:40,580
found that 99% of the things would be

00:25:37,520 --> 00:25:44,660
cache hits so it should still be pretty

00:25:40,580 --> 00:25:47,200
good something like that I think it was

00:25:44,660 --> 00:25:50,900
99 it was certainly starting with a nine

00:25:47,200 --> 00:25:50,900
[Laughter]

00:25:51,430 --> 00:25:58,790
the word buzz and scope are expressed

00:25:54,230 --> 00:26:00,740
with like an implication goal right more

00:25:58,790 --> 00:26:07,520
or less you know more or less so they -

00:26:00,740 --> 00:26:16,070
are they - are canonicalized in' and so

00:26:07,520 --> 00:26:18,820
forth okay we actually do distinguish

00:26:16,070 --> 00:26:21,830
the environment from the from my

00:26:18,820 --> 00:26:23,960
implication goal but they're not really

00:26:21,830 --> 00:26:28,420
a solving an implication bowl just move

00:26:23,960 --> 00:26:28,420
something to be learning right

00:26:30,410 --> 00:26:36,320
one other small question it was a little

00:26:35,000 --> 00:26:38,480
unclear where exactly the

00:26:36,320 --> 00:26:40,670
canonicalization happens does it happen

00:26:38,480 --> 00:26:42,950
on the trait engine side in the

00:26:40,670 --> 00:26:45,170
aggregator or in chopped engine itself

00:26:42,950 --> 00:26:49,730
it happens if the trait engine side

00:26:45,170 --> 00:26:53,470
right here okay so it's gonna select a

00:26:49,730 --> 00:26:55,130
goal which is stored in uncanonical form

00:26:53,470 --> 00:26:57,530
hmm okay

00:26:55,130 --> 00:27:03,020
it's going to canonicalize it and then

00:26:57,530 --> 00:27:04,610
send it over and and then get back a

00:27:03,020 --> 00:27:08,480
response in terms of those canonical

00:27:04,610 --> 00:27:09,560
variables in translated back and part of

00:27:08,480 --> 00:27:14,690
the reason it's stored in uncanonical

00:27:09,560 --> 00:27:16,400
forum is that well that way if there are

00:27:14,690 --> 00:27:19,130
other side effects that that wind up

00:27:16,400 --> 00:27:20,630
unifying those variables like maybe we

00:27:19,130 --> 00:27:23,510
know we had to prove vac of question

00:27:20,630 --> 00:27:24,980
mark 32 is debug that doesn't tell us

00:27:23,510 --> 00:27:26,900
what question mark 32 is but some other

00:27:24,980 --> 00:27:29,180
part of the program does then later you

00:27:26,900 --> 00:27:30,590
know will when we canonical eyes will

00:27:29,180 --> 00:27:32,780
see that question mark 32 has been

00:27:30,590 --> 00:27:34,130
unifying will well it will get

00:27:32,780 --> 00:27:35,420
canonicalize differently this time in a

00:27:34,130 --> 00:27:38,030
bit canonicalize to the actual type

00:27:35,420 --> 00:27:44,600
gotcha okay and which of these

00:27:38,030 --> 00:27:46,370
interfaces are rusty queries the there's

00:27:44,600 --> 00:27:51,350
a query that takes the canonical goals

00:27:46,370 --> 00:27:52,850
basically the query is like here okay my

00:27:51,350 --> 00:27:55,760
games getting kind of messy good yeah

00:27:52,850 --> 00:27:58,910
the query takes the goal and gives back

00:27:55,760 --> 00:28:00,830
the answer essentially yep I guess it's

00:27:58,910 --> 00:28:04,540
like stupid either because a training

00:28:00,830 --> 00:28:08,240
engine and yeah the talk engine its

00:28:04,540 --> 00:28:10,550
first yeah it gives back the

00:28:08,240 --> 00:28:14,890
substitution in their results all right

00:28:10,550 --> 00:28:19,540
so the aggregator all right let's see

00:28:14,890 --> 00:28:19,540
let me show you a few bits of this code

00:28:21,220 --> 00:28:28,490
I don't know what's gonna happen if I

00:28:26,110 --> 00:28:32,810
let's find out

00:28:28,490 --> 00:28:39,170
I don't close this whiteboard I'll save

00:28:32,810 --> 00:28:41,590
it for one thing okay uh just in case do

00:28:39,170 --> 00:28:41,590
share

00:28:41,720 --> 00:28:50,930
see do you see a really tiny font in a

00:28:47,120 --> 00:28:53,480
bunch of code should I make it a little

00:28:50,930 --> 00:28:57,620
bigger let's see if I'm actually able to

00:28:53,480 --> 00:28:58,340
do that I forgot that I don't know it

00:28:57,620 --> 00:29:01,640
did work okay

00:28:58,340 --> 00:29:02,900
I switched terminals since the last time

00:29:01,640 --> 00:29:04,190
I tried this because the last time I

00:29:02,900 --> 00:29:06,590
remember it was like pressed all the

00:29:04,190 --> 00:29:12,560
keys I can think of none of them we're

00:29:06,590 --> 00:29:16,280
making the font big so okay what am I

00:29:12,560 --> 00:29:23,780
looking at I don't even know so

00:29:16,280 --> 00:29:31,300
oh I'm like in shock code for song right

00:29:23,780 --> 00:29:31,300
so let's start with this so they the I

00:29:32,260 --> 00:29:39,940
said trait engine in my little chart and

00:29:36,560 --> 00:29:42,500
that was like the fulfillment context

00:29:39,940 --> 00:29:46,030
there's actually a trait in rusty called

00:29:42,500 --> 00:29:51,040
trait engine and it has these operations

00:29:46,030 --> 00:29:53,510
like normalizing things registering

00:29:51,040 --> 00:29:57,050
something a predicate that has to be

00:29:53,510 --> 00:30:00,020
proven through and select all or error

00:29:57,050 --> 00:30:02,420
means try to prove all the things and if

00:30:00,020 --> 00:30:05,420
you fail that's in your that you can

00:30:02,420 --> 00:30:07,490
report hence you get back this your and

00:30:05,420 --> 00:30:10,610
select where possible means try to prove

00:30:07,490 --> 00:30:13,280
all the things oh I see the only

00:30:10,610 --> 00:30:14,570
difference is select all our error will

00:30:13,280 --> 00:30:15,380
give an error if there are things that

00:30:14,570 --> 00:30:17,270
can't be proven

00:30:15,380 --> 00:30:18,500
whereas select where possible just

00:30:17,270 --> 00:30:20,450
leaves them in the list for later it's

00:30:18,500 --> 00:30:24,560
not it's only an error if they were

00:30:20,450 --> 00:30:26,360
proven to be false essential and yeah so

00:30:24,560 --> 00:30:28,220
this is basically the interface that the

00:30:26,360 --> 00:30:29,690
type checker needs from the fulfillment

00:30:28,220 --> 00:30:33,170
context and we introduced this little

00:30:29,690 --> 00:30:36,550
shim so that you can write - see chalk

00:30:33,170 --> 00:30:38,390
and stuff so like the old school

00:30:36,550 --> 00:30:40,100
fulfillment context with Russell's

00:30:38,390 --> 00:30:43,390
current rate solver also implements the

00:30:40,100 --> 00:30:49,130
same trade right this is the old school

00:30:43,390 --> 00:30:54,110
but the newer one is here under chalk

00:30:49,130 --> 00:30:56,210
fulfilled RS and I'll start with the

00:30:54,110 --> 00:30:58,400
select where possible because this is

00:30:56,210 --> 00:31:01,220
that algorithm I talked about so you see

00:30:58,400 --> 00:31:06,590
that it maintains a list of obligations

00:31:01,220 --> 00:31:09,140
they have to be proven which we iterate

00:31:06,590 --> 00:31:12,380
through here's where we do the

00:31:09,140 --> 00:31:14,660
canonicalization so we're gonna

00:31:12,380 --> 00:31:18,050
canonicalize the query that's going to

00:31:14,660 --> 00:31:24,040
give us a canonical goal here and then

00:31:18,050 --> 00:31:26,570
this is you asked Tyler Tyler team and

00:31:24,040 --> 00:31:30,110
really you and children you and Taylor

00:31:26,570 --> 00:31:36,890
confuse me especially now that you're

00:31:30,110 --> 00:31:38,450
both Google so so right so this is where

00:31:36,890 --> 00:31:43,210
the actual query comes in from from

00:31:38,450 --> 00:31:45,650
Rusty's perspective this evaluate goal

00:31:43,210 --> 00:31:49,280
and here's the actual query definition

00:31:45,650 --> 00:31:50,780
we'll come back to that but but you see

00:31:49,280 --> 00:31:53,000
we're giving it the canonical goal and

00:31:50,780 --> 00:31:58,220
we're getting back a response and this

00:31:53,000 --> 00:32:00,710
response is it's a result it's a

00:31:58,220 --> 00:32:02,810
canonical query response then the no

00:32:00,710 --> 00:32:04,310
solution means there was an we could we

00:32:02,810 --> 00:32:07,670
knew that this kit this is false

00:32:04,310 --> 00:32:09,740
otherwise we get back this maybe it's

00:32:07,670 --> 00:32:11,450
true or maybe it's not yet fully proven

00:32:09,740 --> 00:32:12,920
and we can ask like is it true is it

00:32:11,450 --> 00:32:16,820
fully proven if so we're making progress

00:32:12,920 --> 00:32:18,830
and we don't have to this instantiate

00:32:16,820 --> 00:32:20,300
query response and reagent obligations

00:32:18,830 --> 00:32:22,970
what this does that's actually

00:32:20,300 --> 00:32:24,770
interesting okay that's up fix me but

00:32:22,970 --> 00:32:26,600
we'll come to that what this does is

00:32:24,770 --> 00:32:31,190
take the substitution that came back and

00:32:26,600 --> 00:32:33,710
unify it into the inference context

00:32:31,190 --> 00:32:36,200
unifying the inference variables and

00:32:33,710 --> 00:32:38,450
here we say oh if it wasn't proven we'll

00:32:36,200 --> 00:32:40,790
just leave it in our list for later

00:32:38,450 --> 00:32:44,170
we'll come back to it this is a bit of a

00:32:40,790 --> 00:32:46,520
bug like I think we should be

00:32:44,170 --> 00:32:47,840
instantiating the query response and

00:32:46,520 --> 00:32:51,530
regional obligations in both cases

00:32:47,840 --> 00:32:53,240
potentially I feel but in other words

00:32:51,530 --> 00:32:55,310
this is like that case I mentioned where

00:32:53,240 --> 00:32:57,440
it might be that we know something about

00:32:55,310 --> 00:33:00,320
the variables but we don't yet know that

00:32:57,440 --> 00:33:01,880
it's fully proven well I'm not sure why

00:33:00,320 --> 00:33:03,320
we're not doing in both cases maybe just

00:33:01,880 --> 00:33:06,740
an oversight or maybe there's some more

00:33:03,320 --> 00:33:08,649
refactoring this musical but that's the

00:33:06,740 --> 00:33:14,360
idea

00:33:08,649 --> 00:33:17,960
so far so good okay so if we go dig in

00:33:14,360 --> 00:33:20,570
to evaluate goal that's over here let's

00:33:17,960 --> 00:33:25,659
bring that over this is the actual cold

00:33:20,570 --> 00:33:30,999
code so what it does there's a bit of a

00:33:25,659 --> 00:33:34,340
thing where does this happen you don't

00:33:30,999 --> 00:33:36,159
write actually before we get here let me

00:33:34,340 --> 00:33:39,259
let me jump back to the old code I

00:33:36,159 --> 00:33:40,489
wanted to look at the register predicate

00:33:39,259 --> 00:33:42,440
obligation because this is actually

00:33:40,489 --> 00:33:44,509
interesting so this is where the the

00:33:42,440 --> 00:33:47,419
type checker says hey we have something

00:33:44,509 --> 00:33:51,350
we need to prove and a predicate

00:33:47,419 --> 00:33:53,690
obligation is the old Russy notion of

00:33:51,350 --> 00:33:57,190
things to prove so it's all very rust

00:33:53,690 --> 00:34:00,440
specific this is a friend kit it's like

00:33:57,190 --> 00:34:02,029
you know whatever some traders holds

00:34:00,440 --> 00:34:06,049
some outlooks relationship a type

00:34:02,029 --> 00:34:08,649
relationship and so on and what we do is

00:34:06,049 --> 00:34:12,049
we call this method in environment and

00:34:08,649 --> 00:34:13,250
that is going to translate or it's a

00:34:12,049 --> 00:34:14,659
function rather but we call this

00:34:13,250 --> 00:34:16,639
function in environment and it's going

00:34:14,659 --> 00:34:20,270
to translate from the Russy notion of a

00:34:16,639 --> 00:34:22,429
predicate into we have so into the chalk

00:34:20,270 --> 00:34:23,899
notion and we sort of have like we're

00:34:22,429 --> 00:34:25,280
out we we thought we might keep these

00:34:23,899 --> 00:34:26,839
more unified but we will end up kind of

00:34:25,280 --> 00:34:30,589
separating them so rusty has sort of two

00:34:26,839 --> 00:34:31,369
notions of things there's like the old

00:34:30,589 --> 00:34:38,629
one and the new one

00:34:31,369 --> 00:34:41,599
and so yeah so one of the things that

00:34:38,629 --> 00:34:45,319
this does this predicate obligation

00:34:41,599 --> 00:34:46,639
includes a a parameter environment which

00:34:45,319 --> 00:34:49,819
is the set of things we the where

00:34:46,639 --> 00:34:51,290
clauses in scope basically and those are

00:34:49,819 --> 00:34:53,869
represented quite differently in Russy

00:34:51,290 --> 00:34:56,659
and chalk so this is like a little bit

00:34:53,869 --> 00:34:59,480
hacky right now if we're in chalk mode

00:34:56,659 --> 00:35:01,130
we keep a deaf ID which was like what

00:34:59,480 --> 00:35:04,400
function did this parameter come from

00:35:01,130 --> 00:35:08,720
and now we can construct the chalk

00:35:04,400 --> 00:35:09,770
environment from that def ID it if you

00:35:08,720 --> 00:35:11,750
see I mean so we saw are these two

00:35:09,770 --> 00:35:14,359
parallel things going on so there's some

00:35:11,750 --> 00:35:15,710
translation that takes place here it

00:35:14,359 --> 00:35:18,319
will be nice to refactor that at some

00:35:15,710 --> 00:35:20,099
points that I accept exactly remember

00:35:18,319 --> 00:35:23,999
why we had to do that

00:35:20,099 --> 00:35:26,279
so this is because the chalk notion of

00:35:23,999 --> 00:35:27,989
an environment is quite different and

00:35:26,279 --> 00:35:30,479
included stuff like implied bounds and

00:35:27,989 --> 00:35:35,970
so on that just aren't part of the

00:35:30,479 --> 00:35:39,710
Rusties notion but so we'll do this

00:35:35,970 --> 00:35:44,119
translation will call this evaluate goal

00:35:39,710 --> 00:35:44,119
let's take a look at evaluate goal again

00:35:46,009 --> 00:35:58,650
evaluate goal where this happens just

00:35:51,410 --> 00:36:03,269
computing to me let's see if I can find

00:35:58,650 --> 00:36:05,039
it where is it oh there it is right

00:36:03,269 --> 00:36:06,960
right so the first thing I value eighth

00:36:05,039 --> 00:36:09,749
goal does we already converted the

00:36:06,960 --> 00:36:11,880
environment from the rusty notion of an

00:36:09,749 --> 00:36:14,279
environment to the chalk to the sort of

00:36:11,880 --> 00:36:16,319
chalk version we also have to convert

00:36:14,279 --> 00:36:20,130
the goal that's what evaluate goal does

00:36:16,319 --> 00:36:23,279
here it's saying oh so predicates was

00:36:20,130 --> 00:36:26,789
the chalk

00:36:23,279 --> 00:36:29,180
- rusty notion but the the chalk version

00:36:26,789 --> 00:36:32,130
is called goal

00:36:29,180 --> 00:36:32,940
I'm also this is a little confusing I'm

00:36:32,130 --> 00:36:35,160
not sure I have the right terminology

00:36:32,940 --> 00:36:37,739
for this when I'm saying Chuck here what

00:36:35,160 --> 00:36:42,930
I mean is there are a set of types that

00:36:37,739 --> 00:36:45,150
are in rust see that represent the chaco

00:36:42,930 --> 00:36:47,640
five versions of traits and so forth

00:36:45,150 --> 00:36:49,890
right but they're not in Chuck there

00:36:47,640 --> 00:36:52,769
they're rather the when you instantiate

00:36:49,890 --> 00:36:54,479
the chalk engine and we have to set its

00:36:52,769 --> 00:36:56,910
associated types for like what is a goal

00:36:54,479 --> 00:37:00,960
and so forth this is what these types

00:36:56,910 --> 00:37:03,779
are and is this just a clear party code

00:37:00,960 --> 00:37:07,680
I think you mentioned in the working

00:37:03,779 --> 00:37:11,489
group meeting that's right you right now

00:37:07,680 --> 00:37:13,920
the lowering code in chalk is not used

00:37:11,489 --> 00:37:16,680
in the rusty integration and you'd like

00:37:13,920 --> 00:37:19,079
to factor that out yeah they both share

00:37:16,680 --> 00:37:21,150
that code they both have their own copy

00:37:19,079 --> 00:37:23,190
of that code okay okay right because

00:37:21,150 --> 00:37:26,640
this feels like what's being enumerated

00:37:23,190 --> 00:37:29,219
here is the lowered form of these tools

00:37:26,640 --> 00:37:32,190
yes like the plan is ultimately that

00:37:29,219 --> 00:37:33,849
rusty would not have this would be

00:37:32,190 --> 00:37:36,489
operating truly at a high

00:37:33,849 --> 00:37:38,410
all right what specific thing and then

00:37:36,489 --> 00:37:40,599
this would be in some shared library

00:37:38,410 --> 00:37:41,890
nothing about like this but it's a

00:37:40,599 --> 00:37:43,599
little tricky because it references

00:37:41,890 --> 00:37:50,319
types and so forth for example right

00:37:43,599 --> 00:37:52,719
okay quite yes so right so this code is

00:37:50,319 --> 00:37:55,119
right now just in traits the libera see

00:37:52,719 --> 00:38:01,390
slash traits that's where I am here and

00:37:55,119 --> 00:38:03,130
see up here on this line and it has you

00:38:01,390 --> 00:38:04,749
know they might look familiar if you've

00:38:03,130 --> 00:38:10,209
looked at Chuck so it has like a domain

00:38:04,749 --> 00:38:12,249
goal with various options you get into

00:38:10,209 --> 00:38:14,380
the details later but and then these are

00:38:12,249 --> 00:38:19,449
like the meta things right so this is a

00:38:14,380 --> 00:38:25,170
implies B a and B are both true it's not

00:38:19,449 --> 00:38:25,170
a and so on that oopsie wrong key

00:38:25,949 --> 00:38:33,969
so right so we convert into these format

00:38:31,599 --> 00:38:35,380
and there's one thing I wanted to

00:38:33,969 --> 00:38:36,789
highlight there's some special cases

00:38:35,380 --> 00:38:39,479
here for some reason or another but I

00:38:36,789 --> 00:38:42,880
don't remember but then the general case

00:38:39,479 --> 00:38:44,650
we invoke this this lower method and

00:38:42,880 --> 00:38:49,329
this is exactly the lower encoding I'm

00:38:44,650 --> 00:38:52,180
talking about Aaron okay it lives in the

00:38:49,329 --> 00:38:56,109
lib receipt rates notice the underscore

00:38:52,180 --> 00:39:02,680
this is a different crate subtle subtle

00:38:56,109 --> 00:39:07,449
convention in general the rusty colon

00:39:02,680 --> 00:39:10,630
colon traits code is like the shims that

00:39:07,449 --> 00:39:12,759
are needed to bridge into like the query

00:39:10,630 --> 00:39:14,709
let's put it the signatures and the

00:39:12,759 --> 00:39:16,449
query interface code and the query

00:39:14,709 --> 00:39:19,869
implementations live in the rusty

00:39:16,449 --> 00:39:22,479
underscore treats crates except for all

00:39:19,869 --> 00:39:24,519
the old rusty trade solving code which

00:39:22,479 --> 00:39:29,049
all lives in the pressing but when it's

00:39:24,519 --> 00:39:31,059
the newer stock code and that I don't

00:39:29,049 --> 00:39:32,799
know anyway so MJ told me that division

00:39:31,059 --> 00:39:38,229
was helpful I still think it's a little

00:39:32,799 --> 00:39:40,839
confusing so so this lowering right

00:39:38,229 --> 00:39:42,910
there's this trait called lower this is

00:39:40,839 --> 00:39:45,400
basically like what it says here

00:39:42,910 --> 00:39:49,119
lowering from a rusty construct

00:39:45,400 --> 00:39:50,499
into a chalk like type and it can do it

00:39:49,119 --> 00:39:52,479
differ a couple of different kinds of

00:39:50,499 --> 00:39:55,960
lowering that when one interesting thing

00:39:52,479 --> 00:39:58,450
is that lowering into a goal something

00:39:55,960 --> 00:39:59,799
to be proven is sometimes slightly

00:39:58,450 --> 00:40:05,710
different from lowering into a clause

00:39:59,799 --> 00:40:08,079
something always true but so you you can

00:40:05,710 --> 00:40:09,910
implement it twice if necessary but you

00:40:08,079 --> 00:40:13,269
know for example here we say okay lower

00:40:09,910 --> 00:40:18,099
from a credit get into a goal does some

00:40:13,269 --> 00:40:21,369
stuff I'm too excited that's just a

00:40:18,099 --> 00:40:23,259
dispatching imple obviously but so now

00:40:21,369 --> 00:40:26,849
here at this point the point is we now

00:40:23,259 --> 00:40:29,589
have a chalk like lowered goal yes

00:40:26,849 --> 00:40:31,719
actually this is quite inefficient so

00:40:29,589 --> 00:40:34,779
the picture I showed you is wrong as

00:40:31,719 --> 00:40:36,700
presently implemented I told you that we

00:40:34,779 --> 00:40:38,609
have a persistent forest that lives

00:40:36,700 --> 00:40:44,140
across sorry of persistent chalk

00:40:38,609 --> 00:40:46,210
conflict engine and that's but we don't

00:40:44,140 --> 00:40:48,190
I forgot we're actually making a new

00:40:46,210 --> 00:40:49,749
forest for every query that's totally

00:40:48,190 --> 00:40:52,269
inefficient there's no there's nothing

00:40:49,749 --> 00:40:56,049
wrong with it it's just gonna avoid all

00:40:52,269 --> 00:40:57,940
the caching benefits a plan is to

00:40:56,049 --> 00:40:59,819
there's I don't think there's any good

00:40:57,940 --> 00:41:02,579
reason for this to be this way I just

00:40:59,819 --> 00:41:06,130
easier

00:41:02,579 --> 00:41:09,309
so yeah forest is the name from the

00:41:06,130 --> 00:41:12,549
chalk engine crate before would like be

00:41:09,309 --> 00:41:15,069
I don't know why it's called a forest I

00:41:12,549 --> 00:41:17,380
I guess I called it that I guess I

00:41:15,069 --> 00:41:28,559
thought there were trees it really

00:41:17,380 --> 00:41:31,690
there's a dag for the set of tables so

00:41:28,559 --> 00:41:35,650
maybe that name is from an older or

00:41:31,690 --> 00:41:38,920
something in any case oh yeah so it

00:41:35,650 --> 00:41:40,690
calls forest solve that'll that'll do

00:41:38,920 --> 00:41:42,369
this aggregator thing I will create the

00:41:40,690 --> 00:41:45,130
iterator do the aggregation come up with

00:41:42,369 --> 00:41:48,309
a substitution and then we map that back

00:41:45,130 --> 00:41:51,039
to the answer that we put back as the

00:41:48,309 --> 00:41:52,599
result of the query so we are creating a

00:41:51,039 --> 00:41:57,039
new forest we're not going to get as

00:41:52,599 --> 00:41:59,210
much caching as you would like however

00:41:57,039 --> 00:42:02,569
we're still getting caching

00:41:59,210 --> 00:42:06,500
at the level of the Russy query itself

00:42:02,569 --> 00:42:07,940
right so what that means is the

00:42:06,500 --> 00:42:10,550
difference is like if I asked you if

00:42:07,940 --> 00:42:13,280
avakov is lots of people ask about a

00:42:10,550 --> 00:42:16,339
Veck of question mark T equals goal they

00:42:13,280 --> 00:42:18,800
will all get the same response but if

00:42:16,339 --> 00:42:22,220
somebody asks about something which as a

00:42:18,800 --> 00:42:24,470
sub task has to solve that it will redo

00:42:22,220 --> 00:42:26,119
that work whereas with the if they share

00:42:24,470 --> 00:42:27,559
the forest it wouldn't we do the work at

00:42:26,119 --> 00:42:30,950
all right

00:42:27,559 --> 00:42:32,750
and yeah in other words like the once

00:42:30,950 --> 00:42:35,630
you're off to the chalk engine you're

00:42:32,750 --> 00:42:37,430
not using the rusty query system there's

00:42:35,630 --> 00:42:39,650
no sort of pretty entrance key in that

00:42:37,430 --> 00:42:42,140
sense that's right you never come back

00:42:39,650 --> 00:42:46,670
up it has its own well you do but not to

00:42:42,140 --> 00:42:49,000
this not to this query which is what

00:42:46,670 --> 00:42:51,589
we're going to talk about right now so

00:42:49,000 --> 00:42:53,780
yeah so so that's kind of now we've seen

00:42:51,589 --> 00:42:55,849
the forest I guess the last interesting

00:42:53,780 --> 00:42:59,089
thing that I noticed but I'd forgotten

00:42:55,849 --> 00:43:03,760
about that you will we've all talked

00:42:59,089 --> 00:43:08,839
about lazy normalization if you compare

00:43:03,760 --> 00:43:10,849
the this is the this is the two

00:43:08,839 --> 00:43:12,890
implementations of trade engine oopsy

00:43:10,849 --> 00:43:15,260
relax my cursor there it is this is the

00:43:12,890 --> 00:43:18,200
old one on the right hand side you see

00:43:15,260 --> 00:43:21,380
the normalized projection type does a

00:43:18,200 --> 00:43:24,290
bunch of work figuring out what an

00:43:21,380 --> 00:43:28,010
Associated type is and so on fine though

00:43:24,290 --> 00:43:29,599
on the chalk side it doesn't do anything

00:43:28,010 --> 00:43:32,000
because that's because it's lazy and

00:43:29,599 --> 00:43:34,940
this normalization will take place the

00:43:32,000 --> 00:43:40,520
truck engine will handle it um that's

00:43:34,940 --> 00:43:45,230
kind of neat so let's look at this

00:43:40,520 --> 00:43:47,180
integration now so maybe I'll stop for

00:43:45,230 --> 00:43:52,160
one second from looking at rusty and

00:43:47,180 --> 00:43:56,930
just go over to look at chalk engine so

00:43:52,160 --> 00:44:01,099
the truck engine code has it has a bunt

00:43:56,930 --> 00:44:02,869
this this this context RS this is all

00:44:01,099 --> 00:44:05,119
the traits you see there's a lot

00:44:02,869 --> 00:44:11,680
actually kind of a lot of stuff that you

00:44:05,119 --> 00:44:11,680
have to implement to use this and

00:44:12,310 --> 00:44:18,700
mostly there's a whole bunch of types

00:44:15,810 --> 00:44:19,900
but there's also some operations on

00:44:18,700 --> 00:44:22,390
those types and that's what I wanted to

00:44:19,900 --> 00:44:26,110
show you so some of them are really

00:44:22,390 --> 00:44:27,730
simple like goal in environment this

00:44:26,110 --> 00:44:29,320
kind of says given an environment and a

00:44:27,730 --> 00:44:32,980
goal gave me a goal glue them together

00:44:29,320 --> 00:44:36,340
and give me the aggregated I like maybe

00:44:32,980 --> 00:44:37,570
if we add like I don't know GATS or

00:44:36,340 --> 00:44:41,200
something we could express some of these

00:44:37,570 --> 00:44:44,920
things a little more nicely but it's

00:44:41,200 --> 00:44:47,500
traffic right exactly so then it has

00:44:44,920 --> 00:44:51,850
some questions like is this a conductive

00:44:47,500 --> 00:44:54,480
goal or not the thing I wanted to show

00:44:51,850 --> 00:45:00,610
you was scrolling down a little bit

00:44:54,480 --> 00:45:03,880
first off where is it here this this

00:45:00,610 --> 00:45:05,350
hook program clauses this is the one

00:45:03,880 --> 00:45:06,940
that says given this environment and

00:45:05,350 --> 00:45:10,270
this goal you give me back all the ways

00:45:06,940 --> 00:45:12,880
a super set of things I might use to

00:45:10,270 --> 00:45:17,800
prove it yeah so that's where the

00:45:12,880 --> 00:45:21,550
strands originate right and jumping back

00:45:17,800 --> 00:45:24,790
up a little bit I think or no jump it

00:45:21,550 --> 00:45:28,360
back down sorry here we go

00:45:24,790 --> 00:45:30,370
yeah this one another key callback most

00:45:28,360 --> 00:45:32,800
of these are not interesting these are

00:45:30,370 --> 00:45:34,920
like the most important ones unified

00:45:32,800 --> 00:45:37,300
parameters this is where we're saying

00:45:34,920 --> 00:45:40,390
here are two things make them make them

00:45:37,300 --> 00:45:42,780
equal you'll note we have a variance in

00:45:40,390 --> 00:45:44,980
there I'll come back to that in a second

00:45:42,780 --> 00:45:46,690
normally that's not used because traits

00:45:44,980 --> 00:45:49,200
normally or just require strict equality

00:45:46,690 --> 00:45:50,430
but we have sub goals like sub type

00:45:49,200 --> 00:45:53,470
[Music]

00:45:50,430 --> 00:45:55,030
don't know anyway I'm not sure I like

00:45:53,470 --> 00:45:57,820
how it's handled but it's okay for now

00:45:55,030 --> 00:46:03,520
so it says take two parameters and unify

00:45:57,820 --> 00:46:05,920
them and you know get me back if that's

00:46:03,520 --> 00:46:08,350
true or false or whatever done and

00:46:05,920 --> 00:46:09,820
because of lazy normalization so that

00:46:08,350 --> 00:46:13,120
can what can happen here is that this

00:46:09,820 --> 00:46:17,200
can succeed but give back region

00:46:13,120 --> 00:46:19,030
constraints so like today and to be in

00:46:17,200 --> 00:46:21,810
my tail there only if take a equals to

00:46:19,030 --> 00:46:24,370
be but it can also succeed with

00:46:21,810 --> 00:46:25,960
normalization constraints so I can say

00:46:24,370 --> 00:46:28,000
if you had a project

00:46:25,960 --> 00:46:29,290
on one side in it and that's something

00:46:28,000 --> 00:46:30,609
on the other it would say yes but it

00:46:29,290 --> 00:46:33,250
would give you back a new sub goal you

00:46:30,609 --> 00:46:36,310
have to prove well so really really this

00:46:33,250 --> 00:46:38,500
this unification is not special um I

00:46:36,310 --> 00:46:40,750
think it's just it's kind of just

00:46:38,500 --> 00:46:43,150
another goal like that's kind of true

00:46:40,750 --> 00:46:47,320
for any goal but it's one that we handle

00:46:43,150 --> 00:46:48,550
a little specially but I feel like it

00:46:47,320 --> 00:46:51,280
kind of helped me to think about it

00:46:48,550 --> 00:46:52,869
eventually as there's a notion of

00:46:51,280 --> 00:46:55,390
unification that is like built of

00:46:52,869 --> 00:46:57,099
equality that is built into the logic

00:46:55,390 --> 00:47:00,520
somehow that like they're textually

00:46:57,099 --> 00:47:03,250
equal or something but but what we're

00:47:00,520 --> 00:47:05,410
really saying is whenever we have to

00:47:03,250 --> 00:47:07,690
equate two types we sort of have to

00:47:05,410 --> 00:47:12,030
prove a sub-goal equate t1 and t2 and

00:47:07,690 --> 00:47:13,990
that may require doing extra steps yeah

00:47:12,030 --> 00:47:20,530
but we treat them a little differently

00:47:13,990 --> 00:47:22,030
in that normally we sort of maybe this

00:47:20,530 --> 00:47:23,440
is not I don't know if this is actually

00:47:22,030 --> 00:47:26,050
right but this is how it's happening now

00:47:23,440 --> 00:47:27,730
normally we would process sub goals kind

00:47:26,050 --> 00:47:29,470
of they would make new tables and go

00:47:27,730 --> 00:47:30,910
down whereas this one says does all the

00:47:29,470 --> 00:47:33,070
work and then gives you a list of things

00:47:30,910 --> 00:47:34,960
to prove sort of a little anyway it

00:47:33,070 --> 00:47:36,220
doesn't matter that's - in the weeds the

00:47:34,960 --> 00:47:38,980
point is this is the main hook you have

00:47:36,220 --> 00:47:42,730
to implement unification and the program

00:47:38,980 --> 00:47:45,220
clauses and there's a few other variants

00:47:42,730 --> 00:47:48,010
of unification these are these things

00:47:45,220 --> 00:47:53,050
are their unification but in a specific

00:47:48,010 --> 00:47:55,480
context I won't go into so if we come

00:47:53,050 --> 00:47:58,839
back to chop context now we're looking

00:47:55,480 --> 00:48:02,500
back at rust see we can kind of see some

00:47:58,839 --> 00:48:13,500
of these these hooks so the program

00:48:02,500 --> 00:48:16,540
clauses in it you see program clauses

00:48:13,500 --> 00:48:22,000
goes over to this function for some

00:48:16,540 --> 00:48:24,420
reason which yeah and what it tries to

00:48:22,000 --> 00:48:29,609
do is it tries to say

00:48:24,420 --> 00:48:34,089
okay if we need to prove that some trait

00:48:29,609 --> 00:48:38,799
is implemented if you just look at

00:48:34,089 --> 00:48:40,150
there's a document on the rusty and the

00:48:38,799 --> 00:48:42,279
rusty guide that sort of shows you all

00:48:40,150 --> 00:48:44,920
the chalk lowering rules you can kind of

00:48:42,279 --> 00:48:46,359
fairly easily see where could such a

00:48:44,920 --> 00:48:49,029
rule come from it could come from

00:48:46,359 --> 00:48:54,940
lowering the trait or it could come from

00:48:49,029 --> 00:48:56,380
lowering some impulse so from in book

00:48:54,940 --> 00:48:59,219
sorry I guess they can come from

00:48:56,380 --> 00:49:01,839
implementations of the trait and I think

00:48:59,219 --> 00:49:02,979
right this is this has to do with

00:49:01,839 --> 00:49:04,329
implied counts that's just ignore that

00:49:02,979 --> 00:49:05,619
one for a second but the point is you

00:49:04,329 --> 00:49:07,420
can kind of go down and see what are the

00:49:05,619 --> 00:49:09,130
Russ language constructs that could be

00:49:07,420 --> 00:49:11,769
lowered into a rule that would satisfy

00:49:09,130 --> 00:49:15,219
this goal and then our job in this code

00:49:11,769 --> 00:49:17,140
is to go pull on those and this ties in

00:49:15,219 --> 00:49:21,670
with IDs and on demand processing

00:49:17,140 --> 00:49:25,779
because ideally also a specialization as

00:49:21,670 --> 00:49:30,279
it happens ideally we would only pull on

00:49:25,779 --> 00:49:32,859
like a sort of minimal set of things um

00:49:30,279 --> 00:49:34,599
we could go get all the impulse for all

00:49:32,859 --> 00:49:36,579
the traits but it would be inefficient

00:49:34,599 --> 00:49:37,779
and if there's type errors and those

00:49:36,579 --> 00:49:39,549
simples and stuff we might get weird

00:49:37,779 --> 00:49:42,339
result but if we can the board we can

00:49:39,549 --> 00:49:44,289
narrow this set the faster you'll be

00:49:42,339 --> 00:49:47,199
able to get answers back from from the

00:49:44,289 --> 00:49:48,430
RLS and so on right and it also ties

00:49:47,199 --> 00:49:50,079
into specialization and become

00:49:48,430 --> 00:49:52,119
significant to the language definition

00:49:50,079 --> 00:49:55,420
in that you know when you have to

00:49:52,119 --> 00:49:56,859
recursively if figuring out whether one

00:49:55,420 --> 00:50:02,019
table specializes another requires

00:49:56,859 --> 00:50:03,369
solving predicates hmm then the set of

00:50:02,019 --> 00:50:06,789
things we pull from here could create a

00:50:03,369 --> 00:50:10,839
cycle that would the way are out if it's

00:50:06,789 --> 00:50:12,849
too broad um so we should put this this

00:50:10,839 --> 00:50:16,930
is like a significant callback for the

00:50:12,849 --> 00:50:19,329
language semantics um anyway I think

00:50:16,930 --> 00:50:21,309
right now what it does the symbol

00:50:19,329 --> 00:50:23,949
clauses for imple basically just

00:50:21,309 --> 00:50:28,509
iterates through the impulse for the

00:50:23,949 --> 00:50:29,949
trait I don't exactly remember I have to

00:50:28,509 --> 00:50:34,180
go I was looking into this and didn't

00:50:29,949 --> 00:50:36,249
quite get done figuring out this is the

00:50:34,180 --> 00:50:37,250
stuff with implied bounds the

00:50:36,249 --> 00:50:39,619
interaction there but

00:50:37,250 --> 00:50:42,040
we'll come back to it but this part is

00:50:39,619 --> 00:50:44,630
significant so there are some things

00:50:42,040 --> 00:50:46,359
this is getting to the work that is

00:50:44,630 --> 00:50:49,520
actually in one of the sprinkles now

00:50:46,359 --> 00:50:52,940
yeah sometimes we don't have explicit

00:50:49,520 --> 00:50:54,680
impulse right have we have things that

00:50:52,940 --> 00:50:57,920
are built into the compiler so sized is

00:50:54,680 --> 00:51:04,240
an example and so it it's our job here

00:50:57,920 --> 00:51:08,630
to sort of add those rules as needed and

00:51:04,240 --> 00:51:10,130
one of the challenges is sometimes in

00:51:08,630 --> 00:51:12,530
order to figure out what the rule would

00:51:10,130 --> 00:51:14,480
be you might like to know a little bit

00:51:12,530 --> 00:51:17,510
about the type in question so if you

00:51:14,480 --> 00:51:24,080
look at like sized if you think about

00:51:17,510 --> 00:51:26,960
size you know it's easy to tell you if a

00:51:24,080 --> 00:51:28,820
boolean is sized it's pretty easy to

00:51:26,960 --> 00:51:33,710
tell you if an array of size because

00:51:28,820 --> 00:51:35,060
it's like sized if the argument oh I

00:51:33,710 --> 00:51:38,060
guess a razor always said I don't know

00:51:35,060 --> 00:51:40,849
whatever you know it's sometimes easy to

00:51:38,060 --> 00:51:43,790
tell you like in terms of other types if

00:51:40,849 --> 00:51:46,490
something is sized but it's pretty hard

00:51:43,790 --> 00:51:49,490
to tell you if some random infants

00:51:46,490 --> 00:51:52,099
variable is sized right so the set of

00:51:49,490 --> 00:51:54,680
rules that you would need to properly

00:51:52,099 --> 00:51:56,960
model properly model this the rules we

00:51:54,680 --> 00:51:59,930
would want would basically enumerate all

00:51:56,960 --> 00:52:04,240
the size two types as answers right

00:51:59,930 --> 00:52:06,500
which is a lot now we could do that but

00:52:04,240 --> 00:52:10,310
this is something we want to figure out

00:52:06,500 --> 00:52:12,290
a better answer to I think I think it

00:52:10,310 --> 00:52:14,150
will also be very important I mentioned

00:52:12,290 --> 00:52:21,320
long ago we want to prevent the solver

00:52:14,150 --> 00:52:22,280
from from getting stuck and trying to

00:52:21,320 --> 00:52:24,710
decide if this is too much of a

00:52:22,280 --> 00:52:27,700
digression but but basically stop me if

00:52:24,710 --> 00:52:30,080
you feeling I'm going off and losing you

00:52:27,700 --> 00:52:32,900
to jump back to the chalk engine a

00:52:30,080 --> 00:52:34,369
little bit you had those tables and the

00:52:32,900 --> 00:52:36,770
way that the talk engine kind of works

00:52:34,369 --> 00:52:38,570
internally is it's a list of things to

00:52:36,770 --> 00:52:40,670
prove it's going to pick one to focus on

00:52:38,570 --> 00:52:43,070
and pull answers out of it and then it's

00:52:40,670 --> 00:52:45,440
going to sort of feed those answers in

00:52:43,070 --> 00:52:49,270
so if you had to prove so you have two

00:52:45,440 --> 00:52:49,270
goals t is debug and T is

00:52:49,580 --> 00:52:53,690
display or something you might start

00:52:52,220 --> 00:52:56,330
with the debug and find well what are

00:52:53,690 --> 00:52:58,340
the values of T that make it debug it

00:52:56,330 --> 00:53:00,830
has infants variables in it and for each

00:52:58,340 --> 00:53:01,880
of those concrete answers now you can go

00:53:00,830 --> 00:53:04,430
take them off and see if they're

00:53:01,880 --> 00:53:06,470
displayed so the first goal acts as like

00:53:04,430 --> 00:53:14,230
a producer and the other goals act is

00:53:06,470 --> 00:53:16,460
like filters so make sense you lost me

00:53:14,230 --> 00:53:18,200
it's how we to detail let's just say

00:53:16,460 --> 00:53:19,820
I'll come back to it I'm not as deep

00:53:18,200 --> 00:53:22,880
into the rusty good I'll just say

00:53:19,820 --> 00:53:26,000
suffice to say that the order in which

00:53:22,880 --> 00:53:28,130
we solve goals is very important and we

00:53:26,000 --> 00:53:33,800
would prefer to solve goals that have

00:53:28,130 --> 00:53:35,570
more types like fewer answers first so

00:53:33,800 --> 00:53:38,210
something like question mark t : sized

00:53:35,570 --> 00:53:40,760
is like the worst goal remember we never

00:53:38,210 --> 00:53:45,280
want to solve that goal we always want

00:53:40,760 --> 00:53:45,280
to solve some other goal first and

00:53:46,240 --> 00:53:53,270
ideally when we know something about T

00:53:48,460 --> 00:53:55,880
so okay yeah a couple clarifying

00:53:53,270 --> 00:53:58,280
questions here because so one one thing

00:53:55,880 --> 00:54:00,710
I'm getting a bit confused about is the

00:53:58,280 --> 00:54:04,580
callback we were looking at was

00:54:00,710 --> 00:54:08,800
essentially the lowerings I mean it's

00:54:04,580 --> 00:54:13,910
like the creation of strands right and

00:54:08,800 --> 00:54:18,440
so what one question I have is is there

00:54:13,910 --> 00:54:21,260
mmm like the we are treating answer

00:54:18,440 --> 00:54:25,030
generation lazily but it seems like we

00:54:21,260 --> 00:54:30,170
are treating strand generation eagerly

00:54:25,030 --> 00:54:42,680
is there a simple reason that we do it

00:54:30,170 --> 00:54:46,540
that way you see what I mean I do I'm

00:54:42,680 --> 00:54:49,540
trying to decide what I think it seems

00:54:46,540 --> 00:54:49,540
like

00:54:53,319 --> 00:54:58,609
well for one thing we do need the

00:54:56,299 --> 00:55:01,220
ability in order to know when we can

00:54:58,609 --> 00:55:03,529
stop pulling on answers we do have to

00:55:01,220 --> 00:55:06,799
have I mentioned that sometimes we'll

00:55:03,529 --> 00:55:08,690
take back a partial answer and walk over

00:55:06,799 --> 00:55:11,259
the set of pending strands to see if any

00:55:08,690 --> 00:55:15,619
of them invalid that would be hard to do

00:55:11,259 --> 00:55:17,569
out a list of them however we don't

00:55:15,619 --> 00:55:21,710
always need to do that

00:55:17,569 --> 00:55:23,589
I suspect we could be lazier I think it

00:55:21,710 --> 00:55:26,809
is in part I think it's important that

00:55:23,589 --> 00:55:31,690
we generate the strands in a kind of

00:55:26,809 --> 00:55:31,690
deterministic order and so on

00:55:34,180 --> 00:55:38,569
not sure how important is but I think I

00:55:36,440 --> 00:55:40,670
think if we're not careful analysis that

00:55:38,569 --> 00:55:41,869
would be that doesn't like that's

00:55:40,670 --> 00:55:47,990
neither here nor there of course we know

00:55:41,869 --> 00:55:49,430
he could be deterministic and lazy so

00:55:47,990 --> 00:55:50,450
yeah I think we could be lazier I don't

00:55:49,430 --> 00:55:52,490
know if it would solve any fundamental

00:55:50,450 --> 00:55:54,710
problems but I think we could be lazier

00:55:52,490 --> 00:55:55,880
okay well I guess I mean the other the

00:55:54,710 --> 00:55:58,519
other thing I was wondering it's like

00:55:55,880 --> 00:56:00,470
hmm you know you were sort of initially

00:55:58,519 --> 00:56:03,710
talking about okay when we're generating

00:56:00,470 --> 00:56:04,460
these strands we have some cases like

00:56:03,710 --> 00:56:07,759
sized

00:56:04,460 --> 00:56:11,450
that potentially involve a lot of

00:56:07,759 --> 00:56:14,930
strands I think but you sort of switch

00:56:11,450 --> 00:56:17,150
to talking about the order in which we

00:56:14,930 --> 00:56:20,000
try to solve goals and and that I got a

00:56:17,150 --> 00:56:21,529
bit confused because again the strands

00:56:20,000 --> 00:56:23,630
seemed like we were eagerly producing

00:56:21,529 --> 00:56:28,190
these things and eagerly producing the

00:56:23,630 --> 00:56:30,980
set of all you know sized things seems

00:56:28,190 --> 00:56:33,349
problematic you see it I mean like I'm

00:56:30,980 --> 00:56:36,980
kind of I'm a bit confused exactly yes I

00:56:33,349 --> 00:56:38,720
see your point so yeah so it's

00:56:36,980 --> 00:56:41,769
definitely there's sort of two problems

00:56:38,720 --> 00:56:41,769
I mean it's definitely true that

00:56:42,039 --> 00:56:47,680
producing the set of all sized strands

00:56:44,390 --> 00:56:51,200
would be a lot it's not infinite because

00:56:47,680 --> 00:56:55,509
they can be recursive um it would be

00:56:51,200 --> 00:56:55,509
like one for struct or something but

00:56:55,690 --> 00:57:03,859
still like it the reason I I think it

00:57:02,000 --> 00:57:05,119
would be maybe I do have to explain to

00:57:03,859 --> 00:57:06,440
answer this question maybe the best

00:57:05,119 --> 00:57:09,799
thing is to jump a little bit back to

00:57:06,440 --> 00:57:10,819
the truck engine or yry I shifted goals

00:57:09,799 --> 00:57:12,079
is big

00:57:10,819 --> 00:57:14,569
I guess I'll put it like this because

00:57:12,079 --> 00:57:20,539
the reason I shifted is that the order

00:57:14,569 --> 00:57:25,339
in which we select the goals has a lot

00:57:20,539 --> 00:57:29,210
to do with which things what when we end

00:57:25,339 --> 00:57:31,849
up in this callback select in a

00:57:29,210 --> 00:57:36,589
different order we can avoid annoying

00:57:31,849 --> 00:57:39,680
questions a lot of the time yeah I see

00:57:36,589 --> 00:57:45,829
okay so wait so I guess another part of

00:57:39,680 --> 00:57:49,160
this is mmm-hmm so okay I think I think

00:57:45,829 --> 00:57:50,960
I was I hadn't quite put all these

00:57:49,160 --> 00:57:52,730
pieces together in my head like in in

00:57:50,960 --> 00:57:55,480
the old model of chalk I was thinking

00:57:52,730 --> 00:57:58,460
about you basically had a preliminary

00:57:55,480 --> 00:58:00,289
lowering steps which give you the entire

00:57:58,460 --> 00:58:03,619
contents of the program basically at

00:58:00,289 --> 00:58:06,589
once and I'm just query on that here

00:58:03,619 --> 00:58:08,329
like there is a laziness already in the

00:58:06,589 --> 00:58:12,170
sense that you're only doing that

00:58:08,329 --> 00:58:15,200
lowering based on goals that you're

00:58:12,170 --> 00:58:18,319
trying to prove so the only time you

00:58:15,200 --> 00:58:20,450
would ever start enumerated every sized

00:58:18,319 --> 00:58:22,730
type is if you actually encountered a

00:58:20,450 --> 00:58:24,559
goal that was just question mark ecoan

00:58:22,730 --> 00:58:28,430
sized and I think what you're saying is

00:58:24,559 --> 00:58:31,819
we want to avoid we want to sort of put

00:58:28,430 --> 00:58:34,099
off those goals as much as possible to

00:58:31,819 --> 00:58:36,200
avoid that that enumeration yeah and

00:58:34,099 --> 00:58:38,630
what we actually do is probably not bad

00:58:36,200 --> 00:58:40,519
like we we want to put them off that's

00:58:38,630 --> 00:58:43,789
right the only thing I would say is we

00:58:40,519 --> 00:58:45,740
do have to have a strategy like we can't

00:58:43,789 --> 00:58:47,630
always put it off all right though we

00:58:45,740 --> 00:58:50,839
need some answer what we're actually

00:58:47,630 --> 00:58:51,700
doing here is maybe good it might even

00:58:50,839 --> 00:58:54,710
be the right answer

00:58:51,700 --> 00:58:59,779
where is it well well I don't know it is

00:58:54,710 --> 00:59:02,059
but it comes down to that the the the

00:58:59,779 --> 00:59:03,650
chalk engine well I guess I'm gonna have

00:59:02,059 --> 00:59:06,700
to go soon but the chalk engine answer

00:59:03,650 --> 00:59:06,700
what it can be

00:59:07,220 --> 00:59:12,859
it me one second it doesn't have to be

00:59:09,800 --> 00:59:16,970
yes or no it can also include I don't

00:59:12,859 --> 00:59:18,859
know essentially and I think we're

00:59:16,970 --> 00:59:22,010
currently giving back an answer of this

00:59:18,859 --> 00:59:25,550
kind was like do not prove or it cannot

00:59:22,010 --> 00:59:26,900
prove so we would call it but the the

00:59:25,550 --> 00:59:33,530
thing is it's a little bit sketchy

00:59:26,900 --> 00:59:35,119
because like there are answers so it's

00:59:33,530 --> 00:59:36,829
it's kind of wrong to say the only

00:59:35,119 --> 00:59:39,470
answer is I do not it cannot prove

00:59:36,829 --> 00:59:40,970
answer that's not really true yes

00:59:39,470 --> 00:59:43,700
but I think it probably doesn't hurt

00:59:40,970 --> 00:59:45,890
anybody as for me right because I mean

00:59:43,700 --> 00:59:47,540
this could this is basically only gonna

00:59:45,890 --> 00:59:48,890
happen when we have some inference

00:59:47,540 --> 00:59:50,540
variables floating around

00:59:48,890 --> 00:59:53,119
I mean basically this is just affecting

00:59:50,540 --> 00:59:59,119
how the lengths we go for type inference

00:59:53,119 --> 01:00:00,859
right no I think so I I think there are

00:59:59,119 --> 01:00:02,540
fancier caching strategies that we're

01:00:00,859 --> 01:00:05,150
not using where it would cause problems

01:00:02,540 --> 01:00:08,750
so there's stuff like subsumption

01:00:05,150 --> 01:00:10,250
caching where the idea is like let's say

01:00:08,750 --> 01:00:12,950
you've let's say you've got a goal like

01:00:10,250 --> 01:00:14,900
Veck of question mark th debug and you

01:00:12,950 --> 01:00:16,730
go and solve it and then you have a

01:00:14,900 --> 01:00:19,130
later goal it's like vac of you 32 is

01:00:16,730 --> 01:00:20,450
debug in in the chalk strategy those are

01:00:19,130 --> 01:00:22,250
different tables they're not gonna share

01:00:20,450 --> 01:00:24,500
work but there are other strategies

01:00:22,250 --> 01:00:27,380
where you try to say oh well this is a

01:00:24,500 --> 01:00:28,730
subset of that other question so why

01:00:27,380 --> 01:00:30,740
don't I just use the results on that and

01:00:28,730 --> 01:00:33,079
filter them out basically but that would

01:00:30,740 --> 01:00:35,060
not I would not work if you did that

01:00:33,079 --> 01:00:37,040
with size under this strategy right

01:00:35,060 --> 01:00:39,829
because size doesn't have all the

01:00:37,040 --> 01:00:42,200
answers so I'm just a little nervous I

01:00:39,829 --> 01:00:44,720
think it's fine but we would we are sort

01:00:42,200 --> 01:00:46,849
of breaking the the model a little bit

01:00:44,720 --> 01:00:49,280
of a solver this way and so I would like

01:00:46,849 --> 01:00:52,089
to we should keep our eyes out for where

01:00:49,280 --> 01:00:54,710
it might lead us into bad assumptions um

01:00:52,089 --> 01:00:56,150
but I think god I think that we're

01:00:54,710 --> 01:00:58,160
probably going to wind up with some sort

01:00:56,150 --> 01:01:02,750
of thing that lets it bail out when it's

01:00:58,160 --> 01:01:04,490
just a clearly pointless task but we're

01:01:02,750 --> 01:01:06,560
gonna try to order our clauses so that

01:01:04,490 --> 01:01:11,180
we try not to get there in the first

01:01:06,560 --> 01:01:13,190
place if we keep it all possible and

01:01:11,180 --> 01:01:17,960
maybe we can make that bail out a little

01:01:13,190 --> 01:01:19,460
more um like first class up yeah exactly

01:01:17,960 --> 01:01:20,820
you were fine great into something so

01:01:19,460 --> 01:01:26,650
they

01:01:20,820 --> 01:01:30,060
that's all right I have to run to

01:01:26,650 --> 01:01:32,320
another thing I think we kind of covered

01:01:30,060 --> 01:01:35,290
you almost covered all the things I

01:01:32,320 --> 01:01:37,450
wanted to cover so that's good we need

01:01:35,290 --> 01:01:41,820
to narrow in exactly on I think a good

01:01:37,450 --> 01:01:44,650
starting point for what the task is I

01:01:41,820 --> 01:01:46,770
realized as we were talking that what I

01:01:44,650 --> 01:01:50,980
thought that I should be isn't oh no

01:01:46,770 --> 01:01:53,619
maybe it wasn't right but like one

01:01:50,980 --> 01:01:56,260
obvious starting task might be to do one

01:01:53,619 --> 01:01:57,369
of these fixed Me's but just to say

01:01:56,260 --> 01:02:00,840
rather than trying to solve some

01:01:57,369 --> 01:02:04,240
fundamental like refactoring of how we

01:02:00,840 --> 01:02:05,470
select clauses or whatever we should

01:02:04,240 --> 01:02:06,640
start by let's just copy some of the

01:02:05,470 --> 01:02:09,849
existing code just to get a feel for

01:02:06,640 --> 01:02:13,270
what's happening and learn the system so

01:02:09,849 --> 01:02:14,650
in particular maybe implementing the we

01:02:13,270 --> 01:02:16,630
have the built-in impulse for sized

01:02:14,650 --> 01:02:24,580
maybe we should try to make the built-in

01:02:16,630 --> 01:02:26,530
impulse for copy or something and I'm

01:02:24,580 --> 01:02:27,849
sure that will raise become you know

01:02:26,530 --> 01:02:37,960
once that's done then we can talk about

01:02:27,849 --> 01:02:39,460
how to make sense yeah yeah well it

01:02:37,960 --> 01:02:42,430
sounds like we should we should sync up

01:02:39,460 --> 01:02:52,290
when you have time and get this a little

01:02:42,430 --> 01:02:52,290

YouTube URL: https://www.youtube.com/watch?v=MBWtbDifPeU


