Title: RFC #2229 Disjoint Field Capture Plan
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	We discuss the overall strategy for implementing RFC #2229, pulling together a rough roadmap including a number of refactorings, and identifying some bits of work that can be done independently.
Captions: 
	00:00:01,909 --> 00:00:08,309
so alright let's try to remember so

00:00:06,210 --> 00:00:11,639
currently we did I think we did one

00:00:08,309 --> 00:00:17,550
thing well what was the PR we landed

00:00:11,639 --> 00:00:21,359
some PR right it was in a private branch

00:00:17,550 --> 00:00:25,890
though okay

00:00:21,359 --> 00:00:30,810
oh the P did we landed a PR but that was

00:00:25,890 --> 00:00:33,329
related to some cleanup the important PR

00:00:30,810 --> 00:00:37,350
for this one where we actually converted

00:00:33,329 --> 00:00:38,910
the list of upwards into a top oh that

00:00:37,350 --> 00:00:41,879
will be dental and it's just in a

00:00:38,910 --> 00:00:43,820
private branch okay so we can it oh I

00:00:41,879 --> 00:00:45,390
remember there was an efficiency problem

00:00:43,820 --> 00:00:48,300
right right right

00:00:45,390 --> 00:00:51,180
so the basic plan I'm just coming back

00:00:48,300 --> 00:00:55,170
to me now the first thing we did was we

00:00:51,180 --> 00:01:04,920
were converting the closure substance

00:00:55,170 --> 00:01:09,619
and generator subs pipes to to have a

00:01:04,920 --> 00:01:09,619
fixed number of type parameters

00:01:12,080 --> 00:01:20,390
regardless of how many up far as they

00:01:14,400 --> 00:01:26,360
captured right all right okay and I

00:01:20,390 --> 00:01:29,430
think the T key on my keyboard is like I

00:01:26,360 --> 00:01:35,670
if you notice any missing T's fill them

00:01:29,430 --> 00:01:39,079
in so yeah so this is like right and so

00:01:35,670 --> 00:01:44,280
it's kind of step one a of this was like

00:01:39,079 --> 00:01:47,579
basically um changed the api's for

00:01:44,280 --> 00:01:50,670
closure subset cetera to synthesize a

00:01:47,579 --> 00:01:53,720
tuple type and that part we did as a

00:01:50,670 --> 00:01:58,920
commit on the branch

00:01:53,720 --> 00:02:01,380
it has prey locations we didn't want to

00:01:58,920 --> 00:02:05,729
land it independently or it could have

00:02:01,380 --> 00:02:08,190
we couldn't test that anyway and then

00:02:05,729 --> 00:02:13,460
step B was going to be changed the type

00:02:08,190 --> 00:02:18,770
check or actually generate

00:02:13,460 --> 00:02:27,210
eight people right

00:02:18,770 --> 00:02:31,050
and actually my stinkweed you have a few

00:02:27,210 --> 00:02:33,990
videos in and around this area yeah so

00:02:31,050 --> 00:02:38,900
those videos are there in that the pull

00:02:33,990 --> 00:02:41,640
request that I sent you okay very nice

00:02:38,900 --> 00:02:49,520
so you've been working on step B right

00:02:41,640 --> 00:02:53,520
now right yeah and how is that going so

00:02:49,520 --> 00:02:57,240
when we have changed this into this the

00:02:53,520 --> 00:03:02,760
topple we have a few test failures yeah

00:02:57,240 --> 00:03:06,450
I saw your mess are you I guess so the

00:03:02,760 --> 00:03:08,070
one with the trait the UI test for trait

00:03:06,450 --> 00:03:13,650
matching was adding an extra line is

00:03:08,070 --> 00:03:16,370
that correct yeah and that same error is

00:03:13,650 --> 00:03:20,459
in all the nine tests that are failing

00:03:16,370 --> 00:03:22,770
okay so I don't know if you saw my

00:03:20,459 --> 00:03:27,600
messages and Zul upon that topic but I

00:03:22,770 --> 00:03:29,430
can expand yeah I don't see them okay

00:03:27,600 --> 00:03:32,360
let's leave that we'll come back to that

00:03:29,430 --> 00:03:34,590
topic because something we can discuss

00:03:32,360 --> 00:03:39,709
asynchronously I don't think it's a

00:03:34,590 --> 00:03:43,200
major problem like okay Dorit we could

00:03:39,709 --> 00:03:44,760
plausibly even land the PR as is but I

00:03:43,200 --> 00:03:46,980
think I'm inclined to try to fix the

00:03:44,760 --> 00:03:48,870
error messages I just don't think it's

00:03:46,980 --> 00:03:50,120
very well yeah but mostly because it

00:03:48,870 --> 00:03:51,650
seems like we're exposing uh

00:03:50,120 --> 00:03:55,650
implementation details

00:03:51,650 --> 00:03:57,030
if we land those message but the changes

00:03:55,650 --> 00:03:59,580
to the message kind of expose an

00:03:57,030 --> 00:04:04,320
internal detail that maybe users don't

00:03:59,580 --> 00:04:08,520
care about I see but I'm not overly

00:04:04,320 --> 00:04:13,590
concerned it's not the best error

00:04:08,520 --> 00:04:16,709
message anyway so I guess the

00:04:13,590 --> 00:04:18,720
interesting next question is where will

00:04:16,709 --> 00:04:22,260
we go from here

00:04:18,720 --> 00:04:24,740
right I think I definitely think step

00:04:22,260 --> 00:04:26,750
one that we should lay on this as a PR

00:04:24,740 --> 00:04:28,820
like this

00:04:26,750 --> 00:04:33,650
this is just a good change that's the

00:04:28,820 --> 00:04:37,940
stance on its own okay and so to the

00:04:33,650 --> 00:04:43,040
extent that you have it working already

00:04:37,940 --> 00:04:45,290
that's great and we should um we base it

00:04:43,040 --> 00:04:52,010
and everything get it ready to land

00:04:45,290 --> 00:04:58,220
um once we do that though then the next

00:04:52,010 --> 00:05:02,360
thing we have to do we're going to have

00:04:58,220 --> 00:05:08,180
to change okay we're going to have to

00:05:02,360 --> 00:05:10,880
change how many look all the code that

00:05:08,180 --> 00:05:15,760
assumes that the set of free variables

00:05:10,880 --> 00:05:15,760
is the same as the set of captures right

00:05:16,600 --> 00:05:22,550
maybe a later a way to look at this

00:05:19,160 --> 00:05:26,060
that's like a meta thing is we have some

00:05:22,550 --> 00:05:32,980
problems we have some assumptions in the

00:05:26,060 --> 00:05:36,950
current current code that have to be

00:05:32,980 --> 00:05:42,970
have to be fixed and step one was number

00:05:36,950 --> 00:05:48,010
of bars is baked into the sort of

00:05:42,970 --> 00:05:50,570
generics of a closure / generator this

00:05:48,010 --> 00:05:59,390
yeah and just to review this is the

00:05:50,570 --> 00:06:03,530
problem because the type checker or

00:05:59,390 --> 00:06:07,040
because we have to generate yeah we have

00:06:03,530 --> 00:06:10,490
to know the number of generic type

00:06:07,040 --> 00:06:16,160
parameters and so forth before we

00:06:10,490 --> 00:06:18,440
actually type check with your body so if

00:06:16,160 --> 00:06:26,419
the number of captures is going to be

00:06:18,440 --> 00:06:28,700
dependent on what the closure body on

00:06:26,419 --> 00:06:32,050
what paths the closure body actually

00:06:28,700 --> 00:06:36,969
uses and the types of those paths then

00:06:32,050 --> 00:06:40,280
this is a problem

00:06:36,969 --> 00:06:46,870
okay so that's number one in a similar

00:06:40,280 --> 00:06:51,199
vein code that uses the free VARs list

00:06:46,870 --> 00:06:55,069
to determine many field slash captures

00:06:51,199 --> 00:07:01,509
etc an enclosure has so you remember

00:06:55,069 --> 00:07:05,120
what I mean by free VARs list right so

00:07:01,509 --> 00:07:07,129
one question the first point B we

00:07:05,120 --> 00:07:09,770
already did something about it right

00:07:07,129 --> 00:07:11,150
like there are in the last here okay

00:07:09,770 --> 00:07:14,930
that's basically what we've been trying

00:07:11,150 --> 00:07:18,710
to fix until right okay so now I'm

00:07:14,930 --> 00:07:20,120
saying we probably want to probably the

00:07:18,710 --> 00:07:26,919
next thing we want to target is this

00:07:20,120 --> 00:07:29,960
free VARs situation and once we do that

00:07:26,919 --> 00:07:34,189
change consumers I think I think the

00:07:29,960 --> 00:07:41,449
plan here we're gonna have to dig into

00:07:34,189 --> 00:07:45,560
this a little bit I think what we're

00:07:41,449 --> 00:07:51,620
going to do ideally actually didn't you

00:07:45,560 --> 00:07:53,960
do some work about this - because you

00:07:51,620 --> 00:08:00,080
didn't actually we did something here

00:07:53,960 --> 00:08:02,689
maybe it's Anna branch oh so it bit free

00:08:00,080 --> 00:08:08,770
bars the call to be three bars we

00:08:02,689 --> 00:08:11,000
changed it that one yes remember we did

00:08:08,770 --> 00:08:16,639
we added something to the type check

00:08:11,000 --> 00:08:18,800
tables right yeah so we had so instead

00:08:16,639 --> 00:08:21,409
of going through the width field bars

00:08:18,800 --> 00:08:27,080
function which has mistakes the closure

00:08:21,409 --> 00:08:35,810
we added a map - lab who's this up for a

00:08:27,080 --> 00:08:41,419
capture map no not that one okay we deal

00:08:35,810 --> 00:08:46,069
for capitalists yeah I think it was up

00:08:41,419 --> 00:08:46,519
for list ah this looks right yeah that

00:08:46,069 --> 00:08:49,610
one

00:08:46,519 --> 00:08:56,320
yeah yeah that is the one we are

00:08:49,610 --> 00:09:01,340
right so so part a is to add information

00:08:56,320 --> 00:09:05,960
into this part we've already done into

00:09:01,340 --> 00:09:15,410
the tight check tables or tracks bars

00:09:05,960 --> 00:09:18,320
right and this is basically done okay so

00:09:15,410 --> 00:09:22,070
let me add a link here just for I'm

00:09:18,320 --> 00:09:24,320
basically hoping we can both for me to

00:09:22,070 --> 00:09:25,640
remember and that it's it will be nice

00:09:24,320 --> 00:09:30,560
to have a sort of overview of what the

00:09:25,640 --> 00:09:34,970
whole plan was and how I know and so

00:09:30,560 --> 00:09:36,650
step B we basically have to use this now

00:09:34,970 --> 00:09:41,540
and I don't remember how much of that

00:09:36,650 --> 00:09:44,540
work we did yeah we we just filled it up

00:09:41,540 --> 00:09:47,270
and we let it be I think you did a

00:09:44,540 --> 00:09:49,160
little bit of experimentation or not at

00:09:47,270 --> 00:09:55,610
least at least one consumer I think you

00:09:49,160 --> 00:09:56,990
changed I'm pretty sure because I

00:09:55,610 --> 00:10:01,280
remember there being some bugs around it

00:09:56,990 --> 00:10:05,360
I guess we don't have a paper document

00:10:01,280 --> 00:10:08,600
did we how did we communicate before

00:10:05,360 --> 00:10:11,390
well it doesn't matter so I would say

00:10:08,600 --> 00:10:13,250
like the work here first of all the work

00:10:11,390 --> 00:10:19,370
that has to be done in step two is we

00:10:13,250 --> 00:10:26,210
have to make a list of code that uses

00:10:19,370 --> 00:10:29,960
with free VARs we have to we have to for

00:10:26,210 --> 00:10:35,060
each for each user sort of make a plan

00:10:29,960 --> 00:10:38,930
for how it will be altered all right so

00:10:35,060 --> 00:10:43,280
I think a number of them and just use

00:10:38,930 --> 00:10:46,750
the up for list I'm pretty sure you

00:10:43,280 --> 00:10:46,750
changed mirror construction or something

00:10:47,110 --> 00:10:51,350
actually I could probably figure this

00:10:49,100 --> 00:10:57,950
out with relative ease so the up

00:10:51,350 --> 00:11:02,300
wireless map is accessible through the

00:10:57,950 --> 00:11:04,630
up far list let me just do a quick code

00:11:02,300 --> 00:11:04,630
search

00:11:06,030 --> 00:11:09,100
[Music]

00:11:10,150 --> 00:11:22,820
yeah so Samir construction Russ let's

00:11:15,650 --> 00:11:26,030
see it looks like oh man this is the

00:11:22,820 --> 00:11:29,630
weirdest I have to complain it she sorry

00:11:26,030 --> 00:11:33,050
totally unrelated but in github for some

00:11:29,630 --> 00:11:36,200
reason it does never it does not find

00:11:33,050 --> 00:11:38,750
like in this file search mode mere

00:11:36,200 --> 00:11:40,130
construction it just can't find and I've

00:11:38,750 --> 00:11:42,500
never understood lion and drives me a

00:11:40,130 --> 00:11:44,510
little bit crazy but there's some kind

00:11:42,500 --> 00:11:46,400
of there's some kind of bug there's a

00:11:44,510 --> 00:11:48,980
directory lip rusty mirror slash build

00:11:46,400 --> 00:11:50,870
but you see it's not in this list so

00:11:48,980 --> 00:11:53,570
what I always have to do is yeah go to

00:11:50,870 --> 00:12:05,290
some other thing and then pop back and

00:11:53,570 --> 00:12:05,290
then go here anyway uh so online 635

00:12:06,840 --> 00:12:10,440
[Music]

00:12:10,720 --> 00:12:20,180
right so this this code here um is now

00:12:15,410 --> 00:12:23,890
using the up farthest right right and

00:12:20,180 --> 00:12:28,850
that you changed that I'm pretty sure

00:12:23,890 --> 00:12:34,670
nobody that's part of this PR so similar

00:12:28,850 --> 00:12:37,850
to this but there there may be other

00:12:34,670 --> 00:12:41,660
code I guess the question is to check

00:12:37,850 --> 00:12:44,570
where is the other code but in which

00:12:41,660 --> 00:12:48,530
cases is discharged and I think that

00:12:44,570 --> 00:12:51,050
would primarily be harder to do if for

00:12:48,530 --> 00:12:54,640
some reason that code comes before type

00:12:51,050 --> 00:12:58,010
check is done you know type check yeah

00:12:54,640 --> 00:13:02,030
and I'm hoping we don't have any such

00:12:58,010 --> 00:13:07,310
cases or at least we can find you know

00:13:02,030 --> 00:13:10,400
solutions for each of them in the last

00:13:07,310 --> 00:13:13,550
call we had you actually checked that

00:13:10,400 --> 00:13:16,790
and you said that there are cases where

00:13:13,550 --> 00:13:20,350
it is happening but it's later well be

00:13:16,790 --> 00:13:21,560
have already inferred so it's risk-free

00:13:20,350 --> 00:13:25,340
okay

00:13:21,560 --> 00:13:27,380
I sort of remember that but I don't know

00:13:25,340 --> 00:13:29,750
where maybe you remember if if there was

00:13:27,380 --> 00:13:31,550
a like I think I just did that

00:13:29,750 --> 00:13:38,270
informally right I didn't like write it

00:13:31,550 --> 00:13:41,360
down yeah yeah it seems like a good idea

00:13:38,270 --> 00:13:47,540
to write it down but I'm glad I did look

00:13:41,360 --> 00:13:47,930
at it already yeah I have a memory of

00:13:47,540 --> 00:13:50,480
that

00:13:47,930 --> 00:13:57,980
so hopefully that won't be too hard so

00:13:50,480 --> 00:14:03,460
once we land step 1 we can do step 2 and

00:13:57,980 --> 00:14:03,460
that hopefully is mostly gonna be like

00:14:04,000 --> 00:14:07,390
straight this out

00:14:11,410 --> 00:14:15,610
that's mostly going to be a matter of

00:14:15,970 --> 00:14:26,240
making these changes and once we've done

00:14:18,740 --> 00:14:28,010
that I think those are all the yeah I

00:14:26,240 --> 00:14:33,140
think those are all the bits of code

00:14:28,010 --> 00:14:35,720
that sort of all the places where we

00:14:33,140 --> 00:14:37,520
need to break the assumptions right and

00:14:35,720 --> 00:14:43,640
I think at this point we are then able

00:14:37,520 --> 00:14:47,240
to make the we're then able to make the

00:14:43,640 --> 00:14:54,080
tight check code kind of change the

00:14:47,240 --> 00:14:55,670
captures well okay in theory we're able

00:14:54,080 --> 00:14:58,160
to make the typeset code change the set

00:14:55,670 --> 00:15:00,560
of captures and other things we'll just

00:14:58,160 --> 00:15:05,530
adapt to that change but I realize now

00:15:00,560 --> 00:15:09,440
another problem is going to be the

00:15:05,530 --> 00:15:13,650
mirror well let's see so mere

00:15:09,440 --> 00:15:21,840
construction I guess

00:15:13,650 --> 00:15:25,590
when we right now we assume that an up

00:15:21,840 --> 00:15:27,840
for you basically

00:15:25,590 --> 00:15:32,550
we translate at some point a reference

00:15:27,840 --> 00:15:39,980
to X to a reference to self dot X and we

00:15:32,550 --> 00:15:48,150
might want hmm we might want to change

00:15:39,980 --> 00:15:51,990
so that we so that we're able to like

00:15:48,150 --> 00:15:56,730
intercept you know X dot food or food up

00:15:51,990 --> 00:15:57,960
bar hold on I'm gonna make a question

00:15:56,730 --> 00:15:59,580
mark section actually did a little

00:15:57,960 --> 00:16:07,800
uncertainty here in my mind so

00:15:59,580 --> 00:16:13,170
so what option would be let's see i'm

00:16:07,800 --> 00:16:20,520
making a closure and i used X x dot y

00:16:13,170 --> 00:16:22,050
right and today we will translate let's

00:16:20,520 --> 00:16:26,520
make it very obvious what's happening

00:16:22,050 --> 00:16:32,520
this is a read today we will translate

00:16:26,520 --> 00:16:37,830
to a capture of X what we want according

00:16:32,520 --> 00:16:44,700
to RFC is that logically we capture x

00:16:37,830 --> 00:16:49,440
dot y there is some concern that if you

00:16:44,700 --> 00:16:56,600
had for example a number of captures

00:16:49,440 --> 00:16:58,010
with the same route let's change this to

00:16:56,600 --> 00:17:02,060
[Music]

00:16:58,010 --> 00:17:08,010
we might prefer to still just capture X

00:17:02,060 --> 00:17:11,550
by reference right and the reason would

00:17:08,010 --> 00:17:13,080
be that it's just less one you know just

00:17:11,550 --> 00:17:17,550
more in it's fewer fields at runtime

00:17:13,080 --> 00:17:21,990
right that would sort of be unsafe in

00:17:17,550 --> 00:17:25,310
the sense like unsafe in the sense that

00:17:21,990 --> 00:17:25,310
the borrow checker

00:17:25,709 --> 00:17:30,399
you you if you wanted to write that as

00:17:28,239 --> 00:17:32,320
in real code you'd have to use unsafe

00:17:30,399 --> 00:17:34,059
code kind of because you're actually

00:17:32,320 --> 00:17:35,919
taking a reference to X but you're sort

00:17:34,059 --> 00:17:38,379
of promising that you'll only use the Y

00:17:35,919 --> 00:17:42,580
in C fields and the bar checker has to

00:17:38,379 --> 00:17:49,059
kind of know to believe you I I don't

00:17:42,580 --> 00:17:51,489
know how I want to do that I think that

00:17:49,059 --> 00:17:54,269
is a nice optimization I don't know

00:17:51,489 --> 00:17:57,940
whether we would want to do that as a

00:17:54,269 --> 00:18:01,529
actual mirror optimization after the

00:17:57,940 --> 00:18:03,999
fact or whether we would want to create

00:18:01,529 --> 00:18:05,409
the mirror with the optimization but

00:18:03,999 --> 00:18:13,269
tell the borrowed checker to type check

00:18:05,409 --> 00:18:15,190
it differently I don't love I guess I

00:18:13,269 --> 00:18:17,169
don't love either of those plans but I'm

00:18:15,190 --> 00:18:20,470
I'm nervous about telling the bar

00:18:17,169 --> 00:18:23,320
checker to treat the code differently

00:18:20,470 --> 00:18:24,999
than what it's actually doing because

00:18:23,320 --> 00:18:26,710
it's the kind of thing we used to do a

00:18:24,999 --> 00:18:31,690
lot and it can definitely lead to subtle

00:18:26,710 --> 00:18:33,159
bugs I feel I mean I guess this that's

00:18:31,690 --> 00:18:38,940
also true for the optimization but

00:18:33,159 --> 00:18:42,519
somehow it feels different to me um so

00:18:38,940 --> 00:18:46,809
whatever you said should we write it on

00:18:42,519 --> 00:18:51,789
the dock so that we remember yeah I mean

00:18:46,809 --> 00:18:56,970
so the question is so basically the

00:18:51,789 --> 00:18:59,769
question is should we or two possible

00:18:56,970 --> 00:19:04,409
there are two possible approaches right

00:18:59,769 --> 00:19:09,700
either we generate code that captures X

00:19:04,409 --> 00:19:18,549
like a borrow checker understands treat

00:19:09,700 --> 00:19:22,139
it as borrowing XY and XZ or we generate

00:19:18,549 --> 00:19:22,139
code that borrows

00:19:25,420 --> 00:19:36,530
no rate code that borrows X Y and X dot

00:19:33,230 --> 00:19:43,310
C and optimize it after the fact now

00:19:36,530 --> 00:19:48,020
this is kind of maybe kind of hard so

00:19:43,310 --> 00:19:54,620
let's just let's just drill into this a

00:19:48,020 --> 00:20:05,720
little bit it seems worth it so like if

00:19:54,620 --> 00:20:11,090
I take an example here's a captured

00:20:05,720 --> 00:20:19,760
variable X we'll put some we'll put two

00:20:11,090 --> 00:20:25,520
vectors in it and I'm going to like

00:20:19,760 --> 00:20:28,430
print Len for three vectors so there's

00:20:25,520 --> 00:20:47,000
one we don't use I'm going to print

00:20:28,430 --> 00:20:51,400
these two things X dot 0 X dot 1 this

00:20:47,000 --> 00:21:00,230
code will compile let's find out

00:20:51,400 --> 00:21:02,570
okay almost oh of course it won't

00:21:00,230 --> 00:21:05,290
compile the whole play this RFC is to

00:21:02,570 --> 00:21:07,850
make this code compile right so we would

00:21:05,290 --> 00:21:11,930
all of this RFC is that line six would

00:21:07,850 --> 00:21:16,720
compile but it won't because right now

00:21:11,930 --> 00:21:16,720
we're capturing all of X which is fine

00:21:18,400 --> 00:21:23,270
but what I wanted to do the reason I was

00:21:20,750 --> 00:21:27,410
doing this is I wanted to look at the to

00:21:23,270 --> 00:21:29,770
look at the mirror that results blah

00:21:27,410 --> 00:21:29,770
blah blah

00:21:33,600 --> 00:21:41,220
how can I resize this okay I don't know

00:21:43,260 --> 00:21:51,040
so while using vexes maybe not a good

00:21:47,500 --> 00:22:22,540
choice because it's college stuff let's

00:21:51,040 --> 00:22:24,670
just do this okay right toad so here is

00:22:22,540 --> 00:22:27,130
interesting okay I guess this is getting

00:22:24,670 --> 00:22:30,280
more optimized than I expected but this

00:22:27,130 --> 00:22:32,890
must be the point where it is underscore

00:22:30,280 --> 00:22:35,800
to this variable this must be the

00:22:32,890 --> 00:22:37,360
closure and we're assigning to its to

00:22:35,800 --> 00:22:41,890
its one field oops

00:22:37,360 --> 00:22:46,390
just in there for signing to its one

00:22:41,890 --> 00:22:51,160
field the the tuple a reference to the

00:22:46,390 --> 00:22:56,560
tuple X right and so my point was if we

00:22:51,160 --> 00:23:00,700
were gonna change this after the fact we

00:22:56,560 --> 00:23:05,080
would have to kind of alter this code

00:23:00,700 --> 00:23:07,810
like it's pretty tricky right we'd have

00:23:05,080 --> 00:23:10,360
to alter this code to instead of doing

00:23:07,810 --> 00:23:11,620
one thing to do two or three things we

00:23:10,360 --> 00:23:14,080
still obviously have to change the

00:23:11,620 --> 00:23:15,400
fields this alone might argue why we

00:23:14,080 --> 00:23:21,570
can't do it after the fact very easily

00:23:15,400 --> 00:23:24,280
because okay so to make the change or

00:23:21,570 --> 00:23:28,450
whatever however we do it you have to

00:23:24,280 --> 00:23:30,790
accommodate two concepts which is the

00:23:28,450 --> 00:23:35,680
number of fields in the closure struct

00:23:30,790 --> 00:23:41,040
and the number of captures right and

00:23:35,680 --> 00:23:41,040
these right now are one-to-one but

00:23:42,230 --> 00:23:51,630
but we would want to make them separate

00:23:45,660 --> 00:23:57,270
because yeah right you can't do this and

00:23:51,630 --> 00:24:00,480
so what that implies to me is however we

00:23:57,270 --> 00:24:01,740
do this the layout code and other code

00:24:00,480 --> 00:24:07,590
that has to deal with the number of

00:24:01,740 --> 00:24:09,600
fields is going to want to be kind of

00:24:07,590 --> 00:24:13,740
aware of the final result before we even

00:24:09,600 --> 00:24:15,210
get started right because it has to

00:24:13,740 --> 00:24:18,870
generate the right size you can't change

00:24:15,210 --> 00:24:22,020
it up later and that means that code is

00:24:18,870 --> 00:24:23,460
kind of tied to to the mirror in the

00:24:22,020 --> 00:24:26,450
first place we can't generate mirror

00:24:23,460 --> 00:24:28,400
that writes to fields that don't exist

00:24:26,450 --> 00:24:32,130
do you see my point

00:24:28,400 --> 00:24:33,510
yeah so let's see so so it seems like

00:24:32,130 --> 00:24:36,840
we're kind of getting to that we can't

00:24:33,510 --> 00:24:41,730
they're actually this approach is maybe

00:24:36,840 --> 00:24:45,750
incoherent because it would it would

00:24:41,730 --> 00:24:49,650
require us alter the layout of the

00:24:45,750 --> 00:24:53,400
closure struct after mirror generation

00:24:49,650 --> 00:24:54,210
and we don't currently on them mechanism

00:24:53,400 --> 00:24:55,920
for that like that would require

00:24:54,210 --> 00:24:57,870
introducing two concepts of layout one

00:24:55,920 --> 00:25:02,180
that's like pre optimization and one

00:24:57,870 --> 00:25:06,170
that's post optimization or something I

00:25:02,180 --> 00:25:06,170
think we just don't wanna do that so

00:25:07,100 --> 00:25:14,610
that means we either we only really have

00:25:10,920 --> 00:25:19,050
one choice which is this which is that

00:25:14,610 --> 00:25:21,390
we have to figure out ahead of time the

00:25:19,050 --> 00:25:23,460
logical Barros and the actual burrows or

00:25:21,390 --> 00:25:26,940
the logical captures and the actual

00:25:23,460 --> 00:25:28,170
captures and some parts of the code are

00:25:26,940 --> 00:25:30,390
going to want to deal with the actual

00:25:28,170 --> 00:25:31,560
captures and some parts of the code are

00:25:30,390 --> 00:25:36,390
gonna want to deal with the logical

00:25:31,560 --> 00:25:38,070
captures and now we get to another

00:25:36,390 --> 00:25:42,300
challenge so let's just assume we're

00:25:38,070 --> 00:25:47,280
doing that that's how we going to

00:25:42,300 --> 00:25:51,860
separate logical captures

00:25:47,280 --> 00:25:55,200
our check sees on the actual captures

00:25:51,860 --> 00:25:59,880
what the code does and how we have

00:25:55,200 --> 00:26:01,500
another problem is that if you look at

00:25:59,880 --> 00:26:04,620
where these captures these borrows and

00:26:01,500 --> 00:26:07,080
things are occurring in this code you

00:26:04,620 --> 00:26:09,030
can see that we are we're actually

00:26:07,080 --> 00:26:12,060
borrowing so underscore one is the

00:26:09,030 --> 00:26:14,040
variable X here right and we're actually

00:26:12,060 --> 00:26:16,860
borrowing it just kind of in this random

00:26:14,040 --> 00:26:19,680
statement that's not connected to the

00:26:16,860 --> 00:26:22,260
closure in any particular way and this

00:26:19,680 --> 00:26:23,940
is actually after optimization but but

00:26:22,260 --> 00:26:25,830
this is really the closure construction

00:26:23,940 --> 00:26:29,100
this is just a normal borrow from our

00:26:25,830 --> 00:26:32,400
point of view so well for us to know

00:26:29,100 --> 00:26:33,930
that logically this is borrowing X Y and

00:26:32,400 --> 00:26:39,050
X dot Z even though it looks like it's

00:26:33,930 --> 00:26:47,070
borrowing X it's actually something we

00:26:39,050 --> 00:26:55,410
sort of can't do right now so what this

00:26:47,070 --> 00:27:01,070
leads me to so ok hold on problem a set

00:26:55,410 --> 00:27:08,490
of her borrow check sort of Muir has no

00:27:01,070 --> 00:27:12,180
way to reflect optical versus actual

00:27:08,490 --> 00:27:16,260
borrows right now the borrows in Weston

00:27:12,180 --> 00:27:20,640
are just normal borrows borrow Tucker

00:27:16,260 --> 00:27:26,220
camp obviously distinguish unless we add

00:27:20,640 --> 00:27:31,050
some metadata so I think what I would

00:27:26,220 --> 00:27:32,550
what I I think what we should do a is we

00:27:31,050 --> 00:27:36,000
should probably try to introduce this

00:27:32,550 --> 00:27:41,660
concept of logical versus actual but we

00:27:36,000 --> 00:27:44,540
prob we probably shouldn't use it yet

00:27:41,660 --> 00:27:46,530
violation ok still be sort of one-to-one

00:27:44,540 --> 00:27:47,790
I'm not sure if we even want to

00:27:46,530 --> 00:27:48,990
introduce it but it seems like it might

00:27:47,790 --> 00:27:51,240
be nice while we're going through all

00:27:48,990 --> 00:27:52,740
the consumers we can try to separate

00:27:51,240 --> 00:27:55,170
them out a little bit and maybe there's

00:27:52,740 --> 00:27:59,179
two api's that go to the same thing or

00:27:55,170 --> 00:27:59,179
something or maybe we don't bother but

00:28:00,270 --> 00:28:04,150
and I think we should get it working

00:28:02,380 --> 00:28:07,480
first with the inefficient version is

00:28:04,150 --> 00:28:11,380
basically what I'm advocating however I

00:28:07,480 --> 00:28:14,080
think there's a principled way that we

00:28:11,380 --> 00:28:17,010
might want to do as a second step to add

00:28:14,080 --> 00:28:20,230
this notion of logical versus actual and

00:28:17,010 --> 00:28:22,659
that is that actually this is the

00:28:20,230 --> 00:28:25,750
problem like if you look at the borrowed

00:28:22,659 --> 00:28:30,340
track in general there's just a general

00:28:25,750 --> 00:28:44,289
problem of you know if you have a method

00:28:30,340 --> 00:28:48,510
like this I have I try to call bar I'm

00:28:44,289 --> 00:28:48,510
gonna get an error right now because

00:28:49,620 --> 00:28:56,710
because I have a borrow of self dot a

00:28:54,010 --> 00:28:58,150
and calling bar requires access to all

00:28:56,710 --> 00:29:00,700
of self even though it's not going to

00:28:58,150 --> 00:29:05,590
use the field eight right it's the same

00:29:00,700 --> 00:29:11,039
problem and I I would like to have a way

00:29:05,590 --> 00:29:14,950
for us in rust in general to declare

00:29:11,039 --> 00:29:16,809
sort of that that four bar to declare

00:29:14,950 --> 00:29:18,970
that it only uses this field bar so that

00:29:16,809 --> 00:29:22,120
so that we could type check this code I

00:29:18,970 --> 00:29:23,770
don't plan for us to add that to I mean

00:29:22,120 --> 00:29:25,780
I have no concrete plans for how that

00:29:23,770 --> 00:29:27,070
would work in rust but it might be

00:29:25,780 --> 00:29:29,679
something where we could start building

00:29:27,070 --> 00:29:34,960
some of the underlying mechanism now in

00:29:29,679 --> 00:29:36,789
order to handle this yeah I mean

00:29:34,960 --> 00:29:42,850
basically what it would mean is that we

00:29:36,789 --> 00:29:47,980
would so yes the same problem as this

00:29:42,850 --> 00:29:55,210
and the underlying mechanism has to be

00:29:47,980 --> 00:30:03,870
something like borrowing X but

00:29:55,210 --> 00:30:12,340
specifying the paths you can use from X

00:30:03,870 --> 00:30:14,260
so so I yeah I'm not even gonna

00:30:12,340 --> 00:30:16,210
venture a guess as to what this indicted

00:30:14,260 --> 00:30:18,160
ad syntax might look like well okay I

00:30:16,210 --> 00:30:21,700
will I'm like you know you might imagine

00:30:18,160 --> 00:30:26,770
something like this I a reference that

00:30:21,700 --> 00:30:29,970
can home the access bar that's kind of

00:30:26,770 --> 00:30:31,960
the concept we want it seems to me like

00:30:29,970 --> 00:30:34,300
well we could sort of do this in any

00:30:31,960 --> 00:30:39,370
order but it seems to me like it would

00:30:34,300 --> 00:30:44,860
be nice to get to first get the feature

00:30:39,370 --> 00:30:46,540
working so that we can test it and deal

00:30:44,860 --> 00:30:48,160
with some of the other questions like

00:30:46,540 --> 00:30:49,510
even ignoring this optimization there

00:30:48,160 --> 00:30:53,710
are some questions and stuff we wanted

00:30:49,510 --> 00:30:55,540
to play around with around when should

00:30:53,710 --> 00:30:58,330
you break it up into fields and so forth

00:30:55,540 --> 00:31:00,130
um and then we could separately come

00:30:58,330 --> 00:31:03,070
take a look at this problem and try to

00:31:00,130 --> 00:31:03,370
deal with it that's what I think makes

00:31:03,070 --> 00:31:07,510
sense

00:31:03,370 --> 00:31:09,280
so okay digression aside well that means

00:31:07,510 --> 00:31:11,080
that that already tells us that there's

00:31:09,280 --> 00:31:15,240
going to be a like step n which is like

00:31:11,080 --> 00:31:21,400
try to optimize the representation of

00:31:15,240 --> 00:31:27,880
closures you don't know exactly what n

00:31:21,400 --> 00:31:30,780
is gonna be yet but two separate optical

00:31:27,880 --> 00:31:35,770
from actual bars um

00:31:30,780 --> 00:31:38,250
so step three is probably going to be so

00:31:35,770 --> 00:31:42,240
we're gonna assume still a one to one

00:31:38,250 --> 00:31:44,920
logical and actual bar oh then I think

00:31:42,240 --> 00:31:51,010
what that means is we're going to want

00:31:44,920 --> 00:31:56,740
to probably in the type checker analyze

00:31:51,010 --> 00:32:00,490
the paths that get used and create more

00:31:56,740 --> 00:32:02,890
refined borrows probably the first step

00:32:00,490 --> 00:32:09,820
is going to be I think we could probably

00:32:02,890 --> 00:32:13,120
land some kind of sort of write the code

00:32:09,820 --> 00:32:18,570
that figures out what paths should be

00:32:13,120 --> 00:32:20,820
borrowed like some unit testing of this

00:32:18,570 --> 00:32:24,550
so the idea here would be that we can

00:32:20,820 --> 00:32:26,020
have code that figures out and in fact

00:32:24,550 --> 00:32:26,290
this doesn't really depend on any of the

00:32:26,020 --> 00:32:30,030
other

00:32:26,290 --> 00:32:30,030
we're doing so this is like a separable

00:32:32,310 --> 00:32:37,330
before we go into step three we'll have

00:32:35,560 --> 00:32:39,070
to build a feature gate and stuff right

00:32:37,330 --> 00:32:41,620
because at that time we will be starting

00:32:39,070 --> 00:32:44,980
to rate the performance currently we

00:32:41,620 --> 00:32:49,050
don't have our gate good point very good

00:32:44,980 --> 00:32:57,460
point yes so that's the thing when you

00:32:49,050 --> 00:32:59,260
add feature gate yeah this so this

00:32:57,460 --> 00:33:01,240
actual change I'm proposing doesn't blow

00:32:59,260 --> 00:33:02,620
strictly speaking require a feature gate

00:33:01,240 --> 00:33:06,130
but I agree that making a future Gators

00:33:02,620 --> 00:33:07,480
it could it's time for that because now

00:33:06,130 --> 00:33:09,520
we're starting in on the feature itself

00:33:07,480 --> 00:33:10,960
and what I was going to propose here is

00:33:09,520 --> 00:33:16,210
that you would basically have something

00:33:10,960 --> 00:33:20,410
where like where you can kind of write a

00:33:16,210 --> 00:33:22,830
unit test where you you had some funny

00:33:20,410 --> 00:33:26,800
annotation like rusty underscore

00:33:22,830 --> 00:33:31,270
captured dumped on to the function on

00:33:26,800 --> 00:33:35,230
the enclosing function and then we will

00:33:31,270 --> 00:33:39,340
emit notes or errors for each closure

00:33:35,230 --> 00:33:42,760
with in describing the past that should

00:33:39,340 --> 00:33:45,910
be captured on why and so I can give you

00:33:42,760 --> 00:33:48,310
an example this is something I found to

00:33:45,910 --> 00:33:52,990
be pretty useful especially in the early

00:33:48,310 --> 00:33:55,600
stages often less so later on but it

00:33:52,990 --> 00:33:57,970
lets you kind of land PRS that have

00:33:55,600 --> 00:34:12,330
tested code without having built all the

00:33:57,970 --> 00:34:15,190
mechanism right you see so like in the I

00:34:12,330 --> 00:34:22,360
think in the NLL we do some stuff like

00:34:15,190 --> 00:34:24,750
this actually around closures where we

00:34:22,360 --> 00:34:24,750
put this

00:34:25,040 --> 00:34:31,590
right little unit tests they have a

00:34:28,350 --> 00:34:34,620
funny annotation rusty regions which

00:34:31,590 --> 00:34:36,090
itself is feature gated and any any

00:34:34,620 --> 00:34:39,210
attribute that starts with rusty is

00:34:36,090 --> 00:34:40,470
feature Gator automatically with a

00:34:39,210 --> 00:34:43,200
feature that will never be stable

00:34:40,470 --> 00:34:45,540
because it's not really meant for real

00:34:43,200 --> 00:34:48,240
rust programs to use and then it dumps

00:34:45,540 --> 00:34:49,440
it dumps this this information which the

00:34:48,240 --> 00:34:51,960
details aren't important but the key

00:34:49,440 --> 00:34:53,400
point is it's basically like a unit test

00:34:51,960 --> 00:34:55,830
right saying here's something here's

00:34:53,400 --> 00:34:59,550
some details about the closure we

00:34:55,830 --> 00:35:00,990
figured out how many external variable

00:34:59,550 --> 00:35:02,310
IDs it has and and what their

00:35:00,990 --> 00:35:06,180
relationships are and that way you can

00:35:02,310 --> 00:35:07,610
kind of check that stuff right yeah

00:35:06,180 --> 00:35:13,530
thank you

00:35:07,610 --> 00:35:14,790
and then later we would add I don't

00:35:13,530 --> 00:35:16,830
actually know the details we'll have to

00:35:14,790 --> 00:35:20,970
look more closely but we're gonna want

00:35:16,830 --> 00:35:27,480
to sort of define the or modify the off

00:35:20,970 --> 00:35:30,540
our list entries somehow to specify the

00:35:27,480 --> 00:35:36,980
path that is captured and we'll want to

00:35:30,540 --> 00:35:41,810
modify your construction to translate

00:35:36,980 --> 00:35:47,240
sort of a dot B dot C into a reference

00:35:41,810 --> 00:35:51,840
to the OP far instead of only

00:35:47,240 --> 00:35:56,870
translating okay and probably

00:35:51,840 --> 00:35:59,000
unfortunately will probably also have to

00:35:56,870 --> 00:36:01,140
there are some other bits of code that

00:35:59,000 --> 00:36:07,050
will probably also have to be changed

00:36:01,140 --> 00:36:08,580
I'm thinking of the with something

00:36:07,050 --> 00:36:11,970
called the expression use visitor which

00:36:08,580 --> 00:36:15,150
is sort of a predecessor ish to Mir it's

00:36:11,970 --> 00:36:18,060
used in the old used in the ast bar

00:36:15,150 --> 00:36:21,120
check primarily though also other places

00:36:18,060 --> 00:36:22,610
and there's like a few other bits of

00:36:21,120 --> 00:36:26,220
code that it will have to alter

00:36:22,610 --> 00:36:27,840
hopefully if we move slow enough maybe

00:36:26,220 --> 00:36:30,050
some of those codes will be factored

00:36:27,840 --> 00:36:30,050
away

00:36:32,670 --> 00:36:37,710
actually not the expression use visitor

00:36:34,710 --> 00:36:39,570
though because it's also used in closure

00:36:37,710 --> 00:36:41,930
analysis it's not going anywhere at

00:36:39,570 --> 00:36:44,540
least not for the short term but still

00:36:41,930 --> 00:36:46,470
there's some advantage to moving slow

00:36:44,540 --> 00:36:48,000
anyway but I think that's far enough

00:36:46,470 --> 00:36:50,100
away we don't have to like do in too

00:36:48,000 --> 00:36:52,980
much detail but once we do that we're

00:36:50,100 --> 00:36:58,470
basically done with versions one of the

00:36:52,980 --> 00:36:59,490
features or so maybe this becomes step

00:36:58,470 --> 00:37:10,590
four I don't know I'm sure we'll add

00:36:59,490 --> 00:37:13,680
some more steps as we go yeah a simple

00:37:10,590 --> 00:37:16,530
PR would be adding a future game I guess

00:37:13,680 --> 00:37:18,000
the main insight here is it indeed this

00:37:16,530 --> 00:37:21,120
code that figures out what path should

00:37:18,000 --> 00:37:22,470
be borrowed is something that it's kind

00:37:21,120 --> 00:37:25,770
of independent from the rest right like

00:37:22,470 --> 00:37:27,510
we can write that code and dump it out

00:37:25,770 --> 00:37:36,480
and we're just not using it for anything

00:37:27,510 --> 00:37:39,780
yet all right so you say version one so

00:37:36,480 --> 00:37:44,640
the what will be the version two on this

00:37:39,780 --> 00:37:50,550
one where did I say version one sorry no

00:37:44,640 --> 00:37:52,890
like step three is version one no you

00:37:50,550 --> 00:37:55,680
just say we will be done with the first

00:37:52,890 --> 00:38:01,410
word you know the future I think I meant

00:37:55,680 --> 00:38:05,210
the unoptimized version oh okay I see we

00:38:01,410 --> 00:38:05,210
want to think about whether to optimize

00:38:06,290 --> 00:38:13,920
and how I should add that I think

00:38:11,130 --> 00:38:16,620
figuring out the set of things that are

00:38:13,920 --> 00:38:18,990
SCAP sure it is not like super complex

00:38:16,620 --> 00:38:23,550
but not entirely trivial if I recall

00:38:18,990 --> 00:38:25,020
there's some subtle points in order to

00:38:23,550 --> 00:38:27,600
preserve execution order and stuff like

00:38:25,020 --> 00:38:28,830
that hopefully we think it's documented

00:38:27,600 --> 00:38:29,910
in the RFC more or less but that's

00:38:28,830 --> 00:38:35,370
something we're gonna have to think

00:38:29,910 --> 00:38:38,720
about okay and all right so that's

00:38:35,370 --> 00:38:41,010
that's a good overview of the whole path

00:38:38,720 --> 00:38:43,380
maybe we have a few minutes left

00:38:41,010 --> 00:38:45,720
do we want to dive into the error

00:38:43,380 --> 00:38:46,440
message stuff you were getting or are

00:38:45,720 --> 00:38:52,140
there other question

00:38:46,440 --> 00:38:55,049
on your mind yeah baby the error message

00:38:52,140 --> 00:38:57,569
because then I think we can land this

00:38:55,049 --> 00:39:00,780
Bri yeah that would be awesome

00:38:57,569 --> 00:39:08,430
freak Atlanta star okay let's look at

00:39:00,780 --> 00:39:11,490
that error message so let me first of

00:39:08,430 --> 00:39:20,130
all make a link or let me get your

00:39:11,490 --> 00:39:31,349
message so the yes okay right so the

00:39:20,130 --> 00:39:45,210
problem was that here's the test so in a

00:39:31,349 --> 00:39:53,309
test like this not clone we get this

00:39:45,210 --> 00:39:55,770
extra line in the UI right yeah so

00:39:53,309 --> 00:39:58,559
what's happening here right in

00:39:55,770 --> 00:40:01,289
particular in this UI error message you

00:39:58,559 --> 00:40:08,210
get an extra line here okay so the

00:40:01,289 --> 00:40:16,289
what's happening is as part of trait

00:40:08,210 --> 00:40:17,609
solving there's actually well well I'm

00:40:16,289 --> 00:40:20,490
just going to show you what's on master

00:40:17,609 --> 00:40:25,529
and then we can sort of hopefully you'll

00:40:20,490 --> 00:40:30,049
be able to see what's different let's

00:40:25,529 --> 00:40:34,319
see so there's this function called

00:40:30,049 --> 00:40:39,109
constituent types for tie so let's see

00:40:34,319 --> 00:40:39,109
as an extra line in the branch

00:40:39,610 --> 00:40:51,760
but the context is in selected I rest

00:40:44,950 --> 00:40:56,510
constituent types for pi so this

00:40:51,760 --> 00:40:58,820
function what it does is it it's used

00:40:56,510 --> 00:41:02,300
for auto traits and it basically takes a

00:40:58,820 --> 00:41:04,160
type and gives you the Constituent types

00:41:02,300 --> 00:41:05,630
of things that are inside of it like for

00:41:04,160 --> 00:41:07,490
a struct it would be all of its fields

00:41:05,630 --> 00:41:08,900
for something like a you enter in

00:41:07,490 --> 00:41:14,900
there's nothing inside of it so it's

00:41:08,900 --> 00:41:17,360
just an empty vector and the idea is you

00:41:14,900 --> 00:41:19,490
know for an auto trait something is send

00:41:17,360 --> 00:41:21,230
for example if all of its constituent

00:41:19,490 --> 00:41:24,470
types are sin all right and so for a

00:41:21,230 --> 00:41:26,900
tuple it's just gonna be the list of

00:41:24,470 --> 00:41:27,500
stuff inside of it and here's the change

00:41:26,900 --> 00:41:30,980
we made

00:41:27,500 --> 00:41:36,820
right because today for a closure it

00:41:30,980 --> 00:41:43,390
directly returns a vector of the

00:41:36,820 --> 00:41:47,870
captured up var types right so today

00:41:43,390 --> 00:41:51,740
they for a closure for a closure let's

00:41:47,870 --> 00:41:58,330
call it C you get back a vector like u 1

00:41:51,740 --> 00:42:03,380
u 2 u 3 of the up four types right and

00:41:58,330 --> 00:42:08,590
in your branch of the branch if I guess

00:42:03,380 --> 00:42:16,460
you get back a vector u of the up for

00:42:08,590 --> 00:42:24,250
bull-type right and then we will break

00:42:16,460 --> 00:42:27,980
that tuple into its constituents right

00:42:24,250 --> 00:42:30,610
and this is exactly what's so as it

00:42:27,980 --> 00:42:37,130
happens the error message kind of tracks

00:42:30,610 --> 00:42:39,710
this each step that we have to expand

00:42:37,130 --> 00:42:41,810
like this gets tracked and then that's

00:42:39,710 --> 00:42:45,350
how we generate that dump that says like

00:42:41,810 --> 00:42:50,060
in the type such thing we did something

00:42:45,350 --> 00:42:52,000
else hold on actually I have the output

00:42:50,060 --> 00:42:54,200
here

00:42:52,000 --> 00:42:57,410
[Music]

00:42:54,200 --> 00:43:00,150
right this is from your message on Zulu

00:42:57,410 --> 00:43:01,530
so the each of these lines comes from

00:43:00,150 --> 00:43:03,210
from one of those steps so that's why

00:43:01,530 --> 00:43:06,780
you're seeing an extra line basically we

00:43:03,210 --> 00:43:10,290
added an extra step and I see two

00:43:06,780 --> 00:43:13,470
options how to fix this I'm not actually

00:43:10,290 --> 00:43:16,500
sure which one I like better option

00:43:13,470 --> 00:43:19,650
number one would be that we we modify

00:43:16,500 --> 00:43:21,320
this line in your branch to kind of do

00:43:19,650 --> 00:43:24,930
something more like the current behavior

00:43:21,320 --> 00:43:29,400
so you could imagine saying instead of

00:43:24,930 --> 00:43:33,660
just returning the OP particle tie we

00:43:29,400 --> 00:43:37,099
could inspect it if it is known to be a

00:43:33,660 --> 00:43:39,690
tuple you just returned its contents

00:43:37,099 --> 00:43:42,480
else we returned the two bullet

00:43:39,690 --> 00:43:43,770
the problem with that is besides being

00:43:42,480 --> 00:43:49,650
complicated I'm a little bit nervous

00:43:43,770 --> 00:43:51,869
that something weird will happen

00:43:49,650 --> 00:43:53,910
basically like having a consistent

00:43:51,869 --> 00:43:56,790
return type from that function seems

00:43:53,910 --> 00:43:58,560
better than inspecting especially

00:43:56,790 --> 00:44:03,180
inspecting the state of inference is

00:43:58,560 --> 00:44:08,220
very fragile okay so another option is

00:44:03,180 --> 00:44:14,609
to suppress this in the sort of print

00:44:08,220 --> 00:44:17,420
out right I think and that I feel a

00:44:14,609 --> 00:44:21,450
little bit this seems maybe better

00:44:17,420 --> 00:44:27,510
because it's less steep the question is

00:44:21,450 --> 00:44:28,440
exactly how to do it so let's see what

00:44:27,510 --> 00:44:30,859
happens today

00:44:28,440 --> 00:44:34,260
let me show you a little bit more detail

00:44:30,859 --> 00:44:39,030
where that tracing mechanism comes into

00:44:34,260 --> 00:44:42,180
play so each time we have to prove

00:44:39,030 --> 00:44:45,810
something we have something called a

00:44:42,180 --> 00:44:48,810
cause it so like if we have to prove

00:44:45,810 --> 00:44:50,550
that something is send will have a cause

00:44:48,810 --> 00:44:53,010
saying why maybe because we called

00:44:50,550 --> 00:44:56,760
another function or whatever and there's

00:44:53,010 --> 00:45:00,980
inside this cause there's a code which

00:44:56,760 --> 00:45:00,980
is the obligation cause code

00:45:01,950 --> 00:45:07,950
and one of the there's a lot of stuff in

00:45:05,880 --> 00:45:10,470
here different reasons we have to prove

00:45:07,950 --> 00:45:16,910
things which we use for error messages

00:45:10,470 --> 00:45:21,859
but one of them somewhere where is it

00:45:16,910 --> 00:45:27,840
it's probably this one let's see derived

00:45:21,859 --> 00:45:29,970
obligation cause yeah I think this is it

00:45:27,840 --> 00:45:32,430
so I think this is where we build up a

00:45:29,970 --> 00:45:38,310
little chain that'll have these things

00:45:32,430 --> 00:45:40,650
saying like I had to prove I had it's

00:45:38,310 --> 00:45:42,630
kind of just making a little linked list

00:45:40,650 --> 00:45:44,630
of the types that that I had to prove

00:45:42,630 --> 00:45:46,740
and then when you see this error message

00:45:44,630 --> 00:45:51,440
we're actually iterating through that

00:45:46,740 --> 00:45:55,290
linked list going going through the

00:45:51,440 --> 00:45:57,810
parent codes so if I jump to the

00:45:55,290 --> 00:46:00,420
Diagnostics file and have I'm gonna have

00:45:57,810 --> 00:46:03,900
to end this call in a minute or not

00:46:00,420 --> 00:46:09,920
quite yet just over a few minutes um the

00:46:03,900 --> 00:46:16,160
I think and did I schedule everything

00:46:09,920 --> 00:46:19,200
there's so many schedules sometimes I

00:46:16,160 --> 00:46:23,790
just heard some calendar notification

00:46:19,200 --> 00:46:28,320
but it was for something else so let's

00:46:23,790 --> 00:46:31,109
see Bates

00:46:28,320 --> 00:46:33,020
where is it it's called error reporting

00:46:31,109 --> 00:46:35,540
that's what it is so in the Train error

00:46:33,020 --> 00:46:39,320
reporting code

00:46:35,540 --> 00:46:41,820
let's see required because it appears

00:46:39,320 --> 00:46:46,200
right so when we see a built in derived

00:46:41,820 --> 00:46:48,840
obligation we kind of get the parent we

00:46:46,200 --> 00:46:50,210
dump some information about the self

00:46:48,840 --> 00:46:56,910
type of the parent and then we

00:46:50,210 --> 00:46:59,670
recursively process the thing in the

00:46:56,910 --> 00:47:07,559
list so maybe what we can do is just add

00:46:59,670 --> 00:47:10,839
some it's a little bit tricky so

00:47:07,559 --> 00:47:13,359
you could look I can see I guess I can

00:47:10,839 --> 00:47:15,819
see two ways to combat this either when

00:47:13,359 --> 00:47:18,039
we add a link when we're when we're in a

00:47:15,819 --> 00:47:22,689
closure type we kind of suppress that

00:47:18,039 --> 00:47:24,219
link in the stage or something off to

00:47:22,689 --> 00:47:25,599
look where these actually get created

00:47:24,219 --> 00:47:27,249
but basically so that we create a

00:47:25,599 --> 00:47:31,150
shorter chain that doesn't include the

00:47:27,249 --> 00:47:32,799
tuple type and then that we could

00:47:31,150 --> 00:47:35,829
probably do with relative ease actually

00:47:32,799 --> 00:47:38,799
that's probably the way to go um that's

00:47:35,829 --> 00:47:41,469
just better but either we do it that way

00:47:38,799 --> 00:47:43,749
or we somehow add a field or something

00:47:41,469 --> 00:47:46,269
so that we know in this code to ignore

00:47:43,749 --> 00:47:47,890
that link in the chain all right but I

00:47:46,269 --> 00:47:52,419
feel like if we can add some way to note

00:47:47,890 --> 00:47:55,449
to ignore it then we could also just not

00:47:52,419 --> 00:47:56,949
create it I guess I guess what we could

00:47:55,449 --> 00:47:59,019
do in this code for example is you could

00:47:56,949 --> 00:48:02,469
look and you could say oh if I'm looking

00:47:59,019 --> 00:48:06,160
at a tuple and its parent is a closure

00:48:02,469 --> 00:48:08,650
I won't print it right that would be

00:48:06,160 --> 00:48:12,849
alright very a very local change it

00:48:08,650 --> 00:48:26,039
feels a little like a little hacky I

00:48:12,849 --> 00:48:29,529
would sort of rather not what is that oh

00:48:26,039 --> 00:48:34,479
no I was just saying that if the closure

00:48:29,529 --> 00:48:37,989
takes in a legitimate couple then that

00:48:34,479 --> 00:48:44,409
case not interfere with our if statement

00:48:37,989 --> 00:48:46,569
ah oh it should be okay because because

00:48:44,409 --> 00:48:50,039
right now it happens so right now what

00:48:46,569 --> 00:48:55,739
happens is that you have a closure

00:48:50,039 --> 00:48:59,859
it always has a tuple of up FAR's

00:48:55,739 --> 00:49:01,479
leg and then if there's one of those up

00:48:59,859 --> 00:49:04,209
FAR's is a tuple then it would have a

00:49:01,479 --> 00:49:05,999
tuple which is the individual of our

00:49:04,209 --> 00:49:08,679
right and so when we go to print the

00:49:05,999 --> 00:49:11,529
okay its first tuple its parent is not a

00:49:08,679 --> 00:49:12,849
closure it's another tuple right but it

00:49:11,529 --> 00:49:14,890
still feels kind of hacky thing cuz

00:49:12,849 --> 00:49:17,949
we're changing these two parts of the

00:49:14,890 --> 00:49:18,880
code there's obviously no you know it's

00:49:17,949 --> 00:49:20,370
kind of a don't repeat yourself

00:49:18,880 --> 00:49:23,320
violation

00:49:20,370 --> 00:49:24,970
if we if we then change again the

00:49:23,320 --> 00:49:26,560
constituent types function then this

00:49:24,970 --> 00:49:29,920
code is now wrong with there's no reason

00:49:26,560 --> 00:49:35,050
to so it's sort of rather if we can make

00:49:29,920 --> 00:49:36,490
it more local but let's see where does

00:49:35,050 --> 00:49:40,210
that actually happen it's probably not

00:49:36,490 --> 00:49:51,240
too hard hold on so I think I think what

00:49:40,210 --> 00:49:54,040
happens let's see Constituent yeah so

00:49:51,240 --> 00:49:57,490
you see so this what this function here

00:49:54,040 --> 00:50:06,130
is doing confirm Auto imple candidate is

00:49:57,490 --> 00:50:10,780
saying given let's see I'm just gonna

00:50:06,130 --> 00:50:15,790
leave a few notes here I guess we have

00:50:10,780 --> 00:50:17,590
the video open anyway given given that

00:50:15,790 --> 00:50:19,440
you know like given that you're proving

00:50:17,590 --> 00:50:25,090
[Music]

00:50:19,440 --> 00:50:27,310
sort of t send greater returns it

00:50:25,090 --> 00:50:30,090
returns a list among other things of

00:50:27,310 --> 00:50:34,180
other things you have to prove right

00:50:30,090 --> 00:50:40,690
which might be like if T happens to be

00:50:34,180 --> 00:50:44,650
let's call it t you send eg he send you

00:50:40,690 --> 00:50:46,750
send right so it's gonna kind of and it

00:50:44,650 --> 00:50:48,760
and it calls constituent types for tight

00:50:46,750 --> 00:50:55,630
to do that and then it calls v table

00:50:48,760 --> 00:50:59,080
Auto imple which which does some stuff

00:50:55,630 --> 00:51:00,820
and this is the key line okay this part

00:50:59,080 --> 00:51:03,550
is not important this is building up the

00:51:00,820 --> 00:51:05,860
traits it's like taking the types and

00:51:03,550 --> 00:51:09,750
putting them into the trade itself but

00:51:05,860 --> 00:51:11,830
this line obligation dot derived cause

00:51:09,750 --> 00:51:18,910
that's interesting that we get imple

00:51:11,830 --> 00:51:20,230
derived obligation sorry hold on a

00:51:18,910 --> 00:51:23,370
minute let me look a little more closely

00:51:20,230 --> 00:51:26,520
yeah no problem

00:51:23,370 --> 00:51:26,520
[Music]

00:51:28,410 --> 00:51:35,830
no no I think this is wrong this is the

00:51:31,090 --> 00:51:39,280
line obligation derive cause built-in

00:51:35,830 --> 00:51:40,990
derived obligation oh this line is where

00:51:39,280 --> 00:51:43,690
we're actually making that chain I was

00:51:40,990 --> 00:51:48,190
talking about I see

00:51:43,690 --> 00:51:51,300
and so what we might do here we could

00:51:48,190 --> 00:51:56,560
instead sort of say if this is a closure

00:51:51,300 --> 00:52:01,200
then don't use the derived cause but

00:51:56,560 --> 00:52:01,200
instead use like obligation Clause clone

00:52:01,830 --> 00:52:14,950
okay so could check here and say make

00:52:08,950 --> 00:52:20,700
sure this is a permalink if this is a

00:52:14,950 --> 00:52:27,070
derive if the self type is a closure

00:52:20,700 --> 00:52:30,630
don't don't make a derived up with the

00:52:27,070 --> 00:52:34,510
right cause but just use obligation

00:52:30,630 --> 00:52:36,610
column we could make it maybe even a

00:52:34,510 --> 00:52:40,120
little less a little more local by

00:52:36,610 --> 00:52:42,880
saying that maybe the return type of

00:52:40,120 --> 00:52:45,130
constituent types for tie instead of

00:52:42,880 --> 00:52:47,890
hard-coding that it's a closure you

00:52:45,130 --> 00:52:51,520
could say or maybe make its that you

00:52:47,890 --> 00:52:57,040
went I can't spell that word apparently

00:52:51,520 --> 00:52:59,830
one statue and pipes for a tie return

00:52:57,040 --> 00:53:03,040
sort of a vector and a boolean or

00:52:59,830 --> 00:53:06,580
something where the boolean means you

00:53:03,040 --> 00:53:09,730
know make derived cause and that way we

00:53:06,580 --> 00:53:11,020
only we would literally change you know

00:53:09,730 --> 00:53:14,500
we're putting all the decision in that

00:53:11,020 --> 00:53:17,050
one function which feels good um so I

00:53:14,500 --> 00:53:19,720
think that's what I would do okay

00:53:17,050 --> 00:53:25,060
and this line you can leave alone what

00:53:19,720 --> 00:53:27,190
this is saying is it's going and this is

00:53:25,060 --> 00:53:29,230
this line is making this the sub

00:53:27,190 --> 00:53:31,990
obligations based on the type and this

00:53:29,230 --> 00:53:33,550
is making other obligations based on the

00:53:31,990 --> 00:53:34,780
trait like if the trait has super

00:53:33,550 --> 00:53:36,460
predicates or something like that which

00:53:34,780 --> 00:53:38,500
actually are illegal now this is

00:53:36,460 --> 00:53:39,630
probably no up anyway but it's a

00:53:38,500 --> 00:53:43,770
different thing

00:53:39,630 --> 00:53:46,380
different different it's not gonna

00:53:43,770 --> 00:53:48,000
reveal the presence of this tuple so

00:53:46,380 --> 00:53:49,770
yeah so that's what I would do I think

00:53:48,000 --> 00:53:52,880
that's the right strategy we'll see what

00:53:49,770 --> 00:53:52,880
happens but I think that will be good

00:53:53,270 --> 00:54:05,220
sound good yeah yeah hey this was fun

00:54:02,370 --> 00:54:10,530
so I guess what we'll do overall you'll

00:54:05,220 --> 00:54:11,760
try that out we can pull this list here

00:54:10,530 --> 00:54:13,740
I mean I guess I can just move the

00:54:11,760 --> 00:54:15,810
heading down this is kind of our roadmap

00:54:13,740 --> 00:54:17,070
and then when next time we talk we kind

00:54:15,810 --> 00:54:18,960
of already know the plan we can figure

00:54:17,070 --> 00:54:23,450
out the next step but it seems like

00:54:18,960 --> 00:54:23,450
maybe this could be on this is a

00:54:23,810 --> 00:54:30,290
something I can do it's not too hard oh

00:54:33,380 --> 00:54:37,020
wait I remember now

00:54:35,190 --> 00:54:45,960
there's some way of tracking this

00:54:37,020 --> 00:54:51,450
section hold on a second okay I'll

00:54:45,960 --> 00:54:54,630
assign that to myself and you're going

00:54:51,450 --> 00:54:55,920
to change the type check to actually

00:54:54,630 --> 00:55:04,380
generate a tuple this is what you're

00:54:55,920 --> 00:55:08,960
basically doing fix the I got to make it

00:55:04,380 --> 00:55:11,330
all look pretty I can add your help okay

00:55:08,960 --> 00:55:13,890
great

00:55:11,330 --> 00:55:17,870
now we don't need to use this double

00:55:13,890 --> 00:55:22,440
strikethrough I guess in a particular

00:55:17,870 --> 00:55:28,920
fix the error messages around trade

00:55:22,440 --> 00:55:34,080
selection right which one is you this

00:55:28,920 --> 00:55:36,150
must be you okay all right cool then we

00:55:34,080 --> 00:55:37,770
have a plan see you later

00:55:36,150 --> 00:55:39,240
but by the way what time zone are you

00:55:37,770 --> 00:55:47,220
still in this time zone you're in it

00:55:39,240 --> 00:55:47,910
also next week yeah I'll get back March

00:55:47,220 --> 00:55:51,180
15th

00:55:47,910 --> 00:55:55,120
ok cool

00:55:51,180 --> 00:55:59,230
well maybe we'll meet again at this time

00:55:55,120 --> 00:56:02,470
oh yeah that works for you we'll talk

00:55:59,230 --> 00:56:05,110
about owns it yeah see you later sounds

00:56:02,470 --> 00:56:09,210
good all right see you later for your

00:56:05,110 --> 00:56:09,210

YouTube URL: https://www.youtube.com/watch?v=UTXOptVMuIc


