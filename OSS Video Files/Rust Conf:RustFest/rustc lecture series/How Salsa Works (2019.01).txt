Title: How Salsa Works (2019.01)
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	The Dropbox Paper has been converted to a gist here:

https://gist.github.com/nikomatsakis/0bd497f157a40776216f37d8bbec25cd

Or, if you prefer, you can view the original document here (but it will record your e-mail, I believe):

https://paper.dropbox.com/doc/How-Salsa-Works-2019.01--AWnkDrrWoSyv0yfTleFeyGElAg-u8rQGbebYIxSA8r23muiN
Captions: 
	00:00:03,940 --> 00:00:10,790
hello so I'd like to welcome you to this

00:00:09,290 --> 00:00:14,420
little video we're gonna be talking

00:00:10,790 --> 00:00:16,250
about how salsa works and I'm gonna be

00:00:14,420 --> 00:00:19,099
doing this by working in this Dropbox

00:00:16,250 --> 00:00:21,349
paper document the URL for which I'll

00:00:19,099 --> 00:00:23,300
post with the video you can come later

00:00:21,349 --> 00:00:27,409
kind of look at it if you like

00:00:23,300 --> 00:00:30,560
so let's start with the first question

00:00:27,409 --> 00:00:32,750
what is salsa anyway

00:00:30,560 --> 00:00:35,660
it's also the libraries for incremental

00:00:32,750 --> 00:00:37,400
recomputation and what I mean by that is

00:00:35,660 --> 00:00:41,390
basically imagine you have some function

00:00:37,400 --> 00:00:43,430
like we'll call it through various and

00:00:41,390 --> 00:00:45,770
it has that's like two inputs and it

00:00:43,430 --> 00:00:50,810
produces an output these types they

00:00:45,770 --> 00:00:52,520
might be and then the idea is well in

00:00:50,810 --> 00:00:56,660
some part of your code you invoke this

00:00:52,520 --> 00:00:59,660
function with one input and then later

00:00:56,660 --> 00:01:01,670
you invoke it again but with slightly

00:00:59,660 --> 00:01:03,829
different set of inputs and ei is this

00:01:01,670 --> 00:01:05,720
thing the PS change we would like to

00:01:03,829 --> 00:01:09,320
make this more efficient we'd like to

00:01:05,720 --> 00:01:11,930
reuse some of the intermediate values

00:01:09,320 --> 00:01:15,770
that you did right in the first of all

00:01:11,930 --> 00:01:19,190
and that's the basic idea of salsa is

00:01:15,770 --> 00:01:20,600
how to make this kind of automatic and

00:01:19,190 --> 00:01:22,100
what I mean by that is you will reuse

00:01:20,600 --> 00:01:23,990
automatically I don't necessarily mean

00:01:22,100 --> 00:01:25,490
that you'll get really good news that

00:01:23,990 --> 00:01:27,470
requires really fishy to me

00:01:25,490 --> 00:01:31,490
but we will be use automatically and

00:01:27,470 --> 00:01:33,770
sound or correct by that I mean you get

00:01:31,490 --> 00:01:37,430
the same result essentially as if we

00:01:33,770 --> 00:01:43,310
didn't do any who used at all how's that

00:01:37,430 --> 00:01:46,310
so cool that's what sells there is no so

00:01:43,310 --> 00:01:48,229
salsas actual model doesn't isn't like a

00:01:46,310 --> 00:01:50,900
random function like through it's

00:01:48,229 --> 00:01:52,549
actually some easting and all much more

00:01:50,900 --> 00:01:56,299
complicated cases right so imagine you

00:01:52,549 --> 00:01:58,939
have like an IDE in that case you might

00:01:56,299 --> 00:02:02,630
have the inputs might be something like

00:01:58,939 --> 00:02:04,939
a manifest you can think of my card with

00:02:02,630 --> 00:02:09,200
optimal file the data inside that may be

00:02:04,939 --> 00:02:10,759
as well as the sources the source files

00:02:09,200 --> 00:02:15,530
in their text right will not be like

00:02:10,759 --> 00:02:17,250
okay food LRS has contents food on our

00:02:15,530 --> 00:02:19,350
essence

00:02:17,250 --> 00:02:21,150
and the outputs well there's a lot of

00:02:19,350 --> 00:02:23,220
possible outputs but one might be the

00:02:21,150 --> 00:02:26,040
actual like binary executable between

00:02:23,220 --> 00:02:28,560
Mantovani but you might also have things

00:02:26,040 --> 00:02:31,260
like what are the completions at this

00:02:28,560 --> 00:02:34,950
point or what is the type or what what

00:02:31,260 --> 00:02:39,420
should I show the user when the mouse is

00:02:34,950 --> 00:02:41,370
hovering on this line that sort of thing

00:02:39,420 --> 00:02:46,020
so there's a kind of rich set of inputs

00:02:41,370 --> 00:02:47,640
and outputs not a single function and

00:02:46,020 --> 00:02:53,040
that's that's kind of more the model

00:02:47,640 --> 00:02:54,390
that software is is working in right so

00:02:53,040 --> 00:02:56,310
let's give it a kind of high level idea

00:02:54,390 --> 00:02:59,390
so how does it work is that kind of high

00:02:56,310 --> 00:03:02,640
level view from house also works well

00:02:59,390 --> 00:03:04,560
you're going to identify but the first

00:03:02,640 --> 00:03:06,650
thing is you have you have to identify

00:03:04,560 --> 00:03:14,910
for yourself those inputs and outputs

00:03:06,650 --> 00:03:16,650
that you want right and when we well

00:03:14,910 --> 00:03:17,130
rather you identify the inputs later

00:03:16,650 --> 00:03:18,690
like that

00:03:17,130 --> 00:03:22,320
it's probably the base inputs to your

00:03:18,690 --> 00:03:23,520
computation and the main thing here is

00:03:22,320 --> 00:03:24,810
that they are not something which you

00:03:23,520 --> 00:03:28,080
compute there are something that you

00:03:24,810 --> 00:03:29,730
kind of gets at from the outside you get

00:03:28,080 --> 00:03:36,110
given them and then you have these

00:03:29,730 --> 00:03:38,670
things with a kind of derived values and

00:03:36,110 --> 00:03:41,120
derived values are basically some

00:03:38,670 --> 00:03:44,760
deterministic you're gonna give a

00:03:41,120 --> 00:03:49,500
deterministic and a pure function from

00:03:44,760 --> 00:03:51,840
the from the inputs to that computes

00:03:49,500 --> 00:03:53,730
them right and this this function will

00:03:51,840 --> 00:03:55,680
take we'll start with some of the inputs

00:03:53,730 --> 00:03:57,570
and produce the outputs so these divided

00:03:55,680 --> 00:03:59,100
values they might be you know at the

00:03:57,570 --> 00:04:00,870
very limit they'll be things like what

00:03:59,100 --> 00:04:03,000
are the completions at this point but

00:04:00,870 --> 00:04:05,130
there might be intermediate steps though

00:04:03,000 --> 00:04:07,980
let me give you so if we come back to

00:04:05,130 --> 00:04:10,920
our up to our IDE example if the inputs

00:04:07,980 --> 00:04:13,530
are things like the source text the

00:04:10,920 --> 00:04:15,720
manifest what's the source cuts and some

00:04:13,530 --> 00:04:19,020
derived values might be like for each

00:04:15,720 --> 00:04:24,330
source file X you might have a derived

00:04:19,020 --> 00:04:26,070
value the ast for X right and so

00:04:24,330 --> 00:04:29,610
actually we're gonna stress the manifest

00:04:26,070 --> 00:04:30,030
here is like think of these like a label

00:04:29,610 --> 00:04:31,800
and

00:04:30,030 --> 00:04:36,060
maybe some some inputs right so the

00:04:31,800 --> 00:04:38,310
source fax might be like kind of giving

00:04:36,060 --> 00:04:40,110
the source text for some path X and the

00:04:38,310 --> 00:04:41,610
manifest just to keep it simple

00:04:40,110 --> 00:04:47,580
maybe the manifest actually gives you

00:04:41,610 --> 00:04:50,790
back like a vector of of paths and the

00:04:47,580 --> 00:04:52,820
source text would be like path X I look

00:04:50,790 --> 00:04:54,810
give you back a string that's they

00:04:52,820 --> 00:04:58,520
that's kind of how these are gonna look

00:04:54,810 --> 00:04:58,520
for me when she get to meet with us

00:05:00,980 --> 00:05:08,640
so our ast might be something like X the

00:05:05,250 --> 00:05:11,940
same path and it's going to give us an

00:05:08,640 --> 00:05:13,740
ast whatever that is and so an ast is

00:05:11,940 --> 00:05:15,360
not like a final output that's the

00:05:13,740 --> 00:05:18,600
meaning it's an intermediate value that

00:05:15,360 --> 00:05:21,930
we could use right to do our computation

00:05:18,600 --> 00:05:30,120
and eventually we'll have something like

00:05:21,930 --> 00:05:35,420
the completion at line number and this

00:05:30,120 --> 00:05:42,320
would be like this would be like if you

00:05:35,420 --> 00:05:45,540
what what the IDE should show and so

00:05:42,320 --> 00:05:47,570
what's going to happen is us when you go

00:05:45,540 --> 00:05:49,470
to execute say what is the completion

00:05:47,570 --> 00:05:51,360
we're gonna see that it's going to

00:05:49,470 --> 00:05:53,220
compute variants derived values as if

00:05:51,360 --> 00:05:54,630
those intermediate values and eventually

00:05:53,220 --> 00:05:57,090
read from the inputs to produce the

00:05:54,630 --> 00:06:00,090
result and also the framework is going

00:05:57,090 --> 00:06:05,520
to track but in the course of computing

00:06:00,090 --> 00:06:09,390
say the ast for a given path will track

00:06:05,520 --> 00:06:13,860
which inputs did we access which derived

00:06:09,390 --> 00:06:16,170
values and we'll use that later to

00:06:13,860 --> 00:06:18,210
figure out what should happen when the

00:06:16,170 --> 00:06:22,260
inputs change right so when an input

00:06:18,210 --> 00:06:24,230
changes you can say these values these

00:06:22,260 --> 00:06:28,770
derived values are still valid because

00:06:24,230 --> 00:06:32,930
the inputs that they touch changed well

00:06:28,770 --> 00:06:35,460
maybe these drive values may be invalid

00:06:32,930 --> 00:06:37,110
because some of their inputs change and

00:06:35,460 --> 00:06:39,450
we'll see that actually we're a little

00:06:37,110 --> 00:06:41,970
bit smarter than this might suggest so

00:06:39,450 --> 00:06:44,220
it doesn't just figure out everything

00:06:41,970 --> 00:06:45,870
that's sort of downstream

00:06:44,220 --> 00:06:47,040
from a change what does that would

00:06:45,870 --> 00:06:48,990
usually be quite a lot of your

00:06:47,040 --> 00:06:52,170
computation we can actually do somewhat

00:06:48,990 --> 00:06:54,740
better than that um no but but basically

00:06:52,170 --> 00:06:56,640
that the model you should I think mono

00:06:54,740 --> 00:06:59,730
useful to have in your head is there's

00:06:56,640 --> 00:07:02,040
the kind of graph so we might have we

00:06:59,730 --> 00:07:08,000
have our inputs on one side right so

00:07:02,040 --> 00:07:10,650
let's say something like this and then

00:07:08,000 --> 00:07:12,180
these are these are like we call these

00:07:10,650 --> 00:07:15,930
queries these even know it's in the back

00:07:12,180 --> 00:07:20,930
and then when you have a derived query

00:07:15,930 --> 00:07:24,000
so something like AST edges this way

00:07:20,930 --> 00:07:25,350
these become also nodes in there so what

00:07:24,000 --> 00:07:28,380
we're saying here is when I'm computing

00:07:25,350 --> 00:07:33,630
the ast for a given path I need to know

00:07:28,380 --> 00:07:35,520
the I have to use the source text to do

00:07:33,630 --> 00:07:37,140
it and then on both the parser I may be

00:07:35,520 --> 00:07:39,060
computing the ast is just running the

00:07:37,140 --> 00:07:43,070
parser on one file it doesn't need any

00:07:39,060 --> 00:07:47,190
other input than the source tags um but

00:07:43,070 --> 00:07:48,960
when but how do we know so the whole

00:07:47,190 --> 00:07:50,640
this is all in the context of some

00:07:48,960 --> 00:07:55,350
compilation like so somewhere there'll

00:07:50,640 --> 00:07:56,580
be some sort of some root thing that

00:07:55,350 --> 00:07:59,850
we're trying to do and this is kind of

00:07:56,580 --> 00:08:02,820
that function foo I was button in this

00:07:59,850 --> 00:08:07,710
compilation maybe this is going to read

00:08:02,820 --> 00:08:11,729
from the manifest to start and it's also

00:08:07,710 --> 00:08:13,770
going to read like you know from each of

00:08:11,729 --> 00:08:17,280
these once it reads from the manifest

00:08:13,770 --> 00:08:20,310
it's going to go access we are gonna go

00:08:17,280 --> 00:08:22,830
read the ast es of all the inputs right

00:08:20,310 --> 00:08:25,590
and so forth actually personally a lot

00:08:22,830 --> 00:08:27,240
of other values between these two is to

00:08:25,590 --> 00:08:29,880
say that the role compilation is just a

00:08:27,240 --> 00:08:34,200
purse maybe we can rename this to them

00:08:29,880 --> 00:08:36,900
first everything so now we have kind of

00:08:34,200 --> 00:08:38,940
our base inputs the manifests the source

00:08:36,900 --> 00:08:40,979
text so I stack these are our basic

00:08:38,940 --> 00:08:43,830
words we have some intermediate derived

00:08:40,979 --> 00:08:45,960
values and then we have this goal here

00:08:43,830 --> 00:08:48,540
parse everything but maybe we'll call it

00:08:45,960 --> 00:08:49,950
whole program ast this was fun and we'll

00:08:48,540 --> 00:08:52,260
say the whole program has to do all the

00:08:49,950 --> 00:08:53,760
assets for each file compacted and in

00:08:52,260 --> 00:08:56,310
order to conclude that we had to access

00:08:53,760 --> 00:08:57,660
the name Fest we had to access the SD

00:08:56,310 --> 00:08:59,760
for each individual file

00:08:57,660 --> 00:09:02,220
and then we gave out of the salt well

00:08:59,760 --> 00:09:05,490
maybe this winds up being computed part

00:09:02,220 --> 00:09:08,000
I was like typing or something actually

00:09:05,490 --> 00:09:12,000
this wouldn't be a very good structure

00:09:08,000 --> 00:09:15,330
and so now what if we have this graph if

00:09:12,000 --> 00:09:17,220
we see a change like the source x then

00:09:15,330 --> 00:09:18,990
we can easily see okay if you change a

00:09:17,220 --> 00:09:21,060
dot RS that's going to potentially

00:09:18,990 --> 00:09:22,920
affect the ISTE that will in turn

00:09:21,060 --> 00:09:24,690
potentially affect the whole program

00:09:22,920 --> 00:09:26,370
which would mean type checking all these

00:09:24,690 --> 00:09:28,260
results are invalidated

00:09:26,370 --> 00:09:35,820
but the AAS teams from the other files

00:09:28,260 --> 00:09:37,650
they're just fun and one of the magic is

00:09:35,820 --> 00:09:40,850
actually stop with propagation a little

00:09:37,650 --> 00:09:43,470
bit early in something so imagine that

00:09:40,850 --> 00:09:46,290
although we see that like this roll path

00:09:43,470 --> 00:09:51,570
is potentially effective this will pass

00:09:46,290 --> 00:09:53,490
here we might also see that after me run

00:09:51,570 --> 00:09:55,950
the part so you end up with the same ASD

00:09:53,490 --> 00:09:57,390
we got the time before and so maybe all

00:09:55,950 --> 00:09:59,190
they did was add some spaces and that

00:09:57,390 --> 00:10:01,590
doesn't affect the ASD but then all

00:09:59,190 --> 00:10:04,230
those sorts of extremes the ast scale is

00:10:01,590 --> 00:10:06,870
C so then we can wind up keeping these

00:10:04,230 --> 00:10:08,610
values because we say their direct

00:10:06,870 --> 00:10:10,140
influence did not change even though

00:10:08,610 --> 00:10:11,880
some of their like indirect influence

00:10:10,140 --> 00:10:13,640
happened but it didn't make any

00:10:11,880 --> 00:10:16,620
difference

00:10:13,640 --> 00:10:20,460
well come back here that's a pretty

00:10:16,620 --> 00:10:23,910
important thing so all right let's go

00:10:20,460 --> 00:10:30,420
just a little bit I'm going to talk now

00:10:23,910 --> 00:10:32,970
about the idea of I'm sure I'm gonna

00:10:30,420 --> 00:10:36,150
show you how these salsa concepts for

00:10:32,970 --> 00:10:40,230
time factors so there's a theme te he

00:10:36,150 --> 00:10:46,050
contracted to keep in mind the first

00:10:40,230 --> 00:10:48,240
thing is something called a query and

00:10:46,050 --> 00:10:49,800
the query we've actually been looking at

00:10:48,240 --> 00:10:55,740
queries at all times so when I write

00:10:49,800 --> 00:11:01,890
like manifest this is an input there and

00:10:55,740 --> 00:11:05,010
when I write whole program ast this is a

00:11:01,890 --> 00:11:09,150
derived where both of these queries have

00:11:05,010 --> 00:11:11,640
a query basically some value that we

00:11:09,150 --> 00:11:13,680
access in the course about

00:11:11,640 --> 00:11:15,600
maybe something you compute for a

00:11:13,680 --> 00:11:18,029
drive-through or something we didn't

00:11:15,600 --> 00:11:20,040
agree and queries in general have some

00:11:18,029 --> 00:11:24,540
number of keys both of these have zero

00:11:20,040 --> 00:11:29,519
keys but something like sois text that

00:11:24,540 --> 00:11:32,040
had one that had one gene which was the

00:11:29,519 --> 00:11:35,160
path and all queries right initially

00:11:32,040 --> 00:11:36,870
have a result site right so they're kind

00:11:35,160 --> 00:11:42,450
of a function so this would be like a

00:11:36,870 --> 00:11:46,290
manifest this might be a st source text

00:11:42,450 --> 00:11:48,180
I think you said it's a string and yes

00:11:46,290 --> 00:11:52,019
that's just for completeness we'll throw

00:11:48,180 --> 00:11:54,680
in a sta also the AST these are either

00:11:52,019 --> 00:11:57,300
drive phrases one input and one output

00:11:54,680 --> 00:11:59,610
you always have one output you can have

00:11:57,300 --> 00:12:00,959
any number of engines and so you don't

00:11:59,610 --> 00:12:03,839
have any good examples here but you can

00:12:00,959 --> 00:12:06,750
have a query that's like that takes two

00:12:03,839 --> 00:12:09,990
integers and now it kind of has two keys

00:12:06,750 --> 00:12:16,920
or you can think of it is yes one tuple

00:12:09,990 --> 00:12:20,850
as the key and the output here let's say

00:12:16,920 --> 00:12:23,130
after we do okay that's what a query is

00:12:20,850 --> 00:12:26,490
and the next key concept is something

00:12:23,130 --> 00:12:28,290
called the database go salsa database is

00:12:26,490 --> 00:12:30,750
going to be a strut it's basically the

00:12:28,290 --> 00:12:32,940
context for your entire computation it's

00:12:30,750 --> 00:12:34,079
going to store all of salsas internal

00:12:32,940 --> 00:12:35,610
stings

00:12:34,079 --> 00:12:39,180
you can also store other things whatever

00:12:35,610 --> 00:12:40,230
you want basically and they should be a

00:12:39,180 --> 00:12:44,160
bit careful because you can mess

00:12:40,230 --> 00:12:47,370
something in the no result sure in the

00:12:44,160 --> 00:12:50,699
goal statement but but it's going to

00:12:47,370 --> 00:12:52,680
store our salsa to internal state and it

00:12:50,699 --> 00:12:54,839
has essentially all the intermediate

00:12:52,680 --> 00:12:57,510
values for these different queries that

00:12:54,839 --> 00:12:59,820
we might wind up reusing when we compute

00:12:57,510 --> 00:13:01,709
all those intermediate values are things

00:12:59,820 --> 00:13:05,250
that we that are stored somewhere in

00:13:01,709 --> 00:13:07,290
this database but so basically the

00:13:05,250 --> 00:13:09,269
database is kind of like all the kind of

00:13:07,290 --> 00:13:11,459
the heap for your salsa composition all

00:13:09,269 --> 00:13:15,060
the in all the data that you need now

00:13:11,459 --> 00:13:16,620
the only thing is just like you don't

00:13:15,060 --> 00:13:20,880
build your whole program in one giant

00:13:16,620 --> 00:13:23,130
file or function you don't build your

00:13:20,880 --> 00:13:25,050
database and of all at once but it's

00:13:23,130 --> 00:13:25,470
gonna have to currently has all the

00:13:25,050 --> 00:13:28,740
internal

00:13:25,470 --> 00:13:34,170
it has to know all the queries that you

00:13:28,740 --> 00:13:36,840
do but you don't have to miss them sort

00:13:34,170 --> 00:13:39,210
of all in one place instead what we do

00:13:36,840 --> 00:13:41,160
must be group queries what I'm calling

00:13:39,210 --> 00:13:43,470
query groups they're kind of like salsa

00:13:41,160 --> 00:13:49,500
modulus they're basically a set of

00:13:43,470 --> 00:13:53,190
queries which which are defined together

00:13:49,500 --> 00:13:54,510
as a unit and then you combine very

00:13:53,190 --> 00:13:57,090
groups before you do this

00:13:54,510 --> 00:13:59,100
welcome back to tricks but I want to

00:13:57,090 --> 00:14:00,930
just point out Monday's in the way

00:13:59,100 --> 00:14:02,420
you're going to interact and salsa when

00:14:00,930 --> 00:14:05,730
you have these queries the database

00:14:02,420 --> 00:14:08,220
basically feels like a function of the

00:14:05,730 --> 00:14:09,600
business so for example if I have a

00:14:08,220 --> 00:14:10,080
database and I invoke TB doesn't

00:14:09,600 --> 00:14:13,320
manifest

00:14:10,080 --> 00:14:16,140
I got a manifest return to write and

00:14:13,320 --> 00:14:19,760
then the idea is or if I broke your DBA

00:14:16,140 --> 00:14:23,610
s2 something then I'm gonna get the ast

00:14:19,760 --> 00:14:26,190
returned to me for a food RS and the

00:14:23,610 --> 00:14:28,440
idea of incremental recomputation is

00:14:26,190 --> 00:14:31,650
that these values are memorized if I

00:14:28,440 --> 00:14:33,900
invoke this place I just get the result

00:14:31,650 --> 00:14:39,210
cloned cannot be computed at least by

00:14:33,900 --> 00:14:40,020
default the idea is even once the inputs

00:14:39,210 --> 00:14:43,800
change

00:14:40,020 --> 00:14:46,110
I may just hope this is a result it did

00:14:43,800 --> 00:14:48,000
not was not affected by the change

00:14:46,110 --> 00:14:51,030
didn't work I can just get it cloned

00:14:48,000 --> 00:14:55,410
they don't have to so how do inputs

00:14:51,030 --> 00:14:58,140
change well unlike when you have an

00:14:55,410 --> 00:15:00,030
input query you also have a method a set

00:14:58,140 --> 00:15:03,450
method that you can use where you kind

00:15:00,030 --> 00:15:06,650
of say okay I'm gonna set set the value

00:15:03,450 --> 00:15:10,080
of this input and this triggers other

00:15:06,650 --> 00:15:13,169
memorized or previous memorized values

00:15:10,080 --> 00:15:13,169
[Music]

00:15:13,310 --> 00:15:19,890
whose needs okay so let's come back to

00:15:18,060 --> 00:15:21,750
three keys so we saw now how you're

00:15:19,890 --> 00:15:23,250
actually going to use the database but

00:15:21,750 --> 00:15:25,920
how are we going to define the database

00:15:23,250 --> 00:15:30,060
do that using prayer groups the idea

00:15:25,920 --> 00:15:33,060
would be let's use an example we'll go

00:15:30,060 --> 00:15:35,580
back to our off to our IDE query sir you

00:15:33,060 --> 00:15:38,150
might want to have for example a prayer

00:15:35,580 --> 00:15:41,390
group that is basically the

00:15:38,150 --> 00:15:43,430
for inputs will despite evils that I've

00:15:41,390 --> 00:15:47,270
identified and to do that we just

00:15:43,430 --> 00:15:51,730
basically write a trade what exactly

00:15:47,270 --> 00:15:56,480
starting point and we're going to apply

00:15:51,730 --> 00:15:58,070
the we're going to apply I'm gonna use

00:15:56,480 --> 00:16:01,430
these types we know he's actually would

00:15:58,070 --> 00:16:04,640
be spending a second and we're gonna

00:16:01,430 --> 00:16:07,580
apply this salsa actually that growth

00:16:04,640 --> 00:16:09,730
was very good once again this meaning

00:16:07,580 --> 00:16:13,910
second and what this will do is it will

00:16:09,730 --> 00:16:16,100
it will kind of a decorator or I can you

00:16:13,910 --> 00:16:19,250
network it will process this tree it

00:16:16,100 --> 00:16:20,330
will produce that tree as output but it

00:16:19,250 --> 00:16:22,580
will also produce a bunch of

00:16:20,330 --> 00:16:24,260
intermediate stuff that's also uses and

00:16:22,580 --> 00:16:26,240
one of those things is something called

00:16:24,260 --> 00:16:28,970
the storage struck the name of which is

00:16:26,240 --> 00:16:30,380
given here and this will see later we're

00:16:28,970 --> 00:16:33,680
going to use that later when we create

00:16:30,380 --> 00:16:36,380
the database to put all the pretty girls

00:16:33,680 --> 00:16:38,030
together and so that basically the set

00:16:36,380 --> 00:16:40,070
of queries and we reboot are just a set

00:16:38,030 --> 00:16:41,390
of methods in the street all the methods

00:16:40,070 --> 00:16:44,990
have been done before and much like this

00:16:41,390 --> 00:16:46,700
one cell and you can mark them with

00:16:44,990 --> 00:16:49,100
special attributes like salsa employed

00:16:46,700 --> 00:16:51,110
to indicate that in this case were

00:16:49,100 --> 00:16:52,430
saying these are the base inputs don't

00:16:51,110 --> 00:16:54,680
you have for every input we're also

00:16:52,430 --> 00:17:00,860
going to have a setter as a member area

00:16:54,680 --> 00:17:03,470
trade which is all of you so now we

00:17:00,860 --> 00:17:05,510
defined it very good I'm the key point

00:17:03,470 --> 00:17:07,300
of this this is like a set of standalone

00:17:05,510 --> 00:17:11,690
queries in this case are all integers

00:17:07,300 --> 00:17:13,940
but that we can define and we could

00:17:11,690 --> 00:17:21,530
define another query group perhaps for

00:17:13,940 --> 00:17:23,650
the parsing lets them and it's gonna

00:17:21,530 --> 00:17:31,400
look much like the one you did before

00:17:23,650 --> 00:17:35,900
but here you might say function we said

00:17:31,400 --> 00:17:44,810
that were defining this ast query that's

00:17:35,900 --> 00:17:48,020
it okay but I would define this ast

00:17:44,810 --> 00:17:50,000
query and if you recall I showed you

00:17:48,020 --> 00:17:51,650
before the ast query is gonna wind up

00:17:50,000 --> 00:17:54,110
when it executes that

00:17:51,650 --> 00:17:56,180
it's given the names of the past apart

00:17:54,110 --> 00:17:58,250
so it needs to get the source text for

00:17:56,180 --> 00:17:59,900
that in order to parse it so you can

00:17:58,250 --> 00:18:01,400
make one query you have access to

00:17:59,900 --> 00:18:05,300
another just like we being traits

00:18:01,400 --> 00:18:07,190
important here I had a trait inputs and

00:18:05,300 --> 00:18:12,140
now I say well the trade parser extends

00:18:07,190 --> 00:18:15,140
inputs and this query ast is not in

00:18:12,140 --> 00:18:17,650
English ready to derive 3 so we have to

00:18:15,140 --> 00:18:19,970
give the definition and you can do that

00:18:17,650 --> 00:18:24,350
just by writing a function you write it

00:18:19,970 --> 00:18:26,510
outside of compute engine and it's

00:18:24,350 --> 00:18:32,480
something like this this is just

00:18:26,510 --> 00:18:34,520
ordinary sort of it's just ordinary code

00:18:32,480 --> 00:18:37,550
but so this is the function that when we

00:18:34,520 --> 00:18:39,140
do need to ask you for a file we're

00:18:37,550 --> 00:18:41,600
gonna call this function and we're going

00:18:39,140 --> 00:18:44,870
to give it the database now we don't

00:18:41,600 --> 00:18:47,510
know all the query groups that are part

00:18:44,870 --> 00:18:50,090
of this database so what we get is

00:18:47,510 --> 00:18:52,130
actually some unknown type infiltrate to

00:18:50,090 --> 00:18:54,410
kind of say well this is some database

00:18:52,130 --> 00:18:55,790
that implements the price rate because

00:18:54,410 --> 00:18:58,790
it implements the parson trait we know

00:18:55,790 --> 00:19:00,770
it has an ast query we also know that it

00:18:58,790 --> 00:19:02,420
implements the input stream which means

00:19:00,770 --> 00:19:04,760
it has a manifest and an input file

00:19:02,420 --> 00:19:07,100
where you can find as well so now we can

00:19:04,760 --> 00:19:10,640
do stuff like you can get the source

00:19:07,100 --> 00:19:21,860
text for an even input file and actually

00:19:10,640 --> 00:19:23,570
i sorry i change means you can get the

00:19:21,860 --> 00:19:26,600
source text we're getting file by phone

00:19:23,570 --> 00:19:32,800
he begot source site and now we might

00:19:26,600 --> 00:19:32,800
like the actual pressure on sorry Spence

00:19:34,120 --> 00:19:41,690
um so that's how you define query it's

00:19:39,170 --> 00:19:44,360
awesome and also I want to point out

00:19:41,690 --> 00:19:47,270
this is using impulse rate in quick used

00:19:44,360 --> 00:19:51,050
in train doesn't actually like using

00:19:47,270 --> 00:19:57,020
better because as new copies of this

00:19:51,050 --> 00:19:59,210
function we will generate the cord okay

00:19:57,020 --> 00:20:00,830
now we have this source and we can keep

00:19:59,210 --> 00:20:03,710
building these layers as high as you

00:20:00,830 --> 00:20:06,470
want like so maybe

00:20:03,710 --> 00:20:10,430
hmm maybe we want to put this whole

00:20:06,470 --> 00:20:13,430
program this whole program AST perhaps

00:20:10,430 --> 00:20:18,950
belongs with the parser kind of feels

00:20:13,430 --> 00:20:23,720
like the parser Benefield's like a

00:20:18,950 --> 00:20:26,510
parser activity so you can put what it

00:20:23,720 --> 00:20:33,230
like so and then it might say sort of or

00:20:26,510 --> 00:20:47,570
source file in DB down in efest let's

00:20:33,230 --> 00:20:48,980
say something up here whatever so that

00:20:47,570 --> 00:20:55,460
you here would be we iterate from the

00:20:48,980 --> 00:20:57,530
manifest we create we get a get each

00:20:55,460 --> 00:21:01,640
source file we get the est of the source

00:20:57,530 --> 00:21:04,250
file by invoking the ast query which

00:21:01,640 --> 00:21:06,740
we'll call this code and then we want to

00:21:04,250 --> 00:21:09,700
put that into this master he has to be

00:21:06,740 --> 00:21:11,660
the female and this is the whole protein

00:21:09,700 --> 00:21:14,630
that's this is kind of how you define

00:21:11,660 --> 00:21:15,800
movie plays there are ways to take these

00:21:14,630 --> 00:21:17,620
functions if you don't want them to be

00:21:15,800 --> 00:21:22,280
in the same module the traders to find

00:21:17,620 --> 00:21:24,680
inside but now finally then we can layer

00:21:22,280 --> 00:21:29,150
this up even further so maybe our type

00:21:24,680 --> 00:21:35,060
checker we have this type chicken that

00:21:29,150 --> 00:21:40,490
might be kind of your rank checker

00:21:35,060 --> 00:21:49,460
storage so that that will build on the

00:21:40,490 --> 00:21:51,200
oppressor this returns a vector of

00:21:49,460 --> 00:21:53,150
errors that's the basic idea

00:21:51,200 --> 00:21:55,580
now when you're all done with this

00:21:53,150 --> 00:21:57,110
eventually you do have to define so this

00:21:55,580 --> 00:21:58,010
is how you define all the little modules

00:21:57,110 --> 00:21:59,860
so then you have to put them all

00:21:58,010 --> 00:22:02,420
together to meet your final thickness

00:21:59,860 --> 00:22:03,250
and the way that looks is that you make

00:22:02,420 --> 00:22:06,050
a start

00:22:03,250 --> 00:22:07,970
and in that struct you annotate it with

00:22:06,050 --> 00:22:11,030
stuffing is this invokes another grade

00:22:07,970 --> 00:22:14,180
and what you're gonna list here this

00:22:11,030 --> 00:22:17,330
query takes as input all the storage for

00:22:14,180 --> 00:22:17,630
each very good so for every crater that

00:22:17,330 --> 00:22:19,730
you

00:22:17,630 --> 00:22:22,820
to put into this business you have to

00:22:19,730 --> 00:22:25,580
have it smooth and so you put them here

00:22:22,820 --> 00:22:28,669
and you have thousands one field which

00:22:25,580 --> 00:22:30,890
is this also run time and you have to

00:22:28,669 --> 00:22:33,380
implement it's also a long time I'm

00:22:30,890 --> 00:22:37,000
sorry it's also database treat for your

00:22:33,380 --> 00:22:37,000
database types well it might be the bids

00:22:38,080 --> 00:22:44,150
and implementing the straight is

00:22:40,100 --> 00:22:46,100
actually during Paul has been far in

00:22:44,150 --> 00:22:52,390
terms of nine different methods is a

00:22:46,100 --> 00:22:55,520
single simple method which returns to

00:22:52,390 --> 00:22:57,919
this basically how the so what happens

00:22:55,520 --> 00:23:00,110
here is inside this one time we're going

00:22:57,919 --> 00:23:02,809
to generate the storage for all of these

00:23:00,110 --> 00:23:05,450
query groups internally in the engine

00:23:02,809 --> 00:23:06,559
and your you own that storage in the end

00:23:05,450 --> 00:23:10,520
and you have to be able to give us a

00:23:06,559 --> 00:23:13,070
call there's nothing um and that's how

00:23:10,520 --> 00:23:17,210
you defined your database usually what I

00:23:13,070 --> 00:23:19,039
do personally is I also do by default so

00:23:17,210 --> 00:23:22,220
that then you might have a program which

00:23:19,039 --> 00:23:26,690
says like but if me is my database

00:23:22,220 --> 00:23:33,440
invoked VD dot set manifest blah blah

00:23:26,690 --> 00:23:34,909
blah you got set device ah so you kind

00:23:33,440 --> 00:23:37,760
of setup your inputs and now I could

00:23:34,909 --> 00:23:39,230
invoke this fight Chuck Berry alright

00:23:37,760 --> 00:23:43,850
and then I could have a little loop that

00:23:39,230 --> 00:23:46,429
would like perhaps apply some edits and

00:23:43,850 --> 00:23:48,049
mean both type check a few times and

00:23:46,429 --> 00:23:53,299
each time we're going to reuse whatever

00:23:48,049 --> 00:23:58,580
results you can from the previous

00:23:53,299 --> 00:24:02,150
execution ability okay so that's the

00:23:58,580 --> 00:24:04,640
basic overview awesome thanks for

00:24:02,150 --> 00:24:07,010
listening I would say if you want to

00:24:04,640 --> 00:24:09,679
learn more possible I doing some other

00:24:07,010 --> 00:24:12,760
overviews but also you can complete the

00:24:09,679 --> 00:24:16,220
look here's where this also RS salsa

00:24:12,760 --> 00:24:18,429
there's some stuff there's some

00:24:16,220 --> 00:24:20,600
instructions and in particular there's

00:24:18,429 --> 00:24:22,220
the kind of shows all the things I

00:24:20,600 --> 00:24:28,580
talked about but in someone looking to

00:24:22,220 --> 00:24:31,539
all the comments and tweets that IO

00:24:28,580 --> 00:24:31,539

YouTube URL: https://www.youtube.com/watch?v=_muY4HjSqVw


