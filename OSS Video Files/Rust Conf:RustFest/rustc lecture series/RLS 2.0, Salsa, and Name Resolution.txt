Title: RLS 2.0, Salsa, and Name Resolution
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	A pragmatic discussion about how to proceed integrating name resolution with Salsa and RLS 2.0.
Captions: 
	00:00:00,030 --> 00:01:01,829
now I can hear you are you based in

00:00:48,899 --> 00:01:05,479
building somewhere or Garrity's so which

00:01:01,829 --> 00:01:16,710
we start Alex I was reading your

00:01:05,479 --> 00:01:20,729
description and one thing I could one

00:01:16,710 --> 00:01:22,830
thing I could explain I could explain a

00:01:20,729 --> 00:01:32,430
little bit how like chalky and all

00:01:22,830 --> 00:01:33,780
cycles which I think or we could just

00:01:32,430 --> 00:01:35,729
talk about it I think maybe the best

00:01:33,780 --> 00:01:38,280
place to start is actually mapping would

00:01:35,729 --> 00:01:40,439
you rather than being totally abstract

00:01:38,280 --> 00:01:46,140
talking about the actual problem like

00:01:40,439 --> 00:01:49,200
how you got to that yeah I think maybe

00:01:46,140 --> 00:01:51,780
it's even make sense to take a step back

00:01:49,200 --> 00:01:54,299
and speak a little bit about like name

00:01:51,780 --> 00:01:58,770
resolution in general and why do we want

00:01:54,299 --> 00:02:00,780
to hear do this whole so yeah let me

00:01:58,770 --> 00:02:05,250
just describe what you're trying to

00:02:00,780 --> 00:02:09,660
achieve we would like to have name

00:02:05,250 --> 00:02:11,819
resolution to be incremental and it's

00:02:09,660 --> 00:02:13,670
probably make sense to ask why do we

00:02:11,819 --> 00:02:16,880
want it to be incremental because

00:02:13,670 --> 00:02:18,890
example in something like intellij name

00:02:16,880 --> 00:02:20,900
resolution is not much mental but is not

00:02:18,890 --> 00:02:23,440
incremental because it is on-demand and

00:02:20,900 --> 00:02:26,560
really is basically the in Java every

00:02:23,440 --> 00:02:28,730
file has especially derivative and you

00:02:26,560 --> 00:02:32,030
import stuff using fully qualified name

00:02:28,730 --> 00:02:33,980
so he can basically maintain a mapping

00:02:32,030 --> 00:02:36,260
from fully qualified named a class

00:02:33,980 --> 00:02:39,470
object in its internal presentation and

00:02:36,260 --> 00:02:42,910
this mapping is like it's very easy to

00:02:39,470 --> 00:02:47,720
update after file changes so in IntelliJ

00:02:42,910 --> 00:02:49,400
you basically resolve names in this part

00:02:47,720 --> 00:02:51,769
every time you need to import something

00:02:49,400 --> 00:02:54,230
and if you resolve names locally inside

00:02:51,769 --> 00:02:56,299
the file you can just basically use of

00:02:54,230 --> 00:02:58,549
all of them because it's usually not

00:02:56,299 --> 00:03:00,920
that question fork anyway but you can

00:02:58,549 --> 00:03:04,220
also imagine that lay solutions which

00:03:00,920 --> 00:03:06,380
resolve name only in single function or

00:03:04,220 --> 00:03:13,220
something like that basically you can be

00:03:06,380 --> 00:03:16,970
really lazy in rust we it seems to be

00:03:13,220 --> 00:03:19,810
that we can't really be lazy with name

00:03:16,970 --> 00:03:23,660
resolution inside the thing it is

00:03:19,810 --> 00:03:26,510
scientists single crate we must name

00:03:23,660 --> 00:03:28,549
resolve the crate as a whole

00:03:26,510 --> 00:03:31,010
and when I say name is all basically

00:03:28,549 --> 00:03:35,299
neighbors of all the imports like not in

00:03:31,010 --> 00:03:40,340
solution in science item but it's just

00:03:35,299 --> 00:03:42,950
like top-level stuff because macros and

00:03:40,340 --> 00:03:45,410
imports need these exploitation

00:03:42,950 --> 00:03:51,049
algorithm and it's completely unclear

00:03:45,410 --> 00:03:54,079
how to make that on the mat because this

00:03:51,049 --> 00:03:57,140
seems like it could take a fair amount

00:03:54,079 --> 00:04:00,200
of time we need to make it faster and we

00:03:57,140 --> 00:04:02,049
need to somehow link realized one way

00:04:00,200 --> 00:04:04,940
you can commit lies it is to memorize

00:04:02,049 --> 00:04:10,250
macro implications themselves basically

00:04:04,940 --> 00:04:14,150
if you expand this macro using this

00:04:10,250 --> 00:04:17,329
input token stream you just analyzed it

00:04:14,150 --> 00:04:19,880
and when you expand this macro in some

00:04:17,329 --> 00:04:22,640
other context you just take results from

00:04:19,880 --> 00:04:25,220
cache this seems like an easy part and

00:04:22,640 --> 00:04:26,639
also requires part because macros

00:04:25,220 --> 00:04:32,129
positional markers can be

00:04:26,639 --> 00:04:35,939
it's very complicated that's leaves us

00:04:32,129 --> 00:04:39,810
we've resolved in imports using this

00:04:35,939 --> 00:04:42,449
exploit iteration loop and I think we

00:04:39,810 --> 00:04:46,110
should incremental eyes the is as well

00:04:42,449 --> 00:04:48,629
because it's actually the code which

00:04:46,110 --> 00:04:51,479
works industrialized now is pretty fast

00:04:48,629 --> 00:04:53,969
it's like tens of milliseconds but it's

00:04:51,479 --> 00:04:56,430
like not super complete not super

00:04:53,969 --> 00:04:59,129
complete and even tens of milliseconds

00:04:56,430 --> 00:05:01,800
is like something you could spend

00:04:59,129 --> 00:05:04,979
computing typing trains or stuff like

00:05:01,800 --> 00:05:07,860
that I think for completion of the

00:05:04,979 --> 00:05:10,319
budget is about like 100 milliseconds

00:05:07,860 --> 00:05:13,580
but but even 100 milliseconds is already

00:05:10,319 --> 00:05:16,259
a noticeable perceptible delay so the

00:05:13,580 --> 00:05:20,069
ETL does it will be like something like

00:05:16,259 --> 00:05:22,289
16 milliseconds in your frame so like

00:05:20,069 --> 00:05:26,400
tens of milliseconds is something we

00:05:22,289 --> 00:05:28,229
wishes were filed to say the strategy

00:05:26,400 --> 00:05:33,389
which I think could work for making this

00:05:28,229 --> 00:05:36,539
incremental is to detect what and there

00:05:33,389 --> 00:05:38,580
when there are now changes on the top

00:05:36,539 --> 00:05:41,759
level for example when you are typing

00:05:38,580 --> 00:05:46,409
inside a function you easily don't want

00:05:41,759 --> 00:05:48,000
to in a default name resolution because

00:05:46,409 --> 00:05:51,509
all the modules are the same all the

00:05:48,000 --> 00:05:53,789
imports are the same you maybe need some

00:05:51,509 --> 00:05:55,529
imports inside the function but it's not

00:05:53,789 --> 00:06:00,710
over so you can just resolve them

00:05:55,529 --> 00:06:04,500
legally yeah so here's the basic idea

00:06:00,710 --> 00:06:07,680
Ian so we start the query in such a way

00:06:04,500 --> 00:06:09,750
that it looks only at top-level items

00:06:07,680 --> 00:06:12,599
and it's not completely ignores bodies

00:06:09,750 --> 00:06:15,509
and that means that type in anybody is

00:06:12,599 --> 00:06:17,849
okay and name is evolution is reused and

00:06:15,509 --> 00:06:21,000
this actually is implemented and works

00:06:17,849 --> 00:06:23,550
quite well so when you type something

00:06:21,000 --> 00:06:26,669
set the body a resolution is instant

00:06:23,550 --> 00:06:29,430
when you add a new import you still got

00:06:26,669 --> 00:06:31,680
completions for import these completions

00:06:29,430 --> 00:06:35,389
are still basically instantaneous but

00:06:31,680 --> 00:06:40,620
they rerun the in solution from scry for

00:06:35,389 --> 00:06:44,100
the whole crate and the problem

00:06:40,620 --> 00:06:50,280
where these approach falls down is

00:06:44,100 --> 00:06:52,980
macros because so specific instance

00:06:50,280 --> 00:06:55,110
where we conclude name resolution but

00:06:52,980 --> 00:06:57,990
where I think we could avoid confusion

00:06:55,110 --> 00:06:59,790
in solution is when you have some item

00:06:57,990 --> 00:07:03,420
which is decorated by a macro so

00:06:59,790 --> 00:07:06,600
something like lazy static and inside

00:07:03,420 --> 00:07:08,700
this item there is items body and you

00:07:06,600 --> 00:07:13,740
type something inside the body of the

00:07:08,700 --> 00:07:16,320
item entirely you should maybe expand

00:07:13,740 --> 00:07:18,450
this single macro understand with the

00:07:16,320 --> 00:07:20,669
set of top-level items is the same and

00:07:18,450 --> 00:07:22,800
the computer name resolution but

00:07:20,669 --> 00:07:25,440
currently when we compute a set of

00:07:22,800 --> 00:07:28,410
top-level items itself we include

00:07:25,440 --> 00:07:31,440
microbes with their bodies in this set

00:07:28,410 --> 00:07:33,240
so if you change microbe body you change

00:07:31,440 --> 00:07:35,640
the sort of top-level items and you have

00:07:33,240 --> 00:07:38,070
to rerun the whole name resolution even

00:07:35,640 --> 00:07:39,840
if the result of macro expansion to

00:07:38,070 --> 00:07:41,870
basically be the same from the point of

00:07:39,840 --> 00:07:44,700
view of name solution

00:07:41,870 --> 00:07:57,600
yes I think this is the statement of the

00:07:44,700 --> 00:08:00,810
problem you really want to reuse the

00:07:57,600 --> 00:08:09,870
expanded form we went out a way to be

00:08:00,810 --> 00:08:16,020
expanding necklace and don't think I

00:08:09,870 --> 00:08:18,950
didn't understand when you're you said

00:08:16,020 --> 00:08:21,870
that the macro and its body does include

00:08:18,950 --> 00:08:24,060
items so if you change the macro body

00:08:21,870 --> 00:08:28,500
and in detective rear-ending was that

00:08:24,060 --> 00:08:32,520
right yes but if you're taking the body

00:08:28,500 --> 00:08:33,810
of some other function I wouldn't tell

00:08:32,520 --> 00:08:39,300
me when you change the contents of the

00:08:33,810 --> 00:08:42,020
Mac could repeat this please it's only

00:08:39,300 --> 00:08:45,120
when you change the body of the macro

00:08:42,020 --> 00:08:48,480
yes yes you change the body of the Metro

00:08:45,120 --> 00:08:50,730
but like macros like could be big like

00:08:48,480 --> 00:08:52,709
you can imagine sampling procedural

00:08:50,730 --> 00:08:54,290
micro which the currents a function for

00:08:52,709 --> 00:08:57,960
example

00:08:54,290 --> 00:09:06,029
so typing inside this function is

00:08:57,960 --> 00:09:11,760
basically typing on the top level so why

00:09:06,029 --> 00:09:13,350
do we think that we could avoid I mean

00:09:11,760 --> 00:09:15,480
when you do change the body of the map

00:09:13,350 --> 00:09:19,410
where we are gonna have to really expand

00:09:15,480 --> 00:09:20,940
to see what its result is yes because it

00:09:19,410 --> 00:09:26,279
might have been different

00:09:20,940 --> 00:09:29,700
yes is your idea that after you we

00:09:26,279 --> 00:09:34,010
expand the macro you can figure out that

00:09:29,700 --> 00:09:37,830
the solution didn't need to change

00:09:34,010 --> 00:09:39,960
personally name yes yes

00:09:37,830 --> 00:09:41,700
so like lazy stats for example is a very

00:09:39,960 --> 00:09:44,250
good example here because if you change

00:09:41,700 --> 00:09:46,770
the definition how you initialize really

00:09:44,250 --> 00:09:49,589
static you don't change the name of the

00:09:46,770 --> 00:09:52,140
stuff so from the point of view of any

00:09:49,589 --> 00:10:00,900
resolution this is actually now of

00:09:52,140 --> 00:10:03,270
change nothing changes okay so in the

00:10:00,900 --> 00:10:05,610
dark I'm gonna write this out over

00:10:03,270 --> 00:10:09,420
Society so one scenario would you like

00:10:05,610 --> 00:10:12,480
do the leading static I don't care how

00:10:09,420 --> 00:10:32,520
the syntax is whatever it is heading

00:10:12,480 --> 00:10:36,870
left cookie-based example okay so you're

00:10:32,520 --> 00:10:41,459
saying right so the change is to alter

00:10:36,870 --> 00:10:47,550
this line basically uncomment it yeah

00:10:41,459 --> 00:10:57,089
and so that doesn't need to affect the

00:10:47,550 --> 00:11:01,680
biscuits okay and so the challenge

00:10:57,089 --> 00:11:08,290
you're finding so what you would like to

00:11:01,680 --> 00:11:14,000
have understood is some way to say

00:11:08,290 --> 00:11:16,660
basically some way to say we had like a

00:11:14,000 --> 00:11:20,110
top-level query that was like a

00:11:16,660 --> 00:11:23,779
resolution was also as a different

00:11:20,110 --> 00:11:27,790
that's kind of a fully missiles or or

00:11:23,779 --> 00:11:27,790
something this kind of gives up a map

00:11:28,839 --> 00:11:35,800
look like identifiers to ID here

00:11:31,279 --> 00:11:41,360
something it's close enough to traverse

00:11:35,800 --> 00:11:43,070
and then it in the process of figuring

00:11:41,360 --> 00:11:47,510
these out this is like a fixed point

00:11:43,070 --> 00:11:52,279
process some trade in the process it

00:11:47,510 --> 00:11:58,580
invokes like expand query let's say this

00:11:52,279 --> 00:12:03,610
has ID ID l0 it would sort of say hey

00:11:58,580 --> 00:12:03,610
expand this sorry not expand memory

00:12:04,839 --> 00:12:13,070
right and the date the problem is this

00:12:08,930 --> 00:12:18,050
would this in turn uses a m-- resolution

00:12:13,070 --> 00:12:21,140
results right really I suppose this is

00:12:18,050 --> 00:12:37,580
also parametrized by like probably a

00:12:21,140 --> 00:12:39,920
module or something by crates okay so

00:12:37,580 --> 00:12:45,290
this uses those results so now we have a

00:12:39,920 --> 00:12:48,320
site called great yes this axe expansion

00:12:45,290 --> 00:12:50,420
uses those results or figuring out which

00:12:48,320 --> 00:12:54,200
not really I suppose it's figuring out

00:12:50,420 --> 00:12:56,390
which definition lazy static yes birds

00:12:54,200 --> 00:12:59,779
too yes

00:12:56,390 --> 00:13:01,820
so it does not like actually takes an ID

00:12:59,779 --> 00:13:08,060
l know it takes an identifier lazy

00:13:01,820 --> 00:13:11,190
static okay if you figure out what lazy

00:13:08,060 --> 00:13:15,250
static refers to so there's a query usin

00:13:11,190 --> 00:13:19,300
it's like the code has implemented today

00:13:15,250 --> 00:13:22,000
probably does this internally yes it is

00:13:19,300 --> 00:13:25,750
not a query because this runs inside

00:13:22,000 --> 00:13:28,120
this like general six-point loop so it

00:13:25,750 --> 00:13:32,680
just looks up in this map which we are

00:13:28,120 --> 00:13:37,030
currently building and so then it would

00:13:32,680 --> 00:13:41,290
invoke like let's say it we figure out

00:13:37,030 --> 00:13:46,060
what first to use the map we are

00:13:41,290 --> 00:13:51,940
building we get back the idea of a

00:13:46,060 --> 00:13:53,670
definition that's easier and so then

00:13:51,940 --> 00:13:57,910
there's a query that's like expand macro

00:13:53,670 --> 00:14:10,510
invocation and 0 with the arguments from

00:13:57,910 --> 00:14:13,300
l0 I guess state yes I mean probably and

00:14:10,510 --> 00:14:18,280
that query though doesn't recursively

00:14:13,300 --> 00:14:20,980
refer back to neighbors or does the

00:14:18,280 --> 00:14:24,130
expand macron vacation query is all good

00:14:20,980 --> 00:14:27,730
now it doesn't into the first name

00:14:24,130 --> 00:14:30,340
resolution but like this actually is

00:14:27,730 --> 00:14:37,030
important what are the arguments to this

00:14:30,340 --> 00:14:40,210
query so like if we actually pass token

00:14:37,030 --> 00:14:42,220
three as an argument we need to have

00:14:40,210 --> 00:14:45,310
this token three in this neighbor

00:14:42,220 --> 00:14:47,020
solution results query and that means

00:14:45,310 --> 00:14:53,670
that we depend on the actual ticket read

00:14:47,020 --> 00:14:59,950
about on the results of the expansion so

00:14:53,670 --> 00:15:05,980
we could pass an ID here like the ID of

00:14:59,950 --> 00:15:10,240
the macro and this actually what makes

00:15:05,980 --> 00:15:13,480
it difficult because you need results of

00:15:10,240 --> 00:15:15,790
name resolution to assign this ID so for

00:15:13,480 --> 00:15:18,790
example okay in the simple case this

00:15:15,790 --> 00:15:22,360
list static is a macro in a file which

00:15:18,790 --> 00:15:24,560
is typed by the user so any could be a

00:15:22,360 --> 00:15:27,470
position in this file

00:15:24,560 --> 00:15:31,910
and this would actually work for one

00:15:27,470 --> 00:15:33,620
level so to be sure when you say the ID

00:15:31,910 --> 00:15:41,960
you referring the idea of the macro

00:15:33,620 --> 00:15:43,970
definition or invocation invocation so I

00:15:41,960 --> 00:15:45,290
like the idea of micro invocation could

00:15:43,970 --> 00:15:47,839
be basically a position in the file

00:15:45,290 --> 00:15:50,210
maybe like a relative position or some

00:15:47,839 --> 00:15:53,510
path length so it can not be you know

00:15:50,210 --> 00:15:56,300
the patient on changes and this would

00:15:53,510 --> 00:16:00,620
work for one layer but say this list

00:15:56,300 --> 00:16:02,210
static generates another macro generic

00:16:00,620 --> 00:16:07,970
something which invokes another macro

00:16:02,210 --> 00:16:16,120
and we need to expand that macro and we

00:16:07,970 --> 00:16:18,740
somehow need to identify that macro and

00:16:16,120 --> 00:16:22,550
kind of to understand the meaning of

00:16:18,740 --> 00:16:25,400
that ID you need to know the results of

00:16:22,550 --> 00:16:28,240
invocation or the previous macro and to

00:16:25,400 --> 00:16:44,600
know that you do need name solution I

00:16:28,240 --> 00:16:49,030
think you would need what you would

00:16:44,600 --> 00:16:52,339
definitely need it seems like is the IDE

00:16:49,030 --> 00:16:59,260
would have to sort of tell you how to

00:16:52,339 --> 00:17:05,929
recreate the input I guess right so like

00:16:59,260 --> 00:17:07,790
so for one level so so really then I

00:17:05,929 --> 00:17:12,939
guess what the question is it's like

00:17:07,790 --> 00:17:12,939
what does the ID nap - in other words

00:17:14,050 --> 00:17:21,640
I'm thinking of the salsa Internet

00:17:17,390 --> 00:17:25,630
privacy you know where the ID could be

00:17:21,640 --> 00:17:28,310
as you say like the base IDs are sort of

00:17:25,630 --> 00:17:32,120
some path through the invoice to some

00:17:28,310 --> 00:17:36,230
bytes I guess you can just think of it

00:17:32,120 --> 00:17:38,330
as a file line for now it's like the

00:17:36,230 --> 00:17:42,980
base level and then the next level would

00:17:38,330 --> 00:17:45,230
be like a span into the result of a

00:17:42,980 --> 00:17:51,880
macro expansion which means we would

00:17:45,230 --> 00:17:56,720
need few other IDs to identify it right

00:17:51,880 --> 00:18:01,070
yeah and that seems like it covers all

00:17:56,720 --> 00:18:03,800
the cases no so there is your write that

00:18:01,070 --> 00:18:08,750
name resolution plays a role because

00:18:03,800 --> 00:18:11,800
figuring out the D in that macro

00:18:08,750 --> 00:18:15,190
expansion got the definition that's like

00:18:11,800 --> 00:18:29,450
name resolutions job but given a

00:18:15,190 --> 00:18:30,710
definition ended in with I think you

00:18:29,450 --> 00:18:35,570
could but I don't think this would solve

00:18:30,710 --> 00:18:37,429
here so so I think you could say okay I

00:18:35,570 --> 00:18:41,000
think you could make an ID that maps to

00:18:37,429 --> 00:18:43,610
something like this over here and the

00:18:41,000 --> 00:18:46,309
idea would be if you have to let's say

00:18:43,610 --> 00:18:50,570
that the lazy static is inside

00:18:46,309 --> 00:18:54,469
if one macaroni generates the invocation

00:18:50,570 --> 00:18:55,070
of another mackworthy then what would

00:18:54,469 --> 00:19:02,450
happen

00:18:55,070 --> 00:19:05,629
a crow a spins to be banned something's

00:19:02,450 --> 00:19:10,009
been right why you would wind up with

00:19:05,629 --> 00:19:15,919
first you would invoke like in macro

00:19:10,009 --> 00:19:18,919
inculcation a definition right and this

00:19:15,919 --> 00:19:21,440
this use sight is just a base decision

00:19:18,919 --> 00:19:26,049
in a file something that would give you

00:19:21,440 --> 00:19:26,049
some set of tokens which are part of the

00:19:26,469 --> 00:19:37,309
then you would ask for okay

00:19:31,179 --> 00:19:43,070
now I would ask for light now I might

00:19:37,309 --> 00:19:57,349
say later I look at those tokens I see

00:19:43,070 --> 00:19:59,149
be ban and I say I make an ID which I'll

00:19:57,349 --> 00:20:02,059
call B you say the corresponds to them

00:19:59,149 --> 00:20:06,559
there yes yes I see

00:20:02,059 --> 00:20:09,589
I yes I think actually this might solve

00:20:06,559 --> 00:20:23,299
a problem the problem was that in my

00:20:09,589 --> 00:20:26,359
intimidation I used okay so in my

00:20:23,299 --> 00:20:30,259
implementation I used on the user side

00:20:26,359 --> 00:20:33,109
as an ID because like in fear we're

00:20:30,259 --> 00:20:35,119
given your side you can get to the

00:20:33,109 --> 00:20:36,649
definition if you involve name

00:20:35,119 --> 00:20:39,700
resolution because I could say you cite

00:20:36,649 --> 00:20:42,289
if however the we actually put

00:20:39,700 --> 00:20:47,479
definition of the macro into the same

00:20:42,289 --> 00:20:50,229
entity this seems like it could just

00:20:47,479 --> 00:20:50,229
work probably

00:20:55,840 --> 00:21:03,250
what does expand microwave invocation

00:20:58,600 --> 00:21:05,890
return because it is returned to for

00:21:03,250 --> 00:21:09,010
talking trees doesn't that invalidate

00:21:05,890 --> 00:21:11,860
the whole cry anyway every time we

00:21:09,010 --> 00:21:14,230
change something right so I think that's

00:21:11,860 --> 00:21:15,550
I think you could do something something

00:21:14,230 --> 00:21:22,270
like what I'm showing but I think it may

00:21:15,550 --> 00:21:25,870
not solve no problem like I just

00:21:22,270 --> 00:21:27,880
realized it yes I now understand that

00:21:25,870 --> 00:21:30,130
this is at least a partial solution due

00:21:27,880 --> 00:21:35,740
to the problem that's Florian said

00:21:30,130 --> 00:21:38,830
because like really we need to put some

00:21:35,740 --> 00:21:41,560
kind of extract top-level items between

00:21:38,830 --> 00:21:46,510
expand marker in the occasion and the

00:21:41,560 --> 00:21:48,010
rest of the name resolution so yeah I

00:21:46,510 --> 00:21:53,020
mean the problem is that explained macro

00:21:48,010 --> 00:21:55,360
Invitational right it returns to full it

00:21:53,020 --> 00:21:57,040
returns the full set of tokens so in

00:21:55,360 --> 00:21:59,800
principle you could have a layer in

00:21:57,040 --> 00:22:01,420
between that sort of extracts out the

00:21:59,800 --> 00:22:04,390
stuff that name resolution cares about

00:22:01,420 --> 00:22:07,510
which is like the definitions that

00:22:04,390 --> 00:22:11,890
results from a macro invocation for

00:22:07,510 --> 00:22:21,490
something right yeah yes and if you did

00:22:11,890 --> 00:22:23,350
that you might well find that the full

00:22:21,490 --> 00:22:26,290
name resolution becomes reusable because

00:22:23,350 --> 00:22:31,000
you have like that name resolution which

00:22:26,290 --> 00:22:37,960
directly in focus like definitions from

00:22:31,000 --> 00:22:41,980
a crow invocation or something a death a

00:22:37,960 --> 00:22:46,840
use sight which wouldn't I guess this

00:22:41,980 --> 00:22:47,410
would probably return back this would

00:22:46,840 --> 00:22:48,790
afterward

00:22:47,410 --> 00:22:50,200
maybe definitions isn't quite the right

00:22:48,790 --> 00:22:52,360
term but it has to include also the

00:22:50,200 --> 00:22:56,680
macros right they need to be expanded

00:22:52,360 --> 00:22:59,320
further but I think this idea be

00:22:56,680 --> 00:23:06,870
relatively stable like it would return

00:22:59,320 --> 00:23:06,870
back be you cite this yes

00:23:08,560 --> 00:23:14,420
which hopefully didn't change I guess

00:23:12,500 --> 00:23:16,340
like actually using spans isn't probably

00:23:14,420 --> 00:23:17,120
great but if you have it or stable for

00:23:16,340 --> 00:23:20,990
identifiers

00:23:17,120 --> 00:23:24,470
um then and then this would say okay

00:23:20,990 --> 00:23:27,710
then we would invoke definitions from a

00:23:24,470 --> 00:23:32,330
clarification we would figure out the

00:23:27,710 --> 00:23:33,770
name somehow do this and that point

00:23:32,330 --> 00:23:35,390
would be that while the results of

00:23:33,770 --> 00:23:36,590
expand macro implication are dirty the

00:23:35,390 --> 00:23:39,890
results with definitions from a

00:23:36,590 --> 00:23:44,810
clinician yes so you would reexpansion

00:23:39,890 --> 00:23:46,370
she wouldn't or some of them I think you

00:23:44,810 --> 00:23:53,420
could do something like this feels like

00:23:46,370 --> 00:23:56,200
it can't work and in fact like it feels

00:23:53,420 --> 00:23:58,610
sort of nice because having a label you

00:23:56,200 --> 00:24:01,520
did you want some sort of ID for the

00:23:58,610 --> 00:24:03,350
text in a macro then just on its own you

00:24:01,520 --> 00:24:06,590
can sort of trace it back to recover

00:24:03,350 --> 00:24:21,770
that text I mean that's kind of what

00:24:06,590 --> 00:24:25,220
this ID gives us I think what this

00:24:21,770 --> 00:24:27,890
solution does not give us is the ability

00:24:25,220 --> 00:24:30,740
to have finer grained reuse within a

00:24:27,890 --> 00:24:32,360
crate if we think we want that like

00:24:30,740 --> 00:24:35,000
right now you are doing name resolution

00:24:32,360 --> 00:24:38,390
across the entire crate and maybe we

00:24:35,000 --> 00:24:40,610
would like to be able to stay within

00:24:38,390 --> 00:24:44,780
this module nothing changed so I don't

00:24:40,610 --> 00:24:46,370
need to compute anything you know that's

00:24:44,780 --> 00:24:47,830
a little bit complicated because of the

00:24:46,370 --> 00:24:55,510
[Music]

00:24:47,830 --> 00:25:00,290
interdependence between modules yes but

00:24:55,510 --> 00:25:02,140
my hope is like that probably is a point

00:25:00,290 --> 00:25:07,100
to the Damini of diminishing returns

00:25:02,140 --> 00:25:09,350
like if we can get reuse across not

00:25:07,100 --> 00:25:13,550
typing on the top level and that's

00:25:09,350 --> 00:25:16,370
probably fine yes

00:25:13,550 --> 00:25:19,190
I think like at least at least the mists

00:25:16,370 --> 00:25:19,490
based based on what's performance looks

00:25:19,190 --> 00:25:22,340
like

00:25:19,490 --> 00:25:24,950
right now that would be justice we will

00:25:22,340 --> 00:25:27,340
have instantaneous completions right it

00:25:24,950 --> 00:25:29,659
seems like if we're careful with our

00:25:27,340 --> 00:25:32,539
with our choice of intermedia inquiries

00:25:29,659 --> 00:25:35,120
right then the only time you would have

00:25:32,539 --> 00:25:39,649
to rerun name resolution so when you add

00:25:35,120 --> 00:25:42,289
a new item or when you change the name

00:25:39,649 --> 00:25:44,390
of an item or in some other way like

00:25:42,289 --> 00:25:48,409
this or at a new macro application at

00:25:44,390 --> 00:25:55,669
the top level in that is probably

00:25:48,409 --> 00:25:57,860
unusual it's not Bachelor yes all right

00:25:55,669 --> 00:26:00,919
so in a sense correctly what we're

00:25:57,860 --> 00:26:05,600
trying to do is if the outermost my

00:26:00,919 --> 00:26:08,840
configuration changes then we hope that

00:26:05,600 --> 00:26:10,820
the innermost one docents doesn't change

00:26:08,840 --> 00:26:14,570
becomes cached by the creationism and

00:26:10,820 --> 00:26:16,850
set rights it's more like the set of

00:26:14,570 --> 00:26:21,620
definitions created by the macro they'll

00:26:16,850 --> 00:26:23,870
change like the actual macro expanded

00:26:21,620 --> 00:26:25,130
token tree probably will change well

00:26:23,870 --> 00:26:30,500
that's the whole idea it is changing we

00:26:25,130 --> 00:26:33,770
know it's changing with the innermost

00:26:30,500 --> 00:26:42,950
ones are cached because they hopefully

00:26:33,770 --> 00:26:46,159
don't change implications the locations

00:26:42,950 --> 00:26:49,340
themselves like what this token tree

00:26:46,159 --> 00:26:53,600
expands to giving these micro definition

00:26:49,340 --> 00:26:56,390
is definitely cached and this does not

00:26:53,600 --> 00:27:00,230
seem like a hard problem because well

00:26:56,390 --> 00:27:02,539
basically cache it and that's it but I'm

00:27:00,230 --> 00:27:05,630
understanding that the specific names

00:27:02,539 --> 00:27:12,440
which are in the result the name of the

00:27:05,630 --> 00:27:15,500
invocation is the same so basically the

00:27:12,440 --> 00:27:19,600
in the macros would just be reused if

00:27:15,500 --> 00:27:23,690
they resolve to the same macro yes I

00:27:19,600 --> 00:27:25,850
think that's right and I think what this

00:27:23,690 --> 00:27:28,190
would do is like any macro whose

00:27:25,850 --> 00:27:33,230
definition changed with Apple to expand

00:27:28,190 --> 00:27:35,750
in physics unavoidable but as long as

00:27:33,230 --> 00:27:37,280
generate the same set of ID's the

00:27:35,750 --> 00:27:39,559
neighbor solution results themselves to

00:27:37,280 --> 00:27:41,299
con the key thing would be coming up

00:27:39,559 --> 00:27:44,419
with the name of like making sure the

00:27:41,299 --> 00:27:45,860
ideas are sufficiently stable that it's

00:27:44,419 --> 00:27:50,440
true but I think the basic trick for

00:27:45,860 --> 00:27:53,000
that is to make the ideas a tree right

00:27:50,440 --> 00:27:55,940
so that you're not using like the offset

00:27:53,000 --> 00:27:57,169
in bytes or tokens the flat list because

00:27:55,940 --> 00:28:00,260
then inserting things in the middle the

00:27:57,169 --> 00:28:01,850
list costs problems but you know have

00:28:00,260 --> 00:28:04,720
some tree structure to it so that

00:28:01,850 --> 00:28:10,940
inserting the body of the lazy static

00:28:04,720 --> 00:28:13,190
doesn't affect the idea well actually

00:28:10,940 --> 00:28:16,429
also the second trick we should actually

00:28:13,190 --> 00:28:19,910
use for items now like the IDS are not

00:28:16,429 --> 00:28:22,970
trees the IDS are positional to identify

00:28:19,910 --> 00:28:25,669
an item in the file we enumerate all the

00:28:22,970 --> 00:28:29,710
top-level items and use the index of an

00:28:25,669 --> 00:28:31,760
item is as an ID so it's like kind of

00:28:29,710 --> 00:28:34,490
not really a tree structure

00:28:31,760 --> 00:28:36,710
it's a positional positional thing but

00:28:34,490 --> 00:28:47,540
you carefully arranged so that positions

00:28:36,710 --> 00:28:50,030
don't change often that's that sounds

00:28:47,540 --> 00:28:52,450
like it's changing when you form a sort

00:28:50,030 --> 00:28:55,370
of L for example because then the

00:28:52,450 --> 00:28:59,750
positions changed with structure doesn't

00:28:55,370 --> 00:29:01,429
ready right right the ID comes out the

00:28:59,750 --> 00:29:05,330
same but the thing with the ID maps to

00:29:01,429 --> 00:29:13,669
changes um I think it works to class

00:29:05,330 --> 00:29:17,299
name record this seems like a cover that

00:29:13,669 --> 00:29:21,820
would make me happy I do think at some

00:29:17,299 --> 00:29:25,549
point we can accommodate this recursive

00:29:21,820 --> 00:29:27,049
invocation style but I would want to I

00:29:25,549 --> 00:29:30,350
don't mind putting off the day of

00:29:27,049 --> 00:29:49,970
reckoning a little longer if we can do

00:29:30,350 --> 00:29:51,919
so yes I think I feel satisfied well at

00:29:49,970 --> 00:29:54,080
least at least I want to try it I am Not

00:29:51,919 --> 00:29:58,340
sure that I don't actually hit a wall

00:29:54,080 --> 00:30:03,230
somewhere in this plan but I don't see

00:29:58,340 --> 00:30:06,860
problems before implementing it actually

00:30:03,230 --> 00:30:09,140
actually if if somebody else wants to

00:30:06,860 --> 00:30:14,000
dig into micro Spanish name resolution

00:30:09,140 --> 00:30:16,370
because feel free to join like to work

00:30:14,000 --> 00:30:20,270
on something else like doing Diagnostics

00:30:16,370 --> 00:30:21,320
now it's also very exciting I would love

00:30:20,270 --> 00:30:23,240
to but I don't think that's a very

00:30:21,320 --> 00:30:28,480
realistic other suggestion so I'm not

00:30:23,240 --> 00:30:33,349
gonna make it I know I will say I will

00:30:28,480 --> 00:30:33,349
[Music]

00:30:34,720 --> 00:30:44,290
see where it goes I would be the best I

00:30:38,659 --> 00:30:46,280
could do sure it might be useful like I

00:30:44,290 --> 00:30:48,260
think it might be worth trying to play

00:30:46,280 --> 00:30:50,960
with this in a smaller example I don't

00:30:48,260 --> 00:30:52,640
know how much Oh

00:30:50,960 --> 00:30:54,080
I never actually worked in my say -

00:30:52,640 --> 00:30:55,700
maybe it's small enough and you're

00:30:54,080 --> 00:30:57,409
familiar enough that you move pretty

00:30:55,700 --> 00:30:59,179
fast like for me if I were gonna try to

00:30:57,409 --> 00:31:10,940
fruit this node I would make a little

00:30:59,179 --> 00:31:15,919
stain I don't think so yes one thing I

00:31:10,940 --> 00:31:21,470
want to talk through is that how does

00:31:15,919 --> 00:31:26,870
this work with macro by example defined

00:31:21,470 --> 00:31:31,010
like part of the crate so like what

00:31:26,870 --> 00:31:34,520
would be ad for macro by example is it

00:31:31,010 --> 00:31:36,520
the intern intern version of basically

00:31:34,520 --> 00:31:39,700
determines which defines the macro or

00:31:36,520 --> 00:31:39,700
something else

00:31:43,929 --> 00:31:48,380
can't just be the idea I thought it

00:31:47,059 --> 00:31:52,270
would just be the idea I'm not sure I

00:31:48,380 --> 00:31:55,909
understand what it makes it harder

00:31:52,270 --> 00:31:57,500
yes okay yeah I think that they do it

00:31:55,909 --> 00:32:00,440
work I was under the impression that

00:31:57,500 --> 00:32:03,950
like you really need to intern the macro

00:32:00,440 --> 00:32:06,620
bodies but it doesn't look like this

00:32:03,950 --> 00:32:10,720
okay so we probably can do this here

00:32:06,620 --> 00:32:10,720
without that internal branch of salsa

00:32:11,049 --> 00:32:19,549
probably I yeah I think the original are

00:32:16,850 --> 00:32:21,230
we ready to land gorgeous but a toilet

00:32:19,549 --> 00:32:25,549
but maybe it would be nice if we keep

00:32:21,230 --> 00:32:27,289
that a little separated I guess um I do

00:32:25,549 --> 00:32:29,539
think that will be a really powerful in

00:32:27,289 --> 00:32:30,770
a blender for this sort of thing it's

00:32:29,539 --> 00:32:38,840
exactly the kind of case where it's

00:32:30,770 --> 00:32:40,460
useful because you need some way but I

00:32:38,840 --> 00:32:42,169
mean you could the interning branch

00:32:40,460 --> 00:32:43,760
ultimately you could always like it's

00:32:42,169 --> 00:32:48,710
really just useful for constructing

00:32:43,760 --> 00:32:50,330
these sort of complex identifiers but

00:32:48,710 --> 00:32:51,140
they could always be built out of our

00:32:50,330 --> 00:32:53,630
system

00:32:51,140 --> 00:32:56,000
yeah like we do haven't turned in

00:32:53,630 --> 00:32:59,390
already it's just like handwritten ends

00:32:56,000 --> 00:33:00,650
no good see at home right so it doesn't

00:32:59,390 --> 00:33:02,260
really enable anything you can't already

00:33:00,650 --> 00:33:09,200
do

00:33:02,260 --> 00:33:13,159
just makes a little nicer so I think

00:33:09,200 --> 00:33:14,390
that is it like and I'm satisfied more

00:33:13,159 --> 00:33:18,789
than satisfied well let's see what

00:33:14,390 --> 00:33:18,789

YouTube URL: https://www.youtube.com/watch?v=Xr-rBqLr-G4


