Title: blitzerr closure upvar tys
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	Discussing how to refactor the way closure upvar types are represented with @blitzerr.
Captions: 
	00:00:01,460 --> 00:00:10,440
basically paying corporate otaku where

00:00:04,259 --> 00:00:14,900
we look that we store the actual path to

00:00:10,440 --> 00:00:17,310
the valuable to the member of the

00:00:14,900 --> 00:00:49,649
composite data that is actually being

00:00:17,310 --> 00:00:58,649
used as an awkward for the alright yeah

00:00:49,649 --> 00:01:05,000
I can see your screen okay what do you

00:00:58,649 --> 00:01:08,549
see here you see nice you see her - no I

00:01:05,000 --> 00:01:10,439
don't see a prompt I see Athena like

00:01:08,549 --> 00:01:18,420
that means by that I mean I don't see

00:01:10,439 --> 00:01:21,420
the dollarfranc - oh nice what does that

00:01:18,420 --> 00:01:27,890
see now mean it's the name of a computer

00:01:21,420 --> 00:01:27,890
in this case okay let's see

00:01:38,390 --> 00:01:40,960
so

00:01:48,180 --> 00:01:51,600
it's moving

00:02:01,390 --> 00:02:12,330
call this closure a part time okay so

00:02:17,310 --> 00:02:26,080
wait so the idea was we're gonna try to

00:02:19,740 --> 00:02:29,350
get started on justice and then trying

00:02:26,080 --> 00:02:32,500
to get started on refactoring the up bar

00:02:29,350 --> 00:02:37,540
types so that instead of having one type

00:02:32,500 --> 00:02:46,840
parameter for up bar we have a tool and

00:02:37,540 --> 00:02:53,260
we hope that this is going to work I

00:02:46,840 --> 00:02:58,120
think that the only hindrance we had was

00:02:53,260 --> 00:03:00,730
that the poeple that I checked later or

00:02:58,120 --> 00:03:10,900
something you said that that problem you

00:03:00,730 --> 00:03:14,170
have to overcome but so just to make

00:03:10,900 --> 00:03:20,769
sure we're on the same page the why

00:03:14,170 --> 00:03:24,310
we're doing this is that we're not we

00:03:20,769 --> 00:03:27,670
want to change it so that in order to

00:03:24,310 --> 00:03:31,000
figure out how many type parameters a

00:03:27,670 --> 00:03:33,489
closure type has we don't have to know

00:03:31,000 --> 00:03:35,739
how many things it captures because we

00:03:33,489 --> 00:03:38,670
want to figure out how many things it

00:03:35,739 --> 00:03:45,310
captures during type checking and not

00:03:38,670 --> 00:03:48,870
before here I see yeah the reason I mean

00:03:45,310 --> 00:03:52,030
that lets us construct closure types and

00:03:48,870 --> 00:03:53,830
wait now this is sort of a closure type

00:03:52,030 --> 00:03:58,420
is sort of conceptually a struct like

00:03:53,830 --> 00:04:06,519
this and so we're basically talking

00:03:58,420 --> 00:04:08,739
about doing is changing this like so so

00:04:06,519 --> 00:04:11,050
now you still have this basically all

00:04:08,739 --> 00:04:12,290
the same information but the number of

00:04:11,050 --> 00:04:14,659
type renders

00:04:12,290 --> 00:04:18,979
it's not dependent and the number of our

00:04:14,659 --> 00:04:22,280
parties will always be the same but the

00:04:18,979 --> 00:04:24,970
arity of this tuple is dependent but you

00:04:22,280 --> 00:04:24,970
think it's not a problem

00:04:26,350 --> 00:04:36,310
you of course couldn't socially write

00:04:31,370 --> 00:04:39,350
this struct definition rust because like

00:04:36,310 --> 00:04:46,669
these this is really a type parameter

00:04:39,350 --> 00:04:48,889
like yeah so one of the things I was

00:04:46,669 --> 00:04:51,169
saying I think we can maybe just cheap

00:04:48,889 --> 00:04:55,340
this is not really a struct and a

00:04:51,169 --> 00:04:57,620
compiler so I think we can actually

00:04:55,340 --> 00:05:01,550
cheat but if we didn't want to cheat I

00:04:57,620 --> 00:05:03,530
think we could also do this that is to

00:05:01,550 --> 00:05:05,810
say we could sort of change it so

00:05:03,530 --> 00:05:09,710
they've had a single field of type tuple

00:05:05,810 --> 00:05:11,389
and then everywhere there are parts in

00:05:09,710 --> 00:05:13,160
the compiler which refer to fields of

00:05:11,389 --> 00:05:16,430
the closure to mean the up bar so might

00:05:13,160 --> 00:05:19,610
be like Clojure dot zero to get the zero

00:05:16,430 --> 00:05:23,090
or not one to get the zero apart and

00:05:19,610 --> 00:05:25,669
they would become closure dot zero dot

00:05:23,090 --> 00:05:27,260
one you know so that we go through the

00:05:25,669 --> 00:05:32,620
tuple and go to the first field of the

00:05:27,260 --> 00:05:35,900
tuple um I think we can avoid doing that

00:05:32,620 --> 00:05:40,400
and if we can I would at least for the

00:05:35,900 --> 00:05:41,750
first round prefer to do so okay so it's

00:05:40,400 --> 00:05:45,410
sort of cheap as I said it's not

00:05:41,750 --> 00:05:52,870
actually something you could make in

00:05:45,410 --> 00:05:55,669
last can I ask a question so in this

00:05:52,870 --> 00:05:58,940
structure the first

00:05:55,669 --> 00:06:06,430
fields our lifetimes easy row - EJ

00:05:58,940 --> 00:06:13,610
archetypes and then seek a CSR are those

00:06:06,430 --> 00:06:17,180
right here so so CK is the type that we

00:06:13,610 --> 00:06:22,240
use to represent the closure time you

00:06:17,180 --> 00:06:24,520
use a kind of random

00:06:22,240 --> 00:06:29,110
basically we use it's always an integer

00:06:24,520 --> 00:06:32,130
type so it's either i8i 16 or 32 and if

00:06:29,110 --> 00:06:35,919
it's I hate that means function can you

00:06:32,130 --> 00:06:38,860
function so this is really like an

00:06:35,919 --> 00:06:44,470
internal thing it's not your Evernote or

00:06:38,860 --> 00:06:48,760
sneeze and similarly CS is the closure

00:06:44,470 --> 00:06:55,930
signature and it's always a function

00:06:48,760 --> 00:06:59,710
type nice so we're kind of packing a lot

00:06:55,930 --> 00:07:02,169
of information into this struct in the

00:06:59,710 --> 00:07:09,220
form of types because it's cannot do

00:07:02,169 --> 00:07:24,270
that but and so that's why the parity of

00:07:09,220 --> 00:07:24,270
the table will be alright

00:07:49,389 --> 00:08:08,889
so see you represents the closure up

00:07:53,319 --> 00:08:11,259
bars I see there's always a cool yeah it

00:08:08,889 --> 00:08:13,060
seems you know I'm just thinking we're

00:08:11,259 --> 00:08:16,020
gonna be able to get a regular this well

00:08:13,060 --> 00:08:16,020
if we're gonna have to change

00:08:16,439 --> 00:08:23,310
maybe we should I'm trying to decide if

00:08:20,050 --> 00:08:23,310
we're gonna be able to get away with

00:08:27,180 --> 00:08:33,250
with the up for is those fields that

00:08:30,550 --> 00:08:36,419
have reference for some parts of this to

00:08:33,250 --> 00:08:38,890
blow I'm not sure I guess we'll find out

00:08:36,419 --> 00:08:41,110
yeah it might be an alternative might be

00:08:38,890 --> 00:08:43,329
to first we factor the up farce and

00:08:41,110 --> 00:08:52,720
introduced the tuple which we could do

00:08:43,329 --> 00:08:57,699
right like this well basically we could

00:08:52,720 --> 00:09:02,339
um you could start by leaving this part

00:08:57,699 --> 00:09:05,940
as it is and just we factor this to be

00:09:02,339 --> 00:09:05,940
up for people

00:09:09,300 --> 00:09:18,450
see that means and then we'd have to we

00:09:17,010 --> 00:09:21,270
have to refactor all the things that

00:09:18,450 --> 00:09:25,070
reference those fields to go to the big

00:09:21,270 --> 00:09:27,360
reference like food zero dot whatever

00:09:25,070 --> 00:09:29,960
but then we would be very easy for us to

00:09:27,360 --> 00:09:29,960
do the next step

00:09:30,020 --> 00:09:38,520
okay I'm not sure the only reason I'm

00:09:35,010 --> 00:09:43,310
hesitant is that maybe it's not so bad I

00:09:38,520 --> 00:09:45,570
think most code sort of doesn't tear

00:09:43,310 --> 00:09:49,080
like it wouldn't be so hard to introduce

00:09:45,570 --> 00:09:51,450
this field it's mostly I think the

00:09:49,080 --> 00:09:52,860
mirror there's some special taste code

00:09:51,450 --> 00:09:56,250
in the borrow checker especially for

00:09:52,860 --> 00:09:59,070
Diagnostics it tries to identify access

00:09:56,250 --> 00:10:06,510
needs to up bars and bad code would have

00:09:59,070 --> 00:10:10,520
to be adjusted I'm not so bad I guess we

00:10:06,510 --> 00:10:10,520
shouldn't see okay

00:10:26,929 --> 00:10:51,479
let's see so if we try to remember how

00:10:41,429 --> 00:10:53,549
this works think right so it's a little

00:10:51,479 --> 00:11:00,259
more back now so the closure sucks

00:10:53,549 --> 00:11:00,259
a closure type first of all is to find

00:11:15,550 --> 00:11:21,550
right so these are all the variants

00:11:17,820 --> 00:11:23,710
types that we have compiled when you see

00:11:21,550 --> 00:11:25,330
closures here yeah

00:11:23,710 --> 00:11:28,860
the def ID and it has one of these

00:11:25,330 --> 00:11:31,870
structs and these are just a new typed

00:11:28,860 --> 00:11:34,540
list of type rendered like subst is just

00:11:31,870 --> 00:11:35,590
the usual list of values for type number

00:11:34,540 --> 00:11:39,220
groups that you use elsewhere any

00:11:35,590 --> 00:11:44,590
provided but we have some in this struck

00:11:39,220 --> 00:11:45,940
to kind of give it some extra

00:11:44,590 --> 00:11:48,700
interpretation that these are

00:11:45,940 --> 00:11:53,560
specifically a list for closers and then

00:11:48,700 --> 00:11:57,190
there's some helper methods is like a

00:11:53,560 --> 00:12:06,180
mnemonic or something or a substitution

00:11:57,190 --> 00:12:12,550
substitution because you substitute like

00:12:06,180 --> 00:12:17,200
if you have something like this then

00:12:12,550 --> 00:12:26,980
when you have who of you 32t gets

00:12:17,200 --> 00:12:28,510
substituted so so one of the things you

00:12:26,980 --> 00:12:33,540
can see that you have is this function

00:12:28,510 --> 00:12:37,630
apart eyes which says given a closure

00:12:33,540 --> 00:12:43,690
substance you can get out the types of

00:12:37,630 --> 00:12:51,640
every up far yeah right now all that

00:12:43,690 --> 00:12:54,160
does is call split which which gives

00:12:51,640 --> 00:12:55,960
which basically takes the so split takes

00:12:54,160 --> 00:12:57,790
the list of type parameters and breaks

00:12:55,960 --> 00:13:01,720
it up into categories right the closure

00:12:57,790 --> 00:13:06,520
kind this is that seek a upload your

00:13:01,720 --> 00:13:11,950
signature and on a verbal length list of

00:13:06,520 --> 00:13:13,660
up bars and then we just iterate through

00:13:11,950 --> 00:13:15,460
that list to get the list then of all

00:13:13,660 --> 00:13:20,380
the upper are types you iterate through

00:13:15,460 --> 00:13:26,080
that list and down castes so have you

00:13:20,380 --> 00:13:29,280
seen this type kind of work yeah with

00:13:26,080 --> 00:13:29,280
either a type or region

00:13:29,970 --> 00:13:35,919
and so here we're just saying normally

00:13:34,480 --> 00:13:37,540
in the list of substitutions we have

00:13:35,919 --> 00:13:40,749
kinds because they could be lifetime

00:13:37,540 --> 00:13:47,139
cookie types book what we're saying the

00:13:40,749 --> 00:13:50,980
up part should always be so if we wanted

00:13:47,139 --> 00:13:57,699
to change this basically it's gonna

00:13:50,980 --> 00:14:09,129
happen is instead of returning a slice

00:13:57,699 --> 00:14:11,109
here we're gonna return type right let's

00:14:09,129 --> 00:14:15,910
check let's give a little more reading

00:14:11,109 --> 00:14:18,100
so up fart eyes this is the function it

00:14:15,910 --> 00:14:19,329
gets back the types of each bar I want

00:14:18,100 --> 00:14:29,829
to see you kind of where it's called

00:14:19,329 --> 00:14:31,600
from okay so because the reason I want

00:14:29,829 --> 00:14:37,509
to see is if we change this to be a

00:14:31,600 --> 00:14:40,329
tuple type and then down here we're

00:14:37,509 --> 00:14:42,789
going to basically have to check that it

00:14:40,329 --> 00:14:47,980
is a tuple typing and then iterate over

00:14:42,789 --> 00:14:52,089
its contents right so it's actually sort

00:14:47,980 --> 00:14:54,850
of similar right so this function

00:14:52,089 --> 00:14:56,439
closure signature yeah gives back the

00:14:54,850 --> 00:14:59,649
signature of the closure like which

00:14:56,439 --> 00:15:01,359
argument types in its return type and it

00:14:59,649 --> 00:15:04,589
works in a somewhat similar way so it

00:15:01,359 --> 00:15:08,049
gets that type CS from the substitution

00:15:04,589 --> 00:15:12,220
it checks it says yes this is basically

00:15:08,049 --> 00:15:15,999
saying see us must be a function type so

00:15:12,220 --> 00:15:19,959
fun okay and then it extracts the

00:15:15,999 --> 00:15:25,480
signature from there and returned it and

00:15:19,959 --> 00:15:26,499
otherwise he points um and we're gonna

00:15:25,480 --> 00:15:33,419
do something we would do something

00:15:26,499 --> 00:15:36,639
similar like here we say match up our

00:15:33,419 --> 00:15:38,850
minds not sty and you would expect ID to

00:15:36,639 --> 00:15:38,850
pull

00:15:42,139 --> 00:15:52,500
but I this this basically gives us the

00:15:50,490 --> 00:15:57,810
same thing as the park lines used to be

00:15:52,500 --> 00:16:02,430
but there's a kind of catch yes there's

00:15:57,810 --> 00:16:05,339
a slight catch which is it's actually in

00:16:02,430 --> 00:16:09,120
the case that when we first create the

00:16:05,339 --> 00:16:10,829
closure but when we first create an

00:16:09,120 --> 00:16:14,760
instance at the closure type during type

00:16:10,829 --> 00:16:17,639
checking we don't know yet for example

00:16:14,760 --> 00:16:23,820
what kind it is or when its signature is

00:16:17,639 --> 00:16:27,649
or you would like it if we don't have to

00:16:23,820 --> 00:16:29,970
know how many up parts it has right

00:16:27,649 --> 00:16:32,399
that's the whole point of this so that

00:16:29,970 --> 00:16:35,550
means that actually this type isn't

00:16:32,399 --> 00:16:45,060
always a tuple please it's either an

00:16:35,550 --> 00:16:49,110
inference variable or and so actually

00:16:45,060 --> 00:16:53,040
like this is true also for the closure

00:16:49,110 --> 00:16:55,079
sig so you can see here there's some

00:16:53,040 --> 00:16:58,769
comments that says only usable outside

00:16:55,079 --> 00:17:02,579
of an inference context and we enforce

00:16:58,769 --> 00:17:05,309
that by taking this as it happened like

00:17:02,579 --> 00:17:09,020
by taking it using some lifetime trip

00:17:05,309 --> 00:17:12,569
sizing but the reason for that is

00:17:09,020 --> 00:17:14,339
because of this problem of we only you

00:17:12,569 --> 00:17:33,150
may not if you're if you haven't fully

00:17:14,339 --> 00:17:36,090
completed typing well so inference is

00:17:33,150 --> 00:17:38,370
where we figure out types and they're

00:17:36,090 --> 00:17:39,990
not explicitly written the way it

00:17:38,370 --> 00:17:43,830
basically works is that you make these

00:17:39,990 --> 00:17:46,870
things called variables represent some

00:17:43,830 --> 00:17:49,760
type not yet known

00:17:46,870 --> 00:17:53,630
and in some point of another of those

00:17:49,760 --> 00:17:56,210
variables get bound which means that

00:17:53,630 --> 00:17:57,860
basically we assignment number valor

00:17:56,210 --> 00:18:01,040
Knights would say this is the type that

00:17:57,860 --> 00:18:04,130
the you figured out the type now but in

00:18:01,040 --> 00:18:06,800
the meantime you can use these verbal so

00:18:04,130 --> 00:18:08,570
you might make a variable usually I have

00:18:06,800 --> 00:18:12,290
denote these variables using a prologue

00:18:08,570 --> 00:18:13,610
like notation question mark X you might

00:18:12,290 --> 00:18:16,010
say okay well make it tight we're gonna

00:18:13,610 --> 00:18:18,140
call it question mark X and then I can

00:18:16,010 --> 00:18:22,550
use that type in all kinds of places so

00:18:18,140 --> 00:18:24,710
I could say like if you wrote this you

00:18:22,550 --> 00:18:27,440
might say what is the type of X well

00:18:24,710 --> 00:18:28,970
it's question mark X you know it's

00:18:27,440 --> 00:18:30,320
something I don't know yet but then

00:18:28,970 --> 00:18:34,160
somewhere along the line that will get

00:18:30,320 --> 00:18:36,020
unified or bound with you 32 and now we

00:18:34,160 --> 00:18:38,120
can resolve it and find out what did it

00:18:36,020 --> 00:18:39,950
get down to and that's that right back

00:18:38,120 --> 00:18:40,640
phase that you modified that's exactly

00:18:39,950 --> 00:18:42,860
what he does

00:18:40,640 --> 00:18:47,260
oh those two and takes all the typer

00:18:42,860 --> 00:18:47,260
won't replaces them their ultimate value

00:19:05,690 --> 00:19:14,130
so right so basically this method

00:19:12,240 --> 00:19:16,710
apartheid some reason I'm talking about

00:19:14,130 --> 00:19:21,330
all this is if it's getting called

00:19:16,710 --> 00:19:23,010
during type checking before we have

00:19:21,330 --> 00:19:25,350
inferred everything that could be a

00:19:23,010 --> 00:19:28,350
problem so I wanted to look over these

00:19:25,350 --> 00:19:30,270
fall sites and see whether whether they

00:19:28,350 --> 00:19:33,450
fall into that like where they happen in

00:19:30,270 --> 00:19:35,130
the pipeline so this one is mere

00:19:33,450 --> 00:19:37,880
construction that comes way after ten

00:19:35,130 --> 00:19:37,880
shipping that's fine

00:19:42,230 --> 00:19:56,400
this one is a little bit different so so

00:19:50,850 --> 00:19:57,990
this some of these uses this is part of

00:19:56,400 --> 00:19:59,580
trait and type check this actually

00:19:57,990 --> 00:20:01,260
occurs during type checking although it

00:19:59,580 --> 00:20:02,850
occurs very lazy to type checking so I

00:20:01,260 --> 00:20:06,419
think all types have been resolved by

00:20:02,850 --> 00:20:08,360
this period um but there's something

00:20:06,419 --> 00:20:13,230
interesting about this which is that a

00:20:08,360 --> 00:20:16,429
lot of the uses of up far ties would

00:20:13,230 --> 00:20:19,890
actually be fine to operate on a tuple

00:20:16,429 --> 00:20:24,270
like what this is doing this particular

00:20:19,890 --> 00:20:26,280
function is walking down but basically

00:20:24,270 --> 00:20:27,659
examining all the data that's inside of

00:20:26,280 --> 00:20:30,530
something right so if you're in it too

00:20:27,659 --> 00:20:32,850
so during a closure it goes through and

00:20:30,530 --> 00:20:35,549
recursively processes the type of each

00:20:32,850 --> 00:20:37,320
out far but if you look right here if

00:20:35,549 --> 00:20:38,640
you if it encounters a to bolt it does

00:20:37,320 --> 00:20:40,470
the same thing with the types in the

00:20:38,640 --> 00:20:42,299
tuple right

00:20:40,470 --> 00:20:46,770
so actually we could have another method

00:20:42,299 --> 00:20:48,360
like up for are tied to pull that just

00:20:46,770 --> 00:20:50,970
returns the tuple of all up for our

00:20:48,360 --> 00:20:52,559
types and doesn't try to sort of

00:20:50,970 --> 00:20:59,850
dereference it and iterate it through

00:20:52,559 --> 00:21:01,830
the internal types and that we can do no

00:20:59,850 --> 00:21:03,450
matter what because it might be an

00:21:01,830 --> 00:21:05,220
infant's variable but we oh it's just a

00:21:03,450 --> 00:21:08,340
single type no matter what right so the

00:21:05,220 --> 00:21:10,830
problem the reason that the infant

00:21:08,340 --> 00:21:12,840
variable causes a problem for the

00:21:10,830 --> 00:21:15,960
current signature is that we would have

00:21:12,840 --> 00:21:18,269
to sort of open up the to bulletin

00:21:15,960 --> 00:21:19,799
sense and we have to know what it's

00:21:18,269 --> 00:21:23,249
bound to but if if we just have

00:21:19,799 --> 00:21:26,820
something that says give me well what is

00:21:23,249 --> 00:21:30,659
now or will eventually become the tuple

00:21:26,820 --> 00:21:36,619
of all of our types we could use that

00:21:30,659 --> 00:21:53,730
here and in a lot of other places yeah

00:21:36,619 --> 00:21:55,889
so similarly here I think that here yeah

00:21:53,730 --> 00:22:01,559
we could also this could be as well the

00:21:55,889 --> 00:22:06,269
tuple um this debug info this is way

00:22:01,559 --> 00:22:09,179
after typing friends way after similarly

00:22:06,269 --> 00:22:15,749
this all this all this code comes way

00:22:09,179 --> 00:22:19,679
after tightening friends layout also I

00:22:15,749 --> 00:22:23,039
believe layout already sort of so so

00:22:19,679 --> 00:22:26,990
layout is what computes like what fields

00:22:23,039 --> 00:22:32,369
of a struct occur which offset and so on

00:22:26,990 --> 00:22:34,110
yeah yeah and you can see here that

00:22:32,369 --> 00:22:38,340
layout already fails if it encounters

00:22:34,110 --> 00:22:39,990
the type inference Mayer ball and fog so

00:22:38,340 --> 00:22:46,769
this must be after detecting prints as

00:22:39,990 --> 00:22:50,039
well about that now trait selection this

00:22:46,769 --> 00:22:54,299
is a little bit different but this is

00:22:50,039 --> 00:22:57,869
another so this this code is saying when

00:22:54,299 --> 00:23:00,029
is a closure copy or clone and a closure

00:22:57,869 --> 00:23:02,399
basically some closure type C implements

00:23:00,029 --> 00:23:07,110
clone if all the up flower types are

00:23:02,399 --> 00:23:09,299
cloneable but we could again use the

00:23:07,110 --> 00:23:11,159
tuple type right

00:23:09,299 --> 00:23:14,330
today we sort of do that but we could

00:23:11,159 --> 00:23:14,330
instead do something like

00:23:16,760 --> 00:23:24,930
and that's true because two bulls are

00:23:20,490 --> 00:23:28,320
cloneable if all our constituents

00:23:24,930 --> 00:23:35,000
employed in fact you see the coat right

00:23:28,320 --> 00:23:39,620
here so that's good

00:23:35,000 --> 00:23:42,060
similarly I think this is just fine I

00:23:39,620 --> 00:23:44,520
think all of these cases can also be a

00:23:42,060 --> 00:23:46,610
people and it's got looked at them

00:23:44,520 --> 00:23:46,610
before

00:23:47,750 --> 00:23:56,670
similarly here so this is computing what

00:23:54,660 --> 00:23:58,650
you know like well forming this

00:23:56,670 --> 00:24:05,130
conditions so if you have types they

00:23:58,650 --> 00:24:09,480
have criteria for them to be valid but

00:24:05,130 --> 00:24:11,220
like maybe this something like this this

00:24:09,480 --> 00:24:13,130
is not actually true but it might need

00:24:11,220 --> 00:24:18,060
it for this to be valid

00:24:13,130 --> 00:24:19,560
okay hash must be true um I think the

00:24:18,060 --> 00:24:23,550
actual hash set does not require this

00:24:19,560 --> 00:24:25,410
but this is the code that we computed if

00:24:23,550 --> 00:24:27,980
they do and I think again we could use

00:24:25,410 --> 00:24:27,980
it to Boyer

00:24:30,890 --> 00:24:37,550
similarly this I'm not mistaken

00:24:39,860 --> 00:24:56,980
you use the tip oh okay they are this

00:24:53,450 --> 00:24:56,980
whispered again use the two ball

00:25:00,990 --> 00:25:05,990
I think they also comes after 10 minutes

00:25:02,910 --> 00:25:05,990
this is pretty printing

00:25:06,600 --> 00:25:15,300
I don't know this one's a little tricky

00:25:13,530 --> 00:25:18,780
because pretty printing happens at any

00:25:15,300 --> 00:25:21,870
time so we have to like you probably

00:25:18,780 --> 00:25:23,340
have to adjust this code to be to

00:25:21,870 --> 00:25:25,350
account for the possibility that it

00:25:23,340 --> 00:25:27,890
doesn't know how many hours it has yet

00:25:25,350 --> 00:25:33,950
the point where we are pretty printing

00:25:27,890 --> 00:25:36,470
is PPA us it's the pretty print auxilary

00:25:33,950 --> 00:25:38,490
horrible

00:25:36,470 --> 00:25:42,540
no one's ever figured out a way to make

00:25:38,490 --> 00:25:49,890
it nice basically it basically prints

00:25:42,540 --> 00:25:52,050
types in a user readable way it's not I

00:25:49,890 --> 00:26:00,960
mean it's kind of hard for us to print

00:25:52,050 --> 00:26:11,940
things like a closure type anyway when

00:26:00,960 --> 00:26:15,090
you do that question no no this is used

00:26:11,940 --> 00:26:31,560
when you're printing an error message do

00:26:15,090 --> 00:26:34,620
you have to like print print on this one

00:26:31,560 --> 00:26:44,460
like can we change it easily I didn't

00:26:34,620 --> 00:26:47,090
get it I think what we want to do in

00:26:44,460 --> 00:26:47,090
that case is

00:26:55,470 --> 00:27:08,890
well I think we just have to make it

00:26:58,710 --> 00:27:16,650
able to check whether basically yeah I

00:27:08,890 --> 00:27:19,000
think it has to degrade gracefully so I

00:27:16,650 --> 00:27:20,919
think what I mean is I think it means

00:27:19,000 --> 00:27:22,270
that code means to look at the type and

00:27:20,919 --> 00:27:31,000
if it's an inference variable it just

00:27:22,270 --> 00:27:32,260
won't print anything I don't know when

00:27:31,000 --> 00:27:34,059
it gets called but it might there call

00:27:32,260 --> 00:27:39,549
if nothing else you can get calling

00:27:34,059 --> 00:27:41,710
debug output anytime yeah this is still

00:27:39,549 --> 00:27:45,190
me this is still after type checking

00:27:41,710 --> 00:27:47,770
after type checking well this is a case

00:27:45,190 --> 00:27:48,940
where we can use the too long after

00:27:47,770 --> 00:28:01,720
after after so I think it should be

00:27:48,940 --> 00:28:04,990
 didn't find anything that's

00:28:01,720 --> 00:28:06,789
right and there is called during type

00:28:04,990 --> 00:28:12,010
checking but only very late when it

00:28:06,789 --> 00:28:14,679
should already be going alone or in all

00:28:12,010 --> 00:28:16,330
the cases where it's sort of ambiguous I

00:28:14,679 --> 00:28:18,809
think we can make them almost all

00:28:16,330 --> 00:28:21,850
operate over the - cool they'll be fun

00:28:18,809 --> 00:28:25,090
ok so let's try it

00:28:21,850 --> 00:28:28,240
I guess we'll find out so the first

00:28:25,090 --> 00:28:33,250
thing that needs to change

00:28:28,240 --> 00:28:40,190
I mean we'll start by changing this

00:28:33,250 --> 00:28:43,479
closure sub structure so we'll see a bar

00:28:40,190 --> 00:28:43,479
[Music]

00:28:47,250 --> 00:28:59,500
so basically the where we were giving a

00:28:53,200 --> 00:29:02,220
slice we're now going to expect there to

00:28:59,500 --> 00:29:02,220
be a single argument

00:29:03,520 --> 00:29:16,080
and then here the up bar ties so let's

00:29:08,650 --> 00:29:16,080
make any the new helper

00:29:25,610 --> 00:29:32,539
so this helper will give back to type as

00:29:29,070 --> 00:29:32,539
a tuple about flowers right

00:30:09,480 --> 00:30:17,770
so here I'm going to change this

00:30:13,420 --> 00:30:21,060
signature also so that it can't be

00:30:17,770 --> 00:30:21,060
called during tightening prints

00:30:34,670 --> 00:30:37,789
[Music]

00:30:44,120 --> 00:31:02,850
so what we're gonna do now is this is

00:31:00,660 --> 00:31:05,730
giving back into a Raider okay we'll

00:31:02,850 --> 00:31:11,850
keep that we're basically just copying

00:31:05,730 --> 00:31:17,820
this is set up that other parts of this

00:31:11,850 --> 00:31:21,390
code have alright so we'll call the up

00:31:17,820 --> 00:31:26,180
bar to pull time it should be a tuple

00:31:21,390 --> 00:31:26,180
some types and we can call this

00:31:37,510 --> 00:31:50,760
okay you with me so far yeah yeah yeah

00:31:42,210 --> 00:31:50,760
so let's so actually

00:31:53,660 --> 00:32:00,890
let's do this let's do this in somewhat

00:31:57,500 --> 00:32:03,910
smaller steps sorry what I'm doing here

00:32:00,890 --> 00:32:07,490
is reviewing my kit mystery

00:32:03,910 --> 00:32:09,500
I'm gonna leave this comment alone we'll

00:32:07,490 --> 00:32:11,050
hold off on editing that comment until

00:32:09,500 --> 00:32:14,330
we actually know what a birth you doing

00:32:11,050 --> 00:32:15,950
but what I'm thinking is what if we

00:32:14,330 --> 00:32:26,720
leave everything the same but we'll just

00:32:15,950 --> 00:32:34,540
introduce the four tuple type helper or

00:32:26,720 --> 00:32:34,540
no well we'll do this so

00:32:35,889 --> 00:32:44,210
what well we'll keep them well keep it

00:32:39,649 --> 00:32:50,269
so that we have a kind of unknown number

00:32:44,210 --> 00:32:55,340
of of our substitutions and what will

00:32:50,269 --> 00:32:56,989
make a tuple type of them and that way

00:32:55,340 --> 00:32:59,049
we can adjust but people like sort of

00:32:56,989 --> 00:33:06,200
the code that uses this without

00:32:59,049 --> 00:33:17,859
independently from the rest yeah okay we

00:33:06,200 --> 00:33:17,859
can yeah so I think to make a tuple type

00:33:27,460 --> 00:33:51,649
okay I guess I make a tuple type it used

00:33:45,289 --> 00:33:56,029
to be called me okay it's called mk2 so

00:33:51,649 --> 00:33:59,869
let me show you this function so there's

00:33:56,029 --> 00:34:04,339
a function here to make it to ball it

00:33:59,869 --> 00:34:08,889
takes something that can be interned as

00:34:04,339 --> 00:34:08,889
a slice of types yes

00:34:10,359 --> 00:34:14,139
so what we'll do is well

00:34:19,720 --> 00:34:35,780
so I've got this list of kinds basically

00:34:22,970 --> 00:34:38,200
I have to kind of convert it to a list

00:34:35,780 --> 00:34:38,200
of types

00:34:41,599 --> 00:34:48,200
since we are serving that there are

00:34:43,679 --> 00:34:48,200
actually an archetype to not wait times

00:34:48,440 --> 00:34:53,419
and now I think this should be enough

00:34:56,569 --> 00:35:12,119
probably need so now I can call make two

00:35:09,000 --> 00:35:15,559
times see what happens

00:35:12,119 --> 00:35:21,660
theory this this will not probably build

00:35:15,559 --> 00:35:26,970
I'm just gonna call xpy check this if I

00:35:21,660 --> 00:35:29,910
can my preferred way to build with the

00:35:26,970 --> 00:35:31,770
compilers refactoring things that I only

00:35:29,910 --> 00:35:35,430
have to check if it builds I don't need

00:35:31,770 --> 00:35:39,720
to actually run another just positive

00:35:35,430 --> 00:35:44,900
and then and then maybe go back and run

00:35:39,720 --> 00:35:44,900
the tests and if I have a bug bisection

00:35:45,260 --> 00:35:59,819
happens like so quickly for me this I

00:35:50,270 --> 00:36:09,569
can click five to ten minutes Ted are

00:35:59,819 --> 00:36:17,309
you running Chuck this is Jack probably

00:36:09,569 --> 00:36:21,390
could but that's kind of what I'm saying

00:36:17,309 --> 00:36:23,670
he said I like to use check I like to

00:36:21,390 --> 00:36:26,369
set up my work so that I can use check

00:36:23,670 --> 00:36:31,950
and just do type checking in part cause

00:36:26,369 --> 00:36:33,630
it's much faster oh and of course it's

00:36:31,950 --> 00:36:36,270
also nice like it leads you through a

00:36:33,630 --> 00:36:44,369
sort of series of small changes that are

00:36:36,270 --> 00:36:50,809
independently processable um okay so now

00:36:44,369 --> 00:36:50,809
I have some of our substance

00:36:56,900 --> 00:37:02,290
okay

00:36:59,200 --> 00:37:02,290
[Music]

00:37:07,340 --> 00:37:15,110
I see okay so this code is just trying

00:37:11,420 --> 00:37:17,810
to sort of be generic over two kinds of

00:37:15,110 --> 00:37:21,020
up fires I didn't realize that generator

00:37:17,810 --> 00:37:22,220
subs was their own struct that's going

00:37:21,020 --> 00:37:29,210
to be a little annoying we'll deal with

00:37:22,220 --> 00:37:34,030
that so the reason is what wonder why

00:37:29,210 --> 00:37:39,140
it's an integrator well it makes sense

00:37:34,030 --> 00:37:41,720
so the problem is imple iterator means

00:37:39,140 --> 00:37:44,680
that you have one iterator type but

00:37:41,720 --> 00:37:46,760
there's actually sort of two possible

00:37:44,680 --> 00:37:52,760
I'm just gonna put this in a slightly

00:37:46,760 --> 00:37:54,080
different way um so this is basically

00:37:52,760 --> 00:37:56,750
saying you're getting yourselves from

00:37:54,080 --> 00:37:58,790
one or two places right and in theory

00:37:56,750 --> 00:38:07,670
you could write this you'll see that

00:37:58,790 --> 00:38:11,050
this doesn't actually build but we can

00:38:07,670 --> 00:38:11,050
tweak it to make your build in a second

00:38:13,960 --> 00:38:18,200
you'll know if this makes sense but

00:38:16,190 --> 00:38:20,210
saying depending on whether you have a

00:38:18,200 --> 00:38:22,850
closure or generator you'll have

00:38:20,210 --> 00:38:24,770
slightly different types if you can they

00:38:22,850 --> 00:38:29,840
still each have an upfront eyes method

00:38:24,770 --> 00:38:33,280
so we could call it like this right in

00:38:29,840 --> 00:38:36,320
practice right this is the problem

00:38:33,280 --> 00:38:39,110
problem is they each have a different

00:38:36,320 --> 00:38:42,350
iterator type and we need to return

00:38:39,110 --> 00:38:45,830
exactly one iterator type well if you

00:38:42,350 --> 00:38:58,820
haven't worked with them infiltrate this

00:38:45,830 --> 00:39:00,710
is the problem that occurs sometimes so

00:38:58,820 --> 00:39:07,510
one way to solve that is you can use

00:39:00,710 --> 00:39:10,100
this either type which basically it's

00:39:07,510 --> 00:39:12,170
it's kind of exactly this to be honest

00:39:10,100 --> 00:39:13,910
it's like exactly the same as this up

00:39:12,170 --> 00:39:17,570
fire subtype it's just an enum with left

00:39:13,910 --> 00:39:19,220
and right and it implements iterator if

00:39:17,570 --> 00:39:21,860
left and right both implement iterator

00:39:19,220 --> 00:39:29,330
and it does whatever dispatch is

00:39:21,860 --> 00:39:39,230
appropriately have you seen that before

00:39:29,330 --> 00:39:40,760
or not it's like you see I'm adding it

00:39:39,230 --> 00:39:49,880
to the cargo tom oh here without telling

00:39:40,760 --> 00:39:57,440
you but it's a it's a it's like crazy

00:39:49,880 --> 00:40:04,880
okay Oh putting anyone so we are fine

00:39:57,440 --> 00:40:09,130
picking up a dependent just not in this

00:40:04,880 --> 00:40:09,130
particular grace but other crates do

00:40:16,579 --> 00:40:24,949
so I'm just taking what's already there

00:40:20,559 --> 00:40:38,349
if you see here the Liberace mirror uses

00:40:24,949 --> 00:40:38,349
either this is a this is a my favorite

00:41:05,439 --> 00:41:13,039
well okay so now that code is all

00:41:11,059 --> 00:41:15,920
building but we're getting errors

00:41:13,039 --> 00:41:19,130
because I made this I made it so that

00:41:15,920 --> 00:41:25,249
the up fart eyes helper method can only

00:41:19,130 --> 00:41:29,959
be called if you know they had that

00:41:25,249 --> 00:41:31,429
enduring influence which right it's

00:41:29,959 --> 00:41:36,650
getting us some compilation errors we're

00:41:31,429 --> 00:41:39,049
about to see which i think is okay

00:41:36,650 --> 00:41:44,569
because these are exactly the cases

00:41:39,049 --> 00:41:47,019
where you can try to use the tuple type

00:41:44,569 --> 00:41:47,019
instead

00:41:56,839 --> 00:42:01,849
for at least some of them are you see

00:41:59,519 --> 00:42:01,849
how it goes

00:42:08,200 --> 00:42:12,460
like here I think we just need

00:42:18,599 --> 00:42:29,020
I'm just going through these and

00:42:20,680 --> 00:42:39,760
changing them to use this apart to

00:42:29,020 --> 00:42:41,290
bow-tied appropriate drops calculus yeah

00:42:39,760 --> 00:42:43,930
so if you look at this code what it's

00:42:41,290 --> 00:42:48,760
doing is it's going through each of the

00:42:43,930 --> 00:42:51,910
upper ties and for each man it's calling

00:42:48,760 --> 00:42:53,530
trivial drop check out lives okay so

00:42:51,910 --> 00:42:55,270
what I'm doing instead is I'm calling

00:42:53,530 --> 00:42:59,710
trivial drop check out lives on the

00:42:55,270 --> 00:43:07,079
tuple and then that will cause it to be

00:42:59,710 --> 00:43:07,079
the rate that make sense yeah thanks

00:43:09,450 --> 00:43:21,540
similarly here I can instead of

00:43:16,359 --> 00:43:21,540
iterating through the list I can just

00:43:29,560 --> 00:43:42,310
you can just call it once yes mistress

00:43:33,740 --> 00:43:42,310
I think the same here who work

00:43:57,200 --> 00:44:04,819
okay so this is a what's happening here

00:44:01,730 --> 00:44:18,859
is I the TC X has all these lifetimes

00:44:04,819 --> 00:44:23,270
have you seen it so happened the last

00:44:18,859 --> 00:44:26,900
one in the list is sort of the lifetime

00:44:23,270 --> 00:44:28,940
of the shortest like basically the

00:44:26,900 --> 00:44:34,119
lifetime of the innermost enclosing

00:44:28,940 --> 00:44:36,349
inference context and it's kind of the

00:44:34,119 --> 00:44:39,829
the lifetime of types that you're

00:44:36,349 --> 00:44:41,750
working with physically and it so

00:44:39,829 --> 00:44:44,119
happens that those functions didn't need

00:44:41,750 --> 00:44:46,970
to constrain it before because they

00:44:44,119 --> 00:44:49,579
weren't making types so when you make a

00:44:46,970 --> 00:44:51,740
new type that gets interns it gets

00:44:49,579 --> 00:44:54,319
stored into out in the arena and it gets

00:44:51,740 --> 00:44:57,730
that lifetime the shortest one but they

00:44:54,319 --> 00:45:26,569
weren't making new types but now we are

00:44:57,730 --> 00:45:28,130
so I had indicate no it's just that we

00:45:26,569 --> 00:45:31,520
weren't our killing any memory in those

00:45:28,130 --> 00:45:37,760
functions so they didn't need to be we

00:45:31,520 --> 00:45:40,359
need to say how long you will live now

00:45:37,760 --> 00:45:40,359
I'm getting some

00:45:45,170 --> 00:45:54,170
No so what I'm gonna do in order to

00:45:49,250 --> 00:45:55,700
avoid I'm gonna take off this this is

00:45:54,170 --> 00:45:59,089
the requirement that was forcing us to

00:45:55,700 --> 00:46:01,400
not call it where we might be where it

00:45:59,089 --> 00:46:08,000
might be in inference code I'm gonna

00:46:01,400 --> 00:46:10,670
take that out because I want to get it

00:46:08,000 --> 00:46:13,849
working without if I did instead of all

00:46:10,670 --> 00:46:15,440
the ones I'm gonna just go through now

00:46:13,849 --> 00:46:20,240
this is the rip crap out plan I'm just

00:46:15,440 --> 00:46:24,950
gonna go through and find places I think

00:46:20,240 --> 00:46:26,750
we can manually convert away from

00:46:24,950 --> 00:46:54,200
calling up fart eyes even if they would

00:46:26,750 --> 00:46:57,619
compile because we know so so here again

00:46:54,200 --> 00:47:02,920
I'm just converting on what was an

00:46:57,619 --> 00:47:05,920
iteration from crack to a single call

00:47:02,920 --> 00:47:05,920
confused

00:47:07,509 --> 00:47:11,710
that should work

00:47:08,930 --> 00:47:11,710
yes

00:47:16,280 --> 00:47:20,240
this one I'm gonna leave alone because

00:47:18,470 --> 00:47:22,670
this is a generator which I will have to

00:47:20,240 --> 00:47:28,450
change generators to but I haven't done

00:47:22,670 --> 00:47:28,450
them yet this one

00:47:46,560 --> 00:47:54,300
incidentally if we were going to change

00:47:49,580 --> 00:47:57,210
the memory layout you know I said we

00:47:54,300 --> 00:48:00,780
still model or to pull closure as having

00:47:57,210 --> 00:48:04,560
and feels instead of one field is a

00:48:00,780 --> 00:48:05,550
tuple this layout code is if we were

00:48:04,560 --> 00:48:07,350
going to change that we would probably

00:48:05,550 --> 00:48:11,700
be among other things changing the

00:48:07,350 --> 00:48:16,230
memory layout could but anyway so that's

00:48:11,700 --> 00:48:20,160
a generator here I'm going to change

00:48:16,230 --> 00:48:21,720
this so I think I'm gonna have just

00:48:20,160 --> 00:48:22,260
looking at the time I'm gonna have to go

00:48:21,720 --> 00:48:23,640
soon

00:48:22,260 --> 00:48:25,950
but what I was thinking is once we get

00:48:23,640 --> 00:48:30,590
hopefully we can get this building and

00:48:25,950 --> 00:48:35,760
I'll push it to a branch and then maybe

00:48:30,590 --> 00:48:36,780
you can try to we'll have to discuss

00:48:35,760 --> 00:48:40,070
this she Bella

00:48:36,780 --> 00:48:40,070
sort of come up with some next steps

00:48:52,420 --> 00:48:55,350
hmm

00:48:58,020 --> 00:49:02,190
this is annoying so

00:49:28,079 --> 00:49:36,130
strattice this is an annoying lifetime

00:49:30,700 --> 00:49:45,130
you are denied possibly just side side

00:49:36,130 --> 00:49:49,799
step so yeah so what's happening I mean

00:49:45,130 --> 00:49:57,160
here is that in the pretty printing code

00:49:49,799 --> 00:50:00,520
we have we actually normally we'd get

00:49:57,160 --> 00:50:03,130
given tcx the type context as a

00:50:00,520 --> 00:50:08,309
perimeter and so we can kind of

00:50:03,130 --> 00:50:08,309
constrain its lifetime however we like

00:50:14,780 --> 00:50:22,920
[Music]

00:50:17,520 --> 00:50:26,079
but in the case of the preprinting code

00:50:22,920 --> 00:50:28,750
we can't do that because we get invoked

00:50:26,079 --> 00:50:31,599
from a debug imple so what we do is we

00:50:28,750 --> 00:50:33,640
grab the type context from we use like

00:50:31,599 --> 00:50:37,619
thread-local storage and then we have to

00:50:33,640 --> 00:50:39,970
do some horrible things because the

00:50:37,619 --> 00:50:41,920
because we weren't giving it as a type

00:50:39,970 --> 00:50:45,099
parameter the compiler doesn't really

00:50:41,920 --> 00:50:46,750
know like what is lifetimes over and so

00:50:45,099 --> 00:50:49,720
forth it doesn't know kind of what its

00:50:46,750 --> 00:50:51,069
full type is it so we're sort of doing

00:50:49,720 --> 00:50:53,589
some hacks and that's what I'm trying to

00:50:51,069 --> 00:50:59,640
solve here unfortunately it's not

00:50:53,589 --> 00:50:59,640
working and I don't know why but

00:51:11,880 --> 00:51:17,109
so what happens is this this tie TLS

00:51:14,980 --> 00:51:20,859
which says give me the tight context

00:51:17,109 --> 00:51:23,500
it's um in scope and you wind up having

00:51:20,859 --> 00:51:26,319
to give it a closure which works sort of

00:51:23,500 --> 00:51:35,200
for any lifetimes and now it's getting

00:51:26,319 --> 00:51:36,160
unhappy because because it has to work

00:51:35,200 --> 00:51:44,220
for any lifetime

00:51:36,160 --> 00:51:44,220
oh it has to work for any lifetime

00:51:44,700 --> 00:51:51,270
because it doesn't really know how how

00:51:47,410 --> 00:51:51,270
long the data is gonna live after all

00:51:51,869 --> 00:51:57,670
and yet we told it it we sort of we're

00:51:56,140 --> 00:52:02,549
basically combining data with unknown

00:51:57,670 --> 00:52:06,640
left with one known lifetime confusing

00:52:02,549 --> 00:52:11,890
so what we have is we have the scheme if

00:52:06,640 --> 00:52:15,279
you see this so here where I call T CX

00:52:11,890 --> 00:52:16,599
dot lift what that does is actually uses

00:52:15,279 --> 00:52:19,000
a little bit of unsafe code but it

00:52:16,599 --> 00:52:24,609
basically checks dynamically that the

00:52:19,000 --> 00:52:26,770
data that we're lifting was allocated in

00:52:24,609 --> 00:52:29,829
the right arena and it will return none

00:52:26,770 --> 00:52:32,920
if not and so it kind of lets you bridge

00:52:29,829 --> 00:52:34,420
this where a compiler doesn't know that

00:52:32,920 --> 00:52:38,140
these two things are the same this kind

00:52:34,420 --> 00:52:42,339
of dynamically checks it and lets you

00:52:38,140 --> 00:52:44,380
assert to do the same by unwrapping so

00:52:42,339 --> 00:52:46,930
when I call T CX dot lifts up start on

00:52:44,380 --> 00:52:48,579
rep I'm saying basically check that this

00:52:46,930 --> 00:52:50,250
is in the right arena and if it's not

00:52:48,579 --> 00:52:52,630
then abort

00:52:50,250 --> 00:53:01,569
but it will be this there's only one

00:52:52,630 --> 00:53:04,770
arena so it's not we know that don't

00:53:01,569 --> 00:53:04,770
worry that's like a superfood

00:53:05,359 --> 00:53:18,330
okay hopefully this will build now yeah

00:53:09,980 --> 00:53:22,200
it is start to introduce up 4-tuple time

00:53:18,330 --> 00:53:30,600
and use in some places let's take the

00:53:22,200 --> 00:53:33,770
last five minutes I'll push this let's

00:53:30,600 --> 00:53:37,260
take so the next steps so what we did

00:53:33,770 --> 00:53:45,780
today we introduced this up for tuple

00:53:37,260 --> 00:53:50,540
type um I think I called it more or less

00:53:45,780 --> 00:53:55,190
everywhere that we want to be calling it

00:53:50,540 --> 00:54:03,260
I think all the rest of these locations

00:53:55,190 --> 00:54:06,840
almost with one exception this yep so

00:54:03,260 --> 00:54:08,930
okay there's all the rest of these

00:54:06,840 --> 00:54:12,450
locations that call up for our ties are

00:54:08,930 --> 00:54:15,210
fine except for two things and by fine I

00:54:12,450 --> 00:54:18,300
mean they come after typing things I see

00:54:15,210 --> 00:54:22,590
except for two things first some of them

00:54:18,300 --> 00:54:24,600
are calling on a generator and I didn't

00:54:22,590 --> 00:54:28,109
convert I converted the closure but not

00:54:24,600 --> 00:54:30,900
the generating um so that needs to be

00:54:28,109 --> 00:54:32,130
changed we probably just need to change

00:54:30,900 --> 00:54:34,440
the tenor ago the same way and that

00:54:32,130 --> 00:54:36,840
might be a good next step to like we

00:54:34,440 --> 00:54:41,609
played these steps that we did that I

00:54:36,840 --> 00:54:46,830
just did real fast and you can try to do

00:54:41,609 --> 00:54:50,310
it yourself but the other thing is this

00:54:46,830 --> 00:54:51,990
particular usage here is in this is

00:54:50,310 --> 00:54:55,140
actually in the type checker in the very

00:54:51,990 --> 00:55:00,869
last phase where it it's exactly the

00:54:55,140 --> 00:55:02,820
phase where it figures out the kinds of

00:55:00,869 --> 00:55:04,320
like they see where it infers all the

00:55:02,820 --> 00:55:07,770
upper part types in it so we're gonna

00:55:04,320 --> 00:55:09,060
have to update this eventually but you

00:55:07,770 --> 00:55:11,940
don't have to yet because we're doing

00:55:09,060 --> 00:55:16,500
this intermediate step where we just

00:55:11,940 --> 00:55:17,880
have a tuple so I think what I would say

00:55:16,500 --> 00:55:24,810
is

00:55:17,880 --> 00:55:30,450
the next steps probably are so first I

00:55:24,810 --> 00:55:39,010
would change the generator subst here

00:55:30,450 --> 00:55:41,200
okay so that basically this what we did

00:55:39,010 --> 00:55:43,480
today was we changed the closure subs

00:55:41,200 --> 00:55:47,650
introduced this code to make a coupon

00:55:43,480 --> 00:55:51,010
right right we do the same thing here in

00:55:47,650 --> 00:55:55,090
the generator self split basically wants

00:55:51,010 --> 00:55:57,250
the same codes a little bit different

00:55:55,090 --> 00:56:01,330
because the numbers are different things

00:55:57,250 --> 00:56:08,950
are a little different but same idea and

00:56:01,330 --> 00:56:15,420
then once that's done we might want to

00:56:08,950 --> 00:56:18,370
change the the pretty printing code okay

00:56:15,420 --> 00:56:23,200
because I because right now it's

00:56:18,370 --> 00:56:25,090
assuming that you know how many first

00:56:23,200 --> 00:56:31,630
there are and we want it to basically

00:56:25,090 --> 00:56:36,010
want to rewrite this code to fix me you

00:56:31,630 --> 00:56:39,670
write this to call up our people time

00:56:36,010 --> 00:56:54,970
and check the results if it is an

00:56:39,670 --> 00:57:00,130
inference variable you might want to add

00:56:54,970 --> 00:57:03,310
like maybe add a helper like opt up Bart

00:57:00,130 --> 00:57:06,710
eyes or something there returns

00:57:03,310 --> 00:57:06,710
[Music]

00:57:08,609 --> 00:57:16,819
I don't know there's still like no

00:57:13,079 --> 00:57:20,009
capsulate things a little bit but here

00:57:16,819 --> 00:57:22,079
that's one thing the same that's for

00:57:20,009 --> 00:57:29,779
generators the same logic applies me

00:57:22,079 --> 00:57:29,779
record closes maybe what I'm gonna write

00:57:32,719 --> 00:57:51,979
that's your name yes yes and then he

00:57:47,359 --> 00:57:51,979
said we should change the generators

00:57:59,589 --> 00:58:05,309
so once we do I think

00:58:07,240 --> 00:58:10,320
[Music]

00:58:13,290 --> 00:58:20,880
I don't know if this will work but I

00:58:15,630 --> 00:58:24,570
would like it if we could change this

00:58:20,880 --> 00:58:27,420
signature to this to prevent this from

00:58:24,570 --> 00:58:29,100
the faltering infants if we're going to

00:58:27,420 --> 00:58:33,750
do that we would need to update the

00:58:29,100 --> 00:58:37,310
peepee the pretty printing code no this

00:58:33,750 --> 00:58:37,310
is really just bad luck

00:58:39,140 --> 00:58:44,460
so once we do that then we're basically

00:58:41,970 --> 00:58:46,050
ready for the next step which would be

00:58:44,460 --> 00:58:51,630
to actually make it a tubule from the

00:58:46,050 --> 00:58:54,510
beginning I'm not oh you should just

00:58:51,630 --> 00:58:57,359
talk again yes sounds good

00:58:54,510 --> 00:59:04,830
all right well so here's what I'll do I

00:58:57,359 --> 00:59:22,980
will push this branch I will post this

00:59:04,830 --> 00:59:28,740
video all right thanks a lot for your

00:59:22,980 --> 00:59:33,170
time it's fun to see this I hope it's

00:59:28,740 --> 00:59:36,500
that I look forward to this future

00:59:33,170 --> 00:59:36,500

YouTube URL: https://www.youtube.com/watch?v=pLmVhSB-z4s


