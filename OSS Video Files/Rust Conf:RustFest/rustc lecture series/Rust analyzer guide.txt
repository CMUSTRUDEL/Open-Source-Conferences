Title: Rust analyzer guide
Publication date: 2019-02-04
Playlist: rustc lecture series
Description: 
	A walk-through of the rust-analyzer implementation, which talks about implementing compiler-driven completion for IDEs.

rust-analyzer: https://github.com/rust-analyzer/rust-analyzer
transcript of the talk: https://github.com/rust-analyzer/rust-analyzer/pull/578
Captions: 
	00:00:01,939 --> 00:00:07,859
hello I am at Clark I'd like to talk

00:00:05,100 --> 00:00:11,759
about retinol at the experimental

00:00:07,859 --> 00:00:14,460
project to build a wrath compiler which

00:00:11,759 --> 00:00:17,250
is a good heat for IDs that means that a

00:00:14,460 --> 00:00:20,580
raster layer is fully incremental on

00:00:17,250 --> 00:00:25,800
demand and is capable of providing at

00:00:20,580 --> 00:00:30,539
least some completion results as visual

00:00:25,800 --> 00:00:33,870
types so without further ado let's take

00:00:30,539 --> 00:00:38,280
a look at the code city to the necessary

00:00:33,870 --> 00:00:40,350
directory open the code obviously to

00:00:38,280 --> 00:00:45,480
read the source code of rust analyzer we

00:00:40,350 --> 00:00:48,629
will be using rotten eyes itself so

00:00:45,480 --> 00:00:51,390
there is also a sort of written

00:00:48,629 --> 00:00:54,300
transcript of this talk and if you'd

00:00:51,390 --> 00:00:56,610
rather with text then listen to me take

00:00:54,300 --> 00:01:00,180
a look at these pull requests which

00:00:56,610 --> 00:01:03,660
contains a markdown document also keep

00:01:00,180 --> 00:01:05,580
in mind that today is January 2019 the

00:01:03,660 --> 00:01:09,210
year of the Blade Runner if you are

00:01:05,580 --> 00:01:13,710
watching this video in the future things

00:01:09,210 --> 00:01:19,920
might have changed things okay so let's

00:01:13,710 --> 00:01:23,580
start the typical command-line compiler

00:01:19,920 --> 00:01:25,830
is a vegetable you run a compiler you

00:01:23,580 --> 00:01:28,680
give it a set of source files and it

00:01:25,830 --> 00:01:32,970
produces an output an executable or a

00:01:28,680 --> 00:01:37,110
library or whatever rust analyzer in

00:01:32,970 --> 00:01:39,060
contrast is a long-lived process a

00:01:37,110 --> 00:01:42,570
long-lived actor

00:01:39,060 --> 00:01:47,729
it is a stateful compliant analysis

00:01:42,570 --> 00:01:50,009
which you can apply changes to and which

00:01:47,729 --> 00:01:52,470
you can query about certain aspects of

00:01:50,009 --> 00:01:55,829
rust code like for example what is the

00:01:52,470 --> 00:01:59,310
definition of this symbol over there in

00:01:55,829 --> 00:02:01,399
code analysis this like high highest

00:01:59,310 --> 00:02:06,420
level API is represented by two types

00:02:01,399 --> 00:02:11,060
analysis host and analysis so analysis

00:02:06,420 --> 00:02:14,270
host is like a really really tiny API

00:02:11,060 --> 00:02:16,940
which apply changes to you start with

00:02:14,270 --> 00:02:19,270
creating and amped analysis using

00:02:16,940 --> 00:02:21,920
default simple and then you

00:02:19,270 --> 00:02:24,380
incrementally populate it with source

00:02:21,920 --> 00:02:27,650
information using the apply change

00:02:24,380 --> 00:02:31,670
method the change here is basically the

00:02:27,650 --> 00:02:36,050
contents of this file is now this string

00:02:31,670 --> 00:02:39,800
and the third method of knowledge cost

00:02:36,050 --> 00:02:44,739
is analysis which gets you an analysis

00:02:39,800 --> 00:02:48,560
structure and analysis has a ton of

00:02:44,739 --> 00:02:50,480
methods to actually go very a useful

00:02:48,560 --> 00:02:56,720
information about trust God for example

00:02:50,480 --> 00:02:59,570
it has go to definition one interesting

00:02:56,720 --> 00:03:04,010
thing about analysis API is that it is

00:02:59,570 --> 00:03:06,340
based on source files and spans for

00:03:04,010 --> 00:03:11,900
example the input to go to definition is

00:03:06,340 --> 00:03:14,780
file position which is a file and an

00:03:11,900 --> 00:03:17,030
offset in this file and the output of go

00:03:14,780 --> 00:03:20,480
to definition is a so-called navigation

00:03:17,030 --> 00:03:24,080
target I wish again is a file span

00:03:20,480 --> 00:03:27,560
inside the file and like the icon the

00:03:24,080 --> 00:03:30,739
name but it does not really tells you

00:03:27,560 --> 00:03:34,850
what kind of the rust symbol it is it's

00:03:30,739 --> 00:03:38,420
like an API which is not really a rust

00:03:34,850 --> 00:03:42,140
and which specific it talks in terms of

00:03:38,420 --> 00:03:46,160
the simple code editor which operates on

00:03:42,140 --> 00:03:50,410
buffers and files okay so as you can see

00:03:46,160 --> 00:03:57,079
these analysis has like a lot of methods

00:03:50,410 --> 00:03:59,570
if we select it it's like okay visual

00:03:57,079 --> 00:04:02,570
code does not show me the number of

00:03:59,570 --> 00:04:09,290
lines like it but like it's a fairly big

00:04:02,570 --> 00:04:12,820
API okay so why do we need like two

00:04:09,290 --> 00:04:17,570
types analysis host and analysis and

00:04:12,820 --> 00:04:20,000
board are exactly which changes so let's

00:04:17,570 --> 00:04:22,680
first talk about separation into the

00:04:20,000 --> 00:04:26,639
types as you

00:04:22,680 --> 00:04:32,639
no tests a lot of methods on analysis

00:04:26,639 --> 00:04:38,910
like a lot of yeah return cancelable

00:04:32,639 --> 00:04:43,740
results this solves very interesting

00:04:38,910 --> 00:04:46,830
problem suppose like you're inside an

00:04:43,740 --> 00:04:49,199
IDE and you're trying to highlight all

00:04:46,830 --> 00:04:52,520
the errors across a project this

00:04:49,199 --> 00:04:55,380
obviously takes some time to process and

00:04:52,520 --> 00:04:57,750
at the very same time while you are in

00:04:55,380 --> 00:05:00,449
the process of analyzing the code user

00:04:57,750 --> 00:05:02,910
type something in the editor and asks

00:05:00,449 --> 00:05:05,789
for completion the behavior we would

00:05:02,910 --> 00:05:10,020
like here is to get the completion

00:05:05,789 --> 00:05:12,599
results as soon as possible and at the

00:05:10,020 --> 00:05:15,210
same time because we already have

00:05:12,599 --> 00:05:19,020
adjusted the code we are not actually

00:05:15,210 --> 00:05:20,699
interested in the results of the like

00:05:19,020 --> 00:05:22,770
error highlighting that's because we

00:05:20,699 --> 00:05:28,650
need to restart it anyway the source

00:05:22,770 --> 00:05:32,880
code changed so these observation is

00:05:28,650 --> 00:05:37,260
what explains the cancellable

00:05:32,880 --> 00:05:39,990
API the idea is that when you want to do

00:05:37,260 --> 00:05:42,360
some kind of analysis you get your

00:05:39,990 --> 00:05:44,849
analysis host you call the analysis

00:05:42,360 --> 00:05:46,650
method and send this analysis to a

00:05:44,849 --> 00:05:49,800
separate write and do a background

00:05:46,650 --> 00:05:52,650
computation there and at the same time

00:05:49,800 --> 00:05:56,509
at the main thread you are waiting for

00:05:52,650 --> 00:06:00,030
the changes when changes come you just

00:05:56,509 --> 00:06:03,900
apply changes to the analysis host and

00:06:00,030 --> 00:06:06,479
ya import of material last year is that

00:06:03,900 --> 00:06:08,820
there is only one analysis host you

00:06:06,479 --> 00:06:12,030
can't clone it and applying changes

00:06:08,820 --> 00:06:14,220
requires unique access tunnels cost but

00:06:12,030 --> 00:06:16,099
there may be several outstanding

00:06:14,220 --> 00:06:18,539
analysis in different friends different

00:06:16,099 --> 00:06:19,560
threads doing different and related

00:06:18,539 --> 00:06:22,680
things like for example syntax

00:06:19,560 --> 00:06:26,310
highlighting and reference search or

00:06:22,680 --> 00:06:30,300
whatever so when you got these

00:06:26,310 --> 00:06:32,099
outstanding analysis instances and you

00:06:30,300 --> 00:06:34,000
got an incoming change what analysis

00:06:32,099 --> 00:06:38,890
caused us is that it

00:06:34,000 --> 00:06:41,800
marks each analysis as canceled that

00:06:38,890 --> 00:06:45,100
makes all the pending currently ji-hyun

00:06:41,800 --> 00:06:48,760
Aquarius to short-circuit and quickly

00:06:45,100 --> 00:06:53,830
returned or cancelled and yeah probably

00:06:48,760 --> 00:06:56,170
we should take at the definition of

00:06:53,830 --> 00:06:59,080
these canceled what is also a constable

00:06:56,170 --> 00:07:01,660
is basically a result where the error

00:06:59,080 --> 00:07:04,390
type is cancelled and cancelled is zero

00:07:01,660 --> 00:07:10,560
size type so basically just a market

00:07:04,390 --> 00:07:15,250
that the result should be canceled yeah

00:07:10,560 --> 00:07:18,160
so what we call apply change we cancel

00:07:15,250 --> 00:07:21,730
all the pending analysis all the methods

00:07:18,160 --> 00:07:25,360
returned canceled and then big round

00:07:21,730 --> 00:07:28,240
Fred's died and the also called drop on

00:07:25,360 --> 00:07:31,350
the corresponding analysis structs as

00:07:28,240 --> 00:07:35,680
soon as all analysis instances are that

00:07:31,350 --> 00:07:38,650
analysis cost the proceeds with actually

00:07:35,680 --> 00:07:41,890
applying change so basically when you

00:07:38,650 --> 00:07:45,040
apply change you kill all background

00:07:41,890 --> 00:07:50,130
processes you apply change in place and

00:07:45,040 --> 00:07:55,750
you start analysis if you would like to

00:07:50,130 --> 00:08:00,030
okay I think yeah another important

00:07:55,750 --> 00:08:04,630
thing to talk about now is what is

00:08:00,030 --> 00:08:08,830
analysis change in other words what are

00:08:04,630 --> 00:08:12,570
the input data to the analysis so let's

00:08:08,830 --> 00:08:16,470
take a look look at this type it is

00:08:12,570 --> 00:08:22,300
basically I think I need an impo

00:08:16,470 --> 00:08:24,960
analysis change in policy changes so

00:08:22,300 --> 00:08:29,340
another change is basically a builder

00:08:24,960 --> 00:08:34,030
for a single transaction of changes and

00:08:29,340 --> 00:08:36,360
it doesn't have too many methods

00:08:34,030 --> 00:08:36,360
actually

00:08:37,149 --> 00:08:46,640
so you can change source files by adding

00:08:44,630 --> 00:08:50,930
a new file change an existing file or

00:08:46,640 --> 00:08:54,350
remove an existing file you can add a

00:08:50,930 --> 00:08:56,149
bunch of new files in one go using add

00:08:54,350 --> 00:08:58,339
library method it is not essential to

00:08:56,149 --> 00:09:00,860
basically an optimization for greater

00:08:58,339 --> 00:09:06,529
your crates which are expected to be

00:09:00,860 --> 00:09:11,180
immutable and you also can set a crane

00:09:06,529 --> 00:09:13,880
graph we'll talk about how files are

00:09:11,180 --> 00:09:17,089
represented in the moment a currently

00:09:13,880 --> 00:09:18,709
you can think of a file as of something

00:09:17,089 --> 00:09:24,320
with an integer

00:09:18,709 --> 00:09:28,550
I need file ID a text and a path to the

00:09:24,320 --> 00:09:34,130
file and that's it the more interesting

00:09:28,550 --> 00:09:35,720
bit is a crane graph so rest code

00:09:34,130 --> 00:09:40,279
originally consists of course of source

00:09:35,720 --> 00:09:42,800
files but such files is not part of a

00:09:40,279 --> 00:09:46,120
model trust the model of rust the

00:09:42,800 --> 00:09:49,370
completion unit of rust is a crate and

00:09:46,120 --> 00:09:52,579
crate is really more than a single

00:09:49,370 --> 00:09:57,320
source file because for example a great

00:09:52,579 --> 00:10:01,010
is determined by the active CFG flags

00:09:57,320 --> 00:10:04,700
and if you point out if you point

00:10:01,010 --> 00:10:06,920
receipt to the same file for example on

00:10:04,700 --> 00:10:09,500
Windows and on Linux you actually get

00:10:06,920 --> 00:10:13,270
different trades because they will have

00:10:09,500 --> 00:10:18,050
different CMG flags open a crate also

00:10:13,270 --> 00:10:20,449
has dependencies on other crate and this

00:10:18,050 --> 00:10:23,600
is what create graph structure is for

00:10:20,449 --> 00:10:27,680
let's take a look at its definition so

00:10:23,600 --> 00:10:30,980
here it stores a direct acyclic graph of

00:10:27,680 --> 00:10:36,019
crates where a crate is an instance of a

00:10:30,980 --> 00:10:42,310
crate it contains a particular file

00:10:36,019 --> 00:10:46,130
it contains CFG Flags

00:10:42,310 --> 00:10:48,770
which we don't actually support at the

00:10:46,130 --> 00:10:51,890
moment but like conceptually they should

00:10:48,770 --> 00:10:54,140
be here and it contains a list of

00:10:51,890 --> 00:10:56,210
dependencies where each dependency is

00:10:54,140 --> 00:10:59,840
again a particular instance of a credit

00:10:56,210 --> 00:11:01,910
and a name which would be written in the

00:10:59,840 --> 00:11:04,790
external trade declaration if you put

00:11:01,910 --> 00:11:07,490
one into your source code remember that

00:11:04,790 --> 00:11:09,650
in rust and which is a really really

00:11:07,490 --> 00:11:12,950
great feature of the language for and I

00:11:09,650 --> 00:11:15,950
the perspective in rust crate anonymous

00:11:12,950 --> 00:11:18,320
and you need to explicitly pass all the

00:11:15,950 --> 00:11:22,160
dependencies and not rely on some kind

00:11:18,320 --> 00:11:32,180
of like goal path or class path or

00:11:22,160 --> 00:11:36,560
whatever so one important thing to

00:11:32,180 --> 00:11:41,330
realize is that there is no restriction

00:11:36,560 --> 00:11:44,950
that a single file ID must correspond to

00:11:41,330 --> 00:11:49,160
a single crate you totally can have

00:11:44,950 --> 00:11:52,280
different crates which point to the same

00:11:49,160 --> 00:11:59,690
route file ID but differently in CV

00:11:52,280 --> 00:12:04,460
flags or dependencies and this is a

00:11:59,690 --> 00:12:08,350
major difference in rust from other

00:12:04,460 --> 00:12:13,100
languages like C sharp and Java because

00:12:08,350 --> 00:12:15,980
in Java the source code basically

00:12:13,100 --> 00:12:19,880
corresponds one-to-one to the semantic

00:12:15,980 --> 00:12:22,220
model in rust a single source file a

00:12:19,880 --> 00:12:26,350
single function in a source file can

00:12:22,220 --> 00:12:29,600
give rise to several instances in

00:12:26,350 --> 00:12:31,820
semantic model for example if you have

00:12:29,600 --> 00:12:34,580
like a same crates with different CFG

00:12:31,820 --> 00:12:37,790
Flags twice in your compilation graph or

00:12:34,580 --> 00:12:41,320
for example when you include the same

00:12:37,790 --> 00:12:47,510
file as a module in two different Crites

00:12:41,320 --> 00:12:50,810
so and yeah this is basically it so

00:12:47,510 --> 00:12:53,850
rusty nervous internally does not do any

00:12:50,810 --> 00:12:56,820
I at all only puts

00:12:53,850 --> 00:12:59,370
explicitly passed as analysis change and

00:12:56,820 --> 00:13:05,040
the inputs are basically the source

00:12:59,370 --> 00:13:06,930
files and the crate graph running ahead

00:13:05,040 --> 00:13:10,620
a little bit we will get credit graph

00:13:06,930 --> 00:13:15,030
from cargo but it is not exactly in the

00:13:10,620 --> 00:13:19,250
cargo model let's get back to this issue

00:13:15,030 --> 00:13:22,890
about files you may have noticed this

00:13:19,250 --> 00:13:24,990
source route ID argument in the at Iona

00:13:22,890 --> 00:13:27,960
hat and you may have noticed that the

00:13:24,990 --> 00:13:31,740
path is not like a steady path move it's

00:13:27,960 --> 00:13:34,140
some kind of relative path and this is

00:13:31,740 --> 00:13:36,930
very intentional so what is the problem

00:13:34,140 --> 00:13:40,950
with files the problem is that file

00:13:36,930 --> 00:13:43,560
systems are horrible you can't check to

00:13:40,950 --> 00:13:48,000
pass for quality for example because it

00:13:43,560 --> 00:13:52,650
requires you to do Cisco the file paths

00:13:48,000 --> 00:13:55,530
are not required to be a boot a fade and

00:13:52,650 --> 00:13:58,110
like the core issue here is that while

00:13:55,530 --> 00:14:01,110
we would like to think about file system

00:13:58,110 --> 00:14:04,680
as like three of files it is like not

00:14:01,110 --> 00:14:07,500
really a tree you can have cycles of

00:14:04,680 --> 00:14:11,850
symlinks you can have like a sensitive

00:14:07,500 --> 00:14:14,490
file system and versions of stuff so in

00:14:11,850 --> 00:14:19,080
what analyzer I really want the internal

00:14:14,490 --> 00:14:22,920
model to be 300 files with would have

00:14:19,080 --> 00:14:25,440
eight paths so that I don't have to

00:14:22,920 --> 00:14:28,410
think no differences between windows

00:14:25,440 --> 00:14:29,850
case-sensitive and Linux windows

00:14:28,410 --> 00:14:35,070
case-insensitive and the new transitions

00:14:29,850 --> 00:14:39,630
to file systems etc another thing which

00:14:35,070 --> 00:14:44,070
I would rather not care about in routine

00:14:39,630 --> 00:14:47,310
Eliza is the actual absolute path to the

00:14:44,070 --> 00:14:51,890
files on disk what I am talking about

00:14:47,310 --> 00:14:51,890
suppose your project is in light

00:14:52,370 --> 00:15:00,620
projects for my product

00:14:56,830 --> 00:15:04,400
in theory more than this products to

00:15:00,620 --> 00:15:07,610
products bar my project should not

00:15:04,400 --> 00:15:11,780
change I think inside when you like um

00:15:07,610 --> 00:15:14,750
have a project but if you actually give

00:15:11,780 --> 00:15:18,080
access to like this absolute path to the

00:15:14,750 --> 00:15:20,660
file you will be able to observe these

00:15:18,080 --> 00:15:23,810
folders as power difference and so you

00:15:20,660 --> 00:15:27,440
need to explicitly write code not to

00:15:23,810 --> 00:15:30,710
depend on these details in Rustin wiser

00:15:27,440 --> 00:15:34,480
or I'd like to just not have access to

00:15:30,710 --> 00:15:39,380
misinformation at all and this actually

00:15:34,480 --> 00:15:45,020
gives rise to this concept of source

00:15:39,380 --> 00:15:51,110
routes let's take a look at a virtual

00:15:45,020 --> 00:15:54,110
file system abstraction so VFS is a

00:15:51,110 --> 00:15:57,650
component which is not like part of the

00:15:54,110 --> 00:16:00,470
chorused analyzer which interacts with

00:15:57,650 --> 00:16:04,880
external file system and converts this

00:16:00,470 --> 00:16:10,390
like horrible world of X for file system

00:16:04,880 --> 00:16:16,160
into this nice three of utf-8 paths and

00:16:10,390 --> 00:16:24,410
the data in the file system is now is

00:16:16,160 --> 00:16:29,090
organized into a set of source route so

00:16:24,410 --> 00:16:34,610
a source route or DFS root is basically

00:16:29,090 --> 00:16:38,030
a tree a contents of a directory on the

00:16:34,610 --> 00:16:39,860
real file system so it has this like

00:16:38,030 --> 00:16:42,160
absolute path to the root of a

00:16:39,860 --> 00:16:44,630
derivative and it optionally has this

00:16:42,160 --> 00:16:50,420
filter like this source fruit contains

00:16:44,630 --> 00:16:57,390
only files with dot RS extension and the

00:16:50,420 --> 00:17:00,980
contents of source root is yes ok yeah

00:16:57,390 --> 00:17:04,320
yeah contents of a sauce root is

00:17:00,980 --> 00:17:06,959
basically a tree of files with a

00:17:04,320 --> 00:17:14,760
relative path from a source route to the

00:17:06,959 --> 00:17:18,390
file and we've texts so we what we do we

00:17:14,760 --> 00:17:23,220
create a source route for each cargo

00:17:18,390 --> 00:17:25,980
package and each source route remembers

00:17:23,220 --> 00:17:29,430
all the files inside cargo package but

00:17:25,980 --> 00:17:35,390
it does not know the path to the source

00:17:29,430 --> 00:17:35,390
route itself so this DFS thing knows

00:17:36,530 --> 00:17:48,360
knows where it was so the DFS

00:17:46,800 --> 00:17:52,590
abstraction itself of course knows the

00:17:48,360 --> 00:17:56,310
absolute path to the crate route but the

00:17:52,590 --> 00:17:59,760
data the data will be passed to analysis

00:17:56,310 --> 00:18:03,680
change is only ID of the source route

00:17:59,760 --> 00:18:10,800
and the relative path to the file

00:18:03,680 --> 00:18:15,300
this also is useful for things like this

00:18:10,800 --> 00:18:18,080
in rust you can have a module

00:18:15,300 --> 00:18:18,080
declaration

00:18:19,419 --> 00:18:26,419
or with a bath attribute and this fat

00:18:22,490 --> 00:18:30,740
attribute can point basically anywhere

00:18:26,419 --> 00:18:33,020
and this is a problem because you don't

00:18:30,740 --> 00:18:36,140
know the set of input files to be great

00:18:33,020 --> 00:18:39,950
until you actually compile the crate in

00:18:36,140 --> 00:18:42,530
rust analyzer I sort of explicitly do

00:18:39,950 --> 00:18:46,970
not solve this problem I require a set

00:18:42,530 --> 00:18:49,309
of files to be known upfront so that all

00:18:46,970 --> 00:18:53,600
the i/o can be done outside the rest in

00:18:49,309 --> 00:18:55,700
wiser and the trust analyzer can just

00:18:53,600 --> 00:19:01,460
know the contents of the old file files

00:18:55,700 --> 00:19:05,659
it's could potentially need so this

00:19:01,460 --> 00:19:09,260
means that like in return Eliza this

00:19:05,659 --> 00:19:13,280
path wouldn't be resolved you can by

00:19:09,260 --> 00:19:15,500
default you can only refer the path

00:19:13,280 --> 00:19:17,600
attribute all the edges usual not

00:19:15,500 --> 00:19:20,179
statement or the include derivative to

00:19:17,600 --> 00:19:25,640
the files in the same source root

00:19:20,179 --> 00:19:30,559
because you can only write relative path

00:19:25,640 --> 00:19:32,960
here of course if you really need to

00:19:30,559 --> 00:19:35,000
refer to another file by absolute path

00:19:32,960 --> 00:19:38,030
or you need to refer to a file

00:19:35,000 --> 00:19:39,650
not from this directory you confirm

00:19:38,030 --> 00:19:42,890
isn't implemented here but it could be

00:19:39,650 --> 00:19:46,760
implemented you can explicitly add these

00:19:42,890 --> 00:19:48,169
extra files to sauce road but again it

00:19:46,760 --> 00:19:50,539
doesn't break this like fundamental

00:19:48,169 --> 00:19:53,059
assumption that before the calculation

00:19:50,539 --> 00:19:57,320
rust analyzer knows about all possible

00:19:53,059 --> 00:20:00,080
files which might be involved okay so

00:19:57,320 --> 00:20:06,049
this concludes the site about source

00:20:00,080 --> 00:20:09,799
roads let's actually see how we expose

00:20:06,049 --> 00:20:12,830
this API to the outside world we do it

00:20:09,799 --> 00:20:15,919
the language server protocol which

00:20:12,830 --> 00:20:21,409
leaves in a separate crate the core of

00:20:15,919 --> 00:20:24,200
the protocol is these event loop which

00:20:21,409 --> 00:20:26,059
will handle events and there are a ton

00:20:24,200 --> 00:20:29,059
of events which we might handle here

00:20:26,059 --> 00:20:34,329
first of all

00:20:29,059 --> 00:20:37,399
we watch like not really watch but watch

00:20:34,329 --> 00:20:40,909
file system for changes so one possible

00:20:37,399 --> 00:20:43,969
event is that like user change branches

00:20:40,909 --> 00:20:47,209
and the contents of the files on disk

00:20:43,969 --> 00:20:50,209
changed another source of events is the

00:20:47,209 --> 00:20:53,149
editor once the editor learner user type

00:20:50,209 --> 00:20:56,209
something in the editor the lp client in

00:20:53,149 --> 00:20:59,089
the editor sends us notification about

00:20:56,209 --> 00:21:04,789
hey this file is now has new contents

00:20:59,089 --> 00:21:08,569
and yes source of concurrency here is

00:21:04,789 --> 00:21:09,559
our burger on position when the client

00:21:08,569 --> 00:21:12,829
should press from his Appleseed extract

00:21:09,559 --> 00:21:16,999
information we schedule a big round fret

00:21:12,829 --> 00:21:19,339
to compute recent expediting which

00:21:16,999 --> 00:21:21,519
allows us not to block the main loop and

00:21:19,339 --> 00:21:24,049
to process changes quickly and

00:21:21,519 --> 00:21:27,259
Brandenburger now change background

00:21:24,049 --> 00:21:29,389
thread finishes it sends the results

00:21:27,259 --> 00:21:33,619
back to menu and all communication

00:21:29,389 --> 00:21:37,209
happens on the main okay so how do we

00:21:33,619 --> 00:21:37,209
actually get here in the first place

00:21:37,299 --> 00:21:47,869
from the main loop method and what this

00:21:43,279 --> 00:21:52,969
method does initially it creates this

00:21:47,869 --> 00:21:59,779
great graph input from the cargo net

00:21:52,969 --> 00:22:03,229
data command so let's just walk for a

00:21:59,779 --> 00:22:06,109
tortilla this method is executed this

00:22:03,229 --> 00:22:10,489
function is executed too many cotton

00:22:06,109 --> 00:22:13,809
programming for me it's executed when

00:22:10,489 --> 00:22:17,839
you start a server and it knows about

00:22:13,809 --> 00:22:20,299
here it notes about the root directory

00:22:17,839 --> 00:22:23,619
where the editor will start a project

00:22:20,299 --> 00:22:29,649
you take the first thing we do is we

00:22:23,619 --> 00:22:29,649
send this route to load workspaces

00:22:30,260 --> 00:22:34,460
it's works but yeah it's workspace

00:22:32,450 --> 00:22:37,550
loader so like it's like something which

00:22:34,460 --> 00:22:39,950
loads project workspace in the

00:22:37,550 --> 00:22:42,610
background and project workspace is

00:22:39,950 --> 00:22:45,710
consists of two parts first of all it's

00:22:42,610 --> 00:22:48,410
the cargo workspace with all crates from

00:22:45,710 --> 00:22:53,270
Casio and with local crates and it is

00:22:48,410 --> 00:22:59,240
also the see sort of the crates like

00:22:53,270 --> 00:23:01,940
summit library core etc so yeah how do

00:22:59,240 --> 00:23:06,290
we trade project workspace first of all

00:23:01,940 --> 00:23:11,570
we find carbothermal then we need cargo

00:23:06,290 --> 00:23:15,850
metadata then we reach this route and

00:23:11,570 --> 00:23:18,680
return the scene and remanded this

00:23:15,850 --> 00:23:23,150
vegetation is like a really cargo

00:23:18,680 --> 00:23:26,750
centric really OC and centric while the

00:23:23,150 --> 00:23:29,750
data we have in analysis this graph is

00:23:26,750 --> 00:23:36,070
completely built system independent so

00:23:29,750 --> 00:23:40,820
once we've got that project we need to

00:23:36,070 --> 00:23:44,900
lower this cargo port information to

00:23:40,820 --> 00:23:49,490
analyzer format and this happens inside

00:23:44,900 --> 00:23:52,670
server state so the world state is banks

00:23:49,490 --> 00:23:54,440
together analysis host and the

00:23:52,670 --> 00:23:59,300
information which I know this house does

00:23:54,440 --> 00:24:02,600
not have specifically the absolute paths

00:23:59,300 --> 00:24:05,660
to source suits in the ad FS and the

00:24:02,600 --> 00:24:08,990
information about cargo workspaces we

00:24:05,660 --> 00:24:11,270
are this like pocket or a struct okay

00:24:08,990 --> 00:24:13,580
and so this lowering of product

00:24:11,270 --> 00:24:15,980
workspace to something which rot

00:24:13,580 --> 00:24:19,460
analyzer can work happens in this new

00:24:15,980 --> 00:24:23,180
method so if it's fall

00:24:19,460 --> 00:24:24,680
we need create source route substitutes

00:24:23,180 --> 00:24:27,460
we create source routes for which

00:24:24,680 --> 00:24:34,120
packaged in cargo workspace and for each

00:24:27,460 --> 00:24:39,800
create in the SIS route and we yeah we

00:24:34,120 --> 00:24:42,170
schedule to read recursively the

00:24:39,800 --> 00:24:47,870
contents of the source code all the rest

00:24:42,170 --> 00:24:51,230
files here the results this like file

00:24:47,870 --> 00:24:54,170
system scanning will be handled as other

00:24:51,230 --> 00:24:56,870
modifications in the main loop okay

00:24:54,170 --> 00:24:58,970
after we've dealt with this routes which

00:24:56,870 --> 00:25:02,780
basically will give us that file I did

00:24:58,970 --> 00:25:05,480
relative path to source text and we

00:25:02,780 --> 00:25:08,450
reconstruct crave graph and currently

00:25:05,480 --> 00:25:10,550
this is somewhat approximate because we

00:25:08,450 --> 00:25:12,740
don't really handle a CFG changes we

00:25:10,550 --> 00:25:15,350
don't really handle total specific

00:25:12,740 --> 00:25:18,230
dependencies and actually I believe we

00:25:15,350 --> 00:25:20,840
don't quite have enough information from

00:25:18,230 --> 00:25:22,730
cargo to reconstruct this precisely but

00:25:20,840 --> 00:25:25,150
of course cargo can always be extended

00:25:22,730 --> 00:25:30,640
to provide us with this information

00:25:25,150 --> 00:25:30,640
okay so for each as you sort credit we

00:25:31,840 --> 00:25:43,220
here for each sort rate we we we create

00:25:38,170 --> 00:25:49,430
Rasta noise a crate and for each package

00:25:43,220 --> 00:25:52,840
in cargo workspaces we create rust Eliza

00:25:49,430 --> 00:25:59,060
credit and we stab dependencies between

00:25:52,840 --> 00:26:04,820
sis Road crates from

00:25:59,060 --> 00:26:08,720
sis route to cargo crates and yeah and

00:26:04,820 --> 00:26:10,310
between cargo crates themselves and yeah

00:26:08,720 --> 00:26:11,810
this is like terminology confusion

00:26:10,310 --> 00:26:14,630
because cargo actually talks about

00:26:11,810 --> 00:26:17,780
crates it talks about packages and

00:26:14,630 --> 00:26:19,460
targets and each cargo package has many

00:26:17,780 --> 00:26:21,500
targets like binary target library

00:26:19,460 --> 00:26:26,050
target test targets example targets and

00:26:21,500 --> 00:26:28,880
each target is actually a crate in

00:26:26,050 --> 00:26:30,620
raspily not really crate you really get

00:26:28,880 --> 00:26:31,340
a great when you combine target with

00:26:30,620 --> 00:26:35,390
particular

00:26:31,340 --> 00:26:40,250
CFG flag so for example like cargo build

00:26:35,390 --> 00:26:43,040
leap and cargo - - test - leave -

00:26:40,250 --> 00:26:44,630
national run are two different would be

00:26:43,040 --> 00:26:47,320
two different traits from the rotten

00:26:44,630 --> 00:26:51,560
Eliza perspective but it's probably

00:26:47,320 --> 00:26:55,109
getting into the weeds so yeah after we

00:26:51,560 --> 00:26:57,829
have created a resource graph

00:26:55,109 --> 00:27:04,049
make change with this sauce graph and

00:26:57,829 --> 00:27:05,609
apply apply this change so here how we

00:27:04,049 --> 00:27:08,489
are either the create graph to the

00:27:05,609 --> 00:27:11,759
change okay so let's get back to the

00:27:08,489 --> 00:27:16,320
main loop main loop

00:27:11,759 --> 00:27:19,349
I am so we've loaded the workspace and

00:27:16,320 --> 00:27:22,949
they're currently we load workspace once

00:27:19,349 --> 00:27:25,229
at the start of the server of course it

00:27:22,949 --> 00:27:26,729
should be possible to reload workspace

00:27:25,229 --> 00:27:28,259
later when you like for example add new

00:27:26,729 --> 00:27:33,229
craze or change your cargo tunnel or

00:27:28,259 --> 00:27:35,879
whatever it's just not implemented yet

00:27:33,229 --> 00:27:40,169
and yeah in the main loop in our first

00:27:35,879 --> 00:27:52,319
of all let's see how we react to changes

00:27:40,169 --> 00:27:56,159
to the files yeah so if we get results

00:27:52,319 --> 00:28:02,699
from background file systems can we add

00:27:56,159 --> 00:28:08,579
the results to the FS and if we get a

00:28:02,699 --> 00:28:12,329
notification and this indication is

00:28:08,579 --> 00:28:16,529
about like changing text documents we

00:28:12,329 --> 00:28:21,869
also write this change to the virtual

00:28:16,529 --> 00:28:23,930
file system and at the end of the loop

00:28:21,869 --> 00:28:27,329
term we

00:28:23,930 --> 00:28:27,329
[Music]

00:28:29,250 --> 00:28:34,590
yeah we process all the file system

00:28:32,490 --> 00:28:38,430
changes which we have gotten in this

00:28:34,590 --> 00:28:47,690
loop term and what these basically does

00:28:38,430 --> 00:28:52,830
is that it builds and analysis change

00:28:47,690 --> 00:28:56,580
using changes from the file system at

00:28:52,830 --> 00:29:00,360
file new file etc and eventually we

00:28:56,580 --> 00:29:04,190
apply this change to the analysis

00:29:00,360 --> 00:29:04,190
Constitution like this familiar that

00:29:05,210 --> 00:29:13,530
okay so how do we handle requests well

00:29:11,730 --> 00:29:17,610
we first of all receive a request from

00:29:13,530 --> 00:29:23,270
the client and call on request method

00:29:17,610 --> 00:29:27,180
and this request method schedules

00:29:23,270 --> 00:29:29,880
request to be run on a different pool so

00:29:27,180 --> 00:29:32,640
this world is this third world structure

00:29:29,880 --> 00:29:38,070
which contains analysis first instance

00:29:32,640 --> 00:29:41,940
the snapshot basically gets us an

00:29:38,070 --> 00:29:45,750
analysis from this analysis first and we

00:29:41,940 --> 00:29:52,470
move a days analysis to the separate

00:29:45,750 --> 00:29:54,330
thread you remember that while this is

00:29:52,470 --> 00:29:57,180
refuting on a separate thread on the

00:29:54,330 --> 00:29:59,520
main thread we can receive a file change

00:29:57,180 --> 00:30:01,830
notification which will call apply

00:29:59,520 --> 00:30:08,100
change method on by analysis which will

00:30:01,830 --> 00:30:11,850
cancel the background thread and we get

00:30:08,100 --> 00:30:14,130
I cannot ever here and return a contact

00:30:11,850 --> 00:30:17,190
modified error to the editor and you

00:30:14,130 --> 00:30:19,110
actually have already seen this so this

00:30:17,190 --> 00:30:22,830
is the debugger output from rat analyzer

00:30:19,110 --> 00:30:26,760
and this is what happened when I've just

00:30:22,830 --> 00:30:28,980
opened their project the editor started

00:30:26,760 --> 00:30:32,370
to ask me about hot lenses about

00:30:28,980 --> 00:30:34,410
collections at cursor cetera cetera at

00:30:32,370 --> 00:30:39,120
the same time the rotten Eliza was

00:30:34,410 --> 00:30:43,060
actively scanning the source code so all

00:30:39,120 --> 00:30:45,370
those requests got cancelled initially

00:30:43,060 --> 00:30:48,970
and then after the scanning was

00:30:45,370 --> 00:30:51,550
completed the client asked these

00:30:48,970 --> 00:30:56,380
requests again and got highlighting to

00:30:51,550 --> 00:31:06,390
Twitter so yeah let's take a look for

00:30:56,380 --> 00:31:10,510
example on something like go to

00:31:06,390 --> 00:31:13,750
definition so we receive this yeah

00:31:10,510 --> 00:31:15,340
notification request and call handle on

00:31:13,750 --> 00:31:17,410
the background frantic call and we'll go

00:31:15,340 --> 00:31:21,520
to definition function this function

00:31:17,410 --> 00:31:23,260
first converts the request from language

00:31:21,520 --> 00:31:26,710
server protocol specific implementation

00:31:23,260 --> 00:31:30,130
to rest and lies implementation this

00:31:26,710 --> 00:31:35,410
basically means mapping file URLs to

00:31:30,130 --> 00:31:42,220
file IDs then it calls method inside

00:31:35,410 --> 00:31:44,650
analysis and converse results back to

00:31:42,220 --> 00:31:48,030
the language server protocol types and

00:31:44,650 --> 00:31:52,800
responds with the appropriate response

00:31:48,030 --> 00:31:57,100
okay I think this concludes the basic

00:31:52,800 --> 00:31:59,740
walkthrough around API of rust analyzer

00:31:57,100 --> 00:32:01,510
you have the stateful actor and you have

00:31:59,740 --> 00:32:03,970
this elaborate translation system and

00:32:01,510 --> 00:32:06,700
you need to be very careful about not

00:32:03,970 --> 00:32:09,160
leaking details about like your build

00:32:06,700 --> 00:32:09,610
system your absolute file path etcetera

00:32:09,160 --> 00:32:11,620
etcetera

00:32:09,610 --> 00:32:14,430
inside the analyzer itself so that

00:32:11,620 --> 00:32:20,140
analyzer can be a predictable reliable

00:32:14,430 --> 00:32:23,500
pure function now we actually are

00:32:20,140 --> 00:32:26,260
getting to the interesting bit what is

00:32:23,500 --> 00:32:30,700
the implementation of rust analyzer how

00:32:26,260 --> 00:32:33,790
managed solve everything quickly so one

00:32:30,700 --> 00:32:36,760
approach would be to basically maintain

00:32:33,790 --> 00:32:38,800
the current state of the world if you

00:32:36,760 --> 00:32:41,910
like cold state of all inputs internal

00:32:38,800 --> 00:32:45,400
as an add-on every applied change

00:32:41,910 --> 00:32:47,110
schedule a completion which compels the

00:32:45,400 --> 00:32:50,710
whole crate possibly incrementally and

00:32:47,110 --> 00:32:54,190
then serves requests to the client and

00:32:50,710 --> 00:32:55,230
this is actually what account

00:32:54,190 --> 00:32:58,020
architecture

00:32:55,230 --> 00:33:01,110
of rust language Sarah RLS looks like if

00:32:58,020 --> 00:33:03,540
you squint enough

00:33:01,110 --> 00:33:07,020
unfortunately social protection is

00:33:03,540 --> 00:33:08,910
necessary slow even if you incremental

00:33:07,020 --> 00:33:11,250
II compare the whole treasure at the

00:33:08,910 --> 00:33:13,410
whole crate or the whole set of crates

00:33:11,250 --> 00:33:16,080
of your workspace you are doing a lot of

00:33:13,410 --> 00:33:18,510
useless work because you see now I have

00:33:16,080 --> 00:33:21,419
only a single file opened in my editor

00:33:18,510 --> 00:33:25,590
and I really don't care at all about all

00:33:21,419 --> 00:33:32,880
information except information for the

00:33:25,590 --> 00:33:36,000
lies between 239 and 283 and this real

00:33:32,880 --> 00:33:39,780
little place where we need these ability

00:33:36,000 --> 00:33:43,799
to only query a specific subset of the e

00:33:39,780 --> 00:33:48,710
confession so how do we do this

00:33:43,799 --> 00:34:00,929
it's the magic sauce here we use the

00:33:48,710 --> 00:34:05,400
salsa crate definition because it's a

00:34:00,929 --> 00:34:08,669
rigged spurt and it is yeah okay so

00:34:05,400 --> 00:34:14,070
that's not everything works of course

00:34:08,669 --> 00:34:16,619
let's do it's the other way yes so this

00:34:14,070 --> 00:34:21,600
is the source code of the dependency

00:34:16,619 --> 00:34:25,530
from crater or salsa salsa is awesome

00:34:21,600 --> 00:34:28,740
crate it allows you to have a database

00:34:25,530 --> 00:34:29,909
of queries and it allows you to execute

00:34:28,740 --> 00:34:33,210
these quotes

00:34:29,909 --> 00:34:34,649
both incremental e and on-demand what

00:34:33,210 --> 00:34:38,040
this means is the fact for example if

00:34:34,649 --> 00:34:41,369
you have a query which uses the results

00:34:38,040 --> 00:34:45,619
of Kurumi when you apply changes to the

00:34:41,369 --> 00:34:48,119
inputs salsa will be smart enough to

00:34:45,619 --> 00:34:50,460
recompute the B if it could have been

00:34:48,119 --> 00:34:53,129
changed by the changes to the inputs but

00:34:50,460 --> 00:34:56,550
avoid you computing the a if the results

00:34:53,129 --> 00:34:59,850
of recomputing to be actually stays the

00:34:56,550 --> 00:35:02,580
same so if you don't know about salsa

00:34:59,850 --> 00:35:04,650
already my expansion probably doesn't

00:35:02,580 --> 00:35:06,770
make this easier for you so just stop

00:35:04,650 --> 00:35:12,130
the video and read some documentation

00:35:06,770 --> 00:35:17,180
salsa okay so let's see a concrete

00:35:12,130 --> 00:35:20,900
example of a salsa database well no

00:35:17,180 --> 00:35:25,010
let's just verify that like actually

00:35:20,900 --> 00:35:27,619
actually all this state which analysis

00:35:25,010 --> 00:35:32,450
holes is basically these salsa database

00:35:27,619 --> 00:35:34,550
and this is true both for analysis host

00:35:32,450 --> 00:35:40,540
and for analysis and now let's take a

00:35:34,550 --> 00:35:43,700
look at this database what well it has a

00:35:40,540 --> 00:35:49,820
bunch of queries for different things

00:35:43,700 --> 00:35:56,500
and probably yes and probably the most

00:35:49,820 --> 00:35:56,500
interesting part of it database is input

00:35:57,010 --> 00:36:02,410
input data base input it should be

00:36:06,869 --> 00:36:13,900
we just called inputs database isn't it

00:36:10,539 --> 00:36:15,489
Oh so it's it's not called infant

00:36:13,900 --> 00:36:18,999
database it's called files database

00:36:15,489 --> 00:36:22,630
that's why I haven't found so and this

00:36:18,999 --> 00:36:25,509
database describes the whole set of

00:36:22,630 --> 00:36:27,999
inputs to the salsa and basically a

00:36:25,509 --> 00:36:30,190
response to that analysis change data

00:36:27,999 --> 00:36:32,319
structure as you see if the set of

00:36:30,190 --> 00:36:34,469
inputs is like really really small you

00:36:32,319 --> 00:36:37,809
have files and each file has a text

00:36:34,469 --> 00:36:41,349
relative path inside a sore throat and a

00:36:37,809 --> 00:36:46,329
source or a source root has a set of

00:36:41,349 --> 00:36:50,229
files locals his roots is optimization

00:36:46,329 --> 00:36:52,089
to know which rules correspond to files

00:36:50,229 --> 00:36:54,459
inside the current workspace and which

00:36:52,089 --> 00:37:00,160
rules corresponds to cranes from crazy

00:36:54,459 --> 00:37:02,079
or and for criteria we do one time not

00:37:00,160 --> 00:37:06,579
really do but in some parts we do a

00:37:02,079 --> 00:37:09,809
top-down one time processing which would

00:37:06,579 --> 00:37:14,140
be and we like produces a really compact

00:37:09,809 --> 00:37:17,349
data structures modify such for the

00:37:14,140 --> 00:37:19,209
whole credit structures is costly so we

00:37:17,349 --> 00:37:21,160
use more fine-grained data structures

00:37:19,209 --> 00:37:25,170
for local trades but for great sale

00:37:21,160 --> 00:37:29,079
price which do not change this is a week

00:37:25,170 --> 00:37:31,239
so libraries roots is the complement of

00:37:29,079 --> 00:37:34,779
local rules and the credit graph is V

00:37:31,239 --> 00:37:39,509
phonetic regular so basically everything

00:37:34,779 --> 00:37:42,509
else is direct consequences of these

00:37:39,509 --> 00:37:42,509
data

00:37:47,310 --> 00:37:59,220
so the main thing which we get out of

00:37:55,660 --> 00:38:01,990
this database is the code model API

00:37:59,220 --> 00:38:04,630
remember how I said that like analysis

00:38:01,990 --> 00:38:07,650
operates on spans and files and does not

00:38:04,630 --> 00:38:11,380
know about the cross specific stuff so

00:38:07,650 --> 00:38:13,750
this is the lower level API which I was

00:38:11,380 --> 00:38:21,750
talking about which talks about what

00:38:13,750 --> 00:38:21,750
specific contents like crates modules

00:38:25,680 --> 00:38:33,279
structs

00:38:28,470 --> 00:38:37,420
animals etc and all these types are

00:38:33,279 --> 00:38:41,769
represented by an ID and have a bunch of

00:38:37,420 --> 00:38:44,440
methods which all take a database as an

00:38:41,769 --> 00:38:50,549
argument and return some of and I find

00:38:44,440 --> 00:38:55,839
great information for example for module

00:38:50,549 --> 00:38:58,869
you can get a scope and scope defines

00:38:55,839 --> 00:39:00,880
the set of names defined in this module

00:38:58,869 --> 00:39:02,910
so you can imagine how these powers from

00:39:00,880 --> 00:39:07,450
sample completion or go to diffusion

00:39:02,910 --> 00:39:11,109
access for cetera and what the bulk of

00:39:07,450 --> 00:39:13,839
rust analyzer does is that it provides a

00:39:11,109 --> 00:39:18,009
queries which populate this a rich

00:39:13,839 --> 00:39:23,069
semantic model so what are we going to

00:39:18,009 --> 00:39:23,069
talk about next

00:39:25,140 --> 00:39:32,910
yeah so probably a good thing to talk

00:39:27,940 --> 00:39:39,599
about now is that specifics of rust

00:39:32,910 --> 00:39:42,220
where a single source file may

00:39:39,599 --> 00:39:46,569
correspond to several semantic panels

00:39:42,220 --> 00:39:50,670
and this is something explicitly handled

00:39:46,569 --> 00:39:54,039
in the rust analyzer in this source

00:39:50,670 --> 00:39:56,019
binders infrastructure so what this

00:39:54,039 --> 00:40:00,190
source binder infrastructure does is

00:39:56,019 --> 00:40:02,140
that it takes an information about the

00:40:00,190 --> 00:40:04,900
source code the actual files which are

00:40:02,140 --> 00:40:07,630
on disk like here is like the file ID

00:40:04,900 --> 00:40:12,759
and the syntax of a particular module

00:40:07,630 --> 00:40:16,119
node and it returns a semantic model for

00:40:12,759 --> 00:40:18,099
this source node and it does it

00:40:16,119 --> 00:40:20,799
basically by getting so it like picks a

00:40:18,099 --> 00:40:23,559
fast semantic model which corresponds to

00:40:20,799 --> 00:40:25,569
the source so this is like and naturally

00:40:23,559 --> 00:40:28,839
always a transformation but it is only

00:40:25,569 --> 00:40:30,910
cold within the IDE code and so for

00:40:28,839 --> 00:40:33,670
example if you like running completion

00:40:30,910 --> 00:40:37,720
inside the function this function might

00:40:33,670 --> 00:40:38,690
be present in several crates and in the

00:40:37,720 --> 00:40:41,810
current architecture

00:40:38,690 --> 00:40:44,510
you pick a single crate and run

00:40:41,810 --> 00:40:46,730
completions compute completions for that

00:40:44,510 --> 00:40:48,500
of course it will be possible to like

00:40:46,730 --> 00:40:51,349
return not an option but like some kind

00:40:48,500 --> 00:40:54,140
of life iterable iterator where item is

00:40:51,349 --> 00:40:58,339
a module and like somehow no results but

00:40:54,140 --> 00:41:00,560
it will be more work and hopefully we

00:40:58,339 --> 00:41:04,550
will get a situation where the majority

00:41:00,560 --> 00:41:06,319
of the crates correspond the where the

00:41:04,550 --> 00:41:08,869
majority of a source code responds only

00:41:06,319 --> 00:41:12,440
to a single semantic model so we use

00:41:08,869 --> 00:41:17,869
option which is an iterator of 0 or 1

00:41:12,440 --> 00:41:20,569
item okay so let's just see how we

00:41:17,869 --> 00:41:23,930
actually populate this model how we

00:41:20,569 --> 00:41:29,420
actually grades module score cetera this

00:41:23,930 --> 00:41:35,270
of course starts with a syntax and yeah

00:41:29,420 --> 00:41:37,280
I have seen things database great great

00:41:35,270 --> 00:41:41,869
thing about Trust is that to parse

00:41:37,280 --> 00:41:42,740
source code you don't need to know these

00:41:41,869 --> 00:41:44,390
matically

00:41:42,740 --> 00:41:48,550
and by parsing I mean that literal

00:41:44,390 --> 00:41:52,700
parsing I don't mean macro expansion so

00:41:48,550 --> 00:41:54,470
that's why I the method parser

00:41:52,700 --> 00:41:57,829
it's called source file but probably

00:41:54,470 --> 00:42:01,160
should have been called parse accepts a

00:41:57,829 --> 00:42:02,990
file ad does not know in the context of

00:42:01,160 --> 00:42:06,650
which crate we are parsing this file and

00:42:02,990 --> 00:42:11,119
it returns a source file and the source

00:42:06,650 --> 00:42:15,770
file is basically and now in the

00:42:11,119 --> 00:42:18,710
abstract syntax tree so I wouldn't talk

00:42:15,770 --> 00:42:23,180
too much about syntax tree we are using

00:42:18,710 --> 00:42:26,290
here it spiders to say that this syntax

00:42:23,180 --> 00:42:28,369
tree lossless and they explicitly

00:42:26,290 --> 00:42:31,220
represent all the comments and

00:42:28,369 --> 00:42:35,569
whitespace and they have this like apart

00:42:31,220 --> 00:42:38,300
pointers and they have offsets to give a

00:42:35,569 --> 00:42:40,790
route length and immutable and chippie

00:42:38,300 --> 00:42:44,420
chippie update and they are very much

00:42:40,790 --> 00:42:46,609
inspired by what I've seen in Swift

00:42:44,420 --> 00:42:51,319
sleep syntax in roasting and the

00:42:46,609 --> 00:42:54,829
couraging so just to get a feeling what

00:42:51,319 --> 00:43:01,009
a syntax tree looks like let's take a

00:42:54,829 --> 00:43:03,859
look at the assists so assists are well

00:43:01,009 --> 00:43:07,519
why should I explain what an assist if

00:43:03,859 --> 00:43:10,549
if I can just just give you an example

00:43:07,519 --> 00:43:15,170
so this is replace if let's with much

00:43:10,549 --> 00:43:17,529
what it does is if you have code like

00:43:15,170 --> 00:43:17,529
this

00:43:22,550 --> 00:43:33,050
do this do it assist replaces this if

00:43:30,380 --> 00:43:35,210
with match which to my mind looks

00:43:33,050 --> 00:43:39,230
ultimate cleaner and more symmetrical

00:43:35,210 --> 00:43:43,310
and this is a purely syntax to

00:43:39,230 --> 00:43:45,500
transformation so here is the code for

00:43:43,310 --> 00:43:52,810
all these things like if you see you not

00:43:45,500 --> 00:43:55,910
not to complicate it first we find a

00:43:52,810 --> 00:44:00,650
center and if expression at the current

00:43:55,910 --> 00:44:03,350
cursor position so let's let's take a

00:44:00,650 --> 00:44:06,410
look how we do it so this is the assist

00:44:03,350 --> 00:44:08,480
context assistance contact can we go to

00:44:06,410 --> 00:44:19,940
self here no we can't go to self here

00:44:08,480 --> 00:44:23,060
too bad assets assist context contains a

00:44:19,940 --> 00:44:26,420
source file and basically the range at

00:44:23,060 --> 00:44:29,290
which the intention wasn't work involved

00:44:26,420 --> 00:44:31,580
great thing about assists is that the

00:44:29,290 --> 00:44:35,810
activated in the specific context for

00:44:31,580 --> 00:44:38,750
example here I can add Drive because I

00:44:35,810 --> 00:44:40,130
am inside a structure but if an outside

00:44:38,750 --> 00:44:44,750
the structure I don't have this

00:44:40,130 --> 00:44:49,460
intention which is great so this is

00:44:44,750 --> 00:44:58,240
context contains contains a range and

00:44:49,460 --> 00:44:58,240
the source file and ok I've lost

00:44:58,680 --> 00:45:07,950
we were here and we were studied another

00:45:03,339 --> 00:45:13,150
nonsense even some yeah

00:45:07,950 --> 00:45:15,249
okay and so first thing which we need to

00:45:13,150 --> 00:45:17,259
do to replace even if match is that we

00:45:15,249 --> 00:45:19,960
need to find an eighth note at the

00:45:17,259 --> 00:45:25,019
current cursor position it's what this

00:45:19,960 --> 00:45:25,019
method does let's take a look at the

00:45:25,170 --> 00:45:32,289
implementation yeah so first of all we

00:45:28,779 --> 00:45:36,910
find a leaf node in this industry at

00:45:32,289 --> 00:45:39,460
this offset and then we look at the

00:45:36,910 --> 00:45:42,309
ancestors of this node and it's like a

00:45:39,460 --> 00:45:44,109
great part a great feature of its API

00:45:42,309 --> 00:45:46,900
providing this sort of assist that you

00:45:44,109 --> 00:45:48,640
do actually have parent pointers and you

00:45:46,900 --> 00:45:51,279
have a uniform representation of a

00:45:48,640 --> 00:45:53,829
syntax tree so that you can get and like

00:45:51,279 --> 00:45:55,839
syntax node which represents anything

00:45:53,829 --> 00:46:01,410
extract the function talking etcetera

00:45:55,839 --> 00:46:05,380
etcetera and you actually find the node

00:46:01,410 --> 00:46:07,720
which is an expression using this cast

00:46:05,380 --> 00:46:11,140
method so despite the fact that you have

00:46:07,720 --> 00:46:13,569
like this a uniform representation you

00:46:11,140 --> 00:46:15,130
can also switch to world type to

00:46:13,569 --> 00:46:17,799
presentation like an if expression which

00:46:15,130 --> 00:46:22,089
has an addition and Enbridge and health

00:46:17,799 --> 00:46:25,739
branch and in across lean in swift in

00:46:22,089 --> 00:46:28,210
IntelliJ this is achieved by using

00:46:25,739 --> 00:46:31,210
basically inheritance so you have like

00:46:28,210 --> 00:46:32,739
basic syntax node interface and all the

00:46:31,210 --> 00:46:34,749
concrete syntax not like if expression

00:46:32,739 --> 00:46:37,059
class declarations at read cetera

00:46:34,749 --> 00:46:41,410
inherit from this interface and you just

00:46:37,059 --> 00:46:45,369
use casts and rusts resistant basically

00:46:41,410 --> 00:46:48,249
some neat magic it's not treat objects

00:46:45,369 --> 00:46:51,249
it's basically just a little bit of

00:46:48,249 --> 00:46:52,930
transmutes but they should be safe if

00:46:51,249 --> 00:46:56,319
you are interested in a girl read the

00:46:52,930 --> 00:46:59,950
documentation for the role and crate

00:46:56,319 --> 00:47:03,970
which is actually what powers set of

00:46:59,950 --> 00:47:07,210
trees so I'm back in the weeds again and

00:47:03,970 --> 00:47:13,720
we won't wanted to

00:47:07,210 --> 00:47:15,280
to replace much replace yes we wanted to

00:47:13,720 --> 00:47:19,630
replace my frigate lat

00:47:15,280 --> 00:47:24,640
so we get an if expression and we give a

00:47:19,630 --> 00:47:27,490
condition we get a pattern and we get an

00:47:24,640 --> 00:47:32,160
expression and you notice that all of

00:47:27,490 --> 00:47:36,849
these methods overturns options so well

00:47:32,160 --> 00:47:39,880
rust centers requires that each

00:47:36,849 --> 00:47:46,089
expression has a condition and pattern

00:47:39,880 --> 00:47:48,790
and then branch the syntax tree I use in

00:47:46,089 --> 00:47:58,300
rotten eliezer allows you to amidst

00:47:48,790 --> 00:48:03,369
these things so let's see this and

00:47:58,300 --> 00:48:07,089
that's the US industry for this file so

00:48:03,369 --> 00:48:09,460
yep here I've typed a fun food so it's

00:48:07,089 --> 00:48:12,580
definitely not rat function definition

00:48:09,460 --> 00:48:15,089
because it misses parameters it misses

00:48:12,580 --> 00:48:17,890
return type but it's a etc nevertheless

00:48:15,089 --> 00:48:20,770
on the right we see that in the syntax

00:48:17,890 --> 00:48:24,520
tree we actually have this function

00:48:20,770 --> 00:48:26,410
definition when we make a complete

00:48:24,520 --> 00:48:28,570
syntax or or disappear the wire it

00:48:26,410 --> 00:48:34,420
doesn't complete we get a rascal here

00:48:28,570 --> 00:48:37,839
you can find an error and so we can yeah

00:48:34,420 --> 00:48:40,690
right and if expression here and we see

00:48:37,839 --> 00:48:47,080
to write that with have an if expression

00:48:40,690 --> 00:48:49,060
and its condition is broken because it's

00:48:47,080 --> 00:48:52,060
like a birth block expression it doesn't

00:48:49,060 --> 00:48:54,540
have the engine else right but we do

00:48:52,060 --> 00:48:57,490
know that this is an if expression and

00:48:54,540 --> 00:48:59,550
another like great thing about this is

00:48:57,490 --> 00:48:59,550
that

00:49:01,070 --> 00:49:11,040
direct whoo yeah very bar I despite all

00:49:08,820 --> 00:49:15,500
of this being incomplete and unfinished

00:49:11,040 --> 00:49:23,460
we actually don't break parsing of

00:49:15,500 --> 00:49:29,190
subsequent stuff so at the trade bar is

00:49:23,460 --> 00:49:32,870
parsed completely without errors despite

00:49:29,190 --> 00:49:37,200
the errors present in the previous files

00:49:32,870 --> 00:49:42,330
so yeah it's that's another aspect of

00:49:37,200 --> 00:49:45,090
this industries is that they allow you

00:49:42,330 --> 00:49:47,720
to produce partial syntax tree and don't

00:49:45,090 --> 00:49:51,750
care a lot if some essential business

00:49:47,720 --> 00:49:54,300
nevertheless if we are indeed in the if

00:49:51,750 --> 00:49:56,130
expression and if this is a fairly

00:49:54,300 --> 00:50:01,680
complete expression which has a

00:49:56,130 --> 00:50:08,660
condition pattern a 10-block and an else

00:50:01,680 --> 00:50:11,940
block we actually suggest and edit which

00:50:08,660 --> 00:50:13,530
is if flat and transforms it into much

00:50:11,940 --> 00:50:16,260
expression oh yeah

00:50:13,530 --> 00:50:22,080
if and if flat are both represented by

00:50:16,260 --> 00:50:24,720
the same if expert datatype okay

00:50:22,080 --> 00:50:28,890
just to give a quick peek at the

00:50:24,720 --> 00:50:30,750
implementation of the if expression and

00:50:28,890 --> 00:50:33,480
those mysterious words about

00:50:30,750 --> 00:50:35,700
transmitting forecasting if expression

00:50:33,480 --> 00:50:38,240
internally like and each eistein are

00:50:35,700 --> 00:50:42,560
terminally holds this index node and

00:50:38,240 --> 00:50:47,910
this index node is this like homogeneous

00:50:42,560 --> 00:50:50,910
node which has parent we shouldn't index

00:50:47,910 --> 00:50:53,130
node first child last child next sibling

00:50:50,910 --> 00:51:01,820
very simple in which all returns that's

00:50:53,130 --> 00:51:05,190
now and if expression is sort of neutral

00:51:01,820 --> 00:51:08,340
around aesthetics node and what this new

00:51:05,190 --> 00:51:11,370
type adds it has a static knowledge that

00:51:08,340 --> 00:51:13,660
the syntax note indeed returns an if

00:51:11,370 --> 00:51:15,910
expression and so

00:51:13,660 --> 00:51:18,819
custom works and what's the interesting

00:51:15,910 --> 00:51:21,400
the Caston works even between the

00:51:18,819 --> 00:51:23,770
references you can cast a reference the

00:51:21,400 --> 00:51:26,650
subjects not to make a reference to an

00:51:23,770 --> 00:51:30,069
if expression and that's because we use

00:51:26,650 --> 00:51:33,160
this transparent rock around a tiny bit

00:51:30,069 --> 00:51:35,619
of unsafe code which should say but if

00:51:33,160 --> 00:51:38,500
you actually do this it will be grateful

00:51:35,619 --> 00:51:44,500
because I am NOT that comfortable way of

00:51:38,500 --> 00:51:46,690
writing and safe go so going back to

00:51:44,500 --> 00:51:54,400
semantic model what we've actually

00:51:46,690 --> 00:51:57,579
talked about was how do we get how do we

00:51:54,400 --> 00:52:00,609
get this syntax database and this is

00:51:57,579 --> 00:52:03,369
also a salsa query so each file is

00:52:00,609 --> 00:52:10,359
parsed read lately only when we request

00:52:03,369 --> 00:52:15,190
the parse tree and the results analyze

00:52:10,359 --> 00:52:19,240
so you parse each trial on the ones well

00:52:15,190 --> 00:52:22,390
actually in theory what I am trying to

00:52:19,240 --> 00:52:23,859
do is to make this syntax tree which are

00:52:22,390 --> 00:52:25,450
a relatively heavy data structure

00:52:23,859 --> 00:52:28,150
because they remember all whitespace and

00:52:25,450 --> 00:52:31,420
commences etcetera and the highly

00:52:28,150 --> 00:52:33,910
pointer based to be a really temporary

00:52:31,420 --> 00:52:36,940
thing in the compiled it generally only

00:52:33,910 --> 00:52:40,750
the source file opened in the editor

00:52:36,940 --> 00:52:42,940
should have a syntax tree present in

00:52:40,750 --> 00:52:45,910
memory for all the other files

00:52:42,940 --> 00:52:49,079
I would love to lower this index to

00:52:45,910 --> 00:52:52,299
representation into some kind of like

00:52:49,079 --> 00:52:55,690
pact of representation with indexes and

00:52:52,299 --> 00:53:01,180
lots of stuff and just use that and we

00:52:55,690 --> 00:53:07,660
actually see all of this later so we get

00:53:01,180 --> 00:53:13,450
this syntax we get this okay and how do

00:53:07,660 --> 00:53:15,760
we get from syntax to what other source

00:53:13,450 --> 00:53:18,990
starts with building a module tree

00:53:15,760 --> 00:53:21,520
because really every item in rust is

00:53:18,990 --> 00:53:22,640
within the context of a particular

00:53:21,520 --> 00:53:26,869
module

00:53:22,640 --> 00:53:33,619
and you really start with building a

00:53:26,869 --> 00:53:36,410
module tree there is salsa query which

00:53:33,619 --> 00:53:39,019
takes source route and returns and

00:53:36,410 --> 00:53:41,749
module T so easily

00:53:39,019 --> 00:53:44,539
this argument should be not a source

00:53:41,749 --> 00:53:46,549
route but a crate because really rust

00:53:44,539 --> 00:53:49,119
builds a module tree for a single crate

00:53:46,549 --> 00:53:53,089
for most historical reasons we built

00:53:49,119 --> 00:53:56,660
module three for all the crates inside a

00:53:53,089 --> 00:53:59,059
particular source route the real reason

00:53:56,660 --> 00:54:00,920
why this is so is just because source

00:53:59,059 --> 00:54:03,890
route appeared and wanted to appear

00:54:00,920 --> 00:54:06,829
before we actually had crates but the

00:54:03,890 --> 00:54:09,410
intentional reason is that there are

00:54:06,829 --> 00:54:12,910
files which are not part of ink right so

00:54:09,410 --> 00:54:12,910
for example I can I don't know

00:54:15,700 --> 00:54:33,319
create a full res file and this res file

00:54:28,009 --> 00:54:37,400
is not part of any crate however I do

00:54:33,319 --> 00:54:40,999
want to get completion as its register

00:54:37,400 --> 00:54:43,039
for this file and the way I do it it

00:54:40,999 --> 00:54:46,579
actually create a sort of like fake

00:54:43,039 --> 00:54:48,200
crate for these floating files and

00:54:46,579 --> 00:54:50,869
usually we should also give a narrative

00:54:48,200 --> 00:54:52,489
a user hey this file is not part of any

00:54:50,869 --> 00:54:54,440
crate would you like to include it in

00:54:52,489 --> 00:54:58,069
Caribou tamil as explicit library or

00:54:54,440 --> 00:55:04,430
test or whatever okay so let's actually

00:54:58,069 --> 00:55:06,920
see how one you have three very works so

00:55:04,430 --> 00:55:08,930
it takes a sore throat and it creates

00:55:06,920 --> 00:55:10,609
this internal deck structure which is

00:55:08,930 --> 00:55:15,710
not a part of the API which is a module

00:55:10,609 --> 00:55:18,099
three it is part here but only for the

00:55:15,710 --> 00:55:20,749
reason that salsa actually cannot have

00:55:18,099 --> 00:55:23,650
private keys and values at the moment

00:55:20,749 --> 00:55:26,960
hopefully I hope that this will be fixed

00:55:23,650 --> 00:55:28,730
so module 3 contains the chief module as

00:55:26,960 --> 00:55:31,430
usual in rust want to have parent

00:55:28,730 --> 00:55:34,309
pointers in our tree and so we start

00:55:31,430 --> 00:55:35,490
really inside the vector and we use in

00:55:34,309 --> 00:55:39,750
exists or

00:55:35,490 --> 00:55:42,090
to particular module and we use an arena

00:55:39,750 --> 00:55:47,930
for the epigenetic basically a vector

00:55:42,090 --> 00:55:52,920
with attacked index so each module

00:55:47,930 --> 00:55:54,690
remembers the motor declaration it

00:55:52,920 --> 00:56:02,040
ordinated from so the sleep it needs

00:55:54,690 --> 00:56:07,050
basically not declaration this thing and

00:56:02,040 --> 00:56:09,270
if one declaration remembers the module

00:56:07,050 --> 00:56:12,060
where the declaration is situated and

00:56:09,270 --> 00:56:14,430
the module this declaration is also two

00:56:12,060 --> 00:56:16,890
points to is a vector to account for

00:56:14,430 --> 00:56:21,530
like resolve errors when you have bought

00:56:16,890 --> 00:56:24,300
both for rest and full / mother s and

00:56:21,530 --> 00:56:27,240
whatever we can have in 2008 in addition

00:56:24,300 --> 00:56:30,090
it's not actually used at the moment if

00:56:27,240 --> 00:56:33,630
I remember correctly so how do we build

00:56:30,090 --> 00:56:36,620
a module to deny way to approach this

00:56:33,630 --> 00:56:41,070
would be to parse each source file

00:56:36,620 --> 00:56:43,380
collect child modules and assemble the

00:56:41,070 --> 00:56:45,230
tree the problem with this approach is

00:56:43,380 --> 00:56:49,560
in criminality

00:56:45,230 --> 00:56:53,940
so such trees are really identity based

00:56:49,560 --> 00:56:57,330
so if user types a single character or

00:56:53,940 --> 00:57:01,980
in the buffer like very tightly spaced

00:56:57,330 --> 00:57:04,890
the hello syntax tree for the file

00:57:01,980 --> 00:57:07,890
changed because well know the syntax

00:57:04,890 --> 00:57:10,350
tree remember parent links and s like

00:57:07,890 --> 00:57:12,870
the file as a whole changed each

00:57:10,350 --> 00:57:19,560
constituent constituent now must change

00:57:12,870 --> 00:57:22,350
as well and that means that if we read

00:57:19,560 --> 00:57:24,600
syntax directly whether it in the module

00:57:22,350 --> 00:57:28,200
tree will have to recompute module 3

00:57:24,600 --> 00:57:30,750
upon every modification and that seems

00:57:28,200 --> 00:57:32,280
really unfortunate because we actually

00:57:30,750 --> 00:57:35,400
would like to do as we would like to

00:57:32,280 --> 00:57:37,830
avoid or computing the module tree

00:57:35,400 --> 00:57:41,100
as long as user type something benign

00:57:37,830 --> 00:57:43,320
like a fan do whatever we only need to

00:57:41,100 --> 00:57:45,630
recompute module treatment user type

00:57:43,320 --> 00:57:46,780
small Safi know when they move files

00:57:45,630 --> 00:57:50,530
around or rename

00:57:46,780 --> 00:57:52,980
or social system and we are shared this

00:57:50,530 --> 00:57:52,980
by

00:57:59,470 --> 00:58:06,299
having an intermediate co-vary let me

00:58:07,200 --> 00:58:18,480
let me see where we actually called this

00:58:09,970 --> 00:58:18,480
query yeah so

00:58:22,390 --> 00:58:32,450
okay it's kind of difficult to start

00:58:29,380 --> 00:58:35,980
okay so let's start from the middle the

00:58:32,450 --> 00:58:40,550
main idea is that we don't actually

00:58:35,980 --> 00:58:44,300
inspect the raw source code we inspect

00:58:40,550 --> 00:58:47,960
result sub modules and sub-modules is a

00:58:44,300 --> 00:58:51,380
query which take which takes a source

00:58:47,960 --> 00:58:55,190
stream and returns a vector of sub

00:58:51,380 --> 00:58:59,150
modules and some module is plain old

00:58:55,190 --> 00:59:04,640
based data which is basically a string

00:58:59,150 --> 00:59:07,670
name and declaration and okay it's hard

00:59:04,640 --> 00:59:10,760
to tell things from the middle and

00:59:07,670 --> 00:59:12,200
pointer in the source tree and okay

00:59:10,760 --> 00:59:13,700
let's pretend that it does not have

00:59:12,200 --> 00:59:17,870
source has on the name and this

00:59:13,700 --> 00:59:20,990
declaration okay so except module is

00:59:17,870 --> 00:59:24,650
this simple then the somebody else query

00:59:20,990 --> 00:59:28,250
is a really nice query because although

00:59:24,650 --> 00:59:30,350
when we change source code we have to

00:59:28,250 --> 00:59:34,310
release acute sub-module square because

00:59:30,350 --> 00:59:37,460
independent source code directed the

00:59:34,310 --> 00:59:40,790
results of the sub-modules query will

00:59:37,460 --> 00:59:45,050
not be changed because well unless you

00:59:40,790 --> 00:59:47,300
type and what rule so again the input to

00:59:45,050 --> 00:59:49,970
the query changes but the output of the

00:59:47,300 --> 00:59:52,550
sub-module square stays the same that

00:59:49,970 --> 00:59:54,920
means that all the queries which depend

00:59:52,550 --> 00:59:59,200
on some module query for example module

00:59:54,920 --> 01:00:01,670
3 query do not have to change when

00:59:59,200 --> 01:00:05,420
unless the actual set of sub modules

01:00:01,670 --> 01:00:07,480
changes in other words user typed

01:00:05,420 --> 01:00:09,950
something in the editor like a space

01:00:07,480 --> 01:00:15,070
sauce it figured out that hey source

01:00:09,950 --> 01:00:17,030
code changes and module 3 indirectly

01:00:15,070 --> 01:00:19,130
depends on the source code so we

01:00:17,030 --> 01:00:22,720
probably need to recompute the module

01:00:19,130 --> 01:00:26,810
tree but they direct dependencies of the

01:00:22,720 --> 01:00:31,610
module 3 query sub modules query and

01:00:26,810 --> 01:00:33,650
Sassa figure out that all except also

01:00:31,610 --> 01:00:35,109
modules queries for all files except

01:00:33,650 --> 01:00:37,599
this one already

01:00:35,109 --> 01:00:39,369
fresh so it only needs to compute this

01:00:37,599 --> 01:00:44,529
single sub-module query for the current

01:00:39,369 --> 01:00:47,709
file it computes it and it gets the same

01:00:44,529 --> 01:00:49,390
result and salsa realizes well so all

01:00:47,709 --> 01:00:52,119
the sub modules are the same so the

01:00:49,390 --> 01:00:57,119
module tree must be the same and it I

01:00:52,119 --> 01:01:00,009
was a computing multi which is great so

01:00:57,119 --> 01:01:02,859
yeah one bit

01:01:00,009 --> 01:01:06,489
often for about this or cycling we

01:01:02,859 --> 01:01:07,719
actually like to have a link back to the

01:01:06,489 --> 01:01:12,640
source code where are we several

01:01:07,719 --> 01:01:18,519
originated too and we can use a pointer

01:01:12,640 --> 01:01:21,039
to this in technology yeah but this

01:01:18,519 --> 01:01:24,700
would be bad because a syntax tree is

01:01:21,039 --> 01:01:27,219
change after every modification and this

01:01:24,700 --> 01:01:28,900
means that this field the result of some

01:01:27,219 --> 01:01:31,599
model query will be changed at every

01:01:28,900 --> 01:01:34,359
modification which is better now we can

01:01:31,599 --> 01:01:39,489
store like for example a pair of offsets

01:01:34,359 --> 01:01:41,739
to the source of the module but this

01:01:39,489 --> 01:01:43,390
also will be bad because text because

01:01:41,739 --> 01:01:47,469
forces change when you type something

01:01:43,390 --> 01:01:51,999
before the offset so what we start here

01:01:47,469 --> 01:01:57,609
is as table and identifier of the source

01:01:51,999 --> 01:02:01,719
item and the way we get a stable

01:01:57,609 --> 01:02:07,029
identifier is that we enumerate all the

01:02:01,719 --> 01:02:13,839
items in the file and store them in an

01:02:07,029 --> 01:02:16,569
arena such that each source item gets

01:02:13,839 --> 01:02:18,190
and index in the arena and by source

01:02:16,569 --> 01:02:19,949
item items like real rust items like

01:02:18,190 --> 01:02:23,279
fine constructed setter etcetera

01:02:19,949 --> 01:02:26,079
expressions are not processed here and

01:02:23,279 --> 01:02:29,680
what we get as a result is that each

01:02:26,079 --> 01:02:33,789
item gets a relatively stable ID the ID

01:02:29,680 --> 01:02:35,709
changes only when you add new functions

01:02:33,789 --> 01:02:38,170
new top-level items when you type

01:02:35,709 --> 01:02:40,539
something inside the function body the

01:02:38,170 --> 01:02:46,089
idea of a function stays the same so

01:02:40,539 --> 01:02:47,350
that means that this field actually does

01:02:46,089 --> 01:02:49,660
not change that

01:02:47,350 --> 01:02:53,440
often and this means that sub-module

01:02:49,660 --> 01:02:56,170
query stays the same and that module

01:02:53,440 --> 01:02:58,930
three query stay the same as well

01:02:56,170 --> 01:03:02,380
and yeah so the actual procedure of

01:02:58,930 --> 01:03:04,930
recursively building some module three

01:03:02,380 --> 01:03:07,890
is not that interesting what is

01:03:04,930 --> 01:03:07,890
interesting is

01:03:12,960 --> 01:03:20,790
yeah we'll show a test a little bit

01:03:18,480 --> 01:03:25,740
later but the point I'm trying to make

01:03:20,790 --> 01:03:28,050
is that type in like this does not

01:03:25,740 --> 01:03:32,970
require this little tree to be

01:03:28,050 --> 01:03:37,589
recomputed which is great okay so we've

01:03:32,970 --> 01:03:40,400
got this model tree which give us

01:03:37,589 --> 01:03:43,470
modules and each module has now an

01:03:40,400 --> 01:03:47,430
identity and with a model tree we

01:03:43,470 --> 01:03:51,569
probably can build name resolution so

01:03:47,430 --> 01:03:53,819
that we can resolve paths in use items

01:03:51,569 --> 01:04:00,150
etc etcetera

01:03:53,819 --> 01:04:02,849
how do we do this well and here is an

01:04:00,150 --> 01:04:07,740
interesting problem IPS we need to

01:04:02,849 --> 01:04:12,660
somehow identify the items inside the

01:04:07,740 --> 01:04:14,339
module for the module tree the way we

01:04:12,660 --> 01:04:17,880
identified the module is that we

01:04:14,339 --> 01:04:20,099
collected all the modules into a single

01:04:17,880 --> 01:04:22,710
vector in some particular order and we

01:04:20,099 --> 01:04:25,140
use index in this vector as identity of

01:04:22,710 --> 01:04:28,500
the module and this is probably good

01:04:25,140 --> 01:04:32,460
because the set of modules changes so

01:04:28,500 --> 01:04:34,650
rarely and when it changes the idea the

01:04:32,460 --> 01:04:36,780
module changes and all other sorts of

01:04:34,650 --> 01:04:39,299
stuff which depends on this ad will have

01:04:36,780 --> 01:04:45,859
to be computed but usually they stay the

01:04:39,299 --> 01:04:45,859
same and so the dependency is stay fresh

01:04:46,099 --> 01:04:51,960
doing the same thing in completion for

01:04:49,380 --> 01:04:57,299
example all the functions from the crate

01:04:51,960 --> 01:04:59,430
into a single array will be less

01:04:57,299 --> 01:05:01,020
fortunate because for example I did a

01:04:59,430 --> 01:05:02,609
new function suppose changing a new

01:05:01,020 --> 01:05:05,760
function adding a new module is a

01:05:02,609 --> 01:05:08,040
relatively common operation so the ideas

01:05:05,760 --> 01:05:09,030
will be invalidated more frequently and

01:05:08,040 --> 01:05:12,240
what's wrong

01:05:09,030 --> 01:05:16,079
you actually will have to crawl across

01:05:12,240 --> 01:05:18,750
all over all of the functions but Italy

01:05:16,079 --> 01:05:21,089
we would like to avoid even looking at

01:05:18,750 --> 01:05:23,130
the functions inside some of the

01:05:21,089 --> 01:05:24,990
implementation which we not

01:05:23,130 --> 01:05:29,460
used to type-check a particular function

01:05:24,990 --> 01:05:32,640
which is opened in the editor so now in

01:05:29,460 --> 01:05:39,000
some other way to identify the function

01:05:32,640 --> 01:05:41,720
and we may use location as the identity

01:05:39,000 --> 01:05:44,760
of the function so this is for example

01:05:41,720 --> 01:05:47,130
location structure which describes a

01:05:44,760 --> 01:05:50,460
particular item inside the module so it

01:05:47,130 --> 01:05:54,000
has soft suit ID and module ID fields

01:05:50,460 --> 01:05:57,450
which uniquely identify the module and

01:05:54,000 --> 01:05:59,070
it has this source item ID which

01:05:57,450 --> 01:06:01,500
uniquely identifies an item inside the

01:05:59,070 --> 01:06:04,050
module and we understand that this

01:06:01,500 --> 01:06:07,290
Deathlok of a particular function or

01:06:04,050 --> 01:06:10,560
strike or for example yeah so a diff

01:06:07,290 --> 01:06:16,080
lock of this diff lock struct itself

01:06:10,560 --> 01:06:20,550
will not be changed unless we add a new

01:06:16,080 --> 01:06:24,990
function in this same file so it is

01:06:20,550 --> 01:06:26,850
stable but it is not really great as an

01:06:24,990 --> 01:06:30,180
ID because eagerly we would like to have

01:06:26,850 --> 01:06:33,930
our IDs to be like just you 32 integers

01:06:30,180 --> 01:06:37,620
and the flock has all sorts of stuff and

01:06:33,930 --> 01:06:40,740
you can imagine that if we would like to

01:06:37,620 --> 01:06:43,530
see a location of an item inside an

01:06:40,740 --> 01:06:45,420
input inside something else we will need

01:06:43,530 --> 01:06:47,610
to make this the flock recursive and

01:06:45,420 --> 01:06:52,370
store some kind of objector paths in

01:06:47,610 --> 01:06:56,220
them and yeah this does not block sorry

01:06:52,370 --> 01:06:58,350
and this doesn't look like compact admx

01:06:56,220 --> 01:07:00,540
storing it in the hash map search it'll

01:06:58,350 --> 01:07:03,450
probably be slow so it would like to

01:07:00,540 --> 01:07:08,850
somehow assign just American deep to

01:07:03,450 --> 01:07:11,970
this location and if these the location

01:07:08,850 --> 01:07:14,760
in certain pattern pattern so allocation

01:07:11,970 --> 01:07:17,070
Turner does it keeps a directional

01:07:14,760 --> 01:07:19,290
matter the direction of a tenant only

01:07:17,070 --> 01:07:23,420
this is important Martin between

01:07:19,290 --> 01:07:23,420
allocations and numeric IDs

01:07:27,470 --> 01:07:34,480
or something like that yeah and

01:07:30,710 --> 01:07:36,530
basically when you can give it an ID

01:07:34,480 --> 01:07:39,500
allocation and it will give you an ID

01:07:36,530 --> 01:07:44,900
and if this is all over the service

01:07:39,500 --> 01:07:46,520
location it will give they otherwise it

01:07:44,900 --> 01:07:49,640
will allocate in UID

01:07:46,520 --> 01:07:54,560
by pushing this location to a vector and

01:07:49,640 --> 01:08:02,740
give you this new ad so yeah this is how

01:07:54,560 --> 01:08:02,740
we turn this positional identifiers into

01:08:03,369 --> 01:08:11,720
user two integers and all the stuff

01:08:08,020 --> 01:08:15,310
inside rust analyzer semantic model is

01:08:11,720 --> 01:08:21,199
identified by this sort of internal abs

01:08:15,310 --> 01:08:25,449
okay so now we have we know all the

01:08:21,199 --> 01:08:25,449
things to look into the name resolution

01:08:26,739 --> 01:08:32,980
the in resolution are used here in a

01:08:29,359 --> 01:08:37,850
pretty narrow sense it only resolves use

01:08:32,980 --> 01:08:41,180
paths so it builds a thing called item

01:08:37,850 --> 01:08:44,180
map which for each module tells which

01:08:41,180 --> 01:08:46,609
items are visible in this module and an

01:08:44,180 --> 01:08:48,589
item is visible inside the module if it

01:08:46,609 --> 01:08:51,469
is declared inside the module or if it

01:08:48,589 --> 01:08:57,650
is imported inside the module and the

01:08:51,469 --> 01:09:01,120
idea for building item map is pretty

01:08:57,650 --> 01:09:01,120
much the same

01:09:04,759 --> 01:09:10,429
pretty much the same as for building

01:09:07,339 --> 01:09:12,739
module two we can't add the pant on the

01:09:10,429 --> 01:09:14,989
source code directly because this will

01:09:12,739 --> 01:09:20,179
invalidate module item map after every

01:09:14,989 --> 01:09:22,459
change so a we first lower module into

01:09:20,179 --> 01:09:25,639
our position independent representation

01:09:22,459 --> 01:09:27,949
and then using this position independent

01:09:25,639 --> 01:09:29,239
to presentation which is basically like

01:09:27,949 --> 01:09:31,849
sub modules for middle three

01:09:29,239 --> 01:09:40,039
we run this export iterative algorithm

01:09:31,849 --> 01:09:42,859
resolving everything and what we get

01:09:40,039 --> 01:09:44,179
here is basically this test that type in

01:09:42,859 --> 01:09:46,880
inside the function does not invalidate

01:09:44,179 --> 01:09:50,029
item app so how much test what we have a

01:09:46,880 --> 01:09:55,219
bunch of files yeah Linda Torres for

01:09:50,029 --> 01:09:59,889
mother s for bar s and we compute item

01:09:55,219 --> 01:10:05,090
map for this crate and then we change

01:09:59,889 --> 01:10:07,729
libris file and we change the body of

01:10:05,090 --> 01:10:11,269
the food item for function from like one

01:10:07,729 --> 01:10:13,909
plus one to ninety two and this actually

01:10:11,269 --> 01:10:16,400
does not execute this item up query and

01:10:13,909 --> 01:10:17,900
the current because we only change the

01:10:16,400 --> 01:10:20,360
body of the item the set of items

01:10:17,900 --> 01:10:22,130
visible in the modules is the same and

01:10:20,360 --> 01:10:24,349
that means that like we can speedily

01:10:22,130 --> 01:10:26,179
give you completions because we know

01:10:24,349 --> 01:10:30,289
what items are visible about repeating

01:10:26,179 --> 01:10:37,340
them so let's look at this award module

01:10:30,289 --> 01:10:39,590
thing again it contains this position

01:10:37,340 --> 01:10:42,050
different items with like james its

01:10:39,590 --> 01:10:44,179
position independent pointer in the

01:10:42,050 --> 01:10:49,550
source code and it also contains import

01:10:44,179 --> 01:10:51,469
and the important bit is interesting why

01:10:49,550 --> 01:10:54,679
it is interesting for an obscure reason

01:10:51,469 --> 01:10:57,920
when we run completion we if we like

01:10:54,679 --> 01:10:59,269
complete a full struct we need to know

01:10:57,920 --> 01:11:03,170
if this was tracked

01:10:59,269 --> 01:11:08,119
was imported and we need to know a

01:11:03,170 --> 01:11:11,449
particular segment of the use path which

01:11:08,119 --> 01:11:15,039
imported we struct the new way to do

01:11:11,449 --> 01:11:15,039
this would be to just like add

01:11:18,910 --> 01:11:31,280
like something like syndics note to this

01:11:28,420 --> 01:11:33,440
import to be slower even but again this

01:11:31,280 --> 01:11:36,950
won't work because it has three changes

01:11:33,440 --> 01:11:43,040
after every modification and we really

01:11:36,950 --> 01:11:47,530
want that test to work so we use another

01:11:43,040 --> 01:11:47,530
interesting as a person here source map

01:11:48,130 --> 01:11:54,230
first of all again we store imports

01:11:51,740 --> 01:11:59,810
inside an arena so each import gets an

01:11:54,230 --> 01:12:01,910
ID and when we use a lower module query

01:11:59,810 --> 01:12:04,580
which takes sources the module and

01:12:01,910 --> 01:12:07,880
produce this produces this position

01:12:04,580 --> 01:12:09,980
independent Lord presentation we

01:12:07,880 --> 01:12:12,350
actually returned two bits of

01:12:09,980 --> 01:12:15,950
information this lower limit abstract

01:12:12,350 --> 01:12:18,530
and this import source map and the

01:12:15,950 --> 01:12:23,090
source map is bad from a sales

01:12:18,530 --> 01:12:25,970
perspective because it's tours local six

01:12:23,090 --> 01:12:28,850
index pitcher is basically a text range

01:12:25,970 --> 01:12:31,790
inside the file so it changes with

01:12:28,850 --> 01:12:35,660
notification and so this is like sort of

01:12:31,790 --> 01:12:38,780
basically a syntax note itself I'll be

01:12:35,660 --> 01:12:41,750
using a little bit less memory so this

01:12:38,780 --> 01:12:43,550
again change is verification and this

01:12:41,750 --> 01:12:48,110
means that the results of this lower

01:12:43,550 --> 01:12:50,660
module query also change after every

01:12:48,110 --> 01:12:54,560
modification but actually that's a trick

01:12:50,660 --> 01:12:57,530
because in lowered module we have import

01:12:54,560 --> 01:12:59,930
ID and we can use import ID to look up

01:12:57,530 --> 01:13:02,180
the syntax in this import source map I

01:12:59,930 --> 01:13:06,110
wanna be you we want to get rid of this

01:13:02,180 --> 01:13:09,800
aspect of becoming stale after edit and

01:13:06,110 --> 01:13:12,140
this what lower module module does with

01:13:09,800 --> 01:13:14,180
a really simple query it translate

01:13:12,140 --> 01:13:16,490
previous query which returns a pair and

01:13:14,180 --> 01:13:19,430
projects the first component of the pair

01:13:16,490 --> 01:13:22,190
out of it so it projects just lowered

01:13:19,430 --> 01:13:25,460
will start and this query will not

01:13:22,190 --> 01:13:28,940
change when you edit file files unless

01:13:25,460 --> 01:13:29,900
you actually create a new top level

01:13:28,940 --> 01:13:32,080
function

01:13:29,900 --> 01:13:40,670
or in you trade or something like that

01:13:32,080 --> 01:13:44,150
that's what we actually use here so

01:13:40,670 --> 01:13:46,460
again we want two things first of all we

01:13:44,150 --> 01:13:50,900
want to map from semantic model back to

01:13:46,460 --> 01:13:53,030
the syntax but we want to keep semantic

01:13:50,900 --> 01:13:57,650
model independent of the Alliance index

01:13:53,030 --> 01:14:00,170
and we do this by keeping mapping from

01:13:57,650 --> 01:14:04,370
semantic model to the syntax as a

01:14:00,170 --> 01:14:07,760
separate source map and by just removing

01:14:04,370 --> 01:14:10,610
this source map from the analysis okay

01:14:07,760 --> 01:14:16,790
so how do the actual name resolution

01:14:10,610 --> 01:14:17,960
works let's take a quick look it's the

01:14:16,790 --> 01:14:22,400
water in the reservoir

01:14:17,960 --> 01:14:27,530
so it's this like X point iterative

01:14:22,400 --> 01:14:30,409
algorithm which just trades over this

01:14:27,530 --> 01:14:33,230
set of items until all inputs are

01:14:30,409 --> 01:14:36,230
resolved all until it can't resolve more

01:14:33,230 --> 01:14:39,920
imports actually don't know how this

01:14:36,230 --> 01:14:42,860
works in racine it's actually pretty

01:14:39,920 --> 01:14:45,830
important problem to solve in IDs like

01:14:42,860 --> 01:14:47,530
to implement this name resolution which

01:14:45,830 --> 01:14:50,659
should be intuitive macro expansion

01:14:47,530 --> 01:14:55,400
correctly and for that we probably need

01:14:50,659 --> 01:14:59,270
the specification first okay so what I'd

01:14:55,400 --> 01:15:02,989
like to show here is also yeah the place

01:14:59,270 --> 01:15:06,260
we are where we assigned the veggies if

01:15:02,989 --> 01:15:08,960
you look at the item map struct which

01:15:06,260 --> 01:15:11,179
stores which module a set of item of

01:15:08,960 --> 01:15:14,239
which implemented for it where each item

01:15:11,179 --> 01:15:18,260
is basically a def ID account info like

01:15:14,239 --> 01:15:21,560
types macros and various namespaces so

01:15:18,260 --> 01:15:25,550
we need with the funny and this is the

01:15:21,560 --> 01:15:29,690
place where we get this def ID we get an

01:15:25,550 --> 01:15:33,620
item from this load module and we know

01:15:29,690 --> 01:15:37,250
this source route we know module and we

01:15:33,620 --> 01:15:40,920
know the ID of the item source so we can

01:15:37,250 --> 01:15:43,050
create the flock and we can use

01:15:40,920 --> 01:15:47,070
in tournaments at the database to turn

01:15:43,050 --> 01:15:50,310
this location into identity actually

01:15:47,070 --> 01:15:54,290
this code probably does belong to this

01:15:50,310 --> 01:16:00,000
lower instep it's here for students

01:15:54,290 --> 01:16:07,290
okay so how we do name resolution what

01:16:00,000 --> 01:16:11,510
else should be in discuss yeah we

01:16:07,290 --> 01:16:11,510
probably should discuss type inference

01:16:13,640 --> 01:16:18,210
type inference uses all the same

01:16:15,960 --> 01:16:20,130
patterns I use a position depends

01:16:18,210 --> 01:16:27,090
presentation and using a source map

01:16:20,130 --> 01:16:30,060
being incremental it is you then you

01:16:27,090 --> 01:16:33,570
point to type inference and by the way a

01:16:30,060 --> 01:16:41,130
huge shout-outs to float Diebold who

01:16:33,570 --> 01:16:47,330
actually implemented all of this all of

01:16:41,130 --> 01:16:50,219
this type inference stuff so in inter

01:16:47,330 --> 01:16:55,350
runs type inference for a single

01:16:50,219 --> 01:17:01,949
function and what it creates it creates

01:16:55,350 --> 01:17:04,860
a Madam from expressions to their types

01:17:01,949 --> 01:17:07,500
and again what is an extraction if we

01:17:04,860 --> 01:17:09,000
use the syntax of expression we will get

01:17:07,500 --> 01:17:13,260
query we should be invalidated

01:17:09,000 --> 01:17:16,290
every time etcetera etcetera so we

01:17:13,260 --> 01:17:22,050
actually run an extra step before type

01:17:16,290 --> 01:17:26,250
inference we lower the lower the row

01:17:22,050 --> 01:17:28,920
syntax function which contains offset

01:17:26,250 --> 01:17:32,880
and is not stable into this compact

01:17:28,920 --> 01:17:35,130
presentation of arena based iced tea so

01:17:32,880 --> 01:17:38,100
here X bar is not a syntax tree is just

01:17:35,130 --> 01:17:43,770
like your usual recursive and I'm except

01:17:38,100 --> 01:17:47,660
that it uses IDs and not boxes to avoid

01:17:43,770 --> 01:17:50,370
infinite recursive size problem and

01:17:47,660 --> 01:17:51,430
primarily not to avoid this like size

01:17:50,370 --> 01:17:53,800
problem but

01:17:51,430 --> 01:17:59,590
actually leave and identity to each

01:17:53,800 --> 01:18:07,710
expression and this expression is what

01:17:59,590 --> 01:18:07,710
we store the inference result okay so

01:18:16,169 --> 01:18:24,599
and again these uses this source map

01:18:22,169 --> 01:18:26,809
pattern when we lower function body

01:18:24,599 --> 01:18:29,189
first of all we get this body struct

01:18:26,809 --> 01:18:31,860
which is position independent and

01:18:29,189 --> 01:18:35,130
contains IDs and it is a function model

01:18:31,860 --> 01:18:36,780
so if you like more function around all

01:18:35,130 --> 01:18:39,329
I can move it to completely unrelated

01:18:36,780 --> 01:18:43,559
file the body of the function will stay

01:18:39,329 --> 01:18:45,959
the same but together with this body we

01:18:43,559 --> 01:18:48,300
store it index method which maps a

01:18:45,959 --> 01:18:50,489
syntax nodes to expression the

01:18:48,300 --> 01:18:53,159
expressions and expressions back to

01:18:50,489 --> 01:18:57,419
syntax nodes and we use these heavily in

01:18:53,159 --> 01:19:10,349
the IDE we aren't in the actual type

01:18:57,419 --> 01:19:13,559
inference happens in Kalamazoo and this

01:19:10,349 --> 01:19:16,699
is probably the entry point and this is

01:19:13,559 --> 01:19:23,010
like usual type inference which works on

01:19:16,699 --> 01:19:25,260
these ADT Adams Nest autonomous

01:19:23,010 --> 01:19:26,999
expression representation and it's

01:19:25,260 --> 01:19:28,999
really challenging and really

01:19:26,999 --> 01:19:34,380
interesting from like type inference

01:19:28,999 --> 01:19:35,909
perspective but from ID point the core

01:19:34,380 --> 01:19:39,239
feature we should want to type inference

01:19:35,909 --> 01:19:43,039
is that we run it for a single function

01:19:39,239 --> 01:19:45,749
at a time so to complete completion we

01:19:43,039 --> 01:19:50,849
only type check a single function where

01:19:45,749 --> 01:19:53,669
completion is requested why to stay and

01:19:50,849 --> 01:19:56,329
so on to compute completion probably

01:19:53,669 --> 01:19:56,329
something Oh

01:19:57,050 --> 01:20:02,840
looks like there is looks like there is

01:20:00,110 --> 01:20:06,770
some bargain type inference which panics

01:20:02,840 --> 01:20:08,870
well it's a demo okay so the main thing

01:20:06,770 --> 01:20:11,480
which we want from type inference is

01:20:08,870 --> 01:20:14,840
that it works locally to a function so

01:20:11,480 --> 01:20:18,320
when we want to run completion we run it

01:20:14,840 --> 01:20:23,780
for a single function and we actually

01:20:18,320 --> 01:20:26,810
get this okay so what should we discuss

01:20:23,780 --> 01:20:30,830
next well probably we have discussed

01:20:26,810 --> 01:20:35,450
everything so let's just look at a

01:20:30,830 --> 01:20:36,110
single feature from the protocol back to

01:20:35,450 --> 01:20:38,300
panelizer

01:20:36,110 --> 01:20:39,800
to the salsa database and back to

01:20:38,300 --> 01:20:43,239
analyze again back to the protocol and

01:20:39,800 --> 01:20:52,989
let speak completion for this fusion so

01:20:43,239 --> 01:20:55,820
let's see what happens when you type

01:20:52,989 --> 01:20:59,090
something in the editor and press ctrl

01:20:55,820 --> 01:21:01,730
spacebar to request completion this

01:20:59,090 --> 01:21:05,150
happens this starts in the main loop

01:21:01,730 --> 01:21:09,350
where we get these are handy where we

01:21:05,150 --> 01:21:11,330
get is a completion request that's that

01:21:09,350 --> 01:21:14,680
gets routed to handle completion

01:21:11,330 --> 01:21:23,080
function hello completion function

01:21:14,680 --> 01:21:26,480
converts LSB requests to file position

01:21:23,080 --> 01:21:29,360
which basically is a file ID and an

01:21:26,480 --> 01:21:31,489
offset this code is like a special case

01:21:29,360 --> 01:21:34,180
because we want to show completion

01:21:31,489 --> 01:21:34,180
automatically

01:21:35,460 --> 01:21:50,349
after you've type a semicolon but we

01:21:39,219 --> 01:21:54,489
don't want to okay but we don't want to

01:21:50,349 --> 01:21:57,280
show completion after you typed only one

01:21:54,489 --> 01:22:02,920
dot so we need to check that the

01:21:57,280 --> 01:22:06,550
previous char is also : so not at all

01:22:02,920 --> 01:22:12,520
okay so we got our position and really

01:22:06,550 --> 01:22:21,060
run a completion we get fala position

01:22:12,520 --> 01:22:25,989
and we ask completions on the database

01:22:21,060 --> 01:22:28,300
is not using database I don't know yep

01:22:25,989 --> 01:22:31,030
so H cancelled it's like an interesting

01:22:28,300 --> 01:22:33,340
aside beat in that inside cells

01:22:31,030 --> 01:22:36,550
translation actually is implemented we

01:22:33,340 --> 01:22:39,820
are winding so we literally panic when

01:22:36,550 --> 01:22:41,440
something types something into the

01:22:39,820 --> 01:22:44,170
editor where the completion is running

01:22:41,440 --> 01:22:47,790
and that cheers down all the queries and

01:22:44,170 --> 01:22:51,989
here we catch Hispanic and turn it into

01:22:47,790 --> 01:22:55,869
handy cancel which is a result okay so

01:22:51,989 --> 01:22:58,690
what is completions this is finally the

01:22:55,869 --> 01:23:03,130
like guts of the code completion where

01:22:58,690 --> 01:23:06,880
we start to do some useful work it

01:23:03,130 --> 01:23:09,280
receives the database and it receives me

01:23:06,880 --> 01:23:13,300
position in the source file and it needs

01:23:09,280 --> 01:23:15,550
to return a set of completions the first

01:23:13,300 --> 01:23:18,610
thing we do here is that we figure

01:23:15,550 --> 01:23:20,590
completion context so we need to

01:23:18,610 --> 01:23:23,260
understand is the cursor after a dot or

01:23:20,590 --> 01:23:26,489
is a cursor after a double colon colon

01:23:23,260 --> 01:23:29,110
search for cetera let's see how we do it

01:23:26,489 --> 01:23:30,880
completion context is like in predefined

01:23:29,110 --> 01:23:34,389
data structure it contains all sorts of

01:23:30,880 --> 01:23:36,579
interesting bits of information and so

01:23:34,389 --> 01:23:40,780
the basic stuff is like the reference to

01:23:36,579 --> 01:23:43,750
the database is the offset where the

01:23:40,780 --> 01:23:47,260
completion wasn't worked the leaves

01:23:43,750 --> 01:23:47,519
index node where the completion wasn't

01:23:47,260 --> 01:23:49,139
works

01:23:47,519 --> 01:23:50,840
like a talking like an identifier

01:23:49,139 --> 01:23:55,909
whitespace or whatnot

01:23:50,840 --> 01:24:00,269
it also contains references to the

01:23:55,909 --> 01:24:02,909
syntax nodes around the insertion point

01:24:00,269 --> 01:24:04,079
so for example if you involved

01:24:02,909 --> 01:24:06,719
completion inside a function definition

01:24:04,079 --> 01:24:08,489
you will have function syntax if you

01:24:06,719 --> 01:24:11,249
invoke completion inside of user item

01:24:08,489 --> 01:24:15,269
you will get news item symbols and it

01:24:11,249 --> 01:24:19,710
also got a semantic model of a function

01:24:15,269 --> 01:24:22,789
so remember there is no bijection

01:24:19,710 --> 01:24:25,920
between syntax and semantic model and

01:24:22,789 --> 01:24:30,960
completion jaian must get semantic model

01:24:25,920 --> 01:24:36,329
and we will just see how it happens so

01:24:30,960 --> 01:24:38,489
yeah first of all we need to figure out

01:24:36,329 --> 01:24:41,999
in the context of which module we are at

01:24:38,489 --> 01:24:45,599
writing and this goes the source bind

01:24:41,999 --> 01:24:51,210
infrastructure which tries to guess the

01:24:45,599 --> 01:24:53,760
module and the way it does it both first

01:24:51,210 --> 01:24:58,949
all it determines if we are inside and

01:24:53,760 --> 01:25:00,989
in mind module the common case is that

01:24:58,949 --> 01:25:06,300
we are not we are not just in usual file

01:25:00,989 --> 01:25:14,130
and here we construct module from a file

01:25:06,300 --> 01:25:15,329
and this means that we just traverse the

01:25:14,130 --> 01:25:17,730
whole module tree

01:25:15,329 --> 01:25:20,249
like we traverse all the modules we are

01:25:17,730 --> 01:25:22,530
know about and we find a module which

01:25:20,249 --> 01:25:25,920
originated the first module which

01:25:22,530 --> 01:25:29,340
originated from this source file but

01:25:25,920 --> 01:25:31,679
there are may be many modules which are

01:25:29,340 --> 01:25:34,980
generated from a single source file okay

01:25:31,679 --> 01:25:37,949
so yeah and this is like one of the most

01:25:34,980 --> 01:25:41,369
interesting bits because this is here

01:25:37,949 --> 01:25:44,010
where we get from purely source code

01:25:41,369 --> 01:25:47,579
base presentation to the representation

01:25:44,010 --> 01:25:51,349
where we know the whole context and the

01:25:47,579 --> 01:25:51,349
grade is a few G flags setter etcetera

01:25:52,390 --> 01:26:02,190
okay so now once we have a module we can

01:25:57,220 --> 01:26:02,190
feel a little bit more of context and

01:26:03,120 --> 01:26:09,640
they need trick we do here which I

01:26:06,310 --> 01:26:12,040
belong from IntelliJ is better to learn

01:26:09,640 --> 01:26:14,200
the syntax and the current position we

01:26:12,040 --> 01:26:17,620
first of all insert and then identify

01:26:14,200 --> 01:26:21,580
where the cursor is so that we get a

01:26:17,620 --> 01:26:26,680
sound more reasonable parsed win and we

01:26:21,580 --> 01:26:29,410
can so like to give an example if you

01:26:26,680 --> 01:26:32,170
type something like this and cursor was

01:26:29,410 --> 01:26:33,850
here you know this is an identifier and

01:26:32,170 --> 01:26:36,700
we are supposed to complete an

01:26:33,850 --> 01:26:40,180
identifier if however there is no

01:26:36,700 --> 01:26:42,460
identify were told it becomes much less

01:26:40,180 --> 01:26:43,989
cumbersome to understand the context at

01:26:42,460 --> 01:26:46,620
a course because well you don't have any

01:26:43,989 --> 01:26:50,020
be defined you want to complete so we

01:26:46,620 --> 01:27:00,730
serve some random string here around

01:26:50,020 --> 01:27:04,390
force okay so if we find reference in

01:27:00,730 --> 01:27:08,110
these identifiers we try to figure out

01:27:04,390 --> 01:27:10,390
what kind of the reference it is so it

01:27:08,110 --> 01:27:13,660
probably is inside the function so we

01:27:10,390 --> 01:27:16,840
try to find the function outside our

01:27:13,660 --> 01:27:21,790
cursor position it also can be inside

01:27:16,840 --> 01:27:25,450
the history so we find that as well if

01:27:21,790 --> 01:27:28,450
we are inside the function we tried to

01:27:25,450 --> 01:27:31,330
find a somatic model for this function

01:27:28,450 --> 01:27:33,910
and this is now much easier than finding

01:27:31,330 --> 01:27:37,110
the semantic model for a module because

01:27:33,910 --> 01:27:39,790
we already know the module and module

01:27:37,110 --> 01:27:41,800
completely determines the semantic

01:27:39,790 --> 01:27:44,020
context the create sort of stiffens

01:27:41,800 --> 01:27:46,300
reflex so final function is basically

01:27:44,020 --> 01:27:49,630
just its writing through items are

01:27:46,300 --> 01:27:52,260
described in the module and picking the

01:27:49,630 --> 01:27:55,630
one with the respondent source tree

01:27:52,260 --> 01:27:58,380
so let's Taurus attract an interesting

01:27:55,630 --> 01:27:58,380
bit here

01:28:00,190 --> 01:28:07,280
yeah if we are a field expression we

01:28:04,760 --> 01:28:18,710
also feel this dot receiver the receiver

01:28:07,280 --> 01:28:20,690
is English which is expression to the

01:28:18,710 --> 01:28:23,150
left of the dot so if we request

01:28:20,690 --> 01:28:24,760
completion yeah the receiver will be

01:28:23,150 --> 01:28:35,990
this expression

01:28:24,760 --> 01:28:37,370
okay so completion yeah so we collected

01:28:35,990 --> 01:28:39,410
the context which contains both

01:28:37,370 --> 01:28:44,360
syntactic and semantic information and

01:28:39,410 --> 01:28:47,690
now we run a serious of completion

01:28:44,360 --> 01:28:50,090
utilities which feel the context with

01:28:47,690 --> 01:28:51,890
possible temptation variants and let's

01:28:50,090 --> 01:28:55,100
look at complete dot which completes

01:28:51,890 --> 01:28:59,570
staff after Vlad first of all it tries

01:28:55,100 --> 01:29:02,690
to extract the function semantic model

01:28:59,570 --> 01:29:04,370
and their receivers syntax if there is

01:29:02,690 --> 01:29:07,100
no receiver syntax we probably can't

01:29:04,370 --> 01:29:10,160
complete after the dots are we just

01:29:07,100 --> 01:29:12,590
returned at them and are given the

01:29:10,160 --> 01:29:16,400
function semantic model we Iran type

01:29:12,590 --> 01:29:19,360
inference or this function and we get

01:29:16,400 --> 01:29:24,140
back a result which maps expression IDs

01:29:19,360 --> 01:29:28,900
to inference results but we don't have

01:29:24,140 --> 01:29:28,900
an expression ID because we super here

01:29:33,460 --> 01:29:39,950
okay type type inference is not yet

01:29:36,980 --> 01:29:42,700
perfect okay so a receiver is a syntax

01:29:39,950 --> 01:29:42,700
and we want

01:29:42,760 --> 01:29:49,520
syntax a B so we asked for source map

01:29:46,370 --> 01:29:52,460
for the body of the function and autocar

01:29:49,520 --> 01:29:57,260
expression ID using these symbols now we

01:29:52,460 --> 01:30:02,000
can get the actual type because we know

01:29:57,260 --> 01:30:05,390
the expression ID and we can complete

01:30:02,000 --> 01:30:08,949
methods and service and our bit from the

01:30:05,390 --> 01:30:14,710
context if we complete in

01:30:08,949 --> 01:30:16,330
ha we shouldn't suggest methods because

01:30:14,710 --> 01:30:18,250
we know that this is a method called

01:30:16,330 --> 01:30:21,630
oral if you compute in just bar we

01:30:18,250 --> 01:30:25,570
should suggest both fields and methods

01:30:21,630 --> 01:30:27,989
and yeah here we basically iterate the

01:30:25,570 --> 01:30:31,179
fields on the type and we trade

01:30:27,989 --> 01:30:37,120
available Impuls and suggest completion

01:30:31,179 --> 01:30:41,489
variants I think this is almost

01:30:37,120 --> 01:30:44,530
everything I wanted to talk about

01:30:41,489 --> 01:30:48,340
probably yeah a single bit which is

01:30:44,530 --> 01:30:51,400
missing is micro support I missed it

01:30:48,340 --> 01:30:52,900
just because there is not too much motor

01:30:51,400 --> 01:30:55,780
support in retinal as a quantity

01:30:52,900 --> 01:30:58,780
basically we have a set of hard-coded

01:30:55,780 --> 01:31:06,310
macros but it's interesting how it feeds

01:30:58,780 --> 01:31:16,750
into this IDs infrastructure so I will

01:31:06,310 --> 01:31:18,850
download now the problem with macros is

01:31:16,750 --> 01:31:21,610
that they effectively create new files

01:31:18,850 --> 01:31:31,690
so if you have something not foo and

01:31:21,610 --> 01:31:34,300
like I don't know how Sergius and run

01:31:31,690 --> 01:31:39,580
expression how sabji macro actually

01:31:34,300 --> 01:31:44,830
works I don't take that yeah something

01:31:39,580 --> 01:31:48,070
here this actually gets expanded to

01:31:44,830 --> 01:31:50,949
basically a support file so we can't

01:31:48,070 --> 01:31:54,219
save it like the results of macro

01:31:50,949 --> 01:31:58,870
expansion are in this same source file

01:31:54,219 --> 01:32:01,090
because at least be dependent on the

01:31:58,870 --> 01:32:03,670
current module because CFG if may be

01:32:01,090 --> 01:32:08,980
defined differently depending on your Co

01:32:03,670 --> 01:32:11,560
G's so we need to somehow handle this

01:32:08,980 --> 01:32:18,610
and my handle this I mean that we use

01:32:11,560 --> 01:32:22,290
pointers to items everywhere and now we

01:32:18,610 --> 01:32:24,690
can store pointer to an item by using

01:32:22,290 --> 01:32:30,300
Leidy to identify the semantic context

01:32:24,690 --> 01:32:34,950
the file ID 25 the file and the ID of an

01:32:30,300 --> 01:32:37,830
item inside this file but these does not

01:32:34,950 --> 01:32:40,410
work for macro generates the file

01:32:37,830 --> 01:32:42,930
because we don't have a file ID so what

01:32:40,410 --> 01:32:46,940
we do instead is that we use so-called

01:32:42,930 --> 01:32:51,030
here file ID throughout the core of

01:32:46,940 --> 01:32:54,270
rustic-y zone and this file ID lat it's

01:32:51,030 --> 01:32:57,180
pretty natural it is either very the ID

01:32:54,270 --> 01:33:00,930
of the original source file or it is the

01:32:57,180 --> 01:33:06,360
ID of the file generated by macro and to

01:33:00,930 --> 01:33:08,910
assign an ID to the file generated by

01:33:06,360 --> 01:33:12,420
the macro we just assigned the ID to the

01:33:08,910 --> 01:33:16,620
particular macro call expression macro

01:33:12,420 --> 01:33:18,510
call goes via this familiar internal

01:33:16,620 --> 01:33:20,670
infrastructure where we have macro

01:33:18,510 --> 01:33:23,700
location and macro call and macro

01:33:20,670 --> 01:33:26,040
location is simple we have a module I

01:33:23,700 --> 01:33:33,840
need to define again semantic context

01:33:26,040 --> 01:33:38,670
and we get a file where this macro

01:33:33,840 --> 01:33:41,430
called happens and we get like the index

01:33:38,670 --> 01:33:44,840
of this my current location in this file

01:33:41,430 --> 01:33:51,540
which is again stable across surprises

01:33:44,840 --> 01:33:54,150
so yeah again final is a resource file

01:33:51,540 --> 01:33:56,370
or macro file where a macro file is

01:33:54,150 --> 01:33:58,470
determined by the macro allocation and

01:33:56,370 --> 01:34:00,450
macro invocation is determined by the

01:33:58,470 --> 01:34:03,600
file and the position in this file and

01:34:00,450 --> 01:34:08,370
you really see how this is recursive

01:34:03,600 --> 01:34:12,320
so again like to really see recursion we

01:34:08,370 --> 01:34:15,630
have this file ID and it's file ID

01:34:12,320 --> 01:34:19,290
historical ID which is identical to

01:34:15,630 --> 01:34:21,780
marshal log which stores a source file

01:34:19,290 --> 01:34:25,020
item ID which stores a file ID which is

01:34:21,780 --> 01:34:28,350
again here a file ID from which we have

01:34:25,020 --> 01:34:30,330
started and we have a point here is that

01:34:28,350 --> 01:34:32,440
this actually works because this

01:34:30,330 --> 01:34:37,719
recursion is not infinite

01:34:32,440 --> 01:34:40,030
each key file ID always ends in a mutual

01:34:37,719 --> 01:34:43,239
file ID and we actually can see is a

01:34:40,030 --> 01:34:46,480
recursion here so yeah to get the

01:34:43,239 --> 01:34:48,610
original file of the file ID we check

01:34:46,480 --> 01:34:50,380
that if we adjust original file like

01:34:48,610 --> 01:34:54,070
original file means were found by the

01:34:50,380 --> 01:34:58,180
user we're Thomas ID if we are generated

01:34:54,070 --> 01:35:00,489
from the macro we see the file where the

01:34:58,180 --> 01:35:03,280
macro code is situated and we

01:35:00,489 --> 01:35:20,020
recursively return original file ID of

01:35:03,280 --> 01:35:22,590
that file okay so this is like how I

01:35:20,020 --> 01:35:26,710
imagine micro expansion can be

01:35:22,590 --> 01:35:32,830
implemented you have this potentially

01:35:26,710 --> 01:35:40,090
macro file ID and then you have expand

01:35:32,830 --> 01:35:44,950
my current location query which looks at

01:35:40,090 --> 01:35:47,380
the source syntax resolves of the macro

01:35:44,950 --> 01:35:52,200
invocation to macro definition and macro

01:35:47,380 --> 01:35:56,140
input where a macro input as is just a

01:35:52,200 --> 01:36:05,770
token tree and like parses this macro in

01:35:56,140 --> 01:36:11,170
put back into the syntax and to get the

01:36:05,770 --> 01:36:15,580
code of macro expansion you again either

01:36:11,170 --> 01:36:18,190
look up the original source file which

01:36:15,580 --> 01:36:22,000
is which you get from the parts of the

01:36:18,190 --> 01:36:24,520
file on the disk or if it is a macro you

01:36:22,000 --> 01:36:26,410
expand multiplication which again can be

01:36:24,520 --> 01:36:31,120
recursive because sauce allows recursive

01:36:26,410 --> 01:36:34,120
queries and you return this in the chief

01:36:31,120 --> 01:36:35,770
that macro expansion actually

01:36:34,120 --> 01:36:38,340
implementing

01:36:35,770 --> 01:36:45,870
macro expansion is of course future work

01:36:38,340 --> 01:36:49,570
okay so I think this is definitely it

01:36:45,870 --> 01:36:51,250
was longer than I expected by but I hope

01:36:49,570 --> 01:36:58,650
it was interesting

01:36:51,250 --> 01:36:58,650

YouTube URL: https://www.youtube.com/watch?v=ANKBNiSWyfc


