Title: Convert Closure Upvar Representation to Tuples with @blitzerr
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	Walk through the steps to convert the internal representation of closures to use a tuple for the upvar types. In the process, explain a lot about how closures work in rustc itself.
Captions: 
	00:00:02,000 --> 00:00:23,869
so yeah I'm able to see your screen okay

00:00:27,140 --> 00:00:39,420
you see see if we can remember what you

00:00:31,710 --> 00:00:52,980
did recently okay so let's just rebuild

00:00:39,420 --> 00:00:57,780
this so the goal here let's see our subs

00:00:52,980 --> 00:01:04,379
so right the goal is to basically change

00:00:57,780 --> 00:01:09,270
this from the u00 Dora this this range

00:01:04,379 --> 00:01:20,159
to just sort of well to this kind of um

00:01:09,270 --> 00:01:24,000
okay and I think so let's let's update

00:01:20,159 --> 00:01:26,430
the comment a bit here represents a type

00:01:24,000 --> 00:01:36,200
of parameter which will always be a

00:01:26,430 --> 00:01:36,200
tuple okay different types these

00:01:41,409 --> 00:01:53,490
well post type insets okay so

00:02:02,420 --> 00:02:09,259
so is the idea that that is a tuple but

00:02:06,350 --> 00:02:11,660
inside that that you zero to UK each of

00:02:09,259 --> 00:02:15,860
them will individually also be a tuple

00:02:11,660 --> 00:02:17,570
is it no because no because the struck

00:02:15,860 --> 00:02:20,030
let's say if there is a struct and it

00:02:17,570 --> 00:02:23,420
has some member variables then we want

00:02:20,030 --> 00:02:26,000
to capture exactly like the entire path

00:02:23,420 --> 00:02:32,200
to the lowermost variable that is being

00:02:26,000 --> 00:02:34,250
captured by the by the closure right yes

00:02:32,200 --> 00:02:36,820
we're not gonna but we're not gonna do

00:02:34,250 --> 00:02:40,880
that yet but yeah the idea would be that

00:02:36,820 --> 00:02:43,070
right now each of these of these types

00:02:40,880 --> 00:02:45,650
in the tuple will correspond to some

00:02:43,070 --> 00:02:47,720
little vulnerable but right going

00:02:45,650 --> 00:02:51,739
forward they might correspond to just

00:02:47,720 --> 00:02:53,090
the type of some path okay and then and

00:02:51,739 --> 00:02:55,520
that's exactly why we have to change

00:02:53,090 --> 00:02:58,550
this because the set the number of paths

00:02:55,520 --> 00:03:03,500
we don't know until later in compilation

00:02:58,550 --> 00:03:05,180
process and whereas before we knew

00:03:03,500 --> 00:03:07,340
exactly how many variables we're going

00:03:05,180 --> 00:03:09,950
to captured very early we don't even

00:03:07,340 --> 00:03:13,420
have to look at the names you know look

00:03:09,950 --> 00:03:17,120
at their types right now the only thing

00:03:13,420 --> 00:03:20,750
here is that this is not legal

00:03:17,120 --> 00:03:23,150
rough syntax right I think we talked

00:03:20,750 --> 00:03:24,890
about this before like you couldn't make

00:03:23,150 --> 00:03:28,670
a struct where you put parentheses in

00:03:24,890 --> 00:03:35,680
this list right I don't think that's

00:03:28,670 --> 00:03:38,660
gonna be a problem for the compiler but

00:03:35,680 --> 00:03:42,290
why don't I think that is a good

00:03:38,660 --> 00:03:45,489
question um I think you said something

00:03:42,290 --> 00:03:48,590
that it's not a real struct or something

00:03:45,489 --> 00:03:50,120
yeah that's right

00:03:48,590 --> 00:03:56,750
I don't think it's gonna be a problem

00:03:50,120 --> 00:03:59,840
because these are not real fields in the

00:03:56,750 --> 00:04:04,430
compiler like we don't give them a def

00:03:59,840 --> 00:04:08,989
ID and so you can't ask for like what is

00:04:04,430 --> 00:04:10,790
the type of this field if you could that

00:04:08,989 --> 00:04:12,349
would be a problem because we wouldn't

00:04:10,790 --> 00:04:14,610
have a type to give back because when

00:04:12,349 --> 00:04:17,790
you ask for the type of the field it

00:04:14,610 --> 00:04:20,040
in the context of its declaration so he

00:04:17,790 --> 00:04:22,200
can refer to these type parameters but

00:04:20,040 --> 00:04:27,510
it can't refer to like sub elements of

00:04:22,200 --> 00:04:30,090
this tool right Ron right so we'll see

00:04:27,510 --> 00:04:31,140
like it may turn out that I'm wrong in

00:04:30,090 --> 00:04:33,210
that case we'll have to do another

00:04:31,140 --> 00:04:36,030
refactoring first where we introduce

00:04:33,210 --> 00:04:39,840
where we make this be one filled with a

00:04:36,030 --> 00:04:41,940
tuple right to be honest I actually

00:04:39,840 --> 00:04:45,150
would prefer if we did that eventually

00:04:41,940 --> 00:04:48,140
just because I would like this to map to

00:04:45,150 --> 00:04:51,180
a restaurant it's just sort of nice

00:04:48,140 --> 00:04:55,020
conceptually but it would be kind of

00:04:51,180 --> 00:04:58,080
annoying to do and I don't know that

00:04:55,020 --> 00:04:59,400
it's this step I would want to take like

00:04:58,080 --> 00:05:02,640
it might be a better to do as a cleanup

00:04:59,400 --> 00:05:03,720
pass afterwards I see okay so let's put

00:05:02,640 --> 00:05:07,860
a note about this though

00:05:03,720 --> 00:05:13,280
note that the struct above is not legal

00:05:07,860 --> 00:05:20,250
rust syntax because the up bar fields

00:05:13,280 --> 00:05:28,440
get their type from elements of the UK

00:05:20,250 --> 00:05:33,320
tuple we can do this because this struct

00:05:28,440 --> 00:05:33,320
is not truly represented as a

00:05:44,460 --> 00:05:49,400
we might want to

00:05:51,160 --> 00:06:13,600
refactor to a single field up bars to

00:06:02,960 --> 00:06:19,639
bull-type just to be nice okay so let's

00:06:13,600 --> 00:06:21,880
modify so let's see so how would we

00:06:19,639 --> 00:06:28,100
actually make this change happen well

00:06:21,880 --> 00:06:30,680
first thing is there's a path called or

00:06:28,100 --> 00:06:33,229
you know about the query system I think

00:06:30,680 --> 00:06:39,530
great and so there's a query called

00:06:33,229 --> 00:06:42,370
generics of you can see it here and it's

00:06:39,530 --> 00:06:46,400
the one that says for any given def ID

00:06:42,370 --> 00:06:48,590
what what is the number of generic type

00:06:46,400 --> 00:06:50,449
parameters that it has basically what

00:06:48,590 --> 00:06:53,240
are the generic type members declared on

00:06:50,449 --> 00:06:56,120
right and so you can see here the

00:06:53,240 --> 00:07:00,740
definition it starts out it has this def

00:06:56,120 --> 00:07:04,630
ID and it converts that to a note ID

00:07:00,740 --> 00:07:08,389
which is old crap that we still have

00:07:04,630 --> 00:07:09,979
identifies a note in here grabs that

00:07:08,389 --> 00:07:11,840
node looks at it says kind of what what

00:07:09,979 --> 00:07:12,470
is this stuff I evasive what kind of

00:07:11,840 --> 00:07:15,410
thing is it

00:07:12,470 --> 00:07:17,990
and the thing we're interested in is

00:07:15,410 --> 00:07:18,620
this case where what we have is a

00:07:17,990 --> 00:07:25,070
closure

00:07:18,620 --> 00:07:27,440
so in that case actually what it's doing

00:07:25,070 --> 00:07:30,470
here when it calls closure based fiu so

00:07:27,440 --> 00:07:33,080
this this is computing the parent def ID

00:07:30,470 --> 00:07:34,220
the idea for the generics struct I don't

00:07:33,080 --> 00:07:43,810
know if we looked at that before you

00:07:34,220 --> 00:07:46,360
forget is that it is there it is it is

00:07:43,810 --> 00:07:51,050
there actually like a little bit of a

00:07:46,360 --> 00:07:52,250
linked list of generics right so you

00:07:51,050 --> 00:07:54,050
have what are the type parameters

00:07:52,250 --> 00:07:58,070
declared on this particular thing and

00:07:54,050 --> 00:07:59,930
then it has a parent and there and you

00:07:58,070 --> 00:08:00,850
kind of inherit the type parameters from

00:07:59,930 --> 00:08:02,980
your parent

00:08:00,850 --> 00:08:06,400
this is so you can think of like a

00:08:02,980 --> 00:08:08,230
method has some type parameters and then

00:08:06,400 --> 00:08:09,580
it's inside of an info on the info might

00:08:08,230 --> 00:08:11,230
have type parameters and all of those

00:08:09,580 --> 00:08:15,100
parameters are in scope in the method

00:08:11,230 --> 00:08:20,080
right this list is never very long I

00:08:15,100 --> 00:08:23,110
think it's usually of length 1 or like 1

00:08:20,080 --> 00:08:25,470
or 2 basically but we might add some

00:08:23,110 --> 00:08:28,690
extra levels synthetic levels I forget

00:08:25,470 --> 00:08:31,330
but it's not not for long

00:08:28,690 --> 00:08:33,310
in any case what we want in the case of

00:08:31,330 --> 00:08:36,280
a closure the way we do it is that the

00:08:33,310 --> 00:08:39,729
closure parameters the closures parent

00:08:36,280 --> 00:08:41,860
is the enclosing function which may

00:08:39,729 --> 00:08:43,450
itself have a parent so a closure inside

00:08:41,860 --> 00:08:44,140
a method would have like a list of

00:08:43,450 --> 00:08:50,500
length 3

00:08:44,140 --> 00:08:51,850
right that makes it-- yeah so here so

00:08:50,500 --> 00:08:54,070
here when we call closure base

00:08:51,850 --> 00:08:56,260
definitely all that does is basically

00:08:54,070 --> 00:08:57,550
walk up in case it's a closure inside a

00:08:56,260 --> 00:09:00,190
closure inside a closure it walks

00:08:57,550 --> 00:09:03,250
through the list of folders to find the

00:09:00,190 --> 00:09:05,770
innermost non closure and that's the

00:09:03,250 --> 00:09:08,500
parent so because there's moisture out

00:09:05,770 --> 00:09:12,880
there most innermost right so if you if

00:09:08,500 --> 00:09:24,010
you have like in both ooh let's say a

00:09:12,880 --> 00:09:25,960
function our e let x equals then this is

00:09:24,010 --> 00:09:27,820
this is the one we want you go off to

00:09:25,960 --> 00:09:31,450
the innermost which is bar that's gonna

00:09:27,820 --> 00:09:45,780
be our parent ok right and it of course

00:09:31,450 --> 00:09:47,680
has a sort of grandparent us ok so I

00:09:45,780 --> 00:09:49,180
guess it doesn't really matter if his

00:09:47,680 --> 00:09:52,270
innermost outermost because there's only

00:09:49,180 --> 00:09:54,880
one function but anyway so right so then

00:09:52,270 --> 00:09:57,670
what we do so now we have the parent def

00:09:54,880 --> 00:10:02,050
ID that we match on the actual thing

00:09:57,670 --> 00:10:06,570
itself that we're computing the generic

00:10:02,050 --> 00:10:06,570
so in this case it's going to be a

00:10:06,880 --> 00:10:16,839
wait what is this oh I see in this case

00:10:13,839 --> 00:10:20,259
it's gonna be an expression because it's

00:10:16,839 --> 00:10:22,480
a closure right so if you look here

00:10:20,259 --> 00:10:23,860
you'll see that there's actually no it

00:10:22,480 --> 00:10:25,839
goes to the underscore case and

00:10:23,860 --> 00:10:29,410
basically here what we're doing is we're

00:10:25,839 --> 00:10:32,170
computing what are the generics that

00:10:29,410 --> 00:10:33,850
were in that ast that like the user

00:10:32,170 --> 00:10:37,720
wrote what were the generic declarations

00:10:33,850 --> 00:10:39,190
that the user wrote right and so for a

00:10:37,720 --> 00:10:41,170
closure there are none because there are

00:10:39,190 --> 00:10:43,389
no space for them but like on a method

00:10:41,170 --> 00:10:46,029
or something there would be that would

00:10:43,389 --> 00:10:48,839
be like the ast for this syntax here

00:10:46,029 --> 00:10:53,920
right so this way we get no generics and

00:10:48,839 --> 00:10:58,540
then now what's going on here is we

00:10:53,920 --> 00:11:01,000
start to do some like manipulations

00:10:58,540 --> 00:11:03,610
basically what this is doing is counting

00:11:01,000 --> 00:11:10,209
how many generic parameters came from

00:11:03,610 --> 00:11:13,509
the parent scope because when we we give

00:11:10,209 --> 00:11:15,209
each generic parameter an index I'm

00:11:13,509 --> 00:11:18,189
gonna make a little buffer really

00:11:15,209 --> 00:11:25,029
talking about this so like if I have

00:11:18,189 --> 00:11:28,209
like something like this right what's

00:11:25,029 --> 00:11:31,269
gonna happen is we're gonna assign this

00:11:28,209 --> 00:11:34,750
the index 0 we're gonna assign this the

00:11:31,269 --> 00:11:38,769
index 1 and so the starting index

00:11:34,750 --> 00:11:42,069
depends on the parent right and this has

00:11:38,769 --> 00:11:47,139
self thing this is like in a trait like

00:11:42,069 --> 00:11:55,720
this actually does the self parameter is

00:11:47,139 --> 00:12:07,449
0 this is 1 and if you had a method you

00:11:55,720 --> 00:12:10,019
know you would be 2 but anyway there's

00:12:07,449 --> 00:12:12,279
some stuff around lifetimes not so excit

00:12:10,019 --> 00:12:15,339
here's where we actually create the type

00:12:12,279 --> 00:12:19,630
parameters so all of this is like a no

00:12:15,339 --> 00:12:23,860
op for closures because

00:12:19,630 --> 00:12:26,290
this variable AST generics here is going

00:12:23,860 --> 00:12:29,680
to be the an empty list basically so

00:12:26,290 --> 00:12:32,740
we're gonna now here like iterate over

00:12:29,680 --> 00:12:36,579
all the AST generics but there aren't

00:12:32,740 --> 00:12:40,389
any so okay and here's where we get to

00:12:36,579 --> 00:12:42,579
closures so here we have a little

00:12:40,389 --> 00:12:51,490
special case basically saying if this is

00:12:42,579 --> 00:12:52,959
a closure node what do we do and we

00:12:51,490 --> 00:12:55,810
actually do something slightly different

00:12:52,959 --> 00:12:57,040
for generics sorry for generators and

00:12:55,810 --> 00:13:04,000
closures here

00:12:57,040 --> 00:13:08,050
but the basic idea first we add some

00:13:04,000 --> 00:13:09,519
number of dummy arguments we're not

00:13:08,050 --> 00:13:13,410
gonna change this code this is for these

00:13:09,519 --> 00:13:25,149
slaves but these fixed ones above right

00:13:13,410 --> 00:13:35,110
and if we go back to our declaration go

00:13:25,149 --> 00:13:36,939
back here okay so right there you can

00:13:35,110 --> 00:13:40,569
see the correspondence right so see K

00:13:36,939 --> 00:13:46,509
here yeah corresponds to this closure

00:13:40,569 --> 00:13:49,509
client here and there and so on so we

00:13:46,509 --> 00:13:53,069
add those and now finally you're

00:13:49,509 --> 00:13:53,069
immediately nice to add a comment line

00:14:15,470 --> 00:14:18,519
I don't know what the

00:14:26,440 --> 00:14:31,450
where's the generator stops coming maybe

00:14:30,040 --> 00:14:33,870
there is no corresponding generator

00:14:31,450 --> 00:14:33,870
subscribe

00:14:38,570 --> 00:14:41,290
okay

00:14:44,120 --> 00:14:50,210
so now here is where we add the

00:14:57,460 --> 00:15:02,140
right right

00:15:03,210 --> 00:15:11,940
and so what I want I think what we want

00:15:07,920 --> 00:15:16,640
to do is really the first thing we want

00:15:11,940 --> 00:15:23,270
to do is basically take this away and

00:15:16,640 --> 00:15:23,270
just change this to one parameter

00:15:35,440 --> 00:15:39,660
that makes sense yeah

00:15:44,270 --> 00:15:52,190
now now we have to change a few other

00:15:47,270 --> 00:15:54,440
bits of code too to match and then what

00:15:52,190 --> 00:15:56,290
we have to do is try to build it and

00:15:54,440 --> 00:15:59,360
watch it die a million horrible hard

00:15:56,290 --> 00:16:00,620
hard to diagnose deaths until we get

00:15:59,360 --> 00:16:04,670
everything else that I forgotten about

00:16:00,620 --> 00:16:09,050
right the first thing we can do it

00:16:04,670 --> 00:16:11,270
should be relatively easy now is we were

00:16:09,050 --> 00:16:15,130
making this tuple somewhere right where

00:16:11,270 --> 00:16:25,420
here we go so what we want to do instead

00:16:15,130 --> 00:16:25,420
is just say basically

00:16:27,230 --> 00:16:29,260
ah

00:16:35,070 --> 00:16:43,529
right right yeah similarly in the

00:16:39,600 --> 00:16:46,009
generator sucks we want to just get rid

00:16:43,529 --> 00:16:46,009
of lots

00:16:54,040 --> 00:17:00,750
I guess it is using TCX

00:17:04,880 --> 00:17:12,839
um okay wait that's not everything

00:17:09,150 --> 00:17:14,490
so that's one part I think the rest of

00:17:12,839 --> 00:17:18,270
the code should just be fine because

00:17:14,490 --> 00:17:20,570
nobody directly that was the whole point

00:17:18,270 --> 00:17:22,740
of the work we just did

00:17:20,570 --> 00:17:25,320
just nobody directly accessed

00:17:22,740 --> 00:17:29,310
self-thought stuffs anymore we'll find

00:17:25,320 --> 00:17:37,020
out if that's true but the next thing we

00:17:29,310 --> 00:17:39,990
have to do is so before we were editing

00:17:37,020 --> 00:17:41,520
the generics of query now we have to

00:17:39,990 --> 00:17:45,060
edit the code that when you actually

00:17:41,520 --> 00:17:47,820
encounter a closure in an expression we

00:17:45,060 --> 00:17:49,980
have to assign it a type right

00:17:47,820 --> 00:17:51,630
right that's the code that kind of has

00:17:49,980 --> 00:17:53,390
to be made to match now because that's

00:17:51,630 --> 00:17:55,950
going to actually instantiate a

00:17:53,390 --> 00:17:56,880
reference to one of these closure types

00:17:55,950 --> 00:17:59,340
and it's going to create the

00:17:56,880 --> 00:18:01,110
substitutions array the substrate and it

00:17:59,340 --> 00:18:03,090
has to have one type for everything that

00:18:01,110 --> 00:18:04,560
came from the generic self query so now

00:18:03,090 --> 00:18:06,840
it's gonna have to many types basically

00:18:04,560 --> 00:18:08,490
um because we're gonna have one for

00:18:06,840 --> 00:18:12,480
Alfaro we just want one for the whole

00:18:08,490 --> 00:18:16,970
tuple so right so we're so somewhere in

00:18:12,480 --> 00:18:21,270
here is this with free bars I guess

00:18:16,970 --> 00:18:23,070
where does it actually alright okay or

00:18:21,270 --> 00:18:24,630
not so let's take a look let's read

00:18:23,070 --> 00:18:28,380
through this code a little bit check

00:18:24,630 --> 00:18:29,580
coder it's kind of complicated this this

00:18:28,380 --> 00:18:32,220
part is kind of complicated but luckily

00:18:29,580 --> 00:18:36,210
we don't care about it so what this is

00:18:32,220 --> 00:18:38,100
doing is figuring out the what are the

00:18:36,210 --> 00:18:40,410
parameter types and the argument types

00:18:38,100 --> 00:18:41,460
and so on that we expect that's not

00:18:40,410 --> 00:18:44,070
really relevant to what we're trying to

00:18:41,460 --> 00:18:46,470
do now so we can just ignore that and go

00:18:44,070 --> 00:18:48,210
to this check closure function and you

00:18:46,470 --> 00:18:50,490
see it takes as argument the expected

00:18:48,210 --> 00:18:54,870
signature because if you don't care

00:18:50,490 --> 00:18:59,190
about that right now it's going to do

00:18:54,870 --> 00:19:00,840
some stuff and here we go create so if

00:18:59,190 --> 00:19:08,390
you this is the code that's creating the

00:19:00,840 --> 00:19:11,390
type variables for the up bars and I

00:19:08,390 --> 00:19:11,390
think

00:19:17,059 --> 00:19:26,359
it looks like we don't call with free

00:19:20,209 --> 00:19:36,049
VARs because we we just we just sort of

00:19:26,359 --> 00:19:37,759
matched it looks like we just get the

00:19:36,049 --> 00:19:40,999
generics that it came from that other

00:19:37,759 --> 00:19:42,589
query and we just do the same number of

00:19:40,999 --> 00:19:44,869
things as we're in there so this will

00:19:42,589 --> 00:19:46,639
all kind of already work let's take

00:19:44,869 --> 00:19:47,209
let's walk through the codon make sure

00:19:46,639 --> 00:19:50,899
I'm right

00:19:47,209 --> 00:19:53,569
so what identity for item does is it

00:19:50,899 --> 00:19:55,279
calls subs for item I'll make it easy

00:19:53,569 --> 00:20:02,019
I'll make an example here so like

00:19:55,279 --> 00:20:05,599
example let's say given a struct s

00:20:02,019 --> 00:20:07,959
declared like so what do people normally

00:20:05,599 --> 00:20:07,959
do

00:20:08,390 --> 00:20:11,599
[Music]

00:20:13,040 --> 00:20:32,490
strucked s ABC right so basically this

00:20:27,180 --> 00:20:34,830
returns like within the context from

00:20:32,490 --> 00:20:39,930
inside the context of the declaration it

00:20:34,830 --> 00:20:48,390
just returns the parameter types and the

00:20:39,930 --> 00:20:51,440
idea is you can a lot of times you'll

00:20:48,390 --> 00:20:54,810
have a mapping like from a to you 32b to

00:20:51,440 --> 00:20:59,970
mine 3206 before or something and you

00:20:54,810 --> 00:21:01,950
can apply that mapping to this anyway so

00:20:59,970 --> 00:21:05,940
okay so going back so that was identity

00:21:01,950 --> 00:21:09,900
for item and then that gives us this

00:21:05,940 --> 00:21:16,200
base substitution okay right for the

00:21:09,900 --> 00:21:18,980
closure base Stephanie so this is this

00:21:16,200 --> 00:21:18,980
is the enclosing function

00:21:21,029 --> 00:21:28,339
so if we go back to my example if if we

00:21:25,019 --> 00:21:28,339
had a closure in here

00:21:30,490 --> 00:21:35,900
but this is the what we're doing is

00:21:33,080 --> 00:21:39,140
we're getting this self substitutions

00:21:35,900 --> 00:21:41,870
for the for the enclosing function right

00:21:39,140 --> 00:21:48,140
so basically bass subst will be

00:21:41,870 --> 00:21:48,710
something will start out as tu okay that

00:21:48,140 --> 00:21:52,760
makes sense right

00:21:48,710 --> 00:21:54,640
actually it's going to be self I forget

00:21:52,760 --> 00:21:57,380
where it will order itself probably

00:21:54,640 --> 00:22:00,110
anyway same idea and the point of this

00:21:57,380 --> 00:22:02,720
is those things are actually not

00:22:00,110 --> 00:22:05,720
changing like we're creating the closure

00:22:02,720 --> 00:22:10,600
type from the point of view of of this

00:22:05,720 --> 00:22:12,770
spot so from outside the closure but

00:22:10,600 --> 00:22:14,720
inside and outside the closure we share

00:22:12,770 --> 00:22:16,880
the same like overall context right so

00:22:14,720 --> 00:22:19,039
these are so if you ask me like what is

00:22:16,880 --> 00:22:21,230
the type T in this context the answer is

00:22:19,039 --> 00:22:24,260
it's steam it's a placeholder for T

00:22:21,230 --> 00:22:26,030
right for some unknown 20 so so that's

00:22:24,260 --> 00:22:28,280
the best of starting point and then we

00:22:26,030 --> 00:22:33,350
call extend to and here we give it the

00:22:28,280 --> 00:22:34,909
actual def idea of the closure right so

00:22:33,350 --> 00:22:36,679
we just we just modified into the

00:22:34,909 --> 00:22:39,950
generics of this or going to be like

00:22:36,679 --> 00:22:41,419
self to you whatever I suppose your

00:22:39,950 --> 00:22:44,720
signature close or something in the up

00:22:41,419 --> 00:22:46,730
bars right let me up to crank up first

00:22:44,720 --> 00:22:52,210
so what this extend to was going to do

00:22:46,730 --> 00:22:52,210
is add in for each missing thing

00:22:54,909 --> 00:23:04,940
something which comes from this closure

00:22:58,270 --> 00:23:06,230
this disclosure here is code way and if

00:23:04,940 --> 00:23:13,130
you look at that code it just creates

00:23:06,230 --> 00:23:14,390
fresh diaper please so and we we can

00:23:13,130 --> 00:23:16,039
error out in the case of lifetimes

00:23:14,390 --> 00:23:17,570
because this is basically what are the

00:23:16,039 --> 00:23:18,890
extra type parameters we add it to the

00:23:17,570 --> 00:23:22,039
closure and we know that they're never

00:23:18,890 --> 00:23:23,809
lifetimes so this code is all a

00:23:22,039 --> 00:23:26,679
long-winded way to say that this code

00:23:23,809 --> 00:23:30,610
should be all fine instead of making an

00:23:26,679 --> 00:23:34,039
OP far as we now have exactly one right

00:23:30,610 --> 00:23:45,010
right and now this is the generator code

00:23:34,039 --> 00:23:45,010
this is fine thumb what this does is oh

00:23:45,340 --> 00:23:48,590
okay I see

00:23:46,640 --> 00:23:50,809
so this says if we know some stuff about

00:23:48,590 --> 00:23:54,169
the generator if you remember in the

00:23:50,809 --> 00:23:58,520
case of a generator well actually have

00:23:54,169 --> 00:24:03,580
like an extra variable in here so it's

00:23:58,520 --> 00:24:05,600
going to unify now these three variables

00:24:03,580 --> 00:24:07,370
that's what this is doing right it's

00:24:05,600 --> 00:24:11,029
unifying with what we know the yield

00:24:07,370 --> 00:24:12,500
type to be that gets unified with the

00:24:11,029 --> 00:24:18,020
variable that we extract from the

00:24:12,500 --> 00:24:20,720
substitutions okay great and then we

00:24:18,020 --> 00:24:25,279
call make the closure and all make the

00:24:20,720 --> 00:24:29,539
closure does is basically in turn the

00:24:25,279 --> 00:24:32,320
pair of the def ID of the closure with

00:24:29,539 --> 00:24:36,770
this substitutions that we have here

00:24:32,320 --> 00:24:40,640
that's the closure type and that's the

00:24:36,770 --> 00:24:45,309
type of arts question all done nobody in

00:24:40,640 --> 00:24:51,200
here in this code actually cares about

00:24:45,309 --> 00:24:52,580
the the types of the out cars right so

00:24:51,200 --> 00:24:58,560
they're just type variables that don't

00:24:52,580 --> 00:25:02,130
get changed hmm so far so good yeah

00:24:58,560 --> 00:25:08,580
so where this starts to change is the up

00:25:02,130 --> 00:25:11,100
for analysis so this code runs when we

00:25:08,580 --> 00:25:16,950
type check a function this code runs

00:25:11,100 --> 00:25:22,860
sort of at the very end I think this

00:25:16,950 --> 00:25:24,210
closure analyze function let's yeah so

00:25:22,860 --> 00:25:26,220
kind of after we've done a bunch of

00:25:24,210 --> 00:25:27,930
other stuff then we come back over and

00:25:26,220 --> 00:25:30,630
now we try to figure out the types of

00:25:27,930 --> 00:25:32,220
you deploys and the reason we do that's

00:25:30,630 --> 00:25:37,650
the late is we want to know how those up

00:25:32,220 --> 00:25:40,230
Farscape used within the closure body in

00:25:37,650 --> 00:25:46,170
order to decide if they're move or and

00:25:40,230 --> 00:25:48,470
mute or what um so the details of this I

00:25:46,170 --> 00:25:50,460
think we talked about this before a bit

00:25:48,470 --> 00:25:59,390
well it doesn't really matter too much

00:25:50,460 --> 00:26:04,830
how the inference works that's the

00:25:59,390 --> 00:26:06,540
important thing is right okay so I'll

00:26:04,830 --> 00:26:10,280
just sort of walk through quickly so

00:26:06,540 --> 00:26:12,510
what the but what the inference does

00:26:10,280 --> 00:26:14,450
first we get the type of the closure

00:26:12,510 --> 00:26:18,030
okay that's fine

00:26:14,450 --> 00:26:21,900
and they basically pull it apart into

00:26:18,030 --> 00:26:23,040
the def ID and the substitutions and of

00:26:21,900 --> 00:26:25,910
course the type of the closure had

00:26:23,040 --> 00:26:31,610
better be closed or else something crazy

00:26:25,910 --> 00:26:34,110
and then we for every up variable we

00:26:31,610 --> 00:26:35,700
create in this part of the code what

00:26:34,110 --> 00:26:37,710
we're doing is basically in the infants

00:26:35,700 --> 00:26:39,810
we're going to keep a little bit of

00:26:37,710 --> 00:26:42,810
information which we call the off for

00:26:39,810 --> 00:26:43,940
capture map about how that variable got

00:26:42,810 --> 00:26:46,590
used

00:26:43,940 --> 00:26:50,790
we start off assuming that it's only

00:26:46,590 --> 00:26:53,130
read from like the most minimal

00:26:50,790 --> 00:26:55,050
requirement you could put on this and

00:26:53,130 --> 00:26:57,540
then when we see if we see that it's

00:26:55,050 --> 00:26:59,220
written to will up that to oh and it

00:26:57,540 --> 00:27:02,640
gets mutated if we see that it's moved

00:26:59,220 --> 00:27:04,950
or up into oh and gets move and so on

00:27:02,640 --> 00:27:07,980
right but that's all in this like

00:27:04,950 --> 00:27:13,560
internal data structure for extranet

00:27:07,980 --> 00:27:14,970
we don't care about that we go in

00:27:13,560 --> 00:27:21,060
particular I don't think any of this

00:27:14,970 --> 00:27:22,530
code none of this code touches the

00:27:21,060 --> 00:27:24,060
substitution so none of this code

00:27:22,530 --> 00:27:28,410
interacts with these type variables that

00:27:24,060 --> 00:27:32,130
we've created we have this internal data

00:27:28,410 --> 00:27:34,110
structure we we then what this code does

00:27:32,130 --> 00:27:36,180
is it basically walks over the function

00:27:34,110 --> 00:27:38,250
body and this is where that where we're

00:27:36,180 --> 00:27:45,710
looking to see oh this fr got written to

00:27:38,250 --> 00:27:59,040
O this F archive mutated whatever and I

00:27:45,710 --> 00:28:00,870
think I think it is still true that well

00:27:59,040 --> 00:28:04,730
we're gonna find out I think it is still

00:28:00,870 --> 00:28:10,650
true that this doesn't interact with the

00:28:04,730 --> 00:28:12,870
types from that closure substitution but

00:28:10,650 --> 00:28:15,330
like this those type inference variables

00:28:12,870 --> 00:28:19,230
it could be that something in here is

00:28:15,330 --> 00:28:22,980
gonna try to call methods on the closure

00:28:19,230 --> 00:28:24,900
substance and get upset because it's

00:28:22,980 --> 00:28:28,170
gonna find not a tuple of up front types

00:28:24,900 --> 00:28:39,690
but I'm not inferred type variable C

00:28:28,170 --> 00:28:42,090
we'll find out what this is doing is

00:28:39,690 --> 00:28:44,820
once we figure out this is basically

00:28:42,090 --> 00:28:50,970
recording whether the closure is FN once

00:28:44,820 --> 00:28:54,270
FM finally this is where it gets

00:28:50,970 --> 00:28:58,860
interesting to us so here we have the

00:28:54,270 --> 00:29:04,140
final up for our types so these are the

00:28:58,860 --> 00:29:07,290
types that now that we know how the

00:29:04,140 --> 00:29:08,910
variable is used we can compute a type

00:29:07,290 --> 00:29:11,430
for each of the free variables right so

00:29:08,910 --> 00:29:15,780
like you go through each of the

00:29:11,430 --> 00:29:19,200
variables that are captured we see we

00:29:15,780 --> 00:29:21,450
read information about what we tried to

00:29:19,200 --> 00:29:23,490
do with it did we need to take ownership

00:29:21,450 --> 00:29:26,160
if we needed to take ownership this is

00:29:23,490 --> 00:29:28,530
that Miss then computing the type of the

00:29:26,160 --> 00:29:32,940
field and the resulting closure like so

00:29:28,530 --> 00:29:39,870
if if we have a variable like some

00:29:32,940 --> 00:29:44,550
vector back 1 2 3 and then we have

00:29:39,870 --> 00:29:52,770
something like another vector 4 5 6 then

00:29:44,550 --> 00:29:56,580
you have some you know juror 22 then and

00:29:52,770 --> 00:30:00,420
let's say that the closure does stuff

00:29:56,580 --> 00:30:04,820
like this sort of drops some deck it

00:30:00,420 --> 00:30:10,290
pushes a value here and it prints out

00:30:04,820 --> 00:30:12,060
some integer then the resulting this is

00:30:10,290 --> 00:30:14,100
going to be by move this is going to be

00:30:12,060 --> 00:30:22,170
by mute and this would be like by shared

00:30:14,100 --> 00:30:26,880
reference and the resulting closure

00:30:22,170 --> 00:30:30,960
struct would have the resulting types

00:30:26,880 --> 00:30:33,870
let's say of the capture of bars would

00:30:30,960 --> 00:30:39,630
be for some that will just capture that

00:30:33,870 --> 00:30:44,690
just like it is for another Veck will

00:30:39,630 --> 00:30:51,930
have a borrow right and for some integer

00:30:44,690 --> 00:30:53,820
a borrow as well so that's what you see

00:30:51,930 --> 00:30:55,950
going on here like if it's moved

00:30:53,820 --> 00:30:59,700
this is computing for each out bar what

00:30:55,950 --> 00:31:02,010
is the sort of type starting from the

00:30:59,700 --> 00:31:04,410
type in the parent which would be like a

00:31:02,010 --> 00:31:08,600
vector like 32 it'll add an ampersand

00:31:04,410 --> 00:31:12,780
make ref this creates an ampersand type

00:31:08,600 --> 00:31:14,700
and it's either the region northern

00:31:12,780 --> 00:31:17,940
regions it's either a abuse and Orient's

00:31:14,700 --> 00:31:20,690
and you depending on whether this was

00:31:17,940 --> 00:31:20,690
immutable or not

00:31:22,490 --> 00:31:26,510
you got some comments here

00:32:08,580 --> 00:32:16,990
that makes sense yeah okay so this is

00:32:12,790 --> 00:32:18,640
going to compute a vector of types now

00:32:16,990 --> 00:32:20,170
this doesn't actually do anything with

00:32:18,640 --> 00:32:22,180
these types it just computes them and

00:32:20,170 --> 00:32:26,500
that's the vector and the final up four

00:32:22,180 --> 00:32:28,570
types so now at long last we get to the

00:32:26,500 --> 00:32:32,050
particle and interested in which

00:32:28,570 --> 00:32:33,760
iterates through the types of each up

00:32:32,050 --> 00:32:36,400
bar and unifies them with the

00:32:33,760 --> 00:32:37,690
corresponding final type and this is

00:32:36,400 --> 00:32:50,020
what we want to change we want to say

00:32:37,690 --> 00:32:54,040
something like this would make to bow we

00:32:50,020 --> 00:32:55,600
want to instead of doing instead of we

00:32:54,040 --> 00:33:00,880
basically don't have to do this just

00:32:55,600 --> 00:33:03,850
work anymore we can say we can make a

00:33:00,880 --> 00:33:08,590
tuple of these types and then we can get

00:33:03,850 --> 00:33:13,140
the up for our tuple type and we can do

00:33:08,590 --> 00:33:13,140
this and that will have the same effect

00:33:14,160 --> 00:33:18,160
because that's just how to people's work

00:33:16,600 --> 00:33:21,540
when we make when we relate these two

00:33:18,160 --> 00:33:21,540
possible relate all the types with you

00:33:23,190 --> 00:33:35,950
so yeah it's okay um so I'm good yes

00:33:31,720 --> 00:33:37,270
good that might be I don't know let's

00:33:35,950 --> 00:33:39,880
find out that might be everything we

00:33:37,270 --> 00:33:43,200
have to do I would be a little surprised

00:33:39,880 --> 00:33:45,280
I bet there's some code somewhere else

00:33:43,200 --> 00:33:47,860
probably in the code generator or

00:33:45,280 --> 00:33:49,060
something but you might all the other

00:33:47,860 --> 00:33:51,250
code might go through the closure

00:33:49,060 --> 00:33:53,380
suppsed that would be nice if that were

00:33:51,250 --> 00:33:55,890
true because in that case we've already

00:33:53,380 --> 00:33:55,890
done the work

00:34:10,310 --> 00:34:14,720
so let's see so what we did here we

00:34:15,320 --> 00:34:32,389
change closure generics to produce a two

00:34:18,990 --> 00:34:39,000
bull about bars also change closer slips

00:34:32,389 --> 00:34:42,300
and apart influence too much its did not

00:34:39,000 --> 00:34:52,200
quite compile because this needs to be

00:34:42,300 --> 00:35:00,720
an iterator I guess oh ok so this type

00:34:52,200 --> 00:35:02,990
up forceps I guess this just doesn't

00:35:00,720 --> 00:35:02,990
have a

00:35:04,960 --> 00:35:08,170
Miss Muffet

00:35:22,700 --> 00:35:26,109
and I guess this code is

00:35:30,070 --> 00:35:33,870
also normally we put a space

00:35:59,290 --> 00:36:14,720
yeah so just work why doing stuff like

00:36:11,870 --> 00:36:24,740
that be kind of amazing it's just

00:36:14,720 --> 00:36:28,310
actually weird so while we're waiting

00:36:24,740 --> 00:36:35,630
your any questions kind of into a lot of

00:36:28,310 --> 00:36:37,790
stuff do ya know no questions like I'll

00:36:35,630 --> 00:36:49,210
probably realize this video later

00:36:37,790 --> 00:36:52,580
tonight okay well we built it builds but

00:36:49,210 --> 00:36:53,770
that is to say tech checks that's not

00:36:52,580 --> 00:36:58,970
saying a whole lot

00:36:53,770 --> 00:37:01,010
um unfortunately this is not the sort of

00:36:58,970 --> 00:37:04,700
change where just because it's a checks

00:37:01,010 --> 00:37:07,240
you know so I'm probably gonna have to

00:37:04,700 --> 00:37:09,440
go in a little bit what I'll do is all

00:37:07,240 --> 00:37:11,570
we have a few more minutes but until

00:37:09,440 --> 00:37:15,860
then I'll push this stuff to your branch

00:37:11,570 --> 00:37:17,060
when we're done sure and I think let's

00:37:15,860 --> 00:37:20,270
hope let's see if we can get to the

00:37:17,060 --> 00:37:21,710
first ice because I don't know how much

00:37:20,270 --> 00:37:22,940
experience you have to bugging knows it

00:37:21,710 --> 00:37:27,260
it would be nice if I could show you

00:37:22,940 --> 00:37:29,810
something some oh my oh you think it ice

00:37:27,260 --> 00:37:31,970
out oh yeah I'm pretty sure it's gonna

00:37:29,810 --> 00:37:35,780
be somewhere so what I think is gonna

00:37:31,970 --> 00:37:36,740
happen is some code I mean if we're

00:37:35,780 --> 00:37:41,750
lucky is can ice

00:37:36,740 --> 00:37:43,430
so some bit of code well forget that

00:37:41,750 --> 00:37:44,750
about what I said about lucky but so

00:37:43,430 --> 00:37:49,340
some bit of code is gonna have a

00:37:44,750 --> 00:37:51,050
mismatched assumption about both the set

00:37:49,340 --> 00:37:53,210
of generics on the closure right that

00:37:51,050 --> 00:37:55,760
it's kind of hard coded to assume the

00:37:53,210 --> 00:37:58,640
old set up and so it's gonna try to grab

00:37:55,760 --> 00:38:00,650
a type variable that doesn't exist or

00:37:58,640 --> 00:38:06,620
something at least that's what I would I

00:38:00,650 --> 00:38:08,210
would think but we'll find out like I

00:38:06,620 --> 00:38:09,890
said it's possible that that actually

00:38:08,210 --> 00:38:11,680
won't be the case that would be really

00:38:09,890 --> 00:38:13,270
cool

00:38:11,680 --> 00:38:15,130
the annoying thing this is what's going

00:38:13,270 --> 00:38:16,720
to be annoying now I just realized is

00:38:15,130 --> 00:38:19,420
that normally ices are kind of good

00:38:16,720 --> 00:38:25,540
because I mean depending a point of view

00:38:19,420 --> 00:38:28,960
but because they they die sort of very

00:38:25,540 --> 00:38:32,710
early or they die very easy it's easy to

00:38:28,960 --> 00:38:35,260
trace it to where it's dying but what's

00:38:32,710 --> 00:38:36,940
probably gonna happen is that we're

00:38:35,260 --> 00:38:38,560
gonna get an ice the first thing we do

00:38:36,940 --> 00:38:43,480
after we build the GNU Compiler is we

00:38:38,560 --> 00:38:46,480
try to build the core and usually with a

00:38:43,480 --> 00:38:48,760
change like this that will die because

00:38:46,480 --> 00:38:52,870
Lib core actually uses a lot of language

00:38:48,760 --> 00:38:55,660
features and that's annoying because

00:38:52,870 --> 00:38:57,190
debugging like if you have a lip

00:38:55,660 --> 00:38:59,050
standard it's kind of nice you can make

00:38:57,190 --> 00:38:59,620
a minimal type a minimal example and

00:38:59,050 --> 00:39:02,170
debug it

00:38:59,620 --> 00:39:05,400
but debugging lib core when the core

00:39:02,170 --> 00:39:07,180
feels super pain in the neck however

00:39:05,400 --> 00:39:08,710
because there's a whole lot of code

00:39:07,180 --> 00:39:10,390
basically and it's kind of complicated

00:39:08,710 --> 00:39:12,640
and you have to like interrupt the

00:39:10,390 --> 00:39:20,200
bootstrapping process and so on but I

00:39:12,640 --> 00:39:22,780
have a trick what I usually do is I have

00:39:20,200 --> 00:39:27,190
a little like what I call the Lib core

00:39:22,780 --> 00:39:29,650
template that's is the thing about Lib

00:39:27,190 --> 00:39:32,500
core is it has some types the compiler

00:39:29,650 --> 00:39:34,750
and it needs to know about like send and

00:39:32,500 --> 00:39:38,590
sized and so on you sort of built-in

00:39:34,750 --> 00:39:41,470
traits so my core template has like very

00:39:38,590 --> 00:39:43,960
minimal definitions there are enough to

00:39:41,470 --> 00:39:48,670
get you up in compiling but not really

00:39:43,960 --> 00:39:50,830
right and then usually what you can do

00:39:48,670 --> 00:39:54,160
then is when you see a nice you sort of

00:39:50,830 --> 00:39:58,000
copy and paste just enough to reproduce

00:39:54,160 --> 00:39:59,650
the ice into this core template and then

00:39:58,000 --> 00:40:03,810
you can debug against that which is a

00:39:59,650 --> 00:40:07,720
lot less code and a lot more tractable

00:40:03,810 --> 00:40:09,820
so that's one option another option is

00:40:07,720 --> 00:40:12,400
if we could make this change conditional

00:40:09,820 --> 00:40:13,810
like maybe we make it that would be a

00:40:12,400 --> 00:40:16,150
little annoying to do but I guess not so

00:40:13,810 --> 00:40:18,970
hard you could imagine passing in a flag

00:40:16,150 --> 00:40:22,300
to the compiler to tap to tell it to use

00:40:18,970 --> 00:40:24,130
this new code and then we'd have to go

00:40:22,300 --> 00:40:25,870
back and undo some of the changes

00:40:24,130 --> 00:40:28,660
just did but or make them check a flag

00:40:25,870 --> 00:40:30,280
to decide which version to do the nice

00:40:28,660 --> 00:40:31,600
thing about that would be then when it

00:40:30,280 --> 00:40:35,590
builds live core and stuff it's gonna

00:40:31,600 --> 00:40:37,330
use the old style and when you build a

00:40:35,590 --> 00:40:39,790
new example it'll use the new style but

00:40:37,330 --> 00:40:41,380
I think that would probably wind up that

00:40:39,790 --> 00:40:43,420
would be annoying and I think it would

00:40:41,380 --> 00:40:46,990
probably get us in trouble I think about

00:40:43,420 --> 00:40:48,580
it because it would break because then

00:40:46,990 --> 00:40:51,070
code that was compiled from the Bakura

00:40:48,580 --> 00:40:53,860
has a different structure than code that

00:40:51,070 --> 00:40:55,060
comes from the current crate we're

00:40:53,860 --> 00:40:57,040
building like when you use the spike

00:40:55,060 --> 00:41:00,060
closures are set up differently and that

00:40:57,040 --> 00:41:04,350
might cause problems I don't know um so

00:41:00,060 --> 00:41:08,310
I probably wouldn't do that actually hmm

00:41:04,350 --> 00:41:14,290
we'll see anyway what I would recommend

00:41:08,310 --> 00:41:16,210
is as a side note is to build with the

00:41:14,290 --> 00:41:18,940
incremental option I don't know if you

00:41:16,210 --> 00:41:24,010
already do that but right yeah just

00:41:18,940 --> 00:41:25,530
because at least when when I'm debugging

00:41:24,010 --> 00:41:27,820
this sort of thing

00:41:25,530 --> 00:41:31,120
well I always do is turn on the rest

00:41:27,820 --> 00:41:32,410
logs dump out a bunch of information and

00:41:31,120 --> 00:41:35,440
you never double you have to add some

00:41:32,410 --> 00:41:36,580
more across logs and then that's where

00:41:35,440 --> 00:41:39,850
the incremental builds are really nice

00:41:36,580 --> 00:41:41,560
because you can kind of get your get the

00:41:39,850 --> 00:41:43,770
output of your new debug print out much

00:41:41,560 --> 00:41:43,770
faster

00:41:47,700 --> 00:41:55,720
so this lib cool template that you were

00:41:51,970 --> 00:41:59,860
talking about you you create it and you

00:41:55,720 --> 00:42:01,630
replace it in no no no lib I mean I did

00:41:59,860 --> 00:42:05,760
create it yes but I don't replace it in

00:42:01,630 --> 00:42:08,740
the repository what I do instead is I

00:42:05,760 --> 00:42:15,670
have it all I'll send you it it's on get

00:42:08,740 --> 00:42:20,110
up somewhere but I I basically just with

00:42:15,670 --> 00:42:25,450
directories this you would just sort of

00:42:20,110 --> 00:42:26,530
do this we just kind of build it well

00:42:25,450 --> 00:42:34,150
that's interesting

00:42:26,530 --> 00:42:36,130
oh yeah so that's some weird problem I

00:42:34,150 --> 00:42:37,280
don't think that's actually our fault my

00:42:36,130 --> 00:42:40,310
computer has some kind of

00:42:37,280 --> 00:42:42,860
thing that happens let's see if that

00:42:40,310 --> 00:42:44,810
reproduces but for some reason that I

00:42:42,860 --> 00:42:47,300
don't know I get random crashes in LVM

00:42:44,810 --> 00:42:49,880
and nobody else seems to have this

00:42:47,300 --> 00:42:56,720
problem but me it's kind of weird and

00:42:49,880 --> 00:42:58,730
kind of scared yeah I'm not sure if it's

00:42:56,720 --> 00:42:59,990
a hardware I've tested the hardware a

00:42:58,730 --> 00:43:04,220
whole bunch of times that never found a

00:42:59,990 --> 00:43:06,680
problem but or what but anyway all right

00:43:04,220 --> 00:43:08,000
so so by now I know though if I see some

00:43:06,680 --> 00:43:08,770
weird crash and I love um I should try

00:43:08,000 --> 00:43:12,590
it again

00:43:08,770 --> 00:43:17,690
um it's not only all of them but it's

00:43:12,590 --> 00:43:20,210
usually um anyway the point is you can

00:43:17,690 --> 00:43:24,560
build this just like so you just build

00:43:20,210 --> 00:43:32,630
it like a library and it's got all these

00:43:24,560 --> 00:43:35,510
little weird no that looks again another

00:43:32,630 --> 00:43:39,740
six egg feeds probably not like we're

00:43:35,510 --> 00:43:41,330
not even are we we're not even running I

00:43:39,740 --> 00:43:45,020
don't think yeah we're still running

00:43:41,330 --> 00:43:47,930
though we haven't even run our code yet

00:43:45,020 --> 00:43:50,690
we're running like the bootstrap just

00:43:47,930 --> 00:43:56,290
ate the stage zero compilers I really

00:43:50,690 --> 00:43:59,390
wish I knew what was going on can you

00:43:56,290 --> 00:44:03,500
like a little bit tell me about what

00:43:59,390 --> 00:44:07,310
this lab core does what like what the

00:44:03,500 --> 00:44:08,720
court does in general yeah cliff core is

00:44:07,310 --> 00:44:13,070
so ellipse standard is the standard

00:44:08,720 --> 00:44:16,880
library the standard library has some

00:44:13,070 --> 00:44:18,980
internal crates that it's built from and

00:44:16,880 --> 00:44:21,890
the smallest of those is called the core

00:44:18,980 --> 00:44:24,080
and the core is a special one because

00:44:21,890 --> 00:44:29,390
it's the only core it's the only library

00:44:24,080 --> 00:44:30,920
that is required for all bus programs so

00:44:29,390 --> 00:44:32,540
the rest of them standard you can opt

00:44:30,920 --> 00:44:35,450
out Earth by using the no standard

00:44:32,540 --> 00:44:38,780
attribute but you can't opt out of Lib

00:44:35,450 --> 00:44:40,340
core at least not unstable rust we do

00:44:38,780 --> 00:44:41,750
actually have a flag for it because we

00:44:40,340 --> 00:44:46,370
need it as part of the bootstrapping

00:44:41,750 --> 00:44:49,250
process but the the reason that it's

00:44:46,370 --> 00:44:50,760
required it's very minimal in some sense

00:44:49,250 --> 00:44:52,320
it only has things

00:44:50,760 --> 00:44:53,580
the like doesn't place any real

00:44:52,320 --> 00:44:56,369
requirements on the host operating

00:44:53,580 --> 00:44:58,680
system but it does have some basic

00:44:56,369 --> 00:44:59,340
concepts that are like part of the

00:44:58,680 --> 00:45:00,930
language

00:44:59,340 --> 00:45:03,780
they're like library types but they're

00:45:00,930 --> 00:45:06,030
part of the language right stuff like

00:45:03,780 --> 00:45:08,369
size the size to treat this is where the

00:45:06,030 --> 00:45:10,590
Declaration of the size trig is and this

00:45:08,369 --> 00:45:13,380
laying declaration here this is another

00:45:10,590 --> 00:45:16,470
unstable things that's an internal thing

00:45:13,380 --> 00:45:18,240
to the compiler saying this this is the

00:45:16,470 --> 00:45:21,470
size check this is not just a trade name

00:45:18,240 --> 00:45:23,910
size right this is these I stirred so

00:45:21,470 --> 00:45:27,600
and all these similar leaks to these

00:45:23,910 --> 00:45:30,600
other things and those those those

00:45:27,600 --> 00:45:32,330
attributes can only actually they can be

00:45:30,600 --> 00:45:36,510
in the things that are not core but they

00:45:32,330 --> 00:45:38,160
there can only be one crate like there

00:45:36,510 --> 00:45:39,960
can only be one trait that is tagged as

00:45:38,160 --> 00:45:42,180
the size trait in your entire crate

00:45:39,960 --> 00:45:46,730
grasp and because everybody has to have

00:45:42,180 --> 00:45:48,930
Lib core it's always this one right um

00:45:46,730 --> 00:45:50,700
and it would be unstable objects that

00:45:48,930 --> 00:45:52,109
you every night point you know these

00:45:50,700 --> 00:45:57,240
bases that are not meant to be used by

00:45:52,109 --> 00:45:58,560
at normal rest developers yeah so that's

00:45:57,240 --> 00:46:00,390
that's what that's the rolled up core

00:45:58,560 --> 00:46:03,300
place that's why it's special and why

00:46:00,390 --> 00:46:04,890
you kind of want this minimal set of

00:46:03,300 --> 00:46:07,170
things so that the compiler can actually

00:46:04,890 --> 00:46:08,670
start up and get going without these

00:46:07,170 --> 00:46:17,130
laying items it dies pretty early

00:46:08,670 --> 00:46:18,570
because it has no size tree and to be

00:46:17,130 --> 00:46:20,369
honest this is probably out of date like

00:46:18,570 --> 00:46:22,980
I basically adjust this every time that

00:46:20,369 --> 00:46:25,140
I have to debug something in core and

00:46:22,980 --> 00:46:29,010
that kind of luckily core doesn't change

00:46:25,140 --> 00:46:30,810
very much anymore but it may be missing

00:46:29,010 --> 00:46:36,330
a few things or sometimes you have to

00:46:30,810 --> 00:46:38,340
tweak it because something changed okay

00:46:36,330 --> 00:46:39,930
all right I'm gonna probably leave at

00:46:38,340 --> 00:46:42,210
this point because I have another thing

00:46:39,930 --> 00:46:44,090
and it looks like building your VM here

00:46:42,210 --> 00:46:47,460
so that's gonna be a little long but

00:46:44,090 --> 00:46:50,070
I'll push this and we'll see what

00:46:47,460 --> 00:46:54,270
happens so if it does die we can chat

00:46:50,070 --> 00:46:56,970
over zu it about how to debug it sure

00:46:54,270 --> 00:46:59,910
yeah all right cool talk to you later

00:46:56,970 --> 00:47:04,700
all right thanks a lot for your time

00:46:59,910 --> 00:47:04,700

YouTube URL: https://www.youtube.com/watch?v=2QCuNtISoYc


