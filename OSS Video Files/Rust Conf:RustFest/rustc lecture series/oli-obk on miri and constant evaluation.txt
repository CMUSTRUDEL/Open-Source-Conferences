Title: oli-obk on miri and constant evaluation
Publication date: 2019-03-06
Playlist: rustc lecture series
Description: 
	miri is an interpreter for MIR, Rust's internal representation. miri is the foundation for Rust's compile-time evaluation capabilities. Its design enables it to simulate the workings of the machine at a low-level, meaning that it can interpret not only "safe Rust" but also a lot of unsafe Rust code, including complex and highly optimized libraries like the stdlib hashmap. In this talk, compiler team member oli-obk will dig into how miri works, giving us some insight into its architecture, the way that it represents and reasons about memory, and what kinds of capabilities it offers for Rust itself.
Captions: 
	00:00:00,800 --> 00:00:12,059
okay okay well then let's start oh

00:00:06,180 --> 00:00:15,839
you're already recording cool yes right

00:00:12,059 --> 00:00:20,640
so I am gonna dive into the constant

00:00:15,839 --> 00:00:24,000
evaluation stuff in a bit but first I'm

00:00:20,640 --> 00:00:26,970
gonna give you a small intro into some

00:00:24,000 --> 00:00:29,519
things that are necessary first to

00:00:26,970 --> 00:00:32,130
understand first so we we have to mi are

00:00:29,519 --> 00:00:34,320
in the compiler and the console valuator

00:00:32,130 --> 00:00:37,200
is based on the MIR it's essentially a

00:00:34,320 --> 00:00:38,850
virtual machine that can run mir so to

00:00:37,200 --> 00:00:41,070
understand what all the constable stuff

00:00:38,850 --> 00:00:44,940
is doing will first go a little bit

00:00:41,070 --> 00:00:49,680
until the mir itself you can see the

00:00:44,940 --> 00:00:53,699
first well no scrolling for me i guess

00:00:49,680 --> 00:01:00,949
it's more sensitive huh yes I just crow

00:00:53,699 --> 00:01:03,989
very slowly you can see the graph here

00:01:00,949 --> 00:01:06,600
which makes up the three components that

00:01:03,989 --> 00:01:08,549
are relevant for constable from the NIR

00:01:06,600 --> 00:01:12,119
so if we started with the code for

00:01:08,549 --> 00:01:16,350
example here with variable X and the

00:01:12,119 --> 00:01:20,990
value is 42 divided by 2 plus 1 then we

00:01:16,350 --> 00:01:20,990
mutate X and then we return X and

00:01:21,200 --> 00:01:25,200
theoretically this could be turned into

00:01:23,790 --> 00:01:26,460
the MIR you see on the left it's not

00:01:25,200 --> 00:01:28,229
going to be turned into this but it is

00:01:26,460 --> 00:01:28,740
very simplified version that is still

00:01:28,229 --> 00:01:31,860
valid

00:01:28,740 --> 00:01:34,920
Mir kind of so what happens and then you

00:01:31,860 --> 00:01:38,189
kind of get a graph that is made out of

00:01:34,920 --> 00:01:41,189
single blocks and each block either has

00:01:38,189 --> 00:01:44,009
a go to or some other command like a and

00:01:41,189 --> 00:01:46,229
if that goes to multiple blocks to

00:01:44,009 --> 00:01:50,430
decide where to go next so if we start

00:01:46,229 --> 00:01:53,850
out with basic block 0 and we have a

00:01:50,430 --> 00:01:55,820
temporary I will - it computes the 42

00:01:53,850 --> 00:01:58,530
divided by 2 which we have over here and

00:01:55,820 --> 00:02:01,140
this is stored on temporary rebel

00:01:58,530 --> 00:02:03,210
variable and this next step we are

00:02:01,140 --> 00:02:06,240
assigning to another variable the value

00:02:03,210 --> 00:02:09,360
of the previous computation plus 1 so we

00:02:06,240 --> 00:02:11,550
have to slow computation here to

00:02:09,360 --> 00:02:13,890
understand really underscore one and

00:02:11,550 --> 00:02:16,970
twos are coming from

00:02:13,890 --> 00:02:20,280
local table in the mir which maps

00:02:16,970 --> 00:02:23,160
variables you declare for temporary

00:02:20,280 --> 00:02:26,370
variables into one big namespace just

00:02:23,160 --> 00:02:28,520
just numbers and each of those types

00:02:26,370 --> 00:02:31,020
each of the three bills also has a type

00:02:28,520 --> 00:02:32,850
the return place is kind of a very

00:02:31,020 --> 00:02:34,560
special variable

00:02:32,850 --> 00:02:37,560
it doesn't actually exist as a variable

00:02:34,560 --> 00:02:40,320
it's just a hook so the MIR can no knows

00:02:37,560 --> 00:02:43,020
where to write the return value because

00:02:40,320 --> 00:02:45,330
it's not actually in your function you

00:02:43,020 --> 00:02:48,390
you return the value to outside of the

00:02:45,330 --> 00:02:50,280
function so it's very special thingy and

00:02:48,390 --> 00:02:53,430
this is actually what we do in the last

00:02:50,280 --> 00:02:55,500
step we assign to the return value and

00:02:53,430 --> 00:02:55,980
then we execute an mi our return

00:02:55,500 --> 00:02:57,840
statement

00:02:55,980 --> 00:03:01,590
I'll come to those things later in more

00:02:57,840 --> 00:03:03,240
detail but right now the important

00:03:01,590 --> 00:03:05,100
difference is you're not actually

00:03:03,240 --> 00:03:06,450
returning a value with a return

00:03:05,100 --> 00:03:08,700
statement what you're doing here signing

00:03:06,450 --> 00:03:11,940
the value and then you're terminating

00:03:08,700 --> 00:03:16,770
the evaluation of this function with a

00:03:11,940 --> 00:03:20,070
return statement so this lets just get a

00:03:16,770 --> 00:03:23,610
small overview about how the MIRR itself

00:03:20,070 --> 00:03:24,930
kind of looks it's way more detail there

00:03:23,610 --> 00:03:26,340
there's many more intermediate steps in

00:03:24,930 --> 00:03:30,890
there but those are for pretty

00:03:26,340 --> 00:03:35,400
irrelevant for constant valuation right

00:03:30,890 --> 00:03:37,709
another part is how constants actually

00:03:35,400 --> 00:03:42,270
look inside the compiler so if you have

00:03:37,709 --> 00:03:45,270
a constant and you end up with your

00:03:42,270 --> 00:03:50,810
final constants value or like hey let's

00:03:45,270 --> 00:03:50,810
make an example if I can click

00:03:53,440 --> 00:03:58,409
I think

00:03:55,980 --> 00:04:01,110
change to edit mode in our candy III

00:03:58,409 --> 00:04:19,829
just oh I just edited and then you

00:04:01,110 --> 00:04:21,900
should seed like so okay so if a

00:04:19,829 --> 00:04:24,660
constant variable foo and has to have

00:04:21,900 --> 00:04:32,100
you 32 and you do like I know let's do

00:04:24,660 --> 00:04:34,530
the thing we did earlier and you compute

00:04:32,100 --> 00:04:38,039
this value at some point you're gonna

00:04:34,530 --> 00:04:40,699
have to store the final constant that is

00:04:38,039 --> 00:04:42,660
the value of the constant foo somewhere

00:04:40,699 --> 00:04:45,090
you're not going to be carrying around

00:04:42,660 --> 00:04:49,530
the 42 divided by two plus one forever

00:04:45,090 --> 00:04:52,289
and what we do is we have a virtual

00:04:49,530 --> 00:04:55,370
memory representation of any kind of

00:04:52,289 --> 00:04:58,410
constant that you could ever have and

00:04:55,370 --> 00:05:01,050
this isn't just a random list of bytes

00:04:58,410 --> 00:05:03,780
this is a little bit more it has a few

00:05:01,050 --> 00:05:06,060
additional features so one thing is

00:05:03,780 --> 00:05:08,940
obviously you have a list of bytes so if

00:05:06,060 --> 00:05:11,340
you look below this could be the memory

00:05:08,940 --> 00:05:14,880
of a little bit more complex constant

00:05:11,340 --> 00:05:16,919
could just contain a lot of fights and

00:05:14,880 --> 00:05:19,979
these bytes would have here for example

00:05:16,919 --> 00:05:21,930
zeros or f3 or have some random value

00:05:19,979 --> 00:05:24,210
you can store anything in this kind of

00:05:21,930 --> 00:05:28,380
memory this is literally just a Becky

00:05:24,210 --> 00:05:32,340
wait and additionally constant

00:05:28,380 --> 00:05:35,310
evaluation cares very much about whether

00:05:32,340 --> 00:05:37,050
a byte has actually ever been written so

00:05:35,310 --> 00:05:39,690
if there's padding inside of a struct

00:05:37,050 --> 00:05:42,960
those bytes have never been written so

00:05:39,690 --> 00:05:44,610
what we do we store a second list you

00:05:42,960 --> 00:05:48,060
see the Deaf and the undef here and

00:05:44,610 --> 00:05:50,340
assess this byte is defined so somebody

00:05:48,060 --> 00:05:52,260
actually wrote this bite into this

00:05:50,340 --> 00:05:54,900
virtual memory location but for example

00:05:52,260 --> 00:05:56,520
these two bytes could be some padding

00:05:54,900 --> 00:05:58,020
and they've never been written so we

00:05:56,520 --> 00:06:00,300
have another information about this deep

00:05:58,020 --> 00:06:04,770
dosa undefined and the rest of the bytes

00:06:00,300 --> 00:06:08,910
are defined again so even though we have

00:06:04,770 --> 00:06:10,890
just a list of bytes here technically

00:06:08,910 --> 00:06:13,680
the constant also knows whether these

00:06:10,890 --> 00:06:15,270
bytes have ever been written to and this

00:06:13,680 --> 00:06:16,770
is transitive so if you copy from

00:06:15,270 --> 00:06:19,290
unconstitu another even though you're

00:06:16,770 --> 00:06:21,390
writing undefined by it somewhere it'll

00:06:19,290 --> 00:06:22,400
still know those were undefined when you

00:06:21,390 --> 00:06:24,600
started out with

00:06:22,400 --> 00:06:26,880
so the second layer is also copied

00:06:24,600 --> 00:06:28,950
whenever you are using it and then we

00:06:26,880 --> 00:06:33,600
have a third layer and a third layer

00:06:28,950 --> 00:06:35,510
that's for pointers so imagine we on a

00:06:33,600 --> 00:06:40,830
32-bit system and these four bytes

00:06:35,510 --> 00:06:45,270
specify a pointer to some other maybe to

00:06:40,830 --> 00:06:49,830
a static or something and now just

00:06:45,270 --> 00:06:52,020
having a number here could be could be

00:06:49,830 --> 00:06:55,170
used to define pointers just like in if

00:06:52,020 --> 00:06:57,600
you have a full computer of you you know

00:06:55,170 --> 00:06:59,100
every pointer is essentially an address

00:06:57,600 --> 00:07:00,690
it's a little bit more than that and

00:06:59,100 --> 00:07:03,000
rafi young will tell you a lot about

00:07:00,690 --> 00:07:04,740
that but technically inside a computer

00:07:03,000 --> 00:07:07,830
you just have a list of bytes in your

00:07:04,740 --> 00:07:10,590
memory and those bytes specify the

00:07:07,830 --> 00:07:14,430
address of something and we interpret

00:07:10,590 --> 00:07:17,600
those by its as a pointer in constant

00:07:14,430 --> 00:07:21,870
evaluation that's slightly problematic

00:07:17,600 --> 00:07:26,790
imagine if you could just create a raw

00:07:21,870 --> 00:07:30,690
pointer I'll make an example again so if

00:07:26,790 --> 00:07:33,210
you had I just clarify one thing this 42

00:07:30,690 --> 00:07:35,460
yes that you've listed there yes

00:07:33,210 --> 00:07:39,390
absolutely nothing to do with the 42 in

00:07:35,460 --> 00:07:41,190
your Const foe example above right

00:07:39,390 --> 00:07:43,080
in other words oh that has nothing to do

00:07:41,190 --> 00:07:44,730
that's some kind of allocation idea or

00:07:43,080 --> 00:07:46,190
something so so this is constant word I

00:07:44,730 --> 00:07:47,370
was going to come to that in a second

00:07:46,190 --> 00:07:48,690
okay

00:07:47,370 --> 00:07:50,190
this constant we're looking at is not an

00:07:48,690 --> 00:07:55,830
integer it's some kind of struct with a

00:07:50,190 --> 00:08:00,110
pointer or something yes so if you had

00:07:55,830 --> 00:08:04,560
for example well a Const

00:08:00,110 --> 00:08:12,840
bar which is an address of a u32 and we

00:08:04,560 --> 00:08:17,040
just do like one so if we're taking the

00:08:12,840 --> 00:08:23,790
address of this we could

00:08:17,040 --> 00:08:25,620
be using a normal fight based address

00:08:23,790 --> 00:08:27,510
you could just say okay so we're storing

00:08:25,620 --> 00:08:29,460
just underscore one somewhere and then

00:08:27,510 --> 00:08:31,890
we're just using bunch of bytes here and

00:08:29,460 --> 00:08:33,030
I guess the compiler will know where it

00:08:31,890 --> 00:08:34,860
is

00:08:33,030 --> 00:08:40,370
the problem with that is if you allow

00:08:34,860 --> 00:08:45,030
that you will also allow something like

00:08:40,370 --> 00:08:53,250
creating a user 32 by transmuting I

00:08:45,030 --> 00:08:55,770
don't know some number and well and

00:08:53,250 --> 00:09:00,870
unsafe around it but if you're if we're

00:08:55,770 --> 00:09:03,210
doing that and in the end try to for

00:09:00,870 --> 00:09:04,920
example use this number to index to

00:09:03,210 --> 00:09:07,470
create an array with the lengths of this

00:09:04,920 --> 00:09:10,770
number the compiler should it look at

00:09:07,470 --> 00:09:14,280
the address 999 and find an integer

00:09:10,770 --> 00:09:16,440
there so this is a question that can't

00:09:14,280 --> 00:09:19,860
really be answered it never makes sense

00:09:16,440 --> 00:09:22,290
to use in a number or as an as a pointer

00:09:19,860 --> 00:09:25,530
during constant evaluation and then

00:09:22,290 --> 00:09:27,810
actually try to read from it so in order

00:09:25,530 --> 00:09:32,100
to uniquely identify something like this

00:09:27,810 --> 00:09:34,080
the memory that goes into this one we

00:09:32,100 --> 00:09:37,200
are using the third layer which is

00:09:34,080 --> 00:09:39,300
essentially just an a counter inside a

00:09:37,200 --> 00:09:43,380
compiler that increases every single

00:09:39,300 --> 00:09:44,940
time we create a new allocation and so

00:09:43,380 --> 00:09:47,040
every time we create one of those big

00:09:44,940 --> 00:09:50,940
blocks we also get for the number this

00:09:47,040 --> 00:09:53,280
so called a log ID and this ID might be

00:09:50,940 --> 00:09:55,080
anything it can be any number you can

00:09:53,280 --> 00:09:56,760
never see this number it's abstracted

00:09:55,080 --> 00:09:59,430
away so the user never knows about this

00:09:56,760 --> 00:10:03,560
actual number in fact between

00:09:59,430 --> 00:10:05,520
compilations these numbers actually vary

00:10:03,560 --> 00:10:06,930
depending on your incremental

00:10:05,520 --> 00:10:08,670
compilation state and other things so

00:10:06,930 --> 00:10:11,850
these numbers are completely irrelevant

00:10:08,670 --> 00:10:14,640
they are just for identifying one of

00:10:11,850 --> 00:10:19,170
those big allocations so now if we have

00:10:14,640 --> 00:10:23,160
this ampersand one we get this third

00:10:19,170 --> 00:10:24,900
layer set to the value or to the ID of

00:10:23,160 --> 00:10:28,770
the allocation where we storing the one

00:10:24,900 --> 00:10:31,470
inside and now if we're trying

00:10:28,770 --> 00:10:33,180
dereference this bar what we're going to

00:10:31,470 --> 00:10:34,410
do is we're not even gonna really look

00:10:33,180 --> 00:10:36,480
at those by its what we're going to do

00:10:34,410 --> 00:10:39,959
is we're going to look at the number in

00:10:36,480 --> 00:10:41,640
the third layer fetch the allocation so

00:10:39,959 --> 00:10:43,800
now we get one of those big allocations

00:10:41,640 --> 00:10:45,360
and then we're going to look at those

00:10:43,800 --> 00:10:47,910
bytes because those by it's already

00:10:45,360 --> 00:10:49,470
offset inside that allocation so then if

00:10:47,910 --> 00:10:54,149
it's less five then we're going to go

00:10:49,470 --> 00:10:56,930
one two zero one two three four five so

00:10:54,149 --> 00:11:00,570
I would point somewhere here for example

00:10:56,930 --> 00:11:02,910
and with these two informations with the

00:11:00,570 --> 00:11:05,360
offset and the allocation ID we can

00:11:02,910 --> 00:11:07,860
point it to any other allocation and

00:11:05,360 --> 00:11:14,610
create basically any data structure we

00:11:07,860 --> 00:11:17,760
might want to have in memory IDs

00:11:14,610 --> 00:11:19,980
also saw a surfer secondary purpose they

00:11:17,760 --> 00:11:23,040
allow us to create cyclic data

00:11:19,980 --> 00:11:25,380
structures inside constants so for

00:11:23,040 --> 00:11:28,320
example think if you had a graph data

00:11:25,380 --> 00:11:31,680
structure in memory certain memory he

00:11:28,320 --> 00:11:34,740
places would point directly or

00:11:31,680 --> 00:11:35,430
indirectly back to themselves and we

00:11:34,740 --> 00:11:37,230
could also choose a different

00:11:35,430 --> 00:11:39,750
representation where we wouldn't have

00:11:37,230 --> 00:11:43,050
those LM ID is here but we just like

00:11:39,750 --> 00:11:45,089
place a box of a location in here so

00:11:43,050 --> 00:11:46,740
we'd have like this big tree of data

00:11:45,089 --> 00:11:49,050
structures but at some point you'd get

00:11:46,740 --> 00:11:51,270
into cyclic data structures and then you

00:11:49,050 --> 00:11:53,310
couldn't point have an allocation that

00:11:51,270 --> 00:11:55,200
points back to itself we could have

00:11:53,310 --> 00:11:57,959
course then start moving on to like arcs

00:11:55,200 --> 00:12:00,420
and ref cells and whatnot but this is

00:11:57,959 --> 00:12:01,800
not going to get us into happy place

00:12:00,420 --> 00:12:05,399
we actually tried this in some

00:12:01,800 --> 00:12:06,990
situations and it never worked so we

00:12:05,399 --> 00:12:11,690
have the separation between allocations

00:12:06,990 --> 00:12:13,250
and a log IDs don't worry I'm going to

00:12:11,690 --> 00:12:15,680
actual constant evaluation stuff in a

00:12:13,250 --> 00:12:19,220
second once we're done with this

00:12:15,680 --> 00:12:21,710
so allocations are the actual memory and

00:12:19,220 --> 00:12:23,300
the a log IDs are just an ID referring

00:12:21,710 --> 00:12:24,950
to this memory and you can freely

00:12:23,300 --> 00:12:27,290
convert between stuff between those two

00:12:24,950 --> 00:12:32,420
so if you want to get from an alligator

00:12:27,290 --> 00:12:34,670
in a location this is a big word full

00:12:32,420 --> 00:12:36,110
you can access the alarm app and then

00:12:34,670 --> 00:12:37,010
fetch the memory from that and so on but

00:12:36,110 --> 00:12:40,700
you actually never have to do this

00:12:37,010 --> 00:12:43,610
yourself because you never actually

00:12:40,700 --> 00:12:45,290
touch a log IDs while developing

00:12:43,610 --> 00:12:48,560
constant evaluation stuff what you

00:12:45,290 --> 00:12:51,430
instead do ya have some abstract objects

00:12:48,560 --> 00:12:54,710
inside the concert where your evaluator

00:12:51,430 --> 00:12:56,510
which you can ask the console by the way

00:12:54,710 --> 00:12:59,720
- the result for you so you're not even

00:12:56,510 --> 00:13:01,850
looking at method allocations yourself

00:12:59,720 --> 00:13:03,800
and you're never looking at our IDs

00:13:01,850 --> 00:13:05,300
yourself the constant evaluator is doing

00:13:03,800 --> 00:13:07,070
this in a background in the foreground

00:13:05,300 --> 00:13:09,290
you're just asking the constant

00:13:07,070 --> 00:13:12,410
evaluator for example to read something

00:13:09,290 --> 00:13:14,240
from a virtual pointer or to write

00:13:12,410 --> 00:13:16,430
something to a virtual pointer you're

00:13:14,240 --> 00:13:18,380
never actually going to work with those

00:13:16,430 --> 00:13:22,660
types yourself except if you're diving

00:13:18,380 --> 00:13:22,660
really deep into the constant evaluation

00:13:23,620 --> 00:13:28,910
but um

00:13:25,040 --> 00:13:40,010
oh no I scrolled again that was bad I'm

00:13:28,910 --> 00:13:42,680
sorry I made most of these things in the

00:13:40,010 --> 00:13:43,880
Indus presentation I made hyperlinks so

00:13:42,680 --> 00:13:46,250
if you're interested in more details you

00:13:43,880 --> 00:13:48,980
can actually click on the separate part

00:13:46,250 --> 00:13:51,350
here for example the memory type is

00:13:48,980 --> 00:13:53,630
where all the memory accesses or all the

00:13:51,350 --> 00:13:55,040
allocation accessing happens but it's

00:13:53,630 --> 00:13:57,920
abstracting away a lot of things so you

00:13:55,040 --> 00:14:02,330
can ask it to actually like read a user

00:13:57,920 --> 00:14:04,280
t2 from memory or read a see like string

00:14:02,330 --> 00:14:06,589
from memory and there's all kinds of

00:14:04,280 --> 00:14:08,410
features like this that you should be

00:14:06,589 --> 00:14:11,060
using the abstraction and not directly

00:14:08,410 --> 00:14:13,130
access the memory of course if you're

00:14:11,060 --> 00:14:14,870
building an abstraction you can access

00:14:13,130 --> 00:14:17,180
it directly through memory - and then

00:14:14,870 --> 00:14:23,640
write your abstraction that does some

00:14:17,180 --> 00:14:26,010
special kind of access okeydoke that

00:14:23,640 --> 00:14:27,870
the boilerplate one thing I also want to

00:14:26,010 --> 00:14:29,850
say if there are any questions just

00:14:27,870 --> 00:14:31,200
interrupt me in the middle and we'll

00:14:29,850 --> 00:14:34,020
resolve them right in place

00:14:31,200 --> 00:14:36,630
I think that's easier than having

00:14:34,020 --> 00:14:42,900
questions in the end so um yeah feel

00:14:36,630 --> 00:14:46,860
free to stop me at any point okay

00:14:42,900 --> 00:14:50,220
so constant evaluation itself starts

00:14:46,860 --> 00:14:53,040
pretty simple first of all one thing you

00:14:50,220 --> 00:14:54,930
have to know a constant is nothing else

00:14:53,040 --> 00:14:58,950
than a function that has zero arguments

00:14:54,930 --> 00:15:00,570
and a single return type so to evaluate

00:14:58,950 --> 00:15:02,730
a constant what we're doing we are

00:15:00,570 --> 00:15:04,620
calling this kind of zero argument

00:15:02,730 --> 00:15:06,320
function by not passing any arguments

00:15:04,620 --> 00:15:10,320
because doesn't have any and then

00:15:06,320 --> 00:15:13,920
starting evaluation how this works is we

00:15:10,320 --> 00:15:18,420
are creating a evaluation context this

00:15:13,920 --> 00:15:20,340
is an object that is the entry point for

00:15:18,420 --> 00:15:24,030
any kind of constant evaluation what it

00:15:20,340 --> 00:15:26,910
does it stores internally a stack of

00:15:24,030 --> 00:15:30,150
frames and every frame itself has again

00:15:26,910 --> 00:15:32,190
a stack of local variables and those

00:15:30,150 --> 00:15:35,700
local variables itself they point again

00:15:32,190 --> 00:15:38,730
back to allocations so if you're looking

00:15:35,700 --> 00:15:41,940
at this on the bottom the evaluation

00:15:38,730 --> 00:15:43,560
context is full of those frames when you

00:15:41,940 --> 00:15:47,610
start off you have a single frame that's

00:15:43,560 --> 00:15:50,220
the frame for your constant it contains

00:15:47,610 --> 00:15:53,790
the MIR off the constant contains the

00:15:50,220 --> 00:15:56,370
locals inside that constant it contains

00:15:53,790 --> 00:15:59,310
a return place which is the information

00:15:56,370 --> 00:16:02,760
where to fight the final result of the

00:15:59,310 --> 00:16:06,120
constant once it's computed and you have

00:16:02,760 --> 00:16:07,410
two IDs which is the basic block ID that

00:16:06,120 --> 00:16:10,470
we're currently evaluating and a

00:16:07,410 --> 00:16:13,140
statement inside that basic block in the

00:16:10,470 --> 00:16:14,490
mir that you saw earlier I had multiple

00:16:13,140 --> 00:16:17,040
basic blocks and some basic blocks had

00:16:14,490 --> 00:16:22,980
multiple statements so these two fields

00:16:17,040 --> 00:16:25,020
they tell us we're inside the mir we are

00:16:22,980 --> 00:16:27,000
right now during our evaluation so you

00:16:25,020 --> 00:16:29,370
have kind of gdb debugging experience

00:16:27,000 --> 00:16:31,830
here where you know exactly where you

00:16:29,370 --> 00:16:33,840
are and you can step through your code

00:16:31,830 --> 00:16:36,860
except you're stepping through the

00:16:33,840 --> 00:16:36,860
constant evaluation

00:16:37,680 --> 00:16:42,820
so once we have created this first frame

00:16:40,420 --> 00:16:45,910
what we do is we actually trigger the

00:16:42,820 --> 00:16:48,220
stepping by having a loop that calls the

00:16:45,910 --> 00:16:53,529
step function on the evaluation context

00:16:48,220 --> 00:16:56,680
and a step function just that's all the

00:16:53,529 --> 00:17:00,670
logic internally we'll go to the details

00:16:56,680 --> 00:17:02,770
of step function later once the step

00:17:00,670 --> 00:17:04,060
function returns that it doesn't have

00:17:02,770 --> 00:17:06,040
anything more to evaluate because

00:17:04,060 --> 00:17:08,560
there's no more frames left to evaluate

00:17:06,040 --> 00:17:12,189
that means the final frame has returned

00:17:08,560 --> 00:17:13,959
so no matter how many functions are

00:17:12,189 --> 00:17:15,670
called in between at some point you're

00:17:13,959 --> 00:17:17,770
going to end up back at your original

00:17:15,670 --> 00:17:19,839
frame the one that you created was the

00:17:17,770 --> 00:17:22,000
mir after constant and then at some

00:17:19,839 --> 00:17:24,490
point that frame is going to call return

00:17:22,000 --> 00:17:26,890
and then the evaluation is over just no

00:17:24,490 --> 00:17:29,050
more frames to evaluate so now we know

00:17:26,890 --> 00:17:32,590
the value of the constant the final

00:17:29,050 --> 00:17:35,410
value is stored inside the return place

00:17:32,590 --> 00:17:37,360
we gave we gave the evaluator and what

00:17:35,410 --> 00:17:40,360
we do now is we run so-called validity

00:17:37,360 --> 00:17:42,250
checks on the result you might have seen

00:17:40,360 --> 00:17:45,100
those before if you've tried to do some

00:17:42,250 --> 00:17:46,900
unsafe things with constable for example

00:17:45,100 --> 00:17:49,030
if you're using a union inside a

00:17:46,900 --> 00:17:51,760
constant evaluation you could end up

00:17:49,030 --> 00:17:55,270
having for example undefined by it's for

00:17:51,760 --> 00:17:58,630
a u32 or you could have a reference that

00:17:55,270 --> 00:18:04,630
is actually an 0 value which is

00:17:58,630 --> 00:18:06,700
obviously not okay and so this final

00:18:04,630 --> 00:18:09,970
validity check it goes through the tile

00:18:06,700 --> 00:18:11,890
layout and make sure that everything

00:18:09,970 --> 00:18:14,140
different in at I lay out is actually

00:18:11,890 --> 00:18:16,540
adhere to so you're if you have an enum

00:18:14,140 --> 00:18:19,170
which is three variants for example and

00:18:16,540 --> 00:18:22,240
they have discriminant 0 1 & 2 and

00:18:19,170 --> 00:18:23,560
there's a value for then that's not

00:18:22,240 --> 00:18:25,720
legal and the tile layout actually

00:18:23,560 --> 00:18:30,960
presents this it tells you what kind of

00:18:25,720 --> 00:18:32,800
values can be inside a certain type and

00:18:30,960 --> 00:18:35,110
additionally due to that we have some

00:18:32,800 --> 00:18:37,780
additional checks like we enforce that

00:18:35,110 --> 00:18:39,670
there are no dangling pointers at all so

00:18:37,780 --> 00:18:42,460
even if you put a dangling pointer

00:18:39,670 --> 00:18:43,840
inside padding of a struct it will check

00:18:42,460 --> 00:18:46,770
the dere no dangling pointers do you

00:18:43,840 --> 00:18:50,140
kind of think pointers ever in constable

00:18:46,770 --> 00:18:51,460
and also characters

00:18:50,140 --> 00:18:54,640
checking that they're actually related

00:18:51,460 --> 00:18:57,309
unicode index and not some arbitrary

00:18:54,640 --> 00:18:59,230
other value here's a bunch of more

00:18:57,309 --> 00:19:01,059
checks if you're interested in this

00:18:59,230 --> 00:19:03,910
there's links on the bottom of this

00:19:01,059 --> 00:19:07,230
presentation to all the different parts

00:19:03,910 --> 00:19:09,850
of constant evaluation also to validity

00:19:07,230 --> 00:19:11,710
once we are sure that our value is

00:19:09,850 --> 00:19:14,860
saying what we're doing is we're moving

00:19:11,710 --> 00:19:17,260
the memory of this allocation so the

00:19:14,860 --> 00:19:22,360
allocation objects we're moving them to

00:19:17,260 --> 00:19:25,660
the tie C ties C txt so to the global in

00:19:22,360 --> 00:19:27,400
Turners so once constant evaluation is

00:19:25,660 --> 00:19:31,570
finished we still have access to this

00:19:27,400 --> 00:19:34,480
memory and can use it to compute the

00:19:31,570 --> 00:19:37,059
value of any other constant so a

00:19:34,480 --> 00:19:39,250
constant is only ever evaluated once and

00:19:37,059 --> 00:19:53,290
it's returned its values are cached

00:19:39,250 --> 00:19:56,140
inside their global context okay so

00:19:53,290 --> 00:19:59,770
earlier I skimmed over a few things sort

00:19:56,140 --> 00:20:01,330
of frame it contains locals those are

00:19:59,770 --> 00:20:05,100
not the same locals that you have any my

00:20:01,330 --> 00:20:07,570
are so for each value inside the locals

00:20:05,100 --> 00:20:09,429
each value inside ami are you have a

00:20:07,570 --> 00:20:11,049
value in the locals field but they are

00:20:09,429 --> 00:20:14,350
completely different types what you have

00:20:11,049 --> 00:20:17,200
here is for one you have to lay out of

00:20:14,350 --> 00:20:19,900
the local and you have a pointer to an

00:20:17,200 --> 00:20:25,480
allocation that backs the memory of this

00:20:19,900 --> 00:20:26,770
local and so if you're writing to one of

00:20:25,480 --> 00:20:28,929
those variables what you're actually

00:20:26,770 --> 00:20:31,960
writing to is to the backing allocation

00:20:28,929 --> 00:20:34,059
of a local the same thing goes for the

00:20:31,960 --> 00:20:38,500
return place it also refers to some

00:20:34,059 --> 00:20:41,890
allocation and that internally is where

00:20:38,500 --> 00:20:44,380
you write the final result of your

00:20:41,890 --> 00:20:46,390
computation to and the allocation has

00:20:44,380 --> 00:20:48,330
introduced earlier has some bite layer

00:20:46,390 --> 00:20:51,100
has a relocations layer which is the

00:20:48,330 --> 00:20:52,929
thing used for pointers and we have an

00:20:51,100 --> 00:21:02,149
undef mask which says for every bite

00:20:52,929 --> 00:21:11,389
whether it's defined 25 so

00:21:02,149 --> 00:21:17,319
the rubella I scroll too much the step

00:21:11,389 --> 00:21:23,019
function of the evaluation context is a

00:21:17,319 --> 00:21:27,639
follows a few very strict rules one is

00:21:23,019 --> 00:21:32,389
there needs to be one frame on the

00:21:27,639 --> 00:21:34,219
understand so if we keep calling step

00:21:32,389 --> 00:21:35,959
after everything is finished you're

00:21:34,219 --> 00:21:42,889
probably going to get a panic

00:21:35,959 --> 00:21:44,269
that's intended this way because we used

00:21:42,889 --> 00:21:46,399
to have problems where the constant

00:21:44,269 --> 00:21:48,229
evaluator kind of got finished or

00:21:46,399 --> 00:21:50,599
accidentally called step after it got

00:21:48,229 --> 00:21:53,059
finished and that kind of messed up all

00:21:50,599 --> 00:21:54,319
our state so what you have before

00:21:53,059 --> 00:21:57,699
calling it you have to check that

00:21:54,319 --> 00:21:57,699
there's actually still something to do

00:21:58,449 --> 00:22:03,769
then we have the basic block ID in the

00:22:01,189 --> 00:22:05,659
frame which identifies the current basic

00:22:03,769 --> 00:22:08,989
block that we're evaluating fetching

00:22:05,659 --> 00:22:11,599
that from the MIR and then we're

00:22:08,989 --> 00:22:13,939
checking for that basic block if this

00:22:11,599 --> 00:22:16,519
statement IDE points to an actual

00:22:13,939 --> 00:22:18,679
statement inside s Mir so we always have

00:22:16,519 --> 00:22:19,819
this list of statements and below the

00:22:18,679 --> 00:22:22,609
list of statements we have one

00:22:19,819 --> 00:22:24,499
terminator and we are just reusing the

00:22:22,609 --> 00:22:26,749
statement ID to either point to

00:22:24,499 --> 00:22:28,879
statements or if it points to one beyond

00:22:26,749 --> 00:22:31,279
two statements we say okay we want to

00:22:28,879 --> 00:22:33,529
evaluate a terminator so the Terminator

00:22:31,279 --> 00:22:35,089
is for example the go-to to jump to

00:22:33,529 --> 00:22:39,019
another basic block or it could be an if

00:22:35,089 --> 00:22:41,569
or it could be a return yeah how do you

00:22:39,019 --> 00:22:44,269
work internally exactly I'll get to

00:22:41,569 --> 00:22:46,399
later so these steps they're basically

00:22:44,269 --> 00:22:49,219
just run in cycles until we run out of

00:22:46,399 --> 00:22:54,829
frames and then we assume that our

00:22:49,219 --> 00:22:57,319
evaluation is finished we'll start with

00:22:54,829 --> 00:23:00,259
statements first so if we have a

00:22:57,319 --> 00:23:02,869
statement to interpret all that we are

00:23:00,259 --> 00:23:04,669
really interested in are these two

00:23:02,869 --> 00:23:06,709
statements assignments and set

00:23:04,669 --> 00:23:08,989
discriminant set discriminant is

00:23:06,709 --> 00:23:13,909
essentially an assignment to the attack

00:23:08,989 --> 00:23:15,389
field of an enum and is very it shows a

00:23:13,909 --> 00:23:16,799
very rarely

00:23:15,389 --> 00:23:20,579
it's not very interesting for us right

00:23:16,799 --> 00:23:22,679
now all the other statements they are

00:23:20,579 --> 00:23:26,399
pretty much irrelevant for all of

00:23:22,679 --> 00:23:28,200
constant evaluation these two they are

00:23:26,399 --> 00:23:31,589
just creating and destroying local

00:23:28,200 --> 00:23:33,479
variables they're very they're very

00:23:31,589 --> 00:23:37,019
simple code and that hasn't been touched

00:23:33,479 --> 00:23:39,659
in quite a while but it's not yeah it's

00:23:37,019 --> 00:23:42,599
not a very important evaluation we could

00:23:39,659 --> 00:23:44,399
just allocate all memory and never

00:23:42,599 --> 00:23:46,049
destroy it and everything would work out

00:23:44,399 --> 00:23:47,820
just fine too

00:23:46,049 --> 00:23:49,499
one statement that one might see is to

00:23:47,820 --> 00:23:52,440
retag statement constant evaluation

00:23:49,499 --> 00:23:56,489
ignores it but Miri uses it for doing

00:23:52,440 --> 00:23:59,879
this tack Burroughs checking yeah we

00:23:56,489 --> 00:24:01,529
could we were we could have put this

00:23:59,879 --> 00:24:03,209
into constant evaluation too but then

00:24:01,529 --> 00:24:05,519
all our constant evaluation would get

00:24:03,209 --> 00:24:12,539
very very slow so we are choosing not to

00:24:05,519 --> 00:24:14,339
do that yes so we ultimately adopt let's

00:24:12,539 --> 00:24:17,089
say some variant of stock borrows as the

00:24:14,339 --> 00:24:19,229
definition of undefined behavior yeah

00:24:17,089 --> 00:24:21,389
does that imply the cost evaluation

00:24:19,229 --> 00:24:24,450
would permit undefined behavior because

00:24:21,389 --> 00:24:28,769
we're not checking the retag that we

00:24:24,450 --> 00:24:34,469
might have caught otherwise okay yes and

00:24:28,769 --> 00:24:36,509
we're kind kind of worried but only semi

00:24:34,469 --> 00:24:39,899
worried so you can't do much stupid

00:24:36,509 --> 00:24:42,450
stuff during Constable there's it's it's

00:24:39,899 --> 00:24:44,489
it's rather limited in the fancy stuff

00:24:42,450 --> 00:24:49,229
that it can do Miri itself is more

00:24:44,489 --> 00:24:50,639
powerful and while you still can do a

00:24:49,229 --> 00:24:55,349
few things especially if you start

00:24:50,639 --> 00:24:56,759
transmuting and so on the the final

00:24:55,349 --> 00:25:00,299
result that you need to end up with

00:24:56,759 --> 00:25:02,129
needs to be a same value so all you

00:25:00,299 --> 00:25:04,829
could do is have like undefined behavior

00:25:02,129 --> 00:25:09,029
during constant evaluation but not in

00:25:04,829 --> 00:25:11,729
the final value and it's not nice but we

00:25:09,029 --> 00:25:13,190
like kind of reserved to write to break

00:25:11,729 --> 00:25:16,649
your code if it does undefined behavior

00:25:13,190 --> 00:25:18,629
so we will basically hoping we we can

00:25:16,649 --> 00:25:21,149
get away with extending that to constant

00:25:18,629 --> 00:25:23,669
evaluation - yeah it seems like

00:25:21,149 --> 00:25:25,139
alternative better than the runtime

00:25:23,669 --> 00:25:27,200
implications like we'll be able to

00:25:25,139 --> 00:25:30,740
create a rate for example

00:25:27,200 --> 00:25:33,049
oh yes definitely so these are

00:25:30,740 --> 00:25:36,169
absolutely deterministic undefined

00:25:33,049 --> 00:25:37,639
behaviors so they did this if we change

00:25:36,169 --> 00:25:40,039
something or we add in the additional

00:25:37,639 --> 00:25:41,870
checks even with some point decide we

00:25:40,039 --> 00:25:46,070
want to have stack power us and some

00:25:41,870 --> 00:25:48,470
constant evaluation we can easily add

00:25:46,070 --> 00:25:50,710
this as an extra feature that starts off

00:25:48,470 --> 00:25:52,789
with a warning face and everything so

00:25:50,710 --> 00:25:56,419
we're not going to get accidental

00:25:52,789 --> 00:25:58,880
breakage we're gonna have to add those

00:25:56,419 --> 00:26:00,950
explicitly maybe it's worth adding for

00:25:58,880 --> 00:26:03,740
those listeners who don't know stack

00:26:00,950 --> 00:26:05,480
Barros is a proposal for checking sort

00:26:03,740 --> 00:26:07,059
of what kinds of aliases are illegal and

00:26:05,480 --> 00:26:10,279
unsafe code and rust

00:26:07,059 --> 00:26:13,460
Ralph Young's blog site blog website has

00:26:10,279 --> 00:26:18,529
a lot about it all right carry on thank

00:26:13,460 --> 00:26:20,389
you okay so the really really important

00:26:18,529 --> 00:26:27,080
statement the one that we actually care

00:26:20,389 --> 00:26:32,019
about is the assignment and stuff is

00:26:27,080 --> 00:26:38,630
hanging do I still have internet oh

00:26:32,019 --> 00:27:04,450
maybe you're here okay yeah stuff for us

00:26:38,630 --> 00:27:04,450
for a second okay okay

00:27:10,299 --> 00:27:15,750
so a statement consists of two parts it

00:27:12,970 --> 00:27:18,039
has a destination where we want to write

00:27:15,750 --> 00:27:20,980
something - this is the thing on the

00:27:18,039 --> 00:27:23,289
left side of equals sign and we have a

00:27:20,980 --> 00:27:25,539
value that we want to sign there just a

00:27:23,289 --> 00:27:31,080
thing on the right side of the equal

00:27:25,539 --> 00:27:33,760
sign the left side we have a place which

00:27:31,080 --> 00:27:36,159
can be a bunch of things it could for

00:27:33,760 --> 00:27:38,679
example be a static or a local variable

00:27:36,159 --> 00:27:41,230
or it could be a projection into these

00:27:38,679 --> 00:27:45,029
so it could for example be in an index

00:27:41,230 --> 00:27:46,179
operation into a local variable or a

00:27:45,029 --> 00:27:48,429
dereference

00:27:46,179 --> 00:27:53,649
of a local variable and then access to a

00:27:48,429 --> 00:27:56,679
field of it or so so if you write x dot

00:27:53,649 --> 00:27:58,630
foo equals y then the X dot foo would be

00:27:56,679 --> 00:28:05,440
such a protection you're accessing field

00:27:58,630 --> 00:28:07,090
through after variable X and the data

00:28:05,440 --> 00:28:08,500
structures around T's are changing

00:28:07,090 --> 00:28:10,419
currently but it's not going to change

00:28:08,500 --> 00:28:17,700
much about how a constant evaluation is

00:28:10,419 --> 00:28:24,190
going to work with it yeah what the

00:28:17,700 --> 00:28:26,260
essentially only disease or like the

00:28:24,190 --> 00:28:28,929
full place data structure and mirror

00:28:26,260 --> 00:28:32,980
currently at least includes the ability

00:28:28,929 --> 00:28:35,590
to index into a slice oh yeah I left a

00:28:32,980 --> 00:28:39,750
bunch of things out here okay this is

00:28:35,590 --> 00:28:43,240
not a full this is basically just the

00:28:39,750 --> 00:28:46,809
important ones so they're inside a field

00:28:43,240 --> 00:28:52,059
projection yeah if you click the link oh

00:28:46,809 --> 00:28:53,799
you'll see a bunch of data to a bunch of

00:28:52,059 --> 00:28:55,029
enum Maryann's and those are all the

00:28:53,799 --> 00:29:03,880
protections that you can actually choose

00:28:55,029 --> 00:29:07,809
from yeah Meiri kind of simplifies this

00:29:03,880 --> 00:29:12,220
place by evaluating it to a pointer a

00:29:07,809 --> 00:29:15,070
pointer is just a group of a pair of an

00:29:12,220 --> 00:29:16,510
Alec ID and an offset so similar to what

00:29:15,070 --> 00:29:18,789
we have in allocations where we have the

00:29:16,510 --> 00:29:20,610
officer that inside divides and the

00:29:18,789 --> 00:29:23,019
allocation ID in the third level a

00:29:20,610 --> 00:29:23,500
pointer is a simplification of this data

00:29:23,019 --> 00:29:25,929
structure

00:29:23,500 --> 00:29:29,770
and it's just a tuple of the LOA ID and

00:29:25,929 --> 00:29:32,409
the asset and this is much easier to

00:29:29,770 --> 00:29:35,650
work with so we always convert such a

00:29:32,409 --> 00:29:40,539
place to a pointer and then continue

00:29:35,650 --> 00:29:43,330
working on it to write to it in order to

00:29:40,539 --> 00:29:46,030
know what we want to write to it we need

00:29:43,330 --> 00:29:50,679
to have an R value the R value is the

00:29:46,030 --> 00:29:56,429
thing on the right side of the of the

00:29:50,679 --> 00:29:59,549
assignment and it's not scrolling again

00:29:56,429 --> 00:29:59,549
there we are

00:30:01,870 --> 00:30:05,289
there's a bunch of things that can be on

00:30:03,309 --> 00:30:07,179
the right-hand side of an assignment for

00:30:05,289 --> 00:30:09,730
one thing you could just have a naming

00:30:07,179 --> 00:30:12,840
and a variable or a constant or

00:30:09,730 --> 00:30:15,850
accessing a field of some local variable

00:30:12,840 --> 00:30:17,520
what you also can have is different

00:30:15,850 --> 00:30:20,409
operators so you can have plus

00:30:17,520 --> 00:30:23,980
multiplication and unary negation or

00:30:20,409 --> 00:30:25,990
something you can have aggregates so

00:30:23,980 --> 00:30:29,169
creating a tuple or an array or

00:30:25,990 --> 00:30:33,159
something by including a bunch of

00:30:29,169 --> 00:30:35,289
objects together for example there's

00:30:33,159 --> 00:30:38,799
also one R value we're taking the

00:30:35,289 --> 00:30:41,409
address of a place and storing that in

00:30:38,799 --> 00:30:48,429
the place that's on the left side of the

00:30:41,409 --> 00:30:50,950
equal sign so instead of evaluating

00:30:48,429 --> 00:30:53,919
these two a value and then storing the

00:30:50,950 --> 00:30:57,450
value at the address we got from the

00:30:53,919 --> 00:31:00,460
place what we're doing is we're directly

00:30:57,450 --> 00:31:03,820
evaluating these into the target

00:31:00,460 --> 00:31:06,429
destination for example if we are

00:31:03,820 --> 00:31:08,080
evaluating in aggregate instead of

00:31:06,429 --> 00:31:09,850
computing all the fields of the

00:31:08,080 --> 00:31:12,070
aggregate and then writing them to the

00:31:09,850 --> 00:31:14,200
destination allocation what we're doing

00:31:12,070 --> 00:31:16,690
is we're just immediately writing into

00:31:14,200 --> 00:31:18,130
the destination allocation to save us

00:31:16,690 --> 00:31:21,580
the trouble of having to allocate

00:31:18,130 --> 00:31:24,400
additional memory just temporary memory

00:31:21,580 --> 00:31:29,500
to store the value before writing it

00:31:24,400 --> 00:31:32,200
back to the memory and these

00:31:29,500 --> 00:31:34,149
optimizations are very important for

00:31:32,200 --> 00:31:37,089
constable performance we were trying on

00:31:34,149 --> 00:31:40,599
different setups there but basically

00:31:37,089 --> 00:31:43,019
this is I think pretty optimal already

00:31:40,599 --> 00:31:46,839
that we're writing this directly there

00:31:43,019 --> 00:31:48,429
one saying such a binary operation for

00:31:46,839 --> 00:31:50,939
example those actually create a

00:31:48,429 --> 00:31:53,979
temporary intermediate value but since

00:31:50,939 --> 00:31:56,949
we only can use those for floating-point

00:31:53,979 --> 00:31:58,539
or integers we don't really have to

00:31:56,949 --> 00:32:00,999
worry about those they're pretty small

00:31:58,539 --> 00:32:03,909
they don't require a bigger locations so

00:32:00,999 --> 00:32:06,129
binary operator even though it's a plus

00:32:03,909 --> 00:32:09,999
operator it can be applied for example

00:32:06,129 --> 00:32:12,639
strings and so on these binary operators

00:32:09,999 --> 00:32:15,309
owner operators they are just four basic

00:32:12,639 --> 00:32:17,139
values so they're just four integers

00:32:15,309 --> 00:32:22,599
floats and so on

00:32:17,139 --> 00:32:37,149
anything that doesn't actually need any

00:32:22,599 --> 00:32:40,149
complex computations so so if we start

00:32:37,149 --> 00:32:42,359
out with such an hour value that we had

00:32:40,149 --> 00:32:46,569
for example binary operations or

00:32:42,359 --> 00:32:51,669
aggregates we need a bunch of values to

00:32:46,569 --> 00:32:56,949
operate on so we need something to do a

00:32:51,669 --> 00:32:59,859
binary operation on and these are values

00:32:56,949 --> 00:33:02,469
then have certain so-called arguments or

00:32:59,859 --> 00:33:04,029
I didn't find a better way for name for

00:33:02,469 --> 00:33:06,339
it so for example if you have an a

00:33:04,029 --> 00:33:08,529
binary operation you have two so-called

00:33:06,339 --> 00:33:11,289
operands and an operand can either be a

00:33:08,529 --> 00:33:13,239
place or constant so if you have X plus

00:33:11,289 --> 00:33:16,389
3 that would be an operand where the

00:33:13,239 --> 00:33:18,429
first one points to a place to X and the

00:33:16,389 --> 00:33:22,859
second one it's just a constant in

00:33:18,429 --> 00:33:24,879
itself and in the case of for example

00:33:22,859 --> 00:33:28,959
taking an address or something so the

00:33:24,879 --> 00:33:33,069
ref R value the argument is just a place

00:33:28,959 --> 00:33:38,049
we're taking the the address of a place

00:33:33,069 --> 00:33:41,439
any expression that the user could write

00:33:38,049 --> 00:33:44,679
that is more complex would automatically

00:33:41,439 --> 00:33:48,729
generate temporary variables that aren't

00:33:44,679 --> 00:33:50,139
usually fine and we don't really need to

00:33:48,729 --> 00:33:50,800
worry about those two in constant

00:33:50,139 --> 00:33:52,450
evaluation

00:33:50,800 --> 00:33:58,660
because they're just treated like normal

00:33:52,450 --> 00:34:01,510
variables and we can then reuse the

00:33:58,660 --> 00:34:03,850
r-value operations and so on on those

00:34:01,510 --> 00:34:05,500
temporary variables so everything is

00:34:03,850 --> 00:34:12,159
split up at certain points when it gets

00:34:05,500 --> 00:34:15,880
too complex you know so back to

00:34:12,159 --> 00:34:19,570
assignments we have his left side and

00:34:15,880 --> 00:34:22,149
right side left side is evaluated to a

00:34:19,570 --> 00:34:24,370
pointer so we know where to write our

00:34:22,149 --> 00:34:28,320
information and the right side is

00:34:24,370 --> 00:34:31,720
evaluated directly into this address

00:34:28,320 --> 00:34:33,429
there I did not include any links here

00:34:31,720 --> 00:34:36,460
I'll do it later

00:34:33,429 --> 00:34:41,220
there is a one big entry point which is

00:34:36,460 --> 00:34:45,270
evaluate our value into destination and

00:34:41,220 --> 00:34:48,220
this method on the evaluation context

00:34:45,270 --> 00:34:49,960
basically thus the whole constant

00:34:48,220 --> 00:34:53,080
evaluation this is this is like the D

00:34:49,960 --> 00:34:56,710
entry point that does all the logic

00:34:53,080 --> 00:34:58,260
behind it so if you want to follow

00:34:56,710 --> 00:35:02,110
bottom up

00:34:58,260 --> 00:35:07,050
no top down where constant variation

00:35:02,110 --> 00:35:07,050
works you would start with that function

00:35:08,700 --> 00:35:15,070
so once we have exhausted all the

00:35:12,010 --> 00:35:19,060
statements inside a basic block we reach

00:35:15,070 --> 00:35:20,590
a terminator and the terminator there's

00:35:19,060 --> 00:35:23,470
some other terminators too but it does

00:35:20,590 --> 00:35:25,990
up basically the usual ones we can have

00:35:23,470 --> 00:35:28,900
function calls we can after searchings

00:35:25,990 --> 00:35:32,740
which just basically function calls that

00:35:28,900 --> 00:35:35,290
you don't have a success case or throw a

00:35:32,740 --> 00:35:37,630
panic we can have go-to which does

00:35:35,290 --> 00:35:41,610
literally nothing except go to the next

00:35:37,630 --> 00:35:44,920
block with a switch which depending on a

00:35:41,610 --> 00:35:47,890
on an operand decides which basic block

00:35:44,920 --> 00:35:49,570
to go to and we have a return which just

00:35:47,890 --> 00:35:51,370
terminates the function it does not

00:35:49,570 --> 00:35:57,930
return any value or anything it just

00:35:51,370 --> 00:36:01,000
terminates a function a function call

00:35:57,930 --> 00:36:03,430
also jumps to a new basic block

00:36:01,000 --> 00:36:04,400
afterwards or well all Terminator

00:36:03,430 --> 00:36:06,170
students so when

00:36:04,400 --> 00:36:09,350
terminator is finished evaluating we

00:36:06,170 --> 00:36:15,230
jump to a new basic block and start the

00:36:09,350 --> 00:36:16,520
whole process anew in order to know

00:36:15,230 --> 00:36:21,380
where we are

00:36:16,520 --> 00:36:23,420
the the frame contains a basic block

00:36:21,380 --> 00:36:25,490
index and the statement index and these

00:36:23,420 --> 00:36:27,290
are incremented in different situations

00:36:25,490 --> 00:36:29,390
so the statement index is incremented

00:36:27,290 --> 00:36:32,980
after every single assignment is

00:36:29,390 --> 00:36:34,910
evaluated once we are pointing to a

00:36:32,980 --> 00:36:40,000
terminator because there are no more

00:36:34,910 --> 00:36:44,330
statements inside this basic block then

00:36:40,000 --> 00:36:47,960
we change to block that's currently

00:36:44,330 --> 00:36:49,670
being evaluated and set the statement

00:36:47,960 --> 00:36:52,640
field back to zero so we starting off in

00:36:49,670 --> 00:36:54,710
a new block at the start the only

00:36:52,640 --> 00:36:56,450
operators that do something different

00:36:54,710 --> 00:36:58,790
but the only operator that's something

00:36:56,450 --> 00:37:00,620
different it's a return operator because

00:36:58,790 --> 00:37:03,170
the return operator actually destroys

00:37:00,620 --> 00:37:06,290
the current stack frame so we are back

00:37:03,170 --> 00:37:10,850
at the original callers stack frame all

00:37:06,290 --> 00:37:12,860
other terminators follow exactly this

00:37:10,850 --> 00:37:16,990
kind of procedure so even if you're

00:37:12,860 --> 00:37:16,990
doing a function call all you're doing

00:37:18,490 --> 00:37:22,010
one question all right

00:37:20,240 --> 00:37:25,730
there's also panics right yes I guess

00:37:22,010 --> 00:37:27,830
that's more or less they're not really

00:37:25,730 --> 00:37:30,020
implemented in constable all they do is

00:37:27,830 --> 00:37:31,400
tell you the compiler panicked and

00:37:30,020 --> 00:37:33,520
there's no unwinding or anything

00:37:31,400 --> 00:37:43,070
happening okay that simplifies things

00:37:33,520 --> 00:37:50,500
very simple right now yeah so function

00:37:43,070 --> 00:37:53,150
calls let's ask a different question yes

00:37:50,500 --> 00:37:55,520
maybe there's a bit of context I wasn't

00:37:53,150 --> 00:37:58,630
fully aware of so in Amiri though our

00:37:55,520 --> 00:38:01,940
panics ignored or are they implemented

00:37:58,630 --> 00:38:04,670
now in Mary we also don't do unwinding

00:38:01,940 --> 00:38:06,590
well we just stop when the panic ABS so

00:38:04,670 --> 00:38:09,950
to what extent is the constant value

00:38:06,590 --> 00:38:12,620
raishin and miri like the same codebase

00:38:09,950 --> 00:38:15,200
well do they share these memory and

00:38:12,620 --> 00:38:17,030
other data structures yeah that'll come

00:38:15,200 --> 00:38:23,120
again okay

00:38:17,030 --> 00:38:28,730
we'll get there yep

00:38:23,120 --> 00:38:32,240
so when we call a new function which we

00:38:28,730 --> 00:38:36,650
here below we fetched Mir of this

00:38:32,240 --> 00:38:38,900
function we sets the frame to point to

00:38:36,650 --> 00:38:42,650
the initial block which is usually block

00:38:38,900 --> 00:38:46,180
0 we set a statement to 0 we add two

00:38:42,650 --> 00:38:49,580
stack frame to the current stack and

00:38:46,180 --> 00:38:52,070
then we don't do anything what happens

00:38:49,580 --> 00:38:54,680
is next time we call step step we'll

00:38:52,070 --> 00:38:58,340
take the uppermost frame on the stack

00:38:54,680 --> 00:39:00,380
and start evaluating there so the frame

00:38:58,340 --> 00:39:02,780
below simply stays where it was it's not

00:39:00,380 --> 00:39:04,850
even getting touched and the uppermost

00:39:02,780 --> 00:39:06,530
stack which is our new frame that

00:39:04,850 --> 00:39:09,290
happens after the function call that

00:39:06,530 --> 00:39:11,630
gets evaluated so a function call

00:39:09,290 --> 00:39:13,370
actually takes two steps inside the

00:39:11,630 --> 00:39:17,960
interpreter it takes a step that

00:39:13,370 --> 00:39:20,840
evaluates the determinator for calling

00:39:17,960 --> 00:39:22,970
and then it takes a step to actually be

00:39:20,840 --> 00:39:25,160
inside the function and do something

00:39:22,970 --> 00:39:28,070
with it so pushing a stack frame is a

00:39:25,160 --> 00:39:32,780
single step and then evaluating inside

00:39:28,070 --> 00:39:35,870
the stack frame needs its own steps okay

00:39:32,780 --> 00:39:38,120
so how do we do a function calls the

00:39:35,870 --> 00:39:40,880
easy one is if we're starting out with a

00:39:38,120 --> 00:39:45,110
function pointer a function pointer is

00:39:40,880 --> 00:39:47,780
also analog ID but it has two invariant

00:39:45,110 --> 00:39:51,560
that the offset must be zero and the a

00:39:47,780 --> 00:39:55,220
log ID doesn't actually point to an

00:39:51,560 --> 00:39:57,440
allocation this a little bit hackneyed

00:39:55,220 --> 00:40:00,470
but what we're doing is we are

00:39:57,440 --> 00:40:02,360
allocating allegretti's for functions so

00:40:00,470 --> 00:40:05,570
we have a hash map somewhere when you go

00:40:02,360 --> 00:40:08,960
from analog ID to an instance so you can

00:40:05,570 --> 00:40:11,650
ask the global context to give you the

00:40:08,960 --> 00:40:15,230
instance that belongs to an elevator a

00:40:11,650 --> 00:40:20,060
instance is essentially a pair of def ID

00:40:15,230 --> 00:40:22,120
and a substitution set which is

00:40:20,060 --> 00:40:25,340
important if you have generic functions

00:40:22,120 --> 00:40:30,350
for example if you have a function that

00:40:25,340 --> 00:40:30,830
has generic parameters but you now know

00:40:30,350 --> 00:40:32,570
all

00:40:30,830 --> 00:40:34,490
generic parameters - it's basically

00:40:32,570 --> 00:40:36,140
Monomoy feist at this point then you

00:40:34,490 --> 00:40:40,670
also have a set of substitutions that

00:40:36,140 --> 00:40:43,490
defines how this function how did the

00:40:40,670 --> 00:40:46,790
functions generic parameters are defined

00:40:43,490 --> 00:40:48,890
in this current call other or monomyth

00:40:46,790 --> 00:40:52,370
highest so in some sense the allegheny

00:40:48,890 --> 00:40:53,780
might be like a special value ID you

00:40:52,370 --> 00:40:59,630
could think like it's not only for

00:40:53,780 --> 00:41:01,460
allocations but alligators locations we

00:40:59,630 --> 00:41:02,720
have considered doing some different

00:41:01,460 --> 00:41:07,880
setups but we have not been able to do

00:41:02,720 --> 00:41:10,580
this in a performance or scalable way so

00:41:07,880 --> 00:41:14,360
right now we're working with that but it

00:41:10,580 --> 00:41:16,130
seems to work I think there's even other

00:41:14,360 --> 00:41:18,490
oh yeah there's also other other I like

00:41:16,130 --> 00:41:22,310
IDs for example as analogue ID for

00:41:18,490 --> 00:41:24,140
referring to statics so if you refer to

00:41:22,310 --> 00:41:26,630
as static you don't actually refer to

00:41:24,140 --> 00:41:29,030
the statics memory you only refer to the

00:41:26,630 --> 00:41:31,670
static in an abstract way so there's a

00:41:29,030 --> 00:41:34,010
map going from alpha guy T to def ID and

00:41:31,670 --> 00:41:37,010
DEF ID must be the DEF idea for static

00:41:34,010 --> 00:41:40,130
and this exists because you can actually

00:41:37,010 --> 00:41:43,100
aesthetics that are cyclic taken a

00:41:40,130 --> 00:41:45,110
static a which isn't a raw pointer

00:41:43,100 --> 00:41:48,050
pointing to static B and saying P can

00:41:45,110 --> 00:41:51,590
have a pointer pointer static a and we

00:41:48,050 --> 00:41:53,840
would never be able to create the memory

00:41:51,590 --> 00:41:55,790
that is structured this way so while

00:41:53,840 --> 00:41:57,350
evaluating one of one static we would

00:41:55,790 --> 00:41:59,840
need to evaluate the other static to get

00:41:57,350 --> 00:42:01,850
yellow the allocation and the correct a

00:41:59,840 --> 00:42:03,320
logue ID for the allocation but that

00:42:01,850 --> 00:42:05,750
static would also want the other statics

00:42:03,320 --> 00:42:09,520
1 and then we'd been in bind so what we

00:42:05,750 --> 00:42:12,350
did we created this kind of shallow

00:42:09,520 --> 00:42:13,940
pointer which is analog ID that just

00:42:12,350 --> 00:42:15,440
refers to the def idea of another static

00:42:13,940 --> 00:42:18,830
and doesn't actually need to evaluate

00:42:15,440 --> 00:42:21,320
the other static once you try to

00:42:18,830 --> 00:42:24,140
dereference such a pointer you the

00:42:21,320 --> 00:42:26,510
constant evaluation will actually fetch

00:42:24,140 --> 00:42:33,560
the correct alok ID and the correct

00:42:26,510 --> 00:42:37,220
memory um so if we started with a

00:42:33,560 --> 00:42:39,620
definition we have two def ID of the

00:42:37,220 --> 00:42:42,050
function usually from the type so if you

00:42:39,620 --> 00:42:44,830
call a function on directly when you get

00:42:42,050 --> 00:42:47,770
us like a serie sized value which

00:42:44,830 --> 00:42:50,350
is of a function type which directly

00:42:47,770 --> 00:42:54,610
contains the DEF ID of the corresponding

00:42:50,350 --> 00:42:58,900
function and what we also use is the

00:42:54,610 --> 00:43:03,370
substitutions of the current function to

00:42:58,900 --> 00:43:04,960
figure out how to call the next function

00:43:03,370 --> 00:43:08,050
so if you're in a generic function

00:43:04,960 --> 00:43:10,270
calling another generic function but the

00:43:08,050 --> 00:43:12,700
outer generic function already is being

00:43:10,270 --> 00:43:14,560
monomer Feist you know the exact generic

00:43:12,700 --> 00:43:18,000
parameters and you can forward them to

00:43:14,560 --> 00:43:20,200
the inner function call and thus

00:43:18,000 --> 00:43:25,480
correctly call it completely mono more

00:43:20,200 --> 00:43:27,910
fast one more intermediate step is the

00:43:25,480 --> 00:43:31,390
instant result call which is important

00:43:27,910 --> 00:43:34,630
if you for example trying to call a

00:43:31,390 --> 00:43:37,270
clone method on for example a string or

00:43:34,630 --> 00:43:40,210
something this is actually a trade

00:43:37,270 --> 00:43:44,260
method but we need to resolve it to the

00:43:40,210 --> 00:43:50,470
actual in pull method of in pull clone

00:43:44,260 --> 00:43:52,330
for string this mmm this is required

00:43:50,470 --> 00:43:55,000
when you're for example monomer firing

00:43:52,330 --> 00:43:57,580
inside a generic function but the

00:43:55,000 --> 00:43:59,740
generic parameter has for example been

00:43:57,580 --> 00:44:01,810
set to string and when you're now

00:43:59,740 --> 00:44:04,630
calling clone on the generic parameter

00:44:01,810 --> 00:44:06,880
you know it's string but you don't know

00:44:04,630 --> 00:44:09,190
what the actual function is the actual

00:44:06,880 --> 00:44:11,140
clone method that's on string so that's

00:44:09,190 --> 00:44:13,680
what instant results basically does it

00:44:11,140 --> 00:44:22,810
gives you the very did a concrete

00:44:13,680 --> 00:44:25,420
function from the input block if you try

00:44:22,810 --> 00:44:28,090
to create function pointers from the

00:44:25,420 --> 00:44:29,620
ether by for example transmuting a

00:44:28,090 --> 00:44:31,690
integer to a function pointer

00:44:29,620 --> 00:44:34,660
maybe we'll definitely notice and

00:44:31,690 --> 00:44:37,030
complain loudly so you can't actually

00:44:34,660 --> 00:44:39,100
try to do something like evaluating

00:44:37,030 --> 00:44:50,020
bytecode or something that just doesn't

00:44:39,100 --> 00:44:52,840
work okay now we're getting to a few

00:44:50,020 --> 00:44:57,450
more fancy features that aren't actually

00:44:52,840 --> 00:45:02,760
implemented yet and let's go to 44 again

00:44:57,450 --> 00:45:05,220
so one thing that works in Miri but does

00:45:02,760 --> 00:45:09,330
not work in constant evaluation is heap

00:45:05,220 --> 00:45:11,760
allocations and if allocations are

00:45:09,330 --> 00:45:14,010
actually a very simple feature when we

00:45:11,760 --> 00:45:16,230
implement those in the very beginning

00:45:14,010 --> 00:45:20,460
they were quite very very little

00:45:16,230 --> 00:45:22,410
additional code because we already have

00:45:20,460 --> 00:45:24,330
stack of locations but as you saw

00:45:22,410 --> 00:45:27,150
earlier in the graph stack of locations

00:45:24,330 --> 00:45:30,330
aren't really like a stack that you know

00:45:27,150 --> 00:45:32,280
from actual computers they are more a

00:45:30,330 --> 00:45:35,490
little bit like I don't know Java stacks

00:45:32,280 --> 00:45:38,310
or something where every variable itself

00:45:35,490 --> 00:45:40,710
is like completely separated from every

00:45:38,310 --> 00:45:44,820
other variable so each variable has its

00:45:40,710 --> 00:45:47,150
own memory and you you can't possibly go

00:45:44,820 --> 00:45:50,010
from one memory look to an hour

00:45:47,150 --> 00:45:52,410
variables memory pointer into one

00:45:50,010 --> 00:45:55,140
variable no matter how many times you do

00:45:52,410 --> 00:45:57,690
offset on this pointer you will never

00:45:55,140 --> 00:46:00,090
ever end up in another variables memory

00:45:57,690 --> 00:46:03,360
they're completely logically separated

00:46:00,090 --> 00:46:06,030
and the same thing works a heap

00:46:03,360 --> 00:46:09,720
allocations so if you create a heap

00:46:06,030 --> 00:46:10,950
allocation then you have a heap

00:46:09,720 --> 00:46:16,050
allocation of the size that you

00:46:10,950 --> 00:46:18,000
specified but you can't actually get

00:46:16,050 --> 00:46:20,430
into other heap allocations you can't

00:46:18,000 --> 00:46:23,060
accidentally run into the stack there

00:46:20,430 --> 00:46:27,630
they're completely separated which is

00:46:23,060 --> 00:46:31,170
possible because the alloc IDs aren't a

00:46:27,630 --> 00:46:33,420
normal memory space like we know it from

00:46:31,170 --> 00:46:35,310
from a computer they're each a log ID

00:46:33,420 --> 00:46:40,980
has its own memory and then we can only

00:46:35,310 --> 00:46:42,840
offset inside that memory in order to

00:46:40,980 --> 00:46:45,570
create heap allocations now what we did

00:46:42,840 --> 00:46:47,970
is we kind of hacked on some support to

00:46:45,570 --> 00:46:49,410
intercept function calls so if somebody

00:46:47,970 --> 00:46:52,410
tried to call the underscore underscore

00:46:49,410 --> 00:46:55,830
rest allocate function what we did is we

00:46:52,410 --> 00:47:02,670
just did not call it and simply return a

00:46:55,830 --> 00:47:04,830
new Alec ID and offset of zero and let's

00:47:02,670 --> 00:47:06,840
the rest of the rest code continue on as

00:47:04,830 --> 00:47:08,820
it was so we're not actually

00:47:06,840 --> 00:47:11,080
interpreting the rest allocate function

00:47:08,820 --> 00:47:13,930
because that would go for

00:47:11,080 --> 00:47:16,570
into the system a locator or something

00:47:13,930 --> 00:47:19,470
what we instead do it was kind of

00:47:16,570 --> 00:47:22,240
implement our own system a locator which

00:47:19,470 --> 00:47:25,020
use the same mechanism for that we used

00:47:22,240 --> 00:47:31,830
for second locations simply allocated a

00:47:25,020 --> 00:47:37,960
piece of memory and returned that that

00:47:31,830 --> 00:47:40,290
pointer and so function intercepting is

00:47:37,960 --> 00:47:47,200
one thing we're constable and miri

00:47:40,290 --> 00:47:48,760
differ very extremely so Miri has random

00:47:47,200 --> 00:47:50,740
functions implemented that it actually

00:47:48,760 --> 00:47:52,420
will intercept and do something that you

00:47:50,740 --> 00:47:54,460
go with it so for example you can

00:47:52,420 --> 00:47:56,770
actually call malloc and free there's a

00:47:54,460 --> 00:47:59,470
bunch of sis calls that you can do we

00:47:56,770 --> 00:48:02,280
implemented quite a list of P thread

00:47:59,470 --> 00:48:06,220
functions and the list is very long I

00:48:02,280 --> 00:48:08,740
think I partially got memory mapping to

00:48:06,220 --> 00:48:10,960
work and so on so Miri itself will do a

00:48:08,740 --> 00:48:14,080
lot of crazy stuff that is definitely

00:48:10,960 --> 00:48:15,430
not good for constable but there's a

00:48:14,080 --> 00:48:19,750
list of things that are interesting in

00:48:15,430 --> 00:48:22,360
constable for example intrinsic s-- we

00:48:19,750 --> 00:48:25,540
have a lot of intrinsic for our integer

00:48:22,360 --> 00:48:30,270
arithmetic you can see those if you're

00:48:25,540 --> 00:48:34,390
for example calling checked add or

00:48:30,270 --> 00:48:39,160
overflowing soap or something these

00:48:34,390 --> 00:48:42,900
functions will get intercepted by the

00:48:39,160 --> 00:48:45,990
conciliator and then do something

00:48:42,900 --> 00:48:48,520
actually to do some hard handwritten

00:48:45,990 --> 00:48:54,580
interpretation there's no rest code

00:48:48,520 --> 00:48:58,080
there it's just Miri internal code that

00:48:54,580 --> 00:49:00,460
will kind of emulate what the actual

00:48:58,080 --> 00:49:03,940
function would do for example if it were

00:49:00,460 --> 00:49:06,310
translated to LLVM we also have a bunch

00:49:03,940 --> 00:49:09,280
of laying items that we are intercepting

00:49:06,310 --> 00:49:11,620
for example the panic Lang item is

00:49:09,280 --> 00:49:13,330
intercepted so we're not going into the

00:49:11,620 --> 00:49:15,250
panic machinery but the moment we hit

00:49:13,330 --> 00:49:17,380
the panic Lang item we abort

00:49:15,250 --> 00:49:20,550
consideration and report an error about

00:49:17,380 --> 00:49:20,550
having hit a panic

00:49:21,090 --> 00:49:28,890
and by now and as the question has

00:49:25,800 --> 00:49:29,940
already been there there it's clear

00:49:28,890 --> 00:49:33,630
there's a lot of code duplication

00:49:29,940 --> 00:49:37,250
between contestable Amiri in order to

00:49:33,630 --> 00:49:39,960
reduce this what we have is a central

00:49:37,250 --> 00:49:42,030
part which is called the miry engine

00:49:39,960 --> 00:49:45,330
which contains everything that constable

00:49:42,030 --> 00:49:47,760
needs and that miri needs without having

00:49:45,330 --> 00:49:52,950
anything more that either of those would

00:49:47,760 --> 00:49:56,220
need the miry engine is for example the

00:49:52,950 --> 00:49:58,530
evaluation contacts the memory inside of

00:49:56,220 --> 00:50:01,320
that and so on and these types are all

00:49:58,530 --> 00:50:03,510
generic and they are generic over the so

00:50:01,320 --> 00:50:06,180
called machine trade the machine trade

00:50:03,510 --> 00:50:08,100
implements a bunch of methods and has a

00:50:06,180 --> 00:50:10,230
bunch of associated types and associated

00:50:08,100 --> 00:50:13,610
constants that you can use to configure

00:50:10,230 --> 00:50:17,310
how your evaluation is actually gonna

00:50:13,610 --> 00:50:20,910
kind of work for example there's a

00:50:17,310 --> 00:50:24,600
function in there for mutating a static

00:50:20,910 --> 00:50:27,000
and in constable that function will

00:50:24,600 --> 00:50:30,950
simply return error and Amiri it will

00:50:27,000 --> 00:50:36,540
actually have some logic implemented and

00:50:30,950 --> 00:50:38,340
this is also the entry point for the

00:50:36,540 --> 00:50:42,710
function intercepting so there's a

00:50:38,340 --> 00:50:46,560
method on the machine trade which

00:50:42,710 --> 00:50:50,040
intercepts arbitrary functions and you

00:50:46,560 --> 00:50:52,260
can define which set of functions are

00:50:50,040 --> 00:50:56,670
going to get intercepted by overriding

00:50:52,260 --> 00:50:59,520
this message yourself the functions that

00:50:56,670 --> 00:51:02,340
have intercepted both by a constable and

00:50:59,520 --> 00:51:04,680
miri they are directly inside the miry

00:51:02,340 --> 00:51:06,480
engine and it don't even ever hit the

00:51:04,680 --> 00:51:10,770
machine method for intercepting

00:51:06,480 --> 00:51:13,310
functions they are completely inside the

00:51:10,770 --> 00:51:13,310
miry engine

00:51:18,970 --> 00:51:24,069
so if we're implementing new constable

00:51:21,490 --> 00:51:26,440
features most of those already exist

00:51:24,069 --> 00:51:29,380
inside Mary so what we're doing often is

00:51:26,440 --> 00:51:31,750
we are uplifting them from me read to

00:51:29,380 --> 00:51:33,099
the miry engine and removing the

00:51:31,750 --> 00:51:34,240
relevant machine hooks if the

00:51:33,099 --> 00:51:40,119
Constabulary that doesn't need them

00:51:34,240 --> 00:51:42,220
anymore one thing that we do quite a lot

00:51:40,119 --> 00:51:48,250
as uplifting oops

00:51:42,220 --> 00:51:50,589
uplifting intrinsics so there's a file

00:51:48,250 --> 00:51:53,020
which implements all the intrinsic sand

00:51:50,589 --> 00:51:56,530
in Miri

00:51:53,020 --> 00:51:59,500
and well what we do is we move over to

00:51:56,530 --> 00:52:07,210
code from the for Miri to the concept by

00:51:59,500 --> 00:52:09,730
later evaluator they the files are even

00:52:07,210 --> 00:52:11,020
named the same thing they're very easy

00:52:09,730 --> 00:52:12,369
to find that they refer to each other

00:52:11,020 --> 00:52:15,520
actually in the code in the

00:52:12,369 --> 00:52:18,819
documentation once we have moved over

00:52:15,520 --> 00:52:22,869
the code we make the intrinsic wrapper

00:52:18,819 --> 00:52:25,750
Khan seven and at the intrinsic to the

00:52:22,869 --> 00:52:27,310
white list inside this file the white

00:52:25,750 --> 00:52:28,750
list is all the intrinsics that are

00:52:27,310 --> 00:52:30,940
allowed to be called at constant values

00:52:28,750 --> 00:52:32,470
in time there's a bunch of intrinsics

00:52:30,940 --> 00:52:34,150
that don't make sense during constant

00:52:32,470 --> 00:52:36,190
variation time so we don't want to

00:52:34,150 --> 00:52:38,140
accidentally allow arbitrary intrinsics

00:52:36,190 --> 00:52:42,670
so we have a whitelist to allow those

00:52:38,140 --> 00:52:44,819
and once this D steps are done and maybe

00:52:42,670 --> 00:52:49,440
there's some additional workarounds for

00:52:44,819 --> 00:52:53,170
stability and so on you can remove the

00:52:49,440 --> 00:52:58,480
code from Miri entirely and it's inside

00:52:53,170 --> 00:53:05,670
the maybe engine and both constable and

00:52:58,480 --> 00:53:09,339
Miri can now use the same code base yep

00:53:05,670 --> 00:53:12,310
that's it pretty much from me I included

00:53:09,339 --> 00:53:15,160
a bunch of links on the bottom to have

00:53:12,310 --> 00:53:20,760
some quicker entry points into what kind

00:53:15,160 --> 00:53:25,810
of code lifts we're inside conciliator

00:53:20,760 --> 00:53:28,089
yeah wow that was really fun very cool

00:53:25,810 --> 00:53:29,800
thanks ollie

00:53:28,089 --> 00:53:31,930
trying to think if there's any final

00:53:29,800 --> 00:53:34,619
questions on my part or anybody else

00:53:31,930 --> 00:53:34,619
maybe has any

00:53:35,440 --> 00:53:46,720
so where are we with uplifting can't

00:53:42,310 --> 00:53:51,099
float alleys loops and some NDE London

00:53:46,720 --> 00:53:54,700
OPR so what was the first part just if

00:53:51,099 --> 00:54:01,000
and you okay okay a control float that

00:53:54,700 --> 00:54:03,700
was worth yes so it so we're not even we

00:54:01,000 --> 00:54:06,880
don't even need to uplift it the problem

00:54:03,700 --> 00:54:10,720
is it's already inside a mirror engine

00:54:06,880 --> 00:54:12,580
it's just disabled because we can't

00:54:10,720 --> 00:54:15,760
currently prove certain saying

00:54:12,580 --> 00:54:19,109
statically so the cons qualify 'el is

00:54:15,760 --> 00:54:25,500
actually a and let me scroll down I

00:54:19,109 --> 00:54:44,770
can't anymore maybe maybe just slow

00:54:25,500 --> 00:54:46,990
scroll down there it goes yeah well so

00:54:44,770 --> 00:54:51,339
we have this can't qualify

00:54:46,990 --> 00:54:57,400
file and this is a bunch of static

00:54:51,339 --> 00:55:02,800
analysis on constants that prove that we

00:54:57,400 --> 00:55:05,830
can actually say with a certain level of

00:55:02,800 --> 00:55:10,780
certainty that the constant is sane this

00:55:05,830 --> 00:55:13,930
is important because some constants

00:55:10,780 --> 00:55:16,390
can't just be evaluated if you have for

00:55:13,930 --> 00:55:22,089
example an Associated constant of a

00:55:16,390 --> 00:55:25,150
trait and that straight method that rate

00:55:22,089 --> 00:55:27,280
constant depends on other constants that

00:55:25,150 --> 00:55:29,770
are not defined yet you can't evaluate

00:55:27,280 --> 00:55:32,980
them yet only when the user actually

00:55:29,770 --> 00:55:34,900
uses the trait and implements their the

00:55:32,980 --> 00:55:38,650
trade for their own type they have to

00:55:34,900 --> 00:55:40,680
specify the constants so if you have for

00:55:38,650 --> 00:55:40,680
example

00:55:59,930 --> 00:56:09,540
if you have a an associate constant full

00:56:04,020 --> 00:56:14,369
of type u32 and its value is power

00:56:09,540 --> 00:56:16,440
minus-1 and cons are you 32 isn't

00:56:14,369 --> 00:56:21,750
actually defined yet if a user would

00:56:16,440 --> 00:56:24,300
supply a zero here then this will panic

00:56:21,750 --> 00:56:28,589
later or it will break constant relation

00:56:24,300 --> 00:56:30,720
and this is one of the cases that we

00:56:28,589 --> 00:56:36,180
can't actually detect statically but

00:56:30,720 --> 00:56:38,339
there's other situations where we have

00:56:36,180 --> 00:56:51,210
so for example if we get to control flow

00:56:38,339 --> 00:56:52,760
and we say if R then we do let's do

00:56:51,210 --> 00:57:06,089
something more complex let's do an

00:56:52,760 --> 00:57:07,980
option and sell you 32 and usually we

00:57:06,089 --> 00:57:21,990
put a nun in there but maybe in some

00:57:07,980 --> 00:57:25,170
situation we might put a sum in there if

00:57:21,990 --> 00:57:32,300
you now had runtime code that x equals

00:57:25,170 --> 00:57:38,040
foo and you do for example X dot unwrap

00:57:32,300 --> 00:57:47,970
dot set 99 you would not want that y

00:57:38,040 --> 00:57:50,099
equals to Y 2 equal 99 because that

00:57:47,970 --> 00:57:52,040
would not only be very surprising if

00:57:50,099 --> 00:57:55,510
constants could change the value

00:57:52,040 --> 00:57:58,270
additionally it would be

00:57:55,510 --> 00:58:00,490
very problematic if you could have a

00:57:58,270 --> 00:58:03,990
cell to exchange data between threats

00:58:00,490 --> 00:58:08,770
because that's that has race conditions

00:58:03,990 --> 00:58:11,230
so we kind of want to look at all the

00:58:08,770 --> 00:58:15,520
branches and figure out information from

00:58:11,230 --> 00:58:17,890
them to declare whether this constant is

00:58:15,520 --> 00:58:20,050
actually a legal constant or if it does

00:58:17,890 --> 00:58:23,440
some things that we know are really

00:58:20,050 --> 00:58:24,940
problematic I don't have to issue at

00:58:23,440 --> 00:58:26,050
hand where we where we have more

00:58:24,940 --> 00:58:27,540
examples that are actually more

00:58:26,050 --> 00:58:31,840
real-world examples that are problematic

00:58:27,540 --> 00:58:35,400
but yeah we are trying to statically

00:58:31,840 --> 00:58:39,520
prevent certain very problematic things

00:58:35,400 --> 00:58:41,740
so and unless you read a number of post

00:58:39,520 --> 00:58:47,650
manifestation post one of my fat asian

00:58:41,740 --> 00:58:51,760
errors to do a minimum so in this case

00:58:47,650 --> 00:58:57,780
you would require that both the if and

00:58:51,760 --> 00:59:02,650
the else branches are well-formed right

00:58:57,780 --> 00:59:04,000
can we yeah and yeah keep going I was

00:59:02,650 --> 00:59:07,270
just thinking that this actually sounds

00:59:04,000 --> 00:59:09,430
like an interesting topic to dive into

00:59:07,270 --> 00:59:10,540
perhaps in a follow-on session or

00:59:09,430 --> 00:59:12,400
something like it's a little off field

00:59:10,540 --> 00:59:14,800
from where we covered so far but read

00:59:12,400 --> 00:59:16,570
right there's a lot of stuff a lot of

00:59:14,800 --> 00:59:20,980
interesting questions are coming to mind

00:59:16,570 --> 00:59:23,230
from this it's a big topic and so far we

00:59:20,980 --> 00:59:27,730
haven't discussed that much from it it's

00:59:23,230 --> 00:59:30,150
basically a struggle between the postman

00:59:27,730 --> 00:59:33,040
office a postman of a citation or other

00:59:30,150 --> 00:59:36,730
okay people and the people were not okay

00:59:33,040 --> 00:59:40,120
with it because we're always trying to

00:59:36,730 --> 00:59:42,340
find like a balance there we already

00:59:40,120 --> 00:59:44,040
have postman of our citation errors for

00:59:42,340 --> 00:59:48,280
example the one thing was the

00:59:44,040 --> 00:59:50,410
subtracting one from another variable so

00:59:48,280 --> 00:59:52,870
any integer arithmetic can actually cost

00:59:50,410 --> 00:59:56,350
postman authorization errors but a lot

00:59:52,870 --> 01:00:02,200
of other things cannot and just keeping

00:59:56,350 --> 01:00:05,080
this balance in a nice way as I think

01:00:02,200 --> 01:00:07,150
this fits we had this essential you'll

01:00:05,080 --> 01:00:08,420
recall in our line teen discussions we

01:00:07,150 --> 01:00:10,369
had this sort of we should

01:00:08,420 --> 01:00:11,960
some kind of working group around cost

01:00:10,369 --> 01:00:13,400
evaluation it sounds like this is the

01:00:11,960 --> 01:00:16,190
kind of thing that would be exactly

01:00:13,400 --> 01:00:20,210
under that agenda so we should sync up

01:00:16,190 --> 01:00:23,930
on that after the call we do have the

01:00:20,210 --> 01:00:26,089
contest Eva RC repo where we're

01:00:23,930 --> 01:00:28,010
discussing a bunch of these topics right

01:00:26,089 --> 01:00:29,480
I'm basically talking about trying to

01:00:28,010 --> 01:00:31,369
lift some of those discussions or make

01:00:29,480 --> 01:00:33,950
make them more visible to everyone who

01:00:31,369 --> 01:00:36,260
might have any gaps I know you're

01:00:33,950 --> 01:00:41,289
already well underway - I'm excited

01:00:36,260 --> 01:00:44,599
about all right so we end this call and

01:00:41,289 --> 01:00:47,779
carry on oh yes and yeah and our

01:00:44,599 --> 01:00:52,849
questions can also be raised in these in

01:00:47,779 --> 01:00:56,510
the sulla threat for four comes Eva I

01:00:52,849 --> 01:00:58,309
think it has don't channel so just open

01:00:56,510 --> 01:00:58,789
the new topic there and then we can talk

01:00:58,309 --> 01:01:02,089
about it

01:00:58,789 --> 01:01:09,819
well thanks again this was excellent see

01:01:02,089 --> 01:01:09,819

YouTube URL: https://www.youtube.com/watch?v=5Pm2C1YXrvM


