Title: Universes and Lifetimes
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	An overview of how higher-ranked types/trait-bounds (`for&lt;'a&gt; fn(&'a u32)` or `for&lt;'a&gt; T: Foo&lt;'a&gt;`) are implemented in rustc. Focuses on the idea of universes and placeholders and how those are used in subtyping.

The paper doc used in the video is readable here:

https://paper.dropbox.com/doc/Universes-and-57639--AXjnSUh91ZmbD0dDMwTTfFHfAg-vVrMCkndUoXzyrHCOQdq8

Or in gist form:

https://gist.github.com/nikomatsakis/848f6bd0db706b1f0596e7e559588128
Captions: 
	00:00:00,030 --> 00:00:11,400
all right obviously I'm gonna cut the

00:00:08,309 --> 00:00:11,790
spoiler recording so welcome to Arden

00:00:11,400 --> 00:00:15,389
evening

00:00:11,790 --> 00:00:20,580
um so what I'm gonna talk I this is an

00:00:15,389 --> 00:00:22,230
interesting book that I wanted to kind

00:00:20,580 --> 00:00:26,130
of dive into interesting topic to dive

00:00:22,230 --> 00:00:28,230
into because it's I kind of wanted to

00:00:26,130 --> 00:00:33,510
pursue a specific bug a little bit but

00:00:28,230 --> 00:00:36,000
also it is a kind of cross-cutting but

00:00:33,510 --> 00:00:37,829
it affects two fundamental issues things

00:00:36,000 --> 00:00:42,090
in the way the rusty works

00:00:37,829 --> 00:00:44,879
so there's we'll see how far we get we

00:00:42,090 --> 00:00:46,079
may want to do another meeting um but

00:00:44,879 --> 00:00:49,879
it's kind of an interesting way to it to

00:00:46,079 --> 00:00:52,770
instruct so I put a little rough agenda

00:00:49,879 --> 00:00:54,690
if you're in the paper doc and I guess

00:00:52,770 --> 00:00:56,940
you're sure I'm sharing it I put a rough

00:00:54,690 --> 00:01:02,550
agenda here these are the two things so

00:00:56,940 --> 00:01:04,680
the first one is like how to handle how

00:01:02,550 --> 00:01:08,280
to deal with higher ranked trade bound

00:01:04,680 --> 00:01:12,090
like things and solve constraints like

00:01:08,280 --> 00:01:14,700
for all a to get to be or other similar

00:01:12,090 --> 00:01:16,590
things um and how we how we do that I

00:01:14,700 --> 00:01:18,420
would kind of implemented that no low

00:01:16,590 --> 00:01:21,650
level and rusty today and this is

00:01:18,420 --> 00:01:24,180
something that I recently changed and

00:01:21,650 --> 00:01:26,490
that's kind of the problem in some sense

00:01:24,180 --> 00:01:30,030
the source of the problem and then the

00:01:26,490 --> 00:01:36,570
second half is some details on how rusty

00:01:30,030 --> 00:01:39,119
straight silver presently works and and

00:01:36,570 --> 00:01:41,790
and and how that interacts and basically

00:01:39,119 --> 00:01:45,110
the interaction of these two leads to

00:01:41,790 --> 00:01:51,360
how the interaction of these two points

00:01:45,110 --> 00:02:02,030
leads to number 576 screamin so that

00:01:51,360 --> 00:02:07,610
particular bug is a regression here and

00:02:02,030 --> 00:02:11,480
problem is this is like a minimal

00:02:07,610 --> 00:02:14,450
example of it but what it let me see if

00:02:11,480 --> 00:02:15,709
I can remember right and I kind of laid

00:02:14,450 --> 00:02:19,250
out some of the things but it comes down

00:02:15,709 --> 00:02:24,560
to is that the compiler is making a poor

00:02:19,250 --> 00:02:26,180
choice and forcing a for all requirement

00:02:24,560 --> 00:02:28,100
that is stricter than what is actually

00:02:26,180 --> 00:02:32,750
necessary and it didn't use to do this

00:02:28,100 --> 00:02:34,160
in the older system and I guess I'll

00:02:32,750 --> 00:02:36,980
have to talk a little bit about that too

00:02:34,160 --> 00:02:38,780
so you have to sort of cover how we're

00:02:36,980 --> 00:02:40,550
handling regions however healing trade

00:02:38,780 --> 00:02:43,040
selection how we use to handle this

00:02:40,550 --> 00:02:44,900
situation to a certain extent and why it

00:02:43,040 --> 00:02:51,500
led to a different outcome I know we

00:02:44,900 --> 00:02:57,080
have to decide what we want to do so

00:02:51,500 --> 00:02:59,030
let's dive in so the first one for the

00:02:57,080 --> 00:03:03,319
higher-ranked trade bounds problem I

00:02:59,030 --> 00:03:05,769
think so what what's there are a lot of

00:03:03,319 --> 00:03:09,709
different ways that we can get ourselves

00:03:05,769 --> 00:03:12,650
into okay sort of derive these kind of

00:03:09,709 --> 00:03:16,700
constraints so one of the simplest ways

00:03:12,650 --> 00:03:22,070
is that you could have you could have

00:03:16,700 --> 00:03:25,459
like a type like this right and you

00:03:22,070 --> 00:03:30,350
might ask yourself a question like is

00:03:25,459 --> 00:03:31,700
this a subtype of this other type so

00:03:30,350 --> 00:03:36,230
that what this says is I have a function

00:03:31,700 --> 00:03:38,480
pointer that takes a reference of any

00:03:36,230 --> 00:03:40,940
lifetime and I want to know can I use

00:03:38,480 --> 00:03:44,410
that function let's make it more

00:03:40,940 --> 00:03:44,410
concrete I might have like

00:03:46,140 --> 00:03:49,440
[Music]

00:03:47,270 --> 00:03:54,470
somewhere I have a function pointer like

00:03:49,440 --> 00:03:58,680
this and then I have another variable

00:03:54,470 --> 00:04:02,370
with a different type and I want to know

00:03:58,680 --> 00:04:07,020
can I is this is this assignment allowed

00:04:02,370 --> 00:04:10,560
right now that basically says can X the

00:04:07,020 --> 00:04:21,600
assigned that type and in order to do

00:04:10,560 --> 00:04:23,370
that we what happens is we have to there

00:04:21,600 --> 00:04:26,430
is basically an algorithm for doing this

00:04:23,370 --> 00:04:31,260
and the way it works is that when you

00:04:26,430 --> 00:04:33,390
see for all binders on the left like on

00:04:31,260 --> 00:04:35,760
the subtype side well let me go to a

00:04:33,390 --> 00:04:36,900
more intuitive level so first of all is

00:04:35,760 --> 00:04:38,490
the answer yes or no

00:04:36,900 --> 00:04:42,000
should this be allowed or should it not

00:04:38,490 --> 00:04:45,480
be allowed the answer is yes in this

00:04:42,000 --> 00:04:48,240
case and intuitively the reason is this

00:04:45,480 --> 00:04:49,979
this function is able to accept a

00:04:48,240 --> 00:04:54,240
reference with any lifetime or so he

00:04:49,979 --> 00:04:55,680
claims and this type is a lot is a

00:04:54,240 --> 00:04:57,180
function that accepts the reference with

00:04:55,680 --> 00:05:01,370
exactly one lifetime and that's kind of

00:04:57,180 --> 00:05:04,110
a subset right because tip B is a

00:05:01,370 --> 00:05:05,460
lifetime this function is able to accept

00:05:04,110 --> 00:05:09,000
any so that should be okay that means

00:05:05,460 --> 00:05:10,530
you can accept it Li the other direction

00:05:09,000 --> 00:05:12,600
is more problematic

00:05:10,530 --> 00:05:16,229
let's we'll get to that in a second so

00:05:12,600 --> 00:05:18,210
the way that this this works in rusty

00:05:16,229 --> 00:05:22,800
today is when you come like when you

00:05:18,210 --> 00:05:25,590
come to you're doing your you're kind of

00:05:22,800 --> 00:05:29,580
trying to compute you have two types t1

00:05:25,590 --> 00:05:33,660
and t2 and you want to know is t1 a

00:05:29,580 --> 00:05:35,040
subtype of t2 and the outcome of this in

00:05:33,660 --> 00:05:38,600
general when we're asking this question

00:05:35,040 --> 00:05:43,160
or rusty the outcome is either yes or no

00:05:38,600 --> 00:05:46,710
basically and a yes if the answer is yes

00:05:43,160 --> 00:05:48,960
become me can we give back some what we

00:05:46,710 --> 00:05:52,020
call region constraints or lifetime

00:05:48,960 --> 00:05:53,520
constraints incidentally I remember I

00:05:52,020 --> 00:05:55,930
realize now I covered more or less

00:05:53,520 --> 00:06:02,440
exactly this in my recent blog post

00:05:55,930 --> 00:06:04,060
so for all of you who are like following

00:06:02,440 --> 00:06:08,110
along on the Internet's and you feel

00:06:04,060 --> 00:06:11,010
like reading this blog post its kind of

00:06:08,110 --> 00:06:11,010
covering similar stuff

00:06:12,240 --> 00:06:15,439
[Music]

00:06:20,160 --> 00:06:26,860
that link is the vague link yeah okay so

00:06:24,100 --> 00:06:28,420
uh right so let me very simple example

00:06:26,860 --> 00:06:32,250
before he gets the higher rank stuff so

00:06:28,420 --> 00:06:37,240
if you have like ampersand Takei you 32

00:06:32,250 --> 00:06:44,950
if you ask this question thieves

00:06:37,240 --> 00:06:51,550
the result would be yes if now those

00:06:44,950 --> 00:06:54,310
tippy so so basically what we're saying

00:06:51,550 --> 00:06:56,260
here is there's an important thing which

00:06:54,310 --> 00:06:58,030
is that we don't the the subtyping

00:06:56,260 --> 00:06:59,730
engine all of these two gays entities

00:06:58,030 --> 00:07:03,100
that I'm running down are basically

00:06:59,730 --> 00:07:05,530
variables we don't know what lifetimes

00:07:03,100 --> 00:07:07,570
they represent or what sets of loans and

00:07:05,530 --> 00:07:09,340
the polonius terminology but we just

00:07:07,570 --> 00:07:11,200
know that there are some lifetime and so

00:07:09,340 --> 00:07:13,990
what we want to get out of this is what

00:07:11,200 --> 00:07:15,910
would be the constraint if we if we gave

00:07:13,990 --> 00:07:17,710
these variables like map them to

00:07:15,910 --> 00:07:19,660
concrete lifetimes what would be the

00:07:17,710 --> 00:07:21,820
constraint that must be satisfied for

00:07:19,660 --> 00:07:27,100
the subtyping relationship to hold right

00:07:21,820 --> 00:07:29,350
and so like a concrete example or this

00:07:27,100 --> 00:07:30,850
all derives from the idea that a longer

00:07:29,350 --> 00:07:32,200
a reference to the longer lifetime can

00:07:30,850 --> 00:07:36,700
be coerced along with a shorter lifetime

00:07:32,200 --> 00:07:38,320
because that make sense um if it's valid

00:07:36,700 --> 00:07:42,430
for the longer periods valid for the

00:07:38,320 --> 00:07:43,810
shorter period so so for this kind of

00:07:42,430 --> 00:07:45,340
case where there's no for else is easy

00:07:43,810 --> 00:07:47,530
right

00:07:45,340 --> 00:07:52,330
so our subtyping algorithm for that is

00:07:47,530 --> 00:07:55,480
like if t1 is ampersand 2k you 32 and t2

00:07:52,330 --> 00:08:01,800
is you represent a P well that's to

00:07:55,480 --> 00:08:10,540
specific if it's if it's two references

00:08:01,800 --> 00:08:13,240
then we can say we can kind of make sure

00:08:10,540 --> 00:08:14,350
that the t1 and t2 will have to be some

00:08:13,240 --> 00:08:17,080
types of one another so we can

00:08:14,350 --> 00:08:19,210
recursively do that and that gives us

00:08:17,080 --> 00:08:24,160
back some constraints and then we return

00:08:19,210 --> 00:08:25,540
like c1 plus 2k all those TV I don't

00:08:24,160 --> 00:08:28,630
know it's kind of pseudocode does that

00:08:25,540 --> 00:08:30,719
make sense so this is the sort of

00:08:28,630 --> 00:08:32,189
definition of sub type t1 t2

00:08:30,719 --> 00:08:33,899
map this to the rescue code in a second

00:08:32,189 --> 00:08:37,560
to make it more concrete because I think

00:08:33,899 --> 00:08:43,579
that's important but um but what about

00:08:37,560 --> 00:08:45,480
if t1 equals for all something something

00:08:43,579 --> 00:08:49,410
which is the case that we have here

00:08:45,480 --> 00:08:51,240
right for now I'll make it specific to

00:08:49,410 --> 00:08:54,930
functions it actually applies also to

00:08:51,240 --> 00:08:57,480
trade objects and the answer is what we

00:08:54,930 --> 00:09:02,699
do if this if the thing that has to be a

00:08:57,480 --> 00:09:04,079
subtype that's t1 has binders like this

00:09:02,699 --> 00:09:06,959
let's just say for all today right now

00:09:04,079 --> 00:09:11,300
we make a fresh variable inference

00:09:06,959 --> 00:09:11,300
variable the idea is it's valid for any

00:09:11,569 --> 00:09:16,019
it's valid for any lifetime or region

00:09:14,639 --> 00:09:19,110
today so let's make a variable we'll

00:09:16,019 --> 00:09:22,199
call it tick zero let's replace together

00:09:19,110 --> 00:09:25,620
with tick zero in the function type and

00:09:22,199 --> 00:09:27,990
then let's that's gonna yield us like

00:09:25,620 --> 00:09:31,050
yielding a type t1 prime and then let's

00:09:27,990 --> 00:09:34,050
relate t1 prime to teach him so to make

00:09:31,050 --> 00:09:37,199
it to come to our example we had for all

00:09:34,050 --> 00:09:40,920
of take a function and again you 32 we

00:09:37,199 --> 00:09:43,559
would we would sort of replace and get a

00:09:40,920 --> 00:09:52,050
type like this we replace the the today

00:09:43,559 --> 00:09:55,379
with a variable take 0 and why we do

00:09:52,050 --> 00:09:56,730
that as we say hey it was valid for all

00:09:55,379 --> 00:09:58,589
things so we're trying to find is there

00:09:56,730 --> 00:10:01,379
any value that we could give to today

00:09:58,589 --> 00:10:03,209
that would be would make it would make

00:10:01,379 --> 00:10:04,439
these types compatible right that's why

00:10:03,209 --> 00:10:05,850
it's an inference variable because it's

00:10:04,439 --> 00:10:08,059
like let's find a value that is

00:10:05,850 --> 00:10:12,600
compatible

00:10:08,059 --> 00:10:17,220
so in this case then t2 is just T 2

00:10:12,600 --> 00:10:19,319
doesn't have any or that let me know

00:10:17,220 --> 00:10:20,670
like you can imagine this is not exactly

00:10:19,319 --> 00:10:23,560
how the code works but you can imagine

00:10:20,670 --> 00:10:26,690
that there's

00:10:23,560 --> 00:10:26,690
[Music]

00:10:28,070 --> 00:10:33,670
how sure how to pose Equis we'll do it

00:10:32,570 --> 00:10:35,779
like this

00:10:33,670 --> 00:10:40,910
you can imagine there's some rule that

00:10:35,779 --> 00:10:42,589
says if you have a function type by

00:10:40,910 --> 00:10:46,579
itself without the for all's around it

00:10:42,589 --> 00:10:49,339
then you have to you have to require

00:10:46,579 --> 00:10:55,009
that first of all the arguments have to

00:10:49,339 --> 00:10:57,829
be subtypes and the return type have to

00:10:55,009 --> 00:10:59,000
be related more or less and you notice I

00:10:57,829 --> 00:11:01,940
swapped the orders here that's because

00:10:59,000 --> 00:11:03,529
of how functions work their so-called

00:11:01,940 --> 00:11:07,670
countries are not that important to this

00:11:03,529 --> 00:11:12,079
particular thing so that's how we get to

00:11:07,670 --> 00:11:13,279
our answer so that will get us so if we

00:11:12,079 --> 00:11:16,240
apply this algorithm to our original

00:11:13,279 --> 00:11:19,839
question we'll basically wind up with

00:11:16,240 --> 00:11:19,839
having created

00:11:20,030 --> 00:11:29,340
applied to our original problem we have

00:11:23,520 --> 00:11:30,270
created a will say the result will be

00:11:29,340 --> 00:11:36,150
like yes

00:11:30,270 --> 00:11:38,340
if tick zero out lives or our lives 50

00:11:36,150 --> 00:11:44,760
right where tip zero is some freshman

00:11:38,340 --> 00:11:47,190
some fresh infants variable and so sort

00:11:44,760 --> 00:11:50,910
of the result I said that it's the

00:11:47,190 --> 00:11:53,700
result is like what did I say that here

00:11:50,910 --> 00:11:55,440
that is yes with region constraints it

00:11:53,700 --> 00:11:57,420
also may make fresh variables as he

00:11:55,440 --> 00:12:01,440
feels so it's kind of like plus fresh

00:11:57,420 --> 00:12:02,940
variables and if this is the only use of

00:12:01,440 --> 00:12:04,770
tick zero like when we're gonna come

00:12:02,940 --> 00:12:06,480
back later and do our inference process

00:12:04,770 --> 00:12:10,440
we have to find a value for tick zero

00:12:06,480 --> 00:12:12,570
that works in this case of one answer

00:12:10,440 --> 00:12:14,130
might be to be that's like whatever tick

00:12:12,570 --> 00:12:15,510
B turns out to be take zero can there's

00:12:14,130 --> 00:12:17,550
no other constraints on it so it's not a

00:12:15,510 --> 00:12:20,640
hard problem to solve this is only used

00:12:17,550 --> 00:12:24,690
once um okay

00:12:20,640 --> 00:12:27,510
that that's sort of the easy part

00:12:24,690 --> 00:12:29,640
but let's look at the other question

00:12:27,510 --> 00:12:33,110
this is where the universe is stuff kind

00:12:29,640 --> 00:12:33,110
of comes in so if we had

00:12:39,459 --> 00:12:45,100
if we move the for all to the other side

00:12:42,070 --> 00:12:47,779
so now we're saying we have some

00:12:45,100 --> 00:12:50,720
function without a for all then we're

00:12:47,779 --> 00:12:53,029
relating it to this the super type has a

00:12:50,720 --> 00:12:55,850
for all here we want to you probably

00:12:53,029 --> 00:12:58,510
want to error because not necessarily

00:12:55,850 --> 00:13:01,880
actually will see nothing out but

00:12:58,510 --> 00:13:04,339
because whatever sort of whatever today

00:13:01,880 --> 00:13:07,089
whatever value TK is that's going to be

00:13:04,339 --> 00:13:09,500
a function that demands one specific

00:13:07,089 --> 00:13:11,480
lifetime in the end of the day and we're

00:13:09,500 --> 00:13:14,810
wanting to use it as if it can accept

00:13:11,480 --> 00:13:18,579
any lifetime right and that's not

00:13:14,810 --> 00:13:21,649
necessarily valid and the way we do this

00:13:18,579 --> 00:13:23,779
this is where the is but we don't

00:13:21,649 --> 00:13:26,120
before we replaced tik be where we

00:13:23,779 --> 00:13:27,709
replace the bound variable tonight with

00:13:26,120 --> 00:13:28,940
the inference variable but that doesn't

00:13:27,709 --> 00:13:31,550
make sense here because that would give

00:13:28,940 --> 00:13:33,320
us the same sort of thing everything is

00:13:31,550 --> 00:13:35,600
there any value of tik beat it works and

00:13:33,320 --> 00:13:37,970
what we want to show is more like does

00:13:35,600 --> 00:13:40,160
this work for any value look technique

00:13:37,970 --> 00:13:41,480
it could be anything not is there a some

00:13:40,160 --> 00:13:44,449
specific value but does it work for all

00:13:41,480 --> 00:13:47,230
of them so this is essentially 4l4 since

00:13:44,449 --> 00:13:50,480
there exists is the question right and

00:13:47,230 --> 00:13:54,490
the way we do that is we introduce the

00:13:50,480 --> 00:13:56,540
idea of a place holder and universe is a

00:13:54,490 --> 00:13:58,670
place holder is basically like a

00:13:56,540 --> 00:14:00,440
symbolic region where we say we don't

00:13:58,670 --> 00:14:01,730
really know exactly what this is we know

00:14:00,440 --> 00:14:04,459
that it's different from all the other

00:14:01,730 --> 00:14:06,860
things and if we can prove that it's

00:14:04,459 --> 00:14:08,510
true for that place holder then you

00:14:06,860 --> 00:14:10,240
could sort of swap in any region and it

00:14:08,510 --> 00:14:12,500
would have to be truth in that too um

00:14:10,240 --> 00:14:16,399
it's like I'm maximally conservative

00:14:12,500 --> 00:14:23,209
right and the idea of universes is that

00:14:16,399 --> 00:14:26,180
we say okay there's some set of names

00:14:23,209 --> 00:14:29,769
that are kind of global that like if you

00:14:26,180 --> 00:14:31,880
think of lifetime sighs hmm

00:14:29,769 --> 00:14:35,000
what's the right intuition to go for

00:14:31,880 --> 00:14:36,290
here well if we use them as polonius

00:14:35,000 --> 00:14:39,329
than our lifetime is the set of loans

00:14:36,290 --> 00:14:40,949
right and

00:14:39,329 --> 00:14:42,600
those Nate there's some set of loans

00:14:40,949 --> 00:14:44,759
that are alone is like a specific

00:14:42,600 --> 00:14:46,559
ampersand expression in the program and

00:14:44,759 --> 00:14:48,209
those are kind of global names that any

00:14:46,559 --> 00:14:49,739
region could contain but this

00:14:48,209 --> 00:14:52,980
placeholder name this is like a special

00:14:49,739 --> 00:14:56,489
loan that's different from all the loans

00:14:52,980 --> 00:14:57,779
we know so far and so when we make one

00:14:56,489 --> 00:14:59,910
of those special loans we do it by

00:14:57,779 --> 00:15:02,160
creating we put we say that all the

00:14:59,910 --> 00:15:03,779
names of loans are in universes and a

00:15:02,160 --> 00:15:05,220
variable is associated with a universe

00:15:03,779 --> 00:15:07,049
and that basically describes the set of

00:15:05,220 --> 00:15:09,269
loans that it is allowed to contain and

00:15:07,049 --> 00:15:11,579
so you start out with this this is the

00:15:09,269 --> 00:15:15,480
root University or zero that contains

00:15:11,579 --> 00:15:18,480
all the global names that we know I just

00:15:15,480 --> 00:15:21,360
do by the way I'm switching from Mac to

00:15:18,480 --> 00:15:23,369
Windows it's fine except for the fact

00:15:21,360 --> 00:15:25,529
that the scroll bar goes like the old

00:15:23,369 --> 00:15:28,170
way before Mac decided to change it and

00:15:25,529 --> 00:15:33,209
that's really annoying I haven't gotten

00:15:28,170 --> 00:15:36,899
used to that yet the and the new

00:15:33,209 --> 00:15:40,290
universe is like adds some let's say in

00:15:36,899 --> 00:15:41,910
this case just one add one fresh name to

00:15:40,290 --> 00:15:44,369
you zero and so now if something is in

00:15:41,910 --> 00:15:46,259
you one it can name all the things from

00:15:44,369 --> 00:15:48,779
use euro plus it can name this extra

00:15:46,259 --> 00:15:50,579
thing but there was not nameable before

00:15:48,779 --> 00:15:52,559
it and these are a tree so that you too

00:15:50,579 --> 00:15:57,239
can extend you one with one more name

00:15:52,559 --> 00:15:59,249
but maybe you three is a sibling of you

00:15:57,239 --> 00:16:01,350
one and so it does not contain the name

00:15:59,249 --> 00:16:02,910
of you one nor the name of you two but

00:16:01,350 --> 00:16:11,970
it has some fresh name of its own which

00:16:02,910 --> 00:16:13,049
they can't name good so far okay so so

00:16:11,970 --> 00:16:16,290
what we can do now that we have this

00:16:13,049 --> 00:16:19,410
idea is when we have a for all on a

00:16:16,290 --> 00:16:22,199
super-tight side we can replace them you

00:16:19,410 --> 00:16:28,829
can create a new universe create a fresh

00:16:22,199 --> 00:16:33,899
universe that is a child or that extends

00:16:28,829 --> 00:16:35,369
the current the universe so with this we

00:16:33,899 --> 00:16:38,369
have some notion of the current universe

00:16:35,369 --> 00:16:43,040
you and we make a fresh universe you

00:16:38,369 --> 00:16:46,639
prime this has some

00:16:43,040 --> 00:16:52,420
add some placeholder names conceptually

00:16:46,639 --> 00:16:59,930
at least into you crime for each region

00:16:52,420 --> 00:17:03,649
and now I can't type and now we can

00:16:59,930 --> 00:17:06,679
replace the four tick be with these

00:17:03,649 --> 00:17:08,419
placeholders so where we had like four

00:17:06,679 --> 00:17:19,669
take the function in the absence of

00:17:08,419 --> 00:17:24,500
these 32 now have I'm gonna use this

00:17:19,669 --> 00:17:26,689
same notation we now have a function

00:17:24,500 --> 00:17:28,910
that doesn't have any binders but has

00:17:26,689 --> 00:17:34,580
this sort of placeholder region that's

00:17:28,910 --> 00:17:38,450
gentle um and we want to relate then we

00:17:34,580 --> 00:17:40,700
sort of relate t1 and t2 as before so

00:17:38,450 --> 00:17:46,190
where we had so if we go through our

00:17:40,700 --> 00:17:48,620
step we would wind up saying we were

00:17:46,190 --> 00:17:57,500
checking this in let's say in university

00:17:48,620 --> 00:17:59,090
room and now we're checking now we're

00:17:57,500 --> 00:18:04,640
checking that in universe one which

00:17:59,090 --> 00:18:14,000
contains this placeholder and god gives

00:18:04,640 --> 00:18:16,610
us this result which says basically that

00:18:14,000 --> 00:18:22,070
is this is true so long oops I have this

00:18:16,610 --> 00:18:25,390
backward its contravariant um let me do

00:18:22,070 --> 00:18:28,640
it one more step this will be true if

00:18:25,390 --> 00:18:30,770
the argument types relate and they flip

00:18:28,640 --> 00:18:32,570
orders and that gives rise to this

00:18:30,770 --> 00:18:36,530
region constraint right which basically

00:18:32,570 --> 00:18:39,230
says take a whatever it is has to

00:18:36,530 --> 00:18:41,630
outlive every region like some reason

00:18:39,230 --> 00:18:47,919
that we don't know which you can't

00:18:41,630 --> 00:18:47,919
really do is we don't or I can't do

00:18:49,290 --> 00:18:53,490
oh I don't know if you had some sort of

00:18:51,990 --> 00:18:56,640
empty region that's never valid or

00:18:53,490 --> 00:18:59,130
something you could do it um but this is

00:18:56,640 --> 00:19:02,040
the point like if there's no region that

00:18:59,130 --> 00:19:06,900
is valid at some point which is known to

00:19:02,040 --> 00:19:11,070
be outlived by every other region so

00:19:06,900 --> 00:19:15,030
this is probably an error or at least

00:19:11,070 --> 00:19:18,540
it's an error let's say if the function

00:19:15,030 --> 00:19:21,720
is ever called because the reason that

00:19:18,540 --> 00:19:23,070
would be required is that like maybe you

00:19:21,720 --> 00:19:25,680
could infer that it's a function that's

00:19:23,070 --> 00:19:28,710
well typed as long as it's never cold or

00:19:25,680 --> 00:19:32,670
something but it's not I don't think we

00:19:28,710 --> 00:19:37,620
even support that okay that's the kind

00:19:32,670 --> 00:19:41,040
of theoretical side of this so you can

00:19:37,620 --> 00:19:43,470
you can view this constraint you could

00:19:41,040 --> 00:19:48,720
sort of take it out of the universes and

00:19:43,470 --> 00:19:50,210
go back to before all notation and you

00:19:48,720 --> 00:19:53,610
could sort of see it as saying this

00:19:50,210 --> 00:19:56,220
right and that's sort of what I just how

00:19:53,610 --> 00:19:57,900
I described it in the blog post but in

00:19:56,220 --> 00:20:01,100
the way that the compiler thinks about

00:19:57,900 --> 00:20:03,210
it this is actually much closer so I

00:20:01,100 --> 00:20:06,150
maybe will type a little into that no

00:20:03,210 --> 00:20:09,050
but we we really tracked the universe's

00:20:06,150 --> 00:20:12,150
the way I talked about them and we um

00:20:09,050 --> 00:20:13,410
kind of don't ever bother to decode

00:20:12,150 --> 00:20:17,910
these constraints back to the more

00:20:13,410 --> 00:20:19,890
structured tree like for him so another

00:20:17,910 --> 00:20:22,590
thing to note that's important is I

00:20:19,890 --> 00:20:26,640
described just like shifting to the

00:20:22,590 --> 00:20:31,830
implementation side of this I described

00:20:26,640 --> 00:20:36,420
the universe tree as a tree and that and

00:20:31,830 --> 00:20:40,230
it is however in the compiler we only

00:20:36,420 --> 00:20:42,810
keep a single integer so what we do is

00:20:40,230 --> 00:20:44,730
we kind of rely on the fact that we will

00:20:42,810 --> 00:20:46,470
never fall we will never ask cousins to

00:20:44,730 --> 00:20:48,870
interact with one another the only way

00:20:46,470 --> 00:20:52,530
for things to interact is by sharing an

00:20:48,870 --> 00:20:54,660
inference variable Oh suffice to say

00:20:52,530 --> 00:20:58,410
it's enough to keep just an integer so

00:20:54,660 --> 00:21:00,270
you just remember like the index and if

00:20:58,410 --> 00:21:02,490
the index is greater and you know it's a

00:21:00,270 --> 00:21:03,389
child and if it's not it's not let me

00:21:02,490 --> 00:21:05,220
you try to make that a little more

00:21:03,389 --> 00:21:08,519
concrete so I didn't show you this other

00:21:05,220 --> 00:21:12,869
case which is like this is maybe a good

00:21:08,519 --> 00:21:15,480
case to talk about before we move on but

00:21:12,869 --> 00:21:17,009
if you have four hours on both sides we

00:21:15,480 --> 00:21:20,100
would like this to be true obviously

00:21:17,009 --> 00:21:22,080
this is the same type so what happens is

00:21:20,100 --> 00:21:24,450
you do a combination of these things but

00:21:22,080 --> 00:21:26,940
you first process the super tape this

00:21:24,450 --> 00:21:30,450
would be important in a second so we

00:21:26,940 --> 00:21:33,179
kind of started out with this like in

00:21:30,450 --> 00:21:44,519
the universe zero and we would first

00:21:33,179 --> 00:21:45,960
process the super type and say okay you

00:21:44,519 --> 00:21:48,929
know we're placed to be with a

00:21:45,960 --> 00:21:55,919
placeholder and then we process then we

00:21:48,929 --> 00:21:58,230
replace the left-hand side with an

00:21:55,919 --> 00:22:03,230
infant's variable but this is the

00:21:58,230 --> 00:22:06,059
important part the each infant variable

00:22:03,230 --> 00:22:11,059
has a universe and so the infant's

00:22:06,059 --> 00:22:13,619
variable tick zero is in universe U one

00:22:11,059 --> 00:22:14,940
because it's that universe is taken

00:22:13,619 --> 00:22:16,889
basically from what is the current

00:22:14,940 --> 00:22:20,100
universe at the point where were of this

00:22:16,889 --> 00:22:21,659
thing were processing and idea is the

00:22:20,100 --> 00:22:23,070
universe that it's in basically says

00:22:21,659 --> 00:22:27,029
what are the names that it can be

00:22:23,070 --> 00:22:30,539
inferred to so here because it's a new

00:22:27,029 --> 00:22:33,419
one it's allowed to take the value of

00:22:30,539 --> 00:22:35,340
the placeholder right so this will wind

00:22:33,419 --> 00:22:35,909
up with it with the same constraint we

00:22:35,340 --> 00:22:39,629
saw before

00:22:35,909 --> 00:22:43,320
only instead of you today we got take

00:22:39,629 --> 00:22:46,919
zero so we'll get this constraint just

00:22:43,320 --> 00:22:50,999
like we had before up here but this is

00:22:46,919 --> 00:22:53,700
not an error no because we can infer to

00:22:50,999 --> 00:23:01,440
zero to be two things and that's just

00:22:53,700 --> 00:23:05,940
fine okay I have a quick clarifying

00:23:01,440 --> 00:23:09,029
question aren't there or the what you're

00:23:05,940 --> 00:23:10,879
calling placeholders dabangg ones can

00:23:09,029 --> 00:23:13,019
there be more than one placeholder

00:23:10,879 --> 00:23:15,990
associated with a given universe or is

00:23:13,019 --> 00:23:16,260
that a one-to-one relationship there can

00:23:15,990 --> 00:23:22,650
be

00:23:16,260 --> 00:23:25,200
in rust because the order basically you

00:23:22,650 --> 00:23:28,560
can have more than one region bound in a

00:23:25,200 --> 00:23:31,140
function signature hmm so like it's

00:23:28,560 --> 00:23:33,450
actually a sole point of an interesting

00:23:31,140 --> 00:23:36,360
point like this functions including rust

00:23:33,450 --> 00:23:42,360
which would be written more elaborately

00:23:36,360 --> 00:23:44,970
like so is it's not important whether

00:23:42,360 --> 00:23:48,180
ticka ticka appeared first in this for

00:23:44,970 --> 00:23:50,310
all and so we we model that by having

00:23:48,180 --> 00:23:55,770
like we make one fresh universe with two

00:23:50,310 --> 00:23:57,810
names in it uh and that's okay but if

00:23:55,770 --> 00:23:59,070
you had a system like this is like a

00:23:57,810 --> 00:24:00,990
subtle difference between some of the

00:23:59,070 --> 00:24:04,200
formal work because often these are

00:24:00,990 --> 00:24:06,060
modeled as like if you go to a system

00:24:04,200 --> 00:24:08,670
ask for whatever this is like our

00:24:06,060 --> 00:24:10,290
function from types and then the

00:24:08,670 --> 00:24:12,180
ordering is think if you can partially

00:24:10,290 --> 00:24:14,060
apply it you can say I just say what

00:24:12,180 --> 00:24:16,710
today is that I don't stay with to be is

00:24:14,060 --> 00:24:20,910
it kind of matters but that's all not

00:24:16,710 --> 00:24:25,830
really relevant anymore so yeah you can

00:24:20,910 --> 00:24:30,450
have more than one and that's okay um so

00:24:25,830 --> 00:24:31,980
okay well I guess I'll look a little bit

00:24:30,450 --> 00:24:39,120
at the code so I'm gonna do now is share

00:24:31,980 --> 00:24:47,810
my there's something different I can

00:24:39,120 --> 00:24:50,100
figure out how I guess I will new

00:24:47,810 --> 00:25:01,080
know how they I should stop this share

00:24:50,100 --> 00:25:04,650
first and do a new share okay did you

00:25:01,080 --> 00:25:11,510
all see this I want it bigger

00:25:04,650 --> 00:25:15,570
is it nothing stupid news why

00:25:11,510 --> 00:25:17,940
okay we'll settle for that and you'll

00:25:15,570 --> 00:25:20,950
see that I don't know how to make the

00:25:17,940 --> 00:25:24,670
font bigger it's big enough

00:25:20,950 --> 00:25:26,050
okay good is I pressing the keys I would

00:25:24,670 --> 00:25:34,960
expect to make the font bigger did not

00:25:26,050 --> 00:25:36,280
make the font um here let me get a what

00:25:34,960 --> 00:25:41,680
would be a good one of my workspaces

00:25:36,280 --> 00:25:43,860
here this one will do so let me walk a

00:25:41,680 --> 00:25:46,210
little bit through the code so we got

00:25:43,860 --> 00:25:54,820
and we'll try to map these concepts

00:25:46,210 --> 00:25:56,500
first of all the regions in in rusty are

00:25:54,820 --> 00:25:58,810
represented the lifetimes regions

00:25:56,500 --> 00:26:06,760
represented by this region type right

00:25:58,810 --> 00:26:07,960
which is which is just a so region is

00:26:06,760 --> 00:26:09,940
just a region kind

00:26:07,960 --> 00:26:12,460
let's put into an interning pool like

00:26:09,940 --> 00:26:15,370
memory allocated arena and you can see

00:26:12,460 --> 00:26:17,650
it has various variants the one I wanted

00:26:15,370 --> 00:26:20,260
to call your attention to is is this

00:26:17,650 --> 00:26:24,010
placeholder here so if you have a

00:26:20,260 --> 00:26:28,600
placeholder region this is what it would

00:26:24,010 --> 00:26:32,920
be represented as um and what is

00:26:28,600 --> 00:26:37,960
happening now okay so if I jump

00:26:32,920 --> 00:26:40,420
what is placeholder region yeah taking

00:26:37,960 --> 00:26:46,540
me some time to get used to this you can

00:26:40,420 --> 00:26:48,070
anticipate this problem by good it's

00:26:46,540 --> 00:26:54,250
okay it forces you to operate at our

00:26:48,070 --> 00:26:56,590
speed yeah okay I don't know what's

00:26:54,250 --> 00:26:58,030
happening now end of your team some

00:26:56,590 --> 00:27:03,310
reason I can't seem to issue commands to

00:26:58,030 --> 00:27:05,260
you mess why okay we're gonna do a

00:27:03,310 --> 00:27:11,280
slightly different way you stop this

00:27:05,260 --> 00:27:11,280
sharing and I'm going to share instead

00:27:15,180 --> 00:27:26,950
this you should see my web browser now

00:27:17,920 --> 00:27:36,430
right we'll do it like this so do you

00:27:26,950 --> 00:27:39,820
see everyone sees I hope right so a

00:27:36,430 --> 00:27:40,990
placeholder region this is just remember

00:27:39,820 --> 00:27:44,980
what file this is in this is the

00:27:40,990 --> 00:27:51,970
annoying thing but it's it's basically

00:27:44,980 --> 00:27:55,870
just a pair of there we go it's this

00:27:51,970 --> 00:27:59,230
placeholder type which somewhere is

00:27:55,870 --> 00:28:02,710
defined that there it is which has the

00:27:59,230 --> 00:28:04,270
universe index and the name so air into

00:28:02,710 --> 00:28:06,880
your question of can there be more than

00:28:04,270 --> 00:28:08,050
one thing this is basically why you

00:28:06,880 --> 00:28:13,510
might have one universe in you would

00:28:08,050 --> 00:28:17,410
have distinct names um so that's how our

00:28:13,510 --> 00:28:22,540
region is represented and then actually

00:28:17,410 --> 00:28:26,230
region inference we do inference let's

00:28:22,540 --> 00:28:29,740
see he's broken up into a couple of

00:28:26,230 --> 00:28:32,710
different things I'm just going to jump

00:28:29,740 --> 00:28:34,270
to some file but the relevant code so if

00:28:32,710 --> 00:28:38,110
you go into the infer directory this is

00:28:34,270 --> 00:28:40,240
our hole type inference set of code

00:28:38,110 --> 00:28:41,770
right and the kind the bit of code I'm

00:28:40,240 --> 00:28:45,400
most interested in right now is this

00:28:41,770 --> 00:28:49,510
region constraints module and what that

00:28:45,400 --> 00:28:52,210
contains is basically the code to

00:28:49,510 --> 00:28:55,650
collect these constraints so what I was

00:28:52,210 --> 00:28:59,490
writing in the document I wrote like

00:28:55,650 --> 00:29:01,409
like this take

00:28:59,490 --> 00:29:06,720
take one all that stuff this is how we

00:29:01,409 --> 00:29:08,250
represent those MSC and it's also where

00:29:06,720 --> 00:29:10,230
we track the set of region variables so

00:29:08,250 --> 00:29:11,940
it's this big struct it's got a lot of

00:29:10,230 --> 00:29:15,149
stuff in it that's not too relevant here

00:29:11,940 --> 00:29:17,270
but the most important thing is for each

00:29:15,149 --> 00:29:21,149
region variable we have some information

00:29:17,270 --> 00:29:23,730
this maps from the FID which is the

00:29:21,149 --> 00:29:26,039
variable ID to the information about the

00:29:23,730 --> 00:29:27,809
variable and then there's a struct

00:29:26,039 --> 00:29:29,010
called data which has like the set of

00:29:27,809 --> 00:29:36,260
constraints and I'll get to that in a

00:29:29,010 --> 00:29:39,140
second so a region variable info

00:29:36,260 --> 00:29:41,090
is really not a lot of stuff it's

00:29:39,140 --> 00:29:42,920
basically the origin this is for

00:29:41,090 --> 00:29:44,540
Diagnostics this is like why did I make

00:29:42,920 --> 00:29:47,630
this inference variable it doesn't

00:29:44,540 --> 00:29:49,880
affect the type system rules in any way

00:29:47,630 --> 00:29:55,070
and then the other one is the universe

00:29:49,880 --> 00:29:58,070
that we created the variable in and so

00:29:55,070 --> 00:29:59,270
when we make a new region variable you

00:29:58,070 --> 00:30:02,710
just give those two pieces of

00:29:59,270 --> 00:30:02,710
information and it gets stored

00:30:04,970 --> 00:30:13,450
region constraint the regions data okay

00:30:13,870 --> 00:30:21,049
where is that there so this is a big

00:30:17,960 --> 00:30:24,860
struct I'll which is very important but

00:30:21,049 --> 00:30:27,530
the important part is this field here so

00:30:24,860 --> 00:30:29,840
this is it's a b-tree map only because

00:30:27,530 --> 00:30:32,120
we want to detect duplicates but it says

00:30:29,840 --> 00:30:34,640
as a constraint and then the key the

00:30:32,120 --> 00:30:36,549
value is why did we create this

00:30:34,640 --> 00:30:40,659
constraint that's again for Diagnostics

00:30:36,549 --> 00:30:40,659
so if we look at this constraint

00:30:40,790 --> 00:30:45,130
this is one of these ticket out lipstick

00:30:42,440 --> 00:30:48,980
be the four variants are all the same

00:30:45,130 --> 00:30:50,480
the only difference between them is in

00:30:48,980 --> 00:30:52,070
which case it this is to infants

00:30:50,480 --> 00:30:53,210
variables this is an infant's variable

00:30:52,070 --> 00:30:55,520
and something is not an infant's

00:30:53,210 --> 00:30:57,770
variable in both directions or two

00:30:55,520 --> 00:30:59,150
things that are not in this purple which

00:30:57,770 --> 00:31:03,740
happens to be convenient

00:30:59,150 --> 00:31:05,929
um so right so you see what I meant

00:31:03,740 --> 00:31:07,970
about we don't track the four alls and

00:31:05,929 --> 00:31:09,530
all that stuff we just track which were

00:31:07,970 --> 00:31:11,510
the two variables and then we know what

00:31:09,530 --> 00:31:12,890
universe the inference rule was in and

00:31:11,510 --> 00:31:14,179
we know what universe the placeholder is

00:31:12,890 --> 00:31:17,510
in and you can kind of figure out all we

00:31:14,179 --> 00:31:20,630
have to know um and the way we do

00:31:17,510 --> 00:31:22,280
inference for now I'm going to ignore

00:31:20,630 --> 00:31:23,809
nlll for a second because it's not

00:31:22,280 --> 00:31:26,690
actually relevant to this it's sort of

00:31:23,809 --> 00:31:31,010
easier and not the lexical so this is

00:31:26,690 --> 00:31:34,190
the old region solver but nll has a

00:31:31,010 --> 00:31:37,370
similar character for this purpose the

00:31:34,190 --> 00:31:39,200
way we do region inference is that's all

00:31:37,370 --> 00:31:43,340
in this module called lexical region

00:31:39,200 --> 00:31:49,090
result and it's basically a really

00:31:43,340 --> 00:31:53,090
simple process in which it's right here

00:31:49,090 --> 00:31:58,070
infer variable values and what it does

00:31:53,090 --> 00:32:00,200
is this all in this function expansion

00:31:58,070 --> 00:32:02,809
the idea is that for each region

00:32:00,200 --> 00:32:04,400
variable we start out with what its

00:32:02,809 --> 00:32:06,260
value is and we start out I think with

00:32:04,400 --> 00:32:10,790
empty meaning that it's not usable

00:32:06,260 --> 00:32:12,890
anywhere and then we keep growing it in

00:32:10,790 --> 00:32:14,360
response to constraints so if you have a

00:32:12,890 --> 00:32:17,059
constraint that says like the variable

00:32:14,360 --> 00:32:19,429
must outlive tick static then we will

00:32:17,059 --> 00:32:20,510
say okay it must be text attic but

00:32:19,429 --> 00:32:21,590
that's a kind of an extreme point

00:32:20,510 --> 00:32:23,690
because you can never get bigger than

00:32:21,590 --> 00:32:25,429
that but if we say the variable must

00:32:23,690 --> 00:32:28,130
outlive so this is lexical region

00:32:25,429 --> 00:32:31,520
resolves so it would it might be like it

00:32:28,130 --> 00:32:32,929
has to be as big as this statement that

00:32:31,520 --> 00:32:34,429
this part of the code right and then we

00:32:32,929 --> 00:32:35,660
would grow into that statement and then

00:32:34,429 --> 00:32:38,210
if it has to outlive the neighboring

00:32:35,660 --> 00:32:39,950
statement then it has to get big enough

00:32:38,210 --> 00:32:42,530
to encompass its current value which was

00:32:39,950 --> 00:32:44,000
saving a and the neighboring statement B

00:32:42,530 --> 00:32:46,250
and the only way for it to do that is to

00:32:44,000 --> 00:32:48,230
jump up to the whole enclosing block so

00:32:46,250 --> 00:32:48,650
it will become the closing block and so

00:32:48,230 --> 00:32:51,590
forth

00:32:48,650 --> 00:32:52,790
um that's pretty easy but that's all

00:32:51,590 --> 00:32:54,380
assuming you're kind of in the root

00:32:52,790 --> 00:32:56,300
universe

00:32:54,380 --> 00:32:58,280
so what you basically do now as we

00:32:56,300 --> 00:33:00,890
extend for well what happens if it has

00:32:58,280 --> 00:33:03,070
to outlive a placeholder right so if it

00:33:00,890 --> 00:33:07,880
has to outlive all the regions um

00:33:03,070 --> 00:33:09,830
and so here's the expansion code it does

00:33:07,880 --> 00:33:11,240
this iterate until fixed point so this

00:33:09,830 --> 00:33:14,930
is just going over and over again and

00:33:11,240 --> 00:33:16,790
recursively growing things until we meet

00:33:14,930 --> 00:33:21,230
you on fix point where we don't where

00:33:16,790 --> 00:33:25,070
all the things are satisfied and then we

00:33:21,230 --> 00:33:27,710
see so hmm I should point out this was

00:33:25,070 --> 00:33:30,290
written in the old days so you see how

00:33:27,710 --> 00:33:32,120
it says sub u I've been showing the

00:33:30,290 --> 00:33:34,370
constraints as to K :

00:33:32,120 --> 00:33:35,960
tick B meaning today outlives to P these

00:33:34,370 --> 00:33:37,700
constraints are actually stored in took

00:33:35,960 --> 00:33:39,650
me less than or equal to today for him

00:33:37,700 --> 00:33:41,960
so they're the same constraint but

00:33:39,650 --> 00:33:46,430
reversed because that was how my phone

00:33:41,960 --> 00:33:48,290
was more natural of the time uh but so

00:33:46,430 --> 00:33:51,560
yeah so this is that requires a bit of a

00:33:48,290 --> 00:33:53,930
mental shift but this is saying like if

00:33:51,560 --> 00:33:56,960
you have some region variable which

00:33:53,930 --> 00:33:59,120
outlives some specific region this is

00:33:56,960 --> 00:34:01,760
like a blah that's gonna call this in

00:33:59,120 --> 00:34:03,920
function expand node so essentially in

00:34:01,760 --> 00:34:07,700
this what we're doing here is we're

00:34:03,920 --> 00:34:10,550
trying to get some specific region and

00:34:07,700 --> 00:34:13,669
sorry some variable and some specific

00:34:10,550 --> 00:34:15,290
region it has to be bigger than and

00:34:13,669 --> 00:34:16,760
we're gonna pass that to expand node

00:34:15,290 --> 00:34:19,190
which is going to make the value of that

00:34:16,760 --> 00:34:21,919
variable be big enough to enclose its

00:34:19,190 --> 00:34:24,440
current value plus this region now we're

00:34:21,919 --> 00:34:27,500
going to do that iteratively um I forget

00:34:24,440 --> 00:34:30,110
what this other stuff is but not

00:34:27,500 --> 00:34:33,710
important so here's the function expand

00:34:30,110 --> 00:34:36,789
node and

00:34:33,710 --> 00:34:36,789
[Music]

00:34:37,659 --> 00:34:41,169
takes the region the variable that has

00:34:39,789 --> 00:34:44,649
to be bigger than this region when it's

00:34:41,169 --> 00:34:47,679
done and some data will figure out that

00:34:44,649 --> 00:34:54,549
is I think that's like some this is like

00:34:47,679 --> 00:34:56,559
some some other information okay yeah so

00:34:54,549 --> 00:34:58,240
this is I think this basically contains

00:34:56,559 --> 00:35:02,440
the current values of all the variables

00:34:58,240 --> 00:35:04,720
if I'm not mistaken uh ignore the Givens

00:35:02,440 --> 00:35:09,210
please like embarrass that that coastal

00:35:04,720 --> 00:35:12,280
they come back to it it's not real so

00:35:09,210 --> 00:35:14,770
this being the Gibbons don't don't look

00:35:12,280 --> 00:35:21,609
there don't look where my mouth is so

00:35:14,770 --> 00:35:27,339
the so what happens we look well B what

00:35:21,609 --> 00:35:29,200
is B data actually that's oh I see so B

00:35:27,339 --> 00:35:31,030
data is actually the value for this

00:35:29,200 --> 00:35:32,289
exact variable that's what it is it's

00:35:31,030 --> 00:35:33,549
not the set of values for all variables

00:35:32,289 --> 00:35:35,680
it's the value for this particular

00:35:33,549 --> 00:35:39,480
variable so we look at what is the

00:35:35,680 --> 00:35:41,740
current value and either it's an error

00:35:39,480 --> 00:35:42,940
meaning that we already found that for

00:35:41,740 --> 00:35:44,950
some reason there was an error in that

00:35:42,940 --> 00:35:46,720
case we can just ignore it or it has

00:35:44,950 --> 00:35:51,640
some value now which is this current

00:35:46,720 --> 00:35:53,380
region right and then we can check this

00:35:51,640 --> 00:35:56,440
just checks is the current region

00:35:53,380 --> 00:35:58,809
already the same as the red as the

00:35:56,440 --> 00:36:00,190
region it has to outlive then Leslie

00:35:58,809 --> 00:36:03,700
that's like saying today all this to

00:36:00,190 --> 00:36:05,680
Gay's it's mine to Noah that's a

00:36:03,700 --> 00:36:08,619
performance optimization otherwise we

00:36:05,680 --> 00:36:11,770
find soul of concrete region says okay

00:36:08,619 --> 00:36:13,569
we got two exact Scopes in the lexical

00:36:11,770 --> 00:36:14,859
system let's find their least upper

00:36:13,569 --> 00:36:17,589
bound let's find some scope that

00:36:14,859 --> 00:36:19,329
encloses both of them um and if that's

00:36:17,589 --> 00:36:21,549
the same as the value we already have

00:36:19,329 --> 00:36:24,279
then we're done because we didn't need

00:36:21,549 --> 00:36:28,000
to grow we already included the new

00:36:24,279 --> 00:36:29,349
value we have to include otherwise and

00:36:28,000 --> 00:36:34,869
here because here comes the placeholder

00:36:29,349 --> 00:36:40,049
code um otherwise let's look at what let

00:36:34,869 --> 00:36:42,650
universe this variable was declared in

00:36:40,049 --> 00:36:45,290
and let's look

00:36:42,650 --> 00:36:49,100
if if the value that it has to take on

00:36:45,290 --> 00:36:51,140
is a placeholder then we check if that

00:36:49,100 --> 00:36:55,670
placeholder is in scope for the universe

00:36:51,140 --> 00:36:57,710
and if not we make it beat ecstatic when

00:36:55,670 --> 00:36:59,150
we take this back now to the to the

00:36:57,710 --> 00:37:02,900
paper drop box paper and I try to

00:36:59,150 --> 00:37:07,400
explain that logic um so if we come back

00:37:02,900 --> 00:37:10,410
to this case actually that let me give a

00:37:07,400 --> 00:37:13,100
different case which was the case

00:37:10,410 --> 00:37:20,750
[Music]

00:37:13,100 --> 00:37:28,240
well yeah this first case so this is the

00:37:20,750 --> 00:37:30,500
case where know which case do I want

00:37:28,240 --> 00:37:34,270
neither of these cases none of these

00:37:30,500 --> 00:37:34,270
cases actually fit what's happening here

00:37:35,340 --> 00:37:42,130
so right I think I want there were

00:37:40,080 --> 00:37:48,940
slightly different kids than what we

00:37:42,130 --> 00:37:50,440
have because it would okay right I want

00:37:48,940 --> 00:38:10,780
I want a different case let's do this

00:37:50,440 --> 00:38:12,610
case okay so we always looked at

00:38:10,780 --> 00:38:15,640
parameter types before but I think the

00:38:12,610 --> 00:38:19,720
case that one is actually will rise more

00:38:15,640 --> 00:38:21,250
easily with return types so if you work

00:38:19,720 --> 00:38:24,810
this through the algorithm that we said

00:38:21,250 --> 00:38:24,810
we're going to replace

00:38:28,970 --> 00:38:33,539
we're gonna replace though so on the

00:38:31,619 --> 00:38:35,309
left-hand side we have I'm writing tix

00:38:33,539 --> 00:38:36,539
ero here instead of Takei I'm just

00:38:35,309 --> 00:38:38,910
saying there's some inference variable

00:38:36,539 --> 00:38:42,479
that we've created in the past and it's

00:38:38,910 --> 00:38:43,920
part of this trick so we don't really

00:38:42,479 --> 00:38:45,450
know what it represents yet that's

00:38:43,920 --> 00:38:46,710
really what the today's were before but

00:38:45,450 --> 00:38:53,759
I thought maybe with the clearer this

00:38:46,710 --> 00:38:56,519
way and so we're gonna replace we're

00:38:53,759 --> 00:38:58,769
gonna replace the placeholder with a

00:38:56,519 --> 00:39:01,170
fresh universe we're gonna replace the

00:38:58,769 --> 00:39:03,420
boundary genetic B with a placeholder in

00:39:01,170 --> 00:39:05,729
a fresh universe and then we're gonna

00:39:03,420 --> 00:39:07,589
relate a now because these are return

00:39:05,729 --> 00:39:10,799
types we don't swap the order in there

00:39:07,589 --> 00:39:12,420
covariant so in order to relate these

00:39:10,799 --> 00:39:15,720
two function types will relate their

00:39:12,420 --> 00:39:19,289
return types and so we'll wind up with a

00:39:15,720 --> 00:39:22,200
constraint like this which says this

00:39:19,289 --> 00:39:27,900
variable has to live longer than this

00:39:22,200 --> 00:39:30,720
placeholder and so in expressed in R in

00:39:27,900 --> 00:39:34,039
the notation that the lexical solver is

00:39:30,720 --> 00:39:36,420
using it would be like that right and

00:39:34,039 --> 00:39:38,069
now this is interesting because we're

00:39:36,420 --> 00:39:39,779
now and now when the solver runs it's

00:39:38,069 --> 00:39:42,210
trying to it's trying to change the

00:39:39,779 --> 00:39:44,430
value of tick zero to be something that

00:39:42,210 --> 00:39:45,779
lives like it doesn't matter what it is

00:39:44,430 --> 00:39:47,819
as long as it's longer than this thing

00:39:45,779 --> 00:39:50,190
but this thing we don't know exactly

00:39:47,819 --> 00:39:52,589
what it is um so there are two options

00:39:50,190 --> 00:39:55,229
either if tick zero is in an appropriate

00:39:52,589 --> 00:39:57,599
universe like if it were in the universe

00:39:55,229 --> 00:40:01,289
one we could set its value it to be the

00:39:57,599 --> 00:40:04,109
place holder itself not be great but if

00:40:01,289 --> 00:40:06,269
tick zero is not in that universe there

00:40:04,109 --> 00:40:09,269
is still another option it could equal

00:40:06,269 --> 00:40:12,809
tick static and Ecstatic is no doubt of

00:40:09,269 --> 00:40:14,640
all the things so that would be okay so

00:40:12,809 --> 00:40:17,670
that's what this code is doing okay so

00:40:14,640 --> 00:40:21,479
it's saying assuming that I can't name

00:40:17,670 --> 00:40:22,609
it then I'm gonna basically love is the

00:40:21,479 --> 00:40:25,829
least upper bound is going to be

00:40:22,609 --> 00:40:27,839
assuming you can name the placeholder

00:40:25,829 --> 00:40:29,969
and so this is saying in the case that I

00:40:27,839 --> 00:40:31,950
can't let me reset that I have to grow

00:40:29,969 --> 00:40:33,509
even further I have to go all the way to

00:40:31,950 --> 00:40:36,539
take static to make this be satisfied

00:40:33,509 --> 00:40:38,759
and then we can just set the value to

00:40:36,539 --> 00:40:40,320
whatever this least upper bound is and

00:40:38,759 --> 00:40:42,750
it should be okay

00:40:40,320 --> 00:40:45,150
um and so the kind of interesting thing

00:40:42,750 --> 00:40:48,180
about this is that in a sense you don't

00:40:45,150 --> 00:40:49,890
get often in error you kind of get

00:40:48,180 --> 00:40:52,200
success but you get just a really really

00:40:49,890 --> 00:40:54,090
big vision that may give other errors

00:40:52,200 --> 00:40:55,620
later like maybe because you were in

00:40:54,090 --> 00:40:56,820
first ecstatic you now hold a borough

00:40:55,620 --> 00:40:59,370
for a really long time

00:40:56,820 --> 00:41:05,700
longer than you expect and stuff like

00:40:59,370 --> 00:41:08,100
that and I don't know there's also the

00:41:05,700 --> 00:41:10,110
reverse error as that play out I'm not

00:41:08,100 --> 00:41:12,300
sure I think that comes to do with the

00:41:10,110 --> 00:41:15,180
least upper bound right so sorry if we

00:41:12,300 --> 00:41:17,760
if we go back now to my original example

00:41:15,180 --> 00:41:20,250
so here I put it in the return type but

00:41:17,760 --> 00:41:22,860
if you have the placeholder like like in

00:41:20,250 --> 00:41:24,240
this case the placeholder was in the

00:41:22,860 --> 00:41:26,840
parameter type we wound up with the

00:41:24,240 --> 00:41:30,900
placeholder being done so sort of lower

00:41:26,840 --> 00:41:34,620
variable or sorry it becomes the

00:41:30,900 --> 00:41:36,030
outlived thing then that winds up

00:41:34,620 --> 00:41:37,530
reporting an error through a different

00:41:36,030 --> 00:41:39,810
kind of because when we're doing the

00:41:37,530 --> 00:41:44,280
region solving we're only interested in

00:41:39,810 --> 00:41:46,230
in in growing the inference variables we

00:41:44,280 --> 00:41:48,420
try to make them so we only basically

00:41:46,230 --> 00:41:49,800
care if the inference variable is in the

00:41:48,420 --> 00:41:51,690
left hand side if it's the bigger thing

00:41:49,800 --> 00:41:53,550
they happen that we can make bigger and

00:41:51,690 --> 00:41:56,010
bigger and bigger and then once we found

00:41:53,550 --> 00:41:58,050
a value of it's big enough to satisfy

00:41:56,010 --> 00:42:00,330
all the places then we go back and look

00:41:58,050 --> 00:42:03,420
for the for the constraints where it

00:42:00,330 --> 00:42:06,870
appears in the right hand side was it

00:42:03,420 --> 00:42:08,580
still small enough to satisfy so we're

00:42:06,870 --> 00:42:09,930
finding like this is the smallest value

00:42:08,580 --> 00:42:12,210
that will meet all the constraints and

00:42:09,930 --> 00:42:13,680
maybe even the smallest value is too big

00:42:12,210 --> 00:42:18,000
in that case there's an internal

00:42:13,680 --> 00:42:24,150
contradiction and we do that let's see

00:42:18,000 --> 00:42:26,310
function okay sorry and another windows

00:42:24,150 --> 00:42:28,830
compatibility thing where some key I

00:42:26,310 --> 00:42:31,560
press causes like a lot of stuff to fly

00:42:28,830 --> 00:42:32,790
fly up in my face and makes also sounds

00:42:31,560 --> 00:42:36,650
in my ears that it hopefully you guys

00:42:32,790 --> 00:42:37,970
can't hear um let's try me little crazy

00:42:36,650 --> 00:42:41,130
okay

00:42:37,970 --> 00:42:42,930
so right so the expansion is this phase

00:42:41,130 --> 00:42:44,400
where we're growing all the things to be

00:42:42,930 --> 00:42:46,470
the smallest values that satisfy the

00:42:44,400 --> 00:42:49,350
constraints and then the collect errors

00:42:46,470 --> 00:42:51,060
and collect far errors is where we go

00:42:49,350 --> 00:42:53,580
back over and say how are those two big

00:42:51,060 --> 00:42:54,090
is so let's report an ear and that's

00:42:53,580 --> 00:42:58,020
where

00:42:54,090 --> 00:42:59,580
this placeholder the fact that this

00:42:58,020 --> 00:43:00,630
variable had to be smaller than a

00:42:59,580 --> 00:43:05,280
placeholder and we don't know what the

00:43:00,630 --> 00:43:07,830
policeman is we would feel um Nico why

00:43:05,280 --> 00:43:10,350
isn't it possible to record the error

00:43:07,830 --> 00:43:11,850
when you make the region like really big

00:43:10,350 --> 00:43:14,730
like why do we have to go back over it

00:43:11,850 --> 00:43:17,700
afterwards it's not necessarily an error

00:43:14,730 --> 00:43:19,080
that it grows to be tick static there

00:43:17,700 --> 00:43:22,950
are examples where that that will type

00:43:19,080 --> 00:43:24,900
just fine so if you recall I could give

00:43:22,950 --> 00:43:26,910
you one if you want but if you remember

00:43:24,900 --> 00:43:28,140
from the very first thing we looked at I

00:43:26,910 --> 00:43:29,370
said something like we'll make an

00:43:28,140 --> 00:43:32,600
inference variable and it's not going to

00:43:29,370 --> 00:43:35,070
be constrained anywhere outside of this

00:43:32,600 --> 00:43:36,900
like subtyping relationship so all the

00:43:35,070 --> 00:43:38,730
constraints arise from them there they

00:43:36,900 --> 00:43:41,460
may well be tit ecstatic is a perfectly

00:43:38,730 --> 00:43:44,490
valid value for that verbal to take on

00:43:41,460 --> 00:43:48,420
or maybe it just is a valid burger

00:43:44,490 --> 00:43:51,420
okay thanks I'm not related to that so

00:43:48,420 --> 00:43:54,390
in the sort of case that there is

00:43:51,420 --> 00:43:57,240
ultimately an error does the compiler do

00:43:54,390 --> 00:43:59,670
some work to sort of so I can imagine

00:43:57,240 --> 00:44:02,280
like this picking tick static thing if

00:43:59,670 --> 00:44:04,530
the code is ultimately erroneous you

00:44:02,280 --> 00:44:06,750
could get a very confusing message where

00:44:04,530 --> 00:44:08,460
something is claimed to be tick static

00:44:06,750 --> 00:44:09,060
and it's hard to understand where that's

00:44:08,460 --> 00:44:12,180
coming from

00:44:09,060 --> 00:44:15,570
is there some logic to try to like catch

00:44:12,180 --> 00:44:17,610
that case and explain it yes yes there

00:44:15,570 --> 00:44:19,920
is so there's this module called

00:44:17,610 --> 00:44:25,830
inference or recording nice region

00:44:19,920 --> 00:44:31,680
errors and and one of them is called

00:44:25,830 --> 00:44:33,180
placeholder error and indeed this is the

00:44:31,680 --> 00:44:35,250
way this basically works is when you get

00:44:33,180 --> 00:44:37,020
it you get an error from region

00:44:35,250 --> 00:44:38,340
inference it's it's kind of like here's

00:44:37,020 --> 00:44:40,740
a constraint I couldn't satisfy it's

00:44:38,340 --> 00:44:42,360
kind of the shape it takes and then the

00:44:40,740 --> 00:44:44,010
job of the nice region errors is to like

00:44:42,360 --> 00:44:45,620
look at that constraint and try to see

00:44:44,010 --> 00:44:47,640
if we can categorize it into something

00:44:45,620 --> 00:44:49,650
for which we have a Taylor to error

00:44:47,640 --> 00:44:51,480
message try to take a guess as to what's

00:44:49,650 --> 00:44:56,520
going on basically so this particular

00:44:51,480 --> 00:44:57,930
one tries to detect if it came came

00:44:56,520 --> 00:45:00,510
about as a result of a place holder

00:44:57,930 --> 00:45:03,360
conflict and there's various scenarios

00:45:00,510 --> 00:45:04,920
you see it let's do a reasonable amount

00:45:03,360 --> 00:45:07,230
of effort to make a nice message and say

00:45:04,920 --> 00:45:09,660
things like

00:45:07,230 --> 00:45:11,400
you know this thing would have to be

00:45:09,660 --> 00:45:16,320
implemented for this type for any two

00:45:11,400 --> 00:45:17,849
lifetimes but it's only implemented for

00:45:16,320 --> 00:45:19,920
this type for some specific lifetime

00:45:17,849 --> 00:45:21,390
instantly so yeah we put a lot of effort

00:45:19,920 --> 00:45:24,839
actually this transition in two

00:45:21,390 --> 00:45:26,310
universes was accompanied with the we

00:45:24,839 --> 00:45:27,900
never did have nice errors for this case

00:45:26,310 --> 00:45:31,260
sense and we tried to link do that at

00:45:27,900 --> 00:45:32,700
the same time um and there are some

00:45:31,260 --> 00:45:34,530
cases that's still a work in progress

00:45:32,700 --> 00:45:36,720
there's still a few I think we fixed all

00:45:34,530 --> 00:45:39,109
the major regressions maybe there's one

00:45:36,720 --> 00:45:41,310
left okay lq d's been working on that

00:45:39,109 --> 00:45:44,310
kind of extending this to cover more and

00:45:41,310 --> 00:45:46,770
more cases but so and then one other

00:45:44,310 --> 00:45:50,280
thing and this may be clear to everybody

00:45:46,770 --> 00:45:53,450
here but just in case just trying to

00:45:50,280 --> 00:45:55,170
think about like all of these

00:45:53,450 --> 00:45:57,960
constraints we're trying to put in place

00:45:55,170 --> 00:45:59,910
with universes right so i think the case

00:45:57,960 --> 00:46:03,599
we care about is it's basically about

00:45:59,910 --> 00:46:05,550
nesting of exists and for all so if you

00:46:03,599 --> 00:46:08,220
if you're saying that there exists

00:46:05,550 --> 00:46:11,670
something such that for all something

00:46:08,220 --> 00:46:13,200
else something happens then you that's

00:46:11,670 --> 00:46:16,140
why we can't allow you to pick that

00:46:13,200 --> 00:46:18,240
outer thing to be whatever placeholder

00:46:16,140 --> 00:46:20,040
you're using for the inner thing because

00:46:18,240 --> 00:46:22,800
you're trying to show that it works yeah

00:46:20,040 --> 00:46:24,599
I baited rather to start with this and

00:46:22,800 --> 00:46:26,819
even I should happen anyway do you like

00:46:24,599 --> 00:46:28,290
now but let me because we only have a

00:46:26,819 --> 00:46:29,520
few minutes left anyway so we're not

00:46:28,290 --> 00:46:31,440
going to get to the rest of my agent I

00:46:29,520 --> 00:46:33,569
will have to schedule a follow me but

00:46:31,440 --> 00:46:35,220
this is good I think now that I've

00:46:33,569 --> 00:46:37,819
walked through all of this with you you

00:46:35,220 --> 00:46:43,440
can look at the pure logic side which is

00:46:37,819 --> 00:46:47,520
like what basically what Aaron was

00:46:43,440 --> 00:46:49,290
saying is you could have a couple of to

00:46:47,520 --> 00:46:52,260
imagine a and B are variables of any

00:46:49,290 --> 00:46:54,329
kind essentially you can have a

00:46:52,260 --> 00:46:57,810
constraint like this that says they'll

00:46:54,329 --> 00:47:03,109
exist in a sucks but for all be a equals

00:46:57,810 --> 00:47:03,109
B or you could have a constraint like

00:47:03,190 --> 00:47:11,060
for all a there exists to be such that a

00:47:07,760 --> 00:47:16,520
equals B right and this latter one this

00:47:11,060 --> 00:47:19,070
is like just fine right so obviously for

00:47:16,520 --> 00:47:21,140
all a there is some B that is equal to a

00:47:19,070 --> 00:47:25,370
and that's just a at least if you have a

00:47:21,140 --> 00:47:28,220
suitably I'm sure there are logics where

00:47:25,370 --> 00:47:31,670
that's not true but anyway in the cases

00:47:28,220 --> 00:47:36,320
we care about but this one not so good

00:47:31,670 --> 00:47:38,570
right at least if you want to be general

00:47:36,320 --> 00:47:40,460
then you can't say that for all be there

00:47:38,570 --> 00:47:42,680
some a that equals it the only way you

00:47:40,460 --> 00:47:44,090
can say that for sure is if there's like

00:47:42,680 --> 00:47:45,680
you know something about the domains and

00:47:44,090 --> 00:47:52,040
these variables there's only exactly one

00:47:45,680 --> 00:47:53,420
value and okay sure so or rather yeah

00:47:52,040 --> 00:47:54,620
you said I mean you can't pick some a

00:47:53,420 --> 00:47:56,120
and then know that it's gonna be equal

00:47:54,620 --> 00:48:01,390
to all the B's unless there's exactly

00:47:56,120 --> 00:48:01,390
one being money and

00:48:01,690 --> 00:48:08,890
right and so this would map out to

00:48:03,609 --> 00:48:16,150
basically a being in universe 0 and B

00:48:08,890 --> 00:48:21,640
being in universe 1 and hence we get a

00:48:16,150 --> 00:48:25,630
conflict but in this case they rather

00:48:21,640 --> 00:48:28,180
the placeholder is in universe 0 and the

00:48:25,630 --> 00:48:29,619
variable is a rather equatorial it's in

00:48:28,180 --> 00:48:31,359
universe 1 the placeholders in universe

00:48:29,619 --> 00:48:35,200
1 but the variable is also in the

00:48:31,359 --> 00:48:36,760
universe 1 um and this actually is the

00:48:35,200 --> 00:48:39,849
framework by which I think I can explain

00:48:36,760 --> 00:48:41,500
why we only have to keep a single

00:48:39,849 --> 00:48:43,650
integer instead of this whole tree

00:48:41,500 --> 00:48:46,990
hanging around um

00:48:43,650 --> 00:48:48,880
which roughly speaking idea is that we

00:48:46,990 --> 00:48:51,700
process these constraints by like

00:48:48,880 --> 00:48:53,859
walking down this tree and so they don't

00:48:51,700 --> 00:48:55,710
directly communicate to one another in

00:48:53,859 --> 00:48:58,630
some sense so the only way that a value

00:48:55,710 --> 00:49:01,780
like here's a situation where you have

00:48:58,630 --> 00:49:04,180
for all be some stuff and for all see

00:49:01,780 --> 00:49:06,369
some stuff and these are two siblings

00:49:04,180 --> 00:49:08,170
now B and C are two different universes

00:49:06,369 --> 00:49:11,589
they can't communicate but the only way

00:49:08,170 --> 00:49:12,789
that like solving the stuff in this

00:49:11,589 --> 00:49:14,529
first half could have side-effects

00:49:12,789 --> 00:49:16,569
somehow that are like visible to this

00:49:14,529 --> 00:49:18,549
other half is if it changes the value of

00:49:16,569 --> 00:49:21,250
a so only thing they have in common and

00:49:18,549 --> 00:49:22,599
a is already in the root universe so any

00:49:21,250 --> 00:49:25,180
value of that a you can have is some

00:49:22,599 --> 00:49:28,869
player they can both name so so long as

00:49:25,180 --> 00:49:31,329
we don't allow like if the bad case

00:49:28,869 --> 00:49:33,880
would be like this you know if we were

00:49:31,329 --> 00:49:36,010
if we were buggy for illogic silver was

00:49:33,880 --> 00:49:39,369
buggy or something it might say oh okay

00:49:36,010 --> 00:49:41,559
B is a is equal to B and therefore this

00:49:39,369 --> 00:49:44,130
is like saying B is equal asking if B is

00:49:41,559 --> 00:49:48,250
equal to C or not and since we're not

00:49:44,130 --> 00:49:49,930
since we've assigned this index 1 and

00:49:48,250 --> 00:49:52,029
we've assigned this index 2 and 2 is

00:49:49,930 --> 00:49:52,960
greater than 1 like it's okay because we

00:49:52,029 --> 00:49:54,430
think that they're a but the

00:49:52,960 --> 00:49:56,020
parent-child relationship when actually

00:49:54,430 --> 00:49:58,089
don't but that just can't happen because

00:49:56,020 --> 00:49:59,859
we would never allow a to take the value

00:49:58,089 --> 00:50:04,289
B in the first place it would instead

00:49:59,859 --> 00:50:07,390
the TIC static or or error or something

00:50:04,289 --> 00:50:11,440
so that's convenient cuz it an integer

00:50:07,390 --> 00:50:14,210
is like small yeah so that's the

00:50:11,440 --> 00:50:15,619
universe system and

00:50:14,210 --> 00:50:17,170
I guess we should schedule a follow-up

00:50:15,619 --> 00:50:20,450
meeting to walk through the trades over

00:50:17,170 --> 00:50:23,180
and actually that's sort of nice this is

00:50:20,450 --> 00:50:28,670
enough for a day all right

00:50:23,180 --> 00:50:31,420
thanks all Thank You Nico thank you

00:50:28,670 --> 00:50:31,420

YouTube URL: https://www.youtube.com/watch?v=iV1Z0xYXkck


