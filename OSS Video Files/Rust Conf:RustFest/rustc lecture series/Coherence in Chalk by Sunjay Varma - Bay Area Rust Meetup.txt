Title: Coherence in Chalk by Sunjay Varma - Bay Area Rust Meetup
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	This video was recorded during the Bay Area Rust Meetup in San Francisco, CA, USA on June 28, 2018.

https://www.meetup.com/Rust-Bay-Area/events/251073767/

Sunjay Varma presented an overview of his work on Chalk, the new trait-solving implementation in the Rust Compiler. He talked about the concept of coherence in the Rust language, described how it is implemented in rustc today, and then covered how he has implemented it in Chalk using logic programming.

Talk written and presented by:
Sunjay Varma (https://twitter.com/sunjay03)
Captions: 
	00:00:00,030 --> 00:00:06,210
all right everyone welcome to the June

00:00:02,129 --> 00:00:10,469
rust meetup as always thanks Mozilla for

00:00:06,210 --> 00:00:15,030
hosting and the food and stuff next

00:00:10,469 --> 00:00:18,600
month we will probably be in Stanford

00:00:15,030 --> 00:00:20,609
maybe the meetup still being put

00:00:18,600 --> 00:00:22,260
together but like like I said a couple

00:00:20,609 --> 00:00:24,660
meetups ago we're thinking about moving

00:00:22,260 --> 00:00:28,650
it around so that more people can come

00:00:24,660 --> 00:00:30,330
easier and like it's good and also it's

00:00:28,650 --> 00:00:33,540
easier if I don't have to organize every

00:00:30,330 --> 00:00:36,510
meetup that way don't make mistakes like

00:00:33,540 --> 00:00:39,239
July all right

00:00:36,510 --> 00:00:45,450
just one quick announcement the rust

00:00:39,239 --> 00:00:48,870
book is now in stores this is the this

00:00:45,450 --> 00:00:51,510
is the one that's online but you can get

00:00:48,870 --> 00:00:54,510
a paper copy as well this is the one by

00:00:51,510 --> 00:00:57,149
Steven Carroll so yeah that's the first

00:00:54,510 --> 00:00:58,980
print copy I guess like Steve had it a

00:00:57,149 --> 00:01:01,440
few weeks ago and now it's like out for

00:00:58,980 --> 00:01:03,960
everyone so yeah you can grab a copy on

00:01:01,440 --> 00:01:05,930
Amazon or no starch press or somewhere I

00:01:03,960 --> 00:01:09,299
don't know you can find it it's not hard

00:01:05,930 --> 00:01:11,670
yeah so today we have two talks we have

00:01:09,299 --> 00:01:14,299
Sanjay talking about coherence and chalk

00:01:11,670 --> 00:01:17,490
and we have Rafe talking about

00:01:14,299 --> 00:01:20,180
data-oriented GOI and rust so I'll hand

00:01:17,490 --> 00:01:20,180
it over to son jet

00:01:29,930 --> 00:01:37,159
okay we have spy it's wonderful

00:01:37,640 --> 00:01:43,650
awesome so hi everybody

00:01:40,020 --> 00:01:45,420
so as Manish said I'm Sanjay I actually

00:01:43,650 --> 00:01:47,820
only started working at Mozilla a couple

00:01:45,420 --> 00:01:50,149
of weeks ago and I've had the pleasure

00:01:47,820 --> 00:01:53,040
of working on this project called chalk

00:01:50,149 --> 00:01:56,340
chalk is the new trade system

00:01:53,040 --> 00:01:59,310
implementation in rust C and my research

00:01:56,340 --> 00:02:01,530
mainly focuses on modeling coherence in

00:01:59,310 --> 00:02:03,270
chalk door if you don't know what

00:02:01,530 --> 00:02:05,720
coherence is I'm actually going to talk

00:02:03,270 --> 00:02:08,789
about it as I go along

00:02:05,720 --> 00:02:10,860
so I'm gonna start this talk by talking

00:02:08,789 --> 00:02:13,950
about talking a bit about what chalk

00:02:10,860 --> 00:02:16,110
actually is then I'll go into coherence

00:02:13,950 --> 00:02:17,700
and what that means in the context of

00:02:16,110 --> 00:02:20,069
the rust programming language

00:02:17,700 --> 00:02:23,160
after that I'll talk a bit about logic

00:02:20,069 --> 00:02:26,940
programming and cover how we lower rust

00:02:23,160 --> 00:02:29,280
code into logic in chalk finally we'll

00:02:26,940 --> 00:02:31,860
talk about two parts of coherence the

00:02:29,280 --> 00:02:34,739
orphan check and the overlap check and

00:02:31,860 --> 00:02:38,100
I'll finish the talk with a summary and

00:02:34,739 --> 00:02:45,290
some final thoughts so let's start with

00:02:38,100 --> 00:02:49,799
chalk there we go so sorry about that

00:02:45,290 --> 00:02:51,959
there we go so chalk is the is like I

00:02:49,799 --> 00:02:54,600
said the new traits of plantation in

00:02:51,959 --> 00:02:57,540
rust but here's how the current rust

00:02:54,600 --> 00:03:00,630
compiler looks at about 10,000 feet so

00:02:57,540 --> 00:03:03,239
the Cuyler takes your rust code and runs

00:03:00,630 --> 00:03:05,190
it through some very cool stuff in the

00:03:03,239 --> 00:03:07,019
current trades implementation and then

00:03:05,190 --> 00:03:12,060
eventually after a couple more steps

00:03:07,019 --> 00:03:14,220
outputs machine code chalk is the new

00:03:12,060 --> 00:03:17,280
trades implementation it uses logic

00:03:14,220 --> 00:03:19,260
programming and the idea is that we can

00:03:17,280 --> 00:03:21,840
take the logical rules that the trade

00:03:19,260 --> 00:03:23,970
system abides by and represent them with

00:03:21,840 --> 00:03:25,530
logic programming I'll tell you more

00:03:23,970 --> 00:03:28,440
about logic programming in a little bit

00:03:25,530 --> 00:03:30,480
but for now let's talk about the part of

00:03:28,440 --> 00:03:35,100
the rust rate system that I'm personally

00:03:30,480 --> 00:03:38,030
focusing on coherence is all about

00:03:35,100 --> 00:03:39,670
making sure that there's only a single

00:03:38,030 --> 00:03:43,780
implementation

00:03:39,670 --> 00:03:47,319
of any given trait that applies to any

00:03:43,780 --> 00:03:49,330
method call at a given time so it's

00:03:47,319 --> 00:03:51,130
responsible for a lot of the really cool

00:03:49,330 --> 00:03:53,400
properties that our trade system has

00:03:51,130 --> 00:03:56,500
that other languages actually don't have

00:03:53,400 --> 00:03:59,140
so what that means is that if you call

00:03:56,500 --> 00:04:02,230
the fav method from the favorite color

00:03:59,140 --> 00:04:05,769
trait we want to match that to exactly

00:04:02,230 --> 00:04:07,120
one implementation of that method we

00:04:05,769 --> 00:04:09,430
want to make sure that you can't

00:04:07,120 --> 00:04:11,260
actually even define two possible

00:04:09,430 --> 00:04:15,400
implementations of a method for the same

00:04:11,260 --> 00:04:18,190
types fundamentally coherence means that

00:04:15,400 --> 00:04:20,500
no matter what given a trait and some

00:04:18,190 --> 00:04:24,010
set of type parameters there should be

00:04:20,500 --> 00:04:26,139
exactly one imple that applies this is

00:04:24,010 --> 00:04:28,090
important because if we have this

00:04:26,139 --> 00:04:30,220
property then no matter where your

00:04:28,090 --> 00:04:32,139
traits methods are called you can be

00:04:30,220 --> 00:04:34,840
sure that the behavior will be exactly

00:04:32,139 --> 00:04:36,970
as you expect and Russ coherence

00:04:34,840 --> 00:04:39,520
guarantees actually apply across crates

00:04:36,970 --> 00:04:41,560
as well so even if you add a dependency

00:04:39,520 --> 00:04:44,440
to your project it's important for that

00:04:41,560 --> 00:04:46,600
dependency to never be able to introduce

00:04:44,440 --> 00:04:50,229
a conflicting implementation of any

00:04:46,600 --> 00:04:51,700
trait coherence enables rest and cargo

00:04:50,229 --> 00:04:54,760
to actually do a lot of really cool

00:04:51,700 --> 00:04:57,070
things rust is able to allow multiple

00:04:54,760 --> 00:04:59,680
distinct versions of crates in the

00:04:57,070 --> 00:05:02,140
dependency tree of your project we avoid

00:04:59,680 --> 00:05:04,360
what's known as the hash table problem

00:05:02,140 --> 00:05:06,190
where different underlying Impuls are

00:05:04,360 --> 00:05:08,530
selected for the same operation in

00:05:06,190 --> 00:05:11,710
different contexts you can imagine that

00:05:08,530 --> 00:05:14,620
if a different implementation of hash

00:05:11,710 --> 00:05:15,940
was chosen for insert versus when you

00:05:14,620 --> 00:05:18,150
were getting something from the hash

00:05:15,940 --> 00:05:20,590
table that would cause a lot of problems

00:05:18,150 --> 00:05:23,080
so coherence makes it so that we can

00:05:20,590 --> 00:05:25,810
never split the ecosystem by having

00:05:23,080 --> 00:05:28,440
multiple incompatible implementations of

00:05:25,810 --> 00:05:31,030
the same types in two different crates

00:05:28,440 --> 00:05:33,460
crates are able to maintain backwards

00:05:31,030 --> 00:05:35,169
compatibility and add Impuls without

00:05:33,460 --> 00:05:38,229
increasing their major version number

00:05:35,169 --> 00:05:40,660
every time if some other crate could

00:05:38,229 --> 00:05:44,889
implement methods for your types this

00:05:40,660 --> 00:05:46,479
just wouldn't be possible an often

00:05:44,889 --> 00:05:48,820
requested feature in rust is

00:05:46,479 --> 00:05:50,650
specialization and the only reason

00:05:48,820 --> 00:05:53,380
specialization is actually possible in

00:05:50,650 --> 00:05:53,639
rust is because coherence makes it so

00:05:53,380 --> 00:05:55,499
that

00:05:53,639 --> 00:05:57,689
there's only a single choice for a

00:05:55,499 --> 00:06:00,150
methods implementation at any given time

00:05:57,689 --> 00:06:02,099
if two crates that are compiled

00:06:00,150 --> 00:06:04,830
separately could have overlapping

00:06:02,099 --> 00:06:08,909
implementations then we wouldn't be able

00:06:04,830 --> 00:06:12,120
to implement specialization so coherence

00:06:08,909 --> 00:06:15,629
means that for any given trade there are

00:06:12,120 --> 00:06:18,330
either zero or one Impuls of that trade

00:06:15,629 --> 00:06:20,879
that applied to a given set of types no

00:06:18,330 --> 00:06:23,580
more than that that means that the my

00:06:20,879 --> 00:06:27,930
trade food method here mapped to just

00:06:23,580 --> 00:06:31,169
one implementation coherence also means

00:06:27,930 --> 00:06:35,610
that for every imple that could exist it

00:06:31,169 --> 00:06:38,009
only exists in one place and this is key

00:06:35,610 --> 00:06:40,319
for having a coherent system in this

00:06:38,009 --> 00:06:43,529
example that means that only one crate

00:06:40,319 --> 00:06:47,159
has the power to define this imple of my

00:06:43,529 --> 00:06:49,229
trade for any type T if you'd like to

00:06:47,159 --> 00:06:51,199
learn more about coherence and here the

00:06:49,229 --> 00:06:54,270
things I described in much more detail

00:06:51,199 --> 00:06:55,979
boats who's known as without boats on

00:06:54,270 --> 00:06:59,580
give up and Twitter gave a fantastic

00:06:55,979 --> 00:07:04,319
talk at a meet-up last year which covers

00:06:59,580 --> 00:07:06,240
coherence in detail so how does the rest

00:07:04,319 --> 00:07:08,189
compiler and force coherence well

00:07:06,240 --> 00:07:11,159
coherence is implemented as the

00:07:08,189 --> 00:07:14,610
combination of two checks the orphan

00:07:11,159 --> 00:07:17,399
check and the overlap check the orphan

00:07:14,610 --> 00:07:20,069
check is designed to ensure that every

00:07:17,399 --> 00:07:22,229
imple abides by the orphan rules which

00:07:20,069 --> 00:07:24,300
we'll talk about in just a minute

00:07:22,229 --> 00:07:27,740
this check is what gives us the property

00:07:24,300 --> 00:07:31,800
that every info exists in only one place

00:07:27,740 --> 00:07:34,680
the overlap check makes sure that every

00:07:31,800 --> 00:07:37,770
pair of Impuls can never apply to the

00:07:34,680 --> 00:07:39,990
same set of types this check allows us

00:07:37,770 --> 00:07:42,839
to guarantee that there is only up to

00:07:39,990 --> 00:07:47,550
one imple of a trait for a given set of

00:07:42,839 --> 00:07:50,189
types the orphan check goes through each

00:07:47,550 --> 00:07:51,569
imple in the current program and tests

00:07:50,189 --> 00:07:53,879
to make sure that it abides by the

00:07:51,569 --> 00:07:55,740
orphan rules now there are actually a

00:07:53,879 --> 00:07:57,569
lot of different sources about the

00:07:55,740 --> 00:07:59,219
orphan rules and I definitely suggest

00:07:57,569 --> 00:08:01,560
you check some of these out if you're

00:07:59,219 --> 00:08:03,509
interested in learning more but when it

00:08:01,560 --> 00:08:05,370
comes to the rest compiler and the rest

00:08:03,509 --> 00:08:07,230
language in general the most

00:08:05,370 --> 00:08:09,330
authoritative source is often

00:08:07,230 --> 00:08:13,530
actually the source code of the rest

00:08:09,330 --> 00:08:15,480
compiler so let me show you some of the

00:08:13,530 --> 00:08:17,000
files and functions where the orphan

00:08:15,480 --> 00:08:19,830
rules are implemented

00:08:17,000 --> 00:08:21,960
there's the orphan checker which

00:08:19,830 --> 00:08:23,670
actually describes how rusty goes

00:08:21,960 --> 00:08:26,490
through each imple in order to check it

00:08:23,670 --> 00:08:27,870
there are the orphan check and orphan

00:08:26,490 --> 00:08:29,670
check trade raff function so that

00:08:27,870 --> 00:08:31,470
actually do the heavy lifting of

00:08:29,670 --> 00:08:34,050
checking that an impulse Attis fides the

00:08:31,470 --> 00:08:36,419
orphan rules and well we don't actually

00:08:34,050 --> 00:08:38,280
have enough time to dive into the code

00:08:36,419 --> 00:08:40,169
for each of these functions what I've

00:08:38,280 --> 00:08:42,510
done is I've gone through them and

00:08:40,169 --> 00:08:45,260
extracted the orphan rules exactly as

00:08:42,510 --> 00:08:48,330
they're implemented in rust see today so

00:08:45,260 --> 00:08:50,280
here without any further ado our the

00:08:48,330 --> 00:08:53,310
orphan rules according to the source

00:08:50,280 --> 00:08:55,710
code of the rest compiler tada

00:08:53,310 --> 00:08:57,630
now this is actually this is a whole

00:08:55,710 --> 00:08:59,850
bunch of words and it's written to be

00:08:57,630 --> 00:09:02,220
very precise you know it's written to be

00:08:59,850 --> 00:09:05,280
a very precise mathematical definition

00:09:02,220 --> 00:09:06,990
of the orphan rules and originally when

00:09:05,280 --> 00:09:10,110
I was designing this talk I tried

00:09:06,990 --> 00:09:13,050
reading them out loud and it turns out

00:09:10,110 --> 00:09:16,350
that reading math out loud is a terrible

00:09:13,050 --> 00:09:18,180
way to explain things and it's literally

00:09:16,350 --> 00:09:20,190
impossible to understand so we're

00:09:18,180 --> 00:09:23,220
actually gonna skip all of this and I'm

00:09:20,190 --> 00:09:25,140
gonna explain the orphan rules in a much

00:09:23,220 --> 00:09:26,450
more visual way that I hope will be

00:09:25,140 --> 00:09:29,460
easier to understand

00:09:26,450 --> 00:09:32,340
so the orphan rules are centered around

00:09:29,460 --> 00:09:35,010
impulse and imple describes the

00:09:32,340 --> 00:09:37,980
implementation of a trait for a given

00:09:35,010 --> 00:09:40,470
type and impulse can have zero or more

00:09:37,980 --> 00:09:43,620
type parameters and the trait itself can

00:09:40,470 --> 00:09:45,720
also have zero more type parameters one

00:09:43,620 --> 00:09:48,240
thing I've done which is going to come

00:09:45,720 --> 00:09:51,090
in handy later is I've labeled the

00:09:48,240 --> 00:09:53,760
implemented type as p0 and labeled the

00:09:51,090 --> 00:09:56,580
type parameters of the trait as p1 to PN

00:09:53,760 --> 00:09:59,400
now let's talk about why I did that

00:09:56,580 --> 00:10:01,800
so the orphan rules start by asking

00:09:59,400 --> 00:10:04,650
whether the trait we're implementing is

00:10:01,800 --> 00:10:06,990
defined in the current crate or if it

00:10:04,650 --> 00:10:10,170
comes from a dependency and is thus an

00:10:06,990 --> 00:10:12,450
upstream trait if the trait is locally

00:10:10,170 --> 00:10:14,340
defined in the current crate the orphan

00:10:12,450 --> 00:10:16,770
will say that it's good to go

00:10:14,340 --> 00:10:19,380
and we can implement it for any type at

00:10:16,770 --> 00:10:21,220
all but if the trait is an upstream

00:10:19,380 --> 00:10:23,020
trade then the orphan

00:10:21,220 --> 00:10:25,870
say that we need to check a few more

00:10:23,020 --> 00:10:28,450
things the first thing we have to check

00:10:25,870 --> 00:10:32,140
is that there's at least one type from

00:10:28,450 --> 00:10:35,320
p0 to PN that's locally defined in the

00:10:32,140 --> 00:10:36,670
current crate part of the definition of

00:10:35,320 --> 00:10:39,250
the orphan rules is that we actually

00:10:36,670 --> 00:10:41,650
start searching from the implemented

00:10:39,250 --> 00:10:43,800
type and then go through each type

00:10:41,650 --> 00:10:47,050
parameter in the trade in order I

00:10:43,800 --> 00:10:49,440
labeled those types from p0 to P n so

00:10:47,050 --> 00:10:53,020
it's easy for us to remember to do that

00:10:49,440 --> 00:10:55,510
once we have a local type we check each

00:10:53,020 --> 00:10:57,100
type before that and make sure that it

00:10:55,510 --> 00:11:01,420
doesn't contain any of the type

00:10:57,100 --> 00:11:03,880
parameters T UV etc if all this can be

00:11:01,420 --> 00:11:06,760
verified the imple is valid and we can

00:11:03,880 --> 00:11:10,090
continue but if any of these steps fail

00:11:06,760 --> 00:11:12,840
the imple is considered an orphan imple

00:11:10,090 --> 00:11:15,400
and it's disallowed by the orphan rules

00:11:12,840 --> 00:11:18,010
so if these rules seem kind of strange

00:11:15,400 --> 00:11:21,850
and arbitrary it's because they sort of

00:11:18,010 --> 00:11:23,680
are and the resources I link to earlier

00:11:21,850 --> 00:11:26,350
go into the history and the reasoning

00:11:23,680 --> 00:11:28,720
behind them and they talk about why they

00:11:26,350 --> 00:11:32,710
work towards our goal of having exactly

00:11:28,720 --> 00:11:34,480
one place where an implicant belong but

00:11:32,710 --> 00:11:36,190
for now just try to keep these rules in

00:11:34,480 --> 00:11:37,900
mind because we'll come back to them

00:11:36,190 --> 00:11:39,790
later and talk about how they get

00:11:37,900 --> 00:11:43,000
implemented with logic programming and

00:11:39,790 --> 00:11:45,880
chalk the other part of coherence and

00:11:43,000 --> 00:11:49,120
rest is the overlap check this goes

00:11:45,880 --> 00:11:52,120
through all pairs of impulse and checks

00:11:49,120 --> 00:11:55,060
for any overlap between them the tricky

00:11:52,120 --> 00:11:57,460
part about this is that it in order to

00:11:55,060 --> 00:12:00,580
enforce coherence we have to be able to

00:11:57,460 --> 00:12:03,220
check all possible impulse in the entire

00:12:00,580 --> 00:12:05,260
universe in other words we need to be

00:12:03,220 --> 00:12:09,130
able to check any impulse that could

00:12:05,260 --> 00:12:10,810
exist in any compatible world and the

00:12:09,130 --> 00:12:13,270
reason that we're only interested in

00:12:10,810 --> 00:12:14,560
impulse in some ver compatible worlds is

00:12:13,270 --> 00:12:16,870
because if we try to just support

00:12:14,560 --> 00:12:21,670
everything our rules would be way too

00:12:16,870 --> 00:12:23,980
restrictive ok so that's a lot of

00:12:21,670 --> 00:12:26,650
information let's take a break from

00:12:23,980 --> 00:12:29,920
coherence and talk about logic

00:12:26,650 --> 00:12:32,740
programming so in logic programming the

00:12:29,920 --> 00:12:35,450
idea is that given some facts and some

00:12:32,740 --> 00:12:37,640
rules about those facts we can come to

00:12:35,450 --> 00:12:40,460
inclusions by proving things based on

00:12:37,640 --> 00:12:43,010
what we know take for example the

00:12:40,460 --> 00:12:45,920
sentence son Jay loves cake I'm Sanjay I

00:12:43,010 --> 00:12:50,720
love cake right this is a fact and I can

00:12:45,920 --> 00:12:53,810
write this in emojis like this cake is

00:12:50,720 --> 00:12:55,160
pretty sugary so if I enjoy cake well it

00:12:53,810 --> 00:12:58,130
might be reasonable to think that I

00:12:55,160 --> 00:13:01,990
enjoy candy as well we can write this as

00:12:58,130 --> 00:13:05,060
a general rule using emojis like this

00:13:01,990 --> 00:13:07,010
notice how I've left a placeholder to

00:13:05,060 --> 00:13:10,400
represent that this rule applies to

00:13:07,010 --> 00:13:13,580
anyone who loves cake this is a general

00:13:10,400 --> 00:13:18,020
rule that says that blank loves candy if

00:13:13,580 --> 00:13:20,210
they love cake we can take this fact and

00:13:18,020 --> 00:13:23,990
this rule and use them to derive the

00:13:20,210 --> 00:13:26,840
conclusion that Sanjay loves candy we

00:13:23,990 --> 00:13:29,660
took the rule that says that someone

00:13:26,840 --> 00:13:32,510
loves candy if they love cake and use

00:13:29,660 --> 00:13:34,370
the fact that Sanjay loves cake to come

00:13:32,510 --> 00:13:36,200
to the conclusion that Sanjay loves

00:13:34,370 --> 00:13:38,800
candy and I can tell you from personal

00:13:36,200 --> 00:13:42,560
experience both of these things are true

00:13:38,800 --> 00:13:44,750
so this is provable because we can

00:13:42,560 --> 00:13:48,010
logically derive it from the rule we

00:13:44,750 --> 00:13:51,050
created using the fact that I love cake

00:13:48,010 --> 00:13:53,660
chalks logic programming language is

00:13:51,050 --> 00:13:55,340
actually based on an extended form of a

00:13:53,660 --> 00:13:58,130
well established logic programming

00:13:55,340 --> 00:14:00,110
language called Prolog if we wanted to

00:13:58,130 --> 00:14:02,330
represent the same logic we showed

00:14:00,110 --> 00:14:05,870
before with emojis we might write

00:14:02,330 --> 00:14:08,150
something like this in Prolog here we've

00:14:05,870 --> 00:14:10,850
represented the same fact that Sanjay

00:14:08,150 --> 00:14:12,770
loves cake but we put the loves part on

00:14:10,850 --> 00:14:15,440
the outside and the sunjae and cake

00:14:12,770 --> 00:14:18,440
parts on the inside it still represents

00:14:15,440 --> 00:14:21,830
that same sentence it just uses a

00:14:18,440 --> 00:14:24,110
different syntax previously we were

00:14:21,830 --> 00:14:26,840
using the heart emoji to represent when

00:14:24,110 --> 00:14:30,410
someone loves something here we defined

00:14:26,840 --> 00:14:33,830
a predicate using the word love's to

00:14:30,410 --> 00:14:36,590
represent the same thing and after that

00:14:33,830 --> 00:14:39,680
line that represents Sanjay loves cake

00:14:36,590 --> 00:14:43,130
we even have the same rule about candy

00:14:39,680 --> 00:14:45,620
that we had before the colon followed by

00:14:43,130 --> 00:14:49,260
a dash is how you represent the word if

00:14:45,620 --> 00:14:53,250
in Prolog so just like before this

00:14:49,260 --> 00:14:56,970
rule reads as tea loves candy if tea

00:14:53,250 --> 00:14:59,040
loves cake tea is a variable that

00:14:56,970 --> 00:15:02,580
represents anything that could be placed

00:14:59,040 --> 00:15:05,340
there now if we ask whether Sanjay loves

00:15:02,580 --> 00:15:08,550
candy the answer that Prolog produces is

00:15:05,340 --> 00:15:11,190
yes this is the same conclusion we came

00:15:08,550 --> 00:15:13,710
to before and Prolog has reached it in a

00:15:11,190 --> 00:15:15,990
similar way by using our facts and our

00:15:13,710 --> 00:15:20,040
rules to prove the answer to our

00:15:15,990 --> 00:15:22,470
question Jaques logical language is

00:15:20,040 --> 00:15:24,720
actually even more powerful than Prolog

00:15:22,470 --> 00:15:26,940
on its own chalk supports a number of

00:15:24,720 --> 00:15:30,450
interesting features such as for all and

00:15:26,940 --> 00:15:33,180
exists and for all means that a given

00:15:30,450 --> 00:15:36,480
rule is provable for all values of the

00:15:33,180 --> 00:15:39,000
variable T whereas exists means that a

00:15:36,480 --> 00:15:41,760
given rule is provable for at least one

00:15:39,000 --> 00:15:44,850
value of the variable T this allows us

00:15:41,760 --> 00:15:48,630
to express things like each type T

00:15:44,850 --> 00:15:51,120
implements my trait or that there is at

00:15:48,630 --> 00:15:55,860
least one type T that implements my

00:15:51,120 --> 00:15:58,020
trait okay so now that we know some

00:15:55,860 --> 00:16:00,750
basic parts of logic programming let's

00:15:58,020 --> 00:16:02,900
talk about how chalk takes your rest

00:16:00,750 --> 00:16:05,580
program and turns it into logic I

00:16:02,900 --> 00:16:08,070
mentioned earlier that chalk is the new

00:16:05,580 --> 00:16:09,990
trait system implementation and that it

00:16:08,070 --> 00:16:12,510
uses logic programming to model the

00:16:09,990 --> 00:16:14,580
rules of the trade system while lowering

00:16:12,510 --> 00:16:16,920
is the name of the process in which

00:16:14,580 --> 00:16:19,530
chalk takes each declaration in your

00:16:16,920 --> 00:16:21,180
program and turns it into logical

00:16:19,530 --> 00:16:24,540
predicate that are similar to what you

00:16:21,180 --> 00:16:27,060
saw before when we're lowering we can

00:16:24,540 --> 00:16:29,700
take anything that we know about the

00:16:27,060 --> 00:16:31,560
program and use it to produce facts and

00:16:29,700 --> 00:16:35,040
rules just like we did when we were

00:16:31,560 --> 00:16:37,050
talking about cake and candy let's say

00:16:35,040 --> 00:16:40,500
for example that we're compiling a crate

00:16:37,050 --> 00:16:43,110
called people the people crate depends

00:16:40,500 --> 00:16:46,800
on another crate called favourites which

00:16:43,110 --> 00:16:48,990
defines a struct a trait and implements

00:16:46,800 --> 00:16:52,080
that trait for any type that implements

00:16:48,990 --> 00:16:55,350
copy both people and favorites

00:16:52,080 --> 00:16:58,610
implicitly depend on the STD crate which

00:16:55,350 --> 00:17:01,260
defines some traits and types of its own

00:16:58,610 --> 00:17:02,410
using the favorite color trade from the

00:17:01,260 --> 00:17:04,150
favorites crate

00:17:02,410 --> 00:17:06,429
people define some of its own

00:17:04,150 --> 00:17:09,280
implementations of favorite color for

00:17:06,429 --> 00:17:11,199
its own types this gives us the complete

00:17:09,280 --> 00:17:14,140
program shown on the left

00:17:11,199 --> 00:17:17,020
now what chalk wants to do is it wants

00:17:14,140 --> 00:17:20,020
to lower this entire program that means

00:17:17,020 --> 00:17:23,100
all three crates into a single logical

00:17:20,020 --> 00:17:25,480
program made up of facts and rules

00:17:23,100 --> 00:17:27,220
there's a whole bunch of facts that we

00:17:25,480 --> 00:17:29,919
could actually potentially get from this

00:17:27,220 --> 00:17:32,140
program for example we could describe

00:17:29,919 --> 00:17:34,210
the relationship between the crates and

00:17:32,140 --> 00:17:36,880
add something like depends on people

00:17:34,210 --> 00:17:38,830
favorites to talk about how the people

00:17:36,880 --> 00:17:41,409
crate depends on the favorite the

00:17:38,830 --> 00:17:44,830
favorites crate or we could add some

00:17:41,409 --> 00:17:47,860
clauses like defined in Sanjay people or

00:17:44,830 --> 00:17:50,110
defined in Manish people to describe how

00:17:47,860 --> 00:17:50,919
those two structs are defined and the

00:17:50,110 --> 00:17:54,010
people crate

00:17:50,919 --> 00:17:55,659
these are hypothetical but my point is

00:17:54,010 --> 00:17:57,700
that you can lower a program into any

00:17:55,659 --> 00:18:01,390
set of facts that you can derive from it

00:17:57,700 --> 00:18:03,090
in reality chalk would lower the program

00:18:01,390 --> 00:18:05,260
into something that looks like this I've

00:18:03,090 --> 00:18:07,059
filtered out some of the facts that

00:18:05,260 --> 00:18:09,309
aren't relevant to what we're about to

00:18:07,059 --> 00:18:11,049
talk about next but you can probably see

00:18:09,309 --> 00:18:13,030
where most of this information is coming

00:18:11,049 --> 00:18:14,950
from I mentioned that we're currently

00:18:13,030 --> 00:18:18,490
compiling the people crate

00:18:14,950 --> 00:18:21,520
so the sunjai and Manish types are local

00:18:18,490 --> 00:18:23,620
to the current crate chalk represents

00:18:21,520 --> 00:18:26,340
this by lowering these two structs into

00:18:23,620 --> 00:18:29,770
two facts using the is local predicate

00:18:26,340 --> 00:18:32,950
we lower the two implementations of the

00:18:29,770 --> 00:18:36,250
favorite color trade by adding two facts

00:18:32,950 --> 00:18:38,710
using the implemented predicate the taco

00:18:36,250 --> 00:18:40,419
type which is defined in the crate that

00:18:38,710 --> 00:18:43,720
the current crate the people crate

00:18:40,419 --> 00:18:46,960
depends on is an upstream type we can

00:18:43,720 --> 00:18:49,169
lower it to represent that with a fact

00:18:46,960 --> 00:18:51,970
that uses the is upstream predicate

00:18:49,169 --> 00:18:54,070
notice that each of these predicates

00:18:51,970 --> 00:18:56,830
represents a concept that we can clearly

00:18:54,070 --> 00:18:59,049
see in the code the reason that any of

00:18:56,830 --> 00:19:01,870
these exists at all is because we

00:18:59,049 --> 00:19:03,280
decided that they're important and we

00:19:01,870 --> 00:19:05,500
decided that there's something that we

00:19:03,280 --> 00:19:07,900
needed to use in order to model whatever

00:19:05,500 --> 00:19:10,360
we're modeling we literally could have

00:19:07,900 --> 00:19:13,809
created any predicate at all based on

00:19:10,360 --> 00:19:16,300
what's in the program the final line of

00:19:13,809 --> 00:19:20,170
this lower program is probably the most

00:19:16,300 --> 00:19:23,740
ding there we create a rule that

00:19:20,170 --> 00:19:27,960
describes that any type T implements

00:19:23,740 --> 00:19:30,580
favorite color if T also implements copy

00:19:27,960 --> 00:19:32,650
you may not see it perfectly just yet

00:19:30,580 --> 00:19:34,360
but it's pretty amazing that we're able

00:19:32,650 --> 00:19:37,660
to take the rust code on the Left

00:19:34,360 --> 00:19:39,900
extract its essence and put it into the

00:19:37,660 --> 00:19:42,580
logical representation on the right in

00:19:39,900 --> 00:19:44,170
the next section of this talk we're

00:19:42,580 --> 00:19:46,630
going to see how this allows us to

00:19:44,170 --> 00:19:48,760
elegantly represent the very complex

00:19:46,630 --> 00:19:53,110
orphan rules that we described earlier

00:19:48,760 --> 00:19:55,450
in terms of logic so there's a lot of

00:19:53,110 --> 00:19:57,700
details about chalk and lowering process

00:19:55,450 --> 00:19:59,020
which I couldn't get into today but if

00:19:57,700 --> 00:20:02,110
you're interested in finding out more

00:19:59,020 --> 00:20:04,840
the online rusty guide actually has an

00:20:02,110 --> 00:20:10,390
entire section on the new style trait

00:20:04,840 --> 00:20:12,130
solving implemented in chalk ok so

00:20:10,390 --> 00:20:14,230
remember all that stuff about the orphan

00:20:12,130 --> 00:20:16,420
rules we're gonna bring everything

00:20:14,230 --> 00:20:19,120
together now and talk about how the

00:20:16,420 --> 00:20:23,080
orphan check is actually implemented in

00:20:19,120 --> 00:20:24,730
chalk before we start though let's

00:20:23,080 --> 00:20:26,290
quickly do one more example of the

00:20:24,730 --> 00:20:29,200
orphan rules to make sure that we've

00:20:26,290 --> 00:20:31,870
definitely got it let's say that we have

00:20:29,200 --> 00:20:35,890
a crate foo which defines a trait called

00:20:31,870 --> 00:20:38,650
my trait and a type foo we also have the

00:20:35,890 --> 00:20:42,100
bark rate which depends on foo and

00:20:38,650 --> 00:20:46,150
defines its own type bar as well as an

00:20:42,100 --> 00:20:49,060
imp of my trait for bar the orphan check

00:20:46,150 --> 00:20:51,100
will look at that info and try to decide

00:20:49,060 --> 00:20:54,520
if it's valid under the orphan rules

00:20:51,100 --> 00:20:57,070
when we compile bar my trait is

00:20:54,520 --> 00:20:59,380
considered to be an upstream trait that

00:20:57,070 --> 00:21:02,740
means that based on the orphan rules we

00:20:59,380 --> 00:21:05,530
have to do some more checking we can't

00:21:02,740 --> 00:21:09,370
just implement that type directly we

00:21:05,530 --> 00:21:12,190
have to check a foo bar and then tea in

00:21:09,370 --> 00:21:16,750
order in order to look for a local type

00:21:12,190 --> 00:21:19,600
in this case the first local type in the

00:21:16,750 --> 00:21:21,400
bar crate is the bar type and once we

00:21:19,600 --> 00:21:23,740
find that we need to check every type

00:21:21,400 --> 00:21:26,110
before it to make sure that those types

00:21:23,740 --> 00:21:30,020
don't contain any of the type parameters

00:21:26,110 --> 00:21:33,350
of the imple the term we're going to use

00:21:30,020 --> 00:21:36,020
four types that don't contain any of the

00:21:33,350 --> 00:21:37,760
imple type parameters is fully visible

00:21:36,020 --> 00:21:41,450
and you'll see why that is in a few

00:21:37,760 --> 00:21:43,880
minutes but a fully visible type is made

00:21:41,450 --> 00:21:46,760
up of types that aren't completely known

00:21:43,880 --> 00:21:51,110
to us and can't be filled with some

00:21:46,760 --> 00:21:53,539
other type later this is all we need in

00:21:51,110 --> 00:21:56,630
order to check that the simple is good

00:21:53,539 --> 00:21:59,659
to go one important observation here is

00:21:56,630 --> 00:22:02,260
that any types after the first local

00:21:59,659 --> 00:22:05,539
type don't actually matter at all

00:22:02,260 --> 00:22:08,179
according to the orphan rules that means

00:22:05,539 --> 00:22:10,640
that we can put any type after bar at

00:22:08,179 --> 00:22:11,840
all including type parameters even

00:22:10,640 --> 00:22:14,240
though we weren't allowed to include

00:22:11,840 --> 00:22:17,419
those before bar in the order of the

00:22:14,240 --> 00:22:20,330
type parameters so now let's talk about

00:22:17,419 --> 00:22:22,730
how this gets implemented in chalk well

00:22:20,330 --> 00:22:25,220
the idea is that we create a new

00:22:22,730 --> 00:22:28,309
predicate called local impo allowed

00:22:25,220 --> 00:22:30,260
which describes when a type is allowed

00:22:28,309 --> 00:22:34,070
to implement a trade under the orphaned

00:22:30,260 --> 00:22:36,350
laws then we can go through each type or

00:22:34,070 --> 00:22:39,080
sorry then we can go through each imple

00:22:36,350 --> 00:22:42,200
in our program and ask whether local

00:22:39,080 --> 00:22:45,440
imple allowed is provable for that imple

00:22:42,200 --> 00:22:47,450
if it is then we can move on but if that

00:22:45,440 --> 00:22:49,159
isn't provable we know that the orphan

00:22:47,450 --> 00:22:52,309
rules have been violated and that we

00:22:49,159 --> 00:22:55,100
need to produce an error here the turtle

00:22:52,309 --> 00:22:56,539
type is local so we know that we can

00:22:55,100 --> 00:22:59,240
implement display for it

00:22:56,539 --> 00:23:01,850
but in the other example a vector of

00:22:59,240 --> 00:23:04,760
Turtles is not local to the current

00:23:01,850 --> 00:23:07,130
crate because Veck is defined in the STD

00:23:04,760 --> 00:23:09,500
crate that means that we can't implement

00:23:07,130 --> 00:23:13,610
display for a vector of turtles

00:23:09,500 --> 00:23:16,940
according to the orphan rules okay so

00:23:13,610 --> 00:23:19,190
how do we create local imploded well

00:23:16,940 --> 00:23:21,409
more specifically we need to ask what

00:23:19,190 --> 00:23:23,450
are the lowering rules for a local in

00:23:21,409 --> 00:23:26,960
Palau like how are we going to lower

00:23:23,450 --> 00:23:30,380
each trait that we come across in a rust

00:23:26,960 --> 00:23:32,149
program well we can figure this out by

00:23:30,380 --> 00:23:35,059
going through each case of the orphan

00:23:32,149 --> 00:23:38,690
rules let's say that we had this trait

00:23:35,059 --> 00:23:41,029
with two type parameters we know based

00:23:38,690 --> 00:23:43,760
on which crate the trait comes from

00:23:41,029 --> 00:23:47,090
whether that trait is local

00:23:43,760 --> 00:23:49,880
or if that trait is up strength if that

00:23:47,090 --> 00:23:52,940
trait is locally defined in the current

00:23:49,880 --> 00:23:55,910
crate we generate a local in Palau drool

00:23:52,940 --> 00:23:59,510
that allows any type to be implemented

00:23:55,910 --> 00:24:01,760
for that trait this rule says that my

00:23:59,510 --> 00:24:05,720
trait is allowed to be implemented for

00:24:01,760 --> 00:24:08,030
any types at all if the trait is

00:24:05,720 --> 00:24:10,610
upstream we need to check those other

00:24:08,030 --> 00:24:13,490
conditions that we went over earlier we

00:24:10,610 --> 00:24:15,790
need at least one local type and for

00:24:13,490 --> 00:24:19,640
every type before it to be fully visible

00:24:15,790 --> 00:24:23,330
the tricky thing here is that we need to

00:24:19,640 --> 00:24:25,250
somehow find the first local type we can

00:24:23,330 --> 00:24:28,490
do that by taking advantage of the fact

00:24:25,250 --> 00:24:30,590
that during lowering we know exactly how

00:24:28,490 --> 00:24:33,920
many type parameters there are in the

00:24:30,590 --> 00:24:36,880
trait we can add one rule for every case

00:24:33,920 --> 00:24:39,800
of where the local type might end up if

00:24:36,880 --> 00:24:41,930
any of these rules are satisfied the

00:24:39,800 --> 00:24:46,820
imple is considered valid under the

00:24:41,930 --> 00:24:49,370
orphan rules now these rules are

00:24:46,820 --> 00:24:51,830
basically an exact translation of the

00:24:49,370 --> 00:24:54,230
English sentence find the first local

00:24:51,830 --> 00:24:57,620
type and make sure that each type before

00:24:54,230 --> 00:24:59,420
it is fully visible the problem is that

00:24:57,620 --> 00:25:02,450
we actually haven't defined any of the

00:24:59,420 --> 00:25:04,610
main parts of that sentence like when is

00:25:02,450 --> 00:25:07,100
the fully visible predicate actually

00:25:04,610 --> 00:25:09,080
provable when is is local provable we

00:25:07,100 --> 00:25:12,920
aren't actually finished until we talk

00:25:09,080 --> 00:25:15,470
about is fully visible and is local so

00:25:12,920 --> 00:25:17,420
let's start by talking about is fully

00:25:15,470 --> 00:25:19,790
visible this one is pretty

00:25:17,420 --> 00:25:22,130
straightforward because we really just

00:25:19,790 --> 00:25:25,310
want to make sure that it isn't provable

00:25:22,130 --> 00:25:27,770
for types that aren't defined in some

00:25:25,310 --> 00:25:29,930
crate somewhere we want it to be

00:25:27,770 --> 00:25:31,790
provable for all the types we can see

00:25:29,930 --> 00:25:34,490
right that's where visible comes from

00:25:31,790 --> 00:25:37,820
but we don't want it to be provable for

00:25:34,490 --> 00:25:41,090
any of those type parameters to do that

00:25:37,820 --> 00:25:44,120
we can add a fact for every struct in

00:25:41,090 --> 00:25:46,910
every crate that uses the is fully

00:25:44,120 --> 00:25:50,180
visible predicate to indicate that it is

00:25:46,910 --> 00:25:52,460
a type that's fully visible since type

00:25:50,180 --> 00:25:55,580
parameters won't have any such fact is

00:25:52,460 --> 00:25:57,910
fully visible won't be provable for

00:25:55,580 --> 00:26:00,470
those type parameters

00:25:57,910 --> 00:26:03,350
we can make sure that is fully visible

00:26:00,470 --> 00:26:07,070
doesn't allow any type parameters at any

00:26:03,350 --> 00:26:09,500
level by making sure that we use if and

00:26:07,070 --> 00:26:12,860
checking that each type parameter of

00:26:09,500 --> 00:26:14,540
every structure is also fully visible in

00:26:12,860 --> 00:26:19,910
order for the structure to be fully

00:26:14,540 --> 00:26:22,460
visible itself for is local we just need

00:26:19,910 --> 00:26:24,950
to take every strut defined in the

00:26:22,460 --> 00:26:28,309
current crate and lower it into a fact

00:26:24,950 --> 00:26:30,260
using the is local predicate in this

00:26:28,309 --> 00:26:32,330
case we don't actually care about any of

00:26:30,260 --> 00:26:35,330
the type parameters that these types may

00:26:32,330 --> 00:26:37,970
have because a type is local regardless

00:26:35,330 --> 00:26:40,610
of its type parameters notice that I've

00:26:37,970 --> 00:26:42,980
only added an is local fact for foo

00:26:40,610 --> 00:26:45,830
because that's the only type in the

00:26:42,980 --> 00:26:49,610
current crate and bar is an upstream

00:26:45,830 --> 00:26:52,040
type so there's a couple of things that

00:26:49,610 --> 00:26:54,080
I've left out here for example I didn't

00:26:52,040 --> 00:26:56,240
cover how is local interacts with

00:26:54,080 --> 00:26:57,890
fundamental types if you don't know what

00:26:56,240 --> 00:26:59,780
a fundamental type you can absolutely

00:26:57,890 --> 00:27:03,740
come up to me afterwards and talk to me

00:26:59,780 --> 00:27:05,660
about this and if you'd like to know

00:27:03,740 --> 00:27:07,300
more about any of this or how it works

00:27:05,660 --> 00:27:09,440
you can also come and ask me about that

00:27:07,300 --> 00:27:12,620
but all this is actually fully

00:27:09,440 --> 00:27:14,660
implemented in chalk right now rusty

00:27:12,620 --> 00:27:17,270
doesn't actually use chalk internally

00:27:14,660 --> 00:27:19,160
just yet but you can expect that one day

00:27:17,270 --> 00:27:21,050
your rust code might be checked with

00:27:19,160 --> 00:27:24,470
logical queries like the ones I've

00:27:21,050 --> 00:27:27,830
demonstrated today the other part of

00:27:24,470 --> 00:27:30,650
coherence is the overlap check this is

00:27:27,830 --> 00:27:32,990
currently an active area of research in

00:27:30,650 --> 00:27:35,600
my own work and just like with the

00:27:32,990 --> 00:27:38,240
orphan check my job is to figure out how

00:27:35,600 --> 00:27:41,030
to model this using logic the tricky

00:27:38,240 --> 00:27:43,160
part about the orphan check is what I

00:27:41,030 --> 00:27:46,760
mentioned before we need some way to

00:27:43,160 --> 00:27:49,250
model all possible compatible Impuls in

00:27:46,760 --> 00:27:51,410
the entire universe in order to make

00:27:49,250 --> 00:27:53,360
sure that you haven't overlapped with an

00:27:51,410 --> 00:27:56,030
impolite may be possible to define

00:27:53,360 --> 00:27:57,620
somewhere else I have some ideas about

00:27:56,030 --> 00:28:01,220
this but the research is still

00:27:57,620 --> 00:28:02,780
definitely ongoing well thanks for

00:28:01,220 --> 00:28:05,690
listening to my talk we talked about

00:28:02,780 --> 00:28:09,290
coherence logic programming and went

00:28:05,690 --> 00:28:10,580
over some examples of how we are using

00:28:09,290 --> 00:28:13,120
logic to model

00:28:10,580 --> 00:28:14,990
various parts of the rest rate system I

00:28:13,120 --> 00:28:17,120
definitely wouldn't have been able to do

00:28:14,990 --> 00:28:19,010
this without the help of a lot of great

00:28:17,120 --> 00:28:21,740
people so I just wanted to take a moment

00:28:19,010 --> 00:28:23,870
to thank Nikko boats and the many other

00:28:21,740 --> 00:28:27,350
awesome people that have helped me

00:28:23,870 --> 00:28:29,630
figure all this out thank you here's my

00:28:27,350 --> 00:28:33,580
Twitter and a link to these slides and

00:28:29,630 --> 00:28:33,580
I'll be around for questions as well

00:28:34,430 --> 00:28:39,869
[Applause]

00:28:46,179 --> 00:28:52,070
cool so I really like the idea of using

00:28:50,059 --> 00:28:53,360
a logic language or logic programming

00:28:52,070 --> 00:28:55,789
language to model this and I'm curious

00:28:53,360 --> 00:28:57,289
if you feel like let's say something

00:28:55,789 --> 00:29:01,100
violates these rules

00:28:57,289 --> 00:29:02,990
does it seem feasible to determine given

00:29:01,100 --> 00:29:04,580
a violation turn it into a human

00:29:02,990 --> 00:29:06,470
readable explanation like if I want to

00:29:04,580 --> 00:29:08,000
understand you know why my thing was

00:29:06,470 --> 00:29:10,519
there wasn't an orphan and that could be

00:29:08,000 --> 00:29:12,889
some complex series of visibility rules

00:29:10,519 --> 00:29:14,450
and so on like that it's that something

00:29:12,889 --> 00:29:16,010
I'll have looked at or I mean does it

00:29:14,450 --> 00:29:18,080
seem feasible to provide some sort of

00:29:16,010 --> 00:29:19,190
translation layer from given these rules

00:29:18,080 --> 00:29:20,480
were violated to turn that into

00:29:19,190 --> 00:29:23,179
something I could spit out of the

00:29:20,480 --> 00:29:25,519
compiler yeah we actually already do

00:29:23,179 --> 00:29:27,169
this right so we have coherence checking

00:29:25,519 --> 00:29:29,240
already implementing the rest compiler

00:29:27,169 --> 00:29:31,399
it's just not implemented using logic

00:29:29,240 --> 00:29:33,490
it's implemented in rust and so we

00:29:31,399 --> 00:29:35,779
already produce error messages like that

00:29:33,490 --> 00:29:37,220
that give you a lot of details and tell

00:29:35,779 --> 00:29:39,830
you exactly what went wrong so what

00:29:37,220 --> 00:29:41,570
we'll probably end up happening is with

00:29:39,830 --> 00:29:44,990
this implementation you'll get enough

00:29:41,570 --> 00:29:46,730
information back to just know like oh

00:29:44,990 --> 00:29:48,380
okay this is what went wrong and then

00:29:46,730 --> 00:29:52,880
we'll be able to produce the same or

00:29:48,380 --> 00:29:53,690
better error messages using that quick

00:29:52,880 --> 00:29:55,220
fault I guess I'm just trying to

00:29:53,690 --> 00:29:56,929
understand like say if you change the

00:29:55,220 --> 00:29:59,269
rules or added a new rule like to what

00:29:56,929 --> 00:30:00,919
extent is that process just done almost

00:29:59,269 --> 00:30:01,970
automatically by the by the fact of the

00:30:00,919 --> 00:30:03,620
design of your logic programming

00:30:01,970 --> 00:30:05,330
language or is it like you would have to

00:30:03,620 --> 00:30:07,870
very carefully craft your error messages

00:30:05,330 --> 00:30:10,279
to each new change to your logic system

00:30:07,870 --> 00:30:12,169
no I think it would it would work about

00:30:10,279 --> 00:30:13,850
the same as it does now so you wouldn't

00:30:12,169 --> 00:30:15,830
have to necessarily change anything

00:30:13,850 --> 00:30:20,799
unless you change the orphan rules right

00:30:15,830 --> 00:30:20,799
yeah any other questions

00:30:24,080 --> 00:30:30,510
so I was looking at the the coherence

00:30:27,450 --> 00:30:34,010
definition there and I am extremely

00:30:30,510 --> 00:30:37,830
confused by why the the is fully visible

00:30:34,010 --> 00:30:40,410
predicate only covers all types up to

00:30:37,830 --> 00:30:44,100
the locally found type is there some

00:30:40,410 --> 00:30:45,690
sort of arcane reason for that the

00:30:44,100 --> 00:30:47,160
chance to do with like what order type

00:30:45,690 --> 00:30:48,480
inference and this I mean I did soon

00:30:47,160 --> 00:30:50,610
this already happens when type after

00:30:48,480 --> 00:30:53,640
this is all done like why why is why is

00:30:50,610 --> 00:30:56,580
that a is that even necessary really or

00:30:53,640 --> 00:30:58,050
is this just yeah so I mentioned how you

00:30:56,580 --> 00:31:00,180
know these rules kind of seem pretty

00:30:58,050 --> 00:31:01,500
arbitrary and and complex and it's

00:31:00,180 --> 00:31:03,030
because they really do like that's

00:31:01,500 --> 00:31:05,040
something that I personally had to

00:31:03,030 --> 00:31:06,720
grapple with a lot and that's nothing I

00:31:05,040 --> 00:31:08,340
bugged Nikko about a lot but if you read

00:31:06,720 --> 00:31:10,740
through some of those blog posts that I

00:31:08,340 --> 00:31:12,420
talked about they describe the reasoning

00:31:10,740 --> 00:31:15,150
behind the rules and why they work the

00:31:12,420 --> 00:31:18,690
way they do and and basically the goal

00:31:15,150 --> 00:31:21,090
is to ensure that every imple can only

00:31:18,690 --> 00:31:24,690
be just it can only be implemented in

00:31:21,090 --> 00:31:27,150
one crate right and so we have to have

00:31:24,690 --> 00:31:30,060
some sort of local type there because

00:31:27,150 --> 00:31:32,250
that way you have to use a type in your

00:31:30,060 --> 00:31:34,860
current crate in order to implement a

00:31:32,250 --> 00:31:36,990
trait right and then as for the ordering

00:31:34,860 --> 00:31:39,390
acquirements there's also some reasoning

00:31:36,990 --> 00:31:42,090
behind that that goes towards that goal

00:31:39,390 --> 00:31:48,300
of only having one place to implement

00:31:42,090 --> 00:31:51,270
that in that trait for those types does

00:31:48,300 --> 00:31:52,500
that answer your question right but I

00:31:51,270 --> 00:31:54,210
guess we'll have to be satisfied with

00:31:52,500 --> 00:31:56,130
that for now since it seems you should

00:31:54,210 --> 00:31:57,510
definitely take a look at the resources

00:31:56,130 --> 00:32:00,440
that I link to they go in a lot of

00:31:57,510 --> 00:32:00,440
detail about this

00:32:02,450 --> 00:32:05,719
[Music]

00:32:09,519 --> 00:32:13,940
so while they explained that any other

00:32:12,679 --> 00:32:14,419
questions or do you have any more

00:32:13,940 --> 00:32:18,830
questions

00:32:14,419 --> 00:32:22,009
no I'm good okay this is all nice but

00:32:18,830 --> 00:32:23,269
like as a normal user of rust yeah I'm a

00:32:22,009 --> 00:32:25,909
very normal use of rust I don't know

00:32:23,269 --> 00:32:28,279
much as a normal user of rust

00:32:25,909 --> 00:32:30,950
yeah as a normal user of rust who

00:32:28,279 --> 00:32:34,609
actually doesn't know prologue how does

00:32:30,950 --> 00:32:36,259
this impact me alright so so this

00:32:34,609 --> 00:32:39,350
impacts you in a couple of ways so the

00:32:36,259 --> 00:32:42,080
reason that we're talking about logic

00:32:39,350 --> 00:32:45,320
programming in general is because it

00:32:42,080 --> 00:32:48,470
gives us a lot of really cool benefits

00:32:45,320 --> 00:32:51,289
to the implementation of the trait

00:32:48,470 --> 00:32:52,460
system so right now and again I don't

00:32:51,289 --> 00:32:53,869
know anything about the current

00:32:52,460 --> 00:32:56,059
implementation of the trait system but

00:32:53,869 --> 00:32:57,590
what I've been told is that right now

00:32:56,059 --> 00:32:59,809
the current implementation of the trade

00:32:57,590 --> 00:33:01,369
system is sort of ad hoc and it's it's

00:32:59,809 --> 00:33:02,840
like it's it's right and it's all over

00:33:01,369 --> 00:33:05,899
the place it's very difficult to debug

00:33:02,840 --> 00:33:08,899
or change or do anything to and so the

00:33:05,899 --> 00:33:12,049
idea with this is that we sort of remove

00:33:08,899 --> 00:33:14,539
that entire layer and just have these

00:33:12,049 --> 00:33:17,600
logical rules that we can run in a very

00:33:14,539 --> 00:33:19,820
general you know logic programming

00:33:17,600 --> 00:33:23,769
engine and and then solve

00:33:19,820 --> 00:33:27,230
and so while you as a as a rust user

00:33:23,769 --> 00:33:28,609
won't necessarily see the impact right

00:33:27,230 --> 00:33:31,429
away because this is supposed to be a

00:33:28,609 --> 00:33:33,529
drop-in replacement what it will do is

00:33:31,429 --> 00:33:36,919
it'll enable us to do cool things like

00:33:33,529 --> 00:33:38,450
really fast incremental compilation and

00:33:36,919 --> 00:33:40,549
all kinds of other things that will

00:33:38,450 --> 00:33:45,830
eventually benefit the busers of the

00:33:40,549 --> 00:33:47,480
rest compiler quite a bit I'm curious

00:33:45,830 --> 00:33:50,539
you said that it was gonna be a drop-in

00:33:47,480 --> 00:33:54,679
replacement and what are the performance

00:33:50,539 --> 00:33:57,049
implications of anything if any as far

00:33:54,679 --> 00:34:00,859
as I know never had as far as I know we

00:33:57,049 --> 00:34:04,629
don't know yet but it should be just as

00:34:00,859 --> 00:34:10,510
good otherwise we wouldn't do it perfect

00:34:04,629 --> 00:34:10,510
we'll have to see any other questions

00:34:16,589 --> 00:34:21,940
you described chalk as a logic

00:34:19,629 --> 00:34:25,119
programming language but you only talk

00:34:21,940 --> 00:34:27,819
about in terms of implementing a type

00:34:25,119 --> 00:34:29,349
checker to what extent is chalk a

00:34:27,819 --> 00:34:33,089
general-purpose programming language

00:34:29,349 --> 00:34:35,230
with things like syntax and compilation

00:34:33,089 --> 00:34:37,210
versus just being a part of the RUS

00:34:35,230 --> 00:34:39,579
compiler and is there any effort being

00:34:37,210 --> 00:34:41,619
is there any effort toward turning it

00:34:39,579 --> 00:34:43,480
into a general-purpose language that

00:34:41,619 --> 00:34:46,179
anybody can use for any purpose sorry I

00:34:43,480 --> 00:34:47,950
should have clarified chalk itself is

00:34:46,179 --> 00:34:50,740
not a logic programming language chalk

00:34:47,950 --> 00:34:52,480
is based off of existing logic

00:34:50,740 --> 00:34:54,490
programming languages it's an

00:34:52,480 --> 00:34:56,919
implementation of an engine that can

00:34:54,490 --> 00:34:58,990
solve certain queries within a logic

00:34:56,919 --> 00:35:00,430
programming language and it's entirely

00:34:58,990 --> 00:35:02,950
catered towards Russ

00:35:00,430 --> 00:35:04,599
so like chalk has its own syntax which

00:35:02,950 --> 00:35:06,970
we use just for testing it's not

00:35:04,599 --> 00:35:09,430
actually used with rust code and it

00:35:06,970 --> 00:35:11,500
helps us write tests that sort of look

00:35:09,430 --> 00:35:13,690
like rust code and so you could say that

00:35:11,500 --> 00:35:17,140
the chalk syntax looks like rust code

00:35:13,690 --> 00:35:19,450
but there really isn't any plans to make

00:35:17,140 --> 00:35:21,549
chalk into a general-purpose language or

00:35:19,450 --> 00:35:25,000
anything like that it's just designed to

00:35:21,549 --> 00:35:29,140
be used to implement to re-implement the

00:35:25,000 --> 00:35:31,960
trait system I've been brought into

00:35:29,140 --> 00:35:34,509
asking you whether or not this has any

00:35:31,960 --> 00:35:36,009
consequences in the realm of this

00:35:34,509 --> 00:35:39,039
magical thing we've been wanting for a

00:35:36,009 --> 00:35:42,220
very long time called associated type

00:35:39,039 --> 00:35:44,950
constructors some types have something

00:35:42,220 --> 00:35:46,990
to do with yes higher kind of types and

00:35:44,950 --> 00:35:48,869
and the magical M word are you talking

00:35:46,990 --> 00:35:51,759
about generic associated types and yes

00:35:48,869 --> 00:35:54,069
yeah so so yeah for sure it's like chalk

00:35:51,759 --> 00:35:55,660
already supports generic associated

00:35:54,069 --> 00:36:01,000
types if you don't know what those are

00:35:55,660 --> 00:36:03,789
don't worry about it like it already

00:36:01,000 --> 00:36:06,869
supports a lot of really cool extensions

00:36:03,789 --> 00:36:10,599
to the trade system and the idea behind

00:36:06,869 --> 00:36:12,460
doing chalk like itself is that we can

00:36:10,599 --> 00:36:14,470
add these sorts of extensions really

00:36:12,460 --> 00:36:16,539
easily right because it's just a couple

00:36:14,470 --> 00:36:19,240
more rules it's a different set of

00:36:16,539 --> 00:36:21,099
lowering things right and so we can

00:36:19,240 --> 00:36:22,480
actually extend the trade system very

00:36:21,099 --> 00:36:25,570
easily and start to add these features

00:36:22,480 --> 00:36:29,940
faster if we have a more principled well

00:36:25,570 --> 00:36:29,940
and implementation of the trade system

00:36:34,470 --> 00:36:40,120
so I've heard that in Prolog the the

00:36:37,570 --> 00:36:41,740
search strategy for basically resolving

00:36:40,120 --> 00:36:43,570
predicates it's actually fairly

00:36:41,740 --> 00:36:45,550
constrained by the specification because

00:36:43,570 --> 00:36:47,080
Prolog involves things like side-effects

00:36:45,550 --> 00:36:49,300
and cups and things like that do you

00:36:47,080 --> 00:36:50,710
know if choc engine is somehow more

00:36:49,300 --> 00:36:52,030
flexible on the kind of search strategy

00:36:50,710 --> 00:36:54,460
can used if you can get any kind of

00:36:52,030 --> 00:36:57,250
optimizations from that so right now our

00:36:54,460 --> 00:36:59,170
solver isn't actually based off of a

00:36:57,250 --> 00:37:03,820
Prolog implementation I think it started

00:36:59,170 --> 00:37:05,290
that way there's a paper I forget the

00:37:03,820 --> 00:37:08,050
exact title it's in my backpack right

00:37:05,290 --> 00:37:11,440
there it's I haven't read it but it's in

00:37:08,050 --> 00:37:14,410
my backpack great thing and and it talks

00:37:11,440 --> 00:37:17,680
about something called a hereditary

00:37:14,410 --> 00:37:20,080
harap formulas and so there's there's a

00:37:17,680 --> 00:37:22,960
paper it's called a proof procedure for

00:37:20,080 --> 00:37:26,800
hereditary Harrop formulas and so we use

00:37:22,960 --> 00:37:28,870
a modified implementation of that so we

00:37:26,800 --> 00:37:31,630
probably don't have some of the

00:37:28,870 --> 00:37:33,190
downsides of a regular Prolog solver

00:37:31,630 --> 00:37:35,710
because we're not using Prolog directly

00:37:33,190 --> 00:37:38,080
but there are other limitations like a

00:37:35,710 --> 00:37:40,660
lot of the research that I have to do

00:37:38,080 --> 00:37:42,490
next has to do with the impact of

00:37:40,660 --> 00:37:44,380
negative reasoning like you know

00:37:42,490 --> 00:37:47,890
negating a query putting not in front of

00:37:44,380 --> 00:37:49,630
it and what that does like like what

00:37:47,890 --> 00:37:55,510
impact that has on the solver and what

00:37:49,630 --> 00:38:02,890
it can solve cool thank you any other

00:37:55,510 --> 00:38:06,330
questions last one okay somebody pass

00:38:02,890 --> 00:38:06,330
along the mic to over there

00:38:11,560 --> 00:38:15,250
so there's currently also an effort to

00:38:13,780 --> 00:38:17,740
reformulate the borrow checker in terms

00:38:15,250 --> 00:38:21,130
of logic programming based don't want to

00:38:17,740 --> 00:38:23,530
seen it seems like the the data log

00:38:21,130 --> 00:38:25,330
engine that it's using is a less

00:38:23,530 --> 00:38:27,070
powerful form of logic than what chalk

00:38:25,330 --> 00:38:29,140
is using like what's the relationship

00:38:27,070 --> 00:38:31,119
between those two efforts I have no idea

00:38:29,140 --> 00:38:34,119
but so I've read the I've read the blog

00:38:31,119 --> 00:38:35,290
post that Nikko put out but Nikko would

00:38:34,119 --> 00:38:41,680
definitely be the right person to ask

00:38:35,290 --> 00:38:42,930
about that stuff anyone else okay thank

00:38:41,680 --> 00:38:51,820
you very much

00:38:42,930 --> 00:38:51,820

YouTube URL: https://www.youtube.com/watch?v=rZqS4bLPL24


