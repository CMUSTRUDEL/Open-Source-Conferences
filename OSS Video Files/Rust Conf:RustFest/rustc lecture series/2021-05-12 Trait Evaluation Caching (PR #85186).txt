Title: 2021-05-12 Trait Evaluation Caching (PR #85186)
Publication date: 2021-05-12
Playlist: rustc lecture series
Description: 
	Niko and Jack Huey walking through how caching of trait evaluation works. The context is explaining PR #85186.
Captions: 
	00:00:00,320 --> 00:00:07,759
so let's see so there is this

00:00:05,120 --> 00:00:09,360
also this assertion failure we could

00:00:07,759 --> 00:00:10,400
either i can either walk you through the

00:00:09,360 --> 00:00:13,040
idea

00:00:10,400 --> 00:00:14,000
or we can try to debug this together or

00:00:13,040 --> 00:00:17,600
both

00:00:14,000 --> 00:00:18,640
um i'm not for either

00:00:17,600 --> 00:00:21,680
all right why don't we go through the

00:00:18,640 --> 00:00:24,720
first high level idea and then

00:00:21,680 --> 00:00:26,480
um proceed

00:00:24,720 --> 00:00:27,760
to maybe debugging will give us a nice

00:00:26,480 --> 00:00:29,359
like

00:00:27,760 --> 00:00:30,800
way to explore the code in a purposeful

00:00:29,359 --> 00:00:33,840
fashion but um

00:00:30,800 --> 00:00:37,520
the uh

00:00:33,840 --> 00:00:37,520
right so the idea so

00:00:40,079 --> 00:00:44,399
actually what i um trying to decide

00:00:43,200 --> 00:00:46,000
i guess i'll walk through the what's on

00:00:44,399 --> 00:00:47,280
the branch exactly and then we'll go

00:00:46,000 --> 00:00:49,600
from there i have a little

00:00:47,280 --> 00:00:51,680
i like my i have a different branch

00:00:49,600 --> 00:00:53,360
where i refactored the code to isolate

00:00:51,680 --> 00:00:55,760
out

00:00:53,360 --> 00:00:58,000
the stack logic and i think it's easier

00:00:55,760 --> 00:01:01,120
to follow but

00:00:58,000 --> 00:01:05,040
it might be confusing um

00:01:01,120 --> 00:01:09,360
if i started with that so i won't uh

00:01:05,040 --> 00:01:12,240
what do i want i want select mod so

00:01:09,360 --> 00:01:13,119
i don't this is annoying dude do you

00:01:12,240 --> 00:01:14,479
have this problem

00:01:13,119 --> 00:01:16,640
maybe there's i should figure out how

00:01:14,479 --> 00:01:19,200
there's got to be a way to tell it like

00:01:16,640 --> 00:01:20,960
i'm not interested in all of them please

00:01:19,200 --> 00:01:25,439
put them at the bottom of the list

00:01:20,960 --> 00:01:27,119
yeah i have that problem sometimes um

00:01:25,439 --> 00:01:28,640
yeah i don't know it turns out like

00:01:27,119 --> 00:01:31,759
every unique substring

00:01:28,640 --> 00:01:33,520
appears in lvm somewhere uh and

00:01:31,759 --> 00:01:35,680
often many times yeah it doesn't

00:01:33,520 --> 00:01:38,799
surprise me also we do

00:01:35,680 --> 00:01:42,079
use a lot of the same words like

00:01:38,799 --> 00:01:45,759
also both compilers anyway

00:01:42,079 --> 00:01:49,280
okay so right so trade evaluation

00:01:45,759 --> 00:01:52,399
is a fairly straightforward

00:01:49,280 --> 00:01:55,439
process in which we

00:01:52,399 --> 00:01:58,880
do a basically a sort of depth first

00:01:55,439 --> 00:02:00,399
search down to try to decide if a trait

00:01:58,880 --> 00:02:04,320
might be implemented

00:02:00,399 --> 00:02:06,799
it's not entirely clear why it exists

00:02:04,320 --> 00:02:08,560
in addition to the other mode of

00:02:06,799 --> 00:02:09,440
evaluating traits except that nico

00:02:08,560 --> 00:02:11,200
didn't know what what

00:02:09,440 --> 00:02:12,640
he was doing when he first implemented

00:02:11,200 --> 00:02:16,160
this code and it

00:02:12,640 --> 00:02:20,000
grew into this structure uh but

00:02:16,160 --> 00:02:21,920
that's all right um it has wait so

00:02:20,000 --> 00:02:23,920
what do you mean by different than the

00:02:21,920 --> 00:02:25,520
other way of evaluating

00:02:23,920 --> 00:02:27,040
so there's two ways that the compiler

00:02:25,520 --> 00:02:29,200
evaluates traits

00:02:27,040 --> 00:02:30,879
they're connected and interrelated and

00:02:29,200 --> 00:02:32,959
not entirely separable

00:02:30,879 --> 00:02:34,560
there's the fulfillment context and the

00:02:32,959 --> 00:02:36,879
evaluation logic

00:02:34,560 --> 00:02:39,200
okay and the fulfillment context sort of

00:02:36,879 --> 00:02:39,200
does a

00:02:39,280 --> 00:02:42,560
i'll call it a breath first search

00:02:40,720 --> 00:02:43,599
that's that's not really true

00:02:42,560 --> 00:02:45,360
that's actually maybe just kind of

00:02:43,599 --> 00:02:47,599
misleading but it basically keeps a

00:02:45,360 --> 00:02:51,040
queue of work to do

00:02:47,599 --> 00:02:55,280
and if you have to prove that one

00:02:51,040 --> 00:02:57,519
impul is or that t implements some trait

00:02:55,280 --> 00:02:59,440
some type t implements some trait it

00:02:57,519 --> 00:03:03,440
will figure out which impul

00:02:59,440 --> 00:03:06,400
you're using and take the where clauses

00:03:03,440 --> 00:03:07,200
from that impul and add them to that

00:03:06,400 --> 00:03:09,120
queue

00:03:07,200 --> 00:03:10,640
right so that's like one distinct step

00:03:09,120 --> 00:03:11,599
that's trait selection or i call that

00:03:10,640 --> 00:03:13,519
trade selection

00:03:11,599 --> 00:03:14,640
right uh is picking which input you're

00:03:13,519 --> 00:03:17,680
going to use but

00:03:14,640 --> 00:03:21,120
it does that without necessarily knowing

00:03:17,680 --> 00:03:22,959
that the where clauses are satisfied

00:03:21,120 --> 00:03:24,319
the problem is and this is where the two

00:03:22,959 --> 00:03:25,680
systems arose that was the first

00:03:24,319 --> 00:03:27,120
inspiration for how it should work and

00:03:25,680 --> 00:03:29,760
in old rust

00:03:27,120 --> 00:03:31,200
when that was implemented like we didn't

00:03:29,760 --> 00:03:32,480
have we didn't even have and actually

00:03:31,200 --> 00:03:33,280
didn't really have where clauses for the

00:03:32,480 --> 00:03:36,959
most part

00:03:33,280 --> 00:03:38,879
so it wasn't that complicated to do uh

00:03:36,959 --> 00:03:42,239
and we had where clauses i guess but we

00:03:38,879 --> 00:03:45,200
did we didn't have

00:03:42,239 --> 00:03:46,480
uh our coherence rules were much simpler

00:03:45,200 --> 00:03:48,080
such that like

00:03:46,480 --> 00:03:50,319
basically only one at most one input

00:03:48,080 --> 00:03:52,480
would unify so

00:03:50,319 --> 00:03:53,840
that was fairly straightforward and then

00:03:52,480 --> 00:03:57,439
when we tried to extend it

00:03:53,840 --> 00:03:58,799
to allow for things like i have an impul

00:03:57,439 --> 00:04:01,120
for all things that are cloned and an

00:03:58,799 --> 00:04:03,360
impulse for something that's not cloned

00:04:01,120 --> 00:04:04,239
uh we had this problem that we couldn't

00:04:03,360 --> 00:04:06,159
pick

00:04:04,239 --> 00:04:07,920
in the same way and so we added trait

00:04:06,159 --> 00:04:10,640
evaluation

00:04:07,920 --> 00:04:11,360
which basically tries to figure out is

00:04:10,640 --> 00:04:12,799
this type

00:04:11,360 --> 00:04:14,480
it does instead of instead of like

00:04:12,799 --> 00:04:16,799
unrolling and pushing things onto the

00:04:14,480 --> 00:04:19,600
queue it tries to go

00:04:16,799 --> 00:04:21,199
down all the way and figure out do all

00:04:19,600 --> 00:04:22,880
the where clauses

00:04:21,199 --> 00:04:25,440
are they all satisfied all the way down

00:04:22,880 --> 00:04:28,080
can i just fully prove this out

00:04:25,440 --> 00:04:30,880
um and it's not always it's sort of a

00:04:28,080 --> 00:04:32,400
try value right like it comes back with

00:04:30,880 --> 00:04:33,919
well it comes back with an evaluation

00:04:32,400 --> 00:04:37,759
result

00:04:33,919 --> 00:04:40,320
which is um either like yes

00:04:37,759 --> 00:04:41,840
or probably but there's some region

00:04:40,320 --> 00:04:43,840
relationships i couldn't verify because

00:04:41,840 --> 00:04:46,479
i don't know how to do that

00:04:43,840 --> 00:04:47,440
uh or i couldn't tell one way or the

00:04:46,479 --> 00:04:48,800
other

00:04:47,440 --> 00:04:50,560
or some other variation of i couldn't

00:04:48,800 --> 00:04:53,919
tell one way or the other

00:04:50,560 --> 00:04:55,360
or uh you know no it does not

00:04:53,919 --> 00:04:57,120
there's no such impulse that could

00:04:55,360 --> 00:04:57,919
potentially apply and recur is like

00:04:57,120 --> 00:05:01,120
another thing

00:04:57,919 --> 00:05:04,800
um and so that's for cycles and stuff

00:05:01,120 --> 00:05:05,680
um and so right so the code is fairly

00:05:04,800 --> 00:05:07,440
straightforward

00:05:05,680 --> 00:05:08,960
like proving the trait predicate so we

00:05:07,440 --> 00:05:10,880
have this stack i guess that's the other

00:05:08,960 --> 00:05:14,639
thing uh we keep a stack

00:05:10,880 --> 00:05:18,639
of the context in which we had to

00:05:14,639 --> 00:05:20,160
prove something um when we're doing the

00:05:18,639 --> 00:05:21,680
at the fulfillment context level that

00:05:20,160 --> 00:05:24,160
stack is always empty like everything

00:05:21,680 --> 00:05:25,919
the fulfillment context

00:05:24,160 --> 00:05:27,680
starts to work on is the top of the root

00:05:25,919 --> 00:05:29,280
of the stack it's the first thing is

00:05:27,680 --> 00:05:30,400
finding the impul that applies for a

00:05:29,280 --> 00:05:31,360
given

00:05:30,400 --> 00:05:33,360
thing but when we're doing the

00:05:31,360 --> 00:05:34,800
evaluation we can go deeper in where

00:05:33,360 --> 00:05:35,919
we're processing the where clause and

00:05:34,800 --> 00:05:36,400
then the where clauses of the where

00:05:35,919 --> 00:05:39,680
clause

00:05:36,400 --> 00:05:43,280
and so forth um and

00:05:39,680 --> 00:05:44,800
this is the stack type um it is well

00:05:43,280 --> 00:05:46,000
actually this is an iterator this is the

00:05:44,800 --> 00:05:49,600
stack type

00:05:46,000 --> 00:05:53,360
um and it's just a linked list so

00:05:49,600 --> 00:05:56,240
it has a reference to the previous

00:05:53,360 --> 00:05:58,000
element on the stack and then this is

00:05:56,240 --> 00:06:01,680
the top of the stack

00:05:58,000 --> 00:06:04,720
um it's a link increase your font size

00:06:01,680 --> 00:06:07,840
like one two yeah good point

00:06:04,720 --> 00:06:11,919
um maybe uh control plus

00:06:07,840 --> 00:06:16,639
i think um

00:06:11,919 --> 00:06:16,639
let's zoom in does that work

00:06:17,280 --> 00:06:21,840
okay yeah is that better yes thank you

00:06:20,160 --> 00:06:24,880
uh

00:06:21,840 --> 00:06:28,080
so yeah this is the top of the stack

00:06:24,880 --> 00:06:29,680
we push things on by calling well by

00:06:28,080 --> 00:06:31,280
building another one of these structs

00:06:29,680 --> 00:06:33,280
with a reference to the previous top of

00:06:31,280 --> 00:06:35,600
the stack so it actually

00:06:33,280 --> 00:06:36,880
walks up the real program stack as well

00:06:35,600 --> 00:06:39,120
um

00:06:36,880 --> 00:06:39,120
and

00:06:40,080 --> 00:06:46,160
um jumping like my chalk hat on

00:06:43,919 --> 00:06:47,680
i'm like thinking about how this is

00:06:46,160 --> 00:06:49,120
similar and different

00:06:47,680 --> 00:06:51,840
yeah it's similar to the recursive

00:06:49,120 --> 00:06:53,199
silver you know

00:06:51,840 --> 00:06:55,440
but different in certain respects that

00:06:53,199 --> 00:06:58,479
i'm about to go into um

00:06:55,440 --> 00:07:01,759
so and but this pr is

00:06:58,479 --> 00:07:03,840
among other things moving them

00:07:01,759 --> 00:07:05,360
moving the evaluation model closer and

00:07:03,840 --> 00:07:08,319
closer to

00:07:05,360 --> 00:07:10,880
how the recursive solver works and like

00:07:08,319 --> 00:07:12,160
to shift gears to chalk ever so slightly

00:07:10,880 --> 00:07:14,000
i haven't fully mapped this out in my

00:07:12,160 --> 00:07:15,120
head yet but i do think one way to get

00:07:14,000 --> 00:07:17,039
chalk into rusty

00:07:15,120 --> 00:07:18,800
as we were sort of discussing is to

00:07:17,039 --> 00:07:22,639
tweak how rusty

00:07:18,800 --> 00:07:23,919
works so that it uses the evaluation

00:07:22,639 --> 00:07:25,440
more and more which we've also been

00:07:23,919 --> 00:07:26,400
moving from time to time for various

00:07:25,440 --> 00:07:28,240
other reasons

00:07:26,400 --> 00:07:30,240
and then but like the more we're able to

00:07:28,240 --> 00:07:31,680
lean on this instead of the fulfillment

00:07:30,240 --> 00:07:34,639
model the closer we're getting

00:07:31,680 --> 00:07:35,840
to how chalk's going to interact and

00:07:34,639 --> 00:07:36,720
that could be useful and then we can

00:07:35,840 --> 00:07:38,960
also bring

00:07:36,720 --> 00:07:40,479
like lessons from chalk to make this

00:07:38,960 --> 00:07:41,680
evaluation system

00:07:40,479 --> 00:07:45,440
better because it has certain

00:07:41,680 --> 00:07:47,360
limitations um so

00:07:45,440 --> 00:07:49,120
right evaluation starts here at this

00:07:47,360 --> 00:07:52,879
evaluate trade predicate

00:07:49,120 --> 00:07:53,680
recursively um which gets called by some

00:07:52,879 --> 00:07:54,879
other

00:07:53,680 --> 00:07:57,520
it doesn't really start here but the

00:07:54,879 --> 00:08:00,879
interesting stuff starts here uh

00:07:57,520 --> 00:08:05,120
and first thing it does is push

00:08:00,879 --> 00:08:06,639
so here's the old stack we're gonna push

00:08:05,120 --> 00:08:08,319
push onto the stack which means make a

00:08:06,639 --> 00:08:10,840
new struct if you go through you'll see

00:08:08,319 --> 00:08:13,039
it just instantiates one of those

00:08:10,840 --> 00:08:15,360
instances um

00:08:13,039 --> 00:08:17,120
we track the depth and this will be

00:08:15,360 --> 00:08:18,720
important we track this depth first

00:08:17,120 --> 00:08:20,639
number

00:08:18,720 --> 00:08:22,000
that's familiar to you from chalk i'm

00:08:20,639 --> 00:08:23,840
sure it's just a counter

00:08:22,000 --> 00:08:25,199
that increments the difference between

00:08:23,840 --> 00:08:26,720
them is when things get popped off the

00:08:25,199 --> 00:08:28,240
stack the depth goes down but the depth

00:08:26,720 --> 00:08:30,080
first number never changes or it just

00:08:28,240 --> 00:08:33,360
keeps going it's monotonic

00:08:30,080 --> 00:08:36,560
um which is useful uh

00:08:33,360 --> 00:08:37,760
so then we do some

00:08:36,560 --> 00:08:38,880
i'm going to ignore this caching

00:08:37,760 --> 00:08:40,080
although it's going to turn out to be

00:08:38,880 --> 00:08:42,240
pretty important

00:08:40,080 --> 00:08:44,640
but for now let's ignore it because the

00:08:42,240 --> 00:08:47,920
whole the whole bug is around caching

00:08:44,640 --> 00:08:50,080
so it will be important but um

00:08:47,920 --> 00:08:51,680
we look for a cycle that doesn't well

00:08:50,080 --> 00:08:53,279
that will also become relevant but let's

00:08:51,680 --> 00:08:57,120
ignore it for the moment

00:08:53,279 --> 00:08:59,839
uh and then we do this thing

00:08:57,120 --> 00:09:01,680
evaluate stack so this what does the

00:08:59,839 --> 00:09:03,760
actual work this is like

00:09:01,680 --> 00:09:05,200
okay i have a stack i want to check if

00:09:03,760 --> 00:09:07,120
the thing on the top of the stack is

00:09:05,200 --> 00:09:10,399
true false whatever

00:09:07,120 --> 00:09:11,839
true false are unknown and um

00:09:10,399 --> 00:09:13,839
i've already had the cat i've already

00:09:11,839 --> 00:09:15,200
looked for cycles and checked the cache

00:09:13,839 --> 00:09:18,320
and done all that stuff just

00:09:15,200 --> 00:09:20,839
do the actual work um so what does it do

00:09:18,320 --> 00:09:23,760
um ignore this stuff this has to do with

00:09:20,839 --> 00:09:26,560
coherence uh

00:09:23,760 --> 00:09:27,200
and it's basically it's it's basically

00:09:26,560 --> 00:09:30,320
uh

00:09:27,200 --> 00:09:30,320
makes us fail to

00:09:30,560 --> 00:09:34,160
i don't know i forget what this does who

00:09:32,000 --> 00:09:36,480
cares something with coherence and

00:09:34,160 --> 00:09:38,720
like making us not try to prove things

00:09:36,480 --> 00:09:38,720
that

00:09:39,040 --> 00:09:43,920
would be bad for coherence um this is

00:09:42,080 --> 00:09:46,000
the interesting part

00:09:43,920 --> 00:09:47,920
so here we call candidate from

00:09:46,000 --> 00:09:50,560
obligation

00:09:47,920 --> 00:09:51,120
what that does is it finds so a

00:09:50,560 --> 00:09:52,720
candidate

00:09:51,120 --> 00:09:54,240
in the parlance of this code is

00:09:52,720 --> 00:09:57,839
basically

00:09:54,240 --> 00:09:59,760
a way to prove that a trait holds

00:09:57,839 --> 00:10:01,680
and so this is the this is the point

00:09:59,760 --> 00:10:04,240
where this is one of the points where we

00:10:01,680 --> 00:10:04,959
break from chalk and from a traditional

00:10:04,240 --> 00:10:08,959
like a more

00:10:04,959 --> 00:10:10,640
capable deer improver uh because

00:10:08,959 --> 00:10:12,720
really what we should probably get back

00:10:10,640 --> 00:10:15,200
here is a vector of candidates

00:10:12,720 --> 00:10:17,200
um there can be many ways to prove that

00:10:15,200 --> 00:10:18,560
the thing that the tree holds

00:10:17,200 --> 00:10:20,720
and it sort of doesn't matter which one

00:10:18,560 --> 00:10:23,920
we do as long as we have one

00:10:20,720 --> 00:10:25,920
however we force ourselves to return one

00:10:23,920 --> 00:10:27,519
with some horrible heuristics that

00:10:25,920 --> 00:10:28,640
you're vaguely familiar with and that we

00:10:27,519 --> 00:10:29,680
will not go into here because they're

00:10:28,640 --> 00:10:33,200
not relevant

00:10:29,680 --> 00:10:34,560
um and so we get back we get back one of

00:10:33,200 --> 00:10:36,399
these options either we get back a

00:10:34,560 --> 00:10:38,240
selection candidate

00:10:36,399 --> 00:10:39,440
that means we found what we think of as

00:10:38,240 --> 00:10:41,680
the right way to go

00:10:39,440 --> 00:10:44,079
we found the impul let's take the easy

00:10:41,680 --> 00:10:46,959
case there's exactly one impul that

00:10:44,079 --> 00:10:47,279
unifies and might apply this will this

00:10:46,959 --> 00:10:48,720
will

00:10:47,279 --> 00:10:50,560
information about that input will be in

00:10:48,720 --> 00:10:53,839
c if we get back none

00:10:50,560 --> 00:10:55,680
it means there were ways to go but we

00:10:53,839 --> 00:10:57,519
couldn't figure out

00:10:55,680 --> 00:10:58,720
which one there were too many impulse

00:10:57,519 --> 00:10:59,680
that might have applied and we couldn't

00:10:58,720 --> 00:11:01,440
narrow it down

00:10:59,680 --> 00:11:03,040
that could happen if there's inference

00:11:01,440 --> 00:11:05,680
variables for example like if we

00:11:03,040 --> 00:11:06,399
if we're trying to prove that question

00:11:05,680 --> 00:11:08,640
mark t

00:11:06,399 --> 00:11:09,440
implements a trait that could be any

00:11:08,640 --> 00:11:11,680
impul

00:11:09,440 --> 00:11:13,360
so so long as there's at least two

00:11:11,680 --> 00:11:16,480
impulse

00:11:13,360 --> 00:11:16,480
we're stuck um

00:11:16,800 --> 00:11:21,279
uh or where clauses stuff like that

00:11:19,279 --> 00:11:23,440
overflow is overflow and otherwise if we

00:11:21,279 --> 00:11:24,880
get back air here it means

00:11:23,440 --> 00:11:26,240
there was no impul that might apply

00:11:24,880 --> 00:11:26,880
there was no candidate we couldn't find

00:11:26,240 --> 00:11:30,320
one

00:11:26,880 --> 00:11:32,800
um is it just me or would like an enum

00:11:30,320 --> 00:11:36,560
here make more sense than a nested

00:11:32,800 --> 00:11:39,920
option result it's not just you

00:11:36,560 --> 00:11:41,680
um yeah i don't know we might use

00:11:39,920 --> 00:11:44,560
question mark

00:11:41,680 --> 00:11:45,680
yeah this yeah there are some things

00:11:44,560 --> 00:11:47,200
that could be improved

00:11:45,680 --> 00:11:48,800
uh for one thing i noticed as we're

00:11:47,200 --> 00:11:51,360
walking through here that

00:11:48,800 --> 00:11:52,480
also like air is used somewhat

00:11:51,360 --> 00:11:55,600
differently

00:11:52,480 --> 00:11:58,160
right like for evaluation you can have

00:11:55,600 --> 00:12:00,480
an okay with a evaluated to error

00:11:58,160 --> 00:12:02,079
and an error is just used for overflow

00:12:00,480 --> 00:12:03,440
but for candidate error means no

00:12:02,079 --> 00:12:06,560
candidates

00:12:03,440 --> 00:12:10,399
which is a little confusing uh

00:12:06,560 --> 00:12:12,800
yeah you're not wrong so nonetheless

00:12:10,399 --> 00:12:14,959
the happy path is we found a candidate

00:12:12,800 --> 00:12:17,760
we jump in to evaluate candidate

00:12:14,959 --> 00:12:19,360
what does evaluate candidate do um

00:12:17,760 --> 00:12:22,000
evaluation probe just

00:12:19,360 --> 00:12:24,000
prevents muta uh inference variable side

00:12:22,000 --> 00:12:28,399
effects from leaking outside

00:12:24,000 --> 00:12:31,279
so what confirm candidate does is it

00:12:28,399 --> 00:12:32,000
takes the like we figured out which

00:12:31,279 --> 00:12:34,959
impul

00:12:32,000 --> 00:12:37,040
applies confirm candidate will unify all

00:12:34,959 --> 00:12:40,079
the types from the impul with the types

00:12:37,040 --> 00:12:43,040
of the thing we're trying to prove so as

00:12:40,079 --> 00:12:43,040
an example if we had

00:12:43,279 --> 00:12:49,279
an impul if we were trying to prove like

00:12:46,560 --> 00:12:51,360
option of question mark t is foo and

00:12:49,279 --> 00:12:54,160
there's exactly one impul of

00:12:51,360 --> 00:12:56,399
foo that was like impul fu for option of

00:12:54,160 --> 00:12:58,480
i32

00:12:56,399 --> 00:13:02,320
then this confirmed candidate would

00:12:58,480 --> 00:13:05,519
unify question mark t with i32

00:13:02,320 --> 00:13:08,800
more commonly it goes the other way that

00:13:05,519 --> 00:13:11,440
we have a type that we know

00:13:08,800 --> 00:13:12,639
and an inference variable which arises

00:13:11,440 --> 00:13:14,399
out of the input like we

00:13:12,639 --> 00:13:15,760
replace t with a fresh infant's variable

00:13:14,399 --> 00:13:17,920
as part of the conformation

00:13:15,760 --> 00:13:20,480
and then we unify them and so t becomes

00:13:17,920 --> 00:13:24,079
unified with i-32 i32

00:13:20,480 --> 00:13:26,320
but then we get back from this a list of

00:13:24,079 --> 00:13:29,360
um well we get back what's called an

00:13:26,320 --> 00:13:29,360
impulse source which is

00:13:29,440 --> 00:13:32,639
kind of related to the canon it's sort

00:13:31,040 --> 00:13:34,000
of the information

00:13:32,639 --> 00:13:35,760
but the main thing that's in there that

00:13:34,000 --> 00:13:38,160
we're

00:13:35,760 --> 00:13:41,040
interested in is this nested obligations

00:13:38,160 --> 00:13:41,920
which is basically the where clauses

00:13:41,040 --> 00:13:44,639
and so then we're going to go

00:13:41,920 --> 00:13:48,320
recursively evaluate them

00:13:44,639 --> 00:13:49,680
and say like okay well the impul applied

00:13:48,320 --> 00:13:50,959
we were able to unify the impul

00:13:49,680 --> 00:13:52,480
everything succeeded

00:13:50,959 --> 00:13:54,079
now let's check if the where clauses

00:13:52,480 --> 00:13:55,279
apply and that's that's the whole

00:13:54,079 --> 00:13:59,199
recursive

00:13:55,279 --> 00:14:00,399
concept so far so good um

00:13:59,199 --> 00:14:03,600
all right we're going to pop back up

00:14:00,399 --> 00:14:06,880
this is actually the root of evaluation

00:14:03,600 --> 00:14:08,240
evaluate predicate um not i sure before

00:14:06,880 --> 00:14:09,920
i showed you like evaluate trade

00:14:08,240 --> 00:14:11,600
predicate which is called here

00:14:09,920 --> 00:14:13,120
but that's just one case because there's

00:14:11,600 --> 00:14:15,360
different kinds of predicates but most

00:14:13,120 --> 00:14:17,839
of the others are not that interesting

00:14:15,360 --> 00:14:18,480
like if for example we're forced to

00:14:17,839 --> 00:14:21,199
prove some

00:14:18,480 --> 00:14:22,880
region relationship we can just say yeah

00:14:21,199 --> 00:14:26,720
that seems good

00:14:22,880 --> 00:14:28,720
it's good as far as we know uh and

00:14:26,720 --> 00:14:31,199
uh there's like some other stuff here

00:14:28,720 --> 00:14:35,680
but it sort of bottoms out to

00:14:31,199 --> 00:14:38,079
this is the main case okay um

00:14:35,680 --> 00:14:39,360
so jumping back i want to talk about the

00:14:38,079 --> 00:14:42,079
caching

00:14:39,360 --> 00:14:43,440
and the cycles let's talk about cycles

00:14:42,079 --> 00:14:47,279
first

00:14:43,440 --> 00:14:50,800
um so what do we do

00:14:47,279 --> 00:14:51,360
where did i that's the other problem i

00:14:50,800 --> 00:14:56,480
have with

00:14:51,360 --> 00:14:57,760
vs code is the back is like

00:14:56,480 --> 00:15:00,160
it's good because it has like every

00:14:57,760 --> 00:15:01,600
place my cursor landed but

00:15:00,160 --> 00:15:03,199
sometimes it takes me a while to find

00:15:01,600 --> 00:15:06,880
the one i

00:15:03,199 --> 00:15:08,480
i want okay now there's a pack option so

00:15:06,880 --> 00:15:10,839
oh yeah i don't know how you live

00:15:08,480 --> 00:15:13,839
without that

00:15:10,839 --> 00:15:16,560
control dash on mac but it changes on

00:15:13,839 --> 00:15:19,920
other platforms

00:15:16,560 --> 00:15:22,079
um so

00:15:19,920 --> 00:15:23,040
check evaluation cache uh that's not

00:15:22,079 --> 00:15:24,959
what we're talking about talking about

00:15:23,040 --> 00:15:27,920
check evaluation cycle

00:15:24,959 --> 00:15:30,320
um so we have the stack and the main

00:15:27,920 --> 00:15:33,519
reason we actually have the stack

00:15:30,320 --> 00:15:33,519
is so that we can

00:15:33,680 --> 00:15:36,639
sorry just having a little thought oh

00:15:35,120 --> 00:15:37,759
right i remember now so that we can

00:15:36,639 --> 00:15:41,600
detect cycles

00:15:37,759 --> 00:15:44,720
um and what do we do

00:15:41,600 --> 00:15:46,399
we iterate it's very simple we basically

00:15:44,720 --> 00:15:49,199
iterate up the stack

00:15:46,399 --> 00:15:50,480
looking for something where we have the

00:15:49,199 --> 00:15:52,399
same thing we have to prove

00:15:50,480 --> 00:15:54,560
or the environment is the same and the

00:15:52,399 --> 00:15:57,600
thing we're trying to prove is the same

00:15:54,560 --> 00:15:58,639
fresh trait ref uh

00:15:57,600 --> 00:16:00,639
that's an old version of

00:15:58,639 --> 00:16:02,399
canonicalization

00:16:00,639 --> 00:16:04,720
where inference variables get replaced

00:16:02,399 --> 00:16:04,720
with a

00:16:05,440 --> 00:16:08,959
like an integer that is ordered by their

00:16:07,600 --> 00:16:10,079
appearance

00:16:08,959 --> 00:16:12,240
it's basically the same as

00:16:10,079 --> 00:16:13,199
canonicalization we just have two ways

00:16:12,240 --> 00:16:15,680
to do it

00:16:13,199 --> 00:16:17,360
that are similar but different uh

00:16:15,680 --> 00:16:21,360
because this one was done first

00:16:17,360 --> 00:16:26,480
um that's great yes isn't it

00:16:21,360 --> 00:16:26,480
uh so um

00:16:26,800 --> 00:16:30,720
right so we we iterate over the stack we

00:16:29,360 --> 00:16:31,519
look and see if any of them are there if

00:16:30,720 --> 00:16:34,399
there is one

00:16:31,519 --> 00:16:36,480
we extract its depth and we say okay we

00:16:34,399 --> 00:16:37,680
found a cycle

00:16:36,480 --> 00:16:39,519
and this is where the assertion is

00:16:37,680 --> 00:16:41,759
failing as an aside or one of the places

00:16:39,519 --> 00:16:43,360
it might be failing

00:16:41,759 --> 00:16:45,040
and then we call update reach depth so

00:16:43,360 --> 00:16:46,160
what is that what happens is for

00:16:45,040 --> 00:16:50,320
everything on the stack

00:16:46,160 --> 00:16:53,680
we are tracking what is the oh

00:16:50,320 --> 00:16:54,880
what is the f up and down are always

00:16:53,680 --> 00:16:58,480
kind of problematic

00:16:54,880 --> 00:17:01,519
what's the oldest thing on the stack

00:16:58,480 --> 00:17:03,040
that you depended on right so if i if

00:17:01,519 --> 00:17:05,280
if there's no cycle then it's just going

00:17:03,040 --> 00:17:07,360
to be yourself basically so

00:17:05,280 --> 00:17:08,559
i depend on in order to prove that t

00:17:07,360 --> 00:17:10,240
implemented foo

00:17:08,559 --> 00:17:12,160
i had to prove that to implement flu

00:17:10,240 --> 00:17:13,839
that seems fine but if you end up with a

00:17:12,160 --> 00:17:15,199
cycle like

00:17:13,839 --> 00:17:17,199
usually with auto traits here's an

00:17:15,199 --> 00:17:19,120
example right here

00:17:17,199 --> 00:17:20,880
like you're proving foo of t is send

00:17:19,120 --> 00:17:22,720
that requires proving bar of t is n and

00:17:20,880 --> 00:17:24,319
maybe bar has a foo inside of it

00:17:22,720 --> 00:17:26,160
so then i have to prove the foo of t is

00:17:24,319 --> 00:17:29,200
send again

00:17:26,160 --> 00:17:31,760
then i would update the reached depth of

00:17:29,200 --> 00:17:32,799
bar of t to be equal to the depth of the

00:17:31,760 --> 00:17:35,039
foo of t

00:17:32,799 --> 00:17:36,160
so if this was zero and that was one and

00:17:35,039 --> 00:17:37,600
that's

00:17:36,160 --> 00:17:39,360
well that's two but it does never get

00:17:37,600 --> 00:17:40,000
pushed then this would have a reach

00:17:39,360 --> 00:17:44,720
depth of

00:17:40,000 --> 00:17:48,080
zero um and

00:17:44,720 --> 00:17:51,200
that's useful because that tells me that

00:17:48,080 --> 00:17:54,559
in order that tells me that um

00:17:51,200 --> 00:17:59,039
especially for the co-inductive cases

00:17:54,559 --> 00:18:00,880
bar of send is true so long as

00:17:59,039 --> 00:18:02,480
the things that were higher on the stack

00:18:00,880 --> 00:18:05,360
up to the reached depth

00:18:02,480 --> 00:18:06,400
are also true it's kind of conditionally

00:18:05,360 --> 00:18:10,080
true

00:18:06,400 --> 00:18:12,640
um or provisionally true

00:18:10,080 --> 00:18:13,360
right so that's what the checking cycle

00:18:12,640 --> 00:18:16,480
basically does

00:18:13,360 --> 00:18:18,320
it tracks how high did you go it checks

00:18:16,480 --> 00:18:19,520
if it's a co-inductive

00:18:18,320 --> 00:18:21,840
if everything in that cycle is

00:18:19,520 --> 00:18:24,480
co-inductive in which case it's okay

00:18:21,840 --> 00:18:24,960
but we updated the depth otherwise it

00:18:24,480 --> 00:18:29,280
does this

00:18:24,960 --> 00:18:32,480
evaluated to recur which

00:18:29,280 --> 00:18:35,039
um either way we're going to stop

00:18:32,480 --> 00:18:38,400
right so either we reach the cycle which

00:18:35,039 --> 00:18:38,400
will be treated as a kind of error

00:18:38,880 --> 00:18:43,280
or we are considering it okay but we we

00:18:41,919 --> 00:18:43,760
had to mark things on the stack to

00:18:43,280 --> 00:18:47,200
indicate

00:18:43,760 --> 00:18:48,400
that was like a provisional okay um

00:18:47,200 --> 00:18:50,559
and so that's where we come to this

00:18:48,400 --> 00:18:53,919
caching business so then

00:18:50,559 --> 00:18:54,720
assuming zooming out now if we were

00:18:53,919 --> 00:18:57,760
doing that

00:18:54,720 --> 00:18:59,520
this case of fubar foo when we're

00:18:57,760 --> 00:19:00,400
processing foo the first time there's no

00:18:59,520 --> 00:19:02,640
cycle

00:19:00,400 --> 00:19:03,440
we go into the evaluate stack we come in

00:19:02,640 --> 00:19:06,480
here for bar

00:19:03,440 --> 00:19:07,840
no cycle we go into evaluate stack now

00:19:06,480 --> 00:19:10,320
we come back for foo

00:19:07,840 --> 00:19:11,360
we hit a cycle we're going to mark bars

00:19:10,320 --> 00:19:15,039
having reached

00:19:11,360 --> 00:19:16,720
an earlier depth and return

00:19:15,039 --> 00:19:17,919
and then we're going to come back and

00:19:16,720 --> 00:19:19,039
now we're still at the point where we're

00:19:17,919 --> 00:19:21,360
proving bar

00:19:19,039 --> 00:19:23,200
so we basically will have proved

00:19:21,360 --> 00:19:24,960
evaluate stack will have returned okay

00:19:23,200 --> 00:19:27,600
because that cycle

00:19:24,960 --> 00:19:30,880
was checked and returned okay so we now

00:19:27,600 --> 00:19:30,880
think okay bar is proven

00:19:31,520 --> 00:19:36,400
and ignore this for a second we're going

00:19:33,919 --> 00:19:40,480
to look here at what depth did you reach

00:19:36,400 --> 00:19:44,400
and the question is if it is

00:19:40,480 --> 00:19:45,120
uh if if you never depended on anything

00:19:44,400 --> 00:19:46,880
above you

00:19:45,120 --> 00:19:48,559
in the stack or older than you i should

00:19:46,880 --> 00:19:50,240
really stick to older anything older

00:19:48,559 --> 00:19:52,240
than you on the stack

00:19:50,240 --> 00:19:54,000
then you're kind of self-complete right

00:19:52,240 --> 00:19:55,520
so so you're done

00:19:54,000 --> 00:19:57,520
but in our case where we're processing

00:19:55,520 --> 00:19:58,640
bar bar depended on foo which was older

00:19:57,520 --> 00:20:02,320
in the stack

00:19:58,640 --> 00:20:04,000
and therefore um we can't consider that

00:20:02,320 --> 00:20:06,799
to be completely evaluated so we use

00:20:04,000 --> 00:20:08,559
this thing called a provisional cache

00:20:06,799 --> 00:20:11,919
and the idea is that essentially

00:20:08,559 --> 00:20:15,120
attached to the stack itself

00:20:11,919 --> 00:20:18,240
we have a cache we have several caches

00:20:15,120 --> 00:20:19,679
at different layers depending on how how

00:20:18,240 --> 00:20:22,480
true

00:20:19,679 --> 00:20:23,440
that thing is but for our purpose for

00:20:22,480 --> 00:20:26,000
this particular

00:20:23,440 --> 00:20:26,640
bug we can just think about two caches

00:20:26,000 --> 00:20:28,799
there's like

00:20:26,640 --> 00:20:30,559
the global cache for stuff that we

00:20:28,799 --> 00:20:32,559
really know is true

00:20:30,559 --> 00:20:34,000
and then there's the provisional cache

00:20:32,559 --> 00:20:36,480
which is attached to our stack

00:20:34,000 --> 00:20:37,039
which is saying we proved this to be

00:20:36,480 --> 00:20:38,480
true but

00:20:37,039 --> 00:20:41,039
it was subject to something that's still

00:20:38,480 --> 00:20:41,039
on the stack

00:20:41,600 --> 00:20:45,520
um so it's true it's true unless that

00:20:44,240 --> 00:20:49,200
thing turns out to be false

00:20:45,520 --> 00:20:52,480
um and we'll track we pass in

00:20:49,200 --> 00:20:54,000
what was our depth first number

00:20:52,480 --> 00:20:56,799
what was the depth that we're dependent

00:20:54,000 --> 00:20:59,360
on and what was the result

00:20:56,799 --> 00:21:00,480
um and now when you come back if for

00:20:59,360 --> 00:21:05,200
example

00:21:00,480 --> 00:21:06,640
you had foo of t had to prove bar of t

00:21:05,200 --> 00:21:08,640
then bar of t would be added as a

00:21:06,640 --> 00:21:10,480
provisional cash hit

00:21:08,640 --> 00:21:12,880
because of the cycle but now suppose

00:21:10,480 --> 00:21:16,240
that then foo has to prove baz

00:21:12,880 --> 00:21:19,679
and baz has to prove bar as well

00:21:16,240 --> 00:21:20,159
okay uh now we have another cycle

00:21:19,679 --> 00:21:22,320
because

00:21:20,159 --> 00:21:24,159
or if we went and recursively processed

00:21:22,320 --> 00:21:26,240
bar again

00:21:24,159 --> 00:21:27,840
if we ignore the caching we would we

00:21:26,240 --> 00:21:29,360
would get a cycle just like before

00:21:27,840 --> 00:21:31,679
where bar would depend on foo and it

00:21:29,360 --> 00:21:33,760
would mark um

00:21:31,679 --> 00:21:34,720
bar would depend on foo let me put the

00:21:33,760 --> 00:21:36,559
comments because i'm

00:21:34,720 --> 00:21:39,039
it's clear in my there's a visualization

00:21:36,559 --> 00:21:42,080
in my brain but it may not be in yours

00:21:39,039 --> 00:21:43,919
uh i'm gonna write out though i think i

00:21:42,080 --> 00:21:45,039
can do it but for the people who are

00:21:43,919 --> 00:21:46,640
watching the recording

00:21:45,039 --> 00:21:48,720
it would definitely be helpful that's

00:21:46,640 --> 00:21:50,159
what i'm imagining um so we basically

00:21:48,720 --> 00:21:51,919
had let's let's replay it

00:21:50,159 --> 00:21:53,600
we started out with foo we pushed bar

00:21:51,919 --> 00:21:57,280
into the stack

00:21:53,600 --> 00:21:59,440
we pushed foo we got a cycle right

00:21:57,280 --> 00:22:01,120
then we marked bar as reached depth

00:21:59,440 --> 00:22:03,919
equals zero

00:22:01,120 --> 00:22:06,640
um processing that cycle and we marked

00:22:03,919 --> 00:22:06,640
this as okay

00:22:06,799 --> 00:22:13,039
then here we would consider this okay

00:22:10,000 --> 00:22:14,080
because all of its children are okay but

00:22:13,039 --> 00:22:17,679
then suppose that

00:22:14,080 --> 00:22:20,880
for foo let's add like depends on

00:22:17,679 --> 00:22:22,480
bar bass so

00:22:20,880 --> 00:22:23,919
in order to prove foo was true we had to

00:22:22,480 --> 00:22:24,559
prove bar and best so we started by

00:22:23,919 --> 00:22:26,240
proving

00:22:24,559 --> 00:22:28,960
bar which we have done and then we went

00:22:26,240 --> 00:22:28,960
to prove baz

00:22:31,039 --> 00:22:37,679
um baz let's say depends on

00:22:34,640 --> 00:22:39,200
bar okay

00:22:37,679 --> 00:22:41,120
so then what we're gonna do i'm just

00:22:39,200 --> 00:22:43,840
going to ignore caching for a second

00:22:41,120 --> 00:22:45,840
pretend we did everything with no caches

00:22:43,840 --> 00:22:48,159
at all

00:22:45,840 --> 00:22:48,880
then we would go to bar and we would say

00:22:48,159 --> 00:22:53,280
okay

00:22:48,880 --> 00:22:57,039
well bar depends on foo just like before

00:22:53,280 --> 00:22:57,039
we'll push foo here's a cycle

00:22:57,120 --> 00:23:00,559
you could think of this as a cycle

00:22:59,600 --> 00:23:04,000
reached

00:23:00,559 --> 00:23:05,440
depth equals zero okay

00:23:04,000 --> 00:23:07,280
you can sort of see i'm evolving a weird

00:23:05,440 --> 00:23:09,280
notation here uh

00:23:07,280 --> 00:23:10,400
this would be the same we we again we

00:23:09,280 --> 00:23:12,000
found a cycle

00:23:10,400 --> 00:23:14,240
the depth of the thing was zero so we

00:23:12,000 --> 00:23:15,360
reached up zero we consider ourselves

00:23:14,240 --> 00:23:18,159
okay

00:23:15,360 --> 00:23:19,760
this guy is going to say okay well my

00:23:18,159 --> 00:23:23,840
reach depth is zero

00:23:19,760 --> 00:23:23,840
because i have a child that reached so

00:23:24,159 --> 00:23:28,000
the way this works in chalk and the way

00:23:26,159 --> 00:23:30,400
i would like to think of it

00:23:28,000 --> 00:23:31,280
is that your result is not just okay or

00:23:30,400 --> 00:23:33,120
error

00:23:31,280 --> 00:23:35,360
but your result comes with the depth

00:23:33,120 --> 00:23:37,120
that you reached

00:23:35,360 --> 00:23:38,799
or something like that that's not the

00:23:37,120 --> 00:23:40,720
way we've implemented it here

00:23:38,799 --> 00:23:42,480
because it was stapled on to an older

00:23:40,720 --> 00:23:45,039
system that didn't understand this stuff

00:23:42,480 --> 00:23:46,320
so the the depth is like stored in the

00:23:45,039 --> 00:23:50,720
stack as a kind of

00:23:46,320 --> 00:23:52,640
side mutation thing uh and

00:23:50,720 --> 00:23:53,919
and the only the okay is passed back we

00:23:52,640 --> 00:23:54,400
should probably refactor that at some

00:23:53,919 --> 00:23:56,640
point

00:23:54,400 --> 00:23:58,080
but what that means is the way this is

00:23:56,640 --> 00:23:59,360
actually working

00:23:58,080 --> 00:24:01,360
is that at each point we are

00:23:59,360 --> 00:24:02,720
initializing the reach depth so it

00:24:01,360 --> 00:24:06,000
starts out with

00:24:02,720 --> 00:24:07,760
the depth of the current node right um

00:24:06,000 --> 00:24:09,760
and then when we find the cycle before

00:24:07,760 --> 00:24:13,120
we've actually returned

00:24:09,760 --> 00:24:16,640
we're going to go back here and update

00:24:13,120 --> 00:24:19,039
these to be equal to the

00:24:16,640 --> 00:24:22,240
the minimum of their previous value and

00:24:19,039 --> 00:24:22,240
the cycle we just encountered

00:24:23,039 --> 00:24:27,039
okay and then we're going to return

00:24:27,120 --> 00:24:30,720
and then here we're going to return and

00:24:29,679 --> 00:24:32,559
here let's say there's no more

00:24:30,720 --> 00:24:35,919
dependencies so we return

00:24:32,559 --> 00:24:38,400
and and now we get up to here

00:24:35,919 --> 00:24:40,159
and we can return our reach depth here

00:24:38,400 --> 00:24:42,080
started out as zero and it never changed

00:24:40,159 --> 00:24:43,919
because

00:24:42,080 --> 00:24:45,600
nobody was able to reach past the top of

00:24:43,919 --> 00:24:49,919
the stack or the bottom of the stick

00:24:45,600 --> 00:24:51,200
rather um the root of the stack and

00:24:49,919 --> 00:24:53,919
that's fine that's how this would work

00:24:51,200 --> 00:24:57,360
with no caching

00:24:53,919 --> 00:24:59,200
uh so

00:24:57,360 --> 00:25:01,120
what do we do now what do we do instead

00:24:59,200 --> 00:25:02,720
um or what do we do

00:25:01,120 --> 00:25:05,279
the problem is we repeated some some

00:25:02,720 --> 00:25:08,480
effort here

00:25:05,279 --> 00:25:10,000
and that's one problem another problem

00:25:08,480 --> 00:25:14,480
is we would like to cache

00:25:10,000 --> 00:25:16,960
all these results so that if anybody

00:25:14,480 --> 00:25:18,320
uh and another function should try to

00:25:16,960 --> 00:25:20,799
prove the same thing they don't have to

00:25:18,320 --> 00:25:22,320
do the work again either

00:25:20,799 --> 00:25:23,679
um we would like to do both those things

00:25:22,320 --> 00:25:25,120
so we like to save ourselves some work

00:25:23,679 --> 00:25:27,760
while we're doing it and save future

00:25:25,120 --> 00:25:28,960
callers some work too

00:25:27,760 --> 00:25:31,200
and those are a little bit different so

00:25:28,960 --> 00:25:32,720
the way that we do this is

00:25:31,200 --> 00:25:35,440
we'll first just talk about saving our

00:25:32,720 --> 00:25:38,400
self-work um

00:25:35,440 --> 00:25:39,600
when we see a cycle or rather let's

00:25:38,400 --> 00:25:40,240
first talk about saving other people

00:25:39,600 --> 00:25:43,039
work

00:25:40,240 --> 00:25:44,720
i guess so there's a global cache of

00:25:43,039 --> 00:25:47,919
things that we've proven true

00:25:44,720 --> 00:25:50,000
right and norm like

00:25:47,919 --> 00:25:51,360
when we get an okay result we like to

00:25:50,000 --> 00:25:52,400
put things in that cache as soon as we

00:25:51,360 --> 00:25:55,440
can because then

00:25:52,400 --> 00:25:59,279
everybody else can make use of them um

00:25:55,440 --> 00:26:01,600
the problem is we can't put

00:25:59,279 --> 00:26:02,720
these internal nodes like we can't put

00:26:01,600 --> 00:26:05,440
this foo in there

00:26:02,720 --> 00:26:07,039
for example we did find it it's okay but

00:26:05,440 --> 00:26:08,400
that was part of this big cycle thing

00:26:07,039 --> 00:26:09,520
and it's only okay if all the other

00:26:08,400 --> 00:26:12,880
parts of the cycle

00:26:09,520 --> 00:26:13,520
turn out to be okay the same with bar as

00:26:12,880 --> 00:26:16,559
it happens

00:26:13,520 --> 00:26:19,360
because because it's reached depth was

00:26:16,559 --> 00:26:20,159
older than itself it's a provisionally

00:26:19,360 --> 00:26:22,840
okay result

00:26:20,159 --> 00:26:25,360
it can't be cached globally yet because

00:26:22,840 --> 00:26:25,760
maybe it will turn out that baz is not

00:26:25,360 --> 00:26:28,720
true

00:26:25,760 --> 00:26:30,320
and we don't know that yet um and the

00:26:28,720 --> 00:26:31,600
same with baz well if with as it turns

00:26:30,320 --> 00:26:32,960
out it's the last thing we have to prove

00:26:31,600 --> 00:26:35,840
so it would be okay but

00:26:32,960 --> 00:26:36,559
we didn't figure that out yet either um

00:26:35,840 --> 00:26:37,600
so

00:26:36,559 --> 00:26:40,480
so what we do is we have this

00:26:37,600 --> 00:26:40,480
provisional cache

00:26:41,039 --> 00:26:45,600
and if we kind of replay when we got to

00:26:44,080 --> 00:26:49,679
the point where we proved bar

00:26:45,600 --> 00:26:50,799
to be true not for cycles we don't do it

00:26:49,679 --> 00:26:53,919
there all the

00:26:50,799 --> 00:26:55,520
you could i guess anyway

00:26:53,919 --> 00:26:57,120
it doesn't matter instead of searching

00:26:55,520 --> 00:26:59,279
the stack if you wanted

00:26:57,120 --> 00:27:00,559
you could seed the provisional cache now

00:26:59,279 --> 00:27:01,360
that i think about it probably be more

00:27:00,559 --> 00:27:04,880
efficient

00:27:01,360 --> 00:27:06,640
um but in any case uh what we do instead

00:27:04,880 --> 00:27:08,400
is we

00:27:06,640 --> 00:27:10,640
when we see bar and we see that it's

00:27:08,400 --> 00:27:11,520
okay but we see that the depth is older

00:27:10,640 --> 00:27:15,279
than ourselves

00:27:11,520 --> 00:27:16,640
that's this path uh we insert into the

00:27:15,279 --> 00:27:20,799
provisional cache

00:27:16,640 --> 00:27:23,919
this entry so we'll say okay bar is okay

00:27:20,799 --> 00:27:23,919
with a reached depth

00:27:24,240 --> 00:27:28,640
of zero and let me just walk into the

00:27:27,279 --> 00:27:29,440
provisional cache for a second what does

00:27:28,640 --> 00:27:33,120
that look like

00:27:29,440 --> 00:27:36,399
cache is very simple it's a

00:27:33,120 --> 00:27:40,240
um well that's interesting well anyway

00:27:36,399 --> 00:27:42,399
uh here's a bit of break from

00:27:40,240 --> 00:27:43,679
chalk also the key is the thing we're

00:27:42,399 --> 00:27:45,200
trying to prove we don't store the

00:27:43,679 --> 00:27:46,640
environment because we assume the entire

00:27:45,200 --> 00:27:50,080
stack has a single environment

00:27:46,640 --> 00:27:52,799
that's stupid we should fix that um

00:27:50,080 --> 00:27:54,240
small thing uh and the value is this

00:27:52,799 --> 00:27:56,799
provisional evaluation

00:27:54,240 --> 00:27:59,200
so what was the result what was the

00:27:56,799 --> 00:28:01,919
depth first number

00:27:59,200 --> 00:28:03,120
from which i tried to prove it that's

00:28:01,919 --> 00:28:04,880
useful later

00:28:03,120 --> 00:28:07,200
and what depth did it wind up depending

00:28:04,880 --> 00:28:09,360
on what was the oldest thing it depended

00:28:07,200 --> 00:28:10,799
on

00:28:09,360 --> 00:28:13,760
okay so we're going to insert that in

00:28:10,799 --> 00:28:16,880
the cache and now when baz comes

00:28:13,760 --> 00:28:20,960
and wants to prove bar

00:28:16,880 --> 00:28:24,159
it's going to find it in the cache here

00:28:20,960 --> 00:28:25,039
get provisional get provisional is going

00:28:24,159 --> 00:28:28,000
to

00:28:25,039 --> 00:28:29,279
oops here just do a just a hash map look

00:28:28,000 --> 00:28:32,960
up

00:28:29,279 --> 00:28:32,960
it returns a provisional evaluation

00:28:33,120 --> 00:28:36,399
and the main thing is we can return the

00:28:35,520 --> 00:28:39,440
result

00:28:36,399 --> 00:28:42,399
but we have to act as if we reached the

00:28:39,440 --> 00:28:45,120
depth of that cache value

00:28:42,399 --> 00:28:46,240
because effectively we're replaying this

00:28:45,120 --> 00:28:48,000
search

00:28:46,240 --> 00:28:50,399
we're just short-circuiting it to the to

00:28:48,000 --> 00:28:50,960
the result so if we redo this what would

00:28:50,399 --> 00:28:53,679
happen

00:28:50,960 --> 00:28:55,600
with the cache just to like play it

00:28:53,679 --> 00:28:59,039
through and not require you to hold

00:28:55,600 --> 00:29:00,799
state in your mind um we would start

00:28:59,039 --> 00:29:04,240
here

00:29:00,799 --> 00:29:07,279
we would say this is okay we would

00:29:04,240 --> 00:29:07,279
cache provisionally

00:29:09,600 --> 00:29:13,760
we would go to prove bar baz we would

00:29:12,480 --> 00:29:16,640
say okay

00:29:13,760 --> 00:29:19,919
this has a reach depth of 1 to start we

00:29:16,640 --> 00:29:19,919
know that it depends on bar

00:29:20,559 --> 00:29:23,679
we would come to bar we would say cash

00:29:22,240 --> 00:29:26,720
hit

00:29:23,679 --> 00:29:28,559
it's ok or it has a reach depth

00:29:26,720 --> 00:29:31,039
of zero that would cause us to go back

00:29:28,559 --> 00:29:33,200
up and tweak this to zero

00:29:31,039 --> 00:29:34,640
we would then return okay this would

00:29:33,200 --> 00:29:35,120
return okay and then this would get

00:29:34,640 --> 00:29:38,960
cached

00:29:35,120 --> 00:29:42,159
too because um

00:29:38,960 --> 00:29:45,200
it is also a okay result that depends on

00:29:42,159 --> 00:29:45,200
something older in this deck

00:29:47,840 --> 00:29:51,919
okay and then we would get up to foo and

00:29:50,159 --> 00:29:54,559
at that point foo now

00:29:51,919 --> 00:29:56,799
has its okay result but unlike these

00:29:54,559 --> 00:29:56,799
other

00:29:57,919 --> 00:30:04,960
sub results the reach depth of foo is

00:30:01,840 --> 00:30:07,279
not older than itself so

00:30:04,960 --> 00:30:08,240
we've actually found the start of the

00:30:07,279 --> 00:30:11,360
cycle

00:30:08,240 --> 00:30:12,559
um it happens to be the root node but we

00:30:11,360 --> 00:30:15,919
don't that's not

00:30:12,559 --> 00:30:16,799
important um and so that means that not

00:30:15,919 --> 00:30:18,640
only is foo

00:30:16,799 --> 00:30:20,000
okay but we know that these provisional

00:30:18,640 --> 00:30:23,520
cache results

00:30:20,000 --> 00:30:27,679
are also true um

00:30:23,520 --> 00:30:31,120
and so now that's this case

00:30:27,679 --> 00:30:34,880
okay the reached depth is no older than

00:30:31,120 --> 00:30:37,200
our depth um that's what that's saying

00:30:34,880 --> 00:30:38,240
uh it's greater than or equal to so it's

00:30:37,200 --> 00:30:41,919
younger than

00:30:38,240 --> 00:30:44,880
uh or equal to um it actually will not

00:30:41,919 --> 00:30:47,039
like that's backwards tower i think but

00:30:44,880 --> 00:30:49,919
no that's right

00:30:47,039 --> 00:30:51,360
yeah that's right um it's i think it i

00:30:49,919 --> 00:30:52,159
think if i were to write this again i

00:30:51,360 --> 00:30:54,640
would write

00:30:52,159 --> 00:30:55,440
if stack that up is less than or equal

00:30:54,640 --> 00:30:57,840
to but

00:30:55,440 --> 00:30:59,600
yeah i find greater than or equal to be

00:30:57,840 --> 00:31:01,840
a very

00:30:59,600 --> 00:31:03,600
my mind wants small things on the left

00:31:01,840 --> 00:31:04,320
uh but anyway that's how it was written

00:31:03,600 --> 00:31:07,360
i don't know

00:31:04,320 --> 00:31:11,360
so by me i'm sure but uh

00:31:07,360 --> 00:31:14,240
it made sense at the time so the um

00:31:11,360 --> 00:31:14,720
what does it do right insert evaluation

00:31:14,240 --> 00:31:17,440
cache

00:31:14,720 --> 00:31:18,000
that's the global cache unlike before we

00:31:17,440 --> 00:31:19,760
called insert

00:31:18,000 --> 00:31:21,760
provisional on this cache associated

00:31:19,760 --> 00:31:23,120
with the stack we're now calling insert

00:31:21,760 --> 00:31:26,320
evaluation cache

00:31:23,120 --> 00:31:28,080
on the whole inference context well the

00:31:26,320 --> 00:31:30,559
selection context but

00:31:28,080 --> 00:31:32,640
and what that's going to do ignore this

00:31:30,559 --> 00:31:34,480
for a second that's going to go

00:31:32,640 --> 00:31:36,240
and inside the inference context it's

00:31:34,480 --> 00:31:37,840
going to insert

00:31:36,240 --> 00:31:40,320
keyed by the parameter environment and

00:31:37,840 --> 00:31:43,519
the trait this time which is correct

00:31:40,320 --> 00:31:46,960
the depth node and the result and then

00:31:43,519 --> 00:31:49,360
we actually have this global cache too

00:31:46,960 --> 00:31:50,320
what's the difference uh the evaluation

00:31:49,360 --> 00:31:53,600
cache is

00:31:50,320 --> 00:31:53,600
tied to things

00:31:54,000 --> 00:31:58,080
basically if that looks like something

00:31:55,600 --> 00:32:01,360
that is just true for everyone like

00:31:58,080 --> 00:32:03,840
u32 send or something we'll use the

00:32:01,360 --> 00:32:05,760
the big global cache and if it has

00:32:03,840 --> 00:32:09,200
inference variables or others

00:32:05,760 --> 00:32:12,480
or like generic parameters or something

00:32:09,200 --> 00:32:15,679
we'll use the uh inference context

00:32:12,480 --> 00:32:18,080
cache um this probably doesn't

00:32:15,679 --> 00:32:18,960
they don't they they sort of both need

00:32:18,080 --> 00:32:22,080
to exist

00:32:18,960 --> 00:32:24,320
but not entirely um i like choc's

00:32:22,080 --> 00:32:27,440
version of this better uh using

00:32:24,320 --> 00:32:27,440
canonicalization and stuff

00:32:27,760 --> 00:32:32,080
and then this is the other part on

00:32:29,600 --> 00:32:33,679
completion what does that do

00:32:32,080 --> 00:32:36,080
uh this is what i actually changed in

00:32:33,679 --> 00:32:39,440
this pr so

00:32:36,080 --> 00:32:39,840
mostly uh what this does is it goes

00:32:39,440 --> 00:32:44,640
through

00:32:39,840 --> 00:32:48,480
everything in the provisional cache

00:32:44,640 --> 00:32:52,559
that is covered by this cycle basically

00:32:48,480 --> 00:32:52,559
and goes and puts it in the global cache

00:32:52,720 --> 00:32:56,880
because now like i said bar and baz we

00:32:55,440 --> 00:32:58,159
not only know that foo is true we know

00:32:56,880 --> 00:33:00,960
that the things that we're dependent on

00:32:58,159 --> 00:33:00,960
foo are also true

00:33:01,200 --> 00:33:07,039
and here's here's what changed um

00:33:05,679 --> 00:33:10,399
in order to show what changed i have to

00:33:07,039 --> 00:33:11,919
make a slightly more annoying example uh

00:33:10,399 --> 00:33:13,919
and maybe to explain how this works

00:33:11,919 --> 00:33:17,120
better

00:33:13,919 --> 00:33:21,200
so this example had only one cycle

00:33:17,120 --> 00:33:26,799
but the actual example from the bug

00:33:21,200 --> 00:33:30,159
is more like a depends on b

00:33:26,799 --> 00:33:31,679
depends on c well we don't need to make

00:33:30,159 --> 00:33:34,960
it that complicated a depends on b which

00:33:31,679 --> 00:33:39,360
depends on a so now we have a cycle

00:33:34,960 --> 00:33:43,760
depends on c

00:33:39,360 --> 00:33:45,840
depends on d depends on c

00:33:43,760 --> 00:33:49,360
now we have another cycle and that's the

00:33:45,840 --> 00:33:49,360
key point this cycle

00:33:50,840 --> 00:33:53,840
uh

00:33:55,760 --> 00:34:02,320
um sort of contained within

00:33:58,880 --> 00:34:04,159
this greater cycle right um and i think

00:34:02,320 --> 00:34:06,559
in the actual example of the code like a

00:34:04,159 --> 00:34:08,720
also depends on like an e

00:34:06,559 --> 00:34:10,720
that depends on c this doesn't really

00:34:08,720 --> 00:34:12,560
matter but that could happen

00:34:10,720 --> 00:34:14,079
um and so what we used to do in the old

00:34:12,560 --> 00:34:15,919
code was you kind of consider this all

00:34:14,079 --> 00:34:21,839
one big cycle

00:34:15,919 --> 00:34:21,839
um we would

00:34:22,560 --> 00:34:25,839
we would wind up uh

00:34:26,079 --> 00:34:32,720
we had for for the cash itself

00:34:29,679 --> 00:34:33,919
a reached depth there was the minimum of

00:34:32,720 --> 00:34:35,679
the reach depth of all of the

00:34:33,919 --> 00:34:36,480
provisional entries in the cache rather

00:34:35,679 --> 00:34:40,320
than having a per

00:34:36,480 --> 00:34:42,800
entry value and so we said everything in

00:34:40,320 --> 00:34:45,760
this cache becomes true at that depth

00:34:42,800 --> 00:34:47,200
um and that was okay like that sounds

00:34:45,760 --> 00:34:50,320
like an approximation

00:34:47,200 --> 00:34:53,200
a less good version of what we do now

00:34:50,320 --> 00:34:54,240
but it actually led to incorrect results

00:34:53,200 --> 00:34:55,760
because

00:34:54,240 --> 00:34:57,839
there's one little detail i didn't show

00:34:55,760 --> 00:35:01,200
you

00:34:57,839 --> 00:35:02,079
which is this dot max so we're not

00:35:01,200 --> 00:35:05,440
actually storing

00:35:02,079 --> 00:35:06,400
the result that was cached this okay

00:35:05,440 --> 00:35:07,680
result

00:35:06,400 --> 00:35:11,520
what we're storing when we go to the

00:35:07,680 --> 00:35:13,839
global result is

00:35:11,520 --> 00:35:15,359
sorry just having a thought is there a

00:35:13,839 --> 00:35:19,040
subtle weird bug here

00:35:15,359 --> 00:35:21,359
i think it's okay uh what restoring

00:35:19,040 --> 00:35:22,160
is i have to think about it though uh

00:35:21,359 --> 00:35:25,200
we're actually

00:35:22,160 --> 00:35:27,520
storing is the

00:35:25,200 --> 00:35:27,520
um

00:35:28,800 --> 00:35:34,240
the max of that and the result

00:35:32,079 --> 00:35:35,920
from the main cache and there's this

00:35:34,240 --> 00:35:37,200
other little weird thing about failure

00:35:35,920 --> 00:35:38,800
let's ignore failure for a second and

00:35:37,200 --> 00:35:40,079
assume everything is true

00:35:38,800 --> 00:35:42,560
the real problem here is there's two

00:35:40,079 --> 00:35:44,800
versions of true there's okay and okay

00:35:42,560 --> 00:35:48,000
modular regions

00:35:44,800 --> 00:35:50,960
um so things can be less true

00:35:48,000 --> 00:35:52,320
but still true where we say well we had

00:35:50,960 --> 00:35:54,960
some region stuff to prove

00:35:52,320 --> 00:35:55,839
and we didn't we didn't evaluate that

00:35:54,960 --> 00:35:59,119
and so

00:35:55,839 --> 00:36:02,720
what was happening in the bug is

00:35:59,119 --> 00:36:05,119
let's say to prove e this is ok modulo

00:36:02,720 --> 00:36:05,119
regions

00:36:07,920 --> 00:36:12,560
let's say it depended on c and it also

00:36:09,920 --> 00:36:15,680
depended on

00:36:12,560 --> 00:36:16,160
this was the actual thing in sin depends

00:36:15,680 --> 00:36:17,680
on

00:36:16,160 --> 00:36:19,680
some type outliving tic static which

00:36:17,680 --> 00:36:22,640
actually we could just prove

00:36:19,680 --> 00:36:25,200
it's kind of because like there's this

00:36:22,640 --> 00:36:27,599
is like literally a struct

00:36:25,200 --> 00:36:29,040
uh we don't need any fancy region logic

00:36:27,599 --> 00:36:30,000
to know that that that's true but that's

00:36:29,040 --> 00:36:34,000
a very special case

00:36:30,000 --> 00:36:36,960
um uh so we so we said okay well this is

00:36:34,000 --> 00:36:40,160
okay modulo regions

00:36:36,960 --> 00:36:42,000
which makes e okay modular regions

00:36:40,160 --> 00:36:44,560
which makes a okay modular regions

00:36:42,000 --> 00:36:47,359
because a depends on all these things

00:36:44,560 --> 00:36:48,160
and then the idea is well for example

00:36:47,359 --> 00:36:51,839
take b

00:36:48,160 --> 00:36:55,280
b depends on a so b isn't really okay

00:36:51,839 --> 00:36:57,520
b is only as true as a is true so so b

00:36:55,280 --> 00:36:58,800
is actually even though we got an okay

00:36:57,520 --> 00:37:00,000
result when we just looked at b in

00:36:58,800 --> 00:37:01,119
isolation that's because we were

00:37:00,000 --> 00:37:04,880
assuming

00:37:01,119 --> 00:37:08,240
a was okay modular regions

00:37:04,880 --> 00:37:09,200
when in fact um because we were assuming

00:37:08,240 --> 00:37:11,119
a was okay

00:37:09,200 --> 00:37:13,040
but if we re-ran this result to a fixed

00:37:11,119 --> 00:37:15,119
point

00:37:13,040 --> 00:37:16,880
and we started with a being okay modular

00:37:15,119 --> 00:37:18,640
regions this time instead of assuming a

00:37:16,880 --> 00:37:20,240
was okay

00:37:18,640 --> 00:37:23,520
we would actually come back with okay

00:37:20,240 --> 00:37:26,960
modular regions here

00:37:23,520 --> 00:37:28,400
makes sense and so so what we're doing

00:37:26,960 --> 00:37:29,839
is we're kind of cutting instead of

00:37:28,400 --> 00:37:31,920
re-running to a fixed point which is

00:37:29,839 --> 00:37:35,119
probably what we should do

00:37:31,920 --> 00:37:35,520
or is like the naive thing to do we're

00:37:35,119 --> 00:37:37,280
just

00:37:35,520 --> 00:37:38,880
doing the dot max here because we know

00:37:37,280 --> 00:37:41,119
some stuff about

00:37:38,880 --> 00:37:43,040
our logic system and we know that it

00:37:41,119 --> 00:37:45,680
doesn't do anything besides

00:37:43,040 --> 00:37:46,480
propagate truth up doesn't have negation

00:37:45,680 --> 00:37:50,880
in particular

00:37:46,480 --> 00:37:53,119
uh and so um yeah

00:37:50,880 --> 00:37:54,480
so that's what's actually happening and

00:37:53,119 --> 00:37:57,839
that's all fine

00:37:54,480 --> 00:38:00,320
except for this part

00:37:57,839 --> 00:38:04,160
because we would do that same thing to

00:38:00,320 --> 00:38:07,440
the result of c which was also okay whoa

00:38:04,160 --> 00:38:10,480
what just happened okay

00:38:07,440 --> 00:38:11,680
uh somehow i hit something and so that

00:38:10,480 --> 00:38:13,440
means we would

00:38:11,680 --> 00:38:14,800
c and d were also okay but if you look

00:38:13,440 --> 00:38:19,839
at those

00:38:14,800 --> 00:38:19,839
even though they're sort of

00:38:19,920 --> 00:38:23,040
amongst it's a sub even though it's like

00:38:22,400 --> 00:38:24,320
in this

00:38:23,040 --> 00:38:26,000
it's a different strongly connected

00:38:24,320 --> 00:38:26,560
component because from c you can't reach

00:38:26,000 --> 00:38:29,599
a

00:38:26,560 --> 00:38:31,119
so um so actually c

00:38:29,599 --> 00:38:33,040
isn't dependent on a and the fact that a

00:38:31,119 --> 00:38:35,040
is okay modular doesn't affect our c

00:38:33,040 --> 00:38:37,839
result it should just be okay

00:38:35,040 --> 00:38:39,280
but because we didn't track that for

00:38:37,839 --> 00:38:42,640
each entry

00:38:39,280 --> 00:38:44,839
in the cache we couldn't recognize that

00:38:42,640 --> 00:38:47,359
and so we wound up caching ok modular

00:38:44,839 --> 00:38:50,640
region

00:38:47,359 --> 00:38:52,079
and that was okay because for the most

00:38:50,640 --> 00:38:53,280
part that distinction doesn't really

00:38:52,079 --> 00:38:56,240
matter

00:38:53,280 --> 00:38:58,320
until in the incremental version or for

00:38:56,240 --> 00:38:59,520
whatever reason when we restarted and we

00:38:58,320 --> 00:39:02,160
ran

00:38:59,520 --> 00:39:04,079
we happened to compute c without

00:39:02,160 --> 00:39:06,480
starting from a

00:39:04,079 --> 00:39:08,160
just starting from c and in that case we

00:39:06,480 --> 00:39:11,359
would get the proper result

00:39:08,160 --> 00:39:11,359
and so we would get a uh

00:39:11,599 --> 00:39:14,960
an assertion failure recognizing that we

00:39:13,599 --> 00:39:18,320
actually got two different results

00:39:14,960 --> 00:39:18,320
without any change in the inputs

00:39:18,400 --> 00:39:22,800
so that's the bug and the fix is that

00:39:20,880 --> 00:39:26,640
now we store everything per depth

00:39:22,800 --> 00:39:28,480
and that means when we get to c

00:39:26,640 --> 00:39:30,320
the reached depth of c is just going to

00:39:28,480 --> 00:39:31,520
be itself and so we're going to clear

00:39:30,320 --> 00:39:33,440
out

00:39:31,520 --> 00:39:35,280
everything at that point we haven't

00:39:33,440 --> 00:39:37,119
looked at e yet keep that in mind

00:39:35,280 --> 00:39:38,880
so we're going to clear out everything

00:39:37,119 --> 00:39:43,280
with a higher depth first number

00:39:38,880 --> 00:39:44,720
than c in the provisional cache

00:39:43,280 --> 00:39:47,440
but not things with lower depth versus

00:39:44,720 --> 00:39:51,119
numbers so when we get to see

00:39:47,440 --> 00:39:54,560
let's say contents

00:39:51,119 --> 00:39:57,599
of provisional cache when we finish

00:39:54,560 --> 00:40:02,160
with c we're going to have

00:39:57,599 --> 00:40:05,599
b is okay with a reach depth of zero

00:40:02,160 --> 00:40:08,640
and we're going to have d is okay

00:40:05,599 --> 00:40:10,079
with a reach depth of zero because in

00:40:08,640 --> 00:40:11,920
the course of proving

00:40:10,079 --> 00:40:13,280
c we had to prove d we haven't gotten to

00:40:11,920 --> 00:40:14,480
e yet so that's not going to be in the

00:40:13,280 --> 00:40:16,480
cache

00:40:14,480 --> 00:40:17,599
oh and i'm also going to add in the dfns

00:40:16,480 --> 00:40:21,440
just for fun

00:40:17,599 --> 00:40:21,440
this is going to have from dfn1

00:40:21,920 --> 00:40:25,920
this is going to have from dfn2 which is

00:40:24,240 --> 00:40:28,960
the or 3 rather

00:40:25,920 --> 00:40:32,480
because this is dfn0123

00:40:28,960 --> 00:40:34,640
um and so we're going to look for

00:40:32,480 --> 00:40:36,319
everything with a higher dfn than csdfn

00:40:34,640 --> 00:40:39,680
which is 2.

00:40:36,319 --> 00:40:41,680
um and oh and this reach depth is not

00:40:39,680 --> 00:40:44,400
zero it's actually one

00:40:41,680 --> 00:40:46,000
uh and we're going to move it to the

00:40:44,400 --> 00:40:47,520
global cache

00:40:46,000 --> 00:40:49,760
and we're gonna max it with the result

00:40:47,520 --> 00:40:50,640
of c so we're gonna move c and d into

00:40:49,760 --> 00:40:53,680
the global cache

00:40:50,640 --> 00:40:55,040
that should be two right not one one is

00:40:53,680 --> 00:40:58,640
b

00:40:55,040 --> 00:41:00,400
no this is this is this is depth

00:40:58,640 --> 00:41:01,760
that's confusing there's no reason to

00:41:00,400 --> 00:41:04,880
use both the fn in depth

00:41:01,760 --> 00:41:08,400
except that we do uh

00:41:04,880 --> 00:41:10,400
oh great that's one of the things i

00:41:08,400 --> 00:41:12,079
refactored in my branch we only use dfn

00:41:10,400 --> 00:41:13,599
which i found to be easier to think

00:41:12,079 --> 00:41:16,640
about uh

00:41:13,599 --> 00:41:18,240
yeah no that's confusing the fn has the

00:41:16,640 --> 00:41:19,520
advantage of not being reused so when

00:41:18,240 --> 00:41:20,480
you're gripping through logs and stuff

00:41:19,520 --> 00:41:24,160
you don't get

00:41:20,480 --> 00:41:25,599
like weird results um but

00:41:24,160 --> 00:41:28,160
otherwise i think you could use either

00:41:25,599 --> 00:41:29,839
one here because it's

00:41:28,160 --> 00:41:31,520
but anyway we use different ones and

00:41:29,839 --> 00:41:35,119
it's confusing but

00:41:31,520 --> 00:41:36,000
uh that's what we do so yeah one at this

00:41:35,119 --> 00:41:39,040
point

00:41:36,000 --> 00:41:42,400
is c for the depth right

00:41:39,040 --> 00:41:45,680
um so

00:41:42,400 --> 00:41:46,960
yeah so that's the fix uh everything

00:41:45,680 --> 00:41:48,640
else

00:41:46,960 --> 00:41:50,079
just works i think i didn't really

00:41:48,640 --> 00:41:53,920
change anything else in this branch

00:41:50,079 --> 00:41:56,240
um the only problem is

00:41:53,920 --> 00:41:57,599
we're getting this assertion failure i

00:41:56,240 --> 00:41:59,200
don't understand

00:41:57,599 --> 00:42:01,760
uh let me just check what's on my

00:41:59,200 --> 00:42:02,960
schedule oh right okay that's all right

00:42:01,760 --> 00:42:04,880
i have a phone call to make other than

00:42:02,960 --> 00:42:09,200
that we're okay

00:42:04,880 --> 00:42:09,200
um it's one of those things where

00:42:09,359 --> 00:42:13,920
anything that any business that doesn't

00:42:11,359 --> 00:42:15,920
open before i start working

00:42:13,920 --> 00:42:17,920
it's very hard for me to deal with my

00:42:15,920 --> 00:42:19,359
brain gets into rust

00:42:17,920 --> 00:42:21,599
and like it doesn't let go until like

00:42:19,359 --> 00:42:25,599
7pm and then most pistons are closed

00:42:21,599 --> 00:42:29,200
uh yeah um

00:42:25,599 --> 00:42:31,520
so anyway uh

00:42:29,200 --> 00:42:32,480
where were we right the bug so i don't

00:42:31,520 --> 00:42:34,160
know what the problem is

00:42:32,480 --> 00:42:35,680
let's take a look it's an assertion

00:42:34,160 --> 00:42:38,079
failure

00:42:35,680 --> 00:42:39,440
the problem is update reach depth and

00:42:38,079 --> 00:42:40,560
maybe the assertion's just wrong for

00:42:39,440 --> 00:42:44,640
some reason

00:42:40,560 --> 00:42:47,599
uh i don't think so um

00:42:44,640 --> 00:42:47,599
we're asserting that

00:42:51,520 --> 00:42:54,880
yeah that's weird why is that that does

00:42:52,960 --> 00:42:58,400
seem weird we're asserting that nobody

00:42:54,880 --> 00:43:02,240
ever calls

00:42:58,400 --> 00:43:05,680
no one ever tells us to update our depth

00:43:02,240 --> 00:43:08,400
to something below us or

00:43:05,680 --> 00:43:08,400
newer than us

00:43:09,040 --> 00:43:13,520
that makes sense you think i think it

00:43:12,319 --> 00:43:16,720
does right because

00:43:13,520 --> 00:43:19,599
if there's a cycle then

00:43:16,720 --> 00:43:21,520
either we're the start of the cycle so

00:43:19,599 --> 00:43:23,440
it should be equal to us

00:43:21,520 --> 00:43:24,960
or it's older than us or if it's newer

00:43:23,440 --> 00:43:28,160
than us then it's not

00:43:24,960 --> 00:43:32,319
doesn't affect us so why do we care um

00:43:28,160 --> 00:43:36,400
it's not actually harmful

00:43:32,319 --> 00:43:38,839
like it may be that it's just getting

00:43:36,400 --> 00:43:41,280
cold and it's not harmful but it's weird

00:43:38,839 --> 00:43:44,240
um

00:43:41,280 --> 00:43:46,079
i'm wondering yeah so oh there's one

00:43:44,240 --> 00:43:49,200
other thing before we go on to this bug

00:43:46,079 --> 00:43:52,000
i just want to mention one thing that

00:43:49,200 --> 00:43:54,079
the logic does do

00:43:52,000 --> 00:43:55,280
today i change this in my branch and i

00:43:54,079 --> 00:43:56,640
think it's right

00:43:55,280 --> 00:43:58,480
though i have to completely convince

00:43:56,640 --> 00:44:01,200
myself if

00:43:58,480 --> 00:44:04,079
the result isn't is not okay or okay

00:44:01,200 --> 00:44:04,079
modulo regions

00:44:05,839 --> 00:44:09,359
it clears everything on the cache that

00:44:07,839 --> 00:44:12,240
comes after it

00:44:09,359 --> 00:44:13,920
that every so in other words going

00:44:12,240 --> 00:44:17,040
through our whole example here if a had

00:44:13,920 --> 00:44:17,040
turned out to be an error

00:44:18,240 --> 00:44:22,720
we would have cleared this provisional

00:44:21,200 --> 00:44:24,160
result and we would never move it to the

00:44:22,720 --> 00:44:27,280
global cache

00:44:24,160 --> 00:44:28,560
so this dot max that's occurring here i

00:44:27,280 --> 00:44:30,079
believe you could put an assert and

00:44:28,560 --> 00:44:33,680
maybe i should

00:44:30,079 --> 00:44:36,240
that result this code should only ever

00:44:33,680 --> 00:44:38,240
execute in the case where the

00:44:36,240 --> 00:44:40,000
result we're maxing with is either okay

00:44:38,240 --> 00:44:41,200
or okay modular regions

00:44:40,000 --> 00:44:43,040
because otherwise the cache should have

00:44:41,200 --> 00:44:44,560
been cleared um

00:44:43,040 --> 00:44:46,480
i don't actually think that's necessary

00:44:44,560 --> 00:44:49,599
i think it would be okay to

00:44:46,480 --> 00:44:52,400
like if if the result was error we could

00:44:49,599 --> 00:44:53,920
cache error because it's not true

00:44:52,400 --> 00:44:55,599
and when we evaluate it we're going to

00:44:53,920 --> 00:44:57,839
get an error but

00:44:55,599 --> 00:44:57,839
um

00:44:59,119 --> 00:45:02,880
yeah what was your reasoning for

00:45:02,079 --> 00:45:04,960
discarding

00:45:02,880 --> 00:45:07,200
error i don't know that's what i'm i'm a

00:45:04,960 --> 00:45:10,000
little i would like to

00:45:07,200 --> 00:45:11,280
go back and ask myself um i think i was

00:45:10,000 --> 00:45:12,560
not

00:45:11,280 --> 00:45:14,880
i might have been a little nervous

00:45:12,560 --> 00:45:14,880
because

00:45:14,960 --> 00:45:18,640
it is certainly true that well basically

00:45:16,960 --> 00:45:20,160
the question is

00:45:18,640 --> 00:45:22,000
i think it's similar to the dot max

00:45:20,160 --> 00:45:24,400
logic like

00:45:22,000 --> 00:45:25,200
that's a shortcut that's making an

00:45:24,400 --> 00:45:28,560
assumption

00:45:25,200 --> 00:45:31,920
which is that if if we found that

00:45:28,560 --> 00:45:34,720
that b is true if a is true if we knew

00:45:31,920 --> 00:45:37,440
that a was false

00:45:34,720 --> 00:45:39,359
would we we're assuming we could never

00:45:37,440 --> 00:45:41,760
prove b to be true

00:45:39,359 --> 00:45:43,280
right which i think should be correct

00:45:41,760 --> 00:45:47,839
like

00:45:43,280 --> 00:45:47,839
but if you had uh

00:45:51,119 --> 00:45:55,040
if you could imagine that the code might

00:45:54,000 --> 00:45:57,359
do something different

00:45:55,040 --> 00:45:58,880
like say try to evaluate a and if i

00:45:57,359 --> 00:46:00,240
don't know then i'll go down one path

00:45:58,880 --> 00:46:01,359
but if i know it's an error i'll go down

00:46:00,240 --> 00:46:03,200
another path

00:46:01,359 --> 00:46:05,119
and like in particular the where clause

00:46:03,200 --> 00:46:06,560
winnowing and stuff

00:46:05,119 --> 00:46:08,720
i wouldn't be totally shocked if there's

00:46:06,560 --> 00:46:10,079
some edge case where if we were to run

00:46:08,720 --> 00:46:11,440
this to a fixed point it would do

00:46:10,079 --> 00:46:14,960
something different

00:46:11,440 --> 00:46:16,000
uh so it makes me like mildly

00:46:14,960 --> 00:46:17,680
uncomfortable

00:46:16,000 --> 00:46:19,200
um but that code in general just makes

00:46:17,680 --> 00:46:20,880
me mildly uncomfortable

00:46:19,200 --> 00:46:24,240
uh i think that's a good example why

00:46:20,880 --> 00:46:26,800
that code is bad um

00:46:24,240 --> 00:46:28,240
i if if we had negation this all this

00:46:26,800 --> 00:46:30,319
logic gets a little more complicated

00:46:28,240 --> 00:46:32,400
which is why

00:46:30,319 --> 00:46:33,760
well we don't have negation in chalk

00:46:32,400 --> 00:46:36,800
either anymore

00:46:33,760 --> 00:46:37,119
but like the old slg solver maybe before

00:46:36,800 --> 00:46:39,599
you

00:46:37,119 --> 00:46:40,480
started hacking on i can't remember uh i

00:46:39,599 --> 00:46:45,119
removed the

00:46:40,480 --> 00:46:48,960
negation this is why it used to have two

00:46:45,119 --> 00:46:51,280
it used to have two things positive

00:46:48,960 --> 00:46:52,640
reached depth effectively and negative

00:46:51,280 --> 00:46:56,000
reach depth

00:46:52,640 --> 00:46:57,280
because it basically you have

00:46:56,000 --> 00:46:59,440
you will have to do somewhat different

00:46:57,280 --> 00:47:00,800
things um

00:46:59,440 --> 00:47:02,079
where you're you're either saying b is

00:47:00,800 --> 00:47:03,040
true if a is true or you're saying b is

00:47:02,079 --> 00:47:06,160
true if a is false

00:47:03,040 --> 00:47:06,160
that's different um

00:47:06,480 --> 00:47:12,560
but um

00:47:11,119 --> 00:47:14,800
but we don't have that because we don't

00:47:12,560 --> 00:47:16,960
have nikki uh anyway so let's look at

00:47:14,800 --> 00:47:16,960
this

00:47:18,720 --> 00:47:22,400
what happened to my terminal it's like

00:47:20,160 --> 00:47:22,400
gone

00:47:22,880 --> 00:47:29,119
okay that's weird um

00:47:27,040 --> 00:47:31,760
oh there's like some anonymous terminals

00:47:29,119 --> 00:47:31,760
here or something

00:47:32,000 --> 00:47:34,480
very weird

00:47:36,839 --> 00:47:39,839
um

00:47:41,119 --> 00:47:45,040
just gonna get rid of that something

00:47:42,960 --> 00:47:45,839
weird is going on let's try this instead

00:47:45,040 --> 00:47:49,920
rust back

00:47:45,839 --> 00:47:53,839
trace so i think what i found was

00:47:49,920 --> 00:47:53,839
in order to reproduce this problem

00:47:54,960 --> 00:48:01,760
i had to do dist so i think it dies when

00:47:58,559 --> 00:48:01,760
running rust dock or something

00:48:03,599 --> 00:48:09,920
which is always a good sign yeah

00:48:06,960 --> 00:48:11,280
i definitely run into that crosstalk

00:48:09,920 --> 00:48:13,520
does some unusual things

00:48:11,280 --> 00:48:14,319
with the trade solver which exercise

00:48:13,520 --> 00:48:18,640
some different paths

00:48:14,319 --> 00:48:20,160
so i'm not that surprised uh

00:48:18,640 --> 00:48:21,920
right so we've got some i think what i

00:48:20,160 --> 00:48:24,880
would like to do is dump let's dump some

00:48:21,920 --> 00:48:24,880
state while we're here too

00:48:27,520 --> 00:48:30,559
this is going to generate a bunch of

00:48:28,800 --> 00:48:35,280
crap isn't it i hope not

00:48:30,559 --> 00:48:38,480
let's find out

00:48:35,280 --> 00:48:42,319
i had some fun cases of like

00:48:38,480 --> 00:48:43,680
two terabyte log files while debugging

00:48:42,319 --> 00:48:46,160
the same thing

00:48:43,680 --> 00:48:47,440
yeah i always do my best to like get an

00:48:46,160 --> 00:48:50,400
mcb

00:48:47,440 --> 00:48:52,000
and then it really makes life better

00:48:50,400 --> 00:48:54,640
yeah

00:48:52,000 --> 00:48:56,160
the uh the nice trick that i was using

00:48:54,640 --> 00:48:57,119
with some success but that is a little

00:48:56,160 --> 00:48:58,960
risky

00:48:57,119 --> 00:49:01,599
is like piping it through rip grep dash

00:48:58,960 --> 00:49:03,040
see a thousand or something so you get

00:49:01,599 --> 00:49:04,400
find some string that you care about and

00:49:03,040 --> 00:49:07,040
then you get a thousand lines before and

00:49:04,400 --> 00:49:10,640
after that string each time it appears

00:49:07,040 --> 00:49:10,640
but then you never quite know like

00:49:11,200 --> 00:49:14,559
when you try to find every occurrence of

00:49:12,960 --> 00:49:16,079
something or if it's not that exact

00:49:14,559 --> 00:49:18,079
string you don't quite know if it's in

00:49:16,079 --> 00:49:21,839
there or not

00:49:18,079 --> 00:49:24,160
yeah i think it depends

00:49:21,839 --> 00:49:25,280
usually i can get an mcbe and then i

00:49:24,160 --> 00:49:28,839
just like

00:49:25,280 --> 00:49:31,520
vlog freight selection

00:49:28,839 --> 00:49:35,119
infer rusty middle

00:49:31,520 --> 00:49:38,240
just the big grapes let's take a look

00:49:35,119 --> 00:49:40,880
here so we're getting this

00:49:38,240 --> 00:49:43,040
hit from evaluate trade predicate site

00:49:40,880 --> 00:49:46,800
recursively

00:49:43,040 --> 00:49:46,800
which probably

00:49:47,760 --> 00:49:50,640
is here right

00:49:50,800 --> 00:49:56,319
that would be my guess um like it's

00:49:53,599 --> 00:49:59,760
probably a provisional cash hit

00:49:56,319 --> 00:50:02,480
and so what i'm wondering is

00:49:59,760 --> 00:50:02,480
could it happen

00:50:04,400 --> 00:50:08,640
i feel like the there's something

00:50:09,040 --> 00:50:12,480
okay maybe i can see how this no it

00:50:11,280 --> 00:50:13,200
feels like this shouldn't happen this

00:50:12,480 --> 00:50:14,480
feels bad

00:50:13,200 --> 00:50:17,119
so what i'm imagining could have

00:50:14,480 --> 00:50:17,119
happened is

00:50:19,839 --> 00:50:25,040
ah i think i know what could happen

00:50:23,599 --> 00:50:27,040
maybe this is an argument for switching

00:50:25,040 --> 00:50:30,240
to dfns

00:50:27,040 --> 00:50:35,119
um which isn't that much work

00:50:30,240 --> 00:50:38,240
uh i think what could be happening is

00:50:35,119 --> 00:50:38,240
let's try to sketch it out

00:50:38,839 --> 00:50:45,440
um scott

00:50:41,760 --> 00:50:45,440
why are you not why are you doing that

00:50:48,960 --> 00:50:52,319
i don't understand what it's doing

00:50:52,400 --> 00:50:57,040
don't make a new terminal no

00:51:02,319 --> 00:51:05,010
uh i don't know maybe try closing the

00:51:04,400 --> 00:51:06,400
terminal

00:51:05,010 --> 00:51:09,839
[Music]

00:51:06,400 --> 00:51:09,839
let's close something

00:51:20,839 --> 00:51:28,319
um no i guess all that stuff was

00:51:25,200 --> 00:51:28,319
that's fine it doesn't matter

00:51:28,480 --> 00:51:32,400
um there we go

00:51:34,839 --> 00:51:38,160
no

00:51:36,160 --> 00:51:41,359
why are you doing this to me also how

00:51:38,160 --> 00:51:41,359
big is kill me

00:51:42,640 --> 00:51:45,920
pretty big okay

00:51:46,400 --> 00:51:50,079
it's not worth it we'll figure something

00:51:48,400 --> 00:51:52,960
else out uh

00:51:50,079 --> 00:51:52,960
what we'll do is this

00:51:57,599 --> 00:52:01,839
you could just winnow it to the trade

00:52:00,240 --> 00:52:05,839
select

00:52:01,839 --> 00:52:05,839
module yeah that might help too

00:52:08,800 --> 00:52:14,559
um but also i should

00:52:12,079 --> 00:52:15,119
close this maybe something gonna let me

00:52:14,559 --> 00:52:18,880
have

00:52:15,119 --> 00:52:21,760
i think i just have to restart ps code

00:52:18,880 --> 00:52:21,760
it's very grumpy

00:52:22,319 --> 00:52:26,400
we'll worry about you later uh so here's

00:52:24,960 --> 00:52:29,760
what i think is happening

00:52:26,400 --> 00:52:29,760
even though i can't type to show you

00:52:30,839 --> 00:52:36,960
um

00:52:33,839 --> 00:52:39,920
i think that we are completing a

00:52:36,960 --> 00:52:42,800
provisional cache

00:52:39,920 --> 00:52:43,760
and then the thing that which was

00:52:42,800 --> 00:52:46,880
dependent on

00:52:43,760 --> 00:52:48,720
let's say something with one depth

00:52:46,880 --> 00:52:50,800
and then we go to do other things within

00:52:48,720 --> 00:52:53,680
that which wind up making

00:52:50,800 --> 00:52:53,680
the depth higher

00:52:54,079 --> 00:52:58,839
but we're not updating the cache entries

00:52:56,960 --> 00:53:02,480
if that makes sense

00:52:58,839 --> 00:53:02,480
um yeah i think that makes sense

00:53:03,040 --> 00:53:06,240
if we use dfn

00:53:06,800 --> 00:53:11,280
i think it would be the same problem and

00:53:08,400 --> 00:53:12,800
that's probably why i made one

00:53:11,280 --> 00:53:15,839
that's probably why i had yeah that's

00:53:12,800 --> 00:53:19,599
why i had one depth in the beginning

00:53:15,839 --> 00:53:21,200
because i exactly this transitive thing

00:53:19,599 --> 00:53:24,960
i didn't want to deal with it

00:53:21,200 --> 00:53:26,960
um i remember that now

00:53:24,960 --> 00:53:29,359
it's good we should probably add a test

00:53:26,960 --> 00:53:31,920
for this uh

00:53:29,359 --> 00:53:32,800
yeah that is not like yeah i know good

00:53:31,920 --> 00:53:36,559
luck minimizing

00:53:32,800 --> 00:53:37,920
it it's something very sensitive

00:53:36,559 --> 00:53:40,559
it's possible we could add a test for

00:53:37,920 --> 00:53:43,040
this surprised you were able to

00:53:40,559 --> 00:53:44,559
figure this out you should be able to

00:53:43,040 --> 00:53:48,480
make a test for this come on

00:53:44,559 --> 00:53:51,920
uh hold on the problem with these tests

00:53:48,480 --> 00:53:51,920
is they're always so dependent on like

00:53:54,240 --> 00:53:59,040
i don't know um i mean it's something

00:53:56,800 --> 00:53:59,040
like

00:53:59,839 --> 00:54:03,200
tray a i guess these have to be auto

00:54:01,920 --> 00:54:10,720
traits okay it's

00:54:03,200 --> 00:54:12,319
something like struct a

00:54:10,720 --> 00:54:14,559
great hold on let's show the graph we

00:54:12,319 --> 00:54:17,920
want the graph we want is

00:54:14,559 --> 00:54:20,480
a depends on b

00:54:17,920 --> 00:54:20,480
depends on

00:54:21,440 --> 00:54:25,839
e or maybe just b depends on b

00:54:27,040 --> 00:54:32,720
and then b also depends on a

00:54:30,160 --> 00:54:33,839
and then that will make b have it or we

00:54:32,720 --> 00:54:34,800
probably need an intermediate node to

00:54:33,839 --> 00:54:37,200
make it

00:54:34,800 --> 00:54:38,720
really do the right thing so this would

00:54:37,200 --> 00:54:41,599
have a depth of

00:54:38,720 --> 00:54:43,200
one this would have a depth of zero and

00:54:41,599 --> 00:54:43,839
now the overall result is a depth of

00:54:43,200 --> 00:54:49,119
zero

00:54:43,839 --> 00:54:49,119
right um what we can do

00:54:50,319 --> 00:54:53,839
i actually don't i don't particularly

00:54:51,680 --> 00:54:57,359
love the structure of this cache

00:54:53,839 --> 00:55:00,640
because it's a it's a um

00:54:57,359 --> 00:55:02,000
hash map which is annoying because so

00:55:00,640 --> 00:55:03,119
much of what we want to do is dependent

00:55:02,000 --> 00:55:06,880
on

00:55:03,119 --> 00:55:09,920
the depth first numbers really um

00:55:06,880 --> 00:55:14,400
but like what we could very easily do

00:55:09,920 --> 00:55:16,960
is when we decide

00:55:14,400 --> 00:55:18,160
when we're done with b and we see that

00:55:16,960 --> 00:55:19,040
we're going to insert our thing as

00:55:18,160 --> 00:55:20,640
provisional

00:55:19,040 --> 00:55:22,000
we can also sweep everything with a

00:55:20,640 --> 00:55:22,960
higher depth first number that's in the

00:55:22,000 --> 00:55:26,079
cache

00:55:22,960 --> 00:55:28,960
and update its like its depth should

00:55:26,079 --> 00:55:29,440
it's reached up should be the minimum of

00:55:28,960 --> 00:55:32,720
uh

00:55:29,440 --> 00:55:34,810
our reach depth if that makes sense

00:55:32,720 --> 00:55:36,640
you know um yeah

00:55:34,810 --> 00:55:37,839
[Music]

00:55:36,640 --> 00:55:41,520
i'm trying to think if that's early

00:55:37,839 --> 00:55:41,520
enough or if we can have a problem where

00:55:41,839 --> 00:55:46,559
um you haven't yet left b

00:55:45,280 --> 00:55:48,880
and it's already annoying that it's out

00:55:46,559 --> 00:55:48,880
of date

00:55:49,359 --> 00:55:52,640
i don't think so because

00:55:55,440 --> 00:56:03,839
basically the reach depth of everything

00:55:57,839 --> 00:56:03,839
that's in the cache

00:56:05,599 --> 00:56:10,559
is always something that is still on the

00:56:09,359 --> 00:56:13,599
stack

00:56:10,559 --> 00:56:15,119
like in order to have a problem

00:56:13,599 --> 00:56:17,119
it would have to be a depth of some node

00:56:15,119 --> 00:56:19,119
that was popped

00:56:17,119 --> 00:56:22,400
right that's the problem we're having

00:56:19,119 --> 00:56:24,640
that we popped b from the step back

00:56:22,400 --> 00:56:26,240
like we didn't complete the whole the

00:56:24,640 --> 00:56:28,240
whole the assertion fails when we then

00:56:26,240 --> 00:56:32,480
go to process d

00:56:28,240 --> 00:56:36,400
and we find a provisional cache result

00:56:32,480 --> 00:56:37,760
for c with depth one um

00:56:36,400 --> 00:56:39,680
this problem this actually won't trigger

00:56:37,760 --> 00:56:41,440
this version but to make the thing a

00:56:39,680 --> 00:56:44,000
little more convoluted it should

00:56:41,440 --> 00:56:44,720
uh like you need like another layer or

00:56:44,000 --> 00:56:46,720
something

00:56:44,720 --> 00:56:48,880
to make it depth to um which was

00:56:46,720 --> 00:56:50,880
annoying but

00:56:48,880 --> 00:56:52,559
uh that's where we have the problem and

00:56:50,880 --> 00:56:55,599
the problem is that it's referring to b

00:56:52,559 --> 00:56:57,440
but b was popped but we maintain the

00:56:55,599 --> 00:56:58,079
invariant if if what we do is when we

00:56:57,440 --> 00:56:59,680
top b

00:56:58,079 --> 00:57:01,200
and we see that b isn't ready yet we go

00:56:59,680 --> 00:57:03,040
and update everybody's depth

00:57:01,200 --> 00:57:04,240
to b's depth it must be something lower

00:57:03,040 --> 00:57:06,400
than b

00:57:04,240 --> 00:57:07,680
or else b would have been ready and so

00:57:06,400 --> 00:57:09,200
we kind of maintained that invariant

00:57:07,680 --> 00:57:09,520
that the depth is always referring to

00:57:09,200 --> 00:57:10,960
some

00:57:09,520 --> 00:57:12,640
some parent on the stack which might be

00:57:10,960 --> 00:57:16,000
ourselves or which will never be

00:57:12,640 --> 00:57:19,280
it will never be d because d

00:57:16,000 --> 00:57:20,480
if there's some common ancestor and d is

00:57:19,280 --> 00:57:22,400
a child of that and

00:57:20,480 --> 00:57:24,839
at that point before d was pushed

00:57:22,400 --> 00:57:26,799
everything on the stack referred to a or

00:57:24,839 --> 00:57:30,480
above

00:57:26,799 --> 00:57:34,319
that make sense um it does

00:57:30,480 --> 00:57:34,319
it's true trust me uh

00:57:34,400 --> 00:57:39,040
trust me it's fine it's it sounds

00:57:37,839 --> 00:57:40,480
correct

00:57:39,040 --> 00:57:42,799
you can sort of see what i'm getting for

00:57:40,480 --> 00:57:43,119
i hope yeah uh yeah okay so now i just

00:57:42,799 --> 00:57:45,280
have

00:57:43,119 --> 00:57:47,839
that's the easiest fix is to do that but

00:57:45,280 --> 00:57:49,119
i do i would like to have a test

00:57:47,839 --> 00:57:51,440
it's gonna be annoying to make one

00:57:49,119 --> 00:57:54,079
though um

00:57:51,440 --> 00:57:56,960
i need like i need a i need the cache

00:57:54,079 --> 00:58:00,079
result to be depth two

00:57:56,960 --> 00:58:02,880
oh well okay so c has depth one so

00:58:00,079 --> 00:58:02,880
if if a

00:58:03,920 --> 00:58:10,400
if a just depends on

00:58:08,160 --> 00:58:10,400
c

00:58:13,440 --> 00:58:20,240
that do it i think that would do it

00:58:17,839 --> 00:58:22,000
because what would happen is a will come

00:58:20,240 --> 00:58:28,559
along a will find the provisional

00:58:22,000 --> 00:58:28,559
cache result c won't yet be on the stack

00:58:29,040 --> 00:58:34,240
so let's try it i think this will work

00:58:32,000 --> 00:58:37,760
that looks right

00:58:34,240 --> 00:58:41,920
because it would go through b

00:58:37,760 --> 00:58:44,480
update a with a depth of zero go to c

00:58:41,920 --> 00:58:46,240
see it's step one try to update a get

00:58:44,480 --> 00:58:48,400
some garbage in the way to prevent it

00:58:46,240 --> 00:58:48,400
from

00:58:49,200 --> 00:58:52,880
prevent other things from freaking out

00:58:51,280 --> 00:58:56,240
uh

00:58:52,880 --> 00:58:56,240
c has to depend on b

00:58:57,520 --> 00:59:05,839
or let's just do like no that'll work

00:59:02,839 --> 00:59:05,839
uh

00:59:25,520 --> 00:59:28,400
of course that worked fine

00:59:31,280 --> 00:59:39,040
but you don't depend on c again from a

00:59:34,799 --> 00:59:39,040
right it's only through good point

00:59:43,599 --> 00:59:51,220
still not good enough why b depends on

00:59:46,640 --> 00:59:54,350
c and a

00:59:51,220 --> 00:59:54,350
[Music]

00:59:58,839 --> 01:00:04,319
um

01:00:01,599 --> 01:00:06,799
i don't know let's look at the logs why

01:00:04,319 --> 01:00:07,760
is this so smart

01:00:06,799 --> 01:00:10,240
it could be that it's not even

01:00:07,760 --> 01:00:11,359
evaluating this it might not even be

01:00:10,240 --> 01:00:14,559
going down this path

01:00:11,359 --> 01:00:15,920
actually it's kind of annoying

01:00:14,559 --> 01:00:17,839
it's hard to make it it's not always

01:00:15,920 --> 01:00:21,119
easy to make it do an evaluation

01:00:17,839 --> 01:00:23,200
uh yeah that's

01:00:21,119 --> 01:00:26,319
at least with chalk right you can just

01:00:23,200 --> 01:00:26,319
tell it what you want it to do

01:00:26,839 --> 01:00:31,359
um trying to think what's a way to

01:00:29,280 --> 01:00:32,640
force it to do an evaluation it will do

01:00:31,359 --> 01:00:36,480
it if there's two work

01:00:32,640 --> 01:00:40,079
if there's two options that might apply

01:00:36,480 --> 01:00:40,079
um and it needs to narrow it down

01:00:40,400 --> 01:00:44,240
so like we could do

01:00:46,640 --> 01:00:54,799
implement for all t nitrate

01:00:50,000 --> 01:00:56,960
no for all t that are a my trait for t

01:00:54,799 --> 01:00:56,960
and

01:00:59,280 --> 01:01:06,480
not sure that'll work because t

01:01:04,319 --> 01:01:08,839
implements a doesn't make sense it's

01:01:06,480 --> 01:01:12,559
destruct

01:01:08,839 --> 01:01:25,440
oh you're right that does not work

01:01:12,559 --> 01:01:29,520
uh send is what i wanted

01:01:25,440 --> 01:01:29,520
of course that doesn't work well

01:01:33,200 --> 01:01:35,680
i don't know

01:01:36,400 --> 01:01:39,839
i mean i don't know you could restrict t

01:01:38,480 --> 01:01:41,520
to

01:01:39,839 --> 01:01:44,400
i don't know it's not gonna work because

01:01:41,520 --> 01:01:44,400
it's not gonna unify

01:01:45,280 --> 01:01:48,240
what happens if i do this

01:01:49,040 --> 01:01:56,240
no okay i don't know

01:01:52,240 --> 01:01:59,039
just fix it stop being so smart

01:01:56,240 --> 01:01:59,039
stop being smart

01:01:59,359 --> 01:02:03,200
all right we'll try to just fix the bug

01:02:00,960 --> 01:02:03,200
uh

01:02:03,359 --> 01:02:10,960
what we really need is

01:02:07,599 --> 01:02:14,640
yeah so insert provisional

01:02:10,960 --> 01:02:15,920
i feel like update the when you update

01:02:14,640 --> 01:02:18,880
the dfn

01:02:15,920 --> 01:02:19,359
or the reach depth that should just if

01:02:18,880 --> 01:02:23,119
it's

01:02:19,359 --> 01:02:26,480
greater just ignore it right because

01:02:23,119 --> 01:02:30,559
well i'm that doesn't feel right to me

01:02:26,480 --> 01:02:33,680
because it actually does depend on

01:02:30,559 --> 01:02:36,400
like if b depends on if c

01:02:33,680 --> 01:02:36,400
depends on a

01:02:37,200 --> 01:02:41,039
like to go back to our example i thought

01:02:39,280 --> 01:02:44,160
about that but i think that's wrong

01:02:41,039 --> 01:02:47,520
because c really does depend on

01:02:44,160 --> 01:02:50,720
a here right

01:02:47,520 --> 01:02:50,720
and if we

01:02:50,799 --> 01:02:54,960
if we just ignored the depth we don't

01:02:53,440 --> 01:02:56,720
know that we don't realize that there's

01:02:54,960 --> 01:02:57,520
actually a dependency between processing

01:02:56,720 --> 01:02:59,839
c

01:02:57,520 --> 01:03:02,079
and the thing at depth zero and so we

01:02:59,839 --> 01:03:06,000
might incorrectly assume

01:03:02,079 --> 01:03:09,760
that some parent node is complete

01:03:06,000 --> 01:03:09,760
wait i'm confused so

01:03:10,079 --> 01:03:13,599
we so we're at the point that we finish

01:03:12,480 --> 01:03:17,119
processing b

01:03:13,599 --> 01:03:20,160
so the root depth

01:03:17,119 --> 01:03:23,680
of a is going to be zero

01:03:20,160 --> 01:03:25,760
we go to try to process c now we have

01:03:23,680 --> 01:03:27,039
we see that that's the root depth of one

01:03:25,760 --> 01:03:30,160
we want to update a

01:03:27,039 --> 01:03:33,359
to b at least

01:03:30,160 --> 01:03:36,000
um older than one but it's already

01:03:33,359 --> 01:03:36,960
zero right this doesn't show the problem

01:03:36,000 --> 01:03:39,920
the problem would be

01:03:36,960 --> 01:03:39,920
if we

01:03:40,480 --> 01:03:45,839
suppose that we add some more layers in

01:03:43,520 --> 01:03:45,839
here

01:03:46,720 --> 01:03:50,079
don't don't make me write all the layers

01:03:48,480 --> 01:03:51,520
out suppose that we

01:03:50,079 --> 01:03:59,839
had another layer i guess the layers

01:03:51,520 --> 01:03:59,839
have to be here

01:04:01,039 --> 01:04:04,000
oh i hate this

01:04:05,280 --> 01:04:08,799
suppose that this was depth one

01:04:09,039 --> 01:04:16,240
right now we'll get a reach depth of

01:04:12,880 --> 01:04:20,000
two right

01:04:16,240 --> 01:04:22,160
and we would go up and this has

01:04:20,000 --> 01:04:24,480
reached depth one because it started

01:04:22,160 --> 01:04:27,760
that way

01:04:24,480 --> 01:04:29,599
and this has reached up zero now my my

01:04:27,760 --> 01:04:30,400
concern is we walk up the stack we say

01:04:29,599 --> 01:04:33,200
ah

01:04:30,400 --> 01:04:36,720
well that's inside of us so we don't

01:04:33,200 --> 01:04:39,680
have to update or reach depth of one

01:04:36,720 --> 01:04:41,599
okay and then but the problem is now we

01:04:39,680 --> 01:04:44,319
might actually cache this result

01:04:41,599 --> 01:04:45,440
in the global cache when in fact it does

01:04:44,319 --> 01:04:47,280
depend on a

01:04:45,440 --> 01:04:49,920
because c depends on b which depends on

01:04:47,280 --> 01:04:54,559
a so it's actually wrong

01:04:49,920 --> 01:04:56,480
yeah i see um i think the right result

01:04:54,559 --> 01:04:58,160
i'm trying to decide the most i think

01:04:56,480 --> 01:04:59,520
that

01:04:58,160 --> 01:05:01,200
there's a number of times you could do

01:04:59,520 --> 01:05:03,359
this

01:05:01,200 --> 01:05:05,119
but the bottom line is you have to like

01:05:03,359 --> 01:05:08,480
we could use

01:05:05,119 --> 01:05:11,200
we could what we could do is

01:05:08,480 --> 01:05:12,160
um we could do the what do you call it

01:05:11,200 --> 01:05:15,280
union find

01:05:12,160 --> 01:05:16,960
algorithm like union find is probably

01:05:15,280 --> 01:05:18,960
actually the easiest way to do this

01:05:16,960 --> 01:05:22,319
which is to say that we

01:05:18,960 --> 01:05:23,920
you know we say okay

01:05:22,319 --> 01:05:26,079
wait what was the what was the minimum

01:05:23,920 --> 01:05:28,799
dfn

01:05:26,079 --> 01:05:29,599
if we used dfns and stuff we could poke

01:05:28,799 --> 01:05:31,200
back up

01:05:29,599 --> 01:05:33,760
and get union find that would be like

01:05:31,200 --> 01:05:35,119
that maximally efficient we would say

01:05:33,760 --> 01:05:37,119
we would just never forget that as the

01:05:35,119 --> 01:05:39,520
end result we'd have the dfn for c

01:05:37,119 --> 01:05:40,960
would be okay well c depended on b and

01:05:39,520 --> 01:05:44,000
then we would we would unify b

01:05:40,960 --> 01:05:46,000
with a and then we would say

01:05:44,000 --> 01:05:47,039
uh we found c let's let's refresh to

01:05:46,000 --> 01:05:49,520
whatever's

01:05:47,039 --> 01:05:50,799
the transient thing so that makes sense

01:05:49,520 --> 01:05:53,440
um

01:05:50,799 --> 01:05:54,480
yeah wait i feel like using union find

01:05:53,440 --> 01:05:57,760
why did

01:05:54,480 --> 01:06:00,480
why did b not get updated to zero here

01:05:57,760 --> 01:06:04,079
oh it will it will b will get updated to

01:06:00,480 --> 01:06:04,960
zero but that's not the problem the

01:06:04,079 --> 01:06:08,480
problem is here

01:06:04,960 --> 01:06:12,400
this is reach depth equals one

01:06:08,480 --> 01:06:12,400
because at the time when b gets

01:06:14,480 --> 01:06:23,920
but i mean oh i see what you mean

01:06:19,599 --> 01:06:27,520
yeah because c depends on b depends on a

01:06:23,920 --> 01:06:28,319
right so d union five would be like the

01:06:27,520 --> 01:06:30,720
laziest

01:06:28,319 --> 01:06:31,680
thing but i think just eagerly updating

01:06:30,720 --> 01:06:34,880
them when we pop b

01:06:31,680 --> 01:06:35,280
is the easier thing and probably more

01:06:34,880 --> 01:06:38,079
correct

01:06:35,280 --> 01:06:38,640
or i don't know whether it's more

01:06:38,079 --> 01:06:42,799
efficient

01:06:38,640 --> 01:06:42,799
they're probably both fine um

01:06:43,119 --> 01:06:46,640
that's what i'm going to do it's not

01:06:45,760 --> 01:06:49,839
hard it's just

01:06:46,640 --> 01:06:51,119
annoying um

01:06:49,839 --> 01:06:54,720
basically i think what you would do is

01:06:51,119 --> 01:06:54,720
when you insert a provisional entry

01:06:56,319 --> 01:07:03,760
you want to say everything

01:07:01,200 --> 01:07:06,319
everything with a dfn greater than my

01:07:03,760 --> 01:07:06,319
dfn

01:07:06,720 --> 01:07:12,079
has to have it has to have the minimum

01:07:08,880 --> 01:07:12,079
of its depth and my depth

01:07:12,480 --> 01:07:15,920
because that's stuff that was added

01:07:14,480 --> 01:07:19,039
after i started

01:07:15,920 --> 01:07:21,760
and it's all now dependent on anything

01:07:19,039 --> 01:07:21,760
that i'm dependent on

01:07:22,400 --> 01:07:29,839
yeah that sounds like it

01:07:26,240 --> 01:07:29,839
it'll work

01:07:31,440 --> 01:07:34,720
it will work and i do have to drop off

01:07:33,280 --> 01:07:37,280
now because i have another call

01:07:34,720 --> 01:07:38,240
but we've at least i think we covered

01:07:37,280 --> 01:07:40,720
everything

01:07:38,240 --> 01:07:41,520
i wish i had a test for this ah it's so

01:07:40,720 --> 01:07:44,079
annoying there should

01:07:41,520 --> 01:07:46,880
we should add some rusty attribute or

01:07:44,079 --> 01:07:46,880
something that lets us

01:07:47,039 --> 01:07:51,440
be clever and tell girls no that lets us

01:07:49,440 --> 01:07:55,119
do like what we can do in shock

01:07:51,440 --> 01:07:55,760
yeah rusty evaluate predicate a my trait

01:07:55,119 --> 01:07:59,119
or something

01:07:55,760 --> 01:07:59,680
you know uh the annoying thing is i also

01:07:59,119 --> 01:08:01,520
couldn't

01:07:59,680 --> 01:08:04,720
i could not convince that standalone

01:08:01,520 --> 01:08:07,200
test to reproduce for me

01:08:04,720 --> 01:08:08,720
in in any way partially because i don't

01:08:07,200 --> 01:08:11,760
have this like if i had this

01:08:08,720 --> 01:08:13,599
capability i think we could do it but i

01:08:11,760 --> 01:08:14,880
couldn't like trigger the evaluates in

01:08:13,599 --> 01:08:17,120
the right order

01:08:14,880 --> 01:08:18,719
without turning off debug assertions and

01:08:17,120 --> 01:08:22,880
turning on other things

01:08:18,719 --> 01:08:25,600
yeah i mean conceptually

01:08:22,880 --> 01:08:26,960
i understand what's going on i will have

01:08:25,600 --> 01:08:29,199
to go back

01:08:26,960 --> 01:08:30,719
and like look through your exact changes

01:08:29,199 --> 01:08:31,920
and like double check that everything

01:08:30,719 --> 01:08:33,440
lines up

01:08:31,920 --> 01:08:36,080
yeah oh it's good i mean it's good for

01:08:33,440 --> 01:08:38,159
me to talk it out and through some depth

01:08:36,080 --> 01:08:39,120
i've i didn't encounter any points where

01:08:38,159 --> 01:08:43,040
i was like

01:08:39,120 --> 01:08:49,679
oh wait a minute so that's a good sign

01:08:43,040 --> 01:08:49,679

YouTube URL: https://www.youtube.com/watch?v=_tG2E9KVy5o


