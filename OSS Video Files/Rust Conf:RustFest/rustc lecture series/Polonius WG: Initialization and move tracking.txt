Title: Polonius WG: Initialization and move tracking
Publication date: 2019-05-31
Playlist: rustc lecture series
Description: 
	Discussed how the current borrow checker tracks moves and initialization and how to move that logic to polonius.

Dropbox paper link:

https://paper.dropbox.com/doc/Polonius-and-initialization--AeKw2KzJcfEftnZDZ5C9cV8iAg-mNvR4jqITCdsJDUMEhFbv
Captions: 
	00:00:00,030 --> 00:00:08,690
oh okay tasted so I'm gonna create a

00:00:03,629 --> 00:00:08,690
paper I guess yeah

00:00:10,219 --> 00:00:14,990
to start for some notes

00:00:17,680 --> 00:00:19,740
you

00:00:25,490 --> 00:00:56,160
let me put it also here just for

00:00:50,430 --> 00:01:12,119
communions and let me share this in

00:00:56,160 --> 00:01:18,479
though we'll start with this so let me

00:01:12,119 --> 00:01:25,590
do one other thing just make sure I have

00:01:18,479 --> 00:01:29,010
my notifications turned off okay so

00:01:25,590 --> 00:01:31,760
let's see so I wanted I figured I'd

00:01:29,010 --> 00:01:35,100
start by you know you just sort of

00:01:31,760 --> 00:01:37,409
explain a little bit about what the

00:01:35,100 --> 00:01:41,220
rustic rules are in st. Peter you may

00:01:37,409 --> 00:01:42,900
not have mastered them too much what

00:01:41,220 --> 00:01:46,310
we're trying to models when the user

00:01:42,900 --> 00:01:48,030
point of view you get our terminology

00:01:46,310 --> 00:01:50,640
consistent and so on

00:01:48,030 --> 00:01:54,210
we're basically we're trying to check

00:01:50,640 --> 00:01:56,970
this is like quite a bit different in

00:01:54,210 --> 00:01:58,409
some sense and the stuff about Polonius

00:01:56,970 --> 00:02:01,460
we've been doing it has nothing to do

00:01:58,409 --> 00:02:03,750
with regions or lifetimes for example um

00:02:01,460 --> 00:02:06,439
we're just we're just trying to check

00:02:03,750 --> 00:02:11,190
that all the data that you use is

00:02:06,439 --> 00:02:12,650
actually initialized at least that's the

00:02:11,190 --> 00:02:16,140
way I think about it there are different

00:02:12,650 --> 00:02:18,269
terminologies you can use and this sort

00:02:16,140 --> 00:02:21,900
of it's in a way it's a very similar to

00:02:18,269 --> 00:02:26,790
check to like you know do you ever wrote

00:02:21,900 --> 00:02:28,170
Java code there's some maybe you have

00:02:26,790 --> 00:02:31,560
and maybe that's like I'm dating myself

00:02:28,170 --> 00:02:32,849
or something but man I haven't written

00:02:31,560 --> 00:02:33,510
it in a while you know see how does this

00:02:32,849 --> 00:02:36,060
work something like

00:02:33,510 --> 00:02:37,980
this I don't know anyway there's some

00:02:36,060 --> 00:02:41,909
check that would give you an error I

00:02:37,980 --> 00:02:43,890
initialized variable this is a kind of

00:02:41,909 --> 00:02:50,099
standard check that people teaching

00:02:43,890 --> 00:03:05,250
compiler courses for example and we do a

00:02:50,099 --> 00:03:08,310
fancy version of that check so the

00:03:05,250 --> 00:03:14,840
reason our check is fancier is first of

00:03:08,310 --> 00:03:14,840
all you know yes

00:03:16,849 --> 00:03:24,239
first of all yes it would give an error

00:03:19,349 --> 00:03:29,489
in this situation just like in in the

00:03:24,239 --> 00:03:31,709
Java sort of case but there are some

00:03:29,489 --> 00:03:35,010
other things that we can handle as well

00:03:31,709 --> 00:03:44,310
right so obviously the most obvious one

00:03:35,010 --> 00:03:49,079
is something like this where you moved

00:03:44,310 --> 00:03:54,480
out of V and I call that D

00:03:49,079 --> 00:03:56,340
initialization basically what's after

00:03:54,480 --> 00:03:58,440
you do a move out what's left in that

00:03:56,340 --> 00:04:05,010
variable is just initialize memory from

00:03:58,440 --> 00:04:13,410
our point of view and the other thing

00:04:05,010 --> 00:04:15,239
that we do which is a bit soul is we we

00:04:13,410 --> 00:04:16,769
track things at a finer level of

00:04:15,239 --> 00:04:23,610
granularity than just individual

00:04:16,769 --> 00:04:25,940
variables so we might have like two two

00:04:23,610 --> 00:04:29,130
vectors and we can drop to below zero

00:04:25,940 --> 00:04:33,270
and of course we're going to error if we

00:04:29,130 --> 00:04:39,659
try to use tuple by zero but if we try

00:04:33,270 --> 00:04:43,159
to access 2.1 that's okay but we don't

00:04:39,659 --> 00:04:45,260
track things at infinite granularity

00:04:43,159 --> 00:04:48,300
because

00:04:45,260 --> 00:04:51,720
various reasons there are some cases

00:04:48,300 --> 00:04:53,880
where we where we done so basically

00:04:51,720 --> 00:04:57,660
there are various cases where it's not

00:04:53,880 --> 00:05:00,260
actually legal to D initialize memory in

00:04:57,660 --> 00:05:07,610
the first place right so one of them is

00:05:00,260 --> 00:05:12,410
you can't move out from borrowed data

00:05:07,610 --> 00:05:12,410
and move the referent of a reference

00:05:12,560 --> 00:05:27,290
another example that's a little more

00:05:14,940 --> 00:05:27,290
subtle is if a struck implements drug

00:05:34,370 --> 00:05:40,260
you can't move

00:05:36,390 --> 00:05:42,570
fields of that structure ordinarily you

00:05:40,260 --> 00:05:45,750
can move fields of a struct just like

00:05:42,570 --> 00:05:49,440
with the tuple however if they implement

00:05:45,750 --> 00:05:51,390
drop you can't and the reason is now

00:05:49,440 --> 00:05:56,220
it's sort of confusing and a little

00:05:51,390 --> 00:05:57,750
unclear like do we run drop we can't run

00:05:56,220 --> 00:06:00,600
a drop now because all the fields aren't

00:05:57,750 --> 00:06:02,520
there so we can poke the destructor but

00:06:00,600 --> 00:06:03,960
then what happened the destructor just

00:06:02,520 --> 00:06:11,940
never runs I don't know it's just weird

00:06:03,960 --> 00:06:15,120
so we don't like it to do it and I think

00:06:11,940 --> 00:06:21,450
there's a third case I don't know where

00:06:15,120 --> 00:06:23,640
this o slices similarly even if you have

00:06:21,450 --> 00:06:28,260
an array or a slice or something like

00:06:23,640 --> 00:06:33,120
this we don't let you drop out of it

00:06:28,260 --> 00:06:37,630
because that would require us to sort of

00:06:33,120 --> 00:06:40,750
know well let's come to the next point

00:06:37,630 --> 00:06:41,170
we don't allow this and why don't we

00:06:40,750 --> 00:06:42,940
allow it

00:06:41,170 --> 00:06:45,130
well so there's a thing that's only

00:06:42,940 --> 00:06:47,820
tangentially related which is like

00:06:45,130 --> 00:06:52,690
dynamic drop so basically here we say

00:06:47,820 --> 00:07:03,640
some we don't allow moves from all

00:06:52,690 --> 00:07:05,440
possible so we also allow you to move so

00:07:03,640 --> 00:07:08,350
a dynamic drop this was a hot debate

00:07:05,440 --> 00:07:12,450
some time ago by now it's settled law I

00:07:08,350 --> 00:07:28,450
guess but the question is if you have

00:07:12,450 --> 00:07:32,220
something like this when does let's

00:07:28,450 --> 00:07:37,860
suppose that that in some particular run

00:07:32,220 --> 00:07:40,810
something is false this this variable

00:07:37,860 --> 00:07:46,720
now the question is well let's suppose

00:07:40,810 --> 00:07:48,280
something is true I guess to start so if

00:07:46,720 --> 00:07:50,970
it's true then the vector is going to be

00:07:48,280 --> 00:07:53,470
dropped here and obviously that means

00:07:50,970 --> 00:07:58,240
you know it would it would be an error

00:07:53,470 --> 00:08:02,080
to access the from the code here because

00:07:58,240 --> 00:08:04,630
it may or may not be initialized but the

00:08:02,080 --> 00:08:06,550
question is so the memory gets freed

00:08:04,630 --> 00:08:08,530
here so everything's kind of fine in

00:08:06,550 --> 00:08:12,940
that case the question is if it doesn't

00:08:08,530 --> 00:08:15,000
go down that path if it goes if it goes

00:08:12,940 --> 00:08:17,350
down this path

00:08:15,000 --> 00:08:20,530
when do we free the memory for the

00:08:17,350 --> 00:08:23,560
vector do we free it sort of somewhere

00:08:20,530 --> 00:08:28,270
in this else branch or do we free it as

00:08:23,560 --> 00:08:31,240
we exit this block and the answer in

00:08:28,270 --> 00:08:32,680
rust is that V gets freed here for

00:08:31,240 --> 00:08:36,660
better or worse that's the semantics we

00:08:32,680 --> 00:08:39,880
chose and a side effect of that is that

00:08:36,660 --> 00:08:41,800
actually V only maybe gets freed here

00:08:39,880 --> 00:08:43,930
right because it depends on which path

00:08:41,800 --> 00:08:45,660
we took through the program so we call

00:08:43,930 --> 00:08:48,760
that dynamic drop because it's

00:08:45,660 --> 00:08:51,510
dynamically decided whether we will drop

00:08:48,760 --> 00:08:53,760
the vector V as we exit this

00:08:51,510 --> 00:08:56,790
function it basically depends on if

00:08:53,760 --> 00:08:59,700
somebody moved it already or not and in

00:08:56,790 --> 00:09:03,320
the limit or in cases like this the

00:08:59,700 --> 00:09:08,880
compiler will actually insert a sort of

00:09:03,320 --> 00:09:12,030
flag which is set to true when when the

00:09:08,880 --> 00:09:20,700
thing is initialized and then set the

00:09:12,030 --> 00:09:22,680
false here you could not of course write

00:09:20,700 --> 00:09:26,550
code like this we wouldn't allow you to

00:09:22,680 --> 00:09:29,700
yourself but effectively be write

00:09:26,550 --> 00:09:31,620
something like this to actually do the

00:09:29,700 --> 00:09:33,930
drop so in the mirror this is all that

00:09:31,620 --> 00:09:35,400
that flag gets added after Bartek so

00:09:33,930 --> 00:09:40,500
from bar checks point of view it doesn't

00:09:35,400 --> 00:09:45,600
exist from borrowed checks point of view

00:09:40,500 --> 00:09:50,250
if we just look at the mirror it'll look

00:09:45,600 --> 00:09:53,490
something like V equals you know a new

00:09:50,250 --> 00:09:57,480
vector whatever that looks like some

00:09:53,490 --> 00:10:06,050
bunch of random code you know switch on

00:09:57,480 --> 00:10:08,910
something this is like basic block 0 no

00:10:06,050 --> 00:10:12,770
I'm kind of forget what Mir looks like

00:10:08,910 --> 00:10:17,510
playing my life that you get the idea

00:10:12,770 --> 00:10:17,510
stylized stylized version of mirrors and

00:10:20,450 --> 00:10:30,540
so one thing to note is that I'll just

00:10:25,380 --> 00:10:32,940
do it like this oh I guess it would be

00:10:30,540 --> 00:10:35,550
like so we don't really need this well

00:10:32,940 --> 00:10:47,460
I'll leave the else block in here that's

00:10:35,550 --> 00:10:48,960
a basic block so from the compilers

00:10:47,460 --> 00:10:58,570
point of view this looks kind of like

00:10:48,960 --> 00:11:09,230
this this isn't quite right that but

00:10:58,570 --> 00:11:12,320
so yeah not not that it matters but drop

00:11:09,230 --> 00:11:13,640
drop is a terminator in the mirror so it

00:11:12,320 --> 00:11:18,340
always comes at the end of a basic block

00:11:13,640 --> 00:11:18,340
and that's because it can unwind but

00:11:18,370 --> 00:11:30,850
annoyingly actually I know something I

00:11:21,470 --> 00:11:30,850
would change if I could but any case so

00:11:31,450 --> 00:11:36,320
right so what you see is that actually

00:11:34,790 --> 00:11:39,500
in the mirror as we see it there are two

00:11:36,320 --> 00:11:42,980
drops for V and it's certainly possible

00:11:39,500 --> 00:11:45,770
for one to reach the other and because

00:11:42,980 --> 00:11:49,070
you can go from zero to one two three

00:11:45,770 --> 00:11:50,960
and now you've got two drops so mirrors

00:11:49,070 --> 00:11:52,810
kind of semantics is that you can drop

00:11:50,960 --> 00:11:55,220
the same thing multiple times and that's

00:11:52,810 --> 00:11:58,540
that's okay we you can sort of imagine

00:11:55,220 --> 00:12:01,070
that the runtime semantics includes a

00:11:58,540 --> 00:12:03,230
flag for whether it's initialized or not

00:12:01,070 --> 00:12:06,860
and drop has the semantics of checking

00:12:03,230 --> 00:12:09,260
this flag and then dropping only if it

00:12:06,860 --> 00:12:11,750
is and then we later sort of lower that

00:12:09,260 --> 00:12:18,370
by making the flag explicit where it's

00:12:11,750 --> 00:12:20,510
necessary and otherwise not right so

00:12:18,370 --> 00:12:22,160
after that big tangent what does that

00:12:20,510 --> 00:12:26,600
have to do with this well that relates

00:12:22,160 --> 00:12:28,460
to these arrays because if we allow you

00:12:26,600 --> 00:12:30,760
to drop from an array we would have to

00:12:28,460 --> 00:12:35,570
remember which index you dropped and

00:12:30,760 --> 00:12:37,010
which indexes you didn't and that means

00:12:35,570 --> 00:12:37,910
we can't just use boolean Flags they

00:12:37,010 --> 00:12:40,370
have to be something more complicated

00:12:37,910 --> 00:12:43,760
and so we didn't want to support that so

00:12:40,370 --> 00:12:45,380
we just don't um there's a couple other

00:12:43,760 --> 00:12:52,400
situations I think the other one is you

00:12:45,380 --> 00:12:55,760
can't drop oh well no you can never mind

00:12:52,400 --> 00:12:57,080
you that there's something about enums

00:12:55,760 --> 00:13:00,620
and matching which doesn't really matter

00:12:57,080 --> 00:13:02,860
here you can't do you can't sort of drop

00:13:00,620 --> 00:13:05,210
some parts of an enum and not others but

00:13:02,860 --> 00:13:07,339
or we will drop all the rest for you

00:13:05,210 --> 00:13:10,910
it's kind of what happens

00:13:07,339 --> 00:13:12,680
in any case all right so come back to

00:13:10,910 --> 00:13:13,939
this so this is what we wanted this is

00:13:12,680 --> 00:13:17,110
the analysis we want to implement

00:13:13,939 --> 00:13:20,569
basically we want to give these errors

00:13:17,110 --> 00:13:22,610
when you try to move or what bar check

00:13:20,569 --> 00:13:23,839
currently does it will give you errors

00:13:22,610 --> 00:13:26,360
when you try to move from things you're

00:13:23,839 --> 00:13:27,829
not supposed to move from but more

00:13:26,360 --> 00:13:29,269
importantly it'll give you errors when

00:13:27,829 --> 00:13:32,720
you access things that may not be

00:13:29,269 --> 00:13:34,160
initialized and actually these errors we

00:13:32,720 --> 00:13:37,189
probably won't do in polonius at least

00:13:34,160 --> 00:13:41,149
not to start maybe never because they're

00:13:37,189 --> 00:13:42,709
not really I mean what I mean is the

00:13:41,149 --> 00:13:45,019
error is about moving from a path you're

00:13:42,709 --> 00:13:52,009
not supposed to move from those are like

00:13:45,019 --> 00:13:55,970
not very interesting um so oh why is my

00:13:52,009 --> 00:14:04,129
screen sharing polished was my screen

00:13:55,970 --> 00:14:11,660
share been paused this whole time it

00:14:04,129 --> 00:14:19,550
just had you okay somehow you followed

00:14:11,660 --> 00:14:22,610
okay that's good so all right so that

00:14:19,550 --> 00:14:26,449
sort of made sense so far I hope so

00:14:22,610 --> 00:14:32,240
what what does this analysis look like

00:14:26,449 --> 00:14:34,689
well it let's actually drop over to code

00:14:32,240 --> 00:14:34,689
a little bit

00:14:39,680 --> 00:14:52,800
this analysis so if you go to borrow

00:14:45,000 --> 00:14:56,399
Chuck and we go over yeah you'll start

00:14:52,800 --> 00:15:02,279
to see what we do somewhere

00:14:56,399 --> 00:15:06,329
okay so bunch of code so when we

00:15:02,279 --> 00:15:08,040
actually do the analysis this part isn't

00:15:06,329 --> 00:15:09,690
too important or it will be important

00:15:08,040 --> 00:15:17,040
but it's not a high level important but

00:15:09,690 --> 00:15:22,620
there's three steps we construct this

00:15:17,040 --> 00:15:24,029
move data and I'm going to talk about

00:15:22,620 --> 00:15:25,769
that in a bit but that's sort of more

00:15:24,029 --> 00:15:32,639
how its implemented than the conceptual

00:15:25,769 --> 00:15:35,250
thing then we compute to two important

00:15:32,639 --> 00:15:40,769
sets of bits and one of them is called

00:15:35,250 --> 00:15:49,259
may be initialized and one of them is

00:15:40,769 --> 00:15:51,149
may be uninitialized that's here

00:15:49,259 --> 00:15:53,730
I mean computer fewer well I guess

00:15:51,149 --> 00:15:56,370
there's three I'll explain why there's

00:15:53,730 --> 00:15:58,050
three in a second if there's one third

00:15:56,370 --> 00:16:01,199
set that is a little bit of a sidestep

00:15:58,050 --> 00:16:04,709
called ever initialized and I'll explain

00:16:01,199 --> 00:16:12,810
that learning it that's sort of a weird

00:16:04,709 --> 00:16:14,730
one nice not as central and so what

00:16:12,810 --> 00:16:19,079
these bits are is they're basically

00:16:14,730 --> 00:16:22,019
tracking what sets of paths have been or

00:16:19,079 --> 00:16:25,050
maybe as it says initialize that a given

00:16:22,019 --> 00:16:27,180
point and which ones may not be and so

00:16:25,050 --> 00:16:31,769
the way we do this so if you recall I

00:16:27,180 --> 00:16:33,899
said that we we allow you to we have to

00:16:31,769 --> 00:16:43,470
we have to track this not just at the

00:16:33,899 --> 00:16:47,670
resolution of sorry I'm not just at the

00:16:43,470 --> 00:16:52,319
resolution of local variables but also

00:16:47,670 --> 00:16:53,130
sub tabs like tuple 0 right and there

00:16:52,319 --> 00:16:56,340
could be like

00:16:53,130 --> 00:17:00,150
infinite sort of set of potentially

00:16:56,340 --> 00:17:07,589
interesting pads if you imagine like a

00:17:00,150 --> 00:17:12,360
recursive structure like like so yeah

00:17:07,589 --> 00:17:13,770
you get the idea and well it turns out

00:17:12,360 --> 00:17:19,079
they would have to terminate in an

00:17:13,770 --> 00:17:22,319
option actually but nonetheless there

00:17:19,079 --> 00:17:23,670
could be a left s like you could imagine

00:17:22,319 --> 00:17:25,199
that if you just started like all the

00:17:23,670 --> 00:17:27,150
pads that user might name there could be

00:17:25,199 --> 00:17:29,840
quite a lot so what we actually do is we

00:17:27,150 --> 00:17:34,470
construct the pads that we actually see

00:17:29,840 --> 00:17:36,060
and only those in within the source

00:17:34,470 --> 00:17:39,900
function we're analyzing right so for

00:17:36,060 --> 00:17:42,690
this one we might we might well first of

00:17:39,900 --> 00:17:45,030
all we'll always make well we have this

00:17:42,690 --> 00:17:46,440
we have this set of interesting move

00:17:45,030 --> 00:17:48,600
pads and we're gonna give each one an

00:17:46,440 --> 00:17:50,100
index and we first thing we do is we

00:17:48,600 --> 00:17:52,470
make one for every local variable cuz

00:17:50,100 --> 00:17:54,510
that's just makes our lives easier so

00:17:52,470 --> 00:17:55,800
there would be a path for tuple but then

00:17:54,510 --> 00:17:57,690
we're gonna analyze the program and

00:17:55,800 --> 00:18:01,290
we're gonna see oh the user actually

00:17:57,690 --> 00:18:03,900
accesses tuple 0 so I'll make a path for

00:18:01,290 --> 00:18:06,720
tuple dot 0 and then later we'll see

00:18:03,900 --> 00:18:08,430
that they access to pull dot 1 so we'll

00:18:06,720 --> 00:18:11,010
make a path for tuple not 1 if it

00:18:08,430 --> 00:18:13,380
happened that they didn't ever access

00:18:11,010 --> 00:18:28,560
Google that one then we just would have

00:18:13,380 --> 00:18:36,840
no path worth so what does they mean by

00:18:28,560 --> 00:18:42,270
dynamic access to the tuple oh no you

00:18:36,840 --> 00:18:43,950
can't do that okay so for a tuple you

00:18:42,270 --> 00:18:45,960
could access to a slice or something but

00:18:43,950 --> 00:18:48,660
now so basically we take the path that

00:18:45,960 --> 00:18:50,190
you act you accessed and where we go

00:18:48,660 --> 00:18:51,900
through and look at each each path that

00:18:50,190 --> 00:18:55,160
appears in this function I mean we could

00:18:51,900 --> 00:19:02,510
have construct one of these indexes on

00:18:55,160 --> 00:19:05,220
but we don't access every possible path

00:19:02,510 --> 00:19:06,850
we only construct embassies for paths

00:19:05,220 --> 00:19:09,700
that you actually could drop

00:19:06,850 --> 00:19:12,940
so pads like this star from uh through a

00:19:09,700 --> 00:19:15,429
reference or a field of a struck that

00:19:12,940 --> 00:19:17,799
implements drop we're gonna see later we

00:19:15,429 --> 00:19:20,259
will never have what's called a move

00:19:17,799 --> 00:19:22,389
path for that because we don't really

00:19:20,259 --> 00:19:25,779
need to track the initialization of that

00:19:22,389 --> 00:19:27,970
because it can't be it can't have been

00:19:25,779 --> 00:19:30,340
it can't be D initialized so it's

00:19:27,970 --> 00:19:32,350
basically initialized if the parent path

00:19:30,340 --> 00:19:37,899
is initialized and otherwise not right

00:19:32,350 --> 00:19:42,179
um so right so that's what a move path

00:19:37,899 --> 00:19:47,080
is essentially it's just it's just in an

00:19:42,179 --> 00:19:51,429
index the maps to a path that we you

00:19:47,080 --> 00:19:53,860
might have moved from that you've used

00:19:51,429 --> 00:19:56,889
and we have these these are arranged in

00:19:53,860 --> 00:19:58,960
in a sort of couple different ways but

00:19:56,889 --> 00:20:00,909
one of them is a tree so that you can go

00:19:58,960 --> 00:20:03,990
from the parent to each of the children

00:20:00,909 --> 00:20:07,360
and vice versa so let me show you that

00:20:03,990 --> 00:20:09,549
or let me not quite sure that the reason

00:20:07,360 --> 00:20:12,490
I'm talking about move paths is once we

00:20:09,549 --> 00:20:14,590
have indices for all these now when we

00:20:12,490 --> 00:20:18,159
do these analyses like is it may be

00:20:14,590 --> 00:20:20,740
initialized these are basically

00:20:18,159 --> 00:20:24,039
computing these are data flow analysis

00:20:20,740 --> 00:20:27,610
their computing bid sets so we now have

00:20:24,039 --> 00:20:29,259
bits to express them in terms of right

00:20:27,610 --> 00:20:32,769
there are sets of these with these

00:20:29,259 --> 00:20:37,389
indices so may be initialized you might

00:20:32,769 --> 00:20:44,110
have if we look at this function you

00:20:37,389 --> 00:20:48,549
might say okay at this point there's

00:20:44,110 --> 00:20:52,029
nothing initialized at this point we've

00:20:48,549 --> 00:20:54,309
initialized zero one and two because by

00:20:52,029 --> 00:20:55,899
assigning to tuple we also assigned to

00:20:54,309 --> 00:21:00,549
all the sub pads and tuples sort of

00:20:55,899 --> 00:21:06,759
implicitly if that makes sense and then

00:21:00,549 --> 00:21:10,570
at this point we moved out of of one so

00:21:06,759 --> 00:21:15,669
we only have zero and two or maybe

00:21:10,570 --> 00:21:17,080
initialized right make sense okay so

00:21:15,669 --> 00:21:20,650
let's let's look at this move path real

00:21:17,080 --> 00:21:23,350
fast just to be clear

00:21:20,650 --> 00:21:25,900
or my my planned result or walkthrough

00:21:23,350 --> 00:21:27,940
what the code does today and then I will

00:21:25,900 --> 00:21:30,520
sort of pivot to what part of this

00:21:27,940 --> 00:21:33,850
Polonius will do which shouldn't take

00:21:30,520 --> 00:21:38,920
that long I hope so we'll see how far we

00:21:33,850 --> 00:21:41,950
get right so this gather moves what this

00:21:38,920 --> 00:21:45,130
is actually doing is creating those move

00:21:41,950 --> 00:21:47,230
pads and also just indexing it's kind of

00:21:45,130 --> 00:21:50,770
computing in the Polonius sense the base

00:21:47,230 --> 00:21:56,230
input facts from the program actually

00:21:50,770 --> 00:21:57,309
and if you see if I can find where that

00:21:56,230 --> 00:22:02,500
code actually lives

00:21:57,309 --> 00:22:05,200
I think this code lives in dataflow yeah

00:22:02,500 --> 00:22:07,240
so this code is not part of Baro check

00:22:05,200 --> 00:22:11,679
this move analysis code and that's

00:22:07,240 --> 00:22:14,050
because it was initially written before

00:22:11,679 --> 00:22:17,860
we had the mihrab ro check we still had

00:22:14,050 --> 00:22:20,980
to do this dynamic drop analysis and it

00:22:17,860 --> 00:22:22,660
used a lot of this code it was like the

00:22:20,980 --> 00:22:27,460
first consumer because it also had to do

00:22:22,660 --> 00:22:30,970
similar answer similar questions anyway

00:22:27,460 --> 00:22:32,740
so the move paths so this is the the in

00:22:30,970 --> 00:22:37,000
terms of the code we have this move

00:22:32,740 --> 00:22:42,429
passed index that's just a new typed

00:22:37,000 --> 00:22:50,140
index that represents a move path you

00:22:42,429 --> 00:22:55,510
just drop in some code links so this is

00:22:50,140 --> 00:23:09,420
a new typed index representing a move

00:22:55,510 --> 00:23:13,190
path and the actual move path is here so

00:23:09,420 --> 00:23:17,570
you see that it contains

00:23:13,190 --> 00:23:19,850
a place this is a mere place or what

00:23:17,570 --> 00:23:22,790
I've been calling path mere we called it

00:23:19,850 --> 00:23:24,980
place something else I might change

00:23:22,790 --> 00:23:28,670
something or I would possibly change but

00:23:24,980 --> 00:23:31,340
anyway so this is like where's this is

00:23:28,670 --> 00:23:33,890
the the mirror version of you know tuple

00:23:31,340 --> 00:23:35,660
dot zero or whatever so we're kind of in

00:23:33,890 --> 00:23:37,580
turning them into these move pets and

00:23:35,660 --> 00:23:39,860
then these these three fields these

00:23:37,580 --> 00:23:41,870
encode the tree not sure if you've seen

00:23:39,860 --> 00:23:45,050
this encoding of a tree before but it's

00:23:41,870 --> 00:23:48,590
super useful so this is a link to the

00:23:45,050 --> 00:23:51,740
parent the index of our parent this is a

00:23:48,590 --> 00:23:54,110
link to or rather this one is a link to

00:23:51,740 --> 00:23:56,630
our first child and then there's a link

00:23:54,110 --> 00:24:00,320
list that's what the next sibling field

00:23:56,630 --> 00:24:02,060
is is our child well you can sort of go

00:24:00,320 --> 00:24:05,180
down the list the siblings of the child

00:24:02,060 --> 00:24:06,350
of the child so this way you store the

00:24:05,180 --> 00:24:08,870
nice thing about this encoding of the

00:24:06,350 --> 00:24:10,640
tree is you can store two fields per if

00:24:08,870 --> 00:24:14,090
you ignore the parent from two fields

00:24:10,640 --> 00:24:16,880
per node but you can sort of build an

00:24:14,090 --> 00:24:21,680
arbitrary size tree um you don't need to

00:24:16,880 --> 00:24:24,500
have like a vector for example a vector

00:24:21,680 --> 00:24:28,700
of children um so it's more condensed

00:24:24,500 --> 00:24:30,650
well depends on your pointing you but in

00:24:28,700 --> 00:24:32,510
any case that's how it's encoded it's a

00:24:30,650 --> 00:24:34,250
linked list threaded through this next

00:24:32,510 --> 00:24:36,710
sibling and you can kind of see that

00:24:34,250 --> 00:24:38,960
like oh well this is a this is some code

00:24:36,710 --> 00:24:42,050
that walks up the parents of a path

00:24:38,960 --> 00:24:43,180
that's very easy you just get the parent

00:24:42,050 --> 00:24:47,300
and iterate

00:24:43,180 --> 00:24:51,710
loading the next parent each time but

00:24:47,300 --> 00:24:56,860
there's some other code like mmm where

00:24:51,710 --> 00:25:00,740
is it I don't know somewhere or other

00:24:56,860 --> 00:25:02,540
that I don't see right now probably in

00:25:00,740 --> 00:25:04,910
another module there'll be some code

00:25:02,540 --> 00:25:06,920
that like walks all the children for

00:25:04,910 --> 00:25:09,410
example of a given index and it'll do

00:25:06,920 --> 00:25:11,410
that by first load the first child and

00:25:09,410 --> 00:25:14,240
then from there load the next sibling

00:25:11,410 --> 00:25:16,070
okay so that's what these move paths are

00:25:14,240 --> 00:25:19,040
that's alright and where they're built

00:25:16,070 --> 00:25:21,310
that's what I wanted to show you so the

00:25:19,040 --> 00:25:24,640
first thing we do is this gather moves

00:25:21,310 --> 00:25:28,360
function which is here

00:25:24,640 --> 00:25:52,090
and all that does is it invokes this

00:25:28,360 --> 00:25:54,309
builder so this builder is here and what

00:25:52,090 --> 00:25:56,410
this is going to do is walk over all the

00:25:54,309 --> 00:25:58,600
statements and the terminators in the

00:25:56,410 --> 00:26:01,600
mirror and gather information about them

00:25:58,600 --> 00:26:05,049
by calling you know gather statement

00:26:01,600 --> 00:26:07,780
which invokes some visitor which is the

00:26:05,049 --> 00:26:09,820
gatherer and the gather statement will

00:26:07,780 --> 00:26:12,370
look and it kind of truck it's basically

00:26:09,820 --> 00:26:14,799
looking for what are the effects of each

00:26:12,370 --> 00:26:16,600
kind of mere statement so this is what I

00:26:14,799 --> 00:26:19,780
meant by the this is basically building

00:26:16,600 --> 00:26:21,720
up your your polonius facts or what

00:26:19,780 --> 00:26:25,870
Polonius would call the input facts so

00:26:21,720 --> 00:26:29,950
for example here it says okay we have an

00:26:25,870 --> 00:26:34,299
assignment into place from graph I'll

00:26:29,950 --> 00:26:37,870
first create move path what does that do

00:26:34,299 --> 00:26:40,080
that um that will take this this mere

00:26:37,870 --> 00:26:44,770
place and create a move path

00:26:40,080 --> 00:26:46,840
corresponding to it and we're gonna look

00:26:44,770 --> 00:26:49,840
at this in a second but if you remember

00:26:46,840 --> 00:26:51,880
I told you that not all move paths not

00:26:49,840 --> 00:26:55,600
all places have move pads because they

00:26:51,880 --> 00:26:57,520
can't all be moved out of so this

00:26:55,600 --> 00:27:00,040
function doesn't always succeed but here

00:26:57,520 --> 00:27:01,360
we don't care it might this function

00:27:00,040 --> 00:27:03,070
might give back an error basically

00:27:01,360 --> 00:27:06,010
saying this is not something that I can

00:27:03,070 --> 00:27:11,460
make a move that for if it were like a

00:27:06,010 --> 00:27:17,799
field of a struck with drop and then

00:27:11,460 --> 00:27:22,120
where was I found here somewhere all

00:27:17,799 --> 00:27:25,059
right then it's gonna say oh like for

00:27:22,120 --> 00:27:30,000
example this is an assignment so I'm

00:27:25,059 --> 00:27:31,870
initializing this place here therefore I

00:27:30,000 --> 00:27:34,780
don't know what this initialization

00:27:31,870 --> 00:27:38,800
State thing is oh this is some you can

00:27:34,780 --> 00:27:41,180
kind of ignore that that's a weird thing

00:27:38,800 --> 00:27:43,610
basically it's saying this this gather

00:27:41,180 --> 00:27:47,470
in it this is going to add it it's going

00:27:43,610 --> 00:27:53,120
to mark that at this location we

00:27:47,470 --> 00:27:55,990
initialize this place so let me jump

00:27:53,120 --> 00:27:55,990
back one moment

00:27:56,470 --> 00:28:10,100
oops just go back to yeah so the move

00:28:03,410 --> 00:28:13,940
data and where am I no okay the move

00:28:10,100 --> 00:28:15,740
data that we're constructing I should

00:28:13,940 --> 00:28:17,300
have talked about this actually has it

00:28:15,740 --> 00:28:19,280
this is the thing called the move data

00:28:17,300 --> 00:28:21,620
and I spent a lot of time talking about

00:28:19,280 --> 00:28:24,290
the move pads so one of the big things

00:28:21,620 --> 00:28:26,210
that move data has is an indexing for

00:28:24,290 --> 00:28:28,040
each move path index here's the actual

00:28:26,210 --> 00:28:32,810
move path data but it also has all this

00:28:28,040 --> 00:28:35,300
other stuff right and this reverse

00:28:32,810 --> 00:28:36,980
lookup that's just a map I think that

00:28:35,300 --> 00:28:39,380
helps you quickly map from place to move

00:28:36,980 --> 00:28:42,050
paths sort of rather than searching

00:28:39,380 --> 00:28:46,070
linearly through this array but this

00:28:42,050 --> 00:28:46,820
stuff like moves and location map and

00:28:46,070 --> 00:28:51,200
stuff like that

00:28:46,820 --> 00:28:53,470
this is detailing the effects so the

00:28:51,200 --> 00:28:55,940
location map says at a given location

00:28:53,470 --> 00:28:59,540
here are the paths that get moved out of

00:28:55,940 --> 00:29:01,790
from that location and the way we do

00:28:59,540 --> 00:29:07,670
that is we give each each time that

00:29:01,790 --> 00:29:09,230
there there's a move we create we have

00:29:07,670 --> 00:29:15,980
we create an entry in this vector which

00:29:09,230 --> 00:29:18,440
we call a move out and it's stores some

00:29:15,980 --> 00:29:20,090
information it's stores like this was

00:29:18,440 --> 00:29:22,670
the path that was moved and here's where

00:29:20,090 --> 00:29:26,570
it was moved from so actually in Polonia

00:29:22,670 --> 00:29:32,600
sense this would be exactly a set of

00:29:26,570 --> 00:29:37,340
facts right so the move data stores

00:29:32,600 --> 00:29:40,970
facts about the input source has the

00:29:37,340 --> 00:29:44,570
mapping from places to move paths it

00:29:40,970 --> 00:29:47,090
also has like a list of moves or move

00:29:44,570 --> 00:29:51,620
outs which I think you would kind of

00:29:47,090 --> 00:29:53,749
call like mm I don't know what

00:29:51,620 --> 00:29:58,909
I forget what there are letters we used

00:29:53,749 --> 00:30:00,740
for these things I'll call em P and P so

00:29:58,909 --> 00:30:04,999
sort of saying there was a move out from

00:30:00,740 --> 00:30:07,610
this move path to this point right and

00:30:04,999 --> 00:30:09,889
then we have we have that data indexed

00:30:07,610 --> 00:30:12,799
by where the move occurs so that you

00:30:09,889 --> 00:30:14,779
sometimes want to access it that way so

00:30:12,799 --> 00:30:16,519
just like in Polonius you end up with

00:30:14,779 --> 00:30:21,249
two versions of the same thing you have

00:30:16,519 --> 00:30:23,360
the same here and then similarly we have

00:30:21,249 --> 00:30:25,039
mapped this way if you want to know

00:30:23,360 --> 00:30:28,970
every place that a given path is moved

00:30:25,039 --> 00:30:30,889
there's a there's a mapping okay they

00:30:28,970 --> 00:30:34,909
both just index into this vector which

00:30:30,889 --> 00:30:36,529
has the data and similarly we have a

00:30:34,909 --> 00:30:43,249
list of in it's these are all the places

00:30:36,529 --> 00:30:45,440
that a path is assigned to right so this

00:30:43,249 --> 00:30:47,960
path was initialized at this location

00:30:45,440 --> 00:31:01,279
and some extra information I don't know

00:30:47,960 --> 00:31:11,749
what that is let's let's make links to

00:31:01,279 --> 00:31:13,369
this so that's what this data structure

00:31:11,749 --> 00:31:15,259
does I guess I won't dig into the

00:31:13,369 --> 00:31:17,629
gathering except to say that it fills

00:31:15,259 --> 00:31:19,399
out all those fields the one thing I

00:31:17,629 --> 00:31:24,049
want to looked at I did want to look at

00:31:19,399 --> 00:31:26,149
is the move path constructions not super

00:31:24,049 --> 00:31:34,700
exciting but it's suspect it will be

00:31:26,149 --> 00:31:36,830
relevant um so yeah so this is the

00:31:34,700 --> 00:31:42,049
function that makes a new move path I

00:31:36,830 --> 00:31:44,299
think and note that we only ever create

00:31:42,049 --> 00:31:46,369
move times in this first pass there's

00:31:44,299 --> 00:31:49,369
other functions later that do the lookup

00:31:46,369 --> 00:31:50,570
but we assume that we've sort of made

00:31:49,369 --> 00:31:52,820
all the move ties that are ever

00:31:50,570 --> 00:31:56,090
interesting in this first pass and after

00:31:52,820 --> 00:32:04,399
that it's just just looking up and so

00:31:56,090 --> 00:32:05,450
basically what it does is it what does

00:32:04,399 --> 00:32:07,039
it do

00:32:05,450 --> 00:32:10,570
this is this code has changed a little

00:32:07,039 --> 00:32:13,539
bit this is probably thanks to Santiago

00:32:10,570 --> 00:32:17,210
who's been refactoring these things so

00:32:13,539 --> 00:32:19,460
what this a place in mirror has a base

00:32:17,210 --> 00:32:21,559
like a local variable usually and then a

00:32:19,460 --> 00:32:24,320
set of projections right so this place

00:32:21,559 --> 00:32:25,429
dot iterate I think if I the code I have

00:32:24,320 --> 00:32:28,269
never seen before but this is what I

00:32:25,429 --> 00:32:35,510
think it does walks over invokes this

00:32:28,269 --> 00:32:38,750
function for each projection like a feel

00:32:35,510 --> 00:32:40,880
like if you have a dot B dot C you can

00:32:38,750 --> 00:32:42,500
see our projections they call it they

00:32:40,880 --> 00:32:49,639
call it your like projecting out from

00:32:42,500 --> 00:32:55,340
the base path that's what it's and so

00:32:49,639 --> 00:32:59,149
what does it do so or no it looks like

00:32:55,340 --> 00:33:01,760
this is a list okay so it's iterable

00:32:59,149 --> 00:33:03,409
anyway the point is we can sort of build

00:33:01,760 --> 00:33:07,909
this starting from one side and moving

00:33:03,409 --> 00:33:09,799
forward right and so we we start with

00:33:07,909 --> 00:33:11,450
the base I said that we always have for

00:33:09,799 --> 00:33:12,679
every local variable we have a path we

00:33:11,450 --> 00:33:14,960
just make one that's the easiest thing

00:33:12,679 --> 00:33:17,059
to do you can always move out of a local

00:33:14,960 --> 00:33:19,639
variable so that's fine so we do that

00:33:17,059 --> 00:33:21,950
then we walk down each projection so if

00:33:19,639 --> 00:33:24,080
you started out with a then we'll now

00:33:21,950 --> 00:33:27,820
looking at the B if you have a dot B dot

00:33:24,080 --> 00:33:32,450
C and we look at what was the type on

00:33:27,820 --> 00:33:34,370
not of the what is the type of the thing

00:33:32,450 --> 00:33:35,779
we're projecting from so if we're

00:33:34,370 --> 00:33:38,149
looking at a dot B we're looking at the

00:33:35,779 --> 00:33:40,429
type of a here and we'll give some

00:33:38,149 --> 00:33:43,850
errors in some cases right so you can't

00:33:40,429 --> 00:33:47,779
move for example out of a borrowed

00:33:43,850 --> 00:33:51,500
pointer so if we see that you're trying

00:33:47,779 --> 00:33:53,059
to build a move path that goes through a

00:33:51,500 --> 00:33:56,120
borrowed pointer we'll just stop and

00:33:53,059 --> 00:33:58,309
return an error at that point so we will

00:33:56,120 --> 00:34:03,260
we will along the way I think have built

00:33:58,309 --> 00:34:04,700
up paths for all the leading up things

00:34:03,260 --> 00:34:06,649
that led up to that point but we don't

00:34:04,700 --> 00:34:07,519
actually build one for them the

00:34:06,649 --> 00:34:12,260
referenda tough

00:34:07,519 --> 00:34:15,260
similarly if ADT is a struct if this is

00:34:12,260 --> 00:34:18,619
a struct that has a destructor will stop

00:34:15,260 --> 00:34:19,230
and so on all right but otherwise we

00:34:18,619 --> 00:34:22,560
succeed

00:34:19,230 --> 00:34:24,510
so we're going to look first check if it

00:34:22,560 --> 00:34:27,149
already is in there or not this is

00:34:24,510 --> 00:34:30,419
basically just a look it up in the

00:34:27,149 --> 00:34:33,350
hashmap um if it's not in the hashmap

00:34:30,419 --> 00:34:37,609
yet will construct a move path and

00:34:33,350 --> 00:34:40,200
that's it right so that's how we do it

00:34:37,609 --> 00:34:42,240
so then the main point is that this

00:34:40,200 --> 00:34:44,310
function basically builds all the move

00:34:42,240 --> 00:34:46,619
paths that it can and then either gives

00:34:44,310 --> 00:34:47,940
you back an okay result if it got all

00:34:46,619 --> 00:34:49,950
the way through or gives you an error of

00:34:47,940 --> 00:34:53,040
somewhere along the line it couldn't and

00:34:49,950 --> 00:34:54,480
then that error that's that's why you'll

00:34:53,040 --> 00:34:58,140
notice the remember that code that said

00:34:54,480 --> 00:34:59,520
let underscore equals so sometimes that

00:34:58,140 --> 00:35:01,080
error doesn't mean anything like if

00:34:59,520 --> 00:35:02,880
you're just if this is code is not

00:35:01,080 --> 00:35:05,280
actually moving out from that path it's

00:35:02,880 --> 00:35:07,260
just like initializing that path that's

00:35:05,280 --> 00:35:09,359
fine we don't need to have constructed

00:35:07,260 --> 00:35:11,390
all the pets but if it is an actual move

00:35:09,359 --> 00:35:14,550
we would report that error to the user

00:35:11,390 --> 00:35:17,040
and then I think we just I don't know

00:35:14,550 --> 00:35:19,380
what we do in terms of well we could

00:35:17,040 --> 00:35:21,119
look whether we actually generate a move

00:35:19,380 --> 00:35:22,410
out data structure or not we may just

00:35:21,119 --> 00:35:24,780
ignore the move in that case probably

00:35:22,410 --> 00:35:29,930
absolutely do that's what I would think

00:35:24,780 --> 00:35:29,930
would be good um if that makes sense

00:35:30,440 --> 00:35:36,510
there's this don't do this

00:35:32,760 --> 00:35:39,140
I lost my tab where did it go come back

00:35:36,510 --> 00:35:39,140
tab okay

00:35:39,290 --> 00:35:43,040
so okay

00:35:43,130 --> 00:35:50,910
so the point is this is basically we

00:35:46,740 --> 00:35:54,119
make one of these for every move that is

00:35:50,910 --> 00:36:00,090
a legal path okay all right so far so

00:35:54,119 --> 00:36:06,450
good then what do we do I think enough

00:36:00,090 --> 00:36:10,020
about move building let's talk about how

00:36:06,450 --> 00:36:13,490
we actually use this stuff I'm assuming

00:36:10,020 --> 00:36:21,060
you'll stop me if anything is confusion

00:36:13,490 --> 00:36:22,470
so what we do now once we've we've built

00:36:21,060 --> 00:36:23,490
this move data now we know where the

00:36:22,470 --> 00:36:25,890
moves are we know where the

00:36:23,490 --> 00:36:28,560
initializations are then we do these

00:36:25,890 --> 00:36:31,750
data flow computations right and these

00:36:28,560 --> 00:36:33,849
are very analogous to

00:36:31,750 --> 00:36:40,750
these are of course what we want to move

00:36:33,849 --> 00:36:42,550
to Polonius and that's but that's doing

00:36:40,750 --> 00:36:45,670
right now is it's using this dataflow

00:36:42,550 --> 00:36:49,390
framework which is kind of a generic

00:36:45,670 --> 00:36:52,090
framework II thing and the idea of this

00:36:49,390 --> 00:37:00,310
framework is that you define your own

00:36:52,090 --> 00:37:01,830
place you define analyses like see if I

00:37:00,310 --> 00:37:04,119
can find one

00:37:01,830 --> 00:37:06,880
well the framework is going to be

00:37:04,119 --> 00:37:09,580
parametrized by with by a BD or a bit

00:37:06,880 --> 00:37:11,590
denotation just basically what are we

00:37:09,580 --> 00:37:13,750
computing like the mate there's a struct

00:37:11,590 --> 00:37:15,490
that corresponds to computing maybe

00:37:13,750 --> 00:37:17,890
initialized and a struct for maybe

00:37:15,490 --> 00:37:22,420
uninitialized and that's what this BD is

00:37:17,890 --> 00:37:36,339
and that's you see we're building them

00:37:22,420 --> 00:37:38,200
here what can be that's right it's

00:37:36,339 --> 00:37:39,940
essentially so all of these are dataflow

00:37:38,200 --> 00:37:42,010
analysis right they all work the same

00:37:39,940 --> 00:37:43,990
way they have these kill in gen sets and

00:37:42,010 --> 00:37:45,490
you propagate it around it's just a

00:37:43,990 --> 00:37:47,589
matter of what do you consider a kill

00:37:45,490 --> 00:37:50,589
and what do you consider a gen and

00:37:47,589 --> 00:37:55,540
that's exactly what this denotation

00:37:50,589 --> 00:37:58,839
thing is all about so let's see if I can

00:37:55,540 --> 00:38:00,640
find where that is it so for each of

00:37:58,839 --> 00:38:04,030
these they're going to define this bit D

00:38:00,640 --> 00:38:09,700
notation which has what is the index

00:38:04,030 --> 00:38:11,050
type so this is like and then a bunch of

00:38:09,700 --> 00:38:15,280
random stuff that's not that important

00:38:11,050 --> 00:38:16,900
and then this stuff which says basically

00:38:15,280 --> 00:38:18,550
you're we're gonna call these these

00:38:16,900 --> 00:38:20,410
callbacks as we walk the control flow

00:38:18,550 --> 00:38:22,810
graph and they're supposed to add and

00:38:20,410 --> 00:38:26,830
remove things from the sets of what's

00:38:22,810 --> 00:38:28,900
present or not present right okay and so

00:38:26,830 --> 00:38:30,910
there's one it's like when you start the

00:38:28,900 --> 00:38:37,240
block before the statement when you

00:38:30,910 --> 00:38:43,960
execute the statement and if we come up

00:38:37,240 --> 00:38:45,430
to dataflow impulse we'll see some of

00:38:43,960 --> 00:38:53,560
these things in action

00:38:45,430 --> 00:38:56,110
so like maybe initialized this is the it

00:38:53,560 --> 00:38:59,590
right so maybe initialized places this

00:38:56,110 --> 00:39:02,890
is the struct that does that analysis

00:38:59,590 --> 00:39:07,090
there's some comments here or where is

00:39:02,890 --> 00:39:18,100
it let's see for me the English okay and

00:39:07,090 --> 00:39:22,900
then it implements bit denotation what

00:39:18,100 --> 00:39:24,730
does denotation mean yes to be honest I

00:39:22,900 --> 00:39:25,300
have never understood why this trait has

00:39:24,730 --> 00:39:28,840
that name

00:39:25,300 --> 00:39:32,440
laughs ties Felix but usually denote a

00:39:28,840 --> 00:39:36,250
denotation is like something you denote

00:39:32,440 --> 00:39:38,350
something when you you know so but I

00:39:36,250 --> 00:39:40,420
guess it denotes the bits I don't know

00:39:38,350 --> 00:39:45,370
maybe gives meaning to this probably

00:39:40,420 --> 00:39:49,090
something I would have called it

00:39:45,370 --> 00:39:59,620
something else but I'm not sure my name

00:39:49,090 --> 00:40:01,270
had been better just different I think I

00:39:59,620 --> 00:40:15,790
would have called it analysis definition

00:40:01,270 --> 00:40:20,650
or something but anyway so dataflow

00:40:15,790 --> 00:40:22,270
operator anyway whatever is you get the

00:40:20,650 --> 00:40:26,050
idea it's a very generic thing it's a

00:40:22,270 --> 00:40:31,420
it's a it's a dataflow factory builder

00:40:26,050 --> 00:40:33,040
constructor so I'm trying to find the

00:40:31,420 --> 00:40:34,810
interest in this this is all like super

00:40:33,040 --> 00:40:36,700
generic code there's some where I found

00:40:34,810 --> 00:40:40,630
earlier I found we're sort of bottoms

00:40:36,700 --> 00:40:43,360
out but where is it oh here we go update

00:40:40,630 --> 00:40:46,420
bits I think that's it there's some

00:40:43,360 --> 00:40:48,100
helper functions um but in the end of

00:40:46,420 --> 00:40:50,260
the day they kind of boil down to

00:40:48,100 --> 00:40:51,670
killing and Jenning and you can sort of

00:40:50,260 --> 00:40:53,650
see that this code references that

00:40:51,670 --> 00:40:57,670
dynamic drop thing these helper

00:40:53,650 --> 00:40:58,740
functions basically say there was some

00:40:57,670 --> 00:41:00,540
stuff

00:40:58,740 --> 00:41:03,210
the statement or terminator or whatever

00:41:00,540 --> 00:41:06,780
else that caused us to change the drop

00:41:03,210 --> 00:41:09,750
flag state for this path to either

00:41:06,780 --> 00:41:13,140
absent or present presumably present

00:41:09,750 --> 00:41:15,600
means there is a value present and

00:41:13,140 --> 00:41:19,170
therefore we should Jen the bit because

00:41:15,600 --> 00:41:21,240
we're may be initialized so like we want

00:41:19,170 --> 00:41:25,140
to include it if it if it's present and

00:41:21,240 --> 00:41:26,970
excluded if it's absent right and maybe

00:41:25,140 --> 00:41:32,510
uninitialized is exactly reversed

00:41:26,970 --> 00:41:36,360
um but okay that's how this code works

00:41:32,510 --> 00:41:38,070
what we're what we'll do in I think what

00:41:36,360 --> 00:41:39,930
we'll do is you know in Polonius we'll

00:41:38,070 --> 00:41:42,060
have like a move out and an init and

00:41:39,930 --> 00:41:45,270
then the actual analysis is basically

00:41:42,060 --> 00:41:46,890
exactly the same as liveness just copy

00:41:45,270 --> 00:41:54,510
and paste it and put the right things in

00:41:46,890 --> 00:42:00,540
the right place right like - yeah yeah

00:41:54,510 --> 00:42:03,300
you can make a macro for it actually I

00:42:00,540 --> 00:42:07,260
was starting to look into creating

00:42:03,300 --> 00:42:12,990
macros for that would have translated

00:42:07,260 --> 00:42:16,470
the board prologue ish data log ish I've

00:42:12,990 --> 00:42:23,190
thought about the time yeah seems

00:42:16,470 --> 00:42:26,180
complicated the one you're borrowing the

00:42:23,190 --> 00:42:30,540
syntax from I think they do that they

00:42:26,180 --> 00:42:32,070
they generate C++ from and then they

00:42:30,540 --> 00:42:34,530
embed that and then you would have

00:42:32,070 --> 00:42:37,830
another language to maintain it is about

00:42:34,530 --> 00:42:41,130
it yeah and it's like sometimes we want

00:42:37,830 --> 00:42:42,869
to do tricks and I don't know I I

00:42:41,130 --> 00:42:46,940
decided not to do it at this point but

00:42:42,869 --> 00:42:52,190
it is it is very tempting because it's a

00:42:46,940 --> 00:42:54,390
it's like almost trivial but not quite

00:42:52,190 --> 00:42:56,640
but yeah you get the idea so it's may be

00:42:54,390 --> 00:43:01,140
initialized if it is actually

00:42:56,640 --> 00:43:03,420
initialized you know and it's also may

00:43:01,140 --> 00:43:06,090
be initialized if there's a predecessor

00:43:03,420 --> 00:43:10,210
or whatever um and it hasn't been moved

00:43:06,090 --> 00:43:13,120
something like that um I guess

00:43:10,210 --> 00:43:15,940
one difference would be from liveness as

00:43:13,120 --> 00:43:19,420
these are forward analyses not backwards

00:43:15,940 --> 00:43:23,170
so you know you could so there'll be

00:43:19,420 --> 00:43:33,010
some CFG PQ oops

00:43:23,170 --> 00:43:36,910
dammit how'd this become a link okay

00:43:33,010 --> 00:43:40,960
yeah you get the idea we'll leave it

00:43:36,910 --> 00:43:43,660
alone so yes let me think what am I not

00:43:40,960 --> 00:43:48,250
telling you so right okay one last thing

00:43:43,660 --> 00:43:53,620
did so but I'm gonna assume that you've

00:43:48,250 --> 00:43:59,380
figured out the we're gonna define some

00:43:53,620 --> 00:44:03,040
sort of maybe uninit some sort of MPP

00:43:59,380 --> 00:44:07,120
thing here then the question is what is

00:44:03,040 --> 00:44:10,690
an error like we can compute these in

00:44:07,120 --> 00:44:12,970
polonius readily enough but now where do

00:44:10,690 --> 00:44:15,340
we start to get errors so when you when

00:44:12,970 --> 00:44:19,290
you see an access this basically comes

00:44:15,340 --> 00:44:24,730
down to UM you see an access to the path

00:44:19,290 --> 00:44:30,490
it must not be may be uninit right yeah

00:44:24,730 --> 00:44:32,320
and oh let me put that out so you'll

00:44:30,490 --> 00:44:34,990
notice that maybe in it is not actually

00:44:32,320 --> 00:44:36,550
needed for your errors the only thing we

00:44:34,990 --> 00:44:40,450
use may be a nip for you've already come

00:44:36,550 --> 00:44:45,280
across which is the drop dead the drop

00:44:40,450 --> 00:44:49,360
drop aliveness so drop liveness becomes

00:44:45,280 --> 00:44:56,140
something like you know is dropped at

00:44:49,360 --> 00:45:16,510
point p and is maybe an it point which

00:44:56,140 --> 00:45:19,600
actually and I have to look we can look

00:45:16,510 --> 00:45:21,520
actually let's look right now I'm trying

00:45:19,600 --> 00:45:24,590
to think this might mean that we only

00:45:21,520 --> 00:45:26,150
need to compute maybe in it for local

00:45:24,590 --> 00:45:35,450
[Music]

00:45:26,150 --> 00:45:36,800
I forget how smart we are we can come

00:45:35,450 --> 00:45:41,180
back to let's let's let's not worry

00:45:36,800 --> 00:45:43,520
about this just now but what computer

00:45:41,180 --> 00:45:46,100
for everything but we might be able to

00:45:43,520 --> 00:45:49,190
optimize by doing less or maybe we can

00:45:46,100 --> 00:45:52,640
get smarter the point being you know if

00:45:49,190 --> 00:45:55,640
you've moved from one half of the tuple

00:45:52,640 --> 00:45:58,160
but not the other I don't think we're

00:45:55,640 --> 00:46:01,160
smart enough to understand that only

00:45:58,160 --> 00:46:03,560
that half like only the half that you

00:46:01,160 --> 00:46:07,370
haven't moved from this drop life and

00:46:03,560 --> 00:46:09,080
the other half is not but we do do some

00:46:07,370 --> 00:46:10,340
sort of smart things like that I don't

00:46:09,080 --> 00:46:14,420
think we do that particular one but I'm

00:46:10,340 --> 00:46:18,440
not sure I can't remember if you look at

00:46:14,420 --> 00:46:22,820
the code but this is the main error and

00:46:18,440 --> 00:46:25,090
the way that this works in rust C so we

00:46:22,820 --> 00:46:30,650
do this maybe uninit computation and

00:46:25,090 --> 00:46:36,770
then we have this other thing where is

00:46:30,650 --> 00:46:38,240
this code I forget which Phi this like

00:46:36,770 --> 00:46:40,480
everything is in this file probably

00:46:38,240 --> 00:46:45,590
there's a lot of code in this file

00:46:40,480 --> 00:46:49,370
let's take a look maybe under heads yeah

00:46:45,590 --> 00:46:51,440
so we there's some code in between the

00:46:49,370 --> 00:46:54,470
stuff I was showing you and this I'm

00:46:51,440 --> 00:46:57,970
looking at right now it kind of walks

00:46:54,470 --> 00:47:01,910
over the mirror again and along the way

00:46:57,970 --> 00:47:06,230
we have this notion of flow state let me

00:47:01,910 --> 00:47:09,410
show you that flows in you so this is

00:47:06,230 --> 00:47:12,290
the the top level code that's like the

00:47:09,410 --> 00:47:14,860
entry point to scroll the entry point to

00:47:12,290 --> 00:47:18,650
borrow check that we've been looking at

00:47:14,860 --> 00:47:21,200
where it computes the move data it

00:47:18,650 --> 00:47:23,540
computes the maybe in its and you see

00:47:21,200 --> 00:47:25,090
that it does these kind of early that's

00:47:23,540 --> 00:47:28,340
because if they're needed for liveness

00:47:25,090 --> 00:47:30,890
then later and then they just get

00:47:28,340 --> 00:47:32,420
dropped after that then later it

00:47:30,890 --> 00:47:35,120
computes then maybe onion it's and a

00:47:32,420 --> 00:47:36,570
bunch of other random stuff and it puts

00:47:35,120 --> 00:47:42,300
all of those things in

00:47:36,570 --> 00:47:46,740
this flows data structure and that just

00:47:42,300 --> 00:47:48,990
means these are all data flow sets that

00:47:46,740 --> 00:47:50,580
we want to track as we are walking

00:47:48,990 --> 00:47:52,140
through the Baro check we want to have

00:47:50,580 --> 00:47:53,550
their values sort of up-to-date so at

00:47:52,140 --> 00:47:57,630
this statement what is the set of

00:47:53,550 --> 00:48:06,030
uninitialized things um that's what this

00:47:57,630 --> 00:48:10,140
is so well it groups together the data

00:48:06,030 --> 00:48:19,730
flow analysis whose values should be

00:48:10,140 --> 00:48:23,790
up-to-date for the current point and

00:48:19,730 --> 00:48:27,270
part of the reason we do it this way in

00:48:23,790 --> 00:48:28,800
this code is that we don't store all the

00:48:27,270 --> 00:48:30,210
values for all the points we only store

00:48:28,800 --> 00:48:32,190
the values on entry to each basic block

00:48:30,210 --> 00:48:35,460
and then we sort of recompute the

00:48:32,190 --> 00:48:41,840
intermediate states as we go which is

00:48:35,460 --> 00:48:44,460
something that don't do in data frog and

00:48:41,840 --> 00:48:46,470
it would be nice if we can just never do

00:48:44,460 --> 00:48:48,030
that because it's really complicated but

00:48:46,470 --> 00:48:56,610
maybe we'll have to reproduce it someday

00:48:48,030 --> 00:48:58,260
I don't know anyway so right so then as

00:48:56,610 --> 00:49:01,920
we walk the data flow we're gonna call

00:48:58,260 --> 00:49:05,730
this check it full path is moved if we

00:49:01,920 --> 00:49:09,090
see a move or no if we see an access to

00:49:05,730 --> 00:49:13,500
a given place at a given location

00:49:09,090 --> 00:49:16,590
these are loops together just first just

00:49:13,500 --> 00:49:18,930
for clarity I think say that that's the

00:49:16,590 --> 00:49:24,080
span of this place so what that does is

00:49:18,930 --> 00:49:24,080
it calls this helper newly to link here

00:49:35,550 --> 00:49:41,390
it calls this helper move path closest

00:49:38,250 --> 00:49:44,670
to and what that basically does it says

00:49:41,390 --> 00:49:46,230
well maybe a dot B dot C is not

00:49:44,670 --> 00:49:49,590
something we build a move path for

00:49:46,230 --> 00:49:52,440
because C is a field you couldn't move

00:49:49,590 --> 00:49:55,410
from then we want the the longest path

00:49:52,440 --> 00:49:57,270
we can get so if a dot B dot C doesn't

00:49:55,410 --> 00:50:03,090
exist then a dot B maybe that exists it

00:49:57,270 --> 00:50:04,860
in the limit a should exist um and this

00:50:03,090 --> 00:50:08,870
usually succeeds you can see it can

00:50:04,860 --> 00:50:11,100
actually error because it's not always

00:50:08,870 --> 00:50:12,390
the paths don't always begin with the

00:50:11,100 --> 00:50:14,760
local variable they can begin with

00:50:12,390 --> 00:50:16,380
global variables too but as long as it's

00:50:14,760 --> 00:50:18,660
begins with the local variable it should

00:50:16,380 --> 00:50:21,360
succeed because there's a path for every

00:50:18,660 --> 00:50:25,230
local variable and then we can check if

00:50:21,360 --> 00:50:31,640
that's initialized so essentially yeah

00:50:25,230 --> 00:50:31,640
if you access data B dot C what's that

00:50:33,890 --> 00:50:41,820
we just don't they're very mutable so

00:50:39,620 --> 00:50:43,230
they must be in it they're always

00:50:41,820 --> 00:50:44,730
initialized and they never you can't

00:50:43,230 --> 00:50:49,950
move out from them so they can never get

00:50:44,730 --> 00:50:53,160
uninitialized um right so right you

00:50:49,950 --> 00:50:57,620
basically find the closest move path we

00:50:53,160 --> 00:51:10,980
can and check that it is uninitialized

00:50:57,620 --> 00:51:14,820
Earth is not I think they're treated as

00:51:10,980 --> 00:51:24,600
local variables but we we generate them

00:51:14,820 --> 00:51:27,660
on entry as initialized and yeah the

00:51:24,600 --> 00:51:30,240
only special thing the only special mere

00:51:27,660 --> 00:51:31,650
local variable that's the other wall the

00:51:30,240 --> 00:51:34,320
other mere local variable that's a bit

00:51:31,650 --> 00:51:37,620
special is there's a return slot and

00:51:34,320 --> 00:51:40,260
that wouldn't would be never initialized

00:51:37,620 --> 00:51:42,630
or it certainly not uninitialized

00:51:40,260 --> 00:51:49,500
certainly not initialized on entry

00:51:42,630 --> 00:51:51,619
um so yes access to a path must not be

00:51:49,500 --> 00:51:55,940
maybe internet um

00:51:51,619 --> 00:52:02,670
right and note actually it might be that

00:51:55,940 --> 00:52:08,250
well no I I was going to say it might be

00:52:02,670 --> 00:52:12,329
that if you access a dot B dot C it

00:52:08,250 --> 00:52:13,769
might not exist for many reasons like it

00:52:12,329 --> 00:52:17,579
might be that you can't move from that

00:52:13,769 --> 00:52:20,670
path but I think in principle we could

00:52:17,579 --> 00:52:24,089
choose not to generate move paths for

00:52:20,670 --> 00:52:29,549
things that are never moved from but are

00:52:24,089 --> 00:52:32,250
only accessed in other ways because then

00:52:29,549 --> 00:52:33,839
there they are initialized if the base

00:52:32,250 --> 00:52:36,690
structure is initialized and otherwise

00:52:33,839 --> 00:52:38,220
not however I think at moment we are

00:52:36,690 --> 00:52:40,920
simpler than that and we just generate

00:52:38,220 --> 00:52:42,869
move ties for everything so basically

00:52:40,920 --> 00:52:47,970
the only reason that there would not be

00:52:42,869 --> 00:52:52,250
an exact matches yeah okay so that's

00:52:47,970 --> 00:52:52,250
pretty much how the code works today I

00:52:53,990 --> 00:53:04,430
think what Polonius wants to do you want

00:52:58,950 --> 00:53:04,430
to add our base fax which is going to be

00:53:04,609 --> 00:53:15,869
move out so I guess we have a new Adam

00:53:08,910 --> 00:53:23,720
first of all the move path and we have

00:53:15,869 --> 00:53:32,819
base fax move out move path point and

00:53:23,720 --> 00:53:35,759
well actually there's initialize you

00:53:32,819 --> 00:53:37,980
know you could call these depending I

00:53:35,759 --> 00:53:39,269
don't know we could debate the names you

00:53:37,980 --> 00:53:41,880
could imagine calling it initializing

00:53:39,269 --> 00:53:44,279
uninitialized for example I'm not sure

00:53:41,880 --> 00:53:45,869
if that's clearer or less clear but it

00:53:44,279 --> 00:53:48,100
occurs to me that this is very similar

00:53:45,869 --> 00:53:51,159
to if not identical to

00:53:48,100 --> 00:53:51,159
[Music]

00:53:55,450 --> 00:54:02,349
like deaf in the liveness analysis the

00:54:00,250 --> 00:54:05,500
only real difference is the Deaf is

00:54:02,349 --> 00:54:07,300
basically and initialize that to a local

00:54:05,500 --> 00:54:25,980
variable and not some other kind of path

00:54:07,300 --> 00:54:28,599
oh there's something I left out well I

00:54:25,980 --> 00:54:35,710
didn't leave it out but it's it's

00:54:28,599 --> 00:54:38,050
relevant if you have something like if

00:54:35,710 --> 00:54:39,910
you have a equals foo this is gonna

00:54:38,050 --> 00:54:43,410
generate an initialized fact but

00:54:39,910 --> 00:54:43,410
actually might generate more than one

00:54:44,940 --> 00:54:50,079
depending right so there might be a DUP

00:54:47,410 --> 00:54:53,609
like if there's a if there are sub pads

00:54:50,079 --> 00:54:57,849
they're also being initialized and

00:54:53,609 --> 00:55:01,569
there's some code in the I think this

00:54:57,849 --> 00:55:03,700
logic is probably not I have to double

00:55:01,569 --> 00:55:07,000
check but I think the gather moves logic

00:55:03,700 --> 00:55:08,800
is kind of already has this covered the

00:55:07,000 --> 00:55:11,500
existing moves in other words there

00:55:08,800 --> 00:55:14,290
already be entries in the array for all

00:55:11,500 --> 00:55:19,210
the sub paths but I'm not sure if that's

00:55:14,290 --> 00:55:22,290
true because actually that's probably

00:55:19,210 --> 00:55:25,000
not true that probably can't be true I

00:55:22,290 --> 00:55:26,920
realize now because you need to do two

00:55:25,000 --> 00:55:29,650
passes you need to first generate all

00:55:26,920 --> 00:55:31,240
the move paths and then come back and

00:55:29,650 --> 00:55:32,940
figure out what all the sub children are

00:55:31,240 --> 00:55:35,170
you might not know them all at the time

00:55:32,940 --> 00:55:37,000
when you're if you see what I mean like

00:55:35,170 --> 00:55:38,980
when you see a equals foo you may not

00:55:37,000 --> 00:55:40,839
yet have seen it up using so I think

00:55:38,980 --> 00:55:44,530
that expansion probably happens in the

00:55:40,839 --> 00:55:46,089
bit denotation info today I think we

00:55:44,530 --> 00:55:48,490
probably want to do it in the data log

00:55:46,089 --> 00:56:01,119
itself so that implies there's probably

00:55:48,490 --> 00:56:03,190
another relation certainly I didn't even

00:56:01,119 --> 00:56:06,280
talk about I've sort of offhand

00:56:03,190 --> 00:56:08,320
mentioned like a few times like was just

00:56:06,280 --> 00:56:11,110
sort of different compiler different

00:56:08,320 --> 00:56:14,820
language but it had similar things and I

00:56:11,110 --> 00:56:18,370
did this in like and I remember that I I

00:56:14,820 --> 00:56:28,570
put this logic in in the data flow

00:56:18,370 --> 00:56:30,010
anyway yeah well the light code is up

00:56:28,570 --> 00:56:31,780
I'm not sure if you mean the like or the

00:56:30,010 --> 00:56:37,410
Russ code the larper is kind of

00:56:31,780 --> 00:56:37,410
confusing awesome cuz that's like okay

00:56:38,430 --> 00:56:49,690
yeah I some point wanted to go back and

00:56:42,460 --> 00:56:52,240
make it read beautifully so I was

00:56:49,690 --> 00:56:54,700
looking over today I was like and this

00:56:52,240 --> 00:56:58,030
data flog stuff it's like so nice but

00:56:54,700 --> 00:57:04,470
it's kind of right only you have to be

00:56:58,030 --> 00:57:07,060
very careful documenting so anyway um

00:57:04,470 --> 00:57:11,830
these are probably your base facts and

00:57:07,060 --> 00:57:16,710
then we can compute from these let's

00:57:11,830 --> 00:57:16,710
just start with maybe on an it I guess

00:57:17,640 --> 00:57:23,850
we'll deal with maybe an it later

00:57:20,790 --> 00:57:27,130
because it's not relevant to errors and

00:57:23,850 --> 00:57:32,530
well we need some other thing which is

00:57:27,130 --> 00:57:36,640
probably act something like access which

00:57:32,530 --> 00:57:38,140
says which is also similar to the to

00:57:36,640 --> 00:57:43,890
what liveness has right which is like

00:57:38,140 --> 00:57:48,670
use the value from this move path and

00:57:43,890 --> 00:57:56,250
similarly foo of a is a use in liveness

00:57:48,670 --> 00:58:03,040
and an access and similarly accessing a

00:57:56,250 --> 00:58:07,750
implicitly accesses accesses you know

00:58:03,040 --> 00:58:12,010
all sub paths and so we have again a

00:58:07,750 --> 00:58:15,040
sort of transitive closure thing going

00:58:12,010 --> 00:58:18,789
on so an error winds up being something

00:58:15,040 --> 00:58:27,160
like you know there was an access

00:58:18,789 --> 00:58:30,669
some move paths MP that that is either

00:58:27,160 --> 00:58:42,009
direct is either uninitialized or has an

00:58:30,669 --> 00:58:49,319
uninitialized child transitive and I

00:58:42,009 --> 00:58:49,319
think that's kind of it that's the idea

00:58:50,560 --> 00:58:53,780
[Music]

00:58:58,259 --> 00:59:00,839
you think the factions will be the hard

00:59:00,369 --> 00:59:11,919
part

00:59:00,839 --> 00:59:15,959
yeah in my experience now yeah yeah this

00:59:11,919 --> 00:59:18,999
this stuff is fairly straightforward I

00:59:15,959 --> 00:59:20,679
think I'm the one saving grace here is

00:59:18,999 --> 00:59:23,349
that we're actually kind of already

00:59:20,679 --> 00:59:24,640
generating facts like that move data

00:59:23,349 --> 00:59:26,859
data structures kind of already got

00:59:24,640 --> 00:59:33,329
everything you need so you just have to

00:59:26,859 --> 00:59:37,929
iterate over it and spit it out um the I

00:59:33,329 --> 00:59:39,969
was just gonna say the Lark type just

00:59:37,929 --> 00:59:41,829
for reference I probably already linked

00:59:39,969 --> 00:59:56,380
to it but just so I can my own

00:59:41,829 --> 00:59:58,390
edification yeah these are doing similar

00:59:56,380 --> 01:00:03,429
things tracking them it business

00:59:58,390 --> 01:00:05,199
tracking the uninitialized right we'll

01:00:03,429 --> 01:00:06,369
probably wind up I don't think you

01:00:05,199 --> 01:00:08,409
should read this but I'll probably go

01:00:06,369 --> 01:00:09,880
reread it and try to remember because I

01:00:08,409 --> 01:00:13,569
suspect we're gonna wind up computing

01:00:09,880 --> 01:00:15,400
all the same things but one of the

01:00:13,569 --> 01:00:19,409
things that came up that I do remember

01:00:15,400 --> 01:00:23,309
is there's a lot of like phasing here

01:00:19,409 --> 01:00:30,819
because the data frog stuff likes to

01:00:23,309 --> 01:00:34,229
distinguish closed relations from you

01:00:30,819 --> 01:00:34,229
know iteration variable

01:00:36,990 --> 01:00:43,890
you can see that I sort of you know like

01:00:41,710 --> 01:00:46,990
there's a first first path here that

01:00:43,890 --> 01:00:48,880
computes I think this is saying over

01:00:46,990 --> 01:00:50,590
written is my aversion to initialized

01:00:48,880 --> 01:00:55,510
but if you write to a given path at a

01:00:50,590 --> 01:00:57,280
given spot then you also write to all

01:00:55,510 --> 01:00:59,230
the children of that path right and I

01:00:57,280 --> 01:01:01,180
compute that sort of as one thing and

01:00:59,230 --> 01:01:03,760
get a relation out of it so that I can

01:01:01,180 --> 01:01:12,510
then later do leap joins and stuff like

01:01:03,760 --> 01:01:15,400
that with it and similarly if you access

01:01:12,510 --> 01:01:19,270
hmm all the different ways to access the

01:01:15,400 --> 01:01:21,820
given path this may not be relevant but

01:01:19,270 --> 01:01:27,540
I'm sort of combining like oh it's a

01:01:21,820 --> 01:01:30,910
direct access or yeah or it's a

01:01:27,540 --> 01:01:33,250
transitive access so I computed the

01:01:30,910 --> 01:01:35,590
transitive the transitive relation and

01:01:33,250 --> 01:01:38,590
then I can just kind of join them

01:01:35,590 --> 01:01:44,610
together and so forth so we may wind up

01:01:38,590 --> 01:01:44,610
trying to do stuff like that but

01:01:44,730 --> 01:01:51,240
nonetheless I think you are corrected

01:01:47,080 --> 01:01:51,240
the hard part will be the rest code I

01:01:52,500 --> 01:01:59,790
think that's kind of all I got in terms

01:01:55,780 --> 01:02:02,050
of giving the high-level picture on I

01:01:59,790 --> 01:02:05,160
imagine that you sorta have a feel for

01:02:02,050 --> 01:02:07,600
the drill by now probably I would

01:02:05,160 --> 01:02:10,540
probably we would approach it in the

01:02:07,600 --> 01:02:12,100
same in this order more or less start by

01:02:10,540 --> 01:02:13,570
adding the atom and generating the base

01:02:12,100 --> 01:02:19,150
facts and then write the polonius code

01:02:13,570 --> 01:02:24,490
um speaking of which I don't know I

01:02:19,150 --> 01:02:26,560
haven't looked today but I guess I need

01:02:24,490 --> 01:02:27,910
to start merging things huh is this read

01:02:26,560 --> 01:02:41,080
this is not ready or is it ready for me

01:02:27,910 --> 01:02:44,250
to merge them not yet sweet okay very

01:02:41,080 --> 01:02:44,250
cool I will take a look

01:02:45,160 --> 01:02:51,910
rust fmt on on some violin that so now I

01:02:49,750 --> 01:02:53,650
got much conflicts whenever anything

01:02:51,910 --> 01:02:54,009
happens upstream I'm never doing that

01:02:53,650 --> 01:02:57,700
again

01:02:54,009 --> 01:03:01,089
I do that a lot but what I do is I do it

01:02:57,700 --> 01:03:03,789
in one commit and if there's a merge

01:03:01,089 --> 01:03:05,920
commit I just throw away my version and

01:03:03,789 --> 01:03:10,119
rerun rust format and then that's the

01:03:05,920 --> 01:03:15,130
new per minute however it's still

01:03:10,119 --> 01:03:20,019
annoying but it's less annoying yeah all

01:03:15,130 --> 01:03:25,509
right well any last questions I have two

01:03:20,019 --> 01:03:30,039
questions let's take them in order of

01:03:25,509 --> 01:03:32,710
distance to topic okay so I didn't quite

01:03:30,039 --> 01:03:35,380
understand what when exactly something

01:03:32,710 --> 01:03:38,410
is maybe uninitialized you skimmed over

01:03:35,380 --> 01:03:43,269
that oh yeah that's a good point

01:03:38,410 --> 01:03:52,240
okay so let's first start the intuition

01:03:43,269 --> 01:03:55,960
we go back to this example so you remove

01:03:52,240 --> 01:03:57,940
all these drop flags let me make a

01:03:55,960 --> 01:04:00,240
version that's clean without the drop

01:03:57,940 --> 01:04:00,240
flags

01:04:18,490 --> 01:04:28,940
so if you look at this here D is

01:04:24,230 --> 01:04:30,590
initialized yeah you get the idea but

01:04:28,940 --> 01:04:32,690
I'll I'll go through the exercise anyway

01:04:30,590 --> 01:04:52,760
you could say that V is definitely

01:04:32,690 --> 01:05:02,750
uninitialized here yeah yeah pretty much

01:04:52,760 --> 01:05:04,370
if there's a if there's no Nanette can

01:05:02,750 --> 01:05:08,600
reach the point without an interrupting

01:05:04,370 --> 01:05:12,650
in it yeah and that's exactly what you

01:05:08,600 --> 01:05:15,410
want to express in this this relation

01:05:12,650 --> 01:05:21,100
here or something right light I mean it

01:05:15,410 --> 01:05:21,100
can reach P without in the net middle

01:05:24,970 --> 01:05:29,030
yeah we could we could go through the

01:05:27,200 --> 01:05:34,510
exercise where as you say it's basically

01:05:29,030 --> 01:05:34,510
cutting and pasting from from limas and

01:05:34,720 --> 01:05:37,870
that's it

01:05:49,180 --> 01:05:54,110
yeah okay I don't like that terminology

01:05:52,970 --> 01:05:57,530
anymore and I've been trying to move

01:05:54,110 --> 01:05:59,870
away from it but um what it refers to is

01:05:57,530 --> 01:06:02,570
the named lifetimes on the function

01:05:59,870 --> 01:06:04,910
perimeter and the reason I called them

01:06:02,570 --> 01:06:08,300
the universal is that they're

01:06:04,910 --> 01:06:13,400
universally quantified meaning that you

01:06:08,300 --> 01:06:18,740
have points yeah you sort of you don't

01:06:13,400 --> 01:06:21,170
know what today is but it's some set of

01:06:18,740 --> 01:06:24,140
things um you know I think for the

01:06:21,170 --> 01:06:25,550
purposes of polonius they don't they're

01:06:24,140 --> 01:06:28,820
not very different from any other region

01:06:25,550 --> 01:06:29,280
except that they're sort of life all the

01:06:28,820 --> 01:06:32,160
time

01:06:29,280 --> 01:06:36,990
uh yeah and they're a little special and

01:06:32,160 --> 01:06:39,000
some yeah I have been trying to move

01:06:36,990 --> 01:06:42,480
towards the terminology of free regions

01:06:39,000 --> 01:06:51,660
because they're free but it's also not

01:06:42,480 --> 01:06:54,510
amazing but anyway they are free in the

01:06:51,660 --> 01:06:58,170
sense that so you know the free inbound

01:06:54,510 --> 01:07:00,060
terminology yeah they're not bound in

01:06:58,170 --> 01:07:02,880
the function body like they're not there

01:07:00,060 --> 01:07:04,560
are region names that they kind of

01:07:02,880 --> 01:07:12,090
reference things from the outside so

01:07:04,560 --> 01:07:17,820
they're free it's not addressed but it's

01:07:12,090 --> 01:07:32,130
at least consistent that or placeholders

01:07:17,820 --> 01:07:34,530
that's my other term of choice all right

01:07:32,130 --> 01:07:41,390
well let me know I'll try to answer

01:07:34,530 --> 01:07:41,390

YouTube URL: https://www.youtube.com/watch?v=ilv9V-328HI


