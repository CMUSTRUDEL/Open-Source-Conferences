Title: Salsa In More Depth (2019.01)
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	You can view the DropBox paper document anonymously here:

https://gist.github.com/nikomatsakis/5b119a71465549b61743e8739a369b5e

Or you can view the original here:

https://paper.dropbox.com/doc/Salsa-In-More-Depth-2019.01--AWnTZTDJPJ_dsuLU7gIzZeHKAg-wYaiL8t72BdGGPFrnmt7h
Captions: 
	00:00:00,000 --> 00:00:06,150
word on this computer okay hello so this

00:00:04,259 --> 00:00:07,799
is a video about salsa and in particular

00:00:06,150 --> 00:00:09,900
going just a little more in depth than

00:00:07,799 --> 00:00:13,110
the introductory video on house also

00:00:09,900 --> 00:00:15,269
works the goal is to kind of give you an

00:00:13,110 --> 00:00:17,430
understanding of what salsas doing when

00:00:15,269 --> 00:00:21,000
you actually invoke a query so that you

00:00:17,430 --> 00:00:23,039
can use it more effectively and here to

00:00:21,000 --> 00:00:27,960
ask make sure that I keep me honest

00:00:23,039 --> 00:00:29,970
let's say this Jonathan Turner and the

00:00:27,960 --> 00:00:32,399
idea is when I say really confusing

00:00:29,970 --> 00:00:36,090
things you can tell me that they I need

00:00:32,399 --> 00:00:38,760
to explain more so I think he falls in

00:00:36,090 --> 00:00:40,379
that that point of a position right now

00:00:38,760 --> 00:00:44,520
if a salsa user who doesn't know how the

00:00:40,379 --> 00:00:48,600
user moles work so how does also work

00:00:44,520 --> 00:00:51,059
internally so let's say let's set the

00:00:48,600 --> 00:00:54,960
scene let's imagine you have like a

00:00:51,059 --> 00:00:57,420
salsa query group and so I'm trait I'm

00:00:54,960 --> 00:01:01,640
just gonna go grab an example here from

00:00:57,420 --> 00:01:08,310
the prior paper suppose we have this

00:01:01,640 --> 00:01:12,090
this parser trait and I guess we need

00:01:08,310 --> 00:01:14,220
the inputs too so let's review it so

00:01:12,090 --> 00:01:15,570
what we've got is we have we have two

00:01:14,220 --> 00:01:17,070
Curie groups but I'm going to put I'm

00:01:15,570 --> 00:01:18,990
just going to collapse this into one

00:01:17,070 --> 00:01:21,630
because the distinction isn't important

00:01:18,990 --> 00:01:24,240
for house also works internally so we

00:01:21,630 --> 00:01:27,390
have two inputs a manifest in a source

00:01:24,240 --> 00:01:30,540
text and we have two derived queries the

00:01:27,390 --> 00:01:31,740
ast and the whole program ast and for

00:01:30,540 --> 00:01:37,979
each of those we're going to have some

00:01:31,740 --> 00:01:40,259
function which defines how they work the

00:01:37,979 --> 00:01:42,630
AST function is going to start by

00:01:40,259 --> 00:01:45,060
invoking the source text to get a string

00:01:42,630 --> 00:01:47,369
out and so this source text is a string

00:01:45,060 --> 00:01:51,360
because that's how the query is defined

00:01:47,369 --> 00:01:53,310
right here and it's going to do some

00:01:51,360 --> 00:01:56,640
actual work on the source text and

00:01:53,310 --> 00:01:59,009
return it and the whole program ast is

00:01:56,640 --> 00:02:01,829
going to iterate and invoke the ast

00:01:59,009 --> 00:02:06,030
query each time for a given name and

00:02:01,829 --> 00:02:08,759
combine them in some way and is there

00:02:06,030 --> 00:02:09,989
something else oh no oh I know this just

00:02:08,759 --> 00:02:12,720
just for reference this is what the

00:02:09,989 --> 00:02:13,710
database looks like you'll you'll define

00:02:12,720 --> 00:02:15,900
a database

00:02:13,710 --> 00:02:17,580
and there's probably some loop here

00:02:15,900 --> 00:02:21,330
where I instantiate the database

00:02:17,580 --> 00:02:24,090
I set the inputs I invoke type check and

00:02:21,330 --> 00:02:25,680
I set the text so let's start here and

00:02:24,090 --> 00:02:28,020
walk through just a little bit of detail

00:02:25,680 --> 00:02:30,200
just on this first line in my database

00:02:28,020 --> 00:02:35,700
default you know what's happening here

00:02:30,200 --> 00:02:38,850
so the way when the idea when salsa

00:02:35,700 --> 00:02:41,400
executes it needs to have it needs to

00:02:38,850 --> 00:02:43,500
keep track of the values that resulted

00:02:41,400 --> 00:02:45,420
from all the previous like queries that

00:02:43,500 --> 00:02:48,300
you did in the prior execution that's

00:02:45,420 --> 00:02:50,580
basically how we avoid redoing work is

00:02:48,300 --> 00:02:52,440
by remembering like what was the ast of

00:02:50,580 --> 00:02:55,740
this file in the first iteration and so

00:02:52,440 --> 00:02:57,930
forth and all of that data winds up

00:02:55,740 --> 00:03:01,260
being stored inside this also run time

00:02:57,930 --> 00:03:04,020
and that and it's that's what these

00:03:01,260 --> 00:03:05,760
storage names here are basically doing

00:03:04,020 --> 00:03:08,100
that you attach to the database is

00:03:05,760 --> 00:03:09,840
that's it's gonna keep those strux or

00:03:08,100 --> 00:03:12,540
keep values associated with those trucks

00:03:09,840 --> 00:03:15,690
that has like a hash map essentially for

00:03:12,540 --> 00:03:24,150
every query that you have to execute all

00:03:15,690 --> 00:03:28,710
right so me good yep for the for each of

00:03:24,150 --> 00:03:30,740
those they see yeah some infant storage

00:03:28,710 --> 00:03:33,540
parser storage and pet record storage

00:03:30,740 --> 00:03:39,810
are those defined do we did we define

00:03:33,540 --> 00:03:41,340
those them earlier yes so each of these

00:03:39,810 --> 00:03:44,100
corresponds to one query group and

00:03:41,340 --> 00:03:46,470
they're defined by the query group there

00:03:44,100 --> 00:03:48,090
this is an actual name of a struct and

00:03:46,470 --> 00:03:49,200
this struct is generated by this

00:03:48,090 --> 00:03:51,420
decorator

00:03:49,200 --> 00:03:53,880
sort of attribute macro and what the

00:03:51,420 --> 00:03:55,470
struct has is for each of the queries in

00:03:53,880 --> 00:03:58,830
that query group it has the actual

00:03:55,470 --> 00:04:00,330
storage so by in directing through this

00:03:58,830 --> 00:04:01,740
struct like you don't name the

00:04:00,330 --> 00:04:04,110
individual queries here you name the

00:04:01,740 --> 00:04:05,850
struct and inside the struct or is it

00:04:04,110 --> 00:04:07,770
crazy so this the struct for type

00:04:05,850 --> 00:04:10,380
checker storage is gonna have one hash

00:04:07,770 --> 00:04:12,120
map for the tech jet query but the

00:04:10,380 --> 00:04:14,430
struct for parser is going to have two

00:04:12,120 --> 00:04:20,820
one for the ast and one for whole

00:04:14,430 --> 00:04:22,620
program the ast and so forth and they're

00:04:20,820 --> 00:04:24,360
slightly different so for the inputs

00:04:22,620 --> 00:04:26,430
there will also be a kind of hash map

00:04:24,360 --> 00:04:27,389
but it's a slightly different wrapper

00:04:26,430 --> 00:04:30,289
around it

00:04:27,389 --> 00:04:33,360
in puts work a little differently but

00:04:30,289 --> 00:04:36,930
basically per each query you have the

00:04:33,360 --> 00:04:38,610
storage which is this is a map and so

00:04:36,930 --> 00:04:39,870
that all gets concatenated into the

00:04:38,610 --> 00:04:42,180
database

00:04:39,870 --> 00:04:44,669
and when you call something like set

00:04:42,180 --> 00:04:47,069
manifest what's happening under the

00:04:44,669 --> 00:04:48,810
scenes is that let's say we we call it

00:04:47,069 --> 00:04:52,259
with m1 or something

00:04:48,810 --> 00:04:55,139
what's happening under the scenes is

00:04:52,259 --> 00:04:58,949
that that data is getting stored into

00:04:55,139 --> 00:05:04,199
the map and it's because of the name set

00:04:58,949 --> 00:05:07,439
underscore manifest right I think that

00:05:04,199 --> 00:05:10,139
that made my special in some way for

00:05:07,439 --> 00:05:11,819
each input for every salsa input that

00:05:10,139 --> 00:05:14,699
you define there's a setter

00:05:11,819 --> 00:05:17,729
automatically generated oh yeah I see

00:05:14,699 --> 00:05:19,560
the comment now you know so that you

00:05:17,729 --> 00:05:21,719
can't call set ASD because it's not

00:05:19,560 --> 00:05:27,120
input you can only ask for the ast and

00:05:21,719 --> 00:05:29,639
it gets computed um so right so look so

00:05:27,120 --> 00:05:31,020
okay this isn't really relevant um

00:05:29,639 --> 00:05:34,050
these might be the topics for future

00:05:31,020 --> 00:05:35,699
salsa discussions but the so that's

00:05:34,050 --> 00:05:38,729
already taken a few notes here so like

00:05:35,699 --> 00:05:42,659
the database storage so the database has

00:05:38,729 --> 00:05:46,139
as I said internally a shared storage

00:05:42,659 --> 00:05:48,659
with kind of one struct per query group

00:05:46,139 --> 00:05:51,479
which has any the structs have one field

00:05:48,659 --> 00:05:53,250
for a query one hash map basically all

00:05:51,479 --> 00:05:55,439
the cost kata map because it is a hash

00:05:53,250 --> 00:05:57,870
map but it's also other stuff one map

00:05:55,439 --> 00:06:00,689
per query and when you do DB dot set

00:05:57,870 --> 00:06:03,599
something what you do is you basically

00:06:00,689 --> 00:06:10,009
let's say on let's make it more concrete

00:06:03,599 --> 00:06:13,589
if I set input file you know a dot RS I

00:06:10,009 --> 00:06:15,599
don't know a little little rest source

00:06:13,589 --> 00:06:20,699
text there then what I'm basically doing

00:06:15,599 --> 00:06:24,180
is storing into the input file map with

00:06:20,699 --> 00:06:27,899
the key a dot RS and the value given

00:06:24,180 --> 00:06:30,689
right I'm also doing one other thing is

00:06:27,899 --> 00:06:33,479
the database has internally a revision

00:06:30,689 --> 00:06:36,120
which is really just a counter it starts

00:06:33,479 --> 00:06:37,529
out at r0 you know when I do that every

00:06:36,120 --> 00:06:40,050
time I call set I'm going to increment

00:06:37,529 --> 00:06:41,190
the revision so in this case I would go

00:06:40,050 --> 00:06:42,870
to r1

00:06:41,190 --> 00:06:46,470
and we're gonna see later that we need

00:06:42,870 --> 00:06:48,360
this revision so to remember basically

00:06:46,470 --> 00:06:50,630
when did we compute for derive queries

00:06:48,360 --> 00:06:53,430
and things we want to remember um when

00:06:50,630 --> 00:06:54,870
did this last change essentially and so

00:06:53,430 --> 00:06:56,700
actually when I store into this

00:06:54,870 --> 00:07:00,660
I don't just put their value given I

00:06:56,700 --> 00:07:03,360
also store the revision r1 the new

00:07:00,660 --> 00:07:05,670
revision when I set an input so I'm

00:07:03,360 --> 00:07:08,400
remembering now this value was last

00:07:05,670 --> 00:07:10,290
changed as we entered revision one right

00:07:08,400 --> 00:07:12,630
and we're gonna up the revision each

00:07:10,290 --> 00:07:14,520
time we do a set so when we set the

00:07:12,630 --> 00:07:16,740
manifest or when we said if we called

00:07:14,520 --> 00:07:22,560
set input file twice we would go to

00:07:16,740 --> 00:07:24,570
revision twice revision to just out of

00:07:22,560 --> 00:07:26,880
curiosity revisions makes me think of

00:07:24,570 --> 00:07:30,510
databases and databases make me think of

00:07:26,880 --> 00:07:32,220
things like transactions so each one of

00:07:30,510 --> 00:07:34,770
these calls is kind of a its own

00:07:32,220 --> 00:07:37,860
transaction you can group them into a

00:07:34,770 --> 00:07:41,040
single one just that's right that's

00:07:37,860 --> 00:07:43,770
right so we guarantee that when you when

00:07:41,040 --> 00:07:45,210
you execute a derived query like a type

00:07:43,770 --> 00:07:47,010
check query which we'll get to in a

00:07:45,210 --> 00:07:49,890
second that's gonna do a whole bunch of

00:07:47,010 --> 00:07:51,930
work but um while it's executing that's

00:07:49,890 --> 00:07:54,330
like a transaction there can't be any

00:07:51,930 --> 00:07:57,930
sets that come in between and actually

00:07:54,330 --> 00:07:59,790
you you kind of get that guarantee to a

00:07:57,930 --> 00:08:03,680
certain extent for free through rusts

00:07:59,790 --> 00:08:05,970
system because this is an an self method

00:08:03,680 --> 00:08:07,800
shared so has a shared reference which

00:08:05,970 --> 00:08:10,140
means that you can't get a mutable

00:08:07,800 --> 00:08:13,230
reference at the same time and these set

00:08:10,140 --> 00:08:15,480
methods the setters are a mute self so

00:08:13,230 --> 00:08:18,240
they can't kind of overlap with vb.net

00:08:15,480 --> 00:08:22,260
check but that's also really important

00:08:18,240 --> 00:08:23,520
for our algorithm basically it would be

00:08:22,260 --> 00:08:25,890
really confusing if in the middle of

00:08:23,520 --> 00:08:28,520
executing the revision was changing and

00:08:25,890 --> 00:08:30,930
you even have a sort of explicit

00:08:28,520 --> 00:08:32,880
mechanism which I didn't talk about in

00:08:30,930 --> 00:08:34,500
the other I didn't talk about it and I

00:08:32,880 --> 00:08:37,409
won't talk about in great depth but

00:08:34,500 --> 00:08:39,450
given a DB handle I think the method is

00:08:37,409 --> 00:08:41,669
called freeze I forget you can get a

00:08:39,450 --> 00:08:44,550
second handle or I think I call this

00:08:41,669 --> 00:08:46,470
snapshot and this second handle

00:08:44,550 --> 00:08:48,690
basically lets you do a number of you

00:08:46,470 --> 00:08:51,750
can use it just like a database but you

00:08:48,690 --> 00:08:53,460
can't do any set operations and it's

00:08:51,750 --> 00:08:55,260
effectively as it keeps the database in

00:08:53,460 --> 00:08:57,700
a frozen state while it exists

00:08:55,260 --> 00:08:59,740
and then it's really meant to be sent to

00:08:57,700 --> 00:09:01,630
another thread and processed in parallel

00:08:59,740 --> 00:09:03,430
and it's exactly this idea that while

00:09:01,630 --> 00:09:06,610
that thread is executing it does not

00:09:03,430 --> 00:09:09,520
want it wants to execute atomically with

00:09:06,610 --> 00:09:11,170
respect to the database and there's just

00:09:09,520 --> 00:09:13,480
me clear there's no way of saying start

00:09:11,170 --> 00:09:15,730
transaction and do these five minutes

00:09:13,480 --> 00:09:18,940
and then stop transaction like you're

00:09:15,730 --> 00:09:19,360
just assumed to do one edit edit that's

00:09:18,940 --> 00:09:20,830
right

00:09:19,360 --> 00:09:23,020
and edits can only happen on the main

00:09:20,830 --> 00:09:25,990
thread anyway you can't go you can't

00:09:23,020 --> 00:09:28,630
clone the DB you only snapshot it which

00:09:25,990 --> 00:09:31,180
freezes it so there's sort of no need

00:09:28,630 --> 00:09:35,680
for a transaction because there could be

00:09:31,180 --> 00:09:37,950
nothing that intervenes so all right so

00:09:35,680 --> 00:09:39,850
that's the database concept um

00:09:37,950 --> 00:09:42,100
let's look a little bit more at this

00:09:39,850 --> 00:09:45,120
query storage so I mentioned the for an

00:09:42,100 --> 00:09:51,310
input query effectively you have a map

00:09:45,120 --> 00:09:55,630
like this um it says given a key I'll

00:09:51,310 --> 00:09:57,820
give you a value and a revision which is

00:09:55,630 --> 00:10:00,820
when the value was set for a derived

00:09:57,820 --> 00:10:01,990
query we have there's actually a bunch

00:10:00,820 --> 00:10:05,190
of options here but I'm just going to

00:10:01,990 --> 00:10:07,839
explain like the main a normal one and

00:10:05,190 --> 00:10:10,470
I'll probably forget something we may we

00:10:07,839 --> 00:10:17,710
may come back to this but this is the

00:10:10,470 --> 00:10:19,240
basic idea what is this verified at and

00:10:17,710 --> 00:10:21,940
changed at so we are actually two

00:10:19,240 --> 00:10:26,350
revisions so a derived value would be

00:10:21,940 --> 00:10:28,750
something that we compute by doing a by

00:10:26,350 --> 00:10:30,910
running a function right and uh I'll

00:10:28,750 --> 00:10:32,410
come back to this struct with like the

00:10:30,910 --> 00:10:34,300
details of this but let's let's first

00:10:32,410 --> 00:10:38,589
just sort of walk through if you called

00:10:34,300 --> 00:10:40,480
let's say DB ast for some file what's

00:10:38,589 --> 00:10:43,000
going to happen here at a high level is

00:10:40,480 --> 00:10:47,680
we will check to see if we have a

00:10:43,000 --> 00:10:50,070
memorized value already and if so we

00:10:47,680 --> 00:10:52,900
will clone that value and return it

00:10:50,070 --> 00:10:57,190
that's for people that haven't heard the

00:10:52,900 --> 00:10:59,620
term memo is but what right so basically

00:10:57,190 --> 00:11:02,320
did we already execute this query and if

00:10:59,620 --> 00:11:04,450
so we will stash a copy of the results

00:11:02,320 --> 00:11:05,920
that's the memorized value it's like you

00:11:04,450 --> 00:11:07,780
wrote a little memo to yourself with

00:11:05,920 --> 00:11:08,830
what the result was then the next time

00:11:07,780 --> 00:11:12,160
you use it you can

00:11:08,830 --> 00:11:13,510
just clone it and you already you can

00:11:12,160 --> 00:11:16,150
kind of see here something important

00:11:13,510 --> 00:11:18,700
which is that the type really matters so

00:11:16,150 --> 00:11:21,700
I I define these queries as returning an

00:11:18,700 --> 00:11:24,310
ast and if that were some big struck

00:11:21,700 --> 00:11:25,900
that's kind of expensive to clone like

00:11:24,310 --> 00:11:28,930
maybe it has deep ownership of all of

00:11:25,900 --> 00:11:31,240
its so then that's not so great because

00:11:28,930 --> 00:11:33,400
every time we invoke DB ast we're gonna

00:11:31,240 --> 00:11:36,640
clone it we've got enough we've always

00:11:33,400 --> 00:11:38,670
got we always have at least one clone

00:11:36,640 --> 00:11:42,280
because we're keeping the old value here

00:11:38,670 --> 00:11:44,560
so so what you really want there is to

00:11:42,280 --> 00:11:47,320
have maybe maybe you want to put it in

00:11:44,560 --> 00:11:48,550
an arc or something like that I'm not

00:11:47,320 --> 00:11:50,410
gonna worry about that right now what

00:11:48,550 --> 00:11:52,780
similarly string and so forth might not

00:11:50,410 --> 00:11:55,080
be the best choices um you really want

00:11:52,780 --> 00:11:57,700
keys and values to be cheaply cloneable

00:11:55,080 --> 00:11:59,290
so about any case we'll check to see if

00:11:57,700 --> 00:12:03,820
those memoirs value if there is no

00:11:59,290 --> 00:12:06,730
memorized value this is like the basic

00:12:03,820 --> 00:12:13,470
algorithm I guess then we invoke the

00:12:06,730 --> 00:12:15,430
function DB or Ras tdv8 other so

00:12:13,470 --> 00:12:17,140
essentially here we're gonna call the

00:12:15,430 --> 00:12:18,790
function that you defined we'll see it

00:12:17,140 --> 00:12:20,620
in a second we'll give it the database

00:12:18,790 --> 00:12:23,370
we'll give it the keys sometimes there's

00:12:20,620 --> 00:12:25,750
more keys right now there's only one and

00:12:23,370 --> 00:12:29,260
then we will take the return value so

00:12:25,750 --> 00:12:32,650
this would be like let's take the return

00:12:29,260 --> 00:12:34,000
value or store V into the map with note

00:12:32,650 --> 00:12:35,860
that here when we do this we're actually

00:12:34,000 --> 00:12:37,990
going to clone the keys too so that's

00:12:35,860 --> 00:12:43,300
why I say both should be cloneable well

00:12:37,990 --> 00:12:45,550
store V into the map and well well put

00:12:43,300 --> 00:12:46,990
the ignore I'm going to ignore the

00:12:45,550 --> 00:12:49,450
dependencies part for a second we're

00:12:46,990 --> 00:12:57,640
gonna put the value you know with the

00:12:49,450 --> 00:13:00,550
key a dot RS the value is the value is V

00:12:57,640 --> 00:13:02,050
and the verify that or the change that

00:13:00,550 --> 00:13:04,420
is going to be the current revision

00:13:02,050 --> 00:13:05,620
whatever that is and so we'll have

00:13:04,420 --> 00:13:08,350
verify and what that's basically saying

00:13:05,620 --> 00:13:10,390
is the last time we computed this was we

00:13:08,350 --> 00:13:13,090
remember what the revision was so let's

00:13:10,390 --> 00:13:16,050
say it's r1 for now or r2 I guess

00:13:13,090 --> 00:13:19,270
because we said we called two setters um

00:13:16,050 --> 00:13:23,560
so we went to a revision r2 here

00:13:19,270 --> 00:13:30,510
now we know that in r2 we computed this

00:13:23,560 --> 00:13:30,510
ast and this was what it looked like and

00:13:31,320 --> 00:13:37,630
I think that's a really great high level

00:13:33,940 --> 00:13:39,240
overview of what's happening but maybe

00:13:37,630 --> 00:13:42,070
we can talk a little bit about that is

00:13:39,240 --> 00:13:44,320
function like what is it returning from

00:13:42,070 --> 00:13:46,510
that that function that's going into V

00:13:44,320 --> 00:13:47,080
that we're then snoring into the map

00:13:46,510 --> 00:13:50,200
later

00:13:47,080 --> 00:13:52,000
right so the AST function that's that's

00:13:50,200 --> 00:13:54,850
literally this function that the user

00:13:52,000 --> 00:14:01,120
defined here so it's returning whatever

00:13:54,850 --> 00:14:02,589
this function returns and because we're

00:14:01,120 --> 00:14:05,020
sort of generating all this code with

00:14:02,589 --> 00:14:07,000
macros and things going well or generics

00:14:05,020 --> 00:14:07,390
and so forth as necessary the types all

00:14:07,000 --> 00:14:12,190
line up

00:14:07,390 --> 00:14:14,260
um and write so that once we call here

00:14:12,190 --> 00:14:17,170
this is really the users code yes we

00:14:14,260 --> 00:14:19,420
don't you're not do anything um so that

00:14:17,170 --> 00:14:20,740
would call that would internally if we

00:14:19,420 --> 00:14:23,640
walk through what that's going to do in

00:14:20,740 --> 00:14:26,350
this case it's gonna call DB source text

00:14:23,640 --> 00:14:28,209
so we've given it our database right

00:14:26,350 --> 00:14:32,680
here as one of its parameters

00:14:28,209 --> 00:14:33,700
um and actually I wrote here I wrote

00:14:32,680 --> 00:14:36,160
database but I'm gonna write itself

00:14:33,700 --> 00:14:38,110
because this is effectively that this is

00:14:36,160 --> 00:14:41,680
like when this is the definition for the

00:14:38,110 --> 00:14:45,430
actual method like in other words we're

00:14:41,680 --> 00:14:48,940
kind of defining the name of this trait

00:14:45,430 --> 00:14:52,180
oh I was willing consistent we'll just

00:14:48,940 --> 00:14:56,279
call it example do it a very good name

00:14:52,180 --> 00:14:56,279
my query group

00:14:57,270 --> 00:15:01,089
we're basically defining this what we're

00:14:59,860 --> 00:15:06,360
saying here this algorithm this is

00:15:01,089 --> 00:15:11,160
essentially what what the database

00:15:06,360 --> 00:15:11,160
actually gonna do when you call AST oh

00:15:13,050 --> 00:15:16,860
sometimes invoke

00:15:20,579 --> 00:15:28,930
so right so we go back here and here we

00:15:27,069 --> 00:15:30,879
see that in while we're running the

00:15:28,930 --> 00:15:35,410
users code it actually calls source text

00:15:30,879 --> 00:15:38,860
right and source text is an input so

00:15:35,410 --> 00:15:40,930
inputs behave a little differently when

00:15:38,860 --> 00:15:44,949
you when you invoke an input what

00:15:40,930 --> 00:15:47,220
happens it's much simpler essentially

00:15:44,949 --> 00:15:51,699
you just look it up in the hashmap

00:15:47,220 --> 00:15:53,350
amateur and clone the result but again

00:15:51,699 --> 00:15:55,389
you see we're cloning so it's important

00:15:53,350 --> 00:15:56,980
it might be too expensive but so when we

00:15:55,389 --> 00:15:58,300
call DB dot source text that's that's

00:15:56,980 --> 00:15:59,709
literally just a hash name but look up

00:15:58,300 --> 00:16:01,029
with a little a little bit of stuff

00:15:59,709 --> 00:16:03,759
around it that we'll get to in a second

00:16:01,029 --> 00:16:06,879
but that's where we get the string from

00:16:03,759 --> 00:16:09,160
and that the hash map is again returning

00:16:06,879 --> 00:16:12,519
not just the value but the revision and

00:16:09,160 --> 00:16:14,560
the value William well yeah that's right

00:16:12,519 --> 00:16:16,750
internally it is returning the boat both

00:16:14,560 --> 00:16:18,160
of them but the revision doesn't make it

00:16:16,750 --> 00:16:22,860
all the way to the user right we kind of

00:16:18,160 --> 00:16:25,389
intercept that um and right so okay so

00:16:22,860 --> 00:16:28,149
if you didn't have any revision tracking

00:16:25,389 --> 00:16:31,120
this is actually more or less how the

00:16:28,149 --> 00:16:32,380
system works and you see that now you

00:16:31,120 --> 00:16:34,930
can sort of see what the memo ice

00:16:32,380 --> 00:16:37,269
happens because if we call DB ast twice

00:16:34,930 --> 00:16:39,490
the first time we invoke the function

00:16:37,269 --> 00:16:41,800
the second time we have a value so we

00:16:39,490 --> 00:16:45,490
can just return it the only thing that I

00:16:41,800 --> 00:16:47,680
would add on to this is that's kind of

00:16:45,490 --> 00:16:52,509
important is actually before we do any

00:16:47,680 --> 00:16:54,579
of this we check for a cycle and that

00:16:52,509 --> 00:16:56,800
means that while you're computing DB or

00:16:54,579 --> 00:16:58,689
the ast for a given file you can't

00:16:56,800 --> 00:17:00,730
recursively ask for the ast for that

00:16:58,689 --> 00:17:05,049
file because we don't know what to give

00:17:00,730 --> 00:17:07,270
you essentially um and in that case we

00:17:05,049 --> 00:17:09,429
panic so you're really not supposed to

00:17:07,270 --> 00:17:13,059
to do that you have to kind of set up

00:17:09,429 --> 00:17:15,459
your query so they don't cycle and in in

00:17:13,059 --> 00:17:18,579
Russy itself these panics get we kind of

00:17:15,459 --> 00:17:20,199
capture the stack trace and print them

00:17:18,579 --> 00:17:24,059
out to the user as user errors and your

00:17:20,199 --> 00:17:24,059
source code is messed up in some cases

00:17:24,390 --> 00:17:33,770
so right but now we can kind of start to

00:17:30,730 --> 00:17:35,450
add the revision tracking I guess

00:17:33,770 --> 00:17:40,490
so the idea what the revision tracking

00:17:35,450 --> 00:17:43,580
is when we next call if we when we next

00:17:40,490 --> 00:17:46,820
call a setter it's going to up the

00:17:43,580 --> 00:17:49,840
revision and so now when we look at this

00:17:46,820 --> 00:17:57,380
memorized value we really want to check

00:17:49,840 --> 00:18:01,160
check if the verified at field is equal

00:17:57,380 --> 00:18:05,870
to the current revision if so we can

00:18:01,160 --> 00:18:08,330
return it so now we said was this

00:18:05,870 --> 00:18:11,450
basically was this verified out is

00:18:08,330 --> 00:18:14,300
telling us is this value do we know that

00:18:11,450 --> 00:18:15,770
it's correct give in this revision given

00:18:14,300 --> 00:18:17,059
the state of the inputs in this revision

00:18:15,770 --> 00:18:19,670
right so if that's the current revision

00:18:17,059 --> 00:18:22,340
then we're done and that's still going

00:18:19,670 --> 00:18:25,190
to work the same for the memorizing but

00:18:22,340 --> 00:18:26,600
if it's not if it's older like that's it

00:18:25,190 --> 00:18:29,870
that means that an input has changed

00:18:26,600 --> 00:18:32,150
since this revision was done then we

00:18:29,870 --> 00:18:34,580
want to see like basically figure out if

00:18:32,150 --> 00:18:37,340
we can reuse the value or not that's

00:18:34,580 --> 00:18:40,429
what the into a bit um to do that we

00:18:37,340 --> 00:18:43,610
have to go back one step while we were

00:18:40,429 --> 00:18:44,540
actually computing the value we were

00:18:43,610 --> 00:18:47,679
doing a little bit more

00:18:44,540 --> 00:18:52,490
behind-the-scenes we were also tracking

00:18:47,679 --> 00:18:54,679
what queries you did and recording them

00:18:52,490 --> 00:19:02,809
in a step basically recording them as

00:18:54,679 --> 00:19:05,630
the dependencies so the way we do that

00:19:02,809 --> 00:19:07,940
tracking is well first of all so like in

00:19:05,630 --> 00:19:10,850
this case what that would mean for ast

00:19:07,940 --> 00:19:13,370
is we would get back a result movie yeah

00:19:10,850 --> 00:19:14,840
we'll get back to things here we'll get

00:19:13,370 --> 00:19:17,870
back the value and we'll get back the

00:19:14,840 --> 00:19:23,690
dependencies and the dependencies would

00:19:17,870 --> 00:19:26,630
be like a vector in this case the what

00:19:23,690 --> 00:19:29,000
did we call source text so we have this

00:19:26,630 --> 00:19:30,260
concept which is you don't directly

00:19:29,000 --> 00:19:34,460
interact with it but it's called the

00:19:30,260 --> 00:19:37,370
database key and basically what it is if

00:19:34,460 --> 00:19:39,920
the query key if the key for a query is

00:19:37,370 --> 00:19:42,230
just this string that arguments to the

00:19:39,920 --> 00:19:44,150
query basically and the database key is

00:19:42,230 --> 00:19:45,650
kind of the pair of the query name and

00:19:44,150 --> 00:19:47,020
all of its arguments so it kind of

00:19:45,650 --> 00:19:51,669
uniquely identifies

00:19:47,020 --> 00:19:54,039
one bit of computation and so-so a

00:19:51,669 --> 00:19:57,570
dependencies the dependencies list is

00:19:54,039 --> 00:20:01,899
just it's like a vector of database keys

00:19:57,570 --> 00:20:04,299
and in this case we would have okay

00:20:01,899 --> 00:20:08,529
in the course of computing the ast we

00:20:04,299 --> 00:20:12,850
accessed the source text and we'll store

00:20:08,529 --> 00:20:15,850
that along with the value and this kind

00:20:12,850 --> 00:20:18,190
of works because when we're invoking the

00:20:15,850 --> 00:20:21,760
query and that query invokes another

00:20:18,190 --> 00:20:25,000
query because of the magic of macros we

00:20:21,760 --> 00:20:27,789
can we have some visibility into what is

00:20:25,000 --> 00:20:29,919
like that second query we can see that

00:20:27,789 --> 00:20:31,990
that's fitting in both by the first one

00:20:29,919 --> 00:20:35,770
yeah so let me it's not really a magic

00:20:31,990 --> 00:20:37,539
of macros per se but we have in the

00:20:35,770 --> 00:20:39,730
database we know what is the currently

00:20:37,539 --> 00:20:41,470
active query we actually know the whole

00:20:39,730 --> 00:20:45,309
stack which is how we check for a cycle

00:20:41,470 --> 00:20:46,659
in the first place so what we can do is

00:20:45,309 --> 00:20:50,049
the first thing we do when you enter

00:20:46,659 --> 00:20:51,789
into any operation is we record this as

00:20:50,049 --> 00:20:57,880
a dependency of the currently active

00:20:51,789 --> 00:20:59,860
query so like also here we would record

00:20:57,880 --> 00:21:08,380
so for this is let's say this is DB

00:20:59,860 --> 00:21:10,840
choice text we would record source text

00:21:08,380 --> 00:21:15,340
as a dependency and similarly finally

00:21:10,840 --> 00:21:22,419
here we have to kind of push on to the

00:21:15,340 --> 00:21:25,240
currently active query stack the push

00:21:22,419 --> 00:21:27,190
afresh sort of afresh record on to the

00:21:25,240 --> 00:21:31,059
currently active query step um and here

00:21:27,190 --> 00:21:32,500
we would pop it off that's kind of

00:21:31,059 --> 00:21:34,960
actually how we get the dependencies out

00:21:32,500 --> 00:21:41,049
as we pop off the record extract the

00:21:34,960 --> 00:21:44,380
dependencies from it and so really it's

00:21:41,049 --> 00:21:46,090
not returned to us it's it's something

00:21:44,380 --> 00:21:48,570
we recorded while we've Wally st was

00:21:46,090 --> 00:21:48,570
executed

00:21:49,610 --> 00:21:56,070
and right

00:21:53,760 --> 00:21:59,970
so that we have that we also track one

00:21:56,070 --> 00:22:06,060
other thing as we go which is we track

00:21:59,970 --> 00:22:09,210
the the maximum revision at which any of

00:22:06,060 --> 00:22:11,100
the things we did changed so we

00:22:09,210 --> 00:22:13,590
mentioned that in the source text we're

00:22:11,100 --> 00:22:21,990
going to clone the result and return the

00:22:13,590 --> 00:22:23,700
associated revision so track the maximum

00:22:21,990 --> 00:22:27,780
changed position so for example when we

00:22:23,700 --> 00:22:29,820
call a ste well when we in this case

00:22:27,780 --> 00:22:31,170
we're only we're only doing one thing so

00:22:29,820 --> 00:22:33,300
the maximum revision would just be

00:22:31,170 --> 00:22:35,550
whatever basically whatever revision the

00:22:33,300 --> 00:22:39,950
source text changed in we'll bring that

00:22:35,550 --> 00:22:42,930
back with us um and we use that later so

00:22:39,950 --> 00:22:44,610
okay so now we have information now we

00:22:42,930 --> 00:22:46,920
can come back to figuring out if we can

00:22:44,610 --> 00:22:50,970
reuse the value now we have a list of

00:22:46,920 --> 00:22:54,810
dependencies that we and this is

00:22:50,970 --> 00:22:56,480
basically all that we assume that you're

00:22:54,810 --> 00:22:58,860
derived query is a purely deterministic

00:22:56,480 --> 00:23:00,270
function and that's kind of on you to

00:22:58,860 --> 00:23:01,860
get correct but we assume that it's a

00:23:00,270 --> 00:23:06,900
function that if you give it exactly the

00:23:01,860 --> 00:23:09,360
same inputs then it will do exactly the

00:23:06,900 --> 00:23:11,250
same thing right and that means and by

00:23:09,360 --> 00:23:14,220
inputs here I don't mean just the inputs

00:23:11,250 --> 00:23:16,140
to the salsa database as a whole like

00:23:14,220 --> 00:23:17,790
source text I really mean all the

00:23:16,140 --> 00:23:19,710
queries that it invokes are kind of its

00:23:17,790 --> 00:23:22,020
inputs right so here there's an input

00:23:19,710 --> 00:23:24,750
dbi source text but for the whole

00:23:22,020 --> 00:23:26,670
program ast query manifest as an input

00:23:24,750 --> 00:23:31,080
but so is sort of the result of this

00:23:26,670 --> 00:23:33,750
recursive call so we assume that it's

00:23:31,080 --> 00:23:36,360
deterministic and therefore we assume if

00:23:33,750 --> 00:23:40,410
none of the inputs have changed in this

00:23:36,360 --> 00:23:42,450
revision then the result must not have

00:23:40,410 --> 00:23:45,330
changed in this revision either and we

00:23:42,450 --> 00:23:47,520
don't need to re-execute it so what we

00:23:45,330 --> 00:23:52,880
can do is say something like for each

00:23:47,520 --> 00:23:52,880
dependency we had before let's call it D

00:23:53,120 --> 00:24:00,540
did D change or like look at the is the

00:23:57,930 --> 00:24:02,950
changed at of D

00:24:00,540 --> 00:24:07,000
which is the last provision where this

00:24:02,950 --> 00:24:09,940
thing changed greater than or equal to

00:24:07,000 --> 00:24:12,180
the current revision I guess it can't

00:24:09,940 --> 00:24:19,210
ever be greater than equal to the Cruz

00:24:12,180 --> 00:24:20,410
and if so or yeah it's so break I don't

00:24:19,210 --> 00:24:23,320
know that's kind of annoying let's look

00:24:20,410 --> 00:24:27,700
at it more like this for all the

00:24:23,320 --> 00:24:31,450
dependencies is changed at of D less

00:24:27,700 --> 00:24:33,880
than the current revision more or less

00:24:31,450 --> 00:24:38,950
not quite right but that's the idea

00:24:33,880 --> 00:24:43,330
I probably mean the verified app and if

00:24:38,950 --> 00:24:45,430
so we can update verified at to the

00:24:43,330 --> 00:24:46,750
current revision I probably this is

00:24:45,430 --> 00:24:49,450
maybe a bit more detail I'm sure I'm

00:24:46,750 --> 00:24:50,830
getting some of the exact logic here a

00:24:49,450 --> 00:24:52,690
little bit wrong but the basic idea is

00:24:50,830 --> 00:24:55,150
we look at those we know when those

00:24:52,690 --> 00:25:00,190
values changed and we can go over them

00:24:55,150 --> 00:25:03,070
and see have they changed in the current

00:25:00,190 --> 00:25:04,390
revision or not and or since the law how

00:25:03,070 --> 00:25:06,730
they change since the last time we

00:25:04,390 --> 00:25:08,920
computed this value basically and if

00:25:06,730 --> 00:25:10,480
they haven't then we can just say well

00:25:08,920 --> 00:25:12,550
the value is still good and we can

00:25:10,480 --> 00:25:14,290
change the verified at field to say well

00:25:12,550 --> 00:25:16,450
at least in this revision it was up to

00:25:14,290 --> 00:25:18,280
date right and the next time through we

00:25:16,450 --> 00:25:20,890
don't have to redo this work again but

00:25:18,280 --> 00:25:23,020
the change that we don't change because

00:25:20,890 --> 00:25:24,490
it didn't change its value it's it never

00:25:23,020 --> 00:25:27,070
changed it in revision in the new

00:25:24,490 --> 00:25:29,680
revision it's still the same value it

00:25:27,070 --> 00:25:31,390
was before so it's like an example I

00:25:29,680 --> 00:25:37,180
think that'll help a little bit so if we

00:25:31,390 --> 00:25:39,280
say like we do DB dot set source text or

00:25:37,180 --> 00:25:42,780
whatever I called it I think I called it

00:25:39,280 --> 00:25:45,310
source text something this puts us in r1

00:25:42,780 --> 00:25:47,680
then let's say we set source text here

00:25:45,310 --> 00:25:51,670
at a beam it puts us in r2 and then we

00:25:47,680 --> 00:25:54,310
invoke the parser on a that's going to

00:25:51,670 --> 00:25:57,160
give us a record that says you know I

00:25:54,310 --> 00:26:01,210
was verified at r2 and I changed at r2

00:25:57,160 --> 00:26:03,550
and of course my dependencies is just a

00:26:01,210 --> 00:26:06,250
dot RS and then suppose that I set the

00:26:03,550 --> 00:26:12,970
source for B again and now I'm in r3 and

00:26:06,250 --> 00:26:13,720
I really in puts for this function have

00:26:12,970 --> 00:26:16,720
changed in the

00:26:13,720 --> 00:26:20,680
new revision so when we ask I'll just go

00:26:16,720 --> 00:26:23,560
ahead and put the dependencies list when

00:26:20,680 --> 00:26:25,510
we ask when we go look at source text

00:26:23,560 --> 00:26:28,480
for a dot RS and we asked when did it

00:26:25,510 --> 00:26:30,790
change we're gonna get back our - or

00:26:28,480 --> 00:26:32,650
yeah I'm sorry our one function we'll

00:26:30,790 --> 00:26:35,080
get back our one because that's the last

00:26:32,650 --> 00:26:37,660
time a new value was set and so we'll

00:26:35,080 --> 00:26:39,970
say okay we can just we can just change

00:26:37,660 --> 00:26:41,500
this to our three um

00:26:39,970 --> 00:26:43,230
we can leave changed at the way it was

00:26:41,500 --> 00:26:46,630
we leave the dependencies the way it was

00:26:43,230 --> 00:26:47,920
because sort of if we had we executed it

00:26:46,630 --> 00:26:53,560
we would have gotten the same thing we

00:26:47,920 --> 00:26:55,480
got in or - that's fine and I forget

00:26:53,560 --> 00:26:57,400
actually it may it may be that we

00:26:55,480 --> 00:26:59,770
actually store our one year because I

00:26:57,400 --> 00:27:02,580
mentioned we compute the maximum of all

00:26:59,770 --> 00:27:04,990
of our inputs when did they change I

00:27:02,580 --> 00:27:07,150
forget exactly how we do that but either

00:27:04,990 --> 00:27:09,100
one would be correct at least for the

00:27:07,150 --> 00:27:10,320
algorithm I think it doesn't really

00:27:09,100 --> 00:27:15,160
matter as long as it's uh

00:27:10,320 --> 00:27:16,600
as long as it's you know recorded at

00:27:15,160 --> 00:27:21,820
this point because we only care about

00:27:16,600 --> 00:27:25,270
the future but the point is we know go

00:27:21,820 --> 00:27:27,280
on jump in maybe I can repeat back to

00:27:25,270 --> 00:27:31,120
you what I'm hearing you say and we can

00:27:27,280 --> 00:27:36,330
kind of double-check that I got it some

00:27:31,120 --> 00:27:40,240
part so we set tour specs on a RS and

00:27:36,330 --> 00:27:42,670
source tags a RS is kind of that special

00:27:40,240 --> 00:27:44,890
key that special key that will allow us

00:27:42,670 --> 00:27:46,650
to know if we've run this before in the

00:27:44,890 --> 00:27:49,120
past

00:27:46,650 --> 00:27:52,720
alright so we remember that we've done

00:27:49,120 --> 00:27:56,950
that we've set it at revision one that's

00:27:52,720 --> 00:28:00,430
that's the r1 or a Don RS mm-hmm then we

00:27:56,950 --> 00:28:04,240
do sense we're specs or B dot RS that's

00:28:00,430 --> 00:28:06,220
a different file and a different key as

00:28:04,240 --> 00:28:09,250
a result so because that screen is

00:28:06,220 --> 00:28:13,600
different we now have sourced XB RS in

00:28:09,250 --> 00:28:17,260
the database as well and that's an r2 we

00:28:13,600 --> 00:28:18,910
don't touch we don't touch me the

00:28:17,260 --> 00:28:21,370
previous tenants that we made at that

00:28:18,910 --> 00:28:24,280
point so a non RS would still be a more

00:28:21,370 --> 00:28:26,559
one even though now b dot RS is still

00:28:24,280 --> 00:28:30,659
alert - yep I guess

00:28:26,559 --> 00:28:34,090
to change that so when we do the lion

00:28:30,659 --> 00:28:36,460
3db dot ASP so now we're going to do a

00:28:34,090 --> 00:28:39,009
query we're not setting anything we're

00:28:36,460 --> 00:28:43,570
just queering in back out when we create

00:28:39,009 --> 00:28:46,350
a dot RS we know to go look for its

00:28:43,570 --> 00:28:50,350
dependencies to be able to answer that

00:28:46,350 --> 00:28:54,070
we get that because as the query runs

00:28:50,350 --> 00:28:59,169
where we're basically logging the steps

00:28:54,070 --> 00:29:04,330
and it's picking to answer that yes okay

00:28:59,169 --> 00:29:08,049
so at this time through we watch it run

00:29:04,330 --> 00:29:10,539
because it's not cached yet so we

00:29:08,049 --> 00:29:13,149
actually run the SQ function we step

00:29:10,539 --> 00:29:15,850
through we see it call the source Bex

00:29:13,149 --> 00:29:19,119
query and when it does we set that into

00:29:15,850 --> 00:29:21,549
the dependencies it finishes running and

00:29:19,119 --> 00:29:24,850
gives us a value and we know that we

00:29:21,549 --> 00:29:27,309
verify this at the most recent which is

00:29:24,850 --> 00:29:31,799
our two because everything just came out

00:29:27,309 --> 00:29:36,519
fresh and they changed is the most

00:29:31,799 --> 00:29:40,149
recent for that for the query I guess

00:29:36,519 --> 00:29:41,919
the camera which we called Oh max chain

00:29:40,149 --> 00:29:44,710
provision was what you call it so the

00:29:41,919 --> 00:29:47,049
match change revision would be our one

00:29:44,710 --> 00:29:51,129
in this case because everything that a

00:29:47,049 --> 00:29:54,759
dot RS means is in the first provision

00:29:51,129 --> 00:29:56,590
mm-hmm does that sound right so far

00:29:54,759 --> 00:29:59,799
yep I'm trying to like note down some of

00:29:56,590 --> 00:30:04,929
the things you said yeah that sounds

00:29:59,799 --> 00:30:05,889
exactly right so right oh yeah so maybe

00:30:04,929 --> 00:30:09,369
we can keep going

00:30:05,889 --> 00:30:11,409
that sounds good so far right I'm pretty

00:30:09,369 --> 00:30:15,190
sure yeah exactly so change that r1 is

00:30:11,409 --> 00:30:18,580
basically that's the last time any input

00:30:15,190 --> 00:30:20,710
changed right so therefore that must be

00:30:18,580 --> 00:30:22,090
if we went back in time into revision 1

00:30:20,710 --> 00:30:24,519
and we execute it we should get the same

00:30:22,090 --> 00:30:25,799
result because we don't get any other

00:30:24,519 --> 00:30:29,830
things that changed after that

00:30:25,799 --> 00:30:32,139
and then we do a sense or specs on line

00:30:29,830 --> 00:30:35,799
4 we do a sensory specs with B dot RS

00:30:32,139 --> 00:30:40,419
again so this is the first time we're

00:30:35,799 --> 00:30:43,179
reusing one of our keys yes he was

00:30:40,419 --> 00:30:50,590
are too but now that we're editing it

00:30:43,179 --> 00:30:53,649
again that's at our 3/10 on line 5 you

00:30:50,590 --> 00:30:59,019
have a SD a dot RS so now we're four

00:30:53,649 --> 00:31:01,090
rerunning that query we update the I

00:30:59,019 --> 00:31:02,649
guess we update the verify because we're

00:31:01,090 --> 00:31:06,489
we're saying okay we're in r3

00:31:02,649 --> 00:31:08,980
I'm checking everything again an r3 8

00:31:06,489 --> 00:31:12,249
this is where we're at everything's

00:31:08,980 --> 00:31:13,629
still r1 we don't have to rerun any of

00:31:12,249 --> 00:31:16,690
the query none of the dependencies

00:31:13,629 --> 00:31:18,429
change at this point so we can just give

00:31:16,690 --> 00:31:21,309
you the cash value or the memorized

00:31:18,429 --> 00:31:24,009
values yep and so to walk through this

00:31:21,309 --> 00:31:27,369
just to touch more detail on entry we

00:31:24,009 --> 00:31:31,330
will have this value in particular this

00:31:27,369 --> 00:31:33,249
is out of date because the current the

00:31:31,330 --> 00:31:35,440
current revision is r3 but we saw that

00:31:33,249 --> 00:31:37,029
this was last verified in r2 so it might

00:31:35,440 --> 00:31:39,519
there might be a problem we don't know

00:31:37,029 --> 00:31:42,690
yet and then we can iterate over the

00:31:39,519 --> 00:31:46,299
dependencies and basically ask them

00:31:42,690 --> 00:31:47,529
right when they last changed and in this

00:31:46,299 --> 00:31:49,929
case this is exactly one input

00:31:47,529 --> 00:31:51,249
dependency so it's very easy to tell

00:31:49,929 --> 00:31:54,999
when it last change we just look it up

00:31:51,249 --> 00:31:58,869
in the hash map and so the most recent

00:31:54,999 --> 00:32:03,669
version is r1 and so we conclude then

00:31:58,869 --> 00:32:08,259
that nothing changed that affects us so

00:32:03,669 --> 00:32:10,239
we just update verify that the current

00:32:08,259 --> 00:32:18,820
revision that's the last time we figured

00:32:10,239 --> 00:32:22,899
we checked it yeah so yeah that's the

00:32:18,820 --> 00:32:26,950
idea so far there's one twist we haven't

00:32:22,899 --> 00:32:28,029
gotten to yet one of it well there's two

00:32:26,950 --> 00:32:30,220
things we didn't talk about that are

00:32:28,029 --> 00:32:32,039
relevant I think the first one is I only

00:32:30,220 --> 00:32:36,399
showed you when you have a direct

00:32:32,039 --> 00:32:39,850
dependency which is an input that's very

00:32:36,399 --> 00:32:41,820
easy in the case where the dependency is

00:32:39,850 --> 00:32:44,259
not an input but rather a derived thing

00:32:41,820 --> 00:32:46,330
then we sort of have to recursively do

00:32:44,259 --> 00:32:50,919
this procedure so let's say the whole

00:32:46,330 --> 00:32:53,570
program ast invokes that invokes one of

00:32:50,919 --> 00:32:55,100
its ast dependencies

00:32:53,570 --> 00:32:56,539
we want to find out if it's up to date

00:32:55,100 --> 00:32:58,490
in this revision and it's the same basic

00:32:56,539 --> 00:33:01,760
idea but it's a slightly different

00:32:58,490 --> 00:33:03,200
variation on it so before we actually

00:33:01,760 --> 00:33:07,250
dive into that which sounds really

00:33:03,200 --> 00:33:09,529
interesting there's um maybe we can take

00:33:07,250 --> 00:33:12,140
this example and go a little bit further

00:33:09,529 --> 00:33:15,289
in this particular example so we can see

00:33:12,140 --> 00:33:17,870
the interaction between the the

00:33:15,289 --> 00:33:20,390
memorizing and the edits so right now

00:33:17,870 --> 00:33:22,700
we're we're editing feed on RS and

00:33:20,390 --> 00:33:24,830
that's not affecting eight others we

00:33:22,700 --> 00:33:27,620
still get the same annoys version of

00:33:24,830 --> 00:33:30,799
eight on RS but if we set the source

00:33:27,620 --> 00:33:34,700
specs of eight on RS you know after this

00:33:30,799 --> 00:33:36,830
block yep yeah actually I think I think

00:33:34,700 --> 00:33:38,630
that you are totally correct we should

00:33:36,830 --> 00:33:41,149
continue with this example and the thing

00:33:38,630 --> 00:33:42,380
I was going to say you said sounds very

00:33:41,149 --> 00:33:43,100
interesting I think it actually isn't

00:33:42,380 --> 00:33:45,380
that interesting

00:33:43,100 --> 00:33:47,870
so we'll come back to it baby it's

00:33:45,380 --> 00:33:49,820
basically a variation on a theme but

00:33:47,870 --> 00:33:52,250
let's let's look at this instead suppose

00:33:49,820 --> 00:33:54,470
suppose that I call now a set source

00:33:52,250 --> 00:33:58,190
text on a dot RS but where I had

00:33:54,470 --> 00:34:01,340
function main with an empty body I now

00:33:58,190 --> 00:34:03,649
change it oops I lost my where am I Here

00:34:01,340 --> 00:34:06,049
I am I now change it to have a space in

00:34:03,649 --> 00:34:07,669
the body right it's not a particularly

00:34:06,049 --> 00:34:10,010
important edit it won't affect the

00:34:07,669 --> 00:34:11,720
parser at all but we don't really know

00:34:10,010 --> 00:34:15,470
that so what we're gonna do is we're

00:34:11,720 --> 00:34:22,129
gonna remap this to r4 because now we're

00:34:15,470 --> 00:34:24,409
in revision 4 and now if I reinvest e we

00:34:22,129 --> 00:34:26,359
have a problem we'll we'll have a sort

00:34:24,409 --> 00:34:29,929
of a problem in a sense we're gonna see

00:34:26,359 --> 00:34:33,260
that indeed this should now be r3 I

00:34:29,929 --> 00:34:33,980
suppose so we see that it was verified

00:34:33,260 --> 00:34:36,379
in r3

00:34:33,980 --> 00:34:38,419
that's not our 4 so it's out of date so

00:34:36,379 --> 00:34:43,609
we have to check we iterate over our

00:34:38,419 --> 00:34:47,810
dependencies and we find that hey this

00:34:43,609 --> 00:34:50,659
actually did change yeah you know like

00:34:47,810 --> 00:34:52,389
since we last checked so now we have a

00:34:50,659 --> 00:34:56,389
problem we're going to re-execute the

00:34:52,389 --> 00:34:57,800
AST method but we're gonna do one last

00:34:56,389 --> 00:35:00,470
twist that I didn't we didn't write

00:34:57,800 --> 00:35:01,940
about in the algorithm yet what we're

00:35:00,470 --> 00:35:03,990
gonna do is we're gonna hold on to the

00:35:01,940 --> 00:35:08,609
old value

00:35:03,990 --> 00:35:12,000
that we had before the old ASD and we're

00:35:08,609 --> 00:35:18,210
gonna get now the new value by

00:35:12,000 --> 00:35:22,200
re-executing and then we can do a check

00:35:18,210 --> 00:35:24,060
and we can say what happened it'd we

00:35:22,200 --> 00:35:25,800
actually even though the inputs changed

00:35:24,060 --> 00:35:27,240
did that result in a change in the

00:35:25,800 --> 00:35:29,609
return value or not

00:35:27,240 --> 00:35:33,510
because if it didn't change the return

00:35:29,609 --> 00:35:35,670
value then nobody who is invoking us

00:35:33,510 --> 00:35:39,089
really cares

00:35:35,670 --> 00:35:40,710
essentially the yeah it's not it's not

00:35:39,089 --> 00:35:43,290
that's assuming that again this

00:35:40,710 --> 00:35:46,380
deterministic nature so what we can do

00:35:43,290 --> 00:35:50,970
is say Oh in that case update verified

00:35:46,380 --> 00:35:52,890
at but leave change that alone and if

00:35:50,970 --> 00:35:55,500
they did actually change then we have to

00:35:52,890 --> 00:35:58,320
make a new record where update both

00:35:55,500 --> 00:36:00,240
verified at and changed after to current

00:35:58,320 --> 00:36:02,430
revisions so in this particular case

00:36:00,240 --> 00:36:04,740
since we didn't change anything that

00:36:02,430 --> 00:36:09,900
will affect the parsed result we

00:36:04,740 --> 00:36:13,400
actually wind up with verified at our

00:36:09,900 --> 00:36:17,430
for but we leave change that as our one

00:36:13,400 --> 00:36:18,869
we kind of back dated our result even

00:36:17,430 --> 00:36:22,170
though we read something which changed

00:36:18,869 --> 00:36:24,000
in our for we can observe that the

00:36:22,170 --> 00:36:28,580
result is the same as it was in our one

00:36:24,000 --> 00:36:31,589
so we can leave it alone um so what is

00:36:28,580 --> 00:36:34,650
this is helped us do if we kind of back

00:36:31,589 --> 00:36:37,500
it like that yeah it doesn't help us do

00:36:34,650 --> 00:36:40,080
anything in this example so far I guess

00:36:37,500 --> 00:36:42,210
we still had to re-execute the ast

00:36:40,080 --> 00:36:46,410
method right so we still did all the

00:36:42,210 --> 00:36:49,920
work however if we go to the next level

00:36:46,410 --> 00:36:53,609
up and we invoke what did I call it hold

00:36:49,920 --> 00:36:55,530
program AST old program AST and let's

00:36:53,609 --> 00:37:00,510
assume that we actually we also invoked

00:36:55,530 --> 00:37:05,910
it you know earlier like here um and we

00:37:00,510 --> 00:37:08,670
got some st actually i'm gonna do is for

00:37:05,910 --> 00:37:11,490
the sake of the historical record i'm

00:37:08,670 --> 00:37:13,109
going to take this and copy it because

00:37:11,490 --> 00:37:15,300
it's kind of a useful artifact just as

00:37:13,109 --> 00:37:17,140
it is and then start injecting the whole

00:37:15,300 --> 00:37:22,779
program ast into this

00:37:17,140 --> 00:37:26,109
pose that so this is what is this like

00:37:22,779 --> 00:37:27,910
second-generation derived queries so

00:37:26,109 --> 00:37:31,089
suppose that we invoked db2 whole

00:37:27,910 --> 00:37:34,599
program ast there before this last edit

00:37:31,089 --> 00:37:39,400
right and we got some some results some

00:37:34,599 --> 00:37:41,710
result W then now when we invoke and

00:37:39,400 --> 00:37:46,569
let's say we didn't invoke DBS he

00:37:41,710 --> 00:37:48,099
directly Roxy okay let's just make this

00:37:46,569 --> 00:37:51,730
a little more realistic we set the

00:37:48,099 --> 00:37:56,710
source text we invoked DB whole program

00:37:51,730 --> 00:37:59,769
ast and this in turn invokes debate like

00:37:56,710 --> 00:38:02,190
internally invokes EB is theta RS and

00:37:59,769 --> 00:38:05,349
beat out of us it also invokes the

00:38:02,190 --> 00:38:07,150
manifest as it happens and all this

00:38:05,349 --> 00:38:09,990
other stuff happens that we said before

00:38:07,150 --> 00:38:15,220
and we'll basically wind up with now

00:38:09,990 --> 00:38:20,200
something like verified at our - I guess

00:38:15,220 --> 00:38:22,509
changed at I think r2 and we have our

00:38:20,200 --> 00:38:24,309
dependencies list which is all the other

00:38:22,509 --> 00:38:27,099
queries so the dependencies list will

00:38:24,309 --> 00:38:30,279
the ast of a dell RS there's to be done

00:38:27,099 --> 00:38:32,920
RS and o ordering is important here

00:38:30,279 --> 00:38:35,470
I don't want it I'll just say that and

00:38:32,920 --> 00:38:36,579
leave it mysteriously unexplained but we

00:38:35,470 --> 00:38:39,609
have to record them in the order that

00:38:36,579 --> 00:38:43,210
they occurred because otherwise that for

00:38:39,609 --> 00:38:49,750
reasons actually an interesting point so

00:38:43,210 --> 00:38:51,670
the the manifest is ers ers we know from

00:38:49,750 --> 00:38:55,839
earlier in the conversation that ast

00:38:51,670 --> 00:38:57,700
also depends on V source text but we

00:38:55,839 --> 00:39:01,630
don't we're not finding all the

00:38:57,700 --> 00:39:04,329
dependencies say hey s need into this

00:39:01,630 --> 00:39:07,029
list right that's right it's a shallow

00:39:04,329 --> 00:39:10,839
list that's sort of a STRs is problem

00:39:07,029 --> 00:39:13,299
what its dependencies were um yeah yeah

00:39:10,839 --> 00:39:15,460
so now we change the source text again

00:39:13,299 --> 00:39:17,859
but all we did was add a space and weary

00:39:15,460 --> 00:39:21,130
invoke all program ast and we have this

00:39:17,859 --> 00:39:24,250
question can we reuse can we reuse the

00:39:21,130 --> 00:39:25,089
results or not and what we're gonna do

00:39:24,250 --> 00:39:29,799
is we're going to go over the

00:39:25,089 --> 00:39:30,820
dependencies list and we'll look so like

00:39:29,799 --> 00:39:33,970
for the man

00:39:30,820 --> 00:39:36,880
first query this has not changed well

00:39:33,970 --> 00:39:38,110
actually we never said it it also seen I

00:39:36,880 --> 00:39:39,820
think that will actually cause salsa to

00:39:38,110 --> 00:39:41,740
panic if you read input you never set

00:39:39,820 --> 00:39:43,480
but let's assume it was in r0 or

00:39:41,740 --> 00:39:49,150
something this the point is it hasn't

00:39:43,480 --> 00:39:51,010
changed since r2 so this is fine right

00:39:49,150 --> 00:39:53,140
this is like exactly the case we saw it

00:39:51,010 --> 00:39:57,490
with source text above but now we get to

00:39:53,140 --> 00:39:59,530
Asda dot RS and we're gonna recursively

00:39:57,490 --> 00:40:02,170
ask it because it's a derived query

00:39:59,530 --> 00:40:07,300
we're gonna sort of ask it have you

00:40:02,170 --> 00:40:09,010
changed since our to write and it's

00:40:07,300 --> 00:40:12,190
going to do the process we just talked

00:40:09,010 --> 00:40:15,370
about it we'll look at look at its own

00:40:12,190 --> 00:40:17,110
inputs that will determine that they

00:40:15,370 --> 00:40:19,660
have to temp and it'll determine that

00:40:17,110 --> 00:40:22,210
they have changed it will re execute and

00:40:19,660 --> 00:40:24,280
produce a new ast it will compare the

00:40:22,210 --> 00:40:28,290
old and new ast and it will see that

00:40:24,280 --> 00:40:30,130
they are the same so it's gonna leave

00:40:28,290 --> 00:40:32,950
therefore it's going to be able to say

00:40:30,130 --> 00:40:36,070
no I have not changed because the

00:40:32,950 --> 00:40:38,170
changed at value is less than our less

00:40:36,070 --> 00:40:41,110
than or equal to R 2 because it was able

00:40:38,170 --> 00:40:42,490
to backdate if it hadn't backdated it

00:40:41,110 --> 00:40:44,410
would have had to say yes i may have

00:40:42,490 --> 00:40:46,060
changed right a more conservative result

00:40:44,410 --> 00:40:48,010
if we didn't have the old value to

00:40:46,060 --> 00:40:51,160
compare against for example and in the

00:40:48,010 --> 00:40:55,660
case of ASD Beadle RS no input has

00:40:51,160 --> 00:40:58,330
changed since r2 because we only set a

00:40:55,660 --> 00:41:02,500
dot RS not B and therefore this is

00:40:58,330 --> 00:41:03,940
trivially still valid trivial I don't

00:41:02,500 --> 00:41:08,620
know but that's the base case kind of

00:41:03,940 --> 00:41:11,100
and so in the end we determine the value

00:41:08,620 --> 00:41:13,270
is still valid and we can just update

00:41:11,100 --> 00:41:15,370
verify that and we never have to re

00:41:13,270 --> 00:41:19,390
execute and that's really nice because

00:41:15,370 --> 00:41:21,310
actually building the whole program ASD

00:41:19,390 --> 00:41:23,020
is perhaps no significantly more

00:41:21,310 --> 00:41:25,150
expensive than just any one piece of it

00:41:23,020 --> 00:41:26,500
I mean so we were able to keep the end

00:41:25,150 --> 00:41:32,580
result that we all that we really care

00:41:26,500 --> 00:41:38,530
about that's that's basically the whole

00:41:32,580 --> 00:41:41,560
algorithm in all of its sides and the

00:41:38,530 --> 00:41:43,360
one thing I would mention is that you

00:41:41,560 --> 00:41:44,620
can tweak this and salsa offers some

00:41:43,360 --> 00:41:46,630
knobs for this I would like to

00:41:44,620 --> 00:41:49,630
more so you could imagine for example

00:41:46,630 --> 00:41:52,600
that some queries might not keep the old

00:41:49,630 --> 00:41:54,340
value in which case they have to be more

00:41:52,600 --> 00:41:56,850
conservative because they don't have

00:41:54,340 --> 00:41:59,500
they can't do this back dating trick and

00:41:56,850 --> 00:42:01,900
similarly some queries might keep just a

00:41:59,500 --> 00:42:04,960
hash of the old value and not the actual

00:42:01,900 --> 00:42:06,520
value itself in which case they can do

00:42:04,960 --> 00:42:09,040
the back dating if you assume it's like

00:42:06,520 --> 00:42:11,860
a cryptographic hash that you trust but

00:42:09,040 --> 00:42:14,410
you can't you can sort of backdate

00:42:11,860 --> 00:42:16,450
yourself but if someone directly invokes

00:42:14,410 --> 00:42:18,610
you you don't actually have a value to

00:42:16,450 --> 00:42:19,840
return so you still have to execute so

00:42:18,610 --> 00:42:23,200
it's kind of these in between points

00:42:19,840 --> 00:42:24,550
where you might be able to save like we

00:42:23,200 --> 00:42:26,860
might be able to reuse the whole program

00:42:24,550 --> 00:42:30,280
AST but if we find if we work we're only

00:42:26,860 --> 00:42:31,690
keeping hashes of the ast then you know

00:42:30,280 --> 00:42:32,920
if we do have two real executes the

00:42:31,690 --> 00:42:34,330
whole program you see we have two

00:42:32,920 --> 00:42:37,360
reparse everything but we might be able

00:42:34,330 --> 00:42:43,330
to reuse a final end result so there's a

00:42:37,360 --> 00:42:47,920
bunch of knobs you can show yeah that's

00:42:43,330 --> 00:42:51,190
that's kind of it questions on this last

00:42:47,920 --> 00:42:54,850
part that sounds that sounds good

00:42:51,190 --> 00:42:57,100
so this is kind of like how we we can

00:42:54,850 --> 00:42:58,990
make our edits and then we can as we

00:42:57,100 --> 00:43:01,330
develop a more sophisticated so the

00:42:58,990 --> 00:43:05,290
dependence views we can be smarter about

00:43:01,330 --> 00:43:07,000
how we're caching whole whole parts of

00:43:05,290 --> 00:43:10,900
that graph or whole parts of that tree

00:43:07,000 --> 00:43:12,970
so we don't rerun a very deep set of

00:43:10,900 --> 00:43:21,370
dependencies and queries on top of

00:43:12,970 --> 00:43:24,870
queries that's right I had a note here

00:43:21,370 --> 00:43:24,870
for for posterity

00:43:29,220 --> 00:43:36,820
yep no are we done maybe were done no so

00:43:34,750 --> 00:43:41,220
I stopped you before you got to another

00:43:36,820 --> 00:43:45,370
thing so we were talking about that

00:43:41,220 --> 00:43:48,790
original example and I said well let's

00:43:45,370 --> 00:43:52,420
do some edits on or into another query

00:43:48,790 --> 00:43:54,580
on say V dot RS and you were about to

00:43:52,420 --> 00:43:57,290
take us into a different direction about

00:43:54,580 --> 00:43:59,710
different kinds of queries I think

00:43:57,290 --> 00:44:02,210
I think I was going to talk about this

00:43:59,710 --> 00:44:05,330
procedure where one of your dependencies

00:44:02,210 --> 00:44:08,900
is itself a derived query and I kind of

00:44:05,330 --> 00:44:11,090
hand waved over it but basically I asked

00:44:08,900 --> 00:44:12,590
this question have you changed there are

00:44:11,090 --> 00:44:15,560
sort of two fundamental things that a

00:44:12,590 --> 00:44:18,080
query has to be able to do it has to be

00:44:15,560 --> 00:44:21,410
able to give you a result that is

00:44:18,080 --> 00:44:23,750
up-to-date and it has to be able to tell

00:44:21,410 --> 00:44:25,820
you if it has changed and they're like

00:44:23,750 --> 00:44:28,910
similar but slightly ever so slightly

00:44:25,820 --> 00:44:30,380
different and they're the reason that

00:44:28,910 --> 00:44:32,720
they're ever so slightly different is

00:44:30,380 --> 00:44:34,640
exactly that you might be able to figure

00:44:32,720 --> 00:44:36,050
out that you have not changed even if

00:44:34,640 --> 00:44:37,670
you don't know what your value is as I

00:44:36,050 --> 00:44:40,240
was kind of saying because you can see

00:44:37,670 --> 00:44:42,980
that none of your inputs have changed

00:44:40,240 --> 00:44:45,050
but so there's actually two kind of

00:44:42,980 --> 00:44:47,780
branches of the code for handling these

00:44:45,050 --> 00:44:51,830
two cases for every query we generate

00:44:47,780 --> 00:44:54,950
two methods and in what in some cases

00:44:51,830 --> 00:44:56,780
like here actually when you ask has it

00:44:54,950 --> 00:44:59,060
changed if it finds that an input has

00:44:56,780 --> 00:45:02,150
changed it will actually invoke the

00:44:59,060 --> 00:45:03,650
other method the we execute method so

00:45:02,150 --> 00:45:07,850
they kind of invoke each other back and

00:45:03,650 --> 00:45:09,320
forth because producing a value has to

00:45:07,850 --> 00:45:10,850
check if the inputs have changed and

00:45:09,320 --> 00:45:16,460
then checking if the inputs have changed

00:45:10,850 --> 00:45:19,880
sometimes has to produce value but yeah

00:45:16,460 --> 00:45:22,910
that's the idea okay so we've been

00:45:19,880 --> 00:45:26,060
talking about using strings as keys and

00:45:22,910 --> 00:45:29,150
strings as values may be helpful to talk

00:45:26,060 --> 00:45:31,970
about different kinds of data types that

00:45:29,150 --> 00:45:33,859
you can put into the database and query

00:45:31,970 --> 00:45:36,500
back out there are some good practices

00:45:33,859 --> 00:45:40,130
there yeah all right got a little time

00:45:36,500 --> 00:45:44,180
we'll go through our list check okay so

00:45:40,130 --> 00:45:46,609
we did this right so what makes a good

00:45:44,180 --> 00:45:50,690
key value type so the short version is

00:45:46,609 --> 00:45:53,180
or I mentioned that we have to do a lot

00:45:50,690 --> 00:45:55,580
of cloning so really vexing strings and

00:45:53,180 --> 00:45:57,020
stuff are possibly not a good choice

00:45:55,580 --> 00:46:01,580
unless you know that they're going to be

00:45:57,020 --> 00:46:05,869
small you what we use for example in

00:46:01,580 --> 00:46:07,820
mark is this seek and text type switch

00:46:05,869 --> 00:46:10,490
this is supposed to be sequence and

00:46:07,820 --> 00:46:13,220
that's supposed to be text

00:46:10,490 --> 00:46:15,470
they are kind of ref counted versions of

00:46:13,220 --> 00:46:17,240
Veck and string and you can do some sub

00:46:15,470 --> 00:46:19,660
slicing they're sort of very simple

00:46:17,240 --> 00:46:22,640
ropes I wouldn't really call them ropes

00:46:19,660 --> 00:46:23,810
I guess a rope would be a potentially a

00:46:22,640 --> 00:46:26,570
good choice or an immutable data

00:46:23,810 --> 00:46:30,470
structure um I think there will probably

00:46:26,570 --> 00:46:33,110
be some experimentation around this to

00:46:30,470 --> 00:46:35,170
figure out the right choices another

00:46:33,110 --> 00:46:38,270
kind of thing you can do is interning

00:46:35,170 --> 00:46:40,340
which we also do in lark which then sort

00:46:38,270 --> 00:46:43,610
of produces integers which are very good

00:46:40,340 --> 00:46:45,140
keys but there's that brings its own

00:46:43,610 --> 00:46:47,600
complications that I don't want to get

00:46:45,140 --> 00:46:50,690
into at the moment like how to how and

00:46:47,600 --> 00:46:52,910
if to garbage collect the internals and

00:46:50,690 --> 00:46:56,000
so on but just for just for people

00:46:52,910 --> 00:46:57,800
watching so have you did you explain and

00:46:56,000 --> 00:47:00,800
turning on the other video by chance I

00:46:57,800 --> 00:47:03,230
did not we can just gonna do it quick

00:47:00,800 --> 00:47:05,630
what is what is interning and training

00:47:03,230 --> 00:47:09,500
who's been very that's sound scary yeah

00:47:05,630 --> 00:47:11,390
so interning is taking a risk it's

00:47:09,500 --> 00:47:14,750
basically when you have a canonical pool

00:47:11,390 --> 00:47:16,640
like a hashmap um so for a given value

00:47:14,750 --> 00:47:20,210
you store it in the map and you

00:47:16,640 --> 00:47:23,240
associate it with some integer and then

00:47:20,210 --> 00:47:25,130
you can just pass the integer around and

00:47:23,240 --> 00:47:26,390
that's a very cheap thing to pass around

00:47:25,130 --> 00:47:29,810
it's kind of like a pointer in its own

00:47:26,390 --> 00:47:31,640
way but when you later want to read what

00:47:29,810 --> 00:47:33,440
the value is you can use the integer to

00:47:31,640 --> 00:47:35,900
get it out from the from the hash map

00:47:33,440 --> 00:47:38,540
and a particularly good hash map for

00:47:35,900 --> 00:47:40,010
this is the index map trait which is

00:47:38,540 --> 00:47:41,840
sort of a combination of a hash map and

00:47:40,010 --> 00:47:44,300
a vector so it can give you an index

00:47:41,840 --> 00:47:47,480
back out that you can then use to index

00:47:44,300 --> 00:47:49,840
directly in that's one version of

00:47:47,480 --> 00:47:52,850
interning anyway so we take a

00:47:49,840 --> 00:47:55,070
complicated structure is stick it say

00:47:52,850 --> 00:47:57,950
and the database or into uh and the

00:47:55,070 --> 00:47:59,840
index map and then we get out just an

00:47:57,950 --> 00:48:03,050
integer value and we can pass around the

00:47:59,840 --> 00:48:05,359
integer value and we can reference we

00:48:03,050 --> 00:48:07,580
can reference this larger structure just

00:48:05,359 --> 00:48:09,980
by this vintage your values and we only

00:48:07,580 --> 00:48:10,580
need to pull it that big structure back

00:48:09,980 --> 00:48:12,770
out again

00:48:10,580 --> 00:48:14,780
when we actually need to have it in our

00:48:12,770 --> 00:48:16,369
hands otherwise we can just kind of

00:48:14,780 --> 00:48:19,700
refer to it by this integer

00:48:16,369 --> 00:48:22,310
most of the time the flesh is fine yeah

00:48:19,700 --> 00:48:23,780
and that actually bleeds a little bit

00:48:22,310 --> 00:48:27,050
into the strategies for reuse

00:48:23,780 --> 00:48:30,380
I think merits a bigger discussion but I

00:48:27,050 --> 00:48:31,910
would just say that in general when

00:48:30,380 --> 00:48:34,850
you're setting up these sorts of queries

00:48:31,910 --> 00:48:37,010
like we've shown here you you often will

00:48:34,850 --> 00:48:39,440
want to introduce some kind of

00:48:37,010 --> 00:48:43,160
indirection like let's say you have a

00:48:39,440 --> 00:48:45,530
module in your compiler at least it has

00:48:43,160 --> 00:48:48,290
like a list of items in it you could

00:48:45,530 --> 00:48:50,270
make a module you could make a data

00:48:48,290 --> 00:48:55,280
structure that's like let's call it the

00:48:50,270 --> 00:48:58,250
enum AST you might have the module might

00:48:55,280 --> 00:49:00,110
have the vector of ast nodes directly

00:48:58,250 --> 00:49:01,430
embedded within it but you might be

00:49:00,110 --> 00:49:05,270
better off if you can

00:49:01,430 --> 00:49:08,930
finding a way to make the module have a

00:49:05,270 --> 00:49:12,350
vector of ID's and having a separate

00:49:08,930 --> 00:49:17,750
query that's like given an ID give me

00:49:12,350 --> 00:49:20,660
the ast and the reason that you would

00:49:17,750 --> 00:49:24,200
want to do that is that maybe there are

00:49:20,660 --> 00:49:26,180
changes inside the ast but like the the

00:49:24,200 --> 00:49:27,980
list of ID's doesn't change essentially

00:49:26,180 --> 00:49:29,540
so the module level looks the same even

00:49:27,980 --> 00:49:30,860
if some of its contents changed and that

00:49:29,540 --> 00:49:34,550
way you can get finer-grained reuse

00:49:30,860 --> 00:49:36,680
because only those derived queries that

00:49:34,550 --> 00:49:40,340
actually had to access the ast for a

00:49:36,680 --> 00:49:41,840
given ID care if the ast changed so

00:49:40,340 --> 00:49:43,760
often with recursive structures you'll

00:49:41,840 --> 00:49:46,100
want to set up a set it up this way it's

00:49:43,760 --> 00:49:52,490
awesome so in the database you might

00:49:46,100 --> 00:49:55,520
have like set the ID to an updated ast

00:49:52,490 --> 00:49:59,030
and ID doesn't change but the let's say

00:49:55,520 --> 00:50:01,820
you had new parts of the structure

00:49:59,030 --> 00:50:04,940
behind that the new ASP has has some

00:50:01,820 --> 00:50:07,640
more data in it right people keep using

00:50:04,940 --> 00:50:08,240
that that ID and everything that uses

00:50:07,640 --> 00:50:10,730
that ID

00:50:08,240 --> 00:50:14,980
none of those queries become invalidated

00:50:10,730 --> 00:50:17,240
because that ID doesn't change right so

00:50:14,980 --> 00:50:19,160
so I would like to make this a concrete

00:50:17,240 --> 00:50:21,440
if we assume that the ID is some kind of

00:50:19,160 --> 00:50:23,870
path let's say and it could literally be

00:50:21,440 --> 00:50:28,340
a maybe even an arch path or something

00:50:23,870 --> 00:50:30,880
then then this the value for foo the

00:50:28,340 --> 00:50:36,690
module foo would be like a vector of

00:50:30,880 --> 00:50:39,809
this path foo bar right and the value

00:50:36,690 --> 00:50:41,460
for a foo bar would be the fields and so

00:50:39,809 --> 00:50:42,720
now if they changed if you change the

00:50:41,460 --> 00:50:53,150
fields a bar you don't actually change

00:50:42,720 --> 00:50:53,150
the value for a foo at all so yeah I I

00:50:54,289 --> 00:50:58,319
this stuff can get a little tricky and

00:50:56,369 --> 00:50:59,549
complicated that's why I think it's this

00:50:58,319 --> 00:51:02,880
is the idea of what you want but

00:50:59,549 --> 00:51:05,609
actually realizing like this so I mean

00:51:02,880 --> 00:51:09,900
and it's worth saying - I mean some of

00:51:05,609 --> 00:51:11,520
this is that salsas so new you know

00:51:09,900 --> 00:51:13,500
we're still learning how to use it to

00:51:11,520 --> 00:51:15,780
its fullest potential some of the tricks

00:51:13,500 --> 00:51:18,359
that we're trying out may not be good

00:51:15,780 --> 00:51:20,010
later and some will learn new tricks as

00:51:18,359 --> 00:51:22,500
we go this is just kind of like a

00:51:20,010 --> 00:51:26,430
snapshot of where we're at yeah look

00:51:22,500 --> 00:51:28,799
that's right I think the only thing in

00:51:26,430 --> 00:51:31,349
this list that I feel like might we

00:51:28,799 --> 00:51:33,869
could talk about real briefly may be

00:51:31,349 --> 00:51:36,780
cancellation so we talked about parallel

00:51:33,869 --> 00:51:39,359
patterns already actually but yeah so

00:51:36,780 --> 00:51:40,559
the on-demand thinking I think it's good

00:51:39,359 --> 00:51:42,990
to drill into that a little bit

00:51:40,559 --> 00:51:45,109
especially for people coming to salsa

00:51:42,990 --> 00:51:48,329
and thinking about salsa as a user

00:51:45,109 --> 00:51:51,539
knowing that you should think about your

00:51:48,329 --> 00:51:53,490
query in these stages just like Nico was

00:51:51,539 --> 00:51:55,740
showing earlier where you have a query

00:51:53,490 --> 00:51:57,510
and that query calls other queries that

00:51:55,740 --> 00:52:02,369
allows you to kind of cache things and

00:51:57,510 --> 00:52:04,650
do them and steps to think about rather

00:52:02,369 --> 00:52:08,190
than pulling large bits of data of the

00:52:04,650 --> 00:52:10,319
database for one shot to have it in that

00:52:08,190 --> 00:52:12,630
stage allows you to like there's my key

00:52:10,319 --> 00:52:14,400
staying on demand thinking like pull on

00:52:12,630 --> 00:52:19,650
the data up to the point that you need

00:52:14,400 --> 00:52:21,359
and then stop yeah so I think one of the

00:52:19,650 --> 00:52:23,760
challenges that I found with the

00:52:21,359 --> 00:52:25,799
on-demand stuff is that at least saying

00:52:23,760 --> 00:52:29,700
compilers you often have something where

00:52:25,799 --> 00:52:30,839
it's like in order to type check

00:52:29,700 --> 00:52:34,829
something you there's a certain amount

00:52:30,839 --> 00:52:36,539
of context that you need like maybe I I

00:52:34,829 --> 00:52:40,470
can I could for example pull out an

00:52:36,539 --> 00:52:42,510
expression you know isolation like I

00:52:40,470 --> 00:52:44,039
have some function like this and they

00:52:42,510 --> 00:52:47,339
have let x equals 22 or something

00:52:44,039 --> 00:52:48,690
something here I could I could I could

00:52:47,339 --> 00:52:49,980
maybe pull out this expression in

00:52:48,690 --> 00:52:50,560
isolation but I can't really do anything

00:52:49,980 --> 00:52:52,870
with

00:52:50,560 --> 00:52:54,970
until I know what the type of X is and

00:52:52,870 --> 00:52:57,880
that's determined by these other

00:52:54,970 --> 00:53:00,610
statements so what what you often end up

00:52:57,880 --> 00:53:02,140
with is this is this the structure of

00:53:00,610 --> 00:53:04,720
queries where you start out very local

00:53:02,140 --> 00:53:07,540
and you kind of branch out to get your

00:53:04,720 --> 00:53:09,880
context you'll have some outer queries

00:53:07,540 --> 00:53:12,370
that they will parse the whole file

00:53:09,880 --> 00:53:13,810
maybe and give you like the set of names

00:53:12,370 --> 00:53:15,100
that are defined or something they try

00:53:13,810 --> 00:53:17,080
to do the minimal amount of work there

00:53:15,100 --> 00:53:19,000
very shallow kind of like we show here

00:53:17,080 --> 00:53:20,770
they just leave pointers for how to

00:53:19,000 --> 00:53:22,630
continue if you care about the details

00:53:20,770 --> 00:53:24,700
of this thing enough that you can then

00:53:22,630 --> 00:53:27,940
then you can drill in on just the parts

00:53:24,700 --> 00:53:30,250
that you actually need so maybe you

00:53:27,940 --> 00:53:32,020
would find out oh the name X I have a

00:53:30,250 --> 00:53:35,200
map that tells me where it's defined I

00:53:32,020 --> 00:53:37,000
can find its initializer and therefore

00:53:35,200 --> 00:53:38,800
I'm just dependent on that but if there

00:53:37,000 --> 00:53:40,840
are other statements in here like a

00:53:38,800 --> 00:53:43,330
print 'ln I never wind up asking for the

00:53:40,840 --> 00:53:45,460
details about this and so it then I'm

00:53:43,330 --> 00:53:51,400
insulated from changes that might affect

00:53:45,460 --> 00:53:54,610
it that's the idea but the practice like

00:53:51,400 --> 00:53:56,140
I said I think that's really getting

00:53:54,610 --> 00:53:57,790
into that and showing a good examples of

00:53:56,140 --> 00:54:00,910
it would would be a good topic for a

00:53:57,790 --> 00:54:03,880
future and there's bit of an art to it

00:54:00,910 --> 00:54:06,130
breaking up your problem so that it's in

00:54:03,880 --> 00:54:09,150
these really good stages for your from

00:54:06,130 --> 00:54:11,890
what makes sense for your project right

00:54:09,150 --> 00:54:13,240
one thing I want to add or I want to

00:54:11,890 --> 00:54:18,130
come because it's directly relevant to

00:54:13,240 --> 00:54:19,540
what we said is that the one of the nice

00:54:18,130 --> 00:54:21,760
things that back the back dating

00:54:19,540 --> 00:54:24,700
technique lets you do basically is be a

00:54:21,760 --> 00:54:26,680
bit sloppy here so you can have we

00:54:24,700 --> 00:54:30,220
showed an example where we had the

00:54:26,680 --> 00:54:32,200
source file here and it's a very crude

00:54:30,220 --> 00:54:33,880
very imprecise right it doesn't like

00:54:32,200 --> 00:54:35,470
break the source text into chunks or

00:54:33,880 --> 00:54:37,390
anything so every edit is gonna change

00:54:35,470 --> 00:54:39,790
this key which means every edit is going

00:54:37,390 --> 00:54:41,500
to rebuild the ast but that's maybe not

00:54:39,790 --> 00:54:43,540
so expensive right and then we find out

00:54:41,500 --> 00:54:46,150
that in fact later parts of the program

00:54:43,540 --> 00:54:47,980
are insulated by this the fact that the

00:54:46,150 --> 00:54:49,780
ASC doesn't ASC doesn't actually change

00:54:47,980 --> 00:54:53,680
on every edit and you might have even

00:54:49,780 --> 00:54:57,490
more finer grained queries like item

00:54:53,680 --> 00:54:59,560
names which are which reads the ast it

00:54:57,490 --> 00:55:01,810
produces a list of names of items in the

00:54:59,560 --> 00:55:04,270
list right or something and now the key

00:55:01,810 --> 00:55:06,490
point is even if the ast changes

00:55:04,270 --> 00:55:08,980
the names of the of the items to find

00:55:06,490 --> 00:55:10,600
probably for a lot of edits are not so

00:55:08,980 --> 00:55:12,280
adding a field to a struct won't affect

00:55:10,600 --> 00:55:13,750
the structure name for example maybe

00:55:12,280 --> 00:55:16,120
items it's not a good choice let's call

00:55:13,750 --> 00:55:19,530
it type names ISM so basically defining

00:55:16,120 --> 00:55:22,120
these levels of information lets you

00:55:19,530 --> 00:55:24,340
make use of backdating so that even

00:55:22,120 --> 00:55:25,750
though you will execute up to a certain

00:55:24,340 --> 00:55:36,130
point you won't get to the expensive

00:55:25,750 --> 00:55:40,210
stuff all right I'm ready to stop how

00:55:36,130 --> 00:55:43,510
about you our listeners may be ready to

00:55:40,210 --> 00:55:46,660
stuff too I think this is good I think

00:55:43,510 --> 00:55:50,650
there this is from a user's perspective

00:55:46,660 --> 00:55:55,420
this is a great review of how how salsa

00:55:50,650 --> 00:55:57,400
is working with your project fund equal

00:55:55,420 --> 00:55:58,960
going to talk about like how salsa

00:55:57,400 --> 00:56:00,700
itself works maybe we can do that at a

00:55:58,960 --> 00:56:02,230
separate video oh yeah I think we should

00:56:00,700 --> 00:56:06,430
wait on that but I like this format

00:56:02,230 --> 00:56:07,360
we'll do more of these in true alright

00:56:06,430 --> 00:56:11,460
thanks Jonathan

00:56:07,360 --> 00:56:11,460

YouTube URL: https://www.youtube.com/watch?v=i_IhACacPRY


