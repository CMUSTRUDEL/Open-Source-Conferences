Title: Representing types in rustc
Publication date: 2019-04-26
Playlist: rustc lecture series
Description: 
	This discussion covers how types are represented in rustc. It discusses the `Ty` type, generics and substitution, and type folding.

The Dropbox paper document that is being shared in the video can be found here:

https://paper.dropbox.com/doc/Ty-lecture--Ab8REO0WfNUvsZSb3L~DliFvAg-8hOUpAEhOvoBQC5EYXKJM
Captions: 
	00:00:01,820 --> 00:00:15,330
okay yes okay so hi everybody thanks for

00:00:11,429 --> 00:00:19,560
showing up so yeah I wanted to talk

00:00:15,330 --> 00:00:24,390
today about the the way that rusty

00:00:19,560 --> 00:00:27,660
represents types and I'm curious for

00:00:24,390 --> 00:00:29,910
those of you who are here have any of

00:00:27,660 --> 00:00:31,560
you written code and rusty before the

00:00:29,910 --> 00:00:34,020
used types

00:00:31,560 --> 00:00:39,420
I know Santiago you did a little bit at

00:00:34,020 --> 00:00:43,160
least you may not know you did are we

00:00:39,420 --> 00:00:43,160
all starting from scratch okay awesome

00:00:43,219 --> 00:00:48,239
so I'm probably through in terms that

00:00:46,020 --> 00:00:52,079
you don't know we'll come across them

00:00:48,239 --> 00:00:55,949
feel free to stop me um let's start with

00:00:52,079 --> 00:00:58,620
the kind of basic thing when I talk

00:00:55,949 --> 00:01:02,250
about how rusty represents types there's

00:00:58,620 --> 00:01:05,129
actually a lot of types neck planner and

00:01:02,250 --> 00:01:07,200
if you just look I'm talking sort of

00:01:05,129 --> 00:01:09,450
around this this type we call T why I

00:01:07,200 --> 00:01:12,869
mean you made it short because you know

00:01:09,450 --> 00:01:16,470
we type it a lot and if you just look

00:01:12,869 --> 00:01:18,600
for like things name T Y and the

00:01:16,470 --> 00:01:20,009
compiler some of these are methods but

00:01:18,600 --> 00:01:24,840
yeah you'll already see there's there's

00:01:20,009 --> 00:01:28,080
actually quite a few so the one I'm

00:01:24,840 --> 00:01:31,590
specifically talking about is rusty Ty

00:01:28,080 --> 00:01:37,710
Ty and not here tidy and let me explain

00:01:31,590 --> 00:01:39,509
the difference so the here first of all

00:01:37,710 --> 00:01:43,250
the here in rust is sort of our

00:01:39,509 --> 00:01:46,140
high-level IR it's kind of our ast

00:01:43,250 --> 00:01:48,360
there's a couple stages but it basically

00:01:46,140 --> 00:01:52,460
represents the syntax that the user

00:01:48,360 --> 00:01:55,649
wrote ready so the result of parsing and

00:01:52,460 --> 00:01:59,040
after some amount of G sugaring and so

00:01:55,649 --> 00:02:02,009
on and it has a representation of types

00:01:59,040 --> 00:02:04,380
but that really represents the syntax

00:02:02,009 --> 00:02:06,439
that the user wrote so exactly what did

00:02:04,380 --> 00:02:09,000
they write to represent that type and

00:02:06,439 --> 00:02:13,740
one way I think they try to explain the

00:02:09,000 --> 00:02:15,930
difference of between that

00:02:13,740 --> 00:02:18,330
and the rusty ties that we're gonna

00:02:15,930 --> 00:02:21,420
focus on is looking at like look at this

00:02:18,330 --> 00:02:25,230
function for example here I have this

00:02:21,420 --> 00:02:27,000
type u 32 and it appears twice right but

00:02:25,230 --> 00:02:29,220
we know that that's in some sense the

00:02:27,000 --> 00:02:30,720
same type it takes an argument and

00:02:29,220 --> 00:02:33,720
returns an argument of the same type but

00:02:30,720 --> 00:02:35,580
from the point of view of the here there

00:02:33,720 --> 00:02:37,620
would be two distinct type instances

00:02:35,580 --> 00:02:39,480
because these are occurring in two

00:02:37,620 --> 00:02:41,430
different places in the program they

00:02:39,480 --> 00:02:44,490
have two different spans so like two

00:02:41,430 --> 00:02:45,900
different locations and so on right and

00:02:44,490 --> 00:02:50,460
there might be information that's left

00:02:45,900 --> 00:02:53,100
out like this type ampersand u 32

00:02:50,460 --> 00:02:55,350
reference to u 32 it's kind of

00:02:53,100 --> 00:02:57,990
incomplete right in the full rust

00:02:55,350 --> 00:03:00,780
compiler there's actually a lifetime

00:02:57,990 --> 00:03:03,200
here or a region as we're often calling

00:03:00,780 --> 00:03:05,580
the compiler but we didn't write it and

00:03:03,200 --> 00:03:10,730
there's some sort of defaulting rules

00:03:05,580 --> 00:03:14,070
right like if I had this signature

00:03:10,730 --> 00:03:16,850
there's elision rules that would that

00:03:14,070 --> 00:03:21,090
would kind of insert the equivalent of

00:03:16,850 --> 00:03:23,520
of this right and in the here level

00:03:21,090 --> 00:03:27,000
these things are not yet all spelled out

00:03:23,520 --> 00:03:30,030
but in the tie level it's complete and

00:03:27,000 --> 00:03:32,370
moreover for something like u 32 we'll

00:03:30,030 --> 00:03:33,930
have exactly one type because it doesn't

00:03:32,370 --> 00:03:35,040
it does not connect it to a specific

00:03:33,930 --> 00:03:37,350
spot in the program it's more the

00:03:35,040 --> 00:03:42,960
abstract notion of the type itself right

00:03:37,350 --> 00:03:44,670
um so so this is the title saying that

00:03:42,960 --> 00:03:47,880
it describes the semantics of the type

00:03:44,670 --> 00:03:49,560
in this sense and you can actually you

00:03:47,880 --> 00:03:52,730
know click on it and see how it's

00:03:49,560 --> 00:03:54,780
defined um it's actually a type alias

00:03:52,730 --> 00:03:56,670
and we're gonna get into this lifetime

00:03:54,780 --> 00:04:00,180
but for now I want to just sort of

00:03:56,670 --> 00:04:04,140
ignore it and you see that a type is a

00:04:00,180 --> 00:04:06,560
reference to a structure creatively

00:04:04,140 --> 00:04:10,500
called ty s I don't know I guess then

00:04:06,560 --> 00:04:12,240
it's for type structure and this this

00:04:10,500 --> 00:04:13,680
type structure is where the actual data

00:04:12,240 --> 00:04:16,650
is right so basically we're passing

00:04:13,680 --> 00:04:18,989
around pointers to we're gonna see that

00:04:16,650 --> 00:04:20,549
these get interned like allocated in a

00:04:18,989 --> 00:04:22,350
special pool I'll come back to that

00:04:20,549 --> 00:04:24,240
we're passing around references or

00:04:22,350 --> 00:04:27,090
pointers to these strokes and this is

00:04:24,240 --> 00:04:31,050
the actual fields of the type

00:04:27,090 --> 00:04:32,970
there's three things here the one that

00:04:31,050 --> 00:04:36,150
matters most and that we'll spend most

00:04:32,970 --> 00:04:40,320
of our time on is the sty for structured

00:04:36,150 --> 00:04:42,120
type I guess and the other two the flags

00:04:40,320 --> 00:04:43,800
and the outer exclusive binder I don't

00:04:42,120 --> 00:04:45,570
know if we'll talk about those but they

00:04:43,800 --> 00:04:48,330
basically summarize they're kind of

00:04:45,570 --> 00:04:50,130
convenient hacks for efficiency but

00:04:48,330 --> 00:04:52,470
summarize information about the type

00:04:50,130 --> 00:04:54,180
that we might like to know so I might

00:04:52,470 --> 00:04:59,340
come back to it but most of the time

00:04:54,180 --> 00:05:03,320
when you work with a type in rust you

00:04:59,340 --> 00:05:09,990
might have a a variable or a function

00:05:03,320 --> 00:05:11,430
this most of the time you will little

00:05:09,990 --> 00:05:15,169
there writing code sort of like this

00:05:11,430 --> 00:05:18,120
that extracts out this sty field and

00:05:15,169 --> 00:05:20,910
matches on it and why do I say match

00:05:18,120 --> 00:05:25,680
because what this sty a field stores is

00:05:20,910 --> 00:05:28,430
something called a type kind and this is

00:05:25,680 --> 00:05:30,990
kind if you're familiar with like

00:05:28,430 --> 00:05:33,180
Haskell terminology and their functional

00:05:30,990 --> 00:05:34,770
programming that that's sort of not

00:05:33,180 --> 00:05:37,320
nomenclature this is not that sort of

00:05:34,770 --> 00:05:38,910
kind this is just the kinds of types

00:05:37,320 --> 00:05:41,280
that we have that's what it means like

00:05:38,910 --> 00:05:42,479
the different sort sorts so it's all the

00:05:41,280 --> 00:05:45,360
different variants there could be

00:05:42,479 --> 00:05:46,710
boolean 's characters you know this

00:05:45,360 --> 00:05:50,099
should look kind of familiar too these

00:05:46,710 --> 00:05:52,800
are like the rust type system written

00:05:50,099 --> 00:05:54,450
out some of them might be a little

00:05:52,800 --> 00:05:56,760
surprising right so boolean is character

00:05:54,450 --> 00:05:59,130
is integers if you go ahead and click on

00:05:56,760 --> 00:06:02,389
int i you'll see that it's like all the

00:05:59,130 --> 00:06:05,160
different things that you might expect

00:06:02,389 --> 00:06:09,750
those are pretty obvious but some of

00:06:05,160 --> 00:06:12,240
them are less obvious so an ADT that

00:06:09,750 --> 00:06:16,200
stands for abstracted or algebraic data

00:06:12,240 --> 00:06:20,160
types re oh and you can see that it

00:06:16,200 --> 00:06:22,560
basically means a struct an enum or a

00:06:20,160 --> 00:06:24,210
Union all of those are represented as

00:06:22,560 --> 00:06:27,479
the same variant for us because they're

00:06:24,210 --> 00:06:30,900
kind of all variations on a theme it's

00:06:27,479 --> 00:06:32,970
basically a user defined type in some

00:06:30,900 --> 00:06:34,800
sense and we'll come back to this the

00:06:32,970 --> 00:06:36,930
details of what's in here but but this

00:06:34,800 --> 00:06:39,150
would represent a reference to a struck

00:06:36,930 --> 00:06:41,530
like back of you 32 or something that

00:06:39,150 --> 00:06:45,610
would be an ADT

00:06:41,530 --> 00:06:49,960
so for in East corresponds to these

00:06:45,610 --> 00:06:52,090
external that are like experimental stir

00:06:49,960 --> 00:06:53,620
is the type stirred so when you have

00:06:52,090 --> 00:06:57,430
ampersand stir for example this is the

00:06:53,620 --> 00:06:59,469
stir of that an array is this you kind

00:06:57,430 --> 00:07:00,969
of see that each case of the reston like

00:06:59,469 --> 00:07:03,990
where the rest syntax has a type there's

00:07:00,969 --> 00:07:06,879
a corresponding very into raw pointers

00:07:03,990 --> 00:07:10,990
one that's kind of interesting is ref

00:07:06,879 --> 00:07:13,080
these stand for safe references and it

00:07:10,990 --> 00:07:17,080
might be episode mute or neighbor sanity

00:07:13,080 --> 00:07:19,870
and they have some parts to them this is

00:07:17,080 --> 00:07:22,810
the type of the reference references

00:07:19,870 --> 00:07:25,330
this is the lifetime or region we'll

00:07:22,810 --> 00:07:28,060
come back to that and immutability okay

00:07:25,330 --> 00:07:29,800
i'm gonna stop going down here because

00:07:28,060 --> 00:07:32,050
it's not that important but you get the

00:07:29,800 --> 00:07:35,409
idea that you have all these variants

00:07:32,050 --> 00:07:38,020
that correspond to the different types

00:07:35,409 --> 00:07:40,349
in the rest language any questions on

00:07:38,020 --> 00:07:40,349
that so far

00:07:42,539 --> 00:07:49,629
okay so there's a whole family of like

00:07:46,560 --> 00:07:52,449
related types that are in my mind groups

00:07:49,629 --> 00:07:54,430
together that kind of represent

00:07:52,449 --> 00:07:56,199
different parts of the semantics of the

00:07:54,430 --> 00:07:58,919
type and we kind of saw that already

00:07:56,199 --> 00:08:02,139
there's stuff like you and tie in in tie

00:07:58,919 --> 00:08:07,240
but ADT death we'll come back to that

00:08:02,139 --> 00:08:08,860
one sucks tref tie const or region so

00:08:07,240 --> 00:08:11,819
we'll see some of these and i kind of

00:08:08,860 --> 00:08:13,960
plan to talk a little bit about them but

00:08:11,819 --> 00:08:18,839
but they're all kind of parts of the

00:08:13,960 --> 00:08:22,659
type in the end of the day um so i

00:08:18,839 --> 00:08:26,680
mentioned this when we were talking

00:08:22,659 --> 00:08:31,870
about the definition of tie i said there

00:08:26,680 --> 00:08:34,209
was a lifetime TCX we'll get into more

00:08:31,870 --> 00:08:35,680
detail about what that is but i just

00:08:34,209 --> 00:08:37,899
want to talk about where these types

00:08:35,680 --> 00:08:42,459
live and how they're handled right for a

00:08:37,899 --> 00:08:46,300
little bit so types in Russy are

00:08:42,459 --> 00:08:47,560
allocated from a global memory pool if

00:08:46,300 --> 00:08:50,350
you're if you're familiar with the term

00:08:47,560 --> 00:08:51,760
arena we use an arena and what it means

00:08:50,350 --> 00:08:53,210
is basically at the beginning of

00:08:51,760 --> 00:08:57,110
compilation

00:08:53,210 --> 00:09:00,170
we make a buffer and each time we need

00:08:57,110 --> 00:09:01,640
to allocate a type we kind of use some

00:09:00,170 --> 00:09:06,050
of that memory buffer and if we run out

00:09:01,640 --> 00:09:08,090
of space we get another one and the

00:09:06,050 --> 00:09:10,550
lifetime of that buffer that's what this

00:09:08,090 --> 00:09:12,050
TC X is talking about so the idea is

00:09:10,550 --> 00:09:13,580
that when we finish copulation we're

00:09:12,050 --> 00:09:17,480
gonna take that buffer and just free the

00:09:13,580 --> 00:09:19,190
whole thing really fast and therefore

00:09:17,480 --> 00:09:20,980
any references any types that we

00:09:19,190 --> 00:09:25,760
allocated from that memory buffer are

00:09:20,980 --> 00:09:27,020
invalid so they're they're tied to the

00:09:25,760 --> 00:09:29,680
lifetime of that buffer and that's what

00:09:27,020 --> 00:09:33,230
this TC X is is basically telling us um

00:09:29,680 --> 00:09:37,190
so that's called well that's called a

00:09:33,230 --> 00:09:38,960
rena allocation and then we further you

00:09:37,190 --> 00:09:42,110
look canonicalization step so the idea

00:09:38,960 --> 00:09:44,660
is that we don't just each time you want

00:09:42,110 --> 00:09:46,460
to construct the type we don't just

00:09:44,660 --> 00:09:47,330
naively allocate from the buffer but we

00:09:46,460 --> 00:09:49,820
look and see

00:09:47,330 --> 00:09:51,680
have you already constructed this type

00:09:49,820 --> 00:09:53,960
once before and if so we'll give you the

00:09:51,680 --> 00:09:55,820
same pointer that that you had before

00:09:53,960 --> 00:09:57,320
and other times otherwise we'll make a

00:09:55,820 --> 00:09:59,300
fresh pointer and so that we're

00:09:57,320 --> 00:10:01,460
interning them and that means that

00:09:59,300 --> 00:10:04,100
actually if you want to know if two

00:10:01,460 --> 00:10:06,530
types are exactly the same and they're

00:10:04,100 --> 00:10:09,410
allocated from this arena all you have

00:10:06,530 --> 00:10:11,390
to do is compare the pointers which is

00:10:09,410 --> 00:10:15,290
efficient right and you can actually see

00:10:11,390 --> 00:10:18,110
that so the tie s struct it represents

00:10:15,290 --> 00:10:22,340
types is only ever allocated we never

00:10:18,110 --> 00:10:27,020
can set up so that you never construct

00:10:22,340 --> 00:10:28,550
them just on the stack right you always

00:10:27,020 --> 00:10:30,590
allocate them from this arena and you

00:10:28,550 --> 00:10:32,660
always intern them so that they're

00:10:30,590 --> 00:10:35,870
unique and that means that we can define

00:10:32,660 --> 00:10:39,880
like partial EQ this compare the

00:10:35,870 --> 00:10:39,880
pointers of two of them

00:10:40,000 --> 00:10:47,810
similarly the hash just hashes the

00:10:42,350 --> 00:10:49,550
pointer so I'm not gonna at this moment

00:10:47,810 --> 00:10:53,330
dive in because it doesn't matter that

00:10:49,550 --> 00:10:56,540
much what I'll probably come back to how

00:10:53,330 --> 00:10:58,280
this arena stuff is set up but suffice

00:10:56,540 --> 00:11:00,740
to say that there is a struct called

00:10:58,280 --> 00:11:03,320
context in Turners and it has a lot of

00:11:00,740 --> 00:11:05,090
data right and one of the things it has

00:11:03,320 --> 00:11:06,920
is in arena this is that buffer I was

00:11:05,090 --> 00:11:08,660
talking about

00:11:06,920 --> 00:11:10,579
I'll get things from the buffer and that

00:11:08,660 --> 00:11:14,810
has a bunch of hash maps and these are

00:11:10,579 --> 00:11:17,389
how we make things unique right and we

00:11:14,810 --> 00:11:21,160
want to in turn a title for example we

00:11:17,389 --> 00:11:24,800
look in the hash map to see is there

00:11:21,160 --> 00:11:26,149
already you have some tie s that

00:11:24,800 --> 00:11:28,490
represents the type and you look in the

00:11:26,149 --> 00:11:30,620
hash map to sees do we already have that

00:11:28,490 --> 00:11:36,170
a pointer to that exact is and if so

00:11:30,620 --> 00:11:38,649
we're going to return it any questions

00:11:36,170 --> 00:11:38,649
on that so far

00:11:39,339 --> 00:11:44,510
so the existing documentation mentioned

00:11:42,050 --> 00:11:48,260
that there are two types of arenas the

00:11:44,510 --> 00:11:53,240
global and innermost and that the

00:11:48,260 --> 00:11:55,820
innermost is used or like local when

00:11:53,240 --> 00:11:57,410
you're inferring like a specific type

00:11:55,820 --> 00:11:58,610
I assume that the global arena is

00:11:57,410 --> 00:12:03,110
allocated at the beginning of

00:11:58,610 --> 00:12:06,589
compilation and the local arena is done

00:12:03,110 --> 00:12:08,180
for each type difference yeah I was

00:12:06,589 --> 00:12:09,889
lighting that now it's gonna come to

00:12:08,180 --> 00:12:13,760
layer but might as well do it now it's a

00:12:09,889 --> 00:12:15,290
good question so I met I talked about as

00:12:13,760 --> 00:12:18,529
if there was exactly one arena but

00:12:15,290 --> 00:12:21,320
actually we have two we have many arenas

00:12:18,529 --> 00:12:23,510
during compilation then as occupants

00:12:21,320 --> 00:12:26,560
pointed so there is one global arena

00:12:23,510 --> 00:12:29,240
that kind of lives for the whole

00:12:26,560 --> 00:12:31,790
compilation and then when we're type

00:12:29,240 --> 00:12:36,230
checking or doing other things on a

00:12:31,790 --> 00:12:37,670
specific function you often make a lot

00:12:36,230 --> 00:12:39,320
of throwaway types we'll see you later

00:12:37,670 --> 00:12:40,940
what I mean but you end up with a lot of

00:12:39,320 --> 00:12:45,019
temporary types during type inference

00:12:40,940 --> 00:12:47,510
that are not really useful outside of

00:12:45,019 --> 00:12:50,870
that specific function necessarily and

00:12:47,510 --> 00:12:55,250
so what we do is we create a temporary a

00:12:50,870 --> 00:12:56,870
local arena here and those types that

00:12:55,250 --> 00:13:01,760
are specific to type checking get

00:12:56,870 --> 00:13:04,339
allocated in here and types that are

00:13:01,760 --> 00:13:07,490
specific types that are kind of global

00:13:04,339 --> 00:13:08,870
Oh like you already do get allocated

00:13:07,490 --> 00:13:14,420
here right

00:13:08,870 --> 00:13:16,579
and so when you pass around the TC x the

00:13:14,420 --> 00:13:19,970
TC X is the type context it's kind of

00:13:16,579 --> 00:13:25,070
the omnipresent compilers state

00:13:19,970 --> 00:13:27,140
you when you pass around a TC exit it it

00:13:25,070 --> 00:13:33,800
is sometimes kind of in one of these

00:13:27,140 --> 00:13:35,210
local arenas and sometimes not but it

00:13:33,800 --> 00:13:36,890
well it will kind of pick which of the

00:13:35,210 --> 00:13:38,390
arenas to use based on the type that

00:13:36,890 --> 00:13:39,980
you're in in turning them so when you

00:13:38,390 --> 00:13:41,930
have a given type you'll say oh this one

00:13:39,980 --> 00:13:43,670
has some state that is local to entrance

00:13:41,930 --> 00:13:48,980
I'll put it in the local arena or it

00:13:43,670 --> 00:13:55,390
doesn't and we'll come back to that all

00:13:48,980 --> 00:13:58,280
right so let's talk about generics um so

00:13:55,390 --> 00:14:01,820
imagine I define this generic struct my

00:13:58,280 --> 00:14:05,210
struct T when you have a reference to

00:14:01,820 --> 00:14:08,030
this struct in rust like a variable

00:14:05,210 --> 00:14:15,370
whose type is my struct or whatever that

00:14:08,030 --> 00:14:23,240
reference never comes by itself let me

00:14:15,370 --> 00:14:27,080
back up and say one thing whenever the

00:14:23,240 --> 00:14:29,090
compiler assigns these special IDs we

00:14:27,080 --> 00:14:31,670
called F IDs and they're kind of

00:14:29,090 --> 00:14:38,810
assigned to everything that has a

00:14:31,670 --> 00:14:44,630
definition so in this example there

00:14:38,810 --> 00:14:48,920
would be at least two def IDs actually

00:14:44,630 --> 00:14:50,840
more but at least two all right so we

00:14:48,920 --> 00:14:52,640
would have one def ID that is just the

00:14:50,840 --> 00:14:56,300
DEF idea of this struct definition as a

00:14:52,640 --> 00:14:59,090
whole and we would have one def ID for

00:14:56,300 --> 00:15:01,430
example for the type parameter T we

00:14:59,090 --> 00:15:03,350
would also have one for the field we

00:15:01,430 --> 00:15:05,780
would not have a def ID for this u32

00:15:03,350 --> 00:15:07,640
here that's because that's not a

00:15:05,780 --> 00:15:09,440
definition that's a reference to the

00:15:07,640 --> 00:15:12,740
type u 32 but we're not defining to take

00:15:09,440 --> 00:15:14,600
you 32 here um so I'm gonna use the term

00:15:12,740 --> 00:15:16,130
def ID a lot but I wanted to kind of

00:15:14,600 --> 00:15:20,830
clarify what it is it's basically an

00:15:16,130 --> 00:15:22,730
identifier it's an integer that that

00:15:20,830 --> 00:15:27,770
identifies something that we define

00:15:22,730 --> 00:15:29,660
somewhere um it's an integer it happens

00:15:27,770 --> 00:15:31,490
to map we have an internal map they can

00:15:29,660 --> 00:15:33,770
go from the DEF ID to what's called a

00:15:31,490 --> 00:15:35,420
def path the DEF path is

00:15:33,770 --> 00:15:38,030
kind of what it sounds like it's a path

00:15:35,420 --> 00:15:41,330
through the it's basically like a module

00:15:38,030 --> 00:15:44,800
path holding a little more rich they

00:15:41,330 --> 00:15:49,360
might say like create Foom I struck and

00:15:44,800 --> 00:15:52,370
identifies this particular definition

00:15:49,360 --> 00:15:53,750
uniquely um it's a little different than

00:15:52,370 --> 00:15:55,670
a model path you can actually use in

00:15:53,750 --> 00:15:58,220
rust because you know it might for

00:15:55,670 --> 00:16:00,860
example include like the type parameter

00:15:58,220 --> 00:16:03,860
T has a path like this and you could not

00:16:00,860 --> 00:16:05,450
I mean the type parameter T from rust

00:16:03,860 --> 00:16:07,430
and nonsense

00:16:05,450 --> 00:16:08,810
the reason to have these pads these are

00:16:07,430 --> 00:16:09,980
used in incremental compilation they

00:16:08,810 --> 00:16:13,700
kind of match up things between

00:16:09,980 --> 00:16:17,290
compilations but doesn't matter too much

00:16:13,700 --> 00:16:19,970
basically for everything we have an ID

00:16:17,290 --> 00:16:21,290
so that's that's what the def idea of a

00:16:19,970 --> 00:16:23,900
struct is but now when we have an actual

00:16:21,290 --> 00:16:26,390
type like when we use my struct as the

00:16:23,900 --> 00:16:27,020
type it's never by itself it's not just

00:16:26,390 --> 00:16:29,480
my structure

00:16:27,020 --> 00:16:32,180
it also has together with it a set of

00:16:29,480 --> 00:16:35,450
type parameters right the value so in

00:16:32,180 --> 00:16:40,040
this basically the value for T and if

00:16:35,450 --> 00:16:46,630
you look at the definition of a DT and

00:16:40,040 --> 00:16:55,220
we saw earlier you will see here this

00:16:46,630 --> 00:16:58,460
was kind of small so you'll see that it

00:16:55,220 --> 00:17:06,800
has two parts it has an ADT death and a

00:16:58,460 --> 00:17:10,700
sub stress so see you still see my

00:17:06,800 --> 00:17:14,570
Dropbox paper here not only did some

00:17:10,700 --> 00:17:17,720
dragging so anyway here's the two parts

00:17:14,570 --> 00:17:21,170
actually so what these two parts are the

00:17:17,720 --> 00:17:24,740
ADT def that's like algebraic a type

00:17:21,170 --> 00:17:26,740
definition basically specifies the

00:17:24,740 --> 00:17:29,390
struct but without the type parameters

00:17:26,740 --> 00:17:31,100
it's essentially a def ID there's a one

00:17:29,390 --> 00:17:33,650
to one relationship between these and

00:17:31,100 --> 00:17:37,310
DEF IDs but what it actually is is this

00:17:33,650 --> 00:17:39,800
an intern struct interned in the same

00:17:37,310 --> 00:17:43,910
sense as the types of interns are

00:17:39,800 --> 00:17:46,400
allocated in the global arena and here

00:17:43,910 --> 00:17:47,390
we have a reference to it you can the t

00:17:46,400 --> 00:17:49,040
CX lifetime is kind

00:17:47,390 --> 00:17:51,620
the tell-tale something has that

00:17:49,040 --> 00:17:53,030
lifetime it's it must be allocated in

00:17:51,620 --> 00:17:57,110
the arena because that's what that's for

00:17:53,030 --> 00:17:59,300
um and it has some helper methods and

00:17:57,110 --> 00:18:02,450
some other things so when you have one

00:17:59,300 --> 00:18:07,940
of these struts you can ask things like

00:18:02,450 --> 00:18:10,610
is this a whatever um a lot of annoying

00:18:07,940 --> 00:18:13,040
stuff um let me scroll up actually oh

00:18:10,610 --> 00:18:17,660
wait what am I looking at this is the

00:18:13,040 --> 00:18:20,060
wrong link okay that link is wrong sorry

00:18:17,660 --> 00:18:22,490
what that ADT death does so I mentioned

00:18:20,060 --> 00:18:26,720
that here we're we were looking at us

00:18:22,490 --> 00:18:28,670
struct but I mentioned at some point

00:18:26,720 --> 00:18:31,130
that the ADT type is used for structs

00:18:28,670 --> 00:18:32,870
enums am unions so we kind of in the

00:18:31,130 --> 00:18:34,790
compiler have a sort of unified view of

00:18:32,870 --> 00:18:39,320
things you can think of a struct as

00:18:34,790 --> 00:18:40,910
being a lot like a one variant email you

00:18:39,320 --> 00:18:41,990
know that's just like an enum it has

00:18:40,910 --> 00:18:46,820
fields it's just that there's only one

00:18:41,990 --> 00:18:48,890
possibility and so the ADT deaf and cup

00:18:46,820 --> 00:18:51,820
lets you view all of those distinct

00:18:48,890 --> 00:18:54,230
things more uniformly so it has a def ID

00:18:51,820 --> 00:18:56,390
but then it has a list of variants and

00:18:54,230 --> 00:19:00,800
for our struct this will always be of

00:18:56,390 --> 00:19:04,340
length one and for each one within the

00:19:00,800 --> 00:19:05,870
variant it has some information about

00:19:04,340 --> 00:19:08,210
the variant like the variant has a def

00:19:05,870 --> 00:19:10,250
ideas will blah blah blah what is its

00:19:08,210 --> 00:19:13,790
discriminant and then it has a list of

00:19:10,250 --> 00:19:16,580
fields and these are basically the names

00:19:13,790 --> 00:19:18,650
each field has an ID and then it has it

00:19:16,580 --> 00:19:21,020
has a type that's not stored in this

00:19:18,650 --> 00:19:23,270
structure that's a vector but so that's

00:19:21,020 --> 00:19:26,960
what they DT test is it lets it kind of

00:19:23,270 --> 00:19:28,670
gives you some information and you can

00:19:26,960 --> 00:19:34,220
get them that's what that link is going

00:19:28,670 --> 00:19:36,590
to you can get them you there's a

00:19:34,220 --> 00:19:39,260
there's a way to construct an ADT death

00:19:36,590 --> 00:19:43,760
given a def ID this is a query i'm won't

00:19:39,260 --> 00:19:45,260
go into it so okay the sub stress so

00:19:43,760 --> 00:19:47,210
what is that so first of all people

00:19:45,260 --> 00:19:50,180
often have trouble with this that we

00:19:47,210 --> 00:19:52,730
should probably rename it okay what

00:19:50,180 --> 00:19:54,890
substance stands for substitutions and

00:19:52,730 --> 00:19:57,140
ref I guess is just because it's a

00:19:54,890 --> 00:19:59,360
reference and so what the substitutions

00:19:57,140 --> 00:20:01,059
are is it's basically a list of types

00:19:59,360 --> 00:20:03,159
that are meant to be sub

00:20:01,059 --> 00:20:06,999
stitute 'add for the generic type

00:20:03,159 --> 00:20:10,450
parameters on a struct so these are the

00:20:06,999 --> 00:20:12,999
replacements for these generic types and

00:20:10,450 --> 00:20:13,570
actually it's not just types because it

00:20:12,999 --> 00:20:15,759
could be reached

00:20:13,570 --> 00:20:17,679
it could be lifetimes or regions but for

00:20:15,759 --> 00:20:20,470
now we'll just talk about so in this

00:20:17,679 --> 00:20:22,419
case it would be a list like you 32 um

00:20:20,470 --> 00:20:25,629
and if you follow through this

00:20:22,419 --> 00:20:27,249
definition you'll see it's got a certain

00:20:25,629 --> 00:20:32,440
amount of complexity it's an internal

00:20:27,249 --> 00:20:36,419
sub switches an alias for a list of a

00:20:32,440 --> 00:20:39,190
kind a kind is either a type or a region

00:20:36,419 --> 00:20:45,850
defined in a weird way but this list

00:20:39,190 --> 00:20:48,759
what is list so a list is it's basically

00:20:45,850 --> 00:20:53,369
a slice of data so this is a little bit

00:20:48,759 --> 00:21:02,279
fancy but what this really is morally is

00:20:53,369 --> 00:21:10,059
this just say it's an arena allocated

00:21:02,279 --> 00:21:19,710
slice of types on and the or actually a

00:21:10,059 --> 00:21:21,909
little more accurately the cytokines and

00:21:19,710 --> 00:21:28,899
what I mean by kinds is there either

00:21:21,909 --> 00:21:31,990
types of regions so right so it's a

00:21:28,899 --> 00:21:38,169
slice it has this the difference is we

00:21:31,990 --> 00:21:41,649
use this list this kind of an for sanity

00:21:38,169 --> 00:21:46,360
TCX list kind this is kind of what it

00:21:41,649 --> 00:21:52,899
really is if you play it out and what

00:21:46,360 --> 00:21:54,730
that is let's see oh yes this has to do

00:21:52,899 --> 00:22:00,070
with the pointer equality and so on that

00:21:54,730 --> 00:22:01,629
I mentioned earlier so the idea is this

00:22:00,070 --> 00:22:03,940
is like a list of things that we

00:22:01,629 --> 00:22:05,679
allocated in the arena and the

00:22:03,940 --> 00:22:08,409
difference between a list and a slice is

00:22:05,679 --> 00:22:09,940
that you a list is the full list always

00:22:08,409 --> 00:22:13,210
whereas with a slice you can get sub

00:22:09,940 --> 00:22:16,230
slices and it matters because you might

00:22:13,210 --> 00:22:16,230
imagine you had like

00:22:16,830 --> 00:22:23,680
one list like this and one list like

00:22:20,380 --> 00:22:31,030
this okay these could be two different

00:22:23,680 --> 00:22:32,710
lists list a and this B but if we and

00:22:31,030 --> 00:22:35,650
now if we want to compare them for

00:22:32,710 --> 00:22:38,620
equality because we know that they're

00:22:35,650 --> 00:22:39,940
the complete list and we we in turned it

00:22:38,620 --> 00:22:41,890
and hashed it and we have these unique

00:22:39,940 --> 00:22:43,840
pointers we can actually compare the

00:22:41,890 --> 00:22:45,520
pointers for equality we don't have to

00:22:43,840 --> 00:22:49,360
dive in and iterate over the contents

00:22:45,520 --> 00:23:00,460
but if we had just slices I might take a

00:22:49,360 --> 00:23:03,910
sub slice of a I may have a sub slice of

00:23:00,460 --> 00:23:06,100
a and the full list B and I might want

00:23:03,910 --> 00:23:07,720
to compare them for equality and if I

00:23:06,100 --> 00:23:08,980
just compared the pointers it would tell

00:23:07,720 --> 00:23:12,280
me that they're unequal but actually

00:23:08,980 --> 00:23:14,380
they're equivalent so that's why we use

00:23:12,280 --> 00:23:18,460
this other type because it can't be sub

00:23:14,380 --> 00:23:21,280
sliced which is a win because we can

00:23:18,460 --> 00:23:25,540
have more efficient pointer operations

00:23:21,280 --> 00:23:27,520
but also a loss because we cancel which

00:23:25,540 --> 00:23:33,790
means that if we want to have a sub list

00:23:27,520 --> 00:23:37,030
you have to like allocated so that's how

00:23:33,790 --> 00:23:38,290
you represent these these my strokes any

00:23:37,030 --> 00:23:43,720
questions about that so far

00:23:38,290 --> 00:23:45,880
I have slightly off-topic question you

00:23:43,720 --> 00:23:49,600
mentioned that the compiler of ATT

00:23:45,880 --> 00:23:52,540
represents like a global view of is that

00:23:49,600 --> 00:23:54,910
reflected in the parts for grammar since

00:23:52,540 --> 00:23:58,240
then it distinguishes between them and

00:23:54,910 --> 00:23:59,620
then generates like this kind of

00:23:58,240 --> 00:24:03,130
structure or is it the other way around

00:23:59,620 --> 00:24:10,120
the grammar just it's okay I hope after

00:24:03,130 --> 00:24:12,880
we do so in rust grammar we treat those

00:24:10,120 --> 00:24:14,800
three things very differently all right

00:24:12,880 --> 00:24:16,390
and if you look at the here this is

00:24:14,800 --> 00:24:20,650
another difference between here types

00:24:16,390 --> 00:24:22,030
and well not quite but it's difference

00:24:20,650 --> 00:24:24,130
between the here and the later phases in

00:24:22,030 --> 00:24:26,350
the compiler right the here is more like

00:24:24,130 --> 00:24:27,880
mmm this is a struct definition this is

00:24:26,350 --> 00:24:29,380
an enum definition there are

00:24:27,880 --> 00:24:32,799
distinctions

00:24:29,380 --> 00:24:36,179
but then then we when we create the ADT

00:24:32,799 --> 00:24:40,240
death in this query that I talked about

00:24:36,179 --> 00:24:42,730
it actually sort of makes a unified view

00:24:40,240 --> 00:24:44,770
of I look saying oh if it's a struct let

00:24:42,730 --> 00:24:47,890
me give it a single variant if it's an e

00:24:44,770 --> 00:24:52,510
or if it's an email and the Union I

00:24:47,890 --> 00:24:54,880
think is more the other way that they're

00:24:52,510 --> 00:24:56,169
sort of I forget how unions are written

00:24:54,880 --> 00:24:57,159
I think they have also a single great

00:24:56,169 --> 00:25:00,000
but you could imagine them being

00:24:57,159 --> 00:25:05,010
actually all variants of their own I

00:25:00,000 --> 00:25:05,010
think we have only a single variant but

00:25:05,610 --> 00:25:12,370
yeah so that that translation happens

00:25:09,480 --> 00:25:14,350
that's exactly a good example I think of

00:25:12,370 --> 00:25:21,210
the translation from syntax to the

00:25:14,350 --> 00:25:24,730
semantics I'm talking about okay so I

00:25:21,210 --> 00:25:26,470
want to talk a bit about this a little

00:25:24,730 --> 00:25:30,580
more I talked about I said that these

00:25:26,470 --> 00:25:34,059
are the substitutions if you're familiar

00:25:30,580 --> 00:25:35,980
with like play the type systems that

00:25:34,059 --> 00:25:36,850
might be familiar to you but if not it's

00:25:35,980 --> 00:25:43,059
worth discussing

00:25:36,850 --> 00:25:46,230
so the we have a notion of sort of

00:25:43,059 --> 00:25:55,049
substituted and unsubstituted generics

00:25:46,230 --> 00:25:58,570
so here I talked about the type you 32

00:25:55,049 --> 00:26:01,990
as the value for T but inside the

00:25:58,570 --> 00:26:05,230
definition of my struct I might

00:26:01,990 --> 00:26:06,760
reference T directly right and when I'm

00:26:05,230 --> 00:26:09,010
inside this definition I don't really

00:26:06,760 --> 00:26:12,659
know what T is I'd have to treat it like

00:26:09,010 --> 00:26:15,909
it's a placeholder right for any type so

00:26:12,659 --> 00:26:18,760
we need a way just to talk about these

00:26:15,909 --> 00:26:21,309
these generic types that are not yet

00:26:18,760 --> 00:26:25,840
known and there is indeed a variant for

00:26:21,309 --> 00:26:32,590
that so if you go to this this list of

00:26:25,840 --> 00:26:35,100
variants called kind yep one of them is

00:26:32,590 --> 00:26:38,020
called paren unless we changed its knee

00:26:35,100 --> 00:26:40,659
yes no we didn't do that and it

00:26:38,020 --> 00:26:41,660
represents like a none substituted type

00:26:40,659 --> 00:26:45,770
holder okay

00:26:41,660 --> 00:26:49,660
type or a placeholder and it has two

00:26:45,770 --> 00:26:49,660
things it has an index and a name

00:26:49,730 --> 00:27:00,470
the index is just the essentially its

00:26:57,980 --> 00:27:06,920
position in the list right so figure a

00:27:00,470 --> 00:27:11,410
and B then anyone have index 0 B we have

00:27:06,920 --> 00:27:18,170
index 1 and the name is obviously a B

00:27:11,410 --> 00:27:21,110
and sometimes that index can stretch

00:27:18,170 --> 00:27:21,740
across definitions which is a little bit

00:27:21,110 --> 00:27:38,980
interesting

00:27:21,740 --> 00:27:47,930
so that usually occurs right don't

00:27:38,980 --> 00:27:52,220
inside inside this method let's say XY

00:27:47,930 --> 00:27:59,090
and z are all in scope so what will

00:27:52,220 --> 00:28:04,010
happen is that exercise index 0 Y has

00:27:59,090 --> 00:28:05,630
index 1 and Z has indexed two even

00:28:04,010 --> 00:28:11,420
though it's the first one in this list

00:28:05,630 --> 00:28:12,920
so the list of when you when you

00:28:11,420 --> 00:28:15,020
actually look at the generics of a

00:28:12,920 --> 00:28:17,150
particular item like the generic things

00:28:15,020 --> 00:28:18,910
that are generic parameters defined on a

00:28:17,150 --> 00:28:21,530
particular item like to this method

00:28:18,910 --> 00:28:24,070
you'll see that it has a parent show you

00:28:21,530 --> 00:28:27,380
in a second I'm sorry kind of inherits

00:28:24,070 --> 00:28:29,090
it can inherit generics from its parent

00:28:27,380 --> 00:28:32,780
and then extend them further with new

00:28:29,090 --> 00:28:39,200
generic definitions um so that's how

00:28:32,780 --> 00:28:40,700
this works and well so when we're inside

00:28:39,200 --> 00:28:43,010
the definition will actually just work

00:28:40,700 --> 00:28:45,500
with these parameters types as if they

00:28:43,010 --> 00:28:49,870
were real types right we'll treat them

00:28:45,500 --> 00:28:52,640
like any other type but when we come

00:28:49,870 --> 00:28:54,670
well when we want to pull something that

00:28:52,640 --> 00:28:56,740
was inside a definition

00:28:54,670 --> 00:28:58,330
out and use it from the outside we have

00:28:56,740 --> 00:29:00,400
to do what's called a substitution so

00:28:58,330 --> 00:29:04,500
let me give an example so imagine that

00:29:00,400 --> 00:29:04,500
we had this struct foo when it has a

00:29:04,740 --> 00:29:18,610
field of type Becker day and then now

00:29:13,030 --> 00:29:26,290
the type the type of this field is going

00:29:18,610 --> 00:29:28,600
to be an ADT of Veck if you ask this

00:29:26,290 --> 00:29:30,940
that this field has a def ID let me back

00:29:28,600 --> 00:29:32,860
up well no let me not do like a little

00:29:30,940 --> 00:29:34,900
the type of this field I'll explain in a

00:29:32,860 --> 00:29:36,970
second how you would get that type is

00:29:34,900 --> 00:29:39,640
but when we do get it it's going to be

00:29:36,970 --> 00:29:43,570
stored as an ADT that's because it's a

00:29:39,640 --> 00:29:45,310
reference to a vector and that's the ADT

00:29:43,570 --> 00:29:47,740
death is vector and then the list of

00:29:45,310 --> 00:29:49,930
substituted types is going to be the

00:29:47,740 --> 00:29:53,340
first parameter which corresponds to a

00:29:49,930 --> 00:29:58,900
right but now imagine that we were

00:29:53,340 --> 00:30:01,660
accessing that field from well actually

00:29:58,900 --> 00:30:05,100
even from here but let's let's make a

00:30:01,660 --> 00:30:05,100
separate example make a little here

00:30:10,020 --> 00:30:14,680
imagine we were accessing we want to

00:30:13,390 --> 00:30:16,390
know what we're trying to figure out is

00:30:14,680 --> 00:30:19,180
what is the type of this expression food

00:30:16,390 --> 00:30:23,380
X and if we just read the type of that

00:30:19,180 --> 00:30:25,150
field we would get sort of that directly

00:30:23,380 --> 00:30:27,130
and that doesn't make sense because this

00:30:25,150 --> 00:30:28,540
parameter isn't even we don't have any

00:30:27,130 --> 00:30:32,770
generic parameters in our current scope

00:30:28,540 --> 00:30:34,860
it's like a namespacing violation so

00:30:32,770 --> 00:30:38,320
what we want to do is we want to take

00:30:34,860 --> 00:30:44,710
the type of foo you see here the type of

00:30:38,320 --> 00:30:48,000
foo is gonna be this which is to say it

00:30:44,710 --> 00:30:51,970
has a slice with u-32 as the

00:30:48,000 --> 00:30:53,800
substitution and we want to replace the

00:30:51,970 --> 00:30:56,110
corresponding indices actually foo had

00:30:53,800 --> 00:30:59,500
two arguments so let's add that in there

00:30:56,110 --> 00:31:00,910
so basically we want to walk down this

00:30:59,500 --> 00:31:03,580
we want to get the type of the field

00:31:00,910 --> 00:31:06,220
like from here walk down and each place

00:31:03,580 --> 00:31:08,490
we see a parameter take the index index

00:31:06,220 --> 00:31:11,030
into that list of substitutions

00:31:08,490 --> 00:31:14,490
and replace it all right so that would

00:31:11,030 --> 00:31:17,600
substituting here would give us back

00:31:14,490 --> 00:31:21,750
with you 32 which is the correct type

00:31:17,600 --> 00:31:25,250
and that that transformation is called

00:31:21,750 --> 00:31:33,390
substituting and there's a substitute

00:31:25,250 --> 00:31:34,710
method called sup so let me I'll come

00:31:33,390 --> 00:31:36,510
back to how that actually happens in one

00:31:34,710 --> 00:31:38,130
second let me just talk about the types

00:31:36,510 --> 00:31:43,860
of fields so what I wanted to mention is

00:31:38,130 --> 00:31:45,840
that if the field has a def ID you can

00:31:43,860 --> 00:31:47,610
say you can use this type of query to

00:31:45,840 --> 00:31:49,470
say give me the type of this field and

00:31:47,610 --> 00:31:52,350
that's how I would actually get this

00:31:49,470 --> 00:31:55,590
type and it's gonna that type of query

00:31:52,350 --> 00:31:57,720
is quite flexible you can use it on any

00:31:55,590 --> 00:32:00,179
any def ID that has a type associated

00:31:57,720 --> 00:32:02,460
with it so for example I could even add

00:32:00,179 --> 00:32:10,800
I could ask for what is the type of the

00:32:02,460 --> 00:32:13,710
struct and that would give me it kind of

00:32:10,800 --> 00:32:16,559
gives me the like identity type of the

00:32:13,710 --> 00:32:18,300
struct that's just by definition you

00:32:16,559 --> 00:32:21,120
just decided it's just convenient as it

00:32:18,300 --> 00:32:22,230
happens that you can ask a struct for

00:32:21,120 --> 00:32:24,390
its type and you'll get back this

00:32:22,230 --> 00:32:28,080
identity sort of the internal view of

00:32:24,390 --> 00:32:31,170
the declarations those week and so forth

00:32:28,080 --> 00:32:32,940
um but one of the things you can ask for

00:32:31,170 --> 00:32:34,830
the type of is a field and in all cases

00:32:32,940 --> 00:32:37,559
when you do that you get this view with

00:32:34,830 --> 00:32:38,820
using that is in terms of the generics

00:32:37,559 --> 00:32:41,190
that are in scope and then you have to

00:32:38,820 --> 00:32:43,170
translate it to your particular scope

00:32:41,190 --> 00:32:51,780
where you've got values for those

00:32:43,170 --> 00:32:53,840
generics done so far following along so

00:32:51,780 --> 00:33:04,860
this subs method let's talk about that

00:32:53,840 --> 00:33:08,070
let me find an actual call to it here's

00:33:04,860 --> 00:33:11,420
one okay this is like a totally random

00:33:08,070 --> 00:33:11,420
piece of code but that's okay

00:33:13,360 --> 00:33:33,480
[Music]

00:33:15,260 --> 00:33:35,790
so so if we look at for example oh okay

00:33:33,480 --> 00:33:41,630
my checkout is a little out of date and

00:33:35,790 --> 00:33:41,630
we find the other place okay sure

00:33:42,710 --> 00:33:53,460
actually I'll do that yeah let's do this

00:33:45,120 --> 00:33:54,930
once okay here's an example of doing

00:33:53,460 --> 00:34:10,200
these substitutions that I've been

00:33:54,930 --> 00:34:21,840
talking about let me put a link to this

00:34:10,200 --> 00:34:25,890
for a future reference so so what is

00:34:21,840 --> 00:34:27,540
happening here so this is this is not

00:34:25,890 --> 00:34:30,300
two of what this code is actually doing

00:34:27,540 --> 00:34:33,260
is converting as it happens from the

00:34:30,300 --> 00:34:35,670
here the syntax of the type to the

00:34:33,260 --> 00:34:37,800
semantic view of the type so it's kind

00:34:35,670 --> 00:34:40,650
of doing this translation that's not so

00:34:37,800 --> 00:34:43,410
important but suffice to say it gets

00:34:40,650 --> 00:34:45,510
somehow a list of substitutions that are

00:34:43,410 --> 00:34:47,460
to be applied and then you can see it

00:34:45,510 --> 00:34:49,320
calls type of just like I said for a

00:34:47,460 --> 00:34:52,230
given def ID and that's going to give us

00:34:49,320 --> 00:34:54,750
the self view and then it applies this

00:34:52,230 --> 00:34:56,550
sub stood applies those substitutions

00:34:54,750 --> 00:35:00,600
and that'll make that actually do the

00:34:56,550 --> 00:35:02,250
substitution and now what you might

00:35:00,600 --> 00:35:05,600
wonder is what is this how does this

00:35:02,250 --> 00:35:10,050
subs method work what is it defined on

00:35:05,600 --> 00:35:13,110
so it turns out you want to be able to

00:35:10,050 --> 00:35:14,970
do these substitutions for a whole bunch

00:35:13,110 --> 00:35:16,890
of things like you want to be able to

00:35:14,970 --> 00:35:18,600
apply them to a type but you also might

00:35:16,890 --> 00:35:22,200
want to be able to apply them say to a

00:35:18,600 --> 00:35:23,880
struct with a bunch of types in it and

00:35:22,200 --> 00:35:25,020
apply the substitution to all the types

00:35:23,880 --> 00:35:26,490
in this drug

00:35:25,020 --> 00:35:28,680
a vector of types it's kind of like a

00:35:26,490 --> 00:35:31,440
map you want a sort of map operation

00:35:28,680 --> 00:35:33,869
where you can find all the types that

00:35:31,440 --> 00:35:36,330
appear inside of some thing and the

00:35:33,869 --> 00:35:40,650
compiler and substitute them and change

00:35:36,330 --> 00:35:43,650
their view and we have a we have a treat

00:35:40,650 --> 00:35:46,110
for that it's called type foldable even

00:35:43,650 --> 00:35:49,380
though this is sort of a map we call it

00:35:46,110 --> 00:35:52,320
type foldable feels like the right name

00:35:49,380 --> 00:35:53,850
but what it means is it's any type that

00:35:52,320 --> 00:35:56,700
implements type foldable is basically

00:35:53,850 --> 00:35:59,730
something that embeds types or regions

00:35:56,700 --> 00:36:04,380
and it allows you to walk itself and

00:35:59,730 --> 00:36:06,390
translate them right um so let me jump

00:36:04,380 --> 00:36:10,230
back to my anything so this is the type

00:36:06,390 --> 00:36:11,670
foldable section so the idea is there's

00:36:10,230 --> 00:36:13,560
actually two parts to the way type

00:36:11,670 --> 00:36:16,530
foldable words there's something called

00:36:13,560 --> 00:36:19,680
a type folder and the type folder is

00:36:16,530 --> 00:36:20,970
defines what you want to do to every

00:36:19,680 --> 00:36:24,900
type it's like the closure that you

00:36:20,970 --> 00:36:29,460
might give to a map if you were using my

00:36:24,900 --> 00:36:37,109
analogy is like vector dot error or dot

00:36:29,460 --> 00:36:38,400
map so if we do this we we walk over the

00:36:37,109 --> 00:36:41,460
vector and we apply something to every

00:36:38,400 --> 00:36:49,080
element this this closure is kind of the

00:36:41,460 --> 00:36:51,960
folder analogous to the folder and this

00:36:49,080 --> 00:36:57,119
the definition of map is sort of

00:36:51,960 --> 00:36:59,330
analogous to the type fool so the folder

00:36:57,119 --> 00:37:02,460
has a few methods you can see here um

00:36:59,330 --> 00:37:05,940
too many there's kind of one for every

00:37:02,460 --> 00:37:08,910
core sort of thing it's basically every

00:37:05,940 --> 00:37:11,520
kind of generic parameter that rusts the

00:37:08,910 --> 00:37:15,150
language defines and some that it

00:37:11,520 --> 00:37:17,700
doesn't defined yet so there there are

00:37:15,150 --> 00:37:21,180
types regions which is another name for

00:37:17,700 --> 00:37:24,750
a lifetime and constants for when we

00:37:21,180 --> 00:37:27,000
support constant arcs so what's going to

00:37:24,750 --> 00:37:32,970
happen and binders I'm going to ignore

00:37:27,000 --> 00:37:34,350
for the moment but they're there there

00:37:32,970 --> 00:37:36,330
another place that you get to intercept

00:37:34,350 --> 00:37:38,400
so what's going to happen is that when

00:37:36,330 --> 00:37:38,880
you have a type foldable it's going to

00:37:38,400 --> 00:37:42,750
walk it

00:37:38,880 --> 00:37:47,220
self and invoke the meth and sort of

00:37:42,750 --> 00:37:49,140
recursively apply until recursively fold

00:37:47,220 --> 00:37:50,700
until it gets down to us to a type or a

00:37:49,140 --> 00:37:54,539
region or a custom and then invoke the

00:37:50,700 --> 00:38:01,109
type folder to do some processing so in

00:37:54,539 --> 00:38:07,529
the case of substitution this is oops

00:38:01,109 --> 00:38:08,759
wrong in the case of substitution that

00:38:07,529 --> 00:38:14,309
just looks like the place I want to

00:38:08,759 --> 00:38:15,869
click the actual folder is just going to

00:38:14,309 --> 00:38:18,329
be doing that indexing that I talked

00:38:15,869 --> 00:38:19,769
about you can actually see it here so we

00:38:18,329 --> 00:38:21,750
define the folder here

00:38:19,769 --> 00:38:25,349
it's a struct it's called a sub stoller

00:38:21,750 --> 00:38:27,029
we we call it a fold width which means

00:38:25,349 --> 00:38:33,539
process might basically the map

00:38:27,029 --> 00:38:35,279
operation process myself and and invoke

00:38:33,539 --> 00:38:37,950
the folder methods as appropriate and if

00:38:35,279 --> 00:38:40,529
you skim down to like fold tie this is

00:38:37,950 --> 00:38:44,099
the method that that process is each

00:38:40,529 --> 00:38:47,759
title you see that it looks it says AHA

00:38:44,099 --> 00:38:50,640
this is a parameter type in that case

00:38:47,759 --> 00:38:52,730
I'm going to replace it with something

00:38:50,640 --> 00:38:55,609
from the list of substitutions and

00:38:52,730 --> 00:38:58,109
otherwise I'm going to recursively

00:38:55,609 --> 00:39:02,700
process the typo so I'll come back to

00:38:58,109 --> 00:39:04,740
this in a second um but the replacing it

00:39:02,700 --> 00:39:10,319
this is calling this tie for per a

00:39:04,740 --> 00:39:12,930
method and all that does is to basically

00:39:10,319 --> 00:39:16,470
index into the list of substitutions

00:39:12,930 --> 00:39:17,730
with the index of the parameter the rest

00:39:16,470 --> 00:39:19,829
of this stuff is basically all error

00:39:17,730 --> 00:39:22,079
recovery so that in case something goes

00:39:19,829 --> 00:39:23,670
wrong we get a nice message that can

00:39:22,079 --> 00:39:25,519
help us figure out what the heck

00:39:23,670 --> 00:39:32,609
happened um

00:39:25,519 --> 00:39:38,940
but effectively through morally what's

00:39:32,609 --> 00:39:42,029
happening is something like match it's a

00:39:38,940 --> 00:39:48,660
parameter in Dex and replace it with

00:39:42,029 --> 00:39:50,809
stuffs to be Dex um the so let me come

00:39:48,660 --> 00:39:54,439
back to this now but then

00:39:50,809 --> 00:39:59,659
look let's so what is this super fold

00:39:54,439 --> 00:40:03,380
with and what's happening here so so

00:39:59,659 --> 00:40:04,939
when you define a type foldable this is

00:40:03,380 --> 00:40:06,799
what a typical type foldable might look

00:40:04,939 --> 00:40:10,759
like and actually there's a shorthand

00:40:06,799 --> 00:40:13,099
that we can use to sort of derive it so

00:40:10,759 --> 00:40:16,009
likes imagine I have a struct it has a

00:40:13,099 --> 00:40:18,319
def idea of something and of type in it

00:40:16,009 --> 00:40:20,539
and I want to make it tight foldable and

00:40:18,319 --> 00:40:25,130
that would mean that if I had a my

00:40:20,539 --> 00:40:27,559
struct instance I would be able to do my

00:40:25,130 --> 00:40:30,559
struct ops for example and apply a

00:40:27,559 --> 00:40:32,659
substitution I there's a whole bunch of

00:40:30,559 --> 00:40:34,459
stuff and I can find out it just works

00:40:32,659 --> 00:40:38,150
on any type foldable thing so it would

00:40:34,459 --> 00:40:39,949
be compatible with all that um what I

00:40:38,150 --> 00:40:41,839
really do is I just define actually

00:40:39,949 --> 00:40:47,079
there's two methods I left off one of

00:40:41,839 --> 00:40:51,499
them I defined this Super fold with and

00:40:47,079 --> 00:40:53,359
we're kind of emulating an oo set up to

00:40:51,499 --> 00:40:56,089
certain extent so there's a fold with

00:40:53,359 --> 00:41:00,439
the actual trait has a fold width method

00:40:56,089 --> 00:41:03,429
and the default thing that it does I'm

00:41:00,439 --> 00:41:04,659
not mistaken is to call super fold with

00:41:03,429 --> 00:41:09,439
immediately

00:41:04,659 --> 00:41:11,329
um and so you're normally you're just

00:41:09,439 --> 00:41:12,829
defined super fold with but you don't

00:41:11,329 --> 00:41:14,839
normally invoke it most of the time and

00:41:12,829 --> 00:41:17,329
what it was super fold with will do is

00:41:14,839 --> 00:41:21,079
recursively descend through your fields

00:41:17,329 --> 00:41:22,999
and process and recursively process them

00:41:21,079 --> 00:41:27,549
so this this split gives you some

00:41:22,999 --> 00:41:30,019
ability to say like maybe I want to do

00:41:27,549 --> 00:41:32,179
something at the struct level like maybe

00:41:30,019 --> 00:41:34,699
I can replace the entire struct without

00:41:32,179 --> 00:41:35,779
substituting its fields individually in

00:41:34,699 --> 00:41:38,749
which case I

00:41:35,779 --> 00:41:41,269
that's what fold with the top-level

00:41:38,749 --> 00:41:43,249
method would do but otherwise the Super

00:41:41,269 --> 00:41:45,589
fold with says no I just want to replace

00:41:43,249 --> 00:41:46,880
I want to go and replace my fields but

00:41:45,589 --> 00:41:48,259
the structure I just want to build back

00:41:46,880 --> 00:41:50,419
up from the replaced version of each

00:41:48,259 --> 00:41:51,769
field and then for almost all types

00:41:50,419 --> 00:41:53,900
these are the same because you don't

00:41:51,769 --> 00:41:55,669
want to intercept at the top level the

00:41:53,900 --> 00:41:59,359
main difference the only real case where

00:41:55,669 --> 00:42:01,130
we use the super is types and regions

00:41:59,359 --> 00:42:03,049
and basically the things that the folder

00:42:01,130 --> 00:42:04,760
itself operates on because now the

00:42:03,049 --> 00:42:07,850
folder gets a chance to intercept

00:42:04,760 --> 00:42:10,730
and replaced the type as a whole as in

00:42:07,850 --> 00:42:12,380
the case of substitutions or as we also

00:42:10,730 --> 00:42:14,150
saw in substations it doesn't want to

00:42:12,380 --> 00:42:15,890
replace the type as a whole they can go

00:42:14,150 --> 00:42:19,190
to send into the type and replace its

00:42:15,890 --> 00:42:21,380
little pieces so an example by calling

00:42:19,190 --> 00:42:24,140
super fold with an example where it

00:42:21,380 --> 00:42:32,690
might want to do that would be like if I

00:42:24,140 --> 00:42:39,730
had well if I had a type like backpack

00:42:32,690 --> 00:42:44,960
of X this would be like a DT effect VDP

00:42:39,730 --> 00:42:49,460
Beck koream X let's say whatever the

00:42:44,960 --> 00:42:51,200
index of X is and so now when I

00:42:49,460 --> 00:42:53,690
substitute I have this is actually my

00:42:51,200 --> 00:42:55,760
entire type and there is no substitution

00:42:53,690 --> 00:42:57,890
to happen here but I want to recursively

00:42:55,760 --> 00:43:00,170
look at this inner type still no

00:42:57,890 --> 00:43:01,940
substitution recursively look at this

00:43:00,170 --> 00:43:04,070
inner type ok the minister I'm gonna

00:43:01,940 --> 00:43:06,020
replace this one with you 32 or whatever

00:43:04,070 --> 00:43:19,610
and then I'm gonna build the rest around

00:43:06,020 --> 00:43:20,480
it so that I wind up with this and

00:43:19,610 --> 00:43:27,280
that's what's going to happen when I

00:43:20,480 --> 00:43:38,860
call super one last thing I'll mention

00:43:27,280 --> 00:43:38,860
so if we look in the structural impulse

00:43:42,940 --> 00:43:52,550
is this I was so this this this file

00:43:49,850 --> 00:43:56,210
structural imposed on our risk happens

00:43:52,550 --> 00:43:58,160
to contain a lot of type foldable

00:43:56,210 --> 00:44:03,020
definitions so you can kind of see how

00:43:58,160 --> 00:44:04,490
they look um sometimes like this one ADT

00:44:03,020 --> 00:44:06,440
def this is actually interesting example

00:44:04,490 --> 00:44:07,940
you can see that fold with doesn't do

00:44:06,440 --> 00:44:10,210
anything at all it's just the identity

00:44:07,940 --> 00:44:13,460
function and the reason for that is

00:44:10,210 --> 00:44:17,210
essentially if the intuition you should

00:44:13,460 --> 00:44:18,230
think of is if I were substituting

00:44:17,210 --> 00:44:20,390
things

00:44:18,230 --> 00:44:23,240
to go from the self view to the outside

00:44:20,390 --> 00:44:25,280
view what I want to replace types that

00:44:23,240 --> 00:44:27,349
appear inside of here or not and an ADT

00:44:25,280 --> 00:44:29,150
def is basically just the name like we

00:44:27,349 --> 00:44:31,760
said that logically it represents the

00:44:29,150 --> 00:44:33,530
name of the struct like Veck and you

00:44:31,760 --> 00:44:35,630
never change that when you substituting

00:44:33,530 --> 00:44:37,430
but the vac is always affect um it's

00:44:35,630 --> 00:44:40,820
only these so that's why it doesn't get

00:44:37,430 --> 00:44:42,560
changed as you fold it um then we have

00:44:40,820 --> 00:44:44,570
some things like this will fold a tuple

00:44:42,560 --> 00:44:48,740
of other foldable things and it just

00:44:44,570 --> 00:44:51,680
recursively recurse is down um and these

00:44:48,740 --> 00:44:54,710
macros these are what I wanted to refer

00:44:51,680 --> 00:44:57,530
to make to highlight so for technical

00:44:54,710 --> 00:45:00,200
crappy reasons we can't use derive in

00:44:57,530 --> 00:45:01,910
the compiler itself yet this is because

00:45:00,200 --> 00:45:04,490
of the bootstrapping cycle we are I

00:45:01,910 --> 00:45:07,010
think actually maybe close to solving

00:45:04,490 --> 00:45:09,800
that I'm not sure but so we end up

00:45:07,010 --> 00:45:12,310
writing these macro rules definitions

00:45:09,800 --> 00:45:17,060
instead they are sort of like derive and

00:45:12,310 --> 00:45:18,980
this is one that handles the pain of

00:45:17,060 --> 00:45:21,380
implementing type foldable for some kind

00:45:18,980 --> 00:45:22,730
of enum so in this cookie right even

00:45:21,380 --> 00:45:24,890
though I'm type foldable and then you

00:45:22,730 --> 00:45:27,170
can list out the variants and it's gonna

00:45:24,890 --> 00:45:29,990
generate the glue code that's like match

00:45:27,170 --> 00:45:32,900
on self if it's a Sun recursively Boston

00:45:29,990 --> 00:45:34,730
all that stuff um and one annoying thing

00:45:32,900 --> 00:45:36,200
is that often we don't get all the edge

00:45:34,730 --> 00:45:37,270
cases right when we write these macro

00:45:36,200 --> 00:45:41,720
rules because we're lazy

00:45:37,270 --> 00:45:43,640
so like enums work for parenthesized

00:45:41,720 --> 00:45:46,940
lists of fields but they might not work

00:45:43,640 --> 00:45:49,490
for named items with main fields and so

00:45:46,940 --> 00:45:51,200
sometimes you'll see manual impulse that

00:45:49,490 --> 00:45:52,490
don't seem like it seems like you should

00:45:51,200 --> 00:45:54,950
be able to derive it but you can't

00:45:52,490 --> 00:45:56,780
because it just doesn't quite fit but

00:45:54,950 --> 00:45:58,940
the macro is made to do and that's

00:45:56,780 --> 00:46:01,910
annoying but here's a case for like a

00:45:58,940 --> 00:46:04,310
brace struct so this happening is a

00:46:01,910 --> 00:46:06,800
struct with three fields I can read

00:46:04,310 --> 00:46:08,240
brace truck code foldable I don't have

00:46:06,800 --> 00:46:11,930
to write all the crew code I just have

00:46:08,240 --> 00:46:14,260
to list out the fields um copy these

00:46:11,930 --> 00:46:14,260
links

00:46:26,380 --> 00:46:30,210
[Music]

00:46:27,680 --> 00:46:32,970
it would be really nice like definitely

00:46:30,210 --> 00:46:39,930
we've long wanted to be able to apply

00:46:32,970 --> 00:46:45,060
derived from just just get rid of these

00:46:39,930 --> 00:46:53,369
done get the idea now what one other one

00:46:45,060 --> 00:46:56,369
I'll mention is okay so all these types

00:46:53,369 --> 00:46:58,200
I mentioned that if there is if nothing

00:46:56,369 --> 00:47:01,410
needs to happen during substitution if

00:46:58,200 --> 00:47:02,790
you just want to copy it over that's an

00:47:01,410 --> 00:47:04,770
easy case and all of these types are

00:47:02,790 --> 00:47:06,510
examples where there's really no self

00:47:04,770 --> 00:47:09,420
substitution to be done that's why this

00:47:06,510 --> 00:47:19,500
clone thing just says just clone it it's

00:47:09,420 --> 00:47:22,160
all you gotta do where you covered this

00:47:19,500 --> 00:47:29,910
all right so we're running out of time I

00:47:22,160 --> 00:47:31,680
will let's take a vote should I try to

00:47:29,910 --> 00:47:33,750
talk about infants in the two levels of

00:47:31,680 --> 00:47:37,470
the arena table or is that too much and

00:47:33,750 --> 00:47:44,540
you should leave it for another time if

00:47:37,470 --> 00:47:47,369
you think it's one is you mentioned

00:47:44,540 --> 00:47:48,599
handling for substitution the obvious

00:47:47,369 --> 00:47:50,819
case I can think of is trying to

00:47:48,599 --> 00:47:52,369
substitute something with a list and you

00:47:50,819 --> 00:47:55,020
have like an index out of bounds

00:47:52,369 --> 00:47:57,089
situation other than that is there any

00:47:55,020 --> 00:48:02,040
other failure for substitution

00:47:57,089 --> 00:48:04,560
yeah there there could be you could pass

00:48:02,040 --> 00:48:08,060
a type where a region was expected or

00:48:04,560 --> 00:48:14,369
vice versa and usually that would be a

00:48:08,060 --> 00:48:15,060
compiler programmer error well yes

00:48:14,369 --> 00:48:19,050
always

00:48:15,060 --> 00:48:20,910
so it's possible I mean it might it

00:48:19,050 --> 00:48:30,720
might be that the user wrote something

00:48:20,910 --> 00:48:32,490
wrong like they might have written they

00:48:30,720 --> 00:48:33,900
might have written like back of today or

00:48:32,490 --> 00:48:35,520
something and that would be just wrong

00:48:33,900 --> 00:48:36,839
but what should have happened is that we

00:48:35,520 --> 00:48:38,790
should have intercepted that earlier

00:48:36,839 --> 00:48:39,480
when we were translating from syntax to

00:48:38,790 --> 00:48:42,810
semantics

00:48:39,480 --> 00:48:44,040
and substituted dummy something such

00:48:42,810 --> 00:48:46,280
that it made sense and we actually have

00:48:44,040 --> 00:48:49,020
a special type called error for example

00:48:46,280 --> 00:48:51,060
that is would be used in situations like

00:48:49,020 --> 00:48:52,470
this where it's like I there was a bug

00:48:51,060 --> 00:48:53,880
they usually did something dumb and I'm

00:48:52,470 --> 00:48:55,859
just putting this in them and the idea

00:48:53,880 --> 00:48:58,740
for that is that then you should

00:48:55,859 --> 00:48:59,970
suppress downstream yours like if you

00:48:58,740 --> 00:49:02,190
see an error you don't have to report

00:48:59,970 --> 00:49:05,730
you can just pretend it was everything

00:49:02,190 --> 00:49:07,109
was good because but right so that

00:49:05,730 --> 00:49:09,600
should be handled earlier so if you see

00:49:07,109 --> 00:49:14,040
it at this late stage then somebody

00:49:09,600 --> 00:49:15,359
mixed up something that's and the second

00:49:14,040 --> 00:49:17,700
small question was you mentioned several

00:49:15,359 --> 00:49:19,200
times of the Selphy versus the outside

00:49:17,700 --> 00:49:22,470
view p-please clarify what you meant by

00:49:19,200 --> 00:49:26,040
that yeah that's kind of my intuitive

00:49:22,470 --> 00:49:30,390
name for it but what I met was self use

00:49:26,040 --> 00:49:34,530
I mean like inside the struct definition

00:49:30,390 --> 00:49:37,109
for example so it's basically the when

00:49:34,530 --> 00:49:38,609
when the generics are in scope and you

00:49:37,109 --> 00:49:41,220
have to treat them as placeholders

00:49:38,609 --> 00:49:45,930
that's what I mean by self you and then

00:49:41,220 --> 00:49:47,820
the outside view would be when well for

00:49:45,930 --> 00:49:49,290
example here when I'm reaching in

00:49:47,820 --> 00:49:52,190
together the type of the field but I'm

00:49:49,290 --> 00:49:54,930
not the generics are not in scope now

00:49:52,190 --> 00:49:57,000
that our generics on that type are not

00:49:54,930 --> 00:49:58,590
in school so I should be substituting

00:49:57,000 --> 00:50:00,119
them and there's actually a little bit

00:49:58,590 --> 00:50:04,590
of a like the Impala is an interesting

00:50:00,119 --> 00:50:05,970
case because it's an outside view from

00:50:04,590 --> 00:50:09,240
the point of view of the fields of the

00:50:05,970 --> 00:50:11,520
struct actually but an inside view from

00:50:09,240 --> 00:50:13,109
these generics here right it's why I

00:50:11,520 --> 00:50:15,990
give them different letters to emphasize

00:50:13,109 --> 00:50:17,940
that indeed although there is a

00:50:15,990 --> 00:50:20,060
parameter with index zero in scope in

00:50:17,940 --> 00:50:25,230
both places it's logically a distinct

00:50:20,060 --> 00:50:28,320
type and so a common failure is to

00:50:25,230 --> 00:50:30,150
forget to do substitution and if you do

00:50:28,320 --> 00:50:32,700
that sometimes they might go unnoticed

00:50:30,150 --> 00:50:36,090
for a while because you just happen to

00:50:32,700 --> 00:50:38,520
have the same set of things in scope and

00:50:36,090 --> 00:50:40,200
it's only when you're writing more

00:50:38,520 --> 00:50:46,020
complex examples that you realize you've

00:50:40,200 --> 00:50:47,520
got something wrong all right I think

00:50:46,020 --> 00:50:51,500
it's a good place to stop we won't cover

00:50:47,520 --> 00:50:51,500
we'll get to the infant sir another time

00:50:51,770 --> 00:51:01,500
and parting questions in Thank You Nico

00:50:57,270 --> 00:51:03,900
I was you find something could you

00:51:01,500 --> 00:51:06,360
clarify um when you're talking about the

00:51:03,900 --> 00:51:10,310
type foldable and pulls and he said we

00:51:06,360 --> 00:51:13,380
treat abt deaths completely opaquely

00:51:10,310 --> 00:51:15,150
so when I'm confused by is okay if that

00:51:13,380 --> 00:51:19,800
were a struct why don't we recursing to

00:51:15,150 --> 00:51:23,130
all of its fields so the ATT def two

00:51:19,800 --> 00:51:36,050
reasons it's a good question the answer

00:51:23,130 --> 00:51:39,450
is because basically because you don't

00:51:36,050 --> 00:51:40,710
you frankly cut into this there's like a

00:51:39,450 --> 00:51:42,900
couple of different directions to answer

00:51:40,710 --> 00:51:45,540
it one way to view it is because we

00:51:42,900 --> 00:51:48,630
don't and what we do instead is when you

00:51:45,540 --> 00:51:50,970
extract the type of the field you you

00:51:48,630 --> 00:51:52,410
substitute it then alright so I guess

00:51:50,970 --> 00:51:54,660
that there will be two possible options

00:51:52,410 --> 00:51:56,790
you could you could say that the ADT

00:51:54,660 --> 00:52:00,900
death is like a structural description

00:51:56,790 --> 00:52:04,200
of the field of the fields invariants

00:52:00,900 --> 00:52:06,480
and so in that case it's not just a name

00:52:04,200 --> 00:52:08,220
of the struct it's like more like here's

00:52:06,480 --> 00:52:11,040
the data of the struct and you would

00:52:08,220 --> 00:52:14,670
want to substitute it then because it

00:52:11,040 --> 00:52:15,750
should represent the view but what we

00:52:14,670 --> 00:52:19,200
actually say is that it's really just

00:52:15,750 --> 00:52:20,760
the name and that so it goes it never

00:52:19,200 --> 00:52:25,170
changes the types in there are always

00:52:20,760 --> 00:52:27,090
with the consistent view of being inside

00:52:25,170 --> 00:52:28,560
they always have the self view so to

00:52:27,090 --> 00:52:29,730
speak and that the you just that you

00:52:28,560 --> 00:52:31,980
have to know that and know that when you

00:52:29,730 --> 00:52:34,140
extract them out they will be you need

00:52:31,980 --> 00:52:36,840
to apply substitution um there's a sort

00:52:34,140 --> 00:52:38,520
of deeper reason for that that there's

00:52:36,840 --> 00:52:41,910
this term nominal and structural type

00:52:38,520 --> 00:52:44,250
systems they're like where this is a

00:52:41,910 --> 00:52:46,380
nominal type system which means

00:52:44,250 --> 00:52:48,510
basically that exactly this basically

00:52:46,380 --> 00:52:51,180
that you pass around you reference

00:52:48,510 --> 00:52:52,770
trucks by name and not two strokes that

00:52:51,180 --> 00:52:55,100
have different names even if they have

00:52:52,770 --> 00:52:58,860
the same fields are distinct strokes um

00:52:55,100 --> 00:53:00,870
and so when you take that approach here

00:52:58,860 --> 00:53:02,490
generally you would not do the

00:53:00,870 --> 00:53:03,850
substitution on the name itself instead

00:53:02,490 --> 00:53:05,740
you will

00:53:03,850 --> 00:53:07,330
I guess one way to think of it is you

00:53:05,740 --> 00:53:09,760
could think of it as just efficiency

00:53:07,330 --> 00:53:14,260
also right like the only thing that can

00:53:09,760 --> 00:53:16,180
change inside a Veck is the type

00:53:14,260 --> 00:53:18,250
parameters defined on the Veck right

00:53:16,180 --> 00:53:20,950
like if we're substituting if we have

00:53:18,250 --> 00:53:23,560
some effective back of u-32 and it has

00:53:20,950 --> 00:53:25,270
all or you if a vector type and it has a

00:53:23,560 --> 00:53:26,650
bunch of references to tea all

00:53:25,270 --> 00:53:28,720
throughout let's say a whole bunch of

00:53:26,650 --> 00:53:32,620
fields I mean let me make them work

00:53:28,720 --> 00:53:35,440
tying it to vectors may be confusing so

00:53:32,620 --> 00:53:38,520
imagine I have like a struct my struct

00:53:35,440 --> 00:53:42,550
right and it has a tee and I have

00:53:38,520 --> 00:53:45,220
hundreds of fields each of which is like

00:53:42,550 --> 00:53:47,530
Veck of tea or something right if I were

00:53:45,220 --> 00:53:48,940
to apply the substitution deeply I would

00:53:47,530 --> 00:53:53,800
have to replace the T in all of those

00:53:48,940 --> 00:53:57,490
fields eagerly every time but it but if

00:53:53,800 --> 00:54:00,040
I do it lazily then I keep my struck the

00:53:57,490 --> 00:54:03,960
same and I just substitute once the

00:54:00,040 --> 00:54:09,010
value like I have a reference somewhere

00:54:03,960 --> 00:54:10,870
to my struct of a so some other generic

00:54:09,010 --> 00:54:13,240
a and I substitute that to my structure

00:54:10,870 --> 00:54:14,680
be I'm only changing this one type once

00:54:13,240 --> 00:54:16,780
right and it's only when I actually pull

00:54:14,680 --> 00:54:17,470
the field out that I that I would have

00:54:16,780 --> 00:54:19,540
to do any work

00:54:17,470 --> 00:54:21,880
um there's kind of the only thing that

00:54:19,540 --> 00:54:25,600
can change between these is is all

00:54:21,880 --> 00:54:28,630
summarized right there that may make

00:54:25,600 --> 00:54:36,990
sense yeah yeah that does make sense

00:54:28,630 --> 00:54:41,650
Thanks okay any more questions once

00:54:36,990 --> 00:54:43,900
twice three times okay cool

00:54:41,650 --> 00:54:48,130
you can always pay me if something comes

00:54:43,900 --> 00:54:55,890
up thanks everybody and we'll talk talk

00:54:48,130 --> 00:54:55,890

YouTube URL: https://www.youtube.com/watch?v=c01TsOsr3-c


