Title: Tom Tromey discusses debugging support in rustc
Publication date: 2019-01-23
Playlist: rustc lecture series
Description: 
	The talk gives a high-level overview of how Rust integration with gdb, lldb, and so forth work. It discusses some of the steps that are needed to add extensions to the DWARF standard for Rust-specific features.

Speaker: Tom Tromey, who added Rust support to gdb, and implemented the rust-lldb debugger.
Captions: 
	00:00:00,000 --> 00:00:10,200
I mean yeah okay hi I'm Tom draw me here

00:00:04,890 --> 00:00:13,920
to talk about rusty bugging let's see

00:00:10,200 --> 00:00:15,389
I'm gonna I was like to have a slide

00:00:13,920 --> 00:00:16,890
that explains what I'm going to tell you

00:00:15,389 --> 00:00:18,390
about so that when I'm telling you about

00:00:16,890 --> 00:00:21,779
it you can remember that I told you that

00:00:18,390 --> 00:00:26,300
it was going to tell you about it at any

00:00:21,779 --> 00:00:28,470
time there's two people on on this

00:00:26,300 --> 00:00:30,119
conference if you want if you have a

00:00:28,470 --> 00:00:34,079
question or a comment or something just

00:00:30,119 --> 00:00:37,350
jump in you know so I'm going to talk a

00:00:34,079 --> 00:00:40,379
little bit about what the current state

00:00:37,350 --> 00:00:44,100
of things is in GB and ll DB and and

00:00:40,379 --> 00:00:47,430
Wharf and sort of what's missing like

00:00:44,100 --> 00:00:49,920
some sort of accessible projects that

00:00:47,430 --> 00:00:52,710
could be worked on then some more out

00:00:49,920 --> 00:00:55,949
there like future projects and that

00:00:52,710 --> 00:00:57,960
haven't been looked at really and then I

00:00:55,949 --> 00:00:59,730
wrote sample questions but I don't think

00:00:57,960 --> 00:01:02,489
I actually wrote any sample questions so

00:00:59,730 --> 00:01:07,229
you can ignore the hell SP all right so

00:01:02,489 --> 00:01:09,720
for gdb the current state of rusty buggy

00:01:07,229 --> 00:01:13,020
and gdb is like there's a rust

00:01:09,720 --> 00:01:17,390
expression parser this parses like a

00:01:13,020 --> 00:01:20,250
subset of rust expressions it's just a

00:01:17,390 --> 00:01:21,900
this parser has no relation to any other

00:01:20,250 --> 00:01:24,140
parser it's just one that was written

00:01:21,900 --> 00:01:24,140
from scratch

00:01:25,009 --> 00:01:32,430
gdb has rust like value and type output

00:01:30,090 --> 00:01:36,210
so like when you print a value it looks

00:01:32,430 --> 00:01:39,270
like rust syntax on out you know on the

00:01:36,210 --> 00:01:41,930
output or when you print a type you know

00:01:39,270 --> 00:01:47,909
using P type and gdb it also looks like

00:01:41,930 --> 00:01:51,450
rust source code the expert

00:01:47,909 --> 00:01:53,009
parser has a couple of extensions in it

00:01:51,450 --> 00:01:55,560
to do things that you couldn't normally

00:01:53,009 --> 00:01:58,950
do in rust and to support those

00:01:55,560 --> 00:02:03,119
extensions there is also some special

00:01:58,950 --> 00:02:04,740
code in the dwarf reader in gdb so we'll

00:02:03,119 --> 00:02:07,700
talk a little bit more about dwarf from

00:02:04,740 --> 00:02:12,209
the dwarf extensions and stuff later but

00:02:07,700 --> 00:02:14,430
two examples of that are like the GTV

00:02:12,209 --> 00:02:21,500
dwarf reader needed special support for

00:02:14,430 --> 00:02:25,260
rust enum types and then the expression

00:02:21,500 --> 00:02:26,849
you know like in because the because the

00:02:25,260 --> 00:02:29,340
expression subset doesn't include

00:02:26,849 --> 00:02:33,799
matches if you want to access fields of

00:02:29,340 --> 00:02:36,989
an enum you know like you can just type

00:02:33,799 --> 00:02:39,180
in own value dot the name of the field

00:02:36,989 --> 00:02:41,069
in the currently active email branch if

00:02:39,180 --> 00:02:42,930
that makes sense how do you know

00:02:41,069 --> 00:02:45,840
actually have two questions first of all

00:02:42,930 --> 00:02:47,940
the dwarf reader that's something that

00:02:45,840 --> 00:02:51,390
parses dwarf and Mike converts it to gdb

00:02:47,940 --> 00:02:53,760
is internal that's correct yeah both the

00:02:51,390 --> 00:02:56,130
debuggers have a step like that where

00:02:53,760 --> 00:02:58,799
they you know Dorf is kind of this

00:02:56,130 --> 00:03:02,220
compressed format that's not super great

00:02:58,799 --> 00:03:05,970
to work with as like a data format you

00:03:02,220 --> 00:03:08,510
know so they both sort of read it and

00:03:05,970 --> 00:03:11,780
explode it into data structures that you

00:03:08,510 --> 00:03:15,540
yeah they're more natural to use and so

00:03:11,780 --> 00:03:21,290
yes so you know this enum stuff

00:03:15,540 --> 00:03:24,150
gdb understands about the RUS compiler

00:03:21,290 --> 00:03:26,459
writes information about an enum into

00:03:24,150 --> 00:03:28,919
the dwarf and then gdb reads the dwarf

00:03:26,459 --> 00:03:33,209
to understand like where is the tag

00:03:28,919 --> 00:03:37,799
field is there a tag field because you

00:03:33,209 --> 00:03:40,650
can have univariant in ohms or is the

00:03:37,799 --> 00:03:42,780
tag slot shared with you know like the

00:03:40,650 --> 00:03:45,000
non zero optimization is the tag slot

00:03:42,780 --> 00:03:47,160
shared with some other slot and if so

00:03:45,000 --> 00:03:49,290
which special values mean which enum

00:03:47,160 --> 00:03:54,750
branch and stuff that's all described in

00:03:49,290 --> 00:03:59,729
the dwarf so another extension gdb

00:03:54,750 --> 00:04:01,410
supports is dissecting trait objects and

00:03:59,729 --> 00:04:01,950
this leg of you look on the slide it

00:04:01,410 --> 00:04:04,950
says this thing

00:04:01,950 --> 00:04:09,800
about V tables we made a little dwarf

00:04:04,950 --> 00:04:12,810
extension where a trait object will a

00:04:09,800 --> 00:04:18,019
trait objects description in the dwarf

00:04:12,810 --> 00:04:21,660
also points to like sort of a stub

00:04:18,019 --> 00:04:25,110
description of the corresponding V table

00:04:21,660 --> 00:04:29,280
and then that in turn points to the

00:04:25,110 --> 00:04:31,320
concrete type for which this trait

00:04:29,280 --> 00:04:33,870
object exists and what that means is if

00:04:31,320 --> 00:04:37,500
you have a trait object you can like

00:04:33,870 --> 00:04:39,960
print star object and gdb understands

00:04:37,500 --> 00:04:41,790
how to understands how to find the

00:04:39,960 --> 00:04:47,010
correct type of the payload in the trade

00:04:41,790 --> 00:04:50,070
object so you know so it's like nice for

00:04:47,010 --> 00:04:51,450
debugging you can be in this spot or you

00:04:50,070 --> 00:04:52,770
don't really know what this thing you're

00:04:51,450 --> 00:04:54,660
looking at is and you can just pretend

00:04:52,770 --> 00:04:56,430
its GDP will tell you well this is

00:04:54,660 --> 00:04:59,100
actually a pointer to one of these

00:04:56,430 --> 00:05:01,080
things does it do some other things but

00:04:59,100 --> 00:05:02,220
you said currently active invariant did

00:05:01,080 --> 00:05:03,240
you mean that it'll like read the

00:05:02,220 --> 00:05:06,060
discriminant to figure that out

00:05:03,240 --> 00:05:09,270
dynamically yeah that's right so when

00:05:06,060 --> 00:05:11,760
you print an enum value you know

00:05:09,270 --> 00:05:14,180
previously if you use gdb before like

00:05:11,760 --> 00:05:18,330
say a lot of this ease now more quaint

00:05:14,180 --> 00:05:20,970
and/or if you know if you printed an

00:05:18,330 --> 00:05:23,550
enum value that used to look like kind

00:05:20,970 --> 00:05:26,610
of like basically a C Union in the dwarf

00:05:23,550 --> 00:05:28,139
in the dwarf and so you would just get

00:05:26,610 --> 00:05:31,010
this thing with all the different member

00:05:28,139 --> 00:05:33,900
you know all the different variants and

00:05:31,010 --> 00:05:37,560
try to figure it out on your own but now

00:05:33,900 --> 00:05:40,310
gdb does that work for you so it will

00:05:37,560 --> 00:05:41,430
only print the currently active branch

00:05:40,310 --> 00:05:47,010
yeah

00:05:41,430 --> 00:05:50,820
and so all this work is upstream it's

00:05:47,010 --> 00:05:55,320
just part of gdb and GB has uses

00:05:50,820 --> 00:05:58,200
bugzilla you can easily go and find the

00:05:55,320 --> 00:06:02,820
existing bugs there's I think on the

00:05:58,200 --> 00:06:05,539
order of 25 or something you know anyway

00:06:02,820 --> 00:06:05,539
so

00:06:05,710 --> 00:06:11,030
that's kind of it for gdb I are there

00:06:09,650 --> 00:06:12,860
any more questions about how would you

00:06:11,030 --> 00:06:16,820
move on I don't know all right

00:06:12,860 --> 00:06:20,720
you make sense okay so LD be it's

00:06:16,820 --> 00:06:26,030
actually um in a it's roughly in a

00:06:20,720 --> 00:06:31,220
similar state it also has its own

00:06:26,030 --> 00:06:33,200
expression parser also just uh you know

00:06:31,220 --> 00:06:38,390
no relation to any other parser I

00:06:33,200 --> 00:06:43,760
actually wrote a second one for ll DB so

00:06:38,390 --> 00:06:48,760
uh this one C in C++ yeah they're both

00:06:43,760 --> 00:06:53,080
the gdb one is in bayson of all things

00:06:48,760 --> 00:06:55,520
which I wouldn't do again so for ll DBA

00:06:53,080 --> 00:06:59,990
it's just like a recursive descent

00:06:55,520 --> 00:07:03,200
parser written in C++ it actually

00:06:59,990 --> 00:07:08,210
implements slightly less of the language

00:07:03,200 --> 00:07:10,729
than gdb mostly because I missed a step

00:07:08,210 --> 00:07:17,479
when I was writing it so there's no deep

00:07:10,729 --> 00:07:19,729
reason so you know like that's just some

00:07:17,479 --> 00:07:22,220
detail there's an LD beepo or you know a

00:07:19,729 --> 00:07:25,340
bug in RL l DB tracker about the missing

00:07:22,220 --> 00:07:29,150
bits like for instance the v table thing

00:07:25,340 --> 00:07:30,760
i didn't implement it also has rust like

00:07:29,150 --> 00:07:33,830
value and type output

00:07:30,760 --> 00:07:35,450
it's dwarf reader also understands the

00:07:33,830 --> 00:07:39,140
stuff that needed to be done for you

00:07:35,450 --> 00:07:40,910
gnomes you know that's something i call

00:07:39,140 --> 00:07:42,830
out because it's something that's in

00:07:40,910 --> 00:07:44,390
dwarf like dwarf has this whole thing

00:07:42,830 --> 00:07:47,240
about variant types and all this stuff

00:07:44,390 --> 00:07:50,360
but no compiler ever admitted it and no

00:07:47,240 --> 00:07:53,390
debugger ever read it until we needed it

00:07:50,360 --> 00:07:58,130
for rust so it's like a special thing

00:07:53,390 --> 00:07:59,990
you can see there's a link to the

00:07:58,130 --> 00:08:03,800
repository it's in rustling nursery

00:07:59,990 --> 00:08:06,410
however upstream LLVM is moving to this

00:08:03,800 --> 00:08:08,150
mono repo and so rust is following I

00:08:06,410 --> 00:08:14,180
think there's a PR that's active right

00:08:08,150 --> 00:08:17,860
now and when that happens are lldp will

00:08:14,180 --> 00:08:21,040
be moving to wherever this mono repo is

00:08:17,860 --> 00:08:23,620
so what does that mean okay so you mean

00:08:21,040 --> 00:08:27,550
it'll going is this part of the LOB I'm

00:08:23,620 --> 00:08:29,530
fragile no no it's not so we will have

00:08:27,550 --> 00:08:35,380
our you know we have our own Fork of

00:08:29,530 --> 00:08:38,860
LLVM in somewhere rustling and basically

00:08:35,380 --> 00:08:41,380
that will now contain lldp all right

00:08:38,860 --> 00:08:44,440
you know previously we had a because of

00:08:41,380 --> 00:08:47,140
the way ldb works you need lov m and l l

00:08:44,440 --> 00:08:50,620
DB and clang actually all in the same

00:08:47,140 --> 00:08:52,390
tree to build it um so we were doing

00:08:50,620 --> 00:08:56,140
that with sub-modules in the normal

00:08:52,390 --> 00:09:00,190
build but now with the mono repo we'll

00:08:56,140 --> 00:09:02,260
have one repository for all of those but

00:09:00,190 --> 00:09:06,980
probably also still our own fork and

00:09:02,260 --> 00:09:10,970
rustling none of

00:09:06,980 --> 00:09:15,079
the rust lldp work is upstream at us

00:09:10,970 --> 00:09:18,050
upstreams request I am asked about this

00:09:15,079 --> 00:09:23,930
there's some links on the if you go to

00:09:18,050 --> 00:09:26,540
the rust Lange nursery LDB wiki there's

00:09:23,930 --> 00:09:29,779
a link to a discussion if you read

00:09:26,540 --> 00:09:33,050
around in that email thread or in that

00:09:29,779 --> 00:09:34,850
month um there's just some discussion

00:09:33,050 --> 00:09:36,440
about that ldb recently went through

00:09:34,850 --> 00:09:39,019
this thing where they removed all the

00:09:36,440 --> 00:09:40,610
other language plugins due to lack of

00:09:39,019 --> 00:09:42,680
maintenance and so they didn't want to

00:09:40,610 --> 00:09:47,000
accept any new ones so none of this is

00:09:42,680 --> 00:09:48,920
upstream it's a and L LD B has a plug-in

00:09:47,000 --> 00:09:51,290
architecture where you can write plugins

00:09:48,920 --> 00:09:54,139
as their shared libraries or something

00:09:51,290 --> 00:09:57,440
however that doesn't work for language

00:09:54,139 --> 00:09:59,680
support so we had to fork the whole

00:09:57,440 --> 00:09:59,680
thing

00:10:01,810 --> 00:10:10,450
DB is built for Mac OS as part of the

00:10:04,660 --> 00:10:12,390
rust build so and

00:10:10,450 --> 00:10:16,960
it's available through rust operas the

00:10:12,390 --> 00:10:20,410
ll DB preview package so the

00:10:16,960 --> 00:10:23,620
recommendation effectively is that Mac

00:10:20,410 --> 00:10:25,660
uses LOD beat and everybody else uses

00:10:23,620 --> 00:10:29,860
well actually I should just say UNIX

00:10:25,660 --> 00:10:32,710
users gdb yeah we'll get to that there's

00:10:29,860 --> 00:10:35,560
no answer there but yes that's kind of

00:10:32,710 --> 00:10:38,740
the recommendation at the time when I

00:10:35,560 --> 00:10:40,510
did this the issue I had was I wasn't

00:10:38,740 --> 00:10:44,700
sure how I wanted to solve this problem

00:10:40,510 --> 00:10:47,530
of hello DB has a Python dependency and

00:10:44,700 --> 00:10:52,510
I wasn't sure I wasn't sure how I wanted

00:10:47,530 --> 00:10:55,510
to deal with that on Linux and so on Mac

00:10:52,510 --> 00:10:58,390
OS that was reasonably easy to solve we

00:10:55,510 --> 00:11:02,530
can just rely on the system one but you

00:10:58,390 --> 00:11:07,410
know the Linux world is hairier in this

00:11:02,530 --> 00:11:11,590
regard since then I feel like I came to

00:11:07,410 --> 00:11:14,680
an OK solution and I'll talk about that

00:11:11,590 --> 00:11:17,470
a little later so it could be you know

00:11:14,680 --> 00:11:19,300
we could ship LD be everywhere my

00:11:17,470 --> 00:11:22,570
experience though is GB generally works

00:11:19,300 --> 00:11:26,160
better on Linux and you know I look

00:11:22,570 --> 00:11:32,380
people disagree with that but ok so

00:11:26,160 --> 00:11:36,510
dwarf dwarf for people who don't know

00:11:32,380 --> 00:11:40,900
Dorf is sort of the standard way that

00:11:36,510 --> 00:11:44,200
compilers generate debugging debugging

00:11:40,900 --> 00:11:47,470
information that debuggers read it's a

00:11:44,200 --> 00:11:51,670
debugging format and it's prevalent in

00:11:47,470 --> 00:11:57,010
like it's the debugging format on Mac OS

00:11:51,670 --> 00:12:01,870
and Linux it's a it's a multi-language

00:11:57,010 --> 00:12:05,290
and extensible format and the main part

00:12:01,870 --> 00:12:09,250
that describes like types and things

00:12:05,290 --> 00:12:11,440
like that is also extensible it's like

00:12:09,250 --> 00:12:13,960
this tree structured thing where you can

00:12:11,440 --> 00:12:16,720
it's got tags and attributes and you can

00:12:13,960 --> 00:12:18,490
actually invent to a certain extent your

00:12:16,720 --> 00:12:22,030
own tags and your own attributes and

00:12:18,490 --> 00:12:24,329
debuggers normally are expected to

00:12:22,030 --> 00:12:28,269
ignore anything they don't understand

00:12:24,329 --> 00:12:31,990
so you can you can kind of go nuts in

00:12:28,269 --> 00:12:34,839
there if you need to the dwarf standard

00:12:31,990 --> 00:12:36,579
there's the URL if you want to go you

00:12:34,839 --> 00:12:40,389
can go download the standard and you can

00:12:36,579 --> 00:12:46,449
see the open bugs dwarf is mostly good

00:12:40,389 --> 00:12:48,850
enough for rusts purposes so my overall

00:12:46,449 --> 00:12:54,069
philosophy when you know sort of

00:12:48,850 --> 00:12:56,949
changing the dwarf output is to reuse

00:12:54,069 --> 00:12:59,940
existing dwarf constructs even if say

00:12:56,949 --> 00:13:02,829
the names don't exactly line up or if

00:12:59,940 --> 00:13:11,230
even if the semantics are slightly off

00:13:02,829 --> 00:13:13,839
home now there are some things that that

00:13:11,230 --> 00:13:18,250
require dwarf extensions so we have a

00:13:13,839 --> 00:13:20,350
few dwarf extensions that that the RUS

00:13:18,250 --> 00:13:22,300
compiler emits and that the debuggers

00:13:20,350 --> 00:13:25,870
understand that are not in the dwarf

00:13:22,300 --> 00:13:31,750
standard one was that vtable thing that

00:13:25,870 --> 00:13:33,579
required an extension I feel like

00:13:31,750 --> 00:13:37,899
there's another one and not remembering

00:13:33,579 --> 00:13:40,389
what it was anyway they're documented in

00:13:37,899 --> 00:13:42,190
the debuggers like in comments or in

00:13:40,389 --> 00:13:45,100
LLVM and comments and I think I

00:13:42,190 --> 00:13:48,190
submitted one or two dwarf standard bug

00:13:45,100 --> 00:13:50,790
reports asking for some changes now some

00:13:48,190 --> 00:13:53,410
things will require bigger changes so

00:13:50,790 --> 00:13:56,139
traits which I think I have all slide

00:13:53,410 --> 00:14:03,190
all about how to represent traits and

00:13:56,139 --> 00:14:05,470
dwarf require a bigger change and there

00:14:03,190 --> 00:14:08,800
are some things that are not don't rise

00:14:05,470 --> 00:14:11,800
to the level of like it would be cleaner

00:14:08,800 --> 00:14:14,680
if the dwarf if we changed or or added

00:14:11,800 --> 00:14:16,660
some extension but in the meantime we

00:14:14,680 --> 00:14:19,329
have this these heuristics or

00:14:16,660 --> 00:14:22,769
workarounds that work reasonably well so

00:14:19,329 --> 00:14:25,899
I haven't seen the need so for instance

00:14:22,769 --> 00:14:29,790
dwarf provides no way to differentiate

00:14:25,899 --> 00:14:29,790
between structs and tuples

00:14:30,880 --> 00:14:34,389
what the Russ compiler does is omits

00:14:32,740 --> 00:14:38,199
fields with names like underscore

00:14:34,389 --> 00:14:41,500
underscore 0 and then the debuggers like

00:14:38,199 --> 00:14:44,350
look for a sequence of such field names

00:14:41,500 --> 00:14:45,819
which it's kind of ugly if you remove

00:14:44,350 --> 00:14:48,310
the underscores it might be better

00:14:45,819 --> 00:14:50,130
because it would remove the ambiguity so

00:14:48,310 --> 00:14:54,959
that might be a possibility

00:14:50,130 --> 00:14:57,339
it didn't seem super vital you know

00:14:54,959 --> 00:14:59,949
yeah those underscores are sending the

00:14:57,339 --> 00:15:04,959
user types like the debugger doesn't

00:14:59,949 --> 00:15:07,540
notes this bugger does know now so I

00:15:04,959 --> 00:15:10,509
feel like yeah I feel like those were

00:15:07,540 --> 00:15:13,660
probably added I don't know I didn't do

00:15:10,509 --> 00:15:15,519
the archaeology but I feel like those

00:15:13,660 --> 00:15:18,910
were probably added because before the

00:15:15,519 --> 00:15:22,029
debuggers had rust support if you wanted

00:15:18,910 --> 00:15:24,610
to extract the value of a field you

00:15:22,029 --> 00:15:27,190
needed to type it into like GDP and GDP

00:15:24,610 --> 00:15:31,269
would say well X dot zero being is a

00:15:27,190 --> 00:15:34,990
syntax error whereas X dot underscore

00:15:31,269 --> 00:15:38,470
underscore zero is fine that makes sense

00:15:34,990 --> 00:15:41,259
so but now the debugger is no and so in

00:15:38,470 --> 00:15:43,480
ng be like because it has this rust

00:15:41,259 --> 00:15:45,779
parser you can type print X dot zero and

00:15:43,480 --> 00:15:50,350
it knows though I'm doing a two-pole

00:15:45,779 --> 00:15:54,339
member access and you know does the

00:15:50,350 --> 00:15:56,649
right thing okay yeah okay so that's

00:15:54,339 --> 00:16:00,820
like the state of Dwarf some you know

00:15:56,649 --> 00:16:04,770
pretty good some extensions needed

00:16:00,820 --> 00:16:06,820
you know yes okay next what's missing

00:16:04,770 --> 00:16:08,410
we're gonna just go through there's a

00:16:06,820 --> 00:16:10,840
bunch of slides about things that are

00:16:08,410 --> 00:16:12,970
missing and these are basically the kind

00:16:10,840 --> 00:16:15,190
of larger projects I was planning to

00:16:12,970 --> 00:16:20,160
tackle over the next year but I am NOT

00:16:15,190 --> 00:16:25,240
now one is shipping GDB and rest up

00:16:20,160 --> 00:16:27,520
there's actually a PR however the PR I

00:16:25,240 --> 00:16:30,370
don't know I messed something up because

00:16:27,520 --> 00:16:32,380
it doesn't build in autumn it doesn't

00:16:30,370 --> 00:16:35,860
actually build GEB in automation so that

00:16:32,380 --> 00:16:41,590
required some debugging however I can do

00:16:35,860 --> 00:16:44,440
that debating because I think the basic

00:16:41,590 --> 00:16:46,350
reason is Alex didn't like that we're

00:16:44,440 --> 00:16:48,910
stuffing everything into the rust build

00:16:46,350 --> 00:16:52,420
which makes sense if you think about it

00:16:48,910 --> 00:16:57,900
and also maybe we're pretty close to our

00:16:52,420 --> 00:16:57,900
time budget for these builds already so

00:16:58,080 --> 00:17:08,500
so that required so actually shipping

00:17:03,190 --> 00:17:12,760
gdb requires some kind of change to like

00:17:08,500 --> 00:17:14,860
the rust up delivery system so that gdb

00:17:12,760 --> 00:17:17,560
could be built as its own entity and

00:17:14,860 --> 00:17:19,900
then the artifacts that are created that

00:17:17,560 --> 00:17:23,380
way can be stuck into rust up without

00:17:19,900 --> 00:17:25,050
requiring it to be part of one giant

00:17:23,380 --> 00:17:29,500
rust build

00:17:25,050 --> 00:17:33,310
now the reason to ship up so if however

00:17:29,500 --> 00:17:38,410
this PR that it exists is still useful

00:17:33,310 --> 00:17:40,750
because to look at because it the main

00:17:38,410 --> 00:17:43,420
issue with things like GEB is setting up

00:17:40,750 --> 00:17:45,010
their dependencies remember with the ll

00:17:43,420 --> 00:17:46,810
DB thing I was talking about shipping on

00:17:45,010 --> 00:17:48,730
Linux is tricky because of a Python

00:17:46,810 --> 00:17:53,170
dependency and that's true for gdb as

00:17:48,730 --> 00:17:56,470
well so I thought there was we can rely

00:17:53,170 --> 00:17:57,970
on the least common denominator which is

00:17:56,470 --> 00:18:01,150
Python 2.7

00:17:57,970 --> 00:18:07,120
most of the distros ship it and then

00:18:01,150 --> 00:18:11,020
what I did for gdb was like like ll DB

00:18:07,120 --> 00:18:14,500
or like LLVM we have our own Fork of gdb

00:18:11,020 --> 00:18:16,659
this is and I'll talk about this in

00:18:14,500 --> 00:18:20,909
to make it really clear what this means

00:18:16,659 --> 00:18:24,280
but we'll have our own fork that has

00:18:20,909 --> 00:18:26,260
where we import stock upstream jeebies

00:18:24,280 --> 00:18:28,240
and apply a few patches and that's the

00:18:26,260 --> 00:18:32,380
one that we build and ship to rust up

00:18:28,240 --> 00:18:36,220
and one of those patches is a change to

00:18:32,380 --> 00:18:39,159
heavy driver that actually runs gdb and

00:18:36,220 --> 00:18:41,409
the driver will check for the existence

00:18:39,159 --> 00:18:44,320
of the correct version version of Python

00:18:41,409 --> 00:18:47,049
and tell you hey you didn't install

00:18:44,320 --> 00:18:51,030
Python 2.7 and please and install it

00:18:47,049 --> 00:18:52,340
however you do that for your distro and

00:18:51,030 --> 00:18:56,150
the Rees

00:18:52,340 --> 00:18:58,270
for that is it's in most dependencies

00:18:56,150 --> 00:19:00,890
can be statically linked but I think

00:18:58,270 --> 00:19:04,909
statically linking Python is probably a

00:19:00,890 --> 00:19:07,429
mistake because it's not impossible or

00:19:04,909 --> 00:19:09,020
maybe even unusual to want to write a

00:19:07,429 --> 00:19:13,730
Python script that loads a shared

00:19:09,020 --> 00:19:17,210
library that depends on Python itself so

00:19:13,730 --> 00:19:21,169
for example I have some chibi scripts

00:19:17,210 --> 00:19:24,200
that do that so so most things in this

00:19:21,169 --> 00:19:25,820
build like in the PR you know it

00:19:24,200 --> 00:19:30,590
statically links most dependencies

00:19:25,820 --> 00:19:34,490
except for Python now why to do why do

00:19:30,590 --> 00:19:38,419
this you know the the reason to do it is

00:19:34,490 --> 00:19:41,630
so that it's easier to like make a

00:19:38,419 --> 00:19:45,350
compiler change to change the debug info

00:19:41,630 --> 00:19:48,500
and then immediately ship debuggers that

00:19:45,350 --> 00:19:50,870
can understand it and so that way we

00:19:48,500 --> 00:19:53,539
don't have this problem where we're

00:19:50,870 --> 00:19:57,590
reluctant to turn on new debug info

00:19:53,539 --> 00:19:59,480
features for fear of breaking things um

00:19:57,590 --> 00:20:03,649
we could just immediately ship

00:19:59,480 --> 00:20:06,470
everything working you know and sort of

00:20:03,649 --> 00:20:09,200
my vision for this Fork of gdb was to

00:20:06,470 --> 00:20:13,190
keep it was to treat it a lot like we

00:20:09,200 --> 00:20:16,580
treat rust LLVM where most changes

00:20:13,190 --> 00:20:18,169
anything not like truly rust specific

00:20:16,580 --> 00:20:21,350
like in this case that funny little

00:20:18,169 --> 00:20:23,990
wrapper program most changes should go

00:20:21,350 --> 00:20:26,840
upstream first or at least be in the

00:20:23,990 --> 00:20:30,380
process of being up streamed before they

00:20:26,840 --> 00:20:32,380
get stuck into the rust tree and the

00:20:30,380 --> 00:20:35,480
rust tree would be primarily about

00:20:32,380 --> 00:20:38,659
delivering things to users before or you

00:20:35,480 --> 00:20:41,960
know actual upstream releases GEB only

00:20:38,659 --> 00:20:43,309
releases there every six months so you

00:20:41,960 --> 00:20:49,100
know it's it's a really different

00:20:43,309 --> 00:20:52,159
cadence okay that makes sense yeah so

00:20:49,100 --> 00:20:54,500
basically the recommended way to run gdb

00:20:52,159 --> 00:20:55,730
with rust would be to install a detour

00:20:54,500 --> 00:20:58,070
rust up just like on tv

00:20:55,730 --> 00:21:01,220
if we did all these changes that's right

00:20:58,070 --> 00:21:04,520
and if you look like there's another

00:21:01,220 --> 00:21:05,440
part of this gdb PR that's salvageable

00:21:04,520 --> 00:21:07,210
in fact maybe I

00:21:05,440 --> 00:21:10,750
should try to push it in well I don't

00:21:07,210 --> 00:21:12,250
know it's not ready but if you look at

00:21:10,750 --> 00:21:14,889
like there's these little rapper scripts

00:21:12,250 --> 00:21:18,639
rust a little to be a trust GB and what

00:21:14,889 --> 00:21:20,440
they do is they run LOD B or GB with

00:21:18,639 --> 00:21:24,070
some special arguments to make sure that

00:21:20,440 --> 00:21:31,539
like the rough specific Python code is

00:21:24,070 --> 00:21:33,700
found properly and the ll DB script like

00:21:31,539 --> 00:21:35,769
for Mac OS has a little hack in it where

00:21:33,700 --> 00:21:40,750
if you've installed the ll DB preview it

00:21:35,769 --> 00:21:42,820
prefers that and the idea would be to do

00:21:40,750 --> 00:21:45,879
the same for rust the rust gdb script

00:21:42,820 --> 00:21:48,190
and this play are as a patch for that

00:21:45,879 --> 00:21:52,720
that can be extracted or whatever might

00:21:48,190 --> 00:21:54,940
make sense to error out like because

00:21:52,720 --> 00:21:58,360
it's sort of a suboptimal questionable

00:21:54,940 --> 00:22:01,149
experience otherwise you know eventually

00:21:58,360 --> 00:22:01,629
I think that I think that would make

00:22:01,149 --> 00:22:04,629
sense

00:22:01,629 --> 00:22:08,440
in the meantime I'm not so sure just

00:22:04,629 --> 00:22:10,269
because you can kind of limp along and

00:22:08,440 --> 00:22:13,779
and also we haven't solved the problem

00:22:10,269 --> 00:22:16,360
of like you can run rust the rough lob B

00:22:13,779 --> 00:22:24,580
script on Linux but we don't ship for

00:22:16,360 --> 00:22:27,220
Linux so okay so okay so that's gdb and

00:22:24,580 --> 00:22:30,269
rest up still valuable to do but it

00:22:27,220 --> 00:22:34,139
requires this rust up flash

00:22:30,269 --> 00:22:36,190
infrastructure groundwork first that I

00:22:34,139 --> 00:22:44,110
actually don't know the state of that

00:22:36,190 --> 00:22:48,009
you al excite okay next all right debug

00:22:44,110 --> 00:22:52,629
on Mac OS there are these features

00:22:48,009 --> 00:22:57,159
called sip which system integrity

00:22:52,629 --> 00:22:59,409
protection I think basically it prevents

00:22:57,159 --> 00:23:03,129
processes from using the P trace system

00:22:59,409 --> 00:23:04,929
column and processes that want to use it

00:23:03,129 --> 00:23:10,460
have to be code signed you know

00:23:04,929 --> 00:23:12,230
certainly and the

00:23:10,460 --> 00:23:14,270
certificate or whatever that you used to

00:23:12,230 --> 00:23:18,350
sign it has to be trusted on your

00:23:14,270 --> 00:23:24,430
machine now what that means is debuggers

00:23:18,350 --> 00:23:30,740
out of the box don't work now you can

00:23:24,430 --> 00:23:32,840
you can sign these programs however to

00:23:30,740 --> 00:23:34,820
sign them and have it work where the

00:23:32,840 --> 00:23:37,370
user installs the program and it just

00:23:34,820 --> 00:23:42,950
works you have to get an official

00:23:37,370 --> 00:23:46,220
certificate like through some Mac you

00:23:42,950 --> 00:23:49,780
know through some Apple process I was

00:23:46,220 --> 00:23:53,480
hoping we could work around this by

00:23:49,780 --> 00:23:56,870
relying on users that already have like

00:23:53,480 --> 00:23:59,200
the ll DB debug server installed in fact

00:23:56,870 --> 00:24:02,690
that's what we do today which is not

00:23:59,200 --> 00:24:09,400
very ideal not everyone wants to install

00:24:02,690 --> 00:24:14,630
Xcode so to fix it in a real way what we

00:24:09,400 --> 00:24:17,900
need to do is sign up with Apple and get

00:24:14,630 --> 00:24:21,040
the special keys that we need to do the

00:24:17,900 --> 00:24:25,610
signing in automation

00:24:21,040 --> 00:24:27,800
however I've I looked into maybe getting

00:24:25,610 --> 00:24:31,760
Mozilla to do this because Mozilla

00:24:27,800 --> 00:24:35,330
already does this for its products it

00:24:31,760 --> 00:24:40,160
ships so I talked to someone at Mozilla

00:24:35,330 --> 00:24:43,160
but it sounded to me my understanding of

00:24:40,160 --> 00:24:46,160
the outcome is that Mozilla can't we are

00:24:43,160 --> 00:24:48,350
at the maximum or near the maximum

00:24:46,160 --> 00:24:50,530
number of things were allowed to sign

00:24:48,350 --> 00:24:56,090
with the keys that we currently have

00:24:50,530 --> 00:24:58,650
so maybe Mozilla could get more keys I

00:24:56,090 --> 00:25:02,730
don't actually know

00:24:58,650 --> 00:25:04,920
otherwise I think maybe the route

00:25:02,730 --> 00:25:09,780
forward is that there has to be a rust

00:25:04,920 --> 00:25:13,740
legal entity that can

00:25:09,780 --> 00:25:18,150
get these keys through Apple and manage

00:25:13,740 --> 00:25:21,810
them itself so this is a tricky problem

00:25:18,150 --> 00:25:24,720
oh it's not really a technical problem

00:25:21,810 --> 00:25:29,730
at all once you have key it's kind of

00:25:24,720 --> 00:25:32,400
like making sure the build server hasn't

00:25:29,730 --> 00:25:39,600
backing out a scenic patch I mean you

00:25:32,400 --> 00:25:42,390
know that part's not too hard but you

00:25:39,600 --> 00:25:44,550
know so unsolved problem and the impact

00:25:42,390 --> 00:25:46,650
of this problem is pretty big like you

00:25:44,550 --> 00:25:51,420
either have to install Xcode for lld be

00:25:46,650 --> 00:25:54,780
torque or it just doesn't work so on Mac

00:25:51,420 --> 00:25:57,390
OS now if we had such a key we could

00:25:54,780 --> 00:26:02,970
also sign gdb and ship gdb for people

00:25:57,390 --> 00:26:08,210
like that I don't know but yeah okay any

00:26:02,970 --> 00:26:11,280
questions about this one no questions no

00:26:08,210 --> 00:26:15,600
annoying so many problems yes it's

00:26:11,280 --> 00:26:19,710
terrible there's a this is disgusting a

00:26:15,600 --> 00:26:22,560
bug in it in our ll DB repo so you can

00:26:19,710 --> 00:26:29,970
look through there for some a little bit

00:26:22,560 --> 00:26:31,530
of information so okay something that's

00:26:29,970 --> 00:26:35,520
totally missing this a bit in the

00:26:31,530 --> 00:26:39,240
future stuff section maybe is Windows is

00:26:35,520 --> 00:26:41,010
a complete unknown I don't really know

00:26:39,240 --> 00:26:44,640
anything about Windows Windows has its

00:26:41,010 --> 00:26:48,590
own debugging format PDB there is some

00:26:44,640 --> 00:26:54,300
support in LLVM free mitting PDB however

00:26:48,590 --> 00:26:55,770
what is not known to me is how well does

00:26:54,300 --> 00:26:59,640
it handle the things that are part of

00:26:55,770 --> 00:27:01,230
Rus but not part of C++ like a really

00:26:59,640 --> 00:27:06,380
good example would be going back to the

00:27:01,230 --> 00:27:10,370
dwarf stuff how would we describe enums

00:27:06,380 --> 00:27:14,570
rusty gnomes - PDB can it even be done

00:27:10,370 --> 00:27:14,570
so I don't know the answer

00:27:15,180 --> 00:27:22,410
that's something to research yeah so

00:27:18,180 --> 00:27:29,220
it's just a big blank spot yeah okay

00:27:22,410 --> 00:27:32,160
yeah okay remember I talked about like

00:27:29,220 --> 00:27:35,760
dwarf and what things are missing or

00:27:32,160 --> 00:27:38,640
what's needed so I wanted to do a little

00:27:35,760 --> 00:27:41,790
bit more about traits because it kind of

00:27:38,640 --> 00:27:44,220
shows some stuff about how how to

00:27:41,790 --> 00:27:48,360
actually implement one of these projects

00:27:44,220 --> 00:27:53,330
so currently rust traits are not emitted

00:27:48,360 --> 00:27:59,550
in Dwarf at all and the impact of this

00:27:53,330 --> 00:28:03,210
is that like a really typical bug report

00:27:59,550 --> 00:28:05,640
to get I think there's at least I think

00:28:03,210 --> 00:28:06,840
I'm sure it's open for GTB and ll to be

00:28:05,640 --> 00:28:09,660
but I feel like there's been several

00:28:06,840 --> 00:28:12,300
dupes over time a really typical bug

00:28:09,660 --> 00:28:15,830
report is I wanted to call a method

00:28:12,300 --> 00:28:18,590
print X dot method and it didn't work

00:28:15,830 --> 00:28:21,920
well the reason it didn't work is that

00:28:18,590 --> 00:28:26,960
method is implemented via a tree

00:28:21,920 --> 00:28:30,240
you know as opposed to in pull type and

00:28:26,960 --> 00:28:32,610
that information is just not there like

00:28:30,240 --> 00:28:34,800
some of it is there but there's no

00:28:32,610 --> 00:28:37,740
association between like the type of X

00:28:34,800 --> 00:28:40,410
and how to find some route through the

00:28:37,740 --> 00:28:42,780
debug info to find the methods you know

00:28:40,410 --> 00:28:48,920
that are implemented on it by traits

00:28:42,780 --> 00:28:51,930
okay so dwarf does have this notion of

00:28:48,920 --> 00:28:54,660
like interface types it was added for

00:28:51,930 --> 00:28:58,970
Java I think so my idea was to reuse

00:28:54,660 --> 00:29:02,970
this idea so you can say well this class

00:28:58,970 --> 00:29:05,480
you know this or this type implements

00:29:02,970 --> 00:29:09,540
these interfaces and then each interface

00:29:05,480 --> 00:29:14,130
would be you know each trait would be

00:29:09,540 --> 00:29:16,260
like an interface type well I'm sorry

00:29:14,130 --> 00:29:18,690
are we talking specifically about like

00:29:16,260 --> 00:29:20,280
didn't trade objects or things or do you

00:29:18,690 --> 00:29:25,560
mean no we're just talking about traits

00:29:20,280 --> 00:29:27,510
in general yeah you know like you know

00:29:25,560 --> 00:29:29,550
like one of the one of the

00:29:27,510 --> 00:29:31,380
one of the classic bugs is that one

00:29:29,550 --> 00:29:33,780
printing a method you know like trying

00:29:31,380 --> 00:29:36,300
to call a method but another classic one

00:29:33,780 --> 00:29:39,840
is you can't implement operator

00:29:36,300 --> 00:29:45,680
overloading in the debugger without

00:29:39,840 --> 00:29:45,680
knowing what traits a type implements so

00:29:46,730 --> 00:29:52,030
so the idea would be

00:29:48,700 --> 00:29:54,070
tre you know it can't dwarf only deals

00:29:52,030 --> 00:29:58,510
with concrete things it doesn't deal

00:29:54,070 --> 00:30:03,490
with like generic things so like in C++

00:29:58,510 --> 00:30:05,530
it only done it only describes template

00:30:03,490 --> 00:30:07,150
instantiations not the templates in

00:30:05,530 --> 00:30:11,560
themselves and the same would be true

00:30:07,150 --> 00:30:13,510
for rust so the idea would be given

00:30:11,560 --> 00:30:15,700
implementation and implementation of a

00:30:13,510 --> 00:30:16,480
trait for a type would be one of these

00:30:15,700 --> 00:30:19,960
interface

00:30:16,480 --> 00:30:24,070
you know DW tag interface type or

00:30:19,960 --> 00:30:26,560
whatever and then the type for which

00:30:24,070 --> 00:30:29,140
it's implemented right like you

00:30:26,560 --> 00:30:32,860
implemented it for i-32 the description

00:30:29,140 --> 00:30:36,610
for i 32 would say hey i implement all

00:30:32,860 --> 00:30:38,920
these different interfaces and it would

00:30:36,610 --> 00:30:40,600
have pointers to those interfaces in the

00:30:38,920 --> 00:30:43,270
dwarf and then that way a debugger could

00:30:40,600 --> 00:30:46,360
say AHA print X dot method well X has

00:30:43,270 --> 00:30:49,210
type I 32 I can go look that up in the

00:30:46,360 --> 00:30:50,860
dwarf oh here's all the interfaces that

00:30:49,210 --> 00:30:54,580
implements I can go search through all

00:30:50,860 --> 00:30:56,380
of those to find the method to call so

00:30:54,580 --> 00:31:00,550
that's how that would work now that

00:30:56,380 --> 00:31:03,820
requires to first of all that requires a

00:31:00,550 --> 00:31:06,610
dwarf extension if you go and read the

00:31:03,820 --> 00:31:10,679
dwarf standard you'll see that

00:31:06,610 --> 00:31:13,360
interfaces are only really defined for

00:31:10,679 --> 00:31:16,000
structure types structures and classes

00:31:13,360 --> 00:31:18,549
not for any type but rust needs on for

00:31:16,000 --> 00:31:22,029
any type now that's the exactly the kind

00:31:18,549 --> 00:31:26,110
of thing where it's totally fine to just

00:31:22,029 --> 00:31:28,269
emit dwarf that does that o debuggers

00:31:26,110 --> 00:31:29,919
are expected to skip things they don't

00:31:28,269 --> 00:31:33,460
understand and they would certainly just

00:31:29,919 --> 00:31:36,460
ignore those attributes so that's safe

00:31:33,460 --> 00:31:42,159
to just do but it's the kind of thing

00:31:36,460 --> 00:31:44,950
where because LLVM does not emit

00:31:42,159 --> 00:31:47,919
interface types at all you need to

00:31:44,950 --> 00:31:50,289
implement this in LLVM and get sign-off

00:31:47,919 --> 00:31:54,700
from the LLVM debug maintainer x' that

00:31:50,289 --> 00:31:56,649
it's a good idea so oh so you know you

00:31:54,700 --> 00:31:58,809
think well I should file a dwarf root

00:31:56,649 --> 00:32:00,850
bug report but if you look at the to do

00:31:58,809 --> 00:32:02,769
if you look at this slide it's like

00:32:00,850 --> 00:32:06,250
that's the last thing you should do

00:32:02,769 --> 00:32:10,480
because normally what you want to do is

00:32:06,250 --> 00:32:12,580
implement the entire thing so that any

00:32:10,480 --> 00:32:15,909
problems in the process can be caught

00:32:12,580 --> 00:32:21,700
before you try to you know standardize

00:32:15,909 --> 00:32:24,730
this now the LLVM maintainer x' have

00:32:21,700 --> 00:32:27,789
been pretty pretty good about this so

00:32:24,730 --> 00:32:30,100
it's not like a giant problem or some

00:32:27,789 --> 00:32:31,419
complicated negotiation they're usually

00:32:30,100 --> 00:32:34,750
just like yeah whatever

00:32:31,419 --> 00:32:39,159
in my experience but still it has to be

00:32:34,750 --> 00:32:41,470
done so you get all this stuff into LLVM

00:32:39,159 --> 00:32:43,990
to mid interfaces and describe them and

00:32:41,470 --> 00:32:47,380
associate them with types which is

00:32:43,990 --> 00:32:49,539
slightly tricky given you know how LLVM

00:32:47,380 --> 00:32:51,730
happens to work in this area but it's

00:32:49,539 --> 00:32:56,470
not impossible

00:32:51,730 --> 00:32:59,019
then the way I do these projects as next

00:32:56,470 --> 00:33:01,539
I well usually what I actually do is I

00:32:59,019 --> 00:33:03,370
do this end to end I do all the patches

00:33:01,539 --> 00:33:06,820
first before submitting anything to make

00:33:03,370 --> 00:33:11,260
sure it actually works but you still

00:33:06,820 --> 00:33:13,960
want to stage how you land things so

00:33:11,260 --> 00:33:16,660
after you land the LLVM changes then you

00:33:13,960 --> 00:33:19,450
land the debugger changes so you update

00:33:16,660 --> 00:33:21,340
the debuggers like in a case like this

00:33:19,450 --> 00:33:24,460
you'd want to update the dwarf readers

00:33:21,340 --> 00:33:27,309
to understand the new attributes and to

00:33:24,460 --> 00:33:30,100
change like the data types that the

00:33:27,309 --> 00:33:32,380
debugger operates with and then update

00:33:30,100 --> 00:33:37,570
the expression evaluators to know how to

00:33:32,380 --> 00:33:40,600
do this method lookup before you basic

00:33:37,570 --> 00:33:42,280
question sure yeah we don't directly

00:33:40,600 --> 00:33:43,450
admit work right so the reason we have

00:33:42,280 --> 00:33:48,150
to change all of em is that we're

00:33:43,450 --> 00:33:50,830
admitting some yeah that's right yes

00:33:48,150 --> 00:33:54,490
LLVM has this there's this whole thing

00:33:50,830 --> 00:33:57,580
called di builders debug info builders

00:33:54,490 --> 00:34:01,059
and that's the primary thing that rust

00:33:57,580 --> 00:34:06,669
calls into if you look at like the rust

00:34:01,059 --> 00:34:08,859
LLVM API that's in the tree like is it

00:34:06,669 --> 00:34:13,450
called rust wrapper I feel like I have a

00:34:08,859 --> 00:34:17,619
rust wrapper dot cpp and there's some

00:34:13,450 --> 00:34:20,830
file with the funny name FF ID IRS like

00:34:17,619 --> 00:34:24,639
in Lib rusty code Chen LLVM basically

00:34:20,830 --> 00:34:27,310
what you do is uh yes this is a kind of

00:34:24,639 --> 00:34:30,330
metadata that you construct and it just

00:34:27,310 --> 00:34:33,820
kind of hand off to LLVM and ignore so

00:34:30,330 --> 00:34:35,679
the rust can you know there's this part

00:34:33,820 --> 00:34:39,040
of the Russ compiler that takes like

00:34:35,679 --> 00:34:40,840
types you know it has the russ compiler

00:34:39,040 --> 00:34:44,230
notion of a type and it's as well like

00:34:40,840 --> 00:34:48,929
for this type I call these LLVM debug

00:34:44,230 --> 00:34:50,889
info builder methods to construct the

00:34:48,929 --> 00:34:55,119
representation of this type you know

00:34:50,889 --> 00:34:58,150
yeah when you do that compose the LVM

00:34:55,119 --> 00:35:00,340
change I guess you would say what work

00:34:58,150 --> 00:35:03,609
gets converted into would you also talk

00:35:00,340 --> 00:35:06,670
about what like pdb time or is that

00:35:03,609 --> 00:35:11,590
usually less stuff well you can you know

00:35:06,670 --> 00:35:14,760
now I like when I did this for in ohms

00:35:11,590 --> 00:35:17,910
I just didn't because

00:35:14,760 --> 00:35:19,500
I don't know what P DBT meant you know I

00:35:17,910 --> 00:35:24,420
like I know absolutely nothing about

00:35:19,500 --> 00:35:27,960
that and my impression was that in LOV M

00:35:24,420 --> 00:35:35,130
that is not required because no one even

00:35:27,960 --> 00:35:36,839
mentioned it so you know I think I don't

00:35:35,130 --> 00:35:38,670
know the impression I was left with is

00:35:36,839 --> 00:35:42,770
that the pdb stuff is relatively

00:35:38,670 --> 00:35:42,770
immature and so it's not like I

00:35:42,950 --> 00:35:49,040
something that they require when you

00:35:45,630 --> 00:35:54,150
change to bug info builder stuff so yeah

00:35:49,040 --> 00:35:56,609
I you know that surprised me a little I

00:35:54,150 --> 00:35:58,500
expected some kind of pushback so maybe

00:35:56,609 --> 00:36:01,829
that's something that will change in the

00:35:58,500 --> 00:36:03,720
future I really couldn't say so yeah if

00:36:01,829 --> 00:36:05,130
you do know stuff about PD be of course

00:36:03,720 --> 00:36:11,670
that those kind of things would be good

00:36:05,130 --> 00:36:13,770
to do you know but so anyway so we're at

00:36:11,670 --> 00:36:17,099
the stage where you update the debuggers

00:36:13,770 --> 00:36:20,280
for you know to understand this stuff

00:36:17,099 --> 00:36:21,690
and you know you can punt on that a

00:36:20,280 --> 00:36:24,480
little if you need to you or whatever

00:36:21,690 --> 00:36:26,880
like I pictured probably trying to

00:36:24,480 --> 00:36:29,220
implement the method calls but not

00:36:26,880 --> 00:36:30,660
operator overloading at first just

00:36:29,220 --> 00:36:35,099
trying to make the problem a little

00:36:30,660 --> 00:36:37,319
simpler and also because in my

00:36:35,099 --> 00:36:40,020
experience people actually report bugs

00:36:37,319 --> 00:36:41,640
about method calls but nobody has ever

00:36:40,020 --> 00:36:44,000
reported a bug about operator

00:36:41,640 --> 00:36:44,000
overloading

00:36:45,190 --> 00:36:50,980
once the debugger changes land then you

00:36:47,050 --> 00:36:55,960
can go and update the RUS compiler and

00:36:50,980 --> 00:37:00,010
change it to actually emit this new

00:36:55,960 --> 00:37:03,880
information or more precisely now you

00:37:00,010 --> 00:37:07,420
can land the change you know it's best

00:37:03,880 --> 00:37:14,200
to write everything first so that you

00:37:07,420 --> 00:37:16,680
know it actually works contend now and

00:37:14,200 --> 00:37:21,400
this is the step where see if we had

00:37:16,680 --> 00:37:22,960
both debuggers in rostov this would be

00:37:21,400 --> 00:37:26,500
much more seamless because you could

00:37:22,960 --> 00:37:29,319
land the debugger changes and then land

00:37:26,500 --> 00:37:31,930
the RUS compiler change and people on

00:37:29,319 --> 00:37:35,109
nightly you know when they updated

00:37:31,930 --> 00:37:37,300
everything would keep working or they

00:37:35,109 --> 00:37:40,619
would just have immediate access to the

00:37:37,300 --> 00:37:40,619
new features like in this case

00:37:42,160 --> 00:37:45,700
the butters would you know Aldi butters

00:37:44,019 --> 00:37:47,680
would still work fine because they would

00:37:45,700 --> 00:37:50,740
just ignore the extension but there are

00:37:47,680 --> 00:37:53,170
other cases maybe where you omit

00:37:50,740 --> 00:37:57,549
something new you know like the enum

00:37:53,170 --> 00:38:00,279
changes home were more in a quandary

00:37:57,549 --> 00:38:03,039
where if you change the debug output old

00:38:00,279 --> 00:38:06,549
debuggers will just stop working but on

00:38:03,039 --> 00:38:10,750
the other hand it fixed other bugs in

00:38:06,549 --> 00:38:12,609
the older bunch and yeah so um yeah yeah

00:38:10,750 --> 00:38:14,109
this seems like a reason also to if we

00:38:12,609 --> 00:38:17,440
can get to the point remember say you

00:38:14,109 --> 00:38:19,809
must use the rest oh yeah exactly that's

00:38:17,440 --> 00:38:22,059
right that would be that would be

00:38:19,809 --> 00:38:26,640
preferable because it would let us um

00:38:22,059 --> 00:38:26,640
control our own destiny a little better

00:38:27,180 --> 00:38:33,910
then but you know like you know that

00:38:31,690 --> 00:38:35,680
said like my view is generally it's

00:38:33,910 --> 00:38:39,480
better to work with upstream so I like

00:38:35,680 --> 00:38:42,880
to try to get things into you know like

00:38:39,480 --> 00:38:45,009
to like the last step here file a dwarf

00:38:42,880 --> 00:38:49,059
bug with an explanation

00:38:45,009 --> 00:38:53,589
you know dwarf is a pretty opaque

00:38:49,059 --> 00:38:55,569
process so you know like you'll file a

00:38:53,589 --> 00:38:56,950
bug and it's not like github where you

00:38:55,569 --> 00:38:59,259
file a bug and it's just there and you

00:38:56,950 --> 00:39:01,779
can comment on it you file a bug and

00:38:59,259 --> 00:39:03,519
then a few weeks later someone emails

00:39:01,779 --> 00:39:05,440
you and says thanks we've accepted your

00:39:03,519 --> 00:39:08,380
body now it's like a page on a website

00:39:05,440 --> 00:39:12,150
that's read-only so that's it's kind of

00:39:08,380 --> 00:39:16,799
a weird thing but it's still good to

00:39:12,150 --> 00:39:16,799
kind of close the loop or like you know

00:39:17,250 --> 00:39:23,619
GB patches should go into GB and I tried

00:39:21,519 --> 00:39:25,660
to get the hello DB patches into L LD be

00:39:23,619 --> 00:39:27,670
you know but like you know well you know

00:39:25,660 --> 00:39:31,210
and some did go in right like any kind

00:39:27,670 --> 00:39:34,480
of bug fixes but my idea is that not to

00:39:31,210 --> 00:39:37,380
just use this ability to sort of just go

00:39:34,480 --> 00:39:39,549
off in some new direction but to

00:39:37,380 --> 00:39:42,750
continue to work with other existing

00:39:39,549 --> 00:39:42,750
projects anyway

00:39:42,810 --> 00:39:48,630
this process that kind of outlined here

00:39:45,930 --> 00:39:52,680
is the typical process for a big debug

00:39:48,630 --> 00:39:56,420
info change and it's not uncommon to do

00:39:52,680 --> 00:39:59,940
multiple passes through it where you

00:39:56,420 --> 00:40:04,170
write some changes and then you have to

00:39:59,940 --> 00:40:07,200
go back and do things again like maybe

00:40:04,170 --> 00:40:10,170
the LLVM review wanted API changes so

00:40:07,200 --> 00:40:14,240
then you have to tweak LLVM and the

00:40:10,170 --> 00:40:16,650
compiler again or maybe the LLVM review

00:40:14,240 --> 00:40:19,380
wanted the dwarf to be written

00:40:16,650 --> 00:40:22,710
differently so then you have to change

00:40:19,380 --> 00:40:27,270
the debuggers again well so it's not too

00:40:22,710 --> 00:40:32,610
unusual dye have to repeat all this you

00:40:27,270 --> 00:40:34,950
know and it's also yeah my experience

00:40:32,610 --> 00:40:36,810
was with it was a little bit bad because

00:40:34,950 --> 00:40:40,470
I feel like I was doing one of these

00:40:36,810 --> 00:40:42,150
multiple pass things and rust upgraded

00:40:40,470 --> 00:40:44,490
LLVM and then everything happened to be

00:40:42,150 --> 00:40:50,540
full reported I don't know that stuff

00:40:44,490 --> 00:40:50,540
gets to be kind of nightmarish okay

00:40:51,680 --> 00:40:56,060
still on things

00:40:53,570 --> 00:40:59,360
missing there's this open bug about

00:40:56,060 --> 00:41:01,850
macro stepping where the question is

00:40:59,360 --> 00:41:04,160
like what is the location you remit for

00:41:01,850 --> 00:41:06,980
a macro expansion you have multiple

00:41:04,160 --> 00:41:10,010
choices you can omit a location of the

00:41:06,980 --> 00:41:12,140
invocation of the macro you can omit the

00:41:10,010 --> 00:41:14,270
location of the definition of the macro

00:41:12,140 --> 00:41:16,820
or if you have a really complicated

00:41:14,270 --> 00:41:20,060
macro you can even omit locations for

00:41:16,820 --> 00:41:23,060
the contents of the macro you know or

00:41:20,060 --> 00:41:29,620
like the arguments some of them or maybe

00:41:23,060 --> 00:41:29,620
all of them so there's this RFC about it

00:41:30,619 --> 00:41:35,089
I think the Connelly there's some

00:41:32,599 --> 00:41:39,259
there's a flag but the flag is kind of

00:41:35,089 --> 00:41:41,599
global so it's not really good and so

00:41:39,259 --> 00:41:45,109
the idea is to let macros decide what to

00:41:41,599 --> 00:41:48,799
do by having some kind of attribute that

00:41:45,109 --> 00:41:52,009
lets them tell the compiler where line

00:41:48,799 --> 00:41:54,440
markers should be and what that affects

00:41:52,009 --> 00:41:57,529
is where you can set breakpoints and

00:41:54,440 --> 00:41:58,970
what happens when you step up so you're

00:41:57,529 --> 00:42:01,940
stepping through the code and does it

00:41:58,970 --> 00:42:04,609
jump onto some thing over here or does

00:42:01,940 --> 00:42:07,819
it you know like further say a simple

00:42:04,609 --> 00:42:10,009
case the print line macro should just be

00:42:07,819 --> 00:42:12,680
like a function call you step onto that

00:42:10,009 --> 00:42:14,539
line of source and then the next time

00:42:12,680 --> 00:42:17,440
you hit next it goes to the next line of

00:42:14,539 --> 00:42:19,970
source and you don't try to go off into

00:42:17,440 --> 00:42:23,470
wherever print line the macro was

00:42:19,970 --> 00:42:27,740
defined but other ones may be different

00:42:23,470 --> 00:42:29,269
this is one that this is a debugging bug

00:42:27,740 --> 00:42:33,519
that can be done entirely in the RUS

00:42:29,269 --> 00:42:33,519
compiler yeah what's up

00:42:34,710 --> 00:42:39,600
hmm I thought someone was gonna say

00:42:36,960 --> 00:42:41,610
something oh yeah no sorry I didn't

00:42:39,600 --> 00:42:43,230
realize that my um using you all night I

00:42:41,610 --> 00:42:44,940
might tell you something yeah no I

00:42:43,230 --> 00:42:48,720
actually gonna ask you about debugging

00:42:44,940 --> 00:42:53,430
macros now you're writing a macro how do

00:42:48,720 --> 00:42:57,750
you - EE bug it yeah you know that's a

00:42:53,430 --> 00:43:02,070
whole different thing like um so yes I

00:42:57,750 --> 00:43:03,570
don't know GB or ll DB don't really try

00:43:02,070 --> 00:43:07,290
to deal with that because they don't

00:43:03,570 --> 00:43:12,710
have nearly enough information do you

00:43:07,290 --> 00:43:15,660
mean debugging macro expansion no well

00:43:12,710 --> 00:43:18,600
you're writing a brand new macro you've

00:43:15,660 --> 00:43:21,590
made it you're trying to test the seats

00:43:18,600 --> 00:43:24,300
is doing what you expect it to do and

00:43:21,590 --> 00:43:26,310
you know you need to debug it in some

00:43:24,300 --> 00:43:29,460
way hey I'm thing about procedural

00:43:26,310 --> 00:43:32,550
macros not um yeah what would be other

00:43:29,460 --> 00:43:33,900
types in my brain that works oh you mean

00:43:32,550 --> 00:43:36,990
like you want to step through the

00:43:33,900 --> 00:43:40,790
procedural macro as it executes exactly

00:43:36,990 --> 00:43:40,790
doesn't change exactly what's going on

00:43:40,880 --> 00:43:45,930
yeah and I'm also thinking about where

00:43:44,250 --> 00:43:47,820
you're using once you know another

00:43:45,930 --> 00:43:49,320
procedural macro inside of a different

00:43:47,820 --> 00:43:51,510
macro you know for example we read your

00:43:49,320 --> 00:43:53,850
procedural macro and inside there you've

00:43:51,510 --> 00:43:56,460
got a Bex it you know BEC macro or a

00:43:53,850 --> 00:43:58,110
print line or something else so now now

00:43:56,460 --> 00:44:00,810
you technically have a whole stack of

00:43:58,110 --> 00:44:04,260
execution frames or contacts or whatever

00:44:00,810 --> 00:44:07,230
you want to call them yeah does that

00:44:04,260 --> 00:44:09,000
make sense it does it's probably a as

00:44:07,230 --> 00:44:12,660
much a rusty problem I would imagine a

00:44:09,000 --> 00:44:16,470
cargo problem in other words we are the

00:44:12,660 --> 00:44:19,470
ones who invoke that code so you would

00:44:16,470 --> 00:44:22,080
do you probably could even do it today

00:44:19,470 --> 00:44:24,990
just by running rusty and like gdb but

00:44:22,080 --> 00:44:27,270
and saying breakpoints appropriately if

00:44:24,990 --> 00:44:28,950
you could that would require you to know

00:44:27,270 --> 00:44:33,180
a lot about yeah you'd have to once

00:44:28,950 --> 00:44:36,630
again see - yeah you know I think this

00:44:33,180 --> 00:44:38,520
is yes there's I have not looked at this

00:44:36,630 --> 00:44:40,470
problem I I consider it kind of a

00:44:38,520 --> 00:44:42,590
separate problem but it's definitely

00:44:40,470 --> 00:44:45,780
something that needs to be solved like

00:44:42,590 --> 00:44:48,180
you know my experience with C++ is like

00:44:45,780 --> 00:44:50,279
you can write these hairy contexts BRR

00:44:48,180 --> 00:44:53,279
things that are run at compile time you

00:44:50,279 --> 00:44:56,309
know whole functions and stuff and how

00:44:53,279 --> 00:44:58,619
do you debug those there's no way well

00:44:56,309 --> 00:45:00,150
there should be a way because you're

00:44:58,619 --> 00:45:03,089
writing code and it's gonna have bugs

00:45:00,150 --> 00:45:05,670
and it's tricky to get in there you know

00:45:03,089 --> 00:45:08,400
and I think gross it's dumb but because

00:45:05,670 --> 00:45:10,950
you know if you look at anything with

00:45:08,400 --> 00:45:13,230
like booths and they're crazy niceness

00:45:10,950 --> 00:45:15,420
of template metaprogramming yeah yet

00:45:13,230 --> 00:45:18,299
once wrong the template and the compiler

00:45:15,420 --> 00:45:20,160
you know hits point we've had 10,000

00:45:18,299 --> 00:45:22,619
errors and says no I'm just not going to

00:45:20,160 --> 00:45:24,240
go continue compiling yeah when you find

00:45:22,619 --> 00:45:26,130
is your one template can you change that

00:45:24,240 --> 00:45:29,039
one tiny thing and all good everything

00:45:26,130 --> 00:45:31,470
work yeah yeah that's how it should be

00:45:29,039 --> 00:45:33,180
yeah well I think these are things that

00:45:31,470 --> 00:45:36,750
I mean they're good ideas there's

00:45:33,180 --> 00:45:40,140
something that need to be done either in

00:45:36,750 --> 00:45:42,450
the compiler or by some other program

00:45:40,140 --> 00:45:46,349
that reuses the same machinery that the

00:45:42,450 --> 00:45:49,410
compiler uses you know but it's not out

00:45:46,349 --> 00:45:53,220
of scope before that is doing so I just

00:45:49,410 --> 00:45:55,799
wanted to point out that it's 10:50 yes

00:45:53,220 --> 00:45:58,109
um I actually have a have to go at 11:00

00:45:55,799 --> 00:46:00,450
and I think when I go the zooms in gets

00:45:58,109 --> 00:46:01,529
canceled I have two more things to talk

00:46:00,450 --> 00:46:04,140
about and then we're done

00:46:01,529 --> 00:46:06,660
okay I have a question also yeah go

00:46:04,140 --> 00:46:08,339
ahead I realized I forgot to reason it

00:46:06,660 --> 00:46:10,920
sort of relates to the trade dispatching

00:46:08,339 --> 00:46:14,010
thing one of the things I would like to

00:46:10,920 --> 00:46:16,770
at some point doing in Russy is to

00:46:14,010 --> 00:46:18,150
generate one copy of a function I take

00:46:16,770 --> 00:46:21,359
what would be multiple monomorphic

00:46:18,150 --> 00:46:24,410
functions and collapse them into one bit

00:46:21,359 --> 00:46:28,740
of generated code yeah is there anything

00:46:24,410 --> 00:46:31,200
like that indoor today uh Swift I know

00:46:28,740 --> 00:46:34,859
does this but they probably just don't

00:46:31,200 --> 00:46:37,200
use ID oh yeah

00:46:34,859 --> 00:46:38,970
that's no there's nothing there is

00:46:37,200 --> 00:46:43,140
nothing for that and actually there's

00:46:38,970 --> 00:46:44,849
another thing in Ross that requires this

00:46:43,140 --> 00:46:47,670
is something else I just remembered

00:46:44,849 --> 00:46:51,150
which is if you have if you if the

00:46:47,670 --> 00:46:56,010
compiler chooses to omit functions with

00:46:51,150 --> 00:46:58,230
some like kind of change to the calling

00:46:56,010 --> 00:47:00,240
convention you know dwarf relies on

00:46:58,230 --> 00:47:01,930
debuggers to know some stuff about the

00:47:00,240 --> 00:47:05,380
platform ABI

00:47:01,930 --> 00:47:08,680
and but like rust doesn't always do that

00:47:05,380 --> 00:47:10,690
right like suppose suppose you call a

00:47:08,680 --> 00:47:12,550
function with a tuple but the function D

00:47:10,690 --> 00:47:14,800
structures the tuple rust might choose

00:47:12,550 --> 00:47:19,150
to D structure the tuple at call time

00:47:14,800 --> 00:47:20,920
and that is something that you would

00:47:19,150 --> 00:47:24,430
have to be able to tell the dwarf hey

00:47:20,920 --> 00:47:26,260
this function um you know the type of

00:47:24,430 --> 00:47:28,300
this function is this thing but the

00:47:26,260 --> 00:47:29,980
effective calling convention is this

00:47:28,300 --> 00:47:30,690
other thing and there's no way to do

00:47:29,980 --> 00:47:36,220
that either

00:47:30,690 --> 00:47:40,200
okay yeah so yeah um you may need more

00:47:36,220 --> 00:47:42,490
extensions yeah stuff for the future

00:47:40,200 --> 00:47:45,040
Michael well wrister has been talking

00:47:42,490 --> 00:47:49,020
about changing rust name mangling which

00:47:45,040 --> 00:47:52,930
i think is a very good idea but to

00:47:49,020 --> 00:47:56,080
really do that you need to write new D

00:47:52,930 --> 00:47:59,170
manglers one has to go in this thing

00:47:56,080 --> 00:48:02,560
called Liberty which is shared by GCC

00:47:59,170 --> 00:48:05,080
and GB and a bonito you know the ganoub

00:48:02,560 --> 00:48:06,730
in utils but it's in the GCC source tree

00:48:05,080 --> 00:48:08,320
that's where its canonically maintained

00:48:06,730 --> 00:48:11,110
so you'd have to write a new rusty mango

00:48:08,320 --> 00:48:14,590
there and then lld B also has a deep

00:48:11,110 --> 00:48:16,030
angler or maybe it's in LVM now I things

00:48:14,590 --> 00:48:18,910
change there and I didn't really follow

00:48:16,030 --> 00:48:23,800
what was going on um but so you need to

00:48:18,910 --> 00:48:28,720
write new ones and land them the GCC one

00:48:23,800 --> 00:48:33,360
is particularly tricky maybe because the

00:48:28,720 --> 00:48:35,770
at least the C++ one was written home

00:48:33,360 --> 00:48:38,020
first of all it's all pure C code which

00:48:35,770 --> 00:48:40,240
is a little harder to deal with and it

00:48:38,020 --> 00:48:42,730
was written in this style where it can

00:48:40,240 --> 00:48:45,070
optionally do no allocation so that it

00:48:42,730 --> 00:48:49,990
could be used from signal handlers so

00:48:45,070 --> 00:48:54,000
it's like super you know maybe you could

00:48:49,990 --> 00:48:56,170
just skip that part I don't know okay so

00:48:54,000 --> 00:48:57,460
that's one thing that needs to be done

00:48:56,170 --> 00:48:59,650
in the future

00:48:57,460 --> 00:49:01,930
and another one is this idea comes up a

00:48:59,650 --> 00:49:03,820
lot about of instead of having the

00:49:01,930 --> 00:49:06,520
debuggers implement their own sorta

00:49:03,820 --> 00:49:10,860
half-assed expression parsers why not

00:49:06,520 --> 00:49:10,860
just reuse the rest compiler and

00:49:11,040 --> 00:49:17,400
a good idea one way it's a good idea is

00:49:15,360 --> 00:49:21,750
that the debuggers by and large don't

00:49:17,400 --> 00:49:27,240
try to implement type inference it's

00:49:21,750 --> 00:49:28,830
just too hard so it means that when

00:49:27,240 --> 00:49:30,930
you're typing in the debugger sometimes

00:49:28,830 --> 00:49:33,450
you need to be much more explicit than

00:49:30,930 --> 00:49:36,360
you would normally need to be in your

00:49:33,450 --> 00:49:39,120
actual rough source code you know like

00:49:36,360 --> 00:49:40,830
there's a sort of principle that the

00:49:39,120 --> 00:49:43,740
ideal for a debugger would be you could

00:49:40,830 --> 00:49:45,540
copy a piece of like say an expression

00:49:43,740 --> 00:49:47,070
from your source paste it into the

00:49:45,540 --> 00:49:49,290
debugger and it would evaluate it and

00:49:47,070 --> 00:49:51,060
get the same answer but without all the

00:49:49,290 --> 00:49:54,410
features of the compiler like type

00:49:51,060 --> 00:49:59,580
inference that can't reasonably be done

00:49:54,410 --> 00:50:01,850
so reusing the compilers parser is

00:49:59,580 --> 00:50:05,400
certainly doable it's a large project

00:50:01,850 --> 00:50:07,830
you still need some kind of bridge to

00:50:05,400 --> 00:50:10,700
the debugger because the debugger is the

00:50:07,830 --> 00:50:12,930
only thing that has access to memory so

00:50:10,700 --> 00:50:17,220
they need to communicate

00:50:12,930 --> 00:50:21,300
now both lld be handy to be do some do

00:50:17,220 --> 00:50:25,230
have features like this lldp uses clang

00:50:21,300 --> 00:50:29,280
to compile code to get into the inferior

00:50:25,230 --> 00:50:33,240
and gb can do that with GCC as well so

00:50:29,280 --> 00:50:38,850
it could be done however there's also

00:50:33,240 --> 00:50:40,670
this issue where both of these both of

00:50:38,850 --> 00:50:43,530
the debuggers expression evaluators

00:50:40,670 --> 00:50:47,280
implement both a superset and a subset

00:50:43,530 --> 00:50:49,200
and a subset and a superset of rust so

00:50:47,280 --> 00:50:51,030
they implement just the expression

00:50:49,200 --> 00:50:53,010
language but they also add some

00:50:51,030 --> 00:50:58,490
extensions like GEB has this thing

00:50:53,010 --> 00:50:58,490
called convenience variables and

00:50:59,450 --> 00:51:03,980
ella debe has some similar of similar

00:51:01,609 --> 00:51:06,619
kind of things but there's also some

00:51:03,980 --> 00:51:08,809
other extensions for like you know in

00:51:06,619 --> 00:51:10,640
rust your kind of you declare what

00:51:08,809 --> 00:51:12,349
you're going to use the file that you're

00:51:10,640 --> 00:51:14,359
doing like which crates you might refer

00:51:12,349 --> 00:51:15,680
to but in debuggers it's convenient to

00:51:14,359 --> 00:51:17,119
just be able to refer to anything

00:51:15,680 --> 00:51:19,250
anywhere at any time

00:51:17,119 --> 00:51:22,819
so like gb has an extension to let you

00:51:19,250 --> 00:51:24,650
do that so if you're going to take this

00:51:22,819 --> 00:51:27,200
route you not only need to do this

00:51:24,650 --> 00:51:31,579
bridge but you also may have to add some

00:51:27,200 --> 00:51:38,299
mode to let the compiler understand some

00:51:31,579 --> 00:51:40,040
extensions think yeah but I think yeah

00:51:38,299 --> 00:51:42,950
that's all I was gonna say about that is

00:51:40,040 --> 00:51:45,799
that probably that I'm hoping that the

00:51:42,950 --> 00:51:48,380
outcome is like WG grande mode hopefully

00:51:45,799 --> 00:51:50,809
the canonical rest gamer you know

00:51:48,380 --> 00:51:54,109
described in some form you can generate

00:51:50,809 --> 00:51:56,210
they allow us to generate parsers you

00:51:54,109 --> 00:52:00,920
know and subsets and supersets diamond

00:51:56,210 --> 00:52:02,990
without actually need to share well do

00:52:00,920 --> 00:52:04,940
you sure yeah like let's see like with

00:52:02,990 --> 00:52:07,670
the type inference it's not just about

00:52:04,940 --> 00:52:13,280
the parsing but also about some of the

00:52:07,670 --> 00:52:17,270
semantic analysis yeah yeah so we'll see

00:52:13,280 --> 00:52:19,700
that's a very yeah this is a good yes I

00:52:17,270 --> 00:52:21,530
thought I hope this was useful you know

00:52:19,700 --> 00:52:26,869
I wasn't really sure where to aim it all

00:52:21,530 --> 00:52:29,359
but okay good and you can reach out to

00:52:26,869 --> 00:52:30,230
me with you know questions or whatever

00:52:29,359 --> 00:52:35,059
I'm happy to help

00:52:30,230 --> 00:52:37,760
I'm gonna be still working on gdb so I

00:52:35,059 --> 00:52:40,690
can certainly help there actually I'd be

00:52:37,760 --> 00:52:44,930
good oh we should make sure we have to

00:52:40,690 --> 00:52:48,410
have a contact yeah I guess there's

00:52:44,930 --> 00:52:48,770
always I'll stick it on the slide sounds

00:52:48,410 --> 00:52:53,020
good

00:52:48,770 --> 00:52:57,309
thanks Tom yep cool thank you very much

00:52:53,020 --> 00:53:00,819
yeah talk to you later

00:52:57,309 --> 00:53:00,819

YouTube URL: https://www.youtube.com/watch?v=elBxMRSNYr4


