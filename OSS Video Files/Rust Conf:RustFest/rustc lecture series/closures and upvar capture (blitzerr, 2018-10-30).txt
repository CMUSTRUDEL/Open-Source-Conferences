Title: closures and upvar capture (blitzerr, 2018-10-30)
Publication date: 2019-04-29
Playlist: rustc lecture series
Description: 
	Discussing how closure desugaring and upvar inference works in rustc today with blitzerr on 2018-10-30
Captions: 
	00:00:00,170 --> 00:00:17,340
so so I think what our plan was is we

00:00:07,470 --> 00:00:18,830
were going to talk about like the how

00:00:17,340 --> 00:00:24,800
the closure stuff works today

00:00:18,830 --> 00:00:24,800
with the goal of hopefully getting to

00:00:25,099 --> 00:00:33,809
see what's on my screen the goal of

00:00:32,099 --> 00:00:37,530
eventually in figuring out how we're

00:00:33,809 --> 00:00:40,530
gonna do this closure the sugaring RFC

00:00:37,530 --> 00:00:45,390
right okay

00:00:40,530 --> 00:00:49,250
so figure out which first problem with

00:00:45,390 --> 00:00:49,250
my workspaces you should choose

00:00:59,620 --> 00:01:02,680
[Music]

00:01:03,110 --> 00:01:08,150
let me make a little branch with you

00:01:05,940 --> 00:01:08,150
guys

00:01:17,020 --> 00:01:22,790
all right

00:01:18,590 --> 00:01:28,189
so how much do you know about the the

00:01:22,790 --> 00:01:38,950
way US models closures actually I just

00:01:28,189 --> 00:01:41,750
read the rusty guide about okay so like

00:01:38,950 --> 00:01:47,810
the first thing is just to understand

00:01:41,750 --> 00:02:09,130
that when you let's show you a few

00:01:47,810 --> 00:02:09,130
examples here so

00:02:14,310 --> 00:02:27,040
okay so the first thing is when you make

00:02:21,760 --> 00:02:29,170
a closure invest this this this

00:02:27,040 --> 00:02:33,069
basically corresponds to some structure

00:02:29,170 --> 00:02:44,680
that implements the FN phase right that

00:02:33,069 --> 00:02:49,900
part so the interesting thing is if this

00:02:44,680 --> 00:02:55,530
closure should use a local variable then

00:02:49,900 --> 00:02:55,530
we compile this

00:02:55,569 --> 00:03:01,900
we basically analyze and figure out well

00:03:00,609 --> 00:03:03,909
we have two different modes but in the

00:03:01,900 --> 00:03:08,829
default mode we analyzed how this local

00:03:03,909 --> 00:03:10,150
variable is to use and figure out what

00:03:08,829 --> 00:03:12,670
the discovered version should look like

00:03:10,150 --> 00:03:14,230
right so essentially we're going to make

00:03:12,670 --> 00:03:16,870
some kind of structure it's like the

00:03:14,230 --> 00:03:19,090
closure struct and now we have some

00:03:16,870 --> 00:03:21,220
choices but for this field X that we

00:03:19,090 --> 00:03:25,569
captured we could either store a

00:03:21,220 --> 00:03:27,760
reference it's assumed X's of you 32 we

00:03:25,569 --> 00:03:29,230
could store it a reference to X or a

00:03:27,760 --> 00:03:33,639
mutable reference to X or we could just

00:03:29,230 --> 00:03:35,799
capture it by a value and the way we

00:03:33,639 --> 00:03:40,540
decide between those three is by looking

00:03:35,799 --> 00:03:47,019
at how X actually gets used so so like

00:03:40,540 --> 00:03:48,970
here it's even though X is mutable we're

00:03:47,019 --> 00:03:51,849
not actually doing anything to mutate X

00:03:48,970 --> 00:03:53,590
here we're just reading from it then

00:03:51,849 --> 00:04:04,230
we're gonna capture it as a shared

00:03:53,590 --> 00:04:06,970
borrow but if we were to mutate X

00:04:04,230 --> 00:04:07,960
now we would need a mutable borrow and

00:04:06,970 --> 00:04:14,230
we're actually going to get an error

00:04:07,960 --> 00:04:15,850
here now the problem is this the problem

00:04:14,230 --> 00:04:19,769
is that we specified we need an FN

00:04:15,850 --> 00:04:23,590
closure but if you kind of discover this

00:04:19,769 --> 00:04:26,490
you're going to have something that

00:04:23,590 --> 00:04:26,490
looks sort of like this

00:04:38,719 --> 00:04:45,289
something like that that's what the do

00:04:41,959 --> 00:04:51,579
sugar and the problem here is that if

00:04:45,289 --> 00:04:55,999
you have shared reference leading to

00:04:51,579 --> 00:04:57,469
unique reference immutable reckons that

00:04:55,999 --> 00:05:00,019
that mutable reference isn't really

00:04:57,469 --> 00:05:01,369
unique anymore right because you could

00:05:00,019 --> 00:05:04,099
copy the shared reference and then you

00:05:01,369 --> 00:05:06,259
have two paths that lead to it so that's

00:05:04,099 --> 00:05:08,539
the type checker that gets unhappy so

00:05:06,259 --> 00:05:10,189
that's kind of the root cause for this

00:05:08,539 --> 00:05:13,189
error right but the way you see it as a

00:05:10,189 --> 00:05:16,009
user is that we're telling you hey you

00:05:13,189 --> 00:05:17,959
can't use a shared FN closure you need

00:05:16,009 --> 00:05:21,050
an MMU closure because in order to

00:05:17,959 --> 00:05:30,759
mutate the state from your caller you

00:05:21,050 --> 00:05:34,489
need to have unique access that part

00:05:30,759 --> 00:05:36,199
that's not required right like that will

00:05:34,489 --> 00:05:39,349
be the dish you got part but if somebody

00:05:36,199 --> 00:05:41,989
happens to write just the main then and

00:05:39,349 --> 00:05:43,849
they remove the line it's the sequel to

00:05:41,989 --> 00:05:46,129
the last line basically we are

00:05:43,849 --> 00:05:48,739
incrementing X by one and they should be

00:05:46,129 --> 00:06:05,179
able to compile it just fine no but

00:05:48,739 --> 00:06:10,069
version using you mean like if I just

00:06:05,179 --> 00:06:11,389
assign the closure to a very poor yeah

00:06:10,069 --> 00:06:16,189
this this should work just fine

00:06:11,389 --> 00:06:18,519
and in fact it's also okay well if nll

00:06:16,189 --> 00:06:18,519
at least

00:06:22,460 --> 00:06:25,580
[Music]

00:06:30,880 --> 00:06:38,840
so this this will work fine you get if

00:06:35,750 --> 00:06:40,460
you're if you're in MLL mode you

00:06:38,840 --> 00:06:51,440
wouldn't have to it'll compile just fine

00:06:40,460 --> 00:06:55,100
because because the closure is dead here

00:06:51,440 --> 00:06:56,210
and it's Baro has ended yeah yeah the

00:06:55,100 --> 00:06:58,940
problem is more that we're falling

00:06:56,210 --> 00:07:03,550
through okay so the last thing to show

00:06:58,940 --> 00:07:07,060
is that there's another option which is

00:07:03,550 --> 00:07:07,060
this might be

00:07:10,889 --> 00:07:15,749
this you can either so far we've seen

00:07:13,680 --> 00:07:17,729
cases where we have our sheriff Baro

00:07:15,749 --> 00:07:20,129
you've seen case with a mutable Baro

00:07:17,729 --> 00:07:21,930
but it could also be a move all right

00:07:20,129 --> 00:07:23,669
and it's there's a common

00:07:21,930 --> 00:07:26,159
misunderstanding about move closers I

00:07:23,669 --> 00:07:27,629
haven't even talked about yet uh you

00:07:26,159 --> 00:07:31,349
don't need a move closer to have a move

00:07:27,629 --> 00:07:35,219
you can use that this code is going to

00:07:31,349 --> 00:07:37,590
insist you drop it's going to remove X

00:07:35,219 --> 00:07:39,300
from its parent so when the closure is

00:07:37,590 --> 00:07:40,860
constructed and needs ownership of the

00:07:39,300 --> 00:07:44,189
vector so it will go ahead and take

00:07:40,860 --> 00:07:48,210
ownership which means if I try to call X

00:07:44,189 --> 00:07:49,949
here I'm gonna get an error because like

00:07:48,210 --> 00:07:53,370
it says the value was moved into the

00:07:49,949 --> 00:07:56,129
closure and so that means I can't use it

00:07:53,370 --> 00:07:58,620
afterwards so this is kind of the

00:07:56,129 --> 00:08:03,629
analysis I was I wanted to kind of walk

00:07:58,620 --> 00:08:24,539
through how this works I think at a high

00:08:03,629 --> 00:08:28,379
level yes okay one way is you can dump

00:08:24,539 --> 00:08:31,020
the mirror this actually generates quite

00:08:28,379 --> 00:08:36,360
a lot of stuff why'd you dump well let's

00:08:31,020 --> 00:08:44,070
make one that actually compiles if I do

00:08:36,360 --> 00:08:46,560
dump your equals all for example now I'm

00:08:44,070 --> 00:08:49,050
gonna get you're gonna get a directory

00:08:46,560 --> 00:08:51,680
called mere dump and it has a whole

00:08:49,050 --> 00:08:54,029
bunch of files each one corresponds to

00:08:51,680 --> 00:08:55,680
some version of the mirror for some

00:08:54,029 --> 00:08:58,670
function as it goes through the

00:08:55,680 --> 00:09:01,050
transformations so in this case we want

00:08:58,670 --> 00:09:04,380
let's say the version of let's look at

00:09:01,050 --> 00:09:12,930
the main function and we might start

00:09:04,380 --> 00:09:14,220
with like no I usually look at the NLL

00:09:12,930 --> 00:09:18,260
ones actually because they're kind of in

00:09:14,220 --> 00:09:18,260
a good level of

00:09:18,970 --> 00:09:23,730
oops so

00:09:24,430 --> 00:09:34,220
so if we look at like rusty got named I

00:09:30,520 --> 00:09:43,460
want a log and all that in here this one

00:09:34,220 --> 00:09:45,890
here this contains what does this

00:09:43,460 --> 00:09:48,250
contain let's just clear out this

00:09:45,890 --> 00:09:48,250
directory

00:10:00,100 --> 00:10:05,410
okay I don't think I ran with in all so

00:10:02,410 --> 00:10:08,560
you don't get that but this this first

00:10:05,410 --> 00:10:10,690
file I think is the initial mirror that

00:10:08,560 --> 00:10:15,100
we build and then we do transformations

00:10:10,690 --> 00:10:16,770
on so this is for the main function it

00:10:15,100 --> 00:10:24,550
has a lot of junk

00:10:16,770 --> 00:10:26,710
the thing that somewhere here this most

00:10:24,550 --> 00:10:28,300
of that stuff okay so all this code I

00:10:26,710 --> 00:10:33,850
just skipped over this is just building

00:10:28,300 --> 00:10:35,050
the Hector it's right around here it's a

00:10:33,850 --> 00:10:38,950
little hard to parse but what's

00:10:35,050 --> 00:10:44,880
happening is this is the equivalent of

00:10:38,950 --> 00:10:47,590
saying this like we're building a struct

00:10:44,880 --> 00:10:52,150
but the name of this truck is this

00:10:47,590 --> 00:10:56,770
closure that's it's and you can see here

00:10:52,150 --> 00:11:01,090
that we actually moved the field and if

00:10:56,770 --> 00:11:07,840
we change this to doesn't change our

00:11:01,090 --> 00:11:11,470
input to let's say just era now we're

00:11:07,840 --> 00:11:18,460
mutating it but we're not moving it and

00:11:11,470 --> 00:11:21,490
we regenerate these files now we can see

00:11:18,460 --> 00:11:23,020
that we brought in underscore 6 which is

00:11:21,490 --> 00:11:31,270
Namsan so you can really see what's

00:11:23,020 --> 00:11:35,380
happening ok so let's see go back to my

00:11:31,270 --> 00:11:47,670
notes ok so first of all you can view

00:11:35,380 --> 00:11:47,670
the disha good form with - side open

00:11:54,640 --> 00:12:06,040
so well they're not that different

00:12:04,570 --> 00:12:08,920
I just didn't happen to be using it all

00:12:06,040 --> 00:12:15,030
in space there was no nitrogen if we did

00:12:08,920 --> 00:12:19,060
run with an oil then it would look like

00:12:15,030 --> 00:12:20,650
basically the same the main thing is if

00:12:19,060 --> 00:12:22,300
you look here there's all these

00:12:20,650 --> 00:12:24,430
different versions as we transform their

00:12:22,300 --> 00:12:25,690
color they're actually mostly not that

00:12:24,430 --> 00:12:28,270
different from one another so you could

00:12:25,690 --> 00:12:31,300
probably pick any one it'll be kind of

00:12:28,270 --> 00:12:36,310
okay but in some cases we do like

00:12:31,300 --> 00:12:39,220
optimizations that might make it like

00:12:36,310 --> 00:12:42,660
yeah okay so for example here in this

00:12:39,220 --> 00:12:49,600
version we no longer have that

00:12:42,660 --> 00:12:52,930
underscore 5 equals loser X we've sort

00:12:49,600 --> 00:12:58,510
of rewritten it to just say closure dot

00:12:52,930 --> 00:13:00,850
x equals because it's mortgage um so

00:12:58,510 --> 00:13:02,860
that's why I say like the NLL or this

00:13:00,850 --> 00:13:05,010
this very first one he's early enough

00:13:02,860 --> 00:13:08,010
that we haven't done much so looks

00:13:05,010 --> 00:13:08,010
similar

00:13:09,270 --> 00:13:15,220
yeah so so what happens in the compiler

00:13:12,220 --> 00:13:19,420
now so oh one last thing to mention it

00:13:15,220 --> 00:13:21,070
is is that all of this happens if you

00:13:19,420 --> 00:13:22,930
write a default closure if you write the

00:13:21,070 --> 00:13:25,720
move keyword we don't do any of this

00:13:22,930 --> 00:13:30,280
analysis we just always move that's all

00:13:25,720 --> 00:13:32,440
um but but but like I said it's not the

00:13:30,280 --> 00:13:38,280
only way to move it's just a way to for

00:13:32,440 --> 00:13:40,630
certain um and the way this works is

00:13:38,280 --> 00:13:44,470
there's like a couple of phases the

00:13:40,630 --> 00:13:48,940
first thing is somewhere I don't exactly

00:13:44,470 --> 00:13:51,940
remember where we have this notion of

00:13:48,940 --> 00:13:57,210
what the free variables of the closure

00:13:51,940 --> 00:13:57,210
are there's a square here

00:14:00,660 --> 00:14:07,029
yeah

00:14:01,870 --> 00:14:11,019
so what this does is you've sort of

00:14:07,029 --> 00:14:16,779
familiar with the Russ query system the

00:14:11,019 --> 00:14:20,440
rest of the query system right so this

00:14:16,779 --> 00:14:24,070
file is all the query is it yes this

00:14:20,440 --> 00:14:27,220
file is a why you can't see the very

00:14:24,070 --> 00:14:30,550
topics a view but basically it's like

00:14:27,220 --> 00:14:32,260
rusty type library there's a section in

00:14:30,550 --> 00:14:34,660
the rusty bucket it's probably the best

00:14:32,260 --> 00:14:37,930
thing but yeah lists all the queries and

00:14:34,660 --> 00:14:41,110
then somewhere there's a function that

00:14:37,930 --> 00:14:44,079
defines this query some reason I'm not

00:14:41,110 --> 00:14:47,490
finding probably because some of the

00:14:44,079 --> 00:14:47,490
queries are set up in a kind of like

00:15:04,949 --> 00:15:09,550
anyway somewhere around here somehow

00:15:07,750 --> 00:15:11,079
there's a notion of what the free

00:15:09,550 --> 00:15:12,760
variables are and this is just the local

00:15:11,079 --> 00:15:13,560
variables that the query happens to talk

00:15:12,760 --> 00:15:16,000
about

00:15:13,560 --> 00:15:17,800
so in this sorry not query but the

00:15:16,000 --> 00:15:22,750
closure happens so in this case the free

00:15:17,800 --> 00:15:25,209
bars would be X and we say three because

00:15:22,750 --> 00:15:28,000
they're not balanced like there's no

00:15:25,209 --> 00:15:38,260
definition of them inside the closure

00:15:28,000 --> 00:15:39,880
so there's C so in general a free

00:15:38,260 --> 00:15:42,850
variable is a variable that is

00:15:39,880 --> 00:15:45,910
referenced but not to find wise by

00:15:42,850 --> 00:15:47,529
something so you can say the free

00:15:45,910 --> 00:15:50,470
variables of the closure would be all

00:15:47,529 --> 00:15:57,029
the local variables that and it talks

00:15:50,470 --> 00:16:01,890
about but it doesn't define any more so

00:15:57,029 --> 00:16:05,140
in the we go into the Lib Russy

00:16:01,890 --> 00:16:05,140
[Music]

00:16:06,910 --> 00:16:20,450
if we look at the lip Russy type check

00:16:10,300 --> 00:16:21,670
sure well yeah I just like where to

00:16:20,450 --> 00:16:24,290
start from

00:16:21,670 --> 00:16:29,450
I'll start from here there's this file

00:16:24,290 --> 00:16:31,640
called up for RS and you can sort of see

00:16:29,450 --> 00:16:36,110
some of the documentation it has the job

00:16:31,640 --> 00:16:40,130
of figuring out for every free variable

00:16:36,110 --> 00:16:43,610
how does it get used and that that

00:16:40,130 --> 00:16:46,540
determines the mode for that free

00:16:43,610 --> 00:16:49,070
variable what we call the borrow kind

00:16:46,540 --> 00:16:51,380
should it be a shared borrow of mutable

00:16:49,070 --> 00:16:52,810
borrow or no borrow at all actually

00:16:51,380 --> 00:16:55,330
there's another mode I didn't talk about

00:16:52,810 --> 00:16:58,760
which is a unique and beautiful borrow

00:16:55,330 --> 00:16:59,839
not particularly important but it's kind

00:16:58,760 --> 00:17:01,430
of like basically there's just these

00:16:59,839 --> 00:17:02,270
levels that's the main thing based on

00:17:01,430 --> 00:17:11,329
how you use it

00:17:02,270 --> 00:17:14,290
and and that in turn defines sort of the

00:17:11,329 --> 00:17:19,189
minimum which traits the closure can for

00:17:14,290 --> 00:17:21,079
implements because if if all you do is

00:17:19,189 --> 00:17:23,449
if you have no free variable so you just

00:17:21,079 --> 00:17:26,300
read then you can implement the FN trait

00:17:23,449 --> 00:17:28,520
the SMU trade and the FN one straight

00:17:26,300 --> 00:17:31,610
because you can be called many times in

00:17:28,520 --> 00:17:34,400
parallel or sequentially which is like

00:17:31,610 --> 00:17:36,530
FM or exactly once it's fine

00:17:34,400 --> 00:17:38,780
but if you do more advanced operations

00:17:36,530 --> 00:17:41,059
like if you move something then you only

00:17:38,780 --> 00:17:42,320
implement FN once because you can't be

00:17:41,059 --> 00:17:44,780
called with other ways you have to be

00:17:42,320 --> 00:17:47,750
called exactly once you require

00:17:44,780 --> 00:17:51,260
ownership and similarly so we kind of

00:17:47,750 --> 00:17:55,730
infer all of this and the way it works

00:17:51,260 --> 00:18:00,020
is uses some kind of old and grotty

00:17:55,730 --> 00:18:02,210
color but anyway that I was someday like

00:18:00,020 --> 00:18:07,990
to remove called the expression use

00:18:02,210 --> 00:18:12,110
visitor and what this does is it walks

00:18:07,990 --> 00:18:14,080
the walks the here like the i/o so at

00:18:12,110 --> 00:18:16,330
this point we're representing rustiness

00:18:14,080 --> 00:18:20,500
you're familiar with it here it's like

00:18:16,330 --> 00:18:22,390
the syntax tree yeah so what's the

00:18:20,500 --> 00:18:27,760
source of the closure right in here and

00:18:22,390 --> 00:18:31,240
figures out it basically calls you back

00:18:27,760 --> 00:18:34,840
for everything that gets moved mutated

00:18:31,240 --> 00:18:36,280
or borrowed those kind of things so it

00:18:34,840 --> 00:18:40,900
was used to implement the old pirate

00:18:36,280 --> 00:18:42,640
record it still is but so basically it

00:18:40,900 --> 00:18:44,860
it's kind of exactly what we want here

00:18:42,640 --> 00:18:48,700
so in this case it might say you go back

00:18:44,860 --> 00:18:51,520
to our example if we use X let's say we

00:18:48,700 --> 00:18:54,340
use X twice but y equals x is zero this

00:18:51,520 --> 00:18:57,490
is gonna be a bar of shared borrow of X

00:18:54,340 --> 00:18:59,230
because we're reading and here we have X

00:18:57,490 --> 00:18:59,590
of 0 plus equals 1 we would get to Paul

00:18:59,230 --> 00:19:02,920
batts

00:18:59,590 --> 00:19:05,980
right one year saying there's a shared

00:19:02,920 --> 00:19:08,590
borrow and one here saying there's a

00:19:05,980 --> 00:19:15,460
mutable borrow and I'll also tell us

00:19:08,590 --> 00:19:21,640
what was borrowed and so those callbacks

00:19:15,460 --> 00:19:25,540
get invoked on this this delegate by the

00:19:21,640 --> 00:19:27,490
way just to the part of the reason I'm

00:19:25,540 --> 00:19:28,000
videotaping this do I know it's a lot of

00:19:27,490 --> 00:19:31,420
information

00:19:28,000 --> 00:19:33,130
cuz I plan to post it on youtube so you

00:19:31,420 --> 00:19:37,450
know it's some of these notes and things

00:19:33,130 --> 00:19:40,090
we could probably find haters so the

00:19:37,450 --> 00:19:45,760
infer Barrow kind so the delegate

00:19:40,090 --> 00:19:50,080
implements this struct this struct as a

00:19:45,760 --> 00:19:57,100
bunch of random stuff like context

00:19:50,080 --> 00:19:59,950
information but the main thing it has is

00:19:57,100 --> 00:20:02,410
this field that's tracking so oh here it

00:19:59,950 --> 00:20:04,420
says up far that's the same as free

00:20:02,410 --> 00:20:07,120
variable that's a tournament I don't

00:20:04,420 --> 00:20:09,400
know why but rusty uses it rivers I've

00:20:07,120 --> 00:20:13,090
never seen it outside of rusty for

00:20:09,400 --> 00:20:18,960
meaning a variable from the surrounding

00:20:13,090 --> 00:20:23,280
context so somewhere up yes

00:20:18,960 --> 00:20:27,450
so the up foreclosures this basically is

00:20:23,280 --> 00:20:29,670
saying for each of our what moment what

00:20:27,450 --> 00:20:31,410
mode did we require and as we see those

00:20:29,670 --> 00:20:33,540
callbacks will adjust it right so we'll

00:20:31,410 --> 00:20:36,000
start out saying we everything is just

00:20:33,540 --> 00:20:38,460
read because we haven't seen any uses

00:20:36,000 --> 00:20:40,470
yet and then if we see a move a mutate

00:20:38,460 --> 00:20:42,390
we'll bump it up to mutate if we see a

00:20:40,470 --> 00:20:44,700
move to bump it up to move they

00:20:42,390 --> 00:20:51,570
basically need the strictest one that we

00:20:44,700 --> 00:20:54,050
actually see and I think so they up for

00:20:51,570 --> 00:20:56,910
a capture map this is just a hash map

00:20:54,050 --> 00:21:01,440
going from the ID of the variable just

00:20:56,910 --> 00:21:02,910
some I get some in it index to is up for

00:21:01,440 --> 00:21:06,450
capture which tells you it's either

00:21:02,910 --> 00:21:16,230
moved or it's borrowed and what kind of

00:21:06,450 --> 00:21:19,980
borrowed so the actual callbacks there

00:21:16,230 --> 00:21:23,850
here we get like consume you get this

00:21:19,980 --> 00:21:28,350
consume callback if if we see a move of

00:21:23,850 --> 00:21:30,240
something we get the borrow callback if

00:21:28,350 --> 00:21:33,990
we see a borrow shared borrow or a

00:21:30,240 --> 00:21:35,790
mutable borrow or something and the rest

00:21:33,990 --> 00:21:38,430
of them mutate is when we see a

00:21:35,790 --> 00:21:42,240
assignment to something the rest I guess

00:21:38,430 --> 00:21:44,570
don't really matter so and in the

00:21:42,240 --> 00:21:48,660
callback we get this thing called a CMT

00:21:44,570 --> 00:21:52,500
which is an old data structure stands

00:21:48,660 --> 00:21:55,800
for like categorization suitability and

00:21:52,500 --> 00:21:59,670
tight yes but basically it represents

00:21:55,800 --> 00:22:02,670
yeah it basically represents what was

00:21:59,670 --> 00:22:06,750
your borrow removed so in mirror we call

00:22:02,670 --> 00:22:09,300
this a place so like if you had back to

00:22:06,750 --> 00:22:15,930
our example here I have X of 0 plus

00:22:09,300 --> 00:22:17,790
equals 1 it's actually a bit of a let's

00:22:15,930 --> 00:22:26,730
just simplify this for instance I just

00:22:17,790 --> 00:22:30,170
had this now the the CMT would just be

00:22:26,730 --> 00:22:32,269
for a local variable X you see it later

00:22:30,170 --> 00:22:34,409
so

00:22:32,269 --> 00:22:36,269
when we call one of these methods

00:22:34,409 --> 00:22:38,549
basically based on the kind of thing

00:22:36,269 --> 00:22:40,830
that happened we call a method saying

00:22:38,549 --> 00:22:43,049
adjust the bar Oh kind for this sort of

00:22:40,830 --> 00:22:45,389
access so this would be like for a

00:22:43,049 --> 00:22:46,889
mutable borrow this would be for a

00:22:45,389 --> 00:22:49,109
unique borrow I didn't talk about but

00:22:46,889 --> 00:22:50,960
that's the point in between so if a

00:22:49,109 --> 00:22:53,669
shared borrow let's we make aliases and

00:22:50,960 --> 00:22:56,519
requires immutability and a mutable

00:22:53,669 --> 00:22:56,970
borrow is unique and allows you to make

00:22:56,519 --> 00:22:59,940
a change

00:22:56,970 --> 00:23:03,570
mutation a unique borrow is unique but

00:22:59,940 --> 00:23:06,929
still a new book if the Pilar uses them

00:23:03,570 --> 00:23:08,369
internally because there are certain

00:23:06,929 --> 00:23:10,049
rules of rust who don't make sense to be

00:23:08,369 --> 00:23:17,220
open but they're not really something

00:23:10,049 --> 00:23:19,619
you talk about that's normally that's

00:23:17,220 --> 00:23:22,529
not so important but we come into this

00:23:19,619 --> 00:23:27,359
adjust thing and here we look we look at

00:23:22,529 --> 00:23:30,599
what was the what was the thing that got

00:23:27,359 --> 00:23:33,389
borrowed basically that's what this EMT

00:23:30,599 --> 00:23:34,919
got at that stands for category it's

00:23:33,389 --> 00:23:39,450
like look at the category of this thing

00:23:34,919 --> 00:23:45,659
is it a DRS so that would be like you

00:23:39,450 --> 00:23:50,279
know sans star X or an interior means

00:23:45,659 --> 00:23:52,590
like access to a field the details

00:23:50,279 --> 00:23:57,840
aren't well you can read them on your

00:23:52,590 --> 00:23:59,700
own time I guess so but basically this

00:23:57,840 --> 00:24:09,720
basically propagates down so the idea

00:23:59,700 --> 00:24:19,710
would be the simplest case is when the

00:24:09,720 --> 00:24:22,200
simplest case would be when yeah I don't

00:24:19,710 --> 00:24:23,369
know the simplest case would be like

00:24:22,200 --> 00:24:25,559
where it's just a local variable

00:24:23,369 --> 00:24:29,669
basically and then the more complex

00:24:25,559 --> 00:24:35,009
cases are like if you had let's say we

00:24:29,669 --> 00:24:36,840
had a tuple here let me add something

00:24:35,009 --> 00:24:39,519
like this

00:24:36,840 --> 00:24:52,480
then we would get a CMT telling us that

00:24:39,519 --> 00:24:54,519
this is X dot one yes and actually

00:24:52,480 --> 00:24:55,990
there's a service that's an important

00:24:54,519 --> 00:24:59,379
point in some sense that I'm skipping

00:24:55,990 --> 00:25:01,840
over I should say because I think that

00:24:59,379 --> 00:25:04,139
the CMT we get back actually looks a

00:25:01,840 --> 00:25:07,269
little bit different for those two cases

00:25:04,139 --> 00:25:08,710
so you will get callbacks in that cult

00:25:07,269 --> 00:25:11,289
like for example we would get a callback

00:25:08,710 --> 00:25:15,269
here too and this is a true local

00:25:11,289 --> 00:25:17,830
variable of the closure but in this case

00:25:15,269 --> 00:25:25,779
in the case where you access an up far

00:25:17,830 --> 00:25:28,690
it's gonna look C like this

00:25:25,779 --> 00:25:31,419
that's the actual path that you'll get a

00:25:28,690 --> 00:25:35,379
callback for here so we sort of see the

00:25:31,419 --> 00:25:38,409
D sugared path only there's a look I

00:25:35,379 --> 00:25:41,830
forget exactly how this works because we

00:25:38,409 --> 00:25:44,950
don't actually know yet I think yeah we

00:25:41,830 --> 00:25:48,870
see this path always we always see a

00:25:44,950 --> 00:25:55,929
star and then so there's some code you

00:25:48,870 --> 00:25:59,200
see here that if it sees a dear F of a

00:25:55,929 --> 00:26:06,309
borrowed pointer that would be this case

00:25:59,200 --> 00:26:09,100
star it's gonna go and look and see so

00:26:06,309 --> 00:26:13,029
we have this extra notes basically says

00:26:09,100 --> 00:26:14,409
this note thing is like saying where did

00:26:13,029 --> 00:26:16,870
this dear F come from was this

00:26:14,409 --> 00:26:20,039
implicitly inserted because it's an

00:26:16,870 --> 00:26:22,570
access to a closed referral and if so

00:26:20,039 --> 00:26:24,159
then we'll this is where the actual

00:26:22,570 --> 00:26:26,620
thing this is where the actual code is

00:26:24,159 --> 00:26:30,759
that changes okay then in that case we

00:26:26,620 --> 00:26:33,009
need to upgrade to a write for X dot one

00:26:30,759 --> 00:26:35,169
you know because now we saw a mutation

00:26:33,009 --> 00:26:37,919
or when he's upgraded to a mutable

00:26:35,169 --> 00:26:40,809
borrow of X whether it's this code here

00:26:37,919 --> 00:26:43,990
so so you will see this distinction that

00:26:40,809 --> 00:26:46,720
way um so yeah so that's that's

00:26:43,990 --> 00:26:48,279
basically it in some sense when it's all

00:26:46,720 --> 00:26:48,950
done once it's boxing the whole

00:26:48,279 --> 00:26:52,309
enclosure

00:26:48,950 --> 00:26:53,809
you have you've observed all the things

00:26:52,309 --> 00:26:58,210
that the cloture does and you figured

00:26:53,809 --> 00:27:00,500
out you have adjusted this map to be

00:26:58,210 --> 00:27:02,630
immutables or borrows or shares as it

00:27:00,500 --> 00:27:11,649
moves borrows yours whatever as

00:27:02,630 --> 00:27:17,929
appropriate then then we just kind of

00:27:11,649 --> 00:27:19,909
store it and store it in our so the

00:27:17,929 --> 00:27:22,880
output of type check is this whole bunch

00:27:19,909 --> 00:27:27,260
of tables hashmaps telling different

00:27:22,880 --> 00:27:29,659
things about the RUS program we just

00:27:27,260 --> 00:27:32,240
hijacked it in this case we store and

00:27:29,659 --> 00:27:37,220
say here's associated with disclosure

00:27:32,240 --> 00:27:39,440
yours the set of borrows that we did or

00:27:37,220 --> 00:27:44,029
the here's the news like the modes for

00:27:39,440 --> 00:27:48,860
each capture and then we'll also figure

00:27:44,029 --> 00:27:57,320
out it's the closure implements FM what

00:27:48,860 --> 00:27:59,000
and store that information but so that's

00:27:57,320 --> 00:28:02,269
that's this part of the code I wanted to

00:27:59,000 --> 00:28:20,120
walk through a little bit the question

00:28:02,269 --> 00:28:25,429
would be now very good question yes and

00:28:20,120 --> 00:28:27,860
no so one option is there are two ways

00:28:25,429 --> 00:28:29,960
to go about this you can build them you

00:28:27,860 --> 00:28:33,139
can disable optimizations and build a

00:28:29,960 --> 00:28:39,500
build with debug info and then you can

00:28:33,139 --> 00:28:41,929
use gdb or or better yet RR if you know

00:28:39,500 --> 00:28:43,309
there's sort of similar I don't know

00:28:41,929 --> 00:28:46,800
which platform you're on actually are

00:28:43,309 --> 00:28:49,410
you on Mac or Windows yeah

00:28:46,800 --> 00:28:53,010
okay so in that case I think LOV B is

00:28:49,410 --> 00:28:54,690
the debugger of choice um this I can

00:28:53,010 --> 00:28:57,650
point you it's in material tonight and

00:28:54,690 --> 00:28:59,700
as far as I know it should work okay but

00:28:57,650 --> 00:29:03,030
I don't have a lot of experience with

00:28:59,700 --> 00:29:04,680
that because we usually because

00:29:03,030 --> 00:29:08,040
disabling optimizations takes a long

00:29:04,680 --> 00:29:13,530
time for so the problem is that the

00:29:08,040 --> 00:29:14,940
compiler you build the compiler and then

00:29:13,530 --> 00:29:18,390
the compiler has to build the standard

00:29:14,940 --> 00:29:20,400
library so if you turn off optimizations

00:29:18,390 --> 00:29:21,960
in the compiler then it runs really

00:29:20,400 --> 00:29:26,030
slowly and takes a long time for it to

00:29:21,960 --> 00:29:27,990
build the standard library we'll see so

00:29:26,030 --> 00:29:31,170
so usually we don't turn off

00:29:27,990 --> 00:29:32,730
optimizations because it's it's kind of

00:29:31,170 --> 00:29:34,020
annoying but you know if you're willing

00:29:32,730 --> 00:29:36,030
to wait it might be worth it especially

00:29:34,020 --> 00:29:38,030
if if you're not if you're just putting

00:29:36,030 --> 00:29:41,940
to like walk through and not make

00:29:38,030 --> 00:29:44,820
changes then maybe it's worth it the

00:29:41,940 --> 00:29:47,970
other thing that I usually do you see

00:29:44,820 --> 00:29:50,360
already all these debug statements my

00:29:47,970 --> 00:29:55,670
usual strategy is to turn on debugging

00:29:50,360 --> 00:29:58,490
just dump everything save it to a file

00:29:55,670 --> 00:30:00,420
and kind of walk through but but that's

00:29:58,490 --> 00:30:03,900
for what you're trying to do it's

00:30:00,420 --> 00:30:05,490
obviously less less good because we have

00:30:03,900 --> 00:30:07,410
to sort of think of the questions before

00:30:05,490 --> 00:30:12,060
you happen so that you can print the

00:30:07,410 --> 00:30:17,900
answers so you could try a debug build I

00:30:12,060 --> 00:30:17,900
would be curious to hear how those be I

00:30:26,330 --> 00:30:33,600
think there's material about it in the

00:30:28,740 --> 00:30:36,810
rusty guide but if not I'll just tell

00:30:33,600 --> 00:30:44,250
you that you would open your config

00:30:36,810 --> 00:30:48,090
tunnel and change debug equals false

00:30:44,250 --> 00:30:49,560
to debug equals true and then I think

00:30:48,090 --> 00:30:52,380
you probably want to change optimized

00:30:49,560 --> 00:30:55,110
false at least it's been my experience

00:30:52,380 --> 00:30:57,940
that I love um it's not very good or

00:30:55,110 --> 00:31:02,020
about preserving debug information

00:30:57,940 --> 00:31:04,630
after doing optimizations and so the end

00:31:02,020 --> 00:31:06,490
result is that like most local variables

00:31:04,630 --> 00:31:08,230
it tells you they're optimized gallop

00:31:06,490 --> 00:31:18,640
and stuff like that so you can't

00:31:08,230 --> 00:31:20,050
actually get a lot of information main

00:31:18,640 --> 00:31:27,060
thing I would say is if you do this

00:31:20,050 --> 00:31:27,060
just just build when I do a build like

00:31:31,220 --> 00:31:38,490
with a command like this where you just

00:31:35,970 --> 00:31:40,440
build stage 1 so you're not going all

00:31:38,490 --> 00:31:42,090
the different phases and you just stop

00:31:40,440 --> 00:31:44,580
after building the standard library and

00:31:42,090 --> 00:31:47,100
stage one cuz that's a useable compiler

00:31:44,580 --> 00:31:48,360
that also reviews that'll do the minimum

00:31:47,100 --> 00:31:51,300
amount of building with your non

00:31:48,360 --> 00:31:52,200
optimized compiler that you can get in

00:31:51,300 --> 00:31:56,309
order to have something that's really

00:31:52,200 --> 00:31:58,410
usable you could in theory build a

00:31:56,309 --> 00:32:01,740
little basket with you or you could just

00:31:58,410 --> 00:32:02,160
build up or something no mic you're

00:32:01,740 --> 00:32:04,020
worth it

00:32:02,160 --> 00:32:07,020
Thanks just build the poor and write

00:32:04,020 --> 00:32:08,429
some those standard tests like like

00:32:07,020 --> 00:32:11,960
foreclosures you don't need the rest

00:32:08,429 --> 00:32:11,960
babies but I would probably just do this

00:32:16,970 --> 00:32:22,130
no no but you do have to do a clean bill

00:32:22,580 --> 00:32:37,740
it shouldn't leave all of um but I think

00:32:27,030 --> 00:32:39,630
otherwise it doesn't so I think I think

00:32:37,740 --> 00:32:41,429
this information regarding the RFC in

00:32:39,630 --> 00:32:44,210
question I think all this information is

00:32:41,429 --> 00:32:50,100
sort of background that you should know

00:32:44,210 --> 00:32:52,100
it's not well basically because we're

00:32:50,100 --> 00:32:58,020
going to have to generalize this system

00:32:52,100 --> 00:33:00,860
so that we're not storing just we're not

00:32:58,020 --> 00:33:06,440
tracking everything at the level of

00:33:00,860 --> 00:33:06,440
individual variables but rather paths

00:33:06,710 --> 00:33:10,920
like that's the goal of the RFC right is

00:33:09,030 --> 00:33:13,350
that if you do like X dot one and that's

00:33:10,920 --> 00:33:17,309
the only thing you use then you should

00:33:13,350 --> 00:33:18,809
just capture X dot one but I don't

00:33:17,309 --> 00:33:20,190
actually know I guess I have to reread

00:33:18,809 --> 00:33:24,570
the RFC and think about it a little bit

00:33:20,190 --> 00:33:29,850
like I'm not sure for example it might

00:33:24,570 --> 00:33:32,340
be that right it might be that this this

00:33:29,850 --> 00:33:34,290
there isn't actually a super deep

00:33:32,340 --> 00:33:36,150
changes I think that's the hope anyway

00:33:34,290 --> 00:33:39,150
that we don't need deep changes to the

00:33:36,150 --> 00:33:41,610
code here except that we sort of figure

00:33:39,150 --> 00:33:43,280
out a set of unique paths to get

00:33:41,610 --> 00:33:48,040
accessed

00:33:43,280 --> 00:33:53,350
to an extent and then we track those

00:33:48,040 --> 00:33:53,350
otherwise the system remains the same

00:33:53,770 --> 00:35:04,550
but worry about it later yeah you don't

00:35:02,870 --> 00:35:07,760
have to worry about that latter case I

00:35:04,550 --> 00:35:09,470
don't think because they all sort of

00:35:07,760 --> 00:35:12,200
come up in the borrow checker that if

00:35:09,470 --> 00:35:13,760
you've borrowed a field so I think from

00:35:12,200 --> 00:35:15,170
from your point of view at this stage in

00:35:13,760 --> 00:35:18,950
the code we can think of all the local

00:35:15,170 --> 00:35:20,840
variables as disjoint and then the

00:35:18,950 --> 00:35:23,720
borrow Tucker's job is to ensure that

00:35:20,840 --> 00:35:28,730
this is true like as much as it needs to

00:35:23,720 --> 00:35:30,260
be true so it's probably okay if they

00:35:28,730 --> 00:35:34,520
overlap as long as it's only shared

00:35:30,260 --> 00:35:36,140
borrowers fix anything but I think the

00:35:34,520 --> 00:35:41,540
challenge here is gonna be that there's

00:35:36,140 --> 00:35:47,090
a bit of a gap between like the mere

00:35:41,540 --> 00:35:48,740
operates on D sugared stuff and here in

00:35:47,090 --> 00:35:53,120
the type-check phase we're still sort of

00:35:48,740 --> 00:35:54,830
in a semi sugared world and some of

00:35:53,120 --> 00:35:57,329
these pads can get kind of complex like

00:35:54,830 --> 00:36:00,869
the theoretic although to do

00:35:57,329 --> 00:36:03,509
other things and I'm not sure we have to

00:36:00,869 --> 00:36:05,489
sort of we'll have to work through that

00:36:03,509 --> 00:36:07,079
I imagine we can start with very simple

00:36:05,489 --> 00:36:07,950
cases where we don't have where those

00:36:07,079 --> 00:36:14,160
things don't apply

00:36:07,950 --> 00:36:16,019
so probably where we will start I would

00:36:14,160 --> 00:36:20,150
imagine that a good first PR might be to

00:36:16,019 --> 00:36:22,440
try to write an analysis that just

00:36:20,150 --> 00:36:26,759
basically to generalize the free

00:36:22,440 --> 00:36:28,229
variables so we might yeah that that

00:36:26,759 --> 00:36:33,779
makes sense the first refactoring

00:36:28,229 --> 00:36:35,430
company is to changed so that we're not

00:36:33,779 --> 00:36:37,319
representing free variables always is

00:36:35,430 --> 00:36:39,630
just local variables but rather as

00:36:37,319 --> 00:36:43,829
something that can be more that can

00:36:39,630 --> 00:36:45,599
accommodate more complex paths not sure

00:36:43,829 --> 00:36:47,009
exactly what that is yeah but like the

00:36:45,599 --> 00:36:49,140
very first refactoring is probably just

00:36:47,009 --> 00:36:50,819
introduced a new struct so that we can

00:36:49,140 --> 00:36:58,170
make changes to destruct later he's

00:36:50,819 --> 00:37:04,529
doing so like these maps like the there

00:36:58,170 --> 00:37:06,029
was that math you were looking at you

00:37:04,529 --> 00:37:10,319
know well this with free bars for

00:37:06,029 --> 00:37:14,219
example this this tells you all the free

00:37:10,319 --> 00:37:19,680
variables and in this in the closure and

00:37:14,219 --> 00:37:29,430
then we we have this up for ID

00:37:19,680 --> 00:37:31,670
everything is key violate so like this

00:37:29,430 --> 00:37:31,670
map

00:37:33,210 --> 00:37:41,200
this map stores the mode shared mutable

00:37:37,630 --> 00:37:43,090
remove and it's keyed by upper ID that's

00:37:41,200 --> 00:37:47,710
the battle probly have to change to like

00:37:43,090 --> 00:37:49,540
a far path or something if you see what

00:37:47,710 --> 00:37:51,460
I mean so that we can even talk about

00:37:49,540 --> 00:37:54,550
the idea of capturing something it's not

00:37:51,460 --> 00:37:58,840
a local variable and then right now we

00:37:54,550 --> 00:38:01,210
just can't even represent it and what so

00:37:58,840 --> 00:38:03,400
I that's sort of we can start I think we

00:38:01,210 --> 00:38:05,110
I don't have I've done my head though I

00:38:03,400 --> 00:38:06,640
think this series of PRS will be

00:38:05,110 --> 00:38:09,670
something like first we have to

00:38:06,640 --> 00:38:12,130
introduce a new type here and we'll just

00:38:09,670 --> 00:38:14,140
push that through but that new type will

00:38:12,130 --> 00:38:16,750
just be a struct the wraps up our ID so

00:38:14,140 --> 00:38:17,950
like none of the code really changes but

00:38:16,750 --> 00:38:21,310
there's still a lot of like grunt work

00:38:17,950 --> 00:38:25,710
to push it through and now once that's

00:38:21,310 --> 00:38:28,720
in place then we can like start adding a

00:38:25,710 --> 00:38:30,790
new some new cases more complex cases

00:38:28,720 --> 00:38:32,680
and we won't use them at first but we

00:38:30,790 --> 00:38:38,350
can you can sort of beside what's the

00:38:32,680 --> 00:38:43,210
right order to do it that like maybe

00:38:38,350 --> 00:38:45,250
will generate well okay what I imagine

00:38:43,210 --> 00:38:47,890
is that we'll have well add some more

00:38:45,250 --> 00:38:49,690
complex cases it'll be feature gated and

00:38:47,890 --> 00:38:51,340
we'll start with the easy stuff like if

00:38:49,690 --> 00:38:53,590
you have a tuple and you use dot zero

00:38:51,340 --> 00:38:55,810
and dot one that's like no couple

00:38:53,590 --> 00:38:58,990
realtively a few complications get that

00:38:55,810 --> 00:39:01,120
to work and then we'll gradually expand

00:38:58,990 --> 00:39:02,770
so the next piece of code is will

00:39:01,120 --> 00:39:05,320
probably be something how could we do

00:39:02,770 --> 00:39:06,820
that grunt work that looks at looks at

00:39:05,320 --> 00:39:12,340
the paths that the closure uses and

00:39:06,820 --> 00:39:14,920
decides what what the up fart has that

00:39:12,340 --> 00:39:16,600
it captures ought to be and when we

00:39:14,920 --> 00:39:18,190
first write that code it'll always yield

00:39:16,600 --> 00:39:21,940
just the set of our ID so always

00:39:18,190 --> 00:39:23,980
simplifies and then we'll go anyway I

00:39:21,940 --> 00:39:27,990
think well we'll worry about that math

00:39:23,980 --> 00:39:27,990
later but that's the basic plan I have

00:39:29,780 --> 00:39:40,440
the place where the concept of like that

00:39:35,730 --> 00:39:42,349
is basically come model this kind of

00:39:40,440 --> 00:39:45,260
path I mean is more like a dot B dot C

00:39:42,349 --> 00:39:48,119
like a series of fuel excesses that

00:39:45,260 --> 00:39:51,329
there isn't a very clean representation

00:39:48,119 --> 00:39:52,470
of a path but that's one of the

00:39:51,329 --> 00:39:55,020
challenges we have to figure out how to

00:39:52,470 --> 00:39:59,910
overcome but I think the closest thing

00:39:55,020 --> 00:40:02,579
is this CMT's which they have a path

00:39:59,910 --> 00:40:06,990
basically so if you look at them they

00:40:02,579 --> 00:40:08,579
have a category the category is like do

00:40:06,990 --> 00:40:13,530
you rep so that would be like star AK

00:40:08,579 --> 00:40:15,599
star P where P is also a path and then

00:40:13,530 --> 00:40:17,099
they recursively have a structure it's a

00:40:15,599 --> 00:40:21,000
a dot B dot C would be a series of

00:40:17,099 --> 00:40:22,920
interiors until you get to the local

00:40:21,000 --> 00:40:30,349
variable or the up farmer to the a or b

00:40:22,920 --> 00:40:32,880
so that's kind of what it looks like and

00:40:30,349 --> 00:40:34,500
would this data structure isn't really

00:40:32,880 --> 00:40:39,990
suitable for what I'm talking about I

00:40:34,500 --> 00:40:41,400
don't think I don't think we have a good

00:40:39,990 --> 00:40:41,849
data structure for what I'm talking

00:40:41,400 --> 00:40:45,809
about

00:40:41,849 --> 00:40:48,059
so we we probably have to make like in

00:40:45,809 --> 00:40:50,540
other words this up far path data

00:40:48,059 --> 00:40:54,359
structure that I was referring to

00:40:50,540 --> 00:40:57,059
doesn't really exist we have we have a

00:40:54,359 --> 00:41:02,819
way to talk about you have here

00:40:57,059 --> 00:41:04,680
expressions we have a couple of things I

00:41:02,819 --> 00:41:14,549
don't the gain time are quite right so

00:41:04,680 --> 00:41:16,890
off to think about that the CMT might be

00:41:14,549 --> 00:41:19,410
okay maybe we'll use that but it but I

00:41:16,890 --> 00:41:20,520
sort of like that too I always sort of

00:41:19,410 --> 00:41:22,619
like that to go away

00:41:20,520 --> 00:41:24,720
it's very old code and it's very grody

00:41:22,619 --> 00:41:27,210
you could you can sort of tell that it's

00:41:24,720 --> 00:41:28,829
old because like it doesn't follow our

00:41:27,210 --> 00:41:30,260
naming conventions for example and right

00:41:28,829 --> 00:41:34,140
it starts with a lowercase letter

00:41:30,260 --> 00:41:37,020
whereas modern rust struck start with an

00:41:34,140 --> 00:41:41,700
uppercase letter this predates that

00:41:37,020 --> 00:41:42,480
convention among other things but so I

00:41:41,700 --> 00:41:46,260
sort of rather

00:41:42,480 --> 00:41:56,010
a clean new thing I will get rid of this

00:41:46,260 --> 00:41:58,830
whole thing so do you think do you feel

00:41:56,010 --> 00:42:33,600
like you can try to write down some of

00:41:58,830 --> 00:42:35,310
what I said yeah I'm gonna as soon as we

00:42:33,600 --> 00:42:37,050
get off or start encoding it thank you

00:42:35,310 --> 00:42:39,720
sir takes a while and then I'll post it

00:42:37,050 --> 00:42:41,820
up and I'll send a link it'll be on my

00:42:39,720 --> 00:42:46,980
like I'll send it to you but I I have

00:42:41,820 --> 00:42:56,480
also a playlist of like videos like this

00:42:46,980 --> 00:42:59,369
so I'll put it in there yep I need to UM

00:42:56,480 --> 00:43:00,750
advertise attend anomaly I don't know

00:42:59,369 --> 00:43:04,619
that it has anything else that you might

00:43:00,750 --> 00:43:06,840
want but you can all send anyone all

00:43:04,619 --> 00:43:11,690
right cool

00:43:06,840 --> 00:43:11,690

YouTube URL: https://www.youtube.com/watch?v=fMopdkn5-Xw


