Title: How the chalk-engine crate works
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	A discussion of how the chalk-engine crate works.
Captions: 
	00:00:00,030 --> 00:00:10,559
all right so I've started the recording

00:00:02,820 --> 00:00:16,009
so I want to talk today about two things

00:00:10,559 --> 00:00:16,009
first of all Oh me erase this white blur

00:00:16,490 --> 00:00:29,699
kind of everybody can hear me okay I'm

00:00:22,260 --> 00:00:47,430
gonna share my screen here umm actually

00:00:29,699 --> 00:00:54,030
let me do this okay so right so let's

00:00:47,430 --> 00:00:55,410
see I probably won't hopefully we'll get

00:00:54,030 --> 00:01:00,020
through everything today because they

00:00:55,410 --> 00:01:02,670
didn't finish preparing everything so

00:01:00,020 --> 00:01:06,930
but what I will try to talk about our

00:01:02,670 --> 00:01:08,670
main focus was to talk about this the

00:01:06,930 --> 00:01:12,270
chalk engine great

00:01:08,670 --> 00:01:14,939
first and foremost and some of the sort

00:01:12,270 --> 00:01:18,509
of foundational concepts that it's based

00:01:14,939 --> 00:01:21,170
on in particular there's a paper hold on

00:01:18,509 --> 00:01:21,170
a second here

00:01:21,259 --> 00:01:34,520
there's a paper called there we go so

00:01:31,340 --> 00:01:38,430
there's a paper if I can change windows

00:01:34,520 --> 00:01:40,409
successfully yes called a new

00:01:38,430 --> 00:01:44,220
formulation of tabled resolution with

00:01:40,409 --> 00:01:47,399
delay very catchy title that kind of

00:01:44,220 --> 00:01:48,630
covers the concepts in a sort of

00:01:47,399 --> 00:01:51,689
conceptually elegant way although it

00:01:48,630 --> 00:01:55,200
doesn't give you much information about

00:01:51,689 --> 00:02:02,820
how to put it into practice and so one

00:01:55,200 --> 00:02:06,509
of my goals here is to this is the paper

00:02:02,820 --> 00:02:10,170
one of my goals is to kind of make some

00:02:06,509 --> 00:02:11,630
connections between the terminology in

00:02:10,170 --> 00:02:13,040
this paper and the

00:02:11,630 --> 00:02:19,190
pardon what the code itself actually

00:02:13,040 --> 00:02:23,270
does and I think today if all goes to

00:02:19,190 --> 00:02:26,720
plan will cover the kind of easy part of

00:02:23,270 --> 00:02:32,180
how this works which is to say this sort

00:02:26,720 --> 00:02:33,470
of positive part of find any answers and

00:02:32,180 --> 00:02:34,520
we'll see a little bit what happens when

00:02:33,470 --> 00:02:37,520
there could be an infinite set of

00:02:34,520 --> 00:02:39,680
answers and so on I think we won't get

00:02:37,520 --> 00:02:42,050
to some of the weirder stuff when your

00:02:39,680 --> 00:02:51,530
chart start to introduce negative

00:02:42,050 --> 00:02:53,140
reasoning in particular and so I think

00:02:51,530 --> 00:02:55,340
we'll cover that next time probably

00:02:53,140 --> 00:02:58,310
because I I would have to do a little

00:02:55,340 --> 00:03:03,110
more credit um but negative reasoning

00:02:58,310 --> 00:03:06,730
would be able to say something like you

00:03:03,110 --> 00:03:09,230
know this really usual notation

00:03:06,730 --> 00:03:12,050
something like P is true if Q is not

00:03:09,230 --> 00:03:14,480
true and when you start adding that it

00:03:12,050 --> 00:03:15,920
gets a little more complicated and we do

00:03:14,480 --> 00:03:17,660
actually want to be able to do that

00:03:15,920 --> 00:03:21,410
reasoning in a limited way even though

00:03:17,660 --> 00:03:23,540
Russ doesn't have syntax like that which

00:03:21,410 --> 00:03:29,020
actually I think probably sidesteps a

00:03:23,540 --> 00:03:31,520
lot of the complicating parts but our

00:03:29,020 --> 00:03:34,100
engine still theoretically handles the

00:03:31,520 --> 00:03:43,280
full generality but we'll leave that for

00:03:34,100 --> 00:03:50,480
another time so hi tanner so let's see

00:03:43,280 --> 00:03:54,310
um where to start I'm gonna bring my

00:03:50,480 --> 00:03:56,480
secret paper just a little bit of a plan

00:03:54,310 --> 00:04:00,250
all right so first I want to do a little

00:03:56,480 --> 00:04:02,390
terminology um for anything else

00:04:00,250 --> 00:04:04,640
probably many of you have heard these

00:04:02,390 --> 00:04:06,620
turn out just terms but it's always good

00:04:04,640 --> 00:04:09,530
to be sure we're saying you mean the

00:04:06,620 --> 00:04:12,640
same things the first thing is I think

00:04:09,530 --> 00:04:14,810
people usually call this a proposition

00:04:12,640 --> 00:04:19,820
it's basically something that can be

00:04:14,810 --> 00:04:22,190
proven true so like in rust terms this

00:04:19,820 --> 00:04:25,250
might be something like option of a few

00:04:22,190 --> 00:04:25,710
thirty-two is sized but the notation

00:04:25,250 --> 00:04:28,139
that

00:04:25,710 --> 00:04:30,539
I'll be using today would be more like

00:04:28,139 --> 00:04:35,550
this and in general you would have

00:04:30,539 --> 00:04:38,340
something like I don't know I don't have

00:04:35,550 --> 00:04:41,430
to call this the name of the proposition

00:04:38,340 --> 00:04:47,520
and then some some term some type in

00:04:41,430 --> 00:04:48,870
here in the full it in the full choc D

00:04:47,520 --> 00:04:50,759
sugaring there's like a bunch of more

00:04:48,870 --> 00:04:53,880
complex things here but we don't

00:04:50,759 --> 00:04:55,289
actually care for the purposes of choc

00:04:53,880 --> 00:04:57,389
engine you don't really care one way or

00:04:55,289 --> 00:04:59,699
the other just some kind of thing that

00:04:57,389 --> 00:05:05,430
can be proven and they can be unified

00:04:59,699 --> 00:05:08,190
together and then so then you have

00:05:05,430 --> 00:05:12,900
something called a query and the query

00:05:08,190 --> 00:05:21,060
is usually written like this let's say

00:05:12,900 --> 00:05:23,310
this and it means something you it's

00:05:21,060 --> 00:05:25,680
basically the outside when you request

00:05:23,310 --> 00:05:28,020
answers this is the the thing you're

00:05:25,680 --> 00:05:33,150
looking for answers to and answers would

00:05:28,020 --> 00:05:37,349
be like both a result of yes meaning it

00:05:33,150 --> 00:05:39,000
is true and then with a substitution for

00:05:37,349 --> 00:05:40,800
any variables so in this case there are

00:05:39,000 --> 00:05:42,210
no variables this particular example so

00:05:40,800 --> 00:05:51,539
there would be no substitution this is

00:05:42,210 --> 00:05:58,050
just true or false but you might have a

00:05:51,539 --> 00:06:01,289
more general query like in which case an

00:05:58,050 --> 00:06:03,449
answer might be yes if X is youth are

00:06:01,289 --> 00:06:07,050
you doing and there might be other

00:06:03,449 --> 00:06:09,389
answers like yes if X is 32 and in fact

00:06:07,050 --> 00:06:10,680
there's kind of an infinite series of

00:06:09,389 --> 00:06:15,060
answers here because you could have

00:06:10,680 --> 00:06:18,570
option of you 32 like an option option

00:06:15,060 --> 00:06:20,789
and so on so we'll come to that problem

00:06:18,570 --> 00:06:24,750
a little bit and how we think about that

00:06:20,789 --> 00:06:26,220
but that's the basic idea of a query and

00:06:24,750 --> 00:06:27,720
so from the point of view of chalk

00:06:26,220 --> 00:06:29,250
engine this part of the code that I'm

00:06:27,720 --> 00:06:30,840
going to cover today at least depends

00:06:29,250 --> 00:06:33,330
how far I get we're basically just

00:06:30,840 --> 00:06:34,830
giving a series of answers it's somebody

00:06:33,330 --> 00:06:37,200
else's problem to decide if they want

00:06:34,830 --> 00:06:39,029
more how many they want and so on and

00:06:37,200 --> 00:06:39,390
the code kind of has like an iterator

00:06:39,029 --> 00:06:42,600
like

00:06:39,390 --> 00:06:44,580
ylan so you can stop at any temple and

00:06:42,600 --> 00:06:47,360
the last two thing not too relevant

00:06:44,580 --> 00:06:51,660
today that usually helpful term a goal

00:06:47,360 --> 00:06:52,860
the goal is just a proposition a little

00:06:51,660 --> 00:06:54,240
bit more general than this but basically

00:06:52,860 --> 00:06:57,540
it's a proposition that you are trying

00:06:54,240 --> 00:06:59,810
to prove so what you're trying to figure

00:06:57,540 --> 00:07:05,160
out and the clause with the proposition

00:06:59,810 --> 00:07:11,850
that you assume to injure any questions

00:07:05,160 --> 00:07:16,220
on that basic terminology okay so so

00:07:11,850 --> 00:07:22,440
let's see um let's give an example so

00:07:16,220 --> 00:07:27,960
here's a little probiem in prologue e /

00:07:22,440 --> 00:07:30,900
rusty quasi syntax this might have come

00:07:27,960 --> 00:07:32,660
from so in the level of we're operating

00:07:30,900 --> 00:07:36,540
out here we're really quite just

00:07:32,660 --> 00:07:38,490
separated from rusts you know notions of

00:07:36,540 --> 00:07:39,980
traits and impulse but of course this

00:07:38,490 --> 00:07:42,780
might have come from

00:07:39,980 --> 00:07:44,970
but like this rule here this rule says

00:07:42,780 --> 00:07:46,410
copy is is true for you thirty-two and

00:07:44,970 --> 00:07:49,560
of course it might have come from an

00:07:46,410 --> 00:07:52,620
impolite this which the Pilar serve has

00:07:49,560 --> 00:07:58,160
implicitly and this rule might have come

00:07:52,620 --> 00:07:58,160
from an input like this oops

00:07:59,630 --> 00:08:07,530
so it says copy is true for option of T

00:08:03,540 --> 00:08:10,340
if if copy is true for T and there's

00:08:07,530 --> 00:08:14,370
kind of an implicit like for all T here

00:08:10,340 --> 00:08:18,750
that I'm not gonna write because it's

00:08:14,370 --> 00:08:20,250
tedious um so this is our example

00:08:18,750 --> 00:08:28,320
program that we'll be working with to

00:08:20,250 --> 00:08:30,600
the most part and the actually I don't

00:08:28,320 --> 00:08:33,660
think we'll actually get to clone so

00:08:30,600 --> 00:08:38,190
maybe we don't even need that just look

00:08:33,660 --> 00:08:42,330
at copy it's enough um so now we want to

00:08:38,190 --> 00:08:44,730
be able to take queries like um well

00:08:42,330 --> 00:08:54,410
like a very simple query might be

00:08:44,730 --> 00:08:54,410
something like this is is you 32 copy

00:08:55,280 --> 00:08:58,890
and we want to be able to get an answer

00:08:57,240 --> 00:09:00,420
out from this yeah that's kind of the

00:08:58,890 --> 00:09:01,980
topic of today how do we evaluate these

00:09:00,420 --> 00:09:07,880
queries how do we come up with answers

00:09:01,980 --> 00:09:10,710
however many there are and so on and

00:09:07,880 --> 00:09:14,780
that's exactly what this paper is kind

00:09:10,710 --> 00:09:14,780
of about and it's based on this idea

00:09:15,560 --> 00:09:21,270
where the idea is that you have a solver

00:09:18,690 --> 00:09:24,990
or the solver is kind of represented as

00:09:21,270 --> 00:09:26,610
a tree sorry a forest of trees the state

00:09:24,990 --> 00:09:28,980
of the solver is represented as a forest

00:09:26,610 --> 00:09:31,050
of trees and each of these trees is like

00:09:28,980 --> 00:09:32,970
some thing you're trying to prove in

00:09:31,050 --> 00:09:34,560
different ways you can prove it and so

00:09:32,970 --> 00:09:37,230
the the nodes in these trees have a

00:09:34,560 --> 00:09:40,500
particular form that's called well I'm

00:09:37,230 --> 00:09:42,480
calling it an X in some of the papers is

00:09:40,500 --> 00:09:44,850
called an x clause for some reason and

00:09:42,480 --> 00:09:46,230
I'm keeping up with that terminology

00:09:44,850 --> 00:09:50,520
it's actually not called Ben's

00:09:46,230 --> 00:09:56,070
particular paper but the the structure

00:09:50,520 --> 00:09:57,600
of this clause looks like well it's kind

00:09:56,070 --> 00:09:59,970
of the goal that you're trying to prove

00:09:57,600 --> 00:10:03,380
and something called a delay set and

00:09:59,970 --> 00:10:05,700
then something called the sub goals so

00:10:03,380 --> 00:10:07,590
well we're not gonna get to the delay

00:10:05,700 --> 00:10:09,930
set today this has to do with negative

00:10:07,590 --> 00:10:12,680
reasoning but all of these things are

00:10:09,930 --> 00:10:15,450
propositions so something might be like

00:10:12,680 --> 00:10:17,400
you might imagine if we were trying to

00:10:15,450 --> 00:10:25,250
copy not not for this particular example

00:10:17,400 --> 00:10:27,480
but let's come back to this over concept

00:10:25,250 --> 00:10:33,030
you might imagine if we were trying to

00:10:27,480 --> 00:10:35,430
figure out if option of u 32 were copy

00:10:33,030 --> 00:10:37,020
and somewhere along the line we're gonna

00:10:35,430 --> 00:10:41,670
wind up in a state kind of like this

00:10:37,020 --> 00:10:45,600
which is saying I can prove that option

00:10:41,670 --> 00:10:49,380
of u-32 is copy if I can prove that copy

00:10:45,600 --> 00:10:52,020
of u32 is true okay we'll come back to

00:10:49,380 --> 00:10:54,690
so so these X causes there's like a

00:10:52,020 --> 00:10:57,120
forest of trees of expose as possible

00:10:54,690 --> 00:10:59,840
and the idea is that we have this

00:10:57,120 --> 00:10:59,840
initial State

00:10:59,990 --> 00:11:06,290
um the initial state is going to take

00:11:04,130 --> 00:11:08,209
the query so let's say let's use our

00:11:06,290 --> 00:11:10,339
simple or really simple query copy of

00:11:08,209 --> 00:11:17,209
you 32 the initial state is we're gonna

00:11:10,339 --> 00:11:18,980
make a tree that looks like this and now

00:11:17,209 --> 00:11:21,020
what's going on here so first of all

00:11:18,980 --> 00:11:24,410
there's an empty set of delay clauses

00:11:21,020 --> 00:11:26,089
here that's what that pipe is and right

00:11:24,410 --> 00:11:28,700
now we'll always just see the pipe as an

00:11:26,089 --> 00:11:30,950
empty set and then this is like the

00:11:28,700 --> 00:11:32,420
stuff we have yet to prove so this root

00:11:30,950 --> 00:11:33,800
node is a little bit weird because we're

00:11:32,420 --> 00:11:35,990
basically saying it's always the same

00:11:33,800 --> 00:11:38,270
thing in the root node we're they here's

00:11:35,990 --> 00:11:40,399
the thing we're trying to prove and we

00:11:38,270 --> 00:11:43,149
haven't proven anything yet so we'll put

00:11:40,399 --> 00:11:45,740
this here okay and this is gonna be a

00:11:43,149 --> 00:11:48,130
tree so I'm actually can I represent it

00:11:45,740 --> 00:11:50,779
as a list

00:11:48,130 --> 00:12:03,560
either way feel free to interrupt me and

00:11:50,779 --> 00:12:05,120
ask questions but so so we start out the

00:12:03,560 --> 00:12:08,720
very first thing before anything happens

00:12:05,120 --> 00:12:10,550
we create from our query one tree and it

00:12:08,720 --> 00:12:11,829
has this root node and then there are

00:12:10,550 --> 00:12:14,029
operations that we're going to do

00:12:11,829 --> 00:12:16,130
there's a whole is a set of them like

00:12:14,029 --> 00:12:18,260
ten different operations that add new

00:12:16,130 --> 00:12:21,200
nodes to trees or create new trees in

00:12:18,260 --> 00:12:23,750
the forest which when we're all done

00:12:21,200 --> 00:12:25,970
kind of tells us all the answers um and

00:12:23,750 --> 00:12:27,529
the first operation is something called

00:12:25,970 --> 00:12:29,480
program clause resolution and what it

00:12:27,529 --> 00:12:31,579
basically does is it says if you have a

00:12:29,480 --> 00:12:33,589
tree that has exactly one it's just a

00:12:31,579 --> 00:12:36,320
root and the first thing you can do is

00:12:33,589 --> 00:12:39,140
consult your program and look for ways

00:12:36,320 --> 00:12:41,060
to prove the goal that you have to prove

00:12:39,140 --> 00:12:43,459
this proposition so if we go to our

00:12:41,060 --> 00:12:45,500
program we have three ways we can prove

00:12:43,459 --> 00:12:48,700
that we know that copy is true for you

00:12:45,500 --> 00:12:51,440
32 we know that it's true for F 32 and

00:12:48,700 --> 00:12:53,540
we know that it's true for option of T

00:12:51,440 --> 00:12:57,709
as long as it's also true for T for any

00:12:53,540 --> 00:12:59,390
T so we can try to apply those and the

00:12:57,709 --> 00:13:01,370
way we apply them is we take the thing

00:12:59,390 --> 00:13:06,050
we're trying to prove here in this

00:13:01,370 --> 00:13:08,440
proposition and we unify it with with

00:13:06,050 --> 00:13:11,390
the sort of head of this clause here

00:13:08,440 --> 00:13:13,250
right and so sometimes that succeeds

00:13:11,390 --> 00:13:14,000
that's great in this case it's only

00:13:13,250 --> 00:13:16,880
gonna succeed

00:13:14,000 --> 00:13:18,410
once which is with the copy of you 32 at

00:13:16,880 --> 00:13:22,580
the top so we're gonna add a node then

00:13:18,410 --> 00:13:24,580
it says okay it's gonna look kind of

00:13:22,580 --> 00:13:27,560
similar as the same it has the same goal

00:13:24,580 --> 00:13:29,630
but what comes here would be all the

00:13:27,560 --> 00:13:32,020
conditions we have yet to prove based on

00:13:29,630 --> 00:13:34,820
this particular rule now in this case

00:13:32,020 --> 00:13:36,950
there are none because this format

00:13:34,820 --> 00:13:38,780
basically means we can prove copy of you

00:13:36,950 --> 00:13:40,880
32 if we prove these sub-goals when

00:13:38,780 --> 00:13:47,240
there are none to prove we just end up

00:13:40,880 --> 00:13:49,820
with this okay and this is a this is a

00:13:47,240 --> 00:13:51,620
child so now we have a tree

00:13:49,820 --> 00:13:54,920
this is the root node in the tree this

00:13:51,620 --> 00:13:57,620
is its child we don't add any rules for

00:13:54,920 --> 00:14:00,500
like the copy of f/32 rule for example

00:13:57,620 --> 00:14:02,900
we can't unify copy of you 32 and copy

00:14:00,500 --> 00:14:04,730
of F 32 because you 32 an F 32 are

00:14:02,900 --> 00:14:07,520
different types and same for this rule

00:14:04,730 --> 00:14:09,110
so we get exactly one child and this

00:14:07,520 --> 00:14:13,010
child is kind of special because it has

00:14:09,110 --> 00:14:18,610
no goals left to prove so we call that

00:14:13,010 --> 00:14:22,250
an answer basically we just now proved

00:14:18,610 --> 00:14:23,630
that rule you 32 is copy and we proved

00:14:22,250 --> 00:14:25,390
it by saying oh well there's a rule that

00:14:23,630 --> 00:14:27,980
says you 32 is comfy so that's like a

00:14:25,390 --> 00:14:29,270
example that's so trivial it's almost

00:14:27,980 --> 00:14:31,880
kind of confusing because it's so

00:14:29,270 --> 00:14:32,750
trivial but this is the general shape of

00:14:31,880 --> 00:14:33,920
what we're going to do is we're going to

00:14:32,750 --> 00:14:35,690
start with these trees we're gonna add a

00:14:33,920 --> 00:14:38,210
bunch of nodes and we're trying to get

00:14:35,690 --> 00:14:39,650
to the point where we have some node

00:14:38,210 --> 00:14:40,880
with nothing left to prove and that's

00:14:39,650 --> 00:14:42,410
called an answer and then we'll

00:14:40,880 --> 00:14:44,890
sometimes propagate those answers in

00:14:42,410 --> 00:14:48,320
between things so let's do another

00:14:44,890 --> 00:14:51,050
alright question yeah go for it so why

00:14:48,320 --> 00:14:53,750
don't we ask why do we ask for situation

00:14:51,050 --> 00:14:55,150
settles just a single tree that's a

00:14:53,750 --> 00:15:00,830
guess what I'm gonna show you now oh

00:14:55,150 --> 00:15:05,120
actually will I oh yes I will um so the

00:15:00,830 --> 00:15:10,700
answer is that each each tree

00:15:05,120 --> 00:15:12,530
corresponds to sort of some query that

00:15:10,700 --> 00:15:15,560
we're trying to prove right and in this

00:15:12,530 --> 00:15:16,610
case the queries let me just me just

00:15:15,560 --> 00:15:18,950
work it out and I'll show you but

00:15:16,610 --> 00:15:21,020
basically as we encounter different

00:15:18,950 --> 00:15:22,100
kinds of predicates with different sets

00:15:21,020 --> 00:15:24,800
of variables we're gonna create new

00:15:22,100 --> 00:15:26,390
trees to represent them um but let's

00:15:24,800 --> 00:15:28,420
let's make an example suppose that we're

00:15:26,390 --> 00:15:36,529
trying to prove

00:15:28,420 --> 00:15:39,259
so example number two suppose I were

00:15:36,529 --> 00:15:43,100
trying to prove copy of option user this

00:15:39,259 --> 00:15:44,300
is a little more complex so again we're

00:15:43,100 --> 00:15:46,129
gonna follow the same procedure we're

00:15:44,300 --> 00:15:51,529
going to start with a root node that is

00:15:46,129 --> 00:15:53,000
just or equal to itself that's the thing

00:15:51,529 --> 00:15:54,740
we're trying to prove and we're gonna

00:15:53,000 --> 00:15:57,230
elaborate it by adding by using the

00:15:54,740 --> 00:15:59,540
program clauses and we go up here we

00:15:57,230 --> 00:16:02,120
can't use this one because option and

00:15:59,540 --> 00:16:04,160
u-32 are different types we can't use

00:16:02,120 --> 00:16:05,800
this one because I left 32 an option or

00:16:04,160 --> 00:16:15,019
different types but we can use this one

00:16:05,800 --> 00:16:20,389
so when we unify so we're going to apply

00:16:15,019 --> 00:16:25,100
the rule okay and when we try to unify

00:16:20,389 --> 00:16:26,959
option of you 32 an option of T we see

00:16:25,100 --> 00:16:30,050
we need a substitution that says okay we

00:16:26,959 --> 00:16:31,670
can do that if T is U 32 right so we

00:16:30,050 --> 00:16:34,670
have some substitution that goes from

00:16:31,670 --> 00:16:37,670
this from this rule to the one we're

00:16:34,670 --> 00:16:39,860
trying to prove and so when we do that

00:16:37,670 --> 00:16:43,660
we we apply that substitution and we

00:16:39,860 --> 00:16:48,709
wind up with a child that says copy

00:16:43,660 --> 00:16:51,019
adoption 32 if so we would take this T

00:16:48,709 --> 00:16:55,579
but we apply the substitution so we get

00:16:51,019 --> 00:16:58,069
copy of 32 sorry and this is the child

00:16:55,579 --> 00:16:59,420
and this I'm going to take out because

00:16:58,069 --> 00:17:02,000
this is not actually part of the tree

00:16:59,420 --> 00:17:04,549
this is just my notes I'm going to put

00:17:02,000 --> 00:17:18,620
it in a comment here like how we derive

00:17:04,549 --> 00:17:20,299
is this part of the tree so so right so

00:17:18,620 --> 00:17:23,079
this is the tree we had now we started

00:17:20,299 --> 00:17:25,730
with the root node we added a child and

00:17:23,079 --> 00:17:27,860
this is not unlike before this child

00:17:25,730 --> 00:17:31,280
still has a list of goals so it's not an

00:17:27,860 --> 00:17:32,570
answer yet right now we need to figure

00:17:31,280 --> 00:17:37,460
out what do we do how do we prove that

00:17:32,570 --> 00:17:38,659
sub goal copy of u 32 and the answer is

00:17:37,460 --> 00:17:41,400
this is where the forest comes in

00:17:38,659 --> 00:17:44,450
because now we go looking for some other

00:17:41,400 --> 00:17:46,800
for some tree where this is the label

00:17:44,450 --> 00:17:49,170
this is the goal of that tree that it

00:17:46,800 --> 00:17:51,090
was trying to prove and we don't have a

00:17:49,170 --> 00:17:52,830
tree like that yet because this this

00:17:51,090 --> 00:17:55,740
tree is trying to prove four options and

00:17:52,830 --> 00:17:56,660
this one is asking for integers that's a

00:17:55,740 --> 00:18:03,540
different question

00:17:56,660 --> 00:18:04,920
you would add another tree and just like

00:18:03,540 --> 00:18:08,630
before the root node of the tree is

00:18:04,920 --> 00:18:11,430
always kind of the same thing twice and

00:18:08,630 --> 00:18:14,250
now we're actually interestingly this is

00:18:11,430 --> 00:18:15,960
the same tree we just did here right so

00:18:14,250 --> 00:18:21,330
we can do the same step of will apply

00:18:15,960 --> 00:18:26,940
the program Clause rule we'll end up

00:18:21,330 --> 00:18:28,500
with this this is an answer so this is

00:18:26,940 --> 00:18:31,650
also what they call the program close

00:18:28,500 --> 00:18:34,559
resolution no at this point let me just

00:18:31,650 --> 00:18:37,110
pop over to the paper because I Niko how

00:18:34,559 --> 00:18:40,040
come you made another tree when you

00:18:37,110 --> 00:18:44,870
think why not just make another sub tree

00:18:40,040 --> 00:18:47,429
over why not just keep writing down

00:18:44,870 --> 00:18:50,070
every everything in the sub tree has to

00:18:47,429 --> 00:18:55,740
be working towards this thing for some

00:18:50,070 --> 00:18:57,150
instantiation of this course so good

00:18:55,740 --> 00:18:59,790
lettuces this is working towards a

00:18:57,150 --> 00:19:02,300
different goal like when we produce the

00:18:59,790 --> 00:19:04,920
answers we get here are going to be our

00:19:02,300 --> 00:19:07,380
answers that proves that you 32 is copy

00:19:04,920 --> 00:19:09,780
what we're looking for in this in each

00:19:07,380 --> 00:19:11,300
tree any answers we want in this

00:19:09,780 --> 00:19:14,160
particular tradition of the answers that

00:19:11,300 --> 00:19:16,290
proved optional for you so does that

00:19:14,160 --> 00:19:18,240
mean that every day will only have up to

00:19:16,290 --> 00:19:22,230
one child if you're always changing

00:19:18,240 --> 00:19:25,980
goals no we'll see that later there

00:19:22,230 --> 00:19:29,280
could be there could be more than one

00:19:25,980 --> 00:19:30,840
way to prove a given thing in this

00:19:29,280 --> 00:19:32,460
particular example I guess there isn't

00:19:30,840 --> 00:19:45,750
we'll see you in the next example a case

00:19:32,460 --> 00:19:48,500
where that's true unification is it just

00:19:45,750 --> 00:19:48,500
within a data type

00:19:54,360 --> 00:20:00,730
okay so the unification it's basically

00:19:59,050 --> 00:20:03,700
the rustic type the quality rules in

00:20:00,730 --> 00:20:05,290
this case but in in Prolog rules

00:20:03,700 --> 00:20:07,420
normally it would just be basically the

00:20:05,290 --> 00:20:09,790
same string you means like they're the

00:20:07,420 --> 00:20:11,980
they're the same alright so the same

00:20:09,790 --> 00:20:14,590
string u-32 it after two are not the

00:20:11,980 --> 00:20:24,970
same string and there's no variables in

00:20:14,590 --> 00:20:27,430
it so they're not equal so let me

00:20:24,970 --> 00:20:29,110
present so soon j2 coming back to this

00:20:27,430 --> 00:20:33,150
question of like why are these different

00:20:29,110 --> 00:20:38,080
trees maybe it's helpful to say that um

00:20:33,150 --> 00:20:39,700
well when we get to the actual code

00:20:38,080 --> 00:20:41,080
there's actually a slightly different

00:20:39,700 --> 00:20:42,970
name for these trees that I was using

00:20:41,080 --> 00:20:47,170
that comes from some other text called

00:20:42,970 --> 00:20:51,880
tables but the idea is basically each

00:20:47,170 --> 00:20:55,180
one corresponds to yeah some goal that

00:20:51,880 --> 00:20:56,650
we were trying to prove right and they

00:20:55,180 --> 00:20:58,510
are they're interdependent with one

00:20:56,650 --> 00:21:00,730
another because proving one goal

00:20:58,510 --> 00:21:02,590
requires proving another but when you

00:21:00,730 --> 00:21:04,120
create them this way often these things

00:21:02,590 --> 00:21:05,890
can be really complicated and there

00:21:04,120 --> 00:21:08,320
might be cycles back and forth and this

00:21:05,890 --> 00:21:11,260
allows you to kind of cache answers also

00:21:08,320 --> 00:21:14,320
between queries and so forth so if you

00:21:11,260 --> 00:21:16,180
put everything like these trees they

00:21:14,320 --> 00:21:17,710
sell seems very abstract I guess but it

00:21:16,180 --> 00:21:23,080
does correspond pretty closely to the

00:21:17,710 --> 00:21:24,520
code and the essentially it's just how

00:21:23,080 --> 00:21:26,470
you organize the answers so you're

00:21:24,520 --> 00:21:28,240
looking for answers for a particular sub

00:21:26,470 --> 00:21:29,980
goal that you may encounter many times

00:21:28,240 --> 00:21:31,750
and so it's useful to have a tree for it

00:21:29,980 --> 00:21:33,010
so that all of those times that you

00:21:31,750 --> 00:21:34,930
encounter the same sub goal from

00:21:33,010 --> 00:21:38,200
different parts of the thing can refer

00:21:34,930 --> 00:21:39,970
back to about shared data structure so I

00:21:38,200 --> 00:21:41,410
guess that the point is performance

00:21:39,970 --> 00:21:42,910
right because you're memorizing the

00:21:41,410 --> 00:21:44,740
results of queries that you've already

00:21:42,910 --> 00:21:46,690
found and creating a different tree

00:21:44,740 --> 00:21:52,080
allows you to do that it's not just

00:21:46,690 --> 00:21:54,430
performance um like this is if you

00:21:52,080 --> 00:21:56,740
another way to look at it it also it

00:21:54,430 --> 00:21:59,770
comes up when you have recursion to

00:21:56,740 --> 00:22:02,170
prevent infinite recursion so when I

00:21:59,770 --> 00:22:04,590
mentioned that like there's an infinite

00:22:02,170 --> 00:22:04,590
set of answers

00:22:05,270 --> 00:22:13,160
and we'll see later that part of the

00:22:08,770 --> 00:22:15,280
having these trees allows us to produce

00:22:13,160 --> 00:22:19,190
that infinite set of answers correctly

00:22:15,280 --> 00:22:21,860
so in contrast I would have to

00:22:19,190 --> 00:22:23,480
in contrast like a traditional four

00:22:21,860 --> 00:22:25,280
locks over doesn't have any trees in its

00:22:23,480 --> 00:22:27,200
state it only has a stack the things

00:22:25,280 --> 00:22:28,430
that it's trying to prove and it can

00:22:27,200 --> 00:22:33,020
easily go into an infinite loop and

00:22:28,430 --> 00:22:34,610
never produce any answers um so well

00:22:33,020 --> 00:22:36,640
I'll come back to that and maybe that

00:22:34,610 --> 00:22:38,750
will help clarify it but let me give one

00:22:36,640 --> 00:22:40,640
let me keep going the disks I want to

00:22:38,750 --> 00:22:43,820
show one more example and then we'll try

00:22:40,640 --> 00:22:45,740
it so we're now just taking on faith

00:22:43,820 --> 00:22:47,980
that there's a useful to have these

00:22:45,740 --> 00:22:50,720
trees and that they represent different

00:22:47,980 --> 00:22:54,260
questions like you 32 or optionally 32

00:22:50,720 --> 00:22:56,870
um so at this point we have now two

00:22:54,260 --> 00:22:59,900
trees one of them references the other

00:22:56,870 --> 00:23:02,390
here and in the second tree we actually

00:22:59,900 --> 00:23:04,730
have an answer node which has no nothing

00:23:02,390 --> 00:23:07,460
no work left to do so there's another

00:23:04,730 --> 00:23:11,270
kind of stuff we can do now where we say

00:23:07,460 --> 00:23:13,310
okay we resolve this sub goal we resolve

00:23:11,270 --> 00:23:17,270
this sub goal sorry by using the answer

00:23:13,310 --> 00:23:18,440
here um so in this case this case

00:23:17,270 --> 00:23:19,820
there's no variables so it's a little

00:23:18,440 --> 00:23:21,410
maybe unclear but we know that you

00:23:19,820 --> 00:23:23,780
thirty basically we know that this is

00:23:21,410 --> 00:23:25,070
true because we have this answer that

00:23:23,780 --> 00:23:26,900
says it's true and that's what we were

00:23:25,070 --> 00:23:30,830
trying to prove so we can remove that

00:23:26,900 --> 00:23:34,000
from the list of work to do and we can

00:23:30,830 --> 00:23:36,830
have caption of option u 32 if nothing

00:23:34,000 --> 00:23:38,810
right because you use that answer to

00:23:36,830 --> 00:23:41,000
remove this and now this is another

00:23:38,810 --> 00:23:45,530
interval and so now indeed we know that

00:23:41,000 --> 00:23:46,760
option of u 32 is also comfortable at

00:23:45,530 --> 00:23:49,850
this point there's nothing left we can

00:23:46,760 --> 00:23:51,920
do in this tree because all of the nodes

00:23:49,850 --> 00:23:57,080
in the tree have answers as children so

00:23:51,920 --> 00:23:59,030
all done so that's okay because he place

00:23:57,080 --> 00:24:03,470
in history writes is it's not so normal

00:23:59,030 --> 00:24:08,690
not what's that that's a the answer is

00:24:03,470 --> 00:24:10,970
it removes the part of the nodes or does

00:24:08,690 --> 00:24:14,259
it create a new nodes it's a new node

00:24:10,970 --> 00:24:16,999
conceptually in the actual code

00:24:14,259 --> 00:24:18,499
like some of these this is sort of a

00:24:16,999 --> 00:24:20,659
mathematical formulation and nothing

00:24:18,499 --> 00:24:24,289
ever gets removed it just gets added but

00:24:20,659 --> 00:24:26,449
the reason for that is you'll see later

00:24:24,289 --> 00:24:27,469
that it could be as possible well let me

00:24:26,449 --> 00:24:29,059
just give you the next example it's

00:24:27,469 --> 00:24:30,559
possible to have many children so far

00:24:29,059 --> 00:24:34,519
we've only had one children of any given

00:24:30,559 --> 00:24:44,359
node but it's possible so let's do the

00:24:34,519 --> 00:24:48,619
next example so this one would say here

00:24:44,359 --> 00:24:55,209
I'm saying give me this X is meant to be

00:24:48,619 --> 00:24:55,209
a variable and we're saying give me all

00:24:57,189 --> 00:25:04,159
give me all the X all the types X such

00:25:01,459 --> 00:25:06,379
that copy of option of X is the option

00:25:04,159 --> 00:25:08,149
of X Istanbul right so the correct list

00:25:06,379 --> 00:25:11,179
of answers is we said earlier it's kind

00:25:08,149 --> 00:25:18,799
of infinite it could be X could be you

00:25:11,179 --> 00:25:24,649
32 X could be F 32 X for the option of

00:25:18,799 --> 00:25:28,369
you 32 X X could be option of option

00:25:24,649 --> 00:25:32,209
interview 32 because all of these types

00:25:28,369 --> 00:25:35,959
are things for which they are kind of

00:25:32,209 --> 00:25:43,099
like an option of this is comfortable so

00:25:35,959 --> 00:25:47,299
that make sense of no or Gaddis okay

00:25:43,099 --> 00:25:48,379
okay so so how would we do this one so

00:25:47,299 --> 00:25:54,499
let's walk it through so we'll make a

00:25:48,379 --> 00:25:57,619
treat we'll say okay copy option you 32

00:25:54,499 --> 00:26:00,769
if copy of sorry how do you think you

00:25:57,619 --> 00:26:02,059
cut the adoption of X you copy of option

00:26:00,769 --> 00:26:05,959
X and this is the first time that we've

00:26:02,059 --> 00:26:07,999
actually had a variable in our in our

00:26:05,959 --> 00:26:11,449
tree nodes and I'm being a little hand

00:26:07,999 --> 00:26:13,489
wavy here about how we know it's a

00:26:11,449 --> 00:26:15,139
variable like basically if it's a single

00:26:13,489 --> 00:26:17,539
capital letter is my convention right

00:26:15,139 --> 00:26:19,489
now but in the code of course we're more

00:26:17,539 --> 00:26:21,859
explicit about this but the meaning for

00:26:19,489 --> 00:26:24,169
this is find when you have variables the

00:26:21,859 --> 00:26:25,909
meaning is always an answer for this

00:26:24,169 --> 00:26:27,650
will have to be a specific route will

00:26:25,909 --> 00:26:31,490
include values for all the verticals

00:26:27,650 --> 00:26:33,080
um unless it or if it a partial

00:26:31,490 --> 00:26:34,970
substitution values for all the

00:26:33,080 --> 00:26:37,280
variables that matter basically so if

00:26:34,970 --> 00:26:38,990
option were always copy no matter what X

00:26:37,280 --> 00:26:41,390
is you wouldn't necessarily have to

00:26:38,990 --> 00:26:43,790
include a value for X but that's not

00:26:41,390 --> 00:26:47,420
true in this case all right and so now

00:26:43,790 --> 00:26:48,590
we go up and we I'm gonna call this I'm

00:26:47,420 --> 00:26:51,470
gonna do one other thing and this is

00:26:48,590 --> 00:26:54,980
this is relevant so I renamed X to a

00:26:51,470 --> 00:26:57,950
alright and my query I wrote X but year

00:26:54,980 --> 00:26:59,030
I'm writing a and that's both because of

00:26:57,950 --> 00:27:02,210
course the names of the variables

00:26:59,030 --> 00:27:04,460
doesn't matter as long as they're within

00:27:02,210 --> 00:27:07,610
one thing but also this corresponds to

00:27:04,460 --> 00:27:12,170
what we call canonicalization and Charma

00:27:07,610 --> 00:27:14,240
so basically one of the steps in chalk

00:27:12,170 --> 00:27:16,910
when you try to create a table or you

00:27:14,240 --> 00:27:18,320
create a tree in the forest is you

00:27:16,910 --> 00:27:20,660
canonicalize the names of all the

00:27:18,320 --> 00:27:23,210
variables so that they start in this

00:27:20,660 --> 00:27:25,370
case I'm starting from a and going BCD

00:27:23,210 --> 00:27:28,580
like in the order of which they appear

00:27:25,370 --> 00:27:30,650
and that way if you had multiple queries

00:27:28,580 --> 00:27:35,570
that are all kind of variations of this

00:27:30,650 --> 00:27:37,190
you'll end up at the same tree but one

00:27:35,570 --> 00:27:40,760
easy way to do that is just to Nate will

00:27:37,190 --> 00:27:42,800
always have the consistent naming so

00:27:40,760 --> 00:27:44,750
copy about tonight here so this is our

00:27:42,800 --> 00:27:47,420
estate and if we go back to our rules

00:27:44,750 --> 00:27:48,650
you know we can't apply you 32 we're

00:27:47,420 --> 00:27:51,230
gonna do the same thing as we did before

00:27:48,650 --> 00:27:53,720
and there's only going to be one program

00:27:51,230 --> 00:27:58,550
cause we can apply to make the child

00:27:53,720 --> 00:28:00,580
which is we can apply this one the one

00:27:58,550 --> 00:28:06,020
we have the same as here but this time

00:28:00,580 --> 00:28:13,040
the variable t winds up getting maps

00:28:06,020 --> 00:28:14,690
basically to a right because the t from

00:28:13,040 --> 00:28:15,980
that clause because that's the thing we

00:28:14,690 --> 00:28:18,679
don't we still don't know exactly what

00:28:15,980 --> 00:28:21,110
child were proving for and so now we

00:28:18,679 --> 00:28:23,090
have to prove the sub goal here is is

00:28:21,110 --> 00:28:26,000
now copy a which is different from copy

00:28:23,090 --> 00:28:29,080
32 because it has a variable in it so

00:28:26,000 --> 00:28:29,080
we'll make a table for that

00:28:33,650 --> 00:28:42,860
sorry yeah we'll make up a tree yes or

00:28:38,480 --> 00:28:45,440
table and and now we have to find

00:28:42,860 --> 00:28:46,790
answers for that and here we get a

00:28:45,440 --> 00:28:49,700
little more interesting in some of our

00:28:46,790 --> 00:28:52,940
other cases because there's actually all

00:28:49,700 --> 00:28:55,490
of these rules could unify now because

00:28:52,940 --> 00:28:57,800
you have a type variable so we can make

00:28:55,490 --> 00:29:06,230
three children you can make copy of you

00:28:57,800 --> 00:29:17,030
32 you can make copy of F 32 we can make

00:29:06,230 --> 00:29:19,910
copy option and I want to point out a

00:29:17,030 --> 00:29:23,090
few things so first of all coming back

00:29:19,910 --> 00:29:26,890
to or like in back too soon J's question

00:29:23,090 --> 00:29:30,320
you see that but this part the left part

00:29:26,890 --> 00:29:32,030
these are all versions of their of the

00:29:30,320 --> 00:29:33,680
root note that they have some things

00:29:32,030 --> 00:29:36,470
partially specified so if we look at

00:29:33,680 --> 00:29:39,260
this like when we go down this path to

00:29:36,470 --> 00:29:42,220
proving that route annuities we actually

00:29:39,260 --> 00:29:48,320
have a value for a now I'm gonna call

00:29:42,220 --> 00:29:50,540
okay I'm gonna call this B and here we

00:29:48,320 --> 00:29:52,340
have a value for a which is F 32 and

00:29:50,540 --> 00:29:53,540
here we have a partial value we know

00:29:52,340 --> 00:29:56,900
that it's an option but we don't know

00:29:53,540 --> 00:30:01,190
what it's not enough yet um so as we go

00:29:56,900 --> 00:30:02,630
this as we as we go down a tree we

00:30:01,190 --> 00:30:04,760
always stay with something that can be

00:30:02,630 --> 00:30:06,380
unified with this original goal we were

00:30:04,760 --> 00:30:11,840
trying to prove but it gets more and

00:30:06,380 --> 00:30:15,230
more specific question

00:30:11,840 --> 00:30:17,630
so we also store some kind of

00:30:15,230 --> 00:30:21,860
substitution table which says that like

00:30:17,630 --> 00:30:27,680
a is 52 well like when we produce a new

00:30:21,860 --> 00:30:29,270
subtree mm-hmm so like is this

00:30:27,680 --> 00:30:30,380
information like really is stored and

00:30:29,270 --> 00:30:32,600
like probably it should like be

00:30:30,380 --> 00:30:35,510
mentioned in the paper look just to see

00:30:32,600 --> 00:30:37,700
it yeah I'm gonna come to map to the

00:30:35,510 --> 00:30:40,820
code but what we actually do here it's a

00:30:37,700 --> 00:30:44,600
good question so in the actual code if I

00:30:40,820 --> 00:30:46,610
recall I think we only store the values

00:30:44,600 --> 00:30:47,590
for these we store two things in the

00:30:46,610 --> 00:30:51,070
table for

00:30:47,590 --> 00:30:53,230
tree we keep this this root goal that we

00:30:51,070 --> 00:30:55,570
originally had and then for each child

00:30:53,230 --> 00:30:57,159
within the tree each node within the

00:30:55,570 --> 00:30:59,950
tree we store the values for these

00:30:57,159 --> 00:31:01,510
variables so we wouldn't actually kind

00:30:59,950 --> 00:31:05,830
of repeat all the information we would

00:31:01,510 --> 00:31:09,159
just kind of keep like hey is your 3200

00:31:05,830 --> 00:31:11,020
here in this path that's what it is in

00:31:09,159 --> 00:31:13,230
this formulation that comes from the

00:31:11,020 --> 00:31:15,730
paper you can sort of reproduce that by

00:31:13,230 --> 00:31:17,320
unifying the two of them and figuring

00:31:15,730 --> 00:31:23,230
out what the substitution is that makes

00:31:17,320 --> 00:31:25,720
them unify yeah thanks sense so right so

00:31:23,230 --> 00:31:29,370
now we have three children here and

00:31:25,720 --> 00:31:32,220
interestingly two of them are answers

00:31:29,370 --> 00:31:35,649
and this one is not an answer node

00:31:32,220 --> 00:31:37,000
however it is an instance of something

00:31:35,649 --> 00:31:39,549
which we hadn't seen before which is a

00:31:37,000 --> 00:31:41,140
cycle which kind of gets back to some of

00:31:39,549 --> 00:31:44,140
the questions 2j was asking I think but

00:31:41,140 --> 00:31:48,130
yeah so this this sub goal here copy B

00:31:44,140 --> 00:31:51,370
we already have a table for it and it's

00:31:48,130 --> 00:31:54,580
actually ourselves right um so what we

00:31:51,370 --> 00:31:56,710
can do is we can add answers to this

00:31:54,580 --> 00:32:00,429
note by taking them from other parts of

00:31:56,710 --> 00:32:09,149
this the same tree so we can say well if

00:32:00,429 --> 00:32:09,149
B for example were you 32 that would be

00:32:11,730 --> 00:32:21,429
that would be one sort of child we could

00:32:16,059 --> 00:32:25,600
add let me get out another one for the

00:32:21,429 --> 00:32:28,059
case of F 32 but now each as as we do

00:32:25,600 --> 00:32:29,679
this we're creating more answers right

00:32:28,059 --> 00:32:32,850
this is where you get that infinite set

00:32:29,679 --> 00:32:46,270
because we could go ahead and add one

00:32:32,850 --> 00:32:47,559
like this which comes from here right

00:32:46,270 --> 00:32:48,970
and so you can see that will never

00:32:47,559 --> 00:32:50,380
actually if we keep repeating this

00:32:48,970 --> 00:32:51,730
process we'll never really reach a fixed

00:32:50,380 --> 00:32:55,600
point we'll just keep growing the tree

00:32:51,730 --> 00:32:57,880
infinitely but we always at any point we

00:32:55,600 --> 00:33:01,350
have a kind of partial set of answers

00:32:57,880 --> 00:33:01,350
these are the answers we found so far

00:33:05,730 --> 00:33:12,190
so friends do we actually detect this

00:33:09,100 --> 00:33:14,230
cycle like and if we detect the psyche

00:33:12,190 --> 00:33:19,030
of how do we do it by using kinect

00:33:14,230 --> 00:33:24,370
canonicalization yes we detect this

00:33:19,030 --> 00:33:26,950
cycle and yes you canonicalization so in

00:33:24,370 --> 00:33:31,870
the actual code there would be a and not

00:33:26,950 --> 00:33:35,050
B in the yeah you could think of it as

00:33:31,870 --> 00:33:37,600
we canonicalize this in order to find a

00:33:35,050 --> 00:33:43,660
tree for this economical is it

00:33:37,600 --> 00:33:48,010
so copy B is canonicalized a copy of a

00:33:43,660 --> 00:33:49,180
which has the truth you're not actually

00:33:48,010 --> 00:33:50,380
is not a matter of thinking of it that

00:33:49,180 --> 00:33:54,340
way that's actually literally what

00:33:50,380 --> 00:33:56,320
happens and then since it has the tree

00:33:54,340 --> 00:34:00,460
we can go look we can go look for

00:33:56,320 --> 00:34:01,990
answers within tree um the way that we

00:34:00,460 --> 00:34:04,510
handle this in the code we're gonna I'm

00:34:01,990 --> 00:34:08,260
gonna start mapping now to the more

00:34:04,510 --> 00:34:11,110
concrete code but is it's basically we

00:34:08,260 --> 00:34:14,350
don't the goal is usually not to run

00:34:11,110 --> 00:34:15,790
till a fixpoint part of the way reason I

00:34:14,350 --> 00:34:17,530
showed it this way of like building up

00:34:15,790 --> 00:34:22,270
and applying these steps one by one is

00:34:17,530 --> 00:34:24,190
that the goal is to iteratively produce

00:34:22,270 --> 00:34:28,540
the answers and decide if it makes sense

00:34:24,190 --> 00:34:30,250
to keep going so in the case of if we

00:34:28,540 --> 00:34:34,240
were actually asking this query in the

00:34:30,250 --> 00:34:36,460
RUS compiler we know that we kind of

00:34:34,240 --> 00:34:38,680
don't want to guess the value for x so

00:34:36,460 --> 00:34:41,200
if for some reason we haven't figured

00:34:38,680 --> 00:34:43,930
out what x is yet as soon as we get two

00:34:41,200 --> 00:34:45,220
different answers that don't well they

00:34:43,930 --> 00:34:48,190
aren't compatible with one another like

00:34:45,220 --> 00:34:49,810
if we got you 32 + f 32 we can just kind

00:34:48,190 --> 00:34:51,970
of stop we don't have to keep going

00:34:49,810 --> 00:34:55,330
because there's nothing useful for us

00:34:51,970 --> 00:35:01,000
yet like we're not gonna be able X is

00:34:55,330 --> 00:35:03,880
not uniquely determined so so we should

00:35:01,000 --> 00:35:06,340
just stop searching for answers and see

00:35:03,880 --> 00:35:10,810
if other parts of the program can string

00:35:06,340 --> 00:35:12,200
X um that might be jumping up too far

00:35:10,810 --> 00:35:13,790
our level but base

00:35:12,200 --> 00:35:15,109
I'm saying is you know there is an

00:35:13,790 --> 00:35:16,579
infinite set of answers but that doesn't

00:35:15,109 --> 00:35:19,520
mean we have to produce it and that's

00:35:16,579 --> 00:35:21,859
kind of up on our callers job to to try

00:35:19,520 --> 00:35:23,930
to not keep asking for more answers when

00:35:21,859 --> 00:35:26,540
they're not that useful but this is one

00:35:23,930 --> 00:35:28,760
of the challenges and we have also some

00:35:26,540 --> 00:35:30,950
safeguards in the engine that I don't

00:35:28,760 --> 00:35:34,369
plan to get to today that basically stop

00:35:30,950 --> 00:35:35,480
it from producing if things are getting

00:35:34,369 --> 00:35:36,980
too big and it seems like we're

00:35:35,480 --> 00:35:41,119
producing too many answers they start to

00:35:36,980 --> 00:35:43,579
just say like just produce uncertain

00:35:41,119 --> 00:35:48,740
values and they will stop it so that it

00:35:43,579 --> 00:35:50,799
always eventually stops so hopefully

00:35:48,740 --> 00:35:55,480
those safeguards don't kick in is they

00:35:50,799 --> 00:35:55,480
it forces to produce approximate results

00:35:56,589 --> 00:36:06,020
which today in the RUS compiler

00:35:59,750 --> 00:36:08,299
corresponds to overflow right so this is

00:36:06,020 --> 00:36:10,250
the way that the paper looks at things I

00:36:08,299 --> 00:36:14,990
failed to reference back on that I meant

00:36:10,250 --> 00:36:17,750
to I'm just gonna show you real fast in

00:36:14,990 --> 00:36:19,069
case you're curious to read it this is

00:36:17,750 --> 00:36:21,559
the way they notate things so I

00:36:19,069 --> 00:36:23,290
mentioned there's these trees this is an

00:36:21,559 --> 00:36:26,869
example of the tree here's the root node

00:36:23,290 --> 00:36:28,940
here are the children on their children

00:36:26,869 --> 00:36:30,619
and we didn't get to failure but

00:36:28,940 --> 00:36:33,200
sometimes you have failures where that

00:36:30,619 --> 00:36:36,290
basically means this was not provable

00:36:33,200 --> 00:36:38,000
there was this was false um so children

00:36:36,290 --> 00:36:45,250
can either yield and eventually a child

00:36:38,000 --> 00:36:47,599
either yield an answer or fail and the

00:36:45,250 --> 00:36:49,819
and they have basically here's the set

00:36:47,599 --> 00:36:53,329
of things which say these are the

00:36:49,819 --> 00:36:57,020
operations I've mentioned these three so

00:36:53,329 --> 00:36:59,839
far so like program clause resolution

00:36:57,020 --> 00:37:01,250
positive return new sub goal these are

00:36:59,839 --> 00:37:02,750
the things where we say taking the tree

00:37:01,250 --> 00:37:05,990
in what this is like the state machine

00:37:02,750 --> 00:37:07,849
transition rules take the tree if this

00:37:05,990 --> 00:37:11,990
conditions apply we can add a new node

00:37:07,849 --> 00:37:14,710
to the tree this is saying it can take a

00:37:11,990 --> 00:37:17,000
program clause this is saying we can

00:37:14,710 --> 00:37:20,690
propagate an answer from one tree to

00:37:17,000 --> 00:37:21,790
another businessing we can create a new

00:37:20,690 --> 00:37:23,410
tree

00:37:21,790 --> 00:37:25,390
all these other things have to do with

00:37:23,410 --> 00:37:30,160
negative reasoning which we're not going

00:37:25,390 --> 00:37:33,730
to get to you so those are the basic

00:37:30,160 --> 00:37:42,870
three operations and now let's look a

00:37:33,730 --> 00:37:45,190
little bit at the code oops not good so

00:37:42,870 --> 00:37:48,660
see if I remembered all the things I

00:37:45,190 --> 00:37:48,660
meant to talk about looks like you did

00:37:49,950 --> 00:37:54,490
so let me try to show you how this stuff

00:37:52,360 --> 00:37:56,950
this kind of abstract stuff I've been

00:37:54,490 --> 00:37:59,950
talking about is represented in the code

00:37:56,950 --> 00:38:02,320
itself um first of all the forest of

00:37:59,950 --> 00:38:08,890
trees is in that type creatively called

00:38:02,320 --> 00:38:11,860
the forest um and it has a list of lists

00:38:08,890 --> 00:38:15,130
of trees which I call tables I confess

00:38:11,860 --> 00:38:17,650
this is a little incongruous and a stack

00:38:15,130 --> 00:38:20,020
the stack is when we're not actively

00:38:17,650 --> 00:38:21,610
doing anything the stack is empty but I

00:38:20,020 --> 00:38:23,230
like to see the scapular we'll see you

00:38:21,610 --> 00:38:27,880
later that's how we detect cycles for

00:38:23,230 --> 00:38:30,930
your question um and we can just ignore

00:38:27,880 --> 00:38:36,370
the stack for them so the list of tables

00:38:30,930 --> 00:38:39,790
the tables is just a vector we map here

00:38:36,370 --> 00:38:41,380
we have so this this big type so what's

00:38:39,790 --> 00:38:44,980
going on here first of all meet step

00:38:41,380 --> 00:38:47,650
back this see in the chalk engine itself

00:38:44,980 --> 00:38:49,990
is very generic it just thinks about

00:38:47,650 --> 00:38:52,090
logical things and doesn't know anything

00:38:49,990 --> 00:38:54,580
about rust and so on and so this see

00:38:52,090 --> 00:38:56,200
supplies like all the concrete types for

00:38:54,580 --> 00:38:58,030
what how do you represent a composition

00:38:56,200 --> 00:39:01,900
how do you represent a type a kind of

00:38:58,030 --> 00:39:03,970
stuff um so in this case this you

00:39:01,900 --> 00:39:06,870
canonical Bowl environment this is

00:39:03,970 --> 00:39:09,400
saying basically here we're mapping from

00:39:06,870 --> 00:39:13,240
the canonical goal that we're trying to

00:39:09,400 --> 00:39:15,880
prove to an index of an actual table so

00:39:13,240 --> 00:39:18,360
if we come back up here the canonical

00:39:15,880 --> 00:39:21,280
goal might would be like one of these or

00:39:18,360 --> 00:39:24,400
your copy of option A something like

00:39:21,280 --> 00:39:25,900
that and that's where we that's how we

00:39:24,400 --> 00:39:27,910
detect if you already have a table for

00:39:25,900 --> 00:39:29,770
that goal we can find the index

00:39:27,910 --> 00:39:31,830
otherwise we can but there's even an

00:39:29,770 --> 00:39:34,230
operation probably somewhere

00:39:31,830 --> 00:39:48,330
anyway and then there's just a vector of

00:39:34,230 --> 00:39:49,590
tables the table is tables here this

00:39:48,330 --> 00:39:52,680
starts to look a little bit different

00:39:49,590 --> 00:39:55,890
than the in the mathematical structure

00:39:52,680 --> 00:39:57,090
so kidding but there's definitely a

00:39:55,890 --> 00:40:00,150
mapping between them but it's different

00:39:57,090 --> 00:40:02,630
and let me explain it so we got two main

00:40:00,150 --> 00:40:06,360
things the first is a list of okay so

00:40:02,630 --> 00:40:08,790
the first is a list of answers and the

00:40:06,360 --> 00:40:10,500
second is a list of strands and what

00:40:08,790 --> 00:40:14,130
that corresponds to in the mathematical

00:40:10,500 --> 00:40:16,290
table is basically for any given we

00:40:14,130 --> 00:40:17,790
don't keep all the intermediate nodes in

00:40:16,290 --> 00:40:22,800
the tree because that's kind of

00:40:17,790 --> 00:40:25,470
unnecessary so we keep the leaves but

00:40:22,800 --> 00:40:32,760
basically all the leaves at any point

00:40:25,470 --> 00:40:34,470
and we we have we keep legacy would say

00:40:32,760 --> 00:40:35,940
we keep leaves and we keep intermediate

00:40:34,470 --> 00:40:39,510
nodes where there might yet be board

00:40:35,940 --> 00:40:42,960
children and so the Leafs are either an

00:40:39,510 --> 00:40:44,430
answer in which case we're gonna put it

00:40:42,960 --> 00:40:46,320
in that answer Beck one where there's no

00:40:44,430 --> 00:40:48,390
more sub-goals left or what we call a

00:40:46,320 --> 00:40:51,240
strand which is like a thread that's

00:40:48,390 --> 00:40:53,910
like work to do and that's where there

00:40:51,240 --> 00:40:56,550
are still sub-goals remaining and so

00:40:53,910 --> 00:41:01,980
when we have some intermediate node like

00:40:56,550 --> 00:41:03,780
this one will this this one wasn't was a

00:41:01,980 --> 00:41:05,520
case where we actually were able to

00:41:03,780 --> 00:41:06,990
produce three different sub children I

00:41:05,520 --> 00:41:08,880
said what we would do is we would take

00:41:06,990 --> 00:41:10,170
that one this would be us before we

00:41:08,880 --> 00:41:12,780
actually produce these three sub

00:41:10,170 --> 00:41:13,980
children this would be a strand we would

00:41:12,780 --> 00:41:17,460
find the rules and we would produce

00:41:13,980 --> 00:41:18,090
three more strands that need to be

00:41:17,460 --> 00:41:20,280
processed

00:41:18,090 --> 00:41:22,230
one for each rule that we could apply

00:41:20,280 --> 00:41:23,760
right and then some of those strands

00:41:22,230 --> 00:41:27,780
would get converted to answers there's

00:41:23,760 --> 00:41:30,690
no more rules left maybe all um that's

00:41:27,780 --> 00:41:33,720
the basic idea so so the strands are

00:41:30,690 --> 00:41:35,970
work left to do and the answers are

00:41:33,720 --> 00:41:39,540
answers we've already found and what we

00:41:35,970 --> 00:41:42,690
do is we have we give these answers in

00:41:39,540 --> 00:41:44,130
order I'm basically the order in which

00:41:42,690 --> 00:41:45,570
we found them the zeroth answer or the

00:41:44,130 --> 00:41:46,890
first answer in song

00:41:45,570 --> 00:41:50,400
and that we'll see that in a second I

00:41:46,890 --> 00:41:52,080
want them so now that's that's kind of a

00:41:50,400 --> 00:41:55,380
steady state at any given point you have

00:41:52,080 --> 00:41:57,180
a list of forest of trees which we call

00:41:55,380 --> 00:41:58,680
tables for each table it's a table of

00:41:57,180 --> 00:42:00,000
answers we have a set of answers we've

00:41:58,680 --> 00:42:01,290
found so far and we have a set of things

00:42:00,000 --> 00:42:03,960
we could do that might produce more

00:42:01,290 --> 00:42:08,280
answers so the strengths are kind of

00:42:03,960 --> 00:42:10,290
like said the leaf salsa Latrice yeah I

00:42:08,280 --> 00:42:14,370
think it's safe it's like leaves with

00:42:10,290 --> 00:42:15,750
active sub goals but non-empty um you

00:42:14,370 --> 00:42:18,510
are either called strands

00:42:15,750 --> 00:42:25,650
I called them strands because I think of

00:42:18,510 --> 00:42:28,830
them as threats so that's not a term

00:42:25,650 --> 00:42:30,750
from from any paper or anything so I

00:42:28,830 --> 00:42:32,670
think of it as a thread because what

00:42:30,750 --> 00:42:34,050
we're gonna do later I'm going to talk a

00:42:32,670 --> 00:42:35,610
little bit about like the scheduling

00:42:34,050 --> 00:42:38,340
aspect of this the sort of a search

00:42:35,610 --> 00:42:40,500
order but ideas you're gonna your

00:42:38,340 --> 00:42:43,590
incremental e growing this tree right

00:42:40,500 --> 00:42:45,330
and it kind of matters the order in

00:42:43,590 --> 00:42:48,600
which we choose to evaluate how we

00:42:45,330 --> 00:42:53,510
choose to walk the tree so the strands

00:42:48,600 --> 00:42:55,710
are like a given direction we can go and

00:42:53,510 --> 00:42:57,240
like any thread scheduler we want to

00:42:55,710 --> 00:43:00,840
kind of make sure that all those strands

00:42:57,240 --> 00:43:07,500
have time to or have some share of the

00:43:00,840 --> 00:43:10,040
total time that we spend working so you

00:43:07,500 --> 00:43:14,490
can think of it like if you had to solve

00:43:10,040 --> 00:43:18,810
there's some if all the tree sort of

00:43:14,490 --> 00:43:21,090
exists in your mind in potential space

00:43:18,810 --> 00:43:22,920
and you have to explore it the strand is

00:43:21,090 --> 00:43:26,640
like a particular path that you're

00:43:22,920 --> 00:43:28,650
taking down the street maybe it should

00:43:26,640 --> 00:43:29,910
be called path I don't know there's it's

00:43:28,650 --> 00:43:33,680
clear that we could go over these terms

00:43:29,910 --> 00:43:39,150
and try a unifier don't be interesting

00:43:33,680 --> 00:43:47,310
so right they actually an actual strand

00:43:39,150 --> 00:43:50,190
that's is represented here and there's

00:43:47,310 --> 00:43:51,780
actually two types here but let's just

00:43:50,190 --> 00:43:56,040
ignore the canonical strain for a second

00:43:51,780 --> 00:43:57,560
so a strand consists of an X clause

00:43:56,040 --> 00:44:00,950
which is that

00:43:57,560 --> 00:44:03,470
the term for this funny notation here of

00:44:00,950 --> 00:44:05,000
like Cola three parts basically the

00:44:03,470 --> 00:44:06,860
thing we're trying to prove the delayed

00:44:05,000 --> 00:44:09,500
things which we didn't do and the sub

00:44:06,860 --> 00:44:11,540
goals we'll see it in a second and it

00:44:09,500 --> 00:44:15,170
consists then of a selected sub goal

00:44:11,540 --> 00:44:17,090
which is basically what part the strand

00:44:15,170 --> 00:44:24,800
is working on now if any will come back

00:44:17,090 --> 00:44:26,360
to life so the let me talk to two more

00:44:24,800 --> 00:44:29,240
things to say about strands so the

00:44:26,360 --> 00:44:30,680
strand is basically an X clause there's

00:44:29,240 --> 00:44:36,620
a little bit of extra state called the

00:44:30,680 --> 00:44:38,390
selected sub goal but it's basically

00:44:36,620 --> 00:44:51,260
with a label from one of those nodes in

00:44:38,390 --> 00:44:53,480
the tree and an X Clause oh I wanted to

00:44:51,260 --> 00:44:54,110
talk about the canonical stream no I

00:44:53,480 --> 00:44:55,700
don't actually

00:44:54,110 --> 00:44:56,990
the canonical strand is just a strand

00:44:55,700 --> 00:44:57,770
that's not active that's been

00:44:56,990 --> 00:45:00,020
canonicalized

00:44:57,770 --> 00:45:06,440
the details of that have to do with how

00:45:00,020 --> 00:45:08,180
rust rust sees infants tables work like

00:45:06,440 --> 00:45:10,280
why we need that otherwise you could

00:45:08,180 --> 00:45:11,780
just keep strands as they were in fact

00:45:10,280 --> 00:45:15,200
earlier versions didn't have a notion of

00:45:11,780 --> 00:45:20,330
canonical school so TL DR doesn't really

00:45:15,200 --> 00:45:23,450
matter we'll come back to India this is

00:45:20,330 --> 00:45:29,480
the way we represent an X cause so Matt

00:45:23,450 --> 00:45:31,010
clad per your question we have this is

00:45:29,480 --> 00:45:32,870
the list of things we have yet to prove

00:45:31,010 --> 00:45:34,160
the sub goals this is the list of

00:45:32,870 --> 00:45:36,320
delayed literals that are needed for

00:45:34,160 --> 00:45:38,330
negative reasoning that we haven't used

00:45:36,320 --> 00:45:41,150
yet and this is the way we represent

00:45:38,330 --> 00:45:43,280
that the thing we're trying to prove and

00:45:41,150 --> 00:45:47,450
you see it's just a substitution so we

00:45:43,280 --> 00:45:49,100
hope we don't repeat the the information

00:45:47,450 --> 00:45:53,600
that's always the same for everything

00:45:49,100 --> 00:45:57,590
within the table this would be like the

00:45:53,600 --> 00:46:05,600
a equals u 32 and so on um and for any

00:45:57,590 --> 00:46:07,730
act that makes sense so let's actually

00:46:05,600 --> 00:46:12,160
walk a little bit do this and see how

00:46:07,730 --> 00:46:12,160
this works so

00:46:12,969 --> 00:46:19,219
these are the pieces and what happens

00:46:16,009 --> 00:46:29,719
there's a basic operation actually

00:46:19,219 --> 00:46:31,369
personal links copy the way that what

00:46:29,719 --> 00:46:38,529
happens in the actual solver like the

00:46:31,369 --> 00:46:42,259
outermost interface before I get to this

00:46:38,529 --> 00:46:49,309
sort of the solver interface you can do

00:46:42,259 --> 00:46:53,959
is you can say here is a gold here is a

00:46:49,309 --> 00:46:59,029
canonical gold G so for example this

00:46:53,959 --> 00:47:00,979
might be in terms of our stuff we've

00:46:59,029 --> 00:47:04,759
been doing this is basically something

00:47:00,979 --> 00:47:08,630
like that and you can say give me answer

00:47:04,759 --> 00:47:10,759
n from that goal and usually you would

00:47:08,630 --> 00:47:12,559
start at zero and then you would go to

00:47:10,759 --> 00:47:17,689
one you can keep asking for more answers

00:47:12,559 --> 00:47:19,819
if you like um actually I think you

00:47:17,689 --> 00:47:21,319
actually get depends on where you draw

00:47:19,819 --> 00:47:24,380
the line I think these fundamental

00:47:21,319 --> 00:47:27,979
interfaces like a slightly abstract as

00:47:24,380 --> 00:47:31,130
you get back an iterator of answers but

00:47:27,979 --> 00:47:36,319
internally the iterator is going to ask

00:47:31,130 --> 00:47:49,189
for answer n bulgy and let me show you

00:47:36,319 --> 00:47:51,920
what I mean by ask I mean okay well this

00:47:49,189 --> 00:47:55,189
is where you get the iterator to see it

00:47:51,920 --> 00:47:56,920
are over the answers for some gold and

00:47:55,189 --> 00:47:59,630
it gives you back a stream of answers

00:47:56,920 --> 00:48:01,609
and internally what that's going to do

00:47:59,630 --> 00:48:03,229
is keep a counter and it's gonna call

00:48:01,609 --> 00:48:07,130
this method called ensure answer

00:48:03,229 --> 00:48:11,150
recursively so what this tries to do is

00:48:07,130 --> 00:48:13,069
it says given some goal that we're

00:48:11,150 --> 00:48:13,609
trying to prove the table the table for

00:48:13,069 --> 00:48:16,009
some goal

00:48:13,609 --> 00:48:17,630
find the answer number end and the

00:48:16,009 --> 00:48:19,789
reason I call it ensure is that this

00:48:17,630 --> 00:48:21,799
state persist between queries so it

00:48:19,789 --> 00:48:23,900
might be that we already found a zeroth

00:48:21,799 --> 00:48:26,000
answer for that particular or and

00:48:23,900 --> 00:48:27,260
for that particular goal in which case

00:48:26,000 --> 00:48:30,980
this is just gonna return immediately

00:48:27,260 --> 00:48:33,050
but if we haven't found the answer then

00:48:30,980 --> 00:48:36,170
it's gonna go do you the work to try to

00:48:33,050 --> 00:48:42,200
find it so you can see that here's the

00:48:36,170 --> 00:48:46,310
actual logic the first thing it does is

00:48:42,200 --> 00:48:48,200
it loads the table that were which

00:48:46,310 --> 00:48:50,510
corresponds to the goal and it checks if

00:48:48,200 --> 00:48:56,150
there's an answer already and if so it

00:48:50,510 --> 00:48:57,710
just returns it all done um otherwise it

00:48:56,150 --> 00:49:00,230
checks for cycles on the stack

00:48:57,710 --> 00:49:04,010
do you know that for a second otherwise

00:49:00,230 --> 00:49:07,730
it calls this pursue so pursue next

00:49:04,010 --> 00:49:12,500
strand if we visualize it um

00:49:07,730 --> 00:49:13,640
others might work if you had like let's

00:49:12,500 --> 00:49:17,000
say the first thing you did was you

00:49:13,640 --> 00:49:23,420
asked for a copy of you 32 I might make

00:49:17,000 --> 00:49:26,990
a table which corresponds to where was

00:49:23,420 --> 00:49:28,520
the case we had two links let's go

00:49:26,990 --> 00:49:30,140
through the examples one by one if the

00:49:28,520 --> 00:49:33,410
first thing we asked was for copy of you

00:49:30,140 --> 00:49:36,110
32 we would make a table for copy of you

00:49:33,410 --> 00:49:38,330
32 and it would come up with an answer 0

00:49:36,110 --> 00:49:43,070
which is just like yes with an empty

00:49:38,330 --> 00:49:46,070
substitution there's no variables and

00:49:43,070 --> 00:49:49,790
then if we later asked for a copy of

00:49:46,070 --> 00:49:52,820
option new 32 it would create a table

00:49:49,790 --> 00:49:54,710
for that which would internally ask for

00:49:52,820 --> 00:49:57,500
the 0th answer from this table which

00:49:54,710 --> 00:50:00,650
would get it cashed back already and and

00:49:57,500 --> 00:50:03,560
thus it would grow eventually grow

00:50:00,650 --> 00:50:06,140
another answer here and so on and then

00:50:03,560 --> 00:50:09,290
if we asked for a copy of option of X I

00:50:06,140 --> 00:50:14,360
think the way I did it however was or if

00:50:09,290 --> 00:50:15,620
we asked for copy of X well anyway as

00:50:14,360 --> 00:50:16,820
you asked for more tables they may

00:50:15,620 --> 00:50:23,840
reference prior tables

00:50:16,820 --> 00:50:27,110
um well very sec so how do we ask for a

00:50:23,840 --> 00:50:28,790
table copy of option.you 32 first it

00:50:27,110 --> 00:50:32,180
would have created the other table for

00:50:28,790 --> 00:50:35,380
coffee 32 yeah so what do I mean by ask

00:50:32,180 --> 00:50:37,700
what I mean by ask is that you invoke

00:50:35,380 --> 00:50:39,140
like at the outermost level it means you

00:50:37,700 --> 00:50:43,730
tell the forest to iterate over the

00:50:39,140 --> 00:50:48,530
answers for that cold right but

00:50:43,730 --> 00:50:50,480
internally there's it might ask in some

00:50:48,530 --> 00:50:56,840
sense as well by calling Insurance

00:50:50,480 --> 00:51:00,880
Services and so I guess there are

00:50:56,840 --> 00:51:00,880
multiple people who can be asking but

00:51:01,660 --> 00:51:17,900
that make sense yeah so the let's see so

00:51:15,920 --> 00:51:19,970
let's look what does this actually do so

00:51:17,900 --> 00:51:21,440
if if I mentioned that it will return a

00:51:19,970 --> 00:51:23,540
cached answer if one exists otherwise

00:51:21,440 --> 00:51:25,900
it'll go to compute one um

00:51:23,540 --> 00:51:30,200
pursue next strand itself isn't that

00:51:25,900 --> 00:51:33,680
interesting it you know but it's basic

00:51:30,200 --> 00:51:36,140
job is to grab it takes it goes to the

00:51:33,680 --> 00:51:39,460
table it pops the strand from that list

00:51:36,140 --> 00:51:42,260
of strands that are appending

00:51:39,460 --> 00:51:46,520
instantiates it which has to do with how

00:51:42,260 --> 00:51:48,770
rusty manages memory but so most of this

00:51:46,520 --> 00:51:49,760
like all this this logic here I'll come

00:51:48,770 --> 00:51:51,200
back to it in a second but this is

00:51:49,760 --> 00:51:54,140
basically saying process that strand

00:51:51,200 --> 00:51:57,650
that I pumped and then it propagates the

00:51:54,140 --> 00:52:01,280
answer and so the process that strand

00:51:57,650 --> 00:52:03,080
that I popped basically winds up going

00:52:01,280 --> 00:52:06,440
through I don't want to go into the

00:52:03,080 --> 00:52:08,840
details of this but suffice to say that

00:52:06,440 --> 00:52:10,850
it calls this method soon earlier called

00:52:08,840 --> 00:52:13,970
pursue strand right and so this point is

00:52:10,850 --> 00:52:18,110
when you say ok let's come back to work

00:52:13,970 --> 00:52:20,240
to our reasoning in terms of this logic

00:52:18,110 --> 00:52:22,100
we've basically now descended into some

00:52:20,240 --> 00:52:24,140
sub tree and where we're trying to take

00:52:22,100 --> 00:52:27,170
the next step based on its current state

00:52:24,140 --> 00:52:29,750
um so we have the X clause it has a list

00:52:27,170 --> 00:52:31,250
of pending sub goals that may or may not

00:52:29,750 --> 00:52:35,180
be empty and we want to examine it and

00:52:31,250 --> 00:52:37,970
figure out what to do so we'll go and

00:52:35,180 --> 00:52:42,350
say okay if no sub goal has been

00:52:37,970 --> 00:52:43,580
selected so if we come back to let's

00:52:42,350 --> 00:52:48,670
actually work

00:52:43,580 --> 00:52:48,670
let's say we were trying to do here

00:52:50,480 --> 00:53:01,260
copy of a we'll do this

00:52:53,400 --> 00:53:03,960
suppose we were asking this query um we

00:53:01,260 --> 00:53:09,000
would create the table for copy of a and

00:53:03,960 --> 00:53:10,860
we would I didn't mention this but when

00:53:09,000 --> 00:53:12,390
we create a table for a given goal if

00:53:10,860 --> 00:53:14,190
you remember whenever we did things

00:53:12,390 --> 00:53:16,380
there was this root node was kind of

00:53:14,190 --> 00:53:18,420
special and then the immediate children

00:53:16,380 --> 00:53:20,370
of the root node they all came from the

00:53:18,420 --> 00:53:24,030
program clauses that we had from our

00:53:20,370 --> 00:53:25,740
program here all right and so those two

00:53:24,030 --> 00:53:27,810
steps are kind of special and different

00:53:25,740 --> 00:53:29,250
because that's where you actually load

00:53:27,810 --> 00:53:30,510
from the program so what we do is we do

00:53:29,250 --> 00:53:34,590
that immediately when we create the

00:53:30,510 --> 00:53:40,110
table we also populate it with all of

00:53:34,590 --> 00:53:44,300
the results from the from the program

00:53:40,110 --> 00:53:44,300
clauses you don't have to do it that way

00:53:44,330 --> 00:53:51,090
but it's convenient to do it all at once

00:53:47,220 --> 00:53:52,320
and actually tutor me

00:53:51,090 --> 00:53:55,770
and wear your real name sorry if you

00:53:52,320 --> 00:53:57,150
have Lucas any case that I call back you

00:53:55,770 --> 00:54:01,800
were writing that's exactly what does

00:53:57,150 --> 00:54:06,390
this sure is um it's exactly where we

00:54:01,800 --> 00:54:09,240
get the list of things from so so we

00:54:06,390 --> 00:54:12,330
would be in a state like so where we

00:54:09,240 --> 00:54:13,620
have a table with three strands as soon

00:54:12,330 --> 00:54:21,440
as we create the table we would populate

00:54:13,620 --> 00:54:21,440
it with three strands but no answers um

00:54:21,980 --> 00:54:25,920
also I should not have this be a text

00:54:24,720 --> 00:54:27,960
area either that's good

00:54:25,920 --> 00:54:30,750
and and so now what we will do is we

00:54:27,960 --> 00:54:32,640
have pick pop one of these strands from

00:54:30,750 --> 00:54:36,290
the list of pending strands let's say

00:54:32,640 --> 00:54:43,050
it's this one and make it sort of the

00:54:36,290 --> 00:54:45,450
like active strand right and we would

00:54:43,050 --> 00:54:47,130
then try to process it and in this case

00:54:45,450 --> 00:54:49,860
it's a very simple strand because

00:54:47,130 --> 00:54:52,740
there's no answers so what we would say

00:54:49,860 --> 00:54:55,140
is first thing we try to do is find some

00:54:52,740 --> 00:54:59,550
sub goal within the strand to focus on

00:54:55,140 --> 00:55:01,350
right now there are no sub goals at all

00:54:59,550 --> 00:55:03,030
so we

00:55:01,350 --> 00:55:06,000
you do that we call this function pursue

00:55:03,030 --> 00:55:07,740
answer which basically means I'm

00:55:06,000 --> 00:55:09,420
pursuing this strand to see if I release

00:55:07,740 --> 00:55:12,120
one answer and I indeed I found in the

00:55:09,420 --> 00:55:13,680
answer uh there's a lot of logic here

00:55:12,120 --> 00:55:15,060
but it's mostly around negative

00:55:13,680 --> 00:55:18,780
reasoning what's going to happen in this

00:55:15,060 --> 00:55:20,490
case is because there's nothing left to

00:55:18,780 --> 00:55:24,270
do we'll just call this an answer I said

00:55:20,490 --> 00:55:27,810
we would add then a equals u 32 to our

00:55:24,270 --> 00:55:30,180
list of answers and we're done and we

00:55:27,810 --> 00:55:35,700
would return back saying there's answer

00:55:30,180 --> 00:55:38,190
zero you asked for it um now if they

00:55:35,700 --> 00:55:40,650
came and asked for answer one it would

00:55:38,190 --> 00:55:49,080
pop off the next strand and process that

00:55:40,650 --> 00:55:52,920
which would get us a equals F 32 and now

00:55:49,080 --> 00:55:53,880
if they ask for answer to this is where

00:55:52,920 --> 00:55:56,700
things get a little more interesting

00:55:53,880 --> 00:55:59,280
because when we top this strand it

00:55:56,700 --> 00:56:04,740
actually has sub goals so we would

00:55:59,280 --> 00:56:08,160
select this sub goal to work on and I'm

00:56:04,740 --> 00:56:13,080
gonna denote that we'll see so we would

00:56:08,160 --> 00:56:15,450
make this the the active strand like so

00:56:13,080 --> 00:56:16,770
you would sort of mark this one is the

00:56:15,450 --> 00:56:20,660
active sub goal and what that means is

00:56:16,770 --> 00:56:24,030
we're gonna go we're gonna remember our

00:56:20,660 --> 00:56:26,850
answer index which starts out as 0 and

00:56:24,030 --> 00:56:30,060
we're gonna go ask the table for this

00:56:26,850 --> 00:56:31,980
sub goal if it has an answer 0 which in

00:56:30,060 --> 00:56:34,650
this case is the same table we started

00:56:31,980 --> 00:56:37,760
with so we have a cycle now where we're

00:56:34,650 --> 00:56:40,800
asking ourselves what is the answer 0 um

00:56:37,760 --> 00:56:42,810
but it turns out you have an answer for

00:56:40,800 --> 00:56:44,370
that like you don't actually because

00:56:42,810 --> 00:56:46,230
there's a cached answer there is no

00:56:44,370 --> 00:56:48,300
cycle we don't to worry about the cycle

00:56:46,230 --> 00:56:53,640
we can supply the answer so we'll get

00:56:48,300 --> 00:56:57,360
back the answer a equals u 32 and we

00:56:53,640 --> 00:57:00,530
will then apply that to our strand and

00:56:57,360 --> 00:57:03,150
make a new strand this is the key point

00:57:00,530 --> 00:57:06,500
make a new strand of work I'll put it

00:57:03,150 --> 00:57:06,500
here which is like

00:57:07,720 --> 00:57:14,589
the data and then we have still our old

00:57:11,109 --> 00:57:18,369
strand which we can kind of put back for

00:57:14,589 --> 00:57:21,310
later because it may yet have more

00:57:18,369 --> 00:57:23,410
answers to give us so we can put it back

00:57:21,310 --> 00:57:27,310
and that's our occurred our current

00:57:23,410 --> 00:57:28,750
state now in some sense we've had we we

00:57:27,310 --> 00:57:30,819
pursued this strand and what it did was

00:57:28,750 --> 00:57:33,180
it gave rise to another chain of

00:57:30,819 --> 00:57:35,740
reasoning by using a previous answer um

00:57:33,180 --> 00:57:37,690
and if we keep doing this well like if

00:57:35,740 --> 00:57:39,670
we pursue this one will get option of

00:57:37,690 --> 00:57:42,730
you 32 and so on and we'll just keep

00:57:39,670 --> 00:57:43,780
finding more answers as people ask and

00:57:42,730 --> 00:57:48,099
this will keep growing

00:57:43,780 --> 00:57:49,510
oh I realized I was running short of

00:57:48,099 --> 00:57:51,510
time so I kind of ran through this last

00:57:49,510 --> 00:57:55,359
part really fast

00:57:51,510 --> 00:58:01,270
but did that make sense so far any

00:57:55,359 --> 00:58:03,160
questions on that last part because if

00:58:01,270 --> 00:58:06,010
not I think what we'll probably do is

00:58:03,160 --> 00:58:09,280
stop here and I'll come back and revisit

00:58:06,010 --> 00:58:24,700
this last part in more detail the next

00:58:09,280 --> 00:58:26,380
time we do Wednesday which mean up like

00:58:24,700 --> 00:58:28,680
the Wednesday's Wednesday's Boston

00:58:26,380 --> 00:58:31,690
burrito Oh the Boston rest meetup you

00:58:28,680 --> 00:58:34,540
possibly yeah I just want to ask you

00:58:31,690 --> 00:58:39,369
some questions about it oh we could

00:58:34,540 --> 00:58:47,829
definitely talk sort of I'm not sure if

00:58:39,369 --> 00:58:54,180
I want to present them it without all

00:58:47,829 --> 00:58:54,180
right thanks Nico all right everybody

00:58:54,480 --> 00:58:57,990

YouTube URL: https://www.youtube.com/watch?v=Ny2928cGDoM


