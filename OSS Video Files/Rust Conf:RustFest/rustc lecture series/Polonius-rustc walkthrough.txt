Title: Polonius-rustc walkthrough
Publication date: 2019-04-25
Playlist: rustc lecture series
Description: 
	A walk through the rustc and Polonius code bases, showing how the two are connected. 

Paper doc is viewable here: https://paper.dropbox.com/doc/Polonius-Walkthrough-2--AZVdfdGwg3j9xs693~KyChtnAg-Wr90dk3V5DQQem9duos4P
Captions: 
	00:00:00,680 --> 00:00:05,940
okay welcome to this polonius

00:00:02,939 --> 00:00:08,189
walkthrough recording has started so

00:00:05,940 --> 00:00:15,690
let's see I'm going to share this

00:00:08,189 --> 00:00:17,220
document I guess let me just move this

00:00:15,690 --> 00:00:25,230
to a fresh window so you don't have a

00:00:17,220 --> 00:00:31,349
bunch of junk and share okay hopefully

00:00:25,230 --> 00:00:36,020
y'all can see that and I'll try let's

00:00:31,349 --> 00:00:36,020
see I'm gonna see if I can do it through

00:00:37,850 --> 00:00:44,640
like github links more than you know

00:00:42,719 --> 00:00:45,000
jumping into any Mac's buffer we'll see

00:00:44,640 --> 00:00:52,920
how it goes

00:00:45,000 --> 00:00:55,800
um so right so looking at the agenda how

00:00:52,920 --> 00:00:59,390
data is collected and packaged up in

00:00:55,800 --> 00:01:08,549
rusty so before that let me go to

00:00:59,390 --> 00:01:13,619
Polonius probably so so here's Polonius

00:01:08,549 --> 00:01:19,770
and if we look at this we will find you

00:01:13,619 --> 00:01:21,720
know there's there's Polonius and

00:01:19,770 --> 00:01:23,909
Polonius engine Polonius is like the

00:01:21,720 --> 00:01:26,580
data the testing harness it's not

00:01:23,909 --> 00:01:31,850
actually used by rusty blow Gnaeus

00:01:26,580 --> 00:01:36,000
engine is and within it there's this fax

00:01:31,850 --> 00:01:37,140
file and this is one of the interface to

00:01:36,000 --> 00:01:41,700
rusty alright

00:01:37,140 --> 00:01:45,680
and so it's totally generic over what

00:01:41,700 --> 00:01:49,590
exactly represents a region alone or a

00:01:45,680 --> 00:01:51,390
point in the control flow graph these

00:01:49,590 --> 00:01:53,939
are always some new type integer

00:01:51,390 --> 00:01:56,130
basically but the the actual new types

00:01:53,939 --> 00:01:58,469
are not in this great there's no it's

00:01:56,130 --> 00:02:02,100
generic might be declared in rusty and

00:01:58,469 --> 00:02:07,170
so on and you have here this basically

00:02:02,100 --> 00:02:10,920
one vector for each of the inputs to the

00:02:07,170 --> 00:02:13,830
analysis so the one that we are gonna

00:02:10,920 --> 00:02:14,010
look at most closely today I guess or

00:02:13,830 --> 00:02:15,090
the

00:02:14,010 --> 00:02:18,510
one that we're looking to let's say

00:02:15,090 --> 00:02:21,060
replace is this region why that and the

00:02:18,510 --> 00:02:23,879
reason is that most of these like the

00:02:21,060 --> 00:02:25,920
control flow graph edge for example is

00:02:23,879 --> 00:02:28,200
something you can directly get out of

00:02:25,920 --> 00:02:29,549
the mirror control flow graph you just

00:02:28,200 --> 00:02:31,349
kind of walk through the control flow

00:02:29,549 --> 00:02:32,640
graph structure and anytime a node is

00:02:31,349 --> 00:02:34,819
connected to another node you put a

00:02:32,640 --> 00:02:36,810
thing in the vector there's really no

00:02:34,819 --> 00:02:38,489
interpretation there it's just a

00:02:36,810 --> 00:02:41,700
different representation of the data

00:02:38,489 --> 00:02:44,670
structure and to a certain extent that's

00:02:41,700 --> 00:02:46,829
true for for all of these a little bit

00:02:44,670 --> 00:02:47,940
less so for something like killed which

00:02:46,829 --> 00:02:50,609
I don't think we've even talked about

00:02:47,940 --> 00:02:52,470
but that basically says there's an

00:02:50,609 --> 00:02:55,620
assignment at this location like x

00:02:52,470 --> 00:02:58,260
equals foo and there's a borrow of some

00:02:55,620 --> 00:03:01,590
sub path of X like X dot bar and

00:02:58,260 --> 00:03:04,170
therefore you put it in the vector but

00:03:01,590 --> 00:03:07,170
it's still fairly easy to understand a

00:03:04,170 --> 00:03:09,150
lot of interpretation involved liveness

00:03:07,170 --> 00:03:10,980
is different in liveness what's

00:03:09,150 --> 00:03:12,450
happening is the compilers we're going

00:03:10,980 --> 00:03:14,129
to see is going to do a live miss

00:03:12,450 --> 00:03:16,019
computation of figuring out what's live

00:03:14,129 --> 00:03:17,430
at each point and then encode the

00:03:16,019 --> 00:03:19,560
results of that computation which is

00:03:17,430 --> 00:03:21,750
itself a fixed point computation into

00:03:19,560 --> 00:03:23,370
this vector and that's kind of silly it

00:03:21,750 --> 00:03:25,530
would be better to do we'd like to move

00:03:23,370 --> 00:03:26,760
these like I guess that's the real

00:03:25,530 --> 00:03:30,150
distinction anything that requires

00:03:26,760 --> 00:03:32,269
iteration ideally we would move into

00:03:30,150 --> 00:03:32,269
this

00:03:33,239 --> 00:03:42,810
today a frog or into Polonius okay

00:03:39,180 --> 00:03:46,410
so that's our goal the so where does

00:03:42,810 --> 00:03:50,099
this all fax get populated or where does

00:03:46,410 --> 00:03:52,769
the kind of compiler communicate with

00:03:50,099 --> 00:03:58,230
Polonius that's a good question let's

00:03:52,769 --> 00:04:01,079
see if I can find it so not here hold on

00:03:58,230 --> 00:04:11,729
a second actually I should pull up a few

00:04:01,079 --> 00:04:19,829
links I have to turn on my VPN or

00:04:11,729 --> 00:04:22,430
something sorry one sec do housekeeping

00:04:19,829 --> 00:04:22,430
work

00:04:24,040 --> 00:04:30,530
there we go okay sorry

00:04:29,360 --> 00:04:32,449
you can't see what I'm doing right now

00:04:30,530 --> 00:04:33,800
but I'm trying to connect real fast so

00:04:32,449 --> 00:04:37,850
that I can at least do some greps

00:04:33,800 --> 00:04:41,150
through the source code and and answer

00:04:37,850 --> 00:04:46,610
some of these questions better um there

00:04:41,150 --> 00:05:05,389
we go so let me get you that real fast

00:04:46,610 --> 00:05:07,639
okay okay yeah so okay so one place we

00:05:05,389 --> 00:05:10,880
might look at in the bar checker there's

00:05:07,639 --> 00:05:12,070
this this is this module called fracks

00:05:10,880 --> 00:05:14,900
[Music]

00:05:12,070 --> 00:05:18,410
and you can see here that it grabs from

00:05:14,900 --> 00:05:20,660
polonius Engine the all facts structure

00:05:18,410 --> 00:05:23,539
which it renamed stopped the polonius

00:05:20,660 --> 00:05:26,389
all effects and and then we defined we

00:05:23,539 --> 00:05:30,260
here we export a sort of version of this

00:05:26,389 --> 00:05:31,639
that uses the compilers new types all

00:05:30,260 --> 00:05:33,470
right so we're Polonius talks about a

00:05:31,639 --> 00:05:34,760
region in the compiler that's

00:05:33,470 --> 00:05:36,650
represented by this data structure

00:05:34,760 --> 00:05:39,919
called region vid where vid stands for

00:05:36,650 --> 00:05:42,919
variable ID and Baro index is what we

00:05:39,919 --> 00:05:44,120
call a lone location index is a point in

00:05:42,919 --> 00:05:45,590
the control flow graph so you can see

00:05:44,120 --> 00:05:47,090
that there are they're just integers but

00:05:45,590 --> 00:05:50,169
they have their own little local names

00:05:47,090 --> 00:05:54,080
so this is our like local instantiation

00:05:50,169 --> 00:05:55,789
and then this this trait this is like an

00:05:54,080 --> 00:05:59,780
extension trait to add some methods to

00:05:55,789 --> 00:06:02,680
it so you can ask if it's enabled and

00:05:59,780 --> 00:06:08,599
the right to derp all that does is on

00:06:02,680 --> 00:06:10,190
this really dump these into files that

00:06:08,599 --> 00:06:11,960
are in the format that Polonius can

00:06:10,190 --> 00:06:13,669
import and the point of that is that

00:06:11,960 --> 00:06:15,470
rusty can run with an option to dump

00:06:13,669 --> 00:06:17,090
these files so that you can then run

00:06:15,470 --> 00:06:19,070
Polonius in a standalone way without the

00:06:17,090 --> 00:06:21,500
rest of rusty and just reproduce the

00:06:19,070 --> 00:06:25,310
actual analysis so that's where the

00:06:21,500 --> 00:06:35,180
facts are like that's one part of it at

00:06:25,310 --> 00:06:37,570
least um let's see the next part is it's

00:06:35,180 --> 00:06:37,570
going to

00:06:46,139 --> 00:06:53,729
oh I was in the right place

00:06:50,819 --> 00:06:55,379
oh I'm just searching I don't know

00:06:53,729 --> 00:07:00,210
what's going on let's try this

00:06:55,379 --> 00:07:03,870
I think I'm hitting the wrong Keys okay

00:07:00,210 --> 00:07:08,789
right so so this function compute

00:07:03,870 --> 00:07:10,469
regions this is a big part of the barrio

00:07:08,789 --> 00:07:13,770
checker and non lexical items broad

00:07:10,469 --> 00:07:18,899
trackers and one of the things it does

00:07:13,770 --> 00:07:21,990
is - if Polonius is enabled is it

00:07:18,899 --> 00:07:25,169
creates the facts for Polonius and so

00:07:21,990 --> 00:07:26,999
here it will say if I'm enabled which

00:07:25,169 --> 00:07:29,339
means that you passed the correct flag

00:07:26,999 --> 00:07:31,289
to the command line then I create an

00:07:29,339 --> 00:07:34,949
instance of the effects which is empty

00:07:31,289 --> 00:07:36,569
and store it in this variable and then

00:07:34,949 --> 00:07:38,189
we run and you can see we give this

00:07:36,569 --> 00:07:40,919
variable for example to the type checker

00:07:38,189 --> 00:07:43,139
and that will the type checker will emit

00:07:40,919 --> 00:07:45,680
facts like that one lifetime has to

00:07:43,139 --> 00:07:48,810
outlive another or very 1/1 regions ever

00:07:45,680 --> 00:07:51,389
so it generates some subset of facts and

00:07:48,810 --> 00:07:53,490
then you know here we're adding some

00:07:51,389 --> 00:07:55,409
more facts into that into that variable

00:07:53,490 --> 00:07:57,680
saying okay let's extend that with the

00:07:55,409 --> 00:08:01,979
set of universal regions or free regions

00:07:57,680 --> 00:08:04,620
and so forth and and again here this

00:08:01,979 --> 00:08:06,569
constraint generation so where all these

00:08:04,620 --> 00:08:08,610
things are basically populating the

00:08:06,569 --> 00:08:11,550
facts table right and the generate

00:08:08,610 --> 00:08:13,169
invalidates this is saying invalidates

00:08:11,550 --> 00:08:15,740
this how Polonia says well this action

00:08:13,169 --> 00:08:17,969
would be incompatible with that loan um

00:08:15,740 --> 00:08:20,639
at this point we're done and you can

00:08:17,969 --> 00:08:22,709
kind of see that by the fact that we're

00:08:20,639 --> 00:08:24,719
gonna write out if they've asked us to

00:08:22,709 --> 00:08:29,129
write these things to files the user

00:08:24,719 --> 00:08:31,169
then we will do so and the other thing

00:08:29,129 --> 00:08:33,539
we'll do here is where we write to the

00:08:31,169 --> 00:08:35,639
files if we do our ask to the other

00:08:33,539 --> 00:08:37,680
thing we'll do is if we're asked to use

00:08:35,639 --> 00:08:40,199
balunia s-- in order to create our

00:08:37,680 --> 00:08:44,899
errors then we actually invoke polonius

00:08:40,199 --> 00:08:49,000
here right and this output is comes from

00:08:44,899 --> 00:08:51,670
the somewhere here

00:08:49,000 --> 00:08:55,779
comes from the polonius engine so this

00:08:51,670 --> 00:08:58,000
is actually the sort of main way that

00:08:55,779 --> 00:09:00,819
Polonius executes and you can see we

00:08:58,000 --> 00:09:03,220
picked the algorithm we get it from a

00:09:00,819 --> 00:09:05,259
string but we tell Polonius to figure

00:09:03,220 --> 00:09:07,540
out the algorithm and compute the result

00:09:05,259 --> 00:09:13,800
and that goes into this variable

00:09:07,540 --> 00:09:16,449
Polonius output so it will have the

00:09:13,800 --> 00:09:18,129
either none or it'll have the results

00:09:16,449 --> 00:09:19,449
that Polonius gives back let me put them

00:09:18,129 --> 00:09:22,449
in a ref counted things so that we don't

00:09:19,449 --> 00:09:23,769
have to so we can clone it because

00:09:22,449 --> 00:09:27,160
they're immutable once they get created

00:09:23,769 --> 00:09:30,069
and then Polonius output happens at that

00:09:27,160 --> 00:09:31,810
that gets returned and it's not really

00:09:30,069 --> 00:09:35,680
that important for the point so I'm not

00:09:31,810 --> 00:09:38,050
going to go into it but uh but that

00:09:35,680 --> 00:09:40,149
Polonius output what it contains I guess

00:09:38,050 --> 00:09:42,779
I won't go into it at this level if we

00:09:40,149 --> 00:09:49,779
jump back to the Polonius engine now

00:09:42,779 --> 00:09:52,959
it's wrong please the Polonius output is

00:09:49,779 --> 00:09:55,180
this data structure and the only thing

00:09:52,959 --> 00:09:56,319
in here that's that these these maps are

00:09:55,180 --> 00:09:58,660
all going to be empty these are only

00:09:56,319 --> 00:10:00,250
used as it says for debugging but it

00:09:58,660 --> 00:10:00,759
will contain a list of errors at each

00:10:00,250 --> 00:10:02,350
point

00:10:00,759 --> 00:10:04,809
it's basically at this point there was

00:10:02,350 --> 00:10:07,300
an error because this loan and so the

00:10:04,809 --> 00:10:10,600
actual later on the error reporting code

00:10:07,300 --> 00:10:13,180
is gonna if that's is that if that's not

00:10:10,600 --> 00:10:14,470
if we're in the some case it's going to

00:10:13,180 --> 00:10:18,250
walk through those errors and use it to

00:10:14,470 --> 00:10:23,559
report there's um okay so that that's

00:10:18,250 --> 00:10:26,009
kind of a quick walk through of of how

00:10:23,559 --> 00:10:31,329
data is collected and packaged up and

00:10:26,009 --> 00:10:33,730
how it gets fed to Polonius I guess the

00:10:31,329 --> 00:10:36,579
thing I didn't cover is the liveness in

00:10:33,730 --> 00:10:38,019
much detail and part of that's because I

00:10:36,579 --> 00:10:39,879
don't exactly remember but let's take a

00:10:38,019 --> 00:10:41,379
look where that actually gets computed I

00:10:39,879 --> 00:10:44,740
think it's probably in constraint

00:10:41,379 --> 00:10:53,550
generation so the way that liveness

00:10:44,740 --> 00:10:53,550
works today let's see is this true

00:10:54,540 --> 00:10:59,079
somewhere I don't recall where we have a

00:10:57,490 --> 00:11:01,380
liveness computation that I'd have to

00:10:59,079 --> 00:11:01,380
find

00:11:01,790 --> 00:11:22,440
see region live yes it's not here let me

00:11:07,170 --> 00:11:30,420
take a look okay

00:11:22,440 --> 00:11:31,829
oh I see yeah so in the borough check-in

00:11:30,420 --> 00:11:32,600
the type Jack there's the directory

00:11:31,829 --> 00:11:36,420
called liveness

00:11:32,600 --> 00:11:37,740
and in this liveness code we actually

00:11:36,420 --> 00:11:39,540
this is this is the current aliveness

00:11:37,740 --> 00:11:42,120
computation and it's a little bit

00:11:39,540 --> 00:11:44,279
complicated it's a little bit more than

00:11:42,120 --> 00:11:45,779
just liveness in the traditional

00:11:44,279 --> 00:11:47,399
compiler sense of normally that would

00:11:45,779 --> 00:11:49,440
just be like is this variable used later

00:11:47,399 --> 00:11:51,510
and we do that but we distinguish a few

00:11:49,440 --> 00:11:53,399
different kinds of uses in particular it

00:11:51,510 --> 00:11:55,110
drops the implicit drop that occurs when

00:11:53,399 --> 00:11:57,120
a variable goes out of scope is a little

00:11:55,110 --> 00:11:59,579
bit different from an actual use where

00:11:57,120 --> 00:12:01,920
you wrote it manually because sometimes

00:11:59,579 --> 00:12:03,420
we can tell that drop won't access some

00:12:01,920 --> 00:12:06,079
of the data and so we don't have to

00:12:03,420 --> 00:12:10,310
consider it to be used by the drop um

00:12:06,079 --> 00:12:12,870
which can even lets us be more flexible

00:12:10,310 --> 00:12:15,089
but we do this computation and we append

00:12:12,870 --> 00:12:19,769
it in and so what we're gonna what our

00:12:15,089 --> 00:12:21,420
initial goal I think would be not to

00:12:19,769 --> 00:12:23,519
change anything here but just to add to

00:12:21,420 --> 00:12:28,410
it that we're gonna add a new set of

00:12:23,519 --> 00:12:31,190
facts which is probably two things or

00:12:28,410 --> 00:12:34,110
it's certainly where is each variable

00:12:31,190 --> 00:12:35,490
defined and where is it used all right

00:12:34,110 --> 00:12:37,769
and I mentioned that there's two kinds

00:12:35,490 --> 00:12:40,130
of uses so let's see let's scroll down a

00:12:37,769 --> 00:12:40,130
little bit

00:12:40,699 --> 00:12:51,480
how does this go to work anyway

00:12:43,050 --> 00:12:53,490
I remember writing it not well I don't

00:12:51,480 --> 00:12:57,380
know we'll come back to it but compute

00:12:53,490 --> 00:12:57,380
live it must be this computation here I

00:12:58,399 --> 00:13:04,230
don't know like there's a different

00:13:00,149 --> 00:13:05,459
thing well somewhere in here who can do

00:13:04,230 --> 00:13:07,470
this computation and we would do this

00:13:05,459 --> 00:13:09,510
you would find a set of uses from each

00:13:07,470 --> 00:13:14,579
point and basically we'll wind up with a

00:13:09,510 --> 00:13:15,270
in addition to the vector we're gonna

00:13:14,579 --> 00:13:21,530
wind up with

00:13:15,270 --> 00:13:23,280
adding to all facts something like

00:13:21,530 --> 00:13:26,400
variable first of all we're actually

00:13:23,280 --> 00:13:30,270
going to have to add a new parameter for

00:13:26,400 --> 00:13:33,660
variables let's call it V so where we

00:13:30,270 --> 00:13:40,380
now have on the art regions loans and

00:13:33,660 --> 00:13:41,850
points will be something like it's

00:13:40,380 --> 00:13:44,010
called it variables and then there are

00:13:41,850 --> 00:13:48,120
the variable definitions probably that's

00:13:44,010 --> 00:13:49,980
it's like a vector of V and P so a

00:13:48,120 --> 00:13:52,530
variable definition occurs at some point

00:13:49,980 --> 00:13:57,420
and they'll be like variable regular use

00:13:52,530 --> 00:14:02,240
is which is also a vector of V and P and

00:13:57,420 --> 00:14:02,240
we just mean variable is regular used

00:14:02,450 --> 00:14:10,710
point and things like that

00:14:06,230 --> 00:14:17,730
and we could have a variable drop uses

00:14:10,710 --> 00:14:19,230
to mean if the variable is drop used at

00:14:17,730 --> 00:14:20,640
some point and drop yours means that

00:14:19,230 --> 00:14:24,210
it's that implicit drop I mentioned

00:14:20,640 --> 00:14:25,620
probably just start with this um once we

00:14:24,210 --> 00:14:44,280
get the basic set up it'll be easy to

00:14:25,620 --> 00:14:47,280
add the rest so good let's jump so now

00:14:44,280 --> 00:14:48,570
we kind of covered these two points and

00:14:47,280 --> 00:14:52,140
I guess we covered a little more like

00:14:48,570 --> 00:14:57,420
what we would want to add to that for

00:14:52,140 --> 00:14:59,750
liveness so what about this mapping so

00:14:57,420 --> 00:15:02,820
if we were going to do liveness

00:14:59,750 --> 00:15:06,290
computation there's going to be some

00:15:02,820 --> 00:15:10,530
rules that are gonna say something like

00:15:06,290 --> 00:15:12,570
the variable is lie let's say we we have

00:15:10,530 --> 00:15:13,530
these variable regular uses variable job

00:15:12,570 --> 00:15:20,640
uses and so on

00:15:13,530 --> 00:15:24,240
and you might say anytime that a

00:15:20,640 --> 00:15:28,410
variable is regular used at a given

00:15:24,240 --> 00:15:29,250
point then the variable is regular life

00:15:28,410 --> 00:15:30,810
so

00:15:29,250 --> 00:15:33,000
that means like on entry to that point

00:15:30,810 --> 00:15:35,520
the value in that variable is going to

00:15:33,000 --> 00:15:43,260
get used and then you might have

00:15:35,520 --> 00:15:53,760
something like if there's an edge from P

00:15:43,260 --> 00:15:55,710
to Q and the variable is live at Q then

00:15:53,760 --> 00:16:03,780
the variable o and probably we want and

00:15:55,710 --> 00:16:06,030
it's not find that P then it's going to

00:16:03,780 --> 00:16:07,350
be live at P also right so we walk

00:16:06,030 --> 00:16:10,320
backwards to the control program so

00:16:07,350 --> 00:16:11,610
that's like our basic rule and now what

00:16:10,320 --> 00:16:13,350
I want to show you now because you've

00:16:11,610 --> 00:16:16,050
seen a lot of rules like this is how do

00:16:13,350 --> 00:16:19,530
you map these sorts of rules into data

00:16:16,050 --> 00:16:21,450
fraud it's not entirely obvious um so we

00:16:19,530 --> 00:16:24,210
won't map that actual rule because we

00:16:21,450 --> 00:16:27,150
don't have that rule yet but we'll map a

00:16:24,210 --> 00:16:30,300
different rule and will use go if we go

00:16:27,150 --> 00:16:33,540
to the naive computation let's find a

00:16:30,300 --> 00:16:35,490
subset is pretty similar so if you

00:16:33,540 --> 00:16:38,000
recall there were rules in the naive

00:16:35,490 --> 00:16:42,300
computation make this a little bigger

00:16:38,000 --> 00:16:44,730
like this one well let's start with a

00:16:42,300 --> 00:16:49,589
simple one this is a transitive rule

00:16:44,730 --> 00:16:52,470
this says if at some point P R 1 is a

00:16:49,589 --> 00:16:57,089
subset of R 2 and R 2 is a subset of R 3

00:16:52,470 --> 00:16:59,640
then R 1 is a subset of R 3 um pretty

00:16:57,089 --> 00:17:06,060
simple and the way that that gets

00:16:59,640 --> 00:17:15,329
encoded I take this over to my our data

00:17:06,060 --> 00:17:19,650
frog works so this is the this is the

00:17:15,329 --> 00:17:22,079
rule we wanted to put in like the data

00:17:19,650 --> 00:17:24,510
log rule so what's going to happen in

00:17:22,079 --> 00:17:27,120
theta frogs model is that this variable

00:17:24,510 --> 00:17:30,240
subset or this relation I should say

00:17:27,120 --> 00:17:33,150
subset is mapped into a program variable

00:17:30,240 --> 00:17:40,250
like a rust variable which you see

00:17:33,150 --> 00:17:44,900
defined right here so what

00:17:40,250 --> 00:17:46,250
what this so oh I see we have this

00:17:44,900 --> 00:17:48,860
iteration so first of all there's gonna

00:17:46,250 --> 00:17:50,210
be the first thing in data fog you

00:17:48,860 --> 00:17:51,740
always have is some kind of iteration

00:17:50,210 --> 00:17:54,620
and what that basically means is this is

00:17:51,740 --> 00:17:56,990
a computation and an iteration can have

00:17:54,620 --> 00:17:58,640
associated with it the various variables

00:17:56,990 --> 00:18:02,150
which represent the relations your

00:17:58,640 --> 00:18:03,799
computing and so when you write

00:18:02,150 --> 00:18:07,130
iteration that variable you give it some

00:18:03,799 --> 00:18:09,200
some types region this correspond to you

00:18:07,130 --> 00:18:11,360
know region and region point region

00:18:09,200 --> 00:18:13,250
region point so it's a tuple basically

00:18:11,360 --> 00:18:16,750
this tuple is what the variable consists

00:18:13,250 --> 00:18:19,010
of a set of those tuples and then

00:18:16,750 --> 00:18:20,539
there's the reason that thing is called

00:18:19,010 --> 00:18:23,150
iteration is because there's actually a

00:18:20,539 --> 00:18:24,440
bit of russ code here you know we're

00:18:23,150 --> 00:18:26,330
doing a fixed point iteration which

00:18:24,440 --> 00:18:28,940
means we're continually working adding

00:18:26,330 --> 00:18:30,620
things until we get no more changes so

00:18:28,940 --> 00:18:32,780
the way that happens in rust like data

00:18:30,620 --> 00:18:35,059
frog itself is just some libraries that

00:18:32,780 --> 00:18:38,270
you can invoke and the actual iteration

00:18:35,059 --> 00:18:43,700
is here so we keep going while it's

00:18:38,270 --> 00:18:46,669
changed and then we do this call and

00:18:43,700 --> 00:18:48,919
this corresponds to this rule right and

00:18:46,669 --> 00:18:53,840
what this from join does is it says add

00:18:48,919 --> 00:18:59,360
in to so the current value of subset add

00:18:53,840 --> 00:19:02,360
any new tuples that you get by joining

00:18:59,360 --> 00:19:04,370
in the database sense these two other

00:19:02,360 --> 00:19:07,429
variables will come to those variables

00:19:04,370 --> 00:19:08,809
in a second so joining meaning take the

00:19:07,429 --> 00:19:12,020
set of tuples from one and the set from

00:19:08,809 --> 00:19:13,520
the other and see where they have

00:19:12,020 --> 00:19:16,429
overlap so in this case these are

00:19:13,520 --> 00:19:19,760
expected to always be two tuples where

00:19:16,429 --> 00:19:21,350
there's like a key and a value one and a

00:19:19,760 --> 00:19:23,510
key and a value two that's the type

00:19:21,350 --> 00:19:25,010
these types have to be mapped to that

00:19:23,510 --> 00:19:26,809
and so these keys wherever the keys

00:19:25,010 --> 00:19:30,140
match up you get it you get a callback

00:19:26,809 --> 00:19:32,450
so what you have here is this is the key

00:19:30,140 --> 00:19:36,799
and this is the first value and this is

00:19:32,450 --> 00:19:41,030
the second value so so what is this r2p

00:19:36,799 --> 00:19:43,970
and r1p going on well these are also

00:19:41,030 --> 00:19:45,860
variables they're like temporary

00:19:43,970 --> 00:19:47,539
variables basically they're not the real

00:19:45,860 --> 00:19:48,830
they don't even appear in the data log

00:19:47,539 --> 00:19:52,730
but they're like intermediate variables

00:19:48,830 --> 00:19:53,520
that you would use and the way they're

00:19:52,730 --> 00:19:56,340
defined

00:19:53,520 --> 00:19:58,350
just exactly the same as subsets except

00:19:56,340 --> 00:20:00,690
to be organized there like a ver like a

00:19:58,350 --> 00:20:03,720
database index which that means just

00:20:00,690 --> 00:20:07,830
reorganized to identify what the key is

00:20:03,720 --> 00:20:09,179
right so we this from map says add into

00:20:07,830 --> 00:20:13,340
subset r1p

00:20:09,179 --> 00:20:17,340
all the tuples that that are in subset

00:20:13,340 --> 00:20:19,530
but apply this closure first so we're

00:20:17,340 --> 00:20:22,170
taking the subset tuple which is the

00:20:19,530 --> 00:20:23,790
three things all equal and we're

00:20:22,170 --> 00:20:26,580
reorganizing them so that we have the

00:20:23,790 --> 00:20:28,770
key we want which is basically we look

00:20:26,580 --> 00:20:33,450
here we see oh this thing what this have

00:20:28,770 --> 00:20:39,960
in common is that they're there at a

00:20:33,450 --> 00:20:43,860
specific point and r2 appears in both of

00:20:39,960 --> 00:20:46,710
them right so we want to join where the

00:20:43,860 --> 00:20:48,900
second part of this tuple is equal to

00:20:46,710 --> 00:20:50,670
the first part of this tuple and the

00:20:48,900 --> 00:20:52,500
third parts of the tuple are equal so

00:20:50,670 --> 00:20:53,940
first we extract out the first part and

00:20:52,500 --> 00:20:56,370
we make a map that has the first part

00:20:53,940 --> 00:20:58,470
and the point the first region and the

00:20:56,370 --> 00:21:00,690
point and then we have another one or a

00:20:58,470 --> 00:21:03,870
to P which is basically the same except

00:21:00,690 --> 00:21:06,450
it's gonna pull out the second part and

00:21:03,870 --> 00:21:09,620
then we join those together and now so

00:21:06,450 --> 00:21:12,750
what we essentially have here is the r2p

00:21:09,620 --> 00:21:16,080
and the r1p and now you can start to see

00:21:12,750 --> 00:21:19,080
where the naming convention comes from

00:21:16,080 --> 00:21:21,660
this underscore like r2p is telling you

00:21:19,080 --> 00:21:23,730
okay this is the key this is the same as

00:21:21,660 --> 00:21:26,940
subset but with this key and this is the

00:21:23,730 --> 00:21:29,070
same as subset that key and so when we

00:21:26,940 --> 00:21:31,140
get the call back here that where these

00:21:29,070 --> 00:21:33,630
names come from this are that kind of

00:21:31,140 --> 00:21:37,020
comes from this this data log code the

00:21:33,630 --> 00:21:40,110
r1 is the second half of this tuple

00:21:37,020 --> 00:21:41,990
which in our data log code is r1 and the

00:21:40,110 --> 00:21:45,390
r3 is the second half of this tuple

00:21:41,990 --> 00:21:48,570
which would be that r3 and then this is

00:21:45,390 --> 00:21:49,850
the final result r1 r3 RP so you can

00:21:48,570 --> 00:21:53,970
kind of make this in a fairly mechanical

00:21:49,850 --> 00:21:56,100
it's like hard it's not trivial but it's

00:21:53,970 --> 00:21:58,140
mechanical to convert the data log rules

00:21:56,100 --> 00:22:00,540
into this data fraudulence that's the

00:21:58,140 --> 00:22:03,929
basic structure um there is some more

00:22:00,540 --> 00:22:06,570
fancy stuff you can do in particular

00:22:03,929 --> 00:22:07,520
there's from leap join which is more

00:22:06,570 --> 00:22:13,220
efficient

00:22:07,520 --> 00:22:15,240
and kind of nifty but also kind of wacky

00:22:13,220 --> 00:22:17,130
let's see if we can walk through how it

00:22:15,240 --> 00:22:20,820
works see if I can remember how it works

00:22:17,130 --> 00:22:22,500
so what this what this rule is trying to

00:22:20,820 --> 00:22:26,130
do this is somewhat similar to the rule

00:22:22,500 --> 00:22:28,740
that liveness will ultimately want what

00:22:26,130 --> 00:22:30,840
this rule is trying to that's the one

00:22:28,740 --> 00:22:33,660
thing I hate about not the one thing but

00:22:30,840 --> 00:22:42,660
it is one thing that I hate about flux

00:22:33,660 --> 00:22:45,200
paper when you paste in anyway so right

00:22:42,660 --> 00:22:47,940
so what is this saying it's saying if

00:22:45,200 --> 00:22:50,310
you have that r1 is less than or two at

00:22:47,940 --> 00:22:53,040
P and there's an edge from P to Q so

00:22:50,310 --> 00:22:55,160
it's going forward but there's an edge

00:22:53,040 --> 00:22:59,330
from P to Q and the region is live at Q

00:22:55,160 --> 00:23:02,250
then we have R 1 is less than R 2 a Q so

00:22:59,330 --> 00:23:06,840
we've got to kind of join together in

00:23:02,250 --> 00:23:09,690
some sense the we want to take all the

00:23:06,840 --> 00:23:11,730
existing subset tuples and take take out

00:23:09,690 --> 00:23:13,110
the point where they are join that with

00:23:11,730 --> 00:23:15,510
the control flow graph edge to get

00:23:13,110 --> 00:23:17,460
another point Q and we're going to join

00:23:15,510 --> 00:23:20,640
that with these region live at

00:23:17,460 --> 00:23:24,270
computations to see if the r1 and the r2

00:23:20,640 --> 00:23:25,680
all match up right and there's something

00:23:24,270 --> 00:23:29,160
interesting about this rule which is

00:23:25,680 --> 00:23:30,870
that first of all the only variable and

00:23:29,160 --> 00:23:33,120
the sense of thing that changes as we

00:23:30,870 --> 00:23:35,610
iterate so that's what a variable is in

00:23:33,120 --> 00:23:37,500
and data frog I didn't actually say that

00:23:35,610 --> 00:23:39,210
explicitly there's actually two concepts

00:23:37,500 --> 00:23:41,280
state variables and relations and

00:23:39,210 --> 00:23:42,480
relations are essentially your inputs

00:23:41,280 --> 00:23:43,800
from the point of view of any

00:23:42,480 --> 00:23:45,710
computation so they're not changing

00:23:43,800 --> 00:23:47,730
during the iteration they're fixed and

00:23:45,710 --> 00:23:49,910
the variables are the things that are

00:23:47,730 --> 00:23:52,590
actually growing at each round right and

00:23:49,910 --> 00:23:54,510
here we have this the only fall of these

00:23:52,590 --> 00:23:56,400
are relations these are all base inputs

00:23:54,510 --> 00:23:59,280
that don't grow with the exception of

00:23:56,400 --> 00:24:00,510
subsets and that's also the output so

00:23:59,280 --> 00:24:02,190
there's like a recursive thing going on

00:24:00,510 --> 00:24:05,670
and in that case we have a particular

00:24:02,190 --> 00:24:08,430
optimized method called from leap join

00:24:05,670 --> 00:24:12,350
that can be more efficient in the way

00:24:08,430 --> 00:24:12,350
that it's implemented that you can use

00:24:12,560 --> 00:24:17,670
and what it does so how it works is

00:24:16,350 --> 00:24:19,110
actually it doesn't matter that they're

00:24:17,670 --> 00:24:21,030
the same I don't think it just matters

00:24:19,110 --> 00:24:23,550
that there's one variable and

00:24:21,030 --> 00:24:26,100
and then some number of relations that

00:24:23,550 --> 00:24:28,110
it gets combined with and so there's the

00:24:26,100 --> 00:24:30,150
same basic structure you call from leap

00:24:28,110 --> 00:24:33,170
join and that adds things into subsets

00:24:30,150 --> 00:24:35,880
and then you give that one variable here

00:24:33,170 --> 00:24:39,090
that's the first parameter and then the

00:24:35,880 --> 00:24:41,880
rest of the parameters are a definition

00:24:39,090 --> 00:24:43,260
are derived from the relations so the

00:24:41,880 --> 00:24:46,160
things that aren't changing the inputs

00:24:43,260 --> 00:24:49,280
and they tell you how it should be like

00:24:46,160 --> 00:24:52,650
combined with the value of that variable

00:24:49,280 --> 00:24:57,930
so in this case the first one extend

00:24:52,650 --> 00:25:01,110
with what that says is first look at

00:24:57,930 --> 00:25:03,450
this tuple here r1 r2 P lets you see

00:25:01,110 --> 00:25:08,060
that in each case it's r1 r2 P we're

00:25:03,450 --> 00:25:11,640
gonna pull out just the p value and oh

00:25:08,060 --> 00:25:14,280
this config edge relation yeah this is

00:25:11,640 --> 00:25:16,140
just config edge like so so we're gonna

00:25:14,280 --> 00:25:18,270
take that whatever gets returned from

00:25:16,140 --> 00:25:20,340
here we're gonna match this has to be a

00:25:18,270 --> 00:25:26,910
2-tuple we're gonna match to the first

00:25:20,340 --> 00:25:29,790
part and then and then we're gonna take

00:25:26,910 --> 00:25:31,950
the we're going to match to the first

00:25:29,790 --> 00:25:36,630
part and we'll take that Q value and we

00:25:31,950 --> 00:25:39,470
will use it later on to make new tuples

00:25:36,630 --> 00:25:41,880
with right so that's what happens here

00:25:39,470 --> 00:25:44,210
so basically here we're finding we're

00:25:41,880 --> 00:25:46,920
basically doing this joint and then

00:25:44,210 --> 00:25:49,170
actually I'm a little surprised by this

00:25:46,920 --> 00:25:54,210
but that's okay and then what this is

00:25:49,170 --> 00:26:04,590
saying is well that's what the code says

00:25:54,210 --> 00:26:07,050
must be right so this is saying right

00:26:04,590 --> 00:26:11,100
kind of oh I see right because these Q's

00:26:07,050 --> 00:26:13,770
all have to be the same so kind of the

00:26:11,100 --> 00:26:16,560
same thing same kind of join except that

00:26:13,770 --> 00:26:18,780
in order to all of these extend which

00:26:16,560 --> 00:26:22,290
calls are going to produce a new Q value

00:26:18,780 --> 00:26:24,240
basically they're all proposing new what

00:26:22,290 --> 00:26:25,710
is a possible value for Q because all

00:26:24,240 --> 00:26:27,660
the rest of the variables came from the

00:26:25,710 --> 00:26:30,720
input so that's the only thing we're

00:26:27,660 --> 00:26:32,430
extracting and the way that they're

00:26:30,720 --> 00:26:34,500
doing it is by doing this joining right

00:26:32,430 --> 00:26:36,510
and so so the here

00:26:34,500 --> 00:26:37,860
we're saying okay pull out the r-1 match

00:26:36,510 --> 00:26:39,690
it on this thing which is already a

00:26:37,860 --> 00:26:41,190
2-tuple so that's okay and that'll

00:26:39,690 --> 00:26:43,530
propose a queue and this will propose a

00:26:41,190 --> 00:26:45,390
queue and then for all the things that

00:26:43,530 --> 00:26:47,220
they all proposed in common you'll get a

00:26:45,390 --> 00:26:49,770
callback where here was the input value

00:26:47,220 --> 00:26:51,600
that we passed to each prisoner and here

00:26:49,770 --> 00:26:53,430
was the queue they all agreed on and now

00:26:51,600 --> 00:26:56,130
you can return a new value something

00:26:53,430 --> 00:26:58,470
roughly like that and there's some other

00:26:56,130 --> 00:27:00,870
methods and options so extend with is

00:26:58,470 --> 00:27:03,240
the basic one that lets you say pull out

00:27:00,870 --> 00:27:04,740
some part of the variable use it to

00:27:03,240 --> 00:27:07,110
match against the relation and pull out

00:27:04,740 --> 00:27:09,870
some new thing that that you can use to

00:27:07,110 --> 00:27:13,560
make new values um then there's also

00:27:09,870 --> 00:27:15,330
like extend anti which lets you say if

00:27:13,560 --> 00:27:17,520
you pull out some parts of the variable

00:27:15,330 --> 00:27:20,070
and if you find any match then remove

00:27:17,520 --> 00:27:21,270
this like then kill it because it's not

00:27:20,070 --> 00:27:25,470
supposed to fit so that would be useful

00:27:21,270 --> 00:27:29,130
for something like not variable to find

00:27:25,470 --> 00:27:31,440
right and there's some other things

00:27:29,130 --> 00:27:33,470
filter filter width and filter anti

00:27:31,440 --> 00:27:35,880
which is kind of the same thing except

00:27:33,470 --> 00:27:38,120
here you're always joining the first

00:27:35,880 --> 00:27:41,460
half and the second half you're either

00:27:38,120 --> 00:27:43,050
you're either proposing or killing right

00:27:41,460 --> 00:27:44,940
so if you say extend anti then it would

00:27:43,050 --> 00:27:47,160
say anytime that you have a match and it

00:27:44,940 --> 00:27:50,280
has a Q that Q is not part of the output

00:27:47,160 --> 00:27:54,060
and filter within filter anti take these

00:27:50,280 --> 00:27:55,710
entire tuples here or these tuples or I

00:27:54,060 --> 00:27:58,230
forget exactly but they don't propose

00:27:55,710 --> 00:27:59,520
new they don't don't have that key value

00:27:58,230 --> 00:28:01,020
of thing it's more like you're just

00:27:59,520 --> 00:28:02,760
checking is this tuple part of the set

00:28:01,020 --> 00:28:07,380
or not anyway we can get to that but

00:28:02,760 --> 00:28:12,990
that's it I'm after I have to go but we

00:28:07,380 --> 00:28:16,980
just made it with a cover E of how sort

00:28:12,990 --> 00:28:18,270
of data frog and Polonius work we won't

00:28:16,980 --> 00:28:21,060
get to this but that's okay it's not

00:28:18,270 --> 00:28:23,310
very important and we kind of did this

00:28:21,060 --> 00:28:26,280
what it would mean so I think that's

00:28:23,310 --> 00:28:32,690
just part of this section any brief

00:28:26,280 --> 00:28:37,550
questions right now in 0 minutes ok good

00:28:32,690 --> 00:28:37,550
also you're muted um I'll be saying

00:28:38,200 --> 00:28:44,879
then I will see one zoo thanks everybody

00:28:40,720 --> 00:28:44,879

YouTube URL: https://www.youtube.com/watch?v=i5KdU0ieb_A


