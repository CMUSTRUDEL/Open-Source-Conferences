Title: Cranelift
Publication date: 2019-01-31
Playlist: rustc lecture series
Description: 
	Dan Gohman explains the basic idea of the Cranelift code generator, covering the setup of the IR, the overall philosophy of its design, and some details of how it could be integrated with rustc.
Captions: 
	00:00:00,230 --> 00:00:09,240
okay well so hello everyone welcome to

00:00:05,130 --> 00:00:11,130
the compiler lecture series episode 2 we

00:00:09,240 --> 00:00:14,960
got Dan Goleman here to talk about crane

00:00:11,130 --> 00:00:18,029
lifts and I'll let him take it away

00:00:14,960 --> 00:00:20,789
thanks Nico so I'm Dan Gilman and I have

00:00:18,029 --> 00:00:21,930
talked about creative stuff and if I

00:00:20,789 --> 00:00:25,650
don't have some questions as we go along

00:00:21,930 --> 00:00:30,449
feel free to ping me or or me go either

00:00:25,650 --> 00:00:33,059
online or here in the video so quite

00:00:30,449 --> 00:00:34,380
lifts just gonna be a little talk about

00:00:33,059 --> 00:00:37,050
today and then I will basically what

00:00:34,380 --> 00:00:39,149
Queen it is you know if you some talking

00:00:37,050 --> 00:00:40,590
support Queen if they are and what kind

00:00:39,149 --> 00:00:43,200
of things we're doing with it and why we

00:00:40,590 --> 00:00:44,879
think it's designed Bell and talk about

00:00:43,200 --> 00:00:46,050
augmentation that we're doing now and

00:00:44,879 --> 00:00:47,969
stuff we want to do in the future and

00:00:46,050 --> 00:00:49,079
stuff that that people using cleaners

00:00:47,969 --> 00:00:54,059
can do before they start using

00:00:49,079 --> 00:00:55,949
agreements so chopping you do it what is

00:00:54,059 --> 00:00:57,840
clean lift queen lift is a compiler code

00:00:55,949 --> 00:00:59,010
again back-end that's where the cord is

00:00:57,840 --> 00:01:00,350
just that's what a lot of us definitely

00:00:59,010 --> 00:01:02,460
pulled around

00:01:00,350 --> 00:01:05,460
that's where organized this is a series

00:01:02,460 --> 00:01:09,000
of crates the central crate is the queen

00:01:05,460 --> 00:01:10,680
of kujan crate and antis cords actually

00:01:09,000 --> 00:01:12,930
function it sort of mathematical sense

00:01:10,680 --> 00:01:14,850
for the input is first of all why are

00:01:12,930 --> 00:01:17,159
you know but your position for a

00:01:14,850 --> 00:01:20,549
function it's a big data structure that

00:01:17,159 --> 00:01:21,930
rids a whole function of code a target

00:01:20,549 --> 00:01:24,560
description which is basically a machine

00:01:21,930 --> 00:01:27,530
like x86 no just you know what that is

00:01:24,560 --> 00:01:31,439
as well as a couple engine settings

00:01:27,530 --> 00:01:33,509
optimization level things like that the

00:01:31,439 --> 00:01:35,610
output of this function is first of all

00:01:33,509 --> 00:01:36,030
machine code which is just an array of

00:01:35,610 --> 00:01:37,920
bytes

00:01:36,030 --> 00:01:40,530
it's bytes that you presented to your

00:01:37,920 --> 00:01:41,790
CPU it can execute them and also

00:01:40,530 --> 00:01:43,560
metadata to describe those bytes

00:01:41,790 --> 00:01:46,909
metadata that can describe things like

00:01:43,560 --> 00:01:49,590
which instructions are expected to trap

00:01:46,909 --> 00:01:51,530
which instructions reference symbolic

00:01:49,590 --> 00:01:53,369
addresses that need to be relocated and

00:01:51,530 --> 00:01:56,659
other properties of the chapter in your

00:01:53,369 --> 00:01:58,740
code debug it film can also be in there

00:01:56,659 --> 00:02:00,570
along with quail Akutan we have a bunch

00:01:58,740 --> 00:02:01,860
of other treats that sort of augment it

00:02:00,570 --> 00:02:04,290
and for extra functionality clean the

00:02:01,860 --> 00:02:05,850
front end is a crate that helps in

00:02:04,290 --> 00:02:07,170
producing queen of they are in building

00:02:05,850 --> 00:02:09,869
up this data structure to hand off to

00:02:07,170 --> 00:02:12,420
the code generator creaminess possum is

00:02:09,869 --> 00:02:13,860
a great that is that can translate was

00:02:12,420 --> 00:02:16,490
encoded between if they are

00:02:13,860 --> 00:02:20,490
now what wasn't being webassembly

00:02:16,490 --> 00:02:22,680
Krishna fairy is a system for generating

00:02:20,490 --> 00:02:23,940
native object files data files with

00:02:22,680 --> 00:02:26,760
quaint enough code generated members you

00:02:23,940 --> 00:02:28,800
can creative code we also have a queen

00:02:26,760 --> 00:02:30,690
of simple jets there are many ways to

00:02:28,800 --> 00:02:32,100
use cream efforts including easily the

00:02:30,690 --> 00:02:33,420
Jets you don't have to use simple to it

00:02:32,100 --> 00:02:35,400
but simple Jade is sort of a simple

00:02:33,420 --> 00:02:36,570
framework that ties a lot things

00:02:35,400 --> 00:02:38,790
together it provides a lot of services

00:02:36,570 --> 00:02:40,950
for you to just run the code Aquino

00:02:38,790 --> 00:02:44,070
cream of generates memory but making an

00:02:40,950 --> 00:02:45,120
executable I'm running it's rightly this

00:02:44,070 --> 00:02:46,920
is just a brief overview of some of the

00:02:45,120 --> 00:02:50,730
major crates there are more but this is

00:02:46,920 --> 00:02:54,090
just kind of way to get started no I

00:02:50,730 --> 00:02:56,850
didn't a little bit about the fire so

00:02:54,090 --> 00:02:58,650
quit if I are is the central data

00:02:56,850 --> 00:02:59,760
structure that the code generator uses

00:02:58,650 --> 00:03:02,400
and I belong the system is could

00:02:59,760 --> 00:03:03,900
organized rounds it's a it's an

00:03:02,400 --> 00:03:05,400
in-memory data structure of course we

00:03:03,900 --> 00:03:07,230
also have a textual representation of it

00:03:05,400 --> 00:03:11,820
and we can go back to 40 and - now

00:03:07,230 --> 00:03:12,810
here's a screenshot of Mir I'm just

00:03:11,820 --> 00:03:15,930
gonna give you a flavor of what's going

00:03:12,810 --> 00:03:17,430
on basically the main unit of what they

00:03:15,930 --> 00:03:20,100
are is the function so we have a

00:03:17,430 --> 00:03:21,989
function Queen of desired operate on a

00:03:20,100 --> 00:03:23,250
single function at a time absolutely

00:03:21,989 --> 00:03:25,080
compiled functions are parallel with the

00:03:23,250 --> 00:03:26,459
VA since to create that suppose the

00:03:25,080 --> 00:03:27,480
quickly just focus on like that might

00:03:26,459 --> 00:03:30,030
one function and that's my universe

00:03:27,480 --> 00:03:32,160
everything is in that now inside the

00:03:30,030 --> 00:03:33,810
function there are a sequence of you

00:03:32,160 --> 00:03:35,160
start with those ticket declarations I

00:03:33,810 --> 00:03:38,790
guess in this code here there's just

00:03:35,160 --> 00:03:40,769
that SS 0 0 is a stack slot and then

00:03:38,790 --> 00:03:43,290
there's a series of basic blocks

00:03:40,769 --> 00:03:46,110
APB's has four extended basic block I'll

00:03:43,290 --> 00:03:47,430
talk about that a similar and then

00:03:46,110 --> 00:03:49,440
within each basic block is just a series

00:03:47,430 --> 00:03:50,610
of instructions and the instructions are

00:03:49,440 --> 00:03:54,060
typically doing things like arithmetic

00:03:50,610 --> 00:04:00,269
or accessing memory or patching build a

00:03:54,060 --> 00:04:02,100
basic box it looks like the local

00:04:00,269 --> 00:04:04,500
variable sort of speakers are local to

00:04:02,100 --> 00:04:07,470
basic blocks is that true I see they

00:04:04,500 --> 00:04:10,380
take parameters it's sort of like nice

00:04:07,470 --> 00:04:15,959
to say about even more refined yeah they

00:04:10,380 --> 00:04:17,640
do if one block dominates another block

00:04:15,959 --> 00:04:19,440
then the very one can be seen you know

00:04:17,640 --> 00:04:20,640
block so they are visible across

00:04:19,440 --> 00:04:23,280
boundaries as long as doesn't have an

00:04:20,640 --> 00:04:25,550
associative million - so V to witness a

00:04:23,280 --> 00:04:28,490
coding that pool is to fight an EVP one

00:04:25,550 --> 00:04:30,500
I guess there's no use of it here but it

00:04:28,490 --> 00:04:35,330
could be used in me - because EB - is

00:04:30,500 --> 00:04:38,330
dominated by now in this example so the

00:04:35,330 --> 00:04:40,310
perimeter is four blocks come in when

00:04:38,330 --> 00:04:41,900
when a block when you're not dominated

00:04:40,310 --> 00:04:43,639
when they use his dominate over the deaf

00:04:41,900 --> 00:04:45,940
so you know potentially multiple

00:04:43,639 --> 00:04:48,650
different values that when I get used

00:04:45,940 --> 00:04:50,300
and this is so this is getting into that

00:04:48,650 --> 00:04:51,680
SSA for a little bit in order to

00:04:50,300 --> 00:04:53,539
preserve as a safe form every variable

00:04:51,680 --> 00:04:56,000
can have a single death but if you have

00:04:53,539 --> 00:04:57,770
something like Indian else where in the

00:04:56,000 --> 00:05:02,990
source code you assign a different value

00:04:57,770 --> 00:05:04,819
in the if-else typical to SSA form would

00:05:02,990 --> 00:05:06,349
you Sophie node to merge the two

00:05:04,819 --> 00:05:09,139
together at the merge point into a

00:05:06,349 --> 00:05:10,849
single death for the merge Freimuth uses

00:05:09,139 --> 00:05:11,930
a called gone parameters because

00:05:10,849 --> 00:05:13,430
basically the same thing as he knows it

00:05:11,930 --> 00:05:14,560
just looks a bit different in there it

00:05:13,430 --> 00:05:16,340
just looks like the blocks hence

00:05:14,560 --> 00:05:17,719
hemorrhage you can almost think of the

00:05:16,340 --> 00:05:21,349
blocks as being little functions you can

00:05:17,719 --> 00:05:23,330
call it sits along the Devon on the

00:05:21,349 --> 00:05:25,460
lines of a CPS kind of system where

00:05:23,330 --> 00:05:32,870
basic locks recipe functions although we

00:05:25,460 --> 00:05:36,199
don't go to full CPS to do that so the

00:05:32,870 --> 00:05:37,729
big ideas we have as a safe form is the

00:05:36,199 --> 00:05:40,729
subtle concept and we actually make this

00:05:37,729 --> 00:05:42,740
we rely on this in all aspects you geek

00:05:40,729 --> 00:05:43,699
as as I a form then we preserve it all

00:05:42,740 --> 00:05:45,949
the way through code generator we do

00:05:43,699 --> 00:05:48,860
alleged occasion in SSA form so that's

00:05:45,949 --> 00:05:50,870
that's a very special guide yeah and in

00:05:48,860 --> 00:05:51,860
Owen with that we use one ir through a

00:05:50,870 --> 00:05:54,409
code generator instead of switching

00:05:51,860 --> 00:05:56,029
between a mid-level miser IR code

00:05:54,409 --> 00:05:57,830
generator our if you just use one that

00:05:56,029 --> 00:06:01,159
is suitable freezing totally through

00:05:57,830 --> 00:06:03,229
source selection and education we don't

00:06:01,159 --> 00:06:04,810
have twitter types because calif they

00:06:03,229 --> 00:06:06,830
are is focused on being a coordinator

00:06:04,810 --> 00:06:09,020
it's not doing things like player

00:06:06,830 --> 00:06:11,029
analysis and so it doesn't have any kind

00:06:09,020 --> 00:06:14,300
of useful Twitter types or any kind of

00:06:11,029 --> 00:06:14,990
knowledge of of higher level concept of

00:06:14,300 --> 00:06:17,599
memory ordering

00:06:14,990 --> 00:06:18,889
remembering layouts and so I said put

00:06:17,599 --> 00:06:20,180
attempts we just have energy types

00:06:18,889 --> 00:06:21,409
this also means we don't have a

00:06:20,180 --> 00:06:23,029
gentleman put our instruction there just

00:06:21,409 --> 00:06:25,639
unit or instructions it simplifies

00:06:23,029 --> 00:06:27,259
things writer the coordinator because at

00:06:25,639 --> 00:06:29,270
a hardware level pointers are just

00:06:27,259 --> 00:06:30,590
integers on most of our pictures so

00:06:29,270 --> 00:06:32,419
they'll use the same registers and the

00:06:30,590 --> 00:06:34,279
single functions so it supplies things

00:06:32,419 --> 00:06:36,649
we just have we just exclusively are

00:06:34,279 --> 00:06:38,149
they're just integers in this level and

00:06:36,649 --> 00:06:39,569
I'll talk a bit about later but like

00:06:38,149 --> 00:06:41,309
what if we want to do

00:06:39,569 --> 00:06:46,439
memory operations and point operations

00:06:41,309 --> 00:06:47,909
what we need to do what hapless another

00:06:46,439 --> 00:06:49,740
of our big ideas is what a memory is

00:06:47,909 --> 00:06:50,879
minimize the memory usage especially for

00:06:49,740 --> 00:06:53,069
the very common case of just generating

00:06:50,879 --> 00:06:56,759
coal quickly so we don't have built in

00:06:53,069 --> 00:06:58,919
death useless yeah in for example LVM

00:06:56,759 --> 00:07:01,559
there's it maintains a lid list for

00:06:58,919 --> 00:07:03,389
every useful value automatically so

00:07:01,559 --> 00:07:05,849
whatever you create a value or a branch

00:07:03,389 --> 00:07:07,559
these linked lists of all the values

00:07:05,849 --> 00:07:09,029
that are being used all the places their

00:07:07,559 --> 00:07:11,009
values being used is maybe none might be

00:07:09,029 --> 00:07:12,659
in cui that doesn't maintain that it's

00:07:11,009 --> 00:07:14,369
just an extra data structure that it's

00:07:12,659 --> 00:07:15,959
not always needed and so we just take

00:07:14,369 --> 00:07:17,399
care to not need one and so we can save

00:07:15,959 --> 00:07:20,849
the memory and save the exit capacity of

00:07:17,399 --> 00:07:22,349
having those around we also don't have

00:07:20,849 --> 00:07:24,689
Ontario sized integers like el viento so

00:07:22,349 --> 00:07:27,199
there's no i-77 type and this again is

00:07:24,689 --> 00:07:29,459
of a biased for its code generator focus

00:07:27,199 --> 00:07:30,749
hardware don't miss wasn't most hardware

00:07:29,459 --> 00:07:34,019
platforms don't have integer types like

00:07:30,749 --> 00:07:37,919
I 77 we just have stared spinard i ate i

00:07:34,019 --> 00:07:38,879
69 32 24 and some queen that does really

00:07:37,919 --> 00:07:41,490
focus in those types with the

00:07:38,879 --> 00:07:42,809
expectation at this point if people want

00:07:41,490 --> 00:07:44,459
to use other side's integers those could

00:07:42,809 --> 00:07:47,759
be lowered before producing cream if

00:07:44,459 --> 00:07:50,879
they are a higher level another one of

00:07:47,759 --> 00:07:52,589
the big ideas is it's still in kind of

00:07:50,879 --> 00:07:55,169
the early phases is to use an e CS like

00:07:52,589 --> 00:07:56,399
design into the component system this is

00:07:55,169 --> 00:07:57,229
a way that it's got a lot of tension in

00:07:56,399 --> 00:08:00,449
rust

00:07:57,229 --> 00:08:03,990
recently and the idea is that instead of

00:08:00,449 --> 00:08:05,819
having a large soup of pointers

00:08:03,990 --> 00:08:07,469
essentially a lot of commodity records

00:08:05,819 --> 00:08:11,009
are basically just big graphs of

00:08:07,469 --> 00:08:13,559
pointers in Queen left we have is the

00:08:11,009 --> 00:08:15,569
large arrays essentially arenas and

00:08:13,559 --> 00:08:16,559
indices into arrays so we didn't same

00:08:15,569 --> 00:08:17,899
kind of things we have the same time

00:08:16,559 --> 00:08:19,889
data structures it's same photographs

00:08:17,899 --> 00:08:22,619
but instead of there's pointers on where

00:08:19,889 --> 00:08:23,610
it's into season two arrays and this is

00:08:22,619 --> 00:08:25,079
a couple of bandages I'm gonna talk

00:08:23,610 --> 00:08:26,789
about a little later just want to go

00:08:25,079 --> 00:08:29,789
back and look at the in our example

00:08:26,789 --> 00:08:32,279
again one interesting thing to point out

00:08:29,789 --> 00:08:33,509
here is that the numbers you see so the

00:08:32,279 --> 00:08:35,339
value numbers on the left of every

00:08:33,509 --> 00:08:38,490
instruction we see anything like b2

00:08:35,339 --> 00:08:40,469
equals say two more pots those value

00:08:38,490 --> 00:08:42,719
numbers aren't arbitrary straightness

00:08:40,469 --> 00:08:44,069
those are actually says V 2 that's

00:08:42,719 --> 00:08:46,170
actually indexed to an Italian table

00:08:44,069 --> 00:08:48,449
when we see SS 0 for the stack slot

00:08:46,170 --> 00:08:50,850
that's actually stack slot 0 in the

00:08:48,449 --> 00:08:52,990
stacks about table and so you can you

00:08:50,850 --> 00:08:54,370
can very clearly see all the MCS in

00:08:52,990 --> 00:08:56,590
in the textual dump this also means that

00:08:54,370 --> 00:08:58,180
when we double the IR and meet back in

00:08:56,590 --> 00:08:59,830
all the indices can be preserved so ever

00:08:58,180 --> 00:09:04,630
they can be preserved recreated exactly

00:08:59,830 --> 00:09:05,860
how abouts in order was this could be

00:09:04,630 --> 00:09:07,210
really handy for debugging because we

00:09:05,860 --> 00:09:08,430
can dump what I are agreed if I can now

00:09:07,210 --> 00:09:10,840
I have to worry about things

00:09:08,430 --> 00:09:19,630
tuning order or moving around everything

00:09:10,840 --> 00:09:21,010
can be preserved so ECS is cool one of

00:09:19,630 --> 00:09:24,010
the cool things you can do with ECS is a

00:09:21,010 --> 00:09:25,650
thing called a secondary map so woke up

00:09:24,010 --> 00:09:27,280
needing compilers is when you have

00:09:25,650 --> 00:09:29,140
something you care about like

00:09:27,280 --> 00:09:31,720
instructions or basic blocks you often

00:09:29,140 --> 00:09:33,130
want to associate extra information for

00:09:31,720 --> 00:09:35,500
every instruction or education for every

00:09:33,130 --> 00:09:37,210
basic block and the ECM system exactly

00:09:35,500 --> 00:09:39,340
it used to do we've got my cuts bacala

00:09:37,210 --> 00:09:41,560
secondary map it is basically another

00:09:39,340 --> 00:09:44,200
array that uses the same index base is

00:09:41,560 --> 00:09:45,400
your primary array and so you can use

00:09:44,200 --> 00:09:46,930
one day next to look up the main

00:09:45,400 --> 00:09:48,340
instruction in the instruction table we

00:09:46,930 --> 00:09:49,780
could use that same index to look up the

00:09:48,340 --> 00:09:51,910
unsealer information in your secondary

00:09:49,780 --> 00:09:54,610
table so it's very quick we don't need

00:09:51,910 --> 00:09:56,140
to have a lot of hashmaps to associate

00:09:54,610 --> 00:09:58,510
extra information you can just use use

00:09:56,140 --> 00:10:01,420
the index pieces and clean that entity

00:09:58,510 --> 00:10:03,160
system has distinguished types for the

00:10:01,420 --> 00:10:04,780
indices so it's very difficult so you

00:10:03,160 --> 00:10:06,130
prevented from using an index into the

00:10:04,780 --> 00:10:08,890
wrong table because we all know type

00:10:06,130 --> 00:10:11,470
safety disease so second parents are

00:10:08,890 --> 00:10:12,940
really cool although we're is we're

00:10:11,470 --> 00:10:14,350
getting further into this kind of design

00:10:12,940 --> 00:10:16,090
we're actually finding persons and the

00:10:14,350 --> 00:10:18,790
shortcuts for coming so we're running

00:10:16,090 --> 00:10:20,590
into that's causing some problems one of

00:10:18,790 --> 00:10:22,780
them is that we're not really using ECS

00:10:20,590 --> 00:10:25,360
in a kind of conventional way when you

00:10:22,780 --> 00:10:27,700
think what using easiest a game engine a

00:10:25,360 --> 00:10:29,290
common use for ECS is that you would

00:10:27,700 --> 00:10:31,360
like start all of your raised are we

00:10:29,290 --> 00:10:33,040
doing just linear iterations and like I

00:10:31,360 --> 00:10:35,260
want to get all the entities and usage

00:10:33,040 --> 00:10:36,610
box in the array but in playlists

00:10:35,260 --> 00:10:37,690
because we're basically presenting both

00:10:36,610 --> 00:10:39,430
data structures we're doing a lot of

00:10:37,690 --> 00:10:41,110
crafts traversals

00:10:39,430 --> 00:10:43,360
a lot of what we end up doing is random

00:10:41,110 --> 00:10:45,340
access its arrays so we just have you

00:10:43,360 --> 00:10:46,900
know here's an interruption that want to

00:10:45,340 --> 00:10:49,360
see what operands in our operates it has

00:10:46,900 --> 00:10:50,980
those are indices infinity table I want

00:10:49,360 --> 00:10:52,540
to see what we have those are more

00:10:50,980 --> 00:10:54,490
indices we end up doing essentially book

00:10:52,540 --> 00:10:55,510
but ends up looking like Twitter chasing

00:10:54,490 --> 00:10:57,460
but it's actually do like you next

00:10:55,510 --> 00:10:59,980
submitter write chasing these are all of

00:10:57,460 --> 00:11:01,120
item access accesses and of course we're

00:10:59,980 --> 00:11:03,160
using bus so the green seas are all

00:11:01,120 --> 00:11:04,840
bounds checked and we actually did some

00:11:03,160 --> 00:11:06,940
experiments recently where we clean we

00:11:04,840 --> 00:11:09,010
did some tricks to disable to bounce

00:11:06,940 --> 00:11:11,100
checks and found that it sped up couple

00:11:09,010 --> 00:11:12,970
agent type of Kleenex overall by 8%

00:11:11,100 --> 00:11:13,990
that's kind of a lot and it kind of

00:11:12,970 --> 00:11:15,640
shows you how heavily we're actually

00:11:13,990 --> 00:11:17,620
leading on this technique of using

00:11:15,640 --> 00:11:19,840
arrays and using random X's and arrays

00:11:17,620 --> 00:11:22,150
so we can I have this open question

00:11:19,840 --> 00:11:23,470
there about it pretend it's a lot we're

00:11:22,150 --> 00:11:26,920
not really interested in living that of

00:11:23,470 --> 00:11:28,780
people and we don't have the same kind

00:11:26,920 --> 00:11:31,150
of problem that a lot of array access

00:11:28,780 --> 00:11:32,470
uses have we're not doing indices we're

00:11:31,150 --> 00:11:33,730
not doing arithmetic on our indices the

00:11:32,470 --> 00:11:36,460
indices are basically just these will

00:11:33,730 --> 00:11:37,690
pick tokens and so it's very unlikely

00:11:36,460 --> 00:11:38,830
that well Branca chances on our way out

00:11:37,690 --> 00:11:39,970
of balance because we're never using an

00:11:38,830 --> 00:11:41,380
arbitrary index girl that's using a

00:11:39,970 --> 00:11:43,780
token that was given to us from you

00:11:41,380 --> 00:11:45,690
right itself and so you could argue that

00:11:43,780 --> 00:11:47,890
we don't really need those bound chicks

00:11:45,690 --> 00:11:49,690
so the kind of question is like should

00:11:47,890 --> 00:11:51,100
we add unsafe to get back that 80%

00:11:49,690 --> 00:11:53,890
should we make that option to our users

00:11:51,100 --> 00:11:54,880
like a cargo feature or something so

00:11:53,890 --> 00:11:56,020
it's an interesting design for that

00:11:54,880 --> 00:12:00,010
question we're sort of thing up there is

00:11:56,020 --> 00:12:04,510
as we get further in this ECS design one

00:12:00,010 --> 00:12:06,760
question about that do you do you what

00:12:04,510 --> 00:12:09,910
do you do with you for example remove a

00:12:06,760 --> 00:12:12,430
basic block with its what happens to its

00:12:09,910 --> 00:12:15,190
index in that case that's right so clear

00:12:12,430 --> 00:12:17,110
remove a block in our case the index it

00:12:15,190 --> 00:12:20,410
just remains essentially dead at that

00:12:17,110 --> 00:12:21,970
point and we'll never reuse it and so we

00:12:20,410 --> 00:12:23,440
just have we just remove the block from

00:12:21,970 --> 00:12:25,510
the code and we delete all references to

00:12:23,440 --> 00:12:27,520
it and then basically just leak that

00:12:25,510 --> 00:12:29,560
index and never try to reuse it okay

00:12:27,520 --> 00:12:31,600
that makes things simpler for us and and

00:12:29,560 --> 00:12:33,370
because because again is also that it's

00:12:31,600 --> 00:12:36,580
getting back to the food in focus we're

00:12:33,370 --> 00:12:38,710
not doing a lot of aggressive sort of

00:12:36,580 --> 00:12:40,440
blue team instructions or cleaning you

00:12:38,710 --> 00:12:42,610
know reorganizing instructions

00:12:40,440 --> 00:12:43,930
most things we assume in code gen

00:12:42,610 --> 00:12:45,070
they're gonna be pretty close to the

00:12:43,930 --> 00:12:47,530
format that can look like in the output

00:12:45,070 --> 00:12:48,880
and so we don't need a lot of reuse and

00:12:47,530 --> 00:12:50,050
actually that simplifies our energy

00:12:48,880 --> 00:12:51,880
possessed of a lot because we don't even

00:12:50,050 --> 00:12:55,420
do things like the generational system

00:12:51,880 --> 00:12:59,500
with indices or try to keep track of is

00:12:55,420 --> 00:13:00,700
this in X dangling somehow and but yeah

00:12:59,500 --> 00:13:01,900
we can get away with that because we

00:13:00,700 --> 00:13:02,770
know we're compiler Beca and it won't

00:13:01,900 --> 00:13:03,670
compile just one function

00:13:02,770 --> 00:13:05,830
nothing another function we're gonna

00:13:03,670 --> 00:13:07,420
blow it away and do the X function so we

00:13:05,830 --> 00:13:10,540
can get away with wasting a little bit

00:13:07,420 --> 00:13:11,920
memory and in return we can actually

00:13:10,540 --> 00:13:14,140
save memory by not having to have all

00:13:11,920 --> 00:13:17,310
this every index having have a

00:13:14,140 --> 00:13:17,310
generation testable for example

00:13:17,610 --> 00:13:21,490
um another challenge we found with the

00:13:20,200 --> 00:13:24,130
system is that we end up keeping a lot

00:13:21,490 --> 00:13:26,740
of our raise around a memory between

00:13:24,130 --> 00:13:27,700
lift is designed to be quite paranoid

00:13:26,740 --> 00:13:29,470
about calling malloc

00:13:27,700 --> 00:13:32,320
I wonder if s/he is it's too paranoid

00:13:29,470 --> 00:13:33,550
but we had a whole bunch of arrays we

00:13:32,320 --> 00:13:35,829
have the instruction array we have the

00:13:33,550 --> 00:13:39,550
data array or the value array basic

00:13:35,829 --> 00:13:41,290
wakame you have sex a lot arrays tables

00:13:39,550 --> 00:13:42,610
and we just keep all these tables around

00:13:41,290 --> 00:13:44,860
we have the bodhi like when you're done

00:13:42,610 --> 00:13:46,390
on one function we can call clear on the

00:13:44,860 --> 00:13:49,149
function then it calls clear on all its

00:13:46,390 --> 00:13:50,589
underlying tables which are of X and

00:13:49,149 --> 00:13:52,390
that allows us to hold on to the

00:13:50,589 --> 00:13:54,640
allocations the size is set to zero but

00:13:52,390 --> 00:13:56,620
the capacity remains allocated which is

00:13:54,640 --> 00:13:58,990
a way to avoid calling malloc routine

00:13:56,620 --> 00:14:01,360
functions but it means that each of

00:13:58,990 --> 00:14:03,010
these tables grows to the size of the

00:14:01,360 --> 00:14:05,410
biggest table across the entire set of

00:14:03,010 --> 00:14:06,640
function to block quote compile and

00:14:05,410 --> 00:14:07,899
pitch Li means our high watermark for

00:14:06,640 --> 00:14:11,320
memory usage is higher than it used to

00:14:07,899 --> 00:14:12,940
be one of the things that we're kind of

00:14:11,320 --> 00:14:14,950
thinking about is an alternative I'm

00:14:12,940 --> 00:14:17,079
really a big fan of the life away like

00:14:14,950 --> 00:14:18,579
Athena structure it SpiderMonkey so life

00:14:17,079 --> 00:14:20,050
away like is basically just a big bug

00:14:18,579 --> 00:14:22,029
cleaner alligator and it really fits the

00:14:20,050 --> 00:14:22,930
kind of compiler or use case what are

00:14:22,029 --> 00:14:25,180
you saying I'm going to compile one

00:14:22,930 --> 00:14:26,410
function and while I'm compiling I'm

00:14:25,180 --> 00:14:28,149
just gonna bump later elekid not ready

00:14:26,410 --> 00:14:29,769
we use any memory at all and just

00:14:28,149 --> 00:14:30,910
telling Alec Alec Alec Alec throw the

00:14:29,769 --> 00:14:33,459
whole thing away what's that funky who's

00:14:30,910 --> 00:14:35,290
done that Fitz

00:14:33,459 --> 00:14:36,550
especially if you're thinking about you

00:14:35,290 --> 00:14:38,440
much fun fast compilation

00:14:36,550 --> 00:14:39,519
that's a really fast pattern and you're

00:14:38,440 --> 00:14:41,620
going for the ball for a kind of a code

00:14:39,519 --> 00:14:42,850
general use case and it also means that

00:14:41,620 --> 00:14:45,070
we could probably get away with actually

00:14:42,850 --> 00:14:46,839
freeing and shrinking our memory usage

00:14:45,070 --> 00:14:47,850
more often right now we don't do that

00:14:46,839 --> 00:14:51,089
very often because we have lots of

00:14:47,850 --> 00:14:53,410
medium sized arrays and one big array

00:14:51,089 --> 00:14:54,850
and so we end up paying more because we

00:14:53,410 --> 00:14:57,149
the sum of all the media types of races

00:14:54,850 --> 00:14:59,350
more than the one big array that's we

00:14:57,149 --> 00:15:03,640
you're familiar with the tight Dorina

00:14:59,350 --> 00:15:06,940
crate right and yes yeah yes I think I

00:15:03,640 --> 00:15:08,190
think we're looking at and that's nobody

00:15:06,940 --> 00:15:12,699
in our state experiment to do

00:15:08,190 --> 00:15:14,560
one thing that I'm sort of missed is and

00:15:12,699 --> 00:15:15,730
he's coming from SpiderMonkey the late

00:15:14,560 --> 00:15:17,980
boil activate has the bodhi there's a

00:15:15,730 --> 00:15:20,110
vector class that sort of always set up

00:15:17,980 --> 00:15:22,560
to use the life was a vacuum stored so

00:15:20,110 --> 00:15:24,490
you basically just have multiple vectors

00:15:22,560 --> 00:15:26,110
to write code widths I don't have to

00:15:24,490 --> 00:15:27,730
worry about you know trying to manager

00:15:26,110 --> 00:15:28,830
your underlying allocation you just read

00:15:27,730 --> 00:15:30,660
like a vector and

00:15:28,830 --> 00:15:31,650
it's over the life I like everything

00:15:30,660 --> 00:15:33,120
just automatically has the right

00:15:31,650 --> 00:15:35,040
lifetime and just goes away we wanted to

00:15:33,120 --> 00:15:37,890
so that's a that's interesting

00:15:35,040 --> 00:15:39,960
possibility area we want to explore that

00:15:37,890 --> 00:15:41,190
may end up moving us away from the ACS

00:15:39,960 --> 00:15:43,500
system because it may just have like one

00:15:41,190 --> 00:15:44,900
big arena and then we might just look at

00:15:43,500 --> 00:15:46,650
using regular players instead of indices

00:15:44,900 --> 00:15:48,480
although that's an integer question

00:15:46,650 --> 00:15:50,100
because using a 2 C's means we can use

00:15:48,480 --> 00:15:53,310
32-bit in to see photos so if you didn't

00:15:50,100 --> 00:15:54,990
see it we didn't save half of our memory

00:15:53,310 --> 00:15:58,830
because so much of our Asian Tricia's

00:15:54,990 --> 00:16:00,360
players and other generations another

00:15:58,830 --> 00:16:02,340
petrel downside is the dense memory

00:16:00,360 --> 00:16:03,570
usage I mentioned the secondary bad

00:16:02,340 --> 00:16:05,700
thing that we're doing where we guess we

00:16:03,570 --> 00:16:08,580
create a slide array to describe extra

00:16:05,700 --> 00:16:09,990
data log with the primary array this is

00:16:08,580 --> 00:16:12,000
pretty cool when that arraigns at being

00:16:09,990 --> 00:16:14,760
dense because it's just one big dense

00:16:12,000 --> 00:16:16,560
array but when it's sparse we use a lot

00:16:14,760 --> 00:16:17,940
of memories because a for array an

00:16:16,560 --> 00:16:19,410
element for every instruction where if

00:16:17,940 --> 00:16:21,270
you only need to annotate a small number

00:16:19,410 --> 00:16:23,430
instructions reason why we didn't use so

00:16:21,270 --> 00:16:25,680
I think the system could have encouraged

00:16:23,430 --> 00:16:27,030
us towards secondary maps but sometimes

00:16:25,680 --> 00:16:28,350
we do that too much and we should

00:16:27,030 --> 00:16:32,940
probably just get to go back to hashmaps

00:16:28,350 --> 00:16:34,140
and use less memory some pieces I don't

00:16:32,940 --> 00:16:36,630
know if it's physical in the recording

00:16:34,140 --> 00:16:38,310
so I'm just gonna repeat that alexey man

00:16:36,630 --> 00:16:43,590
clad road bump that the bump Alec

00:16:38,310 --> 00:16:44,640
creates may also yeah that's good you

00:16:43,590 --> 00:16:45,900
know I haven't actually taken that a

00:16:44,640 --> 00:16:46,890
survey of all the different options out

00:16:45,900 --> 00:16:51,180
there so that's good to know illegals

00:16:46,890 --> 00:16:52,770
are just as a data point I think the

00:16:51,180 --> 00:16:54,840
compiler moved towards hashmaps

00:16:52,770 --> 00:16:56,520
versus there were a couple places where

00:16:54,840 --> 00:16:58,860
we're using dense arrays and we also

00:16:56,520 --> 00:17:00,390
move pretty universally to hashmaps for

00:16:58,860 --> 00:17:03,120
our secondary Maps for the same reasons

00:17:00,390 --> 00:17:05,940
it's just the overhead isn't that high

00:17:03,120 --> 00:17:12,420
when they're dense and the sparks caused

00:17:05,940 --> 00:17:13,830
is too high yeah so I guess this kind of

00:17:12,420 --> 00:17:15,510
a tangent here but also want to address

00:17:13,830 --> 00:17:20,040
the topic about like why don't we use

00:17:15,510 --> 00:17:21,630
web assemblies or ir and and a couple

00:17:20,040 --> 00:17:23,280
quick questions that one of them is that

00:17:21,630 --> 00:17:25,680
web assembly is designed to be a safe

00:17:23,280 --> 00:17:27,000
language and some of the stuff that code

00:17:25,680 --> 00:17:28,710
narrators do is just fundamentally

00:17:27,000 --> 00:17:30,870
unsafe for example one of things about I

00:17:28,710 --> 00:17:34,140
do with with array axises it often ways

00:17:30,870 --> 00:17:35,310
away mouth checks and it's it's not

00:17:34,140 --> 00:17:36,840
possible represent a very excellent

00:17:35,310 --> 00:17:38,340
cause check out without being unsafe and

00:17:36,840 --> 00:17:41,740
some levels so like I'm simply can't

00:17:38,340 --> 00:17:42,640
represent that as innocent or concept

00:17:41,740 --> 00:17:43,660
so we need to be able to terms and

00:17:42,640 --> 00:17:47,610
things that are unsafe because we've

00:17:43,660 --> 00:17:49,240
proven them they're safe

00:17:47,610 --> 00:17:51,400
another thing is that we're actually

00:17:49,240 --> 00:17:52,900
looking to use crane left as a back-end

00:17:51,400 --> 00:17:54,309
for more than just webassembly we're

00:17:52,900 --> 00:17:56,740
looking at using anis back in for the

00:17:54,309 --> 00:17:58,270
Ross compiler as well and Brust being a

00:17:56,740 --> 00:17:59,230
systems language once relatively

00:17:58,270 --> 00:18:00,730
complete access to go in a white

00:17:59,230 --> 00:18:02,710
platform wants all the goodies all the

00:18:00,730 --> 00:18:03,970
intrinsics all the special colleague

00:18:02,710 --> 00:18:05,350
mentions we want to explain all those

00:18:03,970 --> 00:18:08,470
things and so we can't do that we can

00:18:05,350 --> 00:18:16,030
simply we know much more complete by our

00:18:08,470 --> 00:18:17,260
is is where we're gonna go initially

00:18:16,030 --> 00:18:18,460
design question I just wanted to bring

00:18:17,260 --> 00:18:20,050
up here and keep people have thoughts

00:18:18,460 --> 00:18:21,280
about this what kind of going through

00:18:20,050 --> 00:18:24,400
this so we don't have a lot of clear

00:18:21,280 --> 00:18:25,840
guidelines so we're adding a feature we

00:18:24,400 --> 00:18:27,309
can add things as an ir construct

00:18:25,840 --> 00:18:29,230
directly or we can we can lower things

00:18:27,309 --> 00:18:30,429
in the finance for example pretty

00:18:29,230 --> 00:18:33,550
recently we had someone contribute a

00:18:30,429 --> 00:18:34,750
patch to allow us to do mem copy if

00:18:33,550 --> 00:18:37,000
you're a front-end and you want to you

00:18:34,750 --> 00:18:39,640
know copy a structure an array we'll be

00:18:37,000 --> 00:18:40,600
able to call them copy what an option we

00:18:39,640 --> 00:18:43,770
could have done is we could have put

00:18:40,600 --> 00:18:46,270
about copy instruction in a ir and then

00:18:43,770 --> 00:18:47,920
the legalization phase could turn an

00:18:46,270 --> 00:18:51,429
instruction into a mcafee collets

00:18:47,920 --> 00:18:53,170
propria time doing is we actually ended

00:18:51,429 --> 00:18:55,870
up having the front end to put in the

00:18:53,170 --> 00:18:58,390
front end great expose an API call for

00:18:55,870 --> 00:19:00,460
just calling now no copy and what it

00:18:58,390 --> 00:19:01,840
does is it produces IR instead of

00:19:00,460 --> 00:19:04,840
creating a mem copy instruction it just

00:19:01,840 --> 00:19:06,100
creates the number call directly or in

00:19:04,840 --> 00:19:07,540
the in optimizing case if you're making

00:19:06,100 --> 00:19:09,040
a small amount of copy it'll actually

00:19:07,540 --> 00:19:10,840
just omit loads of source directly so

00:19:09,040 --> 00:19:12,210
the IR data from here itself never

00:19:10,840 --> 00:19:14,260
actually hasn't been copy instruction

00:19:12,210 --> 00:19:15,490
and this is a question that we have a

00:19:14,260 --> 00:19:17,440
kind of over and over again and we don't

00:19:15,490 --> 00:19:19,210
actually have a lot of clear answers for

00:19:17,440 --> 00:19:24,550
once we do something in one side or

00:19:19,210 --> 00:19:26,950
other how did IRB and a lot of it comes

00:19:24,550 --> 00:19:28,390
down to like this having things as an

00:19:26,950 --> 00:19:29,790
opcode and now you discipline to

00:19:28,390 --> 00:19:32,080
optimize things more than what otherwise

00:19:29,790 --> 00:19:33,070
and with meant copy the answer is not

00:19:32,080 --> 00:19:34,960
really because per month

00:19:33,070 --> 00:19:36,070
it's a code generator already traje but

00:19:34,960 --> 00:19:37,510
not really focused on things like thumb

00:19:36,070 --> 00:19:39,520
calculations that'll be something

00:19:37,510 --> 00:19:40,690
that'll be higher level so right now

00:19:39,520 --> 00:19:42,970
would it make sense for an about coke

00:19:40,690 --> 00:19:45,370
that no but this is a question that will

00:19:42,970 --> 00:19:48,340
probably end up reviewing disappoint we

00:19:45,370 --> 00:19:49,750
also have questions for like arbitrary

00:19:48,340 --> 00:19:51,730
signs integers or people want even just

00:19:49,750 --> 00:19:52,980
like egg 128 if you want that I will 28

00:19:51,730 --> 00:19:55,240
type that ghost has

00:19:52,980 --> 00:19:55,600
should we add that to the IR or should

00:19:55,240 --> 00:19:57,160
we have

00:19:55,600 --> 00:19:59,680
fun ends lower that before they go to

00:19:57,160 --> 00:20:01,000
our it's kind of a bit issue for that we

00:19:59,680 --> 00:20:02,860
might even have answer to that so sort

00:20:01,000 --> 00:20:04,660
of interesting question that we're kind

00:20:02,860 --> 00:20:11,080
of looking for if people have opinions

00:20:04,660 --> 00:20:12,040
or insights on that this you can almost

00:20:11,080 --> 00:20:15,100
even think of this question is

00:20:12,040 --> 00:20:16,450
contending in essence a construction we

00:20:15,100 --> 00:20:18,520
went all the way and said we're not even

00:20:16,450 --> 00:20:20,050
get haven't IR that can represent an

00:20:18,520 --> 00:20:22,470
essay form at all so in order to even

00:20:20,050 --> 00:20:25,570
produce IR you have a say form up front

00:20:22,470 --> 00:20:27,540
this can be awkward for fun ends because

00:20:25,570 --> 00:20:29,860
not all friends have us a form coming in

00:20:27,540 --> 00:20:31,420
and so we basically pushed esta

00:20:29,860 --> 00:20:33,640
construction into the queen of finance

00:20:31,420 --> 00:20:36,490
rage we have a pretty simple API that

00:20:33,640 --> 00:20:38,020
you can use you declare variable and

00:20:36,490 --> 00:20:39,670
then once you've declared a variable

00:20:38,020 --> 00:20:42,310
then you can use it and you can define

00:20:39,670 --> 00:20:43,600
it or or slide about you to it so use it

00:20:42,310 --> 00:20:45,010
is just functionally you give it a

00:20:43,600 --> 00:20:47,080
variable handle and it gives you the

00:20:45,010 --> 00:20:48,070
value at that put and to define it you

00:20:47,080 --> 00:20:50,170
give it a variable head of value to

00:20:48,070 --> 00:20:51,640
assign it to and what this does is

00:20:50,170 --> 00:20:53,230
actually it constructs as they form

00:20:51,640 --> 00:20:55,480
under the covers so given the uses and

00:20:53,230 --> 00:20:59,770
deaths it will insert the block

00:20:55,480 --> 00:21:00,790
parameters fees as needed you know it's

00:20:59,770 --> 00:21:01,330
sort of satisfy your as it's a

00:21:00,790 --> 00:21:04,600
conditions

00:21:01,330 --> 00:21:06,400
that's so we've we've in in the spirit

00:21:04,600 --> 00:21:08,110
of thinking about what belongs in the AR

00:21:06,400 --> 00:21:09,340
versus what belongs in the finitely we

00:21:08,110 --> 00:21:10,570
were actually able to push us as a

00:21:09,340 --> 00:21:11,140
construction team in the front end so at

00:21:10,570 --> 00:21:12,730
the back end

00:21:11,140 --> 00:21:14,050
and the data doctors don't even need to

00:21:12,730 --> 00:21:16,930
worry about the possibility of being on

00:21:14,050 --> 00:21:18,750
the state form and we don't even need to

00:21:16,930 --> 00:21:20,560
break ball things like mint oregano

00:21:18,750 --> 00:21:22,510
differently does it for you so they have

00:21:20,560 --> 00:21:23,860
this not as super firm representatives

00:21:22,510 --> 00:21:26,140
memory but it's kind of a special memory

00:21:23,860 --> 00:21:27,790
that could be optimized we just have a

00:21:26,140 --> 00:21:29,020
single form that just registers and you

00:21:27,790 --> 00:21:35,590
produce with registers as you produce

00:21:29,020 --> 00:21:37,270
the IR and you can use this all right

00:21:35,590 --> 00:21:40,300
that's what it concludes my my brief

00:21:37,270 --> 00:21:42,880
tour of the IR and I want to move on to

00:21:40,300 --> 00:21:44,530
authorization and talk about first

00:21:42,880 --> 00:21:47,740
operation that crane itself is doing

00:21:44,530 --> 00:21:48,730
today and then also talk about what kind

00:21:47,740 --> 00:21:51,220
of illusions we want to do in the future

00:21:48,730 --> 00:21:52,420
and how we can how we can arrange it

00:21:51,220 --> 00:21:57,100
compiler to help make those operation

00:21:52,420 --> 00:21:58,510
possible so first rate if we're

00:21:57,100 --> 00:21:59,710
currently focused on being a code

00:21:58,510 --> 00:22:00,970
generator and so we're doing that sort

00:21:59,710 --> 00:22:03,010
of code and operation things

00:22:00,970 --> 00:22:06,850
one of those is translating from

00:22:03,010 --> 00:22:08,460
quickness relatively mid-level ir which

00:22:06,850 --> 00:22:11,639
has some obstructions

00:22:08,460 --> 00:22:13,740
now into machine level IR which

00:22:11,639 --> 00:22:14,970
basically uses machine up codes so

00:22:13,740 --> 00:22:16,740
example that it's like the pop code

00:22:14,970 --> 00:22:19,169
instruction in Queen of Pop code is just

00:22:16,740 --> 00:22:20,399
an instruction code of course not all

00:22:19,169 --> 00:22:22,049
hardware platforms have a pub Co

00:22:20,399 --> 00:22:23,460
instructions so if you do have it

00:22:22,049 --> 00:22:25,169
obviously we just use that instruction

00:22:23,460 --> 00:22:26,100
if you don't want that huh construction

00:22:25,169 --> 00:22:27,450
might turn into a sequence of

00:22:26,100 --> 00:22:30,320
instructions or maybe even a library

00:22:27,450 --> 00:22:34,559
column so we call this process of

00:22:30,320 --> 00:22:36,929
turning things that are not legal for

00:22:34,559 --> 00:22:39,090
the machine being a machine has no

00:22:36,929 --> 00:22:40,200
equivalent of that up code into things

00:22:39,090 --> 00:22:41,730
that are legal from the sheet mean the

00:22:40,200 --> 00:22:43,200
machine has a thing that is say like a

00:22:41,730 --> 00:22:44,960
pop construction that exactly

00:22:43,200 --> 00:22:47,460
corresponds the operations we're doing

00:22:44,960 --> 00:22:49,799
and this is this is our the same process

00:22:47,460 --> 00:22:51,059
of we also call this lowering and it's

00:22:49,799 --> 00:22:52,320
also sort of the same thing as

00:22:51,059 --> 00:22:54,330
instruction selection to some level just

00:22:52,320 --> 00:22:55,559
like deciding what machine opcodes we're

00:22:54,330 --> 00:22:57,990
going to use the binder particular

00:22:55,559 --> 00:23:00,299
constructs great it doesn't currently

00:22:57,990 --> 00:23:01,409
have a very fancy system for doing this

00:23:00,299 --> 00:23:03,840
we just kind of walk through the code

00:23:01,409 --> 00:23:05,639
and expand when the unit I'm but this is

00:23:03,840 --> 00:23:07,549
an area where there's been a lot of

00:23:05,639 --> 00:23:09,960
academic work in this area and a lot of

00:23:07,549 --> 00:23:12,119
the art is pretty advanced those areas

00:23:09,960 --> 00:23:14,399
I'm having a fancy system for deciding

00:23:12,119 --> 00:23:15,929
the best way to lower puna construction

00:23:14,399 --> 00:23:17,429
or to tile

00:23:15,929 --> 00:23:19,350
ACEF instructions with with machine out

00:23:17,429 --> 00:23:20,789
codes that's an area that we're hoping

00:23:19,350 --> 00:23:22,350
to get into in the future that we don't

00:23:20,789 --> 00:23:25,889
do yet so I don't have a lot to say

00:23:22,350 --> 00:23:27,330
about again one of things that happens

00:23:25,889 --> 00:23:29,549
kind of in any compiler whenever you

00:23:27,330 --> 00:23:31,019
lower whenever you go from any ir to

00:23:29,549 --> 00:23:32,970
another ir that's lower level it almost

00:23:31,019 --> 00:23:35,009
always exposes my tendencies because our

00:23:32,970 --> 00:23:36,749
anomaly are typically has we don't see

00:23:35,009 --> 00:23:38,249
is that are there implicit they're kind

00:23:36,749 --> 00:23:40,230
of bound up in the operation because to

00:23:38,249 --> 00:23:41,279
make many things when you expand it into

00:23:40,230 --> 00:23:42,720
a simpler operation this those

00:23:41,279 --> 00:23:45,480
redundancies become exposed of course

00:23:42,720 --> 00:23:48,119
whatever you do that it becomes valuable

00:23:45,480 --> 00:23:50,399
to do things like GBM le cm to get rid

00:23:48,119 --> 00:23:51,869
of the dependencies GD n is just

00:23:50,399 --> 00:23:54,629
operation that looks for the same

00:23:51,869 --> 00:23:55,889
expression that carry multiple times and

00:23:54,629 --> 00:23:57,119
instead of competing multiple times we

00:23:55,889 --> 00:23:59,970
just computed once and hold value in

00:23:57,119 --> 00:24:01,320
register la cm is conceptually the same

00:23:59,970 --> 00:24:01,889
thing except that it works across smooth

00:24:01,320 --> 00:24:03,539
puppies

00:24:01,889 --> 00:24:05,220
so if you're competing the same value

00:24:03,539 --> 00:24:06,600
every iteration of a loop you can

00:24:05,220 --> 00:24:07,889
compete at once outside of a loop and

00:24:06,600 --> 00:24:09,840
just reuse that value of the register of

00:24:07,889 --> 00:24:12,299
iterations loop so these are ten things

00:24:09,840 --> 00:24:14,539
that they come exposed after lowering

00:24:12,299 --> 00:24:16,799
then code all this is the same theory of

00:24:14,539 --> 00:24:17,570
after lowering ports the operations

00:24:16,799 --> 00:24:19,499
become unneeded

00:24:17,570 --> 00:24:20,390
and you can delay those parts that are

00:24:19,499 --> 00:24:23,210
mutant

00:24:20,390 --> 00:24:25,880
can I ask a question about this what are

00:24:23,210 --> 00:24:29,420
you lowering to lowering to the actual

00:24:25,880 --> 00:24:37,429
target assembly so we're actually

00:24:29,420 --> 00:24:39,320
lowering to is maybe we keep our state I

00:24:37,429 --> 00:24:43,100
are but we canít eight the instructions

00:24:39,320 --> 00:24:44,660
with a machine opcode encoding so we

00:24:43,100 --> 00:24:47,179
have that I add instruction which is

00:24:44,660 --> 00:24:49,220
just the in you know in the middle of a

00:24:47,179 --> 00:24:51,320
lie are it just appear I add you know

00:24:49,220 --> 00:24:55,130
it's your add just to a brands doesn't

00:24:51,320 --> 00:24:56,330
add it all to the same type and then we

00:24:55,130 --> 00:24:57,980
can do is we can take that same

00:24:56,330 --> 00:24:59,090
instruction without changing it and we

00:24:57,980 --> 00:25:00,590
do so sign it say like look it's

00:24:59,090 --> 00:25:02,179
actually this instruction happens to

00:25:00,590 --> 00:25:04,850
correspond directly to a thing that x86

00:25:02,179 --> 00:25:06,169
can do and so we just give it encoding

00:25:04,850 --> 00:25:07,640
and say that here's the use the FCS

00:25:06,169 --> 00:25:11,720
exact code which does what this does I

00:25:07,640 --> 00:25:13,669
see and so this jvn or whatever these

00:25:11,720 --> 00:25:16,730
these optimizations they would basically

00:25:13,669 --> 00:25:18,260
be applied on this encodings it's right

00:25:16,730 --> 00:25:19,400
so they might produce a smaller set of

00:25:18,260 --> 00:25:21,620
instructions than would otherwise be

00:25:19,400 --> 00:25:23,150
necessary because you know that it's

00:25:21,620 --> 00:25:25,490
dominated by the value is available

00:25:23,150 --> 00:25:26,990
somewhere else or whatever yeah exactly

00:25:25,490 --> 00:25:29,090
so they can actually ignore the encoding

00:25:26,990 --> 00:25:30,080
this for the most part when they're when

00:25:29,090 --> 00:25:32,030
they're actually driving instructions

00:25:30,080 --> 00:25:33,380
they need to be careful but when you're

00:25:32,030 --> 00:25:36,919
trying to find like is this expression

00:25:33,380 --> 00:25:40,700
you know congruence to use the term to

00:25:36,919 --> 00:25:42,140
an earlier expression that the opcode

00:25:40,700 --> 00:25:43,070
doesn't know the gene encoding doesn't

00:25:42,140 --> 00:25:45,020
come into it they can actually just look

00:25:43,070 --> 00:25:46,790
good though that IR level opcode which

00:25:45,020 --> 00:25:49,850
is just like IGAD and then sort of hide

00:25:46,790 --> 00:25:51,350
the block quotes totally decide okay

00:25:49,850 --> 00:25:53,600
this is this is the same in my hash map

00:25:51,350 --> 00:25:55,130
this maps the same thing and so I can I

00:25:53,600 --> 00:25:57,020
can tell you this one and the matter of

00:25:55,130 --> 00:26:00,049
just do the rewrite so you're doing the

00:25:57,020 --> 00:26:01,160
optimization at the level of Creighton

00:26:00,049 --> 00:26:04,250
if they are not at a level of the

00:26:01,160 --> 00:26:05,440
instructors selective instructions it's

00:26:04,250 --> 00:26:08,059
sort of both

00:26:05,440 --> 00:26:09,559
Queen if they are is at that point

00:26:08,059 --> 00:26:11,330
lowered to flow below stalk instructions

00:26:09,559 --> 00:26:13,340
we use the queen of their instructions

00:26:11,330 --> 00:26:15,080
and those instructions are annotated

00:26:13,340 --> 00:26:16,669
with the machine

00:26:15,080 --> 00:26:21,740
here's a cookie that says how to encode

00:26:16,669 --> 00:26:23,720
it when it comes on Arbor okay I guess

00:26:21,740 --> 00:26:25,639
what I'm trying to understand is like

00:26:23,720 --> 00:26:28,309
do you need to know the result of

00:26:25,639 --> 00:26:31,700
lowering to know that you can do the

00:26:28,309 --> 00:26:32,809
optimization become for gdn and ICM you

00:26:31,700 --> 00:26:35,269
don't need to know that they actually

00:26:32,809 --> 00:26:36,860
work we don't currently run them before

00:26:35,269 --> 00:26:43,519
lowering but you could and it would work

00:26:36,860 --> 00:26:45,019
maybe top right register on kitchen I

00:26:43,519 --> 00:26:46,269
don't know what to say about that here

00:26:45,019 --> 00:26:49,879
that's kind of a bigger topic this

00:26:46,269 --> 00:26:51,799
finish talk but we do SSA based

00:26:49,879 --> 00:26:54,070
education sweeper your cousin say for

00:26:51,799 --> 00:26:57,429
all the way through its kind of this

00:26:54,070 --> 00:27:01,580
using the sebastian hack technique of

00:26:57,429 --> 00:27:04,789
doing spilling first to make sure that

00:27:01,580 --> 00:27:07,519
your SSA graph can be allocated that

00:27:04,789 --> 00:27:08,899
machine and then we can observe the the

00:27:07,519 --> 00:27:11,240
basic of the page investing vegetation

00:27:08,899 --> 00:27:12,860
is that an SSA graph the interference

00:27:11,240 --> 00:27:14,960
graph for is a chordal graph and you can

00:27:12,860 --> 00:27:17,090
color it in linear time so in theory

00:27:14,960 --> 00:27:18,649
it's very fast but in practice what

00:27:17,090 --> 00:27:20,330
we've really done is we've split a hard

00:27:18,649 --> 00:27:21,980
problem Bridgette a patient into two

00:27:20,330 --> 00:27:24,529
hands one of them which we call next

00:27:21,980 --> 00:27:25,879
occasion becomes the easy part room and

00:27:24,529 --> 00:27:26,990
then the hard problem gets put into the

00:27:25,879 --> 00:27:28,970
first half which is just one problem

00:27:26,990 --> 00:27:30,350
pursuit of it we can we can say Li Mei -

00:27:28,970 --> 00:27:32,750
occasion easy by splitting out the hard

00:27:30,350 --> 00:27:33,620
part into us have a problem it's for

00:27:32,750 --> 00:27:35,870
this little trick that come other

00:27:33,620 --> 00:27:37,850
writers like to do and so so it ends up

00:27:35,870 --> 00:27:39,230
the original occasion is is actually not

00:27:37,850 --> 00:27:40,460
as fast as we would hope it to be right

00:27:39,230 --> 00:27:42,799
now and so that's actually an area we

00:27:40,460 --> 00:27:45,710
need to overcome but again that's kind

00:27:42,799 --> 00:27:49,429
of a big topic I'm gonna stick to more

00:27:45,710 --> 00:27:51,889
high-level stuff in this talk that's

00:27:49,429 --> 00:27:53,840
done the codec C is ready to go once we

00:27:51,889 --> 00:27:55,639
have registers that's enough for us to

00:27:53,840 --> 00:27:57,110
encode which instructions the cookie

00:27:55,639 --> 00:27:59,210
that says what what we should up good is

00:27:57,110 --> 00:28:00,889
gonna use plus you know what my truth is

00:27:59,210 --> 00:28:03,230
can use also once let's stack slots in

00:28:00,889 --> 00:28:06,049
these beats so let's fill anything and

00:28:03,230 --> 00:28:07,129
now we can put up machine code but at

00:28:06,049 --> 00:28:09,289
this point we can also do the coding

00:28:07,129 --> 00:28:10,789
operations once we know how big the

00:28:09,289 --> 00:28:13,850
instructions are that's the time we can

00:28:10,789 --> 00:28:16,669
do things like branch

00:28:13,850 --> 00:28:18,110
so if example x86 has branch invidious

00:28:16,669 --> 00:28:20,870
as a branch there's an 8-bit immediate

00:28:18,110 --> 00:28:23,179
and French as the 30 DB DB yet depending

00:28:20,870 --> 00:28:24,470
on how far the brush needs to go you can

00:28:23,179 --> 00:28:27,049
do the smaller we get more bigger

00:28:24,470 --> 00:28:27,980
immediate now once we know how big the

00:28:27,049 --> 00:28:29,360
actual file on coding wealthiest

00:28:27,980 --> 00:28:30,759
ructions are we know how far part of it

00:28:29,360 --> 00:28:32,929
is and we can pick the actual brush

00:28:30,759 --> 00:28:34,659
target so we do sort of this final class

00:28:32,929 --> 00:28:37,100
of the encoding operations at the end

00:28:34,659 --> 00:28:39,799
and that's basically it so that's

00:28:37,100 --> 00:28:42,320
the rough ture of like major cool of all

00:28:39,799 --> 00:28:44,330
collisions I should also mention that

00:28:42,320 --> 00:28:45,559
like one of the reasons why cogeneration

00:28:44,330 --> 00:28:47,780
can be this simple

00:28:45,559 --> 00:28:49,940
is that modern hardware and especially

00:28:47,780 --> 00:28:52,610
x86 chips but also high-end

00:28:49,940 --> 00:28:54,740
arm types these days does a lot of stuff

00:28:52,610 --> 00:28:56,059
that compilers otherwise used to think

00:28:54,740 --> 00:28:58,700
it was their job like in charge of

00:28:56,059 --> 00:29:00,620
scheduling is something we do e2a first

00:28:58,700 --> 00:29:01,910
fluctuation don't have to work but there

00:29:00,620 --> 00:29:03,309
still will be a place for it and we may

00:29:01,910 --> 00:29:05,630
actually look at doing it someday but

00:29:03,309 --> 00:29:07,010
but for a while you can basically just

00:29:05,630 --> 00:29:14,450
rely on the hardware to schedule for you

00:29:07,010 --> 00:29:16,730
it has a pretty good job so that's what

00:29:14,450 --> 00:29:17,990
we're doing today I also wanted to talk

00:29:16,730 --> 00:29:20,830
weekly people like looking forward and

00:29:17,990 --> 00:29:22,940
high level nations we do in the future

00:29:20,830 --> 00:29:24,320
this is kind of big topic and we don't

00:29:22,940 --> 00:29:26,150
have live plants here but we do have

00:29:24,320 --> 00:29:28,580
some some ideas for what should I think

00:29:26,150 --> 00:29:30,440
that you take the very first thing we

00:29:28,580 --> 00:29:32,120
get you need figured out sort of the

00:29:30,440 --> 00:29:34,640
frame upon which a lot of stuff will be

00:29:32,120 --> 00:29:35,780
built easy in lighting in lighting you

00:29:34,640 --> 00:29:37,270
can either think of it as some people

00:29:35,780 --> 00:29:39,230
call it the mother in wild malposition

00:29:37,270 --> 00:29:41,720
some people call it the poor man's

00:29:39,230 --> 00:29:42,950
interprocedural analysis but in lighting

00:29:41,720 --> 00:29:44,539
really is the thing that makes it

00:29:42,950 --> 00:29:46,370
possible to do a lot of Opposition in a

00:29:44,539 --> 00:29:47,390
language like rust where are so many

00:29:46,370 --> 00:29:48,620
obstructions are going to be this

00:29:47,390 --> 00:29:53,780
function calls that are expected to be

00:29:48,620 --> 00:29:55,280
clapped down and too small in 1970 need

00:29:53,780 --> 00:29:57,409
to figure the inviting story I mentioned

00:29:55,280 --> 00:29:59,090
their previous the coordinator is

00:29:57,409 --> 00:30:00,350
organized to just think about 100 a time

00:29:59,090 --> 00:30:02,780
so it actually isn't very well

00:30:00,350 --> 00:30:04,520
positioned to be aligning and I expect

00:30:02,780 --> 00:30:07,700
to do a mid-level pfizer we would have

00:30:04,520 --> 00:30:10,370
to add other layer between we currently

00:30:07,700 --> 00:30:12,380
think of is rust and crane efforts that

00:30:10,370 --> 00:30:14,330
would add the ability to think about

00:30:12,380 --> 00:30:17,900
multiple Funky's at a time and people to

00:30:14,330 --> 00:30:19,220
inline one into another so many

00:30:17,900 --> 00:30:20,600
Lighting's really important of course

00:30:19,220 --> 00:30:22,000
what to do in mining then then we're

00:30:20,600 --> 00:30:24,740
back to our same old story again

00:30:22,000 --> 00:30:26,000
eliminate redundancies of course at the

00:30:24,740 --> 00:30:27,530
middle optimizer this is extended to

00:30:26,000 --> 00:30:30,860
include limiting weekends between loads

00:30:27,530 --> 00:30:32,510
of stores food is really important we

00:30:30,860 --> 00:30:33,950
also think about again think what

00:30:32,510 --> 00:30:35,780
eliminating indents is between the loop

00:30:33,950 --> 00:30:36,380
iterations and may also extend that to

00:30:35,780 --> 00:30:39,289
Lowe's and stores

00:30:36,380 --> 00:30:41,000
Siddalee you know hosting loads out of

00:30:39,289 --> 00:30:42,380
loops siccing stores are loose and

00:30:41,000 --> 00:30:46,549
promoting loads of stories and loops

00:30:42,380 --> 00:30:48,470
into registers and the other sort of big

00:30:46,549 --> 00:30:50,130
high level tasks that the middle of

00:30:48,470 --> 00:30:52,800
pleasure to do is user

00:30:50,130 --> 00:30:54,480
use deeper instructions in us that's

00:30:52,800 --> 00:30:55,560
constant folding but I also sort of move

00:30:54,480 --> 00:30:56,970
in that category algebraic

00:30:55,560 --> 00:30:59,130
simplifications just like you know

00:30:56,970 --> 00:31:02,610
multiply is more expensive a shift so

00:30:59,130 --> 00:31:04,500
convert mobilizing the shifts also more

00:31:02,610 --> 00:31:05,970
complex stainless but also great

00:31:04,500 --> 00:31:07,230
operations but if you have a branch you

00:31:05,970 --> 00:31:10,140
can prove the condition is constant you

00:31:07,230 --> 00:31:15,120
can fold that away and result in more

00:31:10,140 --> 00:31:16,320
locations and so most of these things we

00:31:15,120 --> 00:31:18,930
don't need a lot of help in terms of

00:31:16,320 --> 00:31:20,310
like what can work in people look in

00:31:18,930 --> 00:31:22,770
front ends people producing my are you

00:31:20,310 --> 00:31:24,960
do for us aligning will need help to

00:31:22,770 --> 00:31:26,370
figure out how can we organize the

00:31:24,960 --> 00:31:27,930
compiler to manage local function than

00:31:26,370 --> 00:31:32,190
just in terms of the data structure and

00:31:27,930 --> 00:31:33,150
managing memory inside the compiler but

00:31:32,190 --> 00:31:34,290
the main thing what we need we really

00:31:33,150 --> 00:31:36,000
care about when we look here but what

00:31:34,290 --> 00:31:39,450
the fund that telling us is memory

00:31:36,000 --> 00:31:40,470
instructions so those are stores it may

00:31:39,450 --> 00:31:41,220
be we done see between them rate

00:31:40,470 --> 00:31:44,040
vibrations

00:31:41,220 --> 00:31:45,870
I guess I've gotta have this slide here

00:31:44,040 --> 00:31:47,880
so in lighting one of the big things the

00:31:45,870 --> 00:31:48,930
Eleni is also heuristics and so that'll

00:31:47,880 --> 00:31:50,280
be an itching question going forward

00:31:48,930 --> 00:31:53,220
it's when you decide to put you in line

00:31:50,280 --> 00:31:55,140
and when it might be the case right at

00:31:53,220 --> 00:31:58,800
least for rust that we could do the in

00:31:55,140 --> 00:32:00,960
lining before you we even reach you yeah

00:31:58,800 --> 00:32:03,480
and actually I suspect that we might end

00:32:00,960 --> 00:32:05,640
up with with both it's kind of one of

00:32:03,480 --> 00:32:08,130
the games so certainly with rusts you

00:32:05,640 --> 00:32:11,190
have so many abstractions so many small

00:32:08,130 --> 00:32:13,260
functions they're just essentially

00:32:11,190 --> 00:32:18,000
syntax sugar for reminding or

00:32:13,260 --> 00:32:19,260
instruction writing into place it almost

00:32:18,000 --> 00:32:20,580
becomes a property that language and you

00:32:19,260 --> 00:32:21,870
almost can think about in terms of like

00:32:20,580 --> 00:32:23,910
the front end should just be letting you

00:32:21,870 --> 00:32:25,290
see this because you like you never ever

00:32:23,910 --> 00:32:27,390
want to have this code without having it

00:32:25,290 --> 00:32:30,060
be in mind yeah maybe even in debug mode

00:32:27,390 --> 00:32:31,860
funny and I'm those things always and

00:32:30,060 --> 00:32:32,760
that's that's a different set of

00:32:31,860 --> 00:32:34,620
heuristics

00:32:32,760 --> 00:32:37,140
those those obstruction levels that are

00:32:34,620 --> 00:32:38,160
conceptually just like user rights those

00:32:37,140 --> 00:32:39,690
with the expectation that will always be

00:32:38,160 --> 00:32:42,060
in mind is kind of a different level

00:32:39,690 --> 00:32:43,200
aligning them what sometimes people call

00:32:42,060 --> 00:32:45,090
back in the aligning which is sort of

00:32:43,200 --> 00:32:46,140
more focused on okay now I'm gonna try

00:32:45,090 --> 00:32:47,940
to make a heuristic they're gonna try to

00:32:46,140 --> 00:32:49,140
balance code size versus performance so

00:32:47,940 --> 00:32:52,050
I try to make a clever decision about

00:32:49,140 --> 00:32:53,610
you know if I inline this are the

00:32:52,050 --> 00:32:56,970
arguments constants that could be folded

00:32:53,610 --> 00:32:58,290
away if I in the inline body or is this

00:32:56,970 --> 00:32:59,130
inside of a hot loop these kind of

00:32:58,290 --> 00:33:00,660
questions

00:32:59,130 --> 00:33:03,270
feels like a different set of heuristics

00:33:00,660 --> 00:33:04,169
so I can see a place where rushed at the

00:33:03,270 --> 00:33:05,489
mere level in lines

00:33:04,169 --> 00:33:06,509
the first category of things of just

00:33:05,489 --> 00:33:08,789
like I'm doing the things that I

00:33:06,509 --> 00:33:11,759
considered the instructions that should

00:33:08,789 --> 00:33:13,950
always be in mind and the second level

00:33:11,759 --> 00:33:15,149
is now I'm gonna try to like think about

00:33:13,950 --> 00:33:17,220
the Machine of line and I think about no

00:33:15,149 --> 00:33:18,899
I think what my cache locality and I

00:33:17,220 --> 00:33:20,369
think what those kind things and make a

00:33:18,899 --> 00:33:22,379
semi intelligent decision about whether

00:33:20,369 --> 00:33:24,480
it's worth it in mind at that level

00:33:22,379 --> 00:33:28,220
might be just be a separate liner at

00:33:24,480 --> 00:33:34,769
some weight that's the interesting

00:33:28,220 --> 00:33:36,330
trade-off I sometimes talk about the way

00:33:34,769 --> 00:33:37,799
for elevators water by compilers we've

00:33:36,330 --> 00:33:40,830
got about a C code the way would look

00:33:37,799 --> 00:33:42,960
like if a programmer from the 70s wrote

00:33:40,830 --> 00:33:44,850
C code and the way programmers in the

00:33:42,960 --> 00:33:46,859
70s write C code is like when they have

00:33:44,850 --> 00:33:48,029
things they want in line they don't

00:33:46,859 --> 00:33:49,679
write functions they write about goes

00:33:48,029 --> 00:33:52,710
because that's how you do mind things in

00:33:49,679 --> 00:33:54,929
70s writing so that kind of code turns

00:33:52,710 --> 00:33:57,570
out to be kind of a coincidence but also

00:33:54,929 --> 00:33:59,070
kind of a result of the way C worked in

00:33:57,570 --> 00:34:00,210
that era was kind of this low level sign

00:33:59,070 --> 00:34:02,669
language for the program was kind of

00:34:00,210 --> 00:34:05,429
thinking in terms of how should I lay

00:34:02,669 --> 00:34:07,320
out the code in a way that will compile

00:34:05,429 --> 00:34:09,690
at a good code and so we kind of watched

00:34:07,320 --> 00:34:11,099
front-ends to produce for us that kind

00:34:09,690 --> 00:34:13,319
of code that's what things look like we

00:34:11,099 --> 00:34:14,399
want things to have like if a smart

00:34:13,319 --> 00:34:16,619
program in seven days would have written

00:34:14,399 --> 00:34:18,960
a macro for this we want the front end

00:34:16,619 --> 00:34:20,190
of the invited for us ideally so this

00:34:18,960 --> 00:34:21,659
kind of our that's kind of our like

00:34:20,190 --> 00:34:22,679
ideal picture like you know can give us

00:34:21,659 --> 00:34:23,520
the best possible code that's what it

00:34:22,679 --> 00:34:26,280
would look like is the sort of

00:34:23,520 --> 00:34:27,720
medium-sized functions not too big but

00:34:26,280 --> 00:34:32,099
not small functions because those of

00:34:27,720 --> 00:34:33,450
kaliesha that in mind and and not only

00:34:32,099 --> 00:34:35,970
simple code that's not doing a lot of

00:34:33,450 --> 00:34:37,409
abstract things and that's really what

00:34:35,970 --> 00:34:40,559
can operate one so if the front end can

00:34:37,409 --> 00:34:43,290
collapse away the things that would have

00:34:40,559 --> 00:34:46,020
been macros you know in earlier more

00:34:43,290 --> 00:34:47,399
primitive air I that's made for us if

00:34:46,020 --> 00:34:49,589
the front end doesn't do it for us we'll

00:34:47,399 --> 00:34:52,309
probably end up doing ourselves but I

00:34:49,589 --> 00:34:54,030
think actually one of my ideas is that

00:34:52,309 --> 00:34:56,069
front ends actually have a better idea

00:34:54,030 --> 00:34:58,290
of what you can think of as a

00:34:56,069 --> 00:34:59,940
abstraction versus there's a pure

00:34:58,290 --> 00:35:01,319
heuristic approach of just like looking

00:34:59,940 --> 00:35:03,329
at code size and looking kind of guess

00:35:01,319 --> 00:35:07,920
about what cuts of folding and what

00:35:03,329 --> 00:35:09,680
could be possible so wouldn't be

00:35:07,920 --> 00:35:12,950
undermining of looking at memory ones is

00:35:09,680 --> 00:35:14,970
this is one of one of the big big tasks

00:35:12,950 --> 00:35:17,430
it's such a big task we split up into

00:35:14,970 --> 00:35:18,040
many categories because EDM called we

00:35:17,430 --> 00:35:19,870
don't know

00:35:18,040 --> 00:35:22,270
we call it the ACM we call it dead store

00:35:19,870 --> 00:35:24,780
elevation start look forwarding s are

00:35:22,270 --> 00:35:27,010
away scaler placements you know it's

00:35:24,780 --> 00:35:28,210
registered promotion the only basically

00:35:27,010 --> 00:35:30,190
means of an essentially names for the

00:35:28,210 --> 00:35:31,720
same thing of trying to get rid of

00:35:30,190 --> 00:35:32,680
redone this one's in stores tried

00:35:31,720 --> 00:35:34,690
destroyed instead of going through

00:35:32,680 --> 00:35:36,880
memory can be hold values and registers

00:35:34,690 --> 00:35:38,740
more and can we just avoid no doing the

00:35:36,880 --> 00:35:43,000
same local times before we doing stores

00:35:38,740 --> 00:35:44,680
we don't need and so even though you

00:35:43,000 --> 00:35:46,060
look like compiler like LV I'm not miser

00:35:44,680 --> 00:35:47,470
has a lot different passes

00:35:46,060 --> 00:35:49,240
maybe the passes are actually doing the

00:35:47,470 --> 00:35:50,410
same thing like this probably six or

00:35:49,240 --> 00:35:52,390
seven passes that are basically all just

00:35:50,410 --> 00:36:00,250
doing the same version of GBM this

00:35:52,390 --> 00:36:01,270
specialized forms of it looking beyond

00:36:00,250 --> 00:36:02,800
dad if you want talk about like one of

00:36:01,270 --> 00:36:04,420
the other bigger things optimizers what

00:36:02,800 --> 00:36:05,500
to do if you want to get fancy with

00:36:04,420 --> 00:36:08,820
loops there's a lot of different things

00:36:05,500 --> 00:36:10,930
fission-fusion interchange factorization

00:36:08,820 --> 00:36:12,850
we can split this into two halves

00:36:10,930 --> 00:36:14,350
there's the transform half which is of

00:36:12,850 --> 00:36:16,480
the mechanics of like taking a loop and

00:36:14,350 --> 00:36:18,250
doing some some advanced reservations to

00:36:16,480 --> 00:36:20,290
it but the first half of that is the

00:36:18,250 --> 00:36:22,120
analysis the analyze loop and say now

00:36:20,290 --> 00:36:24,100
first of all what is safe to do in this

00:36:22,120 --> 00:36:28,900
loop is it possible to to do gonna

00:36:24,100 --> 00:36:31,840
change is it possible to do other kind

00:36:28,900 --> 00:36:33,790
of operations it would change the order

00:36:31,840 --> 00:36:35,020
the things would happen in and so

00:36:33,790 --> 00:36:37,510
there's also kind of boils down to a

00:36:35,020 --> 00:36:41,740
memory dependence question of can I

00:36:37,510 --> 00:36:43,000
reorder to operations and so if you

00:36:41,740 --> 00:36:45,690
really wanna thought to like what

00:36:43,000 --> 00:36:47,800
question is the one you want to ask what

00:36:45,690 --> 00:36:51,670
are the insights that I think we can

00:36:47,800 --> 00:36:53,170
take is it's difficult to think in terms

00:36:51,670 --> 00:36:55,000
of alias tells us in terms of think of

00:36:53,170 --> 00:36:57,400
can I prove these two pointers are the

00:36:55,000 --> 00:37:00,280
same or different and that actually ends

00:36:57,400 --> 00:37:01,330
up being more of a use a means other

00:37:00,280 --> 00:37:03,700
than end the question that we really

00:37:01,330 --> 00:37:06,490
want to ask is if I have a loader store

00:37:03,700 --> 00:37:10,240
or a call can I move past some other

00:37:06,490 --> 00:37:12,610
load or store and so it really becomes

00:37:10,240 --> 00:37:14,320
the question isn't is this load loading

00:37:12,610 --> 00:37:16,150
from the same address as that store it's

00:37:14,320 --> 00:37:19,810
is a safe to move this load across that

00:37:16,150 --> 00:37:21,970
store and so that's actually another

00:37:19,810 --> 00:37:23,860
reason why we think that Twitter types

00:37:21,970 --> 00:37:25,750
in the IR aren't the important part we

00:37:23,860 --> 00:37:27,730
can get a front-end that can provide us

00:37:25,750 --> 00:37:29,110
with high level memory dependence

00:37:27,730 --> 00:37:30,910
information about you know what storage

00:37:29,110 --> 00:37:32,839
find out what loads and what loads by

00:37:30,910 --> 00:37:34,619
the store and so on

00:37:32,839 --> 00:37:37,140
then we think we can get away without

00:37:34,619 --> 00:37:39,029
having to do pointer analysis which is

00:37:37,140 --> 00:37:40,499
really attractive because pointed also

00:37:39,029 --> 00:37:42,509
some compilers is really complicated and

00:37:40,499 --> 00:37:48,029
really arrow heads they get caught up

00:37:42,509 --> 00:37:49,289
and fail in a lot of ways yeah in sort

00:37:48,029 --> 00:37:50,400
of a very confusing way because you end

00:37:49,289 --> 00:37:53,069
up having to have these very complex

00:37:50,400 --> 00:37:54,809
solvers that can't explain how they came

00:37:53,069 --> 00:37:56,249
up with the answers they came up with so

00:37:54,809 --> 00:37:57,119
if we can have a system like rust which

00:37:56,249 --> 00:38:00,839
is really attractive

00:37:57,119 --> 00:38:02,309
I feel like you're doing that trick like

00:38:00,839 --> 00:38:04,289
register allocation trick you like

00:38:02,309 --> 00:38:06,720
there's this hard problem what if we

00:38:04,289 --> 00:38:08,160
make you tell us the answer then it

00:38:06,720 --> 00:38:09,539
would look it's a hard problem but I

00:38:08,160 --> 00:38:12,690
agree we probably can't supply the

00:38:09,539 --> 00:38:14,279
information it's the hard problem is any

00:38:12,690 --> 00:38:15,869
others I'll say is you seen throw away

00:38:14,279 --> 00:38:17,730
or you start with a situation where you

00:38:15,869 --> 00:38:19,589
have all these pointers you know nothing

00:38:17,730 --> 00:38:21,029
you basically a sort of reverse engineer

00:38:19,589 --> 00:38:22,769
or the quite ablation sips from nothing

00:38:21,029 --> 00:38:23,759
you could have this system of you know

00:38:22,769 --> 00:38:25,619
like look at all the assignments of

00:38:23,759 --> 00:38:31,049
player transfers and put them all in a

00:38:25,619 --> 00:38:32,339
big country system and solve it and in

00:38:31,049 --> 00:38:34,230
language like class that has for example

00:38:32,339 --> 00:38:35,970
an immutable reference you just know in

00:38:34,230 --> 00:38:39,779
French that that loads and that think

00:38:35,970 --> 00:38:40,980
are all gonna be the same value and so

00:38:39,779 --> 00:38:42,569
if we can represent that information we

00:38:40,980 --> 00:38:44,489
just remember that instead of throwing

00:38:42,569 --> 00:38:45,450
it away or instead of having the purpose

00:38:44,489 --> 00:38:47,339
of medicines like some kind of

00:38:45,450 --> 00:38:49,200
complicated metadata we just remember

00:38:47,339 --> 00:38:51,960
this in a first-class way you know not

00:38:49,200 --> 00:38:53,009
matter I R then it could make all the

00:38:51,960 --> 00:38:55,650
things were going to do all the

00:38:53,009 --> 00:38:57,390
operations and it's a large part of what

00:38:55,650 --> 00:38:59,309
my visors do is just basically this kind

00:38:57,390 --> 00:39:01,619
of set of things of know can I move

00:38:59,309 --> 00:39:03,450
these stores to pass these other stores

00:39:01,619 --> 00:39:06,630
it will be flowed across these stores or

00:39:03,450 --> 00:39:07,680
calls yeah that would basically give us

00:39:06,630 --> 00:39:09,690
a lot of stuff for free which is way too

00:39:07,680 --> 00:39:12,900
talkative it also means you're out of

00:39:09,690 --> 00:39:14,489
the business of like C's type based

00:39:12,900 --> 00:39:17,880
analysis you know yeah

00:39:14,489 --> 00:39:20,789
IPC less analysis and C is notoriously

00:39:17,880 --> 00:39:21,930
problematic for a lot of reasons and it

00:39:20,789 --> 00:39:23,369
gets us out of the business of trying to

00:39:21,930 --> 00:39:25,019
mean if you look at LVM example there's

00:39:23,369 --> 00:39:27,059
this question of like they're trying to

00:39:25,019 --> 00:39:29,369
do memory semantics and it's very

00:39:27,059 --> 00:39:31,440
difficult because the rules for what

00:39:29,369 --> 00:39:32,970
even just trying to describe what GE n

00:39:31,440 --> 00:39:35,099
is doing today is is actually quite

00:39:32,970 --> 00:39:37,710
complicated because they kind of have

00:39:35,099 --> 00:39:39,509
always like discovered rules about no

00:39:37,710 --> 00:39:41,539
this seems to work across a large body x

00:39:39,509 --> 00:39:43,920
equals code piece so we'll just do this

00:39:41,539 --> 00:39:44,470
and then try to sort of extract a formal

00:39:43,920 --> 00:39:45,849
set of rules

00:39:44,470 --> 00:39:47,020
like what is it actually doing is

00:39:45,849 --> 00:39:48,609
they're very difficult to practice and

00:39:47,020 --> 00:39:49,240
no one actually knows you know what the

00:39:48,609 --> 00:39:50,920
rules are

00:39:49,240 --> 00:39:52,720
whereas if we can express a system in

00:39:50,920 --> 00:39:55,950
terms of dependency is basically saying

00:39:52,720 --> 00:39:58,119
no I don't know anything about pointers

00:39:55,950 --> 00:39:59,890
but if you still be that this load can't

00:39:58,119 --> 00:40:02,020
cross that store I can represent a

00:39:59,890 --> 00:40:03,190
dependency in the punch graph and just

00:40:02,020 --> 00:40:06,970
preserve that property and it's actually

00:40:03,190 --> 00:40:07,900
really easy to reason about I think it's

00:40:06,970 --> 00:40:10,020
also interesting to bring up another

00:40:07,900 --> 00:40:13,690
example of the see restrict pointer

00:40:10,020 --> 00:40:17,440
feature see as this keyword called

00:40:13,690 --> 00:40:18,730
restrict which is kind of confusing but

00:40:17,440 --> 00:40:20,560
one of the one of the key insights that

00:40:18,730 --> 00:40:25,590
I think they had we think it's a really

00:40:20,560 --> 00:40:29,230
good insight was that you can't discuss

00:40:25,590 --> 00:40:31,359
or the chain of repetition matters look

00:40:29,230 --> 00:40:32,890
how you get a pointer matters is if we

00:40:31,359 --> 00:40:34,359
can't discuss all the different possible

00:40:32,890 --> 00:40:35,980
ways that you can get from one pointer

00:40:34,359 --> 00:40:37,180
to computing to another point about you

00:40:35,980 --> 00:40:39,070
there's there's just too many ways for

00:40:37,180 --> 00:40:40,150
players to flip the programs so they

00:40:39,070 --> 00:40:41,619
kind of have to sort of cut that out of

00:40:40,150 --> 00:40:43,570
it basically say if there's any possible

00:40:41,619 --> 00:40:45,820
path that this point could be dried from

00:40:43,570 --> 00:40:47,590
another pointer then that's sufficient

00:40:45,820 --> 00:40:50,290
to sort of satisfy the Reacher qualified

00:40:47,590 --> 00:40:51,609
pointer concept I think what we can do

00:40:50,290 --> 00:40:52,869
here is actually kind of take another

00:40:51,609 --> 00:40:54,490
step further and say like let's get away

00:40:52,869 --> 00:40:57,250
from pointer values altogether I not

00:40:54,490 --> 00:40:58,450
care about Twitter equality or printer

00:40:57,250 --> 00:41:00,849
inequality because those actually aren't

00:40:58,450 --> 00:41:02,080
the key things Twitter's a load of

00:41:00,849 --> 00:41:02,859
Sorkin Elios even if they had if

00:41:02,080 --> 00:41:04,300
employers because if you have a

00:41:02,859 --> 00:41:06,010
different size load from a store

00:41:04,300 --> 00:41:07,060
you still care about that dependency

00:41:06,010 --> 00:41:10,599
even though the pointers are aren't

00:41:07,060 --> 00:41:12,160
equal or if sometimes the CL + theta

00:41:10,599 --> 00:41:13,359
gets confused about whether or not she

00:41:12,160 --> 00:41:15,849
should be carrying about people who have

00:41:13,359 --> 00:41:18,040
the same memory into multiple pieces of

00:41:15,849 --> 00:41:19,690
their outer space at the same time which

00:41:18,040 --> 00:41:20,859
then has two different pointers that can

00:41:19,690 --> 00:41:21,880
have excess as a dependent each other

00:41:20,859 --> 00:41:23,950
just by having completely different

00:41:21,880 --> 00:41:26,740
addresses and so if you I don't think

00:41:23,950 --> 00:41:27,400
what those kind of things again we want

00:41:26,740 --> 00:41:28,869
to get back to thinking about

00:41:27,400 --> 00:41:32,880
dependencies and what can you move past

00:41:28,869 --> 00:41:37,390
what else and that's really the

00:41:32,880 --> 00:41:38,230
important part let's see we're getting

00:41:37,390 --> 00:41:44,560
pinged on irce

00:41:38,230 --> 00:41:45,970
no okay and so this is this goes all the

00:41:44,560 --> 00:41:48,099
way up so we also I talked before about

00:41:45,970 --> 00:41:51,310
loop optimizations kind of things of the

00:41:48,099 --> 00:41:54,490
next level high-tech thing that

00:41:51,310 --> 00:41:55,750
compilers can do memory tendencies are

00:41:54,490 --> 00:41:56,770
basically the big answer they are as far

00:41:55,750 --> 00:41:57,050
as what do you care about in terms of

00:41:56,770 --> 00:41:58,790
the house

00:41:57,050 --> 00:42:00,940
of course there's also the site of you

00:41:58,790 --> 00:42:03,050
know machine heroes Dixon and cos models

00:42:00,940 --> 00:42:05,000
and transformations but if you want to

00:42:03,050 --> 00:42:06,500
know like is it safe to vectorize this

00:42:05,000 --> 00:42:08,570
loop is it safe to cache block this loop

00:42:06,500 --> 00:42:10,310
right at what distance kind of vector is

00:42:08,570 --> 00:42:13,820
this kind of famous also turn into

00:42:10,310 --> 00:42:17,000
memory memory depends how questions you

00:42:13,820 --> 00:42:19,030
care about not just what other store

00:42:17,000 --> 00:42:20,810
instructions in they are but

00:42:19,030 --> 00:42:21,890
transforming it into the road nine one

00:42:20,810 --> 00:42:24,650
time domain and thinking about coming

00:42:21,890 --> 00:42:29,420
iterations ahead is another store that

00:42:24,650 --> 00:42:30,380
will depend I can't cross and so there's

00:42:29,420 --> 00:42:32,570
all kind of collapses in the same

00:42:30,380 --> 00:42:34,250
problem now loose of course they're

00:42:32,570 --> 00:42:35,990
they're different than the straight line

00:42:34,250 --> 00:42:37,970
code that we don't see is at one time

00:42:35,990 --> 00:42:38,930
rather than at compile time so we need

00:42:37,970 --> 00:42:39,950
different mechanisms for the Google

00:42:38,930 --> 00:42:40,970
loops but I think this is kind of the

00:42:39,950 --> 00:42:43,100
basic model that we want to think in

00:42:40,970 --> 00:42:44,720
terms of you know here's a load or a

00:42:43,100 --> 00:42:47,830
store what are them say instead of

00:42:44,720 --> 00:42:47,830
things above it that it can't cross

00:42:48,760 --> 00:42:54,920
sometimes this could be expensive to

00:42:52,730 --> 00:42:56,510
representing compilers because if you

00:42:54,920 --> 00:42:59,900
have a whole bunch of stores to

00:42:56,510 --> 00:43:01,070
everybody access is you have one load we

00:42:59,900 --> 00:43:03,590
don't want to basically say that that

00:43:01,070 --> 00:43:05,180
load has to be depending on every single

00:43:03,590 --> 00:43:06,230
store that came before it because you

00:43:05,180 --> 00:43:09,050
know you can't cut any of them they're

00:43:06,230 --> 00:43:12,260
all sort of visible and one way we have

00:43:09,050 --> 00:43:13,730
to to simplify this is to making sort of

00:43:12,260 --> 00:43:15,250
is just say that every store depends I

00:43:13,730 --> 00:43:19,310
have a previous store or has a

00:43:15,250 --> 00:43:20,570
dependency that we really care we can we

00:43:19,310 --> 00:43:22,220
can sort of look at the two stores and

00:43:20,570 --> 00:43:23,450
figure it out if we know that one who

00:43:22,220 --> 00:43:24,890
does the own sell one but in order to

00:43:23,450 --> 00:43:28,310
sort of factor of the dependencies to

00:43:24,890 --> 00:43:30,140
avoid an EM pens and dependence tree we

00:43:28,310 --> 00:43:32,360
can basically say every store gonna

00:43:30,140 --> 00:43:33,680
sterilize all the stores but then loads

00:43:32,360 --> 00:43:36,080
will all just point to the one most

00:43:33,680 --> 00:43:37,220
recent story depend on kind of a cheaper

00:43:36,080 --> 00:43:39,170
way to do it so that's actually kind of

00:43:37,220 --> 00:43:39,880
a good Celtic player we could have an

00:43:39,170 --> 00:43:43,190
immediate

00:43:39,880 --> 00:43:45,710
fast points one of one of Queen left

00:43:43,190 --> 00:43:47,510
goals is to be as well as a what I call

00:43:45,710 --> 00:43:49,100
the pretty good compiler which is a

00:43:47,510 --> 00:43:51,560
compiler that can optimize decently well

00:43:49,100 --> 00:43:54,980
with with quite fast of all times so not

00:43:51,560 --> 00:43:57,770
the highest quality performance but also

00:43:54,980 --> 00:43:59,540
fast enough that in typical builds debug

00:43:57,770 --> 00:44:00,710
girls are like you're so slow because

00:43:59,540 --> 00:44:03,020
you're not doing any inlining we're not

00:44:00,710 --> 00:44:04,220
doing enough you lining we could have

00:44:03,020 --> 00:44:05,720
kind of a middle balance where you have

00:44:04,220 --> 00:44:07,790
enough code be usable for IP today

00:44:05,720 --> 00:44:09,960
developer says enough population digadz

00:44:07,790 --> 00:44:12,120
won't for all the purposes but also

00:44:09,960 --> 00:44:13,290
fast about time to be a very volatile

00:44:12,120 --> 00:44:15,180
email so it's kind of an every you'd

00:44:13,290 --> 00:44:16,530
stuff that I see us building and this

00:44:15,180 --> 00:44:19,050
kind of a model where you basically like

00:44:16,530 --> 00:44:21,690
take all the stores in and serialize

00:44:19,050 --> 00:44:22,860
them makes it very cheap to represent

00:44:21,690 --> 00:44:32,940
this co-defendants graph because just

00:44:22,860 --> 00:44:35,850
one edge per store and promote the other

00:44:32,940 --> 00:44:37,260
talk briefly about we didn't load

00:44:35,850 --> 00:44:37,890
elation and actually this is kind of the

00:44:37,260 --> 00:44:40,830
view of doing

00:44:37,890 --> 00:44:42,060
we didn't motivation unclear there's a

00:44:40,830 --> 00:44:43,290
data structure and I actually a really

00:44:42,060 --> 00:44:45,450
really cool technique for doing this

00:44:43,290 --> 00:44:47,880
that we can use an intrical this code

00:44:45,450 --> 00:44:50,460
cache map which is basically a hash map

00:44:47,880 --> 00:44:52,260
where you have checkpoints and rewind in

00:44:50,460 --> 00:44:54,060
checkpoints so you can basically say you

00:44:52,260 --> 00:44:56,280
know take this half map put a bunch of

00:44:54,060 --> 00:44:57,960
things in it make a checkpoint now put

00:44:56,280 --> 00:44:59,250
more things in it and then decide that

00:44:57,960 --> 00:45:00,570
you're done and I'll rewind to this

00:44:59,250 --> 00:45:01,710
earlier point so then reuse that hash

00:45:00,570 --> 00:45:03,180
map going forward you can add more

00:45:01,710 --> 00:45:05,580
things and make more checkpoints and

00:45:03,180 --> 00:45:08,190
then rewind that points and that Maps up

00:45:05,580 --> 00:45:10,080
really well with a Dominator tree that's

00:45:08,190 --> 00:45:11,460
for search traversal so for walking down

00:45:10,080 --> 00:45:13,500
the Dominator tree every time I go down

00:45:11,460 --> 00:45:17,880
a level we can look ahead look at

00:45:13,500 --> 00:45:20,730
checkpoints and then we keep walking

00:45:17,880 --> 00:45:24,270
instructions in that I made a tree node

00:45:20,730 --> 00:45:25,530
editing instructions there and then when

00:45:24,270 --> 00:45:27,450
we're done we're gonna pop back up the

00:45:25,530 --> 00:45:28,410
DFS tack then we can just like rewind at

00:45:27,450 --> 00:45:29,730
that checkpoint and go down the next

00:45:28,410 --> 00:45:31,740
bunch of the DFS tree so at any given

00:45:29,730 --> 00:45:33,030
points we have a hash map which

00:45:31,740 --> 00:45:34,980
represents all the things that are

00:45:33,030 --> 00:45:36,900
dominating the particular point of

00:45:34,980 --> 00:45:38,040
you're at so this kind of scope and hash

00:45:36,900 --> 00:45:39,810
map is actually pretty easy to build

00:45:38,040 --> 00:45:43,230
there's an example of one in prenups

00:45:39,810 --> 00:45:44,670
and it's it's regionally efficient and

00:45:43,230 --> 00:45:46,860
you can do a double your trade search

00:45:44,670 --> 00:45:48,930
and this is basically enough if you have

00:45:46,860 --> 00:45:50,780
for example a trust mirror if you just

00:45:48,930 --> 00:45:53,580
want to do we done a little asian over

00:45:50,780 --> 00:45:55,290
in beautiful references if you could

00:45:53,580 --> 00:45:58,050
build animator tree you can do a let's

00:45:55,290 --> 00:45:59,070
go back map traversal overrides them you

00:45:58,050 --> 00:46:01,980
could do this pretty quickly and pretty

00:45:59,070 --> 00:46:03,060
evenly this is better I've heard some

00:46:01,980 --> 00:46:04,590
people have tossed on the idea I'm just

00:46:03,060 --> 00:46:06,240
like let's voice all the loads at the ng

00:46:04,590 --> 00:46:09,000
block or sort of to the highest off

00:46:06,240 --> 00:46:10,470
point you they can go I think doing this

00:46:09,000 --> 00:46:12,270
in terms of like let's take the loads

00:46:10,470 --> 00:46:13,980
where they are and just really limited

00:46:12,270 --> 00:46:15,840
the redundant ones is actually a little

00:46:13,980 --> 00:46:18,120
bit safer to do in terms of cobalt ion

00:46:15,840 --> 00:46:21,570
because maximally wasting loads can

00:46:18,120 --> 00:46:24,100
increase register pressure will be like

00:46:21,570 --> 00:46:26,380
leading library is the flipside of

00:46:24,100 --> 00:46:27,520
factory downloads is that we're holding

00:46:26,380 --> 00:46:29,050
things and registers which is great if

00:46:27,520 --> 00:46:30,670
you have enough I deserve able if you

00:46:29,050 --> 00:46:32,290
don't then we get enough spilling things

00:46:30,670 --> 00:46:33,700
we've done it causes us to potentially

00:46:32,290 --> 00:46:36,040
make were stored in some cases so it

00:46:33,700 --> 00:46:38,260
sort of conservative thing of don't move

00:46:36,040 --> 00:46:40,390
any loads but just delete the other ones

00:46:38,260 --> 00:46:41,890
and so a good trade-off point you can do

00:46:40,390 --> 00:46:45,370
it pretty easily with this scope at map

00:46:41,890 --> 00:46:47,770
and other key can approach now mater

00:46:45,370 --> 00:46:48,820
tree kind of approach this is also one

00:46:47,770 --> 00:46:51,370
thing and I said what this book is you

00:46:48,820 --> 00:46:52,720
can extend it through GBM so gbn also

00:46:51,370 --> 00:46:54,790
wants the same thing and once a hashmap

00:46:52,720 --> 00:46:57,820
that wants to be sort of scope / /

00:46:54,790 --> 00:46:59,080
Dominator tree traversal and so you can

00:46:57,820 --> 00:47:00,310
extend this kind of concept it is to

00:46:59,080 --> 00:47:04,660
have that and get of arbitrary

00:47:00,310 --> 00:47:07,150
expressions rust mirror doesn't have SSA

00:47:04,660 --> 00:47:10,930
form which makes the GP a little bit

00:47:07,150 --> 00:47:12,100
more complex but one of the ideas there

00:47:10,930 --> 00:47:13,840
is that you can rely on the fact that

00:47:12,100 --> 00:47:15,100
you have immutable references or unit

00:47:13,840 --> 00:47:17,170
above my bindings by default you can

00:47:15,100 --> 00:47:21,010
search meet those as I say values limit

00:47:17,170 --> 00:47:22,150
yourself to just those values you might

00:47:21,010 --> 00:47:24,820
be able to get a fair amount done you

00:47:22,150 --> 00:47:26,860
know might allow you to delete no coach

00:47:24,820 --> 00:47:28,120
have West code which might what means

00:47:26,860 --> 00:47:29,760
less where it sounds good passes to do

00:47:28,120 --> 00:47:32,320
which could good speed up contact and so

00:47:29,760 --> 00:47:32,590
it's an interesting thing to consider of

00:47:32,320 --> 00:47:34,150
course

00:47:32,590 --> 00:47:37,260
the DN isn't free you doing a lot of

00:47:34,150 --> 00:47:40,510
passion Apple games so visiting me there

00:47:37,260 --> 00:47:42,730
it's a random aside I expect for the

00:47:40,510 --> 00:47:44,440
index map crate would be really nice for

00:47:42,730 --> 00:47:47,650
implementing scoped attachments and it's

00:47:44,440 --> 00:47:49,330
also really pretty fast so it lets you

00:47:47,650 --> 00:47:53,850
kind of push things and then talk them

00:47:49,330 --> 00:47:56,950
by index if I recall though not sure um

00:47:53,850 --> 00:47:58,000
but yes I think you could do that I

00:47:56,950 --> 00:47:59,260
don't know the efficiency if you want to

00:47:58,000 --> 00:48:02,110
put a whole bunch of things at once I

00:47:59,260 --> 00:48:03,910
don't know if it's for that of hams but

00:48:02,110 --> 00:48:08,440
but but yeah so it means we're looking

00:48:03,910 --> 00:48:10,600
at regarding them as to say and not as I

00:48:08,440 --> 00:48:12,310
say I mean it seems like even without

00:48:10,600 --> 00:48:13,680
looking at how a user declared the let

00:48:12,310 --> 00:48:15,850
declaration you could simply look for

00:48:13,680 --> 00:48:17,410
kind of the final assignment or

00:48:15,850 --> 00:48:20,830
something like that like that we should

00:48:17,410 --> 00:48:22,930
there's like a large immutable span

00:48:20,830 --> 00:48:25,600
likely for most variables even those

00:48:22,930 --> 00:48:28,170
that are declared you often I think have

00:48:25,600 --> 00:48:30,220
a mutation period in that you spirit

00:48:28,170 --> 00:48:32,110
anyway yeah that's a good point

00:48:30,220 --> 00:48:33,460
and also just within a basic block it's

00:48:32,110 --> 00:48:35,170
pretty easy to just if you're doing a

00:48:33,460 --> 00:48:36,040
top-down walk the base of park it's busy

00:48:35,170 --> 00:48:38,260
you just remember the most

00:48:36,040 --> 00:48:39,910
and definitely something you've seen I

00:48:38,260 --> 00:48:41,920
think the only kids but fairly tricky is

00:48:39,910 --> 00:48:45,010
when you have a use of variable let's

00:48:41,920 --> 00:48:46,810
define you know and some other control

00:48:45,010 --> 00:48:48,520
condition basic black whatever we want

00:48:46,810 --> 00:48:50,110
to college and so you don't know exactly

00:48:48,520 --> 00:48:52,600
chef it is but everything else it's

00:48:50,110 --> 00:48:54,760
actually pretty easy to sort of keep as

00:48:52,600 --> 00:48:55,930
subsets of vessels a form on the fly so

00:48:54,760 --> 00:49:03,490
you could do a pretty good job with

00:48:55,930 --> 00:49:05,050
doing a gbn on the fly like this alright

00:49:03,490 --> 00:49:06,370
and just all the finished up here I just

00:49:05,050 --> 00:49:07,840
on to give a kind of brief status of

00:49:06,370 --> 00:49:12,130
queen of cabal system

00:49:07,840 --> 00:49:13,300
first we have our github site here cool

00:49:12,130 --> 00:49:15,910
thing that's going on the bus community

00:49:13,300 --> 00:49:17,560
of always adjusted in Buren three is

00:49:15,910 --> 00:49:19,870
working out back end for the roster

00:49:17,560 --> 00:49:21,340
Pilar infamous this is kind of built on

00:49:19,870 --> 00:49:24,190
a lot of good pieces of and kind of

00:49:21,340 --> 00:49:25,780
slowly come into place so Dennis very

00:49:24,190 --> 00:49:28,930
goo did a lot of work with us this last

00:49:25,780 --> 00:49:30,700
summer to to refactor their West

00:49:28,930 --> 00:49:32,860
back-end so that all the code that rust

00:49:30,700 --> 00:49:36,120
has for translating into LVM now goes

00:49:32,860 --> 00:49:38,530
through at rate and so this this trade

00:49:36,120 --> 00:49:39,820
now currently just has a single open

00:49:38,530 --> 00:49:40,720
agent in the treat which is the LV

00:49:39,820 --> 00:49:42,640
employed so it's basically just like

00:49:40,720 --> 00:49:45,550
making on the same alien API calls and

00:49:42,640 --> 00:49:47,530
which nickname into LVM but now we're

00:49:45,550 --> 00:49:49,170
going to do and with this with this new

00:49:47,530 --> 00:49:52,330
crew dinner is built on is to go get to

00:49:49,170 --> 00:49:53,800
just create when there's traits with

00:49:52,330 --> 00:49:56,200
Queen methods back and instead cleanups

00:49:53,800 --> 00:49:57,910
IR builder is pretty similar to ellaby

00:49:56,200 --> 00:49:58,960
MSI our builder there are some

00:49:57,910 --> 00:50:01,030
differences but it's sort of within

00:49:58,960 --> 00:50:03,070
business of generalizing these traits to

00:50:01,030 --> 00:50:04,930
to produce either LV Mir creel if they

00:50:03,070 --> 00:50:06,460
are actually really a factoring the

00:50:04,930 --> 00:50:09,400
backend because there's a lot of code in

00:50:06,460 --> 00:50:10,900
in rust for the translation from here to

00:50:09,400 --> 00:50:13,240
var this kind of where a lot of the

00:50:10,900 --> 00:50:15,010
policy happens were like lowering match

00:50:13,240 --> 00:50:17,320
statements and lowering items and all

00:50:15,010 --> 00:50:19,690
different stuff that mostly is that that

00:50:17,320 --> 00:50:21,490
don't exist in the LVM aro or clean if

00:50:19,690 --> 00:50:23,110
they are we can share all that code

00:50:21,490 --> 00:50:25,120
basically by using these traits so

00:50:23,110 --> 00:50:27,010
that's actually a pretty cool system so

00:50:25,120 --> 00:50:27,970
check it out and that's all the time

00:50:27,010 --> 00:50:31,120
that they have now are there any other

00:50:27,970 --> 00:50:33,660
questions I have a question what other

00:50:31,120 --> 00:50:37,420
uses of crane lift outside of receive

00:50:33,660 --> 00:50:39,160
are there an are anticipated yeah so

00:50:37,420 --> 00:50:41,620
some of the major ones we're using cream

00:50:39,160 --> 00:50:43,630
ifs in spider monkey to do website like

00:50:41,620 --> 00:50:44,830
evolution and that's actually that's

00:50:43,630 --> 00:50:48,220
something that's that's ongoing projects

00:50:44,830 --> 00:50:49,400
we have it in Firefox nightly if you get

00:50:48,220 --> 00:50:51,710
slightly and

00:50:49,400 --> 00:50:53,930
flag you can enable innovation forum

00:50:51,710 --> 00:50:55,280
assembly it's not very fast yet because

00:50:53,930 --> 00:50:56,900
I have more operation work to do yet but

00:50:55,280 --> 00:50:58,310
that's that's in place in the tree and I

00:50:56,900 --> 00:51:01,400
passed the test week so we're kind of

00:50:58,310 --> 00:51:03,380
moving forward there another major use

00:51:01,400 --> 00:51:05,720
of clean lift is was imagine that I'm

00:51:03,380 --> 00:51:07,130
building called buy some time and I'm

00:51:05,720 --> 00:51:08,930
building with this with the hope that

00:51:07,130 --> 00:51:10,970
we're gonna sort of broaden the scope on

00:51:08,930 --> 00:51:12,530
forum assembly genomica so who can put

00:51:10,970 --> 00:51:15,220
together a coalition of people there

00:51:12,530 --> 00:51:18,500
used to do rigging I'm with with us

00:51:15,220 --> 00:51:20,120
taking them assembly beyond the web the

00:51:18,500 --> 00:51:23,840
big focus right now is actually building

00:51:20,120 --> 00:51:25,610
on a set of API is for plugging the

00:51:23,840 --> 00:51:27,230
final stone in a sandbox way so if you

00:51:25,610 --> 00:51:29,690
wanna be able to do nulls and files and

00:51:27,230 --> 00:51:31,550
that kind of thing with i/o outside a

00:51:29,690 --> 00:51:32,690
browser you can do that kind of thing we

00:51:31,550 --> 00:51:34,310
don't just want to give a website

00:51:32,690 --> 00:51:35,870
program this flushes about something

00:51:34,310 --> 00:51:37,670
because the whole benefit of bumps on

00:51:35,870 --> 00:51:38,990
these with your sandbox so this is a big

00:51:37,670 --> 00:51:42,610
thing I'm working on in wasn't time

00:51:38,990 --> 00:51:42,610
right now so if my checkup wasn't fun

00:51:42,760 --> 00:51:47,330
another big user of green EFT is is

00:51:45,800 --> 00:51:49,040
fastly so fastly it's also using a

00:51:47,330 --> 00:51:51,020
enough to do what tell me completion and

00:51:49,040 --> 00:51:55,430
they're doing web site of occupation in

00:51:51,020 --> 00:51:57,440
the edge firstly is a CDN and so they

00:51:55,430 --> 00:51:59,180
provide they have servers are on the

00:51:57,440 --> 00:52:00,650
world and they could my web so my code

00:51:59,180 --> 00:52:02,540
on our servers is a service for

00:52:00,650 --> 00:52:04,120
customers so if I check out fastly and

00:52:02,540 --> 00:52:05,960
think they have a demo called terrarium

00:52:04,120 --> 00:52:09,410
we're essentially using so we're free

00:52:05,960 --> 00:52:13,430
month online expect the best buy my past

00:52:09,410 --> 00:52:14,510
thing so go check those out guess what

00:52:13,430 --> 00:52:18,010
example that commission that really

00:52:14,510 --> 00:52:19,970
quickly is is a cream of simple jet demo

00:52:18,010 --> 00:52:23,330
so if you if you just search for a

00:52:19,970 --> 00:52:25,370
simple jet demo all in the communication

00:52:23,330 --> 00:52:26,480
project you'll see the demo project it's

00:52:25,370 --> 00:52:27,770
a it's actually really simple toy

00:52:26,480 --> 00:52:30,260
language to be built so use the queen of

00:52:27,770 --> 00:52:31,370
backends to compile my language and I'll

00:52:30,260 --> 00:52:33,200
show you the basics of using that

00:52:31,370 --> 00:52:35,540
interpreted API and acquaintances

00:52:33,200 --> 00:52:37,790
builder API is to go by our and generate

00:52:35,540 --> 00:52:39,380
them into code but it so those are some

00:52:37,790 --> 00:52:46,400
examples of you to the wedding

00:52:39,380 --> 00:52:47,720
very cool any other questions well thank

00:52:46,400 --> 00:52:49,630
you very much Dan that was really

00:52:47,720 --> 00:52:53,860
informative

00:52:49,630 --> 00:52:53,860

YouTube URL: https://www.youtube.com/watch?v=9OIA7DTFQWU


