Title: An unholy fusion of Rust and C++ in physx-rs (Stockholm Rust Meetup, October 2019)
Publication date: 2019-11-10
Playlist: Stockholm Rust Meetup
Description: 
	Embark Studios software engineer Tomasz Stachowiak (@h3r2tic) explains how he combined Rust and C++ in the creation of the physx-rs open source project.

See all our open source projects and sign up for our newsletter at https://embark.dev
Captions: 
	                              Thank You Ari so I'm Tom I'm going to                               talk about the dark arts of binding C++                               and rust or as I would like this                               presentation to be because the reality                               is it's more like this that we have a                               rust mask on top of this fat C++ cats                               and it's it is defined out here we                               deserve but it is here we sadly some                               things need and before we start here's                                just a brief agenda of what you're                                getting yourself into                                I'm going to talk about some mid mid to                                low level details about how binary well                                programming languages interact that's a                                binary level if you know a little bit of                                x                                                                     otherwise I'll try to make it but                                understand both anyway we'll dig into                                some code generation both from the                                compiler side and some of our own crazy                                shenanigans and then show some results                                and the the lessons will their                                informants before we start just a word                                about embark studios we're a Stockholm                                game studio with a slightly unusual                                mission of blurring the line between                                creation and making and on that mission                                we have decided to use rust as a super                                weapon and you have probably heard many                                times that service is great so I'm going                                to just move on and they'll talk about                                that if you're here you're probably a                                rest man but in the process of making                                our games of shenanigans we decided that                                we needed a physics engine and the                                physics engine is the thing which allows                                those those pictures in here so stimuli                                is the the contacts between rigid bodies                                soft bodies the constraints between them                                allows things like character                                interactions and so on and we needed a                                robust solution that would be battle                                tested and while rust quoits exists we                                went for something that has shipped in                                many successful games which is Nvidia                                PhysX or we wanted to use it but we                                didn't really know how but physics is                                pretty great because it's recently got                                open source and so you get to use for                                free a library which helped ship many                                games in the past and it is now licensed                                under BSD                                                               get it in open source as on github sorry                                so the problem is it's a C++ SDK                                and it's not just a 'suppose plus SDK                                it's a massive one so according to                                Wikipedia the project has been on for                                around                                                             years it's gotten a lot of functionality                                and in terms of just API functions                                there's two thousand public ones and                                they implement a lot of great features                                so they exist there for a reason so you                                get things like vehicle controllers it                                can just easily assemble things out of                                wheels and components and steering you                                got characters in clothes and even a                                special remote debugger so you can just                                connect an application that shows you                                all the internal state of the engine to                                running application so you don't need to                                implant all the debugging features in                                your game and that is pretty great but                                before we dive into that how does one in                                general talk to something compiled in a                                different language it's actually a                                similar situation to something compiled                                in the same language as long as it as a                                set of library so if you download some                                crates from rust                                those who will typically be compelled as                                very separate things and then they need                                to talk to each other and the API of                                programming them is one thing but it's                                also the binary compatibility that they                                need to match so there is a thing called                                an ABI which is application binary                                interface and that specifies things like                                the struck layouts the calling                                convention for how the various                                parameters the functions are passed in                                in registers or pushed onto the stack                                and a bunch of other things like name                                mangling and so on                                and the C++ doesn't really have a ABI I                                mean it kind of does but it's only like                                the facto standard on each platform so                                in practice what happens is that the OS                                / compiler vendors they agree on a                                 specific set of conventions that's they                                 stick to and then in practice it is                                 pretty fun so you have a look at the                                 function we have here which just takes a                                 few simple parameters and we already                                 have a discrepancy for word that's C                                 parameter gets passed to so in Windows                                 it comes in the X and M to register in                                 Linux this xmm one register so that is                                 out of fun to deal with at least on a                                 single platform the compilers will be                                 compatible just for the virtue of the                                 clang people and GCC people agreeing                                 yeah we should do the same thing because                                 otherwise it's insane yet still                                 sometimes buggy bugs can                                 in in differences between those calling                                 conventions and then some flags can                                 potentially even affect that ABI so for                                 example if you were to use this                                 zette PFLAG on on the Microsoft compiler                                 and Windows you get something which is                                 completely incompatible with anything                                 else which there's written on Windows                                 and of course you're still in a                                 situation where Windows and Linux are                                 incompatible between each other so how                                 would we talk to something like physics                                 and we would like it to be easy to                                 maintain so we don't have to patch                                 things up every every time a new special                                 a standard comes out or a new version of                                 the physics as the cake comes out we                                 would like it to be robust so it doesn't                                 break on some platforms like we don't                                 want to support just windows we wanted                                 to be cross-platform and we would like                                 to be fast because those API calls will                                 be plentiful so you can if you have tens                                 of thousands of summative units or                                 objects and in the scenes will be making                                 API calls for all of them in a single                                 frame and that's that's all of course so                                 one potential possibility is to add the                                 support for the C++ ABI to the RUS                                 compiler but that unfortunately involves                                 making the rest compiler aware of a                                 whole bunch of supposed type system                                 things and keeping truck with a tent and                                 judging by bugs which exists between                                 super fast compilers that is not an easy                                 task so it's not really a reliable                                 option for now at least in the viable                                 one so another option is to create some                                 kind of magic glue layer between the                                 film the suppose plus and the rust so                                 we'll be talking to this layer from rust                                 and this layer be talking to the C++ and                                 there's a tool in the Rossi ecosystem                                 which promises to provide a glue layer                                 for at least C and a subset of C++                                 now I tried it and unsurprisingly a                                 bunch of things exploded because while                                 it managed to translate some things from                                 C++ its could not match the ABI which is                                 kind of implementation specific and then                                 very well defined and then even if it                                 did manage to support one platform well                                 it's it's if it manages to output                                 something that works in Windows they'll                                 probably break in Linux because it                                 doesn't support that ABI so we would                                 likely need to have specific bindings                                 or per platform per compilers I think                                 and likely still a lot of compiler                                 supports in rust C so another great                                 option hider so in practice what is                                 recommended is and even recommend                                 recommended by the creator of the best                                 bus is that you create a stable C layer                                 and then you talk to that C layer and                                 while C doesn't have an ABI either just                                 like Super Plus at least it's a pretty                                 old old language it is not changing very                                 fast it is not going to go anywhere so                                 in practice a lot of languages which are                                 not C can speak it's including rust so                                 you just have a few declarations the                                 creations instruct and specify the the                                 linkage and it can talk to C so the idea                                 would be to create a stable layer for                                 physics where we would define a public C                                 API and that would just redirect all the                                 calls to the C++ layer and then we will                                 talk into the C C wrapper the C wrapper                                 just redirects things to C++ and                                 hopefully everything works then we will                                 take the C layer compile it with the C                                 cos PLAs compiler which can understand                                 both code bases and give us a compatible                                 C library that we can use and we just                                 create this link that with a with a                                 matching rusts so run matching set of                                 frost declarations and hopefully things                                 just work and it is out of hoping                                 because things get tricky pretty quickly                                 and you have to be super careful when                                 doing this so for example here's a                                 simple structure containing an integer                                 on both sides and there's a function                                 which just takes this truck and returns                                 it immediately the only difference                                 between it is that the one on the right                                 has a constructor it's not even defined                                 in this thing and when you look at the                                 compiled code from for those functions                                 it's a becomes clear they're not                                 compatible so even though we're saying                                 oh this is an extern C function is going                                 to be used in a single face you actually                                 get a very different result if you have                                 a simple plus feature in one of those                                 trucks                                 luckily some compilers will give us a                                 warning and as we see will clang will                                 and g plus plus did not tell me that                                 something is wrong so they will tell you                                 you're gonna have a bad time those                                 functions cannot be used from C                                 but let's go deeper here's a very                                 similar thing where you still have a                                 struct with just a single integer and in                                 here the function does not return it it                                 just takes the integer from the struct                                 and returns it as an integer and the                                 twist here is the struck has a copy                                 constructor instead and once again we                                 have a different code being generated                                 and even a pointer being accessed on the                                 right side so that'll be fun because if                                 you called it unknowingly you'll just                                 get a crash basically and all the                                 compilers have tried with all the sets                                 of flags in for the wlw extra - pedantic                                 and so on they they said this was cool                                 this is cool to use in the C layer so                                 we're gonna have a lot of fun if we go                                 and use that there's also this and this                                 is little spoiler in the title of the                                 slide but let's go through it so this is                                 a few strokes which inherit from each                                 other is a chain and this is basic                                 copied from the physics SDK and what                                 we're interested in is the size the PX                                 sweep hit and I'm not going to ask you                                 to calculate what the size is because I                                 don't think you can know the answer                                 because there is not a single answer if                                 you ask the compilers and windows you're                                 going to get                                                          bytes and I actually ran into this while                                 trying to create this layer that will                                 bind the physics SDK and at that point                                 I'm just realized I hit the wall and I                                 needed to somehow deal with it so we're                                 in a situation where we can't really use                                 simple plus types in the C wrapper even                                 if it's a simple struct like a vector                                 containing X Y and that floats because                                 that already contains things like copy                                 constructors and regular constructors it                                 will break the the ABI we don't even                                 know the sizes of structs so imagine                                 taking or using an array across the                                 interface where you don't know the size                                 of the item so you have need to have                                 some kind of function which will give                                 you the index into the array at an                                 unknown location and then even then you                                 end up with a struct that you don't know                                 the layout of so you have accessor                                 methods to get the specific fields so                                 that is going to be a great time and the                                 running into this and kind of giving up                                 on the situation just kind of gave me                                 and I                                 yeah maybe there's something else we can                                 do                                 why why bother having a single stable                                 layer where you can have a layer a pair                                 compiler per platform first set of                                 compiler flies so you get a wrapper you                                 get a wrapper everyone gets a wrapper                                 and we can actually generate that on the                                 target machine that we're compelling for                                 and build that's with the specific                                 flavor of the C++ compiler in mind so be                                 matching everything and then we end up                                 in a situation where the the layouts of                                 structs and the ABI the calling                                 convention actually are very well                                 defined the dot one specific set of                                 things and of course to support all the                                 different compilers and sets of flags                                 there will be a lot of work and I didn't                                 want to do that I'm out to worry because                                 that sounds crazy so instead I figure if                                 I can just ask the C++ compiler where                                 are the things so you have a struct or                                 class on the left side and you can write                                 a simple space path program which will                                 go over the fields inside that's struct                                 and ask what is your offset from the                                 start of this track what what is the                                 size of the field what does this and off                                 so that the others field and so on and                                 you can write this program once and it                                 will reflect and provide the offsets and                                 locations of the layout on the target                                 platform so we will write this this                                 thing once and then just run it on every                                 single target platform it will generate                                 or output the offsets for everything                                 inside the struct and that will create a                                 little bit spoke wrapper for whatever                                 the supposed last compiler thinks that                                 the layout of things are and from from                                 that information we can actually                                 generate the matching C or rasta code so                                 this is already a basis for that special                                 wrapper for every single person and                                 platform and everything and of course                                 writing that little reflection snippet                                 which will go over the fields and ask                                 the offsets will be a lot of work to do                                 for every single struct inside the                                 physics SDK and of course we can                                 automate things if there is something                                 which can give us information about the                                 C++ compiler and that is the lip tooling                                 from clang and loop till link is a                                 really cool library which you can use to                                 inspect the internal states of the                                 compiler you can get the                                 you can get the ast you can get some                                 stuff after initial passes of semantic                                 analysis so you can get the list of                                 trucks a list of functions list of                                 members and slice trucks and so on and                                 the when you build a tool like this you                                 can actually make it work just like                                 clang does and support all the the                                 default flags that it works with so for                                 example the include directories a bunch                                 of switches and preprocessor definitions                                 and so on so you do it by creating this                                 abstract syntax tree consumer which in                                 which you actually basically have                                 filters slash queries I guess and you                                 say give me all the functions that start                                 with the P X prefix and then it just                                 calls your handler with all the                                 information has on that's function and                                 in there you can go deeper and and                                 Dickens here what is this field oh is it                                 the basic field or is it struck field                                 and so on you can just going to recurse                                 and get all the information about the                                 stuff that you're interested in and then                                 from there it can eventually just go                                 down to the to the smallest building                                 blocks and configure up oh it's it's a                                 Bulls I'll just output a rose bowl it's                                 a flow it will output F for this U and                                 so on so with this two-way connection                                 generates and that little reflection                                 snippets no they had in this life use a                                 few slides back for every single struct                                 in the suppose class code base in                                 practice ends up being a bit more                                 complicated than version but it is                                 essentially a sign thing for every                                 single field we end up just outputting                                 the office events along we have to                                 inherit from the C++ trucks because if                                 they have protected members we could not                                 get the offset of but we can just kind                                 of work around that in a fun way                                 and the nice thing is that this this                                 code generated by our tool this we only                                 need to run once because we will run it                                 on the target platform and then we will                                 get different results but this code                                 actually ends up being platform                                 independence so even though it uses                                 clang and somebody might run the                                 generated code on GCC it will still be                                 will be so correct now this was structs                                 and for functions actually the story is                                 much simpler so for for every single C++                                 function that we're interested in we                                 will generate a single a very slim C                                 function which will take which will just                                 pass all the arguments to the suppose                                 pass code and then pass the return back                                 now we need to be really careful to                                 actually enforce that the the destructs                                 passed in and the types are C types and                                 not C++ types as we saw before because                                 otherwise to compile there we go I'll                                 just send things in the wrong register                                 and you'll crash but we can do that                                 pretty consistently by just going over                                 the type information remapping things as                                 necessary and then do some simple stuff                                 like remap the overloaded variants to                                 slightly renamed things and so on and                                 the nice thing is that this is also a                                 platform or compiler independent so we                                 will only need to do this once and this                                 is also output of that tool so with                                 those building blocks we can actually                                 get the full flow from the from Rosco in                                 this bus plus which will look something                                 like this                                 so between rust and see the there's                                 basically no work being done you just                                 link them together and the destructor                                 you pass into the the layer will be bit                                 and then identical between each other                                 and that's just free then between C and                                 C++ it's a bit more complicated because                                 we have we have generated c structs                                 which are a bit identical with the c++                                 but the type system does not understand                                 it so everything aligns but those are                                 just four and bar difference trucks at                                 the type system so what we do is just                                 mem copy the all the fields between each                                 other and then we call this both class                                 code we get the the result types and do                                 the thing in Reverse now this might seem                                 like some overhead at the mem copy level                                 but so in practice because man copy is                                 an intrinsic the compiler actually                                 understands that's you are just copying                                 field a to field a in the other struct                                 and then just accessing that so it knows                                 doesn't have to do that so in practice                                 you get just gets optimized out and then                                 this becomes an almost your overheads                                 layer so using those those tricks we                                 managed to generates this physics is                                 great which gives this lovely example of                                 a balancing bowl and you can tell that's                                 no graphics programmers were harmed and                                 making of this example it is lovely                                 gives you access to basically all the                                 the public functionality of the SDK but                                 in an extremely unsafe and an organic                                 way so whenever you have things like                                 inheritance you have to like cast the                                 role pointers between seemingly                                 unrelated                                 types because Ross doesn't know that                                 there were those should inherit from                                 each other so it's it's it's kind of                                 ugly but but it works and the nice                                 little side effect of that is it is a                                 generic see layer as well so if for                                 example Lua or Pascal or Haskell or                                 something they want to use physics they                                 can just use the same generated C layer                                 and just steal it from here and so about                                 this machinery which was running on top                                 of Clank the whole dip tooling thing we                                 only actually need to run it whenever we                                 updates the C++ SDK for physics or                                 whenever we change the hole generator                                 process it is not fully cross-platform                                 because it was a lot of work to                                 otherwise to make sure it works so for                                 example we have to have the clang                                 developer libraries installed on your                                 system and we would need to port the                                 shell scripts to batch or PowerShell or                                 whatever does so in practice it doesn't                                 really matter because we can just run                                 that on on some Linux / Mac machine and                                 we'll be fine                                 so this whole pipeline will basically                                 generate the the C function wrappers and                                 the little utility that will provide                                 reflection over c plus plus types and we                                 put those things into crates so that the                                 end-users end-users don't need to worry                                 about it and then on the end user side                                 they just grab this great continues                                 those artifacts and just pass it into                                 the the actual build pipelines up the                                 users execute so as a part of that they                                 will actually build the physics SDK from                                 source using the C make and CC crates                                 inside the Builder s so the entire                                 suppose SDK is is built with a known set                                 of flags and a known compiler and then                                 we built the the generated wrapper with                                 the exact same sort of flags having                                 reflected onto the layouts and structs                                 of everything so we have kind of                                 finished building the the wrapper                                 library by reusing the utility and we                                 just glue everything together and we                                 have a working                                 rust solution and that's that and when                                 it comes to using well there's a little                                 caveat the stuff you wrap everything in                                 unsafe because this role pointers about                                 and no such thing as ownership tracking                                 and like                                 and so on but the the coat is not that                                 horrible to you to read for example you                                 can actually use the the struts for for                                 vector instead of heap allocating                                 everything so it is it is a right even                                 though it has some nasty stuff in it but                                 we don't like up nasty stuff so we went                                 and built a safe or layer on top of that                                 or something so that umber clear that                                 it's gives you a lot of economics in                                 comparison it provides some safety I                                 would like to say all safety but sin in                                 practice dealing with us is kind of                                 complicated and we basically work on                                 those grades when we need more features                                 so we have a bunch of to dues to clean                                 up some unsafe stuff but it does give                                 you a lot of stuff and it doesn't cover                                 all the functionality but but it's fine                                 to to mix and match between the nice                                 ergonomic layers and the unsafe                                 horribleness and we have a matching                                 example of offer of a bouncing ball but                                 this thing from from Linux and I'm cold                                 using just the physics it is lacking the                                 the lovely you read with the unsafe on                                 the side but otherwise it's kind of                                 similar it doesn't have a horrible                                 pointer cast but it does have one unsafe                                 because we need live to use a row                                 pointer one place but it's not better                                 and because we love open source you can                                 get it now from Chris i/o and from from                                 github and feel free to play with it                                 experiment with some physics and so on                                 so it is out there so having covered                                 that's a one might ask what do we do                                 with this longer term and ideally I                                 would like to say let's not do this                                 because it's kind of horrible and I                                 would not want to be the person                                 suggesting to integrate tons and tons of                                 service bus into the rest ecosystem and                                 we would vastly prefer a native                                 resolution for things like this but in                                 the the physics SDK to                                             develop for pretty serious reasons and a                                 lot of really good development went into                                 it including tons and tons of                                 optimizations by skilled engineers so it                                 will take a while to to get to that                                 level when it comes to to some libraries                                 at least so in the short term Altezza                                 dent lee say let's do this                                 and this is a at least a viable way to                                 provide a binding layer or glue layer                                 between rust and suppose boss which                                 seems at least so far to be robust and                                 reliable we haven't seen it do anything                                 and expect to be at least and and please                                 don't judge me by the code generator I                                 was learning Clank and things as I was                                 going it is a bit messy messy and can                                 definitely be improved maybe some stuff                                 can be merge or collaborates with a bond                                 engine for example we've learned a lot                                 of stuff in the process of doing that so                                 we have learned that binding rust and                                 stuff bus is not that difficult if you                                 use the right tools so if you use cargo                                 you get the old amazing build process                                 which allows you to do things like                                 building you suppose plus software and                                 then extracting libraries and and also                                 the crazy stuff and with clang and lip                                 tooling you can get information out of                                 the out of this class code base and so                                 on so it's it's not that difficult so if                                 you're a game developer for example and                                 you are afraid of using rust because you                                 fear you might be isolated inside the                                 ecosystem because most of the stuff in                                 game dev is written in scenes above Plus                                 well you can know that there is a way to                                 actually get all those dependencies into                                 rust so potentially it is an enabler for                                 people who would otherwise not try rust                                 so it's not all evil and a little side                                 effect of of this setup is is actually                                 easier to integrate the physics as he                                 came to rust now then it is inclusive as                                 poss because and Rossi just say physics                                 equals version and Snyder cargo tunnel                                 and in C++ you would probably spend well                                 if you're using C make you might just                                 use it but if you're using anything else                                 you might spend between hours to days                                 integrating the C make stuff into your                                 proprietary build system I actually                                 tried untangling the C make build                                 scripts from physics itself but after                                 half a day I gave up I decided that the                                 logic in there was just too complicated                                 so you just use it like this and                                 probably the most important thing I've                                 learned making versus that's if you                                 integrates a ton of superclass code into                                 your otherwise pure rust repository                                 you're not going to be popular among                                 your co-workers but it is a good                                 motivation to to turn the whole thing                                 into                                 uncrate an open source it's because when                                 we just push it out and have a pure                                 project again so we can live you can                                 live convinced that we are just writing                                 arrests and everything is beautiful that                                 I apologize profoundly and that was it                                 and please ask me at least                                        questions not sure we have time for                                 thirty billion questions but maybe it is                                                                                 great talk yeah Tomas just tell me Tommy                                 okay sorry you have any questions from                                 the audience so using your measurement                                 in in base or whatever to integrate the                                 build system how long would it take to                                 use this for another CPAs personal                                 library this rust crazy mean yeah or                                 redo the process for something else yeah                                 that depends which can each cases one                                 might run into so the development of                                 this was basically try to do something                                 with the the ast or information we have                                 and from Clank                                 run into a wall then Co what kind of                                 other thing that they add oh they have                                 emails I didn't have support for emails                                 then as support for that and continue                                 and then we run into another wall and so                                 on so it is very much an incremental                                 thing and I did take some shortcuts                                 specific to physics but in theory one                                 could extend this to a fairly general                                 thing and support a decent subset of C++                                 I could imagine issues around things                                 like templates and I don't know lambdas                                 as parameters and so on so more kind of                                 abstract features but a lot of libraries                                 are written using a subset of space plus                                 at least at the interface level so maybe                                 it would not be too crazy to have good                                 coverage cool so if I very loud sorry so                                 if I would do something stupid like oh I                                 want to use the standard library from                                 C++ in rust is in your thing there'll be                                 a bad time because that's mostly                                 templates okay                                 so you mentioned that you run part of                                 the code to get the offsets and so on on                                 the target which could be a limitation                                 did you find the clang tooling too                                 limiting to get this limitation I'm not                                 familiar with a club to get this                                 information I'm not familiar with a                                 clang tooling but I mean it's just a                                 limitation because you cannot cross                                 compile that easily and the information                                 is there and executable somewhere                                 actually because all we need from Clank                                 is just information of which fields are                                 in destruct so this allows me to just                                 write this kind of generate almost                                 copypasta like code like get the offset                                 if there's a field called foo insider                                 struct I'll literally write add member                                 foo of set of foo size of food so you                                 just generate this this Fame which                                 doesn't care about layers at all and                                 then this is basically a C++ program                                 that you run on the targets and just                                 knowing the names of things inside the                                 structs that you could know if the slots                                 had actually run through deflection this                                 you just run this small thing and then                                 you're done okay but that is code that                                 runs at the build time yes at the build                                 time inside cargo so every time you run                                 cargo it is potentially going to run                                 that and practice it is all cached so                                 unless you actually change the set of                                 flags if I see compilers or your object                                 trades it is going to just run once but                                 in theory the entire pipeline is defined                                 inside cargo except the the clang thing                                 with the lip the wing ok sure                                 yeah we were kids creating a line here                                 so I maintained the v                                                   so I've encountered some of this v                                  thing the JavaScript time so I have                                 encountered some of these problems as                                 well and you already spoke about                                 templates being a problem what about                                 other things such as you know logic in                                 move constructors or destructor that                                 depend on stack layout or are you                                 encountering of those likely what                                 suppose plus I did with physics I did                                 not                                 so if I were to work with an SDK that                                 had features the features like this I                                 would just have the the automatic tool                                 which uses clang - actually em it's                                 already some kind of wrapper inside I                                 suppose plus sites or or in the C layer                                 deal with the move constructors and so                                 on to actually well not use them in the                                 just like in in the current version we                                 generated C functions that don't take                                 C++ inputs at all but just man copying                                 stuff rounds similar tricks mines might                                 do yeah yeah like because I was saying I                                 maintain d                                                              haven't been able to update it first                                 like years because I can't maintain the                                 mapping so I should talk to you after                                 sure maybe using your library think                                 we're down to                                                          you mentioned his lip clunk looks                                 similar to the internals of Benjamin mmm                                 did you consider to contributed Oh                                 Benjamin make some custom Benjen or make                                 it available to the Benjen users to use                                 your sink inside the Benjen so I did                                 have a look at SAP engine and it does                                 use clang as well it is a rough project                                 and it uses partial client bindings                                 I tried doing the same but all the stuff                                 I needed wasn't really exposed to rust                                 yet so maybe one could use a binding                                 generator that shouldn't generate a                                 clang bindings to you you can use that                                 in rust                                 so that's the on higher-level I wanted                                 to avoid making something which is too                                 general because my task or my idea is to                                 to point physics not knowing whether                                 that actually will be feasible so I just                                 went all in what is the quickest way we                                 can get this                                 only things as fast as the k                                          with rust so not thinking about the                                 larger picture too much but now having                                 finished this there is a bunch of                                 techniques what one could use to to make                                 a larger is a more wide partly or white                                 but part of the deco system to work with                                 with rust I don't know how much work it                                 will be and I don't want to be first in                                 the deal serviceable spots for too much                                 of my time so I'll say there's                                 potentially some ways to make this                                 supports but the full request welcome                                 masking because my engine actually is                                 trying to do the same and by trying to                                 generate the cheapest place like outs                                 for the classes and happens and I                                 actually used it for the bullet physics                                 buildings and it actually worked at some                                 so that summer was the super cool if                                 your work will be like merged with App                                 Engine it will be like actually work so                                 they'll be fine if we could use things                                 like bulletins oh let's thank Tom again                                 thank you                                 [Applause]
YouTube URL: https://www.youtube.com/watch?v=RxtXGeDHu0w


