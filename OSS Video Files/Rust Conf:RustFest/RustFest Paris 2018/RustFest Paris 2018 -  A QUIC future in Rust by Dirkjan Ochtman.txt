Title: RustFest Paris 2018 -  A QUIC future in Rust by Dirkjan Ochtman
Publication date: 2018-05-26
Playlist: RustFest Paris 2018
Description: 
	Dirkjan Ochtmann takes us on a ride
to the future of Rust serverside
to learn what async fate we will have to await
Meanwhile let us Rust far and wide! 

Once HTTP/2 was standardized in 2015, the IETF started work on an even faster iteration of HTTP, based on QUIC: the Quick UDP Internet Connections protocol. The QUIC community is getting ever closer to standardizing it. While we have great HTTP and HTTP/2 implementations in Rust already, this talk discusses an effort to implement QUIC in pure Rust, based on the futures ecosystem.

(Limerick by @llogiq)

https://paris.rustfest.eu/sessions/a-quic-future-in-rust
Captions: 
	00:00:04,709 --> 00:00:11,920
Dillion Ockman takes us on a ride to the

00:00:08,170 --> 00:00:14,189
future of rust server site to learn what

00:00:11,920 --> 00:00:18,060
a zinc fate we will have to await

00:00:14,189 --> 00:00:23,829
meanwhile let us rust far and white

00:00:18,060 --> 00:00:23,829
[Applause]

00:00:34,199 --> 00:00:40,300
better yes it's not just about a server

00:00:38,229 --> 00:00:42,429
site it's a client site as well yeah

00:00:40,300 --> 00:00:46,510
gotta have two sides to any connection

00:00:42,429 --> 00:00:48,550
so I'm here to talk about quick it's a

00:00:46,510 --> 00:00:51,539
new protocol the ITF is currently

00:00:48,550 --> 00:00:54,069
working on first a little bit about me

00:00:51,539 --> 00:00:58,059
so I've been using rust for about two

00:00:54,069 --> 00:01:04,690
years in my spare time mostly or really

00:00:58,059 --> 00:01:06,970
only and I've had a lot of fun and I

00:01:04,690 --> 00:01:09,070
think Russ is great I believe in the

00:01:06,970 --> 00:01:12,880
future of doing things in rust rather

00:01:09,070 --> 00:01:15,010
than other languages so I got interested

00:01:12,880 --> 00:01:16,540
in this protocol that they are

00:01:15,010 --> 00:01:18,970
developing

00:01:16,540 --> 00:01:22,210
it's called quick UDP internet

00:01:18,970 --> 00:01:24,520
connections or just quick and basically

00:01:22,210 --> 00:01:26,190
the the large companies are working on

00:01:24,520 --> 00:01:28,810
internet stuff this started at Google

00:01:26,190 --> 00:01:30,610
but a number of companies are working at

00:01:28,810 --> 00:01:33,430
now and are in the working group

00:01:30,610 --> 00:01:35,620
together trying to standardize it and

00:01:33,430 --> 00:01:39,460
what they want to do in the end is to

00:01:35,620 --> 00:01:42,310
replace TCP and TCP is sort of this core

00:01:39,460 --> 00:01:44,710
part of the internet stack you might

00:01:42,310 --> 00:01:48,790
have heard you you might just think of

00:01:44,710 --> 00:01:51,909
it as TCP and IP where basically you

00:01:48,790 --> 00:01:54,070
shove data bytes into a stream and you

00:01:51,909 --> 00:01:56,650
get it out on the other side so what

00:01:54,070 --> 00:02:01,420
it's trying to do is reliable in order

00:01:56,650 --> 00:02:03,370
delivery across the Internet and this

00:02:01,420 --> 00:02:05,560
has been working for about four years

00:02:03,370 --> 00:02:08,470
and there have been some extensions to

00:02:05,560 --> 00:02:10,300
make it better but it turns out we have

00:02:08,470 --> 00:02:12,790
learned a few things about doing

00:02:10,300 --> 00:02:14,530
internet scale things in 40 years so

00:02:12,790 --> 00:02:18,299
they think they can do better than TCP

00:02:14,530 --> 00:02:18,299
even with extensions and

00:02:18,380 --> 00:02:26,000
they started at Google in 2012 and in

00:02:21,610 --> 00:02:27,380
2016 they went to the ITF hopefully by

00:02:26,000 --> 00:02:30,470
the end of the year it will be

00:02:27,380 --> 00:02:33,100
standardized and though there's still a

00:02:30,470 --> 00:02:35,150
number of things to be fixed and

00:02:33,100 --> 00:02:37,430
recently there was this week there was a

00:02:35,150 --> 00:02:40,280
proposal which might slow it down for I

00:02:37,430 --> 00:02:45,290
think nine months the estimate it so

00:02:40,280 --> 00:02:49,370
well no no when it comes really to to a

00:02:45,290 --> 00:02:52,730
standard but I think as forward-looking

00:02:49,370 --> 00:02:54,950
people are in the rest community let's

00:02:52,730 --> 00:02:59,510
look at this protocol that will at some

00:02:54,950 --> 00:03:00,920
point be part of our lives so these are

00:02:59,510 --> 00:03:05,150
sort of the three sections of the talk

00:03:00,920 --> 00:03:06,260
that I'm going to do today first I want

00:03:05,150 --> 00:03:08,030
to talk a little bit about the problem

00:03:06,260 --> 00:03:10,250
or one of the main problems that we're

00:03:08,030 --> 00:03:12,320
trying to solve with quake and that is

00:03:10,250 --> 00:03:14,120
head-of-line blocking and I've tried to

00:03:12,320 --> 00:03:14,810
make an animation to make this a little

00:03:14,120 --> 00:03:17,540
bit clearer

00:03:14,810 --> 00:03:19,010
so you see data flowing from the

00:03:17,540 --> 00:03:21,620
application through the transfer layer

00:03:19,010 --> 00:03:23,390
through the network and at some point a

00:03:21,620 --> 00:03:25,430
packet is going to go get dropped in a

00:03:23,390 --> 00:03:27,800
network side and the packets that come

00:03:25,430 --> 00:03:29,420
after that after that packets have to

00:03:27,800 --> 00:03:32,330
wait to be delivered back to the

00:03:29,420 --> 00:03:34,430
application so as you can see they get

00:03:32,330 --> 00:03:37,100
buffered in the transport layer and then

00:03:34,430 --> 00:03:39,520
once the packet is retransmitted then

00:03:37,100 --> 00:03:43,850
they can be delivered to the application

00:03:39,520 --> 00:03:45,980
and in many cases in practice actually

00:03:43,850 --> 00:03:48,620
what you're delivering over the

00:03:45,980 --> 00:03:52,940
transport layer over network is not just

00:03:48,620 --> 00:03:56,120
one stream of bytes but is multiple

00:03:52,940 --> 00:03:58,250
streams of bytes interleaved so you're

00:03:56,120 --> 00:04:00,560
doing multiplexing and in that case it

00:03:58,250 --> 00:04:02,209
might be nice to actually take some of

00:04:00,560 --> 00:04:04,790
the parts that are not directly affected

00:04:02,209 --> 00:04:06,820
by the packet loss and we will be able

00:04:04,790 --> 00:04:12,709
to deliver them to the application layer

00:04:06,820 --> 00:04:15,680
before the reasons mission is fixed so

00:04:12,709 --> 00:04:17,450
in general the quick goals these are the

00:04:15,680 --> 00:04:20,840
goals that are as stated by the working

00:04:17,450 --> 00:04:23,360
group Charter to minimize latency both

00:04:20,840 --> 00:04:26,780
in the connection establishment as well

00:04:23,360 --> 00:04:29,479
as in the data transfer as you might

00:04:26,780 --> 00:04:30,919
know TCP connections are a bit slow to

00:04:29,479 --> 00:04:31,720
set up often because you have to do

00:04:30,919 --> 00:04:36,510
multiple around

00:04:31,720 --> 00:04:40,240
and if you also DTLS that's even worse

00:04:36,510 --> 00:04:42,460
to provide multiplexing so that's sort

00:04:40,240 --> 00:04:45,180
of wedging together multiple streams by

00:04:42,460 --> 00:04:47,220
taking chunks of each stream and

00:04:45,180 --> 00:04:50,980
serializing them into a single stream

00:04:47,220 --> 00:04:52,390
but with quick it better understands how

00:04:50,980 --> 00:04:54,700
you're doing multiplexing so the

00:04:52,390 --> 00:04:56,650
application layer can influence that and

00:04:54,700 --> 00:04:59,860
it allows you to get rid of this

00:04:56,650 --> 00:05:01,300
head-of-line blocking problem change is

00:04:59,860 --> 00:05:04,750
limited to path endpoints so what

00:05:01,300 --> 00:05:06,850
they're saying is they don't want the

00:05:04,750 --> 00:05:10,600
whole internet to have to change to be

00:05:06,850 --> 00:05:14,890
able to do quick so what they do is they

00:05:10,600 --> 00:05:17,710
use UDP UDP is sort of the simple simple

00:05:14,890 --> 00:05:19,960
sibling to TCP which basically means you

00:05:17,710 --> 00:05:22,090
take an IP packets you stuff two port

00:05:19,960 --> 00:05:24,580
numbers a checksum and a length field in

00:05:22,090 --> 00:05:28,840
it and then you just shove it on the

00:05:24,580 --> 00:05:32,710
wire and so that means you don't get in

00:05:28,840 --> 00:05:34,300
order or reliable but you can do this

00:05:32,710 --> 00:05:37,980
sort of more fine-grained stuff and

00:05:34,300 --> 00:05:39,940
leave the inorder reliability to

00:05:37,980 --> 00:05:41,920
something closer to the application

00:05:39,940 --> 00:05:44,050
layer which also means it's easier to

00:05:41,920 --> 00:05:46,300
evolve over time because you're not

00:05:44,050 --> 00:05:48,580
dependent on for example most people

00:05:46,300 --> 00:05:52,030
running TCP stacks it from the kernel

00:05:48,580 --> 00:05:54,850
which are hard to upgrade they want to

00:05:52,030 --> 00:05:56,919
do multi path support built in it's also

00:05:54,850 --> 00:05:59,530
possible with TCP but what they do there

00:05:56,919 --> 00:06:03,760
as to they sort of layer an extra thing

00:05:59,530 --> 00:06:06,669
on top of TCP which makes it less

00:06:03,760 --> 00:06:09,220
efficient with quick that's built-in

00:06:06,669 --> 00:06:15,600
they do better error correction so they

00:06:09,220 --> 00:06:19,330
try to make the most of error robustness

00:06:15,600 --> 00:06:22,780
against problems from the packet also

00:06:19,330 --> 00:06:25,780
with quake Security's built in so they

00:06:22,780 --> 00:06:28,690
use they reuse a lot of the stuff that's

00:06:25,780 --> 00:06:33,460
in from TLS although they rely on TLS

00:06:28,690 --> 00:06:35,860
1.3 but it's always there unlike with

00:06:33,460 --> 00:06:38,050
TCP where you get TCP and then you can

00:06:35,860 --> 00:06:40,510
layer to your less on top of it so even

00:06:38,050 --> 00:06:42,880
though these days it's getting more and

00:06:40,510 --> 00:06:45,340
more common to just use always use TLS

00:06:42,880 --> 00:06:49,240
on TCP with quic is built-in and

00:06:45,340 --> 00:06:52,630
nice and what they're saying is we want

00:06:49,240 --> 00:06:54,729
to rapidly do development and testing so

00:06:52,630 --> 00:06:58,060
it will not just be this version of

00:06:54,729 --> 00:07:00,669
quick and then ghost along for a long

00:06:58,060 --> 00:07:02,740
while but they expect that there will be

00:07:00,669 --> 00:07:06,220
revisions of quake so there's stuff like

00:07:02,740 --> 00:07:08,770
version ago she ation built in and that

00:07:06,220 --> 00:07:10,360
makes it possible to at some point move

00:07:08,770 --> 00:07:15,190
the ecosystem forward without having

00:07:10,360 --> 00:07:17,680
large flag days quick is split up

00:07:15,190 --> 00:07:20,229
currently in six documents it's nice

00:07:17,680 --> 00:07:24,150
because it makes it a bit easier to get

00:07:20,229 --> 00:07:27,010
to the parts you find interesting or to

00:07:24,150 --> 00:07:29,919
maybe at some point do more modular

00:07:27,010 --> 00:07:32,200
protocol implementations first one is

00:07:29,919 --> 00:07:33,970
invariants so they try to document stuff

00:07:32,200 --> 00:07:36,760
that cannot change across versions so

00:07:33,970 --> 00:07:38,410
that that helps if you're doing good

00:07:36,760 --> 00:07:40,539
version negotiation or you want to try

00:07:38,410 --> 00:07:42,910
to be robust against future protocol

00:07:40,539 --> 00:07:44,949
changes transport is like the core

00:07:42,910 --> 00:07:48,160
protocol logic so it has all the stuff

00:07:44,949 --> 00:07:50,680
about the handshake and how the data is

00:07:48,160 --> 00:07:53,650
transferred recovery is all about loss

00:07:50,680 --> 00:07:56,080
detection and congestion control so if

00:07:53,650 --> 00:07:59,200
packets get lost how do you detect it

00:07:56,080 --> 00:08:01,990
what do you do when you detect it that

00:07:59,200 --> 00:08:05,260
sort of thing or if the flow of the

00:08:01,990 --> 00:08:07,389
network is restricted what's the best

00:08:05,260 --> 00:08:09,280
way to handle that and all of a lot of

00:08:07,389 --> 00:08:12,120
these algorithms are algorithms are

00:08:09,280 --> 00:08:16,690
described in the special specification

00:08:12,120 --> 00:08:22,900
TLS so that is how is that promise of

00:08:16,690 --> 00:08:24,760
security realized so what they do is use

00:08:22,900 --> 00:08:27,750
the TLS spec that's already out there

00:08:24,760 --> 00:08:31,320
which we have implementations for but

00:08:27,750 --> 00:08:33,789
make it use it in a slightly more

00:08:31,320 --> 00:08:37,479
efficient way because it can integrate

00:08:33,789 --> 00:08:41,229
into the quick layer and then in order

00:08:37,479 --> 00:08:44,830
to do HTTP on top a quick there's two

00:08:41,229 --> 00:08:46,779
other things so queue back you might

00:08:44,830 --> 00:08:49,000
know that in HTTP two there's something

00:08:46,779 --> 00:08:51,730
called H pack which is a way of trying

00:08:49,000 --> 00:08:55,030
to do a binary sort of compression

00:08:51,730 --> 00:08:58,300
encoding of the headers both header

00:08:55,030 --> 00:09:01,300
names and header values so you can do

00:08:58,300 --> 00:09:04,690
being more efficient at HTTP data

00:09:01,300 --> 00:09:07,209
transfer making it almost look like some

00:09:04,690 --> 00:09:10,089
really smartly encode its binary

00:09:07,209 --> 00:09:15,310
protocol and for quick they have

00:09:10,089 --> 00:09:16,750
slightly different needs so they also

00:09:15,310 --> 00:09:19,330
have to do with different encoding of

00:09:16,750 --> 00:09:22,510
the confession scheme and then HTTP to

00:09:19,330 --> 00:09:24,640
HTTP is sort of the same thing where

00:09:22,510 --> 00:09:26,350
it's really based on HTTP too and it's

00:09:24,640 --> 00:09:30,779
quite similar but a lot of the details

00:09:26,350 --> 00:09:34,899
are different to accommodate the quic

00:09:30,779 --> 00:09:37,779
semantics so sort of this core idea in

00:09:34,899 --> 00:09:45,520
quic is that of streams so I had to

00:09:37,779 --> 00:09:48,270
think of some nice analogy and what the

00:09:45,520 --> 00:09:50,890
core concept is that you have any and

00:09:48,270 --> 00:09:53,709
hardly hardly limited number of streams

00:09:50,890 --> 00:09:56,470
you can have I think two to the power 62

00:09:53,709 --> 00:10:00,339
or something so it should be enough for

00:09:56,470 --> 00:10:02,920
most people and they have four different

00:10:00,339 --> 00:10:05,370
types of streams streams are either

00:10:02,920 --> 00:10:10,120
client initiated or server initiated and

00:10:05,370 --> 00:10:13,329
they are either by directional or

00:10:10,120 --> 00:10:14,649
unidirectional so that allows you to

00:10:13,329 --> 00:10:17,350
make some optimizations with how you

00:10:14,649 --> 00:10:20,230
handle those streams and you can and

00:10:17,350 --> 00:10:22,360
that's used in the protocol and this is

00:10:20,230 --> 00:10:25,350
sort of encoded by having the least

00:10:22,360 --> 00:10:32,950
significant bits of this stream type

00:10:25,350 --> 00:10:34,899
represent these stream types short bit

00:10:32,950 --> 00:10:37,720
about recovery so there are the

00:10:34,899 --> 00:10:38,800
differences with TCP are well explained

00:10:37,720 --> 00:10:42,550
in a specification

00:10:38,800 --> 00:10:45,730
so whereas TCP conflates the order of

00:10:42,550 --> 00:10:48,160
transmission of packets and the order of

00:10:45,730 --> 00:10:50,560
delivery of the package contents to the

00:10:48,160 --> 00:10:54,100
application these are separate concepts

00:10:50,560 --> 00:10:56,440
in quick which means that quick packet

00:10:54,100 --> 00:10:59,320
numbers are just representative of the

00:10:56,440 --> 00:11:00,730
transmission order but the order in

00:10:59,320 --> 00:11:03,880
which data is delivered to the

00:11:00,730 --> 00:11:06,459
application relies on data offsets that

00:11:03,880 --> 00:11:09,040
are per stream so this again helps you

00:11:06,459 --> 00:11:11,610
do prevent head of line blocking type

00:11:09,040 --> 00:11:13,290
problems and

00:11:11,610 --> 00:11:15,300
because you have a very clear ordering

00:11:13,290 --> 00:11:16,769
in your packet numbers in terms of

00:11:15,300 --> 00:11:20,930
transmission order that also makes it

00:11:16,769 --> 00:11:23,670
easier to detect I could loss TCP

00:11:20,930 --> 00:11:26,760
actually allows you to in some cases go

00:11:23,670 --> 00:11:30,570
back on acknowledging packets which is

00:11:26,760 --> 00:11:33,180
called reneging this could happen for

00:11:30,570 --> 00:11:34,980
example if you have you lose some

00:11:33,180 --> 00:11:37,950
packets and you buffer a bunch packets

00:11:34,980 --> 00:11:40,680
after that and then the receiver is

00:11:37,950 --> 00:11:41,940
allowed to at some point say this packet

00:11:40,680 --> 00:11:43,649
last thing is taking too much time I

00:11:41,940 --> 00:11:48,149
don't want to buffer these packets

00:11:43,649 --> 00:11:50,040
anymore but as it turns out there was a

00:11:48,149 --> 00:11:51,690
paper that showed that this doesn't

00:11:50,040 --> 00:11:53,880
actually function in practice it's use

00:11:51,690 --> 00:11:58,140
only rarely but it causes substantial

00:11:53,880 --> 00:12:01,200
complexity on both sides so this was

00:11:58,140 --> 00:12:02,760
dropped from quick and if you receive a

00:12:01,200 --> 00:12:06,300
packet you just have to it's your

00:12:02,760 --> 00:12:09,450
responsibility now really only if you a

00:12:06,300 --> 00:12:15,029
kit and there's a more efficient way of

00:12:09,450 --> 00:12:17,279
doing X in quick so that you can more

00:12:15,029 --> 00:12:19,260
reliably convey as a receiver to the

00:12:17,279 --> 00:12:22,440
sender what you have received and what

00:12:19,260 --> 00:12:24,870
you have not received making it clearer

00:12:22,440 --> 00:12:27,899
what packets need to be retransmitted by

00:12:24,870 --> 00:12:29,910
the sender finally there is an explicit

00:12:27,899 --> 00:12:33,120
correction for delayed acknowledgment so

00:12:29,910 --> 00:12:36,300
as a sender you might well as a receiver

00:12:33,120 --> 00:12:37,860
you might well choose not to ACK to send

00:12:36,300 --> 00:12:39,690
acknowledgments directly for any package

00:12:37,860 --> 00:12:41,190
that you receive because for example

00:12:39,690 --> 00:12:44,820
it's more efficient to group

00:12:41,190 --> 00:12:46,980
acknowledgments but that makes it harder

00:12:44,820 --> 00:12:49,860
for the sender to determine the

00:12:46,980 --> 00:12:57,260
round-trip time because you're fiddling

00:12:49,860 --> 00:13:00,209
with the timing of the X so in quick the

00:12:57,260 --> 00:13:02,720
delay between receiving the packet and

00:13:00,209 --> 00:13:06,029
sending the acknowledgment for it can be

00:13:02,720 --> 00:13:08,310
made explicit so that you can reliably

00:13:06,029 --> 00:13:14,390
estimate the round-trip time for our

00:13:08,310 --> 00:13:19,770
packets so TLS is just TLS 1.3 handshake

00:13:14,390 --> 00:13:21,449
with a custom extension the extension is

00:13:19,770 --> 00:13:24,079
used to announce transport parameter so

00:13:21,449 --> 00:13:24,079
this is things like

00:13:24,089 --> 00:13:29,220
as a receiver you announce how much data

00:13:26,759 --> 00:13:31,529
you can hold in your buffers until

00:13:29,220 --> 00:13:34,019
you've acknowledged it or how many

00:13:31,529 --> 00:13:36,720
streams you allow to be open so this

00:13:34,019 --> 00:13:39,269
really also makes it possible to scale

00:13:36,720 --> 00:13:42,779
down implementations do not need a lot

00:13:39,269 --> 00:13:45,149
of memory and the nice part of doing

00:13:42,779 --> 00:13:50,759
this in the till SN 1.3 handshake is

00:13:45,149 --> 00:13:52,350
that both you get you don't have to do

00:13:50,759 --> 00:13:54,720
an extra round trip after the handshake

00:13:52,350 --> 00:13:57,990
plus you get authentication from the

00:13:54,720 --> 00:13:59,459
handshake so it's clear that these are

00:13:57,990 --> 00:14:03,449
actually your kind of mess with the

00:13:59,459 --> 00:14:10,680
transport parameters in flight after the

00:14:03,449 --> 00:14:13,110
handshake you use the negotiated cipher

00:14:10,680 --> 00:14:15,689
suite and secrets from TLS but you don't

00:14:13,110 --> 00:14:19,709
actually use the TLS protocol anymore so

00:14:15,689 --> 00:14:22,800
instead of wrapping every data transport

00:14:19,709 --> 00:14:25,259
stuff in TLS record since you're less

00:14:22,800 --> 00:14:29,689
managed messages that doesn't happen you

00:14:25,259 --> 00:14:32,670
just encrypt your packet payloads with

00:14:29,689 --> 00:14:36,059
the handshake or the stuff that you got

00:14:32,670 --> 00:14:37,819
from the handshake not sure if the

00:14:36,059 --> 00:14:42,990
slides are going to come back this time

00:14:37,819 --> 00:14:45,870
doesn't look like it yeah and so this

00:14:42,990 --> 00:14:50,670
week there was an announcement

00:14:45,870 --> 00:14:52,559
it looks like the quick working group

00:14:50,670 --> 00:14:57,379
has design teams so that seems like

00:14:52,559 --> 00:14:57,379
similar as in the rest community

00:15:04,220 --> 00:15:09,720
and the design dust there's a stream

00:15:07,920 --> 00:15:13,010
zero design team stream zero is the

00:15:09,720 --> 00:15:16,980
stream that carries the TLS handshake

00:15:13,010 --> 00:15:18,690
and and further messages and it looks

00:15:16,980 --> 00:15:21,480
like the stream zero design team has a

00:15:18,690 --> 00:15:23,190
lot of ideas about how to improve stream

00:15:21,480 --> 00:15:25,440
zero or that there are still problems

00:15:23,190 --> 00:15:28,350
with the current design of stream 0 that

00:15:25,440 --> 00:15:30,089
is what might cause a bunch of extra

00:15:28,350 --> 00:15:33,510
delays because this now means that all

00:15:30,089 --> 00:15:37,110
the TLS implementations so open SSL or

00:15:33,510 --> 00:15:46,380
in my case Russell's will have to be

00:15:37,110 --> 00:15:53,519
updated to support that kind of stuff my

00:15:46,380 --> 00:15:56,940
next slide is about quick HTTP and quick

00:15:53,519 --> 00:15:58,800
HTTP is negotiated as a application

00:15:56,940 --> 00:16:00,930
layer during the application layer

00:15:58,800 --> 00:16:03,540
protocol negotiation that's part of the

00:16:00,930 --> 00:16:08,160
TLS handshake that works today it's used

00:16:03,540 --> 00:16:11,160
for HTTP 2 as well for example in this

00:16:08,160 --> 00:16:15,050
case you just say you can say just HQ to

00:16:11,160 --> 00:16:17,790
say hey I supports HTTP quick / quick

00:16:15,050 --> 00:16:21,120
you can also do things like saying I

00:16:17,790 --> 00:16:26,459
support HQ on this particular port so

00:16:21,120 --> 00:16:29,220
you're a regular HTTP 1 web server can

00:16:26,459 --> 00:16:30,750
in its TLS handshake say if you go to

00:16:29,220 --> 00:16:33,750
this other port you can talk to me over

00:16:30,750 --> 00:16:37,230
quick and it can also mention the quick

00:16:33,750 --> 00:16:39,540
version support it so that that's quite

00:16:37,230 --> 00:16:41,730
nice and prevents you from having to do

00:16:39,540 --> 00:16:45,089
more round trips to do all that figure

00:16:41,730 --> 00:16:48,149
all of that out and as I mentioned quick

00:16:45,089 --> 00:16:50,970
HTTP is built on HTTP 2 so it's really

00:16:48,149 --> 00:16:53,430
similar semantically but a lot of the

00:16:50,970 --> 00:17:01,620
bits on the wire are slightly different

00:16:53,430 --> 00:17:04,260
I have a interoperability matrix it's a

00:17:01,620 --> 00:17:07,410
really nice visual with coloured cell

00:17:04,260 --> 00:17:09,600
cells and a lot of letters on it so

00:17:07,410 --> 00:17:14,350
really what they do in the working group

00:17:09,600 --> 00:17:16,179
is you might know that the IETF is big

00:17:14,350 --> 00:17:18,549
around the motto rough consensus and

00:17:16,179 --> 00:17:20,649
running code and this really represents

00:17:18,549 --> 00:17:24,130
a running coat part of it so I think

00:17:20,649 --> 00:17:27,459
they're like 15 people or groups that

00:17:24,130 --> 00:17:33,039
are trying to implement quick and this

00:17:27,459 --> 00:17:35,889
matrix has 15 clients on the on the left

00:17:33,039 --> 00:17:38,970
side and 15 servers on the top side and

00:17:35,889 --> 00:17:43,539
then for each combination you can track

00:17:38,970 --> 00:17:45,370
what's working and what's not and it's

00:17:43,539 --> 00:17:47,200
interesting to see the organizations

00:17:45,370 --> 00:17:48,580
that are participating in this so

00:17:47,200 --> 00:17:51,129
there's an there's a mozilla

00:17:48,580 --> 00:17:52,450
implementation there's a fake facebook

00:17:51,129 --> 00:17:55,509
implementation called

00:17:52,450 --> 00:18:00,039
MV FST you might have heard their motto

00:17:55,509 --> 00:18:02,100
move fast and break things there's I

00:18:00,039 --> 00:18:06,460
think Google has an implementation

00:18:02,100 --> 00:18:09,100
CloudFlare Apple and pretty much all of

00:18:06,460 --> 00:18:11,620
these are in C or C++ I think there's

00:18:09,100 --> 00:18:16,169
one in go and one in OGS and then

00:18:11,620 --> 00:18:16,169
there's two in rust one of which is mine

00:18:16,620 --> 00:18:20,889
so I'm back to the table of contents

00:18:19,000 --> 00:18:25,899
second SEC section is on the rust

00:18:20,889 --> 00:18:29,379
ecosystem so that's basically stuff that

00:18:25,899 --> 00:18:32,889
I used in my implementation first thing

00:18:29,379 --> 00:18:36,750
that I used is Russell's so big thanks

00:18:32,889 --> 00:18:39,580
to Joe for making it and also supporting

00:18:36,750 --> 00:18:41,950
me with code reviews while I was putting

00:18:39,580 --> 00:18:44,860
some quick specific stuff in there so

00:18:41,950 --> 00:18:48,850
there's one the transport parameters

00:18:44,860 --> 00:18:52,269
extension that I implemented and I have

00:18:48,850 --> 00:18:55,169
some extensions traits added to the

00:18:52,269 --> 00:18:58,419
client session and server session type

00:18:55,169 --> 00:19:01,509
with which you can during the setup or

00:18:58,419 --> 00:19:06,009
construction of a session type you can

00:19:01,509 --> 00:19:08,259
pass in your own parameters as just as a

00:19:06,009 --> 00:19:11,200
byte feck and then there's another

00:19:08,259 --> 00:19:14,669
method that you can get the beers

00:19:11,200 --> 00:19:16,929
parameters with after the handshake and

00:19:14,669 --> 00:19:19,379
while I was in there I also implemented

00:19:16,929 --> 00:19:25,299
support for the ssl key lock file

00:19:19,379 --> 00:19:27,530
feature so this is a feature where you

00:19:25,299 --> 00:19:30,320
can specify an environment variable

00:19:27,530 --> 00:19:33,560
and that will dump the TLS session

00:19:30,320 --> 00:19:35,180
secrets to a file which is really useful

00:19:33,560 --> 00:19:37,790
when you want to debug what's happening

00:19:35,180 --> 00:19:41,090
in your TLS connection and is for

00:19:37,790 --> 00:19:43,730
example supported by browsers and NSS

00:19:41,090 --> 00:19:45,830
and open SSL and Russell's didn't have

00:19:43,730 --> 00:19:50,120
support yet but it does now if you use

00:19:45,830 --> 00:20:20,330
master now I can see my own slides

00:19:50,120 --> 00:20:22,190
anymore so it makes it even harder ok so

00:20:20,330 --> 00:20:32,030
just try to go in from memory for a

00:20:22,190 --> 00:20:39,430
little bit so I also used that makes my

00:20:32,030 --> 00:20:39,430
practice actually worthwhile there it is

00:20:39,850 --> 00:20:48,230
yes a ring and WebP api PK i keep

00:20:44,330 --> 00:20:50,030
pronouncing it wrong these are things by

00:20:48,230 --> 00:20:52,730
brian smith that sort of underlie

00:20:50,030 --> 00:20:54,440
brussels as well and it's really great

00:20:52,730 --> 00:20:56,780
to be able to use that stuff also

00:20:54,440 --> 00:20:58,460
because we I know that's boring SSL is

00:20:56,780 --> 00:21:00,650
used there so it's I think it's really

00:20:58,460 --> 00:21:03,560
trustworthy stuff even though it might

00:21:00,650 --> 00:21:05,120
not be as mature as your open SSL but in

00:21:03,560 --> 00:21:10,730
terms of security I'm not sure which

00:21:05,120 --> 00:21:13,340
horse I would bet on and so if you get a

00:21:10,730 --> 00:21:15,380
handshake complete in Russells then

00:21:13,340 --> 00:21:17,150
there's a method you can call it I think

00:21:15,380 --> 00:21:18,770
it's called get negotiated cipher suite

00:21:17,150 --> 00:21:23,030
and it basically gives you access to all

00:21:18,770 --> 00:21:26,540
the algorithms in ring so that's really

00:21:23,030 --> 00:21:28,670
nice for something like the quick

00:21:26,540 --> 00:21:32,380
current design of stream zero anyway

00:21:28,670 --> 00:21:35,570
where you can then do the packet payload

00:21:32,380 --> 00:21:40,000
encryption separately without relying on

00:21:35,570 --> 00:21:44,670
the internals of city less stuff

00:21:40,000 --> 00:21:49,570
I also made use of futures Tokyo and H -

00:21:44,670 --> 00:21:52,600
H - is the HTTP - implementation based

00:21:49,570 --> 00:21:55,210
on futures in Tokyo I had worked before

00:21:52,600 --> 00:21:56,940
with futures in Tokyo I met but it was

00:21:55,210 --> 00:22:00,490
relatively simple because they were just

00:21:56,940 --> 00:22:04,300
futures that pulled their internal

00:22:00,490 --> 00:22:06,820
futures for the networking stuff but I

00:22:04,300 --> 00:22:12,100
was looking at how H - implemented their

00:22:06,820 --> 00:22:16,000
API you know how it exposes sort of the

00:22:12,100 --> 00:22:19,720
fake multiplexing that HTTP 2 does to

00:22:16,000 --> 00:22:22,720
the API user and what they do is there's

00:22:19,720 --> 00:22:24,820
a streams object that's part of a

00:22:22,720 --> 00:22:30,700
connection and they give a clone of that

00:22:24,820 --> 00:22:32,230
to the API user and then if you send

00:22:30,700 --> 00:22:34,120
some bytes through that streams object

00:22:32,230 --> 00:22:36,580
the streams object will notify the

00:22:34,120 --> 00:22:39,820
connection and make sure it sends it off

00:22:36,580 --> 00:22:42,790
over the connection so I'm working on a

00:22:39,820 --> 00:22:46,930
similar design of the API for my

00:22:42,790 --> 00:22:49,180
implementation and it's I learned a

00:22:46,930 --> 00:22:53,680
bunch of new stuff about futures in

00:22:49,180 --> 00:22:56,740
Tokyo in the process so that was fun a

00:22:53,680 --> 00:22:59,590
final trip created I use this bytes

00:22:56,740 --> 00:23:06,810
great which has been around for quite a

00:22:59,590 --> 00:23:06,810
while I stole an idea from nice

00:23:09,510 --> 00:23:27,600
I stole an idea from Russells where it

00:23:24,930 --> 00:23:31,110
has a codec trait which knows or

00:23:27,600 --> 00:23:38,280
provides an API for encoding and

00:23:31,110 --> 00:23:39,690
decoding types 2 bytes and I try to or I

00:23:38,280 --> 00:23:42,270
looked at how it was done in Russells

00:23:39,690 --> 00:23:44,280
and also in other crates and they were

00:23:42,270 --> 00:23:46,440
using the buff and buff new traits and

00:23:44,280 --> 00:23:48,390
that's a really neat way of sort of

00:23:46,440 --> 00:23:52,230
keeping track of where you are in a

00:23:48,390 --> 00:23:55,920
buffer and putting bytes in or getting

00:23:52,230 --> 00:23:57,330
bytes out so this is used for all the

00:23:55,920 --> 00:23:59,130
low-level encoding and decoding and

00:23:57,330 --> 00:24:01,140
because quic is trying to be very

00:23:59,130 --> 00:24:03,360
efficient about using bandwidth there's

00:24:01,140 --> 00:24:06,090
a lot of details in the encoding and

00:24:03,360 --> 00:24:07,710
decoding for how to do like variable

00:24:06,090 --> 00:24:12,990
length integer encoding and that kind of

00:24:07,710 --> 00:24:18,240
stuff so there we go into the last

00:24:12,990 --> 00:24:20,580
section the goals for my implementation

00:24:18,240 --> 00:24:22,260
so yes for the past two months I've been

00:24:20,580 --> 00:24:27,330
working on my own implementation of

00:24:22,260 --> 00:24:30,510
quick it's called Quinn it's named after

00:24:27,330 --> 00:24:32,790
a character from a science-fiction book

00:24:30,510 --> 00:24:35,490
which I've done with other projects as

00:24:32,790 --> 00:24:37,470
well the goals for this foundation were

00:24:35,490 --> 00:24:40,590
to first to implement the specification

00:24:37,470 --> 00:24:44,730
faithfully and so we can fill up that

00:24:40,590 --> 00:24:47,430
interoperability matrix which I'll just

00:24:44,730 --> 00:24:53,820
quickly show to you so you have an idea

00:24:47,430 --> 00:24:56,040
of what it looks like a second to have

00:24:53,820 --> 00:25:01,290
clear abstractions and concepts so that

00:24:56,040 --> 00:25:03,480
there will be a good API I think earlier

00:25:01,290 --> 00:25:05,790
it was said that libraries without or

00:25:03,480 --> 00:25:07,530
with with bad documentation aren't

00:25:05,790 --> 00:25:09,840
really that useful currently there is no

00:25:07,530 --> 00:25:12,630
documentation yet so in that sense this

00:25:09,840 --> 00:25:14,580
is not a very useful library but I'm

00:25:12,630 --> 00:25:16,680
trying to get score some points on

00:25:14,580 --> 00:25:19,620
interoperability before I get to

00:25:16,680 --> 00:25:22,200
documentation and it's fully futures

00:25:19,620 --> 00:25:25,770
based there's no polling going on

00:25:22,200 --> 00:25:26,940
and I like to leverage the type system

00:25:25,770 --> 00:25:28,679
for all that stuff since we have this

00:25:26,940 --> 00:25:31,200
good type system might as well well make

00:25:28,679 --> 00:25:35,010
use of it so there's no boolean so it's

00:25:31,200 --> 00:25:37,890
all like enums that's our say the

00:25:35,010 --> 00:25:42,059
direction for this stream is Uni or by

00:25:37,890 --> 00:25:45,660
die and instead of it having some kind

00:25:42,059 --> 00:25:48,990
of boolean that says false or true I was

00:25:45,660 --> 00:25:51,570
really satisfied with my 85% coverage

00:25:48,990 --> 00:25:54,900
until Tyler came along and spoiled all

00:25:51,570 --> 00:25:58,549
my hopes for that so now I'll have to do

00:25:54,900 --> 00:25:58,549
a bunch more stuff to make it better

00:25:59,299 --> 00:26:04,080
this is kind of a nice technique I think

00:26:02,100 --> 00:26:07,260
for figuring out whether the design for

00:26:04,080 --> 00:26:10,799
your code is good to try to figure out

00:26:07,260 --> 00:26:12,330
if there's a nice layering in it so on

00:26:10,799 --> 00:26:13,830
top there's a client in the server that

00:26:12,330 --> 00:26:18,179
should be pretty straightforward and

00:26:13,830 --> 00:26:21,510
conceptually correct what I've done is

00:26:18,179 --> 00:26:24,929
put a connection state object in there

00:26:21,510 --> 00:26:27,380
so because unlike in TCP you are

00:26:24,929 --> 00:26:29,160
typically your servers accepting

00:26:27,380 --> 00:26:31,530
connections and that gets a different

00:26:29,160 --> 00:26:33,240
socket for each connection in quick

00:26:31,530 --> 00:26:34,770
there's just the UDP socket and it's

00:26:33,240 --> 00:26:36,929
just there and you get stuff out of it

00:26:34,770 --> 00:26:38,370
so for a server there's just one socket

00:26:36,929 --> 00:26:41,580
but you have to manage a bunch of

00:26:38,370 --> 00:26:44,010
connections so I've chosen to keep this

00:26:41,580 --> 00:26:46,770
connection state object separate and

00:26:44,010 --> 00:26:50,730
keep the sockets in the client or server

00:26:46,770 --> 00:26:53,250
instead and that also is actually nice

00:26:50,730 --> 00:26:54,960
for testing because you can just sort of

00:26:53,250 --> 00:26:56,160
do all your protocol interactions

00:26:54,960 --> 00:26:59,100
without having to deal with network

00:26:56,160 --> 00:27:02,910
stuff and then there's the parameters

00:26:59,100 --> 00:27:03,600
module which deals with the transport

00:27:02,910 --> 00:27:05,970
parameters

00:27:03,600 --> 00:27:09,630
there's the stream stuff that has the

00:27:05,970 --> 00:27:10,500
strange object TLS is fully abstract in

00:27:09,630 --> 00:27:11,669
the sense that the rest of the

00:27:10,500 --> 00:27:14,580
implementation doesn't know about

00:27:11,669 --> 00:27:17,040
russell's but just deals with what's in

00:27:14,580 --> 00:27:19,530
that module and then the rest of the

00:27:17,040 --> 00:27:24,799
stuff is basically about low-level

00:27:19,530 --> 00:27:24,799
encoding and decoding types two bytes

00:27:25,520 --> 00:27:31,830
mmm current status of the implementation

00:27:27,919 --> 00:27:35,190
I'm targeting draft 11 with TLS 1.3

00:27:31,830 --> 00:27:37,259
draft 28 as most implementations are

00:27:35,190 --> 00:27:39,809
doing right now

00:27:37,259 --> 00:27:42,479
draft 12 was released this week so

00:27:39,809 --> 00:27:43,979
people will move on soon but I think

00:27:42,479 --> 00:27:46,259
there's another interoperability event

00:27:43,979 --> 00:27:51,869
first so for that event people will

00:27:46,259 --> 00:27:53,849
mostly stick to draft 11 the clients my

00:27:51,869 --> 00:27:55,199
clients the Queen client can handshake

00:27:53,849 --> 00:27:58,529
with other servers pretty good pretty

00:27:55,199 --> 00:28:01,769
well other clients with Queen server not

00:27:58,529 --> 00:28:03,929
as well because I made some simplifying

00:28:01,769 --> 00:28:07,979
assumptions that were turn out to be and

00:28:03,929 --> 00:28:10,229
not so interoperable most

00:28:07,979 --> 00:28:13,199
implementations don't have much in the

00:28:10,229 --> 00:28:17,190
way of actual quick HTTP yet so they're

00:28:13,199 --> 00:28:19,579
just throwing HTTP one over one of the

00:28:17,190 --> 00:28:22,109
streams or multiple of the streams and

00:28:19,579 --> 00:28:24,659
in order to be able to test sort of the

00:28:22,109 --> 00:28:26,190
lower-level bits of the protocol I hope

00:28:24,659 --> 00:28:29,190
to keep this implementation moving

00:28:26,190 --> 00:28:34,589
forward that depends a bit on my free

00:28:29,190 --> 00:28:37,259
time it is a big job because there's a

00:28:34,589 --> 00:28:39,479
lot of stuff to deal with which you may

00:28:37,259 --> 00:28:42,929
expect if you're sort of dealing with

00:28:39,479 --> 00:28:46,859
this whole thing that transfers bytes

00:28:42,929 --> 00:28:51,419
across the internet and it's not just

00:28:46,859 --> 00:28:56,579
doing the job of TCP but also a sort of

00:28:51,419 --> 00:28:58,319
reimplementation of HTTP to so it feels

00:28:56,579 --> 00:29:00,089
sort of like fractal complexities

00:28:58,319 --> 00:29:03,629
everywhere you go into detail there's

00:29:00,089 --> 00:29:04,919
more to deal with but I've just been

00:29:03,629 --> 00:29:07,109
taking it from the start of the

00:29:04,919 --> 00:29:10,349
connection and that's seems a workable

00:29:07,109 --> 00:29:13,649
approach there's one other rust

00:29:10,349 --> 00:29:15,449
implementation by Benjamin Saunders I

00:29:13,649 --> 00:29:16,699
had not found it when I started my

00:29:15,449 --> 00:29:21,929
implementation or I may have

00:29:16,699 --> 00:29:23,429
reconsidered doing so he uses open SSL

00:29:21,929 --> 00:29:26,459
instead of Russell's and I think he

00:29:23,429 --> 00:29:28,949
spent way more time hacking open SSL to

00:29:26,459 --> 00:29:31,499
support the extra stuff or the open SSL

00:29:28,949 --> 00:29:35,579
bindings to Russ to support extra stuff

00:29:31,499 --> 00:29:36,929
then I spent on fixing Russell's so at

00:29:35,579 --> 00:29:40,229
some point I want to consider whether it

00:29:36,929 --> 00:29:43,649
makes sense to share more code he has a

00:29:40,229 --> 00:29:46,799
sort of networking less less core and

00:29:43,649 --> 00:29:49,109
then a small Tokio layer on top of it so

00:29:46,799 --> 00:29:49,890
it can also do Tokyo and his

00:29:49,109 --> 00:29:51,810
implementation is

00:29:49,890 --> 00:29:53,100
currently more mature so it handles a

00:29:51,810 --> 00:29:58,380
bunch more stuff in that

00:29:53,100 --> 00:30:00,150
interoperability matrix so if you are

00:29:58,380 --> 00:30:02,720
looking for a fun product project to

00:30:00,150 --> 00:30:06,110
contribute to then consider this one

00:30:02,720 --> 00:30:08,220
I've put some issues in the repository

00:30:06,110 --> 00:30:11,520
even if you don't have much experience

00:30:08,220 --> 00:30:14,000
with rust or networking protocols I'm

00:30:11,520 --> 00:30:17,160
happy to help you get stuff done and

00:30:14,000 --> 00:30:19,980
I'll be here it at the conference for

00:30:17,160 --> 00:30:22,890
the rest of the comfort for the weekend

00:30:19,980 --> 00:30:25,650
and also the imple days or if you want

00:30:22,890 --> 00:30:28,530
to contribute some funding to be able to

00:30:25,650 --> 00:30:30,620
use this in a real setting then I'd also

00:30:28,530 --> 00:30:32,760
be very interested in talking to you

00:30:30,620 --> 00:30:35,510
that's all I have

00:30:32,760 --> 00:30:35,510
thanks

00:30:41,309 --> 00:30:43,370

YouTube URL: https://www.youtube.com/watch?v=EHgyY5DNdvI


