Title: RustFest Paris 2018 -  Vector graphics rendering on the GPU in Rust with Lyon by Nicolas Silva
Publication date: 2018-05-26
Playlist: RustFest Paris 2018
Description: 
	Our next speaker, Nicholas, made
a vector thing that's worth the wait
A renderer for you
and your GPU
Now frenetic applause would be great

Lyon is a collection of low level tools to render 2D vector graphics on the GPU, useful for games as well as other applications benefiting from vector graphics (map renderers, web browsers, graphical user interfaces, creative coding, etc.). This presentation will start with a very short overview of the type of functionalities lyon provides, followed by a deep dive into how lyon approaches rendering and how it relates to other GPU based vector graphics rendering tools.

(Limerick by @llogiq)

https://paris.rustfest.eu/sessions/lyon-vector-graphics-rendering-in-rust
Captions: 
	00:00:05,360 --> 00:00:13,080
our next speaker Nikolas made a web

00:00:09,420 --> 00:00:16,200
thing that's worth wait a renderer for

00:00:13,080 --> 00:00:22,680
you and your GPU now frenetic applause

00:00:16,200 --> 00:00:25,740
would be great thank you so much got

00:00:22,680 --> 00:00:27,990
lots to cover in only 25 minutes to fit

00:00:25,740 --> 00:00:29,850
all that in so without further ado let

00:00:27,990 --> 00:00:33,180
me talk to you about vector graphics and

00:00:29,850 --> 00:00:34,410
rust and the GPU and how to use the GPU

00:00:33,180 --> 00:00:35,760
to to make that happen and in the

00:00:34,410 --> 00:00:38,579
context of that I'm gonna talk about a

00:00:35,760 --> 00:00:42,570
crate I've been working on for maybe I

00:00:38,579 --> 00:00:44,640
don't know like three years and it's

00:00:42,570 --> 00:00:48,270
called video and it's kind of my Arnie

00:00:44,640 --> 00:00:51,450
sort of toy project which I used to make

00:00:48,270 --> 00:00:56,070
to try out ideas and algorithms to

00:00:51,450 --> 00:00:58,469
render vector graphics on the GPU so

00:00:56,070 --> 00:01:00,239
before I get into the details of Leo I

00:00:58,469 --> 00:01:02,850
just want to get the terminology

00:01:00,239 --> 00:01:06,090
straight so on the one hand you have

00:01:02,850 --> 00:01:09,150
raster graphics so typically your your

00:01:06,090 --> 00:01:10,770
you know typical image format like a PNG

00:01:09,150 --> 00:01:13,170
or JPEG like something that you display

00:01:10,770 --> 00:01:19,290
on the screen by using a uniform grid of

00:01:13,170 --> 00:01:21,570
pixels and it you working with uniform

00:01:19,290 --> 00:01:23,250
grids of width of pixels is really

00:01:21,570 --> 00:01:25,920
convenient for a lot of things but also

00:01:23,250 --> 00:01:28,740
comes with some challenges for instance

00:01:25,920 --> 00:01:30,869
you you need to think about the

00:01:28,740 --> 00:01:32,670
resolution at which you offer your

00:01:30,869 --> 00:01:35,220
content and the resolution at which you

00:01:32,670 --> 00:01:37,590
present it and when the two don't match

00:01:35,220 --> 00:01:39,930
which they usually don't you need to

00:01:37,590 --> 00:01:41,430
figure out how to scale your content to

00:01:39,930 --> 00:01:43,590
this to the resolution at which you

00:01:41,430 --> 00:01:45,180
present it and sometimes well you will

00:01:43,590 --> 00:01:48,869
get artifacts like you know a blurry

00:01:45,180 --> 00:01:50,759
mess or a pixelated mess and it's not

00:01:48,869 --> 00:01:54,329
necessarily a very pleasant to deal with

00:01:50,759 --> 00:01:56,670
as a Content author sometimes your your

00:01:54,329 --> 00:01:58,229
resolutions also kind of change

00:01:56,670 --> 00:02:00,750
sometimes you need to you know present

00:01:58,229 --> 00:02:03,450
on a phone or on a PC with different

00:02:00,750 --> 00:02:05,100
sort of screen sizes and and raster

00:02:03,450 --> 00:02:08,040
graphics is sort of like the fundamental

00:02:05,100 --> 00:02:10,470
building block of presenting anything on

00:02:08,040 --> 00:02:12,780
the screen but for thering it has like a

00:02:10,470 --> 00:02:16,050
few a few disadvantages

00:02:12,780 --> 00:02:18,220
fala size being one of one of them as

00:02:16,050 --> 00:02:20,890
well but on the other hand you

00:02:18,220 --> 00:02:24,460
vector graphics and when I talk about

00:02:20,890 --> 00:02:28,000
vector graphics well think about it as

00:02:24,460 --> 00:02:29,620
you know the SVG file that will you will

00:02:28,000 --> 00:02:32,620
author using you know Inkscape

00:02:29,620 --> 00:02:36,850
illustrator this kind of software but

00:02:32,620 --> 00:02:40,210
but also like beyond that like HTML and

00:02:36,850 --> 00:02:41,650
CSS I consider to be you know a vector

00:02:40,210 --> 00:02:45,370
format in the sense that instead of

00:02:41,650 --> 00:02:47,500
specifying pixel colors everywhere you

00:02:45,370 --> 00:02:49,750
will say I I want to put some text there

00:02:47,500 --> 00:02:51,970
and to put some a box here and it's it

00:02:49,750 --> 00:02:53,890
has this color and and the way you

00:02:51,970 --> 00:02:55,510
author your content usually doesn't

00:02:53,890 --> 00:02:58,000
really depend on the resolution of the

00:02:55,510 --> 00:02:59,980
screen or at least it's not like it can

00:02:58,000 --> 00:03:04,090
more easily scale to different

00:02:59,980 --> 00:03:05,440
resolution and so that little thingy

00:03:04,090 --> 00:03:07,360
that I had on the previous slide didn't

00:03:05,440 --> 00:03:09,310
look like much but when you add a lot of

00:03:07,360 --> 00:03:13,490
it you end up with this ghost script

00:03:09,310 --> 00:03:14,640
tiger that is always present in any

00:03:13,490 --> 00:03:18,520
[Music]

00:03:14,640 --> 00:03:18,820
vector graphics presentation so there it

00:03:18,520 --> 00:03:22,570
is

00:03:18,820 --> 00:03:25,150
in my case on a day to day basis you you

00:03:22,570 --> 00:03:28,000
guys interact with vector graphics

00:03:25,150 --> 00:03:29,620
content like all the time for instance I

00:03:28,000 --> 00:03:33,400
I was talking about web browsers in web

00:03:29,620 --> 00:03:34,960
pages but also Maps typically will make

00:03:33,400 --> 00:03:36,820
use of vector graphics because this kind

00:03:34,960 --> 00:03:38,620
of content needs to be transferred over

00:03:36,820 --> 00:03:40,960
the network and vector graphics are like

00:03:38,620 --> 00:03:43,360
a more sort of expressive and compact

00:03:40,960 --> 00:03:45,760
representation that is independent of

00:03:43,360 --> 00:03:48,820
the resolution so let me see if it can

00:03:45,760 --> 00:03:52,020
zoom on that thing right so this is an

00:03:48,820 --> 00:03:55,300
SVG that I exported from from

00:03:52,020 --> 00:03:56,710
OpenStreetMap and as you zoom on it you

00:03:55,300 --> 00:04:01,720
can see that it doesn't turn into a

00:03:56,710 --> 00:04:04,390
blurry mess or a pixelated thing and but

00:04:01,720 --> 00:04:07,150
it doesn't stop there like all of your

00:04:04,390 --> 00:04:11,020
apps nowadays like modern apps use

00:04:07,150 --> 00:04:13,720
vector graphics for icons for text for

00:04:11,020 --> 00:04:16,600
you know rendering diagrams for you know

00:04:13,720 --> 00:04:19,750
all of the UI typically now is is you

00:04:16,600 --> 00:04:21,310
know directives to render things rather

00:04:19,750 --> 00:04:25,630
than just oh here is an image that

00:04:21,310 --> 00:04:27,130
represents the entire thing and and you

00:04:25,630 --> 00:04:29,320
if you think about it if you if you took

00:04:27,130 --> 00:04:31,240
that diagram right there and and as an

00:04:29,320 --> 00:04:33,100
author decided to be

00:04:31,240 --> 00:04:35,259
this diagram into an image and then ship

00:04:33,100 --> 00:04:36,610
that to the users that would be a

00:04:35,259 --> 00:04:37,840
terrible workflow and you wouldn't be

00:04:36,610 --> 00:04:39,819
able to do interesting things like

00:04:37,840 --> 00:04:42,419
animating that diagram or you know

00:04:39,819 --> 00:04:45,880
making transitions or or whatnot

00:04:42,419 --> 00:04:47,380
video games are also an area where where

00:04:45,880 --> 00:04:48,370
you can do fun things with vector

00:04:47,380 --> 00:04:52,870
graphics right

00:04:48,370 --> 00:04:55,780
you could have interesting gameplay

00:04:52,870 --> 00:04:58,599
mechanics that rely on the idea of

00:04:55,780 --> 00:05:00,970
having of presenting things at different

00:04:58,599 --> 00:05:04,150
scales for instance what if I want to

00:05:00,970 --> 00:05:07,180
zoom on that Lady Bird over there right

00:05:04,150 --> 00:05:09,160
um you can do interesting things with

00:05:07,180 --> 00:05:12,070
vector graphics and and again the file

00:05:09,160 --> 00:05:16,660
size is a big issue for for video games

00:05:12,070 --> 00:05:18,699
today be it 2d or 3d games they tend to

00:05:16,660 --> 00:05:22,659
ship gigabytes and gigabytes of texture

00:05:18,699 --> 00:05:24,190
memory these days and and if you start

00:05:22,659 --> 00:05:27,880
thinking about in terms of vector

00:05:24,190 --> 00:05:29,949
graphics then you can you can make that

00:05:27,880 --> 00:05:32,349
like a lot smaller and maybe even think

00:05:29,949 --> 00:05:35,349
about shipping your game over over the

00:05:32,349 --> 00:05:37,330
network which it's really hard like if

00:05:35,349 --> 00:05:40,330
you if you try to if for instance you

00:05:37,330 --> 00:05:43,180
yourself try to you know publish Rayman

00:05:40,330 --> 00:05:44,740
origin on web browser that will have

00:05:43,180 --> 00:05:46,210
they would have this like oh we have ten

00:05:44,740 --> 00:05:47,620
gigabytes of texture memory that we need

00:05:46,210 --> 00:05:51,039
to string over the network and that's a

00:05:47,620 --> 00:05:52,930
bit of an issue and and you could do a

00:05:51,039 --> 00:05:56,110
lot of stuff that you you don't usually

00:05:52,930 --> 00:05:58,810
see on a lot of games 2d games because

00:05:56,110 --> 00:06:01,330
of the the the problem you know of being

00:05:58,810 --> 00:06:04,090
fixed to a certain resolution for

00:06:01,330 --> 00:06:07,060
instance maybe assume in a character and

00:06:04,090 --> 00:06:09,940
better to better show like expressions

00:06:07,060 --> 00:06:11,409
and put some end phase and and and sort

00:06:09,940 --> 00:06:15,759
of in hence the the storytelling that

00:06:11,409 --> 00:06:17,580
way but the challenge with working with

00:06:15,759 --> 00:06:20,440
vector graphics everywhere is that

00:06:17,580 --> 00:06:23,400
today's computers and phones and and

00:06:20,440 --> 00:06:27,250
screens in general have a lot of pixels

00:06:23,400 --> 00:06:30,789
really a lot of them and they be it

00:06:27,250 --> 00:06:33,849
you're really underpowered CPU on the

00:06:30,789 --> 00:06:36,580
phone or overpowered a CPU on your

00:06:33,849 --> 00:06:38,440
computer they actually struggle to go

00:06:36,580 --> 00:06:40,539
through these 4k screen and you know

00:06:38,440 --> 00:06:42,639
like set the color of every pixels at

00:06:40,539 --> 00:06:44,889
interactive framerate

00:06:42,639 --> 00:06:46,860
if you if you think about this this

00:06:44,889 --> 00:06:50,139
tiger thing that I showed you earlier

00:06:46,860 --> 00:06:56,169
it's built upon layers and layers and

00:06:50,139 --> 00:06:58,569
layers of shapes which which means that

00:06:56,169 --> 00:07:00,159
if you draw things back to front you

00:06:58,569 --> 00:07:02,710
will you're gonna touch like pixels

00:07:00,159 --> 00:07:06,159
quite quite a few times and you're gonna

00:07:02,710 --> 00:07:09,789
hit this memory bandwidth limit that is

00:07:06,159 --> 00:07:14,400
it's pretty hard good to get by on a 4k

00:07:09,789 --> 00:07:20,590
screen whatever the power of your CPU is

00:07:14,400 --> 00:07:26,169
so how did we go about fixing this this

00:07:20,590 --> 00:07:27,580
is this is interesting okay so if you

00:07:26,169 --> 00:07:29,500
look at the games industry they actually

00:07:27,580 --> 00:07:32,310
had to solve this problem and if solved

00:07:29,500 --> 00:07:35,229
it like a while ago already video games

00:07:32,310 --> 00:07:37,690
most of them tend to refresh the entire

00:07:35,229 --> 00:07:40,330
screen at Interactive's frame rates and

00:07:37,690 --> 00:07:43,330
they they managed to pull that off at

00:07:40,330 --> 00:07:44,979
very high resolutions as well so maybe

00:07:43,330 --> 00:07:46,840
there are things that we can learn from

00:07:44,979 --> 00:07:48,870
the ways they've been able to fix this

00:07:46,840 --> 00:07:52,120
and

00:07:48,870 --> 00:07:54,879
nowadays like most of the video games

00:07:52,120 --> 00:07:56,919
like 99.999999% of the video games that

00:07:54,879 --> 00:08:01,900
ship today they all make use of the the

00:07:56,919 --> 00:08:03,069
GPU and and to be fair you should sort

00:08:01,900 --> 00:08:06,460
of present it the other way actually

00:08:03,069 --> 00:08:08,680
like how do our manufacturers make GPUs

00:08:06,460 --> 00:08:13,029
so that you can play games and these

00:08:08,680 --> 00:08:14,379
GPUs are made to perform a certain

00:08:13,029 --> 00:08:17,229
certain kinds of things really really

00:08:14,379 --> 00:08:20,620
fast so that you can play games and if

00:08:17,229 --> 00:08:22,449
as a web browser or an application that

00:08:20,620 --> 00:08:25,509
needs to render vector graphics we can

00:08:22,449 --> 00:08:28,419
leverage what the hardware vendors have

00:08:25,509 --> 00:08:30,520
built for game developers then then

00:08:28,419 --> 00:08:31,260
maybe wiki we're hunting we're onto

00:08:30,520 --> 00:08:35,079
something

00:08:31,260 --> 00:08:37,570
so the basic primitive that all video

00:08:35,079 --> 00:08:41,289
games are based on these days is

00:08:37,570 --> 00:08:45,130
triangles like meshes are what we call a

00:08:41,289 --> 00:08:49,660
mesh is the way we that we represent

00:08:45,130 --> 00:08:51,699
these 3d models you know by like

00:08:49,660 --> 00:08:53,560
representing them with with triangles

00:08:51,699 --> 00:08:55,089
around the surface and then you know

00:08:53,560 --> 00:08:57,430
supplying some textures on them

00:08:55,089 --> 00:09:02,050
and then animating that in a 3d world

00:08:57,430 --> 00:09:04,180
and GPUs are pretty much designed to

00:09:02,050 --> 00:09:06,850
render triangles very fast and touch a

00:09:04,180 --> 00:09:10,059
lot of pixels very fast using triangle

00:09:06,850 --> 00:09:12,759
rasterization so that's interesting what

00:09:10,059 --> 00:09:15,459
can we do with this another thing that I

00:09:12,759 --> 00:09:17,199
want to touch on quickly and and if I

00:09:15,459 --> 00:09:19,360
have time I'll sort of get back to that

00:09:17,199 --> 00:09:23,850
towards the end of this presentation is

00:09:19,360 --> 00:09:27,459
that in order to solve the problem of

00:09:23,850 --> 00:09:31,689
things being rendered in in the front

00:09:27,459 --> 00:09:33,100
and in the back in the 3d world the how

00:09:31,689 --> 00:09:36,100
to Ravenna came up with this idea of

00:09:33,100 --> 00:09:38,709
having a def buffer so like this or

00:09:36,100 --> 00:09:41,529
z-buffer as as we sometimes call it

00:09:38,709 --> 00:09:45,279
which is kind of like a buffer that

00:09:41,529 --> 00:09:47,470
contains the depth of every pixel and so

00:09:45,279 --> 00:09:48,790
it lets you make sure that if you draw

00:09:47,470 --> 00:09:50,920
something and it's behind something that

00:09:48,790 --> 00:09:52,449
you've already drawn then the pixels

00:09:50,920 --> 00:09:54,160
they're behind are gonna be discarded

00:09:52,449 --> 00:09:57,759
rather than covering the thing that

00:09:54,160 --> 00:09:59,620
you've already drawn and it started as a

00:09:57,759 --> 00:10:00,759
way to sort of solve the problem or of

00:09:59,620 --> 00:10:05,470
rendering 3d worlds

00:10:00,759 --> 00:10:09,639
but it actually ended up being a great

00:10:05,470 --> 00:10:10,749
tool to avoid writing into memory it's

00:10:09,639 --> 00:10:12,519
actually a lot more complicated than

00:10:10,749 --> 00:10:14,139
like just a buffer in memory like the

00:10:12,519 --> 00:10:16,379
hardware it's like really hand-tuned and

00:10:14,139 --> 00:10:20,379
optimized it's you know your kacal

00:10:16,379 --> 00:10:22,540
representation it all tries to avoid as

00:10:20,379 --> 00:10:24,249
much memory bandwidth traffic as

00:10:22,540 --> 00:10:27,610
possible because this is pretty much the

00:10:24,249 --> 00:10:29,649
the bottleneck in video games today so

00:10:27,610 --> 00:10:35,920
how do we go about doing this kind of

00:10:29,649 --> 00:10:38,519
stuff in lyon ru is based on the same

00:10:35,920 --> 00:10:41,410
idea as those video game video games

00:10:38,519 --> 00:10:43,959
which is to take vector graphics and

00:10:41,410 --> 00:10:46,269
turn them into this soup of triangles

00:10:43,959 --> 00:10:48,009
this this triangle mesh that you can

00:10:46,269 --> 00:10:51,579
feed the GPU and then the GPU gets

00:10:48,009 --> 00:10:54,550
really good it's rendering them and this

00:10:51,579 --> 00:10:56,170
process of taking a shape you know an

00:10:54,550 --> 00:11:00,249
SVG path or what-have-you

00:10:56,170 --> 00:11:02,290
into a triangle mesh is called

00:11:00,249 --> 00:11:04,990
tessellation sometimes people also call

00:11:02,290 --> 00:11:09,180
it triangulation

00:11:04,990 --> 00:11:11,730
so generating the tessellation for

00:11:09,180 --> 00:11:14,200
convex polygons is actually quite easy

00:11:11,730 --> 00:11:15,820
you can just pick of ethics and then

00:11:14,200 --> 00:11:18,670
loop through the other vertex in order

00:11:15,820 --> 00:11:21,060
and then just you know add triangles and

00:11:18,670 --> 00:11:24,700
it will work out but most interesting

00:11:21,060 --> 00:11:28,180
path or vector shapes are are not convex

00:11:24,700 --> 00:11:29,380
at all so we need to to figure something

00:11:28,180 --> 00:11:32,650
out for this

00:11:29,380 --> 00:11:35,050
we can't just like take an edge and then

00:11:32,650 --> 00:11:36,970
take a neighbor edge and then make a

00:11:35,050 --> 00:11:39,910
triangle out of the two because you

00:11:36,970 --> 00:11:42,640
might intersect with other edges that

00:11:39,910 --> 00:11:44,410
are in their shape that are actually

00:11:42,640 --> 00:11:49,090
quite far away and in the loop of

00:11:44,410 --> 00:11:52,120
vertices and so we need to sort of come

00:11:49,090 --> 00:11:54,130
up with a solution that is able to sort

00:11:52,120 --> 00:11:56,920
of look at pixels that are pixel sorry

00:11:54,130 --> 00:11:59,980
to look at vertices that are nearby and

00:11:56,920 --> 00:12:02,530
and figure out how to add triangles that

00:11:59,980 --> 00:12:07,240
don't you know cover pixels that are

00:12:02,530 --> 00:12:09,760
outside of the shape and already if I if

00:12:07,240 --> 00:12:12,130
we take a step back we can see that like

00:12:09,760 --> 00:12:14,680
this is a bit of a like at the heart of

00:12:12,130 --> 00:12:19,230
it it's a problem of figuring out

00:12:14,680 --> 00:12:19,230
intersection and actually avoiding them

00:12:19,320 --> 00:12:26,170
there is one kind of polygon that is

00:12:22,980 --> 00:12:29,950
that has interesting properties it's not

00:12:26,170 --> 00:12:32,890
as easy as convex polygons but it's but

00:12:29,950 --> 00:12:36,160
it will turn out useful it's what I call

00:12:32,890 --> 00:12:37,960
why monotone polygons you can also have

00:12:36,160 --> 00:12:39,670
X monotone polygons basically the idea

00:12:37,960 --> 00:12:41,740
is you want to have polygons that are

00:12:39,670 --> 00:12:46,300
monotone along a certain axis and in the

00:12:41,740 --> 00:12:50,140
case of the UM I'm using the y-axis a Y

00:12:46,300 --> 00:12:54,000
mono and polygon basically the idea is

00:12:50,140 --> 00:12:58,090
that if you draw an a horizontal line

00:12:54,000 --> 00:13:01,830
anywhere in the plane it will intersect

00:12:58,090 --> 00:13:05,670
with the the polygons at most twice

00:13:01,830 --> 00:13:09,700
which which is interesting because

00:13:05,670 --> 00:13:11,260
basically at any height if you if you

00:13:09,700 --> 00:13:17,660
intersect with the polygon there is

00:13:11,260 --> 00:13:20,870
always a left and a right side and the

00:13:17,660 --> 00:13:23,570
sort of makes it easy to go through your

00:13:20,870 --> 00:13:25,850
shape and you know add triangles in

00:13:23,570 --> 00:13:27,680
between like ping ponging in between the

00:13:25,850 --> 00:13:29,030
left and the right side because you you

00:13:27,680 --> 00:13:30,980
know by definition that there's nothing

00:13:29,030 --> 00:13:33,590
in between that's gonna produce

00:13:30,980 --> 00:13:35,720
intersections that you don't want for

00:13:33,590 --> 00:13:38,090
instance this is not a monotone polygon

00:13:35,720 --> 00:13:41,030
because it adds like this type of you

00:13:38,090 --> 00:13:43,430
know vertices this is what I call a

00:13:41,030 --> 00:13:45,830
merge that vertex so this is where like

00:13:43,430 --> 00:13:49,610
to sort of shape sort of merge together

00:13:45,830 --> 00:13:51,890
and this is a split vertex this is where

00:13:49,610 --> 00:13:56,510
like the the things sort of splits into

00:13:51,890 --> 00:13:59,750
two things and in terms of algorithms if

00:13:56,510 --> 00:14:02,930
we can figure out how to decompose

00:13:59,750 --> 00:14:06,140
polygons so that we don't have any merge

00:14:02,930 --> 00:14:08,810
vertex or split vertex then we might be

00:14:06,140 --> 00:14:12,050
onto something and there is a pretty

00:14:08,810 --> 00:14:13,940
efficient algorithm for doing this which

00:14:12,050 --> 00:14:15,560
I'm gonna give you sort of a bit of a

00:14:13,940 --> 00:14:18,800
walkthrough it's actually like more of a

00:14:15,560 --> 00:14:20,390
run-through and I'm gonna it's very like

00:14:18,800 --> 00:14:23,210
I'm gonna oversimplify all of this

00:14:20,390 --> 00:14:25,760
because if I had to explain the entire

00:14:23,210 --> 00:14:27,080
algorithm it would be taking like three

00:14:25,760 --> 00:14:30,590
hours and it would be painful for

00:14:27,080 --> 00:14:32,870
everyone in this room including me so

00:14:30,590 --> 00:14:35,560
what I just want is to give you sort of

00:14:32,870 --> 00:14:37,730
a an intuition of how these things work

00:14:35,560 --> 00:14:39,920
when you go home tonight you probably

00:14:37,730 --> 00:14:42,410
won't be like oh I'm coding a monotone

00:14:39,920 --> 00:14:44,990
Desolator before I'm before going to

00:14:42,410 --> 00:14:46,310
sleep but at least you'll have some sort

00:14:44,990 --> 00:14:50,210
of an intuition of how this works

00:14:46,310 --> 00:14:52,550
so imagine a horizontal line an image

00:14:50,210 --> 00:14:54,610
imaginary horizontal line that goes

00:14:52,550 --> 00:14:59,840
through your geometry from top to bottom

00:14:54,610 --> 00:15:02,230
and as we stop at each vertex we

00:14:59,840 --> 00:15:04,910
remember the list of all of the vertices

00:15:02,230 --> 00:15:07,340
that intersect with this image in your a

00:15:04,910 --> 00:15:10,790
line which I will from now on call the

00:15:07,340 --> 00:15:13,360
sweep line and and so we add those those

00:15:10,790 --> 00:15:18,590
edges to that list and then as we

00:15:13,360 --> 00:15:21,110
proceed we remove edges and that were

00:15:18,590 --> 00:15:22,820
that are not intersecting anymore from

00:15:21,110 --> 00:15:25,250
from the sweep line so for instance in

00:15:22,820 --> 00:15:26,960
this in this case and the step nerd

00:15:25,250 --> 00:15:29,600
number two I have this guy in the sweep

00:15:26,960 --> 00:15:31,670
line I have I just introduced and this

00:15:29,600 --> 00:15:35,690
this guy over there

00:15:31,670 --> 00:15:41,660
the green one and I'm removing the the

00:15:35,690 --> 00:15:44,030
edge on the left for I truly apologize

00:15:41,660 --> 00:15:47,360
for anyone who cannot see the slides or

00:15:44,030 --> 00:15:48,770
cannot see colors because uh I didn't

00:15:47,360 --> 00:15:52,190
really think about that when I was

00:15:48,770 --> 00:15:56,870
making the presentation so as we go

00:15:52,190 --> 00:15:59,270
through in Y order we maintain that list

00:15:56,870 --> 00:16:01,490
and then eventually we run into one of

00:15:59,270 --> 00:16:05,240
those vertices that we don't want to

00:16:01,490 --> 00:16:08,000
have a norm on polygons so as this

00:16:05,240 --> 00:16:09,620
dramatic red background indicates we're

00:16:08,000 --> 00:16:13,100
into a place where we need to do

00:16:09,620 --> 00:16:15,650
something and thanks to the nature and

00:16:13,100 --> 00:16:17,030
the structure of this sorted list of

00:16:15,650 --> 00:16:21,950
edges that we have in our swept line

00:16:17,030 --> 00:16:24,110
it's very easy to find the next edge

00:16:21,950 --> 00:16:25,910
that is directly on the left of the

00:16:24,110 --> 00:16:28,760
current vertex that we want to connect

00:16:25,910 --> 00:16:32,000
to something then go up that edge say

00:16:28,760 --> 00:16:34,760
select this vertex and then insert a new

00:16:32,000 --> 00:16:39,740
edge there and now we're happy because

00:16:34,760 --> 00:16:41,960
we we no longer have this this split

00:16:39,740 --> 00:16:43,850
vertex that was there was making us so

00:16:41,960 --> 00:16:49,700
sad and having like a red background at

00:16:43,850 --> 00:16:53,960
all so we continue we continue and we

00:16:49,700 --> 00:16:56,180
run into another instance of a type of

00:16:53,960 --> 00:17:00,050
vertex that we don't want the infamous

00:16:56,180 --> 00:17:03,140
merge back vertex and again we have our

00:17:00,050 --> 00:17:05,630
dramatic red background but in this

00:17:03,140 --> 00:17:09,470
instance there is actually nothing that

00:17:05,630 --> 00:17:13,190
we can do because if we were to try to

00:17:09,470 --> 00:17:16,940
connect this guy with some other vertex

00:17:13,190 --> 00:17:18,980
that we've visited before then we

00:17:16,940 --> 00:17:22,790
wouldn't be well like we would still

00:17:18,980 --> 00:17:24,530
have this this sort of v-shaped merge

00:17:22,790 --> 00:17:25,010
vertex that we that we're trying to

00:17:24,530 --> 00:17:27,140
avoid

00:17:25,010 --> 00:17:28,670
so we have to remember that there's a

00:17:27,140 --> 00:17:31,400
merge vertex that we need to resolve

00:17:28,670 --> 00:17:36,620
later and as it turns out in the next

00:17:31,400 --> 00:17:38,390
iteration I am under I am under this

00:17:36,620 --> 00:17:40,940
this merge vertex which means that

00:17:38,390 --> 00:17:44,300
basically I am at a point that is

00:17:40,940 --> 00:17:45,020
between those two edges that are like

00:17:44,300 --> 00:17:46,670
around this

00:17:45,020 --> 00:17:48,620
this much of that sex you probably guess

00:17:46,670 --> 00:17:53,240
probably don't see the bottom of the

00:17:48,620 --> 00:17:55,220
slates very much sorry about that and we

00:17:53,240 --> 00:17:57,500
we remembered that we had something to

00:17:55,220 --> 00:18:00,670
fix up there we insert a new edge and

00:17:57,500 --> 00:18:04,070
there we go we have or monotone polygons

00:18:00,670 --> 00:18:05,660
the utakome decomposed and so this is

00:18:04,070 --> 00:18:09,890
like sort of the general idea of the

00:18:05,660 --> 00:18:11,330
algorithm and it's it's been like sort

00:18:09,890 --> 00:18:14,210
of documented in the literature like

00:18:11,330 --> 00:18:16,100
forever this this pretty good literature

00:18:14,210 --> 00:18:19,670
about this so if you're interested you

00:18:16,100 --> 00:18:22,420
can look into this one thing that is

00:18:19,670 --> 00:18:25,430
interesting about Leon is that um I

00:18:22,420 --> 00:18:30,200
started by implementing like so the the

00:18:25,430 --> 00:18:32,960
naive and common algorithm for first

00:18:30,200 --> 00:18:35,300
figuring this stuff out and basically

00:18:32,960 --> 00:18:38,360
it's it's composed of three phases in

00:18:35,300 --> 00:18:40,010
the first phase you you need to take

00:18:38,360 --> 00:18:42,620
your arbitrary shape that might have

00:18:40,010 --> 00:18:45,020
self intersections and resolve your your

00:18:42,620 --> 00:18:47,270
self intersections and decompose your

00:18:45,020 --> 00:18:48,920
polygon into polygons that don't have so

00:18:47,270 --> 00:18:50,540
like into several polygons that don't

00:18:48,920 --> 00:18:52,130
have self intersections then you go

00:18:50,540 --> 00:18:53,720
through each of these polygons and you

00:18:52,130 --> 00:18:56,570
do this this monotone polygon the

00:18:53,720 --> 00:18:58,280
compositing that I just showed you and

00:18:56,570 --> 00:19:00,380
then you go through all of those

00:18:58,280 --> 00:19:04,340
monotone polygons and you do this this

00:19:00,380 --> 00:19:05,990
ping-ponging of the to insert the the

00:19:04,340 --> 00:19:10,850
actual triangles that are the output of

00:19:05,990 --> 00:19:15,140
your algorithm and so I implemented this

00:19:10,850 --> 00:19:16,940
and it was working okay the performance

00:19:15,140 --> 00:19:21,620
was sort of on par with what the other

00:19:16,940 --> 00:19:25,810
tessa leaders we're doing but if you

00:19:21,620 --> 00:19:28,490
think about it all of those passes are

00:19:25,810 --> 00:19:31,340
processing their input and producing

00:19:28,490 --> 00:19:34,760
their outputs in the same order like top

00:19:31,340 --> 00:19:36,560
to bottom so if you sit down for a bit

00:19:34,760 --> 00:19:39,050
and actually I had to sit down for a

00:19:36,560 --> 00:19:40,820
long time you can concatenate this

00:19:39,050 --> 00:19:42,740
algorithm into a single pass algorithm

00:19:40,820 --> 00:19:45,020
and to my knowledge

00:19:42,740 --> 00:19:47,960
Lois is actually the only implementation

00:19:45,020 --> 00:19:50,150
of a monotone polygon decelerator that

00:19:47,960 --> 00:19:52,010
runs into a single pass but as a result

00:19:50,150 --> 00:19:53,740
of that it's on average twice faster

00:19:52,010 --> 00:19:55,970
than the other tessa waiters that i

00:19:53,740 --> 00:19:57,799
benchmarked it against so

00:19:55,970 --> 00:20:00,679
and I'm pretty happy about this but in

00:19:57,799 --> 00:20:04,250
order to do this at running to more edge

00:20:00,679 --> 00:20:07,690
cases and basically the algorithm from

00:20:04,250 --> 00:20:11,840
their owns like diverge like a lot from

00:20:07,690 --> 00:20:15,470
the sort of official common monofin pong

00:20:11,840 --> 00:20:18,080
and tessellation algorithm so it's a

00:20:15,470 --> 00:20:22,059
pretty unique algorithm actually so now

00:20:18,080 --> 00:20:26,750
let's look at what things look like when

00:20:22,059 --> 00:20:29,149
we take the triangle view of something

00:20:26,750 --> 00:20:31,309
that we've tessellated oh by the way I

00:20:29,149 --> 00:20:33,529
didn't I forgot to tell you but this

00:20:31,309 --> 00:20:42,289
this entire slide deck is a rust program

00:20:33,529 --> 00:20:44,779
that uses Lyon to render SVG elements so

00:20:42,289 --> 00:20:47,659
if I press W I can see the wireframe

00:20:44,779 --> 00:20:53,509
view I can you know like do this in any

00:20:47,659 --> 00:20:55,909
slide and it was a terrible idea but but

00:20:53,509 --> 00:20:59,059
I'm happy about it anyways

00:20:55,909 --> 00:21:01,909
so like the in case of maps I think

00:20:59,059 --> 00:21:04,009
that's sort of like it I really like

00:21:01,909 --> 00:21:06,830
this this kind of view it's it's kind of

00:21:04,009 --> 00:21:08,269
fun to see like how this what would we

00:21:06,830 --> 00:21:11,539
actually sending for the GPU is those

00:21:08,269 --> 00:21:12,889
triangles right there let's look at this

00:21:11,539 --> 00:21:15,049
guy because I spent like three hours

00:21:12,889 --> 00:21:20,320
drawing that thing so I want to show it

00:21:15,049 --> 00:21:20,320
to you again right I just lets you know

00:21:22,010 --> 00:21:31,190
and and in in this case actually for for

00:21:28,639 --> 00:21:32,690
the benefit of the demo like I was

00:21:31,190 --> 00:21:38,179
talking about resolution independence

00:21:32,690 --> 00:21:41,090
but i zoom in to things like you're

00:21:38,179 --> 00:21:42,830
gonna start seeing angles and and this

00:21:41,090 --> 00:21:45,500
is supposed to be like perfectly round

00:21:42,830 --> 00:21:47,450
this is because right now the only

00:21:45,500 --> 00:21:51,139
worked with polygons and doesn't work

00:21:47,450 --> 00:21:53,120
with curse and so in order to render

00:21:51,139 --> 00:21:57,169
curves I first have to flatten curves

00:21:53,120 --> 00:22:00,860
into you know a series of line segments

00:21:57,169 --> 00:22:02,480
and this is deffend of the resolution so

00:22:00,860 --> 00:22:04,399
normally what you want to do is as

00:22:02,480 --> 00:22:07,309
people zoom you let sort of re

00:22:04,399 --> 00:22:08,870
tessellate things so that the thing is

00:22:07,309 --> 00:22:10,429
always sort of like nice and round but

00:22:08,870 --> 00:22:11,929
for the day if I did this and then I

00:22:10,429 --> 00:22:14,389
couldn't I couldn't

00:22:11,929 --> 00:22:16,490
zoom on the demo and have you like have

00:22:14,389 --> 00:22:21,950
a look at the beautiful triangles of

00:22:16,490 --> 00:22:24,139
that ladybird over there so I actually I

00:22:21,950 --> 00:22:26,179
was talking about about the the filling

00:22:24,139 --> 00:22:28,279
algorithm we can do the same thing for

00:22:26,179 --> 00:22:30,669
strokes strokes are actually like a lot

00:22:28,279 --> 00:22:32,840
easier we just follow the path and

00:22:30,669 --> 00:22:36,019
insert a strip of triangles along the

00:22:32,840 --> 00:22:39,110
thing and then for joins and and caps we

00:22:36,019 --> 00:22:40,399
we just do some specific distillation

00:22:39,110 --> 00:22:43,549
depending on what kind of stuff that we

00:22:40,399 --> 00:22:48,320
want to do Lyon currently supports the

00:22:43,549 --> 00:22:50,389
typical things I can do in SVG it's a

00:22:48,320 --> 00:22:52,820
very simple extort okay I'll go rhythm

00:22:50,389 --> 00:22:54,980
is very simple it's actually something I

00:22:52,820 --> 00:22:59,590
did more just because but I was more

00:22:54,980 --> 00:23:02,539
interested in the filling algorithm I'm

00:22:59,590 --> 00:23:05,720
starting to run out of time so I'm gonna

00:23:02,539 --> 00:23:08,179
quickly glance over this this one so

00:23:05,720 --> 00:23:09,440
this is a slide that I took from a web

00:23:08,179 --> 00:23:13,429
brand represents a shinai gave a little

00:23:09,440 --> 00:23:15,610
while ago and the main idea is that if

00:23:13,429 --> 00:23:19,549
we're gonna render things back to front

00:23:15,610 --> 00:23:21,470
which sort of makes sense from like it's

00:23:19,549 --> 00:23:22,880
it's kind of intuitive to you know go

00:23:21,470 --> 00:23:24,230
through we're seeing render things back

00:23:22,880 --> 00:23:27,440
to phones so that you don't have like

00:23:24,230 --> 00:23:28,490
something stomping over there something

00:23:27,440 --> 00:23:30,500
that should be on the front of it right

00:23:28,490 --> 00:23:32,330
but if you do this it means that you're

00:23:30,500 --> 00:23:35,020
gonna touch pixels a lot of a lot of

00:23:32,330 --> 00:23:37,180
times and if you make shapes

00:23:35,020 --> 00:23:40,360
and it's sort of wasteful to draw

00:23:37,180 --> 00:23:43,990
something and to cover it in the next in

00:23:40,360 --> 00:23:46,450
the next roll call so what we did with

00:23:43,990 --> 00:23:48,730
web render and I think is a technique

00:23:46,450 --> 00:23:49,780
that sort of lends itself naturally to

00:23:48,730 --> 00:23:52,510
work very well with the kind of

00:23:49,780 --> 00:23:55,660
tessellation that we do in Lyon is to

00:23:52,510 --> 00:24:00,700
render opaque shapes back to front

00:23:55,660 --> 00:24:03,400
no front to back sorry so that as you

00:24:00,700 --> 00:24:07,180
render things underneath it then the the

00:24:03,400 --> 00:24:09,220
GPU hardware can optimize a way of

00:24:07,180 --> 00:24:11,860
writing some memory which is your your

00:24:09,220 --> 00:24:15,580
bottleneck and so this is a technique

00:24:11,860 --> 00:24:17,140
that we use in web render and and it

00:24:15,580 --> 00:24:18,670
works really well like this light that

00:24:17,140 --> 00:24:21,280
actually uses this technique and then

00:24:18,670 --> 00:24:24,760
for for pixels that need blending like

00:24:21,280 --> 00:24:26,980
transparency or things like this you you

00:24:24,760 --> 00:24:30,430
you still render things back to front to

00:24:26,980 --> 00:24:32,770
get like the correct rendering a lot of

00:24:30,430 --> 00:24:34,420
people ask me about Pathfinder so I just

00:24:32,770 --> 00:24:36,880
wanted to like I have a quick note about

00:24:34,420 --> 00:24:39,010
Pathfinder so Patrick and I we both work

00:24:36,880 --> 00:24:41,170
for the same company right we've been

00:24:39,010 --> 00:24:43,810
talking about these things quite a bit

00:24:41,170 --> 00:24:45,550
it's fair to say that Pathfinder

00:24:43,810 --> 00:24:51,100
influenced Leo and Leo influenced

00:24:45,550 --> 00:24:53,350
Pathfinder to a great extent Leo has

00:24:51,100 --> 00:24:55,120
been like around since a lot longer than

00:24:53,350 --> 00:24:58,030
Pathfinder actually but the difference

00:24:55,120 --> 00:25:00,210
is that Patrick is actually working like

00:24:58,030 --> 00:25:03,090
in his like it professionally on

00:25:00,210 --> 00:25:06,640
Pathfinder whereas you know is more of a

00:25:03,090 --> 00:25:10,180
site R&D project of mine Pathfinder's

00:25:06,640 --> 00:25:11,800
algorithm is so passenger actually has

00:25:10,180 --> 00:25:14,130
two algorithms it has one for rendering

00:25:11,800 --> 00:25:15,970
small text that is very optimized for

00:25:14,130 --> 00:25:18,730
cases where you don't have a lot of

00:25:15,970 --> 00:25:21,250
pixels to cover but you really need very

00:25:18,730 --> 00:25:23,560
good anti-aliasing and it has a

00:25:21,250 --> 00:25:25,930
different algorithm that is optimized

00:25:23,560 --> 00:25:27,850
for the memory bandwidth when you need

00:25:25,930 --> 00:25:30,160
to cover a lot of pixels the one I'm

00:25:27,850 --> 00:25:32,310
most interested in is the second one

00:25:30,160 --> 00:25:34,870
because it's the one that's sort of

00:25:32,310 --> 00:25:36,580
similar to that tries to fill the

00:25:34,870 --> 00:25:39,960
similar similar initiative to what I'm

00:25:36,580 --> 00:25:43,810
doing in the new and Pathfinder actually

00:25:39,960 --> 00:25:46,770
instead of generating triangles it will

00:25:43,810 --> 00:25:53,610
generate what Patrick called

00:25:46,770 --> 00:25:59,100
ah what is it colder this busy road it's

00:25:53,610 --> 00:26:03,750
like a strip like this but instead of

00:25:59,100 --> 00:26:06,260
having this a quad shaped with straight

00:26:03,750 --> 00:26:09,810
edges on the sides it will actually

00:26:06,260 --> 00:26:11,580
handle curves on the side and so you go

00:26:09,810 --> 00:26:14,250
through your geometry from top to bottom

00:26:11,580 --> 00:26:15,870
it's also a sweep line algorithm that

00:26:14,250 --> 00:26:19,800
works similarly to the one I showed you

00:26:15,870 --> 00:26:21,780
earlier a much simpler one though and

00:26:19,800 --> 00:26:24,120
you generate this these these things

00:26:21,780 --> 00:26:25,800
that you can send to the GPU and then

00:26:24,120 --> 00:26:28,440
the GPU will have like you have to do a

00:26:25,800 --> 00:26:31,350
lot of shader work on the GPU so a

00:26:28,440 --> 00:26:38,190
shader is a little program that you run

00:26:31,350 --> 00:26:41,220
on the GPU to evaluate the curves so

00:26:38,190 --> 00:26:45,090
this different trade-offs like if you're

00:26:41,220 --> 00:26:47,310
just rendering polygons it's really hard

00:26:45,090 --> 00:26:49,920
to beat mu because you know is just like

00:26:47,310 --> 00:26:52,380
doing exactly what GPUs have been doing

00:26:49,920 --> 00:26:54,780
since they've been invented so they are

00:26:52,380 --> 00:26:58,880
actually just like using all of the

00:26:54,780 --> 00:27:01,080
capabilities of the triangle rasterizer

00:26:58,880 --> 00:27:02,820
but if you need to do like a lot of

00:27:01,080 --> 00:27:05,340
curves and have very precise

00:27:02,820 --> 00:27:09,900
anti-aliasing Pathfinder has like more

00:27:05,340 --> 00:27:12,360
advanced solutions so I think that you

00:27:09,900 --> 00:27:14,010
guys if anyone wants to do vector

00:27:12,360 --> 00:27:15,840
graphics in on the GPU no rush you

00:27:14,010 --> 00:27:17,540
should check out at both and see what

00:27:15,840 --> 00:27:20,040
works best for you

00:27:17,540 --> 00:27:21,810
it's it has like those those two

00:27:20,040 --> 00:27:24,950
approaches have different trade-offs for

00:27:21,810 --> 00:27:27,300
instance loon will generate like twice

00:27:24,950 --> 00:27:29,430
like half of the geometry that

00:27:27,300 --> 00:27:31,620
Pathfinder would generate for instance

00:27:29,430 --> 00:27:34,860
so it has like a different memory and

00:27:31,620 --> 00:27:37,320
then performance trade-off but but

00:27:34,860 --> 00:27:41,330
you'll get probably like nicer curves

00:27:37,320 --> 00:27:46,590
and anti-aliasing and pipeline there so

00:27:41,330 --> 00:27:48,690
what what's what's next in leo so lately

00:27:46,590 --> 00:27:50,100
if you if you're looking the repository

00:27:48,690 --> 00:27:54,320
you haven't been pushing a lot of stuff

00:27:50,100 --> 00:27:59,490
because I'm sort of playing on my own

00:27:54,320 --> 00:28:00,550
with ideas to sort of advance the state

00:27:59,490 --> 00:28:03,490
of the art of motion

00:28:00,550 --> 00:28:05,590
isolation a bit further so one of the

00:28:03,490 --> 00:28:07,600
like the biggest problem with monotone

00:28:05,590 --> 00:28:09,820
polygon tessellation is that it tends to

00:28:07,600 --> 00:28:12,840
generate those really thin triangles

00:28:09,820 --> 00:28:16,030
because of the way we we do the the

00:28:12,840 --> 00:28:18,130
triangulation of the moment in shape and

00:28:16,030 --> 00:28:20,530
these thing triangles are not really

00:28:18,130 --> 00:28:24,520
nice for you GPU for reasons that I

00:28:20,530 --> 00:28:27,190
won't have time to to explain here but

00:28:24,520 --> 00:28:29,650
if you do a tessellation that looks more

00:28:27,190 --> 00:28:32,200
like this you're gonna get better

00:28:29,650 --> 00:28:36,210
performance it's it's hard to build an

00:28:32,200 --> 00:28:39,610
intuition of why that is but basically

00:28:36,210 --> 00:28:41,380
the the thing is if you have something

00:28:39,610 --> 00:28:43,300
like this like monotone polygons are so

00:28:41,380 --> 00:28:45,310
simple to tessellate that the algorithm

00:28:43,300 --> 00:28:48,640
like the known algorithm does this this

00:28:45,310 --> 00:28:51,910
kind of thing mess but if you if you

00:28:48,640 --> 00:28:53,860
buffer a few vertices and and then sort

00:28:51,910 --> 00:28:56,170
of look ahead and say oh okay did we

00:28:53,860 --> 00:28:58,540
like are the left and the right side far

00:28:56,170 --> 00:29:00,610
apart and if so can do something about

00:28:58,540 --> 00:29:02,860
the tessellations that i can simplify

00:29:00,610 --> 00:29:06,970
this side then simplify this other side

00:29:02,860 --> 00:29:08,800
and then just do the the in between you

00:29:06,970 --> 00:29:10,270
get a much nicer tessellation and so

00:29:08,800 --> 00:29:12,160
this is something that I've been working

00:29:10,270 --> 00:29:14,620
on and I'm getting some good results and

00:29:12,160 --> 00:29:17,080
the thing I'm gonna push that into very

00:29:14,620 --> 00:29:19,780
soon another thing that I've been

00:29:17,080 --> 00:29:21,600
telling people that would work on for I

00:29:19,780 --> 00:29:26,530
think this has been in the wiki for

00:29:21,600 --> 00:29:29,710
maybe two years already is actually have

00:29:26,530 --> 00:29:32,680
the Tesla later know about quadratic

00:29:29,710 --> 00:29:35,350
Bezier curves a bit like Pathfinder but

00:29:32,680 --> 00:29:39,780
still using the monotone polygon

00:29:35,350 --> 00:29:43,050
approach to be able to make a truly

00:29:39,780 --> 00:29:45,430
resolution-independent tessellation and

00:29:43,050 --> 00:29:48,000
and not at this point this is like

00:29:45,430 --> 00:29:50,440
really like research research research

00:29:48,000 --> 00:29:52,150
this is a hard problem and then sort of

00:29:50,440 --> 00:29:53,800
going at it and have been going in it

00:29:52,150 --> 00:29:56,520
for a while and it's quite interesting

00:29:53,800 --> 00:30:01,120
but it might take a while to complete

00:29:56,520 --> 00:30:03,460
before I stop I just want to give a big

00:30:01,120 --> 00:30:06,730
shout out for the 19 people who

00:30:03,460 --> 00:30:07,990
contributed to the project you guys are

00:30:06,730 --> 00:30:09,640
awesome

00:30:07,990 --> 00:30:12,880
I don't know if some of you are in this

00:30:09,640 --> 00:30:14,440
room but in any case thanks a lot it

00:30:12,880 --> 00:30:17,200
would be

00:30:14,440 --> 00:30:20,770
like it really helped me sort of keep

00:30:17,200 --> 00:30:22,840
the motivation and and I really like

00:30:20,770 --> 00:30:25,630
that I got this this these contributions

00:30:22,840 --> 00:30:27,960
for from you awesome people thank you

00:30:25,630 --> 00:30:27,960
very much

00:30:34,060 --> 00:30:36,120

YouTube URL: https://www.youtube.com/watch?v=2Ng5kpDirDI


