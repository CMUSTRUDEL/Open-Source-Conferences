Title: RustFest Paris 2018 -  Monotron: Making a 80s style computer with a $20 dev kit by Jonathan Pallant
Publication date: 2018-05-26
Playlist: RustFest Paris 2018
Description: 
	Jonathan Pallant has a knack
for bringing that retro feel back
with embedded Rust code
 on a Cortex M node
I would say that's a glorious hack

I missed the simplicity of of computers like the C64 and the Apple 2 and I wondered if I could recreate something like that, but using the Cortex M4 devboard on my desk and a handful of resistors. Can you generate VGA without a video chip? Can you render text without enough RAM for a framebuffer? Can you read from a PS/2 keyboard? Can you do it all in Rust, and run tests on an actual PC? Will it run fast enough to be useful?

(Limerick by @llogiq)

https://paris.rustfest.eu/sessions/monotron-recreating-an-80s-style-computer
Captions: 
	00:00:06,389 --> 00:00:11,019
johnathan talent has a knack for

00:00:08,610 --> 00:00:13,869
bringing that retro feel back

00:00:11,019 --> 00:00:18,689
with embedded rust coat on a cortex-m

00:00:13,869 --> 00:00:18,689
note I would say that's a glorious heck

00:00:21,360 --> 00:00:25,360
all right thank you very much everyone

00:00:23,410 --> 00:00:26,320
it's a pleasure to be here sir yeah I'm

00:00:25,360 --> 00:00:29,260
talking about

00:00:26,320 --> 00:00:37,449
mono Tron my attempt to pretend I'm not

00:00:29,260 --> 00:00:39,670
quite as old as I actually am so a very

00:00:37,449 --> 00:00:41,739
good question why so this is an embedded

00:00:39,670 --> 00:00:44,649
righteous project embedded rust is cool

00:00:41,739 --> 00:00:47,499
you should all do more embedded rust I

00:00:44,649 --> 00:00:49,239
am an embedded C programmer by trade I

00:00:47,499 --> 00:00:51,370
work in Cambridge at a company called

00:00:49,239 --> 00:00:53,350
Cambridge consultants and I don't get to

00:00:51,370 --> 00:00:55,120
do enough embedded programming at work I

00:00:53,350 --> 00:00:56,979
mean it's literally my whole day at work

00:00:55,120 --> 00:01:00,579
but it's not enough so I come home and I

00:00:56,979 --> 00:01:03,159
do more at home I have tried some

00:01:00,579 --> 00:01:05,530
embedded C++ we have long engaging

00:01:03,159 --> 00:01:09,880
discussions at lunch breaks over the

00:01:05,530 --> 00:01:14,470
values of C versus C++ it's not for me

00:01:09,880 --> 00:01:15,820
I've tried it at work we mainly stick to

00:01:14,470 --> 00:01:17,890
C but I'm trying to convince people that

00:01:15,820 --> 00:01:19,690
embedded rust is the answer because it

00:01:17,890 --> 00:01:22,480
fixes all of my problems right

00:01:19,690 --> 00:01:24,910
I've got Docs built in doc generator

00:01:22,480 --> 00:01:27,280
built in build system tests package

00:01:24,910 --> 00:01:30,610
manager' memory safety it's amazing it

00:01:27,280 --> 00:01:32,950
it is an an excellent solution when

00:01:30,610 --> 00:01:35,470
you're trying to build small embedded

00:01:32,950 --> 00:01:38,740
devices like modems or Bluetooth

00:01:35,470 --> 00:01:40,900
headsets and you're you're in a hurry so

00:01:38,740 --> 00:01:43,660
one of the things I take part in because

00:01:40,900 --> 00:01:46,330
clearly I have vast amount of spare time

00:01:43,660 --> 00:01:48,010
is the embedded working group so jorge's

00:01:46,330 --> 00:01:49,870
out there somewhere Jorge heads up the

00:01:48,010 --> 00:01:51,640
the embedded working group there's a

00:01:49,870 --> 00:01:53,980
bunch of us get together and talk about

00:01:51,640 --> 00:01:57,190
what the future of rust is like on

00:01:53,980 --> 00:01:59,020
embedded systems and I'm happy to say it

00:01:57,190 --> 00:02:01,840
looks like by the end of this year by

00:01:59,020 --> 00:02:05,550
Russ 2018 edition you will be able to

00:02:01,840 --> 00:02:08,110
build embedded code for a cortex-m ARM

00:02:05,550 --> 00:02:10,599
processor and a bunch of others using

00:02:08,110 --> 00:02:13,430
the stable rust compiler no more doing

00:02:10,599 --> 00:02:19,069
rust up update and rolling the dice

00:02:13,430 --> 00:02:20,780
it's good news seriously the number of

00:02:19,069 --> 00:02:23,450
times I've rolled the roster update dice

00:02:20,780 --> 00:02:26,330
and everything's broken so why this

00:02:23,450 --> 00:02:29,090
particular project well I like the

00:02:26,330 --> 00:02:32,060
eighties systems were much simpler

00:02:29,090 --> 00:02:35,150
computers like the the vic-20 in the the

00:02:32,060 --> 00:02:36,560
Commodore 64 that I had a fear all goes

00:02:35,150 --> 00:02:37,940
wrong you turn it off turn it on again

00:02:36,560 --> 00:02:42,860
and everything is back to factory

00:02:37,940 --> 00:02:44,959
settings I like I like working on bare

00:02:42,860 --> 00:02:46,700
metal you know libraries and things that

00:02:44,959 --> 00:02:47,989
help you do stuff are interesting but

00:02:46,700 --> 00:02:50,000
I'm quite interesting getting down to

00:02:47,989 --> 00:02:52,310
the to the guts I want to understand

00:02:50,000 --> 00:02:54,200
what the processor is doing and why it's

00:02:52,310 --> 00:02:56,930
doing what it's doing so that's what

00:02:54,200 --> 00:02:58,819
that's what interests me and it turns

00:02:56,930 --> 00:03:00,319
out I don't seem to watch any TV these

00:02:58,819 --> 00:03:03,500
days because I'm far too busy watching

00:03:00,319 --> 00:03:05,690
YouTube find selection of retro YouTube

00:03:03,500 --> 00:03:12,230
channels I recommend you check them all

00:03:05,690 --> 00:03:15,170
out because they're all marvelous so

00:03:12,230 --> 00:03:18,980
this particular project can we make some

00:03:15,170 --> 00:03:23,389
sort of retro 80s style 8-bit style

00:03:18,980 --> 00:03:27,139
computer in embedded rust I like the

00:03:23,389 --> 00:03:29,329
challenge there's there's a saying that

00:03:27,139 --> 00:03:33,880
there's a certain amount of beauty comes

00:03:29,329 --> 00:03:36,109
from constraints right it's easier to

00:03:33,880 --> 00:03:39,170
it's easier to perhaps design a

00:03:36,109 --> 00:03:42,319
beautiful urban garden when you have a

00:03:39,170 --> 00:03:44,180
very small parcel of land than it is to

00:03:42,319 --> 00:03:46,760
dry and do a beautiful landscape when

00:03:44,180 --> 00:03:50,780
you've got 300 acres to work with being

00:03:46,760 --> 00:03:52,849
constrained can bring out beauty in in a

00:03:50,780 --> 00:03:54,709
solution I think and I literally when I

00:03:52,849 --> 00:03:56,239
started this project I had no idea if

00:03:54,709 --> 00:03:59,720
what I wanted to do was even possible

00:03:56,239 --> 00:04:01,609
can you make a computer out of just a

00:03:59,720 --> 00:04:03,349
small cheap embedded microcontroller

00:04:01,609 --> 00:04:05,060
basically with the junk I had lying on

00:04:03,349 --> 00:04:07,220
my desk anyway

00:04:05,060 --> 00:04:09,230
ham and how much how much can we make it

00:04:07,220 --> 00:04:11,440
dear how far can we yeah can we push

00:04:09,230 --> 00:04:11,440
this

00:04:15,360 --> 00:04:22,080
so what have I done well the goals for

00:04:20,670 --> 00:04:23,520
this project so I had to do so that it

00:04:22,080 --> 00:04:25,740
cost very little don't have a lot of

00:04:23,520 --> 00:04:27,570
money I just have junk on my desk I want

00:04:25,740 --> 00:04:30,480
to ride it in rust and that basically

00:04:27,570 --> 00:04:33,830
limits you to some of the cortex-m cause

00:04:30,480 --> 00:04:36,830
from from arm also based in Cambridge

00:04:33,830 --> 00:04:39,960
for those of you who don't know arm cell

00:04:36,830 --> 00:04:43,440
processor cause but you don't just buy a

00:04:39,960 --> 00:04:45,900
cortex m3 you buy a chip from Texas

00:04:43,440 --> 00:04:48,660
Instruments or one of the other

00:04:45,900 --> 00:04:50,640
manufacturers ST micro and they give you

00:04:48,660 --> 00:04:52,380
the arm core and a whole bunch of

00:04:50,640 --> 00:04:54,090
peripherals around it in the olden days

00:04:52,380 --> 00:04:56,970
this was what was on your motherboard a

00:04:54,090 --> 00:04:58,290
processor a serial port you know maybe a

00:04:56,970 --> 00:04:59,850
video controller maybe a sound

00:04:58,290 --> 00:05:02,220
controller but now they all come on on

00:04:59,850 --> 00:05:04,200
one chip and they're incredibly cheap

00:05:02,220 --> 00:05:06,870
you can you can get some of the basic

00:05:04,200 --> 00:05:08,220
ones for literally pennies in a very low

00:05:06,870 --> 00:05:09,600
power but I didn't want to use a

00:05:08,220 --> 00:05:11,520
platform I had lots of built-in

00:05:09,600 --> 00:05:13,290
peripherals because built-in peripherals

00:05:11,520 --> 00:05:15,690
are cheating we're supposed to do this

00:05:13,290 --> 00:05:17,760
the hard way to try and understand these

00:05:15,690 --> 00:05:20,400
constraints so you know things with

00:05:17,760 --> 00:05:22,650
video generators well that's just no fun

00:05:20,400 --> 00:05:27,120
so this was the first platform I looked

00:05:22,650 --> 00:05:30,260
at the the SD micro f7 discovery it's

00:05:27,120 --> 00:05:33,060
got a megabyte of flash 340k of SRAM

00:05:30,260 --> 00:05:35,250
this board retails for about fifty

00:05:33,060 --> 00:05:37,710
pounds or about fifty dollars because

00:05:35,250 --> 00:05:39,810
everything Britain's expensive but it

00:05:37,710 --> 00:05:41,790
comes with a proper LCD interface and

00:05:39,810 --> 00:05:43,560
you could probably just wear up a a

00:05:41,790 --> 00:05:46,950
monitor and have full color output

00:05:43,560 --> 00:05:49,260
pretty trivially with audio and Ethernet

00:05:46,950 --> 00:05:52,710
and memory cards and well frankly that

00:05:49,260 --> 00:05:54,630
is cheating that is far too much working

00:05:52,710 --> 00:05:55,919
out of the box someone's already written

00:05:54,630 --> 00:05:58,710
some rough software so most of this

00:05:55,919 --> 00:06:01,280
stuff already works no fun at all this

00:05:58,710 --> 00:06:01,280
is what it looks like

00:06:03,880 --> 00:06:10,930
so the the board I use is the stellaris

00:06:08,120 --> 00:06:16,730
launchpad from Texas Instruments you get

00:06:10,930 --> 00:06:18,770
256 K a flash and 32 K of RAM

00:06:16,730 --> 00:06:20,510
it's clocked at up to 80 megahertz and

00:06:18,770 --> 00:06:22,160
because I've been working with these for

00:06:20,510 --> 00:06:23,540
a little while I have some some board

00:06:22,160 --> 00:06:25,670
support crates I kind of know how to

00:06:23,540 --> 00:06:28,250
start the processor the ones I did

00:06:25,670 --> 00:06:31,160
originally they're not great there was a

00:06:28,250 --> 00:06:32,660
lot of a lot of difference of opinion in

00:06:31,160 --> 00:06:34,250
the embedded rust community every time

00:06:32,660 --> 00:06:36,020
someone supported a new chip they did it

00:06:34,250 --> 00:06:37,910
differently and now we've started to

00:06:36,020 --> 00:06:40,010
work out now there's a consistent way to

00:06:37,910 --> 00:06:43,760
do this that that allows these things to

00:06:40,010 --> 00:06:46,190
feel the same look more similar so this

00:06:43,760 --> 00:06:48,440
was an exercise in testing out some of

00:06:46,190 --> 00:06:51,530
those things and I've got some very

00:06:48,440 --> 00:06:54,980
simple peripherals SPI is basically just

00:06:51,530 --> 00:06:57,230
a one bit digital output you can turn on

00:06:54,980 --> 00:07:00,410
and off at quite high speed we've got

00:06:57,230 --> 00:07:02,990
serial ports you arts and a thing called

00:07:00,410 --> 00:07:06,200
PWM pulse width modulation this is

00:07:02,990 --> 00:07:07,730
basically on autonomous waveform you can

00:07:06,200 --> 00:07:08,990
generate from the process it's on for a

00:07:07,730 --> 00:07:10,550
period of time and then off for a period

00:07:08,990 --> 00:07:13,280
of time it's just like a blinking light

00:07:10,550 --> 00:07:15,440
on off on off and you get to choose how

00:07:13,280 --> 00:07:17,870
long it's on and how long it's off and

00:07:15,440 --> 00:07:20,390
everything else happens by magic but

00:07:17,870 --> 00:07:22,490
there's literally nothing else on there

00:07:20,390 --> 00:07:23,990
that's of use to me so we're gonna have

00:07:22,490 --> 00:07:26,570
to roll our sleeves up to do this this

00:07:23,990 --> 00:07:28,340
is what the board looks like if you're

00:07:26,570 --> 00:07:30,710
interested later I've I've got one with

00:07:28,340 --> 00:07:34,220
me you can have a little look-see looks

00:07:30,710 --> 00:07:35,990
like with all the wires on so how are we

00:07:34,220 --> 00:07:38,540
doing this well this is the this is the

00:07:35,990 --> 00:07:40,910
chip I'm apologize for failing to

00:07:38,540 --> 00:07:45,850
respect margins in my Google

00:07:40,910 --> 00:07:48,650
presentation but basically we've got a

00:07:45,850 --> 00:07:50,420
DMA engine this is a piece of silicon

00:07:48,650 --> 00:07:52,310
baked into the chip that can

00:07:50,420 --> 00:07:54,380
automatically move memory from somewhere

00:07:52,310 --> 00:07:57,290
to somewhere else and you can get off

00:07:54,380 --> 00:07:58,850
and do a different you can execute some

00:07:57,290 --> 00:08:01,250
code while that's happening in the

00:07:58,850 --> 00:08:03,620
background may be useful we have some

00:08:01,250 --> 00:08:05,960
timers on there these are the devices

00:08:03,620 --> 00:08:07,880
that generate those PWM signals so that

00:08:05,960 --> 00:08:10,520
you can either do on/off on/off in

00:08:07,880 --> 00:08:12,850
cycles or they can they can wait a

00:08:10,520 --> 00:08:16,710
period of time and when the time expires

00:08:12,850 --> 00:08:20,699
an alarm goes off and your CPU is in too

00:08:16,710 --> 00:08:22,619
and can go and do some work and it can

00:08:20,699 --> 00:08:25,169
run at a speed of sixty six point six

00:08:22,619 --> 00:08:30,569
seven or or 80 megahertz and we'll see

00:08:25,169 --> 00:08:33,389
if that's relevant now the some of the

00:08:30,569 --> 00:08:36,209
great work Jorge's been doing and others

00:08:33,389 --> 00:08:38,069
it's this tool called SVD to rust and

00:08:36,209 --> 00:08:39,899
what an SVD is it's basically a

00:08:38,069 --> 00:08:42,180
description of the chip provided by the

00:08:39,899 --> 00:08:45,300
manufacturer the way these chips work is

00:08:42,180 --> 00:08:47,069
all of their peripherals exist at magic

00:08:45,300 --> 00:08:50,009
memory addresses that aren't really

00:08:47,069 --> 00:08:52,019
memory their chip peripheral and this

00:08:50,009 --> 00:08:54,209
file describes them all so instead of

00:08:52,019 --> 00:08:57,240
having to write thousands of lines of

00:08:54,209 --> 00:08:59,220
code like I did on my first project the

00:08:57,240 --> 00:09:01,829
code is auto-generated and there are

00:08:59,220 --> 00:09:04,319
just you art object serial port objects

00:09:01,829 --> 00:09:06,300
that you can use or here we can we've

00:09:04,319 --> 00:09:10,860
got the run time clock control module

00:09:06,300 --> 00:09:13,050
and we are modifying the the amber H

00:09:10,860 --> 00:09:16,170
buffs enable register and we're

00:09:13,050 --> 00:09:21,600
modifying it to turn on the IOP enable

00:09:16,170 --> 00:09:24,060
bit but in C this would look like star

00:09:21,600 --> 00:09:25,740
some number or equals some other number

00:09:24,060 --> 00:09:27,209
and they're like well unless you've

00:09:25,740 --> 00:09:30,470
memorized the data sheet that is of no

00:09:27,209 --> 00:09:33,120
use whatsoever I admit that is

00:09:30,470 --> 00:09:34,440
relatively unreadable to some people but

00:09:33,120 --> 00:09:37,199
if you understand the chip and you

00:09:34,440 --> 00:09:41,069
understand that there is an IO P enable

00:09:37,199 --> 00:09:43,079
bit in the AHB enable register then that

00:09:41,069 --> 00:09:46,050
becomes a lot more readable and actually

00:09:43,079 --> 00:09:47,910
the compiler just turns that in to set

00:09:46,050 --> 00:09:50,519
this bit in this memory location so

00:09:47,910 --> 00:09:52,769
although there's more typing it doesn't

00:09:50,519 --> 00:09:54,810
cost you anything at runtime it's just

00:09:52,769 --> 00:09:54,959
as fast as doing it the old-fashioned

00:09:54,810 --> 00:09:57,720
way

00:09:54,959 --> 00:09:59,449
which i think is just brilliant who

00:09:57,720 --> 00:10:01,860
listens to new rush station the podcast

00:09:59,449 --> 00:10:03,510
there's a brilliant podcast kraits you

00:10:01,860 --> 00:10:06,600
should know is my list of crates you

00:10:03,510 --> 00:10:09,990
should know SVD to rust generates a

00:10:06,600 --> 00:10:11,850
crate for each supported chip the TM is

00:10:09,990 --> 00:10:14,279
the the TI chip I've gone on mine

00:10:11,850 --> 00:10:17,310
there's an STM chip there but these are

00:10:14,279 --> 00:10:19,529
fairly low-level api's as you as you've

00:10:17,310 --> 00:10:22,339
seen so we wrapped them up in something

00:10:19,529 --> 00:10:24,389
a little higher level these Hal crates

00:10:22,339 --> 00:10:26,730
describe the various types of

00:10:24,389 --> 00:10:28,410
peripherals in a common fashion so

00:10:26,730 --> 00:10:29,760
there's one further chip I'm using run

00:10:28,410 --> 00:10:31,590
for the STM

00:10:29,760 --> 00:10:33,240
but they use these embedded howl traits

00:10:31,590 --> 00:10:36,240
and basically if you write your code to

00:10:33,240 --> 00:10:38,760
use a UART then you should be able to

00:10:36,240 --> 00:10:41,100
plug in any of these chip crates and use

00:10:38,760 --> 00:10:43,680
any UART from any of these chips and it

00:10:41,100 --> 00:10:45,510
helps people write reusable libraries

00:10:43,680 --> 00:10:47,250
that will run on a number of embedded

00:10:45,510 --> 00:10:51,990
platforms again it's quite difficult to

00:10:47,250 --> 00:10:53,910
do in C though for this specific case of

00:10:51,990 --> 00:10:56,850
a cortex-m then there are a couple of

00:10:53,910 --> 00:10:58,770
cortex-m help with crates again based on

00:10:56,850 --> 00:11:00,600
great work on those ones are sort of

00:10:58,770 --> 00:11:01,980
managing the chip and one artis the

00:11:00,600 --> 00:11:03,840
runtime so that's for getting the chip

00:11:01,980 --> 00:11:10,980
booted so there was a bunch of stuff I

00:11:03,840 --> 00:11:12,840
didn't have to do so video signals how

00:11:10,980 --> 00:11:16,260
ironic that my presentation about video

00:11:12,840 --> 00:11:18,360
is falling off the edge of the screen so

00:11:16,260 --> 00:11:19,850
this is old-fashioned VGA video you

00:11:18,360 --> 00:11:22,110
might remember the little blue

00:11:19,850 --> 00:11:24,480
connectors on the back of your PC with

00:11:22,110 --> 00:11:26,580
fifteen pins well it's an analog video

00:11:24,480 --> 00:11:29,100
signal and it involves the three

00:11:26,580 --> 00:11:31,980
standard analog colors red green and

00:11:29,100 --> 00:11:35,640
blue and these are analog signals that

00:11:31,980 --> 00:11:39,150
vary between naught and 0.7 volts and

00:11:35,640 --> 00:11:41,430
the amount of voltage you put on each of

00:11:39,150 --> 00:11:44,520
those colored pins controls how bright

00:11:41,430 --> 00:11:47,940
the screen is in that particular color

00:11:44,520 --> 00:11:49,980
and so the signals on the screen start

00:11:47,940 --> 00:11:52,470
and left and go to the right and that is

00:11:49,980 --> 00:11:55,560
time so the left-hand edge of the screen

00:11:52,470 --> 00:11:57,360
is this edge on the left and the

00:11:55,560 --> 00:12:00,150
right-hand edge of the screen is here

00:11:57,360 --> 00:12:01,620
except of course in my case I think the

00:12:00,150 --> 00:12:03,870
edge of the projector is probably about

00:12:01,620 --> 00:12:06,090
here which is why you're you're missing

00:12:03,870 --> 00:12:08,070
the left-hand side of the screen the the

00:12:06,090 --> 00:12:11,190
black line at the top this is called the

00:12:08,070 --> 00:12:14,280
sync pulse so this helps the monitor

00:12:11,190 --> 00:12:16,740
find the edge of the screen so the sync

00:12:14,280 --> 00:12:19,170
pulse goes low for a period of time and

00:12:16,740 --> 00:12:21,990
then it goes high and you get this

00:12:19,170 --> 00:12:24,300
little gap called the back porch and

00:12:21,990 --> 00:12:26,220
then we have the data our visible data

00:12:24,300 --> 00:12:28,020
and ordinarily these lines would wiggle

00:12:26,220 --> 00:12:30,330
up and down if they're flat like that

00:12:28,020 --> 00:12:32,610
then that's a plain white screen because

00:12:30,330 --> 00:12:34,740
every pixel is maximum on all three

00:12:32,610 --> 00:12:36,600
colors and then there's a sort of a gap

00:12:34,740 --> 00:12:38,340
at the end called the front porch and

00:12:36,600 --> 00:12:42,600
this just happens around around around

00:12:38,340 --> 00:12:43,830
around again again and again each of

00:12:42,600 --> 00:12:47,590
those lines

00:12:43,830 --> 00:12:50,830
stacks up and we have a certain number

00:12:47,590 --> 00:12:52,840
of lines in a frame 600 480 whatever it

00:12:50,830 --> 00:12:57,760
is and the frames again just repeat

00:12:52,840 --> 00:13:00,160
repeat and there's a special sync pulse

00:12:57,760 --> 00:13:02,650
called the vertical sync which tells you

00:13:00,160 --> 00:13:04,270
which line you are within a frame so we

00:13:02,650 --> 00:13:06,040
have a horizontal sync that says where

00:13:04,270 --> 00:13:07,150
you are within your line and our

00:13:06,040 --> 00:13:08,620
vertical sync this is where you are

00:13:07,150 --> 00:13:11,650
within your frame and again there's some

00:13:08,620 --> 00:13:13,630
blank lines the sync pulse goes low some

00:13:11,650 --> 00:13:15,130
more blank lines and then these blue

00:13:13,630 --> 00:13:16,390
lines are whether where the picture is

00:13:15,130 --> 00:13:17,800
so is it it's kind of straightforward

00:13:16,390 --> 00:13:19,510
you can kind of start to see where these

00:13:17,800 --> 00:13:23,460
timer peripherals might be useful to

00:13:19,510 --> 00:13:28,510
generate these sort of repeated on-off

00:13:23,460 --> 00:13:30,820
signals of loss my mouse cursor so

00:13:28,510 --> 00:13:33,670
timing is incredibly important if you

00:13:30,820 --> 00:13:37,330
get the timing wrong your monitor will

00:13:33,670 --> 00:13:40,510
tell you to go away my monitor has told

00:13:37,330 --> 00:13:44,380
me to go away on a very large number of

00:13:40,510 --> 00:13:46,420
occasions it's taken awhile to get this

00:13:44,380 --> 00:13:49,350
to work it's all about this thing called

00:13:46,420 --> 00:13:52,240
the pixel clock the pixels must change

00:13:49,350 --> 00:13:55,240
repeatedly and reliably and each pixel

00:13:52,240 --> 00:13:58,089
must be exactly the right length in time

00:13:55,240 --> 00:13:59,980
and if they're not the monitor will get

00:13:58,089 --> 00:14:03,630
confused and the pixels will start to

00:13:59,980 --> 00:14:05,560
look very strange and the timing

00:14:03,630 --> 00:14:07,360
basically comes from the resolution you

00:14:05,560 --> 00:14:12,430
choose right so there's a pixels across

00:14:07,360 --> 00:14:15,730
lines down 640 pixels across times 480

00:14:12,430 --> 00:14:18,490
lines high 60 frames per second this is

00:14:15,730 --> 00:14:20,920
the good old fashioned IBM standard and

00:14:18,490 --> 00:14:24,490
that means you need to be generating new

00:14:20,920 --> 00:14:26,770
pixels every well you need 25 point one

00:14:24,490 --> 00:14:29,500
seven five million pixels per second

00:14:26,770 --> 00:14:32,500
this is quite a large number for the

00:14:29,500 --> 00:14:35,320
small embedded chips it also does not

00:14:32,500 --> 00:14:41,490
divide down nicely into sixty six point

00:14:35,320 --> 00:14:44,650
seven or 80 so that's not going to work

00:14:41,490 --> 00:14:46,510
so the other one when you turn on your

00:14:44,650 --> 00:14:47,860
old-fashioned PC and you get the BIOS

00:14:46,510 --> 00:14:50,530
screen comes up when he makes the beep

00:14:47,860 --> 00:14:51,910
sound you know press Delete to enter

00:14:50,530 --> 00:14:56,420
setup well that used to be at a

00:14:51,910 --> 00:14:58,130
resolution of 720 by 470 Hertz

00:14:56,420 --> 00:15:00,170
just how the numbers worked out when IBM

00:14:58,130 --> 00:15:02,810
developed it twenty-eight point three to

00:15:00,170 --> 00:15:04,370
two megahertz that's not gonna work

00:15:02,810 --> 00:15:06,649
either which is a shame because it would

00:15:04,370 --> 00:15:11,990
have a great sort of IBM classic retro

00:15:06,649 --> 00:15:13,790
feel 800 by 600 at sixty Hertz

00:15:11,990 --> 00:15:17,360
well that's sort of a resolution you

00:15:13,790 --> 00:15:22,630
were using in Windows 95 windows 3.1 it

00:15:17,360 --> 00:15:24,889
feels quite a retro 40.000 megahertz

00:15:22,630 --> 00:15:27,050
ladies and gentlemen I think we have a

00:15:24,889 --> 00:15:29,750
winner I can just take my 80 megahertz

00:15:27,050 --> 00:15:31,579
processor clock divide it by two and

00:15:29,750 --> 00:15:36,250
there's the pixel clock I need to

00:15:31,579 --> 00:15:40,370
generate this data so the math stacks up

00:15:36,250 --> 00:15:43,329
so what do we end up with well 800 by

00:15:40,370 --> 00:15:48,440
600 the 40 megahertz clock done

00:15:43,329 --> 00:15:50,810
turns out 800 horizontal pixels is too

00:15:48,440 --> 00:15:53,389
many I don't have enough processor time

00:15:50,810 --> 00:15:57,290
to generate that many but I've got a

00:15:53,389 --> 00:16:01,550
plan if I make my pixels twice as long

00:15:57,290 --> 00:16:03,980
and send half as many the monitor will

00:16:01,550 --> 00:16:06,980
have no idea I've done this it will see

00:16:03,980 --> 00:16:10,399
two pixels when I've only sent one so we

00:16:06,980 --> 00:16:13,490
can do it 400 by 600 and the monitor has

00:16:10,399 --> 00:16:16,040
no idea and that will work if we then

00:16:13,490 --> 00:16:19,370
divide the screen into characters eight

00:16:16,040 --> 00:16:22,310
pixels across 16 pixels high that's sort

00:16:19,370 --> 00:16:25,790
of a good old-fashioned dos style font

00:16:22,310 --> 00:16:29,029
then we get about 48 by 36 it doesn't

00:16:25,790 --> 00:16:31,610
divide evenly we put a border on 12

00:16:29,029 --> 00:16:34,550
pixels top bottom 8 on the side makes it

00:16:31,610 --> 00:16:36,920
feel like a Commodore 64 and helpfully

00:16:34,550 --> 00:16:39,800
makes up with math simpler as it turns

00:16:36,920 --> 00:16:42,800
out and then the idea is we can load

00:16:39,800 --> 00:16:45,560
these pixels into our into our digital

00:16:42,800 --> 00:16:48,019
output our SPI peripheral synchronous

00:16:45,560 --> 00:16:51,740
peripheral interface basically I can

00:16:48,019 --> 00:16:54,410
load bytes in 8-bit values and single

00:16:51,740 --> 00:16:56,149
bits will magically appear so my

00:16:54,410 --> 00:16:58,069
processor can put an 8-bit value in and

00:16:56,149 --> 00:17:02,630
then go off and do something else and

00:16:58,069 --> 00:17:04,400
the eight bits will be generated at well

00:17:02,630 --> 00:17:06,740
in my case 20 megahertz to get my

00:17:04,400 --> 00:17:08,900
double-width pixels automatically and

00:17:06,740 --> 00:17:10,130
even better this particular chip has

00:17:08,900 --> 00:17:12,829
what's called a 5

00:17:10,130 --> 00:17:16,970
though first in first out queue I can

00:17:12,829 --> 00:17:20,810
load 16 bytes up and then go away and

00:17:16,970 --> 00:17:23,420
the chip will generate 8 bits for each

00:17:20,810 --> 00:17:26,150
of those 16 bytes completely all by

00:17:23,420 --> 00:17:28,610
itself it's never designed to do video

00:17:26,150 --> 00:17:31,730
it was designed to talk to modems and

00:17:28,610 --> 00:17:33,670
memory chips and SD cards SPI

00:17:31,730 --> 00:17:39,170
incidentally is exactly how SD cards

00:17:33,670 --> 00:17:41,530
work in their basic mode so how do we do

00:17:39,170 --> 00:17:43,820
this in software terms well we have our

00:17:41,530 --> 00:17:46,370
pixels and we can divide our line up

00:17:43,820 --> 00:17:48,590
into discreet pixels I can turn on and

00:17:46,370 --> 00:17:50,660
off I don't really have any sense of

00:17:48,590 --> 00:17:53,780
brightness there aren't scales of grey

00:17:50,660 --> 00:17:56,510
here either the output is maximum on or

00:17:53,780 --> 00:17:58,430
maximum off and so what we do is we set

00:17:56,510 --> 00:18:00,380
up some timer interrupts and at the

00:17:58,430 --> 00:18:02,330
beginning of the line the start of this

00:18:00,380 --> 00:18:04,550
sync pulse and when the sync pulse goes

00:18:02,330 --> 00:18:06,350
low a timer interrupts fires and we

00:18:04,550 --> 00:18:08,450
execute some code and what we do is we

00:18:06,350 --> 00:18:10,430
get the line set up what line am I on

00:18:08,450 --> 00:18:14,720
well that's one more than the one I was

00:18:10,430 --> 00:18:16,250
last time if I get to 628 then I'm at

00:18:14,720 --> 00:18:19,070
the bottom and I need to go back around

00:18:16,250 --> 00:18:23,060
to the top again and I can start filling

00:18:19,070 --> 00:18:25,490
my SPI FIFO and then right about here

00:18:23,060 --> 00:18:27,740
when I expect the data to start my

00:18:25,490 --> 00:18:30,730
pixels to start being generated I can

00:18:27,740 --> 00:18:33,500
fire a second interrupt and I can

00:18:30,730 --> 00:18:35,990
basically my SPI five throws like a bath

00:18:33,500 --> 00:18:38,140
the first interrupt I fill my bath on

00:18:35,990 --> 00:18:41,060
the second interrupt I pull the plug and

00:18:38,140 --> 00:18:42,950
I can't quite fill my bath fast enough

00:18:41,060 --> 00:18:45,110
but that's fine because I've had a bit

00:18:42,950 --> 00:18:48,440
of a head start and hopefully by the end

00:18:45,110 --> 00:18:50,870
of the line the very last bit of pixel

00:18:48,440 --> 00:18:53,120
data drains out of my bath just as I'm

00:18:50,870 --> 00:18:55,760
pouring it in and everything will work

00:18:53,120 --> 00:18:58,700
and I have to do that six hundred and

00:18:55,760 --> 00:19:01,610
twenty eight times as times a frame 60

00:18:58,700 --> 00:19:03,290
frames a second it's best not to think

00:19:01,610 --> 00:19:06,100
about how much work this processor is

00:19:03,290 --> 00:19:08,840
doing because you start to question

00:19:06,100 --> 00:19:11,180
what's happening so this is the magic

00:19:08,840 --> 00:19:14,450
number if I have an 80 megahertz

00:19:11,180 --> 00:19:16,910
processor clock and I'm dividing it down

00:19:14,450 --> 00:19:20,180
with a 20 megahertz pixel clock and I

00:19:16,910 --> 00:19:22,550
have to output these 8 bits for my every

00:19:20,180 --> 00:19:23,480
character basically what happens is I

00:19:22,550 --> 00:19:26,210
have 32

00:19:23,480 --> 00:19:29,960
you clock cycles of my processor I can

00:19:26,210 --> 00:19:33,350
perform about 32 instructions in my

00:19:29,960 --> 00:19:34,940
processor for every character across my

00:19:33,350 --> 00:19:37,670
screen I have to go to the character

00:19:34,940 --> 00:19:40,790
buffer find out what letter is being

00:19:37,670 --> 00:19:43,790
displayed a letter a workout where I am

00:19:40,790 --> 00:19:46,160
in the letter I'm in the middle maybe

00:19:43,790 --> 00:19:48,200
across the bar of the letter a work out

00:19:46,160 --> 00:19:49,430
which bits need to be on and off well

00:19:48,200 --> 00:19:51,710
there's some off at the edge and there's

00:19:49,430 --> 00:19:53,600
maybe a line in the middle I have to

00:19:51,710 --> 00:19:55,610
work out if there's any coloring or

00:19:53,600 --> 00:19:57,980
other stuff going on and then I have to

00:19:55,610 --> 00:19:59,990
get that into the output register for my

00:19:57,980 --> 00:20:03,470
SPI peripheral and I've got to do that

00:19:59,990 --> 00:20:09,910
in 32 clock cycles or less if you get it

00:20:03,470 --> 00:20:09,910
wrong you get a mess if you get it right

00:20:10,990 --> 00:20:23,330
you get something like this so this is

00:20:20,270 --> 00:20:25,550
actually the font from FreeBSD if you

00:20:23,330 --> 00:20:26,840
boot FreeBSD on a spark machine or

00:20:25,550 --> 00:20:29,780
something that doesn't have a VGA video

00:20:26,840 --> 00:20:31,880
card they use this exact font and we can

00:20:29,780 --> 00:20:32,810
see here I'm generating green text on a

00:20:31,880 --> 00:20:35,660
black background

00:20:32,810 --> 00:20:38,360
I'm just wagging the green pin out of my

00:20:35,660 --> 00:20:41,090
red green blue at this point can't

00:20:38,360 --> 00:20:42,560
manage red and blue but it you know it's

00:20:41,090 --> 00:20:44,960
a solid picked it goes fuzzy in the

00:20:42,560 --> 00:20:47,840
corner but that is my appalling ability

00:20:44,960 --> 00:20:49,580
to use my Canon SLR as opposed to the

00:20:47,840 --> 00:20:55,240
quality of the video if you look at it

00:20:49,580 --> 00:20:55,240
in the real thing it looks fine in fact

00:20:55,480 --> 00:21:09,669
looks a bit like this and

00:21:06,150 --> 00:21:13,480
the very observant of you will spot that

00:21:09,669 --> 00:21:16,029
it is no longer green on black it is now

00:21:13,480 --> 00:21:17,679
in fact white on blue there are some

00:21:16,029 --> 00:21:20,890
shortcuts you can take when it comes to

00:21:17,679 --> 00:21:23,140
generating color video if you want to

00:21:20,890 --> 00:21:26,260
generate white on blue then for every

00:21:23,140 --> 00:21:29,260
pixel that is set then you need to put a

00:21:26,260 --> 00:21:33,580
one in the red the green and the blue

00:21:29,260 --> 00:21:35,650
and for every background pixel you just

00:21:33,580 --> 00:21:37,570
need the blue on on the red and the

00:21:35,650 --> 00:21:39,970
green a blank so if I have my 8-bit

00:21:37,570 --> 00:21:43,240
value then basically what I need to do

00:21:39,970 --> 00:21:46,029
is put my 8-bit value in the red and in

00:21:43,240 --> 00:21:49,510
the green and then always put eight ones

00:21:46,029 --> 00:21:51,760
in the blue Channel and this happened so

00:21:49,510 --> 00:21:53,110
basically there's no more work to do and

00:21:51,760 --> 00:21:55,659
I could just drive the three channels

00:21:53,110 --> 00:21:56,710
and this was as far as I got and if you

00:21:55,659 --> 00:21:59,010
if you've seen what I've been doing on

00:21:56,710 --> 00:22:02,799
Twitter this has been just driving me

00:21:59,010 --> 00:22:05,440
driving me wild trying to get this

00:22:02,799 --> 00:22:08,620
sorted let's see if I can get the serial

00:22:05,440 --> 00:22:10,630
terminal going so I am going to

00:22:08,620 --> 00:22:16,110
implement keyboard support I do have an

00:22:10,630 --> 00:22:16,110
old Dell keyboard but for now I have a

00:22:17,039 --> 00:22:22,210
menu system so it's a serial port so you

00:22:20,500 --> 00:22:23,230
can send it commands and you can do

00:22:22,210 --> 00:22:27,070
things like if you want to see how this

00:22:23,230 --> 00:22:31,330
chip boots dump hex 100 bytes at address

00:22:27,070 --> 00:22:34,510
0 for the terminally curious the base

00:22:31,330 --> 00:22:37,240
value here is the the stack pointer and

00:22:34,510 --> 00:22:38,770
then these values are my interrupt

00:22:37,240 --> 00:22:40,360
vectors and you notice all my all

00:22:38,770 --> 00:22:42,130
interrupt vectors are the same they

00:22:40,360 --> 00:22:44,860
pointed an interrupter vector that says

00:22:42,130 --> 00:22:47,679
I haven't written this this this yet you

00:22:44,860 --> 00:22:50,230
need to crash so basically the function

00:22:47,679 --> 00:22:51,940
at address 0 these addresses are

00:22:50,230 --> 00:22:53,380
backwards little-endian I think you've

00:22:51,940 --> 00:22:56,890
got Intel to thank for that

00:22:53,380 --> 00:22:58,779
the address 0 0 0 0 1 7 7 F is the intro

00:22:56,890 --> 00:23:01,090
vector that says crash hilariously

00:22:58,779 --> 00:23:02,770
these monitors down here now look

00:23:01,090 --> 00:23:04,830
exactly like a Windows blue screen of

00:23:02,770 --> 00:23:07,900
death

00:23:04,830 --> 00:23:10,540
let's say that's a scene many people

00:23:07,900 --> 00:23:12,340
have seen before but you know what

00:23:10,540 --> 00:23:13,960
enough of this let's talk about some art

00:23:12,340 --> 00:23:16,510
what can you do with this system well I

00:23:13,960 --> 00:23:18,760
don't have pixels if I had a pixel

00:23:16,510 --> 00:23:21,160
buffer then I would blow half of my

00:23:18,760 --> 00:23:24,490
memory storing individual pixels and

00:23:21,160 --> 00:23:26,680
there would be no color so we've got

00:23:24,490 --> 00:23:29,020
blocks it's a bit like teletext but you

00:23:26,680 --> 00:23:31,480
can imagine if I put the effort in this

00:23:29,020 --> 00:23:33,760
would be a playable game you know my

00:23:31,480 --> 00:23:36,880
kids might enjoy this right space

00:23:33,760 --> 00:23:41,080
invaders that's good all right maybe not

00:23:36,880 --> 00:23:42,310
space invaders how about pac-man I think

00:23:41,080 --> 00:23:45,910
you find that's full color ladies and

00:23:42,310 --> 00:23:52,360
gentlemen forgot red green and blue at

00:23:45,910 --> 00:23:54,400
the same time so it turns out there are

00:23:52,360 --> 00:23:57,520
some more cheats you can take if you are

00:23:54,400 --> 00:24:00,340
prepared to use vast amounts of flash

00:23:57,520 --> 00:24:03,190
memory I don't have enough time to do

00:24:00,340 --> 00:24:05,830
maths to say if this character is yellow

00:24:03,190 --> 00:24:08,140
then place values here and here and not

00:24:05,830 --> 00:24:10,360
here if this value is green do this

00:24:08,140 --> 00:24:12,220
other thing because the if it's yellow

00:24:10,360 --> 00:24:15,430
if it's green if it's blue if it's

00:24:12,220 --> 00:24:20,620
whatever takes too long you can arrange

00:24:15,430 --> 00:24:23,950
a table in memory and pre-compute values

00:24:20,620 --> 00:24:27,190
it basically uses one kilobyte per color

00:24:23,950 --> 00:24:28,450
and I have 64 color combinations so I

00:24:27,190 --> 00:24:31,210
have eight foreground and eight

00:24:28,450 --> 00:24:33,430
background but if you just blow 64

00:24:31,210 --> 00:24:36,460
kilobytes of memory then your color

00:24:33,430 --> 00:24:38,920
lookup just becomes an index into find

00:24:36,460 --> 00:24:41,380
the table I want jump down to the 8-bit

00:24:38,920 --> 00:24:44,440
value I want there's my red green blue

00:24:41,380 --> 00:24:47,200
values until we have full color so this

00:24:44,440 --> 00:24:50,320
is a bit more exciting right how about

00:24:47,200 --> 00:24:53,140
we have a sort of a dot style dot style

00:24:50,320 --> 00:24:54,160
there are a Productivity application

00:24:53,140 --> 00:24:56,410
right I can manage

00:24:54,160 --> 00:24:58,390
I can manage my life with that and you

00:24:56,410 --> 00:24:59,590
can imagine Mouse support right bear

00:24:58,390 --> 00:25:01,900
with Mouse of what you could drag these

00:24:59,590 --> 00:25:04,390
windows around I spent a lot of time in

00:25:01,900 --> 00:25:07,030
my youth using ball and turbo Pascal 6

00:25:04,390 --> 00:25:09,660
and this was the future back when back

00:25:07,030 --> 00:25:09,660
when I was a kid

00:25:11,590 --> 00:25:18,410
so incidentally typing these into your

00:25:15,230 --> 00:25:20,480
source code by hand is incredibly slow

00:25:18,410 --> 00:25:22,730
so I found a wonderful paint package

00:25:20,480 --> 00:25:26,360
called Rex paint and it is designed to

00:25:22,730 --> 00:25:29,240
paint these DA style pictures and as I

00:25:26,360 --> 00:25:31,100
have absolutely no artistic merit the

00:25:29,240 --> 00:25:34,850
only other thing I could think to draw

00:25:31,100 --> 00:25:38,810
while using Rex paint was a picture of

00:25:34,850 --> 00:25:40,670
Rex paint so this is an ASCII art editor

00:25:38,810 --> 00:25:42,260
again mine's just a sort of a fictional

00:25:40,670 --> 00:25:44,150
version it's an artwork but you can

00:25:42,260 --> 00:25:46,820
imagine you can select the characters

00:25:44,150 --> 00:25:49,370
this is my character set it is if you're

00:25:46,820 --> 00:25:51,740
interested dose code page 850 for those

00:25:49,370 --> 00:25:53,600
of you who remember dose code pages

00:25:51,740 --> 00:25:56,770
basically Unicode hadn't been invented

00:25:53,600 --> 00:25:59,420
and so you had a choice did you want

00:25:56,770 --> 00:26:01,610
Central European languages or Western

00:25:59,420 --> 00:26:02,600
European languages or were you American

00:26:01,610 --> 00:26:04,850
and you didn't give a damn about

00:26:02,600 --> 00:26:07,730
accented letters in which case you could

00:26:04,850 --> 00:26:09,200
have lots of boxes and drawing

00:26:07,730 --> 00:26:10,280
characters this is a this is a

00:26:09,200 --> 00:26:14,680
combination of the two we have some

00:26:10,280 --> 00:26:17,990
accents we have a few boxes this is the

00:26:14,680 --> 00:26:20,210
50% character which is 50% foreground

00:26:17,990 --> 00:26:22,430
50% background but it helps get you a

00:26:20,210 --> 00:26:24,410
few more a few more colors but you know

00:26:22,430 --> 00:26:27,520
I'm use myself I drew some new trees and

00:26:24,410 --> 00:26:30,530
hills and suns and backgrounds but um

00:26:27,520 --> 00:26:31,730
but let's face it this project was never

00:26:30,530 --> 00:26:32,860
going to set the world on fire thank you

00:26:31,730 --> 00:26:46,910
very much ladies gentlemen

00:26:32,860 --> 00:26:46,910
[Applause]

00:26:51,560 --> 00:27:03,720
okay yeah happy to take questions

00:26:54,120 --> 00:27:05,310
I should add you can find all the all

00:27:03,720 --> 00:27:09,450
the code on github if you go to key

00:27:05,310 --> 00:27:13,310
based io / the J pista you can you can

00:27:09,450 --> 00:27:13,310
find all of the all of the source code

00:27:17,180 --> 00:27:24,480
would would you accept a pull request to

00:27:21,210 --> 00:27:26,520
add Space Invaders absolutely please do

00:27:24,480 --> 00:27:39,840
write software for this because I have

00:27:26,520 --> 00:27:42,150
no time at all thank you

00:27:39,840 --> 00:27:47,000
do you think this could work on the

00:27:42,150 --> 00:27:47,000
anima BC micro bit or is it too slow

00:27:47,270 --> 00:27:52,200
interesting question so this requires a

00:27:51,000 --> 00:27:54,240
certain amount of processing power I'd

00:27:52,200 --> 00:27:56,070
have to go and look at the specs but I

00:27:54,240 --> 00:27:58,050
think the micro bit is another cortex-m

00:27:56,070 --> 00:27:59,700
I'd have to check the exact clock

00:27:58,050 --> 00:28:02,580
frequencies you can tell it to but maybe

00:27:59,700 --> 00:28:04,260
you could handle Powell video or NTSC

00:28:02,580 --> 00:28:06,570
analog video or maybe a lower resolution

00:28:04,260 --> 00:28:08,520
so it's it's possible and the crates are

00:28:06,570 --> 00:28:12,720
portable so there is a crate that called

00:28:08,520 --> 00:28:14,670
VGA frame buffer and that just has some

00:28:12,720 --> 00:28:17,070
plug-in values of the timing and some

00:28:14,670 --> 00:28:18,660
hardware specific callbacks you can set

00:28:17,070 --> 00:28:21,740
so yeah you could definitely try on on

00:28:18,660 --> 00:28:21,740
some other platforms as well

00:28:28,400 --> 00:28:34,500
where did you need to buy any inline

00:28:32,850 --> 00:28:37,860
assembly to get this to work or is it

00:28:34,500 --> 00:28:43,140
all in rust yeah there is a little

00:28:37,860 --> 00:28:45,360
limited smooth ship of inline assembler

00:28:43,140 --> 00:28:48,390
if I'm honest so it turns out if you

00:28:45,360 --> 00:28:50,310
activate your red Fife oh and then in

00:28:48,390 --> 00:28:53,010
the next machine instruction you

00:28:50,310 --> 00:28:55,230
activate your green FIFO well the red

00:28:53,010 --> 00:28:57,270
FIFO has already started sending pixels

00:28:55,230 --> 00:28:59,370
and then you'll read your green in your

00:28:57,270 --> 00:29:01,260
blue don't line up and you get these

00:28:59,370 --> 00:29:04,020
sort of weird fringe effects around all

00:29:01,260 --> 00:29:05,940
of your letters so the solution and then

00:29:04,020 --> 00:29:11,040
it took me a while to get to this is you

00:29:05,940 --> 00:29:13,020
preload your red FIFO with two 8-bit

00:29:11,040 --> 00:29:16,290
values that are all zero and you preload

00:29:13,020 --> 00:29:19,380
your green with one 8-bit value that's

00:29:16,290 --> 00:29:22,470
all zeros and you start your red 16

00:29:19,380 --> 00:29:24,750
pixels early and then you have to put

00:29:22,470 --> 00:29:28,410
exactly the right number of assemble and

00:29:24,750 --> 00:29:30,150
no operation instructions in and you

00:29:28,410 --> 00:29:32,640
start the green and then you have

00:29:30,150 --> 00:29:35,790
another seven no ops and then you start

00:29:32,640 --> 00:29:37,890
the blue and they are always in sync

00:29:35,790 --> 00:29:42,410
perfectly in sync but you do need that

00:29:37,890 --> 00:29:42,410
little just a smoosh of inline assembler

00:29:47,890 --> 00:29:54,340
ok I think that's all the time we have

00:29:50,800 --> 00:29:54,340

YouTube URL: https://www.youtube.com/watch?v=pTEYqpcQ6lg


