Title: RustFest Paris 2018 -  A Rust Crate that also quacks like a modern C++ Library by Henri Sivonen
Publication date: 2018-05-26
Playlist: RustFest Paris 2018
Description: 
	A Mozillian and Rustacean by heart,
Henri Sivonen got a great start
porting Firefox' char 
handling to Rust, so far
it's been quietly doing its part

In Firefox 56, the encoding_rs character encoding conversion crate replaced Firefoxâ€™s previous encoding conversion library that was written in C++. This talk examines the API design characteristics that allowed the Rust API of encoding_rs to be mapped to an idiomatic C API and how it was possible to re-create an almost exact modern C++ analog of the Rust API on top of the C API. Rather than trying to cover the mapping of an arbitrary Rust API to C++, this talk focuses on patterns that are easy to map to C++ to help others to aim for such patterns when bringing Rust to C++ code bases.

(Limerick by @llogiq)

https://paris.rustfest.eu/sessions/rust-crate-as-a-cpp-library
Captions: 
	00:00:04,540 --> 00:00:12,760
a mozillian Andhra Station by heart

00:00:09,460 --> 00:00:15,309
Henry civilan got a great start pouring

00:00:12,760 --> 00:00:26,169
Firefox ciao handling tourists so far

00:00:15,309 --> 00:00:28,720
it's been quietly doing its part hi I'm

00:00:26,169 --> 00:00:30,880
Henry Silva and I work for Mozilla on

00:00:28,720 --> 00:00:33,280
the Gecko engine and today I'm gonna

00:00:30,880 --> 00:00:37,210
talk about a rust crate that also works

00:00:33,280 --> 00:00:38,920
like a modern C++ library so since we're

00:00:37,210 --> 00:00:41,320
at rest fest we probably want to write

00:00:38,920 --> 00:00:44,590
the rust code many times there's

00:00:41,320 --> 00:00:47,290
existing C++ code that we need that rust

00:00:44,590 --> 00:00:52,510
code to integrate with rusts FFI

00:00:47,290 --> 00:00:55,600
provides C api's and C++ community kind

00:00:52,510 --> 00:00:57,910
of frowns upon plain C so we will

00:00:55,600 --> 00:01:01,420
probably better accept it if we can

00:00:57,910 --> 00:01:03,070
provide more C++ like api's so today I'm

00:01:01,420 --> 00:01:05,680
gonna show you one weird trick for

00:01:03,070 --> 00:01:08,460
making rust objects look like C++

00:01:05,680 --> 00:01:14,050
objects and then I'm gonna show you

00:01:08,460 --> 00:01:16,090
rustic modern C++ types the examples

00:01:14,050 --> 00:01:18,670
we're gonna look at today come from a

00:01:16,090 --> 00:01:21,100
crate called encoding RS which is a

00:01:18,670 --> 00:01:23,290
character encoding conversion crate that

00:01:21,100 --> 00:01:26,830
conforms to the what WG encoding

00:01:23,290 --> 00:01:31,030
standard and in Firefox 56 it replaced a

00:01:26,830 --> 00:01:33,549
C++ library from 1999 it can convert to

00:01:31,030 --> 00:01:36,280
and from utf-8 which makes sense for

00:01:33,549 --> 00:01:39,760
rust code including in Firefox and it

00:01:36,280 --> 00:01:43,299
can convert to and from utx utf-16 which

00:01:39,760 --> 00:01:47,320
makes sense for the pre-existing c++

00:01:43,299 --> 00:01:50,380
code in firefox in at mozilla we don't

00:01:47,320 --> 00:01:52,600
use or we try to avoid using the c++

00:01:50,380 --> 00:01:54,880
standard library but today I'm going to

00:01:52,600 --> 00:01:58,299
show you C++ standard library types

00:01:54,880 --> 00:02:00,159
instead of Mozilla types because the the

00:01:58,299 --> 00:02:04,659
standard library types are probably more

00:02:00,159 --> 00:02:09,220
relevant to a larger number of you let's

00:02:04,659 --> 00:02:11,980
look at the rest API there's there are

00:02:09,220 --> 00:02:14,439
three structs there's a struct called

00:02:11,980 --> 00:02:17,920
encoding that represents the idea of an

00:02:14,439 --> 00:02:20,890
encoding we have a statically allocated

00:02:17,920 --> 00:02:22,990
in singleton instance for each one so

00:02:20,890 --> 00:02:25,780
there's one for utf-8 there's one for

00:02:22,990 --> 00:02:28,450
Windows one two five two and so forth it

00:02:25,780 --> 00:02:30,670
provides label resolution so when in

00:02:28,450 --> 00:02:33,760
protocol text you have charts it equals

00:02:30,670 --> 00:02:35,650
foo foo is a label and then you can go

00:02:33,760 --> 00:02:38,680
from that kind of identifier to an

00:02:35,650 --> 00:02:40,990
instance of this tract and it provides

00:02:38,680 --> 00:02:43,570
non streaming conversion which means

00:02:40,990 --> 00:02:45,489
conversion in the case where you have

00:02:43,570 --> 00:02:48,190
all the inputs available to the

00:02:45,489 --> 00:02:50,410
converter at one time when you don't

00:02:48,190 --> 00:02:53,080
have the input available at one time or

00:02:50,410 --> 00:02:55,810
you for some other reason want to do the

00:02:53,080 --> 00:02:57,880
conversion incrementally then encoding

00:02:55,810 --> 00:03:01,080
acts as a factory for decoder and

00:02:57,880 --> 00:03:04,810
encoding structs encoder structs that

00:03:01,080 --> 00:03:07,420
encapsulate the streaming state so here

00:03:04,810 --> 00:03:10,690
we see some code that uses this how to

00:03:07,420 --> 00:03:14,110
obtain instances first we see that we

00:03:10,690 --> 00:03:16,360
refer to encoding by references that

00:03:14,110 --> 00:03:18,880
have the static lifetime because they

00:03:16,360 --> 00:03:23,019
are statically allocated Singleton's if

00:03:18,880 --> 00:03:26,110
we have a variable called a byte slice

00:03:23,019 --> 00:03:28,989
from protocol that contains the Foo part

00:03:26,110 --> 00:03:32,260
from charset equals foo we can pass it

00:03:28,989 --> 00:03:34,390
to encoding for a label and then we get

00:03:32,260 --> 00:03:37,150
back an instance or if it didn't match

00:03:34,390 --> 00:03:40,600
then we default to Windows one two five

00:03:37,150 --> 00:03:43,420
two so we see here as an example that we

00:03:40,600 --> 00:03:47,230
can indeed refer to the encoding is by

00:03:43,420 --> 00:03:49,209
named static then we create use the

00:03:47,230 --> 00:03:52,630
encoding as a factory to create a

00:03:49,209 --> 00:03:56,070
decoder and we see that as is usual in

00:03:52,630 --> 00:03:59,980
rust the decoder is returned by value

00:03:56,070 --> 00:04:03,660
the crate uses enum based polymorphism

00:03:59,980 --> 00:04:06,940
so the names encoding decoding encoder

00:04:03,660 --> 00:04:09,250
sound like they could be traits but they

00:04:06,940 --> 00:04:11,500
are indeed structs and we'll come back

00:04:09,250 --> 00:04:14,920
later to why this is important so for

00:04:11,500 --> 00:04:18,010
example the struct decoder has a field

00:04:14,920 --> 00:04:22,330
variant of typed variant decoder which

00:04:18,010 --> 00:04:25,030
is an enum that wraps a struct of that

00:04:22,330 --> 00:04:31,090
implements a concrete decoder for a

00:04:25,030 --> 00:04:31,689
given encoding the fundamental operation

00:04:31,090 --> 00:04:35,289
of the stream

00:04:31,689 --> 00:04:38,619
being API looks like this it takes a

00:04:35,289 --> 00:04:42,219
slice of bytes as an input it takes a

00:04:38,619 --> 00:04:44,649
caller allocated slice of output code

00:04:42,219 --> 00:04:47,139
units so in the streaming operation

00:04:44,649 --> 00:04:49,689
there are no heap allocations performed

00:04:47,139 --> 00:04:51,189
by encoding RS itself it takes a boolean

00:04:49,689 --> 00:04:53,979
indicating whether this is the last

00:04:51,189 --> 00:04:56,709
slice to convert and then it returns a

00:04:53,979 --> 00:04:58,569
tuple of decoder result how many bytes

00:04:56,709 --> 00:05:01,719
were read and how many code units were

00:04:58,569 --> 00:05:05,319
written decode result is a non C like

00:05:01,719 --> 00:05:07,779
enum because it can rap in the malformed

00:05:05,319 --> 00:05:10,319
case it can wrap some information about

00:05:07,779 --> 00:05:14,409
the malformed byte sequence that we saw

00:05:10,319 --> 00:05:17,949
in the non streaming case we take a

00:05:14,409 --> 00:05:22,300
slice of bytes as input and and and then

00:05:17,949 --> 00:05:26,919
we tie to its lifetime a cow of stir so

00:05:22,300 --> 00:05:29,619
if we are decoding an ASCII compatible

00:05:26,919 --> 00:05:32,709
encoding and the input is all ASCII then

00:05:29,619 --> 00:05:37,719
we simply borrow the input and otherwise

00:05:32,709 --> 00:05:40,149
we have to go and allocate a string then

00:05:37,719 --> 00:05:43,689
we get to the C++ part so how do we even

00:05:40,149 --> 00:05:45,969
know what is good modern C++ what what

00:05:43,689 --> 00:05:49,169
should we be aiming for we want some

00:05:45,969 --> 00:05:52,149
guidelines for using modern C++ well and

00:05:49,169 --> 00:05:54,009
there is a document called C++ core

00:05:52,149 --> 00:05:57,429
guidelines that answers this question

00:05:54,009 --> 00:06:01,059
and this isn't just some random document

00:05:57,429 --> 00:06:03,639
on the internet even though it's not an

00:06:01,059 --> 00:06:05,679
official document of the C++ standards

00:06:03,639 --> 00:06:08,379
committee it's edited by B earnest

00:06:05,679 --> 00:06:10,629
Travis Tripp the creator of C++ and herb

00:06:08,379 --> 00:06:12,909
Sutter the convener of the C++ Standards

00:06:10,629 --> 00:06:17,139
Committee so we'll believe that this is

00:06:12,909 --> 00:06:20,439
authoritative and when looking at these

00:06:17,139 --> 00:06:22,719
guidelines we see that it includes a

00:06:20,439 --> 00:06:24,789
number of rustic things now I'm not

00:06:22,719 --> 00:06:27,039
saying that C++ gets those things from

00:06:24,789 --> 00:06:29,199
rest rather both languages draw from the

00:06:27,039 --> 00:06:31,779
same inspirations but the conclusion

00:06:29,199 --> 00:06:35,469
remains that if we want to provide a

00:06:31,779 --> 00:06:39,399
modern C++ API to a rest crate we should

00:06:35,469 --> 00:06:42,159
be trying to recreate the rust API using

00:06:39,399 --> 00:06:45,150
C++ types on the other side of the FFI

00:06:42,159 --> 00:06:49,110
and and this way we'll end up with

00:06:45,150 --> 00:06:52,170
a C++ API that's more modern than the

00:06:49,110 --> 00:06:55,740
API of a typical C++ library out there

00:06:52,170 --> 00:06:58,590
speaking C++ libraries there's a library

00:06:55,740 --> 00:07:01,350
called guideline support library because

00:06:58,590 --> 00:07:03,870
which exists because the core guidelines

00:07:01,350 --> 00:07:06,570
tell you to use a couple of types that

00:07:03,870 --> 00:07:08,610
are not standardized yet so GSL provides

00:07:06,570 --> 00:07:12,900
those you can find it on github under

00:07:08,610 --> 00:07:15,600
Microsoft's account let's look at the

00:07:12,900 --> 00:07:21,180
first one of the GSL types with which is

00:07:15,600 --> 00:07:24,030
GSL not now it imitates a C++ pointer

00:07:21,180 --> 00:07:26,610
type as saying that this pointer is not

00:07:24,030 --> 00:07:28,470
now so that's a type system annotation

00:07:26,610 --> 00:07:31,620
it also comes with a runtime check to

00:07:28,470 --> 00:07:33,960
back that up it doesn't change the

00:07:31,620 --> 00:07:36,750
representation of the pointer anyway so

00:07:33,960 --> 00:07:42,330
it's a compile time thing in terms of

00:07:36,750 --> 00:07:46,260
the type but the check is in run time as

00:07:42,330 --> 00:07:48,570
an example let's look at how the static

00:07:46,260 --> 00:07:49,110
singleton instances of the encoding are

00:07:48,570 --> 00:07:51,900
declared

00:07:49,110 --> 00:07:54,930
so in rust we first declare a value

00:07:51,900 --> 00:07:57,570
typed static for each encoding and then

00:07:54,930 --> 00:07:59,610
we declare a reference type static that

00:07:57,570 --> 00:08:01,200
refers to the value type static because

00:07:59,610 --> 00:08:05,400
this is how you need to do things in

00:08:01,200 --> 00:08:08,130
rest in on the FFI layer we want to

00:08:05,400 --> 00:08:11,280
expose see visible pointers to those

00:08:08,130 --> 00:08:13,350
static value types so see visible in the

00:08:11,280 --> 00:08:17,040
sense that their names are not manual

00:08:13,350 --> 00:08:19,110
and since these are pointer types we

00:08:17,040 --> 00:08:21,330
need to new type the pointer and

00:08:19,110 --> 00:08:23,280
implement sync on the new type to keep

00:08:21,330 --> 00:08:26,550
the rest compiler happy about the fact

00:08:23,280 --> 00:08:28,230
that we are exposing global pointers and

00:08:26,550 --> 00:08:33,450
we're saying that yes this is now

00:08:28,230 --> 00:08:37,140
actually okay to do across threads then

00:08:33,450 --> 00:08:38,760
on the c++ side we have class encoding

00:08:37,140 --> 00:08:42,110
we'll see in a moment what it looks like

00:08:38,760 --> 00:08:46,560
and then we claimed to C++ that these

00:08:42,110 --> 00:08:49,110
global pointers that come from the car

00:08:46,560 --> 00:08:51,870
from the object code that the rest

00:08:49,110 --> 00:08:56,100
compiler gave us we claimed to C++ that

00:08:51,870 --> 00:08:57,860
their type is GSL not now constant her

00:08:56,100 --> 00:09:01,200
to the encoding class

00:08:57,860 --> 00:09:04,710
let's look at the encoding class we

00:09:01,200 --> 00:09:07,260
declare it as class encoding final so it

00:09:04,710 --> 00:09:10,380
doesn't inherit from anything and we say

00:09:07,260 --> 00:09:13,350
final so no other class can inherit from

00:09:10,380 --> 00:09:14,730
it either since all the instances came

00:09:13,350 --> 00:09:15,660
from rest they are statically allocated

00:09:14,730 --> 00:09:18,570
and rust

00:09:15,660 --> 00:09:20,790
we don't want C++ code to be able to

00:09:18,570 --> 00:09:24,300
accidentally create instances in the C++

00:09:20,790 --> 00:09:26,580
side so we tell C++ that we don't want

00:09:24,300 --> 00:09:28,980
the default constructor default copy

00:09:26,580 --> 00:09:32,790
constructor default assignment operator

00:09:28,980 --> 00:09:35,070
or the default destructor then let's

00:09:32,790 --> 00:09:39,150
look at us to the unique pointer which

00:09:35,070 --> 00:09:41,760
is to C++ as box is to rust now in the

00:09:39,150 --> 00:09:44,280
rest api we didn't see any boxes so why

00:09:41,760 --> 00:09:47,670
is this here the reason is that we saw

00:09:44,280 --> 00:09:50,870
decoder returned by value and we saw

00:09:47,670 --> 00:09:53,730
that decoder inside of it there's this

00:09:50,870 --> 00:09:56,670
variant decoder which is a scene on C

00:09:53,730 --> 00:09:59,220
like enum so decoder is a non C like

00:09:56,670 --> 00:10:01,770
struct and we don't have a well-defined

00:09:59,220 --> 00:10:05,400
way to return it over the FFI by value

00:10:01,770 --> 00:10:07,320
in theory we could have c++ allocate

00:10:05,400 --> 00:10:09,090
some memory provide a pointer to that

00:10:07,320 --> 00:10:11,100
memory have rest right through the

00:10:09,090 --> 00:10:14,100
pointer but then we wouldn't get

00:10:11,100 --> 00:10:16,560
idiomatic ergonomics on the c++ side so

00:10:14,100 --> 00:10:20,880
we take the cost of a heap allocation to

00:10:16,560 --> 00:10:24,180
get idiomatic ergonomics in both cases

00:10:20,880 --> 00:10:26,550
these are smart pointers with at most

00:10:24,180 --> 00:10:28,890
like one owner at a time with move

00:10:26,550 --> 00:10:32,520
semantics we can declare both types in

00:10:28,890 --> 00:10:34,710
both languages in rust when we want a

00:10:32,520 --> 00:10:38,640
box for foo we call the constructor for

00:10:34,710 --> 00:10:42,840
foo pass it to the constructor for box

00:10:38,640 --> 00:10:44,730
in C++ since APIs 14 it's considered

00:10:42,840 --> 00:10:47,700
better practice to use a function

00:10:44,730 --> 00:10:49,710
template called make unique to

00:10:47,700 --> 00:10:52,470
instantiate as to the unique pointer of

00:10:49,710 --> 00:10:55,380
foo in both languages we can tell the

00:10:52,470 --> 00:10:57,330
smart pointer to forget about the memory

00:10:55,380 --> 00:10:59,460
that it's managing and give us the raw

00:10:57,330 --> 00:11:02,400
pointer to the memory then in both

00:10:59,460 --> 00:11:07,020
languages we can put a smart pointer

00:11:02,400 --> 00:11:09,109
back together from a row pointer let's

00:11:07,020 --> 00:11:11,789
look at a concrete example

00:11:09,109 --> 00:11:15,089
so on the encoding struct we had a

00:11:11,789 --> 00:11:19,169
factory method called new decoder that

00:11:15,089 --> 00:11:23,339
takes self by reference and returns a

00:11:19,169 --> 00:11:28,979
decoder by value then on the FFI layer

00:11:23,339 --> 00:11:31,979
we since we are wrapping a method of a

00:11:28,979 --> 00:11:33,779
struct called encoding we prefix the

00:11:31,979 --> 00:11:36,419
name of the function with the name of

00:11:33,779 --> 00:11:40,499
the struct so we call the function

00:11:36,419 --> 00:11:42,779
encoding new decoder we take what

00:11:40,499 --> 00:11:45,419
becomes the self reference in the case

00:11:42,779 --> 00:11:48,029
of calling the method as a pointer so we

00:11:45,419 --> 00:11:50,279
get a pointer to an encoding as an

00:11:48,029 --> 00:11:54,139
argument we return a mute pointer to a

00:11:50,279 --> 00:11:56,759
decoder so we call a new decoder on the

00:11:54,139 --> 00:11:59,399
object that's pointed to by the pointer

00:11:56,759 --> 00:12:01,619
pass it to the constructor a box and

00:11:59,399 --> 00:12:05,309
then immediately tell box to forget

00:12:01,619 --> 00:12:06,899
about what just did since we told box to

00:12:05,309 --> 00:12:09,029
forget about what it just did we need

00:12:06,899 --> 00:12:10,169
something else to be able to free this

00:12:09,029 --> 00:12:13,409
allocation later

00:12:10,169 --> 00:12:16,219
so we declare a function called decoder

00:12:13,409 --> 00:12:19,619
free that takes a pointer to a decoder

00:12:16,219 --> 00:12:21,539
puts a box back together for it assigns

00:12:19,619 --> 00:12:24,359
that you are variable the variable goes

00:12:21,539 --> 00:12:29,819
out of scope and and and then the memory

00:12:24,359 --> 00:12:32,729
gets freed on the c++ side we again like

00:12:29,819 --> 00:12:35,189
in rust we had a method called new

00:12:32,729 --> 00:12:38,039
decoder we declare a method called new

00:12:35,189 --> 00:12:41,279
decoder that returns us to date stood a

00:12:38,039 --> 00:12:43,589
unique pointer of decoder and we say

00:12:41,279 --> 00:12:46,829
that it's Const because it doesn't

00:12:43,589 --> 00:12:50,579
modify the encoding itself so that this

00:12:46,829 --> 00:12:53,579
pointer is a type conspirator we pass

00:12:50,579 --> 00:12:56,249
this pointer to the FFI function that we

00:12:53,579 --> 00:12:58,889
created and then we construct us to do

00:12:56,249 --> 00:13:03,329
you need pointer around the raw pointer

00:12:58,889 --> 00:13:06,779
that we get back on the deletion side

00:13:03,329 --> 00:13:10,079
it's more involved on the decoder object

00:13:06,779 --> 00:13:12,169
we have an empty destructor because we

00:13:10,079 --> 00:13:16,049
don't want that to do anything and we

00:13:12,169 --> 00:13:19,169
overload operator delete that takes a

00:13:16,049 --> 00:13:21,779
void pointer to decoder for reasons but

00:13:19,169 --> 00:13:22,860
it's guaranteed to be reinterpreted as a

00:13:21,779 --> 00:13:25,980
pointer to

00:13:22,860 --> 00:13:28,710
a decoder so we do that and we pass the

00:13:25,980 --> 00:13:31,290
pointer to the decoder fee-free FF I

00:13:28,710 --> 00:13:34,680
function and this way when studio unique

00:13:31,290 --> 00:13:38,640
pointer goes out of scope it fur it

00:13:34,680 --> 00:13:40,860
deletes its pointer to decoder it runs

00:13:38,640 --> 00:13:43,680
the destructor that does nothing and

00:13:40,860 --> 00:13:46,410
then we route the pointer back to rust

00:13:43,680 --> 00:13:49,680
for the memory to be freed with the

00:13:46,410 --> 00:13:52,680
right allocator and as with encoding we

00:13:49,680 --> 00:13:54,720
tell C++ that we don't want instances of

00:13:52,680 --> 00:13:58,650
these to be able to be created on the

00:13:54,720 --> 00:14:02,070
C++ side now how is that that possible

00:13:58,650 --> 00:14:04,140
we had some pointers from rust then we

00:14:02,070 --> 00:14:08,280
just claimed to C++ that these are some

00:14:04,140 --> 00:14:10,830
pointers to C++ class types and then we

00:14:08,280 --> 00:14:14,820
passed that this pointer back to us so

00:14:10,830 --> 00:14:18,660
what's going on here to see what a

00:14:14,820 --> 00:14:22,440
method call in in even means let's look

00:14:18,660 --> 00:14:25,650
at method calls in rust so if we have a

00:14:22,440 --> 00:14:28,380
struct foo and it has a method get Val

00:14:25,650 --> 00:14:32,160
and then we have an instance of foo

00:14:28,380 --> 00:14:35,400
called bar and we call bar get Val it's

00:14:32,160 --> 00:14:37,950
just syntactic sugar for foo colon colon

00:14:35,400 --> 00:14:41,310
get val and passing a reference to bar

00:14:37,950 --> 00:14:44,370
as an explicit first argument and that

00:14:41,310 --> 00:14:46,350
sort of explains why it's declared in a

00:14:44,370 --> 00:14:50,250
way that self is the first argument so

00:14:46,350 --> 00:14:53,520
that's all there is to it and on the c++

00:14:50,250 --> 00:14:57,060
side it's the same story except this has

00:14:53,520 --> 00:15:00,810
the role of reference to self in rust in

00:14:57,060 --> 00:15:03,930
c++ we don't write the this pointer

00:15:00,810 --> 00:15:07,710
explicitly in the argument list but we

00:15:03,930 --> 00:15:09,900
do write the constants of this after the

00:15:07,710 --> 00:15:13,410
argument list if we want it to be a

00:15:09,900 --> 00:15:14,760
constant fighter type the important

00:15:13,410 --> 00:15:19,050
thing here is that there are no be

00:15:14,760 --> 00:15:22,200
tables so in in rust trade of a pointer

00:15:19,050 --> 00:15:26,250
a pointer that to a trade a trade type

00:15:22,200 --> 00:15:28,680
pointer is two pointers one pointer to

00:15:26,250 --> 00:15:30,930
the object instance and another pointer

00:15:28,680 --> 00:15:33,930
to an array of function pointers for

00:15:30,930 --> 00:15:35,430
operating on that instance and since we

00:15:33,930 --> 00:15:36,150
want these pointers to travel back and

00:15:35,430 --> 00:15:44,970
forth

00:15:36,150 --> 00:15:51,450
the languages because since C++ uses a

00:15:44,970 --> 00:15:58,170
plane pointer to point to objects we

00:15:51,450 --> 00:16:01,050
can't we can't have the other pointer

00:15:58,170 --> 00:16:02,610
from the duplicate dual pointer from

00:16:01,050 --> 00:16:05,490
rest to travel over because we don't

00:16:02,610 --> 00:16:07,230
have place for the other half so that's

00:16:05,490 --> 00:16:10,080
why we can't have rest rate objects on

00:16:07,230 --> 00:16:13,500
the other hand C++ needs another place

00:16:10,080 --> 00:16:15,450
for its vtable pointer because the

00:16:13,500 --> 00:16:18,150
pointers to objects are plane pointers

00:16:15,450 --> 00:16:20,910
so it puts its vtable pointer on the

00:16:18,150 --> 00:16:24,510
objects themselves so when you have

00:16:20,910 --> 00:16:27,510
inheritance in C++ C++ goes ahead and

00:16:24,510 --> 00:16:30,270
dereferences the this pointer to find a

00:16:27,510 --> 00:16:33,360
vtable pointer and since this is

00:16:30,270 --> 00:16:37,080
actually pointing to a rest object there

00:16:33,360 --> 00:16:39,540
is no c++ vtable pointer there and and

00:16:37,080 --> 00:16:41,760
we can't have c++ d referencing that

00:16:39,540 --> 00:16:44,459
this pointer so we just can't have any

00:16:41,760 --> 00:16:47,040
inheritance on the c++ side which means

00:16:44,459 --> 00:16:49,709
that we can't inherit from some kind of

00:16:47,040 --> 00:16:51,959
common superclass of a c++ framework in

00:16:49,709 --> 00:16:55,170
gecko we don't get to inherit from NSN

00:16:51,959 --> 00:16:57,390
supports if the if we were in a cute app

00:16:55,170 --> 00:17:00,570
we wouldn't be able to inherit from q

00:16:57,390 --> 00:17:03,620
objects right for example then let's

00:17:00,570 --> 00:17:08,459
take a look at these more of these

00:17:03,620 --> 00:17:12,000
rustic c++ types there's studio optional

00:17:08,459 --> 00:17:14,550
which is like option in rust in rust we

00:17:12,000 --> 00:17:17,189
can return none in c++ we can return

00:17:14,550 --> 00:17:19,620
student no opt in rust we can return

00:17:17,189 --> 00:17:23,610
some food in C++ we'll just return foo

00:17:19,620 --> 00:17:26,610
and some implicit stuff happens we can

00:17:23,610 --> 00:17:30,179
ask if option ORS to the optional wraps

00:17:26,610 --> 00:17:32,100
of value we can get that value or we can

00:17:30,179 --> 00:17:34,080
get that value or if it doesn't wrap a

00:17:32,100 --> 00:17:36,240
value take some default so it looks like

00:17:34,080 --> 00:17:37,890
it's just the same thing there is one

00:17:36,240 --> 00:17:40,290
thing to be aware of though which is

00:17:37,890 --> 00:17:41,940
that the most ergonomic way to extract a

00:17:40,290 --> 00:17:44,610
value from us to the optional is

00:17:41,940 --> 00:17:47,330
operator star which is unchecked and

00:17:44,610 --> 00:17:50,100
therefore unsafe so watch out for that

00:17:47,330 --> 00:17:53,250
in rust we often like to

00:17:50,100 --> 00:17:55,799
return multiple values as tuples and in

00:17:53,250 --> 00:17:58,410
C++ we have stood a tuple in both

00:17:55,799 --> 00:18:01,620
languages we can declare methods that

00:17:58,410 --> 00:18:04,410
return a tuple of some types in both

00:18:01,620 --> 00:18:07,710
languages we can take some values and

00:18:04,410 --> 00:18:10,590
and return them as a tuple and in both

00:18:07,710 --> 00:18:12,570
languages we can take a return to pool

00:18:10,590 --> 00:18:15,660
and be structure it into a bunch of

00:18:12,570 --> 00:18:17,730
variables as is usual with rust if we

00:18:15,660 --> 00:18:20,490
want mutability in rust we say mute and

00:18:17,730 --> 00:18:25,470
in if we don't want immutability in C++

00:18:20,490 --> 00:18:29,970
we say Const again the same thing GSL

00:18:25,470 --> 00:18:34,230
span provides the slice concept for C++

00:18:29,970 --> 00:18:36,120
a slice is a pointer and a length a

00:18:34,230 --> 00:18:41,460
conspirator in the case of a read-only

00:18:36,120 --> 00:18:44,309
span so in C++ GSL span puts these

00:18:41,460 --> 00:18:47,400
together and in the case of a read-only

00:18:44,309 --> 00:18:50,490
span the comm specifier goes inside the

00:18:47,400 --> 00:18:53,909
type parameter of GSL span we can use

00:18:50,490 --> 00:18:56,850
GSL makespan to take a span view to a

00:18:53,909 --> 00:18:59,400
contiguous container and then we can use

00:18:56,850 --> 00:19:02,039
a two argument version of GSL span to

00:18:59,400 --> 00:19:07,500
put a span together from a pointer and a

00:19:02,039 --> 00:19:10,049
length we can access spans like we do

00:19:07,500 --> 00:19:13,320
slices in in rust we can iterate over

00:19:10,049 --> 00:19:15,900
them we can index into them and indexing

00:19:13,320 --> 00:19:19,799
is a checked operator operation even in

00:19:15,900 --> 00:19:21,809
in C++ so it's safe and we can take the

00:19:19,799 --> 00:19:24,000
pointer and length back apart again

00:19:21,809 --> 00:19:26,490
there's something some like tiny thing

00:19:24,000 --> 00:19:28,860
to be aware of which is that subs we're

00:19:26,490 --> 00:19:30,750
taking a sub span is slightly less organ

00:19:28,860 --> 00:19:33,870
amah for common cases and in rest

00:19:30,750 --> 00:19:36,870
because the substance planet function

00:19:33,870 --> 00:19:39,120
takes the start index and the length of

00:19:36,870 --> 00:19:41,820
the sub span so you have to compute the

00:19:39,120 --> 00:19:44,400
length yourself in case you're sort of

00:19:41,820 --> 00:19:48,210
assuming the resting of being able to

00:19:44,400 --> 00:19:52,020
pass the index to the next item not

00:19:48,210 --> 00:19:54,690
included since we have our own versions

00:19:52,020 --> 00:19:58,200
of all of these in Mozilla code we get

00:19:54,690 --> 00:20:01,049
to fix design bugs like that you should

00:19:58,200 --> 00:20:03,270
be aware that in C++ read-only string

00:20:01,049 --> 00:20:03,810
slices are a special case called stew

00:20:03,270 --> 00:20:07,620
the string

00:20:03,810 --> 00:20:10,170
or in the utf-16 cases today use 16

00:20:07,620 --> 00:20:10,980
string view that are already in the

00:20:10,170 --> 00:20:13,020
standard library

00:20:10,980 --> 00:20:16,170
unlike span which you need to get from

00:20:13,020 --> 00:20:17,460
GSL this kind of makes sense like

00:20:16,170 --> 00:20:19,770
superficial sense from a rasp

00:20:17,460 --> 00:20:22,890
perspective since rust has separate

00:20:19,770 --> 00:20:27,030
string slices but in rust those provide

00:20:22,890 --> 00:20:29,400
utf-8 validity these don't so they

00:20:27,030 --> 00:20:31,410
aren't that useful compared to GSL span

00:20:29,400 --> 00:20:33,930
it's more a matter of the committee

00:20:31,410 --> 00:20:35,580
being able to agree to this first but if

00:20:33,930 --> 00:20:38,040
you use the sepals for standard library

00:20:35,580 --> 00:20:44,190
you should just be using these and not

00:20:38,040 --> 00:20:46,470
go against the way of the land a key

00:20:44,190 --> 00:20:49,770
difference though between slices and

00:20:46,470 --> 00:20:52,740
spans is that spans a zero length span

00:20:49,770 --> 00:20:54,810
can contain a null pointer a slice can

00:20:52,740 --> 00:20:58,050
never contain a null pointer because

00:20:54,810 --> 00:21:02,550
rust has an optimization that an option

00:20:58,050 --> 00:21:07,290
of slice takes the same space as a slice

00:21:02,550 --> 00:21:10,290
and to distinguish some wrapping a zero

00:21:07,290 --> 00:21:12,900
and span from none we need some nonzero

00:21:10,290 --> 00:21:16,200
bits in the pointer to act as the

00:21:12,900 --> 00:21:19,740
discriminant so when you have some

00:21:16,200 --> 00:21:22,200
pointers that you take from span and you

00:21:19,740 --> 00:21:25,410
want to create create a slice with them

00:21:22,200 --> 00:21:29,010
you have to have something along the way

00:21:25,410 --> 00:21:32,700
that replaces all no pointers with bogus

00:21:29,010 --> 00:21:34,680
pointers and and then let's look at a

00:21:32,700 --> 00:21:38,430
concrete example that puts all these

00:21:34,680 --> 00:21:39,870
together on the encoding struct we have

00:21:38,430 --> 00:21:42,960
a static method called

00:21:39,870 --> 00:21:45,870
for bomb that takes a bite a slice of

00:21:42,960 --> 00:21:48,810
bytes checks if it starts with a byte

00:21:45,870 --> 00:21:54,150
order mark if it doesn't returns none if

00:21:48,810 --> 00:21:57,570
it does returns a triple of the encoding

00:21:54,150 --> 00:22:00,450
and the length of the byte order mark on

00:21:57,570 --> 00:22:02,880
the FFI layer we have a bunch of stuff

00:22:00,450 --> 00:22:05,220
going on here again we have the same

00:22:02,880 --> 00:22:08,730
naming convention as before but since

00:22:05,220 --> 00:22:10,740
it's a static method we don't take the a

00:22:08,730 --> 00:22:13,770
pointer that would correspond to the

00:22:10,740 --> 00:22:15,190
self reference or this pointer we just

00:22:13,770 --> 00:22:18,610
take

00:22:15,190 --> 00:22:22,900
the slice decomposed into pointer and

00:22:18,610 --> 00:22:25,660
length since we have two values to

00:22:22,900 --> 00:22:28,330
return the encoding and the length of

00:22:25,660 --> 00:22:31,780
the bomb we we don't we only get one

00:22:28,330 --> 00:22:34,330
return value from C so we use that for a

00:22:31,780 --> 00:22:37,980
pointer to encoding and then we need an

00:22:34,330 --> 00:22:40,450
out pram for the length of the bomb

00:22:37,980 --> 00:22:42,610
since the length of the bomb is kinda

00:22:40,450 --> 00:22:46,120
logically related to the incoming slice

00:22:42,610 --> 00:22:50,500
instead of introducing an an extra out

00:22:46,120 --> 00:22:53,350
pram we reuse the incoming length as an

00:22:50,500 --> 00:22:56,950
in/out pram so it's a mute pointer to

00:22:53,350 --> 00:23:00,910
use size instead of use size in the case

00:22:56,950 --> 00:23:04,720
the rest method returns none we return a

00:23:00,910 --> 00:23:07,870
null pointer and 0 length and then on

00:23:04,720 --> 00:23:11,470
the c++ side if we reverse the whole

00:23:07,870 --> 00:23:15,100
thing and now we get to declare recreate

00:23:11,470 --> 00:23:18,070
the rest API on c++ side so on class

00:23:15,100 --> 00:23:21,400
encoding we have a static method called

00:23:18,070 --> 00:23:23,590
for bomb that returns us to the optional

00:23:21,400 --> 00:23:26,380
containing ass to the tuple containing

00:23:23,590 --> 00:23:29,650
GS l not null of Const pointer to

00:23:26,380 --> 00:23:34,930
encoding and a size T and as an argument

00:23:29,650 --> 00:23:36,970
takes a GS l span of const u + 8 t + and

00:23:34,930 --> 00:23:40,690
then we need to create a stack variable

00:23:36,970 --> 00:23:43,420
for use its address as an in/out pram we

00:23:40,690 --> 00:23:46,570
when we take the pointer from the slice

00:23:43,420 --> 00:23:48,490
we pass it to malta bogus in order to

00:23:46,570 --> 00:23:51,700
make it okay to use as a pointer to

00:23:48,490 --> 00:23:56,290
slice if we get back a normal encoding

00:23:51,700 --> 00:23:58,030
we create a student tuple and and here

00:23:56,290 --> 00:24:01,060
we need to do it explicitly because we

00:23:58,030 --> 00:24:05,170
have a tuple inside an option so the

00:24:01,060 --> 00:24:07,420
brace syntax would make the inference

00:24:05,170 --> 00:24:09,940
fall over we have to tell at first that

00:24:07,420 --> 00:24:12,610
this is a tuple and then the optional

00:24:09,940 --> 00:24:15,250
gets created implicitly and and if we

00:24:12,610 --> 00:24:19,570
got a null pointer we return a student

00:24:15,250 --> 00:24:23,590
know logged in in the streaming API

00:24:19,570 --> 00:24:27,670
though we saw that we had non C like

00:24:23,590 --> 00:24:32,380
enum in in the rest api so can we

00:24:27,670 --> 00:24:36,460
the same thing with it C++ does have a

00:24:32,380 --> 00:24:39,130
typesafe discriminated Union types calls

00:24:36,460 --> 00:24:41,860
to the variant but unfortunately it's

00:24:39,130 --> 00:24:44,440
not really enum the variants are not

00:24:41,860 --> 00:24:46,900
named it was proposed as L variant but

00:24:44,440 --> 00:24:49,210
not accepted it's legal to declare

00:24:46,900 --> 00:24:51,160
duplicate types but if you do things

00:24:49,210 --> 00:24:54,160
become really impractical so not in

00:24:51,160 --> 00:24:57,040
practice but most importantly there's no

00:24:54,160 --> 00:24:59,560
language level analog for a match one

00:24:57,040 --> 00:25:02,080
was proposed as inspect but again not

00:24:59,560 --> 00:25:04,660
accepted so instead I just ended up

00:25:02,080 --> 00:25:07,630
manually packing the bits into a

00:25:04,660 --> 00:25:11,050
thirty-two and using that both in the C

00:25:07,630 --> 00:25:14,770
API and in the C++ API since most of the

00:25:11,050 --> 00:25:16,870
time the in the information wrapped in

00:25:14,770 --> 00:25:20,220
the malformed case isn't going to be

00:25:16,870 --> 00:25:22,270
looked at by most applications it's just

00:25:20,220 --> 00:25:25,420
specialized applications that actually

00:25:22,270 --> 00:25:30,130
want to look at that what about the cows

00:25:25,420 --> 00:25:33,130
though in the non streaming API we saw

00:25:30,130 --> 00:25:36,370
that encoding RS was returning cows

00:25:33,130 --> 00:25:40,330
obscure and even the cow part isn't the

00:25:36,370 --> 00:25:44,460
problem just the the the string or vac

00:25:40,330 --> 00:25:49,870
is a problem because she doesn't have a

00:25:44,460 --> 00:25:52,690
universally accepted like standard

00:25:49,870 --> 00:25:55,690
library way of representing a growable

00:25:52,690 --> 00:25:57,370
buffer that knows its length but since

00:25:55,690 --> 00:25:59,530
the non streaming API is just

00:25:57,370 --> 00:26:00,400
convenience functionality on top of the

00:25:59,530 --> 00:26:05,560
streaming API

00:26:00,400 --> 00:26:08,560
I just didn't expose the non streaming

00:26:05,560 --> 00:26:10,690
API to C at all and instead recreated

00:26:08,560 --> 00:26:13,260
that functionality on top of the stream

00:26:10,690 --> 00:26:17,650
streaming functionality on the C++ sign

00:26:13,260 --> 00:26:20,710
so in C++ we could in principle declare

00:26:17,650 --> 00:26:22,540
a studio variant of studio string

00:26:20,710 --> 00:26:24,520
instead of string view and that would be

00:26:22,540 --> 00:26:28,690
like structurally the same thing as a

00:26:24,520 --> 00:26:31,600
cow but in C++ we don't have a burrow

00:26:28,690 --> 00:26:33,970
checker so we can't represent the

00:26:31,600 --> 00:26:37,090
lifetime of stew the string view which

00:26:33,970 --> 00:26:40,170
makes this sort of thing very unsafe in

00:26:37,090 --> 00:26:42,990
C++ so if we return

00:26:40,170 --> 00:26:45,780
a string to the string view or a GSL

00:26:42,990 --> 00:26:48,540
span there is no compiler mechanism

00:26:45,780 --> 00:26:51,660
making sure that the memory that it

00:26:48,540 --> 00:26:56,100
points to lives for as long at least as

00:26:51,660 --> 00:26:59,760
long enough as as long as the string

00:26:56,100 --> 00:27:02,160
view or span so instead I decided to

00:26:59,760 --> 00:27:03,990
keep it simple for the standard library

00:27:02,160 --> 00:27:07,799
binding and just return us to the string

00:27:03,990 --> 00:27:12,410
in this case in the Gecko case xpcom

00:27:07,799 --> 00:27:15,720
strings have or can have heap-allocated

00:27:12,410 --> 00:27:18,179
shared buffers so in that case a borrow

00:27:15,720 --> 00:27:21,780
just becomes a reference count increment

00:27:18,179 --> 00:27:26,910
Saburo was possible in a safe way in the

00:27:21,780 --> 00:27:28,890
Gecko case in fairness let's look at

00:27:26,910 --> 00:27:31,730
what we didn't see today so it seemed

00:27:28,890 --> 00:27:35,190
like okay we had these things and they

00:27:31,730 --> 00:27:38,640
nicely translated to c++ except for the

00:27:35,190 --> 00:27:41,850
enum a sort of variant thing and like

00:27:38,640 --> 00:27:45,510
this looked nice so so in fairness what

00:27:41,850 --> 00:27:47,820
was not here in this example we didn't

00:27:45,510 --> 00:27:50,309
see rust code examining any non

00:27:47,820 --> 00:27:53,309
primitive c++ types it's totally doable

00:27:50,309 --> 00:27:56,130
but we didn't see it today we didn't see

00:27:53,309 --> 00:27:58,440
rust code holding pointers to C++

00:27:56,130 --> 00:28:01,470
objects again doable but increases

00:27:58,440 --> 00:28:05,250
complexity and we didn't see rust code

00:28:01,470 --> 00:28:08,400
calling out to FF I and and again it's

00:28:05,250 --> 00:28:11,059
doable but if you do watch out for C

00:28:08,400 --> 00:28:14,280
plug the C++ code that you call into

00:28:11,059 --> 00:28:18,600
freeing the arguments that you got from

00:28:14,280 --> 00:28:20,669
C++ it's a like a normal C++ concern but

00:28:18,600 --> 00:28:22,410
when you're writing rust code you might

00:28:20,669 --> 00:28:25,470
not be thinking of it in terms of your

00:28:22,410 --> 00:28:30,059
arguments disappearing while you are in

00:28:25,470 --> 00:28:33,210
a function so let's recap what we saw we

00:28:30,059 --> 00:28:35,490
saw that that this pointer in C++ is

00:28:33,210 --> 00:28:37,760
just like a reference to self and and

00:28:35,490 --> 00:28:41,040
those are just syntactic sugar in the

00:28:37,760 --> 00:28:44,340
non-inherited non-trade case so we can't

00:28:41,040 --> 00:28:46,850
have C++ inheritance we can't have rust

00:28:44,340 --> 00:28:50,760
straight objects going over the boundary

00:28:46,850 --> 00:28:52,610
however we can declare C++ visible rust

00:28:50,760 --> 00:28:55,880
statics

00:28:52,610 --> 00:28:58,070
we saw how GSL not now can be used to

00:28:55,880 --> 00:29:01,010
make c++ pointers more like trust

00:28:58,070 --> 00:29:04,100
references we learned about Stu the

00:29:01,010 --> 00:29:08,120
unique pointer which is to C++ as boxes

00:29:04,100 --> 00:29:10,880
rust we saw how to tell C++ that we

00:29:08,120 --> 00:29:13,450
don't want some default from structures

00:29:10,880 --> 00:29:16,010
were generated so that we don't

00:29:13,450 --> 00:29:21,910
accidentally instantiate the reflector

00:29:16,010 --> 00:29:24,890
classes from C++ we saw how we can use

00:29:21,910 --> 00:29:27,620
overloading of operator delete to route

00:29:24,890 --> 00:29:31,010
the deletion of a heap-allocated rust

00:29:27,620 --> 00:29:34,820
object that pretends to be a C++ object

00:29:31,010 --> 00:29:39,530
back to rust when it's time to release

00:29:34,820 --> 00:29:41,420
it we saw that the C++ now has student

00:29:39,530 --> 00:29:44,720
optional that is just like option in

00:29:41,420 --> 00:29:47,890
rust that we use a lot so that we can

00:29:44,720 --> 00:29:51,920
return multiple values in both languages

00:29:47,890 --> 00:29:55,460
we saw that there is a the sliced

00:29:51,920 --> 00:29:59,780
concept in C++ and there's a special

00:29:55,460 --> 00:30:02,030
case for read-only string slices and we

00:29:59,780 --> 00:30:05,030
saw that there that discriminated

00:30:02,030 --> 00:30:08,390
typesafe unions exist but they are kind

00:30:05,030 --> 00:30:11,630
of inconvenient to use and then we saw

00:30:08,390 --> 00:30:14,510
saw that the C++ type system is able to

00:30:11,630 --> 00:30:15,560
represent the structure of cows but not

00:30:14,510 --> 00:30:18,920
their lifetimes

00:30:15,560 --> 00:30:22,490
which makes cows dangerous in C++ so we

00:30:18,920 --> 00:30:25,040
shouldn't just do all the things we're

00:30:22,490 --> 00:30:27,560
doing the rest in C++ but like this

00:30:25,040 --> 00:30:30,860
thing becomes dangerous so let's not do

00:30:27,560 --> 00:30:33,350
that one and that's it you can find the

00:30:30,860 --> 00:30:43,009
slides at that address Thanks

00:30:33,350 --> 00:30:43,009

YouTube URL: https://www.youtube.com/watch?v=Ct7jveV7j8g


