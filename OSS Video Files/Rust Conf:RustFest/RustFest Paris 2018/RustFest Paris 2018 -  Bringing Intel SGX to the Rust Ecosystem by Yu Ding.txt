Title: RustFest Paris 2018 -  Bringing Intel SGX to the Rust Ecosystem by Yu Ding
Publication date: 2018-05-26
Playlist: RustFest Paris 2018
Description: 
	Yu Ding from Baidu X Labs today
is securely joining the fray
to rust'ly enclave
your bits to behave
that's a big deal for securitay 

In this talk, we introduce Rust SGX SDK (future code name MesaLock SGX), which can protect secrets from most attacks by combining the power of Intel SGX and Rust. Intel SGX is the next generation trusted computing technique supported in almost all recent Intel CPUs. It provides strong security guarantees and uses a completely different os/threading model, but lacks memory safety guarantees. We show how we ported Rust std and a series of fundamental and popular Rust crates into the Rust-SGX world. Whatâ€™s more, we support Xargo by providing a new target platform as x86_64-unknown-linux-sgx.

(Limerick by @llogiq)

https://paris.rustfest.eu/sessions/mesalock-sgx
Captions: 
	00:00:05,720 --> 00:00:14,250
uding from by 2x laps today is securely

00:00:10,410 --> 00:00:17,400
joining the frame to rusta lee in clave

00:00:14,250 --> 00:00:26,460
your bits to behave that's a big deal

00:00:17,400 --> 00:00:30,000
for security hello everyone I'm using

00:00:26,460 --> 00:00:33,809
from by dou X lab and I'm coming from

00:00:30,000 --> 00:00:40,079
California so it's a 10 hour jet lag I'm

00:00:33,809 --> 00:00:45,870
really sleepy now so give me some thank

00:00:40,079 --> 00:00:49,620
you this is a joint work with my

00:00:45,870 --> 00:00:52,199
colleagues to hang on below and some

00:00:49,620 --> 00:00:54,929
other colleagues I want to express my

00:00:52,199 --> 00:00:58,589
appreciate them because they really did

00:00:54,929 --> 00:01:02,100
help me a lot and first leg talk but

00:00:58,589 --> 00:01:05,159
about myself I'm a security research

00:01:02,100 --> 00:01:08,820
scientist spending my last 10 years on

00:01:05,159 --> 00:01:11,939
exploit attacks and defense and I've

00:01:08,820 --> 00:01:15,570
been working on autonomous driving

00:01:11,939 --> 00:01:18,780
project recently for the apollo apollo

00:01:15,570 --> 00:01:24,180
project in Baidu and I'm in charge of

00:01:18,780 --> 00:01:28,350
auditing the C and C++ code and since

00:01:24,180 --> 00:01:31,640
the December 20 2000 2016 I've been

00:01:28,350 --> 00:01:35,579
diving into interest checks and rust and

00:01:31,640 --> 00:01:38,939
during the two years of my rust life our

00:01:35,579 --> 00:01:42,509
team become more and more ambitious in

00:01:38,939 --> 00:01:45,090
in the beginning we only want to bring

00:01:42,509 --> 00:01:48,289
interest reacts to rust but on the road

00:01:45,090 --> 00:01:52,250
we found that we can bring the entire

00:01:48,289 --> 00:01:56,759
here as stack to rust and by the help of

00:01:52,250 --> 00:02:02,880
Russell we wrap wrap it wrap it to a

00:01:56,759 --> 00:02:05,729
drop in replacement for open SSL and for

00:02:02,880 --> 00:02:08,190
the more we implement a set of Linux

00:02:05,729 --> 00:02:10,679
users based applications and we named

00:02:08,190 --> 00:02:13,159
named them as methyl ink and a mess lock

00:02:10,679 --> 00:02:16,349
they're both open source on github and

00:02:13,159 --> 00:02:17,970
can be used directly in IOT devices and

00:02:16,349 --> 00:02:20,220
Android systems

00:02:17,970 --> 00:02:24,720
and Baidu product teams like them very

00:02:20,220 --> 00:02:29,400
much this is my outline for today so

00:02:24,720 --> 00:02:31,530
this is the first time I'm talked to the

00:02:29,400 --> 00:02:34,080
rust community instead of the security

00:02:31,530 --> 00:02:37,710
guys so I will spend a little more time

00:02:34,080 --> 00:02:41,480
on interest reacts and discuss why rust

00:02:37,710 --> 00:02:45,780
is SGX best friend so next I will use

00:02:41,480 --> 00:02:48,930
easiest the most easy simple print line

00:02:45,780 --> 00:02:53,400
as an example show how I support print

00:02:48,930 --> 00:02:56,459
line in ICS so next is the most

00:02:53,400 --> 00:03:00,000
challenge challenging part the live STD

00:02:56,459 --> 00:03:00,690
and we pour the whole entire live STD to

00:03:00,000 --> 00:03:04,650
SGX

00:03:00,690 --> 00:03:10,709
name as as Jax and underscore trusted

00:03:04,650 --> 00:03:16,040
STD and the last two sections tells you

00:03:10,709 --> 00:03:20,400
how to port more crates to as Jax and

00:03:16,040 --> 00:03:27,420
show some masterpieces already built in

00:03:20,400 --> 00:03:32,220
as Jax so what is s GX s GX is an CPU

00:03:27,420 --> 00:03:36,269
mode which can protect data i authorize

00:03:32,220 --> 00:03:38,750
the data access which means that for

00:03:36,269 --> 00:03:42,480
example in the past the OS kernel and

00:03:38,750 --> 00:03:45,600
vmm can get access to the applications

00:03:42,480 --> 00:03:49,890
memory without notice the application

00:03:45,600 --> 00:03:52,110
but with with sjx enabled the

00:03:49,890 --> 00:03:55,799
application can protect its own memory

00:03:52,110 --> 00:04:00,000
in the small yellow boxes named as as GS

00:03:55,799 --> 00:04:04,760
and clave and in this way no matter how

00:04:00,000 --> 00:04:07,860
the OS tries he cannot get read or read

00:04:04,760 --> 00:04:11,010
access to the unlived memory this is

00:04:07,860 --> 00:04:13,019
enforced by the in-house memory

00:04:11,010 --> 00:04:16,169
encryption engine the memory kim

00:04:13,019 --> 00:04:20,600
changjun is implemented as Hardware in

00:04:16,169 --> 00:04:22,260
inside as if you and it guarantees the

00:04:20,600 --> 00:04:25,350
map

00:04:22,260 --> 00:04:30,820
access control by the paid paging

00:04:25,350 --> 00:04:35,530
information and yeah so the

00:04:30,820 --> 00:04:39,100
is how the ICS unclaimed for protects

00:04:35,530 --> 00:04:44,320
avocations memory but it has a strong

00:04:39,100 --> 00:04:47,650
limitation it because the the supported

00:04:44,320 --> 00:04:52,360
memory size is quite small on each

00:04:47,650 --> 00:04:56,050
platform only 128 gigabytes of physical

00:04:52,360 --> 00:04:58,450
memory can be used for the as you as

00:04:56,050 --> 00:05:03,580
Jackson clave but don't worry

00:04:58,450 --> 00:05:06,700
intel has implemented a software by a

00:05:03,580 --> 00:05:09,820
page fault based making a mapping

00:05:06,700 --> 00:05:13,240
mechanism which can swap in and swap out

00:05:09,820 --> 00:05:17,260
the memories between trusted 128

00:05:13,240 --> 00:05:20,350
gigabytes and untrusted what no matter

00:05:17,260 --> 00:05:22,540
how much memory you have but it will be

00:05:20,350 --> 00:05:27,640
a little bit slow if you trigger a page

00:05:22,540 --> 00:05:30,850
fault and what kernel driver get get the

00:05:27,640 --> 00:05:35,560
page in and decrypt that's a little bit

00:05:30,850 --> 00:05:40,900
more performance overhead so so how do

00:05:35,560 --> 00:05:45,280
the SGS and clave works normally when

00:05:40,900 --> 00:05:48,640
they as Jax application can be splitted

00:05:45,280 --> 00:05:52,420
to two parts that I'm trusted a part of

00:05:48,640 --> 00:05:55,360
an app and a trusted part of an app in

00:05:52,420 --> 00:06:00,940
the untrusted part of app the Linux read

00:05:55,360 --> 00:06:02,320
keep accusing and QA eco which goes

00:06:00,940 --> 00:06:05,920
through the cockades

00:06:02,320 --> 00:06:09,190
of a stress and clave and start

00:06:05,920 --> 00:06:12,310
execution in the trusted part or SGS

00:06:09,190 --> 00:06:16,990
Enclave and final fan finally returns to

00:06:12,310 --> 00:06:21,280
the untrusted part of F so it works like

00:06:16,990 --> 00:06:25,870
a blocks is blocked Cisco but it does

00:06:21,280 --> 00:06:29,230
not escalate the privilege to ring zero

00:06:25,870 --> 00:06:30,210
it's it only keeps its own privilege in

00:06:29,230 --> 00:06:36,070
Greene Street

00:06:30,210 --> 00:06:39,070
so as Jax provide not only the memory

00:06:36,070 --> 00:06:41,350
encryption engine but also the remoted

00:06:39,070 --> 00:06:44,050
hesitation ability which means that

00:06:41,350 --> 00:06:47,620
everyone can remote remote

00:06:44,050 --> 00:06:51,039
a test if the SJS enclave is launched

00:06:47,620 --> 00:06:54,789
correctly the code inside Enclave is the

00:06:51,039 --> 00:06:59,349
one I want to launch this is guaranteed

00:06:54,789 --> 00:07:01,750
by the Seaview mechanism as if you will

00:06:59,349 --> 00:07:04,419
automatically calculate the char some of

00:07:01,750 --> 00:07:08,740
the loaded enclaved memory and returns

00:07:04,419 --> 00:07:11,050
you a as the result and you during the

00:07:08,740 --> 00:07:14,440
compile compile asian you can calculate

00:07:11,050 --> 00:07:16,870
the hash value by yourself and you can

00:07:14,440 --> 00:07:23,669
verify if the use these two values are

00:07:16,870 --> 00:07:28,300
equal are at the identical and the the

00:07:23,669 --> 00:07:32,319
the hash value calculated by hardware is

00:07:28,300 --> 00:07:34,780
assigned by Intel so you can verify if

00:07:32,319 --> 00:07:39,159
the report is correctly signed by Intel

00:07:34,780 --> 00:07:44,430
if the report is valid and and the hash

00:07:39,159 --> 00:07:47,740
value is identical so you can trust the

00:07:44,430 --> 00:07:50,800
the Enclave and put your secrets through

00:07:47,740 --> 00:07:53,469
the enclaves and start a calculation so

00:07:50,800 --> 00:07:56,710
the remote attestation mechanism can

00:07:53,469 --> 00:07:59,500
guarantee if a ICS Enclave is

00:07:56,710 --> 00:08:01,719
initialized correctly and whether the

00:07:59,500 --> 00:08:05,169
platform satisfies the security

00:08:01,719 --> 00:08:09,550
requirement what is the platform in s

00:08:05,169 --> 00:08:17,440
Jax the platform means CPU plus the

00:08:09,550 --> 00:08:22,900
motherboard class no no more because in

00:08:17,440 --> 00:08:24,969
some version of CPU there are some SGX

00:08:22,900 --> 00:08:27,779
parts such as private privilege

00:08:24,969 --> 00:08:32,079
escalation and it should be fixed by

00:08:27,779 --> 00:08:36,459
macro code upgrade and the bios version

00:08:32,079 --> 00:08:39,219
reflects the macro code version and the

00:08:36,459 --> 00:08:43,959
remote attestation will tell you if the

00:08:39,219 --> 00:08:47,620
bios version is higher enough to have

00:08:43,959 --> 00:08:50,860
patched all the known vulnerabilities so

00:08:47,620 --> 00:08:54,160
as Jax can be used to build a minimum

00:08:50,860 --> 00:08:58,660
set of your own trust computing base and

00:08:54,160 --> 00:09:01,179
solve the cloud computing

00:08:58,660 --> 00:09:03,519
privacy-preserving problem in this

00:09:01,179 --> 00:09:06,669
picture there are three parts the cloud

00:09:03,519 --> 00:09:09,119
service provider and the algorithm

00:09:06,669 --> 00:09:13,179
providers such as a newer Network and

00:09:09,119 --> 00:09:16,959
user who has many many data each of

00:09:13,179 --> 00:09:23,949
these parts wouldn't trust any of the

00:09:16,959 --> 00:09:28,149
other two parts because for the newer

00:09:23,949 --> 00:09:30,369
network he can't trust a cloud service

00:09:28,149 --> 00:09:35,019
provider because cloud service provider

00:09:30,369 --> 00:09:39,339
would steal the truing model from their

00:09:35,019 --> 00:09:43,239
program and and he cannot trust user

00:09:39,339 --> 00:09:46,660
because user can still can make

00:09:43,239 --> 00:09:48,759
arbitrary numbers of quick hurry to

00:09:46,660 --> 00:09:52,029
their to their neural network and get

00:09:48,759 --> 00:09:54,489
the model out and user from the other

00:09:52,029 --> 00:09:56,949
side the user can now trust both of them

00:09:54,489 --> 00:09:59,679
because the user has the data

00:09:56,949 --> 00:10:02,049
he cannot trust anyone and the cloud for

00:09:59,679 --> 00:10:05,559
service provider cannot transpose

00:10:02,049 --> 00:10:11,439
because they can DDoS the cloud service

00:10:05,559 --> 00:10:16,119
so how to solve it they can use as yes

00:10:11,439 --> 00:10:20,319
and claim the new network could be

00:10:16,119 --> 00:10:23,799
sealed within encrypted as Jack's

00:10:20,319 --> 00:10:27,459
Enclave and put it on the remote cloud

00:10:23,799 --> 00:10:30,100
and users and the their data to the

00:10:27,459 --> 00:10:32,970
remote cloud sent directly to the SGX

00:10:30,100 --> 00:10:37,089
Enclave and to the completion there so

00:10:32,970 --> 00:10:42,339
everything should be fine as a quick

00:10:37,089 --> 00:10:44,109
summary as Jax is this is designed to be

00:10:42,339 --> 00:10:47,559
a high performance memory encryption

00:10:44,109 --> 00:10:51,009
engine and with the ability to do local

00:10:47,559 --> 00:10:53,859
and remote attestation and it's the best

00:10:51,009 --> 00:10:57,519
choice for my algorithm your data

00:10:53,859 --> 00:11:03,539
whoever CPU the problem and this path

00:10:57,519 --> 00:11:06,909
choice for SMC and previously we have

00:11:03,539 --> 00:11:10,280
PowerDVD and offers over ssl

00:11:06,909 --> 00:11:13,700
which supports as shares in their portal

00:11:10,280 --> 00:11:16,370
for the power DVDs they use ICS and

00:11:13,700 --> 00:11:19,640
clave to process raw video stream

00:11:16,370 --> 00:11:22,970
directly from the blu-ray disc and this

00:11:19,640 --> 00:11:26,210
decrypted decrypt the data stream and

00:11:22,970 --> 00:11:29,870
output to screen for wolf SSL it

00:11:26,210 --> 00:11:32,800
protects the key as here as session data

00:11:29,870 --> 00:11:39,320
such master key in SES and clave and

00:11:32,800 --> 00:11:41,540
yeah that's how they use SGX so this is

00:11:39,320 --> 00:11:44,960
easy to for you guys to understand

00:11:41,540 --> 00:11:48,140
because you C or C++ code there are

00:11:44,960 --> 00:11:51,800
always partial flows use a freeze a

00:11:48,140 --> 00:11:53,990
memory corruption vulnerabilities and as

00:11:51,800 --> 00:11:56,720
Jax codes that's need memory safety

00:11:53,990 --> 00:12:00,700
because as Jax is designed to process

00:11:56,720 --> 00:12:02,810
privacy and sensitive data so as yes

00:12:00,700 --> 00:12:09,020
definitely means memory safety

00:12:02,810 --> 00:12:13,340
guarantees so I start the research in

00:12:09,020 --> 00:12:16,720
SGX and want to solve the memory safety

00:12:13,340 --> 00:12:20,180
counties in an innovation way which

00:12:16,720 --> 00:12:24,080
applies new technology of program

00:12:20,180 --> 00:12:27,110
language to the ICS programming model so

00:12:24,080 --> 00:12:31,790
I tried three different languages the

00:12:27,110 --> 00:12:37,070
colon rest and Swift first I look into :

00:12:31,790 --> 00:12:40,250
mmm I've tried my best to understand how

00:12:37,070 --> 00:12:44,660
: works but I found that : requires

00:12:40,250 --> 00:12:47,450
everything every process as a go routine

00:12:44,660 --> 00:12:51,800
and it keeps switching between the

00:12:47,450 --> 00:12:57,650
goroutines and so called Co machine in a

00:12:51,800 --> 00:13:00,260
in Co Co what appear as a cue yes it's a

00:12:57,650 --> 00:13:03,410
job queue as dynamically scheduling

00:13:00,260 --> 00:13:06,440
cannot be implemented in as GX because

00:13:03,410 --> 00:13:10,400
inside as Jax we cannot make this cause

00:13:06,440 --> 00:13:15,230
cannot decide whether or not wish myself

00:13:10,400 --> 00:13:19,339
should get get off the CPU so echo is

00:13:15,230 --> 00:13:20,660
almost impossible for as Jax and for

00:13:19,339 --> 00:13:24,350
Swift

00:13:20,660 --> 00:13:26,450
personally I I don't like the foundation

00:13:24,350 --> 00:13:30,230
corefoundation part of swift because it

00:13:26,450 --> 00:13:35,420
contains too much C and C++ code I hate

00:13:30,230 --> 00:13:39,970
I hate that so I chose wrath and in fact

00:13:35,420 --> 00:13:39,970
it's the best choice in my in my life

00:13:42,070 --> 00:13:47,450
thank you

00:13:43,400 --> 00:13:51,950
so in the past what Intel provide us is

00:13:47,450 --> 00:13:55,250
that an Intel says that every part could

00:13:51,950 --> 00:13:59,360
be written in C or C++ but with our work

00:13:55,250 --> 00:14:03,130
we can use rest for Graham the untrusted

00:13:59,360 --> 00:14:06,350
app and unclaimed for the contexts which

00:14:03,130 --> 00:14:09,260
they are they are the foundation library

00:14:06,350 --> 00:14:11,810
is provided by Intel and I don't want to

00:14:09,260 --> 00:14:15,170
waste their efforts because they have

00:14:11,810 --> 00:14:20,600
plenty of experienced engineers working

00:14:15,170 --> 00:14:22,910
on that so if if I do if I work to some

00:14:20,600 --> 00:14:26,890
working on that I cannot guarantee that

00:14:22,910 --> 00:14:32,210
I can upgrade it according to the Intel

00:14:26,890 --> 00:14:35,270
engineers work so I plan to build

00:14:32,210 --> 00:14:40,400
everything on top of the Intel SGX

00:14:35,270 --> 00:14:43,610
accounts which libraries so here it

00:14:40,400 --> 00:14:47,000
comes another question in the past the

00:14:43,610 --> 00:14:49,790
application is a Intel application we

00:14:47,000 --> 00:14:53,210
never split it to two parts but now we

00:14:49,790 --> 00:14:55,820
have to split into two parts though the

00:14:53,210 --> 00:14:58,580
untrusted part and trusted parts where

00:14:55,820 --> 00:15:03,800
the trusted part components cannot make

00:14:58,580 --> 00:15:07,760
Cisco's and can only excute in a limited

00:15:03,800 --> 00:15:15,550
size of memory so this is a key question

00:15:07,760 --> 00:15:15,550
we we need partition yeah that myself so

00:15:15,610 --> 00:15:24,080
that's a key question and I whenever I

00:15:18,800 --> 00:15:27,440
talk partition the concept to developers

00:15:24,080 --> 00:15:29,360
in by do they they say that I don't want

00:15:27,440 --> 00:15:33,260
know these details

00:15:29,360 --> 00:15:34,850
these are burden to me so I don't know

00:15:33,260 --> 00:15:35,760
how to talk to them but I think you guys

00:15:34,850 --> 00:15:39,029
me understand

00:15:35,760 --> 00:15:42,899
I have to everyone who want to write an

00:15:39,029 --> 00:15:46,829
STX application he means what secret he

00:15:42,899 --> 00:15:50,250
wants to protect and what code should be

00:15:46,829 --> 00:15:53,940
guaranteed for his integrity that's a

00:15:50,250 --> 00:15:57,839
key question so let's assume that we

00:15:53,940 --> 00:16:00,660
have a correct partition for now so

00:15:57,839 --> 00:16:03,750
after the partition how do we assemble

00:16:00,660 --> 00:16:07,980
them together so it is easy to

00:16:03,750 --> 00:16:10,709
understand for the untrusted app we just

00:16:07,980 --> 00:16:12,540
build build it together with our as

00:16:10,709 --> 00:16:16,519
Jack's and trusted runtime service

00:16:12,540 --> 00:16:19,860
create and linked together with leap SGX

00:16:16,519 --> 00:16:23,970
underscore and untrusted runtime service

00:16:19,860 --> 00:16:26,910
dot a and some other stuffs for the

00:16:23,970 --> 00:16:30,029
trusted part it a is a static library

00:16:26,910 --> 00:16:32,850
because as Jax does not support dynamic

00:16:30,029 --> 00:16:40,649
loading so every everything is linked

00:16:32,850 --> 00:16:45,000
aesthetically we build our SDK as a set

00:16:40,649 --> 00:16:47,639
of static libraries and and developers

00:16:45,000 --> 00:16:51,060
read their own as jazz and claves and

00:16:47,639 --> 00:16:53,370
generated a Lib enclave dot a we link

00:16:51,060 --> 00:16:57,420
everything together as a shared object

00:16:53,370 --> 00:17:01,380
and use the as Jack's i2o by Intel and

00:16:57,420 --> 00:17:06,809
provide a signing key and finally create

00:17:01,380 --> 00:17:11,120
a sign ISO and in the very first

00:17:06,809 --> 00:17:15,089
beginning as I successfully support the

00:17:11,120 --> 00:17:20,569
interest Jax API by directly is wrapping

00:17:15,089 --> 00:17:25,459
the their api's with rest interface and

00:17:20,569 --> 00:17:28,260
here is a simple simple stack which

00:17:25,459 --> 00:17:32,460
depend finally depends on Intel's SDK

00:17:28,260 --> 00:17:35,580
yeah so here here is a key question is

00:17:32,460 --> 00:17:38,910
that on the on the top they are rust

00:17:35,580 --> 00:17:41,429
creates which can his memory safety but

00:17:38,910 --> 00:17:45,390
at the bottom the interested they do not

00:17:41,429 --> 00:17:48,690
they're written in c and c++ so how do

00:17:45,390 --> 00:17:54,239
we guarantee the memory safety of

00:17:48,690 --> 00:17:57,330
entire program the the answer is no we

00:17:54,239 --> 00:18:00,059
cannot get into 100 memory 60 but we

00:17:57,330 --> 00:18:04,080
propose the principles of hybrid memory

00:18:00,059 --> 00:18:10,349
safe architecture with three rules rules

00:18:04,080 --> 00:18:13,679
of thumbs first simply they are the

00:18:10,349 --> 00:18:15,539
basic idea is that the unsafe or memory

00:18:13,679 --> 00:18:20,340
and safe components should be small and

00:18:15,539 --> 00:18:23,869
should be a drop in of credible and it

00:18:20,340 --> 00:18:26,249
should has a clear boundary or between

00:18:23,869 --> 00:18:30,539
memory unsafe and the memory safe

00:18:26,249 --> 00:18:33,059
modules yes this is a principles

00:18:30,539 --> 00:18:35,369
proposed by my boss the chief security

00:18:33,059 --> 00:18:40,409
scientist and distinguished architecture

00:18:35,369 --> 00:18:42,869
of Baidu yeah and I believe to use

00:18:40,409 --> 00:18:46,409
memory safety guarantees in the

00:18:42,869 --> 00:18:49,019
production we the only thing we can do

00:18:46,409 --> 00:18:51,210
is that we guarantee this principle

00:18:49,019 --> 00:18:54,419
apply this principle to the existing

00:18:51,210 --> 00:18:56,340
products and replace the modules by

00:18:54,419 --> 00:18:59,220
memories if modules one by one and

00:18:56,340 --> 00:19:03,029
finally achieve best security guarantees

00:18:59,220 --> 00:19:11,460
so next finally we come to the print

00:19:03,029 --> 00:19:15,269
line sample so the steps is easy first I

00:19:11,460 --> 00:19:17,909
need the petition for the first step of

00:19:15,269 --> 00:19:20,340
addition and e2 defines the boundary it

00:19:17,909 --> 00:19:23,840
is defined using a edie arrow syntax

00:19:20,340 --> 00:19:25,190
defined by Intel very similar to C and

00:19:23,840 --> 00:19:29,129
[Music]

00:19:25,190 --> 00:19:32,669
the first lies are entrusted which says

00:19:29,129 --> 00:19:36,239
that is a Oh call function which it is

00:19:32,669 --> 00:19:39,119
enables a a code instead as GS and clave

00:19:36,239 --> 00:19:43,769
make outside call to the to the

00:19:39,119 --> 00:19:47,099
untrusted world right to the STD out and

00:19:43,769 --> 00:19:50,909
get back to the transit world and inside

00:19:47,099 --> 00:19:53,279
the trusted codes I can expand the macro

00:19:50,909 --> 00:19:56,580
actually I copied the coast from leave a

00:19:53,279 --> 00:19:59,330
sticky to as jxt STD and finally

00:19:56,580 --> 00:20:03,980
implement such a certain function

00:19:59,330 --> 00:20:07,629
and such a structure very almost the

00:20:03,980 --> 00:20:12,909
same as the lib STD and finally after

00:20:07,629 --> 00:20:16,580
across the boundary of trusted untrusted

00:20:12,909 --> 00:20:20,269
the in the untrusted world the the code

00:20:16,580 --> 00:20:23,059
way is very much simple yes so put

00:20:20,269 --> 00:20:26,110
everything together in inside the

00:20:23,059 --> 00:20:31,100
Enclave I implement the macro and

00:20:26,110 --> 00:20:35,840
defines the edge and finally implement

00:20:31,100 --> 00:20:39,859
the the OCO so the most challenging part

00:20:35,840 --> 00:20:45,489
is as TD is too much large and as takes

00:20:39,859 --> 00:20:45,489
us about half a year to for this create

00:20:45,639 --> 00:20:52,549
the challenge here I selected part of

00:20:49,009 --> 00:20:54,799
tournaments here for examples reading as

00:20:52,549 --> 00:20:57,679
you can see from the previous slide as

00:20:54,799 --> 00:21:01,399
Jax does not has a isolated shredding

00:20:57,679 --> 00:21:04,879
mechanism the Eco function is treated as

00:21:01,399 --> 00:21:07,190
something like blocked syscall and it

00:21:04,879 --> 00:21:10,190
does not have this training model it

00:21:07,190 --> 00:21:14,269
only has a setting policy we which

00:21:10,190 --> 00:21:18,580
decide on each eco whether or not you

00:21:14,269 --> 00:21:26,389
get the same in enclaves

00:21:18,580 --> 00:21:29,629
TCB so and another challenge is from the

00:21:26,389 --> 00:21:32,690
leaves each time in her sleep c is quite

00:21:29,629 --> 00:21:37,489
small because its support it doesn't

00:21:32,690 --> 00:21:42,340
support too much any cisco so it only

00:21:37,489 --> 00:21:43,909
has a very limited set of features and

00:21:42,340 --> 00:21:48,649
as Jack's

00:21:43,909 --> 00:21:50,960
mmm it supports a weird or or something

00:21:48,649 --> 00:21:56,169
like vectorized exception handling

00:21:50,960 --> 00:21:59,210
mechanism very different from rust so

00:21:56,169 --> 00:22:02,090
challenges are a lot they are these are

00:21:59,210 --> 00:22:05,059
only for I listed and I will use

00:22:02,090 --> 00:22:07,820
exception as an example to show how we

00:22:05,059 --> 00:22:11,510
port the latest CD to as Jess

00:22:07,820 --> 00:22:15,110
and so exception

00:22:11,510 --> 00:22:19,880
exceptionally as Jax is quite complex

00:22:15,110 --> 00:22:22,540
but it's very very similar to to the

00:22:19,880 --> 00:22:26,630
operating systems exception it will

00:22:22,540 --> 00:22:29,780
first use a trampoline to trap to aware

00:22:26,630 --> 00:22:32,780
to OS kernel and do with the host do

00:22:29,780 --> 00:22:37,280
visa such as page fold and get back to

00:22:32,780 --> 00:22:39,080
the Han clave one example is that in SGS

00:22:37,280 --> 00:22:42,560
and clave there is no CPUID instruction

00:22:39,080 --> 00:22:46,870
if we excuse such an instruction it will

00:22:42,560 --> 00:22:50,240
trap a fault and to the OS and if we

00:22:46,870 --> 00:22:53,720
register such a such a exception Handler

00:22:50,240 --> 00:22:59,680
and it will transfer the control control

00:22:53,720 --> 00:23:03,320
flow to our register Handler and do the

00:22:59,680 --> 00:23:05,720
handle handles the safety ID instruction

00:23:03,320 --> 00:23:09,770
and get back to the unclaimed a

00:23:05,720 --> 00:23:14,090
continuous execution so this is entirely

00:23:09,770 --> 00:23:17,690
different from rust exception so from

00:23:14,090 --> 00:23:20,840
the dry side the exception is is

00:23:17,690 --> 00:23:26,390
triggered from either panic or assertion

00:23:20,840 --> 00:23:29,330
and I just expand routines here in the

00:23:26,390 --> 00:23:31,640
board settings it can directly make

00:23:29,330 --> 00:23:35,030
cause to wrap our as Jack support

00:23:31,640 --> 00:23:39,110
function which aboard immediately and if

00:23:35,030 --> 00:23:43,460
we try to handle that panic we need a

00:23:39,110 --> 00:23:46,750
finally forced to the thread local macro

00:23:43,460 --> 00:23:50,480
which requires thread-local storage and

00:23:46,750 --> 00:23:54,290
that's that's the key part of the

00:23:50,480 --> 00:23:57,980
implementation we recommend this real

00:23:54,290 --> 00:24:01,580
local macro by copy codes from lobosdied

00:23:57,980 --> 00:24:05,120
e2 as GST STD lime function by function

00:24:01,580 --> 00:24:07,490
by function until the s.res local key

00:24:05,120 --> 00:24:11,630
inner function and from there we need to

00:24:07,490 --> 00:24:18,110
implement as Jack specification say yeah

00:24:11,630 --> 00:24:22,670
and I implemented several structures and

00:24:18,110 --> 00:24:24,930
their methods and finally it it invokes

00:24:22,670 --> 00:24:29,340
make an FF I cause

00:24:24,930 --> 00:24:33,090
to the SGS Intel SGX EP is and get a

00:24:29,340 --> 00:24:37,020
syrette data and it returns saturated

00:24:33,090 --> 00:24:41,040
structure and within with two areas

00:24:37,020 --> 00:24:43,490
indicate the TRS area and in this way we

00:24:41,040 --> 00:24:49,080
support through our local storage and

00:24:43,490 --> 00:24:54,900
and uh finally the the entire routine

00:24:49,080 --> 00:24:58,530
works so another example is as Jax mutex

00:24:54,900 --> 00:25:00,710
mmm Linux the mutex important

00:24:58,530 --> 00:25:05,010
implementation will finally fall to

00:25:00,710 --> 00:25:09,510
leave sees piece ran new text but as Jax

00:25:05,010 --> 00:25:14,010
we don't have pizza so Intel provides an

00:25:09,510 --> 00:25:17,880
alternative solution in named as as Jax

00:25:14,010 --> 00:25:22,550
read mutex so I implement the

00:25:17,880 --> 00:25:26,730
re-implement the mutex dot RS and which

00:25:22,550 --> 00:25:29,660
caused to the as Jax thread mutex in

00:25:26,730 --> 00:25:36,680
needs we finally make FF I caused to

00:25:29,660 --> 00:25:40,680
inherit ap is in this way we implement

00:25:36,680 --> 00:25:44,910
mutex as as Jack's mutex the reason why

00:25:40,680 --> 00:25:47,790
I didn't directly name as new tags is

00:25:44,910 --> 00:25:50,850
that I want programmers to know that

00:25:47,790 --> 00:25:56,250
they are using Intel's mutex instead of

00:25:50,850 --> 00:25:59,010
common piece revenue tax so that's

00:25:56,250 --> 00:26:01,770
that's how the liebe city works so next

00:25:59,010 --> 00:26:05,510
I would tell you guys how to pour

00:26:01,770 --> 00:26:09,300
existing projects to Russ SGX and

00:26:05,510 --> 00:26:12,440
protect your data and privacy but before

00:26:09,300 --> 00:26:15,300
that I want to I want you guys to know

00:26:12,440 --> 00:26:19,380
before port anything we need to

00:26:15,300 --> 00:26:23,700
partition it for example when a petition

00:26:19,380 --> 00:26:26,820
port the Russell I have to partition the

00:26:23,700 --> 00:26:30,540
Russell framework put our synchronized I

00:26:26,820 --> 00:26:34,470
all out of the of into the untrusted

00:26:30,540 --> 00:26:37,760
world and put everything synchronized in

00:26:34,470 --> 00:26:41,360
the trusted world and

00:26:37,760 --> 00:26:46,660
yeah every everybody should do the

00:26:41,360 --> 00:26:51,740
petition before he starts coding

00:26:46,660 --> 00:26:58,070
after he petitioned the application the

00:26:51,740 --> 00:27:01,370
first thing is to import the STD I for

00:26:58,070 --> 00:27:04,250
now we support either the post the cargo

00:27:01,370 --> 00:27:07,250
settings and the XR go I don't know how

00:27:04,250 --> 00:27:11,510
to pronounce in Chinese we call it choco

00:27:07,250 --> 00:27:15,560
because I extends for char so but now

00:27:11,510 --> 00:27:18,800
whatever so in cargo settings it is a no

00:27:15,560 --> 00:27:22,190
STD environment the creator is named as

00:27:18,800 --> 00:27:25,070
jxt STD and what you need to do is to

00:27:22,190 --> 00:27:29,300
exterminate as as yet

00:27:25,070 --> 00:27:33,110
gsdd as STD and add another prelude

00:27:29,300 --> 00:27:39,680
include add the header and it supports

00:27:33,110 --> 00:27:42,700
rust able and rust nightly but in XR go

00:27:39,680 --> 00:27:47,120
it's say the environment does include

00:27:42,700 --> 00:27:49,820
STD so the create is different with his

00:27:47,120 --> 00:27:52,940
name as TD and verse number zero point

00:27:49,820 --> 00:27:55,970
zero point zero and is and it it has a

00:27:52,940 --> 00:27:59,000
customized this route and it's support

00:27:55,970 --> 00:28:04,190
nightly only because i XR go only

00:27:59,000 --> 00:28:09,230
support nightly but we want the act and

00:28:04,190 --> 00:28:12,620
leave be stable so we hacked that x XR

00:28:09,230 --> 00:28:19,790
go and shipped with a customized XR go

00:28:12,620 --> 00:28:23,080
with our code project and forest reacts

00:28:19,790 --> 00:28:26,240
features in Russ SGX we support both the

00:28:23,080 --> 00:28:29,030
Linux side for example the Linux file

00:28:26,240 --> 00:28:31,730
system access we support them and Intel

00:28:29,030 --> 00:28:34,430
provides another called as Jack's file

00:28:31,730 --> 00:28:37,460
system that's a encrypted file system

00:28:34,430 --> 00:28:40,490
and we support and post before you

00:28:37,460 --> 00:28:42,950
decide to use

00:28:40,490 --> 00:28:46,190
file system you have to choose between

00:28:42,950 --> 00:28:46,760
the Linux file system and the STX file

00:28:46,190 --> 00:28:51,290
system

00:28:46,760 --> 00:28:53,360
this happens to time which Linux time or

00:28:51,290 --> 00:28:56,600
the as Jack's time as UX time is

00:28:53,360 --> 00:29:02,570
guaranteed to be true from India me

00:28:56,600 --> 00:29:07,610
mechanism and here I listed some of the

00:29:02,570 --> 00:29:11,120
masterpieces of rasa SGS first at least

00:29:07,610 --> 00:29:16,820
the create sported by myself

00:29:11,120 --> 00:29:18,620
for example the rusty machine because as

00:29:16,820 --> 00:29:21,350
the early stage of this year or last

00:29:18,620 --> 00:29:25,850
year people are talking about a I and I

00:29:21,350 --> 00:29:28,130
poured part of I select one famous

00:29:25,850 --> 00:29:33,130
Marshall learning library cause rusty

00:29:28,130 --> 00:29:33,130
machine it has a clean dependency with

00:29:34,240 --> 00:29:43,370
linear algebra are create I can I can

00:29:39,650 --> 00:29:47,120
port and that makes a sect made made

00:29:43,370 --> 00:29:51,260
success and the second I poured the

00:29:47,120 --> 00:29:55,990
Russell set to as Jax and provides a

00:29:51,260 --> 00:30:00,320
course imposed to show how to create a

00:29:55,990 --> 00:30:04,550
here as server and client in as Jack's

00:30:00,320 --> 00:30:08,270
and uses Jack's protect the TOS context

00:30:04,550 --> 00:30:12,440
and then someone write email to me say

00:30:08,270 --> 00:30:15,140
that I need program ok and I pour the

00:30:12,440 --> 00:30:19,970
product to as Jack's so photograph I

00:30:15,140 --> 00:30:22,610
related to some partitions because part

00:30:19,970 --> 00:30:24,950
of the protobuf should be implemented in

00:30:22,610 --> 00:30:27,440
the untrusted world and a part of the

00:30:24,950 --> 00:30:33,290
probe should be work in the trusted

00:30:27,440 --> 00:30:36,710
world and and 4:30 is the it's one of my

00:30:33,290 --> 00:30:39,410
favorite create and personally I

00:30:36,710 --> 00:30:43,490
wouldn't use Russ proto before

00:30:39,410 --> 00:30:45,830
civilization I would use 30 and finally

00:30:43,490 --> 00:30:48,880
last week I made the web assembly

00:30:45,830 --> 00:30:52,250
interpreter worked perfectly in STS and

00:30:48,880 --> 00:30:53,710
that's what I believe will be success in

00:30:52,250 --> 00:30:58,149
near future

00:30:53,710 --> 00:31:02,440
and some winning stories in last year I

00:30:58,149 --> 00:31:07,630
I participate in the I - competition

00:31:02,440 --> 00:31:12,240
hosted in US and the CEA from France won

00:31:07,630 --> 00:31:14,679
the trophy in a - 17 and the

00:31:12,240 --> 00:31:18,279
successfully compressed the search

00:31:14,679 --> 00:31:22,750
gigabytes of genome data to hundreds of

00:31:18,279 --> 00:31:26,380
me megabeth and transfer it to the

00:31:22,750 --> 00:31:29,740
authorized enclave lock-free a hashmap

00:31:26,380 --> 00:31:33,070
and finally the size of the hash math is

00:31:29,740 --> 00:31:35,860
only seven gigabytes even less than the

00:31:33,070 --> 00:31:39,250
l3 cache of the processor and the

00:31:35,860 --> 00:31:43,570
process they process this 30 gigabytes

00:31:39,250 --> 00:31:46,330
of data within seconds I remember it

00:31:43,570 --> 00:31:49,149
seven seconds so they won't the trophy

00:31:46,330 --> 00:31:52,419
and they build their application on the

00:31:49,149 --> 00:31:56,080
Rath SGX framework and that this is the

00:31:52,419 --> 00:31:59,200
first winning story of Russa SGX they

00:31:56,080 --> 00:32:04,330
beat a set of a bunch of teams using C

00:31:59,200 --> 00:32:09,570
and C++ and another winning story is

00:32:04,330 --> 00:32:15,460
from my previous lab at UC Berkeley and

00:32:09,570 --> 00:32:18,730
they poured a entire reserve mbm called

00:32:15,460 --> 00:32:22,480
Sputnik the EVM to the SGS Enclave and

00:32:18,730 --> 00:32:24,880
write a smart contract protocol the

00:32:22,480 --> 00:32:27,370
consent some consensus mechanisms they

00:32:24,880 --> 00:32:30,490
implement they implement correctly and

00:32:27,370 --> 00:32:36,370
make the smart contract system work

00:32:30,490 --> 00:32:37,000
perfectly honest react Russ SES and at

00:32:36,370 --> 00:32:41,830
last

00:32:37,000 --> 00:32:45,100
I last week I finally make it work make

00:32:41,830 --> 00:32:50,669
the web assembly interpreter works in

00:32:45,100 --> 00:32:55,570
ICS and clave which means that I can put

00:32:50,669 --> 00:32:59,620
W as T web assembly to the highest rank

00:32:55,570 --> 00:33:02,110
lave and and send some execution

00:32:59,620 --> 00:33:06,220
requests to the web assembly interpreter

00:33:02,110 --> 00:33:07,360
and it can calculate the evaluates the

00:33:06,220 --> 00:33:09,960
results and return

00:33:07,360 --> 00:33:14,290
to return to Elantra a word or either

00:33:09,960 --> 00:33:21,549
Sande to remote using secure layer

00:33:14,290 --> 00:33:24,670
transportation and it will be a winning

00:33:21,549 --> 00:33:31,440
story because as Jax in the past can is

00:33:24,670 --> 00:33:35,350
designed to build a customized set of

00:33:31,440 --> 00:33:37,360
trust computing base but with the help

00:33:35,350 --> 00:33:40,780
of webassembly interpreter it can

00:33:37,360 --> 00:33:44,590
execute every popular language because

00:33:40,780 --> 00:33:49,150
every popular compiler can generate web

00:33:44,590 --> 00:33:51,630
assembly as a target platform so we can

00:33:49,150 --> 00:33:56,200
run everything in as your exam safe now

00:33:51,630 --> 00:33:58,750
so here's the summary and I have some

00:33:56,200 --> 00:34:01,570
problems love you hon first is cargo

00:33:58,750 --> 00:34:04,210
test as Jax has a different system

00:34:01,570 --> 00:34:08,369
settings so it does not support a couple

00:34:04,210 --> 00:34:12,609
tests and for char go it can now support

00:34:08,369 --> 00:34:14,800
Russ stable and for AI guys they need a

00:34:12,609 --> 00:34:18,250
high performance blast create but we

00:34:14,800 --> 00:34:23,379
don't have one and yeah I need to better

00:34:18,250 --> 00:34:26,970
manage my versioning crystal io so thank

00:34:23,379 --> 00:34:26,970
you that's all my talk

00:34:28,429 --> 00:34:36,489

YouTube URL: https://www.youtube.com/watch?v=8IvWPeavjiQ


