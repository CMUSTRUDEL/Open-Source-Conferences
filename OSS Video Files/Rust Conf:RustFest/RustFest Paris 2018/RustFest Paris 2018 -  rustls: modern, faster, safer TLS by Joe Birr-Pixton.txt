Title: RustFest Paris 2018 -  rustls: modern, faster, safer TLS by Joe Birr-Pixton
Publication date: 2018-05-26
Playlist: RustFest Paris 2018
Description: 
	If crypto stuff you want to know
just listen to this guy called Joe
who knows Rustls
for securing access
so let's look at what he's gonna show

rustls is an open-source Transport Level Security (TLS) stack written in safe Rust. This talk reviews the current state of TLS support in the Rust ecosystem, and the design choices taken in rustls.

(Limerick by @llogiq)

https://paris.rustfest.eu/sessions/rustls-modern-faster-safer-tls
Captions: 
	00:00:05,080 --> 00:00:12,110
so if crypto stuff you want to know just

00:00:09,380 --> 00:00:16,369
listen to this guy called Joel he knows

00:00:12,110 --> 00:00:38,480
rust TLS for securing access so let's

00:00:16,369 --> 00:00:43,160
look at what he's gonna show right the

00:00:38,480 --> 00:00:46,040
first part is like what what is all for

00:00:43,160 --> 00:00:50,480
the second part is I want to write the

00:00:46,040 --> 00:00:53,750
thing in rust what what crates are

00:00:50,480 --> 00:00:56,690
available to me to to do TLS and then

00:00:53,750 --> 00:00:58,670
the third part is like my thing which is

00:00:56,690 --> 00:01:10,130
called Russell's or rusty or less if you

00:00:58,670 --> 00:01:12,229
like yeah so TLS first of all is

00:01:10,130 --> 00:01:14,390
transport layer security it's not a

00:01:12,229 --> 00:01:20,720
thread local storage if you're here for

00:01:14,390 --> 00:01:23,299
third local storage talk I'm sorry but

00:01:20,720 --> 00:01:26,479
but it's also known as SSL and an in

00:01:23,299 --> 00:01:31,640
common usage SSL is actually more more

00:01:26,479 --> 00:01:33,979
common it's like the s in HTTP it's your

00:01:31,640 --> 00:01:36,950
it's your padlock in your browser which

00:01:33,979 --> 00:01:40,369
is very very common it's like more XP s

00:01:36,950 --> 00:01:41,330
now is more common than HTTP which is

00:01:40,369 --> 00:01:46,119
awesome

00:01:41,330 --> 00:01:49,220
very good indeed very happy with that so

00:01:46,119 --> 00:01:51,009
we can talk about goals what was what's

00:01:49,220 --> 00:01:54,409
the point of this thing in really high

00:01:51,009 --> 00:01:57,950
level terms not very low level technical

00:01:54,409 --> 00:02:00,259
detail a bit about history and then a

00:01:57,950 --> 00:02:03,470
bit about kind of the security history

00:02:00,259 --> 00:02:05,840
because it has a long and kind of

00:02:03,470 --> 00:02:11,239
checkered history when it comes to

00:02:05,840 --> 00:02:13,069
actually achieving those goals so we've

00:02:11,239 --> 00:02:14,900
got our cast of characters here these

00:02:13,069 --> 00:02:16,640
are normal like

00:02:14,900 --> 00:02:18,319
we used characters we've got Alice on

00:02:16,640 --> 00:02:20,989
the left who wants to talk to Bob the

00:02:18,319 --> 00:02:24,110
clown on the right and then we've got

00:02:20,989 --> 00:02:26,900
Eve in the middle who's in this case

00:02:24,110 --> 00:02:31,599
he's an eavesdropper who's just watching

00:02:26,900 --> 00:02:34,790
traffic going back and forth Alice and

00:02:31,599 --> 00:02:36,700
Bob are really concerned that they don't

00:02:34,790 --> 00:02:39,860
want Eve to be able to learn much about

00:02:36,700 --> 00:02:42,650
traffic communications that's one thing

00:02:39,860 --> 00:02:47,560
that clear les aims to do the next is

00:02:42,650 --> 00:02:51,109
like authenticity Alex wants to know

00:02:47,560 --> 00:02:54,079
that she's actually talking to Bob and

00:02:51,109 --> 00:02:55,640
not Mallory in the center who

00:02:54,079 --> 00:03:00,760
suspiciously looks like a lot like Eve

00:02:55,640 --> 00:03:00,760
in that case maybe she's the same person

00:03:01,329 --> 00:03:08,629
Els also as a kind of secondary but not

00:03:05,030 --> 00:03:10,940
commonly used option allows Bob to

00:03:08,629 --> 00:03:14,799
authenticate Alice as well not not very

00:03:10,940 --> 00:03:19,760
common news but used in enterprise

00:03:14,799 --> 00:03:24,099
settings but not only and the last one

00:03:19,760 --> 00:03:27,739
which is kind related to authenticity is

00:03:24,099 --> 00:03:29,599
like integrity so not just integrity in

00:03:27,739 --> 00:03:32,769
terms of bits and bytes going over the

00:03:29,599 --> 00:03:35,060
wire but integrity of the whole

00:03:32,769 --> 00:03:37,190
communication so that includes things

00:03:35,060 --> 00:03:40,579
like we play so if I send a message

00:03:37,190 --> 00:03:42,260
saying deposit a thousand euros into

00:03:40,579 --> 00:03:44,120
this account someone shouldn't be able

00:03:42,260 --> 00:03:45,980
to take that message and send it to the

00:03:44,120 --> 00:03:48,260
server a second time and have the server

00:03:45,980 --> 00:03:57,379
accept it that would be obviously a bad

00:03:48,260 --> 00:03:59,780
thing so yes there's also a kind of

00:03:57,379 --> 00:04:02,540
belated thing which doesn't really work

00:03:59,780 --> 00:04:05,989
in practice which is like truncation

00:04:02,540 --> 00:04:08,299
resistance which is kind of like similar

00:04:05,989 --> 00:04:11,120
to the reef a problem but at the end of

00:04:08,299 --> 00:04:12,410
the communication and the reason that

00:04:11,120 --> 00:04:14,799
doesn't work is because in general

00:04:12,410 --> 00:04:21,139
people are people aren't willing to

00:04:14,799 --> 00:04:23,450
treat TCP closures of the TLS channel as

00:04:21,139 --> 00:04:25,130
a security problem it's just like earth

00:04:23,450 --> 00:04:25,700
the connection went away I don't know

00:04:25,130 --> 00:04:28,730
whether that

00:04:25,700 --> 00:04:30,770
you know because it's the internet or

00:04:28,730 --> 00:04:32,960
because there's someone trying to attack

00:04:30,770 --> 00:04:36,440
me so watch out for that if you were

00:04:32,960 --> 00:04:39,590
ever designing a protocol like you know

00:04:36,440 --> 00:04:41,210
you imagine a database a transactional

00:04:39,590 --> 00:04:43,190
database thing where your first message

00:04:41,210 --> 00:04:46,340
is start a transaction your last message

00:04:43,190 --> 00:04:48,530
is commit the transaction so if an

00:04:46,340 --> 00:04:54,590
attacker can chop off the c'mere that's

00:04:48,530 --> 00:04:58,940
can be quite disastrous so this is a bit

00:04:54,590 --> 00:05:01,670
of history so one ignore where so long

00:04:58,940 --> 00:05:04,310
it didn't exist basically the first time

00:05:01,670 --> 00:05:07,330
it was ever presented to anyone someone

00:05:04,310 --> 00:05:07,330
the audience broke it

00:05:08,290 --> 00:05:13,700
SSL - also quite bad as self three was

00:05:11,840 --> 00:05:17,810
the first one which was actually

00:05:13,700 --> 00:05:19,520
designed by like cryptographer and that

00:05:17,810 --> 00:05:24,430
worked really well but they they only

00:05:19,520 --> 00:05:27,740
gave the chap two weeks to do it so yeah

00:05:24,430 --> 00:05:29,660
and then it kind of changed name but you

00:05:27,740 --> 00:05:32,720
shouldn't think that s self three until

00:05:29,660 --> 00:05:35,990
s1 are really that different they're

00:05:32,720 --> 00:05:38,030
really really close protocol wise and

00:05:35,990 --> 00:05:41,810
that was because it transfers from

00:05:38,030 --> 00:05:44,870
Netscape to wait yes but yeah you can

00:05:41,810 --> 00:05:49,180
really think of SSL three - TLS 1.2 as

00:05:44,870 --> 00:05:52,850
being really the same family of protocol

00:05:49,180 --> 00:05:56,060
1.3 is dramatically dramatically but

00:05:52,850 --> 00:06:00,470
very very very different way way more

00:05:56,060 --> 00:06:06,410
different than you know 1.1 to 1.2 there

00:06:00,470 --> 00:06:10,970
was quite a disagreement in the TLS

00:06:06,410 --> 00:06:12,680
working group about whether tearless 1.3

00:06:10,970 --> 00:06:16,010
was the right name for it whether it

00:06:12,680 --> 00:06:18,350
should be to you later 2.0 1.3 kind of

00:06:16,010 --> 00:06:19,970
one out because it had already been used

00:06:18,350 --> 00:06:22,190
and talked about and there was lots of

00:06:19,970 --> 00:06:23,750
security papers like security result

00:06:22,190 --> 00:06:26,330
saying yes we prove this is you're

00:06:23,750 --> 00:06:29,140
talking about here that's 1.3 they want

00:06:26,330 --> 00:06:29,140
to avoid that

00:06:29,599 --> 00:06:34,699
this is how its deployed so the

00:06:32,689 --> 00:06:36,889
important thing to know is like well

00:06:34,699 --> 00:06:38,240
these percentages don't add up and the

00:06:36,889 --> 00:06:42,349
reason they don't add up is because a

00:06:38,240 --> 00:06:45,110
given server can support more mana at a

00:06:42,349 --> 00:06:47,240
time so really you should interpret this

00:06:45,110 --> 00:06:52,309
is like if I go to any of these servers

00:06:47,240 --> 00:06:54,889
in this data set the probability of them

00:06:52,309 --> 00:06:58,069
supporting TLS 1.2 for a given random

00:06:54,889 --> 00:07:01,279
server there is like 90 of them and the

00:06:58,069 --> 00:07:04,219
direction is nice the one we think is

00:07:01,279 --> 00:07:08,860
good is going up for the ones before I

00:07:04,219 --> 00:07:12,559
kind of going down some like slowly and

00:07:08,860 --> 00:07:15,800
this is like the security status like

00:07:12,559 --> 00:07:17,689
how much you could distill the security

00:07:15,800 --> 00:07:23,779
status of these complicated protocols

00:07:17,689 --> 00:07:29,719
into one slide right so 1.0 and 1.1 are

00:07:23,779 --> 00:07:33,229
quite very close 1.2 has some good

00:07:29,719 --> 00:07:37,399
options but also inherits most of the

00:07:33,229 --> 00:07:39,649
stuff from before so you have to kind of

00:07:37,399 --> 00:07:43,939
pay attention to it that your parameter

00:07:39,649 --> 00:07:45,860
choices until this one point TLS 1.3 is

00:07:43,939 --> 00:07:50,300
very new it's not even standardized it

00:07:45,860 --> 00:07:53,930
will be in like a matter of weeks but it

00:07:50,300 --> 00:07:58,519
throws away all the old stuff which is

00:07:53,930 --> 00:08:00,589
nice so umm I want to spend a little bit

00:07:58,519 --> 00:08:06,069
of time on this slide and talking about

00:08:00,589 --> 00:08:09,649
these countermeasures so these are all

00:08:06,069 --> 00:08:14,029
implementation strategies for dealing

00:08:09,649 --> 00:08:18,289
with kind of design faults really but

00:08:14,029 --> 00:08:22,699
came in around 1996 and haven't been

00:08:18,289 --> 00:08:24,469
removed as I said until like today and

00:08:22,699 --> 00:08:26,839
people will go well why don't you just

00:08:24,469 --> 00:08:27,849
implement the countermeasures it'll be

00:08:26,839 --> 00:08:30,019
fine

00:08:27,849 --> 00:08:33,560
there's some problems with that one is

00:08:30,019 --> 00:08:36,030
that the aims of the countermeasures and

00:08:33,560 --> 00:08:39,510
how to do them isn't documented anywhere

00:08:36,030 --> 00:08:42,450
for example the ITF doesn't publish or

00:08:39,510 --> 00:08:44,130
hasn't published any implementation

00:08:42,450 --> 00:08:46,680
guidance saying this is what we're

00:08:44,130 --> 00:08:51,000
trying to do and this is how you might

00:08:46,680 --> 00:08:55,850
do it and as a result they're quite

00:08:51,000 --> 00:08:55,850
under tested and difficult to

00:08:56,420 --> 00:09:05,070
unconvincing they're also sometimes

00:09:01,980 --> 00:09:07,800
quite uncommon for example them go

00:09:05,070 --> 00:09:09,200
Lang's TLS library which is really

00:09:07,800 --> 00:09:11,250
really good

00:09:09,200 --> 00:09:13,920
started off its life without any of

00:09:11,250 --> 00:09:17,540
these countermeasures and even now has

00:09:13,920 --> 00:09:19,890
fewer countermeasures in the same like

00:09:17,540 --> 00:09:22,260
countermeasures for the same bug then

00:09:19,890 --> 00:09:24,570
I've necessarly so you're kind of

00:09:22,260 --> 00:09:26,730
reduced to thinking like just worrying

00:09:24,570 --> 00:09:27,300
about this like do I need all these

00:09:26,730 --> 00:09:32,790
things

00:09:27,300 --> 00:09:38,310
do I not the other thing which is

00:09:32,790 --> 00:09:39,720
slightly more serious is in 2013 Agnes

00:09:38,310 --> 00:09:44,310
Cell implemented one of these

00:09:39,720 --> 00:09:48,000
countermeasures and it had a bug in here

00:09:44,310 --> 00:09:51,390
and that bug stayed there until 2016 and

00:09:48,000 --> 00:09:53,490
the bug was worse than the bug that they

00:09:51,390 --> 00:09:57,860
were writing the countermeasure for so

00:09:53,490 --> 00:09:57,860
this wasn't this wasn't a triumph really

00:09:57,920 --> 00:10:05,370
so let's not I mean we don't have to so

00:10:03,480 --> 00:10:11,370
that's not and if we did have to do then

00:10:05,370 --> 00:10:14,510
that would be so there's also this like

00:10:11,370 --> 00:10:19,440
modern TLS terminology I use in the

00:10:14,510 --> 00:10:22,200
title of this this talk and I'm not just

00:10:19,440 --> 00:10:25,560
making stuff up it's like I'm quite

00:10:22,200 --> 00:10:28,260
commonly talked about I think Zillow

00:10:25,560 --> 00:10:31,050
really bought in this is from their wiki

00:10:28,260 --> 00:10:33,600
page about configuring servers to have

00:10:31,050 --> 00:10:35,180
good TLS cloud fare has it has it as an

00:10:33,600 --> 00:10:37,320
option

00:10:35,180 --> 00:10:42,110
Apple has a similar thing but called it

00:10:37,320 --> 00:10:47,970
different name yeah

00:10:42,110 --> 00:10:51,690
so let's talk about a trust of it this

00:10:47,970 --> 00:10:54,930
is like the diagrams I'm going to use

00:10:51,690 --> 00:10:56,970
orange boxes are crate gray box isn't

00:10:54,930 --> 00:11:01,760
not a crate is like another library

00:10:56,970 --> 00:11:04,920
white arrow is a useful rust API and

00:11:01,760 --> 00:11:07,140
yeah so we've got open cell s challenge

00:11:04,920 --> 00:11:09,630
guilty framework and SS bindings I'm

00:11:07,140 --> 00:11:12,780
missing out of these - this crazier

00:11:09,630 --> 00:11:16,170
because they're kind of just consider

00:11:12,780 --> 00:11:17,610
them they're part of that line right and

00:11:16,170 --> 00:11:19,860
then we've got some implementations

00:11:17,610 --> 00:11:25,950
there's my one there's another one which

00:11:19,860 --> 00:11:28,800
is a B TLS which is very interesting

00:11:25,950 --> 00:11:31,350
it's like an all-in-one thing like more

00:11:28,800 --> 00:11:37,050
to the scope of open cell and it's very

00:11:31,350 --> 00:11:41,730
interesting it's not on waste it is

00:11:37,050 --> 00:11:43,830
written mostly in rust and then we've

00:11:41,730 --> 00:11:46,260
got some abstractions like so native TLS

00:11:43,830 --> 00:11:48,830
is really really common very widely used

00:11:46,260 --> 00:11:56,160
probably the most widely used way of

00:11:48,830 --> 00:12:00,720
doing TLS in rust right now and yeah so

00:11:56,160 --> 00:12:02,610
it's basically we have these these

00:12:00,720 --> 00:12:04,110
bindings let's choose one based on

00:12:02,610 --> 00:12:06,330
what's the most convenient for the

00:12:04,110 --> 00:12:09,720
platform I'm running on and that really

00:12:06,330 --> 00:12:13,650
works very well and it's whoops it's

00:12:09,720 --> 00:12:17,340
very low friction so if that's what you

00:12:13,650 --> 00:12:19,920
want this is a good choice there's also

00:12:17,340 --> 00:12:22,770
this moment I really do like

00:12:19,920 --> 00:12:25,890
so there's TLS API which is just like a

00:12:22,770 --> 00:12:29,690
collection of traits and then these

00:12:25,890 --> 00:12:31,950
intermediate ones TLS API open-cell etc

00:12:29,690 --> 00:12:33,540
which provide implementations of those

00:12:31,950 --> 00:12:35,940
crates so if you're writing a library

00:12:33,540 --> 00:12:39,990
and you're not quite sure what TLS

00:12:35,940 --> 00:12:42,930
library you're kind of application level

00:12:39,990 --> 00:12:46,590
consumer wants to to use you can just

00:12:42,930 --> 00:12:50,670
and make your library generic on those

00:12:46,590 --> 00:12:53,730
traits and then your application at the

00:12:50,670 --> 00:12:58,389
top just passes in one of these choices

00:12:53,730 --> 00:13:02,019
and that that works really well it did

00:12:58,389 --> 00:13:05,320
come after native TLS though and if you

00:13:02,019 --> 00:13:08,019
kind of in your mind pick out a native

00:13:05,320 --> 00:13:12,120
CLS it's kind of doing the same job

00:13:08,019 --> 00:13:14,949
twice one is providing a generic

00:13:12,120 --> 00:13:16,570
abstraction over TLS and then native TLS

00:13:14,949 --> 00:13:20,800
is doing the same thing but a different

00:13:16,570 --> 00:13:22,240
level and so that would be good to fix

00:13:20,800 --> 00:13:24,519
although I'm not sure it's really worth

00:13:22,240 --> 00:13:34,440
fixing at this point because um there's

00:13:24,519 --> 00:13:37,570
a lot of users and then Tokyo right so

00:13:34,440 --> 00:13:40,870
it's a whole nother level of oh my god

00:13:37,570 --> 00:13:42,490
what's happening and that they get

00:13:40,870 --> 00:13:45,970
there's another similar set of things

00:13:42,490 --> 00:13:47,769
which blew Tokyo to TLS like gluing it

00:13:45,970 --> 00:13:50,470
to straight to open the cell mates of

00:13:47,769 --> 00:13:53,199
TLS gluing it to the whole like subgraph

00:13:50,470 --> 00:13:56,860
of TLS API implementations and that's

00:13:53,199 --> 00:14:00,730
really interesting and then gluing it to

00:13:56,860 --> 00:14:04,660
Brussels as well as you want so speaking

00:14:00,730 --> 00:14:08,410
of which so I made a logo on Monday and

00:14:04,660 --> 00:14:12,940
I made stickers I'm a graphic designer

00:14:08,410 --> 00:14:18,040
probably tell but yeah so this project

00:14:12,940 --> 00:14:21,250
is an implementation of of 1.2 and 1.3

00:14:18,040 --> 00:14:25,540
and when I say 1.2 just the good bits

00:14:21,250 --> 00:14:28,690
right and in general just the good bits

00:14:25,540 --> 00:14:33,370
not it's not comprehensive

00:14:28,690 --> 00:14:37,209
like I've necessaries so I've got quite

00:14:33,370 --> 00:14:39,699
a background in kind of security

00:14:37,209 --> 00:14:41,110
oriented software development and I've

00:14:39,699 --> 00:14:43,690
written a couple of TLS libraries

00:14:41,110 --> 00:14:46,680
proprietary ones in the past so I've

00:14:43,690 --> 00:14:52,510
been studying this this kind of area for

00:14:46,680 --> 00:14:56,310
well really most of my career so yeah

00:14:52,510 --> 00:14:59,380
that's that's this is like the whole um

00:14:56,310 --> 00:15:01,180
the aims of project this kind of came

00:14:59,380 --> 00:15:04,630
after I started started writing it so

00:15:01,180 --> 00:15:06,700
it's a bit post hoc

00:15:04,630 --> 00:15:10,690
but the reading of the point is only

00:15:06,700 --> 00:15:13,990
good stuff try and talk to about 95% of

00:15:10,690 --> 00:15:15,910
other things as you can see from the

00:15:13,990 --> 00:15:17,950
earlier things almost there

00:15:15,910 --> 00:15:20,350
not quite and I'm kind of like aiming

00:15:17,950 --> 00:15:24,250
where things are going rather than where

00:15:20,350 --> 00:15:28,330
they are no unsafe for us so there's no

00:15:24,250 --> 00:15:30,400
unsafe blocks in in this grade it does

00:15:28,330 --> 00:15:32,560
depend on others which obviously have

00:15:30,400 --> 00:15:36,790
unsafe behavior well no unsafe behavior

00:15:32,560 --> 00:15:41,080
but unsafe blocks let's say and trying

00:15:36,790 --> 00:15:43,150
to present a really simple API which

00:15:41,080 --> 00:15:45,370
kind of just looks like a pipe right so

00:15:43,150 --> 00:15:48,640
you you put your bytes in here maybe

00:15:45,370 --> 00:15:50,500
it's a HTTP request you get TLS out and

00:15:48,640 --> 00:15:52,090
likewise from the other end you put to

00:15:50,500 --> 00:15:59,170
your lesson and you get your how to be

00:15:52,090 --> 00:16:01,090
response back so yeah and it's it's

00:15:59,170 --> 00:16:03,970
almost two years old now like tomorrow

00:16:01,090 --> 00:16:05,170
it will be like properly two years old

00:16:03,970 --> 00:16:08,550
because the first mate doesn't really

00:16:05,170 --> 00:16:12,370
care it's a big load of non-working code

00:16:08,550 --> 00:16:19,690
and yeah I'm very pleased

00:16:12,370 --> 00:16:27,280
there's good and testing right so

00:16:19,690 --> 00:16:28,750
testing very important I'm not gonna in

00:16:27,280 --> 00:16:32,910
the coffee break I will happily tell you

00:16:28,750 --> 00:16:34,960
a anecdote about my interaction with

00:16:32,910 --> 00:16:37,390
reporting a moderate level security

00:16:34,960 --> 00:16:40,420
vulnerability to open SSL and the

00:16:37,390 --> 00:16:42,400
testing that happened around that but

00:16:40,420 --> 00:16:45,520
not here so we've got quite a lot of

00:16:42,400 --> 00:16:49,840
tests and 97% line coverage and that's

00:16:45,520 --> 00:16:55,950
of like 68 sorry 68 hundred lines of of

00:16:49,840 --> 00:17:01,870
off code in comparison open SSL's

00:16:55,950 --> 00:17:05,020
automated testing is about 65% but that

00:17:01,870 --> 00:17:06,819
is like the equivalent of 40,000 lines

00:17:05,020 --> 00:17:09,270
of uncovered code that they ship in

00:17:06,819 --> 00:17:09,270
every release

00:17:10,839 --> 00:17:19,100
so let's talk a little bit about

00:17:13,309 --> 00:17:22,240
performance I'm gonna there there's

00:17:19,100 --> 00:17:25,130
there's blog posts which are kind of

00:17:22,240 --> 00:17:26,360
expand on this section so if you really

00:17:25,130 --> 00:17:30,950
want to look at the details where we

00:17:26,360 --> 00:17:33,380
produce the results then go there but

00:17:30,950 --> 00:17:37,520
just to say that that a TLS connection

00:17:33,380 --> 00:17:39,590
kind of starts with a handshake which

00:17:37,520 --> 00:17:41,660
involves lots of public key crypto which

00:17:39,590 --> 00:17:45,350
is quite expensive and then it goes into

00:17:41,660 --> 00:17:47,210
a data transfer stage where there's no

00:17:45,350 --> 00:17:50,360
public key crypto but really what you're

00:17:47,210 --> 00:17:54,919
trying to do is take your data and

00:17:50,360 --> 00:17:57,770
shovel it at the fastest crypto

00:17:54,919 --> 00:18:00,650
implementation you can find without you

00:17:57,770 --> 00:18:04,179
know copying it too much or really just

00:18:00,650 --> 00:18:09,440
getting in the way in any other sense

00:18:04,179 --> 00:18:11,450
but there's also a way of short cutting

00:18:09,440 --> 00:18:14,270
the public key crypto if you've talked

00:18:11,450 --> 00:18:16,400
to a server before and that's called a

00:18:14,270 --> 00:18:18,500
resumed or abbreviated handshake so

00:18:16,400 --> 00:18:22,610
that's also interesting for performance

00:18:18,500 --> 00:18:24,290
because um in practice so if you're if

00:18:22,610 --> 00:18:26,450
you're doing HTTP typically what you'll

00:18:24,290 --> 00:18:28,910
do is you'll go and do a full handshake

00:18:26,450 --> 00:18:30,830
with the server and then maybe you'll

00:18:28,910 --> 00:18:36,140
open a few more connections the same

00:18:30,830 --> 00:18:38,419
server to do other supper quests those

00:18:36,140 --> 00:18:41,059
other connections will tend to be

00:18:38,419 --> 00:18:47,260
resumed and then we just go into the

00:18:41,059 --> 00:18:50,020
same data transfer stage right so um

00:18:47,260 --> 00:18:53,480
russell's does quite well here and

00:18:50,020 --> 00:18:55,190
compared to open itself and the bottom

00:18:53,480 --> 00:18:57,910
they've got a link and blog post which

00:18:55,190 --> 00:18:57,910
should have

00:19:00,780 --> 00:19:08,170
but yeah but the headline is that both

00:19:03,700 --> 00:19:10,480
libraries can comfortably do 25 Gigabit

00:19:08,170 --> 00:19:12,070
Ethernet which is not hardware that I

00:19:10,480 --> 00:19:16,000
have I just don't have that kind of

00:19:12,070 --> 00:19:18,430
money the the difference here is

00:19:16,000 --> 00:19:22,750
basically that open itself has an extra

00:19:18,430 --> 00:19:26,260
men copy in in descending direction

00:19:22,750 --> 00:19:30,160
russell's doesn't because when we get

00:19:26,260 --> 00:19:32,350
data from the application we just borrow

00:19:30,160 --> 00:19:37,960
it to encrypt it rather than copying it

00:19:32,350 --> 00:19:41,710
and then encrypt again that's like I

00:19:37,960 --> 00:19:45,610
guess and then this is resumed

00:19:41,710 --> 00:19:48,670
handshaking performance so this is quite

00:19:45,610 --> 00:19:55,630
a lot better but I haven't fully

00:19:48,670 --> 00:19:57,520
understood why yeah I think I think I

00:19:55,630 --> 00:20:00,670
can I still is doing quite a lot more

00:19:57,520 --> 00:20:06,160
per connection well obviously is but

00:20:00,670 --> 00:20:10,450
yeah I haven't really looked into what

00:20:06,160 --> 00:20:13,000
precisely is doing so take that with a

00:20:10,450 --> 00:20:15,130
little bit pinch of salt and the full

00:20:13,000 --> 00:20:16,930
handshake performance is a little bit

00:20:15,130 --> 00:20:20,200
work well quite a lot worse for Russells

00:20:16,930 --> 00:20:23,560
but there are coming improvements in

00:20:20,200 --> 00:20:27,580
ring so it should make it roughly the

00:20:23,560 --> 00:20:29,140
same like 1.7 1.6 slower and then once

00:20:27,580 --> 00:20:34,840
we're there we can we're going to have a

00:20:29,140 --> 00:20:37,090
look I think making that equal and you

00:20:34,840 --> 00:20:39,040
may think oh 1600 that's actually really

00:20:37,090 --> 00:20:42,190
really slow but this test is

00:20:39,040 --> 00:20:45,660
specifically and quite artificial so it

00:20:42,190 --> 00:20:49,210
has an artificially long difficut chain

00:20:45,660 --> 00:20:51,190
just to really exercise as much public

00:20:49,210 --> 00:20:56,170
different paths of public key crypto as

00:20:51,190 --> 00:21:04,210
possible so now I wanna talk to talk

00:20:56,170 --> 00:21:08,200
about a fairly famous infamous security

00:21:04,210 --> 00:21:11,769
failure in Apple's homegrown

00:21:08,200 --> 00:21:13,029
pls library called to your transport and

00:21:11,769 --> 00:21:15,429
you might have noticed earlier there was

00:21:13,029 --> 00:21:20,639
some bindings to this it is today and

00:21:15,429 --> 00:21:24,100
quite well-regarded so don't worry but

00:21:20,639 --> 00:21:27,009
the interesting thing about this is they

00:21:24,100 --> 00:21:31,590
it's kind of open source but they don't

00:21:27,009 --> 00:21:31,590
develop it in the open so they just drop

00:21:31,739 --> 00:21:38,950
source for every release and someone

00:21:36,190 --> 00:21:42,519
noticed or maybe through testing I don't

00:21:38,950 --> 00:21:45,070
know that between two releases this line

00:21:42,519 --> 00:21:46,629
just appeared there were other changes

00:21:45,070 --> 00:21:49,059
in the file between this this release

00:21:46,629 --> 00:21:51,249
and that one so I think the current

00:21:49,059 --> 00:21:54,039
thinking is it's like a merge hazard

00:21:51,249 --> 00:21:56,769
that's happened where someone's screwed

00:21:54,039 --> 00:22:01,960
up emerge and duplicate this line

00:21:56,769 --> 00:22:03,940
unfortunately that go-to is executed

00:22:01,960 --> 00:22:08,649
unconditionally right because this isn't

00:22:03,940 --> 00:22:11,980
- and so it skips over this SSL raw

00:22:08,649 --> 00:22:13,989
verify and you may think OS or verify is

00:22:11,980 --> 00:22:15,249
that important yes it is that's the

00:22:13,989 --> 00:22:21,549
authenticity thing that we were talking

00:22:15,249 --> 00:22:22,989
about earlier so for quite a while it

00:22:21,549 --> 00:22:26,100
just that whole like we had no

00:22:22,989 --> 00:22:29,639
authenticity checks whatsoever really

00:22:26,100 --> 00:22:29,639
which is a shame

00:22:31,040 --> 00:22:37,910
so IIIi thought about um you know let's

00:22:35,660 --> 00:22:43,880
take that as a problem like the problem

00:22:37,910 --> 00:22:48,610
is I I use BIM and it's chaos and maybe

00:22:43,880 --> 00:22:50,720
I'll make an error like this one day and

00:22:48,610 --> 00:22:54,050
well first of all I'd like you not to

00:22:50,720 --> 00:22:57,500
compile really we're failing that can I

00:22:54,050 --> 00:23:00,770
make it you know what can I do what can

00:22:57,500 --> 00:23:03,290
we do right and I came up with the the

00:23:00,770 --> 00:23:09,620
conclusion that really the problem in

00:23:03,290 --> 00:23:11,180
this code is ignore the fact that

00:23:09,620 --> 00:23:14,390
obviously there's there's a lack of

00:23:11,180 --> 00:23:16,370
testing here the problem in this code is

00:23:14,390 --> 00:23:19,190
that there's nothing positive coming out

00:23:16,370 --> 00:23:20,930
of this this function it's just like the

00:23:19,190 --> 00:23:23,000
the return value from this function is

00:23:20,930 --> 00:23:27,050
zero if there's no error or an error

00:23:23,000 --> 00:23:32,450
code in practice all error codes are

00:23:27,050 --> 00:23:36,200
treated the same they're like you're

00:23:32,450 --> 00:23:38,000
being attached so returning zero is not

00:23:36,200 --> 00:23:39,530
actually very helpful when there's all

00:23:38,000 --> 00:23:44,000
these possible possibilities of

00:23:39,530 --> 00:23:48,080
returning zero so let's actually encode

00:23:44,000 --> 00:23:51,890
this in the type system and have a type

00:23:48,080 --> 00:23:55,240
which explicitly says I have verified

00:23:51,890 --> 00:23:58,070
the signature and only create that once

00:23:55,240 --> 00:24:02,030
exactly in the bit of code which

00:23:58,070 --> 00:24:05,300
verifies the signature and once we've

00:24:02,030 --> 00:24:08,960
got that type let's take it from up here

00:24:05,300 --> 00:24:11,630
where the verification happens and we've

00:24:08,960 --> 00:24:12,230
that type into the whole rest of the

00:24:11,630 --> 00:24:14,450
session

00:24:12,230 --> 00:24:16,040
so you can't get down here in the

00:24:14,450 --> 00:24:18,170
important bit of the session without

00:24:16,040 --> 00:24:22,610
having been up here and made this type

00:24:18,170 --> 00:24:26,170
having done this verification and that's

00:24:22,610 --> 00:24:28,520
cool right isn't awesome so this is what

00:24:26,170 --> 00:24:30,350
this is what it looks like so this is a

00:24:28,520 --> 00:24:31,200
particular verification it's not exactly

00:24:30,350 --> 00:24:34,380
the same

00:24:31,200 --> 00:24:36,539
all doing that I'm trying to be brief

00:24:34,380 --> 00:24:38,549
with this coach there so we want to

00:24:36,539 --> 00:24:41,179
verify that this thing that we got is

00:24:38,549 --> 00:24:46,080
the same as as this thing that we

00:24:41,179 --> 00:24:49,169
computed and only then we make one of

00:24:46,080 --> 00:24:51,450
these these values and then this struck

00:24:49,169 --> 00:24:54,649
down here is like the terminal state of

00:24:51,450 --> 00:24:59,370
of the TLS session where you're

00:24:54,649 --> 00:25:03,000
encrypting data back and forth and we

00:24:59,370 --> 00:25:06,269
have all these different zero size types

00:25:03,000 --> 00:25:10,320
which have only been created further up

00:25:06,269 --> 00:25:13,080
and earlier in the in the connection and

00:25:10,320 --> 00:25:15,870
that basically means that if you screw

00:25:13,080 --> 00:25:18,750
up this bit of code then the compiler

00:25:15,870 --> 00:25:20,789
won't let you get to here and all you

00:25:18,750 --> 00:25:22,950
have to do then is just it's a code

00:25:20,789 --> 00:25:27,980
review task of looking for this finish

00:25:22,950 --> 00:25:31,500
message verified assertion function and

00:25:27,980 --> 00:25:33,750
convincing yourself that the only path

00:25:31,500 --> 00:25:47,309
to get there does actually do the

00:25:33,750 --> 00:25:49,830
replication so there's so I used to have

00:25:47,309 --> 00:25:53,730
like this big list of stuff to do in the

00:25:49,830 --> 00:25:55,470
future and it keeps being ruined so I

00:25:53,730 --> 00:25:58,620
one of the things was write some glue

00:25:55,470 --> 00:26:03,240
for use in non-rem so my idea was

00:25:58,620 --> 00:26:07,139
actually - but you know and then someone

00:26:03,240 --> 00:26:09,179
went and did it so that was cool so this

00:26:07,139 --> 00:26:14,880
is very interesting in Calton makes a

00:26:09,179 --> 00:26:18,029
link and it's basically a sea library

00:26:14,880 --> 00:26:21,779
shaped box with an open ssl external

00:26:18,029 --> 00:26:23,970
interface containing Russells and ring

00:26:21,779 --> 00:26:27,059
and all the other stuff that russell

00:26:23,970 --> 00:26:30,480
depends on and the idea with this is

00:26:27,059 --> 00:26:32,690
that it's part of them

00:26:30,480 --> 00:26:36,690
and you live situation called Mesa lock

00:26:32,690 --> 00:26:40,379
Linux and they're just like taking large

00:26:36,690 --> 00:26:42,600
chunks of unsafe code in this case after

00:26:40,379 --> 00:26:46,950
that open itself and swapping them out

00:26:42,600 --> 00:26:53,879
incrementally that's really interesting

00:26:46,950 --> 00:26:56,460
like incremental approach to like you

00:26:53,879 --> 00:26:57,929
could either be right the world or you

00:26:56,460 --> 00:27:01,619
could start being right in the welding

00:26:57,929 --> 00:27:03,659
little bit um and I think that's really

00:27:01,619 --> 00:27:05,999
cool so I'm very have to do that I had

00:27:03,659 --> 00:27:10,619
no idea that was happening and it's just

00:27:05,999 --> 00:27:12,239
like oh I think amazing the other thing

00:27:10,619 --> 00:27:17,340
I want to work on in future is like

00:27:12,239 --> 00:27:20,220
verification so this is so testing

00:27:17,340 --> 00:27:21,570
testing is good testing with high

00:27:20,220 --> 00:27:25,980
coverage is good but it doesn't actually

00:27:21,570 --> 00:27:26,549
prove much it really if you get good

00:27:25,980 --> 00:27:29,129
coverage

00:27:26,549 --> 00:27:31,970
it proves that your tests aren't bad but

00:27:29,129 --> 00:27:34,409
it doesn't prove that your tests so good

00:27:31,970 --> 00:27:35,580
so you know if you're not covering the

00:27:34,409 --> 00:27:39,809
lines then you definitely don't have

00:27:35,580 --> 00:27:42,749
good tests but verification is a whole

00:27:39,809 --> 00:27:44,820
lot stronger it's like we have this

00:27:42,749 --> 00:27:47,820
abstract description of what the

00:27:44,820 --> 00:27:51,210
protocol should be does that match the

00:27:47,820 --> 00:27:54,059
concrete description in the code of what

00:27:51,210 --> 00:27:55,830
we're doing if they do then that's

00:27:54,059 --> 00:27:58,440
excellent if they don't if they differ

00:27:55,830 --> 00:28:00,869
that's probably a bug and it means that

00:27:58,440 --> 00:28:05,580
Russells is implementing a protocol

00:28:00,869 --> 00:28:08,820
which isn't strictly speaking TLS this

00:28:05,580 --> 00:28:10,649
has been done so I'm planning to reuse

00:28:08,820 --> 00:28:15,899
some of the work from estuary which is

00:28:10,649 --> 00:28:21,090
Amazon's in-house proprietary right

00:28:15,899 --> 00:28:22,649
trees open-source TLS library but yeah

00:28:21,090 --> 00:28:25,679
they've done this verification on their

00:28:22,649 --> 00:28:27,119
implementation and it's it's quite

00:28:25,679 --> 00:28:31,409
simple but it's a start

00:28:27,119 --> 00:28:34,210
it's like what that is is going then it

00:28:31,409 --> 00:28:36,750
should be possible to write you know

00:28:34,210 --> 00:28:42,610
automated verifications for things like

00:28:36,750 --> 00:28:45,540
replace replace the code review step in

00:28:42,610 --> 00:28:48,730
the previous slide just make sure that

00:28:45,540 --> 00:28:50,800
this function produces this type and

00:28:48,730 --> 00:28:57,940
then let the compiler deal with all the

00:28:50,800 --> 00:28:58,820
the rest of it but 3po that's my slides

00:28:57,940 --> 00:29:01,880
if you want them and

00:28:58,820 --> 00:29:01,880
[Music]

00:29:13,270 --> 00:29:35,470
do I have time for questions thank you

00:29:33,350 --> 00:29:38,950
great talk by the way

00:29:35,470 --> 00:29:43,340
and one of your previous slides she's

00:29:38,950 --> 00:29:44,690
said using a safe subset of rust could

00:29:43,340 --> 00:29:53,950
you explain a little bit more what does

00:29:44,690 --> 00:29:53,950
it means okay thank you

00:30:01,150 --> 00:30:08,900
subtle bugs I've heard I'm not really an

00:30:06,230 --> 00:30:12,320
expert but I heard that sometimes there

00:30:08,900 --> 00:30:14,690
are timing bugs yeah and I was wondering

00:30:12,320 --> 00:30:17,270
if there could be something that could

00:30:14,690 --> 00:30:20,270
be done too are we doing something to

00:30:17,270 --> 00:30:27,950
prevent them systematically or not just

00:30:20,270 --> 00:30:30,380
the main question so one of the the

00:30:27,950 --> 00:30:34,490
scope of Russell's is kind of like the

00:30:30,380 --> 00:30:36,400
protocol and that does have some steps

00:30:34,490 --> 00:30:39,950
which needs to be done in constant time

00:30:36,400 --> 00:30:41,920
but really the most important bits which

00:30:39,950 --> 00:30:46,660
need to be done in constant time are

00:30:41,920 --> 00:30:46,660
done in the crypto library in ring I

00:30:46,990 --> 00:30:54,830
definitely trust the Brian Smith to go

00:30:49,130 --> 00:30:57,430
right and and some extent the to a great

00:30:54,830 --> 00:31:03,170
extent the boring Excel people as well

00:30:57,430 --> 00:31:06,950
which is like the ultimate source of

00:31:03,170 --> 00:31:08,360
quite a lot of the code in ring so yeah

00:31:06,950 --> 00:31:11,300
I'm not saying not my problems because

00:31:08,360 --> 00:31:13,370
it definitely is but not to the extent

00:31:11,300 --> 00:31:15,530
which is an openness cell where it's

00:31:13,370 --> 00:31:17,990
like a bigger scope of project which

00:31:15,530 --> 00:31:21,810
includes all the crypto all the TLS

00:31:17,990 --> 00:31:29,340
protocol and yeah

00:31:21,810 --> 00:31:30,600
oh hi dad hey you mentioned earlier that

00:31:29,340 --> 00:31:32,160
you have a story about reporting a bug

00:31:30,600 --> 00:31:41,340
to OpenSSL do you have time to tell the

00:31:32,160 --> 00:31:45,150
story now hi I was wondering how much

00:31:41,340 --> 00:31:53,400
effort was it to achieve 97% test

00:31:45,150 --> 00:31:56,730
coverage yeah absolutely not a huge

00:31:53,400 --> 00:31:58,950
amount it was a lot of effort to get

00:31:56,730 --> 00:32:03,150
from like 94 to 97

00:31:58,950 --> 00:32:09,240
but getting to 94 was very easy I just

00:32:03,150 --> 00:32:12,540
want to like shout out to the BOGO the

00:32:09,240 --> 00:32:18,720
boys cell test suite that's like a

00:32:12,540 --> 00:32:25,160
really really really it's like the

00:32:18,720 --> 00:32:28,020
golang TLS library but really evil so it

00:32:25,160 --> 00:32:29,250
it like connects you and then sends the

00:32:28,020 --> 00:32:31,310
wrong message and then connects to you

00:32:29,250 --> 00:32:35,430
and then sends a different wrong message

00:32:31,310 --> 00:32:38,000
in a very targeted way so that that was

00:32:35,430 --> 00:32:40,920
really really awesome in order to UM

00:32:38,000 --> 00:32:42,440
actually test the library without that I

00:32:40,920 --> 00:32:44,850
probably would have had to write

00:32:42,440 --> 00:32:48,090
something equivalent myself and that's

00:32:44,850 --> 00:32:53,930
just no fun at all so and that that's

00:32:48,090 --> 00:32:56,850
that's that gives me like a lot more

00:32:53,930 --> 00:32:59,720
happiness about the state of it because

00:32:56,850 --> 00:32:59,720
it's being tested like

00:33:02,680 --> 00:33:09,080
so we all really like I think rust for

00:33:06,050 --> 00:33:13,000
the safety part but since most of us

00:33:09,080 --> 00:33:13,000
don't write all the application in rust

00:33:13,630 --> 00:33:18,560
what a lot of people do is they write

00:33:16,700 --> 00:33:21,260
this this libraries that you can consume

00:33:18,560 --> 00:33:23,450
from see and then pipe and so forth and

00:33:21,260 --> 00:33:26,600
it happened more than once to us already

00:33:23,450 --> 00:33:29,450
that the actual unsafety was in the in

00:33:26,600 --> 00:33:31,100
in the see binding or then they consumed

00:33:29,450 --> 00:33:32,870
on the PI site and so you mentioned

00:33:31,100 --> 00:33:37,280
before that I was miss a link which

00:33:32,870 --> 00:33:39,250
tries to expose Russells as my cell

00:33:37,280 --> 00:33:42,140
compatible API do you know if there's a

00:33:39,250 --> 00:33:46,180
do they do some auto generation there to

00:33:42,140 --> 00:33:48,440
verify that these bindings are safe or

00:33:46,180 --> 00:34:02,960
or do you know if there's a project that

00:33:48,440 --> 00:34:09,080
does this work obviously with the open

00:34:02,960 --> 00:34:10,700
SSL API is an interesting API and it's

00:34:09,080 --> 00:34:12,649
probably not if you would if you were

00:34:10,700 --> 00:34:15,100
looking for like a safety oriented C API

00:34:12,649 --> 00:34:18,050
50 LS it's probably not what you'd write

00:34:15,100 --> 00:34:20,330
there are better C api's like the one

00:34:18,050 --> 00:34:25,790
and that Lieber SSL came up with called

00:34:20,330 --> 00:34:27,560
Lib TLS that's probably what most people

00:34:25,790 --> 00:34:33,080
would come up with if they were writing

00:34:27,560 --> 00:34:37,870
a TLS API to see but no yeah I'm not

00:34:33,080 --> 00:34:37,870

YouTube URL: https://www.youtube.com/watch?v=aHMRFZkXq4Y


