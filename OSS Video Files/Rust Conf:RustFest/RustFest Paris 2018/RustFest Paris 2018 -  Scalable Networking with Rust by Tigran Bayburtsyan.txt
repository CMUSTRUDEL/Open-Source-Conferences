Title: RustFest Paris 2018 -  Scalable Networking with Rust by Tigran Bayburtsyan
Publication date: 2018-05-26
Playlist: RustFest Paris 2018
Description: 
	Tigran Bayburtsyan knows how to scale
a network service without fail
using #rustlang, MIO,
and a threadpool to go
so fast all competitors pale

Real-time networking applications becoming more popular, but building backend systems is challenging in terms of memory and cpu efficiency. This is a story about how at TreeScale (github.com/treescale) we got 10X+ memory and cpu efficiency using Rust MIO as a main network TCP/UNIX handling system with thread pools.

(Limerick by @llogiq)

https://paris.rustfest.eu/sessions/scalable-networking-with-rust
Captions: 
	00:00:06,839 --> 00:00:12,280
Teagan by Bucheon knows how to scale a

00:00:10,240 --> 00:00:16,180
network service without fail

00:00:12,280 --> 00:00:25,210
using rust mio and a threat pool to go

00:00:16,180 --> 00:00:27,539
so fast all competitors pale thank

00:00:25,210 --> 00:00:32,859
thanks for great introduction actually

00:00:27,539 --> 00:00:34,870
I'm Tigran for the past like eight years

00:00:32,859 --> 00:00:38,350
I've been doing system engineering

00:00:34,870 --> 00:00:41,050
mostly helping companies to optimize

00:00:38,350 --> 00:00:44,530
their cloud environments and especially

00:00:41,050 --> 00:00:47,620
Network heavy applications and you will

00:00:44,530 --> 00:00:50,199
be amazed how much you can save as a

00:00:47,620 --> 00:00:53,440
company just optimizing your network

00:00:50,199 --> 00:00:57,670
stack and it's it's just saving a lot of

00:00:53,440 --> 00:01:00,760
your resources for cloud computing so

00:00:57,670 --> 00:01:04,059
I'm typing many programming languages

00:01:00,760 --> 00:01:07,750
per day it's four or five that's my

00:01:04,059 --> 00:01:10,720
daily work and rust is not the major one

00:01:07,750 --> 00:01:13,840
but it's something that like I enjoy

00:01:10,720 --> 00:01:16,330
even doing like after work and this

00:01:13,840 --> 00:01:23,530
project actually started the project

00:01:16,330 --> 00:01:25,930
like to feed my interest and I'm doing a

00:01:23,530 --> 00:01:31,780
lot of motorcycling adventure writing

00:01:25,930 --> 00:01:34,900
and also skiing that's a lot yeah so few

00:01:31,780 --> 00:01:39,040
words about rescale we not going to dive

00:01:34,900 --> 00:01:41,680
in too deep how it actually behaved so

00:01:39,040 --> 00:01:44,020
in a few words it's just a scalable pop

00:01:41,680 --> 00:01:46,120
subsystem where you have the entire

00:01:44,020 --> 00:01:49,810
event distribution system without any

00:01:46,120 --> 00:01:53,320
central point and without any failure it

00:01:49,810 --> 00:01:56,530
just routing for the events first

00:01:53,320 --> 00:02:00,820
implementation was on goal obviously

00:01:56,530 --> 00:02:03,400
because it's it's just easy it's easy to

00:02:00,820 --> 00:02:07,270
code but after running it on a

00:02:03,400 --> 00:02:10,450
production with very heavy scale it

00:02:07,270 --> 00:02:14,620
turns out that goes garbage collection

00:02:10,450 --> 00:02:18,160
messing a lot with like memory

00:02:14,620 --> 00:02:21,820
deallocation and heavy traffic so

00:02:18,160 --> 00:02:25,270
second implementation was on C++ but

00:02:21,820 --> 00:02:29,130
after having a week working example on

00:02:25,270 --> 00:02:33,010
the production we got a segfault error

00:02:29,130 --> 00:02:35,620
and we even didn't made any debugging so

00:02:33,010 --> 00:02:44,470
we just started to write on rust because

00:02:35,620 --> 00:02:46,690
the yeah at that time we had some

00:02:44,470 --> 00:02:49,300
experiments but we thought okay maybe

00:02:46,690 --> 00:02:52,720
rust is too early but then we actually

00:02:49,300 --> 00:02:57,340
saw that it's a pretty mature language

00:02:52,720 --> 00:03:02,260
to use and for our specific needs we

00:02:57,340 --> 00:03:03,910
made on C++ the plays loop library

00:03:02,260 --> 00:03:06,610
called base loop which is actually

00:03:03,910 --> 00:03:09,010
almost the same thing as a my own but

00:03:06,610 --> 00:03:10,840
with less features the specific need

00:03:09,010 --> 00:03:14,470
features that we need it for that time

00:03:10,840 --> 00:03:16,480
and after we saw that mio like completes

00:03:14,470 --> 00:03:18,580
all the features that we need we just

00:03:16,480 --> 00:03:22,390
starting writing on that and actually

00:03:18,580 --> 00:03:24,640
writing to rust we canvassed from mio

00:03:22,390 --> 00:03:27,670
because if rust community didn't had

00:03:24,640 --> 00:03:33,130
that library we wouldn't start doing the

00:03:27,670 --> 00:03:36,010
rust and the base usage of mio here is

00:03:33,130 --> 00:03:39,670
actually the example code it's very

00:03:36,010 --> 00:03:42,280
simplified basically what it does it

00:03:39,670 --> 00:03:46,150
just makes event loop around the

00:03:42,280 --> 00:03:49,050
existing operating system a pole or K

00:03:46,150 --> 00:03:53,230
event based on the operating system and

00:03:49,050 --> 00:03:57,070
it just registers specific sockets to

00:03:53,230 --> 00:03:59,560
receive events and make some data

00:03:57,070 --> 00:04:02,560
processing with them each single event

00:03:59,560 --> 00:04:05,110
as you can see there's a like infinite

00:04:02,560 --> 00:04:07,450
loop which contains your entire logic

00:04:05,110 --> 00:04:09,730
and it's operates anterior your

00:04:07,450 --> 00:04:12,670
application is life so it based

00:04:09,730 --> 00:04:14,980
principle of event loop and it's single

00:04:12,670 --> 00:04:17,890
threaded so if you can imagine the

00:04:14,980 --> 00:04:20,549
application which works with the event

00:04:17,890 --> 00:04:23,560
loop it's something like this you have

00:04:20,549 --> 00:04:26,260
the infinite loop which produced

00:04:23,560 --> 00:04:29,410
specific actions based on kernel events

00:04:26,260 --> 00:04:31,760
then using a thread pool just to

00:04:29,410 --> 00:04:34,540
optimize your processes you

00:04:31,760 --> 00:04:37,370
the threat to land picking up some pull

00:04:34,540 --> 00:04:40,070
some thread inside that tool to perform

00:04:37,370 --> 00:04:42,230
some action and return back to your

00:04:40,070 --> 00:04:46,790
event loop and continue doing your

00:04:42,230 --> 00:04:49,300
process this is like the base for almost

00:04:46,790 --> 00:04:54,140
any kind of single threaded application

00:04:49,300 --> 00:04:56,750
but we actually faced some issues with

00:04:54,140 --> 00:05:00,770
this especially performance issues

00:04:56,750 --> 00:05:04,520
because like first point of three scale

00:05:00,770 --> 00:05:07,970
was to scale then it should be like

00:05:04,520 --> 00:05:12,290
super heavy network application so

00:05:07,970 --> 00:05:16,340
having working it on all CPUs without

00:05:12,290 --> 00:05:19,970
like a single thread that's like pretty

00:05:16,340 --> 00:05:24,440
important part and rust helped us to

00:05:19,970 --> 00:05:25,970
develop a technique with mio which is

00:05:24,440 --> 00:05:30,350
looking something like this

00:05:25,970 --> 00:05:32,630
let me this works okay so which looks

00:05:30,350 --> 00:05:36,140
something like this so basically we have

00:05:32,630 --> 00:05:39,440
instead of thread pool we have threads

00:05:36,140 --> 00:05:42,890
which is the same amount of threads as

00:05:39,440 --> 00:05:47,780
you have a CPU cores and each thread

00:05:42,890 --> 00:05:50,900
running single threaded loop which we

00:05:47,780 --> 00:05:53,000
called IO loop which means that we have

00:05:50,900 --> 00:05:55,190
a main thread which receives the

00:05:53,000 --> 00:05:57,170
connection makes some authentication

00:05:55,190 --> 00:06:01,130
stuff the first initial handshake and

00:05:57,170 --> 00:06:04,610
then passes that socket to IO loop which

00:06:01,130 --> 00:06:09,440
then performs the specific IO operation

00:06:04,610 --> 00:06:12,710
with its own action and tasks receiver

00:06:09,440 --> 00:06:15,790
mechanism inside that single thread so

00:06:12,710 --> 00:06:20,180
this helps to handle a lot more

00:06:15,790 --> 00:06:23,180
connections that we could in a previous

00:06:20,180 --> 00:06:26,060
example if when we have only one event

00:06:23,180 --> 00:06:29,270
loop and in this use case we

00:06:26,060 --> 00:06:33,980
specifically could interact through

00:06:29,270 --> 00:06:37,370
event aisle loop if someone stuck on one

00:06:33,980 --> 00:06:41,810
task the main loop detects that and

00:06:37,370 --> 00:06:44,720
catches that action and just performing

00:06:41,810 --> 00:06:45,800
that later on when other threads are

00:06:44,720 --> 00:06:48,290
free

00:06:45,800 --> 00:06:51,980
so basically we have some control system

00:06:48,290 --> 00:06:56,240
over multiple i/o loops and this is

00:06:51,980 --> 00:06:59,120
mainly we got this performance because

00:06:56,240 --> 00:07:03,230
of the rust thread saving thread safe

00:06:59,120 --> 00:07:06,280
fitting model and this is like the

00:07:03,230 --> 00:07:09,530
entire process works completely

00:07:06,280 --> 00:07:13,550
non-blocking so everything is written

00:07:09,530 --> 00:07:16,880
with the thread channels which is pretty

00:07:13,550 --> 00:07:20,470
awesome performance in terms of real

00:07:16,880 --> 00:07:25,420
code execution so here is like the

00:07:20,470 --> 00:07:28,880
example of the main main handler loop

00:07:25,420 --> 00:07:31,730
basically it whenever you got some TCP

00:07:28,880 --> 00:07:34,880
socket to accept or if it's a client

00:07:31,730 --> 00:07:36,650
socket you're basically making some

00:07:34,880 --> 00:07:41,270
validation around

00:07:36,650 --> 00:07:43,700
I know maybe certificate checking or the

00:07:41,270 --> 00:07:46,670
data validation whenever you can perform

00:07:43,700 --> 00:07:50,720
that and then basically what you are

00:07:46,670 --> 00:07:53,660
doing is using Mio principle you are the

00:07:50,720 --> 00:07:56,720
registering that TCP socket from current

00:07:53,660 --> 00:07:59,140
loop and passing that using the rust

00:07:56,720 --> 00:08:01,970
channels to one of the threads that

00:07:59,140 --> 00:08:04,130
operating another loop so that's the

00:08:01,970 --> 00:08:07,280
main principle for transferring and

00:08:04,130 --> 00:08:09,590
after this transfer operation this main

00:08:07,280 --> 00:08:12,380
handler loop don't know anything about

00:08:09,590 --> 00:08:14,560
that TCP socket it goes away from him

00:08:12,380 --> 00:08:17,900
and the other processing and

00:08:14,560 --> 00:08:22,910
input/output operations is just on that

00:08:17,900 --> 00:08:27,800
thread so this is a little bit like more

00:08:22,910 --> 00:08:31,160
code but the concept is that the ill

00:08:27,800 --> 00:08:35,150
handler loop receives that and just

00:08:31,160 --> 00:08:39,190
registers that inside his Pole inside

00:08:35,150 --> 00:08:43,130
his event loop so that way we can just

00:08:39,190 --> 00:08:46,600
transfer connections between multiple

00:08:43,130 --> 00:08:49,400
event loops and have operational like

00:08:46,600 --> 00:08:53,000
completely I think principle without any

00:08:49,400 --> 00:08:57,760
blocking data so that's the main

00:08:53,000 --> 00:08:59,060
benefits and the optimizations we had

00:08:57,760 --> 00:09:02,569
customer

00:08:59,060 --> 00:09:05,240
which is operating like few petabytes of

00:09:02,569 --> 00:09:09,230
networked data transfer especially

00:09:05,240 --> 00:09:12,259
images per day and they have got like

00:09:09,230 --> 00:09:15,769
from 6 to 10 times optimization in terms

00:09:12,259 --> 00:09:21,410
of memory after deploying this this

00:09:15,769 --> 00:09:24,639
principle versus go so and the main

00:09:21,410 --> 00:09:28,879
benefit from us is that using this

00:09:24,639 --> 00:09:32,870
technique we are able to like scale the

00:09:28,879 --> 00:09:37,459
code because rust itself is checking the

00:09:32,870 --> 00:09:39,110
safety and if you are for example hiring

00:09:37,459 --> 00:09:41,720
a new developer he don't know this

00:09:39,110 --> 00:09:43,850
trading model and he writes some

00:09:41,720 --> 00:09:46,759
component around that it just rust

00:09:43,850 --> 00:09:50,750
prevents some memory leak between

00:09:46,759 --> 00:09:55,819
passing some data between channels and

00:09:50,750 --> 00:09:59,060
threads and of course using multiple

00:09:55,819 --> 00:10:02,329
cores as a multiple event loops not only

00:09:59,060 --> 00:10:05,180
tasks we got really huge benefits of

00:10:02,329 --> 00:10:08,959
network bandwidth because now we are

00:10:05,180 --> 00:10:11,240
able to make input/output more

00:10:08,959 --> 00:10:15,829
aggressively with using multiple threads

00:10:11,240 --> 00:10:20,540
and yeah that's it the main benefit so

00:10:15,829 --> 00:10:23,870
in terms of closures this is the are

00:10:20,540 --> 00:10:28,100
something that we we have a lot in our

00:10:23,870 --> 00:10:30,980
code base so the principle is that when

00:10:28,100 --> 00:10:34,939
we need to implement or execute some

00:10:30,980 --> 00:10:37,459
tasks we are not passing data and we are

00:10:34,939 --> 00:10:41,149
passing the closer which contains the

00:10:37,459 --> 00:10:44,209
logic itself with the data in it which

00:10:41,149 --> 00:10:48,079
helps just to make some kind of a

00:10:44,209 --> 00:10:51,620
generic task executional threads or

00:10:48,079 --> 00:10:55,329
inside the thread tool which is like

00:10:51,620 --> 00:10:59,180
generic and you can pass any kind of

00:10:55,329 --> 00:11:02,199
operation which makes CPU execution or

00:10:59,180 --> 00:11:07,130
other stuff with the data itself in it

00:11:02,199 --> 00:11:11,000
and it's just helped us a lot to scale

00:11:07,130 --> 00:11:12,470
the code base from like having multiple

00:11:11,000 --> 00:11:15,950
traits into

00:11:12,470 --> 00:11:19,510
multiple traits even without like

00:11:15,950 --> 00:11:23,900
changing anything inside the base code

00:11:19,510 --> 00:11:27,650
so this is the main feature that we

00:11:23,900 --> 00:11:32,560
liked a lot after like moving away to

00:11:27,650 --> 00:11:34,910
rust in terms of infrastructure so we

00:11:32,560 --> 00:11:37,100
partially open source so based

00:11:34,910 --> 00:11:40,340
technology itself three scaled is open

00:11:37,100 --> 00:11:43,040
source but it's some kind of a demo we

00:11:40,340 --> 00:11:48,740
mainly showing that to customers or

00:11:43,040 --> 00:11:51,770
they're trying out on their own but the

00:11:48,740 --> 00:11:54,680
base code is written in rust but

00:11:51,770 --> 00:11:57,950
supportive technologies I will say the

00:11:54,680 --> 00:12:02,840
API endpoint is not rust because mainly

00:11:57,950 --> 00:12:06,550
the lack of hiring mainly so that's the

00:12:02,840 --> 00:12:10,100
main issue of getting started with rust

00:12:06,550 --> 00:12:14,090
yeah I guess that's it so I prepared a

00:12:10,100 --> 00:12:18,310
very short talk so yeah and if you have

00:12:14,090 --> 00:12:18,310
any questions please

00:12:18,690 --> 00:12:31,430
[Applause]

00:12:26,500 --> 00:12:34,960
so - we have time for questions but we

00:12:31,430 --> 00:12:34,960
need to figure out how to start these

00:12:46,870 --> 00:12:53,470
tester oh it's the red puppy okay thank

00:12:50,270 --> 00:12:58,160
you thank you

00:12:53,470 --> 00:13:03,020
hello thank you I was wondering if I

00:12:58,160 --> 00:13:04,339
played with a 0m q and a is it possible

00:13:03,020 --> 00:13:07,550
to do kind of the same thing of

00:13:04,339 --> 00:13:12,830
connecting a Rose application with a

00:13:07,550 --> 00:13:15,950
Python application not GS yeah yeah so

00:13:12,830 --> 00:13:19,370
the communication protocol itself the

00:13:15,950 --> 00:13:21,560
custom binary protocol but we have like

00:13:19,370 --> 00:13:24,920
API integrations with high-level

00:13:21,560 --> 00:13:28,190
application including the WebSockets so

00:13:24,920 --> 00:13:30,860
one of our clients is using inside the

00:13:28,190 --> 00:13:34,130
mobile lab so basically we compiled our

00:13:30,860 --> 00:13:36,980
rust SDK inside the mobile app and

00:13:34,130 --> 00:13:39,380
providing them this real-time networking

00:13:36,980 --> 00:13:42,100
feature for their mobile app so

00:13:39,380 --> 00:13:45,500
basically it just integratable and

00:13:42,100 --> 00:13:53,600
thanks to mio we can just integrate that

00:13:45,500 --> 00:13:56,210
to any any kind of platform some other

00:13:53,600 --> 00:13:59,690
questions thanks for the talk actually I

00:13:56,210 --> 00:14:02,000
have a question on the data how much

00:13:59,690 --> 00:14:04,880
copying of the data is actually

00:14:02,000 --> 00:14:08,630
happening when you have a movin'

00:14:04,880 --> 00:14:10,520
closures I mean do you have like

00:14:08,630 --> 00:14:14,120
multiple actions which should be

00:14:10,520 --> 00:14:17,870
executed on the same data oh yeah we we

00:14:14,120 --> 00:14:20,900
have multiple actions but data itself is

00:14:17,870 --> 00:14:23,630
not copying we have basically the byte

00:14:20,900 --> 00:14:26,089
array and every time when we are doing

00:14:23,630 --> 00:14:30,380
something we are actually doing by

00:14:26,089 --> 00:14:32,720
reference to that array and in terms of

00:14:30,380 --> 00:14:37,339
protocol we are just appending like 60

00:14:32,720 --> 00:14:39,980
byte to that original data and we're not

00:14:37,339 --> 00:14:42,320
doing any data manipulation to like

00:14:39,980 --> 00:14:44,630
customers original data whenever you

00:14:42,320 --> 00:14:46,760
have some API endpoint and transferring

00:14:44,630 --> 00:14:48,680
data through three scale we are not

00:14:46,760 --> 00:14:51,800
touching that we are only working with

00:14:48,680 --> 00:14:55,430
our sixty byte header which is our main

00:14:51,800 --> 00:14:56,810
protocol stuff and that header is all

00:14:55,430 --> 00:14:59,420
all the time

00:14:56,810 --> 00:15:01,430
first and they code it using bite

00:14:59,420 --> 00:15:04,760
reference without caulking

00:15:01,430 --> 00:15:09,190
so we are using some little pieces of

00:15:04,760 --> 00:15:11,900
unsafe code just to give that like

00:15:09,190 --> 00:15:16,310
manipulation more easily because we have

00:15:11,900 --> 00:15:19,339
some big endian and little engine Indian

00:15:16,310 --> 00:15:22,100
conversed conversation between just to

00:15:19,339 --> 00:15:25,820
figure out the lengths of the bytes some

00:15:22,100 --> 00:15:28,610
in some places but it's some that

00:15:25,820 --> 00:15:30,740
protocol came from C++ code and we

00:15:28,610 --> 00:15:35,529
didn't change that we just made the

00:15:30,740 --> 00:15:35,529
unsafe rest code okay thanks

00:15:36,040 --> 00:15:43,160
hello you said you're using mio yeah

00:15:40,100 --> 00:15:47,210
would it make sense in your case or is

00:15:43,160 --> 00:15:49,910
it possible to use Tokyo so during that

00:15:47,210 --> 00:15:53,089
time when we started writing the Tokyo

00:15:49,910 --> 00:15:56,570
wasn't that stable I mean it's not to

00:15:53,089 --> 00:15:58,580
release released yet but then when it's

00:15:56,570 --> 00:16:01,370
released with started to think about

00:15:58,580 --> 00:16:05,089
moving but it was too much change

00:16:01,370 --> 00:16:07,490
because the principle of features inside

00:16:05,089 --> 00:16:11,120
the Tokyo is not relevant for our case

00:16:07,490 --> 00:16:13,339
because basically we're transferring TCP

00:16:11,120 --> 00:16:17,600
sockets between multiple threads and

00:16:13,339 --> 00:16:20,540
actually inside the github issues for

00:16:17,600 --> 00:16:23,960
mio I raise the question is it really

00:16:20,540 --> 00:16:26,720
thread safe to pass TCP connection

00:16:23,960 --> 00:16:29,990
between multiple threads and Alex

00:16:26,720 --> 00:16:33,560
actually replied that I generally no but

00:16:29,990 --> 00:16:36,110
if you if you are using in linux based

00:16:33,560 --> 00:16:39,440
environment or unix so basically it's

00:16:36,110 --> 00:16:43,870
not it wouldn't work on windows but for

00:16:39,440 --> 00:16:46,520
windows we did don't making like thread

00:16:43,870 --> 00:16:49,520
TCP socket thread passing we are using

00:16:46,520 --> 00:16:51,890
different technique but we all have only

00:16:49,520 --> 00:16:56,810
one customer which requires a Windows so

00:16:51,890 --> 00:16:59,060
it's not to deal there was another

00:16:56,810 --> 00:17:00,890
question over there yeah so you

00:16:59,060 --> 00:17:04,699
mentioned that you are taking the

00:17:00,890 --> 00:17:06,020
existing or the existing messages that

00:17:04,699 --> 00:17:07,490
you receive and

00:17:06,020 --> 00:17:11,060
and our prepending some stuff at the

00:17:07,490 --> 00:17:12,950
beginning how do you make sure that you

00:17:11,060 --> 00:17:14,570
have room to do that or are these like

00:17:12,950 --> 00:17:15,440
fixed-length header for the dynamic and

00:17:14,570 --> 00:17:16,850
how do you make sure that when you

00:17:15,440 --> 00:17:19,190
actually read the data in there's enough

00:17:16,850 --> 00:17:21,560
room before the data that you're getting

00:17:19,190 --> 00:17:24,680
in order to place your headers yeah so

00:17:21,560 --> 00:17:28,880
if you can imagine the white flow we're

00:17:24,680 --> 00:17:31,010
basically getting your data and make

00:17:28,880 --> 00:17:33,920
making sure that we have a proper length

00:17:31,010 --> 00:17:36,830
because of the like nature of TCP we

00:17:33,920 --> 00:17:41,060
know that if the airflow ends with some

00:17:36,830 --> 00:17:43,910
specific point then your data that's how

00:17:41,060 --> 00:17:47,810
it is we basically measuring the length

00:17:43,910 --> 00:17:49,760
of bytes and putting that with the begin

00:17:47,810 --> 00:17:53,210
the end that you have this amount of

00:17:49,760 --> 00:17:57,470
length it's a four byte integer for us

00:17:53,210 --> 00:18:00,440
so basically whenever our another node

00:17:57,470 --> 00:18:03,020
reading your data it tries to find first

00:18:00,440 --> 00:18:06,050
first four bytes to decode and

00:18:03,020 --> 00:18:09,290
understand how many lengths length he

00:18:06,050 --> 00:18:12,110
needs to accept from another node so

00:18:09,290 --> 00:18:14,750
that's how we transferring data and

00:18:12,110 --> 00:18:16,700
making sure that there is no data loss

00:18:14,750 --> 00:18:23,780
we're basically transferring the length

00:18:16,700 --> 00:18:28,460
as a first four bytes and do you play

00:18:23,780 --> 00:18:33,740
any you integration from stock before so

00:18:28,460 --> 00:18:36,740
for weather no so we have one customer

00:18:33,740 --> 00:18:41,270
with web integration but we provided for

00:18:36,740 --> 00:18:44,630
them WebSockets I guess we'd webassembly

00:18:41,270 --> 00:18:47,420
it's really complicated because not all

00:18:44,630 --> 00:18:51,470
production browsers right now supporting

00:18:47,420 --> 00:18:54,260
and not all customers wants to see

00:18:51,470 --> 00:18:57,440
Hecky website web assembly right now

00:18:54,260 --> 00:19:01,640
because generally it's not in production

00:18:57,440 --> 00:19:04,370
so most of the like companies don't want

00:19:01,640 --> 00:19:06,980
to see that on their environment that's

00:19:04,370 --> 00:19:10,420
from my experience because we tried also

00:19:06,980 --> 00:19:10,420
experimental on that way

00:19:18,669 --> 00:19:26,320
now thank you and enjoy your lunch

00:19:21,620 --> 00:19:26,320

YouTube URL: https://www.youtube.com/watch?v=1y_0kf5CxI8


