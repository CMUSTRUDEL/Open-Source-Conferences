Title: Rust and Tell Berlin - March 2020
Publication date: 2020-04-01
Playlist: Rust and Tell Berlin
Description: 
	https://berline.rs/2020/03/31/rust-and-tell.html

Rust & Tell Berlin, the monthly event to share ideas, and learn about new things in and about Rust, went fully online for the first time. 

Talks:

#1: 00:09:25 - Integers in the Small, Big, and Macro by Bram Geron

#2: 00:32:12 - Tremor - A Rust Project from Wayfair by Heinz Gies

#3: 01:03:39 - Async HTTP by Yosh Wuyts
Captions: 
	00:00:00,000 --> 00:00:03,080
[Music]

00:00:55,770 --> 00:01:04,440
hello everyone oops

00:01:12,320 --> 00:01:17,820
unfortunately a zoom doesn't allow me to

00:01:14,190 --> 00:01:19,620
see the list while I'm presenting so I

00:01:17,820 --> 00:01:21,240
assume people are coming into the room

00:01:19,620 --> 00:01:23,360
now we're gonna get started in just a

00:01:21,240 --> 00:01:23,360
minute

00:02:57,570 --> 00:03:06,700
all right so we're going to get started

00:03:01,810 --> 00:03:09,580
welcome everyone to rust Intel Berlin

00:03:06,700 --> 00:03:12,269
for four March we're doing things a

00:03:09,580 --> 00:03:15,280
little bit differently this month

00:03:12,269 --> 00:03:17,290
everyone here probably can tell we are

00:03:15,280 --> 00:03:20,650
not somewhere in Berlin but we are

00:03:17,290 --> 00:03:23,920
rather on the interwebs shout out to

00:03:20,650 --> 00:03:24,640
anybody who is coming to us who does not

00:03:23,920 --> 00:03:27,340
live in Berlin

00:03:24,640 --> 00:03:30,970
welcome to probably your first rest

00:03:27,340 --> 00:03:34,930
until Berlin that you've been to we're

00:03:30,970 --> 00:03:37,840
happy to have you here and we are going

00:03:34,930 --> 00:03:40,170
to have a great night of talks and also

00:03:37,840 --> 00:03:42,880
a small club challenge at the end and

00:03:40,170 --> 00:03:44,230
hopefully things will go smoothly this

00:03:42,880 --> 00:03:47,380
is the first time we're doing this event

00:03:44,230 --> 00:03:52,930
online and so bear with us if you have

00:03:47,380 --> 00:03:54,970
any questions or any any technical

00:03:52,930 --> 00:03:56,799
questions or anything about the stream

00:03:54,970 --> 00:03:59,170
or anything like that feel free to write

00:03:56,799 --> 00:04:02,140
it in the zoom chat we also have our

00:03:59,170 --> 00:04:03,640
matrix chat um hopefully you have the

00:04:02,140 --> 00:04:09,750
instructions for joining that that's

00:04:03,640 --> 00:04:12,700
where we'll do more of our more of the

00:04:09,750 --> 00:04:16,979
kind of talk about the actual talks and

00:04:12,700 --> 00:04:20,950
things like that there so real quick a

00:04:16,979 --> 00:04:23,410
little bit about who we are I'm Ryan

00:04:20,950 --> 00:04:25,539
Levesque and you can't see my Twitter

00:04:23,410 --> 00:04:28,479
handle because it's covered by Ferriss

00:04:25,539 --> 00:04:29,620
but i'm at ryan underscore Levesque on

00:04:28,479 --> 00:04:32,890
twitter um

00:04:29,620 --> 00:04:38,400
so feel free to reach out to me and I'm

00:04:32,890 --> 00:04:39,610
posting group also a rest full-time

00:04:38,400 --> 00:04:42,009
developer

00:04:39,610 --> 00:04:43,840
for about a year and you can reach out

00:04:42,009 --> 00:04:50,710
on me find me on LinkedIn or on my

00:04:43,840 --> 00:04:53,650
website and so like the concept for the

00:04:50,710 --> 00:04:56,530
meetup is the first time it's super a

00:04:53,650 --> 00:04:59,500
digital but even here it's for the

00:04:56,530 --> 00:05:02,199
beginners to the expert so we just want

00:04:59,500 --> 00:05:05,590
to hear about your ideas your struggles

00:05:02,199 --> 00:05:08,349
your hikes or projects we want to have

00:05:05,590 --> 00:05:10,810
just them every month them two to three

00:05:08,349 --> 00:05:14,439
hours where we can come together as a

00:05:10,810 --> 00:05:18,580
rest community and talk and share about

00:05:14,439 --> 00:05:25,419
our struggles or our laughs for the

00:05:18,580 --> 00:05:28,569
language and really what that means is

00:05:25,419 --> 00:05:30,610
that we would like you to to participate

00:05:28,569 --> 00:05:32,909
em and that really also means people who

00:05:30,610 --> 00:05:35,229
are joining from outside of Berlin I'm

00:05:32,909 --> 00:05:37,930
probably I'm pretty sure we're going to

00:05:35,229 --> 00:05:42,250
be doing this online again in the future

00:05:37,930 --> 00:05:43,810
unless things go really well then we

00:05:42,250 --> 00:05:46,240
will be doing this online in the future

00:05:43,810 --> 00:05:49,240
and so we are open to having talks from

00:05:46,240 --> 00:05:52,960
people who are not based in Berlin and

00:05:49,240 --> 00:05:55,659
we really wanted to you to to speak

00:05:52,960 --> 00:05:57,819
about anything related to rest and if

00:05:55,659 --> 00:06:01,060
you think we're not talking about you

00:05:57,819 --> 00:06:04,150
specifically we are we mean every each

00:06:01,060 --> 00:06:06,250
and last one of you we want to hear even

00:06:04,150 --> 00:06:07,029
if you've only played with rust for a

00:06:06,250 --> 00:06:08,770
minute

00:06:07,029 --> 00:06:13,569
give us your first impressions we'd love

00:06:08,770 --> 00:06:17,830
to hear about it and we follow the

00:06:13,569 --> 00:06:22,240
Berlin code of contact we want to have a

00:06:17,830 --> 00:06:24,430
safe and a fun space every one of us I'm

00:06:22,240 --> 00:06:27,069
spending there I'm a free time and

00:06:24,430 --> 00:06:30,879
they're in a private time on this Meetup

00:06:27,069 --> 00:06:34,150
so we want to behave nicely you can

00:06:30,879 --> 00:06:36,610
share on a secure code you can share

00:06:34,150 --> 00:06:41,020
what you want and you shouldn't be like

00:06:36,610 --> 00:06:44,560
a rest by it and if you feel not welcome

00:06:41,020 --> 00:06:48,459
here or you feel that something happened

00:06:44,560 --> 00:06:51,580
at a meet-up please report us privately

00:06:48,459 --> 00:06:53,470
you can create a fake email and email us

00:06:51,580 --> 00:07:00,340
we will follow through

00:06:53,470 --> 00:07:01,960
every request which comes our way so

00:07:00,340 --> 00:07:04,210
this slide is normally for our sponsors

00:07:01,960 --> 00:07:06,490
we don't have a sponsor this month but

00:07:04,210 --> 00:07:09,070
we would like to have a shout out to yon

00:07:06,490 --> 00:07:13,060
epic who has helped us set up the matrix

00:07:09,070 --> 00:07:16,780
in the zoom this is based off of the

00:07:13,060 --> 00:07:21,070
infrastructure that was used for the

00:07:16,780 --> 00:07:24,370
oxide 1000 conference that happened last

00:07:21,070 --> 00:07:26,230
week which was really great

00:07:24,370 --> 00:07:29,500
for those that weren't there the talks

00:07:26,230 --> 00:07:31,870
are now online so check check that out

00:07:29,500 --> 00:07:39,010
and so thank you very much an attic for

00:07:31,870 --> 00:07:42,670
your help and I'm a today's talks we

00:07:39,010 --> 00:07:45,690
have Ambrym who talks about integers and

00:07:42,670 --> 00:07:48,730
a small big and macro we hear about

00:07:45,690 --> 00:07:51,690
project from a Wayfarer which is called

00:07:48,730 --> 00:07:56,470
tremor which I think it's a run time and

00:07:51,690 --> 00:07:59,560
we hear from your about essing htdp

00:07:56,470 --> 00:08:02,320
so I think all different types and

00:07:59,560 --> 00:08:06,580
interesting talks today just a little

00:08:02,320 --> 00:08:09,010
note on brakes we will have one roughly

00:08:06,580 --> 00:08:12,310
10 to 15 minute break after the second

00:08:09,010 --> 00:08:14,620
talk and we'll break out into two

00:08:12,310 --> 00:08:17,169
breakout rooms where if you are feeling

00:08:14,620 --> 00:08:19,360
up to it you can chat with your fellow

00:08:17,169 --> 00:08:21,760
recitations about anything and

00:08:19,360 --> 00:08:23,770
everything and then we'll bring you back

00:08:21,760 --> 00:08:26,980
and when the talks are ready to go and

00:08:23,770 --> 00:08:29,919
of course feel free to mute your mic and

00:08:26,980 --> 00:08:31,360
your and your webcam if you don't want

00:08:29,919 --> 00:08:34,620
to participate there's there's no

00:08:31,360 --> 00:08:36,250
obligation there so thank you very much

00:08:34,620 --> 00:08:40,630
for that

00:08:36,250 --> 00:08:46,150
and without further ado we will switch

00:08:40,630 --> 00:08:48,580
over to our first speaker Bram who will

00:08:46,150 --> 00:08:51,460
take will talk to us about very

00:08:48,580 --> 00:08:54,460
interesting things take it away cool

00:08:51,460 --> 00:08:56,800
awesome thanks you did mention before

00:08:54,460 --> 00:08:58,900
that it's August recorded so I'm not

00:08:56,800 --> 00:09:00,220
sure you mentioned if your webcam is on

00:08:58,900 --> 00:09:02,500
you might be on the court

00:09:00,220 --> 00:09:04,420
I just wanted to make up doubly clear

00:09:02,500 --> 00:09:24,660
let me figure out how to share my screen

00:09:04,420 --> 00:09:27,690
again good all right good

00:09:24,660 --> 00:09:30,580
yeah welcome thanks for organizing this

00:09:27,690 --> 00:09:32,020
Ryan Gosling generic kiss stuff like

00:09:30,580 --> 00:09:34,720
this really breaks up my week in a nice

00:09:32,020 --> 00:09:36,760
way it's it makes it a lot less boring

00:09:34,720 --> 00:09:39,310
and monotonous these testing times I

00:09:36,760 --> 00:09:41,860
hope everyone's okay given the

00:09:39,310 --> 00:09:45,400
circumstances so my talk is gonna be

00:09:41,860 --> 00:09:47,050
about a crates that I wrote school small

00:09:45,400 --> 00:09:49,540
beginnings PC my cursor oh by the way

00:09:47,050 --> 00:09:53,320
I'm assuming it can because I'm using it

00:09:49,540 --> 00:09:56,080
to point at stuff and if they're awesome

00:09:53,320 --> 00:09:58,210
thanks and the talks for the slide the

00:09:56,080 --> 00:10:02,050
slides for this talk are on this URL and

00:09:58,210 --> 00:10:05,380
there's also some links in that and the

00:10:02,050 --> 00:10:07,330
presence of notes if you want my name is

00:10:05,380 --> 00:10:09,700
Brian Jarrah I have a company called

00:10:07,330 --> 00:10:12,250
confirmo we make data virtualization and

00:10:09,700 --> 00:10:16,150
government stuff for enterprise but it's

00:10:12,250 --> 00:10:19,000
not related to rust and I think for us

00:10:16,150 --> 00:10:21,400
is really amazing because I find it

00:10:19,000 --> 00:10:23,560
super satisfying that when you create a

00:10:21,400 --> 00:10:24,880
program maybe it's not always the

00:10:23,560 --> 00:10:26,980
easiest language to create your program

00:10:24,880 --> 00:10:29,050
in the first time but when it works it

00:10:26,980 --> 00:10:31,150
really works you don't tend to get no

00:10:29,050 --> 00:10:34,210
pointer exceptions or there's a lot of

00:10:31,150 --> 00:10:37,110
funny stuff that you could run into in

00:10:34,210 --> 00:10:40,240
production or wherever you see a thing

00:10:37,110 --> 00:10:42,280
that you didn't expect when you wrote

00:10:40,240 --> 00:10:45,580
the program and then it takes a lot of

00:10:42,280 --> 00:10:47,710
time to fix the thing with rust that's

00:10:45,580 --> 00:10:51,520
less I think a lot of this comes from

00:10:47,710 --> 00:10:53,470
the type system and a compiler it just

00:10:51,520 --> 00:10:55,930
knows are not allowed stuff like that

00:10:53,470 --> 00:10:58,000
but I think another part is because

00:10:55,930 --> 00:10:59,770
there are fractions are so cheap so a

00:10:58,000 --> 00:11:02,050
new step for instance structs with a

00:10:59,770 --> 00:11:02,980
single field they are practically free

00:11:02,050 --> 00:11:05,940
at runtime

00:11:02,980 --> 00:11:08,290
not entirely free at compile time and

00:11:05,940 --> 00:11:11,700
that's like small overheads but it's

00:11:08,290 --> 00:11:13,860
really negligible and I think this

00:11:11,700 --> 00:11:15,810
allows people to create

00:11:13,860 --> 00:11:17,250
our actions more often they don't sweat

00:11:15,810 --> 00:11:19,740
the things why so you just make a new

00:11:17,250 --> 00:11:22,769
struts stuff like this not just the

00:11:19,740 --> 00:11:25,200
abstractions but stuff like this not

00:11:22,769 --> 00:11:27,959
just new types I mean it really helps to

00:11:25,200 --> 00:11:30,570
make a great community with great API is

00:11:27,959 --> 00:11:33,510
and then create everything and so this

00:11:30,570 --> 00:11:35,839
is talk about making the right thing to

00:11:33,510 --> 00:11:38,519
do a bit cheaper

00:11:35,839 --> 00:11:42,029
unfortunately in programming numbers

00:11:38,519 --> 00:11:45,290
don't just work so numbers are a very

00:11:42,029 --> 00:11:47,820
common thing let me give you an example

00:11:45,290 --> 00:11:50,970
I've got a note here so that's the

00:11:47,820 --> 00:11:53,310
program for JavaScript and you might

00:11:50,970 --> 00:11:56,640
want to calculate with some manners

00:11:53,310 --> 00:11:59,670
it's like a big number here you might

00:11:56,640 --> 00:12:01,790
use numbers for counting them refuses

00:11:59,670 --> 00:12:08,519
that you have or page views or maybe

00:12:01,790 --> 00:12:12,390
times or maybe yeah not a second synonym

00:12:08,519 --> 00:12:13,620
or their stats on it so there's a lot of

00:12:12,390 --> 00:12:15,660
manipulations that you won't deal with

00:12:13,620 --> 00:12:21,029
numbers and so it's really useful when

00:12:15,660 --> 00:12:23,820
the numbers work but it depends on how

00:12:21,029 --> 00:12:26,070
big you get can you see if you've got

00:12:23,820 --> 00:12:28,230
this really big number in JavaScript

00:12:26,070 --> 00:12:32,579
then you can't do +1 anymore you can do

00:12:28,230 --> 00:12:33,449
plus 2 you can do plus 3 but it rounds

00:12:32,579 --> 00:12:35,930
really funny

00:12:33,449 --> 00:12:38,820
and so I think numbers are often

00:12:35,930 --> 00:12:42,870
something that don't just work here yeah

00:12:38,820 --> 00:12:44,820
and it's a pity it bother me a bit so I

00:12:42,870 --> 00:12:46,230
made us more great about it the crate is

00:12:44,820 --> 00:12:50,399
super simple this is not gonna be a

00:12:46,230 --> 00:12:52,980
super difficult talk I hope ya thought

00:12:50,399 --> 00:12:54,750
it could be fun to explain anyway so the

00:12:52,980 --> 00:12:57,959
thing that you just saw is because

00:12:54,750 --> 00:13:00,120
JavaScript uses 64 bit floats and that

00:12:57,959 --> 00:13:02,579
means that there's about 53 bits of

00:13:00,120 --> 00:13:05,820
precision if you're a numbers girl above

00:13:02,579 --> 00:13:07,920
53 bits then you can only store every

00:13:05,820 --> 00:13:09,600
other number so plus 2 works but plus 1

00:13:07,920 --> 00:13:10,860
doesn't work anymore and when the

00:13:09,600 --> 00:13:13,279
numbers get even bigger then you get

00:13:10,860 --> 00:13:16,740
even less precision and this is a

00:13:13,279 --> 00:13:18,269
surprising thing you probably expect us

00:13:16,740 --> 00:13:21,959
to just work because they always work

00:13:18,269 --> 00:13:24,779
but sometimes yeah you suddenly get

00:13:21,959 --> 00:13:27,300
something even expects rust or something

00:13:24,779 --> 00:13:29,430
different I think it's better

00:13:27,300 --> 00:13:31,050
is also not perfect so in Russell you

00:13:29,430 --> 00:13:32,519
know big it's still big sign your

00:13:31,050 --> 00:13:37,140
program crashes it's really annoying

00:13:32,519 --> 00:13:39,390
that you can fix it and then it's

00:13:37,140 --> 00:13:42,120
probably easier to debug the crash than

00:13:39,390 --> 00:13:44,370
to debug a wrong answer but still a bit

00:13:42,120 --> 00:13:46,769
annoying other languages tend to do

00:13:44,370 --> 00:13:50,040
wrapping integers which you cannot see

00:13:46,769 --> 00:13:51,480
you in rust if you want to so then if

00:13:50,040 --> 00:13:55,290
you have a big number on your multiplier

00:13:51,480 --> 00:13:57,360
then maybe you get zero Lawson or maybe

00:13:55,290 --> 00:14:01,680
you get something negative or something

00:13:57,360 --> 00:14:03,750
else funny also not really ideal and I

00:14:01,680 --> 00:14:06,570
come from I used to use a lot of Lisp

00:14:03,750 --> 00:14:08,670
and Python in the past and as language

00:14:06,570 --> 00:14:11,160
tends to have big uns which are

00:14:08,670 --> 00:14:13,140
optimized and everything just works and

00:14:11,160 --> 00:14:15,779
I thought it's a really nice experience

00:14:13,140 --> 00:14:19,500
that wants it make it's slightly easier

00:14:15,779 --> 00:14:21,029
immersed as well I just want to say from

00:14:19,500 --> 00:14:23,100
that I didn't do any of the hard work

00:14:21,029 --> 00:14:26,250
the real hard work is done by this great

00:14:23,100 --> 00:14:29,610
non-vegans and but let me let me just

00:14:26,250 --> 00:14:32,760
explain how they work so with humans if

00:14:29,610 --> 00:14:35,430
you want to use numbers you've got they

00:14:32,760 --> 00:14:38,760
just wondered once a nine and people

00:14:35,430 --> 00:14:41,760
learned that three plus four is seven so

00:14:38,760 --> 00:14:42,870
you have those graphics and if you do

00:14:41,760 --> 00:14:45,180
plus some of those things that you get

00:14:42,870 --> 00:14:48,870
you just learn it by heart but it's not

00:14:45,180 --> 00:14:51,600
scalable of course so after seven eight

00:14:48,870 --> 00:14:53,370
nine you need to go to one zero and then

00:14:51,600 --> 00:14:55,230
after one nine you need to go to zero

00:14:53,370 --> 00:14:58,260
and after nine nine years ago two one

00:14:55,230 --> 00:15:01,079
zero zero and this makes things

00:14:58,260 --> 00:15:03,690
unlimited and they're certain algorithms

00:15:01,079 --> 00:15:08,550
for calculating so there's a sofa in

00:15:03,690 --> 00:15:11,370
London primary school probably and so no

00:15:08,550 --> 00:15:14,010
big and the supreme was saying but in a

00:15:11,370 --> 00:15:16,980
bigger sense so big humans is the type

00:15:14,010 --> 00:15:19,320
of numbers that we're gonna use that we

00:15:16,980 --> 00:15:22,680
use internally in this crate and it's

00:15:19,320 --> 00:15:25,800
just a vector of digits the digits are 0

00:15:22,680 --> 00:15:29,310
to 9 the ditches are 4 bytes each there

00:15:25,800 --> 00:15:31,680
are users and we are so the the type

00:15:29,310 --> 00:15:34,649
definition of the type is super simple

00:15:31,680 --> 00:15:35,850
the hard part is writing the addition so

00:15:34,649 --> 00:15:40,130
the stuff that you learn in primary

00:15:35,850 --> 00:15:40,130
school but now the computer is basically

00:15:40,220 --> 00:15:46,850
yeah this is all great but it's not

00:15:44,090 --> 00:15:48,740
perfect because you always have to go to

00:15:46,850 --> 00:15:52,880
the heap you see this is a vector and

00:15:48,740 --> 00:15:55,640
the vector is I think 24 bytes on the

00:15:52,880 --> 00:15:59,060
stack or wherever the the big Givens

00:15:55,640 --> 00:16:04,010
will be stored and then at least four by

00:15:59,060 --> 00:16:05,330
Sandeep so it's it could be quite day if

00:16:04,010 --> 00:16:07,610
you're big and big you insist just

00:16:05,330 --> 00:16:09,680
storing the number five then using a lot

00:16:07,610 --> 00:16:12,050
of bytes and using one indirection

00:16:09,680 --> 00:16:16,250
distorted number five which is not

00:16:12,050 --> 00:16:18,310
always also for signed integers it's

00:16:16,250 --> 00:16:20,660
even a bit bigger and the speed is also

00:16:18,310 --> 00:16:22,460
it's accessible to think in most cases

00:16:20,660 --> 00:16:25,340
but it's not amazing

00:16:22,460 --> 00:16:32,450
I think about 200 times as slow as

00:16:25,340 --> 00:16:35,360
machine images and so this goes like me

00:16:32,450 --> 00:16:36,620
against the second thing so when it's

00:16:35,360 --> 00:16:38,210
cheap or exceeded all right thing I

00:16:36,620 --> 00:16:41,050
think you'll do it more often and I

00:16:38,210 --> 00:16:43,220
think you'll get less books and the end

00:16:41,050 --> 00:16:45,710
so I'm gonna make big in smaller and

00:16:43,220 --> 00:16:48,200
faster that's what the crate does and I

00:16:45,710 --> 00:16:51,680
just used a small fact trick so small

00:16:48,200 --> 00:16:53,450
that is a type of vectors but when it's

00:16:51,680 --> 00:16:56,540
small it goes on the stack so you can

00:16:53,450 --> 00:16:58,640
make a small vac of size 8 integers and

00:16:56,540 --> 00:17:00,710
then when you have 5 integers now it

00:16:58,640 --> 00:17:03,440
stays on the stack if it gets more than

00:17:00,710 --> 00:17:07,189
it goes to the and we just do the exact

00:17:03,440 --> 00:17:08,780
same thing so small big uns the small

00:17:07,189 --> 00:17:12,740
numbers go on the stack big numbers go

00:17:08,780 --> 00:17:15,650
on the heap you see this is the non

00:17:12,740 --> 00:17:18,199
begins type so stroke Givens and then we

00:17:15,650 --> 00:17:21,189
just either have small one I've chosen

00:17:18,199 --> 00:17:26,420
you 32 but it could be anything I guess

00:17:21,189 --> 00:17:28,840
either this or we have a reference to a

00:17:26,420 --> 00:17:31,970
known reference to ambiguous on the heap

00:17:28,840 --> 00:17:32,390
so when it's small it just stays on the

00:17:31,970 --> 00:17:36,260
stack

00:17:32,390 --> 00:17:38,330
this thing is 16 bytes so it's still

00:17:36,260 --> 00:17:40,460
fairly begging could be optimized more I

00:17:38,330 --> 00:17:44,510
think if you use unsafe then we can go

00:17:40,460 --> 00:17:46,040
to 8 bytes for this UN type and it could

00:17:44,510 --> 00:17:48,380
be made faster the functions could be

00:17:46,040 --> 00:17:51,320
made faster as well but it works already

00:17:48,380 --> 00:17:53,540
and I think it's already an improvement

00:17:51,320 --> 00:17:55,040
in certain cases so

00:17:53,540 --> 00:18:00,410
let's give it a go I want to convince

00:17:55,040 --> 00:18:03,070
you that it's fairly easy to use so let

00:18:00,410 --> 00:18:08,330
me show you I have a program here and

00:18:03,070 --> 00:18:11,000
what was the program do the program goes

00:18:08,330 --> 00:18:13,100
through all numbers from 10 million up

00:18:11,000 --> 00:18:15,470
that funds in line down and it computes

00:18:13,100 --> 00:18:18,110
the prime factors and the algorithm

00:18:15,470 --> 00:18:20,600
itself is not super exciting but we're

00:18:18,110 --> 00:18:24,020
just gonna modify this to use humans

00:18:20,600 --> 00:18:26,540
instead so we'll start by just copying

00:18:24,020 --> 00:18:32,690
and pasting all the code and rename the

00:18:26,540 --> 00:18:38,990
functions and we're gonna call the new

00:18:32,690 --> 00:18:43,700
function in main and we need to change

00:18:38,990 --> 00:18:46,640
the types mister a few 32 okay use my

00:18:43,700 --> 00:18:51,470
new type events this example by the way

00:18:46,640 --> 00:18:54,010
is in the repository of the crate so you

00:18:51,470 --> 00:18:56,000
don't need to copy anything or whatever

00:18:54,010 --> 00:18:58,610
instead of these literals we need

00:18:56,000 --> 00:19:00,070
something you use UN's small which looks

00:18:58,610 --> 00:19:03,530
like a function call but it's a constant

00:19:00,070 --> 00:19:06,140
so it doesn't take up any time now you

00:19:03,530 --> 00:19:07,850
still see we got some compilers and this

00:19:06,140 --> 00:19:10,340
is because humans unfortunately is not

00:19:07,850 --> 00:19:13,280
copy because in some cases I can contain

00:19:10,340 --> 00:19:15,970
a reference to the heap and types like

00:19:13,280 --> 00:19:19,790
that I never copy so we're gonna do is

00:19:15,970 --> 00:19:22,010
in some cases we're gonna ask references

00:19:19,790 --> 00:19:26,020
all the function arguments were gonna

00:19:22,010 --> 00:19:29,570
make references and then we need to has

00:19:26,020 --> 00:19:33,919
references to them as well so that's

00:19:29,570 --> 00:19:37,429
here and then there's a couple more

00:19:33,919 --> 00:19:38,750
things left so any comparison needs to

00:19:37,429 --> 00:19:42,140
be between the same things are the

00:19:38,750 --> 00:19:43,520
reference and a EWTN's or a serve

00:19:42,140 --> 00:19:45,890
between a reference and orphans or

00:19:43,520 --> 00:19:50,809
humans and humans or another type of

00:19:45,890 --> 00:19:57,690
number so and first we're gonna make

00:19:50,809 --> 00:20:01,559
currents a show humans not a reference

00:19:57,690 --> 00:20:05,750
right certain persons they're here so

00:20:01,559 --> 00:20:05,750
need to read the reference here

00:20:06,350 --> 00:20:17,160
compressions already borrow so we need

00:20:11,070 --> 00:20:20,429
to be a prince here and then here we

00:20:17,160 --> 00:20:26,549
want to preserve a fresh for a factor

00:20:20,429 --> 00:20:30,980
I'm not a reference in it versus happens

00:20:26,549 --> 00:20:30,980
like it works well ten times

00:20:33,360 --> 00:20:38,690
yeah we need to take a reference because

00:20:35,400 --> 00:20:38,690
we don't want to use up the kerf answer

00:20:40,730 --> 00:20:45,530
impressive this went well so of them

00:20:53,210 --> 00:21:09,419
right I should be I should have been

00:21:07,140 --> 00:21:12,710
it's probably mixed up a star with a

00:21:09,419 --> 00:21:12,710
person or something

00:21:22,420 --> 00:21:33,860
this is the OS I'm just gonna leave it

00:21:30,370 --> 00:21:38,420
yeah okay there's something really

00:21:33,860 --> 00:21:43,010
stupid in the coach this works fine five

00:21:38,420 --> 00:21:44,600
times but okay you see the amount of

00:21:43,010 --> 00:21:46,580
changes is not so big so it's gonna be

00:21:44,600 --> 00:21:50,320
about I guess it changed in the source

00:21:46,580 --> 00:21:50,320
code and they're all super small changes

00:21:54,220 --> 00:22:00,020
the micro benchmarks I included some

00:21:56,690 --> 00:22:02,060
benchmarks in their history and the

00:22:00,020 --> 00:22:04,670
benchmarks just do the same thing so

00:22:02,060 --> 00:22:06,890
prime factorization and we do run for

00:22:04,670 --> 00:22:10,010
transition on two numbers a big number

00:22:06,890 --> 00:22:12,790
in a small number let me just show so

00:22:10,010 --> 00:22:14,900
the big number we use we do with begins

00:22:12,790 --> 00:22:16,250
and you'll see that the big number with

00:22:14,900 --> 00:22:18,500
small begins is actually a bit slower

00:22:16,250 --> 00:22:21,680
which is not so great but actually it

00:22:18,500 --> 00:22:23,900
makes sense because in the crates war

00:22:21,680 --> 00:22:26,170
begins so we always have to do is check

00:22:23,900 --> 00:22:28,580
so either it's a small one or a big one

00:22:26,170 --> 00:22:30,710
and if it's a big one then we use the

00:22:28,580 --> 00:22:33,680
begin library which is the case here so

00:22:30,710 --> 00:22:35,900
we're never gonna be faster than we're

00:22:33,680 --> 00:22:41,660
always gonna be a bit slower on big

00:22:35,900 --> 00:22:44,240
numbers but yeah you see that on small

00:22:41,660 --> 00:22:46,040
numbers though we're also slower than

00:22:44,240 --> 00:22:49,070
machine integers but of course the

00:22:46,040 --> 00:22:52,220
advantage is that here we can have any

00:22:49,070 --> 00:22:54,290
size integer so we don't suddenly crash

00:22:52,220 --> 00:22:58,280
when you're trying to factorize a big

00:22:54,290 --> 00:23:01,640
number and we're significantly faster

00:22:58,280 --> 00:23:03,470
than big uns so there's also always

00:23:01,640 --> 00:23:06,650
trade-offs but I think it can make for a

00:23:03,470 --> 00:23:08,900
nice to defaults for the project I'm

00:23:06,650 --> 00:23:10,990
trying to use this for we I really want

00:23:08,900 --> 00:23:14,360
to stay on the stack so let's just

00:23:10,990 --> 00:23:15,740
source it for me there's some

00:23:14,360 --> 00:23:23,780
interesting things I could show in the

00:23:15,740 --> 00:23:26,450
API so let's go to dos dot RS and so

00:23:23,780 --> 00:23:28,730
there's just two struts basically in the

00:23:26,450 --> 00:23:30,040
API and this for arts implements

00:23:28,730 --> 00:23:33,910
stressing from

00:23:30,040 --> 00:23:36,010
a lot of traits this would be really

00:23:33,910 --> 00:23:38,800
boring culture right I also don't want

00:23:36,010 --> 00:23:40,750
to copy and paste this so I want to do

00:23:38,800 --> 00:23:42,340
something with this there are some

00:23:40,750 --> 00:23:44,380
duplicated code between you and zan ins

00:23:42,340 --> 00:23:45,730
and I just copy and pasted that and

00:23:44,380 --> 00:23:48,760
change it myself because the thing is

00:23:45,730 --> 00:23:51,850
not worth trying to add extra layers of

00:23:48,760 --> 00:23:53,530
abstraction there but yeah for this kind

00:23:51,850 --> 00:23:56,770
of repetition it's really not worth

00:23:53,530 --> 00:23:58,600
making it could be so big I think and I

00:23:56,770 --> 00:24:00,520
think there's something reasonable that

00:23:58,600 --> 00:24:03,990
we can do so let me show you what I had

00:24:00,520 --> 00:24:06,970
here so I considered using traits

00:24:03,990 --> 00:24:07,810
programming so traits and genetic

00:24:06,970 --> 00:24:10,120
implementations

00:24:07,810 --> 00:24:12,340
I think people from Hoskin Escada would

00:24:10,120 --> 00:24:14,170
use this or would tend to this at least

00:24:12,340 --> 00:24:16,990
for the first choice but a certain wants

00:24:14,170 --> 00:24:20,710
to do it because it's a lot of thinking

00:24:16,990 --> 00:24:22,690
so you get this right you have to find

00:24:20,710 --> 00:24:24,160
the right abstractions that racism is

00:24:22,690 --> 00:24:25,840
little bit limited in a different

00:24:24,160 --> 00:24:28,270
application I've run into a brick wall

00:24:25,840 --> 00:24:30,340
somewhere like I don't start something

00:24:28,270 --> 00:24:33,130
but the type system just couldn't deal

00:24:30,340 --> 00:24:34,540
with it which was a bit of a pity and

00:24:33,130 --> 00:24:36,400
it's also hard to explain for people who

00:24:34,540 --> 00:24:39,100
might once you come to your projects so

00:24:36,400 --> 00:24:41,470
instead what I'm doing is macros by

00:24:39,100 --> 00:24:43,990
example and ever greats

00:24:41,470 --> 00:24:47,770
actually I think in general generation

00:24:43,990 --> 00:24:50,290
always works and especially in rust it's

00:24:47,770 --> 00:24:52,930
also pretty usable so the code is still

00:24:50,290 --> 00:24:54,070
fairly legible it's pretty robust

00:24:52,930 --> 00:24:56,830
everything is checked at compile time

00:24:54,070 --> 00:24:58,870
and see ID and error messages and the ID

00:24:56,830 --> 00:25:05,820
is also pretty good great you get the

00:24:58,870 --> 00:25:08,110
nice red squiggles yeah so this is a

00:25:05,820 --> 00:25:12,460
example for things that will not strike

00:25:08,110 --> 00:25:14,890
from so if you do 5 minus 3 then you

00:25:12,460 --> 00:25:16,930
should work if you do 3 minus 5 as

00:25:14,890 --> 00:25:20,170
unsigned integers that should not be

00:25:16,930 --> 00:25:23,650
have a results this is what checks of

00:25:20,170 --> 00:25:27,040
those and so there's two cases either as

00:25:23,650 --> 00:25:28,930
two small numbers and then we just I

00:25:27,040 --> 00:25:32,200
just use the checks up on the machine

00:25:28,930 --> 00:25:35,470
inertia type or you've got one I see big

00:25:32,200 --> 00:25:37,780
numbers and what I do there is I convert

00:25:35,470 --> 00:25:40,600
both to big or unless if they're not big

00:25:37,780 --> 00:25:43,000
already and I need is checked so from

00:25:40,600 --> 00:25:46,750
the big type

00:25:43,000 --> 00:25:48,820
so two cases but this has to be done for

00:25:46,750 --> 00:25:53,650
against and also projective and a couple

00:25:48,820 --> 00:25:55,240
other traits so how I would like to do

00:25:53,650 --> 00:25:58,360
it I couldn't get this to work

00:25:55,240 --> 00:26:00,360
unfortunately is with a macro like this

00:25:58,360 --> 00:26:03,880
for all typing events and ends

00:26:00,360 --> 00:26:06,520
implements today's code don't then

00:26:03,880 --> 00:26:09,820
execute it but compile it basically and

00:26:06,520 --> 00:26:12,490
I feel any wins for type here and here

00:26:09,820 --> 00:26:16,300
in some other places I tried to make

00:26:12,490 --> 00:26:18,840
this but it seems impossible to write

00:26:16,300 --> 00:26:22,660
this for all just with Mars by example

00:26:18,840 --> 00:26:25,390
because if you want to execute if you

00:26:22,660 --> 00:26:29,050
want to invoke macros you can't return

00:26:25,390 --> 00:26:30,730
the thing that goes here it seems

00:26:29,050 --> 00:26:32,860
because microbes been only expensive

00:26:30,730 --> 00:26:34,960
come on statements expressions items and

00:26:32,860 --> 00:26:39,730
in violence and said a little bit with

00:26:34,960 --> 00:26:42,100
much crushed micros and it's probably so

00:26:39,730 --> 00:26:47,770
instead I found out the following

00:26:42,100 --> 00:26:49,600
pattern is not as elegant but also we

00:26:47,770 --> 00:26:52,480
just define new macro for everything

00:26:49,600 --> 00:26:54,400
that we wire beats so here we want to

00:26:52,480 --> 00:26:57,730
repeat checked sub for integer and

00:26:54,400 --> 00:27:01,000
humans and then the variables come from

00:26:57,730 --> 00:27:03,190
macros itself and you know it's a bit

00:27:01,000 --> 00:27:06,220
less beautiful because now you have this

00:27:03,190 --> 00:27:11,920
new macro but if the macro is not

00:27:06,220 --> 00:27:14,830
exploded I think it's okay so yeah so

00:27:11,920 --> 00:27:17,590
here we just call this macro twice but

00:27:14,830 --> 00:27:20,020
then you can do other tricks so I made a

00:27:17,590 --> 00:27:22,210
little matter of cool with arcs and of

00:27:20,020 --> 00:27:24,430
course import jackets up with no bare

00:27:22,210 --> 00:27:26,830
documents but then first with humans and

00:27:24,430 --> 00:27:32,460
then within service macro cool cause

00:27:26,830 --> 00:27:35,290
this twice and then you can extend this

00:27:32,460 --> 00:27:37,420
you can add these arguments so here we

00:27:35,290 --> 00:27:38,980
have stretched from also traits that are

00:27:37,420 --> 00:27:41,200
influencing and the methods that were

00:27:38,980 --> 00:27:44,820
using so for checks of waiting to use

00:27:41,200 --> 00:27:48,400
the method so there's our variables here

00:27:44,820 --> 00:27:50,680
and so we call check traits it's wise

00:27:48,400 --> 00:27:52,810
for you and some hint and then also six

00:27:50,680 --> 00:27:57,210
more times for different traits and

00:27:52,810 --> 00:28:00,280
different methods I found it quite nice

00:27:57,210 --> 00:28:02,260
there's some other loads that you can

00:28:00,280 --> 00:28:06,430
get if you implement a lot of trades

00:28:02,260 --> 00:28:09,820
like I didn't this is great so brush

00:28:06,430 --> 00:28:11,710
your EQ with with machine flaps I wanted

00:28:09,820 --> 00:28:15,790
to do with all machine type so you wake

00:28:11,710 --> 00:28:18,250
your 16 blah blah and this is a bit much

00:28:15,790 --> 00:28:21,400
can be a bit hard to see if if you

00:28:18,250 --> 00:28:23,820
really have all the gene integers so I

00:28:21,400 --> 00:28:26,380
just show a little help limit row that

00:28:23,820 --> 00:28:29,620
practically calls code arts with all the

00:28:26,380 --> 00:28:31,930
Machine interview types and SoCo with

00:28:29,620 --> 00:28:34,780
all unsigned base types I think it's

00:28:31,930 --> 00:28:39,010
super easy to read and my programming

00:28:34,780 --> 00:28:41,220
can be really nice I found in that's my

00:28:39,010 --> 00:28:43,990
confusion

00:28:41,220 --> 00:28:45,880
obviously precision integers are quite

00:28:43,990 --> 00:28:48,580
fast and easy unless you want to do it

00:28:45,880 --> 00:28:50,110
in a talk and you can practice his life

00:28:48,580 --> 00:28:51,010
coding as as often as you want but

00:28:50,110 --> 00:28:54,010
you're still going to get everyone in

00:28:51,010 --> 00:28:56,440
this work that I find out easy in

00:28:54,010 --> 00:28:58,150
practice unfortunate not copy so you do

00:28:56,440 --> 00:29:01,270
have to do some referencing and Ronen

00:28:58,150 --> 00:29:03,700
sometimes code generations can be decent

00:29:01,270 --> 00:29:05,260
at least early sometimes to abstractions

00:29:03,700 --> 00:29:08,020
did not just see I think their

00:29:05,260 --> 00:29:10,660
importance free ecosystem for your API

00:29:08,020 --> 00:29:13,230
is that just leads a better quality code

00:29:10,660 --> 00:29:16,210
it's my version

00:29:13,230 --> 00:29:19,450
thanks to begins because they really did

00:29:16,210 --> 00:29:20,710
our work again and thanks everyone in

00:29:19,450 --> 00:29:24,030
the community for making the community

00:29:20,710 --> 00:29:30,030
so nice I'm having a good time addressed

00:29:24,030 --> 00:29:33,370
questions alright thank you very much

00:29:30,030 --> 00:29:38,440
since you can't hear the class there's

00:29:33,370 --> 00:29:41,080
clapping on myself and real quick before

00:29:38,440 --> 00:29:43,960
we get to the questions one note if you

00:29:41,080 --> 00:29:45,790
do not want to be recorded then make

00:29:43,960 --> 00:29:48,490
sure that your video is off otherwise

00:29:45,790 --> 00:29:50,230
this is recorded and you will be seen in

00:29:48,490 --> 00:29:54,100
the video so please make sure to every

00:29:50,230 --> 00:29:55,840
everybody in the in the audience to turn

00:29:54,100 --> 00:29:59,680
off your video unless you want to be

00:29:55,840 --> 00:30:02,740
recorded for all of time and clapping is

00:29:59,680 --> 00:30:06,070
now happening inside of the zoom Jack is

00:30:02,740 --> 00:30:08,260
constant lots of clapping emojis and

00:30:06,070 --> 00:30:11,230
so we have one question here from

00:30:08,260 --> 00:30:14,350
Matthias who is asking since big empties

00:30:11,230 --> 00:30:18,220
is Veck internally why not replace the

00:30:14,350 --> 00:30:18,909
internal Veck with small Beck that's a

00:30:18,220 --> 00:30:22,419
good idea

00:30:18,909 --> 00:30:24,039
I didn't consider that and let's see how

00:30:22,419 --> 00:30:27,639
big would that be so in the small case

00:30:24,039 --> 00:30:30,700
then you would have you 32

00:30:27,639 --> 00:30:33,070
I guess 1u 32 because that will be the

00:30:30,700 --> 00:30:36,669
length of your small deck and then you

00:30:33,070 --> 00:30:38,440
want their capacity as well so it's a

00:30:36,669 --> 00:30:40,929
good idea I think you would still end up

00:30:38,440 --> 00:30:46,899
with 16 bytes with any of them since it

00:30:40,929 --> 00:30:55,539
implementation yeah 16 bytes I guess I

00:30:46,899 --> 00:30:57,039
would have wrote yeah I I don't know the

00:30:55,539 --> 00:31:00,490
impression that it would be equally fast

00:30:57,039 --> 00:31:02,649
but maybe it would have been yeah I

00:31:00,490 --> 00:31:03,610
didn't want to clone a fork number

00:31:02,649 --> 00:31:09,130
against anyway because that's

00:31:03,610 --> 00:31:13,200
complicated code so yeah it's a good

00:31:09,130 --> 00:31:15,940
idea we should try that cool then some

00:31:13,200 --> 00:31:19,059
collaboration possibility for people on

00:31:15,940 --> 00:31:21,070
a teacher definitely

00:31:19,059 --> 00:31:26,440
let's see Bastian did you see any more

00:31:21,070 --> 00:31:28,630
questions from people yes I think the

00:31:26,440 --> 00:31:30,940
only other there was a comment about how

00:31:28,630 --> 00:31:34,809
this might be an interesting optional

00:31:30,940 --> 00:31:36,760
feature for Cindy Jason perhaps the

00:31:34,809 --> 00:31:38,529
those who are working on 70 Jason

00:31:36,760 --> 00:31:42,039
library might be interested in taking

00:31:38,529 --> 00:31:43,120
advantage of of this functionality so

00:31:42,039 --> 00:31:46,720
that that's a collab that would

00:31:43,120 --> 00:31:47,919
definitely be really cool all right well

00:31:46,720 --> 00:31:50,080
thank you very much

00:31:47,919 --> 00:31:54,639
Bram freer for your talk that was very

00:31:50,080 --> 00:31:56,350
interesting appreciate business alright

00:31:54,639 --> 00:31:59,289
and next we have Heinz who will be

00:31:56,350 --> 00:32:02,260
speaking next so we're gonna switch over

00:31:59,289 --> 00:32:05,710
and then after Heinz is done then we

00:32:02,260 --> 00:32:07,600
will be taking a 15-minute break

00:32:05,710 --> 00:32:09,610
and again for those who do not want to

00:32:07,600 --> 00:32:13,240
be recorded make sure to turn off your

00:32:09,610 --> 00:32:15,250
camera alright take it away okay first

00:32:13,240 --> 00:32:17,549
of all yes the same to Jason people will

00:32:15,250 --> 00:32:21,210
definitely consider that and do that

00:32:17,549 --> 00:32:25,110
um so Thank You Brad that's going to be

00:32:21,210 --> 00:32:27,179
awesome okay let's get started I'm going

00:32:25,110 --> 00:32:30,149
to talk about tremor tremor is something

00:32:27,179 --> 00:32:32,970
we builded Wayfair and killed a thousand

00:32:30,149 --> 00:32:35,909
and more course was that in the cloud so

00:32:32,970 --> 00:32:42,509
I think we can say we are saving the

00:32:35,909 --> 00:32:44,249
planet one course anyway the agenda even

00:32:42,509 --> 00:32:46,470
so it's only 20 minutes I'm German I

00:32:44,249 --> 00:32:49,289
like to have an agenda I make one when I

00:32:46,470 --> 00:32:51,929
go shopping and so we'll start was a bit

00:32:49,289 --> 00:32:53,730
about ourselves who we are what we do

00:32:51,929 --> 00:32:57,929
what wafer is because I guarantee no one

00:32:53,730 --> 00:33:00,899
here has here before what tremor is and

00:32:57,929 --> 00:33:03,239
then we will drive into one part of

00:33:00,899 --> 00:33:05,759
tremor because I learned that the talk

00:33:03,239 --> 00:33:08,940
is 20 minutes not an hour and 20 minutes

00:33:05,759 --> 00:33:10,139
I'm just kidding and because it's pretty

00:33:08,940 --> 00:33:12,659
big there's a lot to talk about what

00:33:10,139 --> 00:33:14,879
will focus on that and at the end we

00:33:12,659 --> 00:33:16,649
want to give a shout out to some open

00:33:14,879 --> 00:33:19,679
source stuff we have been using because

00:33:16,649 --> 00:33:23,129
well the rest community is awesome when

00:33:19,679 --> 00:33:25,379
it comes to that anyway what is Wayfarer

00:33:23,129 --> 00:33:28,889
Wayfarer sells rocks and couches so it

00:33:25,379 --> 00:33:32,100
is not a IT company in the sense of it

00:33:28,889 --> 00:33:34,529
so benders that shifts our perspective

00:33:32,100 --> 00:33:36,840
as developers because we develop for a

00:33:34,529 --> 00:33:39,659
production meet and not for something we

00:33:36,840 --> 00:33:44,820
want to sell later and it is pretty

00:33:39,659 --> 00:33:49,460
large model Germany but in the US and it

00:33:44,820 --> 00:33:52,559
has offices in the US the UK and Germany

00:33:49,460 --> 00:33:55,080
and also sells stuff there so you want

00:33:52,559 --> 00:33:58,080
to go buy a rack now that we all are at

00:33:55,080 --> 00:34:00,559
home go buy a rack and we have about a

00:33:58,080 --> 00:34:03,869
thousand people working in Berlin and

00:34:00,559 --> 00:34:06,809
25,000 worldwide between engineers

00:34:03,869 --> 00:34:09,450
marketing sales people in warehouses

00:34:06,809 --> 00:34:12,569
people deliver and what not so not a

00:34:09,450 --> 00:34:16,760
small company and as a result we do have

00:34:12,569 --> 00:34:19,230
a few computers running and doing stuff

00:34:16,760 --> 00:34:21,059
who are we as a team we are a small team

00:34:19,230 --> 00:34:22,740
we had two people in Berlin that is that

00:34:21,059 --> 00:34:26,520
he hangs around in the chat say hi to

00:34:22,740 --> 00:34:29,250
him and in Berlin with me and we have a

00:34:26,520 --> 00:34:30,960
new in Boston he's also in the chat say

00:34:29,250 --> 00:34:33,830
hi so

00:34:30,960 --> 00:34:36,690
represents our Boston part of the team

00:34:33,830 --> 00:34:39,629
we do system engineering it wafer is the

00:34:36,690 --> 00:34:40,800
first team doing that and what we've

00:34:39,629 --> 00:34:43,859
been building about the last

00:34:40,800 --> 00:34:45,750
year-and-a-half give or take

00:34:43,859 --> 00:34:48,750
em is trauma water I'm going to talk

00:34:45,750 --> 00:34:51,480
about today and and yes we do sometimes

00:34:48,750 --> 00:34:53,849
talk about it if you're curious we have

00:34:51,480 --> 00:34:54,899
all Twitter accounts well battle had me

00:34:53,849 --> 00:34:56,369
have Twitter accounts of the new

00:34:54,899 --> 00:34:59,130
perfuses to be on Twitter

00:34:56,369 --> 00:35:02,460
um but who knows perhaps that account

00:34:59,130 --> 00:35:04,320
will exist eventually um go say hi

00:35:02,460 --> 00:35:06,030
we also have one for tremor that is at

00:35:04,320 --> 00:35:09,630
the end so you can copy it because we

00:35:06,030 --> 00:35:11,849
want to you all to remember em so what

00:35:09,630 --> 00:35:14,730
is tremor and tremor is an event

00:35:11,849 --> 00:35:16,849
processing engine and it is also an ETL

00:35:14,730 --> 00:35:20,880
language it is also a query language

00:35:16,849 --> 00:35:23,820
then we have replaced locks - and I am

00:35:20,880 --> 00:35:26,400
sure a lot of you are familiar with it

00:35:23,820 --> 00:35:29,520
it's Java thing doing lots viously with

00:35:26,400 --> 00:35:34,410
elasticsearch and friends in waving and

00:35:29,520 --> 00:35:36,530
we have replaced Telegraph the influx

00:35:34,410 --> 00:35:39,140
thing that does the last mile between

00:35:36,530 --> 00:35:43,740
our case Kafka and influx to be

00:35:39,140 --> 00:35:45,869
completely with tremor we're now

00:35:43,740 --> 00:35:48,930
starting to get integrated it with

00:35:45,869 --> 00:35:51,150
kubernetes so there is more stuff to be

00:35:48,930 --> 00:35:52,890
going and I forgot to put it on a slide

00:35:51,150 --> 00:35:56,790
or delete at the slide this morning when

00:35:52,890 --> 00:36:01,170
I read at the talk we was this rolling

00:35:56,790 --> 00:36:04,410
out we saw saved about to 3,000 cores

00:36:01,170 --> 00:36:07,020
and went to reduction on infrastructure

00:36:04,410 --> 00:36:09,630
in this realm for nearly a factor of 10

00:36:07,020 --> 00:36:11,690
and so for every 10 bucks that were

00:36:09,630 --> 00:36:15,930
there now there as well which is nice

00:36:11,690 --> 00:36:17,550
okay we'll start with to get the

00:36:15,930 --> 00:36:19,800
understanding of the different things

00:36:17,550 --> 00:36:22,890
and why we are doing what we are doing a

00:36:19,800 --> 00:36:25,470
bit of cartography about event

00:36:22,890 --> 00:36:26,730
processing systems please note this is

00:36:25,470 --> 00:36:28,770
not scientifically accurate

00:36:26,730 --> 00:36:31,349
there is no islands in event presenting

00:36:28,770 --> 00:36:33,750
that just programs and but this makes it

00:36:31,349 --> 00:36:36,240
really fun to explain and don't come

00:36:33,750 --> 00:36:37,230
near me with facts about them this is

00:36:36,240 --> 00:36:39,420
going to be funny

00:36:37,230 --> 00:36:41,839
I hope or really embarrassing one of

00:36:39,420 --> 00:36:43,960
those two but stay away with facts and

00:36:41,839 --> 00:36:46,240
don't take it as

00:36:43,960 --> 00:36:50,020
bad take and I know it likes nuances

00:36:46,240 --> 00:36:51,849
spots well here we go and so first group

00:36:50,020 --> 00:36:54,160
of event processing systems is the

00:36:51,849 --> 00:36:57,369
you're going to write some effing Java

00:36:54,160 --> 00:37:01,300
if you want to are not island that would

00:36:57,369 --> 00:37:04,570
be systems like spark or Fink and so big

00:37:01,300 --> 00:37:07,060
big data systems mostly and they are

00:37:04,570 --> 00:37:09,609
used by developers who know how to write

00:37:07,060 --> 00:37:12,730
code who like to get their hands dirty

00:37:09,609 --> 00:37:16,690
and write low level logic in Java or

00:37:12,730 --> 00:37:19,390
equal languages the second is the

00:37:16,690 --> 00:37:22,510
archipelago's off let's cobble together

00:37:19,390 --> 00:37:24,580
transformations effectively that is log

00:37:22,510 --> 00:37:26,380
stash and friends where you just have a

00:37:24,580 --> 00:37:28,800
few building blocks that are programmed

00:37:26,380 --> 00:37:32,910
by the team that builds log stash and

00:37:28,800 --> 00:37:35,830
you configure them you change them in a

00:37:32,910 --> 00:37:37,599
well in whatever fashion you want to do

00:37:35,830 --> 00:37:39,700
what you want that is usually used by

00:37:37,599 --> 00:37:42,040
operational teams to just need to get

00:37:39,700 --> 00:37:43,900
 done which is fair shout out to

00:37:42,040 --> 00:37:46,240
them there at the front lines we as

00:37:43,900 --> 00:37:47,830
developers have the happy job and so

00:37:46,240 --> 00:37:49,660
they like to get their stuff done it is

00:37:47,830 --> 00:37:53,560
easy to configure but it gets unwieldy

00:37:49,660 --> 00:37:56,349
when it gets big and last but not least

00:37:53,560 --> 00:37:59,109
in this little cat ography exercise we

00:37:56,349 --> 00:38:03,609
have the make your language at all this

00:37:59,109 --> 00:38:05,710
is where we came from with tremor it

00:38:03,609 --> 00:38:08,680
consists a bit between the two others

00:38:05,710 --> 00:38:11,980
well it takes some of one some of the

00:38:08,680 --> 00:38:14,290
others and it comes at the cost of

00:38:11,980 --> 00:38:18,940
having and was mentioned before a rather

00:38:14,290 --> 00:38:21,190
big runtime that allows you to do most

00:38:18,940 --> 00:38:23,890
of the logic you'd usually have to write

00:38:21,190 --> 00:38:26,140
in a programming language like Java and

00:38:23,890 --> 00:38:29,500
in a scripting language is easy to learn

00:38:26,140 --> 00:38:32,140
for operational folks and not so heavy

00:38:29,500 --> 00:38:36,130
not so resource intensive as something

00:38:32,140 --> 00:38:38,530
heavyweight so that's it for the little

00:38:36,130 --> 00:38:41,380
exercise and geography for event

00:38:38,530 --> 00:38:43,480
processing systems and let's talk a bit

00:38:41,380 --> 00:38:45,099
about tremor script because well we

00:38:43,480 --> 00:38:48,130
talked about scripting so this is the

00:38:45,099 --> 00:38:50,920
natural conclusion of that and tremor

00:38:48,130 --> 00:38:54,070
script is a ETL language so basically

00:38:50,920 --> 00:38:56,470
what happens was locks in wafer is we

00:38:54,070 --> 00:38:57,609
parse them we transform them training

00:38:56,470 --> 00:38:59,710
fields

00:38:57,609 --> 00:39:02,680
changing date hand them the filters some

00:38:59,710 --> 00:39:04,239
out we care about sanitize them and it

00:39:02,680 --> 00:39:09,069
is mostly and I'm embarrassed to say

00:39:04,239 --> 00:39:12,009
that Jason s data not not a fan of Jason

00:39:09,069 --> 00:39:17,289
but it is well we're living in so it's

00:39:12,009 --> 00:39:19,089
active it is not a language we love in

00:39:17,289 --> 00:39:20,980
the sense of that we didn't design it to

00:39:19,089 --> 00:39:22,930
be a beautiful language we designed it

00:39:20,980 --> 00:39:25,269
to be a language which gets the stuff

00:39:22,930 --> 00:39:27,849
done there operational teams need to get

00:39:25,269 --> 00:39:30,369
done and and sometimes those two things

00:39:27,849 --> 00:39:31,690
are at odds as a programmer you want

00:39:30,369 --> 00:39:33,730
some beauty in the language as a

00:39:31,690 --> 00:39:36,910
rational person you just wanted to get

00:39:33,730 --> 00:39:39,970
it done so we came from that aside on it

00:39:36,910 --> 00:39:43,509
it is heavily influenced by rust for

00:39:39,970 --> 00:39:45,880
obvious reasons and by Erlang Sims both

00:39:43,509 --> 00:39:49,410
style and me have been happier line

00:39:45,880 --> 00:39:53,680
users for years and we try to spread the

00:39:49,410 --> 00:39:55,720
Erlang goodness wherever we can last but

00:39:53,680 --> 00:39:57,940
not least there's a good pinch of what

00:39:55,720 --> 00:39:59,710
was needed in there so we looked at all

00:39:57,940 --> 00:40:01,900
that we had where we had to pick fortune

00:39:59,710 --> 00:40:03,999
to being able to look at thousands of

00:40:01,900 --> 00:40:06,880
nodes whose configurations and see how

00:40:03,999 --> 00:40:08,650
they are used and how you can making how

00:40:06,880 --> 00:40:11,380
you can make some kind of this more

00:40:08,650 --> 00:40:13,210
efficient more easy to use more friendly

00:40:11,380 --> 00:40:19,720
for the operator while also making it

00:40:13,210 --> 00:40:22,119
fast so well let's jump into it we are

00:40:19,720 --> 00:40:24,819
going to release the version 8 of tremor

00:40:22,119 --> 00:40:28,180
and we decided we are going to do that

00:40:24,819 --> 00:40:30,549
over the last few days and got it nearly

00:40:28,180 --> 00:40:31,869
ready today so that's why I rewrote the

00:40:30,549 --> 00:40:34,269
entire talking I was going to talk about

00:40:31,869 --> 00:40:36,640
something slightly different but no we

00:40:34,269 --> 00:40:41,289
are going to talk about the o8 release

00:40:36,640 --> 00:40:44,259
and partially because we are following

00:40:41,289 --> 00:40:46,119
an RFC driven process or try to follow

00:40:44,259 --> 00:40:48,460
an RC driven process and this is in the

00:40:46,119 --> 00:40:50,049
last stretch of it so if any of you is

00:40:48,460 --> 00:40:51,999
interested after this to give their

00:40:50,049 --> 00:40:56,109
commands and tell us what we did wrong

00:40:51,999 --> 00:40:58,450
and please do so I'm going to share a

00:40:56,109 --> 00:41:01,180
bit about what is new in the o8 release

00:40:58,450 --> 00:41:04,390
and we are going to introduce new

00:41:01,180 --> 00:41:08,170
modules so logical encapsulation of code

00:41:04,390 --> 00:41:11,200
we are going to use use to introduce a

00:41:08,170 --> 00:41:13,990
use keyword which allows us to

00:41:11,200 --> 00:41:15,790
include those modules from different

00:41:13,990 --> 00:41:19,930
files and make structuring the code

00:41:15,790 --> 00:41:22,420
easier I suspect most of you will see

00:41:19,930 --> 00:41:24,310
the rust influence here and we literally

00:41:22,420 --> 00:41:29,740
stole the keywords I hope we're not

00:41:24,310 --> 00:41:31,990
going to be sued by Mozilla and we added

00:41:29,740 --> 00:41:34,000
functions so it is possible to write

00:41:31,990 --> 00:41:37,300
your own functions with logic in them

00:41:34,000 --> 00:41:42,430
and intrinsic stew hookup rust functions

00:41:37,300 --> 00:41:44,579
easily over this new function module so

00:41:42,430 --> 00:41:47,859
let's look at the components of those

00:41:44,579 --> 00:41:51,099
and first of all modules there I would

00:41:47,859 --> 00:41:54,579
say while probably the most powerful of

00:41:51,099 --> 00:41:56,260
the set also the most boring and they

00:41:54,579 --> 00:41:58,270
just encapsulate you can have your

00:41:56,260 --> 00:42:01,510
module and you see it here it's called

00:41:58,270 --> 00:42:04,180
mod my mod with and we have a constant

00:42:01,510 --> 00:42:06,220
defiant image which is the answer 42 and

00:42:04,180 --> 00:42:09,550
we have a function defined in it which

00:42:06,220 --> 00:42:11,170
takes two arguments a and B and adds

00:42:09,550 --> 00:42:14,200
them together functions called add for

00:42:11,170 --> 00:42:16,270
obvious reasons we then can call this

00:42:14,200 --> 00:42:18,550
function outside of the module by

00:42:16,270 --> 00:42:22,060
prefixing it with the module double

00:42:18,550 --> 00:42:26,520
colon the name of the function my module

00:42:22,060 --> 00:42:28,690
answer and -19 again it is roughly

00:42:26,520 --> 00:42:31,900
visible that there's a lot of rust

00:42:28,690 --> 00:42:34,980
influence there and with a bit of Erlang

00:42:31,900 --> 00:42:37,630
mixed in with waste and and and keywords

00:42:34,980 --> 00:42:39,310
so they can be nested if you want as you

00:42:37,630 --> 00:42:41,829
can define one module in another module

00:42:39,310 --> 00:42:43,510
in another module and get the nested

00:42:41,829 --> 00:42:45,670
structure pretty much like you can do in

00:42:43,510 --> 00:42:47,589
rust something you can't do in Erlang by

00:42:45,670 --> 00:42:52,589
the way which you always missed so we

00:42:47,589 --> 00:42:55,630
made sure we get it in and use clause

00:42:52,589 --> 00:42:59,589
which you can see it on the right use

00:42:55,630 --> 00:43:02,890
food the little box with the code above

00:42:59,589 --> 00:43:05,140
it is the content of food and so the

00:43:02,890 --> 00:43:08,800
file food of strimer includes constants

00:43:05,140 --> 00:43:11,859
not equals badger the second file the

00:43:08,800 --> 00:43:14,380
one we are calling is is using use food

00:43:11,859 --> 00:43:16,390
to include that file and then it matches

00:43:14,380 --> 00:43:19,710
on the event we own event processing

00:43:16,390 --> 00:43:24,339
engine all our scripts handled in event

00:43:19,710 --> 00:43:25,470
and if the event is a empty struct so in

00:43:24,339 --> 00:43:29,550
Jason and

00:43:25,470 --> 00:43:32,790
and we output the strengths not followed

00:43:29,550 --> 00:43:35,040
but by whatever was in the constants not

00:43:32,790 --> 00:43:38,850
in the module foo in this case would be

00:43:35,040 --> 00:43:41,490
better so we get a slot badger we're

00:43:38,850 --> 00:43:44,310
doing that via pre-processing so we

00:43:41,490 --> 00:43:46,050
don't cache modules in the sensor that

00:43:44,310 --> 00:43:47,760
we have multiple source files at the end

00:43:46,050 --> 00:43:50,700
that get linked together because it's an

00:43:47,760 --> 00:43:53,670
interpreter not a compiler so we just

00:43:50,700 --> 00:43:56,280
concatenate them as a preprocessor step

00:43:53,670 --> 00:43:59,760
and add them together and to illustrate

00:43:56,280 --> 00:44:03,510
that at the bottom in the big box you

00:43:59,760 --> 00:44:06,300
can see how the preprocessor output what

00:44:03,510 --> 00:44:08,820
looked like and those files are taken

00:44:06,300 --> 00:44:14,460
for the observant amongst you from a

00:44:08,820 --> 00:44:15,720
test called PP underscore Ness 0 and we

00:44:14,460 --> 00:44:18,810
have a line directive which is a

00:44:15,720 --> 00:44:20,310
compiler hint later on that tells us we

00:44:18,810 --> 00:44:22,350
are in this file at this line that

00:44:20,310 --> 00:44:26,340
allows us to have error numbers and line

00:44:22,350 --> 00:44:29,370
numbers and errors and then the module

00:44:26,340 --> 00:44:32,250
foo which we included gets put into a

00:44:29,370 --> 00:44:34,890
module clause so module foo with and so

00:44:32,250 --> 00:44:37,770
on the content get added constants not

00:44:34,890 --> 00:44:40,110
equals better and we closed the module

00:44:37,770 --> 00:44:41,550
we created with a semicolon and after

00:44:40,110 --> 00:44:44,430
that we have another line directive

00:44:41,550 --> 00:44:47,130
which now tells the lexer and parser and

00:44:44,430 --> 00:44:50,160
compiler later on that we are now even

00:44:47,130 --> 00:44:53,460
so technically in line 5 would be in

00:44:50,160 --> 00:44:55,110
line 2 off the original file so if we

00:44:53,460 --> 00:44:56,900
get errors it can point in the right

00:44:55,110 --> 00:45:00,930
direction

00:44:56,900 --> 00:45:03,810
ok so much for use let's go on and look

00:45:00,930 --> 00:45:06,720
at functions where it where it this is

00:45:03,810 --> 00:45:09,780
where it becomes interesting

00:45:06,720 --> 00:45:13,170
the simple most function is side of at

00:45:09,780 --> 00:45:16,980
is just function a name a list of

00:45:13,170 --> 00:45:20,190
arguments with a function body and an

00:45:16,980 --> 00:45:24,030
end so it's not if I here takes a

00:45:20,190 --> 00:45:26,100
variable probably a string and creates a

00:45:24,030 --> 00:45:30,660
new string with snot followed by

00:45:26,100 --> 00:45:32,790
whatever you passed in so this allows

00:45:30,660 --> 00:45:35,790
you already to define a lot of small

00:45:32,790 --> 00:45:39,070
algorithms internally and abstract the

00:45:35,790 --> 00:45:42,190
way part of the

00:45:39,070 --> 00:45:45,070
of your code into small functions you

00:45:42,190 --> 00:45:47,890
outsource to a module somewhere and go

00:45:45,070 --> 00:45:50,020
in and reuse this whole was a bit of

00:45:47,890 --> 00:45:52,150
background story this whole thought

00:45:50,020 --> 00:45:53,860
experiment aside of you wanted functions

00:45:52,150 --> 00:45:55,350
but we don't do what we want we do what

00:45:53,860 --> 00:45:58,180
we must

00:45:55,350 --> 00:46:00,430
beside us wanting them we found that a

00:45:58,180 --> 00:46:04,420
very common pattern for the users we're

00:46:00,430 --> 00:46:08,110
outsourcing parts of code into templates

00:46:04,420 --> 00:46:10,870
for the configuration management system

00:46:08,110 --> 00:46:13,990
and then cobbling them together inside a

00:46:10,870 --> 00:46:15,280
output template at the end this is

00:46:13,990 --> 00:46:16,630
horrible there was something in

00:46:15,280 --> 00:46:18,430
programming that solved this problem

00:46:16,630 --> 00:46:20,820
before which is modularity so we got

00:46:18,430 --> 00:46:24,040
functions and modules out of that and

00:46:20,820 --> 00:46:26,830
anyway we take parameters we combine

00:46:24,040 --> 00:46:29,350
them so we call this notify function we

00:46:26,830 --> 00:46:34,360
define was better and the result of that

00:46:29,350 --> 00:46:38,110
is not better and but that is not all

00:46:34,360 --> 00:46:40,440
and we thought well we like Erlang and

00:46:38,110 --> 00:46:44,260
Erlang has this wonderful feature of

00:46:40,440 --> 00:46:47,590
allowing you to write a function with

00:46:44,260 --> 00:46:49,960
patterns in the argument definition so

00:46:47,590 --> 00:46:52,540
you can execute different kinds of

00:46:49,960 --> 00:46:55,600
bodies based on the arguments that are

00:46:52,540 --> 00:46:58,090
passed to a function something which

00:46:55,600 --> 00:47:00,760
would be really lovable and rust and I

00:46:58,090 --> 00:47:04,630
saw the yacht Josh earlier tweeting

00:47:00,760 --> 00:47:06,070
about something like that with enums and

00:47:04,630 --> 00:47:06,700
I hope that gets interests because that

00:47:06,070 --> 00:47:10,240
would be awesome

00:47:06,700 --> 00:47:15,610
anyway I digress and we are talking

00:47:10,240 --> 00:47:18,940
about functions with patterns so we use

00:47:15,610 --> 00:47:22,060
case for patterns that is a Erlang ism

00:47:18,940 --> 00:47:24,700
in a way so it changed from function

00:47:22,060 --> 00:47:27,070
named arguments or width to function

00:47:24,700 --> 00:47:30,040
named arguments off and then we have a

00:47:27,070 --> 00:47:32,170
set of cases and a default case of none

00:47:30,040 --> 00:47:35,740
of them hit and so the first case

00:47:32,170 --> 00:47:39,130
compares if the past in argument was a

00:47:35,740 --> 00:47:41,770
string was a content of better if yes it

00:47:39,130 --> 00:47:44,530
returns not bad right hell yeah

00:47:41,770 --> 00:47:47,380
the second one is what we call an

00:47:44,530 --> 00:47:50,440
extractor so since extracting data from

00:47:47,380 --> 00:47:52,869
strings is a incredibly common pattern

00:47:50,440 --> 00:47:55,180
in operational use of the

00:47:52,869 --> 00:47:57,220
engines and we made that a first-level

00:47:55,180 --> 00:47:59,680
construct and here we are using the

00:47:57,220 --> 00:48:02,890
extra JSON extract of JSON pipe pipe

00:47:59,680 --> 00:48:06,609
which looks if the string is a valid

00:48:02,890 --> 00:48:08,470
JSON and then creates the jason out it

00:48:06,609 --> 00:48:12,220
out of it

00:48:08,470 --> 00:48:15,819
so then after that if it was a jason we

00:48:12,220 --> 00:48:18,220
have an object and we set the sub key

00:48:15,819 --> 00:48:22,690
slot of the object to true and return

00:48:18,220 --> 00:48:25,509
the new modified object the third case

00:48:22,690 --> 00:48:28,869
in this function would be looking at the

00:48:25,509 --> 00:48:31,359
input s and if it is a string then

00:48:28,869 --> 00:48:34,180
returns not followed by the string the

00:48:31,359 --> 00:48:36,940
same as the function before and now if

00:48:34,180 --> 00:48:38,680
none of those caged cases matched since

00:48:36,940 --> 00:48:40,329
it is an expression based language and

00:48:38,680 --> 00:48:42,609
we always have so we have to return

00:48:40,329 --> 00:48:45,430
something we have a default case and

00:48:42,609 --> 00:48:47,789
that just tells you like well you call

00:48:45,430 --> 00:48:51,849
that with something that is not working

00:48:47,789 --> 00:48:54,220
so putting in a few examples here that

00:48:51,849 --> 00:48:56,230
would be notified from bedre and we get

00:48:54,220 --> 00:48:57,970
the expected hell yeah it's not if I

00:48:56,230 --> 00:49:01,509
have a horse which could a snot horse

00:48:57,970 --> 00:49:04,660
snow defy of 42 which falls into the

00:49:01,509 --> 00:49:07,450
default well we get the error we defined

00:49:04,660 --> 00:49:11,529
and last but not least modify with a

00:49:07,450 --> 00:49:15,369
jason that is badger 42 returns a purse

00:49:11,529 --> 00:49:19,359
jason of the type of an object or record

00:49:15,369 --> 00:49:21,970
in tremor with two keys one is bedre 42

00:49:19,359 --> 00:49:25,720
which was one we had before and the keys

00:49:21,970 --> 00:49:31,809
not because it's notify set to true so

00:49:25,720 --> 00:49:35,019
so much about the matching on functions

00:49:31,809 --> 00:49:38,829
and since there wasn't enough we figured

00:49:35,019 --> 00:49:42,039
we add variable arcs so functions you

00:49:38,829 --> 00:49:44,499
can pass a arbitrary number of arguments

00:49:42,039 --> 00:49:47,200
sometimes you really need that think

00:49:44,499 --> 00:49:50,499
about the print line macro we have and

00:49:47,200 --> 00:49:57,220
rust and that well that has to be a

00:49:50,499 --> 00:50:00,249
macro that can't be a function so my

00:49:57,220 --> 00:50:03,279
brain is breaking here we define a

00:50:00,249 --> 00:50:05,950
functions not all the things three dots

00:50:03,279 --> 00:50:06,670
for this as bar arcs you could prefix it

00:50:05,950 --> 00:50:08,950
with a number

00:50:06,670 --> 00:50:11,290
of given arguments you always expects a

00:50:08,950 --> 00:50:14,950
minimum number of arguments and in this

00:50:11,290 --> 00:50:18,670
case we don't and we simply have snot

00:50:14,950 --> 00:50:20,830
and then followed by the argument so if

00:50:18,670 --> 00:50:23,740
we call snot all the things with snore

00:50:20,830 --> 00:50:26,140
as three arguments bed jaw horse and cat

00:50:23,740 --> 00:50:30,070
we get snot bad just not horse and snot

00:50:26,140 --> 00:50:31,780
cat out of it this can be quite powerful

00:50:30,070 --> 00:50:34,210
in itself if you're going to write more

00:50:31,780 --> 00:50:37,680
complex functions and look at the number

00:50:34,210 --> 00:50:40,570
of arguments and what you got passed in

00:50:37,680 --> 00:50:42,910
last but not least Sims know no

00:50:40,570 --> 00:50:46,560
functional language or semi functional

00:50:42,910 --> 00:50:49,450
language is complete without recursion

00:50:46,560 --> 00:50:52,390
we added recursion so you can write

00:50:49,450 --> 00:50:54,520
functions that call themselves since

00:50:52,390 --> 00:50:58,800
performance is something we really care

00:50:54,520 --> 00:51:01,630
about and we enforce tail recursion by

00:50:58,800 --> 00:51:05,110
using a special keyword for the

00:51:01,630 --> 00:51:07,810
recursion which we call recur thank you

00:51:05,110 --> 00:51:09,670
closure or someone remembers it and pass

00:51:07,810 --> 00:51:12,730
it the arguments if that is not called

00:51:09,670 --> 00:51:14,320
somewhere in the tail then well it will

00:51:12,730 --> 00:51:15,910
error during compile time I'll tell you

00:51:14,320 --> 00:51:18,880
you can't use recursion that was not

00:51:15,910 --> 00:51:20,830
tail recursion so here we have an

00:51:18,880 --> 00:51:24,280
example of the implementation of the

00:51:20,830 --> 00:51:27,940
Fibonacci sequence and we write two

00:51:24,280 --> 00:51:30,730
functions here one is Fibonacci of n

00:51:27,940 --> 00:51:35,020
which calls Fibonacci underscore of zero

00:51:30,730 --> 00:51:36,820
one N and then the next one have been

00:51:35,020 --> 00:51:38,320
actually underscore it has to define

00:51:36,820 --> 00:51:40,170
first because of the wise it doesn't

00:51:38,320 --> 00:51:44,650
know what to call which prevents

00:51:40,170 --> 00:51:48,100
trampoline like recursion so it has to

00:51:44,650 --> 00:51:51,550
be fine first and we look if n worse was

00:51:48,100 --> 00:51:54,580
larger than zero we call recursion with

00:51:51,550 --> 00:51:57,940
well the math behind it if it was larger

00:51:54,580 --> 00:52:02,080
than zero we return a and are done so if

00:51:57,940 --> 00:52:02,800
we one run this in a comprehension not a

00:52:02,080 --> 00:52:06,700
loop again

00:52:02,800 --> 00:52:08,770
nothing infinite can happen here so we

00:52:06,700 --> 00:52:11,290
run it over a range of the numbers of

00:52:08,770 --> 00:52:15,850
zero to ten and call Fibonacci of them

00:52:11,290 --> 00:52:20,170
we get the array 0 1 2 3 5 8 13 21 and

00:52:15,850 --> 00:52:20,430
30 for the recursion depth is limited

00:52:20,170 --> 00:52:22,920
you

00:52:20,430 --> 00:52:24,930
so we do not consume extra stake for

00:52:22,920 --> 00:52:27,690
them because we want to enforce that

00:52:24,930 --> 00:52:29,300
every event that ever goes into the

00:52:27,690 --> 00:52:31,890
streamer script engine is

00:52:29,300 --> 00:52:33,210
deterministically to guarantee to go out

00:52:31,890 --> 00:52:35,510
and not block forever

00:52:33,210 --> 00:52:39,360
so the default we set it to is I believe

00:52:35,510 --> 00:52:44,580
8000 but that might become more

00:52:39,360 --> 00:52:50,970
configurable later on so this was a

00:52:44,580 --> 00:52:53,640
short rundown of the changes in camera

00:52:50,970 --> 00:52:55,140
light which is going out tomorrow as a

00:52:53,640 --> 00:52:58,860
pre-release otherwise I get in trouble

00:52:55,140 --> 00:53:01,170
if I don't say that if you want come by

00:52:58,860 --> 00:53:02,760
comment on it give us your ideas share

00:53:01,170 --> 00:53:07,580
what you think is a terrible idea what

00:53:02,760 --> 00:53:10,290
we are doing before it's too late and a

00:53:07,580 --> 00:53:13,890
reminder here tremor script this engine

00:53:10,290 --> 00:53:16,110
is not heart rebound - tremor the

00:53:13,890 --> 00:53:18,180
project so you can use the scripting

00:53:16,110 --> 00:53:20,970
engine inside any project you like there

00:53:18,180 --> 00:53:25,680
is a crate for it even can do cargo and

00:53:20,970 --> 00:53:29,250
then put it in your crates tunnel anyway

00:53:25,680 --> 00:53:32,640
last but not least we wanted to use the

00:53:29,250 --> 00:53:35,150
chance to give a shout out to a few

00:53:32,640 --> 00:53:39,420
open-source projects which have been

00:53:35,150 --> 00:53:40,950
elemental to tremor to building this and

00:53:39,420 --> 00:53:43,860
to rust community as a whole to be

00:53:40,950 --> 00:53:49,020
honest because it has been a really

00:53:43,860 --> 00:53:50,850
really really great time so we open

00:53:49,020 --> 00:53:53,520
sourced February this year we have been

00:53:50,850 --> 00:53:56,100
preparing for this for nearly a year

00:53:53,520 --> 00:53:57,780
because we wanted to do it right like

00:53:56,100 --> 00:54:00,750
the RFC process like getting all the

00:53:57,780 --> 00:54:02,190
repositories in the open and and we are

00:54:00,750 --> 00:54:04,020
by now at the point where all

00:54:02,190 --> 00:54:06,660
development happens in the open there

00:54:04,020 --> 00:54:07,140
isn't even a internal project board

00:54:06,660 --> 00:54:11,420
anymore

00:54:07,140 --> 00:54:14,190
they are just get up issues and we as

00:54:11,420 --> 00:54:17,300
people who have been an open source for

00:54:14,190 --> 00:54:20,040
years before we joined way fair value

00:54:17,300 --> 00:54:21,870
collaboration and that is hugely

00:54:20,040 --> 00:54:25,110
important to us which is why we added

00:54:21,870 --> 00:54:27,450
the section and and where we can we try

00:54:25,110 --> 00:54:28,950
to give back so some of the libraries we

00:54:27,450 --> 00:54:31,350
built like tremor script like send

00:54:28,950 --> 00:54:33,000
adjacent they are available for everyone

00:54:31,350 --> 00:54:36,720
as their own projects

00:54:33,000 --> 00:54:39,180
so people can start using them and the

00:54:36,720 --> 00:54:42,630
first shoutout we wanted to give is to

00:54:39,180 --> 00:54:44,970
the Microsoft Research crew in Cambridge

00:54:42,630 --> 00:54:48,270
they have built an allocator called SNM

00:54:44,970 --> 00:54:50,910
airlock or how I can't get it out of my

00:54:48,270 --> 00:54:53,810
head anymore smell ugh

00:54:50,910 --> 00:54:55,920
and it is heavily optimized for a

00:54:53,810 --> 00:54:56,940
producer/consumer patent with multiple

00:54:55,920 --> 00:54:59,010
threads

00:54:56,940 --> 00:55:01,140
so one thread produces data it gets sent

00:54:59,010 --> 00:55:03,120
to another this thread consumes it and

00:55:01,140 --> 00:55:05,730
Friedemann Friese the memory again and

00:55:03,120 --> 00:55:08,220
which is a perfect alignment with what

00:55:05,730 --> 00:55:11,940
we are building was tremor and has given

00:55:08,220 --> 00:55:13,530
us a huge boost in performance so if

00:55:11,940 --> 00:55:16,590
you're building an application that

00:55:13,530 --> 00:55:19,080
follows this patterns of producing data

00:55:16,590 --> 00:55:22,830
and one thread and consuming it in

00:55:19,080 --> 00:55:26,120
another gift as animalic a go the the

00:55:22,830 --> 00:55:29,670
people behind it especially Matthew are

00:55:26,120 --> 00:55:31,770
incredibly incredibly helpful they

00:55:29,670 --> 00:55:33,990
reached out we talked a lot to them and

00:55:31,770 --> 00:55:35,610
as a result of the benchmarking we did

00:55:33,990 --> 00:55:37,830
to them there has been two improvements

00:55:35,610 --> 00:55:39,720
done by them on the engine which gave us

00:55:37,830 --> 00:55:42,600
I think a total of 3 percent more

00:55:39,720 --> 00:55:44,670
throughput and two more are in progress

00:55:42,600 --> 00:55:46,920
which I'm really excited to see what

00:55:44,670 --> 00:55:49,950
comes out of that and there's a link in

00:55:46,920 --> 00:55:52,560
here which is to the C version of the

00:55:49,950 --> 00:55:55,890
allocator but there is also a rust rate

00:55:52,560 --> 00:55:58,860
which you can find I'm sure and the

00:55:55,890 --> 00:56:01,230
person behind it is Matthew go that is

00:55:58,860 --> 00:56:04,200
his Twitter I realize we have not

00:56:01,230 --> 00:56:05,880
figured out how to publish those slides

00:56:04,200 --> 00:56:08,630
but we will figure it out and give you

00:56:05,880 --> 00:56:12,110
the slides with the links in them and I

00:56:08,630 --> 00:56:14,550
can shout out to the vector people and

00:56:12,110 --> 00:56:17,220
which are really awesome and nice to

00:56:14,550 --> 00:56:19,170
work with we when we open source tremor

00:56:17,220 --> 00:56:20,850
we started chatting with them because

00:56:19,170 --> 00:56:23,490
there's a lot of overlap and what we are

00:56:20,850 --> 00:56:25,320
doing and we were already a little

00:56:23,490 --> 00:56:27,150
worried that they might they might see

00:56:25,320 --> 00:56:29,640
this as a competition even so we are not

00:56:27,150 --> 00:56:32,070
a tech company at Wayfair and well

00:56:29,640 --> 00:56:35,460
absolutely they have been wonderful we

00:56:32,070 --> 00:56:37,620
have been cobble a collaborating with

00:56:35,460 --> 00:56:42,030
them on a few things and sharing ideas

00:56:37,620 --> 00:56:45,180
and sharing code and Anna our vector is

00:56:42,030 --> 00:56:48,460
currently working on a pro to buff

00:56:45,180 --> 00:56:51,360
DCU Eliza in Wesson that takes the

00:56:48,460 --> 00:56:55,360
disadvantages of having to hard compile

00:56:51,360 --> 00:56:57,790
protobufs into your application away so

00:56:55,360 --> 00:57:00,190
they can be loaded at starting time

00:56:57,790 --> 00:57:03,250
instead and we've been talking about

00:57:00,190 --> 00:57:05,770
generalizing interfaces for sings and

00:57:03,250 --> 00:57:07,750
sources or how Trainor calls onerous

00:57:05,770 --> 00:57:09,940
offerings so how you get data in and out

00:57:07,750 --> 00:57:11,740
of an event processing system and hope

00:57:09,940 --> 00:57:14,170
to provide a bit of an ecosystem and

00:57:11,740 --> 00:57:16,030
rust around that and we have been

00:57:14,170 --> 00:57:18,190
talking about simply Jason which came

00:57:16,030 --> 00:57:20,950
from Gemma to be integrated and vector

00:57:18,190 --> 00:57:26,650
eventually to increase the performance

00:57:20,950 --> 00:57:28,120
off of there Jason parsley I said comes

00:57:26,650 --> 00:57:30,040
from Trevor the rust part comes from

00:57:28,120 --> 00:57:32,470
Trevor we didn't do simply JS because

00:57:30,040 --> 00:57:36,250
that's the next one and dr. Lee Myer did

00:57:32,470 --> 00:57:38,140
Cindy Jason and a incredibly great

00:57:36,250 --> 00:57:41,050
library again the original library isn't

00:57:38,140 --> 00:57:42,850
C naught and rust but and it is some of

00:57:41,050 --> 00:57:45,280
the cleanest C code I have ever seen it

00:57:42,850 --> 00:57:47,800
as a pleasure to read if you like if you

00:57:45,280 --> 00:57:50,800
like this kind of stuff go check out the

00:57:47,800 --> 00:57:54,100
C library and look at some really great

00:57:50,800 --> 00:57:57,010
C code it is blazingly fast it is just

00:57:54,100 --> 00:57:59,710
amazing how that chews through Jace and

00:57:57,010 --> 00:58:02,110
we have ported this to Russ to be a bit

00:57:59,710 --> 00:58:05,890
more idea Matic in the ecosystem in the

00:58:02,110 --> 00:58:07,750
tools we use in the interaction it is

00:58:05,890 --> 00:58:12,790
comfortable with cert in the large

00:58:07,750 --> 00:58:14,710
degree but it is by far the fastest

00:58:12,790 --> 00:58:18,640
Jason powder you can get in rust by a

00:58:14,710 --> 00:58:20,890
factor of two in many cases we have

00:58:18,640 --> 00:58:22,570
contributed back a few fixes and a few

00:58:20,890 --> 00:58:24,250
performance tweaks to send the Jason

00:58:22,570 --> 00:58:27,570
upstream based on measurements and

00:58:24,250 --> 00:58:32,530
experiences we made with using the port

00:58:27,570 --> 00:58:34,960
in our rust codebase so that is great

00:58:32,530 --> 00:58:36,910
mr. linnemeier was awesome about it it's

00:58:34,960 --> 00:58:39,100
swell I love this kind of collaboration

00:58:36,910 --> 00:58:44,500
and that makes me always really happy if

00:58:39,100 --> 00:58:45,760
open-source just works ok so again thank

00:58:44,500 --> 00:58:47,680
you all thank you for listening and

00:58:45,760 --> 00:58:50,140
thank you for being an awesome community

00:58:47,680 --> 00:58:52,660
and if you're interested in what we have

00:58:50,140 --> 00:58:54,460
built there is tremor dot RS which you

00:58:52,660 --> 00:58:56,590
can go to there all the links everything

00:58:54,460 --> 00:58:58,150
from slack to Twitter through our

00:58:56,590 --> 00:59:01,660
documentation to what now

00:58:58,150 --> 00:59:03,460
and come by say hi we have about hundred

00:59:01,660 --> 00:59:05,559
stickers left if you want some say a

00:59:03,460 --> 00:59:09,579
word and then a Twitter account called

00:59:05,559 --> 00:59:12,400
tremor Deb's and you can follow us there

00:59:09,579 --> 00:59:14,980
or not followers there and that would be

00:59:12,400 --> 00:59:17,049
it for the talk I have no idea how I did

00:59:14,980 --> 00:59:19,750
on time because I forgot to start with

00:59:17,049 --> 00:59:20,950
the clock no that was great thank you

00:59:19,750 --> 00:59:26,529
very much everybody

00:59:20,950 --> 00:59:28,720
Digital collapse all around so we have

00:59:26,529 --> 00:59:31,210
we do have a couple of minutes for some

00:59:28,720 --> 00:59:33,250
questions there was definitely some

00:59:31,210 --> 00:59:35,829
great shots happening inside of the

00:59:33,250 --> 00:59:38,140
matrix instance that we had the first

00:59:35,829 --> 00:59:41,309
one we had was is the tremor API

00:59:38,140 --> 00:59:41,309
compatible with logstash

00:59:42,930 --> 00:59:51,789
tremor is has multiple on ramps and off

00:59:46,059 --> 00:59:53,740
ramps we mostly consume data over Kafka

00:59:51,789 --> 00:59:55,839
within wayfarer that is where most of

00:59:53,740 --> 00:59:57,849
the data comes from yes if you have a

00:59:55,839 --> 00:59:59,559
Kafka top you read from locks that you

00:59:57,849 --> 01:00:03,309
can now read this Kafka topic from

00:59:59,559 --> 01:00:06,069
tremor and the HTTP API is not the same

01:00:03,309 --> 01:00:09,339
at all and we didn't try to build a new

01:00:06,069 --> 01:00:12,130
log stash because well mistakes were

01:00:09,339 --> 01:00:14,170
made without hate for log stash every

01:00:12,130 --> 01:00:16,539
project has mistakes and general will

01:00:14,170 --> 01:00:18,039
have the other ones but we want to make

01:00:16,539 --> 01:00:22,180
our own mistakes and learn from the

01:00:18,039 --> 01:00:24,910
mistakes others made before so in API

01:00:22,180 --> 01:00:26,440
centers not come habit compatible but a

01:00:24,910 --> 01:00:28,299
lot of what you can do is log stash you

01:00:26,440 --> 01:00:31,930
can do is travel krema just slightly

01:00:28,299 --> 01:00:34,390
differently thank you and the next

01:00:31,930 --> 01:00:36,630
question was I think it's already

01:00:34,390 --> 01:00:42,579
answered but it was and what sort of

01:00:36,630 --> 01:00:43,900
throughput tremor get yes that is a hard

01:00:42,579 --> 01:00:45,490
question because it depends on the

01:00:43,900 --> 01:00:49,690
hardware you're having it and the

01:00:45,490 --> 01:00:52,510
algorithms you put into it and the data

01:00:49,690 --> 01:00:55,869
you are going through it and benchmarks

01:00:52,510 --> 01:00:58,660
are always lies but I will share the our

01:00:55,869 --> 01:01:01,420
go to benchmark which was up to 500

01:00:58,660 --> 01:01:04,359
megabytes a second of parsing JSON

01:01:01,420 --> 01:01:06,819
processing Jason like filtering it

01:01:04,359 --> 01:01:08,950
changing some keys in it it's based on a

01:01:06,819 --> 01:01:11,340
production use case in wave here and

01:01:08,950 --> 01:01:14,970
just immunized and then

01:01:11,340 --> 01:01:16,350
reisi realizing it so that was up to 500

01:01:14,970 --> 01:01:18,990
bytes a second then again your mileage

01:01:16,350 --> 01:01:20,820
will vary and it will probably be slower

01:01:18,990 --> 01:01:25,860
unless you're using exactly that use

01:01:20,820 --> 01:01:27,180
case Thanks

01:01:25,860 --> 01:01:29,250
I think we have time for one more

01:01:27,180 --> 01:01:30,630
question this one is a general rust

01:01:29,250 --> 01:01:33,030
question so hopefully you don't mind

01:01:30,630 --> 01:01:36,270
that there was a question about does

01:01:33,030 --> 01:01:40,710
rust have tail recursion optimization I

01:01:36,270 --> 01:01:43,080
am really sure it does otherwise I would

01:01:40,710 --> 01:01:45,930
be really sad but end of the end is

01:01:43,080 --> 01:01:48,210
pretty good at most things like inlining

01:01:45,930 --> 01:01:51,500
and whatnot I would say that rust does

01:01:48,210 --> 01:01:54,990
but I'm just pulling that out of my ass

01:01:51,500 --> 01:01:57,480
I'm pretty sure the answer is it can't

01:01:54,990 --> 01:01:58,790
it sometimes does tendulkar recursion

01:01:57,480 --> 01:02:02,430
but there is absolutely no guarantee

01:01:58,790 --> 01:02:08,460
it's probably true no everything can be

01:02:02,430 --> 01:02:11,520
made into take oh yeah great okay so

01:02:08,460 --> 01:02:13,890
we're going to thanks again for the

01:02:11,520 --> 01:02:17,490
great Todd finds that was really great

01:02:13,890 --> 01:02:20,760
more digital claps all around you can

01:02:17,490 --> 01:02:24,120
continue your your questions in our

01:02:20,760 --> 01:02:27,120
matrix chat that we have and we are

01:02:24,120 --> 01:02:29,130
going to take a 15-minute break and

01:02:27,120 --> 01:02:30,900
we're going to break out into sprague

01:02:29,130 --> 01:02:32,910
out rooms for those that would like to

01:02:30,900 --> 01:02:34,410
chat with others about the talk so we've

01:02:32,910 --> 01:02:37,290
had or about other things

01:02:34,410 --> 01:02:40,710
please remember that our code of conduct

01:02:37,290 --> 01:02:43,080
still applies in the breakout rooms and

01:02:40,710 --> 01:02:44,910
if you would not like to participate

01:02:43,080 --> 01:02:47,850
it's fine to turn off your camera and

01:02:44,910 --> 01:02:50,610
your and your mic and step away have a

01:02:47,850 --> 01:02:52,800
drink of water and we will be back in

01:02:50,610 --> 01:02:56,190
about 15 minutes with our last talk of

01:02:52,800 --> 01:02:58,560
the day from Yosh and then a quick

01:02:56,190 --> 01:03:02,930
coding challenge for everyone so enjoy

01:02:58,560 --> 01:03:02,930
the break everyone thank you very much

01:03:08,190 --> 01:03:15,090
way back I think we are ready to go with

01:03:12,930 --> 01:03:16,560
the last talk of the evening from Yosh

01:03:15,090 --> 01:03:18,300
we're gonna have the option then after

01:03:16,560 --> 01:03:21,450
that we will have a small coding

01:03:18,300 --> 01:03:23,310
challenge where we can talk about some

01:03:21,450 --> 01:03:28,310
risk code together and and out the night

01:03:23,310 --> 01:03:28,310
so without further ado Josh take it away

01:03:28,980 --> 01:03:32,930
yeah oh whoa I can unmute myself amazing

01:03:31,589 --> 01:03:39,030
hi everyone

01:03:32,930 --> 01:03:39,359
let me share my screen screen shared all

01:03:39,030 --> 01:03:41,970
right

01:03:39,359 --> 01:03:43,079
can everyone see this wait wait I see

01:03:41,970 --> 01:03:45,420
exactly one face

01:03:43,079 --> 01:03:49,170
Eric similar if you can see it is wave

01:03:45,420 --> 01:03:52,710
your hands amazing okay great that's

01:03:49,170 --> 01:03:53,609
just a first check passed great um so hi

01:03:52,710 --> 01:03:57,780
everyone

01:03:53,609 --> 01:04:00,089
Josh this talk is called async HTTP what

01:03:57,780 --> 01:04:02,700
click yeah okay which means it's not

01:04:00,089 --> 01:04:06,210
about everything in async h AP it's just

01:04:02,700 --> 01:04:09,000
here's a bunch of stuff that we have

01:04:06,210 --> 01:04:13,130
done in the realm of async HTTP which

01:04:09,000 --> 01:04:17,430
includes me Josh and my co-conspirators

01:04:13,130 --> 01:04:19,770
collaborators friends esteemed

01:04:17,430 --> 01:04:22,200
colleagues Ryan who's right over there

01:04:19,770 --> 01:04:24,990
and and Friedel what I don't think is on

01:04:22,200 --> 01:04:27,119
the stream and many many other people

01:04:24,990 --> 01:04:32,130
it's about three libraries that we've

01:04:27,119 --> 01:04:34,680
written co-written basically so yes so

01:04:32,130 --> 01:04:38,190
talk about today try to keep it keep it

01:04:34,680 --> 01:04:40,530
like a little short talk okay yes okay

01:04:38,190 --> 01:04:42,060
so we're gonna talk a brief history a

01:04:40,530 --> 01:04:43,440
brief overview of like what's happened

01:04:42,060 --> 01:04:45,930
in async rust

01:04:43,440 --> 01:04:48,470
since the beginning of async rest I

01:04:45,930 --> 01:04:48,470
guess

01:04:50,880 --> 01:04:55,349
gonna take a quick look at HT PRS today

01:04:53,220 --> 01:04:58,099
which is our get up org and the stuff

01:04:55,349 --> 01:05:00,810
where we work and do these things under

01:04:58,099 --> 01:05:03,900
I've got a look at some some goals we

01:05:00,810 --> 01:05:05,609
had that we set out recently to be like

01:05:03,900 --> 01:05:07,520
oh here's some things that we want to do

01:05:05,609 --> 01:05:10,500
and we're gonna look at what we did

01:05:07,520 --> 01:05:15,839
that's the basic structure so without

01:05:10,500 --> 01:05:18,839
further ado a brief history of async

01:05:15,839 --> 01:05:20,430
async rests brief history of async so

01:05:18,839 --> 01:05:24,030
beckon August 2016 futures were

01:05:20,430 --> 01:05:25,980
announced on Aaron's blog so it's like

01:05:24,030 --> 01:05:30,869
almost four years three and a half years

01:05:25,980 --> 01:05:33,089
ago then in April of 2018 so futures

01:05:30,869 --> 01:05:34,650
were like here zero cost like state

01:05:33,089 --> 01:05:36,869
machines and they're very cool and

01:05:34,650 --> 01:05:40,319
they're very fast and I know April 2018

01:05:36,869 --> 01:05:42,050
in came along which was we think Eddy B

01:05:40,319 --> 01:05:45,050
and then definitely boats

01:05:42,050 --> 01:05:46,820
took started at a home there which was

01:05:45,050 --> 01:05:48,170
like here's how we can make these things

01:05:46,820 --> 01:05:50,480
even faster so we don't need to allocate

01:05:48,170 --> 01:05:53,660
like a whole lot in future 0.2 came out

01:05:50,480 --> 01:05:55,910
so futures are that 1 3 2 0 2 then in

01:05:53,660 --> 01:05:58,220
July of 2018 turn into futures they're

01:05:55,910 --> 01:06:00,350
about 3 it's pretty soon after and that

01:05:58,220 --> 01:06:03,830
pretty much remained for a year until

01:06:00,350 --> 01:06:06,650
July of 2019 when we got the future

01:06:03,830 --> 01:06:10,670
trait in instead like proper so it was a

01:06:06,650 --> 01:06:13,040
future 0 3 experimental beta but I

01:06:10,670 --> 01:06:13,400
forget to unstable I forget what the

01:06:13,040 --> 01:06:16,310
name was

01:06:13,400 --> 01:06:19,940
but then in in July of 2019 we got

01:06:16,310 --> 01:06:22,910
future properly and instead and then in

01:06:19,940 --> 01:06:23,690
November of 2019 which is last year we

01:06:22,910 --> 01:06:26,450
got async/await

01:06:23,690 --> 01:06:29,270
unstable and now we're a couple months

01:06:26,450 --> 01:06:33,190
further and we're officially in the time

01:06:29,270 --> 01:06:35,780
that we call the async/await MVP still

01:06:33,190 --> 01:06:40,220
the bare minimum works to make

01:06:35,780 --> 01:06:42,770
async/await work and it's early days so

01:06:40,220 --> 01:06:44,330
first take away from from this little

01:06:42,770 --> 01:06:45,620
history here is that in la serena of

01:06:44,330 --> 01:06:48,500
years a lot has happened a lot of

01:06:45,620 --> 01:06:50,270
iterations have happened and a lot of

01:06:48,500 --> 01:06:53,510
things have only recently become

01:06:50,270 --> 01:06:54,830
possible like to go mainstream so we're

01:06:53,510 --> 01:06:56,480
still trying to figure out like what's

01:06:54,830 --> 01:06:59,210
the best way to use a synchros what are

01:06:56,480 --> 01:07:00,440
the right ways to write patterns when

01:06:59,210 --> 01:07:02,270
should we use it what are the trade-offs

01:07:00,440 --> 01:07:04,280
you know we're getting a feel for it and

01:07:02,270 --> 01:07:05,780
this will continue to like phase out

01:07:04,280 --> 01:07:09,830
over the years and and many of the

01:07:05,780 --> 01:07:11,240
things that came before it is maybe were

01:07:09,830 --> 01:07:14,240
not the best options we're still

01:07:11,240 --> 01:07:16,940
exploring how to go forward but at the

01:07:14,240 --> 01:07:19,310
same time there's also this other

01:07:16,940 --> 01:07:21,100
tension which is like in order to keep

01:07:19,310 --> 01:07:23,720
going forward the parts that we agree on

01:07:21,100 --> 01:07:25,340
we need to keep stabilizing those so

01:07:23,720 --> 01:07:28,250
there's a part of exploration but also

01:07:25,340 --> 01:07:30,710
part of stabilization as you could see

01:07:28,250 --> 01:07:32,540
stuff like pin got stabilized stuff like

01:07:30,710 --> 01:07:33,860
the future trade could stabilize and as

01:07:32,540 --> 01:07:35,810
we go forward likely we'll look at

01:07:33,860 --> 01:07:38,690
streams we'll look at the async read an

01:07:35,810 --> 01:07:40,730
async right api's and and keep carving

01:07:38,690 --> 01:07:43,400
forward so that people can share more

01:07:40,730 --> 01:07:45,020
and we we agree on more things that's a

01:07:43,400 --> 01:07:48,560
bit of attention there I say it is

01:07:45,020 --> 01:07:50,150
because I get a lot of comments about

01:07:48,560 --> 01:07:51,260
like you're not stabilizing things I'm

01:07:50,150 --> 01:07:52,820
like yeah yeah but we also need to keep

01:07:51,260 --> 01:07:55,040
exploring you know so there's some stuff

01:07:52,820 --> 01:07:57,590
there anyway

01:07:55,040 --> 01:07:59,720
it's for us today that's a little get up

01:07:57,590 --> 01:08:02,330
work right there there's a people in the

01:07:59,720 --> 01:08:03,950
org and I took a private screenshot so

01:08:02,330 --> 01:08:06,920
you know you can see two two little

01:08:03,950 --> 01:08:09,380
faces there many projects are tied and

01:08:06,920 --> 01:08:12,680
surf which surf is it should be client

01:08:09,380 --> 01:08:14,390
framework there's a little surf example

01:08:12,680 --> 01:08:17,390
here Oh

01:08:14,390 --> 01:08:19,160
or you can see like surf get you give it

01:08:17,390 --> 01:08:21,799
a little URL then you'll wait it and

01:08:19,160 --> 01:08:23,060
then you get back a response and you can

01:08:21,799 --> 01:08:27,260
like give it more parameters if you like

01:08:23,060 --> 01:08:29,270
serve get body got something thought all

01:08:27,260 --> 01:08:30,980
sorts of parameters and then it get it

01:08:29,270 --> 01:08:33,830
gets converted into a future first call

01:08:30,980 --> 01:08:37,160
you call oh wait on it then with strains

01:08:33,830 --> 01:08:39,230
you can see a whole fun example so it

01:08:37,160 --> 01:08:41,359
should be should be there this should be

01:08:39,230 --> 01:08:43,220
a response the response is streaming so

01:08:41,359 --> 01:08:45,890
we can take a take a little request here

01:08:43,220 --> 01:08:47,480
or actual response and pipe it out into

01:08:45,890 --> 01:08:49,910
a file and it will like copy all the

01:08:47,480 --> 01:08:51,980
bytes that are going into or coming from

01:08:49,910 --> 01:08:54,980
the requests and stream them directly

01:08:51,980 --> 01:08:57,589
into a file until the request is done or

01:08:54,980 --> 01:09:01,549
until we get in there which returns i

01:08:57,589 --> 01:09:03,650
over here does it yeah it does anyway so

01:09:01,549 --> 01:09:06,200
that's surf it's nice nice a little

01:09:03,650 --> 01:09:07,850
convenient this Pied or at least what

01:09:06,200 --> 01:09:10,700
we're trying to get to with tide which

01:09:07,850 --> 01:09:13,910
is a great name tide app a greenio type

01:09:10,700 --> 01:09:18,470
server then at the route slash we for de

01:09:13,910 --> 01:09:21,350
HB get method we give it a call back an

01:09:18,470 --> 01:09:22,760
async closure and then we return hi from

01:09:21,350 --> 01:09:24,940
there hopefully like a little hello

01:09:22,760 --> 01:09:27,710
world we listen on localhost 8080

01:09:24,940 --> 01:09:30,380
asynchronously process requests now the

01:09:27,710 --> 01:09:33,440
thing here is like we have a this almost

01:09:30,380 --> 01:09:36,859
working in this exact shape is that the

01:09:33,440 --> 01:09:39,650
core of this code is three lines for an

01:09:36,859 --> 01:09:42,620
HTTP server with like routing which is

01:09:39,650 --> 01:09:45,109
fairly small and fairly competitive with

01:09:42,620 --> 01:09:47,299
a lot of other languages rest as a sea

01:09:45,109 --> 01:09:49,580
replacement is many times how people

01:09:47,299 --> 01:09:51,500
like to think about it but the

01:09:49,580 --> 01:09:55,610
ergonomics part is like something that

01:09:51,500 --> 01:09:57,170
is really good in rest and I feel not

01:09:55,610 --> 01:09:59,150
necessarily always the focus or the

01:09:57,170 --> 01:10:02,090
thing that's brought forward is like one

01:09:59,150 --> 01:10:05,060
of the best benefits but you know what

01:10:02,090 --> 01:10:07,640
we say yeah there we go so my opinion is

01:10:05,060 --> 01:10:08,539
a rush it should be and can be and is

01:10:07,640 --> 01:10:12,769
competitive

01:10:08,539 --> 01:10:17,750
ergonomics for other land you know in

01:10:12,769 --> 01:10:20,840
other languages alright so that's a

01:10:17,750 --> 01:10:22,159
little brief history of of async and

01:10:20,840 --> 01:10:25,610
rust and some of the stuff that's like

01:10:22,159 --> 01:10:27,320
going on today so what are the goals so

01:10:25,610 --> 01:10:29,329
we set out with a few goals we were

01:10:27,320 --> 01:10:31,730
already had like surf and tide and these

01:10:29,329 --> 01:10:34,070
things look really good I think like

01:10:31,730 --> 01:10:36,380
they're quite usable but we had some

01:10:34,070 --> 01:10:37,610
problems internally with the layers that

01:10:36,380 --> 01:10:39,980
we were using internally there was a lot

01:10:37,610 --> 01:10:41,300
of like patching over things abstracting

01:10:39,980 --> 01:10:44,900
over things I just didn't feel quite

01:10:41,300 --> 01:10:46,610
right so we set out to to try and figure

01:10:44,900 --> 01:10:48,110
out like hey can we make the internals

01:10:46,610 --> 01:10:50,750
of the frameworks that we're building as

01:10:48,110 --> 01:10:53,570
nice as the external guys

01:10:50,750 --> 01:10:55,099
that's what is about that now a thing

01:10:53,570 --> 01:10:56,179
that we really wanted to do is like all

01:10:55,099 --> 01:10:56,809
the way through throughout the whole

01:10:56,179 --> 01:11:00,829
thing

01:10:56,809 --> 01:11:03,980
do composition using black screams so or

01:11:00,829 --> 01:11:07,880
well screams in general so in part that

01:11:03,980 --> 01:11:09,320
means get it yeah sorry just click the

01:11:07,880 --> 01:11:14,449
little thing and I'm like how to train a

01:11:09,320 --> 01:11:16,280
thot so it means like ah light streams

01:11:14,449 --> 01:11:21,019
okay bye James yes that's what we want

01:11:16,280 --> 01:11:22,610
thanks boy a clear goal for us something

01:11:21,019 --> 01:11:24,590
we really wanted was to define clear

01:11:22,610 --> 01:11:26,449
boundaries between layers so for example

01:11:24,590 --> 01:11:28,610
something that we were missing that we

01:11:26,449 --> 01:11:30,829
weren't seeing an ecosystem quake it was

01:11:28,610 --> 01:11:35,000
a streaming HTTP encoder and decoder

01:11:30,829 --> 01:11:41,380
that didn't do any IO by itself so for

01:11:35,000 --> 01:11:44,539
example if you want to get do HD AP over

01:11:41,380 --> 01:11:46,280
unix streams that should be possible

01:11:44,539 --> 01:11:49,429
because that should be decoupled from

01:11:46,280 --> 01:11:52,010
from the exact tcp definition all it

01:11:49,429 --> 01:11:55,789
uses is like the is it creates and fried

01:11:52,010 --> 01:11:57,739
AP eyes and the stream API so by by

01:11:55,789 --> 01:12:00,559
decoupling that you get these very nice

01:11:57,739 --> 01:12:03,440
layered api's same for encryption same

01:12:00,559 --> 01:12:04,670
for like HTTP decoding encoding so that

01:12:03,440 --> 01:12:07,219
was like a goal that we were like hey

01:12:04,670 --> 01:12:08,960
can we do that is that possible because

01:12:07,219 --> 01:12:10,579
I would enable a lot of people to be

01:12:08,960 --> 01:12:15,349
very flexible and how do you use these

01:12:10,579 --> 01:12:17,389
things so yeah like running HTTP over

01:12:15,349 --> 01:12:19,070
over you know main streams or unique

01:12:17,389 --> 01:12:19,900
streams this is like an actual use case

01:12:19,070 --> 01:12:24,160
that people

01:12:19,900 --> 01:12:26,530
or file or you know so we started also

01:12:24,160 --> 01:12:28,630
the other one we're kind of like looking

01:12:26,530 --> 01:12:31,060
at like oh what's the perfect tight API

01:12:28,630 --> 01:12:32,770
if we could write one this is pretty

01:12:31,060 --> 01:12:34,870
much where the proxy server would look

01:12:32,770 --> 01:12:38,080
like so you get a request you give it as

01:12:34,870 --> 01:12:40,060
a body for like here this thing you

01:12:38,080 --> 01:12:41,740
proxy this call you stream out the whole

01:12:40,060 --> 01:12:44,650
thing back to the other thing and they

01:12:41,740 --> 01:12:47,500
get back a response and I you can take

01:12:44,650 --> 01:12:48,790
that and like scream it back out like

01:12:47,500 --> 01:12:50,650
writing a whole proxy should be about

01:12:48,790 --> 01:12:52,060
like five lines as again very

01:12:50,650 --> 01:12:55,060
aspirational but we're like pretty close

01:12:52,060 --> 01:12:58,720
to this so we were like how can we make

01:12:55,060 --> 01:13:01,600
this work so introducing three libraries

01:12:58,720 --> 01:13:04,090
you wrote about this last month but yeah

01:13:01,600 --> 01:13:06,220
now I'm doing a little talk on it which

01:13:04,090 --> 01:13:10,000
is async h1 it should be types and async

01:13:06,220 --> 01:13:11,680
native TLS so the way these things work

01:13:10,000 --> 01:13:13,720
together is that the top layer you have

01:13:11,680 --> 01:13:15,940
the framework such as ty for surf then

01:13:13,720 --> 01:13:18,490
there's an abstract interface and these

01:13:15,940 --> 01:13:20,410
libraries they work as the backends for

01:13:18,490 --> 01:13:22,390
it it behind this abstract interface so

01:13:20,410 --> 01:13:25,180
tied and surf they have logical backends

01:13:22,390 --> 01:13:27,340
so if you want to write like serve

01:13:25,180 --> 01:13:28,840
clients and use a web assembly back-end

01:13:27,340 --> 01:13:30,850
in the browser and you know it's it's

01:13:28,840 --> 01:13:33,570
powered by something else then for

01:13:30,850 --> 01:13:35,530
example curl that for example async h1

01:13:33,570 --> 01:13:37,420
because it a little encryption layer

01:13:35,530 --> 01:13:39,220
usually there's a parser just run time

01:13:37,420 --> 01:13:41,380
and they're all like tied together

01:13:39,220 --> 01:13:44,230
through like shared types so you they

01:13:41,380 --> 01:13:45,670
can communicate with each other the way

01:13:44,230 --> 01:13:47,050
it looks and surf is that the pub layer

01:13:45,670 --> 01:13:47,620
we have surf which is the end user

01:13:47,050 --> 01:13:49,330
interface

01:13:47,620 --> 01:13:52,780
HTTP client is the abstract interface

01:13:49,330 --> 01:13:54,640
and async TLS async h1 together with a

01:13:52,780 --> 01:13:56,830
6/3 they sort of form the foundation and

01:13:54,640 --> 01:13:59,110
HTP types brings it together now if

01:13:56,830 --> 01:14:00,730
we're tied with something similar except

01:13:59,110 --> 01:14:03,460
it's tied and should be service and

01:14:00,730 --> 01:14:06,700
stuff HTTP client so that's that's a

01:14:03,460 --> 01:14:09,640
little back-end so the way you can use

01:14:06,700 --> 01:14:11,680
so sort of focusing on I know if y'all

01:14:09,640 --> 01:14:13,990
can see my mouse but we're just gonna

01:14:11,680 --> 01:14:16,330
talk about the async TLS async h1 async

01:14:13,990 --> 01:14:19,360
stood part where you have a runtime and

01:14:16,330 --> 01:14:21,880
like encryption and Lowell HTTP encode

01:14:19,360 --> 01:14:23,710
or decoder is that the way you put those

01:14:21,880 --> 01:14:25,990
together to start making those HTP

01:14:23,710 --> 01:14:27,970
requests is not that much code right now

01:14:25,990 --> 01:14:30,220
so this is all the code that's required

01:14:27,970 --> 01:14:32,740
for to make an actual like I should be

01:14:30,220 --> 01:14:34,000
requests asynchronously in Russ

01:14:32,740 --> 01:14:36,010
today

01:14:34,000 --> 01:14:37,780
so you open up a TCP stream you get the

01:14:36,010 --> 01:14:40,150
address out you create a URL you quit

01:14:37,780 --> 01:14:42,280
you create a request then you pass all

01:14:40,150 --> 01:14:44,050
these things into like you convert the

01:14:42,280 --> 01:14:45,940
stream into an encrypted stream there's

01:14:44,050 --> 01:14:48,670
a handshaking for you et cetera and at

01:14:45,940 --> 01:14:51,160
the other day you convert the encrypted

01:14:48,670 --> 01:14:54,969
stream okay over this encrypted stream

01:14:51,160 --> 01:14:56,620
we're now going to run like our HIV

01:14:54,969 --> 01:14:58,600
requests and you send out the request

01:14:56,620 --> 01:15:00,010
that streams back the response it does

01:14:58,600 --> 01:15:02,500
the encryption etc behind the scenes

01:15:00,010 --> 01:15:03,580
it's like an all too much code but if

01:15:02,500 --> 01:15:05,650
you look at it as you might be like mmm

01:15:03,580 --> 01:15:07,449
that's kind of difficult to read so what

01:15:05,650 --> 01:15:08,620
weird like trying to get at and we're

01:15:07,449 --> 01:15:11,230
not quite here yet but we've like been

01:15:08,620 --> 01:15:13,960
talking about it is greater URL and like

01:15:11,230 --> 01:15:16,630
have a notion of PCP stream pls stream

01:15:13,960 --> 01:15:18,610
HDPE stream and sort of work your way

01:15:16,630 --> 01:15:20,380
down we're here we create a stream that

01:15:18,610 --> 01:15:22,090
we pass into the next stream that we

01:15:20,380 --> 01:15:23,500
pass into an extreme together with like

01:15:22,090 --> 01:15:27,190
a request and then you get back a

01:15:23,500 --> 01:15:29,320
response it like the idea is that you

01:15:27,190 --> 01:15:32,020
know making requests and doing this

01:15:29,320 --> 01:15:33,430
thing should really be concise and just

01:15:32,020 --> 01:15:35,320
natural to write out and you're like oh

01:15:33,430 --> 01:15:38,410
ok I see what goes on if you want to

01:15:35,320 --> 01:15:39,580
remove encryption you want to do

01:15:38,410 --> 01:15:42,010
encryption over a different layer you

01:15:39,580 --> 01:15:44,410
just swap out the backend so instead of

01:15:42,010 --> 01:15:46,420
TCP stream you could do unique stream

01:15:44,410 --> 01:15:47,949
instead of a TLS stream you could for

01:15:46,420 --> 01:15:50,110
example do some utter encryption layer

01:15:47,949 --> 01:15:52,930
or maybe you want to use this in TLS

01:15:50,110 --> 01:15:55,690
encryption with not HTTP at all but some

01:15:52,930 --> 01:15:57,070
other protocol you know so yeah this

01:15:55,690 --> 01:16:00,310
provides us with the necessary

01:15:57,070 --> 01:16:02,440
flexibility for that or at least that

01:16:00,310 --> 01:16:05,020
that's what we're aspiring to and this

01:16:02,440 --> 01:16:06,219
is the server equivalent I've gotta

01:16:05,020 --> 01:16:08,620
linger too much on this because it's

01:16:06,219 --> 01:16:10,870
still like in the semi broken state what

01:16:08,620 --> 01:16:12,940
we're trying to do is recently release

01:16:10,870 --> 01:16:14,680
also called parallel stream which allows

01:16:12,940 --> 01:16:17,290
you to for every incoming requests or

01:16:14,680 --> 01:16:19,900
every incoming stream spawn and task and

01:16:17,290 --> 01:16:21,969
like join all the handles yeah that's

01:16:19,900 --> 01:16:25,000
basically a they we do the inverse where

01:16:21,969 --> 01:16:27,670
we decrypt the incoming connection and

01:16:25,000 --> 01:16:28,270
we turn onto an HTTP except instead of

01:16:27,670 --> 01:16:31,390
like connect

01:16:28,270 --> 01:16:37,030
anyway something nice that we did with

01:16:31,390 --> 01:16:39,670
the series of crates is we now have HTTP

01:16:37,030 --> 01:16:41,290
aware error handling so our HTTP types

01:16:39,670 --> 01:16:43,390
which is the shared types abstraction

01:16:41,290 --> 01:16:46,600
that doesn't do any I know has a notion

01:16:43,390 --> 01:16:50,290
of what a HTTP error is which is

01:16:46,600 --> 01:16:52,180
there with a status code and has a nice

01:16:50,290 --> 01:16:54,730
little shorthand which is HTTP types of

01:16:52,180 --> 01:16:59,800
results you should be aware result and

01:16:54,730 --> 01:17:02,230
the air it exists you can get a ah the

01:16:59,800 --> 01:17:04,270
status trade you can if you get in scope

01:17:02,230 --> 01:17:06,760
or you just imported pre Lou then every

01:17:04,270 --> 01:17:08,680
error gets a dot status every result

01:17:06,760 --> 01:17:10,900
gets adult status method they can use

01:17:08,680 --> 01:17:13,330
you just give it quickly give give her a

01:17:10,900 --> 01:17:15,910
responsive status otherwise when it's

01:17:13,330 --> 01:17:17,650
castle-like default to 500 which is

01:17:15,910 --> 01:17:20,080
quite nice so here for example we're

01:17:17,650 --> 01:17:21,490
like reading file and if some thing

01:17:20,080 --> 01:17:24,310
doesn't hold or if we like get an error

01:17:21,490 --> 01:17:24,910
it just returns with 501 and all the way

01:17:24,310 --> 01:17:26,350
at the top

01:17:24,910 --> 01:17:27,940
inside the frameworks it's intended to

01:17:26,350 --> 01:17:30,130
to look at the error and be like okay

01:17:27,940 --> 01:17:33,100
cool get the status code and act based

01:17:30,130 --> 01:17:35,050
on that yeah having errors are aware of

01:17:33,100 --> 01:17:37,360
status codes is really beneficial when

01:17:35,050 --> 01:17:39,570
writing like Cordell way through and

01:17:37,360 --> 01:17:44,290
yeah we just wanted to be very nice

01:17:39,570 --> 01:17:45,670
working on integrating it so yeah the

01:17:44,290 --> 01:17:48,760
three crates that we provide

01:17:45,670 --> 01:17:52,440
now our HTTP types which is on doctoress

01:17:48,760 --> 01:17:55,090
on their HP types is the docs page so we

01:17:52,440 --> 01:17:57,250
have a notion of what mime types are we

01:17:55,090 --> 01:18:00,700
have no chef what cookies our header is

01:17:57,250 --> 01:18:03,070
etc and we're like looking to to even

01:18:00,700 --> 01:18:04,450
have more things such as you know full

01:18:03,070 --> 01:18:07,510
type constructors for certain like

01:18:04,450 --> 01:18:09,160
things there's a lot of things in the

01:18:07,510 --> 01:18:12,040
HTTP effect are like they can only be

01:18:09,160 --> 01:18:14,170
constructed a single way or a specific

01:18:12,040 --> 01:18:16,120
amount of yeah you know just having type

01:18:14,170 --> 01:18:17,350
constructors is very nice and just fits

01:18:16,120 --> 01:18:21,310
into this trying to build up the

01:18:17,350 --> 01:18:23,560
dictionary of HTTP things that that can

01:18:21,310 --> 01:18:26,500
be the type take away the second one is

01:18:23,560 --> 01:18:28,360
a sink h1 is what the docs page looks

01:18:26,500 --> 01:18:32,800
like there's two functions except

01:18:28,360 --> 01:18:34,300
connect for now then there's a sink

01:18:32,800 --> 01:18:38,380
native TLS which is a little bit more

01:18:34,300 --> 01:18:39,940
but also on crate IO and finally since

01:18:38,380 --> 01:18:41,980
we made these things and since we

01:18:39,940 --> 01:18:44,260
realized burned another crate with the

01:18:41,980 --> 01:18:48,750
help of a go to bus stop which is a

01:18:44,260 --> 01:18:51,970
friend which is a sync SSE a sink - SSE

01:18:48,750 --> 01:18:55,360
which provides a async surface and

01:18:51,970 --> 01:18:57,550
events for rust so we're working towards

01:18:55,360 --> 01:18:59,560
getting like server sent events in which

01:18:57,550 --> 01:19:00,110
is like a you know directional version

01:18:59,560 --> 01:19:04,370
of web sock

01:19:00,110 --> 01:19:05,810
so your server can send events over and

01:19:04,370 --> 01:19:09,320
they existing a chippy connection to

01:19:05,810 --> 01:19:11,000
clients and clients can act on that has

01:19:09,320 --> 01:19:13,130
some caveats compare the WebSockets but

01:19:11,000 --> 01:19:15,410
it's overall quite useful and now it

01:19:13,130 --> 01:19:18,440
exists and this thing also is generic

01:19:15,410 --> 01:19:20,090
over streams again over ASA green it

01:19:18,440 --> 01:19:26,030
provides you like with a handle to send

01:19:20,090 --> 01:19:27,830
events on anyway that was what I wanted

01:19:26,030 --> 01:19:29,600
to share with you today she have two

01:19:27,830 --> 01:19:32,390
links so you can check it out you're

01:19:29,600 --> 01:19:35,600
interested in trying out like some fun

01:19:32,390 --> 01:19:38,390
things around like async HTTP use it

01:19:35,600 --> 01:19:40,970
over you know file systems or some other

01:19:38,390 --> 01:19:44,660
like fun like IO interface you can check

01:19:40,970 --> 01:19:45,890
it out on get up comm /h PRS or if you

01:19:44,660 --> 01:19:47,660
want to read the blog post we're going

01:19:45,890 --> 01:19:51,200
to reduce any of these things we're just

01:19:47,660 --> 01:20:02,090
read the blog blog that SOCOM slash it's

01:19:51,200 --> 01:20:04,790
a HTTP we're getting lots of digital

01:20:02,090 --> 01:20:08,900
claps now so Thank You Yosh for a great

01:20:04,790 --> 01:20:13,310
talk so we can have some time for a few

01:20:08,900 --> 01:20:19,190
questions the first one is how do you

01:20:13,310 --> 01:20:20,600
deal with buffering that is I would like

01:20:19,190 --> 01:20:24,410
to know more what what is meant by

01:20:20,600 --> 01:20:26,720
buffering so we'll wait to see if they

01:20:24,410 --> 01:20:29,510
mean there what they mean there but I

01:20:26,720 --> 01:20:32,750
would imagine how do you buffer how do

01:20:29,510 --> 01:20:35,780
you keep track of your of State during

01:20:32,750 --> 01:20:37,970
parsing of HTTP requests and responses

01:20:35,780 --> 01:20:41,450
and hold on to that state while you go

01:20:37,970 --> 01:20:46,730
through the parsing process do you reuse

01:20:41,450 --> 01:20:48,470
buffers for that so we they're okay

01:20:46,730 --> 01:20:51,800
depending on how the questions asked I'm

01:20:48,470 --> 01:20:54,530
not entirely sure like the operating

01:20:51,800 --> 01:20:55,610
system definitely buffers there's

01:20:54,530 --> 01:20:57,500
buffering in the operating system

01:20:55,610 --> 01:21:00,710
we don't do buffer we haven't shown

01:20:57,500 --> 01:21:02,150
buffering yet in at this layer but if

01:21:00,710 --> 01:21:03,800
you want to introduce some form of like

01:21:02,150 --> 01:21:05,870
back pressure some forms like extra

01:21:03,800 --> 01:21:07,390
buffering you could just plug it in it

01:21:05,870 --> 01:21:09,650
could just be another form of stream

01:21:07,390 --> 01:21:10,970
could be another thing where you set

01:21:09,650 --> 01:21:13,310
limits

01:21:10,970 --> 01:21:16,070
recently wrote a post about parallel

01:21:13,310 --> 01:21:18,220
stream and we export the the concept of

01:21:16,070 --> 01:21:20,660
limits doesn't exist yet in this version

01:21:18,220 --> 01:21:22,580
there's this crates on crate sale which

01:21:20,660 --> 01:21:25,640
provide limits I forget what the name is

01:21:22,580 --> 01:21:28,970
but there there are controls that can be

01:21:25,640 --> 01:21:31,190
implemented to actually provide like a

01:21:28,970 --> 01:21:33,280
maximum amount of like requests are like

01:21:31,190 --> 01:21:36,590
in flight as for rejecting things I

01:21:33,280 --> 01:21:38,210
think the AWS CMS like lots of content

01:21:36,590 --> 01:21:41,390
about how to correctly go about

01:21:38,210 --> 01:21:42,080
buffering as well so it's definitely

01:21:41,390 --> 01:21:45,020
possible

01:21:42,080 --> 01:21:49,610
I just haven't yeah all right does that

01:21:45,020 --> 01:21:51,140
make yeah yes make sense to me okay we

01:21:49,610 --> 01:21:55,520
can see if people want to follow up with

01:21:51,140 --> 01:21:58,010
that and I think the second question was

01:21:55,520 --> 01:22:00,260
oh it's sort of the same what if the

01:21:58,010 --> 01:22:06,440
other and since more than you can handle

01:22:00,260 --> 01:22:08,870
or the consumer doesn't consume false so

01:22:06,440 --> 01:22:14,290
this sounds like a question of back

01:22:08,870 --> 01:22:19,040
pressure so generally like whatever

01:22:14,290 --> 01:22:21,710
controls you are used to having can be

01:22:19,040 --> 01:22:24,860
implemented in this model we just

01:22:21,710 --> 01:22:26,690
haven't done so yet the controls that we

01:22:24,860 --> 01:22:30,320
currently provide live at the async

01:22:26,690 --> 01:22:32,450
state level where there's like a TCP

01:22:30,320 --> 01:22:35,750
timeout it's just a socket flag that's

01:22:32,450 --> 01:22:38,960
set there's like a max like a keepalive

01:22:35,750 --> 01:22:42,230
thing that can be set at the HTTP layer

01:22:38,960 --> 01:22:44,660
we have a notion of like maximum some

01:22:42,230 --> 01:22:46,550
some basic details prevention stuff that

01:22:44,660 --> 01:22:48,830
exists not super elaborate we have

01:22:46,550 --> 01:22:50,780
timeouts also a small notion about that

01:22:48,830 --> 01:22:54,410
like so I'm not sure if we have actually

01:22:50,780 --> 01:22:56,270
implemented that but like we we do make

01:22:54,410 --> 01:22:58,400
sure that we don't consume more than we

01:22:56,270 --> 01:23:00,560
can handle as well as possible at some

01:22:58,400 --> 01:23:03,110
point if things like stall too long or

01:23:00,560 --> 01:23:05,630
like your responsive clients connections

01:23:03,110 --> 01:23:07,520
are actually reported that is built in

01:23:05,630 --> 01:23:08,900
to some degree but we can always be

01:23:07,520 --> 01:23:10,340
better and there are more elaborate

01:23:08,900 --> 01:23:15,980
controls that could be built that should

01:23:10,340 --> 01:23:19,010
be built that haven't been built yet all

01:23:15,980 --> 01:23:23,540
right great I think we have one more

01:23:19,010 --> 01:23:24,770
question and that was it's not entirely

01:23:23,540 --> 01:23:27,770
related to HTTP

01:23:24,770 --> 01:23:29,390
but um about async programming and rust

01:23:27,770 --> 01:23:31,700
have you considered some notion of

01:23:29,390 --> 01:23:33,640
cancellation for futures like maybe if

01:23:31,700 --> 01:23:36,140
the user wants to quit the application

01:23:33,640 --> 01:23:38,270
then you might want to stop taking input

01:23:36,140 --> 01:23:41,690
but still finish off all of the input

01:23:38,270 --> 01:23:45,490
that you are currently processing do I

01:23:41,690 --> 01:23:49,430
love that question such a good question

01:23:45,490 --> 01:23:50,950
is am I still screen sharing yes okay

01:23:49,430 --> 01:23:55,790
great

01:23:50,950 --> 01:23:58,970
so just gonna link you to create you can

01:23:55,790 --> 01:24:04,190
use for this exact thing it's going to

01:23:58,970 --> 01:24:07,610
stop token it's made by Aleksey from

01:24:04,190 --> 01:24:11,120
rest analyzer frame and the basic idea

01:24:07,610 --> 01:24:13,130
is that you this is a channel that can

01:24:11,120 --> 01:24:18,650
receive him death and once I event is

01:24:13,130 --> 01:24:21,860
received so you say like whose work yes

01:24:18,650 --> 01:24:24,830
okay so here is a stream called work you

01:24:21,860 --> 01:24:27,080
wrap it inside of this stop token and at

01:24:24,830 --> 01:24:29,060
some point this stop token will be

01:24:27,080 --> 01:24:32,120
triggered and will say like now work

01:24:29,060 --> 01:24:34,400
means to stop and it will start yielding

01:24:32,120 --> 01:24:35,960
none and then the stream can suit like

01:24:34,400 --> 01:24:38,180
finishes all the work that's been doing

01:24:35,960 --> 01:24:39,710
but no new items will be accepted and

01:24:38,180 --> 01:24:43,280
you get like a graceful shutdown system

01:24:39,710 --> 01:24:46,220
I have some notes on how I think we can

01:24:43,280 --> 01:24:48,170
maybe tweak the ergonomics for this but

01:24:46,220 --> 01:24:50,630
if you want a cancellation like

01:24:48,170 --> 01:24:53,360
cooperative cancellation in Russ in a

01:24:50,630 --> 01:24:55,040
synchros right now then then stop token

01:24:53,360 --> 01:24:56,750
is an interesting one to explore and I

01:24:55,040 --> 01:24:59,330
think it's it gets the semantic things

01:24:56,750 --> 01:25:03,260
right for sure hope to answer your

01:24:59,330 --> 01:25:04,640
question great so I think that's it

01:25:03,260 --> 01:25:06,590
although we real quick we had one

01:25:04,640 --> 01:25:08,960
follow-up question how can people

01:25:06,590 --> 01:25:11,570
outside of github follow the development

01:25:08,960 --> 01:25:13,490
is there a place to collaborate or

01:25:11,570 --> 01:25:16,460
should it is it just in github issues or

01:25:13,490 --> 01:25:17,990
so that's a great question so I've been

01:25:16,460 --> 01:25:19,400
extremely busy recently so I haven't

01:25:17,990 --> 01:25:27,650
like really been tracking get up issues

01:25:19,400 --> 01:25:31,400
even it's Ryan leave it on Twitter

01:25:27,650 --> 01:25:33,380
dignified choir and just formats later

01:25:31,400 --> 01:25:37,460
yeah I know we're not very coordinated

01:25:33,380 --> 01:25:38,300
we just chat oh we have a discord yes

01:25:37,460 --> 01:25:40,850
come

01:25:38,300 --> 01:25:42,770
a a sink RS the wait hold on I'm just

01:25:40,850 --> 01:25:45,940
gonna click you to where you can get

01:25:42,770 --> 01:25:49,880
onto our discord which i think is from

01:25:45,940 --> 01:25:52,280
tide no a sinks it also has a link it's

01:25:49,880 --> 01:25:54,860
the same discord just cuz we're all

01:25:52,280 --> 01:25:56,900
friends there's a chat link here so if

01:25:54,860 --> 01:25:59,720
you look to a Singh stood click on chat

01:25:56,900 --> 01:26:00,590
there's room so HTTP come hang out talk

01:25:59,720 --> 01:26:04,010
to people

01:26:00,590 --> 01:26:06,320
yes alright alright alright thank you

01:26:04,010 --> 01:26:09,140
very much more collapsed for Yosh and

01:26:06,320 --> 01:26:11,060
thank you to all of our speakers for for

01:26:09,140 --> 01:26:14,960
speaking tonight we have about twenty

01:26:11,060 --> 01:26:17,180
more minutes of the meetup and the

01:26:14,960 --> 01:26:20,930
thought was that what we do is a quick

01:26:17,180 --> 01:26:25,120
coding challenge and so I'm going to

01:26:20,930 --> 01:26:25,120
share my screen really quickly

01:26:25,600 --> 01:26:33,500
come on zoom be play nice with me here a

01:26:29,210 --> 01:26:36,500
shared screen and we are going to bring

01:26:33,500 --> 01:26:42,650
this up okay hopefully everybody can see

01:26:36,500 --> 01:26:44,690
my screen now I am going to paste this

01:26:42,650 --> 01:26:48,950
into the various rooms that we have it's

01:26:44,690 --> 01:26:52,970
just a link here to a playground so I'm

01:26:48,950 --> 01:26:57,050
pasting it into our matrix instance that

01:26:52,970 --> 01:26:59,300
we have and if I could find it into the

01:26:57,050 --> 01:27:01,940
zoom chat I'm not very good at zoom

01:26:59,300 --> 01:27:05,270
that's what I've come to the conclusion

01:27:01,940 --> 01:27:06,440
of if somebody could paste that into the

01:27:05,270 --> 01:27:10,670
zoom chat as well that would be super

01:27:06,440 --> 01:27:12,440
helpful so this is hopefully everybody

01:27:10,670 --> 01:27:14,180
can see that and it's it's large enough

01:27:12,440 --> 01:27:21,100
on the screen also let me know if it's

01:27:14,180 --> 01:27:23,930
not what the challenge is is basically

01:27:21,100 --> 01:27:26,930
this is slightly arbitrary and slightly

01:27:23,930 --> 01:27:33,080
just coax up to be giving you some weird

01:27:26,930 --> 01:27:35,210
and interesting kind of challenges with

01:27:33,080 --> 01:27:39,110
the compiler but what we're trying to do

01:27:35,210 --> 01:27:40,250
here and I called a client builder

01:27:39,110 --> 01:27:41,120
because that's what I was doing inside

01:27:40,250 --> 01:27:43,450
of this codebase

01:27:41,120 --> 01:27:46,040
but you can call it whatever you want

01:27:43,450 --> 01:27:48,200
what we're doing is we have an async

01:27:46,040 --> 01:27:51,170
function down below called doom work and

01:27:48,200 --> 01:27:51,900
basically if you know what how async

01:27:51,170 --> 01:27:54,480
functions work

01:27:51,900 --> 01:27:59,900
this will produce a future that returns

01:27:54,480 --> 01:28:03,090
a results of either a u8 or some kind of

01:27:59,900 --> 01:28:06,240
air which is hard-coded to a tuple here

01:28:03,090 --> 01:28:09,870
and our job is to get this to to go

01:28:06,240 --> 01:28:14,490
ahead and build inside of a lazy static

01:28:09,870 --> 01:28:17,790
and for those that aren't aware what

01:28:14,490 --> 01:28:21,270
lazy static is is an a great little

01:28:17,790 --> 01:28:24,090
library that allows you to have of kind

01:28:21,270 --> 01:28:26,280
of statics that are lazily initialized

01:28:24,090 --> 01:28:31,170
so in our example here this hashmap

01:28:26,280 --> 01:28:35,460
static is not created kind of at first

01:28:31,170 --> 01:28:36,990
when you run the program but after you

01:28:35,460 --> 01:28:39,090
call it for the first time it will

01:28:36,990 --> 01:28:40,890
initialize and then you have it and

01:28:39,090 --> 01:28:42,780
wouldn't you refer to it again you just

01:28:40,890 --> 01:28:49,230
get that same instance that you that you

01:28:42,780 --> 01:28:51,600
initialized before and so if we go ahead

01:28:49,230 --> 01:28:53,010
and by the way if one thing that you can

01:28:51,600 --> 01:28:54,990
do if you have any questions or thoughts

01:28:53,010 --> 01:28:59,940
or comments or whatever I'm monitoring

01:28:54,990 --> 01:29:02,640
the the matrix chat so make sure to pop

01:28:59,940 --> 01:29:04,590
your questions or thoughts in there and

01:29:02,640 --> 01:29:09,570
what we're going to do is try and get

01:29:04,590 --> 01:29:12,270
this to build and see if we build it

01:29:09,570 --> 01:29:13,320
what kind of error message that would

01:29:12,270 --> 01:29:14,880
get we're going to go through the

01:29:13,320 --> 01:29:16,800
process of trying to get this to work

01:29:14,880 --> 01:29:18,900
and if you want you can go ahead and

01:29:16,800 --> 01:29:20,550
just quit now and say goodnight for the

01:29:18,900 --> 01:29:23,190
night and try and work on this on your

01:29:20,550 --> 01:29:25,740
own and watch the the video once we post

01:29:23,190 --> 01:29:28,410
that online to see the the answer or you

01:29:25,740 --> 01:29:30,750
can follow along and who knows maybe I

01:29:28,410 --> 01:29:33,020
won't even be able to to do it correctly

01:29:30,750 --> 01:29:37,170
because I've forgotten how it all works

01:29:33,020 --> 01:29:39,210
and maybe the the answer that they have

01:29:37,170 --> 01:29:43,620
is not the the absolute best answer but

01:29:39,210 --> 01:29:46,020
it will be one answer okay so what we

01:29:43,620 --> 01:29:48,060
see here down below and the error

01:29:46,020 --> 01:29:51,150
message is that the trait standard

01:29:48,060 --> 01:29:55,110
marker sink is not implemented for our

01:29:51,150 --> 01:29:57,150
future that we have here and so I think

01:29:55,110 --> 01:29:59,940
the easiest thing to do is just to

01:29:57,150 --> 01:30:04,460
require that this thing is sink like

01:29:59,940 --> 01:30:04,460
this and see what happens there

01:30:06,500 --> 01:30:14,100
and put it in the wrong place here put

01:30:12,450 --> 01:30:15,840
it on the result instead of the future

01:30:14,100 --> 01:30:24,930
itself so we're moving that over one

01:30:15,840 --> 01:30:26,610
here and there we go it works that

01:30:24,930 --> 01:30:30,090
actually was a lot easier than I thought

01:30:26,610 --> 01:30:33,270
it was going to be there is another

01:30:30,090 --> 01:30:36,480
issue that I've forgot to add to this as

01:30:33,270 --> 01:30:38,910
well is if your type here which are you

01:30:36,480 --> 01:30:41,490
8 here is is actually sync but if you

01:30:38,910 --> 01:30:43,110
have a type that is not sync or

01:30:41,490 --> 01:30:46,170
something like that

01:30:43,110 --> 01:30:48,510
then you end up with with different

01:30:46,170 --> 01:30:53,990
error messages and stuff like that so

01:30:48,510 --> 01:31:00,300
give that a try and see what happens and

01:30:53,990 --> 01:31:03,540
let us know how it goes and that was it

01:31:00,300 --> 01:31:06,890
for now sorry for the kind of let down

01:31:03,540 --> 01:31:06,890
there and in the demo

01:31:07,340 --> 01:31:14,280
alright that's all we have for today any

01:31:11,990 --> 01:31:17,460
other questions or anything else that

01:31:14,280 --> 01:31:21,500
you would like to say at the end there

01:31:17,460 --> 01:31:27,350
Bassam no I'm thank you for the coat

01:31:21,500 --> 01:31:32,670
challenge not so hard

01:31:27,350 --> 01:31:36,000
yeah nice win I'm a thank you people for

01:31:32,670 --> 01:31:39,030
joining it was fun and if you have any

01:31:36,000 --> 01:31:43,680
ideas of how we can make this even more

01:31:39,030 --> 01:31:44,280
fun feel free to reach out and yeah it

01:31:43,680 --> 01:31:47,310
was great

01:31:44,280 --> 01:31:48,110
it's nice to be home so fast after a

01:31:47,310 --> 01:31:52,110
meet-up

01:31:48,110 --> 01:31:55,740
yes and I think there was one mention in

01:31:52,110 --> 01:31:57,780
the chat that the rust Zurich meetup

01:31:55,740 --> 01:32:00,330
group is hosting meet up next week as

01:31:57,780 --> 01:32:04,080
well I don't think we have a link for

01:32:00,330 --> 01:32:06,290
that ready yet but we will be retweeting

01:32:04,080 --> 01:32:11,730
that whenever that gets announced that

01:32:06,290 --> 01:32:14,160
and everybody enjoy that and we'll see

01:32:11,730 --> 01:32:16,900
you hopefully in four weeks for the

01:32:14,160 --> 01:32:19,720
expedition

01:32:16,900 --> 01:32:22,710
and great Thank You baron see you next

01:32:19,720 --> 01:32:27,690
time have a good and I thank you young

01:32:22,710 --> 01:32:27,690

YouTube URL: https://www.youtube.com/watch?v=43KS_nCqiIM


