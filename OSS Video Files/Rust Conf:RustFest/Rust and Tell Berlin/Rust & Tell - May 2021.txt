Title: Rust & Tell - May 2021
Publication date: 2021-05-25
Playlist: Rust and Tell Berlin
Description: 
	All Details: https://berline.rs/2021/05/25/rust-and-tell.html

00:00 Introduction
04:13 Tim McNamara - 5 Traits for Beginners to Learn
33:12 Senyo Simpson - Ergonomic error handling in Rust
58:53 Konstantin WÃ¼nscher & Blas Rodriguez - Building a cryptocurrency derivative exchange with Rust
Captions: 
	00:00:01,280 --> 00:00:05,920
good evening good afternoon depending on

00:00:03,840 --> 00:00:07,440
good morning as well depending on where

00:00:05,920 --> 00:00:10,639
you are on the planet and

00:00:07,440 --> 00:00:12,559
thanks to our speakers today uh this is

00:00:10,639 --> 00:00:16,080
another roast until day

00:00:12,559 --> 00:00:18,880
so uh just like we

00:00:16,080 --> 00:00:19,840
usually do i will go and introduce

00:00:18,880 --> 00:00:23,359
myself so

00:00:19,840 --> 00:00:26,000
me as the co-organizer here with jannery

00:00:23,359 --> 00:00:27,760
uh i'm a rust station from guinea

00:00:26,000 --> 00:00:28,880
republic of guinea that is in west

00:00:27,760 --> 00:00:31,760
africa

00:00:28,880 --> 00:00:34,399
and i currently work as a ros developer

00:00:31,760 --> 00:00:36,399
for a company called

00:00:34,399 --> 00:00:37,760
quick with develop we are developing a

00:00:36,399 --> 00:00:40,160
search engine big by

00:00:37,760 --> 00:00:41,520
object storage and we are also the

00:00:40,160 --> 00:00:44,480
company

00:00:41,520 --> 00:00:46,320
behind tv which is a rust search library

00:00:44,480 --> 00:00:47,039
so if you have time you can probably

00:00:46,320 --> 00:00:50,559
check on

00:00:47,039 --> 00:00:52,480
github uh what stan tv is and what it

00:00:50,559 --> 00:00:55,760
can do if you are interested or if you

00:00:52,480 --> 00:00:59,039
need search functionality

00:00:55,760 --> 00:01:00,480
so this meet up has a lot of support

00:00:59,039 --> 00:01:04,160
from jan eric and

00:01:00,480 --> 00:01:04,160
bastian and ryan david

00:01:04,879 --> 00:01:10,159
and this meetup is intended from for

00:01:07,760 --> 00:01:12,640
beginners level to expert level

00:01:10,159 --> 00:01:13,280
we are here to share our struggles ideas

00:01:12,640 --> 00:01:16,320
and hacks

00:01:13,280 --> 00:01:18,080
and projects so rosten kelly is a space

00:01:16,320 --> 00:01:18,960
for the community to learn and grow

00:01:18,080 --> 00:01:22,000
together

00:01:18,960 --> 00:01:22,320
and we expect you to also participate

00:01:22,000 --> 00:01:26,159
and

00:01:22,320 --> 00:01:26,640
help us in any way especially through

00:01:26,159 --> 00:01:29,119
speak

00:01:26,640 --> 00:01:30,640
coming out and speaking here at this

00:01:29,119 --> 00:01:34,320
meeting

00:01:30,640 --> 00:01:35,119
we follow the code of conduct from

00:01:34,320 --> 00:01:38,560
berlin

00:01:35,119 --> 00:01:39,119
and if you have more info on it you can

00:01:38,560 --> 00:01:42,000
go to

00:01:39,119 --> 00:01:44,240
berlin code of conduct.com if you see

00:01:42,000 --> 00:01:46,720
anything inappropriate you can

00:01:44,240 --> 00:01:48,159
probably you can privately or directly

00:01:46,720 --> 00:01:52,240
report to us

00:01:48,159 --> 00:01:54,560
me via email or our twitter handle or

00:01:52,240 --> 00:01:57,119
yannick or via email the same or

00:01:54,560 --> 00:01:57,119
his twitter

00:01:59,360 --> 00:02:06,320
so this is an online meetup so we have

00:02:03,439 --> 00:02:08,239
it available here on zoom and then we

00:02:06,320 --> 00:02:09,840
also have the zoom chat where you can

00:02:08,239 --> 00:02:12,879
post your questions

00:02:09,840 --> 00:02:15,440
uh we currently have three talks

00:02:12,879 --> 00:02:16,000
between those talks after the second

00:02:15,440 --> 00:02:20,160
talks

00:02:16,000 --> 00:02:23,280
mostly we will hold breakout rooms

00:02:20,160 --> 00:02:25,760
this is uh an opportunity for every

00:02:23,280 --> 00:02:28,000
participant to

00:02:25,760 --> 00:02:29,440
talk to each other and then synchronize

00:02:28,000 --> 00:02:32,640
with each other

00:02:29,440 --> 00:02:34,959
and it will last 20 15 minutes

00:02:32,640 --> 00:02:35,760
and after that you can come back for the

00:02:34,959 --> 00:02:39,440
last stop

00:02:35,760 --> 00:02:42,640
if you will be randomly assigned to

00:02:39,440 --> 00:02:45,120
break up rooms so if for instance your

00:02:42,640 --> 00:02:45,680
room is becomes empty before the end of

00:02:45,120 --> 00:02:48,000
the

00:02:45,680 --> 00:02:50,000
15 minutes you can come back onto the

00:02:48,000 --> 00:02:52,560
main room and we will always be able

00:02:50,000 --> 00:02:53,920
to assign it to another home we also

00:02:52,560 --> 00:02:56,319
have matrix charts

00:02:53,920 --> 00:02:57,120
available and where you can post your

00:02:56,319 --> 00:03:00,879
question

00:02:57,120 --> 00:03:02,159
and then this is live stream on youtube

00:03:00,879 --> 00:03:05,680
as well as

00:03:02,159 --> 00:03:07,040
on our website again as a reminder you

00:03:05,680 --> 00:03:09,760
can type your question

00:03:07,040 --> 00:03:12,560
here on the chat or you can post it on

00:03:09,760 --> 00:03:12,560
matrix chat

00:03:13,120 --> 00:03:17,040
another thing we really care about is

00:03:16,720 --> 00:03:19,360
that

00:03:17,040 --> 00:03:20,400
we want you to come in and speak at this

00:03:19,360 --> 00:03:23,680
meet up

00:03:20,400 --> 00:03:26,799
we always have three spots so

00:03:23,680 --> 00:03:29,360
we expect you and we feel like this is

00:03:26,799 --> 00:03:31,440
a good place to to share your knowledge

00:03:29,360 --> 00:03:34,799
your experience on any level

00:03:31,440 --> 00:03:34,799
there you have with rust

00:03:38,560 --> 00:03:43,360
so today we have three talks

00:03:44,959 --> 00:03:51,280
and the first one will be from team

00:03:48,560 --> 00:03:53,040
five tracks for beginners to to learn

00:03:51,280 --> 00:03:55,120
rust

00:03:53,040 --> 00:03:57,200
tim is a software developer a data

00:03:55,120 --> 00:03:57,760
scientist an artist and a technology

00:03:57,200 --> 00:04:00,080
writer

00:03:57,760 --> 00:04:03,280
and he is the author of the famous

00:04:00,080 --> 00:04:03,280
roster in action book

00:04:04,159 --> 00:04:09,280
the second talk will be ergonomic error

00:04:06,799 --> 00:04:12,080
handling and the third one will be

00:04:09,280 --> 00:04:13,599
building cryptocurrency derivative

00:04:12,080 --> 00:04:17,199
exchange with rust

00:04:13,599 --> 00:04:29,840
so without further ado let's

00:04:17,199 --> 00:04:29,840
start with team and

00:04:31,120 --> 00:04:34,720
wonderful okay

00:04:35,440 --> 00:04:38,560
thanks very much for the introduction it

00:04:37,120 --> 00:04:43,440
was very kind i'll just

00:04:38,560 --> 00:04:47,600
share my screen

00:04:43,440 --> 00:04:51,919
so uh there should be a big white um box

00:04:47,600 --> 00:04:54,560
in front of you now perfect um

00:04:51,919 --> 00:04:56,960
how does one start these things

00:04:54,560 --> 00:04:56,960
stronger

00:05:00,320 --> 00:05:04,160
or something like that i uh used to be i

00:05:02,960 --> 00:05:07,360
used to be able to speak german

00:05:04,160 --> 00:05:09,919
uh these days um not so much but um

00:05:07,360 --> 00:05:11,840
i miss berlin very much um i'm currently

00:05:09,919 --> 00:05:14,720
speaking to you from new zealand

00:05:11,840 --> 00:05:16,240
uh if i make mistakes please accept my

00:05:14,720 --> 00:05:19,440
apologies it's currently

00:05:16,240 --> 00:05:22,080
five past or seven past five a.m

00:05:19,440 --> 00:05:22,560
here in wellington okay cool where do we

00:05:22,080 --> 00:05:25,280
go

00:05:22,560 --> 00:05:25,919
we are going to be doing a beginner talk

00:05:25,280 --> 00:05:29,680
today

00:05:25,919 --> 00:05:30,800
and uh like normal we start these things

00:05:29,680 --> 00:05:33,520
with a bit of

00:05:30,800 --> 00:05:35,680
an introduction about who i am i am a i

00:05:33,520 --> 00:05:37,440
see myself as a as a mentor

00:05:35,680 --> 00:05:38,960
in the rus community follow me on

00:05:37,440 --> 00:05:41,680
twitter youtube and twitch

00:05:38,960 --> 00:05:42,639
for um i organized the russ wellington

00:05:41,680 --> 00:05:44,639
meetup group

00:05:42,639 --> 00:05:46,160
luckily we are covered free here in new

00:05:44,639 --> 00:05:50,000
zealand um

00:05:46,160 --> 00:05:50,000
we haven't had any cases i think for

00:05:50,560 --> 00:05:55,039
well over six months now so um yeah it's

00:05:53,759 --> 00:05:55,840
actually an in-person meetup which is

00:05:55,039 --> 00:05:59,039
interesting

00:05:55,840 --> 00:06:00,800
uh as you once said i

00:05:59,039 --> 00:06:02,800
am the author of rust in action uh

00:06:00,800 --> 00:06:04,800
day-to-day i

00:06:02,800 --> 00:06:08,160
do data science um actually i am

00:06:04,800 --> 00:06:11,280
particularly focused on data engineering

00:06:08,160 --> 00:06:12,720
and at a small consultancy well actually

00:06:11,280 --> 00:06:14,400
large consultancy

00:06:12,720 --> 00:06:16,160
called dragonfly data science here in

00:06:14,400 --> 00:06:20,400
wellington

00:06:16,160 --> 00:06:23,039
okay about the talk i want to reiterate

00:06:20,400 --> 00:06:23,600
uh one thing to emphasize is that these

00:06:23,039 --> 00:06:27,039
are not the

00:06:23,600 --> 00:06:30,080
most common traits um this talk is

00:06:27,039 --> 00:06:33,520
designed to inform you about

00:06:30,080 --> 00:06:36,160
how rust uh

00:06:33,520 --> 00:06:37,759
feels like as a programming language or

00:06:36,160 --> 00:06:41,120
how it is implemented

00:06:37,759 --> 00:06:43,840
and so my intention is to be able

00:06:41,120 --> 00:06:45,520
if you have only used java or c-sharp or

00:06:43,840 --> 00:06:47,440
python or javascript

00:06:45,520 --> 00:06:50,479
to be able to understand a little bit

00:06:47,440 --> 00:06:53,840
but you're having difficulty with rust

00:06:50,479 --> 00:06:55,520
my intention is for you to be able to

00:06:53,840 --> 00:06:57,360
get an understanding for what's

00:06:55,520 --> 00:07:00,400
happening inside rust

00:06:57,360 --> 00:07:03,680
and traits are essential to how

00:07:00,400 --> 00:07:05,120
it operates so for those people who

00:07:03,680 --> 00:07:08,240
don't like listening to long talks they

00:07:05,120 --> 00:07:08,240
have a 20 second version

00:07:08,720 --> 00:07:15,680
partial equality is the trait is

00:07:12,240 --> 00:07:16,479
a the trait that relates to the equality

00:07:15,680 --> 00:07:19,280
operator

00:07:16,479 --> 00:07:20,880
all operators are implemented with or

00:07:19,280 --> 00:07:24,240
are defined by traits

00:07:20,880 --> 00:07:25,840
display is how you ask a type to convert

00:07:24,240 --> 00:07:27,360
itself to a string so that it can be

00:07:25,840 --> 00:07:29,520
printed to the console

00:07:27,360 --> 00:07:30,479
clone is a way a mechanism for being

00:07:29,520 --> 00:07:32,479
able

00:07:30,479 --> 00:07:34,400
as from the beginner's perspective to

00:07:32,479 --> 00:07:36,800
avoid the borrow checker

00:07:34,400 --> 00:07:37,520
while you are understanding or taking

00:07:36,800 --> 00:07:40,560
the time

00:07:37,520 --> 00:07:44,080
to learn ownership the iterator trait is

00:07:40,560 --> 00:07:46,400
how is one of the the first

00:07:44,080 --> 00:07:48,400
steps for being able to really

00:07:46,400 --> 00:07:50,160
understand how rust is

00:07:48,400 --> 00:07:51,599
um slightly different from other

00:07:50,160 --> 00:07:53,360
programming languages or its peer

00:07:51,599 --> 00:07:57,280
languages in particular sort of c

00:07:53,360 --> 00:07:58,080
plus and this provides us very very

00:07:57,280 --> 00:08:00,960
ergonomic

00:07:58,080 --> 00:08:02,960
or very friendly way of using a for loop

00:08:00,960 --> 00:08:06,400
for any collection

00:08:02,960 --> 00:08:08,879
drf is this ability for

00:08:06,400 --> 00:08:13,280
the dot operator so method calls to be

00:08:08,879 --> 00:08:16,720
able to automatically

00:08:13,280 --> 00:08:18,639
uh call methods that you can drift into

00:08:16,720 --> 00:08:20,560
and that sounds very confusing but it

00:08:18,639 --> 00:08:23,840
basically allows

00:08:20,560 --> 00:08:27,520
uh if your type can dereference itself

00:08:23,840 --> 00:08:30,080
to become another type you can call the

00:08:27,520 --> 00:08:31,280
target types methods from the from the

00:08:30,080 --> 00:08:34,399
parent type itself

00:08:31,280 --> 00:08:37,440
so that's the 22nd version

00:08:34,399 --> 00:08:39,120
probably a bit more than 20 seconds if

00:08:37,440 --> 00:08:43,039
you have started with rust

00:08:39,120 --> 00:08:46,480
um or you're just um just very very new

00:08:43,039 --> 00:08:51,360
a a struct is just a type which

00:08:46,480 --> 00:08:54,560
can uh be composed of multiple

00:08:51,360 --> 00:08:57,600
objects so um

00:08:54,560 --> 00:08:59,120
it isn't the same as a class

00:08:57,600 --> 00:09:01,200
but it's very similar but you can think

00:08:59,120 --> 00:09:04,640
of a as

00:09:01,200 --> 00:09:07,920
a like a plain object

00:09:04,640 --> 00:09:08,880
so we create them with um so here i'm

00:09:07,920 --> 00:09:12,240
defining oh

00:09:08,880 --> 00:09:14,560
sorry it's saying that i this ignore

00:09:12,240 --> 00:09:19,120
ignore this error it's saying that i

00:09:14,560 --> 00:09:19,120
it doesn't know how to um the

00:09:20,959 --> 00:09:27,680
i can fix that uh

00:09:24,640 --> 00:09:31,040
i can define a cube and also

00:09:27,680 --> 00:09:31,600
create one uh but there are no methods

00:09:31,040 --> 00:09:33,760
attached

00:09:31,600 --> 00:09:35,279
to this struct okay and the other thing

00:09:33,760 --> 00:09:37,920
that i want to just spend

00:09:35,279 --> 00:09:39,200
10 seconds talking about is the notion

00:09:37,920 --> 00:09:43,279
of a bit pattern

00:09:39,200 --> 00:09:46,320
and this will become important when i

00:09:43,279 --> 00:09:47,040
describe uh something about floating

00:09:46,320 --> 00:09:49,600
point

00:09:47,040 --> 00:09:50,880
and it turns out that a well just the

00:09:49,600 --> 00:09:53,920
term bit pattern

00:09:50,880 --> 00:09:55,920
means a sequence of bits that represent

00:09:53,920 --> 00:09:59,200
a type

00:09:55,920 --> 00:10:01,279
uh it is the rep the internal

00:09:59,200 --> 00:10:04,079
representation for every type is a

00:10:01,279 --> 00:10:05,680
at some stage turns into a sequence of

00:10:04,079 --> 00:10:07,040
zeros and ones and that's what i mean by

00:10:05,680 --> 00:10:09,040
the term bit pattern

00:10:07,040 --> 00:10:10,640
okay so now we are ready to talk about

00:10:09,040 --> 00:10:12,399
what a trait is

00:10:10,640 --> 00:10:14,160
uh traits are the foundation for all

00:10:12,399 --> 00:10:17,120
behavior inside rust

00:10:14,160 --> 00:10:18,560
and it's the foundation for all behavior

00:10:17,120 --> 00:10:21,120
that is shared between

00:10:18,560 --> 00:10:21,760
types so if you have all floating point

00:10:21,120 --> 00:10:24,880
numbers

00:10:21,760 --> 00:10:26,800
or all integers behave in a similar way

00:10:24,880 --> 00:10:30,480
even though they are different types and

00:10:26,800 --> 00:10:30,480
that is enabled through traits

00:10:31,600 --> 00:10:34,800
you can think of traits as being an

00:10:33,519 --> 00:10:38,079
abstract bass class

00:10:34,800 --> 00:10:40,240
or an interface um

00:10:38,079 --> 00:10:42,079
if that might be helpful if you're from

00:10:40,240 --> 00:10:44,320
an object orientated

00:10:42,079 --> 00:10:46,079
object-oriented language so almost all

00:10:44,320 --> 00:10:48,240
of rust is actually built

00:10:46,079 --> 00:10:49,279
with traits operators methods the

00:10:48,240 --> 00:10:53,600
generic system

00:10:49,279 --> 00:10:56,800
is uh and trade objects are all uh

00:10:53,600 --> 00:11:00,880
connected to traits in some way

00:10:56,800 --> 00:11:00,880
so for example you know as i mentioned

00:11:01,040 --> 00:11:06,000
addition is related it's defined by this

00:11:04,320 --> 00:11:08,320
trait which is standard ops

00:11:06,000 --> 00:11:08,320
add

00:11:10,320 --> 00:11:17,600
so for example i can define

00:11:13,360 --> 00:11:21,440
a so i can import to the trait add

00:11:17,600 --> 00:11:23,600
and if we ignore what we say is it

00:11:21,440 --> 00:11:25,200
i can this triple function will work

00:11:23,600 --> 00:11:28,200
with any type t

00:11:25,200 --> 00:11:29,360
that implements add and out in the

00:11:28,200 --> 00:11:32,800
output

00:11:29,360 --> 00:11:35,360
of the edition is the same type

00:11:32,800 --> 00:11:36,720
oh and by the way it must be copy which

00:11:35,360 --> 00:11:40,160
means that

00:11:36,720 --> 00:11:41,839
type t will copy itself instead of

00:11:40,160 --> 00:11:43,920
basically duplicate itself if it needs

00:11:41,839 --> 00:11:47,200
to if it was going to encounter any

00:11:43,920 --> 00:11:50,079
borrow problems and what happens uh

00:11:47,200 --> 00:11:51,040
if i you know we've seen rust generics

00:11:50,079 --> 00:11:53,600
um

00:11:51,040 --> 00:11:54,639
before so i can call triple with a

00:11:53,600 --> 00:11:59,440
floating point number

00:11:54,639 --> 00:11:59,440
or i could call it with an integer

00:12:00,399 --> 00:12:04,560
and it will quote unquote just work

00:12:03,120 --> 00:12:06,240
which means that

00:12:04,560 --> 00:12:08,880
i have to find one function in source

00:12:06,240 --> 00:12:12,639
code and use traits to be able to

00:12:08,880 --> 00:12:16,000
uh specify that it must be a type

00:12:12,639 --> 00:12:20,880
that implements addition

00:12:16,000 --> 00:12:20,880
but for some some types

00:12:20,959 --> 00:12:24,800
don't well many types don't implement

00:12:23,120 --> 00:12:27,760
addition and so

00:12:24,800 --> 00:12:29,040
you cannot add a string size to another

00:12:27,760 --> 00:12:31,200
string slice

00:12:29,040 --> 00:12:32,720
and the type system will protect you

00:12:31,200 --> 00:12:33,519
from doing things that are illegal and

00:12:32,720 --> 00:12:35,760
it's all

00:12:33,519 --> 00:12:37,680
enabled by traits so how do we define

00:12:35,760 --> 00:12:40,800
them

00:12:37,680 --> 00:12:43,440
a trait uh in this case movement is

00:12:40,800 --> 00:12:47,519
defined by a set of methods

00:12:43,440 --> 00:12:49,120
and the distinguishing characteristic

00:12:47,519 --> 00:12:52,560
they look a lot like a class

00:12:49,120 --> 00:12:54,320
without any data

00:12:52,560 --> 00:12:55,920
and structs look a lot like a class

00:12:54,320 --> 00:12:58,000
without any methods

00:12:55,920 --> 00:12:59,760
and so i've got the struct here with

00:12:58,000 --> 00:13:02,320
node members so it's just a

00:12:59,760 --> 00:13:04,320
what we call a zero size type and i've

00:13:02,320 --> 00:13:07,279
and a sentinel in english is just a

00:13:04,320 --> 00:13:11,040
thing that never moves

00:13:07,279 --> 00:13:14,160
so just to find movement here sentinel

00:13:11,040 --> 00:13:16,079
and uh but a cannonball let's say

00:13:14,160 --> 00:13:17,839
implements movement it can't change its

00:13:16,079 --> 00:13:20,800
direction once it's fired

00:13:17,839 --> 00:13:22,480
and so uh if it's in the air it can only

00:13:20,800 --> 00:13:26,079
change its speed let's say

00:13:22,480 --> 00:13:29,120
and so um the trait

00:13:26,079 --> 00:13:31,839
system does not impose any more

00:13:29,120 --> 00:13:32,959
restrictions apart from the type

00:13:31,839 --> 00:13:34,560
it can be a little bit more

00:13:32,959 --> 00:13:35,360
sophisticated we've not we saw the

00:13:34,560 --> 00:13:38,800
output

00:13:35,360 --> 00:13:41,680
thing but in general um

00:13:38,800 --> 00:13:43,760
if you define a trait you're free to

00:13:41,680 --> 00:13:46,240
implement it however you want

00:13:43,760 --> 00:13:48,959
with whatever type that you have this

00:13:46,240 --> 00:13:51,839
was a little bit confusing to me because

00:13:48,959 --> 00:13:53,120
uh i sort of thought that trac that

00:13:51,839 --> 00:13:54,079
these definitions were slightly more

00:13:53,120 --> 00:13:57,839
magical

00:13:54,079 --> 00:14:00,320
that if i had a trait like movement that

00:13:57,839 --> 00:14:01,839
i would expect it to always be moving

00:14:00,320 --> 00:14:03,920
but actually it turns out that you can

00:14:01,839 --> 00:14:06,480
implement it just with with um

00:14:03,920 --> 00:14:08,800
with doing nothing hopefully that makes

00:14:06,480 --> 00:14:11,600
sense

00:14:08,800 --> 00:14:12,639
okay right uh one distinguishing

00:14:11,600 --> 00:14:16,240
characteristic

00:14:12,639 --> 00:14:17,120
is that traits do not have data so we

00:14:16,240 --> 00:14:19,440
can't say

00:14:17,120 --> 00:14:20,480
that the trait movement requires that

00:14:19,440 --> 00:14:22,720
the type it's

00:14:20,480 --> 00:14:23,600
has a speed attribute and a direction

00:14:22,720 --> 00:14:27,040
attribute

00:14:23,600 --> 00:14:30,079
um it doesn't make sense from rust uh

00:14:27,040 --> 00:14:31,839
traits only relate to methods okay

00:14:30,079 --> 00:14:33,279
so now we get to our first trait that we

00:14:31,839 --> 00:14:37,120
want to discuss for beginners

00:14:33,279 --> 00:14:38,320
clone and the reason why i think this is

00:14:37,120 --> 00:14:40,320
first is that

00:14:38,320 --> 00:14:42,160
if you're a beginner i want you know

00:14:40,320 --> 00:14:44,560
have you ever seen

00:14:42,160 --> 00:14:45,440
this use of mood value or something

00:14:44,560 --> 00:14:49,440
related i

00:14:45,440 --> 00:14:51,279
i feel that uh it's okay to spend a

00:14:49,440 --> 00:14:52,399
little bit of time at runtime cloning

00:14:51,279 --> 00:14:53,839
values

00:14:52,399 --> 00:14:57,199
if you're spending hours and hours and

00:14:53,839 --> 00:14:57,199
hours learning rust

00:14:57,279 --> 00:15:03,920
so this is this is my example so

00:15:00,959 --> 00:15:04,800
i have this func a function save which

00:15:03,920 --> 00:15:07,440
uh

00:15:04,800 --> 00:15:09,199
is supposed to save an object or this is

00:15:07,440 --> 00:15:11,839
this vector of

00:15:09,199 --> 00:15:13,040
uh integers to disk let's say and so

00:15:11,839 --> 00:15:16,399
here's here's my list of

00:15:13,040 --> 00:15:18,639
my event vector of numbers and i

00:15:16,399 --> 00:15:21,600
try and save it once and so this is just

00:15:18,639 --> 00:15:21,600
a read only

00:15:22,079 --> 00:15:27,440
method and then i mutate or

00:15:25,680 --> 00:15:29,680
modify the value i add two extra

00:15:27,440 --> 00:15:32,160
elements and then i save it again

00:15:29,680 --> 00:15:33,600
so rust when you start will give you

00:15:32,160 --> 00:15:37,680
this horrible error

00:15:33,600 --> 00:15:38,399
and it turns out that one way to fix

00:15:37,680 --> 00:15:41,680
this is by

00:15:38,399 --> 00:15:44,880
asking for a read only or what we uh

00:15:41,680 --> 00:15:44,880
like a uh

00:15:45,120 --> 00:15:48,240
we can take a reference to it but

00:15:46,800 --> 00:15:49,279
another way to do it while you learn

00:15:48,240 --> 00:15:51,519
it's complicated

00:15:49,279 --> 00:15:52,320
so we can we've got this shortcut which

00:15:51,519 --> 00:15:55,920
is

00:15:52,320 --> 00:15:58,720
we can add a clone method

00:15:55,920 --> 00:15:59,519
clone will duplicate all the values and

00:15:58,720 --> 00:16:02,720
this one

00:15:59,519 --> 00:16:04,079
will uh i hope work

00:16:02,720 --> 00:16:08,399
correctly and in this case it actually

00:16:04,079 --> 00:16:10,720
does so i'll just do that once more

00:16:08,399 --> 00:16:10,720
um

00:16:11,519 --> 00:16:15,680
oh okay so now i'm getting a different

00:16:13,680 --> 00:16:18,079
one because

00:16:15,680 --> 00:16:18,880
oh so just the way that the execution

00:16:18,079 --> 00:16:21,199
environment

00:16:18,880 --> 00:16:22,880
it's already diff it's already used save

00:16:21,199 --> 00:16:23,600
and so it thinks that the last call that

00:16:22,880 --> 00:16:26,639
i just

00:16:23,600 --> 00:16:29,680
executed is still present so

00:16:26,639 --> 00:16:32,959
i can create a new variable

00:16:29,680 --> 00:16:34,880
and that might work uh

00:16:32,959 --> 00:16:38,000
in fact i can't do it there either

00:16:34,880 --> 00:16:41,279
because save

00:16:38,000 --> 00:16:43,839
i'll need to clone it twice if i want to

00:16:41,279 --> 00:16:47,759
print it out

00:16:43,839 --> 00:16:47,759
um oh gosh

00:16:48,399 --> 00:16:52,079
tada perfect

00:16:52,880 --> 00:16:56,480
i should stop playing how do i implement

00:16:55,600 --> 00:16:59,680
clone

00:16:56,480 --> 00:17:01,360
uh so this is at the cheap way

00:16:59,680 --> 00:17:02,880
so i've got these three structures uh

00:17:01,360 --> 00:17:04,160
sorry three types and i need to

00:17:02,880 --> 00:17:06,480
implement phone for them

00:17:04,160 --> 00:17:07,439
so how do i do so um in particular i

00:17:06,480 --> 00:17:09,679
want to

00:17:07,439 --> 00:17:12,400
i really care about this meeting thing

00:17:09,679 --> 00:17:14,640
you actually saw me

00:17:12,400 --> 00:17:14,640
uh

00:17:15,439 --> 00:17:18,720
you know using this a derive attribute

00:17:17,919 --> 00:17:21,520
earlier

00:17:18,720 --> 00:17:24,880
which is a request to the compiler to

00:17:21,520 --> 00:17:24,880
implement things on our behalf

00:17:25,760 --> 00:17:33,280
and now it that's that's it

00:17:29,679 --> 00:17:33,840
whenever your many types in the standard

00:17:33,280 --> 00:17:36,559
library

00:17:33,840 --> 00:17:38,240
already know how to clone themselves and

00:17:36,559 --> 00:17:41,520
so if you have a

00:17:38,240 --> 00:17:44,720
a a struct

00:17:41,520 --> 00:17:46,559
that only includes members that already

00:17:44,720 --> 00:17:50,080
know how to clone themselves which is

00:17:46,559 --> 00:17:52,640
the majority of your of uh

00:17:50,080 --> 00:17:53,760
the majority of cases when you're

00:17:52,640 --> 00:17:56,080
starting out

00:17:53,760 --> 00:17:57,520
then you just need to derive clone and

00:17:56,080 --> 00:18:00,320
then you will have

00:17:57,520 --> 00:18:01,840
access to a clone method which is quite

00:18:00,320 --> 00:18:05,280
handy

00:18:01,840 --> 00:18:05,280
okay partial equality

00:18:05,679 --> 00:18:12,880
all operators are defined as traits and

00:18:09,760 --> 00:18:13,280
you know we take two values left and

00:18:12,880 --> 00:18:16,640
right

00:18:13,280 --> 00:18:18,880
and we return a boolean result

00:18:16,640 --> 00:18:20,080
and so that's fine um but the question

00:18:18,880 --> 00:18:22,400
is why is it

00:18:20,080 --> 00:18:23,760
partial like that sounds very strange

00:18:22,400 --> 00:18:27,200
and

00:18:23,760 --> 00:18:30,160
the reason is that rust tries very hard

00:18:27,200 --> 00:18:30,799
to get things right or model the

00:18:30,160 --> 00:18:33,919
environment

00:18:30,799 --> 00:18:34,720
model reality as quick as accurately as

00:18:33,919 --> 00:18:36,559
possible

00:18:34,720 --> 00:18:38,160
rust is very precise it is a systems

00:18:36,559 --> 00:18:42,400
programming language which means that

00:18:38,160 --> 00:18:47,440
it really cares about details

00:18:42,400 --> 00:18:49,840
so floating points um take a bit pattern

00:18:47,440 --> 00:18:50,960
you can see here that we have two

00:18:49,840 --> 00:18:53,200
floating point numbers

00:18:50,960 --> 00:18:55,039
with different bit patterns this one's

00:18:53,200 --> 00:18:58,880
zero and this one's

00:18:55,039 --> 00:19:02,160
you know 2 to the 32 minus 1.

00:18:58,880 --> 00:19:05,280
and they both

00:19:02,160 --> 00:19:07,760
uh evaluate as true

00:19:05,280 --> 00:19:10,480
so there's two bit patterns that are not

00:19:07,760 --> 00:19:13,200
the same that evaluate is true

00:19:10,480 --> 00:19:15,039
and we have here the same bit pattern on

00:19:13,200 --> 00:19:18,000
both sides

00:19:15,039 --> 00:19:19,120
and if we try equality they evaluate as

00:19:18,000 --> 00:19:22,320
false

00:19:19,120 --> 00:19:23,840
and so you may if you haven't

00:19:22,320 --> 00:19:25,520
encountered this behavior it might be

00:19:23,840 --> 00:19:27,360
worthwhile just for me pausing to

00:19:25,520 --> 00:19:31,760
explain what's actually happening

00:19:27,360 --> 00:19:35,440
um floating point has a

00:19:31,760 --> 00:19:38,480
uh so i'll just cheat a little bit

00:19:35,440 --> 00:19:40,799
has the notion of a negative zero

00:19:38,480 --> 00:19:41,520
so this is zero with the sign that uh

00:19:40,799 --> 00:19:44,559
assigned

00:19:41,520 --> 00:19:47,520
uh signed it flipped and so both zero

00:19:44,559 --> 00:19:48,480
uh and negative zero evaluate to uh are

00:19:47,520 --> 00:19:50,720
the same

00:19:48,480 --> 00:19:51,919
uh numeric value and so they evaluates

00:19:50,720 --> 00:19:55,440
evaluate

00:19:51,919 --> 00:19:58,080
to to true when for equality

00:19:55,440 --> 00:19:59,360
now this one here so that's that first

00:19:58,080 --> 00:20:04,840
example

00:19:59,360 --> 00:20:06,559
um the bit pattern is a bit sneaky of me

00:20:04,840 --> 00:20:09,360
so

00:20:06,559 --> 00:20:09,919
by the way just to prove to you this is

00:20:09,360 --> 00:20:13,520
a

00:20:09,919 --> 00:20:17,200
oh no i shouldn't order 60

00:20:13,520 --> 00:20:17,200
so f32

00:20:18,840 --> 00:20:25,200
uh nan so what the heck is that

00:20:22,880 --> 00:20:25,200
um

00:20:26,559 --> 00:20:33,039
floating point has a representation

00:20:29,600 --> 00:20:36,960
for uh in fact many many

00:20:33,039 --> 00:20:38,960
bit patterns that evaluate to ex

00:20:36,960 --> 00:20:40,400
result from expressions that are

00:20:38,960 --> 00:20:43,679
mathematically undefined

00:20:40,400 --> 00:20:45,679
so for example division by zero

00:20:43,679 --> 00:20:48,400
um is one of the or like division by

00:20:45,679 --> 00:20:51,600
infinity for example um

00:20:48,400 --> 00:20:53,760
and so the partial equality

00:20:51,600 --> 00:20:55,280
exists for floating point because of

00:20:53,760 --> 00:20:58,240
these very strange

00:20:55,280 --> 00:20:58,960
um circumstances and this is what i mean

00:20:58,240 --> 00:21:00,640
by what

00:20:58,960 --> 00:21:02,559
one of the things that to understand

00:21:00,640 --> 00:21:03,679
about rust is that it is pedantic and

00:21:02,559 --> 00:21:07,039
precise

00:21:03,679 --> 00:21:09,360
um okay display

00:21:07,039 --> 00:21:10,960
display is very very practical because

00:21:09,360 --> 00:21:12,320
one of the first things that you want to

00:21:10,960 --> 00:21:14,720
do

00:21:12,320 --> 00:21:17,200
when you start out with programming is a

00:21:14,720 --> 00:21:21,200
is print things to the console

00:21:17,200 --> 00:21:24,080
uh and one thing to note however is that

00:21:21,200 --> 00:21:24,799
display is different from debug oopsie

00:21:24,080 --> 00:21:27,679
let's

00:21:24,799 --> 00:21:29,360
mark down um the debug tray is intended

00:21:27,679 --> 00:21:32,400
for programmers

00:21:29,360 --> 00:21:34,159
whereas display is the

00:21:32,400 --> 00:21:36,559
trait that you will use if you want a

00:21:34,159 --> 00:21:39,039
string for users

00:21:36,559 --> 00:21:41,520
now there is also a subtle link to error

00:21:39,039 --> 00:21:41,520
handling

00:21:42,080 --> 00:21:45,679
but let's ignore that so ich been in

00:21:44,400 --> 00:21:49,200
berliner

00:21:45,679 --> 00:21:49,600
um relies on the if i want to print that

00:21:49,200 --> 00:21:53,520
to

00:21:49,600 --> 00:21:56,840
the screen i uh use the display

00:21:53,520 --> 00:22:00,480
trait and the syntax

00:21:56,840 --> 00:22:02,799
uh here uses the debug

00:22:00,480 --> 00:22:04,320
which is the programmer specific

00:22:02,799 --> 00:22:09,280
representation

00:22:04,320 --> 00:22:13,039
so this uh question mark is debug and

00:22:09,280 --> 00:22:16,880
just um curly braces is display

00:22:13,039 --> 00:22:20,559
now how does one implement

00:22:16,880 --> 00:22:24,640
display so i've got a place

00:22:20,559 --> 00:22:27,919
let's say a city let's change it to city

00:22:24,640 --> 00:22:29,120
that has a location uh represented as a

00:22:27,919 --> 00:22:32,640
coordinate and

00:22:29,120 --> 00:22:38,240
a and a city name

00:22:32,640 --> 00:22:38,240
and then i want to

00:22:39,840 --> 00:22:45,919
implement display for city so

00:22:42,880 --> 00:22:49,520
i need to implement a i bring the

00:22:45,919 --> 00:22:52,159
trait into local scope and

00:22:49,520 --> 00:22:53,280
this it includes one method which takes

00:22:52,159 --> 00:22:56,240
the strange type

00:22:53,280 --> 00:22:57,919
formatter with a kind of anonymous

00:22:56,240 --> 00:23:01,280
lifetime

00:22:57,919 --> 00:23:02,240
and and the easiest way to implement

00:23:01,280 --> 00:23:05,520
display

00:23:02,240 --> 00:23:10,159
is to find some member of your type

00:23:05,520 --> 00:23:10,159
that already implements display and

00:23:10,480 --> 00:23:16,080
and to just use that rely on rely on

00:23:13,440 --> 00:23:16,080
that member

00:23:17,679 --> 00:23:24,559
so for example let's say

00:23:22,880 --> 00:23:26,640
i'm only relying on the on the name

00:23:24,559 --> 00:23:27,520
attribute i'm actually ignoring

00:23:26,640 --> 00:23:30,240
coordinate

00:23:27,520 --> 00:23:33,360
for the purposes of display excuse me

00:23:30,240 --> 00:23:37,120
conflicting implementations

00:23:33,360 --> 00:23:41,120
uh that's a bit strange i

00:23:37,120 --> 00:23:44,400
wonder if this is a problem

00:23:41,120 --> 00:23:44,400
i think i pushed enter twice

00:23:47,120 --> 00:23:51,440
and so i'm actually not sure where

00:23:48,799 --> 00:24:04,080
berlin berliners

00:23:51,440 --> 00:24:06,240
but if i

00:24:04,080 --> 00:24:09,200
said that you know what it would just

00:24:06,240 --> 00:24:12,240
say none now because that's easy

00:24:09,200 --> 00:24:19,840
it's off the west africa um

00:24:12,240 --> 00:24:19,840
and then i want to print it

00:24:21,919 --> 00:24:24,480
berlin

00:24:26,080 --> 00:24:29,679
oh i expected it

00:24:29,760 --> 00:24:33,840
let's see uh it's all gone wrong

00:24:36,480 --> 00:24:40,720
okay there we are city builder cool

00:24:38,480 --> 00:24:44,720
that's me implementing display

00:24:40,720 --> 00:24:46,080
okay drift drift is quite special it

00:24:44,720 --> 00:24:49,200
allows types to become

00:24:46,080 --> 00:24:50,640
other types and if you encounter any

00:24:49,200 --> 00:24:53,120
confusing behavior with rust this may

00:24:50,640 --> 00:24:57,440
actually explain why

00:24:53,120 --> 00:24:57,440
rust supports a notion of a

00:24:58,400 --> 00:25:03,120
auto drif and so for smart pointer types

00:25:00,640 --> 00:25:06,480
dref provides access to the inner type

00:25:03,120 --> 00:25:08,960
here we have a box of a string slice

00:25:06,480 --> 00:25:09,600
and the drf operator which is the star

00:25:08,960 --> 00:25:12,480
thing

00:25:09,600 --> 00:25:13,760
actually returns the the string size

00:25:12,480 --> 00:25:16,960
itself

00:25:13,760 --> 00:25:19,840
so i say this is the right you know text

00:25:16,960 --> 00:25:20,400
is the wrong type it is a box but we've

00:25:19,840 --> 00:25:22,480
asked for

00:25:20,400 --> 00:25:24,240
a string slice and i can use the d

00:25:22,480 --> 00:25:26,559
reference operator to access what's

00:25:24,240 --> 00:25:28,799
inside it

00:25:26,559 --> 00:25:30,880
but more momentarily it will actually

00:25:28,799 --> 00:25:32,080
the dot operator which is the method how

00:25:30,880 --> 00:25:34,320
we call methods

00:25:32,080 --> 00:25:36,400
in rust will automatically derive things

00:25:34,320 --> 00:25:39,600
if the target type supports the method

00:25:36,400 --> 00:25:42,880
so for example i've got this platooch

00:25:39,600 --> 00:25:44,799
string here on one line and um i still

00:25:42,880 --> 00:25:48,000
live in north germany so

00:25:44,799 --> 00:25:51,679
maybe that's a dumb joke okay

00:25:48,000 --> 00:25:52,640
anyway uh so string does not implement

00:25:51,679 --> 00:25:57,840
make s key

00:25:52,640 --> 00:25:57,840
uppercase uh but string slices do

00:25:57,919 --> 00:26:02,320
occasionally you will encounter some

00:25:59,600 --> 00:26:04,000
kind of counter-intuitive syntax

00:26:02,320 --> 00:26:05,520
so you see the d reference operator

00:26:04,000 --> 00:26:07,679
followed by the reference operator and

00:26:05,520 --> 00:26:09,760
then type t

00:26:07,679 --> 00:26:11,520
uh this looks like it should do nothing

00:26:09,760 --> 00:26:12,559
they should effectively cancel each

00:26:11,520 --> 00:26:15,520
other out

00:26:12,559 --> 00:26:16,000
um but what is happening here is that

00:26:15,520 --> 00:26:18,720
the

00:26:16,000 --> 00:26:19,600
we're taking a reference to t and that

00:26:18,720 --> 00:26:22,159
type

00:26:19,600 --> 00:26:24,000
uh the referent might implement

00:26:22,159 --> 00:26:27,120
something else with drif

00:26:24,000 --> 00:26:30,159
and so it isn't purely working

00:26:27,120 --> 00:26:32,640
uh if you've only used pointers before

00:26:30,159 --> 00:26:34,400
um just remember that rust is doing

00:26:32,640 --> 00:26:36,240
something more when it dereferences

00:26:34,400 --> 00:26:38,000
values it's actually relying on the

00:26:36,240 --> 00:26:41,679
trade implementation

00:26:38,000 --> 00:26:45,120
and every trait uh every type can define

00:26:41,679 --> 00:26:47,840
exactly what it means by every trait

00:26:45,120 --> 00:26:49,200
uh so just as we had movement for

00:26:47,840 --> 00:26:52,240
sentinel

00:26:49,200 --> 00:26:54,240
did not actually move the sentinel

00:26:52,240 --> 00:26:55,440
here we have a dereference operator

00:26:54,240 --> 00:26:57,600
which isn't actually

00:26:55,440 --> 00:27:00,240
dereferencing a pointer it's just doing

00:26:57,600 --> 00:27:03,120
some conversion

00:27:00,240 --> 00:27:03,600
uh so here's some syntax oh so here's

00:27:03,120 --> 00:27:06,559
some

00:27:03,600 --> 00:27:08,400
some wording from the rust reference

00:27:06,559 --> 00:27:11,520
just saying that on non-pointed

00:27:08,400 --> 00:27:15,200
types uh star x is equivalent to

00:27:11,520 --> 00:27:18,399
star of d reference of reference to x

00:27:15,200 --> 00:27:20,960
so yeah

00:27:18,399 --> 00:27:22,880
i'll just leave that actually the last

00:27:20,960 --> 00:27:23,840
chat that i wanted to talk i think this

00:27:22,880 --> 00:27:26,399
is the last one

00:27:23,840 --> 00:27:28,480
um is iterator so it enables us to go

00:27:26,399 --> 00:27:31,520
through four loops and that's nice

00:27:28,480 --> 00:27:34,799
um so one one question is how do we

00:27:31,520 --> 00:27:37,200
uh we want to be able to implement um

00:27:34,799 --> 00:27:38,080
we want to be able to create a year from

00:27:37,200 --> 00:27:41,600
season

00:27:38,080 --> 00:27:44,640
and so how do i do so um

00:27:41,600 --> 00:27:46,159
well i start with i've got the the way

00:27:44,640 --> 00:27:49,600
to implement iterator

00:27:46,159 --> 00:27:52,640
is to create a like sister type

00:27:49,600 --> 00:27:54,080
a type that it lives alongside if i've

00:27:52,640 --> 00:27:56,640
already got one implementation

00:27:54,080 --> 00:27:58,080
excuse me and this has already been

00:27:56,640 --> 00:28:03,840
evaluated

00:27:58,080 --> 00:28:03,840
evaluated so

00:28:04,480 --> 00:28:09,919
oh man gosh this did work

00:28:08,159 --> 00:28:12,640
just before when i was testing it that's

00:28:09,919 --> 00:28:12,640
really perfect

00:28:15,360 --> 00:28:17,840
excuse me

00:28:18,480 --> 00:28:21,039
i'll go back

00:28:23,919 --> 00:28:28,559
i should maybe so i've got now i've got

00:28:27,679 --> 00:28:31,760
a year method

00:28:28,559 --> 00:28:35,120
on season i'll go back to defining

00:28:31,760 --> 00:28:38,320
describing what's happening here so

00:28:35,120 --> 00:28:40,880
in current season i yield every

00:28:38,320 --> 00:28:43,679
iteration i return an item which is the

00:28:40,880 --> 00:28:46,720
season type so kind of like the sister

00:28:43,679 --> 00:28:50,080
this is the internal part of season

00:28:46,720 --> 00:28:51,600
and uh every iteration i check like what

00:28:50,080 --> 00:28:53,440
follows summer well that's autumn and

00:28:51,600 --> 00:28:58,720
what follows autumn winter

00:28:53,440 --> 00:29:02,240
and then i mutate the internal state and

00:28:58,720 --> 00:29:05,520
i return uh

00:29:02,240 --> 00:29:08,880
the the next um

00:29:05,520 --> 00:29:11,840
i return the next item

00:29:08,880 --> 00:29:12,480
and i apologize for this just stuff at

00:29:11,840 --> 00:29:14,399
the bottom

00:29:12,480 --> 00:29:16,159
it's just because i implemented twice

00:29:14,399 --> 00:29:19,520
and so the other thing that i need to do

00:29:16,159 --> 00:29:21,679
is tell season that on the inter

00:29:19,520 --> 00:29:22,960
into ita method that i should convert

00:29:21,679 --> 00:29:25,760
myself to the

00:29:22,960 --> 00:29:27,679
sister trait sorry the sister type and

00:29:25,760 --> 00:29:29,600
so what is happening in a for loop

00:29:27,679 --> 00:29:31,440
is that the for loop is actually

00:29:29,600 --> 00:29:33,600
iterating or calling

00:29:31,440 --> 00:29:34,799
a sister type of whatever you're

00:29:33,600 --> 00:29:39,760
iterating over

00:29:34,799 --> 00:29:43,440
so inside the definition of year

00:29:39,760 --> 00:29:46,880
we are asking season

00:29:43,440 --> 00:29:49,679
to call into iterator or into it

00:29:46,880 --> 00:29:51,440
and then that is being used to create an

00:29:49,679 --> 00:29:54,720
iterator

00:29:51,440 --> 00:29:56,720
okay cool

00:29:54,720 --> 00:29:58,720
right uh i don't know if we have any

00:29:56,720 --> 00:29:59,440
extra time i think i'm about at 20

00:29:58,720 --> 00:30:02,640
minutes

00:29:59,440 --> 00:30:03,200
um sometimes trades have nothing no no

00:30:02,640 --> 00:30:04,559
time

00:30:03,200 --> 00:30:06,640
uh sorry no methods and they're called

00:30:04,559 --> 00:30:06,960
markers and my favorite implementation

00:30:06,640 --> 00:30:08,640
is

00:30:06,960 --> 00:30:10,559
assisted member drop which is just

00:30:08,640 --> 00:30:13,520
defined for every type

00:30:10,559 --> 00:30:13,919
um there is actually no no contents at

00:30:13,520 --> 00:30:15,520
all

00:30:13,919 --> 00:30:17,679
i think this is my like so what's

00:30:15,520 --> 00:30:19,760
actually uh what's actually happening is

00:30:17,679 --> 00:30:21,520
that drop like drf acts as an operator

00:30:19,760 --> 00:30:24,799
implicitly

00:30:21,520 --> 00:30:27,520
and we'll just uh call call

00:30:24,799 --> 00:30:28,000
the drop method on on the type when it

00:30:27,520 --> 00:30:31,760
ends

00:30:28,000 --> 00:30:34,799
when it ends this uh it's scope

00:30:31,760 --> 00:30:37,919
okay and

00:30:34,799 --> 00:30:40,240
i'm finished thanks very much

00:30:37,919 --> 00:30:41,600
um i'm more than happy to receive

00:30:40,240 --> 00:30:44,720
questions

00:30:41,600 --> 00:30:48,559
hopefully you enjoyed the talk

00:30:44,720 --> 00:30:51,600
yeah right thank you tim i think we have

00:30:48,559 --> 00:30:54,799
a few questions like grace talk uh

00:30:51,600 --> 00:30:57,919
the question is is that a jupiter

00:30:54,799 --> 00:31:00,240
notebook used for the rust code

00:30:57,919 --> 00:31:00,960
yes it is actually a jupiter notebook

00:31:00,240 --> 00:31:04,159
being used

00:31:00,960 --> 00:31:07,039
for us so there is a rust kernel for the

00:31:04,159 --> 00:31:07,039
jupiter notebook

00:31:08,240 --> 00:31:12,320
so if you search for rust kernel jupiter

00:31:13,840 --> 00:31:17,440
you will find it i can also post the

00:31:15,600 --> 00:31:21,440
link

00:31:17,440 --> 00:31:21,440
and i can they're

00:31:21,840 --> 00:31:27,349
it's got a very strange name um

00:31:24,160 --> 00:31:27,349
[Music]

00:31:27,600 --> 00:31:33,120
i'm just searching for it now jobs

00:31:30,559 --> 00:31:35,440
executed the end of scopes oh sorry

00:31:33,120 --> 00:31:37,039
oh sorry i just saw the the the problem

00:31:35,440 --> 00:31:40,360
with the font i apologize

00:31:37,039 --> 00:31:41,840
young eric um i probably should have um

00:31:40,360 --> 00:31:44,799
[Music]

00:31:41,840 --> 00:31:47,600
yeah made that question so um yeah okay

00:31:44,799 --> 00:31:48,080
thanks um david david has just posted a

00:31:47,600 --> 00:31:50,080
link

00:31:48,080 --> 00:31:54,159
to the rust kernel which is in the

00:31:50,080 --> 00:31:54,159
google namespace under under github

00:31:54,580 --> 00:31:57,720
[Music]

00:31:58,840 --> 00:32:01,840
um

00:32:02,399 --> 00:32:07,679
the other tool that i was using for

00:32:04,799 --> 00:32:13,120
turning it into a presentation

00:32:07,679 --> 00:32:13,120
is it's called rise slideshow

00:32:13,600 --> 00:32:19,440
and i can give you the link to that also

00:32:26,840 --> 00:32:30,320
um

00:32:28,080 --> 00:32:32,000
so i apologize if the if if the text was

00:32:30,320 --> 00:32:35,679
too small

00:32:32,000 --> 00:32:35,679
hopefully things are still legible

00:32:36,399 --> 00:32:39,440
yeah it's all right

00:32:41,360 --> 00:32:47,200
i don't see any other questions

00:32:44,480 --> 00:32:49,440
for now if you have questions please

00:32:47,200 --> 00:32:57,840
just post it

00:32:49,440 --> 00:32:57,840
perfect now

00:33:03,360 --> 00:33:09,360
all right so with that thank you

00:33:07,120 --> 00:33:11,760
tim and if they are for a question

00:33:09,360 --> 00:33:16,559
probably you can check on the chat

00:33:11,760 --> 00:33:21,600
and we'll move on to the next

00:33:16,559 --> 00:33:21,600
oh that's going to be given by

00:33:22,840 --> 00:33:27,200
senior and

00:33:24,320 --> 00:33:29,279
he's going to be talking about uh

00:33:27,200 --> 00:33:32,159
ergonomic error handling

00:33:29,279 --> 00:33:32,559
in ros senior is a software engineer

00:33:32,159 --> 00:33:35,120
with

00:33:32,559 --> 00:33:37,120
focus on infrastructure before that he

00:33:35,120 --> 00:33:38,640
worked as a data scientist building

00:33:37,120 --> 00:33:41,600
computer vision model

00:33:38,640 --> 00:33:42,320
so currently he lives in cape town and

00:33:41,600 --> 00:33:45,440
he works

00:33:42,320 --> 00:33:47,600
for a startup and building the next

00:33:45,440 --> 00:33:53,840
generation of smart technologies

00:33:47,600 --> 00:33:53,840
for agriculture senior talk to you

00:34:04,840 --> 00:34:07,840
awesome

00:34:12,079 --> 00:34:15,440
awesome thank you evans for the

00:34:14,000 --> 00:34:19,520
introduction uh

00:34:15,440 --> 00:34:21,839
yeah cool very excited for this um

00:34:19,520 --> 00:34:23,679
yeah so my talk is on ergonomic error

00:34:21,839 --> 00:34:25,760
handling the thrust

00:34:23,679 --> 00:34:27,359
so just a kind of like overview of where

00:34:25,760 --> 00:34:29,679
we're going so

00:34:27,359 --> 00:34:30,800
uh yeah initially just an overview of

00:34:29,679 --> 00:34:33,440
error handling and rust

00:34:30,800 --> 00:34:34,320
um kind of like yeah just how it works

00:34:33,440 --> 00:34:36,320
and the mechanics

00:34:34,320 --> 00:34:38,720
and for the veterans will probably be

00:34:36,320 --> 00:34:41,359
pretty standard and boring

00:34:38,720 --> 00:34:42,720
and then going on to like making uh

00:34:41,359 --> 00:34:46,399
error handling ergonomic

00:34:42,720 --> 00:34:50,000
and how yeah rust just tries to make

00:34:46,399 --> 00:34:51,679
the whole process um ergonomic and then

00:34:50,000 --> 00:34:53,359
going on to making areas informative and

00:34:51,679 --> 00:34:53,760
then just the future of error reporting

00:34:53,359 --> 00:34:56,480
and

00:34:53,760 --> 00:34:57,839
and you know what that kind of like uh

00:34:56,480 --> 00:34:58,560
where we're going with with error

00:34:57,839 --> 00:35:00,320
reporting

00:34:58,560 --> 00:35:02,000
so i mean evan's already introduced me

00:35:00,320 --> 00:35:03,520
but yeah i'm a software engineer

00:35:02,000 --> 00:35:04,960
i work on the platform team at

00:35:03,520 --> 00:35:06,000
aerobotics so yeah working with

00:35:04,960 --> 00:35:08,720
infrastructure

00:35:06,000 --> 00:35:09,920
and we're an agritech startup uh based

00:35:08,720 --> 00:35:11,920
in cape town south africa

00:35:09,920 --> 00:35:13,440
and passionate about technology and how

00:35:11,920 --> 00:35:14,400
we can leverage it to improve the world

00:35:13,440 --> 00:35:17,119
around us

00:35:14,400 --> 00:35:18,880
um iraq semi sent me regularly at senior

00:35:17,119 --> 00:35:19,599
simpson.com and you can find me on

00:35:18,880 --> 00:35:21,920
twitter

00:35:19,599 --> 00:35:23,359
uh posting annoying tweets at saint

00:35:21,920 --> 00:35:26,000
jesus

00:35:23,359 --> 00:35:27,119
um this is just a picture of cape town i

00:35:26,000 --> 00:35:29,119
just thought i'd

00:35:27,119 --> 00:35:31,119
show everyone what it what it looks like

00:35:29,119 --> 00:35:34,480
this is a sunset at one of the places

00:35:31,119 --> 00:35:35,599
we call sunset rock um yeah i'm sure all

00:35:34,480 --> 00:35:39,280
the europeans

00:35:35,599 --> 00:35:41,200
are jealous awesome so

00:35:39,280 --> 00:35:42,720
getting into it why is error handling

00:35:41,200 --> 00:35:45,520
important

00:35:42,720 --> 00:35:46,160
um so yeah the most important uh thing i

00:35:45,520 --> 00:35:47,680
want to just

00:35:46,160 --> 00:35:49,920
emphasize through this talk and like the

00:35:47,680 --> 00:35:53,520
biggest takeaway is that error handling

00:35:49,920 --> 00:35:55,040
um is really just about communication um

00:35:53,520 --> 00:35:57,520
and yeah just being able to communicate

00:35:55,040 --> 00:35:59,119
to developers uh what's going on you

00:35:57,520 --> 00:36:01,040
know why it happened where it happened

00:35:59,119 --> 00:36:03,200
etcetera etcetera um it's really just

00:36:01,040 --> 00:36:04,880
about that communication

00:36:03,200 --> 00:36:06,960
um but some other things are important

00:36:04,880 --> 00:36:08,480
so it prevents undefined behavior so we

00:36:06,960 --> 00:36:09,200
don't want our programs to continue

00:36:08,480 --> 00:36:11,440
executing

00:36:09,200 --> 00:36:13,280
um if they're you know in in valid

00:36:11,440 --> 00:36:15,200
states or ill-defined states

00:36:13,280 --> 00:36:16,960
um provides context to failure mode so

00:36:15,200 --> 00:36:17,839
this is just again about communication

00:36:16,960 --> 00:36:20,800
and providing

00:36:17,839 --> 00:36:23,040
the requisite information and makes

00:36:20,800 --> 00:36:26,320
developers advocate who doesn't want

00:36:23,040 --> 00:36:26,800
happy days cool so how rust does error

00:36:26,320 --> 00:36:30,320
handling

00:36:26,800 --> 00:36:32,079
um rust has no exceptions um and instead

00:36:30,320 --> 00:36:32,880
uh errors are returned so it's similar

00:36:32,079 --> 00:36:36,960
to golang

00:36:32,880 --> 00:36:38,720
that not paradigm

00:36:36,960 --> 00:36:40,320
and it takes in inspiration from the

00:36:38,720 --> 00:36:41,760
immo family of language is so different

00:36:40,320 --> 00:36:43,839
from curling and adapts

00:36:41,760 --> 00:36:45,839
and adopts the result type for handling

00:36:43,839 --> 00:36:48,880
recovery errors which i'll talk through

00:36:45,839 --> 00:36:51,359
um later in the slides um

00:36:48,880 --> 00:36:52,160
and yeah irrecoverable errors are

00:36:51,359 --> 00:36:54,640
signaled

00:36:52,160 --> 00:36:56,000
using panic again which i'll go through

00:36:54,640 --> 00:36:57,440
so recoverable errors these are

00:36:56,000 --> 00:37:00,640
obviously areas that we know

00:36:57,440 --> 00:37:01,280
how to handle um and you know in in the

00:37:00,640 --> 00:37:04,800
course of

00:37:01,280 --> 00:37:06,880
uh program execution we kind of like uh

00:37:04,800 --> 00:37:08,240
come across circumstances which we know

00:37:06,880 --> 00:37:09,920
what to do and how to handle them

00:37:08,240 --> 00:37:10,720
correctly so a good example for instance

00:37:09,920 --> 00:37:12,880
here

00:37:10,720 --> 00:37:14,640
is you know if you want to read a file

00:37:12,880 --> 00:37:16,079
um and

00:37:14,640 --> 00:37:17,520
you don't have any expectation on that

00:37:16,079 --> 00:37:18,320
file existing that's an area that we

00:37:17,520 --> 00:37:21,359
know how to add

00:37:18,320 --> 00:37:23,520
so um the result type is

00:37:21,359 --> 00:37:24,880
is is how we sort of like denote

00:37:23,520 --> 00:37:27,119
fallible computation

00:37:24,880 --> 00:37:29,200
um or variable functions in this case so

00:37:27,119 --> 00:37:31,839
a result types in enum which has

00:37:29,200 --> 00:37:33,280
two variants okay and error if the

00:37:31,839 --> 00:37:36,800
computation succeeds

00:37:33,280 --> 00:37:38,320
it returns or it contains the value

00:37:36,800 --> 00:37:40,800
from that computation otherwise it

00:37:38,320 --> 00:37:44,640
contains an error and this is really

00:37:40,800 --> 00:37:48,079
it's nice and super beneficial because

00:37:44,640 --> 00:37:49,359
we get a quick view into the fact that

00:37:48,079 --> 00:37:50,640
like a function is

00:37:49,359 --> 00:37:52,800
fallible just from the function

00:37:50,640 --> 00:37:53,920
signature so you know again just about

00:37:52,800 --> 00:37:56,160
communication

00:37:53,920 --> 00:37:57,760
um and we're easily able to tell like

00:37:56,160 --> 00:37:59,119
okay you know if i run this function

00:37:57,760 --> 00:38:01,680
i'll have to

00:37:59,119 --> 00:38:03,359
handle the error if it crops up um and

00:38:01,680 --> 00:38:06,480
then again it also forces us to

00:38:03,359 --> 00:38:08,400
to handle those errors um awesome so

00:38:06,480 --> 00:38:09,839
just like an example of using results so

00:38:08,400 --> 00:38:12,960
we create this file

00:38:09,839 --> 00:38:14,800
um ferrous dot text and that returns

00:38:12,960 --> 00:38:16,800
a result file obviously you can succeed

00:38:14,800 --> 00:38:18,800
otherwise result error

00:38:16,800 --> 00:38:20,079
and then we have to unwrap the result to

00:38:18,800 --> 00:38:23,920
get the

00:38:20,079 --> 00:38:27,760
the um the value in the in the result

00:38:23,920 --> 00:38:29,520
so in this case we can use um uh sorry

00:38:27,760 --> 00:38:31,599
so in this case we can obviously use

00:38:29,520 --> 00:38:32,000
match um and so if it's okay then we

00:38:31,599 --> 00:38:34,560
return

00:38:32,000 --> 00:38:35,839
the file or we assign the file to the

00:38:34,560 --> 00:38:37,920
variable otherwise

00:38:35,839 --> 00:38:39,839
in this case we just panic um if there's

00:38:37,920 --> 00:38:42,960
an error

00:38:39,839 --> 00:38:44,560
code and then similarly one um and the

00:38:42,960 --> 00:38:45,599
last thing that result allows us to do

00:38:44,560 --> 00:38:47,839
is to bubble errors

00:38:45,599 --> 00:38:49,680
and so just walking through that so

00:38:47,839 --> 00:38:50,960
oftentimes we don't want to handle the

00:38:49,680 --> 00:38:52,800
error where it's incumbent

00:38:50,960 --> 00:38:54,240
because we don't have like full scope

00:38:52,800 --> 00:38:56,240
and full knowledge of what we're trying

00:38:54,240 --> 00:38:58,000
to do when we're trying to achieve

00:38:56,240 --> 00:38:59,760
and we also don't have context in those

00:38:58,000 --> 00:39:02,320
situations

00:38:59,760 --> 00:39:04,160
and so instead you want to propagate the

00:39:02,320 --> 00:39:06,160
error to the caller so

00:39:04,160 --> 00:39:07,440
um and then the caller implements logic

00:39:06,160 --> 00:39:09,839
to handle the error

00:39:07,440 --> 00:39:11,119
as required so the caller has obviously

00:39:09,839 --> 00:39:12,880
um

00:39:11,119 --> 00:39:14,720
full scope and knowledge of what's going

00:39:12,880 --> 00:39:16,160
on and can decide you know in this

00:39:14,720 --> 00:39:17,839
context i want to handle this area in

00:39:16,160 --> 00:39:18,960
this way and in another context i want

00:39:17,839 --> 00:39:19,839
to handle it in a different way for

00:39:18,960 --> 00:39:22,400
instance

00:39:19,839 --> 00:39:24,000
um and so yeah the important thing is to

00:39:22,400 --> 00:39:24,800
be able to propagate those areas back to

00:39:24,000 --> 00:39:28,000
the chord

00:39:24,800 --> 00:39:28,400
and so we can do this quite easily um so

00:39:28,000 --> 00:39:30,640
here

00:39:28,400 --> 00:39:32,160
we see we have this function in it which

00:39:30,640 --> 00:39:35,760
has a results

00:39:32,160 --> 00:39:37,599
with the unit type and an error and then

00:39:35,760 --> 00:39:39,599
when we're creating this file so we

00:39:37,599 --> 00:39:42,720
obviously match them on the result type

00:39:39,599 --> 00:39:45,839
if it's okay we assign file to the

00:39:42,720 --> 00:39:47,440
variable otherwise um we return an error

00:39:45,839 --> 00:39:49,040
so we have like this early return

00:39:47,440 --> 00:39:50,720
that says now encounter this area i'm

00:39:49,040 --> 00:39:51,280
returning it back to the caller and the

00:39:50,720 --> 00:39:53,920
caller

00:39:51,280 --> 00:39:54,800
can then implement any logic to handle

00:39:53,920 --> 00:39:56,880
it

00:39:54,800 --> 00:39:58,800
and so similarly here and then at the

00:39:56,880 --> 00:40:00,079
bottom uh we have this

00:39:58,800 --> 00:40:01,920
we can kind of think about this as the

00:40:00,079 --> 00:40:02,880
call of the function some executable

00:40:01,920 --> 00:40:04,800
code

00:40:02,880 --> 00:40:06,079
and yeah we're just matching on this

00:40:04,800 --> 00:40:07,680
function call and so

00:40:06,079 --> 00:40:10,079
in this case i mean it's obviously super

00:40:07,680 --> 00:40:11,359
trivial but uh if it's okay then you do

00:40:10,079 --> 00:40:13,760
nothing and if it's

00:40:11,359 --> 00:40:15,280
if there's an error then we panic and

00:40:13,760 --> 00:40:18,640
say it could not initialize

00:40:15,280 --> 00:40:19,440
in this situation so irrecoverable

00:40:18,640 --> 00:40:20,720
errors so

00:40:19,440 --> 00:40:22,960
irrecoverable errors are obviously

00:40:20,720 --> 00:40:24,720
errors that we can't recover from

00:40:22,960 --> 00:40:26,720
and those tend to happen like when we

00:40:24,720 --> 00:40:28,079
encounter bugs so we'll come across

00:40:26,720 --> 00:40:29,680
situations where

00:40:28,079 --> 00:40:31,760
basically what we're saying is that hey

00:40:29,680 --> 00:40:33,680
i don't know how to handle the situation

00:40:31,760 --> 00:40:34,800
um and i think that the best approach is

00:40:33,680 --> 00:40:38,000
to stop uh

00:40:34,800 --> 00:40:39,839
combat execution and that again

00:40:38,000 --> 00:40:42,000
is important for cases where you want to

00:40:39,839 --> 00:40:42,640
for instance um just stopping valid

00:40:42,000 --> 00:40:46,319
states from

00:40:42,640 --> 00:40:49,040
occurring cool so this is

00:40:46,319 --> 00:40:51,680
an example that i've obviously shown

00:40:49,040 --> 00:40:54,800
before in previous

00:40:51,680 --> 00:40:58,000
images where in this case we

00:40:54,800 --> 00:40:59,599
routing to a file saying hey ferris and

00:40:58,000 --> 00:41:00,560
if it's okay do nothing but in this

00:40:59,599 --> 00:41:03,119
error

00:41:00,560 --> 00:41:04,800
branch we panic and so when we panic the

00:41:03,119 --> 00:41:06,640
program crashes at that point in time

00:41:04,800 --> 00:41:09,359
and just says you know there's nothing

00:41:06,640 --> 00:41:10,960
there's nothing further i can do here um

00:41:09,359 --> 00:41:14,400
so cool that's just like a quick

00:41:10,960 --> 00:41:16,319
overview of uh yeah just error handling

00:41:14,400 --> 00:41:18,960
and rust

00:41:16,319 --> 00:41:20,160
level and so yeah making it ergonomic

00:41:18,960 --> 00:41:22,160
rust

00:41:20,160 --> 00:41:23,280
really emphasizes language ergonomics i

00:41:22,160 --> 00:41:25,760
think it's one of the

00:41:23,280 --> 00:41:26,960
first things that i quite like picked up

00:41:25,760 --> 00:41:29,599
just from the community

00:41:26,960 --> 00:41:30,079
and when i started learning rust um and

00:41:29,599 --> 00:41:32,000
this is

00:41:30,079 --> 00:41:33,760
and this is obviously great so in the in

00:41:32,000 --> 00:41:37,920
the sense or in the case of

00:41:33,760 --> 00:41:40,560
errors and this the ergonomics come from

00:41:37,920 --> 00:41:42,160
having several convenience methods or

00:41:40,560 --> 00:41:44,160
syntax to reduce error handling

00:41:42,160 --> 00:41:46,000
boilerplate

00:41:44,160 --> 00:41:48,640
so an example of this is the tri

00:41:46,000 --> 00:41:51,200
operator so try

00:41:48,640 --> 00:41:52,960
so for bubbling errors uh it requires

00:41:51,200 --> 00:41:54,000
boilerplate due to that matching syntax

00:41:52,960 --> 00:41:57,440
so we have to go like

00:41:54,000 --> 00:41:59,200
you know if uh you you match and then if

00:41:57,440 --> 00:42:02,880
the result is okay then you're signing

00:41:59,200 --> 00:42:05,599
otherwise you return the error and

00:42:02,880 --> 00:42:05,920
rust so introduced the tri operator or

00:42:05,599 --> 00:42:07,520
the

00:42:05,920 --> 00:42:09,920
question mark operator as i like to call

00:42:07,520 --> 00:42:11,040
it um as a solution to this to reduce

00:42:09,920 --> 00:42:14,240
the bullet plate so

00:42:11,040 --> 00:42:16,480
in this case you know we have the match

00:42:14,240 --> 00:42:18,800
the matching syntax and this is without

00:42:16,480 --> 00:42:21,760
trying or without the top rated phone

00:42:18,800 --> 00:42:23,440
and um yeah you know similar thing so if

00:42:21,760 --> 00:42:24,480
it's okay we assign that file otherwise

00:42:23,440 --> 00:42:27,200
we return here

00:42:24,480 --> 00:42:28,560
so we can simplify this by using the

00:42:27,200 --> 00:42:32,079
straw operator

00:42:28,560 --> 00:42:33,359
um and here we have file create and then

00:42:32,079 --> 00:42:36,319
we have appended

00:42:33,359 --> 00:42:38,000
the question mark at the end and so

00:42:36,319 --> 00:42:41,520
these two are functionally the same

00:42:38,000 --> 00:42:44,480
achieve the same goal um and so if

00:42:41,520 --> 00:42:46,319
uh you know if the function uh succeeds

00:42:44,480 --> 00:42:47,680
then the variables assign and execution

00:42:46,319 --> 00:42:48,560
continues otherwise the error is

00:42:47,680 --> 00:42:52,400
returned early

00:42:48,560 --> 00:42:54,480
basically unwrap is quite similar

00:42:52,400 --> 00:42:55,760
so the same principle can be applied to

00:42:54,480 --> 00:42:57,680
panic where we

00:42:55,760 --> 00:42:59,359
you can reduce the amount of boilerplate

00:42:57,680 --> 00:43:01,359
that we write

00:42:59,359 --> 00:43:02,720
and it's achieved through the unranked

00:43:01,359 --> 00:43:04,400
function

00:43:02,720 --> 00:43:05,839
in this case yeah obviously it'll

00:43:04,400 --> 00:43:06,800
automatically panic if an error is

00:43:05,839 --> 00:43:10,560
returned

00:43:06,800 --> 00:43:13,920
so here we have this in it function

00:43:10,560 --> 00:43:16,400
and on the file create call we uh

00:43:13,920 --> 00:43:17,760
we call this function dot unwrap and

00:43:16,400 --> 00:43:20,400
that will basically fail

00:43:17,760 --> 00:43:22,000
if the if an error occurs otherwise um

00:43:20,400 --> 00:43:24,400
execution will continue

00:43:22,000 --> 00:43:25,040
um and so in this case for instance you

00:43:24,400 --> 00:43:27,200
know we

00:43:25,040 --> 00:43:28,240
we tried to write to a file and they

00:43:27,200 --> 00:43:30,560
didn't have permission to

00:43:28,240 --> 00:43:31,839
and so you know panicked and the program

00:43:30,560 --> 00:43:33,440
crashed

00:43:31,839 --> 00:43:35,119
so those are like some small things and

00:43:33,440 --> 00:43:38,400
there's many more of them expect

00:43:35,119 --> 00:43:40,480
mapper and many others um yeah i think

00:43:38,400 --> 00:43:42,880
like it's worth going over them

00:43:40,480 --> 00:43:44,720
uh and looking into them as you as you

00:43:42,880 --> 00:43:45,599
continue to write more and more rust i

00:43:44,720 --> 00:43:48,880
certainly will

00:43:45,599 --> 00:43:49,920
uh since i need a handful of them um but

00:43:48,880 --> 00:43:52,880
it just shows like

00:43:49,920 --> 00:43:54,560
rust's commitment to ergonomics and

00:43:52,880 --> 00:43:55,520
really trying to make the language easy

00:43:54,560 --> 00:43:59,680
and fun to use

00:43:55,520 --> 00:44:03,040
and have a great developer experience

00:43:59,680 --> 00:44:06,079
so making informative um this section

00:44:03,040 --> 00:44:08,720
just really ties in back to

00:44:06,079 --> 00:44:09,200
communication so again error handling is

00:44:08,720 --> 00:44:11,359
all about

00:44:09,200 --> 00:44:13,119
communicating um to developers you know

00:44:11,359 --> 00:44:15,680
what's going on

00:44:13,119 --> 00:44:17,359
and so yeah just going through that good

00:44:15,680 --> 00:44:19,760
areas are highly informative

00:44:17,359 --> 00:44:20,720
um they improve developer experience i

00:44:19,760 --> 00:44:23,599
mean

00:44:20,720 --> 00:44:25,040
i'm sure everyone has uh incarnate

00:44:23,599 --> 00:44:26,480
obviously if you've been riding rust

00:44:25,040 --> 00:44:29,920
you've encountered the

00:44:26,480 --> 00:44:31,680
rust compiler and oftentimes um you know

00:44:29,920 --> 00:44:33,280
it's just the best in class in terms of

00:44:31,680 --> 00:44:35,200
like the error reporting that's that's

00:44:33,280 --> 00:44:37,280
given and it's a it's such a huge

00:44:35,200 --> 00:44:40,079
quality of life improvement and so that

00:44:37,280 --> 00:44:43,760
really improves the developed experience

00:44:40,079 --> 00:44:44,319
um it helps debug issues much faster i'm

00:44:43,760 --> 00:44:45,839
sure you've

00:44:44,319 --> 00:44:48,000
all been in situations where like the

00:44:45,839 --> 00:44:49,680
error you've gotten

00:44:48,000 --> 00:44:51,839
doesn't really point to you know what's

00:44:49,680 --> 00:44:53,839
really happened or it's very opaque

00:44:51,839 --> 00:44:55,520
um and and doesn't really give you

00:44:53,839 --> 00:44:57,200
enough context and you spend hours and

00:44:55,520 --> 00:44:59,440
hours and hours and hours

00:44:57,200 --> 00:45:00,560
trying to to debug an issue that would

00:44:59,440 --> 00:45:02,560
have just been solved

00:45:00,560 --> 00:45:03,680
way easier if you've got like a more

00:45:02,560 --> 00:45:06,720
informative error

00:45:03,680 --> 00:45:08,880
and so again talking about communication

00:45:06,720 --> 00:45:11,280
and of course they make developers happy

00:45:08,880 --> 00:45:13,440
to make developers happy to get

00:45:11,280 --> 00:45:15,599
uh highly informative errors but routing

00:45:13,440 --> 00:45:15,599
them

00:45:15,920 --> 00:45:20,160
so yeah when we're talking about uh

00:45:18,880 --> 00:45:21,040
informative areas we've got to think

00:45:20,160 --> 00:45:22,880
about them in

00:45:21,040 --> 00:45:24,480
two types of ways like or in several

00:45:22,880 --> 00:45:26,160
ways when it comes to an application or

00:45:24,480 --> 00:45:26,720
library so this just really has to do

00:45:26,160 --> 00:45:29,520
with

00:45:26,720 --> 00:45:31,440
how we structure um errors and the kind

00:45:29,520 --> 00:45:35,520
of like role they play

00:45:31,440 --> 00:45:37,520
in each in each case so for a library

00:45:35,520 --> 00:45:39,280
um yeah it's important to create

00:45:37,520 --> 00:45:41,040
meaningful custom error types

00:45:39,280 --> 00:45:42,640
so this this is important because

00:45:41,040 --> 00:45:44,079
obviously your application works in a

00:45:42,640 --> 00:45:47,520
certain domain and

00:45:44,079 --> 00:45:49,119
and failures are represented um within

00:45:47,520 --> 00:45:50,240
some certain domain so we want to really

00:45:49,119 --> 00:45:52,319
capture like

00:45:50,240 --> 00:45:54,000
areas that happen in that domain with

00:45:52,319 --> 00:45:55,760
these custom error types

00:45:54,000 --> 00:45:57,359
um but and again being able to

00:45:55,760 --> 00:45:59,200
communicate to developers that these

00:45:57,359 --> 00:46:02,480
certain kinds of errors happen in

00:45:59,200 --> 00:46:03,920
this sort of context that we're in um

00:46:02,480 --> 00:46:06,160
another thing is wrapping standard

00:46:03,920 --> 00:46:08,000
errors where necessary um which allows

00:46:06,160 --> 00:46:09,200
applications to differentiate between

00:46:08,000 --> 00:46:11,040
various areas so

00:46:09,200 --> 00:46:12,720
you can imagine for instance that if you

00:46:11,040 --> 00:46:16,480
have two crates

00:46:12,720 --> 00:46:18,640
crate a and b and they both uh

00:46:16,480 --> 00:46:20,160
produce io errors for instance you want

00:46:18,640 --> 00:46:23,280
to be able to differentiate

00:46:20,160 --> 00:46:23,839
uh if an i error came from crate a or

00:46:23,280 --> 00:46:25,760
crate b

00:46:23,839 --> 00:46:26,960
if they because i errors are from the

00:46:25,760 --> 00:46:28,560
standard rb for instance

00:46:26,960 --> 00:46:30,240
and if they came from crate a or crate b

00:46:28,560 --> 00:46:33,680
and so we wrap them

00:46:30,240 --> 00:46:36,079
um in in our custom

00:46:33,680 --> 00:46:38,240
error types or our create specific error

00:46:36,079 --> 00:46:40,960
types uh so that we can differentiate

00:46:38,240 --> 00:46:42,319
for apps for applications um custom

00:46:40,960 --> 00:46:43,599
areas should always implement

00:46:42,319 --> 00:46:46,160
the error trade from the standard

00:46:43,599 --> 00:46:48,240
library this is just important because

00:46:46,160 --> 00:46:49,359
it allows compatibility within the

00:46:48,240 --> 00:46:52,160
ecosystem so

00:46:49,359 --> 00:46:53,520
before there was a popular crate called

00:46:52,160 --> 00:46:56,640
failure which had its own

00:46:53,520 --> 00:46:58,240
trait fail and it caused a lot of like

00:46:56,640 --> 00:46:59,599
compatibility issues

00:46:58,240 --> 00:47:02,160
at the application level when we're

00:46:59,599 --> 00:47:04,960
trying to stitch different uh

00:47:02,160 --> 00:47:08,000
libraries together um and so you're kind

00:47:04,960 --> 00:47:09,520
of like iterated and settled on

00:47:08,000 --> 00:47:11,119
always implementing the error trade from

00:47:09,520 --> 00:47:14,240
standard library and which just

00:47:11,119 --> 00:47:17,680
again improves the developer experience

00:47:14,240 --> 00:47:20,880
and then ideally um errors

00:47:17,680 --> 00:47:23,760
in a library should never panic um

00:47:20,880 --> 00:47:24,079
or library should never panic it's it's

00:47:23,760 --> 00:47:26,559
kind

00:47:24,079 --> 00:47:27,280
of against you know what you would

00:47:26,559 --> 00:47:29,440
expect

00:47:27,280 --> 00:47:31,440
for a library call to like crash your

00:47:29,440 --> 00:47:32,559
program and so instead you would want to

00:47:31,440 --> 00:47:34,960
return errors

00:47:32,559 --> 00:47:36,640
and the caller can enhance it

00:47:34,960 --> 00:47:39,200
applications are bit different so in

00:47:36,640 --> 00:47:42,079
applications they consume errors

00:47:39,200 --> 00:47:43,839
and their task is to make informed

00:47:42,079 --> 00:47:46,800
decisions on how to handle

00:47:43,839 --> 00:47:47,359
those areas so they're at the level

00:47:46,800 --> 00:47:49,040
where they

00:47:47,359 --> 00:47:51,680
obviously are operating in the context

00:47:49,040 --> 00:47:53,520
that they're in and and

00:47:51,680 --> 00:47:55,119
can decide how to handle certain

00:47:53,520 --> 00:47:57,599
situations depending on on

00:47:55,119 --> 00:47:58,160
obviously what's happening uh they can

00:47:57,599 --> 00:47:59,760
panic

00:47:58,160 --> 00:48:01,280
uh so at the application level you know

00:47:59,760 --> 00:48:02,079
if we come to a scenario that we don't

00:48:01,280 --> 00:48:04,559
know how to handle

00:48:02,079 --> 00:48:05,680
it's easy to say you know raise hands

00:48:04,559 --> 00:48:08,079
and uh

00:48:05,680 --> 00:48:09,040
and and just panic and crash at that

00:48:08,079 --> 00:48:10,720
point

00:48:09,040 --> 00:48:12,079
and they're also responsible for

00:48:10,720 --> 00:48:14,319
deciding how errors and

00:48:12,079 --> 00:48:15,839
uh formatted and displayed to use so

00:48:14,319 --> 00:48:16,400
effectively like how they communicated

00:48:15,839 --> 00:48:20,400
to

00:48:16,400 --> 00:48:22,720
to the user so for an

00:48:20,400 --> 00:48:24,160
an application like adding context is

00:48:22,720 --> 00:48:26,640
extremely important

00:48:24,160 --> 00:48:28,240
so walking through that areas need to

00:48:26,640 --> 00:48:29,359
include the context in which they were

00:48:28,240 --> 00:48:31,680
generated

00:48:29,359 --> 00:48:32,880
uh this provides developers clarity on

00:48:31,680 --> 00:48:35,040
the error case

00:48:32,880 --> 00:48:37,119
and it improves our ability to discover

00:48:35,040 --> 00:48:40,800
and diagnose failure cases

00:48:37,119 --> 00:48:42,319
so um like obviously this is the

00:48:40,800 --> 00:48:44,720
question of like what does that mean

00:48:42,319 --> 00:48:46,160
so just walking through an example sort

00:48:44,720 --> 00:48:48,319
of situation so

00:48:46,160 --> 00:48:49,920
in this first case we have this error no

00:48:48,319 --> 00:48:51,920
such file directory

00:48:49,920 --> 00:48:53,280
which is not extremely informative we

00:48:51,920 --> 00:48:55,440
don't really know you know

00:48:53,280 --> 00:48:57,839
where it came from or like where in the

00:48:55,440 --> 00:48:59,920
lab would like when the code came from

00:48:57,839 --> 00:49:02,480
what file or directory it was whether

00:48:59,920 --> 00:49:03,680
it's a file or a directory um

00:49:02,480 --> 00:49:05,119
and so we're kind of like left

00:49:03,680 --> 00:49:07,040
open-ended with the fact that we just

00:49:05,119 --> 00:49:09,760
know we've got this we try to do some

00:49:07,040 --> 00:49:10,240
eye operation um but there's not too

00:49:09,760 --> 00:49:12,240
much

00:49:10,240 --> 00:49:13,359
to that so we can improve that for

00:49:12,240 --> 00:49:15,680
instance by adding

00:49:13,359 --> 00:49:16,880
um you know the the file that we failed

00:49:15,680 --> 00:49:18,800
to read

00:49:16,880 --> 00:49:20,359
so in this case we get the error failed

00:49:18,800 --> 00:49:24,000
to read file which is

00:49:20,359 --> 00:49:26,480
fairest.txt um and this was caused

00:49:24,000 --> 00:49:27,839
again by this uh no such file directory

00:49:26,480 --> 00:49:29,920
so in this case

00:49:27,839 --> 00:49:31,839
um obviously what's nice is that we're

00:49:29,920 --> 00:49:34,160
able to say you know which file

00:49:31,839 --> 00:49:35,839
uh we were trying to read and which one

00:49:34,160 --> 00:49:39,359
failed

00:49:35,839 --> 00:49:41,040
um and then in this in this case we can

00:49:39,359 --> 00:49:43,119
augment this even more by adding for

00:49:41,040 --> 00:49:44,480
instance like a back trace just as an

00:49:43,119 --> 00:49:47,200
example and so

00:49:44,480 --> 00:49:48,160
you know that again adds more context

00:49:47,200 --> 00:49:51,920
and information

00:49:48,160 --> 00:49:53,119
to uh to the error report in this case

00:49:51,920 --> 00:49:55,359
and then we can think of other things

00:49:53,119 --> 00:49:57,200
like in this case there's no location

00:49:55,359 --> 00:49:59,200
um in the code where this error occurred

00:49:57,200 --> 00:50:00,880
so we can add something like that

00:49:59,200 --> 00:50:02,800
um we could add a suggestion for

00:50:00,880 --> 00:50:05,920
instance like

00:50:02,800 --> 00:50:07,760
create the file ferrous.txt um

00:50:05,920 --> 00:50:09,200
and so you know in those in those cases

00:50:07,760 --> 00:50:10,559
we can keep thinking about how we can

00:50:09,200 --> 00:50:11,200
make these error reports or error

00:50:10,559 --> 00:50:14,000
messages

00:50:11,200 --> 00:50:15,440
way more informative at the application

00:50:14,000 --> 00:50:18,559
and that adds context

00:50:15,440 --> 00:50:19,440
to what's happening so for a library

00:50:18,559 --> 00:50:21,119
custom errors

00:50:19,440 --> 00:50:22,720
again are the most important thing again

00:50:21,119 --> 00:50:24,720
that model like your domain

00:50:22,720 --> 00:50:25,920
um and communicate exactly the kinds of

00:50:24,720 --> 00:50:29,119
areas that happen in your term

00:50:25,920 --> 00:50:32,000
so just walking through an example again

00:50:29,119 --> 00:50:32,960
um in this case we're just using this

00:50:32,000 --> 00:50:36,640
area which is a

00:50:32,960 --> 00:50:37,440
which is one of the commonly used crates

00:50:36,640 --> 00:50:40,160
in the

00:50:37,440 --> 00:50:41,200
rust ecosystem for creating like custom

00:50:40,160 --> 00:50:43,359
errors

00:50:41,200 --> 00:50:44,960
um and in this case we have this beat

00:50:43,359 --> 00:50:47,280
maker error so

00:50:44,960 --> 00:50:49,520
um some of the areas that we have is

00:50:47,280 --> 00:50:52,400
like invalid notes invalid format

00:50:49,520 --> 00:50:53,680
and an invalid instrument name whatever

00:50:52,400 --> 00:50:56,000
and then

00:50:53,680 --> 00:50:56,720
an interesting one here is that we can

00:50:56,000 --> 00:50:58,960
wrap all

00:50:56,720 --> 00:51:01,680
i o errors from the standard library and

00:50:58,960 --> 00:51:04,880
into like our own i o error type

00:51:01,680 --> 00:51:06,240
uh in in our beat maker era and so that

00:51:04,880 --> 00:51:08,000
just speaks to again that

00:51:06,240 --> 00:51:10,079
that idea of wrapping errors so that we

00:51:08,000 --> 00:51:15,440
know that these eye errors came from

00:51:10,079 --> 00:51:15,440
like the speed maker library

00:51:15,839 --> 00:51:22,480
so uh this is yeah this is just a

00:51:19,599 --> 00:51:24,880
simple trivial case of using um that

00:51:22,480 --> 00:51:27,359
error so in this

00:51:24,880 --> 00:51:30,319
function called raise we have a result

00:51:27,359 --> 00:51:32,720
which returns it or

00:51:30,319 --> 00:51:34,720
can't have a beatmaker error um and

00:51:32,720 --> 00:51:36,640
that's in this case just returned simply

00:51:34,720 --> 00:51:41,520
just for the sake of this

00:51:36,640 --> 00:51:43,680
and here we just match on on that

00:51:41,520 --> 00:51:45,520
on that function call and so if it's

00:51:43,680 --> 00:51:48,480
okay i mean write a data and then

00:51:45,520 --> 00:51:50,160
write a message and if it's an error

00:51:48,480 --> 00:51:50,640
then we're too lazy to write better

00:51:50,160 --> 00:51:54,000
errors

00:51:50,640 --> 00:51:57,599
um so we get it um cool

00:51:54,000 --> 00:52:00,000
and then uh in this case we have it for

00:51:57,599 --> 00:52:03,680
an io error so what's really cool here

00:52:00,000 --> 00:52:05,050
um is that we can return

00:52:03,680 --> 00:52:06,880
an io error from

00:52:05,050 --> 00:52:09,359
[Music]

00:52:06,880 --> 00:52:10,400
in this case like file.open or file open

00:52:09,359 --> 00:52:12,960
um

00:52:10,400 --> 00:52:14,480
and this returns like an io from a

00:52:12,960 --> 00:52:15,599
standard library but because we've

00:52:14,480 --> 00:52:18,000
wrapped those errors

00:52:15,599 --> 00:52:19,200
we can still return like a beatmaker and

00:52:18,000 --> 00:52:22,400
so

00:52:19,200 --> 00:52:23,760
when we call this iras uh in this case

00:52:22,400 --> 00:52:27,280
we haven't like taken any

00:52:23,760 --> 00:52:30,559
uh knowledge of that um into use

00:52:27,280 --> 00:52:32,319
but we can we will know that that sort

00:52:30,559 --> 00:52:35,920
of eye era came from beat maker

00:52:32,319 --> 00:52:39,599
um and that allows us to to basically

00:52:35,920 --> 00:52:43,359
handle that um like higher errors from

00:52:39,599 --> 00:52:46,400
different crates quite easily um

00:52:43,359 --> 00:52:49,520
cool and so yeah wrapping up

00:52:46,400 --> 00:52:51,280
uh towards a better future so error

00:52:49,520 --> 00:52:53,680
reporting obviously can still be better

00:52:51,280 --> 00:52:54,559
um as with pretty much everything in

00:52:53,680 --> 00:52:56,079
that

00:52:54,559 --> 00:52:58,319
uh and some ways you can kind of think

00:52:56,079 --> 00:52:59,359
about that is making masked lead error

00:52:58,319 --> 00:53:02,720
reports so

00:52:59,359 --> 00:53:05,680
again not the rust compiler areas of

00:53:02,720 --> 00:53:06,079
like really great area reports um and

00:53:05,680 --> 00:53:07,680
that's

00:53:06,079 --> 00:53:09,680
and that's like best in class and kind

00:53:07,680 --> 00:53:11,200
of like the the future that we're

00:53:09,680 --> 00:53:14,319
thinking about here

00:53:11,200 --> 00:53:15,280
um providing suggestions to resolve

00:53:14,319 --> 00:53:16,960
errors as well

00:53:15,280 --> 00:53:18,880
so that's again something that the last

00:53:16,960 --> 00:53:21,520
compiler does and then

00:53:18,880 --> 00:53:22,559
just in general like jane lesby's air

00:53:21,520 --> 00:53:24,480
library is a

00:53:22,559 --> 00:53:26,079
experimental library that serves as a

00:53:24,480 --> 00:53:27,359
testbed for pushing the boundary on

00:53:26,079 --> 00:53:30,800
error reporting

00:53:27,359 --> 00:53:33,839
um and so i'm just going to do like

00:53:30,800 --> 00:53:35,119
two sort of like error reports that come

00:53:33,839 --> 00:53:36,720
from that library which

00:53:35,119 --> 00:53:39,599
are really cool in my opinion so in this

00:53:36,720 --> 00:53:42,960
case um we have an error

00:53:39,599 --> 00:53:44,400
and you know it's like

00:53:42,960 --> 00:53:46,720
it just describes what's happened so

00:53:44,400 --> 00:53:49,520
unable to read the conflict and then

00:53:46,720 --> 00:53:49,839
command exited so we get like an error

00:53:49,520 --> 00:53:51,680
uh

00:53:49,839 --> 00:53:52,880
messages then we get the location which

00:53:51,680 --> 00:53:54,800
is something that

00:53:52,880 --> 00:53:56,000
i mentioned earlier that we can sort of

00:53:54,800 --> 00:53:59,200
like augment to

00:53:56,000 --> 00:54:00,160
our um error messages so in this case we

00:53:59,200 --> 00:54:03,119
get this

00:54:00,160 --> 00:54:04,000
location uh then we get the the standard

00:54:03,119 --> 00:54:06,720
error

00:54:04,000 --> 00:54:07,520
error so no such file directory we get a

00:54:06,720 --> 00:54:09,440
back trace

00:54:07,520 --> 00:54:10,559
which is in this case really nicely

00:54:09,440 --> 00:54:12,160
formatted

00:54:10,559 --> 00:54:14,319
and then at the end we get a suggestion

00:54:12,160 --> 00:54:16,319
so try using a file that exits next time

00:54:14,319 --> 00:54:17,920
obviously um and that's really that's

00:54:16,319 --> 00:54:20,079
really nice gives a lot of context

00:54:17,920 --> 00:54:21,040
and a lot of information as to what

00:54:20,079 --> 00:54:22,960
happened

00:54:21,040 --> 00:54:24,640
um and kind of and kind of gives you

00:54:22,960 --> 00:54:27,280
like all of the necessary

00:54:24,640 --> 00:54:28,400
uh pieces of information to go from

00:54:27,280 --> 00:54:30,640
their reports

00:54:28,400 --> 00:54:31,839
sorted out directly to fixing your error

00:54:30,640 --> 00:54:35,520
without having to do

00:54:31,839 --> 00:54:38,079
too much uh extra leg work basically

00:54:35,520 --> 00:54:38,960
and then just another cool example here

00:54:38,079 --> 00:54:40,799
where

00:54:38,960 --> 00:54:42,319
in this case we're chaining errors so

00:54:40,799 --> 00:54:44,400
multiple errors happened

00:54:42,319 --> 00:54:47,119
um which is the first area that we got

00:54:44,400 --> 00:54:48,559
here and also gives us the location

00:54:47,119 --> 00:54:50,240
and in this case then we get these

00:54:48,559 --> 00:54:51,920
chains of error so that the task cannot

00:54:50,240 --> 00:54:54,079
be completed

00:54:51,920 --> 00:54:55,200
the machine's unreadable or unreachable

00:54:54,079 --> 00:54:58,640
sorry and

00:54:55,200 --> 00:55:00,160
the file could not be passed and um

00:54:58,640 --> 00:55:01,760
that's really cool so now we've got this

00:55:00,160 --> 00:55:03,920
like really informative uh

00:55:01,760 --> 00:55:05,119
again error report that kind of like

00:55:03,920 --> 00:55:08,000
walks through you know the

00:55:05,119 --> 00:55:09,599
the the sequence of errors happened and

00:55:08,000 --> 00:55:11,119
and it's like nicely formatted and easy

00:55:09,599 --> 00:55:12,160
to read and again just reduces the

00:55:11,119 --> 00:55:14,319
amount of like

00:55:12,160 --> 00:55:16,000
extra network that you have to do to go

00:55:14,319 --> 00:55:18,799
from error report

00:55:16,000 --> 00:55:19,760
to debugging your issue and or fixing

00:55:18,799 --> 00:55:22,000
your issue

00:55:19,760 --> 00:55:23,520
so yeah that's basically that's

00:55:22,000 --> 00:55:26,880
basically it thank you

00:55:23,520 --> 00:55:27,359
um so yeah again just the the main thing

00:55:26,880 --> 00:55:29,680
about

00:55:27,359 --> 00:55:31,040
uh this talk again just highlighting

00:55:29,680 --> 00:55:31,839
that error handling really is about

00:55:31,040 --> 00:55:34,079
communication

00:55:31,839 --> 00:55:34,960
and that that's the end goal um when

00:55:34,079 --> 00:55:36,319
we're writing

00:55:34,960 --> 00:55:37,760
errors and in our libraries and

00:55:36,319 --> 00:55:38,720
applications is really just to be able

00:55:37,760 --> 00:55:40,480
to tell

00:55:38,720 --> 00:55:42,000
or communicate to other developers like

00:55:40,480 --> 00:55:48,640
this is exactly um

00:55:42,000 --> 00:55:51,520
what went wrong cool thank you

00:55:48,640 --> 00:55:52,799
thank you senor um we have a couple of

00:55:51,520 --> 00:55:56,160
questions coming up

00:55:52,799 --> 00:55:57,680
so the first one is how do you determine

00:55:56,160 --> 00:56:00,079
which error type

00:55:57,680 --> 00:56:02,480
e should be whether it is an i o error

00:56:00,079 --> 00:56:04,559
or something else

00:56:02,480 --> 00:56:05,920
uh i'm not too sure i understand the

00:56:04,559 --> 00:56:10,640
question too well

00:56:05,920 --> 00:56:12,480
but i mean that that would come from you

00:56:10,640 --> 00:56:16,880
like obviously if a certain function

00:56:12,480 --> 00:56:18,000
call um returns a certain error then

00:56:16,880 --> 00:56:20,640
obviously you know that e

00:56:18,000 --> 00:56:21,760
is that error otherwise you define them

00:56:20,640 --> 00:56:25,119
yourself

00:56:21,760 --> 00:56:27,200
um and then can handle that logic uh

00:56:25,119 --> 00:56:28,640
depending on what you've chosen um i

00:56:27,200 --> 00:56:31,680
don't know if that answers the question

00:56:28,640 --> 00:56:35,119
well enough but yeah

00:56:31,680 --> 00:56:36,480
all right so the next question is i try

00:56:35,119 --> 00:56:40,160
to use

00:56:36,480 --> 00:56:43,040
always expects instead of on wrap

00:56:40,160 --> 00:56:43,280
do you use unwrapped often do you have

00:56:43,040 --> 00:56:45,520
an

00:56:43,280 --> 00:56:46,480
adult heuristic to decide when to use

00:56:45,520 --> 00:56:50,240
expect

00:56:46,480 --> 00:56:52,880
or on rap so

00:56:50,240 --> 00:56:53,359
for me like i cut like and also i think

00:56:52,880 --> 00:56:54,720
just

00:56:53,359 --> 00:56:56,799
pushed by the rust communities like

00:56:54,720 --> 00:56:59,920
unwrap usually is

00:56:56,799 --> 00:57:02,319
only used for sort of like prototyping

00:56:59,920 --> 00:57:04,480
or when you just you know when you think

00:57:02,319 --> 00:57:07,599
sort of like development but ideally

00:57:04,480 --> 00:57:10,079
um you wouldn't you wouldn't use it

00:57:07,599 --> 00:57:10,880
ever really in production code the only

00:57:10,079 --> 00:57:14,000
cases where

00:57:10,880 --> 00:57:17,520
i do know it's often used is

00:57:14,000 --> 00:57:19,440
uh when you don't expect something

00:57:17,520 --> 00:57:21,280
to occur and like there's pretty much

00:57:19,440 --> 00:57:22,160
like a guarantee not even that you don't

00:57:21,280 --> 00:57:23,760
expect to go in

00:57:22,160 --> 00:57:25,280
it should never occur or never does

00:57:23,760 --> 00:57:26,000
occur really so if you have like a

00:57:25,280 --> 00:57:27,839
strong guarantee

00:57:26,000 --> 00:57:29,520
that this thing will always uh work then

00:57:27,839 --> 00:57:31,839
you can just use tottenham

00:57:29,520 --> 00:57:33,200
but in those cases i think using expect

00:57:31,839 --> 00:57:35,359
is probably better than unwrapped

00:57:33,200 --> 00:57:36,400
just in the event that something goes

00:57:35,359 --> 00:57:39,280
wrong um

00:57:36,400 --> 00:57:41,040
and then you do get like a uh at least

00:57:39,280 --> 00:57:45,280
some sort of like error message back

00:57:41,040 --> 00:57:47,520
basically cool

00:57:45,280 --> 00:57:48,559
yes so on feedback for the first

00:57:47,520 --> 00:57:50,240
question yes

00:57:48,559 --> 00:57:52,319
it was already answered during the

00:57:50,240 --> 00:57:54,079
presentation and the last question we

00:57:52,319 --> 00:57:56,079
have so far is

00:57:54,079 --> 00:57:58,079
do you have an opinion on the crate

00:57:56,079 --> 00:58:00,079
anyhow

00:57:58,079 --> 00:58:01,839
oh yeah yeah so i should have mentioned

00:58:00,079 --> 00:58:06,319
that that was my mistake so

00:58:01,839 --> 00:58:06,319
this area is really good for um

00:58:06,480 --> 00:58:09,920
creating custom errors and that's like

00:58:07,920 --> 00:58:12,240
for the library context context

00:58:09,920 --> 00:58:13,280
and anyhow is for like applications so

00:58:12,240 --> 00:58:16,160
anyhow that's

00:58:13,280 --> 00:58:17,040
also like another commonly used uh

00:58:16,160 --> 00:58:20,240
really

00:58:17,040 --> 00:58:21,839
like um great i guess great

00:58:20,240 --> 00:58:23,520
use for application areas and so that

00:58:21,839 --> 00:58:24,079
one obviously allows you to add like

00:58:23,520 --> 00:58:26,160
those

00:58:24,079 --> 00:58:27,440
with context and that runs at the

00:58:26,160 --> 00:58:29,359
application level so when your

00:58:27,440 --> 00:58:30,960
application fails for any reason

00:58:29,359 --> 00:58:33,280
uh you get back a nice air report with

00:58:30,960 --> 00:58:34,240
your custom message and then whatever

00:58:33,280 --> 00:58:36,880
error happened

00:58:34,240 --> 00:58:37,839
that's from your library so of course

00:58:36,880 --> 00:58:42,240
yeah like i

00:58:37,839 --> 00:58:42,240
i really advise using it cool

00:58:45,680 --> 00:58:49,680
all right i think uh that's all we have

00:58:48,559 --> 00:58:51,599
thank you senior

00:58:49,680 --> 00:58:53,520
for the presentation that's all we have

00:58:51,599 --> 00:58:57,040
for the questions

00:58:53,520 --> 00:58:58,559
okay so thank you everyone the last talk

00:58:57,040 --> 00:59:00,720
for the night would be

00:58:58,559 --> 00:59:01,920
building cryptocurrency derivative

00:59:00,720 --> 00:59:04,960
exchange with

00:59:01,920 --> 00:59:07,280
rust and this one will be given by

00:59:04,960 --> 00:59:08,400
constantine and blast they are from

00:59:07,280 --> 00:59:11,119
collider

00:59:08,400 --> 00:59:13,440
collider is the first real-time settled

00:59:11,119 --> 00:59:16,240
cryptocurrency derivative exchange

00:59:13,440 --> 00:59:17,119
using the bitcoin traders can instantly

00:59:16,240 --> 00:59:20,160
open

00:59:17,119 --> 00:59:21,599
or closed position without exposing

00:59:20,160 --> 00:59:24,720
themselves to excess

00:59:21,599 --> 00:59:25,920
contemporary risk or hefty transaction

00:59:24,720 --> 00:59:32,880
fees

00:59:25,920 --> 00:59:47,359
so yes constant 10 plus up to you

00:59:32,880 --> 00:59:52,160
thanks evens let me just share my screen

00:59:47,359 --> 00:59:54,000
can everyone see my screen appreciation

00:59:52,160 --> 00:59:55,359
um sweet cool thanks evans for the

00:59:54,000 --> 00:59:58,240
introduction um

00:59:55,359 --> 00:59:59,280
and this is pretty much more a more

00:59:58,240 --> 01:00:02,319
applied

00:59:59,280 --> 01:00:03,440
talk about how rust is used in practice

01:00:02,319 --> 01:00:06,079
in a business sort of

01:00:03,440 --> 01:00:06,640
environment um so yeah i'm constantine

01:00:06,079 --> 01:00:09,280
i'm the

01:00:06,640 --> 01:00:09,760
co-founder of collider and pretty much

01:00:09,280 --> 01:00:12,400
everything

01:00:09,760 --> 01:00:13,280
even said we do it's not necessarily

01:00:12,400 --> 01:00:14,720
super important

01:00:13,280 --> 01:00:16,720
because it's a lot of like jargon that

01:00:14,720 --> 01:00:18,079
he threw in and i don't expect anyone to

01:00:16,720 --> 01:00:20,720
understand what he said

01:00:18,079 --> 01:00:21,839
um and so the aim of this talk is

01:00:20,720 --> 01:00:24,240
basically to do

01:00:21,839 --> 01:00:26,319
you basically share our experience with

01:00:24,240 --> 01:00:28,640
uh russ our love hate experience

01:00:26,319 --> 01:00:29,520
um because we have been used rust sort

01:00:28,640 --> 01:00:32,400
of in production

01:00:29,520 --> 01:00:32,720
uh since pretty much day one um and yeah

01:00:32,400 --> 01:00:34,799
so

01:00:32,720 --> 01:00:36,240
the talk is on uh building a derivative

01:00:34,799 --> 01:00:37,760
exchange in rust and

01:00:36,240 --> 01:00:39,280
first thing i i want to say it doesn't

01:00:37,760 --> 01:00:41,839
matter whether it's a derivative or

01:00:39,280 --> 01:00:42,400
an equity or stock stock exchange the

01:00:41,839 --> 01:00:44,480
basis

01:00:42,400 --> 01:00:45,680
is the same so i don't want you to be

01:00:44,480 --> 01:00:49,040
confused about derivatives

01:00:45,680 --> 01:00:50,160
basically just forget it uh uh from now

01:00:49,040 --> 01:00:52,480
on

01:00:50,160 --> 01:00:53,680
um and also i don't assume any knowledge

01:00:52,480 --> 01:00:56,000
of what an exchange is

01:00:53,680 --> 01:00:57,920
um you know because i guess it's also

01:00:56,000 --> 01:00:59,520
very specific uh to finance

01:00:57,920 --> 01:01:01,520
um so i'm just giving you a little

01:00:59,520 --> 01:01:03,599
primer on on what an exchange is

01:01:01,520 --> 01:01:04,640
and essentially what an exchange is um

01:01:03,599 --> 01:01:07,599
it's pretty much just

01:01:04,640 --> 01:01:08,480
you know a database uh which we call the

01:01:07,599 --> 01:01:10,480
order book

01:01:08,480 --> 01:01:12,240
where buyers and sellers come together

01:01:10,480 --> 01:01:14,319
to make an exchange of

01:01:12,240 --> 01:01:15,839
any type of good uh could be you could

01:01:14,319 --> 01:01:17,760
be a stock but it could be like apples

01:01:15,839 --> 01:01:19,200
or oranges it doesn't really matter

01:01:17,760 --> 01:01:21,760
but pretty much you have a buy and a

01:01:19,200 --> 01:01:24,400
seller and one wants to basically buy

01:01:21,760 --> 01:01:26,000
apples the other one wants to

01:01:24,400 --> 01:01:27,599
sell apples right so one wants to give

01:01:26,000 --> 01:01:29,119
the other person dollars for example and

01:01:27,599 --> 01:01:30,160
the other one wants to give apples four

01:01:29,119 --> 01:01:32,000
dollars

01:01:30,160 --> 01:01:33,440
and this order book is pretty much um

01:01:32,000 --> 01:01:34,480
just a place where you know they come

01:01:33,440 --> 01:01:37,440
together

01:01:34,480 --> 01:01:38,319
and the the task of the exchanges is

01:01:37,440 --> 01:01:40,319
pretty much

01:01:38,319 --> 01:01:41,680
uh matching these buyers and sellers uh

01:01:40,319 --> 01:01:44,079
together so basically

01:01:41,680 --> 01:01:45,040
uh making the the price discovery of the

01:01:44,079 --> 01:01:47,040
of the um

01:01:45,040 --> 01:01:48,400
exchange and when it happens um they

01:01:47,040 --> 01:01:50,880
match and at that point

01:01:48,400 --> 01:01:51,680
the exchange or the the trade becomes

01:01:50,880 --> 01:01:54,480
finalized

01:01:51,680 --> 01:01:55,039
and the two parties um exchange sort of

01:01:54,480 --> 01:01:57,440
the goods

01:01:55,039 --> 01:01:58,160
uh whatever it is apples oranges doesn't

01:01:57,440 --> 01:02:00,319
matter

01:01:58,160 --> 01:02:01,520
and then at that point the exchange sort

01:02:00,319 --> 01:02:03,680
of gets a small cut

01:02:01,520 --> 01:02:04,799
from that transaction and we call

01:02:03,680 --> 01:02:07,440
exchange fees

01:02:04,799 --> 01:02:09,200
and you know that is a very simple and

01:02:07,440 --> 01:02:10,960
beautiful business model because

01:02:09,200 --> 01:02:13,440
you know the exchange always makes money

01:02:10,960 --> 01:02:15,680
because it doesn't matter whether

01:02:13,440 --> 01:02:16,640
prices go up or down um they always take

01:02:15,680 --> 01:02:18,640
a small uh

01:02:16,640 --> 01:02:20,079
small cut of the money and you might be

01:02:18,640 --> 01:02:22,160
thinking now awesome

01:02:20,079 --> 01:02:24,160
you know i could do that you know i just

01:02:22,160 --> 01:02:25,920
set up a exchange you know get

01:02:24,160 --> 01:02:27,280
copy trading you know it's awesome

01:02:25,920 --> 01:02:28,799
because you know it's it's a very

01:02:27,280 --> 01:02:32,480
bulletproof business model

01:02:28,799 --> 01:02:34,319
but um uh you know um

01:02:32,480 --> 01:02:36,000
sorry that was actually uh i was i

01:02:34,319 --> 01:02:36,880
jumped this slide ahead but um

01:02:36,000 --> 01:02:38,640
yeah there's this basically this

01:02:36,880 --> 01:02:39,520
business model uh you know it attracts a

01:02:38,640 --> 01:02:40,960
lot of people because

01:02:39,520 --> 01:02:42,720
it's so simple and beautiful in a way

01:02:40,960 --> 01:02:43,359
and that that's basically it's the

01:02:42,720 --> 01:02:45,280
reason why

01:02:43,359 --> 01:02:48,480
the cryptocurrency of markets is it's

01:02:45,280 --> 01:02:51,599
massive um and you know last year

01:02:48,480 --> 01:02:53,280
um it tops uh 3.5 trillion dollars in

01:02:51,599 --> 01:02:55,280
volume which is basically

01:02:53,280 --> 01:02:56,960
saying that people traded 3.5 trillion

01:02:55,280 --> 01:02:58,799
dollars uh with each other

01:02:56,960 --> 01:03:01,039
which is amazing in a way and that's

01:02:58,799 --> 01:03:03,039
just cryptocurrency so financial markets

01:03:01,039 --> 01:03:04,559
um so traditional financial markets are

01:03:03,039 --> 01:03:06,559
not even included

01:03:04,559 --> 01:03:07,760
money what i was going to say is that

01:03:06,559 --> 01:03:09,599
you know this is great

01:03:07,760 --> 01:03:11,440
um in a way you know everyone could just

01:03:09,599 --> 01:03:11,920
build an exchange and get people to

01:03:11,440 --> 01:03:13,280
trade

01:03:11,920 --> 01:03:15,119
but you know the truth of the matter is

01:03:13,280 --> 01:03:16,559
it's quite hard actually

01:03:15,119 --> 01:03:18,559
and that's sort of what we experienced

01:03:16,559 --> 01:03:20,640
you know sort of first-handed um

01:03:18,559 --> 01:03:22,480
and why is it hard well you know first

01:03:20,640 --> 01:03:23,200
of you really have to process a lot of

01:03:22,480 --> 01:03:26,480
messages

01:03:23,200 --> 01:03:28,559
uh when people trade um and the whole

01:03:26,480 --> 01:03:30,160
process is really hard to parallelize

01:03:28,559 --> 01:03:31,920
um just to give you an example of like a

01:03:30,160 --> 01:03:34,720
decent sort of like exchange

01:03:31,920 --> 01:03:36,319
uh it's not even like a fast exchange um

01:03:34,720 --> 01:03:37,359
you have to be able to process 1000

01:03:36,319 --> 01:03:40,319
measures per second

01:03:37,359 --> 01:03:41,839
um you have to sustain a capacity of 5

01:03:40,319 --> 01:03:43,760
000 orders per second

01:03:41,839 --> 01:03:44,880
and you average trade latency which

01:03:43,760 --> 01:03:47,599
means the

01:03:44,880 --> 01:03:48,240
the time it takes uh from uh submission

01:03:47,599 --> 01:03:50,640
of the order

01:03:48,240 --> 01:03:52,240
to response uh you know shouldn't take

01:03:50,640 --> 01:03:54,000
longer than three milliseconds

01:03:52,240 --> 01:03:56,319
uh and that's basically wherever you are

01:03:54,000 --> 01:03:59,280
on the uh sort of in the world

01:03:56,319 --> 01:03:59,920
um and a lot of money is on the line uh

01:03:59,280 --> 01:04:03,280
which

01:03:59,920 --> 01:04:05,280
means um uh you're dealing with you know

01:04:03,280 --> 01:04:06,640
people's money uh so you have precise

01:04:05,280 --> 01:04:07,680
you have to be correct you have to be

01:04:06,640 --> 01:04:09,440
deterministic and

01:04:07,680 --> 01:04:11,440
whatever you do uh just to give you a

01:04:09,440 --> 01:04:13,200
little example uh the

01:04:11,440 --> 01:04:15,760
the five largest exchange and

01:04:13,200 --> 01:04:16,559
derivatives uh in crypto uh they d they

01:04:15,760 --> 01:04:18,880
process

01:04:16,559 --> 01:04:20,640
uh 200 billion dollars in um in

01:04:18,880 --> 01:04:24,160
transactions every day

01:04:20,640 --> 01:04:27,280
um so yeah it is very small sort of

01:04:24,160 --> 01:04:28,880
um sort of a margin of error uh

01:04:27,280 --> 01:04:30,319
and another thing is that you have to

01:04:28,880 --> 01:04:32,000
guarantee fairness audibility and

01:04:30,319 --> 01:04:33,920
availability and that's just

01:04:32,000 --> 01:04:35,760
to make sure you know people sort of

01:04:33,920 --> 01:04:37,920
come come back because

01:04:35,760 --> 01:04:40,559
um you cannot allow people to queue jump

01:04:37,920 --> 01:04:42,240
um you know front running uh you have to

01:04:40,559 --> 01:04:43,839
be audible and that's because

01:04:42,240 --> 01:04:46,319
in every transaction needs to be sort of

01:04:43,839 --> 01:04:48,240
traceable um that's again from

01:04:46,319 --> 01:04:49,760
from the from a regulation part but also

01:04:48,240 --> 01:04:52,240
you know in instances where

01:04:49,760 --> 01:04:53,119
your your platform crashes you have to

01:04:52,240 --> 01:04:55,440
basically

01:04:53,119 --> 01:04:56,400
be able to reverse every you know state

01:04:55,440 --> 01:04:58,079
in the system

01:04:56,400 --> 01:04:59,920
and you have to be highly available uh

01:04:58,079 --> 01:05:02,640
with what means that you know

01:04:59,920 --> 01:05:03,920
this this platform has to run 24 7 um

01:05:02,640 --> 01:05:05,680
seven days a week

01:05:03,920 --> 01:05:07,680
uh and it can never go down because you

01:05:05,680 --> 01:05:10,799
know a second uh of sort of outage

01:05:07,680 --> 01:05:12,319
that means you lose revenue um and

01:05:10,799 --> 01:05:13,839
you're constantly under attack

01:05:12,319 --> 01:05:15,680
and that's because you know you are sort

01:05:13,839 --> 01:05:16,400
of a honey pot um you're dealing with a

01:05:15,680 --> 01:05:18,160
lot of money

01:05:16,400 --> 01:05:20,000
you so have a lot of money and people

01:05:18,160 --> 01:05:22,240
try to either steal it from you

01:05:20,000 --> 01:05:23,839
or they try to um you know gain your

01:05:22,240 --> 01:05:26,799
system you know if there's a little

01:05:23,839 --> 01:05:27,520
bug in it you can imagine um that you

01:05:26,799 --> 01:05:29,520
know

01:05:27,520 --> 01:05:31,760
a small you know a small bug in a small

01:05:29,520 --> 01:05:33,280
transaction um

01:05:31,760 --> 01:05:34,640
error can lead to like massive amounts

01:05:33,280 --> 01:05:36,400
of money you know if you repeat it like

01:05:34,640 --> 01:05:38,000
millions of times

01:05:36,400 --> 01:05:39,680
and there are many stories about about

01:05:38,000 --> 01:05:43,680
these these problems

01:05:39,680 --> 01:05:45,760
um so yeah i'll hand you over to blas

01:05:43,680 --> 01:05:47,119
to basically explain or share with you

01:05:45,760 --> 01:05:50,799
some problems that we face

01:05:47,119 --> 01:05:54,160
uh running this platform

01:05:50,799 --> 01:05:55,680
yes so essentially

01:05:54,160 --> 01:05:58,160
trying to put in practice a bit all

01:05:55,680 --> 01:05:59,680
these points that constantly mention in

01:05:58,160 --> 01:06:02,079
terms of why it is so hard to

01:05:59,680 --> 01:06:02,960
to build an exchange i like to go a bit

01:06:02,079 --> 01:06:06,720
more

01:06:02,960 --> 01:06:08,960
lower level and explain some of these

01:06:06,720 --> 01:06:10,079
particular issues that we we have been

01:06:08,960 --> 01:06:13,280
dealing with and

01:06:10,079 --> 01:06:16,319
why they are relevant to us and uh

01:06:13,280 --> 01:06:16,960
also somehow how we try to go around

01:06:16,319 --> 01:06:20,160
them

01:06:16,960 --> 01:06:22,240
so the first one is um whenever we

01:06:20,160 --> 01:06:23,920
need to deal with money accountancy and

01:06:22,240 --> 01:06:26,079
everything we have to

01:06:23,920 --> 01:06:27,839
um think okay how we're going to model

01:06:26,079 --> 01:06:29,680
um these accounts

01:06:27,839 --> 01:06:32,160
and one of the problems that we do have

01:06:29,680 --> 01:06:35,359
is a floating point

01:06:32,160 --> 01:06:37,520
is first is not even

01:06:35,359 --> 01:06:39,039
like the steps between each of the the

01:06:37,520 --> 01:06:39,839
different points on the on the sort of

01:06:39,039 --> 01:06:42,559
the

01:06:39,839 --> 01:06:43,839
the the line so so you actually have to

01:06:42,559 --> 01:06:46,880
go into something that you

01:06:43,839 --> 01:06:51,119
control more and understand which is

01:06:46,880 --> 01:06:53,760
in this case the decimal um

01:06:51,119 --> 01:06:55,359
expression but essentially that that

01:06:53,760 --> 01:06:56,640
means that you're moving from a lot of

01:06:55,359 --> 01:06:59,280
good things

01:06:56,640 --> 01:07:00,160
that hardware gives you and a lot of

01:06:59,280 --> 01:07:01,520
auditability

01:07:00,160 --> 01:07:04,079
and things that work across all

01:07:01,520 --> 01:07:06,240
platforms and you somehow model

01:07:04,079 --> 01:07:07,680
your problem a bit more with hardware

01:07:06,240 --> 01:07:10,559
software instead of hardware

01:07:07,680 --> 01:07:11,280
and essentially a lot of um things that

01:07:10,559 --> 01:07:12,960
you thought

01:07:11,280 --> 01:07:14,720
they were in certain way they're not

01:07:12,960 --> 01:07:17,760
necessarily like this also you

01:07:14,720 --> 01:07:20,960
you have uh sometimes issues with

01:07:17,760 --> 01:07:21,599
the library panicking um and it's funny

01:07:20,960 --> 01:07:23,920
because

01:07:21,599 --> 01:07:25,359
this is something we talked uh it was

01:07:23,920 --> 01:07:26,559
mentioned before the library soon panic

01:07:25,359 --> 01:07:28,480
but essentially

01:07:26,559 --> 01:07:30,400
this is an issue that we do have

01:07:28,480 --> 01:07:32,480
sometimes and particularly something we

01:07:30,400 --> 01:07:34,160
i wanted to to mention is that uh when

01:07:32,480 --> 01:07:36,000
we think of floating point

01:07:34,160 --> 01:07:37,599
um operations uh one thing they are

01:07:36,000 --> 01:07:40,880
constant time so

01:07:37,599 --> 01:07:43,839
one can think of them as being free but

01:07:40,880 --> 01:07:45,200
for us it happened once um that we were

01:07:43,839 --> 01:07:47,440
doing a benchmark

01:07:45,200 --> 01:07:48,799
uh let me show you the flame graph that

01:07:47,440 --> 01:07:51,839
um

01:07:48,799 --> 01:07:54,880
we had on on our on our benchmarking and

01:07:51,839 --> 01:07:57,200
and as you can see uh this is this is

01:07:54,880 --> 01:07:59,599
one method but it's quite important one

01:07:57,200 --> 01:08:01,520
and you can see like on top of it it

01:07:59,599 --> 01:08:02,880
appears all the time rust decimal that

01:08:01,520 --> 01:08:05,119
was one of the crates that we use

01:08:02,880 --> 01:08:06,000
and particularly we saw the the division

01:08:05,119 --> 01:08:09,440
operation

01:08:06,000 --> 01:08:11,440
was very very expensive um

01:08:09,440 --> 01:08:12,640
so so then we started like investigating

01:08:11,440 --> 01:08:15,599
uh and

01:08:12,640 --> 01:08:16,319
fortunately they they they submit a

01:08:15,599 --> 01:08:19,120
patch

01:08:16,319 --> 01:08:19,679
uh that actually changed our profile

01:08:19,120 --> 01:08:22,880
into

01:08:19,679 --> 01:08:24,480
uh you can see the the after um

01:08:22,880 --> 01:08:25,920
something a bit more what we expected

01:08:24,480 --> 01:08:28,480
and we we

01:08:25,920 --> 01:08:30,719
actually for this method were able to go

01:08:28,480 --> 01:08:33,759
five times faster

01:08:30,719 --> 01:08:36,319
which actually was was amazing um

01:08:33,759 --> 01:08:38,000
but essentially what i want to try to

01:08:36,319 --> 01:08:40,880
say again is that

01:08:38,000 --> 01:08:41,520
we do have problems in in parts of the

01:08:40,880 --> 01:08:43,520
code that

01:08:41,520 --> 01:08:44,880
sometimes we don't even think that would

01:08:43,520 --> 01:08:48,000
be an issue in terms of

01:08:44,880 --> 01:08:51,040
both um the result

01:08:48,000 --> 01:08:53,279
that it has to be um like

01:08:51,040 --> 01:08:54,880
what we expect but also uh the

01:08:53,279 --> 01:08:57,679
performance as well

01:08:54,880 --> 01:08:58,080
um another problem that we we face is

01:08:57,679 --> 01:09:00,640
that

01:08:58,080 --> 01:09:01,520
we need to somehow uh model parts of

01:09:00,640 --> 01:09:03,759
your system

01:09:01,520 --> 01:09:06,239
with the system uh so that we get this

01:09:03,759 --> 01:09:08,400
deterministic behavior

01:09:06,239 --> 01:09:09,839
why is that because we need to be able

01:09:08,400 --> 01:09:11,839
to to guarantee

01:09:09,839 --> 01:09:13,120
some of things that constitute mention

01:09:11,839 --> 01:09:14,880
but also

01:09:13,120 --> 01:09:17,759
in terms of like nobody jumping the

01:09:14,880 --> 01:09:19,759
queue or having weird behavior but

01:09:17,759 --> 01:09:21,759
also because we need to be able to to go

01:09:19,759 --> 01:09:23,920
back in time in case something

01:09:21,759 --> 01:09:25,600
breaks or also in order to be able to

01:09:23,920 --> 01:09:28,239
audit so

01:09:25,600 --> 01:09:29,759
one of the tools that we we use often is

01:09:28,239 --> 01:09:32,080
we replay the system

01:09:29,759 --> 01:09:32,880
perhaps offline in order to be able to

01:09:32,080 --> 01:09:35,679
to get to a

01:09:32,880 --> 01:09:36,719
certain state i know that okay how is

01:09:35,679 --> 01:09:39,520
the

01:09:36,719 --> 01:09:40,880
the the engine looking at this point

01:09:39,520 --> 01:09:42,400
what are the accounts

01:09:40,880 --> 01:09:45,440
uh what are the transactions what

01:09:42,400 --> 01:09:48,480
actually has been happening

01:09:45,440 --> 01:09:50,159
um and connected to this we need

01:09:48,480 --> 01:09:51,600
we need this mechanism to be actually

01:09:50,159 --> 01:09:54,800
safe and fast because

01:09:51,600 --> 01:09:57,360
we do this very often uh at times

01:09:54,800 --> 01:09:58,480
uh and and also this is a mechanism that

01:09:57,360 --> 01:10:01,120
we we use

01:09:58,480 --> 01:10:02,080
in the case of going down so whenever we

01:10:01,120 --> 01:10:04,960
need to actually

01:10:02,080 --> 01:10:05,760
recover from this uh event we actually

01:10:04,960 --> 01:10:08,320
need to

01:10:05,760 --> 01:10:09,600
happen make this happen as fast as we

01:10:08,320 --> 01:10:13,199
can

01:10:09,600 --> 01:10:16,000
and connected to high availability uh

01:10:13,199 --> 01:10:17,280
it is the problem of how do we replicate

01:10:16,000 --> 01:10:18,719
uh the different

01:10:17,280 --> 01:10:21,679
parts of our system how do we

01:10:18,719 --> 01:10:25,280
communicate uh between them how do we

01:10:21,679 --> 01:10:27,760
uh ensure that there's only one leader

01:10:25,280 --> 01:10:30,480
because we cannot have two parts of the

01:10:27,760 --> 01:10:32,560
system in certain areas talking to the

01:10:30,480 --> 01:10:34,480
market because then we duplicate

01:10:32,560 --> 01:10:36,719
uh let's say an order and that's not

01:10:34,480 --> 01:10:38,400
what we want um

01:10:36,719 --> 01:10:39,920
so that that actually poses a

01:10:38,400 --> 01:10:42,000
restriction on us

01:10:39,920 --> 01:10:43,199
in certain places of the code or a

01:10:42,000 --> 01:10:46,320
system where we cannot

01:10:43,199 --> 01:10:49,440
scale horizontally but only

01:10:46,320 --> 01:10:51,360
vertically uh and the and

01:10:49,440 --> 01:10:52,640
actually the delay the last issue that

01:10:51,360 --> 01:10:55,840
that we do have i mean

01:10:52,640 --> 01:10:59,199
as a sort of a common denominator is

01:10:55,840 --> 01:11:00,560
is io latency introduced by

01:10:59,199 --> 01:11:02,320
writing to the disk right into the

01:11:00,560 --> 01:11:05,520
database going to a network

01:11:02,320 --> 01:11:08,800
so we do need to think how do we log

01:11:05,520 --> 01:11:09,920
how do we persist data which databases

01:11:08,800 --> 01:11:12,159
do we use

01:11:09,920 --> 01:11:13,520
how do we actually go to the database

01:11:12,159 --> 01:11:15,679
how do we write because

01:11:13,520 --> 01:11:16,640
we can batch for instance but we need to

01:11:15,679 --> 01:11:19,120
be sure that

01:11:16,640 --> 01:11:21,040
when we batch the data is actually being

01:11:19,120 --> 01:11:21,600
written and if there was an issue we

01:11:21,040 --> 01:11:23,199
need to

01:11:21,600 --> 01:11:24,800
understand where it broke and

01:11:23,199 --> 01:11:26,880
communicate back to the system so that

01:11:24,800 --> 01:11:31,040
we can recover properly

01:11:26,880 --> 01:11:33,440
um so why why do we actually

01:11:31,040 --> 01:11:34,719
enjoy using rust for solving all these

01:11:33,440 --> 01:11:38,000
problems

01:11:34,719 --> 01:11:41,360
for us testing is is paramount

01:11:38,000 --> 01:11:43,840
we we sort of stand in every day

01:11:41,360 --> 01:11:45,440
on top of our tests they are the ones

01:11:43,840 --> 01:11:47,760
who kind of give us the guarantees

01:11:45,440 --> 01:11:48,640
that the system performs the way we we

01:11:47,760 --> 01:11:51,280
expect it to

01:11:48,640 --> 01:11:53,520
to be and both we we find rust like

01:11:51,280 --> 01:11:56,159
writing integration tests

01:11:53,520 --> 01:11:57,679
unit test is pretty nice the same with

01:11:56,159 --> 01:12:00,000
benchmarking

01:11:57,679 --> 01:12:01,120
whenever we want to test some some new

01:12:00,000 --> 01:12:03,920
feature or

01:12:01,120 --> 01:12:04,880
for regression we we find that the

01:12:03,920 --> 01:12:07,440
crates and

01:12:04,880 --> 01:12:09,440
the built-in support from cargo and the

01:12:07,440 --> 01:12:11,600
language is pretty nice

01:12:09,440 --> 01:12:13,360
we do use quite a lot interoperability

01:12:11,600 --> 01:12:15,679
from systems written in c

01:12:13,360 --> 01:12:16,960
or c plus plus that's also pretty nice

01:12:15,679 --> 01:12:19,440
because there's a ton of

01:12:16,960 --> 01:12:21,679
say safe wrappers that work really well

01:12:19,440 --> 01:12:23,760
we also make use

01:12:21,679 --> 01:12:26,480
in certain cases of meta programming

01:12:23,760 --> 01:12:29,840
particularly procedural macros

01:12:26,480 --> 01:12:32,880
and i mean downstream certainly a lot

01:12:29,840 --> 01:12:36,239
it's a blessing and i think

01:12:32,880 --> 01:12:38,400
something else we we make i mean

01:12:36,239 --> 01:12:40,239
good use of is the fact that there's a

01:12:38,400 --> 01:12:42,960
lot of crypto primitives and

01:12:40,239 --> 01:12:43,280
libraries that are built natively from

01:12:42,960 --> 01:12:46,400
like

01:12:43,280 --> 01:12:50,080
directly in rust um the cases

01:12:46,400 --> 01:12:53,360
for for example blockchain solana

01:12:50,080 --> 01:12:56,880
entirely works uh out of the box from

01:12:53,360 --> 01:12:57,199
the rust client a bit the the ugly part

01:12:56,880 --> 01:13:00,400
is

01:12:57,199 --> 01:13:02,880
that particularly for the

01:13:00,400 --> 01:13:04,960
the disadvantages that we we do have is

01:13:02,880 --> 01:13:08,159
that for the industry in which we are

01:13:04,960 --> 01:13:09,199
uh competitors and sort of the the

01:13:08,159 --> 01:13:11,679
status quo is

01:13:09,199 --> 01:13:13,040
is writing everything in java and c plus

01:13:11,679 --> 01:13:17,120
plus

01:13:13,040 --> 01:13:19,760
and thereby we miss a lot of really

01:13:17,120 --> 01:13:20,719
performant and ergonomic libraries

01:13:19,760 --> 01:13:23,199
because they don't have

01:13:20,719 --> 01:13:23,760
necessarily clients written in ros there

01:13:23,199 --> 01:13:26,320
are some

01:13:23,760 --> 01:13:27,199
community available options but very far

01:13:26,320 --> 01:13:28,960
away from

01:13:27,199 --> 01:13:31,360
the the ones that are mainly supported

01:13:28,960 --> 01:13:33,520
by by the libraries

01:13:31,360 --> 01:13:34,960
the same we see with some core

01:13:33,520 --> 01:13:37,840
dependencies that we actually use

01:13:34,960 --> 01:13:40,080
they do have low maintenance because

01:13:37,840 --> 01:13:42,159
sometimes it's just somebody did it

01:13:40,080 --> 01:13:44,080
as a hobby and then we take it and we

01:13:42,159 --> 01:13:46,560
need to maintain it ourselves

01:13:44,080 --> 01:13:47,840
or rewrite it from scratch but it's not

01:13:46,560 --> 01:13:49,920
necessarily the optimal

01:13:47,840 --> 01:13:51,199
especially for startup uh and the last

01:13:49,920 --> 01:13:54,560
thing i is that

01:13:51,199 --> 01:13:56,640
we run a nightly uh and sometimes it is

01:13:54,560 --> 01:13:59,440
a bit more painful because

01:13:56,640 --> 01:14:01,040
we run leading edge which gives us a lot

01:13:59,440 --> 01:14:04,239
of features but that makes

01:14:01,040 --> 01:14:04,719
our builds break for apparently no

01:14:04,239 --> 01:14:06,320
reason

01:14:04,719 --> 01:14:08,239
of course then we need to adjust the

01:14:06,320 --> 01:14:12,320
code but it's it's been

01:14:08,239 --> 01:14:15,440
quite quite fine all in all uh yeah and

01:14:12,320 --> 01:14:17,600
that's it thank you um we

01:14:15,440 --> 01:14:18,960
we're looking for for good people to

01:14:17,600 --> 01:14:21,199
join us so

01:14:18,960 --> 01:14:24,719
if anybody wants to come in on board

01:14:21,199 --> 01:14:24,719
please go to collider xyz

01:14:25,120 --> 01:14:31,040
cool yeah i think that that is it for

01:14:28,640 --> 01:14:31,040
our talk

01:14:31,440 --> 01:14:34,719
thank you constantine thank you blast

01:14:33,520 --> 01:14:43,840
this was a nice

01:14:34,719 --> 01:14:43,840
presentation on blockchain

01:14:46,080 --> 01:14:50,000
yes thank you everyone for attending

01:14:48,719 --> 01:14:53,600
today i think

01:14:50,000 --> 01:14:57,520
uh we are at the end of our

01:14:53,600 --> 01:15:00,320
meet up and hopefully we want to see you

01:14:57,520 --> 01:15:02,320
next month and have a great time and

01:15:00,320 --> 01:15:03,520
again as a reminder we are looking for

01:15:02,320 --> 01:15:07,280
speakers

01:15:03,520 --> 01:15:08,159
if you you have a topic or a project to

01:15:07,280 --> 01:15:10,880
show off here

01:15:08,159 --> 01:15:11,760
would be happy and excited to hear from

01:15:10,880 --> 01:15:15,600
you

01:15:11,760 --> 01:15:19,280
uh i haven't seen any questions

01:15:15,600 --> 01:15:21,360
on the chat for the last talk

01:15:19,280 --> 01:15:23,040
but if you have questions before we

01:15:21,360 --> 01:15:28,480
close i think this is

01:15:23,040 --> 01:15:28,480

YouTube URL: https://www.youtube.com/watch?v=YbguuQzHcfk


