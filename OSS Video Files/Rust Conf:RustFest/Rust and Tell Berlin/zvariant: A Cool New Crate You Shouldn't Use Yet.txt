Title: zvariant: A Cool New Crate You Shouldn't Use Yet
Publication date: 2020-02-05
Playlist: Rust and Tell Berlin
Description: 
	From the Rust Berlin's January "Rust and Tell" Meetup (https://www.meetup.com/Rust-Berlin/)

Andrés Casablanca: https://twitter.com/castarco

Hosted at Prisma: https://www.prisma.io/

🎥 Filmed by iStream: http://www.istream.pl/
Captions: 
	00:00:03,859 --> 00:00:11,429
so hello everyone welcome to my talk

00:00:09,110 --> 00:00:14,519
first of all Who am I

00:00:11,429 --> 00:00:18,180
for those who know no no my name is ian

00:00:14,519 --> 00:00:19,500
ellie and i i'm a bit of a nomad from

00:00:18,180 --> 00:00:21,270
different countries and lived in

00:00:19,500 --> 00:00:23,430
different countries and have passports

00:00:21,270 --> 00:00:26,519
of different countries stuff and

00:00:23,430 --> 00:00:31,320
licenses from different countries it's a

00:00:26,519 --> 00:00:35,270
lot of fun these damager me work for

00:00:31,320 --> 00:00:35,270
this small company called red hat and

00:00:36,290 --> 00:00:44,760
and so a bit of background I give a talk

00:00:41,700 --> 00:00:47,579
about this topic a trust fast and and

00:00:44,760 --> 00:00:49,680
also in this Meetup like many months ago

00:00:47,579 --> 00:00:53,969
but at that time I hadn't made a lot of

00:00:49,680 --> 00:00:58,020
progress yet so so background for some a

00:00:53,969 --> 00:01:00,809
bit of recap for others I started this

00:00:58,020 --> 00:01:02,699
project called zaebis it's not called

00:01:00,809 --> 00:01:06,869
zebras is called zebras browser

00:01:02,699 --> 00:01:09,750
correctly please and what it does is

00:01:06,869 --> 00:01:11,670
like it's a Debus great Debus is a very

00:01:09,750 --> 00:01:14,640
efficient binary inter process

00:01:11,670 --> 00:01:18,090
communication protocol it was designed

00:01:14,640 --> 00:01:20,850
for desktop computers but it's also used

00:01:18,090 --> 00:01:22,590
a lot and embedded and I think these

00:01:20,850 --> 00:01:24,479
days it's used in embedded a lot more

00:01:22,590 --> 00:01:28,799
than a test well actually yeah as far as

00:01:24,479 --> 00:01:32,610
I know and I don't see why not

00:01:28,799 --> 00:01:37,220
it's very if it's a binary protocol and

00:01:32,610 --> 00:01:39,990
it has a wire format like how you what

00:01:37,220 --> 00:01:45,270
format you are you can communicate with

00:01:39,990 --> 00:01:48,329
Debus it's a specific format and that

00:01:45,270 --> 00:01:50,909
format is as I said efficient so it was

00:01:48,329 --> 00:01:53,240
used it was used by other projects as

00:01:50,909 --> 00:01:56,070
well like outside of Debus context and

00:01:53,240 --> 00:01:58,079
they call it G variant

00:01:56,070 --> 00:02:01,740
it's called G variant because it's the

00:01:58,079 --> 00:02:05,189
first API that was provided was by G Lib

00:02:01,740 --> 00:02:06,840
and G live has like always puts 2 G in

00:02:05,189 --> 00:02:09,860
front like I put Z in front of my

00:02:06,840 --> 00:02:13,160
perspective G in front of everything so

00:02:09,860 --> 00:02:16,100
but as

00:02:13,160 --> 00:02:18,080
well almost it's not exactly the wire

00:02:16,100 --> 00:02:20,450
format of Debus they made some changes

00:02:18,080 --> 00:02:23,330
to make it more efficient the hope I

00:02:20,450 --> 00:02:25,010
think was that those changes will be put

00:02:23,330 --> 00:02:27,230
back in the D bus back and the demos

00:02:25,010 --> 00:02:29,330
will change but by that time he was a

00:02:27,230 --> 00:02:31,820
spread so much changing this pack was

00:02:29,330 --> 00:02:34,310
too much of a hassle and that was too

00:02:31,820 --> 00:02:37,160
much disruption so G variant is slightly

00:02:34,310 --> 00:02:39,400
different from from Debus format but

00:02:37,160 --> 00:02:43,910
it's still based on the same format and

00:02:39,400 --> 00:02:45,200
stuff but it's used a lot for example if

00:02:43,910 --> 00:02:48,140
you have heard of this cult or the

00:02:45,200 --> 00:02:51,020
software called OS tree it's used in

00:02:48,140 --> 00:02:54,470
cloud a lot in these days cloud

00:02:51,020 --> 00:02:55,430
infrastructure world openshift depends

00:02:54,470 --> 00:02:58,310
on it

00:02:55,430 --> 00:03:02,090
in many different ways and it's it's a

00:02:58,310 --> 00:03:06,800
bunch of G variant in in files the way

00:03:02,090 --> 00:03:08,270
it stores objects also flat-pack I'm not

00:03:06,800 --> 00:03:11,120
going to go into details of what that is

00:03:08,270 --> 00:03:15,350
but check it out it's also uses the G

00:03:11,120 --> 00:03:18,170
variant and then there is ad account

00:03:15,350 --> 00:03:19,940
which is a configuration database simple

00:03:18,170 --> 00:03:25,250
configuration database and it also uses

00:03:19,940 --> 00:03:26,900
this so a lot of uses for this format G

00:03:25,250 --> 00:03:29,120
variant so I decided that it would be

00:03:26,900 --> 00:03:31,550
very useful for those people to use to

00:03:29,120 --> 00:03:34,310
have a separate crate for that format

00:03:31,550 --> 00:03:38,510
only regardless of whether they want to

00:03:34,310 --> 00:03:41,030
use D base or not so and it's before I

00:03:38,510 --> 00:03:43,640
could do dizzy bus I had to implement

00:03:41,030 --> 00:03:46,430
this anyway for for my project so I

00:03:43,640 --> 00:03:52,250
started working on this I named it well

00:03:46,430 --> 00:03:54,560
Zbyszko Z variant but I have to explain

00:03:52,250 --> 00:04:00,070
a bit to you what the format is before I

00:03:54,560 --> 00:04:03,050
can continue about crystalline talk it's

00:04:00,070 --> 00:04:06,520
it defines there's a spec a defines the

00:04:03,050 --> 00:04:09,980
data types it allows and the encoding

00:04:06,520 --> 00:04:11,990
and it uses natural alignment yeah I

00:04:09,980 --> 00:04:15,440
don't know if it does ever know what

00:04:11,990 --> 00:04:18,250
alignment means memory alignment okay

00:04:15,440 --> 00:04:20,840
well that's um that lease so there's

00:04:18,250 --> 00:04:25,530
some architects CPU architectures that

00:04:20,840 --> 00:04:28,430
can only read from aligned

00:04:25,530 --> 00:04:31,650
data so you there if they want to read

00:04:28,430 --> 00:04:33,750
data from memory it has to be aligned to

00:04:31,650 --> 00:04:36,240
specific sizes for example let's say 8

00:04:33,750 --> 00:04:39,510
bytes or 4 bytes or whatever the CPU

00:04:36,240 --> 00:04:41,940
says and in cases of other CPUs it's

00:04:39,510 --> 00:04:43,800
just more efficient if you keep your

00:04:41,940 --> 00:04:47,270
data aligned it's very efficient for the

00:04:43,800 --> 00:04:51,780
CPU to fetch and write data to memory

00:04:47,270 --> 00:04:53,910
and because of that Debus has memory

00:04:51,780 --> 00:04:57,770
alignment rules but they are very

00:04:53,910 --> 00:05:00,990
natural I'll show you that example later

00:04:57,770 --> 00:05:03,750
and all the data types have a signature

00:05:00,990 --> 00:05:06,840
so all the basic types it defines there

00:05:03,750 --> 00:05:08,580
is like one it's a string but all the

00:05:06,840 --> 00:05:11,750
basic types they have like one character

00:05:08,580 --> 00:05:16,830
that represents which what data it is

00:05:11,750 --> 00:05:20,430
and four basic types it's like for

00:05:16,830 --> 00:05:23,190
example for u8 it's y4i 16 it's T I

00:05:20,430 --> 00:05:25,470
think and stuff like that for us for

00:05:23,190 --> 00:05:28,440
string it's as and all the basic types

00:05:25,470 --> 00:05:33,260
of Rusted just changes map very well to

00:05:28,440 --> 00:05:35,910
to the deepest types fortunately for me

00:05:33,260 --> 00:05:39,510
and then there is containers which is

00:05:35,910 --> 00:05:42,230
not so easy but some are like a rape and

00:05:39,510 --> 00:05:45,570
structure which we have this those

00:05:42,230 --> 00:05:50,040
concepts in and rest of course and it is

00:05:45,570 --> 00:05:53,419
this a dictionary type and the most

00:05:50,040 --> 00:05:56,540
annoying one is a variant because

00:05:53,419 --> 00:05:59,370
sometimes you have to pass data that is

00:05:56,540 --> 00:06:01,200
dynamically typed so you you specify at

00:05:59,370 --> 00:06:01,890
runtime what it is you don't know

00:06:01,200 --> 00:06:06,030
beforehand

00:06:01,890 --> 00:06:08,730
for example there's an interface on a

00:06:06,030 --> 00:06:11,100
diva's standard interface like if you

00:06:08,730 --> 00:06:12,570
implement any service and Debus you have

00:06:11,100 --> 00:06:16,320
to implement this interface which is

00:06:12,570 --> 00:06:18,390
called properties so you the one of the

00:06:16,320 --> 00:06:21,900
method is called get properties where

00:06:18,390 --> 00:06:23,520
you give all your properties and of

00:06:21,900 --> 00:06:25,940
course properties could be of different

00:06:23,520 --> 00:06:29,280
types so how do you return an array of

00:06:25,940 --> 00:06:31,860
varying types of data so what you use is

00:06:29,280 --> 00:06:34,919
a variant so did it's for abused cases

00:06:31,860 --> 00:06:38,840
like that but of course it makes a bit

00:06:34,919 --> 00:06:38,840
life bit harder because it dynamically

00:06:39,330 --> 00:06:44,599
give I'll give you some example of how

00:06:41,159 --> 00:06:47,340
the encoding is don't love on my

00:06:44,599 --> 00:06:51,690
graphing skills this is the first time

00:06:47,340 --> 00:06:53,370
I've ever made diagrams for my slides so

00:06:51,690 --> 00:06:55,770
let's say there's a string called just

00:06:53,370 --> 00:07:00,629
say hello you want to put it encode it

00:06:55,770 --> 00:07:03,120
in this format very easy you have to

00:07:00,629 --> 00:07:06,750
encode the length of it and you have to

00:07:03,120 --> 00:07:08,699
encode the data itself it's like just

00:07:06,750 --> 00:07:12,030
the data like the characters of your

00:07:08,699 --> 00:07:13,830
string unicode string and a null byte

00:07:12,030 --> 00:07:16,319
that's it

00:07:13,830 --> 00:07:19,080
now byte is not very useful for rust but

00:07:16,319 --> 00:07:20,789
it has to be there and fun thing

00:07:19,080 --> 00:07:23,550
yeah the null byte is not included in

00:07:20,789 --> 00:07:27,719
the size of the the length as you can

00:07:23,550 --> 00:07:28,590
see it says 5 it's nothing say 6 we will

00:07:27,719 --> 00:07:33,300
talk about this later

00:07:28,590 --> 00:07:36,180
and the as I said alignment is based is

00:07:33,300 --> 00:07:38,219
natural so since the length of the

00:07:36,180 --> 00:07:41,520
string which is the first which is the

00:07:38,219 --> 00:07:43,860
fixed size the start of the string

00:07:41,520 --> 00:07:47,699
it's 4 bytes so the alignment for 4

00:07:43,860 --> 00:07:49,759
bytes is 4 bytes so in here in the

00:07:47,699 --> 00:07:55,440
bottom below you will see that I have

00:07:49,759 --> 00:07:59,069
made the numbers bigger for the for the

00:07:55,440 --> 00:08:02,219
for the 4 byte boundaries so there's

00:07:59,069 --> 00:08:05,310
this number like it's 0 base so on

00:08:02,219 --> 00:08:08,240
number 7 you have the memory address 7

00:08:05,310 --> 00:08:12,060
you have the boundary for the first byte

00:08:08,240 --> 00:08:15,629
so since we want to start with a 0 with

00:08:12,060 --> 00:08:17,819
a on a 4 byte boundary we first put 2

00:08:15,629 --> 00:08:19,710
zeros and then that's the padding and

00:08:17,819 --> 00:08:22,069
then so this is the whole encoding of

00:08:19,710 --> 00:08:28,050
your string and that's how encoding

00:08:22,069 --> 00:08:30,330
works and in this format similarly the

00:08:28,050 --> 00:08:31,919
same thing but we put in a variant just

00:08:30,330 --> 00:08:34,579
to demonstrate variant because I'll have

00:08:31,919 --> 00:08:37,680
problems with that later I'll show you a

00:08:34,579 --> 00:08:40,110
bit more complicated but similar concept

00:08:37,680 --> 00:08:41,880
that you have the data at the end that's

00:08:40,110 --> 00:08:47,820
the same thing the land the string the

00:08:41,880 --> 00:08:49,390
same 0 byte and what you do is instead

00:08:47,820 --> 00:08:51,310
of

00:08:49,390 --> 00:08:53,140
since you don't know the type of the

00:08:51,310 --> 00:08:57,010
data beforehand it's dynamically typed

00:08:53,140 --> 00:08:59,110
as I said so how do people who need to

00:08:57,010 --> 00:09:01,780
parse this how would they know what type

00:08:59,110 --> 00:09:04,330
it is so what the variant is nothing but

00:09:01,780 --> 00:09:08,100
the data and it's prefixed with the

00:09:04,330 --> 00:09:11,800
signature signature string of that type

00:09:08,100 --> 00:09:13,630
and as you can see it's the same as then

00:09:11,800 --> 00:09:16,630
the encoding of the signature is the

00:09:13,630 --> 00:09:19,390
same as the string but the length is 1

00:09:16,630 --> 00:09:22,600
byte only so you you are limited to 255

00:09:19,390 --> 00:09:25,330
characters so you can't have two complex

00:09:22,600 --> 00:09:28,900
data type you you never need that so

00:09:25,330 --> 00:09:31,030
it's fine so yeah it's and as I said

00:09:28,900 --> 00:09:35,170
it's an efficient format so they made it

00:09:31,030 --> 00:09:37,840
in like not four bytes but one byte and

00:09:35,170 --> 00:09:40,180
then the actual byte the string type so

00:09:37,840 --> 00:09:42,640
it says and then the null byte in here

00:09:40,180 --> 00:09:44,610
as well and then the padding and then

00:09:42,640 --> 00:09:48,610
the rest is exactly the same as before

00:09:44,610 --> 00:09:51,790
so I started working on that the good

00:09:48,610 --> 00:09:53,860
cool I had was super efficient API I

00:09:51,790 --> 00:09:56,380
want to have it as efficient as possible

00:09:53,860 --> 00:10:00,880
I have this thing for efficiency I like

00:09:56,380 --> 00:10:03,430
everything super efficient but a silly

00:10:00,880 --> 00:10:05,950
goal was to have it from day one have

00:10:03,430 --> 00:10:09,390
hunted from the start - to do it super

00:10:05,950 --> 00:10:12,310
efficient that was not a good idea ting

00:10:09,390 --> 00:10:15,160
so I ended up with this type and also I

00:10:12,310 --> 00:10:19,840
decided to make it very very generic and

00:10:15,160 --> 00:10:21,730
very you know abstract and stuff so I

00:10:19,840 --> 00:10:24,040
ended up with this trade that I wanted

00:10:21,730 --> 00:10:27,970
to implement for all types that will be

00:10:24,040 --> 00:10:30,960
encoded and decoded and as you can see

00:10:27,970 --> 00:10:35,710
their lifetime there and that wasn't

00:10:30,960 --> 00:10:37,360
easy to handle in the long run I had to

00:10:35,710 --> 00:10:39,100
deal with a lot of issues of course and

00:10:37,360 --> 00:10:40,570
whatever you do you will always have a

00:10:39,100 --> 00:10:44,740
lot of issues that if you start from

00:10:40,570 --> 00:10:46,990
scratch which I did loads and loads of

00:10:44,740 --> 00:10:48,880
fun with lifetimes each time I have

00:10:46,990 --> 00:10:50,980
realized a problem in my API and I

00:10:48,880 --> 00:10:53,140
changed things if it was a fundamental

00:10:50,980 --> 00:10:54,580
change especially lifetimes are always

00:10:53,140 --> 00:10:56,500
on the way and I had to deal with them

00:10:54,580 --> 00:10:58,600
and I learned a lot about lifetimes but

00:10:56,500 --> 00:11:00,640
I still think I'm a complete newbie in

00:10:58,600 --> 00:11:01,400
lifetimes if there is anything you can

00:11:00,640 --> 00:11:02,990
you

00:11:01,400 --> 00:11:06,290
you should learn from this talk of mine

00:11:02,990 --> 00:11:08,420
is that if you want to learn rust learn

00:11:06,290 --> 00:11:10,880
life times people will say and don't do

00:11:08,420 --> 00:11:13,310
that what you don't need them I think

00:11:10,880 --> 00:11:15,710
that's a lie you you will need lifetimes

00:11:13,310 --> 00:11:17,840
and the thing is that it will be like me

00:11:15,710 --> 00:11:19,580
I learn trust and I've kind of avoided

00:11:17,840 --> 00:11:21,770
lifetimes and learnt everything else and

00:11:19,580 --> 00:11:23,690
then when I had to deal with lifetime

00:11:21,770 --> 00:11:25,970
that I was like what am I supposed to be

00:11:23,690 --> 00:11:28,250
like it's all of a sudden I felt like I

00:11:25,970 --> 00:11:30,710
don't know anything about trust anymore

00:11:28,250 --> 00:11:32,420
so yeah learn them it's they're not as

00:11:30,710 --> 00:11:34,820
difficult as the sound in the beginning

00:11:32,420 --> 00:11:42,370
and it's like anything you can learn

00:11:34,820 --> 00:11:42,370
everything okay

00:11:42,700 --> 00:11:46,040
variant representation was a challenge

00:11:44,930 --> 00:11:48,560
we're challenging as I said it's

00:11:46,040 --> 00:11:50,330
dynamically type and I want everything's

00:11:48,560 --> 00:11:53,600
you know it's a statically typed

00:11:50,330 --> 00:11:57,380
language so it wasn't so easy but I went

00:11:53,600 --> 00:12:00,290
with in the end after of a lot of trials

00:11:57,380 --> 00:12:06,050
and errors I went with them ennum which

00:12:00,290 --> 00:12:08,210
I should have started with but

00:12:06,050 --> 00:12:10,910
eventually things started to look good

00:12:08,210 --> 00:12:15,470
and I had a from beginning I did test

00:12:10,910 --> 00:12:16,760
cases and yeah they started to pass and

00:12:15,470 --> 00:12:20,050
pass and there was more and more data

00:12:16,760 --> 00:12:23,270
types I could had and but at the end of

00:12:20,050 --> 00:12:25,640
everything I I did hashmap the the

00:12:23,270 --> 00:12:28,880
dictionary type and the test cases when

00:12:25,640 --> 00:12:30,080
I added them they were failing in the

00:12:28,880 --> 00:12:31,700
beginning and I was like what's going on

00:12:30,080 --> 00:12:34,220
so I first thought the test case is bad

00:12:31,700 --> 00:12:36,110
or my code is bad and everything was

00:12:34,220 --> 00:12:40,250
fine the dictionary implementation was

00:12:36,110 --> 00:12:42,200
fine the test case was fine and I was

00:12:40,250 --> 00:12:43,910
like yeah like let's look at it like I

00:12:42,200 --> 00:12:49,370
was looking at the bites a lot so this

00:12:43,910 --> 00:12:52,580
is same thing an array of 64-bit

00:12:49,370 --> 00:12:57,590
integers just two of them for simplicity

00:12:52,580 --> 00:13:00,830
in you know variant similarly to the

00:12:57,590 --> 00:13:04,730
string type you have in array you also

00:13:00,830 --> 00:13:07,580
have the the length for battle of length

00:13:04,730 --> 00:13:09,920
and then the LM padding for the first

00:13:07,580 --> 00:13:11,690
element and and then you have the data

00:13:09,920 --> 00:13:15,170
the first element second and even third

00:13:11,690 --> 00:13:17,450
element of course it's all

00:13:15,170 --> 00:13:19,670
so needs the same kind of alignment as

00:13:17,450 --> 00:13:24,500
the string because the four bite length

00:13:19,670 --> 00:13:26,450
in the beginning and since it's in a

00:13:24,500 --> 00:13:29,360
variant as I said you have to provide

00:13:26,450 --> 00:13:32,750
the signature just before it so there's

00:13:29,360 --> 00:13:37,300
the signature is for arrays and T's the

00:13:32,750 --> 00:13:40,070
actual type which is 64-bit integer

00:13:37,300 --> 00:13:46,010
right there's a reason I showed you this

00:13:40,070 --> 00:13:47,930
so don't hit me first so I couldn't

00:13:46,010 --> 00:13:50,389
figure out what what's wrong with this

00:13:47,930 --> 00:13:53,240
picture there is something wrong in this

00:13:50,389 --> 00:13:56,269
picture so as today we won't have any

00:13:53,240 --> 00:13:58,880
quiz let's have this as a quiz if anyone

00:13:56,269 --> 00:14:03,470
can point to me what the problem is here

00:13:58,880 --> 00:14:08,660
I will give you one beer wait wait wait

00:14:03,470 --> 00:14:11,000
first here is then no signature okay

00:14:08,660 --> 00:14:12,949
sorry I didn't mention this before so

00:14:11,000 --> 00:14:15,980
good that you pointed out since

00:14:12,949 --> 00:14:18,769
signature is the length of signature is

00:14:15,980 --> 00:14:21,290
one byte like the first byte and one

00:14:18,769 --> 00:14:23,000
byte alignment is one byte so you don't

00:14:21,290 --> 00:14:25,910
need alignment for signatures and

00:14:23,000 --> 00:14:27,500
therefore not for variants either so

00:14:25,910 --> 00:14:41,350
variant itself does not need alignment

00:14:27,500 --> 00:14:41,350
but good guess which one needs to be 64

00:14:46,149 --> 00:14:52,070
yeah yeah the area they need to be so

00:14:50,000 --> 00:14:55,820
the 64-bit integer needs to be aligned

00:14:52,070 --> 00:15:00,260
on 64 bits like 8 bytes so that's why

00:14:55,820 --> 00:15:04,699
the padding it starts on the 16th okay

00:15:00,260 --> 00:15:05,839
so nobody knows so I continue anyway so

00:15:04,699 --> 00:15:08,630
I couldn't give a figure out four days

00:15:05,839 --> 00:15:10,660
right and I was like my girlfriend was

00:15:08,630 --> 00:15:17,269
saying why are you so sad these days I

00:15:10,660 --> 00:15:21,620
try to explain so back to D was back

00:15:17,269 --> 00:15:23,449
reading and also reading the bytes like

00:15:21,620 --> 00:15:26,950
I was printing out all the bytes and

00:15:23,449 --> 00:15:30,650
looking at each and every bite and

00:15:26,950 --> 00:15:33,890
so first my first I first thought like

00:15:30,650 --> 00:15:36,740
it's the padding I read this back and

00:15:33,890 --> 00:15:38,750
the more I read it I started to get this

00:15:36,740 --> 00:15:42,530
impression that I was wrong about the

00:15:38,750 --> 00:15:44,870
fact that you need padding for the data

00:15:42,530 --> 00:15:47,600
and closed in in a variant since we're

00:15:44,870 --> 00:15:49,370
doesn't need it in any padding so the

00:15:47,600 --> 00:15:51,920
the wording in this back wasn't so clear

00:15:49,370 --> 00:15:55,040
so it sounded like you don't need any

00:15:51,920 --> 00:15:57,800
you don't had the some thing that is

00:15:55,040 --> 00:16:00,560
inside the variant either so I was like

00:15:57,800 --> 00:16:05,390
yeah makes sense so I went with this

00:16:00,560 --> 00:16:08,300
Impa sumption but just needed a complete

00:16:05,390 --> 00:16:12,410
change of the whole API so went back

00:16:08,300 --> 00:16:14,420
into it but each solution I came up with

00:16:12,410 --> 00:16:15,860
when I was implementing it lifetimes

00:16:14,420 --> 00:16:17,450
made it very hard to implement it

00:16:15,860 --> 00:16:19,310
because I had to satisfy all the

00:16:17,450 --> 00:16:22,640
lifetimes and change it in my stuff

00:16:19,310 --> 00:16:25,370
so I was like let's first kill all the

00:16:22,640 --> 00:16:29,150
lifetimes this is this is ridiculous

00:16:25,370 --> 00:16:32,720
so I came up with a solution like an

00:16:29,150 --> 00:16:36,770
immutable slice of data for those of you

00:16:32,720 --> 00:16:40,820
who don't know the rest yet so RC is a

00:16:36,770 --> 00:16:43,070
reference counter data type and you can

00:16:40,820 --> 00:16:44,570
put anything in it and that's reference

00:16:43,070 --> 00:16:46,600
counted so you don't need to copy it

00:16:44,570 --> 00:16:49,220
around if you want to share something

00:16:46,600 --> 00:16:53,750
across your codebase you put it in RC

00:16:49,220 --> 00:16:55,670
and you cloned the RC which is the just

00:16:53,750 --> 00:16:58,190
a container but the actual data does not

00:16:55,670 --> 00:17:01,520
get copied or cloned so it's very

00:16:58,190 --> 00:17:03,590
efficient way of you know but still is

00:17:01,520 --> 00:17:06,590
not as efficient as not having to even

00:17:03,590 --> 00:17:08,150
clone the RC of course but can live with

00:17:06,590 --> 00:17:11,330
it in the beginning

00:17:08,150 --> 00:17:13,610
so yeah it was a way of slicing a data

00:17:11,330 --> 00:17:18,140
and each part of the code having its own

00:17:13,610 --> 00:17:20,240
slice and yeah so it worked actually and

00:17:18,140 --> 00:17:24,320
I got rid of all the lifetimes it's so

00:17:20,240 --> 00:17:28,130
good so after two months I was done

00:17:24,320 --> 00:17:30,410
right and then I thought how the test

00:17:28,130 --> 00:17:32,540
cases should pass and I was so scared

00:17:30,410 --> 00:17:35,610
like I was shaking when I like fresh

00:17:32,540 --> 00:17:38,150
centroid and nope

00:17:35,610 --> 00:17:40,980
the exact same investigators still fail

00:17:38,150 --> 00:17:42,690
so back to my spec reading and bite

00:17:40,980 --> 00:17:44,820
staring at like all the time like

00:17:42,690 --> 00:17:46,650
where's Tech so there was like I

00:17:44,820 --> 00:17:49,080
realized there was a four bytes missing

00:17:46,650 --> 00:17:51,510
somewhere or I was going over the four

00:17:49,080 --> 00:17:58,440
bytes somehow so that's why it was

00:17:51,510 --> 00:18:01,650
convinced that it's a padding no turns

00:17:58,440 --> 00:18:06,320
out the problem was much more trivial

00:18:01,650 --> 00:18:10,200
than I imagined the spec says that the

00:18:06,320 --> 00:18:14,810
size of the array does not include the

00:18:10,200 --> 00:18:20,130
padding of the first element so the size

00:18:14,810 --> 00:18:24,720
has to be 16 because well 8 bytes plus 8

00:18:20,130 --> 00:18:29,340
by 16 bytes and the reason is that the

00:18:24,720 --> 00:18:32,880
size is supposed to be divided you can

00:18:29,340 --> 00:18:35,760
divide it by number of elements in the

00:18:32,880 --> 00:18:38,730
array so it has to be divided divided

00:18:35,760 --> 00:18:40,050
below how do you say it anyway so yeah

00:18:38,730 --> 00:18:42,680
there was a reason for it but I just

00:18:40,050 --> 00:18:47,310
missed it in the spec and that was very

00:18:42,680 --> 00:18:50,010
trivial to fix in me and so yeah I fixed

00:18:47,310 --> 00:18:52,790
it and yeah that was a Christmas

00:18:50,010 --> 00:18:52,790
well-spent

00:18:55,070 --> 00:19:00,110
yeah published a crate on New Year's Eve

00:19:00,320 --> 00:19:07,920
and yeah I know someone told me that I

00:19:05,060 --> 00:19:11,940
wasn't I wasn't expected to provide

00:19:07,920 --> 00:19:16,410
documentation like I did like yeah so

00:19:11,940 --> 00:19:20,160
bad it's so cool so you can you can

00:19:16,410 --> 00:19:22,380
already use it it's like I have example

00:19:20,160 --> 00:19:24,330
code and the on the docstore RS and also

00:19:22,380 --> 00:19:29,880
and the test cases do you have a lot

00:19:24,330 --> 00:19:33,300
more so simple you you want to encode a

00:19:29,880 --> 00:19:34,710
string you just say encode and you say

00:19:33,300 --> 00:19:36,830
which format currently there's only

00:19:34,710 --> 00:19:39,960
deepest format that we support but

00:19:36,830 --> 00:19:42,770
encoding format is there so that I can

00:19:39,960 --> 00:19:46,980
later add other formats like gee variant

00:19:42,770 --> 00:19:48,260
and then you you can then decode it the

00:19:46,980 --> 00:19:52,800
same way

00:19:48,260 --> 00:19:55,050
and yeah that's that's how you do it and

00:19:52,800 --> 00:19:58,590
then there's like if you want to add

00:19:55,050 --> 00:20:01,950
something to a variant you create that

00:19:58,590 --> 00:20:05,190
data and then you say to variant and

00:20:01,950 --> 00:20:08,040
then you encode the variant like you did

00:20:05,190 --> 00:20:13,290
the string and then record it the same

00:20:08,040 --> 00:20:17,550
way for complex types we are we asked

00:20:13,290 --> 00:20:23,310
for the signature when decoding because

00:20:17,550 --> 00:20:27,270
we don't know but I don't want you to

00:20:23,310 --> 00:20:29,460
use it yet so back to efficiency right I

00:20:27,270 --> 00:20:31,350
want you to use it when it's efficient

00:20:29,460 --> 00:20:33,000
but you can use it yeah if you don't

00:20:31,350 --> 00:20:35,100
mind having to change your code later

00:20:33,000 --> 00:20:36,540
and if you really need is for some

00:20:35,100 --> 00:20:38,610
reason I don't know why you would eat it

00:20:36,540 --> 00:20:42,120
so so badly that you can't wait for

00:20:38,610 --> 00:20:44,280
another month or two so I wanted to make

00:20:42,120 --> 00:20:45,870
it efficient and I don't think I can

00:20:44,280 --> 00:20:49,860
make it efficient without breaking the

00:20:45,870 --> 00:20:51,980
API but I looked into it but no I I have

00:20:49,860 --> 00:20:57,270
to do that

00:20:51,980 --> 00:21:00,210
yeah and guess what was the first issue

00:20:57,270 --> 00:21:03,510
that was filed on this crate why don't

00:21:00,210 --> 00:21:05,070
you use survey so in the beginning I

00:21:03,510 --> 00:21:07,830
thought of that but I looked at survey

00:21:05,070 --> 00:21:11,580
and I had like cognitive overload right

00:21:07,830 --> 00:21:13,740
because I was looking into how Debus

00:21:11,580 --> 00:21:15,480
works I didn't know anything about the

00:21:13,740 --> 00:21:18,120
internals I didn't know how G variant

00:21:15,480 --> 00:21:18,960
works on that so that was enough load on

00:21:18,120 --> 00:21:20,970
my head already

00:21:18,960 --> 00:21:23,610
and I was super distracted by this thing

00:21:20,970 --> 00:21:25,560
called work so I was doing this in my

00:21:23,610 --> 00:21:27,600
spare time so that was enough so and

00:21:25,560 --> 00:21:32,640
understanding Sarah is not trivial

00:21:27,600 --> 00:21:35,820
either if you know so yeah I am now that

00:21:32,640 --> 00:21:38,940
I have something that that proves that I

00:21:35,820 --> 00:21:40,680
know what how Debus works and how the

00:21:38,940 --> 00:21:44,670
format works and how G variant works I

00:21:40,680 --> 00:21:46,410
can look into Sara and I have an

00:21:44,670 --> 00:21:49,440
experimental branch where I have have a

00:21:46,410 --> 00:21:51,570
basic like you know proof of concept

00:21:49,440 --> 00:21:54,390
serialization serializer implementation

00:21:51,570 --> 00:21:56,100
it looks really cool but it's just a

00:21:54,390 --> 00:21:59,040
proof of concept I need to really make

00:21:56,100 --> 00:22:00,600
it well and working but the main

00:21:59,040 --> 00:22:01,929
challenge with Sarah is like it's too

00:22:00,600 --> 00:22:05,259
generic

00:22:01,929 --> 00:22:08,009
so you get a data it the only thing that

00:22:05,259 --> 00:22:12,009
it will implement is serialized trait of

00:22:08,009 --> 00:22:15,579
sale day and that I could implement that

00:22:12,009 --> 00:22:18,969
for specific data type you know manually

00:22:15,579 --> 00:22:20,799
but that's also very generic the

00:22:18,969 --> 00:22:23,950
serialized implementation you don't you

00:22:20,799 --> 00:22:26,169
can't assume anything about the

00:22:23,950 --> 00:22:27,700
serializer like if you have a specific

00:22:26,169 --> 00:22:30,129
serialize err you can't assume any

00:22:27,700 --> 00:22:33,579
details about that API it has to be

00:22:30,129 --> 00:22:35,619
serialized abstract to serializer and

00:22:33,579 --> 00:22:36,999
the other way around to and see let's

00:22:35,619 --> 00:22:39,549
see realize it doesn't know any details

00:22:36,999 --> 00:22:42,369
about this serialize implementation so

00:22:39,549 --> 00:22:44,889
that abstraction that's too generic and

00:22:42,369 --> 00:22:46,959
it made it a bit hard and the reason is

00:22:44,889 --> 00:22:51,339
that when I encode and decode it I need

00:22:46,959 --> 00:22:54,549
the signature of of the data at least so

00:22:51,339 --> 00:22:57,700
I came up with the best I could and

00:22:54,549 --> 00:23:00,219
that's as generic as I can get like all

00:22:57,700 --> 00:23:03,039
serve the implementations at least the

00:23:00,219 --> 00:23:05,169
one that comply with the de facto

00:23:03,039 --> 00:23:08,019
standards you would give you some API

00:23:05,169 --> 00:23:10,269
like this to create to serialize data so

00:23:08,019 --> 00:23:12,729
I say two bytes and you I get a vector

00:23:10,269 --> 00:23:17,289
of bytes and I give it a value that

00:23:12,729 --> 00:23:19,269
implements serialize but in my case I

00:23:17,289 --> 00:23:21,609
have to ask you for one more trade which

00:23:19,269 --> 00:23:24,099
is variant value but it's a really

00:23:21,609 --> 00:23:27,399
really simple trade all it has is one

00:23:24,099 --> 00:23:29,409
method required that is signature do you

00:23:27,399 --> 00:23:33,909
just give me your signature and all is

00:23:29,409 --> 00:23:36,429
good and to make it better I will

00:23:33,909 --> 00:23:38,259
provide a derive a crow like Zelda

00:23:36,429 --> 00:23:42,579
provides for serialize and deserialize

00:23:38,259 --> 00:23:47,919
so you just add one more you know word

00:23:42,579 --> 00:23:49,659
into your derive a line and your set of

00:23:47,919 --> 00:23:52,509
course it's doing that your type has

00:23:49,659 --> 00:23:54,279
inside it all the data is also already

00:23:52,509 --> 00:23:55,529
implementing where int value just like

00:23:54,279 --> 00:24:03,219
serialize and deserialize

00:23:55,529 --> 00:24:05,709
sorry my throat is killing me so yeah I

00:24:03,219 --> 00:24:07,089
once I'm done with serialized I hadn't

00:24:05,709 --> 00:24:11,139
been digitized of course and I'm looking

00:24:07,089 --> 00:24:15,020
into it right now also like byte order I

00:24:11,139 --> 00:24:17,330
have Debus sorry allows you to

00:24:15,020 --> 00:24:18,530
say that oh this is the byte order I

00:24:17,330 --> 00:24:22,160
support and currently I've just

00:24:18,530 --> 00:24:25,370
hard-coded to be the native Indian Ness

00:24:22,160 --> 00:24:26,990
so that should be configurable because

00:24:25,370 --> 00:24:30,200
you might have data from somewhere else

00:24:26,990 --> 00:24:32,600
which is it probably in big-endian

00:24:30,200 --> 00:24:35,150
format and you will probably have little

00:24:32,600 --> 00:24:37,640
endian so yeah anyway it's needed and

00:24:35,150 --> 00:24:42,190
then of course I had G variant support

00:24:37,640 --> 00:24:45,290
which shouldn't be that hard shouldn't

00:24:42,190 --> 00:24:48,290
and a few other goodies like large error

00:24:45,290 --> 00:24:52,880
handling as I said like OS tree keeps

00:24:48,290 --> 00:24:56,300
things in a really large variance in the

00:24:52,880 --> 00:24:59,450
file so and a lot of times you want only

00:24:56,300 --> 00:25:02,179
some specific data from from that array

00:24:59,450 --> 00:25:04,510
so you don't want to read the whole area

00:25:02,179 --> 00:25:08,740
into your memory and read it all and

00:25:04,510 --> 00:25:13,100
know yeah so I would hopefully provide a

00:25:08,740 --> 00:25:15,040
you know API to make it easy and an

00:25:13,100 --> 00:25:19,100
efficient at the same time not just easy

00:25:15,040 --> 00:25:22,370
I know of course once I'm done with the

00:25:19,100 --> 00:25:23,870
zero and business I can do the thing

00:25:22,370 --> 00:25:26,000
that actually meant to do with the

00:25:23,870 --> 00:25:29,800
zebras and then I can do the actual

00:25:26,000 --> 00:25:29,800
thing that I want to deceive us all

00:25:32,920 --> 00:25:45,230
history is not in rust

00:25:34,670 --> 00:25:50,870
dr. hope so but the thing is the history

00:25:45,230 --> 00:25:52,550
is not in rust but the but West are pmos

00:25:50,870 --> 00:25:55,700
tree or what is it called OST rpm

00:25:52,550 --> 00:25:58,160
something like that that one is in most

00:25:55,700 --> 00:26:01,220
of it is in in rust so I'm hoping that

00:25:58,160 --> 00:26:02,600
at least they will use this API and I

00:26:01,220 --> 00:26:04,550
have been told by other people who are

00:26:02,600 --> 00:26:08,950
using variants for small projects here

00:26:04,550 --> 00:26:08,950
and there they said yeah we need this

00:26:10,390 --> 00:26:22,480
yeah so I think I'm done

00:26:13,380 --> 00:26:22,480
[Applause]

00:26:23,490 --> 00:26:32,770
so how many got the beard I don't I'll

00:26:27,490 --> 00:26:35,380
drink myself how do you manage to make a

00:26:32,770 --> 00:26:38,289
test that failed if we had your

00:26:35,380 --> 00:26:40,809
assumptions wrong like three new code

00:26:38,289 --> 00:26:42,909
life vests that had also like okay the

00:26:40,809 --> 00:26:46,690
length includes the padding or something

00:26:42,909 --> 00:26:49,090
or how do you you know that did so the

00:26:46,690 --> 00:26:51,610
test case the test case I added at the

00:26:49,090 --> 00:26:55,029
end that that was failing was the for

00:26:51,610 --> 00:26:57,640
the dictionary type and in in this

00:26:55,029 --> 00:27:01,510
format the dictionary type is an array

00:26:57,640 --> 00:27:04,059
of dictionary entry types so it's like a

00:27:01,510 --> 00:27:06,520
struct you know and this for structure

00:27:04,059 --> 00:27:08,799
the encoding is the alignment is a byte

00:27:06,520 --> 00:27:11,710
so before that all my test cases they

00:27:08,799 --> 00:27:14,649
didn't have eight bytes so as soon as I

00:27:11,710 --> 00:27:17,620
had it by element in in my test case in

00:27:14,649 --> 00:27:21,370
an array there was yeah it started

00:27:17,620 --> 00:27:30,159
filling so yeah it was mostly a

00:27:21,370 --> 00:27:32,260
coincidence he said about landing

00:27:30,159 --> 00:27:35,610
lifetimes I was wondering do you have

00:27:32,260 --> 00:27:35,610
any like tips or resources

00:27:37,559 --> 00:27:43,380
I saw recently this I forgot the name of

00:27:42,190 --> 00:27:45,610
the person sorry

00:27:43,380 --> 00:27:51,940
someone from Mozilla they did a

00:27:45,610 --> 00:27:54,190
presentation about subtyping in in

00:27:51,940 --> 00:27:55,929
Jenna's very generic way and Howard

00:27:54,190 --> 00:27:59,080
compliment is it implemented in rust and

00:27:55,929 --> 00:28:01,799
how rust does various variants in

00:27:59,080 --> 00:28:06,429
variants and very covariance and

00:28:01,799 --> 00:28:08,500
contravariance so if you if you go and

00:28:06,429 --> 00:28:10,600
look at that talk and also there is some

00:28:08,500 --> 00:28:13,059
documentation if you google for rust

00:28:10,600 --> 00:28:15,370
variance-covariance you will find these

00:28:13,059 --> 00:28:18,250
I think it's more like internal Docs or

00:28:15,370 --> 00:28:20,500
something that also helps a lot but

00:28:18,250 --> 00:28:23,020
other than that there is the rust book

00:28:20,500 --> 00:28:24,940
the from O'Reilly it does also a pretty

00:28:23,020 --> 00:28:25,530
good job at least for intro that is a

00:28:24,940 --> 00:28:28,920
very

00:28:25,530 --> 00:28:32,790
very good job but the rest is just you

00:28:28,920 --> 00:28:35,010
know well interesting fact like I I went

00:28:32,790 --> 00:28:38,220
a lot to this rust channel on discord

00:28:35,010 --> 00:28:39,900
but the beginner's channel and I asked a

00:28:38,220 --> 00:28:41,700
lot of lifetime questions and I realized

00:28:39,900 --> 00:28:52,530
that most of the questions on that

00:28:41,700 --> 00:28:54,720
channel they're about lifetime the one

00:28:52,530 --> 00:28:56,850
thing about lifetimes I kind of realize

00:28:54,720 --> 00:28:59,400
previously it's more related to the fact

00:28:56,850 --> 00:29:01,500
that a lot of super useful traits that

00:28:59,400 --> 00:29:04,020
make working with Russ very convenient

00:29:01,500 --> 00:29:06,210
like Darrell for example they actually

00:29:04,020 --> 00:29:08,670
circumvent the issue of lifetime's by

00:29:06,210 --> 00:29:10,770
working with zero size types so for

00:29:08,670 --> 00:29:12,720
example if you have a path buff which is

00:29:10,770 --> 00:29:15,170
you know again and an object which owns

00:29:12,720 --> 00:29:18,240
a buffer which owns which owns a path

00:29:15,170 --> 00:29:20,460
and you have the path type and you want

00:29:18,240 --> 00:29:22,380
to what have you reference the path buff

00:29:20,460 --> 00:29:26,210
to go to the path yeah the same for

00:29:22,380 --> 00:29:28,230
string two and back to you know slice

00:29:26,210 --> 00:29:30,690
when you go into the code you actually

00:29:28,230 --> 00:29:34,170
realize that what you return is a

00:29:30,690 --> 00:29:36,870
different type which however is not

00:29:34,170 --> 00:29:39,060
created within the function that you

00:29:36,870 --> 00:29:41,640
know returns it and that only works

00:29:39,060 --> 00:29:44,070
because of some like trickery inside the

00:29:41,640 --> 00:29:45,420
compiler now I'm saying this because I

00:29:44,070 --> 00:29:50,220
was always trying to do something like

00:29:45,420 --> 00:29:52,830
what you did so you created a type which

00:29:50,220 --> 00:29:54,330
is generic over a lifetime a and then

00:29:52,830 --> 00:29:58,770
this holds a reference something else

00:29:54,330 --> 00:30:00,570
yeah and for this to be convenient you

00:29:58,770 --> 00:30:03,900
need to have like D or F and a couple of

00:30:00,570 --> 00:30:06,060
other things borrow and so on and you

00:30:03,900 --> 00:30:08,580
can't actually express that express this

00:30:06,060 --> 00:30:10,380
with the current type system because you

00:30:08,580 --> 00:30:11,130
need something called gin generic as

00:30:10,380 --> 00:30:13,410
those data types

00:30:11,130 --> 00:30:15,110
yeah and that makes it always super

00:30:13,410 --> 00:30:18,420
painful actually work with this because

00:30:15,110 --> 00:30:20,970
you can't really is ya know I did come

00:30:18,420 --> 00:30:23,100
across a quite a few solutions that I

00:30:20,970 --> 00:30:26,310
thought would be good but they were not

00:30:23,100 --> 00:30:33,720
possible with the current the way it is

00:30:26,310 --> 00:30:35,910
currently works so so I what kind of of

00:30:33,720 --> 00:30:37,860
course so this is like a

00:30:35,910 --> 00:30:41,039
if I understood this correctly so this

00:30:37,860 --> 00:30:43,890
is like a mixture between a schematic

00:30:41,039 --> 00:30:46,530
data type and a self describing data

00:30:43,890 --> 00:30:50,390
type right yes because you don't have

00:30:46,530 --> 00:30:52,710
these tags like T&A and whatever you

00:30:50,390 --> 00:30:54,030
yeah you don't have them everywhere

00:30:52,710 --> 00:30:59,250
right you only had them for variant

00:30:54,030 --> 00:31:02,070
types yeah so it's like mostly not

00:30:59,250 --> 00:31:04,500
self-describing but only in one specific

00:31:02,070 --> 00:31:08,809
case which is dynamically typed so it

00:31:04,500 --> 00:31:08,809
has to be you know self describing

00:31:23,220 --> 00:31:34,559

YouTube URL: https://www.youtube.com/watch?v=5P24c18xIOk


