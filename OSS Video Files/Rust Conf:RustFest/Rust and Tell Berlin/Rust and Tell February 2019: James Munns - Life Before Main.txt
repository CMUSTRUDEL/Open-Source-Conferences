Title: Rust and Tell February 2019: James Munns - Life Before Main
Publication date: 2019-03-15
Playlist: Rust and Tell Berlin
Description: 
	A look into all the things that happen before main gets called on embedded devices running Rust.

Rust and Tell is a monthly event (the last Tuesday of every month) to share ideas and learn about new things about Rust.
Check out https://berline.rs/ for more.
Captions: 
	00:00:07,550 --> 00:00:11,040
okay can everyone hear me even the back

00:00:10,230 --> 00:00:16,049
sounds good

00:00:11,040 --> 00:00:19,550
cool alright so I'm James Muntz and this

00:00:16,049 --> 00:00:22,560
is my talk called life before main so

00:00:19,550 --> 00:00:25,500
this talk is sort of about embedded

00:00:22,560 --> 00:00:27,630
embedded development and rust but not

00:00:25,500 --> 00:00:30,149
entirely a lot of it's totally true

00:00:27,630 --> 00:00:33,030
whether you're writing C or rust for

00:00:30,149 --> 00:00:34,829
embedded systems or on a desktop but I

00:00:33,030 --> 00:00:37,440
want to investigate everything that

00:00:34,829 --> 00:00:40,110
happens before when you start running

00:00:37,440 --> 00:00:42,780
your program and you execute the first

00:00:40,110 --> 00:00:45,900
line of main so a little bit about me

00:00:42,780 --> 00:00:48,600
I'm James months I'm bit shift mask on

00:00:45,900 --> 00:00:50,310
Twitter I talk a lot about embedded

00:00:48,600 --> 00:00:52,560
stuff so if that's your kind of thing I

00:00:50,310 --> 00:00:55,650
would recommend following me I work for

00:00:52,560 --> 00:00:58,410
a company upstairs called Faris systems

00:00:55,650 --> 00:01:00,480
we're a software consultancy focused on

00:00:58,410 --> 00:01:02,280
system development in rust so whether

00:01:00,480 --> 00:01:04,920
that's embedded systems distributed

00:01:02,280 --> 00:01:07,079
databases any kinds of fun hard

00:01:04,920 --> 00:01:10,979
low-level problems in rust we help out

00:01:07,079 --> 00:01:12,659
with those kind of things so actually

00:01:10,979 --> 00:01:15,659
before I get started how many people

00:01:12,659 --> 00:01:18,600
here have start who here is written rust

00:01:15,659 --> 00:01:19,649
before all right for the camera that's

00:01:18,600 --> 00:01:22,249
almost everyone in the room at least

00:01:19,649 --> 00:01:26,249
most people how many people have written

00:01:22,249 --> 00:01:27,780
microcontroller code before okay we've

00:01:26,249 --> 00:01:30,450
got like a third room how many people

00:01:27,780 --> 00:01:32,609
know what a microcontroller is okay

00:01:30,450 --> 00:01:33,810
again most of the room so for anyone who

00:01:32,609 --> 00:01:36,749
didn't raise their hands or anyone on

00:01:33,810 --> 00:01:38,639
the video a microcontroller is a really

00:01:36,749 --> 00:01:41,549
tiny little computer system they

00:01:38,639 --> 00:01:43,439
typically power almost every computer

00:01:41,549 --> 00:01:46,020
you don't sit in front of so whether you

00:01:43,439 --> 00:01:48,389
have a SmartWatch whether you have a

00:01:46,020 --> 00:01:50,520
step counter whether you have an engine

00:01:48,389 --> 00:01:52,319
control system for your car that's

00:01:50,520 --> 00:01:56,069
running code and it's probably running

00:01:52,319 --> 00:01:58,590
code on a microcontroller but we write

00:01:56,069 --> 00:02:01,319
code for them but how do they know how

00:01:58,590 --> 00:02:03,090
to run that code so when you power these

00:02:01,319 --> 00:02:04,409
embedded systems on you connect them to

00:02:03,090 --> 00:02:07,619
a battery you plug them into the wall

00:02:04,409 --> 00:02:08,729
step one apply power great that's

00:02:07,619 --> 00:02:10,080
definitely where you're gonna start

00:02:08,729 --> 00:02:12,060
you're gonna plug the USB cable in

00:02:10,080 --> 00:02:17,430
you're gonna flip the switch great makes

00:02:12,060 --> 00:02:19,440
sense so far step two step three run

00:02:17,430 --> 00:02:21,250
code profit this is gonna work great

00:02:19,440 --> 00:02:23,170
it's gonna start running all that imbed

00:02:21,250 --> 00:02:26,710
code we wrote and everything's gonna

00:02:23,170 --> 00:02:28,600
work perfectly but what what happened in

00:02:26,710 --> 00:02:31,620
between like I started shoving electrons

00:02:28,600 --> 00:02:34,300
into my system and then code came out

00:02:31,620 --> 00:02:36,010
well I mean there's a couple things that

00:02:34,300 --> 00:02:37,600
go into this let's say we were writing

00:02:36,010 --> 00:02:39,580
the simplest embedded system in the

00:02:37,600 --> 00:02:41,560
world we were writing a blinky light

00:02:39,580 --> 00:02:43,240
this is like hello world for embedded

00:02:41,560 --> 00:02:44,890
systems a lot of embedded systems don't

00:02:43,240 --> 00:02:46,780
have a screen so how do you say hello

00:02:44,890 --> 00:02:49,000
well if the only thing they have is a

00:02:46,780 --> 00:02:51,910
light well you're gonna blink an LED so

00:02:49,000 --> 00:02:55,600
in rust some blinky LED hello world code

00:02:51,910 --> 00:02:56,620
might look like this so we have main so

00:02:55,600 --> 00:02:58,030
this is gonna feel really familiar

00:02:56,620 --> 00:03:00,940
whether you're you've implemented

00:02:58,030 --> 00:03:02,290
embedded systems or not let's see do I

00:03:00,940 --> 00:03:05,260
have a laser what I do have a laser

00:03:02,290 --> 00:03:06,700
pointer so some of this is specific and

00:03:05,260 --> 00:03:09,010
rust and I'm not gonna get into this in

00:03:06,700 --> 00:03:10,390
this talk but we have these libraries

00:03:09,010 --> 00:03:11,890
that tell us how to work with our board

00:03:10,390 --> 00:03:15,760
for example the board I'm using this

00:03:11,890 --> 00:03:17,110
demo is a board called the DWM 1001 so

00:03:15,760 --> 00:03:18,850
we're gonna go ahead and grab our

00:03:17,110 --> 00:03:21,670
drivers for that we're gonna start a

00:03:18,850 --> 00:03:23,920
timer and then this is our wonderful

00:03:21,670 --> 00:03:26,799
master piece of code we have an endless

00:03:23,920 --> 00:03:29,170
loop that turns an LED on it waits 20

00:03:26,799 --> 00:03:31,390
milliseconds and then it turns the LED

00:03:29,170 --> 00:03:33,370
off and it waits 230 milliseconds so

00:03:31,390 --> 00:03:35,350
it's gonna go blink blink blink blink

00:03:33,370 --> 00:03:37,660
over and over again and this is great

00:03:35,350 --> 00:03:39,340
this is a whole functional embedded

00:03:37,660 --> 00:03:43,989
system it's the best thing that can ever

00:03:39,340 --> 00:03:46,840
be shipped but this is your code but how

00:03:43,989 --> 00:03:49,510
does that actually make the whole system

00:03:46,840 --> 00:03:51,220
go well it's not just your code if i

00:03:49,510 --> 00:03:55,060
zoom out on this example a little bit

00:03:51,220 --> 00:03:56,650
your codes in main but also this is rust

00:03:55,060 --> 00:03:58,780
so you've probably included some

00:03:56,650 --> 00:04:00,040
libraries so at the top of your file you

00:03:58,780 --> 00:04:01,480
might have a line that says this is no

00:04:00,040 --> 00:04:03,730
standard we're on an embedded system

00:04:01,480 --> 00:04:05,860
here there's no standard library I'm

00:04:03,730 --> 00:04:07,420
gonna use that DW on 1001 this is where

00:04:05,860 --> 00:04:08,500
I've defined all my drivers and stuff

00:04:07,420 --> 00:04:10,959
like that I didn't have to write it

00:04:08,500 --> 00:04:12,760
someone else did I'm also gonna pull in

00:04:10,959 --> 00:04:15,459
this crate called cortex MRT

00:04:12,760 --> 00:04:16,870
specifically the entry macro so we saw

00:04:15,459 --> 00:04:18,729
that back on this slide you know we had

00:04:16,870 --> 00:04:22,780
a little entry attribute hanging out on

00:04:18,729 --> 00:04:24,460
top of main panic halt this says what

00:04:22,780 --> 00:04:27,040
happened what our embedded system should

00:04:24,460 --> 00:04:28,450
do if it panics because again this is an

00:04:27,040 --> 00:04:31,150
embedded system and there's no operating

00:04:28,450 --> 00:04:33,640
system so if you panic normally your

00:04:31,150 --> 00:04:34,630
application is stopped by the operating

00:04:33,640 --> 00:04:35,710
system

00:04:34,630 --> 00:04:37,300
everything stops but if you don't have

00:04:35,710 --> 00:04:38,800
an operating system you've got to tell

00:04:37,300 --> 00:04:40,450
the embedded system how to do this and

00:04:38,800 --> 00:04:45,550
then we pull in some other things

00:04:40,450 --> 00:04:46,780
specifically about the driver but we

00:04:45,550 --> 00:04:48,310
still haven't answered what what

00:04:46,780 --> 00:04:49,840
happened so we've got some more code we

00:04:48,310 --> 00:04:51,070
know there's more code involved now

00:04:49,840 --> 00:04:52,950
because this is rust and we have a

00:04:51,070 --> 00:04:55,510
library pulled in and things like that

00:04:52,950 --> 00:04:57,460
but what are all the parts that take the

00:04:55,510 --> 00:04:58,810
code you write that 10 lines of main or

00:04:57,460 --> 00:05:00,040
whatever I had I'm gonna move this away

00:04:58,810 --> 00:05:04,210
from my mouth because the topic a little

00:05:00,040 --> 00:05:05,500
bit what makes it actually run on your

00:05:04,210 --> 00:05:08,590
hardware well there's a couple parts

00:05:05,500 --> 00:05:10,060
that go into this there's code so a

00:05:08,590 --> 00:05:11,650
little bit of your code you write the

00:05:10,060 --> 00:05:13,570
main you define the business logic and

00:05:11,650 --> 00:05:15,640
stuff like that but a lot of other

00:05:13,570 --> 00:05:16,720
people's code and you didn't see that

00:05:15,640 --> 00:05:19,510
because we just pulled those in as

00:05:16,720 --> 00:05:22,540
crates but we'll get into that the

00:05:19,510 --> 00:05:24,760
compiler helps so from the rust side the

00:05:22,540 --> 00:05:26,080
compiler front-end rust C helps with a

00:05:24,760 --> 00:05:28,500
bit of this and then the compiler

00:05:26,080 --> 00:05:30,880
back-end LVM helps out with some of this

00:05:28,500 --> 00:05:32,080
but less than you might think you might

00:05:30,880 --> 00:05:34,470
think the compiler is pulling all the

00:05:32,080 --> 00:05:37,210
magic here but it's really not all of it

00:05:34,470 --> 00:05:38,560
we also have the linker so if you're

00:05:37,210 --> 00:05:40,390
writing desktop applications you're

00:05:38,560 --> 00:05:41,980
still using a linker linker is what

00:05:40,390 --> 00:05:43,720
takes the compiled code and makes your

00:05:41,980 --> 00:05:44,890
final executable but you don't think

00:05:43,720 --> 00:05:47,080
about it very much when you're writing

00:05:44,890 --> 00:05:48,190
desktop code because it just works you

00:05:47,080 --> 00:05:49,810
don't have to interact with it unless

00:05:48,190 --> 00:05:51,640
you get weird symbols like I don't know

00:05:49,810 --> 00:05:54,010
what this is you need to define this and

00:05:51,640 --> 00:05:55,870
tell me what it is but for emitted

00:05:54,010 --> 00:05:56,920
systems this does a lot more heavy

00:05:55,870 --> 00:05:59,500
lifting than you might think

00:05:56,920 --> 00:06:01,930
and then finally you've got the actual

00:05:59,500 --> 00:06:04,600
hardware in this case our embedded

00:06:01,930 --> 00:06:06,460
system is actually going to do some of

00:06:04,600 --> 00:06:08,260
this magically for us when I say

00:06:06,460 --> 00:06:09,580
magically we need to put things in the

00:06:08,260 --> 00:06:13,810
right place but then it's gonna take

00:06:09,580 --> 00:06:16,180
over the show and then finally last your

00:06:13,810 --> 00:06:17,560
code again but not as code as machine

00:06:16,180 --> 00:06:20,860
code so this is something that your

00:06:17,560 --> 00:06:22,390
compiler is going to generate and it's

00:06:20,860 --> 00:06:24,760
gonna create a bunch of machine code or

00:06:22,390 --> 00:06:26,290
the output of the compiler and this is

00:06:24,760 --> 00:06:29,650
what's gonna actually run on your system

00:06:26,290 --> 00:06:32,320
this is what's blinking the LED so I

00:06:29,650 --> 00:06:34,660
have a slide says what is a runtime real

00:06:32,320 --> 00:06:38,800
quick poll is rust a language that has a

00:06:34,660 --> 00:06:41,770
runtime yes raise your hand no raise

00:06:38,800 --> 00:06:43,479
your hand okay we got more nose how

00:06:41,770 --> 00:06:46,270
about C is C a language with the runtime

00:06:43,479 --> 00:06:47,439
raise your hand for yes raise your hand

00:06:46,270 --> 00:06:50,409
for now

00:06:47,439 --> 00:06:51,699
the people who said yes were right it

00:06:50,409 --> 00:06:52,959
doesn't have the same kind of run time

00:06:51,699 --> 00:06:54,610
that Python has where you have an

00:06:52,959 --> 00:06:56,050
interpreter going out and taking your

00:06:54,610 --> 00:06:57,339
code and doing something with it and

00:06:56,050 --> 00:06:59,889
doing a lot of things behind the scene

00:06:57,339 --> 00:07:01,659
but there is a runtime and if there

00:06:59,889 --> 00:07:03,339
wasn't a runtime we wouldn't ever be

00:07:01,659 --> 00:07:04,689
able to execute main because you just

00:07:03,339 --> 00:07:05,499
have to drop main on the hardware and it

00:07:04,689 --> 00:07:08,439
would have to go

00:07:05,499 --> 00:07:10,059
the runtime that si and rust have is a

00:07:08,439 --> 00:07:11,830
little bit different in a lot more

00:07:10,059 --> 00:07:14,349
lightweight but there's still a couple

00:07:11,830 --> 00:07:16,360
things that the language says need to be

00:07:14,349 --> 00:07:18,249
done before you start writing mein and

00:07:16,360 --> 00:07:22,149
this is true for an embedded system or

00:07:18,249 --> 00:07:24,339
your desktop so I talked about that

00:07:22,149 --> 00:07:26,050
thing of someone else's code so at least

00:07:24,339 --> 00:07:27,699
in embedded systems the part that's

00:07:26,050 --> 00:07:29,889
doing the heavy lifting from someone

00:07:27,699 --> 00:07:34,779
else's code is to libraries there's

00:07:29,889 --> 00:07:38,349
cortex-m RT RT stands for runtime and r0

00:07:34,779 --> 00:07:41,079
which is if you've ever developed C code

00:07:38,349 --> 00:07:43,659
and you've seen the word CRT zero zero

00:07:41,079 --> 00:07:45,309
that's the C runtime and it's typically

00:07:43,659 --> 00:07:47,469
provided by your compiler unless you're

00:07:45,309 --> 00:07:49,419
doing something really weird and it's

00:07:47,469 --> 00:07:51,939
gonna be the thing that injects kind of

00:07:49,419 --> 00:07:53,469
this before main behavior and rust we've

00:07:51,939 --> 00:07:58,539
written it in rust so it's just a

00:07:53,469 --> 00:08:01,389
standalone crate called our zero so what

00:07:58,539 --> 00:08:01,839
CRT zero is or excuse me CRT zero in

00:08:01,389 --> 00:08:03,990
rust

00:08:01,839 --> 00:08:06,159
what cortex-m RT is gonna give you is

00:08:03,990 --> 00:08:08,319
this kind of a function and I've boiled

00:08:06,159 --> 00:08:10,360
this down a little bit but we've got a

00:08:08,319 --> 00:08:12,519
couple steps that our launch sequence

00:08:10,360 --> 00:08:14,469
before we get to main so the first thing

00:08:12,519 --> 00:08:18,309
that happens is we power up and this

00:08:14,469 --> 00:08:20,289
function starts executing we in cortex

00:08:18,309 --> 00:08:22,659
MRT give the ability for people to

00:08:20,289 --> 00:08:24,069
define a pre in it so if you really have

00:08:22,659 --> 00:08:25,869
to initialize something on your hardware

00:08:24,069 --> 00:08:26,949
before anything else happens maybe

00:08:25,869 --> 00:08:28,329
you're hooked up some really high

00:08:26,949 --> 00:08:30,610
voltage stuff and you need to turn it

00:08:28,329 --> 00:08:32,680
off when you first power on you might

00:08:30,610 --> 00:08:34,419
you might call the pre init hook and say

00:08:32,680 --> 00:08:37,539
I don't know do this first seriously

00:08:34,419 --> 00:08:39,669
nothing else before this then we're

00:08:37,539 --> 00:08:41,079
going to initialize the RAM and if

00:08:39,669 --> 00:08:42,699
you've developed on desktops you've

00:08:41,079 --> 00:08:44,589
probably not had to think about Ram you

00:08:42,699 --> 00:08:48,339
go ok Ram is there and it starts with

00:08:44,589 --> 00:08:49,750
zero and all of my static variables are

00:08:48,339 --> 00:08:51,490
predefined and they're loaded in when I

00:08:49,750 --> 00:08:52,930
start running but something has to do

00:08:51,490 --> 00:08:55,480
this because the hardware is not going

00:08:52,930 --> 00:08:56,319
to do it for you if we're running on a

00:08:55,480 --> 00:08:57,730
microcontroller that has a

00:08:56,319 --> 00:09:00,620
floating-point unit we're gonna turn

00:08:57,730 --> 00:09:02,480
that on just so we can do faster bath or

00:09:00,620 --> 00:09:03,950
math that actually works um and then we

00:09:02,480 --> 00:09:05,480
call mein hey that looks like a normal

00:09:03,950 --> 00:09:06,950
function call great we're gonna jump

00:09:05,480 --> 00:09:08,780
into main and that's where your main

00:09:06,950 --> 00:09:13,820
actually happens the blights start

00:09:08,780 --> 00:09:15,830
blinking now I didn't really explain

00:09:13,820 --> 00:09:17,960
much in that last thing on these

00:09:15,830 --> 00:09:20,360
embedded systems there is a concept

00:09:17,960 --> 00:09:23,900
called the reset vector and the reset

00:09:20,360 --> 00:09:27,410
vector literally is the address of where

00:09:23,900 --> 00:09:29,900
to jump to in the machine code for where

00:09:27,410 --> 00:09:32,720
you start running so a reset vector is

00:09:29,900 --> 00:09:34,940
literally the the hardware boots on you

00:09:32,720 --> 00:09:36,740
have an address and it goes thank you

00:09:34,940 --> 00:09:38,540
and then it jumps to that address like a

00:09:36,740 --> 00:09:40,610
go-to statement and it starts running

00:09:38,540 --> 00:09:43,720
that code that's called a reset vector

00:09:40,610 --> 00:09:46,940
the vector means you go there now

00:09:43,720 --> 00:09:49,130
vectors are not just the reset vector on

00:09:46,940 --> 00:09:51,500
a microcontroller you have a whole thing

00:09:49,130 --> 00:09:54,590
called a vector table and this is a

00:09:51,500 --> 00:09:56,240
definition where you put in all of these

00:09:54,590 --> 00:09:58,700
kind of vectors so the reset vector is

00:09:56,240 --> 00:10:00,650
one of these kind of vectors but it

00:09:58,700 --> 00:10:02,660
really is only one of them there are a

00:10:00,650 --> 00:10:04,160
bunch of other things like exceptions

00:10:02,660 --> 00:10:06,110
and interrupts that the hardware is

00:10:04,160 --> 00:10:07,970
going to need to know how to respond to

00:10:06,110 --> 00:10:11,390
and these work a lot like callbacks

00:10:07,970 --> 00:10:13,070
where you define a table and you put the

00:10:11,390 --> 00:10:15,560
address of some function in this whole

00:10:13,070 --> 00:10:18,230
table and whenever that event happens so

00:10:15,560 --> 00:10:19,460
on on JavaScript or something like that

00:10:18,230 --> 00:10:20,840
you'd have a callback that gets

00:10:19,460 --> 00:10:22,910
triggered here you have an interrupt

00:10:20,840 --> 00:10:25,190
that fires some response to a real

00:10:22,910 --> 00:10:27,320
hardware stimulus and this is how the

00:10:25,190 --> 00:10:29,890
hardware knows to say oh that happened

00:10:27,320 --> 00:10:34,970
run that code there right now

00:10:29,890 --> 00:10:37,640
so this all fits together in a couple

00:10:34,970 --> 00:10:38,900
different ways I've talked about ok we

00:10:37,640 --> 00:10:40,190
know that when our system power is on

00:10:38,900 --> 00:10:43,040
there's the reset vector and it knows to

00:10:40,190 --> 00:10:45,920
jump somewhere but when we compile the

00:10:43,040 --> 00:10:47,510
code what is that code like all of that

00:10:45,920 --> 00:10:49,880
binary that we've generated what does

00:10:47,510 --> 00:10:51,590
that break into well it turns out it it

00:10:49,880 --> 00:10:53,810
breaks down into about three big

00:10:51,590 --> 00:10:56,260
sections you've got the text section

00:10:53,810 --> 00:10:59,420
which is where all of your read-only

00:10:56,260 --> 00:11:00,950
parts go so your actual machine code

00:10:59,420 --> 00:11:04,100
that you generate your functions your

00:11:00,950 --> 00:11:05,930
actual code lives here because you

00:11:04,100 --> 00:11:08,060
typically don't modify it at runtime

00:11:05,930 --> 00:11:09,440
it's it's read-only this is something

00:11:08,060 --> 00:11:12,310
that your CPU is actually going to pull

00:11:09,440 --> 00:11:14,480
in and start executing it sequentially

00:11:12,310 --> 00:11:17,930
also anything that is constant

00:11:14,480 --> 00:11:19,519
whether you have predefined data if

00:11:17,930 --> 00:11:21,740
you've ever seen just strings and you've

00:11:19,519 --> 00:11:23,360
kind of accidentally typed cat on a

00:11:21,740 --> 00:11:25,100
binary file and you've seen a bunch of

00:11:23,360 --> 00:11:27,139
strings interspersed with a bunch of

00:11:25,100 --> 00:11:29,810
garbage that's because these constant

00:11:27,139 --> 00:11:31,970
strings you have are encoded as part of

00:11:29,810 --> 00:11:34,130
the binary we have another section

00:11:31,970 --> 00:11:36,139
called BSS which stands for basic

00:11:34,130 --> 00:11:37,750
service segment I don't remember it's an

00:11:36,139 --> 00:11:42,529
archaic term that we still use but

00:11:37,750 --> 00:11:43,519
what's that maybe binary storage space

00:11:42,529 --> 00:11:46,699
okay

00:11:43,519 --> 00:11:49,339
I'll have to look at Wikipedia but this

00:11:46,699 --> 00:11:51,019
is a chunk of your RAM where everything

00:11:49,339 --> 00:11:53,269
inside of it is expected to be an

00:11:51,019 --> 00:11:55,610
uninitialized in c if you were defining

00:11:53,269 --> 00:11:57,560
a global variable that you never set to

00:11:55,610 --> 00:11:59,750
you just define the global variable it

00:11:57,560 --> 00:12:01,550
would go here and as Percy's contract

00:11:59,750 --> 00:12:03,199
anything that's uninitialized gets

00:12:01,550 --> 00:12:05,180
filled with zeros so whether that's

00:12:03,199 --> 00:12:07,430
valid for that structure or not it's

00:12:05,180 --> 00:12:09,829
gonna be full of zeros Brust I believe

00:12:07,430 --> 00:12:11,389
follows this as well but it's much

00:12:09,829 --> 00:12:12,889
harder to make on initialize structured

00:12:11,389 --> 00:12:14,810
in rust the compiler really doesn't like

00:12:12,889 --> 00:12:17,420
it although now with mem uninitialized

00:12:14,810 --> 00:12:18,800
maybe you can be able to do that and

00:12:17,420 --> 00:12:22,339
then we have another section of your RAM

00:12:18,800 --> 00:12:24,019
with dot data so if you would define a

00:12:22,339 --> 00:12:26,209
global variable where you say like I've

00:12:24,019 --> 00:12:31,430
got some struct with XY and Z and X is

00:12:26,209 --> 00:12:33,380
10 and Y is 20 and Z is 100 then that

00:12:31,430 --> 00:12:35,690
structure that global variable is gonna

00:12:33,380 --> 00:12:38,269
live in Ram so the actual location of

00:12:35,690 --> 00:12:40,760
that structure lives in RAM but those

00:12:38,269 --> 00:12:42,680
initial values are gonna live somewhere

00:12:40,760 --> 00:12:44,300
else they're gonna live probably in text

00:12:42,680 --> 00:12:46,010
where you say okay all the initial

00:12:44,300 --> 00:12:47,779
values are here when you boot up take

00:12:46,010 --> 00:12:49,190
that value put it there that way

00:12:47,779 --> 00:12:53,839
everything is good to go before we get

00:12:49,190 --> 00:12:56,630
to Maine but how does it know where to

00:12:53,839 --> 00:12:58,790
put stuff well the compiler knows if you

00:12:56,630 --> 00:13:00,500
write some code and you compile a

00:12:58,790 --> 00:13:02,600
function and it makes machine code it

00:13:00,500 --> 00:13:04,639
goes dad's machine code that goes into

00:13:02,600 --> 00:13:06,949
the text section and if you define some

00:13:04,639 --> 00:13:09,110
kind of constant you know string or

00:13:06,949 --> 00:13:12,050
something like that text section global

00:13:09,110 --> 00:13:14,480
variable with without an initializer BSS

00:13:12,050 --> 00:13:16,250
with an initializer data or you put the

00:13:14,480 --> 00:13:19,430
initial value in text and you put the

00:13:16,250 --> 00:13:21,380
location there so the compiler knows how

00:13:19,430 --> 00:13:23,149
to sort these into buckets it still

00:13:21,380 --> 00:13:24,800
doesn't know how to where they should

00:13:23,149 --> 00:13:26,600
live but it can go at least when I'm

00:13:24,800 --> 00:13:27,740
compiling code goes that bucket that

00:13:26,600 --> 00:13:30,650
bucket that bucket

00:13:27,740 --> 00:13:34,460
with rusty same with LVM they know where

00:13:30,650 --> 00:13:36,380
these things are supposed to go okay so

00:13:34,460 --> 00:13:38,780
I guess if we fall down the chain the

00:13:36,380 --> 00:13:40,190
next thing is the linker how does the

00:13:38,780 --> 00:13:41,810
linker know where to put stuff because

00:13:40,190 --> 00:13:44,000
that's the linkers job is to take those

00:13:41,810 --> 00:13:45,770
huge buckets of object files that we've

00:13:44,000 --> 00:13:47,870
created in constants we've created into

00:13:45,770 --> 00:13:51,260
put them in the right places to make an

00:13:47,870 --> 00:13:53,510
actual executable how does it know well

00:13:51,260 --> 00:13:54,920
we tell it because it can't know by

00:13:53,510 --> 00:13:57,320
itself I mean if you're running on a

00:13:54,920 --> 00:13:58,520
desktop and there's a predefined place

00:13:57,320 --> 00:13:59,870
to pull all of these like if you're

00:13:58,520 --> 00:14:01,760
running on Windows or running on Linux

00:13:59,870 --> 00:14:03,830
it's gonna know out-of-the-box but on

00:14:01,760 --> 00:14:05,420
our embedded systems are kind of special

00:14:03,830 --> 00:14:06,920
in every embedded systems a little bit

00:14:05,420 --> 00:14:09,170
different and every manufacturer makes

00:14:06,920 --> 00:14:10,970
their hardware a little bit different so

00:14:09,170 --> 00:14:12,920
for embedded applications we almost

00:14:10,970 --> 00:14:14,990
always have to tell it where to put all

00:14:12,920 --> 00:14:17,630
this stuff and we do that using

00:14:14,990 --> 00:14:19,010
something called a linker file maybe

00:14:17,630 --> 00:14:21,920
you've heard of this as a scatter file

00:14:19,010 --> 00:14:24,350
but essentially there is a separately

00:14:21,920 --> 00:14:27,050
syntax document that you have to prepare

00:14:24,350 --> 00:14:28,850
that tells the linker where to put all

00:14:27,050 --> 00:14:31,160
of these things if nothing else where to

00:14:28,850 --> 00:14:33,710
put each of these categories of things

00:14:31,160 --> 00:14:36,830
so this is the part that's applicable to

00:14:33,710 --> 00:14:39,380
rust that cortex-m artie library that we

00:14:36,830 --> 00:14:41,330
have provides some magic mostly through

00:14:39,380 --> 00:14:44,240
some templates and through using a build

00:14:41,330 --> 00:14:46,790
RS script where they provide some

00:14:44,240 --> 00:14:49,790
defaults of where do you put this stuff

00:14:46,790 --> 00:14:52,340
so cortex-m artie provides a file called

00:14:49,790 --> 00:14:54,670
link text in so whenever you see one of

00:14:52,340 --> 00:14:56,570
these dot x files think linker script

00:14:54,670 --> 00:14:59,270
sometimes they're decks sometimes

00:14:56,570 --> 00:15:00,920
they're dot LD but these dot X are what

00:14:59,270 --> 00:15:02,750
we use here for these generated linker

00:15:00,920 --> 00:15:05,720
scripts so this is the base template

00:15:02,750 --> 00:15:08,270
where we say you know text goes here

00:15:05,720 --> 00:15:10,610
data goes here BSS goes here it's kind

00:15:08,270 --> 00:15:13,630
of the the skeleton of where all this

00:15:10,610 --> 00:15:15,800
goes in a in a regular embedded system

00:15:13,630 --> 00:15:17,210
some embedded systems your gonna do some

00:15:15,800 --> 00:15:18,440
really weird complex stuff so you might

00:15:17,210 --> 00:15:19,610
just jump to the end because you've got

00:15:18,440 --> 00:15:21,560
a hard code where all this stuff is

00:15:19,610 --> 00:15:23,480
anyway because you have a really special

00:15:21,560 --> 00:15:25,310
system but for most people who are

00:15:23,480 --> 00:15:26,990
writing blinky lights and even more

00:15:25,310 --> 00:15:30,140
complex software they can use this kind

00:15:26,990 --> 00:15:31,610
of template the next part is device Dex

00:15:30,140 --> 00:15:33,380
so like I said every one of these

00:15:31,610 --> 00:15:35,030
embedded systems are different one

00:15:33,380 --> 00:15:36,530
microcontroller might have ten

00:15:35,030 --> 00:15:38,510
interrupts that it can respond to and

00:15:36,530 --> 00:15:40,040
another might have a hundred and because

00:15:38,510 --> 00:15:41,600
those all need to go into the vector

00:15:40,040 --> 00:15:43,459
table that might be

00:15:41,600 --> 00:15:45,649
differently sized so you need somewhere

00:15:43,459 --> 00:15:48,949
to define okay what interrupts does my

00:15:45,649 --> 00:15:51,259
hardware actually have you need the

00:15:48,949 --> 00:15:54,050
memory X so even if you have the same

00:15:51,259 --> 00:15:56,000
chip a lot of times vendors will sell

00:15:54,050 --> 00:15:58,040
like a cheaper one with less RAM and

00:15:56,000 --> 00:16:01,279
flash and a more expensive one with more

00:15:58,040 --> 00:16:03,050
so you need to say like okay I have 64

00:16:01,279 --> 00:16:05,060
kilobytes of flash that's a lot of fat

00:16:03,050 --> 00:16:07,100
flash or like a hundred and twenty eight

00:16:05,060 --> 00:16:10,040
kilobytes of RAM that's a really a lot a

00:16:07,100 --> 00:16:12,019
lot of RAM and finally these all get

00:16:10,040 --> 00:16:14,060
smushed together by a build RS script

00:16:12,019 --> 00:16:15,620
and you end up with a file called link X

00:16:14,060 --> 00:16:17,720
and this is what gets fed into the

00:16:15,620 --> 00:16:19,310
linker that says okay you take all those

00:16:17,720 --> 00:16:20,930
object files that the compiler is gonna

00:16:19,310 --> 00:16:22,730
give you you're gonna take this

00:16:20,930 --> 00:16:25,130
configuration file and that tells you

00:16:22,730 --> 00:16:26,449
where to search and sort and put things

00:16:25,130 --> 00:16:28,100
in the right buckets and put them in the

00:16:26,449 --> 00:16:30,290
right place so you can spit out the

00:16:28,100 --> 00:16:34,069
final executable that your hardware

00:16:30,290 --> 00:16:35,930
needs so the device that X might look

00:16:34,069 --> 00:16:38,899
like this where it defines all of these

00:16:35,930 --> 00:16:41,329
different interrupts mines on an NR a 52

00:16:38,899 --> 00:16:43,040
which has a radio so you might have like

00:16:41,329 --> 00:16:44,810
a power clock interrupt or a radio

00:16:43,040 --> 00:16:46,339
interrupt and it's gonna provide come

00:16:44,810 --> 00:16:48,019
some kind of default value but really

00:16:46,339 --> 00:16:50,120
it's gonna list all of these interrupts

00:16:48,019 --> 00:16:53,209
so it knows how big that vector table is

00:16:50,120 --> 00:16:54,620
gonna be and then in memory X you might

00:16:53,209 --> 00:16:56,810
say oh and this is what a linker script

00:16:54,620 --> 00:17:00,019
syntax looks like by the way it's kind

00:16:56,810 --> 00:17:01,399
of reasonable to read but there it's a

00:17:00,019 --> 00:17:03,560
whole different syntax from any other

00:17:01,399 --> 00:17:05,900
language so we might have a section

00:17:03,560 --> 00:17:08,030
called flash this is our non-volatile

00:17:05,900 --> 00:17:10,610
memory and we're gonna say it starts at

00:17:08,030 --> 00:17:13,069
address 0 so on microcontrollers there

00:17:10,610 --> 00:17:16,270
are 32-bit systems so every address is 0

00:17:13,069 --> 00:17:19,220
0 0 0 to ffff and all of these are valid

00:17:16,270 --> 00:17:20,689
address locations so we say because

00:17:19,220 --> 00:17:24,079
we've read the datasheet that our flash

00:17:20,689 --> 00:17:29,270
lives at 0 and we've got 512 kilobytes

00:17:24,079 --> 00:17:33,260
QB bytes of it and RAM lives at 20,000

00:17:29,270 --> 00:17:36,140
hex and it's 64 K so now we've kind of

00:17:33,260 --> 00:17:38,299
told our linker we've got non-volatile

00:17:36,140 --> 00:17:39,650
memory here and volatile memory here so

00:17:38,299 --> 00:17:43,549
it goes ok I know that now

00:17:39,650 --> 00:17:45,890
and that linked X in so this like I said

00:17:43,549 --> 00:17:48,440
it's a skeleton or a template and I've

00:17:45,890 --> 00:17:50,030
taken out a lot of the complicated parts

00:17:48,440 --> 00:17:52,190
but you can see that there are generally

00:17:50,030 --> 00:17:54,350
a couple buckets that we define for our

00:17:52,190 --> 00:17:55,400
linker we've got that vector table that

00:17:54,350 --> 00:17:58,670
I talked about and we

00:17:55,400 --> 00:18:01,690
that goes at the top of flash because in

00:17:58,670 --> 00:18:04,040
a cortex-m system there's kind of a

00:18:01,690 --> 00:18:06,470
contract between you and the hardware

00:18:04,040 --> 00:18:09,260
that says that vector table always goes

00:18:06,470 --> 00:18:10,970
at memory address zero because when the

00:18:09,260 --> 00:18:12,500
system boots up it's gonna look at

00:18:10,970 --> 00:18:14,300
memory address zero and it's gonna start

00:18:12,500 --> 00:18:16,370
processing that vector table the way

00:18:14,300 --> 00:18:18,200
that you've just defined it so that

00:18:16,370 --> 00:18:19,820
lives in flash because flash is the only

00:18:18,200 --> 00:18:21,410
thing that's persistent across resets

00:18:19,820 --> 00:18:22,970
because Ram goes away whenever you turn

00:18:21,410 --> 00:18:25,790
off your power so we put all of our code

00:18:22,970 --> 00:18:28,460
in flash including the vector table so

00:18:25,790 --> 00:18:30,020
vector table goes first then text so

00:18:28,460 --> 00:18:31,880
that's all of your code that you've

00:18:30,020 --> 00:18:33,230
actually compiled as well as all of

00:18:31,880 --> 00:18:35,390
those constants and things like that

00:18:33,230 --> 00:18:38,780
then we scroll down a little bit and

00:18:35,390 --> 00:18:40,400
we've got data and BSS and those are in

00:18:38,780 --> 00:18:42,530
there too oh the one special thing I

00:18:40,400 --> 00:18:44,210
wanted to show you here we've got oh is

00:18:42,530 --> 00:18:46,490
that not updating up there I guess when

00:18:44,210 --> 00:18:48,380
I scroll on my presenter okay there's a

00:18:46,490 --> 00:18:51,740
slightly different syntax in our data

00:18:48,380 --> 00:18:54,130
section we also tell it hey the data the

00:18:51,740 --> 00:18:57,559
actual variables are gonna go in RAM and

00:18:54,130 --> 00:19:00,010
the original definitions for it are

00:18:57,559 --> 00:19:05,090
gonna go in flash so it needs to know

00:19:00,010 --> 00:19:07,130
definition here location here so with

00:19:05,090 --> 00:19:09,890
all of this put together an elf is born

00:19:07,130 --> 00:19:11,570
so if you're building a an executable

00:19:09,890 --> 00:19:13,460
and you're using the elf file format

00:19:11,570 --> 00:19:15,200
because you're on linux this is what

00:19:13,460 --> 00:19:16,910
actually contains all of that

00:19:15,200 --> 00:19:19,100
information it's got all the binary

00:19:16,910 --> 00:19:21,050
sections it's got where they go their

00:19:19,100 --> 00:19:22,970
memory addresses maybe it has debug

00:19:21,050 --> 00:19:26,840
information rolled in there but when you

00:19:22,970 --> 00:19:29,090
run Cargo build you get an elf file out

00:19:26,840 --> 00:19:34,520
that's valid for your microcontroller

00:19:29,090 --> 00:19:35,960
system so now we're down to the last

00:19:34,520 --> 00:19:38,840
part of the system we've got the

00:19:35,960 --> 00:19:40,460
hardware and this is the really magical

00:19:38,840 --> 00:19:43,850
part because once you put things in the

00:19:40,460 --> 00:19:46,370
right place everything just happens so

00:19:43,850 --> 00:19:49,160
once we've taken that elf file and we've

00:19:46,370 --> 00:19:51,260
used a debugger or a JTAG unit or an SWT

00:19:49,160 --> 00:19:53,000
unit we've taken that elf file that

00:19:51,260 --> 00:19:54,590
binary that lives on your hard drive and

00:19:53,000 --> 00:19:56,120
we've uploaded it onto our actual

00:19:54,590 --> 00:19:56,990
microcontroller and it's been smart

00:19:56,120 --> 00:19:59,150
enough where it goes okay

00:19:56,990 --> 00:20:00,620
I put the vector table at zero I put all

00:19:59,150 --> 00:20:02,600
the other code in there that vector

00:20:00,620 --> 00:20:05,300
table points to the reset vector which

00:20:02,600 --> 00:20:06,820
is inside of my code and I've got all of

00:20:05,300 --> 00:20:10,570
this area of RAM where I'm

00:20:06,820 --> 00:20:12,549
going to have my information we go and

00:20:10,570 --> 00:20:13,090
the launch sequence looks a little bit

00:20:12,549 --> 00:20:15,580
like this

00:20:13,090 --> 00:20:17,110
so the code exists in flash again after

00:20:15,580 --> 00:20:18,880
the vector table so the vector table is

00:20:17,110 --> 00:20:22,480
up top the reset vector is called

00:20:18,880 --> 00:20:24,460
because at the top of flash we said when

00:20:22,480 --> 00:20:26,230
you boot up you will call this function

00:20:24,460 --> 00:20:28,480
first and it's that reset function that

00:20:26,230 --> 00:20:31,059
we talked about in cortex mrt so it's

00:20:28,480 --> 00:20:33,909
gonna go to that location and it's gonna

00:20:31,059 --> 00:20:37,450
start running that sequence eventually

00:20:33,909 --> 00:20:39,490
it yeah cortex-m runs reset your RAM is

00:20:37,450 --> 00:20:41,799
set up and then your main is run because

00:20:39,490 --> 00:20:43,120
we've upheld the runtime invariants

00:20:41,799 --> 00:20:45,639
essentially it was just those two

00:20:43,120 --> 00:20:48,519
functions that say zero at this chunk of

00:20:45,639 --> 00:20:51,669
the RAM and copy this chunk of RAM from

00:20:48,519 --> 00:20:53,649
the flash section into the RAM section

00:20:51,669 --> 00:20:56,259
and then your main is actually run and

00:20:53,649 --> 00:20:58,840
like any other rust program it just

00:20:56,259 --> 00:21:00,039
happens and by the way this is how it

00:20:58,840 --> 00:21:01,690
works on microcontrollers but it's

00:21:00,039 --> 00:21:04,629
almost exactly the same on your desktop

00:21:01,690 --> 00:21:06,190
to Windows and Linux and Mac have

00:21:04,629 --> 00:21:07,750
slightly different launch sequences but

00:21:06,190 --> 00:21:09,759
it's going to be holding these kind of

00:21:07,750 --> 00:21:13,330
invariants the same because it has to

00:21:09,759 --> 00:21:14,559
have this runtime behavior so and then

00:21:13,330 --> 00:21:16,570
once we have it all done let there be

00:21:14,559 --> 00:21:18,970
blinky light and there is a blinky light

00:21:16,570 --> 00:21:20,409
running I actually have the hardware

00:21:18,970 --> 00:21:22,000
here so after the talk if you want to

00:21:20,409 --> 00:21:23,559
come up and see exactly how this works

00:21:22,000 --> 00:21:25,330
and I can pull up a debugger and we can

00:21:23,559 --> 00:21:27,309
step through instruction by instruction

00:21:25,330 --> 00:21:28,899
of how this actually works I'm happy to

00:21:27,309 --> 00:21:31,779
sit down and you will end up with a

00:21:28,899 --> 00:21:33,789
blinky light at the end so I have not

00:21:31,779 --> 00:21:35,950
been staring at my time but thank you

00:21:33,789 --> 00:21:39,100
very much for listening to me

00:21:35,950 --> 00:21:40,450
I have a couple plugs so one if you're

00:21:39,100 --> 00:21:42,250
interested in this kind of stuff and

00:21:40,450 --> 00:21:44,169
you're interested in embedded and you're

00:21:42,250 --> 00:21:45,850
interested in rust I'm part of the

00:21:44,169 --> 00:21:48,100
embedded working group come join us

00:21:45,850 --> 00:21:50,169
we're working really hard to make rust

00:21:48,100 --> 00:21:52,450
like the best ecosystem for embedded

00:21:50,169 --> 00:21:53,769
systems development so if this is the

00:21:52,450 --> 00:21:56,110
kind of thing that you're interested in

00:21:53,769 --> 00:21:57,190
interested in working on then come join

00:21:56,110 --> 00:22:00,159
us here I've got a link to our

00:21:57,190 --> 00:22:01,720
coordination repository I work for a

00:22:00,159 --> 00:22:03,639
company called ferrous systems like I

00:22:01,720 --> 00:22:05,980
said we do consulting in the area of

00:22:03,639 --> 00:22:09,490
systems level stuff with rust including

00:22:05,980 --> 00:22:11,590
embedded systems not shown here we're

00:22:09,490 --> 00:22:13,870
also running a conference in at the end

00:22:11,590 --> 00:22:15,700
of April called oxidize which is the

00:22:13,870 --> 00:22:17,620
first embedded rust conference and we're

00:22:15,700 --> 00:22:19,419
having it here in Berlin so we're going

00:22:17,620 --> 00:22:20,039
to be having workshops and talks on

00:22:19,419 --> 00:22:22,549
embed

00:22:20,039 --> 00:22:24,509
rust embedded Linux and bare metal

00:22:22,549 --> 00:22:25,859
development like this so that's the kind

00:22:24,509 --> 00:22:29,489
of thing that interests you come talk to

00:22:25,859 --> 00:22:31,259
me after the talk and yeah thank you

00:22:29,489 --> 00:22:32,850
that was life before main and if I still

00:22:31,259 --> 00:22:34,229
have time I can go into way more detail

00:22:32,850 --> 00:22:36,659
of the actual rust of how this works but

00:22:34,229 --> 00:22:38,399
if not then come find me after the after

00:22:36,659 --> 00:22:40,290
the talk and I'm happy to show you so

00:22:38,399 --> 00:22:45,240
thank you very much

00:22:40,290 --> 00:22:45,240
[Applause]

00:22:49,940 --> 00:22:52,000

YouTube URL: https://www.youtube.com/watch?v=RIHVoNDxNuk


