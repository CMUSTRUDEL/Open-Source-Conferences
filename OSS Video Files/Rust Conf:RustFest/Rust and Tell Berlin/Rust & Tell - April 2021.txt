Title: Rust & Tell - April 2021
Publication date: 2021-04-28
Playlist: Rust and Tell Berlin
Description: 
	All details: https://berline.rs/2021/04/27/rust-and-tell.html

00:00:00 Introduction
00:04:00 Xavier Denis - Safer Rust: program verification with Creusot
00:33:20 Bernhard Borges - Using Rust to build open-source distributed networks
01:04:16 Andreas Klostermaier - Cropping.Rocks: a Rust/Rocket/WASM microservice
Captions: 
	00:00:03,439 --> 00:00:07,680
yes

00:00:04,480 --> 00:00:10,559
good afternoon good evening good morning

00:00:07,680 --> 00:00:11,440
to everyone depending on your time zone

00:00:10,559 --> 00:00:14,960
we are really

00:00:11,440 --> 00:00:18,800
happy to have you here today for

00:00:14,960 --> 00:00:18,800
roast and teleporting station

00:00:19,520 --> 00:00:25,119
and as a presenter and organizer

00:00:22,560 --> 00:00:27,519
my name is evans and we have i have a

00:00:25,119 --> 00:00:30,640
co-organizer called scotland i

00:00:27,519 --> 00:00:33,760
think he is not available today

00:00:30,640 --> 00:00:36,480
uh probably if you have been

00:00:33,760 --> 00:00:37,840
to roast and tell from previous session

00:00:36,480 --> 00:00:40,719
on march you

00:00:37,840 --> 00:00:41,280
know a bit about me now i've been taking

00:00:40,719 --> 00:00:44,320
over

00:00:41,280 --> 00:00:45,920
from quite few strong people on the

00:00:44,320 --> 00:00:48,399
community here in ross

00:00:45,920 --> 00:00:48,399
center

00:00:49,039 --> 00:00:53,280
uh we currently have the support from

00:00:51,360 --> 00:00:56,559
bassian diane rick

00:00:53,280 --> 00:00:56,559
and ryan levick

00:00:57,680 --> 00:01:05,760
ross intel is a beginner to expert

00:01:01,359 --> 00:01:08,880
community is we are here so

00:01:05,760 --> 00:01:12,159
to share and struggles

00:01:08,880 --> 00:01:15,680
ideas hack projects

00:01:12,159 --> 00:01:19,520
on any level rosentel is a space for the

00:01:15,680 --> 00:01:19,520
community to learn and grow together

00:01:21,119 --> 00:01:25,680
and we follow the berlin code of

00:01:24,320 --> 00:01:28,119
conducts

00:01:25,680 --> 00:01:30,000
currently available berlin

00:01:28,119 --> 00:01:32,400
berlin.conduct.org

00:01:30,000 --> 00:01:33,920
if you notice anything inappropriate you

00:01:32,400 --> 00:01:36,799
can privately

00:01:33,920 --> 00:01:41,840
or directly report to us and we'll make

00:01:36,799 --> 00:01:41,840
sure to handle it

00:01:42,399 --> 00:01:49,439
the rosentel is an online meeting meetup

00:01:46,479 --> 00:01:51,600
it is broadcasted on zoom and we also

00:01:49,439 --> 00:01:53,840
have zoom chat where you will be able to

00:01:51,600 --> 00:01:56,719
ask your question to the speakers

00:01:53,840 --> 00:01:57,439
we also have breakout rooms that is

00:01:56,719 --> 00:01:59,680
after the

00:01:57,439 --> 00:02:01,920
second talk today we will have breakout

00:01:59,680 --> 00:02:05,920
room you will be assigned to a room

00:02:01,920 --> 00:02:08,239
and for a few minutes to chat to other

00:02:05,920 --> 00:02:10,399
people to other participants and

00:02:08,239 --> 00:02:12,160
if you feel alone in your room you are

00:02:10,399 --> 00:02:13,840
always have the option to come back to

00:02:12,160 --> 00:02:17,200
the main room and we can

00:02:13,840 --> 00:02:19,360
assign you to another room also after

00:02:17,200 --> 00:02:23,040
the breakout room we will have the last

00:02:19,360 --> 00:02:25,360
stop as well so just keep that in mind

00:02:23,040 --> 00:02:26,959
we also have matrix chart available so

00:02:25,360 --> 00:02:28,400
you can ask your question on matrix

00:02:26,959 --> 00:02:29,280
chart or you can ask your question

00:02:28,400 --> 00:02:32,879
directly on

00:02:29,280 --> 00:02:34,959
the zoom this stream would

00:02:32,879 --> 00:02:37,200
this meetup will be streamed live on

00:02:34,959 --> 00:02:38,800
youtube and it will be recorded and

00:02:37,200 --> 00:02:42,160
posted afterwards

00:02:38,800 --> 00:02:44,480
so if you are not willing to

00:02:42,160 --> 00:02:46,959
to show your face on the video probably

00:02:44,480 --> 00:02:50,319
this might be the best time to

00:02:46,959 --> 00:02:52,480
to turn off the video if you have

00:02:50,319 --> 00:02:53,760
questions you can type it as i said on

00:02:52,480 --> 00:02:56,080
matrix chat or

00:02:53,760 --> 00:02:58,180
on zoom we will be able to pick it up

00:02:56,080 --> 00:02:59,680
and ask the speaker at the end of

00:02:58,180 --> 00:03:03,920
[Music]

00:02:59,680 --> 00:03:06,319
the talk and also to highlight that

00:03:03,920 --> 00:03:08,319
this community is here for you so we

00:03:06,319 --> 00:03:11,840
need to build it all together

00:03:08,319 --> 00:03:15,200
this is we want you to come and speak uh

00:03:11,840 --> 00:03:17,200
as i said this uh meetup on any level

00:03:15,200 --> 00:03:18,959
whether it is something that is new

00:03:17,200 --> 00:03:20,879
something that you are working on we

00:03:18,959 --> 00:03:23,599
want to see people

00:03:20,879 --> 00:03:25,360
what people are working on with rust so

00:03:23,599 --> 00:03:28,159
we'll be really glad to

00:03:25,360 --> 00:03:28,159
hear from you

00:03:29,920 --> 00:03:33,599
today we have three talks the first one

00:03:32,400 --> 00:03:35,760
will be

00:03:33,599 --> 00:03:36,959
safer rust program verification

00:03:35,760 --> 00:03:40,080
represent

00:03:36,959 --> 00:03:42,159
the with salvia dennis and the second

00:03:40,080 --> 00:03:44,239
talk will be using ros to build open

00:03:42,159 --> 00:03:47,840
source distributed network

00:03:44,239 --> 00:03:50,720
from bernhard burgess and he's from

00:03:47,840 --> 00:03:51,920
florence and the last stop will be

00:03:50,720 --> 00:03:54,720
cropping rocks

00:03:51,920 --> 00:03:57,280
roast rocket was microservice from

00:03:54,720 --> 00:03:57,280
andreas

00:03:59,360 --> 00:04:08,000
thank you and i think we'll hand over to

00:04:03,040 --> 00:04:08,000
xavier for the first presentation

00:04:09,840 --> 00:04:16,400
thank you for the introduction um i'm

00:04:14,159 --> 00:04:19,280
very excited to be with all of you today

00:04:16,400 --> 00:04:20,560
and let me just get my slides up

00:04:19,280 --> 00:04:24,880
we'll talk a little bit about how to

00:04:20,560 --> 00:04:24,880
make rust code a bit safer

00:04:26,320 --> 00:04:30,400
so uh my name is xavier i'm a phd

00:04:29,759 --> 00:04:33,280
student

00:04:30,400 --> 00:04:34,639
in uh paris working on verification of

00:04:33,280 --> 00:04:36,560
rus programs

00:04:34,639 --> 00:04:38,400
um and that's i'm gonna be showing you a

00:04:36,560 --> 00:04:42,320
little bit of the work i've been doing

00:04:38,400 --> 00:04:44,479
uh on on this subject

00:04:42,320 --> 00:04:46,240
but first for those who aren't familiar

00:04:44,479 --> 00:04:48,320
i figured we might talk a little bit

00:04:46,240 --> 00:04:51,120
about what it means to verify a program

00:04:48,320 --> 00:04:52,320
and uh what specifically we're going to

00:04:51,120 --> 00:04:54,400
be talking about for the rest of the

00:04:52,320 --> 00:04:56,639
talk

00:04:54,400 --> 00:04:58,240
and so on the internet we often hear the

00:04:56,639 --> 00:05:00,160
phrase you know formally verifying a

00:04:58,240 --> 00:05:01,199
program or a formally verified code or

00:05:00,160 --> 00:05:04,320
things like that

00:05:01,199 --> 00:05:04,720
um but it's like what does that actually

00:05:04,320 --> 00:05:06,960
mean

00:05:04,720 --> 00:05:08,000
uh because when you ask people to

00:05:06,960 --> 00:05:09,280
actually define it

00:05:08,000 --> 00:05:11,360
they give you all sorts of different

00:05:09,280 --> 00:05:13,759
answers it's things like even

00:05:11,360 --> 00:05:15,759
unit tests to uh sort of more advanced

00:05:13,759 --> 00:05:18,080
techniques like property tests

00:05:15,759 --> 00:05:19,680
or you get all the crazy types that you

00:05:18,080 --> 00:05:22,960
find in languages like haskell

00:05:19,680 --> 00:05:24,960
or sometimes in rust as well and then

00:05:22,960 --> 00:05:28,160
you also get these more advanced things

00:05:24,960 --> 00:05:30,560
like model checkers or uh interactive

00:05:28,160 --> 00:05:33,680
theater improvers like cook or agda

00:05:30,560 --> 00:05:35,280
uh all these different tools uh

00:05:33,680 --> 00:05:36,960
they they sort of attack the same

00:05:35,280 --> 00:05:38,639
problem which is we want to show that

00:05:36,960 --> 00:05:40,479
our programs

00:05:38,639 --> 00:05:42,400
have some specific behaviors and don't

00:05:40,479 --> 00:05:45,199
have other behaviors

00:05:42,400 --> 00:05:46,960
and so what they differ on is the kinds

00:05:45,199 --> 00:05:47,680
of behaviors we can check with each

00:05:46,960 --> 00:05:50,240
approach

00:05:47,680 --> 00:05:51,520
and how we actually check those and so

00:05:50,240 --> 00:05:53,919
if we put all this on a very

00:05:51,520 --> 00:05:56,000
scientifically determined plot

00:05:53,919 --> 00:05:57,199
we get something along these lines where

00:05:56,000 --> 00:06:00,639
on the very far

00:05:57,199 --> 00:06:02,160
uh left side we have fully 100 automatic

00:06:00,639 --> 00:06:03,039
techniques that is basically type

00:06:02,160 --> 00:06:04,800
checkers

00:06:03,039 --> 00:06:06,400
where you give it a program it tells you

00:06:04,800 --> 00:06:08,080
yes or no

00:06:06,400 --> 00:06:09,600
and if no it usually gives you a pretty

00:06:08,080 --> 00:06:10,400
decent error message that sort of

00:06:09,600 --> 00:06:13,600
explains

00:06:10,400 --> 00:06:16,720
why your program doesn't do uh

00:06:13,600 --> 00:06:18,400
whatever the type say it does

00:06:16,720 --> 00:06:20,240
and then as we're willing to trade a

00:06:18,400 --> 00:06:21,280
little bit more of automation and ease

00:06:20,240 --> 00:06:24,240
of use

00:06:21,280 --> 00:06:25,919
we typically get uh a lot we get more

00:06:24,240 --> 00:06:28,240
explosivity out of our tools

00:06:25,919 --> 00:06:29,360
so we get tools like model checkers

00:06:28,240 --> 00:06:31,919
where you have to

00:06:29,360 --> 00:06:33,600
sort of build a model a representation

00:06:31,919 --> 00:06:35,199
of your program or your system

00:06:33,600 --> 00:06:37,120
uh and then you can show that it

00:06:35,199 --> 00:06:39,039
satisfies certain properties

00:06:37,120 --> 00:06:41,199
uh and then at the very far extreme end

00:06:39,039 --> 00:06:44,479
we get interactive theorem provers

00:06:41,199 --> 00:06:45,840
where uh you basically you're doing math

00:06:44,479 --> 00:06:47,120
on the computer

00:06:45,840 --> 00:06:49,199
and it just turns out that you're doing

00:06:47,120 --> 00:06:51,440
math about your programs

00:06:49,199 --> 00:06:52,479
and you can do all sorts of crazy stuff

00:06:51,440 --> 00:06:54,800
there but

00:06:52,479 --> 00:06:56,000
uh it gets very very complicated very

00:06:54,800 --> 00:06:58,479
very fast

00:06:56,000 --> 00:06:59,840
um but then in the middle there's this

00:06:58,479 --> 00:07:01,680
point uh which i

00:06:59,840 --> 00:07:02,960
kind of i kind of think it's a sort of

00:07:01,680 --> 00:07:04,720
sweet spot in this

00:07:02,960 --> 00:07:06,400
sort of verification area which is

00:07:04,720 --> 00:07:09,120
deductive verification

00:07:06,400 --> 00:07:10,400
where you have mostly automated

00:07:09,120 --> 00:07:12,720
techniques even though i

00:07:10,400 --> 00:07:14,080
kind of plotted it pretty low you have

00:07:12,720 --> 00:07:16,160
mostly automated techniques but you

00:07:14,080 --> 00:07:19,440
still need a good amount of expertise

00:07:16,160 --> 00:07:21,280
to to get very far

00:07:19,440 --> 00:07:23,759
and you're relatively expressive in what

00:07:21,280 --> 00:07:25,599
uh in what you can say

00:07:23,759 --> 00:07:26,880
so what actually is deductive

00:07:25,599 --> 00:07:28,639
verification

00:07:26,880 --> 00:07:30,479
well the idea is as the name sort of

00:07:28,639 --> 00:07:31,199
implies we want to deduce things about

00:07:30,479 --> 00:07:32,960
our programs

00:07:31,199 --> 00:07:34,319
we want to reason about them so the

00:07:32,960 --> 00:07:36,479
first thing is going to be

00:07:34,319 --> 00:07:37,680
we need a logic in which to reason about

00:07:36,479 --> 00:07:39,680
our programs

00:07:37,680 --> 00:07:41,199
and so typically what we use is what's

00:07:39,680 --> 00:07:42,400
called a logic

00:07:41,199 --> 00:07:44,800
so the idea is that we're going to

00:07:42,400 --> 00:07:46,319
associate to all the little syntactic

00:07:44,800 --> 00:07:50,000
fragments of our language

00:07:46,319 --> 00:07:51,759
a triple of the form pcq which tells us

00:07:50,000 --> 00:07:53,680
given some precondition p when we

00:07:51,759 --> 00:07:56,960
evaluate the code in c

00:07:53,680 --> 00:07:58,879
then we get the post condition q

00:07:56,960 --> 00:08:00,879
and this is very nice because it gives

00:07:58,879 --> 00:08:01,360
us a bunch of simple rules that we can

00:08:00,879 --> 00:08:03,599
then just

00:08:01,360 --> 00:08:05,440
apply to the to the code of our program

00:08:03,599 --> 00:08:08,720
to sort of reason about them

00:08:05,440 --> 00:08:10,160
um and so if we look at this a little

00:08:08,720 --> 00:08:13,039
bit more concretely

00:08:10,160 --> 00:08:14,879
um here's like a little logic for

00:08:13,039 --> 00:08:16,240
a very basic example language that's

00:08:14,879 --> 00:08:18,240
often used in like

00:08:16,240 --> 00:08:19,280
academic courses so the idea is we just

00:08:18,240 --> 00:08:22,639
have if statements

00:08:19,280 --> 00:08:24,960
while loops assignments down here uh

00:08:22,639 --> 00:08:26,000
and like sequencing and you can see you

00:08:24,960 --> 00:08:28,319
can see how

00:08:26,000 --> 00:08:29,360
like the how we define these rules like

00:08:28,319 --> 00:08:31,440
for example

00:08:29,360 --> 00:08:33,039
for skipping we just say that well

00:08:31,440 --> 00:08:35,760
nothing happens so

00:08:33,039 --> 00:08:37,440
uh if we have a precondition q after

00:08:35,760 --> 00:08:40,719
doing a skip we still have q

00:08:37,440 --> 00:08:42,320
right uh whereas for example uh for

00:08:40,719 --> 00:08:45,200
sequencing

00:08:42,320 --> 00:08:46,320
to be able to say that uh we have given

00:08:45,200 --> 00:08:48,160
p at the beginning

00:08:46,320 --> 00:08:51,040
after evaluating these two instructions

00:08:48,160 --> 00:08:53,839
we have q we need to know that

00:08:51,040 --> 00:08:54,480
evaluating s1 is going to give us some

00:08:53,839 --> 00:08:57,760
logical

00:08:54,480 --> 00:08:58,800
phrase r and then working from r when we

00:08:57,760 --> 00:09:02,000
evaluate s2

00:08:58,800 --> 00:09:03,839
we get q and so we can we can define all

00:09:02,000 --> 00:09:05,360
these rules and we can we can do proofs

00:09:03,839 --> 00:09:07,120
about our programs with this

00:09:05,360 --> 00:09:08,399
but we can ask ourselves a very

00:09:07,120 --> 00:09:09,680
reasonable question which is

00:09:08,399 --> 00:09:11,920
how do we know we actually have the

00:09:09,680 --> 00:09:13,040
right rules right like these are choices

00:09:11,920 --> 00:09:14,560
that we have to make

00:09:13,040 --> 00:09:16,000
so what happens if we actually there's a

00:09:14,560 --> 00:09:17,839
rule out there that's a little bit

00:09:16,000 --> 00:09:19,040
simpler and lets us do more proofs more

00:09:17,839 --> 00:09:20,320
easily

00:09:19,040 --> 00:09:22,720
and it turns out people thought about

00:09:20,320 --> 00:09:24,480
this problem and they came up with this

00:09:22,720 --> 00:09:26,000
idea of the weakest precondition

00:09:24,480 --> 00:09:27,440
calculus

00:09:26,000 --> 00:09:29,440
and the idea is to just take a different

00:09:27,440 --> 00:09:32,720
view of this problem of

00:09:29,440 --> 00:09:34,399
of these rules and instead just work

00:09:32,720 --> 00:09:36,080
from the post condition what we're

00:09:34,399 --> 00:09:37,600
trying to show about our program and

00:09:36,080 --> 00:09:39,120
sort of work backwards from there and

00:09:37,600 --> 00:09:41,120
just say like what's the least amount of

00:09:39,120 --> 00:09:42,560
information i actually need to know

00:09:41,120 --> 00:09:44,320
uh to be able to show this post

00:09:42,560 --> 00:09:46,880
condition um

00:09:44,320 --> 00:09:47,920
and so using this weakest precondition

00:09:46,880 --> 00:09:50,240
calculus we can

00:09:47,920 --> 00:09:51,600
we can redefine those like those horror

00:09:50,240 --> 00:09:54,240
uh logic rules that we

00:09:51,600 --> 00:09:55,279
that i was just showing uh but what's

00:09:54,240 --> 00:09:57,680
even more interesting

00:09:55,279 --> 00:09:58,480
is that we get a very nice algorithm for

00:09:57,680 --> 00:10:00,959
calculating

00:09:58,480 --> 00:10:02,480
the exact conditions uh that our program

00:10:00,959 --> 00:10:03,519
has to set or the exact conditions that

00:10:02,480 --> 00:10:07,920
have to be held

00:10:03,519 --> 00:10:09,680
for our program to satisfy some property

00:10:07,920 --> 00:10:12,560
and so we call those the verification

00:10:09,680 --> 00:10:14,240
conditions of a program

00:10:12,560 --> 00:10:15,920
and so in deductive verification what

00:10:14,240 --> 00:10:17,200
we're going to do is we're going to

00:10:15,920 --> 00:10:19,279
combine something like a weakest

00:10:17,200 --> 00:10:21,279
precondition calculus with

00:10:19,279 --> 00:10:22,959
uh automated provers and automated

00:10:21,279 --> 00:10:25,200
solvers and so

00:10:22,959 --> 00:10:26,880
uh that way we can take out a lot of

00:10:25,200 --> 00:10:28,880
busy work of solving things which is

00:10:26,880 --> 00:10:31,120
just like manipulating logical formulas

00:10:28,880 --> 00:10:32,880
that are often very very big

00:10:31,120 --> 00:10:34,160
and focus on the more interesting things

00:10:32,880 --> 00:10:36,000
which is just like

00:10:34,160 --> 00:10:37,760
uh placing a few assertions here and

00:10:36,000 --> 00:10:40,079
there and like determining invariants

00:10:37,760 --> 00:10:42,480
for loops

00:10:40,079 --> 00:10:43,279
and so this technique of deductive

00:10:42,480 --> 00:10:45,279
verification

00:10:43,279 --> 00:10:46,800
is powerful because we can talk we can

00:10:45,279 --> 00:10:48,720
say a lot of things about our programs

00:10:46,800 --> 00:10:50,240
and we can also offload a lot of work to

00:10:48,720 --> 00:10:51,360
the computer so we don't have to do a

00:10:50,240 --> 00:10:52,880
lot of the busy work

00:10:51,360 --> 00:10:54,800
and it's been applied to a bunch of

00:10:52,880 --> 00:10:57,279
different languages so uh you get

00:10:54,800 --> 00:10:59,279
functional languages like o'camel

00:10:57,279 --> 00:11:01,360
but then you also have uh like you have

00:10:59,279 --> 00:11:01,920
a bunch of different deductive verifiers

00:11:01,360 --> 00:11:03,440
for c

00:11:01,920 --> 00:11:05,200
for java for all sorts of different

00:11:03,440 --> 00:11:07,600
imperative languages uh

00:11:05,200 --> 00:11:09,040
with varying degrees of success uh each

00:11:07,600 --> 00:11:11,839
time

00:11:09,040 --> 00:11:14,399
and that varying degrees of success

00:11:11,839 --> 00:11:16,880
tends to be because of pointers

00:11:14,399 --> 00:11:17,920
so the difficulty in a systems language

00:11:16,880 --> 00:11:20,640
like c

00:11:17,920 --> 00:11:22,160
or in rust is handling pointers it's

00:11:20,640 --> 00:11:24,320
handling pointers both

00:11:22,160 --> 00:11:25,920
when we're just writing code because you

00:11:24,320 --> 00:11:29,200
know in c we get the classic

00:11:25,920 --> 00:11:30,800
like uh seg faults and use after free

00:11:29,200 --> 00:11:31,040
errors and all sorts of problems that

00:11:30,800 --> 00:11:33,760
are

00:11:31,040 --> 00:11:35,440
typically rooted in pointers and the

00:11:33,760 --> 00:11:37,600
same way that complicates our sort of

00:11:35,440 --> 00:11:38,560
informal reasoning and the way we write

00:11:37,600 --> 00:11:40,560
our programs

00:11:38,560 --> 00:11:42,480
it's going to complicate the way we

00:11:40,560 --> 00:11:43,040
prove and think about our programs in a

00:11:42,480 --> 00:11:45,760
more

00:11:43,040 --> 00:11:45,760
formal way

00:11:46,530 --> 00:11:50,240
[Music]

00:11:48,160 --> 00:11:52,000
and so researchers have spent a lot of

00:11:50,240 --> 00:11:53,120
time attacking this problem c

00:11:52,000 --> 00:11:55,760
and have come up with a bunch of

00:11:53,120 --> 00:11:58,079
specialized tools that allow us to

00:11:55,760 --> 00:11:59,839
structure our programs like formally in

00:11:58,079 --> 00:12:03,360
and reasons about them more effectively

00:11:59,839 --> 00:12:05,120
um but it it it means that

00:12:03,360 --> 00:12:07,120
all these like a deductive techniques

00:12:05,120 --> 00:12:08,639
are going to be a lot less efficient

00:12:07,120 --> 00:12:10,399
because it's just a fundamentally more

00:12:08,639 --> 00:12:13,120
complicated thing

00:12:10,399 --> 00:12:13,600
and so we can see like what i mean here

00:12:13,120 --> 00:12:15,839
where

00:12:13,600 --> 00:12:17,120
even in the most simple c program we

00:12:15,839 --> 00:12:18,720
have a lot of things that we have to

00:12:17,120 --> 00:12:21,440
consider if we want to talk about what

00:12:18,720 --> 00:12:23,600
it means for it to be correct

00:12:21,440 --> 00:12:25,360
something as simple as incrementing two

00:12:23,600 --> 00:12:27,120
pointers

00:12:25,360 --> 00:12:28,720
is actually hiding a lot of sort of

00:12:27,120 --> 00:12:30,720
potentially undefined behavior

00:12:28,720 --> 00:12:32,720
right so if we just want to say like

00:12:30,720 --> 00:12:35,760
okay well does this program increment

00:12:32,720 --> 00:12:36,160
not crash does it run does this function

00:12:35,760 --> 00:12:38,320
call

00:12:36,160 --> 00:12:39,279
succeed well to know that we need to

00:12:38,320 --> 00:12:41,839
know that a and b

00:12:39,279 --> 00:12:43,279
are both initialized that they point to

00:12:41,839 --> 00:12:45,920
initialized memory

00:12:43,279 --> 00:12:46,399
uh and the question of allegating here

00:12:45,920 --> 00:12:48,560
isn't

00:12:46,399 --> 00:12:50,240
important in this example but it often

00:12:48,560 --> 00:12:53,519
is even for fundamental things we need

00:12:50,240 --> 00:12:55,839
to know that a and b are separate

00:12:53,519 --> 00:12:57,200
and all these challenges it turns out

00:12:55,839 --> 00:12:58,720
are also sort of the challenges that

00:12:57,200 --> 00:13:00,480
russ was made to address in the first

00:12:58,720 --> 00:13:02,160
place right that's why we have borrowing

00:13:00,480 --> 00:13:03,920
that's why we have lifetimes that's why

00:13:02,160 --> 00:13:05,440
we have all these nice things

00:13:03,920 --> 00:13:07,279
it just takes all these problems off the

00:13:05,440 --> 00:13:10,480
table for rest code

00:13:07,279 --> 00:13:12,160
um and so that's exactly uh

00:13:10,480 --> 00:13:13,839
like if we translate the same example

00:13:12,160 --> 00:13:15,920
into rus that's exactly what we

00:13:13,839 --> 00:13:17,600
we can conclude informally right like if

00:13:15,920 --> 00:13:20,880
we have two borrows

00:13:17,600 --> 00:13:21,600
a and b on some integer well we can

00:13:20,880 --> 00:13:23,040
freely just

00:13:21,600 --> 00:13:24,320
increment the value of a with the value

00:13:23,040 --> 00:13:25,760
of b and we don't have to worry about

00:13:24,320 --> 00:13:26,959
any sort of memory problems right we

00:13:25,760 --> 00:13:28,000
know it's going to run we know it's

00:13:26,959 --> 00:13:30,079
going to succeed

00:13:28,000 --> 00:13:31,519
we actually we would like to even say

00:13:30,079 --> 00:13:33,600
that not only is it going to succeed but

00:13:31,519 --> 00:13:35,440
the value of a is going to be

00:13:33,600 --> 00:13:37,920
the value incremented by whatever was

00:13:35,440 --> 00:13:37,920
inside of b

00:13:38,480 --> 00:13:42,800
and so the idea is that we want to

00:13:42,000 --> 00:13:44,320
leverage

00:13:42,800 --> 00:13:46,639
the same properties of the type system

00:13:44,320 --> 00:13:48,560
that allow us to write simple rust code

00:13:46,639 --> 00:13:50,160
that use pointers and not worry about

00:13:48,560 --> 00:13:52,240
memory like memory issues

00:13:50,160 --> 00:13:54,320
seg faults all sorts of stuff we want to

00:13:52,240 --> 00:13:55,920
leverage that in verification as well

00:13:54,320 --> 00:13:57,680
right we don't like we want our

00:13:55,920 --> 00:14:00,320
verifiers to be able to sort of in a way

00:13:57,680 --> 00:14:01,279
assume that the memory is going to be

00:14:00,320 --> 00:14:03,040
well behaved

00:14:01,279 --> 00:14:05,199
and then simplify all the work that they

00:14:03,040 --> 00:14:07,440
have to do behind

00:14:05,199 --> 00:14:09,279
and so that's what uh i've been working

00:14:07,440 --> 00:14:11,360
on in crozo which is a deductive

00:14:09,279 --> 00:14:13,279
verifier for rust

00:14:11,360 --> 00:14:14,639
that heavily leans on the rust type

00:14:13,279 --> 00:14:15,839
system to simplify

00:14:14,639 --> 00:14:18,560
the work it has to do during

00:14:15,839 --> 00:14:18,560
verification

00:14:19,040 --> 00:14:22,399
and so the way it's going to work the

00:14:20,480 --> 00:14:23,199
way closure works is that it translates

00:14:22,399 --> 00:14:26,079
russ code

00:14:23,199 --> 00:14:26,959
into a functional language uh and that

00:14:26,079 --> 00:14:28,880
we can re-exit

00:14:26,959 --> 00:14:30,970
we can reuse existing tools for

00:14:28,880 --> 00:14:32,320
functional language verification

00:14:30,970 --> 00:14:34,880
[Music]

00:14:32,320 --> 00:14:35,600
and and then prove properties on that

00:14:34,880 --> 00:14:37,040
translation

00:14:35,600 --> 00:14:40,000
and know that they hold about our

00:14:37,040 --> 00:14:40,000
original russ program

00:14:40,240 --> 00:14:45,279
and so the key the key the key to kojo

00:14:43,839 --> 00:14:48,079
is this technique developed

00:14:45,279 --> 00:14:48,959
by um the authors of a paper called rust

00:14:48,079 --> 00:14:52,160
horn which is

00:14:48,959 --> 00:14:54,959
a verifier for rust uh where

00:14:52,160 --> 00:14:56,480
we use uh a little trick to represent

00:14:54,959 --> 00:14:58,560
mutable boros we use

00:14:56,480 --> 00:14:59,600
what's called non-determinism where

00:14:58,560 --> 00:15:01,839
we're going to guess

00:14:59,600 --> 00:15:03,519
uh basically we're going to guess values

00:15:01,839 --> 00:15:04,880
about the borrowers

00:15:03,519 --> 00:15:07,680
and turns out we're just allowed to do

00:15:04,880 --> 00:15:09,440
that um

00:15:07,680 --> 00:15:11,360
so this part might get a little bit

00:15:09,440 --> 00:15:13,360
technical so if you don't

00:15:11,360 --> 00:15:14,480
follow fully it doesn't really matter

00:15:13,360 --> 00:15:16,560
we'll get back to

00:15:14,480 --> 00:15:18,320
sort of more concrete examples in a few

00:15:16,560 --> 00:15:19,760
minutes

00:15:18,320 --> 00:15:21,839
but i i just wanted to give a little bit

00:15:19,760 --> 00:15:25,199
of intuition for this translation

00:15:21,839 --> 00:15:27,760
so the idea is if we have some value a

00:15:25,199 --> 00:15:29,040
and we create a borrow b from a for some

00:15:27,760 --> 00:15:31,600
lifetime alpha

00:15:29,040 --> 00:15:33,440
well as we know in rust when we borrowed

00:15:31,600 --> 00:15:35,199
a value we can no longer access that

00:15:33,440 --> 00:15:35,680
original name we had for the value right

00:15:35,199 --> 00:15:38,000
like

00:15:35,680 --> 00:15:40,320
once we've borrowed a we can't use a

00:15:38,000 --> 00:15:42,959
until we give until alpha is done

00:15:40,320 --> 00:15:44,480
until the lifetime of our borrow is done

00:15:42,959 --> 00:15:47,120
um

00:15:44,480 --> 00:15:48,240
and that also means every modification

00:15:47,120 --> 00:15:51,199
to the value of a

00:15:48,240 --> 00:15:52,959
has to go through b right so when we get

00:15:51,199 --> 00:15:55,279
to the end of alpha

00:15:52,959 --> 00:15:56,720
really we know that whatever the value

00:15:55,279 --> 00:16:00,480
point whatever the value

00:15:56,720 --> 00:16:02,399
is pointed to by b at that moment

00:16:00,480 --> 00:16:04,639
has to it has to be the same value as a

00:16:02,399 --> 00:16:05,600
is going to have exactly when we recover

00:16:04,639 --> 00:16:08,959
a right like

00:16:05,600 --> 00:16:10,560
the two have to coincide right here

00:16:08,959 --> 00:16:12,880
and so that's exactly what we're going

00:16:10,560 --> 00:16:15,759
to do in our translation

00:16:12,880 --> 00:16:16,959
uh the idea is we just want to we just

00:16:15,759 --> 00:16:18,959
want to line up

00:16:16,959 --> 00:16:21,440
the value of b at the end of alpha with

00:16:18,959 --> 00:16:24,240
the value of a once we recover it

00:16:21,440 --> 00:16:25,279
and so what we're going to do is in our

00:16:24,240 --> 00:16:28,000
translation

00:16:25,279 --> 00:16:29,199
when we create our borrow b we're going

00:16:28,000 --> 00:16:30,959
to just guess

00:16:29,199 --> 00:16:33,040
its final value we're going to guess the

00:16:30,959 --> 00:16:34,240
value of b at the end of alpha

00:16:33,040 --> 00:16:36,160
and we're just going to immediately

00:16:34,240 --> 00:16:38,880
update a with it we're going to give a

00:16:36,160 --> 00:16:39,920
a value that comes from the future uh

00:16:38,880 --> 00:16:42,959
and then we can just do

00:16:39,920 --> 00:16:45,120
a bunch of work using b as a pointer

00:16:42,959 --> 00:16:46,480
right like as we would normally so

00:16:45,120 --> 00:16:49,600
that's what we do here where

00:16:46,480 --> 00:16:50,480
we just write like 5 into b and so we in

00:16:49,600 --> 00:16:52,079
our translation

00:16:50,480 --> 00:16:53,759
we're updating the value that we have in

00:16:52,079 --> 00:16:55,360
b uh

00:16:53,759 --> 00:16:56,880
uh whenever we would get to the to the

00:16:55,360 --> 00:16:59,759
mo that b is dropped

00:16:56,880 --> 00:17:00,079
that our our borrow is given up we do

00:16:59,759 --> 00:17:02,839
this

00:17:00,079 --> 00:17:06,240
sort of magical thing here which is an

00:17:02,839 --> 00:17:08,720
assume where we're just gonna say well

00:17:06,240 --> 00:17:10,240
it turns out that the final value of b

00:17:08,720 --> 00:17:13,679
is exactly the value of b

00:17:10,240 --> 00:17:16,000
here right now um and so

00:17:13,679 --> 00:17:16,720
through this sort of magic trick we can

00:17:16,000 --> 00:17:18,720
conclude

00:17:16,720 --> 00:17:19,839
then that a must be 5 because we know

00:17:18,720 --> 00:17:22,079
that a

00:17:19,839 --> 00:17:23,520
is the final value b and the final value

00:17:22,079 --> 00:17:26,640
of b is its current value

00:17:23,520 --> 00:17:28,640
and the current value is 5. and so by

00:17:26,640 --> 00:17:30,720
doing this we've actually encoded

00:17:28,640 --> 00:17:32,000
sort of mutable pointers into a

00:17:30,720 --> 00:17:33,600
functional language

00:17:32,000 --> 00:17:35,200
without having to do any sort of

00:17:33,600 --> 00:17:36,720
complicated things like functional

00:17:35,200 --> 00:17:39,200
references we get this

00:17:36,720 --> 00:17:39,919
nice encoding that's very easy to verify

00:17:39,200 --> 00:17:42,000
uh

00:17:39,919 --> 00:17:43,200
and sort of sidesteps all the challenges

00:17:42,000 --> 00:17:45,280
with verifying

00:17:43,200 --> 00:17:46,960
mutable pointer or code using immutable

00:17:45,280 --> 00:17:50,080
pointers

00:17:46,960 --> 00:17:52,000
um so

00:17:50,080 --> 00:17:54,240
we've proven that this translation is

00:17:52,000 --> 00:17:57,919
correct uh on paper at least

00:17:54,240 --> 00:17:59,520
uh the proof is not very interesting

00:17:57,919 --> 00:18:01,600
but what it tells us is that if a

00:17:59,520 --> 00:18:03,039
translated program is like if

00:18:01,600 --> 00:18:04,799
a translated pro if the proverbs

00:18:03,039 --> 00:18:05,120
determine a translated program is safe

00:18:04,799 --> 00:18:08,000
it's

00:18:05,120 --> 00:18:09,440
correct then our original rus program

00:18:08,000 --> 00:18:11,919
must also be

00:18:09,440 --> 00:18:13,360
um and so we yeah as i said we've done

00:18:11,919 --> 00:18:15,919
this proof

00:18:13,360 --> 00:18:16,799
uh it's a it's a challenging proof to do

00:18:15,919 --> 00:18:18,480
um

00:18:16,799 --> 00:18:20,000
but what's more interesting is that

00:18:18,480 --> 00:18:21,760
we're working on a new proof with the

00:18:20,000 --> 00:18:23,600
authors of rust horn

00:18:21,760 --> 00:18:25,039
uh which is much stronger and much more

00:18:23,600 --> 00:18:26,400
extensible and notably

00:18:25,039 --> 00:18:28,480
would allow us to handle things like

00:18:26,400 --> 00:18:30,480
unsafe code like justify

00:18:28,480 --> 00:18:32,640
mixing unsafe code into your safe code

00:18:30,480 --> 00:18:35,520
and then verifying all that together

00:18:32,640 --> 00:18:36,240
um so that is going to be that's the

00:18:35,520 --> 00:18:39,520
current work

00:18:36,240 --> 00:18:42,720
and uh should be very interesting

00:18:39,520 --> 00:18:45,039
um so uh then

00:18:42,720 --> 00:18:46,160
on top of all this we need to talk about

00:18:45,039 --> 00:18:49,200
uh

00:18:46,160 --> 00:18:50,880
what it means uh

00:18:49,200 --> 00:18:52,480
how we how we actually describe the

00:18:50,880 --> 00:18:54,400
behaviors of our arrest programs

00:18:52,480 --> 00:18:56,559
so what we've talked about right now is

00:18:54,400 --> 00:18:59,360
the translation of rust programs

00:18:56,559 --> 00:18:59,840
which uh allows us to to to then verify

00:18:59,360 --> 00:19:01,520
them

00:18:59,840 --> 00:19:03,120
but we still have to talk about like

00:19:01,520 --> 00:19:04,640
what can we actually say about our

00:19:03,120 --> 00:19:06,960
programs and so that's what we call a

00:19:04,640 --> 00:19:09,200
program logic

00:19:06,960 --> 00:19:10,640
and that's a work that we've been doing

00:19:09,200 --> 00:19:13,600
so we've been developing

00:19:10,640 --> 00:19:14,720
a logic that lets us say uh say what

00:19:13,600 --> 00:19:16,480
we're gonna do

00:19:14,720 --> 00:19:19,120
and notably it also allows us to talk

00:19:16,480 --> 00:19:19,760
about the values of mutable borrows and

00:19:19,120 --> 00:19:22,080
so

00:19:19,760 --> 00:19:23,760
talk about like well this function gives

00:19:22,080 --> 00:19:26,799
you a mutable borrower that's the

00:19:23,760 --> 00:19:28,160
element of a list or something like that

00:19:26,799 --> 00:19:31,440
and talk about what you're going to do

00:19:28,160 --> 00:19:31,440
when that mutable borrow is done

00:19:31,919 --> 00:19:36,400
so our our program logic the language of

00:19:35,280 --> 00:19:39,600
our specifications

00:19:36,400 --> 00:19:40,080
is basically a fragment of rust so we

00:19:39,600 --> 00:19:43,120
have

00:19:40,080 --> 00:19:44,720
uh sort of pairs so we have here's a

00:19:43,120 --> 00:19:47,120
sort of simplified syntax but in

00:19:44,720 --> 00:19:50,320
practice it's a fragment of rust we have

00:19:47,120 --> 00:19:53,280
our constructors our tuples our uh

00:19:50,320 --> 00:19:55,280
our enums we have constants we have all

00:19:53,280 --> 00:19:57,760
sorts of pure expressions so

00:19:55,280 --> 00:19:58,640
arithmetic comparisons function calls

00:19:57,760 --> 00:20:00,960
even

00:19:58,640 --> 00:20:02,480
uh so you can do all these fun things in

00:20:00,960 --> 00:20:04,880
your specifications

00:20:02,480 --> 00:20:06,960
uh but we've also added two sort of

00:20:04,880 --> 00:20:09,200
special operators with this rather ugly

00:20:06,960 --> 00:20:12,320
syntax

00:20:09,200 --> 00:20:15,520
which are t at fin and t at now

00:20:12,320 --> 00:20:19,679
which we use to refer to the values of

00:20:15,520 --> 00:20:21,760
borrows in our specifications and so

00:20:19,679 --> 00:20:24,400
we'll look at that just in a second and

00:20:21,760 --> 00:20:24,400
what that means

00:20:24,720 --> 00:20:28,559
so going back to our very very first

00:20:27,039 --> 00:20:30,720
example

00:20:28,559 --> 00:20:32,640
we have a little function that

00:20:30,720 --> 00:20:34,159
increments a mutable borrow using the

00:20:32,640 --> 00:20:36,640
values stored inside of

00:20:34,159 --> 00:20:38,000
another mutable bar and we want to

00:20:36,640 --> 00:20:40,400
actually describe

00:20:38,000 --> 00:20:41,760
what that function is going to do right

00:20:40,400 --> 00:20:43,120
we want to be able to prove what it's

00:20:41,760 --> 00:20:44,720
going to do so first we have to describe

00:20:43,120 --> 00:20:46,880
what it's going to do

00:20:44,720 --> 00:20:48,880
and so that's what we write up here and

00:20:46,880 --> 00:20:50,960
these little pragma clauses

00:20:48,880 --> 00:20:52,480
where we give two post conditions

00:20:50,960 --> 00:20:57,120
denoted by the keyword

00:20:52,480 --> 00:20:59,919
insurers and we say the final value of a

00:20:57,120 --> 00:21:01,280
is equal to its original value the value

00:20:59,919 --> 00:21:04,240
at entry

00:21:01,280 --> 00:21:06,880
along with the original value of b

00:21:04,240 --> 00:21:08,799
whereas the final value of b

00:21:06,880 --> 00:21:10,400
is exactly its original value so b is

00:21:08,799 --> 00:21:13,000
unchanged

00:21:10,400 --> 00:21:14,720
whereas a is the increment

00:21:13,000 --> 00:21:16,400
[Music]

00:21:14,720 --> 00:21:18,159
and so it's a relatively concise

00:21:16,400 --> 00:21:20,320
specification that gives us

00:21:18,159 --> 00:21:21,840
uh exactly what we want to know about

00:21:20,320 --> 00:21:23,520
that tells us exactly what we want to

00:21:21,840 --> 00:21:24,799
know about increment right that it

00:21:23,520 --> 00:21:27,200
it's a function which calculates the

00:21:24,799 --> 00:21:30,000
increment um

00:21:27,200 --> 00:21:31,280
and so yeah so the value of at fin here

00:21:30,000 --> 00:21:32,799
is a value that comes from the

00:21:31,280 --> 00:21:34,159
from the future of a borrowed right

00:21:32,799 --> 00:21:35,360
we're talking about the value a borrow

00:21:34,159 --> 00:21:37,440
will have at the point

00:21:35,360 --> 00:21:38,799
it's going to be dropped so that point

00:21:37,440 --> 00:21:40,960
could be way down in

00:21:38,799 --> 00:21:42,320
the executioner program and yet we can

00:21:40,960 --> 00:21:44,559
still actually talk about it in our

00:21:42,320 --> 00:21:48,559
specifications in a sort of coherent

00:21:44,559 --> 00:21:50,400
sense um and it's rather

00:21:48,559 --> 00:21:51,679
natural in fact i think to want to do

00:21:50,400 --> 00:21:52,960
this in rust because

00:21:51,679 --> 00:21:55,039
we want to be able to do things like

00:21:52,960 --> 00:21:56,960
return a borrow that is actually a sub

00:21:55,039 --> 00:21:58,320
part of some other bigger borrow and

00:21:56,960 --> 00:21:59,280
sort of talk about how they're related

00:21:58,320 --> 00:22:02,880
together

00:21:59,280 --> 00:22:05,919
um and so that's um that's what this

00:22:02,880 --> 00:22:09,600
constructor allows us to do

00:22:05,919 --> 00:22:11,200
um so yeah so now we can see sort of how

00:22:09,600 --> 00:22:11,679
we actually apply this and how we

00:22:11,200 --> 00:22:14,880
actually

00:22:11,679 --> 00:22:16,559
get uh get something out of our borrows

00:22:14,880 --> 00:22:19,200
and our specifications

00:22:16,559 --> 00:22:21,120
um so we have our increment function

00:22:19,200 --> 00:22:23,600
with its specification up here

00:22:21,120 --> 00:22:25,520
and we just want to we want to verify we

00:22:23,600 --> 00:22:27,200
want to verify that these two assertions

00:22:25,520 --> 00:22:29,039
are statically true we want to

00:22:27,200 --> 00:22:30,320
prove that they're going to always be

00:22:29,039 --> 00:22:32,240
true

00:22:30,320 --> 00:22:33,440
and so i mean it's sort of intuitively

00:22:32,240 --> 00:22:35,840
true of course

00:22:33,440 --> 00:22:36,559
but we can sort of step through and see

00:22:35,840 --> 00:22:39,840
what

00:22:36,559 --> 00:22:41,520
our tool is going to to see in a formal

00:22:39,840 --> 00:22:43,360
sense and how it can actually conclude

00:22:41,520 --> 00:22:46,480
that those two assertions

00:22:43,360 --> 00:22:49,600
are true uh

00:22:46,480 --> 00:22:50,960
so as we evaluate our code we on the on

00:22:49,600 --> 00:22:51,679
the right hand side here i have some

00:22:50,960 --> 00:22:53,679
sort of

00:22:51,679 --> 00:22:55,520
logical environment which is just sort

00:22:53,679 --> 00:22:57,360
of saying how the tool

00:22:55,520 --> 00:22:59,039
uh understands the state of the rust

00:22:57,360 --> 00:23:00,960
program to be

00:22:59,039 --> 00:23:03,360
so we we evaluate a code so for the

00:23:00,960 --> 00:23:05,919
moment we just know things about x and y

00:23:03,360 --> 00:23:08,000
uh and we get to this point and we

00:23:05,919 --> 00:23:11,679
perform the two borrows for x and y

00:23:08,000 --> 00:23:13,200
so as i said uh way back when

00:23:11,679 --> 00:23:15,280
when we create a borrow we're going to

00:23:13,200 --> 00:23:17,360
guess its final value ahead of time

00:23:15,280 --> 00:23:19,440
right so we're going to guess some value

00:23:17,360 --> 00:23:20,880
v1 and some value v2

00:23:19,440 --> 00:23:22,640
we don't really know what value it is

00:23:20,880 --> 00:23:24,000
but we we know it's going to be the

00:23:22,640 --> 00:23:25,280
final value

00:23:24,000 --> 00:23:27,200
and then we're going to call the

00:23:25,280 --> 00:23:29,200
increment function

00:23:27,200 --> 00:23:30,320
and so when we call the increment

00:23:29,200 --> 00:23:33,200
function

00:23:30,320 --> 00:23:35,200
we actually we end up recovering sort of

00:23:33,200 --> 00:23:35,679
logically the post conditions right like

00:23:35,200 --> 00:23:37,520
we

00:23:35,679 --> 00:23:38,880
we have when we call a function we have

00:23:37,520 --> 00:23:39,760
to show that the preconditions that

00:23:38,880 --> 00:23:41,200
function hold

00:23:39,760 --> 00:23:43,520
and that we know that the post

00:23:41,200 --> 00:23:45,279
conditions must hold after the call

00:23:43,520 --> 00:23:46,880
and so that's exactly what we recover

00:23:45,279 --> 00:23:50,159
here where we recover that

00:23:46,880 --> 00:23:51,840
the final value of a so a dot fin must

00:23:50,159 --> 00:23:54,640
be a dot now plus a dot b

00:23:51,840 --> 00:23:56,400
so 10 plus 5 so it must be 15 whereas

00:23:54,640 --> 00:23:58,000
the final value of b

00:23:56,400 --> 00:24:00,480
must just be the same as its current

00:23:58,000 --> 00:24:04,080
value and so we recover here just that

00:24:00,480 --> 00:24:05,679
v1 is 15 and v2 is 5. um

00:24:04,080 --> 00:24:08,000
and then from that it becomes rather

00:24:05,679 --> 00:24:11,120
easy to see how we can show that

00:24:08,000 --> 00:24:14,400
x must be 15 since we know that x is z1

00:24:11,120 --> 00:24:17,200
v1 is 15 therefore x must be 15.

00:24:14,400 --> 00:24:18,640
um and the same the same then applies to

00:24:17,200 --> 00:24:22,559
y

00:24:18,640 --> 00:24:23,200
um so uh we can then put all this

00:24:22,559 --> 00:24:24,960
together

00:24:23,200 --> 00:24:26,400
uh and we can actually talk about

00:24:24,960 --> 00:24:29,520
verification of

00:24:26,400 --> 00:24:31,760
sort of more complex programs uh so

00:24:29,520 --> 00:24:34,000
i'll very briefly go over this example

00:24:31,760 --> 00:24:35,919
uh but we can actually verify

00:24:34,000 --> 00:24:37,600
fairly complex data structures involving

00:24:35,919 --> 00:24:38,880
things like linked list without any

00:24:37,600 --> 00:24:40,799
difficulty

00:24:38,880 --> 00:24:43,039
and so here we have a little function

00:24:40,799 --> 00:24:45,200
all it does is zero out

00:24:43,039 --> 00:24:47,200
uh linked list so we take we take a

00:24:45,200 --> 00:24:50,400
linked list defined up here

00:24:47,200 --> 00:24:51,360
and we take a mutable borrow to a linked

00:24:50,400 --> 00:24:53,360
list

00:24:51,360 --> 00:24:55,440
and all we do is we loop over our linked

00:24:53,360 --> 00:24:57,520
list and as long as we have another cell

00:24:55,440 --> 00:25:00,880
in the list then we zero it out

00:24:57,520 --> 00:25:01,200
and then we move along and so we'd like

00:25:00,880 --> 00:25:02,799
to

00:25:01,200 --> 00:25:04,240
we'd like to be able to show that all

00:25:02,799 --> 00:25:06,159
zero is going to result

00:25:04,240 --> 00:25:07,679
is going to put zero inside every cell

00:25:06,159 --> 00:25:09,600
with our list

00:25:07,679 --> 00:25:11,440
so first we have to actually describe

00:25:09,600 --> 00:25:12,480
what it means to put zero in every cell

00:25:11,440 --> 00:25:14,400
of our list

00:25:12,480 --> 00:25:16,159
so we have we have to define a few

00:25:14,400 --> 00:25:18,320
helpers first so

00:25:16,159 --> 00:25:20,720
we have this little annotation logic

00:25:18,320 --> 00:25:23,039
which lets us write rush functions

00:25:20,720 --> 00:25:24,960
that we actually can't execute at

00:25:23,039 --> 00:25:26,559
runtime these aren't real rush functions

00:25:24,960 --> 00:25:28,880
but they allow us to write

00:25:26,559 --> 00:25:31,120
uh they they allow us to write little

00:25:28,880 --> 00:25:32,640
things to use in our logic

00:25:31,120 --> 00:25:35,279
so you can note that the return type

00:25:32,640 --> 00:25:36,640
here for example is int with a big i

00:25:35,279 --> 00:25:38,720
and we're talking about here about

00:25:36,640 --> 00:25:41,520
unbounded integers right not like

00:25:38,720 --> 00:25:44,000
u64 u32 or anything like that so we have

00:25:41,520 --> 00:25:46,400
all the mathematical integers that are

00:25:44,000 --> 00:25:47,200
at our disposition so all we do is we

00:25:46,400 --> 00:25:49,039
write a little

00:25:47,200 --> 00:25:50,400
link function that calculates the list

00:25:49,039 --> 00:25:53,200
of the length of our list

00:25:50,400 --> 00:25:54,559
as an unbounded integer and a little

00:25:53,200 --> 00:25:56,799
accessor function

00:25:54,559 --> 00:25:59,279
which just looks up a cell inside of a

00:25:56,799 --> 00:26:02,240
list and gives us a you like an option

00:25:59,279 --> 00:26:02,960
of whatever is inside of there um and

00:26:02,240 --> 00:26:05,600
these are all

00:26:02,960 --> 00:26:07,039
sort of happening in our in the logic

00:26:05,600 --> 00:26:08,960
which allows us to use it in

00:26:07,039 --> 00:26:11,360
specifications

00:26:08,960 --> 00:26:12,080
so then we can give a specification to

00:26:11,360 --> 00:26:14,559
our

00:26:12,080 --> 00:26:15,520
little all zero function which just

00:26:14,559 --> 00:26:18,159
tells us

00:26:15,520 --> 00:26:20,720
okay well for every i that's less than

00:26:18,159 --> 00:26:23,760
the length of our list

00:26:20,720 --> 00:26:25,200
when we look up i in the final value of

00:26:23,760 --> 00:26:28,400
the list

00:26:25,200 --> 00:26:30,960
we're going to find zero uh and

00:26:28,400 --> 00:26:32,320
also a second thing we know is that the

00:26:30,960 --> 00:26:33,679
length of the list is unchanged

00:26:32,320 --> 00:26:35,760
which means that we haven't added or

00:26:33,679 --> 00:26:38,320
removed any cells of our list right we

00:26:35,760 --> 00:26:42,320
didn't accidentally delete everything

00:26:38,320 --> 00:26:45,679
um and so uh hopefully that's

00:26:42,320 --> 00:26:48,400
the specification is uh satisfactory to

00:26:45,679 --> 00:26:50,720
everyone and so then to actually show

00:26:48,400 --> 00:26:52,080
the specification to be true

00:26:50,720 --> 00:26:54,000
we just need to add a few more

00:26:52,080 --> 00:26:58,000
conditions

00:26:54,000 --> 00:27:00,640
just a few um so we just need to add

00:26:58,000 --> 00:27:01,440
invariants to our loop which are going

00:27:00,640 --> 00:27:03,919
to tell us

00:27:01,440 --> 00:27:05,279
properties that hold throughout our loop

00:27:03,919 --> 00:27:06,880
and basically we just add

00:27:05,279 --> 00:27:08,640
exactly the conditions that we want to

00:27:06,880 --> 00:27:11,679
proof uh

00:27:08,640 --> 00:27:13,520
as invariants to the loop uh and

00:27:11,679 --> 00:27:16,480
then closure is happy to tell us that

00:27:13,520 --> 00:27:18,480
this example is 100 correct

00:27:16,480 --> 00:27:20,399
um and so with that we've actually

00:27:18,480 --> 00:27:21,039
verified a little bit of a program using

00:27:20,399 --> 00:27:24,080
pointers

00:27:21,039 --> 00:27:25,760
and doing uh some some

00:27:24,080 --> 00:27:27,279
fairly trivial operations but it turns

00:27:25,760 --> 00:27:30,960
out not so trivial

00:27:27,279 --> 00:27:35,120
um operations on on those pointed

00:27:30,960 --> 00:27:38,320
on those pointed values um

00:27:35,120 --> 00:27:40,640
so yeah so hopefully i didn't go too

00:27:38,320 --> 00:27:41,520
fast and didn't lose everyone um i'm

00:27:40,640 --> 00:27:44,080
sorry if i

00:27:41,520 --> 00:27:45,679
wasn't able to go into uh enough detail

00:27:44,080 --> 00:27:46,080
but i'd be happy to answer any questions

00:27:45,679 --> 00:27:49,279
uh

00:27:46,080 --> 00:27:51,840
now ordering the breakout session um

00:27:49,279 --> 00:27:53,520
and just as a quick summary uh some of

00:27:51,840 --> 00:27:56,000
the ongoing work we have

00:27:53,520 --> 00:27:57,120
is basically just extending this proof

00:27:56,000 --> 00:27:58,799
um

00:27:57,120 --> 00:28:00,799
so extending the proof that our approach

00:27:58,799 --> 00:28:02,880
is correct uh as i said

00:28:00,799 --> 00:28:05,279
uh we want to we want to actually

00:28:02,880 --> 00:28:07,440
formally verify our proof

00:28:05,279 --> 00:28:08,559
and then uh extending the kinds of rest

00:28:07,440 --> 00:28:10,399
code that we can verify

00:28:08,559 --> 00:28:12,159
so what i showed right now is how we can

00:28:10,399 --> 00:28:14,000
verify russ code that uses mutable

00:28:12,159 --> 00:28:15,760
borrows

00:28:14,000 --> 00:28:17,760
of course we'd like to do things we'd

00:28:15,760 --> 00:28:18,559
like to verify code that uses traits for

00:28:17,760 --> 00:28:20,960
example

00:28:18,559 --> 00:28:23,120
uh rustcode that uses closures and

00:28:20,960 --> 00:28:27,200
roscode that uses types like cell

00:28:23,120 --> 00:28:30,399
which sort of break our approach uh

00:28:27,200 --> 00:28:34,799
and so that that's the ongoing work and

00:28:30,399 --> 00:28:38,080
future work for us uh right now um

00:28:34,799 --> 00:28:38,960
so yeah i sorry sorry if i went too fast

00:28:38,080 --> 00:28:40,399
everyone uh

00:28:38,960 --> 00:28:45,840
but yeah i'd be happy to take any

00:28:40,399 --> 00:28:45,840
questions you have now

00:28:47,720 --> 00:28:53,470
[Music]

00:28:54,320 --> 00:28:57,760
all right so far we haven't had

00:28:56,559 --> 00:29:00,799
questions uh

00:28:57,760 --> 00:29:01,120
on the chat at least on my end so we

00:29:00,799 --> 00:29:05,919
have

00:29:01,120 --> 00:29:07,679
questions talking about future values

00:29:05,919 --> 00:29:09,760
did you in your research already

00:29:07,679 --> 00:29:10,480
evaluate asynchronous programming in

00:29:09,760 --> 00:29:14,000
rust

00:29:10,480 --> 00:29:18,240
studies tokyo for instance

00:29:14,000 --> 00:29:22,240
uh yeah the conclusion is uh

00:29:18,240 --> 00:29:27,039
it's out of scope for now uh it's uh

00:29:22,240 --> 00:29:30,240
asynchronous programming or the like

00:29:27,039 --> 00:29:31,760
fine grain concurrency like that is

00:29:30,240 --> 00:29:34,320
probably going to be

00:29:31,760 --> 00:29:35,279
it's going to be challenging i think uh

00:29:34,320 --> 00:29:38,960
but

00:29:35,279 --> 00:29:41,440
um yeah i that

00:29:38,960 --> 00:29:43,360
i we evaluated to the extent that we

00:29:41,440 --> 00:29:45,760
decided not to evaluate it further

00:29:43,360 --> 00:29:46,480
just because it's it's it's probably

00:29:45,760 --> 00:29:48,640
going to be

00:29:46,480 --> 00:29:50,880
a lot of work on its of it in its own

00:29:48,640 --> 00:29:50,880
right

00:29:52,880 --> 00:30:00,000
we have another question coming into us

00:29:55,919 --> 00:30:03,039
could you compare this to tla plus

00:30:00,000 --> 00:30:03,919
uh right so as i was saying at the

00:30:03,039 --> 00:30:07,039
beginning the

00:30:03,919 --> 00:30:08,880
uh in a tool like tla plus

00:30:07,039 --> 00:30:10,960
you don't actually verify a program

00:30:08,880 --> 00:30:12,320
directly right you're gonna

00:30:10,960 --> 00:30:14,080
you're gonna represent you're gonna

00:30:12,320 --> 00:30:15,279
model your program or you're gonna model

00:30:14,080 --> 00:30:16,880
your system rather

00:30:15,279 --> 00:30:18,880
so you're gonna write a sort of

00:30:16,880 --> 00:30:20,399
description of what your system

00:30:18,880 --> 00:30:22,159
should be doing abstractly and then

00:30:20,399 --> 00:30:22,799
you're gonna verify that so the

00:30:22,159 --> 00:30:24,480
challenge

00:30:22,799 --> 00:30:25,840
in the context of program verification

00:30:24,480 --> 00:30:27,120
is that now you need to know that your

00:30:25,840 --> 00:30:28,640
model is correct right

00:30:27,120 --> 00:30:31,120
you have source code and then you have a

00:30:28,640 --> 00:30:31,840
model and you you write both of these by

00:30:31,120 --> 00:30:33,279
hand

00:30:31,840 --> 00:30:36,720
and so you still have to manually show

00:30:33,279 --> 00:30:39,520
that they correspond right

00:30:36,720 --> 00:30:40,559
whereas in a deductive verifier you work

00:30:39,520 --> 00:30:42,000
from source code

00:30:40,559 --> 00:30:43,679
and then you translate it into a giant

00:30:42,000 --> 00:30:46,799
logical formula and then you just

00:30:43,679 --> 00:30:47,679
show that that formula is correct so the

00:30:46,799 --> 00:30:49,600
guarantees

00:30:47,679 --> 00:30:51,120
are going to be a lot stronger the

00:30:49,600 --> 00:30:52,960
advantage of tla though

00:30:51,120 --> 00:30:55,279
or a toilet tla is that it's typically

00:30:52,960 --> 00:30:58,559
simpler to use

00:30:55,279 --> 00:31:00,559
and it's going to be usually more

00:30:58,559 --> 00:31:01,840
automated

00:31:00,559 --> 00:31:04,559
so i have to say again deductive

00:31:01,840 --> 00:31:07,519
verifiers nowadays is really

00:31:04,559 --> 00:31:10,320
most the time you're just hitting solve

00:31:07,519 --> 00:31:10,320
and then moving on

00:31:11,279 --> 00:31:15,600
all right the next question is going to

00:31:13,919 --> 00:31:18,640
be from me

00:31:15,600 --> 00:31:22,720
i as you can see some of the examples

00:31:18,640 --> 00:31:27,200
seems to me a bit like uh clunky because

00:31:22,720 --> 00:31:30,399
you have to embed a lot of logic inside

00:31:27,200 --> 00:31:33,279
the attributes so do you have

00:31:30,399 --> 00:31:34,159
any plan of deferring that to some

00:31:33,279 --> 00:31:36,640
another place

00:31:34,159 --> 00:31:37,919
so that the main code will not be

00:31:36,640 --> 00:31:40,399
difficult to read

00:31:37,919 --> 00:31:42,480
because of those expressions you write

00:31:40,399 --> 00:31:48,159
in the attribute

00:31:42,480 --> 00:31:50,880
uh no i don't have uh

00:31:48,159 --> 00:31:51,279
there is no plan to do that and in fact

00:31:50,880 --> 00:31:53,760
uh

00:31:51,279 --> 00:31:55,279
though uh though logical annotations can

00:31:53,760 --> 00:31:57,440
often dominate the code

00:31:55,279 --> 00:31:59,360
in informally verified code i think it

00:31:57,440 --> 00:32:01,120
really does make the most sense to

00:31:59,360 --> 00:32:03,840
embed them alongside with the code

00:32:01,120 --> 00:32:04,640
because they often correspond to very

00:32:03,840 --> 00:32:06,640
specific

00:32:04,640 --> 00:32:08,320
program points right like you you don't

00:32:06,640 --> 00:32:09,519
want your assertion to be anywhere

00:32:08,320 --> 00:32:12,640
in your program you want it to be

00:32:09,519 --> 00:32:14,080
exactly on line 73

00:32:12,640 --> 00:32:15,760
and same thing with like loop invariants

00:32:14,080 --> 00:32:17,360
if you have multiple loops you you want

00:32:15,760 --> 00:32:18,000
to say that this invariant is for the

00:32:17,360 --> 00:32:22,000
first loop

00:32:18,000 --> 00:32:24,720
not the second one um so it is

00:32:22,000 --> 00:32:25,360
it's true it is aesthetically less

00:32:24,720 --> 00:32:27,039
pleasing

00:32:25,360 --> 00:32:29,519
uh to look at formally verified code

00:32:27,039 --> 00:32:33,760
when it's 90 assertions and 10

00:32:29,519 --> 00:32:35,440
code uh but i i think that's

00:32:33,760 --> 00:32:38,320
that's sort of how it has to be for it

00:32:35,440 --> 00:32:38,320
to make the most sense

00:32:40,960 --> 00:32:45,360
maybe an editor maybe an editor to learn

00:32:42,799 --> 00:32:49,440
to hide them sorry

00:32:45,360 --> 00:32:52,720
yes yes all right so i think

00:32:49,440 --> 00:32:56,320
uh thank you we have a lot of people

00:32:52,720 --> 00:33:11,840
uh thanking you for the great talk and

00:32:56,320 --> 00:33:11,840
so we think we'll go on to to the next

00:33:13,840 --> 00:33:21,039
then our next talk will be from

00:33:17,279 --> 00:33:21,039
bernhard's and

00:33:21,360 --> 00:33:28,720
trying to find yeah so he will be helped

00:33:25,039 --> 00:33:28,720
yes he's already taken over

00:33:28,880 --> 00:33:31,919
all right can you see me

00:33:34,480 --> 00:33:37,600
hi uh thanks for having me uh thanks for

00:33:36,640 --> 00:33:39,440
being here

00:33:37,600 --> 00:33:41,360
and uh thanks javier this was very

00:33:39,440 --> 00:33:43,039
interesting talk and uh

00:33:41,360 --> 00:33:44,480
he actually derailing me a little bit

00:33:43,039 --> 00:33:46,240
because i have a little bit of high

00:33:44,480 --> 00:33:48,320
calculus so now i'm off of course

00:33:46,240 --> 00:33:49,760
thinking half of which is that of what i

00:33:48,320 --> 00:33:51,919
shouldn't be thinking about

00:33:49,760 --> 00:33:53,360
but anyway so i'll talk today is a

00:33:51,919 --> 00:33:54,880
program distributed system of the act

00:33:53,360 --> 00:33:57,440
marine

00:33:54,880 --> 00:33:59,279
uh let me just give you a little bit

00:33:57,440 --> 00:34:00,960
background fluence labs builds open

00:33:59,279 --> 00:34:02,000
source peer-to-peer network components

00:34:00,960 --> 00:34:04,799
development tools

00:34:02,000 --> 00:34:08,159
uh support systems and uh all the

00:34:04,799 --> 00:34:10,079
development is deeply rooted in rust

00:34:08,159 --> 00:34:12,240
for pretty much all the reasons uh in

00:34:10,079 --> 00:34:12,800
terms of safety javier just pointed out

00:34:12,240 --> 00:34:15,359
and

00:34:12,800 --> 00:34:17,919
we all know that's why we love it and

00:34:15,359 --> 00:34:20,000
our goal is really to empower developers

00:34:17,919 --> 00:34:22,720
to efficiently and reliably build

00:34:20,000 --> 00:34:23,919
peer-to-peer applications so if you

00:34:22,720 --> 00:34:25,760
haven't

00:34:23,919 --> 00:34:27,760
done much in the distributed space or

00:34:25,760 --> 00:34:29,119
peer-to-peer applications

00:34:27,760 --> 00:34:31,679
you might just say well all i need is

00:34:29,119 --> 00:34:33,520
slip p2p and everything's done and gone

00:34:31,679 --> 00:34:35,280
well that's not really the case it gives

00:34:33,520 --> 00:34:37,839
you the basis to build on and

00:34:35,280 --> 00:34:39,760
if you ever had to build on lib p2p in

00:34:37,839 --> 00:34:40,879
terms of application services back in

00:34:39,760 --> 00:34:43,200
systems

00:34:40,879 --> 00:34:44,560
you probably have not had a very good

00:34:43,200 --> 00:34:46,839
experience at all

00:34:44,560 --> 00:34:49,280
and the failure rate seems to very very

00:34:46,839 --> 00:34:52,720
high and one of the things we offer

00:34:49,280 --> 00:34:54,639
is uh is is a concept and the tooling

00:34:52,720 --> 00:34:56,560
it's called ak marine it's all open

00:34:54,639 --> 00:34:57,200
source and it's a runtime and program

00:34:56,560 --> 00:34:59,040
environment

00:34:57,200 --> 00:35:01,200
to enable peer-to-peer choreography and

00:34:59,040 --> 00:35:03,359
composition for distributed applications

00:35:01,200 --> 00:35:05,200
and back-ends

00:35:03,359 --> 00:35:07,680
that's a big statement and we'll unpack

00:35:05,200 --> 00:35:10,880
that over the next few slides

00:35:07,680 --> 00:35:12,800
so why do you need distributed

00:35:10,880 --> 00:35:14,320
programming tools

00:35:12,800 --> 00:35:16,000
well there's a variety of reasons for it

00:35:14,320 --> 00:35:17,440
but at the service level

00:35:16,000 --> 00:35:19,359
one of the key aspects is that

00:35:17,440 --> 00:35:20,720
peer-to-peer offers something that

00:35:19,359 --> 00:35:22,640
your traditional client server

00:35:20,720 --> 00:35:25,119
architecture does not offer

00:35:22,640 --> 00:35:26,079
and that's actually the request response

00:35:25,119 --> 00:35:28,480
pattern

00:35:26,079 --> 00:35:29,200
in your typical client server

00:35:28,480 --> 00:35:31,520
environment

00:35:29,200 --> 00:35:33,040
you basically have requests you process

00:35:31,520 --> 00:35:34,320
response you have a request to process

00:35:33,040 --> 00:35:36,560
response so for example

00:35:34,320 --> 00:35:37,440
if you uh want to do a credit card

00:35:36,560 --> 00:35:40,800
authorization

00:35:37,440 --> 00:35:44,320
and i don't know send a sms to

00:35:40,800 --> 00:35:45,200
uh to the user you basically call your

00:35:44,320 --> 00:35:47,520
stripe ap

00:35:45,200 --> 00:35:48,320
api you get it back and then you send it

00:35:47,520 --> 00:35:49,920
out so

00:35:48,320 --> 00:35:51,680
in in the extreme case it gives you sort

00:35:49,920 --> 00:35:52,480
of an end to end request response call

00:35:51,680 --> 00:35:54,720
pattern

00:35:52,480 --> 00:35:56,160
whereas in peer-to-peer you can actually

00:35:54,720 --> 00:35:57,920
push this way ahead

00:35:56,160 --> 00:35:59,440
you can actually go and start

00:35:57,920 --> 00:36:02,800
piggybacking or or

00:35:59,440 --> 00:36:04,880
forward chaining your responses

00:36:02,800 --> 00:36:06,720
and that's an extremely powerful aspect

00:36:04,880 --> 00:36:08,400
of peer-to-peer programming

00:36:06,720 --> 00:36:10,320
and one of the reasons that's so

00:36:08,400 --> 00:36:12,320
powerful is that it basically allows you

00:36:10,320 --> 00:36:14,160
to run very very thin clients

00:36:12,320 --> 00:36:16,320
so on a sudden you can do very very

00:36:14,160 --> 00:36:18,079
complex and computational intensive

00:36:16,320 --> 00:36:21,119
computation computational intensive

00:36:18,079 --> 00:36:22,160
tasks on thin clients like iot devices

00:36:21,119 --> 00:36:24,160
and

00:36:22,160 --> 00:36:25,680
mobile well not that they're weak these

00:36:24,160 --> 00:36:27,920
days but a particular iot

00:36:25,680 --> 00:36:30,480
devices because you're really offloading

00:36:27,920 --> 00:36:34,640
the entire

00:36:30,480 --> 00:36:36,880
application flow to the peers

00:36:34,640 --> 00:36:38,480
and that's where ackmarine comes in and

00:36:36,880 --> 00:36:41,839
this is very really helps you

00:36:38,480 --> 00:36:43,920
as a developer to uh to to take

00:36:41,839 --> 00:36:46,000
advantage of peer-to-peer systems

00:36:43,920 --> 00:36:47,040
so aquamarine is comprised it's a bunch

00:36:46,000 --> 00:36:49,280
of stuff

00:36:47,040 --> 00:36:51,200
and one is the aquascripting language

00:36:49,280 --> 00:36:51,839
which basically is a high-level language

00:36:51,200 --> 00:36:55,200
to write

00:36:51,839 --> 00:36:57,920
uh peer-to-peer applications it has a

00:36:55,200 --> 00:36:59,359
low-level acme air in representation

00:36:57,920 --> 00:37:02,079
which are low-level language and then

00:36:59,359 --> 00:37:04,800
it's the aqua vm which is uh is

00:37:02,079 --> 00:37:06,880
rust but also has other uh compiled

00:37:04,800 --> 00:37:08,800
targets because it runs in browsers iot

00:37:06,880 --> 00:37:11,839
devices various environments

00:37:08,800 --> 00:37:14,720
which basically runs a low-level

00:37:11,839 --> 00:37:16,560
air language on each peer and then we

00:37:14,720 --> 00:37:20,720
have what's called marine which is

00:37:16,560 --> 00:37:22,720
in rust which is vm basically running

00:37:20,720 --> 00:37:23,760
the assembly modules which comprise

00:37:22,720 --> 00:37:26,560
services with

00:37:23,760 --> 00:37:27,359
uh the interfaces necessary to interact

00:37:26,560 --> 00:37:30,320
with uh

00:37:27,359 --> 00:37:32,640
uh aquamarine and that enables you to do

00:37:30,320 --> 00:37:35,040
some really really cool stuff

00:37:32,640 --> 00:37:36,240
so first of all it enables you to uh to

00:37:35,040 --> 00:37:39,839
separate

00:37:36,240 --> 00:37:41,599
your workflow from the business logic of

00:37:39,839 --> 00:37:45,200
a service

00:37:41,599 --> 00:37:46,800
so basically your glue if you will i

00:37:45,200 --> 00:37:49,280
don't like calling it glue but people

00:37:46,800 --> 00:37:50,160
seem to not seem to seem to gravitate

00:37:49,280 --> 00:37:52,800
towards it

00:37:50,160 --> 00:37:54,560
is basically your workflow that really

00:37:52,800 --> 00:37:58,000
gives you peer-to-peer applications

00:37:54,560 --> 00:38:01,359
and aquamarine is uh is

00:37:58,000 --> 00:38:03,119
built from bottom up to accommodate zero

00:38:01,359 --> 00:38:04,000
trust applications which is super

00:38:03,119 --> 00:38:07,040
important in permission

00:38:04,000 --> 00:38:10,079
as period of peer networks right and

00:38:07,040 --> 00:38:13,119
that really in all gets you

00:38:10,079 --> 00:38:14,880
to a to be able to exploit peer-to-peer

00:38:13,119 --> 00:38:16,640
capabilities which you otherwise

00:38:14,880 --> 00:38:19,440
couldn't do

00:38:16,640 --> 00:38:21,839
all right come on why are you not

00:38:19,440 --> 00:38:21,839
changing

00:38:22,160 --> 00:38:26,079
okay so in order to do this you uh you

00:38:24,720 --> 00:38:28,160
nee you need a foundation

00:38:26,079 --> 00:38:29,359
and this is where uh now it's timing a

00:38:28,160 --> 00:38:32,960
little bit heavier

00:38:29,359 --> 00:38:35,359
aquarine is based on pi calculus and

00:38:32,960 --> 00:38:36,880
and it's a process calculus that's

00:38:35,359 --> 00:38:38,960
geared towards uh

00:38:36,880 --> 00:38:40,320
modeling concurrent systems with dynamic

00:38:38,960 --> 00:38:43,839
topologies

00:38:40,320 --> 00:38:46,800
and i'm not going to go into detail

00:38:43,839 --> 00:38:49,040
but uh one of the big challenges in

00:38:46,800 --> 00:38:53,119
modeling and verifying systems in

00:38:49,040 --> 00:38:54,960
dynamic topologies is that uh that

00:38:53,119 --> 00:38:57,040
in a peer-to-peer network it is the

00:38:54,960 --> 00:38:59,359
expectation that a peer drops

00:38:57,040 --> 00:39:00,800
it's not the exception and you need to

00:38:59,359 --> 00:39:02,560
be able to handle that

00:39:00,800 --> 00:39:04,079
and you need to be able to handle that

00:39:02,560 --> 00:39:05,680
formally and you need to be able to

00:39:04,079 --> 00:39:08,560
handle that your programs function

00:39:05,680 --> 00:39:10,400
when those kind of events happen and

00:39:08,560 --> 00:39:12,640
this is where uh sort of the the pi

00:39:10,400 --> 00:39:15,599
calculus foundation comes in

00:39:12,640 --> 00:39:16,960
and uh the modeling of the systems and

00:39:15,599 --> 00:39:17,680
anybody who's looked at any of the

00:39:16,960 --> 00:39:20,240
calculate

00:39:17,680 --> 00:39:21,359
uh there's a it's just a handful plus of

00:39:20,240 --> 00:39:25,280
operators which are

00:39:21,359 --> 00:39:26,320
extremely uh powerful to uh to get a lot

00:39:25,280 --> 00:39:28,960
done

00:39:26,320 --> 00:39:29,839
so what does it look like in practice in

00:39:28,960 --> 00:39:33,680
practice

00:39:29,839 --> 00:39:36,079
you basically have uh an instruction set

00:39:33,680 --> 00:39:37,280
so the language we're using is comprised

00:39:36,079 --> 00:39:38,400
of a few instructions which are

00:39:37,280 --> 00:39:41,680
basically

00:39:38,400 --> 00:39:43,520
translations from the pi calculus

00:39:41,680 --> 00:39:45,440
and there's more than i listed but it's

00:39:43,520 --> 00:39:47,359
basically you know you execute something

00:39:45,440 --> 00:39:49,440
either in sequential apparel you iterate

00:39:47,359 --> 00:39:52,400
over results and you have branching

00:39:49,440 --> 00:39:53,680
and then you have an identity and then

00:39:52,400 --> 00:39:54,560
if you look at it from an instruction

00:39:53,680 --> 00:39:57,920
statement

00:39:54,560 --> 00:40:01,520
in uh this particular

00:39:57,920 --> 00:40:03,839
light pink line basically it says we

00:40:01,520 --> 00:40:04,480
have a service dht that has a function

00:40:03,839 --> 00:40:06,880
put

00:40:04,480 --> 00:40:09,359
and we want to call that function of

00:40:06,880 --> 00:40:12,800
that service on that particular peer

00:40:09,359 --> 00:40:15,040
one two d3 node and give it uh

00:40:12,800 --> 00:40:16,000
the argument list which is key and value

00:40:15,040 --> 00:40:18,720
so we get up

00:40:16,000 --> 00:40:20,000
we end up with a named result a named

00:40:18,720 --> 00:40:23,280
output our result

00:40:20,000 --> 00:40:24,960
and as you can see this this forms the

00:40:23,280 --> 00:40:26,800
basic of the choreography

00:40:24,960 --> 00:40:29,200
throughout the peer-to-peer system in a

00:40:26,800 --> 00:40:31,440
peer-to-peer application

00:40:29,200 --> 00:40:32,319
so what we have at the core and this is

00:40:31,440 --> 00:40:34,160
heavily

00:40:32,319 --> 00:40:36,160
from an implementation perspective and

00:40:34,160 --> 00:40:38,640
uh modeling perspective raw space is

00:40:36,160 --> 00:40:40,960
what we call a particle particles are

00:40:38,640 --> 00:40:42,240
basically uh conflict-free replication

00:40:40,960 --> 00:40:45,200
data structures

00:40:42,240 --> 00:40:47,200
that combine data and the execution

00:40:45,200 --> 00:40:50,880
sequence which is basically the

00:40:47,200 --> 00:40:54,400
programmatically specified

00:40:50,880 --> 00:40:57,200
workflow connecting services

00:40:54,400 --> 00:41:00,319
throughout a peer-to-peer network into

00:40:57,200 --> 00:41:02,800
quote unquote an application

00:41:00,319 --> 00:41:04,800
and to make this a little bit more

00:41:02,800 --> 00:41:06,400
graphically appealing

00:41:04,800 --> 00:41:08,560
think of uh so on the right we have the

00:41:06,400 --> 00:41:09,359
same uh basic layout of the low-level

00:41:08,560 --> 00:41:11,440
language

00:41:09,359 --> 00:41:14,319
and on the left we have an interaction

00:41:11,440 --> 00:41:16,560
so the big circle is a academia network

00:41:14,319 --> 00:41:17,440
the square ones are just various nodes

00:41:16,560 --> 00:41:19,599
peers on

00:41:17,440 --> 00:41:21,920
in that network and then the little dots

00:41:19,599 --> 00:41:22,319
are services one or more for each node

00:41:21,920 --> 00:41:24,640
on

00:41:22,319 --> 00:41:26,079
throughout the network now think of it

00:41:24,640 --> 00:41:27,040
as i don't know for example a chat

00:41:26,079 --> 00:41:29,760
application

00:41:27,040 --> 00:41:30,720
so we get old firefox there and he wants

00:41:29,760 --> 00:41:34,720
to chat with

00:41:30,720 --> 00:41:38,079
chrome and now they want to send

00:41:34,720 --> 00:41:38,560
a message and a message is more than

00:41:38,079 --> 00:41:40,480
just

00:41:38,560 --> 00:41:42,319
letters these days it could be you want

00:41:40,480 --> 00:41:44,960
to add a file you want to add an

00:41:42,319 --> 00:41:45,599
image you want to add an emoji or more

00:41:44,960 --> 00:41:47,839
than one

00:41:45,599 --> 00:41:49,040
and you could do this through various

00:41:47,839 --> 00:41:50,720
api services

00:41:49,040 --> 00:41:52,640
on the client side or you could do it on

00:41:50,720 --> 00:41:53,920
a peer-to-peer environment

00:41:52,640 --> 00:41:55,920
and if you do it on a peer-to-peer

00:41:53,920 --> 00:41:56,160
environment you basically start marking

00:41:55,920 --> 00:41:59,839
up

00:41:56,160 --> 00:42:01,760
if you will your your message with those

00:41:59,839 --> 00:42:03,920
very through various services that then

00:42:01,760 --> 00:42:04,560
eventually ends along the way ends up at

00:42:03,920 --> 00:42:08,000
that

00:42:04,560 --> 00:42:09,520
chrome consumer of that message and

00:42:08,000 --> 00:42:10,960
i mean that was just a very small

00:42:09,520 --> 00:42:12,960
example but obviously if you look at it

00:42:10,960 --> 00:42:17,200
from a messaging perspective in general

00:42:12,960 --> 00:42:20,640
this is an extremely powerful paradigm

00:42:17,200 --> 00:42:22,800
so i showed you the low level language

00:42:20,640 --> 00:42:25,040
because the low level language is uh

00:42:22,800 --> 00:42:26,480
first of all it's been long around than

00:42:25,040 --> 00:42:29,119
aqua script and to me

00:42:26,480 --> 00:42:30,319
it it really shows you from a sort of

00:42:29,119 --> 00:42:33,359
almost like

00:42:30,319 --> 00:42:36,240
pseudocode what happens

00:42:33,359 --> 00:42:37,280
but anybody who's ever dealt with list

00:42:36,240 --> 00:42:40,079
scheme whatever

00:42:37,280 --> 00:42:40,800
uh uh and have to wrangle parentheses

00:42:40,079 --> 00:42:42,319
and nesting

00:42:40,800 --> 00:42:43,920
knows that is uh it's a highly

00:42:42,319 --> 00:42:44,720
ineffective way of writing large

00:42:43,920 --> 00:42:47,200
programs

00:42:44,720 --> 00:42:48,480
it's not just ineffective it's extremely

00:42:47,200 --> 00:42:50,880
painful especially if

00:42:48,480 --> 00:42:52,319
there are change requirements so what

00:42:50,880 --> 00:42:54,960
we've just released

00:42:52,319 --> 00:42:55,920
is aqua it's in alpha right now and

00:42:54,960 --> 00:42:58,319
that's

00:42:55,920 --> 00:42:59,920
the high level language and if you look

00:42:58,319 --> 00:43:02,000
on the left

00:42:59,920 --> 00:43:03,440
basically uh when you specify this

00:43:02,000 --> 00:43:05,359
language you

00:43:03,440 --> 00:43:06,720
basically refer to a greeting service

00:43:05,359 --> 00:43:07,760
and we'll get to that service in a

00:43:06,720 --> 00:43:10,839
minute

00:43:07,760 --> 00:43:12,000
and then the execution the call the

00:43:10,839 --> 00:43:13,839
instructions

00:43:12,000 --> 00:43:15,520
so if you look there uh the service

00:43:13,839 --> 00:43:17,920
greeting basically

00:43:15,520 --> 00:43:19,520
that that references a service

00:43:17,920 --> 00:43:22,319
generically

00:43:19,520 --> 00:43:23,680
uh by its in by signatures so we have a

00:43:22,319 --> 00:43:25,200
greeting service out there somewhere

00:43:23,680 --> 00:43:27,040
which is basically takes a string and a

00:43:25,200 --> 00:43:29,359
boolean and returns a string

00:43:27,040 --> 00:43:30,640
so this is not the service this is the

00:43:29,359 --> 00:43:32,319
representation so if you

00:43:30,640 --> 00:43:34,560
are coming from a blockchain site think

00:43:32,319 --> 00:43:37,119
of it as as your abi

00:43:34,560 --> 00:43:37,839
for a smart contract this is the ebi

00:43:37,119 --> 00:43:40,240
equivalent

00:43:37,839 --> 00:43:42,319
not the smart contract we're referencing

00:43:40,240 --> 00:43:45,040
and then you have that function

00:43:42,319 --> 00:43:46,960
that actually uh basically takes in

00:43:45,040 --> 00:43:50,240
addition to the call parameters

00:43:46,960 --> 00:43:51,920
it takes your node identifier and your

00:43:50,240 --> 00:43:54,160
greeting service id

00:43:51,920 --> 00:43:56,319
and so we'll be basically saying on the

00:43:54,160 --> 00:43:58,400
node specified in the call

00:43:56,319 --> 00:43:59,839
for the greeting service with that

00:43:58,400 --> 00:44:01,839
particular id

00:43:59,839 --> 00:44:03,760
we want to have this computation through

00:44:01,839 --> 00:44:05,440
the greeting service itself where the

00:44:03,760 --> 00:44:08,079
function is greeting

00:44:05,440 --> 00:44:11,280
uh taking the name and greeter uh

00:44:08,079 --> 00:44:13,680
parameters and then returns the result

00:44:11,280 --> 00:44:15,520
and that's really compact it's very easy

00:44:13,680 --> 00:44:16,880
and as i said we want to help developers

00:44:15,520 --> 00:44:17,839
we want to empower developers with

00:44:16,880 --> 00:44:19,839
aquamarine

00:44:17,839 --> 00:44:21,520
to successfully build peer-to-peer

00:44:19,839 --> 00:44:22,319
application and clearly if you look at

00:44:21,520 --> 00:44:24,640
the left

00:44:22,319 --> 00:44:26,400
the right kind of is uh is not where you

00:44:24,640 --> 00:44:30,800
want to be

00:44:26,400 --> 00:44:34,240
an additional compiled target in

00:44:30,800 --> 00:44:35,920
we have is is a text script

00:44:34,240 --> 00:44:38,079
so basically you can instruct the

00:44:35,920 --> 00:44:39,280
compiler to just say you know what

00:44:38,079 --> 00:44:41,359
i don't want just a low level

00:44:39,280 --> 00:44:44,480
representation i want this wrapped in

00:44:41,359 --> 00:44:46,800
in a typescript uh uh stub

00:44:44,480 --> 00:44:48,640
and uh then you just gotta integrate it

00:44:46,800 --> 00:44:51,599
in your front end application it's uh

00:44:48,640 --> 00:44:53,119
super neat and pretty powerful and saves

00:44:51,599 --> 00:44:55,200
you from a development perspective a lot

00:44:53,119 --> 00:44:58,400
of time

00:44:55,200 --> 00:45:00,160
so given the length of the talk i

00:44:58,400 --> 00:45:01,440
i decided we're i'm not going to do a

00:45:00,160 --> 00:45:03,520
live demo but

00:45:01,440 --> 00:45:04,640
unless we have a lot of time left but

00:45:03,520 --> 00:45:06,720
basically so

00:45:04,640 --> 00:45:09,040
what are those services on a peer peer

00:45:06,720 --> 00:45:10,160
so ours in services right now

00:45:09,040 --> 00:45:13,280
they're written in russ and then

00:45:10,160 --> 00:45:15,599
compiled to web assembly

00:45:13,280 --> 00:45:17,040
and uh if you look at it in the two

00:45:15,599 --> 00:45:19,920
services we're using for

00:45:17,040 --> 00:45:21,599
the demonstration here we have a echo

00:45:19,920 --> 00:45:24,079
service which is basically a practice

00:45:21,599 --> 00:45:25,839
proxy service for whatever you want it

00:45:24,079 --> 00:45:26,640
to be including it could be a database

00:45:25,839 --> 00:45:28,880
service

00:45:26,640 --> 00:45:30,720
and in this particular call where uh

00:45:28,880 --> 00:45:33,599
instance we

00:45:30,720 --> 00:45:34,800
we give the echo service we give it an

00:45:33,599 --> 00:45:37,280
array of strings and we turn

00:45:34,800 --> 00:45:38,880
on a vector of those structs which

00:45:37,280 --> 00:45:41,599
include the string

00:45:38,880 --> 00:45:42,880
and uh that's compiled to webassembly

00:45:41,599 --> 00:45:44,960
and then we have a greeting service

00:45:42,880 --> 00:45:45,359
where we want to uh which was the one

00:45:44,960 --> 00:45:49,280
which

00:45:45,359 --> 00:45:51,520
showed and it basically takes your uh

00:45:49,280 --> 00:45:52,560
your name so it's basically a hello

00:45:51,520 --> 00:45:54,240
world plus

00:45:52,560 --> 00:45:56,880
and it takes you a greeter whether it's

00:45:54,240 --> 00:45:58,960
agreed or not so it's either high or bi

00:45:56,880 --> 00:46:00,800
and now we want to compose those two

00:45:58,960 --> 00:46:02,800
services in the sense that we want the

00:46:00,800 --> 00:46:04,319
greeting service to take the output of

00:46:02,800 --> 00:46:07,440
the ecoservice

00:46:04,319 --> 00:46:10,960
as part of the particle

00:46:07,440 --> 00:46:13,200
travel through the peer-to-peer network

00:46:10,960 --> 00:46:15,680
so there are different ways of going

00:46:13,200 --> 00:46:18,960
about this and uh

00:46:15,680 --> 00:46:18,960
here's one way of doing it

00:46:19,680 --> 00:46:23,599
the same we got the same two services

00:46:21,760 --> 00:46:25,119
and basically what we're specifying here

00:46:23,599 --> 00:46:27,520
is we basically say okay our echo

00:46:25,119 --> 00:46:31,119
service is on node one

00:46:27,520 --> 00:46:32,480
and uh we're piping in uh uh rust berlin

00:46:31,119 --> 00:46:35,119
and deutschland

00:46:32,480 --> 00:46:36,079
and we basically get then the echo

00:46:35,119 --> 00:46:39,040
result back

00:46:36,079 --> 00:46:40,319
echo rust echo blah blah and that's

00:46:39,040 --> 00:46:43,760
coming from

00:46:40,319 --> 00:46:46,960
a pier called node one in addition

00:46:43,760 --> 00:46:49,520
we have a grid two degree of services

00:46:46,960 --> 00:46:50,880
uh one on node two and one on node three

00:46:49,520 --> 00:46:51,440
the greater services are the same

00:46:50,880 --> 00:46:54,240
they're all

00:46:51,440 --> 00:46:56,319
same web assembly modules derived from

00:46:54,240 --> 00:46:58,960
the same webassembly modules

00:46:56,319 --> 00:47:00,880
and since we know we have three inputs

00:46:58,960 --> 00:47:03,280
we just basically take two

00:47:00,880 --> 00:47:04,800
uh the first one and the last one or

00:47:03,280 --> 00:47:07,359
zero and two

00:47:04,800 --> 00:47:09,280
and uh now we get back the uh high rust

00:47:07,359 --> 00:47:11,040
hydrogen

00:47:09,280 --> 00:47:12,480
and that's one way of doing it's kind of

00:47:11,040 --> 00:47:15,280
lame way of doing it because

00:47:12,480 --> 00:47:16,960
uh you need to know how many uh the

00:47:15,280 --> 00:47:18,880
length of the output array and that's

00:47:16,960 --> 00:47:23,200
obviously not something we want to do

00:47:18,880 --> 00:47:26,800
so what we can do is we can use fold

00:47:23,200 --> 00:47:29,359
and sequential execution for example and

00:47:26,800 --> 00:47:29,920
then we specify it slightly differently

00:47:29,359 --> 00:47:33,200
so

00:47:29,920 --> 00:47:33,920
if you have again the accessories on

00:47:33,200 --> 00:47:37,280
node 1

00:47:33,920 --> 00:47:38,079
it takes the same inputs and now we have

00:47:37,280 --> 00:47:40,640
in this particular

00:47:38,079 --> 00:47:43,359
instance i put using just one greeting

00:47:40,640 --> 00:47:47,839
service on node 2 on pier 2

00:47:43,359 --> 00:47:50,000
that now just processes the entire array

00:47:47,839 --> 00:47:52,079
in sequence so it takes one at a time so

00:47:50,000 --> 00:47:53,839
iterates over it one at a time

00:47:52,079 --> 00:47:55,440
and that's basically the specification

00:47:53,839 --> 00:47:56,880
there and then we get the expected

00:47:55,440 --> 00:48:00,000
single array output

00:47:56,880 --> 00:48:03,520
uh high rise turbulent deutschen where

00:48:00,000 --> 00:48:06,400
if you look in the right see if you look

00:48:03,520 --> 00:48:07,599
in that line here where the green

00:48:06,400 --> 00:48:09,839
results is the

00:48:07,599 --> 00:48:11,680
quote-unquote accumulator of the outputs

00:48:09,839 --> 00:48:15,520
of the services which we then get

00:48:11,680 --> 00:48:15,520
at the end as a return service

00:48:17,040 --> 00:48:21,119
we can also repurpose those services

00:48:19,599 --> 00:48:24,240
into a slightly different

00:48:21,119 --> 00:48:27,760
uh workflow different application

00:48:24,240 --> 00:48:29,599
and in this case we want to take

00:48:27,760 --> 00:48:31,680
advantage of the boolean capability of

00:48:29,599 --> 00:48:32,160
the high and buy of the service we take

00:48:31,680 --> 00:48:34,240
the same

00:48:32,160 --> 00:48:35,760
result the same service it's on another

00:48:34,240 --> 00:48:38,240
one and now we have

00:48:35,760 --> 00:48:40,800
a service greeting services on again on

00:48:38,240 --> 00:48:43,280
node 2 and 3 which we used before

00:48:40,800 --> 00:48:44,079
but now we're basically piping in

00:48:43,280 --> 00:48:49,040
different data

00:48:44,079 --> 00:48:52,400
data into the services in the hang on

00:48:49,040 --> 00:48:54,960
in the greeter parameter slot

00:48:52,400 --> 00:48:56,319
and now we're getting uh we accumulated

00:48:54,960 --> 00:48:59,440
in different results

00:48:56,319 --> 00:49:01,359
vectors and we uh return them and now

00:48:59,440 --> 00:49:03,839
we're getting the high high high

00:49:01,359 --> 00:49:05,599
bye bye bye for each one of those uh

00:49:03,839 --> 00:49:08,640
calls

00:49:05,599 --> 00:49:11,440
so if so

00:49:08,640 --> 00:49:12,800
the point of those examples was that uh

00:49:11,440 --> 00:49:15,440
um

00:49:12,800 --> 00:49:17,119
the decoupling of the services from the

00:49:15,440 --> 00:49:20,160
workflow from your application

00:49:17,119 --> 00:49:20,800
is uh is extremely powerful and uh it

00:49:20,160 --> 00:49:23,760
allows you

00:49:20,800 --> 00:49:24,400
an entirely i don't know not necessarily

00:49:23,760 --> 00:49:27,599
new but

00:49:24,400 --> 00:49:30,319
a much more flexible way of reusing uh

00:49:27,599 --> 00:49:31,200
application services you already built

00:49:30,319 --> 00:49:33,040
and

00:49:31,200 --> 00:49:35,680
it allows you to do all that with very

00:49:33,040 --> 00:49:38,240
very thin client applications

00:49:35,680 --> 00:49:39,280
now the big question is probably i'm

00:49:38,240 --> 00:49:40,960
anticipating

00:49:39,280 --> 00:49:43,280
is security particularly in

00:49:40,960 --> 00:49:45,440
permissionless

00:49:43,280 --> 00:49:46,960
environments and peer-to-peer networks

00:49:45,440 --> 00:49:50,640
so one of the things we have

00:49:46,960 --> 00:49:52,960
in uh in aquamarine is the concept of

00:49:50,640 --> 00:49:53,760
security tetraplate because that's

00:49:52,960 --> 00:49:57,440
basically

00:49:53,760 --> 00:49:58,720
uh uh gives you the ability to couple

00:49:57,440 --> 00:50:02,559
your authorization

00:49:58,720 --> 00:50:04,400
from your origin and that allows you to

00:50:02,559 --> 00:50:06,000
uh basically fundamentally what you're

00:50:04,400 --> 00:50:08,400
doing if you're introducing security

00:50:06,000 --> 00:50:09,680
it's authentication and authorization

00:50:08,400 --> 00:50:11,520
as part of your workflow you're

00:50:09,680 --> 00:50:12,000
basically building quote unquote a

00:50:11,520 --> 00:50:14,960
virtual

00:50:12,000 --> 00:50:15,680
network within your peer-to-peer network

00:50:14,960 --> 00:50:18,160
and

00:50:15,680 --> 00:50:19,440
that's uh super powerful and allows you

00:50:18,160 --> 00:50:22,640
to do a lot of

00:50:19,440 --> 00:50:23,680
privacy preserving aspects and data

00:50:22,640 --> 00:50:26,559
exchanges

00:50:23,680 --> 00:50:30,079
on a permission list otherwise

00:50:26,559 --> 00:50:33,200
permissionless peer-to-peer network

00:50:30,079 --> 00:50:36,319
so to recap

00:50:33,200 --> 00:50:38,400
services in in aquamarine

00:50:36,319 --> 00:50:40,000
are business logic units and they

00:50:38,400 --> 00:50:42,960
basically are derived from

00:50:40,000 --> 00:50:43,280
nothing web assembly modules particles

00:50:42,960 --> 00:50:45,520
call

00:50:43,280 --> 00:50:47,280
services exposed apis and provide the

00:50:45,520 --> 00:50:48,960
authentication credentials to services

00:50:47,280 --> 00:50:51,440
protected methods

00:50:48,960 --> 00:50:53,359
and aqua choreographs the services into

00:50:51,440 --> 00:50:54,319
applications independently from service

00:50:53,359 --> 00:50:57,760
business logic

00:50:54,319 --> 00:50:58,400
concerns and that gives you this is all

00:50:57,760 --> 00:51:01,680
part of

00:50:58,400 --> 00:51:05,280
the aquamarine toolset

00:51:01,680 --> 00:51:08,559
and this is where on the

00:51:05,280 --> 00:51:11,680
virtual machine and

00:51:08,559 --> 00:51:11,680
an interpreter level

00:51:13,119 --> 00:51:20,079
it happens on a per peer

00:51:16,800 --> 00:51:22,640
level which allows you the separation of

00:51:20,079 --> 00:51:24,880
those concerns

00:51:22,640 --> 00:51:26,720
i probably went way too fast but i knew

00:51:24,880 --> 00:51:28,640
i only had 20 minutes i tried to

00:51:26,720 --> 00:51:31,760
pack in as much as i could so i'm not

00:51:28,640 --> 00:51:34,839
quite sure where i'm with time

00:51:31,760 --> 00:51:37,839
and if you have any questions please

00:51:34,839 --> 00:51:37,839
shoot

00:51:38,079 --> 00:51:45,119
yes so we have thanks for the talk uh

00:51:41,440 --> 00:51:46,880
we have xavier uh who posted

00:51:45,119 --> 00:51:48,400
a couple of questions so i'm going to

00:51:46,880 --> 00:51:50,480
start with the first one

00:51:48,400 --> 00:51:52,160
have you investigated verification of

00:51:50,480 --> 00:51:56,559
programs for your language

00:51:52,160 --> 00:51:58,640
perhaps using a bounded modem checker

00:51:56,559 --> 00:52:00,559
not yet but it's it's it's it's there

00:51:58,640 --> 00:52:01,200
and uh i'll definitely gonna like come

00:52:00,559 --> 00:52:04,240
back to you

00:52:01,200 --> 00:52:06,720
this was a semi for two it is that uh

00:52:04,240 --> 00:52:07,920
i don't know if it was uh just excellent

00:52:06,720 --> 00:52:09,680
organizing evans

00:52:07,920 --> 00:52:11,200
or if it was just pure luck but i'll

00:52:09,680 --> 00:52:14,640
definitely get back to you uh

00:52:11,200 --> 00:52:17,200
javier it's very very so yeah definitely

00:52:14,640 --> 00:52:18,160
okay so the next one is i'm sorry if i

00:52:17,200 --> 00:52:21,200
missed this but

00:52:18,160 --> 00:52:24,880
does the low level language

00:52:21,200 --> 00:52:24,880
he has a type system

00:52:26,160 --> 00:52:31,440
yeah yes yes there is a there is a type

00:52:30,480 --> 00:52:33,839
system

00:52:31,440 --> 00:52:33,839
but

00:52:42,480 --> 00:52:45,520
see you're separating

00:52:45,599 --> 00:52:50,240
you're separating the service from the

00:52:48,480 --> 00:52:52,400
workflow

00:52:50,240 --> 00:52:54,480
so a lot of the concern of the types

00:52:52,400 --> 00:52:56,400
actually is at the service level right

00:52:54,480 --> 00:52:57,920
it's not so much at the choreography of

00:52:56,400 --> 00:53:00,160
the service

00:52:57,920 --> 00:53:02,079
so you're you're type checking really

00:53:00,160 --> 00:53:03,680
comes in at the service consumption

00:53:02,079 --> 00:53:06,079
level

00:53:03,680 --> 00:53:06,960
and that's where you get your errors

00:53:06,079 --> 00:53:09,119
that's where

00:53:06,960 --> 00:53:10,960
and this is why in many respects

00:53:09,119 --> 00:53:13,040
starting out with rust as opposed to

00:53:10,960 --> 00:53:16,000
other options to write your web assembly

00:53:13,040 --> 00:53:19,359
modules is actually

00:53:16,000 --> 00:53:21,040
uh super super helpful so one thing i

00:53:19,359 --> 00:53:24,559
sort of skipped over

00:53:21,040 --> 00:53:27,280
what's a service because it's not

00:53:24,559 --> 00:53:29,359
not really part of act marine itself but

00:53:27,280 --> 00:53:32,480
what's a service a service is

00:53:29,359 --> 00:53:36,079
is one or more

00:53:32,480 --> 00:53:36,720
webassembly modules quote unquote marked

00:53:36,079 --> 00:53:39,760
up

00:53:36,720 --> 00:53:43,119
by a blueprint that

00:53:39,760 --> 00:53:46,800
ties together different modules into

00:53:43,119 --> 00:53:47,680
a api into a public api and with that we

00:53:46,800 --> 00:53:50,480
associate

00:53:47,680 --> 00:53:50,880
a quote not quote-unquote but definitely

00:53:50,480 --> 00:53:53,920
a

00:53:50,880 --> 00:53:57,839
service id and this is

00:53:53,920 --> 00:53:57,839
the unit of

00:53:58,000 --> 00:54:02,480
i don't know if manipulation is the

00:53:59,359 --> 00:54:06,800
right word but but the unit of reference

00:54:02,480 --> 00:54:06,800
in your workflow script

00:54:06,880 --> 00:54:12,720
so the script it the workflow itself

00:54:10,000 --> 00:54:13,359
doesn't do the data checking that comes

00:54:12,720 --> 00:54:15,200
in or the

00:54:13,359 --> 00:54:16,400
even type checking this comes in at the

00:54:15,200 --> 00:54:18,720
service level

00:54:16,400 --> 00:54:20,559
where when the service level if your web

00:54:18,720 --> 00:54:21,599
assembly module if you will i mean it's

00:54:20,559 --> 00:54:23,920
below the service

00:54:21,599 --> 00:54:25,119
gets the bad data you get your you get

00:54:23,920 --> 00:54:27,359
your error message back

00:54:25,119 --> 00:54:28,480
and that then gets reported back from

00:54:27,359 --> 00:54:32,000
the workflow

00:54:28,480 --> 00:54:32,000
does that answer the question

00:54:33,839 --> 00:54:40,319
yeah that's perfect cool uh

00:54:37,839 --> 00:54:41,119
the last two questions as part i can see

00:54:40,319 --> 00:54:44,799
are uh

00:54:41,119 --> 00:54:47,119
regarding tetraplex how do tetraplex

00:54:44,799 --> 00:54:47,920
establish or guarantee trust with

00:54:47,119 --> 00:54:50,880
potential

00:54:47,920 --> 00:54:50,880
unknown peers

00:54:51,280 --> 00:54:56,640
okay so uh tetraploids have uh

00:54:54,880 --> 00:54:58,640
have a public key and the signature

00:54:56,640 --> 00:55:03,119
associated with them

00:54:58,640 --> 00:55:04,319
and i should come back with another 20

00:55:03,119 --> 00:55:06,720
minutes at one point

00:55:04,319 --> 00:55:07,440
but uh but basically what happens you

00:55:06,720 --> 00:55:09,440
verify

00:55:07,440 --> 00:55:11,359
the integrity of the tetrablade at every

00:55:09,440 --> 00:55:14,160
hop along the way

00:55:11,359 --> 00:55:15,440
and uh we get a it's as i said it's like

00:55:14,160 --> 00:55:18,960
another 20 minutes but

00:55:15,440 --> 00:55:22,000
um that verification ensures

00:55:18,960 --> 00:55:26,319
that not just that

00:55:22,000 --> 00:55:28,880
the origin of the tetraplet is

00:55:26,319 --> 00:55:30,960
what it should be but it also ensures

00:55:28,880 --> 00:55:35,839
that the data

00:55:30,960 --> 00:55:35,839
is what it was supposed to be

00:55:36,000 --> 00:55:43,520
so you can't just uh uh you can't really

00:55:40,319 --> 00:55:47,359
because of the signature and

00:55:43,520 --> 00:55:49,680
the reference of the tetraplet in the

00:55:47,359 --> 00:55:51,040
flow you can't really do a replay attack

00:55:49,680 --> 00:55:52,480
if that's what you're if that's where

00:55:51,040 --> 00:55:54,799
the question was coming from

00:55:52,480 --> 00:55:56,720
or a man-in-the-middle attack it's not

00:55:54,799 --> 00:55:59,920
possible

00:55:56,720 --> 00:56:03,040
however it doesn't give you

00:55:59,920 --> 00:56:04,400
the it only gives you a pseudo identity

00:56:03,040 --> 00:56:05,280
if you will and that's fine for

00:56:04,400 --> 00:56:07,359
verification

00:56:05,280 --> 00:56:08,400
if you need a full identity you probably

00:56:07,359 --> 00:56:11,359
would have to

00:56:08,400 --> 00:56:13,040
bring in a decentralized identity server

00:56:11,359 --> 00:56:16,079
for example or service

00:56:13,040 --> 00:56:20,160
that takes that public key of your

00:56:16,079 --> 00:56:23,680
peer client and associates it with

00:56:20,160 --> 00:56:26,880
a quote-unquote verifiable identity

00:56:23,680 --> 00:56:26,880
does that answer the question

00:56:27,119 --> 00:56:33,760
it's a good question i like it yes

00:56:30,240 --> 00:56:36,319
yes so from massimiliano he said yes

00:56:33,760 --> 00:56:36,960
all right there is one last question to

00:56:36,319 --> 00:56:39,040
take

00:56:36,960 --> 00:56:41,359
those the system has feature like

00:56:39,040 --> 00:56:43,760
circuit breaking in case services are

00:56:41,359 --> 00:56:46,640
overloaded or

00:56:43,760 --> 00:56:48,160
ah yeah so so this is up to you

00:56:46,640 --> 00:56:50,319
fundamentally

00:56:48,160 --> 00:56:52,799
and and this is this is so now it gets

00:56:50,319 --> 00:56:56,000
interesting in

00:56:52,799 --> 00:56:58,319
how you actually design services and

00:56:56,000 --> 00:56:59,280
deploy services and that's a little bit

00:56:58,319 --> 00:57:01,680
out of scope but

00:56:59,280 --> 00:57:02,960
since the question is comes up it's in

00:57:01,680 --> 00:57:06,880
scope i guess

00:57:02,960 --> 00:57:09,599
so granularity of service development is

00:57:06,880 --> 00:57:11,520
is is a huge is hugely important in your

00:57:09,599 --> 00:57:13,040
system's design

00:57:11,520 --> 00:57:14,559
because especially if you want to do

00:57:13,040 --> 00:57:16,640
load balancing and

00:57:14,559 --> 00:57:17,920
load testing because what you what i

00:57:16,640 --> 00:57:20,079
could have done if you go back to

00:57:17,920 --> 00:57:21,359
just a stupid little simple uh echo

00:57:20,079 --> 00:57:23,760
engraving service right we could have

00:57:21,359 --> 00:57:25,599
just written that as one service

00:57:23,760 --> 00:57:27,200
you take those three input values you

00:57:25,599 --> 00:57:29,599
take that input array and

00:57:27,200 --> 00:57:32,000
you do the formatting whatever and

00:57:29,599 --> 00:57:34,559
that's that's it

00:57:32,000 --> 00:57:35,040
but now it's a much fatter service if

00:57:34,559 --> 00:57:36,960
you will

00:57:35,040 --> 00:57:38,799
and uh this gets really really big

00:57:36,960 --> 00:57:40,960
really really quick i mean you could

00:57:38,799 --> 00:57:42,559
i've you know you could i've taken

00:57:40,960 --> 00:57:46,160
entire libraries uh

00:57:42,559 --> 00:57:50,240
like sec p for example 256 and uh

00:57:46,160 --> 00:57:52,240
and me and you know added uh

00:57:50,240 --> 00:57:53,280
exposed apis to it and made it one

00:57:52,240 --> 00:57:55,200
service

00:57:53,280 --> 00:57:56,480
and that's probably not necessarily the

00:57:55,200 --> 00:57:59,520
best way to do it

00:57:56,480 --> 00:58:01,520
and so you do service granularity

00:57:59,520 --> 00:58:05,359
definition

00:58:01,520 --> 00:58:06,160
is very important to how you structure

00:58:05,359 --> 00:58:08,799
it

00:58:06,160 --> 00:58:09,839
and then it comes to uh how you spread

00:58:08,799 --> 00:58:12,319
out services so

00:58:09,839 --> 00:58:13,040
one thing i didn't mention is services

00:58:12,319 --> 00:58:16,160
themselves

00:58:13,040 --> 00:58:18,559
can't call other services and this

00:58:16,160 --> 00:58:21,359
actually goes back to towards the pi

00:58:18,559 --> 00:58:23,680
calculus ability to model certain things

00:58:21,359 --> 00:58:25,520
because once services start nesting

00:58:23,680 --> 00:58:28,799
calls it doesn't work anymore you can't

00:58:25,520 --> 00:58:33,359
track it anymore it becomes intractable

00:58:28,799 --> 00:58:35,839
and and then you have no expectation of

00:58:33,359 --> 00:58:37,839
of of reasoning whatsoever for for your

00:58:35,839 --> 00:58:41,280
topology

00:58:37,839 --> 00:58:44,880
so it depends how many services you have

00:58:41,280 --> 00:58:46,880
now in terms of sort of an auto dns

00:58:44,880 --> 00:58:48,559
to resolve your services we've been

00:58:46,880 --> 00:58:50,319
thinking about it and

00:58:48,559 --> 00:58:51,599
it's certainly uh at least i've been

00:58:50,319 --> 00:58:52,799
thinking about it we've been thinking

00:58:51,599 --> 00:58:54,400
about it i've been thinking about it

00:58:52,799 --> 00:58:57,839
it's high on my list

00:58:54,400 --> 00:58:59,760
and uh so right now if you do it you'd

00:58:57,839 --> 00:59:01,359
have to resolve it yourself uh in the

00:58:59,760 --> 00:59:02,720
nuts of this future hopefully we have

00:59:01,359 --> 00:59:05,760
something for you as

00:59:02,720 --> 00:59:08,160
as part of the tooling that answer the

00:59:05,760 --> 00:59:08,160
question

00:59:08,880 --> 00:59:14,640
all right i think i'm still going to

00:59:12,319 --> 00:59:18,799
give you another questions who are the

00:59:14,640 --> 00:59:22,319
customers and what is the business model

00:59:18,799 --> 00:59:22,319
okay all right all right all right

00:59:23,200 --> 00:59:26,559
customers let me start with the business

00:59:26,160 --> 00:59:30,319
model

00:59:26,559 --> 00:59:34,160
so aquamarine so fluent has a

00:59:30,319 --> 00:59:35,599
we also build a stack and network and

00:59:34,160 --> 00:59:38,640
one of the things we are currently

00:59:35,599 --> 00:59:42,000
actively developing is a blockchain

00:59:38,640 --> 00:59:45,040
and the blockchain basically hosts

00:59:42,000 --> 00:59:47,440
service licenses not

00:59:45,040 --> 00:59:48,960
in terms of use licenses like you know

00:59:47,440 --> 00:59:52,160
mit apache whatever

00:59:48,960 --> 00:59:54,720
but uh licensing licenses

00:59:52,160 --> 00:59:55,680
and that's where if you are an open

00:59:54,720 --> 00:59:58,720
source developer

00:59:55,680 --> 00:59:58,720
where you can start

00:59:59,200 --> 01:00:02,400
registering your service and start

01:00:01,200 --> 01:00:03,599
monetizing the service

01:00:02,400 --> 01:00:05,599
and that was really one of the

01:00:03,599 --> 01:00:07,680
fundamental ideas of him starting fluent

01:00:05,599 --> 01:00:09,920
and progressing with fluence is that

01:00:07,680 --> 01:00:10,960
a lot of open source community

01:00:09,920 --> 01:00:14,559
contributions

01:00:10,960 --> 01:00:17,280
are being monetized by uh

01:00:14,559 --> 01:00:19,839
by some very big cloud providers and the

01:00:17,280 --> 01:00:23,040
individual contributors have

01:00:19,839 --> 01:00:24,960
no fundamentally no benefit no value

01:00:23,040 --> 01:00:27,040
capture whatsoever

01:00:24,960 --> 01:00:28,559
and uh the biz so the business model is

01:00:27,040 --> 01:00:32,480
really around

01:00:28,559 --> 01:00:36,079
facilitating service developers

01:00:32,480 --> 01:00:38,799
to monetize their work so

01:00:36,079 --> 01:00:39,920
before i switch is does that answer the

01:00:38,799 --> 01:00:41,839
so this is nothing to do with

01:00:39,920 --> 01:00:43,200
marine per se act marine is open source

01:00:41,839 --> 01:00:44,480
it's free to use whatever you want to

01:00:43,200 --> 01:00:47,359
use it for

01:00:44,480 --> 01:00:48,000
you you don't have to use anything else

01:00:47,359 --> 01:00:50,079
but

01:00:48,000 --> 01:00:51,280
if you want to use the stack and you

01:00:50,079 --> 01:00:53,359
want to use your

01:00:51,280 --> 01:00:54,480
your services and you want to monetize

01:00:53,359 --> 01:00:56,160
them that's where

01:00:54,480 --> 01:00:58,240
fluence has additional tools and

01:00:56,160 --> 01:00:59,760
capabilities coming online in the

01:00:58,240 --> 01:01:00,240
not-so-distant future that help you with

01:00:59,760 --> 01:01:01,760
that

01:01:00,240 --> 01:01:04,480
so that's the business model does that

01:01:01,760 --> 01:01:04,480
make sense to you

01:01:04,960 --> 01:01:08,839
maybe not sense but does it answer the

01:01:06,559 --> 01:01:11,839
question

01:01:08,839 --> 01:01:11,839
yes

01:01:12,160 --> 01:01:17,359
okay so uh who are the customers the

01:01:14,799 --> 01:01:20,559
customers are

01:01:17,359 --> 01:01:25,440
are are really

01:01:20,559 --> 01:01:29,119
developers who want to change

01:01:25,440 --> 01:01:32,799
not just the business model but the uh

01:01:29,119 --> 01:01:34,480
the operation model of of client server

01:01:32,799 --> 01:01:38,640
to peer-to-peer

01:01:34,480 --> 01:01:42,319
and why would you want to do it

01:01:38,640 --> 01:01:45,839
it probably doesn't fit everything but

01:01:42,319 --> 01:01:48,319
where we see a good fit is is a lot of

01:01:45,839 --> 01:01:49,920
decentralized messaging type based

01:01:48,319 --> 01:01:53,839
applications

01:01:49,920 --> 01:01:53,839
particularly were

01:01:54,960 --> 01:02:00,880
were over the last few months censorship

01:01:58,640 --> 01:02:02,720
has gone beyond governments at to the

01:02:00,880 --> 01:02:06,160
corporate level

01:02:02,720 --> 01:02:09,760
and and business continuity

01:02:06,160 --> 01:02:12,960
is a huge deal for companies

01:02:09,760 --> 01:02:14,799
and uh if you get a notice that your

01:02:12,960 --> 01:02:16,240
services are being discontinued by a big

01:02:14,799 --> 01:02:18,000
cloud provider and you got eight hours

01:02:16,240 --> 01:02:21,359
to get down all your data

01:02:18,000 --> 01:02:24,400
this to me is totally unacceptable

01:02:21,359 --> 01:02:27,920
and uh i think it's uh it's it's exactly

01:02:24,400 --> 01:02:29,599
what stalled the early adoption of cloud

01:02:27,920 --> 01:02:31,920
development because that's what a lot of

01:02:29,599 --> 01:02:34,240
business iit or enterprise i.t

01:02:31,920 --> 01:02:35,200
manager said would happen and now it's

01:02:34,240 --> 01:02:37,440
happening

01:02:35,200 --> 01:02:40,240
now it's not as uh as widespread

01:02:37,440 --> 01:02:45,119
obviously but still

01:02:40,240 --> 01:02:47,280
i think people starting to realize that

01:02:45,119 --> 01:02:48,240
cloud infrastructure it's private it's

01:02:47,280 --> 01:02:50,799
it's not public

01:02:48,240 --> 01:02:51,920
it's private and uh and your subject and

01:02:50,799 --> 01:02:55,359
you can be subject

01:02:51,920 --> 01:02:56,880
subjected to a right variety of

01:02:55,359 --> 01:02:58,240
quote-unquote it's not censorship if

01:02:56,880 --> 01:03:01,599
it's part of the business

01:02:58,240 --> 01:03:04,000
and agreement you signed but uh but

01:03:01,599 --> 01:03:05,119
service unavailability that you probably

01:03:04,000 --> 01:03:09,440
didn't expect

01:03:05,119 --> 01:03:12,559
and we feel that particularly sort of uh

01:03:09,440 --> 01:03:14,079
anything based on on messaging is uh is

01:03:12,559 --> 01:03:18,319
a huge huge uh

01:03:14,079 --> 01:03:23,440
uh customer segment for the platform

01:03:18,319 --> 01:03:23,440
and we also believe that

01:03:24,720 --> 01:03:30,160
open source developers who have not been

01:03:27,839 --> 01:03:31,920
able to

01:03:30,160 --> 01:03:33,599
capitalize on the success of their

01:03:31,920 --> 01:03:35,280
projects should

01:03:33,599 --> 01:03:37,039
at least look at the platform because

01:03:35,280 --> 01:03:38,880
one of the things you do is you once you

01:03:37,039 --> 01:03:41,119
got your services deployed you it

01:03:38,880 --> 01:03:41,920
you deploy and you're done you don't

01:03:41,119 --> 01:03:45,680
have to

01:03:41,920 --> 01:03:49,359
have a lot of devops uh uh experience

01:03:45,680 --> 01:03:52,400
or or resources to manage it uh i think

01:03:49,359 --> 01:03:55,039
we are over time we are not so

01:03:52,400 --> 01:03:55,920
yeah let's close this thank you great

01:03:55,039 --> 01:04:00,319
talk

01:03:55,920 --> 01:04:03,359
and i think time for the breakout rooms

01:04:00,319 --> 01:04:05,599
and just as a reminder if you get sent

01:04:03,359 --> 01:04:07,440
to a breakout room where there is nobody

01:04:05,599 --> 01:04:09,520
you can always come back to

01:04:07,440 --> 01:04:11,599
the main room and we will assign to you

01:04:09,520 --> 01:04:12,400
and don't forget after the breakout room

01:04:11,599 --> 01:04:16,559
we have

01:04:12,400 --> 01:04:16,559
the last talk of evening

01:04:16,799 --> 01:04:21,760
all right i think everyone is coming

01:04:20,000 --> 01:04:26,000
back

01:04:21,760 --> 01:04:30,000
so we should probably resume now for

01:04:26,000 --> 01:04:33,039
the last stop and

01:04:30,000 --> 01:04:34,240
the last talk will be uh from andreas he

01:04:33,039 --> 01:04:38,839
will be talking about

01:04:34,240 --> 01:04:41,839
cropping rocks rust rocket was micro

01:04:38,839 --> 01:04:41,839
service

01:04:42,480 --> 01:04:55,839
yes andrea instruction

01:04:58,799 --> 01:05:05,359
the unused button is all the time

01:05:02,000 --> 01:05:05,359
somewhere else when you look for it

01:05:06,079 --> 01:05:13,680
so thank you very much and

01:05:09,359 --> 01:05:15,760
um thanks a lot to the

01:05:13,680 --> 01:05:17,119
to the rust berlin team for having me

01:05:15,760 --> 01:05:20,319
and the invitation

01:05:17,119 --> 01:05:23,760
and making everything possible

01:05:20,319 --> 01:05:28,720
um my name is andreas i'm

01:05:23,760 --> 01:05:30,480
living near munich germany i'm a

01:05:28,720 --> 01:05:32,079
i'm a freelance software developer and

01:05:30,480 --> 01:05:34,640
consultant and i'm

01:05:32,079 --> 01:05:37,520
specialized on automated workflows in

01:05:34,640 --> 01:05:39,680
the publishing industry

01:05:37,520 --> 01:05:42,319
and just that you don't wonder the black

01:05:39,680 --> 01:05:46,720
ribbon on the screen on the top

01:05:42,319 --> 01:05:51,839
left is is in honor of dan kaminsky

01:05:46,720 --> 01:05:51,839
who died two days ago

01:05:51,920 --> 01:05:57,680
so dropping rocks

01:05:54,960 --> 01:05:59,039
that is a single page web app that comes

01:05:57,680 --> 01:06:02,400
with a bold claim

01:05:59,039 --> 01:06:05,440
that anyone can upload an image and

01:06:02,400 --> 01:06:08,160
crop and scale it to some

01:06:05,440 --> 01:06:09,440
50 social media formats in less than a

01:06:08,160 --> 01:06:12,079
minute

01:06:09,440 --> 01:06:12,880
and the best way to demonstrate what

01:06:12,079 --> 01:06:16,839
this is is

01:06:12,880 --> 01:06:18,640
we we spend this minute and try to do it

01:06:16,839 --> 01:06:21,280
live

01:06:18,640 --> 01:06:22,640
so this is what the web page looks like

01:06:21,280 --> 01:06:24,880
i'm

01:06:22,640 --> 01:06:27,359
selecting two images here they are

01:06:24,880 --> 01:06:29,760
uploaded to a server

01:06:27,359 --> 01:06:30,799
and as soon as they upload it i can

01:06:29,760 --> 01:06:34,720
click on an image

01:06:30,799 --> 01:06:36,559
and i get into a special editor and the

01:06:34,720 --> 01:06:38,880
whole idea behind this thing is that i

01:06:36,559 --> 01:06:42,240
can apply a cropping hint

01:06:38,880 --> 01:06:44,160
once it's universal and it will fit for

01:06:42,240 --> 01:06:45,119
any aspect ratio that i'm going to

01:06:44,160 --> 01:06:48,480
produce

01:06:45,119 --> 01:06:49,119
later on so i have the original image in

01:06:48,480 --> 01:06:54,000
the middle

01:06:49,119 --> 01:06:56,480
and i have a selection of aspect ratios

01:06:54,000 --> 01:06:58,319
as previews around and what you

01:06:56,480 --> 01:06:58,880
currently see is what the image would

01:06:58,319 --> 01:07:01,039
look like

01:06:58,880 --> 01:07:02,960
in different aspect ratios if it was

01:07:01,039 --> 01:07:05,440
cropped from the middle

01:07:02,960 --> 01:07:07,359
but now i can use this color tools like

01:07:05,440 --> 01:07:09,760
this yellow diamond

01:07:07,359 --> 01:07:11,039
and start to move it on the master image

01:07:09,760 --> 01:07:14,319
and what happens is

01:07:11,039 --> 01:07:17,599
that the

01:07:14,319 --> 01:07:19,119
cropping rectangle of the different

01:07:17,599 --> 01:07:21,599
aspect ratios

01:07:19,119 --> 01:07:24,000
changes independence of the movement

01:07:21,599 --> 01:07:26,319
that i make here

01:07:24,000 --> 01:07:28,720
and if i find a position for this yellow

01:07:26,319 --> 01:07:31,760
diamond where all of these pieces

01:07:28,720 --> 01:07:33,359
look good i'm set and done i can save

01:07:31,760 --> 01:07:35,920
and proceed

01:07:33,359 --> 01:07:37,440
sometimes just moving this yellow

01:07:35,920 --> 01:07:40,559
diamond is not enough

01:07:37,440 --> 01:07:43,359
to get a good solution or

01:07:40,559 --> 01:07:44,160
all the images so i take some things

01:07:43,359 --> 01:07:47,119
that is a bit

01:07:44,160 --> 01:07:48,960
a little bit more complicated so

01:07:47,119 --> 01:07:52,160
obviously

01:07:48,960 --> 01:07:53,839
this uh woman is the focus area the main

01:07:52,160 --> 01:07:57,920
topic of the image

01:07:53,839 --> 01:08:00,559
but if you look on the um

01:07:57,920 --> 01:08:01,839
on the super portrait to the ref to the

01:08:00,559 --> 01:08:04,880
right

01:08:01,839 --> 01:08:06,799
um this image is only telling part of

01:08:04,880 --> 01:08:08,640
the story we are missing the groceries

01:08:06,799 --> 01:08:11,039
it's not obvious

01:08:08,640 --> 01:08:12,559
that this is about shopping and

01:08:11,039 --> 01:08:15,039
depending me

01:08:12,559 --> 01:08:16,239
so i can make more sophisticated

01:08:15,039 --> 01:08:19,520
modifications

01:08:16,239 --> 01:08:19,520
there is another room

01:08:20,400 --> 01:08:25,679
and now i can change

01:08:23,440 --> 01:08:26,719
so that even in the super portrait we

01:08:25,679 --> 01:08:29,440
still get a little bit

01:08:26,719 --> 01:08:31,279
impression from the grocery store but we

01:08:29,440 --> 01:08:33,759
don't cut away the face on the other

01:08:31,279 --> 01:08:33,759
images

01:08:33,839 --> 01:08:40,080
well solution looks good for me

01:08:37,199 --> 01:08:41,440
i save and proceed and now the server

01:08:40,080 --> 01:08:45,199
will

01:08:41,440 --> 01:08:46,960
drop a predefined list of some 50 social

01:08:45,199 --> 01:08:50,839
media formats

01:08:46,960 --> 01:08:53,279
and once it's done i can download the

01:08:50,839 --> 01:08:57,759
result

01:08:53,279 --> 01:09:01,600
it comes as a zip file i unpack it

01:08:57,759 --> 01:09:04,000
and i open it and you can see

01:09:01,600 --> 01:09:06,960
we have now named by the social media

01:09:04,000 --> 01:09:11,839
site folders we have all the croppings

01:09:06,960 --> 01:09:11,839
in different formats properly labeled

01:09:12,480 --> 01:09:15,359
and we are all done

01:09:16,719 --> 01:09:21,839
we also return the original image with

01:09:19,120 --> 01:09:23,839
the cropping hints that we just applied

01:09:21,839 --> 01:09:27,679
embedded in the active metadata of the

01:09:23,839 --> 01:09:30,880
image so i could use this

01:09:27,679 --> 01:09:33,600
this pre-cropped

01:09:30,880 --> 01:09:35,040
information image for future use so i

01:09:33,600 --> 01:09:38,480
don't have to reposition the

01:09:35,040 --> 01:09:38,480
the pointers and the frames again

01:09:41,600 --> 01:09:47,120
so let's look how this is done the

01:09:44,480 --> 01:09:49,279
architecture of cropping rocks

01:09:47,120 --> 01:09:50,560
we have a front end that is the web page

01:09:49,279 --> 01:09:53,440
that you've just seen

01:09:50,560 --> 01:09:55,040
and that's only a few lines of html in

01:09:53,440 --> 01:09:58,400
javascript mainly for

01:09:55,040 --> 01:10:00,719
the animations and

01:09:58,400 --> 01:10:02,159
nothing else in it it's a pure front end

01:10:00,719 --> 01:10:06,320
with no business business

01:10:02,159 --> 01:10:08,800
logic at all and then we have a rust

01:10:06,320 --> 01:10:10,560
rocket based backend running on a

01:10:08,800 --> 01:10:13,920
separate server

01:10:10,560 --> 01:10:16,239
and that is doing the real business so

01:10:13,920 --> 01:10:16,960
now for only cropping social media

01:10:16,239 --> 01:10:20,560
images

01:10:16,960 --> 01:10:20,560
it wouldn't be necessary to make

01:10:20,800 --> 01:10:25,679
such a sophisticated everything could be

01:10:23,679 --> 01:10:28,719
done in the client of course

01:10:25,679 --> 01:10:29,199
but the backend has its own name it's

01:10:28,719 --> 01:10:31,360
called q

01:10:29,199 --> 01:10:33,600
crop and it has a much bigger history

01:10:31,360 --> 01:10:35,280
than the cropping rocks front end

01:10:33,600 --> 01:10:37,120
it's in the making since about three

01:10:35,280 --> 01:10:38,960
years and it contains

01:10:37,120 --> 01:10:40,239
all the knowledge and business logic

01:10:38,960 --> 01:10:42,080
about

01:10:40,239 --> 01:10:43,360
the format for this sort of cropping

01:10:42,080 --> 01:10:45,360
hint that we embed

01:10:43,360 --> 01:10:46,719
and the algorithm that can use it to

01:10:45,360 --> 01:10:49,280
crop images

01:10:46,719 --> 01:10:51,600
and all the services that are needed to

01:10:49,280 --> 01:10:53,920
embed this into any workflow in a

01:10:51,600 --> 01:10:56,560
production agency or a publishing house

01:10:53,920 --> 01:10:56,560
for example

01:10:56,640 --> 01:11:01,040
and then there's something a little bit

01:10:58,159 --> 01:11:01,600
special the editor that you've just seen

01:11:01,040 --> 01:11:04,640
where i

01:11:01,600 --> 01:11:06,960
moved um the cropping hints to

01:11:04,640 --> 01:11:08,000
to make my selection that sort of an

01:11:06,960 --> 01:11:10,880
island that's

01:11:08,000 --> 01:11:14,159
again html code with lots of javascript

01:11:10,880 --> 01:11:17,120
in and there is some web assembly inside

01:11:14,159 --> 01:11:19,600
and this is its own rust project

01:11:17,120 --> 01:11:22,880
compiled in its own

01:11:19,600 --> 01:11:27,840
in its own cargo crate and then embedded

01:11:22,880 --> 01:11:27,840
into this back end

01:11:28,800 --> 01:11:32,000
so these are the services that are

01:11:30,800 --> 01:11:35,520
provided by the

01:11:32,000 --> 01:11:37,120
backend we have we have various

01:11:35,520 --> 01:11:40,080
monitoring and debugging

01:11:37,120 --> 01:11:41,199
endpoints we have the options for file

01:11:40,080 --> 01:11:43,840
up and download

01:11:41,199 --> 01:11:44,719
but that's not the necessity the whole

01:11:43,840 --> 01:11:48,000
system is

01:11:44,719 --> 01:11:49,840
is made for considerably larger problems

01:11:48,000 --> 01:11:50,560
in an industrial environment where we

01:11:49,840 --> 01:11:53,600
will

01:11:50,560 --> 01:11:55,440
pick images by url from somewhere else

01:11:53,600 --> 01:11:57,920
for example

01:11:55,440 --> 01:12:00,320
then we have this cropping hint editor

01:11:57,920 --> 01:12:05,040
we call it internally the web client

01:12:00,320 --> 01:12:07,920
that's this island within the code

01:12:05,040 --> 01:12:09,920
but it is delivered by the back end

01:12:07,920 --> 01:12:11,600
usually embedded as an iframe in the

01:12:09,920 --> 01:12:14,719
front end

01:12:11,600 --> 01:12:18,000
and then we have three

01:12:14,719 --> 01:12:20,560
cropping services that either return

01:12:18,000 --> 01:12:22,000
a single image that has been cropped to

01:12:20,560 --> 01:12:25,120
certain parameters that were

01:12:22,000 --> 01:12:29,199
passed by an http get request

01:12:25,120 --> 01:12:32,480
and all the parameters in in the url

01:12:29,199 --> 01:12:36,159
that would be the way if you live

01:12:32,480 --> 01:12:40,159
crop images from a website for example

01:12:36,159 --> 01:12:44,719
or we could we could crop

01:12:40,159 --> 01:12:46,880
a whole area of images or aspect ratios

01:12:44,719 --> 01:12:49,040
called internally bulk crop the multiple

01:12:46,880 --> 01:12:50,800
image crop that returns a zip file that

01:12:49,040 --> 01:12:52,320
is what we just used on the cropping

01:12:50,800 --> 01:12:54,480
rocks front end

01:12:52,320 --> 01:12:55,440
and then there's also a virtual crop

01:12:54,480 --> 01:12:58,239
which

01:12:55,440 --> 01:13:00,239
does the cropping but does not return an

01:12:58,239 --> 01:13:02,960
image file but rather data

01:13:00,239 --> 01:13:04,080
like rectangles positions offsets and

01:13:02,960 --> 01:13:06,800
sizes

01:13:04,080 --> 01:13:08,000
so that you can do something with the

01:13:06,800 --> 01:13:12,159
data in your own

01:13:08,000 --> 01:13:15,120
front end for example

01:13:12,159 --> 01:13:16,640
rescale and pre-position a file in an

01:13:15,120 --> 01:13:19,199
indesign

01:13:16,640 --> 01:13:21,120
picture frame but keep it complete so

01:13:19,199 --> 01:13:23,679
you can rescale it and move it around

01:13:21,120 --> 01:13:23,679
afterwards

01:13:27,520 --> 01:13:31,520
and this is sort of the communication

01:13:30,080 --> 01:13:34,400
that takes place between the

01:13:31,520 --> 01:13:35,199
front end and the back end so we are

01:13:34,400 --> 01:13:37,920
requesting an

01:13:35,199 --> 01:13:38,719
upload the cue card back-end will accept

01:13:37,920 --> 01:13:40,719
the file

01:13:38,719 --> 01:13:42,400
and put it in a cache somewhere for

01:13:40,719 --> 01:13:45,600
three hours in that case

01:13:42,400 --> 01:13:46,000
it will return an id for the file then

01:13:45,600 --> 01:13:48,960
we

01:13:46,000 --> 01:13:50,960
request this cropping hint editor or

01:13:48,960 --> 01:13:54,080
that image from the cache

01:13:50,960 --> 01:13:58,239
with the id that we got before

01:13:54,080 --> 01:14:00,719
that will return one html file

01:13:58,239 --> 01:14:02,880
that contains everything like the html

01:14:00,719 --> 01:14:06,320
the style the javascript

01:14:02,880 --> 01:14:08,719
and the web assembly and that will be

01:14:06,320 --> 01:14:10,480
shown in the cropping rocks fondant as

01:14:08,719 --> 01:14:13,600
an iframe

01:14:10,480 --> 01:14:15,840
and as soon as i press the save button i

01:14:13,600 --> 01:14:18,800
will send a message from the front end

01:14:15,840 --> 01:14:19,600
to the iframe within the front end and

01:14:18,800 --> 01:14:22,560
that

01:14:19,600 --> 01:14:24,000
causes the back end to write back the

01:14:22,560 --> 01:14:27,280
cropping hints into the

01:14:24,000 --> 01:14:28,320
metadata of the image and once this is

01:14:27,280 --> 01:14:31,760
confirmed

01:14:28,320 --> 01:14:33,040
i can order my list of target sizes that

01:14:31,760 --> 01:14:35,679
i want to retrieve

01:14:33,040 --> 01:14:37,440
the back end will produce it sip it and

01:14:35,679 --> 01:14:43,360
deliver a download parse so i can

01:14:37,440 --> 01:14:45,600
download it

01:14:43,360 --> 01:14:46,480
now when i started this project like

01:14:45,600 --> 01:14:48,239
three years ago

01:14:46,480 --> 01:14:49,920
and i spent the first year just to find

01:14:48,239 --> 01:14:52,560
the algorithm and the idea

01:14:49,920 --> 01:14:54,840
how to describe a universal cropping

01:14:52,560 --> 01:14:56,560
hint that would be good for any aspect

01:14:54,840 --> 01:14:59,760
ratios

01:14:56,560 --> 01:15:02,800
there was a first phase conceptual phase

01:14:59,760 --> 01:15:04,480
and then i had a colleague

01:15:02,800 --> 01:15:06,800
we implemented the first proof of

01:15:04,480 --> 01:15:08,880
concept completely in code

01:15:06,800 --> 01:15:10,880
and that was standard way with java

01:15:08,880 --> 01:15:12,800
apache and stuff

01:15:10,880 --> 01:15:13,920
and then last year i decided to port it

01:15:12,800 --> 01:15:16,960
to rust

01:15:13,920 --> 01:15:20,480
because this

01:15:16,960 --> 01:15:22,560
is cropping hint editor

01:15:20,480 --> 01:15:24,159
we have done in the first version as a

01:15:22,560 --> 01:15:26,800
proprietary desktop client

01:15:24,159 --> 01:15:29,199
cross-platform for from mac windows and

01:15:26,800 --> 01:15:32,080
linux and we used some super exotic

01:15:29,199 --> 01:15:32,640
programming language called live code

01:15:32,080 --> 01:15:35,760
and

01:15:32,640 --> 01:15:39,920
it was not performed enough we couldn't

01:15:35,760 --> 01:15:42,239
move the red frame in real time

01:15:39,920 --> 01:15:43,840
without stutters because it has to check

01:15:42,239 --> 01:15:46,159
the positions of the inner frames and

01:15:43,840 --> 01:15:48,640
push them around and stuff

01:15:46,159 --> 01:15:50,400
so i decided we have to make it a web

01:15:48,640 --> 01:15:53,199
client then it's easier to embed

01:15:50,400 --> 01:15:55,520
into other solutions like like dumb

01:15:53,199 --> 01:15:58,719
systems

01:15:55,520 --> 01:16:03,120
and did some investigation

01:15:58,719 --> 01:16:05,120
turned out app assembly would do the job

01:16:03,120 --> 01:16:07,440
or i was just supposed to think like

01:16:05,120 --> 01:16:09,600
this i couldn't imagine that

01:16:07,440 --> 01:16:11,440
javascript could be fast enough to do

01:16:09,600 --> 01:16:13,600
everything that has to be done

01:16:11,440 --> 01:16:14,640
when i move the mouse with the yellow

01:16:13,600 --> 01:16:17,440
diamond

01:16:14,640 --> 01:16:18,719
and i get a mouse event every every six

01:16:17,440 --> 01:16:20,000
teams of a second

01:16:18,719 --> 01:16:22,320
to do the calculations that are

01:16:20,000 --> 01:16:24,400
necessary

01:16:22,320 --> 01:16:26,080
because assembly is faster than script

01:16:24,400 --> 01:16:28,960
right

01:16:26,080 --> 01:16:30,800
oh i'm kidding but that got me into web

01:16:28,960 --> 01:16:34,080
assembly that got me into rust

01:16:30,800 --> 01:16:37,040
and just to see what this means

01:16:34,080 --> 01:16:38,880
what happens when i pick up the yellow

01:16:37,040 --> 01:16:40,640
diamond and i move it around with the

01:16:38,880 --> 01:16:42,320
mouse

01:16:40,640 --> 01:16:44,080
60 times a second i have to do

01:16:42,320 --> 01:16:45,520
everything that is on the listed on the

01:16:44,080 --> 01:16:48,320
right side here

01:16:45,520 --> 01:16:49,440
so i have to calculate where my mouse is

01:16:48,320 --> 01:16:51,199
where this

01:16:49,440 --> 01:16:53,280
element is going to be this movable

01:16:51,199 --> 01:16:56,719
element then i have to check

01:16:53,280 --> 01:17:00,640
the limits for example if i push the the

01:16:56,719 --> 01:17:03,600
outcrop frame the red one and i

01:17:00,640 --> 01:17:05,120
push into the green one it gets pushed

01:17:03,600 --> 01:17:07,679
along

01:17:05,120 --> 01:17:10,000
and because it has to be inside and the

01:17:07,679 --> 01:17:11,120
green one will push the yellow diamond

01:17:10,000 --> 01:17:13,199
with it

01:17:11,120 --> 01:17:14,960
all these limit checks have to be done

01:17:13,199 --> 01:17:17,600
60 times seconds

01:17:14,960 --> 01:17:20,080
then i have to produce an array of all

01:17:17,600 --> 01:17:22,960
the sizes of this preview windows

01:17:20,080 --> 01:17:24,480
i have to get the positions of the

01:17:22,960 --> 01:17:27,520
cropping hint elements

01:17:24,480 --> 01:17:32,239
i have to put everything into some

01:17:27,520 --> 01:17:34,000
objects um json files serialize it and

01:17:32,239 --> 01:17:36,080
then it goes into

01:17:34,000 --> 01:17:37,600
the web assembly part which is written

01:17:36,080 --> 01:17:38,719
in rust and does all the number

01:17:37,600 --> 01:17:40,920
crunching

01:17:38,719 --> 01:17:42,960
or this rectangular um

01:17:40,920 --> 01:17:46,000
[Music]

01:17:42,960 --> 01:17:48,080
cropping rects within the master image

01:17:46,000 --> 01:17:49,520
they are serialized again they are sent

01:17:48,080 --> 01:17:52,480
back

01:17:49,520 --> 01:17:54,400
and then i have to try everything each

01:17:52,480 --> 01:17:55,840
of the previews is a canvas that has to

01:17:54,400 --> 01:18:00,480
be redrawn

01:17:55,840 --> 01:18:02,719
in a nice way so i'm actually

01:18:00,480 --> 01:18:03,920
loading or have the entire image in the

01:18:02,719 --> 01:18:07,040
cache i'm just

01:18:03,920 --> 01:18:08,800
changing the cropping rectangle from it

01:18:07,040 --> 01:18:10,400
and then i have to build up this master

01:18:08,800 --> 01:18:12,800
image in the middle from the background

01:18:10,400 --> 01:18:16,239
and then all the ui elements

01:18:12,800 --> 01:18:19,520
and this i do 60 times a second

01:18:16,239 --> 01:18:21,040
so i decided to go for for web assembly

01:18:19,520 --> 01:18:22,719
even before i tried to do it in

01:18:21,040 --> 01:18:25,360
javascript because i couldn't just

01:18:22,719 --> 01:18:27,360
imagine that it would be fast enough

01:18:25,360 --> 01:18:28,960
i now have learned that javascript is

01:18:27,360 --> 01:18:30,640
also extremely fast

01:18:28,960 --> 01:18:32,560
maybe would have worked without web

01:18:30,640 --> 01:18:34,800
assembly as well but

01:18:32,560 --> 01:18:38,239
there are other reasons why it's good to

01:18:34,800 --> 01:18:38,239
have it that way that i will show in a

01:18:38,840 --> 01:18:43,679
second

01:18:41,040 --> 01:18:44,400
so what were the decisions that a year

01:18:43,679 --> 01:18:47,520
ago i

01:18:44,400 --> 01:18:49,040
i decided to go for rust well there was

01:18:47,520 --> 01:18:51,120
this web assembly part

01:18:49,040 --> 01:18:53,120
and there were multiple reasons i

01:18:51,120 --> 01:18:55,520
thought i had to go for web assembly

01:18:53,120 --> 01:18:56,239
and when i read about webassembly rust

01:18:55,520 --> 01:18:59,679
was the

01:18:56,239 --> 01:19:03,440
recommended language for it so

01:18:59,679 --> 01:19:06,840
i did not i did not question this i just

01:19:03,440 --> 01:19:11,520
went for it and

01:19:06,840 --> 01:19:14,800
um it had one big advantage

01:19:11,520 --> 01:19:18,400
uniformity this super

01:19:14,800 --> 01:19:22,960
complex algorithm for doing the cropping

01:19:18,400 --> 01:19:23,760
calculations um was written in rust in

01:19:22,960 --> 01:19:25,280
the base engine

01:19:23,760 --> 01:19:28,000
and i didn't have to rewrite it in

01:19:25,280 --> 01:19:30,800
javascript to make it client-side i

01:19:28,000 --> 01:19:33,360
could just copy-paste it into my

01:19:30,800 --> 01:19:36,000
web assembly code and move it into the

01:19:33,360 --> 01:19:38,480
website like this

01:19:36,000 --> 01:19:40,480
and there's also a little bit of

01:19:38,480 --> 01:19:41,600
obfuscation because i'm putting the

01:19:40,480 --> 01:19:44,400
cropping algorithm

01:19:41,600 --> 01:19:45,280
on the client side it shouldn't be too

01:19:44,400 --> 01:19:48,480
obvious to

01:19:45,280 --> 01:19:50,880
to look into the code so webassembly

01:19:48,480 --> 01:19:51,679
provides a little bit of optimization

01:19:50,880 --> 01:19:54,880
enough for

01:19:51,679 --> 01:19:57,679
my purposes so

01:19:54,880 --> 01:19:59,679
one code base that they can um that they

01:19:57,679 --> 01:20:01,040
can run instead of javascript i have it

01:19:59,679 --> 01:20:05,280
on the server part i have it

01:20:01,040 --> 01:20:07,920
um in the iframe part that i embed

01:20:05,280 --> 01:20:09,840
then scalability this was one of the

01:20:07,920 --> 01:20:13,840
biggest things

01:20:09,840 --> 01:20:16,080
when we solved the first solution

01:20:13,840 --> 01:20:17,440
we rented a server we installed an

01:20:16,080 --> 01:20:20,560
operating system

01:20:17,440 --> 01:20:22,960
we installed apache and java virtual

01:20:20,560 --> 01:20:25,280
machine and we wrote code and stuff

01:20:22,960 --> 01:20:26,000
and we had our first customer for this

01:20:25,280 --> 01:20:28,480
whole thing

01:20:26,000 --> 01:20:31,679
and we had the impression everyone needs

01:20:28,480 --> 01:20:33,600
this who is dealing with pictures

01:20:31,679 --> 01:20:35,360
how do we scale with how do we scale

01:20:33,600 --> 01:20:37,280
this up

01:20:35,360 --> 01:20:39,280
now there's a long term goal that i have

01:20:37,280 --> 01:20:40,320
that is a function as a service so in

01:20:39,280 --> 01:20:43,920
the end it should be

01:20:40,320 --> 01:20:46,239
probably a cloudflare worker or aws

01:20:43,920 --> 01:20:47,360
lambda or something like this i'm not

01:20:46,239 --> 01:20:49,040
into that yet

01:20:47,360 --> 01:20:51,520
because i don't have enough knowledge

01:20:49,040 --> 01:20:54,320
about it and i have to make more

01:20:51,520 --> 01:20:56,800
preparations on the code as well

01:20:54,320 --> 01:20:57,679
but that's the long-term goal so when i

01:20:56,800 --> 01:21:00,480
started

01:20:57,679 --> 01:21:01,440
to develop with the long-term goal in

01:21:00,480 --> 01:21:03,679
mind

01:21:01,440 --> 01:21:05,120
rust was all over the place like if you

01:21:03,679 --> 01:21:08,159
go for cloudflare worker

01:21:05,120 --> 01:21:09,360
go for rust and app assembly and that

01:21:08,159 --> 01:21:11,760
will be it

01:21:09,360 --> 01:21:14,400
so that was a confirmation for me that

01:21:11,760 --> 01:21:18,159
going for rust would solve a couple of

01:21:14,400 --> 01:21:21,600
issues like scalability and speed

01:21:18,159 --> 01:21:24,320
and single source

01:21:21,600 --> 01:21:26,880
organization it just seemed to make

01:21:24,320 --> 01:21:26,880
sense for me

01:21:27,199 --> 01:21:33,760
and accessibility is a big topic

01:21:30,239 --> 01:21:36,400
i come from a system integrators

01:21:33,760 --> 01:21:37,520
history so i go to a customer i find

01:21:36,400 --> 01:21:39,520
different systems

01:21:37,520 --> 01:21:41,840
and apis and i have to connect it and

01:21:39,520 --> 01:21:43,679
exchange data so i'm

01:21:41,840 --> 01:21:44,880
i'm living in scripting languages like

01:21:43,679 --> 01:21:47,760
tcl or

01:21:44,880 --> 01:21:48,159
or ruby or stuff like this and not too

01:21:47,760 --> 01:21:49,840
deep

01:21:48,159 --> 01:21:51,520
into the academic background of

01:21:49,840 --> 01:21:53,360
programming

01:21:51,520 --> 01:21:54,719
i was by the way completely intimidated

01:21:53,360 --> 01:22:00,400
by the first two talks

01:21:54,719 --> 01:22:00,400
that blew my mind fascinating like hell

01:22:00,960 --> 01:22:04,080
but my daily work is much more earth

01:22:02,880 --> 01:22:07,120
down

01:22:04,080 --> 01:22:09,600
and so

01:22:07,120 --> 01:22:10,960
i gave rust a try tentative in the

01:22:09,600 --> 01:22:13,199
beginning

01:22:10,960 --> 01:22:14,800
and it just clicked for me it worked

01:22:13,199 --> 01:22:16,560
it's not easy to learn

01:22:14,800 --> 01:22:18,400
that's what i say other people but it's

01:22:16,560 --> 01:22:22,159
easy enough it's

01:22:18,400 --> 01:22:24,800
definitely worth the advantages that i

01:22:22,159 --> 01:22:27,600
got from the change to go through the

01:22:24,800 --> 01:22:27,600
learning curve

01:22:29,280 --> 01:22:37,520
so that was q crop version one zero

01:22:34,159 --> 01:22:39,520
just like i described a lot of

01:22:37,520 --> 01:22:41,520
stuff that had to be individually

01:22:39,520 --> 01:22:44,000
maintained and updated and patched and

01:22:41,520 --> 01:22:46,320
stuff and we had a completely

01:22:44,000 --> 01:22:47,360
out of the server world property desktop

01:22:46,320 --> 01:22:48,880
client that we

01:22:47,360 --> 01:22:51,679
would deliver to the customer which

01:22:48,880 --> 01:22:53,679
would of course not scale

01:22:51,679 --> 01:22:55,679
and after the switch to rust that's

01:22:53,679 --> 01:22:59,840
where i am today

01:22:55,679 --> 01:23:00,880
so i have my back end binary that i

01:22:59,840 --> 01:23:03,679
compile i have

01:23:00,880 --> 01:23:04,800
one dependency left that's image magic

01:23:03,679 --> 01:23:07,920
that i'm

01:23:04,800 --> 01:23:09,840
trying to get rid of that it's also

01:23:07,920 --> 01:23:13,040
previously to go for

01:23:09,840 --> 01:23:14,960
function as a service later on

01:23:13,040 --> 01:23:16,480
and i put this in a container and i put

01:23:14,960 --> 01:23:16,880
the summary in the cloud and that's it

01:23:16,480 --> 01:23:18,719
so

01:23:16,880 --> 01:23:20,239
it scales already much easier and

01:23:18,719 --> 01:23:23,600
there's much less

01:23:20,239 --> 01:23:25,760
stuff i have to take care of and where i

01:23:23,600 --> 01:23:29,280
want to be next year

01:23:25,760 --> 01:23:29,280
is the function as a service

01:23:29,440 --> 01:23:35,199
the cache that i maintain for the files

01:23:33,280 --> 01:23:37,280
and the functionality that i maintain in

01:23:35,199 --> 01:23:39,440
the backend should live

01:23:37,280 --> 01:23:43,120
ideally in a content delivery network i

01:23:39,440 --> 01:23:46,840
guess so that's what i'm heading for

01:23:43,120 --> 01:23:49,840
and hopefully we'll be there by next

01:23:46,840 --> 01:23:49,840
year

01:23:50,400 --> 01:23:58,320
and that's it except for questions

01:23:54,480 --> 01:24:02,159
that probably was the fastest talk in

01:23:58,320 --> 01:24:04,719
in rust until history yes i think

01:24:02,159 --> 01:24:05,840
you're right on time that that's great

01:24:04,719 --> 01:24:08,800
as so far

01:24:05,840 --> 01:24:09,440
we haven't had any question but i guess

01:24:08,800 --> 01:24:17,840
probably

01:24:09,440 --> 01:24:17,840
people have few questions great talk

01:24:29,120 --> 01:24:33,520
yes so we have some virtual clubs as

01:24:31,360 --> 01:24:33,520
well

01:24:38,560 --> 01:24:42,560
all right then i think um

01:24:43,520 --> 01:24:50,000
ah well if you give me one more sentence

01:24:46,800 --> 01:24:53,280
this cropping rocks is uh

01:24:50,000 --> 01:24:54,719
free to use so if you have use for it if

01:24:53,280 --> 01:24:56,560
you're living in social media just go

01:24:54,719 --> 01:24:59,280
for it and you did

01:24:56,560 --> 01:25:00,480
and the back end that is the thing that

01:24:59,280 --> 01:25:04,080
uh can be used for

01:25:00,480 --> 01:25:07,040
for many stuff that i eventually want to

01:25:04,080 --> 01:25:08,239
earn money with so that's the business

01:25:07,040 --> 01:25:09,760
model behind why

01:25:08,239 --> 01:25:11,520
why the front end is free and the back

01:25:09,760 --> 01:25:14,080
end is not

01:25:11,520 --> 01:25:15,040
and cropping rocks in that context is

01:25:14,080 --> 01:25:17,760
sort of a

01:25:15,040 --> 01:25:20,000
referenced implementation of the back

01:25:17,760 --> 01:25:20,000
end

01:25:23,280 --> 01:25:30,159
all right so thank you andreas

01:25:26,560 --> 01:25:33,840
yes that's uh to all the attendees

01:25:30,159 --> 01:25:36,960
that's all we have for you today

01:25:33,840 --> 01:25:40,239
and thank you for attending

01:25:36,960 --> 01:25:42,320
the rostentel meetup and i

01:25:40,239 --> 01:25:44,239
stay tuned i think next month we have

01:25:42,320 --> 01:25:48,000
other great talks coming up

01:25:44,239 --> 01:25:51,280
already so yes let's call this

01:25:48,000 --> 01:25:51,280
rock thank you everyone

01:25:52,840 --> 01:25:55,840

YouTube URL: https://www.youtube.com/watch?v=q-oANR8sspw


