Title: Rust and Tell April 2019: Lin Clark - WASI
Publication date: 2019-05-09
Playlist: Rust and Tell Berlin
Description: 
	
Captions: 
	00:00:07,810 --> 00:00:18,340
Wow hi everyone I'm Lynne Clark and I

00:00:15,370 --> 00:00:20,650
make cartoons and I also work at Mozilla

00:00:18,340 --> 00:00:23,020
I'm in the advanced development group we

00:00:20,650 --> 00:00:24,850
work on things like rust and on web

00:00:23,020 --> 00:00:26,320
assembly and today I'll be talking about

00:00:24,850 --> 00:00:28,990
the latest thing that we've been working

00:00:26,320 --> 00:00:32,349
on which is y'see the web assembly

00:00:28,990 --> 00:00:34,780
system interface so basically what we're

00:00:32,349 --> 00:00:37,390
doing is creating a standard way to run

00:00:34,780 --> 00:00:38,620
web assembly outside of the browser and

00:00:37,390 --> 00:00:39,969
you might not have heard this before

00:00:38,620 --> 00:00:42,579
because we've just announced it last

00:00:39,969 --> 00:00:46,089
month so I'll explain at a high level

00:00:42,579 --> 00:00:47,379
the why the what and the who and then we

00:00:46,089 --> 00:00:50,890
can start diving into some of the actual

00:00:47,379 --> 00:00:53,949
details of this is the no-face so first

00:00:50,890 --> 00:00:56,260
off why why would you want to run web

00:00:53,949 --> 00:00:57,609
assembly outside its browser and you

00:00:56,260 --> 00:00:59,710
know it's funny the first time I gave

00:00:57,609 --> 00:01:02,499
this talk was the day after we made the

00:00:59,710 --> 00:01:05,740
announcement so I was drafting the talk

00:01:02,499 --> 00:01:07,479
right after I sent out the tweet for the

00:01:05,740 --> 00:01:09,670
announcement it was at exactly this

00:01:07,479 --> 00:01:12,549
point in my draft when this tweet came

00:01:09,670 --> 00:01:15,399
in from the co-founder of docker so he

00:01:12,549 --> 00:01:17,140
says if wasman wise they existed in 2008

00:01:15,399 --> 00:01:19,810
we wouldn't have needed to create docker

00:01:17,140 --> 00:01:21,520
that's how important it is web assembly

00:01:19,810 --> 00:01:24,789
on the server is the future of computing

00:01:21,520 --> 00:01:26,469
and I want to say that this is not the

00:01:24,789 --> 00:01:28,180
only use case we're running web assembly

00:01:26,469 --> 00:01:30,600
outside of the browser could be helpful

00:01:28,180 --> 00:01:34,030
it can be helpful for things like node

00:01:30,600 --> 00:01:36,310
for other kinds of service applications

00:01:34,030 --> 00:01:39,100
for the blockchain for things like

00:01:36,310 --> 00:01:41,409
portable CLI tools the Internet of

00:01:39,100 --> 00:01:43,899
Things and more than that and I've

00:01:41,409 --> 00:01:46,030
talked about these use cases before in a

00:01:43,899 --> 00:01:48,430
post an article app that I co-authored

00:01:46,030 --> 00:01:50,619
with Jill shine right and Luc Wagner

00:01:48,430 --> 00:01:52,810
about the post MVP feature of pop

00:01:50,619 --> 00:01:53,979
assembly so I'm not gonna go it's too

00:01:52,810 --> 00:01:55,149
much detail if you want to learn more

00:01:53,979 --> 00:01:57,850
about the different use cases you can

00:01:55,149 --> 00:01:59,439
check out that article but I do want to

00:01:57,850 --> 00:02:01,570
talk about some of the reasons the

00:01:59,439 --> 00:02:05,439
common reasons between all these use

00:02:01,570 --> 00:02:08,800
cases why webassembly makes sense so

00:02:05,439 --> 00:02:10,690
first off web assemblies fast it gives

00:02:08,800 --> 00:02:13,090
you the ability to run code at near

00:02:10,690 --> 00:02:14,920
native speeds and it's not just that the

00:02:13,090 --> 00:02:17,159
code runs fast

00:02:14,920 --> 00:02:20,050
it can also give you fast startup times

00:02:17,159 --> 00:02:20,380
and VMs that are built for website

00:02:20,050 --> 00:02:22,780
leaking

00:02:20,380 --> 00:02:24,760
actually start up more quickly than VMS

00:02:22,780 --> 00:02:27,790
are built for things like javascript so

00:02:24,760 --> 00:02:29,830
for example fastly is using web assembly

00:02:27,790 --> 00:02:32,080
to handle requests for their server list

00:02:29,830 --> 00:02:34,240
platform and they do this by spinning up

00:02:32,080 --> 00:02:37,420
a new virtual machine instance on every

00:02:34,240 --> 00:02:39,700
single request and they can only do this

00:02:37,420 --> 00:02:41,970
because they can instantiate the web

00:02:39,700 --> 00:02:45,160
symbol a module in under 50 microseconds

00:02:41,970 --> 00:02:46,660
so for comparison if you are doing the

00:02:45,160 --> 00:02:50,920
same kind of thing with JavaScript in v8

00:02:46,660 --> 00:02:54,100
it takes about 5 milliseconds so the

00:02:50,920 --> 00:02:55,690
next thing is that web simply safe with

00:02:54,100 --> 00:02:57,580
web assembly it's easier to keep things

00:02:55,690 --> 00:02:59,350
secure than it is when you have a binary

00:02:57,580 --> 00:03:01,510
that's running directly on your machine

00:02:59,350 --> 00:03:04,930
and I'll talk about this more later in

00:03:01,510 --> 00:03:06,820
the talk the third thing is that web

00:03:04,930 --> 00:03:08,980
assembly is portable the same web

00:03:06,820 --> 00:03:10,450
assembly file can be run in a bunch of

00:03:08,980 --> 00:03:12,460
different runtimes across different

00:03:10,450 --> 00:03:13,930
kinds of machines using different kinds

00:03:12,460 --> 00:03:14,680
of operating systems and this means that

00:03:13,930 --> 00:03:17,080
you don't have to do things like

00:03:14,680 --> 00:03:19,420
compiling your module specifically for

00:03:17,080 --> 00:03:21,760
every device you're targeting and web

00:03:19,420 --> 00:03:24,130
somebody's also scalable it takes a lot

00:03:21,760 --> 00:03:26,140
less memory to run a web assembly VM

00:03:24,130 --> 00:03:29,080
that does a JavaScript beyond so I

00:03:26,140 --> 00:03:31,450
mentioned fasting for their web assembly

00:03:29,080 --> 00:03:34,420
runtime only requires a few kilobytes of

00:03:31,450 --> 00:03:36,970
memory overhead compared to tens of

00:03:34,420 --> 00:03:38,740
megabytes with v8 so this means that

00:03:36,970 --> 00:03:40,930
they can fit tens of thousands of

00:03:38,740 --> 00:03:44,200
simultaneously running programs in the

00:03:40,930 --> 00:03:47,350
same process as opposed to if you are

00:03:44,200 --> 00:03:48,610
using gate you could only do hundreds so

00:03:47,350 --> 00:03:51,190
that's why you would want to run web

00:03:48,610 --> 00:03:53,920
assembly outside of the browser now

00:03:51,190 --> 00:03:58,570
let's look at the what the what of

00:03:53,920 --> 00:03:59,980
Razzie what it actually is when I was

00:03:58,570 --> 00:04:01,390
introducing web assembly

00:03:59,980 --> 00:04:03,400
I talked about how is an assembly

00:04:01,390 --> 00:04:05,320
language for conception a conceptual

00:04:03,400 --> 00:04:08,200
machine not for an actual physical

00:04:05,320 --> 00:04:11,459
machine this is why I can run across a

00:04:08,200 --> 00:04:14,350
bunch of different machine architectures

00:04:11,459 --> 00:04:16,540
it's very close to the assembly language

00:04:14,350 --> 00:04:18,640
that most machines use so the runtime

00:04:16,540 --> 00:04:20,440
only needs to make a small jump from the

00:04:18,640 --> 00:04:21,820
web assembly to the assembly language

00:04:20,440 --> 00:04:25,150
for the machine that that front times

00:04:21,820 --> 00:04:26,950
running on so it goes from this assembly

00:04:25,150 --> 00:04:30,400
for the conceptual machine to the

00:04:26,950 --> 00:04:32,410
assembly for the actual machine just as

00:04:30,400 --> 00:04:33,970
web assembly is an assembly language for

00:04:32,410 --> 00:04:35,830
a conceptual machine

00:04:33,970 --> 00:04:37,660
webassembly needs a system interface for

00:04:35,830 --> 00:04:40,840
conceptual operating system not for any

00:04:37,660 --> 00:04:42,100
single operating system this way it can

00:04:40,840 --> 00:04:45,430
be run across a whole bunch of different

00:04:42,100 --> 00:04:48,040
operating systems and this is what huazi

00:04:45,430 --> 00:04:53,140
is the system interface for the web

00:04:48,040 --> 00:04:54,610
assembly platform now who's doing this

00:04:53,140 --> 00:04:56,530
work

00:04:54,610 --> 00:04:59,050
why assays being standardized by the web

00:04:56,530 --> 00:05:00,760
assembly community we've chartered a sub

00:04:59,050 --> 00:05:04,240
group to work on it and you can find out

00:05:00,760 --> 00:05:05,590
more in the web assembly / quasi repo so

00:05:04,240 --> 00:05:08,560
if you want to get involved in this work

00:05:05,590 --> 00:05:10,750
you have a couple of options if you have

00:05:08,560 --> 00:05:14,020
you know deep understanding of operating

00:05:10,750 --> 00:05:16,660
systems and you know have some ideas

00:05:14,020 --> 00:05:18,370
about how this standard could work you

00:05:16,660 --> 00:05:20,860
can join the CG and work on the

00:05:18,370 --> 00:05:21,730
standardization or you can start

00:05:20,860 --> 00:05:24,610
contributing to one of the

00:05:21,730 --> 00:05:26,050
implementations such as madam time which

00:05:24,610 --> 00:05:29,020
is the webassembly runtime that we're

00:05:26,050 --> 00:05:31,630
working on it was elect or if you have

00:05:29,020 --> 00:05:34,030
an existing project that you know might

00:05:31,630 --> 00:05:35,560
be able to use Y Z you can feel free to

00:05:34,030 --> 00:05:37,480
get in touch with us and we would be

00:05:35,560 --> 00:05:38,740
happy to talk more about it for example

00:05:37,480 --> 00:05:41,560
we've been talking with the node folks

00:05:38,740 --> 00:05:44,380
about how they could possibly use Y Z so

00:05:41,560 --> 00:05:47,140
that you could have native no modules

00:05:44,380 --> 00:05:48,669
modules that are written in C and which

00:05:47,140 --> 00:05:50,860
typically in node have to be compiled

00:05:48,669 --> 00:05:53,080
you know either

00:05:50,860 --> 00:05:56,740
delivered as a binary or compiled on the

00:05:53,080 --> 00:05:58,480
device we could do that with Wasley

00:05:56,740 --> 00:05:59,980
instead so that those modules would be

00:05:58,480 --> 00:06:03,580
portable in the same way the JavaScript

00:05:59,980 --> 00:06:06,400
modules and noter portable so now is all

00:06:03,580 --> 00:06:11,800
of that covered let's talk about huazi

00:06:06,400 --> 00:06:14,169
in more detail so a lot of people talked

00:06:11,800 --> 00:06:16,600
about languages like C giving you direct

00:06:14,169 --> 00:06:19,390
access to system resources but that's

00:06:16,600 --> 00:06:22,120
not quite true these languages don't

00:06:19,390 --> 00:06:24,580
have direct access to things they can't

00:06:22,120 --> 00:06:28,900
do things like open or create files on

00:06:24,580 --> 00:06:30,610
most systems directly why not because

00:06:28,900 --> 00:06:32,800
these system resources such as files

00:06:30,610 --> 00:06:35,290
memory network connections they're too

00:06:32,800 --> 00:06:39,040
important to the stability and security

00:06:35,290 --> 00:06:40,510
of your computer if one program

00:06:39,040 --> 00:06:42,460
unintentionally messes with the

00:06:40,510 --> 00:06:45,520
resources of another then it could crash

00:06:42,460 --> 00:06:46,470
the program even worse of a program or

00:06:45,520 --> 00:06:48,420
user intentional

00:06:46,470 --> 00:06:51,360
messes with the resources of another it

00:06:48,420 --> 00:06:53,280
could leak sensitive data so we need a

00:06:51,360 --> 00:06:57,360
way to control which programs and users

00:06:53,280 --> 00:06:59,310
can access which resources people figure

00:06:57,360 --> 00:07:01,050
this out pretty early on and came up

00:06:59,310 --> 00:07:03,300
with a way to provide this kind of

00:07:01,050 --> 00:07:06,750
control which is protection rain

00:07:03,300 --> 00:07:08,580
security so with protection ring

00:07:06,750 --> 00:07:10,230
security the operating system basically

00:07:08,580 --> 00:07:12,570
puts a protective barrier around the

00:07:10,230 --> 00:07:15,090
system's resources and this is the

00:07:12,570 --> 00:07:16,830
kernel the kernel is the only thing that

00:07:15,090 --> 00:07:18,990
gets to do operations like creating the

00:07:16,830 --> 00:07:22,050
new file or opening a file or opening a

00:07:18,990 --> 00:07:24,090
network connection the users program

00:07:22,050 --> 00:07:26,790
actually runs outside of its kernel and

00:07:24,090 --> 00:07:28,740
something called user mode and if a

00:07:26,790 --> 00:07:30,330
program wants to do anything like open

00:07:28,740 --> 00:07:33,120
the file it has to ask the kernels to

00:07:30,330 --> 00:07:36,050
open the file for it and this is where

00:07:33,120 --> 00:07:38,940
this concept of a system call comes in

00:07:36,050 --> 00:07:40,919
when the program needs to ask the kernel

00:07:38,940 --> 00:07:43,919
to do one of these things it asks using

00:07:40,919 --> 00:07:46,710
a system call so this gets the kernel a

00:07:43,919 --> 00:07:49,470
chance to figure out which user is

00:07:46,710 --> 00:07:51,960
asking and then I can see if that user

00:07:49,470 --> 00:07:53,750
has access to the file before it does

00:07:51,960 --> 00:07:58,020
the operation before it opens it or

00:07:53,750 --> 00:08:00,450
changes it on most devices this is the

00:07:58,020 --> 00:08:03,110
only way that your code can access the

00:08:00,450 --> 00:08:05,520
system's resources through system calls

00:08:03,110 --> 00:08:08,400
and the operating system is what makes

00:08:05,520 --> 00:08:10,200
these system calls available but a

00:08:08,400 --> 00:08:11,550
feature operating system has its own

00:08:10,200 --> 00:08:13,710
system calls wouldn't you need a

00:08:11,550 --> 00:08:17,100
different version of your code for every

00:08:13,710 --> 00:08:20,300
single operating system fortunately you

00:08:17,100 --> 00:08:24,990
don't so how is this problem solved

00:08:20,300 --> 00:08:27,419
through abstraction most languages

00:08:24,990 --> 00:08:29,340
provide a standard library so while

00:08:27,419 --> 00:08:31,290
coding the programmer doesn't need to

00:08:29,340 --> 00:08:33,539
know which system they'll be targeting

00:08:31,290 --> 00:08:36,630
in the end they just use that interface

00:08:33,539 --> 00:08:38,430
and then when compiling the toolchain

00:08:36,630 --> 00:08:40,740
picks out which implementation of that

00:08:38,430 --> 00:08:43,710
interface to use based on whichever

00:08:40,740 --> 00:08:45,660
system you're targeting so this

00:08:43,710 --> 00:08:47,580
implementation uses functions from the

00:08:45,660 --> 00:08:49,670
operating systems API that means it's

00:08:47,580 --> 00:08:52,350
specific to that operating system and

00:08:49,670 --> 00:08:55,290
this is where the system interface comes

00:08:52,350 --> 00:08:59,190
in so for example put C being compiled

00:08:55,290 --> 00:09:00,409
for Windows could use the windows API to

00:08:59,190 --> 00:09:02,999
interact with

00:09:00,409 --> 00:09:07,499
but if it's being compiled for a Mac or

00:09:02,999 --> 00:09:10,889
Linux it would use POSIX instead this is

00:09:07,499 --> 00:09:13,169
a problem for webassembly though with

00:09:10,889 --> 00:09:14,759
webassembly you don't know what kind of

00:09:13,169 --> 00:09:18,059
operating system you're going to be

00:09:14,759 --> 00:09:19,949
targeting even when you're compiling so

00:09:18,059 --> 00:09:23,159
you can't use any single operating

00:09:19,949 --> 00:09:25,049
systems interface inside the web

00:09:23,159 --> 00:09:29,189
assembly implementation of the standard

00:09:25,049 --> 00:09:31,739
library I've talked before about how web

00:09:29,189 --> 00:09:32,999
assembly is an assembly language for the

00:09:31,739 --> 00:09:35,129
compiler machine you know I talked about

00:09:32,999 --> 00:09:38,429
that in my intro not for the real

00:09:35,129 --> 00:09:41,909
machine and in the same way we need this

00:09:38,429 --> 00:09:44,220
conceptual system interface for the

00:09:41,909 --> 00:09:47,549
conceptual operating system not a real

00:09:44,220 --> 00:09:49,470
operating system but they're already

00:09:47,549 --> 00:09:51,509
runtimes that can run web assembly

00:09:49,470 --> 00:09:54,539
outside of the browser even without

00:09:51,509 --> 00:09:59,459
having that interface in place so how

00:09:54,539 --> 00:10:01,859
are they doing it let's take a look so

00:09:59,459 --> 00:10:04,979
the first tool for producing web

00:10:01,859 --> 00:10:06,749
assembly was unscripted it Emil emulates

00:10:04,979 --> 00:10:11,039
a particular operating system sister

00:10:06,749 --> 00:10:12,629
interface POSIX on the web and so that

00:10:11,039 --> 00:10:14,099
means that the programmer can use

00:10:12,629 --> 00:10:18,479
functions from the C standard library

00:10:14,099 --> 00:10:20,639
Lipsy to do this and script and redo

00:10:18,479 --> 00:10:22,470
this own implementation of Lipsy

00:10:20,639 --> 00:10:24,059
and this implementation was split into

00:10:22,470 --> 00:10:25,859
particle was compiled into the web

00:10:24,059 --> 00:10:27,989
assembly module and the other part was

00:10:25,859 --> 00:10:30,329
implemented in J's blue code that would

00:10:27,989 --> 00:10:31,709
interact with the system you know that

00:10:30,329 --> 00:10:33,569
jazz blue code would call into the

00:10:31,709 --> 00:10:37,259
browser and that would then talk to the

00:10:33,569 --> 00:10:38,909
operating system and most of the early

00:10:37,259 --> 00:10:41,099
web assembly code was compiled using

00:10:38,909 --> 00:10:42,599
Emscripten so when people started

00:10:41,099 --> 00:10:45,509
wanting to run web simply code outside

00:10:42,599 --> 00:10:49,049
of the browser they started by making

00:10:45,509 --> 00:10:51,599
the sub script and compiled code so that

00:10:49,049 --> 00:10:53,819
meant that these runtimes need to create

00:10:51,599 --> 00:10:55,259
their own implementations for all of

00:10:53,819 --> 00:10:59,009
these functions that were in the J's

00:10:55,259 --> 00:11:02,459
glue code and this is where the problem

00:10:59,009 --> 00:11:04,019
comes in the interface provided by the

00:11:02,459 --> 00:11:05,429
J's glue code wasn't designed to be a

00:11:04,019 --> 00:11:07,979
standard or even to be a public

00:11:05,429 --> 00:11:11,699
interface at all because that wasn't the

00:11:07,979 --> 00:11:13,470
problem that was trying to solve so for

00:11:11,699 --> 00:11:15,629
example for a function that

00:11:13,470 --> 00:11:18,569
be called something like read in an API

00:11:15,629 --> 00:11:19,800
that was designed to be a public API the

00:11:18,569 --> 00:11:22,290
jeaious glue code instead uses

00:11:19,800 --> 00:11:24,750
underscore system three the first

00:11:22,290 --> 00:11:27,029
parameter which is an integer which is

00:11:24,750 --> 00:11:29,430
always the same number as what's in the

00:11:27,029 --> 00:11:33,000
name so three in this case and the

00:11:29,430 --> 00:11:35,759
second parameter VAR args is um the

00:11:33,000 --> 00:11:37,649
arguments use and you know you can tell

00:11:35,759 --> 00:11:40,050
from the name there's a variable number

00:11:37,649 --> 00:11:42,509
of them but what assembly doesn't

00:11:40,050 --> 00:11:45,990
provide a way to pass in a variable

00:11:42,509 --> 00:11:47,579
number of arguments to a function so

00:11:45,990 --> 00:11:51,089
instead the arguments are passed in via

00:11:47,579 --> 00:11:53,519
linear memory by others basically now

00:11:51,089 --> 00:11:55,079
this isn't typesafe and it's also slower

00:11:53,519 --> 00:11:59,310
than it would be if you could pass these

00:11:55,079 --> 00:12:00,660
in using registers and that was fine for

00:11:59,310 --> 00:12:03,750
in scripting that was running in the

00:12:00,660 --> 00:12:06,959
browser but now runtimes are treating

00:12:03,750 --> 00:12:08,699
this as a de-facto standard and they're

00:12:06,959 --> 00:12:11,430
implementing their own versions of this

00:12:08,699 --> 00:12:13,860
J's code so they're emulating an

00:12:11,430 --> 00:12:16,500
internal detail of an emulation layer of

00:12:13,860 --> 00:12:18,899
classics this means that they're really

00:12:16,500 --> 00:12:21,089
implementing choices like the passing in

00:12:18,899 --> 00:12:22,769
arguments as heap values that made sense

00:12:21,089 --> 00:12:24,750
based on the descriptives constraints

00:12:22,769 --> 00:12:29,310
even though those constraints don't

00:12:24,750 --> 00:12:31,230
apply in their environments if we're

00:12:29,310 --> 00:12:32,759
going to build a web assembly ecosystem

00:12:31,230 --> 00:12:35,339
that lasts for decades we need solid

00:12:32,759 --> 00:12:37,800
foundations so this means that our de

00:12:35,339 --> 00:12:40,980
facto standard can't be an emulation of

00:12:37,800 --> 00:12:44,100
an emulation but what principles should

00:12:40,980 --> 00:12:45,660
we apply there are two important

00:12:44,100 --> 00:12:49,620
principles that are baked into web

00:12:45,660 --> 00:12:50,939
assembly Portability and security we

00:12:49,620 --> 00:12:52,709
need to maintain these two key

00:12:50,939 --> 00:12:56,670
principles as we move to these outside

00:12:52,709 --> 00:12:59,009
the browser use cases as it is POSIX and

00:12:56,670 --> 00:13:01,589
UNIX is access control approach to

00:12:59,009 --> 00:13:03,180
security don't quite get us there so

00:13:01,589 --> 00:13:07,740
let's look at where those fall short and

00:13:03,180 --> 00:13:10,889
we'll start this with portability POSIX

00:13:07,740 --> 00:13:12,779
provides source code portability you can

00:13:10,889 --> 00:13:15,000
compile the same source code with

00:13:12,779 --> 00:13:17,550
different versions of Lipsy to target

00:13:15,000 --> 00:13:20,879
different machines but what assembly

00:13:17,550 --> 00:13:22,319
needs to go one step beyond this we need

00:13:20,879 --> 00:13:23,430
to be able to compile once and run

00:13:22,319 --> 00:13:26,779
across a whole bunch of different

00:13:23,430 --> 00:13:28,950
machines so we need portable binaries

00:13:26,779 --> 00:13:31,350
this kind of portability makes it much

00:13:28,950 --> 00:13:32,730
easier to distribute coats users so for

00:13:31,350 --> 00:13:33,990
example if notes native modules were

00:13:32,730 --> 00:13:36,660
written webassembly as I was mentioning

00:13:33,990 --> 00:13:38,190
before then users wouldn't need to run

00:13:36,660 --> 00:13:40,050
no chip when they install apps with

00:13:38,190 --> 00:13:42,180
native modules and developers wouldn't

00:13:40,050 --> 00:13:46,670
need to configure and distribute dozens

00:13:42,180 --> 00:13:49,290
of binaries now let's look at security

00:13:46,670 --> 00:13:51,390
when a line of code asks the operating

00:13:49,290 --> 00:13:53,100
system do some input or output the

00:13:51,390 --> 00:13:55,260
operating system needs to determine if

00:13:53,100 --> 00:13:58,500
it's safe to do what the code is asking

00:13:55,260 --> 00:14:00,450
to do now operating systems typically

00:13:58,500 --> 00:14:02,910
handle this with access control that's

00:14:00,450 --> 00:14:05,190
based on ownership and groups so for

00:14:02,910 --> 00:14:09,000
example the program might ask the OS to

00:14:05,190 --> 00:14:11,279
open a file and a user has access to a

00:14:09,000 --> 00:14:13,230
certain set of files when the user

00:14:11,279 --> 00:14:15,750
starts the program the program is

00:14:13,230 --> 00:14:17,820
running on behalf of that user so that

00:14:15,750 --> 00:14:19,200
means that if the user has access to the

00:14:17,820 --> 00:14:20,520
file either because they are the owner

00:14:19,200 --> 00:14:22,740
or because they're a group that has

00:14:20,520 --> 00:14:25,920
access to it then the program has that

00:14:22,740 --> 00:14:27,810
same access to that protects users from

00:14:25,920 --> 00:14:29,399
each other and that made a lot of sense

00:14:27,810 --> 00:14:31,230
when the early operating systems were

00:14:29,399 --> 00:14:32,190
developed because citizens were usually

00:14:31,230 --> 00:14:35,160
multi-user

00:14:32,190 --> 00:14:38,610
and administrators controlled what

00:14:35,160 --> 00:14:40,589
software was installed so the biggest

00:14:38,610 --> 00:14:42,120
threat that you had as a user was that

00:14:40,589 --> 00:14:46,649
other users were going to take a peek

00:14:42,120 --> 00:14:49,320
your files but that's change now systems

00:14:46,649 --> 00:14:51,270
now are usually single user but they're

00:14:49,320 --> 00:14:52,920
running code that pulls in lots of other

00:14:51,270 --> 00:14:55,680
third party code of unknown

00:14:52,920 --> 00:14:57,570
trustworthiness so now the biggest

00:14:55,680 --> 00:14:59,130
threat that you have is that the code

00:14:57,570 --> 00:15:02,850
that you yourself are running is going

00:14:59,130 --> 00:15:05,579
to turn against and so for example let's

00:15:02,850 --> 00:15:07,589
say that you have a library that you're

00:15:05,579 --> 00:15:09,959
using in an application and that library

00:15:07,589 --> 00:15:12,480
gets a new maintainer you know often

00:15:09,959 --> 00:15:14,160
happen with an open source that

00:15:12,480 --> 00:15:16,290
maintainer might have your interests

00:15:14,160 --> 00:15:18,779
your best interest at heart or they may

00:15:16,290 --> 00:15:21,270
be one of the bad guys and if they have

00:15:18,779 --> 00:15:23,339
access to do anything on your system for

00:15:21,270 --> 00:15:25,440
example open any of your files and send

00:15:23,339 --> 00:15:28,500
them over network then your code that

00:15:25,440 --> 00:15:30,630
code can do a lot of damage so this is

00:15:28,500 --> 00:15:34,709
why using third-party libraries that can

00:15:30,630 --> 00:15:36,510
talk directly to the distress wipe

00:15:34,709 --> 00:15:39,920
assemblies way of doing security is

00:15:36,510 --> 00:15:42,240
different web assemblies sandboxed

00:15:39,920 --> 00:15:45,300
so this means that the code can't talk

00:15:42,240 --> 00:15:47,430
directly to the operating system but

00:15:45,300 --> 00:15:50,970
then how does it do anything with the

00:15:47,430 --> 00:15:52,770
systems resources the host which maybe

00:15:50,970 --> 00:15:55,200
the browser or maybe a web assembly

00:15:52,770 --> 00:15:57,780
runtime was functions into the sandbox

00:15:55,200 --> 00:15:59,190
that the code can use and this means

00:15:57,780 --> 00:16:02,640
that the host can limit what a program

00:15:59,190 --> 00:16:04,320
to do on a program by program basis so

00:16:02,640 --> 00:16:06,390
it doesn't just let the program act on

00:16:04,320 --> 00:16:10,560
behalf of the user calling any system

00:16:06,390 --> 00:16:12,300
call with users full permissions but

00:16:10,560 --> 00:16:14,910
just having this macca not mechanism for

00:16:12,300 --> 00:16:17,250
sandbox in doesn't make a system secure

00:16:14,910 --> 00:16:19,410
in and of itself the host could still

00:16:17,250 --> 00:16:20,610
put all of the capabilities into the

00:16:19,410 --> 00:16:23,340
sandbox in which case we're no better

00:16:20,610 --> 00:16:26,040
off than we were before but at least it

00:16:23,340 --> 00:16:31,380
gives hosts the option of creating a

00:16:26,040 --> 00:16:32,580
more secure system so in any system

00:16:31,380 --> 00:16:35,540
interface we design we need to uphold

00:16:32,580 --> 00:16:37,440
these two principles from webassembly

00:16:35,540 --> 00:16:39,750
portability makes it easier to develop

00:16:37,440 --> 00:16:42,330
and distribute code and providing the

00:16:39,750 --> 00:16:45,380
tools for hosts to secure themselves and

00:16:42,330 --> 00:16:47,850
their users as an absolute must

00:16:45,380 --> 00:16:50,160
given those two key principles

00:16:47,850 --> 00:16:53,370
what should the design of a web assembly

00:16:50,160 --> 00:16:54,780
system interface look like well that's

00:16:53,370 --> 00:16:57,810
what we're going to figure out through

00:16:54,780 --> 00:17:01,740
this standardization process we do have

00:16:57,810 --> 00:17:03,660
a proposal to start with them this

00:17:01,740 --> 00:17:05,459
proposal is to create a modular set of

00:17:03,660 --> 00:17:09,089
standard library a standard interfaces

00:17:05,459 --> 00:17:11,240
and starting with standardizing the most

00:17:09,089 --> 00:17:13,579
fundamental module which is widely core

00:17:11,240 --> 00:17:16,170
so what will be in wasseypur

00:17:13,579 --> 00:17:18,480
well YC core will contain the basics

00:17:16,170 --> 00:17:20,310
that all programs need it will cover

00:17:18,480 --> 00:17:23,130
much of the same ground as POSIX

00:17:20,310 --> 00:17:25,410
including things such as files network

00:17:23,130 --> 00:17:28,140
connections clocks and random numbers

00:17:25,410 --> 00:17:30,540
and we'll take a very similar approach

00:17:28,140 --> 00:17:33,030
to POSIX for many of these things so for

00:17:30,540 --> 00:17:34,590
example we use a POSIX s file oriented

00:17:33,030 --> 00:17:36,660
approach where you have system calls

00:17:34,590 --> 00:17:39,150
such as open flows read and write and

00:17:36,660 --> 00:17:42,780
everything else basically provides

00:17:39,150 --> 00:17:45,240
augmentations on top of that but huazi

00:17:42,780 --> 00:17:48,480
core won't cover everything that POSIX

00:17:45,240 --> 00:17:52,130
does so for example the process concept

00:17:48,480 --> 00:17:53,420
doesn't map clearly on to web assembly

00:17:52,130 --> 00:17:55,220
beyond that it doesn't make sense to say

00:17:53,420 --> 00:17:58,820
that every webassembly engine needs to

00:17:55,220 --> 00:18:00,140
support process operations like fork but

00:17:58,820 --> 00:18:02,810
we do want to make it possible to

00:18:00,140 --> 00:18:05,690
standardize fork so this is where this

00:18:02,810 --> 00:18:07,220
modular approach comes in this way we

00:18:05,690 --> 00:18:09,680
can get good standardization coverage

00:18:07,220 --> 00:18:11,300
while still allowing niche platforms to

00:18:09,680 --> 00:18:15,470
use only the parts of huazi that makes

00:18:11,300 --> 00:18:18,110
sense for them so how will this be used

00:18:15,470 --> 00:18:21,470
well languages like rust will use y'see

00:18:18,110 --> 00:18:24,290
cords in their standard libraries so for

00:18:21,470 --> 00:18:26,450
example rusts open is implemented by

00:18:24,290 --> 00:18:30,200
calling what has a path open when it's

00:18:26,450 --> 00:18:31,790
compiled to web assembly for CM C++

00:18:30,200 --> 00:18:33,710
we've created a y'see sis route that

00:18:31,790 --> 00:18:36,590
implements Lipsy in terms of Y Z core

00:18:33,710 --> 00:18:38,120
functions and we expect compilers like

00:18:36,590 --> 00:18:41,390
playing to be ready to interface with

00:18:38,120 --> 00:18:44,150
the Y Z API and complete tool chains

00:18:41,390 --> 00:18:45,800
like rusty and in scripted to use Y Z as

00:18:44,150 --> 00:18:48,170
part of their system implementations and

00:18:45,800 --> 00:18:50,810
in fact rust already does have support

00:18:48,170 --> 00:18:52,850
it actually had support starting at the

00:18:50,810 --> 00:18:54,890
very beginning of huazi announcement

00:18:52,850 --> 00:18:58,220
because of the amazing work of Alex

00:18:54,890 --> 00:19:02,030
printer so how does the users code call

00:18:58,220 --> 00:19:04,670
these wagon functions the runtime that

00:19:02,030 --> 00:19:08,330
is running the code passes the Y Z core

00:19:04,670 --> 00:19:10,670
functions in as imports this gives us

00:19:08,330 --> 00:19:12,650
portability because each host can have

00:19:10,670 --> 00:19:14,660
their own implementation of YC core that

00:19:12,650 --> 00:19:17,000
is especially written for their platform

00:19:14,660 --> 00:19:19,970
so from web assembly runtimes like our

00:19:17,000 --> 00:19:24,110
awesome time and fastly loose it to note

00:19:19,970 --> 00:19:26,630
or even the browser it also gives us an

00:19:24,110 --> 00:19:29,240
boxing because the host can choose which

00:19:26,630 --> 00:19:31,160
quasi core functions pass in so which

00:19:29,240 --> 00:19:33,560
system calls to allow on the program by

00:19:31,160 --> 00:19:34,700
program basis so this preserves the

00:19:33,560 --> 00:19:37,550
security that I was talking about the

00:19:34,700 --> 00:19:40,700
floor but YC also gives us a way to

00:19:37,550 --> 00:19:42,110
extend the security even further it

00:19:40,700 --> 00:19:45,040
brings in more concepts from

00:19:42,110 --> 00:19:46,940
capabilities based security

00:19:45,040 --> 00:19:47,330
traditionally if code needs to open a

00:19:46,940 --> 00:19:50,390
file

00:19:47,330 --> 00:19:53,990
it calls open with a string which is the

00:19:50,390 --> 00:19:55,880
path name of that file and then the OS

00:19:53,990 --> 00:19:57,470
does a check to see if the code has

00:19:55,880 --> 00:20:00,620
permission based on the user who started

00:19:57,470 --> 00:20:02,480
the program with y'see if you're calling

00:20:00,620 --> 00:20:04,220
a function that needs to access a file

00:20:02,480 --> 00:20:06,440
you have to pass

00:20:04,220 --> 00:20:09,110
a file descriptor which has permissions

00:20:06,440 --> 00:20:10,519
attached to it this could be for the

00:20:09,110 --> 00:20:13,669
file itself or it could be for a

00:20:10,519 --> 00:20:15,169
directory that contains the file this

00:20:13,669 --> 00:20:19,279
way you can't have code that randomly

00:20:15,169 --> 00:20:21,379
asks to open ett password instead the

00:20:19,279 --> 00:20:23,750
code can only operate on the directories

00:20:21,379 --> 00:20:26,539
that are passed into it so this makes it

00:20:23,750 --> 00:20:28,220
possible to safely give sandbox code

00:20:26,539 --> 00:20:30,830
more access to the different system

00:20:28,220 --> 00:20:33,409
calls because the capabilities of these

00:20:30,830 --> 00:20:35,480
system calls can be limited and this

00:20:33,409 --> 00:20:37,759
happens on the module by module basis so

00:20:35,480 --> 00:20:41,509
a finer grained basis by finer grained

00:20:37,759 --> 00:20:44,389
level by default a module doesn't have

00:20:41,509 --> 00:20:46,250
any access to file descriptors but if

00:20:44,389 --> 00:20:49,129
code and one module has a file

00:20:46,250 --> 00:20:51,409
descriptor it can choose to pass it that

00:20:49,129 --> 00:20:53,899
file descriptor to a function that calls

00:20:51,409 --> 00:20:55,610
and other modules or it can create a

00:20:53,899 --> 00:20:58,879
more limited version of the file

00:20:55,610 --> 00:21:00,169
descriptor to pass to other functions so

00:20:58,879 --> 00:21:02,539
the runtime passes in the file

00:21:00,169 --> 00:21:04,490
descriptors that napkin use to the

00:21:02,539 --> 00:21:06,169
top-level code and then the file

00:21:04,490 --> 00:21:08,919
descriptors get propagated through the

00:21:06,169 --> 00:21:11,690
rest of the system on an as-needed basis

00:21:08,919 --> 00:21:13,700
this gets webassembly closer to the

00:21:11,690 --> 00:21:15,830
principle of least Authority where a

00:21:13,700 --> 00:21:19,850
module can only access the exact

00:21:15,830 --> 00:21:21,740
resources it needs to do its job and as

00:21:19,850 --> 00:21:24,230
I mentioned these concepts come from

00:21:21,740 --> 00:21:28,129
capability oriented systems like cloud

00:21:24,230 --> 00:21:29,870
EBI or capsicum now one problem with

00:21:28,129 --> 00:21:32,120
capability oriented systems is that

00:21:29,870 --> 00:21:34,610
there often is often hard to port code

00:21:32,120 --> 00:21:37,909
to those systems but we think that this

00:21:34,610 --> 00:21:41,179
problem can be solved if code already

00:21:37,909 --> 00:21:44,179
uses system calls like open at I think F

00:21:41,179 --> 00:21:48,350
open with relative file paths compiling

00:21:44,179 --> 00:21:50,179
the code will just work one case where

00:21:48,350 --> 00:21:52,820
it won't just work is if that code uses

00:21:50,179 --> 00:21:54,740
open if the code use is open and

00:21:52,820 --> 00:21:56,929
migrating to the open a style is too

00:21:54,740 --> 00:21:59,509
much upfront investment whereas he can

00:21:56,929 --> 00:22:01,639
provide an incremental solution so with

00:21:59,509 --> 00:22:03,019
a library called lip read open you can

00:22:01,639 --> 00:22:05,240
create a list of file paths that the

00:22:03,019 --> 00:22:07,340
application legitimately means access to

00:22:05,240 --> 00:22:12,350
and then you can use open but just with

00:22:07,340 --> 00:22:13,639
those paths so what's next well we think

00:22:12,350 --> 00:22:15,590
wasseypur is a good start

00:22:13,639 --> 00:22:17,820
it preserves web assemblies Portability

00:22:15,590 --> 00:22:20,190
and security providing us all

00:22:17,820 --> 00:22:21,330
nation for an ecosystem but there's

00:22:20,190 --> 00:22:24,149
still questions that we'll need to

00:22:21,330 --> 00:22:26,729
address after huazi Corps or Wildlife

00:22:24,149 --> 00:22:29,609
the core is being standardized and those

00:22:26,729 --> 00:22:33,570
questions include asynchronous IO file

00:22:29,609 --> 00:22:35,609
watching file locking and others this is

00:22:33,570 --> 00:22:37,169
just the beginning so if you have ideas

00:22:35,609 --> 00:22:41,850
for how to solve these problems

00:22:37,169 --> 00:22:43,470
please join us so I want to thank my

00:22:41,850 --> 00:22:45,119
collaborators on developing this talk

00:22:43,470 --> 00:22:48,029
Dan Goleman who's the lead developer on

00:22:45,119 --> 00:22:51,659
huasi and our webassembly runtime Bassem

00:22:48,029 --> 00:22:53,309
time til tonight right who is the

00:22:51,659 --> 00:22:55,859
manager of our developer technologies

00:22:53,309 --> 00:22:58,619
team focusing on rust and web sembly and

00:22:55,859 --> 00:23:00,989
also dance manager and luke Wagner who's

00:22:58,619 --> 00:23:03,539
one of web assemblies creators and a

00:23:00,989 --> 00:23:05,729
driving force in all things violently so

00:23:03,539 --> 00:23:20,809
thank you to all of them and thank you

00:23:05,729 --> 00:23:20,809
all for listening sessions ok I saw that

00:23:45,110 --> 00:24:05,849
[Music]

00:23:47,840 --> 00:24:10,049
there are solutions for so for example

00:24:05,849 --> 00:24:15,109
if it has something called portal that

00:24:10,049 --> 00:24:15,109
the user is accessing your location

00:24:30,470 --> 00:26:06,460
[Music]

00:24:31,590 --> 00:26:13,890
you know this wouldn't so tell me you

00:26:06,460 --> 00:26:20,470
have surplus on this as well we have a

00:26:13,890 --> 00:26:30,130
Google student last year implemented

00:26:20,470 --> 00:26:35,600
this there was web assembly processes

00:26:30,130 --> 00:26:38,300
where and you could continue

00:26:35,600 --> 00:26:40,160
use cases here this would make sense

00:26:38,300 --> 00:26:44,090
certainly wouldn't make sense for all

00:26:40,160 --> 00:26:45,530
abundance but if you want to have

00:26:44,090 --> 00:26:47,300
something that's we need that we bare

00:26:45,530 --> 00:26:49,340
metal and you could imagine that

00:26:47,300 --> 00:26:50,960
essentially doing away with the

00:26:49,340 --> 00:27:01,700
operating system and implementing the

00:26:50,960 --> 00:27:03,530
resistors calls directly there are any

00:27:01,700 --> 00:27:20,420
other questions I don't know how long we

00:27:03,530 --> 00:27:25,300
have to do questions so that's on when

00:27:20,420 --> 00:27:29,630
webassembly not a Razzie itself so

00:27:25,300 --> 00:27:36,080
there's active work on that and tools

00:27:29,630 --> 00:27:37,820
also involved in that but I think that

00:27:36,080 --> 00:27:40,760
it so you said

00:27:37,820 --> 00:27:55,010
you interested in our continuing on how

00:27:40,760 --> 00:27:56,510
valuable it is or so one of the nice

00:27:55,010 --> 00:28:00,320
things about it is that it's not

00:27:56,510 --> 00:28:02,330
actually being not the runtimes needs to

00:28:00,320 --> 00:28:04,960
support it only runtime step one two it

00:28:02,330 --> 00:28:08,630
basically allows you to put the hosts

00:28:04,960 --> 00:28:11,960
garbage collector in to integrate rather

00:28:08,630 --> 00:28:15,080
with the host garbage collection if you

00:28:11,960 --> 00:28:16,460
have a webassembly runtime that doesn't

00:28:15,080 --> 00:28:18,800
integrate with JavaScript or another

00:28:16,460 --> 00:28:22,280
language is language that has a garbage

00:28:18,800 --> 00:28:25,910
collector you don't need to implement it

00:28:22,280 --> 00:28:28,820
and there's no performance penalty at

00:28:25,910 --> 00:28:31,190
all for it so it really is an optional

00:28:28,820 --> 00:28:33,980
feature and I think it makes a lot of

00:28:31,190 --> 00:28:35,930
sense for cases like running web sembly

00:28:33,980 --> 00:28:38,690
on the web when you are inter inter

00:28:35,930 --> 00:28:41,020
operating with a linear set means the GC

00:28:38,690 --> 00:28:41,020
support

00:28:47,390 --> 00:28:53,809
so there's some you're talking about

00:28:52,460 --> 00:28:56,890
huazi whether or not we would have

00:28:53,809 --> 00:28:56,890
asynchronous system calls

00:29:01,900 --> 00:29:22,820
so Junsu in place I mean I don't know do

00:29:20,720 --> 00:29:29,840
you know if dance Tony's planning around

00:29:22,820 --> 00:29:32,600
that is so they're they're cleaning no

00:29:29,840 --> 00:29:36,559
beginnings she's lying

00:29:32,600 --> 00:29:39,770
um but one thing is very clear

00:29:36,559 --> 00:29:43,580
just having multi sweating exposed at

00:29:39,770 --> 00:29:45,470
all Sherman we than being able to spawn

00:29:43,580 --> 00:29:48,620
additional threats that would probably

00:29:45,470 --> 00:29:50,540
be a capability in itself that you would

00:29:48,620 --> 00:29:53,380
have to explicitly request and then

00:29:50,540 --> 00:29:55,490
doing things like pinning went to

00:29:53,380 --> 00:29:57,410
specific course would almost certainly

00:29:55,490 --> 00:29:59,840
be this would capability because it

00:29:57,410 --> 00:30:07,520
allows you to to things like of their

00:29:59,840 --> 00:30:11,390
timing but how we specify all of those

00:30:07,520 --> 00:30:13,820
things exactly vents we need for the

00:30:11,390 --> 00:30:18,370
subgroup of the webisode VCG

00:30:13,820 --> 00:30:18,370
to figure out was it starts as water

00:30:25,780 --> 00:30:40,700
okay oh no there's I do you specify like

00:30:38,750 --> 00:30:49,040
how do you pass them into a functioning

00:30:40,700 --> 00:30:51,679
yeah so that is kind of an open

00:30:49,040 --> 00:30:55,220
questions that you know

00:30:51,679 --> 00:30:59,630
so basically runtimes will make their

00:30:55,220 --> 00:31:01,940
own decisions about how to

00:30:59,630 --> 00:31:05,740
allow users to select what they want to

00:31:01,940 --> 00:31:08,960
do or whether or not to set defaults and

00:31:05,740 --> 00:31:13,660
we actually have an open research branch

00:31:08,960 --> 00:31:17,210
to explore this use your experience

00:31:13,660 --> 00:31:20,020
alright then I think all the speakers

00:31:17,210 --> 00:31:20,020
are sticking around

00:31:21,110 --> 00:31:28,239

YouTube URL: https://www.youtube.com/watch?v=TAHlOGNuQc4


