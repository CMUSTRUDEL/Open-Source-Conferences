Title: Rust and Tell February 2019: Jan Stępień - That Looks Oddly Familiar
Publication date: 2019-03-15
Playlist: Rust and Tell Berlin
Description: 
	A talk about "perceptual hashing" which allows us to find visual similarities between images.

Rust and Tell is a monthly event (the last Tuesday of every month) to share ideas and learn about new things about Rust.
Check out https://berline.rs/ for more.
Captions: 
	00:00:07,549 --> 00:00:12,080
good evening ladies and gentlemen

00:00:09,990 --> 00:00:14,150
here tonight we're about to talk about

00:00:12,080 --> 00:00:16,300
I have with pictures I am super

00:00:14,150 --> 00:00:19,640
responsible of pictures I take I

00:00:16,300 --> 00:00:22,670
scattered them all over my SD cards

00:00:19,640 --> 00:00:24,500
backup this cloud backup somewhere there

00:00:22,670 --> 00:00:26,380
somewhere in compressed form somewhere I

00:00:24,500 --> 00:00:32,239
have only known some selected pictures I

00:00:26,380 --> 00:00:34,250
need a way to find similar directories

00:00:32,239 --> 00:00:38,180
the places among my backups which

00:00:34,250 --> 00:00:40,070
contains similar pictures and/or in the

00:00:38,180 --> 00:00:43,070
general case given a new picture I just

00:00:40,070 --> 00:00:46,010
took I want a list of directories or

00:00:43,070 --> 00:00:49,070
files which are somewhat similar to this

00:00:46,010 --> 00:00:50,780
picture so I need to extract certain

00:00:49,070 --> 00:00:54,500
properties of the picture and put them

00:00:50,780 --> 00:00:56,330
in a database of sorts so we can start

00:00:54,500 --> 00:00:58,280
with some sort of a hashing function

00:00:56,330 --> 00:01:01,610
right which takes the data which takes

00:00:58,280 --> 00:01:04,040
the picture and transforms it into this

00:01:01,610 --> 00:01:06,909
short compact representation which I can

00:01:04,040 --> 00:01:10,159
which is more wieldy I can work with

00:01:06,909 --> 00:01:13,689
we know hashing for example from the

00:01:10,159 --> 00:01:17,960
world of cryptography right where we

00:01:13,689 --> 00:01:20,630
take say contents of our get commit and

00:01:17,960 --> 00:01:24,680
get this very nice short representation

00:01:20,630 --> 00:01:28,100
this sha-1 representation this doesn't

00:01:24,680 --> 00:01:30,260
work it doesn't work because if I make a

00:01:28,100 --> 00:01:31,880
small change in my input and the

00:01:30,260 --> 00:01:33,380
resulting hash is completely different

00:01:31,880 --> 00:01:36,170
and it's very important if I'm working

00:01:33,380 --> 00:01:38,390
with cryptography right I want to see if

00:01:36,170 --> 00:01:41,120
somebody tampered with date I'm sending

00:01:38,390 --> 00:01:43,190
over or messed something in my get

00:01:41,120 --> 00:01:45,710
history so want you to look for

00:01:43,190 --> 00:01:48,080
something else and there is a family of

00:01:45,710 --> 00:01:50,150
algorithms which answers exactly this

00:01:48,080 --> 00:01:53,360
demand they're called perceptual hashes

00:01:50,150 --> 00:01:56,870
and they correspond to how we humans

00:01:53,360 --> 00:01:59,600
percept the world small changes and the

00:01:56,870 --> 00:02:02,630
input result in small changes and the

00:01:59,600 --> 00:02:06,800
output and by similar hashes

00:02:02,630 --> 00:02:08,330
I mean hashes which differ on the

00:02:06,800 --> 00:02:14,569
minimal number of positions when

00:02:08,330 --> 00:02:16,819
represented as bit vectors one example

00:02:14,569 --> 00:02:19,040
of this family is called P hash you can

00:02:16,819 --> 00:02:21,080
just get it off the internet under some

00:02:19,040 --> 00:02:24,650
Oprah license an open-source license I

00:02:21,080 --> 00:02:26,030
think it's GPL you can then take image

00:02:24,650 --> 00:02:28,250
files for example JPEGs

00:02:26,030 --> 00:02:33,530
and P hash will translate them for you

00:02:28,250 --> 00:02:36,680
and those short 64-bit vectors P hash

00:02:33,530 --> 00:02:40,490
exposes a nice and friendly C API right

00:02:36,680 --> 00:02:41,750
given a file name and a pointer to a

00:02:40,490 --> 00:02:44,440
piece of memory where I can store the

00:02:41,750 --> 00:02:48,050
hash I will get to 0 if hashing was

00:02:44,440 --> 00:02:52,580
successful let's warm up and try to wrap

00:02:48,050 --> 00:02:56,060
this API with a bit of rust we declare

00:02:52,580 --> 00:03:00,709
an extern function PhD CT image hash and

00:02:56,060 --> 00:03:04,280
we declare its API using data types we

00:03:00,709 --> 00:03:06,500
import it from the lip secret we need to

00:03:04,280 --> 00:03:08,750
also instruct the linker that in order

00:03:06,500 --> 00:03:11,810
to link something against this external

00:03:08,750 --> 00:03:15,620
definition it needs to reach to the P

00:03:11,810 --> 00:03:17,569
hash library having this declaration in

00:03:15,620 --> 00:03:21,530
place we can now and write a simple

00:03:17,569 --> 00:03:26,810
image hash function which exposes an API

00:03:21,530 --> 00:03:29,569
more natural to rotations given us a

00:03:26,810 --> 00:03:34,040
reference to a string slice we will get

00:03:29,569 --> 00:03:36,320
an optional hash we will create a C

00:03:34,040 --> 00:03:38,150
string out two out of that reference to

00:03:36,320 --> 00:03:40,549
a string slice and then in the unsafe

00:03:38,150 --> 00:03:42,769
block we will pass the underlying memory

00:03:40,549 --> 00:03:46,150
to the C function if the function

00:03:42,769 --> 00:03:49,720
returns zero we return some hash

00:03:46,150 --> 00:03:51,380
otherwise we have nothing to return

00:03:49,720 --> 00:03:54,680
everybody with me so far

00:03:51,380 --> 00:03:58,070
looks good excellent this is enough to

00:03:54,680 --> 00:04:01,010
wrap it with a bit of rapid wave main

00:03:58,070 --> 00:04:03,440
function and expose a simple tool which

00:04:01,010 --> 00:04:05,840
given all the arguments on the command

00:04:03,440 --> 00:04:09,950
line it interprets them as names of

00:04:05,840 --> 00:04:12,290
files goes one after another and hashes

00:04:09,950 --> 00:04:14,180
all the files in case of any errors we

00:04:12,290 --> 00:04:20,750
just ignore them a report an error and

00:04:14,180 --> 00:04:23,450
move on now I've got hashes for all the

00:04:20,750 --> 00:04:25,550
files I can find on my desk but let's

00:04:23,450 --> 00:04:27,729
return to the main question how can I

00:04:25,550 --> 00:04:32,600
given all the hashes I have how can I

00:04:27,729 --> 00:04:35,930
find similar things which are somewhere

00:04:32,600 --> 00:04:39,110
on my backup drives in my database of

00:04:35,930 --> 00:04:39,770
hashes we know good algorithms for exact

00:04:39,110 --> 00:04:42,379
search

00:04:39,770 --> 00:04:43,759
right hidden hash table but we're not

00:04:42,379 --> 00:04:46,940
talking about the exact search right we

00:04:43,759 --> 00:04:50,030
want a tolerance a window of error we

00:04:46,940 --> 00:04:51,919
could use a bee tree but bee tree relies

00:04:50,030 --> 00:04:53,599
on the assumption that we have firstly

00:04:51,919 --> 00:04:55,580
most significant and then least

00:04:53,599 --> 00:04:56,840
significant bits most significant at the

00:04:55,580 --> 00:04:59,659
top of that really significant at the

00:04:56,840 --> 00:05:03,889
bottom the problem is it makes no

00:04:59,659 --> 00:05:05,840
difference and our world where the bits

00:05:03,889 --> 00:05:10,340
differ they are equally significant need

00:05:05,840 --> 00:05:12,169
something else and luckily there is a

00:05:10,340 --> 00:05:14,180
data structure from the future defined

00:05:12,169 --> 00:05:16,610
forty years ago which solves this exact

00:05:14,180 --> 00:05:21,069
problem it's called the pique tree and

00:05:16,610 --> 00:05:23,150
it's a tree which is guided by certain

00:05:21,069 --> 00:05:27,229
properties whose construction has been

00:05:23,150 --> 00:05:29,270
guided by certain invariants and it can

00:05:27,229 --> 00:05:32,630
help us answer the question of how do I

00:05:29,270 --> 00:05:34,610
get those hashes quickly let's start

00:05:32,630 --> 00:05:36,380
with the distance function our distance

00:05:34,610 --> 00:05:39,560
function expressed in terms of those

00:05:36,380 --> 00:05:42,500
extra two types is just an exclusive or

00:05:39,560 --> 00:05:46,069
of two hashes and then we just count all

00:05:42,500 --> 00:05:49,690
the bits which are set with the distance

00:05:46,069 --> 00:05:51,590
in place we for the sake of simplicity

00:05:49,690 --> 00:05:55,370
differentiate between empty and

00:05:51,590 --> 00:05:57,889
non-empty trees if the tree is non empty

00:05:55,370 --> 00:06:02,029
it has a node inside and the node looks

00:05:57,889 --> 00:06:06,409
as follows it has a single hash and a

00:06:02,029 --> 00:06:11,300
collection of children and now the

00:06:06,409 --> 00:06:15,169
invariant is that within a all the

00:06:11,300 --> 00:06:17,960
hashes we have in a single sub tree sub

00:06:15,169 --> 00:06:21,279
nodes a child of this node have exactly

00:06:17,960 --> 00:06:23,900
the same distance to the current hash

00:06:21,279 --> 00:06:26,740
it's fairly abstract I've got a picture

00:06:23,900 --> 00:06:29,779
for you we've got the following tree

00:06:26,740 --> 00:06:32,000
we've got the main node and two sub

00:06:29,779 --> 00:06:35,569
nodes which can be arbitrarily deep and

00:06:32,000 --> 00:06:38,990
the rule is all the stuff on the left is

00:06:35,569 --> 00:06:41,419
one distant from the top hash all the

00:06:38,990 --> 00:06:45,289
stuff on the right is six distant from

00:06:41,419 --> 00:06:48,440
the top hash our hashes are 64 bit long

00:06:45,289 --> 00:06:52,419
so we can have at most 64 children of a

00:06:48,440 --> 00:06:52,419
single node

00:06:53,370 --> 00:06:57,690
with the description of the data

00:06:55,690 --> 00:07:00,400
structure in place we can move on and

00:06:57,690 --> 00:07:04,420
try to insert something to such a data

00:07:00,400 --> 00:07:07,150
structure let's start with a function to

00:07:04,420 --> 00:07:09,040
create a single a singleton no it's

00:07:07,150 --> 00:07:13,960
given a hash I returned a note of that

00:07:09,040 --> 00:07:16,510
hash and no children now given a BK tree

00:07:13,960 --> 00:07:18,580
I want to insert something - it's okay

00:07:16,510 --> 00:07:21,250
mutable reference to BK tree and

00:07:18,580 --> 00:07:24,310
everything depends on the shape of the

00:07:21,250 --> 00:07:27,870
tree if it's empty I just replace myself

00:07:24,310 --> 00:07:32,350
with a non empty tree with a single hash

00:07:27,870 --> 00:07:34,750
otherwise I call insert on the node and

00:07:32,350 --> 00:07:40,870
my non empty tree and the insert on a

00:07:34,750 --> 00:07:43,270
node looks as follows if the new hash

00:07:40,870 --> 00:07:46,330
that has to be inserted is equal to the

00:07:43,270 --> 00:07:49,330
current hash undone it's there otherwise

00:07:46,330 --> 00:07:51,580
I have to calculate the distance between

00:07:49,330 --> 00:07:51,970
the hash to be inserted in the current

00:07:51,580 --> 00:07:54,940
hash

00:07:51,970 --> 00:07:56,470
- itself and then I look at look at the

00:07:54,940 --> 00:08:01,540
collection of my children and I take the

00:07:56,470 --> 00:08:06,160
child adds offset new distance if it's

00:08:01,540 --> 00:08:09,610
absent I insert a singleton node and

00:08:06,160 --> 00:08:11,290
then I recur call insert on the node

00:08:09,610 --> 00:08:12,550
I've found because this is the place

00:08:11,290 --> 00:08:13,720
which according to the principle

00:08:12,550 --> 00:08:18,180
according to which we build the tree

00:08:13,720 --> 00:08:22,180
this is where the hash must be long and

00:08:18,180 --> 00:08:25,510
this is enough to build the tree

00:08:22,180 --> 00:08:29,410
preserving our constraint let's try to

00:08:25,510 --> 00:08:33,700
find something inside given a reference

00:08:29,410 --> 00:08:35,710
to a BK tree I want to find all their

00:08:33,700 --> 00:08:38,400
hashes inside which are at most

00:08:35,710 --> 00:08:40,780
tolerance distant from the needle and

00:08:38,400 --> 00:08:44,860
get a vector of hashes for the sake of

00:08:40,780 --> 00:08:47,290
simplicity if I'm empty I return the

00:08:44,860 --> 00:08:53,280
lantee vector if I'm not empty I call

00:08:47,290 --> 00:08:53,280
find on the node passing the tolerance

00:08:53,520 --> 00:08:58,660
list I think most code I have to show

00:08:56,500 --> 00:09:01,110
for tonight no worries it won't get

00:08:58,660 --> 00:09:01,110
worse than that

00:09:01,140 --> 00:09:04,980
we've got a reference to self and a

00:09:03,930 --> 00:09:08,520
needle and intolerance

00:09:04,980 --> 00:09:10,860
we start with an accumulator and we

00:09:08,520 --> 00:09:14,670
calculate the distance between the hash

00:09:10,860 --> 00:09:18,300
to be inserted as between the current

00:09:14,670 --> 00:09:20,190
hash and the needle I am looking for if

00:09:18,300 --> 00:09:23,100
the current hash is within the

00:09:20,190 --> 00:09:26,370
acceptable tolerance then I add the

00:09:23,100 --> 00:09:30,510
current hash to the result and then I

00:09:26,370 --> 00:09:31,980
recur into all the children I have doing

00:09:30,510 --> 00:09:34,470
exactly the same thing for every single

00:09:31,980 --> 00:09:36,840
child for every single hash we can find

00:09:34,470 --> 00:09:40,190
in a child add the child to the

00:09:36,840 --> 00:09:43,320
accumulator and we can then test this

00:09:40,190 --> 00:09:46,320
implementation by starting with a

00:09:43,320 --> 00:09:49,110
mutable BK tree inserting two hashes

00:09:46,320 --> 00:09:51,090
into it and then making sure that only

00:09:49,110 --> 00:09:57,570
one of those hashes is too distant from

00:09:51,090 --> 00:10:01,470
the test - well there is a problem there

00:09:57,570 --> 00:10:02,940
is a problem because this for loop is an

00:10:01,470 --> 00:10:05,460
exhaustive search it brings me nothing

00:10:02,940 --> 00:10:09,480
right I'm still looking at every single

00:10:05,460 --> 00:10:13,620
node I have in my tree and in order to

00:10:09,480 --> 00:10:15,510
optimize this loop in order to narrow

00:10:13,620 --> 00:10:17,760
down the search and prune nodes I'm not

00:10:15,510 --> 00:10:20,330
interested in we have to look at certain

00:10:17,760 --> 00:10:22,260
properties of the distance function

00:10:20,330 --> 00:10:25,500
specifically the fact that the distance

00:10:22,260 --> 00:10:28,260
function is a metric and metric and in

00:10:25,500 --> 00:10:31,710
the mathematical sense this distance we

00:10:28,260 --> 00:10:33,540
know from the real world and it has for

00:10:31,710 --> 00:10:38,900
a function to be a metric it has to

00:10:33,540 --> 00:10:42,200
satisfy four properties first of all and

00:10:38,900 --> 00:10:45,800
metric must be non-negative

00:10:42,200 --> 00:10:48,150
secondly if a metric is negative then

00:10:45,800 --> 00:10:53,480
the distance between two things is I

00:10:48,150 --> 00:10:56,040
mean then things are the same metric is

00:10:53,480 --> 00:11:00,300
symmetric distance ay B is same as

00:10:56,040 --> 00:11:02,130
distance B a and finally that long

00:11:00,300 --> 00:11:03,960
inequality at the bottom is something

00:11:02,130 --> 00:11:06,690
you know from the real world and it's

00:11:03,960 --> 00:11:11,790
called the triangle inequality the

00:11:06,690 --> 00:11:13,620
direct way cannot be longer than a way

00:11:11,790 --> 00:11:18,990
through

00:11:13,620 --> 00:11:26,190
a dieter to be and this is the most

00:11:18,990 --> 00:11:30,170
relevant property for our bigotry if we

00:11:26,190 --> 00:11:34,830
apply the triangle inequality to a

00:11:30,170 --> 00:11:38,220
needle we're looking for in our tree we

00:11:34,830 --> 00:11:41,870
can take this this inequality in term in

00:11:38,220 --> 00:11:45,960
terms of distances between those hashes

00:11:41,870 --> 00:11:50,100
the hash in the current node the needle

00:11:45,960 --> 00:11:51,750
and all the nodes in a certain child

00:11:50,100 --> 00:11:55,050
node because they're guaranteed to have

00:11:51,750 --> 00:11:56,490
the same distance and now if we apply

00:11:55,050 --> 00:11:57,960
this inequality I'm not going to bore

00:11:56,490 --> 00:12:02,190
you with the math but if we apply this

00:11:57,960 --> 00:12:06,360
inequality to two edges of this triangle

00:12:02,190 --> 00:12:11,010
and play around with the math we end up

00:12:06,360 --> 00:12:16,290
with a limit with a constraint for the

00:12:11,010 --> 00:12:18,240
distance the distance between hashes in

00:12:16,290 --> 00:12:19,800
the child node and the current hash must

00:12:18,240 --> 00:12:23,120
belong to a certain interval or

00:12:19,800 --> 00:12:25,650
expressed graphically we have a needle

00:12:23,120 --> 00:12:29,070
distance then distance between the

00:12:25,650 --> 00:12:34,610
current hash and the needle and give or

00:12:29,070 --> 00:12:41,250
take tolerance all of those all of the

00:12:34,610 --> 00:12:48,270
child nodes must fall into this interval

00:12:41,250 --> 00:12:51,630
and we can now apply this property to

00:12:48,270 --> 00:12:53,460
the for loop we have here everything

00:12:51,630 --> 00:12:55,710
above the for loop will remain the same

00:12:53,460 --> 00:12:58,440
I'm going to modify the for loop itself

00:12:55,710 --> 00:12:59,730
the nested for loop will stay the same

00:12:58,440 --> 00:13:07,290
but I will wrap it with an if statement

00:12:59,730 --> 00:13:13,110
take a look we call the inner for loop

00:13:07,290 --> 00:13:16,310
only if the distance to the to all the

00:13:13,110 --> 00:13:21,709
children in the sub node satisfies that

00:13:16,310 --> 00:13:25,830
criterion and as we saw two times before

00:13:21,709 --> 00:13:27,709
the narrower our margin of error our

00:13:25,830 --> 00:13:32,759
tolerance argument

00:13:27,709 --> 00:13:38,730
the more nodes we will prune during the

00:13:32,759 --> 00:13:41,730
search allowing us to save time and

00:13:38,730 --> 00:13:44,009
that's it I'm more than happy to grab

00:13:41,730 --> 00:13:45,480
that grab a pen and the whiteboard in

00:13:44,009 --> 00:13:49,019
that room and go through the math with

00:13:45,480 --> 00:13:50,459
you after the talk but for now I'm the

00:13:49,019 --> 00:13:53,069
happiest person because this works and

00:13:50,459 --> 00:13:55,939
it allows me to quickly find pictures

00:13:53,069 --> 00:13:58,889
and in the database

00:13:55,939 --> 00:14:02,129
I've built using this tool for example

00:13:58,889 --> 00:14:03,839
those two pictures which clearly

00:14:02,129 --> 00:14:07,699
indicate that my hands just shake when I

00:14:03,839 --> 00:14:09,779
take pictures are ten bits apart I think

00:14:07,699 --> 00:14:13,019
so if I give it to learnings of ten I

00:14:09,779 --> 00:14:15,749
get those two but funnily enough those

00:14:13,019 --> 00:14:18,209
two which I took three years and three

00:14:15,749 --> 00:14:20,549
thousand kilometers apart are also ten

00:14:18,209 --> 00:14:22,589
distant according to the P hash metric

00:14:20,549 --> 00:14:25,410
but the cool thing is if I'm not happy

00:14:22,589 --> 00:14:27,959
of results BK tree seems the same I just

00:14:25,410 --> 00:14:30,779
need a different hashing algorithm and

00:14:27,959 --> 00:14:37,350
there is a variety of them to choose

00:14:30,779 --> 00:14:40,559
from okay um ladies and gentleman three

00:14:37,350 --> 00:14:42,559
things firstly perceptual hashes are

00:14:40,559 --> 00:14:48,809
really powerful technique to summarize

00:14:42,559 --> 00:14:52,529
media content secondly if we have a big

00:14:48,809 --> 00:14:55,139
high tree we can very quickly search

00:14:52,529 --> 00:14:57,869
through those metric spaces of our

00:14:55,139 --> 00:15:00,269
perceptual hashes and thirdly a call to

00:14:57,869 --> 00:15:02,699
action if you think that big a tree

00:15:00,269 --> 00:15:04,439
makes sense and you know how to publish

00:15:02,699 --> 00:15:07,889
crates let me know because I have no

00:15:04,439 --> 00:15:09,970
idea how to publish this is Olaf gods

00:15:07,889 --> 00:15:16,529
thank you very much for your patience

00:15:09,970 --> 00:15:16,529
[Applause]

00:15:21,139 --> 00:15:23,199

YouTube URL: https://www.youtube.com/watch?v=07Djry6jX58


