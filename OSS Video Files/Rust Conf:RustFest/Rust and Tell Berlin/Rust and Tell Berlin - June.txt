Title: Rust and Tell Berlin - June
Publication date: 2020-07-27
Playlist: Rust and Tell Berlin
Description: 
	“Rust and Tell“ is a monthly event to share ideas, and learn about new things in and about Rust. Meet fellow Rustaceans, share your learnings, get motivated and inspired.


https://berline.rs/2020/06/30/rust-and-tell.html

#1: 00:11:00 - Rusty Beads by Maxim Zaks
#2: 00:47:26 - Transit Radar by Mike Bush
Captions: 
	00:01:33,579 --> 00:01:39,970
has the shun contact to do

00:01:36,240 --> 00:01:39,970
[Music]

00:01:45,060 --> 00:01:56,090
you're muted I see him online now I

00:01:52,470 --> 00:01:56,090
already started a stream

00:02:01,400 --> 00:02:03,460
you

00:02:04,300 --> 00:02:06,360
you

00:02:06,880 --> 00:02:14,500
but I assume evil people join so should

00:02:11,630 --> 00:02:14,500
we let people in

00:02:17,450 --> 00:02:20,450
yes

00:02:45,720 --> 00:02:47,780
you

00:02:50,140 --> 00:02:52,200
you

00:03:04,220 --> 00:03:10,370
okay the room is still filling up we are

00:03:07,070 --> 00:03:13,240
waiting two more minutes until everyone

00:03:10,370 --> 00:03:13,240
had a chance

00:03:19,130 --> 00:03:21,190
you

00:04:21,959 --> 00:04:32,690
okay I guess we can we can start grind

00:04:27,479 --> 00:04:32,690
you wanna share your screen sure thing

00:04:39,889 --> 00:04:46,590
all right hopefully everybody can see my

00:04:43,199 --> 00:04:51,300
screen thanks for joining everybody this

00:04:46,590 --> 00:04:53,850
is Russ intel I want to welcome

00:04:51,300 --> 00:04:55,680
everybody from far and wide whether

00:04:53,850 --> 00:04:58,220
you're joining from Berlin or from

00:04:55,680 --> 00:05:00,810
somewhere else in the world welcome

00:04:58,220 --> 00:05:03,900
first a little bit about who we the

00:05:00,810 --> 00:05:05,699
organizers are I'm Ryan Levesque you can

00:05:03,900 --> 00:05:09,539
find me on twitter at ryan underscore

00:05:05,699 --> 00:05:13,289
Levesque and I work in restful time I

00:05:09,539 --> 00:05:15,690
work at Microsoft doing rest things let

00:05:13,289 --> 00:05:17,190
me know if you're interested in learning

00:05:15,690 --> 00:05:22,860
more about what we're doing with rust

00:05:17,190 --> 00:05:24,780
and my co-organizer is pasty-ass think

00:05:22,860 --> 00:05:27,120
groovin hi thank you for the

00:05:24,780 --> 00:05:31,020
introduction I worked in rust and full

00:05:27,120 --> 00:05:33,990
time for a year now not so much anymore

00:05:31,020 --> 00:05:37,650
I'm currently about to ride a rust book

00:05:33,990 --> 00:05:39,870
a rust web programming book so if you're

00:05:37,650 --> 00:05:42,479
interested in these types of things feel

00:05:39,870 --> 00:05:44,610
free to get in touch if you want to have

00:05:42,479 --> 00:05:46,169
a preview if you have any questions I

00:05:44,610 --> 00:05:50,930
would be happy to get some early

00:05:46,169 --> 00:05:53,940
feedback and yeah I'm happy to have you

00:05:50,930 --> 00:05:55,349
so a little bit about the concept for

00:05:53,940 --> 00:05:58,229
this meetup for those who are joining

00:05:55,349 --> 00:06:00,990
for the very first time rust Intel is

00:05:58,229 --> 00:06:04,139
really about sharing struggles ideas and

00:06:00,990 --> 00:06:06,990
hacks that you might have done or are

00:06:04,139 --> 00:06:09,750
doing and rust and really this is from

00:06:06,990 --> 00:06:12,120
beginner to expert so whether the

00:06:09,750 --> 00:06:14,430
project that you're working on is hello

00:06:12,120 --> 00:06:15,960
world and you've just learned rust or

00:06:14,430 --> 00:06:19,380
learning programming for the very first

00:06:15,960 --> 00:06:23,690
time or you've been working on rust for

00:06:19,380 --> 00:06:26,190
the past 10 years this space is for you

00:06:23,690 --> 00:06:29,780
and for us as a community to come

00:06:26,190 --> 00:06:29,780
together to learn and to grow

00:06:31,470 --> 00:06:37,800
and we also take our and code of conduct

00:06:34,920 --> 00:06:40,650
very seriously we follow even if this

00:06:37,800 --> 00:06:43,200
meet up now is universal and global and

00:06:40,650 --> 00:06:44,880
we follow the berlin code of contact and

00:06:43,200 --> 00:06:45,450
you can check it out on berlin code of

00:06:44,880 --> 00:06:49,520
conduct

00:06:45,450 --> 00:06:52,620
Dork and if you think that somebody

00:06:49,520 --> 00:06:54,740
violated the code of conduct if you feel

00:06:52,620 --> 00:06:57,570
I'm threatened or not welcomed here

00:06:54,740 --> 00:07:01,020
please I'm a feel free to reporters i'ma

00:06:57,570 --> 00:07:05,460
privately we have twitter emails

00:07:01,020 --> 00:07:09,240
LinkedIn Facebook probably just feel

00:07:05,460 --> 00:07:10,800
free to get in touch and yeah to report

00:07:09,240 --> 00:07:13,250
and we take those matters very very

00:07:10,800 --> 00:07:13,250
seriously

00:07:15,080 --> 00:07:22,350
so a little bit about our online

00:07:17,880 --> 00:07:25,560
continuing experiment we have in the

00:07:22,350 --> 00:07:28,440
past done this meetup in person but ever

00:07:25,560 --> 00:07:31,800
since a certain world event has occurred

00:07:28,440 --> 00:07:36,330
we are now doing it online for the sable

00:07:31,800 --> 00:07:38,900
future this involves both zoom and zoom

00:07:36,330 --> 00:07:41,460
chat as well as a YouTube livestream

00:07:38,900 --> 00:07:43,500
we're going to have zoom breakout rooms

00:07:41,460 --> 00:07:46,669
as well so to hopefully give a little

00:07:43,500 --> 00:07:50,430
bit of the in-person meetup experience

00:07:46,669 --> 00:07:52,140
if you want to you're not obligated to

00:07:50,430 --> 00:07:54,450
but if you would like to we will break

00:07:52,140 --> 00:07:56,280
you out into two different rooms where

00:07:54,450 --> 00:07:58,530
you can get to know fellow attendees

00:07:56,280 --> 00:08:01,560
talk about the talks talk about whatever

00:07:58,530 --> 00:08:04,320
you choose to we also have a matrix chat

00:08:01,560 --> 00:08:07,940
so you can find the instructions for

00:08:04,320 --> 00:08:11,790
joining that inside of the meetup org

00:08:07,940 --> 00:08:14,130
instructions for the Meetup and please

00:08:11,790 --> 00:08:17,220
feel free to at any time in any of the

00:08:14,130 --> 00:08:20,220
chats type your questions and we'll make

00:08:17,220 --> 00:08:22,919
sure to get those questions to the

00:08:20,220 --> 00:08:30,180
speakers as they are at the end of their

00:08:22,919 --> 00:08:32,250
talks um go ahead Bastion know you do

00:08:30,180 --> 00:08:36,870
this yeah this is yeah this is Maura

00:08:32,250 --> 00:08:40,800
this is my part really we are always in

00:08:36,870 --> 00:08:43,260
continually looking for new speakers and

00:08:40,800 --> 00:08:44,420
really what that means is that we want

00:08:43,260 --> 00:08:47,120
you

00:08:44,420 --> 00:08:49,279
and yes that means you it doesn't matter

00:08:47,120 --> 00:08:52,160
if you think your idea is not very good

00:08:49,279 --> 00:08:55,639
trust us it is we're happy to work with

00:08:52,160 --> 00:08:57,260
you on your talk just let us know if you

00:08:55,639 --> 00:09:00,100
have anything that you might be

00:08:57,260 --> 00:09:03,170
interested in telling anybody else about

00:09:00,100 --> 00:09:06,050
and we will help you get your your talk

00:09:03,170 --> 00:09:09,500
ready to go for one of our next meet ups

00:09:06,050 --> 00:09:12,110
please reach out to us and we will put

00:09:09,500 --> 00:09:19,430
you down as a speaker for one of our

00:09:12,110 --> 00:09:23,889
future meetups and the shout out to our

00:09:19,430 --> 00:09:28,160
M co-sponsor co-host which can't be here

00:09:23,889 --> 00:09:31,130
today but young Eric M helped us in the

00:09:28,160 --> 00:09:33,350
past them to set up the whole thing to

00:09:31,130 --> 00:09:35,269
go and he guided us and through the

00:09:33,350 --> 00:09:38,269
whole I'm going from offline to online

00:09:35,269 --> 00:09:44,839
so thank you very much it wouldn't be

00:09:38,269 --> 00:09:47,690
possible without him and also a little M

00:09:44,839 --> 00:09:51,140
shout out to an online conference in

00:09:47,690 --> 00:09:54,589
Poland which is called the rusty days it

00:09:51,140 --> 00:09:59,120
will happen from the 27th of July until

00:09:54,589 --> 00:10:00,949
the 2nd of August it's am 7 days 7 talks

00:09:59,120 --> 00:10:04,339
and the hackathon during the weekend

00:10:00,949 --> 00:10:06,079
it's online and free for everyone I

00:10:04,339 --> 00:10:09,140
think the call of papers is already

00:10:06,079 --> 00:10:11,769
closed so they have enough proposal so

00:10:09,140 --> 00:10:14,540
it's probably gonna be a fun conference

00:10:11,769 --> 00:10:18,339
feel free to hang out there and go to

00:10:14,540 --> 00:10:18,339
the conference and talk about rust

00:10:20,019 --> 00:10:26,390
alright so we have three talks today the

00:10:23,990 --> 00:10:28,430
first one by Maxime will be on rusty

00:10:26,390 --> 00:10:30,620
beads so that will be interesting to

00:10:28,430 --> 00:10:34,250
learn what that is then the next one by

00:10:30,620 --> 00:10:36,860
Mike on transit radar and the last one

00:10:34,250 --> 00:10:39,140
will be by Zi Shan who will be catching

00:10:36,860 --> 00:10:42,199
us up on on Zee bus which we've heard

00:10:39,140 --> 00:10:44,630
about in the past at unrest Intel and

00:10:42,199 --> 00:10:50,380
we'll learn more about the progress of

00:10:44,630 --> 00:10:55,130
that project so without further ado

00:10:50,380 --> 00:10:57,570
Maxime I think you are up yep thank you

00:10:55,130 --> 00:11:01,880
very much I will

00:10:57,570 --> 00:11:01,880
and I will switch to my screen share a

00:11:02,029 --> 00:11:07,410
screen play can you see your

00:11:04,620 --> 00:11:09,480
presentation in full-screen no yes

00:11:07,410 --> 00:11:12,329
yeah probably you can okay great so

00:11:09,480 --> 00:11:15,180
right so my name is Maxine you can find

00:11:12,329 --> 00:11:17,069
me on github at anzacs

00:11:15,180 --> 00:11:20,550
and i would like to talk about a product

00:11:17,069 --> 00:11:26,060
of mine which I was building in it

00:11:20,550 --> 00:11:30,750
it's called rusty beads it's a simple

00:11:26,060 --> 00:11:35,040
binary data serialization format and the

00:11:30,750 --> 00:11:38,130
question is why why did I do this and

00:11:35,040 --> 00:11:41,910
generally first of all for sports so I

00:11:38,130 --> 00:11:44,579
don't use it in production I use our

00:11:41,910 --> 00:11:47,399
different that is binary data

00:11:44,579 --> 00:11:53,399
serialization formats in production I'm

00:11:47,399 --> 00:11:57,889
also a committed to flatbuffers project

00:11:53,399 --> 00:12:01,259
by Google and I have some experience in

00:11:57,889 --> 00:12:06,149
porting different detalization formats

00:12:01,259 --> 00:12:09,180
so at some point I decided why not

00:12:06,149 --> 00:12:11,370
invent your own and then implement in a

00:12:09,180 --> 00:12:14,670
language which you like and this is

00:12:11,370 --> 00:12:20,040
basically rust was second reason why

00:12:14,670 --> 00:12:23,250
I've built rest bits is simplicity if

00:12:20,040 --> 00:12:26,399
you have used some binary situation

00:12:23,250 --> 00:12:31,380
formats they are normally kind of trying

00:12:26,399 --> 00:12:34,949
to solve a very big problem so you have

00:12:31,380 --> 00:12:37,980
some kind of object tree which needs to

00:12:34,949 --> 00:12:42,660
be civilized but actually I haven't

00:12:37,980 --> 00:12:47,189
found any sedation formats which just

00:12:42,660 --> 00:12:49,050
does citizen of sequence of values just

00:12:47,189 --> 00:12:51,089
sequence of values so for example I have

00:12:49,050 --> 00:12:54,449
a sequence of strings and I would like

00:12:51,089 --> 00:12:56,130
to serialize them now the complex object

00:12:54,449 --> 00:12:59,310
3 and so on and so forth just a sequence

00:12:56,130 --> 00:13:04,800
or a sequence of numbers and so on and

00:12:59,310 --> 00:13:07,649
so forth so with beads I'm focusing on

00:13:04,800 --> 00:13:11,080
the simple problem just being able to

00:13:07,649 --> 00:13:15,580
serialize a sequence of something

00:13:11,080 --> 00:13:19,029
and for this I have three type of beats

00:13:15,580 --> 00:13:25,149
so I call this kind of sequences beats

00:13:19,029 --> 00:13:27,880
so it's I was inspired by a video set

00:13:25,149 --> 00:13:29,860
where you have like small things and

00:13:27,880 --> 00:13:33,100
connected together and for me every

00:13:29,860 --> 00:13:38,140
value is one beat you know so here I

00:13:33,100 --> 00:13:39,130
have three options I have fixed size big

00:13:38,140 --> 00:13:41,290
bits

00:13:39,130 --> 00:13:44,260
I have index speed and I have typed

00:13:41,290 --> 00:13:49,269
beats so let's start with fixed size

00:13:44,260 --> 00:13:53,320
beats and I think a unit tail test tells

00:13:49,269 --> 00:13:56,620
more than 300 slides so I will just

00:13:53,320 --> 00:13:59,500
start with with a unit test and walk you

00:13:56,620 --> 00:14:04,420
through what it does and explain as well

00:13:59,500 --> 00:14:06,279
what precipitation contest so in the

00:14:04,420 --> 00:14:10,149
beginning of this unit test I am

00:14:06,279 --> 00:14:12,810
creating a builder and I say I create a

00:14:10,149 --> 00:14:16,510
fixed sized bits build up or even

00:14:12,810 --> 00:14:21,250
constant free it means that every name

00:14:16,510 --> 00:14:25,600
says it is a fixed fixed size beads so

00:14:21,250 --> 00:14:29,529
every bead is of fixed size size for me

00:14:25,600 --> 00:14:34,390
is I'm sorry format size for me is the

00:14:29,529 --> 00:14:38,170
number of bytes so I can push slice

00:14:34,390 --> 00:14:44,529
which have three bytes in it so you can

00:14:38,170 --> 00:14:47,850
see here I'm pushing free sorry for free

00:14:44,529 --> 00:14:52,440
byte slices then I can encode it and

00:14:47,850 --> 00:14:56,470
then I see I have this nice buffer but

00:14:52,440 --> 00:14:59,240
buffets itself is very simple so the

00:14:56,470 --> 00:15:06,890
first byte is

00:14:59,240 --> 00:15:10,370
number of the size of six beads and then

00:15:06,890 --> 00:15:14,120
you see I'm just concatenating all the

00:15:10,370 --> 00:15:17,270
slices to each other in order to read

00:15:14,120 --> 00:15:21,160
this I have a different struct which I

00:15:17,270 --> 00:15:25,600
called a fixed size bead and then

00:15:21,160 --> 00:15:29,420
instantiating it just with a borrowed

00:15:25,600 --> 00:15:32,150
Bubba so quick slice and important same

00:15:29,420 --> 00:15:35,560
with beads what was important for me is

00:15:32,150 --> 00:15:39,020
basically that everything is a zero copy

00:15:35,560 --> 00:15:42,650
abstraction so when I'm instantiate in

00:15:39,020 --> 00:15:46,340
this thing I'm really not doing much I'm

00:15:42,650 --> 00:15:49,850
just basically borrowing a splice and

00:15:46,340 --> 00:15:52,910
this is basically it then I have this

00:15:49,850 --> 00:15:55,250
function length because it's a sequence

00:15:52,910 --> 00:15:57,640
I would like to know how long is the

00:15:55,250 --> 00:16:01,820
sequence and I'm directly tells me for

00:15:57,640 --> 00:16:06,740
how does the do it well internally I

00:16:01,820 --> 00:16:13,160
know that my bead is free bytes long and

00:16:06,740 --> 00:16:18,530
I know that my data is 12 bytes own so

00:16:13,160 --> 00:16:22,010
12 divided by 3 is 4 very simple you can

00:16:18,530 --> 00:16:24,890
directly basically concatenate slices

00:16:22,010 --> 00:16:31,300
together and have something and then you

00:16:24,890 --> 00:16:36,560
can also directly index into the bead if

00:16:31,300 --> 00:16:39,890
itself saying give me a bead on index 0

00:16:36,560 --> 00:16:42,710
1 2 & 3 and as you can see like actually

00:16:39,890 --> 00:16:46,520
here I do a copy but it's not necessary

00:16:42,710 --> 00:16:50,000
what I get here is a slice and I would

00:16:46,520 --> 00:16:53,450
like to convert it into a vector just to

00:16:50,000 --> 00:16:55,760
have a nice assertion actually ok so

00:16:53,450 --> 00:16:59,300
this is kind of interesting but it's

00:16:55,760 --> 00:17:04,370
also kind of limiting normally I don't

00:16:59,300 --> 00:17:07,640
have like fixed sized slices see I would

00:17:04,370 --> 00:17:11,240
like to put somewhere in order to

00:17:07,640 --> 00:17:13,000
serialize them right so but one idea on

00:17:11,240 --> 00:17:20,030
this idea I can do something

00:17:13,000 --> 00:17:22,400
Krita let's say nice abstraction so for

00:17:20,030 --> 00:17:25,430
this abstractions I create a different

00:17:22,400 --> 00:17:27,890
builder and I call that fixed size beats

00:17:25,430 --> 00:17:30,410
incremental you int builder it's a

00:17:27,890 --> 00:17:33,380
mouthful sorry but what it actually can

00:17:30,410 --> 00:17:36,710
do here now I can push you ends so

00:17:33,380 --> 00:17:43,480
unsigned integer values and the type is

00:17:36,710 --> 00:17:46,850
defined as you 128 so as big unsigned in

00:17:43,480 --> 00:17:52,310
number as you wish while I'm pushing

00:17:46,850 --> 00:17:56,450
them internally I'm actually checking

00:17:52,310 --> 00:18:01,730
which integer is the biggest one so in

00:17:56,450 --> 00:18:04,100
this case I push one 220 205 205 is the

00:18:01,730 --> 00:18:08,390
biggest one and when I can directly

00:18:04,100 --> 00:18:12,770
encode it as a fixed size bead and the

00:18:08,390 --> 00:18:15,680
result will be as every number can be

00:18:12,770 --> 00:18:18,160
represented in one bite then we say like

00:18:15,680 --> 00:18:20,690
Oh cable sizes one and then we just see

00:18:18,160 --> 00:18:23,930
one oops sorry

00:18:20,690 --> 00:18:27,950
one two twenty two hundred and five it's

00:18:23,930 --> 00:18:30,490
so good and like I can read the bits

00:18:27,950 --> 00:18:32,780
back the same way as I did before

00:18:30,490 --> 00:18:34,460
because basically the binary

00:18:32,780 --> 00:18:37,220
representation is the same I just

00:18:34,460 --> 00:18:40,670
created a different builder to build a

00:18:37,220 --> 00:18:43,900
little bit to serialize different data

00:18:40,670 --> 00:18:48,110
but before hundred states were saying

00:18:43,900 --> 00:18:50,600
alright but this is already interesting

00:18:48,110 --> 00:18:55,910
but it's not very end of a test so we

00:18:50,600 --> 00:19:01,030
have a page to where I also push an oven

00:18:55,910 --> 00:19:06,980
number into into a builder and it's 340

00:19:01,030 --> 00:19:09,370
now 340 can't be seated in one bite it

00:19:06,980 --> 00:19:13,010
has to be represented in two bytes and

00:19:09,370 --> 00:19:16,460
as you can see when I encode this buffer

00:19:13,010 --> 00:19:20,780
and code this builder into this buffer

00:19:16,460 --> 00:19:25,280
when I see that the size is 2 of each

00:19:20,780 --> 00:19:26,419
bead and now I also see the number

00:19:25,280 --> 00:19:29,450
representation in two

00:19:26,419 --> 00:19:35,739
whites and it's in little-endian

00:19:29,450 --> 00:19:40,460
representation so 1 is 1 0 2 is 2 0 20s

00:19:35,739 --> 00:19:47,149
2002 hundred five is 2005 zero and 340

00:19:40,460 --> 00:19:53,539
is 84 and 1 so basically now I can go so

00:19:47,149 --> 00:19:57,769
if you have for example is trimming and

00:19:53,539 --> 00:20:01,669
so for example in embedded system you

00:19:57,769 --> 00:20:04,100
have some kind of sensor which gets some

00:20:01,669 --> 00:20:07,129
kind of a values you could use beads to

00:20:04,100 --> 00:20:09,700
actually just concatenate and uncreate a

00:20:07,129 --> 00:20:15,590
binary stream to serialize store

00:20:09,700 --> 00:20:18,259
sandoval over wire and ok let's switch

00:20:15,590 --> 00:20:21,470
to ver index beads this is the second

00:20:18,259 --> 00:20:24,049
type of beads that I have in this

00:20:21,470 --> 00:20:26,980
library and we'll come back to fixed

00:20:24,049 --> 00:20:33,109
size beads later alright so first of all

00:20:26,980 --> 00:20:36,619
what does index beads solve what kind of

00:20:33,109 --> 00:20:40,309
a problem with fixed sized beads my

00:20:36,619 --> 00:20:43,100
slices can be only of a fixed size of a

00:20:40,309 --> 00:20:44,989
fixed size right but what if I would

00:20:43,100 --> 00:20:48,769
like to I know I have like different

00:20:44,989 --> 00:20:52,840
sized things for example strings strings

00:20:48,769 --> 00:20:56,539
are normally have different lengths and

00:20:52,840 --> 00:21:00,159
what can I do there so with index beats

00:20:56,539 --> 00:21:03,919
what I can do is again I can push slices

00:21:00,159 --> 00:21:06,710
but now it doesn't I don't provide the

00:21:03,919 --> 00:21:12,019
size from your beginning I just push

00:21:06,710 --> 00:21:15,519
different slices and then I have I have

00:21:12,019 --> 00:21:19,820
a possibility to read my beads out and

00:21:15,519 --> 00:21:25,580
civil length as well and then also

00:21:19,820 --> 00:21:28,730
directly index and get exactly of size

00:21:25,580 --> 00:21:30,340
of the slaves so exactly the bytes which

00:21:28,730 --> 00:21:34,389
I see realized

00:21:30,340 --> 00:21:38,960
all right so how does it work internally

00:21:34,389 --> 00:21:40,280
so kind of how is sausage made right so

00:21:38,960 --> 00:21:43,400
in a way

00:21:40,280 --> 00:21:46,250
here we say again we initially

00:21:43,400 --> 00:21:49,070
initialized by index bits builder we

00:21:46,250 --> 00:21:51,380
push one two three four and then we just

00:21:49,070 --> 00:21:56,210
directly encode it and we see here now

00:21:51,380 --> 00:21:59,660
we see this is one two three four and we

00:21:56,210 --> 00:22:04,250
see another two bytes which are kind of

00:21:59,660 --> 00:22:08,570
like a magic header which tells the

00:22:04,250 --> 00:22:15,770
reader how to read the stream if I would

00:22:08,570 --> 00:22:20,720
push another slice this one with eleven

00:22:15,770 --> 00:22:23,240
bytes then this is my result which I get

00:22:20,720 --> 00:22:26,330
so you can see here again this is the

00:22:23,240 --> 00:22:29,660
first slice this is the second slice and

00:22:26,330 --> 00:22:33,440
now I see here it's four and fifteen and

00:22:29,660 --> 00:22:36,920
when I have here an album magic number

00:22:33,440 --> 00:22:41,780
which I will talk about in a second

00:22:36,920 --> 00:22:43,430
basically regarding foreign hand 15 what

00:22:41,780 --> 00:22:47,890
I'm doing here is basically I'm saying

00:22:43,430 --> 00:22:52,430
this is well when I'm adding the first

00:22:47,890 --> 00:22:57,800
sequence it's off link for so I say like

00:22:52,430 --> 00:23:02,480
okay first sequence and @pytfall when I

00:22:57,800 --> 00:23:07,400
add another sequence of length 11 the

00:23:02,480 --> 00:23:12,980
second sequence ends at byte 15 this is

00:23:07,400 --> 00:23:19,430
how I later in the Builder can read the

00:23:12,980 --> 00:23:22,820
slices with zero copy and directly for

00:23:19,430 --> 00:23:26,090
comparisons we have this fixed size

00:23:22,820 --> 00:23:32,210
beads which structured very simply like

00:23:26,090 --> 00:23:36,440
the first let's call it sequence of

00:23:32,210 --> 00:23:42,290
bytes represents for element size so how

00:23:36,440 --> 00:23:46,250
big are my beads right and then we have

00:23:42,290 --> 00:23:49,030
like multiple beads which we add to the

00:23:46,250 --> 00:23:52,670
sequence by pushing them to the Billa

00:23:49,030 --> 00:23:53,590
with an index bits we have slightly more

00:23:52,670 --> 00:23:54,970
complex

00:23:53,590 --> 00:24:00,340
shall we say like okay we have this

00:23:54,970 --> 00:24:07,560
header which is an element count word

00:24:00,340 --> 00:24:07,560
with offset size in bytes and here is a

00:24:08,790 --> 00:24:15,480
small snippet which actually kind of

00:24:11,320 --> 00:24:18,460
like represents how these things work so

00:24:15,480 --> 00:24:22,600
builders contains all the elements which

00:24:18,460 --> 00:24:26,640
we pushed so all slices which we push so

00:24:22,600 --> 00:24:28,990
we were this represents one number of

00:24:26,640 --> 00:24:32,440
elements which we added to the sequence

00:24:28,990 --> 00:24:35,890
and we shifted by free and when we all

00:24:32,440 --> 00:24:40,870
it with a bite spell index entry minus 1

00:24:35,890 --> 00:24:45,760
so bytes by a index entry as I explained

00:24:40,870 --> 00:24:51,400
to you before in here I need to store at

00:24:45,760 --> 00:24:53,200
which byte does the element end and the

00:24:51,400 --> 00:24:56,080
problem is in the beginning it will be

00:24:53,200 --> 00:24:58,390
just one bite but it could be that our

00:24:56,080 --> 00:25:01,690
sequence grows and goes into megabytes

00:24:58,390 --> 00:25:11,640
and then we would need more bytes to

00:25:01,690 --> 00:25:11,640
represent this sequence and value so

00:25:11,880 --> 00:25:18,160
before that I'm computing how many bytes

00:25:15,760 --> 00:25:21,340
I would need to represent its offset

00:25:18,160 --> 00:25:23,260
value and then I am kind of like

00:25:21,340 --> 00:25:26,800
combining it together with the length

00:25:23,260 --> 00:25:33,010
itself and therefore it is possible for

00:25:26,800 --> 00:25:35,170
me just to again without zero copy to

00:25:33,010 --> 00:25:41,110
index into values and read stuff

00:25:35,170 --> 00:25:43,380
directly from the buffer right last but

00:25:41,110 --> 00:25:47,560
not least what type beads this is

00:25:43,380 --> 00:25:49,630
sequence where we store values and the

00:25:47,560 --> 00:25:53,500
type information before they had in

00:25:49,630 --> 00:25:57,270
perform at we just said like ok we stop

00:25:53,500 --> 00:26:00,700
storing the values and for us it just

00:25:57,270 --> 00:26:02,650
slices so it's just some kind of a bytes

00:26:00,700 --> 00:26:04,390
sometimes it's free byte sentences why I

00:26:02,650 --> 00:26:06,790
buy it sometimes it's 7 bytes but I

00:26:04,390 --> 00:26:09,330
don't really know what exactly they mean

00:26:06,790 --> 00:26:13,500
they could mean numbers they could mean

00:26:09,330 --> 00:26:15,429
strings they could even mean some

00:26:13,500 --> 00:26:19,840
civilized fixed-sized

00:26:15,429 --> 00:26:23,740
struct for example but here in tight

00:26:19,840 --> 00:26:28,890
beats I we can define a sequence and

00:26:23,740 --> 00:26:32,950
tell like what kind of type we actually

00:26:28,890 --> 00:26:36,030
store in the six in this sequence per

00:26:32,950 --> 00:26:42,040
type what kind of types do we have in

00:26:36,030 --> 00:26:44,320
that beats we have nine for basically no

00:26:42,040 --> 00:26:44,890
value at all we have a true flag false

00:26:44,320 --> 00:26:48,370
flag

00:26:44,890 --> 00:26:53,260
we have unsigned integers from eight

00:26:48,370 --> 00:27:00,160
bits to 128 bits we have signed integers

00:26:53,260 --> 00:27:06,540
from 8 to 128 we have floating numbers

00:27:00,160 --> 00:27:06,540
from 16 to 64 we have the pure poly

00:27:07,470 --> 00:27:14,890
quantity and we have variable quantity

00:27:12,850 --> 00:27:18,880
with zigzag then for Strings we have

00:27:14,890 --> 00:27:26,230
utf-8 and for some kind of a civilized

00:27:18,880 --> 00:27:30,460
data we also have bytes so in to see it

00:27:26,230 --> 00:27:33,700
like following in the previous sequences

00:27:30,460 --> 00:27:37,390
we just have head bytes and now we can

00:27:33,700 --> 00:27:40,809
actually annotate with different

00:27:37,390 --> 00:27:43,510
primitive types you know but again all

00:27:40,809 --> 00:27:46,750
these types are still simple they are

00:27:43,510 --> 00:27:52,210
not complex so I don't have maps or

00:27:46,750 --> 00:27:55,630
another sequence as some other formats

00:27:52,210 --> 00:28:01,950
actually have so example sequence of

00:27:55,630 --> 00:28:03,580
Baux values or a bit set if you will so

00:28:01,950 --> 00:28:06,040
what do I do

00:28:03,580 --> 00:28:10,830
again I start with a test and I say type

00:28:06,040 --> 00:28:16,320
is build on you and I have to provide a

00:28:10,830 --> 00:28:20,790
bit upset when I say which types should

00:28:16,320 --> 00:28:20,790
we should release

00:28:20,830 --> 00:28:28,880
bilder except in this case I said just

00:28:25,470 --> 00:28:30,300
true flag and false flag which means

00:28:28,880 --> 00:28:33,010
[Music]

00:28:30,300 --> 00:28:39,790
builders should accept true and false

00:28:33,010 --> 00:28:42,010
values then I just pull push 12 billion

00:28:39,790 --> 00:28:43,710
values true true false true false false

00:28:42,010 --> 00:28:47,290
false and so on and so forth

00:28:43,710 --> 00:28:52,870
and at the end I say like okay builder

00:28:47,290 --> 00:28:56,410
and code into one out letter and this is

00:28:52,870 --> 00:29:01,630
what I get as a result we've tagged

00:28:56,410 --> 00:29:08,890
beads I have here the number of elements

00:29:01,630 --> 00:29:15,430
and in these two bytes I encoded all 12

00:29:08,890 --> 00:29:18,340
values most of the other binary citation

00:29:15,430 --> 00:29:22,570
formats would actually if you encode a

00:29:18,340 --> 00:29:27,250
boolean value it will take at least one

00:29:22,570 --> 00:29:30,790
byte per value so we would have not

00:29:27,250 --> 00:29:33,970
three bytes for this sequence but at

00:29:30,790 --> 00:29:37,120
least 12 and probably more because they

00:29:33,970 --> 00:29:40,690
also need to store some metadata in my

00:29:37,120 --> 00:29:44,440
case in case of beads the metadata is

00:29:40,690 --> 00:29:48,160
just information how many elements did

00:29:44,440 --> 00:29:50,640
we store in this sequence how long is

00:29:48,160 --> 00:29:55,960
the sequence basically right okay and

00:29:50,640 --> 00:29:58,990
there is another way of encoding type

00:29:55,960 --> 00:30:02,310
beats with a little bit more metadata so

00:29:58,990 --> 00:30:08,340
we say encode with types and you see

00:30:02,310 --> 00:30:11,770
this 3 bytes are the same and they

00:30:08,340 --> 00:30:14,710
prepended with 4 bytes which tells us

00:30:11,770 --> 00:30:19,030
what kind of types we expect in this

00:30:14,710 --> 00:30:22,150
sequence to be a hand with 6 0 0 0 means

00:30:19,030 --> 00:30:28,060
that we expect only true and false

00:30:22,150 --> 00:30:31,210
values to be in the sequence alright so

00:30:28,060 --> 00:30:34,000
the structure of type beats is as

00:30:31,210 --> 00:30:34,340
following we had this element count in

00:30:34,000 --> 00:30:37,250
the

00:30:34,340 --> 00:30:40,190
beginning as I explained before and then

00:30:37,250 --> 00:30:45,770
we have one bite of type information and

00:30:40,190 --> 00:30:50,900
then multiple type bites which represent

00:30:45,770 --> 00:30:57,080
the values themself so now for example

00:30:50,900 --> 00:31:00,440
in case of boolean as true value and

00:30:57,080 --> 00:31:05,240
false value are represented as flags we

00:31:00,440 --> 00:31:06,799
actually we don't have values at all we

00:31:05,240 --> 00:31:09,710
just have the type information and this

00:31:06,799 --> 00:31:13,399
is it this is also how it is possible to

00:31:09,710 --> 00:31:17,649
store twelve value or actually up to

00:31:13,399 --> 00:31:19,970
sixteen values in two bytes so I'm

00:31:17,649 --> 00:31:22,789
getting a little bit ahead of myself

00:31:19,970 --> 00:31:26,899
how many type in four values per byte

00:31:22,789 --> 00:31:29,029
can we have and it depends so as you saw

00:31:26,899 --> 00:31:31,610
before when I'm instance taking the

00:31:29,029 --> 00:31:35,510
builder I tell it which kind of types I

00:31:31,610 --> 00:31:40,130
would like this bill that to accept if

00:31:35,510 --> 00:31:43,820
the number of types is smaller or equal

00:31:40,130 --> 00:31:46,669
to then type information can be

00:31:43,820 --> 00:31:50,240
represented in one bit so I can store

00:31:46,669 --> 00:31:53,360
eight elements per byte just of attack

00:31:50,240 --> 00:31:56,270
information if it's small equals four

00:31:53,360 --> 00:31:59,120
then I need two deeds to represent the

00:31:56,270 --> 00:32:05,440
type information and therefore in one

00:31:59,120 --> 00:32:09,470
bite I can store four elements in incase

00:32:05,440 --> 00:32:12,080
if I have less than sixteen then it will

00:32:09,470 --> 00:32:17,450
be stored in four bits and I will

00:32:12,080 --> 00:32:20,510
represent the type information of two of

00:32:17,450 --> 00:32:23,299
two elements in one bite in comparison

00:32:20,510 --> 00:32:27,110
if you are familiar with message pack or

00:32:23,299 --> 00:32:30,260
sibour they all represent that

00:32:27,110 --> 00:32:33,740
information as well similar to beats but

00:32:30,260 --> 00:32:36,850
they do it in one bite where in this

00:32:33,740 --> 00:32:40,940
case dependent on how many types we

00:32:36,850 --> 00:32:43,630
pre-configured the builder to be it will

00:32:40,940 --> 00:32:47,040
be much more dense so we have like

00:32:43,630 --> 00:32:51,220
that a bit pecking strategy in a way

00:32:47,040 --> 00:32:52,420
again with cases with message back and

00:32:51,220 --> 00:32:53,950
seaboard

00:32:52,420 --> 00:32:58,020
it is a little bit different because

00:32:53,950 --> 00:33:00,340
they also store complex types and

00:32:58,020 --> 00:33:06,940
therefore it would be a little bit more

00:33:00,340 --> 00:33:12,640
complicated to do to pack them better

00:33:06,940 --> 00:33:14,380
but this is also why I talked in in the

00:33:12,640 --> 00:33:17,920
beginning if you have a simpler problem

00:33:14,380 --> 00:33:20,710
you can wish you trying to solve the and

00:33:17,920 --> 00:33:25,780
the solution can be also simpler and

00:33:20,710 --> 00:33:28,870
much more optimized okay so here's an

00:33:25,780 --> 00:33:31,600
example where I would like to push so

00:33:28,870 --> 00:33:35,950
but times which I have in the Builder

00:33:31,600 --> 00:33:40,180
are you ate so unsigned integer which is

00:33:35,950 --> 00:33:44,410
just one bite and bit type none right

00:33:40,180 --> 00:33:50,050
then I'm pushing 20 I'm pushing none I

00:33:44,410 --> 00:33:53,890
am pushing 21 and I'm pushing 22 now

00:33:50,050 --> 00:33:59,920
when i encode I see that I have four

00:33:53,890 --> 00:34:04,350
values encoded 13 is my type information

00:33:59,920 --> 00:34:08,679
and then I have just four values 20 21

00:34:04,350 --> 00:34:11,350
22 as you can see this none should be

00:34:08,679 --> 00:34:13,929
theoretically here and in most other

00:34:11,350 --> 00:34:17,590
civilization formats it's actually also

00:34:13,929 --> 00:34:18,179
like represented as one byte but in case

00:34:17,590 --> 00:34:22,690
of beads

00:34:18,179 --> 00:34:26,260
it's just absent it's just part of this

00:34:22,690 --> 00:34:29,260
one byte in here because we have only

00:34:26,260 --> 00:34:36,040
four values and we could actually store

00:34:29,260 --> 00:34:41,830
up to eight eight values in this one

00:34:36,040 --> 00:34:44,950
byte okay right and again we can encode

00:34:41,830 --> 00:34:49,120
it with types and then yeah it's the

00:34:44,950 --> 00:34:51,340
same buffer basically but just be

00:34:49,120 --> 00:34:55,919
pendant will the type information so we

00:34:51,340 --> 00:34:59,010
know which types are actually

00:34:55,919 --> 00:35:04,570
represented in

00:34:59,010 --> 00:35:07,270
sequence okay slightly different example

00:35:04,570 --> 00:35:11,760
now the types are you eight and you 16

00:35:07,270 --> 00:35:17,020
and I'm pushing three numbers I pushed

00:35:11,760 --> 00:35:22,360
28 I pushed 261 and I push 22 again I

00:35:17,020 --> 00:35:25,480
have three values and now I'm actually

00:35:22,360 --> 00:35:29,620
you can see that this is the type

00:35:25,480 --> 00:35:31,780
information and you can see like I store

00:35:29,620 --> 00:35:36,630
20 only in one bite

00:35:31,780 --> 00:35:38,800
I saw 261 in two bytes because I

00:35:36,630 --> 00:35:42,700
physically can't store it in one bite

00:35:38,800 --> 00:35:45,790
and when I thought 22 in just one bite

00:35:42,700 --> 00:35:52,420
basically when you have different types

00:35:45,790 --> 00:35:57,510
in the Builder and you push values the

00:35:52,420 --> 00:36:00,600
builder will check what is the smallest

00:35:57,510 --> 00:36:06,190
appropriate way of representing this

00:36:00,600 --> 00:36:11,440
value so we could also represent 20 with

00:36:06,190 --> 00:36:14,020
two bytes it would be when 20 and 0 but

00:36:11,440 --> 00:36:19,510
it's not the most compact ways and we

00:36:14,020 --> 00:36:22,960
have this u8 declared so it will just

00:36:19,510 --> 00:36:28,630
pick you 8 has a type for this value and

00:36:22,960 --> 00:36:32,500
it will pick you 16 for this video this

00:36:28,630 --> 00:36:34,330
is lots of code here I just have strings

00:36:32,500 --> 00:36:37,660
which I concatenate and it's basically

00:36:34,330 --> 00:36:42,850
with the same stuff I have Maxime I push

00:36:37,660 --> 00:36:44,740
Maxime to the Builder and like way

00:36:42,850 --> 00:36:48,910
interesting part I just wanted to tell

00:36:44,740 --> 00:36:53,170
you how strings has utilized strings as

00:36:48,910 --> 00:36:55,420
she realizes utf-8 buffa prepared it

00:36:53,170 --> 00:36:58,240
with the size of the string so in case

00:36:55,420 --> 00:37:00,190
of how many bytes this string actually

00:36:58,240 --> 00:37:02,220
takes right so in case of Maxime it's 5

00:37:00,190 --> 00:37:09,610
in case of hello

00:37:02,220 --> 00:37:11,050
it's actually 10 bytes in case of man

00:37:09,610 --> 00:37:12,460
nothing changes

00:37:11,050 --> 00:37:14,770
the only thing which changes is we say

00:37:12,460 --> 00:37:16,690
like here we had two elements now we

00:37:14,770 --> 00:37:20,020
have three elements everything else is

00:37:16,690 --> 00:37:26,310
equal and case of aha

00:37:20,020 --> 00:37:29,470
we have four elements and this is utf-8

00:37:26,310 --> 00:37:34,300
representation of four bytes for aha

00:37:29,470 --> 00:37:36,070
exclamation marks all right round tip

00:37:34,300 --> 00:37:39,490
how does it look if you would like to

00:37:36,070 --> 00:37:44,110
not only serialize but also with data

00:37:39,490 --> 00:37:47,680
out of that bits so here you can see

00:37:44,110 --> 00:37:51,450
that I'm defining the types it suit a

00:37:47,680 --> 00:37:54,100
frickin month then I create a builder

00:37:51,450 --> 00:37:54,610
and I have here a string hello my name

00:37:54,100 --> 00:37:58,960
is Maxime

00:37:54,610 --> 00:38:01,480
what about you Here I am pushing all the

00:37:58,960 --> 00:38:05,310
strings into the buildin and when I'm

00:38:01,480 --> 00:38:09,460
encoding it so now we've typed beads

00:38:05,310 --> 00:38:12,670
when I create fabless new I give it a

00:38:09,460 --> 00:38:19,420
splice and I have to provide it types

00:38:12,670 --> 00:38:24,510
what types are inside of inside of this

00:38:19,420 --> 00:38:28,420
sequence so this is important because we

00:38:24,510 --> 00:38:30,640
when we just encode we don't encode net

00:38:28,420 --> 00:38:35,830
information about other types of the

00:38:30,640 --> 00:38:38,650
sequence it is fine if you are creator

00:38:35,830 --> 00:38:43,330
and work consumer or you have some kind

00:38:38,650 --> 00:38:47,460
of hard definition of the schema you

00:38:43,330 --> 00:38:52,690
know that this buffer will only contain

00:38:47,460 --> 00:38:57,000
strings and maybe some non values right

00:38:52,690 --> 00:39:03,070
so you know how to read this stuff and

00:38:57,000 --> 00:39:05,440
the problem here of type beats again as

00:39:03,070 --> 00:39:09,070
I said everything is zero copy

00:39:05,440 --> 00:39:13,390
everything is lazy so what it does it

00:39:09,070 --> 00:39:15,520
just keeps reference to a slice and

00:39:13,390 --> 00:39:19,240
that's a little bit of computation and

00:39:15,520 --> 00:39:23,380
then we can create an iterator and then

00:39:19,240 --> 00:39:24,339
enumerate over it and and then get the

00:39:23,380 --> 00:39:27,339
values

00:39:24,339 --> 00:39:29,739
one after another and we do this

00:39:27,339 --> 00:39:31,719
assertion basically again compared to

00:39:29,739 --> 00:39:35,950
the right different implementations of

00:39:31,719 --> 00:39:38,890
for example sibour and message back but

00:39:35,950 --> 00:39:41,680
but most of them as far as I know are

00:39:38,890 --> 00:39:43,719
kind of you serialized some three

00:39:41,680 --> 00:39:46,089
objects and then when you dis you

00:39:43,719 --> 00:39:48,999
realize they will materialize the whole

00:39:46,089 --> 00:39:52,239
three object for you and if it's a big

00:39:48,999 --> 00:39:57,160
one then you have like a very large

00:39:52,239 --> 00:40:01,749
initial cost with Beats we can actually

00:39:57,160 --> 00:40:04,809
lazily go and just extract values as we

00:40:01,749 --> 00:40:07,779
go we don't have this big penalty in the

00:40:04,809 --> 00:40:09,849
beginning we just can't get an iterate

00:40:07,779 --> 00:40:11,279
and just iterate over all the values in

00:40:09,849 --> 00:40:15,670
the sequence

00:40:11,279 --> 00:40:18,460
it's an iterator so map collect works

00:40:15,670 --> 00:40:21,729
and all the other stuff that you know

00:40:18,460 --> 00:40:26,049
from standard library which kind of work

00:40:21,729 --> 00:40:32,469
with iterative work with beads then as

00:40:26,049 --> 00:40:35,859
well one more difference and here's

00:40:32,469 --> 00:40:39,400
basically I just wanted to showcase that

00:40:35,859 --> 00:40:42,309
you can encode with types and in this

00:40:39,400 --> 00:40:46,809
case where you can initialize without

00:40:42,309 --> 00:40:49,119
beads with new types included and now we

00:40:46,809 --> 00:40:51,579
just have to provide the slice itself

00:40:49,119 --> 00:40:53,950
not very information about the types

00:40:51,579 --> 00:40:57,089
because of information about the types

00:40:53,950 --> 00:41:02,079
is already encoded in the buffer itself

00:40:57,089 --> 00:41:04,599
everything else works the same okay so

00:41:02,079 --> 00:41:08,950
what about type beats and indexing so

00:41:04,599 --> 00:41:18,670
like Jim could be two-minute warning

00:41:08,950 --> 00:41:21,729
like okay so or I can actually skip for

00:41:18,670 --> 00:41:25,359
this one and I will go to something more

00:41:21,729 --> 00:41:29,109
interesting I guess with some a little

00:41:25,359 --> 00:41:34,299
bit of like statistics and so on and so

00:41:29,109 --> 00:41:36,489
forth so so the beats itself the

00:41:34,299 --> 00:41:38,650
sequence itself is actually what I said

00:41:36,489 --> 00:41:40,710
it's built for simplicity

00:41:38,650 --> 00:41:43,210
so it's just sequencing right and

00:41:40,710 --> 00:41:46,030
normally you have sometimes this kind of

00:41:43,210 --> 00:41:49,330
a problem but for problems that we are

00:41:46,030 --> 00:41:53,590
solving normally I'm much more complex

00:41:49,330 --> 00:41:58,180
and you would like to maybe you ask

00:41:53,590 --> 00:42:01,800
yourself like well can I actually also

00:41:58,180 --> 00:42:06,880
solve something useful with it and I'm a

00:42:01,800 --> 00:42:09,940
big proponent of solving solving complex

00:42:06,880 --> 00:42:13,180
problems through composition of simple

00:42:09,940 --> 00:42:14,830
solutions and with this if you think

00:42:13,180 --> 00:42:17,380
about it's a sequence but you can also

00:42:14,830 --> 00:42:19,060
make a sequence of sequences so you can

00:42:17,380 --> 00:42:22,000
have like for example index beads and

00:42:19,060 --> 00:42:25,240
human had have beads inside so for

00:42:22,000 --> 00:42:26,110
example here we have a sequence of names

00:42:25,240 --> 00:42:28,780
all right

00:42:26,110 --> 00:42:33,400
Maxim Alex video Maxim magazine and then

00:42:28,780 --> 00:42:35,650
we would like to compact it somehow and

00:42:33,400 --> 00:42:38,080
the simplest way of compacting it is

00:42:35,650 --> 00:42:41,470
saying like okay I would like to do

00:42:38,080 --> 00:42:43,870
duplicate values because I see like who

00:42:41,470 --> 00:42:46,240
Maxim is appearing three times so how I

00:42:43,870 --> 00:42:49,660
can do it I make a sequence of sequences

00:42:46,240 --> 00:42:53,160
where the first sequence is index of

00:42:49,660 --> 00:42:58,080
value and the second sequence of values

00:42:53,160 --> 00:43:03,550
themselves and here actually we would

00:42:58,080 --> 00:43:05,910
save already five if every element is a

00:43:03,550 --> 00:43:09,310
byte then we would say five bytes

00:43:05,910 --> 00:43:14,250
because we have here five and magazine

00:43:09,310 --> 00:43:14,250
itself has five and we don't have to

00:43:14,280 --> 00:43:22,810
store this third Maxim which is a win

00:43:18,610 --> 00:43:25,750
then okay and duplication can be done

00:43:22,810 --> 00:43:30,280
with it so we have indexed bits with

00:43:25,750 --> 00:43:33,130
fixed size beads and it is bit doesn't

00:43:30,280 --> 00:43:37,120
matter I end I would like to show you so

00:43:33,130 --> 00:43:40,080
I as I say I said I'm doing it for

00:43:37,120 --> 00:43:40,080
sports so I try to

00:43:40,849 --> 00:43:48,150
transform CSV files into bits to see how

00:43:45,390 --> 00:43:53,720
much gain can I get and here is an

00:43:48,150 --> 00:43:57,749
example of a typical CSV file where it's

00:43:53,720 --> 00:44:00,299
statistics of crime in a US state I

00:43:57,749 --> 00:44:04,200
think and you can see we have here and a

00:44:00,299 --> 00:44:09,140
time address district beatgrid a crime

00:44:04,200 --> 00:44:15,329
description and other stuff so basically

00:44:09,140 --> 00:44:21,140
for this I can transform this file into

00:44:15,329 --> 00:44:26,009
a misrepresentation and for this I

00:44:21,140 --> 00:44:29,339
basically defined which column should be

00:44:26,009 --> 00:44:33,210
represented how so I say first column

00:44:29,339 --> 00:44:34,890
should be duplicated utf-8 because as

00:44:33,210 --> 00:44:37,710
you can see here we have lots of the

00:44:34,890 --> 00:44:41,849
application in this in this first column

00:44:37,710 --> 00:44:44,039
it's all strings and we also pretty much

00:44:41,849 --> 00:44:47,579
duplicated the second column will be

00:44:44,039 --> 00:44:50,220
just drinks the first comma column will

00:44:47,579 --> 00:44:53,609
be just a number and so on and so forth

00:44:50,220 --> 00:44:56,999
and the results are basically we CSV

00:44:53,609 --> 00:45:01,230
file is some talent ninety-three

00:44:56,999 --> 00:45:07,499
kilobytes and we CSV and the beats file

00:45:01,230 --> 00:45:12,089
is 522 kilobytes so we get like 30 and

00:45:07,499 --> 00:45:16,319
34 percent so basically one we could

00:45:12,089 --> 00:45:18,299
reduce the file by one third and we

00:45:16,319 --> 00:45:22,170
still keep the same data and it's

00:45:18,299 --> 00:45:26,069
actually a little bit better represented

00:45:22,170 --> 00:45:30,390
because we've CSV we can't have direct

00:45:26,069 --> 00:45:32,640
in this indexing into the columns it

00:45:30,390 --> 00:45:35,640
needs to be parsed first but with beads

00:45:32,640 --> 00:45:37,890
the structure is in a way where I can

00:45:35,640 --> 00:45:40,230
just say like okay give me the column

00:45:37,890 --> 00:45:48,559
free and then I will just go through

00:45:40,230 --> 00:45:53,269
boroughs in country this is the last

00:45:48,559 --> 00:45:56,910
slide basically so here is an example of

00:45:53,269 --> 00:46:01,349
kind of different file sizes and you can

00:45:56,910 --> 00:46:08,749
see that I could like save up to five

00:46:01,349 --> 00:46:10,920
times the size up to like maybe just 22%

00:46:08,749 --> 00:46:14,160
okay now I'm done

00:46:10,920 --> 00:46:19,190
thank you very much sorry for taking too

00:46:14,160 --> 00:46:27,450
long time over it was a very interesting

00:46:19,190 --> 00:46:30,680
presentation we cut one question on

00:46:27,450 --> 00:46:33,210
YouTube but you answered this already

00:46:30,680 --> 00:46:36,589
one question is and we'll cheese of

00:46:33,210 --> 00:46:39,660
compressed ahead files maybe you can

00:46:36,589 --> 00:46:42,150
come again I couldn't hear the question

00:46:39,660 --> 00:46:42,960
was and will cheese soup compress the

00:46:42,150 --> 00:46:47,009
head files

00:46:42,960 --> 00:46:53,450
yes so this is basically sorry hi will

00:46:47,009 --> 00:46:57,960
she have a screen again this was on I

00:46:53,450 --> 00:47:01,019
think yes and if you want you can check

00:46:57,960 --> 00:47:03,180
out the YouTube and you can discuss

00:47:01,019 --> 00:47:07,470
because like we're running away okay I

00:47:03,180 --> 00:47:10,259
am maybe gone on the YouTube thing I

00:47:07,470 --> 00:47:16,319
will post post a link and feel hungry

00:47:10,259 --> 00:47:21,900
too all right all right cool thank you

00:47:16,319 --> 00:47:27,430
so much thank you very much and now it's

00:47:21,900 --> 00:47:31,760
time for Mike to take the stage

00:47:27,430 --> 00:47:35,020
Kri free to share your screen and him

00:47:31,760 --> 00:47:38,690
yeah hi everyone I'm Mike

00:47:35,020 --> 00:47:44,690
so we're gonna talk today about transit

00:47:38,690 --> 00:47:46,940
radar so if I am on screen so yeah

00:47:44,690 --> 00:47:49,940
firstly just a little quickly about me

00:47:46,940 --> 00:47:52,880
I've worked mostly in application

00:47:49,940 --> 00:47:55,040
backends so in different things for data

00:47:52,880 --> 00:47:58,160
processing and backends for web

00:47:55,040 --> 00:48:00,830
applications I'm really interested now

00:47:58,160 --> 00:48:04,040
when working using rust especially on

00:48:00,830 --> 00:48:09,530
web-based tools especially ones that get

00:48:04,040 --> 00:48:11,150
ax use usable data as well a few times

00:48:09,530 --> 00:48:12,740
over the last few years I was trying to

00:48:11,150 --> 00:48:13,940
learn rust but each time I think I've

00:48:12,740 --> 00:48:15,860
tried to use it the things that I

00:48:13,940 --> 00:48:18,380
couldn't do with the other languages

00:48:15,860 --> 00:48:19,940
that I've always worked with and so I'd

00:48:18,380 --> 00:48:22,580
be trying to do systems programming

00:48:19,940 --> 00:48:25,100
things which is not my background so

00:48:22,580 --> 00:48:27,380
here I decided instead I should learn it

00:48:25,100 --> 00:48:29,510
by doing an application making an

00:48:27,380 --> 00:48:32,380
application so the idea for the

00:48:29,510 --> 00:48:36,170
application that came from looking at

00:48:32,380 --> 00:48:41,990
looking in transit maps so like this is

00:48:36,170 --> 00:48:43,880
the s1 and I find I find other transit

00:48:41,990 --> 00:48:45,950
maps quite interesting it's like at all

00:48:43,880 --> 00:48:48,080
that's over a hundred years old and at

00:48:45,950 --> 00:48:50,360
the time the technology you needed to

00:48:48,080 --> 00:48:54,500
use for this was like painting it on the

00:48:50,360 --> 00:48:56,510
wall about a train station nowadays

00:48:54,500 --> 00:48:58,940
nowadays we have all this computation

00:48:56,510 --> 00:49:01,040
power in everyone's pockets and instead

00:48:58,940 --> 00:49:03,350
so instead of the we solve this problem

00:49:01,040 --> 00:49:06,530
of providing a tool to send to this

00:49:03,350 --> 00:49:09,860
route across the city by like you enter

00:49:06,530 --> 00:49:11,930
your and start point in the destination

00:49:09,860 --> 00:49:14,360
and the other parameters and it gives

00:49:11,930 --> 00:49:16,610
you a step-by-step guide how to get that

00:49:14,360 --> 00:49:18,140
and I was thinking that it interesting

00:49:16,610 --> 00:49:20,390
to have somewhere that's somewhere in

00:49:18,140 --> 00:49:21,770
between this with this graphical

00:49:20,390 --> 00:49:24,590
representation and where you have to do

00:49:21,770 --> 00:49:26,570
some work and the computational one

00:49:24,590 --> 00:49:29,690
which can give you more relevant

00:49:26,570 --> 00:49:33,590
information to your search so to this

00:49:29,690 --> 00:49:39,460
I've built transit radar and which lets

00:49:33,590 --> 00:49:39,460
you and just enter a single

00:49:39,470 --> 00:49:46,240
they start out points destination to

00:49:41,990 --> 00:49:51,730
your search so we have so here and

00:49:46,240 --> 00:49:54,559
sports respond station and based on the

00:49:51,730 --> 00:49:56,900
based on the routes available it now

00:49:54,559 --> 00:50:00,049
shows you everywhere that you could get

00:49:56,900 --> 00:50:02,960
to within 30 minutes and you know map

00:50:00,049 --> 00:50:04,460
format so each of these there are three

00:50:02,960 --> 00:50:07,339
rings here and each of them is ten

00:50:04,460 --> 00:50:12,319
minutes away from us quite at the center

00:50:07,339 --> 00:50:15,680
of the map and it's updating in real

00:50:12,319 --> 00:50:19,010
time based on their based on timetables

00:50:15,680 --> 00:50:22,069
so everything else in the network gets

00:50:19,010 --> 00:50:26,000
slowly closer to asteroids until I had

00:50:22,069 --> 00:50:28,099
trained the parts and the trains are

00:50:26,000 --> 00:50:30,559
represented by each of the lines that I

00:50:28,099 --> 00:50:34,039
want to train the parts then it's gone

00:50:30,559 --> 00:50:39,190
and everything that every routes the

00:50:34,039 --> 00:50:43,849
used map train and gets further away so

00:50:39,190 --> 00:50:47,900
the the dotted lines here represents

00:50:43,849 --> 00:50:51,400
waiting times and transfers and the

00:50:47,900 --> 00:50:54,260
solid lines are the trips with trends

00:50:51,400 --> 00:50:56,510
the the angles are actually the compass

00:50:54,260 --> 00:50:59,539
angle to the stops so you do get

00:50:56,510 --> 00:51:02,930
geographical features which are not just

00:50:59,539 --> 00:51:07,880
about the distance traveled and so you

00:51:02,930 --> 00:51:11,589
can see the s s42 curving anti-clockwise

00:51:07,880 --> 00:51:14,359
up to the north and the s41 combing

00:51:11,589 --> 00:51:18,369
clockwise down to the south and east

00:51:14,359 --> 00:51:22,279
west lines going in that direction spot

00:51:18,369 --> 00:51:24,619
and so this has been like this has been

00:51:22,279 --> 00:51:26,869
quite a big project but quite a lot of

00:51:24,619 --> 00:51:28,760
time into it and use it as something

00:51:26,869 --> 00:51:32,119
which I can do a lot of experimentation

00:51:28,760 --> 00:51:33,710
with and trying out techniques and

00:51:32,119 --> 00:51:37,960
technologies that I was interested in

00:51:33,710 --> 00:51:40,819
working on so we can have a look at the

00:51:37,960 --> 00:51:43,930
yeah so I can't I can't go through I

00:51:40,819 --> 00:51:47,599
can't go over it like that much of the

00:51:43,930 --> 00:51:49,789
much of the project today but I will

00:51:47,599 --> 00:51:53,420
give them over to you first of all and

00:51:49,789 --> 00:51:56,010
so the high-level components

00:51:53,420 --> 00:51:59,940
these are the most sort of important as

00:51:56,010 --> 00:52:02,130
highlight components and it's it's false

00:51:59,940 --> 00:52:06,680
back rust so it's both the server and

00:52:02,130 --> 00:52:09,330
client components both of us and the

00:52:06,680 --> 00:52:13,890
it's it's not an interactive program

00:52:09,330 --> 00:52:17,070
really apart from the only interactive

00:52:13,890 --> 00:52:19,290
component is that you can also choose

00:52:17,070 --> 00:52:20,910
you can you can choose where you know

00:52:19,290 --> 00:52:25,560
your start point is and you can also

00:52:20,910 --> 00:52:34,500
change the transform works that you have

00:52:25,560 --> 00:52:36,240
to search with so here the date was all

00:52:34,500 --> 00:52:39,240
data flow of these components goes from

00:52:36,240 --> 00:52:42,510
left to right and they originate the

00:52:39,240 --> 00:52:45,800
data originates in general transit feed

00:52:42,510 --> 00:52:50,430
specification files that's published on

00:52:45,800 --> 00:52:54,930
sort of a week roughly weekly basis by

00:52:50,430 --> 00:52:59,640
the BBB and those are present property

00:52:54,930 --> 00:53:01,920
available and they're in CSV format so

00:52:59,640 --> 00:53:06,540
just the first part is passing most

00:53:01,920 --> 00:53:12,350
funds I then load them into a lookup

00:53:06,540 --> 00:53:15,300
data structure in memory and have a an

00:53:12,350 --> 00:53:19,170
algorithm which is constructing in a

00:53:15,300 --> 00:53:23,370
shortest path tree through from an

00:53:19,170 --> 00:53:25,950
origins but through the trips to get to

00:53:23,370 --> 00:53:29,240
to get to each station as close as

00:53:25,950 --> 00:53:32,160
possible and as fast as possible and

00:53:29,240 --> 00:53:36,150
those two components the lookup data

00:53:32,160 --> 00:53:38,820
structures and the algorithm both run on

00:53:36,150 --> 00:53:42,480
both the server and plan so exactly the

00:53:38,820 --> 00:53:43,830
same code gets to kiss p1 and I think

00:53:42,480 --> 00:53:46,500
there's one of the things that I find

00:53:43,830 --> 00:53:49,410
interesting about being able to do this

00:53:46,500 --> 00:53:52,440
with rust that's that the being able to

00:53:49,410 --> 00:53:57,720
share this this code and especially when

00:53:52,440 --> 00:54:01,350
it's quite at a complex algorithm there

00:53:57,720 --> 00:54:05,310
are two to sort of main components at

00:54:01,350 --> 00:54:08,900
the boundary between the seventh

00:54:05,310 --> 00:54:12,510
so one is the station suggestion look up

00:54:08,900 --> 00:54:17,820
where in that top box you can type in a

00:54:12,510 --> 00:54:20,430
name of a the name of the station and it

00:54:17,820 --> 00:54:22,980
will suggest things even might be

00:54:20,430 --> 00:54:24,660
looking for and that of course has a

00:54:22,980 --> 00:54:26,460
server component which needs to look up

00:54:24,660 --> 00:54:30,780
in those stocks in the station

00:54:26,460 --> 00:54:32,370
information and a client side and then

00:54:30,780 --> 00:54:37,530
there's the sink environment as well

00:54:32,370 --> 00:54:40,530
which is which which is responsible for

00:54:37,530 --> 00:54:42,780
getting the data that's some of them

00:54:40,530 --> 00:54:46,320
some of the server-side data which is

00:54:42,780 --> 00:54:50,280
quite a bit of and transferring its to

00:54:46,320 --> 00:54:51,840
the clams when it needs it and I'll talk

00:54:50,280 --> 00:54:54,900
a bit more about that in the moment and

00:54:51,840 --> 00:54:57,510
then in the front ends of the in the

00:54:54,900 --> 00:55:02,420
front end of the application there is

00:54:57,510 --> 00:55:02,420
the various seat components and

00:55:03,050 --> 00:55:10,380
including the autocomplete box and the

00:55:07,110 --> 00:55:12,840
other controls and then the practical

00:55:10,380 --> 00:55:17,760
part of the display is working using

00:55:12,840 --> 00:55:31,110
them using an HTML campus which also

00:55:17,760 --> 00:55:34,320
provides and is also doing animation so

00:55:31,110 --> 00:55:37,590
the the synchronization component and I

00:55:34,320 --> 00:55:40,880
think is one of the two parts that I

00:55:37,590 --> 00:55:47,190
want to zoom in all of it today

00:55:40,880 --> 00:55:50,400
the main tere is that the when when the

00:55:47,190 --> 00:55:55,350
user changes the control in ads there's

00:55:50,400 --> 00:55:56,670
that produces a query and we run that we

00:55:55,350 --> 00:55:59,850
send that query

00:55:56,670 --> 00:56:03,060
we run that query using the algorithm on

00:55:59,850 --> 00:56:06,360
the on the data sets and both the client

00:56:03,060 --> 00:56:08,130
and the server at the same time or on

00:56:06,360 --> 00:56:11,730
the clients waiting for because it can

00:56:08,130 --> 00:56:13,470
run instantaneously so on the client

00:56:11,730 --> 00:56:16,910
side the algorithm is running against

00:56:13,470 --> 00:56:21,920
the data and producing the tree results

00:56:16,910 --> 00:56:23,960
and that trade results means that is

00:56:21,920 --> 00:56:30,650
then is then rendered on to the canvas

00:56:23,960 --> 00:56:32,390
as you can see the and it's it's running

00:56:30,650 --> 00:56:33,740
the algorithm and against the living to

00:56:32,390 --> 00:56:36,500
the updates that's on the client

00:56:33,740 --> 00:56:38,950
currently and query there is also run

00:56:36,500 --> 00:56:41,120
against the data on the server and

00:56:38,950 --> 00:56:45,650
instead of producing a result we produce

00:56:41,120 --> 00:56:47,060
the IDS after the records that will need

00:56:45,650 --> 00:56:52,430
it in order for the algorithm to

00:56:47,060 --> 00:56:52,970
complete run and from from that required

00:56:52,430 --> 00:56:57,110
data

00:56:52,970 --> 00:56:58,970
I then subtract the data is currently

00:56:57,110 --> 00:57:01,760
available to the client which is thought

00:56:58,970 --> 00:57:04,550
in that session variable to find the

00:57:01,760 --> 00:57:08,240
missing data and then the missing data

00:57:04,550 --> 00:57:10,160
is the data that's the claim that the

00:57:08,240 --> 00:57:12,560
client should have used to produce its

00:57:10,160 --> 00:57:14,870
results and but because it didn't have

00:57:12,560 --> 00:57:17,810
it it was unable to produce it and clean

00:57:14,870 --> 00:57:20,360
result so we fetched that from the

00:57:17,810 --> 00:57:24,230
server database and serialize it and

00:57:20,360 --> 00:57:28,280
send it to the clients and at that point

00:57:24,230 --> 00:57:31,550
the client can then rerun its query or a

00:57:28,280 --> 00:57:34,280
new query if it's and if the user was

00:57:31,550 --> 00:57:36,970
already updated something and we can

00:57:34,280 --> 00:57:45,620
then reduce and up to date results with

00:57:36,970 --> 00:57:47,540
the new information so yeah so yeah so

00:57:45,620 --> 00:57:50,360
this things that we get we have a very

00:57:47,540 --> 00:57:52,250
responsive we go responsive front-end as

00:57:50,360 --> 00:57:54,680
much as possible but we also provide

00:57:52,250 --> 00:57:58,970
access to as much of the data as

00:57:54,680 --> 00:58:04,210
possible and so we can look at some of

00:57:58,970 --> 00:58:04,210
the code now if I have this folks and

00:58:04,510 --> 00:58:13,160
I'm hoping that you can see this schema

00:58:08,390 --> 00:58:16,220
and see their code now so this is the

00:58:13,160 --> 00:58:19,820
I'm using what for the for the web

00:58:16,220 --> 00:58:21,200
server and then this is the one of the

00:58:19,820 --> 00:58:23,290
main functions that's getting caught

00:58:21,200 --> 00:58:27,560
when we do that some criminalization

00:58:23,290 --> 00:58:29,930
it's it gets provided with the full data

00:58:27,560 --> 00:58:32,809
set from the of the trans information

00:58:29,930 --> 00:58:35,270
a reference to that stop that the

00:58:32,809 --> 00:58:38,930
weather search is originating from and

00:58:35,270 --> 00:58:41,030
then the moment I said parameters and we

00:58:38,930 --> 00:58:42,950
constructing an instance of the

00:58:41,030 --> 00:58:45,589
algorithm bra which is this journey

00:58:42,950 --> 00:58:49,329
graph button and then adding the other

00:58:45,589 --> 00:58:52,930
parameters to it and then at this point

00:58:49,329 --> 00:58:56,000
on the client it would be asking for the

00:58:52,930 --> 00:58:58,160
results of the search but on the server

00:58:56,000 --> 00:59:05,089
side we're asking for this sort of data

00:58:58,160 --> 00:59:09,890
and that's that's looping because it's

00:59:05,089 --> 00:59:11,780
an iterative algorithm so this is is

00:59:09,890 --> 00:59:15,920
running the iterative iterations of the

00:59:11,780 --> 00:59:17,780
algorithm and when we get II and the

00:59:15,920 --> 00:59:21,530
results that we get from each iteration

00:59:17,780 --> 00:59:24,079
as q items and we don't care about most

00:59:21,530 --> 00:59:26,020
of the parameters of it there because

00:59:24,079 --> 00:59:29,540
all we're doing is we just want to know

00:59:26,020 --> 00:59:33,440
which stock was it going to be parents

00:59:29,540 --> 00:59:35,630
of that start and which trip wasn't

00:59:33,440 --> 00:59:40,369
using if it is usable if it is using a

00:59:35,630 --> 00:59:46,460
trip so and those each of those their

00:59:40,369 --> 00:59:52,069
stops and the trip get recorded in this

00:59:46,460 --> 00:59:54,950
required data object so the reason why

00:59:52,069 --> 00:59:57,829
two other moments it's only using we're

00:59:54,950 --> 01:00:01,010
only recording the records as breaking

00:59:57,829 --> 01:00:04,400
up the records into trips and stops it's

01:00:01,010 --> 01:00:07,069
the most is the most basic way that they

01:00:04,400 --> 01:00:10,579
could do it so time if I broke it down

01:00:07,069 --> 01:00:15,010
into more into more granular records

01:00:10,579 --> 01:00:17,480
then be able to produce a much smaller

01:00:15,010 --> 01:00:19,760
like initial data transfer

01:00:17,480 --> 01:00:21,500
so the moment at moments the initial

01:00:19,760 --> 01:00:26,270
data transfer can be quite high because

01:00:21,500 --> 01:00:29,319
it is some of the stop information in

01:00:26,270 --> 01:00:33,819
particular is quite large includes

01:00:29,319 --> 01:00:38,500
departures over the entire time taken

01:00:33,819 --> 01:00:48,620
from that's done and

01:00:38,500 --> 01:00:56,210
so so then I go back to to go back to

01:00:48,620 --> 01:00:59,300
the web server the this is the this is

01:00:56,210 --> 01:01:02,060
before the function which is calling the

01:00:59,300 --> 01:01:04,760
function above that I'll show you which

01:01:02,060 --> 01:01:07,550
gets that required data so this is

01:01:04,760 --> 01:01:10,850
running doing the running running query

01:01:07,550 --> 01:01:14,900
on back-end in order to find the data

01:01:10,850 --> 01:01:19,850
that's needed for those needed in order

01:01:14,900 --> 01:01:23,300
to to perform this run and here we also

01:01:19,850 --> 01:01:25,610
have a handle on a session so the

01:01:23,300 --> 01:01:27,620
session is a meet X so it's something

01:01:25,610 --> 01:01:33,710
that we can learn lock and get mutable

01:01:27,620 --> 01:01:39,320
access to and the once we have access to

01:01:33,710 --> 01:01:41,960
the session then and we have also the

01:01:39,320 --> 01:01:47,090
IDs of the data that's required to run

01:01:41,960 --> 01:01:51,290
to make do this run this add data

01:01:47,090 --> 01:01:55,670
function the purpose of this to both ad

01:01:51,290 --> 01:01:57,560
is to produce the date of the new data

01:01:55,670 --> 01:02:00,050
that needs to be serialized from central

01:01:57,560 --> 01:02:04,670
clients and also updates the session

01:02:00,050 --> 01:02:09,320
with the data that with rookie's to the

01:02:04,670 --> 01:02:10,550
data that the client will now have so we

01:02:09,320 --> 01:02:14,060
don't need to send that again in the

01:02:10,550 --> 01:02:17,960
future and here i'm serializing it using

01:02:14,060 --> 01:02:21,140
message back so this could be done using

01:02:17,960 --> 01:02:23,990
json as well but because some of the

01:02:21,140 --> 01:02:27,380
data transfers are quite large message

01:02:23,990 --> 01:02:30,440
back on the tests that i did reduce to

01:02:27,380 --> 01:02:34,090
reduce the data to about one third of

01:02:30,440 --> 01:02:36,620
what it would be doing using json and

01:02:34,090 --> 01:02:38,930
because I'm using rust both sides it's

01:02:36,620 --> 01:02:43,910
just as easy to be message back as it is

01:02:38,930 --> 01:02:49,609
to use JSON and so if you look into here

01:02:43,910 --> 01:02:52,339
so this so this function now is is

01:02:49,609 --> 01:02:55,609
this part of the this part of the sync

01:02:52,339 --> 01:02:59,690
algorithm and where does that

01:02:55,609 --> 01:03:02,450
subtraction subtraction and so it's a

01:02:59,690 --> 01:03:05,809
function almost session let me taste the

01:03:02,450 --> 01:03:08,359
session and we have access to the

01:03:05,809 --> 01:03:12,460
default data source which is read-only

01:03:08,359 --> 01:03:19,190
and we also have the IDS that we need to

01:03:12,460 --> 01:03:21,650
know the client needs and so if it is a

01:03:19,190 --> 01:03:23,960
new session then we know we just need to

01:03:21,650 --> 01:03:26,200
get all the trips and the stops that

01:03:23,960 --> 01:03:33,079
were referred to in this required data

01:03:26,200 --> 01:03:35,839
with these IDs and we create any we also

01:03:33,079 --> 01:03:40,720
add them with we record those in the

01:03:35,839 --> 01:03:43,640
session and we then send them full data

01:03:40,720 --> 01:03:47,180
initial data load with the newly

01:03:43,640 --> 01:03:50,539
generated session ID and the full set of

01:03:47,180 --> 01:03:55,700
data or a partial set of data but using

01:03:50,539 --> 01:04:00,249
at all and data structure and if it's

01:03:55,700 --> 01:04:05,239
some old session then instead we will do

01:04:00,249 --> 01:04:10,069
use retain to filter out filter out the

01:04:05,239 --> 01:04:17,660
trips and the spots that were already

01:04:10,069 --> 01:04:21,079
had and just then get the send the new

01:04:17,660 --> 01:04:25,940
trips and the new stocks and the other

01:04:21,079 --> 01:04:28,579
parts they are the same then lowered

01:04:25,940 --> 01:04:36,259
look at on the drunken part of the

01:04:28,579 --> 01:04:39,200
synchronization fronting part of this

01:04:36,259 --> 01:04:47,329
synchronization and involves a little

01:04:39,200 --> 01:04:52,339
bit more so we have a real estate

01:04:47,329 --> 01:04:53,930
objects enum Jeremy or stadium which is

01:04:52,339 --> 01:04:55,339
either not synchronized so we don't have

01:04:53,930 --> 01:04:58,220
the client doesn't have any information

01:04:55,339 --> 01:04:59,900
from the server or we have a scene or we

01:04:58,220 --> 01:05:02,060
are synchronized in which case we should

01:04:59,900 --> 01:05:10,760
have data and the monthly account

01:05:02,060 --> 01:05:12,740
90 and the update function is an

01:05:10,760 --> 01:05:16,400
important part of is typical part of the

01:05:12,740 --> 01:05:19,190
seed application which I can talk a bit

01:05:16,400 --> 01:05:23,690
more about later it accepts a message

01:05:19,190 --> 01:05:28,160
which is telling its how the which gives

01:05:23,690 --> 01:05:31,750
it a state change and then it updates

01:05:28,160 --> 01:05:35,450
its meat model with that information so

01:05:31,750 --> 01:05:39,860
for instance here fetch data is telling

01:05:35,450 --> 01:05:42,320
it that the query that the result on the

01:05:39,860 --> 01:05:44,240
client sort has been invalidated somehow

01:05:42,320 --> 01:05:49,540
and so we need to perform a

01:05:44,240 --> 01:05:52,550
synchronization with the server and the

01:05:49,540 --> 01:05:55,700
data fetched is called when we get a

01:05:52,550 --> 01:05:59,090
response from the server and at this

01:05:55,700 --> 01:06:03,740
point we call this receive function on

01:05:59,090 --> 01:06:06,500
the model so the model is is the is on

01:06:03,740 --> 01:06:10,070
the client side it's this representation

01:06:06,500 --> 01:06:12,470
of the synchronize data and so

01:06:10,070 --> 01:06:14,000
recordings received with the new data

01:06:12,470 --> 01:06:15,680
that's been sent from the client

01:06:14,000 --> 01:06:24,650
something from the server

01:06:15,680 --> 01:06:26,960
see what data model and if the if we

01:06:24,650 --> 01:06:29,000
receive an initial sync data that could

01:06:26,960 --> 01:06:30,560
be that is usually that would be that is

01:06:29,000 --> 01:06:32,870
the first one in the session or it could

01:06:30,560 --> 01:06:38,060
be that we validated this in session

01:06:32,870 --> 01:06:40,160
somehow which I haven't tried to fix in

01:06:38,060 --> 01:06:43,160
many clever ways really so it's just if

01:06:40,160 --> 01:06:45,830
the session games this has something

01:06:43,160 --> 01:06:48,920
going wrong with it then we just reset

01:06:45,830 --> 01:06:52,370
it with an initial sync data and with

01:06:48,920 --> 01:06:56,150
that we can just set the we can just set

01:06:52,370 --> 01:06:58,310
the sink status this model item to a a

01:06:56,150 --> 01:07:01,700
new synced model with that information

01:06:58,310 --> 01:07:06,410
and if it's an increment then we need to

01:07:01,700 --> 01:07:09,290
add the update the update counts which

01:07:06,410 --> 01:07:12,560
is how we check to see whether the

01:07:09,290 --> 01:07:14,809
session is still valid and we add the

01:07:12,560 --> 01:07:19,489
increment into the existing data

01:07:14,809 --> 01:07:22,699
so unless so in this part I used the a

01:07:19,489 --> 01:07:26,079
design traits so that this this module

01:07:22,699 --> 01:07:30,439
is kind of generic over the types of

01:07:26,079 --> 01:07:33,259
things things that it can work with so

01:07:30,439 --> 01:07:37,699
it gives some kind of dish which can be

01:07:33,259 --> 01:07:39,739
added into the core data and that is

01:07:37,699 --> 01:07:47,329
then just adding adding those records

01:07:39,739 --> 01:07:50,599
into clients data centers so we talked a

01:07:47,329 --> 01:07:53,659
little bit about seed there so can also

01:07:50,599 --> 01:07:55,339
mention a bit about how how a seed

01:07:53,659 --> 01:08:00,019
application works cuz I thought this is

01:07:55,339 --> 01:08:05,630
also quite interesting five minute

01:08:00,019 --> 01:08:09,829
warning okay like okay so yeah so see a

01:08:05,630 --> 01:08:12,880
seed application runs on a raw straight

01:08:09,829 --> 01:08:16,009
type called cdy lib which is a c type

01:08:12,880 --> 01:08:18,819
dynamic library and then we have these

01:08:16,009 --> 01:08:24,289
blue components which all built by the

01:08:18,819 --> 01:08:27,079
rusts web working good so what's behind

01:08:24,289 --> 01:08:29,329
Jenner's then there is the base of that

01:08:27,079 --> 01:08:32,270
which actually has the bindings between

01:08:29,329 --> 01:08:35,900
JavaScript functions and Trust functions

01:08:32,270 --> 01:08:37,039
so they even call both ways and from

01:08:35,900 --> 01:08:43,219
Brussels to JavaScript and vice

01:08:37,039 --> 01:08:45,619
president and wasn't pack is a crate so

01:08:43,219 --> 01:08:48,859
he's a cargo task which packages up

01:08:45,619 --> 01:08:50,869
wasn't managing projects into wasn't

01:08:48,859 --> 01:08:53,710
file a JavaScript file with all this

01:08:50,869 --> 01:08:58,130
bindings and that you can then use and

01:08:53,710 --> 01:09:01,579
Jas this is is the JavaScript language

01:08:58,130 --> 01:09:05,539
bindings so you can call into string

01:09:01,579 --> 01:09:07,219
functions and functions on dates and all

01:09:05,539 --> 01:09:09,199
this kind of stuff is all written into

01:09:07,219 --> 01:09:11,869
Genesis so that you don't need to make

01:09:09,199 --> 01:09:17,790
your own buttons websites is a much

01:09:11,869 --> 01:09:20,040
bigger grade where you are which has the

01:09:17,790 --> 01:09:22,440
which has all the web api water

01:09:20,040 --> 01:09:24,810
generated and because it's so large you

01:09:22,440 --> 01:09:26,580
need to specify which features you're

01:09:24,810 --> 01:09:31,470
going to use so there's a lot of each of

01:09:26,580 --> 01:09:35,150
lacked involved and there's glue which

01:09:31,470 --> 01:09:39,359
is also made by the rust work congruent

01:09:35,150 --> 01:09:41,100
and it's just moments for different for

01:09:39,359 --> 01:09:43,140
different grades and they're bringing up

01:09:41,100 --> 01:09:47,100
the some of the things you need to do a

01:09:43,140 --> 01:09:48,989
lot in in rust and the web to a kind of

01:09:47,100 --> 01:09:51,569
higher burst level so that you're not

01:09:48,989 --> 01:09:54,299
having to deal with JavaScript errors

01:09:51,569 --> 01:09:56,760
and JavaScript call that and this kind

01:09:54,299 --> 01:09:58,590
of thing and so those are those are

01:09:56,760 --> 01:10:02,700
those made to be very generally

01:09:58,590 --> 01:10:05,640
applicable where a seed is more a kind

01:10:02,700 --> 01:10:10,830
of opinionated framework which deals

01:10:05,640 --> 01:10:13,500
with batteries included so it has has

01:10:10,830 --> 01:10:18,170
libraries for doing a lot of things on

01:10:13,500 --> 01:10:23,310
the web and but it's kind of it's the

01:10:18,170 --> 01:10:24,150
faster-moving version of things that has

01:10:23,310 --> 01:10:25,950
everything you need

01:10:24,150 --> 01:10:27,900
so yeah the seed application and you

01:10:25,950 --> 01:10:30,720
just have a HTML file where you call in

01:10:27,900 --> 01:10:34,680
to your JavaScript module the JavaScript

01:10:30,720 --> 01:10:37,440
module and wasn't and and like I was

01:10:34,680 --> 01:10:39,239
kind of showing before you have three

01:10:37,440 --> 01:10:41,460
different three different main functions

01:10:39,239 --> 01:10:44,910
he means to define a seed application

01:10:41,460 --> 01:10:48,060
given init function which creates the

01:10:44,910 --> 01:10:50,960
model and then a view function which

01:10:48,060 --> 01:10:54,540
renders the model producing virtual Dom

01:10:50,960 --> 01:10:57,030
which C then uses to change the DOM and

01:10:54,540 --> 01:10:58,950
then the control flow goes in a loop

01:10:57,030 --> 01:11:01,830
between the two function and the update

01:10:58,950 --> 01:11:05,030
function when the update function is the

01:11:01,830 --> 01:11:08,160
only one that's mutating the model and

01:11:05,030 --> 01:11:10,739
it's doing that based on messages that

01:11:08,160 --> 01:11:14,040
it receives and the view function is

01:11:10,739 --> 01:11:16,950
responsible for writing creating the

01:11:14,040 --> 01:11:23,150
event listeners in the Dom which then

01:11:16,950 --> 01:11:26,640
produce the events of messages which

01:11:23,150 --> 01:11:29,010
work which caused the update function to

01:11:26,640 --> 01:11:30,500
mutate and model so this is based on the

01:11:29,010 --> 01:11:32,750
Elm architecture it

01:11:30,500 --> 01:11:36,230
now it will be different because it's an

01:11:32,750 --> 01:11:39,470
immutable architecture and in rust this

01:11:36,230 --> 01:11:44,780
works better with the company function

01:11:39,470 --> 01:11:47,060
mutating Ashley mutating yeah I was

01:11:44,780 --> 01:11:49,240
going to show some more seat but I think

01:11:47,060 --> 01:11:52,730
maybe a little bit for another time

01:11:49,240 --> 01:11:56,330
and so it's just a bit about I think

01:11:52,730 --> 01:11:58,400
that rusts using rust in the web is I

01:11:56,330 --> 01:12:03,020
think is a good idea and I think it's

01:11:58,400 --> 01:12:06,020
fights and I think it's gonna be it's

01:12:03,020 --> 01:12:07,940
something I'm pretty excited about and I

01:12:06,020 --> 01:12:09,590
think the it's good for sharing these

01:12:07,940 --> 01:12:11,330
complex data structures and algorithms

01:12:09,590 --> 01:12:13,300
and between the backend and the

01:12:11,330 --> 01:12:15,850
front-end so that we can do this planet

01:12:13,300 --> 01:12:17,030
reactive applications that are very

01:12:15,850 --> 01:12:20,840
feature-rich

01:12:17,030 --> 01:12:24,680
and accessing lots of data and the

01:12:20,840 --> 01:12:27,260
tooling the rust all of tool sets and as

01:12:24,680 --> 01:12:29,450
well as the normal one as well as the

01:12:27,260 --> 01:12:34,850
web one they work together they work

01:12:29,450 --> 01:12:36,200
together extremely well and it's we

01:12:34,850 --> 01:12:38,720
don't have the kind of problems that I

01:12:36,200 --> 01:12:42,620
have in the in the JavaScript ecosystem

01:12:38,720 --> 01:12:45,350
where you know some some tools I can get

01:12:42,620 --> 01:12:47,360
some framework to tool system to work

01:12:45,350 --> 01:12:49,240
with another one but I can't get it to

01:12:47,360 --> 01:12:52,670
work with the third one at the same time

01:12:49,240 --> 01:12:55,370
there's an just much more like

01:12:52,670 --> 01:12:58,730
convergence and rust ecosystem whippings

01:12:55,370 --> 01:13:00,800
and then of course the compiler is

01:12:58,730 --> 01:13:02,900
extremely powerful which allows you to

01:13:00,800 --> 01:13:08,020
build these kind of complicated

01:13:02,900 --> 01:13:11,780
applications and the performance and the

01:13:08,020 --> 01:13:15,110
zero cost abstractions in rust really

01:13:11,780 --> 01:13:16,630
good for hide heavy data running on

01:13:15,110 --> 01:13:20,150
Limited's

01:13:16,630 --> 01:13:22,100
on very limited machines and especially

01:13:20,150 --> 01:13:25,850
when you're doing things like animations

01:13:22,100 --> 01:13:32,180
which where you need to be non-blocking

01:13:25,850 --> 01:13:35,300
in front very quickly so yeah that's if

01:13:32,180 --> 01:13:39,170
you if you want to try it out you can go

01:13:35,300 --> 01:13:43,920
to the radar table and JK don't know and

01:13:39,170 --> 01:13:46,770
yeah and if you also want to contact

01:13:43,920 --> 01:13:50,220
about that you ingest it or have any

01:13:46,770 --> 01:13:54,740
questions and women dresses on here as

01:13:50,220 --> 01:13:54,740
well and I'm in the matrix chat as well

01:13:58,040 --> 01:14:03,600
thank you so much Mike

01:14:00,450 --> 01:14:06,420
I before mov up one question in the zoom

01:14:03,600 --> 01:14:08,760
chat but I have a question right away M

01:14:06,420 --> 01:14:11,610
is there the code like Emma do you have

01:14:08,760 --> 01:14:14,430
a github repository and Emma do you plan

01:14:11,610 --> 01:14:16,740
to write this up in some form of blog

01:14:14,430 --> 01:14:19,260
post serious I feel like that's quite a

01:14:16,740 --> 01:14:24,060
bit of content here like it would be

01:14:19,260 --> 01:14:25,560
nice to read up in our own time yeah I I

01:14:24,060 --> 01:14:28,290
would like to do that and I had actually

01:14:25,560 --> 01:14:29,970
intended to do that one sorry when I

01:14:28,290 --> 01:14:34,110
first started working on this project

01:14:29,970 --> 01:14:35,520
and but I am you know it's like I

01:14:34,110 --> 01:14:38,070
haven't really given presentations

01:14:35,520 --> 01:14:39,960
before when they haven't before so it's

01:14:38,070 --> 01:14:43,350
still something and trying to do but I

01:14:39,960 --> 01:14:45,330
think it's I am definitely interested in

01:14:43,350 --> 01:14:48,690
doing that they haven't posted the code

01:14:45,330 --> 01:14:50,550
I haven't published the code but it's is

01:14:48,690 --> 01:14:52,920
also something that I would be

01:14:50,550 --> 01:14:54,900
interested in doing as well I know I've

01:14:52,920 --> 01:14:58,020
done this in a very experimental wet so

01:14:54,900 --> 01:15:00,450
I feel like I was able to try out a lot

01:14:58,020 --> 01:15:01,710
of things because I didn't feel I didn't

01:15:00,450 --> 01:15:04,410
feel like anyone's going to be looking

01:15:01,710 --> 01:15:07,230
at it but and definitely are definitely

01:15:04,410 --> 01:15:10,770
interested in what people would like to

01:15:07,230 --> 01:15:12,590
see or and hear about his projects and I

01:15:10,770 --> 01:15:16,530
will try and write some things up yeah

01:15:12,590 --> 01:15:20,640
cool thanks and we have one question in

01:15:16,530 --> 01:15:22,650
the zoom chat which is didn't get if the

01:15:20,640 --> 01:15:25,170
client was a local process written in

01:15:22,650 --> 01:15:27,900
rust which exposes a web UI for the

01:15:25,170 --> 01:15:33,900
browser or if it was some other trick

01:15:27,900 --> 01:15:36,360
blossom like was it written and I hope

01:15:33,900 --> 01:15:40,860
would get the question right can you see

01:15:36,360 --> 01:15:43,530
the question yourself so it's Johannes

01:15:40,860 --> 01:15:46,860
didn't quite get if the client was a

01:15:43,530 --> 01:15:50,610
local process written in rust and then

01:15:46,860 --> 01:15:53,400
the web UI exit was exposed for the

01:15:50,610 --> 01:15:57,090
browser or if it was written in Boston

01:15:53,400 --> 01:15:59,790
Morrison the other framework

01:15:57,090 --> 01:16:02,070
they say the client is the client is

01:15:59,790 --> 01:16:05,190
written in rust and compared to wasn't

01:16:02,070 --> 01:16:09,390
and so it is running in the running in

01:16:05,190 --> 01:16:11,250
the browser and this is also why I could

01:16:09,390 --> 01:16:16,190
embed it here into my it's my

01:16:11,250 --> 01:16:28,320
presentation and just as a as a wasm

01:16:16,190 --> 01:16:29,460
script I think it does yeah it does

01:16:28,320 --> 01:16:33,840
perfect

01:16:29,460 --> 01:16:37,770
thank you so much okay another great

01:16:33,840 --> 01:16:45,660
talk now we have our ten minute break

01:16:37,770 --> 01:16:49,140
until 5:00 so a time 2025 or 8:25 Emma

01:16:45,660 --> 01:16:53,700
we are back here we break out now and we

01:16:49,140 --> 01:16:57,300
have 20 participants and soon we can

01:16:53,700 --> 01:17:00,180
have four breakout rooms with four to

01:16:57,300 --> 01:17:02,610
five participants so I'm feel free to

01:17:00,180 --> 01:17:06,600
chat if you don't want to chat you don't

01:17:02,610 --> 01:17:07,050
have to join and we see us back in ten

01:17:06,600 --> 01:17:10,010
minutes

01:17:07,050 --> 01:17:10,010
have fun

01:17:21,140 --> 01:17:23,200

YouTube URL: https://www.youtube.com/watch?v=X2MqRZIzdcM


