Title: Rust and Tell Berlin - July
Publication date: 2020-07-28
Playlist: Rust and Tell Berlin
Description: 
	“Rust and Tell“ is a monthly event to share ideas, and learn about new things in and about Rust. Meet fellow Rustaceans, share your learnings, get motivated and inspired.

https://berline.rs/2020/07/28/rust-and-tell.html

#1: 00:06:09 Implementing Fast Route Planning Algorithms in Rust by Payas Rajan
#2: 00:23:24 Rust'N'Games by Stephan Dilly
#3: 00:54:30 To the 90s and Back: Adventures in Rust COM Programming by Ryan Levick
#4: 01:24:20 zbus Announcement by Zeeshan
Captions: 
	00:00:04,319 --> 00:00:08,000
all right everybody good to go

00:00:06,160 --> 00:00:10,240
if you have your video on give me a

00:00:08,000 --> 00:00:13,280
thumbs up

00:00:10,240 --> 00:00:15,920
or a thumbs down if you don't want to go

00:00:13,280 --> 00:00:16,320
alright good cool so welcome everybody

00:00:15,920 --> 00:00:20,000
to

00:00:16,320 --> 00:00:23,119
another edition of rest and tell um

00:00:20,000 --> 00:00:23,920
we're very happy to to have you here uh

00:00:23,119 --> 00:00:26,080
welcome to

00:00:23,920 --> 00:00:27,840
all those who have been at a rest intel

00:00:26,080 --> 00:00:30,960
before either in person or

00:00:27,840 --> 00:00:31,599
online and welcome to everybody who is

00:00:30,960 --> 00:00:33,760
new

00:00:31,599 --> 00:00:36,079
um and might be joining us from berlin

00:00:33,760 --> 00:00:39,520
or beyond

00:00:36,079 --> 00:00:42,480
other places in this beautiful world

00:00:39,520 --> 00:00:43,280
a little bit about the organizers i'm

00:00:42,480 --> 00:00:46,480
ryan levick

00:00:43,280 --> 00:00:48,239
and you can find me on twitter at ryan

00:00:46,480 --> 00:00:50,719
underscore lubbock

00:00:48,239 --> 00:00:51,360
and i'll introduce myself a little bit

00:00:50,719 --> 00:00:54,960
later

00:00:51,360 --> 00:00:57,039
when i give my talk and hi and i'm

00:00:54,960 --> 00:00:58,399
busting grouper and you can find me on

00:00:57,039 --> 00:01:00,399
linkedin

00:00:58,399 --> 00:01:01,920
not on twitter and i'm happy to chat

00:01:00,399 --> 00:01:04,400
about

00:01:01,920 --> 00:01:05,680
like here like the language and if you

00:01:04,400 --> 00:01:08,880
want to use

00:01:05,680 --> 00:01:10,799
rust in a web development environment

00:01:08,880 --> 00:01:13,840
i'm always happy to talk and

00:01:10,799 --> 00:01:13,840
chat about your project

00:01:15,520 --> 00:01:18,720
so a little bit about the concept of the

00:01:18,000 --> 00:01:21,119
meetup

00:01:18,720 --> 00:01:22,880
uh rest intel is for beginners to

00:01:21,119 --> 00:01:25,439
experts to share your struggles

00:01:22,880 --> 00:01:26,799
ideas hacks projects anything and

00:01:25,439 --> 00:01:29,840
everything

00:01:26,799 --> 00:01:32,000
whether you're an advanced

00:01:29,840 --> 00:01:33,600
user of rust or just beginning with a

00:01:32,000 --> 00:01:35,840
language it doesn't matter

00:01:33,600 --> 00:01:37,280
whether you've been programming for 30

00:01:35,840 --> 00:01:39,840
40 50 years or

00:01:37,280 --> 00:01:40,560
just learned how to program yesterday we

00:01:39,840 --> 00:01:42,960
would love

00:01:40,560 --> 00:01:44,479
uh to hear your story this is really a

00:01:42,960 --> 00:01:45,600
space for the community to learn and

00:01:44,479 --> 00:01:48,880
grow together

00:01:45,600 --> 00:01:50,960
um and we are willing to

00:01:48,880 --> 00:01:51,920
take any and every talk and happy to

00:01:50,960 --> 00:01:54,240
help you grow your

00:01:51,920 --> 00:01:57,360
your talk even if it's only at the

00:01:54,240 --> 00:01:57,360
beginning of an idea

00:01:58,479 --> 00:02:02,240
and we also followed a berlin code of

00:02:01,360 --> 00:02:04,240
contact

00:02:02,240 --> 00:02:05,840
which is now the world code of contact

00:02:04,240 --> 00:02:08,560
if you join from

00:02:05,840 --> 00:02:11,680
from emma somewhere else then berlin

00:02:08,560 --> 00:02:15,360
it's um basically just to treat

00:02:11,680 --> 00:02:17,360
um the people here nicely and with

00:02:15,360 --> 00:02:20,560
respect and treat yourself with

00:02:17,360 --> 00:02:24,400
with um respect and if you

00:02:20,560 --> 00:02:24,800
encounter someone which is harassing you

00:02:24,400 --> 00:02:27,840
or

00:02:24,800 --> 00:02:29,599
is making mean comments or

00:02:27,840 --> 00:02:31,040
something else please feel free to get

00:02:29,599 --> 00:02:34,840
in touch

00:02:31,040 --> 00:02:37,760
with us we take those things very very

00:02:34,840 --> 00:02:40,550
seriously

00:02:37,760 --> 00:02:41,760
um since we are online now um

00:02:40,550 --> 00:02:44,239
[Music]

00:02:41,760 --> 00:02:44,800
we have a different emma setup than in

00:02:44,239 --> 00:02:47,280
person

00:02:44,800 --> 00:02:49,280
so we are am i using zoom and assume

00:02:47,280 --> 00:02:50,400
chat so emma during the talks you have

00:02:49,280 --> 00:02:52,800
the chance

00:02:50,400 --> 00:02:55,200
to ask any question and you can just

00:02:52,800 --> 00:02:58,080
them type them into the zoom chat

00:02:55,200 --> 00:02:59,599
we also have a have a matrix chat or

00:02:58,080 --> 00:03:03,840
what is called now

00:02:59,599 --> 00:03:05,519
element chat and after the second talk

00:03:03,840 --> 00:03:08,239
we will go into the zoom

00:03:05,519 --> 00:03:08,560
breakout rooms which means we will have

00:03:08,239 --> 00:03:12,319
um

00:03:08,560 --> 00:03:14,400
three or four rooms um

00:03:12,319 --> 00:03:16,720
where you can join and turn off your

00:03:14,400 --> 00:03:20,239
camera or you can just chat

00:03:16,720 --> 00:03:22,239
with the other people about anything

00:03:20,239 --> 00:03:24,239
you want and i mean you will get a

00:03:22,239 --> 00:03:26,879
notification after the second talk

00:03:24,239 --> 00:03:27,280
if you want to join this room and in

00:03:26,879 --> 00:03:30,080
case

00:03:27,280 --> 00:03:32,080
you don't want to feel free just to wait

00:03:30,080 --> 00:03:35,280
until the third talk starts

00:03:32,080 --> 00:03:37,120
um we will also um stream this live on

00:03:35,280 --> 00:03:38,239
our youtube and the recording will be

00:03:37,120 --> 00:03:41,599
afterwards on

00:03:38,239 --> 00:03:43,920
on youtube as well i think we uh

00:03:41,599 --> 00:03:45,200
we're not uh streaming live on youtube

00:03:43,920 --> 00:03:47,360
or streaming it on

00:03:45,200 --> 00:03:48,560
another platform we can paste the link

00:03:47,360 --> 00:03:51,040
to that okay

00:03:48,560 --> 00:03:52,720
to the zoom as well but the recording

00:03:51,040 --> 00:03:54,640
will be live on youtube and

00:03:52,720 --> 00:03:56,000
for those of you in the future watching

00:03:54,640 --> 00:03:59,840
this on youtube

00:03:56,000 --> 00:04:00,640
hello hey and yeah and um feel free to

00:03:59,840 --> 00:04:05,040
type any

00:04:00,640 --> 00:04:05,040
question you have in the chat rooms

00:04:07,760 --> 00:04:12,720
uh so just going back to what this uh

00:04:10,560 --> 00:04:16,160
meetup is about we really want you

00:04:12,720 --> 00:04:18,079
to come and give a talk we are always

00:04:16,160 --> 00:04:19,919
open to

00:04:18,079 --> 00:04:22,079
helping you with your talk so please

00:04:19,919 --> 00:04:24,240
please please even if you do not have

00:04:22,079 --> 00:04:25,199
a fully formed idea of what you want to

00:04:24,240 --> 00:04:27,680
talk about

00:04:25,199 --> 00:04:29,120
feel free to get in contact with us

00:04:27,680 --> 00:04:31,680
through meetup or on

00:04:29,120 --> 00:04:32,160
twitter linkedin wherever you happen to

00:04:31,680 --> 00:04:35,440
find

00:04:32,160 --> 00:04:36,080
either of us we are happy to work with

00:04:35,440 --> 00:04:37,759
you

00:04:36,080 --> 00:04:43,199
and we would love to hear from you and

00:04:37,759 --> 00:04:45,759
yes we really do mean you

00:04:43,199 --> 00:04:46,479
and also a thank you to jan eric for

00:04:45,759 --> 00:04:49,840
helping us

00:04:46,479 --> 00:04:50,639
once again with the setup um as always

00:04:49,840 --> 00:04:54,000
he has been

00:04:50,639 --> 00:04:56,479
uh very kind and patient with us as

00:04:54,000 --> 00:04:58,080
uh helping us with all the technologies

00:04:56,479 --> 00:04:59,280
of streaming that we have still not

00:04:58,080 --> 00:05:01,280
gotten a handle on

00:04:59,280 --> 00:05:02,800
so thank you yanav for your for your

00:05:01,280 --> 00:05:05,919
help there um

00:05:02,800 --> 00:05:05,919
we really appreciate it

00:05:06,479 --> 00:05:10,000
and um the talks for today um the first

00:05:09,680 --> 00:05:12,880
talk

00:05:10,000 --> 00:05:14,400
will be from uh from pious who joins us

00:05:12,880 --> 00:05:16,639
from california

00:05:14,400 --> 00:05:17,919
and he will talk about implementing fast

00:05:16,639 --> 00:05:20,639
route planning

00:05:17,919 --> 00:05:23,520
algorithms and the second talk will be

00:05:20,639 --> 00:05:26,639
from stefan he joins us from hamburg

00:05:23,520 --> 00:05:29,199
and he will talk about games and rust

00:05:26,639 --> 00:05:29,840
rust and games and then the last talk

00:05:29,199 --> 00:05:33,680
will be

00:05:29,840 --> 00:05:36,639
from ryan himself he will talk about

00:05:33,680 --> 00:05:38,160
windows in the early days and how to do

00:05:36,639 --> 00:05:42,639
something with rust

00:05:38,160 --> 00:05:42,639
i guess something along these lines

00:05:43,120 --> 00:05:46,320
yeah we'll see trust me it's going to be

00:05:45,919 --> 00:05:47,919
fun

00:05:46,320 --> 00:05:49,360
i can see people running for the hills

00:05:47,919 --> 00:05:51,199
now no it's going to be fun we're going

00:05:49,360 --> 00:05:54,320
to get into some fun stuff

00:05:51,199 --> 00:05:56,080
all right uh so with that um

00:05:54,320 --> 00:05:58,319
we are done with the introduction and

00:05:56,080 --> 00:05:58,880
then we're going to hand it off to pious

00:05:58,319 --> 00:06:07,840
for the

00:05:58,880 --> 00:06:07,840
first talk

00:06:10,560 --> 00:06:15,520
okay hello uh good evening

00:06:14,080 --> 00:06:17,680
thank you so much for coming i hope

00:06:15,520 --> 00:06:20,880
you're able to see my screen uh is it

00:06:17,680 --> 00:06:24,080
visible it is

00:06:20,880 --> 00:06:26,000
okay um okay let's start

00:06:24,080 --> 00:06:27,120
so again good evening and thank you so

00:06:26,000 --> 00:06:32,400
much for coming

00:06:27,120 --> 00:06:32,400
um in 2015

00:06:32,479 --> 00:06:37,199
nick cameron a research engineer at

00:06:34,800 --> 00:06:39,520
mozilla working on the rust compiler

00:06:37,199 --> 00:06:41,440
this blog called featherweight musings

00:06:39,520 --> 00:06:42,560
wrote a blog post that started with this

00:06:41,440 --> 00:06:44,479
sentence

00:06:42,560 --> 00:06:46,319
graphs are a bit awkward to construct

00:06:44,479 --> 00:06:48,560
and rust because of rus

00:06:46,319 --> 00:06:50,319
stringent lifetime and mutability

00:06:48,560 --> 00:06:53,039
requirements

00:06:50,319 --> 00:06:53,919
and uh internet being internet in

00:06:53,039 --> 00:06:56,319
responses to

00:06:53,919 --> 00:06:57,759
in response to nick's blog an anonymous

00:06:56,319 --> 00:07:00,720
stranger wrote

00:06:57,759 --> 00:07:00,720
it's not that hard guys

00:07:00,800 --> 00:07:04,960
after next post there were several

00:07:02,880 --> 00:07:06,639
similar posts about graphs and rust

00:07:04,960 --> 00:07:08,720
probably the most notable of them being

00:07:06,639 --> 00:07:10,400
written by nico matsakis called

00:07:08,720 --> 00:07:11,759
modeling graphs and rust using vector

00:07:10,400 --> 00:07:14,000
indices

00:07:11,759 --> 00:07:15,520
and all of these posts tries to answer

00:07:14,000 --> 00:07:17,120
the same question

00:07:15,520 --> 00:07:19,280
what is the correct representation of a

00:07:17,120 --> 00:07:20,960
graph without violating the rust body

00:07:19,280 --> 00:07:23,360
checking rules

00:07:20,960 --> 00:07:24,720
now this was five years ago where do we

00:07:23,360 --> 00:07:26,479
stand today

00:07:24,720 --> 00:07:28,160
the most popular creed providing the

00:07:26,479 --> 00:07:31,039
graph data structure appears to be

00:07:28,160 --> 00:07:33,759
one called pet graph which is downloaded

00:07:31,039 --> 00:07:36,240
about 9000 times every day

00:07:33,759 --> 00:07:37,120
but does having one excellent general

00:07:36,240 --> 00:07:40,400
purpose graph

00:07:37,120 --> 00:07:43,520
trade supplies for all use cases

00:07:40,400 --> 00:07:46,560
very likely not let me introduce to one

00:07:43,520 --> 00:07:48,560
such problem but we'll have to start

00:07:46,560 --> 00:07:51,759
from the first principles for that

00:07:48,560 --> 00:07:55,360
so let's look at what a graph is

00:07:51,759 --> 00:07:58,400
so a graph is composed of nodes edges

00:07:55,360 --> 00:08:00,240
and edge weights for the purposes of

00:07:58,400 --> 00:08:03,199
this talk we shall consider

00:08:00,240 --> 00:08:05,520
that uh only simple graphs so self loops

00:08:03,199 --> 00:08:07,120
and parallel edges are not allowed

00:08:05,520 --> 00:08:08,800
and we shall assume that edge weights

00:08:07,120 --> 00:08:12,479
are always positive integers

00:08:08,800 --> 00:08:13,919
so we shall relax this assumption later

00:08:12,479 --> 00:08:15,199
now the problem we are trying to solve

00:08:13,919 --> 00:08:16,080
is to find the shortest path from a

00:08:15,199 --> 00:08:19,199
source with a

00:08:16,080 --> 00:08:20,319
vertex s to a target vertex t on the

00:08:19,199 --> 00:08:23,360
graph

00:08:20,319 --> 00:08:25,120
and that looks simple right um well it's

00:08:23,360 --> 00:08:27,599
not so simple

00:08:25,120 --> 00:08:28,720
here's the real problem shown here are

00:08:27,599 --> 00:08:30,720
two road networks

00:08:28,720 --> 00:08:31,919
of new york city and the san francisco

00:08:30,720 --> 00:08:33,360
bay area

00:08:31,919 --> 00:08:34,479
which both have about three hundred

00:08:33,360 --> 00:08:36,159
thousand nodes and eight hundred

00:08:34,479 --> 00:08:37,680
thousand edges each

00:08:36,159 --> 00:08:40,320
and we need to find the shortest path

00:08:37,680 --> 00:08:42,320
between any two vertices or these graphs

00:08:40,320 --> 00:08:43,519
and the queries are required to be run

00:08:42,320 --> 00:08:46,640
in milliseconds

00:08:43,519 --> 00:08:48,480
or if possible even lesser than that the

00:08:46,640 --> 00:08:49,279
word shortest here is to be taken with a

00:08:48,480 --> 00:08:50,560
grain of salt

00:08:49,279 --> 00:08:53,120
because the parts don't have to be

00:08:50,560 --> 00:08:54,880
necessarily the physically shortest

00:08:53,120 --> 00:08:56,480
for example if you set the edge weights

00:08:54,880 --> 00:08:57,279
to the time taken to travel between

00:08:56,480 --> 00:08:59,360
nodes

00:08:57,279 --> 00:09:01,120
then the paths we get could be the

00:08:59,360 --> 00:09:03,680
quickest parts

00:09:01,120 --> 00:09:04,399
right so the classic solutions this

00:09:03,680 --> 00:09:06,800
problem is

00:09:04,399 --> 00:09:08,160
of course dijkstra's algorithm which is

00:09:06,800 --> 00:09:11,040
from his 1959

00:09:08,160 --> 00:09:12,959
paper called a note on two problems in

00:09:11,040 --> 00:09:15,279
connection with graphs

00:09:12,959 --> 00:09:16,160
and uh no that is not a typo in the

00:09:15,279 --> 00:09:18,080
title

00:09:16,160 --> 00:09:20,080
it is the archive word of this word

00:09:18,080 --> 00:09:21,760
connection

00:09:20,080 --> 00:09:23,120
um i'm glad that computer science has

00:09:21,760 --> 00:09:26,080
reached a milestone where we can find

00:09:23,120 --> 00:09:27,839
papers with archive words in the titles

00:09:26,080 --> 00:09:29,360
uh let's see what the algorithm looks

00:09:27,839 --> 00:09:30,640
like

00:09:29,360 --> 00:09:32,560
so here's a graph from our earlier

00:09:30,640 --> 00:09:34,640
example where we had

00:09:32,560 --> 00:09:36,080
uh where we've added the source s to a

00:09:34,640 --> 00:09:37,839
set of frontier nodes

00:09:36,080 --> 00:09:39,760
and the green labels on every vertex

00:09:37,839 --> 00:09:42,959
represents the best known distance

00:09:39,760 --> 00:09:45,680
from the source s to that vertex

00:09:42,959 --> 00:09:47,040
now we start relaxing edges on each

00:09:45,680 --> 00:09:49,200
iteration

00:09:47,040 --> 00:09:51,440
we take the shortest edge incident on

00:09:49,200 --> 00:09:53,680
the frontier so in this case it was

00:09:51,440 --> 00:09:53,680
00:09:57,680 --> 00:10:01,519
and we update the green labels on the

00:09:59,760 --> 00:10:02,720
nodes adjacent to the new frontier if

00:10:01,519 --> 00:10:06,000
needed

00:10:02,720 --> 00:10:07,760
so for example um in this

00:10:06,000 --> 00:10:09,920
in the example we took we have updated

00:10:07,760 --> 00:10:11,600
the label for this vertex

00:10:09,920 --> 00:10:12,959
because we found a new shortest path

00:10:11,600 --> 00:10:16,399
from s to this vertex

00:10:12,959 --> 00:10:19,440
we are the vertical on the top

00:10:16,399 --> 00:10:21,200
so we this uh the label uh reduced from

00:10:19,440 --> 00:10:23,440
infinity to five

00:10:21,200 --> 00:10:24,640
whereas the label for this vertex did

00:10:23,440 --> 00:10:26,720
not change

00:10:24,640 --> 00:10:28,880
since the new path that we found to the

00:10:26,720 --> 00:10:30,880
vertex is actually uh

00:10:28,880 --> 00:10:32,480
longer than the path that we already

00:10:30,880 --> 00:10:35,120
knew

00:10:32,480 --> 00:10:35,600
we keep doing this till we run out of

00:10:35,120 --> 00:10:39,200
nodes

00:10:35,600 --> 00:10:41,279
or till we find the target t

00:10:39,200 --> 00:10:42,399
the complexity of this algorithm from

00:10:41,279 --> 00:10:45,519
the original paper

00:10:42,399 --> 00:10:46,000
is order of v square but uh better

00:10:45,519 --> 00:10:48,959
algorithms

00:10:46,000 --> 00:10:50,720
have are known now and uh if we use

00:10:48,959 --> 00:10:52,800
fibonacci heaves and the best known

00:10:50,720 --> 00:10:53,920
complexity of this algorithm comes to be

00:10:52,800 --> 00:10:56,640
ordered off v log v

00:10:53,920 --> 00:10:59,360
plus e now we can do slightly better

00:10:56,640 --> 00:11:01,279
than this

00:10:59,360 --> 00:11:03,040
for an intuition let's say what happens

00:11:01,279 --> 00:11:03,839
if you start frontiers developing

00:11:03,040 --> 00:11:05,920
frontiers from

00:11:03,839 --> 00:11:07,360
both the source and the target so you

00:11:05,920 --> 00:11:08,800
develop a frontier from the source that

00:11:07,360 --> 00:11:10,720
goes in the forward direction

00:11:08,800 --> 00:11:12,000
and another one from the target in the

00:11:10,720 --> 00:11:13,600
reverse direction

00:11:12,000 --> 00:11:16,320
and wherever the both the frontiers

00:11:13,600 --> 00:11:16,959
overlap we can find at the shortest path

00:11:16,320 --> 00:11:19,440
using

00:11:16,959 --> 00:11:20,720
the overlap in the frontiers this

00:11:19,440 --> 00:11:23,040
version of dijkstra's algorithm is

00:11:20,720 --> 00:11:26,399
called the bi-directional bias algorithm

00:11:23,040 --> 00:11:26,399
now let's see how well it performs in

00:11:26,839 --> 00:11:29,839
practice

00:11:49,200 --> 00:11:53,680
so here i'm running the dijkstras a

00:11:52,079 --> 00:11:54,800
version of bi-directional textures

00:11:53,680 --> 00:11:56,880
running or

00:11:54,800 --> 00:11:59,200
implemented using rust and i'm running

00:11:56,880 --> 00:12:01,519
it on the road network of the bay area

00:11:59,200 --> 00:12:02,240
and i will be running it for 100 random

00:12:01,519 --> 00:12:11,839
queries

00:12:02,240 --> 00:12:11,839
that are generated on the fly

00:12:14,000 --> 00:12:17,200
right so since the queries are

00:12:15,600 --> 00:12:18,880
randomized we will see some minor

00:12:17,200 --> 00:12:21,040
variations in the time it takes

00:12:18,880 --> 00:12:23,279
for query but we can see that it takes

00:12:21,040 --> 00:12:24,560
approximately 10 to 15 milliseconds per

00:12:23,279 --> 00:12:26,240
query

00:12:24,560 --> 00:12:27,600
right and for every query we are

00:12:26,240 --> 00:12:28,880
settling approximately hundred thousand

00:12:27,600 --> 00:12:31,040
nodes

00:12:28,880 --> 00:12:32,959
and this is not good we can do something

00:12:31,040 --> 00:12:35,360
better than this

00:12:32,959 --> 00:12:36,079
so let's talk about contraction

00:12:35,360 --> 00:12:38,639
hierarchies

00:12:36,079 --> 00:12:39,680
which is what this talk is all about so

00:12:38,639 --> 00:12:41,680
in 2006

00:12:39,680 --> 00:12:43,920
the center for discrete mathematics and

00:12:41,680 --> 00:12:45,519
theoretical computer science at rutgers

00:12:43,920 --> 00:12:48,079
to cut the shortest path problem as a

00:12:45,519 --> 00:12:48,959
challenge research groups were asked for

00:12:48,079 --> 00:12:51,040
seven papers

00:12:48,959 --> 00:12:52,720
and out of it came a whole host of speed

00:12:51,040 --> 00:12:55,279
up techniques that could be used to make

00:12:52,720 --> 00:12:57,040
the shortest path computation faster

00:12:55,279 --> 00:12:58,480
one such technique is called highway

00:12:57,040 --> 00:13:01,200
hierarchies

00:12:58,480 --> 00:13:02,000
now the idea is simple the research has

00:13:01,200 --> 00:13:05,200
posited

00:13:02,000 --> 00:13:07,680
that not all edges in a graph have

00:13:05,200 --> 00:13:10,880
the same importance in a road network on

00:13:07,680 --> 00:13:12,720
one end there are local edges

00:13:10,880 --> 00:13:14,240
that have low edge weights and on the

00:13:12,720 --> 00:13:15,519
other end there are highways that have

00:13:14,240 --> 00:13:18,800
very high edge weights because they

00:13:15,519 --> 00:13:20,639
connect nodes that are very far apart

00:13:18,800 --> 00:13:21,839
routing now under this model becomes

00:13:20,639 --> 00:13:24,639
like driving

00:13:21,839 --> 00:13:26,560
to travel long distances you want to hop

00:13:24,639 --> 00:13:28,639
on the highway as soon as possible

00:13:26,560 --> 00:13:30,160
and keep driving on the highway only

00:13:28,639 --> 00:13:30,560
descending to the local roads when you

00:13:30,160 --> 00:13:32,800
reach

00:13:30,560 --> 00:13:34,639
close to your destination and this is

00:13:32,800 --> 00:13:36,320
exactly how our search works

00:13:34,639 --> 00:13:38,480
and if you have ever wondered why google

00:13:36,320 --> 00:13:39,440
maps takes you to highways even for

00:13:38,480 --> 00:13:42,880
short distances

00:13:39,440 --> 00:13:42,880
this is exactly the reason for it

00:13:43,040 --> 00:13:45,760
the most popular variant of this

00:13:44,480 --> 00:13:47,440
approach is called the contraction

00:13:45,760 --> 00:13:49,839
hierarchies or ch

00:13:47,440 --> 00:13:50,959
where instead of ranking edges we rank

00:13:49,839 --> 00:13:52,959
nodes

00:13:50,959 --> 00:13:55,040
so we assign a scalar importance to each

00:13:52,959 --> 00:13:57,440
vertex

00:13:55,040 --> 00:13:58,240
then we order the vertices in order of

00:13:57,440 --> 00:14:00,079
increasing

00:13:58,240 --> 00:14:01,360
order of their importance that we just

00:14:00,079 --> 00:14:04,399
assigned

00:14:01,360 --> 00:14:06,639
and finally all of this leads us

00:14:04,399 --> 00:14:08,399
to the applying the operation that gives

00:14:06,639 --> 00:14:11,440
ch its power

00:14:08,399 --> 00:14:14,560
shortcuts for example

00:14:11,440 --> 00:14:17,760
for the vertex v if u to v

00:14:14,560 --> 00:14:19,519
to w is the shortest path from u to w

00:14:17,760 --> 00:14:21,120
then we can add the shots and then we

00:14:19,519 --> 00:14:24,639
can add a shortcut u

00:14:21,120 --> 00:14:26,639
to w this operation is called the

00:14:24,639 --> 00:14:28,959
contraction operation

00:14:26,639 --> 00:14:30,399
and the benefit that it gives us is that

00:14:28,959 --> 00:14:32,480
all dijkstra is searching

00:14:30,399 --> 00:14:33,440
all dijkstra's searches that reach the

00:14:32,480 --> 00:14:36,720
vertex u

00:14:33,440 --> 00:14:39,600
can now reach the vertex w

00:14:36,720 --> 00:14:40,560
completely by passing the vertex v this

00:14:39,600 --> 00:14:43,760
gives us

00:14:40,560 --> 00:14:46,800
a nice speed up in the

00:14:43,760 --> 00:14:49,279
time for the dijkstras algorithm

00:14:46,800 --> 00:14:50,560
so in the running example that we have

00:14:49,279 --> 00:14:53,600
taken so far

00:14:50,560 --> 00:14:56,360
if i contract the if the

00:14:53,600 --> 00:14:59,040
numbers in red are the importance of the

00:14:56,360 --> 00:15:01,199
vertices uh

00:14:59,040 --> 00:15:02,800
and if we uh if we apply the contraction

00:15:01,199 --> 00:15:03,360
operation to all the vertices in this

00:15:02,800 --> 00:15:06,000
graph

00:15:03,360 --> 00:15:06,399
we will find that we have we will be

00:15:06,000 --> 00:15:08,720
adding

00:15:06,399 --> 00:15:10,800
two edges so one from 11 to 13 and

00:15:08,720 --> 00:15:12,639
another from 12 to 13.

00:15:10,800 --> 00:15:13,760
and in this case we have assumed that

00:15:12,639 --> 00:15:16,480
all edges in this graph are

00:15:13,760 --> 00:15:16,480
bi-directional

00:15:18,240 --> 00:15:22,800
now here's something to think about we

00:15:21,120 --> 00:15:25,600
added edges to the graph

00:15:22,800 --> 00:15:26,000
and we made the graph bigger in order to

00:15:25,600 --> 00:15:29,120
compute

00:15:26,000 --> 00:15:29,120
the shortest paths faster

00:15:31,040 --> 00:15:35,040
there's also something that we need to

00:15:33,279 --> 00:15:37,279
change with the query algorithm

00:15:35,040 --> 00:15:38,959
so contraction hierarchies is kind of

00:15:37,279 --> 00:15:40,560
like building an index on the graph it's

00:15:38,959 --> 00:15:41,519
not exactly like building an index but

00:15:40,560 --> 00:15:43,199
it's like

00:15:41,519 --> 00:15:45,199
adding more information to the graph

00:15:43,199 --> 00:15:47,519
that can uh supplemental information to

00:15:45,199 --> 00:15:50,880
the graph that can help your

00:15:47,519 --> 00:15:54,320
searches run faster but uh we cannot run

00:15:50,880 --> 00:15:54,560
regular bi-directional textures uh for

00:15:54,320 --> 00:15:58,000
the

00:15:54,560 --> 00:16:01,279
query algorithm we need to restrict

00:15:58,000 --> 00:16:03,120
our algorithm to run only in directions

00:16:01,279 --> 00:16:05,519
so the forward search goes only from

00:16:03,120 --> 00:16:07,600
vertices that are have low importance

00:16:05,519 --> 00:16:09,279
to vertices that have high importance

00:16:07,600 --> 00:16:11,120
and the backward search goes from

00:16:09,279 --> 00:16:14,399
vertices that have high importance to

00:16:11,120 --> 00:16:14,399
those that have lower importance

00:16:14,800 --> 00:16:18,959
right so in the example that we took the

00:16:17,279 --> 00:16:20,720
forward search goes from one

00:16:18,959 --> 00:16:23,040
to all the nodes where the neighboring

00:16:20,720 --> 00:16:25,040
nodes are bigger than one

00:16:23,040 --> 00:16:26,560
are bigger than the neighbor are bigger

00:16:25,040 --> 00:16:28,959
than the

00:16:26,560 --> 00:16:30,079
neighbors and the backward switch goes

00:16:28,959 --> 00:16:32,800
from 13

00:16:30,079 --> 00:16:34,079
to 4 because 13 is the largest vertex 13

00:16:32,800 --> 00:16:35,279
is the largest in terms of its

00:16:34,079 --> 00:16:37,279
importance and then

00:16:35,279 --> 00:16:38,800
the search goes from 13 to all the

00:16:37,279 --> 00:16:40,800
vertices that it can reach

00:16:38,800 --> 00:16:42,720
where the importance is lower than the

00:16:40,800 --> 00:16:46,480
neighboring vertex

00:16:42,720 --> 00:16:48,839
right and now you might think

00:16:46,480 --> 00:16:51,839
what does any of this have to do with

00:16:48,839 --> 00:16:51,839
rust

00:16:51,920 --> 00:16:55,759
give me a moment we shall come to rust i

00:16:54,000 --> 00:16:58,560
promise

00:16:55,759 --> 00:17:00,320
now remember how we started talking uh

00:16:58,560 --> 00:17:02,800
in this talk about general purpose graph

00:17:00,320 --> 00:17:05,280
libraries when we started

00:17:02,800 --> 00:17:07,039
the problem with those libraries is that

00:17:05,280 --> 00:17:07,760
they often don't implement specialized

00:17:07,039 --> 00:17:10,559
algorithms

00:17:07,760 --> 00:17:12,079
such as contraction hierarchies and that

00:17:10,559 --> 00:17:13,839
is understandable

00:17:12,079 --> 00:17:15,199
these libraries are designed to solve a

00:17:13,839 --> 00:17:17,439
broad set of problems

00:17:15,199 --> 00:17:19,199
for most people and implementing such

00:17:17,439 --> 00:17:20,240
specialized algorithms is clearly beyond

00:17:19,199 --> 00:17:21,520
their scope

00:17:20,240 --> 00:17:23,360
but there's something that we can learn

00:17:21,520 --> 00:17:26,400
from them which is

00:17:23,360 --> 00:17:28,079
how to represent a graph edges

00:17:26,400 --> 00:17:29,600
how to represent vertices and how to

00:17:28,079 --> 00:17:31,039
represent edge weights and how to

00:17:29,600 --> 00:17:32,640
represent the operations that are

00:17:31,039 --> 00:17:34,400
allowed on the edges and the edge

00:17:32,640 --> 00:17:37,120
weights of the graph

00:17:34,400 --> 00:17:38,720
right so for example let's look at c

00:17:37,120 --> 00:17:41,280
plus plus

00:17:38,720 --> 00:17:42,559
so how do we represent graphs the

00:17:41,280 --> 00:17:43,919
correct answer to that would be

00:17:42,559 --> 00:17:45,919
adjacency list

00:17:43,919 --> 00:17:47,120
unless you are representing very small

00:17:45,919 --> 00:17:48,880
graphs which is not the case

00:17:47,120 --> 00:17:50,880
clearly not the case in the problem that

00:17:48,880 --> 00:17:53,600
we're trying to solve here

00:17:50,880 --> 00:17:55,919
right so let's look at a standard

00:17:53,600 --> 00:17:59,039
c-class plus graph library let's look at

00:17:55,919 --> 00:17:59,440
boost graph library right and as soon as

00:17:59,039 --> 00:18:01,360
you

00:17:59,440 --> 00:18:03,360
uh start looking through the boost graph

00:18:01,360 --> 00:18:05,760
code the first thing that strikes you

00:18:03,360 --> 00:18:06,720
is that the library is chock full of

00:18:05,760 --> 00:18:08,640
trades

00:18:06,720 --> 00:18:10,640
for everything from deciding whether the

00:18:08,640 --> 00:18:12,240
graph is stored as an additional list or

00:18:10,640 --> 00:18:14,320
an adjacency matrix

00:18:12,240 --> 00:18:15,520
to deciding whether edges are directed

00:18:14,320 --> 00:18:18,960
or undirected

00:18:15,520 --> 00:18:20,960
everything is handled using traits

00:18:18,960 --> 00:18:22,720
and even more important than that the

00:18:20,960 --> 00:18:23,280
operations allowed on different types of

00:18:22,720 --> 00:18:26,320
nodes

00:18:23,280 --> 00:18:28,720
edges edge weights are decided

00:18:26,320 --> 00:18:30,559
using traits and traits are not a first

00:18:28,720 --> 00:18:33,760
class citizen in c plus plus

00:18:30,559 --> 00:18:35,360
which makes these implementations um

00:18:33,760 --> 00:18:36,880
probably easy to use when you're using

00:18:35,360 --> 00:18:39,280
something like boost but

00:18:36,880 --> 00:18:40,320
really difficult to do it yourself and

00:18:39,280 --> 00:18:43,360
this is where

00:18:40,320 --> 00:18:44,799
rust steps in now traits are a first

00:18:43,360 --> 00:18:47,600
class citizen and trust

00:18:44,799 --> 00:18:49,280
so it is no surprise that rust makes it

00:18:47,600 --> 00:18:51,200
incredibly easy to implement generic

00:18:49,280 --> 00:18:53,200
graphs deal structures

00:18:51,200 --> 00:18:55,200
uh for example we have here i

00:18:53,200 --> 00:18:57,120
implemented uh this is the code from the

00:18:55,200 --> 00:19:00,160
project that i implemented which is

00:18:57,120 --> 00:19:03,280
that you can implement the trade

00:19:00,160 --> 00:19:05,039
and a trade of an edge so every struct

00:19:03,280 --> 00:19:05,760
that implements this edge straight can

00:19:05,039 --> 00:19:08,880
be used as an

00:19:05,760 --> 00:19:12,000
edge and then a graph

00:19:08,880 --> 00:19:12,960
contains a vector of a vector of an edge

00:19:12,000 --> 00:19:16,880
of a set of

00:19:12,960 --> 00:19:20,080
uh structs that implement the edge rate

00:19:16,880 --> 00:19:23,200
right now

00:19:20,080 --> 00:19:26,320
the bigger thing here to notice is

00:19:23,200 --> 00:19:29,440
that it's extremely easy to say

00:19:26,320 --> 00:19:33,280
to apply constraints on the type

00:19:29,440 --> 00:19:36,480
weight here so it's easy to say

00:19:33,280 --> 00:19:39,840
w colon bit rate plus add

00:19:36,480 --> 00:19:42,080
output equals to w plus debug

00:19:39,840 --> 00:19:42,880
this way what we have constrained our

00:19:42,080 --> 00:19:45,200
type

00:19:42,880 --> 00:19:46,320
uh edge weight we have constrained our

00:19:45,200 --> 00:19:49,120
edge way to always be of

00:19:46,320 --> 00:19:49,840
type that implements the operator plus

00:19:49,120 --> 00:19:53,600
doing this in c

00:19:49,840 --> 00:19:56,080
plus plus is neither fun and not easy

00:19:53,600 --> 00:19:57,440
i mean uh this would require something

00:19:56,080 --> 00:19:59,600
like a boost

00:19:57,440 --> 00:20:01,360
the boost conception library but that is

00:19:59,600 --> 00:20:03,919
an additional dependency that

00:20:01,360 --> 00:20:04,720
uh needs to be pulled in and maintained

00:20:03,919 --> 00:20:06,000
over time

00:20:04,720 --> 00:20:08,559
which is again not a very pleasant

00:20:06,000 --> 00:20:10,559
experience um

00:20:08,559 --> 00:20:12,320
so i have been working on this for some

00:20:10,559 --> 00:20:16,159
time now for about a year

00:20:12,320 --> 00:20:20,159
and the results that i've been getting

00:20:16,159 --> 00:20:21,919
are pretty good and let's see and

00:20:20,159 --> 00:20:23,280
of course uh since it's dressed the

00:20:21,919 --> 00:20:25,120
performance is also pretty good

00:20:23,280 --> 00:20:26,559
it's only so there's ease of use and

00:20:25,120 --> 00:20:27,600
there's performance as well

00:20:26,559 --> 00:20:30,159
so let's look at how good the

00:20:27,600 --> 00:20:30,159
performance is

00:20:31,039 --> 00:20:35,679
this is again running uh 100 queries on

00:20:34,320 --> 00:20:36,480
the same graph that we looked at last

00:20:35,679 --> 00:20:39,600
time

00:20:36,480 --> 00:20:41,760
but you can easily see that the

00:20:39,600 --> 00:20:43,360
runtime has come down for every query

00:20:41,760 --> 00:20:46,480
from 14 milliseconds

00:20:43,360 --> 00:20:48,000
to 17 microseconds and the reason for

00:20:46,480 --> 00:20:50,080
this is because we can we have

00:20:48,000 --> 00:20:51,360
drastically reduced the search space the

00:20:50,080 --> 00:20:53,039
average source space

00:20:51,360 --> 00:20:55,280
for the dijkstra's queries that are

00:20:53,039 --> 00:20:57,120
running on the graph

00:20:55,280 --> 00:20:58,960
right we can try running it a couple of

00:20:57,120 --> 00:21:01,919
more times just to be sure that

00:20:58,960 --> 00:21:04,720
uh these randomized queries were not a

00:21:01,919 --> 00:21:04,720
good case for us

00:21:05,679 --> 00:21:17,840
and again we are at 18 microseconds

00:21:09,200 --> 00:21:17,840
and let's try one more run

00:21:18,960 --> 00:21:22,400
that's it so we are seeing an order of

00:21:20,799 --> 00:21:25,679
magnitude difference

00:21:22,400 --> 00:21:27,760
using these algorithms and uh

00:21:25,679 --> 00:21:29,520
yeah so in the end i mean in conclusion

00:21:27,760 --> 00:21:31,520
i would like to say that rust

00:21:29,520 --> 00:21:32,720
is excellent for implementing graphs the

00:21:31,520 --> 00:21:35,760
performance is good

00:21:32,720 --> 00:21:37,600
uh if you are familiar with uh get

00:21:35,760 --> 00:21:42,720
familiar with rates and if you think

00:21:37,600 --> 00:21:44,240
uh it makes it really easy to

00:21:42,720 --> 00:21:45,520
implement the same algorithm and then

00:21:44,240 --> 00:21:47,760
use it again and again for different

00:21:45,520 --> 00:21:49,760
types of edge reads and edges and

00:21:47,760 --> 00:21:51,360
all of the operations become really easy

00:21:49,760 --> 00:21:59,840
while the performance is maintained

00:21:51,360 --> 00:21:59,840
at the same level thank you

00:22:01,200 --> 00:22:04,480
okay thank you so much

00:22:04,799 --> 00:22:08,000
this was fascinating

00:22:09,039 --> 00:22:15,760
um i'm looking for questions and then

00:22:12,559 --> 00:22:19,039
the chat and the zoom chat have

00:22:15,760 --> 00:22:22,880
no questions people were

00:22:19,039 --> 00:22:22,880
either lost or still amazed

00:22:24,559 --> 00:22:28,880
do you have this i'm somewhere in a in a

00:22:27,200 --> 00:22:31,120
productive

00:22:28,880 --> 00:22:32,799
environment or could you take out some

00:22:31,120 --> 00:22:36,880
parts of it for a

00:22:32,799 --> 00:22:39,200
real world application

00:22:36,880 --> 00:22:41,120
uh when this is actually a library that

00:22:39,200 --> 00:22:42,000
i'm planning that i'm using for a paper

00:22:41,120 --> 00:22:44,080
that i'm uh

00:22:42,000 --> 00:22:45,600
we are planning to write next and uh

00:22:44,080 --> 00:22:47,679
when the paper comes out we'll probably

00:22:45,600 --> 00:22:48,640
open source library as well there's

00:22:47,679 --> 00:22:49,919
already a

00:22:48,640 --> 00:22:51,760
really really nice contraction

00:22:49,919 --> 00:22:53,360
hierarchies library interest called fast

00:22:51,760 --> 00:22:56,000
underscore paths

00:22:53,360 --> 00:22:57,840
so if you need it in production then uh

00:22:56,000 --> 00:23:00,960
maybe i would recommend checking it

00:22:57,840 --> 00:23:02,880
out cool

00:23:00,960 --> 00:23:04,799
did you compare the your results with

00:23:02,880 --> 00:23:05,679
the with an implementation from c plus

00:23:04,799 --> 00:23:08,480
plus

00:23:05,679 --> 00:23:10,559
yes i did and we are either equal or

00:23:08,480 --> 00:23:13,919
better

00:23:10,559 --> 00:23:16,240
in all the benchmarks we have okay

00:23:13,919 --> 00:23:16,240
nice

00:23:17,280 --> 00:23:24,240
okay thank you again and now off to you

00:23:21,120 --> 00:23:27,440
stefan yes

00:23:24,240 --> 00:23:27,440
let me share my screen

00:23:29,440 --> 00:23:31,919
can you see

00:23:33,200 --> 00:23:38,720
okay so

00:23:36,640 --> 00:23:41,760
i think it's already two months since my

00:23:38,720 --> 00:23:44,240
last uh rust intel presentation

00:23:41,760 --> 00:23:44,799
and uh this this time it will be quite

00:23:44,240 --> 00:23:47,840
different

00:23:44,799 --> 00:23:49,279
um because i'm actually talking about my

00:23:47,840 --> 00:23:52,240
my day-to-day business

00:23:49,279 --> 00:23:52,960
which is in games actually i've

00:23:52,240 --> 00:23:56,000
developed

00:23:52,960 --> 00:23:57,760
games for the last 13 years and

00:23:56,000 --> 00:23:59,760
over the last one and a half years

00:23:57,760 --> 00:24:03,520
roughly it's more and more

00:23:59,760 --> 00:24:06,320
happening is in in rust as well so

00:24:03,520 --> 00:24:06,960
when i was asked to to uh quickly maybe

00:24:06,320 --> 00:24:09,679
um

00:24:06,960 --> 00:24:10,559
talk about this topic i i gladly accept

00:24:09,679 --> 00:24:12,320
it because uh

00:24:10,559 --> 00:24:14,159
of course this is something that's

00:24:12,320 --> 00:24:17,840
that's dear to my heart

00:24:14,159 --> 00:24:18,559
and um uh not let not that the talk from

00:24:17,840 --> 00:24:21,840
last time

00:24:18,559 --> 00:24:22,480
wasn't as well but um the kind of

00:24:21,840 --> 00:24:25,600
graphics

00:24:22,480 --> 00:24:26,159
uh fidelity that we had had last time in

00:24:25,600 --> 00:24:30,080
my

00:24:26,159 --> 00:24:31,679
little gui tui application

00:24:30,080 --> 00:24:33,440
what is maybe lacking when we are

00:24:31,679 --> 00:24:36,480
talking about modern games

00:24:33,440 --> 00:24:37,600
so um today we are talking about games

00:24:36,480 --> 00:24:40,640
that we are building

00:24:37,600 --> 00:24:42,880
as a company and uh the first one of

00:24:40,640 --> 00:24:44,880
these is actually called stack four

00:24:42,880 --> 00:24:46,640
which we started working on um beginning

00:24:44,880 --> 00:25:01,840
of last year

00:24:46,640 --> 00:25:01,840
and you can get a quick glimpse here

00:25:05,760 --> 00:25:12,799
so yeah stack 4 is a 3d game

00:25:09,200 --> 00:25:16,640
of connect 4 and it's out for mobile

00:25:12,799 --> 00:25:18,960
in canada right now in a so-called uh

00:25:16,640 --> 00:25:20,799
silent launch so basically trying to

00:25:18,960 --> 00:25:23,440
iron out the last couple of bucks

00:25:20,799 --> 00:25:24,799
and uh seeing how people react to it and

00:25:23,440 --> 00:25:27,360
um

00:25:24,799 --> 00:25:28,640
it's on it runs on the platforms of ios

00:25:27,360 --> 00:25:31,840
and android

00:25:28,640 --> 00:25:33,840
and the reason why i picked rust

00:25:31,840 --> 00:25:35,679
in this particular case was that i

00:25:33,840 --> 00:25:38,080
wanted to have a

00:25:35,679 --> 00:25:39,679
authoritative server implementation that

00:25:38,080 --> 00:25:42,240
was supposed to implement the actual

00:25:39,679 --> 00:25:44,080
game logic of connect four

00:25:42,240 --> 00:25:45,760
and i didn't want to duplicate basically

00:25:44,080 --> 00:25:49,039
code between front end and back end

00:25:45,760 --> 00:25:50,080
so the engine that i'm using in this

00:25:49,039 --> 00:25:54,159
particular project

00:25:50,080 --> 00:25:56,480
is unity and i think

00:25:54,159 --> 00:25:57,440
replicating the kind of complexity that

00:25:56,480 --> 00:26:00,720
this sort of

00:25:57,440 --> 00:26:02,559
uh mature engine gives us was definitely

00:26:00,720 --> 00:26:05,200
out of scope for this project so we

00:26:02,559 --> 00:26:05,600
stuck to to what we were used to which

00:26:05,200 --> 00:26:08,640
is

00:26:05,600 --> 00:26:11,120
using such engines and um

00:26:08,640 --> 00:26:12,159
i still wanted to use the opportunity to

00:26:11,120 --> 00:26:15,200
to benefit from

00:26:12,159 --> 00:26:15,520
from rust's uh features in a sense that

00:26:15,200 --> 00:26:17,200
i

00:26:15,520 --> 00:26:19,120
was really focused on performance when

00:26:17,200 --> 00:26:20,000
it came to the ai implementation and

00:26:19,120 --> 00:26:22,400
maybe you can

00:26:20,000 --> 00:26:24,000
look at the actual tech that i'm uh that

00:26:22,400 --> 00:26:25,919
that is used in here

00:26:24,000 --> 00:26:27,120
so there is a core library that

00:26:25,919 --> 00:26:29,760
implements the game logic

00:26:27,120 --> 00:26:32,320
in rust and that is used between uh

00:26:29,760 --> 00:26:35,440
shared between front end and back end

00:26:32,320 --> 00:26:37,919
and uh i mean the the the major

00:26:35,440 --> 00:26:38,560
uh reason for that for this was to have

00:26:37,919 --> 00:26:40,159
a fast

00:26:38,560 --> 00:26:42,000
[Music]

00:26:40,159 --> 00:26:43,200
ai implementation because that is

00:26:42,000 --> 00:26:45,919
actually something

00:26:43,200 --> 00:26:46,880
that i knew from the past would be um

00:26:45,919 --> 00:26:49,200
could be a

00:26:46,880 --> 00:26:50,640
potential bottleneck doing it in a in a

00:26:49,200 --> 00:26:52,799
managed language like

00:26:50,640 --> 00:26:54,320
c-sharp which is the main language you

00:26:52,799 --> 00:26:56,159
are using when you are writing your game

00:26:54,320 --> 00:26:59,039
in unity

00:26:56,159 --> 00:27:00,799
so um yeah and the and the additional

00:26:59,039 --> 00:27:01,600
plus side for me was that i wanted to be

00:27:00,799 --> 00:27:03,600
able to check

00:27:01,600 --> 00:27:06,080
those uh calculations on the back end

00:27:03,600 --> 00:27:09,440
and validate uh that no one is cheating

00:27:06,080 --> 00:27:11,120
so it was kind of straightforward to

00:27:09,440 --> 00:27:12,880
look for a technology that would be able

00:27:11,120 --> 00:27:16,320
to run on both sides

00:27:12,880 --> 00:27:17,039
and um you can see already this is also

00:27:16,320 --> 00:27:19,679
using go

00:27:17,039 --> 00:27:21,120
in the back end and that is because back

00:27:19,679 --> 00:27:24,480
in uh 2008

00:27:21,120 --> 00:27:25,520
and beginning of 2019 when we started

00:27:24,480 --> 00:27:28,320
with this

00:27:25,520 --> 00:27:29,279
um the whole async await and and

00:27:28,320 --> 00:27:31,840
back-end

00:27:29,279 --> 00:27:33,039
framework landscape for me was still

00:27:31,840 --> 00:27:36,080
looking to

00:27:33,039 --> 00:27:38,399
um unstable let's say for me to to

00:27:36,080 --> 00:27:41,520
really make the call to go full on rust

00:27:38,399 --> 00:27:43,120
so there's sort of a step in between

00:27:41,520 --> 00:27:45,520
that we did for stack four

00:27:43,120 --> 00:27:46,399
which is that we are using actually uh

00:27:45,520 --> 00:27:49,440
go as

00:27:46,399 --> 00:27:52,559
the server implementation framework

00:27:49,440 --> 00:27:54,640
and this is also using the same c

00:27:52,559 --> 00:27:56,159
based rust library that the front end is

00:27:54,640 --> 00:27:59,360
also using

00:27:56,159 --> 00:28:01,279
so sort of a hackish kind of thing

00:27:59,360 --> 00:28:03,440
but it worked really well for us because

00:28:01,279 --> 00:28:05,600
the really performance critical code

00:28:03,440 --> 00:28:08,240
that needed to be as fast as possible

00:28:05,600 --> 00:28:09,919
uh was still written in rust and

00:28:08,240 --> 00:28:12,880
benefited from all those

00:28:09,919 --> 00:28:14,720
benefits that we got from from this full

00:28:12,880 --> 00:28:15,600
control over the memory management for

00:28:14,720 --> 00:28:17,440
example

00:28:15,600 --> 00:28:19,279
and we will see a little bit more about

00:28:17,440 --> 00:28:21,919
that later as well

00:28:19,279 --> 00:28:23,600
so the next project is called tower

00:28:21,919 --> 00:28:27,440
rangers

00:28:23,600 --> 00:28:28,960
and you can see some moving animations

00:28:27,440 --> 00:28:31,440
in here

00:28:28,960 --> 00:28:32,640
this is a tower defense based mechanic

00:28:31,440 --> 00:28:34,640
um so

00:28:32,640 --> 00:28:36,159
you can see towers that are shooting

00:28:34,640 --> 00:28:39,200
kind of entities

00:28:36,159 --> 00:28:41,360
and this was a step into

00:28:39,200 --> 00:28:42,960
into a much more complex direction with

00:28:41,360 --> 00:28:58,880
this project

00:28:42,960 --> 00:29:01,120
so it's much more interesting

00:28:58,880 --> 00:29:02,720
i hope i didn't destroy any ears here um

00:29:01,120 --> 00:29:03,679
it definitely was very loud on my

00:29:02,720 --> 00:29:06,480
machine

00:29:03,679 --> 00:29:08,080
um as you can see in this in this short

00:29:06,480 --> 00:29:09,760
video it's it's much more

00:29:08,080 --> 00:29:12,080
interactive there's much more going on

00:29:09,760 --> 00:29:14,720
there's much more real time involved

00:29:12,080 --> 00:29:16,159
and so it was a much more interesting

00:29:14,720 --> 00:29:19,600
use case for us

00:29:16,159 --> 00:29:21,600
and um yeah it's pretty much the same

00:29:19,600 --> 00:29:23,679
kind of approach that i started out with

00:29:21,600 --> 00:29:26,000
here as in stack 4 was to first

00:29:23,679 --> 00:29:27,360
figure out a core game logic that was

00:29:26,000 --> 00:29:30,640
written in rust anyway

00:29:27,360 --> 00:29:31,760
but then i also took the next step and

00:29:30,640 --> 00:29:34,240
kind of decided okay

00:29:31,760 --> 00:29:35,760
let's get rid of this whole go thing we

00:29:34,240 --> 00:29:38,320
are talking about

00:29:35,760 --> 00:29:39,200
middle of or end of last year so for me

00:29:38,320 --> 00:29:41,919
it was definitely

00:29:39,200 --> 00:29:43,120
interesting to to start using one of

00:29:41,919 --> 00:29:46,000
those async

00:29:43,120 --> 00:29:47,840
frameworks uh in rust and and give this

00:29:46,000 --> 00:29:51,120
whole back end a complete rust

00:29:47,840 --> 00:29:53,919
kind of foundation so um this is what we

00:29:51,120 --> 00:29:55,039
what we did here and um the project is

00:29:53,919 --> 00:29:57,440
still in prototype

00:29:55,039 --> 00:29:58,399
phase so it's not something you can play

00:29:57,440 --> 00:30:00,880
out

00:29:58,399 --> 00:30:03,039
out there but it's something we are very

00:30:00,880 --> 00:30:05,600
interested in in proceeding with

00:30:03,039 --> 00:30:06,240
since uh the whole technology behind it

00:30:05,600 --> 00:30:08,559
is

00:30:06,240 --> 00:30:09,600
super interesting for us and the kind of

00:30:08,559 --> 00:30:11,919
game mechanic

00:30:09,600 --> 00:30:14,000
is super promising because we are kind

00:30:11,919 --> 00:30:14,880
of i don't want to go too deeply into

00:30:14,000 --> 00:30:17,840
the game

00:30:14,880 --> 00:30:19,360
design kind of uh considerations here

00:30:17,840 --> 00:30:22,720
but for us this was a very

00:30:19,360 --> 00:30:24,799
interesting combination of two genres

00:30:22,720 --> 00:30:27,200
and something that we didn't see a lot

00:30:24,799 --> 00:30:28,399
out there in the wild

00:30:27,200 --> 00:30:30,480
but when it comes to the actual

00:30:28,399 --> 00:30:32,399
technology was was some

00:30:30,480 --> 00:30:34,720
some things that we that we stepped up

00:30:32,399 --> 00:30:36,960
from from the last project in this one

00:30:34,720 --> 00:30:37,840
and in particular i wanted to highlight

00:30:36,960 --> 00:30:39,600
two of them

00:30:37,840 --> 00:30:41,200
which is i mean first of all i mentioned

00:30:39,600 --> 00:30:42,960
it already there is no go involved in

00:30:41,200 --> 00:30:45,039
this project anymore so the whole back

00:30:42,960 --> 00:30:47,360
end is completely written in rust

00:30:45,039 --> 00:30:49,679
but there is a clear separation between

00:30:47,360 --> 00:30:52,240
the game logic

00:30:49,679 --> 00:30:53,760
and the whole back-end api

00:30:52,240 --> 00:30:56,000
implementation because

00:30:53,760 --> 00:30:57,039
the game logic again is also shared with

00:30:56,000 --> 00:31:00,799
the front end

00:30:57,039 --> 00:31:03,519
so the the the complexity of this kind

00:31:00,799 --> 00:31:04,000
kind of game makes it requires us to do

00:31:03,519 --> 00:31:06,880
a lot of

00:31:04,000 --> 00:31:08,399
uh extrapolations on the front-end side

00:31:06,880 --> 00:31:10,000
to be able to know what

00:31:08,399 --> 00:31:11,919
happens in the next couple of seconds in

00:31:10,000 --> 00:31:14,399
the game play without always

00:31:11,919 --> 00:31:16,080
synchronizing tons of entities between

00:31:14,399 --> 00:31:18,559
uh front-end and back-end

00:31:16,080 --> 00:31:19,760
and so we kind of took this approach to

00:31:18,559 --> 00:31:22,960
have a deterministic

00:31:19,760 --> 00:31:24,799
uh logic implementation that is run on

00:31:22,960 --> 00:31:26,000
both sides basically on the front end

00:31:24,799 --> 00:31:28,799
and the back end

00:31:26,000 --> 00:31:29,519
and we kind of only synchronize between

00:31:28,799 --> 00:31:32,399
those two

00:31:29,519 --> 00:31:34,240
the input events that are happening this

00:31:32,399 --> 00:31:37,200
is kind of a standard approach

00:31:34,240 --> 00:31:39,840
in gaming but it's uh it's something

00:31:37,200 --> 00:31:42,159
that made it super easy for us to reuse

00:31:39,840 --> 00:31:43,519
again this kind of logic library on both

00:31:42,159 --> 00:31:44,799
sides

00:31:43,519 --> 00:31:46,720
but something that that we did

00:31:44,799 --> 00:31:48,480
differently here um

00:31:46,720 --> 00:31:50,480
i wanted to highlight is using flat

00:31:48,480 --> 00:31:52,640
buffers for one so in

00:31:50,480 --> 00:31:53,919
contrast uh in the stack four project

00:31:52,640 --> 00:31:56,080
that i showed you before

00:31:53,919 --> 00:31:57,360
we actually communicated between the the

00:31:56,080 --> 00:32:01,200
core library

00:31:57,360 --> 00:32:04,559
and the the game or or go um

00:32:01,200 --> 00:32:06,320
using json objects that was all fine for

00:32:04,559 --> 00:32:07,200
for this particular use case because it

00:32:06,320 --> 00:32:09,600
wasn't uh

00:32:07,200 --> 00:32:10,799
that much data that needed to go uh back

00:32:09,600 --> 00:32:12,399
and forth and there's also

00:32:10,799 --> 00:32:14,960
much less input events that you actually

00:32:12,399 --> 00:32:17,120
need to need to synchronize

00:32:14,960 --> 00:32:19,120
but because of uh the fact that in this

00:32:17,120 --> 00:32:22,480
game as you can see we have many more

00:32:19,120 --> 00:32:23,760
uh entities going on and um basically

00:32:22,480 --> 00:32:26,000
you you have to be able to

00:32:23,760 --> 00:32:27,760
synchronize with uh with up to a

00:32:26,000 --> 00:32:30,799
thousand entities that could be

00:32:27,760 --> 00:32:32,080
uh simultaneously on screen and so what

00:32:30,799 --> 00:32:35,120
we are using here is

00:32:32,080 --> 00:32:36,480
a uh is a library called flat buffers um

00:32:35,120 --> 00:32:38,640
there's an actual actually a

00:32:36,480 --> 00:32:40,880
pretty nice talk from a meetup in san

00:32:38,640 --> 00:32:43,039
francisco i think about it

00:32:40,880 --> 00:32:44,559
um there's a rust implementation for it

00:32:43,039 --> 00:32:47,919
and what it essentially does

00:32:44,559 --> 00:32:51,760
is that it allows you to serialize data

00:32:47,919 --> 00:32:54,399
by uh mapping basically by mapping uh

00:32:51,760 --> 00:32:55,600
directly into into the memory from

00:32:54,399 --> 00:32:57,440
different languages

00:32:55,600 --> 00:32:59,039
and to be able to interpret this memory

00:32:57,440 --> 00:32:59,600
uh from different languages in the same

00:32:59,039 --> 00:33:02,000
way

00:32:59,600 --> 00:33:03,600
so you don't have to uh have you don't

00:33:02,000 --> 00:33:04,880
have this whole overhead that you are

00:33:03,600 --> 00:33:06,000
using uh when you're

00:33:04,880 --> 00:33:07,919
that you're having when you're using

00:33:06,000 --> 00:33:10,640
json for example

00:33:07,919 --> 00:33:12,399
and that gave us a nice uh boost in in

00:33:10,640 --> 00:33:15,919
performance there

00:33:12,399 --> 00:33:16,640
um secondly uh entity component systems

00:33:15,919 --> 00:33:18,799
is a

00:33:16,640 --> 00:33:19,760
super big buzzword in in the rust

00:33:18,799 --> 00:33:22,399
community

00:33:19,760 --> 00:33:22,960
um and that is i think that has two

00:33:22,399 --> 00:33:25,519
reasons

00:33:22,960 --> 00:33:26,559
first of all rust makes it super hard to

00:33:25,519 --> 00:33:29,200
design your

00:33:26,559 --> 00:33:31,200
whole entity relationships differently

00:33:29,200 --> 00:33:32,960
so ecs is something that

00:33:31,200 --> 00:33:34,720
is pretty straightforward and there's

00:33:32,960 --> 00:33:37,120
also a couple of nice

00:33:34,720 --> 00:33:39,120
meetup talks about ecs in general i'm

00:33:37,120 --> 00:33:41,840
not going to go too deeply on those

00:33:39,120 --> 00:33:43,760
but the the whole idea is that you are

00:33:41,840 --> 00:33:45,279
instead of referencing directly between

00:33:43,760 --> 00:33:47,919
multiple entities

00:33:45,279 --> 00:33:50,240
um you have them all in contiguous

00:33:47,919 --> 00:33:52,960
arrays essentially so it makes it

00:33:50,240 --> 00:33:54,640
super easy and fast to iterate over them

00:33:52,960 --> 00:33:57,200
which is one of the

00:33:54,640 --> 00:33:57,840
predominant access patterns that we see

00:33:57,200 --> 00:34:00,399
in this

00:33:57,840 --> 00:34:01,919
in this sort of game that tower rangers

00:34:00,399 --> 00:34:05,440
is

00:34:01,919 --> 00:34:07,519
and um it also it allows us

00:34:05,440 --> 00:34:09,119
to to also from from another perspective

00:34:07,519 --> 00:34:12,320
to architect the whole game

00:34:09,119 --> 00:34:15,040
in a in a nice way where you can add

00:34:12,320 --> 00:34:16,879
uh behavior to entities by basically

00:34:15,040 --> 00:34:18,800
just adding components to them

00:34:16,879 --> 00:34:20,000
instead of having this this weird class

00:34:18,800 --> 00:34:21,839
hierarchies that

00:34:20,000 --> 00:34:24,399
i'm that i remember from back in the

00:34:21,839 --> 00:34:27,440
past in c plus plus

00:34:24,399 --> 00:34:29,119
so um back in end of last year

00:34:27,440 --> 00:34:30,480
what kind of back-end technology did we

00:34:29,119 --> 00:34:34,079
use for the actual

00:34:30,480 --> 00:34:37,359
web api that was a rocket

00:34:34,079 --> 00:34:39,119
and that is something that i wasn't too

00:34:37,359 --> 00:34:39,599
happy with at the time because it made

00:34:39,119 --> 00:34:43,599
me

00:34:39,599 --> 00:34:47,440
it forced me into uh using instable rust

00:34:43,599 --> 00:34:49,119
or nightly rust and that's something i

00:34:47,440 --> 00:34:50,639
really didn't feel good about because

00:34:49,119 --> 00:34:51,359
there were multiple times that it broke

00:34:50,639 --> 00:34:54,000
my build

00:34:51,359 --> 00:34:55,359
pipeline when suddenly some nightly uh

00:34:54,000 --> 00:34:58,000
releases didn't support

00:34:55,359 --> 00:34:58,720
um the the version uh some sort some

00:34:58,000 --> 00:35:00,640
version of

00:34:58,720 --> 00:35:02,000
some some of my tools anymore so that

00:35:00,640 --> 00:35:04,480
was definitely something i i

00:35:02,000 --> 00:35:06,320
really uh didn't like so much and also

00:35:04,480 --> 00:35:09,520
the fact that uh back in that

00:35:06,320 --> 00:35:11,520
back in that time um i mean the stable

00:35:09,520 --> 00:35:13,359
thing also changed i think pretty

00:35:11,520 --> 00:35:15,760
recently but back in the

00:35:13,359 --> 00:35:17,359
uh in last year that wasn't the case and

00:35:15,760 --> 00:35:18,480
also the the fact that it didn't support

00:35:17,359 --> 00:35:20,240
asic which was

00:35:18,480 --> 00:35:21,520
something that i really was uh

00:35:20,240 --> 00:35:24,800
interested in having

00:35:21,520 --> 00:35:27,280
like um to to really save

00:35:24,800 --> 00:35:28,640
and and scale easier with my uh back-end

00:35:27,280 --> 00:35:31,440
implementation

00:35:28,640 --> 00:35:33,920
uh on a very cheap kind of server

00:35:31,440 --> 00:35:36,880
infrastructure because uh for us as a

00:35:33,920 --> 00:35:38,480
super small company it was essential to

00:35:36,880 --> 00:35:39,760
really not waste any money anywhere

00:35:38,480 --> 00:35:42,800
possible

00:35:39,760 --> 00:35:45,359
and um yeah but we will see that

00:35:42,800 --> 00:35:46,960
in our current project we are actually

00:35:45,359 --> 00:35:47,520
using a different kind of solution that

00:35:46,960 --> 00:35:51,040
i'm

00:35:47,520 --> 00:35:53,200
currently much more happy with so

00:35:51,040 --> 00:35:54,720
that's why we're now talking about

00:35:53,200 --> 00:35:59,839
really royale

00:35:54,720 --> 00:35:59,839
and i show you a short clip again

00:36:01,359 --> 00:36:04,800
oh this time without sound

00:36:06,240 --> 00:36:11,040
so yeah the idea here is it's a racing

00:36:08,320 --> 00:36:13,440
game it's super simple and casual

00:36:11,040 --> 00:36:15,359
and but it's still interesting from a

00:36:13,440 --> 00:36:17,680
technology perspective because you're

00:36:15,359 --> 00:36:20,000
competing against 99 opponents

00:36:17,680 --> 00:36:21,040
at the same time so you're racing

00:36:20,000 --> 00:36:26,079
against

00:36:21,040 --> 00:36:29,920
other actual players out there whoops

00:36:26,079 --> 00:36:32,560
not what i wanted um and

00:36:29,920 --> 00:36:34,400
the this is called in in our game world

00:36:32,560 --> 00:36:35,680
there's a term called royale mechanic

00:36:34,400 --> 00:36:36,160
for that because there's a couple of

00:36:35,680 --> 00:36:38,480
games

00:36:36,160 --> 00:36:39,440
uh that that does that do something

00:36:38,480 --> 00:36:42,400
similar where you're

00:36:39,440 --> 00:36:43,200
competing against 99 opponents until

00:36:42,400 --> 00:36:46,000
basically

00:36:43,200 --> 00:36:47,599
one is left and then wins the game uh

00:36:46,000 --> 00:36:48,880
again this game is currently live in

00:36:47,599 --> 00:36:52,640
canada in a test

00:36:48,880 --> 00:36:55,520
environment and um

00:36:52,640 --> 00:36:56,960
yeah and we have uh we are using a uh

00:36:55,520 --> 00:36:58,720
similar tech stack to

00:36:56,960 --> 00:37:00,400
what what i showed you before but this

00:36:58,720 --> 00:37:03,680
time it's a it's a game that is

00:37:00,400 --> 00:37:04,800
that was too simple actually to also

00:37:03,680 --> 00:37:06,880
have a client side

00:37:04,800 --> 00:37:09,040
so this is for purely back-end uh rust

00:37:06,880 --> 00:37:11,760
implementation

00:37:09,040 --> 00:37:12,480
and the the the back end sort of acts as

00:37:11,760 --> 00:37:14,560
a

00:37:12,480 --> 00:37:16,400
entry point to the database when if you

00:37:14,560 --> 00:37:19,760
will so we have a

00:37:16,400 --> 00:37:19,760
pure rest based api

00:37:20,079 --> 00:37:23,680
we are saving all the data in dynamodb

00:37:22,480 --> 00:37:25,440
databases

00:37:23,680 --> 00:37:27,520
so um there's a there's a very nice

00:37:25,440 --> 00:37:30,960
crate that gives you access to all those

00:37:27,520 --> 00:37:34,000
aws services and for us a very scalable

00:37:30,960 --> 00:37:36,720
solution was using this dynamodb

00:37:34,000 --> 00:37:37,280
and um there is actually async wrappers

00:37:36,720 --> 00:37:40,320
for that

00:37:37,280 --> 00:37:41,760
so that is all all no problem same same

00:37:40,320 --> 00:37:43,599
goes for redis actually that we

00:37:41,760 --> 00:37:45,119
are that we have to use as a caching

00:37:43,599 --> 00:37:46,640
layer in between because there's a

00:37:45,119 --> 00:37:48,720
couple of access patterns that are

00:37:46,640 --> 00:37:50,880
that are super expensive to to always

00:37:48,720 --> 00:37:53,040
hit the actual database

00:37:50,880 --> 00:37:53,920
and uh it's a it's a very

00:37:53,040 --> 00:37:56,000
straightforward

00:37:53,920 --> 00:37:57,599
uh approach to use radius in between for

00:37:56,000 --> 00:37:59,440
that um and again

00:37:57,599 --> 00:38:01,920
there's a nice crate for that uh out

00:37:59,440 --> 00:38:04,960
there it's uh it's it's all async

00:38:01,920 --> 00:38:07,599
no problem um to integrate into a

00:38:04,960 --> 00:38:09,680
tokyo based runtime which is the one

00:38:07,599 --> 00:38:12,720
that i'm going for in our current system

00:38:09,680 --> 00:38:13,520
so i have no experience i cannot say

00:38:12,720 --> 00:38:15,520
much about

00:38:13,520 --> 00:38:16,720
how the alternatives look like even

00:38:15,520 --> 00:38:19,359
though i

00:38:16,720 --> 00:38:20,320
actually aren't i actually am tempted to

00:38:19,359 --> 00:38:23,920
look into them

00:38:20,320 --> 00:38:26,480
because tokyo actually pulls in a lot of

00:38:23,920 --> 00:38:27,520
uh dependencies and a lot of bloat uh

00:38:26,480 --> 00:38:31,040
right away

00:38:27,520 --> 00:38:32,240
but that is something i guess a a battle

00:38:31,040 --> 00:38:34,160
for another day

00:38:32,240 --> 00:38:36,079
but what i'm really uh happy with in

00:38:34,160 --> 00:38:38,720
this back-end implementation is

00:38:36,079 --> 00:38:40,400
using warp that is something that i

00:38:38,720 --> 00:38:41,359
didn't have on the radar at least last

00:38:40,400 --> 00:38:44,560
year um

00:38:41,359 --> 00:38:48,000
when i chose rocket so warp

00:38:44,560 --> 00:38:51,359
basically provides you an async

00:38:48,000 --> 00:38:54,240
implementation for uh for web servers

00:38:51,359 --> 00:38:55,119
and uh for me the the kind of ergonomics

00:38:54,240 --> 00:38:57,599
in how you are

00:38:55,119 --> 00:38:58,400
building up your endpoints and services

00:38:57,599 --> 00:39:00,880
and uh

00:38:58,400 --> 00:39:02,000
how this whole thing is super modular

00:39:00,880 --> 00:39:04,480
was kind of

00:39:02,000 --> 00:39:05,599
intriguing to me and right now i really

00:39:04,480 --> 00:39:07,760
am happy with this

00:39:05,599 --> 00:39:09,680
solution using warp and i'm definitely

00:39:07,760 --> 00:39:12,480
going to go forward with that

00:39:09,680 --> 00:39:15,359
even though i i must admit that those

00:39:12,480 --> 00:39:17,040
benchmarks that you can see on uh

00:39:15,359 --> 00:39:19,119
what's what's this site called anyways

00:39:17,040 --> 00:39:21,520
so it's it's definitely not

00:39:19,119 --> 00:39:22,800
not the fastest in those in those

00:39:21,520 --> 00:39:24,640
benchmarks but you always

00:39:22,800 --> 00:39:26,160
also have to take those benchmarks with

00:39:24,640 --> 00:39:28,960
a grain of salt right

00:39:26,160 --> 00:39:31,040
and for me it was always um more

00:39:28,960 --> 00:39:34,160
beneficial to go with something that is

00:39:31,040 --> 00:39:37,359
that that is maintain more maintainable

00:39:34,160 --> 00:39:39,359
and easier for me to grasp and uh

00:39:37,359 --> 00:39:40,480
maybe it's a little less fast but i'm

00:39:39,359 --> 00:39:42,960
building um

00:39:40,480 --> 00:39:44,000
usually building stateless back-end apis

00:39:42,960 --> 00:39:46,400
anyway so

00:39:44,000 --> 00:39:47,200
that might mean that i have to run one

00:39:46,400 --> 00:39:49,280
instance more

00:39:47,200 --> 00:39:51,839
than if i have written it in in actics

00:39:49,280 --> 00:39:51,839
for example

00:39:52,000 --> 00:39:56,079
um so there's one particular crate that

00:39:54,960 --> 00:39:58,960
i want to go into

00:39:56,079 --> 00:40:00,560
um it's it's a super shameful self plug

00:39:58,960 --> 00:40:01,359
but it's something that i'm using in all

00:40:00,560 --> 00:40:03,520
of my

00:40:01,359 --> 00:40:05,359
uh back end implementations so far

00:40:03,520 --> 00:40:09,040
because we uh

00:40:05,359 --> 00:40:11,359
doing we are doing uh our major

00:40:09,040 --> 00:40:12,880
uh focus is of doing like multiplayer

00:40:11,359 --> 00:40:15,920
games social games

00:40:12,880 --> 00:40:17,599
so the idea is always to to give you a

00:40:15,920 --> 00:40:19,760
really good feeling of

00:40:17,599 --> 00:40:21,040
of a community in the games and you you

00:40:19,760 --> 00:40:22,480
want to know where those people are

00:40:21,040 --> 00:40:24,560
coming from that you are

00:40:22,480 --> 00:40:26,720
competing against and so it's a it's a

00:40:24,560 --> 00:40:27,599
best practice sort of also in the in the

00:40:26,720 --> 00:40:31,040
industry

00:40:27,599 --> 00:40:32,400
to uh assign everyone the flag that

00:40:31,040 --> 00:40:34,000
of their country where they're coming

00:40:32,400 --> 00:40:35,040
from so that you have a feeling of this

00:40:34,000 --> 00:40:37,599
international

00:40:35,040 --> 00:40:39,119
kind of challenge and competition that

00:40:37,599 --> 00:40:41,680
you're engaging with

00:40:39,119 --> 00:40:42,880
and um for for the longest time i was

00:40:41,680 --> 00:40:44,640
using

00:40:42,880 --> 00:40:46,560
actually a go implementation and i

00:40:44,640 --> 00:40:48,160
actually used it in the in the rust

00:40:46,560 --> 00:40:50,319
based uh back ends as well

00:40:48,160 --> 00:40:52,800
um i just basically ran it in a docker

00:40:50,319 --> 00:40:55,599
container as a microservice and

00:40:52,800 --> 00:40:56,480
all that it gave me was a ip lookup to a

00:40:55,599 --> 00:40:58,640
country

00:40:56,480 --> 00:41:00,319
and i always felt bad about it because

00:40:58,640 --> 00:41:03,680
it was first i mean it was

00:41:00,319 --> 00:41:05,440
not super fast it was it took a lot of

00:41:03,680 --> 00:41:08,000
memory so i actually paid

00:41:05,440 --> 00:41:11,119
more money than i had to to to run this

00:41:08,000 --> 00:41:14,240
for example in the in the aws container

00:41:11,119 --> 00:41:17,520
uh it didn't give me ap ip

00:41:14,240 --> 00:41:19,839
v4 and 6 at the same time

00:41:17,520 --> 00:41:21,760
and it also had a shady sort of license

00:41:19,839 --> 00:41:24,160
where they always tried to sell you up

00:41:21,760 --> 00:41:24,880
into some sort of priced tier where you

00:41:24,160 --> 00:41:27,280
had to

00:41:24,880 --> 00:41:28,319
where you could get more uh accurate

00:41:27,280 --> 00:41:30,000
kind of results

00:41:28,319 --> 00:41:32,240
and that is something that i really had

00:41:30,000 --> 00:41:34,640
on my list for a long time to look into

00:41:32,240 --> 00:41:35,440
so in my last project i actually found a

00:41:34,640 --> 00:41:37,760
solution on

00:41:35,440 --> 00:41:38,560
um on crates io that does this whole

00:41:37,760 --> 00:41:41,839
thing

00:41:38,560 --> 00:41:44,720
in rust but um for my

00:41:41,839 --> 00:41:45,200
so to my surprise it was way worse than

00:41:44,720 --> 00:41:47,200
what i

00:41:45,200 --> 00:41:48,800
that than the solution that i had used

00:41:47,200 --> 00:41:51,920
in written go

00:41:48,800 --> 00:41:53,839
so i looked into it and

00:41:51,920 --> 00:41:55,280
it turned out to be basically the

00:41:53,839 --> 00:41:58,560
problem was that it was always

00:41:55,280 --> 00:42:00,960
keeping this super unoptimized

00:41:58,560 --> 00:42:02,000
sort of data structure in memory for the

00:42:00,960 --> 00:42:04,000
whole database

00:42:02,000 --> 00:42:05,359
for the whole ip database to look up

00:42:04,000 --> 00:42:07,920
into and so

00:42:05,359 --> 00:42:09,280
i decided okay let's let's finally do

00:42:07,920 --> 00:42:11,359
this

00:42:09,280 --> 00:42:13,599
myself and implement it in in the right

00:42:11,359 --> 00:42:16,240
way um and i still want to write a blog

00:42:13,599 --> 00:42:19,359
post about that because it's it's

00:42:16,240 --> 00:42:21,640
it's now so much more performant and i'm

00:42:19,359 --> 00:42:24,319
really happy with the result it supports

00:42:21,640 --> 00:42:27,839
ipv4 and six at the same time

00:42:24,319 --> 00:42:28,640
uh it uses a completely free and reality

00:42:27,839 --> 00:42:31,680
free kind of

00:42:28,640 --> 00:42:32,000
database that that is that is provided

00:42:31,680 --> 00:42:34,480
by

00:42:32,000 --> 00:42:36,720
uh all the different isps out there

00:42:34,480 --> 00:42:39,599
where you can get the ip ranges and

00:42:36,720 --> 00:42:40,880
uh the the who is lookups behind that

00:42:39,599 --> 00:42:42,960
and the country as well

00:42:40,880 --> 00:42:44,560
so in the end i'm throwing out all the

00:42:42,960 --> 00:42:45,680
crap that i don't need and basically

00:42:44,560 --> 00:42:48,400
just reduce it

00:42:45,680 --> 00:42:50,000
for ip range to country lookup and that

00:42:48,400 --> 00:42:52,160
is um

00:42:50,000 --> 00:42:54,160
what you can now find also on uh crates

00:42:52,160 --> 00:42:56,960
and uh and github

00:42:54,160 --> 00:42:57,520
and um yeah it's also using warp and

00:42:56,960 --> 00:42:59,599
it's

00:42:57,520 --> 00:43:02,000
super fast even though every uh the

00:42:59,599 --> 00:43:04,240
whole database is in memory as well

00:43:02,000 --> 00:43:05,280
but that is something that really again

00:43:04,240 --> 00:43:08,000
emphasized for me

00:43:05,280 --> 00:43:09,760
how easy it is to write uh really

00:43:08,000 --> 00:43:10,800
performance systems in rust where you

00:43:09,760 --> 00:43:14,160
don't have to

00:43:10,800 --> 00:43:14,960
jump through a ton of hoops to make this

00:43:14,160 --> 00:43:16,880
possible

00:43:14,960 --> 00:43:18,079
yes the learning curve was was kind of

00:43:16,880 --> 00:43:21,119
intense for me as well but

00:43:18,079 --> 00:43:23,520
uh that's something that after a year

00:43:21,119 --> 00:43:25,520
i must say really paid out paid off

00:43:23,520 --> 00:43:28,079
quite well

00:43:25,520 --> 00:43:30,319
so a couple of highlights why we are uh

00:43:28,079 --> 00:43:32,160
happy with our decision to go for rust

00:43:30,319 --> 00:43:34,160
i mean uh obviously the sea

00:43:32,160 --> 00:43:36,560
interoperability for us was

00:43:34,160 --> 00:43:37,280
one of the major uh factors right we

00:43:36,560 --> 00:43:39,280
couldn't be

00:43:37,280 --> 00:43:40,319
using rust in an engine like unity if

00:43:39,280 --> 00:43:42,640
there wasn't this

00:43:40,319 --> 00:43:43,440
sort of opportunity to go through a c

00:43:42,640 --> 00:43:45,040
api

00:43:43,440 --> 00:43:46,720
so that is something that that really

00:43:45,040 --> 00:43:49,520
was important

00:43:46,720 --> 00:43:50,079
and actually in the end the fact that

00:43:49,520 --> 00:43:52,160
there is

00:43:50,079 --> 00:43:53,440
no real run time and that it's super

00:43:52,160 --> 00:43:56,400
lightweight

00:43:53,440 --> 00:43:58,160
allows us to to use this uh in in every

00:43:56,400 --> 00:44:00,319
sort of place and that is

00:43:58,160 --> 00:44:02,160
the sort of portability that that i was

00:44:00,319 --> 00:44:02,960
for example uh that i didn't get for

00:44:02,160 --> 00:44:06,000
example when i

00:44:02,960 --> 00:44:08,000
looked for for a short period of time

00:44:06,000 --> 00:44:09,280
to do the same with go actually back in

00:44:08,000 --> 00:44:12,319
the days

00:44:09,280 --> 00:44:14,720
um yeah of course uh implementing a

00:44:12,319 --> 00:44:17,359
complicated ai like we did in stack four

00:44:14,720 --> 00:44:17,839
that goes through a search tree in into

00:44:17,359 --> 00:44:19,760
the

00:44:17,839 --> 00:44:21,520
i don't know 20th level or something to

00:44:19,760 --> 00:44:24,319
really be able to at least do

00:44:21,520 --> 00:44:26,400
super uh intelligent moves was something

00:44:24,319 --> 00:44:29,760
that was super hard to implement in a

00:44:26,400 --> 00:44:31,200
in a like a language with memory with a

00:44:29,760 --> 00:44:32,800
with an automatic memory management and

00:44:31,200 --> 00:44:35,359
garbage collection because you had to

00:44:32,800 --> 00:44:36,240
keep in mind so much stuff you had to uh

00:44:35,359 --> 00:44:38,240
to to do

00:44:36,240 --> 00:44:40,079
so much things to to make sure that

00:44:38,240 --> 00:44:41,119
you're not allocating in places where

00:44:40,079 --> 00:44:42,960
you

00:44:41,119 --> 00:44:44,400
can maybe uh forget about that it's

00:44:42,960 --> 00:44:45,760
happening there and that is something

00:44:44,400 --> 00:44:48,160
that rust really makes

00:44:45,760 --> 00:44:50,400
easy for you to not run into because i

00:44:48,160 --> 00:44:52,560
mean it's basically the opposite

00:44:50,400 --> 00:44:54,240
kind of approach right where it uh

00:44:52,560 --> 00:44:56,480
shouts into your face whenever you do

00:44:54,240 --> 00:44:59,920
you're doing something that

00:44:56,480 --> 00:45:02,319
that you uh didn't want to do and uh

00:44:59,920 --> 00:45:04,000
yeah this the ergonomics and safeties is

00:45:02,319 --> 00:45:06,000
something that's emphasized

00:45:04,000 --> 00:45:07,119
in a lot of discussions about rust but

00:45:06,000 --> 00:45:09,920
for me it really

00:45:07,119 --> 00:45:11,760
um there's there's one example that i

00:45:09,920 --> 00:45:13,760
keep telling people and it's it's funny

00:45:11,760 --> 00:45:15,599
because it kind of

00:45:13,760 --> 00:45:18,079
came through in in the previous talk as

00:45:15,599 --> 00:45:20,640
well which is ergonomic for me

00:45:18,079 --> 00:45:22,319
uh to to be able to still get benefits

00:45:20,640 --> 00:45:25,440
that other languages give you by

00:45:22,319 --> 00:45:26,720
doing like dynamic dispatch uh uh and

00:45:25,440 --> 00:45:28,880
and russ basically

00:45:26,720 --> 00:45:30,560
makes it easy for you to have this in a

00:45:28,880 --> 00:45:32,160
compile time level where you are when

00:45:30,560 --> 00:45:34,000
you are looking at those uh graph

00:45:32,160 --> 00:45:36,240
uh traits that we saw in the previous

00:45:34,000 --> 00:45:36,880
talk that is that is a prime example for

00:45:36,240 --> 00:45:38,880
me

00:45:36,880 --> 00:45:40,000
to have flexibility like you're used to

00:45:38,880 --> 00:45:43,920
in other languages but

00:45:40,000 --> 00:45:43,920
have it at runtime with high performance

00:45:44,000 --> 00:45:48,319
and yeah i still want to uh also i keep

00:45:46,560 --> 00:45:50,240
emphasizing i think also my last stop

00:45:48,319 --> 00:45:52,480
cargo and the whole community

00:45:50,240 --> 00:45:54,800
um but it's still for me one of the

00:45:52,480 --> 00:45:57,520
reasons why i keep uh

00:45:54,800 --> 00:45:58,079
i guess uh not losing faith when i'm

00:45:57,520 --> 00:45:59,920
when i'm

00:45:58,079 --> 00:46:02,240
running against the wall for the 100th

00:45:59,920 --> 00:46:03,839
time in a rust problem because then i

00:46:02,240 --> 00:46:04,560
realized okay there's other solutions

00:46:03,839 --> 00:46:06,720
out there

00:46:04,560 --> 00:46:08,000
that i uh that i can get my inspiration

00:46:06,720 --> 00:46:09,760
from and uh

00:46:08,000 --> 00:46:11,680
and there's a super helpful community

00:46:09,760 --> 00:46:13,680
even when you reach out to those authors

00:46:11,680 --> 00:46:14,960
and maintainers and you you always get

00:46:13,680 --> 00:46:17,680
help and that is something

00:46:14,960 --> 00:46:18,400
where which i also learned it could be

00:46:17,680 --> 00:46:20,079
much different

00:46:18,400 --> 00:46:21,760
in in other communities or other

00:46:20,079 --> 00:46:25,040
language communities

00:46:21,760 --> 00:46:26,880
and um i know it's it's sort of uh

00:46:25,040 --> 00:46:28,400
something people do is like highlighting

00:46:26,880 --> 00:46:32,079
some of the crates they really like

00:46:28,400 --> 00:46:34,000
and uh i did a little i picked out a

00:46:32,079 --> 00:46:36,560
selection a little differently this time

00:46:34,000 --> 00:46:39,119
because i think these are my prime

00:46:36,560 --> 00:46:41,280
examples of underappreciated crates

00:46:39,119 --> 00:46:42,480
and uh one of them actually could also

00:46:41,280 --> 00:46:44,960
be interesting for

00:46:42,480 --> 00:46:46,480
to the to my the previous speaker

00:46:44,960 --> 00:46:47,680
because it's actually an implementation

00:46:46,480 --> 00:46:49,599
of dijkstra

00:46:47,680 --> 00:46:50,720
and also a ton of other graph search

00:46:49,599 --> 00:46:53,760
algorithms

00:46:50,720 --> 00:46:55,040
and um it's it's one that i picked

00:46:53,760 --> 00:46:58,319
because it has

00:46:55,040 --> 00:46:58,800
uh it just has like 260 stars but it's

00:46:58,319 --> 00:47:01,920
uh

00:46:58,800 --> 00:47:03,200
it's the core uh library for for every

00:47:01,920 --> 00:47:05,839
game basically

00:47:03,200 --> 00:47:07,520
on our site that has any sort of ai

00:47:05,839 --> 00:47:09,839
implementation because it's a

00:47:07,520 --> 00:47:10,960
it's a super flexible and still very

00:47:09,839 --> 00:47:12,720
performant uh

00:47:10,960 --> 00:47:14,560
graph search implementation which is

00:47:12,720 --> 00:47:15,920
which is an essential problem in game

00:47:14,560 --> 00:47:19,040
development

00:47:15,920 --> 00:47:20,800
and um yeah we are we i emphasize the

00:47:19,040 --> 00:47:23,040
entity component system aspect of our

00:47:20,800 --> 00:47:25,280
games and that is something

00:47:23,040 --> 00:47:26,960
we are using hex4 it's not the most

00:47:25,280 --> 00:47:28,880
popular choice out there

00:47:26,960 --> 00:47:30,640
and i think this is also a reason why i

00:47:28,880 --> 00:47:33,920
want to emphasize it because

00:47:30,640 --> 00:47:34,480
it has a much more easy to grasp api i

00:47:33,920 --> 00:47:37,359
think

00:47:34,480 --> 00:47:39,359
in in my understanding it's much more

00:47:37,359 --> 00:47:41,200
flexible it doesn't put too many

00:47:39,359 --> 00:47:43,119
like constraints on you like if i look

00:47:41,200 --> 00:47:43,760
at specs for example as an alternative

00:47:43,119 --> 00:47:45,520
that's

00:47:43,760 --> 00:47:47,680
definitely something that makes you

00:47:45,520 --> 00:47:50,160
forces you to style your uh

00:47:47,680 --> 00:47:52,079
your implementation in a certain way and

00:47:50,160 --> 00:47:53,520
hex gives you much more freedom here

00:47:52,079 --> 00:47:56,400
to choose how you want to implement

00:47:53,520 --> 00:47:58,720
stuff cargo lipo i actually

00:47:56,400 --> 00:47:59,760
won't open this link this time super

00:47:58,720 --> 00:48:02,160
important if you want to do

00:47:59,760 --> 00:48:05,119
cross-platform especially mobile

00:48:02,160 --> 00:48:07,280
libraries because it reduces the pain a

00:48:05,119 --> 00:48:11,119
lot to to to build or cross

00:48:07,280 --> 00:48:14,400
build uh mac um or ios libraries

00:48:11,119 --> 00:48:15,920
that is a absolute necessity to exist um

00:48:14,400 --> 00:48:18,800
either otherwise i

00:48:15,920 --> 00:48:20,240
never would want to uh like interface

00:48:18,800 --> 00:48:22,160
with xcode myself

00:48:20,240 --> 00:48:23,839
to be able to build the libraries so

00:48:22,160 --> 00:48:25,520
that's definitely something i'm super

00:48:23,839 --> 00:48:29,119
thankful that it exists

00:48:25,520 --> 00:48:31,440
and a very small um library uh for

00:48:29,119 --> 00:48:32,960
for a simple caching if you want to add

00:48:31,440 --> 00:48:34,640
a simple caching implementation in

00:48:32,960 --> 00:48:35,680
memory for your application servers

00:48:34,640 --> 00:48:38,160
that's something

00:48:35,680 --> 00:48:39,680
i i used in a couple of places already

00:48:38,160 --> 00:48:43,119
and uh it it's

00:48:39,680 --> 00:48:46,319
very small but it's super

00:48:43,119 --> 00:48:48,640
fast and and does the job basically and

00:48:46,319 --> 00:48:49,599
it has a joke of 130 stars even though i

00:48:48,640 --> 00:48:52,400
know a lot of people

00:48:49,599 --> 00:48:53,040
who are using it already um and last but

00:48:52,400 --> 00:48:55,520
not least

00:48:53,040 --> 00:48:57,200
um ranking something super important in

00:48:55,520 --> 00:49:00,000
games

00:48:57,200 --> 00:49:01,200
the bayesian skill rating system

00:49:00,000 --> 00:49:03,280
implementation

00:49:01,200 --> 00:49:04,640
i was super surprised to find it that it

00:49:03,280 --> 00:49:06,960
was already there and rest i

00:49:04,640 --> 00:49:08,880
i kind of was afraid that i had to

00:49:06,960 --> 00:49:12,079
implement it myself

00:49:08,880 --> 00:49:12,960
and i'm it was one of those surprises

00:49:12,079 --> 00:49:15,760
that

00:49:12,960 --> 00:49:17,280
that really made my life so much easier

00:49:15,760 --> 00:49:19,599
there's a there's a crate for that

00:49:17,280 --> 00:49:21,280
it does all the the crazy math for you

00:49:19,599 --> 00:49:23,280
and you can focus on actually getting

00:49:21,280 --> 00:49:25,920
your product uh on the street

00:49:23,280 --> 00:49:27,760
and so that was my little selection of

00:49:25,920 --> 00:49:31,359
highlight crates that i wanted to

00:49:27,760 --> 00:49:35,119
share with you

00:49:31,359 --> 00:49:35,119
so yeah thank you very much

00:49:37,760 --> 00:49:43,920
thank you so much stefan

00:49:41,680 --> 00:49:45,040
interesting talk um we have one question

00:49:43,920 --> 00:49:48,480
so far

00:49:45,040 --> 00:49:52,640
in the zoom chat and i think the

00:49:48,480 --> 00:49:55,520
person asks um what's tech and power

00:49:52,640 --> 00:49:58,079
i guess it's the benchmark tool yeah

00:49:55,520 --> 00:50:01,520
that was the benchmarking uh

00:49:58,079 --> 00:50:03,599
site that i was uh referring to exactly

00:50:01,520 --> 00:50:05,359
i mean it's uh actics is the clear

00:50:03,599 --> 00:50:06,640
winner i think in most of the categories

00:50:05,359 --> 00:50:09,760
there

00:50:06,640 --> 00:50:12,640
and so it yeah it might be surprising to

00:50:09,760 --> 00:50:13,599
not use that but um call it personal

00:50:12,640 --> 00:50:15,599
taste or whatever

00:50:13,599 --> 00:50:17,599
for me warp was much more ergonomic to

00:50:15,599 --> 00:50:18,640
use and i'm kind of sticking with that

00:50:17,599 --> 00:50:20,960
because those

00:50:18,640 --> 00:50:22,880
couple of milliseconds of improvements i

00:50:20,960 --> 00:50:25,200
get from actics are not worth the hassle

00:50:22,880 --> 00:50:25,200
for me

00:50:25,359 --> 00:50:31,119
okay um one question i got um

00:50:29,119 --> 00:50:32,640
do you have a comparison about the

00:50:31,119 --> 00:50:35,440
server cost like i mean

00:50:32,640 --> 00:50:36,640
you talked about using go in the past

00:50:35,440 --> 00:50:39,760
and now

00:50:36,640 --> 00:50:42,079
rust do you have a comparison of i saved

00:50:39,760 --> 00:50:44,319
200 bucks a month or something

00:50:42,079 --> 00:50:45,359
like this yeah that would be awesome to

00:50:44,319 --> 00:50:47,280
quantify it

00:50:45,359 --> 00:50:50,079
but that is that is super hard because i

00:50:47,280 --> 00:50:50,880
never translated as something directly

00:50:50,079 --> 00:50:53,520
basically from

00:50:50,880 --> 00:50:55,359
go to rust and uh so the there's no

00:50:53,520 --> 00:50:55,839
direct comparison between the same

00:50:55,359 --> 00:50:58,160
product

00:50:55,839 --> 00:51:00,079
written in in go and rust and to be able

00:50:58,160 --> 00:51:01,760
to compare

00:51:00,079 --> 00:51:04,240
but what i actually uh what i can

00:51:01,760 --> 00:51:04,720
actually um extrapolate based on is the

00:51:04,240 --> 00:51:07,599
the

00:51:04,720 --> 00:51:08,720
iplookup service that i translated to

00:51:07,599 --> 00:51:10,160
rust

00:51:08,720 --> 00:51:12,000
i don't have the numbers here right now

00:51:10,160 --> 00:51:13,839
but that's something i wanted to write a

00:51:12,000 --> 00:51:15,680
post about anyways

00:51:13,839 --> 00:51:17,520
and there is definitely some measurable

00:51:15,680 --> 00:51:19,760
measurable improvements

00:51:17,520 --> 00:51:20,640
that you could extrapolate into server

00:51:19,760 --> 00:51:24,400
costs than in

00:51:20,640 --> 00:51:27,599
in the long term okay cool

00:51:24,400 --> 00:51:30,559
and there's one more question popping up

00:51:27,599 --> 00:51:32,079
and one person asks um would you think

00:51:30,559 --> 00:51:34,839
of using rocket again

00:51:32,079 --> 00:51:37,839
as it is about to be supported by stable

00:51:34,839 --> 00:51:37,839
rust

00:51:38,480 --> 00:51:45,520
i i guess no but that's not

00:51:42,079 --> 00:51:47,119
based on like any facts that it's worse

00:51:45,520 --> 00:51:48,240
than warp now but it's more like i'm

00:51:47,119 --> 00:51:51,040
happy with warp

00:51:48,240 --> 00:51:52,480
and i this is totally this is totally

00:51:51,040 --> 00:51:54,720
not based on any uh

00:51:52,480 --> 00:51:55,680
observations but i could i would assume

00:51:54,720 --> 00:51:58,160
that the

00:51:55,680 --> 00:51:59,200
ton of macros that were that rocket

00:51:58,160 --> 00:52:02,240
supports

00:51:59,200 --> 00:52:02,800
would also maybe hit the compile times a

00:52:02,240 --> 00:52:04,960
little bit

00:52:02,800 --> 00:52:07,119
and that is something that i'm already

00:52:04,960 --> 00:52:11,040
struggling with in in my rust projects

00:52:07,119 --> 00:52:14,079
so i'm i i wouldn't i guess um

00:52:11,040 --> 00:52:17,440
add another crate that would heavily

00:52:14,079 --> 00:52:20,720
put put their work in into into macros

00:52:17,440 --> 00:52:24,240
and waste more compile time on that

00:52:20,720 --> 00:52:26,800
okay and i have um one more question

00:52:24,240 --> 00:52:28,480
would you recommend a beginner who is

00:52:26,800 --> 00:52:29,359
just i'm starting out in game

00:52:28,480 --> 00:52:32,640
development

00:52:29,359 --> 00:52:36,480
and like in the multiplayer world

00:52:32,640 --> 00:52:39,520
to use go or or like rust or

00:52:36,480 --> 00:52:41,760
se or

00:52:39,520 --> 00:52:42,800
you have to know your way around a bit

00:52:41,760 --> 00:52:46,000
more if you use

00:52:42,800 --> 00:52:48,720
rust i think it's i think it's not a

00:52:46,000 --> 00:52:49,839
game specific question and i i my

00:52:48,720 --> 00:52:52,319
personal opinion is

00:52:49,839 --> 00:52:53,440
um i think it's hard to start out with

00:52:52,319 --> 00:52:55,520
rust

00:52:53,440 --> 00:52:57,200
um as a first language in general no

00:52:55,520 --> 00:53:00,319
matter if you're doing games or

00:52:57,200 --> 00:53:01,040
whatever and um yeah it's it's hard to

00:53:00,319 --> 00:53:02,559
judge now

00:53:01,040 --> 00:53:04,960
that when you come from from a

00:53:02,559 --> 00:53:07,040
background of c plus plus and stuff uh

00:53:04,960 --> 00:53:08,240
i think it's not that not that tough but

00:53:07,040 --> 00:53:10,079
um

00:53:08,240 --> 00:53:12,160
i think i'm in general i wouldn't uh

00:53:10,079 --> 00:53:15,680
suggest starting out with the rust

00:53:12,160 --> 00:53:18,480
anyway to anyone

00:53:15,680 --> 00:53:20,160
okay thank you so much this was

00:53:18,480 --> 00:53:23,280
interesting

00:53:20,160 --> 00:53:27,040
um okay people we are going into our

00:53:23,280 --> 00:53:30,480
breakout rooms um we will open

00:53:27,040 --> 00:53:32,400
um four different rooms

00:53:30,480 --> 00:53:34,720
and you will get a pop-up if you want to

00:53:32,400 --> 00:53:37,839
join feel free to join

00:53:34,720 --> 00:53:38,960
and if not take a ten minute break we

00:53:37,839 --> 00:53:42,319
will be back

00:53:38,960 --> 00:53:44,800
five after eight and then we will have

00:53:42,319 --> 00:53:57,839
our last talk of the day

00:53:44,800 --> 00:53:57,839
see you later looking forward

00:53:59,040 --> 00:54:01,440
okay

00:54:02,079 --> 00:54:07,200
i hope everyone had a good time

00:54:04,880 --> 00:54:10,559
interesting conversations

00:54:07,200 --> 00:54:13,920
and we are

00:54:10,559 --> 00:54:19,760
with our last speaker of today

00:54:13,920 --> 00:54:19,760
ryan hello all right let me share my

00:54:22,839 --> 00:54:25,839
screen

00:54:31,040 --> 00:54:37,119
all right so um yeah hi everybody

00:54:34,800 --> 00:54:38,400
i'm i'm ryan and i'm going to be talking

00:54:37,119 --> 00:54:42,240
about a

00:54:38,400 --> 00:54:44,240
nearly 30 year old technology today uh

00:54:42,240 --> 00:54:46,319
so let's have some fun we're going to be

00:54:44,240 --> 00:54:47,440
talking a little bit about calm

00:54:46,319 --> 00:54:50,160
programming

00:54:47,440 --> 00:54:51,920
um why you probably don't care about com

00:54:50,160 --> 00:54:54,000
and probably shouldn't care about it but

00:54:51,920 --> 00:54:56,079
it's still fun and interesting

00:54:54,000 --> 00:54:58,319
um and i'm going to talk about it to see

00:54:56,079 --> 00:55:01,359
if we can learn a little bit about

00:54:58,319 --> 00:55:04,240
things in russ like dynamic dispatch um

00:55:01,359 --> 00:55:05,920
unsafe uh all kinds of fun low-level

00:55:04,240 --> 00:55:08,960
stuff while looking at something that's

00:55:05,920 --> 00:55:08,960
nearly 30 years old

00:55:09,200 --> 00:55:12,640
i know i know you're probably uh you

00:55:11,760 --> 00:55:14,400
know

00:55:12,640 --> 00:55:16,720
walking away and this is me right now

00:55:14,400 --> 00:55:18,400
trying to keep you here

00:55:16,720 --> 00:55:20,079
you're not a windows programmer you

00:55:18,400 --> 00:55:22,319
don't certainly you're not a windows

00:55:20,079 --> 00:55:25,440
programmer from the 1990s you don't

00:55:22,319 --> 00:55:26,960
really care about this and that's

00:55:25,440 --> 00:55:28,720
totally cool

00:55:26,960 --> 00:55:30,720
stick around trust me i think you'll

00:55:28,720 --> 00:55:34,079
still find it interesting even if

00:55:30,720 --> 00:55:35,680
uh what you learned today or at least

00:55:34,079 --> 00:55:36,640
the specifics of what you learned today

00:55:35,680 --> 00:55:39,040
might not be

00:55:36,640 --> 00:55:40,400
directly applicable in your day to day

00:55:39,040 --> 00:55:42,000
um there's still some interesting

00:55:40,400 --> 00:55:42,720
tidbits in there to learn about and

00:55:42,000 --> 00:55:44,319
we're just

00:55:42,720 --> 00:55:46,079
having a little bit of fun poking around

00:55:44,319 --> 00:55:48,400
with something that's been around for a

00:55:46,079 --> 00:55:51,040
really long time

00:55:48,400 --> 00:55:51,680
um a little bit about who i am uh when

00:55:51,040 --> 00:55:54,720
i'm not

00:55:51,680 --> 00:55:55,680
uh co-hosting this uh meetup with

00:55:54,720 --> 00:55:59,359
bastian

00:55:55,680 --> 00:56:01,200
uh i am uh i do work for microsoft so

00:55:59,359 --> 00:56:02,799
um there's there is a little connection

00:56:01,200 --> 00:56:05,920
there um but

00:56:02,799 --> 00:56:06,559
uh my background is uh definitely not in

00:56:05,920 --> 00:56:09,839
windows

00:56:06,559 --> 00:56:12,319
uh i have used uh linux and

00:56:09,839 --> 00:56:14,079
i guess mac uh for basically my entire

00:56:12,319 --> 00:56:16,240
programming career

00:56:14,079 --> 00:56:17,280
i'm not a windows programmer at all

00:56:16,240 --> 00:56:19,119
although

00:56:17,280 --> 00:56:20,720
i guess lately i've been slowly

00:56:19,119 --> 00:56:23,040
converting into one but that's

00:56:20,720 --> 00:56:24,400
out of choice and not really out of

00:56:23,040 --> 00:56:28,079
being forced to

00:56:24,400 --> 00:56:28,960
um at microsoft uh on my day to day i

00:56:28,079 --> 00:56:32,079
focus on rust

00:56:28,960 --> 00:56:33,839
so everything rests at microsoft and our

00:56:32,079 --> 00:56:35,760
usage of rust at uh

00:56:33,839 --> 00:56:37,200
at microsoft um so if you're interested

00:56:35,760 --> 00:56:40,400
in that as well i'm happy to

00:56:37,200 --> 00:56:41,839
answer questions about that as well

00:56:40,400 --> 00:56:44,559
um but today we're going to be talking

00:56:41,839 --> 00:56:46,160
about a technology that until about

00:56:44,559 --> 00:56:47,680
uh i'd say a little less than a year ago

00:56:46,160 --> 00:56:48,960
was completely foreign to me i'd never

00:56:47,680 --> 00:56:51,680
heard of it before

00:56:48,960 --> 00:56:52,480
um and so um you know if you're in that

00:56:51,680 --> 00:56:54,799
boat as well

00:56:52,480 --> 00:56:57,119
um hopefully you can go on the same

00:56:54,799 --> 00:56:59,599
journey that i went on

00:56:57,119 --> 00:57:00,240
um what we're going to be talking about

00:56:59,599 --> 00:57:03,920
today

00:57:00,240 --> 00:57:07,680
is about the difference between

00:57:03,920 --> 00:57:09,839
an api and an abi

00:57:07,680 --> 00:57:13,040
um and so if you're not familiar with

00:57:09,839 --> 00:57:15,599
the difference between these two terms

00:57:13,040 --> 00:57:16,319
we'll talk about that now hopefully if

00:57:15,599 --> 00:57:17,680
you're

00:57:16,319 --> 00:57:19,920
if you've programmed before you're

00:57:17,680 --> 00:57:23,119
familiar with the term api

00:57:19,920 --> 00:57:25,839
um an application programming interface

00:57:23,119 --> 00:57:27,680
so this is the interface of some thing

00:57:25,839 --> 00:57:29,760
in your program

00:57:27,680 --> 00:57:31,440
and if we kind of limit that down to

00:57:29,760 --> 00:57:33,839
functions you can imagine

00:57:31,440 --> 00:57:35,599
an api of a function being how many

00:57:33,839 --> 00:57:37,760
arguments does it have

00:57:35,599 --> 00:57:39,119
um you know what are the types of the

00:57:37,760 --> 00:57:42,079
arguments

00:57:39,119 --> 00:57:43,280
um things like that and really if you

00:57:42,079 --> 00:57:46,400
think about what an api

00:57:43,280 --> 00:57:49,040
is it's really a high level construct

00:57:46,400 --> 00:57:51,040
when you're thinking about an api you're

00:57:49,040 --> 00:57:54,319
not necessarily thinking about the

00:57:51,040 --> 00:57:54,880
the bits the ones and zeros uh registers

00:57:54,319 --> 00:57:56,640
memory

00:57:54,880 --> 00:57:57,920
stuff like that um even if you're

00:57:56,640 --> 00:58:01,520
programming in a

00:57:57,920 --> 00:58:03,760
low level language like c um

00:58:01,520 --> 00:58:04,960
you're you're usually not thinking about

00:58:03,760 --> 00:58:07,440
um what register

00:58:04,960 --> 00:58:08,160
is this uh argument going to go into

00:58:07,440 --> 00:58:09,760
it's uh

00:58:08,160 --> 00:58:11,760
it's only if you go lower level than

00:58:09,760 --> 00:58:13,760
that and program in something

00:58:11,760 --> 00:58:14,799
uh like assembly that you're usually

00:58:13,760 --> 00:58:17,680
worried about

00:58:14,799 --> 00:58:19,599
that and that's where the idea of an abi

00:58:17,680 --> 00:58:21,040
comes into the application binary

00:58:19,599 --> 00:58:24,480
interface

00:58:21,040 --> 00:58:24,880
uh and this binary interface is really

00:58:24,480 --> 00:58:27,839
like

00:58:24,880 --> 00:58:28,160
the nitty gritty of your function call

00:58:27,839 --> 00:58:31,359
or

00:58:28,160 --> 00:58:34,319
whatever api that we're talking about um

00:58:31,359 --> 00:58:34,880
really very specific down to how does

00:58:34,319 --> 00:58:38,240
this

00:58:34,880 --> 00:58:40,319
api work it how it works

00:58:38,240 --> 00:58:43,599
in the actual computer is the

00:58:40,319 --> 00:58:46,240
interface's abi

00:58:43,599 --> 00:58:48,480
so like let's take a a specific thing

00:58:46,240 --> 00:58:49,599
here what are method calls actually or

00:58:48,480 --> 00:58:52,079
function calls

00:58:49,599 --> 00:58:54,000
to be even more specific what are they

00:58:52,079 --> 00:58:57,040
what happens when you call

00:58:54,000 --> 00:58:58,559
a function in a program

00:58:57,040 --> 00:59:00,319
if you've never stopped to think about

00:58:58,559 --> 00:59:01,760
it before usually

00:59:00,319 --> 00:59:03,200
when you think about a function call

00:59:01,760 --> 00:59:05,440
you're thinking about it in high level

00:59:03,200 --> 00:59:07,119
terms yeah i'm practicing some arguments

00:59:05,440 --> 00:59:08,640
and some code is getting run and then

00:59:07,119 --> 00:59:11,680
i'm getting a result back but

00:59:08,640 --> 00:59:12,799
like well what actually happens when you

00:59:11,680 --> 00:59:15,280
call that function

00:59:12,799 --> 00:59:16,960
what registers do arguments go into what

00:59:15,280 --> 00:59:18,720
if those arguments are too big for those

00:59:16,960 --> 00:59:20,880
registers so we put it on the stack do

00:59:18,720 --> 00:59:22,880
we does it need to go on the heap

00:59:20,880 --> 00:59:23,920
what order do the arguments go in if i

00:59:22,880 --> 00:59:25,760
write the

00:59:23,920 --> 00:59:26,960
the function with argument one argument

00:59:25,760 --> 00:59:29,599
two argument three

00:59:26,960 --> 00:59:30,160
um and i have three argument registers

00:59:29,599 --> 00:59:32,240
you know

00:59:30,160 --> 00:59:33,760
does it go into our register one does

00:59:32,240 --> 00:59:35,520
our event one go into register one or

00:59:33,760 --> 00:59:38,000
does it go into register three

00:59:35,520 --> 00:59:39,760
and in backwards order um how is the

00:59:38,000 --> 00:59:42,240
return value given back to the

00:59:39,760 --> 00:59:44,240
to the caller of the function um do i

00:59:42,240 --> 00:59:45,280
put it in some special register do i put

00:59:44,240 --> 00:59:47,680
it on the stack

00:59:45,280 --> 00:59:48,559
like these are things that when you call

00:59:47,680 --> 00:59:51,359
a function

00:59:48,559 --> 00:59:53,200
the caller of that function and the the

00:59:51,359 --> 00:59:54,960
callee of the function need to agree

00:59:53,200 --> 00:59:57,119
upon because if they don't then

00:59:54,960 --> 00:59:59,200
things won't work if if the caller

00:59:57,119 --> 01:00:02,319
expects the first argument to go in

00:59:59,200 --> 01:00:04,000
and register you know ax

01:00:02,319 --> 01:00:06,000
and the colleague of the function

01:00:04,000 --> 01:00:07,119
expects the first argument to go on the

01:00:06,000 --> 01:00:08,880
stack

01:00:07,119 --> 01:00:10,319
you know that doesn't make any sense

01:00:08,880 --> 01:00:11,200
like they have to agree upon these

01:00:10,319 --> 01:00:12,880
things so

01:00:11,200 --> 01:00:14,319
this is important to think about it and

01:00:12,880 --> 01:00:15,520
keep this in mind because

01:00:14,319 --> 01:00:17,520
at the end of the day what we're going

01:00:15,520 --> 01:00:21,119
to be talking about a lot in this talk

01:00:17,520 --> 01:00:23,040
is these types of questions

01:00:21,119 --> 01:00:24,960
um here's a little bit of an example

01:00:23,040 --> 01:00:26,640
that you can see here

01:00:24,960 --> 01:00:28,319
we have two methods and this is

01:00:26,640 --> 01:00:30,480
godbolt.org for those that aren't

01:00:28,319 --> 01:00:33,440
familiar with it's a way to write some

01:00:30,480 --> 01:00:34,960
rus code or c code or c plus code a

01:00:33,440 --> 01:00:36,720
whole bunch of languages and see the

01:00:34,960 --> 01:00:38,079
actual assembly output that comes from

01:00:36,720 --> 01:00:41,359
it and you can do this for things like

01:00:38,079 --> 01:00:43,599
profiling and stuff like that

01:00:41,359 --> 01:00:44,559
but it's also an interesting way for us

01:00:43,599 --> 01:00:48,319
to look

01:00:44,559 --> 01:00:51,599
at different um apis of method calls

01:00:48,319 --> 01:00:53,280
and so method one here um and i'm using

01:00:51,599 --> 01:00:54,720
the term method even though these are

01:00:53,280 --> 01:00:56,319
clearly functions for a reason that

01:00:54,720 --> 01:00:59,359
we'll get to in a minute

01:00:56,319 --> 01:01:01,200
um method one here uh

01:00:59,359 --> 01:01:02,640
takes the same arguments as method two

01:01:01,200 --> 01:01:04,160
it's the same exact

01:01:02,640 --> 01:01:06,319
function so from a high level

01:01:04,160 --> 01:01:09,119
perspective these are the exact same

01:01:06,319 --> 01:01:09,680
methods um the only difference between

01:01:09,119 --> 01:01:12,400
the two

01:01:09,680 --> 01:01:12,799
is that one has this extern standard

01:01:12,400 --> 01:01:15,280
call

01:01:12,799 --> 01:01:15,920
attached to it and the other one doesn't

01:01:15,280 --> 01:01:19,359
so

01:01:15,920 --> 01:01:23,200
in rust parlons the method one has the

01:01:19,359 --> 01:01:27,119
kind of default um the default rust

01:01:23,200 --> 01:01:28,960
api um and what is that actually at the

01:01:27,119 --> 01:01:30,480
end of the day well it depends on what

01:01:28,960 --> 01:01:31,599
version of the compiler you are and it

01:01:30,480 --> 01:01:33,839
can change from

01:01:31,599 --> 01:01:35,599
from compiler version to compiler

01:01:33,839 --> 01:01:37,040
version and even from like

01:01:35,599 --> 01:01:38,640
you know commit to commit of the

01:01:37,040 --> 01:01:39,680
compiler there's really no guarantee

01:01:38,640 --> 01:01:42,240
that russ gives

01:01:39,680 --> 01:01:43,599
of exactly what the abi of this method

01:01:42,240 --> 01:01:45,520
will be

01:01:43,599 --> 01:01:47,040
so if we need these guarantees we need

01:01:45,520 --> 01:01:50,079
to know exactly

01:01:47,040 --> 01:01:53,359
what that is we have to specify uh an

01:01:50,079 --> 01:01:54,640
actual calling convention here um and

01:01:53,359 --> 01:01:57,200
if you're wondering well then how does

01:01:54,640 --> 01:02:00,000
rust work if it can't agree upon it well

01:01:57,200 --> 01:02:01,839
per compiler version it does agree so

01:02:00,000 --> 01:02:03,599
it's always the same so if you compile a

01:02:01,839 --> 01:02:04,720
bunch of rust code it will have the same

01:02:03,599 --> 01:02:06,559
calling convention

01:02:04,720 --> 01:02:08,400
but this is why for instance when you

01:02:06,559 --> 01:02:10,880
compile crates

01:02:08,400 --> 01:02:12,160
you always compile your dependencies

01:02:10,880 --> 01:02:15,200
from source

01:02:12,160 --> 01:02:16,160
because um there is no standard calling

01:02:15,200 --> 01:02:18,400
convention

01:02:16,160 --> 01:02:20,000
uh and so if we were to like you know

01:02:18,400 --> 01:02:22,960
put up a bunch of binaries on

01:02:20,000 --> 01:02:24,319
on crates.i o and pull those down um who

01:02:22,960 --> 01:02:25,680
who knows what the the calling

01:02:24,319 --> 01:02:27,039
conventions of those would be and your

01:02:25,680 --> 01:02:30,960
code just wouldn't work

01:02:27,039 --> 01:02:32,480
um and so rust on purpose does not have

01:02:30,960 --> 01:02:34,079
a standard calling convention you have

01:02:32,480 --> 01:02:35,359
to opt into one if you need one

01:02:34,079 --> 01:02:37,280
specifically

01:02:35,359 --> 01:02:39,119
and then here we're taking the standard

01:02:37,280 --> 01:02:40,720
call calling convention which

01:02:39,119 --> 01:02:42,559
again has a reason that we'll look at in

01:02:40,720 --> 01:02:45,599
a second and you can see

01:02:42,559 --> 01:02:48,079
uh on the the right side of the screen

01:02:45,599 --> 01:02:49,920
particularly on the kind of second

01:02:48,079 --> 01:02:53,440
assembly instruction there

01:02:49,920 --> 01:02:56,799
that one the method one is getting

01:02:53,440 --> 01:02:58,720
is reading a pointer that's passed to it

01:02:56,799 --> 01:03:02,079
and the rsi

01:02:58,720 --> 01:03:03,200
register whereas in method two it's

01:03:02,079 --> 01:03:06,559
reading it from the stack

01:03:03,200 --> 01:03:08,880
rsp plus 20. so 20 bytes into the stack

01:03:06,559 --> 01:03:09,839
it's reading from there and so this is

01:03:08,880 --> 01:03:12,880
how these differ

01:03:09,839 --> 01:03:15,359
apparently structs that get passed in

01:03:12,880 --> 01:03:16,960
if they're a certain size and the

01:03:15,359 --> 01:03:19,039
current calling invention of russ for

01:03:16,960 --> 01:03:22,079
rust c145

01:03:19,039 --> 01:03:24,160
um it will pass that uh in as a pointer

01:03:22,079 --> 01:03:26,160
in a register um but if you standard

01:03:24,160 --> 01:03:29,920
call it we'll pass it on the stack

01:03:26,160 --> 01:03:32,319
uh okay so now we know um that that's uh

01:03:29,920 --> 01:03:34,079
how things work at least in rus 1.45

01:03:32,319 --> 01:03:36,160
and how things work for standard call

01:03:34,079 --> 01:03:39,039
calling conventions this is the abi

01:03:36,160 --> 01:03:40,319
of our function we we can see exactly

01:03:39,039 --> 01:03:42,480
what registers

01:03:40,319 --> 01:03:44,559
uh and where our arguments are being

01:03:42,480 --> 01:03:48,000
passed um

01:03:44,559 --> 01:03:49,440
cool all right so

01:03:48,000 --> 01:03:51,359
so why are we talking about this like

01:03:49,440 --> 01:03:53,280
what was the issue um well

01:03:51,359 --> 01:03:55,520
imagine you're back in the early 90s in

01:03:53,280 --> 01:03:57,839
your microsoft and you're thinking

01:03:55,520 --> 01:04:00,640
okay we have a bunch of these old class

01:03:57,839 --> 01:04:01,280
132 apis they're kind of flat c style

01:04:00,640 --> 01:04:04,079
apis

01:04:01,280 --> 01:04:05,520
they're apis that for instance linux

01:04:04,079 --> 01:04:07,760
still uses so

01:04:05,520 --> 01:04:09,280
you know you know you could argue hey

01:04:07,760 --> 01:04:12,880
they should have never changed that

01:04:09,280 --> 01:04:16,400
linux still uses flat style apis that

01:04:12,880 --> 01:04:20,319
they're c you know c compatible um

01:04:16,400 --> 01:04:22,880
kind of very all in one name space

01:04:20,319 --> 01:04:25,039
that that is how windows worked and

01:04:22,880 --> 01:04:25,680
still and some apis of windows still

01:04:25,039 --> 01:04:27,760
works

01:04:25,680 --> 01:04:29,440
but microsoft is like hey it's the 90s

01:04:27,760 --> 01:04:30,319
we want to do object oriented

01:04:29,440 --> 01:04:33,440
programming

01:04:30,319 --> 01:04:36,720
um and we want to do it with c plus plus

01:04:33,440 --> 01:04:38,640
but c plus plus just like rust does not

01:04:36,720 --> 01:04:41,839
have a set abi

01:04:38,640 --> 01:04:43,920
so there is no set abi in c plus

01:04:41,839 --> 01:04:44,880
just like in rust you have to opt into

01:04:43,920 --> 01:04:46,720
it you have to say

01:04:44,880 --> 01:04:48,079
i want this specific calling convention

01:04:46,720 --> 01:04:49,680
otherwise c plus

01:04:48,079 --> 01:04:51,440
is free to choose whatever it wants from

01:04:49,680 --> 01:04:54,400
compiler version a compiler version

01:04:51,440 --> 01:04:54,960
and so if you were to just compile like

01:04:54,400 --> 01:04:58,000
straight c

01:04:54,960 --> 01:04:59,760
plus plus um one version

01:04:58,000 --> 01:05:01,440
for a library and one version for your

01:04:59,760 --> 01:05:02,640
application code and they didn't

01:05:01,440 --> 01:05:04,240
you know they were different versions of

01:05:02,640 --> 01:05:04,799
the compiler they wouldn't work with

01:05:04,240 --> 01:05:06,720
each other

01:05:04,799 --> 01:05:08,640
and so microsoft was like we want to

01:05:06,720 --> 01:05:12,400
create a library

01:05:08,640 --> 01:05:14,400
once and have code that's you know

01:05:12,400 --> 01:05:16,240
far in the future um different version

01:05:14,400 --> 01:05:19,039
of c plus be able to call that with the

01:05:16,240 --> 01:05:19,039
same api

01:05:20,000 --> 01:05:24,400
so how do we want also assure that our

01:05:22,960 --> 01:05:27,039
apis are flexible

01:05:24,400 --> 01:05:28,720
and don't require too much manual memory

01:05:27,039 --> 01:05:31,760
management which is a problem

01:05:28,720 --> 01:05:34,000
of a lot of linux apis for instance you

01:05:31,760 --> 01:05:35,280
can very easily you know allocate a

01:05:34,000 --> 01:05:36,880
resource forget

01:05:35,280 --> 01:05:38,640
to clean it up and stuff like that this

01:05:36,880 --> 01:05:41,760
is still an issue

01:05:38,640 --> 01:05:45,680
in in linux um nowadays in an issue

01:05:41,760 --> 01:05:48,160
and and and windows um win32 apis

01:05:45,680 --> 01:05:49,520
um you know i put issue in air quotes

01:05:48,160 --> 01:05:50,559
because depending on your perspective

01:05:49,520 --> 01:05:52,000
it's an issue but

01:05:50,559 --> 01:05:53,520
you know i i definitely think there's

01:05:52,000 --> 01:05:54,640
enough there's definitely some evidence

01:05:53,520 --> 01:05:58,160
out there to

01:05:54,640 --> 01:06:00,160
say that that um developers often forget

01:05:58,160 --> 01:06:01,359
to to clean up after themselves or to

01:06:00,160 --> 01:06:03,039
use these apis

01:06:01,359 --> 01:06:04,720
correctly so we want to kind of abstract

01:06:03,039 --> 01:06:06,880
that away from the developer as much as

01:06:04,720 --> 01:06:10,319
possible

01:06:06,880 --> 01:06:12,880
so the answer is this thing called

01:06:10,319 --> 01:06:14,000
calm that's what they came up with in

01:06:12,880 --> 01:06:15,039
the 90s and that's what we're going to

01:06:14,000 --> 01:06:17,599
be talking about

01:06:15,039 --> 01:06:19,039
so what is it exactly and this is the

01:06:17,599 --> 01:06:20,079
thing that for a while i was struggling

01:06:19,039 --> 01:06:22,079
with like

01:06:20,079 --> 01:06:24,480
if you look at the documentation i'm

01:06:22,079 --> 01:06:28,480
sorry to whoever wrote the documentation

01:06:24,480 --> 01:06:29,920
it's very fuzzy and unclear of exactly

01:06:28,480 --> 01:06:32,319
what com is

01:06:29,920 --> 01:06:33,920
um basically it's this it's a stable

01:06:32,319 --> 01:06:36,640
binary interface the api

01:06:33,920 --> 01:06:37,039
doesn't change so they picked some api

01:06:36,640 --> 01:06:39,200
um

01:06:37,039 --> 01:06:41,119
it's a it's a programming model that's

01:06:39,200 --> 01:06:42,480
based on interfaces

01:06:41,119 --> 01:06:44,400
and we'll look at how you declare an

01:06:42,480 --> 01:06:46,160
interface and exactly what that is

01:06:44,400 --> 01:06:47,599
um and it's memory managed through

01:06:46,160 --> 01:06:48,880
reference counting so just if you're

01:06:47,599 --> 01:06:52,240
familiar with rust

01:06:48,880 --> 01:06:52,640
you have rc or or arc um or you know if

01:06:52,240 --> 01:06:55,520
you've done

01:06:52,640 --> 01:06:56,880
object c or swift um these are languages

01:06:55,520 --> 01:06:59,359
that use reference counting

01:06:56,880 --> 01:07:00,079
com also uses reference counting to keep

01:06:59,359 --> 01:07:03,599
track of

01:07:00,079 --> 01:07:06,079
if a object is still being used

01:07:03,599 --> 01:07:07,440
and it's all based on a base interface

01:07:06,079 --> 01:07:09,680
called i n node

01:07:07,440 --> 01:07:11,680
that we're going to look at that all

01:07:09,680 --> 01:07:13,839
other interfaces inherit from

01:07:11,680 --> 01:07:15,119
and so you can see where object-oriented

01:07:13,839 --> 01:07:16,640
programming is coming in here you have

01:07:15,119 --> 01:07:19,039
these interfaces and they inherit from

01:07:16,640 --> 01:07:19,039
each other

01:07:19,119 --> 01:07:22,880
so where is com used like what why are

01:07:21,280 --> 01:07:24,079
we talking about this 30 years after it

01:07:22,880 --> 01:07:26,160
came out came out and

01:07:24,079 --> 01:07:27,119
i think 93 was the first year like why

01:07:26,160 --> 01:07:30,240
do i care

01:07:27,119 --> 01:07:33,039
well there's still after all this time

01:07:30,240 --> 01:07:35,119
some windows and non-windows apis out

01:07:33,039 --> 01:07:35,839
there that are built on top of com like

01:07:35,119 --> 01:07:38,160
directx

01:07:35,839 --> 01:07:39,440
direct2d direct 3d direct writes stuff

01:07:38,160 --> 01:07:41,039
like that so if you're doing game

01:07:39,440 --> 01:07:41,599
programming or graphics programming on

01:07:41,039 --> 01:07:43,839
windows

01:07:41,599 --> 01:07:44,720
you still have to use com exclusively

01:07:43,839 --> 01:07:48,400
basically

01:07:44,720 --> 01:07:51,039
um ole or olay uh is a

01:07:48,400 --> 01:07:53,039
an api for doing document um sharing i

01:07:51,039 --> 01:07:54,880
don't think it's really used a lot much

01:07:53,039 --> 01:07:58,160
nowadays but um also kind of

01:07:54,880 --> 01:07:59,520
was the the the kind of introduction to

01:07:58,160 --> 01:08:01,520
the world for com

01:07:59,520 --> 01:08:03,200
um i found this out recently that core

01:08:01,520 --> 01:08:06,240
foundation plug-ins so on

01:08:03,200 --> 01:08:07,119
on mac or on apple platforms use com

01:08:06,240 --> 01:08:08,960
apparently

01:08:07,119 --> 01:08:10,960
um which is surprising and then the

01:08:08,960 --> 01:08:13,359
windows runtime which is the kind of

01:08:10,960 --> 01:08:15,200
new flavor of apis newish i mean it's

01:08:13,359 --> 01:08:17,040
been around for 10 years now

01:08:15,200 --> 01:08:19,120
but the the the way that you write like

01:08:17,040 --> 01:08:21,199
you know modern windows

01:08:19,120 --> 01:08:23,679
applications is using these windows

01:08:21,199 --> 01:08:25,600
runtime and it's built on top of com

01:08:23,679 --> 01:08:27,520
so it's kind of a layer or several

01:08:25,600 --> 01:08:29,199
layers on top of this com stuff

01:08:27,520 --> 01:08:30,960
and so if you're you're writing a csharp

01:08:29,199 --> 01:08:34,000
app or whatever and you're using

01:08:30,960 --> 01:08:37,040
um xaml or some of these you know modern

01:08:34,000 --> 01:08:40,319
uh windows apis it's it's using

01:08:37,040 --> 01:08:42,400
calm under the hood um

01:08:40,319 --> 01:08:43,359
so how do we support calm and rust like

01:08:42,400 --> 01:08:44,960
the reason that i

01:08:43,359 --> 01:08:46,719
that we need to do this is because hey

01:08:44,960 --> 01:08:48,960
we probably want to

01:08:46,719 --> 01:08:50,799
work with windows right like it's it's

01:08:48,960 --> 01:08:53,120
still an operating system that

01:08:50,799 --> 01:08:54,640
gets a ton of users we want to be able

01:08:53,120 --> 01:08:55,920
to use it and a lot of their apis

01:08:54,640 --> 01:08:58,239
require calm

01:08:55,920 --> 01:08:59,440
so how do we should have good support

01:08:58,239 --> 01:09:00,799
for and russ so that we can take

01:08:59,440 --> 01:09:02,400
advantage of this stuff so that we can

01:09:00,799 --> 01:09:04,719
write things like direct 2d

01:09:02,400 --> 01:09:06,239
applications direct3t applications like

01:09:04,719 --> 01:09:09,600
you know aaa games

01:09:06,239 --> 01:09:11,600
for instance use use these things

01:09:09,600 --> 01:09:12,880
so how do we do that well we need a way

01:09:11,600 --> 01:09:15,520
and russ to declare in

01:09:12,880 --> 01:09:16,319
interfaces to correctly call interface

01:09:15,520 --> 01:09:18,560
methods

01:09:16,319 --> 01:09:20,480
methods on these interfaces to correctly

01:09:18,560 --> 01:09:21,679
hook into the memory management model

01:09:20,480 --> 01:09:23,920
that com deals with

01:09:21,679 --> 01:09:24,880
and to implement these com classes which

01:09:23,920 --> 01:09:28,319
are the like

01:09:24,880 --> 01:09:30,159
objects that implement the interfaces

01:09:28,319 --> 01:09:31,839
so when you as a client are calling

01:09:30,159 --> 01:09:34,319
these interface methods there's some

01:09:31,839 --> 01:09:35,600
object in memory that actually receives

01:09:34,319 --> 01:09:37,279
that method call and does

01:09:35,600 --> 01:09:39,279
the business logic with it so we need

01:09:37,279 --> 01:09:40,960
all of this stuff and more but we won't

01:09:39,279 --> 01:09:43,600
talk about them more

01:09:40,960 --> 01:09:45,520
today so let's look at declaring

01:09:43,600 --> 01:09:48,719
interfaces what does that look like

01:09:45,520 --> 01:09:52,239
well this is uh again this is a a

01:09:48,719 --> 01:09:54,800
crate that i'm working on now um called

01:09:52,239 --> 01:09:55,520
com you can find it on crates.i o under

01:09:54,800 --> 01:09:56,960
com

01:09:55,520 --> 01:09:58,640
um and this is how you declare an

01:09:56,960 --> 01:09:59,760
interface and here we're declaring an

01:09:58,640 --> 01:10:01,920
interface called i

01:09:59,760 --> 01:10:03,920
animal and it has two methods on it you

01:10:01,920 --> 01:10:06,080
can eat some food

01:10:03,920 --> 01:10:06,960
and it can give you its happiness as a

01:10:06,080 --> 01:10:10,000
you size

01:10:06,960 --> 01:10:11,360
so can tell you how happy it is um and

01:10:10,000 --> 01:10:12,960
this is you'll you'll notice it's a bit

01:10:11,360 --> 01:10:15,120
of a funny syntax here you have this

01:10:12,960 --> 01:10:16,960
like uuid thing that's because

01:10:15,120 --> 01:10:18,320
you can get interfaces by a unique

01:10:16,960 --> 01:10:20,159
identifier string

01:10:18,320 --> 01:10:21,440
so we have to to do that that's a part

01:10:20,159 --> 01:10:24,239
we won't talk about

01:10:21,440 --> 01:10:25,520
um and we're passing like a pointer to

01:10:24,239 --> 01:10:27,120
food that's because like we're really

01:10:25,520 --> 01:10:27,679
talking about low level things this has

01:10:27,120 --> 01:10:30,880
to be

01:10:27,679 --> 01:10:34,239
kind of c abi compatible so

01:10:30,880 --> 01:10:36,480
you can't just um you can't pass like a

01:10:34,239 --> 01:10:37,280
a vector a rust vector in there because

01:10:36,480 --> 01:10:40,159
that

01:10:37,280 --> 01:10:41,120
the the abi of a rest vector its layout

01:10:40,159 --> 01:10:43,280
in memory

01:10:41,120 --> 01:10:45,199
is not it's not set in stone so it could

01:10:43,280 --> 01:10:46,480
change from uh compiler version compiler

01:10:45,199 --> 01:10:47,600
version so we have to be very careful

01:10:46,480 --> 01:10:49,760
about what we pass

01:10:47,600 --> 01:10:51,040
across this api layer but this is what

01:10:49,760 --> 01:10:52,719
it looks like kind of in a

01:10:51,040 --> 01:10:54,080
rough way we're declaring an interface i

01:10:52,719 --> 01:10:56,080
animal it inherits from i

01:10:54,080 --> 01:10:57,520
unknown which we'll look at in a second

01:10:56,080 --> 01:10:59,920
it can eat food

01:10:57,520 --> 01:11:02,960
and it can give you its happiness that's

01:10:59,920 --> 01:11:02,960
that's what it looks like here

01:11:03,360 --> 01:11:07,679
um and then we have an interface called

01:11:05,040 --> 01:11:09,440
i unknown that that all other interfaces

01:11:07,679 --> 01:11:10,400
inherit from here and it has three

01:11:09,440 --> 01:11:12,000
methods on it and these

01:11:10,400 --> 01:11:13,520
are the three kind of like this is if

01:11:12,000 --> 01:11:13,840
you want to understand com this is what

01:11:13,520 --> 01:11:16,880
it

01:11:13,840 --> 01:11:18,080
it's all about the first one we'll skip

01:11:16,880 --> 01:11:19,040
the first one for a second query

01:11:18,080 --> 01:11:20,880
interface the first

01:11:19,040 --> 01:11:23,040
the next two are have to do with its

01:11:20,880 --> 01:11:24,800
memory management model so add reference

01:11:23,040 --> 01:11:26,400
is basically increasing its reference

01:11:24,800 --> 01:11:28,080
count and release is

01:11:26,400 --> 01:11:29,760
decrementing its reference count so

01:11:28,080 --> 01:11:31,920
every time that you get a new

01:11:29,760 --> 01:11:33,760
kind of handle on an interface you need

01:11:31,920 --> 01:11:36,480
to call adref

01:11:33,760 --> 01:11:38,640
and if you no longer are using the

01:11:36,480 --> 01:11:39,920
handle you need to call release

01:11:38,640 --> 01:11:41,679
and so hopefully in your head you're

01:11:39,920 --> 01:11:42,560
thinking hey that sounds a lot like you

01:11:41,679 --> 01:11:45,600
know

01:11:42,560 --> 01:11:46,159
clone and drop so like we'll see in a

01:11:45,600 --> 01:11:47,760
second

01:11:46,159 --> 01:11:49,600
at ref will be called every time we

01:11:47,760 --> 01:11:51,679
clone an interface and release will be

01:11:49,600 --> 01:11:54,800
called every time we drop an interface

01:11:51,679 --> 01:11:56,239
and query interface is to say given a

01:11:54,800 --> 01:11:59,760
certain interface and its

01:11:56,239 --> 01:12:02,880
id the uuid that you see on the screen

01:11:59,760 --> 01:12:05,120
there for the for some given interface

01:12:02,880 --> 01:12:06,960
is the interface that i have here

01:12:05,120 --> 01:12:09,040
compatible with this other interface and

01:12:06,960 --> 01:12:10,880
kind of like convert it into it so like

01:12:09,040 --> 01:12:13,280
dynamically at runtime i can just

01:12:10,880 --> 01:12:15,600
provide an id for an interface and

01:12:13,280 --> 01:12:17,679
optionally get that interface from

01:12:15,600 --> 01:12:19,120
from another interface and you know if

01:12:17,679 --> 01:12:20,400
it doesn't support that interface

01:12:19,120 --> 01:12:22,159
because it doesn't implement that

01:12:20,400 --> 01:12:25,280
interface then it just returns uh

01:12:22,159 --> 01:12:26,560
you know a negative result basically so

01:12:25,280 --> 01:12:28,239
that's high unknown

01:12:26,560 --> 01:12:30,159
so now we have to figure out how do we

01:12:28,239 --> 01:12:31,920
actually do interface method calling

01:12:30,159 --> 01:12:33,520
and this is where like this is generated

01:12:31,920 --> 01:12:33,840
code right here you won't actually write

01:12:33,520 --> 01:12:35,840
this

01:12:33,840 --> 01:12:37,600
all that we looked at before that that

01:12:35,840 --> 01:12:40,640
macro that we looked at before is

01:12:37,600 --> 01:12:41,040
is implementing this for you and you can

01:12:40,640 --> 01:12:44,320
see

01:12:41,040 --> 01:12:45,199
that an eye animal interface is just a

01:12:44,320 --> 01:12:48,400
pointer

01:12:45,199 --> 01:12:49,760
to a v table pointer

01:12:48,400 --> 01:12:51,679
so there's a little bit of indirection

01:12:49,760 --> 01:12:53,760
in there on line seven you have a

01:12:51,679 --> 01:12:54,320
non-null pointer that points to another

01:12:53,760 --> 01:12:57,440
pointer

01:12:54,320 --> 01:12:58,560
which points to some a v table and so if

01:12:57,440 --> 01:13:00,239
you're familiar with

01:12:58,560 --> 01:13:02,000
with dynamic dispatch this is what

01:13:00,239 --> 01:13:05,280
dynamic dispatch is all about

01:13:02,000 --> 01:13:07,600
we're going to a v table um a a a

01:13:05,280 --> 01:13:09,440
virtual table where we actually dispatch

01:13:07,600 --> 01:13:12,000
our our method

01:13:09,440 --> 01:13:13,600
great so um you can take a look at the

01:13:12,000 --> 01:13:15,679
code here we're basically just doing a

01:13:13,600 --> 01:13:18,239
bunch of like low level

01:13:15,679 --> 01:13:19,280
casting and and pointer dereferencing

01:13:18,239 --> 01:13:21,679
and stuff like that

01:13:19,280 --> 01:13:24,000
to call into our methods uh in our v

01:13:21,679 --> 01:13:24,000
table

01:13:24,719 --> 01:13:29,520
um and here here i added a

01:13:28,000 --> 01:13:31,679
a little bit to so you can see it better

01:13:29,520 --> 01:13:33,520
sorry that i didn't use that before

01:13:31,679 --> 01:13:35,440
and this is what a v table looks like

01:13:33,520 --> 01:13:37,920
you have the i animal v

01:13:35,440 --> 01:13:39,040
table has its parent v table in it at

01:13:37,920 --> 01:13:42,080
the beginning of it

01:13:39,040 --> 01:13:44,640
and the eat and happiness

01:13:42,080 --> 01:13:46,000
methods in it as well and notice there

01:13:44,640 --> 01:13:47,840
that it's using the standard

01:13:46,000 --> 01:13:50,239
call function that we solved here so we

01:13:47,840 --> 01:13:52,560
know exactly when we call this function

01:13:50,239 --> 01:13:53,440
it will pass the arguments exactly how

01:13:52,560 --> 01:13:55,120
we expect to pass

01:13:53,440 --> 01:13:57,120
we'll get the return arguments exact

01:13:55,120 --> 01:13:58,719
exactly how we expect so

01:13:57,120 --> 01:14:00,560
we're good to go there and again

01:13:58,719 --> 01:14:02,400
represent is important too because this

01:14:00,560 --> 01:14:06,480
all has to be like baked and scone

01:14:02,400 --> 01:14:06,480
exactly how it will be in memory

01:14:08,239 --> 01:14:11,600
um memory management uh real quick we

01:14:10,719 --> 01:14:13,360
said it before

01:14:11,600 --> 01:14:14,719
on when we dropped the i animal

01:14:13,360 --> 01:14:18,159
interface it's going to call

01:14:14,719 --> 01:14:20,560
release um on the i unknown

01:14:18,159 --> 01:14:21,280
interface so that just decrements the

01:14:20,560 --> 01:14:23,040
the pointer

01:14:21,280 --> 01:14:24,880
and of course the the backing

01:14:23,040 --> 01:14:27,040
implementation when the

01:14:24,880 --> 01:14:28,880
reference count reaches zero the whole

01:14:27,040 --> 01:14:31,280
thing will be freed

01:14:28,880 --> 01:14:33,520
because it's not used anymore and on

01:14:31,280 --> 01:14:34,239
clone we're calling ad ref so every time

01:14:33,520 --> 01:14:37,199
we clone

01:14:34,239 --> 01:14:38,719
a handle to our our interface we add a

01:14:37,199 --> 01:14:40,719
reference to it

01:14:38,719 --> 01:14:42,800
and this is how memory is managed so you

01:14:40,719 --> 01:14:46,159
can you basically can be assured that

01:14:42,800 --> 01:14:48,719
as long as you have a um an eye animal

01:14:46,159 --> 01:14:49,920
that it's it has valid uh it has valid

01:14:48,719 --> 01:14:51,920
memory because we're

01:14:49,920 --> 01:14:53,840
we're only getting another one if we

01:14:51,920 --> 01:14:56,239
clone and we're in adding ref

01:14:53,840 --> 01:14:59,440
and we're only releasing it when we drop

01:14:56,239 --> 01:15:01,840
the thing and we no longer use it

01:14:59,440 --> 01:15:02,560
and then real quick exposing a class

01:15:01,840 --> 01:15:04,159
looks

01:15:02,560 --> 01:15:05,840
like this so we're basically doing the

01:15:04,159 --> 01:15:08,159
reverse where

01:15:05,840 --> 01:15:10,719
we declare the implementing class in

01:15:08,159 --> 01:15:13,280
this case our animal is a lion

01:15:10,719 --> 01:15:14,960
and we have to implement the the eat and

01:15:13,280 --> 01:15:18,000
happiness methods on it

01:15:14,960 --> 01:15:18,880
here and what the macro the class bang

01:15:18,000 --> 01:15:21,520
macro does

01:15:18,880 --> 01:15:22,320
is basically in reverse implement a v

01:15:21,520 --> 01:15:25,760
table

01:15:22,320 --> 01:15:27,840
that when it gets called it will call

01:15:25,760 --> 01:15:29,280
our our eat and our happiness methods

01:15:27,840 --> 01:15:31,199
for us

01:15:29,280 --> 01:15:32,640
and so everything kind of lines up the

01:15:31,199 --> 01:15:35,440
client can call into a v

01:15:32,640 --> 01:15:37,280
table the class implements that b table

01:15:35,440 --> 01:15:39,040
and when the client calls through

01:15:37,280 --> 01:15:40,880
that v table it will go to the

01:15:39,040 --> 01:15:42,000
implementation that's done here and

01:15:40,880 --> 01:15:44,719
everything lines up

01:15:42,000 --> 01:15:45,600
because the apis are set everything is

01:15:44,719 --> 01:15:47,520
kind of

01:15:45,600 --> 01:15:49,840
set in stone exactly how it will be in

01:15:47,520 --> 01:15:53,280
memory

01:15:49,840 --> 01:15:54,640
and we're done yay that's it

01:15:53,280 --> 01:15:56,400
not really there's a whole bunch of

01:15:54,640 --> 01:15:59,280
other you know cruft and

01:15:56,400 --> 01:16:00,000
and calm is actually super complicated

01:15:59,280 --> 01:16:03,360
um so

01:16:00,000 --> 01:16:05,199
you know if this is weirdly strangely

01:16:03,360 --> 01:16:07,440
interesting to you you can get lost

01:16:05,199 --> 01:16:08,800
uh in it um there's a whole bunch of

01:16:07,440 --> 01:16:10,480
other stuff in there like registering

01:16:08,800 --> 01:16:12,400
classes class factories blah blah blah

01:16:10,480 --> 01:16:14,640
we're not going to get into any of that

01:16:12,400 --> 01:16:16,560
um we just looked at kind of the core

01:16:14,640 --> 01:16:19,840
low-level thing of how we call

01:16:16,560 --> 01:16:21,600
into a an interface and how we implement

01:16:19,840 --> 01:16:22,880
that interface

01:16:21,600 --> 01:16:25,760
and this is what it looks like in real

01:16:22,880 --> 01:16:28,480
life here's a some direct 2d code being

01:16:25,760 --> 01:16:30,000
called in here it's for an app that i'm

01:16:28,480 --> 01:16:31,280
working on right now that is not

01:16:30,000 --> 01:16:33,040
finished

01:16:31,280 --> 01:16:34,480
this is what it looks like right now

01:16:33,040 --> 01:16:36,880
eventually it will be a clock

01:16:34,480 --> 01:16:38,320
that will go around it's not done i

01:16:36,880 --> 01:16:38,640
didn't know i was giving this talk today

01:16:38,320 --> 01:16:42,239
so

01:16:38,640 --> 01:16:44,800
sorry for the unfinished clock

01:16:42,239 --> 01:16:45,840
um if you're interested in uh and

01:16:44,800 --> 01:16:49,520
looking into this

01:16:45,840 --> 01:16:51,679
windows programming weird 30 year old

01:16:49,520 --> 01:16:53,520
interfaces and stuff like that come come

01:16:51,679 --> 01:16:55,600
join us you'll notice

01:16:53,520 --> 01:16:58,000
down below it says com has been

01:16:55,600 --> 01:16:58,800
superseded by winrt windows runtime

01:16:58,000 --> 01:17:02,000
which is true

01:16:58,800 --> 01:17:05,120
if and you should probably not use com

01:17:02,000 --> 01:17:06,560
unless you have to which is for direct2d

01:17:05,120 --> 01:17:09,280
the case

01:17:06,560 --> 01:17:10,880
you should use instead when rt which i

01:17:09,280 --> 01:17:13,360
said before is built on top

01:17:10,880 --> 01:17:14,000
of of com and the great thing about when

01:17:13,360 --> 01:17:16,719
rt com

01:17:14,000 --> 01:17:18,640
is very unsafe you can screw things up

01:17:16,719 --> 01:17:20,000
and stuff like that when rt is built on

01:17:18,640 --> 01:17:22,719
top of metadata

01:17:20,000 --> 01:17:24,719
that as long as the metadata is is good

01:17:22,719 --> 01:17:26,080
you can build completely safe apis and

01:17:24,719 --> 01:17:28,480
so we can build

01:17:26,080 --> 01:17:30,400
rather idiomatic rest apis that just

01:17:28,480 --> 01:17:32,159
directly call into windows

01:17:30,400 --> 01:17:33,679
for us and it's all machine generated

01:17:32,159 --> 01:17:34,960
which is super great

01:17:33,679 --> 01:17:37,360
com on the other hand has to be

01:17:34,960 --> 01:17:40,640
implemented or declared by hand

01:17:37,360 --> 01:17:42,560
which is a real bummer

01:17:40,640 --> 01:17:43,760
this is what when rt looks like so

01:17:42,560 --> 01:17:45,840
you're importing some

01:17:43,760 --> 01:17:46,960
namespaces and then you get safe real

01:17:45,840 --> 01:17:50,400
safe code

01:17:46,960 --> 01:17:50,400
uh that you can call in here

01:17:51,120 --> 01:17:55,280
and it's all built on a foundation of

01:17:53,520 --> 01:17:58,560
the snarly unsafe

01:17:55,280 --> 01:18:02,560
com that we just looked at but is

01:17:58,560 --> 01:18:04,800
because of the metadata safe to to call

01:18:02,560 --> 01:18:07,120
all right and that was a whirlwind tour

01:18:04,800 --> 01:18:09,520
of a 30-year-old technology

01:18:07,120 --> 01:18:11,360
and here's awkward bill gates dancing so

01:18:09,520 --> 01:18:15,920
if you have any questions

01:18:11,360 --> 01:18:18,800
let me know amazing

01:18:15,920 --> 01:18:20,800
super nice talk there was no paint or

01:18:18,800 --> 01:18:22,960
minesweeper but

01:18:20,800 --> 01:18:24,960
that's which they by the way probably do

01:18:22,960 --> 01:18:27,120
use calm inside of them so now you know

01:18:24,960 --> 01:18:31,280
how they work

01:18:27,120 --> 01:18:35,760
no super super nice talk um

01:18:31,280 --> 01:18:37,199
we have a few questions we have a

01:18:35,760 --> 01:18:41,120
comment

01:18:37,199 --> 01:18:45,040
uh like a random note firefox is using

01:18:41,120 --> 01:18:47,280
xpcom the x-rays platform

01:18:45,040 --> 01:18:48,400
the cross-platform component object

01:18:47,280 --> 01:18:50,960
model pretty

01:18:48,400 --> 01:18:55,199
similar to microsoft com and yes we can

01:18:50,960 --> 01:18:57,679
implement xbcom objects in rust

01:18:55,199 --> 01:18:58,560
and it would be hopefully at some point

01:18:57,679 --> 01:19:01,440
uh

01:18:58,560 --> 01:19:02,480
like com on linux which is still used uh

01:19:01,440 --> 01:19:04,640
for instance

01:19:02,480 --> 01:19:06,960
um and and for the stuff in firefox you

01:19:04,640 --> 01:19:09,120
should be able to use the commerce

01:19:06,960 --> 01:19:10,560
crate for that as well so maybe we can

01:19:09,120 --> 01:19:12,080
start consolidating the

01:19:10,560 --> 01:19:14,159
the community a little bit so there's

01:19:12,080 --> 01:19:14,880
not a ton of different implementations

01:19:14,159 --> 01:19:17,760
but

01:19:14,880 --> 01:19:19,199
right now it's all it assumes windows

01:19:17,760 --> 01:19:22,719
for now so

01:19:19,199 --> 01:19:23,760
that's i gotta work on that okay wow

01:19:22,719 --> 01:19:27,360
there are more and more

01:19:23,760 --> 01:19:32,000
questions um i pick a few

01:19:27,360 --> 01:19:32,000
does it support method overwriting

01:19:32,640 --> 01:19:40,080
does com support method of overloading

01:19:36,000 --> 01:19:42,159
um i believe it does

01:19:40,080 --> 01:19:43,280
it should in languages that support

01:19:42,159 --> 01:19:46,000
overloading you would

01:19:43,280 --> 01:19:46,640
because the methods the names of the

01:19:46,000 --> 01:19:48,800
methods

01:19:46,640 --> 01:19:50,560
don't actually matter it's just their

01:19:48,800 --> 01:19:52,159
place in the v table

01:19:50,560 --> 01:19:53,679
and so we have a mapping in our rust

01:19:52,159 --> 01:19:57,120
code that says like the eat

01:19:53,679 --> 01:19:59,679
function on i animal is like the second

01:19:57,120 --> 01:20:00,719
method in the v table and so if the

01:19:59,679 --> 01:20:03,040
backing

01:20:00,719 --> 01:20:04,159
class that implements that calls it you

01:20:03,040 --> 01:20:06,159
know fubar

01:20:04,159 --> 01:20:08,320
instead of e doesn't matter as long as

01:20:06,159 --> 01:20:09,600
it is just it has the same signature and

01:20:08,320 --> 01:20:12,080
it's in the same place in the v

01:20:09,600 --> 01:20:13,040
table and so you could in theory have

01:20:12,080 --> 01:20:15,280
multiple

01:20:13,040 --> 01:20:17,679
uh methods named the same thing as long

01:20:15,280 --> 01:20:19,520
as they dispatched to two places in

01:20:17,679 --> 01:20:21,199
in the v table but of course rust can't

01:20:19,520 --> 01:20:22,800
support that because rust doesn't

01:20:21,199 --> 01:20:24,480
support overloading so you'd have to

01:20:22,800 --> 01:20:28,320
give them different names

01:20:24,480 --> 01:20:31,920
but yeah cool

01:20:28,320 --> 01:20:32,400
next question is um does does the new

01:20:31,920 --> 01:20:37,120
win

01:20:32,400 --> 01:20:40,159
ui use com2 so when ui uses winrt

01:20:37,120 --> 01:20:42,080
under the hood um and so if you're

01:20:40,159 --> 01:20:45,040
interested in when ui

01:20:42,080 --> 01:20:45,520
then contribute to the winrg project and

01:20:45,040 --> 01:20:47,920
because

01:20:45,520 --> 01:20:51,520
when rt uses com under the hood then yes

01:20:47,920 --> 01:20:54,400
when ui uses com at the end of the day

01:20:51,520 --> 01:20:56,800
we are working on there's a whole bunch

01:20:54,400 --> 01:20:58,960
of things in addition to com basic com

01:20:56,800 --> 01:20:59,679
support and basic winrt support that are

01:20:58,960 --> 01:21:01,600
needed for

01:20:59,679 --> 01:21:03,360
wind ui and we're working towards that

01:21:01,600 --> 01:21:04,320
so yes eventually you will be able to

01:21:03,360 --> 01:21:07,679
write

01:21:04,320 --> 01:21:10,560
when ui windows applications uh

01:21:07,679 --> 01:21:12,000
in rust and just plain hopefully rather

01:21:10,560 --> 01:21:15,440
idiomatic

01:21:12,000 --> 01:21:18,400
uh rust so come join help us

01:21:15,440 --> 01:21:21,760
build that this one's a reason to get a

01:21:18,400 --> 01:21:25,520
like a windows laptop soon again

01:21:21,760 --> 01:21:27,120
and i pick one more um what's the plan

01:21:25,520 --> 01:21:29,199
at microsoft to use

01:21:27,120 --> 01:21:31,040
rust on com interface i think you just

01:21:29,199 --> 01:21:33,920
answered this

01:21:31,040 --> 01:21:34,480
yeah there's a whole uh i mean we want

01:21:33,920 --> 01:21:36,000
to

01:21:34,480 --> 01:21:38,880
start using more and more rust at

01:21:36,000 --> 01:21:41,760
microsoft and a bunch of our

01:21:38,880 --> 01:21:42,239
obviously our external apis are com

01:21:41,760 --> 01:21:45,600
based

01:21:42,239 --> 01:21:46,880
and internal apis that you know outside

01:21:45,600 --> 01:21:50,320
developers don't ever see

01:21:46,880 --> 01:21:52,560
are also com based and so

01:21:50,320 --> 01:21:54,080
and we have a bunch of technology that

01:21:52,560 --> 01:21:56,719
we definitely are still

01:21:54,080 --> 01:21:57,280
very much investing in that's like like

01:21:56,719 --> 01:21:58,880
when our t

01:21:57,280 --> 01:22:00,480
for instance it's built on top of com so

01:21:58,880 --> 01:22:03,600
this is all like so

01:22:00,480 --> 01:22:06,239
com itself isn't used

01:22:03,600 --> 01:22:07,120
very much nowadays but like it's still

01:22:06,239 --> 01:22:09,600
being used by

01:22:07,120 --> 01:22:11,280
other technologies that wrap it and

01:22:09,600 --> 01:22:15,520
those are super important

01:22:11,280 --> 01:22:18,320
to the windows ecosystem so

01:22:15,520 --> 01:22:19,360
okay and then let's ask the last the

01:22:18,320 --> 01:22:22,400
last one too

01:22:19,360 --> 01:22:23,040
um are you also planning to add a layer

01:22:22,400 --> 01:22:26,320
on top of

01:22:23,040 --> 01:22:29,760
com rs that makes it safe so

01:22:26,320 --> 01:22:32,800
i tried to do this

01:22:29,760 --> 01:22:34,320
and it's just not possible because

01:22:32,800 --> 01:22:35,840
and that's the difference between when

01:22:34,320 --> 01:22:37,840
rt and calm

01:22:35,840 --> 01:22:38,880
there's basically just not enough

01:22:37,840 --> 01:22:44,000
information

01:22:38,880 --> 01:22:47,120
that you have from from a com interface

01:22:44,000 --> 01:22:50,159
that would make it safe

01:22:47,120 --> 01:22:53,199
now if you

01:22:50,159 --> 01:22:53,840
we might add a layer to comrs that would

01:22:53,199 --> 01:22:56,560
allow you

01:22:53,840 --> 01:22:57,520
if you're writing a interface and rust

01:22:56,560 --> 01:22:59,920
and

01:22:57,520 --> 01:23:00,800
the backing implementation is in rust

01:22:59,920 --> 01:23:02,480
that you can

01:23:00,800 --> 01:23:04,480
assume that it's safe and maybe we'll

01:23:02,480 --> 01:23:07,600
add some support there

01:23:04,480 --> 01:23:08,960
um but but really there's just there's

01:23:07,600 --> 01:23:11,440
not enough information to

01:23:08,960 --> 01:23:13,120
know whether what you're doing is fully

01:23:11,440 --> 01:23:16,400
safe according to

01:23:13,120 --> 01:23:17,840
uh to the rust um runtime um

01:23:16,400 --> 01:23:19,440
there are some things that will

01:23:17,840 --> 01:23:22,719
definitely make it safer

01:23:19,440 --> 01:23:26,000
to use for instance we're working um

01:23:22,719 --> 01:23:28,000
in the um

01:23:26,000 --> 01:23:29,040
sorry in the safe transmute working

01:23:28,000 --> 01:23:32,239
group which

01:23:29,040 --> 01:23:34,960
i'm in in order to better

01:23:32,239 --> 01:23:36,960
be able to declare types as having

01:23:34,960 --> 01:23:40,320
certain layouts in memory

01:23:36,960 --> 01:23:42,080
um with the type system so so being able

01:23:40,320 --> 01:23:43,040
to say in the type system this type has

01:23:42,080 --> 01:23:46,000
a stable

01:23:43,040 --> 01:23:47,040
layout it you know is this big it's it

01:23:46,000 --> 01:23:49,840
has this

01:23:47,040 --> 01:23:51,840
alignment blah blah blah you can't talk

01:23:49,840 --> 01:23:54,000
about in the in the type system today

01:23:51,840 --> 01:23:54,960
about those ideas we're gonna make it so

01:23:54,000 --> 01:23:56,639
that you can

01:23:54,960 --> 01:23:58,719
and then we can encode that and some of

01:23:56,639 --> 01:24:00,719
these apis and make it so that it's

01:23:58,719 --> 01:24:02,400
harder and harder to screw up the com

01:24:00,719 --> 01:24:03,520
api but i don't think we'll ever get to

01:24:02,400 --> 01:24:05,120
a point where we can make it

01:24:03,520 --> 01:24:06,639
fully where you don't have to write

01:24:05,120 --> 01:24:08,320
unsafe because

01:24:06,639 --> 01:24:09,920
um there's just not enough info to know

01:24:08,320 --> 01:24:11,679
that but hopefully you know

01:24:09,920 --> 01:24:14,000
it'll be very hard to make a mistake

01:24:11,679 --> 01:24:17,679
that will crash your computer

01:24:14,000 --> 01:24:20,960
at some point it makes sense yeah well

01:24:17,679 --> 01:24:23,600
thank you so much um yeah

01:24:20,960 --> 01:24:24,000
and there is a little like announcement

01:24:23,600 --> 01:24:26,480
from

01:24:24,000 --> 01:24:28,840
sisha and there's no rust and tell

01:24:26,480 --> 01:24:31,840
without question

01:24:28,840 --> 01:24:31,840
so

01:24:32,350 --> 01:24:42,820
[Laughter]

01:24:43,520 --> 01:24:48,719
um um no um

01:24:47,199 --> 01:24:50,639
it's just that i wanted to announce that

01:24:48,719 --> 01:24:53,160
i've been talking a lot about zebus in

01:24:50,639 --> 01:24:54,320
in some presentations in this

01:24:53,160 --> 01:24:57,199
[Music]

01:24:54,320 --> 01:24:59,199
rest until so we finally finally

01:24:57,199 --> 01:25:02,320
released 1.0

01:24:59,199 --> 01:25:02,639
a week ago so if anyone want to try it

01:25:02,320 --> 01:25:04,639
out

01:25:02,639 --> 01:25:05,840
please do and let us know if there's any

01:25:04,639 --> 01:25:09,360
problems

01:25:05,840 --> 01:25:11,760
yeah thank you thank you so much

01:25:09,360 --> 01:25:12,480
we will try it out and there is the link

01:25:11,760 --> 01:25:15,679
in the

01:25:12,480 --> 01:25:18,960
zoom chat for people who want to see it

01:25:15,679 --> 01:25:23,679
cool well if there are any if there

01:25:18,960 --> 01:25:27,360
are any last questions from anyone

01:25:23,679 --> 01:25:30,960
feel free to talk

01:25:27,360 --> 01:25:34,080
and if not we see you in august

01:25:30,960 --> 01:25:35,520
last tuesday of the month as always feel

01:25:34,080 --> 01:25:38,719
free to get in touch with

01:25:35,520 --> 01:25:41,199
ryan or me to give a talk

01:25:38,719 --> 01:25:42,719
you can just talk you don't even have to

01:25:41,199 --> 01:25:46,239
have slides

01:25:42,719 --> 01:25:47,440
or something just share your ideas your

01:25:46,239 --> 01:25:50,639
code

01:25:47,440 --> 01:25:52,159
browser tabs are fine just feel free to

01:25:50,639 --> 01:25:56,159
take this as you first

01:25:52,159 --> 01:25:58,480
step into the talk speak rust

01:25:56,159 --> 01:25:58,480
world

01:25:59,840 --> 01:26:04,480
okay thank you so much people

01:26:04,960 --> 01:26:09,840

YouTube URL: https://www.youtube.com/watch?v=0Bj-5C2Zfqs


