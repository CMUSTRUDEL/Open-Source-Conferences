Title: Christian Poveda - Miri, Undefined Behavior and Foreign Functions â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	Do you want to write unsafe Rust but don't know how to check its soundness? Do you suspect that your program has Undefined Behavior but you have no way to test it? Are you looking for a cool Rust-related project to contribute to? Then this talk is for you.

More at https://rustfest.global/session/12-miri,-undefined-behavior-and-foreign-functions/
Captions: 
	00:00:02,720 --> 00:00:06,399
miri

00:00:03,360 --> 00:00:09,599
is rust's interpreter and

00:00:06,399 --> 00:00:10,800
christian will gladly debate her on how

00:00:09,599 --> 00:00:14,240
to bequeath

00:00:10,800 --> 00:00:17,920
her the stuff underneath so she can run

00:00:14,240 --> 00:00:17,920
until much later

00:00:19,920 --> 00:00:23,199
okay thank you so

00:00:21,440 --> 00:00:25,680
[Music]

00:00:23,199 --> 00:00:27,279
this stock install is called very

00:00:25,680 --> 00:00:28,160
undefined behavior and for rank

00:00:27,279 --> 00:00:30,800
functions

00:00:28,160 --> 00:00:31,679
so but before even we begin let me just

00:00:30,800 --> 00:00:34,239
introduce me at

00:00:31,679 --> 00:00:35,520
a bit myself so i'm christian poeda i'm

00:00:34,239 --> 00:00:38,000
colombian

00:00:35,520 --> 00:00:40,079
uh as you already know i'm a phd student

00:00:38,000 --> 00:00:41,920
at the india software institute

00:00:40,079 --> 00:00:44,079
occasionally i contribute to the ros

00:00:41,920 --> 00:00:45,920
compiler project and also to the mirror

00:00:44,079 --> 00:00:48,079
project

00:00:45,920 --> 00:00:51,440
i don't work on it like full time i just

00:00:48,079 --> 00:00:51,440
do it like when i have free time

00:00:52,239 --> 00:00:57,760
so first of all i want to

00:00:55,280 --> 00:00:59,840
say what i want to give this like what i

00:00:57,760 --> 00:01:03,039
think this is important somehow

00:00:59,840 --> 00:01:06,400
the first thing is that unsave is

00:01:03,039 --> 00:01:08,560
a controversial topic in our community

00:01:06,400 --> 00:01:10,799
but at the same time is something that

00:01:08,560 --> 00:01:13,439
we need is something super special that

00:01:10,799 --> 00:01:15,759
ross needs to work and to be able to do

00:01:13,439 --> 00:01:18,240
the awesome stuff that already does

00:01:15,759 --> 00:01:19,360
so basically every program you have uses

00:01:18,240 --> 00:01:21,200
unsafe

00:01:19,360 --> 00:01:22,400
in one way or another even if you don't

00:01:21,200 --> 00:01:23,759
know it

00:01:22,400 --> 00:01:25,759
and it's very important to have

00:01:23,759 --> 00:01:28,640
awareness of the implications

00:01:25,759 --> 00:01:29,360
of what happens when you use aeon saving

00:01:28,640 --> 00:01:32,640
correctly

00:01:29,360 --> 00:01:32,640
or if someone else does

00:01:33,360 --> 00:01:36,960
and also i want to show you a super cool

00:01:35,360 --> 00:01:38,799
tool that you can use to

00:01:36,960 --> 00:01:40,960
write better and safe code that helps

00:01:38,799 --> 00:01:42,399
you when you're unsafe code is wrong

00:01:40,960 --> 00:01:44,240
because this goes in the same direction

00:01:42,399 --> 00:01:46,560
as the empowering philosophy that the

00:01:44,240 --> 00:01:49,759
risk community has of being able to use

00:01:46,560 --> 00:01:51,200
to build reliable software and at the

00:01:49,759 --> 00:01:52,640
same time having a super friendly

00:01:51,200 --> 00:01:54,799
community with a bunch of tools that

00:01:52,640 --> 00:01:57,360
help you to build that so

00:01:54,799 --> 00:01:59,439
it was in that direction uh this talk

00:01:57,360 --> 00:02:02,719
will have like four parts basically

00:01:59,439 --> 00:02:04,640
first i'm going to show you a bit uh

00:02:02,719 --> 00:02:06,399
do a little introduction to unsafe and

00:02:04,640 --> 00:02:08,479
what's undefined behavior

00:02:06,399 --> 00:02:10,720
and how that everything works in rust

00:02:08,479 --> 00:02:12,800
then we're going to talk about miri

00:02:10,720 --> 00:02:14,080
miri is this super cool tool uh i'm

00:02:12,800 --> 00:02:16,480
talking about

00:02:14,080 --> 00:02:18,879
and then we're going to talk a bit uh

00:02:16,480 --> 00:02:21,599
about following functions

00:02:18,879 --> 00:02:22,160
and if you like this you think this is

00:02:21,599 --> 00:02:24,560
interesting

00:02:22,160 --> 00:02:25,520
for you i can give you some ideas at the

00:02:24,560 --> 00:02:28,000
end on

00:02:25,520 --> 00:02:29,680
how can you help contributing in all of

00:02:28,000 --> 00:02:32,319
this

00:02:29,680 --> 00:02:32,879
so let's begin by talking about unsafe

00:02:32,319 --> 00:02:36,720
rust and

00:02:32,879 --> 00:02:38,400
undefined behavior um before even

00:02:36,720 --> 00:02:39,920
talking about undefined behavior i think

00:02:38,400 --> 00:02:43,040
super important to know

00:02:39,920 --> 00:02:46,720
or to discuss why people use unsafe

00:02:43,040 --> 00:02:46,720
unsafe rust in the first place

00:02:46,879 --> 00:02:51,200
there are two main reasons the first one

00:02:49,920 --> 00:02:54,239
is that

00:02:51,200 --> 00:02:56,160
some people using safe because they are

00:02:54,239 --> 00:02:58,239
very invested in performance they want

00:02:56,160 --> 00:03:02,159
their programs to run super fast

00:02:58,239 --> 00:03:03,920
so they are ensuring everyone that their

00:03:02,159 --> 00:03:04,400
programs are running correctly even if

00:03:03,920 --> 00:03:06,319
that

00:03:04,400 --> 00:03:08,800
program those programs don't have any

00:03:06,319 --> 00:03:11,120
check to to be sure that

00:03:08,800 --> 00:03:11,920
they're running correctly and not doing

00:03:11,120 --> 00:03:13,680
a lot of checks

00:03:11,920 --> 00:03:15,200
uh lets you squeeze a little bit more of

00:03:13,680 --> 00:03:17,760
performance when you're running

00:03:15,200 --> 00:03:19,280
when you're writing your programs and

00:03:17,760 --> 00:03:20,720
there is a lot of controversy around

00:03:19,280 --> 00:03:23,120
this one some people say that

00:03:20,720 --> 00:03:23,840
yeah performance matters but safety is

00:03:23,120 --> 00:03:25,360
first

00:03:23,840 --> 00:03:27,040
there are a lot of trade-offs you can do

00:03:25,360 --> 00:03:29,440
there but

00:03:27,040 --> 00:03:32,799
the second reason is a little bit more

00:03:29,440 --> 00:03:35,680
less controversial in the sense that

00:03:32,799 --> 00:03:36,640
many projects we have invest need to

00:03:35,680 --> 00:03:38,799
interact with

00:03:36,640 --> 00:03:39,760
other languages or with your operating

00:03:38,799 --> 00:03:41,440
system

00:03:39,760 --> 00:03:44,560
or with a bunch of resources that

00:03:41,440 --> 00:03:46,959
haven't written it themselves in rust

00:03:44,560 --> 00:03:47,840
so most likely you will have to interact

00:03:46,959 --> 00:03:50,400
with a c or c

00:03:47,840 --> 00:03:52,000
plus library or use a crate that

00:03:50,400 --> 00:03:52,720
interacts with a c or c plus plus

00:03:52,000 --> 00:03:54,159
library

00:03:52,720 --> 00:03:56,000
and those languages doesn't have like

00:03:54,159 --> 00:03:59,439
the same guarantees that has about

00:03:56,000 --> 00:04:00,400
safety and having sound programs and so

00:03:59,439 --> 00:04:02,319
on

00:04:00,400 --> 00:04:03,680
so all those functions that interact

00:04:02,319 --> 00:04:06,640
with c libraries

00:04:03,680 --> 00:04:06,640
are unsafe too

00:04:09,439 --> 00:04:14,239
so now we can discuss what onsafe can do

00:04:13,920 --> 00:04:16,720
so

00:04:14,239 --> 00:04:17,280
inside unsafe functions or on safe

00:04:16,720 --> 00:04:19,600
blocks

00:04:17,280 --> 00:04:22,400
any of the two there is not much you can

00:04:19,600 --> 00:04:25,600
do actually you can do only five things

00:04:22,400 --> 00:04:26,720
not anymore you can dereference raw

00:04:25,600 --> 00:04:29,840
pointers

00:04:26,720 --> 00:04:30,800
you can call functions that are marked

00:04:29,840 --> 00:04:32,800
as unsafe

00:04:30,800 --> 00:04:34,720
so if you have a function that is called

00:04:32,800 --> 00:04:36,479
unsafe fn and the name of the function

00:04:34,720 --> 00:04:37,199
you need to use unsafe to call it you

00:04:36,479 --> 00:04:39,199
have to use

00:04:37,199 --> 00:04:40,880
do it in an unsafe block or in another

00:04:39,199 --> 00:04:43,040
safe function

00:04:40,880 --> 00:04:44,080
there are some traits that are marked as

00:04:43,040 --> 00:04:46,160
unsafe too

00:04:44,080 --> 00:04:48,240
so if you want to implement those traits

00:04:46,160 --> 00:04:50,400
like send and sync from the standard

00:04:48,240 --> 00:04:52,320
library you have to use in safe

00:04:50,400 --> 00:04:53,680
if you want to mutate the statics

00:04:52,320 --> 00:04:56,000
because you're sure that the program

00:04:53,680 --> 00:04:58,080
needs some sort of mutable global global

00:04:56,000 --> 00:05:00,000
state even if some people don't like it

00:04:58,080 --> 00:05:03,520
you can easily save to do that

00:05:00,000 --> 00:05:05,199
you can use a unsafe to access

00:05:03,520 --> 00:05:06,880
fields of unions unions are like

00:05:05,199 --> 00:05:08,560
enumerations but they don't have like

00:05:06,880 --> 00:05:11,600
this consistent tag

00:05:08,560 --> 00:05:13,759
to distinguish each variant so it's like

00:05:11,600 --> 00:05:14,960
you can literally join two types of the

00:05:13,759 --> 00:05:18,000
uh

00:05:14,960 --> 00:05:20,400
in a single one and use

00:05:18,000 --> 00:05:21,680
every value of that type as any of the

00:05:20,400 --> 00:05:23,440
possible variants of the

00:05:21,680 --> 00:05:24,720
at the same time so you need to unsafe

00:05:23,440 --> 00:05:27,600
to access the

00:05:24,720 --> 00:05:29,199
fields however for the purposes of this

00:05:27,600 --> 00:05:30,720
we're just going to focus on the first

00:05:29,199 --> 00:05:31,520
two because those are like the more

00:05:30,720 --> 00:05:33,360
common

00:05:31,520 --> 00:05:35,440
uh most likely any of us has been

00:05:33,360 --> 00:05:40,400
exposed to one of these

00:05:35,440 --> 00:05:40,400
at what at one point uh

00:05:41,680 --> 00:05:45,199
and given that the first one is the

00:05:43,759 --> 00:05:47,440
referencing row pointers

00:05:45,199 --> 00:05:50,320
uh i think it's worth to discuss for

00:05:47,440 --> 00:05:50,320
pointers for a moment

00:05:51,280 --> 00:05:57,919
so what are raw pointers uh many of you

00:05:55,039 --> 00:05:59,600
uh if you have already using use rust

00:05:57,919 --> 00:06:00,880
you know that we have references we have

00:05:59,600 --> 00:06:03,520
ampersand mute

00:06:00,880 --> 00:06:05,280
and our prints are ampersand for mutable

00:06:03,520 --> 00:06:08,479
and immutable references

00:06:05,280 --> 00:06:11,680
but those types have like these two

00:06:08,479 --> 00:06:13,840
brothers or sisters siblings whatever

00:06:11,680 --> 00:06:15,039
uh there are called raw pointers we have

00:06:13,840 --> 00:06:18,240
star const and

00:06:15,039 --> 00:06:20,639
star moot story cons is an immutable

00:06:18,240 --> 00:06:22,240
draw pointer and stormwood is a mutable

00:06:20,639 --> 00:06:24,240
row pointer

00:06:22,240 --> 00:06:26,080
and they exist because they don't follow

00:06:24,240 --> 00:06:27,440
the same rules as references

00:06:26,080 --> 00:06:29,600
they don't have these liveness

00:06:27,440 --> 00:06:30,160
constraints for example if you have some

00:06:29,600 --> 00:06:32,960
data

00:06:30,160 --> 00:06:34,160
and you create a pointer to it and you

00:06:32,960 --> 00:06:36,240
drop the data

00:06:34,160 --> 00:06:38,240
it goes out of the scope is deleted you

00:06:36,240 --> 00:06:40,000
can still have the raw pointer to it

00:06:38,240 --> 00:06:42,400
even though it's pointing to something

00:06:40,000 --> 00:06:44,400
that doesn't even exist anymore

00:06:42,400 --> 00:06:46,960
so for these reasons there is something

00:06:44,400 --> 00:06:49,199
else and you can also like

00:06:46,960 --> 00:06:50,720
offset those pointers using integers so

00:06:49,199 --> 00:06:52,560
if you have a pointer

00:06:50,720 --> 00:06:54,400
to a particular remember particular

00:06:52,560 --> 00:06:56,960
memory address you can add it

00:06:54,400 --> 00:06:58,000
like an integer and you size to it and

00:06:56,960 --> 00:07:00,000
you can offset it

00:06:58,000 --> 00:07:02,080
so you can read like another part of the

00:07:00,000 --> 00:07:04,160
memory and maybe you're not supposed

00:07:02,080 --> 00:07:05,680
to for those two reasons those pointers

00:07:04,160 --> 00:07:07,919
might have a lot of problems and

00:07:05,680 --> 00:07:08,960
might misbehave in several reasons you

00:07:07,919 --> 00:07:11,280
can have

00:07:08,960 --> 00:07:12,960
no pointers that are real pointers that

00:07:11,280 --> 00:07:14,080
don't point doesn't point to anything

00:07:12,960 --> 00:07:15,919
really

00:07:14,080 --> 00:07:17,280
uh they can be dangling there are

00:07:15,919 --> 00:07:19,680
pointers

00:07:17,280 --> 00:07:21,120
that let's say are pointing to something

00:07:19,680 --> 00:07:22,960
that doesn't belong to us

00:07:21,120 --> 00:07:24,960
so if you are inside a vector and you

00:07:22,960 --> 00:07:25,759
saw a pointer from inside the vector to

00:07:24,960 --> 00:07:27,280
access something

00:07:25,759 --> 00:07:29,759
outside the vector that's an angling

00:07:27,280 --> 00:07:33,120
pointer

00:07:29,759 --> 00:07:36,240
also if you have a pointer

00:07:33,120 --> 00:07:37,919
that you offset it a bit but you didn't

00:07:36,240 --> 00:07:39,039
do it correctly so for example you have

00:07:37,919 --> 00:07:42,319
a pointer between

00:07:39,039 --> 00:07:44,479
i don't know u64s and you just moved

00:07:42,319 --> 00:07:45,680
i don't know 16 bits instead instead of

00:07:44,479 --> 00:07:48,400
64 sweets

00:07:45,680 --> 00:07:49,440
you will be you will end up reading like

00:07:48,400 --> 00:07:52,720
in between

00:07:49,440 --> 00:07:56,400
values that's an unaligned pointer

00:07:52,720 --> 00:07:57,919
and okay so those are all pointers you

00:07:56,400 --> 00:08:00,080
can do like a lot of nasty stuff with

00:07:57,919 --> 00:08:02,560
them we are not sure why

00:08:00,080 --> 00:08:03,759
that's wrong really right now we will go

00:08:02,560 --> 00:08:06,720
into that later

00:08:03,759 --> 00:08:08,720
but let me show you an example a super

00:08:06,720 --> 00:08:11,199
tiny example of

00:08:08,720 --> 00:08:13,120
how to use these raw pointers and how to

00:08:11,199 --> 00:08:16,319
use and save and so on

00:08:13,120 --> 00:08:17,520
um so here in my terminal i have in my

00:08:16,319 --> 00:08:20,960
editor i have this

00:08:17,520 --> 00:08:21,360
tiny crate it has a single struct it's

00:08:20,960 --> 00:08:24,319
called

00:08:21,360 --> 00:08:25,280
byte array this byte array has a mutable

00:08:24,319 --> 00:08:28,319
row pointer

00:08:25,280 --> 00:08:30,240
to and to an u8 and has

00:08:28,319 --> 00:08:32,159
a new size that represents this length

00:08:30,240 --> 00:08:35,039
you can think of this type like a

00:08:32,159 --> 00:08:36,880
and a slice or if you want like a vector

00:08:35,039 --> 00:08:38,880
but here we only have like two

00:08:36,880 --> 00:08:40,479
simple functions we can only read stuff

00:08:38,880 --> 00:08:42,800
from it we cannot

00:08:40,479 --> 00:08:44,880
grow it or make it smaller we can just

00:08:42,800 --> 00:08:46,800
read stuff from it

00:08:44,880 --> 00:08:48,240
and usually what happens in the rust

00:08:46,800 --> 00:08:51,360
ecosystem is that you have like

00:08:48,240 --> 00:08:53,360
these two these two functions you have

00:08:51,360 --> 00:08:55,040
like the unsafe unchecked version of a

00:08:53,360 --> 00:08:57,680
function and then you have the safe

00:08:55,040 --> 00:09:00,800
version of it

00:08:57,680 --> 00:09:02,720
here we have the unsafe function it's

00:09:00,800 --> 00:09:04,560
called get unchecked it receives an

00:09:02,720 --> 00:09:06,839
index and what this function is doing is

00:09:04,560 --> 00:09:10,080
that it takes this pointer

00:09:06,839 --> 00:09:14,080
ptr cast it into a new size

00:09:10,080 --> 00:09:17,120
then it adds the index to it and cast

00:09:14,080 --> 00:09:18,880
that integer back to a pointer

00:09:17,120 --> 00:09:20,640
so we are offsetting the pointer by

00:09:18,880 --> 00:09:24,160
adding index to it

00:09:20,640 --> 00:09:26,320
and then we reference it actually

00:09:24,160 --> 00:09:28,320
all of this code all these all these

00:09:26,320 --> 00:09:30,399
three lines are not

00:09:28,320 --> 00:09:32,640
required to be done inside an unsaved

00:09:30,399 --> 00:09:35,920
function the only thing that isn't safe

00:09:32,640 --> 00:09:38,000
is reading from the pointer calling the

00:09:35,920 --> 00:09:40,160
reference star operator over it

00:09:38,000 --> 00:09:41,680
so you can use your pointer however you

00:09:40,160 --> 00:09:43,440
want but if you are going to

00:09:41,680 --> 00:09:45,120
the reference them you have to use them

00:09:43,440 --> 00:09:47,040
safe

00:09:45,120 --> 00:09:49,279
and then we have like the safe

00:09:47,040 --> 00:09:50,320
counterpart of this function so we

00:09:49,279 --> 00:09:52,640
guarantee that

00:09:50,320 --> 00:09:54,240
if the index you are reading is out of

00:09:52,640 --> 00:09:57,279
bounds from the length of the

00:09:54,240 --> 00:09:59,120
of this array then we return none

00:09:57,279 --> 00:10:01,279
and if we are sure that we are in

00:09:59,120 --> 00:10:03,279
inbounds then we just return sum

00:10:01,279 --> 00:10:05,839
sum and do an unsafe call to this get

00:10:03,279 --> 00:10:05,839
unchecked function

00:10:06,320 --> 00:10:11,839
and when you run this for example

00:10:09,839 --> 00:10:13,360
let's say this is a creating in the res

00:10:11,839 --> 00:10:15,200
ecosystem

00:10:13,360 --> 00:10:17,040
using create cio and someone else

00:10:15,200 --> 00:10:18,720
decides to use it

00:10:17,040 --> 00:10:20,480
they might just do something like this

00:10:18,720 --> 00:10:23,760
they just import

00:10:20,480 --> 00:10:25,440
our library use this byte array type

00:10:23,760 --> 00:10:26,560
call a function that i didn't show

00:10:25,440 --> 00:10:28,000
because it's not programmed for the

00:10:26,560 --> 00:10:29,839
purposes of the stock that is called

00:10:28,000 --> 00:10:30,720
zeros that just create an array full of

00:10:29,839 --> 00:10:32,480
zeros

00:10:30,720 --> 00:10:34,160
and they might need to use unsafe

00:10:32,480 --> 00:10:36,079
because they need to go super fast with

00:10:34,160 --> 00:10:39,120
this thing so they are just going to use

00:10:36,079 --> 00:10:42,160
getting checked uh and zero

00:10:39,120 --> 00:10:42,160
and if we run this

00:10:42,320 --> 00:10:47,839
it returns zero so it works as is as

00:10:45,200 --> 00:10:47,839
intended

00:10:48,160 --> 00:10:51,680
uh some of you might be asking what

00:10:49,920 --> 00:10:54,079
happens if you do this

00:10:51,680 --> 00:10:55,200
there these you call this function with

00:10:54,079 --> 00:10:58,399
a larger index

00:10:55,200 --> 00:11:01,680
we'll get to that later um

00:10:58,399 --> 00:11:03,120
so yep that's the demo and the big

00:11:01,680 --> 00:11:06,320
question now is

00:11:03,120 --> 00:11:09,519
well actually what can go wrong when you

00:11:06,320 --> 00:11:09,839
when you use unsafe and you might have

00:11:09,519 --> 00:11:11,600
heard

00:11:09,839 --> 00:11:13,120
answers like oh if you doesn't save

00:11:11,600 --> 00:11:14,240
wrong then you're causing undefined

00:11:13,120 --> 00:11:16,160
behavior

00:11:14,240 --> 00:11:17,760
or undefined behavior is so bad anything

00:11:16,160 --> 00:11:18,959
can happen when you're dealing with

00:11:17,760 --> 00:11:20,959
undefined behavior

00:11:18,959 --> 00:11:23,360
so let's discuss a bit undefined

00:11:20,959 --> 00:11:23,360
behavior

00:11:26,160 --> 00:11:30,079
let's say the ros compiler was written

00:11:28,240 --> 00:11:32,320
under same 10 assumptions about how

00:11:30,079 --> 00:11:34,880
programs work

00:11:32,320 --> 00:11:35,760
about the programs we write we write

00:11:34,880 --> 00:11:37,760
programs that

00:11:35,760 --> 00:11:40,000
need to meet certain conditions so the

00:11:37,760 --> 00:11:42,560
compiler can actually compile them

00:11:40,000 --> 00:11:43,279
into what we want if we break any of

00:11:42,560 --> 00:11:45,360
these rules

00:11:43,279 --> 00:11:46,320
uh we say we're calling undefined

00:11:45,360 --> 00:11:48,959
behavior as

00:11:46,320 --> 00:11:50,240
stefan said this is a way of saying like

00:11:48,959 --> 00:11:52,240
if there is something that is not

00:11:50,240 --> 00:11:54,240
actually specified by the compiler

00:11:52,240 --> 00:11:56,160
in a clear way if the compiler is

00:11:54,240 --> 00:11:57,200
trusting that to happen and if you break

00:11:56,160 --> 00:11:59,040
that

00:11:57,200 --> 00:12:00,399
that rule then you're causing undefined

00:11:59,040 --> 00:12:01,920
behavior

00:12:00,399 --> 00:12:03,839
there is something super important is

00:12:01,920 --> 00:12:04,639
that undefined behavior is different in

00:12:03,839 --> 00:12:07,120
each language

00:12:04,639 --> 00:12:08,240
so c has a lot of rules for undefined

00:12:07,120 --> 00:12:10,880
behavior

00:12:08,240 --> 00:12:11,680
and those rules are not the same for us

00:12:10,880 --> 00:12:15,760
um

00:12:11,680 --> 00:12:18,800
for example what stefan told you about

00:12:15,760 --> 00:12:20,959
adding uh an integer and going uh

00:12:18,800 --> 00:12:22,240
let's say going out of bounds in the

00:12:20,959 --> 00:12:23,200
interior like adding too much to an

00:12:22,240 --> 00:12:26,639
interior because

00:12:23,200 --> 00:12:28,320
it can fit a number stupid then that's

00:12:26,639 --> 00:12:30,480
not undefined behavior in rust but

00:12:28,320 --> 00:12:33,519
that's undefined behavior in c

00:12:30,480 --> 00:12:35,680
um because both compilers were built

00:12:33,519 --> 00:12:37,200
with different guarantees in mind

00:12:35,680 --> 00:12:39,279
and actually the list of things that

00:12:37,200 --> 00:12:41,279
rust considers

00:12:39,279 --> 00:12:42,800
important rules when we're dealing with

00:12:41,279 --> 00:12:44,560
undefined behavior is

00:12:42,800 --> 00:12:46,399
a little bit tricky so i'm just going to

00:12:44,560 --> 00:12:47,839
mention some of them

00:12:46,399 --> 00:12:49,839
your program might have undefined

00:12:47,839 --> 00:12:53,200
behavior if you are dereferencing a

00:12:49,839 --> 00:12:56,320
pointer that is dangling or unaligned

00:12:53,200 --> 00:12:58,000
um also if you try to produce or if you

00:12:56,320 --> 00:12:59,440
manage to produce a value that is

00:12:58,000 --> 00:13:02,480
incorrect for their type

00:12:59,440 --> 00:13:04,639
so for example booleans

00:13:02,480 --> 00:13:07,360
when you look at the actual memory let's

00:13:04,639 --> 00:13:10,160
say booleans are represented by bytes

00:13:07,360 --> 00:13:12,320
they take one byte exactly so you have

00:13:10,160 --> 00:13:15,120
r1 or a zero

00:13:12,320 --> 00:13:17,279
but abide has like eight bits so you

00:13:15,120 --> 00:13:19,839
have a lot of values that you could use

00:13:17,279 --> 00:13:22,000
so one is true zero is false but for

00:13:19,839 --> 00:13:24,240
example if you take a three

00:13:22,000 --> 00:13:25,920
and you try to put that into a boolean

00:13:24,240 --> 00:13:27,839
doing that is undefined behavior because

00:13:25,920 --> 00:13:29,920
three is not specified

00:13:27,839 --> 00:13:31,680
as a boolean the compiler doesn't know

00:13:29,920 --> 00:13:34,959
what should it do what you do if

00:13:31,680 --> 00:13:36,639
this is if it sees a tree instead of a

00:13:34,959 --> 00:13:40,000
one or a zero

00:13:36,639 --> 00:13:40,639
um causing data races is also undefined

00:13:40,000 --> 00:13:42,320
behavior

00:13:40,639 --> 00:13:43,920
and as i said before there are a lot of

00:13:42,320 --> 00:13:47,120
subtle rules that

00:13:43,920 --> 00:13:51,760
must be taken into account here

00:13:47,120 --> 00:13:54,320
so what happens if we break these rules

00:13:51,760 --> 00:13:55,279
basically work basically rust cannot

00:13:54,320 --> 00:13:59,360
work correctly

00:13:55,279 --> 00:14:01,839
uh we lose this guarantee that has that

00:13:59,360 --> 00:14:03,519
of producing programs that do what we

00:14:01,839 --> 00:14:06,320
want them to do

00:14:03,519 --> 00:14:07,680
uh they ca rus can no longer compile a

00:14:06,320 --> 00:14:10,320
program correctly so

00:14:07,680 --> 00:14:11,120
what this means is that in the best case

00:14:10,320 --> 00:14:14,320
your program

00:14:11,120 --> 00:14:16,560
might not run maybe it process

00:14:14,320 --> 00:14:18,480
a segmentation fold or some sort of

00:14:16,560 --> 00:14:19,360
memory out of bounds error or something

00:14:18,480 --> 00:14:22,320
like that

00:14:19,360 --> 00:14:22,800
but in the worst case it might run but

00:14:22,320 --> 00:14:24,880
not

00:14:22,800 --> 00:14:26,480
as you intended to so that program might

00:14:24,880 --> 00:14:28,839
do anything

00:14:26,480 --> 00:14:30,079
uh for that reason it's pretty common to

00:14:28,839 --> 00:14:32,079
see

00:14:30,079 --> 00:14:34,480
this kind of psychedelic image with

00:14:32,079 --> 00:14:36,639
unicorns and ray bones and a lot of

00:14:34,480 --> 00:14:38,160
colorful stuff when people discuss

00:14:36,639 --> 00:14:39,360
undefined behavior because

00:14:38,160 --> 00:14:41,920
when we are dealing with undefined

00:14:39,360 --> 00:14:44,240
behavior we lose

00:14:41,920 --> 00:14:44,959
track of what our programmer do is doing

00:14:44,240 --> 00:14:48,720
in the most

00:14:44,959 --> 00:14:52,160
basic level we don't even know anymore

00:14:48,720 --> 00:14:54,399
um so there are good news for us for us

00:14:52,160 --> 00:14:57,600
developers people in the rush community

00:14:54,399 --> 00:14:58,079
if we are using safe rust if we promise

00:14:57,600 --> 00:15:01,920
to never

00:14:58,079 --> 00:15:03,519
never never using safe

00:15:01,920 --> 00:15:05,040
we don't have to worry worry about

00:15:03,519 --> 00:15:08,560
undefined behavior because undefined

00:15:05,040 --> 00:15:10,560
behavior shouldn't happen in safe rust

00:15:08,560 --> 00:15:12,240
also if you are using unsafe and you are

00:15:10,560 --> 00:15:14,800
super sure you're not causing undefined

00:15:12,240 --> 00:15:16,959
behavior you might actually get any

00:15:14,800 --> 00:15:18,160
uh performance benefits or you can

00:15:16,959 --> 00:15:20,079
interact with

00:15:18,160 --> 00:15:21,519
c libraries and so on correctly if you

00:15:20,079 --> 00:15:25,040
don't cause undefined behavior

00:15:21,519 --> 00:15:27,199
that's also good there are also

00:15:25,040 --> 00:15:29,279
not so good news and is that unsafe is a

00:15:27,199 --> 00:15:31,440
super important part of our ecosystem

00:15:29,279 --> 00:15:32,720
uh even if we are not causing undefined

00:15:31,440 --> 00:15:35,519
behavior ourselves

00:15:32,720 --> 00:15:36,800
uh someone else in one of our

00:15:35,519 --> 00:15:39,360
dependencies might be

00:15:36,800 --> 00:15:41,360
might be doing it uh here i have like

00:15:39,360 --> 00:15:42,800
some super interesting statistics about

00:15:41,360 --> 00:15:44,639
this uh twenty percent

00:15:42,800 --> 00:15:46,240
twenty percent of all the crates that

00:15:44,639 --> 00:15:50,079
are in crates i uses

00:15:46,240 --> 00:15:53,279
uses using save directly um

00:15:50,079 --> 00:15:56,800
and seventy four twenty seventy four

00:15:53,279 --> 00:16:00,079
sorry and of those 20 crates

00:15:56,800 --> 00:16:03,199
all those crates 74 of them do

00:16:00,079 --> 00:16:05,120
unsafe calls to functions that

00:16:03,199 --> 00:16:07,040
aren't in the same crate so are crates

00:16:05,120 --> 00:16:09,519
that are using unsafe to call function

00:16:07,040 --> 00:16:12,560
that that either in the standard library

00:16:09,519 --> 00:16:14,800
or in other crits if you want to get

00:16:12,560 --> 00:16:15,920
like more information about this metrics

00:16:14,800 --> 00:16:19,040
you can google

00:16:15,920 --> 00:16:20,320
or use your favorite web search engine

00:16:19,040 --> 00:16:22,800
to look for this paper

00:16:20,320 --> 00:16:24,240
about how the programmers using save

00:16:22,800 --> 00:16:27,519
rust

00:16:24,240 --> 00:16:29,279
um but my point here is that unsafe is

00:16:27,519 --> 00:16:31,279
everywhere not because people are not

00:16:29,279 --> 00:16:34,800
good doing our their job but because we

00:16:31,279 --> 00:16:34,800
need it we actually needed this

00:16:34,839 --> 00:16:38,240
everywhere

00:16:36,079 --> 00:16:40,000
so i also have a good news actually the

00:16:38,240 --> 00:16:42,560
best news and is that

00:16:40,000 --> 00:16:44,240
there is a tool that you can use to

00:16:42,560 --> 00:16:46,639
detect undefined behavior

00:16:44,240 --> 00:16:47,759
uh in your programs and the spoiler is

00:16:46,639 --> 00:16:50,079
in the title of this stock

00:16:47,759 --> 00:16:52,480
is called bearing so let's talk about

00:16:50,079 --> 00:16:54,079
miri

00:16:52,480 --> 00:16:56,079
if you want to take a look at the

00:16:54,079 --> 00:16:58,480
repository now or maybe later this is

00:16:56,079 --> 00:16:59,519
the url you can find all the code in

00:16:58,480 --> 00:17:03,199
github.com

00:16:59,519 --> 00:17:03,199
slash roslink miri

00:17:03,440 --> 00:17:10,400
um so what's miri actually

00:17:07,280 --> 00:17:11,280
miri is a virtual machine for those

00:17:10,400 --> 00:17:14,079
programs

00:17:11,280 --> 00:17:15,199
this means that miri doesn't compile

00:17:14,079 --> 00:17:18,079
your program

00:17:15,199 --> 00:17:20,880
it interprets it in the same sense that

00:17:18,079 --> 00:17:23,280
the jvm interprets java code

00:17:20,880 --> 00:17:25,839
or bytecode or that the python

00:17:23,280 --> 00:17:28,640
interpreter runs python or that

00:17:25,839 --> 00:17:29,280
drove interpreter runs ruby and so on

00:17:28,640 --> 00:17:32,559
mirror is

00:17:29,280 --> 00:17:34,480
like that but for rust and it has a

00:17:32,559 --> 00:17:36,400
super cool feature that none of the

00:17:34,480 --> 00:17:38,080
other interpreters has and is that

00:17:36,400 --> 00:17:39,919
it can detect almost all cases of

00:17:38,080 --> 00:17:41,360
underhind behavior while running our

00:17:39,919 --> 00:17:43,760
code

00:17:41,360 --> 00:17:45,520
and okay there is also something

00:17:43,760 --> 00:17:47,360
interesting and is that some of the code

00:17:45,520 --> 00:17:50,080
that is used in miri

00:17:47,360 --> 00:17:52,320
is using the engine that does compile

00:17:50,080 --> 00:17:55,360
time function evaluation so

00:17:52,320 --> 00:17:57,280
if you have any const item in your

00:17:55,360 --> 00:17:59,120
program you have a constant you have a

00:17:57,280 --> 00:18:01,280
cons function

00:17:59,120 --> 00:18:02,799
uh part of the mirror code is used to

00:18:01,280 --> 00:18:06,400
run

00:18:02,799 --> 00:18:07,440
um that function or that or to evaluate

00:18:06,400 --> 00:18:09,440
that constant so

00:18:07,440 --> 00:18:10,799
it's pretty common to hear stuff like oh

00:18:09,440 --> 00:18:13,039
yeah mirror is the constant

00:18:10,799 --> 00:18:14,160
evaluation for plus but here we will be

00:18:13,039 --> 00:18:17,600
talking just

00:18:14,160 --> 00:18:20,400
uh as mary as just the standalone tool

00:18:17,600 --> 00:18:22,799
outside the compiler that can interpret

00:18:20,400 --> 00:18:26,640
your programs

00:18:22,799 --> 00:18:28,559
um so how to use miri you need

00:18:26,640 --> 00:18:30,880
an elevator version of the compiler to

00:18:28,559 --> 00:18:32,720
do this so if you have restock you have

00:18:30,880 --> 00:18:34,480
to install the nightly tool chain you

00:18:32,720 --> 00:18:37,120
can do this by running rooftop

00:18:34,480 --> 00:18:39,039
tool chain installed nightly and then

00:18:37,120 --> 00:18:41,360
you can install miri just as a

00:18:39,039 --> 00:18:42,640
component so it's the same as installing

00:18:41,360 --> 00:18:45,280
clippy or

00:18:42,640 --> 00:18:46,360
fmt or whatever you just have to do

00:18:45,280 --> 00:18:49,440
browstop

00:18:46,360 --> 00:18:50,960
component.miri and then after mirroring

00:18:49,440 --> 00:18:52,160
installs it has to download some

00:18:50,960 --> 00:18:53,120
additional stuff it takes a while

00:18:52,160 --> 00:18:56,320
compiling

00:18:53,120 --> 00:18:56,799
but you can run binaries you can run

00:18:56,320 --> 00:18:58,880
your

00:18:56,799 --> 00:19:00,559
your whole program if you want with miri

00:18:58,880 --> 00:19:02,320
or you can run just your test suite if

00:19:00,559 --> 00:19:05,440
you have tests

00:19:02,320 --> 00:19:06,960
uh okay so let's do a tiny demo

00:19:05,440 --> 00:19:10,400
with the same code i was showing you

00:19:06,960 --> 00:19:13,679
before so again we have this

00:19:10,400 --> 00:19:16,160
super tiny use user

00:19:13,679 --> 00:19:17,840
super super tiny program that is using

00:19:16,160 --> 00:19:20,880
an external

00:19:17,840 --> 00:19:23,039
crate let's say that is using the safe

00:19:20,880 --> 00:19:24,400
and maybe the person that is writing

00:19:23,039 --> 00:19:25,520
this program doesn't know about the

00:19:24,400 --> 00:19:27,600
guarantees

00:19:25,520 --> 00:19:28,960
that that trait has to be sure that

00:19:27,600 --> 00:19:32,080
these functions doesn't

00:19:28,960 --> 00:19:33,679
don't cause undefined behavior so uh

00:19:32,080 --> 00:19:35,840
you might be tempted to do something

00:19:33,679 --> 00:19:38,000
like i don't know why can i read

00:19:35,840 --> 00:19:39,760
the eleventh position of an array with

00:19:38,000 --> 00:19:42,000
10 elements

00:19:39,760 --> 00:19:43,360
like who is stopping me the compiler is

00:19:42,000 --> 00:19:47,440
not complaining so if i

00:19:43,360 --> 00:19:49,200
if i do cargo run

00:19:47,440 --> 00:19:52,240
it works it actually returns zero that

00:19:49,200 --> 00:19:54,000
is a perfectly good value

00:19:52,240 --> 00:19:55,760
because it returns the same as before so

00:19:54,000 --> 00:19:58,559
it's fine but if you run

00:19:55,760 --> 00:19:58,559
this with miri

00:19:58,880 --> 00:20:04,720
you will find this super cool error

00:20:02,400 --> 00:20:06,960
that says undefined behavior pointer to

00:20:04,720 --> 00:20:10,080
allocation was the references

00:20:06,960 --> 00:20:11,360
after this allocation got freed and it

00:20:10,080 --> 00:20:13,679
points to the

00:20:11,360 --> 00:20:14,640
part of the code in the original trade

00:20:13,679 --> 00:20:16,240
that does

00:20:14,640 --> 00:20:20,480
that causes this undefined behavior and

00:20:16,240 --> 00:20:22,159
is a pointer of the reference

00:20:20,480 --> 00:20:24,320
and you can see more information and so

00:20:22,159 --> 00:20:26,480
on but the important part here is that

00:20:24,320 --> 00:20:29,440
what's happening in the model of

00:20:26,480 --> 00:20:32,559
execution of mirror is that

00:20:29,440 --> 00:20:34,240
this function is creating a pointer

00:20:32,559 --> 00:20:36,320
that is dangling you create a you

00:20:34,240 --> 00:20:38,320
created a pointer that is outside

00:20:36,320 --> 00:20:40,080
the actual rainbow range of the vector

00:20:38,320 --> 00:20:41,520
so when the vector gets deleted because

00:20:40,080 --> 00:20:44,640
rust deleted it

00:20:41,520 --> 00:20:47,280
after everyone has used it has used it

00:20:44,640 --> 00:20:50,159
uh you still have this dangling pointer

00:20:47,280 --> 00:20:50,159
pointing to nothing

00:20:50,400 --> 00:20:53,440
but for example if we go back to the

00:20:52,320 --> 00:20:54,960
perfect case where

00:20:53,440 --> 00:20:56,960
we didn't have like any undefined

00:20:54,960 --> 00:21:00,640
behavior we can just do

00:20:56,960 --> 00:21:02,799
cargo miri run and mirror one complain

00:21:00,640 --> 00:21:05,120
and will return the same as your regular

00:21:02,799 --> 00:21:09,120
program

00:21:05,120 --> 00:21:10,880
um okay so that's like how

00:21:09,120 --> 00:21:12,880
we can use miri we can use it to detect

00:21:10,880 --> 00:21:14,840
undefined behavior if our program is

00:21:12,880 --> 00:21:16,080
causing undefined behavior in that

00:21:14,840 --> 00:21:18,880
descenary

00:21:16,080 --> 00:21:20,000
but now i want to show you i want to

00:21:18,880 --> 00:21:23,039
discuss a little bit like

00:21:20,000 --> 00:21:24,720
how midi works actually and

00:21:23,039 --> 00:21:26,240
to talk about how miri works we have to

00:21:24,720 --> 00:21:29,440
dig a little bit on how the

00:21:26,240 --> 00:21:32,799
rust compiler works

00:21:29,440 --> 00:21:33,919
so this is like a super high level

00:21:32,799 --> 00:21:36,320
overview of

00:21:33,919 --> 00:21:38,240
the rose compilation pipeline these are

00:21:36,320 --> 00:21:39,360
like more or less all the stages that a

00:21:38,240 --> 00:21:42,640
program follows

00:21:39,360 --> 00:21:42,640
when it's getting compiled

00:21:43,600 --> 00:21:49,919
so we always start like add source code

00:21:46,799 --> 00:21:52,559
with our dot rs file and end up in

00:21:49,919 --> 00:21:53,200
a in machine code or you know in a

00:21:52,559 --> 00:21:56,159
binary

00:21:53,200 --> 00:21:58,320
a wasn't binary or a dynamic library

00:21:56,159 --> 00:22:00,320
something like that

00:21:58,320 --> 00:22:01,760
and what happens in the middle are like

00:22:00,320 --> 00:22:05,120
basically four stages

00:22:01,760 --> 00:22:07,280
the first one is parsing so ros reads

00:22:05,120 --> 00:22:08,400
the text of your source code let's say

00:22:07,280 --> 00:22:10,640
and parses it

00:22:08,400 --> 00:22:13,039
to produce an abstract syntax tree

00:22:10,640 --> 00:22:15,679
radius d

00:22:13,039 --> 00:22:17,600
then this isd is transformed and

00:22:15,679 --> 00:22:19,520
processed to produce a high level

00:22:17,600 --> 00:22:23,600
intermediate representation or

00:22:19,520 --> 00:22:25,280
h i r in this stage is where most of the

00:22:23,600 --> 00:22:27,360
type inference process happens

00:22:25,280 --> 00:22:29,039
so a lot of types are inferred here in

00:22:27,360 --> 00:22:32,480
this stage

00:22:29,039 --> 00:22:34,559
um then this hir is lowered to

00:22:32,480 --> 00:22:36,400
another representation intermediate

00:22:34,559 --> 00:22:38,400
representation but this is a middle

00:22:36,400 --> 00:22:39,679
a mid-level intermediate representation

00:22:38,400 --> 00:22:41,120
mir

00:22:39,679 --> 00:22:42,720
and here is where the borrow checking

00:22:41,120 --> 00:22:45,919
happens most of it

00:22:42,720 --> 00:22:47,360
uh in the mir also is

00:22:45,919 --> 00:22:50,080
when the compiler does some

00:22:47,360 --> 00:22:53,919
optimizations about your code

00:22:50,080 --> 00:22:54,799
and after that we start interacting with

00:22:53,919 --> 00:22:56,400
llvm

00:22:54,799 --> 00:22:58,159
that is a backend for compilers that

00:22:56,400 --> 00:23:01,919
resist

00:22:58,159 --> 00:23:03,760
and these this llvm project

00:23:01,919 --> 00:23:05,120
also has their own intermediate

00:23:03,760 --> 00:23:08,640
representation

00:23:05,120 --> 00:23:09,520
so we lower miri mir to mir to the other

00:23:08,640 --> 00:23:12,159
vm

00:23:09,520 --> 00:23:12,559
intermediate representation and lldm

00:23:12,159 --> 00:23:15,120
dots

00:23:12,559 --> 00:23:16,960
a lot of optimizations over your code

00:23:15,120 --> 00:23:19,120
and finally llvm

00:23:16,960 --> 00:23:22,240
does the code generation to produce your

00:23:19,120 --> 00:23:26,240
binary file or your library or so on

00:23:22,240 --> 00:23:28,720
um melee works almost

00:23:26,240 --> 00:23:31,520
in this way the only difference is that

00:23:28,720 --> 00:23:34,000
the code generation stages don't run so

00:23:31,520 --> 00:23:36,159
we don't get to talk with a little well

00:23:34,000 --> 00:23:39,280
with llvm

00:23:36,159 --> 00:23:41,440
uh what happens is that miri lets the

00:23:39,280 --> 00:23:43,600
compiler run until you have the mir of

00:23:41,440 --> 00:23:46,799
your program and miri interprets that

00:23:43,600 --> 00:23:48,000
mir as if it were by code so if java has

00:23:46,799 --> 00:23:51,440
by code

00:23:48,000 --> 00:23:54,240
in the jbm brush has mir

00:23:51,440 --> 00:23:55,760
for the when running miri so that's why

00:23:54,240 --> 00:23:58,960
miri is called mirror because he's some

00:23:55,760 --> 00:24:02,640
mir interpreter mere

00:23:58,960 --> 00:24:04,400
um i'm showing you this because

00:24:02,640 --> 00:24:06,480
here is something super important is

00:24:04,400 --> 00:24:09,440
that miri cannot interpret

00:24:06,480 --> 00:24:10,880
programs that aren't ros programs so you

00:24:09,440 --> 00:24:13,600
have a c library

00:24:10,880 --> 00:24:14,799
that you run with your ros program where

00:24:13,600 --> 00:24:17,279
you cannot interpret that

00:24:14,799 --> 00:24:19,120
in any way that program doesn't have

00:24:17,279 --> 00:24:21,440
like the same syntax the compiler

00:24:19,120 --> 00:24:24,720
doesn't even understand that program

00:24:21,440 --> 00:24:26,559
so you cannot interpret that using miri

00:24:24,720 --> 00:24:28,000
and there are many limitations actually

00:24:26,559 --> 00:24:29,600
there are some limitations that miri has

00:24:28,000 --> 00:24:30,159
smeared is not perfect it's not a silver

00:24:29,600 --> 00:24:33,840
bullet for

00:24:30,159 --> 00:24:36,480
your undefined behavior problems another

00:24:33,840 --> 00:24:37,360
limitation is that mirror is slow so if

00:24:36,480 --> 00:24:40,400
your

00:24:37,360 --> 00:24:41,440
test or your program is performance

00:24:40,400 --> 00:24:43,200
sensitive

00:24:41,440 --> 00:24:46,799
miri can take a while to run your

00:24:43,200 --> 00:24:48,559
program even if you can do it

00:24:46,799 --> 00:24:50,000
this happens because miri has to do a

00:24:48,559 --> 00:24:51,840
lot of runtime checks

00:24:50,000 --> 00:24:54,159
about your pointers and about how

00:24:51,840 --> 00:24:55,760
memories manage to be able to

00:24:54,159 --> 00:24:58,159
tell you when undefined behavior is

00:24:55,760 --> 00:24:58,159
happening

00:24:58,840 --> 00:25:03,600
um and

00:25:02,000 --> 00:25:05,600
the other important point is that mirror

00:25:03,600 --> 00:25:07,200
can only attack undefined behavior if

00:25:05,600 --> 00:25:09,760
it's happening

00:25:07,200 --> 00:25:11,200
so as i show you in the example we have

00:25:09,760 --> 00:25:12,640
a program that might have from behind

00:25:11,200 --> 00:25:15,039
behavior is someone calls

00:25:12,640 --> 00:25:16,640
a function with a certain argument but

00:25:15,039 --> 00:25:20,960
if that doesn't actually happens

00:25:16,640 --> 00:25:23,279
mary won't warn the user about this case

00:25:20,960 --> 00:25:24,799
uh also mary cannot detect data races

00:25:23,279 --> 00:25:26,480
yet there is no way to reasonable

00:25:24,799 --> 00:25:29,120
databases

00:25:26,480 --> 00:25:31,679
and again where you can only interpret

00:25:29,120 --> 00:25:35,120
ros programs

00:25:31,679 --> 00:25:35,840
this one is super important you might be

00:25:35,120 --> 00:25:38,640
wondering

00:25:35,840 --> 00:25:39,039
why does this matter and it's because

00:25:38,640 --> 00:25:41,440
well

00:25:39,039 --> 00:25:43,840
you know programs don't run in isolation

00:25:41,440 --> 00:25:47,200
we tend to use

00:25:43,840 --> 00:25:48,799
files we can access files get resources

00:25:47,200 --> 00:25:51,679
over the network

00:25:48,799 --> 00:25:53,279
interact with databases create all

00:25:51,679 --> 00:25:54,960
stress so we need to access the

00:25:53,279 --> 00:25:58,240
concurrency primitives of

00:25:54,960 --> 00:26:00,720
our operating system or whatever and

00:25:58,240 --> 00:26:02,320
the main the mechanism that rust uses to

00:26:00,720 --> 00:26:04,159
interact with all those are foreign

00:26:02,320 --> 00:26:06,880
functions

00:26:04,159 --> 00:26:10,400
and that's where i this last part is

00:26:06,880 --> 00:26:13,600
about frame functions

00:26:10,400 --> 00:26:15,200
some of us might be let's say maybe

00:26:13,600 --> 00:26:17,360
think that

00:26:15,200 --> 00:26:18,640
we don't need frame functions at all

00:26:17,360 --> 00:26:21,200
maybe you

00:26:18,640 --> 00:26:23,039
we have never used external fan in our

00:26:21,200 --> 00:26:24,400
project so we think no that's fine i

00:26:23,039 --> 00:26:26,480
i usually don't interact with frame

00:26:24,400 --> 00:26:29,200
functions but

00:26:26,480 --> 00:26:30,320
i'm not sure that anyone or almost

00:26:29,200 --> 00:26:32,000
everyone has

00:26:30,320 --> 00:26:34,080
interacted with the standard library to

00:26:32,000 --> 00:26:34,880
do any operation to read files or

00:26:34,080 --> 00:26:37,520
whatever

00:26:34,880 --> 00:26:38,960
and that means that somehow you're using

00:26:37,520 --> 00:26:40,799
following functions

00:26:38,960 --> 00:26:42,559
for example this is the stack trace when

00:26:40,799 --> 00:26:44,240
you call file open

00:26:42,559 --> 00:26:45,919
the standard library function for

00:26:44,240 --> 00:26:49,279
opening files

00:26:45,919 --> 00:26:52,240
uh there are like six functions here

00:26:49,279 --> 00:26:52,799
the first three the first two are like

00:26:52,240 --> 00:26:54,240
rust

00:26:52,799 --> 00:26:56,159
functions they are in the standard

00:26:54,240 --> 00:26:58,799
library there are platform independents

00:26:56,159 --> 00:27:02,559
so these work in any platform

00:26:58,799 --> 00:27:04,640
in windows linux mac os whatever

00:27:02,559 --> 00:27:06,400
then we have like four functions that

00:27:04,640 --> 00:27:08,640
are specific four units

00:27:06,400 --> 00:27:10,400
unix like platform so those only run on

00:27:08,640 --> 00:27:13,600
linux and mac os and

00:27:10,400 --> 00:27:16,400
vsd and so on and then we have this open

00:27:13,600 --> 00:27:18,320
64 function at the end

00:27:16,400 --> 00:27:20,080
the funny part about this open 64

00:27:18,320 --> 00:27:20,720
function is that it's not even a ros

00:27:20,080 --> 00:27:23,120
function

00:27:20,720 --> 00:27:24,480
it's a c function it's the linux system

00:27:23,120 --> 00:27:27,360
call

00:27:24,480 --> 00:27:27,360
to open a file

00:27:27,520 --> 00:27:31,120
so this is a foreign function written in

00:27:29,679 --> 00:27:34,320
c

00:27:31,120 --> 00:27:35,679
and it's an unsafe function and miri

00:27:34,320 --> 00:27:38,159
cannot interpret it

00:27:35,679 --> 00:27:41,200
so what happens if in any of this

00:27:38,159 --> 00:27:43,039
process we have undefined behavior

00:27:41,200 --> 00:27:46,559
can we run that because it cannot

00:27:43,039 --> 00:27:46,559
interpret the open 64 function

00:27:47,039 --> 00:27:51,440
the good news is that yes miri can

00:27:49,120 --> 00:27:54,480
actually run your program

00:27:51,440 --> 00:27:57,760
in a particularly interesting way

00:27:54,480 --> 00:28:00,159
and yes mary cannot

00:27:57,760 --> 00:28:01,679
interpret your following function but it

00:28:00,159 --> 00:28:03,440
can intercept this call

00:28:01,679 --> 00:28:05,679
so when you're running your program if

00:28:03,440 --> 00:28:08,000
you call open 64 maybe we'll say okay

00:28:05,679 --> 00:28:11,120
someone is calling up.64 that's

00:28:08,000 --> 00:28:14,640
a foreign function that i don't know

00:28:11,120 --> 00:28:16,320
that's not a ras function uh and then

00:28:14,640 --> 00:28:18,559
the merry contributors can write

00:28:16,320 --> 00:28:19,760
whatever code they want to emulate that

00:28:18,559 --> 00:28:22,559
function

00:28:19,760 --> 00:28:24,720
uh we call though that the code that

00:28:22,559 --> 00:28:29,039
emulates a function we call it a shim

00:28:24,720 --> 00:28:31,679
s-h-i-m and if machine needs to interact

00:28:29,039 --> 00:28:33,360
with the operating system

00:28:31,679 --> 00:28:34,880
or with any of the resources that the

00:28:33,360 --> 00:28:36,320
standard library provides we use the

00:28:34,880 --> 00:28:37,840
standard library for that

00:28:36,320 --> 00:28:39,919
so it's funny because the standard

00:28:37,840 --> 00:28:42,080
library uses

00:28:39,919 --> 00:28:43,600
foreign functions but miri uses the

00:28:42,080 --> 00:28:45,600
standard library

00:28:43,600 --> 00:28:46,799
to emulate some of those following

00:28:45,600 --> 00:28:50,080
functions

00:28:46,799 --> 00:28:53,120
let me show you so

00:28:50,080 --> 00:28:54,960
instead we are still in our example with

00:28:53,120 --> 00:28:59,840
the byte array crate

00:28:54,960 --> 00:28:59,840
but in this case we have an user that is

00:29:01,440 --> 00:29:04,960
reading the size and index that it wants

00:29:03,440 --> 00:29:08,000
to use

00:29:04,960 --> 00:29:10,720
from a config file and this config file

00:29:08,000 --> 00:29:11,200
is read using red to string bread to

00:29:10,720 --> 00:29:14,000
string

00:29:11,200 --> 00:29:15,760
read the string uses file open so

00:29:14,000 --> 00:29:19,760
eventually it will use

00:29:15,760 --> 00:29:21,120
open 64. um

00:29:19,760 --> 00:29:22,960
and we're doing the same we're just

00:29:21,120 --> 00:29:26,000
printing

00:29:22,960 --> 00:29:29,760
something after using save

00:29:26,000 --> 00:29:31,279
if we try to run this with miri

00:29:29,760 --> 00:29:34,000
we will get an error but it's not

00:29:31,279 --> 00:29:37,039
because we're causing undefined behavior

00:29:34,000 --> 00:29:38,720
uh we have this on support operation

00:29:37,039 --> 00:29:40,960
open it's not available when

00:29:38,720 --> 00:29:43,120
installation is enabled

00:29:40,960 --> 00:29:44,960
so this is the open 64 function i was

00:29:43,120 --> 00:29:45,919
talking about open is not available when

00:29:44,960 --> 00:29:48,720
installation is

00:29:45,919 --> 00:29:50,640
is enabled please pause the mirror

00:29:48,720 --> 00:29:50,960
disabled installation flag to disable

00:29:50,640 --> 00:29:55,840
this

00:29:50,960 --> 00:29:55,840
isolation so if we do that

00:29:57,120 --> 00:30:04,000
and set the miriflux

00:30:00,320 --> 00:30:04,880
environment variable to merely disable

00:30:04,000 --> 00:30:08,320
insulation

00:30:04,880 --> 00:30:10,399
we can actually run the program and in

00:30:08,320 --> 00:30:12,240
this particular case

00:30:10,399 --> 00:30:14,399
it seems that the config file is

00:30:12,240 --> 00:30:16,480
actually causing undefined behavior

00:30:14,399 --> 00:30:17,440
it says memory access failed pointer

00:30:16,480 --> 00:30:19,840
must be involved

00:30:17,440 --> 00:30:20,799
in bounce at 11 but it's outside of

00:30:19,840 --> 00:30:23,520
bounds

00:30:20,799 --> 00:30:25,200
for the allocation which has size 10. so

00:30:23,520 --> 00:30:26,720
this seems to be the same problem as

00:30:25,200 --> 00:30:29,840
before that someone is reading

00:30:26,720 --> 00:30:31,840
11 11th position of something with only

00:30:29,840 --> 00:30:34,480
10 elements and if we check our

00:30:31,840 --> 00:30:36,640
config file yeah it's a salary that is

00:30:34,480 --> 00:30:40,240
reading the 10th position

00:30:36,640 --> 00:30:43,520
or the 11th if you want to think in 0

00:30:40,240 --> 00:30:46,559
in in 0 base indexes

00:30:43,520 --> 00:30:48,159
and that's the whole problem so yeah we

00:30:46,559 --> 00:30:50,640
can use miri to detect undefined

00:30:48,159 --> 00:30:54,080
behavior either in programs that use

00:30:50,640 --> 00:30:58,240
foreign functions that's super cool

00:30:54,080 --> 00:31:00,960
and actually other than handling

00:30:58,240 --> 00:31:02,640
files where you can do a lot of stuff

00:31:00,960 --> 00:31:04,960
you can manipulate directories you can

00:31:02,640 --> 00:31:07,519
delete files create symbolic links

00:31:04,960 --> 00:31:09,120
uh you can spawn threads you can use

00:31:07,519 --> 00:31:11,039
logs anatomics if you're doing

00:31:09,120 --> 00:31:13,600
concurrency somewhere you can

00:31:11,039 --> 00:31:15,200
emulate some concurrency stuff you can

00:31:13,600 --> 00:31:17,760
use it to get the current time so you

00:31:15,200 --> 00:31:19,760
can actually like run clocks inside your

00:31:17,760 --> 00:31:21,600
mute program your last program running

00:31:19,760 --> 00:31:25,039
miri you can handle

00:31:21,600 --> 00:31:28,559
environment variables and

00:31:25,039 --> 00:31:30,080
each of those operations is possible

00:31:28,559 --> 00:31:32,960
because someone

00:31:30,080 --> 00:31:36,320
decided to wrote decided to rotation for

00:31:32,960 --> 00:31:39,200
that specific foreign function

00:31:36,320 --> 00:31:40,559
and this has a super cool side effect

00:31:39,200 --> 00:31:43,200
what not so side effect

00:31:40,559 --> 00:31:44,840
some people were actually targeting to

00:31:43,200 --> 00:31:47,519
get this working

00:31:44,840 --> 00:31:50,399
um and is that

00:31:47,519 --> 00:31:51,279
the standard ros library works in many

00:31:50,399 --> 00:31:53,519
platforms

00:31:51,279 --> 00:31:54,559
you can run it you can use file opening

00:31:53,519 --> 00:31:58,840
basically

00:31:54,559 --> 00:32:01,840
any tier one tier zero um

00:31:58,840 --> 00:32:03,679
platform so this means that you can

00:32:01,840 --> 00:32:06,080
emulate foreign functions

00:32:03,679 --> 00:32:06,880
even if you are not in the platform the

00:32:06,080 --> 00:32:09,200
program

00:32:06,880 --> 00:32:09,919
is going to be compiled on so for

00:32:09,200 --> 00:32:12,640
example

00:32:09,919 --> 00:32:14,240
if you have a program that is supposed

00:32:12,640 --> 00:32:15,360
to run in windows but you don't have a

00:32:14,240 --> 00:32:17,200
windows machine

00:32:15,360 --> 00:32:20,320
you can use miri to interpret that

00:32:17,200 --> 00:32:22,960
program as if it were a windows program

00:32:20,320 --> 00:32:22,960
let me show you

00:32:26,000 --> 00:32:30,080
so here we have another user of our

00:32:29,519 --> 00:32:32,799
library

00:32:30,080 --> 00:32:34,640
this time is using environment variables

00:32:32,799 --> 00:32:36,240
to set the size and index that it wants

00:32:34,640 --> 00:32:39,200
to reach

00:32:36,240 --> 00:32:43,840
and miri can emulate an environment

00:32:39,200 --> 00:32:43,840
inside it so we can do

00:32:43,919 --> 00:32:49,840
we can use

00:32:47,519 --> 00:32:51,120
the size environment variable to set the

00:32:49,840 --> 00:32:53,120
size of the array we

00:32:51,120 --> 00:32:54,880
set the index to one because we want to

00:32:53,120 --> 00:32:58,000
run that and we

00:32:54,880 --> 00:32:58,960
disable this isolation and i'm using a

00:32:58,000 --> 00:33:00,799
linux machine

00:32:58,960 --> 00:33:02,559
but i'm going to run it for a target

00:33:00,799 --> 00:33:05,360
that is windows

00:33:02,559 --> 00:33:07,679
i don't have windows installed here and

00:33:05,360 --> 00:33:09,919
it works

00:33:07,679 --> 00:33:12,000
and if i want to run it in anything else

00:33:09,919 --> 00:33:14,240
i can do it

00:33:12,000 --> 00:33:15,760
i'm running it on my regular linux

00:33:14,240 --> 00:33:18,159
target and it's working

00:33:15,760 --> 00:33:19,360
so this is super cool because maybe you

00:33:18,159 --> 00:33:21,679
can use miri in

00:33:19,360 --> 00:33:22,799
one situation when you're not sure if

00:33:21,679 --> 00:33:24,559
this

00:33:22,799 --> 00:33:26,320
code that you wrote specifically for

00:33:24,559 --> 00:33:27,840
windows is working correctly maybe you

00:33:26,320 --> 00:33:29,279
can use mirror for that too

00:33:27,840 --> 00:33:31,360
even if you're not using save you just

00:33:29,279 --> 00:33:34,880
want to be sure that your program runs

00:33:31,360 --> 00:33:38,320
as intended um

00:33:34,880 --> 00:33:39,600
and yeah basically that's like the hard

00:33:38,320 --> 00:33:41,039
content of my talk

00:33:39,600 --> 00:33:43,120
and i want to spend like the last few

00:33:41,039 --> 00:33:44,399
minutes talking about contributing to

00:33:43,120 --> 00:33:46,000
miri

00:33:44,399 --> 00:33:48,720
so if anything of this caught your

00:33:46,000 --> 00:33:50,880
attention i encourage you to contribute

00:33:48,720 --> 00:33:52,159
to miri for many reasons my personal

00:33:50,880 --> 00:33:53,600
reasons is that

00:33:52,159 --> 00:33:55,279
i always wanted to work like in

00:33:53,600 --> 00:33:56,240
compilers because i find them super

00:33:55,279 --> 00:33:58,720
interesting

00:33:56,240 --> 00:34:00,240
i really like rust and i didn't know

00:33:58,720 --> 00:34:03,840
where to start

00:34:00,240 --> 00:34:05,760
uh so i found miri i say like oh yeah

00:34:03,840 --> 00:34:07,600
i could implement like maybe some

00:34:05,760 --> 00:34:08,879
following functions for opening files or

00:34:07,600 --> 00:34:11,839
whatever it sounds

00:34:08,879 --> 00:34:13,440
not too hard it's it was it took a while

00:34:11,839 --> 00:34:15,919
while i understood some miri

00:34:13,440 --> 00:34:17,599
specific stuff but it actually helped me

00:34:15,919 --> 00:34:19,040
a lot to understand how the compiler

00:34:17,599 --> 00:34:20,879
works and get involved

00:34:19,040 --> 00:34:23,679
in a lot of stuff that i wouldn't be

00:34:20,879 --> 00:34:25,520
able to do otherwise

00:34:23,679 --> 00:34:27,359
even then if you don't feel comfortable

00:34:25,520 --> 00:34:30,879
yet contributing because

00:34:27,359 --> 00:34:33,760
i don't know you can help this project

00:34:30,879 --> 00:34:35,839
by just using it

00:34:33,760 --> 00:34:37,839
maybe you want to use it because you

00:34:35,839 --> 00:34:39,200
actually write unsafe and you want to be

00:34:37,839 --> 00:34:40,560
sure you're not causing undefined

00:34:39,200 --> 00:34:43,040
behavior

00:34:40,560 --> 00:34:43,919
maybe some of your dependencies use

00:34:43,040 --> 00:34:45,280
unsafe

00:34:43,919 --> 00:34:48,079
and you want to be sure that them don't

00:34:45,280 --> 00:34:50,079
cause any undefined behavior

00:34:48,079 --> 00:34:51,119
so yeah there is that you can save

00:34:50,079 --> 00:34:54,079
yourself for a lot

00:34:51,119 --> 00:34:56,320
of others many many headaches debugging

00:34:54,079 --> 00:34:58,640
whereas undefined behavior books

00:34:56,320 --> 00:34:59,680
uh and maybe you're expecting that mary

00:34:58,640 --> 00:35:02,000
catches something

00:34:59,680 --> 00:35:04,000
and it isn't it doesn't it doesn't or

00:35:02,000 --> 00:35:05,359
maybe their way around

00:35:04,000 --> 00:35:07,599
you think this program is correct and

00:35:05,359 --> 00:35:09,599
mirror is complaining maybe

00:35:07,599 --> 00:35:11,359
we can you can open any issue for that

00:35:09,599 --> 00:35:15,599
you can talk with someone from the rest

00:35:11,359 --> 00:35:19,440
from the midi contributors to discuss it

00:35:15,599 --> 00:35:22,560
or from the unsafe working group also

00:35:19,440 --> 00:35:24,640
uh there is

00:35:22,560 --> 00:35:26,720
something super important and this is

00:35:24,640 --> 00:35:27,680
not like an obligation you have with the

00:35:26,720 --> 00:35:31,119
community if your

00:35:27,680 --> 00:35:33,040
if your program is

00:35:31,119 --> 00:35:34,330
runs really slow in miri that's fine i

00:35:33,040 --> 00:35:35,680
mean you don't have to

00:35:34,330 --> 00:35:37,440
[Music]

00:35:35,680 --> 00:35:38,960
to give us to give everyone anyone

00:35:37,440 --> 00:35:41,119
coverage for this

00:35:38,960 --> 00:35:42,160
but if you are super interested in

00:35:41,119 --> 00:35:44,720
contributing to me

00:35:42,160 --> 00:35:45,599
writing a shame is super is a super easy

00:35:44,720 --> 00:35:47,359
way to start

00:35:45,599 --> 00:35:48,720
or if you want just request it because

00:35:47,359 --> 00:35:50,000
you need it and you don't have the time

00:35:48,720 --> 00:35:51,440
that's fine too

00:35:50,000 --> 00:35:52,880
uh if you want to write it yourself it's

00:35:51,440 --> 00:35:53,280
super cool because what you have to

00:35:52,880 --> 00:35:56,240
learn

00:35:53,280 --> 00:35:56,960
is actually like you have to read your

00:35:56,240 --> 00:35:59,839
platform

00:35:56,960 --> 00:36:00,880
specification about how that following

00:35:59,839 --> 00:36:02,400
function works

00:36:00,880 --> 00:36:04,079
and the stuff that you need to learn

00:36:02,400 --> 00:36:05,839
about miri is really small

00:36:04,079 --> 00:36:07,440
you need to know how many words

00:36:05,839 --> 00:36:10,720
completely to do that

00:36:07,440 --> 00:36:12,640
i don't know how miraculous works uh

00:36:10,720 --> 00:36:14,400
completely i just have like i just know

00:36:12,640 --> 00:36:16,240
some little parts here and there

00:36:14,400 --> 00:36:17,440
and i implemented a lot of games because

00:36:16,240 --> 00:36:19,280
i like them

00:36:17,440 --> 00:36:21,440
uh even if you don't need that if you

00:36:19,280 --> 00:36:24,560
don't need that team maybe someone else

00:36:21,440 --> 00:36:25,839
needs it and you are not just testing

00:36:24,560 --> 00:36:27,520
uh the undefined behavior for the

00:36:25,839 --> 00:36:28,000
standard library you're testing on the

00:36:27,520 --> 00:36:29,920
file

00:36:28,000 --> 00:36:31,359
you're helping everyone write better on

00:36:29,920 --> 00:36:33,680
safe code because

00:36:31,359 --> 00:36:35,119
a lot of people use a bunch of chains

00:36:33,680 --> 00:36:36,400
that the standard library doesn't use

00:36:35,119 --> 00:36:38,960
for example

00:36:36,400 --> 00:36:40,320
if you want some specifics for windows

00:36:38,960 --> 00:36:42,240
many of the shims

00:36:40,320 --> 00:36:43,680
haven't been implemented yet and that's

00:36:42,240 --> 00:36:47,119
sort of fine because you can

00:36:43,680 --> 00:36:50,000
cross interpret like you were in windows

00:36:47,119 --> 00:36:52,000
in linux sorry but yeah for example if i

00:36:50,000 --> 00:36:55,839
go back to the

00:36:52,000 --> 00:36:55,839
to the program that opens a file

00:36:56,720 --> 00:37:04,720
and i try to run it with

00:37:01,680 --> 00:37:04,720
the windows target

00:37:07,440 --> 00:37:14,960
it will fail but it will fail because

00:37:11,520 --> 00:37:16,000
this function create file w has not been

00:37:14,960 --> 00:37:18,640
implemented yet

00:37:16,000 --> 00:37:19,520
so maybe one of you want to do it that's

00:37:18,640 --> 00:37:20,800
super cool

00:37:19,520 --> 00:37:22,560
there are a bunch of stuff that haven't

00:37:20,800 --> 00:37:25,760
been implemented yet

00:37:22,560 --> 00:37:26,560
and that's all so thank you for your

00:37:25,760 --> 00:37:29,119
time

00:37:26,560 --> 00:37:30,560
uh i hope you find this interesting and

00:37:29,119 --> 00:37:32,960
i think we can do

00:37:30,560 --> 00:37:35,040
some questions now if you want where are

00:37:32,960 --> 00:37:37,839
we yes the questions so

00:37:35,040 --> 00:37:39,599
um where there was the demo with

00:37:37,839 --> 00:37:41,839
accessing the 11th element in the air

00:37:39,599 --> 00:37:45,599
raid airmen said about accessing

00:37:41,839 --> 00:37:48,560
allocation it was free um

00:37:45,599 --> 00:37:49,760
this was out of bounds so i guess this

00:37:48,560 --> 00:37:53,119
is the question

00:37:49,760 --> 00:37:55,760
how far can it track stuff right

00:37:53,119 --> 00:37:57,280
yeah so uh this is not clear for me

00:37:55,760 --> 00:38:00,720
actually sometimes

00:37:57,280 --> 00:38:01,680
uh this program fails because when miri

00:38:00,720 --> 00:38:04,880
interprets it

00:38:01,680 --> 00:38:06,320
it frees the memory for the array before

00:38:04,880 --> 00:38:09,040
you read the pointer

00:38:06,320 --> 00:38:10,880
so it complains about memory being freed

00:38:09,040 --> 00:38:13,119
or sometimes the pointer the

00:38:10,880 --> 00:38:15,040
array is not deleted yet so it hasn't

00:38:13,119 --> 00:38:16,000
been dropped so it complains about it

00:38:15,040 --> 00:38:18,240
being

00:38:16,000 --> 00:38:19,599
out of bound access even though the race

00:38:18,240 --> 00:38:22,560
is still there

00:38:19,599 --> 00:38:24,480
so the good news is that any of those

00:38:22,560 --> 00:38:25,359
are undefined behavior so we're fine but

00:38:24,480 --> 00:38:28,400
yeah

00:38:25,359 --> 00:38:30,079
miri tries to be deterministic as much

00:38:28,400 --> 00:38:32,079
as it can

00:38:30,079 --> 00:38:33,280
but when you disciple isolation for

00:38:32,079 --> 00:38:34,880
example it's really hard to be

00:38:33,280 --> 00:38:35,599
deterministic because if you change your

00:38:34,880 --> 00:38:37,440
file

00:38:35,599 --> 00:38:40,640
that might change how your how

00:38:37,440 --> 00:38:40,640
everything works internally

00:38:41,680 --> 00:38:46,880
thank you so there's a second question

00:38:44,720 --> 00:38:49,760
where when miriam's engine is used to

00:38:46,880 --> 00:38:52,240
execute const code during compilation

00:38:49,760 --> 00:38:54,400
does it run in fast mode with with less

00:38:52,240 --> 00:38:56,560
validation

00:38:54,400 --> 00:38:59,599
and how i just the difference between

00:38:56,560 --> 00:39:02,720
the fast and the slow mode

00:38:59,599 --> 00:39:04,160
okay so i'm sort of rookie in that part

00:39:02,720 --> 00:39:06,720
of the every project i

00:39:04,160 --> 00:39:07,920
i don't know a lot of constable but yes

00:39:06,720 --> 00:39:10,240
mary

00:39:07,920 --> 00:39:13,440
miller runs without a lot of the

00:39:10,240 --> 00:39:15,200
validations it runs

00:39:13,440 --> 00:39:16,480
when you're running it it's standalone

00:39:15,200 --> 00:39:18,320
so in

00:39:16,480 --> 00:39:20,400
constant evaluation i think it's faster

00:39:18,320 --> 00:39:21,839
than what i show you

00:39:20,400 --> 00:39:23,920
but just because it has to do less

00:39:21,839 --> 00:39:25,760
checks but let's say the

00:39:23,920 --> 00:39:27,839
the engine is the same it's the same

00:39:25,760 --> 00:39:29,040
same engine but in a different car let's

00:39:27,839 --> 00:39:30,800
say

00:39:29,040 --> 00:39:33,040
yeah so we don't have dynamic

00:39:30,800 --> 00:39:34,480
allocations in const eval

00:39:33,040 --> 00:39:36,720
currently right so we don't have to

00:39:34,480 --> 00:39:38,480
check for any of these kind of bugs

00:39:36,720 --> 00:39:41,680
yeah but for example there is this

00:39:38,480 --> 00:39:43,839
flacking nightly ros that lets you run

00:39:41,680 --> 00:39:44,720
it i don't remember the name is it's

00:39:43,839 --> 00:39:47,440
something like

00:39:44,720 --> 00:39:48,079
maybe unleashed something you can run

00:39:47,440 --> 00:39:51,440
like

00:39:48,079 --> 00:39:53,599
let's say undisrupted constant

00:39:51,440 --> 00:39:55,359
evaluation all powerful to run

00:39:53,599 --> 00:39:57,680
basically whatever it wants and most of

00:39:55,359 --> 00:39:59,440
the times it breaks the compiler but

00:39:57,680 --> 00:40:01,520
yeah you can actually run like whatever

00:39:59,440 --> 00:40:03,040
you want using mirror inside the

00:40:01,520 --> 00:40:04,560
compiler but that's like super

00:40:03,040 --> 00:40:08,400
experimental

00:40:04,560 --> 00:40:11,920
okay so long term one could have a vm

00:40:08,400 --> 00:40:14,160
like a full functioning vm in miri

00:40:11,920 --> 00:40:15,280
uh in principle yes but there are a lot

00:40:14,160 --> 00:40:17,920
of questions

00:40:15,280 --> 00:40:18,640
about like for example you read a file

00:40:17,920 --> 00:40:21,920
and then

00:40:18,640 --> 00:40:23,280
you use that file to i don't know create

00:40:21,920 --> 00:40:26,160
some constant or

00:40:23,280 --> 00:40:28,160
you define a type using congeneric so

00:40:26,160 --> 00:40:29,760
that might make your calculation unsound

00:40:28,160 --> 00:40:31,599
because every time you read the file the

00:40:29,760 --> 00:40:32,319
file might change and then you compile

00:40:31,599 --> 00:40:34,160
it

00:40:32,319 --> 00:40:36,319
or maybe you are using random number

00:40:34,160 --> 00:40:36,880
generators and you you shouldn't allow

00:40:36,319 --> 00:40:40,079
those

00:40:36,880 --> 00:40:43,200
inside your computer so maybe i can

00:40:40,079 --> 00:40:45,359
introduce my own question here

00:40:43,200 --> 00:40:47,599
you think in the in a very distant

00:40:45,359 --> 00:40:51,040
future it will be possible to have

00:40:47,599 --> 00:40:54,160
uh miri included in a binary to have

00:40:51,040 --> 00:40:56,880
rust as a scripting language inside your

00:40:54,160 --> 00:41:00,000
ras program

00:40:56,880 --> 00:41:01,440
oh wow i have no idea

00:41:00,000 --> 00:41:03,520
actually i remember that someone was

00:41:01,440 --> 00:41:05,520
writing an interpreter for

00:41:03,520 --> 00:41:06,800
nyr directly so you can use it like it

00:41:05,520 --> 00:41:08,400
was a ripple

00:41:06,800 --> 00:41:10,400
i don't know what happened with that

00:41:08,400 --> 00:41:13,760
project was this the

00:41:10,400 --> 00:41:17,040
python uh like thing

00:41:13,760 --> 00:41:18,880
like the jupiter notebook like no

00:41:17,040 --> 00:41:20,640
it was a little bit different because it

00:41:18,880 --> 00:41:23,920
didn't run rust it run

00:41:20,640 --> 00:41:26,480
miri so you have to write the miri the

00:41:23,920 --> 00:41:29,359
mir of your program instead of the

00:41:26,480 --> 00:41:33,920
regular bus code

00:41:29,359 --> 00:41:36,160
what happened with that yeah interesting

00:41:33,920 --> 00:41:38,000
uh another question from the audience

00:41:36,160 --> 00:41:39,200
would it be possible to do this kind of

00:41:38,000 --> 00:41:42,240
analysis on

00:41:39,200 --> 00:41:45,359
general llvm

00:41:42,240 --> 00:41:48,880
ir um

00:41:45,359 --> 00:41:51,280
i'm tempted to say yes

00:41:48,880 --> 00:41:52,560
yes you could uh the thing is that you

00:41:51,280 --> 00:41:54,079
don't have a lot of the type

00:41:52,560 --> 00:41:55,920
information that you have when you're

00:41:54,079 --> 00:41:58,000
interpreting the mir

00:41:55,920 --> 00:41:59,040
so for example in the yr you have the

00:41:58,000 --> 00:42:00,960
lifetimes for

00:41:59,040 --> 00:42:02,560
every single value you can do a lot of

00:42:00,960 --> 00:42:04,240
reasoning around that

00:42:02,560 --> 00:42:05,760
i don't know if you can do that in

00:42:04,240 --> 00:42:08,160
little vmir directly

00:42:05,760 --> 00:42:10,400
but in principle yeah you can build uh

00:42:08,160 --> 00:42:13,680
for example and stack borrows model

00:42:10,400 --> 00:42:15,839
for a little vm ir if you want

00:42:13,680 --> 00:42:18,560
let's say i don't know how easy it is

00:42:15,839 --> 00:42:20,000
but then principle you can

00:42:18,560 --> 00:42:21,599
i guess we would have to add a lot of

00:42:20,000 --> 00:42:23,920
metadata because like

00:42:21,599 --> 00:42:24,720
new types for instance just erase and

00:42:23,920 --> 00:42:28,800
enos

00:42:24,720 --> 00:42:30,960
may become just ends yeah i think it

00:42:28,800 --> 00:42:33,440
it's harder but i believe it's possible

00:42:30,960 --> 00:42:33,440
to do that

00:42:33,920 --> 00:42:37,520
cool um is there anything you would like

00:42:36,800 --> 00:42:41,359
to show off

00:42:37,520 --> 00:42:43,200
like a final use case or like having

00:42:41,359 --> 00:42:45,920
you have like an idea of like hey if

00:42:43,200 --> 00:42:49,599
someone is bored maybe

00:42:45,920 --> 00:42:51,920
give a shout out a problem yeah actually

00:42:49,599 --> 00:42:51,920
let me

00:42:52,079 --> 00:42:56,240
let me open a new firefox window here

00:42:56,960 --> 00:43:03,920
i will share oh no

00:43:00,400 --> 00:43:05,440
yes so

00:43:03,920 --> 00:43:07,119
if you're bored and you want to do

00:43:05,440 --> 00:43:09,760
something

00:43:07,119 --> 00:43:10,319
inside miri you have a lot of issues

00:43:09,760 --> 00:43:12,640
here

00:43:10,319 --> 00:43:13,920
in particular we have this let me submit

00:43:12,640 --> 00:43:15,760
a little bit because you might

00:43:13,920 --> 00:43:17,680
be not seeing anything but we have this

00:43:15,760 --> 00:43:20,800
chimps label

00:43:17,680 --> 00:43:21,440
so there are a lot of really tiny let's

00:43:20,800 --> 00:43:23,760
say really

00:43:21,440 --> 00:43:26,319
contain problems that you can solve here

00:43:23,760 --> 00:43:27,200
for example maybe doesn't support custom

00:43:26,319 --> 00:43:30,880
allocators

00:43:27,200 --> 00:43:34,640
and in the rash in the last

00:43:30,880 --> 00:43:36,480
version uh now box

00:43:34,640 --> 00:43:37,680
the heap pointer allows for a custom

00:43:36,480 --> 00:43:40,000
allocator

00:43:37,680 --> 00:43:42,000
so it's super important now to have a

00:43:40,000 --> 00:43:43,040
way to use a custom allocator in miri

00:43:42,000 --> 00:43:44,880
just to be able to

00:43:43,040 --> 00:43:47,440
to test box with different allocators

00:43:44,880 --> 00:43:49,440
for example

00:43:47,440 --> 00:43:52,000
so yeah if you're bored you you can just

00:43:49,440 --> 00:43:54,960
grab any of these issues

00:43:52,000 --> 00:43:55,680
yeah very cool oh i'm really looking

00:43:54,960 --> 00:43:58,319
forward to

00:43:55,680 --> 00:44:00,079
a stable box with custom allocator

00:43:58,319 --> 00:44:03,520
support

00:44:00,079 --> 00:44:08,000
yeah that's very interesting

00:44:03,520 --> 00:44:09,760
wonderful so uh i think we have uh

00:44:08,000 --> 00:44:12,640
almost reached the end i don't see any

00:44:09,760 --> 00:44:15,280
more questions anymore

00:44:12,640 --> 00:44:16,960
but it was very well received and uh

00:44:15,280 --> 00:44:20,400
great talk thank you again

00:44:16,960 --> 00:44:23,839
various thank you as well okay thank you

00:44:20,400 --> 00:44:23,839

YouTube URL: https://www.youtube.com/watch?v=ltayS6B8kGM


