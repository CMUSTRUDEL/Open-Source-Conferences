Title: Yosuke Onoue - Think About Front-end Web Development with Rust — RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	With the recent advances in Webassembly and Rust toolchains that support it are making it possible to develop web frontend applications with rust alone. In this talk, I'll report on the current state of front-end web development with Rust and discuss future directions for more realistic situation.

More at https://rustfest.global/session/16-think-about-front-end-web-development-with-rust/
Captions: 
	00:00:21,041 --> 00:00:29,250
Hello. The title of this presentation is ‘Think about Front-End Web Development with Rust’. I’m Onoue.

00:00:29,708 --> 00:00:39,041
In this session, I’ll talk about front-end web development through technological progress like WebAssembly in Rust.

00:00:40,041 --> 00:00:47,166
A bit about me, I work in research and education as an Associate Professor at Nihon University.

00:00:47,416 --> 00:00:56,083
My research is on information visualization and I mainly develop visual analytic systems with web technology.

00:00:56,458 --> 00:01:05,458
I follow the cutting-edge web technology like Rust to achieve high-speed web applications.

00:01:07,375 --> 00:01:17,500
This talk will be on front-end development on Rust, what it can and can’t do, and web development trends.

00:01:18,416 --> 00:01:23,333
First, I’ll explain about recent front-end technology.

00:01:25,416 --> 00:01:34,791
Web application architecture for front-end technology has drastically developed and changed in the last 10 years.

00:01:34,791 --> 00:01:42,041
This was the typical web application configuration: It linked the application server to PHP or Python Ruby

00:01:42,041 --> 00:01:48,083
and used a template engine to assemble HTML from information loaded from a database.

00:01:48,083 --> 00:01:53,458
Then it transmitted this HTML to the client web browser.

00:01:55,416 --> 00:02:03,708
As the front-end became more important, the configuration increasingly became single page application (SPA).

00:02:04,208 --> 00:02:11,000
HTML, CSS, and JavaScript was broadcasted from the web server as a static asset.

00:02:11,000 --> 00:02:21,791
This is loaded on the browser, constructs a UI, links to the API servers, and presents information to users.

00:02:24,125 --> 00:02:33,666
The architecture changed for various reasons. Its main effect was better performance and improved UX.

00:02:34,166 --> 00:02:41,041
Along with this, more weight was put on front-end development, which became complicated.

00:02:41,041 --> 00:02:45,625
Before the browser directly loaded and processed JavaScript.

00:02:45,625 --> 00:02:53,333
The modern front-end requires a complicated bundling process on the browser:

00:02:53,333 --> 00:02:59,750
It transpiles language like TypeScript in JavaScript and aggregates multiple JavaScript files into one.

00:03:01,916 --> 00:03:11,000
With this, I’d like to consider how Rust can contribute to this complicated front-end development.

00:03:12,000 --> 00:03:20,125
The Rust websites lists their strengths as its performance with zero cost abstraction and no garbage collection,

00:03:20,125 --> 00:03:33,416
its reliability and memory safety with a powerful type system, and its productivity with a modern tool chain.

00:03:36,458 --> 00:03:43,166
These capabilities of Rust were created to be leveraged with conventional system programming.

00:03:43,166 --> 00:03:50,666
The debut of WebAssembly has made bringing the capabilities of Rust to development more feasible.

00:03:51,791 --> 00:03:59,666
WebAssembly is a binary format language and the #2 programming language running on a browser.

00:04:00,250 --> 00:04:08,916
Rust incorporated WebAssembly support at an early stage and enables build within standard tool chains.

00:04:08,916 --> 00:04:20,041
Rust is characterized by its near-native performance and small binary size without a runtime.

00:04:23,666 --> 00:04:34,750
Web front-end development by compiling WebAssembly is difficult and requires a link to an API on JavaScript.

00:04:35,166 --> 00:04:39,583
The tool to support that is wasm-bindgen.

00:04:40,125 --> 00:04:52,000
Low-level FFI to call JavaScript to Rust is made simple thanks to the crates wasm-bindgen, js-sys, and web-sys.

00:04:52,916 --> 00:05:00,708
There are two main approaches to incorporate this in web front-end development with Rust.

00:05:00,708 --> 00:05:07,875
The first is to incorporate Rust code in part of the web application mainly created with JavaScript.

00:05:07,875 --> 00:05:16,125
There’s a tool called wasm-pack for this. You can easily create a Javascript package on Rust with this.

00:05:17,166 --> 00:05:21,833
The other approach is to create an entire web application on Rust.

00:05:22,791 --> 00:05:35,500
Currently, React, Angular, and Vue are popular frameworks but require a front-end framework in Rust.

00:05:37,250 --> 00:05:44,708
This talk will be on how to write these overall with Rust.

00:05:46,958 --> 00:05:54,750
Let’s discuss the architecture adopted in the previously mentioned frameworks: React, Angular, and Vue.

00:05:55,166 --> 00:06:03,875
This is not always the case, but a model architecture centered on a virtual DOM is becoming widespread.

00:06:04,333 --> 00:06:15,250
This architecture describes how to assemble the user interface from the app with declarative programming.

00:06:15,791 --> 00:06:24,500
The virtual DOM has an algorithm to effectively update the user interface based on changes in the application.

00:06:24,500 --> 00:06:33,208
These updates are significant, but over the years they have taken various approaches with them.

00:06:33,208 --> 00:06:40,291
A typical example of these approaches is called Elm architecture which has a state update system

00:06:40,291 --> 00:06:43,708
and is adopted in Elm with an AltJS.

00:06:45,541 --> 00:06:51,458
First, View constructs the user interface in the Elm architecture.

00:06:52,416 --> 00:07:03,833
The user performs an operation from the constructed UI and the operation conveys this as a message to the app.

00:07:04,458 --> 00:07:16,958
The app state update occurs based on this message and reconstructs the user interface to match its new state.

00:07:17,708 --> 00:07:27,583
This detaches the screen construction and app state management and keeps app development scalable.

00:07:29,375 --> 00:07:38,750
This modern front-end framework architecture has high-level abstraction to manage complexities.

00:07:38,750 --> 00:07:48,500
Unfortunately, JavaScript expression is limited in how it controls every little quality of the app.

00:07:48,875 --> 00:07:58,416
Lately, TypeScript is in vogue. It makes use of type capabilities but has the limitations of its predecessor.

00:07:58,958 --> 00:08:05,125
I think that an exceptional high-performance language with a type system and tool chains like Rust

00:08:05,125 --> 00:08:12,875
is suitable to incorporate in web front-end which keeps getting more and more complex.

00:08:14,875 --> 00:08:22,083
There are already several front-end frameworks implemented on Rust with their basis in this architecture.

00:08:22,083 --> 00:08:27,750
Next, I’ll introduce front-end frameworks available on Rust.

00:08:30,583 --> 00:08:38,708
This is a list of 11 frameworks introduced on the ‘Rust Web Framework Comparison’ page.

00:08:38,708 --> 00:08:49,916
The graph on the right shows GitHub stars. Yew, Percy, Seed, Dodrio, and Sauron are comparatively popular.

00:08:49,916 --> 00:08:53,833
They have more than 1000 stars.

00:08:55,458 --> 00:09:04,875
Within these Yew is by far the most well-liked, so we’ll cover it in more detail.

00:09:07,041 --> 00:09:18,625
Yew was developed when WebAssembly debuted and has a component-based framework like React and Elm.

00:09:18,625 --> 00:09:30,208
It provides HTML macros like React and JSX and can construct a UI declaratively from the app state.

00:09:31,541 --> 00:09:36,250
It introduces state management system inspired by Elm architecture.

00:09:38,208 --> 00:09:43,416
It has various functions. The router is the most essential equipment for the front-end framework.

00:09:43,416 --> 00:09:49,333
The embedded router enables a transition between multiple pages within the app.

00:09:49,333 --> 00:09:54,958
Yew is equipped with many functions needed in modern front-end web development.

00:09:56,000 --> 00:10:02,250
Currently, it is under active development as seen from the GitHub star rating.

00:10:04,041 --> 00:10:10,250
Let’s look at a brief sample code for app development on Yew.

00:10:10,250 --> 00:10:17,208
This code has a simple counter with a plus and minus button.

00:10:18,958 --> 00:10:32,541
This model shows its components which are achieved by implementing the Component trait.

00:10:34,708 --> 00:10:45,541
It uses HTML macro to mark up the components within the View function which is one of several functions.

00:10:47,000 --> 00:10:55,375
A noteworthy function is the Create function at the top. It initializes the component here.

00:10:55,375 --> 00:10:59,916
Here, the Value field is initialized.

00:10:59,916 --> 00:11:10,750
It holds this as a component state, so it can look up the current field value from within View and then display it.

00:11:13,000 --> 00:11:16,708
Next, let’s look at the state management system.

00:11:16,708 --> 00:11:22,541
The Update function is implemented as a function to update the component state.

00:11:23,250 --> 00:11:31,458
The function receives messages and updates the component based on message’s type and content.

00:11:32,833 --> 00:11:44,833
There are two buttons constructed with View. When this is clicked, a message is issued from a click event.

00:11:46,583 --> 00:11:55,291
The sent message is received by the Update function and a state update is made for the value.

00:11:57,083 --> 00:12:09,958
A ShouldRender value is rendered to determine whether the View function needs to be restarted with an update.

00:12:10,666 --> 00:12:18,666
This is abstracted with ShouldRender. The simplest method is rendering either true or false.

00:12:18,666 --> 00:12:24,250
If it renders ‘true’, then the View function is restarted.

00:12:24,250 --> 00:12:34,708
I focused on Yew due to time constraints, but most frameworks have UI construction and state updates.

00:12:37,583 --> 00:12:42,458
There are already several sophisticated frameworks like Yew.

00:12:42,458 --> 00:12:47,750
We know we’re getting close to achieving front-end development on Rust.

00:12:47,750 --> 00:12:58,291
However, there are still many drawbacks when compared to the latest developments with JavaScript.

00:12:59,750 --> 00:13:05,625
I’ll cover these four topics that are of interest to me.

00:13:06,000 --> 00:13:10,333
The first is front-end multithread programming.

00:13:12,625 --> 00:13:23,041
A single thread, called a main or UI thread, is responsible for most functions displaying on a webpage.

00:13:23,041 --> 00:13:29,791
The HTML loaded by the web browser is stored on the browser with a structure called DOM.

00:13:29,791 --> 00:13:36,791
The main thread performs many tasks: DOM operation, image plotting,

00:13:36,791 --> 00:13:43,875
event handling for the user operation, and finally running the JavaScript processing.

00:13:45,125 --> 00:13:51,333
When the main thread takes on too many tasks, several problems arise.

00:13:51,333 --> 00:14:00,666
For example, if long processing is required for the main thread while it’s managing event handling,

00:14:00,666 --> 00:14:07,583
the thread can’t immediately respond to the user operation during this long processing.

00:14:08,083 --> 00:14:13,583
Animation processing also multiples on the web app.

00:14:13,583 --> 00:14:21,500
If the main thread is overloaded, issues arise like a degraded animation framerate.

00:14:22,666 --> 00:14:27,708
The concept called off the main thread has been proposed for this.

00:14:27,708 --> 00:14:34,791
Workers like WebWorkers are a system to conduct multithreads on a web browser.

00:14:35,375 --> 00:14:42,416
The main thread can move JavaScript processing to an independent thread using this.

00:14:42,416 --> 00:14:48,791
Workers increase idle time and reaction speed for the main thread and smoothen animation.

00:14:48,791 --> 00:14:53,375
This leads to an improved UX.

00:14:56,750 --> 00:15:04,041
For this, I’ll introduce Agents in Yew as an interesting approach to off-the-main-thread in Rust.

00:15:04,791 --> 00:15:13,791
Agents is a system that provides a service available from the overall application with an actor model.

00:15:13,791 --> 00:15:22,541
Agents provides various implementations with an abstracted interface including the use of WebWorkers.

00:15:23,041 --> 00:15:29,666
This enables processing to be delegated from the main thread without being conscious of WebWorkers.

00:15:31,583 --> 00:15:36,166
We’ll look at this code on processing with Agents.

00:15:37,708 --> 00:15:44,875
A SentToWorker message is issued when you click on the button.

00:15:45,958 --> 00:15:52,458
Once it receives the message, it issues a GetDataFromServer request to Worker.

00:15:53,916 --> 00:16:00,500
Worker receives this request and renders the processing results to the main thread.

00:16:01,666 --> 00:16:07,833
The processing results from Worker is processed with call-back and renders the call-back message.

00:16:07,833 --> 00:16:12,708
It issues a DataReceive message here.

00:16:12,708 --> 00:16:19,583
Then, the update function can reflect the processing results from that message in the state.

00:16:19,583 --> 00:16:28,000
Next is working with CSS which is indispensable in constructing a web app.

00:16:29,291 --> 00:16:36,458
As the front-end grows in scale, several issues arise surrounding CSS.

00:16:36,458 --> 00:16:44,791
A typical example of this is when the CSS selector unexpectedly crashes and the website design breaks down.

00:16:45,750 --> 00:16:56,958
Performance is essential on recent browsers, requiring asset optimization to remove unnecessary style.

00:16:57,500 --> 00:17:07,666
Several approaches, like the CSS Modules and CSS-in-JS, have been undertaken in modern front-end development.

00:17:09,291 --> 00:17:14,250
I’ll introduce a few approaches for CSS on Rust.

00:17:14,708 --> 00:17:24,041
Firstly, several methods seem to have a similar approach to CSS Modules, in which they incorporate it in asset

00:17:24,041 --> 00:17:32,000
after generating other elements and unduplicated identifiers for the styles written within the front-end app on Rust.

00:17:32,625 --> 00:17:44,291
It has an independent crate called CSS macro in Percy and CSSinRust and is applicable to this method.

00:17:45,791 --> 00:17:49,458
Let’s look at code using CSS in Rust.

00:17:51,333 --> 00:17:58,041
As you see at the top, first it wraps the style string then generates a style instance.

00:17:58,875 --> 00:18:07,041
The style instance generates a class name for the applicable element without duplicating other elements.

00:18:07,750 --> 00:18:14,208
The style itself is added to the head element in the output HTML.

00:18:14,375 --> 00:18:22,000
I’ll introduce a crate called RUSS as an approach to CSS like Rust.

00:18:22,000 --> 00:18:29,166
This will assist with CSS coding on a Rust system which is prone to error.

00:18:29,166 --> 00:18:37,541
It can describe the pixel count or the RBG color value in Rust like in the code on the bottom of the screen.

00:18:39,625 --> 00:18:45,791
Next is Server Side Rending to create a more practical web application.

00:18:47,625 --> 00:18:55,708
As you may know, when SPA configuration is adopted, the HTML file doesn’t contain much content.

00:18:55,708 --> 00:19:01,291
JavaScript is increasingly run to generate the initial content.

00:19:02,166 --> 00:19:11,083
Herein lies the problem. If the JavaScript isn’t completed, no content whatsoever can be displayed on the page.

00:19:12,000 --> 00:19:22,583
It has performance issues and issues with not displaying content in an environment that can’t process JavaScript.

00:19:22,833 --> 00:19:32,250
The Server Side Rendering (SSR) resolves these issues by constructing a UI on the webpage as SPA

00:19:32,250 --> 00:19:39,750
as well as constructing the initial UI on the server.

00:19:48,250 --> 00:19:57,625
Percy is designed for Isomorphic app construction, so it moves simultaneously on the browser and server.

00:19:57,625 --> 00:20:06,958
Looking at the Isomorphic example that includes Percy, there are 2 place holders in the HTML file for its template.

00:20:06,958 --> 00:20:15,791
One has initial content to display on the page, whereas the other becomes the app state needed to construct this.

00:20:16,500 --> 00:20:24,125
When a request arrives from the browser, the server renders the generated results applying the template.

00:20:24,708 --> 00:20:32,208
The one on the browser makes this its initial state and operates the continuing app on the browser.

00:20:32,666 --> 00:20:39,458
Currently, I believe, even front-end frameworks on Rust are becoming more aware of SRR.

00:20:39,458 --> 00:20:44,708
They’re taking into account the SRR compatibility with Yew.

00:20:46,250 --> 00:20:57,166
If we imagine the near future of front-end development, Jamstack will continue gaining traction as a system

00:20:57,166 --> 00:21:03,041
to achieve a high-performance web app with SRR.

00:21:03,041 --> 00:21:14,208
Jamstack is characterized by a configuration with a content delivery network to facilitate high-speed content to users.

00:21:14,958 --> 00:21:21,500
Next.js is a typical example of a framework for current Jamstack.

00:21:21,791 --> 00:21:30,208
Next.js supports SSR and static site generation with a framework based on React.

00:21:30,833 --> 00:21:36,000
In the future, a single-step high-level framework may become necessary

00:21:36,000 --> 00:21:42,208
to construct a practical web app in Rust more so than the current ones.

00:21:43,250 --> 00:21:46,833
Finally, let’s discuss WebComponents.

00:21:47,875 --> 00:21:59,625
As many of you may know, WebComponents is a standard system to componentize websites.

00:21:59,625 --> 00:22:08,875
It’s configured from 4 specifications: Custom Elements, Shadow DOM, ES Modules, and HTML Template.

00:22:08,875 --> 00:22:12,958
Incidentally, WebComponents has a connection to Rust. 

00:22:12,958 --> 00:22:19,666
It needs to inherit a JavaScript class called HTML Element to implement Custom Elements.

00:22:19,666 --> 00:22:31,625
This inheritance through wasm-bidgen is under discussion, so you can’t directly implement Custom Elements on Rust.

00:22:32,125 --> 00:22:43,666
Personally, I think this’d be great, but let’s consider how you can write WebComponents with Rust.

00:22:43,875 --> 00:22:50,875
In this presentation, we’ve considered how to write the overall web application with Rust.

00:22:50,875 --> 00:23:02,916
If we take this a step further, this will cover creating part of the interface on Rust and embedding this on the app.

00:23:02,916 --> 00:23:07,458
A trend that merits attention is micro frontends.

00:23:07,458 --> 00:23:17,041
The system splits the currently enlarged front-end into several micro frontends

00:23:17,041 --> 00:23:21,833
so that the backend app changes from a monolithic one to a microservice.

00:23:21,833 --> 00:23:29,166
Then, this integrates a large web app. This is the trend for micro frontends.

00:23:29,166 --> 00:23:39,791
Interestingly enough, the micro front-end configuring the app could be disconnected from the implementation.

00:23:40,125 --> 00:23:48,000
These micro frontends could be written with Agular or with React.

00:23:48,000 --> 00:23:55,375
Micro frontends also include things that can be created with Rust and WebAssembly.

00:23:56,083 --> 00:24:04,750
WebComponents is not the only method to achieve micro frontends, but it’s an example of an effective tool for it.

00:24:04,750 --> 00:24:10,041
Once WebComponents is possible on Rust, it surely has the potential

00:24:10,041 --> 00:24:13,791
to create part of the app user interface on Rust.

00:24:14,791 --> 00:24:16,291
To conclude

00:24:16,291 --> 00:24:26,583
this is an opportunity to leverage powerful language like Rust on complex front-end development.

00:24:27,250 --> 00:24:37,750
Front-end development with Rust is close to fruition with the debut of WebAssembly toolchains and frameworks.

00:24:38,250 --> 00:24:46,000
There are still discrepancies, but we need to try out the best practices cultivated thus far on Rust

00:24:46,000 --> 00:24:54,833
in order to achieve full-blown front-end development on Rust.

00:24:55,041 --> 00:25:03,208
There are still many issues to address when you attempt to work on the front-end with Rust,

00:25:03,208 --> 00:25:11,083
so I’d like to challenge everyone here today to try your hand at tackling these.

00:25:11,750 --> 00:25:13,750

YouTube URL: https://www.youtube.com/watch?v=m_zGSFyINhY


