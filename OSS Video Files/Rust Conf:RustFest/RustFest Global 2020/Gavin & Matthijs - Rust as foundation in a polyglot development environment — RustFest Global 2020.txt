Title: Gavin & Matthijs - Rust as foundation in a polyglot development environment â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	by Gavin Mendel-Gleason & Matthijs van Otterdijk



TerminusDB (open source versioned collaboration database) is a small polyglot software house that switched from C++. The change has enabled big improvements in speed and reduction in hunting for hard-to-find re-entrance, locking and memory safety issues which used to plague us.

More at https://rustfest.global/session/20-rust-as-foundation-in-a-polyglot-development-environment/
Captions: 
	00:00:02,800 --> 00:00:07,440
gavin and mathias

00:00:04,080 --> 00:00:09,120
show how one might a large project in

00:00:07,440 --> 00:00:12,160
rust refrigerate

00:00:09,120 --> 00:00:14,559
start out small let it grow until

00:00:12,160 --> 00:00:15,440
stealing the show from whatever was

00:00:14,559 --> 00:00:17,920
there before

00:00:15,440 --> 00:00:17,920
right

00:00:19,359 --> 00:00:23,039
that's an excellent introduction so i'm

00:00:22,160 --> 00:00:25,359
gavin

00:00:23,039 --> 00:00:27,199
mendel gleeson i'm the cto for terminus

00:00:25,359 --> 00:00:29,199
tv and i wanted to talk a little bit

00:00:27,199 --> 00:00:31,359
today about rust as a foundation in a

00:00:29,199 --> 00:00:32,880
polyglot development environment

00:00:31,359 --> 00:00:34,960
so first i'm just going to give a little

00:00:32,880 --> 00:00:36,480
outline of the talk as

00:00:34,960 --> 00:00:38,559
with the motivation challenges in

00:00:36,480 --> 00:00:40,480
solution so initially

00:00:38,559 --> 00:00:42,640
our motivation and i'll talk about our

00:00:40,480 --> 00:00:43,840
problem space and why we switch to rust

00:00:42,640 --> 00:00:44,879
and then some of the challenges we

00:00:43,840 --> 00:00:47,360
encountered

00:00:44,879 --> 00:00:48,320
and the solutions that we uh used in

00:00:47,360 --> 00:00:52,239
order to use

00:00:48,320 --> 00:00:54,160
rust as a foundation in our environment

00:00:52,239 --> 00:00:56,399
so uh first you have to know a little

00:00:54,160 --> 00:00:58,239
bit about our problems so

00:00:56,399 --> 00:00:59,760
we're an in-memory collaborative

00:00:58,239 --> 00:01:03,199
revision control graph

00:00:59,760 --> 00:01:04,559
database uh so we have fairly specific

00:01:03,199 --> 00:01:06,960
requirements

00:01:04,559 --> 00:01:07,680
uh and we we have slightly unusual

00:01:06,960 --> 00:01:09,600
features

00:01:07,680 --> 00:01:11,600
so and that has driven some of the tool

00:01:09,600 --> 00:01:13,439
chain requirements that we have

00:01:11,600 --> 00:01:15,200
our software is also it's a very uh

00:01:13,439 --> 00:01:16,960
polyglot house so we

00:01:15,200 --> 00:01:18,960
we have clients written in javascript

00:01:16,960 --> 00:01:20,720
and in python we have rust

00:01:18,960 --> 00:01:23,520
and we have prologue which is somewhat

00:01:20,720 --> 00:01:26,880
unusual in the modern day

00:01:23,520 --> 00:01:29,759
um so we also there's actually

00:01:26,880 --> 00:01:32,320
also c and c or yeah there's also c

00:01:29,759 --> 00:01:34,400
involved there as well

00:01:32,320 --> 00:01:35,759
so some of the unusual features that

00:01:34,400 --> 00:01:37,920
drive our design

00:01:35,759 --> 00:01:40,079
uh requirements so we're an in-memory

00:01:37,920 --> 00:01:41,360
database so that's uh that enables

00:01:40,079 --> 00:01:43,759
faster query

00:01:41,360 --> 00:01:45,840
uh it's also simpler to implement and i

00:01:43,759 --> 00:01:46,640
i have some experience in implementing

00:01:45,840 --> 00:01:50,159
um

00:01:46,640 --> 00:01:52,640
on acid databases and so

00:01:50,159 --> 00:01:54,799
i know a lot about the difficulties that

00:01:52,640 --> 00:01:58,159
you can encounter when trying to

00:01:54,799 --> 00:02:02,079
uh to uh you know paging

00:01:58,159 --> 00:02:04,320
so we chose this time to to

00:02:02,079 --> 00:02:06,240
leave it in memory for the simplicity of

00:02:04,320 --> 00:02:08,720
design and performance

00:02:06,240 --> 00:02:09,599
we are however also acid so we use

00:02:08,720 --> 00:02:12,879
backing store

00:02:09,599 --> 00:02:14,160
it we're not um we're we uh we actually

00:02:12,879 --> 00:02:17,680
write everything to disk but

00:02:14,160 --> 00:02:19,920
uh we we leave things in memory

00:02:17,680 --> 00:02:21,200
so uh we also use the sync data

00:02:19,920 --> 00:02:22,959
structures and these are

00:02:21,200 --> 00:02:24,560
these are unusual data structures that

00:02:22,959 --> 00:02:27,599
approach the information

00:02:24,560 --> 00:02:30,640
theoretic minimum size uh while still

00:02:27,599 --> 00:02:32,239
allowing query over the data structure

00:02:30,640 --> 00:02:33,920
and so this allows us to get really

00:02:32,239 --> 00:02:37,080
really large graphs

00:02:33,920 --> 00:02:39,760
uh in our you know in in memory

00:02:37,080 --> 00:02:41,760
simultaneously but this requires a lot

00:02:39,760 --> 00:02:43,360
of bit twiddling so they're relatively

00:02:41,760 --> 00:02:45,280
complicated data structures

00:02:43,360 --> 00:02:46,800
and uh they're they're very compact but

00:02:45,280 --> 00:02:49,599
they also they're not so

00:02:46,800 --> 00:02:51,120
transparent to the developer uh so you

00:02:49,599 --> 00:02:54,080
really need to be able to do

00:02:51,120 --> 00:02:54,480
effective bit twiddling which of course

00:02:54,080 --> 00:02:57,280
is where

00:02:54,480 --> 00:02:59,040
rust comes in so we also have a bunch of

00:02:57,280 --> 00:03:00,000
git like features so we have revision

00:02:59,040 --> 00:03:03,040
control

00:03:00,000 --> 00:03:05,120
uh we have push pull clone and

00:03:03,040 --> 00:03:07,760
all of the things that you know from git

00:03:05,120 --> 00:03:09,360
we do those on databases

00:03:07,760 --> 00:03:11,840
so that also drives a lot of our

00:03:09,360 --> 00:03:12,319
requirements we have a data log query

00:03:11,840 --> 00:03:14,879
engine

00:03:12,319 --> 00:03:16,720
and we also have complex schema

00:03:14,879 --> 00:03:19,120
constraint management

00:03:16,720 --> 00:03:20,720
so first why did we look into rust in

00:03:19,120 --> 00:03:23,120
the first place uh

00:03:20,720 --> 00:03:24,560
so we were not initially a rust house we

00:03:23,120 --> 00:03:27,599
didn't have any rust in our

00:03:24,560 --> 00:03:29,200
in our development at all uh i didn't

00:03:27,599 --> 00:03:31,120
come from a rust background and although

00:03:29,200 --> 00:03:32,560
i have a lot of um

00:03:31,120 --> 00:03:34,959
experienced different programming

00:03:32,560 --> 00:03:36,560
languages rust was not one of those

00:03:34,959 --> 00:03:38,640
programming languages

00:03:36,560 --> 00:03:39,920
so our earliest prototype is actually in

00:03:38,640 --> 00:03:42,239
java

00:03:39,920 --> 00:03:43,040
it was hard to write and it had mediocre

00:03:42,239 --> 00:03:46,159
performance

00:03:43,040 --> 00:03:48,319
and so i started prototyping something

00:03:46,159 --> 00:03:49,040
in prolog and the ability to write it in

00:03:48,319 --> 00:03:50,640
prolog

00:03:49,040 --> 00:03:52,720
actually because it is it was very

00:03:50,640 --> 00:03:53,680
logical especially the schema checking

00:03:52,720 --> 00:03:55,840
parts of it

00:03:53,680 --> 00:03:57,439
uh it was extremely fast for us to write

00:03:55,840 --> 00:04:00,319
it in prologue however it had

00:03:57,439 --> 00:04:01,439
poor performance so obviously it's not

00:04:00,319 --> 00:04:04,879
the best

00:04:01,439 --> 00:04:07,760
for bit twiddling um later

00:04:04,879 --> 00:04:08,879
we moved to a library in c plus plus

00:04:07,760 --> 00:04:11,680
called

00:04:08,879 --> 00:04:13,920
hdt and we used that as our storage

00:04:11,680 --> 00:04:16,239
layer and that radically improved the

00:04:13,920 --> 00:04:18,880
performance of the application

00:04:16,239 --> 00:04:20,799
however uh we had a lot of trouble with

00:04:18,880 --> 00:04:24,160
this and it was a persistent

00:04:20,799 --> 00:04:25,840
uh source of pain so c plus plus was

00:04:24,160 --> 00:04:28,000
crashing regularly and this

00:04:25,840 --> 00:04:29,520
is partly because we we needed we had

00:04:28,000 --> 00:04:31,040
requirements that meant that we had to

00:04:29,520 --> 00:04:33,759
be uh multi-threaded

00:04:31,040 --> 00:04:35,520
for performance reasons uh because we

00:04:33,759 --> 00:04:37,759
were dealing with very very large

00:04:35,520 --> 00:04:39,040
graph databases in the in the billions

00:04:37,759 --> 00:04:42,240
of nodes

00:04:39,040 --> 00:04:43,759
um and the code was not to reentrant

00:04:42,240 --> 00:04:45,440
although supposed to be it was written

00:04:43,759 --> 00:04:47,600
with the intent of being reentrant

00:04:45,440 --> 00:04:50,240
it wasn't in practice and that this

00:04:47,600 --> 00:04:52,639
would come up uh when the server crashed

00:04:50,240 --> 00:04:54,880
and it was really really hard to find

00:04:52,639 --> 00:04:57,120
the source of these crashes

00:04:54,880 --> 00:04:58,560
and that that was a persistent source of

00:04:57,120 --> 00:05:01,039
problems for us

00:04:58,560 --> 00:05:02,479
so then there was a secondary problem

00:05:01,039 --> 00:05:04,960
which is that htt

00:05:02,479 --> 00:05:06,720
was not designed uh for right

00:05:04,960 --> 00:05:08,960
transactions so it was really designed

00:05:06,720 --> 00:05:09,360
for data sets and not databases so we

00:05:08,960 --> 00:05:12,400
were

00:05:09,360 --> 00:05:13,199
using extra orchestration logic on top

00:05:12,400 --> 00:05:15,840
of it to

00:05:13,199 --> 00:05:17,280
actually use where we would journal

00:05:15,840 --> 00:05:19,039
transactions and stuff like that in

00:05:17,280 --> 00:05:20,800
order to make it so that it could be

00:05:19,039 --> 00:05:23,120
a transactional database but it wasn't

00:05:20,800 --> 00:05:24,320
designed that way so we had feelings

00:05:23,120 --> 00:05:28,080
about what the interface

00:05:24,320 --> 00:05:30,880
should be for a library hdt wasn't it

00:05:28,080 --> 00:05:32,720
um and it also had these these uh

00:05:30,880 --> 00:05:33,360
crashing problems and we were finding it

00:05:32,720 --> 00:05:36,720
hard to

00:05:33,360 --> 00:05:39,440
to find the source of them so

00:05:36,720 --> 00:05:40,320
matthias off his own bat went out and

00:05:39,440 --> 00:05:43,120
wrote a

00:05:40,320 --> 00:05:44,880
prototype in rust of the succinct data

00:05:43,120 --> 00:05:45,840
structures that we needed to replace

00:05:44,880 --> 00:05:49,440
http

00:05:45,840 --> 00:05:50,560
and sort of um like a simple library

00:05:49,440 --> 00:05:53,680
around it

00:05:50,560 --> 00:05:56,800
uh and it looked really very promising

00:05:53,680 --> 00:05:58,319
um so i had not i had heard of rust but

00:05:56,800 --> 00:05:59,120
i hadn't actually written anything in

00:05:58,319 --> 00:06:02,160
rust

00:05:59,120 --> 00:06:03,440
uh and so this really drove me to take a

00:06:02,160 --> 00:06:05,280
look at rust and rust

00:06:03,440 --> 00:06:06,720
like i know a lot of languages i've

00:06:05,280 --> 00:06:09,520
learned o'camel c

00:06:06,720 --> 00:06:10,560
plus plus you know uh haskell um

00:06:09,520 --> 00:06:12,639
prologue

00:06:10,560 --> 00:06:13,600
lisp you know i've been through the

00:06:12,639 --> 00:06:15,840
gamut of

00:06:13,600 --> 00:06:17,199
all of these i i don't usually try to

00:06:15,840 --> 00:06:19,120
learn a new language unless there's

00:06:17,199 --> 00:06:21,919
something really peculiar

00:06:19,120 --> 00:06:22,800
that drives it as something that you

00:06:21,919 --> 00:06:25,600
might

00:06:22,800 --> 00:06:26,479
need uh in your tool kit and rust really

00:06:25,600 --> 00:06:30,000
had this

00:06:26,479 --> 00:06:30,800
this kind of incredible aspect to it

00:06:30,000 --> 00:06:34,160
which is this

00:06:30,800 --> 00:06:36,400
this uh the ability to avoid

00:06:34,160 --> 00:06:37,919
memory problems while still being

00:06:36,400 --> 00:06:41,120
extremely low level

00:06:37,919 --> 00:06:43,360
uh programming language so

00:06:41,120 --> 00:06:45,199
thread safety was one of our major

00:06:43,360 --> 00:06:46,880
headaches that we had re-interest

00:06:45,199 --> 00:06:48,880
headaches we were getting seg faults

00:06:46,880 --> 00:06:51,039
and this was a problem and we were

00:06:48,880 --> 00:06:51,440
finding it difficult and time consuming

00:06:51,039 --> 00:06:54,800
to

00:06:51,440 --> 00:06:57,440
sort them out and this library

00:06:54,800 --> 00:07:00,080
was exhibiting none of these problems uh

00:06:57,440 --> 00:07:01,599
so this is this was really promising and

00:07:00,080 --> 00:07:03,680
we decided you know we were just going

00:07:01,599 --> 00:07:05,440
to take the plunge and rewrite the

00:07:03,680 --> 00:07:09,360
foundations of our system

00:07:05,440 --> 00:07:11,440
uh in rust so and it also gave us the

00:07:09,360 --> 00:07:13,360
chance to re-engineer our data structure

00:07:11,440 --> 00:07:15,840
simplify code improve

00:07:13,360 --> 00:07:16,720
fitness for purpose change the low-level

00:07:15,840 --> 00:07:18,560
primitives

00:07:16,720 --> 00:07:20,319
and cater to writing to write

00:07:18,560 --> 00:07:23,520
transactions in particular

00:07:20,319 --> 00:07:25,360
but also enabled us to do uh some

00:07:23,520 --> 00:07:28,319
performance enhancements

00:07:25,360 --> 00:07:29,360
that we would like to have done but were

00:07:28,319 --> 00:07:31,440
afraid to do

00:07:29,360 --> 00:07:33,440
because in c plus plus there's this

00:07:31,440 --> 00:07:35,280
there's kind of a fear factor

00:07:33,440 --> 00:07:38,000
where if you had anything new you might

00:07:35,280 --> 00:07:40,800
add something that causes it to crash

00:07:38,000 --> 00:07:41,440
so of course in terms of challenges uh

00:07:40,800 --> 00:07:43,199
i'm sure

00:07:41,440 --> 00:07:44,960
everyone in the russ community knows

00:07:43,199 --> 00:07:46,400
about challenges of ffi so i don't want

00:07:44,960 --> 00:07:49,440
to belabor the point

00:07:46,400 --> 00:07:51,440
uh but we we had an interface with c

00:07:49,440 --> 00:07:53,280
because we had a prologue implementation

00:07:51,440 --> 00:07:56,319
that was written in c so it had

00:07:53,280 --> 00:07:59,840
a comfortable interaction with c stack

00:07:56,319 --> 00:08:02,080
uh and this is uh annoying because

00:07:59,840 --> 00:08:03,840
if we're interfacing with rust we're

00:08:02,080 --> 00:08:06,240
actually interfacing it with it

00:08:03,840 --> 00:08:07,759
through a cffi and that kills some of

00:08:06,240 --> 00:08:08,319
the nice guarantees that you get from

00:08:07,759 --> 00:08:11,360
rust

00:08:08,319 --> 00:08:12,479
um but at least they're isolated to the

00:08:11,360 --> 00:08:15,199
to the

00:08:12,479 --> 00:08:16,160
interaction surface rather than

00:08:15,199 --> 00:08:19,280
completely

00:08:16,160 --> 00:08:20,560
so we also ended up trampolining through

00:08:19,280 --> 00:08:22,879
a light seashin

00:08:20,560 --> 00:08:23,840
uh and this is probably not the best

00:08:22,879 --> 00:08:25,440
approach we're

00:08:23,840 --> 00:08:27,199
we're evaluating a much more direct

00:08:25,440 --> 00:08:30,000
approach currently

00:08:27,199 --> 00:08:31,120
so i won't uh try to tell everybody

00:08:30,000 --> 00:08:33,440
we've done it right

00:08:31,120 --> 00:08:36,159
we've done some things right but i think

00:08:33,440 --> 00:08:37,839
we we can improve a lot here

00:08:36,159 --> 00:08:39,680
now what we would really like though is

00:08:37,839 --> 00:08:41,680
a rust prolog

00:08:39,680 --> 00:08:42,959
because then we could have a nice clean

00:08:41,680 --> 00:08:44,800
rust ffi

00:08:42,959 --> 00:08:46,240
and everything would be beautiful and

00:08:44,800 --> 00:08:48,320
perfect now there's some

00:08:46,240 --> 00:08:50,800
progress being made on scryer prologue

00:08:48,320 --> 00:08:51,360
which is a prologue written in rust with

00:08:50,800 --> 00:08:54,399
a lot of

00:08:51,360 --> 00:08:56,000
very cool uh features

00:08:54,399 --> 00:08:58,320
that that you should go look at if

00:08:56,000 --> 00:09:01,440
you're interested in a rust

00:08:58,320 --> 00:09:01,440
prologue project

00:09:01,680 --> 00:09:05,600
so then some of the challenges that we

00:09:03,440 --> 00:09:06,480
ran into i'd like to go through really

00:09:05,600 --> 00:09:09,200
quickly

00:09:06,480 --> 00:09:10,399
so we initially expected to write a lot

00:09:09,200 --> 00:09:13,440
more of the product

00:09:10,399 --> 00:09:14,959
in rust so we started off um replacing

00:09:13,440 --> 00:09:18,160
the hdt layer

00:09:14,959 --> 00:09:19,839
and then we expected to write a lot more

00:09:18,160 --> 00:09:21,120
uh from the ground up so it's

00:09:19,839 --> 00:09:21,760
essentially it's like we had this

00:09:21,120 --> 00:09:23,839
building

00:09:21,760 --> 00:09:25,279
we went in we replaced the foundations

00:09:23,839 --> 00:09:26,399
and then we were gonna start replacing

00:09:25,279 --> 00:09:28,000
the walls

00:09:26,399 --> 00:09:29,440
so unfortunately developer time

00:09:28,000 --> 00:09:32,959
constraints has favored

00:09:29,440 --> 00:09:36,000
uh a different approach for us um

00:09:32,959 --> 00:09:38,560
so we we're doing rapid prototyping

00:09:36,000 --> 00:09:40,320
uh in prolog we essentially rewrite the

00:09:38,560 --> 00:09:41,279
kind of feature that we're interested in

00:09:40,320 --> 00:09:44,160
there

00:09:41,279 --> 00:09:45,680
and then uh instead of just immediately

00:09:44,160 --> 00:09:48,720
going to rust from there

00:09:45,680 --> 00:09:50,000
we actually wait so we're much more

00:09:48,720 --> 00:09:52,720
selective about what we

00:09:50,000 --> 00:09:54,560
put into rust uh than we had initially

00:09:52,720 --> 00:09:57,120
imagined and partly this is due

00:09:54,560 --> 00:09:58,560
to the learning curve of borrow checking

00:09:57,120 --> 00:10:00,560
semantics meaning that

00:09:58,560 --> 00:10:02,399
there's there's a difficulty in getting

00:10:00,560 --> 00:10:03,200
our developers to understand how this

00:10:02,399 --> 00:10:05,600
stuff works

00:10:03,200 --> 00:10:07,920
so that takes some time and it it there

00:10:05,600 --> 00:10:09,839
is a high up front cost here

00:10:07,920 --> 00:10:11,360
and you win it back and if you're

00:10:09,839 --> 00:10:13,760
replacing c plus

00:10:11,360 --> 00:10:15,120
you win it back very quickly you win it

00:10:13,760 --> 00:10:16,959
back very quickly because

00:10:15,120 --> 00:10:18,480
seeking out those bugs dominates in

00:10:16,959 --> 00:10:21,519
terms of time

00:10:18,480 --> 00:10:23,440
so that upfront learning uh cost is

00:10:21,519 --> 00:10:25,680
nothing compared to the cost of

00:10:23,440 --> 00:10:27,279
some horrible seg fault that you can't

00:10:25,680 --> 00:10:30,320
find

00:10:27,279 --> 00:10:32,480
but if you're replacing prologue uh

00:10:30,320 --> 00:10:34,320
the sort of amortized costs are more

00:10:32,480 --> 00:10:34,959
important so you're gonna have to worry

00:10:34,320 --> 00:10:37,279
about

00:10:34,959 --> 00:10:39,200
where you replace it uh and you have to

00:10:37,279 --> 00:10:40,640
be more careful about that

00:10:39,200 --> 00:10:42,880
once you've gotten the the knack of the

00:10:40,640 --> 00:10:44,720
borrow checker things go a lot faster

00:10:42,880 --> 00:10:46,240
however they're still slower than

00:10:44,720 --> 00:10:47,760
writing prologue because you just have

00:10:46,240 --> 00:10:50,000
to worry about more things

00:10:47,760 --> 00:10:50,959
in rust than you do it's a lower level

00:10:50,000 --> 00:10:53,920
language

00:10:50,959 --> 00:10:54,720
which is why we use it but it's also

00:10:53,920 --> 00:10:57,920
it's why we

00:10:54,720 --> 00:10:59,920
don't always use it so our solution

00:10:57,920 --> 00:11:00,959
really has been a late optimization

00:10:59,920 --> 00:11:03,360
approach

00:11:00,959 --> 00:11:04,079
and the the way that we do this is we we

00:11:03,360 --> 00:11:06,800
developed

00:11:04,079 --> 00:11:07,200
um the low-level primitives in rust for

00:11:06,800 --> 00:11:09,680
our

00:11:07,200 --> 00:11:10,399
low-level storage layer and then we

00:11:09,680 --> 00:11:13,360
design

00:11:10,399 --> 00:11:16,000
the orchestration of these in prolog and

00:11:13,360 --> 00:11:18,160
when we find a performance bottlenecks

00:11:16,000 --> 00:11:20,240
we think about how to press that

00:11:18,160 --> 00:11:21,519
orchestration or what unit of that

00:11:20,240 --> 00:11:23,600
orchestration to press

00:11:21,519 --> 00:11:26,160
down and try to find good sort of

00:11:23,600 --> 00:11:28,240
boundaries module boundaries essentially

00:11:26,160 --> 00:11:30,079
so that we can press it down into rust

00:11:28,240 --> 00:11:32,800
to improve performance and we

00:11:30,079 --> 00:11:33,839
we have really been performance driven

00:11:32,800 --> 00:11:35,519
on this so

00:11:33,839 --> 00:11:36,959
the things that get pressed into rust

00:11:35,519 --> 00:11:39,279
are those things that need

00:11:36,959 --> 00:11:41,360
need performance enhancements so we

00:11:39,279 --> 00:11:43,120
started with the storage layer in rust

00:11:41,360 --> 00:11:46,160
and have extended this to

00:11:43,120 --> 00:11:47,040
several like operations that have proved

00:11:46,160 --> 00:11:48,880
to be

00:11:47,040 --> 00:11:50,880
slow when they were prolonged and needed

00:11:48,880 --> 00:11:53,760
to be faster

00:11:50,880 --> 00:11:55,040
so these include things like you know

00:11:53,760 --> 00:11:58,240
patch application

00:11:55,040 --> 00:11:59,519
and squash operations and things of that

00:11:58,240 --> 00:12:02,240
nature

00:11:59,519 --> 00:12:02,880
so these are larger orchestrated uh

00:12:02,240 --> 00:12:05,920
they're not as

00:12:02,880 --> 00:12:07,760
low level so they have logic

00:12:05,920 --> 00:12:10,639
in them and we're doing it there now we

00:12:07,760 --> 00:12:13,920
also have done some bulk operations that

00:12:10,639 --> 00:12:16,160
in for instance csv loading

00:12:13,920 --> 00:12:17,440
has now been written completely in rust

00:12:16,160 --> 00:12:19,839
as well and this

00:12:17,440 --> 00:12:22,000
uh because if you have hundreds of

00:12:19,839 --> 00:12:24,880
thousands of rows in your csv

00:12:22,000 --> 00:12:26,959
uh you get we get probably about a 10 to

00:12:24,880 --> 00:12:29,120
20 times speed up from going from

00:12:26,959 --> 00:12:30,000
prologue to rust if we're using the same

00:12:29,120 --> 00:12:31,519
algorithm

00:12:30,000 --> 00:12:34,000
because there's some kind of constant

00:12:31,519 --> 00:12:36,240
time uh that you can imagine

00:12:34,000 --> 00:12:37,120
expanding out the the cost of these

00:12:36,240 --> 00:12:38,560
operations

00:12:37,120 --> 00:12:41,040
and for hundreds of thousands of lines

00:12:38,560 --> 00:12:41,680
that becomes a really significant time

00:12:41,040 --> 00:12:44,000
sink

00:12:41,680 --> 00:12:46,160
so csv load has now been moved

00:12:44,000 --> 00:12:48,399
completely into rust and we imagine

00:12:46,160 --> 00:12:50,560
similar kinds of large-scale bulk

00:12:48,399 --> 00:12:53,200
operations will all have to be moved

00:12:50,560 --> 00:12:56,320
into rust eventually

00:12:53,200 --> 00:12:59,040
so um the there are some

00:12:56,320 --> 00:13:01,040
uh features that we know are we're gonna

00:12:59,040 --> 00:13:03,519
add directly to the rust library so we

00:13:01,040 --> 00:13:03,839
have specific feature enhancements that

00:13:03,519 --> 00:13:06,240
we

00:13:03,839 --> 00:13:07,040
are never gonna even bother trying to do

00:13:06,240 --> 00:13:09,760
in prologue

00:13:07,040 --> 00:13:10,800
they generally have to do with low level

00:13:09,760 --> 00:13:12,560
manipulation

00:13:10,800 --> 00:13:14,000
there's just it would be silly to write

00:13:12,560 --> 00:13:16,480
them there's no point in

00:13:14,000 --> 00:13:18,160
prototyping them even there however

00:13:16,480 --> 00:13:19,519
there's a lot of features that we expect

00:13:18,160 --> 00:13:22,560
will end up in rust

00:13:19,519 --> 00:13:24,959
as we move forward and they really it's

00:13:22,560 --> 00:13:26,560
going to be a slow replacement strategy

00:13:24,959 --> 00:13:28,639
and it's not clear that we'll ever

00:13:26,560 --> 00:13:30,720
replace all of prologue although we may

00:13:28,639 --> 00:13:32,720
uh but there's like even i think in the

00:13:30,720 --> 00:13:34,560
in the asymptotic future

00:13:32,720 --> 00:13:36,000
where you know this this product is

00:13:34,560 --> 00:13:38,720
extremely uh

00:13:36,000 --> 00:13:40,000
well developed um 10 years from now and

00:13:38,720 --> 00:13:43,120
and very solid

00:13:40,000 --> 00:13:45,040
uh we can imagine that probably

00:13:43,120 --> 00:13:46,240
some of the schema checking etc will be

00:13:45,040 --> 00:13:48,560
done in

00:13:46,240 --> 00:13:50,800
prologue even even though it will be

00:13:48,560 --> 00:13:52,800
perhaps prologue embedded in rust or

00:13:50,800 --> 00:13:55,199
using squire prologue or something along

00:13:52,800 --> 00:13:58,720
those lines

00:13:55,199 --> 00:14:01,600
so one of the things though that we we

00:13:58,720 --> 00:14:02,160
ran into is a sort of unexpected bonus

00:14:01,600 --> 00:14:04,720
and

00:14:02,160 --> 00:14:06,560
we kind of knew this was here but are

00:14:04,720 --> 00:14:09,199
amazingly impressed with it

00:14:06,560 --> 00:14:10,399
nevertheless so this is the unexpected

00:14:09,199 --> 00:14:12,880
bonus round so

00:14:10,399 --> 00:14:14,399
we got data parallelism uh from

00:14:12,880 --> 00:14:17,360
switching to rust

00:14:14,399 --> 00:14:19,440
at a very low cost using rayon and it

00:14:17,360 --> 00:14:22,079
really blew our minds because

00:14:19,440 --> 00:14:23,680
we had things we hardly changed at all

00:14:22,079 --> 00:14:25,040
we had the logic already written there

00:14:23,680 --> 00:14:25,920
and we just used these magic

00:14:25,040 --> 00:14:28,079
incantations

00:14:25,920 --> 00:14:29,199
into pirate or par bridge par sword

00:14:28,079 --> 00:14:32,160
unstable and

00:14:29,199 --> 00:14:32,720
suddenly everything is way way faster

00:14:32,160 --> 00:14:34,000
and

00:14:32,720 --> 00:14:37,360
we didn't have to think about it that

00:14:34,000 --> 00:14:37,839
hard we and i love that because i'm lazy

00:14:37,360 --> 00:14:39,760
so

00:14:37,839 --> 00:14:41,120
anything that that can reduce the amount

00:14:39,760 --> 00:14:42,959
of time that we spend

00:14:41,120 --> 00:14:44,880
writing things while also improving

00:14:42,959 --> 00:14:48,000
performance is just a huge win

00:14:44,880 --> 00:14:49,680
and i i cannot uh impress upon

00:14:48,000 --> 00:14:51,199
people enough how awesome this is and

00:14:49,680 --> 00:14:52,560
how much we need other people to start

00:14:51,199 --> 00:14:54,720
using it

00:14:52,560 --> 00:14:56,320
so the borrow checker oh you know

00:14:54,720 --> 00:14:58,880
there's a cost to the programmer but

00:14:56,320 --> 00:15:01,040
there's huge benefits that come from it

00:14:58,880 --> 00:15:03,279
and it's not just safety it's also

00:15:01,040 --> 00:15:04,800
potentially speed

00:15:03,279 --> 00:15:06,480
so if you're interested in an open

00:15:04,800 --> 00:15:08,560
source solution to collaborative

00:15:06,480 --> 00:15:10,839
revision control for graphs or complex

00:15:08,560 --> 00:15:12,399
data sets you should give terminus db a

00:15:10,839 --> 00:15:15,040
try

00:15:12,399 --> 00:15:15,040
and that's it

00:15:20,399 --> 00:15:26,000
well thank you so much for the talk it

00:15:22,000 --> 00:15:27,199
was very interesting thank you so much i

00:15:26,000 --> 00:15:30,880
don't think there's uh

00:15:27,199 --> 00:15:32,800
open questions yeah but we have a well i

00:15:30,880 --> 00:15:34,399
uh have help from stefan do i ask the

00:15:32,800 --> 00:15:36,000
question do you always build with

00:15:34,399 --> 00:15:39,040
release mode or is there a speed up but

00:15:36,000 --> 00:15:42,160
debug mode also a good enough speed up

00:15:39,040 --> 00:15:42,800
so no debug is definitely not fast

00:15:42,160 --> 00:15:45,040
enough

00:15:42,800 --> 00:15:46,399
well i mean it is fast enough it's fast

00:15:45,040 --> 00:15:47,199
enough when we're just testing out

00:15:46,399 --> 00:15:49,360
things

00:15:47,199 --> 00:15:51,360
and it's great sometimes to be able to

00:15:49,360 --> 00:15:54,000
use a debugger or something

00:15:51,360 --> 00:15:55,199
but like an actual general use also

00:15:54,000 --> 00:15:55,600
while we're developing and when we're

00:15:55,199 --> 00:15:58,240
not

00:15:55,600 --> 00:16:00,560
developing the low level library we

00:15:58,240 --> 00:16:02,639
definitely build and release mode always

00:16:00,560 --> 00:16:04,000
and it is a tremendous speed up between

00:16:02,639 --> 00:16:05,839
them

00:16:04,000 --> 00:16:07,519
okay cool thank you so much i see like a

00:16:05,839 --> 00:16:09,519
lot of clapping hands in the chat right

00:16:07,519 --> 00:16:12,480
now so thank you so much for the

00:16:09,519 --> 00:16:14,079
um for joining in um is there like a

00:16:12,480 --> 00:16:15,759
last thing that you would like to add

00:16:14,079 --> 00:16:18,160
because we have a few minutes uh also

00:16:15,759 --> 00:16:23,199
still left

00:16:18,160 --> 00:16:23,199
oh wow no i had anything

00:16:28,240 --> 00:16:32,320
was a great uh thing to try like we were

00:16:31,199 --> 00:16:35,279
a bit scared

00:16:32,320 --> 00:16:36,079
to try it because the parallelism uh

00:16:35,279 --> 00:16:38,320
scary

00:16:36,079 --> 00:16:39,759
but it it's literally just replacing a

00:16:38,320 --> 00:16:42,320
few calls and

00:16:39,759 --> 00:16:44,399
it just works and we got so much speed

00:16:42,320 --> 00:16:47,440
out of it so yeah that's

00:16:44,399 --> 00:16:48,720
rust ecosystem is just amazing we we

00:16:47,440 --> 00:16:50,240
love it

00:16:48,720 --> 00:16:52,079
well there's a very like warming

00:16:50,240 --> 00:16:54,639
community i have to say also

00:16:52,079 --> 00:16:56,320
it is it's really great good community i

00:16:54,639 --> 00:16:59,120
think if there's any questions can i ask

00:16:56,320 --> 00:17:00,480
you oh wait i see a question popping

00:16:59,120 --> 00:17:01,759
do you have any idea what hinders

00:17:00,480 --> 00:17:04,319
productivity and rust besides the

00:17:01,759 --> 00:17:07,679
borough checker well

00:17:04,319 --> 00:17:09,760
like i mean it's a it types just to

00:17:07,679 --> 00:17:10,880
introduce extra overhead and like in

00:17:09,760 --> 00:17:12,079
prologue you have

00:17:10,880 --> 00:17:13,839
you don't have to worry about garbage

00:17:12,079 --> 00:17:15,439
collection you don't have to worry about

00:17:13,839 --> 00:17:16,720
how you allocate things

00:17:15,439 --> 00:17:19,039
you just have fewer things to worry

00:17:16,720 --> 00:17:20,799
about and that costs you later it costs

00:17:19,039 --> 00:17:21,360
you in terms of performance but it's

00:17:20,799 --> 00:17:24,240
really

00:17:21,360 --> 00:17:25,039
helpful in terms of developer time and

00:17:24,240 --> 00:17:26,959
lots of things

00:17:25,039 --> 00:17:28,079
it doesn't matter really what the

00:17:26,959 --> 00:17:30,160
constant time

00:17:28,079 --> 00:17:33,120
cost is because you know it's just glue

00:17:30,160 --> 00:17:34,320
like most software is just glue code so

00:17:33,120 --> 00:17:36,480
and if you're just writing glue you

00:17:34,320 --> 00:17:39,120
don't want to be worried about lots of

00:17:36,480 --> 00:17:40,559
details i think you know so there's

00:17:39,120 --> 00:17:43,840
there's another thing here

00:17:40,559 --> 00:17:45,520
uh which is uh to compare with prolog

00:17:43,840 --> 00:17:47,280
in proloque you would generally have a

00:17:45,520 --> 00:17:49,039
running prolog instance with all your

00:17:47,280 --> 00:17:49,600
codes with your entire server running in

00:17:49,039 --> 00:17:51,679
there

00:17:49,600 --> 00:17:53,760
and then you do like live recompilation

00:17:51,679 --> 00:17:54,559
of parts of that program so it's a very

00:17:53,760 --> 00:17:56,320
short loop

00:17:54,559 --> 00:17:58,000
between actually writing your code and

00:17:56,320 --> 00:18:00,000
seeing it in action

00:17:58,000 --> 00:18:02,080
with rust you do have like you have to

00:18:00,000 --> 00:18:04,000
compile and then you can run your unit

00:18:02,080 --> 00:18:04,480
test and i mean it's it's not a big

00:18:04,000 --> 00:18:06,880
thing

00:18:04,480 --> 00:18:09,120
but it is a thing uh so so having that

00:18:06,880 --> 00:18:11,039
kind of uh rebel experience

00:18:09,120 --> 00:18:12,960
that that really does help uh

00:18:11,039 --> 00:18:14,640
development

00:18:12,960 --> 00:18:16,559
care well these are some questions

00:18:14,640 --> 00:18:18,480
popping up also like for use cases and

00:18:16,559 --> 00:18:20,640
what kind of applications are really

00:18:18,480 --> 00:18:21,520
used already terminus tv at the moment

00:18:20,640 --> 00:18:23,679
can you

00:18:21,520 --> 00:18:25,039
elaborate a little bit on that yeah so

00:18:23,679 --> 00:18:27,280
there's sort of like

00:18:25,039 --> 00:18:28,559
machine learning uh where you're trying

00:18:27,280 --> 00:18:30,559
to where you need to have

00:18:28,559 --> 00:18:32,080
revision control of your data sets and

00:18:30,559 --> 00:18:34,960
there's um any kind of

00:18:32,080 --> 00:18:35,600
like large-scale graph uh manipulation

00:18:34,960 --> 00:18:38,640
problems

00:18:35,600 --> 00:18:39,760
or if you want to uh if you if you want

00:18:38,640 --> 00:18:42,000
to keep revisions

00:18:39,760 --> 00:18:43,200
and and be able to pipeline your data

00:18:42,000 --> 00:18:44,880
that's that's where we would

00:18:43,200 --> 00:18:46,559
use it and we scale up to quite large

00:18:44,880 --> 00:18:49,840
graphs so you'd be able to stick

00:18:46,559 --> 00:18:49,840
something large in there if you'd like

00:18:50,400 --> 00:18:54,160
okay and um i think we're running sort

00:18:52,880 --> 00:18:55,280
of out of time i see like postponed

00:18:54,160 --> 00:18:57,360
messages popping up

00:18:55,280 --> 00:18:59,200
uh will you both be active in the chat

00:18:57,360 --> 00:19:01,440
still for to hang around for so

00:18:59,200 --> 00:19:05,280
answer some questions i see otherwise

00:19:01,440 --> 00:19:05,280
you're finally in the chat as well so

00:19:05,679 --> 00:19:08,840
we have some technical difficulties

00:19:07,039 --> 00:19:10,720
sometimes which one does with this

00:19:08,840 --> 00:19:12,559
online experience i would say

00:19:10,720 --> 00:19:14,480
although it's also a kind of fun

00:19:12,559 --> 00:19:16,799
experience until now i have to say

00:19:14,480 --> 00:19:18,640
um yeah i want to thank you both so much

00:19:16,799 --> 00:19:20,400
for your time and also the interesting

00:19:18,640 --> 00:19:24,080
presentation and please do

00:19:20,400 --> 00:19:26,880
check out the chat um and then i

00:19:24,080 --> 00:19:27,440
see that in eight minutes we will start

00:19:26,880 --> 00:19:29,679
the new

00:19:27,440 --> 00:19:30,799
uh the next speaker already so that will

00:19:29,679 --> 00:19:33,200
be interesting as well so

00:19:30,799 --> 00:19:34,640
please also for the people watching the

00:19:33,200 --> 00:19:36,080
live stream stick around for that so

00:19:34,640 --> 00:19:37,760
we'll be back in

00:19:36,080 --> 00:19:39,200
eight minutes i would say and thank you

00:19:37,760 --> 00:19:41,679
so much again uh

00:19:39,200 --> 00:19:42,880
kevin and my dice uh great thanks and

00:19:41,679 --> 00:19:44,240
see you in the chat

00:19:42,880 --> 00:19:47,360
thank you for having us and looking

00:19:44,240 --> 00:19:47,360
forward to the rest of the talks

00:19:50,840 --> 00:19:53,840
ciao

00:19:55,840 --> 00:19:57,919

YouTube URL: https://www.youtube.com/watch?v=YJMxLIwEl6c


