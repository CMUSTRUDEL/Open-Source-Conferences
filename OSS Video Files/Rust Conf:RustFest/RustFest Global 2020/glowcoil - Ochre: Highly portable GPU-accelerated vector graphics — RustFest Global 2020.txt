Title: glowcoil - Ochre: Highly portable GPU-accelerated vector graphics â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	As screen resolutions and refresh rates increase, user interfaces increasingly need to make use of GPU acceleration in order to achieve good performance and battery life. However, the wide range of existing GPU feature sets and APIs makes it difficult to do so in a portable manner. Ochre is a Rust library for vector graphics and text rendering which is structured to take advantage of the performance strengths of GPUs while remaining portable to diverse situations, including older hardware, laptops, mobile devices, and WebGL.

More at https://rustfest.global/session/23-ochre-highly-portable-gpu-accelerated-vector-graphics
Captions: 
	00:00:02,800 --> 00:00:07,600
glow coil

00:00:03,760 --> 00:00:08,639
shows how vectors can act to create a

00:00:07,600 --> 00:00:11,679
great ui

00:00:08,639 --> 00:00:14,639
in fact they are easy to do

00:00:11,679 --> 00:00:17,920
on a slow gpu and they won't fall

00:00:14,639 --> 00:00:17,920
together when stacked

00:00:19,760 --> 00:00:24,240
hi i'm micah johnston i also go by the

00:00:22,800 --> 00:00:26,160
username glowcoil

00:00:24,240 --> 00:00:27,519
and today i'm going to be presenting a

00:00:26,160 --> 00:00:28,560
project that i've been working on called

00:00:27,519 --> 00:00:32,239
ochre which is

00:00:28,560 --> 00:00:33,680
a gpu accelerated vector graphics and

00:00:32,239 --> 00:00:36,719
text renderer

00:00:33,680 --> 00:00:39,280
um library for rust

00:00:36,719 --> 00:00:40,480
and the primary use case that i've

00:00:39,280 --> 00:00:43,680
intended ochre for

00:00:40,480 --> 00:00:44,879
is ui rendering so

00:00:43,680 --> 00:00:46,640
first i'm going to try to answer the

00:00:44,879 --> 00:00:48,559
question why am i making a vector

00:00:46,640 --> 00:00:52,079
graphics render in the first place

00:00:48,559 --> 00:00:55,680
so i would make the claim that

00:00:52,079 --> 00:00:58,320
vector graphics is by far the dominant

00:00:55,680 --> 00:01:00,879
type of representation for graphical

00:00:58,320 --> 00:01:04,879
content in user interfaces today

00:01:00,879 --> 00:01:08,159
we use it for our font formats and

00:01:04,879 --> 00:01:11,040
as well as emoji and

00:01:08,159 --> 00:01:12,479
html and css are they basically comprise

00:01:11,040 --> 00:01:15,840
a vector format and a

00:01:12,479 --> 00:01:16,479
pretty massive amount of uis use html

00:01:15,840 --> 00:01:19,920
css

00:01:16,479 --> 00:01:24,159
and the browser rendering engine today

00:01:19,920 --> 00:01:27,520
so and then beyond that

00:01:24,159 --> 00:01:29,759
most os platform ui toolkits and

00:01:27,520 --> 00:01:32,159
cross-platform ui toolkits

00:01:29,759 --> 00:01:32,960
all use pretty much use vector graphics

00:01:32,159 --> 00:01:36,479
at this point

00:01:32,960 --> 00:01:39,119
and that's for some important reasons so

00:01:36,479 --> 00:01:40,640
first of all it's just more space

00:01:39,119 --> 00:01:41,600
efficient to store the vector form of

00:01:40,640 --> 00:01:43,360
something than

00:01:41,600 --> 00:01:45,040
the image form especially at high

00:01:43,360 --> 00:01:49,840
resolutions but beyond that

00:01:45,040 --> 00:01:53,040
it's a resolution independent format so

00:01:49,840 --> 00:01:53,520
suppose you want your app to run on both

00:01:53,040 --> 00:01:55,759
a

00:01:53,520 --> 00:01:56,960
retina macbook and an older 1080p

00:01:55,759 --> 00:01:58,399
monitor

00:01:56,960 --> 00:02:00,000
if you're using images you have to

00:01:58,399 --> 00:02:02,079
export

00:02:00,000 --> 00:02:04,799
a new image for the retina format

00:02:02,079 --> 00:02:08,560
whereas vector graphics can be rendered

00:02:04,799 --> 00:02:11,760
the same on different pixel densities

00:02:08,560 --> 00:02:13,280
so that's a pretty powerful benefit and

00:02:11,760 --> 00:02:16,640
then

00:02:13,280 --> 00:02:18,959
beyond that it's just a good toolkit

00:02:16,640 --> 00:02:19,760
for if you have anything that's layout

00:02:18,959 --> 00:02:21,520
dependent

00:02:19,760 --> 00:02:23,920
based on the size of your window or if

00:02:21,520 --> 00:02:27,920
you're doing something like rendering a

00:02:23,920 --> 00:02:30,000
a waveform visualizer in a synth or a

00:02:27,920 --> 00:02:31,200
a line graph in a data visualization

00:02:30,000 --> 00:02:33,920
program

00:02:31,200 --> 00:02:35,440
vector graphics is just it's a really

00:02:33,920 --> 00:02:37,920
good tool kit for

00:02:35,440 --> 00:02:40,080
for procedural visualizations like that

00:02:37,920 --> 00:02:40,080
so

00:02:40,160 --> 00:02:44,160
we would like to have a vector graphics

00:02:41,680 --> 00:02:45,920
renderer for our uis but

00:02:44,160 --> 00:02:48,400
um now let me try to answer the question

00:02:45,920 --> 00:02:50,400
why does it need to be gpu accelerated

00:02:48,400 --> 00:02:52,800
so there are kind of two trends over the

00:02:50,400 --> 00:02:56,160
past 15 to 20 years or so

00:02:52,800 --> 00:02:58,239
that um are the reason

00:02:56,160 --> 00:02:59,519
i would say gpu acceleration is

00:02:58,239 --> 00:03:00,959
important for you guys

00:02:59,519 --> 00:03:03,440
so the first one of these is that

00:03:00,959 --> 00:03:06,400
resolutions of our screens are going up

00:03:03,440 --> 00:03:08,000
this is a visualization of iphone screen

00:03:06,400 --> 00:03:09,920
sizes over time

00:03:08,000 --> 00:03:11,599
so there's a pretty drastic increase and

00:03:09,920 --> 00:03:13,440
this doesn't even include the latest

00:03:11,599 --> 00:03:15,360
iphone which

00:03:13,440 --> 00:03:18,879
if i remember right it has something

00:03:15,360 --> 00:03:21,040
like 2700 by 1100 pixels so

00:03:18,879 --> 00:03:23,120
that is a lot of pixels we need to we

00:03:21,040 --> 00:03:24,799
need to render every frame

00:03:23,120 --> 00:03:26,720
if you want your app to run at a smooth

00:03:24,799 --> 00:03:28,959
60 frames per second

00:03:26,720 --> 00:03:29,760
you have to render a lot more pixels

00:03:28,959 --> 00:03:32,239
every second

00:03:29,760 --> 00:03:32,959
and that means using more computing

00:03:32,239 --> 00:03:35,599
power

00:03:32,959 --> 00:03:36,560
so but at the same time we don't want to

00:03:35,599 --> 00:03:38,239
drain

00:03:36,560 --> 00:03:40,410
the battery if we're on a laptop or a

00:03:38,239 --> 00:03:41,599
mobile phone and

00:03:40,410 --> 00:03:43,360
[Music]

00:03:41,599 --> 00:03:44,640
you need to hit that 60 frames per

00:03:43,360 --> 00:03:45,120
second deadline if you want to have a

00:03:44,640 --> 00:03:48,319
smooth

00:03:45,120 --> 00:03:49,519
app so um the other important trend is

00:03:48,319 --> 00:03:52,400
that

00:03:49,519 --> 00:03:54,159
gpus have become really ubiquitous in

00:03:52,400 --> 00:03:58,640
consumer hardware

00:03:54,159 --> 00:04:02,000
so you can you can get a lot more

00:03:58,640 --> 00:04:06,080
computation done both per second and

00:04:02,000 --> 00:04:10,000
per watt with a gpu than a consumer

00:04:06,080 --> 00:04:12,159
single cpu core so

00:04:10,000 --> 00:04:14,959
this lets you be both more efficient and

00:04:12,159 --> 00:04:16,880
hit your frame deadlines and also

00:04:14,959 --> 00:04:19,600
more power efficient so you don't drain

00:04:16,880 --> 00:04:19,600
the battery or

00:04:20,239 --> 00:04:25,280
use too much power just for rendering

00:04:23,280 --> 00:04:26,880
something simple like a ui which because

00:04:25,280 --> 00:04:28,560
presumably you'd like to use the rest of

00:04:26,880 --> 00:04:30,960
your cpu for

00:04:28,560 --> 00:04:32,639
other applications your app is

00:04:30,960 --> 00:04:36,080
presumably not just a ui

00:04:32,639 --> 00:04:39,120
so um because of

00:04:36,080 --> 00:04:40,720
increasing resolutions and i should note

00:04:39,120 --> 00:04:43,120
refresh rates are also starting to

00:04:40,720 --> 00:04:46,560
become an issue because 120 hertz

00:04:43,120 --> 00:04:47,040
144hz monitors are starting to enter the

00:04:46,560 --> 00:04:48,639
market

00:04:47,040 --> 00:04:50,160
so that's even more pixels you have to

00:04:48,639 --> 00:04:55,520
paint per second

00:04:50,160 --> 00:04:58,639
um gpus are really good for

00:04:55,520 --> 00:05:00,880
highly parallel tasks and

00:04:58,639 --> 00:05:02,320
rendering happens to a lot of aspects of

00:05:00,880 --> 00:05:03,039
2d rendering happen to be highly

00:05:02,320 --> 00:05:04,800
parallel

00:05:03,039 --> 00:05:06,880
since a lot of tasks you simply do the

00:05:04,800 --> 00:05:10,000
same operation per pixel

00:05:06,880 --> 00:05:13,039
so it's a good fit for gpus

00:05:10,000 --> 00:05:15,280
and the set of gpus that are available

00:05:13,039 --> 00:05:16,240
in consumer hardware are a good fit for

00:05:15,280 --> 00:05:20,160
returning uis

00:05:16,240 --> 00:05:24,400
so and as kind of evidence of this

00:05:20,160 --> 00:05:27,759
both mac os and windows have been using

00:05:24,400 --> 00:05:29,600
gpu hardware to accelerate the

00:05:27,759 --> 00:05:30,960
basically the step of taking all of the

00:05:29,600 --> 00:05:34,240
different windows you have open

00:05:30,960 --> 00:05:36,479
and painting them all onto one

00:05:34,240 --> 00:05:38,880
one frame to display on your monitor the

00:05:36,479 --> 00:05:41,440
which is an operation called compositing

00:05:38,880 --> 00:05:43,919
both mac and windows have been using the

00:05:41,440 --> 00:05:44,240
gpu to do that for around 15 years i

00:05:43,919 --> 00:05:47,520
think

00:05:44,240 --> 00:05:49,360
mac since around 2004 and windows since

00:05:47,520 --> 00:05:52,720
2007 with vista

00:05:49,360 --> 00:05:53,680
so and in addition to that browsers are

00:05:52,720 --> 00:05:55,759
also

00:05:53,680 --> 00:05:56,720
increasingly taking advantage of the gpu

00:05:55,759 --> 00:05:59,120
so

00:05:56,720 --> 00:06:00,720
um there's evidence that it is a good

00:05:59,120 --> 00:06:03,520
idea to use

00:06:00,720 --> 00:06:06,000
gpu acceleration to render the ui for

00:06:03,520 --> 00:06:08,720
both efficiency and

00:06:06,000 --> 00:06:10,560
power efficiency reasons so hopefully

00:06:08,720 --> 00:06:13,759
i've convinced you that

00:06:10,560 --> 00:06:14,720
a gpu accelerated vector renderer is a

00:06:13,759 --> 00:06:17,759
desirable

00:06:14,720 --> 00:06:19,520
thing to have for a ui but

00:06:17,759 --> 00:06:21,280
using the gpu comes with a catch and

00:06:19,520 --> 00:06:24,319
that's basically that

00:06:21,280 --> 00:06:25,840
um you can't just write a single program

00:06:24,319 --> 00:06:27,759
and then run it on

00:06:25,840 --> 00:06:28,960
every gpu out in the wild there's a big

00:06:27,759 --> 00:06:33,120
variety of

00:06:28,960 --> 00:06:36,240
manufacturers and then of

00:06:33,120 --> 00:06:38,560
apis and platforms which give you some

00:06:36,240 --> 00:06:42,080
subset of the apis but not all of them

00:06:38,560 --> 00:06:43,919
so i have this table here showing which

00:06:42,080 --> 00:06:46,960
apis are available on which

00:06:43,919 --> 00:06:48,639
operating systems and

00:06:46,960 --> 00:06:50,800
there isn't really an api that has full

00:06:48,639 --> 00:06:51,919
coverage of all the operating systems

00:06:50,800 --> 00:06:55,199
you might want to target

00:06:51,919 --> 00:06:56,720
opengl looks promising but it's

00:06:55,199 --> 00:06:58,880
it's officially deprecated on apple

00:06:56,720 --> 00:07:00,880
platforms and even before that

00:06:58,880 --> 00:07:03,120
there was only an older version with

00:07:00,880 --> 00:07:07,199
more limited features was supported

00:07:03,120 --> 00:07:08,800
and um this table actually

00:07:07,199 --> 00:07:11,440
looks a bit more rosy than the real

00:07:08,800 --> 00:07:13,520
situation because

00:07:11,440 --> 00:07:16,560
vulcan and the newer versions of directx

00:07:13,520 --> 00:07:18,960
and metal are only supported on

00:07:16,560 --> 00:07:19,680
newer hardware so suppose you have you

00:07:18,960 --> 00:07:21,199
have a

00:07:19,680 --> 00:07:23,520
slightly older phone or you have a 10

00:07:21,199 --> 00:07:24,319
year old desktop computer it may not be

00:07:23,520 --> 00:07:26,319
able to run

00:07:24,319 --> 00:07:28,639
the newer features so even if you're if

00:07:26,319 --> 00:07:32,160
you've picked an operating system and a

00:07:28,639 --> 00:07:33,759
a gpu api you have to negotiate which

00:07:32,160 --> 00:07:35,599
feature level you're willing to target

00:07:33,759 --> 00:07:39,120
and which users you're willing to

00:07:35,599 --> 00:07:40,880
exclude from your application so

00:07:39,120 --> 00:07:42,560
portability is kind of a hard question

00:07:40,880 --> 00:07:44,080
you have to figure out

00:07:42,560 --> 00:07:46,400
how you're going to make your

00:07:44,080 --> 00:07:48,240
application use different

00:07:46,400 --> 00:07:50,080
apis on different platforms if you do

00:07:48,240 --> 00:07:51,440
want to be cross-platform

00:07:50,080 --> 00:07:53,360
probably the hardest part of this is

00:07:51,440 --> 00:07:54,400
that when you write code that runs on

00:07:53,360 --> 00:07:56,560
the gpu

00:07:54,400 --> 00:07:57,680
you use what's called a shading language

00:07:56,560 --> 00:07:59,280
and

00:07:57,680 --> 00:08:01,120
each of those different apis have

00:07:59,280 --> 00:08:02,479
different shading languages

00:08:01,120 --> 00:08:04,960
so either you're going to have to

00:08:02,479 --> 00:08:06,160
rewrite your shaders for each platform

00:08:04,960 --> 00:08:06,800
or you're going to have to figure out

00:08:06,160 --> 00:08:09,280
some cross

00:08:06,800 --> 00:08:12,160
compilation setup where your build

00:08:09,280 --> 00:08:14,560
system includes a shader compiler which

00:08:12,160 --> 00:08:16,639
increases complexity and even then you

00:08:14,560 --> 00:08:18,800
still have to negotiate

00:08:16,639 --> 00:08:20,240
platform-specific features when you're

00:08:18,800 --> 00:08:22,400
doing so so

00:08:20,240 --> 00:08:24,720
it's kind of a big headache and the

00:08:22,400 --> 00:08:26,960
approach that i've taken with ocr

00:08:24,720 --> 00:08:28,879
is just to choose a very small subset

00:08:26,960 --> 00:08:29,840
the smallest possible subset of gpu

00:08:28,879 --> 00:08:32,479
features

00:08:29,840 --> 00:08:33,519
that are going to be available pretty

00:08:32,479 --> 00:08:36,000
much anywhere

00:08:33,519 --> 00:08:38,159
that are still going to let us leverage

00:08:36,000 --> 00:08:40,240
gpu performance advantages

00:08:38,159 --> 00:08:41,839
and are still going to let us do the ui

00:08:40,240 --> 00:08:45,839
graphics that we would like to do

00:08:41,839 --> 00:08:46,880
so um to get into a little bit more

00:08:45,839 --> 00:08:49,040
detail about what

00:08:46,880 --> 00:08:50,320
a vector render actually has to do there

00:08:49,040 --> 00:08:53,040
are kind of two aspects

00:08:50,320 --> 00:08:55,200
so the first aspect is you take these

00:08:53,040 --> 00:08:58,720
shapes so for instance a

00:08:55,200 --> 00:09:02,000
font glyph a letter in a font it's

00:08:58,720 --> 00:09:03,440
basically defines a solid region bounded

00:09:02,000 --> 00:09:05,760
by a curve

00:09:03,440 --> 00:09:08,240
and the renderer has to determine which

00:09:05,760 --> 00:09:10,240
pixels are inside or outside that curve

00:09:08,240 --> 00:09:11,920
and then fill them in with the

00:09:10,240 --> 00:09:13,600
appropriate color whether that's a solid

00:09:11,920 --> 00:09:15,120
color or a gradient

00:09:13,600 --> 00:09:17,440
and then the other aspect is taking

00:09:15,120 --> 00:09:19,600
multiple shapes like that and

00:09:17,440 --> 00:09:21,360
compositing them in order using what's

00:09:19,600 --> 00:09:23,200
called the painters algorithm where

00:09:21,360 --> 00:09:24,880
it's called that because later things

00:09:23,200 --> 00:09:28,080
that you draw paint over

00:09:24,880 --> 00:09:29,839
earlier things so

00:09:28,080 --> 00:09:31,519
the second step compositing which is on

00:09:29,839 --> 00:09:33,680
the left here

00:09:31,519 --> 00:09:34,800
gpus are really good at it and like i

00:09:33,680 --> 00:09:36,480
mentioned before

00:09:34,800 --> 00:09:38,480
this is what operating systems and

00:09:36,480 --> 00:09:40,880
browsers have been making a lot of use

00:09:38,480 --> 00:09:43,440
of gpus for for a long time now

00:09:40,880 --> 00:09:45,360
so it's it's just an easy thing to do

00:09:43,440 --> 00:09:46,800
with gpus and they're very good at it

00:09:45,360 --> 00:09:48,720
it's much more power efficient than

00:09:46,800 --> 00:09:50,959
doing it with the cpu

00:09:48,720 --> 00:09:52,240
on the other hand the painting the

00:09:50,959 --> 00:09:54,160
operation that i will call painting

00:09:52,240 --> 00:09:55,519
which is determining inside and outside

00:09:54,160 --> 00:09:58,240
of a shape like this

00:09:55,519 --> 00:10:00,399
is it doesn't come naturally to gpus

00:09:58,240 --> 00:10:02,880
since they kind of only natively speak

00:10:00,399 --> 00:10:04,240
in triangles so you have to somehow

00:10:02,880 --> 00:10:07,519
translate

00:10:04,240 --> 00:10:09,279
these types of shapes into triangles

00:10:07,519 --> 00:10:10,959
in one way or another for the gpu to

00:10:09,279 --> 00:10:12,959
understand so

00:10:10,959 --> 00:10:14,480
that's the hard part there are a lot of

00:10:12,959 --> 00:10:17,120
different approaches

00:10:14,480 --> 00:10:18,399
to doing so so i have this kind of

00:10:17,120 --> 00:10:21,440
spectrum here

00:10:18,399 --> 00:10:21,920
from renders that use more cpu to render

00:10:21,440 --> 00:10:24,399
as they

00:10:21,920 --> 00:10:25,519
use more gpu this is a it's a huge

00:10:24,399 --> 00:10:28,800
oversimplification

00:10:25,519 --> 00:10:30,240
so this is super subjective and on

00:10:28,800 --> 00:10:31,920
in different ways you could argue that

00:10:30,240 --> 00:10:33,440
these should be in different orders so

00:10:31,920 --> 00:10:34,480
this is just intended to kind of give a

00:10:33,440 --> 00:10:37,519
broad overview

00:10:34,480 --> 00:10:39,120
so on one end we have doing rendering

00:10:37,519 --> 00:10:41,519
entirely on the cpu

00:10:39,120 --> 00:10:42,880
and then as we move down there's

00:10:41,519 --> 00:10:46,240
tessellation which is

00:10:42,880 --> 00:10:49,200
an approach that basically busts apart

00:10:46,240 --> 00:10:50,720
a shape like this into triangles and

00:10:49,200 --> 00:10:52,399
then just shovels the triangles over to

00:10:50,720 --> 00:10:56,480
the gpu to be rendered

00:10:52,399 --> 00:10:58,399
and it's robust it's simple it does

00:10:56,480 --> 00:10:59,920
work well for performance but there are

00:10:58,399 --> 00:11:03,279
some big downsides

00:10:59,920 --> 00:11:04,880
namely that gpus aren't capable of

00:11:03,279 --> 00:11:06,720
rendering triangles with the type of

00:11:04,880 --> 00:11:07,279
anti-aliasing that you need for small

00:11:06,720 --> 00:11:08,720
text

00:11:07,279 --> 00:11:10,640
so you kind of have to do a hybrid

00:11:08,720 --> 00:11:13,120
approach if you use tessellation

00:11:10,640 --> 00:11:16,240
um and maybe render your text on the cpu

00:11:13,120 --> 00:11:18,640
and your bigger shapes on the gpu

00:11:16,240 --> 00:11:19,680
and um there's another approach called

00:11:18,640 --> 00:11:21,200
stencil and cover

00:11:19,680 --> 00:11:22,880
and it's it's called that because it

00:11:21,200 --> 00:11:24,160
uses a feature of the gpu called the

00:11:22,880 --> 00:11:26,720
stencil buffer

00:11:24,160 --> 00:11:28,160
to rather than doing the kind of

00:11:26,720 --> 00:11:30,399
mathematically hard operation

00:11:28,160 --> 00:11:31,760
of breaking apart a concave curved shape

00:11:30,399 --> 00:11:34,720
into triangles

00:11:31,760 --> 00:11:36,640
it just it draws sort of depicts a point

00:11:34,720 --> 00:11:37,680
and draws a fan of triangles out from

00:11:36,640 --> 00:11:39,600
that point

00:11:37,680 --> 00:11:40,880
in such a way that they all cancel each

00:11:39,600 --> 00:11:43,519
other out

00:11:40,880 --> 00:11:44,240
to leave only the points inside the

00:11:43,519 --> 00:11:46,079
shape

00:11:44,240 --> 00:11:49,120
filled and the points outside the shape

00:11:46,079 --> 00:11:49,680
empty and it has the same disadvantages

00:11:49,120 --> 00:11:51,519
as

00:11:49,680 --> 00:11:52,880
tessellation where the it's hard to get

00:11:51,519 --> 00:11:56,160
really high quality

00:11:52,880 --> 00:11:58,160
anti-aliasing and um

00:11:56,160 --> 00:11:59,760
while it makes more use of the gpu it's

00:11:58,160 --> 00:12:01,440
also an inherently less efficient

00:11:59,760 --> 00:12:03,600
algorithm than

00:12:01,440 --> 00:12:04,959
cpu rasterization methods so it's kind

00:12:03,600 --> 00:12:08,720
of a trade-off it's not a

00:12:04,959 --> 00:12:10,480
it's not a pure win um

00:12:08,720 --> 00:12:12,320
there's an example of a library that

00:12:10,480 --> 00:12:14,480
does this called nano vg which

00:12:12,320 --> 00:12:15,600
it uses the stencil and cover approach

00:12:14,480 --> 00:12:17,200
it has to

00:12:15,600 --> 00:12:18,880
take a hybrid approach with text

00:12:17,200 --> 00:12:19,839
rendering where it renders text on the

00:12:18,880 --> 00:12:22,800
cpu

00:12:19,839 --> 00:12:24,000
and big shapes on the gpu nano vg was a

00:12:22,800 --> 00:12:25,600
big inspiration to ocr

00:12:24,000 --> 00:12:28,399
because it's it's the same kind of

00:12:25,600 --> 00:12:29,040
minimal library focused on portability

00:12:28,399 --> 00:12:30,720
and

00:12:29,040 --> 00:12:33,120
working on as many situations as

00:12:30,720 --> 00:12:35,440
possible so as we move further down we

00:12:33,120 --> 00:12:38,480
get these more complicated approaches

00:12:35,440 --> 00:12:41,040
um such as pathfinder which is

00:12:38,480 --> 00:12:41,519
a rust library written by patrick walton

00:12:41,040 --> 00:12:42,800
and

00:12:41,519 --> 00:12:44,959
pathfinder was probably the number one

00:12:42,800 --> 00:12:45,760
inspiration for ochre i'm not sure if i

00:12:44,959 --> 00:12:48,160
would have

00:12:45,760 --> 00:12:48,959
have written ocr without pathfinder so i

00:12:48,160 --> 00:12:51,120
have to

00:12:48,959 --> 00:12:52,240
give some big acknowledgments to patrick

00:12:51,120 --> 00:12:54,480
walton for that

00:12:52,240 --> 00:12:56,000
pathfinder is kind of a refinement of

00:12:54,480 --> 00:12:59,040
the stencil and cover approach

00:12:56,000 --> 00:13:02,480
that does a lot of cpu work

00:12:59,040 --> 00:13:04,720
to split the shapes up so that

00:13:02,480 --> 00:13:06,720
you only have to do work near the edges

00:13:04,720 --> 00:13:08,160
rather than in the big opaque centers of

00:13:06,720 --> 00:13:11,600
the shapes

00:13:08,160 --> 00:13:13,360
um so it's it's really a cpu gpu hybrid

00:13:11,600 --> 00:13:15,519
you're doing work in both places and it

00:13:13,360 --> 00:13:19,200
can it can really outperform

00:13:15,519 --> 00:13:21,680
cpu rasterizers like cairo but um

00:13:19,200 --> 00:13:24,480
it's it's kind of a hybrid approach like

00:13:21,680 --> 00:13:27,760
that it's not pure gpu and then you

00:13:24,480 --> 00:13:30,160
you um the

00:13:27,760 --> 00:13:31,519
next item on my list here is a vector

00:13:30,160 --> 00:13:34,320
textures architecture which is

00:13:31,519 --> 00:13:35,519
it works kind of differently there the

00:13:34,320 --> 00:13:38,399
way it works is you have a

00:13:35,519 --> 00:13:39,279
cpu preprocess and then you can render

00:13:38,399 --> 00:13:41,040
it

00:13:39,279 --> 00:13:43,440
many times on the gpu from different

00:13:41,040 --> 00:13:47,040
angles for instance in a 3d scene

00:13:43,440 --> 00:13:49,279
so it offloads a lot of work to the gpu

00:13:47,040 --> 00:13:50,800
but unfortunately it kind of has

00:13:49,279 --> 00:13:52,399
performance tradeoffs more appropriate

00:13:50,800 --> 00:13:55,839
to a game than to

00:13:52,399 --> 00:13:58,320
a ui because um the reason for that is

00:13:55,839 --> 00:14:01,519
the end-to-end render time from

00:13:58,320 --> 00:14:03,920
loading a font or or

00:14:01,519 --> 00:14:05,600
generating a scene from scratch to

00:14:03,920 --> 00:14:07,440
processing it uploading and rendering on

00:14:05,600 --> 00:14:11,920
the gpu

00:14:07,440 --> 00:14:14,720
is not even really faster than maybe

00:14:11,920 --> 00:14:16,000
full-on cpu rasterization sometimes um

00:14:14,720 --> 00:14:18,000
so i

00:14:16,000 --> 00:14:20,560
i don't consider this a good approach

00:14:18,000 --> 00:14:22,560
for uis but it is a good approach for

00:14:20,560 --> 00:14:24,800
other situations such as games and then

00:14:22,560 --> 00:14:26,959
finally last on the list we have

00:14:24,800 --> 00:14:27,920
a pure gpu compute renderer which

00:14:26,959 --> 00:14:31,360
basically

00:14:27,920 --> 00:14:33,839
uploads the scene as a

00:14:31,360 --> 00:14:35,680
data structure to the gpu uses modern

00:14:33,839 --> 00:14:38,399
gpu compute features

00:14:35,680 --> 00:14:40,000
to render it from scratch there um

00:14:38,399 --> 00:14:40,959
you'll notice pathfinder also appears

00:14:40,000 --> 00:14:44,399
here because

00:14:40,959 --> 00:14:45,760
patrick walton in in recent months

00:14:44,399 --> 00:14:46,959
developed another renderer for

00:14:45,760 --> 00:14:50,480
pathfinder that

00:14:46,959 --> 00:14:52,399
uses gpu compute and um along with that

00:14:50,480 --> 00:14:55,519
there's another rust library called p

00:14:52,399 --> 00:14:57,360
gpu that um was developed by ray flavine

00:14:55,519 --> 00:14:58,800
and both of these get really impressive

00:14:57,360 --> 00:15:02,160
performance when you're using

00:14:58,800 --> 00:15:04,240
a a high-end gpu they scale up

00:15:02,160 --> 00:15:06,240
unlike any of the other approaches to

00:15:04,240 --> 00:15:08,240
really using the gpu

00:15:06,240 --> 00:15:09,680
um but there's there's kind of this

00:15:08,240 --> 00:15:12,880
central trade-off here

00:15:09,680 --> 00:15:16,639
as you use the gpu better you can

00:15:12,880 --> 00:15:19,920
scale up better with bigger gpus but

00:15:16,639 --> 00:15:21,760
it makes it harder to work on older

00:15:19,920 --> 00:15:24,000
hardware and it makes it harder to port

00:15:21,760 --> 00:15:26,240
between different apis

00:15:24,000 --> 00:15:29,120
and this is as i understand it this is

00:15:26,240 --> 00:15:32,399
why pathfinder has both renders because

00:15:29,120 --> 00:15:36,399
the the non-compute render is

00:15:32,399 --> 00:15:38,240
um trying to achieve more portability so

00:15:36,399 --> 00:15:40,240
ocr is also an attempt to kind of strike

00:15:38,240 --> 00:15:43,360
a balance on this trade-off

00:15:40,240 --> 00:15:45,600
and it is an attempt to strike a balance

00:15:43,360 --> 00:15:46,959
closer to tessellation in the

00:15:45,600 --> 00:15:50,079
portability sense

00:15:46,959 --> 00:15:51,440
but kind of still achieve high enough

00:15:50,079 --> 00:15:52,959
anti-aliasing quality that you can

00:15:51,440 --> 00:15:56,560
render text with it

00:15:52,959 --> 00:15:58,639
so um let me go over a little bit of my

00:15:56,560 --> 00:16:01,279
earlier process that led me to the

00:15:58,639 --> 00:16:05,199
current state of ochre

00:16:01,279 --> 00:16:09,120
so the first thing that i worked on um

00:16:05,199 --> 00:16:12,320
i was working on this for

00:16:09,120 --> 00:16:13,279
about a year um starting about a year

00:16:12,320 --> 00:16:16,000
and a half ago

00:16:13,279 --> 00:16:18,079
and it works like the vector textures

00:16:16,000 --> 00:16:19,680
architecture as i mentioned earlier

00:16:18,079 --> 00:16:22,079
um so it has the trade-offs that i

00:16:19,680 --> 00:16:23,759
mentioned where it's better suited to

00:16:22,079 --> 00:16:25,600
a 3d game where you render something

00:16:23,759 --> 00:16:27,120
that's the same many times from

00:16:25,600 --> 00:16:30,000
different angles

00:16:27,120 --> 00:16:31,279
um and i i put a lot of work into this

00:16:30,000 --> 00:16:33,839
and then i decided it wasn't

00:16:31,279 --> 00:16:35,440
the appropriate approach for uis so i've

00:16:33,839 --> 00:16:38,720
kind of shelved it for now

00:16:35,440 --> 00:16:41,759
but um gouache will return

00:16:38,720 --> 00:16:43,519
eventually um but

00:16:41,759 --> 00:16:45,120
i was searching for something that was

00:16:43,519 --> 00:16:46,399
that struck that trade-off better for

00:16:45,120 --> 00:16:49,120
you guys

00:16:46,399 --> 00:16:50,000
and um this was the first thing i got

00:16:49,120 --> 00:16:52,000
really excited about

00:16:50,000 --> 00:16:54,560
so i call it sparse scanline rendering

00:16:52,000 --> 00:16:58,160
and the way it works is

00:16:54,560 --> 00:17:01,360
um it only renders

00:16:58,160 --> 00:17:04,559
the pixels that are intersected by the

00:17:01,360 --> 00:17:05,919
the outlines um and then it

00:17:04,559 --> 00:17:08,160
and then it uploads those two as

00:17:05,919 --> 00:17:09,199
horizontal lines to the gpu so i also

00:17:08,160 --> 00:17:12,400
like to call it

00:17:09,199 --> 00:17:16,720
the gl lines gopher architecture

00:17:12,400 --> 00:17:19,199
um so you can see on this diagram

00:17:16,720 --> 00:17:20,559
anything that's not a pixel intersected

00:17:19,199 --> 00:17:23,120
by the curve

00:17:20,559 --> 00:17:24,079
doesn't have to be processed on the cpu

00:17:23,120 --> 00:17:26,079
um

00:17:24,079 --> 00:17:27,679
and it just gets filled in by the gpu

00:17:26,079 --> 00:17:31,360
which is

00:17:27,679 --> 00:17:33,520
good at good at doing kind of simple

00:17:31,360 --> 00:17:35,919
highly parallel tasks like filling in a

00:17:33,520 --> 00:17:39,360
bunch of solid pixels

00:17:35,919 --> 00:17:40,720
so um

00:17:39,360 --> 00:17:42,640
so yeah you can see here this is what

00:17:40,720 --> 00:17:46,000
the horizontal lines look like they get

00:17:42,640 --> 00:17:48,480
uploaded to the gpu and you can you can

00:17:46,000 --> 00:17:50,960
actually think of this architecture as

00:17:48,480 --> 00:17:52,559
run length encoding the image so you you

00:17:50,960 --> 00:17:54,320
have to upload less data and compute

00:17:52,559 --> 00:17:56,160
less data in the first place because you

00:17:54,320 --> 00:17:58,960
inherently skip all the work of the

00:17:56,160 --> 00:17:58,960
solid spans

00:17:59,120 --> 00:18:04,000
and this was um this had much better

00:18:01,600 --> 00:18:06,880
performance than i expected from how

00:18:04,000 --> 00:18:08,000
kind of weird of a design and how also

00:18:06,880 --> 00:18:12,080
how simple it is

00:18:08,000 --> 00:18:15,039
so for for complex scenes like the

00:18:12,080 --> 00:18:16,640
the there's a tiger scene that this is a

00:18:15,039 --> 00:18:18,880
this is a clipping of

00:18:16,640 --> 00:18:20,400
i was getting times that were 10 times

00:18:18,880 --> 00:18:22,400
as fast as cairo which is a single

00:18:20,400 --> 00:18:26,480
threaded cpu on the renderer

00:18:22,400 --> 00:18:29,039
so that was really promising but it has

00:18:26,480 --> 00:18:30,799
some downsides basically it doesn't

00:18:29,039 --> 00:18:34,160
handle

00:18:30,799 --> 00:18:35,039
um humongous solid spaces very well so

00:18:34,160 --> 00:18:37,840
if you're

00:18:35,039 --> 00:18:39,919
rendering a full screen rectangle the

00:18:37,840 --> 00:18:41,520
gpu gets stressed out by how many lines

00:18:39,919 --> 00:18:43,840
you're trying to shovel through it

00:18:41,520 --> 00:18:45,520
and it is about five times slower than

00:18:43,840 --> 00:18:48,640
just doing it with two rectangles

00:18:45,520 --> 00:18:48,880
so i i tweaked this approach and i ended

00:18:48,640 --> 00:18:51,760
up

00:18:48,880 --> 00:18:53,360
closer to this is actually very similar

00:18:51,760 --> 00:18:55,360
to what pathfinder does but it

00:18:53,360 --> 00:18:57,520
basically does more on the cpu whereas

00:18:55,360 --> 00:19:01,679
pathfinder does more on the gpu

00:18:57,520 --> 00:19:04,240
basically i break the shape down into

00:19:01,679 --> 00:19:05,600
edge edge tiles and spans so rather than

00:19:04,240 --> 00:19:08,320
edge pixels in it and

00:19:05,600 --> 00:19:09,280
solid spans i have eight by eight edge

00:19:08,320 --> 00:19:12,000
tiles

00:19:09,280 --> 00:19:13,039
and then solid 8 by n spans in the

00:19:12,000 --> 00:19:15,520
middle

00:19:13,039 --> 00:19:16,400
and then i pack these into an atlas

00:19:15,520 --> 00:19:19,440
texture

00:19:16,400 --> 00:19:22,160
upload that to the gpu and render it all

00:19:19,440 --> 00:19:23,280
using using triangles to make up those

00:19:22,160 --> 00:19:26,160
rectangles

00:19:23,280 --> 00:19:27,360
this is an example texture atlas for

00:19:26,160 --> 00:19:29,120
this is what it looks like

00:19:27,360 --> 00:19:30,480
for the tiger this is all of those

00:19:29,120 --> 00:19:34,480
little 8x8

00:19:30,480 --> 00:19:38,320
chunks put in order in the atlas

00:19:34,480 --> 00:19:40,480
so so that's how ochre works

00:19:38,320 --> 00:19:41,600
and um i'm going to get a little bit

00:19:40,480 --> 00:19:43,760
more into

00:19:41,600 --> 00:19:44,799
how it how it works from an api design

00:19:43,760 --> 00:19:49,200
standpoint

00:19:44,799 --> 00:19:51,760
so basically i i wanted ochre to be

00:19:49,200 --> 00:19:52,400
usable as a component rather than kind

00:19:51,760 --> 00:19:54,640
of

00:19:52,400 --> 00:19:55,760
taking over the design of your program

00:19:54,640 --> 00:19:59,440
if you use it

00:19:55,760 --> 00:20:02,480
so when when it builds these

00:19:59,440 --> 00:20:03,760
tiles and spans the what it does is it

00:20:02,480 --> 00:20:05,760
just

00:20:03,760 --> 00:20:07,440
builds that data for you and then you

00:20:05,760 --> 00:20:08,960
can take that data

00:20:07,440 --> 00:20:12,640
and you can upload it yourself to the

00:20:08,960 --> 00:20:15,280
gpu so that lets you

00:20:12,640 --> 00:20:15,919
um whether you're on directx or opengl

00:20:15,280 --> 00:20:17,520
or metal

00:20:15,919 --> 00:20:19,120
whether you have an existing game engine

00:20:17,520 --> 00:20:21,760
you want to use or

00:20:19,120 --> 00:20:24,000
you're using some proprietary console

00:20:21,760 --> 00:20:27,600
api that i couldn't have even

00:20:24,000 --> 00:20:29,760
foreseen or added to ocr as

00:20:27,600 --> 00:20:31,760
as an api you can just add the support

00:20:29,760 --> 00:20:33,600
yourself very straightforwardly using

00:20:31,760 --> 00:20:35,840
some simple operations

00:20:33,600 --> 00:20:35,840
and

00:20:36,640 --> 00:20:41,120
and it will still use the gpu

00:20:40,159 --> 00:20:44,640
efficiently

00:20:41,120 --> 00:20:46,240
but all the work um

00:20:44,640 --> 00:20:49,360
all the work to build this data is done

00:20:46,240 --> 00:20:52,240
for you by ocr and then

00:20:49,360 --> 00:20:53,919
so i like to i like to think of this as

00:20:52,240 --> 00:20:58,000
humble library design

00:20:53,919 --> 00:20:58,880
where you you respect what the user

00:20:58,000 --> 00:21:01,600
wants

00:20:58,880 --> 00:21:02,320
to do the user knows best their platform

00:21:01,600 --> 00:21:04,559
and

00:21:02,320 --> 00:21:05,679
performance things performance

00:21:04,559 --> 00:21:08,960
constraints

00:21:05,679 --> 00:21:10,880
and um you just make a library that

00:21:08,960 --> 00:21:13,360
that can serve as a component alongside

00:21:10,880 --> 00:21:15,760
the other components of an application

00:21:13,360 --> 00:21:17,200
rather than kind of trying to take over

00:21:15,760 --> 00:21:18,640
and insist on things being done a

00:21:17,200 --> 00:21:19,600
certain way i think that's the best way

00:21:18,640 --> 00:21:21,919
to be portable

00:21:19,600 --> 00:21:22,799
because it allows many different

00:21:21,919 --> 00:21:25,840
situations

00:21:22,799 --> 00:21:29,360
to make use of your library

00:21:25,840 --> 00:21:30,080
um and i guess one more shout out for

00:21:29,360 --> 00:21:32,240
inspiration

00:21:30,080 --> 00:21:33,440
here would be the deer m gui library

00:21:32,240 --> 00:21:36,400
which is a

00:21:33,440 --> 00:21:36,960
a ui rendering library for c plus plus

00:21:36,400 --> 00:21:38,480
which

00:21:36,960 --> 00:21:40,480
takes a very similar approach and it's

00:21:38,480 --> 00:21:41,280
been it's been used in very diverse

00:21:40,480 --> 00:21:44,640
scenarios

00:21:41,280 --> 00:21:46,960
including the the um

00:21:44,640 --> 00:21:47,760
code base for the large hadron collider

00:21:46,960 --> 00:21:50,799
i believe

00:21:47,760 --> 00:21:51,679
so um being humble like this gets you a

00:21:50,799 --> 00:21:55,520
long way

00:21:51,679 --> 00:21:57,600
anyway so that's how ochre works and

00:21:55,520 --> 00:22:00,640
that's why i made it the way i made it

00:21:57,600 --> 00:22:03,360
um it's on github i'm hoping to

00:22:00,640 --> 00:22:12,480
release it on crates that i owe fairly

00:22:03,360 --> 00:22:14,559
soon anyway thank you for listening

00:22:12,480 --> 00:22:14,559

YouTube URL: https://www.youtube.com/watch?v=9MAC3bojeyo


