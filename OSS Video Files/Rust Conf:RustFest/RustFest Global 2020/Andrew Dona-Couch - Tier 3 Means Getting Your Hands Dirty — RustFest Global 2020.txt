Title: Andrew Dona-Couch - Tier 3 Means Getting Your Hands Dirty â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	My simple embedded Rust code was broken, and I couldn't figure out why. Let me walk you through what I did to find & fix a bug in the compiler. We'll take a whirlwind tour, pausing at each step for a gentle introduction to the tools and ideas, until we finally learn to speak directly to the machine.

More at https://rustfest.global/session/14-tier-3-means-getting-your-hands-dirty/
Captions: 
	00:00:02,800 --> 00:00:07,200
andrew donah couch

00:00:04,560 --> 00:00:08,800
will now go to the farthest reach of

00:00:07,200 --> 00:00:11,120
trust to show

00:00:08,800 --> 00:00:12,240
if you're willing to get your coding

00:00:11,120 --> 00:00:17,920
feed wet

00:00:12,240 --> 00:00:17,920
tire 3 has some room to grow

00:00:18,160 --> 00:00:23,519
good afternoon welcome to russ fest

00:00:21,840 --> 00:00:25,279
global 2020

00:00:23,519 --> 00:00:27,119
my name is andrew dona couch and this

00:00:25,279 --> 00:00:29,119
talk is tier three means getting your

00:00:27,119 --> 00:00:31,519
hands dirty

00:00:29,119 --> 00:00:32,960
i'm a freelance software developer i'm a

00:00:31,519 --> 00:00:35,440
big fan of rust

00:00:32,960 --> 00:00:36,160
and i love playing around with hardware

00:00:35,440 --> 00:00:38,480
uh

00:00:36,160 --> 00:00:40,000
and recently hardware and rust you can

00:00:38,480 --> 00:00:43,600
find me on social media

00:00:40,000 --> 00:00:45,920
generally at couchand and

00:00:43,600 --> 00:00:46,800
as was previously mentioned this talk is

00:00:45,920 --> 00:00:49,520
about

00:00:46,800 --> 00:00:50,960
my experiences finding and fixing a bug

00:00:49,520 --> 00:00:53,199
in the rust compiler

00:00:50,960 --> 00:00:55,039
within the rest compiler within a

00:00:53,199 --> 00:00:58,160
library used by rust

00:00:55,039 --> 00:00:59,039
called llvm and this bug only comes up

00:00:58,160 --> 00:01:02,160
on the avr

00:00:59,039 --> 00:01:05,000
platform so what's avr

00:01:02,160 --> 00:01:06,799
avr is a series of 8-bit

00:01:05,000 --> 00:01:09,920
microcontrollers

00:01:06,799 --> 00:01:12,000
these are tiny computers they are an

00:01:09,920 --> 00:01:14,320
older series and and so they're cheap

00:01:12,000 --> 00:01:17,520
and they're very hacker friendly

00:01:14,320 --> 00:01:19,040
and support for avr was mainlined into

00:01:17,520 --> 00:01:23,200
the rust compiler this

00:01:19,040 --> 00:01:25,040
past summer into rust and llvm

00:01:23,200 --> 00:01:27,680
thanks to a significant amount of effort

00:01:25,040 --> 00:01:31,520
by a gentleman named dylan mckay

00:01:27,680 --> 00:01:34,320
so thanks very much dylan

00:01:31,520 --> 00:01:35,040
as you can see here there are the avr

00:01:34,320 --> 00:01:38,960
line

00:01:35,040 --> 00:01:42,720
ranges my apologies

00:01:38,960 --> 00:01:46,079
i no problem my cat chewed through my

00:01:42,720 --> 00:01:50,240
power cord and so it was not charging

00:01:46,079 --> 00:01:50,240
all right these are the risks of feline

00:01:50,880 --> 00:01:54,079
so just to briefly go over these ground

00:01:53,439 --> 00:01:55,840
rules again

00:01:54,079 --> 00:01:57,280
i i'm going to try to show everybody

00:01:55,840 --> 00:02:00,640
respect today hopefully

00:01:57,280 --> 00:02:02,960
i uh succeed at that we'll also

00:02:00,640 --> 00:02:04,640
be talking about things that i'm

00:02:02,960 --> 00:02:08,239
relatively an amateur about

00:02:04,640 --> 00:02:09,360
and so uh bear with me uh and and

00:02:08,239 --> 00:02:10,800
most importantly i'm gonna be

00:02:09,360 --> 00:02:12,319
oversimplifying because i'd like to

00:02:10,800 --> 00:02:14,959
cover a lot of material

00:02:12,319 --> 00:02:16,800
and uh due to those technical issues

00:02:14,959 --> 00:02:20,560
we're of course now a few minutes

00:02:16,800 --> 00:02:23,840
um behind from our from our plan

00:02:20,560 --> 00:02:25,440
all right so with that in mind what are

00:02:23,840 --> 00:02:25,840
these simplified models that i'm going

00:02:25,440 --> 00:02:28,800
to be

00:02:25,840 --> 00:02:29,360
talking about all right so the first

00:02:28,800 --> 00:02:31,200
example

00:02:29,360 --> 00:02:33,280
is a black box model we'll be talking

00:02:31,200 --> 00:02:35,120
about some complex system

00:02:33,280 --> 00:02:37,120
take this rube goldberg self-operating

00:02:35,120 --> 00:02:37,920
napkin and we're going to put this

00:02:37,120 --> 00:02:41,280
system

00:02:37,920 --> 00:02:43,200
inside of a box and the reason we do

00:02:41,280 --> 00:02:44,160
that is because we want to analyze this

00:02:43,200 --> 00:02:45,920
complex system

00:02:44,160 --> 00:02:47,840
not in terms of the details of the

00:02:45,920 --> 00:02:51,040
insides the implementation

00:02:47,840 --> 00:02:52,239
but rather in terms of its inputs and

00:02:51,040 --> 00:02:54,879
its outputs

00:02:52,239 --> 00:02:56,239
its relationship to the outside world

00:02:54,879 --> 00:02:58,720
now that's a bit abstract so

00:02:56,239 --> 00:03:00,000
let's look at a couple examples we can

00:02:58,720 --> 00:03:02,879
think of a computer as

00:03:00,000 --> 00:03:03,519
being a box and the input to our

00:03:02,879 --> 00:03:06,800
computer

00:03:03,519 --> 00:03:09,920
is some kind of program

00:03:06,800 --> 00:03:11,760
and the output uh we'll we'll say

00:03:09,920 --> 00:03:12,959
we're hand waving a bit here but that we

00:03:11,760 --> 00:03:17,440
have two outputs

00:03:12,959 --> 00:03:17,440
computation and effects on the world

00:03:17,760 --> 00:03:21,680
all right this is a technical conference

00:03:19,280 --> 00:03:22,720
so let's look inside the box and we find

00:03:21,680 --> 00:03:26,080
that there are four

00:03:22,720 --> 00:03:27,840
additional boxes there's uh

00:03:26,080 --> 00:03:29,360
we'll talk about each of these four in

00:03:27,840 --> 00:03:31,519
turn a little bit later

00:03:29,360 --> 00:03:32,400
but right now i'll give you just a brief

00:03:31,519 --> 00:03:34,640
sense of

00:03:32,400 --> 00:03:36,560
of what they what they are so on the

00:03:34,640 --> 00:03:38,720
left we see we have

00:03:36,560 --> 00:03:40,400
a register we have a set of registers

00:03:38,720 --> 00:03:42,560
and some memory

00:03:40,400 --> 00:03:43,680
and on the right our two boxes are

00:03:42,560 --> 00:03:46,879
called processor

00:03:43,680 --> 00:03:49,440
and peripherals so just to get a

00:03:46,879 --> 00:03:50,959
vague idea of what each of these are

00:03:49,440 --> 00:03:53,200
we'll use

00:03:50,959 --> 00:03:54,959
the metaphor of an old school paper

00:03:53,200 --> 00:03:57,360
pushing office

00:03:54,959 --> 00:03:59,599
and you have someone sitting at a desk

00:03:57,360 --> 00:04:01,120
moving moving paperwork around

00:03:59,599 --> 00:04:03,200
and that person is the brains of the

00:04:01,120 --> 00:04:05,200
operation and that's analogous to the

00:04:03,200 --> 00:04:07,280
processor

00:04:05,200 --> 00:04:08,720
the desk in front of them that's covered

00:04:07,280 --> 00:04:10,879
with the paperwork that they're

00:04:08,720 --> 00:04:12,799
currently working on is something like

00:04:10,879 --> 00:04:15,840
the registers

00:04:12,799 --> 00:04:18,560
the memory is a bit like a file cabinet

00:04:15,840 --> 00:04:20,239
that holds the paperwork that they need

00:04:18,560 --> 00:04:22,720
they need to have access to but they

00:04:20,239 --> 00:04:25,440
don't need it immediately at hand

00:04:22,720 --> 00:04:27,120
and finally the peripherals in this

00:04:25,440 --> 00:04:29,600
metaphor are something like an

00:04:27,120 --> 00:04:30,720
intercom sitting on top of the desk

00:04:29,600 --> 00:04:32,800
where

00:04:30,720 --> 00:04:34,160
if we need to connect with the outside

00:04:32,800 --> 00:04:34,960
world if we need to interface with the

00:04:34,160 --> 00:04:37,600
outside world

00:04:34,960 --> 00:04:38,720
ask for a cup of coffee we can push the

00:04:37,600 --> 00:04:43,040
button on the intercom

00:04:38,720 --> 00:04:44,639
and and request a support

00:04:43,040 --> 00:04:46,639
all right so let's connect our arrows

00:04:44,639 --> 00:04:49,919
from earlier so we said

00:04:46,639 --> 00:04:51,440
that the computation comes from

00:04:49,919 --> 00:04:53,360
we said the processor is the brains of

00:04:51,440 --> 00:04:55,120
the computer and so the computation can

00:04:53,360 --> 00:04:57,120
be thought of as coming from there

00:04:55,120 --> 00:04:59,040
and likewise we said the peripherals are

00:04:57,120 --> 00:05:00,160
the interface to the outside world so we

00:04:59,040 --> 00:05:01,759
can think of our

00:05:00,160 --> 00:05:03,840
effects on the world as coming from

00:05:01,759 --> 00:05:06,960
those peripherals

00:05:03,840 --> 00:05:08,639
and then the program will we will load

00:05:06,960 --> 00:05:11,199
that into memory

00:05:08,639 --> 00:05:14,160
and then we will go ahead and start

00:05:11,199 --> 00:05:14,160
executing from there

00:05:15,199 --> 00:05:19,360
all right let's look at another example

00:05:17,600 --> 00:05:21,600
of a black box

00:05:19,360 --> 00:05:23,199
this one is a compiler and we can think

00:05:21,600 --> 00:05:25,440
of a compiler as a box

00:05:23,199 --> 00:05:26,960
and the program is the input to the

00:05:25,440 --> 00:05:29,199
compiler

00:05:26,960 --> 00:05:31,199
and since this is a rust conference our

00:05:29,199 --> 00:05:35,120
compiler presumably is rust c

00:05:31,199 --> 00:05:38,639
the rust compiler and our program is the

00:05:35,120 --> 00:05:40,800
rust source code for the rest source

00:05:38,639 --> 00:05:42,560
code for our program

00:05:40,800 --> 00:05:44,160
all right and we can look at the output

00:05:42,560 --> 00:05:45,440
of our compiler and

00:05:44,160 --> 00:05:47,680
well now we've reached a really

00:05:45,440 --> 00:05:50,720
interesting point what

00:05:47,680 --> 00:05:53,919
what is the output of this compiler

00:05:50,720 --> 00:05:56,800
so again let's not define it based on

00:05:53,919 --> 00:06:00,240
its intrinsic properties but rather use

00:05:56,800 --> 00:06:00,240
another simplifying model

00:06:00,479 --> 00:06:04,319
so here we'll define this output by how

00:06:02,800 --> 00:06:07,520
we use it

00:06:04,319 --> 00:06:09,759
and we'll see that we use it by

00:06:07,520 --> 00:06:11,039
passing it as the input to our computer

00:06:09,759 --> 00:06:13,120
box

00:06:11,039 --> 00:06:15,520
from previous and we already said that

00:06:13,120 --> 00:06:17,199
that input is a program

00:06:15,520 --> 00:06:19,520
so we've now determined that this

00:06:17,199 --> 00:06:21,600
compiler is a box

00:06:19,520 --> 00:06:23,759
that it's the compiler something that

00:06:21,600 --> 00:06:26,800
takes a program as input

00:06:23,759 --> 00:06:28,800
and produces a program as output now

00:06:26,800 --> 00:06:30,319
this is a bit confusing so we'll be more

00:06:28,800 --> 00:06:33,440
specific about this

00:06:30,319 --> 00:06:36,240
we have two different representations

00:06:33,440 --> 00:06:37,199
of the same program and the input

00:06:36,240 --> 00:06:40,240
representation

00:06:37,199 --> 00:06:42,000
we already called it source code and the

00:06:40,240 --> 00:06:44,560
output representation

00:06:42,000 --> 00:06:46,880
is the one that's meant for the machine

00:06:44,560 --> 00:06:50,000
the computer machine and so we call it

00:06:46,880 --> 00:06:52,000
machine code all right

00:06:50,000 --> 00:06:53,840
so again this is a technical conference

00:06:52,000 --> 00:06:57,280
let's look inside this compiler

00:06:53,840 --> 00:07:01,599
and we see two more boxes we have

00:06:57,280 --> 00:07:04,720
a rust c front end and an llvm back end

00:07:01,599 --> 00:07:08,160
now rest c we know is the rust compiler

00:07:04,720 --> 00:07:09,440
and so that term is not new but llvm

00:07:08,160 --> 00:07:12,560
might be new

00:07:09,440 --> 00:07:16,479
so what is this llvm thing

00:07:12,560 --> 00:07:19,199
llvm is a library that

00:07:16,479 --> 00:07:19,599
uh it contains all of the common parts

00:07:19,199 --> 00:07:21,680
of

00:07:19,599 --> 00:07:23,919
compilers things that are shared among

00:07:21,680 --> 00:07:26,240
uh compilers no matter

00:07:23,919 --> 00:07:28,160
what language they're for it has things

00:07:26,240 --> 00:07:30,800
like optimizations

00:07:28,160 --> 00:07:32,080
um code generation uh for the for the

00:07:30,800 --> 00:07:35,039
machine code

00:07:32,080 --> 00:07:36,000
and and so forth uh as suggested by that

00:07:35,039 --> 00:07:39,120
previous slide

00:07:36,000 --> 00:07:42,720
our back end uh in for the rust compiler

00:07:39,120 --> 00:07:44,160
is llvm uh but the llvm library serves

00:07:42,720 --> 00:07:47,280
as the back end for

00:07:44,160 --> 00:07:48,080
many other languages including julia and

00:07:47,280 --> 00:07:51,280
swift

00:07:48,080 --> 00:07:55,280
and and many others and notably

00:07:51,280 --> 00:07:58,080
the s the silang clang compiler

00:07:55,280 --> 00:07:59,520
which is part of the llvm project is the

00:07:58,080 --> 00:08:02,800
system c compiler

00:07:59,520 --> 00:08:05,919
on on the macintosh

00:08:02,800 --> 00:08:08,479
okay so looking at our compiler

00:08:05,919 --> 00:08:09,440
model again and let's once again connect

00:08:08,479 --> 00:08:11,759
our arrows

00:08:09,440 --> 00:08:13,440
for our input and output and here we

00:08:11,759 --> 00:08:16,080
just extend them inwards

00:08:13,440 --> 00:08:17,919
and connect to the source code input to

00:08:16,080 --> 00:08:20,639
the rest c front end

00:08:17,919 --> 00:08:21,919
and we the the source code is the input

00:08:20,639 --> 00:08:25,280
to our front end

00:08:21,919 --> 00:08:27,840
and the output of our llvm back end is

00:08:25,280 --> 00:08:27,840
our machine code

00:08:29,520 --> 00:08:34,399
and that leaves one big gap

00:08:32,640 --> 00:08:36,640
what is it that's between these two

00:08:34,399 --> 00:08:39,760
boxes well

00:08:36,640 --> 00:08:41,839
it's another representation of a program

00:08:39,760 --> 00:08:44,000
and because it is intermediate between

00:08:41,839 --> 00:08:47,360
the source and machine code

00:08:44,000 --> 00:08:50,480
the llvm authors have decided to call it

00:08:47,360 --> 00:08:52,640
intermediate representation it's

00:08:50,480 --> 00:08:55,920
frequently abbreviated ir

00:08:52,640 --> 00:08:59,200
so we'll see frequently the the term

00:08:55,920 --> 00:09:02,399
llvm ir and that's this

00:08:59,200 --> 00:09:04,959
common currency between the rest c

00:09:02,399 --> 00:09:06,560
front end or the front end for any

00:09:04,959 --> 00:09:11,440
compiler that might be using

00:09:06,560 --> 00:09:11,440
llvm and the llvm backend

00:09:12,160 --> 00:09:16,880
all right it's about time that i tell

00:09:13,839 --> 00:09:19,839
you about my project

00:09:16,880 --> 00:09:20,959
so i was working on something that is

00:09:19,839 --> 00:09:24,160
more or less the

00:09:20,959 --> 00:09:25,839
hello world of embedded the

00:09:24,160 --> 00:09:27,440
the hello world of embedded is it's

00:09:25,839 --> 00:09:31,120
sometimes called blinky

00:09:27,440 --> 00:09:32,880
and the idea here is you take a

00:09:31,120 --> 00:09:34,640
microcontroller so here we have a

00:09:32,880 --> 00:09:37,839
breadboard with a

00:09:34,640 --> 00:09:41,680
80 tiny 85 microcontroller

00:09:37,839 --> 00:09:44,720
that's a particular avr microcontroller

00:09:41,680 --> 00:09:50,000
and we will go ahead and connect it

00:09:44,720 --> 00:09:52,959
to an led an led is like a tiny light

00:09:50,000 --> 00:09:54,080
so we have our tiny computer wired up to

00:09:52,959 --> 00:09:55,680
our tiny light

00:09:54,080 --> 00:09:57,440
and we write a program for the

00:09:55,680 --> 00:09:59,040
microcontroller

00:09:57,440 --> 00:10:01,200
and that program will make the light

00:09:59,040 --> 00:10:04,880
turn on and off

00:10:01,200 --> 00:10:05,519
and on and off and on and off and in

00:10:04,880 --> 00:10:07,839
embedded

00:10:05,519 --> 00:10:08,959
you tend to write things as an infinite

00:10:07,839 --> 00:10:11,600
loop so

00:10:08,959 --> 00:10:14,000
we're going to turn on and off our light

00:10:11,600 --> 00:10:16,480
forever

00:10:14,000 --> 00:10:17,680
well i expect that like me for most of

00:10:16,480 --> 00:10:20,320
you the bulk of your

00:10:17,680 --> 00:10:21,200
software development experience is on

00:10:20,320 --> 00:10:24,800
the desktop

00:10:21,200 --> 00:10:28,160
or server perhaps modern mobile

00:10:24,800 --> 00:10:30,880
or or a web context and

00:10:28,160 --> 00:10:33,440
there are a few important things to know

00:10:30,880 --> 00:10:36,399
about writing software

00:10:33,440 --> 00:10:37,519
for an embedded context that make it

00:10:36,399 --> 00:10:41,519
slightly different

00:10:37,519 --> 00:10:41,519
from those other environments

00:10:42,160 --> 00:10:46,880
so the the most important difference is

00:10:44,560 --> 00:10:49,920
that in an embedded context you have

00:10:46,880 --> 00:10:53,200
extremely limited resources

00:10:49,920 --> 00:10:55,040
now we sort of generally probably know

00:10:53,200 --> 00:10:57,120
what that means in terms of memory

00:10:55,040 --> 00:10:58,320
processing power and so forth but let's

00:10:57,120 --> 00:11:01,360
look at again back

00:10:58,320 --> 00:11:03,279
at our computer model and see

00:11:01,360 --> 00:11:05,040
what what does this limitation in

00:11:03,279 --> 00:11:08,880
resources imply

00:11:05,040 --> 00:11:08,880
for each of these components

00:11:08,959 --> 00:11:13,760
so first we'll look at the processor and

00:11:11,120 --> 00:11:17,200
inside our processor we have

00:11:13,760 --> 00:11:19,519
again hand waving quite a bit here some

00:11:17,200 --> 00:11:21,360
math related stuff that's going to be

00:11:19,519 --> 00:11:24,079
doing arithmetic perhaps

00:11:21,360 --> 00:11:24,640
and some program control stuff that lets

00:11:24,079 --> 00:11:28,399
us do

00:11:24,640 --> 00:11:31,440
loops and conditional jumps and

00:11:28,399 --> 00:11:32,880
moving around in our program and the big

00:11:31,440 --> 00:11:34,000
difference on embedded is that it's

00:11:32,880 --> 00:11:36,800
slower

00:11:34,000 --> 00:11:37,680
and in some cases it's less capable for

00:11:36,800 --> 00:11:40,320
instance

00:11:37,680 --> 00:11:43,360
the avr devices that i'm generally

00:11:40,320 --> 00:11:44,160
developing for don't have floating point

00:11:43,360 --> 00:11:46,399
numbers

00:11:44,160 --> 00:11:48,959
so all arithmetic has to be done on

00:11:46,399 --> 00:11:48,959
integers

00:11:49,200 --> 00:11:53,519
all right let's look at another com

00:11:51,839 --> 00:11:56,320
component of our computer model

00:11:53,519 --> 00:11:57,440
the peripherals so i said previously

00:11:56,320 --> 00:12:01,839
that the peripherals

00:11:57,440 --> 00:12:05,680
are the interface to the outside world

00:12:01,839 --> 00:12:07,680
and let's look at a couple examples

00:12:05,680 --> 00:12:09,120
we can consider a video streaming

00:12:07,680 --> 00:12:12,480
application

00:12:09,120 --> 00:12:14,320
where you might need to have some access

00:12:12,480 --> 00:12:17,040
to a networking peripheral

00:12:14,320 --> 00:12:18,240
that you can use to fetch a video from

00:12:17,040 --> 00:12:20,320
some service

00:12:18,240 --> 00:12:22,399
and then once you have the video you

00:12:20,320 --> 00:12:24,639
want to show it to a user and so it you

00:12:22,399 --> 00:12:28,079
you use some sort of video hardware

00:12:24,639 --> 00:12:30,800
which would be provided by a peripheral

00:12:28,079 --> 00:12:32,639
now in an embedded context it you

00:12:30,800 --> 00:12:35,519
certainly could have a networking

00:12:32,639 --> 00:12:37,440
peripheral although it's not universal

00:12:35,519 --> 00:12:38,320
you might have a video peripheral

00:12:37,440 --> 00:12:41,519
although it's

00:12:38,320 --> 00:12:43,360
somewhat rare you tend to have

00:12:41,519 --> 00:12:45,040
access to peripherals that are much more

00:12:43,360 --> 00:12:47,760
limited

00:12:45,040 --> 00:12:49,839
for instance you could ask the computer

00:12:47,760 --> 00:12:52,160
to count to a number

00:12:49,839 --> 00:12:53,279
and then let you know when it gets to

00:12:52,160 --> 00:12:56,000
that number

00:12:53,279 --> 00:12:57,200
and this is a bit like when my kids are

00:12:56,000 --> 00:13:00,480
in the other room

00:12:57,200 --> 00:13:02,000
and i'm working on the dishes and

00:13:00,480 --> 00:13:03,600
my kids want me to come in and play with

00:13:02,000 --> 00:13:05,440
them and i tell them i need

00:13:03,600 --> 00:13:06,720
to finish up what i'm doing and so i ask

00:13:05,440 --> 00:13:09,120
them to count to 20

00:13:06,720 --> 00:13:10,959
and let me know when they get to 20. and

00:13:09,120 --> 00:13:13,760
we can do the same thing for our

00:13:10,959 --> 00:13:14,959
for our microcontroller for our for our

00:13:13,760 --> 00:13:18,160
little computer

00:13:14,959 --> 00:13:20,959
if we need to delay and

00:13:18,160 --> 00:13:23,040
perform some computation at a later

00:13:20,959 --> 00:13:24,480
point in time we can ask the computer to

00:13:23,040 --> 00:13:28,240
count to a number for us

00:13:24,480 --> 00:13:29,680
and let us know when it gets to it

00:13:28,240 --> 00:13:31,440
all right let's take a look at the

00:13:29,680 --> 00:13:34,000
memory real briefly

00:13:31,440 --> 00:13:34,560
so we're going to be talking a bit more

00:13:34,000 --> 00:13:38,079
about

00:13:34,560 --> 00:13:41,440
how this how the the stack will work but

00:13:38,079 --> 00:13:46,320
let's sort of get a a big idea

00:13:41,440 --> 00:13:48,560
of what it is inside this memory

00:13:46,320 --> 00:13:49,680
so i have this little photocollage that

00:13:48,560 --> 00:13:52,000
i made up

00:13:49,680 --> 00:13:52,800
and hopefully it is not completely

00:13:52,000 --> 00:13:55,360
misleading

00:13:52,800 --> 00:13:57,199
but we have three broadly speaking three

00:13:55,360 --> 00:13:59,279
parts of our memory

00:13:57,199 --> 00:14:01,040
um so as we said previously we're going

00:13:59,279 --> 00:14:03,040
to put our program

00:14:01,040 --> 00:14:05,040
into memory we're going to load the

00:14:03,040 --> 00:14:07,120
program into memory and so that's

00:14:05,040 --> 00:14:08,320
we see at the bottom the brick wall at

00:14:07,120 --> 00:14:10,880
the bottom is our

00:14:08,320 --> 00:14:12,240
is our program that's been loaded and

00:14:10,880 --> 00:14:16,720
any static

00:14:12,240 --> 00:14:20,399
variables any static static

00:14:16,720 --> 00:14:22,320
variables in the program would be there

00:14:20,399 --> 00:14:23,680
and then we we're going to have a heap

00:14:22,320 --> 00:14:25,760
potentially

00:14:23,680 --> 00:14:27,600
and this is a bit like the program this

00:14:25,760 --> 00:14:29,519
is where the program stores things

00:14:27,600 --> 00:14:31,279
that it may need later but it doesn't

00:14:29,519 --> 00:14:34,639
need right now

00:14:31,279 --> 00:14:37,600
it can throw them on the heap and then

00:14:34,639 --> 00:14:39,839
go back and look for them later and

00:14:37,600 --> 00:14:41,839
finally we have a stack

00:14:39,839 --> 00:14:43,360
and there are really two models that

00:14:41,839 --> 00:14:44,000
might be useful for thinking about the

00:14:43,360 --> 00:14:46,720
stack

00:14:44,000 --> 00:14:47,760
so the first model is a bit is more of

00:14:46,720 --> 00:14:51,360
an operational

00:14:47,760 --> 00:14:53,519
model and this is where you are

00:14:51,360 --> 00:14:56,480
you're thinking of the stack as sort of

00:14:53,519 --> 00:15:00,079
nested context for the program

00:14:56,480 --> 00:15:02,480
so we have a perhaps a pile of

00:15:00,079 --> 00:15:04,320
file folders on our desk um now we're

00:15:02,480 --> 00:15:05,040
departing a bit from our desk metaphor

00:15:04,320 --> 00:15:06,399
earlier

00:15:05,040 --> 00:15:09,199
because here the desk is not the

00:15:06,399 --> 00:15:11,199
registers um

00:15:09,199 --> 00:15:12,800
but but using a slightly different

00:15:11,199 --> 00:15:15,120
metaphor so

00:15:12,800 --> 00:15:15,920
i'll have perhaps i'm working on a

00:15:15,120 --> 00:15:18,480
client

00:15:15,920 --> 00:15:19,199
i have my fi the file folder open and i

00:15:18,480 --> 00:15:22,800
have some paid

00:15:19,199 --> 00:15:24,720
pages and then my boss comes in and has

00:15:22,800 --> 00:15:26,320
is holding the file folder for a client

00:15:24,720 --> 00:15:28,560
that's more critical

00:15:26,320 --> 00:15:31,839
and we open that up and set it down on

00:15:28,560 --> 00:15:33,759
top of the pile of papers on my desk

00:15:31,839 --> 00:15:35,920
and we look at that one and then the

00:15:33,759 --> 00:15:37,839
boss's boss comes in with another

00:15:35,920 --> 00:15:41,600
client's file folder and we open that up

00:15:37,839 --> 00:15:43,120
and put it at the very top of the stack

00:15:41,600 --> 00:15:45,040
and then when we finish the boss's

00:15:43,120 --> 00:15:46,959
boss's client

00:15:45,040 --> 00:15:49,120
we close that file folder up and take it

00:15:46,959 --> 00:15:52,000
away and we resume work

00:15:49,120 --> 00:15:52,720
on my boss's client and when we finish

00:15:52,000 --> 00:15:54,639
that up

00:15:52,720 --> 00:15:56,320
we close that folder up my boss leaves

00:15:54,639 --> 00:15:58,800
and i can resume work on

00:15:56,320 --> 00:16:02,000
whatever it was before that i was doing

00:15:58,800 --> 00:16:05,040
before i got interrupted

00:16:02,000 --> 00:16:06,160
uh and that's sort of the the nested

00:16:05,040 --> 00:16:09,199
context view

00:16:06,160 --> 00:16:11,120
of of the stack the sort the somewhat

00:16:09,199 --> 00:16:14,240
more physical view of the stack

00:16:11,120 --> 00:16:17,040
i like to think of as a stalactite uh

00:16:14,240 --> 00:16:18,480
growing from the roof of the cavern

00:16:17,040 --> 00:16:20,800
and and the reason i think of it this

00:16:18,480 --> 00:16:23,839
way is that in most

00:16:20,800 --> 00:16:26,720
uh in on most computers the stack

00:16:23,839 --> 00:16:27,120
begins at the very top of the memory at

00:16:26,720 --> 00:16:30,160
uh

00:16:27,120 --> 00:16:33,519
memory very the very highest address and

00:16:30,160 --> 00:16:35,519
grows downwards grows down into memory

00:16:33,519 --> 00:16:37,199
and so it's a bit like a stalactite

00:16:35,519 --> 00:16:40,800
hanging from

00:16:37,199 --> 00:16:40,800
the the roof of a cavern

00:16:41,120 --> 00:16:43,440
and

00:16:45,600 --> 00:16:50,240
uh yeah so it's a bit like a stalactite

00:16:48,240 --> 00:16:52,959
hanging from the roof of a cavern where

00:16:50,240 --> 00:16:55,360
as we add additional context our

00:16:52,959 --> 00:16:58,880
stalactite grows down

00:16:55,360 --> 00:17:02,000
and then as we resume previous context

00:16:58,880 --> 00:17:02,000
we shrink it back up

00:17:02,240 --> 00:17:06,480
and the most important difference for

00:17:04,319 --> 00:17:07,039
the memory in an embedded context is

00:17:06,480 --> 00:17:09,679
that it's

00:17:07,039 --> 00:17:11,360
much that it's that there's that it's

00:17:09,679 --> 00:17:15,039
significantly restricted you have

00:17:11,360 --> 00:17:16,160
much less memory in most embedded

00:17:15,039 --> 00:17:19,199
devices

00:17:16,160 --> 00:17:21,600
for instance the a t tiny

00:17:19,199 --> 00:17:22,959
10 that you saw on the very first

00:17:21,600 --> 00:17:26,079
picture of the avr

00:17:22,959 --> 00:17:30,080
slides that has

00:17:26,079 --> 00:17:32,559
one kilobyte of program memory

00:17:30,080 --> 00:17:35,520
um there are there are similar devices

00:17:32,559 --> 00:17:37,200
in that line that have only 512 bytes of

00:17:35,520 --> 00:17:39,600
program memory and so you

00:17:37,200 --> 00:17:42,240
must write your program so that it fits

00:17:39,600 --> 00:17:44,320
entirely in 512 bytes

00:17:42,240 --> 00:17:45,760
and that's a very significant limitation

00:17:44,320 --> 00:17:47,360
you need to keep in mind when you're

00:17:45,760 --> 00:17:49,120
developing

00:17:47,360 --> 00:17:51,280
all right for completeness let's look

00:17:49,120 --> 00:17:54,559
inside the registers

00:17:51,280 --> 00:17:55,600
and talk about what the the types of

00:17:54,559 --> 00:17:58,799
registers are

00:17:55,600 --> 00:18:02,480
so the main class of registers are

00:17:58,799 --> 00:18:06,320
is general purpose registers and this is

00:18:02,480 --> 00:18:07,760
where we store the the state that we're

00:18:06,320 --> 00:18:10,000
currently working on

00:18:07,760 --> 00:18:12,480
as i as i had mentioned previously in in

00:18:10,000 --> 00:18:14,799
the desk the desk metaphor

00:18:12,480 --> 00:18:16,799
um and we can sort of think of the

00:18:14,799 --> 00:18:20,640
general purpose registers as a

00:18:16,799 --> 00:18:24,000
pile of etch-a-sketches on a table

00:18:20,640 --> 00:18:24,880
and anytime that we need to ask the

00:18:24,000 --> 00:18:27,600
processor

00:18:24,880 --> 00:18:29,520
to do work for us we have to write down

00:18:27,600 --> 00:18:32,880
the numbers on the etch-a-sketches

00:18:29,520 --> 00:18:35,760
and give them to the processor so

00:18:32,880 --> 00:18:36,320
if we need if we want to if we want to

00:18:35,760 --> 00:18:38,559
provide

00:18:36,320 --> 00:18:40,880
some numbers for the processor to work

00:18:38,559 --> 00:18:43,919
on we need to go to our table

00:18:40,880 --> 00:18:46,960
and pick up an etch a sketch and

00:18:43,919 --> 00:18:48,799
and ideally find a blank one but if we

00:18:46,960 --> 00:18:51,520
don't find a blank one

00:18:48,799 --> 00:18:52,640
we pick up one that's in use we write

00:18:51,520 --> 00:18:54,799
down somewhere

00:18:52,640 --> 00:18:56,400
whatever number is on it and shake it to

00:18:54,799 --> 00:18:58,960
erase it

00:18:56,400 --> 00:19:01,039
and then we put our the the value of of

00:18:58,960 --> 00:19:03,520
our our number on it

00:19:01,039 --> 00:19:05,919
and we need to write it down because we

00:19:03,520 --> 00:19:08,960
probably were using that previously

00:19:05,919 --> 00:19:09,600
and so when we're done with with

00:19:08,960 --> 00:19:11,840
whatever

00:19:09,600 --> 00:19:13,840
we're doing immediately we want to

00:19:11,840 --> 00:19:14,960
restore that edge of sketch to its

00:19:13,840 --> 00:19:17,679
previous state

00:19:14,960 --> 00:19:19,120
and so we want to know what was on it

00:19:17,679 --> 00:19:22,000
before we erase it

00:19:19,120 --> 00:19:22,880
so that we can put it back on and this

00:19:22,000 --> 00:19:24,880
is a process

00:19:22,880 --> 00:19:25,919
that's referred to as clobbering the

00:19:24,880 --> 00:19:27,760
registers

00:19:25,919 --> 00:19:29,520
so when you're using a register that's

00:19:27,760 --> 00:19:32,960
already in use

00:19:29,520 --> 00:19:34,400
you clobber it and if it's important for

00:19:32,960 --> 00:19:35,440
you to maintain what was in it

00:19:34,400 --> 00:19:38,160
previously

00:19:35,440 --> 00:19:40,720
then you have to save and restore that

00:19:38,160 --> 00:19:40,720
register

00:19:40,960 --> 00:19:44,720
all right we also have a few special

00:19:42,720 --> 00:19:46,240
purpose registers and there are lots of

00:19:44,720 --> 00:19:47,760
these but there are two

00:19:46,240 --> 00:19:49,760
there are only two that we will talk

00:19:47,760 --> 00:19:51,360
about today

00:19:49,760 --> 00:19:52,880
and the first one is called the status

00:19:51,360 --> 00:19:54,799
register this

00:19:52,880 --> 00:19:57,280
tells you what the processor has been up

00:19:54,799 --> 00:19:59,919
to recently

00:19:57,280 --> 00:20:01,280
for instance if you do some math and the

00:19:59,919 --> 00:20:02,880
result is zero

00:20:01,280 --> 00:20:05,120
the status register will tell you that

00:20:02,880 --> 00:20:08,159
the last the last math you did

00:20:05,120 --> 00:20:10,640
the result is zero

00:20:08,159 --> 00:20:11,919
another important status register we'll

00:20:10,640 --> 00:20:15,840
talk about later today

00:20:11,919 --> 00:20:18,559
is a frame pointer so the frame pointer

00:20:15,840 --> 00:20:19,039
always points at the current function

00:20:18,559 --> 00:20:22,720
stack

00:20:19,039 --> 00:20:26,240
frame it points at where on the stack

00:20:22,720 --> 00:20:29,600
we can find the local variables

00:20:26,240 --> 00:20:31,120
for the current function and like i said

00:20:29,600 --> 00:20:32,880
there are many other special purpose

00:20:31,120 --> 00:20:35,840
registers that that we won't be talking

00:20:32,880 --> 00:20:35,840
about today

00:20:36,559 --> 00:20:40,240
all right so that is the first

00:20:38,720 --> 00:20:43,440
difference

00:20:40,240 --> 00:20:43,840
we took that opportunity to also expand

00:20:43,440 --> 00:20:46,559
our

00:20:43,840 --> 00:20:47,200
computer model a bit but remember the

00:20:46,559 --> 00:20:48,960
the first

00:20:47,200 --> 00:20:50,559
significant difference for developing

00:20:48,960 --> 00:20:53,280
and embedded is that we have these very

00:20:50,559 --> 00:20:56,559
tight resource constraints

00:20:53,280 --> 00:20:58,480
alright the second difference is that

00:20:56,559 --> 00:21:01,200
in an embedded context we're working in

00:20:58,480 --> 00:21:04,799
a it's a no standard environment

00:21:01,200 --> 00:21:07,919
and what this means is that you don't

00:21:04,799 --> 00:21:09,360
have access to the standard library you

00:21:07,919 --> 00:21:12,640
do have access

00:21:09,360 --> 00:21:14,240
to the core library the rest core

00:21:12,640 --> 00:21:16,159
library

00:21:14,240 --> 00:21:17,760
and this is the parts of the standard

00:21:16,159 --> 00:21:20,559
library that

00:21:17,760 --> 00:21:21,760
don't require memory allocations and

00:21:20,559 --> 00:21:24,960
don't require

00:21:21,760 --> 00:21:26,559
platform support so

00:21:24,960 --> 00:21:28,880
with the core library we don't have

00:21:26,559 --> 00:21:31,440
access to collections like a vector

00:21:28,880 --> 00:21:32,960
or a hash map and we don't have access

00:21:31,440 --> 00:21:35,600
to

00:21:32,960 --> 00:21:36,559
operating system things like like a file

00:21:35,600 --> 00:21:39,200
system

00:21:36,559 --> 00:21:41,919
but we still do have a lot of the the

00:21:39,200 --> 00:21:45,200
basic functionality

00:21:41,919 --> 00:21:48,559
in addition to no standard context

00:21:45,200 --> 00:21:50,400
we are working in a panic abort model

00:21:48,559 --> 00:21:51,919
frequently and this means this is

00:21:50,400 --> 00:21:53,679
because

00:21:51,919 --> 00:21:56,240
unwinding the stack in the case of a

00:21:53,679 --> 00:21:57,600
panic is very expensive in terms of

00:21:56,240 --> 00:22:01,039
memory use

00:21:57,600 --> 00:22:02,880
and processor and so

00:22:01,039 --> 00:22:04,400
in general when developing for an

00:22:02,880 --> 00:22:07,200
embedded context

00:22:04,400 --> 00:22:08,159
we abort on panic rather than unwind the

00:22:07,200 --> 00:22:10,400
stack

00:22:08,159 --> 00:22:11,840
and so this just leads into the third

00:22:10,400 --> 00:22:13,360
difference which is

00:22:11,840 --> 00:22:15,440
limitations on debugging and

00:22:13,360 --> 00:22:18,960
observability if we can't

00:22:15,440 --> 00:22:23,120
unwind a panic then if a panic occurs

00:22:18,960 --> 00:22:27,440
we have a lot a lot fewer clues about

00:22:23,120 --> 00:22:29,200
what has caused the panic to happen

00:22:27,440 --> 00:22:31,039
but there are other debugging and

00:22:29,200 --> 00:22:34,240
observability limitations

00:22:31,039 --> 00:22:35,039
so i'm vaguely aware that there are

00:22:34,240 --> 00:22:38,000
these

00:22:35,039 --> 00:22:38,880
professional in-circuit debugger systems

00:22:38,000 --> 00:22:41,760
there's a

00:22:38,880 --> 00:22:43,200
standard called jtag that i'm aware

00:22:41,760 --> 00:22:45,840
exists

00:22:43,200 --> 00:22:46,559
but i've never used these myself my

00:22:45,840 --> 00:22:48,400
impression

00:22:46,559 --> 00:22:50,240
which might be a naive express

00:22:48,400 --> 00:22:51,280
impression but my my understanding is

00:22:50,240 --> 00:22:55,440
that they're probably

00:22:51,280 --> 00:22:58,640
expensive hard to set up and

00:22:55,440 --> 00:23:01,440
probably windows only systems

00:22:58,640 --> 00:23:02,720
so i've never really looked into them so

00:23:01,440 --> 00:23:05,360
what that means is

00:23:02,720 --> 00:23:06,720
in general when i'm developing for an

00:23:05,360 --> 00:23:10,000
embedded context

00:23:06,720 --> 00:23:11,200
i'm using a much more naive debugging

00:23:10,000 --> 00:23:14,159
methodology

00:23:11,200 --> 00:23:14,880
now i tend to like to write my software

00:23:14,159 --> 00:23:19,039
using

00:23:14,880 --> 00:23:21,039
see lots of unit tests with

00:23:19,039 --> 00:23:22,080
really good making sure that i have a

00:23:21,039 --> 00:23:24,880
really good mental model

00:23:22,080 --> 00:23:25,440
of everything that's going on but when

00:23:24,880 --> 00:23:28,720
i'm

00:23:25,440 --> 00:23:31,840
developing for embedded i often start

00:23:28,720 --> 00:23:33,520
working on a project with with the like

00:23:31,840 --> 00:23:35,679
this meme shows of

00:23:33,520 --> 00:23:38,000
my code doesn't work i have no idea why

00:23:35,679 --> 00:23:40,080
and i changed something about it

00:23:38,000 --> 00:23:43,600
and then it works and i have no idea why

00:23:40,080 --> 00:23:45,360
and and it takes much longer

00:23:43,600 --> 00:23:46,720
for when developing and embedded for me

00:23:45,360 --> 00:23:48,720
to to really

00:23:46,720 --> 00:23:51,840
understand what it is that's making it

00:23:48,720 --> 00:23:51,840
work and not work

00:23:52,240 --> 00:23:55,919
one third option that i've recently

00:23:54,559 --> 00:23:59,520
started looking at

00:23:55,919 --> 00:24:03,120
for debugging uh in an embedded context

00:23:59,520 --> 00:24:05,840
is simulating so now because these

00:24:03,120 --> 00:24:07,600
embedded devices are so limited it's

00:24:05,840 --> 00:24:11,679
actually quite easy to

00:24:07,600 --> 00:24:15,120
run a program on your desktop

00:24:11,679 --> 00:24:18,400
computer that

00:24:15,120 --> 00:24:19,919
simulates the entirety of the embedded

00:24:18,400 --> 00:24:22,240
device

00:24:19,919 --> 00:24:23,840
so there's a wonderful one for avr

00:24:22,240 --> 00:24:27,120
that's an open source project

00:24:23,840 --> 00:24:32,080
called simavr

00:24:27,120 --> 00:24:35,279
and it allows you to

00:24:32,080 --> 00:24:38,640
run simulation of your

00:24:35,279 --> 00:24:40,159
avr program and you it can produce these

00:24:38,640 --> 00:24:43,200
trace files as output

00:24:40,159 --> 00:24:43,840
which you can load into a gtk wave or

00:24:43,200 --> 00:24:48,000
other

00:24:43,840 --> 00:24:50,000
trace visualizers and here we can see a

00:24:48,000 --> 00:24:51,279
trace from a program i was simulating a

00:24:50,000 --> 00:24:54,640
few weeks ago

00:24:51,279 --> 00:24:56,240
running on an avr device

00:24:54,640 --> 00:24:59,360
something else that's interesting about

00:24:56,240 --> 00:25:02,559
sim avr is we can use these trace files

00:24:59,360 --> 00:25:05,600
as inputs the trace files

00:25:02,559 --> 00:25:07,679
can represent memory inside the

00:25:05,600 --> 00:25:11,279
processor but they can also represent

00:25:07,679 --> 00:25:14,799
the state of pins on our chips so

00:25:11,279 --> 00:25:18,159
for instance my a t tiny 85 that i love

00:25:14,799 --> 00:25:20,880
has eight pins two of them are power

00:25:18,159 --> 00:25:21,600
one of them is a reset pin so we have

00:25:20,880 --> 00:25:25,039
five

00:25:21,600 --> 00:25:27,919
five general purpose pins to use and

00:25:25,039 --> 00:25:29,360
so you can see the state of those five

00:25:27,919 --> 00:25:31,440
pins and if one of them

00:25:29,360 --> 00:25:32,720
is an input you could provide a trace

00:25:31,440 --> 00:25:36,159
file that has

00:25:32,720 --> 00:25:37,760
those inputs all right so that's the

00:25:36,159 --> 00:25:39,919
debugging and observability

00:25:37,760 --> 00:25:41,039
somewhat related to that is in an

00:25:39,919 --> 00:25:43,600
embedded context

00:25:41,039 --> 00:25:46,080
your compiler is a cross compiler you're

00:25:43,600 --> 00:25:48,720
generally running the rust compiler

00:25:46,080 --> 00:25:50,559
on the same device that the program

00:25:48,720 --> 00:25:53,039
you're compiling runs on

00:25:50,559 --> 00:25:53,600
but in an embedded context you compile

00:25:53,039 --> 00:25:55,200
it on

00:25:53,600 --> 00:25:57,360
a host machine like your desktop

00:25:55,200 --> 00:25:59,440
computer and then you send that

00:25:57,360 --> 00:26:00,720
to the embedded device and run it on the

00:25:59,440 --> 00:26:03,200
embedded device

00:26:00,720 --> 00:26:04,240
and there's a whole host of nuance to

00:26:03,200 --> 00:26:06,000
this

00:26:04,240 --> 00:26:07,679
but it but it leads to things being a

00:26:06,000 --> 00:26:09,600
little trickier

00:26:07,679 --> 00:26:11,360
okay so let's get back to my project

00:26:09,600 --> 00:26:13,919
it's a simple real world

00:26:11,360 --> 00:26:16,320
button handling library real world

00:26:13,919 --> 00:26:18,480
example for a button handling library

00:26:16,320 --> 00:26:19,679
now the details are not relevant so i'm

00:26:18,480 --> 00:26:22,720
not going to get into it but

00:26:19,679 --> 00:26:25,440
this is the button handling library that

00:26:22,720 --> 00:26:28,400
i that i'm writing an example for

00:26:25,440 --> 00:26:28,720
and the thing to to note here is that

00:26:28,400 --> 00:26:31,919
it's

00:26:28,720 --> 00:26:33,760
an it uses embedded how which is a

00:26:31,919 --> 00:26:36,480
hardware abstraction layer

00:26:33,760 --> 00:26:38,559
for the embedded context so that means

00:26:36,480 --> 00:26:39,360
we can write code for an embedded

00:26:38,559 --> 00:26:42,880
context that

00:26:39,360 --> 00:26:45,440
doesn't need to know details about

00:26:42,880 --> 00:26:47,120
the about what hardware it'll run on

00:26:45,440 --> 00:26:50,320
okay so we'll go back to blinky

00:26:47,120 --> 00:26:52,880
so we're wiring up a microcontroller

00:26:50,320 --> 00:26:54,400
and we're connecting it to an led but

00:26:52,880 --> 00:26:55,919
because i'm writing this example for a

00:26:54,400 --> 00:26:59,279
button handling library

00:26:55,919 --> 00:27:02,559
i'll add a button and the idea is

00:26:59,279 --> 00:27:05,679
that i can write up my an example that

00:27:02,559 --> 00:27:06,080
when i push the button it will blink the

00:27:05,679 --> 00:27:09,360
light

00:27:06,080 --> 00:27:10,080
on and off all right so i take my

00:27:09,360 --> 00:27:12,400
existing

00:27:10,080 --> 00:27:13,360
blinky example which i've run and i know

00:27:12,400 --> 00:27:15,440
that it works

00:27:13,360 --> 00:27:16,960
and i add in a little bit of change i

00:27:15,440 --> 00:27:20,000
add in a little bit of support

00:27:16,960 --> 00:27:22,320
for the button part and i send

00:27:20,000 --> 00:27:25,120
that to my microcontroller and i try it

00:27:22,320 --> 00:27:25,120
out and

00:27:25,360 --> 00:27:32,559
nothing it doesn't work

00:27:29,200 --> 00:27:34,559
okay it's a it's a very simple example

00:27:32,559 --> 00:27:37,440
it's not much code

00:27:34,559 --> 00:27:38,080
but still there's a 95 percent chance

00:27:37,440 --> 00:27:40,240
that

00:27:38,080 --> 00:27:43,039
the it's my fault 95 percent chance the

00:27:40,240 --> 00:27:46,320
bug is in the code you just wrote

00:27:43,039 --> 00:27:48,320
but in fact i'm using unsafe uh

00:27:46,320 --> 00:27:50,880
for for this code because i'm using

00:27:48,320 --> 00:27:53,440
static mutable variables

00:27:50,880 --> 00:27:54,640
so it's actually more like a 99 chance

00:27:53,440 --> 00:27:57,039
that the bug's in

00:27:54,640 --> 00:27:58,640
my code so what are some other things

00:27:57,039 --> 00:28:01,760
that i'm thinking about

00:27:58,640 --> 00:28:06,080
well avr is tier three

00:28:01,760 --> 00:28:08,960
so tier three means that

00:28:06,080 --> 00:28:09,840
it's supported by the rest compiler but

00:28:08,960 --> 00:28:12,000
it's not

00:28:09,840 --> 00:28:13,279
supported it's not built and tested

00:28:12,000 --> 00:28:15,600
automatically by this

00:28:13,279 --> 00:28:17,279
continuous integration server and

00:28:15,600 --> 00:28:18,000
critically as you can see from the docs

00:28:17,279 --> 00:28:21,039
here

00:28:18,000 --> 00:28:23,279
it may not work so

00:28:21,039 --> 00:28:26,559
where everything's a bit up in the air

00:28:23,279 --> 00:28:26,559
when you're running on tier three

00:28:26,720 --> 00:28:31,039
and also as i mentioned previously using

00:28:28,640 --> 00:28:33,600
static mute static mutable variables

00:28:31,039 --> 00:28:34,720
and that's always unsafe and i'm not i

00:28:33,600 --> 00:28:37,120
don't know about you but

00:28:34,720 --> 00:28:38,240
i one reason i like writing rust is i

00:28:37,120 --> 00:28:40,799
can

00:28:38,240 --> 00:28:42,159
almost always ignore unsafe code and not

00:28:40,799 --> 00:28:45,360
have to think about it

00:28:42,159 --> 00:28:49,039
so i'm not entirely confident that i'm

00:28:45,360 --> 00:28:52,000
using my unsafe code correctly here

00:28:49,039 --> 00:28:52,640
one other thing to keep in mind is that

00:28:52,000 --> 00:28:54,159
avr

00:28:52,640 --> 00:28:56,320
interrupt service routines are

00:28:54,159 --> 00:28:58,320
explicitly experimental

00:28:56,320 --> 00:29:00,240
so the code that i've written uses an

00:28:58,320 --> 00:29:03,200
interrupt service routine

00:29:00,240 --> 00:29:04,960
and this is experimental there's a

00:29:03,200 --> 00:29:08,000
tracking issue in rest

00:29:04,960 --> 00:29:10,799
that has no

00:29:08,000 --> 00:29:12,559
no progress effectively made on it and

00:29:10,799 --> 00:29:14,880
so that means i have to compile with the

00:29:12,559 --> 00:29:17,679
rust nightly and add a feature flag

00:29:14,880 --> 00:29:20,240
and all of those sort of add confounding

00:29:17,679 --> 00:29:22,480
factors to the debugging process

00:29:20,240 --> 00:29:24,559
okay i said that avr interrupts are

00:29:22,480 --> 00:29:27,760
experimental i said i'm using interrupts

00:29:24,559 --> 00:29:30,640
but what is an interrupt

00:29:27,760 --> 00:29:31,919
well an interrupt it's it's a lot like a

00:29:30,640 --> 00:29:35,200
function call

00:29:31,919 --> 00:29:35,919
but instead of one piece of code calling

00:29:35,200 --> 00:29:38,880
another

00:29:35,919 --> 00:29:40,640
function it's a bit like the world is

00:29:38,880 --> 00:29:43,840
what's calling your function

00:29:40,640 --> 00:29:46,399
and of course as we

00:29:43,840 --> 00:29:47,120
saw in the model previously the world

00:29:46,399 --> 00:29:50,159
here is

00:29:47,120 --> 00:29:51,279
the peripherals so we have a function

00:29:50,159 --> 00:29:53,200
call we have a

00:29:51,279 --> 00:29:54,399
function on the left a and a function on

00:29:53,200 --> 00:29:56,080
the right b

00:29:54,399 --> 00:29:58,480
and a does some things and then calls

00:29:56,080 --> 00:30:01,520
into b and when b is done it

00:29:58,480 --> 00:30:04,080
returns back to where in a it was

00:30:01,520 --> 00:30:05,200
it was running and what is this actually

00:30:04,080 --> 00:30:07,440
what does this look like

00:30:05,200 --> 00:30:08,960
in terms of what we were talking about

00:30:07,440 --> 00:30:10,320
with the stack

00:30:08,960 --> 00:30:12,480
well there's this thing called a calling

00:30:10,320 --> 00:30:13,279
convention and the calling convention

00:30:12,480 --> 00:30:16,080
says

00:30:13,279 --> 00:30:16,559
some of the working registers need to be

00:30:16,080 --> 00:30:19,840
saved

00:30:16,559 --> 00:30:21,200
by the function that calls that is doing

00:30:19,840 --> 00:30:22,640
the calling

00:30:21,200 --> 00:30:24,159
and so we're going to do that first

00:30:22,640 --> 00:30:25,360
we're going to save working registers

00:30:24,159 --> 00:30:28,000
that we need to save

00:30:25,360 --> 00:30:29,760
and then we jump over into the function

00:30:28,000 --> 00:30:30,480
and then the first thing inside the

00:30:29,760 --> 00:30:32,320
function

00:30:30,480 --> 00:30:33,679
is that we may need to save other

00:30:32,320 --> 00:30:36,799
working registers

00:30:33,679 --> 00:30:40,159
and these are the callee saved registers

00:30:36,799 --> 00:30:42,559
and which registers are in

00:30:40,159 --> 00:30:44,640
are saved in step one or step three are

00:30:42,559 --> 00:30:46,480
determined by the calling convention

00:30:44,640 --> 00:30:49,120
but the important thing to note here is

00:30:46,480 --> 00:30:50,960
that there that some are done in one and

00:30:49,120 --> 00:30:52,960
some are done in three

00:30:50,960 --> 00:30:54,000
okay so let's look at the same thing for

00:30:52,960 --> 00:30:56,159
an interrupt

00:30:54,000 --> 00:30:57,039
we have function a on the left and we

00:30:56,159 --> 00:30:59,279
have an interrupt

00:30:57,039 --> 00:31:01,360
service routine on the right and

00:30:59,279 --> 00:31:02,159
function a is just doing some local

00:31:01,360 --> 00:31:04,559
things

00:31:02,159 --> 00:31:05,200
but the world says oh wait let's call

00:31:04,559 --> 00:31:08,320
into

00:31:05,200 --> 00:31:11,440
our interrupt service routine perhaps

00:31:08,320 --> 00:31:15,039
the computer finished counting to 20

00:31:11,440 --> 00:31:18,000
or perhaps finished counting to 256

00:31:15,039 --> 00:31:19,760
and uh no so now we jumped into our

00:31:18,000 --> 00:31:22,320
interrupt service routine

00:31:19,760 --> 00:31:24,080
or perhaps we received a byte on a

00:31:22,320 --> 00:31:26,000
network interface

00:31:24,080 --> 00:31:27,760
but something in the world has something

00:31:26,000 --> 00:31:28,399
in a peripheral has determined that we

00:31:27,760 --> 00:31:30,720
need to

00:31:28,399 --> 00:31:32,399
service this interrupt so we go into the

00:31:30,720 --> 00:31:33,360
interrupt service routine and then when

00:31:32,399 --> 00:31:36,240
it's done

00:31:33,360 --> 00:31:38,640
we return back to wherever it was that

00:31:36,240 --> 00:31:40,640
we were interrupted

00:31:38,640 --> 00:31:42,240
all right so what is different for a

00:31:40,640 --> 00:31:43,840
calling convention for an interrupt

00:31:42,240 --> 00:31:47,200
service routine

00:31:43,840 --> 00:31:49,039
as opposed to a regular function well

00:31:47,200 --> 00:31:51,279
the first thing is that we don't we're

00:31:49,039 --> 00:31:52,880
not jumping into a function on step two

00:31:51,279 --> 00:31:55,919
we're jumping into an interrupt service

00:31:52,880 --> 00:31:58,480
routine and the second thing is

00:31:55,919 --> 00:31:59,519
because the function that's getting

00:31:58,480 --> 00:32:01,679
interrupted

00:31:59,519 --> 00:32:02,799
doesn't know that it's going to be

00:32:01,679 --> 00:32:05,840
interrupted

00:32:02,799 --> 00:32:06,880
it can't perform step first step one

00:32:05,840 --> 00:32:08,399
first

00:32:06,880 --> 00:32:10,559
the function that's being interrupted

00:32:08,399 --> 00:32:12,799
doesn't know that it needs to save

00:32:10,559 --> 00:32:16,480
the working registers so we need to move

00:32:12,799 --> 00:32:18,720
step one down to step two

00:32:16,480 --> 00:32:20,320
and so now the first the now the first

00:32:18,720 --> 00:32:20,880
thing we do inside our interrupt service

00:32:20,320 --> 00:32:23,360
routine

00:32:20,880 --> 00:32:26,159
needs to be save those working registers

00:32:23,360 --> 00:32:29,600
that would otherwise be saved by

00:32:26,159 --> 00:32:31,840
the caller okay so

00:32:29,600 --> 00:32:33,360
i have some code and it's not working

00:32:31,840 --> 00:32:36,880
and i think it should

00:32:33,360 --> 00:32:39,840
and so i'm making a bunch of changes

00:32:36,880 --> 00:32:40,559
to to try to get it to work or not work

00:32:39,840 --> 00:32:42,080
and

00:32:40,559 --> 00:32:43,600
some of the things that make the bug up

00:32:42,080 --> 00:32:45,519
here and disappear are

00:32:43,600 --> 00:32:46,720
moving my interrupt service routine code

00:32:45,519 --> 00:32:49,279
into main

00:32:46,720 --> 00:32:51,600
well this maybe is a clue but doesn't

00:32:49,279 --> 00:32:55,200
provide a lot of info because we know

00:32:51,600 --> 00:32:57,440
isr is our isr is experimental and

00:32:55,200 --> 00:32:58,640
and also just interrupts are a bit hard

00:32:57,440 --> 00:33:01,679
to

00:32:58,640 --> 00:33:04,960
to to identify what's going on

00:33:01,679 --> 00:33:09,840
we also if i change an inline annotation

00:33:04,960 --> 00:33:12,159
to inline never that makes the bug

00:33:09,840 --> 00:33:14,240
now this is curious i've i've heard of

00:33:12,159 --> 00:33:15,200
there being compiler bugs related to

00:33:14,240 --> 00:33:17,600
inlining

00:33:15,200 --> 00:33:18,960
but that means it's not my bug it's not

00:33:17,600 --> 00:33:21,279
a bug in code i wrote

00:33:18,960 --> 00:33:22,159
that implies it's a bug in the compiler

00:33:21,279 --> 00:33:25,519
and it's

00:33:22,159 --> 00:33:29,840
never a bug in the compiler so

00:33:25,519 --> 00:33:32,240
that's very curious another thing that

00:33:29,840 --> 00:33:33,279
can make the bug disappear is adding a

00:33:32,240 --> 00:33:36,720
map error

00:33:33,279 --> 00:33:39,360
to unit before i unwrap so

00:33:36,720 --> 00:33:39,760
this is basically i've built a conveyor

00:33:39,360 --> 00:33:41,440
belt

00:33:39,760 --> 00:33:43,600
and any error is coming down i just

00:33:41,440 --> 00:33:46,960
throw into the trash

00:33:43,600 --> 00:33:51,200
but it's important to note that this

00:33:46,960 --> 00:33:51,200
error never actually gets called

00:33:51,519 --> 00:33:55,440
the this map error never actually gets

00:33:53,600 --> 00:33:57,519
called so adding

00:33:55,440 --> 00:33:59,679
i'm adding code that doesn't get called

00:33:57,519 --> 00:34:01,440
and that changes the observable behavior

00:33:59,679 --> 00:34:03,360
of the program

00:34:01,440 --> 00:34:05,039
all right let's dig into that just a bit

00:34:03,360 --> 00:34:08,000
more so here i have

00:34:05,039 --> 00:34:09,760
the an example of my broken code it's an

00:34:08,000 --> 00:34:12,720
interrupt

00:34:09,760 --> 00:34:13,679
we call it pcint0 because it's an

00:34:12,720 --> 00:34:17,280
interrupt on

00:34:13,679 --> 00:34:17,839
the pin change if our pin changes value

00:34:17,280 --> 00:34:21,440
we'll

00:34:17,839 --> 00:34:23,679
jump into our interrupt and so on line

00:34:21,440 --> 00:34:26,560
three we toggle our led

00:34:23,679 --> 00:34:29,760
and then on line four we unwrap well why

00:34:26,560 --> 00:34:31,760
is it that toggle returns a result

00:34:29,760 --> 00:34:33,679
this goes back to the embedded hal i was

00:34:31,760 --> 00:34:36,240
talking about embedded hal

00:34:33,679 --> 00:34:38,159
has a number of traits that different

00:34:36,240 --> 00:34:40,720
pieces of hardware can implement

00:34:38,159 --> 00:34:41,440
and in this case we're talking about an

00:34:40,720 --> 00:34:44,320
output pin

00:34:41,440 --> 00:34:46,480
trait and it returns a result because on

00:34:44,320 --> 00:34:48,639
some platforms

00:34:46,480 --> 00:34:50,079
attempting to set an output pin can fail

00:34:48,639 --> 00:34:53,679
but not on avr

00:34:50,079 --> 00:34:56,560
on avr this the error type

00:34:53,679 --> 00:34:57,520
used for this trait is infallible it's

00:34:56,560 --> 00:35:00,320
void

00:34:57,520 --> 00:35:01,520
and so this result can never be the

00:35:00,320 --> 00:35:03,839
error case we know

00:35:01,520 --> 00:35:04,560
statically the result is never the error

00:35:03,839 --> 00:35:07,200
case

00:35:04,560 --> 00:35:07,680
so the unwrap never actually gets called

00:35:07,200 --> 00:35:10,160
or the

00:35:07,680 --> 00:35:12,000
the the error case of the unwrap never

00:35:10,160 --> 00:35:13,920
gets called

00:35:12,000 --> 00:35:15,520
all right so like i said earlier we can

00:35:13,920 --> 00:35:18,400
make this work by

00:35:15,520 --> 00:35:20,079
mapping our error to unit now it's not

00:35:18,400 --> 00:35:21,359
entirely clear why throwing away the

00:35:20,079 --> 00:35:24,000
original error

00:35:21,359 --> 00:35:25,520
and replacing it with an empty error

00:35:24,000 --> 00:35:28,560
would make

00:35:25,520 --> 00:35:30,160
this broken code work particularly

00:35:28,560 --> 00:35:32,800
because i know statically

00:35:30,160 --> 00:35:34,560
that that that that error case never

00:35:32,800 --> 00:35:37,280
actually happens

00:35:34,560 --> 00:35:39,040
we can also replace that with a panic if

00:35:37,280 --> 00:35:41,200
we explicitly panic

00:35:39,040 --> 00:35:42,400
rather than panicking when we unwrap an

00:35:41,200 --> 00:35:45,599
error case

00:35:42,400 --> 00:35:47,520
then it works so i don't

00:35:45,599 --> 00:35:50,160
myself see a semantic difference here

00:35:47,520 --> 00:35:53,040
between this panic version

00:35:50,160 --> 00:35:54,240
and the original broken version so i'm

00:35:53,040 --> 00:35:57,040
going to say

00:35:54,240 --> 00:35:58,560
i found a bug found a bug in the

00:35:57,040 --> 00:36:00,400
compiler we need to minimize our

00:35:58,560 --> 00:36:02,640
reproduction of the bug

00:36:00,400 --> 00:36:04,160
so we're going to remove all of our

00:36:02,640 --> 00:36:05,520
external references

00:36:04,160 --> 00:36:07,440
we're going to remove of course the

00:36:05,520 --> 00:36:08,240
crate that i was writing example code

00:36:07,440 --> 00:36:09,920
for

00:36:08,240 --> 00:36:11,359
we're going to remove any other crates

00:36:09,920 --> 00:36:13,119
that i make use of

00:36:11,359 --> 00:36:15,119
i'm going to remove references to the

00:36:13,119 --> 00:36:16,240
core library where possible because i'm

00:36:15,119 --> 00:36:19,200
trying to

00:36:16,240 --> 00:36:20,560
eliminate anything non-essential and

00:36:19,200 --> 00:36:23,920
finally i'm going to remove

00:36:20,560 --> 00:36:27,440
the memory shenanigans around my unsafe

00:36:23,920 --> 00:36:29,359
static mutable because i want to

00:36:27,440 --> 00:36:32,480
eliminate anything that could possibly

00:36:29,359 --> 00:36:35,760
distract from the bug

00:36:32,480 --> 00:36:36,880
and i do this by copying my working

00:36:35,760 --> 00:36:39,839
version of the code

00:36:36,880 --> 00:36:41,440
to a file called a dash working and the

00:36:39,839 --> 00:36:42,160
broken version of the code to a file

00:36:41,440 --> 00:36:45,040
called a

00:36:42,160 --> 00:36:46,560
broken and i make the same change to

00:36:45,040 --> 00:36:49,520
both of them

00:36:46,560 --> 00:36:50,880
and i compile them and send them to the

00:36:49,520 --> 00:36:52,880
microcontroller

00:36:50,880 --> 00:36:54,000
and check that the working version is

00:36:52,880 --> 00:36:56,400
still working and the broken

00:36:54,000 --> 00:36:57,520
version is still broken and i make these

00:36:56,400 --> 00:37:00,560
incremental changes

00:36:57,520 --> 00:37:03,680
repeatedly until i about

00:37:00,560 --> 00:37:04,400
it looks like i guess the the y case x

00:37:03,680 --> 00:37:07,359
or y

00:37:04,400 --> 00:37:09,119
i get to y and i have what i think is a

00:37:07,359 --> 00:37:10,560
minimal reproduction

00:37:09,119 --> 00:37:12,640
and the minimal difference here looks a

00:37:10,560 --> 00:37:15,359
lot like my

00:37:12,640 --> 00:37:17,040
my minimal difference before but i've

00:37:15,359 --> 00:37:20,240
removed all of the

00:37:17,040 --> 00:37:22,000
core library code and the and the crates

00:37:20,240 --> 00:37:25,280
that are in use

00:37:22,000 --> 00:37:29,280
and just by changing a reference

00:37:25,280 --> 00:37:31,920
to to an error to a reference to unit

00:37:29,280 --> 00:37:32,560
i can make the bug appear and disappear

00:37:31,920 --> 00:37:34,720
and so

00:37:32,560 --> 00:37:36,320
i've confirmed a bug i have a minimal

00:37:34,720 --> 00:37:39,839
repro so i file

00:37:36,320 --> 00:37:42,320
a rest issue and i sit for a little bit

00:37:39,839 --> 00:37:43,760
and nobody comments on it i guess people

00:37:42,320 --> 00:37:45,920
have other things to do

00:37:43,760 --> 00:37:46,880
so i say i'm going to go ahead and dig

00:37:45,920 --> 00:37:50,480
into this now

00:37:46,880 --> 00:37:53,520
i'm vaguely aware that rust uses llvm

00:37:50,480 --> 00:37:54,800
and i've done some messing around with

00:37:53,520 --> 00:37:58,320
llvm in the past

00:37:54,800 --> 00:38:00,720
so i think let's take a look at the llvm

00:37:58,320 --> 00:38:02,720
ir that's emit that's that's that's

00:38:00,720 --> 00:38:05,839
generated for this code

00:38:02,720 --> 00:38:06,560
and so i use this incantation rust flags

00:38:05,839 --> 00:38:10,079
equals

00:38:06,560 --> 00:38:12,240
emit llvmir before the cargo build

00:38:10,079 --> 00:38:13,359
and the rust compiler dutifully complies

00:38:12,240 --> 00:38:15,920
and emits some

00:38:13,359 --> 00:38:17,760
llvmir and here's the version for the

00:38:15,920 --> 00:38:19,680
working code

00:38:17,760 --> 00:38:21,119
and it's not important to understand

00:38:19,680 --> 00:38:23,520
this in detail

00:38:21,119 --> 00:38:24,720
but we can see what the broken codes

00:38:23,520 --> 00:38:27,119
difference is

00:38:24,720 --> 00:38:30,079
and that the main difference is that we

00:38:27,119 --> 00:38:32,880
have this one aloka

00:38:30,079 --> 00:38:33,359
so we have an eloqua and that makes the

00:38:32,880 --> 00:38:36,079
code

00:38:33,359 --> 00:38:37,680
fail well what is this a loca that we

00:38:36,079 --> 00:38:40,800
see

00:38:37,680 --> 00:38:43,040
we're reserving state space on the stack

00:38:40,800 --> 00:38:45,359
for the local variable so we said

00:38:43,040 --> 00:38:47,839
previously our stack has a stack frame

00:38:45,359 --> 00:38:49,359
for each function and if that function

00:38:47,839 --> 00:38:51,599
has a local variable

00:38:49,359 --> 00:38:53,520
we need to reserve space on the stack

00:38:51,599 --> 00:38:55,920
frame for that local variable

00:38:53,520 --> 00:38:58,640
and that's what an llvm aloca

00:38:55,920 --> 00:38:58,640
instruction does

00:38:58,960 --> 00:39:06,079
but why is reserving space break

00:39:02,160 --> 00:39:08,960
my code break my break my example

00:39:06,079 --> 00:39:10,640
so we need to keep digging so let's take

00:39:08,960 --> 00:39:14,000
a look at some assembler

00:39:10,640 --> 00:39:15,599
assembler is a textual representation of

00:39:14,000 --> 00:39:16,640
the machine code that we're talking

00:39:15,599 --> 00:39:19,920
about earlier

00:39:16,640 --> 00:39:21,680
it's as close as you can get to really

00:39:19,920 --> 00:39:22,320
understanding exactly what the machine

00:39:21,680 --> 00:39:26,240
sees

00:39:22,320 --> 00:39:28,960
without reading the binary itself

00:39:26,240 --> 00:39:30,560
and the rest compiler has a flag to emit

00:39:28,960 --> 00:39:32,640
assembler as well and it looks very

00:39:30,560 --> 00:39:34,640
similar to the llvm flag

00:39:32,640 --> 00:39:36,480
and we ask it to emit assembler and the

00:39:34,640 --> 00:39:38,400
rest compiler

00:39:36,480 --> 00:39:39,760
dutifully complies and we get this

00:39:38,400 --> 00:39:41,760
working code

00:39:39,760 --> 00:39:43,520
which is slightly different which is

00:39:41,760 --> 00:39:45,599
significantly different from our broken

00:39:43,520 --> 00:39:47,760
code

00:39:45,599 --> 00:39:50,400
that's a lot more a lot more significant

00:39:47,760 --> 00:39:53,599
differences and they come in three

00:39:50,400 --> 00:39:55,680
main sections so this first section

00:39:53,599 --> 00:39:57,680
where we push some things onto the stack

00:39:55,680 --> 00:39:59,359
and then we do some in and outs and

00:39:57,680 --> 00:40:00,720
we'll go into exactly what this is doing

00:39:59,359 --> 00:40:02,480
a little bit later

00:40:00,720 --> 00:40:04,960
and then we have a second and third

00:40:02,480 --> 00:40:06,319
section where we're doing some pops and

00:40:04,960 --> 00:40:08,400
some more outs all right

00:40:06,319 --> 00:40:09,680
let's walk through this but first we

00:40:08,400 --> 00:40:11,359
need to

00:40:09,680 --> 00:40:14,240
get a little bit more information about

00:40:11,359 --> 00:40:17,760
how to read this avr assembler

00:40:14,240 --> 00:40:20,000
so the push statement like i

00:40:17,760 --> 00:40:22,160
alluded to a moment ago is we're pushing

00:40:20,000 --> 00:40:24,160
a register value onto the stack

00:40:22,160 --> 00:40:26,400
we take some value in a register and we

00:40:24,160 --> 00:40:28,480
put it on the stack to save it for later

00:40:26,400 --> 00:40:30,400
and when we want to get it back we pop

00:40:28,480 --> 00:40:33,440
it that takes it off of the stack and

00:40:30,400 --> 00:40:36,800
puts it back in our register

00:40:33,440 --> 00:40:38,880
we have an in operation which

00:40:36,800 --> 00:40:41,200
will take a value from us one of the

00:40:38,880 --> 00:40:43,040
special registers

00:40:41,200 --> 00:40:44,800
and put it into a general purpose

00:40:43,040 --> 00:40:46,960
register

00:40:44,800 --> 00:40:49,280
and we have an out command that will

00:40:46,960 --> 00:40:52,319
take a value from a special register

00:40:49,280 --> 00:40:54,079
and i apologize take a value from a

00:40:52,319 --> 00:40:55,920
general register and put it into a

00:40:54,079 --> 00:40:58,640
special register

00:40:55,920 --> 00:40:59,839
so push and pop take register values to

00:40:58,640 --> 00:41:01,920
and from the stack

00:40:59,839 --> 00:41:04,480
and in and out take register values to

00:41:01,920 --> 00:41:06,079
and from special registers

00:41:04,480 --> 00:41:07,920
for the purpose of this talk that they

00:41:06,079 --> 00:41:11,280
do other things too

00:41:07,920 --> 00:41:14,240
uh we we can also clear a register

00:41:11,280 --> 00:41:15,760
and we can disable interrupts with the

00:41:14,240 --> 00:41:18,880
cli command

00:41:15,760 --> 00:41:22,560
so disabling interop set tells the

00:41:18,880 --> 00:41:24,800
tells the machine to not interrupt us

00:41:22,560 --> 00:41:26,800
so that we can run some code without

00:41:24,800 --> 00:41:29,440
being interrupted

00:41:26,800 --> 00:41:31,119
and we can also call that clearing the

00:41:29,440 --> 00:41:34,400
interrupt flag

00:41:31,119 --> 00:41:37,280
and it's worth noting that on avr that

00:41:34,400 --> 00:41:40,160
interrupt flag is in the status register

00:41:37,280 --> 00:41:41,920
we were talking about earlier

00:41:40,160 --> 00:41:43,839
all right one other important concept

00:41:41,920 --> 00:41:45,760
before we dig in here

00:41:43,839 --> 00:41:47,200
we have a prologue and epilogue for

00:41:45,760 --> 00:41:48,880
every function

00:41:47,200 --> 00:41:50,240
and these bookend the body of the

00:41:48,880 --> 00:41:52,720
function

00:41:50,240 --> 00:41:53,760
and they provide that calling convention

00:41:52,720 --> 00:41:56,800
that i

00:41:53,760 --> 00:41:58,800
described earlier and it's important

00:41:56,800 --> 00:42:01,280
that these fragments mirror each other

00:41:58,800 --> 00:42:02,640
because they tend to use the stack to

00:42:01,280 --> 00:42:04,319
implement their

00:42:02,640 --> 00:42:08,480
their the saving and restoring of

00:42:04,319 --> 00:42:10,800
registers they need to mirror each other

00:42:08,480 --> 00:42:11,920
well what does that exactly mean to

00:42:10,800 --> 00:42:14,880
mirror each other

00:42:11,920 --> 00:42:15,599
well here we see the prologue and the

00:42:14,880 --> 00:42:18,720
epilogue

00:42:15,599 --> 00:42:20,960
of our working code

00:42:18,720 --> 00:42:23,200
all right so let's read this from the

00:42:20,960 --> 00:42:25,680
outside in

00:42:23,200 --> 00:42:26,240
so we're going to start with a push and

00:42:25,680 --> 00:42:29,440
pop

00:42:26,240 --> 00:42:30,160
on register zero so if we're starting

00:42:29,440 --> 00:42:32,880
from the stop

00:42:30,160 --> 00:42:33,599
from the top of the function on line two

00:42:32,880 --> 00:42:36,640
we push

00:42:33,599 --> 00:42:37,839
register zero onto our stack and then we

00:42:36,640 --> 00:42:41,280
push register one

00:42:37,839 --> 00:42:42,880
onto the stack and then

00:42:41,280 --> 00:42:44,880
we're going to have perform this

00:42:42,880 --> 00:42:48,319
sequence so

00:42:44,880 --> 00:42:50,800
63 on line 4 the constant 63

00:42:48,319 --> 00:42:52,400
refers to the special register the

00:42:50,800 --> 00:42:54,000
status register

00:42:52,400 --> 00:42:55,440
so we're going to read in the status

00:42:54,000 --> 00:42:57,200
register

00:42:55,440 --> 00:42:59,760
and we're going to push it onto the

00:42:57,200 --> 00:43:02,160
stack so now our stack has

00:42:59,760 --> 00:43:03,119
register 0's prior value register 1's

00:43:02,160 --> 00:43:06,160
prior value

00:43:03,119 --> 00:43:09,359
and the status register's prior value

00:43:06,160 --> 00:43:11,359
and then we push register 24 onto the

00:43:09,359 --> 00:43:13,599
stack

00:43:11,359 --> 00:43:14,640
all right the the reason that 24 is down

00:43:13,599 --> 00:43:17,280
below and

00:43:14,640 --> 00:43:18,640
r0 r1 and status register are up above

00:43:17,280 --> 00:43:22,319
is because

00:43:18,640 --> 00:43:23,200
register 0 and 1 are the caller saved

00:43:22,319 --> 00:43:26,480
registers

00:43:23,200 --> 00:43:29,520
and the only reason we are saving them

00:43:26,480 --> 00:43:31,839
here is because we're in an interrupt if

00:43:29,520 --> 00:43:33,599
we were in a regular function

00:43:31,839 --> 00:43:35,680
this prologue would start with line

00:43:33,599 --> 00:43:37,280
seven

00:43:35,680 --> 00:43:38,720
okay and then we go do lines eight

00:43:37,280 --> 00:43:39,599
through ten which are the body of the

00:43:38,720 --> 00:43:41,760
function

00:43:39,599 --> 00:43:44,319
and then we perform the epilogue we pop

00:43:41,760 --> 00:43:47,040
24 off the stack

00:43:44,319 --> 00:43:47,920
we take the we pop the status value off

00:43:47,040 --> 00:43:50,720
of the stack

00:43:47,920 --> 00:43:51,040
and we use an out command to put it back

00:43:50,720 --> 00:43:54,240
in

00:43:51,040 --> 00:43:57,520
so now our status special register has

00:43:54,240 --> 00:44:01,119
its prior value and then we pop

00:43:57,520 --> 00:44:03,520
register 1 and register 0 such that

00:44:01,119 --> 00:44:04,319
at the end of this interrupt we have now

00:44:03,520 --> 00:44:06,960
restored

00:44:04,319 --> 00:44:08,079
all of our registers our special and

00:44:06,960 --> 00:44:13,200
general registers

00:44:08,079 --> 00:44:17,200
and we can return all right

00:44:13,200 --> 00:44:17,200
what's different about the broken code

00:44:17,359 --> 00:44:21,280
so in the broken code we have the same

00:44:19,280 --> 00:44:24,560
sequence at the start

00:44:21,280 --> 00:44:28,800
for the prologue so we can push

00:44:24,560 --> 00:44:32,000
register 0 1 the status register and 24

00:44:28,800 --> 00:44:32,720
and then we have a few more callee saved

00:44:32,000 --> 00:44:36,319
registers

00:44:32,720 --> 00:44:38,800
that will push onto the stack 25 28 29

00:44:36,319 --> 00:44:40,480
because our broken version of the

00:44:38,800 --> 00:44:44,800
interrupt service routine

00:44:40,480 --> 00:44:44,800
clobbers three additional registers

00:44:44,960 --> 00:44:50,079
okay and then towards the end we'll pop

00:44:47,680 --> 00:44:52,720
registers 29 28 and 25

00:44:50,079 --> 00:44:52,720
off the stack

00:44:53,119 --> 00:44:57,520
and finally we have the pre the epilogue

00:44:56,720 --> 00:44:59,680
from our

00:44:57,520 --> 00:45:01,200
working where we from our working code

00:44:59,680 --> 00:45:04,480
and this epilogue

00:45:01,200 --> 00:45:07,760
pops 24 it pops our status value

00:45:04,480 --> 00:45:10,800
and it pops register 1 and 0.

00:45:07,760 --> 00:45:15,599
but note that sequence is

00:45:10,800 --> 00:45:18,560
interrupted by this this other sequence

00:45:15,599 --> 00:45:19,280
so that's a bit mysterious and we note

00:45:18,560 --> 00:45:21,760
that this is

00:45:19,280 --> 00:45:23,280
the sequence to adjust the frame pointer

00:45:21,760 --> 00:45:24,960
so before we walk through that let's

00:45:23,280 --> 00:45:27,839
walk through the corresponding sequence

00:45:24,960 --> 00:45:27,839
from the prologue

00:45:28,400 --> 00:45:34,640
so first we're going to read in

00:45:31,680 --> 00:45:35,200
from 61 and 62 and we're going to store

00:45:34,640 --> 00:45:38,160
that on

00:45:35,200 --> 00:45:38,800
registers 28 29. we said previously we

00:45:38,160 --> 00:45:41,920
clobber

00:45:38,800 --> 00:45:45,599
28 and 29 and here is where we do that

00:45:41,920 --> 00:45:47,280
so 61 and 62 are the special

00:45:45,599 --> 00:45:49,520
ad the addresses of the special

00:45:47,280 --> 00:45:52,560
registers for the frame pointer

00:45:49,520 --> 00:45:56,079
so we read in the frame pointer

00:45:52,560 --> 00:45:57,280
and we uh so this is what we're supposed

00:45:56,079 --> 00:46:00,079
to do here

00:45:57,280 --> 00:46:02,560
so we'll read in the frame pointer into

00:46:00,079 --> 00:46:04,640
register 28 and 29

00:46:02,560 --> 00:46:06,160
and then we subtract one from it on line

00:46:04,640 --> 00:46:09,680
31 we subtract

00:46:06,160 --> 00:46:12,160
one from the frame pointer and then

00:46:09,680 --> 00:46:12,720
we go ahead and we send that updated

00:46:12,160 --> 00:46:15,119
version

00:46:12,720 --> 00:46:16,079
of the frame pointer so that subtracting

00:46:15,119 --> 00:46:18,240
one is

00:46:16,079 --> 00:46:19,599
the at what's allocating space on the

00:46:18,240 --> 00:46:24,000
stack

00:46:19,599 --> 00:46:25,920
and then on 16 and 18 we are going to

00:46:24,000 --> 00:46:27,680
put our updated version of the frame

00:46:25,920 --> 00:46:29,760
pointer into the frame pointer special

00:46:27,680 --> 00:46:31,599
register

00:46:29,760 --> 00:46:33,119
all right we note that that little

00:46:31,599 --> 00:46:36,240
sequence is interrupted by

00:46:33,119 --> 00:46:37,920
this section 14 15 and 17

00:46:36,240 --> 00:46:40,720
and this is a miniature version of

00:46:37,920 --> 00:46:44,240
saving and restoring the status register

00:46:40,720 --> 00:46:45,599
so on 14 we we save the status register

00:46:44,240 --> 00:46:48,319
into register zero

00:46:45,599 --> 00:46:49,760
on 15 we clear interrupts so that we can

00:46:48,319 --> 00:46:52,079
perform our

00:46:49,760 --> 00:46:53,359
pushing of the frame pointer without

00:46:52,079 --> 00:46:56,480
being interrupted

00:46:53,359 --> 00:46:58,960
and then on 17 we restore

00:46:56,480 --> 00:47:01,680
the status register restoring the value

00:46:58,960 --> 00:47:04,640
of the interrupt flag

00:47:01,680 --> 00:47:07,680
something curious to note that 17 is

00:47:04,640 --> 00:47:10,079
before 18 because you get an extra

00:47:07,680 --> 00:47:13,040
instruction free when you set when you

00:47:10,079 --> 00:47:13,040
enable interrupts

00:47:13,839 --> 00:47:17,839
all right and then what is it supposed

00:47:15,599 --> 00:47:19,520
to do to restore the frame pointer at

00:47:17,839 --> 00:47:22,960
the in the epilogue

00:47:19,520 --> 00:47:24,720
well we'll go ahead and add one to our

00:47:22,960 --> 00:47:27,920
updated frame pointer

00:47:24,720 --> 00:47:29,359
in registers 28 and 29 and that's going

00:47:27,920 --> 00:47:32,800
to

00:47:29,359 --> 00:47:33,119
that's going to restore that value to

00:47:32,800 --> 00:47:35,200
the

00:47:33,119 --> 00:47:37,280
what it was prior to entering our

00:47:35,200 --> 00:47:40,079
interrupt service routine

00:47:37,280 --> 00:47:41,440
and then we'll output that value into

00:47:40,079 --> 00:47:43,119
our frame pointer

00:47:41,440 --> 00:47:46,240
and at the end our frame pointer will

00:47:43,119 --> 00:47:49,280
have its original value

00:47:46,240 --> 00:47:54,319
and you can see we have the same little

00:47:49,280 --> 00:47:54,319
status register and interrupt clearing

00:47:55,440 --> 00:47:58,880
all right that's what it's supposed to

00:47:56,880 --> 00:48:01,839
do but

00:47:58,880 --> 00:48:02,880
we note that it we break symmetry here

00:48:01,839 --> 00:48:06,000
in the prologue

00:48:02,880 --> 00:48:09,119
we push into 28 and 29 and then we

00:48:06,000 --> 00:48:12,240
read into our read in our

00:48:09,119 --> 00:48:15,839
frame pointer in the epilogue we pop

00:48:12,240 --> 00:48:18,960
from 28 and 29 and then we send out

00:48:15,839 --> 00:48:22,480
to our frame pointer so we have a push

00:48:18,960 --> 00:48:24,400
and an in followed by a pop and an out

00:48:22,480 --> 00:48:26,480
but if this were symmetric if this

00:48:24,400 --> 00:48:29,680
mirrored properly it should be push

00:48:26,480 --> 00:48:31,920
in out pop

00:48:29,680 --> 00:48:33,599
so we have these last the the epilogue

00:48:31,920 --> 00:48:35,200
is in the wrong order

00:48:33,599 --> 00:48:37,680
let's see let's see what that actually

00:48:35,200 --> 00:48:40,400
means so what is it actually doing

00:48:37,680 --> 00:48:41,040
well as we saw previously were first we

00:48:40,400 --> 00:48:44,960
pushed

00:48:41,040 --> 00:48:48,000
the 28 and 29 registers onto the stack

00:48:44,960 --> 00:48:50,880
and we read in the frame pointer in on

00:48:48,000 --> 00:48:52,559
lines 11 and 12 and subtract one from it

00:48:50,880 --> 00:48:53,520
and send that back out to the frame

00:48:52,559 --> 00:48:56,480
pointer

00:48:53,520 --> 00:48:57,680
so our prolog is fine but then in our

00:48:56,480 --> 00:49:01,359
epilogue

00:48:57,680 --> 00:49:05,520
well first on 22 and 23 we pop

00:49:01,359 --> 00:49:09,280
our values from registers 28 and 29

00:49:05,520 --> 00:49:10,800
and then on line 28 we add one to that

00:49:09,280 --> 00:49:14,960
value

00:49:10,800 --> 00:49:17,440
and then on 31 and 32 we put that value

00:49:14,960 --> 00:49:18,640
into our frame pointer register and we

00:49:17,440 --> 00:49:22,000
note

00:49:18,640 --> 00:49:23,680
that's not the prior value of the frame

00:49:22,000 --> 00:49:27,359
pointer register

00:49:23,680 --> 00:49:28,079
that value is a completely unrelated

00:49:27,359 --> 00:49:30,000
value

00:49:28,079 --> 00:49:32,079
based on the previous value of some

00:49:30,000 --> 00:49:34,960
unrelated registers

00:49:32,079 --> 00:49:35,839
so we've now confirmed we have a bug in

00:49:34,960 --> 00:49:38,720
llvm

00:49:35,839 --> 00:49:41,200
so i file an issue and here's a

00:49:38,720 --> 00:49:44,960
screenshot of the issue in llvms

00:49:41,200 --> 00:49:48,400
bug repository and i sit on it for a bit

00:49:44,960 --> 00:49:50,480
and i wonder who's going to fix it

00:49:48,400 --> 00:49:52,079
well hermes conrad one of my favorite

00:49:50,480 --> 00:49:53,760
characters from futurama said

00:49:52,079 --> 00:49:55,359
if you want a box hurled into the sun

00:49:53,760 --> 00:49:58,079
you have to do it yourself

00:49:55,359 --> 00:49:59,760
so let's dig into the guts of llvm and

00:49:58,079 --> 00:50:02,319
i'm running low on time so i'm going to

00:49:59,760 --> 00:50:03,119
breeze through this but don't get

00:50:02,319 --> 00:50:05,040
overwhelmed

00:50:03,119 --> 00:50:07,760
this is c plus code but i'm mostly

00:50:05,040 --> 00:50:10,960
concerned about the comments

00:50:07,760 --> 00:50:12,960
so we see that we we have

00:50:10,960 --> 00:50:14,319
special epilogue code to restore

00:50:12,960 --> 00:50:16,400
registers one register

00:50:14,319 --> 00:50:18,960
zero and the status register that sounds

00:50:16,400 --> 00:50:18,960
familiar

00:50:19,040 --> 00:50:23,920
and then we see this early exit if

00:50:22,400 --> 00:50:26,800
there's no need to restore the frame

00:50:23,920 --> 00:50:28,720
pointer and i recall restoring the frame

00:50:26,800 --> 00:50:30,400
pointer

00:50:28,720 --> 00:50:31,839
if we don't need to restore a frame

00:50:30,400 --> 00:50:33,839
pointer the code works

00:50:31,839 --> 00:50:35,599
if the code if we do need to restore the

00:50:33,839 --> 00:50:40,240
frame pointer the code doesn't work

00:50:35,599 --> 00:50:41,440
so this triggers something in my mind

00:50:40,240 --> 00:50:43,839
and then we see that we're going to skip

00:50:41,440 --> 00:50:46,480
the kali save pop instructions

00:50:43,839 --> 00:50:48,160
and then insert our frame pointer

00:50:46,480 --> 00:50:49,839
restore code

00:50:48,160 --> 00:50:51,920
all right let's match this up quickly to

00:50:49,839 --> 00:50:54,640
what we had what we saw in our

00:50:51,920 --> 00:50:56,559
assembler so we said we are mid emit the

00:50:54,640 --> 00:50:58,640
special epilogue code here

00:50:56,559 --> 00:51:00,400
and we see that's the same as this

00:50:58,640 --> 00:51:02,319
special epilogue we're storing

00:51:00,400 --> 00:51:03,599
the status register and register one and

00:51:02,319 --> 00:51:05,839
zero

00:51:03,599 --> 00:51:08,160
and we see we restore the frame pointer

00:51:05,839 --> 00:51:10,960
by doing this arithmetic

00:51:08,160 --> 00:51:14,640
and that matches up to our the sequence

00:51:10,960 --> 00:51:14,640
we walked through a few minutes ago

00:51:14,880 --> 00:51:18,000
so now that gets to this bit in the

00:51:17,200 --> 00:51:20,079
middle

00:51:18,000 --> 00:51:22,160
this question of where do we insert the

00:51:20,079 --> 00:51:26,079
frame pointer restoration

00:51:22,160 --> 00:51:27,040
well we're going to do a loop here mbbi

00:51:26,079 --> 00:51:29,920
starts with the

00:51:27,040 --> 00:51:31,520
end of the function and it goes until as

00:51:29,920 --> 00:51:32,480
long as we haven't reached the beginning

00:51:31,520 --> 00:51:34,880
of the function

00:51:32,480 --> 00:51:36,079
we step backwards through the function

00:51:34,880 --> 00:51:38,000
and we check

00:51:36,079 --> 00:51:39,920
if the op code if the current

00:51:38,000 --> 00:51:42,160
instruction is a pop

00:51:39,920 --> 00:51:44,480
then if the current instruction is a pop

00:51:42,160 --> 00:51:47,359
then we continue if it's not a pop

00:51:44,480 --> 00:51:48,800
then we will break out of our loop well

00:51:47,359 --> 00:51:50,000
what does this look like in our broken

00:51:48,800 --> 00:51:52,240
code so here's the broken

00:51:50,000 --> 00:51:53,200
code before we insert our frame pointer

00:51:52,240 --> 00:51:56,160
restoration

00:51:53,200 --> 00:51:58,400
and we start on 29 and that's a pop so

00:51:56,160 --> 00:52:00,160
we keep going we start on we see 28

00:51:58,400 --> 00:52:01,200
that's still a pop we keep going we see

00:52:00,160 --> 00:52:04,400
00:52:01,200 --> 00:52:07,520
27 is not a pop so we insert our frame

00:52:04,400 --> 00:52:10,559
pointer restoration code there

00:52:07,520 --> 00:52:13,359
and that's what leads to our our

00:52:10,559 --> 00:52:14,640
our pops our our frame pointer being

00:52:13,359 --> 00:52:18,000
restored

00:52:14,640 --> 00:52:21,119
later than it should and we see lines

00:52:18,000 --> 00:52:24,240
22 and 23 really need to be

00:52:21,119 --> 00:52:25,680
after the frame pointer restoration

00:52:24,240 --> 00:52:27,599
so i can go ahead and make a fix now

00:52:25,680 --> 00:52:30,000
that i've figured it out it's actually

00:52:27,599 --> 00:52:31,599
quite straightforward once i've once i

00:52:30,000 --> 00:52:33,440
worked through all of that

00:52:31,599 --> 00:52:34,720
i pull out a function to restore the

00:52:33,440 --> 00:52:37,440
status register

00:52:34,720 --> 00:52:39,200
from this special epilogue code and in

00:52:37,440 --> 00:52:41,520
the case of an early exit

00:52:39,200 --> 00:52:42,319
restore the status register then and

00:52:41,520 --> 00:52:44,839
otherwise

00:52:42,319 --> 00:52:46,079
restore the status register at the very

00:52:44,839 --> 00:52:48,319
end

00:52:46,079 --> 00:52:49,520
and i contribute that to llvm first

00:52:48,319 --> 00:52:51,200
write the fix but

00:52:49,520 --> 00:52:52,960
oh i probably need to write a test to

00:52:51,200 --> 00:52:55,599
make sure that it works

00:52:52,960 --> 00:52:57,119
and before that i need to compile llvm

00:52:55,599 --> 00:53:00,640
which is itself

00:52:57,119 --> 00:53:03,200
subjective perhaps a full talk

00:53:00,640 --> 00:53:04,800
then i submit the patch to llvm here's a

00:53:03,200 --> 00:53:08,000
screenshot of the fabricator

00:53:04,800 --> 00:53:11,280
interface that llvm uses

00:53:08,000 --> 00:53:13,200
and i i get

00:53:11,280 --> 00:53:14,720
dylan mckay fortunately had the time to

00:53:13,200 --> 00:53:17,839
to review my patch

00:53:14,720 --> 00:53:20,800
and and and committed it and

00:53:17,839 --> 00:53:21,760
so i appreciate that thanks again dylan

00:53:20,800 --> 00:53:24,880
so it's fixed

00:53:21,760 --> 00:53:27,839
the bug has been fixed in llvm and now i

00:53:24,880 --> 00:53:30,480
want to contribute it to rust so rest

00:53:27,839 --> 00:53:32,240
keeps a fork of llvm so we cherry pick

00:53:30,480 --> 00:53:33,920
the fix into that fork

00:53:32,240 --> 00:53:35,599
and then need to update the rust

00:53:33,920 --> 00:53:39,280
compiler and

00:53:35,599 --> 00:53:42,800
after a couple of prs get landed

00:53:39,280 --> 00:53:44,319
finally the rust bug has been fixed

00:53:42,800 --> 00:53:46,319
hooray all right so what are my next

00:53:44,319 --> 00:53:49,200
steps

00:53:46,319 --> 00:53:50,400
there are several other outstanding avr

00:53:49,200 --> 00:53:52,160
issues including

00:53:50,400 --> 00:53:53,839
as you can see several that relate to

00:53:52,160 --> 00:53:57,119
avr interrupts

00:53:53,839 --> 00:53:58,640
and now that i've worked through

00:53:57,119 --> 00:54:00,640
stepping through the assembler that's

00:53:58,640 --> 00:54:03,119
generated and

00:54:00,640 --> 00:54:04,640
working through the the code that

00:54:03,119 --> 00:54:07,760
generates that assembler

00:54:04,640 --> 00:54:09,280
i feel a little bit of a responsibility

00:54:07,760 --> 00:54:10,000
to take a look at these bugs i haven't

00:54:09,280 --> 00:54:13,440
had time to

00:54:10,000 --> 00:54:13,440
yet but i hope too soon

00:54:14,079 --> 00:54:17,440
well that was a whirlwind but thank you

00:54:15,920 --> 00:54:19,119
very much for listening

00:54:17,440 --> 00:54:21,520
and for your patience with my technical

00:54:19,119 --> 00:54:23,359
difficulties at the beginning

00:54:21,520 --> 00:54:24,559
hopefully we have maybe a couple more

00:54:23,359 --> 00:54:26,559
minutes to

00:54:24,559 --> 00:54:28,400
take a few questions if anyone would

00:54:26,559 --> 00:54:30,720
like to hear anything more

00:54:28,400 --> 00:54:30,720
thank you

00:54:35,760 --> 00:54:42,400
andrew thank you for that

00:54:39,119 --> 00:54:45,520
incredible talk which can only be called

00:54:42,400 --> 00:54:49,839
epic thanks that was an

00:54:45,520 --> 00:54:53,040
epic wow um so avr maybe tier three but

00:54:49,839 --> 00:54:55,200
your patience man is like god here

00:54:53,040 --> 00:54:56,559
not not only not only all you've done

00:54:55,200 --> 00:54:59,119
but also with

00:54:56,559 --> 00:55:00,160
like handling all the tech issues and

00:54:59,119 --> 00:55:02,640
talking just

00:55:00,160 --> 00:55:04,400
you know i can't believe so thank you so

00:55:02,640 --> 00:55:06,480
much for your patience actually

00:55:04,400 --> 00:55:07,920
we're just like this this is gravy for

00:55:06,480 --> 00:55:10,960
us um

00:55:07,920 --> 00:55:14,079
so i do have a few questions um

00:55:10,960 --> 00:55:15,920
first avr is quite a new target right uh

00:55:14,079 --> 00:55:17,359
that's right how are you finding it and

00:55:15,920 --> 00:55:20,559
have you tried things like

00:55:17,359 --> 00:55:23,520
stm32 targets

00:55:20,559 --> 00:55:25,200
i have uh i've messed around a little

00:55:23,520 --> 00:55:26,000
bit with some of the other embedded

00:55:25,200 --> 00:55:29,200
targets

00:55:26,000 --> 00:55:31,200
i haven't done the stm32 for

00:55:29,200 --> 00:55:32,960
for anyone in the audience not familiar

00:55:31,200 --> 00:55:36,400
that's the target that

00:55:32,960 --> 00:55:37,119
the rust embedded book the the intro

00:55:36,400 --> 00:55:39,040
book

00:55:37,119 --> 00:55:40,319
talks through using a board called the

00:55:39,040 --> 00:55:43,599
discovery board

00:55:40,319 --> 00:55:46,240
i have uh on my

00:55:43,599 --> 00:55:48,079
list of too many things to do i have uh

00:55:46,240 --> 00:55:49,200
the goal of picking up one of those

00:55:48,079 --> 00:55:52,400
discovery boards

00:55:49,200 --> 00:55:54,640
and working through uh that that

00:55:52,400 --> 00:55:55,760
that but i haven't uh i haven't had the

00:55:54,640 --> 00:55:59,200
opportunity to do that

00:55:55,760 --> 00:56:00,400
i um yeah i have done a little bit of

00:55:59,200 --> 00:56:02,640
arm development

00:56:00,400 --> 00:56:04,160
uh arm is another embedded target

00:56:02,640 --> 00:56:06,480
another embedded platform

00:56:04,160 --> 00:56:07,359
i've done a little bit with rust but

00:56:06,480 --> 00:56:09,200
honestly

00:56:07,359 --> 00:56:10,799
very little i've done very little rust

00:56:09,200 --> 00:56:13,760
development at this point

00:56:10,799 --> 00:56:15,119
most of my embedded experiences with c

00:56:13,760 --> 00:56:16,799
programming in c

00:56:15,119 --> 00:56:18,319
i've never liked and it's always been

00:56:16,799 --> 00:56:21,520
frustrating and so

00:56:18,319 --> 00:56:23,760
i'm very grateful that uh that the rust

00:56:21,520 --> 00:56:24,559
embedded community is working so hard on

00:56:23,760 --> 00:56:27,440
making

00:56:24,559 --> 00:56:29,520
rust and the and the rust compiler

00:56:27,440 --> 00:56:31,839
contributors are working so hard to make

00:56:29,520 --> 00:56:32,880
make rust a viable option um for

00:56:31,839 --> 00:56:34,480
embedded because

00:56:32,880 --> 00:56:36,400
that's there's there's a lot of

00:56:34,480 --> 00:56:38,160
potential there

00:56:36,400 --> 00:56:41,440
absolutely do you know of a good

00:56:38,160 --> 00:56:45,119
reference for avr assembly

00:56:41,440 --> 00:56:48,079
uh i uh the avr documentation

00:56:45,119 --> 00:56:50,480
generally is pretty good um directly

00:56:48,079 --> 00:56:52,160
it's often hard to find the right pdfs

00:56:50,480 --> 00:56:56,240
but once you find them

00:56:52,160 --> 00:57:00,400
um yeah they they tend to be pretty

00:56:56,240 --> 00:57:03,520
pretty solid so the avr avr is actually

00:57:00,400 --> 00:57:05,599
a very limited platform it's a it's uh

00:57:03,520 --> 00:57:06,559
much more limited than than for instance

00:57:05,599 --> 00:57:09,599
arm

00:57:06,559 --> 00:57:10,720
and so the documentation the the

00:57:09,599 --> 00:57:14,400
assembler reference

00:57:10,720 --> 00:57:16,960
is quite complete so if you

00:57:14,400 --> 00:57:17,680
search for the avr assembler reference

00:57:16,960 --> 00:57:21,359
guide

00:57:17,680 --> 00:57:22,000
uh the and i could drop a a link to it

00:57:21,359 --> 00:57:25,280
in

00:57:22,000 --> 00:57:27,520
in the slides when i release those but

00:57:25,280 --> 00:57:28,960
but that uh that guide is quite complete

00:57:27,520 --> 00:57:30,640
um the other

00:57:28,960 --> 00:57:32,799
resource that i found to be incredibly

00:57:30,640 --> 00:57:36,160
helpful is a as a

00:57:32,799 --> 00:57:38,480
forum called avr freaks um and

00:57:36,160 --> 00:57:40,799
this is a forum that that a bunch of

00:57:38,480 --> 00:57:43,440
people who love programming for avr

00:57:40,799 --> 00:57:45,359
uh answer all kinds of questions so

00:57:43,440 --> 00:57:46,400
almost any question that i have has

00:57:45,359 --> 00:57:48,720
already been answered

00:57:46,400 --> 00:57:50,000
on that platform on that on that uh

00:57:48,720 --> 00:57:53,440
forum

00:57:50,000 --> 00:57:56,079
um i mean on one one post or another and

00:57:53,440 --> 00:57:58,160
and so you know coming up with search

00:57:56,079 --> 00:58:00,559
results on avr freaks

00:57:58,160 --> 00:58:02,799
is uh is fantastic and then the third

00:58:00,559 --> 00:58:06,400
resource i would suggest is

00:58:02,799 --> 00:58:09,440
the avr the the lib c

00:58:06,400 --> 00:58:11,440
documentation for avr is also

00:58:09,440 --> 00:58:13,359
contains a lot of nuggets that are very

00:58:11,440 --> 00:58:15,839
useful for illuminating

00:58:13,359 --> 00:58:17,440
how things actually work on on the avr

00:58:15,839 --> 00:58:19,920
platform

00:58:17,440 --> 00:58:21,680
cool this is an interesting question do

00:58:19,920 --> 00:58:22,640
you think that making types of the

00:58:21,680 --> 00:58:24,480
standard library

00:58:22,640 --> 00:58:27,760
less dependent on the global allocator

00:58:24,480 --> 00:58:29,839
would make your job easier in any way

00:58:27,760 --> 00:58:30,880
certainly yeah that's a great that's a

00:58:29,839 --> 00:58:35,599
great point yeah

00:58:30,880 --> 00:58:39,599
i have i have not yet experimented with

00:58:35,599 --> 00:58:42,559
using out the allocator

00:58:39,599 --> 00:58:43,920
you can so i was previously in my talk i

00:58:42,559 --> 00:58:45,599
was talking about

00:58:43,920 --> 00:58:47,359
you don't have access to the standard

00:58:45,599 --> 00:58:48,480
library but you have access to the core

00:58:47,359 --> 00:58:50,960
library

00:58:48,480 --> 00:58:51,680
and then there's a middle ground there

00:58:50,960 --> 00:58:56,880
where you have

00:58:51,680 --> 00:58:59,599
a lib aloque that can give you access to

00:58:56,880 --> 00:59:00,720
uh to collections like vector and hash

00:58:59,599 --> 00:59:03,760
maps and so forth

00:59:00,720 --> 00:59:06,319
and you can theoretically compile that

00:59:03,760 --> 00:59:08,880
for for for an embedded context i've

00:59:06,319 --> 00:59:11,119
never really experimented with that

00:59:08,880 --> 00:59:11,920
the devices that i tend to work on are

00:59:11,119 --> 00:59:14,960
the the

00:59:11,920 --> 00:59:18,079
at tiny's which are extremely limited

00:59:14,960 --> 00:59:18,079
and you

00:59:18,240 --> 00:59:22,559
it's almost always worth doing analysis

00:59:21,680 --> 00:59:25,440
ahead of time

00:59:22,559 --> 00:59:26,240
to make sure that you don't run out of

00:59:25,440 --> 00:59:29,520
memory

00:59:26,240 --> 00:59:30,480
and that analysis is significantly

00:59:29,520 --> 00:59:33,839
harder

00:59:30,480 --> 00:59:37,280
to do if you're using the heap so

00:59:33,839 --> 00:59:39,040
my programs unembedded almost never do i

00:59:37,280 --> 00:59:40,640
even think about reaching for the heap

00:59:39,040 --> 00:59:43,839
because um

00:59:40,640 --> 00:59:45,520
it it it seems like it's going to be

00:59:43,839 --> 00:59:46,960
creating a lot more problems than it

00:59:45,520 --> 00:59:50,160
would solve i think

00:59:46,960 --> 00:59:52,400
on other embedded devices it probably is

00:59:50,160 --> 00:59:52,400
more

00:59:52,720 --> 00:59:57,839
it's much more relevant particularly

00:59:55,839 --> 01:00:00,160
you know for instance arm obviously but

00:59:57,839 --> 01:00:03,359
but uh but but other more capable

01:00:00,160 --> 01:00:07,520
platforms um i think using using

01:00:03,359 --> 01:00:11,040
an allocator makes a lot of sense i also

01:00:07,520 --> 01:00:14,319
not related to avr but i feel like

01:00:11,040 --> 01:00:17,599
the reliance on a global allocator for

01:00:14,319 --> 01:00:19,599
the standard library means that other

01:00:17,599 --> 01:00:21,040
other contacts so that the other context

01:00:19,599 --> 01:00:25,040
i do a lot of my development in

01:00:21,040 --> 01:00:27,680
is is high performance web development

01:00:25,040 --> 01:00:30,720
and that's a place where being able to

01:00:27,680 --> 01:00:34,000
use for instance a slab allocator

01:00:30,720 --> 01:00:37,520
on a on a per object basis would be

01:00:34,000 --> 01:00:40,240
incredibly valuable but again i i think

01:00:37,520 --> 01:00:40,880
that the you know i'm getting into the

01:00:40,240 --> 01:00:42,559
weeds

01:00:40,880 --> 01:00:44,240
for something not related to this talk

01:00:42,559 --> 01:00:47,280
but but i do see that the

01:00:44,240 --> 01:00:49,680
the user the user experience

01:00:47,280 --> 01:00:51,040
benefit of having it be based on having

01:00:49,680 --> 01:00:52,480
those standard libraries based on a

01:00:51,040 --> 01:00:56,000
global allocator

01:00:52,480 --> 01:00:58,880
probably outweighs the uh the technical

01:00:56,000 --> 01:00:59,599
benefits for these niche use cases cool

01:00:58,880 --> 01:01:01,200
cool

01:00:59,599 --> 01:01:02,960
all right there are a few more questions

01:01:01,200 --> 01:01:04,720
but um we're really running out of time

01:01:02,960 --> 01:01:06,079
so um maybe you could answer them in

01:01:04,720 --> 01:01:08,480
chat um

01:01:06,079 --> 01:01:09,520
or or later on so once again thank you

01:01:08,480 --> 01:01:12,400
so much andrew

01:01:09,520 --> 01:01:23,839
for that epic talk yeah glad to thanks

01:01:12,400 --> 01:01:23,839

YouTube URL: https://www.youtube.com/watch?v=By9FgUzkQTc


