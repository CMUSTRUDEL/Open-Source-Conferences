Title: Diane Hosfelt & Daan Sprenkels - RFC: Secret types in Rust â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	Using empty asm!() directives and empty functions, this talk will show how we can circumvent LLVM's optimizations, and make our binaries secure again. However, these tricks are ugly and unsupported on the stable channel. We need something bigger to solve this issue. We need secret types.

More at https://rustfest.global/session/8-rfc-secret-types-in-rust/
Captions: 
	00:00:03,280 --> 00:00:07,200
dan

00:00:03,760 --> 00:00:09,200
and diane get us to the hype of keeping

00:00:07,200 --> 00:00:11,400
secrets in a type

00:00:09,200 --> 00:00:13,200
disallowing creation of some

00:00:11,400 --> 00:00:17,920
optimization that just

00:00:13,200 --> 00:00:17,920
might tell the fats what you type

00:00:18,800 --> 00:00:25,039
hello everybody i'm dan spankles and i'm

00:00:21,840 --> 00:00:26,400
with here with diane hosfelt

00:00:25,039 --> 00:00:29,039
and we will be talking about secret

00:00:26,400 --> 00:00:30,160
types in rust so the main gist of this

00:00:29,039 --> 00:00:33,760
talk will be that

00:00:30,160 --> 00:00:34,399
um there that like some of you may know

00:00:33,760 --> 00:00:36,559
that

00:00:34,399 --> 00:00:38,000
cryptographic engineers tend to like

00:00:36,559 --> 00:00:42,000
write a lot of their code in

00:00:38,000 --> 00:00:42,960
assembly and um there is a good reason

00:00:42,000 --> 00:00:46,079
for that

00:00:42,960 --> 00:00:48,079
and i will explain why that is um but

00:00:46,079 --> 00:00:49,680
as a cryptographic engineer or an

00:00:48,079 --> 00:00:51,840
aspiring cryptographic engineer i'd like

00:00:49,680 --> 00:00:53,840
to write my code in rust instead

00:00:51,840 --> 00:00:55,520
however because of some of the

00:00:53,840 --> 00:00:57,199
compilation quirks in rust that's not

00:00:55,520 --> 00:00:58,960
really a good idea

00:00:57,199 --> 00:01:01,039
and i will explain why that is the case

00:00:58,960 --> 00:01:03,039
and what needs to be done

00:01:01,039 --> 00:01:04,879
to make rust a programming language that

00:01:03,039 --> 00:01:08,159
we could actually use

00:01:04,879 --> 00:01:10,640
for cryptographic code while

00:01:08,159 --> 00:01:12,159
this talk is pre-recorded both diane and

00:01:10,640 --> 00:01:15,920
me are here in the

00:01:12,159 --> 00:01:17,280
uh at the conference and in the chat so

00:01:15,920 --> 00:01:18,799
feel free to ask

00:01:17,280 --> 00:01:21,280
any questions either at the end of the

00:01:18,799 --> 00:01:22,640
talk or just put them in the chat

00:01:21,280 --> 00:01:24,880
during the talk and we will take care of

00:01:22,640 --> 00:01:24,880
them

00:01:25,360 --> 00:01:30,640
hi i'm diane hospital and this is batman

00:01:28,640 --> 00:01:32,799
and before we get started i have a short

00:01:30,640 --> 00:01:34,560
disclaimer all of this work was done

00:01:32,799 --> 00:01:38,400
while i was a mozilla employee

00:01:34,560 --> 00:01:42,159
and in no way reflects apple's views

00:01:38,400 --> 00:01:42,960
okay so i will explain a couple of

00:01:42,159 --> 00:01:45,600
things and then

00:01:42,960 --> 00:01:46,320
diane will take over uh first we'll talk

00:01:45,600 --> 00:01:48,159
about how

00:01:46,320 --> 00:01:49,759
timing side channels work what what are

00:01:48,159 --> 00:01:52,240
timing side channels

00:01:49,759 --> 00:01:53,360
why are they dangerous and then we'll

00:01:52,240 --> 00:01:57,280
talk about how

00:01:53,360 --> 00:01:58,960
rust is not suitable to write code that

00:01:57,280 --> 00:02:01,040
is actually

00:01:58,960 --> 00:02:03,520
that actually prevents these timing

00:02:01,040 --> 00:02:03,520
channels

00:02:03,759 --> 00:02:07,200
we'll look at a couple of hacks that we

00:02:05,119 --> 00:02:09,360
could use to prevent some of these

00:02:07,200 --> 00:02:11,599
channels in rust

00:02:09,360 --> 00:02:12,400
but then we will go more in depth and

00:02:11,599 --> 00:02:15,440
look at

00:02:12,400 --> 00:02:16,720
the rfc on secret types to see how we

00:02:15,440 --> 00:02:20,080
could actually make

00:02:16,720 --> 00:02:23,840
rust more suitable for side general

00:02:20,080 --> 00:02:23,840
resistant code

00:02:24,000 --> 00:02:29,599
so first a side channel is any attack

00:02:27,680 --> 00:02:30,879
based on information gained from the

00:02:29,599 --> 00:02:33,280
implementation

00:02:30,879 --> 00:02:34,800
of a cryptosystem not a weakness in the

00:02:33,280 --> 00:02:36,959
system itself

00:02:34,800 --> 00:02:38,400
in this case we're concerned about

00:02:36,959 --> 00:02:40,480
timing side channels

00:02:38,400 --> 00:02:42,959
which occur when attackers analyze the

00:02:40,480 --> 00:02:43,760
time taken to execute a cryptographic

00:02:42,959 --> 00:02:46,959
system

00:02:43,760 --> 00:02:50,480
algorithm this can be seen as an

00:02:46,959 --> 00:02:51,040
implicit output for example imagine that

00:02:50,480 --> 00:02:53,360
it takes

00:02:51,040 --> 00:02:54,800
less time to execute part of the code

00:02:53,360 --> 00:02:57,280
when a bit is zero

00:02:54,800 --> 00:02:58,800
than it does when a bit is one that

00:02:57,280 --> 00:03:02,000
difference is measurable

00:02:58,800 --> 00:03:04,560
and can lead to key recovery attacks

00:03:02,000 --> 00:03:06,480
these attacks are a particular threat in

00:03:04,560 --> 00:03:08,640
the post spectre world

00:03:06,480 --> 00:03:10,239
they're primarily used to attack secrets

00:03:08,640 --> 00:03:12,000
that are long lived

00:03:10,239 --> 00:03:13,280
that are extremely valuable if

00:03:12,000 --> 00:03:15,840
compromised

00:03:13,280 --> 00:03:17,599
where each bit compromised provides

00:03:15,840 --> 00:03:19,440
incremental value

00:03:17,599 --> 00:03:21,840
and where the confidentiality of

00:03:19,440 --> 00:03:24,879
compromise is desirable

00:03:21,840 --> 00:03:28,159
the fix is constant time code

00:03:24,879 --> 00:03:28,879
or to be more precise data invariant

00:03:28,159 --> 00:03:31,040
code

00:03:28,879 --> 00:03:34,400
where the time it takes to execute the

00:03:31,040 --> 00:03:37,360
code doesn't depend on the input

00:03:34,400 --> 00:03:40,560
let me explain to you uh why at this

00:03:37,360 --> 00:03:40,560
point it's really hard

00:03:40,640 --> 00:03:44,640
for us to to guarantee that the compiler

00:03:43,200 --> 00:03:47,680
is constant time

00:03:44,640 --> 00:03:50,000
so this is this story will be true for

00:03:47,680 --> 00:03:50,879
basically any programming language that

00:03:50,000 --> 00:03:53,920
is compiled

00:03:50,879 --> 00:03:55,360
there are some exceptions um but we're

00:03:53,920 --> 00:03:57,519
at the rest conference so let's let's

00:03:55,360 --> 00:03:59,360
focus on rust

00:03:57,519 --> 00:04:00,799
so the main problem here is that

00:03:59,360 --> 00:04:03,120
compilers are

00:04:00,799 --> 00:04:05,040
in some sense problematic so compilers

00:04:03,120 --> 00:04:07,599
are allowed to optimize anything

00:04:05,040 --> 00:04:08,879
that they feel does not change the

00:04:07,599 --> 00:04:13,200
program

00:04:08,879 --> 00:04:15,439
um and the the the behavior

00:04:13,200 --> 00:04:16,720
like or the run time of a program and

00:04:15,439 --> 00:04:18,320
stuff like that is not

00:04:16,720 --> 00:04:20,880
it's not considered to change the

00:04:18,320 --> 00:04:23,520
program um in the view of a compiler

00:04:20,880 --> 00:04:24,880
so so the compiler might actually

00:04:23,520 --> 00:04:28,000
optimize stuff that

00:04:24,880 --> 00:04:30,000
we don't think would be would should be

00:04:28,000 --> 00:04:32,639
possible

00:04:30,000 --> 00:04:33,759
and so for example there is there is

00:04:32,639 --> 00:04:35,360
this thing that lvm

00:04:33,759 --> 00:04:37,919
could do which is eliminating

00:04:35,360 --> 00:04:43,840
conditional moves that may load

00:04:37,919 --> 00:04:43,840
and let me show you an example of this

00:04:45,040 --> 00:04:51,360
okay so what you see here on the left

00:04:48,400 --> 00:04:52,000
is i have written this nice little c-mop

00:04:51,360 --> 00:04:54,000
function

00:04:52,000 --> 00:04:55,440
and what this c-mo malfunction is meant

00:04:54,000 --> 00:04:59,759
to do is

00:04:55,440 --> 00:05:02,960
it should so if this conditional

00:04:59,759 --> 00:05:05,280
value is true what it should do is it

00:05:02,960 --> 00:05:08,080
should move the value in b

00:05:05,280 --> 00:05:09,120
into a and if this conditional value is

00:05:08,080 --> 00:05:11,600
false

00:05:09,120 --> 00:05:12,720
then then a should just remain the same

00:05:11,600 --> 00:05:14,560
value

00:05:12,720 --> 00:05:16,639
and b should just be dropped and thrown

00:05:14,560 --> 00:05:17,120
away but the important thing here is

00:05:16,639 --> 00:05:19,199
that

00:05:17,120 --> 00:05:20,240
that conditional value is secret we

00:05:19,199 --> 00:05:22,960
don't want to leak

00:05:20,240 --> 00:05:23,440
any information about this secret value

00:05:22,960 --> 00:05:25,759
so

00:05:23,440 --> 00:05:27,440
the runtime of this function should be

00:05:25,759 --> 00:05:32,479
always the same time

00:05:27,440 --> 00:05:32,479
the same length the same duration

00:05:32,639 --> 00:05:35,919
like depending on the value of this

00:05:34,479 --> 00:05:38,880
conditional value

00:05:35,919 --> 00:05:40,400
so what we do first is we generate a

00:05:38,880 --> 00:05:42,720
mask from this conditional value

00:05:40,400 --> 00:05:43,520
and the value that will come out of this

00:05:42,720 --> 00:05:46,720
mask will be

00:05:43,520 --> 00:05:50,560
something like either um

00:05:46,720 --> 00:05:52,880
only only once uh or if the conditional

00:05:50,560 --> 00:05:54,000
value is true sorry if the conditional

00:05:52,880 --> 00:05:57,600
value was false

00:05:54,000 --> 00:05:57,600
it will be a mask of only zeros

00:05:58,400 --> 00:06:01,919
and then we will use this mask so the

00:06:00,639 --> 00:06:05,600
first line here

00:06:01,919 --> 00:06:07,680
what this does is if this mask

00:06:05,600 --> 00:06:09,120
is only once so if the conditional value

00:06:07,680 --> 00:06:11,759
was true

00:06:09,120 --> 00:06:12,560
then it will xor the value in a with

00:06:11,759 --> 00:06:16,479
itself

00:06:12,560 --> 00:06:18,560
so this will set the value in a to zero

00:06:16,479 --> 00:06:20,080
and then only if this conditional value

00:06:18,560 --> 00:06:23,280
is true

00:06:20,080 --> 00:06:24,319
it will xor a again with b and a was

00:06:23,280 --> 00:06:27,520
zero here

00:06:24,319 --> 00:06:30,080
so a will become like a will get the

00:06:27,520 --> 00:06:30,080
value of b

00:06:30,160 --> 00:06:34,560
and then if if this conditional null

00:06:32,560 --> 00:06:35,120
value was false and then this mask would

00:06:34,560 --> 00:06:39,039
be

00:06:35,120 --> 00:06:40,960
all zeros then both of these

00:06:39,039 --> 00:06:42,639
these and operations will make sure that

00:06:40,960 --> 00:06:45,120
this value was zero

00:06:42,639 --> 00:06:45,919
and this value was zero and both of

00:06:45,120 --> 00:06:48,639
these values

00:06:45,919 --> 00:06:49,199
both of these operations would be a nope

00:06:48,639 --> 00:06:52,240
and then

00:06:49,199 --> 00:06:54,720
a keeps the same value

00:06:52,240 --> 00:06:56,639
and now what we see when lvm compiles

00:06:54,720 --> 00:06:59,280
this and rust compiles this

00:06:56,639 --> 00:07:01,120
is that that the compiler is smart so

00:06:59,280 --> 00:07:04,880
the compiler sees

00:07:01,120 --> 00:07:06,720
hey this this behavior of this function

00:07:04,880 --> 00:07:07,199
completely depends on this conditional

00:07:06,720 --> 00:07:10,319
value

00:07:07,199 --> 00:07:12,880
so first what it does is it checks is

00:07:10,319 --> 00:07:16,880
this conditional value

00:07:12,880 --> 00:07:19,440
is it actually zero so is it false

00:07:16,880 --> 00:07:21,680
and if it's if it sees that this

00:07:19,440 --> 00:07:25,520
conditional value is true

00:07:21,680 --> 00:07:28,319
it jumps to this instruction so it skips

00:07:25,520 --> 00:07:28,880
this complete instruction and if this

00:07:28,319 --> 00:07:31,759
this

00:07:28,880 --> 00:07:33,120
uh this conditional value was false then

00:07:31,759 --> 00:07:35,039
it just does this instruction

00:07:33,120 --> 00:07:36,479
then moves the under instruction and

00:07:35,039 --> 00:07:38,240
that's it so

00:07:36,479 --> 00:07:39,759
basically in one of the two cases it

00:07:38,240 --> 00:07:42,000
skipped this instruction

00:07:39,759 --> 00:07:42,000
and

00:07:43,440 --> 00:07:47,520
the important thing to see here is that

00:07:45,919 --> 00:07:48,879
depending on this value

00:07:47,520 --> 00:07:50,720
depending on the value of the

00:07:48,879 --> 00:07:53,840
conditional um

00:07:50,720 --> 00:07:55,520
the runtime of the algorithm changes and

00:07:53,840 --> 00:07:57,599
so here we have a case

00:07:55,520 --> 00:07:59,840
where the compiler introduced a side

00:07:57,599 --> 00:07:59,840
channel

00:08:00,000 --> 00:08:03,680
which could be a side channel

00:08:01,039 --> 00:08:03,680
vulnerability

00:08:04,000 --> 00:08:07,599
and the the interesting thing is that if

00:08:06,000 --> 00:08:09,840
we if we only look at the

00:08:07,599 --> 00:08:11,599
source code in rust it looks like

00:08:09,840 --> 00:08:12,240
something that like it looks like code

00:08:11,599 --> 00:08:14,319
that

00:08:12,240 --> 00:08:16,080
that that feels completely like this

00:08:14,319 --> 00:08:16,560
could should be implemented in constant

00:08:16,080 --> 00:08:18,479
time

00:08:16,560 --> 00:08:19,919
like we have this this bitwise and

00:08:18,479 --> 00:08:21,759
operation this bit wide end

00:08:19,919 --> 00:08:24,080
and operation and then these claw

00:08:21,759 --> 00:08:26,000
operations and you don't even see them

00:08:24,080 --> 00:08:27,199
in the in the new implement in the

00:08:26,000 --> 00:08:29,919
compiled code

00:08:27,199 --> 00:08:32,560
because lvm is smart enough to see that

00:08:29,919 --> 00:08:34,240
they are not needed

00:08:32,560 --> 00:08:35,839
and this is actually a pretty big danger

00:08:34,240 --> 00:08:40,000
for us

00:08:35,839 --> 00:08:41,599
um so that that's that's what we

00:08:40,000 --> 00:08:43,519
mean when we say that compilers are a

00:08:41,599 --> 00:08:46,320
bit problematic

00:08:43,519 --> 00:08:48,000
obviously we're at rust fest so we've

00:08:46,320 --> 00:08:50,800
all bought into rust

00:08:48,000 --> 00:08:52,720
but the question remains if we can do

00:08:50,800 --> 00:08:53,760
secret invariant programming with

00:08:52,720 --> 00:08:56,320
assembly

00:08:53,760 --> 00:08:57,600
why do we need to do it in rest at all

00:08:56,320 --> 00:09:00,080
writing cryptographic

00:08:57,600 --> 00:09:02,080
and other security critical code in

00:09:00,080 --> 00:09:05,120
high-level languages like rest

00:09:02,080 --> 00:09:07,600
is attractive for numerous reasons

00:09:05,120 --> 00:09:09,600
first they're generally more readable

00:09:07,600 --> 00:09:10,320
and accessible to developers and

00:09:09,600 --> 00:09:12,880
reviewers

00:09:10,320 --> 00:09:14,000
leading to higher quality more secure

00:09:12,880 --> 00:09:16,640
code

00:09:14,000 --> 00:09:17,920
second it allows the integration of

00:09:16,640 --> 00:09:20,160
cryptographic code

00:09:17,920 --> 00:09:22,320
with the rest of an application without

00:09:20,160 --> 00:09:25,279
the use of ffi

00:09:22,320 --> 00:09:27,920
and finally we're motivated to have a

00:09:25,279 --> 00:09:30,320
reference implementation for algorithms

00:09:27,920 --> 00:09:31,200
that is portable to architectures that

00:09:30,320 --> 00:09:33,360
might not

00:09:31,200 --> 00:09:37,519
be supported by highly optimized

00:09:33,360 --> 00:09:40,399
assembly implementations

00:09:37,519 --> 00:09:41,680
so then why do we focus on rust why

00:09:40,399 --> 00:09:44,880
don't we just

00:09:41,680 --> 00:09:46,800
like if we cannot write secure code why

00:09:44,880 --> 00:09:48,320
do we want to use rust in the first

00:09:46,800 --> 00:09:51,760
place and that's

00:09:48,320 --> 00:09:54,720
that's well obviously everybody here has

00:09:51,760 --> 00:09:56,240
their idea of why they reuse rust and in

00:09:54,720 --> 00:09:58,640
our case it's kind of the same

00:09:56,240 --> 00:09:59,279
so we want to use rust um the reason

00:09:58,640 --> 00:10:00,959
that we want

00:09:59,279 --> 00:10:02,560
that we want to use rust is because we

00:10:00,959 --> 00:10:06,079
have all these types

00:10:02,560 --> 00:10:09,600
and all these uh nice nice checks

00:10:06,079 --> 00:10:11,360
um in the compiler that allow us to make

00:10:09,600 --> 00:10:13,600
our code that's that's easier to write

00:10:11,360 --> 00:10:17,440
secure code

00:10:13,600 --> 00:10:19,920
um and we want to utilize

00:10:17,440 --> 00:10:21,519
these checks and these tools as much as

00:10:19,920 --> 00:10:24,160
possible because

00:10:21,519 --> 00:10:27,040
writing just plain assembly is really

00:10:24,160 --> 00:10:28,480
hard and super error prone

00:10:27,040 --> 00:10:30,560
and then there's the other thing that if

00:10:28,480 --> 00:10:32,079
we only write assembly well then you

00:10:30,560 --> 00:10:35,200
have written an assembly for an intel

00:10:32,079 --> 00:10:36,880
processor uh when you run

00:10:35,200 --> 00:10:38,399
want to run the same code on an arm

00:10:36,880 --> 00:10:40,720
processor you

00:10:38,399 --> 00:10:42,160
you have to rewrite the whole code and

00:10:40,720 --> 00:10:43,200
we don't we don't want to do that

00:10:42,160 --> 00:10:46,079
because it also

00:10:43,200 --> 00:10:48,560
allows you to make more mistakes and we

00:10:46,079 --> 00:10:50,480
want our crypto code to be really secure

00:10:48,560 --> 00:10:53,279
so we would like to use a high-level

00:10:50,480 --> 00:10:56,720
language if that is at all possible

00:10:53,279 --> 00:11:00,079
so it's not at all bad

00:10:56,720 --> 00:11:03,120
so there is some way how rust can be

00:11:00,079 --> 00:11:06,320
in a way side channel resistant um

00:11:03,120 --> 00:11:08,800
and this this

00:11:06,320 --> 00:11:09,920
like a couple of these these so so in

00:11:08,800 --> 00:11:12,079
rust we can like

00:11:09,920 --> 00:11:13,279
make these new type style wrappers

00:11:12,079 --> 00:11:15,680
around integer so

00:11:13,279 --> 00:11:17,760
a struct that only has some integer type

00:11:15,680 --> 00:11:21,040
and implement some operations on that

00:11:17,760 --> 00:11:22,560
that are presumably in constant time

00:11:21,040 --> 00:11:24,480
and there's two main examples in the

00:11:22,560 --> 00:11:26,079
world in the wild

00:11:24,480 --> 00:11:27,519
the first one that i'd like to mention

00:11:26,079 --> 00:11:30,720
is the setup rate from

00:11:27,519 --> 00:11:32,720
the dalai crypto team which if you ever

00:11:30,720 --> 00:11:34,720
need to do some kind of stuff in

00:11:32,720 --> 00:11:36,800
constant time

00:11:34,720 --> 00:11:39,200
use this crate this is the current state

00:11:36,800 --> 00:11:41,200
of the art that we have

00:11:39,200 --> 00:11:42,480
this is probably what you should use and

00:11:41,200 --> 00:11:44,000
we don't have anything better at the

00:11:42,480 --> 00:11:45,519
moment

00:11:44,000 --> 00:11:46,959
and the other the other example that i'd

00:11:45,519 --> 00:11:47,600
like to mention is the secret integers

00:11:46,959 --> 00:11:49,120
great

00:11:47,600 --> 00:11:50,880
the secret engine just creates a bit

00:11:49,120 --> 00:11:54,320
more academic of nature

00:11:50,880 --> 00:11:55,680
and what it does it looks at like what

00:11:54,320 --> 00:11:57,839
if we would replace

00:11:55,680 --> 00:12:00,160
all of the integer types with some kind

00:11:57,839 --> 00:12:03,440
of constant time

00:12:00,160 --> 00:12:06,720
integer type would that work and

00:12:03,440 --> 00:12:07,600
and and and what the secret interest

00:12:06,720 --> 00:12:11,600
create does it

00:12:07,600 --> 00:12:14,480
it provides side channel resistant

00:12:11,600 --> 00:12:16,079
resistance on the language level so on

00:12:14,480 --> 00:12:17,040
the language level you're you're sure

00:12:16,079 --> 00:12:18,399
that your code

00:12:17,040 --> 00:12:20,240
looks like something that should be

00:12:18,399 --> 00:12:21,760
sidechain resistant but the secret

00:12:20,240 --> 00:12:23,760
integers create does not

00:12:21,760 --> 00:12:24,959
actually prevent these compiler

00:12:23,760 --> 00:12:27,519
optimizations that

00:12:24,959 --> 00:12:28,079
might introduce vulnerabilities the solo

00:12:27,519 --> 00:12:30,800
crate

00:12:28,079 --> 00:12:31,120
does that and that is why i recommend

00:12:30,800 --> 00:12:34,240
that

00:12:31,120 --> 00:12:37,680
great but

00:12:34,240 --> 00:12:41,040
both of those crates they are only a

00:12:37,680 --> 00:12:43,120
best effort um

00:12:41,040 --> 00:12:44,800
their only only best effort and they

00:12:43,120 --> 00:12:47,920
don't guarantee

00:12:44,800 --> 00:12:49,120
all of the all of the uh like they don't

00:12:47,920 --> 00:12:52,399
fix all of the

00:12:49,120 --> 00:12:52,399
compiler optimization issues

00:12:53,279 --> 00:12:56,800
okay so that is the language level and

00:12:55,360 --> 00:12:59,600
we can also look at like

00:12:56,800 --> 00:13:00,079
more at the the compiler level what do

00:12:59,600 --> 00:13:01,760
we need

00:13:00,079 --> 00:13:04,639
to do in the compiler to actually do it

00:13:01,760 --> 00:13:06,720
right and it turns out we need to add

00:13:04,639 --> 00:13:08,240
some kind of optimization barrier for

00:13:06,720 --> 00:13:11,279
the secret data

00:13:08,240 --> 00:13:13,760
so let me go back to the to the example

00:13:11,279 --> 00:13:13,760
real quick

00:13:14,880 --> 00:13:18,079
so it turns out that the problem here is

00:13:16,800 --> 00:13:21,120
that

00:13:18,079 --> 00:13:23,360
lvm seems to be able to to completely

00:13:21,120 --> 00:13:25,440
eliminate this mask variable so this

00:13:23,360 --> 00:13:27,760
mask variable is secret because the

00:13:25,440 --> 00:13:29,120
because it it directly depends on this

00:13:27,760 --> 00:13:33,279
conditional

00:13:29,120 --> 00:13:35,680
uh value which which we said was secret

00:13:33,279 --> 00:13:36,480
and then because because lvm can just

00:13:35,680 --> 00:13:39,839
analyze

00:13:36,480 --> 00:13:40,399
through this mask variable um it can do

00:13:39,839 --> 00:13:42,160
this

00:13:40,399 --> 00:13:43,839
really nice optimization of adding a

00:13:42,160 --> 00:13:45,519
branch and then just

00:13:43,839 --> 00:13:48,320
just eliminating all these bitwise

00:13:45,519 --> 00:13:49,279
operations so what we need to do here is

00:13:48,320 --> 00:13:52,160
we need to optim

00:13:49,279 --> 00:13:54,639
add an optimization barrier to this mask

00:13:52,160 --> 00:13:54,639
variable

00:13:56,079 --> 00:13:59,839
and there is a couple of ways that we

00:13:58,079 --> 00:14:03,040
can add optimization barriers and

00:13:59,839 --> 00:14:04,480
the first example is that we can add an

00:14:03,040 --> 00:14:06,639
optimization barrier by adding an

00:14:04,480 --> 00:14:08,000
empty assembly directive so what we do

00:14:06,639 --> 00:14:09,920
here is we

00:14:08,000 --> 00:14:11,360
we construct an assembly directive which

00:14:09,920 --> 00:14:14,240
takes this mask value as an

00:14:11,360 --> 00:14:16,160
input and always also takes this mask

00:14:14,240 --> 00:14:19,519
value as an output

00:14:16,160 --> 00:14:22,000
and then lvm is not not able to reason

00:14:19,519 --> 00:14:23,600
about what happens inside of that

00:14:22,000 --> 00:14:25,279
assembly directive like we know

00:14:23,600 --> 00:14:26,880
that nothing happens inside assembly

00:14:25,279 --> 00:14:29,760
directive but lvm

00:14:26,880 --> 00:14:30,720
cannot reason about that and because it

00:14:29,760 --> 00:14:33,440
can't

00:14:30,720 --> 00:14:35,600
the it will actually keep this mask

00:14:33,440 --> 00:14:38,079
value completely intact and

00:14:35,600 --> 00:14:40,639
uh it will not be able to optimize

00:14:38,079 --> 00:14:42,800
through that variable

00:14:40,639 --> 00:14:44,079
and at the other trick so so so the

00:14:42,800 --> 00:14:47,040
assembly directive

00:14:44,079 --> 00:14:47,680
um doesn't work on stable rust because

00:14:47,040 --> 00:14:49,839
it's

00:14:47,680 --> 00:14:50,800
because for the assembly directive you

00:14:49,839 --> 00:14:53,199
need uh

00:14:50,800 --> 00:14:54,399
to have a nightly rust version to

00:14:53,199 --> 00:14:57,440
compile so that's not

00:14:54,399 --> 00:14:59,040
really optimal um

00:14:57,440 --> 00:15:00,959
and so the other trick that we can use

00:14:59,040 --> 00:15:03,839
is to to do a volatile read

00:15:00,959 --> 00:15:05,440
of secret data and what this does is it

00:15:03,839 --> 00:15:07,600
guarantees that at some point

00:15:05,440 --> 00:15:09,279
this mask value would have existed on

00:15:07,600 --> 00:15:13,120
the stack

00:15:09,279 --> 00:15:14,079
and because of that lvm is also not able

00:15:13,120 --> 00:15:17,600
to optimize

00:15:14,079 --> 00:15:21,600
through this um this

00:15:17,600 --> 00:15:26,079
this volatile read um both tricks

00:15:21,600 --> 00:15:27,360
kind of work in 90 of the cases uh they

00:15:26,079 --> 00:15:30,320
don't they don't not have

00:15:27,360 --> 00:15:31,199
like a hundred percent um success rate

00:15:30,320 --> 00:15:34,320
for all

00:15:31,199 --> 00:15:36,079
for all uh for our cases

00:15:34,320 --> 00:15:38,240
i won't go into why that is at this

00:15:36,079 --> 00:15:40,720
moment um

00:15:38,240 --> 00:15:42,560
but but it's important to know that they

00:15:40,720 --> 00:15:43,279
don't always work they are best effort

00:15:42,560 --> 00:15:45,600
tricks

00:15:43,279 --> 00:15:47,279
and the most important part is that

00:15:45,600 --> 00:15:50,560
although these tricks might

00:15:47,279 --> 00:15:54,160
work at the moment um they are not

00:15:50,560 --> 00:15:57,360
guarantees uh and the

00:15:54,160 --> 00:15:59,920
compiler might change in the future so

00:15:57,360 --> 00:16:00,800
perhaps in five years the compiler is

00:15:59,920 --> 00:16:02,399
actually able to

00:16:00,800 --> 00:16:04,240
look into this assembly directive and

00:16:02,399 --> 00:16:05,759
see that nothing happens and it might

00:16:04,240 --> 00:16:06,399
eliminate that assembly directive

00:16:05,759 --> 00:16:08,880
completely

00:16:06,399 --> 00:16:10,560
and we don't know we don't have any

00:16:08,880 --> 00:16:13,759
guarantee that this kind of stuff

00:16:10,560 --> 00:16:16,320
won't happen in the future so

00:16:13,759 --> 00:16:18,639
it might be that in in a couple of years

00:16:16,320 --> 00:16:19,759
a completely secure version of some

00:16:18,639 --> 00:16:21,440
software now

00:16:19,759 --> 00:16:25,600
might actually be insecure with a new

00:16:21,440 --> 00:16:25,600
compiler version which i find very scary

00:16:25,759 --> 00:16:30,720
so yeah we'd like to have guarantees and

00:16:28,160 --> 00:16:33,519
we don't want to have just hacks

00:16:30,720 --> 00:16:34,399
so for the next part i'll give the floor

00:16:33,519 --> 00:16:36,800
to diane

00:16:34,399 --> 00:16:37,680
and she will be talking about how how we

00:16:36,800 --> 00:16:41,519
can use

00:16:37,680 --> 00:16:44,880
secret types in rust to actually make

00:16:41,519 --> 00:16:44,880
make our lives a little bit better

00:16:45,519 --> 00:16:49,680
so why aren't these language level

00:16:47,759 --> 00:16:53,360
protections good enough

00:16:49,680 --> 00:16:55,680
the compiler and instructions

00:16:53,360 --> 00:16:56,480
it turns out that the general purpose

00:16:55,680 --> 00:16:58,880
instructions

00:16:56,480 --> 00:17:00,240
on various platforms take a variable

00:16:58,880 --> 00:17:02,720
number of cycles

00:17:00,240 --> 00:17:04,400
so for us to truly have secret

00:17:02,720 --> 00:17:07,039
independent run times

00:17:04,400 --> 00:17:08,880
we need to completely eliminate the

00:17:07,039 --> 00:17:11,360
problematic instructions

00:17:08,880 --> 00:17:13,520
this can't be done at a language level

00:17:11,360 --> 00:17:17,439
only at a compiler level

00:17:13,520 --> 00:17:20,240
enter rfc number 2859

00:17:17,439 --> 00:17:21,360
this roc defines various secret

00:17:20,240 --> 00:17:22,959
primitive types

00:17:21,360 --> 00:17:24,799
and the instructions that should be

00:17:22,959 --> 00:17:27,199
defined for each type

00:17:24,799 --> 00:17:28,079
for all the extra types we implement all

00:17:27,199 --> 00:17:31,280
of the normal

00:17:28,079 --> 00:17:33,360
acceptable operations when we know

00:17:31,280 --> 00:17:35,039
that a value is safe we can use the

00:17:33,360 --> 00:17:37,679
declassify function

00:17:35,039 --> 00:17:39,919
to convert it back to a public value

00:17:37,679 --> 00:17:41,679
using these integer types we can build

00:17:39,919 --> 00:17:44,640
more complex types

00:17:41,679 --> 00:17:47,039
for example a secret key may be an array

00:17:44,640 --> 00:17:49,360
of secret u8 bytes

00:17:47,039 --> 00:17:51,360
these types keep us secure by

00:17:49,360 --> 00:17:53,679
disallowing any rust code

00:17:51,360 --> 00:17:54,480
that would result in insecure binary

00:17:53,679 --> 00:17:57,440
code

00:17:54,480 --> 00:17:59,280
so for example we don't allow indexing

00:17:57,440 --> 00:18:02,320
based on secrets

00:17:59,280 --> 00:18:03,360
we don't allow using secret bool in an

00:18:02,320 --> 00:18:05,840
if statement

00:18:03,360 --> 00:18:07,120
we don't allow division which is a

00:18:05,840 --> 00:18:10,080
non-constant time

00:18:07,120 --> 00:18:11,360
algorithm we don't allow printing of

00:18:10,080 --> 00:18:14,400
secret values

00:18:11,360 --> 00:18:17,120
and we say that every time we combine

00:18:14,400 --> 00:18:19,679
a public value with a secret value the

00:18:17,120 --> 00:18:22,160
result is also a secret

00:18:19,679 --> 00:18:22,880
to give you an example of how this would

00:18:22,160 --> 00:18:24,960
work

00:18:22,880 --> 00:18:26,960
here's a mock-up error message of what

00:18:24,960 --> 00:18:28,000
would happen if we broke one of these

00:18:26,960 --> 00:18:30,799
rules

00:18:28,000 --> 00:18:32,240
here the programmer chose to branch on a

00:18:30,799 --> 00:18:34,559
secret bool

00:18:32,240 --> 00:18:35,360
in this case the compiler should give us

00:18:34,559 --> 00:18:38,400
an error

00:18:35,360 --> 00:18:40,720
because that's not allowed now

00:18:38,400 --> 00:18:42,480
there are two parts to this problem

00:18:40,720 --> 00:18:44,240
there is an llvm part

00:18:42,480 --> 00:18:45,760
and a rust part which i've already

00:18:44,240 --> 00:18:48,080
described

00:18:45,760 --> 00:18:50,320
there's been some work in the allovm

00:18:48,080 --> 00:18:52,799
realm to propose a similar rfc

00:18:50,320 --> 00:18:53,440
to this one which we've worked together

00:18:52,799 --> 00:18:56,880
on

00:18:53,440 --> 00:18:58,400
at hax 2020. we're not entirely sure

00:18:56,880 --> 00:19:01,679
what the status of that work

00:18:58,400 --> 00:19:02,320
is at the moment but what llvm needs to

00:19:01,679 --> 00:19:04,480
do

00:19:02,320 --> 00:19:07,120
is make sure that our constant time rest

00:19:04,480 --> 00:19:10,960
code is also compiled safely

00:19:07,120 --> 00:19:12,799
so llvm needs to make sure to guarantee

00:19:10,960 --> 00:19:14,960
that what we wrote down in the code is

00:19:12,799 --> 00:19:17,840
still safe in the emitted binary

00:19:14,960 --> 00:19:19,919
that means no branching on secret no

00:19:17,840 --> 00:19:23,039
indexing with secret indices

00:19:19,919 --> 00:19:24,000
and no variable time instructions at the

00:19:23,039 --> 00:19:27,120
moment

00:19:24,000 --> 00:19:29,039
zeroing memory is out of scope but when

00:19:27,120 --> 00:19:31,679
we have this information about

00:19:29,039 --> 00:19:32,640
public and secret values then we've laid

00:19:31,679 --> 00:19:35,840
the groundwork

00:19:32,640 --> 00:19:37,360
to support that as well thank you so

00:19:35,840 --> 00:19:39,760
much for your attention

00:19:37,360 --> 00:19:40,640
if you have any questions feel free to

00:19:39,760 --> 00:19:42,880
ask us

00:19:40,640 --> 00:19:44,080
while this is a recorded talk we're

00:19:42,880 --> 00:19:47,600
currently present

00:19:44,080 --> 00:19:47,600
and ready to answer questions

00:19:48,960 --> 00:19:53,280
all right thank you so much don and

00:19:52,080 --> 00:19:55,039
diane

00:19:53,280 --> 00:19:56,880
uh we're lucky enough to have you both

00:19:55,039 --> 00:20:00,240
here for a q a all right so you've been

00:19:56,880 --> 00:20:00,240
joined by your friend too

00:20:00,960 --> 00:20:07,039
batman came back entirely too ignored

00:20:04,559 --> 00:20:09,280
during the day right people looking at

00:20:07,039 --> 00:20:11,280
their screens all day how dare they

00:20:09,280 --> 00:20:13,200
um so we do have a couple of questions

00:20:11,280 --> 00:20:16,480
from the audience which is great

00:20:13,200 --> 00:20:20,400
uh the first one we've got is

00:20:16,480 --> 00:20:22,080
that this is all very complex

00:20:20,400 --> 00:20:23,760
how do you discover these kind of

00:20:22,080 --> 00:20:27,280
problems and how do you even

00:20:23,760 --> 00:20:29,200
begin to think of a solution

00:20:27,280 --> 00:20:31,600
very broad but i think it would be great

00:20:29,200 --> 00:20:34,880
to hear insight on this

00:20:31,600 --> 00:20:35,679
so there are um there are tools that you

00:20:34,880 --> 00:20:38,880
can use

00:20:35,679 --> 00:20:40,000
um formal verification tools that can

00:20:38,880 --> 00:20:42,880
determine

00:20:40,000 --> 00:20:44,480
if um on different inputs there are

00:20:42,880 --> 00:20:46,159
different runtimes

00:20:44,480 --> 00:20:48,400
um so that's one of the ways that you

00:20:46,159 --> 00:20:52,720
can determine if a program

00:20:48,400 --> 00:20:56,480
has um non-secret independent runtimes

00:20:52,720 --> 00:20:59,200
um for part of it dan

00:20:56,480 --> 00:21:00,240
so yeah so the way we discover these

00:20:59,200 --> 00:21:03,280
kinds of issues

00:21:00,240 --> 00:21:04,880
is like um at some point sometimes i

00:21:03,280 --> 00:21:06,400
write a piece of assembly and the first

00:21:04,880 --> 00:21:07,600
thing i do before i write some piece of

00:21:06,400 --> 00:21:09,280
assembly is actually

00:21:07,600 --> 00:21:11,760
just program it in c or rust and then

00:21:09,280 --> 00:21:13,919
see what the compiler tells me to do

00:21:11,760 --> 00:21:16,080
and then then these are the moments that

00:21:13,919 --> 00:21:18,159
i that i stumble on these

00:21:16,080 --> 00:21:19,840
hey wait but if i would do this that

00:21:18,159 --> 00:21:22,799
would this would not be secure

00:21:19,840 --> 00:21:24,080
um and that's that's when i first

00:21:22,799 --> 00:21:26,720
discovered this for myself

00:21:24,080 --> 00:21:26,720
so yeah

00:21:27,200 --> 00:21:32,880
cool um

00:21:30,640 --> 00:21:34,159
i mean it's really cool that you like

00:21:32,880 --> 00:21:36,159
like you said that you gave us kind of

00:21:34,159 --> 00:21:37,679
an insight on

00:21:36,159 --> 00:21:39,440
you try and see what the compiler tells

00:21:37,679 --> 00:21:42,080
you first and that's how you can

00:21:39,440 --> 00:21:43,039
discover it yeah i guess just be curious

00:21:42,080 --> 00:21:44,640
about what the compiler

00:21:43,039 --> 00:21:46,159
actually tells you not just like all

00:21:44,640 --> 00:21:49,520
right

00:21:46,159 --> 00:21:49,840
um someone is asked if there's a working

00:21:49,520 --> 00:21:53,440
group

00:21:49,840 --> 00:21:57,679
working on it on a solution i suppose

00:21:53,440 --> 00:22:00,320
um there isn't a working group um

00:21:57,679 --> 00:22:01,440
there's just the rfc which has been a

00:22:00,320 --> 00:22:04,720
little bit stale

00:22:01,440 --> 00:22:06,559
um because you know life gets busy

00:22:04,720 --> 00:22:08,640
um so if anyone's interested in

00:22:06,559 --> 00:22:10,640
commenting on the rfc

00:22:08,640 --> 00:22:12,240
and trying to you know help me bring it

00:22:10,640 --> 00:22:15,120
back to life you know that

00:22:12,240 --> 00:22:16,400
that's definitely welcome really cool i

00:22:15,120 --> 00:22:17,679
mean if there's interest for a working

00:22:16,400 --> 00:22:19,679
group then yeah maybe

00:22:17,679 --> 00:22:21,280
someone will hop on from the audience

00:22:19,679 --> 00:22:22,799
yeah that would be great because you

00:22:21,280 --> 00:22:23,520
know one of the things that needs to

00:22:22,799 --> 00:22:26,159
happen

00:22:23,520 --> 00:22:26,559
is on the um on the rest side and on the

00:22:26,159 --> 00:22:28,240
all of

00:22:26,559 --> 00:22:30,880
them side we're going to have to

00:22:28,240 --> 00:22:33,200
eventually do some implementation work

00:22:30,880 --> 00:22:35,120
you know it's not enough to just define

00:22:33,200 --> 00:22:37,200
what has to happen we also have to

00:22:35,120 --> 00:22:38,480
implement these instructions on the

00:22:37,200 --> 00:22:42,480
secret types

00:22:38,480 --> 00:22:42,480
so that'll actually be a lot of work

00:22:42,960 --> 00:22:50,640
yeah um so we actually seem to have

00:22:47,919 --> 00:22:51,200
very little time left but there was a

00:22:50,640 --> 00:22:54,640
lot of

00:22:51,200 --> 00:22:57,600
a lot of chatter in the chat room so

00:22:54,640 --> 00:22:58,640
i guess people can find you in there and

00:22:57,600 --> 00:23:00,159
we can

00:22:58,640 --> 00:23:02,320
get a few more questions there were lots

00:23:00,159 --> 00:23:04,400
of questions and we just

00:23:02,320 --> 00:23:06,240
didn't have enough time but thank you so

00:23:04,400 --> 00:23:08,880
much for joining us it was really great

00:23:06,240 --> 00:23:11,200
to to have you here and

00:23:08,880 --> 00:23:13,360
oh batman let me see if i can get she's

00:23:11,200 --> 00:23:17,039
asleep she's melted into a puddle

00:23:13,360 --> 00:23:21,440
huh say bye to your new friend

00:23:17,039 --> 00:23:23,280
hi awesome thanks fiona

00:23:21,440 --> 00:23:24,640
all right then see you both thank you

00:23:23,280 --> 00:23:37,280
for joining us

00:23:24,640 --> 00:23:37,280

YouTube URL: https://www.youtube.com/watch?v=RSrZzrLAO8A


