Title: Colton Donnelly - Rust for Freshmen â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	Rust is a notably hard language to learn, but its safety guarantees teach valuable skills that can be applied across the industry. Is it possible for college programs to teach Rust to freshman to instill these skills in their students?

More at https://rustfest.global/session/13-rust-for-freshmen/
Captions: 
	00:00:02,800 --> 00:00:08,000
colton donnelly takes rust

00:00:04,640 --> 00:00:12,000
to school to show freshmen the language

00:00:08,000 --> 00:00:12,880
is cool and capable fun great to fail or

00:00:12,000 --> 00:00:17,920
to run

00:00:12,880 --> 00:00:17,920
all in all it's a great teaching tool

00:00:18,320 --> 00:00:21,520
hello and welcome to russ fest global

00:00:20,560 --> 00:00:23,680
00:00:21,520 --> 00:00:25,519
i'm colton donnelly and this is russ for

00:00:23,680 --> 00:00:27,359
freshman

00:00:25,519 --> 00:00:29,279
first a little bit of background about

00:00:27,359 --> 00:00:30,800
me i'm a fourth year student at

00:00:29,279 --> 00:00:32,719
northeastern university

00:00:30,800 --> 00:00:34,160
studying computer science and business

00:00:32,719 --> 00:00:36,079
administration

00:00:34,160 --> 00:00:37,600
i first started learning rust in the

00:00:36,079 --> 00:00:39,840
spring of 2019

00:00:37,600 --> 00:00:42,000
while i was taking computer systems a

00:00:39,840 --> 00:00:44,960
course taught in c

00:00:42,000 --> 00:00:45,920
after i heard about russ's memory

00:00:44,960 --> 00:00:48,559
guarantees

00:00:45,920 --> 00:00:50,160
i decided to look into it when i asked

00:00:48,559 --> 00:00:50,480
my instructors what they thought about

00:00:50,160 --> 00:00:52,399
it

00:00:50,480 --> 00:00:54,640
my professor gave a very encouraging

00:00:52,399 --> 00:00:55,360
response and so i looked more into the

00:00:54,640 --> 00:00:57,600
language

00:00:55,360 --> 00:00:59,199
and started writing projects in it i

00:00:57,600 --> 00:01:01,440
even joined the community

00:00:59,199 --> 00:01:04,080
and earlier this year i became an editor

00:01:01,440 --> 00:01:06,400
for this week in rest

00:01:04,080 --> 00:01:08,320
my goal here is to design a freshman

00:01:06,400 --> 00:01:11,439
level computer science course

00:01:08,320 --> 00:01:14,240
taught in rust i want to enable students

00:01:11,439 --> 00:01:15,920
with rus powerful tooling and ecosystem

00:01:14,240 --> 00:01:18,159
things that they can take advantage of

00:01:15,920 --> 00:01:20,720
for the rest of their career

00:01:18,159 --> 00:01:22,799
russ error messages are better than any

00:01:20,720 --> 00:01:25,280
other language's error messages

00:01:22,799 --> 00:01:26,880
they give students a great way to have

00:01:25,280 --> 00:01:28,880
feedback about their code

00:01:26,880 --> 00:01:30,240
and know exactly what's going wrong with

00:01:28,880 --> 00:01:32,400
it

00:01:30,240 --> 00:01:34,799
for testing and documentation russ

00:01:32,400 --> 00:01:36,720
supports these as first class citizens

00:01:34,799 --> 00:01:38,079
which is great because students don't

00:01:36,720 --> 00:01:40,799
have to worry about adding

00:01:38,079 --> 00:01:42,479
extra dependencies or adding extra

00:01:40,799 --> 00:01:44,240
libraries in order to get their code

00:01:42,479 --> 00:01:46,159
working

00:01:44,240 --> 00:01:47,840
i want to avoid teaching some out of

00:01:46,159 --> 00:01:50,320
scope topics

00:01:47,840 --> 00:01:53,119
stacking heap allocations and threads

00:01:50,320 --> 00:01:55,280
are things that are taught in later

00:01:53,119 --> 00:01:56,799
courses so they're not really in scope

00:01:55,280 --> 00:01:59,200
for this course

00:01:56,799 --> 00:02:00,320
lifetimes are difficult for every rest

00:01:59,200 --> 00:02:03,759
station to learn

00:02:00,320 --> 00:02:05,520
and so not having to

00:02:03,759 --> 00:02:07,680
so students not having to learn about

00:02:05,520 --> 00:02:08,080
these gives them a lot of time to focus

00:02:07,680 --> 00:02:10,000
on the

00:02:08,080 --> 00:02:12,720
other parts of rust that are even more

00:02:10,000 --> 00:02:15,680
important in these early days

00:02:12,720 --> 00:02:16,319
macros are great at reducing redundant

00:02:15,680 --> 00:02:18,640
code

00:02:16,319 --> 00:02:20,239
but unfortunately they hide a lot of

00:02:18,640 --> 00:02:23,200
implementation details

00:02:20,239 --> 00:02:24,720
and so i want to reduce the amount of

00:02:23,200 --> 00:02:27,840
macros that we use

00:02:24,720 --> 00:02:29,200
as much as possible i also want to limit

00:02:27,840 --> 00:02:31,120
the use of cargo

00:02:29,200 --> 00:02:32,800
since dependencies and compiler

00:02:31,120 --> 00:02:35,120
configuration options

00:02:32,800 --> 00:02:38,480
are not really necessary for students

00:02:35,120 --> 00:02:38,480
first learning how to code

00:02:38,800 --> 00:02:43,440
i'm going to be basing this course on

00:02:41,040 --> 00:02:45,519
fundamentals of computer science 2

00:02:43,440 --> 00:02:48,400
affectionately called funnies 2 by

00:02:45,519 --> 00:02:50,800
northeastern university students

00:02:48,400 --> 00:02:52,480
fundies 1 is taught in racket a

00:02:50,800 --> 00:02:54,720
functional programming language

00:02:52,480 --> 00:02:55,680
while fundis 2 is currently taught in

00:02:54,720 --> 00:02:58,239
java and

00:02:55,680 --> 00:02:59,920
introduces students to object oriented

00:02:58,239 --> 00:03:01,440
programming

00:02:59,920 --> 00:03:03,280
the instructors want to make sure that

00:03:01,440 --> 00:03:06,239
students walk away from the courses

00:03:03,280 --> 00:03:07,360
with good habits naming conventions

00:03:06,239 --> 00:03:09,680
documentation

00:03:07,360 --> 00:03:11,519
and unit testing are important no matter

00:03:09,680 --> 00:03:13,440
what language you're using

00:03:11,519 --> 00:03:15,360
but encapsulation is something that

00:03:13,440 --> 00:03:17,360
students haven't encountered before

00:03:15,360 --> 00:03:20,080
and so they must learn how to respect it

00:03:17,360 --> 00:03:22,319
in object-oriented programming

00:03:20,080 --> 00:03:24,400
the instructors don't introduce null yet

00:03:22,319 --> 00:03:26,000
so i'm not really worried about that for

00:03:24,400 --> 00:03:27,760
now

00:03:26,000 --> 00:03:29,360
homework is typically submitted as

00:03:27,760 --> 00:03:31,440
library files

00:03:29,360 --> 00:03:33,280
a testing library runs all of the

00:03:31,440 --> 00:03:35,680
students unit tests

00:03:33,280 --> 00:03:38,319
while an animation library executes

00:03:35,680 --> 00:03:38,319
their code

00:03:38,799 --> 00:03:42,159
so the first thing you want to do when

00:03:40,319 --> 00:03:45,440
you introduce students to

00:03:42,159 --> 00:03:46,080
a new programming language is to teach

00:03:45,440 --> 00:03:49,040
them

00:03:46,080 --> 00:03:50,799
teach them the very basics there are

00:03:49,040 --> 00:03:54,799
numbers booleans and strings

00:03:50,799 --> 00:03:57,439
for numbers in java

00:03:54,799 --> 00:03:58,080
the instructors usually teach students

00:03:57,439 --> 00:04:00,799
to use

00:03:58,080 --> 00:04:03,040
int while double is used for floating

00:04:00,799 --> 00:04:05,200
point precision numbers

00:04:03,040 --> 00:04:06,080
for integers we're going to be using the

00:04:05,200 --> 00:04:08,799
i32

00:04:06,080 --> 00:04:09,120
type while we're going to be using f32

00:04:08,799 --> 00:04:11,439
for

00:04:09,120 --> 00:04:12,959
doubles this is simply to keep a little

00:04:11,439 --> 00:04:16,000
bit of consistency

00:04:12,959 --> 00:04:16,639
even though doubles exact translation

00:04:16,000 --> 00:04:20,479
would be an

00:04:16,639 --> 00:04:23,360
f64 for data types we're going to use

00:04:20,479 --> 00:04:23,919
c style structs and for implementation

00:04:23,360 --> 00:04:25,360
blocks

00:04:23,919 --> 00:04:27,600
we're going to keep it classic with

00:04:25,360 --> 00:04:29,280
constructors and methods

00:04:27,600 --> 00:04:31,040
we're also going to allow students to

00:04:29,280 --> 00:04:31,600
use functions something that they

00:04:31,040 --> 00:04:34,080
currently

00:04:31,600 --> 00:04:34,880
can't do in java since that provides a

00:04:34,080 --> 00:04:38,479
lot of

00:04:34,880 --> 00:04:40,560
great functionality for us programs

00:04:38,479 --> 00:04:42,400
we also have to introduce introduce

00:04:40,560 --> 00:04:45,919
students to references

00:04:42,400 --> 00:04:49,759
since russ is very uh dependent on

00:04:45,919 --> 00:04:49,759
manual pass by reference

00:04:50,400 --> 00:04:56,560
so this is a great first

00:04:53,440 --> 00:04:59,520
step for teaching students how to

00:04:56,560 --> 00:05:00,320
read rust programs you have the dog

00:04:59,520 --> 00:05:03,199
struct

00:05:00,320 --> 00:05:03,759
which has fields that use all of the

00:05:03,199 --> 00:05:05,600
different

00:05:03,759 --> 00:05:06,800
basic data types that we talked about

00:05:05,600 --> 00:05:08,880
earlier

00:05:06,800 --> 00:05:11,199
we have the constructor which constructs

00:05:08,880 --> 00:05:12,080
the dog and we also have a method

00:05:11,199 --> 00:05:15,520
available

00:05:12,080 --> 00:05:18,800
that that accepts the dog by reference

00:05:15,520 --> 00:05:18,800
and returns a string

00:05:19,840 --> 00:05:23,360
now we want to introduce students to

00:05:21,919 --> 00:05:25,840
abstraction

00:05:23,360 --> 00:05:27,199
in funnies 2 this is done with java

00:05:25,840 --> 00:05:31,280
interfaces

00:05:27,199 --> 00:05:33,840
so in rust we're going to use traits to

00:05:31,280 --> 00:05:37,360
introduce students to the idea of

00:05:33,840 --> 00:05:37,360
defining shared behavior

00:05:37,759 --> 00:05:44,479
we now want to add the cat

00:05:40,880 --> 00:05:47,520
struct so in order to reduce the amount

00:05:44,479 --> 00:05:48,160
of inconsistent behavior between dog and

00:05:47,520 --> 00:05:51,360
cat

00:05:48,160 --> 00:05:54,479
we're going to consolidate all of their

00:05:51,360 --> 00:05:57,039
behavior into a trait we create

00:05:54,479 --> 00:05:57,759
the animal trait which has the sound

00:05:57,039 --> 00:06:00,560
method

00:05:57,759 --> 00:06:02,960
which dog will now implement instead of

00:06:00,560 --> 00:06:07,840
the bark method

00:06:02,960 --> 00:06:07,840
cat of course also implements this

00:06:08,720 --> 00:06:11,840
the next thing the instructors usually

00:06:10,960 --> 00:06:15,520
introduce

00:06:11,840 --> 00:06:17,759
is java abstract classes russ doesn't

00:06:15,520 --> 00:06:19,360
have a one-to-one equivalent of this

00:06:17,759 --> 00:06:21,199
so we're going to break it up into two

00:06:19,360 --> 00:06:24,479
different parts

00:06:21,199 --> 00:06:25,120
abstract classes allow allow for

00:06:24,479 --> 00:06:28,160
defining

00:06:25,120 --> 00:06:30,400
default behavior instead of just shared

00:06:28,160 --> 00:06:34,000
behavior between types

00:06:30,400 --> 00:06:37,039
so in rust this is actually available to

00:06:34,000 --> 00:06:40,720
us within the trait

00:06:37,039 --> 00:06:42,400
the trait types we defined the default

00:06:40,720 --> 00:06:45,120
speak implementation

00:06:42,400 --> 00:06:45,759
in the declaration for the animal trait

00:06:45,120 --> 00:06:47,919
and of course

00:06:45,759 --> 00:06:49,440
down below you can see i have unit tests

00:06:47,919 --> 00:06:50,240
to make sure everything works as

00:06:49,440 --> 00:06:51,919
properly

00:06:50,240 --> 00:06:54,400
something that students will have to get

00:06:51,919 --> 00:06:54,400
used to

00:06:54,560 --> 00:06:57,840
the next part of abstract classes is

00:06:56,800 --> 00:07:01,759
defining shared

00:06:57,840 --> 00:07:05,120
data again rust doesn't have a great way

00:07:01,759 --> 00:07:07,840
of of handling this

00:07:05,120 --> 00:07:08,639
and so we have to implement our own

00:07:07,840 --> 00:07:11,199
object

00:07:08,639 --> 00:07:12,479
which will allow us to do this ourselves

00:07:11,199 --> 00:07:15,280
so we have the animal

00:07:12,479 --> 00:07:16,400
shared struct that we've now introduced

00:07:15,280 --> 00:07:20,080
that dog

00:07:16,400 --> 00:07:23,120
and cat can both contain instances of

00:07:20,080 --> 00:07:27,280
this animal shared object contains name

00:07:23,120 --> 00:07:29,520
and weight as public data fields since

00:07:27,280 --> 00:07:31,120
dog and cat will be the only ones that

00:07:29,520 --> 00:07:34,639
will be able to access them

00:07:31,120 --> 00:07:36,400
anyways this allows students to

00:07:34,639 --> 00:07:38,400
reduce the amount of redundant code they

00:07:36,400 --> 00:07:42,000
have and have this

00:07:38,400 --> 00:07:43,280
common data next we're going to have

00:07:42,000 --> 00:07:45,680
dynamic dispatch

00:07:43,280 --> 00:07:46,479
to allow students to act on shared

00:07:45,680 --> 00:07:49,520
behavior

00:07:46,479 --> 00:07:51,599
between different types

00:07:49,520 --> 00:07:53,360
as you can see this is a very simple

00:07:51,599 --> 00:07:55,280
dynamic dispatch example

00:07:53,360 --> 00:07:56,400
but it's enough to show that it's

00:07:55,280 --> 00:07:58,400
possible

00:07:56,400 --> 00:08:00,000
you have the tell animal to speak

00:07:58,400 --> 00:08:02,639
function which

00:08:00,000 --> 00:08:03,759
dynamically dispatches on an animal

00:08:02,639 --> 00:08:07,039
reference

00:08:03,759 --> 00:08:09,599
and returns a string again i

00:08:07,039 --> 00:08:11,039
check to make sure that all of this is

00:08:09,599 --> 00:08:14,400
done properly

00:08:11,039 --> 00:08:16,960
with my unit tests

00:08:14,400 --> 00:08:18,319
next we're going to look at generics

00:08:16,960 --> 00:08:20,400
since they're

00:08:18,319 --> 00:08:22,080
since they allow programmers to contain

00:08:20,400 --> 00:08:25,680
different kinds of data

00:08:22,080 --> 00:08:26,000
in their types we have a problem with

00:08:25,680 --> 00:08:28,879
this

00:08:26,000 --> 00:08:29,840
though typically when the instructors

00:08:28,879 --> 00:08:32,719
introduce

00:08:29,840 --> 00:08:33,839
uh generic types they introduce it by

00:08:32,719 --> 00:08:36,880
re-implementing

00:08:33,839 --> 00:08:40,640
the functional monad uh

00:08:36,880 --> 00:08:43,839
lists we have the ilis interface

00:08:40,640 --> 00:08:46,080
and a cons and empty classes

00:08:43,839 --> 00:08:50,480
which implement the ios interface and

00:08:46,080 --> 00:08:54,080
this effectively serves as a linked list

00:08:50,480 --> 00:08:57,040
this won't work in rust rust

00:08:54,080 --> 00:08:58,560
actually has monads and this is not the

00:08:57,040 --> 00:09:01,519
proper way to define them

00:08:58,560 --> 00:09:02,399
so we must obey rus rules for de uh for

00:09:01,519 --> 00:09:06,160
defining

00:09:02,399 --> 00:09:06,560
things that are similar there's also the

00:09:06,160 --> 00:09:08,880
issue

00:09:06,560 --> 00:09:11,600
of recursive data definitions which you

00:09:08,880 --> 00:09:13,279
can see in the cons list class

00:09:11,600 --> 00:09:15,360
this is something that russ doesn't

00:09:13,279 --> 00:09:19,680
allow and so we must find a way

00:09:15,360 --> 00:09:23,839
around it so in my implementation

00:09:19,680 --> 00:09:27,440
i came i used an enum to define the list

00:09:23,839 --> 00:09:30,560
which now works as a um

00:09:27,440 --> 00:09:31,040
as a monet we have the first and the

00:09:30,560 --> 00:09:34,160
rest

00:09:31,040 --> 00:09:36,720
for the cons while empty doesn't have

00:09:34,160 --> 00:09:39,200
any data available

00:09:36,720 --> 00:09:40,560
we have the cons and empty functions

00:09:39,200 --> 00:09:43,680
available to students

00:09:40,560 --> 00:09:44,560
since they're typically what they're

00:09:43,680 --> 00:09:47,760
used to

00:09:44,560 --> 00:09:50,000
coming from racket we also have

00:09:47,760 --> 00:09:52,480
the count method which is available

00:09:50,000 --> 00:09:53,360
which iterates over all of the items in

00:09:52,480 --> 00:09:56,880
the

00:09:53,360 --> 00:09:59,600
list and counts how many items there are

00:09:56,880 --> 00:10:01,120
as you can see we use a match expression

00:09:59,600 --> 00:10:04,480
something that i was not into

00:10:01,120 --> 00:10:07,680
anticipating teaching to students racket

00:10:04,480 --> 00:10:08,720
does have match expressions but this is

00:10:07,680 --> 00:10:11,600
something that

00:10:08,720 --> 00:10:12,079
wasn't introduced during fundies one and

00:10:11,600 --> 00:10:15,360
so

00:10:12,079 --> 00:10:17,360
there's not really um

00:10:15,360 --> 00:10:18,560
and so students aren't already familiar

00:10:17,360 --> 00:10:20,240
with this idea

00:10:18,560 --> 00:10:22,160
so this is another thing that we have to

00:10:20,240 --> 00:10:25,519
teach students how to use

00:10:22,160 --> 00:10:25,519
and how to use properly

00:10:25,760 --> 00:10:29,279
we also must use heap allocation as you

00:10:28,560 --> 00:10:31,600
can see

00:10:29,279 --> 00:10:32,880
i get around to the redund the recursive

00:10:31,600 --> 00:10:35,760
data definition

00:10:32,880 --> 00:10:36,560
by using a shared pointer or smart

00:10:35,760 --> 00:10:40,560
pointer

00:10:36,560 --> 00:10:42,560
for the rest of the list in my cons

00:10:40,560 --> 00:10:44,240
this is again something that i didn't

00:10:42,560 --> 00:10:45,760
want to teach students

00:10:44,240 --> 00:10:47,440
and so this is something that we'll have

00:10:45,760 --> 00:10:51,440
to find a workaround for

00:10:47,440 --> 00:10:54,560
later next we want to introduce

00:10:51,440 --> 00:10:55,680
function objects to add to existing

00:10:54,560 --> 00:10:59,360
behavior of

00:10:55,680 --> 00:11:01,760
types with list

00:10:59,360 --> 00:11:03,200
this is easy to demonstrate we have the

00:11:01,760 --> 00:11:05,279
filter method now

00:11:03,200 --> 00:11:07,920
which accepts a predicate which as you

00:11:05,279 --> 00:11:11,040
can see at the very top of the file

00:11:07,920 --> 00:11:12,320
is a type alias to a function that

00:11:11,040 --> 00:11:14,959
accepts a reference

00:11:12,320 --> 00:11:15,680
and returns a boolean in the filter

00:11:14,959 --> 00:11:18,240
method

00:11:15,680 --> 00:11:19,519
we have the same thing as count except

00:11:18,240 --> 00:11:22,800
first we check to see

00:11:19,519 --> 00:11:26,240
if the predicate is satisfied by

00:11:22,800 --> 00:11:26,240
the first and the list

00:11:26,800 --> 00:11:30,640
next we're going to look at error

00:11:28,240 --> 00:11:34,320
handling this is the next

00:11:30,640 --> 00:11:35,760
part of the instructor's plan

00:11:34,320 --> 00:11:38,560
and it's a great way to introduce

00:11:35,760 --> 00:11:42,399
students to the results type of rest

00:11:38,560 --> 00:11:43,600
currently the instructors use java

00:11:42,399 --> 00:11:46,000
exceptions

00:11:43,600 --> 00:11:47,680
uh to teach students how to properly

00:11:46,000 --> 00:11:50,399
handle errors

00:11:47,680 --> 00:11:52,320
this of course is one of the things that

00:11:50,399 --> 00:11:54,240
russ decided not to do

00:11:52,320 --> 00:11:56,480
and was one of the decisions that

00:11:54,240 --> 00:11:58,399
created a lot of

00:11:56,480 --> 00:12:01,440
difference between rus and a lot of

00:11:58,399 --> 00:12:04,000
other low-level languages

00:12:01,440 --> 00:12:05,279
instructors teach students how how to

00:12:04,000 --> 00:12:07,279
throw exceptions

00:12:05,279 --> 00:12:09,120
when to throw exceptions which

00:12:07,279 --> 00:12:11,920
exceptions to use

00:12:09,120 --> 00:12:12,480
and how to catch the exceptions with

00:12:11,920 --> 00:12:15,519
rust

00:12:12,480 --> 00:12:17,760
of course all of this goes away

00:12:15,519 --> 00:12:18,959
you really only have to act on the

00:12:17,760 --> 00:12:21,680
results type

00:12:18,959 --> 00:12:23,200
which you can use by checking whether or

00:12:21,680 --> 00:12:25,680
not it's okay or an

00:12:23,200 --> 00:12:27,519
error and then returning the error if

00:12:25,680 --> 00:12:30,480
needed

00:12:27,519 --> 00:12:32,639
it also has a future advantage of giving

00:12:30,480 --> 00:12:36,480
students a better understanding of

00:12:32,639 --> 00:12:38,320
the monadic style of rust

00:12:36,480 --> 00:12:40,160
so that they can better understand how

00:12:38,320 --> 00:12:43,839
to use the option type

00:12:40,160 --> 00:12:47,040
later on when we decide to introduce uh

00:12:43,839 --> 00:12:47,040
non-existent data

00:12:47,200 --> 00:12:52,079
so as you can see we have the animal

00:12:49,440 --> 00:12:53,760
shared implementation from earlier and

00:12:52,079 --> 00:12:54,880
we also have the dog implementation

00:12:53,760 --> 00:12:57,040
block

00:12:54,880 --> 00:12:58,000
from earlier for both of these

00:12:57,040 --> 00:13:01,200
constructors

00:12:58,000 --> 00:13:03,200
we've changed the result type or we've

00:13:01,200 --> 00:13:04,320
yeah we've changed the result type to be

00:13:03,200 --> 00:13:07,360
a result

00:13:04,320 --> 00:13:08,800
where the okay is an animal shared

00:13:07,360 --> 00:13:11,040
object

00:13:08,800 --> 00:13:13,120
while the error is the string for the

00:13:11,040 --> 00:13:15,680
animal shared constructor

00:13:13,120 --> 00:13:16,639
for the dog constructor it's nearly

00:13:15,680 --> 00:13:19,519
identical

00:13:16,639 --> 00:13:20,079
it returns a dog in the okay case and a

00:13:19,519 --> 00:13:24,000
string

00:13:20,079 --> 00:13:26,079
in the error case and the animal shared

00:13:24,000 --> 00:13:27,120
implementation we have to check to make

00:13:26,079 --> 00:13:31,360
sure that the weight

00:13:27,120 --> 00:13:31,760
is non-negative animals simply cannot

00:13:31,360 --> 00:13:36,000
weigh

00:13:31,760 --> 00:13:38,959
negative weight while in dog

00:13:36,000 --> 00:13:40,160
we check to see if the animal shared

00:13:38,959 --> 00:13:42,800
constructor returned an

00:13:40,160 --> 00:13:43,839
okay if it was an error we return the

00:13:42,800 --> 00:13:47,120
air

00:13:43,839 --> 00:13:48,160
we also check to see that the agent dog

00:13:47,120 --> 00:13:51,920
ears of the dog

00:13:48,160 --> 00:13:54,639
is valid and we return the error if not

00:13:51,920 --> 00:13:55,600
students will use this to have a great

00:13:54,639 --> 00:13:58,399
understanding

00:13:55,600 --> 00:14:00,399
of how to properly handle errors and

00:13:58,399 --> 00:14:02,399
since russ doesn't really allow any

00:14:00,399 --> 00:14:05,360
workarounds for

00:14:02,399 --> 00:14:07,440
error handling students always must

00:14:05,360 --> 00:14:10,320
handle this

00:14:07,440 --> 00:14:13,839
which gives a great habit for students

00:14:10,320 --> 00:14:13,839
as they move on in their career

00:14:14,480 --> 00:14:17,760
lastly we're going to look at sameness

00:14:16,240 --> 00:14:20,079
of data

00:14:17,760 --> 00:14:21,680
in the course students are taught that

00:14:20,079 --> 00:14:24,800
data is the same

00:14:21,680 --> 00:14:27,440
when it's reflexive symmetric and

00:14:24,800 --> 00:14:27,440
transitive

00:14:27,920 --> 00:14:31,279
this is what an example might look like

00:14:30,560 --> 00:14:34,560
we have the

00:14:31,279 --> 00:14:37,680
abstract animal class and this has

00:14:34,560 --> 00:14:39,600
the same dog and same cat methods

00:14:37,680 --> 00:14:41,040
which are going to be used to check to

00:14:39,600 --> 00:14:44,000
make sure that

00:14:41,040 --> 00:14:45,760
that odd instances of those type are the

00:14:44,000 --> 00:14:49,360
same

00:14:45,760 --> 00:14:52,399
in the dog class we have the same animal

00:14:49,360 --> 00:14:55,680
method which is inherited from the

00:14:52,399 --> 00:14:57,279
animal interface and you see that we

00:14:55,680 --> 00:15:01,519
have the instance of

00:14:57,279 --> 00:15:03,920
keyword being used this is a problem

00:15:01,519 --> 00:15:05,120
this simply does not have have an

00:15:03,920 --> 00:15:09,600
equivalent in rest

00:15:05,120 --> 00:15:11,920
you cannot check the type of an object

00:15:09,600 --> 00:15:13,040
in fact russ erases the type of an

00:15:11,920 --> 00:15:16,160
object when you

00:15:13,040 --> 00:15:19,680
up cast it into a trait object

00:15:16,160 --> 00:15:22,560
so this part

00:15:19,680 --> 00:15:24,160
simply does not exist which could be a

00:15:22,560 --> 00:15:26,720
problem

00:15:24,160 --> 00:15:28,160
except i'm not sure it is it could in

00:15:26,720 --> 00:15:30,240
fact be an advantage

00:15:28,160 --> 00:15:31,440
and it could help students to build

00:15:30,240 --> 00:15:34,560
better uh

00:15:31,440 --> 00:15:35,120
better habits programmers should only be

00:15:34,560 --> 00:15:38,959
able

00:15:35,120 --> 00:15:41,040
to use what they need and they should be

00:15:38,959 --> 00:15:42,880
and they should be avoiding down casting

00:15:41,040 --> 00:15:46,320
for specific behavior

00:15:42,880 --> 00:15:48,240
whenever possible in fact

00:15:46,320 --> 00:15:49,600
they should only be checking equality

00:15:48,240 --> 00:15:52,000
between two objects

00:15:49,600 --> 00:15:53,759
when they know those two objects are of

00:15:52,000 --> 00:15:56,560
the same type

00:15:53,759 --> 00:15:57,199
this introduces a lot of good habits to

00:15:56,560 --> 00:15:58,959
students

00:15:57,199 --> 00:16:01,600
and ensures that they walk away with a

00:15:58,959 --> 00:16:05,279
lot of great

00:16:01,600 --> 00:16:09,759
great skills and understanding of how to

00:16:05,279 --> 00:16:11,519
properly handle the sameness of data

00:16:09,759 --> 00:16:13,040
now we're going to try to look at how to

00:16:11,519 --> 00:16:14,800
fix our problems

00:16:13,040 --> 00:16:17,360
earlier we talked about the monadic

00:16:14,800 --> 00:16:19,360
behavior of rust

00:16:17,360 --> 00:16:20,800
i didn't want to introduce the enum

00:16:19,360 --> 00:16:24,160
since this isn't even

00:16:20,800 --> 00:16:26,160
introduced for java in fundis2

00:16:24,160 --> 00:16:27,279
but it seems like if we want to talk

00:16:26,160 --> 00:16:29,440
about monadic

00:16:27,279 --> 00:16:30,399
implementations in rust this is what

00:16:29,440 --> 00:16:33,519
we'll have to

00:16:30,399 --> 00:16:35,759
introduce we also

00:16:33,519 --> 00:16:37,279
looked at the sameness of trait objects

00:16:35,759 --> 00:16:39,279
but

00:16:37,279 --> 00:16:43,360
it's not exactly clear whether or not

00:16:39,279 --> 00:16:46,399
that's a good or a bad thing

00:16:43,360 --> 00:16:47,680
lastly we saw the recursive data

00:16:46,399 --> 00:16:49,759
definitions

00:16:47,680 --> 00:16:51,199
and the only way to work around that

00:16:49,759 --> 00:16:54,160
easily was

00:16:51,199 --> 00:16:56,240
to introduce heap allocation something

00:16:54,160 --> 00:16:57,519
that i did not want to introduce into

00:16:56,240 --> 00:17:00,720
the course

00:16:57,519 --> 00:17:02,399
how can we fix this i think with a

00:17:00,720 --> 00:17:05,919
simple crate

00:17:02,399 --> 00:17:06,480
that looks like this but this crate has

00:17:05,919 --> 00:17:09,839
its own

00:17:06,480 --> 00:17:12,880
problem it has too much magic

00:17:09,839 --> 00:17:15,120
in and of itself as of right now

00:17:12,880 --> 00:17:16,240
in funnies 2 students don't have to

00:17:15,120 --> 00:17:19,839
depend on

00:17:16,240 --> 00:17:23,199
uh on external libraries for anything

00:17:19,839 --> 00:17:25,760
except for the animations and for unit

00:17:23,199 --> 00:17:25,760
testing

00:17:25,919 --> 00:17:28,960
there are also some honorable mentions

00:17:28,559 --> 00:17:31,440
uh

00:17:28,960 --> 00:17:32,799
some topics that i didn't get to cover

00:17:31,440 --> 00:17:37,039
in this presentation

00:17:32,799 --> 00:17:39,280
such as loops mutability and algorithms

00:17:37,039 --> 00:17:42,400
these shouldn't be too hard to replicate

00:17:39,280 --> 00:17:45,760
and rust so i'm going to leave that

00:17:42,400 --> 00:17:48,080
alone another problem that

00:17:45,760 --> 00:17:49,200
i didn't mention was the animation

00:17:48,080 --> 00:17:51,360
library

00:17:49,200 --> 00:17:52,400
currently russ has an immature gui

00:17:51,360 --> 00:17:54,240
ecosystem

00:17:52,400 --> 00:17:56,720
which means that there's got to be a lot

00:17:54,240 --> 00:17:57,039
of work done before we have the ability

00:17:56,720 --> 00:17:59,280
to

00:17:57,039 --> 00:18:01,039
have an animation library sufficient

00:17:59,280 --> 00:18:03,200
enough for the course

00:18:01,039 --> 00:18:05,280
there is the possibility of using web

00:18:03,200 --> 00:18:06,960
assembly and having students run their

00:18:05,280 --> 00:18:09,520
rus code in a browser

00:18:06,960 --> 00:18:10,320
this of course is very flexible and

00:18:09,520 --> 00:18:13,440
could actually

00:18:10,320 --> 00:18:17,039
be something that could be used

00:18:13,440 --> 00:18:17,679
in a course like this there's also the

00:18:17,039 --> 00:18:21,120
problem of

00:18:17,679 --> 00:18:24,880
cargo right now cargo is the

00:18:21,120 --> 00:18:27,280
easiest way to run rust code

00:18:24,880 --> 00:18:28,000
without cargo you don't really have

00:18:27,280 --> 00:18:30,480
anything else

00:18:28,000 --> 00:18:32,559
that you can use that students would be

00:18:30,480 --> 00:18:35,840
able to pick up quickly

00:18:32,559 --> 00:18:37,600
you could use the rusty cli but that has

00:18:35,840 --> 00:18:40,160
a lot of extra

00:18:37,600 --> 00:18:42,000
stuff in it and ultimately is too

00:18:40,160 --> 00:18:45,360
complicated for students to learn how

00:18:42,000 --> 00:18:48,559
to pick up so there might be room

00:18:45,360 --> 00:18:49,600
for a custom tool to be used which would

00:18:48,559 --> 00:18:51,840
run all of the

00:18:49,600 --> 00:18:53,360
compilation and testing for students

00:18:51,840 --> 00:18:56,559
without them having to

00:18:53,360 --> 00:18:59,360
learn anything extra

00:18:56,559 --> 00:19:01,760
and lastly there are some topics that

00:18:59,360 --> 00:19:03,760
i'm leaving out for future classes

00:19:01,760 --> 00:19:05,679
such as lifetimes lifetimes could be

00:19:03,760 --> 00:19:07,679
introduced in the next course

00:19:05,679 --> 00:19:09,280
while threads are definitely introduced

00:19:07,679 --> 00:19:11,200
in a later course

00:19:09,280 --> 00:19:13,120
unsafe is also something that students

00:19:11,200 --> 00:19:14,640
should learn how to use and rust

00:19:13,120 --> 00:19:16,640
but they should only learn how to use it

00:19:14,640 --> 00:19:18,320
properly so i think that this would be

00:19:16,640 --> 00:19:22,240
best used alongside

00:19:18,320 --> 00:19:25,679
the thread lessons

00:19:22,240 --> 00:19:28,000
so is this course viable ultimately

00:19:25,679 --> 00:19:29,760
it has a lot of advantages and a lot of

00:19:28,000 --> 00:19:32,320
disadvantages

00:19:29,760 --> 00:19:34,320
for advantages it forces a lot of good

00:19:32,320 --> 00:19:37,120
habits within students

00:19:34,320 --> 00:19:38,320
simply by using rust as the language of

00:19:37,120 --> 00:19:40,720
choice

00:19:38,320 --> 00:19:41,919
and all of the habits that students

00:19:40,720 --> 00:19:43,600
learn with rust

00:19:41,919 --> 00:19:45,919
are applicable to other programming

00:19:43,600 --> 00:19:47,520
languages giving them a lot of skills

00:19:45,919 --> 00:19:50,559
that they can use

00:19:47,520 --> 00:19:50,559
throughout the industry

00:19:50,880 --> 00:19:56,400
furthermore further future concepts

00:19:54,000 --> 00:19:57,120
will enforce good habits within students

00:19:56,400 --> 00:20:00,160
you also

00:19:57,120 --> 00:20:04,080
have the option type lifetimes

00:20:00,160 --> 00:20:05,600
and mutability and thread safety

00:20:04,080 --> 00:20:07,120
and all of these things which are

00:20:05,600 --> 00:20:08,960
included in rust

00:20:07,120 --> 00:20:11,679
either in the standard library or in the

00:20:08,960 --> 00:20:13,440
core library or as a language feature

00:20:11,679 --> 00:20:15,120
which students will be able to take

00:20:13,440 --> 00:20:17,280
advantage of

00:20:15,120 --> 00:20:18,799
and lastly a helpful compiler gives

00:20:17,280 --> 00:20:21,440
students a lot of

00:20:18,799 --> 00:20:23,840
great feedback about what exactly is

00:20:21,440 --> 00:20:25,440
going wrong in their programs

00:20:23,840 --> 00:20:28,559
unfortunately there are still some

00:20:25,440 --> 00:20:30,559
disadvantages to this course

00:20:28,559 --> 00:20:32,880
a lot of work must be done to make sure

00:20:30,559 --> 00:20:36,000
that the student experience is still

00:20:32,880 --> 00:20:38,799
great the animation library for example

00:20:36,000 --> 00:20:41,200
again must have a lot of work in order

00:20:38,799 --> 00:20:44,240
to make sure that it runs as

00:20:41,200 --> 00:20:46,799
efficiently and smoothly as the java

00:20:44,240 --> 00:20:49,120
implementation currently runs

00:20:46,799 --> 00:20:49,840
we also have to figure out whether or

00:20:49,120 --> 00:20:52,240
not we're going to

00:20:49,840 --> 00:20:52,880
replace cargo since students don't

00:20:52,240 --> 00:20:55,600
really

00:20:52,880 --> 00:20:56,960
need to learn how to manage dependencies

00:20:55,600 --> 00:21:00,400
but they will still

00:20:56,960 --> 00:21:02,720
have to use the animation library to run

00:21:00,400 --> 00:21:06,000
their code

00:21:02,720 --> 00:21:06,720
enums are also unavoidable simply

00:21:06,000 --> 00:21:09,840
because

00:21:06,720 --> 00:21:11,600
rust does it differently

00:21:09,840 --> 00:21:12,960
enums in other object-oriented

00:21:11,600 --> 00:21:16,880
programming languages

00:21:12,960 --> 00:21:20,000
don't have the same kind of of

00:21:16,880 --> 00:21:23,440
enum values as rust for example

00:21:20,000 --> 00:21:27,120
you can't have one enum value

00:21:23,440 --> 00:21:29,760
with an integer data field

00:21:27,120 --> 00:21:31,760
and another one with a boolean data

00:21:29,760 --> 00:21:35,200
field

00:21:31,760 --> 00:21:36,320
lastly right now funnies 2 takes

00:21:35,200 --> 00:21:39,440
advantage of

00:21:36,320 --> 00:21:41,440
of java's pass by reference by default

00:21:39,440 --> 00:21:43,039
in order to avoid having to teach

00:21:41,440 --> 00:21:46,400
students how to

00:21:43,039 --> 00:21:48,240
properly manage scoping of variables

00:21:46,400 --> 00:21:49,600
this is something that we must work

00:21:48,240 --> 00:21:52,799
around in rust

00:21:49,600 --> 00:21:55,600
but again this is this is a good habit

00:21:52,799 --> 00:21:56,559
that students must be able to develop

00:21:55,600 --> 00:21:58,480
anyways

00:21:56,559 --> 00:22:00,960
so this could actually be another

00:21:58,480 --> 00:22:03,679
advantage

00:22:00,960 --> 00:22:04,799
ultimately this was a great way to think

00:22:03,679 --> 00:22:07,120
about how

00:22:04,799 --> 00:22:08,640
an introductory link introductory

00:22:07,120 --> 00:22:11,760
computer science course

00:22:08,640 --> 00:22:14,320
written taught in rust might look like

00:22:11,760 --> 00:22:18,000
thank you guys so much for listening and

00:22:14,320 --> 00:22:18,000
i really appreciate you being here

00:22:19,760 --> 00:22:29,520
excellent all right

00:22:26,159 --> 00:22:32,720
interesting we've also often considered

00:22:29,520 --> 00:22:34,799
um here in latin america as

00:22:32,720 --> 00:22:36,640
starting actually there are several

00:22:34,799 --> 00:22:40,000
universities teaching rust in

00:22:36,640 --> 00:22:42,240
several courses um but none none

00:22:40,000 --> 00:22:44,080
uh in basic courses so for example like

00:22:42,240 --> 00:22:45,760
you were saying uh concurrency

00:22:44,080 --> 00:22:46,960
and threading should be in advanced

00:22:45,760 --> 00:22:48,240
courses they're taught in that in

00:22:46,960 --> 00:22:49,760
advanced courses but

00:22:48,240 --> 00:22:52,840
but none you know like as a first

00:22:49,760 --> 00:22:54,159
programming language so a lot to think

00:22:52,840 --> 00:22:56,320
about

00:22:54,159 --> 00:22:57,600
yeah i i do think that there's a lot

00:22:56,320 --> 00:22:59,200
about um

00:22:57,600 --> 00:23:00,799
about that kind of stuff that is a

00:22:59,200 --> 00:23:02,240
little bit more complicated for students

00:23:00,799 --> 00:23:04,000
to learn especially in their first year

00:23:02,240 --> 00:23:06,320
of learning computer science

00:23:04,000 --> 00:23:07,600
and the instructors do a great job of

00:23:06,320 --> 00:23:09,200
making sure that they only learn that

00:23:07,600 --> 00:23:13,200
later on in their education

00:23:09,200 --> 00:23:16,320
so i think that that's a good plan

00:23:13,200 --> 00:23:19,840
right um so one of our questions is

00:23:16,320 --> 00:23:20,880
um would rust be a better fit for such a

00:23:19,840 --> 00:23:23,360
course or

00:23:20,880 --> 00:23:24,799
do you think we should introduce things

00:23:23,360 --> 00:23:25,919
through first through a more basic

00:23:24,799 --> 00:23:28,960
language like go

00:23:25,919 --> 00:23:29,440
to ease into resource management i mean

00:23:28,960 --> 00:23:31,440
i

00:23:29,440 --> 00:23:32,720
i also write go and i think it's a great

00:23:31,440 --> 00:23:34,880
language um

00:23:32,720 --> 00:23:36,640
but ultimately there are some issues

00:23:34,880 --> 00:23:38,720
with go still

00:23:36,640 --> 00:23:40,080
you do have things like the linter being

00:23:38,720 --> 00:23:42,880
able to

00:23:40,080 --> 00:23:43,679
make sure that people check their error

00:23:42,880 --> 00:23:46,400
returns

00:23:43,679 --> 00:23:47,600
but you still have the possibility of if

00:23:46,400 --> 00:23:49,279
you don't have the linter

00:23:47,600 --> 00:23:50,640
then you may not be checking to make

00:23:49,279 --> 00:23:54,799
sure that error is uh

00:23:50,640 --> 00:23:57,039
nil and so with rust monadic

00:23:54,799 --> 00:23:58,799
option type and result type i think that

00:23:57,039 --> 00:24:00,320
that's a great way to

00:23:58,799 --> 00:24:01,919
kind of make sure that students are

00:24:00,320 --> 00:24:05,120
always building that habit and they

00:24:01,919 --> 00:24:08,240
don't really have any workarounds

00:24:05,120 --> 00:24:11,120
right another um suggestion

00:24:08,240 --> 00:24:12,400
question was why not teach students how

00:24:11,120 --> 00:24:15,279
memory actually works

00:24:12,400 --> 00:24:16,240
from the start why shield them from the

00:24:15,279 --> 00:24:17,679
complications

00:24:16,240 --> 00:24:20,240
and not understand the difference

00:24:17,679 --> 00:24:23,440
between stack and heap for example

00:24:20,240 --> 00:24:25,039
um so right now in my uh in the

00:24:23,440 --> 00:24:25,679
curriculum for the computer science

00:24:25,039 --> 00:24:27,840
students

00:24:25,679 --> 00:24:28,960
um that's just simply how it is uh you

00:24:27,840 --> 00:24:32,880
don't really learn

00:24:28,960 --> 00:24:35,120
um the the ideas of stack and heap

00:24:32,880 --> 00:24:36,400
until computer systems the course that i

00:24:35,120 --> 00:24:39,840
was talking about

00:24:36,400 --> 00:24:41,840
um and i think that that's good um

00:24:39,840 --> 00:24:43,840
especially when you get into like

00:24:41,840 --> 00:24:46,960
threading and posting style

00:24:43,840 --> 00:24:49,440
uh uh programming and manual

00:24:46,960 --> 00:24:50,960
stack versus heap right now uh the

00:24:49,440 --> 00:24:51,520
introductory courses are taught in

00:24:50,960 --> 00:24:54,559
racket

00:24:51,520 --> 00:24:56,159
and um and java and you don't really

00:24:54,559 --> 00:24:57,120
have to worry about the stack versus the

00:24:56,159 --> 00:25:00,240
heap in there

00:24:57,120 --> 00:25:02,880
um so i think that it's good to

00:25:00,240 --> 00:25:04,240
still wait until later to worry about

00:25:02,880 --> 00:25:07,440
stack versus heap

00:25:04,240 --> 00:25:10,240
but uh unfortunately because of russ

00:25:07,440 --> 00:25:11,440
still manual memory management that's

00:25:10,240 --> 00:25:12,799
got to be something that has to be

00:25:11,440 --> 00:25:15,039
worked around

00:25:12,799 --> 00:25:16,880
right right um not to put my own

00:25:15,039 --> 00:25:18,720
commentary but i guess it boils down to

00:25:16,880 --> 00:25:20,640
the difference in two schools one is

00:25:18,720 --> 00:25:22,880
teaching programming from the machine up

00:25:20,640 --> 00:25:23,679
and the other from programming concepts

00:25:22,880 --> 00:25:26,320
down

00:25:23,679 --> 00:25:26,799
right yeah that's exactly the approach

00:25:26,320 --> 00:25:28,320
that the

00:25:26,799 --> 00:25:29,520
instructors at my school take they want

00:25:28,320 --> 00:25:31,919
to make sure that students have the

00:25:29,520 --> 00:25:34,159
fundamental ideas of

00:25:31,919 --> 00:25:36,159
computer science first implementing

00:25:34,159 --> 00:25:37,840
algorithms making sure that

00:25:36,159 --> 00:25:39,679
their code works properly all of their

00:25:37,840 --> 00:25:40,720
logic and then eventually they get

00:25:39,679 --> 00:25:43,840
deeper into the

00:25:40,720 --> 00:25:47,279
machine level ideas

00:25:43,840 --> 00:25:48,640
cool um what missing features uh rust

00:25:47,279 --> 00:25:50,400
feature would you

00:25:48,640 --> 00:25:52,400
do you think would most improve

00:25:50,400 --> 00:25:55,039
teachability

00:25:52,400 --> 00:25:56,960
uh it's the manual measure manual memory

00:25:55,039 --> 00:26:00,480
management i think that's the biggest

00:25:56,960 --> 00:26:02,400
problem um so i think that

00:26:00,480 --> 00:26:03,919
that is what ultimately hurts the

00:26:02,400 --> 00:26:06,000
teachability of rust

00:26:03,919 --> 00:26:07,760
uh from the start you can get around

00:26:06,000 --> 00:26:08,640
lifetimes you can get around reference

00:26:07,760 --> 00:26:11,679
passing

00:26:08,640 --> 00:26:13,760
but having to have

00:26:11,679 --> 00:26:15,200
for example like i showed the recursive

00:26:13,760 --> 00:26:18,480
data definitions

00:26:15,200 --> 00:26:20,720
having those is so hard to

00:26:18,480 --> 00:26:21,919
avoid teaching about stack versus the

00:26:20,720 --> 00:26:23,919
heap when

00:26:21,919 --> 00:26:25,039
right now again that's taught later in

00:26:23,919 --> 00:26:27,919
the curriculum

00:26:25,039 --> 00:26:30,000
so i think that that's the part that

00:26:27,919 --> 00:26:32,240
hurts the teachability the best

00:26:30,000 --> 00:26:33,200
right of memory can't live with it can't

00:26:32,240 --> 00:26:36,400
live without it

00:26:33,200 --> 00:26:38,400
seriously all right

00:26:36,400 --> 00:26:39,520
well colton thank you so much for your

00:26:38,400 --> 00:26:41,520
talk

00:26:39,520 --> 00:26:44,480
thank you so much i really uh

00:26:41,520 --> 00:26:46,320
appreciated being here

00:26:44,480 --> 00:26:47,440
likewise and if you want to answer more

00:26:46,320 --> 00:26:48,240
questions so you can hang around in the

00:26:47,440 --> 00:26:50,720
chat

00:26:48,240 --> 00:26:53,840
all right sounds good thank you guys

00:26:50,720 --> 00:26:53,840

YouTube URL: https://www.youtube.com/watch?v=pR43XBBzvSc


