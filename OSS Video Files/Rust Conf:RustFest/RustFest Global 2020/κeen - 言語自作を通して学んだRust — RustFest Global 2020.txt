Title: κeen - 言語自作を通して学んだRust — RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	English title: Rust learned through self-made languages

本講演では言語自作を通して学んできたことをベースに、Rustに入門したての段階でのありがちなトラブルや意外と知られていない機能、Rustコンパイラの進化などを紹介します。Rustの入門体験記は色々ありますが、1つのテーマに沿って何度もプログラムを書いたことで徐々に問題へのアプローチが上手くなっていく点や、言語実装者が新たな言語を学んでいくという側面にも触れられたらなと思います。

More at https://rustfest.global/session/19-%E8%A8%80%E8%AA%9E%E8%87%AA%E4%BD%9C%E3%82%92%E9%80%9A%E3%81%97%E3%81%A6%E5%AD%A6%E3%82%93%E3%81%A0rust/
Captions: 
	00:01:02,166 --> 00:01:04,166
Let’s begin.

00:01:04,166 --> 00:01:08,416
The title of this presentation is ‘Rust: Learning Through the Language Itself’.

00:01:09,500 --> 00:01:11,500
My name is Keen.

00:01:11,500 --> 00:01:17,541
I have a Twitter and GitHub account and use Rust at the company, Idein.

00:01:17,750 --> 00:01:21,916
The image on the right is my Twitter and GitHub icon.

00:01:21,916 --> 00:01:26,208
I’m the author of ‘A Practical Introduction to Rust’ published in Japan.

00:01:26,416 --> 00:01:33,541
I helped translate the initial Rust programming language and their old official website.

00:01:36,500 --> 00:01:44,250
Before my introduction to Rust, I created various Toy languages.

00:01:44,250 --> 00:01:50,458
For example, I made a schema-implementation commit, created a Scala-type Lisp,

00:01:50,458 --> 00:01:54,500
and wrote a whitespace complier.

00:01:54,541 --> 00:01:58,750
I like functional programming languages like ML and Lisp.

00:01:58,791 --> 00:02:05,125
This is because algebraic data types and pattern matching are suitable for writing an interpreter.

00:02:05,375 --> 00:02:09,583
I moderately like C, since you can quickly use it as a beginner.

00:02:11,666 --> 00:02:16,666
But functional programming languages and C have pros and cons.

00:02:16,666 --> 00:02:22,416
Functional languages have potential and are safe since they are ADT and pattern matching.

00:02:22,416 --> 00:02:26,625
But they’re not good for quick interpreters due to its runtime.

00:02:26,625 --> 00:02:31,583
Conversely, C is quick and has no runtime, but it’s not safe.

00:02:31,583 --> 00:02:38,041
I was searching for an ADT and pattern matching language that was safe, quick, and had no runtime.

00:02:39,125 --> 00:02:42,041
One day, I came across Rust.

00:02:42,041 --> 00:02:48,416
This was during Rust 0.12.0 just before 1.0 alpha was released.

00:02:48,416 --> 00:02:54,833
Rust came with all the functions I listed, so I could use it to create languages.

00:02:55,625 --> 00:03:01,041
These are several of the languages I created with it: First, I created a Lisp dialect,

00:03:01,041 --> 00:03:07,000
then after a year, a shell script, a Rust-type small Lisp, a SML complier,

00:03:07,000 --> 00:03:11,166
and an in-memory WebAssembly assembler.

00:03:11,166 --> 00:03:15,500
Then, after a year, I created an alt JSON Schema.

00:03:15,500 --> 00:03:20,000
There were others, but we’ll leave this for now.

00:03:22,250 --> 00:03:32,125
I wanted to talk about all of them, but I only have time to introduce the key takeaways from three languages.

00:03:32,666 --> 00:03:37,333
These are the three languages. I learned the basics from kLisp.

00:03:38,083 --> 00:03:42,500
Then I learned maintenance through WebML.

00:03:42,750 --> 00:03:46,666
Finally, I learned how to make a product with chema.

00:03:46,666 --> 00:03:49,458
I'd like to talk about these three cases.

00:03:50,125 --> 00:03:56,833
Let’s start with kLisp. This was created to interpret SKKLisp.

00:03:56,833 --> 00:04:04,208
SKK is a Japanese-language input method, but it’s irrelevant to this discussion.

00:04:04,208 --> 00:04:11,000
This was my first project with Rust. Initially I was keen to create this in four days.

00:04:11,000 --> 00:04:16,666
In Japan there’s a four-day holiday in fall, so I wanted to create this then.

00:04:17,083 --> 00:04:21,958
I thought it’d just take 4 days because I had created many Lisp-types before.

00:04:22,625 --> 00:04:25,458
The code on this slide is kLisp.

00:04:25,458 --> 00:04:33,541
I called it with a SKK gadget unit conversion function to do a calculation to convert miles to kilometers.

00:04:36,208 --> 00:04:42,041
Writing an interpreter requires the basic functions of the host language.

00:04:42,041 --> 00:04:49,666
For example, the language function requires structure, method, enums, and pattern matches.

00:04:50,166 --> 00:04:54,291
The standard library requires iterators and HashMap.

00:04:54,291 --> 00:04:59,208
I wrote an interpreter while commanding these basic functions.

00:05:01,208 --> 00:05:03,208
This ended in failure.

00:05:04,083 --> 00:05:06,041
It wasn’t finished in 4 days.

00:05:06,041 --> 00:05:09,750
The reason for this failure was several challenges.

00:05:10,041 --> 00:05:16,625
Specifically, they were garbage collection, lifetime or ownership, and error handling.

00:05:16,791 --> 00:05:21,041
This is when I discovered Rust is a difficult language.

00:05:22,625 --> 00:05:25,625
This is what set me back with GC.

00:05:25,625 --> 00:05:33,541
I expressed the Lisp expression with the enum Expr, using Box in the pointer that appears here.

00:05:37,541 --> 00:05:46,333
The code snippet below defines the enum Expr. Then, the second variation holds two pointers with Cons.

00:05:46,333 --> 00:05:49,333
I used Box in these pointers.

00:05:50,583 --> 00:05:54,708
This didn't work because Rust has no GC.

00:05:54,708 --> 00:05:59,458
That slipped my mind, since functional languages have GC.

00:06:00,625 --> 00:06:08,541
This failed because the value of Box in Rust was private, but my implemented Lisp had a sharable value.

00:06:08,541 --> 00:06:11,916
Instead of Box, RC needs to be used.

00:06:11,916 --> 00:06:16,708
Reference Counting (RC) will manage your data.

00:06:17,208 --> 00:06:26,666
The code snippet below is almost the same as before, but the pointer held by Cons is replaced by RC.

00:06:26,666 --> 00:06:28,666
This is the correct approach.

00:06:30,750 --> 00:06:33,583
The next issue was lifetime or ownership.

00:06:34,000 --> 00:06:38,458
This was a new concept for me, and maybe for you too.

00:06:39,333 --> 00:06:47,041
When defining the function, writing is simplified by taking ownership with arguments, but calling is harder.

00:06:48,625 --> 00:06:52,208
Let’s look at the Eval function on this slide.

00:06:52,208 --> 00:07:03,458
The top Eval has &Mut, Env, and &Expr in its arguments. The second argument is referenced.

00:07:03,458 --> 00:07:14,250
The bottom Eval has &Mut and Expr in its arguments. The second argument is not referenced.

00:07:15,083 --> 00:07:30,333
The top with a referenced argument requires a clone to define it but is easily called with just the value.

00:07:30,333 --> 00:07:41,000
The bottom is handy requiring no clone to define it, but calling the Eval is complicated and requires a clone.

00:07:41,000 --> 00:07:45,166
At that time, I wasn’t sure which configuration was right.

00:07:46,500 --> 00:07:50,541
Eventually, I realized the overall configuration was important.

00:07:50,541 --> 00:07:57,291
The data is registered in its runtime, which is why it has to keep running until the execution is complete.

00:07:57,291 --> 00:08:00,500
Thus, you cannot take ownership of it.

00:08:01,416 --> 00:08:05,125
At the same time, the borrow checker is lexical.

00:08:05,125 --> 00:08:11,250
I got an error when typing Get and Insert for the famous HashMap.

00:08:12,541 --> 00:08:18,458
The third issue was error handling. I had no clue what I should do.

00:08:18,625 --> 00:08:22,333
The initial code used Panic in various places.

00:08:22,333 --> 00:08:33,000
The code snippet below defines the k_add_aux function. The return value of the function is Expr.

00:08:36,583 --> 00:08:46,125
I used Panic for unexpected data in the function itself when executing a pattern match for the argument.

00:08:48,166 --> 00:08:53,125
If that didn’t provide the correct value, I started to use Option.

00:08:53,125 --> 00:09:03,000
The code snippet below defines the read_aux function. The return type of the function is Option.

00:09:04,708 --> 00:09:14,000
Next, I learned how to use a result type for errors. I tried it, but all the errors had String in it.

00:09:14,000 --> 00:09:24,750
The code snippet below defines the k_funcall function. The return type is Result.

00:09:24,750 --> 00:09:35,916
I used Err(format!()) for unexpected data in the function when executing a pattern match for the argument.

00:09:37,375 --> 00:09:40,333
At last, I understood the correct method.

00:09:40,333 --> 00:09:44,416
I read Andrew Gallant’s blog, ‘Error Handling in Rust’.

00:09:44,416 --> 00:09:48,666
I memorized the definition of each error type through this blog.

00:09:49,083 --> 00:09:57,791
The code snippet below defines the enum called Error and expresses the error occurring in kLisp with a variant.

00:09:59,333 --> 00:10:05,833
The key takeaway from kLisp was the basics of Rust. Then I learned it has several pointers.

00:10:07,375 --> 00:10:16,666
I used references, boxes, and RC with kLisp. I also learned about ownership, lifetime, and data configuration.

00:10:16,666 --> 00:10:19,416
Finally, I learned about error handling.

00:10:20,208 --> 00:10:22,208
Next is WebML.

00:10:23,666 --> 00:10:32,833
WebML is a Standard ML to WebAssembly complier. WebAssembler-rs was a side project for this.

00:10:32,833 --> 00:10:40,083
This was my largest hobby project. It’s also my Bonsai project.

00:10:40,375 --> 00:10:45,708
This image is a Bonsai tree, which you take care of over a long time.

00:10:45,708 --> 00:10:53,833
Just like a Bonsai tree, I kept working on this project, taking care of it when I had some time.

00:10:56,083 --> 00:11:05,833
The colossal size makes creating WebML difficult. The gigantic code base must be well-organized.

00:11:05,833 --> 00:11:14,083
Also, the syntax of SML is more complicated than Lisp, so unlike Lisp you can’t handwrite a parser.

00:11:14,416 --> 00:11:18,958
Finally, many types are quite similar to a complier.

00:11:19,166 --> 00:11:26,000
A complier can be tricky in the first place, but this talk will focus on just three points.

00:11:27,083 --> 00:11:31,208
SML has syntax like in the code written on this slide.

00:11:31,208 --> 00:11:41,416
First, Infix /::/ \::\ in the first line announces that it’s the infix operator.

00:11:41,416 --> 00:11:54,375
This can create an infix operator within Operator. It defines the infix operator for \: as fun innit\:operator

00:11:54,375 --> 00:12:02,458
The formal argument is defined on the right and left. This unusual syntax is SML.

00:12:04,583 --> 00:12:12,458
Code organization is the timing to use submodules, which is also called Directory/mod.rs.

00:12:12,458 --> 00:12:14,458
It was complicated.

00:12:14,833 --> 00:12:23,041
I wanted to announce mod.a within b.rs but couldn’t, so I didn’t know where to put mod.rs.

00:12:23,041 --> 00:12:28,208
I eventually figured this out through trial and error and compiled this in my blog.

00:12:30,291 --> 00:12:35,750
Next let’s look at parsers. The SML parser is not a handwritten one.

00:12:35,750 --> 00:12:41,125
I used a parser combinator library. Namely, Nom.

00:12:41,125 --> 00:12:46,041
At the time, it was Version 2.0, which was full of macros.

00:12:46,041 --> 00:12:52,041
There was no impl Trait then, so its performance was at this level.

00:12:52,250 --> 00:12:56,000
On this slide is the parser code using Nom.

00:12:57,541 --> 00:13:11,083
In the Named! macro argument was do_parse!, separated_list, and opt!. There are too many macros.

00:13:11,083 --> 00:13:15,208
The number of macros on the API document are impressive.

00:13:20,250 --> 00:13:26,666
This is the Nom API document. An impressive number of macros are defined in the macro column.

00:13:28,250 --> 00:13:34,250
This isn’t a matter of 10 or 20. Rather 50 to 100 macros are defined.

00:13:40,666 --> 00:13:47,291
I write a parser using this, but the error messages in the macros were difficult to understand or debug.

00:13:47,791 --> 00:13:55,000
There’s a wide variety of types. Many of the compliers are similar but have subtle differences.

00:13:55,000 --> 00:14:01,500
For example, UntypedExpr, UntypedCoreExpr, and TypedCoreExpr.

00:14:02,166 --> 00:14:09,250
All of these are rather big and have over 10 variants. At first, I wrote these by hand.

00:14:10,375 --> 00:14:15,083
Through trial and error, I realized I could do something with a type alias.

00:14:15,708 --> 00:14:21,625
The code inserted below is a bit of a mess, but it’s a solution using a type alias.

00:14:21,958 --> 00:14:28,541
This prepares an Explorer type to change its behavior with the type parameter.

00:14:36,458 --> 00:14:46,083
Type parameters are named by their desired behavior. I.e. Untyped Expr allows Empty in Expr.

00:14:46,083 --> 00:15:02,625
In CoreExpr, Empty is allowed by UntypedCoreExpr and Type is allowed by TypedCoreExpr.

00:15:05,958 --> 00:15:11,958
The Rust-type alias are flexible so they can easily be defined.

00:15:12,541 --> 00:15:21,458
For example, CoreExpr is an Expr alias as well as an alias for UntypedCoreExpr and TypedCoreExpr.

00:15:22,125 --> 00:15:33,333
To define the method in both UntypedCoreExpr and TypedCoreExpr, you just add CoreExpr to impl.

00:15:34,041 --> 00:15:44,875
Traits like Display implemented in all Expr should be given a type parameter in the generics.

00:15:49,083 --> 00:15:57,250
The key takeaway from WebML was that my experience with interpreters is helpful to create a complier.

00:15:57,250 --> 00:16:02,791
Internal data types and lifetime configuration were straightforward.

00:16:02,958 --> 00:16:11,666
As mentioned, the module system was complex and debugging a code written with macros is tricky.

00:16:11,666 --> 00:16:19,541
I learned you want to use impl Trait asap. Also, I found the Rust system is great.

00:16:21,000 --> 00:16:32,166
This is a slight digression, but when I switched to this job where I used Rust at work, my skills skyrocketed.

00:16:32,166 --> 00:16:35,125
This is when I moved onto chema.

00:16:36,500 --> 00:16:47,000
Chema is pronounced like Schema without the ‘s’. It’s an Json Schema complier from an original notation.

00:16:47,000 --> 00:16:51,291
It can also be called an alt JSON Schema.

00:16:51,708 --> 00:16:57,083
This had to be useable since it was for a company project.

00:16:57,250 --> 00:17:10,250
Below is a description of chema. You write a comment with /* ~ / and define the type with Type name =.

00:17:13,208 --> 00:17:21,000
First, chema requires you to create a complier. At that point, this was not a problem for me.

00:17:21,666 --> 00:17:31,541
I focused on elements that didn’t work on WebML and then brought them back home to WebML.

00:17:31,541 --> 00:17:36,458
Also, I had to release a command line interface and binary.

00:17:36,458 --> 00:17:44,875
My colleagues would be collaboratively using this, so it needed an enriched command line interface.

00:17:44,875 --> 00:17:55,500
This means a command line argument parser is needed. I adopted StructOpt. Here is code using StructOpt.

00:17:55,500 --> 00:18:04,625
You add #[derive(StructOpt)] to the structure definition and command the #[structopt()] attribute in each field definition.

00:18:05,875 --> 00:18:14,833
Long and Help were typed in the attributes. Long commands a long list of options.

00:18:14,833 --> 00:18:23,708
This commands no-swagger, so it commands an option written as “no-swagger”.

00:18:24,333 --> 00:18:34,208
Help is the message that appears with “help”. The help message is generated with StructOpt.

00:18:34,958 --> 00:18:45,125
As explained, “no-swagger” and input file are generated.

00:18:46,916 --> 00:18:49,458
Next is the binary release.

00:18:49,458 --> 00:18:56,375
Creating distributions and uploading it to GitHub is time consuming. Cross-compiling is also an issue.

00:18:56,541 --> 00:19:02,541
CI alone won’t do, so I incorporated Trust.

00:19:02,541 --> 00:19:09,958
Trust easily creates binary releases for complicated targets using a Travis CI template configuration.

00:19:12,916 --> 00:19:15,875
Let's look at the release of chema.

00:19:18,083 --> 00:19:22,750
As this shows, you can easily create releases, like this, on various platforms.

00:19:22,750 --> 00:19:37,708
For example, you can create the binaries aarch64 on linux, X8664 on linux, X86 on apple darwin, or X8664 on netbsd.

00:19:40,750 --> 00:19:46,416
The key takeaway from chema is that some tweaking is required to create a product.

00:19:46,416 --> 00:19:51,000
Also, it comes with what you need to tweak it.

00:19:52,250 --> 00:19:59,041
Let’s review a bit before concluding. I developed my skills as I wrote various languages.

00:19:59,041 --> 00:20:02,500
At first, I kept wondering how to write with Rust.

00:20:02,500 --> 00:20:10,333
Then I became more attentive to what the overall code should be and how to release it as an entire project.

00:20:10,333 --> 00:20:18,833
Some you may have noticed this, but the Rust update solved several of the obstacles I encountered.

00:20:18,833 --> 00:20:24,250
The Impl trait I set to memory were released with 1.26.0

00:20:25,000 --> 00:20:31,291
The complicated module system and inflexible lifetime was solved with the 2018 edition.

00:20:34,125 --> 00:20:42,666
To summarize, you can discover most elements of Rust by first trying to write a Lisp interpreter.

00:20:42,666 --> 00:20:52,166
You can slowly dig into these details from any approach by grappling with the same issue repeatedly.

00:20:52,166 --> 00:21:02,791
Once you have the overview you can get into the specifics. Finally, Rust is a continually evolving language.

00:21:03,375 --> 00:21:05,375

YouTube URL: https://www.youtube.com/watch?v=GtcZ0ZOcO5w


