Title: Max Orok - Considering Rust for scientific software  â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	This talk is about how Rust can help you write fast, correct scientific software. We'll investigate what makes Rust a viable alternative to the the conventional choices of Python and C++ but will also take a look at the challenges and potential downsides of choosing Rust for your next project.

More at https://rustfest.global/session/6-considering-rust-for-scientific-software/
Captions: 
	00:00:03,199 --> 00:00:07,440
max auroch

00:00:04,160 --> 00:00:10,559
shows science not fiction and rust

00:00:07,440 --> 00:00:13,200
ain't no contradiction it sure won't

00:00:10,559 --> 00:00:17,920
spill your beans so use it by all means

00:00:13,200 --> 00:00:17,920
if permitted by your jurisdiction

00:00:18,880 --> 00:00:23,199
hello everyone my name is max oreck and

00:00:21,359 --> 00:00:25,039
this is a talk called considering rust

00:00:23,199 --> 00:00:26,960
for scientific software

00:00:25,039 --> 00:00:28,240
and this talk is for people who are

00:00:26,960 --> 00:00:30,080
interested in rust

00:00:28,240 --> 00:00:31,760
or are maybe looking for an alternative

00:00:30,080 --> 00:00:34,000
language for their

00:00:31,760 --> 00:00:34,960
programs or research and we're going to

00:00:34,000 --> 00:00:37,200
be talking about the

00:00:34,960 --> 00:00:39,840
current scientific computing ecosystem

00:00:37,200 --> 00:00:41,440
but also rust's place in this ecosystem

00:00:39,840 --> 00:00:43,440
and where it can help researchers write

00:00:41,440 --> 00:00:45,840
good code

00:00:43,440 --> 00:00:48,399
i am a mechanical engineering master

00:00:45,840 --> 00:00:50,559
student at the university of ottawa

00:00:48,399 --> 00:00:52,160
and i'm working as a radiation modeling

00:00:50,559 --> 00:00:55,280
researcher

00:00:52,160 --> 00:00:56,160
my primary tool here is actually c plus

00:00:55,280 --> 00:00:58,800
plus

00:00:56,160 --> 00:01:00,559
but i've been using rust for about a

00:00:58,800 --> 00:01:03,280
year and a half

00:01:00,559 --> 00:01:03,920
i'm also a contract software developer

00:01:03,280 --> 00:01:06,240
for

00:01:03,920 --> 00:01:07,119
a company called mevx which is a

00:01:06,240 --> 00:01:10,799
canadian

00:01:07,119 --> 00:01:13,280
linear accelerator manufacturer

00:01:10,799 --> 00:01:14,640
so uh scientific software is sort of an

00:01:13,280 --> 00:01:16,159
interesting

00:01:14,640 --> 00:01:17,759
case where you have these very strict

00:01:16,159 --> 00:01:19,920
requirements but

00:01:17,759 --> 00:01:20,880
um oftentimes it's written by a very

00:01:19,920 --> 00:01:23,920
small team

00:01:20,880 --> 00:01:25,759
maybe even one person or a couple people

00:01:23,920 --> 00:01:27,360
and they have very limited time and

00:01:25,759 --> 00:01:28,560
resources because usually they have

00:01:27,360 --> 00:01:31,439
other commitments

00:01:28,560 --> 00:01:32,640
maybe they're professors or students or

00:01:31,439 --> 00:01:36,720
researchers

00:01:32,640 --> 00:01:38,240
and this is actually a case where

00:01:36,720 --> 00:01:40,320
correctness of the software is very

00:01:38,240 --> 00:01:42,159
important so it's

00:01:40,320 --> 00:01:44,880
uh it's possible that scientific papers

00:01:42,159 --> 00:01:47,680
will be published based on the results

00:01:44,880 --> 00:01:49,200
and it's important more so than in other

00:01:47,680 --> 00:01:50,720
fields that we

00:01:49,200 --> 00:01:52,640
try and make sure our programs are as

00:01:50,720 --> 00:01:55,280
bug-free as possible

00:01:52,640 --> 00:01:56,079
especially when sort of research is sort

00:01:55,280 --> 00:01:59,200
of on the line

00:01:56,079 --> 00:02:00,159
based on these results but it's also an

00:01:59,200 --> 00:02:01,920
area where

00:02:00,159 --> 00:02:03,680
performance of programs is very

00:02:01,920 --> 00:02:06,479
important because

00:02:03,680 --> 00:02:07,600
if your program takes forever to run it

00:02:06,479 --> 00:02:08,000
usually means that you're going to have

00:02:07,600 --> 00:02:10,800
a lot more

00:02:08,000 --> 00:02:13,120
trouble sort of iterating or maybe

00:02:10,800 --> 00:02:15,120
running a different kind of analysis

00:02:13,120 --> 00:02:16,720
and it's usually a very good thing when

00:02:15,120 --> 00:02:18,560
your program runs quickly

00:02:16,720 --> 00:02:21,200
because you know that means a lot of

00:02:18,560 --> 00:02:23,840
people can do their jobs a lot quicker

00:02:21,200 --> 00:02:25,520
especially if requirements change and

00:02:23,840 --> 00:02:27,680
you have to redo a bunch of analysis

00:02:25,520 --> 00:02:30,720
work

00:02:27,680 --> 00:02:32,000
so sort of the final thing with with

00:02:30,720 --> 00:02:34,480
scientific software is that

00:02:32,000 --> 00:02:35,599
the developers usually have other jobs

00:02:34,480 --> 00:02:36,959
and

00:02:35,599 --> 00:02:38,800
writing software might just be part of

00:02:36,959 --> 00:02:40,560
someone's job and they don't actually

00:02:38,800 --> 00:02:43,519
consider themselves to be

00:02:40,560 --> 00:02:44,560
expert software engineers so these might

00:02:43,519 --> 00:02:47,440
be people who

00:02:44,560 --> 00:02:48,879
are primarily physicists or chemists and

00:02:47,440 --> 00:02:51,920
biologists

00:02:48,879 --> 00:02:53,760
or engineers as well and for a lot of

00:02:51,920 --> 00:02:54,800
people programs are just a means to an

00:02:53,760 --> 00:02:57,920
end

00:02:54,800 --> 00:02:59,360
and sometimes

00:02:57,920 --> 00:03:01,519
sort of good software engineering

00:02:59,360 --> 00:03:03,360
practices are thrown out the window so

00:03:01,519 --> 00:03:04,560
sometimes compilation of a program or

00:03:03,360 --> 00:03:06,560
interpretation

00:03:04,560 --> 00:03:09,200
is the first and last unit test that it

00:03:06,560 --> 00:03:11,440
gets and there's also this idea that

00:03:09,200 --> 00:03:13,200
if it works don't touch it which i think

00:03:11,440 --> 00:03:16,720
is sort of a negative idea

00:03:13,200 --> 00:03:18,480
and i think we should be able to

00:03:16,720 --> 00:03:20,720
have the ability to refactor our

00:03:18,480 --> 00:03:24,480
programs to add new features

00:03:20,720 --> 00:03:26,080
or to improve the performance and

00:03:24,480 --> 00:03:27,920
this is sort of an idea i think we need

00:03:26,080 --> 00:03:31,200
to combat especially when we build our

00:03:27,920 --> 00:03:33,519
own software for people to use

00:03:31,200 --> 00:03:35,120
um so working in the radiation field and

00:03:33,519 --> 00:03:37,280
sort of going to engineering school

00:03:35,120 --> 00:03:38,879
there's the standard case study of the

00:03:37,280 --> 00:03:42,080
therac-25

00:03:38,879 --> 00:03:43,840
and um and sort of the the issues with

00:03:42,080 --> 00:03:45,680
it so the therap-25

00:03:43,840 --> 00:03:47,680
was a radiation therapy device

00:03:45,680 --> 00:03:48,959
manufactured by atomic energy of canada

00:03:47,680 --> 00:03:51,519
limited

00:03:48,959 --> 00:03:54,799
and it was part of six major accidents

00:03:51,519 --> 00:03:57,120
between 1985 and 1987

00:03:54,799 --> 00:03:58,560
and i don't want to minimize the issues

00:03:57,120 --> 00:04:01,760
with this project so there were

00:03:58,560 --> 00:04:02,799
a number of sort of complex factors that

00:04:01,760 --> 00:04:06,239
went into

00:04:02,799 --> 00:04:08,799
the problems that the therap-25 had

00:04:06,239 --> 00:04:10,959
you know there were management issues or

00:04:08,799 --> 00:04:12,720
you know project oversight issues

00:04:10,959 --> 00:04:14,080
and allegedly there was only one

00:04:12,720 --> 00:04:17,199
developer who did the entire

00:04:14,080 --> 00:04:20,239
software for this machine but

00:04:17,199 --> 00:04:21,040
also investigators did find that data

00:04:20,239 --> 00:04:24,800
races

00:04:21,040 --> 00:04:26,560
or concurrency bugs in the thera-25

00:04:24,800 --> 00:04:29,919
control software

00:04:26,560 --> 00:04:31,919
contributed to the accidents and i think

00:04:29,919 --> 00:04:33,520
this just goes to show a little bit that

00:04:31,919 --> 00:04:35,199
software bugs do have real world

00:04:33,520 --> 00:04:38,240
consequences

00:04:35,199 --> 00:04:40,080
and usually it's not this serious you

00:04:38,240 --> 00:04:43,120
know maybe we just have to rerun

00:04:40,080 --> 00:04:46,479
our our code to do another uh

00:04:43,120 --> 00:04:49,360
analysis job but it is the case that

00:04:46,479 --> 00:04:50,800
software does affect real people and um

00:04:49,360 --> 00:04:53,759
we have to be careful to

00:04:50,800 --> 00:04:55,680
try and avoid bugs as much as possible

00:04:53,759 --> 00:04:58,160
so

00:04:55,680 --> 00:05:00,800
moving on to the the existing scientific

00:04:58,160 --> 00:05:02,880
landscape we have

00:05:00,800 --> 00:05:04,880
python is sort of the lingua franca or

00:05:02,880 --> 00:05:06,880
the language that everybody speaks

00:05:04,880 --> 00:05:08,800
and i think this is a very good thing

00:05:06,880 --> 00:05:10,400
because a lot of

00:05:08,800 --> 00:05:12,080
new programmers especially today their

00:05:10,400 --> 00:05:13,360
first language is python

00:05:12,080 --> 00:05:14,560
and it's important that they're able to

00:05:13,360 --> 00:05:16,479
write software in a language they're

00:05:14,560 --> 00:05:18,800
comfortable with

00:05:16,479 --> 00:05:21,120
but this also brings some problems

00:05:18,800 --> 00:05:23,199
because python is actually

00:05:21,120 --> 00:05:25,199
usually quite slow of a language and

00:05:23,199 --> 00:05:26,800
this is so when people need performance

00:05:25,199 --> 00:05:30,160
they start to reach for languages

00:05:26,800 --> 00:05:30,800
like c and c plus and these are sort of

00:05:30,160 --> 00:05:32,960
the

00:05:30,800 --> 00:05:34,720
bedrock systems programming languages

00:05:32,960 --> 00:05:36,560
that support python

00:05:34,720 --> 00:05:39,120
and here i'm sort of skipping over a lot

00:05:36,560 --> 00:05:41,440
of other languages so

00:05:39,120 --> 00:05:43,120
for things written in fortran and julia

00:05:41,440 --> 00:05:44,400
i think all these languages are

00:05:43,120 --> 00:05:46,400
very important and they definitely have

00:05:44,400 --> 00:05:49,680
their place but i'm not going to talk

00:05:46,400 --> 00:05:52,479
about them specifically here

00:05:49,680 --> 00:05:53,360
so an issue i have with the current

00:05:52,479 --> 00:05:55,280
landscape

00:05:53,360 --> 00:05:56,479
of of sort of scientific computing is

00:05:55,280 --> 00:05:58,800
that

00:05:56,479 --> 00:05:59,840
moving from python which is a lot of

00:05:58,800 --> 00:06:03,120
people's first language

00:05:59,840 --> 00:06:05,680
to something like c plus plus which is

00:06:03,120 --> 00:06:06,639
um you know sort of a more performance

00:06:05,680 --> 00:06:09,280
oriented

00:06:06,639 --> 00:06:09,919
expert level programming language this

00:06:09,280 --> 00:06:13,039
should be

00:06:09,919 --> 00:06:16,000
a natural step because many

00:06:13,039 --> 00:06:17,520
popular python libraries depend on c

00:06:16,000 --> 00:06:19,919
plus plus

00:06:17,520 --> 00:06:21,360
as sort of a back end language and

00:06:19,919 --> 00:06:22,080
they're actually written mostly in c

00:06:21,360 --> 00:06:24,479
plus plus and

00:06:22,080 --> 00:06:26,000
sort of wrapped up nicely in python for

00:06:24,479 --> 00:06:28,479
people to use

00:06:26,000 --> 00:06:29,759
and researcher time is usually very

00:06:28,479 --> 00:06:31,759
precious so

00:06:29,759 --> 00:06:33,280
a lot of people want to know how to

00:06:31,759 --> 00:06:34,560
speed up their code or get better

00:06:33,280 --> 00:06:37,600
performance

00:06:34,560 --> 00:06:39,280
and sometimes this is actually

00:06:37,600 --> 00:06:40,639
a very difficult thing to do in python

00:06:39,280 --> 00:06:42,960
it's necessary to move to another

00:06:40,639 --> 00:06:46,000
language

00:06:42,960 --> 00:06:48,000
like c plus plus but unfortunately right

00:06:46,000 --> 00:06:51,360
now this is a very difficult transition

00:06:48,000 --> 00:06:52,800
step and

00:06:51,360 --> 00:06:55,039
you know there's a lot of factors going

00:06:52,800 --> 00:06:56,560
on here and you know the two languages

00:06:55,039 --> 00:07:00,639
are very different

00:06:56,560 --> 00:07:03,759
have different goals but

00:07:00,639 --> 00:07:04,880
it is a problem because um

00:07:03,759 --> 00:07:06,880
you know i've definitely seen people

00:07:04,880 --> 00:07:07,199
leave projects because they don't feel

00:07:06,880 --> 00:07:09,199
they're

00:07:07,199 --> 00:07:10,880
they're up to the task or maybe they

00:07:09,199 --> 00:07:12,639
just abandon their efforts and and sort

00:07:10,880 --> 00:07:15,440
of keep using python

00:07:12,639 --> 00:07:17,360
and um i think here rust really starts

00:07:15,440 --> 00:07:18,479
to shine as a viable alternative to c

00:07:17,360 --> 00:07:20,880
plus plus

00:07:18,479 --> 00:07:22,479
because you can achieve the same or very

00:07:20,880 --> 00:07:25,440
similar performance

00:07:22,479 --> 00:07:27,280
but with a kinder sort of more gentle

00:07:25,440 --> 00:07:30,160
systems programming language

00:07:27,280 --> 00:07:30,720
explicitly designed for non-expert users

00:07:30,160 --> 00:07:32,479
and

00:07:30,720 --> 00:07:34,639
that's what a lot of scientific software

00:07:32,479 --> 00:07:37,199
developers identify as

00:07:34,639 --> 00:07:38,720
so i think it's sort of a very um

00:07:37,199 --> 00:07:41,120
important use case or

00:07:38,720 --> 00:07:42,560
possibility for rust as is sort of an

00:07:41,120 --> 00:07:45,599
alternative

00:07:42,560 --> 00:07:48,080
back-end implementation language to

00:07:45,599 --> 00:07:50,160
achieve certain performance goals

00:07:48,080 --> 00:07:51,759
um and then of course you know right

00:07:50,160 --> 00:07:52,879
away there are maybe some reasons not to

00:07:51,759 --> 00:07:55,440
use rust

00:07:52,879 --> 00:07:56,560
so uh given the comparative age of all

00:07:55,440 --> 00:07:59,280
the languages

00:07:56,560 --> 00:08:00,000
rust is relatively young it's only five

00:07:59,280 --> 00:08:01,840
years old

00:08:00,000 --> 00:08:03,840
or you know it's been five years since

00:08:01,840 --> 00:08:06,160
its 1.0 release

00:08:03,840 --> 00:08:08,879
and python is actually around 30 years

00:08:06,160 --> 00:08:09,919
old and c plus plus is around 40.

00:08:08,879 --> 00:08:12,720
and it's likely they're going to be

00:08:09,919 --> 00:08:14,800
around for a lot longer as well

00:08:12,720 --> 00:08:16,560
rust also has this notion of there being

00:08:14,800 --> 00:08:17,599
a bit of a learning curve associated

00:08:16,560 --> 00:08:19,360
with it

00:08:17,599 --> 00:08:21,840
but i will say i think it's easier to

00:08:19,360 --> 00:08:24,080
get up and running and writing

00:08:21,840 --> 00:08:25,759
good code in rust than it is in other

00:08:24,080 --> 00:08:26,000
languages so the compiler does a really

00:08:25,759 --> 00:08:29,280
good

00:08:26,000 --> 00:08:31,840
job of guiding you away from sort of

00:08:29,280 --> 00:08:31,840
unsafe

00:08:32,479 --> 00:08:36,479
ways of doing things and sort of more

00:08:35,599 --> 00:08:38,719
into

00:08:36,479 --> 00:08:40,320
sort of a correct way of doing things

00:08:38,719 --> 00:08:42,000
and

00:08:40,320 --> 00:08:43,440
especially for beginners i think this is

00:08:42,000 --> 00:08:45,279
very helpful um

00:08:43,440 --> 00:08:47,519
so i know that you know the first few

00:08:45,279 --> 00:08:49,279
months of my writing c plus plus

00:08:47,519 --> 00:08:51,200
it certainly wasn't very good and i was

00:08:49,279 --> 00:08:53,360
making all sorts of um

00:08:51,200 --> 00:08:55,120
sort of out of bounds errors and and

00:08:53,360 --> 00:08:57,839
other issues that just

00:08:55,120 --> 00:08:59,040
wouldn't happen and rust another issue

00:08:57,839 --> 00:09:00,480
of course is that

00:08:59,040 --> 00:09:02,560
you already have a large code base

00:09:00,480 --> 00:09:03,839
written in another language and the the

00:09:02,560 --> 00:09:05,360
saying is that you know

00:09:03,839 --> 00:09:07,440
a lot of times the the right tool for

00:09:05,360 --> 00:09:09,519
the job is the one you're already using

00:09:07,440 --> 00:09:11,120
and i think this is definitely the case

00:09:09,519 --> 00:09:13,760
and i don't think that people should be

00:09:11,120 --> 00:09:14,800
rewriting their projects completely but

00:09:13,760 --> 00:09:17,600
i would say

00:09:14,800 --> 00:09:18,320
you know maybe if there's uh if there's

00:09:17,600 --> 00:09:20,560
a new

00:09:18,320 --> 00:09:22,240
component and you're sort of looking for

00:09:20,560 --> 00:09:25,040
an alternative language i think rust is

00:09:22,240 --> 00:09:27,200
a really good choice for this

00:09:25,040 --> 00:09:28,560
another point might be that there is an

00:09:27,200 --> 00:09:30,560
important library that

00:09:28,560 --> 00:09:32,080
you depend on that's actually missing on

00:09:30,560 --> 00:09:33,920
the rest side of things

00:09:32,080 --> 00:09:36,080
and you know this is definitely a valid

00:09:33,920 --> 00:09:38,480
concern rust's ecosystem is

00:09:36,080 --> 00:09:40,080
smaller than that of python of course

00:09:38,480 --> 00:09:41,680
python's is enormous

00:09:40,080 --> 00:09:44,000
and that of c plus plus just because

00:09:41,680 --> 00:09:46,800
it's younger but

00:09:44,000 --> 00:09:49,200
there are ways to access python and c

00:09:46,800 --> 00:09:51,600
plus plus code in rest as well

00:09:49,200 --> 00:09:53,200
and finally have things like concerns

00:09:51,600 --> 00:09:55,200
about a single vendor so

00:09:53,200 --> 00:09:56,399
there really is only one viable rust

00:09:55,200 --> 00:09:58,880
compiler right now

00:09:56,399 --> 00:09:59,920
even though there's work ongoing to add

00:09:58,880 --> 00:10:03,120
it to

00:09:59,920 --> 00:10:05,200
gcc but i will say that the rust team

00:10:03,120 --> 00:10:06,640
has done a very very good job

00:10:05,200 --> 00:10:08,480
of supporting the rust compiler on a

00:10:06,640 --> 00:10:10,240
variety of platforms uh

00:10:08,480 --> 00:10:12,000
of course you know the three major

00:10:10,240 --> 00:10:13,440
operating systems but also a variety of

00:10:12,000 --> 00:10:15,839
other platforms

00:10:13,440 --> 00:10:18,320
and uh you can definitely run it on a

00:10:15,839 --> 00:10:21,519
lot of systems

00:10:18,320 --> 00:10:23,200
so for me though rust is exciting

00:10:21,519 --> 00:10:25,040
because it really aligns with my goals

00:10:23,200 --> 00:10:27,440
as a researcher

00:10:25,040 --> 00:10:29,360
i want to write the fastest code i can

00:10:27,440 --> 00:10:30,880
with as few bugs as possible

00:10:29,360 --> 00:10:33,680
and i sort of want both those things at

00:10:30,880 --> 00:10:37,120
once and it's a bit of a vague goal

00:10:33,680 --> 00:10:40,640
but rust here really helps me because

00:10:37,120 --> 00:10:43,200
entire classes of bugs are eliminated

00:10:40,640 --> 00:10:45,200
compared to another sort of unsafe

00:10:43,200 --> 00:10:46,959
systems programming language

00:10:45,200 --> 00:10:48,480
and this means i can actually focus my

00:10:46,959 --> 00:10:51,920
time on

00:10:48,480 --> 00:10:53,519
developing a better algorithm or

00:10:51,920 --> 00:10:55,519
actually doing some other work and not

00:10:53,519 --> 00:10:58,560
having to worry about bugs

00:10:55,519 --> 00:11:00,880
as much as i would in another language

00:10:58,560 --> 00:11:02,720
the other thing is that it's a sort of

00:11:00,880 --> 00:11:03,440
productive modern programming language

00:11:02,720 --> 00:11:06,720
with a lot of

00:11:03,440 --> 00:11:09,519
developer conveniences but it also has

00:11:06,720 --> 00:11:11,839
competitive performance to languages

00:11:09,519 --> 00:11:14,480
like c and c plus plus

00:11:11,839 --> 00:11:16,160
and i think this is probably the most

00:11:14,480 --> 00:11:18,880
important point for me is that

00:11:16,160 --> 00:11:20,640
it's a language explicitly designed for

00:11:18,880 --> 00:11:24,000
non-expert users

00:11:20,640 --> 00:11:27,120
and i think other languages cater to

00:11:24,000 --> 00:11:27,680
different audiences so i think in some

00:11:27,120 --> 00:11:30,399
regards

00:11:27,680 --> 00:11:31,120
c plus um really cares about its expert

00:11:30,399 --> 00:11:34,480
developers

00:11:31,120 --> 00:11:37,120
and rust does too but it also

00:11:34,480 --> 00:11:38,480
um spends a lot of time making sure that

00:11:37,120 --> 00:11:40,640
the languages

00:11:38,480 --> 00:11:42,079
is sort of suitable for for non-expert

00:11:40,640 --> 00:11:44,240
programmers which is

00:11:42,079 --> 00:11:45,600
often the case for scientific

00:11:44,240 --> 00:11:48,480
researchers

00:11:45,600 --> 00:11:49,440
who may not identify as experts and

00:11:48,480 --> 00:11:50,959
finally

00:11:49,440 --> 00:11:53,519
there's built-in documentation and

00:11:50,959 --> 00:11:54,240
testing and this is sort of an area

00:11:53,519 --> 00:11:57,040
where

00:11:54,240 --> 00:11:59,360
i don't really want to spend any time um

00:11:57,040 --> 00:12:02,320
sort of wrangling external tools

00:11:59,360 --> 00:12:02,959
or you know fixing issues with them and

00:12:02,320 --> 00:12:04,800
also

00:12:02,959 --> 00:12:06,480
having sort of an integrated package

00:12:04,800 --> 00:12:07,680
manager and rust as a game changer

00:12:06,480 --> 00:12:10,880
because

00:12:07,680 --> 00:12:12,560
personally i consider time spent

00:12:10,880 --> 00:12:14,000
writing build system code to sort of be

00:12:12,560 --> 00:12:16,000
a necessary evil

00:12:14,000 --> 00:12:17,600
and i want to minimize as much as

00:12:16,000 --> 00:12:19,440
possible so

00:12:17,600 --> 00:12:21,680
rust's sort of first class dependency

00:12:19,440 --> 00:12:22,480
management is is really important to me

00:12:21,680 --> 00:12:25,680
and it

00:12:22,480 --> 00:12:28,079
sort of um it lets me do focus my time

00:12:25,680 --> 00:12:31,360
on more important things

00:12:28,079 --> 00:12:33,040
so sort of jumping right in um just to

00:12:31,360 --> 00:12:35,040
some of the rest features i find very

00:12:33,040 --> 00:12:36,800
useful for writing numerical code

00:12:35,040 --> 00:12:38,160
um i just want to sort of preface this

00:12:36,800 --> 00:12:41,600
by saying

00:12:38,160 --> 00:12:42,639
that more than one feature i think it's

00:12:41,600 --> 00:12:44,240
the

00:12:42,639 --> 00:12:46,720
sum total of these features which is

00:12:44,240 --> 00:12:49,440
important so you can sort of get

00:12:46,720 --> 00:12:50,560
analogs to these features using

00:12:49,440 --> 00:12:53,600
different flags

00:12:50,560 --> 00:12:55,600
for c and c plus but it's it's sort of

00:12:53,600 --> 00:12:56,800
how they're all baked into the language

00:12:55,600 --> 00:12:58,320
and

00:12:56,800 --> 00:13:00,399
they're on by default which is really

00:12:58,320 --> 00:13:01,920
important so you don't need to know

00:13:00,399 --> 00:13:02,720
which special flags to pass to your

00:13:01,920 --> 00:13:05,360
compiler

00:13:02,720 --> 00:13:06,000
these are all turned on right away so

00:13:05,360 --> 00:13:08,480
right off the bat

00:13:06,000 --> 00:13:09,839
we have no implicit conversions between

00:13:08,480 --> 00:13:11,440
primitive types

00:13:09,839 --> 00:13:13,440
and so at the top here we're actually

00:13:11,440 --> 00:13:15,360
trying to divide

00:13:13,440 --> 00:13:16,800
two integers and get a floating point

00:13:15,360 --> 00:13:18,399
number out and

00:13:16,800 --> 00:13:20,079
rust is stopping us and saying actually

00:13:18,399 --> 00:13:24,240
there's mismatched

00:13:20,079 --> 00:13:24,959
types here and we expected a floating

00:13:24,240 --> 00:13:28,399
point number

00:13:24,959 --> 00:13:31,680
uh f64 but we found integers and this is

00:13:28,399 --> 00:13:32,800
a very common beginner mistake

00:13:31,680 --> 00:13:35,040
and it's nice that it's caught right

00:13:32,800 --> 00:13:36,399
away here and you know

00:13:35,040 --> 00:13:38,880
having you know it's not the most

00:13:36,399 --> 00:13:39,920
complex bug but having it caught and

00:13:38,880 --> 00:13:43,360
sort of

00:13:39,920 --> 00:13:44,959
addressed right away is is a big deal

00:13:43,360 --> 00:13:46,880
so this can this can be a little bit

00:13:44,959 --> 00:13:48,399
noisy sometimes so here we're trying to

00:13:46,880 --> 00:13:51,920
convert between

00:13:48,399 --> 00:13:52,800
a 32-bit unsigned integer and convert it

00:13:51,920 --> 00:13:56,000
into the

00:13:52,800 --> 00:13:59,120
platform's size of integer and

00:13:56,000 --> 00:14:01,120
rust is is not happy here either because

00:13:59,120 --> 00:14:02,240
it wants us to do an explicit conversion

00:14:01,120 --> 00:14:05,279
where we

00:14:02,240 --> 00:14:06,560
try and we try and convert the number

00:14:05,279 --> 00:14:10,240
but if it wouldn't fit

00:14:06,560 --> 00:14:13,279
we we stop execution

00:14:10,240 --> 00:14:15,760
and so this is you know a little bit

00:14:13,279 --> 00:14:18,240
noisy up front but

00:14:15,760 --> 00:14:19,839
this also catches real bugs especially

00:14:18,240 --> 00:14:21,680
if we're running on something like a

00:14:19,839 --> 00:14:25,120
16-bit platform

00:14:21,680 --> 00:14:27,199
where this would certainly be a bug so

00:14:25,120 --> 00:14:29,920
um having these things sort of caught up

00:14:27,199 --> 00:14:31,360
front is really important because

00:14:29,920 --> 00:14:33,279
the more things that you catch and

00:14:31,360 --> 00:14:34,480
compile time the less you have to worry

00:14:33,279 --> 00:14:36,240
about at runtime

00:14:34,480 --> 00:14:38,320
and this is sort of a theme within rust

00:14:36,240 --> 00:14:40,639
and it's something that the type system

00:14:38,320 --> 00:14:43,360
really helps with

00:14:40,639 --> 00:14:44,399
so there's also this notion of a very

00:14:43,360 --> 00:14:47,920
safe defaults

00:14:44,399 --> 00:14:50,000
to a lot of operations and

00:14:47,920 --> 00:14:51,920
it's what's sort of contributes to rust

00:14:50,000 --> 00:14:54,320
being a memory safe language

00:14:51,920 --> 00:14:55,040
so as much as possible it's not going to

00:14:54,320 --> 00:14:58,480
let you do

00:14:55,040 --> 00:14:59,920
unsafe operations and oftentimes the

00:14:58,480 --> 00:15:02,560
convenient thing

00:14:59,920 --> 00:15:03,760
or the thing that people default to is

00:15:02,560 --> 00:15:05,600
is the safe method and

00:15:03,760 --> 00:15:06,639
there are ways of you know saying you

00:15:05,600 --> 00:15:08,720
know i actually know what i'm doing here

00:15:06,639 --> 00:15:10,560
i want to do this thing specifically

00:15:08,720 --> 00:15:12,079
but for the most part safe defaults are

00:15:10,560 --> 00:15:15,279
i think a good choice

00:15:12,079 --> 00:15:16,560
especially for beginners so here we have

00:15:15,279 --> 00:15:19,199
an example where

00:15:16,560 --> 00:15:20,560
we have a vector with three elements and

00:15:19,199 --> 00:15:21,600
we're going to try and access the tenth

00:15:20,560 --> 00:15:24,959
element

00:15:21,600 --> 00:15:27,279
and of course this is a bug and

00:15:24,959 --> 00:15:28,320
sort of the natural default way of using

00:15:27,279 --> 00:15:30,959
these um

00:15:28,320 --> 00:15:32,399
brackets to access the element is is

00:15:30,959 --> 00:15:35,279
sort of the safe default way

00:15:32,399 --> 00:15:36,000
and we see here that we actually get a

00:15:35,279 --> 00:15:37,680
panic

00:15:36,000 --> 00:15:40,000
which is sort of like rust's way of you

00:15:37,680 --> 00:15:43,120
know winding down the system and

00:15:40,000 --> 00:15:45,120
stopping everything and exiting um

00:15:43,120 --> 00:15:46,800
so we have a panic and it says you know

00:15:45,120 --> 00:15:48,560
the the length of this vector is three

00:15:46,800 --> 00:15:51,839
but we try to get the tenth element

00:15:48,560 --> 00:15:53,360
so of course this is a bug um

00:15:51,839 --> 00:15:55,199
but you know right now a lot of

00:15:53,360 --> 00:15:56,399
performance irritated developers are

00:15:55,199 --> 00:15:58,880
saying okay but

00:15:56,399 --> 00:15:59,680
sometimes i know that my index is

00:15:58,880 --> 00:16:01,199
correct

00:15:59,680 --> 00:16:02,959
and i don't want to pay the cost of

00:16:01,199 --> 00:16:05,920
bounce checking

00:16:02,959 --> 00:16:07,360
and fine okay let's let's go ahead and

00:16:05,920 --> 00:16:11,040
do that so

00:16:07,360 --> 00:16:14,240
rust also has these opt-in low-level

00:16:11,040 --> 00:16:17,279
control features where we can

00:16:14,240 --> 00:16:19,680
you know we can do the sort of the quick

00:16:17,279 --> 00:16:21,600
or maybe the performance oriented thing

00:16:19,680 --> 00:16:22,720
but we have to tell people that we're

00:16:21,600 --> 00:16:24,480
doing it and

00:16:22,720 --> 00:16:25,759
rust's way of doing this is using these

00:16:24,480 --> 00:16:29,519
unsafe blocks

00:16:25,759 --> 00:16:30,800
if there's a potentially memory unsafe

00:16:29,519 --> 00:16:33,360
operation going on

00:16:30,800 --> 00:16:35,600
so it's the same same sort of examples

00:16:33,360 --> 00:16:38,000
we have a vector with three elements

00:16:35,600 --> 00:16:40,000
and we're trying to get the tenth one

00:16:38,000 --> 00:16:42,320
but right away it's a lot noisier

00:16:40,000 --> 00:16:43,279
so we have this unsafe block which says

00:16:42,320 --> 00:16:45,519
okay something

00:16:43,279 --> 00:16:46,560
unsafe is potentially happening here you

00:16:45,519 --> 00:16:48,800
know it's it's sort of

00:16:46,560 --> 00:16:50,720
um the programmer's way of saying okay

00:16:48,800 --> 00:16:54,079
compiler you know get out of my way

00:16:50,720 --> 00:16:55,519
i really want to do this but for

00:16:54,079 --> 00:16:57,519
people reviewing your code it's very

00:16:55,519 --> 00:16:58,880
helpful because you can right away go to

00:16:57,519 --> 00:17:01,920
the unsafe block and

00:16:58,880 --> 00:17:04,480
and sort of the reviewing cost or the

00:17:01,920 --> 00:17:06,240
surface area of your review is shrunk

00:17:04,480 --> 00:17:07,520
because a lot of times you just look at

00:17:06,240 --> 00:17:09,199
the unsafe blocks and see if they're

00:17:07,520 --> 00:17:11,280
okay

00:17:09,199 --> 00:17:12,400
and here of course this is not okay so

00:17:11,280 --> 00:17:15,280
we're trying to get

00:17:12,400 --> 00:17:16,160
the tenth element of a vector with only

00:17:15,280 --> 00:17:18,079
three

00:17:16,160 --> 00:17:19,520
and of course this is going to give us a

00:17:18,079 --> 00:17:21,679
garbage answer

00:17:19,520 --> 00:17:23,039
um and rest documentation does a really

00:17:21,679 --> 00:17:24,640
good job of saying you know this is

00:17:23,039 --> 00:17:28,079
actually not recommended

00:17:24,640 --> 00:17:30,160
um and use it with caution and this is

00:17:28,079 --> 00:17:31,600
you know this this unsafe block is sort

00:17:30,160 --> 00:17:32,400
of the visual equivalent of that it's

00:17:31,600 --> 00:17:35,120
saying

00:17:32,400 --> 00:17:36,240
you know something potentially dangerous

00:17:35,120 --> 00:17:38,160
is happening here

00:17:36,240 --> 00:17:39,840
and just be extra careful when you're

00:17:38,160 --> 00:17:42,080
using it

00:17:39,840 --> 00:17:43,440
and having this this opt-in low-level

00:17:42,080 --> 00:17:46,160
control is what sets

00:17:43,440 --> 00:17:47,919
rust apart from a lot of other memory

00:17:46,160 --> 00:17:50,960
safe languages

00:17:47,919 --> 00:17:51,840
because a lot of times you really do

00:17:50,960 --> 00:17:54,880
know what you're doing

00:17:51,840 --> 00:17:57,120
and rust will say you know go ahead no

00:17:54,880 --> 00:17:59,200
problem but

00:17:57,120 --> 00:18:00,960
like i said the the unsafe block is sort

00:17:59,200 --> 00:18:04,240
of very helpful here because it

00:18:00,960 --> 00:18:05,760
it reduces the the onus on on a code

00:18:04,240 --> 00:18:07,360
reviewer or yourself

00:18:05,760 --> 00:18:10,080
to look at where potentially dangerous

00:18:07,360 --> 00:18:11,760
things are happening

00:18:10,080 --> 00:18:13,120
and i think another another feature of

00:18:11,760 --> 00:18:15,679
rust that really sort of

00:18:13,120 --> 00:18:16,880
is is good for numerical programmers

00:18:15,679 --> 00:18:18,400
especially is that

00:18:16,880 --> 00:18:20,640
floating point numbers are treated with

00:18:18,400 --> 00:18:22,240
a lot of caution and

00:18:20,640 --> 00:18:23,919
you know there are entire books written

00:18:22,240 --> 00:18:24,799
on handling floating point numbers

00:18:23,919 --> 00:18:26,160
correctly

00:18:24,799 --> 00:18:28,080
and i think this is the right choice in

00:18:26,160 --> 00:18:29,840
a lot of cases so

00:18:28,080 --> 00:18:31,600
here we have some potentially surprising

00:18:29,840 --> 00:18:35,039
code where we're adding

00:18:31,600 --> 00:18:36,640
0.1 to itself three times and if that's

00:18:35,039 --> 00:18:38,240
equal to 0.3

00:18:36,640 --> 00:18:39,760
we're going to print out you know got

00:18:38,240 --> 00:18:41,200
0.3

00:18:39,760 --> 00:18:44,400
but otherwise we're going to print got

00:18:41,200 --> 00:18:46,160
something else and

00:18:44,400 --> 00:18:47,520
so this is a bit of a common beginner

00:18:46,160 --> 00:18:48,799
mistake um

00:18:47,520 --> 00:18:51,200
you don't really want to trust flowing

00:18:48,799 --> 00:18:52,480
point numbers and this code actually

00:18:51,200 --> 00:18:54,840
prints got something else

00:18:52,480 --> 00:18:56,559
because in the uh the floating point

00:18:54,840 --> 00:18:59,120
representation

00:18:56,559 --> 00:19:01,440
of point one added to itself three times

00:18:59,120 --> 00:19:03,760
is slightly different than point three

00:19:01,440 --> 00:19:05,679
and rust here is is doing a good job in

00:19:03,760 --> 00:19:07,360
warning us and saying

00:19:05,679 --> 00:19:08,799
that floating point types can't be used

00:19:07,360 --> 00:19:11,679
in patterns because

00:19:08,799 --> 00:19:12,960
this is not a very good uh way of doing

00:19:11,679 --> 00:19:15,520
things and there's better ways of

00:19:12,960 --> 00:19:16,880
of achieving the same result and this

00:19:15,520 --> 00:19:18,080
this warning in particular is actually

00:19:16,880 --> 00:19:20,880
going to be an error

00:19:18,080 --> 00:19:24,000
in later versions of the compiler and

00:19:20,880 --> 00:19:26,240
this is this is sort of a bug where

00:19:24,000 --> 00:19:28,000
it's it's may not be obvious right away

00:19:26,240 --> 00:19:31,039
but having it caught

00:19:28,000 --> 00:19:33,120
at compile time is is a big deal

00:19:31,039 --> 00:19:35,760
and so sometimes this can be a little

00:19:33,120 --> 00:19:38,320
bit annoying so

00:19:35,760 --> 00:19:40,799
the sort of default way of sorting

00:19:38,320 --> 00:19:42,880
floating point numbers

00:19:40,799 --> 00:19:44,480
doesn't actually work so if you're

00:19:42,880 --> 00:19:46,000
trying to sort this vector of floating

00:19:44,480 --> 00:19:48,080
point numbers

00:19:46,000 --> 00:19:50,080
you'll come up with an error that says

00:19:48,080 --> 00:19:51,360
that there's a trait bound that's not

00:19:50,080 --> 00:19:53,919
satisfied

00:19:51,360 --> 00:19:55,520
and i'm sure there's a good reason for

00:19:53,919 --> 00:19:57,200
this and you know generally the reason

00:19:55,520 --> 00:19:59,440
is that

00:19:57,200 --> 00:20:01,440
not a number or you know the infinity

00:19:59,440 --> 00:20:04,240
values might be tricky to

00:20:01,440 --> 00:20:06,960
have a total ordering because uh you

00:20:04,240 --> 00:20:08,640
know the nand or not a number value

00:20:06,960 --> 00:20:10,960
is not actually equal to itself so

00:20:08,640 --> 00:20:12,480
there's all sorts of little celsius here

00:20:10,960 --> 00:20:14,640
and of course you can sort floating

00:20:12,480 --> 00:20:16,640
point numbers and rust there's a

00:20:14,640 --> 00:20:18,080
um you know there's this sort of

00:20:16,640 --> 00:20:20,240
standard way of doing it and it's in the

00:20:18,080 --> 00:20:23,440
rest cookbook as well

00:20:20,240 --> 00:20:25,440
but myself personally i do prefer

00:20:23,440 --> 00:20:28,080
you know if i have to do a little bit

00:20:25,440 --> 00:20:30,640
more code at the source

00:20:28,080 --> 00:20:31,919
and which saves me from bugs later on

00:20:30,640 --> 00:20:33,679
this is a trade-off that

00:20:31,919 --> 00:20:36,480
i'm comfortable making and i'd like to

00:20:33,679 --> 00:20:36,480
make in my code

00:20:36,559 --> 00:20:39,919
but another thing that that rust does

00:20:38,320 --> 00:20:40,559
really well is actually it's quite a

00:20:39,919 --> 00:20:42,000
good

00:20:40,559 --> 00:20:44,400
prototyping language or debugging

00:20:42,000 --> 00:20:44,960
language uh especially given that it's

00:20:44,400 --> 00:20:48,080
also

00:20:44,960 --> 00:20:51,120
a low-level programming language so

00:20:48,080 --> 00:20:54,640
here we have a custom data structure

00:20:51,120 --> 00:20:56,960
called cool data and we have

00:20:54,640 --> 00:20:57,840
these vectors of floating point numbers

00:20:56,960 --> 00:21:00,640
in it

00:20:57,840 --> 00:21:02,000
but we also you know when you're when

00:21:00,640 --> 00:21:03,520
you're writing code and prototyping you

00:21:02,000 --> 00:21:07,039
really want to print out

00:21:03,520 --> 00:21:08,880
um the value of your your data often and

00:21:07,039 --> 00:21:10,400
sort of see what's going on to it

00:21:08,880 --> 00:21:11,919
you know what's happening during

00:21:10,400 --> 00:21:13,360
execution

00:21:11,919 --> 00:21:15,600
and russ does a really good job here so

00:21:13,360 --> 00:21:16,159
we can we can add this one line to our

00:21:15,600 --> 00:21:20,240
code

00:21:16,159 --> 00:21:23,440
and it says essentially give me a

00:21:20,240 --> 00:21:27,360
debug representation of my structure

00:21:23,440 --> 00:21:30,559
and then we can call this debug method

00:21:27,360 --> 00:21:32,000
and have printed out a really nice

00:21:30,559 --> 00:21:33,840
representation

00:21:32,000 --> 00:21:35,520
of our data and this is great for

00:21:33,840 --> 00:21:37,120
prototyping because

00:21:35,520 --> 00:21:38,640
you know i just want to see what's

00:21:37,120 --> 00:21:39,919
happening and i want to start a step

00:21:38,640 --> 00:21:42,559
through my code

00:21:39,919 --> 00:21:44,480
and um it's a very useful thing and i'm

00:21:42,559 --> 00:21:45,919
using this all the time

00:21:44,480 --> 00:21:47,760
it's a very common pattern for people to

00:21:45,919 --> 00:21:50,159
use

00:21:47,760 --> 00:21:51,440
so another thing that makes writing

00:21:50,159 --> 00:21:55,360
scientific code

00:21:51,440 --> 00:21:59,360
very sort of really helps it

00:21:55,360 --> 00:22:02,400
is that integrated testing in rust's

00:21:59,360 --> 00:22:03,440
package manager means that i think tests

00:22:02,400 --> 00:22:06,080
are going to be

00:22:03,440 --> 00:22:07,120
much more likely to be written so we

00:22:06,080 --> 00:22:10,480
have some

00:22:07,120 --> 00:22:12,159
sort of math expression here and we're

00:22:10,480 --> 00:22:14,720
testing it against sort of this known

00:22:12,159 --> 00:22:16,559
value and

00:22:14,720 --> 00:22:17,760
you know without any external tools we

00:22:16,559 --> 00:22:20,799
can write a unit test

00:22:17,760 --> 00:22:22,000
and check it right away and you know

00:22:20,799 --> 00:22:24,480
this really removes a lot of the

00:22:22,000 --> 00:22:25,840
friction around testing

00:22:24,480 --> 00:22:27,120
especially compared to other languages

00:22:25,840 --> 00:22:27,919
where you might need an external

00:22:27,120 --> 00:22:31,280
framework

00:22:27,919 --> 00:22:33,280
and um removing friction means that

00:22:31,280 --> 00:22:35,039
people are going to do it a lot more

00:22:33,280 --> 00:22:36,880
and it's it's sort of an easier tool to

00:22:35,039 --> 00:22:38,799
do and i find myself writing unit tests

00:22:36,880 --> 00:22:40,960
a lot more frequently in rest

00:22:38,799 --> 00:22:44,240
than i would in another language like c

00:22:40,960 --> 00:22:46,480
plus where it's a little more tricky

00:22:44,240 --> 00:22:47,600
and i think in particular documentation

00:22:46,480 --> 00:22:49,919
tests are really

00:22:47,600 --> 00:22:50,720
a killer feature for scientific code

00:22:49,919 --> 00:22:52,480
because

00:22:50,720 --> 00:22:54,000
a lot of scientific code you need a lot

00:22:52,480 --> 00:22:57,120
of examples

00:22:54,000 --> 00:22:59,120
and this is a way to make sure your

00:22:57,120 --> 00:23:00,320
examples continue to compile even if you

00:22:59,120 --> 00:23:04,320
change your code

00:23:00,320 --> 00:23:05,440
so here we have some documentation test

00:23:04,320 --> 00:23:06,799
where it's it's sort of the same

00:23:05,440 --> 00:23:10,559
examples before

00:23:06,799 --> 00:23:14,080
but this will actually be published as

00:23:10,559 --> 00:23:16,159
part of our documentation and

00:23:14,080 --> 00:23:17,440
having this ability to write example

00:23:16,159 --> 00:23:19,679
code and

00:23:17,440 --> 00:23:20,480
but also use it as documentation is sort

00:23:19,679 --> 00:23:22,320
of uh

00:23:20,480 --> 00:23:24,159
is a really big deal because you can you

00:23:22,320 --> 00:23:26,640
can really do two things at once

00:23:24,159 --> 00:23:28,720
and this will also ensure that your

00:23:26,640 --> 00:23:30,080
example code doesn't go out of date

00:23:28,720 --> 00:23:32,720
um which can be a big deal if you're

00:23:30,080 --> 00:23:35,360
refactoring your your project

00:23:32,720 --> 00:23:36,400
so um sort of taking together uh rus

00:23:35,360 --> 00:23:38,799
safety guarantees

00:23:36,400 --> 00:23:39,679
and the fundamentals of the language

00:23:38,799 --> 00:23:41,600
have a large

00:23:39,679 --> 00:23:43,760
qualitative impact on what kind of code

00:23:41,600 --> 00:23:45,679
we're capable of writing

00:23:43,760 --> 00:23:47,120
and i'm just going to use the example of

00:23:45,679 --> 00:23:48,880
of data races or these sort of

00:23:47,120 --> 00:23:49,679
concurrency issues in multi-threaded

00:23:48,880 --> 00:23:53,200
code

00:23:49,679 --> 00:23:54,640
so in safe rust you are actually

00:23:53,200 --> 00:23:57,200
guaranteed an absence

00:23:54,640 --> 00:23:58,640
of these data races and this is a simple

00:23:57,200 --> 00:24:01,760
yes or no answer

00:23:58,640 --> 00:24:02,400
whereas a language like c plus plus we

00:24:01,760 --> 00:24:06,080
go to the

00:24:02,400 --> 00:24:08,640
c plus plus core guidelines and the

00:24:06,080 --> 00:24:10,640
the best that we can get from c plus

00:24:08,640 --> 00:24:12,000
plus today is is this maybe

00:24:10,640 --> 00:24:13,919
you know maybe your code doesn't have a

00:24:12,000 --> 00:24:16,240
data race or maybe it does

00:24:13,919 --> 00:24:17,039
and for me as someone who just wants to

00:24:16,240 --> 00:24:18,559
write the code

00:24:17,039 --> 00:24:20,720
this is 10 times or an order of

00:24:18,559 --> 00:24:23,840
magnitude better than

00:24:20,720 --> 00:24:25,360
or a mortar magnitude worse than

00:24:23,840 --> 00:24:26,880
the simple yes or no answer that russ

00:24:25,360 --> 00:24:28,159
gives us and it's

00:24:26,880 --> 00:24:30,159
sort of a difference in what kind of

00:24:28,159 --> 00:24:32,880
code we're comfortable writing

00:24:30,159 --> 00:24:34,880
and so the thing that sets rust apart is

00:24:32,880 --> 00:24:37,600
that software engineering best practices

00:24:34,880 --> 00:24:38,080
are built into language and core tools

00:24:37,600 --> 00:24:39,440
and

00:24:38,080 --> 00:24:41,120
i think that choosing rust is going to

00:24:39,440 --> 00:24:43,440
have the biggest impact on

00:24:41,120 --> 00:24:44,960
small resource constrained teams who

00:24:43,440 --> 00:24:47,760
don't identify as expert software

00:24:44,960 --> 00:24:50,159
developers

00:24:47,760 --> 00:24:52,080
and rus place in scientific computing is

00:24:50,159 --> 00:24:53,279
a language with the speed and power of c

00:24:52,080 --> 00:24:55,039
plus plus

00:24:53,279 --> 00:24:57,200
but it's also a systems language

00:24:55,039 --> 00:24:59,279
explicitly designed for non-experts and

00:24:57,200 --> 00:25:01,360
it's designed to lower barriers

00:24:59,279 --> 00:25:03,279
it's a companion and complement language

00:25:01,360 --> 00:25:04,720
to c in c plus

00:25:03,279 --> 00:25:07,039
so there's many trade-offs between these

00:25:04,720 --> 00:25:07,840
languages i see myself using them all in

00:25:07,039 --> 00:25:10,000
the future

00:25:07,840 --> 00:25:12,000
and there's no one correct choice here

00:25:10,000 --> 00:25:13,760
but rust's foundational values help us

00:25:12,000 --> 00:25:16,880
to write good software

00:25:13,760 --> 00:25:16,880
thank you very much for listening

00:25:22,159 --> 00:25:28,000
hi thank you it's a great talk

00:25:25,679 --> 00:25:30,799
hello thanks hello thanks for all your

00:25:28,000 --> 00:25:34,400
help thanks for the intro

00:25:30,799 --> 00:25:37,760
we have a couple question and um

00:25:34,400 --> 00:25:40,159
for example here uh

00:25:37,760 --> 00:25:41,520
what do you think about saiton as a

00:25:40,159 --> 00:25:45,919
natural net step

00:25:41,520 --> 00:25:46,960
do speed up python code yeah so i think

00:25:45,919 --> 00:25:49,279
i think there are definitely a lot of

00:25:46,960 --> 00:25:51,120
alternatives here um personally i

00:25:49,279 --> 00:25:52,080
haven't really done a lot of psython

00:25:51,120 --> 00:25:56,000
myself

00:25:52,080 --> 00:25:58,159
um but i think it's um

00:25:56,000 --> 00:25:59,919
not you know having having the rust

00:25:58,159 --> 00:26:00,320
ecosystem is also a really important

00:25:59,919 --> 00:26:03,360
thing

00:26:00,320 --> 00:26:05,679
and having sort of these examples of

00:26:03,360 --> 00:26:06,880
uh different ways to do things or or

00:26:05,679 --> 00:26:09,039
being able to pull

00:26:06,880 --> 00:26:10,880
a lot of dependencies into your project

00:26:09,039 --> 00:26:12,240
and and sort of experiment with them

00:26:10,880 --> 00:26:14,480
i think is also a really important

00:26:12,240 --> 00:26:16,000
feature that rust offers as a language

00:26:14,480 --> 00:26:17,840
and it's sort of this

00:26:16,000 --> 00:26:20,559
maybe a little bit of a fresh start for

00:26:17,840 --> 00:26:20,559
for some people

00:26:20,640 --> 00:26:27,039
hey good okay i have another

00:26:24,000 --> 00:26:28,400
question more is what are your favorite

00:26:27,039 --> 00:26:31,840
ways to integrate

00:26:28,400 --> 00:26:33,919
ros with python if any yeah so

00:26:31,840 --> 00:26:34,960
um i've definitely played around a bit

00:26:33,919 --> 00:26:37,760
with the uh

00:26:34,960 --> 00:26:38,799
pi 03 project or i think the pi oxide

00:26:37,760 --> 00:26:41,120
project

00:26:38,799 --> 00:26:43,039
and um so this is a really nice way you

00:26:41,120 --> 00:26:45,600
can you can do a uh

00:26:43,039 --> 00:26:47,840
you can integrate rust into into python

00:26:45,600 --> 00:26:50,000
just by exposing it as sort of a

00:26:47,840 --> 00:26:51,360
python module or you could also use the

00:26:50,000 --> 00:26:54,240
python code

00:26:51,360 --> 00:26:54,240
in rust as well

00:26:56,080 --> 00:27:03,679
okay well um we don't have more time

00:27:00,320 --> 00:27:06,400
i'm sorry but we can continue uh with

00:27:03,679 --> 00:27:09,200
the q a in the chat if

00:27:06,400 --> 00:27:09,679
if any have another question in the chat

00:27:09,200 --> 00:27:12,559
can

00:27:09,679 --> 00:27:13,600
answer all questions so it's okay thank

00:27:12,559 --> 00:27:21,840
you so much

00:27:13,600 --> 00:27:21,840
thank you thank you very much

00:27:23,520 --> 00:27:25,600

YouTube URL: https://www.youtube.com/watch?v=PEoPrMkg8W4


