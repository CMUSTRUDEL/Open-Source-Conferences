Title: Nikita Baksalyar - Learnable Programming with Rust â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	Lowering the barrier for new Rust developers or library users is something I have always been passionate about. I believe that with WebAssembly and new compiler tools we can - and should - achieve better and easier explanations of complex concepts in our demos, code snippets, and documentation.

More at https://rustfest.global/session/17-learnable-programming-with-rust/
Captions: 
	00:00:02,879 --> 00:00:07,680
nikita makes rust

00:00:04,560 --> 00:00:08,880
interactive so if learning it is your

00:00:07,680 --> 00:00:11,759
directive

00:00:08,880 --> 00:00:12,400
you won't need to fight to see what's

00:00:11,759 --> 00:00:17,920
inside

00:00:12,400 --> 00:00:17,920
to become a debugging detective

00:00:18,400 --> 00:00:22,720
hi i'm nikita and today i'm going to

00:00:20,640 --> 00:00:24,960
share with you a different approach to

00:00:22,720 --> 00:00:26,160
writing documentation and educating

00:00:24,960 --> 00:00:29,199
people about programming

00:00:26,160 --> 00:00:30,960
in rust so let's start by defining the

00:00:29,199 --> 00:00:33,840
problem so what exactly

00:00:30,960 --> 00:00:35,040
is learnable programming it is defined

00:00:33,840 --> 00:00:38,000
by brett victor

00:00:35,040 --> 00:00:39,280
in his essay of the same name as a set

00:00:38,000 --> 00:00:42,559
of design principles

00:00:39,280 --> 00:00:45,920
that helps programmers to understand

00:00:42,559 --> 00:00:47,760
and see how their programs execute

00:00:45,920 --> 00:00:49,039
and some of the defining characteristics

00:00:47,760 --> 00:00:51,199
of this idea

00:00:49,039 --> 00:00:52,480
are seeing the state of a running

00:00:51,199 --> 00:00:54,960
program and

00:00:52,480 --> 00:00:55,520
giving the programmer tools to easily

00:00:54,960 --> 00:00:59,359
play

00:00:55,520 --> 00:01:01,520
with their code and these things

00:00:59,359 --> 00:01:04,159
become especially valuable and important

00:01:01,520 --> 00:01:06,560
when they are applied to the problems of

00:01:04,159 --> 00:01:07,200
education and writing documentation

00:01:06,560 --> 00:01:10,000
because

00:01:07,200 --> 00:01:12,320
they can help to lower the entry

00:01:10,000 --> 00:01:15,200
barriers for people who are

00:01:12,320 --> 00:01:16,080
new to programming and today i'm going

00:01:15,200 --> 00:01:19,119
to show you

00:01:16,080 --> 00:01:21,840
how we can apply these ideas to rust and

00:01:19,119 --> 00:01:23,439
systems programming in particular so

00:01:21,840 --> 00:01:25,920
let's see how it's

00:01:23,439 --> 00:01:27,680
how it looks in action let's imagine

00:01:25,920 --> 00:01:28,240
you're someone new to asynchronous

00:01:27,680 --> 00:01:30,640
programming

00:01:28,240 --> 00:01:31,360
in rust and you want to learn more about

00:01:30,640 --> 00:01:34,400
it

00:01:31,360 --> 00:01:34,880
so you go to the tokyo's website and you

00:01:34,400 --> 00:01:38,079
see

00:01:34,880 --> 00:01:39,600
that they have some really nice

00:01:38,079 --> 00:01:41,439
tutorials

00:01:39,600 --> 00:01:43,040
but before you can start experimenting

00:01:41,439 --> 00:01:45,119
with the synchronous code

00:01:43,040 --> 00:01:46,960
you need to follow a number of steps

00:01:45,119 --> 00:01:49,439
because the examples provided in these

00:01:46,960 --> 00:01:51,600
tutorials have some prerequisites

00:01:49,439 --> 00:01:54,079
and first of all of course you need to

00:01:51,600 --> 00:01:57,840
set up a new rust project

00:01:54,079 --> 00:02:00,320
and then add dependencies through cargo

00:01:57,840 --> 00:02:02,079
then you can take a look at the code

00:02:00,320 --> 00:02:05,280
provided in this example

00:02:02,079 --> 00:02:09,840
and this code connects to a

00:02:05,280 --> 00:02:13,200
redislike it then sends a request to

00:02:09,840 --> 00:02:16,319
set a key hello to value world

00:02:13,200 --> 00:02:19,360
and then it sends another request which

00:02:16,319 --> 00:02:22,800
gets the same key and verifies that

00:02:19,360 --> 00:02:25,200
it has the expected value

00:02:22,800 --> 00:02:26,720
but before you can run this example you

00:02:25,200 --> 00:02:28,319
need to make sure that a mini ready

00:02:26,720 --> 00:02:29,120
server is actually running on your

00:02:28,319 --> 00:02:31,519
machine

00:02:29,120 --> 00:02:33,280
so you also need to figure out how to

00:02:31,519 --> 00:02:36,560
install and run it

00:02:33,280 --> 00:02:38,959
but why don't we try including all the

00:02:36,560 --> 00:02:40,160
necessary dependencies right there on

00:02:38,959 --> 00:02:42,800
the same page

00:02:40,160 --> 00:02:43,280
so that a user can immediately run this

00:02:42,800 --> 00:02:46,560
code

00:02:43,280 --> 00:02:48,560
and see the results so

00:02:46,560 --> 00:02:50,720
this is how it might look i go to the

00:02:48,560 --> 00:02:51,440
same example and i just click on the run

00:02:50,720 --> 00:02:53,599
button

00:02:51,440 --> 00:02:55,840
so this code is compiled and on the

00:02:53,599 --> 00:02:58,159
right side i can see that a key hello

00:02:55,840 --> 00:03:00,879
has been successfully set to a value

00:02:58,159 --> 00:03:01,840
world this gives the user an immediate

00:03:00,879 --> 00:03:03,840
context

00:03:01,840 --> 00:03:06,000
and response of what happens with their

00:03:03,840 --> 00:03:08,239
code and the state of the mini-red

00:03:06,000 --> 00:03:09,599
server can be also observed right there

00:03:08,239 --> 00:03:11,760
in the browser

00:03:09,599 --> 00:03:12,640
but we can take this idea a little bit

00:03:11,760 --> 00:03:15,680
further and

00:03:12,640 --> 00:03:17,360
make this code example editable so i can

00:03:15,680 --> 00:03:18,480
change the value of the key and run this

00:03:17,360 --> 00:03:21,519
code again

00:03:18,480 --> 00:03:23,040
and i can see that the state has has

00:03:21,519 --> 00:03:26,000
also changed

00:03:23,040 --> 00:03:27,200
or i can add a new key value pair like

00:03:26,000 --> 00:03:29,360
hey rustfest

00:03:27,200 --> 00:03:31,120
run it again and see that there is a new

00:03:29,360 --> 00:03:33,200
key now

00:03:31,120 --> 00:03:35,680
this approach minimizes the required

00:03:33,200 --> 00:03:36,959
setup so i can start experimenting and

00:03:35,680 --> 00:03:40,319
exploring the tokyo

00:03:36,959 --> 00:03:42,640
api right away and i believe that

00:03:40,319 --> 00:03:43,680
this is something that we should do to

00:03:42,640 --> 00:03:47,680
make rust

00:03:43,680 --> 00:03:50,720
more accessible to more people

00:03:47,680 --> 00:03:52,959
well of course setting up a new project

00:03:50,720 --> 00:03:56,000
is also an important skill

00:03:52,959 --> 00:03:58,480
but a first impression to show that

00:03:56,000 --> 00:04:00,000
this whole thing is not really that

00:03:58,480 --> 00:04:03,439
complicated

00:04:00,000 --> 00:04:04,400
is also important i think and well it's

00:04:03,439 --> 00:04:06,640
not some

00:04:04,400 --> 00:04:08,400
kind of magic because we already can

00:04:06,640 --> 00:04:10,159
make it happen

00:04:08,400 --> 00:04:12,640
we are able to run the ros code in the

00:04:10,159 --> 00:04:15,360
browser by using webassembly

00:04:12,640 --> 00:04:16,000
and the platform support is constantly

00:04:15,360 --> 00:04:18,320
expanded

00:04:16,000 --> 00:04:20,400
and improved in the compiler so we can

00:04:18,320 --> 00:04:22,800
make it work quite easily

00:04:20,400 --> 00:04:24,479
so when you click on the run button the

00:04:22,800 --> 00:04:26,320
code that you have in the editor

00:04:24,479 --> 00:04:28,720
is sent to the server where it is

00:04:26,320 --> 00:04:31,520
compiled by the rus compiler

00:04:28,720 --> 00:04:33,199
and a web assembly module is produced as

00:04:31,520 --> 00:04:36,479
a result

00:04:33,199 --> 00:04:37,520
this model is then executed in your web

00:04:36,479 --> 00:04:42,880
browser

00:04:37,520 --> 00:04:45,600
and you can see the output this approach

00:04:42,880 --> 00:04:46,320
uh can be expanded way beyond just tokyo

00:04:45,600 --> 00:04:49,680
or

00:04:46,320 --> 00:04:50,880
any other single library because we can

00:04:49,680 --> 00:04:53,360
use it to

00:04:50,880 --> 00:04:54,160
enhance documentation that is produced

00:04:53,360 --> 00:04:56,800
by rasdog

00:04:54,160 --> 00:04:57,840
automatically and all code examples can

00:04:56,800 --> 00:05:00,560
be made into

00:04:57,840 --> 00:05:00,960
this kind of interactive playgrounds

00:05:00,560 --> 00:05:04,560
which

00:05:00,960 --> 00:05:07,280
you can execute in your web browser

00:05:04,560 --> 00:05:08,639
and well it already kind of works like

00:05:07,280 --> 00:05:10,160
that with the standard library

00:05:08,639 --> 00:05:13,280
documentation because

00:05:10,160 --> 00:05:14,160
if you go for example to the page that

00:05:13,280 --> 00:05:17,840
documents

00:05:14,160 --> 00:05:18,320
vectors you can just click on the run

00:05:17,840 --> 00:05:20,080
button

00:05:18,320 --> 00:05:21,360
in any of the examples and you will be

00:05:20,080 --> 00:05:23,280
directed to the

00:05:21,360 --> 00:05:24,560
ros playground where you can see the

00:05:23,280 --> 00:05:26,160
output and

00:05:24,560 --> 00:05:27,919
of course you can also play with this

00:05:26,160 --> 00:05:31,280
code and change it

00:05:27,919 --> 00:05:33,680
but what if we make it simpler by

00:05:31,280 --> 00:05:34,479
running examples in the browser on the

00:05:33,680 --> 00:05:37,600
same page

00:05:34,479 --> 00:05:39,680
and showing the output besides the code

00:05:37,600 --> 00:05:42,160
this will make it easier for people to

00:05:39,680 --> 00:05:46,000
just immediately see the output

00:05:42,160 --> 00:05:46,000
without switching the context

00:05:46,400 --> 00:05:50,639
but there's a problem if we go beyond

00:05:48,560 --> 00:05:53,919
the standard library

00:05:50,639 --> 00:05:55,840
now so the the problem is how do we uh

00:05:53,919 --> 00:05:57,520
how do we deal with dependencies and

00:05:55,840 --> 00:05:58,080
especially those dependencies which

00:05:57,520 --> 00:06:01,360
don't

00:05:58,080 --> 00:06:04,400
uh compile into web assembly yet

00:06:01,360 --> 00:06:05,280
well um the thing is we don't really

00:06:04,400 --> 00:06:07,120
have access to

00:06:05,280 --> 00:06:08,319
dependencies on the ros playground

00:06:07,120 --> 00:06:10,800
either because

00:06:08,319 --> 00:06:12,560
uh ross playground has a limited set of

00:06:10,800 --> 00:06:16,400
crates available to us

00:06:12,560 --> 00:06:18,639
uh since it's um an isolated environment

00:06:16,400 --> 00:06:20,240
and that's an expected thing because the

00:06:18,639 --> 00:06:23,280
rust playground

00:06:20,240 --> 00:06:23,759
executes your code on their server and

00:06:23,280 --> 00:06:25,520
they

00:06:23,759 --> 00:06:28,080
just want to make sure that this code is

00:06:25,520 --> 00:06:32,400
not malicious so they limit

00:06:28,080 --> 00:06:36,000
things like input and outputs or

00:06:32,400 --> 00:06:39,360
loading the external dependencies but

00:06:36,000 --> 00:06:43,120
um on the other hand

00:06:39,360 --> 00:06:45,120
this is this also makes it uh

00:06:43,120 --> 00:06:46,639
harder for us and makes it practically

00:06:45,120 --> 00:06:49,199
impossible to

00:06:46,639 --> 00:06:50,479
run examples from private code bases or

00:06:49,199 --> 00:06:53,680
even from

00:06:50,479 --> 00:06:55,120
public crates and it makes it harder for

00:06:53,680 --> 00:06:57,120
us to

00:06:55,120 --> 00:06:59,759
mentor and educate people through

00:06:57,120 --> 00:06:59,759
examples

00:07:00,880 --> 00:07:03,919
webassembly does not have this problem

00:07:02,639 --> 00:07:07,280
because the

00:07:03,919 --> 00:07:08,240
sandboxed environment is not someone

00:07:07,280 --> 00:07:12,319
else's

00:07:08,240 --> 00:07:12,880
machine or server but it's your own web

00:07:12,319 --> 00:07:15,440
browser

00:07:12,880 --> 00:07:17,759
and this sandbox is secured by

00:07:15,440 --> 00:07:20,479
definition

00:07:17,759 --> 00:07:21,919
but the main problem remains uh not all

00:07:20,479 --> 00:07:25,840
rust code compiles down to

00:07:21,919 --> 00:07:29,120
possibly yet well some of it does

00:07:25,840 --> 00:07:31,759
but even if it doesn't

00:07:29,120 --> 00:07:32,800
well you can argue that this is a good

00:07:31,759 --> 00:07:36,240
thing because

00:07:32,800 --> 00:07:38,479
if you want to add this kind of

00:07:36,240 --> 00:07:40,160
interactive from this kind of

00:07:38,479 --> 00:07:43,199
interactivity to

00:07:40,160 --> 00:07:44,960
your project it will also incentivize

00:07:43,199 --> 00:07:47,039
you to make

00:07:44,960 --> 00:07:48,639
to make your code more portable and make

00:07:47,039 --> 00:07:51,520
it compilable into

00:07:48,639 --> 00:07:51,520
to a new target

00:07:52,160 --> 00:07:56,000
and there is a good chance that your

00:07:54,319 --> 00:07:57,759
code is already compatible with this

00:07:56,000 --> 00:07:59,280
interactive style of documentation

00:07:57,759 --> 00:08:00,879
and that it already compiles to

00:07:59,280 --> 00:08:04,479
webassembly because

00:08:00,879 --> 00:08:07,840
when you write tests for code that

00:08:04,479 --> 00:08:11,039
uh for example sends network requests

00:08:07,840 --> 00:08:13,759
usually what you want to do is to is to

00:08:11,039 --> 00:08:17,759
mock it meaning that your code won't

00:08:13,759 --> 00:08:21,680
really send um real network requests

00:08:17,759 --> 00:08:24,560
but instead it will pretend to do so so

00:08:21,680 --> 00:08:26,479
you can test the you can test the

00:08:24,560 --> 00:08:26,960
behavior of your code in isolation from

00:08:26,479 --> 00:08:29,440
the

00:08:26,960 --> 00:08:30,879
external environment and that is exactly

00:08:29,440 --> 00:08:33,360
the same thing that we want to do with

00:08:30,879 --> 00:08:37,200
our interactive documentation to because

00:08:33,360 --> 00:08:39,599
uh we want to give a user the option to

00:08:37,200 --> 00:08:40,560
run their code independence of the

00:08:39,599 --> 00:08:44,480
external

00:08:40,560 --> 00:08:46,959
uh of the external environment and

00:08:44,480 --> 00:08:49,120
the main thing to look for here is the

00:08:46,959 --> 00:08:50,800
api conformance because we want to make

00:08:49,120 --> 00:08:54,320
sure that

00:08:50,800 --> 00:08:56,640
mock functions that we call have the

00:08:54,320 --> 00:08:58,480
uh exact same interface as your real

00:08:56,640 --> 00:09:00,480
code

00:08:58,480 --> 00:09:02,000
and well you can do this manually by

00:09:00,480 --> 00:09:04,399
using

00:09:02,000 --> 00:09:05,440
feature flags for example or you can use

00:09:04,399 --> 00:09:10,160
one of the many

00:09:05,440 --> 00:09:13,920
rust libraries for automatic mocking and

00:09:10,160 --> 00:09:16,959
but the the main idea remains that you

00:09:13,920 --> 00:09:18,880
uh that you want to provide the same the

00:09:16,959 --> 00:09:23,839
same interface both in your real code

00:09:18,880 --> 00:09:23,839
and in the mocked version

00:09:24,399 --> 00:09:30,240
and and this idea

00:09:27,839 --> 00:09:31,360
of running the playground code in the

00:09:30,240 --> 00:09:34,560
browser

00:09:31,360 --> 00:09:36,800
can um can go a lot further because we

00:09:34,560 --> 00:09:37,839
have lots of techniques for visualizing

00:09:36,800 --> 00:09:41,440
data

00:09:37,839 --> 00:09:44,160
so for example um

00:09:41,440 --> 00:09:46,000
for example on this slide you can see

00:09:44,160 --> 00:09:49,680
some code from the documentation

00:09:46,000 --> 00:09:51,920
of an http client library called request

00:09:49,680 --> 00:09:53,120
it sends a get request and outputs the

00:09:51,920 --> 00:09:56,240
response but

00:09:53,120 --> 00:09:58,399
this example demonstrates only the only

00:09:56,240 --> 00:09:59,519
the abstract idea of sending an http

00:09:58,399 --> 00:10:03,040
request but

00:09:59,519 --> 00:10:04,959
how do we know uh how it actually works

00:10:03,040 --> 00:10:06,480
and what kind of request it actually

00:10:04,959 --> 00:10:09,600
sounds

00:10:06,480 --> 00:10:12,560
so in this case we can output the uh

00:10:09,600 --> 00:10:14,560
the http requests and it's really

00:10:12,560 --> 00:10:16,079
helpful to see what kind of request gets

00:10:14,560 --> 00:10:17,600
sent when you execute this code because

00:10:16,079 --> 00:10:20,959
it can help you to learn

00:10:17,600 --> 00:10:23,360
more about http and

00:10:20,959 --> 00:10:24,800
more than that it can also help you to

00:10:23,360 --> 00:10:26,800
debug problems because

00:10:24,800 --> 00:10:29,200
with an interactive playground like that

00:10:26,800 --> 00:10:30,160
you can just replace the code with your

00:10:29,200 --> 00:10:32,480
own code and

00:10:30,160 --> 00:10:34,240
observe the changes and observe its

00:10:32,480 --> 00:10:37,279
behavior

00:10:34,240 --> 00:10:38,000
and the good news is that a lot of frost

00:10:37,279 --> 00:10:40,560
libraries

00:10:38,000 --> 00:10:41,200
already do something like that with

00:10:40,560 --> 00:10:44,320
tracing

00:10:41,200 --> 00:10:47,360
and logging but

00:10:44,320 --> 00:10:48,560
to use that you also have to choose a

00:10:47,360 --> 00:10:52,000
logging library

00:10:48,560 --> 00:10:52,880
and enable it to uh just get the logo

00:10:52,000 --> 00:10:55,519
output

00:10:52,880 --> 00:10:56,800
and with webassembly enabled playgrounds

00:10:55,519 --> 00:10:59,120
we just need to provide

00:10:56,800 --> 00:11:00,079
our own logging library that will

00:10:59,120 --> 00:11:03,760
redirect

00:11:00,079 --> 00:11:06,240
output from the logs to to a user's

00:11:03,760 --> 00:11:06,240
browser

00:11:07,440 --> 00:11:13,519
and the user's code can be

00:11:10,800 --> 00:11:14,079
can also be seen as as data that we can

00:11:13,519 --> 00:11:16,640
visualize

00:11:14,079 --> 00:11:17,920
and inspect and some of the components

00:11:16,640 --> 00:11:20,800
of the ras compiler

00:11:17,920 --> 00:11:21,360
are already available as libraries and

00:11:20,800 --> 00:11:23,440
there are

00:11:21,360 --> 00:11:25,440
even some more creates that can be used

00:11:23,440 --> 00:11:28,160
for parsing the ros code

00:11:25,440 --> 00:11:30,000
and almost all of them can be built into

00:11:28,160 --> 00:11:32,399
webassembly so we can

00:11:30,000 --> 00:11:33,360
parse the code and extract the context

00:11:32,399 --> 00:11:36,800
information

00:11:33,360 --> 00:11:39,120
that we can use to show hints to

00:11:36,800 --> 00:11:40,959
uh to our user even before they execute

00:11:39,120 --> 00:11:42,880
their code

00:11:40,959 --> 00:11:45,040
it can make our examples even more clear

00:11:42,880 --> 00:11:47,519
because these hints can

00:11:45,040 --> 00:11:50,079
can be shown as a user types code and

00:11:47,519 --> 00:11:53,279
they can provide context information

00:11:50,079 --> 00:11:55,440
almost like in the case of ideas

00:11:53,279 --> 00:11:57,920
and on this slide you can see an example

00:11:55,440 --> 00:12:01,120
from the request documentation again

00:11:57,920 --> 00:12:04,320
and it encodes parameters as http

00:12:01,120 --> 00:12:04,639
form data and as you look at this code

00:12:04,320 --> 00:12:07,120
and

00:12:04,639 --> 00:12:08,959
in the editor you can show some hints

00:12:07,120 --> 00:12:12,160
about what kind of result

00:12:08,959 --> 00:12:13,600
this or that function returns and this

00:12:12,160 --> 00:12:15,920
is possible because the compiler

00:12:13,600 --> 00:12:18,800
provides us with meta information about

00:12:15,920 --> 00:12:19,839
uh about the function names and types

00:12:18,800 --> 00:12:22,839
that are used there

00:12:19,839 --> 00:12:24,480
and all the kinds of all kinds of

00:12:22,839 --> 00:12:26,079
expressions

00:12:24,480 --> 00:12:27,600
and it's really straightforward to work

00:12:26,079 --> 00:12:31,360
with code as data because

00:12:27,600 --> 00:12:34,399
all expressions are actually variants of

00:12:31,360 --> 00:12:36,480
one large enum so you can

00:12:34,399 --> 00:12:38,079
use pattern matching to work with this

00:12:36,480 --> 00:12:41,760
enum just as you would normally

00:12:38,079 --> 00:12:41,760
do with rust

00:12:42,000 --> 00:12:45,279
and there is one more thing that we can

00:12:44,079 --> 00:12:46,959
do here

00:12:45,279 --> 00:12:48,800
and that is highlighting the code

00:12:46,959 --> 00:12:51,279
execution flow

00:12:48,800 --> 00:12:53,760
it can be compared to how you work uh

00:12:51,279 --> 00:12:57,760
with a debugger which can

00:12:53,760 --> 00:13:00,240
go through a program step by step and

00:12:57,760 --> 00:13:01,360
while it goes through the program in

00:13:00,240 --> 00:13:03,839
this fashion

00:13:01,360 --> 00:13:04,480
it also can show the internal state of

00:13:03,839 --> 00:13:07,519
the program

00:13:04,480 --> 00:13:09,440
at this particular point in time

00:13:07,519 --> 00:13:11,920
and we can do the same thing for our

00:13:09,440 --> 00:13:14,480
interactive playgrounds because

00:13:11,920 --> 00:13:16,320
it can really help in understanding the

00:13:14,480 --> 00:13:19,440
cases like

00:13:16,320 --> 00:13:20,959
for example long iterator chains and on

00:13:19,440 --> 00:13:23,120
this slide you can see

00:13:20,959 --> 00:13:24,720
an example from the rust standard

00:13:23,120 --> 00:13:26,800
library documentation

00:13:24,720 --> 00:13:29,680
which shows how we can construct

00:13:26,800 --> 00:13:32,639
iterators in a functional style

00:13:29,680 --> 00:13:34,240
and while this code kind of makes some

00:13:32,639 --> 00:13:36,639
intuitive sense uh

00:13:34,240 --> 00:13:39,680
it's still hard to see what kind of

00:13:36,639 --> 00:13:42,880
output we will get when for example we

00:13:39,680 --> 00:13:45,040
call the filter function on the on the

00:13:42,880 --> 00:13:47,040
third line

00:13:45,040 --> 00:13:49,440
but we can give a user a tool to go

00:13:47,040 --> 00:13:51,839
through this example line by line

00:13:49,440 --> 00:13:53,519
while also showing what each function

00:13:51,839 --> 00:13:55,279
will do

00:13:53,519 --> 00:13:57,600
and we can also combine this technique

00:13:55,279 --> 00:14:00,320
with the others we have discussed so far

00:13:57,600 --> 00:14:02,720
because this time we can have access not

00:14:00,320 --> 00:14:04,480
only to the static context information

00:14:02,720 --> 00:14:07,600
that is provided by the compiler

00:14:04,480 --> 00:14:09,680
but also to the dynamic state at this at

00:14:07,600 --> 00:14:11,680
the runtime

00:14:09,680 --> 00:14:13,199
and we can display data like local

00:14:11,680 --> 00:14:15,600
variables or

00:14:13,199 --> 00:14:16,880
function call results and as a user

00:14:15,600 --> 00:14:19,360
steps through the code

00:14:16,880 --> 00:14:20,399
it becomes really easy to see how the

00:14:19,360 --> 00:14:22,800
state changes

00:14:20,399 --> 00:14:24,079
with each function call with

00:14:22,800 --> 00:14:25,600
asynchronous code

00:14:24,079 --> 00:14:28,480
this approach can really make a

00:14:25,600 --> 00:14:30,800
difference in understanding how it works

00:14:28,480 --> 00:14:32,240
and if we treat each step as its own

00:14:30,800 --> 00:14:34,880
separate function call

00:14:32,240 --> 00:14:36,079
we can do an interesting thing here we

00:14:34,880 --> 00:14:39,199
can record the state

00:14:36,079 --> 00:14:39,839
at each step and store it so we can move

00:14:39,199 --> 00:14:44,240
not only

00:14:39,839 --> 00:14:47,040
forward but also backwards in time and

00:14:44,240 --> 00:14:47,600
since we're talking mainly about things

00:14:47,040 --> 00:14:52,240
like

00:14:47,600 --> 00:14:55,519
short snippets of code and examples

00:14:52,240 --> 00:14:57,760
instead of like uh large code bases

00:14:55,519 --> 00:14:58,800
it's possible to give a user a kind of a

00:14:57,760 --> 00:15:01,760
slider to go

00:14:58,800 --> 00:15:03,279
back and forth to really see the

00:15:01,760 --> 00:15:06,800
execution flow

00:15:03,279 --> 00:15:08,720
or they can just jump straight to

00:15:06,800 --> 00:15:11,839
to a point in time that is interesting

00:15:08,720 --> 00:15:12,560
to them just by clicking on the slider

00:15:11,839 --> 00:15:15,440
and

00:15:12,560 --> 00:15:16,320
again this is this is not some sort of

00:15:15,440 --> 00:15:18,240
magic

00:15:16,320 --> 00:15:20,240
because even if we don't have an

00:15:18,240 --> 00:15:22,720
immediate access to the webassembly

00:15:20,240 --> 00:15:25,360
execution engine in the browser

00:15:22,720 --> 00:15:26,000
and we don't have a kind of fine grained

00:15:25,360 --> 00:15:29,360
control over

00:15:26,000 --> 00:15:30,399
the execution we can transform uh the

00:15:29,360 --> 00:15:33,360
user's code

00:15:30,399 --> 00:15:35,120
during the compilation step uh and we

00:15:33,360 --> 00:15:38,240
can do that even without

00:15:35,120 --> 00:15:40,240
modifying and touching the ras compiler

00:15:38,240 --> 00:15:41,839
this transformation technique is

00:15:40,240 --> 00:15:44,000
actually pretty well known

00:15:41,839 --> 00:15:46,399
and even the rust compiler itself uses

00:15:44,000 --> 00:15:49,120
it for asynchronous code

00:15:46,399 --> 00:15:50,240
so it works by basically breaking down

00:15:49,120 --> 00:15:53,440
each block into

00:15:50,240 --> 00:15:56,720
an individual function that represents

00:15:53,440 --> 00:15:59,279
a single execution step this is known as

00:15:56,720 --> 00:16:00,560
a continuation and it means that we can

00:15:59,279 --> 00:16:03,360
continue the

00:16:00,560 --> 00:16:03,759
execution of a function from the point

00:16:03,360 --> 00:16:07,040
that

00:16:03,759 --> 00:16:10,480
we left it at

00:16:07,040 --> 00:16:13,199
and rust has an unstable feature called

00:16:10,480 --> 00:16:15,279
generators and this feature is actually

00:16:13,199 --> 00:16:16,240
used for implementing the async await

00:16:15,279 --> 00:16:19,440
syntax

00:16:16,240 --> 00:16:20,800
and well it works almost exactly as you

00:16:19,440 --> 00:16:23,519
see it on this slide

00:16:20,800 --> 00:16:24,560
so we have a struct that holds the

00:16:23,519 --> 00:16:27,759
internal state

00:16:24,560 --> 00:16:29,759
and things like local variables and

00:16:27,759 --> 00:16:31,440
each block is transformed into a

00:16:29,759 --> 00:16:34,639
separate function

00:16:31,440 --> 00:16:36,320
so when you want to execute this snippet

00:16:34,639 --> 00:16:38,079
all you have to do is to call these

00:16:36,320 --> 00:16:41,440
functions one by one

00:16:38,079 --> 00:16:43,440
and record the state changes so these

00:16:41,440 --> 00:16:46,720
functions can be called from the browser

00:16:43,440 --> 00:16:48,079
and we are very flexible in choosing in

00:16:46,720 --> 00:16:50,000
what order we can

00:16:48,079 --> 00:16:52,480
we call them and what kind of state we

00:16:50,000 --> 00:16:52,480
record

00:16:54,639 --> 00:16:58,079
and so far we have discussed uh some

00:16:56,560 --> 00:17:01,839
implementation details for

00:16:58,079 --> 00:17:05,199
these ideas but um

00:17:01,839 --> 00:17:07,679
overarchingly how do we actually make it

00:17:05,199 --> 00:17:09,280
work and how to make it accessible to

00:17:07,679 --> 00:17:11,280
everyone

00:17:09,280 --> 00:17:12,720
and there are several problems to solve

00:17:11,280 --> 00:17:15,760
here and not all of them

00:17:12,720 --> 00:17:17,199
are technical so first of all the eras

00:17:15,760 --> 00:17:19,360
compiler itself

00:17:17,199 --> 00:17:20,559
cannot be built into the passenger

00:17:19,360 --> 00:17:23,520
module yet

00:17:20,559 --> 00:17:25,199
so this requires us to have a compiler

00:17:23,520 --> 00:17:28,880
service that will build

00:17:25,199 --> 00:17:32,080
arbitrary rust code into webassembly

00:17:28,880 --> 00:17:35,600
for everyone um so we

00:17:32,080 --> 00:17:38,720
already have something like that uh

00:17:35,600 --> 00:17:42,799
on the rasp playground so it's not uh

00:17:38,720 --> 00:17:47,120
it's not that big of a deal and

00:17:42,799 --> 00:17:49,039
um yeah well so i tried implementing

00:17:47,120 --> 00:17:52,640
these ideas in production

00:17:49,039 --> 00:17:55,200
for um for a systems programming course

00:17:52,640 --> 00:17:56,160
and well surprisingly this

00:17:55,200 --> 00:17:58,320
infrastructure

00:17:56,160 --> 00:17:59,600
is not really uh it's not really hard to

00:17:58,320 --> 00:18:03,039
provide and it's not

00:17:59,600 --> 00:18:06,480
expensive because a single cpu

00:18:03,039 --> 00:18:09,520
cpu optimized virtual machine can easily

00:18:06,480 --> 00:18:13,200
handle hundreds of thousands of

00:18:09,520 --> 00:18:14,480
compilation requests per day but still

00:18:13,200 --> 00:18:17,280
they need to make sure that this

00:18:14,480 --> 00:18:19,679
infrastructure is easily available

00:18:17,280 --> 00:18:20,320
and it should be possible to deploy it

00:18:19,679 --> 00:18:22,240
uh

00:18:20,320 --> 00:18:23,679
to to deploy this comfort this

00:18:22,240 --> 00:18:28,480
compilation service

00:18:23,679 --> 00:18:30,160
uh locally and privately but there is

00:18:28,480 --> 00:18:32,960
another problem that we

00:18:30,160 --> 00:18:34,799
that we have discussed briefly if we

00:18:32,960 --> 00:18:36,320
start to include dependencies in our

00:18:34,799 --> 00:18:39,840
small code snippets

00:18:36,320 --> 00:18:40,559
the compilation will take a large amount

00:18:39,840 --> 00:18:42,960
of time

00:18:40,559 --> 00:18:43,919
and resources and the resulting web

00:18:42,960 --> 00:18:46,320
assembly module

00:18:43,919 --> 00:18:47,679
can have a huge size easily taking up to

00:18:46,320 --> 00:18:50,960
several megabytes

00:18:47,679 --> 00:18:52,720
making it harder to scale and well the

00:18:50,960 --> 00:18:54,320
obvious solution here is to compile

00:18:52,720 --> 00:18:56,720
these dependencies as

00:18:54,320 --> 00:18:57,440
separate webassembly modules instead and

00:18:56,720 --> 00:19:01,120
then

00:18:57,440 --> 00:19:03,280
link the dependencies when we need them

00:19:01,120 --> 00:19:05,120
but this problem is made worse by the

00:19:03,280 --> 00:19:07,600
fact that there is no dynamic linking

00:19:05,120 --> 00:19:09,679
standard for webassembly

00:19:07,600 --> 00:19:10,640
so you're basically left with the only

00:19:09,679 --> 00:19:13,760
choice of

00:19:10,640 --> 00:19:16,880
statically compiling the dependencies

00:19:13,760 --> 00:19:18,880
but technically

00:19:16,880 --> 00:19:20,320
the linking is still possible even

00:19:18,880 --> 00:19:23,120
though there is no

00:19:20,320 --> 00:19:25,280
standard way of doing it it's possible

00:19:23,120 --> 00:19:26,960
to make two webassembly modules work

00:19:25,280 --> 00:19:29,919
together

00:19:26,960 --> 00:19:30,640
uh so each module consists of functions

00:19:29,919 --> 00:19:33,200
that it

00:19:30,640 --> 00:19:34,400
exports and that would be our rust

00:19:33,200 --> 00:19:36,080
functions

00:19:34,400 --> 00:19:38,080
and it also has functions that are

00:19:36,080 --> 00:19:40,240
declared as imported

00:19:38,080 --> 00:19:42,240
and these imported functions are

00:19:40,240 --> 00:19:44,640
provided by the caller

00:19:42,240 --> 00:19:46,880
and usually they are used for calling

00:19:44,640 --> 00:19:49,280
javascript functions from the ros code

00:19:46,880 --> 00:19:50,080
and this is what makes it possible for

00:19:49,280 --> 00:19:52,000
rust

00:19:50,080 --> 00:19:55,120
programs to interact for example with

00:19:52,000 --> 00:19:57,919
john and browser functions

00:19:55,120 --> 00:19:58,320
so we can use this trick when rus module

00:19:57,919 --> 00:20:01,840
a

00:19:58,320 --> 00:20:04,799
calls some imported function

00:20:01,840 --> 00:20:07,440
what we can do is to call an exported

00:20:04,799 --> 00:20:10,320
function from ros module b

00:20:07,440 --> 00:20:12,000
and this works but um this approach

00:20:10,320 --> 00:20:12,720
works but there is another problem with

00:20:12,000 --> 00:20:14,880
it

00:20:12,720 --> 00:20:16,799
each model has its own separate memory

00:20:14,880 --> 00:20:18,159
and this memory is not shared between

00:20:16,799 --> 00:20:20,640
the modules

00:20:18,159 --> 00:20:21,280
and this means that if an imported trust

00:20:20,640 --> 00:20:23,840
function

00:20:21,280 --> 00:20:25,679
tries to access its state when it's

00:20:23,840 --> 00:20:26,320
executed in the context of a different

00:20:25,679 --> 00:20:28,960
model

00:20:26,320 --> 00:20:31,520
it will fail because this memory region

00:20:28,960 --> 00:20:33,520
does not contain the expected data

00:20:31,520 --> 00:20:36,080
what we'll need to do is to basically

00:20:33,520 --> 00:20:38,880
copy memory from module a to module b

00:20:36,080 --> 00:20:40,240
before we can call an imported function

00:20:38,880 --> 00:20:41,280
and the main disadvantage of this

00:20:40,240 --> 00:20:44,799
approach is of course

00:20:41,280 --> 00:20:47,520
that it's not standard and currently

00:20:44,799 --> 00:20:48,480
it requires a manual implementation

00:20:47,520 --> 00:20:50,240
ideally

00:20:48,480 --> 00:20:52,240
the rust compiler should take care of

00:20:50,240 --> 00:20:54,640
this for us but

00:20:52,240 --> 00:20:55,280
for now to make it work in the general

00:20:54,640 --> 00:20:57,760
case

00:20:55,280 --> 00:20:58,799
we'll need to find a way to

00:20:57,760 --> 00:21:00,880
automatically

00:20:58,799 --> 00:21:05,039
link rust dependencies which are

00:21:00,880 --> 00:21:05,039
compiled as web assembly modules

00:21:06,000 --> 00:21:11,120
so now that we have covered all this uh

00:21:08,400 --> 00:21:13,760
what is the conclusion

00:21:11,120 --> 00:21:14,400
i think that it is well worth the effort

00:21:13,760 --> 00:21:17,039
to

00:21:14,400 --> 00:21:18,320
make our to make our documentation

00:21:17,039 --> 00:21:20,320
interactive because

00:21:18,320 --> 00:21:21,600
it will help us to bring more people

00:21:20,320 --> 00:21:23,919
into rust

00:21:21,600 --> 00:21:25,039
and part of the reason why javascript is

00:21:23,919 --> 00:21:28,720
so popular

00:21:25,039 --> 00:21:31,120
is that it's so easy to uh to use it

00:21:28,720 --> 00:21:31,760
and access it you don't need to do any

00:21:31,120 --> 00:21:34,000
sort of

00:21:31,760 --> 00:21:35,919
complicated setup all you have to do is

00:21:34,000 --> 00:21:37,760
to open a console in your web browser

00:21:35,919 --> 00:21:39,600
and you already can start writing code

00:21:37,760 --> 00:21:43,280
and experimenting with it

00:21:39,600 --> 00:21:45,280
and with webassembly we have a really

00:21:43,280 --> 00:21:46,559
we have a really good chance of bringing

00:21:45,280 --> 00:21:48,320
this um

00:21:46,559 --> 00:21:50,400
of bringing this simplicity into the

00:21:48,320 --> 00:21:53,039
ross world

00:21:50,400 --> 00:21:54,000
but we still have a long way ahead of us

00:21:53,039 --> 00:21:57,039
because the

00:21:54,000 --> 00:22:00,480
web assembly ecosystem has not um

00:21:57,039 --> 00:22:03,679
has not matured yet but still

00:22:00,480 --> 00:22:06,240
we can try our best in making this as

00:22:03,679 --> 00:22:08,640
easy as possible to add these sort of

00:22:06,240 --> 00:22:10,240
interactive elements to any project

00:22:08,640 --> 00:22:11,679
because we already have tools like

00:22:10,240 --> 00:22:12,640
crossdock which can generate

00:22:11,679 --> 00:22:16,080
documentation

00:22:12,640 --> 00:22:16,640
out of the source code what we will need

00:22:16,080 --> 00:22:19,120
to do

00:22:16,640 --> 00:22:21,280
is to improve ras dock to also

00:22:19,120 --> 00:22:22,799
automatically generate playgrounds for

00:22:21,280 --> 00:22:26,400
our documentation

00:22:22,799 --> 00:22:27,760
and we we also need to have a toolkit to

00:22:26,400 --> 00:22:31,200
simplify building these

00:22:27,760 --> 00:22:33,120
interactive playgrounds the good news

00:22:31,200 --> 00:22:35,440
is that we don't have to start from

00:22:33,120 --> 00:22:37,919
scratch the most crucial part

00:22:35,440 --> 00:22:38,720
is actually compiling the code into the

00:22:37,919 --> 00:22:41,120
assembly

00:22:38,720 --> 00:22:43,280
and the rust compiler has got us covered

00:22:41,120 --> 00:22:45,440
there we just need to build a tooling

00:22:43,280 --> 00:22:46,960
around it

00:22:45,440 --> 00:22:48,720
so i have started a project that

00:22:46,960 --> 00:22:50,159
contains the docker image for the

00:22:48,720 --> 00:22:52,320
compiler service

00:22:50,159 --> 00:22:54,320
and some front-end components you can

00:22:52,320 --> 00:22:54,799
find the repository at the address you

00:22:54,320 --> 00:22:57,919
see

00:22:54,799 --> 00:23:00,080
on the slide so if you're interested

00:22:57,919 --> 00:23:03,039
you can join the development effort and

00:23:00,080 --> 00:23:04,720
help to make this a reality

00:23:03,039 --> 00:23:06,640
and that's all for me and thanks for

00:23:04,720 --> 00:23:08,240
your attention and i'll be

00:23:06,640 --> 00:23:18,799
answering your questions in the chat

00:23:08,240 --> 00:23:18,799

YouTube URL: https://www.youtube.com/watch?v=8-ole_0rqLM


