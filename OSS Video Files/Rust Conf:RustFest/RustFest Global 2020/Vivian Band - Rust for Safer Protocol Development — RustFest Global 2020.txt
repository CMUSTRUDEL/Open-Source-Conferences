Title: Vivian Band - Rust for Safer Protocol Development â€” RustFest Global 2020
Publication date: 2020-12-19
Playlist: RustFest Global 2020
Description: 
	The Rust philosophy is to use the type system to catch program design flaws at compile time. We aim to do the same for network protocols: we generate a typed model of protocol data, from which we can automatically generate protocol parsers in Rust, and can use these to validate the protocol design.

More at https://rustfest.global/session/11-rust-for-safer-protocol-development/
Captions: 
	00:00:02,960 --> 00:00:09,200
vivian wants us to be

00:00:04,960 --> 00:00:11,920
safe and our code on the web to behave

00:00:09,200 --> 00:00:13,040
use rust to generate code that will

00:00:11,920 --> 00:00:17,840
validate

00:00:13,040 --> 00:00:20,880
risky inputs no need to be brave

00:00:17,840 --> 00:00:22,400
hello my name is vivian band and i'm a

00:00:20,880 --> 00:00:24,320
second year phd student at the

00:00:22,400 --> 00:00:25,599
university of glasgow studying network

00:00:24,320 --> 00:00:27,279
security

00:00:25,599 --> 00:00:28,720
i was an intern on the improving

00:00:27,279 --> 00:00:30,640
protocol standards project

00:00:28,720 --> 00:00:31,840
which is still ongoing and is led by

00:00:30,640 --> 00:00:33,840
colin perkins with

00:00:31,840 --> 00:00:36,239
stephen mcquiston and dedges jacob as

00:00:33,840 --> 00:00:39,600
research assistants

00:00:36,239 --> 00:00:41,280
so improving protocol standards

00:00:39,600 --> 00:00:43,360
the internet engineering task force

00:00:41,280 --> 00:00:44,960
standardizes network protocols

00:00:43,360 --> 00:00:46,399
these are initially presented as drafts

00:00:44,960 --> 00:00:49,200
to working groups and then become

00:00:46,399 --> 00:00:51,600
official standards after further review

00:00:49,200 --> 00:00:53,600
however even after all of this peer

00:00:51,600 --> 00:00:55,600
review from several different sources

00:00:53,600 --> 00:00:56,960
mistakes still sometimes appear in these

00:00:55,600 --> 00:00:59,199
standards documents

00:00:56,960 --> 00:01:01,039
for example in the image on the right

00:00:59,199 --> 00:01:03,760
the ascii diagram claims that the field

00:01:01,039 --> 00:01:06,240
option relay port is 13 bits long

00:01:03,760 --> 00:01:07,760
and option line is 19 bits long but the

00:01:06,240 --> 00:01:10,080
text description says that they should

00:01:07,760 --> 00:01:12,000
both be 16 bits in length

00:01:10,080 --> 00:01:13,760
these errors and inconsistencies create

00:01:12,000 --> 00:01:16,000
ambiguity for people implementing

00:01:13,760 --> 00:01:17,680
protocols

00:01:16,000 --> 00:01:19,680
what the improving protocol standards

00:01:17,680 --> 00:01:21,280
project aims to do is create a machine

00:01:19,680 --> 00:01:22,479
readable ascii diagram and text

00:01:21,280 --> 00:01:23,680
description format

00:01:22,479 --> 00:01:26,000
to allow us to detect these

00:01:23,680 --> 00:01:27,520
inconsistencies much more easily

00:01:26,000 --> 00:01:29,200
these are minimally different from the

00:01:27,520 --> 00:01:31,439
format used in existing diagrams and

00:01:29,200 --> 00:01:33,360
descriptions with authors needing to use

00:01:31,439 --> 00:01:34,960
consistent label names and certain

00:01:33,360 --> 00:01:37,119
specific stock phrases in their

00:01:34,960 --> 00:01:38,880
descriptions

00:01:37,119 --> 00:01:40,640
these machine-readable documents allow

00:01:38,880 --> 00:01:41,680
us to build a tight model of protocol

00:01:40,640 --> 00:01:43,360
data

00:01:41,680 --> 00:01:45,200
we call this custom type system

00:01:43,360 --> 00:01:48,640
developed as part of our project

00:01:45,200 --> 00:01:50,799
network packet representation network

00:01:48,640 --> 00:01:52,079
packet representation is programming

00:01:50,799 --> 00:01:54,079
language agnostic

00:01:52,079 --> 00:01:57,040
so we can use it to generate outputs in

00:01:54,079 --> 00:01:57,040
any language that we like

00:01:57,119 --> 00:02:01,280
i had used rust earlier to implement a

00:01:59,520 --> 00:02:03,280
bare bones version of the quick protocol

00:02:01,280 --> 00:02:04,320
a few years ago as part of my final year

00:02:03,280 --> 00:02:05,840
undergrad project

00:02:04,320 --> 00:02:07,680
and i was impressed at how much safety

00:02:05,840 --> 00:02:09,440
added to systems programming

00:02:07,680 --> 00:02:11,200
so rust was my language of choice for

00:02:09,440 --> 00:02:13,760
this internship project

00:02:11,200 --> 00:02:15,760
our our first automatically generated

00:02:13,760 --> 00:02:17,360
parser libraries would be rust files

00:02:15,760 --> 00:02:20,560
because we wanted our resulting parsers

00:02:17,360 --> 00:02:22,800
to provide a good level of type safety

00:02:20,560 --> 00:02:24,640
okay so first of all let's take a step

00:02:22,800 --> 00:02:27,680
back and take a look at which types we

00:02:24,640 --> 00:02:29,360
need to describe network protocols

00:02:27,680 --> 00:02:30,800
before we can start building parsers and

00:02:29,360 --> 00:02:32,319
parser combinators

00:02:30,800 --> 00:02:34,239
we need to know which basic types will

00:02:32,319 --> 00:02:35,920
need to pass in the first place

00:02:34,239 --> 00:02:37,680
this internship was my first experience

00:02:35,920 --> 00:02:39,040
with uh with parsers

00:02:37,680 --> 00:02:41,440
i use a lot of analogies when i'm trying

00:02:39,040 --> 00:02:42,879
to learn new concepts so i like to think

00:02:41,440 --> 00:02:44,560
of these basic types as

00:02:42,879 --> 00:02:47,360
lego bricks which we can use to build

00:02:44,560 --> 00:02:48,800
cool more ambitious structures later on

00:02:47,360 --> 00:02:50,720
there are several basic types that we

00:02:48,800 --> 00:02:51,440
can identify from protocol standards

00:02:50,720 --> 00:02:53,599
documents

00:02:51,440 --> 00:02:56,640
so we'll take a look at a tcp header as

00:02:53,599 --> 00:02:58,560
an example to demonstrate this

00:02:56,640 --> 00:03:00,720
fields which contain raw data can be

00:02:58,560 --> 00:03:03,040
modeled as a bitstream so source port is

00:03:00,720 --> 00:03:05,680
just a 16-bit unsigned integer that's

00:03:03,040 --> 00:03:07,760
just raw data

00:03:05,680 --> 00:03:09,440
fields which could contain one or more

00:03:07,760 --> 00:03:11,920
of the same element could be modeled as

00:03:09,440 --> 00:03:11,920
an array

00:03:12,000 --> 00:03:15,599
some fields only appear under certain

00:03:14,239 --> 00:03:17,360
conditions and rely

00:03:15,599 --> 00:03:18,800
on values from other fields within the

00:03:17,360 --> 00:03:21,440
same protocol data unit

00:03:18,800 --> 00:03:23,440
in this case the tcp header to establish

00:03:21,440 --> 00:03:25,200
whether we're using that or not

00:03:23,440 --> 00:03:27,920
so we can call these constraint types

00:03:25,200 --> 00:03:29,280
since the they need to be checked

00:03:27,920 --> 00:03:30,959
some fields require information not

00:03:29,280 --> 00:03:33,040
contained within this packet like an

00:03:30,959 --> 00:03:34,159
encryption key or a value from another

00:03:33,040 --> 00:03:36,560
protocol data unit

00:03:34,159 --> 00:03:38,640
somewhere within this draft we can hold

00:03:36,560 --> 00:03:39,920
this information in a context data type

00:03:38,640 --> 00:03:41,840
which can be accessed by

00:03:39,920 --> 00:03:45,280
other protocol data units which also

00:03:41,840 --> 00:03:47,280
feature in this draft when required

00:03:45,280 --> 00:03:48,959
a field which can take on one of a

00:03:47,280 --> 00:03:50,319
limited possible set of values can be

00:03:48,959 --> 00:03:51,920
modeled as an enum

00:03:50,319 --> 00:03:53,840
so we've got them here an enum is

00:03:51,920 --> 00:03:55,040
indicated in these drafts uh with the

00:03:53,840 --> 00:03:58,159
stock phrase

00:03:55,040 --> 00:03:59,519
a tcp option is one of so is one of is

00:03:58,159 --> 00:04:00,080
the key phrasing where we need to use in

00:03:59,519 --> 00:04:03,599
these

00:04:00,080 --> 00:04:03,599
modified standards documents

00:04:03,760 --> 00:04:07,200
packets and protocol data units as a

00:04:05,599 --> 00:04:08,720
whole can be considered as

00:04:07,200 --> 00:04:10,640
structure like types given that they

00:04:08,720 --> 00:04:13,519
contain a sequence of field types as

00:04:10,640 --> 00:04:15,360
constituent members

00:04:13,519 --> 00:04:17,680
one data type which doesn't feature in

00:04:15,360 --> 00:04:19,359
tcp but is integral to quick would be

00:04:17,680 --> 00:04:20,880
the function data type

00:04:19,359 --> 00:04:22,560
so these are required to perform

00:04:20,880 --> 00:04:23,440
conversions between different protocol

00:04:22,560 --> 00:04:25,440
data units

00:04:23,440 --> 00:04:27,759
in this case it would be encryption and

00:04:25,440 --> 00:04:29,759
decryption of quix protected packet

00:04:27,759 --> 00:04:32,560
headers

00:04:29,759 --> 00:04:35,520
so we've got seven types in total in our

00:04:32,560 --> 00:04:38,960
network packet representation system

00:04:35,520 --> 00:04:42,160
bit strings arrays structs constraints

00:04:38,960 --> 00:04:44,479
contexts enums and functions

00:04:42,160 --> 00:04:47,440
so now we get to the fun stuff automatic

00:04:44,479 --> 00:04:48,880
rust parser generation

00:04:47,440 --> 00:04:51,199
so we've got our basic building block

00:04:48,880 --> 00:04:52,720
sorted out now how exactly can we use

00:04:51,199 --> 00:04:55,440
them to build more complex parser

00:04:52,720 --> 00:04:56,960
combinators in rust

00:04:55,440 --> 00:04:58,320
so let's use that bit string example

00:04:56,960 --> 00:04:59,840
that we went over in the previous

00:04:58,320 --> 00:05:02,720
section when we're explaining our

00:04:59,840 --> 00:05:03,840
uh our custom types we can automatically

00:05:02,720 --> 00:05:06,160
generate this custom

00:05:03,840 --> 00:05:08,560
rust type as a wrapper around an

00:05:06,160 --> 00:05:09,600
unsigned 16-bit integer in our rust

00:05:08,560 --> 00:05:13,039
output file

00:05:09,600 --> 00:05:15,520
pretty easily immediately after that

00:05:13,039 --> 00:05:17,039
we can generate a non-based parser for

00:05:15,520 --> 00:05:18,560
that type

00:05:17,039 --> 00:05:20,479
so this is a little bit more difficult

00:05:18,560 --> 00:05:24,000
to generate there's a lot going on here

00:05:20,479 --> 00:05:25,520
so we'll highlight a few key details

00:05:24,000 --> 00:05:27,600
first argument for all of our parser

00:05:25,520 --> 00:05:29,440
functions is an input tuple

00:05:27,600 --> 00:05:30,960
the first element of this tuple is a

00:05:29,440 --> 00:05:32,960
borrowed array of bytes

00:05:30,960 --> 00:05:35,600
which for protocol testing would be an

00:05:32,960 --> 00:05:37,520
incoming packet of some sort

00:05:35,600 --> 00:05:39,759
our parsers work at the bit level so the

00:05:37,520 --> 00:05:41,360
second tuple element is an integer which

00:05:39,759 --> 00:05:43,759
tracks how many bits we've read in the

00:05:41,360 --> 00:05:45,680
current byte

00:05:43,759 --> 00:05:47,360
our second argument is a mutable borrow

00:05:45,680 --> 00:05:48,000
of our current protocols context

00:05:47,360 --> 00:05:49,520
instance

00:05:48,000 --> 00:05:52,240
since we might want to update this as

00:05:49,520 --> 00:05:54,560
well as read from it

00:05:52,240 --> 00:05:55,280
our outputs are a non-specific result

00:05:54,560 --> 00:05:56,880
type

00:05:55,280 --> 00:05:59,759
containing the remaining bytes left to

00:05:56,880 --> 00:06:02,319
be parsed an updated bit counter

00:05:59,759 --> 00:06:03,919
and a tcp header item instantiated with

00:06:02,319 --> 00:06:05,440
the correct value read from the byte

00:06:03,919 --> 00:06:07,680
array

00:06:05,440 --> 00:06:10,720
we also return a mutable reference to

00:06:07,680 --> 00:06:12,639
our possibly updated context

00:06:10,720 --> 00:06:14,479
the parser function itself takes a

00:06:12,639 --> 00:06:15,440
defined number of bits from the input

00:06:14,479 --> 00:06:17,919
byte array

00:06:15,440 --> 00:06:19,680
in this case it will take 16 bits and

00:06:17,919 --> 00:06:20,560
then assigns the value of those taking

00:06:19,680 --> 00:06:24,319
bits to the custom

00:06:20,560 --> 00:06:26,160
bus type as needed the order in which we

00:06:24,319 --> 00:06:27,440
generate these custom types and parsers

00:06:26,160 --> 00:06:30,240
in the rust output file

00:06:27,440 --> 00:06:31,680
is determined by depth first search we

00:06:30,240 --> 00:06:33,440
generate a custom type

00:06:31,680 --> 00:06:35,360
and part we generate a custom type and

00:06:33,440 --> 00:06:37,759
parser whenever we reach a leaf node

00:06:35,360 --> 00:06:39,039
and then generate the parser combinator

00:06:37,759 --> 00:06:40,639
for the parent nodes

00:06:39,039 --> 00:06:42,240
when there are no more leaf nodes found

00:06:40,639 --> 00:06:44,080
for that parent

00:06:42,240 --> 00:06:45,520
so let's walk through parsing a tcp

00:06:44,080 --> 00:06:47,919
header

00:06:45,520 --> 00:06:49,599
the overall protocol data unit is a tcp

00:06:47,919 --> 00:06:51,440
header which is a struct type

00:06:49,599 --> 00:06:53,280
in our custom network packet

00:06:51,440 --> 00:06:54,960
representation system

00:06:53,280 --> 00:06:56,240
so this is the root of the depth first

00:06:54,960 --> 00:06:57,919
search tree and we'll generate the

00:06:56,240 --> 00:06:59,680
parser combinator for this last

00:06:57,919 --> 00:07:02,880
after we've generated all the required

00:06:59,680 --> 00:07:04,960
dependent parsers and parser combinators

00:07:02,880 --> 00:07:07,360
so the first parser will be for source

00:07:04,960 --> 00:07:09,919
port this is a 16 long

00:07:07,360 --> 00:07:12,800
16 bit long bet string and was the

00:07:09,919 --> 00:07:14,639
parser that we walked through earlier

00:07:12,800 --> 00:07:16,639
bet strings are leaf nodes so we move on

00:07:14,639 --> 00:07:17,039
to the next child of the root tcp header

00:07:16,639 --> 00:07:19,759
node

00:07:17,039 --> 00:07:21,360
destination port this is also a bit

00:07:19,759 --> 00:07:23,280
string and therefore a leaf node

00:07:21,360 --> 00:07:25,759
so we write a custom type in a 16-bit

00:07:23,280 --> 00:07:27,599
parser for this

00:07:25,759 --> 00:07:28,880
the first non-bit string we encounter in

00:07:27,599 --> 00:07:31,759
tcp header is

00:07:28,880 --> 00:07:33,360
options which is an array type the

00:07:31,759 --> 00:07:34,800
elements which could be present in the

00:07:33,360 --> 00:07:38,000
options array are tcp

00:07:34,800 --> 00:07:40,880
options tcp options is an enum type with

00:07:38,000 --> 00:07:42,560
a limited range of possible choices

00:07:40,880 --> 00:07:44,160
each of these enum variants are

00:07:42,560 --> 00:07:45,919
described in their own small ascii

00:07:44,160 --> 00:07:47,360
diagrams in another section of the same

00:07:45,919 --> 00:07:49,919
document

00:07:47,360 --> 00:07:51,440
this makes each enum variant a struct

00:07:49,919 --> 00:07:53,440
type in our network packet

00:07:51,440 --> 00:07:58,160
representation typing system

00:07:53,440 --> 00:07:59,759
in this case eol option is a struct

00:07:58,160 --> 00:08:01,520
the value of the field in this ascii

00:07:59,759 --> 00:08:02,720
diagram is a bit string

00:08:01,520 --> 00:08:04,720
this means we've finally reached the

00:08:02,720 --> 00:08:07,360
leaf node and we can write a custom rust

00:08:04,720 --> 00:08:08,560
type definition and a non-parser for eol

00:08:07,360 --> 00:08:10,560
option kind

00:08:08,560 --> 00:08:12,960
and then a rust type definition errors

00:08:10,560 --> 00:08:13,759
type definition and a parser for its

00:08:12,960 --> 00:08:17,039
parent node

00:08:13,759 --> 00:08:18,960
e eol option

00:08:17,039 --> 00:08:20,879
we find that there are more tcp option

00:08:18,960 --> 00:08:22,400
variants so we repeat this process for

00:08:20,879 --> 00:08:24,000
each one

00:08:22,400 --> 00:08:26,080
once we have written parsers for all of

00:08:24,000 --> 00:08:27,199
the variants we can write the rust type

00:08:26,080 --> 00:08:27,919
date we can write the rust type

00:08:27,199 --> 00:08:29,520
definition

00:08:27,919 --> 00:08:31,280
and parser combinator for the parent

00:08:29,520 --> 00:08:34,719
nodes tcp option and then

00:08:31,280 --> 00:08:36,240
options the last field in this packet is

00:08:34,719 --> 00:08:37,680
the payload which we can process

00:08:36,240 --> 00:08:41,039
relatively easily as a

00:08:37,680 --> 00:08:42,800
vet string finally we write the verse

00:08:41,039 --> 00:08:45,279
type definition for the

00:08:42,800 --> 00:08:46,800
tcp header struct and the parser

00:08:45,279 --> 00:08:49,600
combinator to process the entire

00:08:46,800 --> 00:08:51,680
protocol data unit in one function call

00:08:49,600 --> 00:08:53,519
we also create a context option object

00:08:51,680 --> 00:08:55,680
which all cursor functions have access

00:08:53,519 --> 00:08:57,120
to

00:08:55,680 --> 00:08:58,720
so to recap the system that was

00:08:57,120 --> 00:09:00,560
developed in this project

00:08:58,720 --> 00:09:01,760
we have the machine readable protocol

00:09:00,560 --> 00:09:03,279
document in stage one

00:09:01,760 --> 00:09:05,360
with our minimal changes to ascii

00:09:03,279 --> 00:09:06,959
diagrams and text descriptions

00:09:05,360 --> 00:09:08,800
we have the custom protocol typing

00:09:06,959 --> 00:09:10,640
system developed in stage 2

00:09:08,800 --> 00:09:13,360
our network packet representation

00:09:10,640 --> 00:09:14,800
language in stage 3 we have the results

00:09:13,360 --> 00:09:17,200
of my internship work

00:09:14,800 --> 00:09:18,640
a rust library file containing correct

00:09:17,200 --> 00:09:20,080
usable parser functions

00:09:18,640 --> 00:09:23,680
automatically generated from the

00:09:20,080 --> 00:09:23,680
information we have in stage two

00:09:24,720 --> 00:09:27,760
remember earlier when i mentioned that i

00:09:26,080 --> 00:09:29,279
think of these basic types and parsers

00:09:27,760 --> 00:09:31,360
as building blocks

00:09:29,279 --> 00:09:32,480
to go further with that analogy a tcp

00:09:31,360 --> 00:09:34,720
header is a lot like

00:09:32,480 --> 00:09:36,640
this lego block dinosaur here it

00:09:34,720 --> 00:09:38,240
contains many different complex elements

00:09:36,640 --> 00:09:40,720
and it's difficult to build manually

00:09:38,240 --> 00:09:42,560
without making mistakes

00:09:40,720 --> 00:09:44,640
our generated parser libraries are not

00:09:42,560 --> 00:09:45,760
only a manual explaining how this data

00:09:44,640 --> 00:09:47,440
should be parsed

00:09:45,760 --> 00:09:49,200
they also allow protocol developers to

00:09:47,440 --> 00:09:50,880
build the struct with extracted values

00:09:49,200 --> 00:09:53,920
with a single function call

00:09:50,880 --> 00:09:55,920
this is ideal for protocol testing the

00:09:53,920 --> 00:09:58,320
picture on the left is a genuine sample

00:09:55,920 --> 00:10:02,000
of our generated tcp parser code from

00:09:58,320 --> 00:10:05,839
our modified tcp rfc document

00:10:02,000 --> 00:10:05,839
so conclusions

00:10:06,240 --> 00:10:12,800
initially i decided on rust as our first

00:10:10,079 --> 00:10:14,320
parser output language because um i

00:10:12,800 --> 00:10:16,640
enjoyed using rust for systems

00:10:14,320 --> 00:10:18,160
programming on a previous project

00:10:16,640 --> 00:10:19,440
using partial combinators and norm

00:10:18,160 --> 00:10:20,959
turned out to be an ideal fit for

00:10:19,440 --> 00:10:23,040
parsing protocol data

00:10:20,959 --> 00:10:24,959
since parser combinators and assigning

00:10:23,040 --> 00:10:27,760
types to network protocols both use

00:10:24,959 --> 00:10:27,760
depth first search

00:10:28,399 --> 00:10:31,440
parsers can be difficult to write

00:10:29,760 --> 00:10:32,560
manually and are prone to containing

00:10:31,440 --> 00:10:34,320
errors

00:10:32,560 --> 00:10:35,600
automatically generating partners

00:10:34,320 --> 00:10:36,800
minimizes the chance

00:10:35,600 --> 00:10:38,959
chances of some of these errors

00:10:36,800 --> 00:10:40,240
occurring for example the number of bets

00:10:38,959 --> 00:10:41,760
being read will always match the

00:10:40,240 --> 00:10:43,519
specification

00:10:41,760 --> 00:10:44,959
the typing guarantees offered by rust

00:10:43,519 --> 00:10:46,480
helps us to be sure that we're using the

00:10:44,959 --> 00:10:49,360
correct types in both the machine

00:10:46,480 --> 00:10:51,279
readable protocol specification document

00:10:49,360 --> 00:10:53,279
and in our network packet representation

00:10:51,279 --> 00:10:56,480
system if there are errors the rust

00:10:53,279 --> 00:10:59,200
compiler will alert us to this

00:10:56,480 --> 00:11:00,720
next steps this project is still ongoing

00:10:59,200 --> 00:11:03,519
and there are more directions that this

00:11:00,720 --> 00:11:03,519
research could go in

00:11:03,680 --> 00:11:07,839
we're aiming to introduce our system to

00:11:05,279 --> 00:11:08,959
the ietf to see how this system works in

00:11:07,839 --> 00:11:11,760
practice with

00:11:08,959 --> 00:11:12,640
helping with protocol development we

00:11:11,760 --> 00:11:14,240
need to put in more

00:11:12,640 --> 00:11:15,760
work on function types so that we can

00:11:14,240 --> 00:11:17,760
create things like encryption and

00:11:15,760 --> 00:11:20,480
decryption functions for protocols like

00:11:17,760 --> 00:11:22,079
quick which heavily rely on this

00:11:20,480 --> 00:11:24,320
we'd also like to use these generated

00:11:22,079 --> 00:11:26,480
thrust parser libraries for automated

00:11:24,320 --> 00:11:28,160
protocol testing and error correction

00:11:26,480 --> 00:11:30,000
and to support more output languages in

00:11:28,160 --> 00:11:31,600
the future

00:11:30,000 --> 00:11:33,680
resources for this project can be found

00:11:31,600 --> 00:11:35,440
at these links we have a peer-reviewed

00:11:33,680 --> 00:11:36,320
publication which goes into more detail

00:11:35,440 --> 00:11:38,959
about our network

00:11:36,320 --> 00:11:40,480
packet representation typing system and

00:11:38,959 --> 00:11:42,480
the github repository containing the

00:11:40,480 --> 00:11:44,399
code for our automatic rust parser

00:11:42,480 --> 00:11:46,320
generator

00:11:44,399 --> 00:11:49,279
thank you for your time and i'd be happy

00:11:46,320 --> 00:11:49,279
to answer any questions

00:11:51,279 --> 00:11:53,920
that was brilliant

00:11:54,639 --> 00:11:58,720
thank you so much thank you so i know we

00:11:58,320 --> 00:12:02,480
have

00:11:58,720 --> 00:12:05,120
like a 25 to 30 second delay to um

00:12:02,480 --> 00:12:05,760
the stream so uh just to get ahead of

00:12:05,120 --> 00:12:08,639
time i have

00:12:05,760 --> 00:12:09,760
uh two questions you don't mind so the

00:12:08,639 --> 00:12:13,120
first one is

00:12:09,760 --> 00:12:15,440
there's a push for uh native

00:12:13,120 --> 00:12:17,040
uh implementations of the networking

00:12:15,440 --> 00:12:18,560
type so the rust like

00:12:17,040 --> 00:12:20,240
standard library doesn't use lip c

00:12:18,560 --> 00:12:21,600
anymore but directly operates with

00:12:20,240 --> 00:12:23,760
system calls

00:12:21,600 --> 00:12:24,959
do you think that will affect you in any

00:12:23,760 --> 00:12:28,639
way or

00:12:24,959 --> 00:12:32,079
like developing new types uh potentially

00:12:28,639 --> 00:12:33,440
i mean we uh so

00:12:32,079 --> 00:12:35,279
the whole point of us developing the

00:12:33,440 --> 00:12:36,639
network packet representation system was

00:12:35,279 --> 00:12:38,880
to have something that was completely

00:12:36,639 --> 00:12:40,320
agnostic of any programming languages or

00:12:38,880 --> 00:12:43,279
output libraries we'd want to use

00:12:40,320 --> 00:12:44,800
in the actual parser files themselves so

00:12:43,279 --> 00:12:46,560
it should be very easy for us to adapt

00:12:44,800 --> 00:12:49,519
to these things i would think

00:12:46,560 --> 00:12:50,240
cool like i think um we could maybe sort

00:12:49,519 --> 00:12:52,560
of

00:12:50,240 --> 00:12:53,920
we might have to consider like how would

00:12:52,560 --> 00:12:55,120
we convert from network packet

00:12:53,920 --> 00:12:57,440
representation to

00:12:55,120 --> 00:12:58,639
different uh codes featured in the uh

00:12:57,440 --> 00:13:00,480
different types sorry featured in the

00:12:58,639 --> 00:13:02,480
output code files

00:13:00,480 --> 00:13:04,240
um but that's relatively straightforward

00:13:02,480 --> 00:13:07,600
i think

00:13:04,240 --> 00:13:08,399
wonderful uh so this feeds into my other

00:13:07,600 --> 00:13:11,519
question

00:13:08,399 --> 00:13:13,440
so i guess you can use um

00:13:11,519 --> 00:13:15,440
the higher level parsers for let's say

00:13:13,440 --> 00:13:18,160
tcp udp what not

00:13:15,440 --> 00:13:18,639
uh regardless of the underlying types of

00:13:18,160 --> 00:13:21,920
like

00:13:18,639 --> 00:13:23,839
uh ipv4 versus version six

00:13:21,920 --> 00:13:25,040
yes uh so what we're aiming to do is

00:13:23,839 --> 00:13:27,600
have these run through

00:13:25,040 --> 00:13:29,120
um a single protocol specified in a

00:13:27,600 --> 00:13:30,480
draft you know it's very rare that you

00:13:29,120 --> 00:13:31,920
would have an rfc that specifies

00:13:30,480 --> 00:13:34,160
multiple protocols

00:13:31,920 --> 00:13:36,079
um so if you wanted to make an ipv6

00:13:34,160 --> 00:13:37,279
generator sure go ahead run it on that

00:13:36,079 --> 00:13:39,120
rfc

00:13:37,279 --> 00:13:40,720
so what we're aiming to do is introduce

00:13:39,120 --> 00:13:44,160
our machine readable

00:13:40,720 --> 00:13:45,360
ascii format to future ietf drafts and

00:13:44,160 --> 00:13:46,880
hopefully we'll see more adoption of

00:13:45,360 --> 00:13:48,160
that so we can have automated testing

00:13:46,880 --> 00:13:50,720
going forward

00:13:48,160 --> 00:13:51,600
but what we've done for showing the tcp

00:13:50,720 --> 00:13:53,920
example

00:13:51,600 --> 00:13:55,440
we've gone through an old rfc and made

00:13:53,920 --> 00:13:57,680
minimal changes to it to

00:13:55,440 --> 00:13:59,120
allow us to generate passers so if you

00:13:57,680 --> 00:14:02,000
want to do that with all protocols

00:13:59,120 --> 00:14:03,519
yep that's totally fine as well cool so

00:14:02,000 --> 00:14:05,600
i guess an answer to your question

00:14:03,519 --> 00:14:06,959
um sorry the question was about multiple

00:14:05,600 --> 00:14:09,360
protocols sort of nested

00:14:06,959 --> 00:14:11,440
yeah if you can use the departure that's

00:14:09,360 --> 00:14:14,000
coming out of the rfc for tcp

00:14:11,440 --> 00:14:16,079
you can use that for v4 and v6 and

00:14:14,000 --> 00:14:17,680
netlink and what the illustrator is

00:14:16,079 --> 00:14:19,120
uh yeah yeah we can use this for all

00:14:17,680 --> 00:14:20,639
sorts of different protocols i think the

00:14:19,120 --> 00:14:22,000
nice thing about parser combinators is

00:14:20,639 --> 00:14:23,839
if you want to get really ambitious and

00:14:22,000 --> 00:14:25,440
say okay we've got an ipv6 packet

00:14:23,839 --> 00:14:26,480
containing a tcp packet

00:14:25,440 --> 00:14:28,639
you know you can have a personal

00:14:26,480 --> 00:14:32,480
computer that does that if you like

00:14:28,639 --> 00:14:35,040
oh yeah yeah

00:14:32,480 --> 00:14:36,480
cool wonderful there's also a question

00:14:35,040 --> 00:14:38,959
from the audience

00:14:36,480 --> 00:14:41,199
uh how do you deal with uh non-bite

00:14:38,959 --> 00:14:41,600
aligned structures so if like a five bit

00:14:41,199 --> 00:14:45,680
word

00:14:41,600 --> 00:14:49,519
crosses the uh eight bit alignment

00:14:45,680 --> 00:14:50,720
uh so we had so i think i had a small

00:14:49,519 --> 00:14:52,320
file for testing when i was doing the

00:14:50,720 --> 00:14:53,199
internship about okay what if this

00:14:52,320 --> 00:14:56,639
happens and

00:14:53,199 --> 00:14:58,560
non-bite aligned words was one of them

00:14:56,639 --> 00:15:00,160
so what we found was with the bit level

00:14:58,560 --> 00:15:00,959
parsers it tends to just go straight

00:15:00,160 --> 00:15:03,519
into the next

00:15:00,959 --> 00:15:04,079
uh bite if you happen to count to exceed

00:15:03,519 --> 00:15:06,000
seven

00:15:04,079 --> 00:15:07,519
um so it will just run forwards you know

00:15:06,000 --> 00:15:08,560
quite happily we haven't had any issues

00:15:07,519 --> 00:15:11,519
with that so far

00:15:08,560 --> 00:15:12,000
norma's been very good to us yeah yeah

00:15:11,519 --> 00:15:13,839
oh yeah

00:15:12,000 --> 00:15:15,199
it has been released right version six

00:15:13,839 --> 00:15:17,680
has been out since uh

00:15:15,199 --> 00:15:19,120
tuesday i think uh yeah so i don't

00:15:17,680 --> 00:15:19,600
surprisingly haven't attempted to update

00:15:19,120 --> 00:15:21,199
that yet

00:15:19,600 --> 00:15:23,600
uh so i was just writing the number five

00:15:21,199 --> 00:15:24,880
but yeah um we'll see if it still works

00:15:23,600 --> 00:15:26,880
with six and if there's anything that we

00:15:24,880 --> 00:15:29,920
need

00:15:26,880 --> 00:15:31,920
yeah wonderful uh if this were a

00:15:29,920 --> 00:15:33,920
physical conference i will probably meet

00:15:31,920 --> 00:15:37,519
jeffrey who wrote

00:15:33,920 --> 00:15:40,720
the thing sure yeah i would love to

00:15:37,519 --> 00:15:41,680
wonderful uh do you want to uh precise

00:15:40,720 --> 00:15:44,160
something or

00:15:41,680 --> 00:15:46,399
say hey this is like something that came

00:15:44,160 --> 00:15:48,399
to mind just now

00:15:46,399 --> 00:15:50,000
uh no i think i've said everything i

00:15:48,399 --> 00:15:52,079
want to say in the presentation mostly

00:15:50,000 --> 00:15:53,680
uh so what we've it's mostly a proof of

00:15:52,079 --> 00:15:54,480
concept at the moment so i've posted the

00:15:53,680 --> 00:15:56,399
link to

00:15:54,480 --> 00:15:58,880
uh the repository and our paper

00:15:56,399 --> 00:16:01,040
explaining our system in the uh

00:15:58,880 --> 00:16:02,399
conference room chat so people want to

00:16:01,040 --> 00:16:03,920
take a look at our library have a play

00:16:02,399 --> 00:16:04,880
about with it see how the generated

00:16:03,920 --> 00:16:06,399
dress codes looks

00:16:04,880 --> 00:16:08,160
um we would happily take feedback if

00:16:06,399 --> 00:16:08,800
people want to help us improve our

00:16:08,160 --> 00:16:11,199
powers

00:16:08,800 --> 00:16:12,399
um so we consider myself still quite a

00:16:11,199 --> 00:16:14,320
novice at rust

00:16:12,399 --> 00:16:16,000
uh so we wrote everything using uh

00:16:14,320 --> 00:16:17,680
non-functions as opposed to the macros

00:16:16,000 --> 00:16:18,560
so we could sort of expose how much was

00:16:17,680 --> 00:16:19,600
going on

00:16:18,560 --> 00:16:21,839
just so we can make it clear to

00:16:19,600 --> 00:16:23,120
ourselves so if people want to talk to

00:16:21,839 --> 00:16:24,320
us about how we can optimize that or

00:16:23,120 --> 00:16:25,759
make it a bit cleaner

00:16:24,320 --> 00:16:27,920
more improvements that would be great

00:16:25,759 --> 00:16:31,519
we'd love that cool you wonder well

00:16:27,920 --> 00:16:33,759
wonderful so to the lovely people

00:16:31,519 --> 00:16:35,040
in the stream this is about the last

00:16:33,759 --> 00:16:38,800
chance you get to

00:16:35,040 --> 00:16:42,320
ask more questions uh

00:16:38,800 --> 00:16:44,000
hs vision has one has the itf been

00:16:42,320 --> 00:16:45,440
receptive to the machine readable

00:16:44,000 --> 00:16:48,160
diagram format

00:16:45,440 --> 00:16:50,000
uh so the problem with the itf is

00:16:48,160 --> 00:16:51,519
there's so many different groups it's

00:16:50,000 --> 00:16:53,199
impossible to get like a group of

00:16:51,519 --> 00:16:54,480
consensus for the whole organization

00:16:53,199 --> 00:16:57,040
so what we've got at the moment is a

00:16:54,480 --> 00:16:58,720
small side meeting uh the

00:16:57,040 --> 00:17:00,240
formal descriptions and techniques side

00:16:58,720 --> 00:17:00,720
group i think which is aiming to sort of

00:17:00,240 --> 00:17:03,440
like say

00:17:00,720 --> 00:17:04,400
okay how can we deploy this but we have

00:17:03,440 --> 00:17:06,640
um

00:17:04,400 --> 00:17:08,400
so stephen mcquiston and colin perkins

00:17:06,640 --> 00:17:10,400
uh two people involved in this project

00:17:08,400 --> 00:17:12,000
are heavily involved with the ietf uh so

00:17:10,400 --> 00:17:14,000
i think they're having discussions

00:17:12,000 --> 00:17:15,439
to see how we can get this um more

00:17:14,000 --> 00:17:16,880
widely deployed

00:17:15,439 --> 00:17:18,400
so there's been past attempts about like

00:17:16,880 --> 00:17:19,839
okay we can have custom tooling to do

00:17:18,400 --> 00:17:20,720
this this and this and it's all singing

00:17:19,839 --> 00:17:21,839
all dancing

00:17:20,720 --> 00:17:23,439
but what we tried to do was make

00:17:21,839 --> 00:17:24,640
something relatively simple and

00:17:23,439 --> 00:17:25,919
unintrusive that could work with

00:17:24,640 --> 00:17:28,480
multiple

00:17:25,919 --> 00:17:30,840
workflows um so that's why we're hoping

00:17:28,480 --> 00:17:33,760
this will see wider adoption

00:17:30,840 --> 00:17:35,360
cool so the answer is you haven't

00:17:33,760 --> 00:17:37,600
published using it yet but watch this

00:17:35,360 --> 00:17:37,600
space

00:17:37,760 --> 00:17:41,520
i guess you will be trying to

00:17:39,600 --> 00:17:44,080
investigate like the correctness of

00:17:41,520 --> 00:17:46,960
uh the middle boxes and whatnot or maybe

00:17:44,080 --> 00:17:48,480
try to circumvent them

00:17:46,960 --> 00:17:50,160
cool yeah so one of the examples that

00:17:48,480 --> 00:17:52,000
we're working on at the moment is quick

00:17:50,160 --> 00:17:53,840
with quite being very high profile and a

00:17:52,000 --> 00:17:55,600
very complex protocol so we think if we

00:17:53,840 --> 00:17:58,400
can successfully parse this and

00:17:55,600 --> 00:17:59,440
you know um we can successfully use it

00:17:58,400 --> 00:18:02,000
for testing then

00:17:59,440 --> 00:18:03,360
we think that's quite a good promotion i

00:18:02,000 --> 00:18:06,000
suppose

00:18:03,360 --> 00:18:08,320
oh definitely yeah i mean i mean having

00:18:06,000 --> 00:18:08,720
an actually correct implementation

00:18:08,320 --> 00:18:10,960
that's

00:18:08,720 --> 00:18:12,000
like done when the specification is

00:18:10,960 --> 00:18:13,360
finished

00:18:12,000 --> 00:18:14,880
well this is the only problem this was

00:18:13,360 --> 00:18:16,320
one of the main motivations about like

00:18:14,880 --> 00:18:17,919
you know you get protocols that are

00:18:16,320 --> 00:18:18,640
becoming increasingly more complex like

00:18:17,919 --> 00:18:20,240
quick it's

00:18:18,640 --> 00:18:22,559
not surprising that there will be stuff

00:18:20,240 --> 00:18:24,320
uh there will be flaws in it so

00:18:22,559 --> 00:18:26,559
say if we got a packet generated by c

00:18:24,320 --> 00:18:28,000
and c based implementation of quick and

00:18:26,559 --> 00:18:29,440
we fed it through our rust power so

00:18:28,000 --> 00:18:31,679
we could you know potentially find

00:18:29,440 --> 00:18:32,720
errors that way so it's interoperable

00:18:31,679 --> 00:18:33,280
with uh stacks written in other

00:18:32,720 --> 00:18:34,640
languages

00:18:33,280 --> 00:18:36,640
we just need to serve output that they

00:18:34,640 --> 00:18:39,840
generate

00:18:36,640 --> 00:18:42,000
so with tools like cargo expand i could

00:18:39,840 --> 00:18:44,240
then see at the generated

00:18:42,000 --> 00:18:47,360
code and maybe check out the state

00:18:44,240 --> 00:18:50,799
machine that has been generated to see

00:18:47,360 --> 00:18:51,760
if like the specified uh behavior makes

00:18:50,799 --> 00:18:53,919
any sense

00:18:51,760 --> 00:18:55,840
right or if there's like obvious flaws

00:18:53,919 --> 00:18:58,000
in the standard that you cannot see by

00:18:55,840 --> 00:18:59,919
just reading the text

00:18:58,000 --> 00:19:01,120
yeah um yeah that's the aim to sort of

00:18:59,919 --> 00:19:04,880
catch the subtle bugs

00:19:01,120 --> 00:19:04,880
where it's like okay you know um

00:19:05,039 --> 00:19:08,240
essentially what our partners are

00:19:06,320 --> 00:19:09,520
testing is your output on the wire

00:19:08,240 --> 00:19:11,200
correct you know is it doing what you

00:19:09,520 --> 00:19:12,320
think it's doing we can maybe come up

00:19:11,200 --> 00:19:13,840
with surf like

00:19:12,320 --> 00:19:15,280
more advanced testing harnesses and sort

00:19:13,840 --> 00:19:16,799
of automated error correction things for

00:19:15,280 --> 00:19:18,080
stacks later on possibly

00:19:16,799 --> 00:19:20,000
but that's going to take some time to

00:19:18,080 --> 00:19:23,919
develop yeah

00:19:20,000 --> 00:19:24,320
yeah looks like a long ongoing project

00:19:23,919 --> 00:19:27,840
with

00:19:24,320 --> 00:19:27,840
very short potential hopefully yeah

00:19:28,080 --> 00:19:34,080
wonderful so uh i'm currently not seeing

00:19:32,160 --> 00:19:36,640
any more questions i hope i haven't

00:19:34,080 --> 00:19:36,640
missed any

00:19:37,200 --> 00:19:43,440
no it seems like that's all of them

00:19:40,320 --> 00:19:44,080
wonderful then uh thank you again very

00:19:43,440 --> 00:19:48,080
much

00:19:44,080 --> 00:19:48,080
thank you for having me yeah you're

00:19:50,840 --> 00:19:53,840
welcome

00:19:54,400 --> 00:19:56,480

YouTube URL: https://www.youtube.com/watch?v=MPXGHc93bkY


