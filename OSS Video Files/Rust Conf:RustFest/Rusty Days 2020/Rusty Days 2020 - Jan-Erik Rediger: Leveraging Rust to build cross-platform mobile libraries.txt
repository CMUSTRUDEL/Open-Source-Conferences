Title: Rusty Days 2020 - Jan-Erik Rediger: Leveraging Rust to build cross-platform mobile libraries
Publication date: 2020-08-02
Playlist: Rusty Days 2020
Description: 
	Agenda ► https://rusty-days.org/agenda
Slides ►https://rusty-days.org/assets/slides/06-cross-platform-mobile-libraries.pdf
Playlist with all talks ► https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ

Follow ►
Facebook: https://rusty-days.org/facebook
Twitch: https://rusty-days.org/twitch
Twitter: https://rusty-days.org/twitter


This video ►
At Mozilla, Firefox is not the only product we ship. Many others — including a variety of smartphone applications, and certainly not just web browsers — are built by various teams across the organization. These applications are composed of a multitude of libraries which, when possible, are reused across platforms.

In the past year we used Rust to rebuild one of these libraries: the library powering the telemetry in our mobile applications is now integrated into Android and iOS applications and will soon be powering our Desktop platforms as well.

This talk will showcase how this small team managed to create a cross-platform Rust library, and ship it to a bunch of platforms all at once.
Captions: 
	00:00:03,120 --> 00:00:07,359
all right

00:00:04,000 --> 00:00:11,440
welcome everybody welcome to

00:00:07,359 --> 00:00:14,799
rusty days um let's get started

00:00:11,440 --> 00:00:17,840
i'm jan eric i'm your speaker today um

00:00:14,799 --> 00:00:21,119
i am a firefox 11g engineer

00:00:17,840 --> 00:00:23,519
on firefox working at mozilla um i'm

00:00:21,119 --> 00:00:25,760
also a russ community team member

00:00:23,519 --> 00:00:27,439
and sometimes i even go scuba diving

00:00:25,760 --> 00:00:28,960
you'll find me online and you even find

00:00:27,439 --> 00:00:31,439
the slides online already

00:00:28,960 --> 00:00:34,000
i'll link them later on twitter and the

00:00:31,439 --> 00:00:35,840
chat as well

00:00:34,000 --> 00:00:38,879
when i'm not doing any of the mentioned

00:00:35,840 --> 00:00:41,040
things i also organize russ conferences

00:00:38,879 --> 00:00:42,079
i do organize the european conference

00:00:41,040 --> 00:00:44,559
rust fest

00:00:42,079 --> 00:00:45,680
and just as rusty days it should have

00:00:44,559 --> 00:00:47,840
had happened

00:00:45,680 --> 00:00:49,600
as an in-person conference this year it

00:00:47,840 --> 00:00:51,680
should have been in the netherlands

00:00:49,600 --> 00:00:53,680
but unfortunately that didn't happen

00:00:51,680 --> 00:00:55,600
it's still happening this year though

00:00:53,680 --> 00:00:57,680
it's gonna be online and it's gonna be

00:00:55,600 --> 00:01:00,960
in november so stay tuned for more

00:00:57,680 --> 00:01:00,960
information on that as well

00:01:01,680 --> 00:01:08,880
i've started looking at rust in 2014

00:01:05,360 --> 00:01:10,159
that's six years ago i like to make the

00:01:08,880 --> 00:01:12,000
joke that back then

00:01:10,159 --> 00:01:13,600
we barely just got version numbers on

00:01:12,000 --> 00:01:18,320
rust releases

00:01:13,600 --> 00:01:18,320
we really come a long time since then

00:01:19,119 --> 00:01:24,159
today i'm here to talk about how my team

00:01:21,360 --> 00:01:26,720
at mozilla the telemetry team

00:01:24,159 --> 00:01:28,000
built a cross-platform library we call

00:01:26,720 --> 00:01:29,759
gleam

00:01:28,000 --> 00:01:31,040
you deployed that to at least four

00:01:29,759 --> 00:01:33,040
different platforms

00:01:31,040 --> 00:01:34,159
and integrated that with six programming

00:01:33,040 --> 00:01:36,000
language

00:01:34,159 --> 00:01:38,479
and we still feel like we can maintain

00:01:36,000 --> 00:01:38,479
all of this

00:01:38,799 --> 00:01:42,240
let's start off with some background

00:01:40,320 --> 00:01:43,840
around this project

00:01:42,240 --> 00:01:46,000
we will get you some actual rust code

00:01:43,840 --> 00:01:47,360
later and if you're watching this on the

00:01:46,000 --> 00:01:49,840
recording afterwards

00:01:47,360 --> 00:01:51,520
you could skip ahead but if you're on

00:01:49,840 --> 00:01:52,640
the live stream or actually interested

00:01:51,520 --> 00:01:55,119
in all of this

00:01:52,640 --> 00:01:58,479
please bear with me i'm making sure this

00:01:55,119 --> 00:01:58,479
is interesting for all of you

00:01:58,880 --> 00:02:05,600
so let's talk about firefox telemetry

00:02:02,079 --> 00:02:07,520
what is that firefox does collect data

00:02:05,600 --> 00:02:09,759
about how it's used

00:02:07,520 --> 00:02:10,959
we collect those in performance metrics

00:02:09,759 --> 00:02:14,160
for the product

00:02:10,959 --> 00:02:16,480
that is firefox desktop we then bundle

00:02:14,160 --> 00:02:18,640
up these metrics into what we call pings

00:02:16,480 --> 00:02:19,840
that's essentially just a bundle of all

00:02:18,640 --> 00:02:24,080
these metrics

00:02:19,840 --> 00:02:26,560
that we can send out as one big thing

00:02:24,080 --> 00:02:28,720
when doing this we follow what we call

00:02:26,560 --> 00:02:30,640
the lead data practices

00:02:28,720 --> 00:02:33,840
let me get into a little bit more detail

00:02:30,640 --> 00:02:35,680
so you understand what's happening

00:02:33,840 --> 00:02:37,920
this shows the graph of one of the

00:02:35,680 --> 00:02:40,480
metrics you collect

00:02:37,920 --> 00:02:43,040
this metric is the time spent running

00:02:40,480 --> 00:02:45,120
the javascript garbage collector

00:02:43,040 --> 00:02:46,800
the engineers behind the javascript

00:02:45,120 --> 00:02:48,400
engine want to know

00:02:46,800 --> 00:02:51,200
how the garbage collector actually

00:02:48,400 --> 00:02:53,280
behaves most of our developers

00:02:51,200 --> 00:02:54,560
on firefox actually run some high-end

00:02:53,280 --> 00:02:57,760
laptop a macbook

00:02:54,560 --> 00:02:58,319
or binkbed or something else so on their

00:02:57,760 --> 00:03:00,000
laptop

00:02:58,319 --> 00:03:01,519
obviously most of the time and actually

00:03:00,000 --> 00:03:04,720
runs fast

00:03:01,519 --> 00:03:05,760
but they can't test on all the hardware

00:03:04,720 --> 00:03:07,680
that's out there

00:03:05,760 --> 00:03:09,440
so we they want to see the data that's

00:03:07,680 --> 00:03:10,640
coming in from actual users and how it

00:03:09,440 --> 00:03:13,680
behaves

00:03:10,640 --> 00:03:15,920
so by collecting the time the the

00:03:13,680 --> 00:03:18,959
garbage collector takes to run on any

00:03:15,920 --> 00:03:21,680
arbitrary website a user might visit

00:03:18,959 --> 00:03:24,239
they can make decisions whether they are

00:03:21,680 --> 00:03:26,080
satisfied with the performance or not

00:03:24,239 --> 00:03:27,599
there might be outliers in either

00:03:26,080 --> 00:03:30,959
direction but

00:03:27,599 --> 00:03:33,920
as you can see in this graph it

00:03:30,959 --> 00:03:34,640
it's more or less a normal distribution

00:03:33,920 --> 00:03:36,239
and

00:03:34,640 --> 00:03:38,400
i guess for them this is what they're

00:03:36,239 --> 00:03:41,280
aiming for

00:03:38,400 --> 00:03:41,519
now this is just a single metric but

00:03:41,280 --> 00:03:44,159
this

00:03:41,519 --> 00:03:44,560
is already useful to describe what we're

00:03:44,159 --> 00:03:47,120
doing

00:03:44,560 --> 00:03:49,040
because this is only about a technical

00:03:47,120 --> 00:03:51,360
data point inside the browser

00:03:49,040 --> 00:03:52,720
this is not user data but this is huge

00:03:51,360 --> 00:03:55,680
usage data

00:03:52,720 --> 00:03:57,360
we don't want to collect any data about

00:03:55,680 --> 00:04:00,159
the user specifically

00:03:57,360 --> 00:04:03,360
we only want to collect data that tells

00:04:00,159 --> 00:04:05,840
us how the browser is actually behaving

00:04:03,360 --> 00:04:07,200
to make sure we stay true to this we

00:04:05,840 --> 00:04:10,480
follow what we call

00:04:07,200 --> 00:04:11,280
the lean data practices the lean data

00:04:10,480 --> 00:04:13,280
practices

00:04:11,280 --> 00:04:14,560
essentially spread split into three

00:04:13,280 --> 00:04:17,680
principles

00:04:14,560 --> 00:04:18,720
the first of all is staying lean we only

00:04:17,680 --> 00:04:21,280
want to collect this

00:04:18,720 --> 00:04:23,360
the data that actually answers questions

00:04:21,280 --> 00:04:25,040
so whenever we do want to collect data

00:04:23,360 --> 00:04:26,880
we always start with a question we'd

00:04:25,040 --> 00:04:29,440
like to get answered

00:04:26,880 --> 00:04:31,120
we also make decisions how and for how

00:04:29,440 --> 00:04:33,199
long we collect this data

00:04:31,120 --> 00:04:34,960
we only need it most of the time to

00:04:33,199 --> 00:04:36,479
actually answer a question and we had

00:04:34,960 --> 00:04:40,080
when we have this question

00:04:36,479 --> 00:04:42,639
we probably don't need that data anymore

00:04:40,080 --> 00:04:43,840
the second principle is building

00:04:42,639 --> 00:04:45,680
security

00:04:43,840 --> 00:04:46,880
as i mentioned before we really don't

00:04:45,680 --> 00:04:49,919
want to track

00:04:46,880 --> 00:04:52,720
or collect any data about our users

00:04:49,919 --> 00:04:55,199
we want only to see how the browser is

00:04:52,720 --> 00:04:55,199
behaving

00:04:55,280 --> 00:05:00,240
so we don't even collect any data that

00:04:58,479 --> 00:05:04,400
would identify any users

00:05:00,240 --> 00:05:07,120
in any detail and last but not least

00:05:04,400 --> 00:05:09,120
we want to engage our users just as the

00:05:07,120 --> 00:05:12,320
firefox code base itself

00:05:09,120 --> 00:05:13,039
the data collection code and data about

00:05:12,320 --> 00:05:16,000
the

00:05:13,039 --> 00:05:16,800
um how we do all of this is freely

00:05:16,000 --> 00:05:20,000
available

00:05:16,800 --> 00:05:22,080
users can look at what the browser does

00:05:20,000 --> 00:05:24,080
and on top of that users can also look

00:05:22,080 --> 00:05:26,639
at what their browser specifically

00:05:24,080 --> 00:05:26,639
is collecting

00:05:28,080 --> 00:05:32,400
and last but not least and most

00:05:30,320 --> 00:05:34,479
important we will always make it easy

00:05:32,400 --> 00:05:35,759
and possible for the user to actually

00:05:34,479 --> 00:05:37,680
opt out of this

00:05:35,759 --> 00:05:40,800
and not send us this data if they are

00:05:37,680 --> 00:05:43,039
not feeling comfortable doing so

00:05:40,800 --> 00:05:44,800
we always follow these principles and we

00:05:43,039 --> 00:05:46,960
actually have people that ensure

00:05:44,800 --> 00:05:48,960
that every data we collect follows these

00:05:46,960 --> 00:05:52,560
principles

00:05:48,960 --> 00:05:54,880
if you're interesting interested more in

00:05:52,560 --> 00:05:56,479
the behavior behind all of that and the

00:05:54,880 --> 00:05:58,960
ideas behind all of that

00:05:56,479 --> 00:06:00,319
you should check a talk by my colleague

00:05:58,960 --> 00:06:02,400
chattan

00:06:00,319 --> 00:06:04,720
titled collecting there responsibly and

00:06:02,400 --> 00:06:06,800
at scale it's from last year's star con

00:06:04,720 --> 00:06:08,479
2019 and it really

00:06:06,800 --> 00:06:11,280
is a really good resource to describe

00:06:08,479 --> 00:06:11,280
how we do this

00:06:11,520 --> 00:06:15,360
so to summarize a bit and to describe

00:06:14,000 --> 00:06:18,319
what telemetry is

00:06:15,360 --> 00:06:19,280
in a very internet compatible boring way

00:06:18,319 --> 00:06:20,880
is

00:06:19,280 --> 00:06:23,120
well we're actually just starting some

00:06:20,880 --> 00:06:24,479
integers and then send them json encoded

00:06:23,120 --> 00:06:27,440
to a server

00:06:24,479 --> 00:06:27,440
that's about all we do

00:06:28,560 --> 00:06:34,240
now when i joined mozilla in 2018 there

00:06:31,199 --> 00:06:37,360
were two developments happening

00:06:34,240 --> 00:06:39,520
the data teams at mozilla

00:06:37,360 --> 00:06:40,639
decided that the current system wasn't

00:06:39,520 --> 00:06:42,880
good enough anymore

00:06:40,639 --> 00:06:43,840
and they needed to build a new system to

00:06:42,880 --> 00:06:47,520
support

00:06:43,840 --> 00:06:48,960
um data collection from mozilla products

00:06:47,520 --> 00:06:51,360
in the future

00:06:48,960 --> 00:06:53,360
we knew about more products than just

00:06:51,360 --> 00:06:55,840
the desktop browser

00:06:53,360 --> 00:06:56,639
and we needed a system that can scale to

00:06:55,840 --> 00:06:59,120
the size

00:06:56,639 --> 00:07:01,360
of a browser population of millions of

00:06:59,120 --> 00:07:03,120
users

00:07:01,360 --> 00:07:04,560
we also gathered feedback from the

00:07:03,120 --> 00:07:07,840
developers that

00:07:04,560 --> 00:07:09,360
need to use this telemetry collection

00:07:07,840 --> 00:07:12,000
and also the analysts that need to

00:07:09,360 --> 00:07:14,880
finally look at the data

00:07:12,000 --> 00:07:16,639
the outcome of out of all of this is

00:07:14,880 --> 00:07:18,560
glean which is a

00:07:16,639 --> 00:07:19,840
the new development going all the way

00:07:18,560 --> 00:07:21,680
from the sdk

00:07:19,840 --> 00:07:23,120
that's the code that's actually landing

00:07:21,680 --> 00:07:25,440
in the products

00:07:23,120 --> 00:07:26,560
over to the pipeline which ingests the

00:07:25,440 --> 00:07:28,639
data

00:07:26,560 --> 00:07:30,639
puts it in the database and maybe

00:07:28,639 --> 00:07:33,280
transforms it to some extent

00:07:30,639 --> 00:07:35,360
and then also the tooling to analyze and

00:07:33,280 --> 00:07:36,880
look at this data

00:07:35,360 --> 00:07:39,199
this is all summed up in the clean

00:07:36,880 --> 00:07:41,360
project if you're interested

00:07:39,199 --> 00:07:42,720
in a lot more details there check out

00:07:41,360 --> 00:07:46,400
the introducing glean

00:07:42,720 --> 00:07:47,520
blog post by georg the second thing that

00:07:46,400 --> 00:07:50,639
was also happening

00:07:47,520 --> 00:07:52,879
is that our mobile teams decided

00:07:50,639 --> 00:07:54,240
to build out a new version of the

00:07:52,879 --> 00:07:57,680
firefox for android

00:07:54,240 --> 00:07:59,039
browser they wanted to build this new

00:07:57,680 --> 00:08:01,440
version of the browser

00:07:59,039 --> 00:08:02,400
on modern principles in a modular

00:08:01,440 --> 00:08:05,120
approach

00:08:02,400 --> 00:08:06,240
using the existing firefox code base

00:08:05,120 --> 00:08:10,160
using the existing

00:08:06,240 --> 00:08:12,560
modern firefox code base to be precise

00:08:10,160 --> 00:08:14,000
they also knew that they wanted to have

00:08:12,560 --> 00:08:16,160
data about how this

00:08:14,000 --> 00:08:19,199
product or this browser behaves on

00:08:16,160 --> 00:08:21,840
actual end user phones

00:08:19,199 --> 00:08:22,400
the landscape of android is even wider

00:08:21,840 --> 00:08:24,800
than

00:08:22,400 --> 00:08:27,840
the hardware landscape for mainstream

00:08:24,800 --> 00:08:30,400
operating systems on the desktop

00:08:27,840 --> 00:08:31,919
so it's even more out of scope to test

00:08:30,400 --> 00:08:34,719
it on all those platforms

00:08:31,919 --> 00:08:35,680
but if we can get actual performance and

00:08:34,719 --> 00:08:38,000
usage data

00:08:35,680 --> 00:08:38,880
of the browser in the wild then we can

00:08:38,000 --> 00:08:42,240
make decisions

00:08:38,880 --> 00:08:42,240
what works and what doesn't

00:08:42,800 --> 00:08:47,360
now let's take a look into what the

00:08:45,519 --> 00:08:51,600
current telemetry api

00:08:47,360 --> 00:08:51,600
as used in firefox desktop looks like

00:08:52,320 --> 00:08:56,480
this is a simple function call um and

00:08:55,360 --> 00:08:58,399
all it does

00:08:56,480 --> 00:09:00,399
is it increments a counter that's

00:08:58,399 --> 00:09:04,399
identified by some name

00:09:00,399 --> 00:09:06,640
and increments that essentially by one

00:09:04,399 --> 00:09:08,560
now the first thing you see is the

00:09:06,640 --> 00:09:09,040
function the scalar add which is called

00:09:08,560 --> 00:09:12,160
on some

00:09:09,040 --> 00:09:14,399
global telemetry object scalar is our

00:09:12,160 --> 00:09:16,480
naming of just a single value that can

00:09:14,399 --> 00:09:18,240
be changed

00:09:16,480 --> 00:09:20,080
second you have a string that's used as

00:09:18,240 --> 00:09:21,279
the identifier for what we call the

00:09:20,080 --> 00:09:24,000
metric

00:09:21,279 --> 00:09:26,560
that's the underlying data point that we

00:09:24,000 --> 00:09:28,480
actually want to collect

00:09:26,560 --> 00:09:29,839
in this case it's browser engagement max

00:09:28,480 --> 00:09:32,240
concurrent tab count

00:09:29,839 --> 00:09:34,399
in this case the name to some extent

00:09:32,240 --> 00:09:37,200
already describes

00:09:34,399 --> 00:09:39,920
what this data should be and then we

00:09:37,200 --> 00:09:41,760
increment it by one

00:09:39,920 --> 00:09:43,839
now you might wonder where does this

00:09:41,760 --> 00:09:45,680
data actually come from

00:09:43,839 --> 00:09:47,680
and there is actually one single source

00:09:45,680 --> 00:09:50,160
of truth in the firefox code base

00:09:47,680 --> 00:09:51,760
where this data is put in that's

00:09:50,160 --> 00:09:54,160
scalarcml

00:09:51,760 --> 00:09:54,880
scalia's yaml is a definition file that

00:09:54,160 --> 00:09:57,600
holds

00:09:54,880 --> 00:09:59,760
the identifier and a lot more metadata

00:09:57,600 --> 00:10:02,160
about this metric

00:09:59,760 --> 00:10:02,800
it's organized into category names

00:10:02,160 --> 00:10:04,800
whereas

00:10:02,800 --> 00:10:06,000
in this case browser engagement is

00:10:04,800 --> 00:10:08,160
actually the category

00:10:06,000 --> 00:10:09,279
and then our name is concurrent tab

00:10:08,160 --> 00:10:12,240
count

00:10:09,279 --> 00:10:13,519
it has more data on there for example it

00:10:12,240 --> 00:10:16,079
lists the numbers

00:10:13,519 --> 00:10:18,800
of the bugs that implemented or changed

00:10:16,079 --> 00:10:20,800
this metric

00:10:18,800 --> 00:10:22,399
it has a description so that everyone

00:10:20,800 --> 00:10:25,920
coming by can

00:10:22,399 --> 00:10:28,640
look up what this metric actually does

00:10:25,920 --> 00:10:30,240
and at best they don't need to know all

00:10:28,640 --> 00:10:31,519
the surrounding code where this data is

00:10:30,240 --> 00:10:33,200
actually collected to get an

00:10:31,519 --> 00:10:35,200
understanding of what they should be

00:10:33,200 --> 00:10:37,360
seeing

00:10:35,200 --> 00:10:38,560
then we have this expires field which

00:10:37,360 --> 00:10:41,279
actually tells us

00:10:38,560 --> 00:10:43,279
that this data won't be collected beyond

00:10:41,279 --> 00:10:46,240
firefox version 81.

00:10:43,279 --> 00:10:47,920
i said before sometimes or most often we

00:10:46,240 --> 00:10:49,279
don't actually want to collect the data

00:10:47,920 --> 00:10:51,200
for forever

00:10:49,279 --> 00:10:52,399
instead we stop at a certain version to

00:10:51,200 --> 00:10:54,959
collect this data

00:10:52,399 --> 00:10:55,440
and by then whoever is responsible for

00:10:54,959 --> 00:10:57,839
this

00:10:55,440 --> 00:11:01,120
needs to make a decision about the data

00:10:57,839 --> 00:11:03,279
and how it answers the question

00:11:01,120 --> 00:11:04,480
and last but not least there's also some

00:11:03,279 --> 00:11:07,360
form of owner

00:11:04,480 --> 00:11:08,959
in this definition file we have always

00:11:07,360 --> 00:11:10,000
at least someone assigned that's

00:11:08,959 --> 00:11:12,000
responsible

00:11:10,000 --> 00:11:13,839
for this metric so if anything goes

00:11:12,000 --> 00:11:15,680
wrong there or someone needs more

00:11:13,839 --> 00:11:18,079
information around this data

00:11:15,680 --> 00:11:19,360
or needs to find some analysis that

00:11:18,079 --> 00:11:22,320
happened

00:11:19,360 --> 00:11:24,399
they can look up who owns this metric

00:11:22,320 --> 00:11:26,720
and can talk to that person directly

00:11:24,399 --> 00:11:29,839
and sometimes that's not a single person

00:11:26,720 --> 00:11:29,839
sometimes that's faulty

00:11:30,000 --> 00:11:37,279
so how would an developer go from this

00:11:33,519 --> 00:11:40,320
block of definition in the yaml file

00:11:37,279 --> 00:11:43,120
to this api call there's a couple of

00:11:40,320 --> 00:11:45,040
things that over the years we figured

00:11:43,120 --> 00:11:46,720
are actually not nice for the developers

00:11:45,040 --> 00:11:48,320
anymore

00:11:46,720 --> 00:11:50,000
first of all we're passing in some

00:11:48,320 --> 00:11:51,519
opaque string that's used as an

00:11:50,000 --> 00:11:53,760
identifier

00:11:51,519 --> 00:11:54,560
but suddenly there are like underscores

00:11:53,760 --> 00:11:57,040
and dots

00:11:54,560 --> 00:11:58,480
and it's not really clear what's the

00:11:57,040 --> 00:12:00,000
pattern behind that

00:11:58,480 --> 00:12:02,000
in the definition file browser

00:12:00,000 --> 00:12:03,600
engagement was actually done with a dot

00:12:02,000 --> 00:12:06,000
but here it's underscore but then

00:12:03,600 --> 00:12:07,440
there's a dot between the category and

00:12:06,000 --> 00:12:09,760
the name

00:12:07,440 --> 00:12:10,720
and all of this is very opaque to the

00:12:09,760 --> 00:12:14,480
use to the

00:12:10,720 --> 00:12:14,480
developer that needs to use this

00:12:14,639 --> 00:12:19,440
also if they mistype this name there's

00:12:17,440 --> 00:12:19,920
no indication that something doesn't

00:12:19,440 --> 00:12:21,839
work

00:12:19,920 --> 00:12:24,160
they need to actually run this code

00:12:21,839 --> 00:12:28,399
check that telemetry is recorded

00:12:24,160 --> 00:12:30,639
by doing the action they are recording

00:12:28,399 --> 00:12:32,560
and also what if this is not a counter

00:12:30,639 --> 00:12:36,480
what function do they need to call

00:12:32,560 --> 00:12:38,800
scalar add only makes sense for counters

00:12:36,480 --> 00:12:40,399
so just from this idea we can get to a

00:12:38,800 --> 00:12:43,760
point where we can design

00:12:40,399 --> 00:12:43,760
a nicer api already

00:12:44,160 --> 00:12:51,440
so this

00:12:47,839 --> 00:12:53,519
is the api that we are aiming for

00:12:51,440 --> 00:12:54,800
let's split this up a little bit we have

00:12:53,519 --> 00:12:57,360
browser engagement

00:12:54,800 --> 00:12:59,040
dot max concurrent tab count dot adds

00:12:57,360 --> 00:13:00,959
wizard1

00:12:59,040 --> 00:13:03,360
now the browser engagement that's a

00:13:00,959 --> 00:13:05,680
category and that's an actual object

00:13:03,360 --> 00:13:07,839
available in the source code

00:13:05,680 --> 00:13:09,040
and the counter metric is now identified

00:13:07,839 --> 00:13:12,399
by an actual

00:13:09,040 --> 00:13:14,480
by an actual field on this object

00:13:12,399 --> 00:13:15,680
and as we know this is the counter we

00:13:14,480 --> 00:13:18,480
also know what

00:13:15,680 --> 00:13:19,279
methods counter supports in our case

00:13:18,480 --> 00:13:21,040
that's add

00:13:19,279 --> 00:13:22,720
because we only can increment this

00:13:21,040 --> 00:13:25,200
counter and

00:13:22,720 --> 00:13:28,399
incrementing works with an amount so we

00:13:25,200 --> 00:13:31,279
can pass it a positive integer

00:13:28,399 --> 00:13:31,760
and because we have this definition file

00:13:31,279 --> 00:13:33,920
we have

00:13:31,760 --> 00:13:36,160
all of this information about the metric

00:13:33,920 --> 00:13:38,800
readily available

00:13:36,160 --> 00:13:39,440
before compile time so we can do stuff

00:13:38,800 --> 00:13:41,600
with it

00:13:39,440 --> 00:13:42,959
to expose all of this information to the

00:13:41,600 --> 00:13:45,680
developer

00:13:42,959 --> 00:13:46,800
if we get to this api what works

00:13:45,680 --> 00:13:48,959
automatically is

00:13:46,800 --> 00:13:50,639
tab completion for browser engagement

00:13:48,959 --> 00:13:53,120
and for max current tab count

00:13:50,639 --> 00:13:54,880
what also works is tab completion for

00:13:53,120 --> 00:13:56,000
the right method that you can call on

00:13:54,880 --> 00:13:58,240
this

00:13:56,000 --> 00:14:00,240
and you automatically get a type check

00:13:58,240 --> 00:14:03,760
for what needs to be passed

00:14:00,240 --> 00:14:05,519
to this method so this is what we're

00:14:03,760 --> 00:14:07,199
aiming for

00:14:05,519 --> 00:14:10,320
so let's sum up the telemetry

00:14:07,199 --> 00:14:12,240
requirements for this new system

00:14:10,320 --> 00:14:14,800
first of all we want to keep this

00:14:12,240 --> 00:14:17,839
declarative definition of the metrics

00:14:14,800 --> 00:14:18,240
this scalar cml file that we had it

00:14:17,839 --> 00:14:20,560
should

00:14:18,240 --> 00:14:23,440
still exist in some form we might even

00:14:20,560 --> 00:14:25,760
need to extend it a little bit

00:14:23,440 --> 00:14:26,959
we also know that we current we first

00:14:25,760 --> 00:14:29,120
aimed for

00:14:26,959 --> 00:14:30,000
android so we needed to have this

00:14:29,120 --> 00:14:32,079
available in

00:14:30,000 --> 00:14:34,000
kotlin but the other thing we knew is

00:14:32,079 --> 00:14:36,959
that if we built the system

00:14:34,000 --> 00:14:38,480
it needs to work on multiple platforms

00:14:36,959 --> 00:14:40,240
at some point

00:14:38,480 --> 00:14:41,519
because we also want to get that into

00:14:40,240 --> 00:14:43,839
our other products

00:14:41,519 --> 00:14:45,680
and that could be ios that's our desktop

00:14:43,839 --> 00:14:48,320
browser shipped on multiple

00:14:45,680 --> 00:14:50,399
operating systems and potentially other

00:14:48,320 --> 00:14:52,720
applications as well

00:14:50,399 --> 00:14:54,560
and to not redo all the work all of this

00:14:52,720 --> 00:14:56,839
should be bundled in a single

00:14:54,560 --> 00:14:59,199
core implementation that can be used

00:14:56,839 --> 00:15:01,120
cross-platform

00:14:59,199 --> 00:15:02,800
and last but not least we want an

00:15:01,120 --> 00:15:04,639
ergonomic api

00:15:02,800 --> 00:15:06,399
and i said before we're targeting

00:15:04,639 --> 00:15:07,920
different platforms which also means

00:15:06,399 --> 00:15:08,800
we're targeting different programming

00:15:07,920 --> 00:15:11,839
languages

00:15:08,800 --> 00:15:12,639
in which those products are implemented

00:15:11,839 --> 00:15:15,279
and we want

00:15:12,639 --> 00:15:16,399
essentially the same nice api but with

00:15:15,279 --> 00:15:18,000
the right feeling

00:15:16,399 --> 00:15:20,240
per the language we're implementing it

00:15:18,000 --> 00:15:20,240
for

00:15:20,880 --> 00:15:26,000
now glean is the summary implementation

00:15:24,000 --> 00:15:29,279
of all of this

00:15:26,000 --> 00:15:32,639
glean is the project that we built

00:15:29,279 --> 00:15:35,360
with a rust core library that extends to

00:15:32,639 --> 00:15:36,320
multiple platforms which we now all

00:15:35,360 --> 00:15:41,839
support

00:15:36,320 --> 00:15:41,839
so let's dive into the glean sdk stack

00:15:46,560 --> 00:15:49,920
this is a very rough overview of what

00:15:48,800 --> 00:15:52,399
the glean sdk

00:15:49,920 --> 00:15:54,079
looks like on the top you have the

00:15:52,399 --> 00:15:55,440
different app implementations you have

00:15:54,079 --> 00:15:57,600
an android app

00:15:55,440 --> 00:15:59,440
you have an ios app and potentially

00:15:57,600 --> 00:16:02,399
other ones that i didn't even draw

00:15:59,440 --> 00:16:02,399
yet on this screen

00:16:02,639 --> 00:16:06,320
each of these apps uses the glean sdk as

00:16:05,440 --> 00:16:09,279
a dependency

00:16:06,320 --> 00:16:10,639
and calls into it and the top layer of

00:16:09,279 --> 00:16:12,959
the glean sdk

00:16:10,639 --> 00:16:14,880
is the language implementation that's

00:16:12,959 --> 00:16:16,639
either glen kotlin which provides us

00:16:14,880 --> 00:16:18,160
with kotlin bindings and also java

00:16:16,639 --> 00:16:20,880
bindings

00:16:18,160 --> 00:16:22,160
then there's glean swift which gives us

00:16:20,880 --> 00:16:24,320
a swift api

00:16:22,160 --> 00:16:26,480
on top of all of this and then we have a

00:16:24,320 --> 00:16:29,360
couple of more

00:16:26,480 --> 00:16:31,040
just below that we have the clean ffi

00:16:29,360 --> 00:16:33,600
that's the connecting layer

00:16:31,040 --> 00:16:35,360
between the high level dynamic language

00:16:33,600 --> 00:16:36,959
for the app

00:16:35,360 --> 00:16:38,959
and the lower level actual

00:16:36,959 --> 00:16:40,720
implementation of glee

00:16:38,959 --> 00:16:42,079
on the side we have this little tool

00:16:40,720 --> 00:16:44,160
called clean parser

00:16:42,079 --> 00:16:45,279
which is a little connection between the

00:16:44,160 --> 00:16:48,320
definition file

00:16:45,279 --> 00:16:49,519
as seen before that generates codes so

00:16:48,320 --> 00:16:52,560
the android and

00:16:49,519 --> 00:16:54,000
ios developers can actually benefit from

00:16:52,560 --> 00:16:56,399
having this information

00:16:54,000 --> 00:16:58,880
laid out as objects and available in the

00:16:56,399 --> 00:17:02,320
editors

00:16:58,880 --> 00:17:06,640
so let's look at the lowest layer first

00:17:02,320 --> 00:17:07,919
glean core gleamcore is a plain old rust

00:17:06,640 --> 00:17:10,319
crate

00:17:07,919 --> 00:17:12,000
it contains uh some structs and those

00:17:10,319 --> 00:17:16,079
drugs hold some state about

00:17:12,000 --> 00:17:18,319
how glean works it holds the database

00:17:16,079 --> 00:17:19,600
it knows how to write and read from the

00:17:18,319 --> 00:17:22,319
database

00:17:19,600 --> 00:17:24,400
it keeps track of some internal metrics

00:17:22,319 --> 00:17:26,160
so we not only measure the application

00:17:24,400 --> 00:17:30,080
but we can also measure

00:17:26,160 --> 00:17:31,760
uh glean itself and provide

00:17:30,080 --> 00:17:35,200
some metrics that are used in

00:17:31,760 --> 00:17:37,440
essentially every implementation as well

00:17:35,200 --> 00:17:39,200
now the advantage of this is this is

00:17:37,440 --> 00:17:41,919
really just a rust crate

00:17:39,200 --> 00:17:44,160
all the rust tooling works we can rust

00:17:41,919 --> 00:17:44,720
we can test this by just running cargo

00:17:44,160 --> 00:17:47,440
test

00:17:44,720 --> 00:17:49,039
and it works it works on every normal

00:17:47,440 --> 00:17:52,559
operating system be that

00:17:49,039 --> 00:17:54,080
mac os windows or linux and that makes

00:17:52,559 --> 00:17:56,640
development of this part

00:17:54,080 --> 00:17:57,520
really really comfortable for us we can

00:17:56,640 --> 00:17:59,760
rely

00:17:57,520 --> 00:18:01,840
on all the nice things rust provides for

00:17:59,760 --> 00:18:04,559
us we can rely on its guarantees

00:18:01,840 --> 00:18:06,799
we can use the ecosystem and use other

00:18:04,559 --> 00:18:09,039
crates available

00:18:06,799 --> 00:18:10,960
we also implement all the metric types

00:18:09,039 --> 00:18:14,240
we support

00:18:10,960 --> 00:18:15,679
this is essentially a very simplified

00:18:14,240 --> 00:18:18,640
version of the counter

00:18:15,679 --> 00:18:20,480
we talked about before a counter has an

00:18:18,640 --> 00:18:23,200
add function with an amount

00:18:20,480 --> 00:18:25,200
and all it needs to do is look into the

00:18:23,200 --> 00:18:26,160
database and increment whatever is in

00:18:25,200 --> 00:18:27,679
there

00:18:26,160 --> 00:18:29,679
we have some other metrics that are a

00:18:27,679 --> 00:18:31,679
bit more complex but all

00:18:29,679 --> 00:18:32,880
most of the logic for them is still

00:18:31,679 --> 00:18:34,559
implemented in rust

00:18:32,880 --> 00:18:37,200
which allows us to test them

00:18:34,559 --> 00:18:37,200
individually

00:18:38,400 --> 00:18:43,280
now just above this clean core

00:18:40,400 --> 00:18:45,039
implementation is the glean ffi

00:18:43,280 --> 00:18:48,480
this again is the connection layer

00:18:45,039 --> 00:18:51,600
between the cottle implementation

00:18:48,480 --> 00:18:54,840
and the lower core layer

00:18:51,600 --> 00:18:57,840
ffi stands for a foreign function

00:18:54,840 --> 00:18:57,840
interface

00:18:58,640 --> 00:19:04,960
rust from the beginning of

00:19:01,919 --> 00:19:06,160
becoming a thing was able to interface

00:19:04,960 --> 00:19:07,840
with other programming

00:19:06,160 --> 00:19:11,280
programming languages through this

00:19:07,840 --> 00:19:14,559
foreign function interface ffi

00:19:11,280 --> 00:19:16,480
for simplicity the ffi is essentially a

00:19:14,559 --> 00:19:19,440
deterministic and simple naming

00:19:16,480 --> 00:19:20,480
of symbols such as functions as you have

00:19:19,440 --> 00:19:23,600
them

00:19:20,480 --> 00:19:27,360
and it's also the c compatible api

00:19:23,600 --> 00:19:29,600
that's the application binary interface

00:19:27,360 --> 00:19:32,000
which essentially describes how things

00:19:29,600 --> 00:19:35,039
are laid out in memory

00:19:32,000 --> 00:19:37,200
um and how functions need to get called

00:19:35,039 --> 00:19:39,840
and where to pass parameters into those

00:19:37,200 --> 00:19:39,840
functions

00:19:40,880 --> 00:19:44,720
rust is able to cross the ffi in both

00:19:43,679 --> 00:19:47,440
directions

00:19:44,720 --> 00:19:49,440
the first is calling c functions that's

00:19:47,440 --> 00:19:51,039
when you want to integrate an existing

00:19:49,440 --> 00:19:54,880
external c library

00:19:51,039 --> 00:19:58,080
and use that to do your work

00:19:54,880 --> 00:19:59,840
the way you do this is you need to copy

00:19:58,080 --> 00:20:01,520
and convert the declarations of all the

00:19:59,840 --> 00:20:02,480
function calls that you know from this

00:20:01,520 --> 00:20:06,480
library

00:20:02,480 --> 00:20:07,120
into its trust equivalent you then put

00:20:06,480 --> 00:20:10,240
them in this

00:20:07,120 --> 00:20:13,280
extern block and then

00:20:10,240 --> 00:20:16,080
also need to swap around the types so

00:20:13,280 --> 00:20:18,720
that you're not using the c types but

00:20:16,080 --> 00:20:21,440
using their equivalence and rust

00:20:18,720 --> 00:20:23,600
and then you can just call this as if it

00:20:21,440 --> 00:20:25,840
is a normal rust function

00:20:23,600 --> 00:20:28,080
during the build this all hopefully gets

00:20:25,840 --> 00:20:29,840
linked together properly

00:20:28,080 --> 00:20:32,320
and you get a working library out of

00:20:29,840 --> 00:20:35,440
this of course this is all

00:20:32,320 --> 00:20:36,960
very very unsafe in the terms as rust

00:20:35,440 --> 00:20:39,200
defines unsafety

00:20:36,960 --> 00:20:40,559
because you're crossing over in sea land

00:20:39,200 --> 00:20:42,240
you can't rely

00:20:40,559 --> 00:20:43,919
on all the nice things that rust

00:20:42,240 --> 00:20:47,039
provides you such as

00:20:43,919 --> 00:20:49,440
ownership and boring lifetimes

00:20:47,039 --> 00:20:50,480
or even the layout of certain data

00:20:49,440 --> 00:20:53,919
things

00:20:50,480 --> 00:20:55,679
in memory now the other way works just

00:20:53,919 --> 00:20:59,360
as well

00:20:55,679 --> 00:21:01,039
you can get called from c as well

00:20:59,360 --> 00:21:03,440
for this you need a little bit more

00:21:01,039 --> 00:21:06,640
annotations to make it all work

00:21:03,440 --> 00:21:07,039
the first one is if you see on the slide

00:21:06,640 --> 00:21:09,200
here

00:21:07,039 --> 00:21:11,919
is a rust implementation of a function

00:21:09,200 --> 00:21:13,760
we're going to be able to call from c

00:21:11,919 --> 00:21:15,440
the very first thing you see is the no

00:21:13,760 --> 00:21:18,080
mangle attribute

00:21:15,440 --> 00:21:19,280
this attribute tells the compiler to use

00:21:18,080 --> 00:21:23,200
the function name as

00:21:19,280 --> 00:21:25,120
is and place it into the final library

00:21:23,200 --> 00:21:26,480
if you don't have this the compiler will

00:21:25,120 --> 00:21:28,720
actually change the name

00:21:26,480 --> 00:21:29,679
to encode a little bit more information

00:21:28,720 --> 00:21:32,559
into the time

00:21:29,679 --> 00:21:33,840
into the name of the function but to be

00:21:32,559 --> 00:21:37,280
callable from c

00:21:33,840 --> 00:21:40,960
you need the plane name the next thing

00:21:37,280 --> 00:21:43,679
that you see is this extern c annotation

00:21:40,960 --> 00:21:44,000
this tells the compiler what abi it

00:21:43,679 --> 00:21:47,280
should

00:21:44,000 --> 00:21:48,720
expect for this function and in this

00:21:47,280 --> 00:21:51,919
case the api

00:21:48,720 --> 00:21:54,559
describes how parameters or

00:21:51,919 --> 00:21:56,720
arguments are passed into the function

00:21:54,559 --> 00:21:58,720
and how you

00:21:56,720 --> 00:22:00,240
how you return data from this function

00:21:58,720 --> 00:22:01,039
whether that's through the stack or

00:22:00,240 --> 00:22:04,240
certain

00:22:01,039 --> 00:22:08,559
registers now

00:22:04,240 --> 00:22:11,280
the cabi is much less

00:22:08,559 --> 00:22:13,840
expressive in what it can do compared to

00:22:11,280 --> 00:22:16,880
what rust is able to do

00:22:13,840 --> 00:22:18,960
so you will always have the case that

00:22:16,880 --> 00:22:22,240
you need to convert into something that

00:22:18,960 --> 00:22:23,760
the seaside can actually understand

00:22:22,240 --> 00:22:25,919
and you can always see on this little

00:22:23,760 --> 00:22:26,400
example one of the cases where that is

00:22:25,919 --> 00:22:29,600
the

00:22:26,400 --> 00:22:32,640
where where that comes out

00:22:29,600 --> 00:22:35,360
and that's strings in sea land

00:22:32,640 --> 00:22:37,440
strings are always encoded with a null

00:22:35,360 --> 00:22:39,760
byte at the end

00:22:37,440 --> 00:22:41,200
whereas in rust land strings always

00:22:39,760 --> 00:22:42,880
carry their length

00:22:41,200 --> 00:22:44,720
so you need to convert back and forth

00:22:42,880 --> 00:22:47,760
between those

00:22:44,720 --> 00:22:49,520
luckily rust has tooling for that you

00:22:47,760 --> 00:22:50,960
can just use the c-string which is

00:22:49,520 --> 00:22:51,520
essentially a wrapper around the rust

00:22:50,960 --> 00:22:53,360
string

00:22:51,520 --> 00:22:56,159
which appends the nullbyte and gives you

00:22:53,360 --> 00:22:56,159
a pointer to it

00:22:57,600 --> 00:23:00,799
next up to make this all work you

00:22:59,919 --> 00:23:03,280
actually

00:23:00,799 --> 00:23:04,240
also need the declaration of your

00:23:03,280 --> 00:23:08,400
function

00:23:04,240 --> 00:23:11,360
in c so c knows what to call and

00:23:08,400 --> 00:23:13,039
the compiler knows how to do this

00:23:11,360 --> 00:23:15,280
usually you would write this somewhere

00:23:13,039 --> 00:23:16,880
in a code or provide a header file

00:23:15,280 --> 00:23:18,320
but there's a tool that does this for

00:23:16,880 --> 00:23:20,400
you c

00:23:18,320 --> 00:23:21,440
bind shank can create the c header

00:23:20,400 --> 00:23:24,799
automatically

00:23:21,440 --> 00:23:26,640
if you do if you expose a public c api

00:23:24,799 --> 00:23:28,320
so again on the left side you have the

00:23:26,640 --> 00:23:30,720
rest code which just

00:23:28,320 --> 00:23:31,919
implements a rust function that is

00:23:30,720 --> 00:23:35,440
exposed as a

00:23:31,919 --> 00:23:37,520
c api function and if you throw this

00:23:35,440 --> 00:23:38,880
against c by engine you get the output

00:23:37,520 --> 00:23:43,360
on the right

00:23:38,880 --> 00:23:43,360
and that's the declaration in c syntax

00:23:44,159 --> 00:23:48,159
this is really really a nice tool

00:23:46,400 --> 00:23:50,080
especially once you grow beyond

00:23:48,159 --> 00:23:51,760
just a single function so you don't need

00:23:50,080 --> 00:23:53,760
to type it out all the time

00:23:51,760 --> 00:23:56,640
and you definitely don't make mistakes

00:23:53,760 --> 00:23:56,640
when typing it out

00:23:57,120 --> 00:24:03,840
one more thing that we use in glean is

00:24:00,240 --> 00:24:05,120
the crate called ffi support ffi support

00:24:03,840 --> 00:24:07,919
is a small library

00:24:05,120 --> 00:24:10,080
that helps us simplify implementing all

00:24:07,919 --> 00:24:13,200
these ffi stuff

00:24:10,080 --> 00:24:14,240
it's not written by us but by another

00:24:13,200 --> 00:24:16,640
team at mozilla

00:24:14,240 --> 00:24:18,000
the application services team they do

00:24:16,640 --> 00:24:20,320
essentially similar things

00:24:18,000 --> 00:24:22,960
as we do writing rust libraries and

00:24:20,320 --> 00:24:25,200
shipping them to mobile platforms

00:24:22,960 --> 00:24:27,039
they came up with ffi support and we're

00:24:25,200 --> 00:24:29,039
very happy users and contributors to

00:24:27,039 --> 00:24:33,840
this great as well

00:24:29,039 --> 00:24:33,840
one thing ffi support gives us

00:24:33,919 --> 00:24:40,480
is the into ffi trade

00:24:37,520 --> 00:24:42,799
the into f of i trade is a mechanism to

00:24:40,480 --> 00:24:45,600
express how to convert rust types into

00:24:42,799 --> 00:24:48,559
ffi compatible types

00:24:45,600 --> 00:24:49,840
an other few little things in the code

00:24:48,559 --> 00:24:52,880
this allows us to

00:24:49,840 --> 00:24:55,440
basically write dress code and then have

00:24:52,880 --> 00:24:56,400
the conversion to c compatible type done

00:24:55,440 --> 00:24:59,200
automatically

00:24:56,400 --> 00:25:00,960
whenever we pass this through our ffi

00:24:59,200 --> 00:25:02,880
functions

00:25:00,960 --> 00:25:04,400
i said before there's c string that does

00:25:02,880 --> 00:25:06,960
this for strings

00:25:04,400 --> 00:25:07,520
and f i essentially reuses that for

00:25:06,960 --> 00:25:11,279
strings

00:25:07,520 --> 00:25:11,279
but implements it for other types as

00:25:12,840 --> 00:25:19,120
well another thing if i support

00:25:16,000 --> 00:25:20,960
brings us is ffi string i mentioned

00:25:19,120 --> 00:25:25,120
strings a couple of times now

00:25:20,960 --> 00:25:27,440
um has now terminated a list of bytes

00:25:25,120 --> 00:25:29,279
whatever vi screen gives us essentially

00:25:27,440 --> 00:25:32,000
a safe wrap around this

00:25:29,279 --> 00:25:33,840
so when we get a string passed in we

00:25:32,000 --> 00:25:34,240
actually have a rust type we can work

00:25:33,840 --> 00:25:36,320
with

00:25:34,240 --> 00:25:37,679
we can turn this into an actual rast

00:25:36,320 --> 00:25:41,679
string

00:25:37,679 --> 00:25:42,000
or read data out of it ffi string also

00:25:41,679 --> 00:25:45,120
adds

00:25:42,000 --> 00:25:47,279
a lifetime to what we get in so

00:25:45,120 --> 00:25:48,880
we can rely on the compiler to tell us

00:25:47,279 --> 00:25:52,880
if we misuse this

00:25:48,880 --> 00:25:55,360
data we can for we cannot for example

00:25:52,880 --> 00:25:56,000
store this data anywhere if we want to

00:25:55,360 --> 00:25:58,320
do this

00:25:56,000 --> 00:25:59,360
we actually need to allocate it into an

00:25:58,320 --> 00:26:02,480
actual rest string

00:25:59,360 --> 00:26:05,840
and store that away the c side

00:26:02,480 --> 00:26:07,840
on could just remove this data after

00:26:05,840 --> 00:26:09,520
this function returns so we can't rely

00:26:07,840 --> 00:26:11,760
on it

00:26:09,520 --> 00:26:13,760
the third thing we get from ffi support

00:26:11,760 --> 00:26:16,799
is the concurrent handle map

00:26:13,760 --> 00:26:17,520
this is essentially a locked map that

00:26:16,799 --> 00:26:19,840
gives us

00:26:17,520 --> 00:26:21,279
handles to the data we insert these

00:26:19,840 --> 00:26:23,600
handles can be expressed

00:26:21,279 --> 00:26:27,039
as simple integers and simple integers

00:26:23,600 --> 00:26:29,520
we can just pass back over the ffi

00:26:27,039 --> 00:26:31,039
when we get back such an handle we can

00:26:29,520 --> 00:26:33,200
get back to the object

00:26:31,039 --> 00:26:34,400
that is saved under this handle and we

00:26:33,200 --> 00:26:36,960
can also ensure

00:26:34,400 --> 00:26:39,039
that the handle we got actually maps to

00:26:36,960 --> 00:26:40,880
the type that we expect

00:26:39,039 --> 00:26:42,640
if you would use pointers to any of the

00:26:40,880 --> 00:26:44,960
data the

00:26:42,640 --> 00:26:46,080
other side could easily screw up the

00:26:44,960 --> 00:26:48,640
pointer handling

00:26:46,080 --> 00:26:49,360
or pass pointers in the one place and we

00:26:48,640 --> 00:26:53,039
would never

00:26:49,360 --> 00:26:55,760
know until we actually see a crash

00:26:53,039 --> 00:26:57,440
by using a concurrent handle map here we

00:26:55,760 --> 00:27:00,400
get another benefit

00:26:57,440 --> 00:27:01,760
this is all behind a lock so even if we

00:27:00,400 --> 00:27:02,880
get called from a multi-threaded

00:27:01,760 --> 00:27:05,200
application

00:27:02,880 --> 00:27:07,279
we are automatically threat safe simply

00:27:05,200 --> 00:27:10,080
because our data is behind a lock

00:27:07,279 --> 00:27:13,840
and we never allow two indications to

00:27:10,080 --> 00:27:13,840
run them that data at the same time

00:27:13,919 --> 00:27:19,120
now that we talked a lot about the iffi

00:27:16,880 --> 00:27:20,080
let's talk about what the ffi compiles

00:27:19,120 --> 00:27:23,679
to

00:27:20,080 --> 00:27:23,679
let's talk about compile targets

00:27:24,480 --> 00:27:27,919
most people will probably write compile

00:27:27,120 --> 00:27:30,080
and run

00:27:27,919 --> 00:27:31,760
the ros code on their own machine you

00:27:30,080 --> 00:27:33,039
have your laptop you type your ros code

00:27:31,760 --> 00:27:36,000
you type cargo run

00:27:33,039 --> 00:27:37,760
it builds and runs the code but

00:27:36,000 --> 00:27:41,200
sometimes you probably also want to

00:27:37,760 --> 00:27:43,840
compile to that other machine over there

00:27:41,200 --> 00:27:44,799
and as it turns out you're programming

00:27:43,840 --> 00:27:46,559
on windows

00:27:44,799 --> 00:27:48,559
but that machine over there is linux

00:27:46,559 --> 00:27:50,960
because it's your server

00:27:48,559 --> 00:27:52,720
so how do you do this that part is

00:27:50,960 --> 00:27:54,880
called cross compiling

00:27:52,720 --> 00:27:56,399
now luckily the rest compiler is a cross

00:27:54,880 --> 00:27:58,640
compiler by default

00:27:56,399 --> 00:27:59,919
it knows how to compile for other

00:27:58,640 --> 00:28:02,000
targets

00:27:59,919 --> 00:28:04,399
if you're using rest app you can just

00:28:02,000 --> 00:28:06,799
type restart target list

00:28:04,399 --> 00:28:08,240
and you get a list of all the targets

00:28:06,799 --> 00:28:11,600
that rust

00:28:08,240 --> 00:28:13,840
actually knows now

00:28:11,600 --> 00:28:16,559
these are over 80 targets that rostop

00:28:13,840 --> 00:28:18,399
can already deliver to you now why are

00:28:16,559 --> 00:28:19,760
some installed and why not

00:28:18,399 --> 00:28:21,919
well there's still like some

00:28:19,760 --> 00:28:22,559
pre-compiled libraries like the standard

00:28:21,919 --> 00:28:24,640
library

00:28:22,559 --> 00:28:26,480
provided for all these targets so you

00:28:24,640 --> 00:28:29,600
just need to download them first

00:28:26,480 --> 00:28:31,679
and then you can build your code

00:28:29,600 --> 00:28:32,799
now what is the target you made might

00:28:31,679 --> 00:28:35,360
ask

00:28:32,799 --> 00:28:36,720
well it's essentially the combination of

00:28:35,360 --> 00:28:39,120
the architecture

00:28:36,720 --> 00:28:40,080
the operating system and the api you

00:28:39,120 --> 00:28:41,760
want

00:28:40,080 --> 00:28:44,159
now sometimes there's an operating

00:28:41,760 --> 00:28:46,159
system so it's just unknown

00:28:44,159 --> 00:28:48,320
and most of the time the api actually

00:28:46,159 --> 00:28:48,880
specifies what lipc you're compiling

00:28:48,320 --> 00:28:50,640
against

00:28:48,880 --> 00:28:53,120
which then makes certain assumptions

00:28:50,640 --> 00:28:56,880
about the abi

00:28:53,120 --> 00:28:58,720
the target is is expressed as a triple

00:28:56,880 --> 00:29:00,559
now the triple has three to five

00:28:58,720 --> 00:29:03,120
components as you see here

00:29:00,559 --> 00:29:05,120
and depending who you ask and i'm not

00:29:03,120 --> 00:29:08,799
totally ignoring the one or

00:29:05,120 --> 00:29:08,799
uh off by one or more error here

00:29:09,520 --> 00:29:14,880
now this is the list of the 10 targets

00:29:11,919 --> 00:29:18,480
the glean sdk actually compiles for

00:29:14,880 --> 00:29:22,000
we have four targets for android alone

00:29:18,480 --> 00:29:23,760
um for both rm and x86 and one of them

00:29:22,000 --> 00:29:26,240
is actually the x86

00:29:23,760 --> 00:29:27,679
emulator or simulator then you have your

00:29:26,240 --> 00:29:32,799
default targets for

00:29:27,679 --> 00:29:36,000
the mainstream operating systems linux

00:29:32,799 --> 00:29:38,080
macos and windows and we also have two

00:29:36,000 --> 00:29:40,880
irs targets

00:29:38,080 --> 00:29:42,720
where the first one is the arm target

00:29:40,880 --> 00:29:44,559
that's the actual devices and then you

00:29:42,720 --> 00:29:45,360
have the x86 target which is the

00:29:44,559 --> 00:29:48,799
simulator

00:29:45,360 --> 00:29:51,679
running on your mac now

00:29:48,799 --> 00:29:53,440
there's one little detail that i

00:29:51,679 --> 00:29:56,880
basically skipped over so far

00:29:53,440 --> 00:29:59,440
in that rust is a cross compiler yes

00:29:56,880 --> 00:30:00,399
but just by downloading those it can

00:29:59,440 --> 00:30:03,039
compile for

00:30:00,399 --> 00:30:04,720
the target you're specifying but it will

00:30:03,039 --> 00:30:07,279
most likely not produce

00:30:04,720 --> 00:30:08,640
a workable library or binary for you to

00:30:07,279 --> 00:30:10,960
use

00:30:08,640 --> 00:30:11,840
and the reason is rust has no idea about

00:30:10,960 --> 00:30:13,600
the linker

00:30:11,840 --> 00:30:15,520
and the additional libraries that any of

00:30:13,600 --> 00:30:17,440
these targets need

00:30:15,520 --> 00:30:22,000
so you most likely will need some more

00:30:17,440 --> 00:30:25,360
setup to get this all working

00:30:22,000 --> 00:30:27,200
we wrote this down for our part

00:30:25,360 --> 00:30:29,039
and it's actually not too complicated

00:30:27,200 --> 00:30:30,559
anymore

00:30:29,039 --> 00:30:32,960
but it's certainly a thing that you need

00:30:30,559 --> 00:30:33,600
to think about we compile for these

00:30:32,960 --> 00:30:35,440
targets

00:30:33,600 --> 00:30:38,159
on ci so every release build is

00:30:35,440 --> 00:30:40,159
definitely built for all these targets

00:30:38,159 --> 00:30:43,279
and that gets a bit hairy to get it all

00:30:40,159 --> 00:30:46,720
working but once you get it there

00:30:43,279 --> 00:30:46,720
you can mostly rely on it

00:30:46,960 --> 00:30:51,840
next up we're going to look at the glean

00:30:48,640 --> 00:30:51,840
kotlin implementation

00:30:58,159 --> 00:31:02,720
i explained the cork rate and i

00:31:00,320 --> 00:31:05,039
explained how the ffi

00:31:02,720 --> 00:31:06,159
provides a layer on top of that now

00:31:05,039 --> 00:31:07,919
we're looking at the

00:31:06,159 --> 00:31:09,600
implementation that application is going

00:31:07,919 --> 00:31:11,279
to use

00:31:09,600 --> 00:31:13,200
and we are specifically going to look at

00:31:11,279 --> 00:31:14,480
the coupling application

00:31:13,200 --> 00:31:17,039
i'm going to make some comments about

00:31:14,480 --> 00:31:20,240
the others afterwards

00:31:17,039 --> 00:31:20,960
now how do you make kotlin talk with a c

00:31:20,240 --> 00:31:24,399
api

00:31:20,960 --> 00:31:26,080
which is provided by this clean ffi

00:31:24,399 --> 00:31:28,159
if you look that up the first thing you

00:31:26,080 --> 00:31:30,799
find is jni

00:31:28,159 --> 00:31:32,720
jni's and here i quote is the java

00:31:30,799 --> 00:31:35,120
native interface

00:31:32,720 --> 00:31:37,120
it defines a way for the bytecode that

00:31:35,120 --> 00:31:39,279
android compiles from managed code to

00:31:37,120 --> 00:31:43,279
interact with native code

00:31:39,279 --> 00:31:46,399
manage code here means kotlin or java

00:31:43,279 --> 00:31:49,200
and native code here means anything that

00:31:46,399 --> 00:31:51,600
exposes the c api that could be c for

00:31:49,200 --> 00:31:55,120
assets rust

00:31:51,600 --> 00:31:57,279
now jni is a bit special

00:31:55,120 --> 00:31:59,120
there's a crate out there called jni

00:31:57,279 --> 00:32:01,200
which provides you a lot of the things

00:31:59,120 --> 00:32:03,440
around this to make this all work

00:32:01,200 --> 00:32:05,600
but let's look at hello world example

00:32:03,440 --> 00:32:07,440
for jni

00:32:05,600 --> 00:32:10,159
on the left you see the rust code that's

00:32:07,440 --> 00:32:12,640
necessary to make jane eye work

00:32:10,159 --> 00:32:14,080
again you have this no manual attribute

00:32:12,640 --> 00:32:17,440
to tell the compiler

00:32:14,080 --> 00:32:19,279
not to mix up the name then you have an

00:32:17,440 --> 00:32:21,679
extern system declaration

00:32:19,279 --> 00:32:23,360
that's essentially extern c with a

00:32:21,679 --> 00:32:24,559
little bit of other details on some

00:32:23,360 --> 00:32:26,480
platforms

00:32:24,559 --> 00:32:27,679
and then you have the function name and

00:32:26,480 --> 00:32:29,840
the function name here is

00:32:27,679 --> 00:32:31,200
java underscore hello world underscore

00:32:29,840 --> 00:32:33,840
hello

00:32:31,200 --> 00:32:35,039
and that's already kinda awkward you

00:32:33,840 --> 00:32:37,840
need to encode

00:32:35,039 --> 00:32:40,559
actual information into this type so the

00:32:37,840 --> 00:32:42,960
jni site can find this

00:32:40,559 --> 00:32:44,799
on the right side you see the java code

00:32:42,960 --> 00:32:46,640
that is able to call the native code

00:32:44,799 --> 00:32:48,480
here

00:32:46,640 --> 00:32:51,440
you have some class hello world you

00:32:48,480 --> 00:32:54,720
define that there is a static method

00:32:51,440 --> 00:32:56,320
sorry a static method called hello with

00:32:54,720 --> 00:32:57,600
string input and output

00:32:56,320 --> 00:32:59,440
and then you also need to load the

00:32:57,600 --> 00:33:01,279
library

00:32:59,440 --> 00:33:03,519
and if you see both sides now you see

00:33:01,279 --> 00:33:05,519
that the java class hello world

00:33:03,519 --> 00:33:06,720
is actually what's encoded into the

00:33:05,519 --> 00:33:09,919
function name

00:33:06,720 --> 00:33:11,440
on the rust side now i don't want to

00:33:09,919 --> 00:33:13,519
write code like this

00:33:11,440 --> 00:33:14,480
and i certainly didn't but if you're

00:33:13,519 --> 00:33:16,799
interested in this

00:33:14,480 --> 00:33:18,399
definitely check out otavio's talk from

00:33:16,799 --> 00:33:21,519
last year's was latem

00:33:18,399 --> 00:33:23,760
about how they wrote a project that

00:33:21,519 --> 00:33:25,600
interoperates with android ios and web

00:33:23,760 --> 00:33:27,519
assembly

00:33:25,600 --> 00:33:30,000
now as i said i don't want to write code

00:33:27,519 --> 00:33:33,279
like this and i certainly didn't

00:33:30,000 --> 00:33:35,519
so what are other ways to do this

00:33:33,279 --> 00:33:37,519
to repeat we wanted to connect kotlin

00:33:35,519 --> 00:33:40,480
with the underlying ffi library

00:33:37,519 --> 00:33:40,960
that's written in rust and the next

00:33:40,480 --> 00:33:43,360
project

00:33:40,960 --> 00:33:46,000
you're stumbling across if you look this

00:33:43,360 --> 00:33:49,039
up is jna

00:33:46,000 --> 00:33:50,000
jna is the java native access and accord

00:33:49,039 --> 00:33:52,799
again here

00:33:50,000 --> 00:33:55,120
jna provides java programs easy access

00:33:52,799 --> 00:33:57,279
to native shared libraries without

00:33:55,120 --> 00:34:00,480
writing anything but java code

00:33:57,279 --> 00:34:02,559
no jni or native code is required

00:34:00,480 --> 00:34:05,279
again java here you can replace with

00:34:02,559 --> 00:34:07,919
kotlin the same applies

00:34:05,279 --> 00:34:08,879
we can't talk to some native code that's

00:34:07,919 --> 00:34:11,679
c or rust

00:34:08,879 --> 00:34:12,639
or whatever looks like c and can call

00:34:11,679 --> 00:34:14,159
this

00:34:12,639 --> 00:34:16,320
so let's look how the hello world for

00:34:14,159 --> 00:34:18,000
this looks like

00:34:16,320 --> 00:34:19,919
and this is the hello world code that's

00:34:18,000 --> 00:34:21,119
essentially the same code i've shown

00:34:19,919 --> 00:34:23,040
before

00:34:21,119 --> 00:34:24,960
we have our no manual attribute we have

00:34:23,040 --> 00:34:27,359
extern c

00:34:24,960 --> 00:34:29,440
we define our function with its normal

00:34:27,359 --> 00:34:32,159
name and then we pass around what's

00:34:29,440 --> 00:34:34,320
essentially c types

00:34:32,159 --> 00:34:35,359
on the kotlin side we need to load this

00:34:34,320 --> 00:34:37,119
library

00:34:35,359 --> 00:34:39,520
and it looks like a little bit more code

00:34:37,119 --> 00:34:41,040
but just um it's not really

00:34:39,520 --> 00:34:42,800
you just need to tell it the name of the

00:34:41,040 --> 00:34:43,520
library that you're loading then you

00:34:42,800 --> 00:34:45,760
need uh

00:34:43,520 --> 00:34:47,359
to list out all the declarations of the

00:34:45,760 --> 00:34:48,720
functions that are available on this

00:34:47,359 --> 00:34:51,839
library

00:34:48,720 --> 00:34:54,960
and later as seen in the last

00:34:51,839 --> 00:34:58,400
line you can call this as if it was

00:34:54,960 --> 00:35:00,800
pure kotlin code under the hood jna

00:34:58,400 --> 00:35:03,440
takes care of passing things back and

00:35:00,800 --> 00:35:05,200
forth over the ffi

00:35:03,440 --> 00:35:07,359
now to fit this all together there's one

00:35:05,200 --> 00:35:08,880
more thing we need

00:35:07,359 --> 00:35:11,440
we need to integrate this into the build

00:35:08,880 --> 00:35:14,000
system android applications

00:35:11,440 --> 00:35:15,359
use gradle as their build system most of

00:35:14,000 --> 00:35:17,760
the time

00:35:15,359 --> 00:35:18,560
now luckily for me and my team we didn't

00:35:17,760 --> 00:35:21,200
need to write

00:35:18,560 --> 00:35:22,640
anything to make this all happen others

00:35:21,200 --> 00:35:24,640
figured this out before us

00:35:22,640 --> 00:35:25,760
as i said the application service team

00:35:24,640 --> 00:35:28,960
was a bit quicker

00:35:25,760 --> 00:35:31,760
in building that project

00:35:28,960 --> 00:35:33,280
so they built the rust android gradle

00:35:31,760 --> 00:35:35,760
plugin

00:35:33,280 --> 00:35:36,800
that essentially gives us um what you

00:35:35,760 --> 00:35:38,880
see here in the slide

00:35:36,800 --> 00:35:40,320
we can add this little cargo block into

00:35:38,880 --> 00:35:42,079
our build files

00:35:40,320 --> 00:35:45,040
we give it the name of what we're trying

00:35:42,079 --> 00:35:46,720
to build and where to find the code

00:35:45,040 --> 00:35:48,480
and we also tell it the targets it needs

00:35:46,720 --> 00:35:50,480
to compile for

00:35:48,480 --> 00:35:52,960
now whenever we run a full gradle build

00:35:50,480 --> 00:35:56,079
of our library

00:35:52,960 --> 00:35:57,680
this plugin under the hood invokes cargo

00:35:56,079 --> 00:35:59,200
finds the right tool chains and

00:35:57,680 --> 00:36:01,440
compilers and linkers

00:35:59,200 --> 00:36:03,599
for the android platforms it does that

00:36:01,440 --> 00:36:05,680
through the android sdk and ndk as

00:36:03,599 --> 00:36:09,359
you've installed it

00:36:05,680 --> 00:36:12,000
invox cargo compiles that copies the

00:36:09,359 --> 00:36:12,560
generated library into some place that

00:36:12,000 --> 00:36:14,320
your

00:36:12,560 --> 00:36:16,720
kotlin code will actually be able to

00:36:14,320 --> 00:36:16,720
load it

00:36:18,000 --> 00:36:21,680
so that was the coupler implementation

00:36:20,720 --> 00:36:24,839
let's

00:36:21,680 --> 00:36:26,240
briefly look into other glean

00:36:24,839 --> 00:36:27,839
implementations

00:36:26,240 --> 00:36:29,680
the very first one and that's on the

00:36:27,839 --> 00:36:32,480
slide is swift

00:36:29,680 --> 00:36:34,560
swift is was comparably easy to the cut

00:36:32,480 --> 00:36:35,119
implementation because swift actually

00:36:34,560 --> 00:36:38,800
speaks

00:36:35,119 --> 00:36:40,800
c so what we do is we use c binding to

00:36:38,800 --> 00:36:42,800
generate a c header

00:36:40,800 --> 00:36:44,240
then we put that all into the build

00:36:42,800 --> 00:36:45,839
system and that's actually the most

00:36:44,240 --> 00:36:49,359
complicated part of it

00:36:45,839 --> 00:36:49,839
and then we are able to call the swift

00:36:49,359 --> 00:36:54,560
side

00:36:49,839 --> 00:36:56,800
from the rust side from swift

00:36:54,560 --> 00:36:59,280
there's a bit translation sometimes

00:36:56,800 --> 00:37:02,800
needed between different data types

00:36:59,280 --> 00:37:05,359
but all in all it's not that much magic

00:37:02,800 --> 00:37:05,359
after all

00:37:05,760 --> 00:37:08,880
the next implementation we had was

00:37:07,440 --> 00:37:10,800
python

00:37:08,880 --> 00:37:14,000
python again is pretty similar

00:37:10,800 --> 00:37:16,800
conceptually to the swift implementation

00:37:14,000 --> 00:37:17,839
we're using cffi a python library that

00:37:16,800 --> 00:37:20,880
can also load the

00:37:17,839 --> 00:37:23,200
c header and at runtime it then

00:37:20,880 --> 00:37:24,240
loads the dynamic library and provides

00:37:23,200 --> 00:37:26,960
us access to

00:37:24,240 --> 00:37:28,400
the methods that we defined in the c

00:37:26,960 --> 00:37:30,560
header

00:37:28,400 --> 00:37:32,640
there's a little bit more involved to

00:37:30,560 --> 00:37:36,240
convert between python types

00:37:32,640 --> 00:37:38,240
and c types simply because python has

00:37:36,240 --> 00:37:41,040
very different layout of types

00:37:38,240 --> 00:37:42,400
than c expects them but with some

00:37:41,040 --> 00:37:44,640
tooling and utilities

00:37:42,400 --> 00:37:47,760
that's not actually too much work except

00:37:44,640 --> 00:37:47,760
needing to write all of this

00:37:48,880 --> 00:37:53,920
now the nearest addition in the family

00:37:51,920 --> 00:37:56,240
of language implementations of the glean

00:37:53,920 --> 00:37:57,920
sdk is c-sharp

00:37:56,240 --> 00:37:59,680
implementation-wise this is pretty

00:37:57,920 --> 00:38:01,760
similar to kotlin

00:37:59,680 --> 00:38:03,200
we list out all the declarations of all

00:38:01,760 --> 00:38:06,800
the ffi functions

00:38:03,200 --> 00:38:08,640
converted to c-sharp replace some of the

00:38:06,800 --> 00:38:09,760
c-types with their equivalence in

00:38:08,640 --> 00:38:12,079
c-sharp

00:38:09,760 --> 00:38:13,599
then we load the generated library at

00:38:12,079 --> 00:38:17,040
runtime

00:38:13,599 --> 00:38:17,040
and can call methods on it

00:38:17,760 --> 00:38:22,079
note there are more implementations

00:38:19,359 --> 00:38:24,720
actually coming up that we're working on

00:38:22,079 --> 00:38:26,320
and one of the first one is c plus plus

00:38:24,720 --> 00:38:28,960
we're bringing back glean

00:38:26,320 --> 00:38:30,560
into firefox desktop and firefox itself

00:38:28,960 --> 00:38:32,960
is still mostly written in c

00:38:30,560 --> 00:38:36,160
plus plus so that's where we need to

00:38:32,960 --> 00:38:36,160
provide an api for

00:38:36,320 --> 00:38:40,000
firefox is also written in javascript to

00:38:38,480 --> 00:38:41,839
a large extent

00:38:40,000 --> 00:38:43,599
so we're also going to have a javascript

00:38:41,839 --> 00:38:47,440
api soon

00:38:43,599 --> 00:38:49,760
because of how firefox on desktop works

00:38:47,440 --> 00:38:51,440
there's a slight shift in how we need to

00:38:49,760 --> 00:38:54,320
design this

00:38:51,440 --> 00:38:56,480
and a lot of the parts are already in

00:38:54,320 --> 00:38:58,720
firefox to make this all happen

00:38:56,480 --> 00:39:00,640
so if you're using firefox nightly you

00:38:58,720 --> 00:39:03,760
will soon actually use glean

00:39:00,640 --> 00:39:07,119
as the telemetry system inside firefox

00:39:03,760 --> 00:39:09,280
as one of the telemetry systems

00:39:07,119 --> 00:39:11,119
and last but not least we're actually

00:39:09,280 --> 00:39:12,960
working on a rust api

00:39:11,119 --> 00:39:15,680
now you might wonder wait you're writing

00:39:12,960 --> 00:39:18,800
rust why don't you have a rust api

00:39:15,680 --> 00:39:19,760
the reason is glean core is written in a

00:39:18,800 --> 00:39:22,640
way

00:39:19,760 --> 00:39:24,160
that the clean ffi can expose all its

00:39:22,640 --> 00:39:26,560
functionality

00:39:24,160 --> 00:39:28,480
but we didn't bother yet to provide a

00:39:26,560 --> 00:39:30,400
nice api

00:39:28,480 --> 00:39:31,599
on top of all of this to make it usable

00:39:30,400 --> 00:39:34,240
for us

00:39:31,599 --> 00:39:35,440
users we simply didn't had anyone that

00:39:34,240 --> 00:39:37,920
needed that

00:39:35,440 --> 00:39:39,920
but now we have the first request to

00:39:37,920 --> 00:39:42,240
actually provide a rust api

00:39:39,920 --> 00:39:42,960
not only in firefox desktop but also

00:39:42,240 --> 00:39:45,440
outside

00:39:42,960 --> 00:39:46,800
so we're going to work on a rust api

00:39:45,440 --> 00:39:50,079
that's usable

00:39:46,800 --> 00:39:50,079
simply as a roscrate

00:39:50,800 --> 00:39:55,440
now i'd like to

00:39:53,920 --> 00:39:57,680
notice the implementations out of the

00:39:55,440 --> 00:40:00,000
way i'd like to jump over in some of the

00:39:57,680 --> 00:40:02,800
challenges we were facing

00:40:00,000 --> 00:40:04,079
when developing a cross-platform library

00:40:02,800 --> 00:40:05,760
not everything there went

00:40:04,079 --> 00:40:11,839
smoothly and there were a lot of things

00:40:05,760 --> 00:40:11,839
we had to figure out

00:40:14,160 --> 00:40:17,599
the very first thing and that came up a

00:40:16,079 --> 00:40:21,520
lot already

00:40:17,599 --> 00:40:24,640
is data types the data types rust nodes

00:40:21,520 --> 00:40:26,319
the data types that are expressed in c

00:40:24,640 --> 00:40:29,680
and the data types that are available in

00:40:26,319 --> 00:40:32,079
all the other languages we're targeting

00:40:29,680 --> 00:40:34,560
they are very different so we always

00:40:32,079 --> 00:40:36,640
need to convert between those

00:40:34,560 --> 00:40:37,680
now the first one we need to look at is

00:40:36,640 --> 00:40:41,040
numbers

00:40:37,680 --> 00:40:44,160
these are actually pretty simple numbers

00:40:41,040 --> 00:40:47,599
the number types in rust all have their

00:40:44,160 --> 00:40:49,839
bit width defined and there are

00:40:47,599 --> 00:40:51,359
equivalents in both kotlin and swift and

00:40:49,839 --> 00:40:52,880
in the other languages we implement as

00:40:51,359 --> 00:40:54,560
well

00:40:52,880 --> 00:40:56,560
a little bit of care needs to be taken

00:40:54,560 --> 00:40:59,599
for eye size and use

00:40:56,560 --> 00:41:03,440
which are platform defined size

00:40:59,599 --> 00:41:04,960
types they do have their equivalence

00:41:03,440 --> 00:41:06,960
in both kotlin and swift and the other

00:41:04,960 --> 00:41:08,480
languages but you need to

00:41:06,960 --> 00:41:10,480
make sure that you're actually using

00:41:08,480 --> 00:41:14,400
those when passing data

00:41:10,480 --> 00:41:17,520
over the ffi in any of these types

00:41:14,400 --> 00:41:18,560
one little nit there as well kotlin and

00:41:17,520 --> 00:41:22,319
java

00:41:18,560 --> 00:41:25,359
don't really have unsigned integer types

00:41:22,319 --> 00:41:26,079
so what we defer to is we just mostly

00:41:25,359 --> 00:41:28,480
use

00:41:26,079 --> 00:41:30,800
sign types whenever we can so we don't

00:41:28,480 --> 00:41:33,119
get a mismatch between the sites

00:41:30,800 --> 00:41:35,839
there's experimental support for

00:41:33,119 --> 00:41:37,839
unsigned integers in kotlin

00:41:35,839 --> 00:41:40,079
so you could use that and rely on that

00:41:37,839 --> 00:41:40,079
as well

00:41:40,560 --> 00:41:43,920
the next type we need to look at is a

00:41:42,560 --> 00:41:46,160
bool

00:41:43,920 --> 00:41:47,359
a bool is essentially one bit of

00:41:46,160 --> 00:41:49,920
information

00:41:47,359 --> 00:41:50,720
it's either true expressed as a one or

00:41:49,920 --> 00:41:55,280
its faults

00:41:50,720 --> 00:41:58,319
expressed as a zero that's one bit

00:41:55,280 --> 00:42:00,880
now the size of a bool in rust

00:41:58,319 --> 00:42:02,000
is actually eight bit one byte the

00:42:00,880 --> 00:42:05,119
reason behind that is

00:42:02,000 --> 00:42:09,440
we can't really address smaller than

00:42:05,119 --> 00:42:12,480
one byte so that's not too bad

00:42:09,440 --> 00:42:15,200
where it goes bad or it goes wrong

00:42:12,480 --> 00:42:15,760
is when we try to interface with kotlin

00:42:15,200 --> 00:42:19,119
because

00:42:15,760 --> 00:42:22,480
the way kotlin sees bulls is well

00:42:19,119 --> 00:42:25,119
32-bit that's four bytes

00:42:22,480 --> 00:42:26,800
that's not only a waste of memory space

00:42:25,119 --> 00:42:29,920
that we're using up for

00:42:26,800 --> 00:42:32,000
simple one bit of information this is

00:42:29,920 --> 00:42:33,200
also a complete mismatch between the two

00:42:32,000 --> 00:42:37,440
sites

00:42:33,200 --> 00:42:39,680
so we can't pass over bulls over the ffi

00:42:37,440 --> 00:42:42,400
what we do is we always convert them to

00:42:39,680 --> 00:42:44,000
u8 or byte on either side

00:42:42,400 --> 00:42:48,000
and then just compare whether we got a

00:42:44,000 --> 00:42:48,000
one or zero to get out a bool again

00:42:48,319 --> 00:42:53,599
the next thing are strings we use

00:42:51,040 --> 00:42:56,720
strings heavily

00:42:53,599 --> 00:42:58,800
if you use strings as parameters to the

00:42:56,720 --> 00:43:02,240
your ffi functions

00:42:58,800 --> 00:43:04,960
you're in luck jna and also

00:43:02,240 --> 00:43:06,480
the implementations on other platforms

00:43:04,960 --> 00:43:09,359
essentially are able

00:43:06,480 --> 00:43:10,839
to take their version of a string and

00:43:09,359 --> 00:43:14,960
convert that into c

00:43:10,839 --> 00:43:18,000
string so if you pass over a

00:43:14,960 --> 00:43:18,720
kotlin string into the ffi under the

00:43:18,000 --> 00:43:22,079
hood

00:43:18,720 --> 00:43:23,359
jna allocates new block of memory for

00:43:22,079 --> 00:43:26,000
that string

00:43:23,359 --> 00:43:28,640
copies over the string utf-8 encoded if

00:43:26,000 --> 00:43:28,640
you tell it so

00:43:29,200 --> 00:43:35,040
adds the nullbyte and then passes over a

00:43:31,680 --> 00:43:36,880
pointer to this allocated data

00:43:35,040 --> 00:43:39,200
after the function call it will actually

00:43:36,880 --> 00:43:41,839
also make sure this data is

00:43:39,200 --> 00:43:41,839
deleted again

00:43:43,520 --> 00:43:50,560
so what you get on the

00:43:46,640 --> 00:43:52,079
rest side is this ffi string that we can

00:43:50,560 --> 00:43:54,480
then deal with

00:43:52,079 --> 00:43:55,599
and yes that always includes this double

00:43:54,480 --> 00:43:58,560
allocation

00:43:55,599 --> 00:43:59,040
and that's a bit unfortunate but for us

00:43:58,560 --> 00:44:01,119
that's

00:43:59,040 --> 00:44:03,280
not really a performance bottleneck at

00:44:01,119 --> 00:44:03,280
all

00:44:05,200 --> 00:44:10,400
the next thing is getting out strings

00:44:07,520 --> 00:44:12,960
returning them from your edify

00:44:10,400 --> 00:44:14,240
that's a bit more complicated overall

00:44:12,960 --> 00:44:17,760
the way we do this

00:44:14,240 --> 00:44:21,040
is we allocate a rust string inside

00:44:17,760 --> 00:44:22,079
the rest layer we then turn that into a

00:44:21,040 --> 00:44:25,680
c-string

00:44:22,079 --> 00:44:28,079
using which adds the nullbyte

00:44:25,680 --> 00:44:29,119
and then we return a pointer to the

00:44:28,079 --> 00:44:30,720
stator

00:44:29,119 --> 00:44:32,960
and also need to make sure we're not

00:44:30,720 --> 00:44:36,560
de-allocating that data

00:44:32,960 --> 00:44:39,599
on the kotlin side we get this pointer

00:44:36,560 --> 00:44:41,680
and then need to get the data out

00:44:39,599 --> 00:44:44,560
some utility functions again make this

00:44:41,680 --> 00:44:44,560
really easy for us

00:44:45,040 --> 00:44:48,560
first of all on the bottom you see get

00:44:47,040 --> 00:44:50,800
resting this just

00:44:48,560 --> 00:44:52,160
reads out the null terminated string

00:44:50,800 --> 00:44:55,040
from the pointer

00:44:52,160 --> 00:44:57,760
reads it as udf-8 encoded data and turns

00:44:55,040 --> 00:45:00,079
that into a kotlin string

00:44:57,760 --> 00:45:01,760
on the top is the function that

00:45:00,079 --> 00:45:04,079
developers would actually or that we

00:45:01,760 --> 00:45:05,839
actually use in the kotlin bindings get

00:45:04,079 --> 00:45:07,680
a consumer string

00:45:05,839 --> 00:45:11,200
the little detail you need to know here

00:45:07,680 --> 00:45:13,280
is that you also need to ensure that the

00:45:11,200 --> 00:45:14,560
allocation on the rest side is freed

00:45:13,280 --> 00:45:17,280
again so

00:45:14,560 --> 00:45:19,440
when we copied out the data we tell the

00:45:17,280 --> 00:45:22,560
ffi to just deallocate the

00:45:19,440 --> 00:45:24,480
just allocated string again

00:45:22,560 --> 00:45:25,839
now again we have this double allocation

00:45:24,480 --> 00:45:28,480
where rust allocates

00:45:25,839 --> 00:45:29,119
then kotlin allocates copies of our data

00:45:28,480 --> 00:45:32,160
and then

00:45:29,119 --> 00:45:32,800
tells rust to deallocate again so there

00:45:32,160 --> 00:45:37,040
is a bit

00:45:32,800 --> 00:45:39,760
of a overhead there we use

00:45:37,040 --> 00:45:43,280
strings as return values very sparingly

00:45:39,760 --> 00:45:43,280
so it's not a big deal for us

00:45:44,800 --> 00:45:48,160
the next thing we use is enams plain old

00:45:47,280 --> 00:45:49,839
enums

00:45:48,160 --> 00:45:52,560
are just a list of the variants they

00:45:49,839 --> 00:45:55,200
have essentially each variant has

00:45:52,560 --> 00:45:57,680
an integer representation and for now

00:45:55,200 --> 00:46:00,560
we're actually just using this integer

00:45:57,680 --> 00:46:01,200
representation we convert it to the

00:46:00,560 --> 00:46:02,880
integer

00:46:01,200 --> 00:46:05,440
and turn it back into the enum on the

00:46:02,880 --> 00:46:08,480
rust side

00:46:05,440 --> 00:46:10,560
now there's one little detail that

00:46:08,480 --> 00:46:12,000
makes this a little bit of a hassle and

00:46:10,560 --> 00:46:14,079
that we need to ensure

00:46:12,000 --> 00:46:15,760
that both the kotlin side and the rust

00:46:14,079 --> 00:46:19,200
side agree exactly

00:46:15,760 --> 00:46:22,000
about the order of variants in the enum

00:46:19,200 --> 00:46:23,680
and also the values of the enum luckily

00:46:22,000 --> 00:46:27,119
if you don't tell them otherwise

00:46:23,680 --> 00:46:30,880
they will both start counting at zero so

00:46:27,119 --> 00:46:30,880
you can pretty much rely on that

00:46:31,359 --> 00:46:35,280
we need to do this translation all

00:46:33,200 --> 00:46:36,560
manually but this is certainly a part

00:46:35,280 --> 00:46:39,920
which we could automate

00:46:36,560 --> 00:46:42,560
eventually now rust

00:46:39,920 --> 00:46:43,599
actually has another enum type well it's

00:46:42,560 --> 00:46:46,560
not another type

00:46:43,599 --> 00:46:48,480
but it's an extension of enums enums can

00:46:46,560 --> 00:46:50,319
carry data

00:46:48,480 --> 00:46:52,240
by this you're allowed to have different

00:46:50,319 --> 00:46:55,280
variants carry different data

00:46:52,240 --> 00:46:58,800
and the whole thing is still signal type

00:46:55,280 --> 00:47:00,400
now on the left you see a somewhat weird

00:46:58,800 --> 00:47:02,960
looking

00:47:00,400 --> 00:47:03,599
enum in rust because this actually

00:47:02,960 --> 00:47:06,480
includes

00:47:03,599 --> 00:47:08,640
some c compatible types this is the enum

00:47:06,480 --> 00:47:10,640
we use on the ffi layer

00:47:08,640 --> 00:47:12,400
and there's one little annotation on top

00:47:10,640 --> 00:47:15,760
of that they represent

00:47:12,400 --> 00:47:18,400
u8 this is specified in rust

00:47:15,760 --> 00:47:19,760
and what it does it turns this enum when

00:47:18,400 --> 00:47:24,079
converted into a

00:47:19,760 --> 00:47:24,800
c type into essentially a tech union and

00:47:24,079 --> 00:47:28,079
uses

00:47:24,800 --> 00:47:30,160
a tag that's represented as a ui u8

00:47:28,079 --> 00:47:33,119
that's one byte

00:47:30,160 --> 00:47:33,599
the stack then essentially just encodes

00:47:33,119 --> 00:47:36,960
which

00:47:33,599 --> 00:47:39,680
variant the union has that is one of the

00:47:36,960 --> 00:47:42,000
three variants in this example

00:47:39,680 --> 00:47:44,079
on the right side you see what this tech

00:47:42,000 --> 00:47:46,079
union would look like in c

00:47:44,079 --> 00:47:48,400
this is what c binding actually

00:47:46,079 --> 00:47:49,520
generates from this representation of

00:47:48,400 --> 00:47:52,960
the enum

00:47:49,520 --> 00:47:56,000
at first you get the different tags then

00:47:52,960 --> 00:47:56,640
you see that the tag is actually encoded

00:47:56,000 --> 00:47:59,839
as the

00:47:56,640 --> 00:48:02,559
un8 which is the eight bit

00:47:59,839 --> 00:48:03,440
integer and then for each variant that

00:48:02,559 --> 00:48:05,920
has data

00:48:03,440 --> 00:48:07,440
we have their own struct in this case we

00:48:05,920 --> 00:48:09,359
have the upload body

00:48:07,440 --> 00:48:10,960
which contains the document id and the

00:48:09,359 --> 00:48:13,520
body that you also see

00:48:10,960 --> 00:48:14,000
in the ros code but at the very first

00:48:13,520 --> 00:48:17,119
field

00:48:14,000 --> 00:48:20,720
it contains this tag

00:48:17,119 --> 00:48:24,000
and last in this sample of code you see

00:48:20,720 --> 00:48:25,040
the union now c bunchen is actually

00:48:24,000 --> 00:48:27,440
smart enough

00:48:25,040 --> 00:48:28,640
to see that neither rate nor done have

00:48:27,440 --> 00:48:30,400
additional data

00:48:28,640 --> 00:48:32,160
so all the information you need to carry

00:48:30,400 --> 00:48:34,880
around for them is the tech

00:48:32,160 --> 00:48:36,400
they don't need their own structure

00:48:34,880 --> 00:48:39,680
upload on the other hand

00:48:36,400 --> 00:48:40,720
does need the structure and making this

00:48:39,680 --> 00:48:44,079
a union

00:48:40,720 --> 00:48:46,400
means that the union simply has the size

00:48:44,079 --> 00:48:48,160
of the biggest of its variance which in

00:48:46,400 --> 00:48:51,599
this case is the struct

00:48:48,160 --> 00:48:53,760
but because the tag is always the first

00:48:51,599 --> 00:48:55,280
variable in this whole thing you can

00:48:53,760 --> 00:48:57,920
always weed out the tag

00:48:55,280 --> 00:48:58,800
and get valid data back and if it points

00:48:57,920 --> 00:49:03,839
to upload

00:48:58,800 --> 00:49:03,839
you are allowed to read the upload body

00:49:04,000 --> 00:49:08,640
now this is the c version luckily we can

00:49:07,200 --> 00:49:12,800
translate that into kotlin

00:49:08,640 --> 00:49:15,200
quite easily jna the library we're using

00:49:12,800 --> 00:49:16,079
has implementation of both structure and

00:49:15,200 --> 00:49:18,720
union

00:49:16,079 --> 00:49:19,760
so with a little bit of boilerplate that

00:49:18,720 --> 00:49:22,400
we type out

00:49:19,760 --> 00:49:24,160
we essentially replicate this tech union

00:49:22,400 --> 00:49:26,480
in kotlin

00:49:24,160 --> 00:49:27,920
there's one little knit again this is

00:49:26,480 --> 00:49:29,920
mostly a manual process

00:49:27,920 --> 00:49:32,000
translating the rust code on the left to

00:49:29,920 --> 00:49:34,800
the cutling code on the right

00:49:32,000 --> 00:49:35,839
and that is a little bit annoying and if

00:49:34,800 --> 00:49:37,760
you get this wrong

00:49:35,839 --> 00:49:39,839
you might accidentally read

00:49:37,760 --> 00:49:42,400
uninitialized memory

00:49:39,839 --> 00:49:43,280
and that's not good so you need to make

00:49:42,400 --> 00:49:45,520
double sure

00:49:43,280 --> 00:49:47,119
that both sides agree on how the data

00:49:45,520 --> 00:49:49,599
looks like

00:49:47,119 --> 00:49:51,359
this is also a part where i'd like to

00:49:49,599 --> 00:49:54,960
see this just being automated

00:49:51,359 --> 00:49:54,960
i'm pretty sure it would be possible

00:49:55,200 --> 00:49:58,240
if you actually want to pass over other

00:49:57,680 --> 00:50:01,280
data

00:49:58,240 --> 00:50:01,839
and return this from your ffi one thing

00:50:01,280 --> 00:50:04,800
we do

00:50:01,839 --> 00:50:06,960
is we simply encode this as json on the

00:50:04,800 --> 00:50:10,079
rest side we already heavily rely on

00:50:06,960 --> 00:50:12,800
certain to do some serialization for us

00:50:10,079 --> 00:50:14,720
so adding json serialization on the ffi

00:50:12,800 --> 00:50:17,040
was pretty simple

00:50:14,720 --> 00:50:17,839
we turn our we serialize our data into

00:50:17,040 --> 00:50:20,079
json

00:50:17,839 --> 00:50:22,160
turn that json into a c string and

00:50:20,079 --> 00:50:26,319
return that c string

00:50:22,160 --> 00:50:28,800
on the kotlin side we read the string

00:50:26,319 --> 00:50:30,240
read it out as a kotlin string then

00:50:28,800 --> 00:50:33,520
parse the json

00:50:30,240 --> 00:50:36,240
and can then look at the json data

00:50:33,520 --> 00:50:37,119
again this works for us because we only

00:50:36,240 --> 00:50:40,160
use this for

00:50:37,119 --> 00:50:42,559
test functions so we are first fine with

00:50:40,160 --> 00:50:46,319
the performance it provides us

00:50:42,559 --> 00:50:48,400
and we also find with the little bit of

00:50:46,319 --> 00:50:49,599
overhead it has on us as developers

00:50:48,400 --> 00:50:52,960
where we need to ensure

00:50:49,599 --> 00:50:55,359
the json representation is seen

00:50:52,960 --> 00:50:57,839
the same on both sides both in rust and

00:50:55,359 --> 00:50:57,839
kotlin

00:50:58,079 --> 00:51:03,839
and the last thing is you could

00:51:01,200 --> 00:51:04,800
just drop all this and actually just use

00:51:03,839 --> 00:51:06,800
protobuf

00:51:04,800 --> 00:51:08,800
that's what the application service team

00:51:06,800 --> 00:51:10,160
is using for much richer data they need

00:51:08,800 --> 00:51:12,880
to return

00:51:10,160 --> 00:51:13,760
the advantage is they can define their

00:51:12,880 --> 00:51:16,960
data layout

00:51:13,760 --> 00:51:18,000
once and then have the protocol protobuf

00:51:16,960 --> 00:51:22,079
compiler

00:51:18,000 --> 00:51:24,960
generate both rust code and kotlin code

00:51:22,079 --> 00:51:26,640
then their ffi simply serializes the

00:51:24,960 --> 00:51:29,599
data into a protobuf

00:51:26,640 --> 00:51:30,079
returns that over the ffi and the kotlin

00:51:29,599 --> 00:51:32,319
site

00:51:30,079 --> 00:51:33,119
deserializes that using the generated

00:51:32,319 --> 00:51:35,599
code

00:51:33,119 --> 00:51:37,440
and has an actual kotlin object to work

00:51:35,599 --> 00:51:39,200
with

00:51:37,440 --> 00:51:40,800
this not only gives you the safer

00:51:39,200 --> 00:51:42,400
translation where you don't need to do

00:51:40,800 --> 00:51:46,800
this all manually

00:51:42,400 --> 00:51:48,720
it also is faster than parsing json

00:51:46,800 --> 00:51:50,240
now enough with the data types let's

00:51:48,720 --> 00:51:52,960
look let's look at

00:51:50,240 --> 00:51:55,440
a couple more things that we stumbled

00:51:52,960 --> 00:51:58,000
upon while implementing this

00:51:55,440 --> 00:52:00,240
the first off is the optimizer on the

00:51:58,000 --> 00:52:03,920
android side

00:52:00,240 --> 00:52:04,960
r8 is a new optimizer and minifire

00:52:03,920 --> 00:52:08,559
written by google

00:52:04,960 --> 00:52:11,119
that's essentially a successor to the

00:52:08,559 --> 00:52:13,359
pretty well-known proguard tool in the

00:52:11,119 --> 00:52:17,040
android world

00:52:13,359 --> 00:52:21,599
r8 essentially takes the jvm byte code

00:52:17,040 --> 00:52:24,000
then minifies and optimizes this code

00:52:21,599 --> 00:52:24,880
for a lot of application this is very

00:52:24,000 --> 00:52:27,280
essential

00:52:24,880 --> 00:52:29,280
the optimizations it can do are very

00:52:27,280 --> 00:52:31,280
impressive and really speed up certain

00:52:29,280 --> 00:52:34,960
applications a lot

00:52:31,280 --> 00:52:36,000
the problem is it's pretty buggy in some

00:52:34,960 --> 00:52:38,640
places

00:52:36,000 --> 00:52:39,920
and it actually might over optimize j

00:52:38,640 --> 00:52:42,880
and a code

00:52:39,920 --> 00:52:45,200
there's a lot of things inside jna and

00:52:42,880 --> 00:52:47,760
r8 can't look through all of these

00:52:45,200 --> 00:52:48,880
and sometimes it just decides that it

00:52:47,760 --> 00:52:51,040
thinks

00:52:48,880 --> 00:52:53,680
some of this code is not needed throw

00:52:51,040 --> 00:52:55,200
that away because that's an optimization

00:52:53,680 --> 00:52:57,520
but then your final application doesn't

00:52:55,200 --> 00:53:00,079
run anymore

00:52:57,520 --> 00:53:01,119
there are a few things that you can do

00:53:00,079 --> 00:53:04,400
to

00:53:01,119 --> 00:53:05,119
prevent this first of all jna actually

00:53:04,400 --> 00:53:07,520
tells you

00:53:05,119 --> 00:53:09,040
to include certain rules that ensure

00:53:07,520 --> 00:53:13,040
when r8 runs

00:53:09,040 --> 00:53:15,040
it does not touch the jna parts

00:53:13,040 --> 00:53:16,240
additionally you probably want to tell

00:53:15,040 --> 00:53:19,280
it to not touch

00:53:16,240 --> 00:53:20,160
your own ffi code either that's what the

00:53:19,280 --> 00:53:23,920
last rule does

00:53:20,160 --> 00:53:25,920
for us there still might be bugs and we

00:53:23,920 --> 00:53:28,079
stumbled up on a big one

00:53:25,920 --> 00:53:29,040
we found a workaround for that and we're

00:53:28,079 --> 00:53:32,480
hoping this bug

00:53:29,040 --> 00:53:35,520
actually gets fixed but this is def

00:53:32,480 --> 00:53:39,119
sorry this is definitely a part that

00:53:35,520 --> 00:53:43,280
cost me a lot of time uh

00:53:39,119 --> 00:53:44,720
invested into trying to fix this

00:53:43,280 --> 00:53:47,040
now one more thing i'd like to talk

00:53:44,720 --> 00:53:47,040
about

00:53:47,119 --> 00:53:51,359
is extra libraries that you need to

00:53:49,280 --> 00:53:53,359
include in your build

00:53:51,359 --> 00:53:55,200
we're very lucky in that we need exactly

00:53:53,359 --> 00:53:57,760
one external library

00:53:55,200 --> 00:53:59,599
and that external library is compiled as

00:53:57,760 --> 00:54:01,440
part of cargo build

00:53:59,599 --> 00:54:03,200
and that's statically compiled into our

00:54:01,440 --> 00:54:06,400
library

00:54:03,200 --> 00:54:09,280
through a build rs file and that

00:54:06,400 --> 00:54:10,319
luckily just works now the problem is

00:54:09,280 --> 00:54:12,960
build rs

00:54:10,319 --> 00:54:14,079
is just pure rs code anyone could do

00:54:12,960 --> 00:54:16,480
anything there

00:54:14,079 --> 00:54:17,280
it's used to compile external libraries

00:54:16,480 --> 00:54:20,079
if needed

00:54:17,280 --> 00:54:21,599
but everyone does it differently some

00:54:20,079 --> 00:54:25,680
library wrappers

00:54:21,599 --> 00:54:27,839
just look for the library in your system

00:54:25,680 --> 00:54:29,680
that mostly doesn't work if you're

00:54:27,839 --> 00:54:32,640
cross-compiling

00:54:29,680 --> 00:54:35,119
they might try to download this library

00:54:32,640 --> 00:54:36,480
and then compile it and then link it

00:54:35,119 --> 00:54:38,319
but there's still the difference whether

00:54:36,480 --> 00:54:41,359
they dynamically link it

00:54:38,319 --> 00:54:42,319
or they statically link it so my

00:54:41,359 --> 00:54:44,720
recommendation is

00:54:42,319 --> 00:54:46,400
if you actually need to do this ensure

00:54:44,720 --> 00:54:49,280
that you're building and linking your

00:54:46,400 --> 00:54:49,599
c dependency statically so they all end

00:54:49,280 --> 00:54:52,799
up

00:54:49,599 --> 00:54:55,119
in your final library otherwise you also

00:54:52,799 --> 00:54:58,400
need to ship all these c dependencies

00:54:55,119 --> 00:55:00,799
compiled and the second tip

00:54:58,400 --> 00:55:02,319
is consider pre-compiling the

00:55:00,799 --> 00:55:04,480
dependencies you have

00:55:02,319 --> 00:55:06,160
and ship them to your developers make

00:55:04,480 --> 00:55:07,839
them available somehow

00:55:06,160 --> 00:55:10,480
especially if you have large

00:55:07,839 --> 00:55:13,200
dependencies not everyone has the full

00:55:10,480 --> 00:55:15,440
setup to also compile these

00:55:13,200 --> 00:55:17,839
and sometimes it can be a real hassle

00:55:15,440 --> 00:55:20,000
but your ci system probably

00:55:17,839 --> 00:55:21,359
already knows how to compile for all

00:55:20,000 --> 00:55:23,599
these different platforms

00:55:21,359 --> 00:55:24,880
that your developers are also using so

00:55:23,599 --> 00:55:27,040
just pre-compile them

00:55:24,880 --> 00:55:29,119
make them available to the developers

00:55:27,040 --> 00:55:31,520
and that integrate that somehow into

00:55:29,119 --> 00:55:31,520
your build

00:55:31,680 --> 00:55:37,200
now one thing you might now ask so

00:55:35,040 --> 00:55:38,720
what about the platform so far we've

00:55:37,200 --> 00:55:42,240
only seen it

00:55:38,720 --> 00:55:44,640
talk one direction and that's because

00:55:42,240 --> 00:55:46,480
it really only goes one direction we're

00:55:44,640 --> 00:55:49,040
always calling kotlin

00:55:46,480 --> 00:55:49,760
we're always calling from kotlin into

00:55:49,040 --> 00:55:52,640
rust

00:55:49,760 --> 00:55:54,720
we return data on this function call but

00:55:52,640 --> 00:55:57,040
there is never a case where

00:55:54,720 --> 00:56:01,359
from the rest side we call back into

00:55:57,040 --> 00:56:05,440
kotlin to invoke any platform behavior

00:56:01,359 --> 00:56:08,799
i know that it can work and the jn

00:56:05,440 --> 00:56:10,799
i crate that i presented earlier is able

00:56:08,799 --> 00:56:12,079
to provide you the functionality to call

00:56:10,799 --> 00:56:14,319
java or kotlin code

00:56:12,079 --> 00:56:16,000
so you could use that but we don't do

00:56:14,319 --> 00:56:19,040
this so i haven't looked much

00:56:16,000 --> 00:56:19,599
further into this we on the other hand

00:56:19,040 --> 00:56:22,400
we do

00:56:19,599 --> 00:56:24,559
rely on kotlin to do things for us and

00:56:22,400 --> 00:56:26,640
pass us that data

00:56:24,559 --> 00:56:27,680
so some things that kotlin actually does

00:56:26,640 --> 00:56:30,319
for us

00:56:27,680 --> 00:56:31,839
are getting the data storage path

00:56:30,319 --> 00:56:34,559
because this differs

00:56:31,839 --> 00:56:36,400
on how it works on android where there's

00:56:34,559 --> 00:56:39,599
ios and certainly is completely

00:56:36,400 --> 00:56:39,599
different on desktop again

00:56:39,760 --> 00:56:43,200
it also gets us some information about

00:56:41,680 --> 00:56:45,119
the system and the application

00:56:43,200 --> 00:56:46,480
like version numbers and operating

00:56:45,119 --> 00:56:49,680
system versions

00:56:46,480 --> 00:56:53,119
and so on we also rely

00:56:49,680 --> 00:56:55,040
on kotlin to do the http

00:56:53,119 --> 00:56:57,280
or network communication for us we

00:56:55,040 --> 00:56:58,079
essentially tell the kotlin side here's

00:56:57,280 --> 00:57:03,200
data

00:56:58,079 --> 00:57:03,200
now use http to upload it to this server

00:57:03,280 --> 00:57:06,880
and the last thing we rely on for for

00:57:06,000 --> 00:57:10,000
kotlin

00:57:06,880 --> 00:57:12,880
is time the

00:57:10,000 --> 00:57:15,119
time sources the kotlin apis use and the

00:57:12,880 --> 00:57:17,040
time sources that the rest apis use

00:57:15,119 --> 00:57:18,480
are slightly different and we haven't

00:57:17,040 --> 00:57:20,640
yet invested the time

00:57:18,480 --> 00:57:23,839
to simply move that over to rust and use

00:57:20,640 --> 00:57:23,839
the right time sources there

00:57:24,160 --> 00:57:30,319
so before i wrap this all up i want to

00:57:27,440 --> 00:57:34,079
look a little bit ahead

00:57:30,319 --> 00:57:37,040
for us the future is certainly glee

00:57:34,079 --> 00:57:38,880
we use we deployed glean on the new

00:57:37,040 --> 00:57:40,160
firefox android browser and it's an

00:57:38,880 --> 00:57:42,319
active use there

00:57:40,160 --> 00:57:43,520
it's in a lot of different products at

00:57:42,319 --> 00:57:45,440
mozilla already

00:57:43,520 --> 00:57:47,440
and we're currently working on getting

00:57:45,440 --> 00:57:50,960
it into more to replace the old

00:57:47,440 --> 00:57:50,960
telemetry systems we had there

00:57:51,119 --> 00:57:56,000
one thing i am looking forward to

00:57:53,599 --> 00:57:59,040
because that was on my to-do list

00:57:56,000 --> 00:58:01,599
ever since we started is some form of

00:57:59,040 --> 00:58:03,839
reducing the overhead we need to invest

00:58:01,599 --> 00:58:05,599
to write all this boilerplate to support

00:58:03,839 --> 00:58:07,440
all these platforms

00:58:05,599 --> 00:58:08,720
luckily i'm not alone in this and other

00:58:07,440 --> 00:58:11,200
people just

00:58:08,720 --> 00:58:13,680
do stuff faster than i do and there is

00:58:11,200 --> 00:58:15,920
now a project called uni ffi

00:58:13,680 --> 00:58:17,520
that can create this boilerplate

00:58:15,920 --> 00:58:19,920
essentially you can use

00:58:17,520 --> 00:58:21,200
idl files that's interface definition

00:58:19,920 --> 00:58:23,280
language files

00:58:21,200 --> 00:58:24,559
where you describe your interface what

00:58:23,280 --> 00:58:27,520
it should look like

00:58:24,559 --> 00:58:29,280
and uni ffi will be able to take this

00:58:27,520 --> 00:58:30,240
generate the rust part so you can

00:58:29,280 --> 00:58:32,640
implement it

00:58:30,240 --> 00:58:33,839
generate the ffi part so it can get

00:58:32,640 --> 00:58:36,720
called

00:58:33,839 --> 00:58:38,400
and also generate the kotlin part so you

00:58:36,720 --> 00:58:40,880
actually have the integration into the

00:58:38,400 --> 00:58:40,880
platform

00:58:41,200 --> 00:58:44,960
it's not there yet but this is something

00:58:44,079 --> 00:58:47,920
i definitely

00:58:44,960 --> 00:58:50,480
want to help out developing in the next

00:58:47,920 --> 00:58:52,000
few months

00:58:50,480 --> 00:58:54,319
and then i talked about it a couple of

00:58:52,000 --> 00:58:55,839
times we're bringing glean back into

00:58:54,319 --> 00:58:59,200
firefox and desktop

00:58:55,839 --> 00:59:01,520
we call this project fog we're currently

00:58:59,200 --> 00:59:02,559
implementing and designing the apis we

00:59:01,520 --> 00:59:04,799
want to see there

00:59:02,559 --> 00:59:07,040
like c plus plus javascript and also the

00:59:04,799 --> 00:59:09,440
rest api will be used there

00:59:07,040 --> 00:59:10,559
and that's very exciting and we hope to

00:59:09,440 --> 00:59:12,799
get this

00:59:10,559 --> 00:59:15,920
into nightly and actually working in the

00:59:12,799 --> 00:59:15,920
next few months as well

00:59:16,319 --> 00:59:19,920
one thing more that i wanted to achieve

00:59:18,160 --> 00:59:22,160
with this talk is

00:59:19,920 --> 00:59:23,440
for one putting out this knowledge we're

00:59:22,160 --> 00:59:25,280
doing this we're building

00:59:23,440 --> 00:59:28,000
cross-platform libraries targeting

00:59:25,280 --> 00:59:29,920
mobile but i also want to reach out and

00:59:28,000 --> 00:59:32,480
see who else is doing this

00:59:29,920 --> 00:59:34,799
the documentation around all of this is

00:59:32,480 --> 00:59:37,760
a little bit sparse

00:59:34,799 --> 00:59:38,960
so i'd like to see this getting talked

00:59:37,760 --> 00:59:41,280
about more

00:59:38,960 --> 00:59:42,559
more tools being developed for it more

00:59:41,280 --> 00:59:46,000
documentation written

00:59:42,559 --> 00:59:48,000
around all of this and as one last

00:59:46,000 --> 00:59:49,920
thing because i find this highly

00:59:48,000 --> 00:59:51,520
interesting and just to plant the seed

00:59:49,920 --> 00:59:53,680
in your head

00:59:51,520 --> 00:59:54,880
some of these platforms do have ways to

00:59:53,680 --> 00:59:58,000
do async programming

00:59:54,880 --> 00:59:58,720
and now rust has async programming is

00:59:58,000 --> 01:00:01,200
there a way

00:59:58,720 --> 01:00:02,559
we can combine those two things and do

01:00:01,200 --> 01:00:06,720
async rust programming

01:00:02,559 --> 01:00:09,599
but running it on the platform side

01:00:06,720 --> 01:00:12,160
now thanks to my team at mozilla alessio

01:00:09,599 --> 01:00:14,799
bear travis mike and also gerk

01:00:12,160 --> 01:00:15,599
who are working with me on this project

01:00:14,799 --> 01:00:18,160
and also the

01:00:15,599 --> 01:00:19,760
application services team that's paved

01:00:18,160 --> 01:00:22,559
the way in a lot of

01:00:19,760 --> 01:00:23,599
places for us and who are still in

01:00:22,559 --> 01:00:27,119
contact with us

01:00:23,599 --> 01:00:30,319
to further develop these ideas

01:00:27,119 --> 01:00:31,200
you find uh the slides online you find

01:00:30,319 --> 01:00:34,400
all of the clean

01:00:31,200 --> 01:00:36,640
gleam code base in the mozilla

01:00:34,400 --> 01:00:37,760
clean repository in github as well as

01:00:36,640 --> 01:00:40,000
our docs

01:00:37,760 --> 01:00:40,799
and you can read about gleam and how we

01:00:40,000 --> 01:00:44,079
develop it

01:00:40,799 --> 01:00:49,040
on our blog you find me on twitter

01:00:44,079 --> 01:00:49,040
and now i have time for questions thank

01:00:54,839 --> 01:00:57,839
you

01:01:00,559 --> 01:01:07,760
all right i'm getting some questions in

01:01:03,839 --> 01:01:10,240
um the first is from dowie on twitch

01:01:07,760 --> 01:01:12,640
how little kotlin or java must run right

01:01:10,240 --> 01:01:15,200
so as to maximize use of rust in mobile

01:01:12,640 --> 01:01:15,200
development

01:01:15,680 --> 01:01:24,079
so that's a bit hard for

01:01:18,960 --> 01:01:26,319
for me to describe precisely because

01:01:24,079 --> 01:01:27,599
a few things that i left out is that our

01:01:26,319 --> 01:01:29,680
first implementation was

01:01:27,599 --> 01:01:31,440
actually in kotlin and we slowly

01:01:29,680 --> 01:01:34,400
migrated parts of it

01:01:31,440 --> 01:01:35,760
to the rest side and using the rust

01:01:34,400 --> 01:01:38,480
implementation

01:01:35,760 --> 01:01:38,880
so we already had a lot of kotlin that

01:01:38,480 --> 01:01:41,760
we

01:01:38,880 --> 01:01:41,760
just migrated

01:01:42,160 --> 01:01:49,359
i'd say you also need to look at

01:01:47,119 --> 01:01:50,880
how much you actually depend on using

01:01:49,359 --> 01:01:53,200
rust

01:01:50,880 --> 01:01:54,559
for us it was clear that we need to

01:01:53,200 --> 01:01:57,200
share this implementation

01:01:54,559 --> 01:01:59,359
and that we can put a lot of logic into

01:01:57,200 --> 01:02:01,920
this rust implementation

01:01:59,359 --> 01:02:03,520
whereas the kotlin parts are pretty much

01:02:01,920 --> 01:02:05,039
stateless

01:02:03,520 --> 01:02:06,640
and i think that's where it shines

01:02:05,039 --> 01:02:10,880
really well

01:02:06,640 --> 01:02:13,039
if you know that you need to

01:02:10,880 --> 01:02:16,480
do a lot interaction between those two

01:02:13,039 --> 01:02:18,559
sites it might not be optimal anymore

01:02:16,480 --> 01:02:19,760
so how little or how much you need to

01:02:18,559 --> 01:02:22,319
write

01:02:19,760 --> 01:02:22,319
hard to say

01:02:23,200 --> 01:02:28,720
next also from twitch from raritly is

01:02:26,480 --> 01:02:32,319
kotlin native multi-platform at all

01:02:28,720 --> 01:02:35,520
useful in interacting with ffi

01:02:32,319 --> 01:02:38,880
i don't know i have not looked at

01:02:35,520 --> 01:02:40,960
kotlin native um so kotlin native is

01:02:38,880 --> 01:02:42,640
a way of compiling kotlin to actually

01:02:40,960 --> 01:02:45,760
native code and not to jv

01:02:42,640 --> 01:02:47,920
and bytecode i have not looked at this

01:02:45,760 --> 01:02:48,960
so i don't know how it interacts with

01:02:47,920 --> 01:02:52,160
ffi

01:02:48,960 --> 01:02:52,799
what i do know is that it would not have

01:02:52,160 --> 01:02:55,920
been

01:02:52,799 --> 01:02:58,160
a possibility to just use kotlin and get

01:02:55,920 --> 01:03:00,319
that back into the firefox desktop code

01:02:58,160 --> 01:03:01,920
base because that would have been yet

01:03:00,319 --> 01:03:02,640
another language that we would need to

01:03:01,920 --> 01:03:04,880
support

01:03:02,640 --> 01:03:08,079
and that would not have flown with the

01:03:04,880 --> 01:03:08,079
firefox development team

01:03:09,680 --> 01:03:16,319
another question from twitch dowie again

01:03:14,240 --> 01:03:18,400
to what extent have you needed to put

01:03:16,319 --> 01:03:19,119
deliberate effort for mobile ffi

01:03:18,400 --> 01:03:21,440
development

01:03:19,119 --> 01:03:23,200
into keeping rust objects alive for

01:03:21,440 --> 01:03:25,359
longer than rust would typically keep

01:03:23,200 --> 01:03:29,760
them alive

01:03:25,359 --> 01:03:31,280
so there's two parts where we need to do

01:03:29,760 --> 01:03:34,480
this

01:03:31,280 --> 01:03:37,680
we essentially glean is

01:03:34,480 --> 01:03:41,039
a global singleton so

01:03:37,680 --> 01:03:44,640
we simply put that in a global static

01:03:41,039 --> 01:03:48,079
that's behind a lock to be kept alive so

01:03:44,640 --> 01:03:50,160
it essentially lives for forever um

01:03:48,079 --> 01:03:51,680
that would have been the case if we not

01:03:50,160 --> 01:03:53,039
done any ffi either

01:03:51,680 --> 01:03:56,400
it's just that we need this global

01:03:53,039 --> 01:03:58,559
singleton to get to the api we want to

01:03:56,400 --> 01:03:59,760
the other thing where we need to ensure

01:03:58,559 --> 01:04:02,799
things live

01:03:59,760 --> 01:04:04,960
are those metric types that we

01:04:02,799 --> 01:04:06,480
create on the kotlin site through the

01:04:04,960 --> 01:04:09,200
ffi

01:04:06,480 --> 01:04:11,520
but there we essentially rely on these

01:04:09,200 --> 01:04:14,079
on this concurrent handle map

01:04:11,520 --> 01:04:15,520
from ffi support i'm sorry the

01:04:14,079 --> 01:04:18,799
concurrent handle map

01:04:15,520 --> 01:04:20,960
and that's also just a global static

01:04:18,799 --> 01:04:24,079
where it puts in the data which ensures

01:04:20,960 --> 01:04:26,559
it lifts until we delete it again

01:04:24,079 --> 01:04:27,839
the place where we need to do some

01:04:26,559 --> 01:04:30,960
effort and again that's

01:04:27,839 --> 01:04:33,760
wrapped around nice types for us is

01:04:30,960 --> 01:04:35,520
returning streaks if you return strings

01:04:33,760 --> 01:04:36,480
you need to make sure that you allocate

01:04:35,520 --> 01:04:38,720
the data

01:04:36,480 --> 01:04:40,000
then forget about it but return the

01:04:38,720 --> 01:04:42,960
pointer so kotlin can

01:04:40,000 --> 01:04:44,000
read it and that's the one place we need

01:04:42,960 --> 01:04:45,520
to do this

01:04:44,000 --> 01:04:47,520
if you're not using concurrent handle

01:04:45,520 --> 01:04:50,400
map you would need to do this for all

01:04:47,520 --> 01:04:50,400
your other objects

01:04:53,119 --> 01:04:57,520
um follow-up question from dowie on

01:04:55,200 --> 01:04:59,760
twitch again would it be more performant

01:04:57,520 --> 01:05:00,559
to use bytes rather than a string for

01:04:59,760 --> 01:05:03,280
exchanging

01:05:00,559 --> 01:05:04,799
json serialized data yes it would

01:05:03,280 --> 01:05:08,160
because we can just

01:05:04,799 --> 01:05:12,720
um we we wouldn't need to do the

01:05:08,160 --> 01:05:13,680
udf8 check um then again json is utf-8

01:05:12,720 --> 01:05:16,000
data so

01:05:13,680 --> 01:05:18,319
at some point this this would still come

01:05:16,000 --> 01:05:22,079
up we could

01:05:18,319 --> 01:05:24,079
uh use one less check there but again

01:05:22,079 --> 01:05:26,319
we don't care about the performance

01:05:24,079 --> 01:05:27,119
there much it's only returned from test

01:05:26,319 --> 01:05:30,799
functions

01:05:27,119 --> 01:05:30,799
so it will never land in the application

01:05:33,359 --> 01:05:38,559
ariane on twitch asks where does rust

01:05:36,720 --> 01:05:40,240
shine more than any other language in

01:05:38,559 --> 01:05:42,079
the industry

01:05:40,240 --> 01:05:43,599
oh that that puts me in a corner i need

01:05:42,079 --> 01:05:47,440
to be very careful here

01:05:43,599 --> 01:05:50,880
um where it really shines for us is

01:05:47,440 --> 01:05:55,280
simply all the safety it brings us

01:05:50,880 --> 01:05:59,119
um the fact that we can simply rely

01:05:55,280 --> 01:06:01,440
on on being multi-threaded by default

01:05:59,119 --> 01:06:03,440
we we don't need to take specific care

01:06:01,440 --> 01:06:04,000
of that it just works and the compiler

01:06:03,440 --> 01:06:06,160
will stop

01:06:04,000 --> 01:06:08,400
us if it doesn't i think that's one of

01:06:06,160 --> 01:06:10,880
the major places where it shines

01:06:08,400 --> 01:06:13,359
especially in this context we can't

01:06:10,880 --> 01:06:15,119
fully control the kotlin or swift or

01:06:13,359 --> 01:06:16,400
python site and that might be

01:06:15,119 --> 01:06:18,319
multi-threaded

01:06:16,400 --> 01:06:20,720
what we need to ensure that the

01:06:18,319 --> 01:06:24,480
internals in our rust crate

01:06:20,720 --> 01:06:26,640
are thread safe and the other thing is

01:06:24,480 --> 01:06:30,000
the tooling

01:06:26,640 --> 01:06:32,000
cargo is just absolutely amazing and

01:06:30,000 --> 01:06:34,000
for us it was very easy to integrate

01:06:32,000 --> 01:06:36,000
that well not very easy it was

01:06:34,000 --> 01:06:38,240
considerably easy to integrate that into

01:06:36,000 --> 01:06:41,359
the other build sims as we needed it

01:06:38,240 --> 01:06:43,440
and other tooling is just

01:06:41,359 --> 01:06:46,559
excellent as well in cargo and this is

01:06:43,440 --> 01:06:48,079
where i want to see uniffi going uni ffi

01:06:46,559 --> 01:06:50,160
should be one of those tools that you

01:06:48,079 --> 01:06:52,000
can just use and it just works

01:06:50,160 --> 01:06:54,880
and that's where rust is really

01:06:52,000 --> 01:06:54,880
excellent already

01:06:55,760 --> 01:07:00,400
a comment on youtube from jeff

01:06:58,880 --> 01:07:03,520
do you think it would be possible for

01:07:00,400 --> 01:07:06,400
glean to be extended or built upon work

01:07:03,520 --> 01:07:08,319
upon to work with distributed tracing

01:07:06,400 --> 01:07:11,599
seems like having a similar portable

01:07:08,319 --> 01:07:15,920
interface like this would be great

01:07:11,599 --> 01:07:18,559
um i haven't yet looked at tracing

01:07:15,920 --> 01:07:19,839
too close i think you're asking about

01:07:18,559 --> 01:07:23,200
the tracing crate i

01:07:19,839 --> 01:07:25,200
assume um a very new popular crate in

01:07:23,200 --> 01:07:28,400
the rust ecosystem

01:07:25,200 --> 01:07:30,079
our what i can say though is that our

01:07:28,400 --> 01:07:33,200
telemetry

01:07:30,079 --> 01:07:34,880
is slightly different from what tracing

01:07:33,200 --> 01:07:40,160
currently provides

01:07:34,880 --> 01:07:40,160
um we're not so much tracing

01:07:40,240 --> 01:07:46,880
across code blocks but we're more

01:07:43,520 --> 01:07:49,359
gathering single points of data

01:07:46,880 --> 01:07:51,599
collected this in my examples in this

01:07:49,359 --> 01:07:54,319
talk it was mostly counters but what's

01:07:51,599 --> 01:07:56,240
much more used is distributions of time

01:07:54,319 --> 01:07:58,240
distributions of memory

01:07:56,240 --> 01:07:59,920
sometimes it's list of strings or

01:07:58,240 --> 01:08:03,520
similar things

01:07:59,920 --> 01:08:05,920
i don't think tracing has apis

01:08:03,520 --> 01:08:07,920
uh similar to that and implementation

01:08:05,920 --> 01:08:11,839
wise i haven't looked at it at all so

01:08:07,920 --> 01:08:11,839
i can't speak about that

01:08:12,720 --> 01:08:16,960
one more question from ariane on on

01:08:15,599 --> 01:08:20,000
twitch

01:08:16,960 --> 01:08:22,000
python for simplicity and data science c

01:08:20,000 --> 01:08:23,759
for faster computation and low level

01:08:22,000 --> 01:08:25,759
stuff and javascript for

01:08:23,759 --> 01:08:27,920
rep so where do you think rust is an

01:08:25,759 --> 01:08:30,960
epic winner

01:08:27,920 --> 01:08:34,080
um actually in all of these

01:08:30,960 --> 01:08:36,839
as shown we are using rust and interact

01:08:34,080 --> 01:08:38,880
with all these languages

01:08:36,839 --> 01:08:42,880
i write c plus plus

01:08:38,880 --> 01:08:45,440
still as uh as my main job requires that

01:08:42,880 --> 01:08:46,880
i still write javascript because firefox

01:08:45,440 --> 01:08:48,640
is also written in javascript

01:08:46,880 --> 01:08:51,120
and i do write javascript for the web

01:08:48,640 --> 01:08:53,279
sometimes as well

01:08:51,120 --> 01:08:55,199
and i'm interact with python a lot not

01:08:53,279 --> 01:08:56,319
only because half our build system now

01:08:55,199 --> 01:08:58,400
uses that

01:08:56,319 --> 01:08:59,679
but also as you said it's used in data

01:08:58,400 --> 01:09:03,040
science a lot

01:08:59,679 --> 01:09:05,199
and i think rust

01:09:03,040 --> 01:09:07,279
positions itself very well to be the

01:09:05,199 --> 01:09:10,400
language behind the scenes

01:09:07,279 --> 01:09:12,000
it can be used to implement all these

01:09:10,400 --> 01:09:14,080
things that needs to be fast in the

01:09:12,000 --> 01:09:18,799
background and the other languages

01:09:14,080 --> 01:09:21,199
can provide the nice user api

01:09:18,799 --> 01:09:22,319
while cpr plus is the one case where

01:09:21,199 --> 01:09:24,480
they

01:09:22,319 --> 01:09:25,520
basically compare speedwise but the

01:09:24,480 --> 01:09:28,319
other languages

01:09:25,520 --> 01:09:29,359
not necessarily so i think this being

01:09:28,319 --> 01:09:31,759
the language

01:09:29,359 --> 01:09:33,759
behind the scenes essentially being the

01:09:31,759 --> 01:09:34,880
systems programming language behind all

01:09:33,759 --> 01:09:38,480
these things

01:09:34,880 --> 01:09:38,480
that's where rust fits right in

01:09:42,319 --> 01:09:47,520
so that's about the questions i have at

01:09:46,400 --> 01:09:49,679
the moment

01:09:47,520 --> 01:09:50,960
might give you all a couple more minutes

01:09:49,679 --> 01:10:03,840
to

01:09:50,960 --> 01:10:03,840
ask me anything

01:10:14,840 --> 01:10:17,840
um

01:10:20,880 --> 01:10:25,600
all right there's one more question from

01:10:22,880 --> 01:10:25,600
scripted fate

01:10:26,640 --> 01:10:30,159
um that's that's more of a comment but

01:10:28,719 --> 01:10:32,719
i'm still going to read it because

01:10:30,159 --> 01:10:33,520
it's essentially one of the answers to

01:10:32,719 --> 01:10:37,040
the earliest

01:10:33,520 --> 01:10:38,960
questions um there there's a work on

01:10:37,040 --> 01:10:42,080
open tracing

01:10:38,960 --> 01:10:43,679
um and yeah

01:10:42,080 --> 01:10:45,440
for context crypto fader is one of my

01:10:43,679 --> 01:10:46,960
colleagues um

01:10:45,440 --> 01:10:49,120
it's not unreasonable to think of an

01:10:46,960 --> 01:10:51,040
evolution in that direction but for now

01:10:49,120 --> 01:10:52,480
glean is focused on higher level metrics

01:10:51,040 --> 01:10:55,440
not traces

01:10:52,480 --> 01:10:57,440
yeah so this essentially sums it up um

01:10:55,440 --> 01:10:59,840
currently we're focusing a lot of

01:10:57,440 --> 01:11:00,640
on the higher level metrics so i use

01:10:59,840 --> 01:11:03,600
counter

01:11:00,640 --> 01:11:05,920
because that's the easiest but we try to

01:11:03,600 --> 01:11:09,199
come up with the metrics in a way that

01:11:05,920 --> 01:11:12,000
the metric itself has semantic meaning

01:11:09,199 --> 01:11:12,480
for what it wants to collect as i said

01:11:12,000 --> 01:11:14,640
before

01:11:12,480 --> 01:11:16,880
we have these distributions but our

01:11:14,640 --> 01:11:19,040
distributions are specific to either be

01:11:16,880 --> 01:11:20,640
timing distributions which mean they

01:11:19,040 --> 01:11:23,520
measure a time span

01:11:20,640 --> 01:11:24,159
or memory distributions which mean they

01:11:23,520 --> 01:11:25,920
measure

01:11:24,159 --> 01:11:29,040
some form of memory that could be a

01:11:25,920 --> 01:11:32,640
location that could be disk space used

01:11:29,040 --> 01:11:34,560
or memory used for the javascript engine

01:11:32,640 --> 01:11:37,280
or resource like that

01:11:34,560 --> 01:11:38,719
we're also getting new types to measure

01:11:37,280 --> 01:11:41,120
rates

01:11:38,719 --> 01:11:42,080
that is that is useful where we need to

01:11:41,120 --> 01:11:44,480
compare

01:11:42,080 --> 01:11:46,159
certain things that happen on a website

01:11:44,480 --> 01:11:48,880
um where we know that

01:11:46,159 --> 01:11:50,800
um whether something is available and

01:11:48,880 --> 01:11:53,679
whether something is actually used

01:11:50,800 --> 01:11:54,000
and we have a whole process to build out

01:11:53,679 --> 01:11:56,400
these

01:11:54,000 --> 01:11:56,400
types

01:11:58,480 --> 01:12:02,400
another question from twitch and dowie

01:12:00,000 --> 01:12:04,800
and that's that's a pretty good one

01:12:02,400 --> 01:12:09,199
why do we use kotlin for the network

01:12:04,800 --> 01:12:12,719
communication rather than rust

01:12:09,199 --> 01:12:13,600
the reason is that so there are multiple

01:12:12,719 --> 01:12:17,120
reasons actually

01:12:13,600 --> 01:12:18,159
so in firefox for android the android

01:12:17,120 --> 01:12:20,000
browser we're building

01:12:18,159 --> 01:12:21,760
we're actually using gecko that's the

01:12:20,000 --> 01:12:22,880
same engine that's used in firefox

01:12:21,760 --> 01:12:25,120
desktop

01:12:22,880 --> 01:12:26,400
and that engine brings its own http

01:12:25,120 --> 01:12:28,159
stack

01:12:26,400 --> 01:12:30,560
that's the whole implementation of the

01:12:28,159 --> 01:12:33,840
network communication is done

01:12:30,560 --> 01:12:36,159
and on android we actually want to use

01:12:33,840 --> 01:12:38,239
this implementation of the network stack

01:12:36,159 --> 01:12:39,679
so we need to pass it back up through

01:12:38,239 --> 01:12:42,159
kotlin

01:12:39,679 --> 01:12:42,719
and then the fun fact in firefox for

01:12:42,159 --> 01:12:44,880
android

01:12:42,719 --> 01:12:46,159
the data actually gets passed back into

01:12:44,880 --> 01:12:48,400
gecko which is the c

01:12:46,159 --> 01:12:51,360
plus implementation that then does the

01:12:48,400 --> 01:12:53,600
network communication for us

01:12:51,360 --> 01:12:55,199
we can implement this in rust as well

01:12:53,600 --> 01:12:55,760
but again on firefox standard we

01:12:55,199 --> 01:12:58,960
wouldn't

01:12:55,760 --> 01:13:02,159
we could do this on other platforms

01:12:58,960 --> 01:13:04,640
but we still want to leverage

01:13:02,159 --> 01:13:05,760
simply the existing network stacks that

01:13:04,640 --> 01:13:08,159
are there

01:13:05,760 --> 01:13:09,920
android has a network stack and that's

01:13:08,159 --> 01:13:11,679
deeply integrated with the system

01:13:09,920 --> 01:13:13,840
which also allows you to schedule

01:13:11,679 --> 01:13:16,320
uploads the same on swift

01:13:13,840 --> 01:13:18,000
you can schedule uploads and the system

01:13:16,320 --> 01:13:20,320
actually does it for you without

01:13:18,000 --> 01:13:22,080
you needing to control everything that

01:13:20,320 --> 01:13:23,520
actually also allows for upload in the

01:13:22,080 --> 01:13:25,679
background

01:13:23,520 --> 01:13:28,080
and it's the same on other platforms we

01:13:25,679 --> 01:13:29,679
can't necessarily rely on a new

01:13:28,080 --> 01:13:31,280
network implement network stack

01:13:29,679 --> 01:13:33,360
implementation in rust

01:13:31,280 --> 01:13:36,239
because the system might use something

01:13:33,360 --> 01:13:36,239
different to begin with

01:13:38,800 --> 01:13:43,520
flucky on twitch asks do you see glean

01:13:41,280 --> 01:13:45,360
having use cases in other products

01:13:43,520 --> 01:13:47,600
are there any others who are using it or

01:13:45,360 --> 01:13:49,520
looking into using it

01:13:47,600 --> 01:13:50,640
is there a plan to make it friendlier

01:13:49,520 --> 01:13:54,080
for others and drive

01:13:50,640 --> 01:13:57,520
outside adoption um

01:13:54,080 --> 01:14:00,080
to all of this i can answer yes

01:13:57,520 --> 01:14:02,719
glean was developed at mozilla with the

01:14:00,080 --> 01:14:05,440
specific needs that we have

01:14:02,719 --> 01:14:07,199
but we developed it in a way that's the

01:14:05,440 --> 01:14:11,280
implementation

01:14:07,199 --> 01:14:14,400
can essentially talk with any pipeline

01:14:11,280 --> 01:14:16,719
that adheres to the same things um

01:14:14,400 --> 01:14:17,600
if you watch our if you uh keep an eye

01:14:16,719 --> 01:14:19,600
on our blog

01:14:17,600 --> 01:14:21,440
there will soon be a blog post about how

01:14:19,600 --> 01:14:22,560
you can use glean and not use the

01:14:21,440 --> 01:14:25,199
mozilla pipeline

01:14:22,560 --> 01:14:27,280
to get to the data so that's actually

01:14:25,199 --> 01:14:27,679
one of the things we want to do we want

01:14:27,280 --> 01:14:30,320
to

01:14:27,679 --> 01:14:32,000
turn glean into something that others

01:14:30,320 --> 01:14:34,560
could use as well

01:14:32,000 --> 01:14:35,120
to profit from the same things we are

01:14:34,560 --> 01:14:38,080
already

01:14:35,120 --> 01:14:38,080
putting into glee

01:14:40,880 --> 01:14:46,400
um another common

01:14:44,000 --> 01:14:48,159
question from jeff on youtube do you

01:14:46,400 --> 01:14:49,679
have a favorite rust crate for working

01:14:48,159 --> 01:14:52,719
with eros

01:14:49,679 --> 01:14:56,159
um i do not um i hear

01:14:52,719 --> 01:14:59,840
this error is pretty good um i

01:14:56,159 --> 01:15:02,480
actually ripped out all usage of failure

01:14:59,840 --> 01:15:04,480
in our code base and part of our

01:15:02,480 --> 01:15:06,640
dependency tree

01:15:04,480 --> 01:15:07,520
because the overhead it introduced was

01:15:06,640 --> 01:15:09,760
bigger than just

01:15:07,520 --> 01:15:12,560
implementing the enums ourselves and

01:15:09,760 --> 01:15:15,600
then implementing error

01:15:12,560 --> 01:15:16,800
the reason we don't really depend on any

01:15:15,600 --> 01:15:20,239
error crate for this

01:15:16,800 --> 01:15:22,880
is the apis we provide actually don't

01:15:20,239 --> 01:15:26,000
report errors

01:15:22,880 --> 01:15:29,120
we went to great length to ensure that

01:15:26,000 --> 01:15:31,679
under um correct use and like

01:15:29,120 --> 01:15:32,320
most of it is guaranteed by rust um you

01:15:31,679 --> 01:15:35,840
can't run

01:15:32,320 --> 01:15:38,400
into errors the errors you can run into

01:15:35,840 --> 01:15:40,159
are all handed internally if we can't

01:15:38,400 --> 01:15:40,960
write to the database for whatever

01:15:40,159 --> 01:15:42,640
reason

01:15:40,960 --> 01:15:44,480
we still don't want to crash any

01:15:42,640 --> 01:15:46,800
application that we're integrating with

01:15:44,480 --> 01:15:48,400
if you can't write to the database then

01:15:46,800 --> 01:15:53,120
so be it

01:15:48,400 --> 01:15:55,760
the application still runs if however we

01:15:53,120 --> 01:15:57,280
we try to write into a metric type and

01:15:55,760 --> 01:15:59,360
some of the types don't match

01:15:57,280 --> 01:16:00,400
or some integer overflows or something

01:15:59,360 --> 01:16:03,280
like that

01:16:00,400 --> 01:16:04,080
we actually use our own system to report

01:16:03,280 --> 01:16:06,400
these errors

01:16:04,080 --> 01:16:07,840
so we see them in the data so if

01:16:06,400 --> 01:16:09,760
anything is

01:16:07,840 --> 01:16:11,440
is wrong with the data we're trying to

01:16:09,760 --> 01:16:14,800
record we record an

01:16:11,440 --> 01:16:18,080
error in our own data and then we see it

01:16:14,800 --> 01:16:20,320
so we're never exposing any errors

01:16:18,080 --> 01:16:24,320
from the ros code over the ffi so we

01:16:20,320 --> 01:16:24,320
don't need such a crate at the moment

01:16:26,000 --> 01:16:34,480
i got one okay on twitch asks

01:16:30,239 --> 01:16:36,480
what do you not like about rust um

01:16:34,480 --> 01:16:38,239
i've been doing rust for so long there

01:16:36,480 --> 01:16:42,719
are certainly things

01:16:38,239 --> 01:16:44,400
uh that are not perfect um

01:16:42,719 --> 01:16:48,080
all in all it's still more variable than

01:16:44,400 --> 01:16:49,840
other languages that i'm working with

01:16:48,080 --> 01:16:53,199
one thing and for all the greatness that

01:16:49,840 --> 01:16:55,840
cargo is it cost me quite some headache

01:16:53,199 --> 01:16:56,800
because of some things it does

01:16:55,840 --> 01:17:00,960
essentially

01:16:56,800 --> 01:17:03,679
the way features are handled um

01:17:00,960 --> 01:17:05,440
still has a lot of problems and that

01:17:03,679 --> 01:17:07,679
didn't really cause problems

01:17:05,440 --> 01:17:08,560
directly for glean but integrating lean

01:17:07,679 --> 01:17:11,360
into a project

01:17:08,560 --> 01:17:11,920
as large as firefox causes problems

01:17:11,360 --> 01:17:15,120
because

01:17:11,920 --> 01:17:16,000
of the way cargo uses features luckily

01:17:15,120 --> 01:17:18,159
for me

01:17:16,000 --> 01:17:20,080
this is actually fixed and hopefully

01:17:18,159 --> 01:17:21,600
getting stabilized with the next cargo

01:17:20,080 --> 01:17:24,239
release

01:17:21,600 --> 01:17:24,880
so one of the pet peeves i have with

01:17:24,239 --> 01:17:30,800
cargo

01:17:24,880 --> 01:17:33,760
is gonna get fixed

01:17:30,800 --> 01:17:34,239
x akash on twitch asks do you also plan

01:17:33,760 --> 01:17:37,679
to

01:17:34,239 --> 01:17:41,239
build two wasn't for to js

01:17:37,679 --> 01:17:43,840
so two web assembly to use it in

01:17:41,239 --> 01:17:46,880
javascript

01:17:43,840 --> 01:17:47,280
this ideas this idea flows around in our

01:17:46,880 --> 01:17:50,719
team

01:17:47,280 --> 01:17:54,719
quite often to

01:17:50,719 --> 01:17:59,040
which my standard answer is why

01:17:54,719 --> 01:18:01,840
um the way glean is currently designed

01:17:59,040 --> 01:18:03,760
it works for big applications that are

01:18:01,840 --> 01:18:06,719
running for a long time that can

01:18:03,760 --> 01:18:08,640
send data in the background and collect

01:18:06,719 --> 01:18:10,400
metrics over time

01:18:08,640 --> 01:18:12,239
that's the current design of glean and

01:18:10,400 --> 01:18:14,719
that works for

01:18:12,239 --> 01:18:15,679
browser type applications quite well be

01:18:14,719 --> 01:18:19,520
that on mobile or

01:18:15,679 --> 01:18:20,640
desktop the javascript api inside

01:18:19,520 --> 01:18:23,840
firefox

01:18:20,640 --> 01:18:26,800
has a lot of direct integration with

01:18:23,840 --> 01:18:30,000
c and c plus and rust part of firefox so

01:18:26,800 --> 01:18:31,520
we can't use webassembly there

01:18:30,000 --> 01:18:33,679
because we still need to call into the

01:18:31,520 --> 01:18:37,520
native code anyway

01:18:33,679 --> 01:18:40,239
for websites i still can see

01:18:37,520 --> 01:18:41,679
some form of glean being used but i

01:18:40,239 --> 01:18:44,159
don't see

01:18:41,679 --> 01:18:45,280
the current glean design working out for

01:18:44,159 --> 01:18:48,480
a website because

01:18:45,280 --> 01:18:51,760
in a website even in a

01:18:48,480 --> 01:18:54,159
single page application you

01:18:51,760 --> 01:18:55,120
have this you don't have this long

01:18:54,159 --> 01:18:57,600
running thing

01:18:55,120 --> 01:18:59,920
you at potentially any time this tab

01:18:57,600 --> 01:19:02,159
your website could just reload

01:18:59,920 --> 01:19:03,120
you don't have any real persistent

01:19:02,159 --> 01:19:07,199
storage

01:19:03,120 --> 01:19:09,440
so you can't store that forever offline

01:19:07,199 --> 01:19:10,480
but you need constant communication with

01:19:09,440 --> 01:19:13,679
the server

01:19:10,480 --> 01:19:16,480
the way we bundle up metrics into pings

01:19:13,679 --> 01:19:18,159
also doesn't lend itself very good for a

01:19:16,480 --> 01:19:21,679
website on a website

01:19:18,159 --> 01:19:22,000
if you need some statistics or metrics

01:19:21,679 --> 01:19:24,880
about

01:19:22,000 --> 01:19:25,760
your data you probably want to send them

01:19:24,880 --> 01:19:28,320
out quickly

01:19:25,760 --> 01:19:29,040
so you send out small packets and you

01:19:28,320 --> 01:19:31,920
send them off

01:19:29,040 --> 01:19:32,800
before the user leaves the website again

01:19:31,920 --> 01:19:34,840
so

01:19:32,800 --> 01:19:36,159
i don't see the need to compile to

01:19:34,840 --> 01:19:37,679
webassembly

01:19:36,159 --> 01:19:39,360
it could just be compelled to

01:19:37,679 --> 01:19:42,560
webassembly

01:19:39,360 --> 01:19:44,800
i assume and it could run in some of the

01:19:42,560 --> 01:19:47,760
web assembly interpreters

01:19:44,800 --> 01:19:51,840
because the core crate is just rust and

01:19:47,760 --> 01:19:51,840
a little bit of c

01:19:55,040 --> 01:19:59,679
all right so thank you for all the

01:19:58,480 --> 01:20:00,960
questions

01:19:59,679 --> 01:20:03,360
there were some really good ones in

01:20:00,960 --> 01:20:05,040
there and

01:20:03,360 --> 01:20:07,360
now i'm actually tasked with selecting

01:20:05,040 --> 01:20:10,719
one of these as

01:20:07,360 --> 01:20:10,719
a good one um

01:20:11,360 --> 01:20:19,840
let's see uh

01:20:24,320 --> 01:20:28,080
so i think the one of the interesting

01:20:27,199 --> 01:20:31,840
questions here

01:20:28,080 --> 01:20:35,679
um was from from dowie on twitch

01:20:31,840 --> 01:20:38,639
about um what was the effort to

01:20:35,679 --> 01:20:40,639
ensure rust objects live longer than

01:20:38,639 --> 01:20:43,520
rust usually would do

01:20:40,639 --> 01:20:44,239
i answer that we we don't need to do

01:20:43,520 --> 01:20:47,120
much for that

01:20:44,239 --> 01:20:49,120
we rely on our other tooling to do that

01:20:47,120 --> 01:20:49,760
but there are ways and rust to do this

01:20:49,120 --> 01:20:51,679
on your own

01:20:49,760 --> 01:20:52,800
by just allocating stuff and then

01:20:51,679 --> 01:20:54,880
forgetting about it

01:20:52,800 --> 01:20:58,480
and returning pointers so that was

01:20:54,880 --> 01:20:58,480
definitely one of the good questions

01:20:58,960 --> 01:21:04,000
uh thanks again everyone for watching it

01:21:01,199 --> 01:21:04,000
was a lot of fun

01:21:07,239 --> 01:21:10,239

YouTube URL: https://www.youtube.com/watch?v=j5rczOF7pzg


