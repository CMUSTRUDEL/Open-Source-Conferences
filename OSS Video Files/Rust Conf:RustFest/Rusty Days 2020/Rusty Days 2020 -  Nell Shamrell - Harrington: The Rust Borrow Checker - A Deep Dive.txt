Title: Rusty Days 2020 -  Nell Shamrell - Harrington: The Rust Borrow Checker - A Deep Dive
Publication date: 2020-08-02
Playlist: Rusty Days 2020
Description: 
	Agenda ► https://rusty-days.org/agenda
Slides ►https://rusty-days.org/assets/slides/05-the-rust-borrow-checker.pdf
Playlist with all talks ► https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ

Follow ►
Facebook: https://rusty-days.org/facebook
Twitch: https://rusty-days.org/twitch
Twitter: https://rusty-days.org/twitter

This video ►

The Rust compiler's borrow checker is critical for ensuring safe Rust code. Even more critical, however, is how the borrow checker provides useful, automated guidance on how to write safe code when the check fails. 

Early in your Rust journey, it may feel like you are fighting the borrow checker. Come to this talk to learn how you can transition from fighting the borrow checker to using its guidance to write safer and more powerful code at any experience level. Walk away not only understanding the what and the how of the borrow checker - but why it works the way it does - and why it is so critical to both the technical functionality and philosophy of Rust.
Captions: 
	00:00:02,879 --> 00:00:06,720
all right

00:00:03,760 --> 00:00:08,000
hello everyone around the world thank

00:00:06,720 --> 00:00:10,719
you so much for having me

00:00:08,000 --> 00:00:11,440
today here at rusty days it is late

00:00:10,719 --> 00:00:14,639
afternoon

00:00:11,440 --> 00:00:16,720
here in seattle washington uh but i hope

00:00:14,639 --> 00:00:19,600
whatever time it is in your part of the

00:00:16,720 --> 00:00:21,439
world you are doing well

00:00:19,600 --> 00:00:23,199
when i work with someone who is just

00:00:21,439 --> 00:00:25,119
learning rust

00:00:23,199 --> 00:00:28,840
they sometimes question whether the rust

00:00:25,119 --> 00:00:31,840
borrow checker is their friend or their

00:00:28,840 --> 00:00:31,840
foe

00:00:35,040 --> 00:00:45,840
one second i am getting delayed audio

00:00:37,840 --> 00:00:45,840
for some reason

00:01:01,440 --> 00:01:06,960
all right we're having some technical

00:01:02,719 --> 00:01:06,960
difficulties here let me fix this one

00:01:10,840 --> 00:01:13,840
moment

00:01:55,500 --> 00:01:58,680
[Music]

00:02:10,959 --> 00:02:15,120
all right folks for some reason i was

00:02:13,200 --> 00:02:16,080
getting some delayed audio there in my

00:02:15,120 --> 00:02:17,920
headphones

00:02:16,080 --> 00:02:19,680
so what i'm going to do is just take the

00:02:17,920 --> 00:02:22,560
headphones off and continue the

00:02:19,680 --> 00:02:24,160
presentation so i apologize for this

00:02:22,560 --> 00:02:26,480
let's go ahead and go back to the

00:02:24,160 --> 00:02:28,160
beginning when i work with someone who

00:02:26,480 --> 00:02:29,920
is just learning rust

00:02:28,160 --> 00:02:31,760
they sometimes question whether the rust

00:02:29,920 --> 00:02:34,720
borrow checker is their friend

00:02:31,760 --> 00:02:36,879
or their foe if you take a look at the

00:02:34,720 --> 00:02:39,040
russ subreddit you will see

00:02:36,879 --> 00:02:40,239
common it was common to see posts like

00:02:39,040 --> 00:02:42,400
this

00:02:40,239 --> 00:02:44,400
newbie question regarding the borrow

00:02:42,400 --> 00:02:48,160
checker

00:02:44,400 --> 00:02:51,360
help fighting the borrow checker

00:02:48,160 --> 00:02:51,760
and does it ever get easier fighting

00:02:51,360 --> 00:02:55,040
with

00:02:51,760 --> 00:02:56,959
the borrow checker so it's common to

00:02:55,040 --> 00:02:59,040
feel a lot of frustration when you're

00:02:56,959 --> 00:03:00,959
first starting with rust

00:02:59,040 --> 00:03:02,879
however as i watch people get more

00:03:00,959 --> 00:03:04,720
experience and rust

00:03:02,879 --> 00:03:06,080
they tend to come around to the borrow

00:03:04,720 --> 00:03:09,360
checker and realize

00:03:06,080 --> 00:03:11,040
what it is protecting them from doing

00:03:09,360 --> 00:03:13,599
so in answer to the question is the

00:03:11,040 --> 00:03:16,400
borrow checker a friend or a foe

00:03:13,599 --> 00:03:18,720
i say the borrow checker becomes your

00:03:16,400 --> 00:03:20,000
friend through gaining experience with

00:03:18,720 --> 00:03:22,879
it

00:03:20,000 --> 00:03:24,959
and along with getting experience it's

00:03:22,879 --> 00:03:27,920
also very helpful to understand

00:03:24,959 --> 00:03:29,280
how it works and why it does the things

00:03:27,920 --> 00:03:31,519
it does

00:03:29,280 --> 00:03:33,200
we're going to dive very deep into that

00:03:31,519 --> 00:03:36,000
but before we do

00:03:33,200 --> 00:03:37,200
let's briefly cover who i am i'm nell

00:03:36,000 --> 00:03:39,440
shamrell harrington

00:03:37,200 --> 00:03:40,640
i am a senior staff research engineer at

00:03:39,440 --> 00:03:42,879
mozilla

00:03:40,640 --> 00:03:44,959
if you if my voice sounds familiar to

00:03:42,879 --> 00:03:45,680
you i am the lead editor of this week in

00:03:44,959 --> 00:03:47,280
rust

00:03:45,680 --> 00:03:50,000
and host of the this week in russ

00:03:47,280 --> 00:03:51,680
podcast on the rust station station

00:03:50,000 --> 00:03:53,760
if you ever want to get in touch with me

00:03:51,680 --> 00:03:57,120
honestly twitter is the best

00:03:53,760 --> 00:04:00,720
go ahead and tweet me at nell shamrell

00:03:57,120 --> 00:04:03,360
and let's get back to the presentation

00:04:00,720 --> 00:04:04,400
first just to set expectations we're

00:04:03,360 --> 00:04:07,040
going to take an

00:04:04,400 --> 00:04:09,040
overview of the rust compiler in order

00:04:07,040 --> 00:04:10,400
to understand the context in which the

00:04:09,040 --> 00:04:12,480
borrow checker works

00:04:10,400 --> 00:04:15,360
it's important to understand a little

00:04:12,480 --> 00:04:17,759
bit about how the rust compiler works

00:04:15,360 --> 00:04:20,320
and then we will dive very deep into the

00:04:17,759 --> 00:04:22,400
borrow checker after

00:04:20,320 --> 00:04:25,280
so let's start with that overview of the

00:04:22,400 --> 00:04:25,280
rust compiler

00:04:25,520 --> 00:04:29,919
let's take a look at this code example

00:04:28,240 --> 00:04:31,680
this rust function

00:04:29,919 --> 00:04:33,280
declares a vector composed of the

00:04:31,680 --> 00:04:37,040
integers 1 2

00:04:33,280 --> 00:04:38,639
3 4 and 5 and after it declares this

00:04:37,040 --> 00:04:41,520
vector

00:04:38,639 --> 00:04:42,000
it then uses a for loop to iterate

00:04:41,520 --> 00:04:44,400
through each

00:04:42,000 --> 00:04:46,880
integer in the vector and print it out

00:04:44,400 --> 00:04:49,199
on a new line

00:04:46,880 --> 00:04:50,160
now if i were to run this using cargo

00:04:49,199 --> 00:04:52,560
run

00:04:50,160 --> 00:04:53,360
i would see these five numbers one

00:04:52,560 --> 00:04:56,320
through five

00:04:53,360 --> 00:04:57,440
printed out on the screen now this seems

00:04:56,320 --> 00:04:59,759
pretty simple

00:04:57,440 --> 00:05:02,080
cargo builds and runs this piece of code

00:04:59,759 --> 00:05:04,560
for us but there's a lot that happens

00:05:02,080 --> 00:05:06,080
underneath the surface in the compiler

00:05:04,560 --> 00:05:09,440
when cargo is building

00:05:06,080 --> 00:05:11,840
it there are five

00:05:09,440 --> 00:05:13,039
general stages to compiling a piece of

00:05:11,840 --> 00:05:15,120
code

00:05:13,039 --> 00:05:16,320
it starts with lexical analysis of the

00:05:15,120 --> 00:05:19,680
code

00:05:16,320 --> 00:05:21,919
then parsing of the code semantic

00:05:19,680 --> 00:05:25,840
analysis of the code this is where the

00:05:21,919 --> 00:05:25,840
borrow checker comes in

00:05:26,639 --> 00:05:31,440
and one moment i'm getting a message

00:05:32,560 --> 00:05:36,240
looks like we're having some problems

00:05:34,400 --> 00:05:39,840
with the slides let me

00:05:36,240 --> 00:05:39,840
go back a little bit

00:05:55,919 --> 00:05:59,199
all right i'm not sure why the slides

00:05:57,919 --> 00:06:02,240
are not updating

00:05:59,199 --> 00:06:07,840
but we are going to figure that out uh

00:06:02,240 --> 00:06:07,840
right here

00:06:11,770 --> 00:06:14,800
[Music]

00:06:16,720 --> 00:06:20,000
and we're going to get this figured out

00:06:18,160 --> 00:06:22,400
for you folks give us just

00:06:20,000 --> 00:06:22,400
a moment

00:06:23,759 --> 00:06:26,880
what i'm going to do is i'm going to

00:06:25,440 --> 00:06:29,120
stop presenting for a moment

00:06:26,880 --> 00:06:31,520
and then i will restart presenting just

00:06:29,120 --> 00:06:33,039
to see if that fixes the issue with the

00:06:31,520 --> 00:06:35,840
slides not updating

00:06:33,039 --> 00:06:35,840
one moment please

00:06:45,520 --> 00:06:49,840
and let's do this again

00:06:55,520 --> 00:07:00,080
all right i think this should fix the

00:06:58,400 --> 00:07:03,120
issue

00:07:00,080 --> 00:07:05,680
one moment

00:07:03,120 --> 00:07:08,240
let me see if the slides are updating on

00:07:05,680 --> 00:07:08,240
the stream

00:07:11,280 --> 00:07:15,280
i apologize folks this is what happens

00:07:13,199 --> 00:07:17,120
in live presentations sometimes

00:07:15,280 --> 00:07:19,199
uh there's some technical difficulties

00:07:17,120 --> 00:07:20,240
but i promise there's some great content

00:07:19,199 --> 00:07:21,759
coming from here

00:07:20,240 --> 00:07:24,319
all right i'm getting the message that

00:07:21,759 --> 00:07:27,840
it seems to be okay right now

00:07:24,319 --> 00:07:29,759
so let's go ahead and go back to this

00:07:27,840 --> 00:07:31,440
so as i said before if you're looking at

00:07:29,759 --> 00:07:33,599
the rust subreddit on reddit

00:07:31,440 --> 00:07:36,240
it's common to see questions like newbie

00:07:33,599 --> 00:07:39,280
question regarding the borrow checker

00:07:36,240 --> 00:07:42,400
help fighting the borrow checker

00:07:39,280 --> 00:07:44,639
and does it ever get easier fighting

00:07:42,400 --> 00:07:46,319
with the borrow checker

00:07:44,639 --> 00:07:47,759
however as you watch people gain more

00:07:46,319 --> 00:07:49,440
experience and rust

00:07:47,759 --> 00:07:50,879
they tend to come around to the borrow

00:07:49,440 --> 00:07:54,080
checker and realize

00:07:50,879 --> 00:07:55,759
what it protects them from doing so an

00:07:54,080 --> 00:07:58,720
answer to the question is the borrowed

00:07:55,759 --> 00:08:00,800
checker a friend or a foe i say

00:07:58,720 --> 00:08:03,199
the borrow checker will become your

00:08:00,800 --> 00:08:05,120
friend through experience

00:08:03,199 --> 00:08:06,400
and along with gaining experience with

00:08:05,120 --> 00:08:09,120
it it's

00:08:06,400 --> 00:08:10,960
very helpful to understand how it works

00:08:09,120 --> 00:08:13,680
and why it does the things

00:08:10,960 --> 00:08:15,919
it does we're going to dive very deep

00:08:13,680 --> 00:08:18,240
into that but before we do

00:08:15,919 --> 00:08:19,440
let's briefly cover who i am i already

00:08:18,240 --> 00:08:20,800
went through this i'm going to go ahead

00:08:19,440 --> 00:08:23,120
and skip it but

00:08:20,800 --> 00:08:26,160
i will put my details back up at the end

00:08:23,120 --> 00:08:27,840
of the presentation

00:08:26,160 --> 00:08:29,280
let's get back to our overview of the

00:08:27,840 --> 00:08:31,759
rust compiler

00:08:29,280 --> 00:08:32,719
so here's the code that i want you to be

00:08:31,759 --> 00:08:36,320
looking at

00:08:32,719 --> 00:08:38,719
and if we look at this rust function

00:08:36,320 --> 00:08:40,080
we see that we declare a vector composed

00:08:38,719 --> 00:08:44,080
of the integers 1

00:08:40,080 --> 00:08:45,120
2 3 4 and 5 and after it declares this

00:08:44,080 --> 00:08:47,519
vector

00:08:45,120 --> 00:08:49,279
we use a for loop to iterate through

00:08:47,519 --> 00:08:52,800
each integer in the vector

00:08:49,279 --> 00:08:56,399
and print it out on a new line

00:08:52,800 --> 00:08:58,399
if i run this with cargo run as expected

00:08:56,399 --> 00:09:01,519
i will see the numbers one through five

00:08:58,399 --> 00:09:02,480
printed out on the screen now this seems

00:09:01,519 --> 00:09:04,640
pretty simple

00:09:02,480 --> 00:09:05,680
cargo builds and runs this piece of code

00:09:04,640 --> 00:09:07,680
for us

00:09:05,680 --> 00:09:08,880
but there is a lot that happens

00:09:07,680 --> 00:09:13,440
underneath the surface

00:09:08,880 --> 00:09:15,519
in the compiler when cargo is building

00:09:13,440 --> 00:09:17,839
there are five general stages to

00:09:15,519 --> 00:09:20,839
compiling a piece of code

00:09:17,839 --> 00:09:22,560
it starts with lexical analysis of the

00:09:20,839 --> 00:09:26,560
code

00:09:22,560 --> 00:09:28,480
then parsing of the code semantic

00:09:26,560 --> 00:09:30,959
analysis of the code this is where the

00:09:28,480 --> 00:09:34,800
borrow checker comes in

00:09:30,959 --> 00:09:36,480
optimization of the code and finally

00:09:34,800 --> 00:09:38,560
code generation

00:09:36,480 --> 00:09:41,680
where the compiler creates that

00:09:38,560 --> 00:09:44,000
executable binary of our code

00:09:41,680 --> 00:09:45,120
when we look at the stages laid out in a

00:09:44,000 --> 00:09:46,640
list like this

00:09:45,120 --> 00:09:48,160
it might seem like they will run

00:09:46,640 --> 00:09:51,040
linearly and

00:09:48,160 --> 00:09:52,640
in some compilers they do however if

00:09:51,040 --> 00:09:54,160
you've delved it all into the rust

00:09:52,640 --> 00:09:57,040
compiler internals

00:09:54,160 --> 00:09:58,720
you might be thinking wait a minute

00:09:57,040 --> 00:10:00,800
isn't the rust compiler at least

00:09:58,720 --> 00:10:04,000
partially query based

00:10:00,800 --> 00:10:07,360
rather than linear based and the

00:10:04,000 --> 00:10:09,600
answer to this is yes it is a partially

00:10:07,360 --> 00:10:11,519
query based at this time

00:10:09,600 --> 00:10:13,279
but that is out of the scope of this

00:10:11,519 --> 00:10:14,959
particular talk

00:10:13,279 --> 00:10:16,560
for the sake of clarity i'll speak to

00:10:14,959 --> 00:10:18,959
the internals of the compiler

00:10:16,560 --> 00:10:20,240
as if they were functioning linearly

00:10:18,959 --> 00:10:22,320
however

00:10:20,240 --> 00:10:24,399
if you want to delve more into how the

00:10:22,320 --> 00:10:25,360
rust compiler is query based and what

00:10:24,399 --> 00:10:27,040
that means

00:10:25,360 --> 00:10:29,519
check out the guide to rust c

00:10:27,040 --> 00:10:31,760
development for more information

00:10:29,519 --> 00:10:33,200
this guide has been a big help to me as

00:10:31,760 --> 00:10:36,480
i have learned myself

00:10:33,200 --> 00:10:37,200
how to hack on the rust compiler so

00:10:36,480 --> 00:10:39,120
check it out

00:10:37,200 --> 00:10:40,320
and get all the information you want

00:10:39,120 --> 00:10:43,920
about the rust compiler

00:10:40,320 --> 00:10:45,120
and more going back to the stages of

00:10:43,920 --> 00:10:47,360
compilation

00:10:45,120 --> 00:10:50,160
let's start with the first one here

00:10:47,360 --> 00:10:53,200
lexical analysis

00:10:50,160 --> 00:10:55,839
during lexical analysis a program within

00:10:53,200 --> 00:10:58,560
the compiler called alexa

00:10:55,839 --> 00:10:59,279
takes the raw rust source code called a

00:10:58,560 --> 00:11:02,880
lexeme

00:10:59,279 --> 00:11:05,760
in this context and analyzes it

00:11:02,880 --> 00:11:10,480
and then splits the code into tokens to

00:11:05,760 --> 00:11:10,480
make it easier for the compiler to parse

00:11:10,959 --> 00:11:15,360
and speaking of parsing we go on to the

00:11:13,600 --> 00:11:18,560
next stage of compilation called

00:11:15,360 --> 00:11:19,279
conveniently parsing and in the parsing

00:11:18,560 --> 00:11:20,959
stage

00:11:19,279 --> 00:11:23,519
what happens is a program within the

00:11:20,959 --> 00:11:26,320
compiler called a parser

00:11:23,519 --> 00:11:27,440
takes those tokens uh created in the

00:11:26,320 --> 00:11:31,200
previous stage

00:11:27,440 --> 00:11:32,000
and analyzes them and then translates

00:11:31,200 --> 00:11:35,120
them into an

00:11:32,000 --> 00:11:37,519
abstract syntax tree or ast

00:11:35,120 --> 00:11:39,440
having the tokens in this data structure

00:11:37,519 --> 00:11:43,839
makes it quicker and easier for the

00:11:39,440 --> 00:11:43,839
compiler to do the rest of its work

00:11:44,160 --> 00:11:49,200
and now after it's done the parsing the

00:11:47,200 --> 00:11:51,600
rust compiler before it moves on to that

00:11:49,200 --> 00:11:54,079
next stage of compilation

00:11:51,600 --> 00:11:56,959
will take the abstract syntax tree

00:11:54,079 --> 00:12:00,000
generated by the parser

00:11:56,959 --> 00:12:02,880
and first expand any macros

00:12:00,000 --> 00:12:04,959
included in the code if we look back at

00:12:02,880 --> 00:12:08,839
our original source code

00:12:04,959 --> 00:12:10,160
print line our line here is actually a

00:12:08,839 --> 00:12:12,639
macro

00:12:10,160 --> 00:12:13,680
so at this point this line would be

00:12:12,639 --> 00:12:16,399
expanded

00:12:13,680 --> 00:12:17,519
to something that looks like this this

00:12:16,399 --> 00:12:20,240
is what the full

00:12:17,519 --> 00:12:21,920
expanded print line macro looks like and

00:12:20,240 --> 00:12:24,639
how it would be represented in the

00:12:21,920 --> 00:12:27,760
abstract syntax tree

00:12:24,639 --> 00:12:30,160
the next thing the compiler does is it

00:12:27,760 --> 00:12:31,839
also de-sugar some of the syntactic

00:12:30,160 --> 00:12:33,360
sugar that makes riding rust so

00:12:31,839 --> 00:12:36,800
delightful

00:12:33,360 --> 00:12:38,720
for example in rust the for loop

00:12:36,800 --> 00:12:40,000
is a piece of syntactic sugar for an

00:12:38,720 --> 00:12:42,399
iterator

00:12:40,000 --> 00:12:44,240
if we were to de-sugar this section of

00:12:42,399 --> 00:12:45,920
code

00:12:44,240 --> 00:12:47,279
it would consist of both a match

00:12:45,920 --> 00:12:50,880
statement and a

00:12:47,279 --> 00:12:52,720
loop the functionality of this code is

00:12:50,880 --> 00:12:54,720
identical to the for loop

00:12:52,720 --> 00:12:56,959
in our original source code but

00:12:54,720 --> 00:12:58,639
de-sugaring it like this makes it easier

00:12:56,959 --> 00:13:01,200
for the compiler to understand

00:12:58,639 --> 00:13:01,920
and optimize it something i like to say

00:13:01,200 --> 00:13:04,480
is sugar

00:13:01,920 --> 00:13:06,160
code is for the human who's writing and

00:13:04,480 --> 00:13:10,000
reading the code d

00:13:06,160 --> 00:13:11,839
sugar code is for the compiler

00:13:10,000 --> 00:13:14,639
and at this time the compiler also

00:13:11,839 --> 00:13:16,240
resolves any imports in the code

00:13:14,639 --> 00:13:18,079
so if you are bringing in an external

00:13:16,240 --> 00:13:19,040
crate or using internal crates or

00:13:18,079 --> 00:13:23,040
modules

00:13:19,040 --> 00:13:25,040
those would be resolved here as well

00:13:23,040 --> 00:13:26,079
and finally after the compiler does all

00:13:25,040 --> 00:13:29,200
these things

00:13:26,079 --> 00:13:32,399
it converts that abstract syntax tree

00:13:29,200 --> 00:13:35,040
into the higher level intermediate

00:13:32,399 --> 00:13:37,040
representation or h-i-r

00:13:35,040 --> 00:13:38,639
some people say here some people say

00:13:37,040 --> 00:13:41,680
h-i-r i generally prefer

00:13:38,639 --> 00:13:44,560
h-i-r so let's pause here

00:13:41,680 --> 00:13:47,760
and take a closer look at how that hr

00:13:44,560 --> 00:13:49,600
i-h-i-r is constructed

00:13:47,760 --> 00:13:52,399
it helps to understand the data

00:13:49,600 --> 00:13:55,199
structures that make up the hir

00:13:52,399 --> 00:13:57,040
the first data structure is a node this

00:13:55,199 --> 00:14:00,839
corresponds to a specific

00:13:57,040 --> 00:14:03,279
piece of code this is identified by an

00:14:00,839 --> 00:14:06,000
h-i-r-i-d

00:14:03,279 --> 00:14:06,880
and that node belongs to a definition a

00:14:06,000 --> 00:14:08,720
definition

00:14:06,880 --> 00:14:10,160
is an item within the crate that we are

00:14:08,720 --> 00:14:12,560
compiling

00:14:10,160 --> 00:14:14,639
definitions are primarily top-level

00:14:12,560 --> 00:14:18,959
items within the crate

00:14:14,639 --> 00:14:21,839
this is identified by a def id

00:14:18,959 --> 00:14:22,560
and that definition uh defined by the

00:14:21,839 --> 00:14:25,440
def id

00:14:22,560 --> 00:14:26,000
is owned by the crate data structure

00:14:25,440 --> 00:14:29,199
this is

00:14:26,000 --> 00:14:31,120
the crate we are compiling with rust

00:14:29,199 --> 00:14:32,720
this data structure stores the contents

00:14:31,120 --> 00:14:35,600
of the crate we are compiling

00:14:32,720 --> 00:14:36,399
and also contains a number of maps and

00:14:35,600 --> 00:14:38,399
other things

00:14:36,399 --> 00:14:40,720
that help organize the content for

00:14:38,399 --> 00:14:42,079
easier access throughout the compilation

00:14:40,720 --> 00:14:44,720
process

00:14:42,079 --> 00:14:46,399
this crate is identified with a crate

00:14:44,720 --> 00:14:48,320
num

00:14:46,399 --> 00:14:51,839
so looking back at our original source

00:14:48,320 --> 00:14:55,120
code let's focus on this section here

00:14:51,839 --> 00:14:55,839
that for loop and remember that this

00:14:55,120 --> 00:14:58,959
loop

00:14:55,839 --> 00:15:00,240
d sugars into a match statement and a

00:14:58,959 --> 00:15:02,800
loop

00:15:00,240 --> 00:15:05,440
if we look at the node in the hir that

00:15:02,800 --> 00:15:08,240
represents this match statement

00:15:05,440 --> 00:15:10,000
we would see something similar to this

00:15:08,240 --> 00:15:10,560
now this is a little hard to read for

00:15:10,000 --> 00:15:13,760
humans

00:15:10,560 --> 00:15:14,560
so let's break it down this arm

00:15:13,760 --> 00:15:16,800
structure

00:15:14,560 --> 00:15:18,800
represents a single arm of the match

00:15:16,800 --> 00:15:20,560
statement that our for loop de-sugared

00:15:18,800 --> 00:15:22,800
into

00:15:20,560 --> 00:15:23,760
and then we have the hir id for this

00:15:22,800 --> 00:15:26,560
piece of code

00:15:23,760 --> 00:15:27,440
this identifies a node that corresponds

00:15:26,560 --> 00:15:31,920
to that code

00:15:27,440 --> 00:15:33,519
within the hir and that node is owned by

00:15:31,920 --> 00:15:36,240
a definition

00:15:33,519 --> 00:15:37,600
the definition is some top level item in

00:15:36,240 --> 00:15:40,240
the crate

00:15:37,600 --> 00:15:40,959
and that definition data structure is

00:15:40,240 --> 00:15:44,480
owned by

00:15:40,959 --> 00:15:47,600
a crate data structure so our for loop

00:15:44,480 --> 00:15:49,759
is a node within a definition within our

00:15:47,600 --> 00:15:51,759
crates

00:15:49,759 --> 00:15:54,320
and that's how we can identify where

00:15:51,759 --> 00:15:55,600
this node corresponds to in our original

00:15:54,320 --> 00:15:59,120
code

00:15:55,600 --> 00:16:01,199
what also helps us do that is what is

00:15:59,120 --> 00:16:04,000
called a span

00:16:01,199 --> 00:16:05,839
the span stores the file path line

00:16:04,000 --> 00:16:09,040
numbers and column numbers of the

00:16:05,839 --> 00:16:11,279
original source code this will be very

00:16:09,040 --> 00:16:13,279
important in the future as we optimize

00:16:11,279 --> 00:16:15,120
and de-sugar the code

00:16:13,279 --> 00:16:17,199
if we encounter a problem with the code

00:16:15,120 --> 00:16:20,079
if the compiler encounters a problem

00:16:17,199 --> 00:16:22,480
after it is de-sugared and optimized we

00:16:20,079 --> 00:16:24,560
still want to be able to show the user

00:16:22,480 --> 00:16:27,040
where in their original code that they

00:16:24,560 --> 00:16:28,639
wrote that the error was generated

00:16:27,040 --> 00:16:30,320
if we were to have a problem with the

00:16:28,639 --> 00:16:32,240
with the d sugar code

00:16:30,320 --> 00:16:33,839
and show them those lines it probably

00:16:32,240 --> 00:16:35,199
wouldn't mean that much to them because

00:16:33,839 --> 00:16:37,839
it's different from the code they

00:16:35,199 --> 00:16:37,839
originally wrote

00:16:37,920 --> 00:16:44,079
at this point the compiler then

00:16:40,959 --> 00:16:46,480
takes this hir and lowers it again

00:16:44,079 --> 00:16:48,079
into the mid-level intermediate

00:16:46,480 --> 00:16:51,759
representation

00:16:48,079 --> 00:16:55,519
also known as the mir

00:16:51,759 --> 00:16:56,800
the mir is constructed as a control

00:16:55,519 --> 00:16:59,759
graph

00:16:56,800 --> 00:17:00,240
the units within this control graph are

00:16:59,759 --> 00:17:02,639
called

00:17:00,240 --> 00:17:06,319
basic blocks which are identified with

00:17:02,639 --> 00:17:09,439
values like bb0 and bb1

00:17:06,319 --> 00:17:10,480
within these blocks each has a sequence

00:17:09,439 --> 00:17:13,839
of statements that

00:17:10,480 --> 00:17:15,760
execute in order the very last statement

00:17:13,839 --> 00:17:18,000
is known as a terminator

00:17:15,760 --> 00:17:19,760
this is where we get the go to to go to

00:17:18,000 --> 00:17:21,760
another basic building block

00:17:19,760 --> 00:17:24,079
and this is how the program proceeds

00:17:21,760 --> 00:17:26,400
throughout its structure

00:17:24,079 --> 00:17:28,319
now this is a pretty simple example

00:17:26,400 --> 00:17:30,880
there's only one direction the basic

00:17:28,319 --> 00:17:35,360
blocks can go

00:17:30,880 --> 00:17:35,360
but if our code had an if else statement

00:17:35,679 --> 00:17:39,520
like this where we have a condition if

00:17:37,360 --> 00:17:42,480
that condition is true we do one thing

00:17:39,520 --> 00:17:43,200
if it's not true we do something else

00:17:42,480 --> 00:17:45,440
the control

00:17:43,200 --> 00:17:46,240
graph would look like this the

00:17:45,440 --> 00:17:48,720
terminator

00:17:46,240 --> 00:17:50,320
of bb0 would have the option to either

00:17:48,720 --> 00:17:53,840
proceed to bb1

00:17:50,320 --> 00:17:55,760
or to bb2 in this case there is more

00:17:53,840 --> 00:17:57,840
than one path within the program

00:17:55,760 --> 00:18:02,000
that it can take when it encounters a

00:17:57,840 --> 00:18:04,960
terminator within a basic block

00:18:02,000 --> 00:18:06,799
if you are curious about more about the

00:18:04,960 --> 00:18:08,480
mir there are definitely more data

00:18:06,799 --> 00:18:11,039
structures involved in it

00:18:08,480 --> 00:18:15,840
again check out that guide to rusty

00:18:11,039 --> 00:18:15,840
development for more information

00:18:16,160 --> 00:18:22,480
let's go back to our d sugar code

00:18:19,280 --> 00:18:23,200
and let's take a focus on this match

00:18:22,480 --> 00:18:25,520
statement

00:18:23,200 --> 00:18:27,200
which is assigned to a variable called

00:18:25,520 --> 00:18:29,360
results

00:18:27,200 --> 00:18:30,799
if we looked at the mir for this piece

00:18:29,360 --> 00:18:32,720
of code

00:18:30,799 --> 00:18:34,400
it would look similar to this and i have

00:18:32,720 --> 00:18:36,559
simplified it for the sake of appearing

00:18:34,400 --> 00:18:38,160
on a slide

00:18:36,559 --> 00:18:39,919
up here in the top left you can see we

00:18:38,160 --> 00:18:42,880
have our basic block which in this case

00:18:39,919 --> 00:18:45,600
is identified as bb2

00:18:42,880 --> 00:18:48,320
and then we have what is called a local

00:18:45,600 --> 00:18:48,960
a local in the mir represents a place in

00:18:48,320 --> 00:18:51,200
memory

00:18:48,960 --> 00:18:53,039
or more specifically a place on the

00:18:51,200 --> 00:18:55,520
stack frame

00:18:53,039 --> 00:18:59,200
in this case underscore 5 corresponds to

00:18:55,520 --> 00:19:02,000
the value of the variable result

00:18:59,200 --> 00:19:03,039
and like in the nodes in the hir we have

00:19:02,000 --> 00:19:04,799
a span

00:19:03,039 --> 00:19:07,039
the piece of the original rust source

00:19:04,799 --> 00:19:08,880
code that each node in the mir

00:19:07,039 --> 00:19:10,640
corresponds to

00:19:08,880 --> 00:19:12,400
again if we encounter an error when

00:19:10,640 --> 00:19:13,200
we're operating with this within this

00:19:12,400 --> 00:19:15,840
mir

00:19:13,200 --> 00:19:17,600
we can still easily refer to what lines

00:19:15,840 --> 00:19:19,919
in the original source code caused the

00:19:17,600 --> 00:19:19,919
error

00:19:20,320 --> 00:19:24,960
and that brings us to this third stage

00:19:22,559 --> 00:19:28,320
and this is big in the rust compiler

00:19:24,960 --> 00:19:30,160
semantic analysis

00:19:28,320 --> 00:19:32,559
this is where the compiler tries to

00:19:30,160 --> 00:19:33,120
figure out what the program is trying to

00:19:32,559 --> 00:19:35,360
do

00:19:33,120 --> 00:19:36,880
in a way the compiler can understand it

00:19:35,360 --> 00:19:40,080
and then translate it

00:19:36,880 --> 00:19:42,080
into machine code

00:19:40,080 --> 00:19:44,000
and at this point after it's lowered the

00:19:42,080 --> 00:19:46,320
hir into the mir

00:19:44,000 --> 00:19:47,440
the compiler will run several checks on

00:19:46,320 --> 00:19:50,960
the mir

00:19:47,440 --> 00:19:52,960
including the borrow checker

00:19:50,960 --> 00:19:54,640
now we're going to come back and dive

00:19:52,960 --> 00:19:56,080
deep into the borrow checker in just a

00:19:54,640 --> 00:19:59,600
few moments

00:19:56,080 --> 00:20:01,679
but for now let's focus on these last

00:19:59,600 --> 00:20:05,520
two stages of compilation

00:20:01,679 --> 00:20:07,360
optimization and code generation

00:20:05,520 --> 00:20:09,039
these stages are where the code is

00:20:07,360 --> 00:20:12,480
transformed into an

00:20:09,039 --> 00:20:12,960
executable binary in the rust compiler

00:20:12,480 --> 00:20:16,480
we use

00:20:12,960 --> 00:20:19,360
llvm to do this for us

00:20:16,480 --> 00:20:20,240
llvm is a commonly used collection of

00:20:19,360 --> 00:20:22,720
modular

00:20:20,240 --> 00:20:24,559
and reusable compiler and tool chain

00:20:22,720 --> 00:20:27,200
technologies

00:20:24,559 --> 00:20:28,400
the rust compiler uses it to further

00:20:27,200 --> 00:20:30,799
optimize the code

00:20:28,400 --> 00:20:34,000
and generate the machine code to run it

00:20:30,799 --> 00:20:38,480
as an executable

00:20:34,000 --> 00:20:41,600
before it uses llvm the rust compiler

00:20:38,480 --> 00:20:45,360
takes the mir we created earlier

00:20:41,600 --> 00:20:50,960
and lowers it into the llvm

00:20:45,360 --> 00:20:53,919
intermediate representation or llvmir

00:20:50,960 --> 00:20:54,640
and the llvmir is pretty unreadable to

00:20:53,919 --> 00:20:57,679
humans

00:20:54,640 --> 00:21:00,720
but it looks something like this

00:20:57,679 --> 00:21:01,520
as we can see the llvmir is still

00:21:00,720 --> 00:21:06,559
constructed

00:21:01,520 --> 00:21:06,559
into as basic blocks like in the mir

00:21:06,799 --> 00:21:14,640
and after this the compiler then uses

00:21:10,240 --> 00:21:15,679
llvm and takes in that llbmir that we

00:21:14,640 --> 00:21:18,640
created

00:21:15,679 --> 00:21:18,960
and then it runs more optimizations on

00:21:18,640 --> 00:21:22,640
it

00:21:18,960 --> 00:21:26,000
and emits machine code

00:21:22,640 --> 00:21:26,720
and it then links the machine code files

00:21:26,000 --> 00:21:30,320
together

00:21:26,720 --> 00:21:33,280
to produce the final binary

00:21:30,320 --> 00:21:34,880
and this means when we run our code with

00:21:33,280 --> 00:21:38,320
cargo run

00:21:34,880 --> 00:21:41,520
we see those numbers printed out

00:21:38,320 --> 00:21:43,120
so yay that gives you a bit of an idea

00:21:41,520 --> 00:21:45,280
of how the compiler works

00:21:43,120 --> 00:21:48,799
to take your rust source code and make

00:21:45,280 --> 00:21:51,919
it something a computer can execute

00:21:48,799 --> 00:21:53,039
at this point i do want to go back and

00:21:51,919 --> 00:21:56,480
take a deeper

00:21:53,039 --> 00:21:59,360
look at the borrow checker

00:21:56,480 --> 00:22:01,679
and for that let's use a different piece

00:21:59,360 --> 00:22:03,360
of code

00:22:01,679 --> 00:22:05,200
if you are looking at this code if

00:22:03,360 --> 00:22:06,080
you're reading it and thinking this will

00:22:05,200 --> 00:22:08,720
error out

00:22:06,080 --> 00:22:12,240
you are right and we'll see how and why

00:22:08,720 --> 00:22:14,799
that happens in just a moment

00:22:12,240 --> 00:22:17,840
first we declare the variable x and give

00:22:14,799 --> 00:22:21,039
it the type of string

00:22:17,840 --> 00:22:24,320
then we set the value of x to the string

00:22:21,039 --> 00:22:26,159
high rusty days

00:22:24,320 --> 00:22:28,640
then we say that the variable the value

00:22:26,159 --> 00:22:32,480
of y is equal to the value in

00:22:28,640 --> 00:22:35,520
x and then we attempt to print

00:22:32,480 --> 00:22:35,520
both variables

00:22:35,679 --> 00:22:41,760
if we were to try to build this piece of

00:22:38,159 --> 00:22:44,559
code as it is now with cargo build

00:22:41,760 --> 00:22:45,360
it would get give us an error and this

00:22:44,559 --> 00:22:48,880
error

00:22:45,360 --> 00:22:51,440
is the result of the borrow checker

00:22:48,880 --> 00:22:53,039
we are trying to use a value or we are

00:22:51,440 --> 00:22:56,159
trying to borrow a value

00:22:53,039 --> 00:22:57,760
after it has already been moved let's go

00:22:56,159 --> 00:23:00,960
through how the borrow checker

00:22:57,760 --> 00:23:00,960
identified this error

00:23:01,200 --> 00:23:04,320
the borrow checker does several things

00:23:03,679 --> 00:23:07,440
including

00:23:04,320 --> 00:23:10,480
tracking initializations and moves

00:23:07,440 --> 00:23:12,480
how this plays out in our code is

00:23:10,480 --> 00:23:14,960
when we start with this first line where

00:23:12,480 --> 00:23:16,960
we declare the variable x to have a type

00:23:14,960 --> 00:23:19,760
of string

00:23:16,960 --> 00:23:21,120
x is not actually initialized at this

00:23:19,760 --> 00:23:23,840
point

00:23:21,120 --> 00:23:24,240
it won't be considered initialized until

00:23:23,840 --> 00:23:27,679
it is

00:23:24,240 --> 00:23:29,600
assigned a value and if we look at the

00:23:27,679 --> 00:23:31,679
mir for this line of code

00:23:29,600 --> 00:23:34,320
we can see that x is represented by the

00:23:31,679 --> 00:23:37,360
local underscore one

00:23:34,320 --> 00:23:38,799
and local underscore one is assigned the

00:23:37,360 --> 00:23:41,360
type of string

00:23:38,799 --> 00:23:42,480
so this is the mir that corresponds to

00:23:41,360 --> 00:23:44,000
this line of code

00:23:42,480 --> 00:23:46,640
and this is what the compiler is

00:23:44,000 --> 00:23:48,720
analyzing

00:23:46,640 --> 00:23:51,279
now let's look at the next line where we

00:23:48,720 --> 00:23:55,679
create the high rusty days string

00:23:51,279 --> 00:23:55,679
and assign it to be the value of x

00:23:55,840 --> 00:24:01,760
now that x has a value it is considered

00:23:59,039 --> 00:24:03,760
initialized at this point so x is

00:24:01,760 --> 00:24:06,080
initialized and the borrow checker is

00:24:03,760 --> 00:24:08,240
aware of that

00:24:06,080 --> 00:24:09,200
we create to do this we create a new

00:24:08,240 --> 00:24:11,679
place in memory

00:24:09,200 --> 00:24:14,000
local underscore 2 where we store the

00:24:11,679 --> 00:24:17,760
high rusty day string

00:24:14,000 --> 00:24:19,039
and then we move the value stored in

00:24:17,760 --> 00:24:23,200
underscore 2

00:24:19,039 --> 00:24:25,840
to underscore 1. remember underscore 1

00:24:23,200 --> 00:24:27,200
corresponds to the value of the x

00:24:25,840 --> 00:24:29,440
variable

00:24:27,200 --> 00:24:33,840
so we have created the string in memory

00:24:29,440 --> 00:24:33,840
and moved it to be the value of x

00:24:34,000 --> 00:24:37,760
now let's look at this line where we

00:24:36,240 --> 00:24:42,480
attempt to create the variable

00:24:37,760 --> 00:24:42,480
y and assign it the value of x

00:24:42,640 --> 00:24:46,240
this line is where the value of x is

00:24:45,440 --> 00:24:50,159
moved

00:24:46,240 --> 00:24:52,400
to y it's not duplicated it's moved

00:24:50,159 --> 00:24:54,000
if we look at the mir created for this

00:24:52,400 --> 00:24:56,880
line of code

00:24:54,000 --> 00:24:58,559
we see that y is assigned to the local

00:24:56,880 --> 00:25:01,279
underscore 3.

00:24:58,559 --> 00:25:05,039
remember a local represents a place in

00:25:01,279 --> 00:25:08,080
memory or a place on the stack frame

00:25:05,039 --> 00:25:10,480
and underscore three is given the type

00:25:08,080 --> 00:25:13,120
of string

00:25:10,480 --> 00:25:15,039
then the value at underscore one

00:25:13,120 --> 00:25:18,000
remember that represents the value of

00:25:15,039 --> 00:25:18,799
x is moved into the value of underscore

00:25:18,000 --> 00:25:23,120
three

00:25:18,799 --> 00:25:23,120
which represents the value of y

00:25:24,400 --> 00:25:29,520
this means we get here in our code when

00:25:27,120 --> 00:25:31,679
we try to print x we try to print the

00:25:29,520 --> 00:25:34,799
value of x

00:25:31,679 --> 00:25:36,320
x is not initialized at this line so we

00:25:34,799 --> 00:25:39,039
cannot print it

00:25:36,320 --> 00:25:41,279
once that value is moved x is no longer

00:25:39,039 --> 00:25:43,440
considered initialized

00:25:41,279 --> 00:25:46,320
and that's what generates this

00:25:43,440 --> 00:25:48,400
particular error

00:25:46,320 --> 00:25:49,600
we're attempting to use the value of a

00:25:48,400 --> 00:25:52,880
variable after

00:25:49,600 --> 00:25:52,880
it has been moved

00:25:53,200 --> 00:25:57,600
and something i'd like to specifically

00:25:55,039 --> 00:25:59,600
call out is how the compiler shows

00:25:57,600 --> 00:26:01,200
where the error was generated from the

00:25:59,600 --> 00:26:03,600
original source code

00:26:01,200 --> 00:26:05,120
this is that span that is attached to

00:26:03,600 --> 00:26:07,919
all the nodes of the hir

00:26:05,120 --> 00:26:09,120
and the mir so even though we had

00:26:07,919 --> 00:26:11,440
lowered this code

00:26:09,120 --> 00:26:12,799
into mir or mid-level intermediate

00:26:11,440 --> 00:26:15,840
representation

00:26:12,799 --> 00:26:17,919
we still tracked what items in the mir

00:26:15,840 --> 00:26:20,159
corresponded to what places in the

00:26:17,919 --> 00:26:23,440
original rus code

00:26:20,159 --> 00:26:26,960
and this is very helpful to the end user

00:26:23,440 --> 00:26:28,880
what is also helpful is this

00:26:26,960 --> 00:26:31,200
the rust compiler not only tells you

00:26:28,880 --> 00:26:33,520
what the error is and where it is

00:26:31,200 --> 00:26:34,960
it gives you a command to get even more

00:26:33,520 --> 00:26:39,039
information about the error

00:26:34,960 --> 00:26:41,200
so you can fix it and let's go ahead and

00:26:39,039 --> 00:26:43,600
run this command

00:26:41,200 --> 00:26:45,679
if we run this command we see not only

00:26:43,600 --> 00:26:48,159
an explanation of the error

00:26:45,679 --> 00:26:50,320
but also a piece of example code that

00:26:48,159 --> 00:26:53,600
would generate it

00:26:50,320 --> 00:26:55,760
then the message gives you

00:26:53,600 --> 00:26:57,120
even more information not just about

00:26:55,760 --> 00:27:00,720
what the problem is

00:26:57,120 --> 00:27:02,720
or where it originated but how to fix it

00:27:00,720 --> 00:27:04,000
this suggests using a reference to

00:27:02,720 --> 00:27:06,240
borrow a value

00:27:04,000 --> 00:27:08,720
rather than attempting to move the value

00:27:06,240 --> 00:27:12,080
which is what we saw done in the mir

00:27:08,720 --> 00:27:14,480
representation of our code so let's do

00:27:12,080 --> 00:27:17,039
what this says let's take this advice

00:27:14,480 --> 00:27:18,000
and change this line so that y is

00:27:17,039 --> 00:27:20,559
assigned to a

00:27:18,000 --> 00:27:21,279
reference to the value of x rather than

00:27:20,559 --> 00:27:24,960
moving the

00:27:21,279 --> 00:27:27,039
value of x into y

00:27:24,960 --> 00:27:29,279
and let's go ahead and run this again

00:27:27,039 --> 00:27:30,559
and once the compiler builds the code

00:27:29,279 --> 00:27:32,960
and executes it

00:27:30,559 --> 00:27:35,840
we see the message high rusty days

00:27:32,960 --> 00:27:35,840
printed out twice

00:27:35,919 --> 00:27:39,520
rather than fighting the borrow checker

00:27:38,240 --> 00:27:43,120
we used it to make

00:27:39,520 --> 00:27:43,120
our code even better

00:27:44,399 --> 00:27:48,559
along with tracking initializations and

00:27:46,399 --> 00:27:51,679
moves the borrow checker

00:27:48,559 --> 00:27:55,520
also deals with lifetime inference and

00:27:51,679 --> 00:27:58,480
let's go over exactly what that means

00:27:55,520 --> 00:28:00,720
rust uses the word lifetime in two

00:27:58,480 --> 00:28:02,640
distinct ways

00:28:00,720 --> 00:28:04,559
the first way is to refer to the

00:28:02,640 --> 00:28:07,679
lifetime of a value

00:28:04,559 --> 00:28:11,279
that's the span of time before the value

00:28:07,679 --> 00:28:13,279
of the variable gets freed another

00:28:11,279 --> 00:28:15,840
word for referring to the lifetime of a

00:28:13,279 --> 00:28:18,320
value is referring to the variable

00:28:15,840 --> 00:28:20,399
scope and let's see how this plays out

00:28:18,320 --> 00:28:22,080
in our code

00:28:20,399 --> 00:28:23,520
and let's start with this first let's

00:28:22,080 --> 00:28:25,760
start with the second line

00:28:23,520 --> 00:28:28,000
where we assign the value of x to this

00:28:25,760 --> 00:28:30,720
high rusty day strength

00:28:28,000 --> 00:28:31,120
at this point x is live it's initialized

00:28:30,720 --> 00:28:34,480
its

00:28:31,120 --> 00:28:36,720
lifetime begins here

00:28:34,480 --> 00:28:37,679
when we get to here and move the value

00:28:36,720 --> 00:28:42,640
of

00:28:37,679 --> 00:28:44,880
x into y this is the end of x's lifetime

00:28:42,640 --> 00:28:46,799
and that means when we get down here and

00:28:44,880 --> 00:28:48,320
we try to use x again with our

00:28:46,799 --> 00:28:50,960
uncorrected code

00:28:48,320 --> 00:28:54,240
x is dead its lifetime is no longer in

00:28:50,960 --> 00:28:56,880
effect and it is no longer initialized

00:28:54,240 --> 00:28:59,840
this is why this program generated the

00:28:56,880 --> 00:28:59,840
error that we saw

00:29:00,000 --> 00:29:04,159
the other way rust uses the work term

00:29:03,200 --> 00:29:06,720
lifetime

00:29:04,159 --> 00:29:08,960
is referred to refer to the lifetime of

00:29:06,720 --> 00:29:12,320
a reference to a value

00:29:08,960 --> 00:29:15,360
this is the span of code or span of time

00:29:12,320 --> 00:29:17,039
in which the reference can be used

00:29:15,360 --> 00:29:20,000
let's look at that corrected code where

00:29:17,039 --> 00:29:22,960
we created a reference

00:29:20,000 --> 00:29:26,960
so here we assign the value of y to be a

00:29:22,960 --> 00:29:29,039
reference to the value of x

00:29:26,960 --> 00:29:30,640
if we look at the mir for this line of

00:29:29,039 --> 00:29:32,799
code

00:29:30,640 --> 00:29:34,960
we remember that the local underscore 1

00:29:32,799 --> 00:29:38,960
refers to x

00:29:34,960 --> 00:29:42,320
and the local underscore 3 refers to y

00:29:38,960 --> 00:29:45,039
and we see that underscore three or y

00:29:42,320 --> 00:29:46,240
is assigned a reference to the value of

00:29:45,039 --> 00:29:49,440
underscore one

00:29:46,240 --> 00:29:52,320
or x this is how a reference

00:29:49,440 --> 00:29:53,919
creating a reference looks in the mir

00:29:52,320 --> 00:29:57,600
and this is what the compiler is

00:29:53,919 --> 00:30:00,880
analyzing with the borrow checker

00:29:57,600 --> 00:30:03,600
looking back at our code let's alter

00:30:00,880 --> 00:30:06,559
this slightly

00:30:03,600 --> 00:30:07,679
and let's try to drop the value of the

00:30:06,559 --> 00:30:10,880
variable x

00:30:07,679 --> 00:30:11,760
before we try to print out the value of

00:30:10,880 --> 00:30:15,840
y

00:30:11,760 --> 00:30:19,440
so we're dropping the value of x here

00:30:15,840 --> 00:30:22,480
if we do this and then try to build

00:30:19,440 --> 00:30:25,919
our code with cargo

00:30:22,480 --> 00:30:29,200
we will get another borrow checker error

00:30:25,919 --> 00:30:30,159
we cannot drop x we cannot move out of x

00:30:29,200 --> 00:30:34,000
because it is

00:30:30,159 --> 00:30:36,399
borrowed and that borrow is used later

00:30:34,000 --> 00:30:38,159
the borrow checker tells us that x

00:30:36,399 --> 00:30:41,840
because it is referenced by

00:30:38,159 --> 00:30:42,559
y needs to stay alive for at least as

00:30:41,840 --> 00:30:45,760
long as

00:30:42,559 --> 00:30:48,880
y needs to stay alive that means x

00:30:45,760 --> 00:30:49,760
is lifetime must be greater than or

00:30:48,880 --> 00:30:54,320
equal to

00:30:49,760 --> 00:30:56,559
y's lifetime looking at this in the code

00:30:54,320 --> 00:30:59,440
again this is x is lifetime this is the

00:30:56,559 --> 00:31:01,360
lifetime of x

00:30:59,440 --> 00:31:02,640
and this is what needs to be the

00:31:01,360 --> 00:31:05,760
lifetime of y

00:31:02,640 --> 00:31:09,039
which is a reference to x notice that

00:31:05,760 --> 00:31:12,960
even though these two lifetimes overlap

00:31:09,039 --> 00:31:15,840
x's lifetime ends before y's lifetime is

00:31:12,960 --> 00:31:15,840
supposed to end

00:31:15,919 --> 00:31:19,360
that means that once we drop the value

00:31:19,120 --> 00:31:22,399
of

00:31:19,360 --> 00:31:24,799
x again x's lifetime is over and y

00:31:22,399 --> 00:31:25,679
can no longer reference the value of x

00:31:24,799 --> 00:31:29,760
after this

00:31:25,679 --> 00:31:32,000
line so at this point in this last line

00:31:29,760 --> 00:31:33,279
x would be dead its lifetime is no

00:31:32,000 --> 00:31:35,519
longer an effect

00:31:33,279 --> 00:31:36,399
and why would not be able to reference

00:31:35,519 --> 00:31:39,039
it

00:31:36,399 --> 00:31:40,080
again in order for this code to compile

00:31:39,039 --> 00:31:43,120
the lifetime of

00:31:40,080 --> 00:31:46,159
x must last at least as long as the

00:31:43,120 --> 00:31:49,039
lifetime of y

00:31:46,159 --> 00:31:50,880
and how these two ways the overarching

00:31:49,039 --> 00:31:52,880
way the scope and the lifetime of a

00:31:50,880 --> 00:31:54,559
reference relate to each other

00:31:52,880 --> 00:31:56,159
is that if you make a reference to a

00:31:54,559 --> 00:31:58,720
value

00:31:56,159 --> 00:32:00,000
the lifetime of that reference cannot

00:31:58,720 --> 00:32:02,000
outlive the scope

00:32:00,000 --> 00:32:03,279
of the value this is something that gave

00:32:02,000 --> 00:32:05,440
me a lot of trouble

00:32:03,279 --> 00:32:06,960
early in my rest days and once i

00:32:05,440 --> 00:32:11,919
understood how it worked

00:32:06,960 --> 00:32:11,919
it made it much easier to do my rest

00:32:12,080 --> 00:32:15,200
now as i move toward concluding this

00:32:13,919 --> 00:32:17,039
presentation

00:32:15,200 --> 00:32:19,279
i want to make sure that you know that

00:32:17,039 --> 00:32:20,240
there is so much more to the rust

00:32:19,279 --> 00:32:23,760
compiler

00:32:20,240 --> 00:32:24,880
and the borrow checker again if you want

00:32:23,760 --> 00:32:26,720
to know more

00:32:24,880 --> 00:32:28,080
check out the guide to rust c

00:32:26,720 --> 00:32:31,120
development for more

00:32:28,080 --> 00:32:33,840
information it is a fantastic resource

00:32:31,120 --> 00:32:36,000
it has been so helpful to me as i've

00:32:33,840 --> 00:32:36,640
taken my own steps not only into using

00:32:36,000 --> 00:32:41,120
rust

00:32:36,640 --> 00:32:42,559
but hacking on the rust compiler itself

00:32:41,120 --> 00:32:44,240
going back to this question from the

00:32:42,559 --> 00:32:48,399
beginning

00:32:44,240 --> 00:32:51,519
is the borrow checker a friend or a foe

00:32:48,399 --> 00:32:54,720
my answer is it's a friend though a

00:32:51,519 --> 00:32:57,200
very strict friend

00:32:54,720 --> 00:32:59,440
but the best thing about this friend is

00:32:57,200 --> 00:33:01,919
it will not only tell you when you do

00:32:59,440 --> 00:33:04,880
something wrong

00:33:01,919 --> 00:33:06,320
it will also tell you how to fix it and

00:33:04,880 --> 00:33:08,080
i find that to be one of the best

00:33:06,320 --> 00:33:10,399
qualities i can find in a friend

00:33:08,080 --> 00:33:14,080
as well as one of the best qualities i

00:33:10,399 --> 00:33:14,080
can find in a compiler

00:33:14,320 --> 00:33:18,399
thank you there is my information again

00:33:17,039 --> 00:33:25,840
if you want to reach out to me

00:33:18,399 --> 00:33:25,840
and i'm ready to take some questions

00:33:35,600 --> 00:33:39,840
all right i see that we are waiting for

00:33:37,200 --> 00:33:39,840
questions

00:33:50,000 --> 00:33:53,039
certainly hope this is helpful to you

00:33:51,360 --> 00:34:07,840
it's been helpful to me just creating

00:33:53,039 --> 00:34:07,840
this presentation

00:34:18,720 --> 00:34:20,960
all right just so you know if you're

00:34:19,599 --> 00:34:22,720
watching at home there is a little bit

00:34:20,960 --> 00:34:24,079
of a lag so if you see me

00:34:22,720 --> 00:34:26,560
uh just standing here that's because i'm

00:34:24,079 --> 00:34:27,280
waiting for uh the broadcast to catch up

00:34:26,560 --> 00:34:30,480
with the lag

00:34:27,280 --> 00:34:30,480
and i'm looking forward to your

00:34:32,839 --> 00:34:35,839
questions

00:35:08,370 --> 00:35:11,469
[Music]

00:35:36,480 --> 00:35:39,839
all right sure anyone out there doesn't

00:35:38,480 --> 00:35:41,200
have questions

00:35:39,839 --> 00:35:42,640
i know i had a lot of questions about

00:35:41,200 --> 00:35:43,599
how the compiler works when i got

00:35:42,640 --> 00:35:45,520
started

00:35:43,599 --> 00:35:46,800
or questions about the borrow tracker

00:35:45,520 --> 00:35:49,680
you can ask questions about this week

00:35:46,800 --> 00:35:49,680
and rest if you like

00:35:53,119 --> 00:35:59,359
all right twitch user crd477

00:35:56,960 --> 00:36:01,280
says thanks for the talk you're welcome

00:35:59,359 --> 00:36:03,920
russ ownership model seems to be pretty

00:36:01,280 --> 00:36:05,680
unique in the pl world

00:36:03,920 --> 00:36:08,000
i'm assuming pl means programming

00:36:05,680 --> 00:36:10,880
language has anything like it been

00:36:08,000 --> 00:36:12,160
tried in previous languages well the

00:36:10,880 --> 00:36:14,480
answer is

00:36:12,160 --> 00:36:15,440
that the answer that is i don't know i

00:36:14,480 --> 00:36:18,000
don't know of

00:36:15,440 --> 00:36:19,440
any uh ownership models in the

00:36:18,000 --> 00:36:20,160
programming language that i've used at

00:36:19,440 --> 00:36:22,320
least

00:36:20,160 --> 00:36:23,359
that come anywhere close to us in my

00:36:22,320 --> 00:36:25,119
experience

00:36:23,359 --> 00:36:26,720
rust is pretty unique at least as it

00:36:25,119 --> 00:36:27,920
comes to mainstream programming

00:36:26,720 --> 00:36:29,599
languages

00:36:27,920 --> 00:36:31,280
uh so if anyone knows the programming

00:36:29,599 --> 00:36:33,920
languages that use uh

00:36:31,280 --> 00:36:35,119
rus an ownership model similar to rust

00:36:33,920 --> 00:36:39,599
please go ahead

00:36:35,119 --> 00:36:43,280
and send it to me i'm curious

00:36:39,599 --> 00:36:48,320
all right next one is from twitch

00:36:43,280 --> 00:36:51,119
you wed reach u-w-e-d-r-a-c-h-e

00:36:48,320 --> 00:36:52,720
asks is x's lifetime extended by being

00:36:51,119 --> 00:36:55,920
borrowed by y

00:36:52,720 --> 00:36:58,800
and the answer to that is no uh

00:36:55,920 --> 00:37:00,000
x's lifetime will end when we drop it

00:36:58,800 --> 00:37:02,880
even if it's borrowed by

00:37:00,000 --> 00:37:04,720
why i would the nice thing about the

00:37:02,880 --> 00:37:05,520
borrower checkers as you saw that

00:37:04,720 --> 00:37:09,920
prevents us

00:37:05,520 --> 00:37:12,960
from uh yeah that prevents us from

00:37:09,920 --> 00:37:15,440
trying to compile the code when x's

00:37:12,960 --> 00:37:19,119
lifetime runs out before y's

00:37:15,440 --> 00:37:20,800
uh next question from damien on youtube

00:37:19,119 --> 00:37:22,720
is did you have any bad habits from

00:37:20,800 --> 00:37:23,599
other language that made borrow checker

00:37:22,720 --> 00:37:27,119
unhappy

00:37:23,599 --> 00:37:29,119
if so what were such habits yes

00:37:27,119 --> 00:37:31,520
i came from the ruby world like

00:37:29,119 --> 00:37:32,160
surprisingly a lot of people in the rust

00:37:31,520 --> 00:37:35,040
world

00:37:32,160 --> 00:37:37,599
so i was very used to uh you know duck

00:37:35,040 --> 00:37:39,280
typing i was very used to

00:37:37,599 --> 00:37:40,720
not really paying attention because i

00:37:39,280 --> 00:37:43,520
had the garbage collector

00:37:40,720 --> 00:37:44,640
to when my variables went into scope or

00:37:43,520 --> 00:37:47,200
out of scope

00:37:44,640 --> 00:37:48,720
so breaking those habits was hard i was

00:37:47,200 --> 00:37:49,599
definitely it definitely took a few

00:37:48,720 --> 00:37:52,000
months

00:37:49,599 --> 00:37:53,839
but it now feels like the rest code i

00:37:52,000 --> 00:37:55,440
write is so much safer than the ruby

00:37:53,839 --> 00:37:57,839
code i write i wrote

00:37:55,440 --> 00:38:02,000
or the c sharp code i wrote before that

00:37:57,839 --> 00:38:05,040
javascript etc so i really like rust

00:38:02,000 --> 00:38:07,680
let's see here uh x

00:38:05,040 --> 00:38:10,000
saw cage from youtube says would you

00:38:07,680 --> 00:38:11,599
recommend some techniques like rc's or

00:38:10,000 --> 00:38:12,820
ecs

00:38:11,599 --> 00:38:14,720
uh

00:38:12,820 --> 00:38:16,320
[Music]

00:38:14,720 --> 00:38:18,320
i'm not entirely sure what you're

00:38:16,320 --> 00:38:20,640
referring to like that rc

00:38:18,320 --> 00:38:22,079
might mean ref cell but i'm not sure

00:38:20,640 --> 00:38:24,320
what ecs

00:38:22,079 --> 00:38:26,079
stands for so if you don't mind if you

00:38:24,320 --> 00:38:28,640
clarify that i'm happy to come back to

00:38:26,079 --> 00:38:28,640
the question

00:38:29,680 --> 00:38:33,839
and all right so uh someone from twitch

00:38:32,480 --> 00:38:35,760
mr ed makes

00:38:33,839 --> 00:38:38,000
says in your last example where the

00:38:35,760 --> 00:38:39,760
lifetimes of x and y overlap

00:38:38,000 --> 00:38:41,359
do you know why it was decided to be an

00:38:39,760 --> 00:38:43,599
error as opposed to having y

00:38:41,359 --> 00:38:45,040
take ownership and this is something

00:38:43,599 --> 00:38:48,800
that has been brought up a lot

00:38:45,040 --> 00:38:51,040
i actually uh in the the uh

00:38:48,800 --> 00:38:51,920
issue of this week in russ that is going

00:38:51,040 --> 00:38:55,440
out later this

00:38:51,920 --> 00:38:56,720
uh later today uh someone writes a boats

00:38:55,440 --> 00:38:58,720
who's a russ community member

00:38:56,720 --> 00:39:00,160
writes an article about what would it be

00:38:58,720 --> 00:39:02,000
like if

00:39:00,160 --> 00:39:03,680
we had a smaller rust and i believe it's

00:39:02,000 --> 00:39:05,599
in that article that he covers

00:39:03,680 --> 00:39:06,880
what if we could have you know if

00:39:05,599 --> 00:39:10,000
lifetimes of x and y

00:39:06,880 --> 00:39:13,119
overlap uh why couldn't x

00:39:10,000 --> 00:39:14,960
or why couldn't y take ownership and the

00:39:13,119 --> 00:39:17,200
answer to this is i'm not sure i know it

00:39:14,960 --> 00:39:18,079
was a decision made early in the rest

00:39:17,200 --> 00:39:20,640
process

00:39:18,079 --> 00:39:21,440
i can probably find the rfc that

00:39:20,640 --> 00:39:22,960
explains it

00:39:21,440 --> 00:39:25,359
and i will try to do that after this

00:39:22,960 --> 00:39:28,000
talk and tweet it out

00:39:25,359 --> 00:39:29,119
next question is from parker mcmullen on

00:39:28,000 --> 00:39:31,280
youtube

00:39:29,119 --> 00:39:32,800
and they say do you ever see a future

00:39:31,280 --> 00:39:34,160
where the borrow checker moves from

00:39:32,800 --> 00:39:36,640
helpful compiler

00:39:34,160 --> 00:39:38,160
hints to being more abstracted and

00:39:36,640 --> 00:39:38,800
inferring what the programmer meant to

00:39:38,160 --> 00:39:42,079
do

00:39:38,800 --> 00:39:44,079
while still staying optimized i could

00:39:42,079 --> 00:39:45,440
see it if we made a good case for it if

00:39:44,079 --> 00:39:49,200
we did not have to give

00:39:45,440 --> 00:39:51,119
up any of the safety mechanisms that are

00:39:49,200 --> 00:39:52,400
in rust right now the reason so many

00:39:51,119 --> 00:39:54,160
people love rust especially when they

00:39:52,400 --> 00:39:56,560
come from the c plus plus world

00:39:54,160 --> 00:39:58,480
is they feel very safe because they know

00:39:56,560 --> 00:40:01,040
the compiler will tell them

00:39:58,480 --> 00:40:02,480
when something is incorrect as for the

00:40:01,040 --> 00:40:04,560
compiler abstracting and referring what

00:40:02,480 --> 00:40:06,480
the program are meant to do

00:40:04,560 --> 00:40:08,560
that'd be very interesting i'd love to

00:40:06,480 --> 00:40:10,480
see a prototype of that

00:40:08,560 --> 00:40:12,640
i don't know if i don't think the rest

00:40:10,480 --> 00:40:14,560
language will move to that anytime soon

00:40:12,640 --> 00:40:16,000
but if someone can make it work well and

00:40:14,560 --> 00:40:18,400
make a good case for it

00:40:16,000 --> 00:40:19,839
and the rest of the community agrees

00:40:18,400 --> 00:40:20,319
with it or at least the rest of the core

00:40:19,839 --> 00:40:22,079
team

00:40:20,319 --> 00:40:23,440
i could see us trying that so if

00:40:22,079 --> 00:40:24,480
anyone's interested if anyone wants to

00:40:23,440 --> 00:40:27,839
build a prototype

00:40:24,480 --> 00:40:28,400
please do i would love to see it uh next

00:40:27,839 --> 00:40:32,160
question

00:40:28,400 --> 00:40:34,640
on twitch uh czech thief

00:40:32,160 --> 00:40:35,520
czecho thief i i'm not sure if i said

00:40:34,640 --> 00:40:37,200
that right

00:40:35,520 --> 00:40:38,880
but said has there been any research

00:40:37,200 --> 00:40:42,079
into whether the borrow checker has

00:40:38,880 --> 00:40:43,760
produced measurably more reliable code

00:40:42,079 --> 00:40:45,920
the answer to that is i believe there

00:40:43,760 --> 00:40:47,680
has been formal research into it

00:40:45,920 --> 00:40:49,359
and i don't know if it counts as formal

00:40:47,680 --> 00:40:50,960
research but microsoft

00:40:49,359 --> 00:40:52,480
wrote an article i think google's

00:40:50,960 --> 00:40:55,760
written articles too

00:40:52,480 --> 00:40:59,200
about why they are rewriting their c

00:40:55,760 --> 00:40:59,680
plus code in rust a lot of times i see

00:40:59,200 --> 00:41:01,440
in

00:40:59,680 --> 00:41:03,839
you know the rush channels and slacks

00:41:01,440 --> 00:41:06,720
that i'm in that people ask well

00:41:03,839 --> 00:41:09,119
couldn't what's russ does just be done

00:41:06,720 --> 00:41:10,960
by c plus plus programmers who are

00:41:09,119 --> 00:41:13,200
committed to good standards and writing

00:41:10,960 --> 00:41:14,960
safe code and really experienced

00:41:13,200 --> 00:41:16,880
and the answer to that is the thing

00:41:14,960 --> 00:41:17,920
about programmers as you all know is

00:41:16,880 --> 00:41:20,319
we're all human

00:41:17,920 --> 00:41:21,280
we all make mistakes um i tell people

00:41:20,319 --> 00:41:25,119
about the time

00:41:21,280 --> 00:41:27,920
i wrote some not optimized uh ruby code

00:41:25,119 --> 00:41:29,359
and i ended up ddosing myself uh because

00:41:27,920 --> 00:41:32,240
the database queries it was

00:41:29,359 --> 00:41:33,119
it was uh trying to do weren't weren't

00:41:32,240 --> 00:41:36,319
uh

00:41:33,119 --> 00:41:37,520
optimized so yes i believe there has

00:41:36,319 --> 00:41:40,560
been some research

00:41:37,520 --> 00:41:43,520
the best response that i have

00:41:40,560 --> 00:41:44,480
is we have you know big tech companies

00:41:43,520 --> 00:41:46,800
who have been using c

00:41:44,480 --> 00:41:49,200
plus plus for a very long time who are

00:41:46,800 --> 00:41:51,920
seeing the value of rust

00:41:49,200 --> 00:41:53,599
all right jeff from youtube asks how

00:41:51,920 --> 00:41:55,119
does things change when you add

00:41:53,599 --> 00:41:58,000
lifetimes

00:41:55,119 --> 00:41:59,440
and the answer to that is lifetimes are

00:41:58,000 --> 00:42:02,400
even though i've been doing rest for

00:41:59,440 --> 00:42:02,800
a few uh years and i'm assuming you mean

00:42:02,400 --> 00:42:04,880
uh

00:42:02,800 --> 00:42:06,240
you know lifetimes put within the

00:42:04,880 --> 00:42:08,720
arguments of the

00:42:06,240 --> 00:42:09,839
uh function or your specifically noted

00:42:08,720 --> 00:42:13,599
lifetimes

00:42:09,839 --> 00:42:15,680
and that i mean it would if you

00:42:13,599 --> 00:42:16,800
denote that if you denote that the

00:42:15,680 --> 00:42:18,880
lifetime of x

00:42:16,800 --> 00:42:20,400
had to be as long as the lifetime of y

00:42:18,880 --> 00:42:22,240
there might be a way to do that with

00:42:20,400 --> 00:42:25,520
specifying lifetimes

00:42:22,240 --> 00:42:28,240
and that would mean that x would not be

00:42:25,520 --> 00:42:29,119
uninitialized i believe uh when you try

00:42:28,240 --> 00:42:31,200
to use y

00:42:29,119 --> 00:42:32,640
so that is another potential way to

00:42:31,200 --> 00:42:35,200
solve the problem we saw

00:42:32,640 --> 00:42:37,359
in our code would be to add a specific

00:42:35,200 --> 00:42:39,200
lifetime into it

00:42:37,359 --> 00:42:40,800
uh next question comes from youtube

00:42:39,200 --> 00:42:44,079
bart's hello me a

00:42:40,800 --> 00:42:45,760
i sincerely apologize uh if i'm

00:42:44,079 --> 00:42:47,359
butchering the names here

00:42:45,760 --> 00:42:49,359
how much would borrow checker and

00:42:47,359 --> 00:42:51,839
borrowing by be affected by chalk

00:42:49,359 --> 00:42:52,880
and polonius in the near or not so near

00:42:51,839 --> 00:42:54,560
future

00:42:52,880 --> 00:42:55,599
uh that is a great question and i think

00:42:54,560 --> 00:42:56,560
that's something that's still being

00:42:55,599 --> 00:42:58,880
figured out

00:42:56,560 --> 00:43:00,880
uh when i started putting this uh talk

00:42:58,880 --> 00:43:03,760
together i worked with nico

00:43:00,880 --> 00:43:04,560
matsukis at mozilla who's on the russ

00:43:03,760 --> 00:43:05,920
core team

00:43:04,560 --> 00:43:07,599
and i told him i'm putting together a

00:43:05,920 --> 00:43:08,160
talk on the borrow checker and he said

00:43:07,599 --> 00:43:10,160
oh

00:43:08,160 --> 00:43:11,359
let me send you your talk my talk about

00:43:10,160 --> 00:43:13,920
polonius

00:43:11,359 --> 00:43:15,520
so polonius would change things chalk

00:43:13,920 --> 00:43:17,680
would potentially i'm not as familiar

00:43:15,520 --> 00:43:20,640
with chalk as i am with polonius

00:43:17,680 --> 00:43:23,280
i because polonius at least takes a

00:43:20,640 --> 00:43:26,960
different approach to tracking borrows

00:43:23,280 --> 00:43:28,880
lens etc so i will tweet out a link to

00:43:26,960 --> 00:43:31,760
niko's slide deck which will go into

00:43:28,880 --> 00:43:34,400
more detail about polonius

00:43:31,760 --> 00:43:36,079
next question from czecho thief do

00:43:34,400 --> 00:43:37,520
people working with borrow checker find

00:43:36,079 --> 00:43:40,560
this has changed how they think about

00:43:37,520 --> 00:43:40,560
the systems they build

00:43:43,040 --> 00:43:46,720
any anecdotal thoughts on this as

00:43:45,119 --> 00:43:50,079
someone who's been using it for a while

00:43:46,720 --> 00:43:53,920
longer than the rest of us yes i

00:43:50,079 --> 00:43:54,640
so i learned i did take computer science

00:43:53,920 --> 00:43:56,079
courses

00:43:54,640 --> 00:43:58,079
in college but i was not a computer

00:43:56,079 --> 00:44:00,400
science major so i

00:43:58,079 --> 00:44:01,599
learned most of my programming from

00:44:00,400 --> 00:44:03,520
doing it

00:44:01,599 --> 00:44:05,440
and i started with web programming and

00:44:03,520 --> 00:44:06,480
with web programming yes memory is a

00:44:05,440 --> 00:44:08,160
consideration

00:44:06,480 --> 00:44:10,319
but when you're not doing back-end

00:44:08,160 --> 00:44:11,200
system programming you don't consider it

00:44:10,319 --> 00:44:13,200
as much

00:44:11,200 --> 00:44:14,880
now that said uh before i was at mozilla

00:44:13,200 --> 00:44:17,040
i was at chef software as you can

00:44:14,880 --> 00:44:18,640
see in the photo uh that's accompanying

00:44:17,040 --> 00:44:19,920
my details on the slide

00:44:18,640 --> 00:44:22,560
and that was the first time i was

00:44:19,920 --> 00:44:24,880
dealing with back end systems code

00:44:22,560 --> 00:44:25,599
and i ran into a lot of trouble trying

00:44:24,880 --> 00:44:27,599
to do it in

00:44:25,599 --> 00:44:29,520
languages like c plus plus or something

00:44:27,599 --> 00:44:31,839
and part of that was inexperienced

00:44:29,520 --> 00:44:32,560
but when i found rust it forced me to

00:44:31,839 --> 00:44:36,079
think through

00:44:32,560 --> 00:44:38,720
ahead of time of how my program would

00:44:36,079 --> 00:44:40,560
interact with memory and how the scopes

00:44:38,720 --> 00:44:41,280
of my variables and such would work

00:44:40,560 --> 00:44:43,440
through

00:44:41,280 --> 00:44:44,800
and it's very much i think of rust as

00:44:43,440 --> 00:44:47,040
someone has said this i don't remember

00:44:44,800 --> 00:44:49,920
who is compiler driven development

00:44:47,040 --> 00:44:51,839
so i write some code i try to build it

00:44:49,920 --> 00:44:53,680
and i see what the compiler tells me

00:44:51,839 --> 00:44:56,319
and then i try to correct my code and i

00:44:53,680 --> 00:44:58,560
go back and forth and iterate on that

00:44:56,319 --> 00:45:00,800
so yes it has made me think a lot about

00:44:58,560 --> 00:45:02,800
the systems that i build

00:45:00,800 --> 00:45:05,119
uh next question is michael ward which

00:45:02,800 --> 00:45:08,480
of the upcoming changes to rust are you

00:45:05,119 --> 00:45:10,000
and or mozilla most excited to see

00:45:08,480 --> 00:45:12,160
i can tell you one i'm working on

00:45:10,000 --> 00:45:15,200
personally which is adding the

00:45:12,160 --> 00:45:17,680
ability to use a stream with async or

00:45:15,200 --> 00:45:20,319
adding the stream function of async code

00:45:17,680 --> 00:45:21,680
into the standard library uh there are

00:45:20,319 --> 00:45:24,000
code

00:45:21,680 --> 00:45:26,480
there are external crates like futures

00:45:24,000 --> 00:45:28,319
rs that allow you to use a stream

00:45:26,480 --> 00:45:29,680
so you can kind of it's like an iterator

00:45:28,319 --> 00:45:31,040
but for async code

00:45:29,680 --> 00:45:33,200
but we want to move that into the

00:45:31,040 --> 00:45:35,280
standard library so

00:45:33,200 --> 00:45:36,400
async is an area that has a lot of my

00:45:35,280 --> 00:45:39,359
focus right now

00:45:36,400 --> 00:45:40,560
and it works well the way it is but i

00:45:39,359 --> 00:45:42,240
can't wait to

00:45:40,560 --> 00:45:44,160
innovate on that i'm working on drafting

00:45:42,240 --> 00:45:46,400
an rfc now

00:45:44,160 --> 00:45:47,680
regarding moving the stream trait into

00:45:46,400 --> 00:45:49,920
the standard library

00:45:47,680 --> 00:45:51,680
so async streams i would say is what i

00:45:49,920 --> 00:45:53,920
am personally most excited about right

00:45:51,680 --> 00:45:57,040
now

00:45:53,920 --> 00:45:58,560
um michael lezzowski asks how do you

00:45:57,040 --> 00:45:59,599
rate the rust community comparing to

00:45:58,560 --> 00:46:01,040
ruby

00:45:59,599 --> 00:46:02,640
well most of my experience with the ruby

00:46:01,040 --> 00:46:04,560
community was

00:46:02,640 --> 00:46:06,160
you know five or six years ago and

00:46:04,560 --> 00:46:08,400
there's a lot of people who

00:46:06,160 --> 00:46:10,079
migrated from the ruby community to rust

00:46:08,400 --> 00:46:12,800
like steve klobnick

00:46:10,079 --> 00:46:14,000
sean griffin etc so it feels like a lot

00:46:12,800 --> 00:46:17,599
of the community leaders

00:46:14,000 --> 00:46:21,119
are the same uh i would say

00:46:17,599 --> 00:46:22,079
what i love it's i ruby community is

00:46:21,119 --> 00:46:24,560
very good

00:46:22,079 --> 00:46:25,680
but i love the most about the rust

00:46:24,560 --> 00:46:27,280
community

00:46:25,680 --> 00:46:28,880
is that we are a community that

00:46:27,280 --> 00:46:31,520
considers empathy

00:46:28,880 --> 00:46:33,599
and personal maturity to be as important

00:46:31,520 --> 00:46:35,839
as technical excellence

00:46:33,599 --> 00:46:37,520
and you know ruby community has some of

00:46:35,839 --> 00:46:38,480
that but other technical communities

00:46:37,520 --> 00:46:40,960
i've been into

00:46:38,480 --> 00:46:42,960
that is definitely not the case and it

00:46:40,960 --> 00:46:43,520
is wonderful because it helped me learn

00:46:42,960 --> 00:46:45,760
rust

00:46:43,520 --> 00:46:46,720
and to see how other people learn rust

00:46:45,760 --> 00:46:49,040
how they grow

00:46:46,720 --> 00:46:50,640
and the power of the things they create

00:46:49,040 --> 00:46:51,760
and a lot of that is fostered by the

00:46:50,640 --> 00:46:53,920
rust community

00:46:51,760 --> 00:46:55,280
so i rate the rest community very very

00:46:53,920 --> 00:46:57,599
high

00:46:55,280 --> 00:46:58,400
uh let's see here next question ethan

00:46:57,599 --> 00:47:00,720
really

00:46:58,400 --> 00:47:02,240
how much do extra checks russ does

00:47:00,720 --> 00:47:04,079
affect cup

00:47:02,240 --> 00:47:05,440
uh i think he meant compilation

00:47:04,079 --> 00:47:08,640
performance

00:47:05,440 --> 00:47:11,839
uh i'm not sure actually uh so

00:47:08,640 --> 00:47:15,119
let me get back to you on that one uh

00:47:11,839 --> 00:47:16,960
ecs means entity component system ah

00:47:15,119 --> 00:47:18,960
uh answer that is i don't know i'm not

00:47:16,960 --> 00:47:22,000
as familiar with those systems i think

00:47:18,960 --> 00:47:24,240
um but i'm very curious

00:47:22,000 --> 00:47:25,839
michael ward on youtube asks are there

00:47:24,240 --> 00:47:27,440
any known borrow checker improvements

00:47:25,839 --> 00:47:30,400
that will vastly improve

00:47:27,440 --> 00:47:31,359
ergonomics like non-lexical lifetimes

00:47:30,400 --> 00:47:34,079
did

00:47:31,359 --> 00:47:36,000
i am sure there are some in the works i

00:47:34,079 --> 00:47:38,400
don't know of any specific ones off the

00:47:36,000 --> 00:47:42,480
top of my head right now

00:47:38,400 --> 00:47:45,440
uh s burnham on twitch asks since

00:47:42,480 --> 00:47:46,960
since russ doesn't have a rpl do you

00:47:45,440 --> 00:47:48,880
find new rust stations

00:47:46,960 --> 00:47:51,200
often use the compiler as a testing

00:47:48,880 --> 00:47:54,000
mechanism i.e attempting to

00:47:51,200 --> 00:47:56,000
compile fix compile again is there a

00:47:54,000 --> 00:47:57,200
better way to experiment in rust

00:47:56,000 --> 00:47:59,440
well i can tell you when i was in new

00:47:57,200 --> 00:48:02,559
york station that is exactly what i did

00:47:59,440 --> 00:48:04,160
i would write a small piece of code

00:48:02,559 --> 00:48:06,000
see what the compiler did with it

00:48:04,160 --> 00:48:07,119
compiler aired out i would change it and

00:48:06,000 --> 00:48:08,640
i would make the compiler

00:48:07,119 --> 00:48:10,800
be able to use the small piece of code

00:48:08,640 --> 00:48:12,400
before moving on to the next one

00:48:10,800 --> 00:48:14,240
uh that honestly for me has been the

00:48:12,400 --> 00:48:16,400
best way to learn

00:48:14,240 --> 00:48:18,240
the best thing about the rust compiler

00:48:16,400 --> 00:48:19,680
uh and uh someone will be doing a talk

00:48:18,240 --> 00:48:23,359
about this at russ conf

00:48:19,680 --> 00:48:24,480
in august is that the compiler itself is

00:48:23,359 --> 00:48:27,440
a tutor

00:48:24,480 --> 00:48:29,280
uh it's an automatic tutor and the error

00:48:27,440 --> 00:48:30,480
messages are very helpful because again

00:48:29,280 --> 00:48:32,160
they not only tell you what was wrong

00:48:30,480 --> 00:48:34,480
they tell you how to fix it

00:48:32,160 --> 00:48:36,079
so i would say as a new rust station

00:48:34,480 --> 00:48:38,079
yeah go ahead and compile

00:48:36,079 --> 00:48:39,680
fix compile again for me that was the

00:48:38,079 --> 00:48:42,559
best way i could learn

00:48:39,680 --> 00:48:44,880
and i know it's frustrating i promise it

00:48:42,559 --> 00:48:48,000
gets better as you come to understand

00:48:44,880 --> 00:48:51,280
why russ does the things that it does

00:48:48,000 --> 00:48:53,280
uh gullyherm souza on youtube says

00:48:51,280 --> 00:48:54,720
when my code starts to be inundated with

00:48:53,280 --> 00:48:58,000
explicit lifetimes

00:48:54,720 --> 00:48:58,720
i usually stop and rethink my types and

00:48:58,000 --> 00:49:00,319
logic

00:48:58,720 --> 00:49:02,720
i take it as a hint from the language

00:49:00,319 --> 00:49:04,400
that my code is bad do you share this

00:49:02,720 --> 00:49:07,760
experience

00:49:04,400 --> 00:49:08,319
i would say i do uh when i'm putting in

00:49:07,760 --> 00:49:10,559
a ton

00:49:08,319 --> 00:49:11,760
of explicit lifetimes i kind of feel

00:49:10,559 --> 00:49:14,480
like i'm flailing

00:49:11,760 --> 00:49:15,359
against the borrow checker rather than

00:49:14,480 --> 00:49:17,680
really

00:49:15,359 --> 00:49:19,119
you know using it to understand why it

00:49:17,680 --> 00:49:22,160
does what it does

00:49:19,119 --> 00:49:23,599
so yes a lot of explicit lifetimes in a

00:49:22,160 --> 00:49:25,119
small amount of code

00:49:23,599 --> 00:49:27,200
that tells me there's probably a

00:49:25,119 --> 00:49:29,280
different way that i can structure it

00:49:27,200 --> 00:49:30,559
and as you say stop and rethink your

00:49:29,280 --> 00:49:32,480
types and logic

00:49:30,559 --> 00:49:34,480
what i would also suggest doing is you

00:49:32,480 --> 00:49:38,079
know pause you know obviously read the

00:49:34,480 --> 00:49:39,920
uh compiler error messages and if you're

00:49:38,079 --> 00:49:41,599
trying to do a lot of explicit lifetimes

00:49:39,920 --> 00:49:43,200
to correct that error message

00:49:41,599 --> 00:49:45,280
google the error message itself there's

00:49:43,200 --> 00:49:46,319
a lot of stuff on stack overflow i

00:49:45,280 --> 00:49:48,160
believe it's uh

00:49:46,319 --> 00:49:50,079
russ from russ community member burnt

00:49:48,160 --> 00:49:54,000
sushi i love that name

00:49:50,079 --> 00:49:56,240
uh has posted so many really helpful uh

00:49:54,000 --> 00:49:58,079
answers on it and the best thing about

00:49:56,240 --> 00:50:00,400
bert sushi's answers is they very

00:49:58,079 --> 00:50:01,680
clearly understand how the rust compiler

00:50:00,400 --> 00:50:05,040
works and they

00:50:01,680 --> 00:50:06,720
uh give answers along those lines

00:50:05,040 --> 00:50:08,640
so that's the other thing i would do is

00:50:06,720 --> 00:50:10,480
yeah it's a sign that something

00:50:08,640 --> 00:50:12,240
you're making your code more complicated

00:50:10,480 --> 00:50:14,079
than it needs to be and

00:50:12,240 --> 00:50:17,680
use the compiler for help with that and

00:50:14,079 --> 00:50:21,200
also use the web resources

00:50:17,680 --> 00:50:23,520
uh let's see here jeff barcesky

00:50:21,200 --> 00:50:24,319
says will your async stream support back

00:50:23,520 --> 00:50:26,000
pressure

00:50:24,319 --> 00:50:27,839
that is something that we are talking

00:50:26,000 --> 00:50:29,599
about right now um

00:50:27,839 --> 00:50:32,160
the eight the i'm still working on the

00:50:29,599 --> 00:50:33,200
rfc uh in conjunction with the async

00:50:32,160 --> 00:50:36,319
working group

00:50:33,200 --> 00:50:37,680
so as the as the rfc is now remember

00:50:36,319 --> 00:50:39,359
this is still in early stages it has not

00:50:37,680 --> 00:50:41,440
been formally proposed yet

00:50:39,359 --> 00:50:43,760
i don't think we'll support it in the

00:50:41,440 --> 00:50:45,680
initial implementation

00:50:43,760 --> 00:50:47,359
but it is possible that could change

00:50:45,680 --> 00:50:50,160
before we open the rfc

00:50:47,359 --> 00:50:52,640
and even after the rfc is open based on

00:50:50,160 --> 00:50:54,720
the response of the community to it

00:50:52,640 --> 00:50:56,240
so stay tuned we are definitely talking

00:50:54,720 --> 00:50:58,000
about that

00:50:56,240 --> 00:50:59,359
and let's see here mike lesowski says

00:50:58,000 --> 00:51:00,800
have you read computer systems the

00:50:59,359 --> 00:51:02,000
programmer's perspective

00:51:00,800 --> 00:51:04,000
if not i would think it would be

00:51:02,000 --> 00:51:06,960
interesting for you i

00:51:04,000 --> 00:51:09,040
i i have not read that and that sounds

00:51:06,960 --> 00:51:11,040
fantastic so i will give that a read

00:51:09,040 --> 00:51:13,280
and if anyone else wants to form a book

00:51:11,040 --> 00:51:16,079
club or something over twitter or resume

00:51:13,280 --> 00:51:17,359
to read it let me know all right last

00:51:16,079 --> 00:51:20,559
question we have right now

00:51:17,359 --> 00:51:22,480
uh vote vote tech pollock

00:51:20,559 --> 00:51:24,960
says what do you think about verona from

00:51:22,480 --> 00:51:26,640
microsoft i'm not familiar with verona

00:51:24,960 --> 00:51:29,440
from microsoft so i will have to check

00:51:26,640 --> 00:51:33,520
that out and get back to you

00:51:29,440 --> 00:51:33,520
uh any other questions before we close

00:51:34,400 --> 00:51:38,559
all right uh so looks like that's all

00:51:37,119 --> 00:51:42,960
the questions

00:51:38,559 --> 00:51:46,000
so i am going to let's see here

00:51:42,960 --> 00:51:47,520
pick the most pick a question i pick the

00:51:46,000 --> 00:51:49,440
most interesting question these are all

00:51:47,520 --> 00:51:53,760
interesting this is hard

00:51:49,440 --> 00:51:53,760
to get that code for a manning book

00:51:54,010 --> 00:51:57,559
[Music]

00:51:58,480 --> 00:52:08,079
let's see here

00:52:04,000 --> 00:52:08,079
i'm going to go with

00:52:14,480 --> 00:52:20,400
uh guli haram souza ah let me put

00:52:18,319 --> 00:52:22,319
that name because i'm probably

00:52:20,400 --> 00:52:25,599
butchering it i apologize

00:52:22,319 --> 00:52:28,880
profusely uh in my chat with the

00:52:25,599 --> 00:52:32,960
uh uh organizers of

00:52:28,880 --> 00:52:36,079
rusty days all right well uh enjoy

00:52:32,960 --> 00:52:37,040
your i code from manning and thank you

00:52:36,079 --> 00:52:40,000
everyone so

00:52:37,040 --> 00:52:40,480
much for uh tuning in to my presentation

00:52:40,000 --> 00:52:44,160
and

00:52:40,480 --> 00:52:44,839
i am hoping to eventually see you all in

00:52:44,160 --> 00:52:47,839
person

00:52:44,839 --> 00:52:47,839

YouTube URL: https://www.youtube.com/watch?v=knhpe5IUnlE


