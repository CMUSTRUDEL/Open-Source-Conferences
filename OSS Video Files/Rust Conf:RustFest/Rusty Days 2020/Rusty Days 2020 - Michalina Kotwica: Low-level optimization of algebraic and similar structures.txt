Title: Rusty Days 2020 - Michalina Kotwica: Low-level optimization of algebraic and similar structures
Publication date: 2020-08-02
Playlist: Rusty Days 2020
Description: 
	Agenda ► https://rusty-days.org/agenda
Slides ►https://rusty-days.org/assets/slides/02-low-level-optimization-of-algebraic-and-similar-structures.pdf
Playlist with all talks ► https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ

Follow ►
Facebook: https://rusty-days.org/facebook
Twitch: https://rusty-days.org/twitch
Twitter: https://rusty-days.org/twitter

This video ►
While high-level advantages of functional programming and algebraic data structures in comparison to object-oriented programming are quite well known in the Rust community, numerous low-level advantages are not as commonly mentioned. While some programming languages use the functional approach as a means of optimization, Rust optimizes the very tools the functional paradigm is built upon.

In this talk, I want to present how Rust's approach to basic data structures (products/structs and coproducts/enums) is different from that of most functional programming languages. Further, I want to illustrate how low-level optimization is performed, which makes it possible, and what can be improved even further depending on how the language evolves.
Captions: 
	00:00:05,839 --> 00:00:11,040
hello my name is michelina catfisa

00:00:08,000 --> 00:00:13,360
and today i want to

00:00:11,040 --> 00:00:17,920
talk about low level optimization of

00:00:13,360 --> 00:00:17,920
algebraic and similar structures

00:00:19,119 --> 00:00:22,560
which is actually the reason for for me

00:00:22,080 --> 00:00:25,840
to

00:00:22,560 --> 00:00:29,439
present that is basically

00:00:25,840 --> 00:00:29,439
that that was my

00:00:29,519 --> 00:00:35,200
research topic for my master thesis um

00:00:33,040 --> 00:00:37,840
as you could have seen in the

00:00:35,200 --> 00:00:39,760
description of this speech

00:00:37,840 --> 00:00:42,399
uh i'm not a professional rust

00:00:39,760 --> 00:00:46,000
programmer i used to

00:00:42,399 --> 00:00:49,280
code in rust during my uh my time

00:00:46,000 --> 00:00:53,600
at intel poland but

00:00:49,280 --> 00:00:53,600
uh i i use rust

00:00:54,160 --> 00:01:00,640
as a hobby and for side projects for

00:00:57,520 --> 00:01:03,120
a few years now so i

00:01:00,640 --> 00:01:06,799
i hope that you will find my

00:01:03,120 --> 00:01:06,799
presentation interesting enough

00:01:09,040 --> 00:01:16,320
so um first i want to uh

00:01:12,960 --> 00:01:18,880
to tell you what what is the

00:01:16,320 --> 00:01:20,400
the plan for the presentation because i

00:01:18,880 --> 00:01:23,920
hate presentations without

00:01:20,400 --> 00:01:27,520
a decent plan so uh

00:01:23,920 --> 00:01:31,200
first i want to show you some

00:01:27,520 --> 00:01:35,200
math theory that i will use during the

00:01:31,200 --> 00:01:38,560
other points of the presentation

00:01:35,200 --> 00:01:39,680
then i will present you what is the unit

00:01:38,560 --> 00:01:43,759
time and

00:01:39,680 --> 00:01:46,159
type and never type so very special

00:01:43,759 --> 00:01:47,520
types that are more or less unique to

00:01:46,159 --> 00:01:50,320
rust

00:01:47,520 --> 00:01:52,079
and then some optimizations of

00:01:50,320 --> 00:01:54,720
structures

00:01:52,079 --> 00:01:56,399
then some optimizations of anoms then

00:01:54,720 --> 00:01:59,439
some code statistics that

00:01:56,399 --> 00:02:02,479
uh that i might uh

00:01:59,439 --> 00:02:03,759
that i gathered from open source

00:02:02,479 --> 00:02:06,640
repositories

00:02:03,759 --> 00:02:07,920
for uh you know checking some popular

00:02:06,640 --> 00:02:10,800
opinions about

00:02:07,920 --> 00:02:11,920
the stuff i'd be talking about and then

00:02:10,800 --> 00:02:15,440
something that

00:02:11,920 --> 00:02:16,400
is uh that i consider quite trendy

00:02:15,440 --> 00:02:19,840
nowadays in

00:02:16,400 --> 00:02:22,879
rest community uh futures or

00:02:19,840 --> 00:02:26,400
asynchronous execution

00:02:22,879 --> 00:02:29,760
if you prefer to put it that way so

00:02:26,400 --> 00:02:32,319
uh first um the

00:02:29,760 --> 00:02:34,160
the topic of the talk is algebraic

00:02:32,319 --> 00:02:37,360
structures but

00:02:34,160 --> 00:02:38,319
if you search for that phrase in the

00:02:37,360 --> 00:02:41,360
book

00:02:38,319 --> 00:02:42,160
then you will not find such a thing uh

00:02:41,360 --> 00:02:46,319
what you will

00:02:42,160 --> 00:02:48,480
find is uh chapters number five and six

00:02:46,319 --> 00:02:50,959
uh number five is for structures and

00:02:48,480 --> 00:02:55,280
number six is for animals

00:02:50,959 --> 00:02:58,319
uh so uh the the problem here

00:02:55,280 --> 00:03:01,599
or the the gorcha here

00:02:58,319 --> 00:03:03,519
is that the the way it's named is comes

00:03:01,599 --> 00:03:06,640
from the sea family

00:03:03,519 --> 00:03:09,840
while the algebraic structures is

00:03:06,640 --> 00:03:12,959
more of a functional programming way

00:03:09,840 --> 00:03:14,959
to put it so uh

00:03:12,959 --> 00:03:18,000
that's one of the differences and one of

00:03:14,959 --> 00:03:20,480
the reasons why it's not

00:03:18,000 --> 00:03:22,080
it's not that obvious what what's the

00:03:20,480 --> 00:03:23,280
meaning of the things i'll be talking

00:03:22,080 --> 00:03:26,959
about so

00:03:23,280 --> 00:03:30,879
uh first i want to show you

00:03:26,959 --> 00:03:34,480
the some maps of typed theory

00:03:30,879 --> 00:03:38,000
so algebraic structures have

00:03:34,480 --> 00:03:40,159
basically two uh key operators

00:03:38,000 --> 00:03:41,599
one is multiplication and one is

00:03:40,159 --> 00:03:44,239
addition

00:03:41,599 --> 00:03:45,280
so first if you have a point from the

00:03:44,239 --> 00:03:48,959
previous slide

00:03:45,280 --> 00:03:51,920
defined by x y and color

00:03:48,959 --> 00:03:53,920
then it's multiplication because uh if

00:03:51,920 --> 00:03:57,599
you take

00:03:53,920 --> 00:04:01,200
the number of values of that

00:03:57,599 --> 00:04:04,560
x field can take and why if it

00:04:01,200 --> 00:04:06,879
can take and color field can take

00:04:04,560 --> 00:04:09,200
then if you multiply them you get the

00:04:06,879 --> 00:04:10,640
total number of values that point can

00:04:09,200 --> 00:04:13,280
take

00:04:10,640 --> 00:04:14,879
and for event from the previous slide

00:04:13,280 --> 00:04:19,120
that takes

00:04:14,879 --> 00:04:22,320
one of three types of event it's uh

00:04:19,120 --> 00:04:24,479
it's uh summation because uh

00:04:22,320 --> 00:04:25,759
the quit variant that keep respond and

00:04:24,479 --> 00:04:28,880
click variant

00:04:25,759 --> 00:04:31,919
are separate so

00:04:28,880 --> 00:04:32,880
um it's not like for each variant of

00:04:31,919 --> 00:04:36,000
quit you have one

00:04:32,880 --> 00:04:39,600
variant of key press like in point

00:04:36,000 --> 00:04:42,639
uh but uh what is

00:04:39,600 --> 00:04:43,280
important here and that's why the the

00:04:42,639 --> 00:04:47,280
lower

00:04:43,280 --> 00:04:52,080
uh part of of this slide is slightly

00:04:47,280 --> 00:04:55,759
bigger than the upper one is that

00:04:52,080 --> 00:04:59,199
while for multiplication

00:04:55,759 --> 00:05:01,199
the set theory and type theory and

00:04:59,199 --> 00:05:03,120
and how it's coded in rust is basically

00:05:01,199 --> 00:05:05,120
all the same

00:05:03,120 --> 00:05:06,240
and for events it's a little bit

00:05:05,120 --> 00:05:09,360
different

00:05:06,240 --> 00:05:12,639
because for sets it's not just

00:05:09,360 --> 00:05:16,000
summation it's it's a

00:05:12,639 --> 00:05:19,680
special type addition that

00:05:16,000 --> 00:05:22,560
preserves the source of

00:05:19,680 --> 00:05:23,120
of the value so if you have two variants

00:05:22,560 --> 00:05:25,199
that

00:05:23,120 --> 00:05:26,880
have no value then they are

00:05:25,199 --> 00:05:29,600
differentiable

00:05:26,880 --> 00:05:30,800
uh that takes single value or for

00:05:29,600 --> 00:05:34,639
example if you have

00:05:30,800 --> 00:05:38,400
two variants that each have an integer

00:05:34,639 --> 00:05:41,520
so these are the basics uh

00:05:38,400 --> 00:05:44,479
and the reason why i'm showing you this

00:05:41,520 --> 00:05:47,360
is that if you have multiplication then

00:05:44,479 --> 00:05:47,360
you must have

00:05:47,520 --> 00:05:55,600
a single unit so it's the analog of

00:05:52,320 --> 00:05:56,479
number one while in addition you must

00:05:55,600 --> 00:05:59,919
have the

00:05:56,479 --> 00:06:04,080
analog of number zero so neutral

00:05:59,919 --> 00:06:04,080
elements of this operation you might say

00:06:04,240 --> 00:06:09,840
so for uh for multiplication it's

00:06:07,919 --> 00:06:11,360
obviously one because everything

00:06:09,840 --> 00:06:14,319
multiplied by one

00:06:11,360 --> 00:06:16,240
is the same number and it's pretty much

00:06:14,319 --> 00:06:20,319
the same in rest

00:06:16,240 --> 00:06:24,240
uh so you can have a structure with

00:06:20,319 --> 00:06:27,280
which has only uh which has zero

00:06:24,240 --> 00:06:30,479
fields so it only has one value

00:06:27,280 --> 00:06:33,199
is the value and

00:06:30,479 --> 00:06:35,759
and the most popular way of expressing

00:06:33,199 --> 00:06:38,800
that is an empty tuple because

00:06:35,759 --> 00:06:41,199
there is only one empty tuple you cannot

00:06:38,800 --> 00:06:45,360
parameterize it by anything

00:06:41,199 --> 00:06:45,360
and the most used

00:06:46,240 --> 00:06:51,680
and the empty table is the most used as

00:06:48,720 --> 00:06:55,120
the return type of the main method

00:06:51,680 --> 00:06:58,080
uh however it's also

00:06:55,120 --> 00:07:00,720
pretty useful for generics because you

00:06:58,080 --> 00:07:04,880
can parameterize

00:07:00,720 --> 00:07:08,000
generics using empty tuple to show that

00:07:04,880 --> 00:07:11,440
there the information of some variant of

00:07:08,000 --> 00:07:14,639
an anom is important

00:07:11,440 --> 00:07:17,759
but it carries no additional information

00:07:14,639 --> 00:07:21,199
and one of the examples is result

00:07:17,759 --> 00:07:24,319
with with zero empty tuple

00:07:21,199 --> 00:07:27,440
as the error type as you can see here

00:07:24,319 --> 00:07:30,240
uh the reason why i'm showing you

00:07:27,440 --> 00:07:31,120
what it translates to if monomorphized

00:07:30,240 --> 00:07:35,360
so

00:07:31,120 --> 00:07:39,599
if getting rid of the generic arguments

00:07:35,360 --> 00:07:43,440
is because for the empty tuple it's

00:07:39,599 --> 00:07:44,879
mostly obvious it's not so much when we

00:07:43,440 --> 00:07:48,560
get to the analog of

00:07:44,879 --> 00:07:49,599
zero but what uh what is important here

00:07:48,560 --> 00:07:53,360
is that

00:07:49,599 --> 00:07:53,919
uh rust has uh has the way of dealing

00:07:53,360 --> 00:07:57,280
with

00:07:53,919 --> 00:07:58,960
empty tuple quite quite different from

00:07:57,280 --> 00:08:00,479
other languages from the c family

00:07:58,960 --> 00:08:02,479
because the uh

00:08:00,479 --> 00:08:04,080
the size of the empty tuple is actually

00:08:02,479 --> 00:08:07,520
zero so

00:08:04,080 --> 00:08:09,759
be aware that if you create an generic

00:08:07,520 --> 00:08:12,639
type which doesn't handle well

00:08:09,759 --> 00:08:13,919
types that carry zero bytes of

00:08:12,639 --> 00:08:17,039
information

00:08:13,919 --> 00:08:19,120
you might get into trouble so

00:08:17,039 --> 00:08:21,840
remember that you actually can create a

00:08:19,120 --> 00:08:24,160
vector of empty tuples

00:08:21,840 --> 00:08:25,199
so a hundred of empty tables is still

00:08:24,160 --> 00:08:27,840
the same size as

00:08:25,199 --> 00:08:27,840
empty table

00:08:28,400 --> 00:08:35,519
where which is quite useful often

00:08:31,759 --> 00:08:37,760
but i what i found even more useful

00:08:35,519 --> 00:08:38,880
is the analog of zero which is never

00:08:37,760 --> 00:08:42,240
type

00:08:38,880 --> 00:08:44,959
or exclamation mark

00:08:42,240 --> 00:08:46,080
if you want to be graphic or infallible

00:08:44,959 --> 00:08:49,680
type

00:08:46,080 --> 00:08:53,040
if you want to stay on stable rest

00:08:49,680 --> 00:08:56,640
uh it's i think most known

00:08:53,040 --> 00:09:00,000
for results which

00:08:56,640 --> 00:09:03,680
which do not carry any error variant

00:09:00,000 --> 00:09:06,080
but it's also used for expressing

00:09:03,680 --> 00:09:08,800
that the function never returns since

00:09:06,080 --> 00:09:12,320
the name

00:09:08,800 --> 00:09:14,959
for results it's actually a little bit

00:09:12,320 --> 00:09:18,640
tricky because it actually deletes

00:09:14,959 --> 00:09:19,760
the the whole variant that it occupies

00:09:18,640 --> 00:09:22,640
so the result

00:09:19,760 --> 00:09:24,560
that has never assets error type

00:09:22,640 --> 00:09:27,200
actually never errors so

00:09:24,560 --> 00:09:29,440
you do not even have the error variant

00:09:27,200 --> 00:09:32,240
so the whole enum is just a

00:09:29,440 --> 00:09:33,040
single value and it only has a single

00:09:32,240 --> 00:09:36,000
variable so

00:09:33,040 --> 00:09:37,440
you can even pattern match it to the

00:09:36,000 --> 00:09:40,640
okay variant

00:09:37,440 --> 00:09:45,680
as you can see below for uh

00:09:40,640 --> 00:09:48,839
for from str trade

00:09:45,680 --> 00:09:50,080
uh what is quite interesting here is

00:09:48,839 --> 00:09:53,760
that

00:09:50,080 --> 00:09:55,920
the never type that

00:09:53,760 --> 00:09:57,279
is lacking in language in other

00:09:55,920 --> 00:10:00,640
languages like simplest

00:09:57,279 --> 00:10:04,720
or java makes it possible to

00:10:00,640 --> 00:10:06,240
compose not only compose the algebraic

00:10:04,720 --> 00:10:10,640
data structures

00:10:06,240 --> 00:10:13,040
but also discard parts of them without

00:10:10,640 --> 00:10:14,800
suffering runtime codes because as you

00:10:13,040 --> 00:10:18,720
can see here

00:10:14,800 --> 00:10:20,399
we do have uh the our

00:10:18,720 --> 00:10:22,079
result of computation packed in the

00:10:20,399 --> 00:10:25,279
results structure

00:10:22,079 --> 00:10:28,240
and still it only occupi occupies

00:10:25,279 --> 00:10:29,120
the bytes needed to actually store the t

00:10:28,240 --> 00:10:31,760
type

00:10:29,120 --> 00:10:32,880
without sacrificing any performance on

00:10:31,760 --> 00:10:35,680
memory

00:10:32,880 --> 00:10:37,920
for the error variant because it's never

00:10:35,680 --> 00:10:37,920
there

00:10:38,720 --> 00:10:47,120
for the for the multiplication

00:10:41,920 --> 00:10:49,440
aside from the unit type there is that

00:10:47,120 --> 00:10:51,519
one optimization or one major

00:10:49,440 --> 00:10:54,399
optimization i'd say

00:10:51,519 --> 00:10:56,160
uh that is also lacking in c and c plus

00:10:54,399 --> 00:10:59,010
plus and the reason for that

00:10:56,160 --> 00:11:00,480
is that uh c and c plus plus are

00:10:59,010 --> 00:11:03,760
[Music]

00:11:00,480 --> 00:11:07,360
very heavily relying on abis

00:11:03,760 --> 00:11:08,640
meaning uh it is important for c and c

00:11:07,360 --> 00:11:12,079
plus plus how

00:11:08,640 --> 00:11:15,279
exactly the bytes of some structure

00:11:12,079 --> 00:11:18,720
are layer laid in memory well

00:11:15,279 --> 00:11:20,399
in rest data structures are a little

00:11:18,720 --> 00:11:24,160
more abstract

00:11:20,399 --> 00:11:27,680
so in this particular

00:11:24,160 --> 00:11:30,399
method of we optimization

00:11:27,680 --> 00:11:32,079
the fields around so that they occupy

00:11:30,399 --> 00:11:35,760
less space

00:11:32,079 --> 00:11:39,760
so as you can see uh in c

00:11:35,760 --> 00:11:42,000
the the order of the

00:11:39,760 --> 00:11:42,959
fields in the memory layout is exactly

00:11:42,000 --> 00:11:46,480
the same

00:11:42,959 --> 00:11:49,200
as as the one in the declaration

00:11:46,480 --> 00:11:50,880
which you can say which you can check by

00:11:49,200 --> 00:11:54,079
your

00:11:50,880 --> 00:11:57,120
not use your wrap c then

00:11:54,079 --> 00:12:00,480
you can see that the the

00:11:57,120 --> 00:12:03,680
rust structures don't really care

00:12:00,480 --> 00:12:07,519
about the order you declare your fields

00:12:03,680 --> 00:12:10,800
in what is

00:12:07,519 --> 00:12:14,079
quite important though it does

00:12:10,800 --> 00:12:17,519
not work if you use

00:12:14,079 --> 00:12:21,200
nested structures so if you use

00:12:17,519 --> 00:12:24,240
anything like a tuple of substructure

00:12:21,200 --> 00:12:26,399
a structure as a field and it's disabled

00:12:24,240 --> 00:12:27,360
and the reason for that is pretty much

00:12:26,399 --> 00:12:30,160
the same as

00:12:27,360 --> 00:12:31,440
the reason for lack of multiple

00:12:30,160 --> 00:12:34,880
optimization in c

00:12:31,440 --> 00:12:38,160
plus because of the language rules

00:12:34,880 --> 00:12:40,160
so if we want to take a reference to the

00:12:38,160 --> 00:12:43,440
seed tuple

00:12:40,160 --> 00:12:45,519
it needs to have the same memory layout

00:12:43,440 --> 00:12:47,200
like and the other regular tuple in the

00:12:45,519 --> 00:12:51,920
memory

00:12:47,200 --> 00:12:52,480
so it has to occupy the same bytes and

00:12:51,920 --> 00:12:55,200
therefore

00:12:52,480 --> 00:12:56,959
we can't just separate its fields and

00:12:55,200 --> 00:12:59,839
because of that

00:12:56,959 --> 00:12:59,839
rust can get

00:13:00,000 --> 00:13:06,880
the same memory layout to see if using

00:13:03,600 --> 00:13:08,240
nested nested fields or nested

00:13:06,880 --> 00:13:12,079
structures

00:13:08,240 --> 00:13:15,120
but otherwise

00:13:12,079 --> 00:13:19,600
it will try to reorder the fields

00:13:15,120 --> 00:13:22,079
in the most compressed way possible

00:13:19,600 --> 00:13:24,480
and there is even a special fragment to

00:13:22,079 --> 00:13:28,399
ensure this

00:13:24,480 --> 00:13:31,680
uh for coproducts or anoms we have

00:13:28,399 --> 00:13:35,279
even more optimizations the

00:13:31,680 --> 00:13:39,839
i think most useful ones

00:13:35,279 --> 00:13:43,040
on a daily basis is the optimization of

00:13:39,839 --> 00:13:45,680
boolean not non-new pointers and

00:13:43,040 --> 00:13:45,680
non-zero

00:13:46,839 --> 00:13:51,519
numbers

00:13:48,079 --> 00:13:52,720
which is quite similar to how things are

00:13:51,519 --> 00:13:55,760
all

00:13:52,720 --> 00:13:59,600
pretty often handled in

00:13:55,760 --> 00:14:02,639
c so if you have a pointer

00:13:59,600 --> 00:14:05,760
and you do know that it's not null

00:14:02,639 --> 00:14:09,839
you pretty often will treat new

00:14:05,760 --> 00:14:13,360
as an invalid value uh

00:14:09,839 --> 00:14:16,880
or uh to signal

00:14:13,360 --> 00:14:20,079
the user or developer that

00:14:16,880 --> 00:14:23,519
this pointer hasn't been set at all

00:14:20,079 --> 00:14:24,560
and in the last of course the analog of

00:14:23,519 --> 00:14:28,720
that

00:14:24,560 --> 00:14:32,079
is an option type and just like

00:14:28,720 --> 00:14:33,680
you would do in c the non-variant of the

00:14:32,079 --> 00:14:36,320
option is occupied by the

00:14:33,680 --> 00:14:38,320
null pointer because you then low

00:14:36,320 --> 00:14:41,960
pointer isn't a valid value

00:14:38,320 --> 00:14:43,120
for let's say a box or a reference

00:14:41,960 --> 00:14:45,760
[Music]

00:14:43,120 --> 00:14:48,240
which is not the case with just an usual

00:14:45,760 --> 00:14:48,240
pointer

00:14:48,720 --> 00:14:52,880
uh and just like with pointers that do

00:14:51,839 --> 00:14:56,959
not have the

00:14:52,880 --> 00:15:00,000
null value we do have

00:14:56,959 --> 00:15:05,360
numbers like your size for example

00:15:00,000 --> 00:15:08,639
that uh treat zero as invalid value

00:15:05,360 --> 00:15:09,760
which makes it work pretty much like

00:15:08,639 --> 00:15:13,760
with pointers

00:15:09,760 --> 00:15:17,279
considering that's is pretty much always

00:15:13,760 --> 00:15:20,000
binary zero uh with boolean

00:15:17,279 --> 00:15:21,120
the it's a little bit different because

00:15:20,000 --> 00:15:24,160
uh

00:15:21,120 --> 00:15:27,680
false and rule usually map for

00:15:24,160 --> 00:15:31,199
zero and one but because of that

00:15:27,680 --> 00:15:33,519
two or three are still uh

00:15:31,199 --> 00:15:35,440
are still there to be used so the

00:15:33,519 --> 00:15:39,279
non-variant is

00:15:35,440 --> 00:15:43,040
uh equal to binary two but either way

00:15:39,279 --> 00:15:46,639
it's the size is

00:15:43,040 --> 00:15:50,639
reduced by the

00:15:46,639 --> 00:15:54,639
um by that optimization uh you may

00:15:50,639 --> 00:15:57,519
wonder what the dots here mean the

00:15:54,639 --> 00:15:58,199
on this slide the dots are there because

00:15:57,519 --> 00:16:01,759
in the c

00:15:58,199 --> 00:16:06,560
representation each part of

00:16:01,759 --> 00:16:10,160
of that layout states it takes a

00:16:06,560 --> 00:16:13,440
full 32 bytes i think

00:16:10,160 --> 00:16:16,560
32 bits i think yeah and

00:16:13,440 --> 00:16:19,519
in rust it's it's a little more a bit

00:16:16,560 --> 00:16:19,519
more compressed

00:16:21,360 --> 00:16:24,720
uh another optimism optimization which

00:16:23,920 --> 00:16:28,480
may prove

00:16:24,720 --> 00:16:31,519
useful to you in day-to-day life

00:16:28,480 --> 00:16:35,519
uh is product flattening

00:16:31,519 --> 00:16:39,360
which means uh if you have an option

00:16:35,519 --> 00:16:39,839
then the memory layout is pretty obvious

00:16:39,360 --> 00:16:44,160
because

00:16:39,839 --> 00:16:47,040
uh if it's not a null pointer

00:16:44,160 --> 00:16:48,000
or a zero value of the non-zero type or

00:16:47,040 --> 00:16:51,040
a boolean

00:16:48,000 --> 00:16:54,399
but it's just let's say a

00:16:51,040 --> 00:16:56,800
byte value then obviously uh you do need

00:16:54,399 --> 00:16:59,120
to store the information on whenever the

00:16:56,800 --> 00:17:02,800
value is valid or not

00:16:59,120 --> 00:17:03,199
so you do have uh the part for the data

00:17:02,800 --> 00:17:05,520
and

00:17:03,199 --> 00:17:07,039
part for the so-called discriminator

00:17:05,520 --> 00:17:11,280
which discriminates

00:17:07,039 --> 00:17:11,280
which variant of the anom you're at

00:17:11,839 --> 00:17:18,079
and in theory if you have

00:17:14,959 --> 00:17:20,400
a an animal of an anum so for example a

00:17:18,079 --> 00:17:23,520
result of an option or an option over

00:17:20,400 --> 00:17:25,839
option then you should get

00:17:23,520 --> 00:17:28,079
another discriminator for the outer

00:17:25,839 --> 00:17:31,679
layer

00:17:28,079 --> 00:17:32,000
but in practice for for simple cases

00:17:31,679 --> 00:17:35,039
rust

00:17:32,000 --> 00:17:37,360
will flatten the discriminator so

00:17:35,039 --> 00:17:38,720
for instance if you have an option of an

00:17:37,360 --> 00:17:40,559
option

00:17:38,720 --> 00:17:42,480
then it will be flattened into a single

00:17:40,559 --> 00:17:45,760
discriminator

00:17:42,480 --> 00:17:49,520
that treats some of some

00:17:45,760 --> 00:17:54,080
and some of none and none as three

00:17:49,520 --> 00:17:54,080
possible variants of the new animal

00:17:54,240 --> 00:18:02,000
which saves quite a lot of space

00:17:57,360 --> 00:18:05,679
if you have multiple layers of that

00:18:02,000 --> 00:18:10,000
and especially many layers

00:18:05,679 --> 00:18:10,000
if you have only

00:18:10,240 --> 00:18:14,960
if you consider how many enums of the

00:18:13,200 --> 00:18:18,720
kind of option and

00:18:14,960 --> 00:18:22,080
result of unit and async etc

00:18:18,720 --> 00:18:24,799
you can stack together but

00:18:22,080 --> 00:18:28,240
as i mentioned it's only for for simple

00:18:24,799 --> 00:18:28,640
atoms and what i mean by simple is atoms

00:18:28,240 --> 00:18:33,039
that

00:18:28,640 --> 00:18:36,720
have at most one field that

00:18:33,039 --> 00:18:36,720
that holds any information

00:18:37,039 --> 00:18:40,960
more than just what variant it is so in

00:18:40,000 --> 00:18:43,679
practice it's mean

00:18:40,960 --> 00:18:44,559
it looks like an option so for example

00:18:43,679 --> 00:18:48,160
it could be

00:18:44,559 --> 00:18:51,840
and a result with the error type of

00:18:48,160 --> 00:18:54,960
unit or

00:18:51,840 --> 00:18:56,320
anything similar to that so as you can

00:18:54,960 --> 00:18:59,360
see here

00:18:56,320 --> 00:18:59,760
if the if we use a result with error

00:18:59,360 --> 00:19:04,160
type

00:18:59,760 --> 00:19:07,679
of let's say a byte or an integer then

00:19:04,160 --> 00:19:10,640
the optimization is disabled sadly uh

00:19:07,679 --> 00:19:10,960
well it could be applied but it wouldn't

00:19:10,640 --> 00:19:14,160
be

00:19:10,960 --> 00:19:18,400
so trivial and therefore

00:19:14,160 --> 00:19:21,919
it it should be discussed how

00:19:18,400 --> 00:19:21,919
it should be done

00:19:22,880 --> 00:19:30,080
uh to show you why

00:19:26,720 --> 00:19:33,600
that optimization is

00:19:30,080 --> 00:19:34,400
a real deal a real feature and not just

00:19:33,600 --> 00:19:37,039
some

00:19:34,400 --> 00:19:39,840
minor stuff i i want to show you some

00:19:37,039 --> 00:19:43,280
statistics that i gathered

00:19:39,840 --> 00:19:46,480
by scanning code of some open source

00:19:43,280 --> 00:19:49,520
repositories so i took

00:19:46,480 --> 00:19:52,559
some some standard truss

00:19:49,520 --> 00:19:57,039
repositories so last c compiler

00:19:52,559 --> 00:20:01,200
sir the tokyo regex

00:19:57,039 --> 00:20:04,480
my own master this is google google apis

00:20:01,200 --> 00:20:06,720
and logger library gathering

00:20:04,480 --> 00:20:08,480
more than one thousand of unknown

00:20:06,720 --> 00:20:12,559
declarations

00:20:08,480 --> 00:20:12,559
and here is what i found uh

00:20:13,200 --> 00:20:17,760
most of annums are

00:20:18,159 --> 00:20:26,480
two three four maybe five

00:20:22,799 --> 00:20:29,919
uh variants they have

00:20:26,480 --> 00:20:33,360
uh some of them have one or zero

00:20:29,919 --> 00:20:36,400
and no there aren't

00:20:33,360 --> 00:20:37,600
that many of them that have more than

00:20:36,400 --> 00:20:40,880
five variants

00:20:37,600 --> 00:20:44,320
it's pretty rare uh

00:20:40,880 --> 00:20:46,159
and if they do they mostly do not carry

00:20:44,320 --> 00:20:49,679
any data

00:20:46,159 --> 00:20:50,480
other than the information about which

00:20:49,679 --> 00:20:53,840
variant

00:20:50,480 --> 00:20:57,760
it is and uh

00:20:53,840 --> 00:21:01,039
it made me wonder okay so i have two

00:20:57,760 --> 00:21:03,679
three four variants but

00:21:01,039 --> 00:21:05,919
it doesn't mean that i only have one

00:21:03,679 --> 00:21:09,520
field on them or zero fields on them

00:21:05,919 --> 00:21:11,360
so what i checked is

00:21:09,520 --> 00:21:13,280
uh the maximum number of fields

00:21:11,360 --> 00:21:16,400
invariants

00:21:13,280 --> 00:21:19,120
and that result was even

00:21:16,400 --> 00:21:21,840
even more interesting for me because

00:21:19,120 --> 00:21:25,200
over 40 percent of them

00:21:21,840 --> 00:21:27,039
had zero fields at all so they were

00:21:25,200 --> 00:21:30,640
enums in the classical

00:21:27,039 --> 00:21:34,799
seasons and

00:21:30,640 --> 00:21:38,559
about one in one third of them

00:21:34,799 --> 00:21:40,880
had at most one field so

00:21:38,559 --> 00:21:43,280
a variant that is basically a wrapper

00:21:40,880 --> 00:21:46,080
for another type

00:21:43,280 --> 00:21:46,559
which makes sense if you think about it

00:21:46,080 --> 00:21:51,520
and

00:21:46,559 --> 00:21:54,480
then it's less than 15 percent of

00:21:51,520 --> 00:21:56,080
atoms that have two fields or more in

00:21:54,480 --> 00:21:59,120
any variant

00:21:56,080 --> 00:22:02,799
so uh

00:21:59,120 --> 00:22:07,760
that that alone so

00:22:02,799 --> 00:22:10,320
shows that that optimization may

00:22:07,760 --> 00:22:11,840
may be nice considering that it works

00:22:10,320 --> 00:22:15,520
for

00:22:11,840 --> 00:22:18,400
it works for atoms that have

00:22:15,520 --> 00:22:18,880
zero or one fields at most and if they

00:22:18,400 --> 00:22:24,080
have

00:22:18,880 --> 00:22:24,080
one field then only in one variant so

00:22:24,559 --> 00:22:30,720
i checked okay but if

00:22:27,679 --> 00:22:33,919
the maximal number of

00:22:30,720 --> 00:22:35,120
fields is one then what is the minimal

00:22:33,919 --> 00:22:38,840
number of fields

00:22:35,120 --> 00:22:41,360
or what is the number of fields that are

00:22:38,840 --> 00:22:45,360
non-zero

00:22:41,360 --> 00:22:45,360
and it turned out that

00:22:45,760 --> 00:22:54,159
in most cases if you if we have

00:22:49,600 --> 00:22:55,440
an anom with one field at most then in

00:22:54,159 --> 00:22:58,799
most cases

00:22:55,440 --> 00:23:01,760
both variants do carry a value so that

00:22:58,799 --> 00:23:03,360
images optimization doesn't apply but

00:23:01,760 --> 00:23:07,120
it's over 15 percent

00:23:03,360 --> 00:23:10,240
when it does so as i said the

00:23:07,120 --> 00:23:13,200
numbers that look like an option are

00:23:10,240 --> 00:23:14,159
pretty widespread actually because one

00:23:13,200 --> 00:23:17,440
in a

00:23:14,159 --> 00:23:21,039
in six random declarations

00:23:17,440 --> 00:23:24,880
uh are of that kind and they can flatten

00:23:21,039 --> 00:23:28,000
so if you ever

00:23:24,880 --> 00:23:31,200
saw a an anum that

00:23:28,000 --> 00:23:34,960
has multiple layers

00:23:31,200 --> 00:23:38,720
of other animals inside of it

00:23:34,960 --> 00:23:41,360
in in its monomorphization it

00:23:38,720 --> 00:23:42,480
there is a pretty pretty big change it

00:23:41,360 --> 00:23:44,720
will be flattened

00:23:42,480 --> 00:23:47,279
and therefore you will save both memory

00:23:44,720 --> 00:23:50,559
and performance

00:23:47,279 --> 00:23:53,840
uh and uh

00:23:50,559 --> 00:23:55,440
the third thing that's that i wanted to

00:23:53,840 --> 00:23:58,559
show you

00:23:55,440 --> 00:24:02,559
that is also um

00:23:58,559 --> 00:24:06,960
let's say um it's also connected to

00:24:02,559 --> 00:24:10,240
algebraic structures are

00:24:06,960 --> 00:24:14,000
futures and

00:24:10,240 --> 00:24:17,840
you know it's it's not that that

00:24:14,000 --> 00:24:20,400
that obvious to see because uh

00:24:17,840 --> 00:24:21,360
and structures are the dictionary

00:24:20,400 --> 00:24:24,480
definitions of

00:24:21,360 --> 00:24:27,520
product and co-product from type algebra

00:24:24,480 --> 00:24:30,960
while futures are that

00:24:27,520 --> 00:24:35,760
abstract thing that is defined by

00:24:30,960 --> 00:24:39,200
what it does it's a trait right

00:24:35,760 --> 00:24:40,960
but considering how it's implemented in

00:24:39,200 --> 00:24:42,960
rust both

00:24:40,960 --> 00:24:44,799
futures and iterators are actually

00:24:42,960 --> 00:24:48,559
implemented as animals

00:24:44,799 --> 00:24:51,520
so if if you ever implemented

00:24:48,559 --> 00:24:53,600
a future on your own then you probably

00:24:51,520 --> 00:24:56,640
do know it

00:24:53,600 --> 00:24:59,679
so if you take some imperative

00:24:56,640 --> 00:25:02,799
code that uses the new async

00:24:59,679 --> 00:25:02,799
await syntax

00:25:02,880 --> 00:25:07,760
it actually gets compiled to

00:25:07,840 --> 00:25:11,360
something that i wouldn't call an

00:25:09,870 --> 00:25:14,480
[Music]

00:25:11,360 --> 00:25:17,120
algebraic structure per se

00:25:14,480 --> 00:25:20,320
that's why in the title of my

00:25:17,120 --> 00:25:23,440
presentation i called it

00:25:20,320 --> 00:25:26,640
similar to algebraic structure

00:25:23,440 --> 00:25:26,640
and here is why

00:25:27,120 --> 00:25:33,440
well i can show you

00:25:30,320 --> 00:25:36,559
the end of representation of what it uh

00:25:33,440 --> 00:25:40,720
what the above code compiles to

00:25:36,559 --> 00:25:44,640
uh which is the block future here

00:25:40,720 --> 00:25:48,080
it's not entirely true what i

00:25:44,640 --> 00:25:48,559
show you here because um you see if you

00:25:48,080 --> 00:25:51,679
take

00:25:48,559 --> 00:25:56,400
uh just any normal anim

00:25:51,679 --> 00:25:59,760
then if i go from the answer stage

00:25:56,400 --> 00:26:01,279
which is when i enter the future and go

00:25:59,760 --> 00:26:04,559
to the signal next

00:26:01,279 --> 00:26:07,200
stage when i wait for the next signals

00:26:04,559 --> 00:26:11,120
to arrive

00:26:07,200 --> 00:26:13,679
then i should move the signals

00:26:11,120 --> 00:26:15,360
from from the block future and then

00:26:13,679 --> 00:26:19,120
create a new block feature

00:26:15,360 --> 00:26:21,679
of another variant and move the signals

00:26:19,120 --> 00:26:21,679
back there

00:26:22,640 --> 00:26:27,039
and here is the problem it's uh it's a

00:26:25,200 --> 00:26:29,360
nonsense because

00:26:27,039 --> 00:26:30,240
you move the memory around for nothing

00:26:29,360 --> 00:26:33,520
because

00:26:30,240 --> 00:26:34,480
we statically know that it will be moved

00:26:33,520 --> 00:26:37,679
back

00:26:34,480 --> 00:26:38,000
or at least it can be moved back and in

00:26:37,679 --> 00:26:41,440
this

00:26:38,000 --> 00:26:43,600
case uh it's especially silly

00:26:41,440 --> 00:26:46,960
considering that

00:26:43,600 --> 00:26:51,440
the from here from the awaiting

00:26:46,960 --> 00:26:54,880
to that for the next signal we go to

00:26:51,440 --> 00:26:58,880
sending the data of that signal to

00:26:54,880 --> 00:27:03,360
some target and then

00:26:58,880 --> 00:27:05,760
we go to the signals again so we would

00:27:03,360 --> 00:27:07,200
move the memory around for no reason

00:27:05,760 --> 00:27:10,880
inside of a loop

00:27:07,200 --> 00:27:14,080
which is even worse and

00:27:10,880 --> 00:27:18,640
because it's so much against the rust

00:27:14,080 --> 00:27:22,240
zero cost motto

00:27:18,640 --> 00:27:24,399
it's not actually implemented that way

00:27:22,240 --> 00:27:25,600
what could be done is of course

00:27:24,399 --> 00:27:28,880
implementing

00:27:25,600 --> 00:27:32,320
the block structure as a structure is

00:27:28,880 --> 00:27:35,200
instead of an atom and

00:27:32,320 --> 00:27:37,039
in this particular case it would be a

00:27:35,200 --> 00:27:40,799
good idea probably

00:27:37,039 --> 00:27:43,679
because we use signals all the time and

00:27:40,799 --> 00:27:45,120
the only things that would reuse the

00:27:43,679 --> 00:27:48,640
memory are the

00:27:45,120 --> 00:27:51,840
id and data and and error

00:27:48,640 --> 00:27:56,000
is probably not that big

00:27:51,840 --> 00:27:59,919
but in other cases well it bloats up

00:27:56,000 --> 00:28:03,679
to potentially enormous

00:27:59,919 --> 00:28:05,919
sizes so the problem here is

00:28:03,679 --> 00:28:08,720
it's not really obvious what is

00:28:05,919 --> 00:28:12,320
optimization because optimization

00:28:08,720 --> 00:28:15,760
should have a criterion

00:28:12,320 --> 00:28:17,360
and on one hand we have a structural

00:28:15,760 --> 00:28:19,360
representation

00:28:17,360 --> 00:28:20,399
which bloats the size but boosts the

00:28:19,360 --> 00:28:22,320
speed

00:28:20,399 --> 00:28:26,159
and on another we have anal group

00:28:22,320 --> 00:28:26,159
presentation which puts the speed

00:28:26,240 --> 00:28:31,360
which boosts the size but blows the

00:28:28,840 --> 00:28:33,679
speed

00:28:31,360 --> 00:28:35,520
so the solution here is to use something

00:28:33,679 --> 00:28:39,279
that is

00:28:35,520 --> 00:28:42,240
similar to both in a way

00:28:39,279 --> 00:28:42,240
so we

00:28:43,600 --> 00:28:48,320
check which fields are available at

00:28:46,080 --> 00:28:52,000
which stage

00:28:48,320 --> 00:28:54,720
of the future execution make it

00:28:52,000 --> 00:28:55,840
a table or any graphic representation

00:28:54,720 --> 00:28:58,799
you want

00:28:55,840 --> 00:29:00,640
and check which fields are used at the

00:28:58,799 --> 00:29:03,039
same time

00:29:00,640 --> 00:29:04,080
and if they are not never used at the

00:29:03,039 --> 00:29:08,000
same time

00:29:04,080 --> 00:29:10,720
then they can reoccupy the same space

00:29:08,000 --> 00:29:10,720
just like here

00:29:11,120 --> 00:29:20,240
in this example if we have

00:29:14,960 --> 00:29:23,840
some bounds or indexes in a vector

00:29:20,240 --> 00:29:26,559
and an iterator based on them

00:29:23,840 --> 00:29:27,679
and the iterator isn't available on the

00:29:26,559 --> 00:29:30,080
same stage

00:29:27,679 --> 00:29:31,919
of the future execution as the indexes

00:29:30,080 --> 00:29:34,000
probably

00:29:31,919 --> 00:29:35,200
so it can reoccupy the space and

00:29:34,000 --> 00:29:38,399
conveniently

00:29:35,200 --> 00:29:42,640
because the iterator

00:29:38,399 --> 00:29:45,840
over a vector is just twice the size of

00:29:42,640 --> 00:29:48,399
an index then in reoccupies space

00:29:45,840 --> 00:29:51,760
perfectly

00:29:48,399 --> 00:29:54,960
so now we have the size of the

00:29:51,760 --> 00:29:58,480
future cut by

00:29:54,960 --> 00:30:01,520
one third which is uh

00:29:58,480 --> 00:30:04,000
quite nice but it doesn't really show

00:30:01,520 --> 00:30:05,600
the true power of this optimization

00:30:04,000 --> 00:30:09,360
considering that many

00:30:05,600 --> 00:30:14,399
futures used to be

00:30:09,360 --> 00:30:17,600
kilobytes in size

00:30:14,399 --> 00:30:21,360
before turning on this optimization

00:30:17,600 --> 00:30:23,360
and as you can see this optimization of

00:30:21,360 --> 00:30:28,399
futures

00:30:23,360 --> 00:30:31,919
which i called co-products on steroids

00:30:28,399 --> 00:30:35,200
is a somewhat

00:30:31,919 --> 00:30:35,760
a combination of the filter ordering

00:30:35,200 --> 00:30:38,480
because

00:30:35,760 --> 00:30:40,799
we are definitely reordering the fields

00:30:38,480 --> 00:30:40,799
here

00:30:41,120 --> 00:30:47,919
and the

00:30:44,159 --> 00:30:51,039
product optimization because we do a

00:30:47,919 --> 00:30:55,039
similar trick to what we did

00:30:51,039 --> 00:30:55,039
with not new pointers

00:31:01,279 --> 00:31:11,440
any questions or

00:31:05,039 --> 00:31:11,440
remarks for that part of presentation

00:31:14,559 --> 00:31:22,559
i as as i as i said

00:31:18,080 --> 00:31:26,159
uh the rest is pretty

00:31:22,559 --> 00:31:29,679
unique and uh

00:31:26,159 --> 00:31:32,720
in the low level optimization topic

00:31:29,679 --> 00:31:36,480
because uh

00:31:32,720 --> 00:31:38,320
because the optimization are enabled by

00:31:36,480 --> 00:31:40,480
the language just like they are

00:31:38,320 --> 00:31:40,960
prevented by languages like c and c plus

00:31:40,480 --> 00:31:44,840
plus

00:31:40,960 --> 00:31:48,399
and not really needed in languages like

00:31:44,840 --> 00:31:48,399
haskell and it's

00:31:48,799 --> 00:31:55,039
the best example of that that i know is

00:31:51,279 --> 00:31:55,039
optimization of futures that i showed

00:31:58,840 --> 00:32:01,840
you

00:32:05,360 --> 00:32:12,000
okay so uh let's see

00:32:08,960 --> 00:32:15,200
your questions uh

00:32:12,000 --> 00:32:17,120
lucas prokop from youtube asks does

00:32:15,200 --> 00:32:18,240
flattening of the discrimination of

00:32:17,120 --> 00:32:21,200
result result

00:32:18,240 --> 00:32:21,200
occur as well

00:32:21,519 --> 00:32:28,720
thank you for your question lukas

00:32:25,120 --> 00:32:33,279
yes it does happen uh as long

00:32:28,720 --> 00:32:37,360
as one of the variants of the result is

00:32:33,279 --> 00:32:39,840
a unit type or another type well

00:32:37,360 --> 00:32:42,480
if it's another time that it's not an

00:32:39,840 --> 00:32:44,720
optimization actually of course

00:32:42,480 --> 00:32:48,240
if it's a unit type then the result is

00:32:44,720 --> 00:32:51,760
practically working like an option

00:32:48,240 --> 00:32:55,120
so it works for any anoms that that look

00:32:51,760 --> 00:32:55,120
like an option you could say

00:32:55,279 --> 00:32:58,240
so they have

00:32:58,399 --> 00:33:04,799
at most two variants

00:33:01,679 --> 00:33:08,640
and at most one of them

00:33:04,799 --> 00:33:08,640
carries some information

00:33:09,519 --> 00:33:14,159
uh well there i i heard that there are

00:33:12,480 --> 00:33:17,760
plans to enable

00:33:14,159 --> 00:33:20,799
more than two variants uh

00:33:17,760 --> 00:33:25,120
but then you would need to have uh

00:33:20,799 --> 00:33:29,679
more fields that have that particular

00:33:25,120 --> 00:33:29,679
that's this particular um

00:33:30,000 --> 00:33:34,559
characteristics like if you have a

00:33:32,720 --> 00:33:38,559
single variant of

00:33:34,559 --> 00:33:41,519
two pointers then of course you could

00:33:38,559 --> 00:33:42,480
you could encode other variants by null

00:33:41,519 --> 00:33:45,679
on

00:33:42,480 --> 00:33:47,760
either of these pointers but then

00:33:45,679 --> 00:33:50,480
the problem with that is that you would

00:33:47,760 --> 00:33:53,600
need to do multiple checks

00:33:50,480 --> 00:33:54,000
which isn't really good for performance

00:33:53,600 --> 00:33:56,480
so

00:33:54,000 --> 00:33:59,120
that's why it's freaking uh not really

00:33:56,480 --> 00:33:59,120
that trivial

00:33:59,440 --> 00:34:06,480
jaimo kond uh on twitch asks

00:34:03,440 --> 00:34:08,240
where are the usage statistics from i

00:34:06,480 --> 00:34:10,720
missed the early piece of the talks of

00:34:08,240 --> 00:34:15,040
apology that was covered already

00:34:10,720 --> 00:34:18,480
uh yes it's my my original research

00:34:15,040 --> 00:34:22,079
i just scanned them

00:34:18,480 --> 00:34:24,079
with uh with a rust tool for

00:34:22,079 --> 00:34:25,200
parsing the code so i parsed the code

00:34:24,079 --> 00:34:28,240
and i just

00:34:25,200 --> 00:34:34,000
uh used uh

00:34:28,240 --> 00:34:36,800
kind of a crap like thing you could say

00:34:34,000 --> 00:34:39,359
someone gainer from youtube asks i

00:34:36,800 --> 00:34:40,800
always heard the internal representation

00:34:39,359 --> 00:34:44,960
of futures

00:34:40,800 --> 00:34:44,960
being represented as a state machine

00:34:45,520 --> 00:34:50,480
yes the anum is an implementation of a

00:34:48,960 --> 00:34:54,000
state machine

00:34:50,480 --> 00:34:56,800
uh as you could see on the

00:34:54,000 --> 00:34:57,680
slide of mine with that an over

00:34:56,800 --> 00:35:01,520
presentation

00:34:57,680 --> 00:35:04,560
i i showed you

00:35:01,520 --> 00:35:07,680
the state changes

00:35:04,560 --> 00:35:11,119
or the possible stage changes by arrows

00:35:07,680 --> 00:35:12,240
it's a little more explicit in the next

00:35:11,119 --> 00:35:16,000
slide

00:35:12,240 --> 00:35:20,400
when you have a

00:35:16,000 --> 00:35:20,400
table with availability of the fields

00:35:20,960 --> 00:35:24,560
so the state machine is the abstract

00:35:23,760 --> 00:35:26,800
concept

00:35:24,560 --> 00:35:29,359
and you are right it is a state machine

00:35:26,800 --> 00:35:33,839
and anoms and structures are

00:35:29,359 --> 00:35:33,839
the implementations of the state machine

00:35:34,960 --> 00:35:42,800
dot queries please from twitch asks

00:35:38,640 --> 00:35:46,079
so option of non non-zero

00:35:42,800 --> 00:35:50,480
u8 can be optimized into single byte by

00:35:46,079 --> 00:35:53,760
reusing the zero bit pattern yes exactly

00:35:50,480 --> 00:35:57,440
how close are we to generalizing that

00:35:53,760 --> 00:35:58,720
the other bit patterns for example if i

00:35:57,440 --> 00:36:02,880
have

00:35:58,720 --> 00:36:06,400
an u8 like type that's never

00:36:02,880 --> 00:36:09,119
oh yes yes uh

00:36:06,400 --> 00:36:11,760
there have been discussions about uh

00:36:09,119 --> 00:36:15,359
this particular

00:36:11,760 --> 00:36:19,200
example that you use the is the

00:36:15,359 --> 00:36:22,160
ff pattern uh well

00:36:19,200 --> 00:36:22,560
there are two reasons why it's zero

00:36:22,160 --> 00:36:25,520
first

00:36:22,560 --> 00:36:28,480
is that comparing to zero is the fastest

00:36:25,520 --> 00:36:31,040
of the comparisons between

00:36:28,480 --> 00:36:31,599
between variables and literals just

00:36:31,040 --> 00:36:34,880
because of

00:36:31,599 --> 00:36:39,119
how it looks in the machine code

00:36:34,880 --> 00:36:42,480
but in fact the

00:36:39,119 --> 00:36:43,599
there is no reason to not to generalize

00:36:42,480 --> 00:36:45,440
it

00:36:43,599 --> 00:36:46,880
the main problem is that this

00:36:45,440 --> 00:36:50,320
optimization is

00:36:46,880 --> 00:36:54,240
built in the language so it wouldn't

00:36:50,320 --> 00:36:57,440
be obvious if the

00:36:54,240 --> 00:36:57,440
if the change is

00:36:58,480 --> 00:37:05,040
optimal in the performance sense

00:37:02,160 --> 00:37:06,960
it would be in the memory layout as of

00:37:05,040 --> 00:37:10,960
course

00:37:06,960 --> 00:37:14,960
uh in fact um

00:37:10,960 --> 00:37:19,839
if it's uh if it's ff uh

00:37:14,960 --> 00:37:23,040
case or minus one is also a popular

00:37:19,839 --> 00:37:26,640
idea then nothing stops us from that i

00:37:23,040 --> 00:37:29,040
i think and i've actually seen some

00:37:26,640 --> 00:37:30,000
implementations of that and i've done an

00:37:29,040 --> 00:37:33,280
implementation

00:37:30,000 --> 00:37:35,839
implementation of that myself

00:37:33,280 --> 00:37:36,640
uh as for us for checking if something

00:37:35,839 --> 00:37:38,800
is

00:37:36,640 --> 00:37:40,160
less than something or greater than

00:37:38,800 --> 00:37:42,800
something

00:37:40,160 --> 00:37:45,040
not so in easy on the language level so

00:37:42,800 --> 00:37:48,640
the problem here isn't the

00:37:45,040 --> 00:37:52,560
technical aspect but it's the

00:37:48,640 --> 00:37:55,680
safety aspect in this case

00:37:52,560 --> 00:37:59,200
uh the safety aspect and the

00:37:55,680 --> 00:38:02,880
and the proof

00:37:59,200 --> 00:38:05,920
that it's indeed more performant so

00:38:02,880 --> 00:38:08,400
you could say that it's uh

00:38:05,920 --> 00:38:09,040
it's zero because we don't want to

00:38:08,400 --> 00:38:12,480
wonder

00:38:09,040 --> 00:38:16,880
if it's the best choice both

00:38:12,480 --> 00:38:16,880
performance wise and size wise

00:38:17,599 --> 00:38:23,280
a scrap chair from twitch asks

00:38:21,280 --> 00:38:25,200
would that be possible to create an

00:38:23,280 --> 00:38:29,760
option of option of option of

00:38:25,200 --> 00:38:29,760
option of unit

00:38:30,839 --> 00:38:34,560
00:38:32,160 --> 00:38:35,280
repetitions and have it flattened so

00:38:34,560 --> 00:38:38,480
that handling

00:38:35,280 --> 00:38:41,200
it would be as simple as handling a

00:38:38,480 --> 00:38:41,200
u8

00:38:41,520 --> 00:38:45,599
well it depends on what you mean by

00:38:44,320 --> 00:38:48,880
handling

00:38:45,599 --> 00:38:51,920
because from the code

00:38:48,880 --> 00:38:52,480
perspective it's still just an option of

00:38:51,920 --> 00:38:56,320
optional

00:38:52,480 --> 00:38:59,280
option etc of unit

00:38:56,320 --> 00:39:00,560
but yes it will compile down to a single

00:38:59,280 --> 00:39:04,720
bite

00:39:00,560 --> 00:39:08,240
so yes it is possible it's just

00:39:04,720 --> 00:39:09,599
a corner case that i wouldn't expect to

00:39:08,240 --> 00:39:13,119
see in a while but

00:39:09,599 --> 00:39:16,880
yes it it is possible and

00:39:13,119 --> 00:39:20,079
it is possible just in the current

00:39:16,880 --> 00:39:24,240
versions or so i think at least

00:39:20,079 --> 00:39:27,440
maybe 255 repetitions

00:39:24,240 --> 00:39:31,119
uh unless it would crack the

00:39:27,440 --> 00:39:34,000
compiler considering the

00:39:31,119 --> 00:39:34,320
level of nesting but that's another

00:39:34,000 --> 00:39:36,720
thing

00:39:34,320 --> 00:39:36,720
really

00:39:38,000 --> 00:39:44,720
oh some cyber trader from twitch

00:39:42,640 --> 00:39:46,160
asks are phantom types strictly

00:39:44,720 --> 00:39:50,880
necessary or

00:39:46,160 --> 00:39:54,960
could everything also represented with

00:39:50,880 --> 00:39:57,839
unit variants uh

00:39:54,960 --> 00:39:57,839
well

00:39:58,240 --> 00:40:06,560
phantom types are

00:40:01,359 --> 00:40:10,400
are also an interesting topic it's um

00:40:06,560 --> 00:40:14,800
it's indeed a little bit uh

00:40:10,400 --> 00:40:14,800
connected to what i've told you about

00:40:16,560 --> 00:40:22,800
as far as i know the

00:40:19,599 --> 00:40:27,599
language rules for

00:40:22,800 --> 00:40:32,319
pointers so so what kind of pointer is a

00:40:27,599 --> 00:40:36,480
subtype of another pointer uh

00:40:32,319 --> 00:40:39,760
do permit using uh pointers to unit or

00:40:36,480 --> 00:40:43,359
unit variants as

00:40:39,760 --> 00:40:45,040
a sort of phantom type and i did see

00:40:43,359 --> 00:40:47,280
that in the wild actually

00:40:45,040 --> 00:40:47,280
but

00:40:49,680 --> 00:40:56,160
you know i always considered phantom

00:40:53,760 --> 00:40:59,920
type to be

00:40:56,160 --> 00:41:02,640
more of an abstract convention

00:40:59,920 --> 00:41:03,920
but yes of course if if what you mean is

00:41:02,640 --> 00:41:07,359
that

00:41:03,920 --> 00:41:09,920
uh it could be used like that

00:41:07,359 --> 00:41:10,880
yes i think it could be used like that

00:41:09,920 --> 00:41:15,680
and

00:41:10,880 --> 00:41:20,480
i've actually did use uh unit type in

00:41:15,680 --> 00:41:22,960
very i'd say weird ways so

00:41:20,480 --> 00:41:25,119
for instance you could use the unit type

00:41:22,960 --> 00:41:26,880
to

00:41:25,119 --> 00:41:29,520
just create some fields that are

00:41:26,880 --> 00:41:32,720
available or not depending on

00:41:29,520 --> 00:41:35,920
what kind of generic arguments

00:41:32,720 --> 00:41:39,440
you have the spec the type

00:41:35,920 --> 00:41:40,960
instantiated with so for example you

00:41:39,440 --> 00:41:44,079
have some field x

00:41:40,960 --> 00:41:44,480
but only if the type is instantiated

00:41:44,079 --> 00:41:50,079
with

00:41:44,480 --> 00:41:53,119
uh integer um something like that

00:41:50,079 --> 00:41:53,760
and uh it can actually be quite useful

00:41:53,119 --> 00:41:57,119
if you

00:41:53,760 --> 00:42:00,160
make a library for

00:41:57,119 --> 00:42:05,520
uh for

00:42:00,160 --> 00:42:05,520
a multi-dimensional computations

00:42:08,640 --> 00:42:12,800
it's not an easy task to choose the best

00:42:11,680 --> 00:42:17,839
answer

00:42:12,800 --> 00:42:17,839
the best question sorry

00:42:30,960 --> 00:42:33,200
uh

00:42:34,160 --> 00:42:42,319
i personally like dot chris please

00:42:38,000 --> 00:42:45,599
question for option of non-zero

00:42:42,319 --> 00:42:50,000
u8 considering that uh that's exactly

00:42:45,599 --> 00:42:53,040
the the way i thought while

00:42:50,000 --> 00:42:56,640
uh reading about this topic so

00:42:53,040 --> 00:42:59,839
congratu congratulations that chris

00:42:56,640 --> 00:42:59,839

YouTube URL: https://www.youtube.com/watch?v=qBlEi7szSkU


