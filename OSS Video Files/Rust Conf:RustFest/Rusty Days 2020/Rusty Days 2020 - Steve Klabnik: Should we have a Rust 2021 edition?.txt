Title: Rusty Days 2020 - Steve Klabnik: Should we have a Rust 2021 edition?
Publication date: 2020-08-02
Playlist: Rusty Days 2020
Description: 
	Agenda ► https://rusty-days.org/agenda
Slides ►https://rusty-days.org/assets/slides/01-should-we-have-a-2021-edition.pdf
Playlist with all talks ► https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ

Follow ►
Facebook: https://rusty-days.org/facebook
Twitch: https://rusty-days.org/twitch
Twitter: https://rusty-days.org/twitter


This video ►
In 2018, Rust adopted an "edition" system. This lets Rust evolve in ways that feel like breaking changes but are opt-in only, and that do not disturb the open-source ecosystem. Given that Rust 2018 happened three years after the initial 2015 release of Rust, this has everyone wondering: is 2021 the year we have our next edition?

In this talk, Steve lays out his own feelings on this question, as well as talks about the history of the edition system, how it works, and what it might look like in 2021.
Captions: 
	00:00:08,720 --> 00:00:13,200
all right

00:00:10,080 --> 00:00:14,719
hey everybody i'm steve thanks for uh

00:00:13,200 --> 00:00:17,119
thanks for coming to my talk

00:00:14,719 --> 00:00:18,480
this uh talk is titled should we have a

00:00:17,119 --> 00:00:21,840
2021 edition

00:00:18,480 --> 00:00:23,840
um and today is the 27th um so

00:00:21,840 --> 00:00:25,680
uh for those of you who don't know i am

00:00:23,840 --> 00:00:27,760
on the core team of rust

00:00:25,680 --> 00:00:28,960
i previously led the documentation team

00:00:27,760 --> 00:00:30,400
and i

00:00:28,960 --> 00:00:32,800
wrote the rest programming language

00:00:30,400 --> 00:00:34,320
which is the introductory book onrest

00:00:32,800 --> 00:00:36,800
that comes with

00:00:34,320 --> 00:00:38,399
rus itself two other things though that

00:00:36,800 --> 00:00:39,440
you may or may not know i figured i

00:00:38,399 --> 00:00:40,559
would mention before i get in the meat

00:00:39,440 --> 00:00:42,640
of this talk

00:00:40,559 --> 00:00:44,399
i recently got a new job at a company

00:00:42,640 --> 00:00:46,879
called oxide computer company

00:00:44,399 --> 00:00:48,320
um we're building new server computers

00:00:46,879 --> 00:00:50,399
for uh people to use

00:00:48,320 --> 00:00:52,879
and uh we're doing like everything in

00:00:50,399 --> 00:00:55,600
rust so these days i'm like writing

00:00:52,879 --> 00:00:56,800
uh embedded rust and uh it's awesome and

00:00:55,600 --> 00:00:58,000
we've had an embedded working group

00:00:56,800 --> 00:00:59,600
working on it for a while

00:00:58,000 --> 00:01:01,120
and i appreciated their work in the

00:00:59,600 --> 00:01:02,879
abstract sense but now that i'm actually

00:01:01,120 --> 00:01:05,199
doing their work as my job

00:01:02,879 --> 00:01:06,400
it's fantastic so that's pretty cool and

00:01:05,199 --> 00:01:08,560
we are also hiring

00:01:06,400 --> 00:01:10,080
so if you are interested in a job where

00:01:08,560 --> 00:01:12,080
you will write a lot of rust

00:01:10,080 --> 00:01:13,680
you may want to check that out finally

00:01:12,080 --> 00:01:16,159
i've started actually working on open

00:01:13,680 --> 00:01:17,840
source rust streaming stuff so uh i'm

00:01:16,159 --> 00:01:19,520
doing my twitch now so if you want to

00:01:17,840 --> 00:01:22,159
watch me program on tuesdays

00:01:19,520 --> 00:01:23,200
that's the thing i'm doing okay anyway

00:01:22,159 --> 00:01:25,360
enough about me

00:01:23,200 --> 00:01:26,720
uh you want to hear about additions so

00:01:25,360 --> 00:01:29,040
today we're going to kind of cover

00:01:26,720 --> 00:01:30,000
these like three major points in this

00:01:29,040 --> 00:01:32,240
order

00:01:30,000 --> 00:01:34,000
so the first one is what exactly are

00:01:32,240 --> 00:01:35,040
additions um i want to make sure that

00:01:34,000 --> 00:01:37,119
we're on the same page

00:01:35,040 --> 00:01:38,479
about the details because the details do

00:01:37,119 --> 00:01:41,759
actually matter and matter

00:01:38,479 --> 00:01:43,840
a lot here secondly we've already done

00:01:41,759 --> 00:01:45,119
sort of one edition release which is

00:01:43,840 --> 00:01:47,119
rest 2018

00:01:45,119 --> 00:01:49,439
and so i kind of want to take a look at

00:01:47,119 --> 00:01:51,439
that and like kind of how it went

00:01:49,439 --> 00:01:52,640
and some like thoughts you know after

00:01:51,439 --> 00:01:53,840
some time has passed

00:01:52,640 --> 00:01:55,040
so it's kind of like a little bit of a

00:01:53,840 --> 00:01:56,240
case study maybe a little bit of

00:01:55,040 --> 00:01:58,079
retrospective

00:01:56,240 --> 00:02:00,240
um you know but let's like talk about

00:01:58,079 --> 00:02:02,640
rest 2018 and then finally

00:02:00,240 --> 00:02:05,200
like what should we actually do um and

00:02:02,640 --> 00:02:07,600
this is phrases should we have rus 2021

00:02:05,200 --> 00:02:09,200
um that's kind of like a big thing

00:02:07,600 --> 00:02:10,640
people have been talking about lately

00:02:09,200 --> 00:02:12,319
um i want to sort of emphasize

00:02:10,640 --> 00:02:14,080
especially with both of these second

00:02:12,319 --> 00:02:14,720
sections that this is like my personal

00:02:14,080 --> 00:02:16,400
opinion

00:02:14,720 --> 00:02:18,080
um while i am on the court team i am

00:02:16,400 --> 00:02:19,920
only one person and

00:02:18,080 --> 00:02:21,360
uh you know this is this is all phrased

00:02:19,920 --> 00:02:22,560
as like should we because technically

00:02:21,360 --> 00:02:24,959
nothing has been decided

00:02:22,560 --> 00:02:26,160
so uh while i do have my own opinions on

00:02:24,959 --> 00:02:28,319
this uh

00:02:26,160 --> 00:02:30,239
feel free to disagree and just like you

00:02:28,319 --> 00:02:33,760
know this is this is me saying this

00:02:30,239 --> 00:02:36,400
so uh take that as far as that goes

00:02:33,760 --> 00:02:37,280
um all right so first up this first

00:02:36,400 --> 00:02:40,239
section

00:02:37,280 --> 00:02:41,360
what even are additions anyway uh if you

00:02:40,239 --> 00:02:42,640
don't know at all

00:02:41,360 --> 00:02:44,319
thank you for coming my talk even though

00:02:42,640 --> 00:02:45,840
you don't know the subject uh this is

00:02:44,319 --> 00:02:47,760
exactly why i included this section

00:02:45,840 --> 00:02:49,200
but even if you do there's some details

00:02:47,760 --> 00:02:50,000
that maybe some people don't always

00:02:49,200 --> 00:02:51,599
think about so

00:02:50,000 --> 00:02:53,200
i want to talk about a lot of those

00:02:51,599 --> 00:02:55,120
details there's kind of

00:02:53,200 --> 00:02:56,879
two aspects to additions that i think

00:02:55,120 --> 00:02:59,599
are really important and the first one

00:02:56,879 --> 00:03:03,040
is the sort of social aspect of

00:02:59,599 --> 00:03:05,599
uh rust so um in addition is kind of

00:03:03,040 --> 00:03:07,280
this time point in time where we say hey

00:03:05,599 --> 00:03:08,800
rust is significantly different now than

00:03:07,280 --> 00:03:11,040
it was in the past and

00:03:08,800 --> 00:03:13,599
uh you know here's kind of like why um

00:03:11,040 --> 00:03:15,760
so rust 1.0 came out in 2015.

00:03:13,599 --> 00:03:17,599
russ 2018 was the first edition sort of

00:03:15,760 --> 00:03:19,360
release and it came out in 2018

00:03:17,599 --> 00:03:20,879
and we sort of said like hey you know

00:03:19,360 --> 00:03:21,519
rust has changed a lot in the last three

00:03:20,879 --> 00:03:23,440
years

00:03:21,519 --> 00:03:25,040
um you know let's talk about all the

00:03:23,440 --> 00:03:26,000
stuff we've accomplished and add in some

00:03:25,040 --> 00:03:28,799
other things

00:03:26,000 --> 00:03:29,360
um and so that's like largely a social

00:03:28,799 --> 00:03:31,920
thing

00:03:29,360 --> 00:03:33,440
so this is a way to sort of reflect on

00:03:31,920 --> 00:03:35,280
the longer term progress

00:03:33,440 --> 00:03:36,640
of the language and the project as a

00:03:35,280 --> 00:03:38,959
whole um

00:03:36,640 --> 00:03:40,640
because we release every six weeks that

00:03:38,959 --> 00:03:42,879
is like a really great thing

00:03:40,640 --> 00:03:43,760
for a lot of reasons but it's really

00:03:42,879 --> 00:03:46,400
hard to

00:03:43,760 --> 00:03:48,000
like remember how much work we've done

00:03:46,400 --> 00:03:49,599
releases come out all the time

00:03:48,000 --> 00:03:51,120
and they're in small little chunks and

00:03:49,599 --> 00:03:52,159
so it can be really really easy to

00:03:51,120 --> 00:03:55,040
forget like

00:03:52,159 --> 00:03:56,720
just how far along things came half the

00:03:55,040 --> 00:04:00,000
time i forget that it's been

00:03:56,720 --> 00:04:01,280
like almost five years since rest 1.0

00:04:00,000 --> 00:04:03,920
because when things are happening at

00:04:01,280 --> 00:04:05,920
such a rapid pace it's really easy to

00:04:03,920 --> 00:04:07,519
you know lose track of like how far

00:04:05,920 --> 00:04:10,319
we've come um

00:04:07,519 --> 00:04:11,040
and so that's like really important um a

00:04:10,319 --> 00:04:13,920
second one

00:04:11,040 --> 00:04:16,160
is a point on like why additions matter

00:04:13,920 --> 00:04:18,799
are that they're a way to get new users

00:04:16,160 --> 00:04:20,320
into rust so this sort of is kind of

00:04:18,799 --> 00:04:22,560
similar to the first point but

00:04:20,320 --> 00:04:24,479
a little bit different um basically you

00:04:22,560 --> 00:04:26,320
know because we release every six weeks

00:04:24,479 --> 00:04:28,080
there's a lot of people who don't pay

00:04:26,320 --> 00:04:29,919
attention to rest releases because they

00:04:28,080 --> 00:04:30,240
see them so often and they have not that

00:04:29,919 --> 00:04:32,080
much

00:04:30,240 --> 00:04:33,520
in them and so they're kind of like you

00:04:32,080 --> 00:04:36,000
know hey uh

00:04:33,520 --> 00:04:36,800
you know i the new rust release happens

00:04:36,000 --> 00:04:38,800
i don't care

00:04:36,800 --> 00:04:41,440
um with languages that release like once

00:04:38,800 --> 00:04:43,440
a year or once every couple of years

00:04:41,440 --> 00:04:45,120
it's a really big deal and so a lot of

00:04:43,440 --> 00:04:46,560
people will like hear about like you

00:04:45,120 --> 00:04:47,280
know oh there's a new version of

00:04:46,560 --> 00:04:49,280
people's plus

00:04:47,280 --> 00:04:51,360
out or there's a new version of ruby out

00:04:49,280 --> 00:04:52,160
or the new c-sharp has these cool new

00:04:51,360 --> 00:04:53,919
things in it

00:04:52,160 --> 00:04:55,600
and that's a way for people who don't

00:04:53,919 --> 00:04:57,199
currently program in the language just

00:04:55,600 --> 00:04:58,560
sort of like it signals to them

00:04:57,199 --> 00:05:00,400
hey you know i should check this out

00:04:58,560 --> 00:05:02,800
maybe you know i looked at c

00:05:00,400 --> 00:05:04,320
sharp 3.0 and i didn't really like what

00:05:02,800 --> 00:05:06,160
was going on so i didn't use it

00:05:04,320 --> 00:05:07,360
maybe c sharp 4 like time for me to

00:05:06,160 --> 00:05:09,919
check in again maybe

00:05:07,360 --> 00:05:11,440
i want to start programming in it and so

00:05:09,919 --> 00:05:14,000
it's kind of a nice way to signal to

00:05:11,440 --> 00:05:15,520
people outside of the rest world as well

00:05:14,000 --> 00:05:16,560
that you know hey a lot has gone on and

00:05:15,520 --> 00:05:18,240
maybe if you didn't

00:05:16,560 --> 00:05:19,919
use rust in the past you would want to

00:05:18,240 --> 00:05:22,080
use it again um

00:05:19,919 --> 00:05:24,400
and then finally like kind of for

00:05:22,080 --> 00:05:26,479
actually like development of rust um

00:05:24,400 --> 00:05:27,919
sort of like a nice like rallying cry i

00:05:26,479 --> 00:05:30,160
guess basically

00:05:27,919 --> 00:05:32,000
like uh you know not only is it about

00:05:30,160 --> 00:05:33,520
reflecting on what we've done but also

00:05:32,000 --> 00:05:34,080
if there's sort of big things we want to

00:05:33,520 --> 00:05:35,600
do

00:05:34,080 --> 00:05:37,199
it's nice to build a point in the near

00:05:35,600 --> 00:05:39,199
future and say like you know

00:05:37,199 --> 00:05:41,039
hey it's 20 20 now we want to do a rust

00:05:39,199 --> 00:05:41,680
2021 and we want to like get people

00:05:41,039 --> 00:05:43,280
excited

00:05:41,680 --> 00:05:44,639
so let's start working on some projects

00:05:43,280 --> 00:05:45,360
that will like really generate that

00:05:44,639 --> 00:05:46,560
excitement

00:05:45,360 --> 00:05:47,600
and there's some like back and forth

00:05:46,560 --> 00:05:48,560
here and we're going to talk about all

00:05:47,600 --> 00:05:50,320
those details

00:05:48,560 --> 00:05:52,160
in a minute but it can be a really great

00:05:50,320 --> 00:05:53,680
way to sort of get everybody excited

00:05:52,160 --> 00:05:55,440
about the future of rust

00:05:53,680 --> 00:05:58,400
because you know we like need those

00:05:55,440 --> 00:06:01,759
check-in kind of points i think

00:05:58,400 --> 00:06:03,600
um but also additions are not purely a

00:06:01,759 --> 00:06:04,960
social mechanism they're also a

00:06:03,600 --> 00:06:07,680
technical mechanism

00:06:04,960 --> 00:06:08,960
and this this really matters um and so

00:06:07,680 --> 00:06:10,560
on a technical level

00:06:08,960 --> 00:06:12,800
additions are a way to kind of make

00:06:10,560 --> 00:06:15,360
breaking changes to the rust language

00:06:12,800 --> 00:06:16,479
without actually making breaking changes

00:06:15,360 --> 00:06:18,400
and so

00:06:16,479 --> 00:06:20,720
how this kind of works on a technical

00:06:18,400 --> 00:06:23,120
level is that editions are opt-in

00:06:20,720 --> 00:06:24,639
so you say what edition your code is in

00:06:23,120 --> 00:06:27,759
and if you don't update that

00:06:24,639 --> 00:06:30,400
then you don't update you know stuff

00:06:27,759 --> 00:06:31,919
so if new things are added in a way

00:06:30,400 --> 00:06:33,759
that's like technically breaking

00:06:31,919 --> 00:06:35,840
then it doesn't break you because if you

00:06:33,759 --> 00:06:38,240
didn't opt in to the new changes

00:06:35,840 --> 00:06:39,919
then your code still works forever so

00:06:38,240 --> 00:06:41,759
this is like very different than

00:06:39,919 --> 00:06:43,039
you know python 2 to python 3 for

00:06:41,759 --> 00:06:44,800
example where

00:06:43,039 --> 00:06:47,039
uh you know you can't run your code kind

00:06:44,800 --> 00:06:48,720
of like together um

00:06:47,039 --> 00:06:50,319
and uh you know similar kind of things

00:06:48,720 --> 00:06:52,479
like that so we can like

00:06:50,319 --> 00:06:53,440
make it a way to opt into breaking

00:06:52,479 --> 00:06:54,639
changes um

00:06:53,440 --> 00:06:57,440
and that's really really important for

00:06:54,639 --> 00:06:59,440
compatibility reasons and then finally

00:06:57,440 --> 00:07:00,880
um additions are not allowed to change

00:06:59,440 --> 00:07:03,120
everything about rust

00:07:00,880 --> 00:07:04,720
um this is a technical problem as much

00:07:03,120 --> 00:07:06,400
as it is a social problem and there's

00:07:04,720 --> 00:07:07,120
custom interplay back and forth between

00:07:06,400 --> 00:07:10,800
the two

00:07:07,120 --> 00:07:11,440
but um basically like major major

00:07:10,800 --> 00:07:13,440
changes

00:07:11,440 --> 00:07:14,720
are not actually allowed so some kinds

00:07:13,440 --> 00:07:16,000
of breaking changes are fine

00:07:14,720 --> 00:07:18,400
but there are some kinds of changes that

00:07:16,000 --> 00:07:20,720
cannot be made in the addition mechanism

00:07:18,400 --> 00:07:22,000
and that's due to the technical details

00:07:20,720 --> 00:07:24,880
of how all this works

00:07:22,000 --> 00:07:25,840
um it does also kind of a social thing

00:07:24,880 --> 00:07:28,479
in the sense that

00:07:25,840 --> 00:07:30,800
uh it's also useful for humans like if

00:07:28,479 --> 00:07:32,319
tomorrow like say rus 2021 was going to

00:07:30,800 --> 00:07:33,919
be like garbage collected and use

00:07:32,319 --> 00:07:34,560
significant white space instead of curly

00:07:33,919 --> 00:07:35,599
braces

00:07:34,560 --> 00:07:36,800
it would effectively be a whole

00:07:35,599 --> 00:07:38,880
different language and that would make

00:07:36,800 --> 00:07:40,960
it a really big challenge for people to

00:07:38,880 --> 00:07:42,639
update to but uh because we can only

00:07:40,960 --> 00:07:44,000
make certain kinds of breaking changes

00:07:42,639 --> 00:07:46,319
and editions additions

00:07:44,000 --> 00:07:47,360
it's significantly better for people to

00:07:46,319 --> 00:07:49,280
be able to upgrade

00:07:47,360 --> 00:07:50,960
um not only because the opt-in nature of

00:07:49,280 --> 00:07:53,039
things but also just like

00:07:50,960 --> 00:07:54,720
rust is still going to be rust even if

00:07:53,039 --> 00:07:56,639
there are some tweaks to how it works

00:07:54,720 --> 00:07:59,440
and some changes like the core idea of

00:07:56,639 --> 00:08:00,800
rust will be the same

00:07:59,440 --> 00:08:02,479
so let's talk a little bit about what i

00:08:00,800 --> 00:08:04,560
mean by breaking changes

00:08:02,479 --> 00:08:06,479
in an addition so i think one of the

00:08:04,560 --> 00:08:09,680
best examples of a breaking change

00:08:06,479 --> 00:08:12,560
was the async keyword so

00:08:09,680 --> 00:08:14,800
rust has you know as i said two editions

00:08:12,560 --> 00:08:18,080
right now 2015 and 2018

00:08:14,800 --> 00:08:20,800
and in russ 2015 code is uh you know

00:08:18,080 --> 00:08:22,080
async is not a keyword but in 2018 it is

00:08:20,800 --> 00:08:23,280
and so what that means is

00:08:22,080 --> 00:08:24,879
if you look at this code that i have

00:08:23,280 --> 00:08:26,879
here on the left we have a function

00:08:24,879 --> 00:08:28,319
named async that just takes an integer

00:08:26,879 --> 00:08:29,039
and returns it it doesn't do anything

00:08:28,319 --> 00:08:32,640
fancy

00:08:29,039 --> 00:08:34,479
but uh we call it um passing in a five

00:08:32,640 --> 00:08:35,839
and uh used underscore s as the name

00:08:34,479 --> 00:08:37,039
since we never use the variable to get

00:08:35,839 --> 00:08:40,159
rid of that kind of warning

00:08:37,039 --> 00:08:41,279
so if i run this code on russ 2815 as

00:08:40,159 --> 00:08:41,919
you can see this is the playpen

00:08:41,279 --> 00:08:44,320
interface

00:08:41,919 --> 00:08:45,839
on play.wrestling.org you can choose

00:08:44,320 --> 00:08:47,360
this little drop down with the three

00:08:45,839 --> 00:08:48,160
dots and then pick which edition you're

00:08:47,360 --> 00:08:50,480
in so

00:08:48,160 --> 00:08:52,399
if you choose 2015 this code will

00:08:50,480 --> 00:08:53,920
compile and it runs doesn't do anything

00:08:52,399 --> 00:08:54,320
because we just you know pass manager

00:08:53,920 --> 00:08:56,080
around

00:08:54,320 --> 00:08:57,600
so there's no output but if we change

00:08:56,080 --> 00:08:59,680
that to edition 2018

00:08:57,600 --> 00:09:02,480
we will get an error and this will say

00:08:59,680 --> 00:09:04,800
expected identifier found keyword async

00:09:02,480 --> 00:09:06,640
so we're allowed to name a function

00:09:04,800 --> 00:09:07,200
async in rest 2015 because it's not a

00:09:06,640 --> 00:09:09,440
keyword

00:09:07,200 --> 00:09:10,560
but we're not allowed to name it in

00:09:09,440 --> 00:09:12,800
async in rust

00:09:10,560 --> 00:09:13,920
2018 because it is a keyword so this is

00:09:12,800 --> 00:09:16,000
an example of

00:09:13,920 --> 00:09:17,360
you know if we purely made this change

00:09:16,000 --> 00:09:19,200
um in the language

00:09:17,360 --> 00:09:20,720
code that existed and ran just fine

00:09:19,200 --> 00:09:23,440
before would end up breaking

00:09:20,720 --> 00:09:24,959
so this is like a breaking change but

00:09:23,440 --> 00:09:25,680
because you can choose whether or not to

00:09:24,959 --> 00:09:27,600
upgrade

00:09:25,680 --> 00:09:29,680
it's like not a breaking change and so

00:09:27,600 --> 00:09:31,839
this kind of like duality it was a very

00:09:29,680 --> 00:09:33,040
controversial around coming up with the

00:09:31,839 --> 00:09:34,399
plan of editions

00:09:33,040 --> 00:09:36,160
and was also one of the big challenges

00:09:34,399 --> 00:09:38,000
of communicating this to users

00:09:36,160 --> 00:09:40,000
like technically it's breaking but it's

00:09:38,000 --> 00:09:44,080
also not breaking is

00:09:40,000 --> 00:09:44,080
very interesting and kind of unusual

00:09:45,680 --> 00:09:50,240
so is my mic still working all right

00:09:47,839 --> 00:09:52,160
cool dropped out there for a second um

00:09:50,240 --> 00:09:53,440
so the way that you opt into this change

00:09:52,160 --> 00:09:55,440
if you're not on the play pen

00:09:53,440 --> 00:09:56,640
um because most serious rust programs

00:09:55,440 --> 00:09:57,760
are not running in the play pen that

00:09:56,640 --> 00:10:00,480
would be ridiculous

00:09:57,760 --> 00:10:01,440
is in the cargo.tamel so you get to

00:10:00,480 --> 00:10:03,680
choose

00:10:01,440 --> 00:10:05,279
an addition mechanism an addition key by

00:10:03,680 --> 00:10:07,200
putting 2018 in there

00:10:05,279 --> 00:10:08,880
and if this does not exist at all then

00:10:07,200 --> 00:10:11,200
it defaults to 2015.

00:10:08,880 --> 00:10:12,480
so all the code that was generated

00:10:11,200 --> 00:10:16,079
before we had this

00:10:12,480 --> 00:10:17,760
idea of additions um it is able to you

00:10:16,079 --> 00:10:18,959
know stay on the sort of the default

00:10:17,760 --> 00:10:20,640
2015 edition

00:10:18,959 --> 00:10:23,120
but if you opt in then you're able to do

00:10:20,640 --> 00:10:25,200
this and cargo new will start generating

00:10:23,120 --> 00:10:26,079
you know 2018 so i just type cargo new

00:10:25,200 --> 00:10:28,480
to generate this

00:10:26,079 --> 00:10:30,560
and it defaults me to the latest and so

00:10:28,480 --> 00:10:32,000
um that way you know we're able to like

00:10:30,560 --> 00:10:34,000
new projects start in the latest

00:10:32,000 --> 00:10:35,360
edition but older projects stay on the

00:10:34,000 --> 00:10:37,920
edition they were created with

00:10:35,360 --> 00:10:39,600
until their creators explicitly opt-in

00:10:37,920 --> 00:10:40,160
so that's kind of like the way that this

00:10:39,600 --> 00:10:43,600
happens

00:10:40,160 --> 00:10:44,959
in most real projects and one thing

00:10:43,600 --> 00:10:47,920
that's really important

00:10:44,959 --> 00:10:49,519
though about editions is that additions

00:10:47,920 --> 00:10:51,519
can interoperate just fine

00:10:49,519 --> 00:10:53,040
so let's say that i had packaged up my

00:10:51,519 --> 00:10:55,519
useless async function

00:10:53,040 --> 00:10:57,680
into a crate and i wanted to use it from

00:10:55,519 --> 00:10:59,200
some code that was in rust 2018

00:10:57,680 --> 00:11:01,120
well one of the features that was added

00:10:59,200 --> 00:11:02,240
in russ 2018 was the ability to use a

00:11:01,120 --> 00:11:04,640
raw keyword

00:11:02,240 --> 00:11:05,920
so i showed you the error message in the

00:11:04,640 --> 00:11:07,360
2018 code before

00:11:05,920 --> 00:11:09,040
but right below the error is a little

00:11:07,360 --> 00:11:10,560
help message that says hey you can

00:11:09,040 --> 00:11:11,600
escape keywords to use them as

00:11:10,560 --> 00:11:15,040
identifiers

00:11:11,600 --> 00:11:18,000
and so here with this r pound sign

00:11:15,040 --> 00:11:18,480
both at the call site and at the actual

00:11:18,000 --> 00:11:20,480
um

00:11:18,480 --> 00:11:22,880
you know declaration site you're able to

00:11:20,480 --> 00:11:24,640
still define and call a function named

00:11:22,880 --> 00:11:25,760
async even though it's a keyword

00:11:24,640 --> 00:11:28,399
so this would matter if you could

00:11:25,760 --> 00:11:31,040
imagine that the you know async function

00:11:28,399 --> 00:11:33,279
lived in a 2015 crate then i would still

00:11:31,040 --> 00:11:34,880
be able to call it from a 2018 crate

00:11:33,279 --> 00:11:36,320
and you know vice versa if there was

00:11:34,880 --> 00:11:38,079
some other way of doing it so

00:11:36,320 --> 00:11:39,440
this is one example of the ways that

00:11:38,079 --> 00:11:40,079
code can interoperate but just in

00:11:39,440 --> 00:11:41,839
general

00:11:40,079 --> 00:11:43,200
like kind of the idea is that you don't

00:11:41,839 --> 00:11:44,399
have to be worried about your

00:11:43,200 --> 00:11:46,160
dependencies at all

00:11:44,399 --> 00:11:48,240
um other code is allowed to be in any

00:11:46,160 --> 00:11:49,279
edition and they'll compile into your

00:11:48,240 --> 00:11:51,519
project just fine

00:11:49,279 --> 00:11:53,200
and there's no like worrying about this

00:11:51,519 --> 00:11:54,160
kind of interoperability compact

00:11:53,200 --> 00:11:55,760
compatibility

00:11:54,160 --> 00:11:56,880
other than if you know some keywords are

00:11:55,760 --> 00:11:58,399
named a certain way then you have to

00:11:56,880 --> 00:12:00,800
know this escape mechanism

00:11:58,399 --> 00:12:02,480
um but what this means is we don't have

00:12:00,800 --> 00:12:03,519
the situation where by when a new

00:12:02,480 --> 00:12:05,279
addition comes out

00:12:03,519 --> 00:12:07,680
everyone is forced to upgrade all at

00:12:05,279 --> 00:12:10,720
once because that doesn't happen

00:12:07,680 --> 00:12:11,760
um it takes a long time and you know

00:12:10,720 --> 00:12:13,200
there's always some people that are

00:12:11,760 --> 00:12:14,959
going to sort of prefer

00:12:13,200 --> 00:12:17,200
older things and we don't want to like

00:12:14,959 --> 00:12:19,360
bifurcate the ecosystem and so this way

00:12:17,200 --> 00:12:21,120
these versions can live in total harmony

00:12:19,360 --> 00:12:22,000
and your dependencies can upgrade at

00:12:21,120 --> 00:12:24,000
their leisure

00:12:22,000 --> 00:12:25,040
and you can you know upgrade as fast or

00:12:24,000 --> 00:12:26,720
as slow as you'd like

00:12:25,040 --> 00:12:28,160
and you're not locked out of the rest of

00:12:26,720 --> 00:12:30,800
rust world so that's

00:12:28,160 --> 00:12:31,600
a really like helpful way to make sure

00:12:30,800 --> 00:12:34,639
that all this

00:12:31,600 --> 00:12:37,200
operates smoothly and so

00:12:34,639 --> 00:12:38,720
um specifically i had mentioned before

00:12:37,200 --> 00:12:40,639
part of the way that this works

00:12:38,720 --> 00:12:41,920
is that uh additions are not allowed to

00:12:40,639 --> 00:12:44,079
change everything

00:12:41,920 --> 00:12:45,600
so these are the rules that were set out

00:12:44,079 --> 00:12:47,760
in the original rfc

00:12:45,600 --> 00:12:49,120
and they're not complete so this is not

00:12:47,760 --> 00:12:50,880
necessarily like a full list of

00:12:49,120 --> 00:12:52,880
everything that can and can't change

00:12:50,880 --> 00:12:54,320
but uh i wanted to like point out some

00:12:52,880 --> 00:12:56,480
uh some specifics

00:12:54,320 --> 00:12:57,680
so an example of a thing that can change

00:12:56,480 --> 00:12:58,320
as i've already showed you is new

00:12:57,680 --> 00:13:00,560
keywords

00:12:58,320 --> 00:13:01,680
so we're allowed to define new keywords

00:13:00,560 --> 00:13:04,240
and new editions

00:13:01,680 --> 00:13:05,440
and uh you know that's totally fine it's

00:13:04,240 --> 00:13:06,240
like i said they interrupt across the

00:13:05,440 --> 00:13:08,880
boundary

00:13:06,240 --> 00:13:10,160
no problems um the second thing that

00:13:08,880 --> 00:13:12,320
additions are allowed to change

00:13:10,160 --> 00:13:13,279
it's allowed to repurpose existing

00:13:12,320 --> 00:13:16,000
syntax

00:13:13,279 --> 00:13:16,880
and i say repurpose because like you can

00:13:16,000 --> 00:13:18,560
remove

00:13:16,880 --> 00:13:20,320
existing syntax it's like how it gets

00:13:18,560 --> 00:13:22,959
repurposed but like

00:13:20,320 --> 00:13:24,560
it generally shouldn't only remove it

00:13:22,959 --> 00:13:25,839
should like replace with something that

00:13:24,560 --> 00:13:28,880
does something slightly different

00:13:25,839 --> 00:13:32,399
so an example of this is if you have a

00:13:28,880 --> 00:13:33,440
uh the usage of a trait in this case i'm

00:13:32,399 --> 00:13:35,040
just calling it trait

00:13:33,440 --> 00:13:36,639
but uh you know if you're using this as

00:13:35,040 --> 00:13:37,600
a trade object you would just use the

00:13:36,639 --> 00:13:39,920
name of the trait

00:13:37,600 --> 00:13:40,639
originally so you have like box trait or

00:13:39,920 --> 00:13:42,639
arc trait

00:13:40,639 --> 00:13:44,320
something like that and so what we did

00:13:42,639 --> 00:13:46,639
in the 2018 edition was

00:13:44,320 --> 00:13:47,600
we sort of deprecated that usage of just

00:13:46,639 --> 00:13:49,360
trait on its own

00:13:47,600 --> 00:13:50,959
and we introduced dyn trait

00:13:49,360 --> 00:13:52,399
unfortunately my slides kind of split

00:13:50,959 --> 00:13:53,519
this on the two lines normally it would

00:13:52,399 --> 00:13:55,920
be just one line

00:13:53,519 --> 00:13:57,199
but like this helped you know that hey

00:13:55,920 --> 00:13:58,639
this is a trade object because we're

00:13:57,199 --> 00:14:00,560
doing dynamic dispatch

00:13:58,639 --> 00:14:02,560
and so we kind of like replace that

00:14:00,560 --> 00:14:05,040
existing syntax for doing a thing with a

00:14:02,560 --> 00:14:07,519
new syntax instead

00:14:05,040 --> 00:14:08,399
and so you're able to uh you know use

00:14:07,519 --> 00:14:10,320
this

00:14:08,399 --> 00:14:12,000
new syntax and it's like more clear to

00:14:10,320 --> 00:14:12,800
people that dynamic dispatch is what's

00:14:12,000 --> 00:14:14,639
happening so

00:14:12,800 --> 00:14:16,320
we're allowed to kind of like change

00:14:14,639 --> 00:14:17,360
some existing stuff and add some new

00:14:16,320 --> 00:14:19,600
things and like tweak

00:14:17,360 --> 00:14:21,279
things um another example of something

00:14:19,600 --> 00:14:22,880
that changed in the 2018 edition was the

00:14:21,279 --> 00:14:23,519
module system which is a pretty big

00:14:22,880 --> 00:14:24,959
change

00:14:23,519 --> 00:14:27,120
um i'll talk about all the changes we

00:14:24,959 --> 00:14:28,639
made a little bit later

00:14:27,120 --> 00:14:31,680
but there's also some things that we

00:14:28,639 --> 00:14:33,279
can't do earlier i mentioned that

00:14:31,680 --> 00:14:35,519
we couldn't make really big sweeping

00:14:33,279 --> 00:14:37,279
changes but like there's actually

00:14:35,519 --> 00:14:38,720
slightly more specific things

00:14:37,279 --> 00:14:40,240
some of them are based on practical

00:14:38,720 --> 00:14:40,639
limitations and some of them are based

00:14:40,240 --> 00:14:43,199
on

00:14:40,639 --> 00:14:44,800
decisions that we've made so for example

00:14:43,199 --> 00:14:47,040
um the coherence rules

00:14:44,800 --> 00:14:48,800
can't change across conditions if you're

00:14:47,040 --> 00:14:50,880
not familiar a coherence rule

00:14:48,800 --> 00:14:52,560
says like if a tight implements a trait

00:14:50,880 --> 00:14:54,079
is it allowed to implement that trait or

00:14:52,560 --> 00:14:55,519
not like do you get a compiler error

00:14:54,079 --> 00:14:58,639
when you try to compile

00:14:55,519 --> 00:15:00,079
a trait implementation for a type so um

00:14:58,639 --> 00:15:00,959
you know a common example of this rule

00:15:00,079 --> 00:15:04,320
being broken

00:15:00,959 --> 00:15:05,680
is that if i had say um a type that's

00:15:04,320 --> 00:15:06,320
defined in the standard library like

00:15:05,680 --> 00:15:08,480
string

00:15:06,320 --> 00:15:10,399
and i have a type that's defined in a

00:15:08,480 --> 00:15:12,800
third party package it's not mine

00:15:10,399 --> 00:15:14,959
say maybe like surday i can't define

00:15:12,800 --> 00:15:16,720
surday serialize for a string because

00:15:14,959 --> 00:15:18,880
it's not my trait it's not my type

00:15:16,720 --> 00:15:20,240
so that doesn't work if i had made my

00:15:18,880 --> 00:15:22,320
own string type then i would be allowed

00:15:20,240 --> 00:15:24,160
to implement sir day's trait for it

00:15:22,320 --> 00:15:25,680
and if i implemented my own trait i'd be

00:15:24,160 --> 00:15:26,160
allowed to implement it on the standard

00:15:25,680 --> 00:15:28,000
library

00:15:26,160 --> 00:15:29,519
string but i have to own either one of

00:15:28,000 --> 00:15:30,800
the traits or the types the rules are a

00:15:29,519 --> 00:15:32,480
little more complicated than that but

00:15:30,800 --> 00:15:33,519
like that's the gist of it that's the

00:15:32,480 --> 00:15:35,040
the biggest thing

00:15:33,519 --> 00:15:37,040
so that's not allowed to change we

00:15:35,040 --> 00:15:38,079
couldn't say relax them in one edition

00:15:37,040 --> 00:15:40,079
but not in the other

00:15:38,079 --> 00:15:41,199
and that's because coherence rules are

00:15:40,079 --> 00:15:43,440
kind of global

00:15:41,199 --> 00:15:45,680
and those rules happen across different

00:15:43,440 --> 00:15:47,519
crates so if we had different rules for

00:15:45,680 --> 00:15:49,199
different parts of your program

00:15:47,519 --> 00:15:50,959
that would be extremely hard to

00:15:49,199 --> 00:15:54,320
implement very confusing

00:15:50,959 --> 00:15:56,000
and possibly just unsound like it's not

00:15:54,320 --> 00:15:57,920
kind of a thing that you're able to do

00:15:56,000 --> 00:15:59,600
for all of those sort of reasons so

00:15:57,920 --> 00:16:00,800
occurrence rules have to act globally

00:15:59,600 --> 00:16:02,480
and so therefore they kind of have to

00:16:00,800 --> 00:16:03,040
stay the same in every edition no matter

00:16:02,480 --> 00:16:06,320
what

00:16:03,040 --> 00:16:07,360
um that's a trick secondly another thing

00:16:06,320 --> 00:16:08,800
that people

00:16:07,360 --> 00:16:10,240
sort of don't always appreciate is that

00:16:08,800 --> 00:16:11,519
we can't make breaking changes to the

00:16:10,240 --> 00:16:13,040
standard library

00:16:11,519 --> 00:16:14,720
and intuitively you're like wait if i

00:16:13,040 --> 00:16:15,360
can change crates standard libraries

00:16:14,720 --> 00:16:17,440
just to create

00:16:15,360 --> 00:16:19,040
like why not well i mean it is just

00:16:17,440 --> 00:16:21,440
great but it's also kind of not just

00:16:19,040 --> 00:16:23,040
great you get one copy of the standard

00:16:21,440 --> 00:16:26,079
library for your whole program

00:16:23,040 --> 00:16:30,160
and so if you had a dependency that used

00:16:26,079 --> 00:16:33,839
uh rus 2018 and then you use rest 2015

00:16:30,160 --> 00:16:35,839
say um then you would need both

00:16:33,839 --> 00:16:36,959
copies so it doesn't like really work

00:16:35,839 --> 00:16:38,560
that way exactly

00:16:36,959 --> 00:16:40,800
so we're able to sort of deprecate

00:16:38,560 --> 00:16:43,680
things but we're not able to remove them

00:16:40,800 --> 00:16:45,680
um and there's some talk of maybe having

00:16:43,680 --> 00:16:46,160
some sort of visibility situation where

00:16:45,680 --> 00:16:48,079
like

00:16:46,160 --> 00:16:49,279
they exist but there's visibility rules

00:16:48,079 --> 00:16:51,600
where this is like only allowed to be

00:16:49,279 --> 00:16:53,600
seen in 2018 versus 2015.

00:16:51,600 --> 00:16:55,600
those are proposals and they're not like

00:16:53,600 --> 00:16:57,279
real yet so you know this is like kind

00:16:55,600 --> 00:16:59,279
of half a true technical invitation and

00:16:57,279 --> 00:17:01,600
half a sort of social limitation

00:16:59,279 --> 00:17:04,319
um somebody asked a question on twitch

00:17:01,600 --> 00:17:06,880
um how does a deprecated feature move

00:17:04,319 --> 00:17:07,919
from deprecated to like removed and can

00:17:06,880 --> 00:17:11,839
that be done between

00:17:07,919 --> 00:17:14,799
editions so one interesting thing

00:17:11,839 --> 00:17:16,839
about this is that some of this stuff is

00:17:14,799 --> 00:17:19,520
kind of up in the air

00:17:16,839 --> 00:17:22,559
policy-wise-ish basically

00:17:19,520 --> 00:17:24,319
like things cannot actually error on the

00:17:22,559 --> 00:17:26,079
same edition so like usually the way you

00:17:24,319 --> 00:17:26,880
think about it is something becomes a

00:17:26,079 --> 00:17:29,679
warning

00:17:26,880 --> 00:17:31,280
in the old edition and then an error in

00:17:29,679 --> 00:17:33,200
the new edition

00:17:31,280 --> 00:17:34,400
and the original rfc talks a little bit

00:17:33,200 --> 00:17:37,120
about um

00:17:34,400 --> 00:17:38,720
code that's warning free on the first

00:17:37,120 --> 00:17:40,240
edition should compile

00:17:38,720 --> 00:17:42,320
maybe you'll have new warnings but it

00:17:40,240 --> 00:17:44,000
won't break on the second edition

00:17:42,320 --> 00:17:45,440
but like if there's warnings in your

00:17:44,000 --> 00:17:46,559
first edition code maybe the second

00:17:45,440 --> 00:17:48,559
edition would break

00:17:46,559 --> 00:17:49,760
um i'm going to talk a little bit more

00:17:48,559 --> 00:17:52,160
about this at the end

00:17:49,760 --> 00:17:52,799
because the exact policy is like a thing

00:17:52,160 --> 00:17:55,760
that we're

00:17:52,799 --> 00:17:56,960
talking about so um yeah the the rules

00:17:55,760 --> 00:17:58,640
are slightly up in the air but

00:17:56,960 --> 00:17:59,679
originally that's what the intention was

00:17:58,640 --> 00:18:01,039
was that like

00:17:59,679 --> 00:18:02,559
you introduce warnings in the first

00:18:01,039 --> 00:18:03,200
edition you remove them in the second

00:18:02,559 --> 00:18:04,240
edition

00:18:03,200 --> 00:18:06,880
there's some questions about whether or

00:18:04,240 --> 00:18:08,480
not that's like too fast or

00:18:06,880 --> 00:18:10,559
you know maybe we should like require a

00:18:08,480 --> 00:18:11,919
whole edition to go by like we require

00:18:10,559 --> 00:18:13,120
language features to wait for a whole

00:18:11,919 --> 00:18:14,799
release in

00:18:13,120 --> 00:18:15,840
nightly before we're able to stabilize

00:18:14,799 --> 00:18:16,480
them for example there's kind of a

00:18:15,840 --> 00:18:18,799
minotaur

00:18:16,480 --> 00:18:20,400
mandatory minimum waiting period so

00:18:18,799 --> 00:18:21,440
maybe there would be a good mandatory

00:18:20,400 --> 00:18:24,480
waiting period for

00:18:21,440 --> 00:18:26,799
deprecations um but uh yeah

00:18:24,480 --> 00:18:29,120
so i hope that answers enough of your

00:18:26,799 --> 00:18:32,559
question uh hey jared

00:18:29,120 --> 00:18:35,120
um but i'll talk about a little more um

00:18:32,559 --> 00:18:37,120
okay so why do we have these

00:18:35,120 --> 00:18:38,400
restrictions like on some level like i

00:18:37,120 --> 00:18:39,919
talked a little bit about some of them

00:18:38,400 --> 00:18:41,520
with like there's one crate everywhere

00:18:39,919 --> 00:18:43,600
but let's get into some details and i

00:18:41,520 --> 00:18:46,320
think this matters because this also

00:18:43,600 --> 00:18:47,440
really helps you understand like why

00:18:46,320 --> 00:18:48,559
certain things are allowed and why

00:18:47,440 --> 00:18:50,000
certain things aren't allowed

00:18:48,559 --> 00:18:51,679
and it's also just kind of fun to talk

00:18:50,000 --> 00:18:54,320
about the compiler and how it works

00:18:51,679 --> 00:18:56,080
so um this next section is going to be

00:18:54,320 --> 00:18:57,440
about editions i swear but it's also

00:18:56,080 --> 00:18:58,640
kind of how the compiler works because i

00:18:57,440 --> 00:18:59,520
think that's interesting and kind of

00:18:58,640 --> 00:19:02,960
matters

00:18:59,520 --> 00:19:04,559
so um rust is currently

00:19:02,960 --> 00:19:06,080
sorta kinda there's an asterisk here i'm

00:19:04,559 --> 00:19:07,760
gonna get to it later what's called a

00:19:06,080 --> 00:19:09,919
multi-pass compiler

00:19:07,760 --> 00:19:11,520
and so um this is like a classic

00:19:09,919 --> 00:19:13,039
architecture for compilers if you take a

00:19:11,520 --> 00:19:14,799
compiler class in your university this

00:19:13,039 --> 00:19:16,000
is how they teach you compilers work

00:19:14,799 --> 00:19:17,919
a lot of compilers in the world are

00:19:16,000 --> 00:19:18,799
implemented this way basically what

00:19:17,919 --> 00:19:22,080
happens is

00:19:18,799 --> 00:19:24,960
um there are this concept of passes so

00:19:22,080 --> 00:19:26,240
you can you take in a source code and

00:19:24,960 --> 00:19:28,000
then you spit out something

00:19:26,240 --> 00:19:30,160
um a lot of older compilers are called

00:19:28,000 --> 00:19:31,360
one pass compilers because they directly

00:19:30,160 --> 00:19:34,720
turn the code

00:19:31,360 --> 00:19:36,400
into the actual like binary code

00:19:34,720 --> 00:19:37,840
so if you think about like you used to

00:19:36,400 --> 00:19:39,679
have to be a lot of older languages

00:19:37,840 --> 00:19:41,280
required you to define a variable at the

00:19:39,679 --> 00:19:42,640
start of functions for example

00:19:41,280 --> 00:19:44,799
that was because they had one past

00:19:42,640 --> 00:19:47,360
compilers and so they needed to emit

00:19:44,799 --> 00:19:52,880
the stack space for those variables uh

00:19:47,360 --> 00:19:54,799
you know first

00:19:52,880 --> 00:19:56,160
okay it seems to be back cool i don't

00:19:54,799 --> 00:19:57,679
know why that's happening um

00:19:56,160 --> 00:19:59,200
there's probably something on my end but

00:19:57,679 --> 00:20:01,679
anyway uh

00:19:59,200 --> 00:20:03,039
so yeah so older compilers are one pass

00:20:01,679 --> 00:20:03,440
that's also why a lot of them were super

00:20:03,039 --> 00:20:04,400
fast

00:20:03,440 --> 00:20:06,320
because they didn't do a lot of this

00:20:04,400 --> 00:20:08,240
stuff but uh over time you know we

00:20:06,320 --> 00:20:08,960
needed things to to be more complicated

00:20:08,240 --> 00:20:10,640
and so then

00:20:08,960 --> 00:20:12,240
people developed multi-pass compilers

00:20:10,640 --> 00:20:13,679
where you would do multiple steps so

00:20:12,240 --> 00:20:14,720
you'd iterate over the source code in

00:20:13,679 --> 00:20:18,000
multiple ways

00:20:14,720 --> 00:20:18,960
and that's how it's produced so in the

00:20:18,000 --> 00:20:20,799
rust compiler

00:20:18,960 --> 00:20:22,559
it's like multi-pass architecture as it

00:20:20,799 --> 00:20:25,039
traditionally existed

00:20:22,559 --> 00:20:25,679
and is similar to many other compilers

00:20:25,039 --> 00:20:27,440
basically of

00:20:25,679 --> 00:20:29,120
input being source code and it kind of

00:20:27,440 --> 00:20:29,600
goes through each of these steps in turn

00:20:29,120 --> 00:20:31,440
so

00:20:29,600 --> 00:20:33,280
the first one takes the source code and

00:20:31,440 --> 00:20:35,039
it creates an ast out of it which is

00:20:33,280 --> 00:20:37,280
an abstract syntax tree and then it

00:20:35,039 --> 00:20:38,799
takes that ast and it produces here

00:20:37,280 --> 00:20:40,640
which is high level ir

00:20:38,799 --> 00:20:43,039
and it takes the high level rir and it

00:20:40,640 --> 00:20:44,400
produces mir which is the mid-level ir

00:20:43,039 --> 00:20:46,960
and then it takes the mid-level ir and

00:20:44,400 --> 00:20:47,280
it produces mlvm ir and then lvm takes

00:20:46,960 --> 00:20:48,960
that

00:20:47,280 --> 00:20:50,720
and produces the final binary so there's

00:20:48,960 --> 00:20:52,400
a bunch of these steps and within these

00:20:50,720 --> 00:20:53,840
steps there's kind of smaller steps

00:20:52,400 --> 00:20:54,720
and all this sort of like happens we're

00:20:53,840 --> 00:20:57,039
going to talk about this in a little

00:20:54,720 --> 00:20:59,280
more detail

00:20:57,039 --> 00:21:01,039
so compilers traditionally are kind of

00:20:59,280 --> 00:21:02,320
produced in this three different phases

00:21:01,039 --> 00:21:03,840
that's why you have these passes you do

00:21:02,320 --> 00:21:04,320
the full pass and the full pass and full

00:21:03,840 --> 00:21:06,320
pass

00:21:04,320 --> 00:21:08,159
all three steps first one is like a

00:21:06,320 --> 00:21:10,480
lexical or syntactic analysis

00:21:08,159 --> 00:21:11,520
so is your code well formed this is like

00:21:10,480 --> 00:21:14,080
grammar rules

00:21:11,520 --> 00:21:14,720
so you know does the sentence i'm saying

00:21:14,080 --> 00:21:17,120
follow

00:21:14,720 --> 00:21:19,039
proper grammar or not um does your

00:21:17,120 --> 00:21:19,679
program follow the languages grammar or

00:21:19,039 --> 00:21:21,600
not

00:21:19,679 --> 00:21:22,880
secondly is semantic analysis which does

00:21:21,600 --> 00:21:25,200
this code make sense

00:21:22,880 --> 00:21:26,640
so for example you know i could i could

00:21:25,200 --> 00:21:29,120
say like uh you know

00:21:26,640 --> 00:21:30,000
this sentence is false and that sentence

00:21:29,120 --> 00:21:31,760
is grammatically

00:21:30,000 --> 00:21:33,120
correct so it passes lexical or

00:21:31,760 --> 00:21:34,880
syntactic analysis

00:21:33,120 --> 00:21:36,559
but semantically it's very unclear what

00:21:34,880 --> 00:21:38,559
it means because if it's

00:21:36,559 --> 00:21:40,240
true then it's saying it's false which

00:21:38,559 --> 00:21:40,799
means it's false which means it's not

00:21:40,240 --> 00:21:43,200
true

00:21:40,799 --> 00:21:44,480
so there's some reflexivity there it's

00:21:43,200 --> 00:21:44,960
just the first example i could come up

00:21:44,480 --> 00:21:46,320
with

00:21:44,960 --> 00:21:48,159
but like you know you could imagine

00:21:46,320 --> 00:21:48,720
gibberish for example that uses all real

00:21:48,159 --> 00:21:50,480
words

00:21:48,720 --> 00:21:51,840
maybe it's structurally correct but it

00:21:50,480 --> 00:21:54,159
doesn't actually make any sense

00:21:51,840 --> 00:21:55,200
um so semantic analysis makes sure that

00:21:54,159 --> 00:21:57,520
the thing that you've said

00:21:55,200 --> 00:21:59,600
is sensical and finally code generation

00:21:57,520 --> 00:22:01,360
this does not really have a

00:21:59,600 --> 00:22:03,280
an analog in existing languages i guess

00:22:01,360 --> 00:22:04,240
this is the the vocal cords turning it

00:22:03,280 --> 00:22:06,480
into sound

00:22:04,240 --> 00:22:07,919
uh maybe would be the analogy i'm

00:22:06,480 --> 00:22:09,919
stretching this a little too far

00:22:07,919 --> 00:22:11,039
but uh once we verify that everything

00:22:09,919 --> 00:22:13,120
works and makes sense

00:22:11,039 --> 00:22:14,799
we actually produce the binary finally

00:22:13,120 --> 00:22:16,080
out of it

00:22:14,799 --> 00:22:17,200
this step in itself has a bunch of

00:22:16,080 --> 00:22:18,960
different passes for example we talk

00:22:17,200 --> 00:22:20,799
about optimization passes

00:22:18,960 --> 00:22:22,720
and sort of run and generate code you

00:22:20,799 --> 00:22:23,600
know faster so that all happens in this

00:22:22,720 --> 00:22:24,880
kind of stage

00:22:23,600 --> 00:22:26,960
but uh you know these are kind of the

00:22:24,880 --> 00:22:28,480
three big giant steps um

00:22:26,960 --> 00:22:30,640
if you've ever wondered how cargo check

00:22:28,480 --> 00:22:32,480
works for example cargo check will run

00:22:30,640 --> 00:22:33,760
the lexical and syntactic analysis and

00:22:32,480 --> 00:22:35,840
the semantic analysis

00:22:33,760 --> 00:22:37,280
but won't generate any code so this is

00:22:35,840 --> 00:22:39,200
an example of how understanding this can

00:22:37,280 --> 00:22:41,520
help you practically as a rust developer

00:22:39,200 --> 00:22:43,280
use cargo check to check your code makes

00:22:41,520 --> 00:22:43,520
sense but you don't actually want to run

00:22:43,280 --> 00:22:45,120
it

00:22:43,520 --> 00:22:46,559
you can save yourself a lot of time by

00:22:45,120 --> 00:22:47,200
not making the compiler do code

00:22:46,559 --> 00:22:49,440
generation

00:22:47,200 --> 00:22:51,280
so this is like one example of how this

00:22:49,440 --> 00:22:53,520
architecture lets you you know do less

00:22:51,280 --> 00:22:54,880
sometimes

00:22:53,520 --> 00:22:56,559
so there's kind of like two sorts of

00:22:54,880 --> 00:22:58,559
these steps between these

00:22:56,559 --> 00:22:59,840
situations um and this is kind of some

00:22:58,559 --> 00:23:00,640
compiler jargon that you may be

00:22:59,840 --> 00:23:02,720
interested in

00:23:00,640 --> 00:23:04,159
so uh one of them is called lowering and

00:23:02,720 --> 00:23:05,760
so that's the word that you use when you

00:23:04,159 --> 00:23:07,039
talk about going from one form to the

00:23:05,760 --> 00:23:10,640
other so for example

00:23:07,039 --> 00:23:12,960
mir is lowered into lvmir or the ast is

00:23:10,640 --> 00:23:14,799
lowered into here

00:23:12,960 --> 00:23:16,880
and the reason it's called lowering is

00:23:14,799 --> 00:23:19,039
that at every step along the way

00:23:16,880 --> 00:23:20,559
things get simpler and we throw away

00:23:19,039 --> 00:23:24,159
things that we've already validated

00:23:20,559 --> 00:23:27,760
which makes future steps easier so

00:23:24,159 --> 00:23:30,240
for example um

00:23:27,760 --> 00:23:31,600
mir does not have the concept of

00:23:30,240 --> 00:23:33,360
complicated fancy loops

00:23:31,600 --> 00:23:35,520
so like for loops for example don't

00:23:33,360 --> 00:23:37,600
exist in mirror what happens is

00:23:35,520 --> 00:23:39,120
the previous steps in the compiler take

00:23:37,600 --> 00:23:40,640
your for loop and they turn it into a

00:23:39,120 --> 00:23:42,880
while loop with a break in it

00:23:40,640 --> 00:23:43,919
and so um mirror is able to understand a

00:23:42,880 --> 00:23:45,600
while loop with a break

00:23:43,919 --> 00:23:47,120
so we've sort of removed a construct

00:23:45,600 --> 00:23:48,320
from the language when we've gotten to

00:23:47,120 --> 00:23:49,840
the lower step

00:23:48,320 --> 00:23:51,440
and that means each successive step is

00:23:49,840 --> 00:23:52,159
simpler and this definitely really

00:23:51,440 --> 00:23:53,520
matters

00:23:52,159 --> 00:23:54,720
um and that's why it's called lowering

00:23:53,520 --> 00:23:55,679
is because you're kind of like breaking

00:23:54,720 --> 00:23:56,960
down

00:23:55,679 --> 00:23:59,039
what is happening into simpler and

00:23:56,960 --> 00:24:00,159
simpler things and then finally is a

00:23:59,039 --> 00:24:01,679
step called a pass

00:24:00,159 --> 00:24:03,520
which basically means some sort of check

00:24:01,679 --> 00:24:04,320
that validates that your program is well

00:24:03,520 --> 00:24:05,679
formed

00:24:04,320 --> 00:24:07,279
and does not necessarily do a

00:24:05,679 --> 00:24:08,080
transformation although technically it

00:24:07,279 --> 00:24:10,880
can

00:24:08,080 --> 00:24:12,480
so for example type checking is a pass

00:24:10,880 --> 00:24:14,159
on your code so it runs over your code

00:24:12,480 --> 00:24:15,840
and make sure everything makes sense

00:24:14,159 --> 00:24:18,240
a lot of semantic analyses are kind of

00:24:15,840 --> 00:24:20,240
passes and sometimes they will do

00:24:18,240 --> 00:24:21,679
transformations this is like whenever

00:24:20,240 --> 00:24:24,559
basically like okay

00:24:21,679 --> 00:24:25,840
you know i'm going to take your for loop

00:24:24,559 --> 00:24:26,240
and i'm going to rewrite it as a while

00:24:25,840 --> 00:24:29,200
loop

00:24:26,240 --> 00:24:29,919
that happens first as a pass because

00:24:29,200 --> 00:24:32,400
inside of

00:24:29,919 --> 00:24:34,480
here i believe and then the lowering

00:24:32,400 --> 00:24:36,080
step is what turns that simpler form of

00:24:34,480 --> 00:24:38,720
here into mirror so they kind of like

00:24:36,080 --> 00:24:38,720
work together

00:24:38,960 --> 00:24:42,720
okay so this is some example of actual

00:24:41,360 --> 00:24:45,360
code going through these steps

00:24:42,720 --> 00:24:47,120
and i i did this about a year ago so the

00:24:45,360 --> 00:24:48,159
samples are a little dated because of

00:24:47,120 --> 00:24:49,200
the fact that the compiler output

00:24:48,159 --> 00:24:51,360
changes all the time

00:24:49,200 --> 00:24:52,640
but conceptually it's the same so i

00:24:51,360 --> 00:24:53,600
figured it being outdated is actually a

00:24:52,640 --> 00:24:55,039
little better because you shouldn't get

00:24:53,600 --> 00:24:57,600
hung up on the specifics

00:24:55,039 --> 00:24:59,200
so for example let's talk about taking

00:24:57,600 --> 00:25:00,720
code and producing an ast

00:24:59,200 --> 00:25:03,919
if we have this function called plus one

00:25:00,720 --> 00:25:05,039
takes i32 adds one to it returns it

00:25:03,919 --> 00:25:07,760
we could actually ask the compiler to

00:25:05,039 --> 00:25:08,640
print out the json version of the ast

00:25:07,760 --> 00:25:09,919
because again these are all data

00:25:08,640 --> 00:25:11,520
structures inside the compiler so they

00:25:09,919 --> 00:25:12,720
don't really have a text representation

00:25:11,520 --> 00:25:14,559
but you can like print them out in

00:25:12,720 --> 00:25:16,400
things like json so for example

00:25:14,559 --> 00:25:17,919
plus one a little bit of it looks like

00:25:16,400 --> 00:25:20,559
this so there's a statements

00:25:17,919 --> 00:25:21,360
and that's an array of nodes and inside

00:25:20,559 --> 00:25:23,120
of there

00:25:21,360 --> 00:25:24,799
each node has a variance so this is like

00:25:23,120 --> 00:25:26,400
an expression and then

00:25:24,799 --> 00:25:28,159
you know it's like a binary expression

00:25:26,400 --> 00:25:29,600
that's add you can kind of see how these

00:25:28,159 --> 00:25:32,480
little bits all fit together

00:25:29,600 --> 00:25:34,159
and then you know um we're adding x and

00:25:32,480 --> 00:25:35,679
it keeps going on to talk about adding

00:25:34,159 --> 00:25:37,600
one and stuff so you kind of get this

00:25:35,679 --> 00:25:40,880
this data structure view of your code

00:25:37,600 --> 00:25:42,960
and that's what ast looks like

00:25:40,880 --> 00:25:44,320
so here you know we take our statements

00:25:42,960 --> 00:25:45,120
and the statements refers to an

00:25:44,320 --> 00:25:47,120
expression

00:25:45,120 --> 00:25:48,480
expression refers to a binary expression

00:25:47,120 --> 00:25:49,919
the binary expression says hey we have

00:25:48,480 --> 00:25:52,400
an add expression that adds

00:25:49,919 --> 00:25:53,760
x and one together so this is kind of

00:25:52,400 --> 00:25:55,520
like why it's called a tree

00:25:53,760 --> 00:25:56,960
is because if you see there's like this

00:25:55,520 --> 00:25:58,080
root which is the statements and then

00:25:56,960 --> 00:26:00,320
there's the

00:25:58,080 --> 00:26:01,919
branches and leaves um that happen to

00:26:00,320 --> 00:26:05,120
build a tree so this is like

00:26:01,919 --> 00:26:07,279
what an ast kind of looks like visually

00:26:05,120 --> 00:26:08,320
and so yeah fundamentally the ast is a

00:26:07,279 --> 00:26:10,000
data structure

00:26:08,320 --> 00:26:12,159
and it's the way that our code looks

00:26:10,000 --> 00:26:13,919
written in words but is a data structure

00:26:12,159 --> 00:26:15,440
this means it's easier to manipulate

00:26:13,919 --> 00:26:16,000
like you know if you just have a data

00:26:15,440 --> 00:26:17,440
structure

00:26:16,000 --> 00:26:19,039
you can just manipulate it like that's

00:26:17,440 --> 00:26:20,960
what they're there for but if you had to

00:26:19,039 --> 00:26:22,400
do it on the like textual representation

00:26:20,960 --> 00:26:24,480
of your code it'd be much harder

00:26:22,400 --> 00:26:26,000
so the idea is that we break the text

00:26:24,480 --> 00:26:27,360
down into a data structure and then we

00:26:26,000 --> 00:26:28,559
do all our operations on those data

00:26:27,360 --> 00:26:31,679
structures

00:26:28,559 --> 00:26:33,440
so from the ast we move on to the here

00:26:31,679 --> 00:26:34,880
and so here is short for a high level

00:26:33,440 --> 00:26:37,200
intermediate representation

00:26:34,880 --> 00:26:38,400
and this basically is like doing form

00:26:37,200 --> 00:26:40,640
this sort of checks

00:26:38,400 --> 00:26:42,080
what i mean by formness is like you know

00:26:40,640 --> 00:26:43,039
have you imported all the stuff that

00:26:42,080 --> 00:26:46,000
you've used

00:26:43,039 --> 00:26:46,799
um things like that and some things are

00:26:46,000 --> 00:26:48,559
simplified

00:26:46,799 --> 00:26:50,080
so for example in my understanding here

00:26:48,559 --> 00:26:51,440
does not have uh

00:26:50,080 --> 00:26:53,600
you know like use statements they get

00:26:51,440 --> 00:26:56,640
turned into the elaborated like full

00:26:53,600 --> 00:26:59,120
versions of all the types um

00:26:56,640 --> 00:27:00,559
so an example of what uh you know kind

00:26:59,120 --> 00:27:01,520
of like the sort of transformations that

00:27:00,559 --> 00:27:03,600
happens here

00:27:01,520 --> 00:27:04,880
um this is a very simple for loop

00:27:03,600 --> 00:27:06,240
there's a reason i referenced for loop

00:27:04,880 --> 00:27:08,400
several times earlier today

00:27:06,240 --> 00:27:09,679
where we take a vector of five integers

00:27:08,400 --> 00:27:10,159
and we loop over it printing them all

00:27:09,679 --> 00:27:12,799
out

00:27:10,159 --> 00:27:14,240
so the ast would take that literal code

00:27:12,799 --> 00:27:16,559
as written and represent it that way

00:27:14,240 --> 00:27:18,559
but when it gets lowered into here it

00:27:16,559 --> 00:27:21,440
ends up being something more like this

00:27:18,559 --> 00:27:22,960
so this is like still rust code that you

00:27:21,440 --> 00:27:25,200
could write in theory

00:27:22,960 --> 00:27:26,159
um but uh you'll notice the for loop is

00:27:25,200 --> 00:27:27,760
totally gone

00:27:26,159 --> 00:27:29,679
we now have a loop with a match

00:27:27,760 --> 00:27:31,360
statement inside and where we turn

00:27:29,679 --> 00:27:32,720
the thing that we're iterating over into

00:27:31,360 --> 00:27:35,360
an iterator and we

00:27:32,720 --> 00:27:36,960
you know call next on it repeatedly um

00:27:35,360 --> 00:27:37,760
until the body of the loop happens and

00:27:36,960 --> 00:27:39,120
all these things

00:27:37,760 --> 00:27:40,559
so you can see how it's kind of like

00:27:39,120 --> 00:27:41,679
simpler in the sense that there are less

00:27:40,559 --> 00:27:42,960
language constructs

00:27:41,679 --> 00:27:44,240
but it's more complicated in the sense

00:27:42,960 --> 00:27:45,520
that there's more code because like

00:27:44,240 --> 00:27:47,039
that's the reason we write

00:27:45,520 --> 00:27:48,320
in the higher level stuff in the first

00:27:47,039 --> 00:27:49,679
place is because it's easier to

00:27:48,320 --> 00:27:51,360
understand for humans

00:27:49,679 --> 00:27:54,000
but the computer you know having less

00:27:51,360 --> 00:27:57,360
things makes the analyses much simpler

00:27:54,000 --> 00:27:59,520
so we do that kind of stuff most checks

00:27:57,360 --> 00:28:02,159
in the compiler today are done on here

00:27:59,520 --> 00:28:03,840
um at least in my understanding uh so

00:28:02,159 --> 00:28:05,840
here was the original rust ir that

00:28:03,840 --> 00:28:06,640
existed so the the first version of the

00:28:05,840 --> 00:28:08,399
compiler

00:28:06,640 --> 00:28:10,480
or maybe first is a little strong but

00:28:08,399 --> 00:28:12,799
like for a very long time the compiler

00:28:10,480 --> 00:28:14,720
uh turned everything into here and then

00:28:12,799 --> 00:28:16,480
it went to lvm ir from there

00:28:14,720 --> 00:28:18,080
so uh you know it's kind of like the og

00:28:16,480 --> 00:28:19,279
thing so a lot of things are written in

00:28:18,080 --> 00:28:21,360
terms of here

00:28:19,279 --> 00:28:22,480
um so two things that are still written

00:28:21,360 --> 00:28:25,440
in type check or

00:28:22,480 --> 00:28:26,799
in here are type check which is like do

00:28:25,440 --> 00:28:28,240
all the types make sense and have you

00:28:26,799 --> 00:28:30,720
not made any type errors

00:28:28,240 --> 00:28:32,320
and then finally method lookup so that's

00:28:30,720 --> 00:28:34,159
done at compile time instead of in some

00:28:32,320 --> 00:28:35,440
dynamic languages methods lookup is like

00:28:34,159 --> 00:28:37,360
a dynamic process

00:28:35,440 --> 00:28:38,880
but uh basically you know kind of look

00:28:37,360 --> 00:28:40,399
at like you know what

00:28:38,880 --> 00:28:42,159
what trait are you actually calling when

00:28:40,399 --> 00:28:43,279
you call a method or is there a trait as

00:28:42,159 --> 00:28:44,880
an inherent method

00:28:43,279 --> 00:28:46,799
those kind of things these are all done

00:28:44,880 --> 00:28:48,720
on here

00:28:46,799 --> 00:28:50,799
then we move from here to mirror and

00:28:48,720 --> 00:28:52,240
mirror became the subject of a lot of

00:28:50,799 --> 00:28:53,440
discussion in the rust world so you may

00:28:52,240 --> 00:28:54,480
have heard about it over the last couple

00:28:53,440 --> 00:28:56,640
years

00:28:54,480 --> 00:28:58,399
mir is ultimately about control flow so

00:28:56,640 --> 00:28:59,600
here is kind of represented our code in

00:28:58,399 --> 00:29:02,000
the way that we wrote it

00:28:59,600 --> 00:29:02,880
but mir totally rewrites it to be in a

00:29:02,000 --> 00:29:04,559
simpler form

00:29:02,880 --> 00:29:06,240
but also one that's based on a control

00:29:04,559 --> 00:29:08,720
flow graph is the term

00:29:06,240 --> 00:29:09,520
rather than an ast which is the tree so

00:29:08,720 --> 00:29:12,240
going from a tree

00:29:09,520 --> 00:29:13,840
to a graph is uh you know helpful for

00:29:12,240 --> 00:29:15,919
certain kinds of analyses

00:29:13,840 --> 00:29:17,760
um specifically like the graph

00:29:15,919 --> 00:29:19,200
represents the way that the control

00:29:17,760 --> 00:29:20,880
goes through your programs like which

00:29:19,200 --> 00:29:23,840
statement executes in which order

00:29:20,880 --> 00:29:26,480
and um that matters because uh for

00:29:23,840 --> 00:29:27,360
example non-lexical lifetimes it needs

00:29:26,480 --> 00:29:30,320
to know how

00:29:27,360 --> 00:29:31,039
the execution flows within your program

00:29:30,320 --> 00:29:33,679
to work

00:29:31,039 --> 00:29:35,279
and so it was very difficult to write

00:29:33,679 --> 00:29:37,120
that pass on here

00:29:35,279 --> 00:29:39,039
so like this is a practical example of

00:29:37,120 --> 00:29:40,159
why this stuff matters is that we had to

00:29:39,039 --> 00:29:42,640
invent mir

00:29:40,159 --> 00:29:43,360
to make non-lexical lifetimes feasible

00:29:42,640 --> 00:29:44,880
because

00:29:43,360 --> 00:29:46,559
we needed to be able to encode that flow

00:29:44,880 --> 00:29:47,039
control to be able to make it actually

00:29:46,559 --> 00:29:48,960
happen

00:29:47,039 --> 00:29:50,559
and i say we because i'm on the team but

00:29:48,960 --> 00:29:52,240
like i did none of this work to be

00:29:50,559 --> 00:29:53,440
absolutely clear about it a lot of other

00:29:52,240 --> 00:29:56,000
really great people

00:29:53,440 --> 00:29:56,000
made it happen

00:29:57,120 --> 00:30:00,559
man i don't know what's up with my audio

00:29:58,399 --> 00:30:01,840
dropping anyway so another interesting

00:30:00,559 --> 00:30:02,559
thing about mirror beyond the control

00:30:01,840 --> 00:30:04,480
flow move

00:30:02,559 --> 00:30:05,840
is that it's kind of the core of rust so

00:30:04,480 --> 00:30:08,240
it's kind of like everything that's

00:30:05,840 --> 00:30:08,799
rusty about rust without any superfluous

00:30:08,240 --> 00:30:11,279
extra

00:30:08,799 --> 00:30:12,320
concepts so like i said earlier fancy

00:30:11,279 --> 00:30:14,399
loops are gone

00:30:12,320 --> 00:30:15,760
everything is purely loops and breaks i

00:30:14,399 --> 00:30:18,399
think i might even have go-to's

00:30:15,760 --> 00:30:19,679
if i remember correctly but um borrow

00:30:18,399 --> 00:30:21,360
checking is done here because

00:30:19,679 --> 00:30:22,960
like as i said not likes for lifetimes

00:30:21,360 --> 00:30:23,360
but kind of mirror is kind of like the

00:30:22,960 --> 00:30:25,679
core

00:30:23,360 --> 00:30:26,880
way that you know what makes rust rust

00:30:25,679 --> 00:30:28,399
and it's kind of like a

00:30:26,880 --> 00:30:30,960
the representation of the computer of

00:30:28,399 --> 00:30:32,720
what rust is like

00:30:30,960 --> 00:30:34,640
and as example of what mirror looks like

00:30:32,720 --> 00:30:36,480
if you dump out an example

00:30:34,640 --> 00:30:39,039
again this is a little old and it's like

00:30:36,480 --> 00:30:40,240
pseudo rust it's not actually rust code

00:30:39,039 --> 00:30:41,679
but it kind of looks like it again we're

00:30:40,240 --> 00:30:43,520
printing a data structure that doesn't

00:30:41,679 --> 00:30:45,360
have a real text representation

00:30:43,520 --> 00:30:46,720
so uh here you can see our add one

00:30:45,360 --> 00:30:49,679
function it declares

00:30:46,720 --> 00:30:50,720
two variables zero and two or one is the

00:30:49,679 --> 00:30:53,840
first parameter

00:30:50,720 --> 00:30:55,440
and in a bb 0 stands for basic block

00:30:53,840 --> 00:30:56,960
so to pay attention to control flow we

00:30:55,440 --> 00:30:57,440
have this idea of blocks and so it'll

00:30:56,960 --> 00:30:59,600
say hey

00:30:57,440 --> 00:31:01,600
storage live means that the second

00:30:59,600 --> 00:31:04,000
variable is live in this area

00:31:01,600 --> 00:31:05,440
which is an analysis happens it's about

00:31:04,000 --> 00:31:06,799
control flow it's too complicated for me

00:31:05,440 --> 00:31:07,600
to get into and i'm too far in the weeds

00:31:06,799 --> 00:31:09,039
already here

00:31:07,600 --> 00:31:10,399
um you could read the document compiler

00:31:09,039 --> 00:31:12,000
if you want to see all what's happening

00:31:10,399 --> 00:31:15,120
you can see our call to add

00:31:12,000 --> 00:31:16,159
um you know adds a constant one and our

00:31:15,120 --> 00:31:18,240
number two

00:31:16,159 --> 00:31:19,440
uh and then declares the storage is dead

00:31:18,240 --> 00:31:20,960
and then returns

00:31:19,440 --> 00:31:22,159
um this is kind of what mir looks like

00:31:20,960 --> 00:31:23,600
again not anything you ever have to

00:31:22,159 --> 00:31:24,880
worry about as a rust programmer but if

00:31:23,600 --> 00:31:25,679
you want to see how the compiler sees

00:31:24,880 --> 00:31:27,600
your code

00:31:25,679 --> 00:31:29,039
looking at mirror can be really useful

00:31:27,600 --> 00:31:30,399
um

00:31:29,039 --> 00:31:33,600
and then finally mirror gets lowered to

00:31:30,399 --> 00:31:34,880
llvmir lvm is a compiler toolkit that

00:31:33,600 --> 00:31:36,880
you can use to kind of like

00:31:34,880 --> 00:31:38,559
build stuff it's a vm in like the

00:31:36,880 --> 00:31:40,559
technical sense of vm but not in the way

00:31:38,559 --> 00:31:42,080
that everyone uses the word vm so

00:31:40,559 --> 00:31:44,159
it used to stand for low level virtual

00:31:42,080 --> 00:31:44,720
machine but the lvm project changed its

00:31:44,159 --> 00:31:46,720
name

00:31:44,720 --> 00:31:48,159
so that it no longer references virtual

00:31:46,720 --> 00:31:49,519
machines because that got too confusing

00:31:48,159 --> 00:31:53,120
to many people

00:31:49,519 --> 00:31:55,200
so basically uh what we do is

00:31:53,120 --> 00:31:56,159
uh optimizations and code generation are

00:31:55,200 --> 00:31:58,080
done by llvm

00:31:56,159 --> 00:32:00,240
for the most part there are a couple

00:31:58,080 --> 00:32:01,519
optimizations that happen in mir and

00:32:00,240 --> 00:32:03,679
uh we hope to do more of them in the

00:32:01,519 --> 00:32:05,360
future but uh rust would not be anywhere

00:32:03,679 --> 00:32:06,559
where it is today without all vm so it's

00:32:05,360 --> 00:32:08,320
very important to us

00:32:06,559 --> 00:32:09,600
and uh it kind of like is the lowest

00:32:08,320 --> 00:32:12,399
level of the compiler

00:32:09,600 --> 00:32:14,000
sort of operates uh you know lvm takes

00:32:12,399 --> 00:32:15,519
the compiler's output and produces the

00:32:14,000 --> 00:32:17,519
binary so we kind of like hand it off to

00:32:15,519 --> 00:32:20,799
that library as the last couple steps

00:32:17,519 --> 00:32:23,120
um uh andrew levrett

00:32:20,799 --> 00:32:23,919
sorry if i mispronounced your name uh is

00:32:23,120 --> 00:32:25,600
asking

00:32:23,919 --> 00:32:27,519
uh what is the timeline if there's one

00:32:25,600 --> 00:32:30,480
to get cindy support unstable

00:32:27,519 --> 00:32:30,960
so cmd is actually already unstable for

00:32:30,480 --> 00:32:34,080
rust

00:32:30,960 --> 00:32:35,120
but only the x86 versions so uh it's

00:32:34,080 --> 00:32:38,399
also the low level

00:32:35,120 --> 00:32:38,799
unsafe primitives um so i think maybe

00:32:38,399 --> 00:32:40,480
you

00:32:38,799 --> 00:32:41,919
either one don't know that's true which

00:32:40,480 --> 00:32:42,320
is totally fine but that does exist

00:32:41,919 --> 00:32:44,000
today

00:32:42,320 --> 00:32:45,760
or two you're talking about higher level

00:32:44,000 --> 00:32:47,279
cmd which is like what you would want to

00:32:45,760 --> 00:32:48,799
write as a regular programmer instead of

00:32:47,279 --> 00:32:50,320
the intrinsics

00:32:48,799 --> 00:32:52,480
i don't actually know that there's a

00:32:50,320 --> 00:32:53,440
group working on the higher level stuff

00:32:52,480 --> 00:32:55,679
right now

00:32:53,440 --> 00:32:56,960
the low liver stuff does work though on

00:32:55,679 --> 00:32:59,279
x86 at least

00:32:56,960 --> 00:33:00,720
and given arm's recent interest in rust

00:32:59,279 --> 00:33:02,640
i'm assuming that arm

00:33:00,720 --> 00:33:04,240
assembly stuff will be soon to follow i

00:33:02,640 --> 00:33:07,200
think maybe some of it already works

00:33:04,240 --> 00:33:08,720
but i'm not actually 100 sure um so yeah

00:33:07,200 --> 00:33:11,760
still more work to do there

00:33:08,720 --> 00:33:14,799
don't know the exact timeline yet

00:33:11,760 --> 00:33:16,399
a question by jam1 garner uh what would

00:33:14,799 --> 00:33:18,880
go to's be used for in mir

00:33:16,399 --> 00:33:20,880
just more complicated breaks um

00:33:18,880 --> 00:33:22,799
basically like you know

00:33:20,880 --> 00:33:24,320
structured programming is useful as the

00:33:22,799 --> 00:33:25,279
programmer like we write loops because

00:33:24,320 --> 00:33:26,000
we don't want to have to think in

00:33:25,279 --> 00:33:28,080
go-to's

00:33:26,000 --> 00:33:29,440
but go to's are conceptually simpler

00:33:28,080 --> 00:33:31,519
because they

00:33:29,440 --> 00:33:33,039
you know are allowed to do whatever and

00:33:31,519 --> 00:33:34,640
so um

00:33:33,039 --> 00:33:35,840
it's actually easier for the compiler to

00:33:34,640 --> 00:33:37,039
understand than the higher level

00:33:35,840 --> 00:33:38,960
constructs so

00:33:37,039 --> 00:33:40,159
um i actually like i think i want to

00:33:38,960 --> 00:33:41,440
emphasize like i don't work on the

00:33:40,159 --> 00:33:43,200
compiler myself so

00:33:41,440 --> 00:33:44,640
i believe that go to's exist but i don't

00:33:43,200 --> 00:33:47,120
actually 100 remember

00:33:44,640 --> 00:33:48,159
so i might be a little wrong there um so

00:33:47,120 --> 00:33:49,039
you should you know if you care about

00:33:48,159 --> 00:33:50,159
this topic you should look at the

00:33:49,039 --> 00:33:52,399
details a little more

00:33:50,159 --> 00:33:53,919
but i believe that that's the case um

00:33:52,399 --> 00:33:56,960
but i'm not sure

00:33:53,919 --> 00:33:58,640
um finally there's a question about

00:33:56,960 --> 00:34:00,080
working with rust and fuchsia i will

00:33:58,640 --> 00:34:01,360
talk about that towards the end because

00:34:00,080 --> 00:34:02,159
it's not relevant to this part of the

00:34:01,360 --> 00:34:04,880
conversation

00:34:02,159 --> 00:34:06,080
so uh i'll get back to you spacex jedi

00:34:04,880 --> 00:34:09,359
don't worry about it

00:34:06,080 --> 00:34:10,879
thank you for the question uh okay if

00:34:09,359 --> 00:34:11,280
you're curious about what lvmr looks

00:34:10,879 --> 00:34:13,040
like

00:34:11,280 --> 00:34:15,599
this is an example of the text version

00:34:13,040 --> 00:34:18,000
of llvmir so you can see that the

00:34:15,599 --> 00:34:20,079
uh the function's name is mangled so

00:34:18,000 --> 00:34:22,079
it's add one but with a bunch of other

00:34:20,079 --> 00:34:24,800
shenanigans on top of it

00:34:22,079 --> 00:34:26,480
and uh you know we add a number to that

00:34:24,800 --> 00:34:28,159
and return it it's very straightforward

00:34:26,480 --> 00:34:29,760
um there's a whole bunch of attributes

00:34:28,159 --> 00:34:30,240
and other stuff so this is kind of like

00:34:29,760 --> 00:34:32,800
what we

00:34:30,240 --> 00:34:33,919
hand off to lvm it does optimization

00:34:32,800 --> 00:34:35,440
passes there shouldn't be a lot of

00:34:33,919 --> 00:34:36,960
optimizing to do in this code other than

00:34:35,440 --> 00:34:39,200
maybe inlining it into other

00:34:36,960 --> 00:34:40,720
code we've written somewhere else so uh

00:34:39,200 --> 00:34:43,520
you know all that kind of thing

00:34:40,720 --> 00:34:44,560
um okay uh the last thing i need to

00:34:43,520 --> 00:34:46,079
mention

00:34:44,560 --> 00:34:48,480
on the compiler architecture before we

00:34:46,079 --> 00:34:49,919
go back to how this manages how this

00:34:48,480 --> 00:34:52,800
works with additions i hope you'll

00:34:49,919 --> 00:34:54,320
forgive my little compiler tutorial here

00:34:52,800 --> 00:34:56,159
is that i said before we were a

00:34:54,320 --> 00:34:58,480
multi-pass compiler and that's true

00:34:56,159 --> 00:34:59,760
but we're also like working on making

00:34:58,480 --> 00:35:01,520
rust query based so

00:34:59,760 --> 00:35:03,440
a lot of the compiler is already query

00:35:01,520 --> 00:35:05,040
based and what that means is instead of

00:35:03,440 --> 00:35:06,480
these kind of passes where you take the

00:35:05,040 --> 00:35:07,119
whole source code you turn it into one

00:35:06,480 --> 00:35:08,800
ast

00:35:07,119 --> 00:35:11,119
you take the whole ast and turn it into

00:35:08,800 --> 00:35:12,880
here vice versa like you're continuing

00:35:11,119 --> 00:35:15,040
you know down that strategy

00:35:12,880 --> 00:35:16,720
rust instead uses this concept called

00:35:15,040 --> 00:35:18,079
query to create an executable

00:35:16,720 --> 00:35:19,200
so what happens instead is the rest

00:35:18,079 --> 00:35:20,720
compiler will say something like hey

00:35:19,200 --> 00:35:23,200
what type is this function

00:35:20,720 --> 00:35:24,000
um what's the body of this function um

00:35:23,200 --> 00:35:25,280
and then

00:35:24,000 --> 00:35:26,800
the compiler will operate in that

00:35:25,280 --> 00:35:27,920
fashion instead so instead of it being

00:35:26,800 --> 00:35:30,800
like here's the source code of your

00:35:27,920 --> 00:35:32,320
program and turn it all into one way

00:35:30,800 --> 00:35:33,599
the compiler will say like give me the

00:35:32,320 --> 00:35:35,359
you know what where's this function and

00:35:33,599 --> 00:35:35,760
then the internals the compiler will say

00:35:35,359 --> 00:35:37,760
oh

00:35:35,760 --> 00:35:39,440
we don't have this function yet but uh

00:35:37,760 --> 00:35:40,000
you know uh let's load up the source

00:35:39,440 --> 00:35:41,680
code

00:35:40,000 --> 00:35:43,200
um of what where we you know i think it

00:35:41,680 --> 00:35:44,480
is and then we'll look at the body and

00:35:43,200 --> 00:35:45,920
do all that work

00:35:44,480 --> 00:35:47,920
and then sort of figure out that way and

00:35:45,920 --> 00:35:50,320
so it'll sort of do all the steps

00:35:47,920 --> 00:35:51,359
but in smaller chunks instead and the

00:35:50,320 --> 00:35:53,440
reason this is useful

00:35:51,359 --> 00:35:55,520
is first of all memoization so you're

00:35:53,440 --> 00:35:57,119
able to you know reuse

00:35:55,520 --> 00:35:58,880
results of these queries across

00:35:57,119 --> 00:36:00,720
different indications of things

00:35:58,880 --> 00:36:02,560
and so that's helpful it's for compiler

00:36:00,720 --> 00:36:04,160
speed but also more importantly it fits

00:36:02,560 --> 00:36:06,400
information increment

00:36:04,160 --> 00:36:08,160
incremental compilation couldn't say

00:36:06,400 --> 00:36:08,960
that incremental compilation it fits it

00:36:08,160 --> 00:36:10,880
much better

00:36:08,960 --> 00:36:12,880
and so you know if we're able to just

00:36:10,880 --> 00:36:14,240
say like oh the body of this one

00:36:12,880 --> 00:36:16,400
function chained

00:36:14,240 --> 00:36:18,000
that would map directly to one compiler

00:36:16,400 --> 00:36:19,760
query of saying get me the

00:36:18,000 --> 00:36:21,839
body of this function and so then you

00:36:19,760 --> 00:36:24,000
would only do that part of the work

00:36:21,839 --> 00:36:25,280
instead of saying like okay you change

00:36:24,000 --> 00:36:26,800
the body of this function now we have to

00:36:25,280 --> 00:36:28,720
redo the whole ast

00:36:26,800 --> 00:36:31,200
and the whole higher level ir and the

00:36:28,720 --> 00:36:33,760
whole mid-level ir

00:36:31,200 --> 00:36:34,480
and so this is kind of the way that sort

00:36:33,760 --> 00:36:36,160
of

00:36:34,480 --> 00:36:37,760
production grade compilers are written

00:36:36,160 --> 00:36:38,640
today rather than the way that they're

00:36:37,760 --> 00:36:40,480
taught in school

00:36:38,640 --> 00:36:41,920
this was started by c sharp with their

00:36:40,480 --> 00:36:43,280
roslin compiler so if you're more

00:36:41,920 --> 00:36:45,760
interested in kind of how this works

00:36:43,280 --> 00:36:49,359
you should look into roslin or rusty as

00:36:45,760 --> 00:36:51,200
we continue to make it happen this way

00:36:49,359 --> 00:36:52,640
all the mere stuff is written like this

00:36:51,200 --> 00:36:54,160
in my understanding some of the older

00:36:52,640 --> 00:36:55,040
code is not yet converted but this would

00:36:54,160 --> 00:36:57,599
kind of be

00:36:55,040 --> 00:36:58,960
um how this stuff sort of works also if

00:36:57,599 --> 00:36:59,599
you've been following rust analyzer

00:36:58,960 --> 00:37:01,760
lately

00:36:59,599 --> 00:37:03,200
uh it kind of has this sort of model of

00:37:01,760 --> 00:37:05,280
like highly incremental

00:37:03,200 --> 00:37:06,560
and like not traditional architecture

00:37:05,280 --> 00:37:09,920
that uh compilers have

00:37:06,560 --> 00:37:13,599
so that's all uh how that goes okay

00:37:09,920 --> 00:37:15,440
so um editions aren't allowed to break

00:37:13,599 --> 00:37:17,680
everything but like how does that mean

00:37:15,440 --> 00:37:18,640
uh like what's that mean so for

00:37:17,680 --> 00:37:20,560
compilers

00:37:18,640 --> 00:37:23,920
basically like additions aren't allowed

00:37:20,560 --> 00:37:25,680
to differ by the time you get to mirror

00:37:23,920 --> 00:37:27,200
and so you know what that means is a

00:37:25,680 --> 00:37:29,200
little fuzzy from the outside

00:37:27,200 --> 00:37:31,520
basically what it means is the core of

00:37:29,200 --> 00:37:32,079
rust mirror stays the same no matter

00:37:31,520 --> 00:37:33,839
what

00:37:32,079 --> 00:37:35,680
and that really matters for a number of

00:37:33,839 --> 00:37:37,599
different reasons

00:37:35,680 --> 00:37:39,119
the first thing is that like because it

00:37:37,599 --> 00:37:40,880
becomes a common language for all the

00:37:39,119 --> 00:37:42,640
editions

00:37:40,880 --> 00:37:44,240
it's much easier for the compiler team

00:37:42,640 --> 00:37:45,839
to sort of manage changes that are

00:37:44,240 --> 00:37:48,240
brought on by editions

00:37:45,839 --> 00:37:49,760
so all of the stuff that happens

00:37:48,240 --> 00:37:52,240
differences and additions

00:37:49,760 --> 00:37:53,599
happen at earlier stages than mir and so

00:37:52,240 --> 00:37:55,440
what that means is we can assume no

00:37:53,599 --> 00:37:57,040
matter what going forward that mirror

00:37:55,440 --> 00:37:58,320
is like relatively stable obviously

00:37:57,040 --> 00:37:58,880
they're changing the interface but i

00:37:58,320 --> 00:38:00,480
mean like

00:37:58,880 --> 00:38:01,760
we don't have to switch on things by the

00:38:00,480 --> 00:38:03,599
time you get to that step and so

00:38:01,760 --> 00:38:06,160
everything is sorted out earlier

00:38:03,599 --> 00:38:08,160
and this happens to make interoperating

00:38:06,160 --> 00:38:10,880
between editions easier because

00:38:08,160 --> 00:38:12,400
you know your 2015 code and my 2018 code

00:38:10,880 --> 00:38:13,520
will both compile into the same mirror

00:38:12,400 --> 00:38:15,119
at the end so that's how we can

00:38:13,520 --> 00:38:16,240
guarantee interoperability

00:38:15,119 --> 00:38:18,160
because they're both speaking the same

00:38:16,240 --> 00:38:20,800
language at the uh at the

00:38:18,160 --> 00:38:22,800
you know bottom of it um because this is

00:38:20,800 --> 00:38:24,960
the primary mechanism by which things

00:38:22,800 --> 00:38:26,560
become interoperable and it's also the

00:38:24,960 --> 00:38:28,079
way in which we can like control

00:38:26,560 --> 00:38:29,599
the amount of breaking changes because

00:38:28,079 --> 00:38:31,440
if you need something that would change

00:38:29,599 --> 00:38:33,040
things like very fundamentally

00:38:31,440 --> 00:38:34,880
then we can't do it because we need to

00:38:33,040 --> 00:38:38,160
have this sort of interoperability layer

00:38:34,880 --> 00:38:39,920
um on a human side not being able to

00:38:38,160 --> 00:38:41,920
break things in mirror means that things

00:38:39,920 --> 00:38:43,280
can change per edition but not that much

00:38:41,920 --> 00:38:44,640
because like the core understanding of

00:38:43,280 --> 00:38:46,000
rust and what it is is going to be the

00:38:44,640 --> 00:38:47,359
same no matter what the sort of like

00:38:46,000 --> 00:38:50,000
high level details are

00:38:47,359 --> 00:38:51,200
and so that's really important um it

00:38:50,000 --> 00:38:52,720
also means because we are

00:38:51,200 --> 00:38:54,320
compiling down at the same thing we have

00:38:52,720 --> 00:38:56,160
this interoperability we don't split the

00:38:54,320 --> 00:38:58,720
ecosystem and that really matters

00:38:56,160 --> 00:39:00,320
um hey jared has another question uh

00:38:58,720 --> 00:39:02,160
would adding more query based compiler

00:39:00,320 --> 00:39:04,640
features to resc make rust analyzer and

00:39:02,160 --> 00:39:06,960
other sort of analyses tools more robust

00:39:04,640 --> 00:39:08,800
yeah basically that's exactly like the

00:39:06,960 --> 00:39:10,720
reason that c-sharp underwent the roslyn

00:39:08,800 --> 00:39:12,560
project is ides have very different

00:39:10,720 --> 00:39:13,760
needs for languages than the traditional

00:39:12,560 --> 00:39:15,680
compilers do

00:39:13,760 --> 00:39:17,440
and so they kind of like reoriented it

00:39:15,680 --> 00:39:18,960
around what happens in an ide

00:39:17,440 --> 00:39:20,320
that's exactly why i phrased it as kind

00:39:18,960 --> 00:39:21,920
of like oh i changed the body of this

00:39:20,320 --> 00:39:22,400
function let's not recompile the entire

00:39:21,920 --> 00:39:23,440
world

00:39:22,400 --> 00:39:25,040
because that's what happens when you're

00:39:23,440 --> 00:39:26,320
actually in your editor programming as

00:39:25,040 --> 00:39:28,160
you change little bits

00:39:26,320 --> 00:39:30,000
most of the programs program stays the

00:39:28,160 --> 00:39:30,720
same so we kind of want to reuse that

00:39:30,000 --> 00:39:32,240
work

00:39:30,720 --> 00:39:34,720
rather than changing you know throwing

00:39:32,240 --> 00:39:36,720
it all away every single time

00:39:34,720 --> 00:39:38,000
and so yeah it's definitely one of the

00:39:36,720 --> 00:39:39,040
reasons why those tools are better is

00:39:38,000 --> 00:39:40,079
because they want this kind of

00:39:39,040 --> 00:39:43,359
architecture

00:39:40,079 --> 00:39:45,680
um so yeah okay

00:39:43,359 --> 00:39:47,119
um and then another thing about like

00:39:45,680 --> 00:39:48,400
what is additions towards the end

00:39:47,119 --> 00:39:50,400
you kind of think of additions as sort

00:39:48,400 --> 00:39:51,520
of like a bigger release cycle so rust

00:39:50,400 --> 00:39:53,280
already has three different release

00:39:51,520 --> 00:39:54,640
cycles there's stable beta and nightly

00:39:53,280 --> 00:39:56,400
and there's different cadences to those

00:39:54,640 --> 00:39:59,839
releases so nightly is every night

00:39:56,400 --> 00:39:59,839
stable and beta happen every six

00:40:00,000 --> 00:40:04,400
okay so uh you know edition's kind of

00:40:02,960 --> 00:40:05,359
like are like a bigger release cycle

00:40:04,400 --> 00:40:08,560
that happens you know

00:40:05,359 --> 00:40:10,720
broader than versions but um we don't

00:40:08,560 --> 00:40:12,800
have a cadence for editions yet

00:40:10,720 --> 00:40:14,560
um this is kind of why this talk exists

00:40:12,800 --> 00:40:15,599
and uh we're working on an rfc that i'll

00:40:14,560 --> 00:40:17,680
get to here at the end

00:40:15,599 --> 00:40:20,079
but basically like we didn't actually

00:40:17,680 --> 00:40:22,000
decide whether or not this would happen

00:40:20,079 --> 00:40:24,240
on a schedule or not when we decided to

00:40:22,000 --> 00:40:27,040
do it in 2018

00:40:24,240 --> 00:40:29,200
so um there's no policy in the initial

00:40:27,040 --> 00:40:31,280
rfc about when edition should be used

00:40:29,200 --> 00:40:32,720
as i sort of just mentioned um it didn't

00:40:31,280 --> 00:40:34,000
talk about when it just mostly was

00:40:32,720 --> 00:40:35,200
talked about how

00:40:34,000 --> 00:40:37,040
and that way we could focus on shipping

00:40:35,200 --> 00:40:38,000
rest 2018 and not worry about it until

00:40:37,040 --> 00:40:40,720
later because

00:40:38,000 --> 00:40:41,839
you know there's a lot of stuff going on

00:40:40,720 --> 00:40:43,200
and we want to set that policy

00:40:41,839 --> 00:40:44,079
immediately we wanted some experience

00:40:43,200 --> 00:40:45,839
with additions

00:40:44,079 --> 00:40:47,440
we wanted to get 2018 going and we

00:40:45,839 --> 00:40:49,599
didn't want to think about it basically

00:40:47,440 --> 00:40:50,880
um so now that it's been a couple years

00:40:49,599 --> 00:40:53,440
time to start thinking about it

00:40:50,880 --> 00:40:54,720
um so 2018 was sort of the first edition

00:40:53,440 --> 00:40:55,680
but we kind of retconned it to be the

00:40:54,720 --> 00:40:57,760
second one so

00:40:55,680 --> 00:40:59,520
west 1.0 and russ 2015 were the very

00:40:57,760 --> 00:41:01,200
first edition sort of speaking

00:40:59,520 --> 00:41:03,440
2018 was the first one that kind of like

00:41:01,200 --> 00:41:05,119
changed things um

00:41:03,440 --> 00:41:06,480
and so what i want to talk about next is

00:41:05,119 --> 00:41:07,520
like a little look back about how that

00:41:06,480 --> 00:41:08,720
happened because i think that really

00:41:07,520 --> 00:41:10,480
informs

00:41:08,720 --> 00:41:12,160
what we should do in the future and this

00:41:10,480 --> 00:41:13,520
is also again kind of like why we didn't

00:41:12,160 --> 00:41:15,200
pick a policy back then

00:41:13,520 --> 00:41:16,960
is we want to be able to see how it went

00:41:15,200 --> 00:41:18,160
and then think about the problem later

00:41:16,960 --> 00:41:20,000
rather than trying to invent it

00:41:18,160 --> 00:41:21,200
beforehand

00:41:20,000 --> 00:41:23,040
so let's talk a little bit about russ

00:41:21,200 --> 00:41:26,480
2018 and kind of how it went

00:41:23,040 --> 00:41:27,440
um so i think overall russ 2018 was a

00:41:26,480 --> 00:41:29,599
success

00:41:27,440 --> 00:41:30,560
um we achieved our goals even though it

00:41:29,599 --> 00:41:32,480
was a ton of work

00:41:30,560 --> 00:41:33,760
but uh we did ship the addition it did

00:41:32,480 --> 00:41:35,520
happen um

00:41:33,760 --> 00:41:36,800
people did manage to understand this was

00:41:35,520 --> 00:41:38,480
different than russ 2.0

00:41:36,800 --> 00:41:40,079
and they didn't like run away thinking

00:41:38,480 --> 00:41:41,920
that we totally destroyed our

00:41:40,079 --> 00:41:42,960
uh you know stability guarantees

00:41:41,920 --> 00:41:44,560
obviously were some people that were

00:41:42,960 --> 00:41:46,000
kind of not happy that we did any sort

00:41:44,560 --> 00:41:47,280
of changes but you can't please everyone

00:41:46,000 --> 00:41:48,560
all the time

00:41:47,280 --> 00:41:50,240
but the fact that it was a different

00:41:48,560 --> 00:41:51,119
kind of mechanism helped people

00:41:50,240 --> 00:41:52,160
understand what we were trying to

00:41:51,119 --> 00:41:53,920
accomplish

00:41:52,160 --> 00:41:55,680
and i would say that there are not any

00:41:53,920 --> 00:41:58,160
real major issues with the addition

00:41:55,680 --> 00:41:59,920
system itself at this point there are

00:41:58,160 --> 00:42:01,440
some tweaks and things but like

00:41:59,920 --> 00:42:03,280
you know the actual out of the

00:42:01,440 --> 00:42:04,079
implementation went smoothly for the

00:42:03,280 --> 00:42:06,560
most part

00:42:04,079 --> 00:42:08,400
um it was a lot of work it was a really

00:42:06,560 --> 00:42:10,160
big project for all the teams

00:42:08,400 --> 00:42:11,440
we never really had undertaken such a

00:42:10,160 --> 00:42:13,599
big project before

00:42:11,440 --> 00:42:15,280
other than maybe rest 1.0 which is again

00:42:13,599 --> 00:42:17,200
sort of kind of like an addition

00:42:15,280 --> 00:42:18,319
and so we managed to do it and that's

00:42:17,200 --> 00:42:21,040
positive and that

00:42:18,319 --> 00:42:21,599
i think is worth like celebrating

00:42:21,040 --> 00:42:23,839
however

00:42:21,599 --> 00:42:25,760
rest 2018 was also not a complete

00:42:23,839 --> 00:42:28,480
success in my opinion

00:42:25,760 --> 00:42:30,079
um so there's kind of two different ways

00:42:28,480 --> 00:42:31,760
that i think that it really struggled

00:42:30,079 --> 00:42:33,280
the first one was the schedule and the

00:42:31,760 --> 00:42:34,960
second one was the team

00:42:33,280 --> 00:42:37,280
so we didn't ship everything that we

00:42:34,960 --> 00:42:39,040
wanted to ship in the 2018 edition

00:42:37,280 --> 00:42:41,280
some things didn't actually get finished

00:42:39,040 --> 00:42:43,119
some things changed significantly and

00:42:41,280 --> 00:42:46,160
scope had to be cut drastically in order

00:42:43,119 --> 00:42:48,240
to make it under the release line

00:42:46,160 --> 00:42:49,599
and so while we did ship the mechanism

00:42:48,240 --> 00:42:52,000
and it was successful

00:42:49,599 --> 00:42:53,200
it just barely happened like the release

00:42:52,000 --> 00:42:54,000
is going to talk about schedules in a

00:42:53,200 --> 00:42:56,319
second

00:42:54,000 --> 00:42:57,599
happened in december of 2018. we

00:42:56,319 --> 00:42:58,960
actually did not have another rust

00:42:57,599 --> 00:42:59,920
release that happened literally at the

00:42:58,960 --> 00:43:02,160
last moment

00:42:59,920 --> 00:43:03,520
and so that also was you know a sign

00:43:02,160 --> 00:43:04,560
that things weren't necessarily as ideal

00:43:03,520 --> 00:43:06,160
as they could have been

00:43:04,560 --> 00:43:08,560
um secondly was the human cost of the

00:43:06,160 --> 00:43:09,680
edition the team tons of people put in

00:43:08,560 --> 00:43:11,599
tons of work

00:43:09,680 --> 00:43:12,800
for a really long time to make this

00:43:11,599 --> 00:43:14,319
happen and

00:43:12,800 --> 00:43:15,760
it was extremely high stakes because

00:43:14,319 --> 00:43:17,040
this was a really big thing it was the

00:43:15,760 --> 00:43:18,720
first time we'd ever done it

00:43:17,040 --> 00:43:21,280
and so that contributed to a lot of

00:43:18,720 --> 00:43:23,680
burnout amongst contributors i believe

00:43:21,280 --> 00:43:25,040
i can only truly speak for myself i was

00:43:23,680 --> 00:43:26,880
a total freaking mess

00:43:25,040 --> 00:43:28,240
by the time the 2018 edition actually

00:43:26,880 --> 00:43:29,520
happened and i wasn't even the one

00:43:28,240 --> 00:43:30,960
implementing a lot of this stuff i was

00:43:29,520 --> 00:43:32,160
just trying to like keep the book going

00:43:30,960 --> 00:43:33,599
and do some other work

00:43:32,160 --> 00:43:36,079
so other people worked a lot longer and

00:43:33,599 --> 00:43:38,560
harder than i did and i felt terrible

00:43:36,079 --> 00:43:39,280
honestly so i can only imagine with

00:43:38,560 --> 00:43:40,240
other people

00:43:39,280 --> 00:43:42,560
you know how they felt about the

00:43:40,240 --> 00:43:43,200
schedule so we did it but like at what

00:43:42,560 --> 00:43:46,560
cost

00:43:43,200 --> 00:43:50,800
um and so yeah the 2018 edition shipped

00:43:46,560 --> 00:43:53,680
on december 6 2018 um with rust 1.31

00:43:50,800 --> 00:43:55,280
um and what's kind of funny about the

00:43:53,680 --> 00:43:57,599
half shipping thing too is like some

00:43:55,280 --> 00:43:59,839
actual changes didn't chip until 132

00:43:57,599 --> 00:44:00,720
but uh the edition itself shipped at 131

00:43:59,839 --> 00:44:02,079
so uh

00:44:00,720 --> 00:44:03,359
yeah we shipped a bunch of different

00:44:02,079 --> 00:44:04,240
things this is a screenshot from the

00:44:03,359 --> 00:44:06,319
blog post so

00:44:04,240 --> 00:44:08,000
non-lexical lifetimes happened in 2018

00:44:06,319 --> 00:44:11,200
module system changes got simpler

00:44:08,000 --> 00:44:13,200
in 2018 we did some more elision stuff

00:44:11,200 --> 00:44:15,119
constant functions became a thing there

00:44:13,200 --> 00:44:16,640
was things like rust fix got added

00:44:15,119 --> 00:44:18,560
a whole bunch of lints like clippy was

00:44:16,640 --> 00:44:19,920
able to do its job unstable and that was

00:44:18,560 --> 00:44:21,760
a big deal

00:44:19,920 --> 00:44:23,839
documentation got updated we had the new

00:44:21,760 --> 00:44:25,119
domain working groups a new website

00:44:23,839 --> 00:44:27,119
tons of things happened in the stand

00:44:25,119 --> 00:44:28,560
library lots of new cargo features there

00:44:27,119 --> 00:44:29,760
was just like all sorts of stuff like

00:44:28,560 --> 00:44:31,359
2018 was huge

00:44:29,760 --> 00:44:33,440
it's a really big deal we shipped a lot

00:44:31,359 --> 00:44:36,400
of it and that's deserved

00:44:33,440 --> 00:44:37,359
celebrating um but as i said it was

00:44:36,400 --> 00:44:39,520
behind schedule

00:44:37,359 --> 00:44:41,040
so the initial rfc had sort of this

00:44:39,520 --> 00:44:42,160
schedule there's this idea of a preview

00:44:41,040 --> 00:44:44,079
period which is kind of like you can

00:44:42,160 --> 00:44:47,440
think about the addition being unstable

00:44:44,079 --> 00:44:50,960
um so the idea was that like okay

00:44:47,440 --> 00:44:53,680
um rust 123 is gonna start shipping

00:44:50,960 --> 00:44:55,200
a preview of the edition and then in 127

00:44:53,680 --> 00:44:56,480
we're going to like nail everything down

00:44:55,200 --> 00:44:57,359
and actually ship it and that'll be when

00:44:56,480 --> 00:45:00,319
it comes out

00:44:57,359 --> 00:45:01,280
so to put some dates on that uh 123 was

00:45:00,319 --> 00:45:05,280
january 4th

00:45:01,280 --> 00:45:06,079
in 2018 and uh the final 127 release was

00:45:05,280 --> 00:45:10,079
going to be june

00:45:06,079 --> 00:45:11,440
21st 2018 so halfway through the year

00:45:10,079 --> 00:45:13,280
and if you're paying attention a moment

00:45:11,440 --> 00:45:14,800
earlier that was very different than

00:45:13,280 --> 00:45:17,040
what actually happened

00:45:14,800 --> 00:45:18,000
so what actually happened was the

00:45:17,040 --> 00:45:20,160
changes landed

00:45:18,000 --> 00:45:22,240
in the nightly compiler on the 6th of

00:45:20,160 --> 00:45:23,520
february so that was almost one month

00:45:22,240 --> 00:45:25,680
later than the initial

00:45:23,520 --> 00:45:26,800
uh release was planned and then finally

00:45:25,680 --> 00:45:28,800
the actual release was

00:45:26,800 --> 00:45:29,920
in december which is like six months

00:45:28,800 --> 00:45:32,880
june to december

00:45:29,920 --> 00:45:33,200
something like that a long time later

00:45:32,880 --> 00:45:35,520
and

00:45:33,200 --> 00:45:37,040
we kept thinking it was gonna be in like

00:45:35,520 --> 00:45:38,319
october and then that slipped and then

00:45:37,040 --> 00:45:38,880
november and then slipped and then

00:45:38,319 --> 00:45:41,119
december

00:45:38,880 --> 00:45:42,800
we finally got it out the door so um we

00:45:41,119 --> 00:45:46,079
almost missed the date itself

00:45:42,800 --> 00:45:48,400
which is intense i think that this

00:45:46,079 --> 00:45:50,560
happened because we tried to do too much

00:45:48,400 --> 00:45:51,680
um partially that was because there was

00:45:50,560 --> 00:45:53,520
a lot of work to do

00:45:51,680 --> 00:45:54,800
like breast 1.0 was a really small

00:45:53,520 --> 00:45:56,240
release and there was a lot of things

00:45:54,800 --> 00:45:58,160
that really needed to be tweaked

00:45:56,240 --> 00:46:00,000
we had this opportunity to do it so we

00:45:58,160 --> 00:46:02,240
committed to it and we made it happen

00:46:00,000 --> 00:46:03,200
um i think another part of sort of some

00:46:02,240 --> 00:46:05,200
of the problems was

00:46:03,200 --> 00:46:06,800
some of these ideas we tried to move too

00:46:05,200 --> 00:46:08,400
far in front of the community

00:46:06,800 --> 00:46:10,000
so like some of the things around for

00:46:08,400 --> 00:46:11,520
example the anonymous lifetime

00:46:10,000 --> 00:46:12,880
were added and i'm not even sure that

00:46:11,520 --> 00:46:14,800
people like know about the anonymous

00:46:12,880 --> 00:46:16,319
lifetime or use it exactly

00:46:14,800 --> 00:46:18,079
because it kind of got lost in the

00:46:16,319 --> 00:46:19,599
shuffle a little bit but we had some

00:46:18,079 --> 00:46:20,880
ideas about some patterns then it got

00:46:19,599 --> 00:46:22,160
scaled back and then

00:46:20,880 --> 00:46:24,000
some things got sort of like cut or

00:46:22,160 --> 00:46:26,000
barely shipped and we tried to like

00:46:24,000 --> 00:46:27,440
move too far ahead and think about like

00:46:26,000 --> 00:46:28,960
what things should happen

00:46:27,440 --> 00:46:30,480
rather than taking what happened and

00:46:28,960 --> 00:46:32,240
like getting the good parts of it

00:46:30,480 --> 00:46:34,160
there's always a balance to be had there

00:46:32,240 --> 00:46:35,680
um i think that added some stress the

00:46:34,160 --> 00:46:37,040
module system was another example of

00:46:35,680 --> 00:46:39,200
this where we like kind of

00:46:37,040 --> 00:46:40,560
invented what we wanted and then there's

00:46:39,200 --> 00:46:40,960
a lot of changes a lot of feedback and

00:46:40,560 --> 00:46:42,160
it was

00:46:40,960 --> 00:46:45,599
really really difficult to get that

00:46:42,160 --> 00:46:46,880
through um finally the other reason why

00:46:45,599 --> 00:46:49,119
i think we bit off a little more than we

00:46:46,880 --> 00:46:50,400
can chew so we have we're really really

00:46:49,119 --> 00:46:52,400
great that we have so many contributors

00:46:50,400 --> 00:46:54,480
to us and we did at that time but also

00:46:52,400 --> 00:46:56,480
contributors are not employees

00:46:54,480 --> 00:46:58,400
and uh it's much harder to plan a big

00:46:56,480 --> 00:46:59,680
initiative that spans a whole year

00:46:58,400 --> 00:47:01,119
when you can't be guaranteed that

00:46:59,680 --> 00:47:02,800
there's like these people that have

00:47:01,119 --> 00:47:04,000
full-time amounts of work to work on it

00:47:02,800 --> 00:47:04,880
like just from a project management

00:47:04,000 --> 00:47:06,319
perspective

00:47:04,880 --> 00:47:07,920
you know people are free to come and go

00:47:06,319 --> 00:47:09,119
as they please on the rest project but

00:47:07,920 --> 00:47:10,880
that also means that when you're trying

00:47:09,119 --> 00:47:11,920
to like get a huge thing shipped on a

00:47:10,880 --> 00:47:13,200
tight deadline

00:47:11,920 --> 00:47:15,040
it's difficult to be able to rely on

00:47:13,200 --> 00:47:16,880
people having the ability to do stuff

00:47:15,040 --> 00:47:18,640
um and you know even if you are an

00:47:16,880 --> 00:47:20,160
employee like i said i got burned out i

00:47:18,640 --> 00:47:22,640
didn't want to do this anymore

00:47:20,160 --> 00:47:23,680
uh to some degree and uh so you know it

00:47:22,640 --> 00:47:24,800
could just be really difficult with

00:47:23,680 --> 00:47:26,000
these kind of big initiatives

00:47:24,800 --> 00:47:28,000
in an open source world and i don't

00:47:26,000 --> 00:47:28,640
think that anyone has figured out how to

00:47:28,000 --> 00:47:31,839
really

00:47:28,640 --> 00:47:33,280
accomplish this yet um another positive

00:47:31,839 --> 00:47:34,160
thing was we proved that the mechanism

00:47:33,280 --> 00:47:37,280
actually worked

00:47:34,160 --> 00:47:39,520
so 2015 and 2018 interoperate just fine

00:47:37,280 --> 00:47:40,720
the plan was good it happened you know

00:47:39,520 --> 00:47:42,559
you don't have to worry about this thing

00:47:40,720 --> 00:47:43,839
we can have our cake and eat it too

00:47:42,559 --> 00:47:45,520
um which is the thing we always try to

00:47:43,839 --> 00:47:47,359
do in the rest world we didn't split the

00:47:45,520 --> 00:47:49,280
ecosystem there's not a holdout of

00:47:47,359 --> 00:47:50,559
people that use 2015 that like are

00:47:49,280 --> 00:47:51,440
sequestered from the rest of the

00:47:50,559 --> 00:47:53,440
community

00:47:51,440 --> 00:47:54,720
um and so that's like really important

00:47:53,440 --> 00:47:56,160
there are still people that program the

00:47:54,720 --> 00:47:57,599
2015 edition today

00:47:56,160 --> 00:47:59,599
and uh they can do everything they need

00:47:57,599 --> 00:48:00,800
to do and it works just fine so that's i

00:47:59,599 --> 00:48:03,520
think a really important thing

00:48:00,800 --> 00:48:04,079
i've kept some coherence um and i think

00:48:03,520 --> 00:48:05,520
that like

00:48:04,079 --> 00:48:07,119
it works so well because it's pretty

00:48:05,520 --> 00:48:08,880
much silent like i don't think most

00:48:07,119 --> 00:48:10,079
users think about editions a whole ton

00:48:08,880 --> 00:48:12,079
which is part of why i wanted to start

00:48:10,079 --> 00:48:13,520
this talk by putting out all the details

00:48:12,079 --> 00:48:14,720
because like it just kind of works you

00:48:13,520 --> 00:48:15,359
don't really think about it i think for

00:48:14,720 --> 00:48:17,040
most people

00:48:15,359 --> 00:48:20,480
and uh that's a testament to how good

00:48:17,040 --> 00:48:22,240
the thing that we shipped was but as a

00:48:20,480 --> 00:48:22,960
downside we underestimated the cost of

00:48:22,240 --> 00:48:25,359
the addition

00:48:22,960 --> 00:48:27,200
um to both the human element but also to

00:48:25,359 --> 00:48:27,920
like our users who needed to make these

00:48:27,200 --> 00:48:29,280
changes happen

00:48:27,920 --> 00:48:31,359
so even though we put a lot of time and

00:48:29,280 --> 00:48:31,839
effort into making upgrading easy or

00:48:31,359 --> 00:48:34,240
simple

00:48:31,839 --> 00:48:35,119
it wasn't actually so in the end and

00:48:34,240 --> 00:48:36,319
that's just because there's a lot of

00:48:35,119 --> 00:48:37,680
moving pieces so we

00:48:36,319 --> 00:48:39,520
had rust fix which was able to

00:48:37,680 --> 00:48:40,480
automatically upgrade your code but like

00:48:39,520 --> 00:48:42,000
it wasn't perfect

00:48:40,480 --> 00:48:43,680
um and there were some things that

00:48:42,000 --> 00:48:44,559
couldn't necessarily update some of the

00:48:43,680 --> 00:48:45,920
fancier features

00:48:44,559 --> 00:48:47,520
and you know people still have to like

00:48:45,920 --> 00:48:48,160
validate and test and do these kind of

00:48:47,520 --> 00:48:49,680
things

00:48:48,160 --> 00:48:51,839
and so it just takes a lot of time the

00:48:49,680 --> 00:48:52,640
compiler did not shift to rest 2018 for

00:48:51,839 --> 00:48:54,319
a little while

00:48:52,640 --> 00:48:56,400
neither did other big projects i think

00:48:54,319 --> 00:48:58,160
that's also okay like expecting everyone

00:48:56,400 --> 00:49:00,240
to upgrade immediately

00:48:58,160 --> 00:49:02,079
um is part of like an unrealistic

00:49:00,240 --> 00:49:02,559
expectation i don't think we totally had

00:49:02,079 --> 00:49:04,000
that

00:49:02,559 --> 00:49:05,680
but there's definitely some people that

00:49:04,000 --> 00:49:07,200
thought that should happen overall like

00:49:05,680 --> 00:49:08,319
in the community or on the teams

00:49:07,200 --> 00:49:10,880
because uh you know they worked on

00:49:08,319 --> 00:49:12,160
smaller projects um but uh you know some

00:49:10,880 --> 00:49:14,000
production users reported that it took

00:49:12,160 --> 00:49:15,680
them a while to upgrade to 2018 and it

00:49:14,000 --> 00:49:17,440
was a significant costly

00:49:15,680 --> 00:49:19,440
kind of upgrade you know even if it's

00:49:17,440 --> 00:49:22,000
easy to do still takes time

00:49:19,440 --> 00:49:23,119
and time is money to companies and

00:49:22,000 --> 00:49:23,760
companies are the ones that have the

00:49:23,119 --> 00:49:25,040
biggest

00:49:23,760 --> 00:49:26,800
rust projects because they're paying

00:49:25,040 --> 00:49:28,640
people to work on things full time

00:49:26,800 --> 00:49:30,319
and uh so you know we sort of put a big

00:49:28,640 --> 00:49:33,520
burden on a lot of our biggest users

00:49:30,319 --> 00:49:36,000
and that's tough um

00:49:33,520 --> 00:49:36,880
so i think it's it's a it's a challenge

00:49:36,000 --> 00:49:38,079
um

00:49:36,880 --> 00:49:39,760
i think another thing that happened with

00:49:38,079 --> 00:49:41,359
the 2018 edition is it became feature

00:49:39,760 --> 00:49:43,359
driven instead of time boxed

00:49:41,359 --> 00:49:44,960
so you know normal rust releases or time

00:49:43,359 --> 00:49:46,720
box that is there's a schedule

00:49:44,960 --> 00:49:48,720
and the release happens train leaves the

00:49:46,720 --> 00:49:49,440
station regardless of whether you make

00:49:48,720 --> 00:49:51,599
it or not

00:49:49,440 --> 00:49:53,040
um and so that's kind of what happened

00:49:51,599 --> 00:49:54,480
and rust 2018 was sort of became

00:49:53,040 --> 00:49:55,760
designed around features so we sort of

00:49:54,480 --> 00:49:56,480
said like hey what features do we want

00:49:55,760 --> 00:49:57,760
to happen

00:49:56,480 --> 00:49:59,440
and then we figured out how to make them

00:49:57,760 --> 00:50:02,880
happen on the schedule but then when

00:49:59,440 --> 00:50:02,880
they took longer to implement then

00:50:03,040 --> 00:50:05,839
when they took longer to implement them

00:50:04,079 --> 00:50:06,880
maybe we thought uh you know that became

00:50:05,839 --> 00:50:09,040
kind of an issue

00:50:06,880 --> 00:50:10,400
and so uh that was i think a lot of the

00:50:09,040 --> 00:50:11,760
struggle was like we need to get these

00:50:10,400 --> 00:50:12,880
features out there's this time deadline

00:50:11,760 --> 00:50:13,359
we have to have it happen before the

00:50:12,880 --> 00:50:14,640
time

00:50:13,359 --> 00:50:15,760
that doesn't happen with normal rust

00:50:14,640 --> 00:50:17,040
releases because there's always a new

00:50:15,760 --> 00:50:18,559
train coming in six weeks

00:50:17,040 --> 00:50:20,400
like part of the reason why we picked

00:50:18,559 --> 00:50:22,319
the train model in the first place

00:50:20,400 --> 00:50:23,760
is because we knew that having a yearly

00:50:22,319 --> 00:50:25,760
or longer release schedule

00:50:23,760 --> 00:50:27,119
was a problem so then we decided with

00:50:25,760 --> 00:50:27,760
the addition system that we were going

00:50:27,119 --> 00:50:30,800
to do that

00:50:27,760 --> 00:50:33,040
so i think that was like a big issue um

00:50:30,800 --> 00:50:34,400
kind of felt like lead up to us 1.0 um

00:50:33,040 --> 00:50:35,200
where there was this big giant release

00:50:34,400 --> 00:50:37,760
that happened and

00:50:35,200 --> 00:50:39,440
everybody worked super hard um you know

00:50:37,760 --> 00:50:41,200
this this was a huge amount of hard work

00:50:39,440 --> 00:50:43,200
and herculean efforts by folks

00:50:41,200 --> 00:50:45,280
and therefore some burnout happened um

00:50:43,200 --> 00:50:45,920
and so uh i think that that was a big

00:50:45,280 --> 00:50:47,680
problem with

00:50:45,920 --> 00:50:49,680
with 2018 was getting too caught up in

00:50:47,680 --> 00:50:51,359
like it means this set of features and

00:50:49,680 --> 00:50:54,880
we're gonna ship them on this day

00:50:51,359 --> 00:50:56,400
um and so uh a great example of how this

00:50:54,880 --> 00:50:57,440
did not happen and was very successful

00:50:56,400 --> 00:50:59,119
is async await

00:50:57,440 --> 00:51:01,280
so uh you know we realized that async

00:50:59,119 --> 00:51:02,559
await was not going to make it in 2018

00:51:01,280 --> 00:51:04,240
and so we said hey we're going to

00:51:02,559 --> 00:51:05,359
reserve the keyword so that we have it

00:51:04,240 --> 00:51:06,559
in the edition but we're not actually

00:51:05,359 --> 00:51:08,559
going to release the feature

00:51:06,559 --> 00:51:09,839
and so what that meant was is that uh

00:51:08,559 --> 00:51:12,240
you know uh

00:51:09,839 --> 00:51:14,400
so 2018 december was when the audition

00:51:12,240 --> 00:51:17,200
shipped but we actually shipped

00:51:14,400 --> 00:51:18,720
the the um you know async await in 2019

00:51:17,200 --> 00:51:20,400
instead almost a year later

00:51:18,720 --> 00:51:21,839
and i think that worked out really well

00:51:20,400 --> 00:51:23,040
and is a great model for how this should

00:51:21,839 --> 00:51:24,960
sort of work in the future

00:51:23,040 --> 00:51:26,720
is that we don't necessarily like you

00:51:24,960 --> 00:51:27,359
know do we don't force everything to

00:51:26,720 --> 00:51:29,040
happen

00:51:27,359 --> 00:51:30,880
and we don't force the schedule of the

00:51:29,040 --> 00:51:32,079
edition to happen on a feature basis we

00:51:30,880 --> 00:51:33,040
kind of say hey the feature is going to

00:51:32,079 --> 00:51:34,319
be on this cadence

00:51:33,040 --> 00:51:36,079
and you know we're going to ship the

00:51:34,319 --> 00:51:36,800
feature when it happens um so that's

00:51:36,079 --> 00:51:37,920
important

00:51:36,800 --> 00:51:39,440
um this is kind of blending into the

00:51:37,920 --> 00:51:40,400
last part of my talk here what should we

00:51:39,440 --> 00:51:42,640
be doing

00:51:40,400 --> 00:51:43,839
so this is kind of like my opinion on

00:51:42,640 --> 00:51:46,240
where we should go from here

00:51:43,839 --> 00:51:46,880
basically we should have a rest 2021

00:51:46,240 --> 00:51:48,800
edition

00:51:46,880 --> 00:51:50,319
i know that every talk with a title in

00:51:48,800 --> 00:51:51,119
it's supposed to be no but the answer is

00:51:50,319 --> 00:51:54,480
yes

00:51:51,119 --> 00:51:56,000
gotcha betterage's law of headlines um

00:51:54,480 --> 00:51:57,520
but i think that we should have a 2021

00:51:56,000 --> 00:51:58,720
edition and we should commit to a

00:51:57,520 --> 00:51:59,920
trained model for additions and we

00:51:58,720 --> 00:52:02,400
should have one every three years no

00:51:59,920 --> 00:52:02,400
matter what

00:52:02,720 --> 00:52:05,760
i think that this should be smaller than

00:52:04,079 --> 00:52:07,280
russ 2018 was

00:52:05,760 --> 00:52:08,319
for a number of different reasons first

00:52:07,280 --> 00:52:10,160
of all i don't think we have as much

00:52:08,319 --> 00:52:12,000
need as we did in 2018

00:52:10,160 --> 00:52:14,160
but secondly like you know i think that

00:52:12,000 --> 00:52:14,880
it will just go smoother if we don't do

00:52:14,160 --> 00:52:16,319
as much

00:52:14,880 --> 00:52:18,000
and i also think that a lot of people

00:52:16,319 --> 00:52:20,480
are sort of craving stability

00:52:18,000 --> 00:52:22,000
in the rest world and so um i think that

00:52:20,480 --> 00:52:24,640
that's like a very positive thing

00:52:22,000 --> 00:52:26,319
so a smaller edition would be much

00:52:24,640 --> 00:52:27,520
smaller than 2018 but i still think we

00:52:26,319 --> 00:52:31,280
should do it anyway

00:52:27,520 --> 00:52:33,280
um there's a question from emmanuel lima

00:52:31,280 --> 00:52:34,640
in the chat uh does mozilla hire

00:52:33,280 --> 00:52:36,559
engineers to work on rusty and that

00:52:34,640 --> 00:52:38,400
should help diminish burnout no

00:52:36,559 --> 00:52:40,240
mozilla does pay some people but it's a

00:52:38,400 --> 00:52:41,920
very small amount of the overall team

00:52:40,240 --> 00:52:44,160
and there's no indication that mozilla

00:52:41,920 --> 00:52:46,800
is like gonna hire 10 more people

00:52:44,160 --> 00:52:48,400
which is like what we would need so yes

00:52:46,800 --> 00:52:49,359
while they could in theory do that i

00:52:48,400 --> 00:52:51,280
don't think

00:52:49,359 --> 00:52:53,200
the mozilla is going to and i don't

00:52:51,280 --> 00:52:54,559
always think that just hiring

00:52:53,200 --> 00:52:56,240
people is always the right solution

00:52:54,559 --> 00:52:58,800
either because you know

00:52:56,240 --> 00:52:59,760
um it depends like we could hire the

00:52:58,800 --> 00:53:00,960
community and that'd be great because

00:52:59,760 --> 00:53:02,240
they already know what's going on

00:53:00,960 --> 00:53:03,280
but that doesn't necessarily mean that's

00:53:02,240 --> 00:53:04,880
the right call because like not

00:53:03,280 --> 00:53:06,640
everybody wants to do rest as their job

00:53:04,880 --> 00:53:08,960
and like it's complicated basically

00:53:06,640 --> 00:53:10,079
but um it's true that work helps

00:53:08,960 --> 00:53:12,480
diminish burnout

00:53:10,079 --> 00:53:13,599
but on some level work can also force

00:53:12,480 --> 00:53:15,280
you into burnout

00:53:13,599 --> 00:53:16,800
because when it's your job you have to

00:53:15,280 --> 00:53:18,400
do it even if you don't want to

00:53:16,800 --> 00:53:20,240
so like deadlines are somehow weirdly

00:53:18,400 --> 00:53:22,800
more stressful with jobs than they are

00:53:20,240 --> 00:53:24,480
with open source projects i think so um

00:53:22,800 --> 00:53:26,400
you know like i said i was a mozilla

00:53:24,480 --> 00:53:28,319
employee at the time of the 2018 edition

00:53:26,400 --> 00:53:29,920
and i got burned out anyway so i don't

00:53:28,319 --> 00:53:31,760
think it's a pure solution

00:53:29,920 --> 00:53:34,160
i do think they can help um in some

00:53:31,760 --> 00:53:36,720
cases yeah

00:53:34,160 --> 00:53:39,040
okay so release trains like the core of

00:53:36,720 --> 00:53:40,960
my argument with the 2018 2029 edition

00:53:39,040 --> 00:53:42,559
release trains are good and additions

00:53:40,960 --> 00:53:43,200
are kind of release so we should have a

00:53:42,559 --> 00:53:44,640
train

00:53:43,200 --> 00:53:47,200
and that should just be the end of it

00:53:44,640 --> 00:53:49,520
like we should no longer pick date based

00:53:47,200 --> 00:53:50,240
releases we should just always do trains

00:53:49,520 --> 00:53:52,720
because there's

00:53:50,240 --> 00:53:54,480
far better way to ship software um if

00:53:52,720 --> 00:53:56,319
six weeks go by without a new release

00:53:54,480 --> 00:53:58,000
and a new feature in the regular code

00:53:56,319 --> 00:53:59,680
base we still put out a new rust c

00:53:58,000 --> 00:54:01,119
anyway some addition some releases are

00:53:59,680 --> 00:54:02,720
small some editions are big

00:54:01,119 --> 00:54:03,920
uh you know that's just the way that it

00:54:02,720 --> 00:54:05,680
goes and so i think that if there's

00:54:03,920 --> 00:54:06,720
three years go by and we don't need any

00:54:05,680 --> 00:54:08,000
big breaking changes

00:54:06,720 --> 00:54:10,079
it's totally fine but we should still

00:54:08,000 --> 00:54:12,079
release a new edition um

00:54:10,079 --> 00:54:13,599
sprutal asks a question in the chat that

00:54:12,079 --> 00:54:14,079
i'm going to be getting to very shortly

00:54:13,599 --> 00:54:17,359
so

00:54:14,079 --> 00:54:18,400
uh stay tuned um but yeah like basically

00:54:17,359 --> 00:54:19,200
i think the train model has been

00:54:18,400 --> 00:54:21,359
wonderful

00:54:19,200 --> 00:54:22,480
uh and i think that we should do it with

00:54:21,359 --> 00:54:24,160
additions too

00:54:22,480 --> 00:54:25,359
um there's a number of reasons i'm not

00:54:24,160 --> 00:54:27,119
going to get into all of them but

00:54:25,359 --> 00:54:28,880
basically like the shortest version is

00:54:27,119 --> 00:54:30,319
it's a model that works and as a model

00:54:28,880 --> 00:54:32,079
that we've demonstrated is

00:54:30,319 --> 00:54:35,119
uh feasible so i think we should just do

00:54:32,079 --> 00:54:36,400
the same thing but on a longer schedule

00:54:35,119 --> 00:54:37,839
some people argue that the social part

00:54:36,400 --> 00:54:39,200
of addition shouldn't matter and we

00:54:37,839 --> 00:54:40,880
should only make

00:54:39,200 --> 00:54:43,200
editions happen when we have the feature

00:54:40,880 --> 00:54:45,119
need but i think that that's wrong

00:54:43,200 --> 00:54:46,400
um some of it is just the classic

00:54:45,119 --> 00:54:47,599
arguments back and forth that happen the

00:54:46,400 --> 00:54:48,960
first time the edition happens

00:54:47,599 --> 00:54:50,799
like looking over the past three years

00:54:48,960 --> 00:54:52,240
matters getting people outside of us to

00:54:50,799 --> 00:54:54,880
pay attention and stuff matters

00:54:52,240 --> 00:54:56,400
um and all that stuff still happens i

00:54:54,880 --> 00:54:57,280
think that smaller editions are actually

00:54:56,400 --> 00:54:59,280
a nicer

00:54:57,280 --> 00:55:01,119
marketing message so shipping them is

00:54:59,280 --> 00:55:02,640
somehow more important in some ways than

00:55:01,119 --> 00:55:04,079
a big breaking change release

00:55:02,640 --> 00:55:05,839
because it's like hey it's been three

00:55:04,079 --> 00:55:07,119
years with rust and we don't feel the

00:55:05,839 --> 00:55:08,319
need that there's any big breaking

00:55:07,119 --> 00:55:09,040
changes because we think the language is

00:55:08,319 --> 00:55:10,480
good enough

00:55:09,040 --> 00:55:12,160
that is a very strong and powerful

00:55:10,480 --> 00:55:14,000
marketing

00:55:12,160 --> 00:55:15,599
uh message to people to be able to want

00:55:14,000 --> 00:55:16,960
to check things out people are still

00:55:15,599 --> 00:55:18,480
like leaving comments on the internet

00:55:16,960 --> 00:55:20,319
all the time about like i don't know

00:55:18,480 --> 00:55:22,160
that rust is actually stable because the

00:55:20,319 --> 00:55:23,440
six week cadence like people don't

00:55:22,160 --> 00:55:24,559
necessarily know how much time and

00:55:23,440 --> 00:55:25,599
effort we put into making sure those

00:55:24,559 --> 00:55:27,680
things are stable

00:55:25,599 --> 00:55:29,520
and so uh you know every six weeks seems

00:55:27,680 --> 00:55:30,960
fast so people get on the idea of like

00:55:29,520 --> 00:55:31,680
oh i only deal with russ every three

00:55:30,960 --> 00:55:33,280
years

00:55:31,680 --> 00:55:36,559
feels better to a large number of people

00:55:33,280 --> 00:55:36,559
so i think that really matters

00:55:38,240 --> 00:55:41,920
so uh yeah there's another question on

00:55:40,079 --> 00:55:45,119
which i'll get to in one second

00:55:41,920 --> 00:55:46,799
um so uh okay

00:55:45,119 --> 00:55:48,480
spruta l here is your question on a

00:55:46,799 --> 00:55:49,359
slide so what feature should be in rest

00:55:48,480 --> 00:55:52,000
00:55:49,359 --> 00:55:53,680
i actually don't care personally um

00:55:52,000 --> 00:55:54,640
there are some features i want obviously

00:55:53,680 --> 00:55:55,920
but i think that we should do it

00:55:54,640 --> 00:55:57,920
regardless

00:55:55,920 --> 00:55:59,520
and i don't think that we need to have a

00:55:57,920 --> 00:56:00,960
specific feature to justify doing in

00:55:59,520 --> 00:56:02,480
addition in fact i kind of think the

00:56:00,960 --> 00:56:05,040
argument is stronger

00:56:02,480 --> 00:56:06,720
purely on the like release engineering

00:56:05,040 --> 00:56:10,000
and marketing angles and not

00:56:06,720 --> 00:56:10,559
on the feature based things part of this

00:56:10,000 --> 00:56:12,640
is

00:56:10,559 --> 00:56:14,160
also because like consistency and

00:56:12,640 --> 00:56:15,760
scheduling overall is key

00:56:14,160 --> 00:56:16,960
if we miss something that misses a train

00:56:15,760 --> 00:56:17,520
it can get on the next train and that's

00:56:16,960 --> 00:56:21,359
fine

00:56:17,520 --> 00:56:23,280
but like if we release editions based on

00:56:21,359 --> 00:56:25,040
features then every time we have a new

00:56:23,280 --> 00:56:26,559
set of features we have to re-litigate

00:56:25,040 --> 00:56:28,319
this entire conversation

00:56:26,559 --> 00:56:29,920
and we already did it first with 2018

00:56:28,319 --> 00:56:30,799
edition and we're doing it now to set up

00:56:29,920 --> 00:56:32,559
this policy

00:56:30,799 --> 00:56:34,400
and i would like to not sort of like

00:56:32,559 --> 00:56:35,760
have the rust team be arguing every

00:56:34,400 --> 00:56:37,119
three years whether or not we should be

00:56:35,760 --> 00:56:38,799
releasing a decision or not

00:56:37,119 --> 00:56:40,000
or arguing like even more often than

00:56:38,799 --> 00:56:40,960
that like you know if we do it on a

00:56:40,000 --> 00:56:43,119
feature basis

00:56:40,960 --> 00:56:44,319
then it happens at random kind of times

00:56:43,119 --> 00:56:46,000
if we just say like hey

00:56:44,319 --> 00:56:47,440
this is the mechanism it happens on the

00:56:46,000 --> 00:56:49,520
schedule

00:56:47,440 --> 00:56:51,119
period then we can free our time

00:56:49,520 --> 00:56:51,760
actually working on making rust a better

00:56:51,119 --> 00:56:53,920
language

00:56:51,760 --> 00:56:56,000
rather than worrying about this policy

00:56:53,920 --> 00:57:00,319
um and so i think that's actually the

00:56:56,000 --> 00:57:02,799
sort of most important kind of thing um

00:57:00,319 --> 00:57:04,880
i will answer that question predko uh

00:57:02,799 --> 00:57:08,319
afterwards

00:57:04,880 --> 00:57:10,079
um so why a three-year cadence um it's

00:57:08,319 --> 00:57:11,920
just like a nice length of time

00:57:10,079 --> 00:57:13,200
um sepals plus has a three-year cadence

00:57:11,920 --> 00:57:15,680
uh as of late

00:57:13,200 --> 00:57:16,880
and uh yearly is too often because like

00:57:15,680 --> 00:57:18,480
there's not enough stuff to sort of

00:57:16,880 --> 00:57:19,280
accumulate to make it a big enough deal

00:57:18,480 --> 00:57:21,200
every year

00:57:19,280 --> 00:57:22,559
five years would be far too long in my

00:57:21,200 --> 00:57:23,440
mind so i think three is kind of a nice

00:57:22,559 --> 00:57:25,359
compromise

00:57:23,440 --> 00:57:27,440
and uh if it's similar to c plus and so

00:57:25,359 --> 00:57:31,599
i think that uh i think that happens

00:57:27,440 --> 00:57:34,720
um specifically i bring c plus plus

00:57:31,599 --> 00:57:36,240
uh up because c plus plus ox i think is

00:57:34,720 --> 00:57:38,240
a cautionary tale that we didn't really

00:57:36,240 --> 00:57:40,079
learn enough for for the 2018 edition

00:57:38,240 --> 00:57:41,119
and it feels very similar to the 2018

00:57:40,079 --> 00:57:43,599
edition for me

00:57:41,119 --> 00:57:45,359
so the first draft of the this standard

00:57:43,599 --> 00:57:47,520
of c plus was in 2008

00:57:45,359 --> 00:57:48,799
um c plus plus 03 was the previous year

00:57:47,520 --> 00:57:50,240
of the standard and so

00:57:48,799 --> 00:57:52,079
bjorn and some other people were hoping

00:57:50,240 --> 00:57:52,640
that this would be c plus plus 08 or o

00:57:52,079 --> 00:57:55,200
9.

00:57:52,640 --> 00:57:56,240
so they named it plus ox the problem was

00:57:55,200 --> 00:57:58,160
is that they made it

00:57:56,240 --> 00:57:59,359
on a feature basis and it took them so

00:57:58,160 --> 00:58:00,000
many years to get through all the

00:57:59,359 --> 00:58:02,000
details

00:58:00,000 --> 00:58:04,079
and ended up shipping in 2011 and so

00:58:02,000 --> 00:58:06,640
people used to joke that it was becoming

00:58:04,079 --> 00:58:08,799
oa because like they had missed like

00:58:06,640 --> 00:58:10,480
with the 0809 scheme it strip

00:58:08,799 --> 00:58:12,720
slipped to 10 so it should be c plus

00:58:10,480 --> 00:58:14,480
plus 10 but they'd already said ox

00:58:12,720 --> 00:58:16,000
so like you know this demonstrates some

00:58:14,480 --> 00:58:17,200
of this kind of like conflict here

00:58:16,000 --> 00:58:19,200
and so that's when they decided to move

00:58:17,200 --> 00:58:20,720
to the train model for the super plus

00:58:19,200 --> 00:58:21,440
releases was like we're releasing every

00:58:20,720 --> 00:58:23,839
three years

00:58:21,440 --> 00:58:25,440
because like this was just not great um

00:58:23,839 --> 00:58:27,040
and so i think we had a similar kind of

00:58:25,440 --> 00:58:30,240
learning from 2018

00:58:27,040 --> 00:58:32,240
so i think that that matters um

00:58:30,240 --> 00:58:33,760
i'm gonna answer some more of these

00:58:32,240 --> 00:58:35,359
questions afterwards because i'm almost

00:58:33,760 --> 00:58:36,400
done with my slides then we can get into

00:58:35,359 --> 00:58:40,160
sort of the details

00:58:36,400 --> 00:58:42,160
um so specifically um and this is kind

00:58:40,160 --> 00:58:44,799
of like the second part of uh

00:58:42,160 --> 00:58:45,920
of your questions brutal earlier so uh

00:58:44,799 --> 00:58:47,040
there's this comment on the internals

00:58:45,920 --> 00:58:49,760
forum recently like

00:58:47,040 --> 00:58:51,520
hey the roadmap for the year what things

00:58:49,760 --> 00:58:52,880
are we actually going to do in 2021 so

00:58:51,520 --> 00:58:54,079
even though i don't think it matters

00:58:52,880 --> 00:58:56,400
should talk a little bit about maybe

00:58:54,079 --> 00:58:57,760
what i see happening um so this is the

00:58:56,400 --> 00:58:59,200
text from the original rfc i'm not going

00:58:57,760 --> 00:59:00,400
to read all of it but if you want to go

00:58:59,200 --> 00:59:01,520
read it you can

00:59:00,400 --> 00:59:03,280
but what we talked about this year is

00:59:01,520 --> 00:59:04,880
when we prepare for an edition so the

00:59:03,280 --> 00:59:07,599
goal should be any changes we make for

00:59:04,880 --> 00:59:08,960
2021 are completed by october of 2020 so

00:59:07,599 --> 00:59:10,640
we should know what's going on

00:59:08,960 --> 00:59:11,680
so uh you know it's the end of july

00:59:10,640 --> 00:59:12,319
right now so that gives us a couple

00:59:11,680 --> 00:59:14,079
months

00:59:12,319 --> 00:59:16,400
but we should have the plan sort of like

00:59:14,079 --> 00:59:17,839
in um and also we said like

00:59:16,400 --> 00:59:20,160
we've not decided whether we were doing

00:59:17,839 --> 00:59:21,040
20 20 or not so we should also decide

00:59:20,160 --> 00:59:22,799
that we're gonna do it

00:59:21,040 --> 00:59:24,319
and so like i said this is my opinion

00:59:22,799 --> 00:59:25,119
but technically the project has not

00:59:24,319 --> 00:59:26,720
decided

00:59:25,119 --> 00:59:28,720
so that's also the work to do

00:59:26,720 --> 00:59:29,200
immediately is and part of deciding to

00:59:28,720 --> 00:59:31,119
do it

00:59:29,200 --> 00:59:32,480
is sort of deciding what should be in it

00:59:31,119 --> 00:59:34,240
too

00:59:32,480 --> 00:59:35,920
so there were some things about what

00:59:34,240 --> 00:59:38,480
might happen in the rfc

00:59:35,920 --> 00:59:39,760
we talked about maybe you know error

00:59:38,480 --> 00:59:41,760
handling might be a good thing to

00:59:39,760 --> 00:59:43,760
address because it's a big topic

00:59:41,760 --> 00:59:46,160
lately improvements on the trade system

00:59:43,760 --> 00:59:47,599
or improvements unsafe code

00:59:46,160 --> 00:59:50,480
but the goal is kind of like to figure

00:59:47,599 --> 00:59:52,160
out what that is and so

00:59:50,480 --> 00:59:54,079
we should have some specifics on exact

00:59:52,160 --> 00:59:55,200
features kind of soon-ish

00:59:54,079 --> 00:59:57,280
the language team has had a few

00:59:55,200 --> 00:59:58,799
discussions on this and as far as i know

00:59:57,280 --> 01:00:00,400
the goal is still to have a specific

00:59:58,799 --> 01:00:01,760
plan about auditions in october

01:00:00,400 --> 01:00:03,200
but as i said we still have to kind of

01:00:01,760 --> 01:00:05,599
also decide if we even want to do an

01:00:03,200 --> 01:00:05,599
edition

01:00:05,680 --> 01:00:08,960
on my audio cut out okay this is not

01:00:07,680 --> 01:00:11,280
formally done yet so

01:00:08,960 --> 01:00:13,200
um you know we also need to plan that

01:00:11,280 --> 01:00:14,799
and so i think that even the stuff the

01:00:13,200 --> 01:00:17,440
language team is talking about

01:00:14,799 --> 01:00:19,280
is nothing like 2018 like the scale is

01:00:17,440 --> 01:00:21,280
very very small overall

01:00:19,280 --> 01:00:23,200
um they're like kind of smaller details

01:00:21,280 --> 01:00:24,480
about things there's an example of one

01:00:23,200 --> 01:00:25,760
thing that's been talked about i don't

01:00:24,480 --> 01:00:26,880
know if this will happen or not or what

01:00:25,760 --> 01:00:28,240
the chances are even

01:00:26,880 --> 01:00:30,480
there's been some discussion that like

01:00:28,240 --> 01:00:31,760
unsafe functions should have

01:00:30,480 --> 01:00:33,599
be able to call unsafe code in their

01:00:31,760 --> 01:00:35,200
bodies without an unsafe block

01:00:33,599 --> 01:00:36,799
or you should need an unsafe block

01:00:35,200 --> 01:00:38,000
forget which order it is but there's

01:00:36,799 --> 01:00:38,880
like things like that that are like

01:00:38,000 --> 01:00:40,960
really tiny

01:00:38,880 --> 01:00:42,640
edge kind of things and nothing like the

01:00:40,960 --> 01:00:44,640
module system is being redone so i think

01:00:42,640 --> 01:00:46,799
anything that happens in 2021

01:00:44,640 --> 01:00:48,480
will be important and matter but like

01:00:46,799 --> 01:00:50,079
will be relatively small changes

01:00:48,480 --> 01:00:51,680
and not like we saw what happened in

01:00:50,079 --> 01:00:53,359
2018. um

01:00:51,680 --> 01:00:54,799
there is going to be an rfc on this

01:00:53,359 --> 01:00:56,160
question of policy

01:00:54,799 --> 01:00:57,920
nico and i were supposed to be working

01:00:56,160 --> 01:00:59,839
on this but honestly i got busy with my

01:00:57,920 --> 01:01:02,000
new job and nico did most of the work

01:00:59,839 --> 01:01:03,599
um so uh we should have something

01:01:02,000 --> 01:01:04,240
published relatively soon to answer this

01:01:03,599 --> 01:01:05,599
question

01:01:04,240 --> 01:01:07,280
and then we can have this discussion as

01:01:05,599 --> 01:01:07,839
a community overall because you know

01:01:07,280 --> 01:01:09,359
it's not

01:01:07,839 --> 01:01:10,960
the teams do get to decide what they

01:01:09,359 --> 01:01:12,319
want to decide but we want feedback from

01:01:10,960 --> 01:01:12,880
everyone to talk about all the details

01:01:12,319 --> 01:01:14,400
so

01:01:12,880 --> 01:01:16,000
um you know that stuff kind of matters

01:01:14,400 --> 01:01:17,200
so you can expect to see an rfc in the

01:01:16,000 --> 01:01:20,240
near-ish future

01:01:17,200 --> 01:01:21,599
um talking about the policy of whether

01:01:20,240 --> 01:01:22,880
we're having an audition or not

01:01:21,599 --> 01:01:23,839
and then also the language team you know

01:01:22,880 --> 01:01:25,200
if we decide we're having one the

01:01:23,839 --> 01:01:26,480
language team would be able like what is

01:01:25,200 --> 01:01:27,440
actually an edition so

01:01:26,480 --> 01:01:29,920
that's all going to come over the next

01:01:27,440 --> 01:01:31,119
four months so thank you for letting me

01:01:29,920 --> 01:01:32,799
talk about that for an hour

01:01:31,119 --> 01:01:33,920
um that's the end of my presentation and

01:01:32,799 --> 01:01:34,480
now there's some questions that were in

01:01:33,920 --> 01:01:35,520
the chat

01:01:34,480 --> 01:01:37,200
i definitely want to cover so i'm going

01:01:35,520 --> 01:01:38,000
to go from the start to the end of the

01:01:37,200 --> 01:01:41,680
ones i did not answer

01:01:38,000 --> 01:01:43,920
already um so uh

01:01:41,680 --> 01:01:45,599
okay there was a question um from

01:01:43,920 --> 01:01:46,720
someone whose name has a lot of numbers

01:01:45,599 --> 01:01:47,440
and i don't know how to pronounce it i'm

01:01:46,720 --> 01:01:49,040
sorry

01:01:47,440 --> 01:01:50,400
uh does it seem reasonable to you to

01:01:49,040 --> 01:01:51,200
make an addition a snapshot of already

01:01:50,400 --> 01:01:52,640
shipped features

01:01:51,200 --> 01:01:53,839
so keeping features opt-in until the

01:01:52,640 --> 01:01:55,359
next edition while making them shipped

01:01:53,839 --> 01:01:57,200
and stable as opt-in

01:01:55,359 --> 01:01:58,720
i think that's nice in some ways i think

01:01:57,200 --> 01:01:59,440
that doesn't always work in some other

01:01:58,720 --> 01:02:01,760
ways

01:01:59,440 --> 01:02:03,440
um so like what i would sort of like to

01:02:01,760 --> 01:02:05,280
see is that we have these

01:02:03,440 --> 01:02:06,720
like features that need an addition

01:02:05,280 --> 01:02:08,480
break you're sort of

01:02:06,720 --> 01:02:10,079
able to opt into the addition on

01:02:08,480 --> 01:02:11,680
unstable so it's kind of like that

01:02:10,079 --> 01:02:12,559
preview idea that happened before so

01:02:11,680 --> 01:02:14,000
basically like

01:02:12,559 --> 01:02:16,400
you know the feature exists and we're

01:02:14,000 --> 01:02:18,079
able to try it out on nightly

01:02:16,400 --> 01:02:20,319
but uh you know it's only about tweaking

01:02:18,079 --> 01:02:20,960
the edition rather than tweaking all the

01:02:20,319 --> 01:02:22,559
details

01:02:20,960 --> 01:02:24,079
and i think wherever possible we

01:02:22,559 --> 01:02:24,880
shouldn't use the addition mechanism

01:02:24,079 --> 01:02:26,160
like it

01:02:24,880 --> 01:02:28,160
making things a breaking change should

01:02:26,160 --> 01:02:30,160
happen only if they have to so

01:02:28,160 --> 01:02:31,680
you talk about the async keyword being a

01:02:30,160 --> 01:02:34,960
breaking change but uh

01:02:31,680 --> 01:02:36,640
i think that like uh you know the union

01:02:34,960 --> 01:02:38,240
keyword for example was a contextual

01:02:36,640 --> 01:02:39,359
keyword and we didn't need to do that in

01:02:38,240 --> 01:02:40,559
addition so we didn't

01:02:39,359 --> 01:02:42,480
we could have and maybe it would have

01:02:40,559 --> 01:02:44,559
been simpler but um i think that

01:02:42,480 --> 01:02:45,680
where prefer where we can ship it on all

01:02:44,559 --> 01:02:47,039
editions we should

01:02:45,680 --> 01:02:48,880
and we should only do it like when we

01:02:47,039 --> 01:02:50,960
actually you know uh

01:02:48,880 --> 01:02:52,880
need to so that's um that's the thing

01:02:50,960 --> 01:02:56,720
that matters

01:02:52,880 --> 01:02:58,799
um okay uh so

01:02:56,720 --> 01:03:00,720
preco sylvester asked a question about

01:02:58,799 --> 01:03:02,559
why we don't have function overloading

01:03:00,720 --> 01:03:03,760
so is this historical situation or some

01:03:02,559 --> 01:03:05,359
design background

01:03:03,760 --> 01:03:07,280
um kind of not exactly related to my

01:03:05,359 --> 01:03:08,400
talk other than in theory this is a big

01:03:07,280 --> 01:03:09,760
feature that would make sense for

01:03:08,400 --> 01:03:12,720
additions i guess so

01:03:09,760 --> 01:03:14,240
um i mean one simple example of why

01:03:12,720 --> 01:03:16,079
russell's not function overloading is no

01:03:14,240 --> 01:03:18,319
one has ever written an rfc

01:03:16,079 --> 01:03:20,000
to suggest adding it so some people have

01:03:18,319 --> 01:03:21,280
written pre-rfcs and some people have

01:03:20,000 --> 01:03:24,160
done some of the work

01:03:21,280 --> 01:03:24,799
but like honest core most features in

01:03:24,160 --> 01:03:27,359
rust

01:03:24,799 --> 01:03:27,920
uh you know don't exist because people

01:03:27,359 --> 01:03:29,760
didn't do

01:03:27,920 --> 01:03:31,599
the design work now this is a little

01:03:29,760 --> 01:03:33,119
controversial with this specific feature

01:03:31,599 --> 01:03:34,240
because like i said some people have

01:03:33,119 --> 01:03:37,680
gotten up there and i think there's

01:03:34,240 --> 01:03:38,720
actually an open rfc right now so

01:03:37,680 --> 01:03:40,799
maybe i don't want to say is there's no

01:03:38,720 --> 01:03:42,400
accepted rfc but i think that

01:03:40,799 --> 01:03:44,720
specifically function overloading is

01:03:42,400 --> 01:03:46,319
interesting because rust does have

01:03:44,720 --> 01:03:47,359
function overloading today in terms of

01:03:46,319 --> 01:03:49,200
traits

01:03:47,359 --> 01:03:50,400
sort of so it's not the same as like

01:03:49,200 --> 01:03:52,079
when you think about

01:03:50,400 --> 01:03:53,599
i i read a function with different

01:03:52,079 --> 01:03:54,319
signatures and like you know you figure

01:03:53,599 --> 01:03:56,240
how that works

01:03:54,319 --> 01:03:57,359
but like you can do that through traits

01:03:56,240 --> 01:04:00,400
sorta kinda

01:03:57,359 --> 01:04:01,119
and that is i think enough for most

01:04:00,400 --> 01:04:04,079
people

01:04:01,119 --> 01:04:04,559
that the idea of regular overloading is

01:04:04,079 --> 01:04:07,200
uh

01:04:04,559 --> 01:04:08,319
you know a bit too much i think also

01:04:07,200 --> 01:04:10,799
this is hard because

01:04:08,319 --> 01:04:12,160
function overloading optional arguments

01:04:10,799 --> 01:04:14,400
and named arguments

01:04:12,160 --> 01:04:15,520
kind of all are three features that are

01:04:14,400 --> 01:04:17,039
technically separate

01:04:15,520 --> 01:04:18,079
but are something as a language designer

01:04:17,039 --> 01:04:19,039
you kind of want to consider

01:04:18,079 --> 01:04:21,520
holistically

01:04:19,039 --> 01:04:22,720
and that's a really big design space and

01:04:21,520 --> 01:04:24,000
so there's also some people that are

01:04:22,720 --> 01:04:25,200
interested in those other two features

01:04:24,000 --> 01:04:27,520
as well

01:04:25,200 --> 01:04:29,280
but you kind of really in my opinion and

01:04:27,520 --> 01:04:31,119
i'm not on the lang team so again this

01:04:29,280 --> 01:04:35,280
is my personal opinion on this

01:04:31,119 --> 01:04:36,000
um these are like a large amount of big

01:04:35,280 --> 01:04:37,920
features

01:04:36,000 --> 01:04:40,559
that i don't actually think buys you

01:04:37,920 --> 01:04:41,760
that much personally for me so i don't

01:04:40,559 --> 01:04:44,640
really want to see these features

01:04:41,760 --> 01:04:45,839
added to rust um but that doesn't mean

01:04:44,640 --> 01:04:47,680
it won't happen like i said

01:04:45,839 --> 01:04:49,280
i'm not on the relevant team so my

01:04:47,680 --> 01:04:51,280
opinion is just contributing as a

01:04:49,280 --> 01:04:53,359
community member just like anyone else's

01:04:51,280 --> 01:04:54,880
but i think it's a huge design space and

01:04:53,359 --> 01:04:55,680
i think that most of the benefit is

01:04:54,880 --> 01:04:57,039
already there

01:04:55,680 --> 01:04:58,960
and so i personally don't think that it

01:04:57,039 --> 01:05:00,000
pulls its weight

01:04:58,960 --> 01:05:01,760
one thing i will say on the named

01:05:00,000 --> 01:05:03,599
arguments front though is i with rust

01:05:01,760 --> 01:05:04,960
analyzer putting the names of arguments

01:05:03,599 --> 01:05:06,400
displayed in the text

01:05:04,960 --> 01:05:08,160
i have found them more useful to see

01:05:06,400 --> 01:05:08,720
that i would have thought so it actually

01:05:08,160 --> 01:05:10,079
made me

01:05:08,720 --> 01:05:11,359
feel a little better about named

01:05:10,079 --> 01:05:12,240
arguments than i would have otherwise

01:05:11,359 --> 01:05:13,760
but i think that the

01:05:12,240 --> 01:05:14,880
again rust analyzer doing that gives you

01:05:13,760 --> 01:05:15,680
all the benefit without changing the

01:05:14,880 --> 01:05:17,039
language so

01:05:15,680 --> 01:05:18,480
putting in language seems like a lot of

01:05:17,039 --> 01:05:21,760
work it doesn't doesn't really get you a

01:05:18,480 --> 01:05:24,079
ton of benefit for me personally

01:05:21,760 --> 01:05:25,680
yeah i think the core challenge is that

01:05:24,079 --> 01:05:27,039
it's really hard to put all three of

01:05:25,680 --> 01:05:28,559
those features together and design them

01:05:27,039 --> 01:05:29,680
all at once that's a huge space and it's

01:05:28,559 --> 01:05:31,200
very difficult so

01:05:29,680 --> 01:05:32,480
i don't blame anyone that cares about

01:05:31,200 --> 01:05:32,880
this feature that has put in some of the

01:05:32,480 --> 01:05:34,160
work

01:05:32,880 --> 01:05:35,839
it's kind of like not made it happen

01:05:34,160 --> 01:05:37,599
because it's just it's really big topic

01:05:35,839 --> 01:05:40,720
in a really big area it's really hard

01:05:37,599 --> 01:05:42,799
um okay so uh floor b

01:05:40,720 --> 01:05:44,160
is talking about being in the uh only

01:05:42,799 --> 01:05:45,920
make editions happen when there's a need

01:05:44,160 --> 01:05:47,359
camp

01:05:45,920 --> 01:05:49,119
a big part of that is that the social

01:05:47,359 --> 01:05:50,079
and technical aspect are conflated would

01:05:49,119 --> 01:05:52,079
it make sense to separate

01:05:50,079 --> 01:05:54,000
them more the addition is a social event

01:05:52,079 --> 01:05:55,920
and addition is in cargo automall

01:05:54,000 --> 01:05:57,200
i i do think that this is like a

01:05:55,920 --> 01:06:00,160
coherent point of view

01:05:57,200 --> 01:06:01,920
but i just personally disagree i think

01:06:00,160 --> 01:06:03,920
that part of that is because

01:06:01,920 --> 01:06:05,119
you need the social side to advertise

01:06:03,920 --> 01:06:08,240
the technical side

01:06:05,119 --> 01:06:09,839
like they're inherently intertwined and

01:06:08,240 --> 01:06:10,880
i know as programmers we really like to

01:06:09,839 --> 01:06:12,720
separate out

01:06:10,880 --> 01:06:14,720
things and we you know want everything

01:06:12,720 --> 01:06:17,039
to be kind of in its own little box

01:06:14,720 --> 01:06:19,200
but i think that specifically like with

01:06:17,039 --> 01:06:20,079
big major changes to the language and

01:06:19,200 --> 01:06:21,039
ones that are breaking

01:06:20,079 --> 01:06:22,880
you're gonna have to learn about and

01:06:21,039 --> 01:06:24,400
stuff there has to be some sort of

01:06:22,880 --> 01:06:25,760
social component of letting people know

01:06:24,400 --> 01:06:28,480
that those things exist

01:06:25,760 --> 01:06:29,680
um and so like yeah you could argue that

01:06:28,480 --> 01:06:32,240
like we should

01:06:29,680 --> 01:06:33,520
um you know celebrate what we've done on

01:06:32,240 --> 01:06:35,440
a different cadence than

01:06:33,520 --> 01:06:37,520
the release of the actual breaking

01:06:35,440 --> 01:06:39,200
changes but like

01:06:37,520 --> 01:06:40,720
that just means we have kind of like two

01:06:39,200 --> 01:06:41,680
major points where we need a bunch of

01:06:40,720 --> 01:06:42,880
communication

01:06:41,680 --> 01:06:44,799
and i think that it all just works

01:06:42,880 --> 01:06:45,599
better by leaning into the fact that

01:06:44,799 --> 01:06:48,640
they're

01:06:45,599 --> 01:06:49,760
actually not separate um i do know that

01:06:48,640 --> 01:06:51,039
there are some people that feel very

01:06:49,760 --> 01:06:53,200
strongly that i'm wrong on this

01:06:51,039 --> 01:06:54,240
and that's also totally fine um just for

01:06:53,200 --> 01:06:56,000
me personally

01:06:54,240 --> 01:06:57,520
i think that they're not it's not really

01:06:56,000 --> 01:06:59,280
possible to untwine them and it's

01:06:57,520 --> 01:07:01,440
actually a good thing that they are

01:06:59,280 --> 01:07:02,559
together um because like you need to be

01:07:01,440 --> 01:07:04,000
able to communicate those things you

01:07:02,559 --> 01:07:07,599
need to make it work out so

01:07:04,000 --> 01:07:09,200
i don't know um okay uh

01:07:07,599 --> 01:07:11,280
january garner says should the six week

01:07:09,200 --> 01:07:12,559
cycle changes also be listed in the 2021

01:07:11,280 --> 01:07:13,680
announcement to be closer to the other

01:07:12,559 --> 01:07:15,839
language release

01:07:13,680 --> 01:07:15,839
so

01:07:27,119 --> 01:07:30,559
they should be like two separate ones

01:07:29,039 --> 01:07:32,319
kind of what we did last time was we

01:07:30,559 --> 01:07:34,000
blogged before the edition actually

01:07:32,319 --> 01:07:34,960
happened to kind of talk about what was

01:07:34,000 --> 01:07:36,799
going to happen

01:07:34,960 --> 01:07:38,240
and then the release post was kind of

01:07:36,799 --> 01:07:39,920
like more

01:07:38,240 --> 01:07:41,440
of you know describing the changes in

01:07:39,920 --> 01:07:43,599
detail so it's kind of a way to split

01:07:41,440 --> 01:07:45,440
that up a little bit

01:07:43,599 --> 01:07:46,880
to some degree i think that when you

01:07:45,440 --> 01:07:48,079
start to separate it out too much you

01:07:46,880 --> 01:07:49,440
get into the exact problem that we're

01:07:48,079 --> 01:07:49,839
talking about the last question which is

01:07:49,440 --> 01:07:51,200
like

01:07:49,839 --> 01:07:52,559
i think they need to be around each

01:07:51,200 --> 01:07:54,079
other because you want to communicate

01:07:52,559 --> 01:07:55,680
them at the same time

01:07:54,079 --> 01:07:57,119
so i do think that including them all in

01:07:55,680 --> 01:07:59,119
one thing or small

01:07:57,119 --> 01:08:00,720
maybe like in like a month kind of area

01:07:59,119 --> 01:08:02,319
sort of thing um

01:08:00,720 --> 01:08:04,960
but uh but yeah hope that answers your

01:08:02,319 --> 01:08:08,079
question uh

01:08:04,960 --> 01:08:10,400
jack asks would it be jack asks

01:08:08,079 --> 01:08:11,440
to be clear um would it be another three

01:08:10,400 --> 01:08:13,039
years till it's available or just

01:08:11,440 --> 01:08:16,400
available in the next russ c

01:08:13,039 --> 01:08:18,239
um so like basically

01:08:16,400 --> 01:08:20,000
i think that we should be flexible a

01:08:18,239 --> 01:08:21,279
little bit about the exact time when we

01:08:20,000 --> 01:08:22,159
stabilize the edition like i don't think

01:08:21,279 --> 01:08:24,000
we should commit

01:08:22,159 --> 01:08:25,679
to a specific release because i think

01:08:24,000 --> 01:08:26,239
that's what introduces like a lot of the

01:08:25,679 --> 01:08:28,000
problems

01:08:26,239 --> 01:08:29,520
it should just be sometime in that year

01:08:28,000 --> 01:08:30,799
and so i think this is part of also why

01:08:29,520 --> 01:08:32,159
it's like

01:08:30,799 --> 01:08:34,159
the land team has to have its stuff

01:08:32,159 --> 01:08:37,279
planned by october of this year

01:08:34,159 --> 01:08:38,000
because we want to be able to release it

01:08:37,279 --> 01:08:39,679
sometime next

01:08:38,000 --> 01:08:41,759
year and so if we have stuff done in

01:08:39,679 --> 01:08:42,480
2020 then there's a whole year's worth

01:08:41,759 --> 01:08:44,880
of time

01:08:42,480 --> 01:08:46,400
to have the schedule happen rather than

01:08:44,880 --> 01:08:47,359
trying to you know say okay we're gonna

01:08:46,400 --> 01:08:48,319
start thinking about this at the

01:08:47,359 --> 01:08:49,279
beginning of the year we're gonna ship

01:08:48,319 --> 01:08:52,239
it by the end of the year

01:08:49,279 --> 01:08:53,279
just like if we're ready in advance that

01:08:52,239 --> 01:08:56,560
that like helps

01:08:53,279 --> 01:08:56,560
alleviate that schedule pain

01:08:56,799 --> 01:08:59,359
excuse me

01:09:00,560 --> 01:09:11,120
okay also oops

01:09:06,880 --> 01:09:12,640
talking too long also

01:09:11,120 --> 01:09:15,120
wow okay i guess i just totally lost my

01:09:12,640 --> 01:09:15,120
voice sorry

01:09:16,239 --> 01:09:20,000
all right so also um i think that having

01:09:19,120 --> 01:09:22,080
the time

01:09:20,000 --> 01:09:23,199
before things are released matters

01:09:22,080 --> 01:09:24,480
because

01:09:23,199 --> 01:09:26,239
putting something in addition that has a

01:09:24,480 --> 01:09:28,239
breaking change as i said

01:09:26,239 --> 01:09:30,000
it impacts people a lot so we should do

01:09:28,239 --> 01:09:31,600
so very carefully

01:09:30,000 --> 01:09:33,359
and so i think that one of the sort of

01:09:31,600 --> 01:09:34,640
like problems of 2018 too was like we

01:09:33,359 --> 01:09:35,839
had these grand plans

01:09:34,640 --> 01:09:38,400
we threw them all in together at the

01:09:35,839 --> 01:09:41,440
last minute um in some sense

01:09:38,400 --> 01:09:43,040
like uh we should be more deliberate

01:09:41,440 --> 01:09:44,400
about what goes in the edition

01:09:43,040 --> 01:09:46,480
and therefore we should have to plan it

01:09:44,400 --> 01:09:47,920
earlier in advance because that means

01:09:46,480 --> 01:09:49,679
that we only are willing to do it for

01:09:47,920 --> 01:09:52,560
things that really really matter

01:09:49,679 --> 01:09:53,600
um and so i i also think that things

01:09:52,560 --> 01:09:54,080
should be planned ahead of time because

01:09:53,600 --> 01:09:56,640
of that

01:09:54,080 --> 01:09:58,480
um so yeah so it should land in rusty at

01:09:56,640 --> 01:09:59,040
some point during the year of the three

01:09:58,480 --> 01:10:00,560
years

01:09:59,040 --> 01:10:02,480
but i don't think the specifics matter

01:10:00,560 --> 01:10:04,480
that much

01:10:02,480 --> 01:10:06,640
and so another comment on that question

01:10:04,480 --> 01:10:10,000
was what does it mean if something

01:10:06,640 --> 01:10:11,040
oh audio there we go

01:10:10,000 --> 01:10:13,040
what does it mean if something misses

01:10:11,040 --> 01:10:14,800
the train like say we had a gc which is

01:10:13,040 --> 01:10:16,080
not a thing that could happen as you say

01:10:14,800 --> 01:10:18,080
but it missed the train would be another

01:10:16,080 --> 01:10:19,760
three years yeah so it would have to be

01:10:18,080 --> 01:10:20,880
another three years unless what missing

01:10:19,760 --> 01:10:22,320
the train would mean

01:10:20,880 --> 01:10:24,560
would mean that the stuff that needs to

01:10:22,320 --> 01:10:26,159
be backwards and compatible would miss

01:10:24,560 --> 01:10:28,239
the release so imagine if we did not

01:10:26,159 --> 01:10:30,480
make async a keyword in 2018

01:10:28,239 --> 01:10:31,840
it would have to be a keyword in 2021

01:10:30,480 --> 01:10:33,280
and that would mean that like async

01:10:31,840 --> 01:10:34,880
await couldn't have shipped yet because

01:10:33,280 --> 01:10:36,719
the time wouldn't have happened so

01:10:34,880 --> 01:10:38,400
i think the feature implementation

01:10:36,719 --> 01:10:40,000
missing the train is totally fine like

01:10:38,400 --> 01:10:42,640
that's what happened with async right

01:10:40,000 --> 01:10:43,840
like the breaking change made it in but

01:10:42,640 --> 01:10:44,960
the implementation didn't happen until

01:10:43,840 --> 01:10:47,920
later

01:10:44,960 --> 01:10:49,360
great i think that's totally fine um and

01:10:47,920 --> 01:10:50,080
in fact i think is the model that should

01:10:49,360 --> 01:10:52,800
kind of happen

01:10:50,080 --> 01:10:54,000
is that like the stuff that is breaking

01:10:52,800 --> 01:10:55,600
that's not ready yet

01:10:54,000 --> 01:10:58,719
we don't worry about making sure that

01:10:55,600 --> 01:11:00,480
it's actually happened exactly by um

01:10:58,719 --> 01:11:02,480
you know the time the release happens

01:11:00,480 --> 01:11:04,159
and some of this i think is because two

01:11:02,480 --> 01:11:05,920
it takes time for the ecosystem to catch

01:11:04,159 --> 01:11:08,320
up so for example with async

01:11:05,920 --> 01:11:10,480
like async even if async await had

01:11:08,320 --> 01:11:12,239
landed on the day of rest 2018

01:11:10,480 --> 01:11:14,000
the ecosystem would not be ready yet and

01:11:12,239 --> 01:11:15,520
so for most people like it's already

01:11:14,000 --> 01:11:16,159
been almost a year since these await

01:11:15,520 --> 01:11:18,960
happened

01:11:16,159 --> 01:11:19,920
time flies um and the ecosystem is

01:11:18,960 --> 01:11:21,600
really still

01:11:19,920 --> 01:11:24,239
only now finally getting into a

01:11:21,600 --> 01:11:26,080
production ready state like async await

01:11:24,239 --> 01:11:27,840
wasn't really a 2018 feature it was

01:11:26,080 --> 01:11:29,840
really a 2021 feature

01:11:27,840 --> 01:11:31,199
um and so i think that like really a lot

01:11:29,840 --> 01:11:32,800
of the edition stuff should be looking

01:11:31,199 --> 01:11:34,400
back over the last three years

01:11:32,800 --> 01:11:36,000
rather than looking forward to the new

01:11:34,400 --> 01:11:37,840
stuff and so like

01:11:36,000 --> 01:11:39,920
in some sense the stuff that we reserve

01:11:37,840 --> 01:11:41,760
in this edition you know gets used by

01:11:39,920 --> 01:11:43,040
folks and like is only really part of

01:11:41,760 --> 01:11:44,400
rust world until the future and i think

01:11:43,040 --> 01:11:45,760
there's some weird interplay there

01:11:44,400 --> 01:11:47,760
and that's also why it's kind of hard to

01:11:45,760 --> 01:11:49,520
do these kind of bigger macro level

01:11:47,760 --> 01:11:52,840
changes and thinking about things

01:11:49,520 --> 01:11:54,000
um so i hope that answers that question

01:11:52,840 --> 01:11:57,120
um

01:11:54,000 --> 01:11:58,640
okay uh angela favrett says

01:11:57,120 --> 01:12:00,320
there's many advances with having a

01:11:58,640 --> 01:12:01,760
unified async runtime instead of having

01:12:00,320 --> 01:12:03,600
conflicting runtimes like tokyo and

01:12:01,760 --> 01:12:06,080
actics

01:12:03,600 --> 01:12:07,600
so yes and no like i think that there's

01:12:06,080 --> 01:12:10,000
two things that are tied up here

01:12:07,600 --> 01:12:12,159
one is that uh i don't think it's

01:12:10,000 --> 01:12:13,600
possible to have a unified run time for

01:12:12,159 --> 01:12:14,560
everything because rust is used in too

01:12:13,600 --> 01:12:16,560
many places

01:12:14,560 --> 01:12:17,920
so for example like i'm a big fan of

01:12:16,560 --> 01:12:21,199
both of those projects

01:12:17,920 --> 01:12:22,800
um but i also do embedded rest work now

01:12:21,199 --> 01:12:24,480
and there's some stuff that maybe would

01:12:22,800 --> 01:12:25,840
be good as asynchronous i'm not going to

01:12:24,480 --> 01:12:29,360
be running tokyo

01:12:25,840 --> 01:12:30,960
on like my embedded device um so

01:12:29,360 --> 01:12:32,159
i would need an embedded executor that

01:12:30,960 --> 01:12:33,760
makes very different trade-offs than

01:12:32,159 --> 01:12:35,040
tokyo tokyo is built for network

01:12:33,760 --> 01:12:36,400
services specifically

01:12:35,040 --> 01:12:38,080
so it's made several trade-offs that

01:12:36,400 --> 01:12:39,760
make lots of sense for those things

01:12:38,080 --> 01:12:41,920
but it wouldn't make sense for my

01:12:39,760 --> 01:12:43,760
microcontroller and the same token like

01:12:41,920 --> 01:12:45,600
if i was building a web service i

01:12:43,760 --> 01:12:47,760
wouldn't want to use my microcontroller

01:12:45,600 --> 01:12:48,800
async await uh impul because it made the

01:12:47,760 --> 01:12:50,640
wrong trade-offs for me

01:12:48,800 --> 01:12:52,000
so i think that it's not possible for

01:12:50,640 --> 01:12:53,520
what what rust is trying to accomplish

01:12:52,000 --> 01:12:55,920
to have a unified run time

01:12:53,520 --> 01:12:56,800
that said it should be possible to make

01:12:55,920 --> 01:12:59,360
libraries you

01:12:56,800 --> 01:13:01,040
run time agnostic so it doesn't matter

01:12:59,360 --> 01:13:02,880
what you run time i'm using

01:13:01,040 --> 01:13:04,960
and that's like kind of one of those

01:13:02,880 --> 01:13:07,440
open things that's still being worked on

01:13:04,960 --> 01:13:08,800
um and uh you know like i don't think

01:13:07,440 --> 01:13:10,480
this is the kind of thing that happens

01:13:08,800 --> 01:13:11,920
from a big top-down perspective

01:13:10,480 --> 01:13:13,520
i think that it just takes time in the

01:13:11,920 --> 01:13:14,960
ecosystem for folks to hash out what

01:13:13,520 --> 01:13:16,480
they need and what's going on

01:13:14,960 --> 01:13:18,239
then we compare experiences and we

01:13:16,480 --> 01:13:19,760
consolidate where possible so

01:13:18,239 --> 01:13:21,440
um there hasn't been any big news on

01:13:19,760 --> 01:13:22,800
that front lately but like all the

01:13:21,440 --> 01:13:24,320
people involved are still working on it

01:13:22,800 --> 01:13:25,360
and i think everyone cares about making

01:13:24,320 --> 01:13:26,960
things agnostic

01:13:25,360 --> 01:13:28,320
at least conceptually because nobody

01:13:26,960 --> 01:13:29,760
wants things to be locked down into one

01:13:28,320 --> 01:13:32,800
specific area so

01:13:29,760 --> 01:13:34,480
it's just it's just really tricky but a

01:13:32,800 --> 01:13:36,239
lot of a lot of libraries are agnostic

01:13:34,480 --> 01:13:37,360
today but not as many as there could be

01:13:36,239 --> 01:13:39,760
and there's still more work to do there

01:13:37,360 --> 01:13:39,760
for sure

01:13:40,080 --> 01:13:45,920
all right another question from uh

01:13:43,199 --> 01:13:47,520
league league 11 is there any intent to

01:13:45,920 --> 01:13:49,199
sync the edition cycle with major

01:13:47,520 --> 01:13:51,600
distros and or windows major release

01:13:49,199 --> 01:13:52,320
cycles because that might be useful for

01:13:51,600 --> 01:13:55,360
you know

01:13:52,320 --> 01:13:57,520
centos debian et cetera um

01:13:55,360 --> 01:13:58,800
not really because the problem is that

01:13:57,520 --> 01:13:59,520
all of those things have different

01:13:58,800 --> 01:14:01,440
cycles

01:13:59,520 --> 01:14:02,719
and you can't really release them on the

01:14:01,440 --> 01:14:04,159
same like you're going to leave some

01:14:02,719 --> 01:14:05,840
people out no matter what

01:14:04,159 --> 01:14:07,360
so really we kind of just got to pick

01:14:05,840 --> 01:14:08,239
our own schedule and just kind of be

01:14:07,360 --> 01:14:10,320
done with it

01:14:08,239 --> 01:14:11,600
and uh that's sort of unfortunate i

01:14:10,320 --> 01:14:13,120
definitely agree with what you're

01:14:11,600 --> 01:14:16,159
getting at that would be really nice

01:14:13,120 --> 01:14:19,440
but just like i it's not

01:14:16,159 --> 01:14:20,960
really possible basically um and yeah i

01:14:19,440 --> 01:14:23,840
am doing great now thank you

01:14:20,960 --> 01:14:24,640
just took a while to get at a burnout um

01:14:23,840 --> 01:14:28,080
okay

01:14:24,640 --> 01:14:29,679
so uh best question i i i

01:14:28,080 --> 01:14:31,840
it's basically like there's only 15

01:14:29,679 --> 01:14:32,640
minutes left and uh i almost lost my

01:14:31,840 --> 01:14:33,920
voice as i said

01:14:32,640 --> 01:14:35,840
there's still more questions i've not

01:14:33,920 --> 01:14:36,400
answered i apologize and not get on to

01:14:35,840 --> 01:14:38,080
them

01:14:36,400 --> 01:14:39,679
um but uh we pretty much don't really

01:14:38,080 --> 01:14:42,239
have a ton of time so um

01:14:39,679 --> 01:14:44,080
i'm going to now pick somebody who asked

01:14:42,239 --> 01:14:44,960
a great question to uh sort of raffle

01:14:44,080 --> 01:14:48,640
off the book

01:14:44,960 --> 01:14:50,239
so um you know there's uh

01:14:48,640 --> 01:14:52,320
we're gonna leave it sort of that so let

01:14:50,239 --> 01:14:56,400
me think here what i think

01:14:52,320 --> 01:14:56,880
i think let's uh let's go with flora b's

01:14:56,400 --> 01:14:59,040
question

01:14:56,880 --> 01:15:00,480
because i think that it was big and was

01:14:59,040 --> 01:15:02,159
on topic with the topic

01:15:00,480 --> 01:15:04,560
and it was like against what i'm saying

01:15:02,159 --> 01:15:07,280
which is always fun asked in a nice way

01:15:04,560 --> 01:15:08,320
and a thing that matters so um floor b

01:15:07,280 --> 01:15:09,360
on twitch

01:15:08,320 --> 01:15:10,800
you're getting picked as my best

01:15:09,360 --> 01:15:12,400
question although i do appreciate all of

01:15:10,800 --> 01:15:13,840
them and i believe that means you get a

01:15:12,400 --> 01:15:15,920
copy of rest in action if i

01:15:13,840 --> 01:15:16,880
remember the details right so uh so

01:15:15,920 --> 01:15:19,120
that's cool

01:15:16,880 --> 01:15:20,159
um the last couple questions i didn't

01:15:19,120 --> 01:15:22,159
really get into

01:15:20,159 --> 01:15:24,880
sorry about that but uh if you want to

01:15:22,159 --> 01:15:27,120
email me i'm happy to talk over email

01:15:24,880 --> 01:15:29,120
or you know whatever else so thank you

01:15:27,120 --> 01:15:33,760
so much for listening everybody

01:15:29,120 --> 01:15:33,760

YouTube URL: https://www.youtube.com/watch?v=7LynNMrS8Z0


