Title: RustLatam 2019 - Kevin Hoffman: WebAssembly with Rust
Publication date: 2019-04-21
Playlist: Rust Latam 2019
Description: 
	WebAssembly fulfills the long-awaited promise of web technologies: fast code, type-safe at compile time, execution in the browser, on embedded devices, or anywhere else. Rust delivers the power of C in a language that strictly enforces type safety. Combine both languages and you can write for the web like never before!

In this demo-heavy talk Kevin will take us on a journey from the basics of WebAssembly to using WebAssembly to integrate with JavaScript, build complete websites, and even host and interpret in Rust apps.

He'll even show hot-swapping WebAssembly modules to control LEDs on a Raspberry Pi.

Follow us on Twitter: https://twitter.com/rustlatamconf
Captions: 
	00:00:03,160 --> 00:00:06,919
[Applause]

00:00:08,260 --> 00:00:15,759
so can you all hear me okay just a

00:00:12,549 --> 00:00:22,270
couple of things one I am NOT using

00:00:15,759 --> 00:00:25,030
keynote so we'll see I'm also not a

00:00:22,270 --> 00:00:27,220
front-end guy so I want to set the bar

00:00:25,030 --> 00:00:29,740
really low I don't have fancy animations

00:00:27,220 --> 00:00:33,340
or any of the really good stuff that the

00:00:29,740 --> 00:00:34,840
previous presenter slides had so I would

00:00:33,340 --> 00:00:40,150
I would do this all from a terminal

00:00:34,840 --> 00:00:43,510
window if they let me but so I've been

00:00:40,150 --> 00:00:48,970
using rust for about two years off and

00:00:43,510 --> 00:00:54,550
on I just recently finished a web

00:00:48,970 --> 00:00:58,570
assembly book that uses rust my day job

00:00:54,550 --> 00:01:03,340
is pretty much all go I'm a huge elixir

00:00:58,570 --> 00:01:05,760
fan and I will take a few seconds just

00:01:03,340 --> 00:01:08,140
to troll the previous presenter about

00:01:05,760 --> 00:01:13,600
OTP having less than 10 microseconds

00:01:08,140 --> 00:01:17,260
called start I'm just saying and then

00:01:13,600 --> 00:01:20,620
I'm also like I said I'm a back-end guy

00:01:17,260 --> 00:01:23,860
distributed systems are what I do the

00:01:20,620 --> 00:01:26,200
less user interface the better for me so

00:01:23,860 --> 00:01:30,549
it makes me talking about web assembling

00:01:26,200 --> 00:01:32,520
a little interesting so what I want to

00:01:30,549 --> 00:01:36,010
make sure that you get out of this is

00:01:32,520 --> 00:01:38,500
some hopefully some curiosity about what

00:01:36,010 --> 00:01:40,770
web assembly is and more importantly

00:01:38,500 --> 00:01:44,979
where you should and shouldn't use it

00:01:40,770 --> 00:01:49,960
did anybody go to the workshop yesterday

00:01:44,979 --> 00:01:52,659
on the web assembly ok a couple other

00:01:49,960 --> 00:01:54,280
than the the references to web assembly

00:01:52,659 --> 00:01:58,150
that you've had here how many people are

00:01:54,280 --> 00:01:58,780
familiar with web assembly already ok so

00:01:58,150 --> 00:02:05,590
that's good

00:01:58,780 --> 00:02:07,210
it's better than usual and again this is

00:02:05,590 --> 00:02:09,109
a lot a lot of this comes from me being

00:02:07,210 --> 00:02:12,859
a back-end guy but

00:02:09,109 --> 00:02:15,530
I want to kind of focus on the idea that

00:02:12,859 --> 00:02:16,849
whether sembly isn't just a brand new

00:02:15,530 --> 00:02:22,519
way of doing JavaScript

00:02:16,849 --> 00:02:25,819
it isn't a JavaScript compiler or just

00:02:22,519 --> 00:02:29,420
another fancy flavor of typescript and I

00:02:25,819 --> 00:02:31,459
personally think calling it web assembly

00:02:29,420 --> 00:02:35,750
and having the web name in front of it

00:02:31,459 --> 00:02:38,359
is doing the technology a disservice and

00:02:35,750 --> 00:02:40,010
again so hopefully you'll be you'll

00:02:38,359 --> 00:02:43,639
you'll come away from this trying to

00:02:40,010 --> 00:02:49,639
find ways to build web assembly modules

00:02:43,639 --> 00:02:53,689
and rust and even host them in rust this

00:02:49,639 --> 00:02:58,150
is a fairly opinionated slide born of my

00:02:53,689 --> 00:03:00,500
hatred of front-end development what

00:02:58,150 --> 00:03:05,060
what we have with web development today

00:03:00,500 --> 00:03:07,040
is a lot of fragmentation we have to

00:03:05,060 --> 00:03:08,480
deal with browser compatibility we have

00:03:07,040 --> 00:03:11,599
to deal with different build

00:03:08,480 --> 00:03:15,590
environments typescript Java scripts all

00:03:11,599 --> 00:03:17,269
the other scripts the bigger our

00:03:15,590 --> 00:03:22,569
applications are getting bigger they're

00:03:17,269 --> 00:03:22,569
getting slower I'm sure we all use slack

00:03:23,660 --> 00:03:31,970
I don't really need to add any more

00:03:25,640 --> 00:03:36,050
commentary there it's as R as the web

00:03:31,970 --> 00:03:39,070
becomes more powerful humans expand to

00:03:36,050 --> 00:03:41,510
fill whatever space they're given and

00:03:39,070 --> 00:03:44,180
we're doing the same thing with our web

00:03:41,510 --> 00:03:47,690
technology and so the more power we have

00:03:44,180 --> 00:03:49,940
the more power we waste and I think

00:03:47,690 --> 00:03:51,410
there's a better way to do it not a not

00:03:49,940 --> 00:03:58,220
a better way to waste power but a better

00:03:51,410 --> 00:04:03,010
way to build applications and as a

00:03:58,220 --> 00:04:06,710
back-end guy the just the amount of

00:04:03,010 --> 00:04:09,680
tooling and setup that's necessary to

00:04:06,710 --> 00:04:13,760
even get a basic hello world running on

00:04:09,680 --> 00:04:16,340
the web now is it's just ridiculous the

00:04:13,760 --> 00:04:22,250
the node modules directory needs to go

00:04:16,340 --> 00:04:23,900
away and I think that web assembly can

00:04:22,250 --> 00:04:27,500
get us there it's certainly not going to

00:04:23,900 --> 00:04:30,170
replace JavaScript sadly it's not going

00:04:27,500 --> 00:04:33,680
to replace node or the node modules

00:04:30,170 --> 00:04:39,350
directory but hopefully it'll give us a

00:04:33,680 --> 00:04:43,970
way to get some of the benefits of you

00:04:39,350 --> 00:04:46,850
know the the Russ language and bring

00:04:43,970 --> 00:04:52,490
those to the front end and the back end

00:04:46,850 --> 00:04:55,760
as well so we've been over we've seen a

00:04:52,490 --> 00:04:59,380
little bit of what web assembly is it's

00:04:55,760 --> 00:05:01,550
portable it's a standard binary format

00:04:59,380 --> 00:05:07,460
everyone familiar with what a stack

00:05:01,550 --> 00:05:11,180
machine is the silence means I'm okay

00:05:07,460 --> 00:05:13,100
so there's when we run virtual machines

00:05:11,180 --> 00:05:15,800
we can essentially run stack machine or

00:05:13,100 --> 00:05:17,570
register machine and it just refers to

00:05:15,800 --> 00:05:21,260
the difference between how we pop

00:05:17,570 --> 00:05:24,760
instructions off and we access and read

00:05:21,260 --> 00:05:28,040
the data that we need and web assembly

00:05:24,760 --> 00:05:31,780
along with Java bytecode and the.net

00:05:28,040 --> 00:05:31,780
runtime are all stack machines

00:05:32,880 --> 00:05:45,430
the webassembly is safe and isolated and

00:05:39,120 --> 00:05:48,580
its memory is in a sandbox I'll get to

00:05:45,430 --> 00:05:51,370
security and hopefully again controlling

00:05:48,580 --> 00:05:54,160
the previous presenter of about how

00:05:51,370 --> 00:05:56,800
secure webassembly can be and in a

00:05:54,160 --> 00:05:58,720
couple slides but one of the important

00:05:56,800 --> 00:06:02,140
things here is that you can compile to

00:05:58,720 --> 00:06:05,650
webassembly from any of the supported

00:06:02,140 --> 00:06:07,990
languages and when I started writing the

00:06:05,650 --> 00:06:10,150
web assembly book that was essentially

00:06:07,990 --> 00:06:16,680
one length with two languages Rustin C

00:06:10,150 --> 00:06:21,550
or C++ and now you can do C C++ rust go

00:06:16,680 --> 00:06:23,920
there's a couple of other ways you can

00:06:21,550 --> 00:06:27,700
do it you can for whatever reason

00:06:23,920 --> 00:06:30,850
compile JavaScript into web assembly I'm

00:06:27,700 --> 00:06:34,390
not really sure what niche that's trying

00:06:30,850 --> 00:06:38,080
to fill but it's possible you can then

00:06:34,390 --> 00:06:39,880
interpret web assembly in dozens of

00:06:38,080 --> 00:06:43,810
different languages and I think this is

00:06:39,880 --> 00:06:45,910
the more important part that well we all

00:06:43,810 --> 00:06:48,340
just assume that web assembly has a

00:06:45,910 --> 00:06:52,240
runtime so we think the browser or the

00:06:48,340 --> 00:06:55,150
v8 engine that's just one of many

00:06:52,240 --> 00:06:59,650
possible runtimes and it just happens to

00:06:55,150 --> 00:07:02,620
expose a JavaScript API go can host and

00:06:59,650 --> 00:07:10,930
run web assembly modules so can rust so

00:07:02,620 --> 00:07:13,110
can see when you leave here and you just

00:07:10,930 --> 00:07:16,330
you immediately feel the need to google

00:07:13,110 --> 00:07:19,780
web assembly technology there's a couple

00:07:16,330 --> 00:07:22,000
of key words that you shouldn't you can

00:07:19,780 --> 00:07:25,170
search for I'm just trying to save you

00:07:22,000 --> 00:07:30,010
on open tab space on the browser here

00:07:25,170 --> 00:07:32,650
the module is the portable binary format

00:07:30,010 --> 00:07:37,840
it's the web assembly file that dot

00:07:32,650 --> 00:07:40,390
Wazza mcleod web assembly has concept of

00:07:37,840 --> 00:07:41,650
tables and at the moment the tables are

00:07:40,390 --> 00:07:44,590
only there to

00:07:41,650 --> 00:07:46,690
will allow us to do function mapping I

00:07:44,590 --> 00:07:49,870
think the spec has more room for

00:07:46,690 --> 00:07:52,840
advancement there but it's not really an

00:07:49,870 --> 00:07:56,169
area that I've dug and much into linear

00:07:52,840 --> 00:07:58,780
memory just big blocks of arrays and

00:07:56,169 --> 00:08:02,800
that's where that's how webassembly

00:07:58,780 --> 00:08:07,449
accesses its internal data and in the

00:08:02,800 --> 00:08:11,110
browser you can you can give webassembly

00:08:07,449 --> 00:08:14,139
a linear memory or you can take it from

00:08:11,110 --> 00:08:16,210
the web assembly module so depending on

00:08:14,139 --> 00:08:19,180
how you want it set up you can choose to

00:08:16,210 --> 00:08:22,330
share memory and this goes some of this

00:08:19,180 --> 00:08:24,039
goes to security webassembly can only

00:08:22,330 --> 00:08:27,550
access the memory that you tell it it

00:08:24,039 --> 00:08:31,380
can access so it's only as secure as the

00:08:27,550 --> 00:08:34,240
host environment and admittedly

00:08:31,380 --> 00:08:37,570
javascript has a number of ways to be

00:08:34,240 --> 00:08:40,900
exploited but if you're running web

00:08:37,570 --> 00:08:42,820
family in a more tailored fit

00:08:40,900 --> 00:08:46,020
environment then you can make it as as

00:08:42,820 --> 00:08:49,630
secure as you want a trap is just

00:08:46,020 --> 00:08:52,720
essentially webassembly terminology for

00:08:49,630 --> 00:08:55,720
handling an exception and imports and

00:08:52,720 --> 00:08:58,209
exports are the two most important

00:08:55,720 --> 00:09:01,930
things that webassembly does imports

00:08:58,209 --> 00:09:04,300
refer to the host environment feeding

00:09:01,930 --> 00:09:08,380
webassembly hooks so that it can do

00:09:04,300 --> 00:09:11,950
things and then exports involved it

00:09:08,380 --> 00:09:14,020
refers to web assembly the web assembly

00:09:11,950 --> 00:09:18,940
module exporting functions so that they

00:09:14,020 --> 00:09:23,050
can be called by the host web assembly

00:09:18,940 --> 00:09:26,110
has four data types and that's it and I

00:09:23,050 --> 00:09:29,709
just I assume we all sort of knew this

00:09:26,110 --> 00:09:32,140
but I want to point out that all of the

00:09:29,709 --> 00:09:35,230
other fanciness that we see sitting on

00:09:32,140 --> 00:09:38,050
top of web assembly is smoke and mirrors

00:09:35,230 --> 00:09:40,420
it's all generated code being able to

00:09:38,050 --> 00:09:43,810
compile Doom and run it in web assembly

00:09:40,420 --> 00:09:48,220
while fun and a great way to spend a day

00:09:43,810 --> 00:09:50,440
at work is all code generation there's

00:09:48,220 --> 00:09:53,190
nothing there's nothing really

00:09:50,440 --> 00:09:57,940
webassembly about it

00:09:53,190 --> 00:10:01,450
so we have two integer types 32 bit and

00:09:57,940 --> 00:10:03,580
64 and we have to float types those are

00:10:01,450 --> 00:10:05,290
the only parameters you can accept on

00:10:03,580 --> 00:10:12,370
webassembly function and those are the

00:10:05,290 --> 00:10:14,680
only return types so why do we want to

00:10:12,370 --> 00:10:17,170
use webassembly other than just the fact

00:10:14,680 --> 00:10:22,150
that it's new and shiny and that's what

00:10:17,170 --> 00:10:27,280
we're attracted to for me I think one of

00:10:22,150 --> 00:10:30,010
the biggest reasons is portability we

00:10:27,280 --> 00:10:32,550
have we've always been we've been given

00:10:30,010 --> 00:10:37,720
this promise of write once run anywhere

00:10:32,550 --> 00:10:39,930
since the beginning days of Java and we

00:10:37,720 --> 00:10:42,970
didn't get what we were promised dotnet

00:10:39,930 --> 00:10:46,300
the the.net framework promised that we

00:10:42,970 --> 00:10:49,780
didn't get that either dotnet core is

00:10:46,300 --> 00:10:52,480
closer than Java was but it's still not

00:10:49,780 --> 00:10:55,180
really the the vision of having this

00:10:52,480 --> 00:10:58,540
Universal binary format that anything

00:10:55,180 --> 00:11:00,460
can execute and I think webassembly

00:10:58,540 --> 00:11:06,630
actually gives us a chance at finally

00:11:00,460 --> 00:11:10,330
having that web assembly is fast the

00:11:06,630 --> 00:11:12,820
through some details about how the

00:11:10,330 --> 00:11:16,750
virtual machine works and how fact

00:11:12,820 --> 00:11:19,030
machines work it's extremely fast but

00:11:16,750 --> 00:11:21,160
like I said without the imports and

00:11:19,030 --> 00:11:24,460
exports where the assembly is really

00:11:21,160 --> 00:11:28,180
just a really fast calculator it can do

00:11:24,460 --> 00:11:31,570
very little other than add and subtract

00:11:28,180 --> 00:11:38,260
and do math operations what what gives

00:11:31,570 --> 00:11:42,730
it its power is the host environment web

00:11:38,260 --> 00:11:45,670
assembly is secure like I said it it's

00:11:42,730 --> 00:11:49,360
as secure as its host environment you

00:11:45,670 --> 00:11:52,360
can secure the memory so that it so that

00:11:49,360 --> 00:11:54,550
it can't be tampered with you can secure

00:11:52,360 --> 00:11:58,180
the web assembly module itself the spec

00:11:54,550 --> 00:12:00,250
has room inside the binary file for I

00:11:58,180 --> 00:12:03,910
forget what the

00:12:00,250 --> 00:12:06,130
is called maybe just metadata you can

00:12:03,910 --> 00:12:08,830
add a digital signature to the file so

00:12:06,130 --> 00:12:14,020
that you can verify that you own or you

00:12:08,830 --> 00:12:16,870
produced that file webassembly is safe

00:12:14,020 --> 00:12:19,620
again it's a in a browser it's

00:12:16,870 --> 00:12:23,320
essentially a sandbox within a sandbox

00:12:19,620 --> 00:12:28,500
it's compiled which means we get all of

00:12:23,320 --> 00:12:32,440
the benefits of rust compile time safety

00:12:28,500 --> 00:12:36,450
and type checking it's compact

00:12:32,440 --> 00:12:39,970
yeah I think someone said yesterday's

00:12:36,450 --> 00:12:42,100
you know weather sembly format was

00:12:39,970 --> 00:12:49,440
specifically designed for download over

00:12:42,100 --> 00:12:51,610
the web and it is surprisingly small I

00:12:49,440 --> 00:12:55,090
actually meant to put portable here

00:12:51,610 --> 00:12:58,090
twice just because I wanted to harp on

00:12:55,090 --> 00:13:02,680
that one point and webassembly is

00:12:58,090 --> 00:13:05,710
largely language agnostic as long as you

00:13:02,680 --> 00:13:07,600
build something that can create a binary

00:13:05,710 --> 00:13:08,890
that conforms to the spec it doesn't

00:13:07,600 --> 00:13:11,050
make any difference what language you

00:13:08,890 --> 00:13:12,760
wrote it in and it doesn't make any

00:13:11,050 --> 00:13:15,370
difference what language is running as

00:13:12,760 --> 00:13:20,080
the host whether it's a browser or a

00:13:15,370 --> 00:13:22,780
rest console application or as I'll

00:13:20,080 --> 00:13:28,060
mention a little bit even

00:13:22,780 --> 00:13:30,040
serverless functions does anybody really

00:13:28,060 --> 00:13:35,430
need me to go into why we want to use

00:13:30,040 --> 00:13:39,820
rush for this I do run into this problem

00:13:35,430 --> 00:13:45,000
when talking to different people who

00:13:39,820 --> 00:13:49,000
aren't at a rest conference and

00:13:45,000 --> 00:13:51,760
confidence safety performance one of the

00:13:49,000 --> 00:13:54,610
things that I think people don't give

00:13:51,760 --> 00:13:58,060
rust enough credit for is the expressive

00:13:54,610 --> 00:14:01,540
nature of the language itself in many

00:13:58,060 --> 00:14:04,990
cases when porting code from go to rust

00:14:01,540 --> 00:14:06,800
I've actually had the code become more

00:14:04,990 --> 00:14:08,630
readable not less

00:14:06,800 --> 00:14:10,459
you know people just to say oh well it's

00:14:08,630 --> 00:14:14,060
a systems language so obviously it's

00:14:10,459 --> 00:14:16,459
going to look like line noise and that

00:14:14,060 --> 00:14:19,060
is a really old reference so now you all

00:14:16,459 --> 00:14:19,060
know how old I am

00:14:20,080 --> 00:14:31,610
so I was looking for an analogy for what

00:14:24,290 --> 00:14:34,250
webassembly is and you know Fineman has

00:14:31,610 --> 00:14:36,230
had this saying where you don't really

00:14:34,250 --> 00:14:39,920
know a subject unless you can explain it

00:14:36,230 --> 00:14:43,940
in very simple terms and so for me web

00:14:39,920 --> 00:14:47,089
assembling is portable brains I can take

00:14:43,940 --> 00:14:51,529
the brain out of one thing and put it

00:14:47,089 --> 00:14:53,089
into another and assuming the those two

00:14:51,529 --> 00:14:56,810
things all share the same set of

00:14:53,089 --> 00:15:00,620
appendages it should just work so one of

00:14:56,810 --> 00:15:03,290
my brains could be running inside

00:15:00,620 --> 00:15:09,140
kubernetes as an open fast function

00:15:03,290 --> 00:15:14,990
which I've actually gotten working at

00:15:09,140 --> 00:15:17,170
3:00 or so in the morning today you

00:15:14,990 --> 00:15:20,420
could get it you could host this

00:15:17,170 --> 00:15:23,810
portable brain inside Firefox you could

00:15:20,420 --> 00:15:27,560
host it in a Raspberry Pi you could host

00:15:23,810 --> 00:15:30,320
it as a command-line application or just

00:15:27,560 --> 00:15:32,630
a server application one of the things

00:15:30,320 --> 00:15:35,510
that I used to do before my current job

00:15:32,630 --> 00:15:39,410
was I wrote auto pilot software for

00:15:35,510 --> 00:15:43,610
search-and-rescue drones and you can

00:15:39,410 --> 00:15:45,440
imagine how hard it is to test your auto

00:15:43,610 --> 00:15:49,490
pilot software when it's designed to

00:15:45,440 --> 00:15:53,020
control physical motors and read from 10

00:15:49,490 --> 00:15:56,660
or 15 different sensors on a device and

00:15:53,020 --> 00:16:02,600
if I can if I had access to web assembly

00:15:56,660 --> 00:16:04,490
then I might still have here the what we

00:16:02,600 --> 00:16:08,209
get with web assemblies the ability to

00:16:04,490 --> 00:16:10,459
take that brain out of the the the

00:16:08,209 --> 00:16:13,459
physical device maybe it's a drone and

00:16:10,459 --> 00:16:16,760
put it into a test harness and I could

00:16:13,459 --> 00:16:18,079
literally run simulations for this drone

00:16:16,760 --> 00:16:20,420
you know what

00:16:18,079 --> 00:16:23,509
I could run it in a build pipeline

00:16:20,420 --> 00:16:27,139
through an automated test or I can run

00:16:23,509 --> 00:16:29,060
it on the physical device and I can't

00:16:27,139 --> 00:16:31,550
think of any other technology whether

00:16:29,060 --> 00:16:33,769
it's Java at core or anything else it

00:16:31,550 --> 00:16:37,490
gives me that type of portability I

00:16:33,769 --> 00:16:41,870
could write it all in C but no one wants

00:16:37,490 --> 00:16:45,310
to do that so the first thing I want to

00:16:41,870 --> 00:16:49,790
show is what ugly webassembly looks like

00:16:45,310 --> 00:16:52,009
we all need to know what people keep

00:16:49,790 --> 00:16:55,399
telling me to stop showing the ugly web

00:16:52,009 --> 00:16:58,639
assembly code because it's it's

00:16:55,399 --> 00:17:00,889
definitely not not pretty but I think we

00:16:58,639 --> 00:17:02,870
should know like the fact that whether

00:17:00,889 --> 00:17:05,120
somebody only has four data types and

00:17:02,870 --> 00:17:07,630
the fact that what assembly can't do

00:17:05,120 --> 00:17:10,220
anything that the hosts won't let it do

00:17:07,630 --> 00:17:11,900
we need to know what our code generators

00:17:10,220 --> 00:17:15,770
are building for us so that we can have

00:17:11,900 --> 00:17:17,929
an appreciation for when we do get doom

00:17:15,770 --> 00:17:20,030
running on the web we know how much is

00:17:17,929 --> 00:17:30,860
magic and how much is running inside web

00:17:20,030 --> 00:17:33,710
assembly so let me see if I can yeah I

00:17:30,860 --> 00:17:36,080
had this all set up in demo mode and I

00:17:33,710 --> 00:17:40,059
couldn't sleep started coding and went

00:17:36,080 --> 00:17:42,799
back to the wrong font size so this is

00:17:40,059 --> 00:17:45,080
what the text version of web assembly

00:17:42,799 --> 00:17:49,700
looks like has anybody seen this type of

00:17:45,080 --> 00:17:51,500
code before for web assembly a couple so

00:17:49,700 --> 00:17:56,000
the good news is you don't have to write

00:17:51,500 --> 00:17:58,750
this by hand this is a text version of

00:17:56,000 --> 00:18:01,940
the byte codes that are being read by

00:17:58,750 --> 00:18:07,490
either the browser or whatever runtime

00:18:01,940 --> 00:18:09,950
host you're in and just to kind of

00:18:07,490 --> 00:18:13,370
reiterate the data data types on these

00:18:09,950 --> 00:18:19,520
function parameters can only be integer

00:18:13,370 --> 00:18:22,520
integers or floats you can only do and

00:18:19,520 --> 00:18:24,590
you've got exports so this makes this

00:18:22,520 --> 00:18:27,290
function called add available to the

00:18:24,590 --> 00:18:27,840
host and so if my host is JavaScript I

00:18:27,290 --> 00:18:32,210
can

00:18:27,840 --> 00:18:34,440
run this function and you can see

00:18:32,210 --> 00:18:37,710
there's some JavaScript here

00:18:34,440 --> 00:18:40,580
this is just straight-up regular

00:18:37,710 --> 00:18:44,879
JavaScript it just happens to be

00:18:40,580 --> 00:18:48,989
compatible and I believe most modern

00:18:44,879 --> 00:18:50,489
browsers all support the the web

00:18:48,989 --> 00:18:55,649
assembly standard so you should be able

00:18:50,489 --> 00:18:58,289
to run this anyway unless you're in an

00:18:55,649 --> 00:19:02,580
enterprise and all of your customers are

00:18:58,289 --> 00:19:07,099
running ie 4 or something and that's not

00:19:02,580 --> 00:19:09,570
a joke that's that's that's my nightmare

00:19:07,099 --> 00:19:13,619
so basically we just we're loading the

00:19:09,570 --> 00:19:17,129
binary file up and then we're using the

00:19:13,619 --> 00:19:20,099
JavaScript web assembly class and you

00:19:17,129 --> 00:19:22,830
can think of this as yet one of many

00:19:20,099 --> 00:19:27,029
runtimes this webassembly that is

00:19:22,830 --> 00:19:29,339
instantiate is the JavaScript runtime

00:19:27,029 --> 00:19:32,700
for hosting a web assembly module and

00:19:29,339 --> 00:19:35,999
I'll show a rust at one time for hosting

00:19:32,700 --> 00:19:38,099
what assembly module but you know if I

00:19:35,999 --> 00:19:39,929
were to run this on you know web browser

00:19:38,099 --> 00:19:43,229
you would see this on the console and it

00:19:39,929 --> 00:19:46,469
all just looks as you would expect but

00:19:43,229 --> 00:19:49,109
the point here is that anything beyond

00:19:46,469 --> 00:19:52,440
what you see here and the ugly

00:19:49,109 --> 00:19:56,489
webassembly that i just showed is all

00:19:52,440 --> 00:20:00,330
code generation and whether it was

00:19:56,489 --> 00:20:03,450
compiled by rust or go it's all going to

00:20:00,330 --> 00:20:07,559
end up at least today you're looking at

00:20:03,450 --> 00:20:09,719
something like this and when as the web

00:20:07,559 --> 00:20:12,269
assembly spec grows and we get more

00:20:09,719 --> 00:20:14,719
potentially more data types or more

00:20:12,269 --> 00:20:18,779
robust ways to share data with the host

00:20:14,719 --> 00:20:21,269
then theoretically our shins will shrink

00:20:18,779 --> 00:20:28,289
but our development while our developer

00:20:21,269 --> 00:20:30,299
experience gets better so has anyone I

00:20:28,289 --> 00:20:33,749
think there were a few hands from from

00:20:30,299 --> 00:20:35,999
yesterday but who is compiled a rust

00:20:33,749 --> 00:20:37,700
application or a librarian to whether

00:20:35,999 --> 00:20:40,320
something

00:20:37,700 --> 00:20:43,490
okay so this should be this should also

00:20:40,320 --> 00:20:46,250
be a bit of a review but I want to

00:20:43,490 --> 00:20:51,450
continue to sort of building on the same

00:20:46,250 --> 00:20:58,680
code so this all looks pretty simple

00:20:51,450 --> 00:21:00,630
this was just standard rust we saw in a

00:20:58,680 --> 00:21:03,740
couple of different presentations today

00:21:00,630 --> 00:21:10,050
it's the extern keyword which we use for

00:21:03,740 --> 00:21:11,820
FFI and pretty much all of the rules and

00:21:10,050 --> 00:21:15,380
guidelines and patterns and practices

00:21:11,820 --> 00:21:19,020
that apply that if I apply to designing

00:21:15,380 --> 00:21:22,860
the public interface for your web

00:21:19,020 --> 00:21:25,680
assembly module I I know there's there's

00:21:22,860 --> 00:21:29,700
differing opinions but I tend to try and

00:21:25,680 --> 00:21:31,950
isolate the the piece of my rust code

00:21:29,700 --> 00:21:35,760
that sits at the barrier between rust

00:21:31,950 --> 00:21:38,660
and the and the host and that way all of

00:21:35,760 --> 00:21:43,110
the rest of it can be compiled for

00:21:38,660 --> 00:21:45,120
regular rust use or for Fi or any other

00:21:43,110 --> 00:21:48,750
reason and you know we saw samples of

00:21:45,120 --> 00:21:50,400
that earlier and so they'll run this we

00:21:48,750 --> 00:21:58,020
just build it as a web assembly module

00:21:50,400 --> 00:22:01,010
and we could copy this file into our

00:21:58,020 --> 00:22:05,030
directory and run the same thing from

00:22:01,010 --> 00:22:09,020
web assembly or from JavaScript and

00:22:05,030 --> 00:22:11,610
prove that we get the same results I

00:22:09,020 --> 00:22:13,380
don't expect to have a much spare time

00:22:11,610 --> 00:22:15,720
so I'll just I'll skip that demo and you

00:22:13,380 --> 00:22:23,160
can just sort of I'll wave my hands and

00:22:15,720 --> 00:22:27,540
you can accept that that stuff works so

00:22:23,160 --> 00:22:30,420
javascript integrations for the one or

00:22:27,540 --> 00:22:34,080
two front-end web developers left in the

00:22:30,420 --> 00:22:36,659
world is fairly important

00:22:34,080 --> 00:22:40,019
and one of the reasons why I think rust

00:22:36,659 --> 00:22:43,250
has an edge over some of the other

00:22:40,019 --> 00:22:46,559
programming language communities is the

00:22:43,250 --> 00:22:54,240
libraries that it has for manipulating

00:22:46,559 --> 00:22:55,890
and interacting with JavaScript so it's

00:22:54,240 --> 00:22:59,600
been mentioned a couple times today as

00:22:55,890 --> 00:23:08,399
well as yesterday during the workshop

00:22:59,600 --> 00:23:10,260
that wasn't by Jen is using macros to

00:23:08,399 --> 00:23:13,710
generate a whole bunch of code and

00:23:10,260 --> 00:23:16,139
hopefully now you've got a little bit of

00:23:13,710 --> 00:23:18,000
perspective on what exactly why isn't

00:23:16,139 --> 00:23:23,730
bind Jen is doing when it's generating

00:23:18,000 --> 00:23:25,440
the code at a low level it's adding

00:23:23,730 --> 00:23:27,240
functions to your web assembly module

00:23:25,440 --> 00:23:31,110
that can then be called again by the

00:23:27,240 --> 00:23:32,639
Weizmann by Jen COI to give it the

00:23:31,110 --> 00:23:37,139
metadata it needs to generate your

00:23:32,639 --> 00:23:39,330
JavaScript shims and sadly there isn't

00:23:37,139 --> 00:23:41,010
currently a version of wasm bind Jen

00:23:39,330 --> 00:23:43,380
that generates that automatically

00:23:41,010 --> 00:23:52,049
generates a rust host so we still have

00:23:43,380 --> 00:23:54,570
to do that by hand but maybe someday so

00:23:52,049 --> 00:23:57,139
the the two things that that generally

00:23:54,570 --> 00:24:01,620
people use that get the biggest reaction

00:23:57,139 --> 00:24:05,010
in JavaScript integration is you can

00:24:01,620 --> 00:24:07,019
import JavaScript that so that when it's

00:24:05,010 --> 00:24:10,230
imported it just looks and behaves like

00:24:07,019 --> 00:24:12,899
it's regular rust and you can export

00:24:10,230 --> 00:24:14,730
native rusts so that it appears as

00:24:12,899 --> 00:24:18,840
though it's just its regular JavaScript

00:24:14,730 --> 00:24:20,519
and the real power of this library is

00:24:18,840 --> 00:24:23,399
how seamlessly it bridges that gap

00:24:20,519 --> 00:24:25,700
between the two so that when you're

00:24:23,399 --> 00:24:28,200
looking at JavaScript you're not

00:24:25,700 --> 00:24:30,740
thinking oh this JavaScript came from

00:24:28,200 --> 00:24:33,690
rust like some other you know

00:24:30,740 --> 00:24:37,730
transpiling libraries tend to do they

00:24:33,690 --> 00:24:40,649
have some of these weird after-effects

00:24:37,730 --> 00:24:43,500
and again whereas mine Jen generates a

00:24:40,649 --> 00:24:44,250
bunch of these javascript shims to allow

00:24:43,500 --> 00:24:47,580
your

00:24:44,250 --> 00:24:50,070
to talk to JavaScript Jayesh sis and web

00:24:47,580 --> 00:24:52,230
sis are just essentially crates that

00:24:50,070 --> 00:24:54,990
defined things that you're going to need

00:24:52,230 --> 00:24:58,110
to talk to JavaScript so your basic

00:24:54,990 --> 00:25:02,549
JavaScript primitives because functions

00:24:58,110 --> 00:25:04,789
like console log web sis has the

00:25:02,549 --> 00:25:07,200
bindings that you need in order to

00:25:04,789 --> 00:25:10,169
traverse the DOM and the manipulation

00:25:07,200 --> 00:25:15,419
access some of the other functionality

00:25:10,169 --> 00:25:21,090
like WebGL audio has anyone who seems a

00:25:15,419 --> 00:25:23,220
SS before use this a couple you know

00:25:21,090 --> 00:25:26,970
essentially you can think of it as

00:25:23,220 --> 00:25:29,850
you've got this JSS crate prefix and

00:25:26,970 --> 00:25:33,600
then inside that crate you have access

00:25:29,850 --> 00:25:36,809
to rust functions and native rust

00:25:33,600 --> 00:25:38,549
structures that will eventually do their

00:25:36,809 --> 00:25:42,530
JavaScript equivalents so this will

00:25:38,549 --> 00:25:46,830
actually call the JavaScript date now

00:25:42,530 --> 00:25:49,289
function you can represent javascript

00:25:46,830 --> 00:25:54,000
native know create native JavaScript

00:25:49,289 --> 00:25:56,880
arrays everything that you need web sis

00:25:54,000 --> 00:25:59,520
essentially gives you access to the

00:25:56,880 --> 00:26:12,120
window and then through that you have

00:25:59,520 --> 00:26:14,820
access to the dome so one of the other

00:26:12,120 --> 00:26:17,070
libraries that you're so raise your hand

00:26:14,820 --> 00:26:19,559
if you actually do front-end development

00:26:17,070 --> 00:26:22,590
I know it's rare but you know if you do

00:26:19,559 --> 00:26:25,590
front-end development so if you're

00:26:22,590 --> 00:26:27,510
planning on doing if you're planning on

00:26:25,590 --> 00:26:30,840
exploring web assembly and you want to

00:26:27,510 --> 00:26:32,700
build a user interface you had oh it to

00:26:30,840 --> 00:26:39,510
yourself to go look at a library called

00:26:32,700 --> 00:26:44,280
u ye w it's a rush native library that

00:26:39,510 --> 00:26:46,320
gives you a react redux style set of

00:26:44,280 --> 00:26:49,049
message passing in order to control a

00:26:46,320 --> 00:26:51,570
virtual Dom and it all compiles into web

00:26:49,049 --> 00:26:54,669
assembly and

00:26:51,570 --> 00:26:57,250
if I have to do front-end web

00:26:54,669 --> 00:27:02,440
development doing it in rust isn't such

00:26:57,250 --> 00:27:05,679
a bad thing so how many have you how

00:27:02,440 --> 00:27:09,250
many have hosted a webassembly module in

00:27:05,679 --> 00:27:16,240
rust all right well you guys need to

00:27:09,250 --> 00:27:21,250
stop raising your hands because so as I

00:27:16,240 --> 00:27:23,440
said I am obviously biased towards

00:27:21,250 --> 00:27:27,879
back-end development and distributed

00:27:23,440 --> 00:27:29,950
systems and cloud and so being able to

00:27:27,879 --> 00:27:31,419
host the web assembly module in rust is

00:27:29,950 --> 00:27:34,179
where I think some of the real power

00:27:31,419 --> 00:27:38,139
comes from not just because I like

00:27:34,179 --> 00:27:42,009
hosting stuff and rust but because if

00:27:38,139 --> 00:27:44,860
rust can host it then so too can so many

00:27:42,009 --> 00:27:48,460
other things like I said we don't

00:27:44,860 --> 00:27:50,230
currently have a we don't have a tool

00:27:48,460 --> 00:27:51,909
that generates all the magic smoke and

00:27:50,230 --> 00:27:54,340
mirrors that we do for JavaScript so a

00:27:51,909 --> 00:27:56,860
lot of this stuff is still a little

00:27:54,340 --> 00:27:59,769
rough around the edges there was a crate

00:27:56,860 --> 00:28:01,419
there still is a crate called Waze me

00:27:59,769 --> 00:28:06,100
I'm sure it's got a better pronunciation

00:28:01,419 --> 00:28:10,480
than that but it came out of I think

00:28:06,100 --> 00:28:13,059
parodies work with blockchain and they

00:28:10,480 --> 00:28:16,809
were using it for blockchain contracts

00:28:13,059 --> 00:28:20,649
and as a result the developer experience

00:28:16,809 --> 00:28:23,200
isn't designed for you know what I would

00:28:20,649 --> 00:28:25,840
consider just common everyday use it's

00:28:23,200 --> 00:28:29,889
not a it's not a super friendly library

00:28:25,840 --> 00:28:33,159
there's a new one video sadly showed up

00:28:29,889 --> 00:28:36,700
after I finished writing my book called

00:28:33,159 --> 00:28:38,740
wise myrrh which building which is it's

00:28:36,700 --> 00:28:43,629
got a couple of nice macros that make it

00:28:38,740 --> 00:28:48,610
really really easy to host rust 200

00:28:43,629 --> 00:28:51,129
webassembly modules and rust so like I

00:28:48,610 --> 00:28:57,850
said you can use it for service embedded

00:28:51,129 --> 00:29:00,010
IOT micro services being able to use web

00:28:57,850 --> 00:29:01,200
assembly modules everywhere that used to

00:29:00,010 --> 00:29:04,050
be able to use a land

00:29:01,200 --> 00:29:06,900
or a cloud function who's pretty

00:29:04,050 --> 00:29:09,240
appealing I mentioned briefly that you

00:29:06,900 --> 00:29:11,280
can sign the module so that in your

00:29:09,240 --> 00:29:14,040
production environment you can guarantee

00:29:11,280 --> 00:29:16,800
that a particular webassembly module

00:29:14,040 --> 00:29:21,570
came from who says it came from and can

00:29:16,800 --> 00:29:30,840
do what they claim they can do just took

00:29:21,570 --> 00:29:33,110
a quick look at Christine Bennett here

00:29:30,840 --> 00:29:33,110
we go

00:29:35,010 --> 00:29:41,880
so I've got a sample here that's just a

00:29:38,010 --> 00:29:44,730
rust application that runs a that runs

00:29:41,880 --> 00:29:48,200
it interprets a web assembly module so

00:29:44,730 --> 00:29:51,059
the module just does its got a

00:29:48,200 --> 00:29:53,160
functional that logs a string from

00:29:51,059 --> 00:29:57,809
inside the web assembly module so this

00:29:53,160 --> 00:30:01,309
is an export and then there's a function

00:29:57,809 --> 00:30:05,610
that will be exported called do work and

00:30:01,309 --> 00:30:08,250
these imports and exports operate the

00:30:05,610 --> 00:30:11,760
same way as they would if I were to be

00:30:08,250 --> 00:30:14,580
running this in JavaScript so I can I

00:30:11,760 --> 00:30:18,270
can compile this to webassembly running

00:30:14,580 --> 00:30:21,000
in a browser and then I can run the same

00:30:18,270 --> 00:30:24,330
file unmodified which is that the real

00:30:21,000 --> 00:30:28,950
test of portability inside a rust host

00:30:24,330 --> 00:30:34,710
and to do that I just use the wesbar

00:30:28,950 --> 00:30:37,080
untime crate and you know I'm just

00:30:34,710 --> 00:30:40,410
obviously I'm just hacking around to

00:30:37,080 --> 00:30:43,380
grab the bytes you would get them from

00:30:40,410 --> 00:30:46,500
disk or you'd get them injected through

00:30:43,380 --> 00:30:48,720
a network call in some sort of service

00:30:46,500 --> 00:30:50,280
environment there's all sorts of ways

00:30:48,720 --> 00:30:56,250
you could get these bytes loaded into

00:30:50,280 --> 00:30:59,490
memory but this section right here is

00:30:56,250 --> 00:31:02,270
essentially where all of what most of

00:30:59,490 --> 00:31:05,730
the web assembly magic happens the

00:31:02,270 --> 00:31:07,650
setting the imports is explicitly

00:31:05,730 --> 00:31:09,809
telling your web assembly module what it

00:31:07,650 --> 00:31:12,510
can and can't do if it's not in this

00:31:09,809 --> 00:31:14,940
import list then your web assembly

00:31:12,510 --> 00:31:17,750
module can't do it if you don't include

00:31:14,940 --> 00:31:20,700
the ability to print to standard out

00:31:17,750 --> 00:31:24,630
through some import your web assembly

00:31:20,700 --> 00:31:27,720
module can't do it if you if you show me

00:31:24,630 --> 00:31:29,280
a JavaScript app that is running a web

00:31:27,720 --> 00:31:34,340
assembly module that prints to the

00:31:29,280 --> 00:31:37,260
console the only way it's happening is

00:31:34,340 --> 00:31:40,710
through something like this and it's

00:31:37,260 --> 00:31:42,630
because we're getting so much of that

00:31:40,710 --> 00:31:45,400
JavaScript generated for us that we just

00:31:42,630 --> 00:31:51,160
kind of take it for granted

00:31:45,400 --> 00:31:55,360
and who has heard of Wasi or was aware

00:31:51,160 --> 00:31:59,890
that the the recent announcement okay so

00:31:55,360 --> 00:32:02,200
not too many so right here I have a

00:31:59,890 --> 00:32:04,300
function that's being exported and it

00:32:02,200 --> 00:32:06,970
has a name called blog stir that's

00:32:04,300 --> 00:32:09,610
obviously proprietary and only works on

00:32:06,970 --> 00:32:12,580
my samples I lose portability when I

00:32:09,610 --> 00:32:14,590
take this module out of my rushed host

00:32:12,580 --> 00:32:17,140
and try and run it somewhere else where

00:32:14,590 --> 00:32:20,650
I don't get the logs they're import so

00:32:17,140 --> 00:32:23,200
what Wasi is trying to do is define a

00:32:20,650 --> 00:32:26,200
set of standards that can be injected

00:32:23,200 --> 00:32:29,080
into the imports of a web assembly

00:32:26,200 --> 00:32:34,630
module so that we do have portability if

00:32:29,080 --> 00:32:37,900
we have like Wasi core we should be able

00:32:34,630 --> 00:32:40,540
to assume that we'll be able to print a

00:32:37,900 --> 00:32:43,179
standard out from our web assembly

00:32:40,540 --> 00:32:47,140
module or read for read from a file or

00:32:43,179 --> 00:32:49,630
make a network call and along the same

00:32:47,140 --> 00:32:52,300
vein is how the dotnet core libraries

00:32:49,630 --> 00:32:56,559
are separated into separate sense of

00:32:52,300 --> 00:33:01,620
functionality the the idea hopefully is

00:32:56,559 --> 00:33:05,500
that you'll have Wasi runtimes that do

00:33:01,620 --> 00:33:07,800
just the basics you know essentially

00:33:05,500 --> 00:33:10,630
just running a calculator in a box to

00:33:07,800 --> 00:33:14,080
giving it standard out so that we can

00:33:10,630 --> 00:33:17,890
run it in serverless environments to add

00:33:14,080 --> 00:33:20,410
a network access and one of my favorites

00:33:17,890 --> 00:33:23,800
is and hopefully we'll see Wasi

00:33:20,410 --> 00:33:28,530
standards for embedded stuff like GPIO

00:33:23,800 --> 00:33:31,450
and i2c and other hardware interactions

00:33:28,530 --> 00:33:36,220
but it all comes through this list of

00:33:31,450 --> 00:33:38,860
imports and then just like in the the

00:33:36,220 --> 00:33:45,690
JavaScript we call essentially and we

00:33:38,860 --> 00:33:45,690
can run it let's see if

00:33:49,330 --> 00:33:56,210
yeah I realize that's tiny halt

00:33:53,710 --> 00:33:58,390
I'll zoom in on as soon as I can find

00:33:56,210 --> 00:33:58,390
that

00:34:08,090 --> 00:34:19,750
okay so see okay

00:34:15,680 --> 00:34:25,070
so it's getting cut off a little bit so

00:34:19,750 --> 00:34:27,530
I just ran my my rust Council

00:34:25,070 --> 00:34:32,350
application is that red was webassembly

00:34:27,530 --> 00:34:36,890
file from disk instantiate Edyta pretend

00:34:32,350 --> 00:34:38,300
called do work which has any for loop on

00:34:36,890 --> 00:34:41,780
the inside of the web assembly module

00:34:38,300 --> 00:34:43,970
that's calling in the logs dysfunction

00:34:41,780 --> 00:34:46,220
and it calls it once inside each of

00:34:43,970 --> 00:34:50,090
those loops so you can see that the web

00:34:46,220 --> 00:34:55,490
assembly module asked the host to log

00:34:50,090 --> 00:34:57,140
this text and like I said you can't the

00:34:55,490 --> 00:34:59,540
web assembly module can't do that unless

00:34:57,140 --> 00:35:05,840
you give it that functionality and so

00:34:59,540 --> 00:35:07,790
when we have special runtimes for

00:35:05,840 --> 00:35:10,880
running web assembly applications

00:35:07,790 --> 00:35:14,000
you know Brazil has got one fastly just

00:35:10,880 --> 00:35:15,950
released one and I'm sure that there

00:35:14,000 --> 00:35:18,550
will probably be another five or ten

00:35:15,950 --> 00:35:21,560
more fairly soon that are all

00:35:18,550 --> 00:35:25,580
specialized towards running webassembly

00:35:21,560 --> 00:35:28,580
modules in certain environments this is

00:35:25,580 --> 00:35:33,040
I think where the the real power of web

00:35:28,580 --> 00:35:35,510
assembly and Russ start to shine as well

00:35:33,040 --> 00:35:39,250
you can do user interface if you want

00:35:35,510 --> 00:35:39,250
but this is a good stuff right here

00:35:47,290 --> 00:35:53,140
so I wanted to get through the slides

00:35:51,070 --> 00:35:55,720
and just show a little bit of code so

00:35:53,140 --> 00:36:01,320
that hopefully I'd have plenty of time

00:35:55,720 --> 00:36:06,520
for questions so yeah

00:36:01,320 --> 00:36:08,500
the main point is webassembly is it's a

00:36:06,520 --> 00:36:10,870
great new technology it's still early

00:36:08,500 --> 00:36:13,660
days so there's still some rough ideas

00:36:10,870 --> 00:36:18,100
around it and the direction is a little

00:36:13,660 --> 00:36:21,310
unclear but I think it has a promising

00:36:18,100 --> 00:36:24,220
future especially with rust but it isn't

00:36:21,310 --> 00:36:29,050
a hero running webassembly everywhere

00:36:24,220 --> 00:36:31,510
doesn't make sense so I think the next

00:36:29,050 --> 00:36:34,330
steps for all of us is to just figure

00:36:31,510 --> 00:36:36,100
out where it makes sense to run these

00:36:34,330 --> 00:36:39,420
web assembly modules and in what

00:36:36,100 --> 00:36:39,420
runtimes we should be running them

00:36:41,160 --> 00:36:44,300
[Applause]

00:36:45,090 --> 00:36:51,150
you

00:36:46,090 --> 00:36:54,199
[Applause]

00:36:51,150 --> 00:36:54,199

YouTube URL: https://www.youtube.com/watch?v=YDQICTKlr9g


