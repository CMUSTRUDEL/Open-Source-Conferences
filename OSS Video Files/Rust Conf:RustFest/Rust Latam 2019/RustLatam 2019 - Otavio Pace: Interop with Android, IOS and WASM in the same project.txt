Title: RustLatam 2019 - Otavio Pace: Interop with Android, IOS and WASM in the same project
Publication date: 2019-04-21
Playlist: Rust Latam 2019
Description: 
	The talk will show and explain how pace and his collegues were able to create a library in Rust which had to be compiled to Android, iOS and WASM at the same time.

Follow us on Twitter: https://twitter.com/rustlatamconf
Captions: 
	00:00:05,030 --> 00:00:11,379
[Applause]

00:00:06,839 --> 00:00:13,990
so hi I'm here to talk about Interop

00:00:11,379 --> 00:00:16,209
with Android iOS and web assembly in the

00:00:13,990 --> 00:00:19,150
same project so basically a roast

00:00:16,209 --> 00:00:21,460
library that you can that you compile to

00:00:19,150 --> 00:00:23,740
all of those three platforms and on each

00:00:21,460 --> 00:00:27,220
of them you basically have an app that

00:00:23,740 --> 00:00:32,469
consumes tools those libraries that's

00:00:27,220 --> 00:00:35,620
the idea oh yeah

00:00:32,469 --> 00:00:37,950
so interoperability when people talk

00:00:35,620 --> 00:00:42,579
about this usually they're talking about

00:00:37,950 --> 00:00:46,980
FFI so does anybody know what FF is like

00:00:42,579 --> 00:00:50,620
raise your hands that's a lot of people

00:00:46,980 --> 00:00:51,309
so FFI stands for foreign function

00:00:50,620 --> 00:00:55,449
interface

00:00:51,309 --> 00:00:58,329
so basically when like a probing

00:00:55,449 --> 00:01:00,730
programming language has like its

00:00:58,329 --> 00:01:02,680
standard library its syntax a lot of

00:01:00,730 --> 00:01:05,710
things and one of the things that the

00:01:02,680 --> 00:01:08,520
most popular one ones have is a way to

00:01:05,710 --> 00:01:12,310
talk to the external world so basically

00:01:08,520 --> 00:01:17,140
let's say you have created those awesome

00:01:12,310 --> 00:01:21,400
rust functions I think actually the it's

00:01:17,140 --> 00:01:23,020
not very easy to see so let's say you

00:01:21,400 --> 00:01:26,440
have created those awesome rust

00:01:23,020 --> 00:01:29,080
functions and you want to use them and

00:01:26,440 --> 00:01:33,580
you need to create I don't know know JSF

00:01:29,080 --> 00:01:38,080
or whatever and you want to use them so

00:01:33,580 --> 00:01:41,410
you can basically go to use create your

00:01:38,080 --> 00:01:44,350
program and consume them using the FFI

00:01:41,410 --> 00:01:46,780
so rust has a way to externalize

00:01:44,350 --> 00:01:49,150
externalize things and also consume

00:01:46,780 --> 00:01:51,490
things from the external also other

00:01:49,150 --> 00:01:56,380
languages have that features so that's

00:01:51,490 --> 00:01:59,530
the idea but why use this you can use

00:01:56,380 --> 00:02:04,300
for variance is reasons one of them is

00:01:59,530 --> 00:02:06,820
performance so let's say you're doing a

00:02:04,300 --> 00:02:09,250
Python program like people who do

00:02:06,820 --> 00:02:11,800
data science they usually use some

00:02:09,250 --> 00:02:18,340
common libraries to

00:02:11,800 --> 00:02:21,160
do some things and basically they use

00:02:18,340 --> 00:02:24,190
some Python libraries like to do common

00:02:21,160 --> 00:02:25,570
things to this domain and some of the

00:02:24,190 --> 00:02:29,170
what those libraries are actually

00:02:25,570 --> 00:02:32,170
written in c and basically they do

00:02:29,170 --> 00:02:35,320
- wrappers around the c code and get

00:02:32,170 --> 00:02:39,190
some C performance out of that so that's

00:02:35,320 --> 00:02:44,740
pretty cool you can also use existing

00:02:39,190 --> 00:02:47,290
code or libraries so let's say there's

00:02:44,740 --> 00:02:50,320
this new language and you can't create a

00:02:47,290 --> 00:02:51,910
GUI application for it so there's no

00:02:50,320 --> 00:02:56,320
libraries for it so you can basically

00:02:51,910 --> 00:03:01,780
get create a wrapper around I don't know

00:02:56,320 --> 00:03:06,820
some ctk library using FFI so basically

00:03:01,780 --> 00:03:10,440
you talk to a library externally and you

00:03:06,820 --> 00:03:13,690
can do that on your cool new language

00:03:10,440 --> 00:03:15,910
you can also do if a fight to actually

00:03:13,690 --> 00:03:21,700
concentrate common logic in one like one

00:03:15,910 --> 00:03:24,520
library so basically i'm at my company

00:03:21,700 --> 00:03:25,420
Pagar me it's a payments company in

00:03:24,520 --> 00:03:28,540
brazil

00:03:25,420 --> 00:03:32,380
we're actually we have an Android app

00:03:28,540 --> 00:03:35,400
and iOS app a web app and a dotnet app

00:03:32,380 --> 00:03:37,959
that all of them need to talk to that

00:03:35,400 --> 00:03:39,850
payment terminal though that thing you

00:03:37,959 --> 00:03:45,190
put your credit card and lose money

00:03:39,850 --> 00:03:47,680
you know so basically we have a sea

00:03:45,190 --> 00:03:49,959
library that actually builds the

00:03:47,680 --> 00:03:52,240
commands for that machine for that

00:03:49,959 --> 00:03:54,730
payment terminal but it's actually

00:03:52,240 --> 00:03:57,820
written in C we are rewriting it to use

00:03:54,730 --> 00:04:00,430
rust for various reasons I won't get

00:03:57,820 --> 00:04:02,320
into that here but you can basically

00:04:00,430 --> 00:04:05,580
concentrate this common logic in one

00:04:02,320 --> 00:04:08,890
library and consume it in various places

00:04:05,580 --> 00:04:11,470
but how to do this in rest so Russ has

00:04:08,890 --> 00:04:15,370
various features to do this or tools

00:04:11,470 --> 00:04:18,820
whatever one of them is the external

00:04:15,370 --> 00:04:21,190
instant declaration so when you put this

00:04:18,820 --> 00:04:23,080
external thing before the function

00:04:21,190 --> 00:04:23,860
declaration it basically means you want

00:04:23,080 --> 00:04:30,030
to do two

00:04:23,860 --> 00:04:33,610
is it externally so this C string

00:04:30,030 --> 00:04:36,729
basically means you use the you are

00:04:33,610 --> 00:04:41,680
using the C API you can use other API it

00:04:36,729 --> 00:04:44,800
but by using this because most languages

00:04:41,680 --> 00:04:47,379
have a way to talk with C when you are

00:04:44,800 --> 00:04:49,389
externalized using the C way they can

00:04:47,379 --> 00:04:54,340
read your rest libraries so it's pretty

00:04:49,389 --> 00:04:57,219
used to be easy to use also there's the

00:04:54,340 --> 00:04:58,930
you can create an external ock that

00:04:57,219 --> 00:05:02,590
actually does the opposite so you

00:04:58,930 --> 00:05:06,759
consume external functions on rest so

00:05:02,590 --> 00:05:09,969
let's say you are operating on iOS and

00:05:06,759 --> 00:05:12,400
you need to use a random function there

00:05:09,969 --> 00:05:14,169
are a lot of options there and you just

00:05:12,400 --> 00:05:17,800
create the signature because the

00:05:14,169 --> 00:05:21,279
implementation is elsewhere and that's

00:05:17,800 --> 00:05:24,430
the idea and there's the know mango and

00:05:21,279 --> 00:05:27,370
attribute that basically does not mango

00:05:24,430 --> 00:05:30,250
the function name so that helps other

00:05:27,370 --> 00:05:31,839
compilers that are not rest compiler to

00:05:30,250 --> 00:05:36,550
actually understand the function name

00:05:31,839 --> 00:05:40,120
and that's the idea there's also wrapped

00:05:36,550 --> 00:05:45,310
C which basically layouts in memory your

00:05:40,120 --> 00:05:46,930
structs or or enums in a c way that

00:05:45,310 --> 00:05:49,270
helps other language to actually

00:05:46,930 --> 00:05:54,339
understand it but this is not necessary

00:05:49,270 --> 00:05:56,500
I find it very useful for enums but you

00:05:54,339 --> 00:05:59,770
can use Oh pack pointers I will get into

00:05:56,500 --> 00:06:03,250
that later but if this is actually not

00:05:59,770 --> 00:06:05,020
necessary for lot of cases so okay so

00:06:03,250 --> 00:06:08,439
how it's the workflow when you're

00:06:05,020 --> 00:06:11,529
building a library for an extern like

00:06:08,439 --> 00:06:13,659
app or something you have your library

00:06:11,529 --> 00:06:15,849
with those external declarations so we

00:06:13,659 --> 00:06:18,520
have a lot of functions there that

00:06:15,849 --> 00:06:22,180
you're going to use externally you build

00:06:18,520 --> 00:06:24,129
them to the target you you want so when

00:06:22,180 --> 00:06:26,169
you do only cargo build it actually uses

00:06:24,129 --> 00:06:30,159
your OS and architecture and everything

00:06:26,169 --> 00:06:32,680
to build it but you can use this car a

00:06:30,159 --> 00:06:36,639
target flag that helps you to build for

00:06:32,680 --> 00:06:37,510
other platforms then you will get a data

00:06:36,639 --> 00:06:40,240
so that

00:06:37,510 --> 00:06:42,490
it depends on the target this file

00:06:40,240 --> 00:06:45,880
basically will contain your functions

00:06:42,490 --> 00:06:48,100
that you want to externalize and then on

00:06:45,880 --> 00:06:52,300
your program in another language you

00:06:48,100 --> 00:06:55,030
consume those functions via SFI so

00:06:52,300 --> 00:06:59,440
that's the idea so for Android for

00:06:55,030 --> 00:07:01,510
example you have your rest library you

00:06:59,440 --> 00:07:05,170
compile for those three targets that

00:07:01,510 --> 00:07:08,710
that's what people use for Android apps

00:07:05,170 --> 00:07:10,870
and then you will get on your target

00:07:08,710 --> 00:07:13,990
folder three folders each one for each

00:07:10,870 --> 00:07:17,950
one of those targets but you get those

00:07:13,990 --> 00:07:21,550
ISO files in all of them and this is a

00:07:17,950 --> 00:07:23,890
files you link them on your Android app

00:07:21,550 --> 00:07:27,490
and you need to create these j'ni libs

00:07:23,890 --> 00:07:31,240
folder to actually link them but this

00:07:27,490 --> 00:07:33,670
j'ni j'ni is basically a part of java

00:07:31,240 --> 00:07:36,250
like in simplified terms a part of Java

00:07:33,670 --> 00:07:41,110
that deals with the external road so

00:07:36,250 --> 00:07:44,320
it's Javas FFI and you can maybe create

00:07:41,110 --> 00:07:47,500
a job or cut in wrapper around it those

00:07:44,320 --> 00:07:50,650
functions those external functions for

00:07:47,500 --> 00:07:53,590
so let's say you have this cool struct

00:07:50,650 --> 00:07:56,020
like it doesn't actually have any data

00:07:53,590 --> 00:08:00,940
in it but it could have doesn't really

00:07:56,020 --> 00:08:03,880
matter for the example but and then you

00:08:00,940 --> 00:08:06,850
need to prove so to consume on Java you

00:08:03,880 --> 00:08:09,730
actually need to create a function on J

00:08:06,850 --> 00:08:10,690
a nice way of understanding things so

00:08:09,730 --> 00:08:14,590
you

00:08:10,690 --> 00:08:16,960
there's the know mango so here's the

00:08:14,590 --> 00:08:18,760
null bangle attribute the external

00:08:16,960 --> 00:08:21,040
function declaration that I've I've said

00:08:18,760 --> 00:08:25,900
before and the name has this awesome

00:08:21,040 --> 00:08:29,800
name basically it that's the way the

00:08:25,900 --> 00:08:32,229
Java can understand your function so you

00:08:29,800 --> 00:08:36,460
start with Java then the package name

00:08:32,229 --> 00:08:38,860
soku comm coo coo android project and

00:08:36,460 --> 00:08:41,349
then it and then your class and then a

00:08:38,860 --> 00:08:44,650
method so that basically access as a

00:08:41,349 --> 00:08:46,600
class on this package and then this

00:08:44,650 --> 00:08:50,530
function receives an environment and

00:08:46,600 --> 00:08:52,750
this and the environment basically it's

00:08:50,530 --> 00:08:57,550
this object or structure or whatever

00:08:52,750 --> 00:08:59,830
that you can do things on the on java so

00:08:57,550 --> 00:09:01,990
you can basically create object you can

00:08:59,830 --> 00:09:05,440
call methods on classes you can do all

00:09:01,990 --> 00:09:07,890
kinds of stuff there and here this

00:09:05,440 --> 00:09:13,980
function basically instantiates this

00:09:07,890 --> 00:09:16,900
struct this cool struct and it creates a

00:09:13,980 --> 00:09:20,560
disco struct allocates it in the heap

00:09:16,900 --> 00:09:23,140
using box and it returns a pointer but

00:09:20,560 --> 00:09:26,290
instead of weekend retaining a simple

00:09:23,140 --> 00:09:30,100
pointer I converted it to a long type

00:09:26,290 --> 00:09:33,010
which is basically just an integer a bit

00:09:30,100 --> 00:09:35,860
integer and that way you can have the

00:09:33,010 --> 00:09:38,770
memory address on your own Java and when

00:09:35,860 --> 00:09:41,190
you're gonna call methods on this struct

00:09:38,770 --> 00:09:44,080
you can basically pass the long to other

00:09:41,190 --> 00:09:47,050
j'ni functions that you've created and

00:09:44,080 --> 00:09:51,160
you convert them back to pointers so you

00:09:47,050 --> 00:09:57,160
can use them in res normally that's the

00:09:51,160 --> 00:10:00,310
idea okay so on Java you need to create

00:09:57,160 --> 00:10:03,040
this just the signature of that external

00:10:00,310 --> 00:10:07,030
method so that's the cool class that's

00:10:03,040 --> 00:10:11,020
the package name the method return type

00:10:07,030 --> 00:10:14,050
it's all like that one and you can also

00:10:11,020 --> 00:10:17,530
like I don't know create a private value

00:10:14,050 --> 00:10:20,980
that contains that construct a memory

00:10:17,530 --> 00:10:25,930
address this is cotton by the way I did

00:10:20,980 --> 00:10:28,180
not say that but yeah for iOS basically

00:10:25,930 --> 00:10:31,000
it's almost the same thing but you get

00:10:28,180 --> 00:10:33,460
dot a files and there's a tool I

00:10:31,000 --> 00:10:36,250
recommend using its called cargo label

00:10:33,460 --> 00:10:38,290
you can do the cargo build target for

00:10:36,250 --> 00:10:40,509
everything too but as from

00:10:38,290 --> 00:10:43,839
it's pretty complex to actually make it

00:10:40,509 --> 00:10:47,889
work for iOS so just use Cargill it

00:10:43,839 --> 00:10:52,839
would work perfectly but instead of

00:10:47,889 --> 00:10:55,539
creating a like a class for example here

00:10:52,839 --> 00:11:00,399
we created this class to actually have

00:10:55,539 --> 00:11:03,399
the signature on Java site for iOS you

00:11:00,399 --> 00:11:05,859
need to create a C bridging header so

00:11:03,399 --> 00:11:08,709
basically it's a C header file with a

00:11:05,859 --> 00:11:10,949
bunch of declarations of your external

00:11:08,709 --> 00:11:16,600
functions of your wrist functions report

00:11:10,949 --> 00:11:21,220
okay so same struct here no mango and

00:11:16,600 --> 00:11:23,529
extern C C syntax and instead of

00:11:21,220 --> 00:11:27,689
returning a long time because we are not

00:11:23,529 --> 00:11:30,609
in Java we return a pointer here and

00:11:27,689 --> 00:11:34,119
like we just use this box into raw which

00:11:30,609 --> 00:11:37,119
just get gets the pointer and returns to

00:11:34,119 --> 00:11:39,999
to the other side however like this

00:11:37,119 --> 00:11:43,929
works because we are using the C API and

00:11:39,999 --> 00:11:48,309
like Swift and Objective C interact good

00:11:43,929 --> 00:11:52,449
way well with C so that's basically just

00:11:48,309 --> 00:11:55,119
like a normal regular C pointer and you

00:11:52,449 --> 00:12:00,699
need to have this this bridging header

00:11:55,119 --> 00:12:03,850
which has the struct and the method that

00:12:00,699 --> 00:12:05,829
returns that's right so this struct on

00:12:03,850 --> 00:12:09,489
Russ it actually didn't have any data

00:12:05,829 --> 00:12:12,189
but here I'm doing like even if it had

00:12:09,489 --> 00:12:14,769
you can just create an opaque pointer

00:12:12,189 --> 00:12:16,299
definition basically in a pack pointer

00:12:14,769 --> 00:12:19,929
is just white pointer I don't know if

00:12:16,299 --> 00:12:21,399
you have programming in C but basically

00:12:19,929 --> 00:12:26,619
it's a pointer that can point to

00:12:21,399 --> 00:12:28,899
anything so yeah and for web assembly

00:12:26,619 --> 00:12:32,859
it's honestly the easiest of them like

00:12:28,899 --> 00:12:34,329
to do the Interop there are two

00:12:32,859 --> 00:12:37,379
libraries that help a lot with that

00:12:34,329 --> 00:12:40,100
which are ways my engine and was back

00:12:37,379 --> 00:12:44,990
thank you Alex

00:12:40,100 --> 00:12:49,040
but basically as was back it's more like

00:12:44,990 --> 00:12:51,110
a command-line tool that you can build

00:12:49,040 --> 00:12:53,709
your project and West Byington is more

00:12:51,110 --> 00:12:58,639
like a library it actually has a CLI but

00:12:53,709 --> 00:13:01,069
I honestly don't use it but so you can

00:12:58,639 --> 00:13:03,620
build your library and it will create

00:13:01,069 --> 00:13:08,449
instead of the regulars target folder

00:13:03,620 --> 00:13:11,240
you get a pkg folder that basically will

00:13:08,449 --> 00:13:14,269
contain your dot wasm and a dot J's file

00:13:11,240 --> 00:13:16,519
so it actually already creates a wrapper

00:13:14,269 --> 00:13:19,880
around those external functions on

00:13:16,519 --> 00:13:22,579
JavaScript and the cool thing about this

00:13:19,880 --> 00:13:25,430
pkg folder it actually you can create a

00:13:22,579 --> 00:13:28,759
web app that actually consumes it like

00:13:25,430 --> 00:13:34,819
it was any any PM package so it's very

00:13:28,759 --> 00:13:38,389
good for using like it's very good okay

00:13:34,819 --> 00:13:41,420
so the same thing the same type here but

00:13:38,389 --> 00:13:44,180
here you can see that we can just return

00:13:41,420 --> 00:13:47,050
the type itself like we can just call my

00:13:44,180 --> 00:13:51,829
stroke nil just by putting this in

00:13:47,050 --> 00:13:55,430
pouring the web by engine attribute and

00:13:51,829 --> 00:13:59,149
we need to put on our types and on our

00:13:55,430 --> 00:14:01,910
functions so you can basically write

00:13:59,149 --> 00:14:04,630
regular dress code and this attribute

00:14:01,910 --> 00:14:09,139
will read your code and convert to that

00:14:04,630 --> 00:14:11,180
dirty box thing so it will deal with a

00:14:09,139 --> 00:14:16,220
lot of stuff for you so I recommend

00:14:11,180 --> 00:14:18,769
using this library yeah so okay but I've

00:14:16,220 --> 00:14:20,300
shown all of these and but how to do all

00:14:18,769 --> 00:14:24,199
of those three at the same time on a

00:14:20,300 --> 00:14:27,620
rest library there's one more - eirick

00:14:24,199 --> 00:14:31,040
it's needed to do this which is the

00:14:27,620 --> 00:14:33,019
conditional compilation attribute so

00:14:31,040 --> 00:14:36,550
there's this thing in Reverse called CFT

00:14:33,019 --> 00:14:39,800
it's an attribute that you can pass a

00:14:36,550 --> 00:14:42,110
basically something to about evaluate

00:14:39,800 --> 00:14:44,569
and if it's true it will actually

00:14:42,110 --> 00:14:47,029
compile the line below like them for

00:14:44,569 --> 00:14:49,720
example here I have a wise Mart module

00:14:47,029 --> 00:14:53,410
that will only be compiled

00:14:49,720 --> 00:14:56,050
if I'm actually targeting for wasn't 32

00:14:53,410 --> 00:14:59,500
so if I build for Android I won't get

00:14:56,050 --> 00:15:04,060
webassembly code that that's like what I

00:14:59,500 --> 00:15:06,629
want so one way to like because wise

00:15:04,060 --> 00:15:09,399
Mumbai engine it's kind of intrusive

00:15:06,629 --> 00:15:14,259
because you have to put on your types

00:15:09,399 --> 00:15:17,699
and on your external functions you need

00:15:14,259 --> 00:15:22,389
to put conditional compilation on your

00:15:17,699 --> 00:15:25,810
imports and also there's this CFG attr

00:15:22,389 --> 00:15:27,819
that evaluates a expression like the

00:15:25,810 --> 00:15:30,220
other one but actually puts and

00:15:27,819 --> 00:15:32,949
attributes the thing below so that's

00:15:30,220 --> 00:15:35,439
very useful and makes you not compile

00:15:32,949 --> 00:15:38,560
where some things to iOS or other

00:15:35,439 --> 00:15:44,439
platforms and also to actually not

00:15:38,560 --> 00:15:47,500
import wasn't binding and other other

00:15:44,439 --> 00:15:50,920
platform specific things you need to put

00:15:47,500 --> 00:15:53,230
this on your car go to mol file - it's

00:15:50,920 --> 00:15:56,230
the same thing but you use it for your

00:15:53,230 --> 00:15:59,230
dependencies so there here there is

00:15:56,230 --> 00:16:03,699
weather engine and giasses just uses a

00:15:59,230 --> 00:16:05,649
library inside of web binding that has a

00:16:03,699 --> 00:16:08,980
lot of JavaScript types so like

00:16:05,649 --> 00:16:11,470
functions you have you wait int you int

00:16:08,980 --> 00:16:14,680
eight array you have a lot of things in

00:16:11,470 --> 00:16:18,129
there okay so how to structure the rest

00:16:14,680 --> 00:16:20,709
library so at my company we started with

00:16:18,129 --> 00:16:24,850
this idea and that actually it's almost

00:16:20,709 --> 00:16:28,360
this the what we are doing we on the

00:16:24,850 --> 00:16:30,370
labor as file we put our common modules

00:16:28,360 --> 00:16:32,889
like of course we don't have a common

00:16:30,370 --> 00:16:38,860
module but we have a lot of modules that

00:16:32,889 --> 00:16:42,459
are our core rest library and then we

00:16:38,860 --> 00:16:44,889
can put like create other modules that

00:16:42,459 --> 00:16:47,199
use that camera module and create a

00:16:44,889 --> 00:16:51,129
public interface for a specific platform

00:16:47,199 --> 00:16:52,809
so on this module if we basically import

00:16:51,129 --> 00:16:55,149
this and create functions that

00:16:52,809 --> 00:16:57,279
webassembly can understand and things

00:16:55,149 --> 00:17:02,470
like that just the same for iOS and

00:16:57,279 --> 00:17:07,180
Android so that's the idea we had

00:17:02,470 --> 00:17:08,920
but and this is the like on each of them

00:17:07,180 --> 00:17:10,930
you create a public interface for the

00:17:08,920 --> 00:17:15,760
specific platform you they were building

00:17:10,930 --> 00:17:18,460
for and then like for today I didn't

00:17:15,760 --> 00:17:19,840
like our projects and virtually has to

00:17:18,460 --> 00:17:22,570
be closed at source because of

00:17:19,840 --> 00:17:24,850
recommendation issues however I did a

00:17:22,570 --> 00:17:27,820
project for just for today which is

00:17:24,850 --> 00:17:28,810
about the dome fire I don't know if you

00:17:27,820 --> 00:17:33,100
have played doom

00:17:28,810 --> 00:17:38,410
it's a game and basically there's this

00:17:33,100 --> 00:17:41,080
fire on the menu screen that you can

00:17:38,410 --> 00:17:43,540
like I basically made a OS Android and

00:17:41,080 --> 00:17:47,920
web app that rendered in sunscreen and

00:17:43,540 --> 00:17:51,490
the logic of doing this is on rest so

00:17:47,920 --> 00:17:54,370
the render part is on the the platform

00:17:51,490 --> 00:17:57,280
specific app so the idea is that

00:17:54,370 --> 00:18:00,490
basically you will have a vector of

00:17:57,280 --> 00:18:04,090
pixels of bytes or numbers whatever and

00:18:00,490 --> 00:18:08,170
each of them represents a number from 0

00:18:04,090 --> 00:18:13,060
to 36 36 is very hot 0 it's not a hot or

00:18:08,170 --> 00:18:16,450
cold and you basically a vector like

00:18:13,060 --> 00:18:18,340
this of course I don't I don't export it

00:18:16,450 --> 00:18:21,670
as just a pixels variable I have a

00:18:18,340 --> 00:18:24,250
struct that has that but that's the idea

00:18:21,670 --> 00:18:27,990
so basically the platform only reads

00:18:24,250 --> 00:18:31,960
this pixels array or vector whatever and

00:18:27,990 --> 00:18:34,360
resolve all of those numbers and that's

00:18:31,960 --> 00:18:36,340
dentist intensity of the fire that it

00:18:34,360 --> 00:18:36,760
needs to render on screen that's the

00:18:36,340 --> 00:18:38,860
idea

00:18:36,760 --> 00:18:42,250
I won't get into many details of how it

00:18:38,860 --> 00:18:44,560
works but ok so basically this is the

00:18:42,250 --> 00:18:47,050
library there those are the common

00:18:44,560 --> 00:18:48,040
modules and here are the three specific

00:18:47,050 --> 00:18:49,810
modules

00:18:48,040 --> 00:18:52,660
here's the web assembly one like I've

00:18:49,810 --> 00:18:56,020
shown and the Android one but here you

00:18:52,660 --> 00:18:59,110
can see there's no iOS basically for

00:18:56,020 --> 00:19:03,180
like we discovered when we were working

00:18:59,110 --> 00:19:07,450
on our project at Pagani that basically

00:19:03,180 --> 00:19:09,850
exporting functions for iOS for.net for

00:19:07,450 --> 00:19:12,580
some specific platforms it's very

00:19:09,850 --> 00:19:15,020
similar it's basically the same thing so

00:19:12,580 --> 00:19:17,090
we really created justice and there

00:19:15,020 --> 00:19:21,310
by module that probably can be consumed

00:19:17,090 --> 00:19:24,200
by other platforms that are not iOS so

00:19:21,310 --> 00:19:26,660
that's the idea this is the iOS one but

00:19:24,200 --> 00:19:31,220
probably works for other platforms too

00:19:26,660 --> 00:19:33,050
and here the Android one actually uses

00:19:31,220 --> 00:19:35,210
the standard the file one I don't know

00:19:33,050 --> 00:19:37,370
if you remember but I've shown that on

00:19:35,210 --> 00:19:40,490
the Android one you basically receive

00:19:37,370 --> 00:19:42,890
long types and convert them to pointers

00:19:40,490 --> 00:19:45,470
and or return long types that will be

00:19:42,890 --> 00:19:46,910
the memory address software structs so

00:19:45,470 --> 00:19:50,330
that you can call methods and crate

00:19:46,910 --> 00:19:52,700
structs and these Android module just

00:19:50,330 --> 00:19:56,270
converts the things that are pointers to

00:19:52,700 --> 00:20:00,020
lungs or vice versa to using this

00:19:56,270 --> 00:20:01,400
standard for fire module so here's the

00:20:00,020 --> 00:20:02,960
libraries core logic

00:20:01,400 --> 00:20:07,310
it's basically a struct with a lot of

00:20:02,960 --> 00:20:09,560
methods and that's like the idea here's

00:20:07,310 --> 00:20:12,440
the main logic and here's the thing I've

00:20:09,560 --> 00:20:17,450
shown about only compile wasm things

00:20:12,440 --> 00:20:19,310
when it's needed okay and then the web

00:20:17,450 --> 00:20:22,190
assembly interface it's very simple it

00:20:19,310 --> 00:20:25,070
just like creates destruct call methods

00:20:22,190 --> 00:20:27,770
on it like you can just receive mutable

00:20:25,070 --> 00:20:32,630
references immutable reference just it

00:20:27,770 --> 00:20:34,300
works perfectly I it's very good and but

00:20:32,630 --> 00:20:38,750
here there's one interesting thing

00:20:34,300 --> 00:20:41,060
basically we needed like I used

00:20:38,750 --> 00:20:44,360
callbacks in this project and there's

00:20:41,060 --> 00:20:48,140
this function type which is from JSC's

00:20:44,360 --> 00:20:51,770
oh that means this is a JavaScript

00:20:48,140 --> 00:20:54,110
function and I created a function that

00:20:51,770 --> 00:20:59,270
basically converts that funk that extern

00:20:54,110 --> 00:21:00,410
type to a rus type like something that's

00:20:59,270 --> 00:21:02,090
not platform-specific

00:21:00,410 --> 00:21:04,600
because you don't want to keep on your

00:21:02,090 --> 00:21:07,760
comma modules on your core library

00:21:04,600 --> 00:21:10,520
things that are platform specific so

00:21:07,760 --> 00:21:13,310
this function basically it's something

00:21:10,520 --> 00:21:16,010
like this it receives the JavaScript

00:21:13,310 --> 00:21:18,410
function it returns the box with

00:21:16,010 --> 00:21:22,160
anything that implements the function

00:21:18,410 --> 00:21:23,390
trait and it creates this box and puts a

00:21:22,160 --> 00:21:26,179
closure in it

00:21:23,390 --> 00:21:31,070
that calls that JavaScript function so

00:21:26,179 --> 00:21:33,049
that way the chorus library doesn't know

00:21:31,070 --> 00:21:36,350
what is a JavaScript function it only

00:21:33,049 --> 00:21:38,240
knows things that are rest types and

00:21:36,350 --> 00:21:40,640
here's basically how you use it of

00:21:38,240 --> 00:21:43,280
course we don't use this in rest we are

00:21:40,640 --> 00:21:45,290
using on the other side but here it's

00:21:43,280 --> 00:21:47,270
basically you call this function and it

00:21:45,290 --> 00:21:49,549
will give you the array of bytes that

00:21:47,270 --> 00:21:50,980
you can renders on screen that's the

00:21:49,549 --> 00:21:53,750
idea

00:21:50,980 --> 00:21:56,510
okay so for iOS there's the stenographer

00:21:53,750 --> 00:22:00,040
file module which creates the the board

00:21:56,510 --> 00:22:02,510
and which is the dead struct I've shown

00:22:00,040 --> 00:22:04,490
returns the pointer and the functions

00:22:02,510 --> 00:22:07,010
basically receive pointers and call

00:22:04,490 --> 00:22:09,679
methods on them but of course do no

00:22:07,010 --> 00:22:11,330
checks like check that that pointer is

00:22:09,679 --> 00:22:13,010
not new

00:22:11,330 --> 00:22:16,970
then you can maybe convert to something

00:22:13,010 --> 00:22:20,059
you can call methods and and then you

00:22:16,970 --> 00:22:22,820
need to free things so basically there's

00:22:20,059 --> 00:22:24,919
this box into Ralph from Ralph's

00:22:22,820 --> 00:22:27,380
function that receives a pointer and

00:22:24,919 --> 00:22:29,960
then converts into a box type so a box

00:22:27,380 --> 00:22:32,360
type when it's out of scope it will free

00:22:29,960 --> 00:22:36,679
that memory so that's how you free

00:22:32,360 --> 00:22:39,650
things and the Android interface is just

00:22:36,679 --> 00:22:42,080
what I've shown before but it receives

00:22:39,650 --> 00:22:45,110
like for example here this function

00:22:42,080 --> 00:22:48,230
returns a J long and basically it calls

00:22:45,110 --> 00:22:51,080
this tender if I'm function that creates

00:22:48,230 --> 00:22:54,410
a pointer and then returns it as a long

00:22:51,080 --> 00:22:56,090
time and then the functions like every

00:22:54,410 --> 00:22:58,309
time you want to call a method on it you

00:22:56,090 --> 00:23:00,500
basically receive the integer which

00:22:58,309 --> 00:23:03,169
represents the memory address and then

00:23:00,500 --> 00:23:04,940
convert it as a pointer so that this

00:23:03,169 --> 00:23:08,929
tender of a file module will do the new

00:23:04,940 --> 00:23:10,790
tracks and call methods in it okay this

00:23:08,929 --> 00:23:14,030
is the project like you can check it

00:23:10,790 --> 00:23:16,100
later I have you can like see oh this is

00:23:14,030 --> 00:23:20,870
weird this is wrong this is good and

00:23:16,100 --> 00:23:23,480
yeah that that's the project and that's

00:23:20,870 --> 00:23:27,950
basically it so some limitations of

00:23:23,480 --> 00:23:30,290
doing Interop like with rust and also

00:23:27,950 --> 00:23:32,300
interrupts in general so for example for

00:23:30,290 --> 00:23:35,280
web assembly at least using the web

00:23:32,300 --> 00:23:38,370
engine project which is very big and

00:23:35,280 --> 00:23:44,310
most users project you can use generics

00:23:38,370 --> 00:23:46,530
or typed parlors I'm yet so you can use

00:23:44,310 --> 00:23:50,640
them but you can't export any type that

00:23:46,530 --> 00:23:56,150
uses it also there's no lifetime

00:23:50,640 --> 00:23:59,640
parameters so goodbye references and

00:23:56,150 --> 00:24:02,640
also for like for Android one thing

00:23:59,640 --> 00:24:05,070
about Java that at least like there's no

00:24:02,640 --> 00:24:07,260
function pointers so a way to call a

00:24:05,070 --> 00:24:09,690
callback is basically either we receive

00:24:07,260 --> 00:24:14,160
an object and call a specific method on

00:24:09,690 --> 00:24:16,470
it or you can maybe on the cotton or

00:24:14,160 --> 00:24:19,080
Java interface receive a closure store

00:24:16,470 --> 00:24:22,050
it and you have a method that calls it

00:24:19,080 --> 00:24:25,170
but you call that on rest that's kind of

00:24:22,050 --> 00:24:26,550
confusing like with but yeah there's no

00:24:25,170 --> 00:24:29,670
function pointer so you have to do some

00:24:26,550 --> 00:24:33,600
things to actually call callbacks on iOS

00:24:29,670 --> 00:24:37,110
you can do callbacks but every time you

00:24:33,600 --> 00:24:39,720
create it you pass a callback to to see

00:24:37,110 --> 00:24:46,200
because on iOS if you think you're just

00:24:39,720 --> 00:24:48,540
doing Interop of see you basically can't

00:24:46,200 --> 00:24:50,880
use data that's on an object for example

00:24:48,540 --> 00:24:52,770
you can use if you're on a class you

00:24:50,880 --> 00:24:55,920
can't use anything that's related to

00:24:52,770 --> 00:24:57,360
cell for this you need to you only can

00:24:55,920 --> 00:25:00,120
reference things that are either

00:24:57,360 --> 00:25:03,150
received on the closure or are static

00:25:00,120 --> 00:25:06,270
data so that's kind of annoying too and

00:25:03,150 --> 00:25:08,280
for all of them at least not much for

00:25:06,270 --> 00:25:10,230
web assembly but for the others one

00:25:08,280 --> 00:25:15,750
other ones there are very few examples

00:25:10,230 --> 00:25:17,550
online like they're most of the examples

00:25:15,750 --> 00:25:20,250
are either you pass the string to the

00:25:17,550 --> 00:25:21,960
other side and come it back or you add

00:25:20,250 --> 00:25:24,210
in the two numbers or you print

00:25:21,960 --> 00:25:26,910
something so it's very annoying to find

00:25:24,210 --> 00:25:29,690
something useful online there are some

00:25:26,910 --> 00:25:33,060
references though I will show them later

00:25:29,690 --> 00:25:37,320
but it's very annoying and was hard to

00:25:33,060 --> 00:25:39,450
do at least for me and my colleague

00:25:37,320 --> 00:25:41,490
the biggest challenge in my opinion was

00:25:39,450 --> 00:25:43,650
to actually match types between the host

00:25:41,490 --> 00:25:46,590
and guest language you can like I really

00:25:43,650 --> 00:25:49,260
literally spend hours trying to like

00:25:46,590 --> 00:25:51,750
okay I have a function that needs to

00:25:49,260 --> 00:25:53,850
receive an array of bytes and then I try

00:25:51,750 --> 00:25:55,920
a type I try another type I tried

00:25:53,850 --> 00:25:58,440
another type and I can you can keep

00:25:55,920 --> 00:26:00,390
hours trying to actually find what types

00:25:58,440 --> 00:26:03,480
actually match because you don't have

00:26:00,390 --> 00:26:07,920
examples online so at least I had this

00:26:03,480 --> 00:26:09,870
problem it was very annoying and some

00:26:07,920 --> 00:26:13,290
references that helped a lot

00:26:09,870 --> 00:26:15,090
please help me for well assembly there's

00:26:13,290 --> 00:26:18,510
this book that basically creates the

00:26:15,090 --> 00:26:21,180
Conway's Game of Life I really recommend

00:26:18,510 --> 00:26:24,360
it it actually gets kind of deep on

00:26:21,180 --> 00:26:26,670
webassembly I recommended there's one

00:26:24,360 --> 00:26:30,510
Android and one iOS tutorial by Mozilla

00:26:26,670 --> 00:26:32,880
that actually do help you to do all of

00:26:30,510 --> 00:26:35,010
the linking process and how to build

00:26:32,880 --> 00:26:38,850
your library it helped it helped me a

00:26:35,010 --> 00:26:41,820
lot but it is a hello world but it's the

00:26:38,850 --> 00:26:44,690
you need to do this like for to start

00:26:41,820 --> 00:26:49,830
actually doing FFI with android iOS and

00:26:44,690 --> 00:26:51,930
for 4j and I I didn't found many

00:26:49,830 --> 00:26:57,290
examples using rests so I found this

00:26:51,930 --> 00:27:00,180
book that was very helpful that 4c but

00:26:57,290 --> 00:27:05,460
some of the interfaces that Jay and I

00:27:00,180 --> 00:27:07,620
the J&I has on see they actually are

00:27:05,460 --> 00:27:10,980
similar to the rest one so I recommend

00:27:07,620 --> 00:27:13,740
this book and then are there there are

00:27:10,980 --> 00:27:15,900
two talks that talk about FS doing ffiv

00:27:13,740 --> 00:27:18,480
first I recommend them there are on

00:27:15,900 --> 00:27:21,720
YouTube one of them gives a lot of tips

00:27:18,480 --> 00:27:25,560
and shows like do no checks and do

00:27:21,720 --> 00:27:27,540
things like care take care because

00:27:25,560 --> 00:27:31,850
you're dealing with pointers and yeah

00:27:27,540 --> 00:27:35,250
and an overview of rust rust to FF I

00:27:31,850 --> 00:27:37,380
basically shows what I've shown like

00:27:35,250 --> 00:27:40,680
some parts and I recommend watching them

00:27:37,380 --> 00:27:43,440
and I would like to thanks to some

00:27:40,680 --> 00:27:45,900
people most of them actually all of them

00:27:43,440 --> 00:27:47,450
in this slide are from my company which

00:27:45,900 --> 00:27:50,150
is a guy I mean

00:27:47,450 --> 00:27:53,090
she like Marcela basically I don't have

00:27:50,150 --> 00:27:56,240
a Mac so to compile it to iOS I

00:27:53,090 --> 00:28:01,400
basically borrowed a Mac from her 2011

00:27:56,240 --> 00:28:03,380
MacBook so thank you also to Phillippi

00:28:01,400 --> 00:28:07,130
basically he's the guy I'm working with

00:28:03,380 --> 00:28:09,500
in Pagar me at this project not the dome

00:28:07,130 --> 00:28:12,740
fire one like our payment terminal

00:28:09,500 --> 00:28:15,140
project those people are actually from a

00:28:12,740 --> 00:28:19,730
company too they I've presented to them

00:28:15,140 --> 00:28:22,910
a lot of times like trying to like

00:28:19,730 --> 00:28:26,360
practice and Alan who is here

00:28:22,910 --> 00:28:27,620
he offered to actually I so I bet I

00:28:26,360 --> 00:28:32,179
could use his computer

00:28:27,620 --> 00:28:35,510
but I did ended up bringing mine so

00:28:32,179 --> 00:28:37,070
thanks and also Pagani which is a

00:28:35,510 --> 00:28:41,809
company aware for a lot of people helped

00:28:37,070 --> 00:28:45,620
me they're like Camilla Mars a lot of

00:28:41,809 --> 00:28:48,919
people there Susanna so and also thanks

00:28:45,620 --> 00:28:51,020
to those three people so casiano I don't

00:28:48,919 --> 00:28:53,510
know him but he actually has a project

00:28:51,020 --> 00:28:56,360
of doom fire during the doom fire on

00:28:53,510 --> 00:28:58,910
Android because I don't know Android and

00:28:56,360 --> 00:29:01,580
iOS I don't know how to render things on

00:28:58,910 --> 00:29:03,950
screen so basically this project helped

00:29:01,580 --> 00:29:07,250
me doing the rendering part marie-loup

00:29:03,950 --> 00:29:09,500
the same for iOS and Philippe Editions

00:29:07,250 --> 00:29:13,120
basically he has a project that collects

00:29:09,500 --> 00:29:13,120
a lot of don't fire algorithm

00:29:13,960 --> 00:29:19,490
implementations on various languages and

00:29:16,250 --> 00:29:22,820
you can check it out later on my project

00:29:19,490 --> 00:29:24,940
there's a link to it and that's it thank

00:29:22,820 --> 00:29:24,940
you

00:29:31,850 --> 00:29:34,920

YouTube URL: https://www.youtube.com/watch?v=W-HUyTwV4LA


