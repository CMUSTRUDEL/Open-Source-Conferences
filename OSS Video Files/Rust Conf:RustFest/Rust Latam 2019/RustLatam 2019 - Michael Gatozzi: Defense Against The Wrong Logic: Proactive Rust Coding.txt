Title: RustLatam 2019 - Michael Gatozzi: Defense Against The Wrong Logic: Proactive Rust Coding
Publication date: 2019-04-21
Playlist: Rust Latam 2019
Description: 
	Rust guarantees memory safety, but it doesnâ€™t stop you from doing everything. From unsafe to unwrap and more, there are lots of ways for you to subvert and make your code fail due to our own mistakes: logic bugs and incorrect assumptions.

Come along and learn Rust techniques and patterns that will help build safe guards into your code, test your assumptions, and get a better understanding of what Rust and you can guarantee with your code.

All so you can sleep sounder at night and not be woken up at 3am while on call.

Follow us on Twitter: https://twitter.com/rustlatamconf
Captions: 
	00:00:04,070 --> 00:00:09,370
[Applause]

00:00:06,959 --> 00:00:10,900
all right so this talk is entitled

00:00:09,370 --> 00:00:12,820
defense against the wrong logic

00:00:10,900 --> 00:00:14,049
proactive rust coding uh pretty much

00:00:12,820 --> 00:00:16,480
this talk is going to be about how we

00:00:14,049 --> 00:00:19,330
can use a couple guidelines on some

00:00:16,480 --> 00:00:24,220
things as well as using the compiler in

00:00:19,330 --> 00:00:26,259
order to make sure that you can make

00:00:24,220 --> 00:00:27,939
sure that you actually can stop yourself

00:00:26,259 --> 00:00:30,609
from doing logic bugs because rust

00:00:27,939 --> 00:00:32,140
prevents you from doing a lot of you

00:00:30,609 --> 00:00:33,250
know it prevents you from doing data

00:00:32,140 --> 00:00:34,600
races and things like that but it

00:00:33,250 --> 00:00:36,640
doesn't exactly stop you from like doing

00:00:34,600 --> 00:00:39,309
the wrong thing yourself

00:00:36,640 --> 00:00:41,020
so a little bit about myself my name is

00:00:39,309 --> 00:00:43,899
Michael Gatto Z I've been using rust

00:00:41,020 --> 00:00:45,370
since about 1.0 I make jokes on Twitter

00:00:43,899 --> 00:00:48,129
a lot of the time that's how a lot of

00:00:45,370 --> 00:00:49,660
people seem to know me so if you do take

00:00:48,129 --> 00:00:52,690
pictures of stuff feel free to at me my

00:00:49,660 --> 00:00:54,039
mom wants some pictures as well so

00:00:52,690 --> 00:00:56,440
that'd be great

00:00:54,039 --> 00:00:59,649
so let's uh let's go over what we're

00:00:56,440 --> 00:01:01,930
gonna cover today so there's quite a few

00:00:59,649 --> 00:01:03,910
things we're gonna cover what's new

00:01:01,930 --> 00:01:07,110
types as well as what the Builder

00:01:03,910 --> 00:01:10,870
pattern is dealing with converting input

00:01:07,110 --> 00:01:12,820
insert assertions what what to do when

00:01:10,870 --> 00:01:14,680
you unwrap and expect as well as a

00:01:12,820 --> 00:01:18,430
little bit of unsafe guidelines when

00:01:14,680 --> 00:01:21,220
you're writing your code so let's let's

00:01:18,430 --> 00:01:23,350
get started out new types so let's say

00:01:21,220 --> 00:01:24,700
we have some code here you know we want

00:01:23,350 --> 00:01:26,230
to we want to create a temperature

00:01:24,700 --> 00:01:28,810
conversion library between Fahrenheit

00:01:26,230 --> 00:01:30,700
and Celsius so you might say okay I'll

00:01:28,810 --> 00:01:32,890
have a type Fahrenheit I'll make it a

00:01:30,700 --> 00:01:34,360
32-bit integer and I'll have a type

00:01:32,890 --> 00:01:36,730
Celsius and I'll make it a 32-bit

00:01:34,360 --> 00:01:37,120
integer and I have this function is it

00:01:36,730 --> 00:01:38,980
hot

00:01:37,120 --> 00:01:41,500
it'll take a just the Fahrenheit

00:01:38,980 --> 00:01:44,470
temperature and it'll return bool yes or

00:01:41,500 --> 00:01:45,970
no right and so we'll say okay we'll say

00:01:44,470 --> 00:01:47,800
that we'll have a temperature we'll make

00:01:45,970 --> 00:01:49,240
it a Celsius we'll give it a 32 as a

00:01:47,800 --> 00:01:54,120
number and then we put into this

00:01:49,240 --> 00:01:59,350
function is it hot so will this compile

00:01:54,120 --> 00:02:00,790
yes unfortunately you can't you can do

00:01:59,350 --> 00:02:02,830
that and the reason is that we just used

00:02:00,790 --> 00:02:05,230
what was known as a type alias we've

00:02:02,830 --> 00:02:07,120
said that they're both 32-bit integers

00:02:05,230 --> 00:02:10,690
and that you can put that in there and

00:02:07,120 --> 00:02:12,790
that's not really good we don't want or

00:02:10,690 --> 00:02:13,629
we don't want to put Fahrenheit inside

00:02:12,790 --> 00:02:15,730
of

00:02:13,629 --> 00:02:18,310
Celsius or Celsius since had a

00:02:15,730 --> 00:02:19,870
Fahrenheit and when you deal with these

00:02:18,310 --> 00:02:21,939
kind of conversions between units you

00:02:19,870 --> 00:02:24,609
have a lot of problems in fact you know

00:02:21,939 --> 00:02:26,379
some of the space like spaceships have

00:02:24,609 --> 00:02:28,060
like blown up in flight because they

00:02:26,379 --> 00:02:31,269
were dealing with meters instead of feet

00:02:28,060 --> 00:02:35,139
or feet instead of meters and that's not

00:02:31,269 --> 00:02:36,730
good so we can prevent that we can do

00:02:35,139 --> 00:02:39,519
this in a way using what's known as a

00:02:36,730 --> 00:02:41,469
new type you define destruct and then

00:02:39,519 --> 00:02:43,900
you give it some internal value with

00:02:41,469 --> 00:02:45,299
that without a name for the field so in

00:02:43,900 --> 00:02:48,370
this case we said okay we have Celsius

00:02:45,299 --> 00:02:50,530
it has an internal field called a 32-bit

00:02:48,370 --> 00:02:52,959
field and we have a struct called

00:02:50,530 --> 00:02:56,469
Fahrenheit and Fahrenheit has as well a

00:02:52,959 --> 00:02:58,090
32-bit integer inside of it so let's

00:02:56,469 --> 00:03:00,310
let's let's try that code again let's

00:02:58,090 --> 00:03:03,129
let's look at it a different way so

00:03:00,310 --> 00:03:05,530
we've taken this new type we've called

00:03:03,129 --> 00:03:07,120
it Celsius right it has 32 is the number

00:03:05,530 --> 00:03:10,090
inside of it and we've assigned it to

00:03:07,120 --> 00:03:13,120
the value temp and then we try to put it

00:03:10,090 --> 00:03:14,530
into this function is it hot and if it

00:03:13,120 --> 00:03:15,540
is it'll say yes otherwise they'll say

00:03:14,530 --> 00:03:20,169
no right

00:03:15,540 --> 00:03:24,939
will this compile the answer is no it

00:03:20,169 --> 00:03:28,359
will not compile and the reason being is

00:03:24,939 --> 00:03:32,019
that we've defined a struct a type in

00:03:28,359 --> 00:03:33,970
our system called Celsius and we our

00:03:32,019 --> 00:03:36,069
function is taking a struct called

00:03:33,970 --> 00:03:37,870
Fahrenheit and Russ is gonna look at

00:03:36,069 --> 00:03:39,790
they can go these aren't the same thing

00:03:37,870 --> 00:03:45,370
what are you doing don't put this in

00:03:39,790 --> 00:03:47,349
here and so we can then you can utilize

00:03:45,370 --> 00:03:49,930
this type system as a way to make sure

00:03:47,349 --> 00:03:52,299
that you know we only put you know the

00:03:49,930 --> 00:03:54,250
square in the square hole or the circle

00:03:52,299 --> 00:03:55,569
in the circular hole we're not able to

00:03:54,250 --> 00:03:57,639
put things that are not supposed to be

00:03:55,569 --> 00:04:02,799
in the right spot or in the wrong spot

00:03:57,639 --> 00:04:04,780
in two different places but you know

00:04:02,799 --> 00:04:07,840
it's kind of useful to be able to

00:04:04,780 --> 00:04:10,810
convert things we want to be able to say

00:04:07,840 --> 00:04:13,810
well Celsius is a unit of temperature

00:04:10,810 --> 00:04:15,939
and so is Fahrenheit wouldn't it be nice

00:04:13,810 --> 00:04:18,969
if we could like convert that and we can

00:04:15,939 --> 00:04:21,310
there's the into trait and we could

00:04:18,969 --> 00:04:24,010
define this we can say okay we can

00:04:21,310 --> 00:04:25,680
implement into four cells into four

00:04:24,010 --> 00:04:29,610
Celsius for Fahrenheit

00:04:25,680 --> 00:04:36,090
so it takes a Celsius input and here's

00:04:29,610 --> 00:04:37,949
how we would convert it right and so we

00:04:36,090 --> 00:04:41,280
can do this in such a way that we can

00:04:37,949 --> 00:04:43,880
now convert between things safely the

00:04:41,280 --> 00:04:46,800
way to look at it is that types and

00:04:43,880 --> 00:04:49,650
structs and things they represent ideas

00:04:46,800 --> 00:04:54,479
or objects right in this case we're

00:04:49,650 --> 00:04:58,169
trying to represent a unit of heat but

00:04:54,479 --> 00:05:01,919
traits defying behaviors behaviors allow

00:04:58,169 --> 00:05:04,139
us to tell how these types work and as a

00:05:01,919 --> 00:05:06,090
result we can do things that we couldn't

00:05:04,139 --> 00:05:09,210
do if we just use the type alias and

00:05:06,090 --> 00:05:12,419
dealing with primitives like a 32-bit

00:05:09,210 --> 00:05:15,810
integer is just a number but a new type

00:05:12,419 --> 00:05:18,360
is a number with meaning and so we can

00:05:15,810 --> 00:05:21,840
therefore define ways to give that

00:05:18,360 --> 00:05:24,389
meaning and those those values that

00:05:21,840 --> 00:05:27,300
we're dealing with behaviors so in this

00:05:24,389 --> 00:05:29,130
case here's how we define Celsius you

00:05:27,300 --> 00:05:31,409
might notice that says dot zero that's

00:05:29,130 --> 00:05:34,349
how you'd pull out the inner value of a

00:05:31,409 --> 00:05:36,210
new type as well so we're saying okay we

00:05:34,349 --> 00:05:38,340
want the value inside of Celsius

00:05:36,210 --> 00:05:42,900
we'll add nine to it divided by five and

00:05:38,340 --> 00:05:44,490
add 32 now there is one kind of iffy

00:05:42,900 --> 00:05:48,570
thing about this and that is that we're

00:05:44,490 --> 00:05:49,680
kind of using as I 32 if you were you

00:05:48,570 --> 00:05:50,669
know actually making a really good

00:05:49,680 --> 00:05:52,949
temperature library you probably

00:05:50,669 --> 00:05:57,810
wouldn't to do that this this would

00:05:52,949 --> 00:06:00,659
truncate any results that are not that

00:05:57,810 --> 00:06:03,330
our decimals but this is just an example

00:06:00,659 --> 00:06:06,300
as to kind of give you an idea of like

00:06:03,330 --> 00:06:08,729
what you can do with this so let's look

00:06:06,300 --> 00:06:10,949
at that again you know we'll define the

00:06:08,729 --> 00:06:13,320
temperature and then we can call dotty

00:06:10,949 --> 00:06:15,120
in two and then this will compile this

00:06:13,320 --> 00:06:18,900
this actually works now because what

00:06:15,120 --> 00:06:21,300
we're saying is that it is hot is asking

00:06:18,900 --> 00:06:21,690
for a fairing height and we're saying

00:06:21,300 --> 00:06:23,759
okay

00:06:21,690 --> 00:06:27,210
temperatures are Celsius and we're

00:06:23,759 --> 00:06:30,539
calling a dot into Wright rust knows

00:06:27,210 --> 00:06:31,650
that it's you it needs a Fahrenheit but

00:06:30,539 --> 00:06:33,900
it also knows that all you have is a

00:06:31,650 --> 00:06:35,760
Celsius but it has a way to do it it

00:06:33,900 --> 00:06:37,930
knows that you've implemented a way to

00:06:35,760 --> 00:06:40,479
change Celsius

00:06:37,930 --> 00:06:45,070
to Fahrenheit and so you can call daddy

00:06:40,479 --> 00:06:45,970
- and this compiles and it works so I

00:06:45,070 --> 00:06:47,800
want to talk a little bit about the

00:06:45,970 --> 00:06:49,449
Builder pattern this is probably one of

00:06:47,800 --> 00:06:50,949
my favorite things inside of rust you'll

00:06:49,449 --> 00:06:56,410
see it use extensively in a lot of

00:06:50,949 --> 00:06:58,990
places so what's the Builder what's the

00:06:56,410 --> 00:07:02,410
Builder pattern used for we want to use

00:06:58,990 --> 00:07:05,080
it to avoid invalid states what I mean

00:07:02,410 --> 00:07:08,320
by this is someone's using your library

00:07:05,080 --> 00:07:10,900
and you've defined a pathway to make

00:07:08,320 --> 00:07:13,060
sure that they cannot do things that

00:07:10,900 --> 00:07:16,810
will not work they can't do something

00:07:13,060 --> 00:07:20,530
that would cause the program to you know

00:07:16,810 --> 00:07:23,440
take input that would you know it would

00:07:20,530 --> 00:07:24,880
compile it would run but it wouldn't

00:07:23,440 --> 00:07:27,130
exactly work the way they expect you

00:07:24,880 --> 00:07:30,220
basically have a logic bug or a runtime

00:07:27,130 --> 00:07:32,620
error and so what we do is that we use

00:07:30,220 --> 00:07:34,660
types to represent these states what

00:07:32,620 --> 00:07:36,280
we're saying is that like okay like you

00:07:34,660 --> 00:07:37,449
know here's here's one type that

00:07:36,280 --> 00:07:39,430
represents this here's one type that

00:07:37,449 --> 00:07:42,310
represents that and then we find a way

00:07:39,430 --> 00:07:44,409
to change it and so by this we use

00:07:42,310 --> 00:07:45,370
functions to change these states and so

00:07:44,409 --> 00:07:47,440
what you're doing is you're doing a

00:07:45,370 --> 00:07:49,539
defined pathway for people to move from

00:07:47,440 --> 00:07:54,010
one place to the next if this sounds

00:07:49,539 --> 00:07:57,340
like a graph it is and so here's an

00:07:54,010 --> 00:08:00,580
example so let's say we're building a

00:07:57,340 --> 00:08:02,229
library to connect to github we want to

00:08:00,580 --> 00:08:05,199
be able to do we want to interact with

00:08:02,229 --> 00:08:07,630
the API we want to you know do a variety

00:08:05,199 --> 00:08:12,070
of things and I've done this in my own

00:08:07,630 --> 00:08:14,490
library and so we'll have a client type

00:08:12,070 --> 00:08:16,990
that lets us do all kinds of requests

00:08:14,490 --> 00:08:18,990
you know we wanted to get request

00:08:16,990 --> 00:08:21,699
there's delete requests post requests

00:08:18,990 --> 00:08:24,849
requests put requests all kinds of

00:08:21,699 --> 00:08:26,289
separate things that you can do now what

00:08:24,849 --> 00:08:27,970
we do to get to those states is I will

00:08:26,289 --> 00:08:30,580
say okay we'll call get or delete or

00:08:27,970 --> 00:08:33,339
post or put and that brings us to the

00:08:30,580 --> 00:08:35,140
next type right but this type when you

00:08:33,339 --> 00:08:38,289
implement you know you'll say like info

00:08:35,140 --> 00:08:40,750
delete or imple get right these only

00:08:38,289 --> 00:08:43,510
have a specific amount of functions that

00:08:40,750 --> 00:08:46,570
they can use right you can't just all of

00:08:43,510 --> 00:08:49,930
a sudden post and then to like I use a

00:08:46,570 --> 00:08:51,800
repo like that's not allowed but we do

00:08:49,930 --> 00:08:55,339
have get and delete which allow

00:08:51,800 --> 00:08:56,869
to get a users repo and so these

00:08:55,339 --> 00:08:58,850
functions allow us to transition from

00:08:56,869 --> 00:09:01,389
one to the next and it's a little bit

00:08:58,850 --> 00:09:03,259
easier if you see it kind of in action

00:09:01,389 --> 00:09:05,300
so this is kind of what it would end up

00:09:03,259 --> 00:09:07,939
looking like right we have a client we

00:09:05,300 --> 00:09:09,649
want to get some user we will want to

00:09:07,939 --> 00:09:11,420
get their repo and then we'll like send

00:09:09,649 --> 00:09:13,939
the request and so the Builder pattern

00:09:11,420 --> 00:09:15,679
allows you to build up a set of

00:09:13,939 --> 00:09:18,379
functions in order to kind of do these

00:09:15,679 --> 00:09:20,660
changes oftentimes you'll see it with

00:09:18,379 --> 00:09:24,939
like iterator adapters you might call

00:09:20,660 --> 00:09:28,910
like inter map and then collect right

00:09:24,939 --> 00:09:32,149
there are ways to kind of build up ideas

00:09:28,910 --> 00:09:35,329
or things that you want to run and it's

00:09:32,149 --> 00:09:37,189
fairly you it's used throughout the rust

00:09:35,329 --> 00:09:39,129
ecosystem you'll see it a lot with like

00:09:37,189 --> 00:09:41,509
diesel for instance you build up a query

00:09:39,129 --> 00:09:43,089
and they do a lot

00:09:41,509 --> 00:09:46,119
diesel does a lot of like really

00:09:43,089 --> 00:09:48,319
interesting some other type level hacks

00:09:46,119 --> 00:09:51,079
to like really make sure that you can

00:09:48,319 --> 00:09:52,549
only do very specific things and it ends

00:09:51,079 --> 00:09:54,379
up allowing you to like make sure that

00:09:52,549 --> 00:09:56,839
you don't do like database queries that

00:09:54,379 --> 00:10:00,170
do not work right things that you might

00:09:56,839 --> 00:10:02,089
not catch until you know it's 5:00 a.m.

00:10:00,170 --> 00:10:04,249
in the morning production is down and

00:10:02,089 --> 00:10:07,639
you're getting a phone call waking you

00:10:04,249 --> 00:10:10,459
up going hey everything's broken subtle

00:10:07,639 --> 00:10:11,569
bugs that you know you could catch at

00:10:10,459 --> 00:10:13,519
compile time if you knew what you're

00:10:11,569 --> 00:10:19,429
doing but you know it's really hard as a

00:10:13,519 --> 00:10:25,850
programmer user to catch and so you'll

00:10:19,429 --> 00:10:28,429
see this throughout and yeah and so the

00:10:25,850 --> 00:10:34,549
next thing I want to talk about is about

00:10:28,429 --> 00:10:36,350
converting input early so let's take an

00:10:34,549 --> 00:10:41,419
example let's say that we are making a

00:10:36,350 --> 00:10:44,689
request to some website you know we'll

00:10:41,419 --> 00:10:47,480
say okay I want to make this HTTP

00:10:44,689 --> 00:10:50,660
request you know and I get the value

00:10:47,480 --> 00:10:53,329
back and it's just the HTTP request an

00:10:50,660 --> 00:10:58,160
HTTP has been around for quite some time

00:10:53,329 --> 00:11:02,240
it's a lot of just strings and you could

00:10:58,160 --> 00:11:03,170
say okay well I want to get the status

00:11:02,240 --> 00:11:05,360
code

00:11:03,170 --> 00:11:07,010
of this and you could go you could

00:11:05,360 --> 00:11:10,459
iterate through the lines find the

00:11:07,010 --> 00:11:13,630
status code parse it grab the number and

00:11:10,459 --> 00:11:19,220
then check was it like a 200 or was it a

00:11:13,630 --> 00:11:22,100
404 or whatever the case might be but

00:11:19,220 --> 00:11:24,410
that's really prone to errors you're

00:11:22,100 --> 00:11:26,269
kind of if you just pass the string

00:11:24,410 --> 00:11:27,980
around there's no guarantees that it

00:11:26,269 --> 00:11:32,449
hasn't changed there's no guarantees

00:11:27,980 --> 00:11:33,560
that you didn't parse it correctly or

00:11:32,449 --> 00:11:36,230
there's no guarantees that you parsed it

00:11:33,560 --> 00:11:39,079
correctly you're dealing with a lot of

00:11:36,230 --> 00:11:40,820
uncertainty the boundaries of input is

00:11:39,079 --> 00:11:45,199
just a bunch of strings that you're

00:11:40,820 --> 00:11:48,410
trying to deal with as a type is not

00:11:45,199 --> 00:11:50,180
exactly the best it would be better if

00:11:48,410 --> 00:11:51,829
you had something more like this where

00:11:50,180 --> 00:11:55,190
you made a request and you got a

00:11:51,829 --> 00:11:56,660
response you have a field headers where

00:11:55,190 --> 00:11:59,570
you have all the headers parsed out

00:11:56,660 --> 00:12:02,449
correctly you have some status code you

00:11:59,570 --> 00:12:04,630
have a body made of JSON these are types

00:12:02,449 --> 00:12:07,970
that you can again deal with they are

00:12:04,630 --> 00:12:11,720
types that again have behaviors and

00:12:07,970 --> 00:12:12,920
traits that you can work with there are

00:12:11,720 --> 00:12:14,510
things that you can match against the

00:12:12,920 --> 00:12:16,940
status code could be an enum that you

00:12:14,510 --> 00:12:19,850
can match against every possible thing

00:12:16,940 --> 00:12:22,370
that happened you could say oh I got a

00:12:19,850 --> 00:12:24,589
404 I want to throw an error or oh I got

00:12:22,370 --> 00:12:27,579
a 200 I want to make sure that like we

00:12:24,589 --> 00:12:31,550
continue on with whatever we're doing

00:12:27,579 --> 00:12:33,949
types allow us to check a lot of things

00:12:31,550 --> 00:12:38,600
and the faster that you get things into

00:12:33,949 --> 00:12:40,130
types the better traits traits and types

00:12:38,600 --> 00:12:44,630
are very powerful things that allow you

00:12:40,130 --> 00:12:47,810
to do a lot a lot of interesting things

00:12:44,630 --> 00:12:49,519
and you're able to check your work with

00:12:47,810 --> 00:12:51,290
the compiler the compiler ends up being

00:12:49,519 --> 00:12:54,019
your friend rather than being this

00:12:51,290 --> 00:12:58,850
antagonist it's able to make sure it's

00:12:54,019 --> 00:13:00,260
got your back in a way so with that I

00:12:58,850 --> 00:13:03,190
also want to mention that Saturday is a

00:13:00,260 --> 00:13:06,490
fantastic crate if you want to deal with

00:13:03,190 --> 00:13:10,519
transforming string based input into

00:13:06,490 --> 00:13:13,149
axle types it makes it super super easy

00:13:10,519 --> 00:13:15,560
I used Saturday JSON a lot for instance

00:13:13,149 --> 00:13:16,940
you know you define a structure like

00:13:15,560 --> 00:13:18,860
okay here's what it looks like

00:13:16,940 --> 00:13:21,410
it kind of looks like the JSON in a way

00:13:18,860 --> 00:13:24,380
and then you say okay derive serialize

00:13:21,410 --> 00:13:27,709
or derive deserialize and then it just

00:13:24,380 --> 00:13:30,410
works you call the function saying okay

00:13:27,709 --> 00:13:32,529
here's my string here's the input turn

00:13:30,410 --> 00:13:36,230
it into this struct and then that's it

00:13:32,529 --> 00:13:37,730
and so there's a lot of these kinds of

00:13:36,230 --> 00:13:39,259
crates that deal with the fact that

00:13:37,730 --> 00:13:41,839
we're gonna have a lot of string as

00:13:39,259 --> 00:13:44,690
input at the boundaries of your program

00:13:41,839 --> 00:13:46,550
any time you take input from a user and

00:13:44,690 --> 00:13:48,319
the faster you turn it into a type the

00:13:46,550 --> 00:13:49,550
faster you can deal with it inside of

00:13:48,319 --> 00:13:52,040
your own program and have a lot of

00:13:49,550 --> 00:13:53,959
benefits for doing so

00:13:52,040 --> 00:13:57,529
there's also parsing libraries like nom

00:13:53,959 --> 00:13:59,300
or pests that you can use those as well

00:13:57,529 --> 00:14:00,589
in order to like write your own parser

00:13:59,300 --> 00:14:02,839
if you're trying to like write your own

00:14:00,589 --> 00:14:05,019
language or something like that you can

00:14:02,839 --> 00:14:07,190
use these things in order to parse input

00:14:05,019 --> 00:14:09,380
but I think the key point I want to make

00:14:07,190 --> 00:14:12,050
sure is that you use types types are

00:14:09,380 --> 00:14:15,050
powerful and the less you're dealing

00:14:12,050 --> 00:14:20,389
with a string based API the easier it is

00:14:15,050 --> 00:14:21,500
to catch errors that you might have okay

00:14:20,389 --> 00:14:26,149
so I want to talk a little bit about

00:14:21,500 --> 00:14:31,060
assertions assertions are ways to say I

00:14:26,149 --> 00:14:33,529
need to stop my program because some

00:14:31,060 --> 00:14:36,170
value or something that's supposed to be

00:14:33,529 --> 00:14:38,149
here or supposed to be like this is not

00:14:36,170 --> 00:14:43,250
and it would make more sense for me to

00:14:38,149 --> 00:14:45,680
crash my program than to continue on it

00:14:43,250 --> 00:14:48,230
tends to be the case in like larger

00:14:45,680 --> 00:14:53,329
programs like if we're not able to load

00:14:48,230 --> 00:14:57,980
up you know for instance a configuration

00:14:53,329 --> 00:15:00,470
file or the cache that you're using gets

00:14:57,980 --> 00:15:03,350
invalidated in a really bad way that it

00:15:00,470 --> 00:15:04,759
subtly breaks everything assertions are

00:15:03,350 --> 00:15:06,350
ways to make sure that you can kind of

00:15:04,759 --> 00:15:11,750
just say you know what let's just stop

00:15:06,350 --> 00:15:14,480
and not continue running the program so

00:15:11,750 --> 00:15:17,389
there's a couple there's also assert not

00:15:14,480 --> 00:15:20,269
equal and debug assert not equal I just

00:15:17,389 --> 00:15:23,350
forgot to put down the slides but assert

00:15:20,269 --> 00:15:25,699
says that you know okay I will take some

00:15:23,350 --> 00:15:28,880
condition or something that evaluates to

00:15:25,699 --> 00:15:30,440
be lien yes or no start equals just says

00:15:28,880 --> 00:15:31,730
the thing on the left side is

00:15:30,440 --> 00:15:34,490
equal to the thing on the right side and

00:15:31,730 --> 00:15:38,150
debug assert does the same but they're

00:15:34,490 --> 00:15:40,760
slightly different how they work a cert

00:15:38,150 --> 00:15:43,070
will be in your code even in release

00:15:40,760 --> 00:15:45,560
mode and this is like this is what you

00:15:43,070 --> 00:15:48,080
want to use when you're saying okay as

00:15:45,560 --> 00:15:48,800
I'm running my program even in

00:15:48,080 --> 00:15:52,540
production

00:15:48,800 --> 00:15:54,800
I want to crash it if it's really bad

00:15:52,540 --> 00:15:56,240
and so you can use these assertions as

00:15:54,800 --> 00:15:58,700
kind of like a double checker for you at

00:15:56,240 --> 00:16:00,410
like runtime these extra things that you

00:15:58,700 --> 00:16:04,300
can kind of look at and go okay if it

00:16:00,410 --> 00:16:07,610
fails I want to know that it's failed

00:16:04,300 --> 00:16:10,310
whereas debug assert is very useful

00:16:07,610 --> 00:16:11,900
while you're writing your program when

00:16:10,310 --> 00:16:13,100
you're not running it in production and

00:16:11,900 --> 00:16:15,380
the reason being is that it compiles

00:16:13,100 --> 00:16:18,290
away so in release mode it's not there

00:16:15,380 --> 00:16:20,900
so it's good if you're like kind of just

00:16:18,290 --> 00:16:22,160
you know you want to have a couple

00:16:20,900 --> 00:16:24,230
things in there as you're like working

00:16:22,160 --> 00:16:26,450
like okay I think this should be equal

00:16:24,230 --> 00:16:29,150
to that but if it's not you know it's

00:16:26,450 --> 00:16:30,800
not good so like crash my program and

00:16:29,150 --> 00:16:34,880
then I'll be able to go and try and fix

00:16:30,800 --> 00:16:37,850
it so you can use assertion for things

00:16:34,880 --> 00:16:41,050
that the runtime or that the compiler

00:16:37,850 --> 00:16:43,070
can't necessarily catch with types and

00:16:41,050 --> 00:16:44,900
it's really just more of just something

00:16:43,070 --> 00:16:50,480
that has to do with input or how your

00:16:44,900 --> 00:16:51,620
code parses or deals with things okay so

00:16:50,480 --> 00:16:55,370
I'm going to talk a little bit about

00:16:51,620 --> 00:17:00,050
unwrap and expect I have a lot of

00:16:55,370 --> 00:17:04,270
opinions on this one should you unwrap

00:17:00,050 --> 00:17:08,620
is a question that gets asked a lot and

00:17:04,270 --> 00:17:11,660
my answer to that is it depends

00:17:08,620 --> 00:17:13,970
I've had a Twitter bot that ran for like

00:17:11,660 --> 00:17:16,610
six months that I wrote that was like a

00:17:13,970 --> 00:17:19,730
hundred two hundred lines of code and

00:17:16,610 --> 00:17:23,410
the only reason it stopped working was

00:17:19,730 --> 00:17:30,230
because the server rebooted not because

00:17:23,410 --> 00:17:31,640
the code was bad or anything and also

00:17:30,230 --> 00:17:33,200
like when you're prototyping and you're

00:17:31,640 --> 00:17:34,250
just working on things and you're just

00:17:33,200 --> 00:17:35,660
like trying to get something working

00:17:34,250 --> 00:17:38,690
really quickly it's great you know you

00:17:35,660 --> 00:17:40,850
just you're saying I don't care if the

00:17:38,690 --> 00:17:42,290
result is an error and I don't care if

00:17:40,850 --> 00:17:43,880
there's nothing here I'm pretty sure

00:17:42,290 --> 00:17:46,299
there's gonna be something

00:17:43,880 --> 00:17:51,890
just like let's unwrap and deal with it

00:17:46,299 --> 00:17:56,539
this isn't and that's fine but when you

00:17:51,890 --> 00:17:59,440
start getting larger it starts ending up

00:17:56,539 --> 00:18:04,490
being a problem at work I spent about

00:17:59,440 --> 00:18:05,990
two weeks or a week of time just trying

00:18:04,490 --> 00:18:08,030
to remove all that and it was the

00:18:05,990 --> 00:18:09,919
hardest refactoring I've ever had to do

00:18:08,030 --> 00:18:12,500
and then the PR never ended up getting

00:18:09,919 --> 00:18:15,770
merged because it was just too big in

00:18:12,500 --> 00:18:17,530
order to kind of go okay we understand

00:18:15,770 --> 00:18:20,659
all these changes that are being made

00:18:17,530 --> 00:18:23,900
once it's in your codebase it's kind of

00:18:20,659 --> 00:18:28,520
hard to take out so I have a few

00:18:23,900 --> 00:18:30,230
guidelines regarding this you kind of

00:18:28,520 --> 00:18:31,130
want to use error handling as soon as

00:18:30,230 --> 00:18:35,780
possible

00:18:31,130 --> 00:18:39,380
libraries like failure are really good

00:18:35,780 --> 00:18:41,330
for this they wrap up all the errors in

00:18:39,380 --> 00:18:45,350
a type that you can just kind of return

00:18:41,330 --> 00:18:48,169
to at the top and the faster that you

00:18:45,350 --> 00:18:50,419
end up using error handling the easier

00:18:48,169 --> 00:18:51,500
it is to just keep it that way if all of

00:18:50,419 --> 00:18:53,350
your programs using it from the

00:18:51,500 --> 00:18:55,309
beginning it's not hard to add it in

00:18:53,350 --> 00:18:58,659
versus if it's not using it from the

00:18:55,309 --> 00:19:01,610
beginning it's a lot harder to add it in

00:18:58,659 --> 00:19:04,220
if you can and if you do need to use

00:19:01,610 --> 00:19:07,700
expect or unwrap or unwrap try to use

00:19:04,220 --> 00:19:09,950
expect nothing's worse than having the

00:19:07,700 --> 00:19:11,750
code crash and you're not really sure

00:19:09,950 --> 00:19:14,559
where because the stacktrace just says

00:19:11,750 --> 00:19:17,000
that it failed inside of Lib core and

00:19:14,559 --> 00:19:21,230
that's not useful you don't know where

00:19:17,000 --> 00:19:22,340
the program crashed and so with expect

00:19:21,230 --> 00:19:24,799
you can give it a like a little bit of a

00:19:22,340 --> 00:19:27,200
string like oh we express that we

00:19:24,799 --> 00:19:31,159
expected two plus two to equal 4 but it

00:19:27,200 --> 00:19:32,179
was 5 for some reason and then you can

00:19:31,159 --> 00:19:33,950
kind of search for that in your code

00:19:32,179 --> 00:19:35,929
base you can use like brick prep or just

00:19:33,950 --> 00:19:37,250
grep and you can find that you'll be

00:19:35,929 --> 00:19:42,010
able to kind of go OK like I know where

00:19:37,250 --> 00:19:42,010
it crashed at least we can go from here

00:19:43,000 --> 00:19:49,760
and so if you do use expect and unwrap

00:19:46,809 --> 00:19:52,250
you should only use it if you know it'll

00:19:49,760 --> 00:19:54,470
never panic what you're telling the

00:19:52,250 --> 00:19:58,080
compiler is you're saying I know exactly

00:19:54,470 --> 00:20:01,420
why this is fine I'm saying

00:19:58,080 --> 00:20:03,480
don't worry about it this will always be

00:20:01,420 --> 00:20:05,740
a value or this will never be an error

00:20:03,480 --> 00:20:08,620
the compiler doesn't know that the

00:20:05,740 --> 00:20:10,930
compiler can check types they can do

00:20:08,620 --> 00:20:13,750
borrow checking but it doesn't know

00:20:10,930 --> 00:20:15,730
everything it's only so smart and we as

00:20:13,750 --> 00:20:16,810
the programmers can know certain things

00:20:15,730 --> 00:20:20,460
about it like we could look at that

00:20:16,810 --> 00:20:23,560
program go oh yeah that is that's fine

00:20:20,460 --> 00:20:25,420
so if you do do that you're telling the

00:20:23,560 --> 00:20:28,770
compiler this that it is fine in some

00:20:25,420 --> 00:20:30,760
cases it's totally perfectly fine

00:20:28,770 --> 00:20:33,370
oftentimes I will use it with like the

00:20:30,760 --> 00:20:35,560
standard library mutex to just unwrap it

00:20:33,370 --> 00:20:37,210
when I get a lock because I'm never

00:20:35,560 --> 00:20:40,180
going to crash the program such way

00:20:37,210 --> 00:20:45,340
that's gonna like poison the lock for

00:20:40,180 --> 00:20:48,190
instance so if you do do that though try

00:20:45,340 --> 00:20:50,950
and leave a comment or as as to why it's

00:20:48,190 --> 00:20:51,880
okay it might be obvious for you but for

00:20:50,950 --> 00:20:54,460
someone else coming to read your

00:20:51,880 --> 00:20:57,520
codebase maybe or even yourself six

00:20:54,460 --> 00:20:59,500
months later if you're in that spot you

00:20:57,520 --> 00:21:01,810
might not know why or you might not have

00:20:59,500 --> 00:21:03,550
the context or you might not be someone

00:21:01,810 --> 00:21:06,430
who does know these kinds of things and

00:21:03,550 --> 00:21:08,980
you want to be able to kind of tell

00:21:06,430 --> 00:21:15,580
people this is okay this is not a bad

00:21:08,980 --> 00:21:22,210
thing like here's why so I want to talk

00:21:15,580 --> 00:21:24,790
a little bit about unsafe it's a not the

00:21:22,210 --> 00:21:26,320
best name I think a lot of the times

00:21:24,790 --> 00:21:28,750
people kind of look at unsafe and they

00:21:26,320 --> 00:21:31,210
go oh no we should never ever ever write

00:21:28,750 --> 00:21:35,740
unsafe ever we should ban it from

00:21:31,210 --> 00:21:38,050
everything you can't write a good rust

00:21:35,740 --> 00:21:44,440
program without unsafe that at some

00:21:38,050 --> 00:21:50,260
level it's being used like try try doing

00:21:44,440 --> 00:21:53,260
like a no STD and a no core program and

00:21:50,260 --> 00:21:56,400
try writing it to like print out hello

00:21:53,260 --> 00:21:59,680
world and let me tell you it is very

00:21:56,400 --> 00:22:03,700
very very hard to do without and you

00:21:59,680 --> 00:22:06,790
have to use unsafe at some point you are

00:22:03,700 --> 00:22:10,600
dealing with a computer and a computer

00:22:06,790 --> 00:22:11,230
needs input and output and as much as if

00:22:10,600 --> 00:22:15,730
we want to kind of

00:22:11,230 --> 00:22:17,049
and that it's not there it is and you

00:22:15,730 --> 00:22:20,470
kind of had to deal with these like raw

00:22:17,049 --> 00:22:22,870
pointers and things like that but the

00:22:20,470 --> 00:22:25,510
nice thing is that a lot of the compiler

00:22:22,870 --> 00:22:27,549
a Ness standard library deal with this

00:22:25,510 --> 00:22:29,500
for you a lot of smart people have spent

00:22:27,549 --> 00:22:31,270
some time writing it to make sure that

00:22:29,500 --> 00:22:34,240
we have some really safe code that's

00:22:31,270 --> 00:22:35,049
really performant that allows us to deal

00:22:34,240 --> 00:22:39,370
with all this stuff

00:22:35,049 --> 00:22:41,169
Veck is a really great example you don't

00:22:39,370 --> 00:22:44,290
have to worry about a global array you

00:22:41,169 --> 00:22:46,600
just throw values into it and it works I

00:22:44,290 --> 00:22:48,549
like to call it the memory safe the

00:22:46,600 --> 00:22:51,190
memory safe allocator for rust

00:22:48,549 --> 00:22:52,570
developers in the sense that you don't

00:22:51,190 --> 00:22:55,500
have to worry about memory allocation

00:22:52,570 --> 00:22:55,500
Beck just does it for you

00:22:55,540 --> 00:23:02,950
so with unsafe what you're trying to

00:22:58,299 --> 00:23:07,870
tell the compiler is that this is fine

00:23:02,950 --> 00:23:10,270
this is OK code you can't I can't prove

00:23:07,870 --> 00:23:12,040
that to you but you should listen to me

00:23:10,270 --> 00:23:13,150
and just trust me I think that's kind of

00:23:12,040 --> 00:23:18,880
what we should have called unsafe who's

00:23:13,150 --> 00:23:22,809
just trust me because it's it's not

00:23:18,880 --> 00:23:25,210
really unsafe so much as it is just you

00:23:22,809 --> 00:23:29,080
have to be careful you're you're

00:23:25,210 --> 00:23:31,630
upholding invariance laws like a

00:23:29,080 --> 00:23:34,059
contract you have this contract with the

00:23:31,630 --> 00:23:36,429
compiler and the compiler is expecting

00:23:34,059 --> 00:23:37,600
you to uphold that contract you don't

00:23:36,429 --> 00:23:39,520
want to break the compilers trust

00:23:37,600 --> 00:23:41,080
because what happens up happening is

00:23:39,520 --> 00:23:45,400
that you end up having like undefined

00:23:41,080 --> 00:23:48,340
behavior seg faults all kinds of not fun

00:23:45,400 --> 00:23:50,980
things the things that rust is trying to

00:23:48,340 --> 00:23:55,150
prevent but safe rust can only do so

00:23:50,980 --> 00:23:58,120
much safe rust knows it's rules and it's

00:23:55,150 --> 00:23:59,890
says okay I know these work but unsafe

00:23:58,120 --> 00:24:03,130
for us is saying I'm gonna let you do

00:23:59,890 --> 00:24:04,600
some other stuff but I need you to also

00:24:03,130 --> 00:24:06,880
make sure that whatever you're doing

00:24:04,600 --> 00:24:09,929
upholds these rules to because I can't

00:24:06,880 --> 00:24:09,929
try I can't do that

00:24:10,860 --> 00:24:17,290
so some guidelines with that you want to

00:24:14,890 --> 00:24:20,049
minimize the scope of unsafe calls you

00:24:17,290 --> 00:24:22,890
want to kind of keep it to one line if

00:24:20,049 --> 00:24:25,100
you can or maybe like a block the less

00:24:22,890 --> 00:24:28,460
less kind of

00:24:25,100 --> 00:24:31,279
on safe that you use the better it's

00:24:28,460 --> 00:24:34,520
gonna be for you and the reason being is

00:24:31,279 --> 00:24:37,250
that it's a lot easier to think about

00:24:34,520 --> 00:24:40,460
it's a lot easier to navigate about in

00:24:37,250 --> 00:24:43,520
your code if you have just a whole lot

00:24:40,460 --> 00:24:45,710
of the code is unsafe it's tagged unsafe

00:24:43,520 --> 00:24:47,840
but really only a portion of it should

00:24:45,710 --> 00:24:50,870
have been it's kind of hard to think

00:24:47,840 --> 00:24:52,490
about oh did and especially if someone

00:24:50,870 --> 00:24:53,240
else comes in much later and helps work

00:24:52,490 --> 00:24:55,580
on your code base

00:24:53,240 --> 00:24:57,440
oh is that unsafe why is that and they

00:24:55,580 --> 00:25:00,049
have to think about all these things if

00:24:57,440 --> 00:25:02,600
you just say no this pointer read this

00:25:00,049 --> 00:25:04,340
raw pointer read is unsafe and you just

00:25:02,600 --> 00:25:07,010
leave it there then it's a lot easier

00:25:04,340 --> 00:25:09,649
for someone coming in looking at the

00:25:07,010 --> 00:25:11,899
code going oh yes just this one spot

00:25:09,649 --> 00:25:18,190
this is the one spot that's unsafe and

00:25:11,899 --> 00:25:21,919
here's why if you are doing functions

00:25:18,190 --> 00:25:24,380
you're writing code and someone has

00:25:21,919 --> 00:25:27,380
who's calling your function needs to

00:25:24,380 --> 00:25:32,029
uphold a very specific contract

00:25:27,380 --> 00:25:33,950
themselves right like oh don't don't

00:25:32,029 --> 00:25:35,870
pass overall pointer in or don't pass a

00:25:33,950 --> 00:25:38,090
null pointer in or whatever the case

00:25:35,870 --> 00:25:40,610
might be or we assume that this is a

00:25:38,090 --> 00:25:42,080
null terminated string right these

00:25:40,610 --> 00:25:45,110
things that the compiler can't check

00:25:42,080 --> 00:25:46,789
obviously they're at runtime then you

00:25:45,110 --> 00:25:48,980
should mark the function itself unsafe

00:25:46,789 --> 00:25:50,539
and the reason being is that you want

00:25:48,980 --> 00:25:54,919
other people when they're calling that

00:25:50,539 --> 00:25:58,370
function to know yes this is fine or I

00:25:54,919 --> 00:26:03,470
need to I need to uphold certain laws

00:25:58,370 --> 00:26:04,669
they're also part of this contract but

00:26:03,470 --> 00:26:07,190
what would be even better is that

00:26:04,669 --> 00:26:09,260
instead of exposing unsafe interfaces

00:26:07,190 --> 00:26:12,409
you actually provide safe interfaces on

00:26:09,260 --> 00:26:14,690
top of them Nicks is a wonderful crate

00:26:12,409 --> 00:26:18,500
as an example for this it's a wrapper

00:26:14,690 --> 00:26:22,039
around Lib C and not only does it deal

00:26:18,500 --> 00:26:24,710
with all the not so fun stuff with error

00:26:22,039 --> 00:26:27,679
handling in Lib C but it also provides a

00:26:24,710 --> 00:26:29,720
rust like interface on top so instead of

00:26:27,679 --> 00:26:31,909
dealing with like I'm writing C code

00:26:29,720 --> 00:26:34,279
that just happens to be in rust you're

00:26:31,909 --> 00:26:35,929
dealing with I'm writing rusts code that

00:26:34,279 --> 00:26:39,429
happens to be calling C functions and

00:26:35,929 --> 00:26:39,429
that's a much nicer experience

00:26:40,029 --> 00:26:48,649
so if you do use unsafe where you call

00:26:44,149 --> 00:26:50,240
it again comments you don't know where

00:26:48,649 --> 00:26:52,370
you'll be in six months when you come

00:26:50,240 --> 00:26:53,899
back to your code you don't know if some

00:26:52,370 --> 00:26:56,179
if it's an open source project something

00:26:53,899 --> 00:26:59,149
coming into your codebase is looking at

00:26:56,179 --> 00:27:03,110
it going I don't know I don't understand

00:26:59,149 --> 00:27:05,029
you you yourself know and you're kind of

00:27:03,110 --> 00:27:08,840
doing yourself and future people a bit

00:27:05,029 --> 00:27:11,990
of a service by just documenting it for

00:27:08,840 --> 00:27:15,429
them saying here's why it's okay and if

00:27:11,990 --> 00:27:18,470
that changes then it's probably unsafe

00:27:15,429 --> 00:27:20,929
and then you also want to make sure that

00:27:18,470 --> 00:27:25,159
you document invariants for unsafe

00:27:20,929 --> 00:27:27,139
functions and by that I mean what are

00:27:25,159 --> 00:27:30,950
the things that people who use this

00:27:27,139 --> 00:27:33,590
unsafe function are required to do a lot

00:27:30,950 --> 00:27:35,000
of the time it's easy to go oh I don't

00:27:33,590 --> 00:27:36,529
need to write documentation it's fine

00:27:35,000 --> 00:27:38,240
people who are calling this will

00:27:36,529 --> 00:27:40,549
understand sure

00:27:38,240 --> 00:27:43,669
for regular functions may be but with

00:27:40,549 --> 00:27:45,889
unsafe functions you know it's gonna be

00:27:43,669 --> 00:27:48,559
pretty subtle as to what needs to happen

00:27:45,889 --> 00:27:50,210
or in order to work in such a way that

00:27:48,559 --> 00:27:52,880
it doesn't break people's code at

00:27:50,210 --> 00:27:54,440
runtime a lot of the time it's you can't

00:27:52,880 --> 00:27:56,990
really notice that until it's too late

00:27:54,440 --> 00:27:58,850
and so by documenting and kind of

00:27:56,990 --> 00:28:01,700
putting a big warning sign on it people

00:27:58,850 --> 00:28:04,309
can go oh okay I understand what I have

00:28:01,700 --> 00:28:05,090
to do if you look at the standard

00:28:04,309 --> 00:28:08,779
library Docs

00:28:05,090 --> 00:28:12,470
especially under STD D mm and STD

00:28:08,779 --> 00:28:13,940
pointer or PTR you'll see that there's

00:28:12,470 --> 00:28:16,519
quite a few functions in there that are

00:28:13,940 --> 00:28:18,950
unsafe and they're really great examples

00:28:16,519 --> 00:28:21,080
of this they're fairly well documented

00:28:18,950 --> 00:28:22,850
and they tell you all the things you

00:28:21,080 --> 00:28:25,730
should do in order to make sure that

00:28:22,850 --> 00:28:29,870
it's safe as well as like a couple of

00:28:25,730 --> 00:28:31,659
gotchas if you do it incorrectly mem

00:28:29,870 --> 00:28:35,029
transmute is a very particularly

00:28:31,659 --> 00:28:38,659
big red warning sign of don't use this

00:28:35,029 --> 00:28:41,000
it's like a it's the barrier between you

00:28:38,659 --> 00:28:46,110
and a really bad time is just a little

00:28:41,000 --> 00:28:47,040
bit of dental floss it is not much and

00:28:46,110 --> 00:28:48,930
but that's not to say that you shouldn't

00:28:47,040 --> 00:28:51,630
use it sometimes it's very very useful

00:28:48,930 --> 00:28:53,190
unsafe is a very useful thing to have

00:28:51,630 --> 00:28:54,810
and sometimes there are just things that

00:28:53,190 --> 00:28:58,800
you know yourself is gonna be fine

00:28:54,810 --> 00:29:01,770
like okay you could use from utf8

00:28:58,800 --> 00:29:04,350
unchecked for instance well if you're

00:29:01,770 --> 00:29:06,620
directly writing all the utf-8 bytes

00:29:04,350 --> 00:29:09,780
into an array and it's statically there

00:29:06,620 --> 00:29:11,100
well that's fine you know it's there so

00:29:09,780 --> 00:29:12,630
you can just use that you can use it

00:29:11,100 --> 00:29:14,100
unchecked like why are you doing a

00:29:12,630 --> 00:29:17,970
compile time check for something that

00:29:14,100 --> 00:29:21,050
you already know works so just just be

00:29:17,970 --> 00:29:23,820
careful write documentation for it and

00:29:21,050 --> 00:29:25,380
but also know that it's not a bad thing

00:29:23,820 --> 00:29:27,510
a lot of times people kind of look at

00:29:25,380 --> 00:29:30,630
unsafe as this like oh I should never

00:29:27,510 --> 00:29:32,070
ever write it ever and you should I

00:29:30,630 --> 00:29:33,630
think if you haven't spent some time

00:29:32,070 --> 00:29:36,480
writing someone safe functions I think

00:29:33,630 --> 00:29:39,060
you should but if your first instinct

00:29:36,480 --> 00:29:41,850
too is when you're writing Russ code to

00:29:39,060 --> 00:29:43,830
go oh the compilers in my way let me

00:29:41,850 --> 00:29:46,140
just do this thing that I did or

00:29:43,830 --> 00:29:48,150
whatever in an unsafe function you

00:29:46,140 --> 00:29:49,860
probably want to try and find a more

00:29:48,150 --> 00:29:51,600
rust like way usually when the compiler

00:29:49,860 --> 00:29:53,010
is telling you don't do that it just

00:29:51,600 --> 00:29:59,310
means that you're not really kind of

00:29:53,010 --> 00:30:02,310
acting within rusts design so that's

00:29:59,310 --> 00:30:06,390
kind of all I have for today we covered

00:30:02,310 --> 00:30:09,810
a lot of a lot of things we covered new

00:30:06,390 --> 00:30:11,610
types we covered the Builder pattern we

00:30:09,810 --> 00:30:13,410
covered kind of making sure that you

00:30:11,610 --> 00:30:16,350
turn springle type two interfaces into

00:30:13,410 --> 00:30:21,030
types a little bit of unsafe and as well

00:30:16,350 --> 00:30:22,090
as about unwrap and expect so yeah thank

00:30:21,030 --> 00:30:22,430
you very much

00:30:22,090 --> 00:30:25,529
[Applause]

00:30:22,430 --> 00:30:25,529
[Music]

00:30:25,779 --> 00:30:27,840
you

00:30:30,470 --> 00:30:33,549

YouTube URL: https://www.youtube.com/watch?v=jT6YEiE6O6E


