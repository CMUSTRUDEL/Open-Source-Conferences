Title: RustLatam 2019 - Florian Gilcher: The Power of the "Where" Clause
Publication date: 2019-04-21
Playlist: Rust Latam 2019
Description: 
	Rust expresses trait bounds using the where clause. It is an essential tool for all generic Rust programming. Yet, many Rust programmers don't know about the full expressiveness of it!

This talk guides us through most of the features and shows us how to creatively use where clauses to both keep our code clean and flexible, but also sound and hard to use in a wrong way.

This talk will teach us the basic building blocks to not get lost in a forest of constraints.

Follow us on Twitter: https://twitter.com/rustlatamconf
Captions: 
	00:00:07,490 --> 00:00:12,780
well hello and thank you

00:00:09,870 --> 00:00:15,360
first of all Alex has not told you the

00:00:12,780 --> 00:00:16,770
full story this is now a completely

00:00:15,360 --> 00:00:18,390
valid Ross program and you actually

00:00:16,770 --> 00:00:20,660
don't need to program anything anymore

00:00:18,390 --> 00:00:25,320
you can just have everything generated

00:00:20,660 --> 00:00:28,740
we just lost their jobs so Who am I I'm

00:00:25,320 --> 00:00:32,660
Rory on Twitter and company links on

00:00:28,740 --> 00:00:37,440
this slide I'm here for Mozilla actually

00:00:32,660 --> 00:00:39,329
Mozilla sent me here as a part of the

00:00:37,440 --> 00:00:40,620
tech speaker program and this is

00:00:39,329 --> 00:00:43,230
actually my second time I'm on this

00:00:40,620 --> 00:00:47,039
stage I was here before at Rubicon

00:00:43,230 --> 00:00:50,070
why keeping my I was 10 years in the

00:00:47,039 --> 00:00:51,780
Ruby community talk now I'm 5 years in

00:00:50,070 --> 00:00:53,940
the rust community is something like

00:00:51,780 --> 00:00:56,550
that and I met a lot of familiar faces

00:00:53,940 --> 00:00:58,670
I'm happy to be again I started rust in

00:00:56,550 --> 00:01:02,879
2015 mostly out of personal curiosity

00:00:58,670 --> 00:01:05,070
and because I'm not a good solo learner

00:01:02,879 --> 00:01:07,439
I immediately started the Berlin user

00:01:05,070 --> 00:01:09,390
group which is one of the biggest and

00:01:07,439 --> 00:01:11,369
most active around the globe I'm

00:01:09,390 --> 00:01:13,710
organizing a to Russ conferences

00:01:11,369 --> 00:01:15,810
Wurstfest and oxidized conf I can have

00:01:13,710 --> 00:01:18,180
the emphasize with how much and have

00:01:15,810 --> 00:01:21,439
much of a great job this is having that

00:01:18,180 --> 00:01:25,290
and I'm a product member since 2015

00:01:21,439 --> 00:01:27,299
mostly in the community team and now

00:01:25,290 --> 00:01:30,570
also moving to other spaces and I can

00:01:27,299 --> 00:01:32,759
definitely agree with Nico that the Russ

00:01:30,570 --> 00:01:34,890
project is very very easy to join on all

00:01:32,759 --> 00:01:36,960
positions if you have something that

00:01:34,890 --> 00:01:38,850
specifically this is specifically off

00:01:36,960 --> 00:01:42,600
your interest it's really easy to get in

00:01:38,850 --> 00:01:44,610
touch with people and get involved and

00:01:42,600 --> 00:01:46,799
this is also my first talk on a Russ

00:01:44,610 --> 00:01:48,600
conference I've organized them I have

00:01:46,799 --> 00:01:51,000
never given a talk in Russ conference um

00:01:48,600 --> 00:01:52,710
and what I want to do is I want to make

00:01:51,000 --> 00:01:54,840
you competent at reading and writing

00:01:52,710 --> 00:01:56,880
where classes because they are important

00:01:54,840 --> 00:01:59,009
but have some subtleties to understand

00:01:56,880 --> 00:02:00,750
so just as a bit of background what is

00:01:59,009 --> 00:02:02,750
the where clause let's say we have a

00:02:00,750 --> 00:02:05,969
pretty simple data type we have a point

00:02:02,750 --> 00:02:07,500
point has an X and the y value and we

00:02:05,969 --> 00:02:09,899
have a function that's called print

00:02:07,500 --> 00:02:12,880
point that just takes a reference to

00:02:09,899 --> 00:02:14,770
that point it prints it out nothing

00:02:12,880 --> 00:02:17,740
important the most important thing here

00:02:14,770 --> 00:02:21,130
is this point implements debug because

00:02:17,740 --> 00:02:23,320
our println macro requires things that

00:02:21,130 --> 00:02:27,970
we print out using the coop question

00:02:23,320 --> 00:02:31,300
mark syntax sorry it requires them to be

00:02:27,970 --> 00:02:35,170
debug but this version of this function

00:02:31,300 --> 00:02:38,680
just takes a bear point so whatever have

00:02:35,170 --> 00:02:41,410
squares so I have a square it has an x

00:02:38,680 --> 00:02:43,930
and y position and width that's enough

00:02:41,410 --> 00:02:46,450
to describe a square and I can write a

00:02:43,930 --> 00:02:48,400
print square function that takes the

00:02:46,450 --> 00:02:51,970
square and just does exactly the same

00:02:48,400 --> 00:02:54,820
thing that's very repetitive and

00:02:51,970 --> 00:02:57,510
computers are very good at repetitive we

00:02:54,820 --> 00:03:00,070
are not as good as computers here and

00:02:57,510 --> 00:03:01,960
the unifying thing but the instant

00:03:00,070 --> 00:03:05,050
between these two is not that they're

00:03:01,960 --> 00:03:07,200
shapes for the printing function what we

00:03:05,050 --> 00:03:09,850
need is actually that both of them

00:03:07,200 --> 00:03:13,360
implement the debugging representation

00:03:09,850 --> 00:03:16,560
by using the derive debug statement up

00:03:13,360 --> 00:03:22,960
there so we can rewrite that function as

00:03:16,560 --> 00:03:26,140
FN print takes a shape s takes a borrow

00:03:22,960 --> 00:03:27,490
of the shape s and prints it out but the

00:03:26,140 --> 00:03:31,330
important thing is we need to indicate

00:03:27,490 --> 00:03:33,640
to the compiler in some way that we only

00:03:31,330 --> 00:03:35,410
accept types that we can actually turn

00:03:33,640 --> 00:03:37,870
into this debug representation that we

00:03:35,410 --> 00:03:43,630
do using the where Clause so we put

00:03:37,870 --> 00:03:46,450
there where as is debug the thing under

00:03:43,630 --> 00:03:49,600
number three is called the trade bound

00:03:46,450 --> 00:03:54,630
and the thing under number one is called

00:03:49,600 --> 00:03:59,530
a trade variable a type variable sorry

00:03:54,630 --> 00:04:01,930
so now we can both create a point and a

00:03:59,530 --> 00:04:04,720
Square and use both print both of them

00:04:01,930 --> 00:04:08,110
out using print the important part here

00:04:04,720 --> 00:04:09,820
is the first statement the first print

00:04:08,110 --> 00:04:12,490
statement internally calls a function

00:04:09,820 --> 00:04:14,380
that's called something like print point

00:04:12,490 --> 00:04:16,810
and the second something like print

00:04:14,380 --> 00:04:19,600
Square important thing here is those are

00:04:16,810 --> 00:04:21,720
actually different functions the

00:04:19,600 --> 00:04:24,040
compiler just generates them for us

00:04:21,720 --> 00:04:25,660
logically speaking there is an infinite

00:04:24,040 --> 00:04:26,680
number of those there's an infinite

00:04:25,660 --> 00:04:29,440
number of those function

00:04:26,680 --> 00:04:31,000
for every type that is debug but in case

00:04:29,440 --> 00:04:35,470
of this program we actually only

00:04:31,000 --> 00:04:37,419
compiled two so for rust from rust point

00:04:35,470 --> 00:04:39,669
of view those functions will be compiled

00:04:37,419 --> 00:04:41,650
on need we are actually using print

00:04:39,669 --> 00:04:43,570
point we are actually using print square

00:04:41,650 --> 00:04:47,080
these two are needed these two are going

00:04:43,570 --> 00:04:51,610
to be generated there are other places

00:04:47,080 --> 00:04:54,100
where the where Clause can be stated for

00:04:51,610 --> 00:05:00,120
example we can create a struct that is

00:04:54,100 --> 00:05:02,349
generic that inside has to some things

00:05:00,120 --> 00:05:05,320
preferably numbers if we representing a

00:05:02,349 --> 00:05:07,870
point and we can also say he needs to be

00:05:05,320 --> 00:05:14,710
debug most of the stuff that's important

00:05:07,870 --> 00:05:17,590
you can totally exercise on functions a

00:05:14,710 --> 00:05:19,810
bit more detail here so we have a

00:05:17,590 --> 00:05:25,300
function that takes that has two

00:05:19,810 --> 00:05:27,520
generics T and E and I can express what

00:05:25,300 --> 00:05:29,770
I want from them first of all what the

00:05:27,520 --> 00:05:34,229
wave function the where Clause gives me

00:05:29,770 --> 00:05:36,880
over any color other shorthand syntax is

00:05:34,229 --> 00:05:38,889
that I can split it up so it can state

00:05:36,880 --> 00:05:40,870
but bounce multiple times I can say I

00:05:38,889 --> 00:05:43,840
want t to implement a trade call trade

00:05:40,870 --> 00:05:46,000
and a trade called other trade or I

00:05:43,840 --> 00:05:48,190
could have another type e that

00:05:46,000 --> 00:05:51,580
implements trade plus other trades so I

00:05:48,190 --> 00:05:53,889
can do both of these it's functionally

00:05:51,580 --> 00:05:56,400
the same but for ordering your code it

00:05:53,889 --> 00:05:58,720
just helps a lot

00:05:56,400 --> 00:06:03,159
the important thing in the where clause

00:05:58,720 --> 00:06:05,830
is the left things are concrete types so

00:06:03,159 --> 00:06:10,479
what this says is I have a function and

00:06:05,830 --> 00:06:14,409
for every pair of of types T and E that

00:06:10,479 --> 00:06:16,389
fulfill the bands to the right there are

00:06:14,409 --> 00:06:23,919
I can't compile this function for any

00:06:16,389 --> 00:06:26,500
two exact types before because the left

00:06:23,919 --> 00:06:28,630
hand is an actual type this for example

00:06:26,500 --> 00:06:32,169
works i can say i have a function takes

00:06:28,630 --> 00:06:34,479
in two string t where string which is

00:06:32,169 --> 00:06:37,750
the standard string of the rust library

00:06:34,479 --> 00:06:39,610
library implements from t so i can say i

00:06:37,750 --> 00:06:40,480
take any kinds of types that can be

00:06:39,610 --> 00:06:47,470
turned into a

00:06:40,480 --> 00:06:50,410
in that way where classes are important

00:06:47,470 --> 00:06:52,590
for a couple of reasons for example they

00:06:50,410 --> 00:06:54,940
are the way how we can for example

00:06:52,590 --> 00:07:00,310
constrain on the type that an iterator

00:06:54,940 --> 00:07:01,900
returns us so again using just the bear

00:07:00,310 --> 00:07:04,060
debug trade and printing stuff out to

00:07:01,900 --> 00:07:06,460
the console I can have a function called

00:07:04,060 --> 00:07:10,570
debug eater that takes any kind of

00:07:06,460 --> 00:07:14,650
iterator the iterator trade is again

00:07:10,570 --> 00:07:16,570
standard iterator but it has an

00:07:14,650 --> 00:07:19,150
Associated type which is the item that

00:07:16,570 --> 00:07:21,190
it's going to return I don't know what

00:07:19,150 --> 00:07:24,400
the item is but using the where Clause I

00:07:21,190 --> 00:07:27,220
can at least say the item must be in the

00:07:24,400 --> 00:07:32,250
set of types that do implement debug and

00:07:27,220 --> 00:07:34,750
that can be printed to the console and

00:07:32,250 --> 00:07:36,010
to my knowledge that was also one of the

00:07:34,750 --> 00:07:37,540
arguments why they were closed although

00:07:36,010 --> 00:07:41,320
actually continues to be able to

00:07:37,540 --> 00:07:42,640
actually do it so there's a couple of

00:07:41,320 --> 00:07:49,020
patterns on how we can work without

00:07:42,640 --> 00:07:51,400
notice so when I do generic programming

00:07:49,020 --> 00:07:55,650
I'm always talking about this idea of

00:07:51,400 --> 00:07:58,600
constraints and for example if we take

00:07:55,650 --> 00:08:02,830
some of the standard library types for

00:07:58,600 --> 00:08:05,020
example result result being either this

00:08:02,830 --> 00:08:08,290
work and gives me result back that's the

00:08:05,020 --> 00:08:11,410
okay variant of the result enum or it

00:08:08,290 --> 00:08:14,350
gives me an error back that doesn't give

00:08:11,410 --> 00:08:15,670
me a lot and if you have a look at the

00:08:14,350 --> 00:08:18,160
standard library implementation of

00:08:15,670 --> 00:08:20,050
results um there's a couple of functions

00:08:18,160 --> 00:08:23,400
defined that this is less actually a lot

00:08:20,050 --> 00:08:26,710
of functions defined on this type and

00:08:23,400 --> 00:08:28,800
the most basic ones are for example here

00:08:26,710 --> 00:08:32,290
the implementation for any kind of

00:08:28,800 --> 00:08:34,840
result value or error I have two

00:08:32,290 --> 00:08:37,030
functions is okay or is error just let

00:08:34,840 --> 00:08:39,880
just tell me which of the variants that

00:08:37,030 --> 00:08:46,360
was that does need no knowledge about

00:08:39,880 --> 00:08:49,600
what T and E actually are but if I want

00:08:46,360 --> 00:08:52,390
to call unwrap for example if I have

00:08:49,600 --> 00:08:53,580
result unwrap I'm going to have a panic

00:08:52,390 --> 00:08:55,920
message that

00:08:53,580 --> 00:08:59,820
includes the debug representation of my

00:08:55,920 --> 00:09:02,550
arrow that I had and there I have an

00:08:59,820 --> 00:09:05,400
implementation that says imple te result

00:09:02,550 --> 00:09:07,650
te where e is debug and then there's a

00:09:05,400 --> 00:09:10,320
couple of functions that rely on error

00:09:07,650 --> 00:09:11,100
actually being because of both units the

00:09:10,320 --> 00:09:16,200
other way around

00:09:11,100 --> 00:09:19,440
there's implementations for if T value

00:09:16,200 --> 00:09:21,540
when when everything work if T

00:09:19,440 --> 00:09:23,970
implements default so it has a default

00:09:21,540 --> 00:09:27,540
value result gains a function that's

00:09:23,970 --> 00:09:29,580
called unwrap or default which doesn't

00:09:27,540 --> 00:09:33,900
panic but instead in case of an error

00:09:29,580 --> 00:09:36,300
gives me the default value back so we

00:09:33,900 --> 00:09:38,280
are gradually constraining the result

00:09:36,300 --> 00:09:42,590
type more and the more we know about it

00:09:38,280 --> 00:09:46,890
the more functions get unlocked on it

00:09:42,590 --> 00:09:51,060
and gradually unlocking features based

00:09:46,890 --> 00:09:53,070
on these kinds of bounds is a common API

00:09:51,060 --> 00:09:58,020
strategy in rosslyn you can see that all

00:09:53,070 --> 00:09:59,850
through the standard library let's look

00:09:58,020 --> 00:10:04,800
about another piece of standard library

00:09:59,850 --> 00:10:06,660
which is the threading API I have a

00:10:04,800 --> 00:10:08,790
threat I have an example here that does

00:10:06,660 --> 00:10:13,110
again something rather useless I have a

00:10:08,790 --> 00:10:16,770
vector and I spawn a thread which takes

00:10:13,110 --> 00:10:20,970
that vector and counts the elements of

00:10:16,770 --> 00:10:22,560
it and gives me the result back the

00:10:20,970 --> 00:10:24,210
threading API is generic because they

00:10:22,560 --> 00:10:31,310
can push anything inside and get

00:10:24,210 --> 00:10:34,140
anything back so coming up with a first

00:10:31,310 --> 00:10:35,670
attempt at writing that on my own you

00:10:34,140 --> 00:10:39,090
could come up with something like this

00:10:35,670 --> 00:10:44,100
you have the sweat spawn function it

00:10:39,090 --> 00:10:49,520
takes an F and the T type takes in DF it

00:10:44,100 --> 00:10:53,520
returns me the T why is it F second

00:10:49,520 --> 00:10:57,000
thread spawn takes the closure ones that

00:10:53,520 --> 00:10:58,830
closure includes all the data that is my

00:10:57,000 --> 00:11:02,880
close close over in this case the vector

00:10:58,830 --> 00:11:06,270
and returns me whatever that closure has

00:11:02,880 --> 00:11:07,230
actually returned as the join handle so

00:11:06,270 --> 00:11:10,710
join handle will be

00:11:07,230 --> 00:11:12,870
me information of has that one has that

00:11:10,710 --> 00:11:14,520
that actually run to completion was

00:11:12,870 --> 00:11:15,930
there an error whatever but it gives me

00:11:14,520 --> 00:11:22,260
the result all you back

00:11:15,930 --> 00:11:26,030
the problem is what fits these slots

00:11:22,260 --> 00:11:31,230
what can I put into that F and that T

00:11:26,030 --> 00:11:35,760
problem there is threats if I'm spawning

00:11:31,230 --> 00:11:38,850
a thread a classic problem is all the

00:11:35,760 --> 00:11:41,730
data that is put on that thread should

00:11:38,850 --> 00:11:43,290
preferably not reference anything out of

00:11:41,730 --> 00:11:46,200
the context where the thread was spawned

00:11:43,290 --> 00:11:49,890
in why because both are going to run in

00:11:46,200 --> 00:11:52,980
parallel and the data in the first part

00:11:49,890 --> 00:11:55,200
might be removed changed whatever and is

00:11:52,980 --> 00:11:57,770
independent of the second so I want to

00:11:55,200 --> 00:12:00,990
have this idea that Nikko introduced

00:11:57,770 --> 00:12:03,270
today today in the morning of actually

00:12:00,990 --> 00:12:06,140
giving complete packages over and also

00:12:03,270 --> 00:12:10,410
getting complete packages back and

00:12:06,140 --> 00:12:13,100
forcing the forcing the programmer to

00:12:10,410 --> 00:12:18,360
actually move everything over and not

00:12:13,100 --> 00:12:20,430
half of it the problem is if I would

00:12:18,360 --> 00:12:25,380
write the API like this that were

00:12:20,430 --> 00:12:29,490
actually possible because I have not any

00:12:25,380 --> 00:12:31,290
have no other constraints on F and T

00:12:29,490 --> 00:12:33,930
then that they actually generic types

00:12:31,290 --> 00:12:36,150
that might be they might end up being

00:12:33,930 --> 00:12:40,650
references they might be any kind of

00:12:36,150 --> 00:12:44,220
valid lost type so what I can do I can

00:12:40,650 --> 00:12:46,740
use the work where at the where clause

00:12:44,220 --> 00:12:49,650
here to express additional things here

00:12:46,740 --> 00:12:52,290
and a way of expressing what I just said

00:12:49,650 --> 00:12:55,230
you can actually send that stuff over to

00:12:52,290 --> 00:12:56,610
a thread rust has a marker for that rust

00:12:55,230 --> 00:12:58,920
has a marker for everything that is

00:12:56,610 --> 00:13:01,800
actually allowed to do that traveling

00:12:58,920 --> 00:13:07,140
that's called scent and the other thing

00:13:01,800 --> 00:13:09,560
is I can bound this value with a special

00:13:07,140 --> 00:13:13,610
lifetime that's called to ecstatic and

00:13:09,560 --> 00:13:16,530
the bound any type plastic static

00:13:13,610 --> 00:13:18,780
essentially means it must own all data

00:13:16,530 --> 00:13:20,480
so you can give up complete ownership

00:13:18,780 --> 00:13:23,000
like the

00:13:20,480 --> 00:13:26,000
party that spawns the threat must give

00:13:23,000 --> 00:13:28,300
up complete ownership of all the data of

00:13:26,000 --> 00:13:31,550
all the payload it puts on the Fed and

00:13:28,300 --> 00:13:34,130
after the threat is done we want to

00:13:31,550 --> 00:13:35,780
remove it and throw it away we also need

00:13:34,130 --> 00:13:39,310
to have the ability to bring everything

00:13:35,780 --> 00:13:42,230
back that you want to bring so this F

00:13:39,310 --> 00:13:47,210
cent prostatic bound expresses this

00:13:42,230 --> 00:13:50,060
quite neatly there was an issue in my

00:13:47,210 --> 00:13:52,460
teaching in like two or three years ago

00:13:50,060 --> 00:13:54,590
that people felt like expressing plastic

00:13:52,460 --> 00:13:56,540
static is cheating because you don't

00:13:54,590 --> 00:13:58,610
take part in the references game it's

00:13:56,540 --> 00:14:00,350
actually a meaningful statement if you

00:13:58,610 --> 00:14:03,650
don't want to deal with references if

00:14:00,350 --> 00:14:06,020
you don't want to deal with borrows just

00:14:03,650 --> 00:14:08,000
Express tic static and that's probably a

00:14:06,020 --> 00:14:13,280
very valid solution to your problem and

00:14:08,000 --> 00:14:16,490
just deal with ownership another problem

00:14:13,280 --> 00:14:19,790
that might arise when you start working

00:14:16,490 --> 00:14:22,870
with where clauses and start trying out

00:14:19,790 --> 00:14:27,170
bounds is we often have rapper types and

00:14:22,870 --> 00:14:30,650
rapper types sometimes Express some

00:14:27,170 --> 00:14:33,260
kinds of expectancies over what you put

00:14:30,650 --> 00:14:36,140
inside here again I have a rapper and I

00:14:33,260 --> 00:14:40,490
game again just using the debug trade as

00:14:36,140 --> 00:14:42,230
a as an example trade now I have another

00:14:40,490 --> 00:14:45,190
function that takes that rapper into

00:14:42,230 --> 00:14:49,150
some raps it and takes the inner part

00:14:45,190 --> 00:14:53,630
but because I have expressed that rapper

00:14:49,150 --> 00:14:57,320
only can can only have pipes with a

00:14:53,630 --> 00:15:01,070
certain bound inside if I want to write

00:14:57,320 --> 00:15:03,170
take inner I also to fulfill that I also

00:15:01,070 --> 00:15:05,930
always have to constrain the generic

00:15:03,170 --> 00:15:12,080
type or the generic variables of take

00:15:05,930 --> 00:15:14,420
inner as debug the function itself

00:15:12,080 --> 00:15:16,790
doesn't actually use it though so that's

00:15:14,420 --> 00:15:18,500
a problem I'm I want to try I want to

00:15:16,790 --> 00:15:20,270
write this function it just does nothing

00:15:18,500 --> 00:15:22,760
more than taking that structure taking

00:15:20,270 --> 00:15:25,450
out whatsoever inside but I do have to

00:15:22,760 --> 00:15:30,340
express an additional bound just to

00:15:25,450 --> 00:15:32,990
basically reiterate that rapper already

00:15:30,340 --> 00:15:35,680
expects the inner part to be debug and

00:15:32,990 --> 00:15:35,680
nothing else is

00:15:35,800 --> 00:15:44,120
so what can I do against that there's a

00:15:39,860 --> 00:15:47,320
pattern in which you can write this

00:15:44,120 --> 00:15:50,630
rapper in a way that it actually itself

00:15:47,320 --> 00:15:54,560
can't contain any type but you can

00:15:50,630 --> 00:15:58,250
exactly only create that rapper in a

00:15:54,560 --> 00:16:01,670
fashion where it is debug let's just do

00:15:58,250 --> 00:16:03,529
me in here the way it works is you don't

00:16:01,670 --> 00:16:06,410
consider you don't allow users to

00:16:03,529 --> 00:16:09,079
directly construct the type and you're

00:16:06,410 --> 00:16:11,449
only giving them a constructor and that

00:16:09,079 --> 00:16:16,370
constructor carries the bound that I

00:16:11,449 --> 00:16:19,010
want to express the what you can then do

00:16:16,370 --> 00:16:21,860
is later if you actually want to use

00:16:19,010 --> 00:16:23,870
this bound for example by putting in and

00:16:21,860 --> 00:16:26,990
putting an inspect method on that

00:16:23,870 --> 00:16:29,329
wrapper and you just need to restate it

00:16:26,990 --> 00:16:31,790
but because the compiler actually

00:16:29,329 --> 00:16:33,649
follows all those variables through the

00:16:31,790 --> 00:16:35,990
whole program it will still know the

00:16:33,649 --> 00:16:38,060
thing you put into the wrapper was a

00:16:35,990 --> 00:16:41,480
type that is debug and no one can

00:16:38,060 --> 00:16:45,699
effectively create any of those wrappers

00:16:41,480 --> 00:16:50,449
that that don't have this bound at all

00:16:45,699 --> 00:16:52,670
which them I can refactor this in the in

00:16:50,449 --> 00:16:57,850
a way by actually putting that bound

00:16:52,670 --> 00:16:57,850
again on the implementation instead of

00:16:58,540 --> 00:17:04,400
instead of on all the functions

00:17:00,800 --> 00:17:06,829
themselves that's for you to decide how

00:17:04,400 --> 00:17:09,559
you want to do this but this allows me

00:17:06,829 --> 00:17:11,240
to write the take inner function in a

00:17:09,559 --> 00:17:13,280
way where do I have to express this

00:17:11,240 --> 00:17:17,270
mount because at that point I don't care

00:17:13,280 --> 00:17:20,689
about it it's absolutely not new so

00:17:17,270 --> 00:17:23,809
where classes are primary refactoring

00:17:20,689 --> 00:17:28,339
targets if you want to change your

00:17:23,809 --> 00:17:29,900
program and make it more flexible more

00:17:28,339 --> 00:17:32,510
constrained depending on what your goal

00:17:29,900 --> 00:17:37,429
is your where classes are your primary

00:17:32,510 --> 00:17:39,320
refactoring target also don't start out

00:17:37,429 --> 00:17:42,590
extremely generic like don't try to

00:17:39,320 --> 00:17:44,020
write generic code out of the blue the

00:17:42,590 --> 00:17:46,429
pattern that I've shown in the beginning

00:17:44,020 --> 00:17:47,750
figuring out that two or three functions

00:17:46,429 --> 00:17:51,500
are basically the same

00:17:47,750 --> 00:17:55,340
and you probably can move them into into

00:17:51,500 --> 00:17:57,230
a generic function is a very useful one

00:17:55,340 --> 00:17:58,940
it's probably the thing that I've shown

00:17:57,230 --> 00:18:01,610
in the beginning you that's something

00:17:58,940 --> 00:18:03,789
you could write immediately but any kind

00:18:01,610 --> 00:18:06,710
of more complex system start simple

00:18:03,789 --> 00:18:12,169
start building up stop building into the

00:18:06,710 --> 00:18:14,600
generic into generic us also the finding

00:18:12,169 --> 00:18:17,990
the right level is important though

00:18:14,600 --> 00:18:21,140
that's a classic in programming a lot of

00:18:17,990 --> 00:18:23,600
application programming like outer edge

00:18:21,140 --> 00:18:25,580
application programming suffers from the

00:18:23,600 --> 00:18:28,880
fact that people try to do it to make it

00:18:25,580 --> 00:18:30,799
too generic so but for library authors

00:18:28,880 --> 00:18:33,590
for giving flexibility and for

00:18:30,799 --> 00:18:36,650
communicating intent to the outside this

00:18:33,590 --> 00:18:37,940
is very useful so always be aware where

00:18:36,650 --> 00:18:41,179
you are and whether that's actually

00:18:37,940 --> 00:18:42,860
needed and in the end you might have

00:18:41,179 --> 00:18:45,350
ended up writing terrible clauses like

00:18:42,860 --> 00:18:46,850
this this is from one of my current

00:18:45,350 --> 00:18:53,830
projects I'm going to refactor that

00:18:46,850 --> 00:18:57,799
tomorrow as literary work in progress ok

00:18:53,830 --> 00:19:00,080
some advanced examples drape penetrates

00:18:57,799 --> 00:19:02,840
and bounds can be used to express

00:19:00,080 --> 00:19:05,360
relationships between types and this

00:19:02,840 --> 00:19:06,919
becomes very useful this is one of my

00:19:05,360 --> 00:19:09,770
favorite Twitter accounts it's called a

00:19:06,919 --> 00:19:11,659
happy automata or vaguely reassuring

00:19:09,770 --> 00:19:15,530
state machines it generates state

00:19:11,659 --> 00:19:17,030
machines like this and I would like to

00:19:15,530 --> 00:19:20,960
write one of those state machines myself

00:19:17,030 --> 00:19:24,590
and state machines usually have States

00:19:20,960 --> 00:19:28,000
some of those states or terminals I skip

00:19:24,590 --> 00:19:30,830
having stop states in this example just

00:19:28,000 --> 00:19:32,750
because that will be wrote and would

00:19:30,830 --> 00:19:35,570
just make the example bigger but what I

00:19:32,750 --> 00:19:38,360
can have is I can write for example two

00:19:35,570 --> 00:19:43,429
traits the first one being transitioned

00:19:38,360 --> 00:19:48,080
to s another state expressing the work

00:19:43,429 --> 00:19:49,580
loss s needs to be a state self also

00:19:48,080 --> 00:19:52,250
needs to be a state so it can make a

00:19:49,580 --> 00:19:54,860
statement about the the type that this

00:19:52,250 --> 00:19:57,080
trait is going to be implemented on and

00:19:54,860 --> 00:20:00,320
give that a function called transition

00:19:57,080 --> 00:20:01,370
and transition will take the current

00:20:00,320 --> 00:20:03,970
state actually

00:20:01,370 --> 00:20:08,300
owning and thereby destroying it and

00:20:03,970 --> 00:20:11,150
return the next state and another trade

00:20:08,300 --> 00:20:13,250
terminate that can only be called in

00:20:11,150 --> 00:20:17,870
terminal states that just removes the

00:20:13,250 --> 00:20:20,000
state machine it calls it done and I can

00:20:17,870 --> 00:20:21,260
create myself three states the state

00:20:20,000 --> 00:20:23,210
machines that I'm creating here is

00:20:21,260 --> 00:20:25,820
basically there's a start

00:20:23,210 --> 00:20:27,790
there's a mid state that I can actually

00:20:25,820 --> 00:20:30,440
loop into again and then there's an end

00:20:27,790 --> 00:20:32,120
so I have start looping stops I

00:20:30,440 --> 00:20:33,920
implement state for them

00:20:32,120 --> 00:20:36,380
this is actually an empty trait it's

00:20:33,920 --> 00:20:37,850
just a marker to make the compiler know

00:20:36,380 --> 00:20:40,580
these types are states

00:20:37,850 --> 00:20:43,700
there's no again no functionality from

00:20:40,580 --> 00:20:47,450
that and stop is actually the terminal

00:20:43,700 --> 00:20:50,000
state that's where I'm ending and then I

00:20:47,450 --> 00:20:51,830
can implement transition to loop from

00:20:50,000 --> 00:20:54,200
start I can go from loop to start

00:20:51,830 --> 00:20:56,420
transition to loop for loop so I can go

00:20:54,200 --> 00:21:00,350
back into it again and transition to

00:20:56,420 --> 00:21:03,770
from to end for loop sorry there's an

00:21:00,350 --> 00:21:06,130
error on the slide and implement

00:21:03,770 --> 00:21:09,650
terminate for end so I can actually call

00:21:06,130 --> 00:21:11,570
so I can actually stop that means I

00:21:09,650 --> 00:21:13,370
cannot terminate that state machine if I

00:21:11,570 --> 00:21:14,600
have not ended up in the end state so I

00:21:13,370 --> 00:21:16,970
need to make sure that people are

00:21:14,600 --> 00:21:19,970
actually that the users of the state

00:21:16,970 --> 00:21:23,720
machine actually follow through and take

00:21:19,970 --> 00:21:27,110
this process to the end of the code here

00:21:23,720 --> 00:21:28,970
is simple this is one pattern how to

00:21:27,110 --> 00:21:31,430
write this there's a whole blog post on

00:21:28,970 --> 00:21:36,170
this by community member called hover

00:21:31,430 --> 00:21:37,610
bear and the setup and the programming

00:21:36,170 --> 00:21:39,590
of this is a little involved but the

00:21:37,610 --> 00:21:41,630
usage is rather straightforward the

00:21:39,590 --> 00:21:44,030
reason why I have to type the left side

00:21:41,630 --> 00:21:45,620
so I need to actually Express what the

00:21:44,030 --> 00:21:47,210
next set is going to be is exactly

00:21:45,620 --> 00:21:49,370
because I have this loop state where it

00:21:47,210 --> 00:21:51,050
can either loop again or go to the end

00:21:49,370 --> 00:21:53,480
state and this is something where I

00:21:51,050 --> 00:21:56,090
actually have to tell the type checker

00:21:53,480 --> 00:21:58,490
I intend to be this this to be the next

00:21:56,090 --> 00:22:01,220
state the two comments in the middle

00:21:58,490 --> 00:22:02,870
those wouldn't compile so if I would try

00:22:01,220 --> 00:22:04,460
to terminate why I'm still in the loop

00:22:02,870 --> 00:22:07,760
state that doesn't work because Luke

00:22:04,460 --> 00:22:10,340
doesn't implement terminate and if I

00:22:07,760 --> 00:22:13,860
would try to transition from the loop

00:22:10,340 --> 00:22:21,870
state again to start that doesn't work

00:22:13,860 --> 00:22:26,520
this that start modifying second example

00:22:21,870 --> 00:22:28,920
that comes also out of my work is how

00:22:26,520 --> 00:22:31,110
about like talking about what's stored

00:22:28,920 --> 00:22:36,470
in databases let's say I have a storage

00:22:31,110 --> 00:22:39,830
trade my storage can be queried for

00:22:36,470 --> 00:22:43,110
example for a model ship that takes

00:22:39,830 --> 00:22:48,330
storage by that both the storage but I

00:22:43,110 --> 00:22:50,970
also give it an ID so exam it takes the

00:22:48,330 --> 00:22:55,650
storage and reach out the model under

00:22:50,970 --> 00:22:58,860
this ID the problem with this definition

00:22:55,650 --> 00:23:02,690
is I could try to get anything out of

00:22:58,860 --> 00:23:06,059
that I could try to read strings vectors

00:23:02,690 --> 00:23:08,070
mutexes whatever because every type is

00:23:06,059 --> 00:23:10,890
valid to fill that variable and this is

00:23:08,070 --> 00:23:15,090
what constraining gives me constrain to

00:23:10,890 --> 00:23:16,850
the things that are meaningful and I can

00:23:15,090 --> 00:23:21,510
define a coat right here that says

00:23:16,850 --> 00:23:25,920
stores model and I can also constrain

00:23:21,510 --> 00:23:27,660
the stores model trade to it can only be

00:23:25,920 --> 00:23:30,960
different they only be implemented on

00:23:27,660 --> 00:23:33,450
storages then I can extend my function

00:23:30,960 --> 00:23:35,490
with where self actually stores that

00:23:33,450 --> 00:23:37,290
model and now I've defined a function

00:23:35,490 --> 00:23:40,770
that communicates you can try to query

00:23:37,290 --> 00:23:44,070
models out of this but only if it

00:23:40,770 --> 00:23:46,559
actually stores them and you force the

00:23:44,070 --> 00:23:48,510
implementer to actually declare what's

00:23:46,559 --> 00:23:52,290
stored here to declare that to the

00:23:48,510 --> 00:23:54,360
component so for example I can have a

00:23:52,290 --> 00:23:57,990
users database this uses database

00:23:54,360 --> 00:24:00,030
implements storage by what do I know an

00:23:57,990 --> 00:24:05,130
SQLite back database source Cresson

00:24:00,030 --> 00:24:07,470
whatever I have a user model and for

00:24:05,130 --> 00:24:09,510
example another Avatar model so they can

00:24:07,470 --> 00:24:12,000
have users and davit house in the same

00:24:09,510 --> 00:24:14,520
database and then I implement implements

00:24:12,000 --> 00:24:17,309
stores user and implements stores avatar

00:24:14,520 --> 00:24:21,570
for users database and this becomes

00:24:17,309 --> 00:24:25,500
pretty natural it so having you can only

00:24:21,570 --> 00:24:27,800
query things where the storage actually

00:24:25,500 --> 00:24:27,800
stores

00:24:28,639 --> 00:24:35,970
and in the end I have things I can write

00:24:33,299 --> 00:24:38,519
a program that boil down looks like this

00:24:35,970 --> 00:24:41,970
I can have I can connect to my database

00:24:38,519 --> 00:24:44,610
I can try to query it um I actually have

00:24:41,970 --> 00:24:47,129
to state at this point what model I

00:24:44,610 --> 00:24:48,840
actually want to query out of it so here

00:24:47,129 --> 00:24:50,909
the type checker won't help me because

00:24:48,840 --> 00:24:53,309
I've actually said I want to have

00:24:50,909 --> 00:24:57,779
multiple options and I need to decide so

00:24:53,309 --> 00:25:00,330
I'm saying query the user out of that

00:24:57,779 --> 00:25:02,580
database but if I would try to query a

00:25:00,330 --> 00:25:04,470
string out of it or any kind of other

00:25:02,580 --> 00:25:07,559
type it will tell me no I actually don't

00:25:04,470 --> 00:25:10,860
store this the error message in this

00:25:07,559 --> 00:25:13,259
case would be that the storage actually

00:25:10,860 --> 00:25:16,110
doesn't implement and the function

00:25:13,259 --> 00:25:18,679
exists but it doesn't implement the the

00:25:16,110 --> 00:25:18,679
right bounds

00:25:19,190 --> 00:25:24,840
so the conclusion out of all of this I'm

00:25:22,499 --> 00:25:27,389
getting comfortable with all the stuff

00:25:24,840 --> 00:25:30,269
that where clauses give you is important

00:25:27,389 --> 00:25:32,549
take it slow though so don't start

00:25:30,269 --> 00:25:36,960
writing big ones just right out of the

00:25:32,549 --> 00:25:40,679
door exactly picking which constraints

00:25:36,960 --> 00:25:43,169
you need where is key and spending some

00:25:40,679 --> 00:25:46,259
time and actually figuring out what you

00:25:43,169 --> 00:25:48,480
need potentially over constraining first

00:25:46,259 --> 00:25:51,179
later maybe removing some of the

00:25:48,480 --> 00:25:53,070
constraints may help there's also an API

00:25:51,179 --> 00:25:57,659
concern around this if you further

00:25:53,070 --> 00:26:00,690
constraint a where clause you are

00:25:57,659 --> 00:26:02,369
breaking you previously committed API if

00:26:00,690 --> 00:26:04,889
you're widening it if you're allowing

00:26:02,369 --> 00:26:06,749
more people to call it or this to be

00:26:04,889 --> 00:26:10,049
called with more types you're not

00:26:06,749 --> 00:26:12,840
breaking the external API and there are

00:26:10,049 --> 00:26:16,139
creative patterns of interplay with

00:26:12,840 --> 00:26:18,809
which you can start declaring through

00:26:16,139 --> 00:26:23,700
the compiler how your systems work to be

00:26:18,809 --> 00:26:25,050
found in all that yeah thank you

00:26:23,700 --> 00:26:36,800
that's it

00:26:25,050 --> 00:26:39,849
[Applause]

00:26:36,800 --> 00:26:39,849

YouTube URL: https://www.youtube.com/watch?v=jSpio0x7024


