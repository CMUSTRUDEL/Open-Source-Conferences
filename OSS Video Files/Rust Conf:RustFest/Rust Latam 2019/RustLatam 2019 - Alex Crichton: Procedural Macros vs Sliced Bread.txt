Title: RustLatam 2019 - Alex Crichton: Procedural Macros vs Sliced Bread
Publication date: 2019-04-21
Playlist: Rust Latam 2019
Description: 
	Alex will try to convince us that procedural macros are the best thing since sliced bread. With "macros 1.2" now on stable Rust there's no better time to discover the world of procedural macros and what they can do for us.

We've already seen the power of derive macros shoot Serde to one of the most popular crates in Rust. With attribute macros we can go even further with lightweight annotations powering frameworks. And finally with procedural macros the sky is the limit!

Let's learn about tips, tricks, and usage of the procedural macro world!

Follow us on Twitter: https://twitter.com/rustlatamconf
Captions: 
	00:00:06,560 --> 00:00:11,370
all right good afternoon everyone my

00:00:09,059 --> 00:00:13,559
name is Alex and today I have one goal

00:00:11,370 --> 00:00:16,560
which is to convince you that procedure

00:00:13,559 --> 00:00:17,880
macros are better than sliced bread now

00:00:16,560 --> 00:00:20,279
you might not think that's actually that

00:00:17,880 --> 00:00:21,960
much of a kind of bar to live up to but

00:00:20,279 --> 00:00:23,460
there's a very common phrase saying that

00:00:21,960 --> 00:00:24,150
this is the best thing since sliced

00:00:23,460 --> 00:00:26,220
bread

00:00:24,150 --> 00:00:27,750
and so this it's actually it's it's you

00:00:26,220 --> 00:00:29,130
so often a lot of things are compared to

00:00:27,750 --> 00:00:31,859
sliced bread I figured I'd continue

00:00:29,130 --> 00:00:33,480
continue the tradition so to start off

00:00:31,859 --> 00:00:34,890
I'd like to tell you what the rise of

00:00:33,480 --> 00:00:37,260
procedure macros and kind of a little

00:00:34,890 --> 00:00:39,180
bit of history of how we came from the

00:00:37,260 --> 00:00:41,430
dark ages of rust 1.0 it's a procedure

00:00:39,180 --> 00:00:42,809
macros that we have today the first

00:00:41,430 --> 00:00:45,390
thing you'll notice is that back around

00:00:42,809 --> 00:00:47,730
at January 2014 this is about a year

00:00:45,390 --> 00:00:49,530
before 1.0 was released we have this

00:00:47,730 --> 00:00:52,260
poor request number the infamous one one

00:00:49,530 --> 00:00:54,899
one five one land for loadable syntax

00:00:52,260 --> 00:00:56,850
extensions now this was the first foray

00:00:54,899 --> 00:00:59,789
that we've used to try and have

00:00:56,850 --> 00:01:02,399
procedurally loaded defined on crates io

00:00:59,789 --> 00:01:04,229
externally defined loadable libraries

00:01:02,399 --> 00:01:06,390
that you can modify the syntax and the

00:01:04,229 --> 00:01:07,560
compiler now it turns out that

00:01:06,390 --> 00:01:10,320
immediately after that we kind of

00:01:07,560 --> 00:01:12,900
regretted landing that but the idea is

00:01:10,320 --> 00:01:14,490
that this was kind of the proving ground

00:01:12,900 --> 00:01:16,799
the staging ground which we ended up

00:01:14,490 --> 00:01:18,720
using to fuel a lot of the later

00:01:16,799 --> 00:01:20,670
decisions about procedure macros and so

00:01:18,720 --> 00:01:22,860
this was some critical test cases that

00:01:20,670 --> 00:01:25,049
we had along the way to kind of inform

00:01:22,860 --> 00:01:27,150
us as to how procedure macros are used

00:01:25,049 --> 00:01:29,189
how they're most commonly expected to be

00:01:27,150 --> 00:01:30,630
used in this ecosystem how to build them

00:01:29,189 --> 00:01:32,790
make them efficient all these kinds of

00:01:30,630 --> 00:01:34,380
nitty-gritty details and so although we

00:01:32,790 --> 00:01:35,729
have still have lots of legacy support

00:01:34,380 --> 00:01:37,890
for this and it's kind of a pain to

00:01:35,729 --> 00:01:39,630
support these older syntax extensions

00:01:37,890 --> 00:01:42,540
they were vital in getting today's

00:01:39,630 --> 00:01:44,880
system currently stabilized the next

00:01:42,540 --> 00:01:46,619
thing was these two RFC's happening in

00:01:44,880 --> 00:01:49,079
quick succession which is starting to

00:01:46,619 --> 00:01:50,970
formally design the macro system this

00:01:49,079 --> 00:01:53,100
happened about a year after 1.0 and we

00:01:50,970 --> 00:01:55,079
had these two one for modularizing the

00:01:53,100 --> 00:01:57,479
macro system and the one for actually

00:01:55,079 --> 00:01:58,979
specifying what a procedure macro is and

00:01:57,479 --> 00:02:00,990
so I'll be kind of going into more

00:01:58,979 --> 00:02:02,850
details about what's going on here but

00:02:00,990 --> 00:02:04,380
you can see how years ago is when we

00:02:02,850 --> 00:02:06,390
actually started the stabilization

00:02:04,380 --> 00:02:07,829
process and specification process for

00:02:06,390 --> 00:02:10,649
the macros that we actually have today

00:02:07,829 --> 00:02:12,450
now they have been tweaked since then

00:02:10,649 --> 00:02:13,440
since they were designed back then but

00:02:12,450 --> 00:02:17,490
they're mostly

00:02:13,440 --> 00:02:20,070
the same in spirit next up we have in

00:02:17,490 --> 00:02:23,040
mid-2016 the first stabilization of

00:02:20,070 --> 00:02:24,870
macros with derive macros so many of you

00:02:23,040 --> 00:02:26,850
might know this is when Surrey first

00:02:24,870 --> 00:02:28,260
started to compile on stable rest and

00:02:26,850 --> 00:02:30,750
this was a massive boon for the

00:02:28,260 --> 00:02:32,670
ecosystem as I imagine everyone who's

00:02:30,750 --> 00:02:35,280
used rust very very quickly runs in the

00:02:32,670 --> 00:02:37,980
30 and the 30 is so reliant on derived

00:02:35,280 --> 00:02:40,380
macros for its functionality and then

00:02:37,980 --> 00:02:43,290
the last thing was when in about April

00:02:40,380 --> 00:02:45,240
2018 so a kind of middle beginning of

00:02:43,290 --> 00:02:47,520
last year we started having a call for

00:02:45,240 --> 00:02:49,650
stabilization for more macros other than

00:02:47,520 --> 00:02:51,660
just pound arrives and so this was

00:02:49,650 --> 00:02:53,340
attribute macros and function like

00:02:51,660 --> 00:02:55,770
macros and so these ended up actually

00:02:53,340 --> 00:02:57,510
being stabilized in October of 2018 and

00:02:55,770 --> 00:02:59,100
so this is kind of where we are today

00:02:57,510 --> 00:03:00,780
and I'm gonna be talking a little bit

00:02:59,100 --> 00:03:02,460
more about kind of what the current

00:03:00,780 --> 00:03:05,250
state of macros are and going into all

00:03:02,460 --> 00:03:07,080
the attributes to rise and functions so

00:03:05,250 --> 00:03:08,610
it's only fair that we talk about the

00:03:07,080 --> 00:03:10,980
rise of sliced bread as it's the

00:03:08,610 --> 00:03:12,660
comparison as well and so most of this

00:03:10,980 --> 00:03:15,450
is copied from Wikipedia but there's two

00:03:12,660 --> 00:03:17,370
notable points one is the inventor of

00:03:15,450 --> 00:03:19,350
sliced bread is from Iowa I also came

00:03:17,370 --> 00:03:21,450
from Iowa so I'm very proud of that I

00:03:19,350 --> 00:03:23,340
did not know that before I anyway the

00:03:21,450 --> 00:03:25,709
next thing is that in World War 2 the

00:03:23,340 --> 00:03:27,570
u.s. banned sliced bread because it was

00:03:25,709 --> 00:03:28,860
so difficult to produce but then they

00:03:27,570 --> 00:03:31,320
had to undo that because it was too

00:03:28,860 --> 00:03:33,360
popular and everyone revolted alright

00:03:31,320 --> 00:03:34,650
back to the actual technical content I'm

00:03:33,360 --> 00:03:37,320
gonna first tell you a little bit about

00:03:34,650 --> 00:03:38,910
what a procedure macro is now if you are

00:03:37,320 --> 00:03:40,770
at David's workshop yesterday this is

00:03:38,910 --> 00:03:42,480
probably going to be a bit of a review

00:03:40,770 --> 00:03:44,550
but it'll kind of get us all on the same

00:03:42,480 --> 00:03:46,019
page and then I want to talk a little

00:03:44,550 --> 00:03:48,330
bit more about how we actually write

00:03:46,019 --> 00:03:49,739
these procedure macros so not just what

00:03:48,330 --> 00:03:51,570
they are but how do you actually

00:03:49,739 --> 00:03:53,820
functionally use them in the ecosystem

00:03:51,570 --> 00:03:54,930
and then finally some fun stuff coming

00:03:53,820 --> 00:03:58,769
down the pike and just some cool

00:03:54,930 --> 00:04:00,870
examples of macros so all right macros

00:03:58,769 --> 00:04:03,239
come in three primary forms in the

00:04:00,870 --> 00:04:05,340
compiler the first of these is function

00:04:03,239 --> 00:04:06,690
like they are denoted by this bang and

00:04:05,340 --> 00:04:08,250
then there's delimited sides and then

00:04:06,690 --> 00:04:09,989
one of the most common ones is print 'ln

00:04:08,250 --> 00:04:11,550
now print 'ln isn't literally procedure

00:04:09,989 --> 00:04:14,190
macro but it's the same thing in spirit

00:04:11,550 --> 00:04:16,739
the next is the very familiar derived

00:04:14,190 --> 00:04:18,090
macros and so this is everything to do

00:04:16,739 --> 00:04:20,130
with Sergey and everything to do with

00:04:18,090 --> 00:04:21,780
every other form of derive on the kraits

00:04:20,130 --> 00:04:23,970
Iuka system and it's a sort of

00:04:21,780 --> 00:04:26,020
annotations for structs and enums to

00:04:23,970 --> 00:04:28,960
extend with various functionality

00:04:26,020 --> 00:04:30,490
and the last is attribute macros now

00:04:28,960 --> 00:04:31,690
we've heard some talk of isin bindings

00:04:30,490 --> 00:04:32,889
and I'm not gonna go too much into the

00:04:31,690 --> 00:04:35,380
details about that but this is

00:04:32,889 --> 00:04:37,960
effectively a macro that is defined on

00:04:35,380 --> 00:04:41,139
crates IO and as a library if I'd a

00:04:37,960 --> 00:04:42,729
definition of how it works so to

00:04:41,139 --> 00:04:46,180
actually start out by writing in a proc

00:04:42,729 --> 00:04:47,470
macro you have to tell both cargo and

00:04:46,180 --> 00:04:49,090
the compiler what you're doing because

00:04:47,470 --> 00:04:50,740
the coop the macro has to be compiled a

00:04:49,090 --> 00:04:51,759
little bit differently especially when

00:04:50,740 --> 00:04:53,319
you're cross compiling into all that

00:04:51,759 --> 00:04:55,690
crazy stuff and so all you have to do is

00:04:53,319 --> 00:04:57,580
open up the Lib section of your carbo

00:04:55,690 --> 00:04:58,960
tamil right in proc macro equals true

00:04:57,580 --> 00:05:00,520
and you're good to go now you're ready

00:04:58,960 --> 00:05:03,250
to start writing some procedure macros

00:05:00,520 --> 00:05:05,110
if you're writing a print Lin macro or a

00:05:03,250 --> 00:05:07,300
function like macro we're going to use

00:05:05,110 --> 00:05:09,159
this pound proc macro attribute and then

00:05:07,300 --> 00:05:10,599
take this weird token stream thing and

00:05:09,159 --> 00:05:12,940
return this weird token stream things

00:05:10,599 --> 00:05:14,979
and the general goal here is that we

00:05:12,940 --> 00:05:17,050
have this invocation like print land of

00:05:14,979 --> 00:05:19,030
a wheat bread and we want to transform

00:05:17,050 --> 00:05:21,069
that and completely replace it with some

00:05:19,030 --> 00:05:22,539
other ugly expanded thing that the

00:05:21,069 --> 00:05:23,650
contents don't matter too much but it's

00:05:22,539 --> 00:05:26,080
something the users not going to write

00:05:23,650 --> 00:05:27,759
and have to worry too much about and so

00:05:26,080 --> 00:05:29,440
to kind of connect all the dots here we

00:05:27,759 --> 00:05:31,150
can see the function name of the

00:05:29,440 --> 00:05:33,880
procedure macro is actually connected to

00:05:31,150 --> 00:05:35,530
the macro itself the input is what's

00:05:33,880 --> 00:05:37,240
inside of those parentheses and so we're

00:05:35,530 --> 00:05:39,580
gonna get just the quote wheat for this

00:05:37,240 --> 00:05:40,960
one macro invocation and then the output

00:05:39,580 --> 00:05:43,120
is going to replace the entire

00:05:40,960 --> 00:05:44,740
invocation and it has to contain all

00:05:43,120 --> 00:05:46,740
those tokens that stood out print for

00:05:44,740 --> 00:05:50,080
minorities of all that good stuff

00:05:46,740 --> 00:05:52,570
the next of these is derive macros and

00:05:50,080 --> 00:05:54,250
so this is an example of how sir you

00:05:52,570 --> 00:05:56,229
might actually be defining their derive

00:05:54,250 --> 00:05:57,460
macro inside there we can see it's a

00:05:56,229 --> 00:05:59,650
little bit different where it's not just

00:05:57,460 --> 00:06:01,270
proc macro but it's proc macro derive

00:05:59,650 --> 00:06:03,610
and then the name of looks in there and

00:06:01,270 --> 00:06:06,009
the input and output is also slightly

00:06:03,610 --> 00:06:08,620
different here as well so a derive macro

00:06:06,009 --> 00:06:10,840
is only only ever used to annotate

00:06:08,620 --> 00:06:12,250
either a struct or an enum and so

00:06:10,840 --> 00:06:15,099
that'll be the input here and the output

00:06:12,250 --> 00:06:16,419
is something that we append so we can

00:06:15,099 --> 00:06:18,550
kind of see the connections here where

00:06:16,419 --> 00:06:19,780
the name is specified on the attribute

00:06:18,550 --> 00:06:22,180
the name of the function action doesn't

00:06:19,780 --> 00:06:24,190
matter too much the input is just the

00:06:22,180 --> 00:06:26,650
struct not the attribute with it and

00:06:24,190 --> 00:06:28,900
then the output does not include the

00:06:26,650 --> 00:06:30,550
struct it's just this one in palak and

00:06:28,900 --> 00:06:32,919
so the main thing here is that with a

00:06:30,550 --> 00:06:34,479
derived macro you cannot modify the

00:06:32,919 --> 00:06:36,250
structure of the enum you cannot change

00:06:34,479 --> 00:06:38,270
what's happening you can only append to

00:06:36,250 --> 00:06:40,040
it typically by adding trade imple

00:06:38,270 --> 00:06:41,570
or other items just various various

00:06:40,040 --> 00:06:43,220
other syntactical constructs that you

00:06:41,570 --> 00:06:46,490
want to associate it with your derived

00:06:43,220 --> 00:06:48,500
macro at that point the next forum is

00:06:46,490 --> 00:06:49,850
the last forum is attribute macros which

00:06:48,500 --> 00:06:51,830
is like kind of like Weizen bind chin

00:06:49,850 --> 00:06:52,910
and this is again slightly different

00:06:51,830 --> 00:06:54,980
from the previous ones where we have

00:06:52,910 --> 00:06:56,780
proc macro attribute as opposed to the

00:06:54,980 --> 00:06:58,880
previous forums and there's also two

00:06:56,780 --> 00:07:00,980
inputs here as well see in a second and

00:06:58,880 --> 00:07:02,450
so the idea here is that we're starting

00:07:00,980 --> 00:07:04,310
with this bake function and we're gonna

00:07:02,450 --> 00:07:06,620
annotate it with a wizened bun in start

00:07:04,310 --> 00:07:08,450
and then we want to transform that by

00:07:06,620 --> 00:07:09,680
generating some goop which you don't

00:07:08,450 --> 00:07:11,900
have to worry so much about it's got a

00:07:09,680 --> 00:07:14,330
bunch of crazy stuff plus the original

00:07:11,900 --> 00:07:15,680
item itself right there and we start

00:07:14,330 --> 00:07:17,390
looking at the connections we can see

00:07:15,680 --> 00:07:18,890
kind of like with function like macros

00:07:17,390 --> 00:07:20,900
the name of the function is connected to

00:07:18,890 --> 00:07:21,770
the name of the attribute and then the

00:07:20,900 --> 00:07:23,240
args

00:07:21,770 --> 00:07:25,130
so this first argument is what's

00:07:23,240 --> 00:07:27,260
provided in parentheses to the argument

00:07:25,130 --> 00:07:29,060
to the attribute itself and so here ours

00:07:27,260 --> 00:07:30,620
is just going to be start and nothing

00:07:29,060 --> 00:07:32,090
else and if you don't you don't have to

00:07:30,620 --> 00:07:35,000
provide the parentheses it'll just be an

00:07:32,090 --> 00:07:36,950
empty token stream the input itself is

00:07:35,000 --> 00:07:38,900
the item with which you are annotating

00:07:36,950 --> 00:07:41,360
and so it's this entire function bake

00:07:38,900 --> 00:07:43,520
and all the contents inside there now

00:07:41,360 --> 00:07:45,410
the output is going to replace the

00:07:43,520 --> 00:07:47,510
invocation so kind of like with function

00:07:45,410 --> 00:07:49,250
like macros if we want the bake function

00:07:47,510 --> 00:07:51,050
to persist we got to make sure to put it

00:07:49,250 --> 00:07:53,240
in the output as well so we can not only

00:07:51,050 --> 00:07:55,640
have our generated goop but we also have

00:07:53,240 --> 00:07:59,870
the bake function serialize straight

00:07:55,640 --> 00:08:02,090
into the output so that's kind of the

00:07:59,870 --> 00:08:03,470
interface that we have with these three

00:08:02,090 --> 00:08:05,120
kinds of macros and the next thing you

00:08:03,470 --> 00:08:06,770
might be wondering is what's this token

00:08:05,120 --> 00:08:09,440
stream thing what is the I is the input

00:08:06,770 --> 00:08:11,450
this weird token thing and so a token

00:08:09,440 --> 00:08:14,380
stream is sort of the lexical foundation

00:08:11,450 --> 00:08:17,060
for all rest syntax and this is where it

00:08:14,380 --> 00:08:18,500
includes atomic tokens inside of it's

00:08:17,060 --> 00:08:21,460
not a string it's not some other

00:08:18,500 --> 00:08:23,690
serialized form but it's kind of a parse

00:08:21,460 --> 00:08:25,820
representation in memory of each token

00:08:23,690 --> 00:08:27,470
that you passed in and this is all

00:08:25,820 --> 00:08:28,880
defined in the compiler it's completely

00:08:27,470 --> 00:08:30,500
unstable internally you can use it

00:08:28,880 --> 00:08:32,900
stable externally but it's all kind of a

00:08:30,500 --> 00:08:34,250
bunch of weird details but you can kind

00:08:32,900 --> 00:08:37,010
of sufficiently think about this as a

00:08:34,250 --> 00:08:39,920
cheaply cloneable hence the RC here

00:08:37,010 --> 00:08:41,360
list and so it's not literally that

00:08:39,920 --> 00:08:42,710
eternally but you can very cheap to

00:08:41,360 --> 00:08:44,450
clone it you could iterate over it and

00:08:42,710 --> 00:08:45,740
see what's inside now the really

00:08:44,450 --> 00:08:47,570
interesting part here is what's actually

00:08:45,740 --> 00:08:49,960
inside of it which is this token tree

00:08:47,570 --> 00:08:52,030
and so the tree aspect

00:08:49,960 --> 00:08:54,460
comes from this first area variant

00:08:52,030 --> 00:08:56,020
called group but I'll go ahead go over

00:08:54,460 --> 00:08:58,900
that in a second and suffice to say that

00:08:56,020 --> 00:09:01,390
these four variants these four pieces of

00:08:58,900 --> 00:09:03,880
syntax are enough to capture all of Russ

00:09:01,390 --> 00:09:08,140
syntax and and a bunch more syntax as

00:09:03,880 --> 00:09:10,210
well so I want to break down this derive

00:09:08,140 --> 00:09:12,670
example and show you some what each of

00:09:10,210 --> 00:09:14,170
these syntax of variants corresponds to

00:09:12,670 --> 00:09:16,600
in this example and so we have this

00:09:14,170 --> 00:09:18,250
derived macro which is 30 and then a

00:09:16,600 --> 00:09:20,950
couple of 30 attributes and some fields

00:09:18,250 --> 00:09:24,100
inside there so first up we have a group

00:09:20,950 --> 00:09:26,620
a group represents a delimited set of

00:09:24,100 --> 00:09:28,450
tokens by a balanced delimiter so these

00:09:26,620 --> 00:09:31,240
are parentheses or brackets or curly

00:09:28,450 --> 00:09:33,760
braces and so here we have three we have

00:09:31,240 --> 00:09:35,950
just the bracket on Surti the

00:09:33,760 --> 00:09:37,570
parentheses on 30 and then the curly

00:09:35,950 --> 00:09:39,520
braces on the struct itself and so

00:09:37,570 --> 00:09:41,500
that's kind of the nesting form here and

00:09:39,520 --> 00:09:43,720
this is why it's a token tree as opposed

00:09:41,500 --> 00:09:45,550
to just a token or a token list is that

00:09:43,720 --> 00:09:47,500
this is a nesting where the group

00:09:45,550 --> 00:09:50,050
internally has another token stream of

00:09:47,500 --> 00:09:52,360
what's inside there the next are

00:09:50,050 --> 00:09:53,980
identifiers and so these are key words

00:09:52,360 --> 00:09:55,690
these are variable names these are

00:09:53,980 --> 00:09:57,280
struck names these are type names this

00:09:55,690 --> 00:09:59,980
is just kind of any valid rust'

00:09:57,280 --> 00:10:02,290
identifier which is various rules for

00:09:59,980 --> 00:10:04,810
that but so here we have 30 rename all

00:10:02,290 --> 00:10:07,240
structs the fields the types all those

00:10:04,810 --> 00:10:08,830
are identifiers which are kind of they

00:10:07,240 --> 00:10:12,010
have no internal spaces they're just one

00:10:08,830 --> 00:10:13,660
valid rust' identifier nice to me have

00:10:12,010 --> 00:10:15,280
punctuation which is kind of all the

00:10:13,660 --> 00:10:17,860
little bits of syntax here and there

00:10:15,280 --> 00:10:20,620
like commas and pounds and colons and

00:10:17,860 --> 00:10:22,630
equals and critically a punctuate piece

00:10:20,620 --> 00:10:24,670
of punctuation is one character large

00:10:22,630 --> 00:10:27,400
and so it's just one utf-8 character or

00:10:24,670 --> 00:10:29,710
one Unicode character and this although

00:10:27,400 --> 00:10:31,990
internally if you have like a shift left

00:10:29,710 --> 00:10:33,850
which has two less than signs that'll be

00:10:31,990 --> 00:10:35,770
two different pieces of punctuation and

00:10:33,850 --> 00:10:38,290
I'm not gonna go too much in details we

00:10:35,770 --> 00:10:40,060
can all figure that out later and the

00:10:38,290 --> 00:10:42,370
final one here is literals and so these

00:10:40,060 --> 00:10:44,110
are numbers these are strings in this

00:10:42,370 --> 00:10:47,020
case we could have byte strings we could

00:10:44,110 --> 00:10:49,240
have arrays well anyway so those are

00:10:47,020 --> 00:10:51,580
kind of the bare values which you'll

00:10:49,240 --> 00:10:52,840
kind of which are compiled in a static

00:10:51,580 --> 00:10:56,320
memory and kind of say different class

00:10:52,840 --> 00:10:57,850
of syntax so these four pieces are what

00:10:56,320 --> 00:10:59,410
encompasses everything that you will

00:10:57,850 --> 00:11:01,459
receive in your procedure macro you'll

00:10:59,410 --> 00:11:03,230
be getting a giant list of all that and

00:11:01,459 --> 00:11:07,040
expected to produce a giant list of all

00:11:03,230 --> 00:11:08,869
that and so to kind of talk another

00:11:07,040 --> 00:11:10,399
feature about the macula system that

00:11:08,869 --> 00:11:12,199
we've been developing is the fact that

00:11:10,399 --> 00:11:15,369
we've been modularizing all of these as

00:11:12,199 --> 00:11:18,649
well so before we actually had stable

00:11:15,369 --> 00:11:20,480
macros in 2018 we had to use these funky

00:11:18,649 --> 00:11:22,009
macro use attributes we had to use other

00:11:20,480 --> 00:11:24,410
funky attributes they had kind of weird

00:11:22,009 --> 00:11:26,119
scoping rules and so with the recent

00:11:24,410 --> 00:11:28,610
push for a stabilization of macros we've

00:11:26,119 --> 00:11:30,619
added new support in the entire module

00:11:28,610 --> 00:11:31,910
system the correctly scope these work

00:11:30,619 --> 00:11:33,499
through the same module system that

00:11:31,910 --> 00:11:35,869
you're kind of used to and so we can

00:11:33,499 --> 00:11:38,089
bring in print Lin serialized wise and

00:11:35,869 --> 00:11:40,129
bind gen we can if you re export and so

00:11:38,089 --> 00:11:42,110
typically as I was saying you have a

00:11:40,129 --> 00:11:44,569
dedicated crate for defining a procedure

00:11:42,110 --> 00:11:46,279
macro but you might re-export it from a

00:11:44,569 --> 00:11:48,079
different crane so the wise and bind gen

00:11:46,279 --> 00:11:49,429
create will react sport this from the

00:11:48,079 --> 00:11:52,309
wise and bind in macro create kind of

00:11:49,429 --> 00:11:54,889
internally and one of the nice aspects

00:11:52,309 --> 00:11:57,170
of this is the macros of their own

00:11:54,889 --> 00:12:00,050
namespace and so this means that you can

00:11:57,170 --> 00:12:02,240
bring in multiple values or types went

00:12:00,050 --> 00:12:04,459
into scope at the same time so when you

00:12:02,240 --> 00:12:06,199
say use Sur to serialize that's actually

00:12:04,459 --> 00:12:08,119
bringing into scope both the tree and

00:12:06,199 --> 00:12:09,439
the macro so it kind of cuts down on the

00:12:08,119 --> 00:12:10,970
number of imports that you have to write

00:12:09,439 --> 00:12:12,199
there's also kind of a nice thing for

00:12:10,970 --> 00:12:13,879
library authors where if you have

00:12:12,199 --> 00:12:16,189
everything line up very nicely trait

00:12:13,879 --> 00:12:17,480
wise and derive wise then you can have

00:12:16,189 --> 00:12:20,720
one import to bring everything into

00:12:17,480 --> 00:12:22,610
scope all at once sorry

00:12:20,720 --> 00:12:24,559
that was a little bit about a whirlwind

00:12:22,610 --> 00:12:26,240
tour of what procedure macros are and so

00:12:24,559 --> 00:12:27,559
let's dive into some internal details of

00:12:26,240 --> 00:12:29,299
how you would actually write these

00:12:27,559 --> 00:12:31,670
macros and generate these giant lists

00:12:29,299 --> 00:12:33,259
and parse these giant lists and so our

00:12:31,670 --> 00:12:34,939
problem here is we have this print Lin

00:12:33,259 --> 00:12:37,040
macro we want to write we have this

00:12:34,939 --> 00:12:38,480
input which is some list of tokens just

00:12:37,040 --> 00:12:39,829
some list of syntax that we have to

00:12:38,480 --> 00:12:42,410
figure out and we have to produce this

00:12:39,829 --> 00:12:43,910
stuff I Oh printing whatnot but

00:12:42,410 --> 00:12:46,369
internally it's kind of hard to work

00:12:43,910 --> 00:12:48,259
with all that so what we morally want to

00:12:46,369 --> 00:12:49,970
do here is have kind of a parsed

00:12:48,259 --> 00:12:52,879
representation of what we might be

00:12:49,970 --> 00:12:54,379
receiving and so if we say printing some

00:12:52,879 --> 00:12:56,569
number of lows then we want kind of the

00:12:54,379 --> 00:12:57,860
format string to be parsed directly into

00:12:56,569 --> 00:13:00,049
memory and then we also want some

00:12:57,860 --> 00:13:01,670
expressions now we don't really know

00:13:00,049 --> 00:13:03,199
where this expression type is coming

00:13:01,670 --> 00:13:04,549
from but we want kind of arbitrary rest

00:13:03,199 --> 00:13:06,889
expressions because it won't rust to be

00:13:04,549 --> 00:13:08,660
very familiar at that point and then so

00:13:06,889 --> 00:13:10,129
after we actually parse it we might do

00:13:08,660 --> 00:13:12,139
some validation to make sure that the

00:13:10,129 --> 00:13:13,579
number of curly braces placeholders

00:13:12,139 --> 00:13:14,410
matches the number of arguments a path

00:13:13,579 --> 00:13:15,459
soon

00:13:14,410 --> 00:13:17,199
and then finally we want to actually

00:13:15,459 --> 00:13:19,959
expand it to generate that stood I hope

00:13:17,199 --> 00:13:21,730
ritalin business that we were seeing so

00:13:19,959 --> 00:13:23,620
it turns out the crates I of ecosystem

00:13:21,730 --> 00:13:26,079
has a number of very handy crates for

00:13:23,620 --> 00:13:28,600
doing exactly this the first of which is

00:13:26,079 --> 00:13:30,399
a crate called sin and so what sin does

00:13:28,600 --> 00:13:32,920
is it's providing a lot of default

00:13:30,399 --> 00:13:34,839
parsers and default types that matches a

00:13:32,920 --> 00:13:36,939
lot of rust syntax and so we can just

00:13:34,839 --> 00:13:40,060
replace this expert with a literal sin

00:13:36,939 --> 00:13:41,500
expert to find on crates i/o we can then

00:13:40,060 --> 00:13:43,149
use sin it'll have a lot of nice

00:13:41,500 --> 00:13:44,709
utilities will see those in a second for

00:13:43,149 --> 00:13:46,509
implementing this parse function so we

00:13:44,709 --> 00:13:48,579
can very easily write our parsers and we

00:13:46,509 --> 00:13:49,660
don't have to parse all of us syntax and

00:13:48,579 --> 00:13:52,089
every single crate and have a little

00:13:49,660 --> 00:13:54,040
buggy here in there and then to actually

00:13:52,089 --> 00:13:56,230
expand this crate to actually create

00:13:54,040 --> 00:13:57,430
some token streams and make more we can

00:13:56,230 --> 00:13:58,899
use the quilt crate which we'll be

00:13:57,430 --> 00:14:03,009
looking at in some detail after this as

00:13:58,899 --> 00:14:04,990
well so as I was saying sin will be used

00:14:03,009 --> 00:14:07,120
to parse all of the rest code that we

00:14:04,990 --> 00:14:09,670
are that we receive and the way that it

00:14:07,120 --> 00:14:11,620
mostly works is kind of a lot of times

00:14:09,670 --> 00:14:14,170
when you write a macro you're extending

00:14:11,620 --> 00:14:16,509
rust syntax and very small or very tiny

00:14:14,170 --> 00:14:18,759
ways so in a print lean format we kind

00:14:16,509 --> 00:14:20,439
of have custom for syntax in the string

00:14:18,759 --> 00:14:21,670
but everything after that is just a

00:14:20,439 --> 00:14:23,709
bunch of function arguments this is

00:14:21,670 --> 00:14:26,170
commas and expressions and all existing

00:14:23,709 --> 00:14:27,850
rust syntax and so the well the reason

00:14:26,170 --> 00:14:29,500
sin is so powerful is it's kind of

00:14:27,850 --> 00:14:31,569
giving you all these parsers which you

00:14:29,500 --> 00:14:33,220
can already leverage but then you can

00:14:31,569 --> 00:14:35,019
write the top-level logic for right

00:14:33,220 --> 00:14:36,939
having a little pieces of custom syntax

00:14:35,019 --> 00:14:38,470
here and there and then use the rest of

00:14:36,939 --> 00:14:40,000
cinder to kind of do the real work of

00:14:38,470 --> 00:14:41,170
actually parsing an expression or kind

00:14:40,000 --> 00:14:43,480
of dealing with precedents and all that

00:14:41,170 --> 00:14:44,829
crazy stuff and then one thing I'll talk

00:14:43,480 --> 00:14:47,110
about a little bit later is the kind of

00:14:44,829 --> 00:14:49,000
this idea of preserving span information

00:14:47,110 --> 00:14:51,220
and so we saw in the previous talk how

00:14:49,000 --> 00:14:52,930
important spans are for producing errors

00:14:51,220 --> 00:14:54,579
and so that's also very important when

00:14:52,930 --> 00:14:56,259
you're manufacturing all these token

00:14:54,579 --> 00:14:58,240
streams and this is exactly what the

00:14:56,259 --> 00:14:59,800
compiler is compiling and so we want to

00:14:58,240 --> 00:15:01,029
make sure that that span information is

00:14:59,800 --> 00:15:02,920
accurate to make sure that the error

00:15:01,029 --> 00:15:06,880
messages are as good as possible and

00:15:02,920 --> 00:15:08,110
then finally sin is relatively large in

00:15:06,880 --> 00:15:11,259
terms of there's actually a lot of rest

00:15:08,110 --> 00:15:13,149
syntax and so because procedure macros

00:15:11,259 --> 00:15:14,290
are always compiled with your crate when

00:15:13,149 --> 00:15:15,970
you type carve a build you have to

00:15:14,290 --> 00:15:17,889
actually build a rust parser on the spot

00:15:15,970 --> 00:15:19,839
and so there's a lot of feature gates to

00:15:17,889 --> 00:15:21,399
aggressively remove code that we don't

00:15:19,839 --> 00:15:24,009
have to compile and so it compiles very

00:15:21,399 --> 00:15:26,649
very quickly for most average cases and

00:15:24,009 --> 00:15:28,180
to give you a bit of an idea if you're

00:15:26,649 --> 00:15:29,350
writing a derived macro

00:15:28,180 --> 00:15:31,120
you can you don't actually have to

00:15:29,350 --> 00:15:32,740
define anything we don't need this my

00:15:31,120 --> 00:15:34,930
invocation or any other serialized

00:15:32,740 --> 00:15:37,810
instance we can just use the the

00:15:34,930 --> 00:15:39,760
utilities provided by sin so sin gives

00:15:37,810 --> 00:15:41,650
us this derive input type that gives us

00:15:39,760 --> 00:15:43,600
a convenient macro for parsing directly

00:15:41,650 --> 00:15:45,580
into it and we're off to the races

00:15:43,600 --> 00:15:48,010
we can immediately take a look at that

00:15:45,580 --> 00:15:49,690
see if it's a struct or an enum how many

00:15:48,010 --> 00:15:51,640
fields it has what kind of variants all

00:15:49,690 --> 00:15:54,670
those various aspects of the input and

00:15:51,640 --> 00:15:56,200
just keep on going and it goes a little

00:15:54,670 --> 00:15:57,370
bit beyond this where it's a little bit

00:15:56,200 --> 00:15:58,660
more advanced and you might have seen

00:15:57,370 --> 00:16:01,089
this in the workshop yesterday had you

00:15:58,660 --> 00:16:03,220
been there but there's extra traits for

00:16:01,089 --> 00:16:06,010
parsing kind of custom syntax and in

00:16:03,220 --> 00:16:08,080
nice ways kind of a it's similar ish to

00:16:06,010 --> 00:16:09,610
nom but a little bit more ergonomic in a

00:16:08,080 --> 00:16:12,820
few places but I'm not gonna go too much

00:16:09,610 --> 00:16:14,050
into the details here and so the second

00:16:12,820 --> 00:16:16,240
half of this was after we've actually

00:16:14,050 --> 00:16:17,620
parsed this code we now need to generate

00:16:16,240 --> 00:16:20,200
a bunch of token streams and so that's

00:16:17,620 --> 00:16:21,670
where quotes gonna come in where if you

00:16:20,200 --> 00:16:23,800
take a look at the bare fundamentals

00:16:21,670 --> 00:16:24,880
it's hard to parse they're hard to take

00:16:23,800 --> 00:16:26,529
a look at this token stream and

00:16:24,880 --> 00:16:28,390
interpret it so we parse it but

00:16:26,529 --> 00:16:30,100
similarly it's very difficult to create

00:16:28,390 --> 00:16:31,630
token streams and all you can do is

00:16:30,100 --> 00:16:33,130
create them from a list or kind of

00:16:31,630 --> 00:16:35,110
create an empty one or kind of add new

00:16:33,130 --> 00:16:37,029
tokens to an existing one and so the

00:16:35,110 --> 00:16:39,220
idea here is that there's a convenient

00:16:37,029 --> 00:16:41,020
macro called quote which does a process

00:16:39,220 --> 00:16:42,550
called quasi quoting which doesn't make

00:16:41,020 --> 00:16:44,860
any sense to me but I'll talk a little

00:16:42,550 --> 00:16:46,510
bit more about it and the idea is you

00:16:44,860 --> 00:16:48,610
can have these interpolations where you

00:16:46,510 --> 00:16:50,560
can splice in pieces of syntax that

00:16:48,610 --> 00:16:51,760
don't always make sense in isolation but

00:16:50,560 --> 00:16:53,589
when you have it look at it when you

00:16:51,760 --> 00:16:56,440
take a look at it as a whole it kind of

00:16:53,589 --> 00:16:58,480
creates a valid Russ program and to give

00:16:56,440 --> 00:17:00,970
you a bit of an idea this is producing

00:16:58,480 --> 00:17:03,670
the same syntax so let's slices equals

00:17:00,970 --> 00:17:05,589
42 and so at the top here is what you

00:17:03,670 --> 00:17:07,720
would be doing with the raw token stream

00:17:05,589 --> 00:17:10,000
and token tree api's it's basically

00:17:07,720 --> 00:17:12,220
terrible it's it's horribly an ergonomic

00:17:10,000 --> 00:17:14,500
to create each identifier to create each

00:17:12,220 --> 00:17:16,510
piece of punctuation it's very difficult

00:17:14,500 --> 00:17:17,230
to read this to modify it to understand

00:17:16,510 --> 00:17:19,030
what's going on

00:17:17,230 --> 00:17:20,800
whereas below hand it's actually pretty

00:17:19,030 --> 00:17:21,490
obvious we're creating let's slices

00:17:20,800 --> 00:17:23,140
equal 42

00:17:21,490 --> 00:17:24,490
you also get some nice syntax

00:17:23,140 --> 00:17:26,559
highlighting in here kind of cuz it

00:17:24,490 --> 00:17:28,030
looks a little bit like brush syntax but

00:17:26,559 --> 00:17:29,679
these are functionally the same where

00:17:28,030 --> 00:17:32,230
they're not actually executing this code

00:17:29,679 --> 00:17:33,670
they're producing a token stream that

00:17:32,230 --> 00:17:35,550
represents that code which will then be

00:17:33,670 --> 00:17:38,380
compiled by the compiler later on and

00:17:35,550 --> 00:17:40,360
this interpolation aspects comes in when

00:17:38,380 --> 00:17:41,590
you have local variables such as the

00:17:40,360 --> 00:17:43,090
name of some structure

00:17:41,590 --> 00:17:44,860
generating or the fields that it

00:17:43,090 --> 00:17:46,750
contains internally and then you can

00:17:44,860 --> 00:17:48,789
just kind of do this splicing where you

00:17:46,750 --> 00:17:50,919
can have little pound names or you can

00:17:48,789 --> 00:17:53,950
do it eration with these it's sort of

00:17:50,919 --> 00:17:55,929
like a macro rules style syntax but the

00:17:53,950 --> 00:17:57,159
idea here is it's all very valid rests

00:17:55,929 --> 00:17:58,840
in text and you don't have to worry so

00:17:57,159 --> 00:18:00,400
much about what's going on but it's very

00:17:58,840 --> 00:18:02,169
easy to read see what's being generated

00:18:00,400 --> 00:18:03,820
as opposed to manually generating each

00:18:02,169 --> 00:18:06,100
of these kinds of token streams and so

00:18:03,820 --> 00:18:08,559
quote ends up being a very very powerful

00:18:06,100 --> 00:18:11,110
create and for writing very concise code

00:18:08,559 --> 00:18:13,210
generators are kind of all these crazy

00:18:11,110 --> 00:18:14,590
different kinds of expanders and sin

00:18:13,210 --> 00:18:16,240
itself comes with all of these so if

00:18:14,590 --> 00:18:17,919
you're given an expression you can both

00:18:16,240 --> 00:18:21,000
parse it and then create a token stream

00:18:17,919 --> 00:18:23,679
as well it's all provided for you there

00:18:21,000 --> 00:18:25,630
sorry the last thing to consider when

00:18:23,679 --> 00:18:27,100
you're writing a macro is the span

00:18:25,630 --> 00:18:29,799
information which I've been saying about

00:18:27,100 --> 00:18:32,169
and so as Esteban was saying earlier a

00:18:29,799 --> 00:18:34,149
span is all about where does this piece

00:18:32,169 --> 00:18:36,429
of code come from and so that's all

00:18:34,149 --> 00:18:37,600
primarily used in Diagnostics but it's

00:18:36,429 --> 00:18:38,860
also used of things like debug

00:18:37,600 --> 00:18:42,100
information for if you set breakpoints

00:18:38,860 --> 00:18:44,409
on line numbers but the idea here is

00:18:42,100 --> 00:18:46,779
that every token tree so the groups the

00:18:44,409 --> 00:18:49,090
literals the punctuation you saw earlier

00:18:46,779 --> 00:18:51,250
are all annotated with the span so just

00:18:49,090 --> 00:18:54,100
this is from byte 4 to byte size this is

00:18:51,250 --> 00:18:56,710
on line 6 line 7 that kind of stuff and

00:18:54,100 --> 00:18:58,360
if you actually erase all span

00:18:56,710 --> 00:19:00,039
information so if you take this input

00:18:58,360 --> 00:19:01,450
and this bake at macro and you just

00:19:00,039 --> 00:19:03,159
stringify everything and parse it back

00:19:01,450 --> 00:19:05,380
out you're gonna get a horrible error

00:19:03,159 --> 00:19:08,350
message here that says oh it points to

00:19:05,380 --> 00:19:09,640
bake at pound 375 it's it doesn't

00:19:08,350 --> 00:19:11,350
actually point to split out 1/2 and it's

00:19:09,640 --> 00:19:14,049
very difficult to know in your code

00:19:11,350 --> 00:19:15,610
where that is actually located whereas

00:19:14,049 --> 00:19:17,020
if you actually correctly preserve the

00:19:15,610 --> 00:19:18,820
span information then you can get the

00:19:17,020 --> 00:19:20,799
normal compiler errors of saying oh look

00:19:18,820 --> 00:19:22,480
it actually is happening at this line at

00:19:20,799 --> 00:19:24,789
this method call or not at this exact

00:19:22,480 --> 00:19:26,649
location and so this is something that's

00:19:24,789 --> 00:19:28,330
very very important to remember when

00:19:26,649 --> 00:19:30,309
you're writing procedure macros is that

00:19:28,330 --> 00:19:32,440
you need to make sure that all along the

00:19:30,309 --> 00:19:34,750
way span information is preserved as

00:19:32,440 --> 00:19:38,169
much as possible because in this case

00:19:34,750 --> 00:19:40,480
there's no problem with the macro itself

00:19:38,169 --> 00:19:42,669
so the bake at macro could be producing

00:19:40,480 --> 00:19:44,679
completely valid code but it's the

00:19:42,669 --> 00:19:46,419
internal code written by the user which

00:19:44,679 --> 00:19:48,610
is actually the invalid part which has a

00:19:46,419 --> 00:19:50,830
syntactical error or type checking error

00:19:48,610 --> 00:19:52,480
or a name resolution error and so that's

00:19:50,830 --> 00:19:54,490
naturally going to happen you want

00:19:52,480 --> 00:19:56,140
make sure that your procedure macros

00:19:54,490 --> 00:19:58,690
don't destroy all the Diagnostics coming

00:19:56,140 --> 00:19:59,980
out of it and the other really cool

00:19:58,690 --> 00:20:01,750
thing that you can do with spans is

00:19:59,980 --> 00:20:04,090
actually manufacture custom error

00:20:01,750 --> 00:20:05,830
messages it's a bit of a hack today but

00:20:04,090 --> 00:20:07,540
you can create fancy error messages like

00:20:05,830 --> 00:20:09,760
this which point directly at a

00:20:07,540 --> 00:20:11,140
particular input token and have no

00:20:09,760 --> 00:20:13,210
correlation to what the compiler would

00:20:11,140 --> 00:20:14,530
do and so here I'm saying I want a very

00:20:13,210 --> 00:20:16,570
specific kind of bread not just a

00:20:14,530 --> 00:20:19,540
generic kind of bread to knead it at

00:20:16,570 --> 00:20:22,870
this point so this is a great way for

00:20:19,540 --> 00:20:25,419
macros who can kind of deduce at parse

00:20:22,870 --> 00:20:27,040
time what's valid what's not valid

00:20:25,419 --> 00:20:28,690
whether this is syntactically incorrect

00:20:27,040 --> 00:20:30,730
and provide very pointed error messages

00:20:28,690 --> 00:20:32,559
of saying you didn't annotate this field

00:20:30,730 --> 00:20:33,850
or you did entities annotate this field

00:20:32,559 --> 00:20:37,020
you shouldn't have done that you forgot

00:20:33,850 --> 00:20:39,130
to use this all that kind of good stuff

00:20:37,020 --> 00:20:40,929
sorry the last thing I want to talk

00:20:39,130 --> 00:20:42,520
about is a little bit about the future

00:20:40,929 --> 00:20:44,020
of macros you know look have some

00:20:42,520 --> 00:20:45,790
features we have coming down the pike as

00:20:44,020 --> 00:20:48,309
well as social some examples of some

00:20:45,790 --> 00:20:50,230
cool macros a little bit later and it

00:20:48,309 --> 00:20:52,299
would be remiss of me to not talk about

00:20:50,230 --> 00:20:54,940
the word hygiene during of talk about

00:20:52,299 --> 00:20:56,799
macros now I don't really know what

00:20:54,940 --> 00:20:58,750
hygiene is myself but it always comes up

00:20:56,799 --> 00:21:00,820
when you talk about macros and rust and

00:20:58,750 --> 00:21:02,770
so I the best way that I can explain it

00:21:00,820 --> 00:21:05,080
is a small example of how it always goes

00:21:02,770 --> 00:21:07,090
wrong and so let's say you are writing a

00:21:05,080 --> 00:21:09,460
custom derive or a derived macro where

00:21:07,090 --> 00:21:11,799
you say you're implementing my treat for

00:21:09,460 --> 00:21:13,510
some type that someone passed in well it

00:21:11,799 --> 00:21:15,910
turns out this might not actually work

00:21:13,510 --> 00:21:18,280
because the way macros work today is as

00:21:15,910 --> 00:21:19,990
if you just took those tokens and then

00:21:18,280 --> 00:21:21,880
wrote them right next to the code or

00:21:19,990 --> 00:21:24,429
where your macro was located and so

00:21:21,880 --> 00:21:26,230
maybe my treat wasn't in scope and so

00:21:24,429 --> 00:21:28,150
where do we actually pull in my trait

00:21:26,230 --> 00:21:31,419
from so this might have a compiler

00:21:28,150 --> 00:21:33,520
unless you have that in scope as a macro

00:21:31,419 --> 00:21:35,110
Arthur will fix that we'll say oh this

00:21:33,520 --> 00:21:36,880
comes from my Cretan so we'll say oh

00:21:35,110 --> 00:21:38,530
it's located here at this path and my

00:21:36,880 --> 00:21:39,880
create and therefore this will always

00:21:38,530 --> 00:21:41,080
compile because you don't have to have

00:21:39,880 --> 00:21:43,179
it in scope you just have to make sure

00:21:41,080 --> 00:21:44,559
to link to my crate but you're probably

00:21:43,179 --> 00:21:47,110
pulling in my crate there the macro

00:21:44,559 --> 00:21:49,840
through the crate anyway but even this

00:21:47,110 --> 00:21:51,580
doesn't work I can rename crates in my

00:21:49,840 --> 00:21:53,830
cargo tunnel for whatever reason I might

00:21:51,580 --> 00:21:56,049
want and so although you might call it

00:21:53,830 --> 00:21:57,880
my crate I might call it other name or

00:21:56,049 --> 00:22:00,040
something else completely different and

00:21:57,880 --> 00:22:01,570
so at this point we actually have no

00:22:00,040 --> 00:22:04,220
idea what we're gonna write in this

00:22:01,570 --> 00:22:06,230
macro here we have no way to canonic

00:22:04,220 --> 00:22:08,240
refer to something that we want to refer

00:22:06,230 --> 00:22:11,169
to and so this is the whole fundamental

00:22:08,240 --> 00:22:14,150
problem of Hygiene which is I want to

00:22:11,169 --> 00:22:15,710
deterministically refer to this treat no

00:22:14,150 --> 00:22:17,120
matter what you're linking to no matter

00:22:15,710 --> 00:22:19,130
what you called things no matter what

00:22:17,120 --> 00:22:21,230
you say anything about and so that that

00:22:19,130 --> 00:22:23,059
problem is very very difficult and one

00:22:21,230 --> 00:22:25,340
that we have not tackled yet and so all

00:22:23,059 --> 00:22:27,169
the procedure macros are not hygienic

00:22:25,340 --> 00:22:28,850
where they're just taking your tokens

00:22:27,169 --> 00:22:30,289
and copy pasting them and they're

00:22:28,850 --> 00:22:32,000
effectively best-effort where you kind

00:22:30,289 --> 00:22:33,130
of just have to write this and hope for

00:22:32,000 --> 00:22:35,690
the best and make sure that

00:22:33,130 --> 00:22:37,669
idiomatically your crates not renamed or

00:22:35,690 --> 00:22:39,710
idiomatically no one writes other crazy

00:22:37,669 --> 00:22:41,600
stuff or tries to react Sport macros and

00:22:39,710 --> 00:22:42,950
it's it's a major pain point of macros

00:22:41,600 --> 00:22:45,710
today and one we want to continue

00:22:42,950 --> 00:22:47,150
improve upon although it's a very large

00:22:45,710 --> 00:22:50,630
extension to relative to where we are

00:22:47,150 --> 00:22:53,270
today unfortunately so the next thing is

00:22:50,630 --> 00:22:55,640
that we've seen kind of the the power of

00:22:53,270 --> 00:22:57,500
rusts Diagnostics we've seen how helpful

00:22:55,640 --> 00:22:59,510
they can be how useful they can be bad

00:22:57,500 --> 00:23:01,340
they can be in some cases but this is

00:22:59,510 --> 00:23:04,419
one where we want to give that same

00:23:01,340 --> 00:23:06,740
level of Devourer to custom or to

00:23:04,419 --> 00:23:08,900
procedure macros written on crates iOS

00:23:06,740 --> 00:23:10,549
and so this is an example of an error

00:23:08,900 --> 00:23:12,320
message produced by the compiler but we

00:23:10,549 --> 00:23:14,000
were unable to use that in our procedure

00:23:12,320 --> 00:23:14,840
macro all we could do was generate the

00:23:14,000 --> 00:23:16,820
word mismatch

00:23:14,840 --> 00:23:18,440
types and so eventually we're gonna have

00:23:16,820 --> 00:23:20,450
the ability to have this underlined text

00:23:18,440 --> 00:23:21,919
the expected business the health

00:23:20,450 --> 00:23:25,640
business the note business welcome

00:23:21,919 --> 00:23:27,230
warnings all sorts of official level

00:23:25,640 --> 00:23:28,700
diagnostics and so this is one that's

00:23:27,230 --> 00:23:30,559
coming down the pike but not stabilized

00:23:28,700 --> 00:23:31,760
yet I think it's implemented on nightly

00:23:30,559 --> 00:23:33,830
right now and you can play around with

00:23:31,760 --> 00:23:37,190
it but it's still a little bit of time

00:23:33,830 --> 00:23:38,780
before stabilization now the last thing

00:23:37,190 --> 00:23:41,030
that I would like to see is kind of a

00:23:38,780 --> 00:23:43,190
better experience for debugging macros

00:23:41,030 --> 00:23:45,080
and so when you're working with macros

00:23:43,190 --> 00:23:47,150
you tend to be producing pieces of russ

00:23:45,080 --> 00:23:49,220
syntax and it's you have to produce

00:23:47,150 --> 00:23:50,539
valid russ syntax because it's gonna be

00:23:49,220 --> 00:23:53,150
turned around and parsed by the compiler

00:23:50,539 --> 00:23:54,770
but if you produce invalid russ syntax

00:23:53,150 --> 00:23:57,080
you get a crazy error message like this

00:23:54,770 --> 00:23:58,400
that doesn't make any sense and so this

00:23:57,080 --> 00:24:00,590
has to do again with the span

00:23:58,400 --> 00:24:02,750
information where the spans all point to

00:24:00,590 --> 00:24:04,610
this original macro and kind of this way

00:24:02,750 --> 00:24:06,260
it's a lot of internal details here but

00:24:04,610 --> 00:24:08,360
I would love to see kind of a better

00:24:06,260 --> 00:24:09,620
system for maybe we can pretty print in

00:24:08,360 --> 00:24:11,030
the compiler we can have a better

00:24:09,620 --> 00:24:12,830
experience where you don't have to add

00:24:11,030 --> 00:24:14,659
random print lines in your macro to see

00:24:12,830 --> 00:24:15,380
what's coming out right now it's just a

00:24:14,659 --> 00:24:17,390
kind of a you

00:24:15,380 --> 00:24:19,010
have to hope that it was valid

00:24:17,390 --> 00:24:20,539
previously and the know what you changed

00:24:19,010 --> 00:24:21,950
if it breaks so you can kind of look

00:24:20,539 --> 00:24:25,850
within that Delta to see what's actually

00:24:21,950 --> 00:24:27,140
broken in this kind of case sorry the

00:24:25,850 --> 00:24:29,150
last thing that I want to do is kind of

00:24:27,140 --> 00:24:31,039
give you a bit of an idea of some cool

00:24:29,150 --> 00:24:32,450
macros that I've seen in the ecosystem I

00:24:31,039 --> 00:24:34,940
was just sitting in the workshop

00:24:32,450 --> 00:24:36,620
yesterday and I realized that all these

00:24:34,940 --> 00:24:39,260
macros that are just described in that

00:24:36,620 --> 00:24:40,970
one readme or just they I always loved

00:24:39,260 --> 00:24:42,110
seeing the possibilities of procedure

00:24:40,970 --> 00:24:43,940
macros I've been talking a lot about

00:24:42,110 --> 00:24:45,980
what they are and kind of tell what they

00:24:43,940 --> 00:24:47,720
can do at a technical level but I love

00:24:45,980 --> 00:24:49,340
seeing examples of how people are doing

00:24:47,720 --> 00:24:51,620
completely crazy things with macros that

00:24:49,340 --> 00:24:53,270
I would never even considered so David

00:24:51,620 --> 00:24:55,340
showed me this one which is what if you

00:24:53,270 --> 00:24:58,220
had a macro to say that your enum was

00:24:55,340 --> 00:24:59,809
always sorted so if I put R I before

00:24:58,220 --> 00:25:01,340
focaccia have a get a compile time error

00:24:59,809 --> 00:25:03,770
saying oh you put this in the wrong

00:25:01,340 --> 00:25:05,990
place please place it after focaccia not

00:25:03,770 --> 00:25:07,580
necessarily the killer feature of rust

00:25:05,990 --> 00:25:09,559
but kind of cool that you can write this

00:25:07,580 --> 00:25:11,299
on crates I own it's just a completely

00:25:09,559 --> 00:25:13,600
library fide crate and it'll never break

00:25:11,299 --> 00:25:15,799
and you can pull it in at any time

00:25:13,600 --> 00:25:17,539
similarly many of you have might have

00:25:15,799 --> 00:25:18,919
used clap for argument parsing when

00:25:17,539 --> 00:25:20,510
you're writing a command-line program in

00:25:18,919 --> 00:25:22,520
rusts and it turns out there's this

00:25:20,510 --> 00:25:25,700
convenient other creek called struct opt

00:25:22,520 --> 00:25:26,600
or you can slap on a derive startup and

00:25:25,700 --> 00:25:28,940
all of a sudden you have an argument

00:25:26,600 --> 00:25:30,770
parser you can internally say what the

00:25:28,940 --> 00:25:32,270
long arguments are or the all the short

00:25:30,770 --> 00:25:33,799
options are kind of so help values

00:25:32,270 --> 00:25:35,960
default values all sorts of crazy

00:25:33,799 --> 00:25:38,900
configuration and this is a very

00:25:35,960 --> 00:25:40,730
succinct way to define a CLI interface

00:25:38,900 --> 00:25:42,590
and have it parsed already for you and

00:25:40,730 --> 00:25:44,299
kind of remove tons of boilerplate and

00:25:42,590 --> 00:25:46,580
so this is one that's not really

00:25:44,299 --> 00:25:49,250
deriving a trait per se but it's still

00:25:46,580 --> 00:25:51,860
kind of leveraging the ability of derive

00:25:49,250 --> 00:25:53,659
to be a very lightweight annotation

00:25:51,860 --> 00:25:55,370
where you're like oh I I I kind of

00:25:53,659 --> 00:25:56,720
understood I don't know exactly what

00:25:55,370 --> 00:25:58,100
that is but I can kind of understand

00:25:56,720 --> 00:25:59,720
what's going on because so much of the

00:25:58,100 --> 00:26:05,299
syntax surrounding that is familiar and

00:25:59,720 --> 00:26:07,309
easy for me to read similarly the genome

00:26:05,299 --> 00:26:09,289
project has been working on a macro for

00:26:07,309 --> 00:26:11,000
quite some time where they have a very

00:26:09,289 --> 00:26:12,710
complicated runtime system and what they

00:26:11,000 --> 00:26:15,140
want to do is define these things called

00:26:12,710 --> 00:26:16,640
G objects and rusts and they have a lot

00:26:15,140 --> 00:26:18,020
of boilerplate associated with them a

00:26:16,640 --> 00:26:20,120
lot of kind of various pieces of

00:26:18,020 --> 00:26:21,620
interfaces here and there and the idea

00:26:20,120 --> 00:26:23,840
is they can wrap it all up in a nice

00:26:21,620 --> 00:26:26,299
little macro and so this isn't exactly

00:26:23,840 --> 00:26:27,840
rust syntax it's more kind of G object

00:26:26,299 --> 00:26:29,520
organ ohm oriented syntax

00:26:27,840 --> 00:26:30,990
but you can kind of see and kind of

00:26:29,520 --> 00:26:33,210
surmise what's going on at this point

00:26:30,990 --> 00:26:35,669
and so this is a cool example of how

00:26:33,210 --> 00:26:37,289
tons of boilerplate is generated behind

00:26:35,669 --> 00:26:38,940
the scenes here and this is very

00:26:37,289 --> 00:26:41,250
error-prone in seeds very error-prone

00:26:38,940 --> 00:26:43,620
and rust if you read it by hand but

00:26:41,250 --> 00:26:45,600
here's a snice and sixteenth way to kind

00:26:43,620 --> 00:26:48,090
of keep everything nice in one place and

00:26:45,600 --> 00:26:49,289
understandable and just kind of a cool

00:26:48,090 --> 00:26:51,720
thing you can do with macros at that

00:26:49,289 --> 00:26:53,909
point and it also is showing how you can

00:26:51,720 --> 00:26:55,890
extend rust syntax you don't have to

00:26:53,909 --> 00:26:58,350
have exactly structs or exactly enums

00:26:55,890 --> 00:27:00,750
this is just arbitrary token streams and

00:26:58,350 --> 00:27:01,890
so class isn't a thing in rust but you

00:27:00,750 --> 00:27:04,620
can make it a thing in the back row if

00:27:01,890 --> 00:27:05,970
you want and then one other important

00:27:04,620 --> 00:27:07,409
thing to point out here is that this is

00:27:05,970 --> 00:27:09,929
again one of those instances where

00:27:07,409 --> 00:27:11,549
there's so much code here in the middle

00:27:09,929 --> 00:27:12,990
you could have any sort of compiler

00:27:11,549 --> 00:27:14,549
errors with that but you could have type

00:27:12,990 --> 00:27:16,559
check errors you could have weird

00:27:14,549 --> 00:27:18,149
integer errors or anything like that so

00:27:16,559 --> 00:27:20,159
you want to make sure that that span

00:27:18,149 --> 00:27:22,529
information is all preserved here so if

00:27:20,159 --> 00:27:24,539
each slice has a random bug inside of it

00:27:22,529 --> 00:27:25,740
not associated with the macro you still

00:27:24,539 --> 00:27:26,909
have so those high quality error

00:27:25,740 --> 00:27:29,669
messages coming out of it

00:27:26,909 --> 00:27:31,770
and then the last thing I thought which

00:27:29,669 --> 00:27:33,720
was really really cool is David's

00:27:31,770 --> 00:27:34,289
actually also created a macro called no

00:27:33,720 --> 00:27:36,299
panic

00:27:34,289 --> 00:27:37,830
where you put it on a function and if

00:27:36,299 --> 00:27:41,010
this compiles the function doesn't

00:27:37,830 --> 00:27:42,210
panics that's kind of I I've heard that

00:27:41,010 --> 00:27:43,649
a lot with kind of embedded systems

00:27:42,210 --> 00:27:45,120
where they want a system where they want

00:27:43,649 --> 00:27:46,409
functions that can never panic or

00:27:45,120 --> 00:27:48,210
functions that are guaranteed to not

00:27:46,409 --> 00:27:50,909
panic for code code size reasons or just

00:27:48,210 --> 00:27:52,890
have correctness reasons and so this is

00:27:50,909 --> 00:27:55,860
a very lightweight way to say to do

00:27:52,890 --> 00:27:58,080
crazy analysis at compile time and a

00:27:55,860 --> 00:27:59,730
kind of a interesting sense but the idea

00:27:58,080 --> 00:28:01,409
is that this is at least a way to say

00:27:59,730 --> 00:28:02,850
this function never panics when at

00:28:01,409 --> 00:28:06,360
runtime when I actually compile it and

00:28:02,850 --> 00:28:08,399
you can know that statically sorry

00:28:06,360 --> 00:28:09,809
that's what I have if you have some

00:28:08,399 --> 00:28:12,210
further questions these are some great

00:28:09,809 --> 00:28:14,100
links the first of which is David's proc

00:28:12,210 --> 00:28:15,870
macro workshop done yesterday which has

00:28:14,100 --> 00:28:18,059
a lot of excellent exercises to kind of

00:28:15,870 --> 00:28:19,620
get your feet wet see how these macros

00:28:18,059 --> 00:28:21,090
work in various different ways and kind

00:28:19,620 --> 00:28:23,520
of get used to sin and quote and all

00:28:21,090 --> 00:28:25,320
that the reference for procedure macros

00:28:23,520 --> 00:28:27,179
is actually pretty up-to-date and it has

00:28:25,320 --> 00:28:28,590
none necessarily it's it's it's very

00:28:27,179 --> 00:28:30,840
technical it's a reference piece of

00:28:28,590 --> 00:28:32,250
documentation and then the sin and the

00:28:30,840 --> 00:28:33,600
quote crates have excellent

00:28:32,250 --> 00:28:35,429
documentation for getting started with

00:28:33,600 --> 00:28:36,950
procedure macros and kind of how to

00:28:35,429 --> 00:28:38,880
write your own and how to do

00:28:36,950 --> 00:28:42,130
sorry thanks so much

00:28:38,880 --> 00:28:42,130
[Applause]

00:28:46,700 --> 00:28:49,779

YouTube URL: https://www.youtube.com/watch?v=g4SYTOc8fL0


