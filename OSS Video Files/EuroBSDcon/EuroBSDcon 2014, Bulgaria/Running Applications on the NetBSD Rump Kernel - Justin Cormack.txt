Title: Running Applications on the NetBSD Rump Kernel - Justin Cormack
Publication date: 2019-10-13
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

The NetBSD rump kernel has been developed for some years now, allowing NetBSD kernel drivers to be used unmodified in many environments, for example as userspace code. However it is only since last year that it has become possible to easily run unmodified applications on the rump kernel, initially with the rump kernel on Xen port, and then with the rumprun tools to run them in userspace on Linux, FreeBSD and NetBSD. This talk will look at how this is achieved, and look at use cases, including kernel driver development, and lightweight process virtualization.

Speaker biography:

Justin Cormack has been a Unix user, developer and sysadmin since the early 1990s. He is based in London and works on open source cloud applications, Lua, and the NetBSD rump kernel project. He has been a NetBSD developer since early 2014.
Captions: 
	00:00:02,570 --> 00:00:10,530
next up is just in Cormack wrong and

00:00:07,400 --> 00:00:15,420
justin is a net bsd developer who does a

00:00:10,530 --> 00:00:18,930
lot of work in ramp time-to-time uses

00:00:15,420 --> 00:00:25,050
that scripting language to saw the next

00:00:18,930 --> 00:00:29,220
45 minutes hi

00:00:25,050 --> 00:00:31,650
um it's rad that's working um right so

00:00:29,220 --> 00:00:34,170
yeah i'm gonna talk about running

00:00:31,650 --> 00:00:37,320
applications on the nebby sdram kernel

00:00:34,170 --> 00:00:38,879
I'm also gonna talk about the stuff

00:00:37,320 --> 00:00:41,129
we've been working on with ROM kernel

00:00:38,879 --> 00:00:43,230
and an introduction to it for people who

00:00:41,129 --> 00:00:46,020
aren't familiar with what it's for and

00:00:43,230 --> 00:00:51,390
some stuff that we're planning to do

00:00:46,020 --> 00:00:55,320
with a run kernel as well so the slides

00:00:51,390 --> 00:00:58,649
are possibly on that URL your BSD

00:00:55,320 --> 00:01:00,000
connery a bit or EU although that they

00:00:58,649 --> 00:01:04,229
didn't seem to be available from this

00:01:00,000 --> 00:01:07,530
room but there are links to stuff on

00:01:04,229 --> 00:01:10,549
them I don't know why if some can fix

00:01:07,530 --> 00:01:12,810
the why they're not working from here

00:01:10,549 --> 00:01:14,909
the DNS seem to be working so it's a bit

00:01:12,810 --> 00:01:17,610
weird anyway but so there's links if you

00:01:14,909 --> 00:01:19,229
want to go there or if you're on the

00:01:17,610 --> 00:01:20,640
live stream it might be helpful because

00:01:19,229 --> 00:01:26,750
of the skies definitely since if you're

00:01:20,640 --> 00:01:31,770
working you can ah sit in this room so

00:01:26,750 --> 00:01:33,329
um the ROM kernels are kind of sorry odd

00:01:31,770 --> 00:01:36,509
thing it's it's something that's only

00:01:33,329 --> 00:01:39,079
available in net bsd and it's you know

00:01:36,509 --> 00:01:42,600
one of the unique features of net bsd

00:01:39,079 --> 00:01:46,770
and it's basically its net bsd but with

00:01:42,600 --> 00:01:49,710
a whole lot of stuff taken out you it's

00:01:46,770 --> 00:01:51,899
it's most of the kernel but it can't

00:01:49,710 --> 00:01:55,500
execute binaries it can't read your

00:01:51,899 --> 00:01:58,140
threads it doesn't understand anything

00:01:55,500 --> 00:01:59,850
about users or anything like that well

00:01:58,140 --> 00:02:01,290
it kind of does but it doesn't add some

00:01:59,850 --> 00:02:05,490
memory management or anything like that

00:02:01,290 --> 00:02:07,560
so it's a kind of it's a it's quite a

00:02:05,490 --> 00:02:09,539
lot of the net bsd kernel but with a

00:02:07,560 --> 00:02:12,170
whole lot of stuff that's not there

00:02:09,539 --> 00:02:16,550
which sounds kind of useless

00:02:12,170 --> 00:02:19,100
but really it's the drivers and the

00:02:16,550 --> 00:02:22,670
drivers are kind of they're the majority

00:02:19,100 --> 00:02:24,560
of the kernel they're the quite often

00:02:22,670 --> 00:02:28,760
the most frustrating bit of the kernel

00:02:24,560 --> 00:02:31,100
and the bit that takes a long time to

00:02:28,760 --> 00:02:35,060
write they they deal with actual

00:02:31,100 --> 00:02:38,330
hardware which is buggy and they also

00:02:35,060 --> 00:02:40,459
deal with the kind of nice bits of stuff

00:02:38,330 --> 00:02:42,920
that as a user you'd like to use with a

00:02:40,459 --> 00:02:45,470
kernel so it deals with actual file

00:02:42,920 --> 00:02:48,830
systems rather than just raw blocks on

00:02:45,470 --> 00:02:50,300
disks and sockets and TCP and stuff like

00:02:48,830 --> 00:02:53,600
that or all in their drivers and so

00:02:50,300 --> 00:02:57,440
that's the stuff that users really need

00:02:53,600 --> 00:02:58,580
in their kernel I mean users like to be

00:02:57,440 --> 00:03:01,540
able to allocate some memory in things

00:02:58,580 --> 00:03:04,400
as well but in a second

00:03:01,540 --> 00:03:06,739
so what we what we do with the ROM

00:03:04,400 --> 00:03:12,680
kernel is basically we use something

00:03:06,739 --> 00:03:14,480
else to do those missing parts some sort

00:03:12,680 --> 00:03:19,220
of host system which will do memory

00:03:14,480 --> 00:03:24,110
allocation and just let you run these

00:03:19,220 --> 00:03:26,180
drivers on their own either on top of

00:03:24,110 --> 00:03:27,739
another operating system or in a

00:03:26,180 --> 00:03:31,850
special-purpose application we'll go

00:03:27,739 --> 00:03:33,829
into in a second so the easiest way to

00:03:31,850 --> 00:03:36,500
just think about it is just a way of

00:03:33,829 --> 00:03:39,650
running drivers unmodified drivers from

00:03:36,500 --> 00:03:45,200
net bsd somewhere else that you want you

00:03:39,650 --> 00:03:46,610
might want to run them and you know why

00:03:45,200 --> 00:03:48,140
might you want to do something weird

00:03:46,610 --> 00:03:49,820
like running drivers not an operating

00:03:48,140 --> 00:03:53,630
system I mean they're you know they sit

00:03:49,820 --> 00:03:56,329
there any offices and they work you fill

00:03:53,630 --> 00:03:59,600
in the you kind of fill it basically we

00:03:56,329 --> 00:04:03,110
want to fill in the gaps and use a very

00:03:59,600 --> 00:04:07,579
simple kind of virtual machine like

00:04:03,110 --> 00:04:11,359
capability to run these drivers on top

00:04:07,579 --> 00:04:12,799
of some other kind of environment and so

00:04:11,359 --> 00:04:14,720
there's been a hyper call there which is

00:04:12,799 --> 00:04:16,810
very much like a virtual machine it

00:04:14,720 --> 00:04:20,269
basically provides memory allocation

00:04:16,810 --> 00:04:23,539
threads mutexes random numbers and a

00:04:20,269 --> 00:04:25,250
clock pretty much and some are a bit of

00:04:23,539 --> 00:04:28,100
Io

00:04:25,250 --> 00:04:30,320
and the original use case of this was

00:04:28,100 --> 00:04:37,160
running this in user space on that bsd

00:04:30,320 --> 00:04:39,050
in particular with the main point of it

00:04:37,160 --> 00:04:41,000
was actually for testing and testing was

00:04:39,050 --> 00:04:42,740
kind of the way i got interested in the

00:04:41,000 --> 00:04:46,810
run kernels were because i like testing

00:04:42,740 --> 00:04:49,790
and tests testing is good and it was i

00:04:46,810 --> 00:04:53,300
started going to the talks at FOSDEM

00:04:49,790 --> 00:04:55,220
about netbsd and i've got interested in

00:04:53,300 --> 00:04:56,990
in testing on their BST and that's what

00:04:55,220 --> 00:04:58,100
kind of brought me into this imping

00:04:56,990 --> 00:04:59,690
interest in this thing in the first

00:04:58,100 --> 00:05:03,860
place

00:04:59,690 --> 00:05:06,440
and in particular you can test little

00:05:03,860 --> 00:05:08,470
parts of your kernel in isolation so you

00:05:06,440 --> 00:05:11,930
can just test a single kernel driver

00:05:08,470 --> 00:05:14,090
without having to create a system boot

00:05:11,930 --> 00:05:15,770
into it maybe the rest of the kernel

00:05:14,090 --> 00:05:19,910
doesn't isn't working cause you've

00:05:15,770 --> 00:05:21,580
broken something else because you don't

00:05:19,910 --> 00:05:26,060
have to boot into it it's much quicker

00:05:21,580 --> 00:05:29,600
you can you can build a full ramp kernel

00:05:26,060 --> 00:05:32,060
from scratch in 10-15 minutes like and

00:05:29,600 --> 00:05:36,169
less than that incrementally run the

00:05:32,060 --> 00:05:38,390
tests so it's a you've you've really got

00:05:36,169 --> 00:05:40,340
this kind of environment where you can

00:05:38,390 --> 00:05:43,970
say you're working on a on a new drive

00:05:40,340 --> 00:05:46,100
you can change it around rebuild it test

00:05:43,970 --> 00:05:47,650
it quickly runs and tests against it so

00:05:46,100 --> 00:05:49,700
and make sure it's still working and do

00:05:47,650 --> 00:05:53,150
test-driven development for drivers

00:05:49,700 --> 00:05:55,490
which has always been difficult a lot of

00:05:53,150 --> 00:05:58,870
people have worked around it in their

00:05:55,490 --> 00:06:01,220
development processes for drivers by

00:05:58,870 --> 00:06:03,470
writing a prototype driver and user

00:06:01,220 --> 00:06:05,330
space or hooking it up to use a space to

00:06:03,470 --> 00:06:09,410
poke to poke the hardware and see what

00:06:05,330 --> 00:06:11,060
happens and so on and or and but that's

00:06:09,410 --> 00:06:12,229
difficult to do with things like you

00:06:11,060 --> 00:06:14,840
know if you want to change the tcp/ip

00:06:12,229 --> 00:06:16,940
stack you've already got to boot into

00:06:14,840 --> 00:06:18,830
the system run some tests and so and

00:06:16,940 --> 00:06:23,780
then that's and ok with virtual machines

00:06:18,830 --> 00:06:26,000
that's easier but then it used to be

00:06:23,780 --> 00:06:28,460
with actual hardware but it's still

00:06:26,000 --> 00:06:31,850
actually much easier just to sit in user

00:06:28,460 --> 00:06:35,120
space run it's run GDB on it put set

00:06:31,850 --> 00:06:37,669
breakpoints see what's going wrong you

00:06:35,120 --> 00:06:38,689
know to get a core dump when it crashes

00:06:37,669 --> 00:06:40,069
and

00:06:38,689 --> 00:06:43,039
treated like a normal program you're

00:06:40,069 --> 00:06:45,669
writing and it's a it's a sort of sane

00:06:43,039 --> 00:06:50,059
and sensible way of working with staff

00:06:45,669 --> 00:06:55,519
and the other original use case apart

00:06:50,059 --> 00:06:57,319
from tests and development was running

00:06:55,519 --> 00:07:01,249
stuff in user space like file systems in

00:06:57,319 --> 00:07:05,119
user space the fuse type things but if

00:07:01,249 --> 00:07:10,189
you want and the old M tools type tools

00:07:05,119 --> 00:07:11,899
that we always used to use for with file

00:07:10,189 --> 00:07:13,849
systems and use a space way if your

00:07:11,899 --> 00:07:16,459
kernel doesn't have support for that you

00:07:13,849 --> 00:07:17,959
can run a file system use a space but

00:07:16,459 --> 00:07:21,469
again those were often kind of clunky

00:07:17,959 --> 00:07:22,610
and users use duplicated code the

00:07:21,469 --> 00:07:24,949
important thing with run kernel is the

00:07:22,610 --> 00:07:27,619
code you're running is exactly the same

00:07:24,949 --> 00:07:30,259
code and so it's not modified at all it

00:07:27,619 --> 00:07:32,839
just sits there it runs you just compile

00:07:30,259 --> 00:07:37,119
it and you know unlink it slightly

00:07:32,839 --> 00:07:37,119
differently into it into user space

00:07:38,229 --> 00:07:44,719
until very recently the apps 99% of the

00:07:42,919 --> 00:07:47,869
use case for ramp was the test suite in

00:07:44,719 --> 00:07:53,209
their PSD which has used rum for many

00:07:47,869 --> 00:07:55,699
years now it basically is specifically

00:07:53,209 --> 00:07:58,999
written for rum so it says rum penis it

00:07:55,699 --> 00:08:00,709
says rump sis make and so on or there's

00:07:58,999 --> 00:08:04,389
a there's been a hijacked library that

00:08:00,709 --> 00:08:07,999
used prelate to try and work around that

00:08:04,389 --> 00:08:09,679
and it's usable it's using the tests is

00:08:07,999 --> 00:08:11,959
pretty it's been useful for a long time

00:08:09,679 --> 00:08:13,669
but it's kind of slightly clunky and

00:08:11,959 --> 00:08:16,009
painful because you have to specifically

00:08:13,669 --> 00:08:21,409
write for a rump kernel which is a kind

00:08:16,009 --> 00:08:25,519
of weird thing to do so I started

00:08:21,409 --> 00:08:31,369
working on rump kernel about seriously

00:08:25,519 --> 00:08:32,829
about a year and a half ago and so I'm

00:08:31,369 --> 00:08:36,829
going to talk about some of the stuff

00:08:32,829 --> 00:08:38,569
that's happened really since since that

00:08:36,829 --> 00:08:41,000
period some of which I've done some

00:08:38,569 --> 00:08:42,169
which auntie who's that other main

00:08:41,000 --> 00:08:44,509
developers dorrance on which other

00:08:42,169 --> 00:08:47,839
people have done wasanta grow a decent

00:08:44,509 --> 00:08:48,580
community around ROM kernel now and -

00:08:47,839 --> 00:08:50,440
and

00:08:48,580 --> 00:08:52,779
I'll talk about some of the other things

00:08:50,440 --> 00:08:57,910
that people doing so the first thing I

00:08:52,779 --> 00:09:01,029
got involved in was someone suggested on

00:08:57,910 --> 00:09:02,740
the lure mailing list that allergic

00:09:01,029 --> 00:09:05,829
mainly mister actually which it can

00:09:02,740 --> 00:09:12,940
publish after that it might be nice to

00:09:05,829 --> 00:09:15,279
run lure directly on zen-like the the

00:09:12,940 --> 00:09:17,410
Erlang on Zen project and there's

00:09:15,279 --> 00:09:20,110
various other ones of these exons and

00:09:17,410 --> 00:09:22,149
projects mirages and things out there

00:09:20,110 --> 00:09:28,660
and I thought that's had me quite an

00:09:22,149 --> 00:09:29,740
interesting idea and I've been getting

00:09:28,660 --> 00:09:32,709
more and more interested in the ROM

00:09:29,740 --> 00:09:34,180
kernel stuff and I thought well one way

00:09:32,709 --> 00:09:38,160
of doing this would be to use the ROM

00:09:34,180 --> 00:09:41,260
kernel to provide the system layers that

00:09:38,160 --> 00:09:44,709
lure needs to run I mean lures a very

00:09:41,260 --> 00:09:48,070
straightforward POSIX portable program

00:09:44,709 --> 00:09:50,940
but it obviously needs some stuff to

00:09:48,070 --> 00:09:53,980
actually run it needs to open files and

00:09:50,940 --> 00:09:57,790
he's some memory allocation you need a

00:09:53,980 --> 00:10:04,750
basic basic system calls not a lot but

00:09:57,790 --> 00:10:10,839
it needs something so as she turned out

00:10:04,750 --> 00:10:14,440
to be relatively not too horrible to do

00:10:10,839 --> 00:10:16,779
the basic thing because then in its tree

00:10:14,440 --> 00:10:20,829
includes a really stupidly simple

00:10:16,779 --> 00:10:23,500
operating system called mini Oz which is

00:10:20,829 --> 00:10:26,620
just there well originally I think it

00:10:23,500 --> 00:10:32,380
was just there as a part of their tests

00:10:26,620 --> 00:10:34,660
and as generally as part of the example

00:10:32,380 --> 00:10:37,600
of how you actually use the Zen hyper

00:10:34,660 --> 00:10:41,230
call there so it turned out that many of

00:10:37,600 --> 00:10:43,990
us actually had pretty much everything

00:10:41,230 --> 00:10:46,570
you needed to well pretty much almost

00:10:43,990 --> 00:10:49,480
everything you needed to actually build

00:10:46,570 --> 00:10:52,390
a hype call therefore the ramp kernel

00:10:49,480 --> 00:10:54,579
built into it already because the things

00:10:52,390 --> 00:10:56,770
that the hyper call therefore rum kernel

00:10:54,579 --> 00:10:59,529
is is actually again just the stuff you

00:10:56,770 --> 00:11:02,230
expect clocks random numbers and some

00:10:59,529 --> 00:11:05,030
memory allocations so on so

00:11:02,230 --> 00:11:08,570
actually getting the rump kernel to run

00:11:05,030 --> 00:11:11,300
was relative straightforward but the

00:11:08,570 --> 00:11:13,010
thing that was actually and we wants to

00:11:11,300 --> 00:11:21,230
do was actually run an application on it

00:11:13,010 --> 00:11:23,090
which an unmodified copy of Lua so the

00:11:21,230 --> 00:11:25,370
process we went through to do this was

00:11:23,090 --> 00:11:30,520
basically well we need obviously it

00:11:25,370 --> 00:11:37,810
would we need Lib C to compile lower so

00:11:30,520 --> 00:11:41,390
we took net BST is Lib C and basically

00:11:37,810 --> 00:11:42,710
ripped out the actual system call there

00:11:41,390 --> 00:11:45,110
that actually just calls the system

00:11:42,710 --> 00:11:47,560
calls and just replaced those with calls

00:11:45,110 --> 00:11:52,250
to the equivalent ROM kernel functions

00:11:47,560 --> 00:11:57,410
and compiled the rest of Lib C with the

00:11:52,250 --> 00:12:00,230
Zen cross compiler and then compiled a

00:11:57,410 --> 00:12:02,270
library version of Lua which is rosy

00:12:00,230 --> 00:12:07,850
straightforward to do linked it all

00:12:02,270 --> 00:12:10,220
together and actually got got it to boot

00:12:07,850 --> 00:12:14,510
and got it to run the ROM kernel test

00:12:10,220 --> 00:12:17,870
suite and everything works fine and so

00:12:14,510 --> 00:12:20,570
that was really the first time we

00:12:17,870 --> 00:12:23,330
actually run a real full application on

00:12:20,570 --> 00:12:27,590
on the ramp kernel it was actually it

00:12:23,330 --> 00:12:30,580
was quite exciting and I it boots up in

00:12:27,590 --> 00:12:32,420
almost zero time because it doesn't

00:12:30,580 --> 00:12:37,490
especially if you don't mail to file

00:12:32,420 --> 00:12:41,060
system or anything like that it's really

00:12:37,490 --> 00:12:44,590
quick you can just you know run it with

00:12:41,060 --> 00:12:48,200
the Zen Excel tool bang runs your code

00:12:44,590 --> 00:12:49,910
and so this was you know so this was my

00:12:48,200 --> 00:12:52,190
first developing run kernel that it was

00:12:49,910 --> 00:13:00,320
all quite quite productive relatively

00:12:52,190 --> 00:13:04,340
painless the the patch is against Lib C

00:13:00,320 --> 00:13:06,620
that we had to do to do this were a bit

00:13:04,340 --> 00:13:12,250
messy but not too bad I'll talk about

00:13:06,620 --> 00:13:12,250
and there's a little bit more later so

00:13:12,460 --> 00:13:17,300
the next so I was quite um

00:13:15,649 --> 00:13:18,860
excited by that and I started playing

00:13:17,300 --> 00:13:21,709
around with her own kernel a bit the

00:13:18,860 --> 00:13:27,170
next thing I worked on in particular was

00:13:21,709 --> 00:13:28,939
portability at the time I started it ran

00:13:27,170 --> 00:13:32,059
the ROM can obviously runs on the net

00:13:28,939 --> 00:13:40,490
bsd was always run on that bsd it also

00:13:32,059 --> 00:13:41,990
run on Linux and it that was oh and it

00:13:40,490 --> 00:13:48,529
ran on dragonfly at that time I think

00:13:41,990 --> 00:13:51,230
and Solaris so I went around flicks the

00:13:48,529 --> 00:13:53,509
the FreeBSD OpenBSD ports which was

00:13:51,230 --> 00:13:59,689
mostly straight fairly straightforward

00:13:53,509 --> 00:14:01,459
and and Android which is a weird

00:13:59,689 --> 00:14:03,769
environment which M but I thought it's

00:14:01,459 --> 00:14:05,720
quite fun because you can boot up a rump

00:14:03,769 --> 00:14:07,730
kernel on your phone and show P shape

00:14:05,720 --> 00:14:09,050
people I did realize I haven't got it

00:14:07,730 --> 00:14:13,689
installed in this fangs like a new phone

00:14:09,050 --> 00:14:16,879
but that that's quite nice and also

00:14:13,689 --> 00:14:20,899
architectures cross builds from

00:14:16,879 --> 00:14:23,809
physically from non net bsd platforms on

00:14:20,899 --> 00:14:28,249
on these different things that were a

00:14:23,809 --> 00:14:32,350
bit of a pain but it runs on all the

00:14:28,249 --> 00:14:35,509
that I run we run its

00:14:32,350 --> 00:14:40,100
extensively tested on on you know arm

00:14:35,509 --> 00:14:41,120
x86 MIPS PowerPC it's bark and it'll

00:14:40,100 --> 00:14:42,829
probably rather than everything out

00:14:41,120 --> 00:14:49,069
there there are very few issues and how

00:14:42,829 --> 00:14:51,379
that you just need to if you if you're

00:14:49,069 --> 00:14:53,059
not using it on net bsd and you're using

00:14:51,379 --> 00:14:56,480
a different set of compilers and so on

00:14:53,059 --> 00:14:58,309
the I think we've ironed out most of

00:14:56,480 --> 00:15:00,470
those kind of basic portability issues

00:14:58,309 --> 00:15:07,759
and there there's still work to do but

00:15:00,470 --> 00:15:08,870
it's it's much better it yeah so if

00:15:07,759 --> 00:15:10,549
you've if you're putting it to another

00:15:08,870 --> 00:15:14,569
weird environment a lot of the works

00:15:10,549 --> 00:15:18,879
been done that also meant I also got

00:15:14,569 --> 00:15:22,429
involved in setting up tests so

00:15:18,879 --> 00:15:27,230
basically we do continuous integration

00:15:22,429 --> 00:15:29,390
with the run kernel code there's every

00:15:27,230 --> 00:15:32,690
commit on Travis CI which

00:15:29,390 --> 00:15:34,579
brands on it's an automated service that

00:15:32,690 --> 00:15:37,850
runs from github button or anywhere else

00:15:34,579 --> 00:15:43,220
on Linux and then there's a bill bot

00:15:37,850 --> 00:15:46,550
setup which runs on pretty much every

00:15:43,220 --> 00:15:48,170
other one of the supported platform a a

00:15:46,550 --> 00:15:52,910
large selection of the supported

00:15:48,170 --> 00:15:54,230
platforms originally just on the run

00:15:52,910 --> 00:15:56,630
kernel commits but actually of course

00:15:54,230 --> 00:16:00,440
the the run kernel is a net bsd and all

00:15:56,630 --> 00:16:04,430
the codes really in net bsd so I set up

00:16:00,440 --> 00:16:08,750
a builder to build from net bsd current

00:16:04,430 --> 00:16:12,260
which runs every currently every hour

00:16:08,750 --> 00:16:15,380
and a half you can see it looks like

00:16:12,260 --> 00:16:18,320
this I think so if you click through the

00:16:15,380 --> 00:16:20,589
link so there so this basic these are

00:16:18,320 --> 00:16:24,800
all the different platforms it builds on

00:16:20,589 --> 00:16:26,920
and it actually it does take less than

00:16:24,800 --> 00:16:32,750
an hour to run on all those on on

00:16:26,920 --> 00:16:35,360
currently on two servers with about

00:16:32,750 --> 00:16:41,540
eight virtual machines some physical

00:16:35,360 --> 00:16:44,480
machine some cross builds as I said each

00:16:41,540 --> 00:16:47,690
each build tends to only would only take

00:16:44,480 --> 00:16:49,820
maybe 10 minutes on a single machine but

00:16:47,690 --> 00:16:55,370
as they all run in parallel it slows

00:16:49,820 --> 00:16:58,640
down a little bit I saw Bill BOTS kind

00:16:55,370 --> 00:17:01,670
of annoying but it does it's easy to set

00:16:58,640 --> 00:17:03,800
it up it is annoying to do things I'd

00:17:01,670 --> 00:17:06,530
rather I'd like to do and continuous

00:17:03,800 --> 00:17:08,299
integration like and I've played around

00:17:06,530 --> 00:17:10,429
with a bit it's kind of possible to hack

00:17:08,299 --> 00:17:12,350
it but it's painful I want to put a

00:17:10,429 --> 00:17:14,240
single source because all the mend all

00:17:12,350 --> 00:17:17,990
these do their own check outs but a

00:17:14,240 --> 00:17:21,740
single source build that save the build

00:17:17,990 --> 00:17:25,370
so you can use them elsewhere run the

00:17:21,740 --> 00:17:28,189
cross compiled code on for real hardware

00:17:25,370 --> 00:17:32,000
or emulated hardware and so you can see

00:17:28,189 --> 00:17:35,660
if it actually runs because only the non

00:17:32,000 --> 00:17:37,490
cross builds run run the actual tests

00:17:35,660 --> 00:17:40,920
mostly they say a lot of it's just a

00:17:37,490 --> 00:17:44,270
build test not a runtime test which

00:17:40,920 --> 00:17:47,100
but it does care it catches a lot of the

00:17:44,270 --> 00:17:50,460
possibility regressions in net bsd so i

00:17:47,100 --> 00:17:52,429
picked those up really fast as far as

00:17:50,460 --> 00:17:55,920
I'm aware I'm the only person doing

00:17:52,429 --> 00:17:58,040
regular cross builds of net bsd so if

00:17:55,920 --> 00:18:00,900
you break something in our tool chain

00:17:58,040 --> 00:18:02,309
i'll probably notice you know within a

00:18:00,900 --> 00:18:03,840
few hours that something's broke and

00:18:02,309 --> 00:18:05,940
there's an ivan gods animated lurtz so

00:18:03,840 --> 00:18:08,360
it doesn't have something but I do tend

00:18:05,940 --> 00:18:12,780
to notice fix those things because

00:18:08,360 --> 00:18:16,610
that's kind of useful and it also use LJ

00:18:12,780 --> 00:18:19,169
Cisco which is a code I wrote before to

00:18:16,610 --> 00:18:22,830
run the case well this this is a program

00:18:19,169 --> 00:18:27,799
I wrote in Lua which or loggia again

00:18:22,830 --> 00:18:32,970
which basically understands the api's of

00:18:27,799 --> 00:18:36,090
net bsd Linux OpenBSD FreeBSD different

00:18:32,970 --> 00:18:39,720
releases of and runs cisco system calls

00:18:36,090 --> 00:18:43,830
directly against those kernels it runs

00:18:39,720 --> 00:18:45,990
about a hundred and thirty odd tests

00:18:43,830 --> 00:18:47,220
depending which which BSD you running

00:18:45,990 --> 00:18:51,030
cuz some of them are specific to a

00:18:47,220 --> 00:18:54,299
particular one and it takes about a

00:18:51,030 --> 00:18:56,870
minute so it's very much the fastest way

00:18:54,299 --> 00:18:59,760
of running a smoke test on a new build

00:18:56,870 --> 00:19:03,150
it doesn't require any compiling because

00:18:59,760 --> 00:19:08,130
it's all interpreted so it really is you

00:19:03,150 --> 00:19:10,770
know very very quick to run tests so so

00:19:08,130 --> 00:19:15,120
all so all those that aren't cross

00:19:10,770 --> 00:19:17,100
builds will run that and and so that

00:19:15,120 --> 00:19:21,690
gives us some extra confidence that

00:19:17,100 --> 00:19:23,910
someone hasn't broken something again I

00:19:21,690 --> 00:19:25,350
would that's testing at the moment I'm

00:19:23,910 --> 00:19:29,090
gonna I'll talk about a bit later about

00:19:25,350 --> 00:19:33,540
test more testing that I want to do but

00:19:29,090 --> 00:19:37,470
it's certainly you know we look we we

00:19:33,540 --> 00:19:39,480
look at this and the run kernel bills

00:19:37,470 --> 00:19:41,280
that the ROM kernel script that you use

00:19:39,480 --> 00:19:43,140
build ramp for which is for building

00:19:41,280 --> 00:19:46,640
stuff not on that if you're not using

00:19:43,140 --> 00:19:52,260
their BSD or you want to use it you know

00:19:46,640 --> 00:19:54,310
as a snapshot on that BSD we take a

00:19:52,260 --> 00:19:56,080
build that we know works take

00:19:54,310 --> 00:19:58,600
snap shot and that's available so we're

00:19:56,080 --> 00:20:02,770
happy reasonably happy that the stuff

00:19:58,600 --> 00:20:04,800
that's available for users is is working

00:20:02,770 --> 00:20:09,850
and tested and so on obviously they're

00:20:04,800 --> 00:20:12,250
they're potentially bugs but that uh you

00:20:09,850 --> 00:20:15,310
know reasonably happy that the tests now

00:20:12,250 --> 00:20:17,500
they're so running applications is the

00:20:15,310 --> 00:20:22,150
thing that was quite exciting with with

00:20:17,500 --> 00:20:25,390
the Zen port and last Christmas over

00:20:22,150 --> 00:20:27,990
Christmas last year I started thinking

00:20:25,390 --> 00:20:30,790
about whether you could actually run

00:20:27,990 --> 00:20:32,560
applications on the ramp kernel as in a

00:20:30,790 --> 00:20:34,900
straightforward way applications that

00:20:32,560 --> 00:20:36,880
aren't written as rump in it and so on

00:20:34,900 --> 00:20:38,710
specifically for RAM we're normal net

00:20:36,880 --> 00:20:43,450
bsd applications i was wondering if you

00:20:38,710 --> 00:20:46,660
could run them in the user space ports

00:20:43,450 --> 00:20:48,670
of ram kernel which is absolutely is

00:20:46,660 --> 00:20:50,410
what people mostly use because it's the

00:20:48,670 --> 00:20:52,330
easiest thing to use for testing it's

00:20:50,410 --> 00:20:55,050
what you use for driver development so

00:20:52,330 --> 00:21:00,280
on and i thought if we could run

00:20:55,050 --> 00:21:01,900
applications then i'm not necessary

00:21:00,280 --> 00:21:03,550
things i lure but the actual basic

00:21:01,900 --> 00:21:05,950
things that will be really useful

00:21:03,550 --> 00:21:08,290
because it'd been bugging me for a while

00:21:05,950 --> 00:21:10,780
was the you couldn't even run a basic

00:21:08,290 --> 00:21:12,640
thing to configure your ramp kernel

00:21:10,780 --> 00:21:16,390
because normally you know say you want

00:21:12,640 --> 00:21:20,500
to test the raid drivers you need to

00:21:16,390 --> 00:21:23,320
build a raid set and you know there's a

00:21:20,500 --> 00:21:25,780
there's a bunch of commands to command

00:21:23,320 --> 00:21:27,640
line commands to build that but you

00:21:25,780 --> 00:21:31,330
can't actually run that has come out and

00:21:27,640 --> 00:21:32,710
so what you had to do was basically at

00:21:31,330 --> 00:21:35,650
the moment if he wants to write say

00:21:32,710 --> 00:21:38,560
either a test for the rate system or or

00:21:35,650 --> 00:21:41,560
if he wants just experiment you know

00:21:38,560 --> 00:21:44,890
modifies you basically had to write

00:21:41,560 --> 00:21:47,310
something that custom for the run kernel

00:21:44,890 --> 00:21:49,660
that did the the i/o kettle or whatever

00:21:47,310 --> 00:21:51,520
commands the the subsystem you're

00:21:49,660 --> 00:21:52,810
working on needed and that was you know

00:21:51,520 --> 00:21:56,950
kind of annoying if you want to do

00:21:52,810 --> 00:21:59,380
anything complicated so i thought maybe

00:21:56,950 --> 00:22:02,430
there's some way away in which we can

00:21:59,380 --> 00:22:04,930
get the stuff to compile in user space

00:22:02,430 --> 00:22:08,059
originally the first thing i came up

00:22:04,930 --> 00:22:14,600
with its we involved

00:22:08,059 --> 00:22:17,809
compiling the net BSD code as a shared

00:22:14,600 --> 00:22:21,340
library and loading it into a wrapper

00:22:17,809 --> 00:22:24,890
program that called called main in the

00:22:21,340 --> 00:22:26,270
in the shared library and it worked it

00:22:24,890 --> 00:22:31,540
was a bit horrible but it kind of worked

00:22:26,270 --> 00:22:36,610
heard that this was actually possible

00:22:31,540 --> 00:22:39,380
then are a bit of a month or two later I

00:22:36,610 --> 00:22:41,929
decided it was too annoying and I

00:22:39,380 --> 00:22:45,470
managed to write another version wait

00:22:41,929 --> 00:22:50,059
basically a script there which it's kind

00:22:45,470 --> 00:22:52,640
of basically that the main issue is that

00:22:50,059 --> 00:22:55,640
you've got you're trying to run a net

00:22:52,640 --> 00:22:58,100
bsd Lipsy in order to compile your net

00:22:55,640 --> 00:23:00,080
bsd and commands but you're also running

00:22:58,100 --> 00:23:01,929
a Lib C on the house and of course they

00:23:00,080 --> 00:23:07,190
have exactly the same symbols in them

00:23:01,929 --> 00:23:08,630
and so but once it's supposed to beat

00:23:07,190 --> 00:23:10,340
off the run kernel one sets actually

00:23:08,630 --> 00:23:14,620
supporting it so talking to your real

00:23:10,340 --> 00:23:16,880
kernel and obviously this is a big mess

00:23:14,620 --> 00:23:18,550
if you just try and link your programs

00:23:16,880 --> 00:23:22,730
together it's just not going to work so

00:23:18,550 --> 00:23:26,750
I came up with a scheme that does work

00:23:22,730 --> 00:23:31,910
which basically does a whole bunch of

00:23:26,750 --> 00:23:34,300
symbol renaming and I'll tell you

00:23:31,910 --> 00:23:37,880
exactly in a minute

00:23:34,300 --> 00:23:41,540
but it works and you can basically

00:23:37,880 --> 00:23:43,550
compile there's a little script that

00:23:41,540 --> 00:23:46,490
compiles stuff out of the net bsd tree

00:23:43,550 --> 00:23:53,960
and so you can compile pretty much all

00:23:46,490 --> 00:24:00,020
the the core user space stuff and the

00:23:53,960 --> 00:24:01,309
way it works basically is you you take

00:24:00,020 --> 00:24:04,160
your the stuff you're building from

00:24:01,309 --> 00:24:07,070
there bsd you link it all without host

00:24:04,160 --> 00:24:09,590
Lipsy at all and then use object copy to

00:24:07,070 --> 00:24:12,950
rename a bunch of symbols so that they

00:24:09,590 --> 00:24:15,260
point at the ramp symbols fix up a few

00:24:12,950 --> 00:24:16,240
horrible things like main because you

00:24:15,260 --> 00:24:20,890
don't have another main

00:24:16,240 --> 00:24:23,440
Lincoln localized all the symbol names

00:24:20,890 --> 00:24:27,100
in the object that you've created so

00:24:23,440 --> 00:24:29,920
that they and then link it him with rump

00:24:27,100 --> 00:24:31,870
and the host lip see if you could click

00:24:29,920 --> 00:24:34,570
on that link there you can see the

00:24:31,870 --> 00:24:36,280
script I do have a plan to rewrite to do

00:24:34,570 --> 00:24:42,610
a third rewrite to make it even nicer

00:24:36,280 --> 00:24:44,020
and more straightforward but it's at the

00:24:42,610 --> 00:24:45,730
moment there's a cross compiler now

00:24:44,020 --> 00:24:49,710
which will cross compile this and run

00:24:45,730 --> 00:24:53,679
the link scripts as it's a GCC wrapper

00:24:49,710 --> 00:25:00,190
which works fine and works on that BST

00:24:53,679 --> 00:25:02,770
and it was some Linux it you can hack it

00:25:00,190 --> 00:25:06,070
to work on FreeBSD but FreeBSD GCC is

00:25:02,770 --> 00:25:10,559
doing something a bit weird and so it's

00:25:06,070 --> 00:25:15,090
a bit hacky but it needs fixing but um

00:25:10,559 --> 00:25:17,650
but basically it's it's usable and it's

00:25:15,090 --> 00:25:21,550
and here's an example of how use it

00:25:17,650 --> 00:25:23,500
there's this there's kind of two modes

00:25:21,550 --> 00:25:25,809
for using the wrong kernel user space

00:25:23,500 --> 00:25:28,059
this is example with the the rump server

00:25:25,809 --> 00:25:29,890
and now the rump servers a thing that

00:25:28,059 --> 00:25:33,370
basically runs the ROM kernel in one

00:25:29,890 --> 00:25:35,020
process and you send it Comeau system

00:25:33,370 --> 00:25:39,910
calls from another process which seems a

00:25:35,020 --> 00:25:42,520
slightly odd thing to want to do but

00:25:39,910 --> 00:25:44,260
otherwise you tend to run the rom kernel

00:25:42,520 --> 00:25:46,179
and then when you terminate the process

00:25:44,260 --> 00:25:49,990
the rom kernel terminates which means

00:25:46,179 --> 00:25:52,300
effectively in sort of machine terms you

00:25:49,990 --> 00:25:55,780
boot up your machine it runs something

00:25:52,300 --> 00:25:57,850
and it stops which isn't that much use

00:25:55,780 --> 00:26:00,280
if you want to just modify the state of

00:25:57,850 --> 00:26:03,460
something so the the remote process like

00:26:00,280 --> 00:26:06,970
this you can just run the the newly

00:26:03,460 --> 00:26:07,870
compiled I have config and you get you

00:26:06,970 --> 00:26:09,190
know you can see your network interface

00:26:07,870 --> 00:26:15,490
you can just create a new network

00:26:09,190 --> 00:26:17,440
interfaces you can ping stuff it pretty

00:26:15,490 --> 00:26:18,940
much everything works as a set of test

00:26:17,440 --> 00:26:22,450
scripts that runs through and creates

00:26:18,940 --> 00:26:25,030
raid devices and so on in the in the

00:26:22,450 --> 00:26:28,360
repository this is the current list of

00:26:25,030 --> 00:26:30,110
supported commands have reasonably been

00:26:28,360 --> 00:26:37,130
tested

00:26:30,110 --> 00:26:38,510
and most of them are useful some things

00:26:37,130 --> 00:26:42,220
in a trump colonel context aren't

00:26:38,510 --> 00:26:46,539
particularly useful in a but basically

00:26:42,220 --> 00:26:50,960
create from creating file systems

00:26:46,539 --> 00:26:54,500
creating network interfaces assist

00:26:50,960 --> 00:26:57,890
careful mounting file systems making

00:26:54,500 --> 00:27:01,010
directories copying stuff into the in

00:26:57,890 --> 00:27:02,889
and out of the rump kernel bit of

00:27:01,010 --> 00:27:05,870
permissions and stuff like that

00:27:02,889 --> 00:27:06,950
making device nodes which obvious you

00:27:05,870 --> 00:27:13,760
need to do when you want to talk to

00:27:06,950 --> 00:27:19,309
devices stuff a wireless so wireless

00:27:13,760 --> 00:27:22,039
devices you can deal with that encrypted

00:27:19,309 --> 00:27:24,110
device is encrypt your files and stuff

00:27:22,039 --> 00:27:27,710
like that so it's it's a decent say it's

00:27:24,110 --> 00:27:30,559
really easy to add more stuff um it's

00:27:27,710 --> 00:27:32,480
just a bit you just need to test it it

00:27:30,559 --> 00:27:35,090
could do with more tests as well to make

00:27:32,480 --> 00:27:36,649
sure that but most things work there's a

00:27:35,090 --> 00:27:41,389
few weirdnesses because of things around

00:27:36,649 --> 00:27:43,750
kernel doesn't support in particular ROM

00:27:41,389 --> 00:27:47,570
kernel doesn't we support signals so

00:27:43,750 --> 00:27:50,240
occasionally things use signals the net

00:27:47,570 --> 00:27:56,230
bsd implementation of ping six we're not

00:27:50,240 --> 00:28:00,799
paying it uses a timer with a signal so

00:27:56,230 --> 00:28:08,720
you can only paint once and then it just

00:28:00,799 --> 00:28:10,309
sits there waiting but generally you can

00:28:08,720 --> 00:28:11,720
just use the stuff as if you're using a

00:28:10,309 --> 00:28:13,190
normal computer i mean that's the thing

00:28:11,720 --> 00:28:16,010
you can just sit there there's a little

00:28:13,190 --> 00:28:17,480
shell wrapper that sets the paths and

00:28:16,010 --> 00:28:18,679
shows you which ROM Colonel you're

00:28:17,480 --> 00:28:20,149
talking to and you can just sit there

00:28:18,679 --> 00:28:23,080
and do I have config and stuff like that

00:28:20,149 --> 00:28:27,350
and and it can just sit there and run

00:28:23,080 --> 00:28:29,389
and you can just script it all to set up

00:28:27,350 --> 00:28:30,919
you your ROM kernel how you want for

00:28:29,389 --> 00:28:39,470
testing your driver your writing and so

00:28:30,919 --> 00:28:40,909
on so basically it's you've suddenly got

00:28:39,470 --> 00:28:43,010
this whole user space you can suddenly

00:28:40,909 --> 00:28:45,370
start actually configuring drivers

00:28:43,010 --> 00:28:47,840
testing

00:28:45,370 --> 00:28:51,320
there's this cross-compiler that can

00:28:47,840 --> 00:28:54,920
probably run most userspace code there's

00:28:51,320 --> 00:28:57,170
some thread support which is a bit

00:28:54,920 --> 00:28:59,420
experimental but has been checked it

00:28:57,170 --> 00:29:00,800
does work as well so that's kind of say

00:28:59,420 --> 00:29:04,270
if you've got code that uses threads you

00:29:00,800 --> 00:29:07,100
can even run that hasn't been tested

00:29:04,270 --> 00:29:09,980
hugely heavily there's a few things that

00:29:07,100 --> 00:29:13,010
use fork that and so on which may or may

00:29:09,980 --> 00:29:15,410
not be support there is actually the the

00:29:13,010 --> 00:29:19,490
run promote does have an emulation for

00:29:15,410 --> 00:29:21,680
Forks so things do kind of work and in

00:29:19,490 --> 00:29:23,720
fact mostly to work in user space but

00:29:21,680 --> 00:29:26,060
they obviously won't run in a rump

00:29:23,720 --> 00:29:28,430
kernel somewhere else but for so for the

00:29:26,060 --> 00:29:30,260
user space tools that call fork and exec

00:29:28,430 --> 00:29:31,970
and so on actually there's enough

00:29:30,260 --> 00:29:35,900
emulation Tomatoes work so you can

00:29:31,970 --> 00:29:37,610
pretty much there's basically a bun a

00:29:35,900 --> 00:29:38,960
little emulation layer that emulates the

00:29:37,610 --> 00:29:44,420
things that you can emulate in user

00:29:38,960 --> 00:29:46,250
space so a lot of you a lot of anonymous

00:29:44,420 --> 00:29:50,030
air map and things like that rule or

00:29:46,250 --> 00:29:54,860
work it's it's it's a decent way to run

00:29:50,030 --> 00:29:57,440
stuff it does need cleaning up and up

00:29:54,860 --> 00:29:59,240
streaming the the patches to Lipsy are

00:29:57,440 --> 00:30:01,160
now very small because i upstream most

00:29:59,240 --> 00:30:04,370
of this they're only patches to the make

00:30:01,160 --> 00:30:06,710
files there's no actual patches to live

00:30:04,370 --> 00:30:09,170
sea at all it's not modified lip see it

00:30:06,710 --> 00:30:14,720
just doesn't build in the SIS called

00:30:09,170 --> 00:30:20,540
stubs and it that's really the main

00:30:14,720 --> 00:30:24,080
change but it needs a bit of and it's

00:30:20,540 --> 00:30:26,960
all there's a flag around if deficit and

00:30:24,080 --> 00:30:29,780
everything it's it's all the small

00:30:26,960 --> 00:30:33,350
things got fixed over time I think and

00:30:29,780 --> 00:30:36,830
there's a so just I'll probably work on

00:30:33,350 --> 00:30:39,050
up streaming it when I get back it also

00:30:36,830 --> 00:30:41,090
needs fixing for northern x86

00:30:39,050 --> 00:30:43,520
architectures just again just adding the

00:30:41,090 --> 00:30:48,110
extra defines render things in the make

00:30:43,520 --> 00:30:50,000
file it's only just dealing with that

00:30:48,110 --> 00:30:53,030
that system call there and I think if we

00:30:50,000 --> 00:30:56,150
if we it's very non intrusive it's again

00:30:53,030 --> 00:30:58,260
as I said it's just in the make file

00:30:56,150 --> 00:31:00,660
I'd like to build some more accuser

00:30:58,260 --> 00:31:05,309
space and libraries I mean it might as

00:31:00,660 --> 00:31:06,750
well just build everything really but I

00:31:05,309 --> 00:31:08,820
mean things like it would be nice to

00:31:06,750 --> 00:31:10,559
build those @fs tools so that it's easy

00:31:08,820 --> 00:31:12,320
for someone start when someone decides

00:31:10,559 --> 00:31:17,429
they want to start doing more work on

00:31:12,320 --> 00:31:19,320
deputies at first then having those

00:31:17,429 --> 00:31:22,740
tools those NFS tools built would be

00:31:19,320 --> 00:31:24,660
useful so you can because file systems

00:31:22,740 --> 00:31:27,480
are a perfect thing for running a user

00:31:24,660 --> 00:31:29,250
space you just need to put a file to use

00:31:27,480 --> 00:31:30,840
as a block device and you can you can

00:31:29,250 --> 00:31:32,659
get going over for files if you need

00:31:30,840 --> 00:31:34,710
multiple block devices it's actually

00:31:32,659 --> 00:31:37,500
really straightforward there's no need

00:31:34,710 --> 00:31:42,150
to ever have a booter file system while

00:31:37,500 --> 00:31:44,700
you're developing it at all so you can

00:31:42,150 --> 00:31:48,120
should be able to just do those in user

00:31:44,700 --> 00:31:50,610
space and then I even had I had a chat

00:31:48,120 --> 00:31:52,260
with one thing young Linux said if s on

00:31:50,610 --> 00:31:55,650
the next developers who said you might

00:31:52,260 --> 00:31:58,590
work on NFS Mozilla Fest Fernet BSD if

00:31:55,650 --> 00:31:59,880
he if he could do it all in Linux it

00:31:58,590 --> 00:32:02,250
didn't have to actually huge net beers

00:31:59,880 --> 00:32:07,140
do you say you know it's as easy for

00:32:02,250 --> 00:32:10,440
these things I'd like to run no BSD

00:32:07,140 --> 00:32:11,760
tests using this which would be really

00:32:10,440 --> 00:32:13,950
nice because it basically means you can

00:32:11,760 --> 00:32:16,409
run users based tests without actually

00:32:13,950 --> 00:32:17,539
booting the kernel at all which would be

00:32:16,409 --> 00:32:21,780
nice

00:32:17,539 --> 00:32:24,630
so as you're developing stuff rather

00:32:21,780 --> 00:32:26,669
than doing a full colonel build install

00:32:24,630 --> 00:32:29,400
and it's not I mean a nice is nice and

00:32:26,669 --> 00:32:33,150
easy and it's quite great but just being

00:32:29,400 --> 00:32:35,010
able to do make and execute you your

00:32:33,150 --> 00:32:36,390
test script just there without actually

00:32:35,010 --> 00:32:38,870
even you know as your as you're

00:32:36,390 --> 00:32:45,150
developing makes it easier to do

00:32:38,870 --> 00:32:47,490
test-driven development so on and the

00:32:45,150 --> 00:32:50,520
build process for the user space stuff

00:32:47,490 --> 00:32:54,090
is a bit slow and longer than it should

00:32:50,520 --> 00:32:55,350
be but it's one of these things I mean

00:32:54,090 --> 00:32:57,720
one of the things I've spent most time

00:32:55,350 --> 00:33:00,150
in doing since I've been working on run

00:32:57,720 --> 00:33:03,510
kernel is looking at build processes and

00:33:00,150 --> 00:33:04,620
watching them scroll past and wondering

00:33:03,510 --> 00:33:06,580
why they're broken and trying to fix

00:33:04,620 --> 00:33:09,309
them and them

00:33:06,580 --> 00:33:13,179
in a way rum Colonel is mostly about

00:33:09,309 --> 00:33:14,590
building it doesn't actually there's not

00:33:13,179 --> 00:33:16,360
actually a lot of code in it there's a

00:33:14,590 --> 00:33:25,149
little bit there's a lot more build and

00:33:16,360 --> 00:33:26,200
make files than there is code and I'd

00:33:25,149 --> 00:33:28,240
like to do continuous integration

00:33:26,200 --> 00:33:31,289
testing if the ramp run code on current

00:33:28,240 --> 00:33:35,200
at the moment is because there's these

00:33:31,289 --> 00:33:37,270
Lipsy make file patches which are

00:33:35,200 --> 00:33:39,429
annoying when those are upstream to be

00:33:37,270 --> 00:33:44,140
able to run it on current which would be

00:33:39,429 --> 00:33:46,779
nice more things we've been working on

00:33:44,140 --> 00:33:53,980
I wrote a green threads implementation

00:33:46,779 --> 00:33:56,260
of the user space the run kernel hyper

00:33:53,980 --> 00:33:57,640
call there which is a funny thing to

00:33:56,260 --> 00:34:00,100
want to do I mean it

00:33:57,640 --> 00:34:03,549
it runs on P threads anomaly which is as

00:34:00,100 --> 00:34:06,850
you kind of as you'd expect this

00:34:03,549 --> 00:34:10,869
basically just uses get context swap

00:34:06,850 --> 00:34:12,760
context to sir compiles on most things

00:34:10,869 --> 00:34:16,440
and runs the whole netbsd kernel

00:34:12,760 --> 00:34:23,220
basically as a uniprocessor kernel in a

00:34:16,440 --> 00:34:25,720
single single process with no threads

00:34:23,220 --> 00:34:27,730
one of the main aims of this was

00:34:25,720 --> 00:34:31,000
actually for running on embedded stuff

00:34:27,730 --> 00:34:34,030
where you want to compile ROM kernel but

00:34:31,000 --> 00:34:36,490
you don't actually have a whole be

00:34:34,030 --> 00:34:37,720
threads library to run it on so it won't

00:34:36,490 --> 00:34:42,669
compile so you've got something really

00:34:37,720 --> 00:34:44,589
basic but there's also got other uses it

00:34:42,669 --> 00:34:45,790
would be really easy and quite fun to

00:34:44,589 --> 00:34:49,629
make an entirely deterministic

00:34:45,790 --> 00:34:51,129
implementation run kernel is kind of

00:34:49,629 --> 00:34:52,389
straightforward and particularly with

00:34:51,129 --> 00:34:53,889
this implementation it's very

00:34:52,389 --> 00:34:56,889
straightforward all the threads run to

00:34:53,889 --> 00:35:00,130
completion or when they block and then

00:34:56,889 --> 00:35:01,450
it switches to another thread so the

00:35:00,130 --> 00:35:04,240
only stuff that makes it

00:35:01,450 --> 00:35:05,560
non-deterministic is the input that

00:35:04,240 --> 00:35:06,849
comes in through the run piper call

00:35:05,560 --> 00:35:09,670
there which is the random numbers and

00:35:06,849 --> 00:35:11,950
the clock and anything you've got a file

00:35:09,670 --> 00:35:18,310
system or something like that but doing

00:35:11,950 --> 00:35:19,660
things like exact replay of your netbsd

00:35:18,310 --> 00:35:21,069
test case for example

00:35:19,660 --> 00:35:23,440
should be possible just by feeding in

00:35:21,069 --> 00:35:29,170
the same time stamps and random numbers

00:35:23,440 --> 00:35:32,710
and so you should be able to do things

00:35:29,170 --> 00:35:35,440
like reproduce bugs exactly even if

00:35:32,710 --> 00:35:38,410
they're non-deterministic and so on or

00:35:35,440 --> 00:35:40,119
modify things and modify timings until

00:35:38,410 --> 00:35:41,920
you get you hit a non-deterministic bug

00:35:40,119 --> 00:35:44,650
and then be able to give it to someone

00:35:41,920 --> 00:35:47,470
say look run this this this drivers got

00:35:44,650 --> 00:35:49,720
this lock up in this situation things

00:35:47,470 --> 00:35:51,270
like that so I think I think that would

00:35:49,720 --> 00:35:53,230
be quite a fun thing to do it should be

00:35:51,270 --> 00:35:54,730
really easy now because all the

00:35:53,230 --> 00:35:58,390
scheduling stuffs all deterministic it's

00:35:54,730 --> 00:36:01,059
just the input state that's that's not

00:35:58,390 --> 00:36:03,609
that's and but as that all comes through

00:36:01,059 --> 00:36:06,460
this small run pipe call there's it's

00:36:03,609 --> 00:36:08,740
entirely easy to replay the same values

00:36:06,460 --> 00:36:13,869
we're on the same on the same hyper

00:36:08,740 --> 00:36:17,740
calls so that's a project for anyone who

00:36:13,869 --> 00:36:21,609
would like a nice project next thing the

00:36:17,740 --> 00:36:24,849
anti-air did was PCI support the

00:36:21,609 --> 00:36:29,250
original the first lis in the next user

00:36:24,849 --> 00:36:32,829
space because Linux has conveniently has

00:36:29,250 --> 00:36:37,180
bring the next two users ways of writing

00:36:32,829 --> 00:36:38,829
user space PCI drivers they're both

00:36:37,180 --> 00:36:41,130
differently annoying it's very typical

00:36:38,829 --> 00:36:44,410
of Linux

00:36:41,130 --> 00:36:49,480
the one we've done so far is you IO

00:36:44,410 --> 00:36:55,930
which is quite simple works for a lot of

00:36:49,480 --> 00:36:59,980
devices but it doesn't work with some

00:36:55,930 --> 00:37:02,680
other devices doesn't like MSI

00:36:59,980 --> 00:37:07,569
interrupts I think and very it'll just

00:37:02,680 --> 00:37:10,210
say no for some devices but it runs but

00:37:07,569 --> 00:37:12,490
it will for example run most wireless

00:37:10,210 --> 00:37:15,150
cards for example and certainly aunty

00:37:12,490 --> 00:37:17,980
did some wireless device development

00:37:15,150 --> 00:37:20,500
using the ramp kernel entirely in user

00:37:17,980 --> 00:37:24,039
space on linux to write an FPS new

00:37:20,500 --> 00:37:29,049
driver and you can sit there you can

00:37:24,039 --> 00:37:30,970
start you can basically reinitialize the

00:37:29,049 --> 00:37:32,490
divisive area if your driver goes wrong

00:37:30,970 --> 00:37:36,010
as you're developing it

00:37:32,490 --> 00:37:39,160
you know you don't have to you can you

00:37:36,010 --> 00:37:40,990
know just sits there it's it's not it's

00:37:39,160 --> 00:37:42,310
not being used by the house you disable

00:37:40,990 --> 00:37:44,290
it from the host colonel to the host

00:37:42,310 --> 00:37:46,330
Colonel doesn't talk to it and you've

00:37:44,290 --> 00:37:50,830
got full control over it you can run

00:37:46,330 --> 00:37:53,410
your driver in userspace and so this is

00:37:50,830 --> 00:37:58,860
this is really useful if you want to

00:37:53,410 --> 00:38:00,820
work on develop me a new pci driver and

00:37:58,860 --> 00:38:02,440
and you want to make it much more

00:38:00,820 --> 00:38:05,290
difficult to lock up your machine and so

00:38:02,440 --> 00:38:07,870
on while you're doing it and you don't

00:38:05,290 --> 00:38:10,080
and you can you want you can use GDB on

00:38:07,870 --> 00:38:14,230
it and things like that

00:38:10,080 --> 00:38:16,420
the second Linux one vfi oh I'll

00:38:14,230 --> 00:38:21,550
probably write a driver for that you

00:38:16,420 --> 00:38:23,020
need an iommu to use that and most of

00:38:21,550 --> 00:38:27,040
the machines I've got don't have iommu

00:38:23,020 --> 00:38:32,980
so but I think I've I've got one that

00:38:27,040 --> 00:38:34,060
does now so I'll try and fix that it

00:38:32,980 --> 00:38:37,780
would be really nice to be able to run

00:38:34,060 --> 00:38:40,570
it under a BSD my current thought that

00:38:37,780 --> 00:38:44,020
I've not spent much only a quick look at

00:38:40,570 --> 00:38:47,650
is that FreeBSD is probably the next

00:38:44,020 --> 00:38:49,930
easiest target with because Bhide

00:38:47,650 --> 00:38:53,290
basically has users based PC our driver

00:38:49,930 --> 00:38:55,990
framework now and I reckon it should be

00:38:53,290 --> 00:38:58,840
possible to adapt fast because that lets

00:38:55,990 --> 00:39:01,600
you put devices into your hypervisor I

00:38:58,840 --> 00:39:03,940
mean into your professional machines and

00:39:01,600 --> 00:39:05,740
that's pretty much all unity basically

00:39:03,940 --> 00:39:07,030
you want to remove them from the host

00:39:05,740 --> 00:39:08,530
kernel and be able to talk to them from

00:39:07,030 --> 00:39:12,220
user base it's pretty much the same

00:39:08,530 --> 00:39:14,380
thing so I reckon a freebsd port will be

00:39:12,220 --> 00:39:17,650
quite easy and then that will probably

00:39:14,380 --> 00:39:27,910
be applicable to net bsd much more

00:39:17,650 --> 00:39:31,000
straightforwardly but but that's it it's

00:39:27,910 --> 00:39:33,010
definitely a real real improvement for a

00:39:31,000 --> 00:39:36,010
device driver development not having to

00:39:33,010 --> 00:39:39,780
actually develop your device driver oh

00:39:36,010 --> 00:39:39,780
oh you know honor

00:39:39,940 --> 00:39:48,440
while actually having to boot it the

00:39:42,079 --> 00:39:50,180
kernel into it especially and without

00:39:48,440 --> 00:39:51,829
having to do things like pass-through to

00:39:50,180 --> 00:39:53,960
it and virtual machine and so on which

00:39:51,829 --> 00:40:00,200
you can do but it's you know it's much

00:39:53,960 --> 00:40:02,690
easy just iterate in user space there's

00:40:00,200 --> 00:40:04,790
also anti decided that he as well as

00:40:02,690 --> 00:40:06,380
booting on Zen he wants to be able to

00:40:04,790 --> 00:40:11,630
boot on various other hypervisors in

00:40:06,380 --> 00:40:15,470
particular so there's a he did a project

00:40:11,630 --> 00:40:18,290
a few months ago basically to boot on a

00:40:15,470 --> 00:40:24,290
basically a either bare metal or a

00:40:18,290 --> 00:40:27,710
virtualized x86 machine this is it's a

00:40:24,290 --> 00:40:31,579
very it's a really small it took him a

00:40:27,710 --> 00:40:32,900
week to write it so it's but in a way

00:40:31,579 --> 00:40:34,720
that's the thing about the wrong

00:40:32,900 --> 00:40:37,010
character you've got all the drivers so

00:40:34,720 --> 00:40:40,130
in a week we're the hundred lines of

00:40:37,010 --> 00:40:41,930
code you've got a kernel you can boot it

00:40:40,130 --> 00:40:44,690
up and it's got PCI supports it's got

00:40:41,930 --> 00:40:47,750
vertigo support so if you're under KVM

00:40:44,690 --> 00:40:52,670
you can get the emulated network device

00:40:47,750 --> 00:40:55,180
and disk and it will run on actual hard

00:40:52,670 --> 00:41:00,609
way up with a you know with a bus it's

00:40:55,180 --> 00:41:03,380
x86 32-bit only at the minute and it's

00:41:00,609 --> 00:41:05,720
it uses the green prototype cage so it

00:41:03,380 --> 00:41:12,829
doesn't have Hardware threads on a

00:41:05,720 --> 00:41:16,069
single processor but it it's a proof of

00:41:12,829 --> 00:41:19,780
concept really the the my plan with this

00:41:16,069 --> 00:41:22,400
is to do an arm port the embed

00:41:19,780 --> 00:41:24,770
microcontroller platform see if I can

00:41:22,400 --> 00:41:26,750
fit netbsd rum kernel onto a micro

00:41:24,770 --> 00:41:34,609
controller that's too small to actually

00:41:26,750 --> 00:41:36,950
run a net bsd proper and so I need to

00:41:34,609 --> 00:41:38,540
you know see how small I can squeeze it

00:41:36,950 --> 00:41:40,609
in to try and boot it on a micro

00:41:38,540 --> 00:41:44,060
controller because that would be a again

00:41:40,609 --> 00:41:45,859
a fun thing that where this kind of bare

00:41:44,060 --> 00:41:47,270
metal thing which doesn't have a full

00:41:45,859 --> 00:41:50,510
operating system it just has the

00:41:47,270 --> 00:41:52,140
absolute minimum you need to run kind of

00:41:50,510 --> 00:41:57,150
makes a lot of sense

00:41:52,140 --> 00:41:58,470
and and that's the nice thing about you

00:41:57,150 --> 00:42:00,030
know never yesterday is very poor

00:41:58,470 --> 00:42:01,650
support of this kind of thing so you can

00:42:00,030 --> 00:42:06,480
run it on a maybe on an even smaller

00:42:01,650 --> 00:42:09,210
toaster than previously so I'm yeah I've

00:42:06,480 --> 00:42:13,440
got a little microcontroller with a

00:42:09,210 --> 00:42:18,170
Ethernet but I'm hoping to play around

00:42:13,440 --> 00:42:21,930
with and get that running on the main

00:42:18,170 --> 00:42:23,940
the thing is working on how little

00:42:21,930 --> 00:42:26,700
memory and storage you can get away with

00:42:23,940 --> 00:42:28,620
so I bought one with it's like excess of

00:42:26,700 --> 00:42:30,780
memory and storage so I can start big

00:42:28,620 --> 00:42:33,360
and cut it down to to a more standard

00:42:30,780 --> 00:42:36,000
size my controller see how much space it

00:42:33,360 --> 00:42:38,580
actually takes up so much you can

00:42:36,000 --> 00:42:40,140
optimize the build and depending what

00:42:38,580 --> 00:42:46,140
you want to run on there but that's my

00:42:40,140 --> 00:42:48,270
one of my experiments another thing that

00:42:46,140 --> 00:42:52,320
happened completely outside the net bsd

00:42:48,270 --> 00:42:54,570
community as the gino decided that they

00:42:52,320 --> 00:42:59,070
needed some file system drivers and gene

00:42:54,570 --> 00:43:01,170
aid is i think the correct thing to call

00:42:59,070 --> 00:43:02,640
it is a operating system framework

00:43:01,170 --> 00:43:09,540
rather than operating system they

00:43:02,640 --> 00:43:15,710
support the l4 microkernel and they have

00:43:09,540 --> 00:43:19,250
basically changed it to run the net PSD

00:43:15,710 --> 00:43:21,930
file system drivers on they cannot in as

00:43:19,250 --> 00:43:25,920
microkernel type user space processes

00:43:21,930 --> 00:43:27,410
with 3,000 licenses untrusted carried

00:43:25,920 --> 00:43:30,150
that runs there so that's quite exciting

00:43:27,410 --> 00:43:34,370
we also got a lego which is quite

00:43:30,150 --> 00:43:36,510
exciting so fundamentally there are four

00:43:34,370 --> 00:43:40,530
different environments that we now

00:43:36,510 --> 00:43:42,750
support the ROM kernel running on say

00:43:40,530 --> 00:43:45,210
Jesus Base hosted the sort of original

00:43:42,750 --> 00:43:47,580
sin and one there's an paravirtualized

00:43:45,210 --> 00:43:51,780
type environment the bare metal one or

00:43:47,580 --> 00:43:53,580
micro kernels as servers and that's

00:43:51,780 --> 00:43:55,260
basically and the sisters of

00:43:53,580 --> 00:43:57,690
architecture of it which you probably

00:43:55,260 --> 00:44:00,570
can't see very well there look at it we

00:43:57,690 --> 00:44:03,510
have much better documentation still is

00:44:00,570 --> 00:44:04,930
improving but there's a wiki there's a

00:44:03,510 --> 00:44:10,880
lot of stuff

00:44:04,930 --> 00:44:12,920
and there's a lot still to do in

00:44:10,880 --> 00:44:15,200
improving documentation and upstream

00:44:12,920 --> 00:44:17,270
e'en so and people are really interested

00:44:15,200 --> 00:44:19,450
in high performance network stacks in

00:44:17,270 --> 00:44:24,290
userspace

00:44:19,450 --> 00:44:25,640
so come and get involved this is where

00:44:24,290 --> 00:44:27,680
we are I'm running an operating system

00:44:25,640 --> 00:44:29,990
conference in London on 25th November

00:44:27,680 --> 00:44:32,120
which you should come to and there's a

00:44:29,990 --> 00:44:34,510
hack run kernel hack day the day after

00:44:32,120 --> 00:44:37,580
it also in London following on from that

00:44:34,510 --> 00:44:41,600
we'd also be a foster my think me and

00:44:37,580 --> 00:44:43,490
Auntie there's a mailing list freenode

00:44:41,600 --> 00:44:46,070
run kernel there's usually someone

00:44:43,490 --> 00:44:48,790
around come on come on ask questions and

00:44:46,070 --> 00:44:48,790
get some help

00:44:55,770 --> 00:44:58,550
questions

00:45:05,849 --> 00:45:14,920
right um I just great talk thank you I

00:45:12,210 --> 00:45:16,599
remember and I know you know ending but

00:45:14,920 --> 00:45:18,670
it's I remember aunty writing at some

00:45:16,599 --> 00:45:22,420
point I have a keen disinterest in

00:45:18,670 --> 00:45:24,039
hardware and he was explicitly not going

00:45:22,420 --> 00:45:25,990
to the root of um controlling hardware

00:45:24,039 --> 00:45:27,910
do you know what it was and where there

00:45:25,990 --> 00:45:32,769
changed um

00:45:27,910 --> 00:45:35,049
I think someone as far as I can work out

00:45:32,769 --> 00:45:37,900
someone paid him to write a wireless

00:45:35,049 --> 00:45:40,930
driver he hated it and he still has the

00:45:37,900 --> 00:45:43,150
hardware but he will he will write

00:45:40,930 --> 00:45:45,249
drivers if you ask him and so he decided

00:45:43,150 --> 00:45:50,349
he would write it all using ramp in

00:45:45,249 --> 00:45:51,609
userspace Wireless was a really good

00:45:50,349 --> 00:45:53,140
test of all the user space

00:45:51,609 --> 00:45:55,150
infrastructure because you have to

00:45:53,140 --> 00:45:56,890
configure your wireless card set up you

00:45:55,150 --> 00:45:58,690
know points of access points and all

00:45:56,890 --> 00:46:00,249
that so there was a it was actually a

00:45:58,690 --> 00:46:02,950
really useful thing and here's a good

00:46:00,249 --> 00:46:06,490
test of you know PCI and so on so it was

00:46:02,950 --> 00:46:08,559
a it was although he doesn't like what

00:46:06,490 --> 00:46:12,099
it was complaining about the size of the

00:46:08,559 --> 00:46:16,630
spec for the Y lesson so I never them it

00:46:12,099 --> 00:46:19,829
was a useful thing to do I think right

00:46:16,630 --> 00:46:19,829
up to see you know vembur

00:46:23,340 --> 00:46:37,340
how much work is adding support for new

00:46:27,800 --> 00:46:42,570
iommu architecture for example on Haram

00:46:37,340 --> 00:46:47,930
yes I think starting with oh yes there

00:46:42,570 --> 00:46:51,180
isn't say yes um I don't know I think I

00:46:47,930 --> 00:46:53,840
haven't really looked at that on arm I

00:46:51,180 --> 00:46:57,990
[Music]

00:46:53,840 --> 00:47:08,520
shouldn't have thought it was too much

00:46:57,990 --> 00:47:09,600
work it's not you know mainly I would

00:47:08,520 --> 00:47:12,030
have thought you could probably do it in

00:47:09,600 --> 00:47:12,660
a week as guess finger in the air but I

00:47:12,030 --> 00:47:18,570
don't it

00:47:12,660 --> 00:47:23,040
it's not hot it's not horrible you

00:47:18,570 --> 00:47:24,450
mentioned MINIX 3's we've been thinking

00:47:23,040 --> 00:47:26,820
about maybe porting around two minutes

00:47:24,450 --> 00:47:29,160
three we have a generic POSIX interface

00:47:26,820 --> 00:47:38,820
although no kernel threads any idea how

00:47:29,160 --> 00:47:41,430
much time it would take support it - if

00:47:38,820 --> 00:47:49,650
you want to run it just as a user space

00:47:41,430 --> 00:47:51,690
process it it's very little work I mean

00:47:49,650 --> 00:47:52,920
it really should it should run already

00:47:51,690 --> 00:47:54,840
in user space

00:47:52,920 --> 00:47:59,940
I imagine though you want to link it

00:47:54,840 --> 00:48:04,320
into the the MINIX 3 kernel rather than

00:47:59,940 --> 00:48:09,510
users Hey okay okay in theory it should

00:48:04,320 --> 00:48:16,470
just it should just run I I had a quick

00:48:09,510 --> 00:48:19,770
look but I think it should be a matter

00:48:16,470 --> 00:48:23,490
of cross but just cross building it and

00:48:19,770 --> 00:48:25,050
I tried building it natively and but

00:48:23,490 --> 00:48:27,210
builder SH isn't very happy building

00:48:25,050 --> 00:48:30,060
natively on MINIX three and the moment

00:48:27,210 --> 00:48:33,600
over at least I run this isn't it when

00:48:30,060 --> 00:48:37,230
did you try that I don't know a few

00:48:33,600 --> 00:48:39,630
weeks ago very briefly but I should talk

00:48:37,230 --> 00:48:41,339
but I think it should probably across

00:48:39,630 --> 00:48:46,770
build might be easier but it should it

00:48:41,339 --> 00:48:49,020
should just work I mean I as long as you

00:48:46,770 --> 00:48:51,690
support I mean it runs on Android and

00:48:49,020 --> 00:48:55,470
Android is the most useless positive

00:48:51,690 --> 00:49:04,799
POSIX user space there is say and I put

00:48:55,470 --> 00:49:06,480
the Android port at me a day yes but

00:49:04,799 --> 00:49:10,200
never the Android the Android portrait

00:49:06,480 --> 00:49:12,000
took a day and it was and that was just

00:49:10,200 --> 00:49:13,619
dealing with the things that had missing

00:49:12,000 --> 00:49:17,190
or with broken headers or things I've

00:49:13,619 --> 00:49:19,530
heard you mentioned signals were an

00:49:17,190 --> 00:49:22,200
issue in ramp run so it was the thought

00:49:19,530 --> 00:49:23,700
to rewrite some of the code that uses

00:49:22,200 --> 00:49:26,609
signals to different ways of doing

00:49:23,700 --> 00:49:28,530
timers or add signal elation into the

00:49:26,609 --> 00:49:32,280
library there's a source of signal

00:49:28,530 --> 00:49:35,609
emulation there's a source of signal

00:49:32,280 --> 00:49:41,309
emulation but it's it's not I don't like

00:49:35,609 --> 00:49:43,079
it it's big I'd rather rewrite the code

00:49:41,309 --> 00:49:44,819
and not use signals because I mean the

00:49:43,079 --> 00:49:46,319
way thing of never sleeping for doesn't

00:49:44,819 --> 00:49:50,549
use signals ping sick stairs I mean it's

00:49:46,319 --> 00:49:51,660
just like then the code could be more

00:49:50,549 --> 00:49:55,079
similar between paying for and paying

00:49:51,660 --> 00:49:59,490
extra frankly it's it's there's no

00:49:55,079 --> 00:50:02,280
reason to use my I'm not a big fan of

00:49:59,490 --> 00:50:04,950
signals there's no reason to use signals

00:50:02,280 --> 00:50:07,230
to do some high timers you you know

00:50:04,950 --> 00:50:11,400
we've got we got nice thing we got keiki

00:50:07,230 --> 00:50:15,290
we got you know it's you know it's

00:50:11,400 --> 00:50:15,290
there's no real reason to use signals

00:50:15,799 --> 00:50:26,579
yeah so yeah well it might yeah I think

00:50:24,270 --> 00:50:29,579
yeah there's no real reason

00:50:26,579 --> 00:50:31,230
I mean signals do work in userspace rum

00:50:29,579 --> 00:50:36,630
but not necessarily on other platforms

00:50:31,230 --> 00:50:39,359
so I don't really and they don't

00:50:36,630 --> 00:50:41,220
necessarily quite work exactly right but

00:50:39,359 --> 00:50:43,980
there's there's there's a you've got a

00:50:41,220 --> 00:50:45,750
choice of ways to emulate that it's not

00:50:43,980 --> 00:50:46,740
it's not really worth spending more time

00:50:45,750 --> 00:50:49,230
on drivin

00:50:46,740 --> 00:50:51,840
and thing I mean it's cuz the front

00:50:49,230 --> 00:50:53,820
doesn't understand processes so signals

00:50:51,840 --> 00:50:56,250
or host signals really and so they can't

00:50:53,820 --> 00:51:01,650
really interrupt a ramesses system call

00:50:56,250 --> 00:51:03,869
but you can kind of fake it a bit it's

00:51:01,650 --> 00:51:07,440
it's but it's not very it's not really

00:51:03,869 --> 00:51:09,360
worth it um pinging six was the only

00:51:07,440 --> 00:51:13,710
thing that I came across where signals

00:51:09,360 --> 00:51:17,119
seem to be an issue and for tests you

00:51:13,710 --> 00:51:17,119
only need two pink ones not anyway

00:51:25,130 --> 00:51:32,700
anymore but they come and talk to me and

00:51:30,740 --> 00:51:35,090
harangue me about things if you want to

00:51:32,700 --> 00:51:35,090
ask more questions

00:51:38,960 --> 00:51:42,139

YouTube URL: https://www.youtube.com/watch?v=5GdP84VqKyk


