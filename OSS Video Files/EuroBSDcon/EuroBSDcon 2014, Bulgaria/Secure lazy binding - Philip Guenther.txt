Title: Secure lazy binding - Philip Guenther
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

A common security measure is now to reduce or eliminate the presence of process memory that is both writable and executable. However, the dynamic linker needs to make changes to executable pages when binding lazy references. In multi-threaded programs this creates a window of vulnerability. Depending on the system architecture, it may also result in extra cache or TLB flushes to maintain coherency on multi-processor systems. Iâ€™ll describe the implementation and use of kbind(), a machine-independent system call for secure and efficient binding of lazy references.

Speaker biography:

Philip was initiated in UNIX system administration in 1992 as a student at Saint Olaf College, where he got involved in Open Source software including procmail and amd. In December 2000 he joined Sendmail Inc and worked on threaded IMAP/POP3/LMTP servers. He started using OpenBSD actively several years later but didnâ€™t join the project until July 2008 after the status of the threads implementation started to annoy him. Philip is currently a Director of Engineering at Proofpoint, Inc.
Captions: 
	00:00:08,200 --> 00:00:13,980
talk a bit about

00:00:10,350 --> 00:00:18,869
trying to make lazy binding by the

00:00:13,980 --> 00:00:21,480
her a bit more secure so plan what's the

00:00:18,869 --> 00:00:24,270
problem then turn it off here and what

00:00:21,480 --> 00:00:26,210
can I do about it and then some bits

00:00:24,270 --> 00:00:28,380
about how good the solution actually is

00:00:26,210 --> 00:00:32,099
and then okay what are the problems

00:00:28,380 --> 00:00:35,370
created by the solution and then it's

00:00:32,099 --> 00:00:39,180
about what Eldar options are and the

00:00:35,370 --> 00:00:42,210
status of this all so review of lazy

00:00:39,180 --> 00:00:46,020
binding leave I mean is it's how the

00:00:42,210 --> 00:00:47,879
dynamic linker lets us defer a bunch of

00:00:46,020 --> 00:00:52,710
work that it would otherwise have to do

00:00:47,879 --> 00:00:54,780
so that when a function call is done to

00:00:52,710 --> 00:00:56,399
a shared library the dynamic linker

00:00:54,780 --> 00:00:59,850
would have to look cast look up the

00:00:56,399 --> 00:01:01,440
actual simple address this is a way we

00:00:59,850 --> 00:01:04,019
can say let's not actually do that work

00:01:01,440 --> 00:01:05,550
unless we need it by deferring it until

00:01:04,019 --> 00:01:08,490
the first time the function is called so

00:01:05,550 --> 00:01:09,990
the pro of course is that you don't have

00:01:08,490 --> 00:01:13,679
to do the effort to the symbol lookup

00:01:09,990 --> 00:01:16,140
for functions that you don't use the con

00:01:13,679 --> 00:01:18,149
well okay the first is inconsistent call

00:01:16,140 --> 00:01:20,789
latency so the first call is quite a bit

00:01:18,149 --> 00:01:23,280
slower than all the others and then the

00:01:20,789 --> 00:01:27,209
one that discovered later is that it

00:01:23,280 --> 00:01:30,090
violates the the goal of a write

00:01:27,209 --> 00:01:33,239
exclusive or execute on some of the

00:01:30,090 --> 00:01:34,800
architectures the code or the function

00:01:33,239 --> 00:01:35,789
pointers involved they need to be

00:01:34,800 --> 00:01:37,619
changed on the fly

00:01:35,789 --> 00:01:39,450
while the code is you know while the

00:01:37,619 --> 00:01:41,729
programmer is executing so we're writing

00:01:39,450 --> 00:01:45,539
to code that writing to actual

00:01:41,729 --> 00:01:47,700
executable code in some cases so that's

00:01:45,539 --> 00:01:51,770
that's bad we we don't want to do that

00:01:47,700 --> 00:01:55,200
and some of you may recognize this slide

00:01:51,770 --> 00:01:57,800
from Theo's presentation from several

00:01:55,200 --> 00:02:00,569
years ago describing how OpenBSD project

00:01:57,800 --> 00:02:02,459
moved around various things and here's

00:02:00,569 --> 00:02:04,140
we moved the constructor constructors

00:02:02,459 --> 00:02:06,780
and destructors over here next to the

00:02:04,140 --> 00:02:09,080
god in order to make sure that they were

00:02:06,780 --> 00:02:11,400
not executable or right and writable and

00:02:09,080 --> 00:02:13,440
similar with various bits and

00:02:11,400 --> 00:02:15,150
permissions on the dots and PLT so it's

00:02:13,440 --> 00:02:22,400
like hey we did all the street work and

00:02:15,150 --> 00:02:25,079
oh by the way it's there's a gap oops so

00:02:22,400 --> 00:02:27,640
cool we want to make it possible for the

00:02:25,079 --> 00:02:29,710
dynamic linker to perform lazy binding

00:02:27,640 --> 00:02:31,870
and we don't want a window vulnerability

00:02:29,710 --> 00:02:36,040
we want to preferably be a bit more

00:02:31,870 --> 00:02:39,750
efficient so that's actually on a wall

00:02:36,040 --> 00:02:39,750
near where I used to live in Emeryville

00:02:41,790 --> 00:02:48,130
so a little review of dynamic linking

00:02:44,350 --> 00:02:50,050
here to kind of set the context the the

00:02:48,130 --> 00:02:52,030
executables they don't contain the

00:02:50,050 --> 00:02:54,160
library code that they're that's in the

00:02:52,030 --> 00:02:56,680
shared library they just reference it so

00:02:54,160 --> 00:02:58,600
the executable it's all the smaller and

00:02:56,680 --> 00:03:01,120
we can even do you know nicely update

00:02:58,600 --> 00:03:02,800
the library about real inking and note

00:03:01,120 --> 00:03:04,690
the references are by name I mean it

00:03:02,800 --> 00:03:06,010
doesn't remember like a symbol index or

00:03:04,690 --> 00:03:08,530
something else like you know we don't

00:03:06,010 --> 00:03:10,720
say calling printf doesn't mean calling

00:03:08,530 --> 00:03:12,730
the thirty-seventh you know function

00:03:10,720 --> 00:03:14,890
inside live C you know it actually the

00:03:12,730 --> 00:03:17,680
the executable knows well I'm calling

00:03:14,890 --> 00:03:20,680
printf and it's the responsibility of

00:03:17,680 --> 00:03:22,240
the dynamic linker to say Oh printf is

00:03:20,680 --> 00:03:26,200
what you wanted okay let me go look that

00:03:22,240 --> 00:03:31,870
up over here okay address is xxx three

00:03:26,200 --> 00:03:36,100
two one two now that information of

00:03:31,870 --> 00:03:38,880
exactly what you know where the what

00:03:36,100 --> 00:03:40,630
addresses are correspond to what is are

00:03:38,880 --> 00:03:43,300
represented by these things called

00:03:40,630 --> 00:03:44,620
relocations so there's these tables of

00:03:43,300 --> 00:03:46,180
these and the symbol it creates them and

00:03:44,620 --> 00:03:48,640
the linker kind of consolidates and

00:03:46,180 --> 00:03:51,400
rewrites them talking about how the code

00:03:48,640 --> 00:03:54,040
and the data depend on these load

00:03:51,400 --> 00:03:57,670
locations and simple things so when you

00:03:54,040 --> 00:04:00,670
load a and executable yet s know okay

00:03:57,670 --> 00:04:02,350
these certain things are at you know

00:04:00,670 --> 00:04:04,120
these functions may be at a different

00:04:02,350 --> 00:04:06,730
relative address and has to convert

00:04:04,120 --> 00:04:08,770
those to an absolute address so these

00:04:06,730 --> 00:04:10,900
are just a couple example relocation so

00:04:08,770 --> 00:04:15,610
every platform has its own set and this

00:04:10,900 --> 00:04:18,280
is a couple from obviously amd64 so you

00:04:15,610 --> 00:04:20,049
have the first this is rewriting in a

00:04:18,280 --> 00:04:22,750
specific area just by adding a new value

00:04:20,049 --> 00:04:25,180
to it to the office leave the load

00:04:22,750 --> 00:04:26,260
location so this like at a certain

00:04:25,180 --> 00:04:29,020
address we're gonna add to take the

00:04:26,260 --> 00:04:30,040
actual address added value to it and the

00:04:29,020 --> 00:04:34,360
other one is okay let's just take a

00:04:30,040 --> 00:04:36,340
symbol value and add something to it now

00:04:34,360 --> 00:04:38,140
protect particularly relocations there

00:04:36,340 --> 00:04:39,700
are actually two types there's those

00:04:38,140 --> 00:04:40,760
that have to be done immediately when

00:04:39,700 --> 00:04:43,250
you actually load

00:04:40,760 --> 00:04:45,350
or when you load a program so as soon as

00:04:43,250 --> 00:04:47,860
it's loaded when either at startup time

00:04:45,350 --> 00:04:51,230
when the executable is actually executed

00:04:47,860 --> 00:04:54,550
or later if you load a shared library

00:04:51,230 --> 00:04:56,690
with DL open all the immediate

00:04:54,550 --> 00:04:58,040
relocations those have to be done right

00:04:56,690 --> 00:04:59,390
then and there it has to go through

00:04:58,040 --> 00:05:02,450
because this is these are places where

00:04:59,390 --> 00:05:04,070
the code actually refers to you know

00:05:02,450 --> 00:05:06,680
some data location or it has a pointer

00:05:04,070 --> 00:05:10,190
to a function and it need there's no way

00:05:06,680 --> 00:05:12,380
to kind of capture act the the flow

00:05:10,190 --> 00:05:14,210
control at that moment I mean the code

00:05:12,380 --> 00:05:16,460
just wants it wants an address it that's

00:05:14,210 --> 00:05:18,320
all it does on the other end there's

00:05:16,460 --> 00:05:19,850
also the lazy relocations which are

00:05:18,320 --> 00:05:22,790
places where it's actually calling a

00:05:19,850 --> 00:05:24,800
it's calling a function now when you're

00:05:22,790 --> 00:05:26,930
calling a function obviously you're in

00:05:24,800 --> 00:05:28,460
the flow of control so we can trick the

00:05:26,930 --> 00:05:32,390
flow of control to go over to the night

00:05:28,460 --> 00:05:34,160
Namek linker instead and then once in

00:05:32,390 --> 00:05:36,020
the dynamic linker it can figure out the

00:05:34,160 --> 00:05:39,110
real bits rewrite the relocation

00:05:36,020 --> 00:05:42,200
actually perform the lazy Ness or stop

00:05:39,110 --> 00:05:47,120
being so lazy and then go on to the

00:05:42,200 --> 00:05:50,060
actual code and so with position

00:05:47,120 --> 00:05:53,090
independent code we do this to maximize

00:05:50,060 --> 00:05:54,530
sharing and you with executables you can

00:05:53,090 --> 00:05:56,480
even do this with executables for

00:05:54,530 --> 00:05:59,240
position independent executables for

00:05:56,480 --> 00:06:03,020
those who were in Shawn's talk I talked

00:05:59,240 --> 00:06:04,580
about it so even though the library

00:06:03,020 --> 00:06:06,500
executable is loaded to random location

00:06:04,580 --> 00:06:09,170
we need to be able to get to the right

00:06:06,500 --> 00:06:12,860
place so the relocations handle that and

00:06:09,170 --> 00:06:15,200
the generated code can't you don't want

00:06:12,860 --> 00:06:17,030
to rewrite all these things in the text

00:06:15,200 --> 00:06:20,600
segments itself so instead you do some

00:06:17,030 --> 00:06:22,880
in directing and so the the program the

00:06:20,600 --> 00:06:24,830
executable or the shared library it's

00:06:22,880 --> 00:06:28,040
representation on the disk has these two

00:06:24,830 --> 00:06:31,010
tables as the the got and the PLT they

00:06:28,040 --> 00:06:33,740
got the global offset table this stores

00:06:31,010 --> 00:06:36,170
it's just addresses and values like that

00:06:33,740 --> 00:06:39,770
in just one big big table

00:06:36,170 --> 00:06:42,860
well the PLT is the executable version

00:06:39,770 --> 00:06:45,860
where this is how if you do want to do a

00:06:42,860 --> 00:06:48,500
lazy binding the you the program

00:06:45,860 --> 00:06:50,100
actually calls the PLT entry and then

00:06:48,500 --> 00:06:51,930
that figures out how to go from there

00:06:50,100 --> 00:06:54,810
and this gets all very very

00:06:51,930 --> 00:06:56,160
architecture-specific and in order to

00:06:54,810 --> 00:06:58,320
make some of this a little clearer and

00:06:56,160 --> 00:07:02,430
actually dig in a little bit on a couple

00:06:58,320 --> 00:07:04,650
architectures here so so on amd64 for

00:07:02,430 --> 00:07:06,450
lazy binding the PLT has never changed

00:07:04,650 --> 00:07:08,610
it's a static chunk of code

00:07:06,450 --> 00:07:09,900
it's the code that's in the executable

00:07:08,610 --> 00:07:11,670
is mapped into memory and it doesn't

00:07:09,900 --> 00:07:14,310
actually have to change all right but

00:07:11,670 --> 00:07:15,960
what that code does is it actually no

00:07:14,310 --> 00:07:19,440
uses the fact that it we can do these

00:07:15,960 --> 00:07:22,920
relative lookups and it then says ok the

00:07:19,440 --> 00:07:25,170
PLT entry for printf for instance it

00:07:22,920 --> 00:07:27,510
knows ok I look over into the gawk table

00:07:25,170 --> 00:07:32,430
for the address of printf and from there

00:07:27,510 --> 00:07:35,040
I can figure out where to jump to I 3 d6

00:07:32,430 --> 00:07:37,710
is similar except they don't have the

00:07:35,040 --> 00:07:40,740
nice relative instruction pointer

00:07:37,710 --> 00:07:42,270
relative addressing they you know the i3

00:07:40,740 --> 00:07:44,460
6 there's really shouldn't take me a

00:07:42,270 --> 00:07:48,150
note from the amd64 designers they

00:07:44,460 --> 00:07:51,360
should have gotten this right so the

00:07:48,150 --> 00:07:54,150
result is that instead the actually the

00:07:51,360 --> 00:07:55,770
caller of a PLT it knows it can be

00:07:54,150 --> 00:07:59,220
colonnades PLT it actually has to set up

00:07:55,770 --> 00:08:04,010
the the the the got pointer for the PLT

00:07:59,220 --> 00:08:07,620
so that it can all fit inside the PLT so

00:08:04,010 --> 00:08:10,410
the even more specific here's the small

00:08:07,620 --> 00:08:14,270
chukka see that if we if we assume that

00:08:10,410 --> 00:08:17,990
fubar and are there are or actually

00:08:14,270 --> 00:08:20,550
being pulled from a shared library the

00:08:17,990 --> 00:08:24,720
generated assembly looks something like

00:08:20,550 --> 00:08:29,070
that so that the first one it has this

00:08:24,720 --> 00:08:33,090
this annotation here phoo

00:08:29,070 --> 00:08:36,000
highlight that actually is a special bit

00:08:33,090 --> 00:08:37,740
of code that says ok yo assembler when

00:08:36,000 --> 00:08:40,349
you actually create the you know linker

00:08:37,740 --> 00:08:42,630
when you create this the number we're

00:08:40,349 --> 00:08:45,810
gonna put a number actually and turn

00:08:42,630 --> 00:08:49,950
that into a number which is the got

00:08:45,810 --> 00:08:53,100
entry for the the the function sorry the

00:08:49,950 --> 00:08:55,920
variable foo so that's that just loads

00:08:53,100 --> 00:08:58,110
into the our ax register whose address

00:08:55,920 --> 00:08:59,670
in the got and then we can dereference

00:08:58,110 --> 00:09:02,520
ID in the next instruction and then the

00:08:59,670 --> 00:09:04,170
second one demonstrates how calling

00:09:02,520 --> 00:09:08,820
the function the PLT it's that's you

00:09:04,170 --> 00:09:11,250
that annotation to call the PLT so what

00:09:08,820 --> 00:09:13,250
the PLT end up doing this is even

00:09:11,250 --> 00:09:17,520
getting deeper

00:09:13,250 --> 00:09:18,750
PLT in here is will say is the the entry

00:09:17,520 --> 00:09:20,250
for bar so that is this nice little

00:09:18,750 --> 00:09:22,650
thing weird it does it don't look over

00:09:20,250 --> 00:09:25,800
into the god and ends up loading index

00:09:22,650 --> 00:09:27,030
and jumps back to the PLT and that

00:09:25,800 --> 00:09:30,510
eventually goes over into the lazy

00:09:27,030 --> 00:09:33,630
binding code so the the got the goal

00:09:30,510 --> 00:09:35,730
here is that this starts off being an

00:09:33,630 --> 00:09:37,860
address that actually points into the pl

00:09:35,730 --> 00:09:39,960
over here to the PLT zero but we're

00:09:37,860 --> 00:09:51,270
gonna rewrite it to point to the real

00:09:39,960 --> 00:09:54,360
printf or the real bar function so the

00:09:51,270 --> 00:09:56,130
lazy binding code what its gonna do is

00:09:54,360 --> 00:09:57,420
it's gonna say okay at the bar symbol

00:09:56,130 --> 00:09:59,190
for instance let's actually resolve it

00:09:57,420 --> 00:10:00,750
to the correct address it actually looks

00:09:59,190 --> 00:10:03,390
through symbol tables goes off that's

00:10:00,750 --> 00:10:06,420
all standard stuff that's gonna update

00:10:03,390 --> 00:10:08,460
that table entry okay but we already

00:10:06,420 --> 00:10:10,350
said may have seen on that slide my

00:10:08,460 --> 00:10:11,940
video that the gotten the PLT don't

00:10:10,350 --> 00:10:15,270
normally need to be written by the

00:10:11,940 --> 00:10:17,190
application code so on OpenBSD after

00:10:15,270 --> 00:10:20,580
loading that are both in protected to

00:10:17,190 --> 00:10:23,910
read-only so how we gonna update that

00:10:20,580 --> 00:10:27,630
got entry okay so here's what we really

00:10:23,910 --> 00:10:29,280
do you resolve the symbol okay then we

00:10:27,630 --> 00:10:32,610
an protect with the got to read write

00:10:29,280 --> 00:10:36,570
update they've got entry and then and

00:10:32,610 --> 00:10:38,520
protect it back to read-only again okay

00:10:36,570 --> 00:10:39,900
well if a signal came in there and we

00:10:38,520 --> 00:10:41,580
called the function the signal handler

00:10:39,900 --> 00:10:44,010
called the front okay so that that's not

00:10:41,580 --> 00:10:45,270
gonna work either so let's actually try

00:10:44,010 --> 00:10:48,060
this again and actually block the

00:10:45,270 --> 00:10:50,480
signals across this all block all the

00:10:48,060 --> 00:10:54,000
signals and protect update the entry on

00:10:50,480 --> 00:10:55,920
and protected back and now unblock our

00:10:54,000 --> 00:10:59,390
signals and actually do the function

00:10:55,920 --> 00:11:02,700
call this works is what we're doing

00:10:59,390 --> 00:11:04,560
threads of course as usual come and mess

00:11:02,700 --> 00:11:09,270
up things even more because threads are

00:11:04,560 --> 00:11:12,180
pain and so in a thresher grab one more

00:11:09,270 --> 00:11:13,420
time what feeling let's actually also

00:11:12,180 --> 00:11:16,330
grab a lock there

00:11:13,420 --> 00:11:17,860
we can make sure that another thread

00:11:16,330 --> 00:11:19,210
doesn't try to do this at the same time

00:11:17,860 --> 00:11:22,030
because the problem is what happens if

00:11:19,210 --> 00:11:23,200
um protect if one guy M protects and

00:11:22,030 --> 00:11:24,670
then another one tries to do the same

00:11:23,200 --> 00:11:26,950
set of M protects and unn protects

00:11:24,670 --> 00:11:28,600
you'll end up with it in the wrong state

00:11:26,950 --> 00:11:30,760
you'll end up leaving it unprotected or

00:11:28,600 --> 00:11:35,050
you leave or you'll actually fault

00:11:30,760 --> 00:11:37,780
trying to do the update so those the the

00:11:35,050 --> 00:11:39,730
spin lock is actually a registered with

00:11:37,780 --> 00:11:42,070
a call back so the thread library tells

00:11:39,730 --> 00:11:43,540
D at the LDS Oh code hey yeah I guess

00:11:42,070 --> 00:11:45,730
you have to use a spin lock here use

00:11:43,540 --> 00:11:49,690
that here so you don't actually get the

00:11:45,730 --> 00:11:52,180
spin lock on non-threaded code and as a

00:11:49,690 --> 00:11:54,790
result of all this if you actually are K

00:11:52,180 --> 00:11:57,400
Tracy any dynamically linked program you

00:11:54,790 --> 00:11:59,770
see lots of noise like this in the the

00:11:57,400 --> 00:12:01,660
resulting K trace where you see a block

00:11:59,770 --> 00:12:03,340
the signal to an M protect you don't

00:12:01,660 --> 00:12:06,390
actually see the there's no syscall

00:12:03,340 --> 00:12:09,820
there for the actual change but it then

00:12:06,390 --> 00:12:11,770
reaper tex it and and reap unblock the

00:12:09,820 --> 00:12:13,930
signals and then finally hey turns out

00:12:11,770 --> 00:12:19,330
that was the that trying to do a

00:12:13,930 --> 00:12:21,760
resolution for octal now let M protect

00:12:19,330 --> 00:12:24,280
isn't free neither of them that matter

00:12:21,760 --> 00:12:25,360
so okay when you add permissions to a

00:12:24,280 --> 00:12:26,980
page when it's actually marked

00:12:25,360 --> 00:12:29,920
read/write

00:12:26,980 --> 00:12:32,020
we just set some bits off we go and then

00:12:29,920 --> 00:12:35,140
when the kernel when you actually try to

00:12:32,020 --> 00:12:36,730
do the right then the will large so you

00:12:35,140 --> 00:12:38,560
have a fault and actually fix it up and

00:12:36,730 --> 00:12:41,280
say oh okay yes you are allowed to write

00:12:38,560 --> 00:12:43,750
to this page okay okay

00:12:41,280 --> 00:12:46,180
no underline when you remove the

00:12:43,750 --> 00:12:48,670
permission that has to be instantaneous

00:12:46,180 --> 00:12:53,020
well that's the week before the return

00:12:48,670 --> 00:12:55,780
from the in protect and more importantly

00:12:53,020 --> 00:12:57,190
if you have threads other threads in

00:12:55,780 --> 00:13:00,040
this process we need to make sure none

00:12:57,190 --> 00:13:02,560
of them can you know they all are denied

00:13:00,040 --> 00:13:04,240
right as well for this so that whenever

00:13:02,560 --> 00:13:07,600
you do an M protect in the thread

00:13:04,240 --> 00:13:09,430
process to remove permissions you

00:13:07,600 --> 00:13:11,350
actually have to you know send IP eyes

00:13:09,430 --> 00:13:13,570
to all the other CPUs which are also

00:13:11,350 --> 00:13:17,380
that are involved in running these

00:13:13,570 --> 00:13:21,070
threads and and that's it's it's not

00:13:17,380 --> 00:13:22,630
cheap it gets expensive and it's kind of

00:13:21,070 --> 00:13:24,250
annoying because we don't even want

00:13:22,630 --> 00:13:26,290
those other processes those other

00:13:24,250 --> 00:13:28,209
threads to even see that it was right

00:13:26,290 --> 00:13:30,070
well to begin with so we make this

00:13:28,209 --> 00:13:33,490
change and then we have to tell oh you

00:13:30,070 --> 00:13:38,440
didn't even see that change that's it's

00:13:33,490 --> 00:13:41,500
a waste so came up with the idea of K

00:13:38,440 --> 00:13:43,300
bind and so you may remember me glossing

00:13:41,500 --> 00:13:45,970
a little bit about this under the name M

00:13:43,300 --> 00:13:48,759
right a couple years ago the name has

00:13:45,970 --> 00:13:52,149
changed a number of things change about

00:13:48,759 --> 00:13:54,120
it so basically it says the SIS call for

00:13:52,149 --> 00:13:56,889
doing these updates other PLT are got

00:13:54,120 --> 00:13:58,420
you pass it the address in length of

00:13:56,889 --> 00:14:00,399
memory to update and a buffer of what

00:13:58,420 --> 00:14:03,339
you want it to stick into the particular

00:14:00,399 --> 00:14:04,690
memory and then in the kernel it has to

00:14:03,339 --> 00:14:06,639
do the same sort of permission check so

00:14:04,690 --> 00:14:08,199
it still does basically the same checks

00:14:06,639 --> 00:14:09,579
that M protect would have done and let

00:14:08,199 --> 00:14:13,389
the copy are right handling would have

00:14:09,579 --> 00:14:14,740
done you know at s do for instance you

00:14:13,389 --> 00:14:16,480
know make sure that if this page was

00:14:14,740 --> 00:14:18,910
actually copy on write that that's do

00:14:16,480 --> 00:14:21,220
you know clone it and and resolve that

00:14:18,910 --> 00:14:22,360
as to make sure if this if you didn't

00:14:21,220 --> 00:14:24,279
actually have write access to the

00:14:22,360 --> 00:14:26,649
underlying page because it was from a

00:14:24,279 --> 00:14:29,139
read-only file it'll it'll break your

00:14:26,649 --> 00:14:31,000
fingers and things like that nicely

00:14:29,139 --> 00:14:33,819
because it's by doing a system call it

00:14:31,000 --> 00:14:35,529
becomes uninterruptible so no you don't

00:14:33,819 --> 00:14:37,510
have to do that sync proc mask dance it

00:14:35,529 --> 00:14:39,940
doesn't have the kernel it's kind of

00:14:37,510 --> 00:14:43,449
implicit there nor do we have to do any

00:14:39,940 --> 00:14:46,779
the the the spin lock because we can

00:14:43,449 --> 00:14:49,089
just say okay yo u vm system and p map

00:14:46,779 --> 00:14:51,550
me you make sure that you do the walking

00:14:49,089 --> 00:14:54,040
sufficiently so that even if two threads

00:14:51,550 --> 00:14:58,029
were both calling k bind that nothing

00:14:54,040 --> 00:15:02,620
goes wrong so the kind of before and

00:14:58,029 --> 00:15:06,250
after this is basically what the LDS Oh

00:15:02,620 --> 00:15:09,220
looks like for for amd64 they've kept

00:15:06,250 --> 00:15:14,199
the particular resolution part and then

00:15:09,220 --> 00:15:16,510
after it's a bit smaller and the result

00:15:14,199 --> 00:15:17,980
is that it actually is a bit nicer even

00:15:16,510 --> 00:15:20,050
in the k trace output I need to see it

00:15:17,980 --> 00:15:25,959
passing enough information and then off

00:15:20,050 --> 00:15:29,079
it goes well let's see the kind of the

00:15:25,959 --> 00:15:31,209
user space side in the kernel the kernel

00:15:29,079 --> 00:15:33,759
we we try it we can try to be a bit more

00:15:31,209 --> 00:15:34,990
efficient - aw thanks I one of my early

00:15:33,759 --> 00:15:36,939
implementations I actually basically

00:15:34,990 --> 00:15:37,180
copied the unprotected code path and

00:15:36,939 --> 00:15:40,660
with

00:15:37,180 --> 00:15:46,150
there but after some help from our UVM

00:15:40,660 --> 00:15:49,030
hackers started just using some sorta

00:15:46,150 --> 00:15:50,830
just wiring in stuff so it consists of

00:15:49,030 --> 00:15:54,610
just a few steps we just copy the data

00:15:50,830 --> 00:15:58,300
into the kernel we then force the the

00:15:54,610 --> 00:16:00,850
UVM fault fault wire there takes care of

00:15:58,300 --> 00:16:03,130
the permission check the the

00:16:00,850 --> 00:16:05,170
copy-on-write resolution make sure the

00:16:03,130 --> 00:16:10,000
page is actually in memory case it got

00:16:05,170 --> 00:16:11,740
paged out and then because we the amd64

00:16:10,000 --> 00:16:13,930
is a direct-mapped where we there's an

00:16:11,740 --> 00:16:17,140
address range in the kernel virtual

00:16:13,930 --> 00:16:20,170
addresses which map to all of physical

00:16:17,140 --> 00:16:23,290
addresses so state a little subtraction

00:16:20,170 --> 00:16:25,330
operation that for the hardware we can

00:16:23,290 --> 00:16:28,210
just grab figure out the right address

00:16:25,330 --> 00:16:31,240
in that range poke the pages hook that

00:16:28,210 --> 00:16:32,590
page directly so actually it's not

00:16:31,240 --> 00:16:36,160
actually be copy because you actually

00:16:32,590 --> 00:16:39,490
want this to be word wise atomic from

00:16:36,160 --> 00:16:42,400
the user space side and then once that's

00:16:39,490 --> 00:16:43,960
updated we can just unwire the page so

00:16:42,400 --> 00:16:46,150
they can be paged again and you know

00:16:43,960 --> 00:16:48,870
clean everything up off we go on return

00:16:46,150 --> 00:16:53,050
user space that's it we don't have to

00:16:48,870 --> 00:16:54,760
you know signal other CPU is the fault

00:16:53,050 --> 00:16:56,650
if there was a copier on right

00:16:54,760 --> 00:16:58,600
resolution the faults mate the UVM fault

00:16:56,650 --> 00:17:00,730
may have to do that but if we were gonna

00:16:58,600 --> 00:17:09,850
have to do that we were gonna have to do

00:17:00,730 --> 00:17:12,490
that anyway so no loss there spark 64 as

00:17:09,850 --> 00:17:15,340
a contrast is a bit different where the

00:17:12,490 --> 00:17:17,290
gaunt instead of in on MB 64 the the

00:17:15,340 --> 00:17:19,900
peel T was static we did everything the

00:17:17,290 --> 00:17:20,620
god in 64 it's kind of the other way

00:17:19,900 --> 00:17:23,470
around

00:17:20,620 --> 00:17:25,720
so the GOC has never changed and instead

00:17:23,470 --> 00:17:31,870
we're actually going to update the

00:17:25,720 --> 00:17:33,190
executed code the dynamic linker we

00:17:31,870 --> 00:17:35,080
actually update the there's a number of

00:17:33,190 --> 00:17:38,230
different code sequences you can use say

00:17:35,080 --> 00:17:40,060
okay if it's if the the place for

00:17:38,230 --> 00:17:42,970
jumping to is within two to the twenty

00:17:40,060 --> 00:17:45,070
first bytes of the PLT entry then we can

00:17:42,970 --> 00:17:46,870
use this code sequence and if it's with

00:17:45,070 --> 00:17:48,100
close to page you know address zero we

00:17:46,870 --> 00:17:48,520
can use this sequence and stuff like

00:17:48,100 --> 00:17:50,360
that

00:17:48,520 --> 00:17:52,640
now i'm

00:17:50,360 --> 00:17:56,419
there's like literally eight different

00:17:52,640 --> 00:17:59,570
code paths in the function in a in LDS

00:17:56,419 --> 00:18:01,640
oh and I don't think anyone's actually

00:17:59,570 --> 00:18:05,390
ever gone through and exercised all of

00:18:01,640 --> 00:18:06,799
them because we're all buddy I went

00:18:05,390 --> 00:18:07,820
through this and discovered that all of

00:18:06,799 --> 00:18:10,100
the ones that we're doing relative

00:18:07,820 --> 00:18:12,019
calculations were failing to actually

00:18:10,100 --> 00:18:14,779
correct for the placement of where the

00:18:12,019 --> 00:18:16,010
actual jump was within the PLT entry so

00:18:14,779 --> 00:18:20,929
they're all jumping into the middle of

00:18:16,010 --> 00:18:22,159
the function so which I mean honestly

00:18:20,929 --> 00:18:23,360
calls in the question of whether maybe

00:18:22,159 --> 00:18:24,500
we should just delete a whole bunch of

00:18:23,360 --> 00:18:27,860
these code sequences because they're

00:18:24,500 --> 00:18:31,220
obviously not being used or they or that

00:18:27,860 --> 00:18:32,960
or our sparc64 else crashing in Reno

00:18:31,220 --> 00:18:34,490
randomly depending on the layout of the

00:18:32,960 --> 00:18:38,289
libraries depending on how close they

00:18:34,490 --> 00:18:40,070
were in the the address space layout so

00:18:38,289 --> 00:18:45,289
something to be aware of when you're

00:18:40,070 --> 00:18:46,850
working on your a SLR stuff and in some

00:18:45,289 --> 00:18:48,889
cases there was there was great places

00:18:46,850 --> 00:18:50,480
where the the azzam was described as

00:18:48,889 --> 00:18:52,820
being one way but actually when you you

00:18:50,480 --> 00:18:54,350
actually you know look at the the octal

00:18:52,820 --> 00:18:56,720
value the hex values you're like that

00:18:54,350 --> 00:19:00,889
isn't what that instruction is ignore

00:18:56,720 --> 00:19:02,840
the comments read the code now the

00:19:00,889 --> 00:19:04,730
problem of course is that we're changing

00:19:02,840 --> 00:19:06,980
the running executable code what happens

00:19:04,730 --> 00:19:08,659
if another thread does this it you know

00:19:06,980 --> 00:19:11,659
calls this at the same time and you know

00:19:08,659 --> 00:19:13,429
the son wasn't dumb they actually came

00:19:11,659 --> 00:19:14,870
up with a set of sequences and

00:19:13,429 --> 00:19:18,380
instruction set so that you could

00:19:14,870 --> 00:19:19,940
actually do this update and make sure it

00:19:18,380 --> 00:19:23,389
was possible to consistently get either

00:19:19,940 --> 00:19:25,070
the original or the corrected PLT result

00:19:23,389 --> 00:19:29,500
but it doesn't mean you have to actually

00:19:25,070 --> 00:19:33,200
change it in two steps so for instance

00:19:29,500 --> 00:19:35,149
similar set up on for maybe 64 the the

00:19:33,200 --> 00:19:37,190
first couple entries are the you know

00:19:35,149 --> 00:19:41,539
the ones that jump do the actual jump to

00:19:37,190 --> 00:19:44,029
the dynamic linker or PLT n what it's so

00:19:41,539 --> 00:19:46,850
we load the offset to the entry and then

00:19:44,029 --> 00:19:48,169
we branch this branch is back up to the

00:19:46,850 --> 00:19:55,100
one that goes then into the dynamic

00:19:48,169 --> 00:19:56,870
linker okay it's nice and simple update

00:19:55,100 --> 00:19:58,909
it what we wanted for instance if let's

00:19:56,870 --> 00:19:59,740
say assume the target addresses within

00:19:58,909 --> 00:20:02,230
two to the 30

00:19:59,740 --> 00:20:04,600
fights or whatever we'd use this call

00:20:02,230 --> 00:20:06,460
sequence where we saved the return

00:20:04,600 --> 00:20:10,059
address through the call and slip the

00:20:06,460 --> 00:20:11,590
return address back into place now if we

00:20:10,059 --> 00:20:15,090
just did it in the obvious order of

00:20:11,590 --> 00:20:17,429
writing the instructions in normal order

00:20:15,090 --> 00:20:20,410
the first step obviously breaks things

00:20:17,429 --> 00:20:22,120
if we wrote that first word then the

00:20:20,410 --> 00:20:23,050
someone of thread client the same time

00:20:22,120 --> 00:20:24,820
would of course barf

00:20:23,050 --> 00:20:26,170
so whatever Owen does correctly is you

00:20:24,820 --> 00:20:27,490
actually do it in the other order you

00:20:26,170 --> 00:20:30,040
actually update all the other

00:20:27,490 --> 00:20:32,290
instructions except for that one and

00:20:30,040 --> 00:20:34,150
then once those are in place then you

00:20:32,290 --> 00:20:36,580
can update the first instruction and

00:20:34,150 --> 00:20:39,130
it's switches semantics from jumping

00:20:36,580 --> 00:20:42,040
into the dynamic linker to instead jump

00:20:39,130 --> 00:20:44,290
to the resolved address now for K bine

00:20:42,040 --> 00:20:45,820
that means we actually have to give the

00:20:44,290 --> 00:20:46,929
kernel has to know how to do that now

00:20:45,820 --> 00:20:50,250
there's a couple ways we could do this

00:20:46,929 --> 00:20:53,050
we could have the kernel just know oh

00:20:50,250 --> 00:20:54,790
I'm on a spark 64 and these are the

00:20:53,050 --> 00:21:01,900
bytes therefore I will write them in

00:20:54,790 --> 00:21:04,590
this order into the memory so instead

00:21:01,900 --> 00:21:08,350
I'll pass the kernel to blocks

00:21:04,590 --> 00:21:10,440
I'll pass the kernel one block that says

00:21:08,350 --> 00:21:13,750
okay I want you to update these two

00:21:10,440 --> 00:21:18,820
instructions and then after that update

00:21:13,750 --> 00:21:21,429
this instruction so okay my butt system

00:21:18,820 --> 00:21:23,920
call signature function signature I gave

00:21:21,429 --> 00:21:26,440
I lied no wait

00:21:23,920 --> 00:21:27,760
instead it's something a bit more like

00:21:26,440 --> 00:21:30,130
this where okay

00:21:27,760 --> 00:21:31,809
passed pointer to parameter which

00:21:30,130 --> 00:21:33,730
actually contains an address a length

00:21:31,809 --> 00:21:40,740
and then data and then another address

00:21:33,730 --> 00:21:43,809
length more data in the kernel it's

00:21:40,740 --> 00:21:46,420
sparc64 it's it doesn't have the the

00:21:43,809 --> 00:21:48,070
direct p map so instead we we basically

00:21:46,420 --> 00:21:50,110
forced that page to be mapped into the

00:21:48,070 --> 00:21:52,630
kernel map then we can cook it directly

00:21:50,110 --> 00:21:55,840
there and then unwrap it back out of

00:21:52,630 --> 00:21:58,750
that and detach clean up everything so

00:21:55,840 --> 00:22:00,220
it's that's actually a little more what

00:21:58,750 --> 00:22:02,080
the L the other arc is what I'm doing

00:22:00,220 --> 00:22:03,700
yeah the result of all this is okay so

00:22:02,080 --> 00:22:04,900
how good is this what what are the

00:22:03,700 --> 00:22:09,010
result in the answered well okay with a

00:22:04,900 --> 00:22:11,710
make build of the system it saves about

00:22:09,010 --> 00:22:13,560
4% on the execution down to make build

00:22:11,710 --> 00:22:15,810
and most of that is actually

00:22:13,560 --> 00:22:17,250
system tournament now how much of that

00:22:15,810 --> 00:22:20,250
is because our P maps could be better

00:22:17,250 --> 00:22:23,310
and our MP could be better and other

00:22:20,250 --> 00:22:28,280
things could be better but it's at least

00:22:23,310 --> 00:22:28,280
removed four percent of bottleneck now

00:22:28,430 --> 00:22:33,660
note that it turns out that almost all

00:22:31,440 --> 00:22:35,160
the savings actually come during the

00:22:33,660 --> 00:22:37,440
make install step when we have lots of

00:22:35,160 --> 00:22:39,390
little short live processes where the

00:22:37,440 --> 00:22:41,820
the amortized time is there's a lot of

00:22:39,390 --> 00:22:44,250
PLT resolution relative to the of the

00:22:41,820 --> 00:22:46,080
total computation time I mean GCC does

00:22:44,250 --> 00:22:48,600
have a lot of entries that it looks at

00:22:46,080 --> 00:22:52,470
but it it eats much more time relative

00:22:48,600 --> 00:22:55,680
to those and the one thing is is

00:22:52,470 --> 00:22:59,850
something not right with my my UVM stuff

00:22:55,680 --> 00:23:02,850
it's not always faster there are test

00:22:59,850 --> 00:23:04,770
cases I've got we're actually running

00:23:02,850 --> 00:23:06,330
with the embertec version actually is

00:23:04,770 --> 00:23:09,420
faster than the K buying version and

00:23:06,330 --> 00:23:12,690
obviously I it should be definitely

00:23:09,420 --> 00:23:14,130
possible to to get around that and one

00:23:12,690 --> 00:23:16,470
possibility is just the fact that K

00:23:14,130 --> 00:23:18,750
binds doesn't actually trigger any read

00:23:16,470 --> 00:23:20,760
ahead so it may be that I just need to

00:23:18,750 --> 00:23:22,470
make you know get the UVM stuff to

00:23:20,760 --> 00:23:31,320
actually be reading ahead on the PLT and

00:23:22,470 --> 00:23:34,350
stuff well so you know maybe this system

00:23:31,320 --> 00:23:35,880
causes some problems give a system call

00:23:34,350 --> 00:23:39,770
that allows you to change read-only

00:23:35,880 --> 00:23:42,240
memory what could possibly go wrong

00:23:39,770 --> 00:23:43,500
both the wonderful fire sign theater

00:23:42,240 --> 00:23:53,010
that's the power that can be used only

00:23:43,500 --> 00:23:54,450
for good or evil so is there some way we

00:23:53,010 --> 00:23:55,890
can lock this down you know we don't

00:23:54,450 --> 00:23:57,480
want to dis leave the system call hain

00:23:55,890 --> 00:24:00,420
out there which allows anyone to get

00:23:57,480 --> 00:24:01,620
around em protect I mean I imagine

00:24:00,420 --> 00:24:03,240
there's some processes which actually

00:24:01,620 --> 00:24:08,310
would love to do that but not all of

00:24:03,240 --> 00:24:11,130
them are on our side so we fix it so it

00:24:08,310 --> 00:24:15,270
only is capable capable of being used by

00:24:11,130 --> 00:24:17,010
LDS so in fact we specifically don't

00:24:15,270 --> 00:24:18,870
want this to be a target for a return

00:24:17,010 --> 00:24:21,660
oriented program we don't want it

00:24:18,870 --> 00:24:23,700
possible to return into a call to this

00:24:21,660 --> 00:24:25,680
and then take advantage of the fact that

00:24:23,700 --> 00:24:28,170
I has changed you know

00:24:25,680 --> 00:24:33,720
memory debates effectively executable

00:24:28,170 --> 00:24:36,890
and often do other stuff so we've had a

00:24:33,720 --> 00:24:39,390
number of ideas for how to lock it down

00:24:36,890 --> 00:24:41,910
bunch of checks here the first rule is

00:24:39,390 --> 00:24:44,250
that okay it should be possible to never

00:24:41,910 --> 00:24:46,410
have this fail for legitimate reasons I

00:24:44,250 --> 00:24:49,410
mean LDS Oh should never actually screw

00:24:46,410 --> 00:24:50,820
up right if it screws up and heck the

00:24:49,410 --> 00:24:54,000
process probably should die immediately

00:24:50,820 --> 00:24:55,500
at that point so if any of these checks

00:24:54,000 --> 00:24:57,690
fails we'll just kill the process not

00:24:55,500 --> 00:25:00,870
even a catchable signal will this call

00:24:57,690 --> 00:25:03,630
sigit exit in the kernel directly so uh

00:25:00,870 --> 00:25:05,280
okay we can lock it's a kay bind can

00:25:03,630 --> 00:25:06,650
only be called from one address in

00:25:05,280 --> 00:25:09,540
userspace

00:25:06,650 --> 00:25:12,480
we could pass a per process cookie maybe

00:25:09,540 --> 00:25:14,010
even a per thread cookie we could pass

00:25:12,480 --> 00:25:16,710
in the old data as well the new data the

00:25:14,010 --> 00:25:19,620
kernel could compare them or maybe we

00:25:16,710 --> 00:25:21,030
could like lock down exactly what k bind

00:25:19,620 --> 00:25:25,290
was allowed to touch by marking the

00:25:21,030 --> 00:25:28,440
pages in some way so like while walking

00:25:25,290 --> 00:25:32,940
down the PC we can actually just record

00:25:28,440 --> 00:25:37,140
in the struct process the address from

00:25:32,940 --> 00:25:38,760
which Kay binds was called and you copy

00:25:37,140 --> 00:25:41,390
that address you know that's just copied

00:25:38,760 --> 00:25:44,040
on for work zero an exec and then if

00:25:41,390 --> 00:25:46,980
that changes if it you tried to call it

00:25:44,040 --> 00:25:49,680
from a new address then we've killed the

00:25:46,980 --> 00:25:51,360
process of course and then we can even

00:25:49,680 --> 00:25:53,580
make sure it make it possible for that a

00:25:51,360 --> 00:25:55,230
statically linked program could

00:25:53,580 --> 00:25:56,610
basically take advantage of this to make

00:25:55,230 --> 00:25:58,530
sure that a statically linked program

00:25:56,610 --> 00:26:00,300
would never be able to call this it

00:25:58,530 --> 00:26:04,770
would just make one call that says never

00:26:00,300 --> 00:26:06,660
let me do this again and then the result

00:26:04,770 --> 00:26:11,390
is we then can do inline Azzam in the

00:26:06,660 --> 00:26:14,490
linker and dynamic linker and there we

00:26:11,390 --> 00:26:17,370
we get some leverage from one of our

00:26:14,490 --> 00:26:21,900
other security things the the stack

00:26:17,370 --> 00:26:23,580
protector where if you try to jump into

00:26:21,900 --> 00:26:26,460
the middle of the DL binding function in

00:26:23,580 --> 00:26:28,350
lell DSO where this is sure you might be

00:26:26,460 --> 00:26:31,050
able to get this the function this you

00:26:28,350 --> 00:26:32,490
hit the system call but your stack won't

00:26:31,050 --> 00:26:34,230
have the right snack protector cookie in

00:26:32,490 --> 00:26:36,270
it so cool you made the call and now

00:26:34,230 --> 00:26:38,670
you've you died

00:26:36,270 --> 00:26:41,809
we can leverage that to make it a little

00:26:38,670 --> 00:26:41,809
harder for someone to cause problems

00:26:42,450 --> 00:26:48,059
it also pass a purr process cookie have

00:26:45,780 --> 00:26:51,270
LDS au in its own

00:26:48,059 --> 00:26:54,120
OpenBSD randomize segment things so it

00:26:51,270 --> 00:26:55,800
automatically gets filled in and then on

00:26:54,120 --> 00:26:58,170
the first call we the kernel remembers

00:26:55,800 --> 00:27:00,870
that and we just make sure and we can

00:26:58,170 --> 00:27:03,750
even then order the the logic you know

00:27:00,870 --> 00:27:06,450
the asila that at first you know the dl

00:27:03,750 --> 00:27:09,390
by encode first says ok let me get the

00:27:06,450 --> 00:27:11,880
cookie now let me do the actual logic of

00:27:09,390 --> 00:27:13,740
looking at the symbol and figuring out a

00:27:11,880 --> 00:27:15,690
bar is at this address printf is over

00:27:13,740 --> 00:27:18,450
here or whatever and then I'll call Kate

00:27:15,690 --> 00:27:20,370
ID so I if someone wants to jump into

00:27:18,450 --> 00:27:23,010
the middle the function they can't get

00:27:20,370 --> 00:27:24,870
the cookie load logic without also

00:27:23,010 --> 00:27:27,330
getting the symbol address resolution

00:27:24,870 --> 00:27:30,480
logic so they they kind of have to get

00:27:27,330 --> 00:27:32,460
both of them together but as observed

00:27:30,480 --> 00:27:34,350
you know the an attacker could probably

00:27:32,460 --> 00:27:37,140
figure out where that cookie is in LDS

00:27:34,350 --> 00:27:40,830
those section to memory so it's a little

00:27:37,140 --> 00:27:44,070
unclear on that one how good it is we

00:27:40,830 --> 00:27:47,250
could also pass a per thread cookie and

00:27:44,070 --> 00:27:48,720
then update it even on each call this

00:27:47,250 --> 00:27:51,540
gets really painful because you have to

00:27:48,720 --> 00:27:53,520
actually be doing TCB management

00:27:51,540 --> 00:27:57,450
correctly the thread control block which

00:27:53,520 --> 00:27:59,429
OpenBSD doesn't have right now so it

00:27:57,450 --> 00:28:01,080
also this one is probably gonna be

00:27:59,429 --> 00:28:03,570
probably gonna get we're probably gonna

00:28:01,080 --> 00:28:05,610
drop this just because it's it it's not

00:28:03,570 --> 00:28:08,220
clear what actual security benefits I

00:28:05,610 --> 00:28:12,179
mean it's actually implemented it's

00:28:08,220 --> 00:28:15,390
running on my laptop but in the end it's

00:28:12,179 --> 00:28:17,070
a pain in the butt and if it doesn't

00:28:15,390 --> 00:28:18,450
actually you know we can't even come up

00:28:17,070 --> 00:28:20,510
with we can't come up with a real attack

00:28:18,450 --> 00:28:25,500
vector that it protects against then

00:28:20,510 --> 00:28:27,630
then it's a hand waving we can pass the

00:28:25,500 --> 00:28:28,679
old data so the kernel can then compare

00:28:27,630 --> 00:28:30,630
and make sure it's only changing

00:28:28,679 --> 00:28:33,030
something that looks like a LD SOA

00:28:30,630 --> 00:28:35,520
appeal to your god

00:28:33,030 --> 00:28:37,830
but it's the we're passing the data from

00:28:35,520 --> 00:28:40,020
L DSO itself and there's actually a

00:28:37,830 --> 00:28:44,309
corner case where the binding can

00:28:40,020 --> 00:28:46,650
actually change where if one thread went

00:28:44,309 --> 00:28:48,990
started to resolve a PLT another thread

00:28:46,650 --> 00:28:49,980
dl opened another library and then

00:28:48,990 --> 00:28:51,029
another thread came

00:28:49,980 --> 00:28:53,519
you could actually have a symbol it

00:28:51,029 --> 00:28:57,240
needed to change in the middle of the

00:28:53,519 --> 00:28:58,559
the processing so it would be one really

00:28:57,240 --> 00:29:01,320
hairy case to actually try to figure out

00:28:58,559 --> 00:29:06,240
that that's what happened so it's not

00:29:01,320 --> 00:29:08,399
worth dealing with that so more

00:29:06,240 --> 00:29:11,389
interesting is the idea of doing the

00:29:08,399 --> 00:29:14,130
protected mappings actually this one

00:29:11,389 --> 00:29:16,200
actually got code to implement part of

00:29:14,130 --> 00:29:18,269
this and we can actually mark the PLT in

00:29:16,200 --> 00:29:19,710
God so that it can't actually change

00:29:18,269 --> 00:29:23,250
again now this way we'd actually make

00:29:19,710 --> 00:29:25,440
sure that K bind is the only way that

00:29:23,250 --> 00:29:26,250
those particular pages in the executable

00:29:25,440 --> 00:29:29,010
would be changed you know and the

00:29:26,250 --> 00:29:30,059
process could be changed and that you

00:29:29,010 --> 00:29:33,120
know the key buying could only change

00:29:30,059 --> 00:29:38,600
those pages so it kind of limits the

00:29:33,120 --> 00:29:41,100
exact scope of this this dangerous call

00:29:38,600 --> 00:29:42,480
and then you can also like make sure

00:29:41,100 --> 00:29:48,299
that LDS oh doesn't get out load in

00:29:42,480 --> 00:29:51,000
stuff like that so the status of this

00:29:48,299 --> 00:29:51,389
okay it's no this is actually a work in

00:29:51,000 --> 00:29:55,320
progress

00:29:51,389 --> 00:29:59,659
unfortunately the it works I've been

00:29:55,320 --> 00:30:02,220
working on three of our architectures

00:29:59,659 --> 00:30:04,710
but we're going to want to update to

00:30:02,220 --> 00:30:07,889
deal deal with these issues and make

00:30:04,710 --> 00:30:10,080
sure that the we're not creating too

00:30:07,889 --> 00:30:12,990
much of a headache for ourselves and

00:30:10,080 --> 00:30:15,029
then kind of if we don't want to commit

00:30:12,990 --> 00:30:17,340
something to just a couple of the

00:30:15,029 --> 00:30:18,720
architectures until we have a or pretty

00:30:17,340 --> 00:30:22,019
sure that it's gonna work for all of

00:30:18,720 --> 00:30:23,700
them you know PowerPC we need to make

00:30:22,019 --> 00:30:26,039
sure that actually it we have to switch

00:30:23,700 --> 00:30:29,010
over its ABI to use the the secure PLT

00:30:26,039 --> 00:30:30,240
ABI we actually need to do that I think

00:30:29,010 --> 00:30:33,409
because if the current one I don't think

00:30:30,240 --> 00:30:37,039
it's even thread safe in certain cases

00:30:33,409 --> 00:30:41,190
so that's kind of a looming requirement

00:30:37,039 --> 00:30:42,840
and need to tweak exactly how some of

00:30:41,190 --> 00:30:45,659
the UVM stuff is so we can make sure

00:30:42,840 --> 00:30:49,440
that it's it's actually consistently

00:30:45,659 --> 00:30:52,080
better but it's a it does close the

00:30:49,440 --> 00:30:53,010
writer execute now the other thing to

00:30:52,080 --> 00:30:56,370
note is that

00:30:53,010 --> 00:30:58,379
OpenBSD you we don't actually do some of

00:30:56,370 --> 00:31:00,580
the things that some of you guys have

00:30:58,379 --> 00:31:02,980
actually done I think the free

00:31:00,580 --> 00:31:06,970
see and I think that beasty as well have

00:31:02,980 --> 00:31:11,380
both done a pretty good cleanup job on

00:31:06,970 --> 00:31:14,080
the cymbals exported by Lib C and lippy

00:31:11,380 --> 00:31:16,539
threatened all these with the result

00:31:14,080 --> 00:31:18,789
that there aren't as many PLT entries in

00:31:16,539 --> 00:31:20,169
Lib C to start with I mean it's you

00:31:18,789 --> 00:31:21,760
don't have to you know go through this

00:31:20,169 --> 00:31:25,000
whole song and dance on a peel TN tree

00:31:21,760 --> 00:31:26,740
that doesn't exist so best is to get rid

00:31:25,000 --> 00:31:31,140
of all those iron right now for instance

00:31:26,740 --> 00:31:33,730
our MD 64 Lib C you know 771 PLT entries

00:31:31,140 --> 00:31:36,940
almost all for references to other

00:31:33,730 --> 00:31:40,059
pieces of Lib C just on the off chance

00:31:36,940 --> 00:31:43,149
that someone wants to override printf

00:31:40,059 --> 00:31:45,010
with their executable uh that sounds

00:31:43,149 --> 00:31:49,269
like more of a bad idea of anything else

00:31:45,010 --> 00:31:50,919
so it would be better we think to to do

00:31:49,269 --> 00:31:54,159
the cleanup job that you guys have

00:31:50,919 --> 00:32:02,760
already done and get it to the point

00:31:54,159 --> 00:32:02,760
where there's few or none any questions

00:32:08,130 --> 00:32:13,690
so more of a comment than a question I

00:32:10,840 --> 00:32:16,929
like that you pointed out that it does

00:32:13,690 --> 00:32:19,029
have security implications one of the

00:32:16,929 --> 00:32:20,889
things that you could do which would

00:32:19,029 --> 00:32:24,519
cost a whole heck of a lot in

00:32:20,889 --> 00:32:27,960
performance is sort of reimplemented

00:32:24,519 --> 00:32:31,049
runtime linker inside of the kernel and

00:32:27,960 --> 00:32:36,340
ensure that the new value passed in

00:32:31,049 --> 00:32:40,120
resolves to and also pass in the name of

00:32:36,340 --> 00:32:44,250
the function that you're resolving and

00:32:40,120 --> 00:32:46,240
have the kernel do a double check that

00:32:44,250 --> 00:32:49,690
that have the kernel

00:32:46,240 --> 00:32:53,789
you know crawl through those elf headers

00:32:49,690 --> 00:32:53,789
and do the reservation

00:32:54,240 --> 00:32:59,620
it would be implementing most of the the

00:32:57,700 --> 00:33:01,510
interesting part of the dynamic linker

00:32:59,620 --> 00:33:04,590
at that point yep and walking that

00:33:01,510 --> 00:33:09,580
address space from the kernel would be

00:33:04,590 --> 00:33:11,830
terrifying to do sanely it also it's

00:33:09,580 --> 00:33:13,030
that's a huge chunk of code which I

00:33:11,830 --> 00:33:15,340
would be

00:33:13,030 --> 00:33:18,210
a horrible thing to pull into the kernel

00:33:15,340 --> 00:33:22,480
and we'd rather try to figure out how to

00:33:18,210 --> 00:33:24,340
make it sane to to avoid doing that and

00:33:22,480 --> 00:33:25,660
maybe some of the bits about locking

00:33:24,340 --> 00:33:28,480
down the pages would keep us from

00:33:25,660 --> 00:33:35,680
actually having to go that far

00:33:28,480 --> 00:33:37,000
the note was that it also that of course

00:33:35,680 --> 00:33:39,640
would also make much harder to actually

00:33:37,000 --> 00:33:41,410
make changes to the dynamic linking

00:33:39,640 --> 00:33:43,620
process I mean there's a number of

00:33:41,410 --> 00:33:47,230
enhancements to our dynamic linker and

00:33:43,620 --> 00:33:49,450
in functionality and performance that

00:33:47,230 --> 00:33:52,180
we'd really like to do and putting into

00:33:49,450 --> 00:33:54,760
the kernel all good I mean while doing

00:33:52,180 --> 00:33:56,530
this work once I got a cape mine system

00:33:54,760 --> 00:33:58,590
called my kernel I've been switching

00:33:56,530 --> 00:34:01,240
back and forth between LDS o versions

00:33:58,590 --> 00:34:05,320
with only like two or three cases where

00:34:01,240 --> 00:34:07,660
I've had to you know boot from CD uh-huh

00:34:05,320 --> 00:34:10,210
but it's been much easier to actually

00:34:07,660 --> 00:34:12,340
test various versions of the the

00:34:10,210 --> 00:34:13,840
implementation and to flip back to ok

00:34:12,340 --> 00:34:17,950
let's do a comparison performance wise

00:34:13,840 --> 00:34:19,480
so I pretty I think we would we'd rather

00:34:17,950 --> 00:34:21,550
would probably throw the whole idea off

00:34:19,480 --> 00:34:24,850
the bridge instead Raymond Leiker into

00:34:21,550 --> 00:34:28,260
the kernel let me know how you fix that

00:34:24,850 --> 00:34:28,260
because I would be very much interested

00:34:38,190 --> 00:34:44,879
for the performance testing did you

00:34:40,379 --> 00:34:46,530
compare to running with LD by now I did

00:34:44,879 --> 00:34:47,850
not compare to running LD by now what I

00:34:46,530 --> 00:34:53,760
did do is I actually did a three-way

00:34:47,850 --> 00:34:56,850
comparison of running without any of the

00:34:53,760 --> 00:34:58,530
M protects at all so don't don't do

00:34:56,850 --> 00:35:02,340
these are they OpenBSD you know

00:34:58,530 --> 00:35:05,750
protecting to the gods and actually

00:35:02,340 --> 00:35:07,650
there was very little difference between

00:35:05,750 --> 00:35:10,980
protecting the gods and not protecting

00:35:07,650 --> 00:35:13,650
the got the the memory costs in the that

00:35:10,980 --> 00:35:15,930
I was seen were that they be the the

00:35:13,650 --> 00:35:17,670
performance costs were fraction a

00:35:15,930 --> 00:35:19,050
percent in the you know which actually

00:35:17,670 --> 00:35:22,790
told me that my tests are probably not

00:35:19,050 --> 00:35:25,230
the exact right test at that point but

00:35:22,790 --> 00:35:26,670
no it doing some more broad test say

00:35:25,230 --> 00:35:29,270
okay let's actually pay the cost of

00:35:26,670 --> 00:35:33,690
doing by now and and see what happens

00:35:29,270 --> 00:35:40,020
would be I have a hard time imagining

00:35:33,690 --> 00:35:41,550
that can ever be faster but do you need

00:35:40,020 --> 00:35:42,990
to make a broader comparison of the

00:35:41,550 --> 00:35:45,330
performance of without many of the

00:35:42,990 --> 00:35:48,390
protections with protections as they are

00:35:45,330 --> 00:35:57,810
now in cable on the kind of as a my

00:35:48,390 --> 00:35:59,160
performance metric I have a pretty

00:35:57,810 --> 00:36:02,520
pretty simple question when you

00:35:59,160 --> 00:36:05,250
mentioned that we need to remove expose

00:36:02,520 --> 00:36:08,730
symbols in Lipsy does that mean marking

00:36:05,250 --> 00:36:10,880
more function static so they or how does

00:36:08,730 --> 00:36:13,710
this work how does why are they exposed

00:36:10,880 --> 00:36:15,600
so there's a number of functions

00:36:13,710 --> 00:36:18,450
internal to parts of Lipsy for instance

00:36:15,600 --> 00:36:20,820
you know there's under part of our

00:36:18,450 --> 00:36:21,210
s.find FP or whatever in first did a

00:36:20,820 --> 00:36:23,310
yo-yo

00:36:21,210 --> 00:36:25,260
where you can't does market static

00:36:23,310 --> 00:36:28,109
because it's actually used by functions

00:36:25,260 --> 00:36:31,020
and other translation units so instead

00:36:28,109 --> 00:36:33,000
you actually you can at the elf level

00:36:31,020 --> 00:36:34,320
you can say okay mark this is as

00:36:33,000 --> 00:36:36,380
visibility:hidden

00:36:34,320 --> 00:36:39,359
and then the linker will actually

00:36:36,380 --> 00:36:42,410
eliminated from the dynamic single table

00:36:39,359 --> 00:36:45,390
and if you mark that there's ways you

00:36:42,410 --> 00:36:47,130
roll Rick dripper has this long paper or

00:36:45,390 --> 00:36:49,460
about optimizing the hell out of all

00:36:47,130 --> 00:36:49,460
this stuff

00:36:50,540 --> 00:36:56,520
yes yes yes it's a gia they do you've

00:36:54,240 --> 00:36:57,540
got visibility:hidden thing and if you

00:36:56,520 --> 00:36:59,130
do it right you can actually even

00:36:57,540 --> 00:37:01,890
eliminate you can make it efficiently

00:36:59,130 --> 00:37:03,450
avoid even you know the old the code can

00:37:01,890 --> 00:37:06,120
actually say oh I even though it's in a

00:37:03,450 --> 00:37:07,470
different translation unit it's because

00:37:06,120 --> 00:37:09,030
it's marked as hidden at this time I can

00:37:07,470 --> 00:37:15,630
actually just do a relative call even

00:37:09,030 --> 00:37:24,050
though it's in theory viewer anymore

00:37:15,630 --> 00:37:28,220
Christians so thank you

00:37:24,050 --> 00:37:33,420
[Applause]

00:37:28,220 --> 00:37:33,420

YouTube URL: https://www.youtube.com/watch?v=zohwJoiFXEM


