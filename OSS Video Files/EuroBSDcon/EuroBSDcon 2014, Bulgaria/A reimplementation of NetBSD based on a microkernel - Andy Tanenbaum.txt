Title: A reimplementation of NetBSD based on a microkernel - Andy Tanenbaum
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

The MINIX 3 microkernel has been used as a base to reimplement NetBSD. To application programs, MINIX 3 looks like NetBSD, with the NetBSD headers, libraries, package manager, etc. Thousands of NetBSD packages run on it on the x86 and ARM Cortex V8 (BeagleBones). Inside, however, it is a completely different architecture, with a tiny microkernel and independent servers for memory management, the file system, and each device driver. This architecture has many valuable properties which will be described in the talk, including better security and the ability to recover from many component crashes without running applications even noticing. Updating to a new version of the operating system while it is running and without a reboot is on the roadmap for the future.

Speaker biography:

Born in 1944 in New York, Tanenbaum currently teaches at the Free University of Amsterdam, where since 2008 his research has been under the aegis of a EU grant for design and implementation of particularly stable operating systems. Minix, which he started in the 1980s, is apparently the reference project. Since its third version, the microkernel operating system has been open source under a BSD license.
Captions: 
	00:00:08,179 --> 00:00:13,519
hello everyone may I introduce you to

00:00:10,519 --> 00:00:16,820
Andrew Tannenbaum operating-system

00:00:13,519 --> 00:00:19,340
Acker extraordinaire author of MINIX and

00:00:16,820 --> 00:00:29,779
it will be talking about re-implementing

00:00:19,340 --> 00:00:31,580
net bsd on top of a microkernel never

00:00:29,779 --> 00:00:33,970
shared the stage of the flying goat

00:00:31,580 --> 00:00:36,440
before but the first time for everything

00:00:33,970 --> 00:00:38,449
okay I wrote the first version of Mannix

00:00:36,440 --> 00:00:39,559
but since then all my students and

00:00:38,449 --> 00:00:41,330
programmers have been doing all the work

00:00:39,559 --> 00:00:45,260
three of them are actually here okay

00:00:41,330 --> 00:00:53,839
guys lentil ben and run stand ups people

00:00:45,260 --> 00:01:05,210
can see you also direct all the hard

00:00:53,839 --> 00:01:08,030
questions to them okay let's go so the

00:01:05,210 --> 00:01:11,780
goal of my work is to build a reliable

00:01:08,030 --> 00:01:13,970
operating system so here is my

00:01:11,780 --> 00:01:16,660
definition of a reliable operating

00:01:13,970 --> 00:01:19,070
system you know your mileage may vary an

00:01:16,660 --> 00:01:21,050
operating system is said to be reliable

00:01:19,070 --> 00:01:23,630
when a typical we use it has never

00:01:21,050 --> 00:01:25,430
experienced even a single failure in his

00:01:23,630 --> 00:01:27,640
or her lifetime and does not know

00:01:25,430 --> 00:01:32,150
anybody who's ever experienced a failure

00:01:27,640 --> 00:01:35,540
that's my idea of reliable ok my stereo

00:01:32,150 --> 00:01:38,960
is reliable for example you know my

00:01:35,540 --> 00:01:40,580
watch is reliable in engineering terms

00:01:38,960 --> 00:01:43,670
were probably talking about mean time to

00:01:40,580 --> 00:01:47,540
failure maybe 50 years of my time okay I

00:01:43,670 --> 00:01:49,580
don't think we're there yet ok so I

00:01:47,540 --> 00:01:53,630
think there's some work to be done yet

00:01:49,580 --> 00:01:56,510
ok this is what I call the television

00:01:53,630 --> 00:01:58,990
model at least before smart TV so you go

00:01:56,510 --> 00:02:02,290
back about 5 years you know it's got

00:01:58,990 --> 00:02:06,590
three steps one you buy the television

00:02:02,290 --> 00:02:08,899
two you plug it in three it works

00:02:06,590 --> 00:02:10,580
perfectly for next ten years okay this

00:02:08,899 --> 00:02:11,870
is how televisions used to work until it

00:02:10,580 --> 00:02:17,079
became computer isn't everything changed

00:02:11,870 --> 00:02:20,219
okay now here's the computer model

00:02:17,079 --> 00:02:23,799
windows Edition

00:02:20,219 --> 00:02:25,019
you by the computer you plug it in now

00:02:23,799 --> 00:02:27,370
or 2/3 of the way they are right now

00:02:25,019 --> 00:02:28,450
just this one stuff about it works

00:02:27,370 --> 00:02:30,219
perfectly the next 10 years that we

00:02:28,450 --> 00:02:32,939
haven't got to you now you install

00:02:30,219 --> 00:02:35,290
service packs one through nine s and

00:02:32,939 --> 00:02:38,799
then you install 18 new emergency

00:02:35,290 --> 00:02:40,540
security patches since nine F and then

00:02:38,799 --> 00:02:43,930
you find install seven new drivers

00:02:40,540 --> 00:02:45,819
somehow okay then you find the antivirus

00:02:43,930 --> 00:02:48,219
software and install it and then you

00:02:45,819 --> 00:02:49,780
install the anti spyware software and

00:02:48,219 --> 00:02:52,780
then you install the anti hacker

00:02:49,780 --> 00:02:55,810
software firewall and then you install

00:02:52,780 --> 00:02:58,629
the anti-spam software and then you

00:02:55,810 --> 00:03:00,220
reboot the computer ok but actually

00:02:58,629 --> 00:03:03,730
we're not done yet I'd ran out of space

00:03:00,220 --> 00:03:09,159
on the sheet there's more ok it doesn't

00:03:03,730 --> 00:03:12,040
work if you call the helpdesk ok you

00:03:09,159 --> 00:03:15,549
wait on hold for 30 minutes and they

00:03:12,040 --> 00:03:16,659
tell you to reinstall windows which is

00:03:15,549 --> 00:03:19,480
what you've been trying to do all along

00:03:16,659 --> 00:03:24,129
right so the typical user reaction to

00:03:19,480 --> 00:03:26,650
this is something like this the New York

00:03:24,129 --> 00:03:29,349
Times actually reported once the 25% of

00:03:26,650 --> 00:03:31,239
computer users have gotten so angry the

00:03:29,349 --> 00:03:33,519
computer they actually hit it ok

00:03:31,239 --> 00:03:35,349
and the monitor it's not the problem is

00:03:33,519 --> 00:03:36,879
not the monitor you know I mean yes it's

00:03:35,349 --> 00:03:38,139
probably running and it's more likely

00:03:36,879 --> 00:03:40,449
running Linux as that's inside the

00:03:38,139 --> 00:03:42,430
monitor these days but you know ordinary

00:03:40,449 --> 00:03:43,989
people don't have the understanding of

00:03:42,430 --> 00:03:44,889
you know like we have that nothing works

00:03:43,989 --> 00:03:47,229
ok

00:03:44,889 --> 00:03:50,560
so the question is reliability important

00:03:47,229 --> 00:03:52,389
ok and it doesn't work it's annoying

00:03:50,560 --> 00:03:54,810
you know you might lose work if

00:03:52,389 --> 00:03:57,099
something goes down but also think about

00:03:54,810 --> 00:03:59,319
industrial control systems and factories

00:03:57,099 --> 00:04:00,879
you know some thing moving cars down the

00:03:59,319 --> 00:04:02,680
belt and you know I don't like to stop

00:04:00,879 --> 00:04:04,720
that abruptly because you know all these

00:04:02,680 --> 00:04:06,430
cars bang as each other you know

00:04:04,720 --> 00:04:08,290
electric power grids you know those guys

00:04:06,430 --> 00:04:10,299
kind of frown upon computers failing

00:04:08,290 --> 00:04:12,370
from time to time hospital operating

00:04:10,299 --> 00:04:13,959
room surgeons and a majority of surgeons

00:04:12,370 --> 00:04:15,340
do not like the lights to go out and the

00:04:13,959 --> 00:04:16,780
equipment to go out in the middle of an

00:04:15,340 --> 00:04:19,389
operation this is not one of the their

00:04:16,780 --> 00:04:20,919
favorite things banking and e-commerce

00:04:19,389 --> 00:04:22,599
servers so those guys talk about you

00:04:20,919 --> 00:04:25,150
know mega bucks per minute when

00:04:22,599 --> 00:04:27,039
something goes down emergency phone

00:04:25,150 --> 00:04:29,110
centers end up there cane and you know

00:04:27,039 --> 00:04:30,849
crashes once in a while you know control

00:04:29,110 --> 00:04:31,380
software in cars and airplanes you know

00:04:30,849 --> 00:04:34,470
there's other

00:04:31,380 --> 00:04:36,090
you know other things that people don't

00:04:34,470 --> 00:04:39,750
like when it you know it sort of fails

00:04:36,090 --> 00:04:42,780
okay and so the question is can you make

00:04:39,750 --> 00:04:45,420
anything reliable okay and well we won't

00:04:42,780 --> 00:04:47,640
find out you know if we don't try so I

00:04:45,420 --> 00:04:49,650
was very lucky in that the Dutch royal

00:04:47,640 --> 00:04:52,290
academy of sciences gave me two million

00:04:49,650 --> 00:04:56,280
euros to go try so all right thank you

00:04:52,290 --> 00:04:57,750
I'll take it you know in the European

00:04:56,280 --> 00:04:59,340
Union on top of that make on that

00:04:57,750 --> 00:05:01,230
contract round your opinion you gave me

00:04:59,340 --> 00:05:02,340
to indefinitely New York to continue so

00:05:01,230 --> 00:05:03,660
we had a little funding for a while

00:05:02,340 --> 00:05:05,490
that's all run out and how so we're

00:05:03,660 --> 00:05:08,310
trying going make it I don't know we're

00:05:05,490 --> 00:05:10,440
going to try first of all is reliability

00:05:08,310 --> 00:05:12,720
achievable at all you know can it be

00:05:10,440 --> 00:05:15,000
done you know but actually systems can

00:05:12,720 --> 00:05:17,850
survive hardware failures think about

00:05:15,000 --> 00:05:19,560
some examples you know a raid can

00:05:17,850 --> 00:05:20,880
survive a failed disk so if you have a

00:05:19,560 --> 00:05:22,980
raid system of some kind

00:05:20,880 --> 00:05:24,470
this simply fails you know the the head

00:05:22,980 --> 00:05:26,610
gets little bit too close to the platter

00:05:24,470 --> 00:05:28,800
scrapes all the oxide off the disk makes

00:05:26,610 --> 00:05:31,200
a big noise raids can continue after

00:05:28,800 --> 00:05:32,730
that it designed with fault tolerance in

00:05:31,200 --> 00:05:35,280
them they can go quite happily after

00:05:32,730 --> 00:05:36,810
losing a drive okay and many of these

00:05:35,280 --> 00:05:38,280
things both the bad drive out throwing

00:05:36,810 --> 00:05:39,960
the garbage put a new drive in hit the

00:05:38,280 --> 00:05:42,780
rebuild button somewhere and everything

00:05:39,960 --> 00:05:44,820
goes on merrily along the ECC memory can

00:05:42,780 --> 00:05:49,620
survive failures in memory making

00:05:44,820 --> 00:05:51,300
correct memory errors on the fly TCP can

00:05:49,620 --> 00:05:52,740
survive lost packets you know sends back

00:05:51,300 --> 00:05:56,280
at times out wasn't gonna answer it

00:05:52,740 --> 00:05:58,650
sends it again okay you know CD ROMs but

00:05:56,280 --> 00:06:00,360
but you know the layout on cd-rom drives

00:05:58,650 --> 00:06:02,310
about three-quarters of the bits are our

00:06:00,360 --> 00:06:03,630
correcting bits okay they come in you

00:06:02,310 --> 00:06:05,070
know what you think it was an 8-bit

00:06:03,630 --> 00:06:06,840
group they think of as a fourteen bit

00:06:05,070 --> 00:06:09,090
group with an error correcting code and

00:06:06,840 --> 00:06:10,650
every 2k block is actually about 4k with

00:06:09,090 --> 00:06:12,750
error correcting bits and you know this

00:06:10,650 --> 00:06:14,250
massive error correcting structure with

00:06:12,750 --> 00:06:17,850
all kinds of fancy codes that you can

00:06:14,250 --> 00:06:19,650
survive those things you know and so we

00:06:17,850 --> 00:06:21,120
should have such survived hardware

00:06:19,650 --> 00:06:23,900
failures for Crytek's we should be able

00:06:21,120 --> 00:06:25,950
to survive software failures as well

00:06:23,900 --> 00:06:28,230
okay so I think we need to rethink

00:06:25,950 --> 00:06:29,340
operating systems and the researcher

00:06:28,230 --> 00:06:31,650
bounced them you know we have fairly

00:06:29,340 --> 00:06:33,480
powerful hardware these days on PC class

00:06:31,650 --> 00:06:36,870
machines there's lots of cycles with

00:06:33,480 --> 00:06:39,060
lots of RAM there's lots bandwidth you

00:06:36,870 --> 00:06:40,740
know plenty of software it's got tons of

00:06:39,060 --> 00:06:41,760
bloat in it and useless features and all

00:06:40,740 --> 00:06:43,169
of you know about that

00:06:41,760 --> 00:06:44,680
and of course none of the beasties have

00:06:43,169 --> 00:06:47,060
any bloat but you know

00:06:44,680 --> 00:06:49,580
some unnamed software's are full of

00:06:47,060 --> 00:06:51,770
bloke so it's low and bloated buggy and

00:06:49,580 --> 00:06:53,419
you know I don't know to achieve the TV

00:06:51,770 --> 00:06:55,099
models for the dumb TVs

00:06:53,419 --> 00:06:59,469
I think operating system need to be

00:06:55,099 --> 00:07:03,199
smaller and simpler and more modular and

00:06:59,469 --> 00:07:05,930
you know more reliable and more secure

00:07:03,199 --> 00:07:07,330
and self-healing which is I'll talk

00:07:05,930 --> 00:07:10,479
about quite a bit

00:07:07,330 --> 00:07:12,830
ok so I'll give you a brief history of

00:07:10,479 --> 00:07:15,379
work we've done you know some of you

00:07:12,830 --> 00:07:17,840
know in 1940 weren't born then but 1976

00:07:15,379 --> 00:07:21,319
John Lyons wrote a book about version 6

00:07:17,840 --> 00:07:23,270
UNIX describing in detail you know how

00:07:21,319 --> 00:07:25,099
it worked line by line so like the power

00:07:23,270 --> 00:07:27,680
mood you know this line means this you

00:07:25,099 --> 00:07:29,360
know and so on and then 18 P they

00:07:27,680 --> 00:07:30,740
released version 7 they forbade books on

00:07:29,360 --> 00:07:32,240
this number of books you know we don't

00:07:30,740 --> 00:07:35,000
want anybody to know about our product

00:07:32,240 --> 00:07:36,919
that'd be horrible and then you know in

00:07:35,000 --> 00:07:38,990
about 85 or so I decided maybe I could

00:07:36,919 --> 00:07:40,340
write a unix-like operating system from

00:07:38,990 --> 00:07:41,659
scratch and then it wouldn't you know

00:07:40,340 --> 00:07:42,860
you people could learn about it so I

00:07:41,659 --> 00:07:44,060
started that and took me a couple of

00:07:42,860 --> 00:07:46,759
years long story

00:07:44,060 --> 00:07:49,279
it's another time it's a road book and I

00:07:46,759 --> 00:07:50,840
wrote you know put the the operating

00:07:49,279 --> 00:07:52,969
system in a cd-rom and back of the book

00:07:50,840 --> 00:07:54,409
we know that came later we released in a

00:07:52,969 --> 00:07:56,300
floppy disk initially that's all there

00:07:54,409 --> 00:07:58,250
was the first talk this morning there's

00:07:56,300 --> 00:07:59,900
also pictures of these five inch floppy

00:07:58,250 --> 00:08:04,759
disks we use those also that's what it

00:07:59,900 --> 00:08:07,599
was in 97 was medics two became POSIX

00:08:04,759 --> 00:08:11,379
rather than version seven conformant

00:08:07,599 --> 00:08:14,569
2000 changed the license to BSD license

00:08:11,379 --> 00:08:17,060
2004 I got the grant first grant starts

00:08:14,569 --> 00:08:18,620
working reliable operating systems 2006

00:08:17,060 --> 00:08:20,360
third edition book MINIX three sort of

00:08:18,620 --> 00:08:21,409
corresponds to the third edition the

00:08:20,360 --> 00:08:22,940
book I don't know if it'll be a fourth

00:08:21,409 --> 00:08:24,259
edition I don't think will change the

00:08:22,940 --> 00:08:26,029
name at this point then he got the

00:08:24,259 --> 00:08:27,949
European grant and then the focus moves

00:08:26,029 --> 00:08:28,990
toward embedded systems and not be a

00:08:27,949 --> 00:08:30,979
stick

00:08:28,990 --> 00:08:33,829
okay then three editions of the book

00:08:30,979 --> 00:08:34,820
different pictures alright you know you

00:08:33,829 --> 00:08:39,620
know a little bit about intelligent

00:08:34,820 --> 00:08:41,219
design at least as applied to operating

00:08:39,620 --> 00:08:44,250
systems

00:08:41,219 --> 00:08:46,470
a pillow the users on it's got a

00:08:44,250 --> 00:08:48,569
microkernels about 13,000 lines of code

00:08:46,470 --> 00:08:49,800
you know Linux is got 15 million lines

00:08:48,569 --> 00:08:52,350
of code Windows

00:08:49,800 --> 00:08:54,600
I believe xp had 50 million lines of

00:08:52,350 --> 00:08:57,600
code and I asked a Probert once how big

00:08:54,600 --> 00:08:59,430
was like you know Windows 7 he said you

00:08:57,600 --> 00:09:00,629
know paying so much account but you know

00:08:59,430 --> 00:09:02,459
maybe 100 million lines of code

00:09:00,629 --> 00:09:03,800
something like that and we've got 13

00:09:02,459 --> 00:09:06,720
thousand lines in the code in the kernel

00:09:03,800 --> 00:09:08,490
there's been a lot of studying studies

00:09:06,720 --> 00:09:10,050
of how many bugs per line of code it's

00:09:08,490 --> 00:09:11,850
kind of Leaney you're not quite but

00:09:10,050 --> 00:09:13,889
goodlove studied that you know too many

00:09:11,850 --> 00:09:14,970
companies a bug tracking systems they

00:09:13,889 --> 00:09:17,490
keep track of the stuff people have

00:09:14,970 --> 00:09:19,199
studied some of those and like one to

00:09:17,490 --> 00:09:20,550
ten bugs per thousand lines of code is

00:09:19,199 --> 00:09:22,649
over the normal range you do a really

00:09:20,550 --> 00:09:24,389
good job you can get it down to one bug

00:09:22,649 --> 00:09:26,339
per thousand lines of code but that's

00:09:24,389 --> 00:09:28,829
relatively rare and it doesn't decrease

00:09:26,339 --> 00:09:30,509
over time either because you let keep

00:09:28,829 --> 00:09:31,310
adding new codes but you know it new

00:09:30,509 --> 00:09:34,110
bugs

00:09:31,310 --> 00:09:35,850
it's a MINIX you might have 13 bugs in

00:09:34,110 --> 00:09:38,160
the carnal who's it's got 13,000 lines

00:09:35,850 --> 00:09:40,290
of code and you know linux probably has

00:09:38,160 --> 00:09:43,529
15,000 bugs in it and bsd you know

00:09:40,290 --> 00:09:45,120
comparable number not all the bugs are

00:09:43,529 --> 00:09:46,380
fatal and the bug might be a typing

00:09:45,120 --> 00:09:47,939
error and some message somewhere it

00:09:46,380 --> 00:09:49,259
doesn't you know spelling error somebody

00:09:47,939 --> 00:09:51,149
got a comma wrong and some message it

00:09:49,259 --> 00:09:52,949
displays but some of the bugs you know

00:09:51,149 --> 00:09:55,529
or more critical bashes you may have

00:09:52,949 --> 00:09:56,850
heard had a bug in it recently that they

00:09:55,529 --> 00:09:58,350
got a certain amount of attention has

00:09:56,850 --> 00:10:00,120
been in there for 25 years nobody

00:09:58,350 --> 00:10:04,319
noticed that you know these things

00:10:00,120 --> 00:10:05,819
happen you know drivers tend to have

00:10:04,319 --> 00:10:07,620
people of study it's three to seven

00:10:05,819 --> 00:10:09,630
times more bugs than the rest of the

00:10:07,620 --> 00:10:11,220
kernel and 70 percent of the code is the

00:10:09,630 --> 00:10:14,490
drivers that's not a good you know a

00:10:11,220 --> 00:10:18,630
good ratio there I think good system

00:10:14,490 --> 00:10:20,040
should be modular and you know example

00:10:18,630 --> 00:10:22,230
operating systems aren't the most

00:10:20,040 --> 00:10:24,269
complicated things around like an

00:10:22,230 --> 00:10:26,040
aircraft carrier it's much more

00:10:24,269 --> 00:10:28,290
complicated than an operating system

00:10:26,040 --> 00:10:29,880
okay very very complicated system but

00:10:28,290 --> 00:10:33,149
they understand that the systems there

00:10:29,880 --> 00:10:34,620
should be modular so you know if for

00:10:33,149 --> 00:10:36,420
example one of the toilets gets plugged

00:10:34,620 --> 00:10:39,420
up it doesn't begin firing nuclear

00:10:36,420 --> 00:10:40,949
missiles okay because the missile system

00:10:39,420 --> 00:10:41,759
and the toilet systems are fairly

00:10:40,949 --> 00:10:44,339
decoupled

00:10:41,759 --> 00:10:45,629
you know and likewise if incoming

00:10:44,339 --> 00:10:48,449
missiles a detective the toilets don't

00:10:45,629 --> 00:10:51,059
start flushing because they understand

00:10:48,449 --> 00:10:52,709
you know you want a modular system where

00:10:51,059 --> 00:10:54,579
the different parts don't interact all

00:10:52,709 --> 00:10:56,470
over the place you put you know

00:10:54,579 --> 00:10:57,910
in lines of code in the kernel and you

00:10:56,470 --> 00:10:59,739
know who knows what the interactions are

00:10:57,910 --> 00:11:03,519
so I think modularity is a very

00:10:59,739 --> 00:11:05,649
important thing here you know isolate

00:11:03,519 --> 00:11:06,910
the the components all the little bow

00:11:05,649 --> 00:11:09,459
modules want to move everything we could

00:11:06,910 --> 00:11:11,049
out of the kernel that means all the

00:11:09,459 --> 00:11:12,610
drivers old file systems memory

00:11:11,049 --> 00:11:13,809
management process management pretty

00:11:12,610 --> 00:11:17,410
much everything's been moved out of the

00:11:13,809 --> 00:11:19,420
kernel every module runs with the Polo

00:11:17,410 --> 00:11:20,949
the principle of least Authority so a

00:11:19,420 --> 00:11:22,839
module it's running out of the kernel

00:11:20,949 --> 00:11:24,939
only has the authority to do those

00:11:22,839 --> 00:11:26,949
things it needs to do so if you're an

00:11:24,939 --> 00:11:29,230
audio driver you need access one way or

00:11:26,949 --> 00:11:30,339
another to the audio card but you don't

00:11:29,230 --> 00:11:32,499
need access to the disk

00:11:30,339 --> 00:11:35,739
okay so we've tried made a very very big

00:11:32,499 --> 00:11:38,199
effort to limit what each piece can do

00:11:35,739 --> 00:11:40,059
and every time some user at land

00:11:38,199 --> 00:11:41,649
component does something is a check or

00:11:40,059 --> 00:11:43,089
you will authorize to do it if the

00:11:41,649 --> 00:11:46,149
answer is no you get back an error error

00:11:43,089 --> 00:11:49,839
code saying no permission okay so the

00:11:46,149 --> 00:11:51,699
next step was to isolate the the i/o so

00:11:49,839 --> 00:11:52,989
you know all the devices were isolated

00:11:51,699 --> 00:11:54,759
every driver is a separate process

00:11:52,989 --> 00:11:56,889
running in user mode protected by the

00:11:54,759 --> 00:11:58,959
MMU it doesn't even have access to its

00:11:56,889 --> 00:12:01,419
own ports okay it's got to ask the

00:11:58,959 --> 00:12:03,160
kernel if it wants to actual i/o so if

00:12:01,419 --> 00:12:04,720
this trucker wants to do I oh it's kind

00:12:03,160 --> 00:12:06,339
of say you know write these values into

00:12:04,720 --> 00:12:08,290
these registers and tells them the

00:12:06,339 --> 00:12:10,389
microkernel go do that the kernel checks

00:12:08,290 --> 00:12:12,279
if that particular process is authorized

00:12:10,389 --> 00:12:14,379
to use those ports if the answer is yes

00:12:12,279 --> 00:12:16,480
it does it the answer is no gets back an

00:12:14,379 --> 00:12:18,459
error code saying no permission okay so

00:12:16,480 --> 00:12:20,619
somebody takes over an audio driver due

00:12:18,459 --> 00:12:22,959
to flaws in the Audio Driver it can make

00:12:20,619 --> 00:12:24,279
really weird noises but it can't for

00:12:22,959 --> 00:12:26,350
cash L because it doesn't have the

00:12:24,279 --> 00:12:28,269
authority to fork anything okay so it

00:12:26,350 --> 00:12:31,660
gives you a lot more security because in

00:12:28,269 --> 00:12:34,809
the modular ization okay so step three

00:12:31,660 --> 00:12:36,160
is isolate the communication so there's

00:12:34,809 --> 00:12:37,779
a lot of you know the system is all

00:12:36,160 --> 00:12:40,119
these processes and user mode for

00:12:37,779 --> 00:12:41,470
drivers and file systems and stuff not

00:12:40,119 --> 00:12:43,149
everybody can talk to everybody they

00:12:41,470 --> 00:12:44,529
wants to talk to be it's got to go to

00:12:43,149 --> 00:12:45,879
the kernel and say you know I'm a I want

00:12:44,529 --> 00:12:48,819
to talk to be first thing it does is

00:12:45,879 --> 00:12:50,410
check is a authorized to talk to B and

00:12:48,819 --> 00:12:52,209
if the answer is yes then it'll send the

00:12:50,410 --> 00:12:54,220
message and if the answer is no you get

00:12:52,209 --> 00:12:55,720
back an arrow saying no permission okay

00:12:54,220 --> 00:12:57,790
so you can't just send to anybody

00:12:55,720 --> 00:12:59,499
whereas in a monolithic kernel any

00:12:57,790 --> 00:13:01,079
driver can you know talk to any other

00:12:59,499 --> 00:13:05,289
component there's not nobody's checking

00:13:01,079 --> 00:13:07,350
and that again restricts you know damage

00:13:05,289 --> 00:13:09,810
on us of a need-to-know basis

00:13:07,350 --> 00:13:11,400
a basis also kernel calls this the

00:13:09,810 --> 00:13:13,620
microkernel itself has a number of calls

00:13:11,400 --> 00:13:15,840
for very low-level things like creating

00:13:13,620 --> 00:13:17,250
a new stack and stuff like that but this

00:13:15,840 --> 00:13:18,960
is a different level of interface in the

00:13:17,250 --> 00:13:20,640
POSIX interface which comes in much

00:13:18,960 --> 00:13:23,100
higher level again not every call is

00:13:20,640 --> 00:13:25,290
awful available to every process so an

00:13:23,100 --> 00:13:26,820
audio driver can't do the things you

00:13:25,290 --> 00:13:28,710
need to build a new process so there's a

00:13:26,820 --> 00:13:30,720
low level equivalent of fork because the

00:13:28,710 --> 00:13:31,980
bitmap for it for the kernel call you

00:13:30,720 --> 00:13:33,270
know the kernel checks the bitmap and if

00:13:31,980 --> 00:13:35,070
the bit is zero it says you're not

00:13:33,270 --> 00:13:36,810
allowed to to create a new process of

00:13:35,070 --> 00:13:39,150
the answer's no and so if somebody takes

00:13:36,810 --> 00:13:40,440
over some component tries to do

00:13:39,150 --> 00:13:41,160
something that that component can't do

00:13:40,440 --> 00:13:46,350
the answer's no

00:13:41,160 --> 00:13:49,290
so that again restricts damage okay one

00:13:46,350 --> 00:13:50,370
problem we had was that you know we

00:13:49,290 --> 00:13:52,110
originally had synchronous communication

00:13:50,370 --> 00:13:52,530
it sends a message the big waits for an

00:13:52,110 --> 00:13:54,090
answer

00:13:52,530 --> 00:13:57,330
trouble is if a sensor measures the

00:13:54,090 --> 00:14:00,180
b-and-b dies then a hangs because a you

00:13:57,330 --> 00:14:01,620
know the other half isn't there anymore

00:14:00,180 --> 00:14:03,330
so we had to go to a synchronous

00:14:01,620 --> 00:14:05,610
communication well we don't like it okay

00:14:03,330 --> 00:14:10,920
now here's the the architecture of

00:14:05,610 --> 00:14:13,050
mimics kind of in a in a nutshell the

00:14:10,920 --> 00:14:14,490
bottom layer is microkernel handle to

00:14:13,050 --> 00:14:16,500
interrupts processing some of the

00:14:14,490 --> 00:14:17,370
schedule the clock inter process

00:14:16,500 --> 00:14:19,590
communication

00:14:17,370 --> 00:14:22,770
kind of the low-level stuff okay next

00:14:19,590 --> 00:14:25,950
level up our user level processes all

00:14:22,770 --> 00:14:28,050
running protected by the MMU as normal

00:14:25,950 --> 00:14:30,240
processes for the drivers like the disk

00:14:28,050 --> 00:14:32,940
driver and terminal networking and

00:14:30,240 --> 00:14:36,780
printing and all other drivers running

00:14:32,940 --> 00:14:37,980
as usable processes above there are the

00:14:36,780 --> 00:14:39,690
servers which are sort of the real

00:14:37,980 --> 00:14:42,480
operating system you know the virtual

00:14:39,690 --> 00:14:44,550
file server and any other any actual

00:14:42,480 --> 00:14:46,830
file servers and the process manager and

00:14:44,550 --> 00:14:48,450
memory manager and things you expect in

00:14:46,830 --> 00:14:50,970
an operating system are all running a

00:14:48,450 --> 00:14:52,950
separate isolated processes there's

00:14:50,970 --> 00:14:54,240
actually no difference technically

00:14:52,950 --> 00:14:56,340
between those levels they just separate

00:14:54,240 --> 00:14:58,290
processes but conceptually it's good to

00:14:56,340 --> 00:15:00,360
think about it like that and then above

00:14:58,290 --> 00:15:02,220
that or the user the true user processes

00:15:00,360 --> 00:15:05,570
running shells and make and you know

00:15:02,220 --> 00:15:05,570
other user applications

00:15:09,630 --> 00:15:16,870
so these are motor drivers each driver

00:15:15,100 --> 00:15:18,339
runs is using my process that doesn't

00:15:16,870 --> 00:15:20,019
have any super years of privileges so

00:15:18,339 --> 00:15:22,390
the operating system drivers and the

00:15:20,019 --> 00:15:23,649
other pieces have only the the pole of

00:15:22,390 --> 00:15:25,510
Principles principle of least Authority

00:15:23,649 --> 00:15:27,130
they have exactly what they need

00:15:25,510 --> 00:15:30,490
controlled by various bitmaps in the

00:15:27,130 --> 00:15:31,899
kernel and so on they're protected by

00:15:30,490 --> 00:15:34,600
the MMU so they can't escape their

00:15:31,899 --> 00:15:36,550
address space they do not have access

00:15:34,600 --> 00:15:37,990
even to their own i/o ports they have to

00:15:36,550 --> 00:15:39,550
ask the colonel it's embarrassing if

00:15:37,990 --> 00:15:42,010
you're a disc driver you can't touch the

00:15:39,550 --> 00:15:43,600
disk that's the way it is you know you

00:15:42,010 --> 00:15:44,980
as this driver ask the colonel could you

00:15:43,600 --> 00:15:47,140
please write these things onto the disk

00:15:44,980 --> 00:15:48,459
you know IO registers and kernel checks

00:15:47,140 --> 00:15:51,000
in if it's okay does it otherwise it

00:15:48,459 --> 00:15:53,950
doesn't okay

00:15:51,000 --> 00:15:55,660
so user mode servers a bunch of them

00:15:53,950 --> 00:15:57,730
each server again runs as a separate

00:15:55,660 --> 00:16:00,670
process some of the key ones or there's

00:15:57,730 --> 00:16:02,529
a virtual file service file virtual file

00:16:00,670 --> 00:16:05,260
system which you know so there's a top

00:16:02,529 --> 00:16:07,420
level of the things so basically when

00:16:05,260 --> 00:16:09,339
you do a read call let's say a user

00:16:07,420 --> 00:16:11,620
process there's a little library routine

00:16:09,339 --> 00:16:13,000
in Lib C and all that thing does is it

00:16:11,620 --> 00:16:14,350
sends a message to the virtual file

00:16:13,000 --> 00:16:16,690
system saying here are the parameters

00:16:14,350 --> 00:16:18,010
for read go to the read and the virtual

00:16:16,690 --> 00:16:19,870
file system figures out which actual

00:16:18,010 --> 00:16:23,560
file system it isn't you know sense of

00:16:19,870 --> 00:16:25,120
the message and you go to the read so

00:16:23,560 --> 00:16:27,430
there's the actual file servers as the

00:16:25,120 --> 00:16:31,089
native mimics file system maybe XT to

00:16:27,430 --> 00:16:32,920
this ISO 96 others in various other file

00:16:31,089 --> 00:16:34,329
systems I don't know if we have fuse or

00:16:32,920 --> 00:16:35,980
not I think we might have had that once

00:16:34,329 --> 00:16:38,230
how much of it's still there but you

00:16:35,980 --> 00:16:40,800
know other just like any other systems

00:16:38,230 --> 00:16:43,270
VFS and lots of file systems on there

00:16:40,800 --> 00:16:45,820
it's process manager there's memory

00:16:43,270 --> 00:16:47,320
manager it's a network server it's this

00:16:45,820 --> 00:16:49,779
thing called a reincarnation server

00:16:47,320 --> 00:16:51,970
which is unusual it's job is to

00:16:49,779 --> 00:16:53,740
reincarnate the dead okay that's a

00:16:51,970 --> 00:16:56,290
useful thing to have basically it sits

00:16:53,740 --> 00:16:58,209
there pinging the other pieces it's sort

00:16:56,290 --> 00:17:00,160
of a parent of everything it pings other

00:16:58,209 --> 00:17:01,630
pieces as the reincarnation server will

00:17:00,160 --> 00:17:04,630
send a message to the disk driver and

00:17:01,630 --> 00:17:06,669
say hi disk driver how you don't disturb

00:17:04,630 --> 00:17:08,829
it says doing great sir 47 requests last

00:17:06,669 --> 00:17:10,900
second and then a little bit later it

00:17:08,829 --> 00:17:12,790
says I just driver how you doing and I

00:17:10,900 --> 00:17:14,410
said it's doing great serve 74 questions

00:17:12,790 --> 00:17:17,610
on a second and a little bit later it

00:17:14,410 --> 00:17:17,610
says this driver how you doing

00:17:19,600 --> 00:17:25,900
this driver how are you doing I'll give

00:17:25,059 --> 00:17:28,600
you one more try

00:17:25,900 --> 00:17:29,830
how are you doing if there's no answer

00:17:28,600 --> 00:17:32,830
it you know it'll kill it start a new

00:17:29,830 --> 00:17:34,540
line and can regenerate it okay you can

00:17:32,830 --> 00:17:35,860
say how do you fetch the disk driver if

00:17:34,540 --> 00:17:38,260
you want a disk driver well we keep the

00:17:35,860 --> 00:17:40,270
disk driver and RAM and once you have a

00:17:38,260 --> 00:17:41,530
disk driver from RAM you can get the

00:17:40,270 --> 00:17:43,750
rest of the drivers from disk if need be

00:17:41,530 --> 00:17:46,419
so it can repair the damage which makes

00:17:43,750 --> 00:17:47,950
it self-healing which is you know that

00:17:46,419 --> 00:17:50,919
and part of the schedule it runs in user

00:17:47,950 --> 00:17:52,630
mode to the policy mechanism separation

00:17:50,919 --> 00:17:55,570
the policy runs in user mode in the

00:17:52,630 --> 00:17:58,120
mechanism runs in the kernel here's an

00:17:55,570 --> 00:18:00,040
example of how things sort of normally

00:17:58,120 --> 00:18:02,169
work user sends a message to the file

00:18:00,040 --> 00:18:03,490
set match I've eliminated the virtual

00:18:02,169 --> 00:18:05,440
file system partners and let's see

00:18:03,490 --> 00:18:07,030
suppose the block you want is in the

00:18:05,440 --> 00:18:09,250
cache so you send some message to the

00:18:07,030 --> 00:18:11,020
file system faster than you know just to

00:18:09,250 --> 00:18:13,809
the kernel go copy this block to user

00:18:11,020 --> 00:18:15,340
mode you know kernel replies okay copies

00:18:13,809 --> 00:18:20,580
the block to user mode and usually got

00:18:15,340 --> 00:18:23,020
his walk okay now suppose it's not in

00:18:20,580 --> 00:18:24,910
the file systems gas use it calls the

00:18:23,020 --> 00:18:26,230
filesystem filesystem says I don't have

00:18:24,910 --> 00:18:28,210
the block calls the disk driver says

00:18:26,230 --> 00:18:29,679
please go read this block you know this

00:18:28,210 --> 00:18:31,809
driver tells the kernel go read the

00:18:29,679 --> 00:18:33,549
block eventually a notification ie an

00:18:31,809 --> 00:18:35,049
interrupt comes in from the disk that's

00:18:33,549 --> 00:18:37,360
turned into a message at a very low

00:18:35,049 --> 00:18:39,490
level this driver gets a message saying

00:18:37,360 --> 00:18:41,830
hi I'm the disk it does actually have

00:18:39,490 --> 00:18:43,330
any content this driver then starts it

00:18:41,830 --> 00:18:45,580
looks at its registers figures out you

00:18:43,330 --> 00:18:46,150
know what happens and then it tells the

00:18:45,580 --> 00:18:48,250
filesystem

00:18:46,150 --> 00:18:49,929
okay the the DMA is completed you've got

00:18:48,250 --> 00:18:52,780
the block in the place you asked for it

00:18:49,929 --> 00:18:53,950
and then it tells the kernel copy to use

00:18:52,780 --> 00:18:55,630
them all and copies the user mode and

00:18:53,950 --> 00:18:57,190
users happy so there's a bunch of

00:18:55,630 --> 00:18:59,230
matches back and forth these things take

00:18:57,190 --> 00:19:01,299
some fraction of a microsecond so

00:18:59,230 --> 00:19:02,950
there's some some performance hit here

00:19:01,299 --> 00:19:04,450
other people we haven't really focused

00:19:02,950 --> 00:19:06,580
much on performance other people like

00:19:04,450 --> 00:19:08,200
the all four people for Linux have got

00:19:06,580 --> 00:19:10,990
the performance hit down to five or 10%

00:19:08,200 --> 00:19:12,460
we haven't really focused on that but

00:19:10,990 --> 00:19:13,960
it's doable you know from their

00:19:12,460 --> 00:19:15,640
experience so again here's this

00:19:13,960 --> 00:19:18,309
reincarnation server it's the parent of

00:19:15,640 --> 00:19:20,620
all the drivers in the servers and a

00:19:18,309 --> 00:19:22,780
driver you know server dines it hears

00:19:20,620 --> 00:19:24,100
about it you know trial died and it can

00:19:22,780 --> 00:19:25,750
collect it basically runs the shell

00:19:24,100 --> 00:19:27,280
script what I do now you know it can

00:19:25,750 --> 00:19:29,380
notify the administrator can go fetch

00:19:27,280 --> 00:19:31,600
the new driver can get log at some work

00:19:29,380 --> 00:19:32,660
and all kinds of stuff and then go get a

00:19:31,600 --> 00:19:35,810
new one you know

00:19:32,660 --> 00:19:36,860
and if I say it pings them frequently

00:19:35,810 --> 00:19:40,250
too you know

00:19:36,860 --> 00:19:42,470
see how they're doing okay so here's how

00:19:40,250 --> 00:19:45,290
like this driver recovery works just as

00:19:42,470 --> 00:19:46,970
an example okay so the user sends a

00:19:45,290 --> 00:19:48,380
message the filesystem you know go read

00:19:46,970 --> 00:19:50,960
a block or go you know read a chunk of

00:19:48,380 --> 00:19:52,550
file file system sends a message to the

00:19:50,960 --> 00:19:54,860
disk driver you know he wants this block

00:19:52,550 --> 00:19:58,100
number so-and-so and this driver feels

00:19:54,860 --> 00:20:00,320
okay hit a you know bad address or

00:19:58,100 --> 00:20:01,760
something okay what happens is the Reena

00:20:00,320 --> 00:20:03,890
connection server hears about that you

00:20:01,760 --> 00:20:06,380
know it's the parent it's child died

00:20:03,890 --> 00:20:08,150
it's not a fight of that this is oh my

00:20:06,380 --> 00:20:09,350
child I know it's horrible let's do

00:20:08,150 --> 00:20:11,390
something which I do well how about

00:20:09,350 --> 00:20:12,620
creating a new one so okay so the disc

00:20:11,390 --> 00:20:14,330
driver it takes a copy from the RAM disk

00:20:12,620 --> 00:20:15,950
case of any other driver goes and

00:20:14,330 --> 00:20:18,080
fetches it from the hard disk or

00:20:15,950 --> 00:20:19,430
wherever you wanted to fetch it from it

00:20:18,080 --> 00:20:21,860
starts up a new one tells the file

00:20:19,430 --> 00:20:23,480
system file system then tells you know

00:20:21,860 --> 00:20:25,910
it's what has to remember and it's

00:20:23,480 --> 00:20:28,520
structured what it was doing okay so it

00:20:25,910 --> 00:20:31,100
says to the new driver ok can you read

00:20:28,520 --> 00:20:33,020
the block and you're back on course so

00:20:31,100 --> 00:20:35,780
the idea is that you can recover from

00:20:33,020 --> 00:20:37,460
actual failures its fault tolerant the

00:20:35,780 --> 00:20:39,410
fault tolerant means you can actually

00:20:37,460 --> 00:20:41,300
tolerate faults which is a different

00:20:39,410 --> 00:20:43,760
strategy than trying to you know avoid

00:20:41,300 --> 00:20:45,710
false so ideal world there wouldn't be

00:20:43,760 --> 00:20:47,480
any faults but experience shows there's

00:20:45,710 --> 00:20:49,220
one bug four thousand lines of code no

00:20:47,480 --> 00:20:51,320
matter what you do so they're gonna be

00:20:49,220 --> 00:20:52,850
false so we have probably as many faults

00:20:51,320 --> 00:20:54,770
per line of lines of code as anybody

00:20:52,850 --> 00:20:57,140
else does only they're all separated and

00:20:54,770 --> 00:21:00,040
isolated and that the damage they can do

00:20:57,140 --> 00:21:01,910
is less because of the system structure

00:21:00,040 --> 00:21:04,670
okay

00:21:01,910 --> 00:21:07,190
so systems self-healing and that's very

00:21:04,670 --> 00:21:09,140
important you know concept of it can fix

00:21:07,190 --> 00:21:10,700
its own errors to some extent not for

00:21:09,140 --> 00:21:13,550
everything but for something it's more

00:21:10,700 --> 00:21:15,290
work and more things there's also some

00:21:13,550 --> 00:21:17,510
security implications here fewer

00:21:15,290 --> 00:21:19,670
critical lines of code means fewer

00:21:17,510 --> 00:21:22,400
critical bugs your total bugs probably

00:21:19,670 --> 00:21:24,530
the same but they're less dangerous

00:21:22,400 --> 00:21:26,600
because they're all you know up in user

00:21:24,530 --> 00:21:28,580
space so the trusted computing base is

00:21:26,600 --> 00:21:30,140
smaller than most systems also there's

00:21:28,580 --> 00:21:31,910
no foreign code in the kernel it's

00:21:30,140 --> 00:21:33,650
important you know other systems you get

00:21:31,910 --> 00:21:36,050
a new device need you to put somebody

00:21:33,650 --> 00:21:37,880
else's code in your kernel and there's a

00:21:36,050 --> 00:21:40,520
fair chance that code written by some

00:21:37,880 --> 00:21:42,560
kid in Taiwan and his boss was beating

00:21:40,520 --> 00:21:44,510
them finished finished let's get a ship

00:21:42,560 --> 00:21:45,800
ship the product shipped the product the

00:21:44,510 --> 00:21:46,490
kid didn't have time to test it so I

00:21:45,800 --> 00:21:48,050
skip that

00:21:46,490 --> 00:21:50,330
you know you're putting on your kernel

00:21:48,050 --> 00:21:52,430
okay here you're putting that you know

00:21:50,330 --> 00:21:54,080
if they're in a user mode process where

00:21:52,430 --> 00:21:55,010
it can't them as much damage if

00:21:54,080 --> 00:21:57,470
something's wrong with it and of course

00:21:55,010 --> 00:21:59,900
the drivers are very bugging me you know

00:21:57,470 --> 00:22:01,790
that we've got no Malik in the kernel

00:21:59,900 --> 00:22:03,230
salts tannic which is a bit wasteful but

00:22:01,790 --> 00:22:05,330
it's also more reliable because you know

00:22:03,230 --> 00:22:06,860
you have to explain to you guys but now

00:22:05,330 --> 00:22:11,090
I can free and all the bugs you get man

00:22:06,860 --> 00:22:13,040
so um you know so putting bugs in user

00:22:11,090 --> 00:22:14,600
space kind of cages them you know

00:22:13,040 --> 00:22:16,400
there's number of bugs probably isn't

00:22:14,600 --> 00:22:19,210
any different than any other system but

00:22:16,400 --> 00:22:23,810
they can do less damage because they're

00:22:19,210 --> 00:22:25,610
you know isolated ok inter-process

00:22:23,810 --> 00:22:27,350
communication we use fixed Alliance

00:22:25,610 --> 00:22:29,960
messages we change the message length

00:22:27,350 --> 00:22:32,480
the first time in 30 years last week

00:22:29,960 --> 00:22:34,490
he's kind of 64 bytes that gives us more

00:22:32,480 --> 00:22:37,310
more space to do things but fixed length

00:22:34,490 --> 00:22:38,660
means no buffer overruns one constant

00:22:37,310 --> 00:22:40,370
somewhere an adder which says message

00:22:38,660 --> 00:22:43,400
size I should know what constant it's

00:22:40,370 --> 00:22:45,230
it's a big as bunch of structs for the

00:22:43,400 --> 00:22:46,400
difference message types and there's a

00:22:45,230 --> 00:22:48,200
union of all these things and that

00:22:46,400 --> 00:22:50,870
determines the message size and that 64

00:22:48,200 --> 00:22:53,210
bytes so the variable size leaves the

00:22:50,870 --> 00:22:54,590
buffer overruns and allocation problems

00:22:53,210 --> 00:22:56,030
you know of any of that cuz it's it's

00:22:54,590 --> 00:22:58,280
simple

00:22:56,030 --> 00:23:00,380
we had a rendezvous system a sense to be

00:22:58,280 --> 00:23:02,120
you know waits for an answer answer

00:23:00,380 --> 00:23:03,830
comes back we eventually had to give up

00:23:02,120 --> 00:23:06,230
on that because the problem was you know

00:23:03,830 --> 00:23:07,610
client sent to the server server did

00:23:06,230 --> 00:23:09,230
some work sent back and the client died

00:23:07,610 --> 00:23:11,060
the server was hanging with this message

00:23:09,230 --> 00:23:13,040
it couldn't get rid of so we had to go

00:23:11,060 --> 00:23:14,990
to asynchronous messages so if against

00:23:13,040 --> 00:23:16,910
their will to some extent but that was

00:23:14,990 --> 00:23:18,680
it was a good scheme while it lasted we

00:23:16,910 --> 00:23:20,630
try to use it as much as we can but

00:23:18,680 --> 00:23:23,440
there are situations where you can't so

00:23:20,630 --> 00:23:25,730
we had a ID a synchronous messages

00:23:23,440 --> 00:23:27,290
interrupt some messages a unified at the

00:23:25,730 --> 00:23:29,000
very very low level when an interrupt

00:23:27,290 --> 00:23:30,350
happens that's instantly by the

00:23:29,000 --> 00:23:32,210
microkernel turned into a message

00:23:30,350 --> 00:23:33,830
whoever's you know so listening for the

00:23:32,210 --> 00:23:35,540
message so we don't see interrupts

00:23:33,830 --> 00:23:36,860
except for a little bit of assembly code

00:23:35,540 --> 00:23:38,330
to the very bottom you know citizen

00:23:36,860 --> 00:23:40,580
Interop happens somebody is getting a

00:23:38,330 --> 00:23:41,600
message and then they do receive and

00:23:40,580 --> 00:23:42,710
they get a message and they can do it

00:23:41,600 --> 00:23:45,850
everything wrong with it so we get

00:23:42,710 --> 00:23:49,130
interrupts out of the way very fast okay

00:23:45,850 --> 00:23:50,900
driver reliability drivers we assume

00:23:49,130 --> 00:23:52,190
drivers are untrusted everybody else

00:23:50,900 --> 00:23:53,630
assumes drivers are trusted cuz they're

00:23:52,190 --> 00:23:55,100
going on the kernel so our attitude

00:23:53,630 --> 00:23:56,660
toward farm-raised you can't trust them

00:23:55,100 --> 00:23:58,290
which i think experience shows is

00:23:56,660 --> 00:24:00,760
probably true

00:23:58,290 --> 00:24:02,170
bugs and viruses can't spread to other

00:24:00,760 --> 00:24:06,820
modules because each one is a separate

00:24:02,170 --> 00:24:08,530
process the driver is an piece of the

00:24:06,820 --> 00:24:09,880
operation that can't touch the kernel

00:24:08,530 --> 00:24:12,100
code that can't touch the kernel data

00:24:09,880 --> 00:24:13,840
they can't touch other pieces of the

00:24:12,100 --> 00:24:16,000
operating system old link touches what's

00:24:13,840 --> 00:24:17,950
in their address space and the MMU keeps

00:24:16,000 --> 00:24:19,330
them from touching things outside their

00:24:17,950 --> 00:24:20,980
address space so they can't you know

00:24:19,330 --> 00:24:23,290
there's all kinds of leaks that can

00:24:20,980 --> 00:24:24,700
happen and some drivers reading critical

00:24:23,290 --> 00:24:26,980
kernel tables they can't there's no way

00:24:24,700 --> 00:24:28,180
to do that unless there's a kernel call

00:24:26,980 --> 00:24:30,310
which they're making which gives them

00:24:28,180 --> 00:24:31,630
access but then it's a bitmap which says

00:24:30,310 --> 00:24:33,460
whether or not they can make that kernel

00:24:31,630 --> 00:24:35,530
map calling only if they're authorized

00:24:33,460 --> 00:24:37,000
to do that which is generally not the

00:24:35,530 --> 00:24:38,950
case can they do that so we can limit

00:24:37,000 --> 00:24:41,830
with what they can learn the damage they

00:24:38,950 --> 00:24:43,240
can do you know bad pointers or buffer

00:24:41,830 --> 00:24:45,490
overruns so that kind of stuff can only

00:24:43,240 --> 00:24:49,420
affect one component cuz they're all you

00:24:45,490 --> 00:24:50,800
know isolated like that infinite loops

00:24:49,420 --> 00:24:52,810
you know if somebody gets into a loop

00:24:50,800 --> 00:24:54,070
and somebody else pings it and doesn't

00:24:52,810 --> 00:24:55,690
answer the pain because it's sitting in

00:24:54,070 --> 00:24:57,250
a loop well the other guy will kill it

00:24:55,690 --> 00:24:59,050
you know and restart it so we can

00:24:57,250 --> 00:25:01,330
recover from infinite loops most systems

00:24:59,050 --> 00:25:03,070
there's a bug somehow in the critical

00:25:01,330 --> 00:25:05,230
kernel code and you know it's looping

00:25:03,070 --> 00:25:07,600
well you know it just hangs in our case

00:25:05,230 --> 00:25:09,430
it will get killed and restarted access

00:25:07,600 --> 00:25:11,440
the i/o ports is limited access the

00:25:09,430 --> 00:25:12,610
kernel calls is limited access you know

00:25:11,440 --> 00:25:13,960
inter-process communication is what

00:25:12,610 --> 00:25:19,210
having is limited so it's very very

00:25:13,960 --> 00:25:20,500
walled off okay no other advantages it's

00:25:19,210 --> 00:25:21,250
a shorter development cycles it's

00:25:20,500 --> 00:25:23,260
developing something

00:25:21,250 --> 00:25:25,510
it's just user mode process users come

00:25:23,260 --> 00:25:26,710
and go start a driver and it starts it

00:25:25,510 --> 00:25:28,750
in user mode and you know if it dies

00:25:26,710 --> 00:25:30,370
well you can try to debug it you can get

00:25:28,750 --> 00:25:31,750
a core dump to you know sort of the

00:25:30,370 --> 00:25:33,400
normal programming model for

00:25:31,750 --> 00:25:35,440
applications programs it makes it easier

00:25:33,400 --> 00:25:37,630
than dealing with the bare metal so

00:25:35,440 --> 00:25:38,650
there's basically no downtime if

00:25:37,630 --> 00:25:40,480
something crashes are just you know

00:25:38,650 --> 00:25:44,470
process crash same way you use a process

00:25:40,480 --> 00:25:45,850
crashed the debugging is easier and it's

00:25:44,470 --> 00:25:46,930
more flexible you can do the file

00:25:45,850 --> 00:25:49,810
systems that's way everything just a

00:25:46,930 --> 00:25:54,100
user process so it's a easier model than

00:25:49,810 --> 00:25:55,570
dealing with the bare metal okay we did

00:25:54,100 --> 00:25:56,080
a fault injection experimental while

00:25:55,570 --> 00:25:57,850
back

00:25:56,080 --> 00:25:59,230
we injected eight hundred thousand

00:25:57,850 --> 00:26:02,470
faults at the each of three Ethernet

00:25:59,230 --> 00:26:03,940
drivers and we basically did on the

00:26:02,470 --> 00:26:06,460
binary driver so we weren't recompiling

00:26:03,940 --> 00:26:10,180
so you know we had a Pete you know Pete

00:26:06,460 --> 00:26:11,760
race like mechanism which basically went

00:26:10,180 --> 00:26:13,850
into the binaries and made

00:26:11,760 --> 00:26:16,740
but it didn't write random junk it

00:26:13,850 --> 00:26:18,540
emulated changes that similar to

00:26:16,740 --> 00:26:20,130
programming errors like there'd be a

00:26:18,540 --> 00:26:22,500
swap the source and destination

00:26:20,130 --> 00:26:24,570
addresses or it would change a loop

00:26:22,500 --> 00:26:26,370
condition from branch less than to

00:26:24,570 --> 00:26:27,990
branch less than or equal you know the

00:26:26,370 --> 00:26:29,700
kind of things a programmer might do so

00:26:27,990 --> 00:26:31,230
these are very carefully are people the

00:26:29,700 --> 00:26:33,540
whole framework to make very carefully

00:26:31,230 --> 00:26:35,970
orchestrated errors like that and we

00:26:33,540 --> 00:26:37,860
introduced like 100 you know faults and

00:26:35,970 --> 00:26:39,630
then let it run for a while waited for a

00:26:37,860 --> 00:26:42,450
second it's even anything crashed and if

00:26:39,630 --> 00:26:43,560
not put another 100 faults I'm not

00:26:42,450 --> 00:26:45,000
through with you yet it's another

00:26:43,560 --> 00:26:48,030
hundred falls well eventually we got a

00:26:45,000 --> 00:26:50,250
multiple crash but even that we brought

00:26:48,030 --> 00:26:52,320
down the drivers in all the time we

00:26:50,250 --> 00:26:53,910
never lost the operating system so you

00:26:52,320 --> 00:26:56,010
know the driver would crash and you know

00:26:53,910 --> 00:26:58,260
if you kill them the driver every two

00:26:56,010 --> 00:27:00,750
seconds performance went down I mean you

00:26:58,260 --> 00:27:02,070
know this is a hit there but if your

00:27:00,750 --> 00:27:03,960
drivers crashing every two seconds

00:27:02,070 --> 00:27:09,180
probably should try to debug it you know

00:27:03,960 --> 00:27:10,230
so um anyway so now the story of the

00:27:09,180 --> 00:27:12,630
port to the arm

00:27:10,230 --> 00:27:15,030
we had a restructure the source tree you

00:27:12,630 --> 00:27:17,970
know it's funny many sworn actually had

00:27:15,030 --> 00:27:19,650
targets for the 68000 for the Atari and

00:27:17,970 --> 00:27:21,450
for the Amiga and for the Macintosh and

00:27:19,650 --> 00:27:23,010
had the spark and a whole bunch of

00:27:21,450 --> 00:27:26,280
different ports and that's sort of got

00:27:23,010 --> 00:27:28,110
lost somewhere in the 80s or 90s and so

00:27:26,280 --> 00:27:29,910
we had to restructure the tree again to

00:27:28,110 --> 00:27:32,910
handle multiple architectures the

00:27:29,910 --> 00:27:35,700
support for you boots you know heard

00:27:32,910 --> 00:27:37,440
about earlier we wrote the low-level

00:27:35,700 --> 00:27:38,880
code for dealing with the hardware or

00:27:37,440 --> 00:27:40,080
because the arm is you know very bottom

00:27:38,880 --> 00:27:43,230
code interrupts and stuff a little bit

00:27:40,080 --> 00:27:44,580
different context switching paging and

00:27:43,230 --> 00:27:46,220
so on has somewhat differences they had

00:27:44,580 --> 00:27:49,020
to be changed the room did most of that

00:27:46,220 --> 00:27:50,910
the x86 segmentation had been in there

00:27:49,020 --> 00:27:53,730
from the beginning it started on the

00:27:50,910 --> 00:27:55,710
8088 which only had segmentation didn't

00:27:53,730 --> 00:27:58,380
have paging and when the 386 come in we

00:27:55,710 --> 00:27:59,760
added paging but Eggman tation was still

00:27:58,380 --> 00:28:02,780
there we figured you know maybe it's

00:27:59,760 --> 00:28:05,370
time to throw it out like a thrown out

00:28:02,780 --> 00:28:09,150
imported the net bsd arm headers and

00:28:05,370 --> 00:28:11,730
libraries build that sh

00:28:09,150 --> 00:28:13,410
came in Lionel did a lot of that wrote

00:28:11,730 --> 00:28:16,350
the drivers for SD cards and some of the

00:28:13,410 --> 00:28:17,760
other beagle devices so there was a lot

00:28:16,350 --> 00:28:20,490
of change when we sort of went to the

00:28:17,760 --> 00:28:22,380
arm and moved many things over that way

00:28:20,490 --> 00:28:24,360
then we began looking at embedded

00:28:22,380 --> 00:28:25,380
systems as the target is the the beagle

00:28:24,360 --> 00:28:27,570
black some of you

00:28:25,380 --> 00:28:29,700
you know that's mentioned earlier today

00:28:27,570 --> 00:28:33,090
it's about you know size of a small

00:28:29,700 --> 00:28:35,760
phone but it's pretty powerful it's got

00:28:33,090 --> 00:28:37,650
you know it's an arm v7 32-bit

00:28:35,760 --> 00:28:40,260
architecture clock runs at a gigahertz

00:28:37,650 --> 00:28:43,140
so half a gig of ram on it four

00:28:40,260 --> 00:28:46,470
gigabytes of disk flash memory it's got

00:28:43,140 --> 00:28:48,750
an HDMI it's a 1080p 92y opens you can

00:28:46,470 --> 00:28:50,580
control things from 100 megabit Ethernet

00:28:48,750 --> 00:28:52,320
it's got a USB port on it it's open

00:28:50,580 --> 00:28:54,120
source arguments open source the

00:28:52,320 --> 00:28:55,500
documentation is open source it's in

00:28:54,120 --> 00:28:57,360
contrast to the Raspberry Pi archive

00:28:55,500 --> 00:28:58,770
needs a secret so here whole thing's

00:28:57,360 --> 00:29:00,570
open source you can find everyone know

00:28:58,770 --> 00:29:03,390
about the Beagle boards and and there

00:29:00,570 --> 00:29:05,460
the black is $55 and I think the bingo

00:29:03,390 --> 00:29:07,289
board wide is $45 so they're fairly

00:29:05,460 --> 00:29:08,580
cheap and presumably to where did these

00:29:07,289 --> 00:29:13,020
things in large quantities they're a lot

00:29:08,580 --> 00:29:16,770
cheaper now I will admit that I was

00:29:13,020 --> 00:29:18,780
wrong on January 29 1992 I posted the

00:29:16,770 --> 00:29:20,340
comp a telex at MINIX don't get me wrong

00:29:18,780 --> 00:29:21,539
this is when Linux was getting started

00:29:20,340 --> 00:29:23,250
and people were talking about it on the

00:29:21,539 --> 00:29:24,690
news group done gonna be wrong I'm not

00:29:23,250 --> 00:29:26,400
unhappy with Linux I'll get all the

00:29:24,690 --> 00:29:29,760
people off my back on when I turn MINIX

00:29:26,400 --> 00:29:31,530
in the BSD I apologize I actually do

00:29:29,760 --> 00:29:41,190
want to turn MINIX into BSD it just took

00:29:31,530 --> 00:29:42,440
me 20 years to figure it out sorry don't

00:29:41,190 --> 00:29:46,289
want to start into Linux them

00:29:42,440 --> 00:29:47,610
okay so Linux meets BSD what's gonna

00:29:46,289 --> 00:29:50,159
happen now

00:29:47,610 --> 00:29:51,840
so here's we have a logo you have a logo

00:29:50,159 --> 00:29:53,370
of some kind you know we simply just use

00:29:51,840 --> 00:30:00,620
the heads which is the whole logo and

00:29:53,370 --> 00:30:00,620
the end and there's you know this day

00:30:01,850 --> 00:30:09,179
thanks to a room for this idea and you

00:30:07,770 --> 00:30:11,309
know the the daemon that should probably

00:30:09,179 --> 00:30:11,820
know is copyright by Marshall Kirk

00:30:11,309 --> 00:30:13,500
McKusick

00:30:11,820 --> 00:30:21,539
and Thank You Kirk for permission to use

00:30:13,500 --> 00:30:23,570
this okay or maybe not sure which this

00:30:21,539 --> 00:30:25,350
mixture should be something like this

00:30:23,570 --> 00:30:26,760
why BSD

00:30:25,350 --> 00:30:28,650
well because we didn't have much

00:30:26,760 --> 00:30:30,330
application software you know it so the

00:30:28,650 --> 00:30:32,820
version 7 software but not much else

00:30:30,330 --> 00:30:34,559
and BSD is sort of a proven stable

00:30:32,820 --> 00:30:35,940
mature quality product and it seems to

00:30:34,559 --> 00:30:39,210
be you're gonna join up with somebody

00:30:35,940 --> 00:30:40,920
else a bunch of people are join up with

00:30:39,210 --> 00:30:43,410
I think the code by and large ISM in

00:30:40,920 --> 00:30:45,600
Linux sort of just grew by Topsy and I

00:30:43,410 --> 00:30:48,030
don't think quality control is high on

00:30:45,600 --> 00:30:49,920
their list of a lot of things there's a

00:30:48,030 --> 00:30:51,660
lot of things that do very very well but

00:30:49,920 --> 00:30:55,020
it's the coders will be messy sometimes

00:30:51,660 --> 00:30:56,670
and we have packaged source and

00:30:55,020 --> 00:30:58,500
Purgatory's as wonderful as all of you

00:30:56,670 --> 00:31:00,510
know and there's a lot of packages out

00:30:58,500 --> 00:31:02,160
there thousands of very good packages

00:31:00,510 --> 00:31:04,110
it's an active community out there

00:31:02,160 --> 00:31:06,000
there's a license compatibility issue

00:31:04,110 --> 00:31:08,040
which is you know it's heard earlier

00:31:06,000 --> 00:31:10,140
today not everybody likes the GPL

00:31:08,040 --> 00:31:12,690
version three we don't even like the GPL

00:31:10,140 --> 00:31:15,840
version 3 with version 1 and so the BSD

00:31:12,690 --> 00:31:17,610
license says go take it there's only one

00:31:15,840 --> 00:31:20,340
thing you can't do and that's to us but

00:31:17,610 --> 00:31:21,540
other than that third of you want so you

00:31:20,340 --> 00:31:23,490
know there's a license compatibility

00:31:21,540 --> 00:31:25,290
Wynette BSD is opposed to one of the

00:31:23,490 --> 00:31:28,050
other biggest days I know it's a tough

00:31:25,290 --> 00:31:30,420
call but our feeling had been because

00:31:28,050 --> 00:31:32,790
net BSD is so you know if it's so much

00:31:30,420 --> 00:31:33,930
of a portability that you know

00:31:32,790 --> 00:31:35,520
portability forces you to have

00:31:33,930 --> 00:31:37,320
relatively clean code you'll see if it's

00:31:35,520 --> 00:31:39,330
gonna run on the kitchen sink you know

00:31:37,320 --> 00:31:41,640
and everybody's motorcycle then you

00:31:39,330 --> 00:31:42,930
can't use weird peculiarities of the

00:31:41,640 --> 00:31:45,510
hard work because that's not going to be

00:31:42,930 --> 00:31:47,070
available on some other platform so you

00:31:45,510 --> 00:31:48,990
kind of have to you know keep it

00:31:47,070 --> 00:31:51,390
relatively clean we thought that would

00:31:48,990 --> 00:31:53,400
be true and what we've seen it that sort

00:31:51,390 --> 00:31:55,140
of relatively true and maybe somewhat

00:31:53,400 --> 00:31:57,120
less so on systems where the emphasis on

00:31:55,140 --> 00:31:59,130
performance around you know other things

00:31:57,120 --> 00:32:01,170
so we thought that's not BSD would be a

00:31:59,130 --> 00:32:03,240
good choice we made that decision so

00:32:01,170 --> 00:32:04,230
some of the net features the main

00:32:03,240 --> 00:32:06,660
compiler is crying

00:32:04,230 --> 00:32:11,220
you know LLVM toolkit which is very nice

00:32:06,660 --> 00:32:12,450
compiler and this is an aside one of my

00:32:11,220 --> 00:32:17,310
students is trying to do some some work

00:32:12,450 --> 00:32:19,470
on Linux using our software and we need

00:32:17,310 --> 00:32:21,510
to compile Linux with clang it's

00:32:19,470 --> 00:32:22,950
horrible it's just horrible commend it

00:32:21,510 --> 00:32:24,570
you know it just doesn't mean it's

00:32:22,950 --> 00:32:26,640
endless hundreds and hundreds of places

00:32:24,570 --> 00:32:28,860
in the code where it doesn't compile

00:32:26,640 --> 00:32:30,930
because they've used peculiar features

00:32:28,860 --> 00:32:32,580
of GCC which are not part of the C

00:32:30,930 --> 00:32:34,680
language and they have to sort of go

00:32:32,580 --> 00:32:36,690
after them one at a time and there is a

00:32:34,680 --> 00:32:38,910
group trying to maintain Linux you know

00:32:36,690 --> 00:32:41,640
in enquiring but it's it's a struggle

00:32:38,910 --> 00:32:43,620
and so and we have clang and we've stuck

00:32:41,640 --> 00:32:46,710
to the official C definition for most

00:32:43,620 --> 00:32:49,170
part and okay we have net theist BSD

00:32:46,710 --> 00:32:50,970
built system build sh lentils doesn't

00:32:49,170 --> 00:32:51,280
work on that very good build system ISM

00:32:50,970 --> 00:32:54,370
for me

00:32:51,280 --> 00:32:56,620
you know helps with portability I'll

00:32:54,370 --> 00:32:58,930
file format source code tree is kind of

00:32:56,620 --> 00:33:00,430
model on the net bsd tree so that bsd

00:32:58,930 --> 00:33:01,410
person looks at our tree you say this

00:33:00,430 --> 00:33:03,430
looks familiar

00:33:01,410 --> 00:33:06,880
headers and libraries are all stolen

00:33:03,430 --> 00:33:08,920
from that BSP we have packaged torus we

00:33:06,880 --> 00:33:11,500
able to build about 4200 packages out of

00:33:08,920 --> 00:33:12,340
the box there's one thing we don't quite

00:33:11,500 --> 00:33:14,860
have x11

00:33:12,340 --> 00:33:16,150
used to work but it sort of got broken

00:33:14,860 --> 00:33:17,530
somewhere along the line where the

00:33:16,150 --> 00:33:19,570
process of fixing it which i think is

00:33:17,530 --> 00:33:20,860
maybe a few weeks work and that'll open

00:33:19,570 --> 00:33:24,550
it probably another three thousand

00:33:20,860 --> 00:33:26,470
packages but anyway so you know it's a

00:33:24,550 --> 00:33:28,450
Roma spec so here's a little smallest

00:33:26,470 --> 00:33:29,950
things we don't have okay we don't have

00:33:28,450 --> 00:33:31,750
kernel threads you know I just it was

00:33:29,950 --> 00:33:33,340
long history of Bank it's an educational

00:33:31,750 --> 00:33:35,320
system it wasn't in there we do have P

00:33:33,340 --> 00:33:37,630
threads in user land as usual and

00:33:35,320 --> 00:33:39,460
package so packages that need P threads

00:33:37,630 --> 00:33:40,780
and don't care whether they're user land

00:33:39,460 --> 00:33:42,490
or kernel they work fine

00:33:40,780 --> 00:33:45,880
it's got to be kernel feds then there's

00:33:42,490 --> 00:33:49,270
a problem some of the system calls are

00:33:45,880 --> 00:33:50,680
missing we don't have lwp or message of

00:33:49,270 --> 00:33:53,380
sim calls I mean some of those should be

00:33:50,680 --> 00:33:56,590
added probably off clone some of the get

00:33:53,380 --> 00:33:58,750
novel calls K Q and K trace aren't there

00:33:56,590 --> 00:34:00,010
job control isn't there sorry if you

00:33:58,750 --> 00:34:01,810
have X I don't see what you need job

00:34:00,010 --> 00:34:03,610
control but you know some of the weird

00:34:01,810 --> 00:34:05,500
socket options aren't there but you know

00:34:03,610 --> 00:34:09,850
a lot of it's there and we can build

00:34:05,500 --> 00:34:12,040
4200 packages QA tests bottom you know

00:34:09,850 --> 00:34:14,200
there's 500 tested 500 tests that fail

00:34:12,040 --> 00:34:18,280
but there's 2,100 tests that succeeded

00:34:14,200 --> 00:34:20,919
so the bottom line here is that 81% of

00:34:18,280 --> 00:34:23,919
the QA test passed okay so to get

00:34:20,919 --> 00:34:26,560
through 81% of the nut BSD test you said

00:34:23,919 --> 00:34:29,679
of 81% compatible in some abstract sense

00:34:26,560 --> 00:34:31,360
so we're not fully there but we're a lot

00:34:29,679 --> 00:34:34,440
of the way there you know 81 percent of

00:34:31,360 --> 00:34:34,440
the way there for whatever that's worth

00:34:35,520 --> 00:34:40,270
so here's this the system architecture

00:34:38,290 --> 00:34:40,899
this is the microkernel is the drivers

00:34:40,270 --> 00:34:43,419
the server's

00:34:40,899 --> 00:34:46,330
that's all mimic stuff okay and then on

00:34:43,419 --> 00:34:48,550
top of that is user land you know the

00:34:46,330 --> 00:34:51,460
regular packages and package source and

00:34:48,550 --> 00:34:54,220
shells that's on that BSD so what we've

00:34:51,460 --> 00:34:56,590
done is we've reimplemented the net BS

00:34:54,220 --> 00:34:58,780
the user land and software and packages

00:34:56,590 --> 00:35:01,330
and shells and all that stuff on top of

00:34:58,780 --> 00:35:02,920
a different underlying substrate which

00:35:01,330 --> 00:35:04,810
has these self-healing properties and

00:35:02,920 --> 00:35:07,120
reliability properties and all other

00:35:04,810 --> 00:35:09,670
things that other systems don't have so

00:35:07,120 --> 00:35:12,040
it's a funny mixture of to the user

00:35:09,670 --> 00:35:14,230
level stuff it's just net bsd or 81

00:35:12,040 --> 00:35:15,640
percent net bsd i know if it's linear

00:35:14,230 --> 00:35:18,340
doctors the things we didn't do our kind

00:35:15,640 --> 00:35:19,930
of peculiar so i think most things don't

00:35:18,340 --> 00:35:21,580
need that stuff but there's a few that

00:35:19,930 --> 00:35:22,900
gonna need it and the bottom layer has

00:35:21,580 --> 00:35:24,940
all this reliabilities thought from the

00:35:22,900 --> 00:35:27,520
better security and why not so it's an

00:35:24,940 --> 00:35:31,300
attempt to rethink the way one could

00:35:27,520 --> 00:35:33,460
implement a net be a state we have this

00:35:31,300 --> 00:35:36,400
three beagle boards we've worked on it's

00:35:33,460 --> 00:35:38,260
the the BeagleBoard XM biggle bone wide

00:35:36,400 --> 00:35:40,180
be able in black we can't read the

00:35:38,260 --> 00:35:43,270
letters but basic Green is good and red

00:35:40,180 --> 00:35:44,920
is bed okay and and I'm the black which

00:35:43,270 --> 00:35:46,300
is the one with mostly focused on it's

00:35:44,920 --> 00:35:48,340
mostly green a little bit of red there's

00:35:46,300 --> 00:35:49,720
a couple of strange things like analog

00:35:48,340 --> 00:35:52,210
digital converter we don't have as a

00:35:49,720 --> 00:35:55,120
driver for that and you know the yellow

00:35:52,210 --> 00:35:57,310
is the USB USB is just barely made it

00:35:55,120 --> 00:35:59,640
into the distribution the hot plug

00:35:57,310 --> 00:36:02,140
ability doesn't always work but you know

00:35:59,640 --> 00:36:04,060
we're working we're fixing that so if

00:36:02,140 --> 00:36:05,980
you put a plug is thick in live it might

00:36:04,060 --> 00:36:08,140
not work if you put the stick in first

00:36:05,980 --> 00:36:09,610
and then boot it then it works so we're

00:36:08,140 --> 00:36:10,870
not we're not quite there for most for

00:36:09,610 --> 00:36:15,520
the for the black and for the white

00:36:10,870 --> 00:36:18,310
we're mostly there that was your role

00:36:15,520 --> 00:36:20,980
like where am I here well it's an open

00:36:18,310 --> 00:36:22,750
source project okay so all the sources

00:36:20,980 --> 00:36:24,670
are out there and we hope some of you

00:36:22,750 --> 00:36:26,980
will join us certainly people who have

00:36:24,670 --> 00:36:28,840
an interest in that BSD and look want to

00:36:26,980 --> 00:36:32,020
see a new way of thinking about net BSD

00:36:28,840 --> 00:36:33,340
of some of you will join here are some

00:36:32,020 --> 00:36:36,100
of the things you might do there's some

00:36:33,340 --> 00:36:37,720
system calls that are missing you know

00:36:36,100 --> 00:36:39,100
we don't have every call necessarily

00:36:37,720 --> 00:36:40,960
things that are really hard to do and

00:36:39,100 --> 00:36:43,450
mess up the structure and aren't that

00:36:40,960 --> 00:36:44,290
important you know maybe it's better to

00:36:43,450 --> 00:36:46,510
do without them because I think

00:36:44,290 --> 00:36:47,650
simplicity is really the the key here

00:36:46,510 --> 00:36:50,230
but there might be a few things that

00:36:47,650 --> 00:36:51,820
aren't that hard to do but which be

00:36:50,230 --> 00:36:52,450
really quite useful and we didn't have

00:36:51,820 --> 00:36:53,770
the time

00:36:52,450 --> 00:36:56,170
you know maybe they should be added

00:36:53,770 --> 00:36:58,090
certainly more packages you know some

00:36:56,170 --> 00:37:00,400
packages are blocked because some

00:36:58,090 --> 00:37:01,990
library is missing or whatever we don't

00:37:00,400 --> 00:37:03,670
have Java but you don't we have we have

00:37:01,990 --> 00:37:06,130
links which is a text browsable you

00:37:03,670 --> 00:37:07,660
don't have a you know a visual browser

00:37:06,130 --> 00:37:09,130
there's Dillo there's a bunch of little

00:37:07,660 --> 00:37:11,140
browsers out there besides fire fire

00:37:09,130 --> 00:37:12,910
boxes you know gigantic but there's a

00:37:11,140 --> 00:37:13,660
bunch of smaller browsers out there that

00:37:12,910 --> 00:37:15,220
are reasonable

00:37:13,660 --> 00:37:17,050
it'll be nice if somebody would find you

00:37:15,220 --> 00:37:17,650
know some other graphical browser and

00:37:17,050 --> 00:37:20,020
and port

00:37:17,650 --> 00:37:21,549
that we don't we don't have every single

00:37:20,020 --> 00:37:23,619
driver for the BeagleBoard zip you don't

00:37:21,549 --> 00:37:25,660
really analog digital drivers a couple

00:37:23,619 --> 00:37:28,329
of the minor pieces were missing this we

00:37:25,660 --> 00:37:30,490
could do one of those get running on

00:37:28,329 --> 00:37:32,650
Raspberry Pi and other platforms you

00:37:30,490 --> 00:37:34,270
know so in that because these people the

00:37:32,650 --> 00:37:35,500
attitude as it runs everywhere basically

00:37:34,270 --> 00:37:39,130
people could try to make this run

00:37:35,500 --> 00:37:40,119
everywhere you know rump talking about

00:37:39,130 --> 00:37:41,890
rump this morning a certainly

00:37:40,119 --> 00:37:44,680
interesting idea we're interested in

00:37:41,890 --> 00:37:46,990
rump you know we don't have any kind of

00:37:44,680 --> 00:37:49,059
a GUI really just sort of when x11 comes

00:37:46,990 --> 00:37:52,059
back it'll be proper x11 to use it now

00:37:49,059 --> 00:37:54,010
the best way simply to SSH into it from

00:37:52,059 --> 00:37:55,869
some other computer and then just work

00:37:54,010 --> 00:37:58,329
on the other computers you know X or

00:37:55,869 --> 00:37:59,380
whatever just X terms but there's a

00:37:58,329 --> 00:38:00,579
couple of libraries I think if you

00:37:59,380 --> 00:38:02,319
ported does it might well be that some

00:38:00,579 --> 00:38:04,240
of the gooeys would work after you get a

00:38:02,319 --> 00:38:05,349
couple of libraries ported and there's a

00:38:04,240 --> 00:38:07,210
lot of other things to do so there's

00:38:05,349 --> 00:38:08,710
lots of interesting projects around for

00:38:07,210 --> 00:38:12,609
somebody who wants to sort of hack on

00:38:08,710 --> 00:38:16,420
this so get involved so here's MINIX in

00:38:12,609 --> 00:38:19,630
a kind of a nutshell you know it's open

00:38:16,420 --> 00:38:21,910
source it's got a BSD license is all of

00:38:19,630 --> 00:38:23,079
you know there are companies you know I

00:38:21,910 --> 00:38:25,480
have where my students used to work in

00:38:23,079 --> 00:38:27,640
IBM and they wanted to put you know help

00:38:25,480 --> 00:38:29,799
with Linux and he said you know IBM was

00:38:27,640 --> 00:38:30,910
really people Hutton the company said

00:38:29,799 --> 00:38:31,960
you know we're not really keen about

00:38:30,910 --> 00:38:33,849
putting a hundred million dollars at

00:38:31,960 --> 00:38:36,130
this and giving everything we did into

00:38:33,849 --> 00:38:38,680
our competitors you know and the GPL

00:38:36,130 --> 00:38:40,359
course required that and the BSD license

00:38:38,680 --> 00:38:41,770
if you want to tell us what you did

00:38:40,359 --> 00:38:43,569
that's fine if you know that's also fine

00:38:41,770 --> 00:38:45,309
if you'd like us to put it in the system

00:38:43,569 --> 00:38:46,690
so it's there in the next release you

00:38:45,309 --> 00:38:48,670
should probably want to tell us about it

00:38:46,690 --> 00:38:50,410
but it's your call you don't have to if

00:38:48,670 --> 00:38:52,059
you don't want it so I think one of the

00:38:50,410 --> 00:38:54,190
strong points of the BSD licenses all of

00:38:52,059 --> 00:38:57,250
you know it's quite compatible user

00:38:54,190 --> 00:39:01,589
level 81% compatible whatever that means

00:38:57,250 --> 00:39:04,390
with net BSD it supports LLVM and GCC

00:39:01,589 --> 00:39:07,930
you know the preferred compiler is LOV

00:39:04,390 --> 00:39:09,160
implying but we do have GCC also uses

00:39:07,930 --> 00:39:11,200
package service which is you know

00:39:09,160 --> 00:39:13,119
wonderful as all of you know we build

00:39:11,200 --> 00:39:15,930
4200 packages and it'll soon be about

00:39:13,119 --> 00:39:18,579
7,000 when we get x11 running again

00:39:15,930 --> 00:39:20,799
another thing which we have in the lab

00:39:18,579 --> 00:39:22,660
but it's not on the current releases

00:39:20,799 --> 00:39:25,750
live update we have the ability we have

00:39:22,660 --> 00:39:27,160
the ability in a lab to replace the

00:39:25,750 --> 00:39:27,700
operating system on the fly with the

00:39:27,160 --> 00:39:30,240
next release

00:39:27,700 --> 00:39:33,099
while it's running without affecting

00:39:30,240 --> 00:39:34,210
running programs okay so you want to put

00:39:33,099 --> 00:39:35,530
it in a new file system which is got

00:39:34,210 --> 00:39:37,059
different data structures and you know

00:39:35,530 --> 00:39:39,940
everything we can do that on the fly

00:39:37,059 --> 00:39:42,369
basically okay so the way it works is we

00:39:39,940 --> 00:39:44,740
start up a process and run put it into

00:39:42,369 --> 00:39:46,720
it the new version the new version then

00:39:44,740 --> 00:39:49,270
goes to the old version and says I need

00:39:46,720 --> 00:39:51,700
your state okay because we're using LLVM

00:39:49,270 --> 00:39:54,490
the compiler has put information meta

00:39:51,700 --> 00:39:56,049
metadata in RAM about this is a struct

00:39:54,490 --> 00:39:57,520
and it's so big and it's got these

00:39:56,049 --> 00:39:59,619
fields and sort of call this is other

00:39:57,520 --> 00:40:01,839
types and so on so the new one can go to

00:39:59,619 --> 00:40:03,640
the old one and say you know okay give

00:40:01,839 --> 00:40:05,049
me the first data structure and then it

00:40:03,640 --> 00:40:06,130
will give it the first data structure

00:40:05,049 --> 00:40:08,109
and tell you it's you know it's a struct

00:40:06,130 --> 00:40:09,490
it's got six members and here's the

00:40:08,109 --> 00:40:11,829
types of the members near the values and

00:40:09,490 --> 00:40:14,109
so on it creates in memory that thing

00:40:11,829 --> 00:40:15,880
including possibly conversions from oh

00:40:14,109 --> 00:40:17,950
you had a linked list before and now you

00:40:15,880 --> 00:40:19,030
want a hash table so the guy who wrote

00:40:17,950 --> 00:40:20,680
the new version has to write a little

00:40:19,030 --> 00:40:22,540
function to do the conversion but it's

00:40:20,680 --> 00:40:24,819
in principle doable okay and then it

00:40:22,540 --> 00:40:26,109
says okay give me the next one and one

00:40:24,819 --> 00:40:27,880
of the time you do that and when we're

00:40:26,109 --> 00:40:29,710
all done we convert it back to the old

00:40:27,880 --> 00:40:31,750
format we can compare them see if

00:40:29,710 --> 00:40:33,940
they're the same okay it's like you use

00:40:31,750 --> 00:40:35,589
Google Translate you convert you know

00:40:33,940 --> 00:40:37,480
say English to Bulgarian and then you

00:40:35,589 --> 00:40:38,890
convert Bulgarian back to English if

00:40:37,480 --> 00:40:40,329
what you get is sort of more or less the

00:40:38,890 --> 00:40:41,650
same as your head you can have some

00:40:40,329 --> 00:40:44,130
confidence that the Bulgarian is sort of

00:40:41,650 --> 00:40:46,140
right ok we can do the same thing and

00:40:44,130 --> 00:40:49,569
there's a lot of interesting properties

00:40:46,140 --> 00:40:51,430
and we have good security by design the

00:40:49,569 --> 00:40:54,220
modular ization the fact that each

00:40:51,430 --> 00:40:57,190
module is limited to the kernel calls it

00:40:54,220 --> 00:40:58,780
can do it's limited to who we can talk

00:40:57,190 --> 00:41:00,130
to it's lemonade which I hope where it

00:40:58,780 --> 00:41:02,380
can touch all its controlled by little

00:41:00,130 --> 00:41:04,180
bit maps and tables in the microkernel

00:41:02,380 --> 00:41:06,309
so you know there's a lot of modularity

00:41:04,180 --> 00:41:08,049
the second thing which we can do when

00:41:06,309 --> 00:41:10,569
the live update is there is there's a

00:41:08,049 --> 00:41:11,920
lot of exploits in operating systems or

00:41:10,569 --> 00:41:13,750
somebody's very carefully studied the

00:41:11,920 --> 00:41:16,569
layout of memory and knows if I

00:41:13,750 --> 00:41:18,640
overflowed this buffer by exactly 18

00:41:16,569 --> 00:41:20,170
bytes then I get to write this word will

00:41:18,640 --> 00:41:22,210
overwrite some return address when it

00:41:20,170 --> 00:41:23,920
returns you know then I can you know

00:41:22,210 --> 00:41:25,540
return to Lib C and all that kind of

00:41:23,920 --> 00:41:28,180
stuff okay that requires knowing the

00:41:25,540 --> 00:41:30,670
exact layout of the memory okay suppose

00:41:28,180 --> 00:41:32,230
we change that every five seconds which

00:41:30,670 --> 00:41:34,780
we can do it live update we just update

00:41:32,230 --> 00:41:36,970
to a new version of itself but compile

00:41:34,780 --> 00:41:39,130
differently because you know LLVM allows

00:41:36,970 --> 00:41:40,630
us to say throw in some random fields

00:41:39,130 --> 00:41:41,580
and instructs you know move the

00:41:40,630 --> 00:41:43,860
functions around

00:41:41,580 --> 00:41:45,480
do all kinds of randomization and every

00:41:43,860 --> 00:41:47,550
few seconds we load a new version of the

00:41:45,480 --> 00:41:49,800
operating system okay well those attacks

00:41:47,550 --> 00:41:51,750
that depend upon knowing the layout

00:41:49,800 --> 00:41:53,550
don't work when they're changing out

00:41:51,750 --> 00:41:55,350
Monday every couple of seconds so it

00:41:53,550 --> 00:41:57,780
gives you a very very strong defense

00:41:55,350 --> 00:41:59,490
against a certain class of attacks and

00:41:57,780 --> 00:42:02,970
that's we wrote a paper about it - close

00:41:59,490 --> 00:42:05,820
your - ago about that so you go out the

00:42:02,970 --> 00:42:07,890
MINIX three org and try it

00:42:05,820 --> 00:42:09,750
positioning of MINIX we want to show

00:42:07,890 --> 00:42:11,310
that multi server systems we don't

00:42:09,750 --> 00:42:13,020
really push the microkernel thing it's a

00:42:11,310 --> 00:42:18,840
multi server system because it's based

00:42:13,020 --> 00:42:21,780
upon a bunch of servers that we want to

00:42:18,840 --> 00:42:24,840
show that it's reliable we want to show

00:42:21,780 --> 00:42:27,030
that it's secure that it's practical

00:42:24,840 --> 00:42:29,130
that you know drivers born in user mode

00:42:27,030 --> 00:42:31,380
that we want to handle high reliability

00:42:29,130 --> 00:42:32,760
and fault tolerant applications maybe

00:42:31,380 --> 00:42:34,530
somebody'll make a single chap

00:42:32,760 --> 00:42:36,390
you know laptop for $50.00 for the third

00:42:34,530 --> 00:42:38,340
world you know small memory footprint

00:42:36,390 --> 00:42:41,430
embedded systems and so on we have a

00:42:38,340 --> 00:42:42,990
logo raccoon you know because it's you

00:42:41,430 --> 00:42:45,180
know totally so dope you know we're

00:42:42,990 --> 00:42:48,480
echoing well they're small they're cute

00:42:45,180 --> 00:42:52,320
they're very clever they're agile they

00:42:48,480 --> 00:42:53,580
eat bugs just important and at least in

00:42:52,320 --> 00:42:54,930
the North America they're more likely to

00:42:53,580 --> 00:42:57,810
visit your house in a penguin you know

00:42:54,930 --> 00:43:07,020
hey mom mom there's a penguin in our

00:42:57,810 --> 00:43:10,760
backyard so website is a mini three or

00:43:07,020 --> 00:43:12,990
gets a fairly simple website you know

00:43:10,760 --> 00:43:15,570
documentation it's in a wiki where he's

00:43:12,990 --> 00:43:18,060
got MINIX three dot org you can help you

00:43:15,570 --> 00:43:19,110
can help document the system that so if

00:43:18,060 --> 00:43:21,210
you don't you don't write code but

00:43:19,110 --> 00:43:22,410
you're good at understanding things new

00:43:21,210 --> 00:43:24,330
good at writing it should only help us

00:43:22,410 --> 00:43:28,200
document things better by writing into

00:43:24,330 --> 00:43:30,480
the wiki here's some of the traffic to

00:43:28,200 --> 00:43:33,270
MINIX 3 you know we've made a release of

00:43:30,480 --> 00:43:35,370
makes three point three last week in

00:43:33,270 --> 00:43:40,080
traffic shot up to a seventy five

00:43:35,370 --> 00:43:43,140
thousand hits in September and the

00:43:40,080 --> 00:43:44,580
download page had seventeen thousand

00:43:43,140 --> 00:43:46,590
visits of the page and from the log

00:43:44,580 --> 00:43:48,210
about fourteen thousand downloads so

00:43:46,590 --> 00:43:50,090
three thousand people went down but the

00:43:48,210 --> 00:43:52,680
rest of them actually downloaded them

00:43:50,090 --> 00:43:55,000
the total number of visits to the main

00:43:52,680 --> 00:43:56,350
page since 2004 when we keep

00:43:55,000 --> 00:43:58,960
we kind of keep you tracks about 2.9

00:43:56,350 --> 00:44:00,550
million so we're probably not in you

00:43:58,960 --> 00:44:02,320
know something on any BSD territory

00:44:00,550 --> 00:44:06,520
probably but yeah almost three million

00:44:02,320 --> 00:44:08,340
visits it's not zero either the total

00:44:06,520 --> 00:44:11,260
number of visits to the download page is

00:44:08,340 --> 00:44:14,230
1.1 million and the number of actual

00:44:11,260 --> 00:44:17,560
downloads since february 2007 is about

00:44:14,230 --> 00:44:19,390
600,000 so it's not 0 I mean it's not

00:44:17,560 --> 00:44:22,720
you know way up in the sky but there's a

00:44:19,390 --> 00:44:24,250
community out there there's a news group

00:44:22,720 --> 00:44:25,720
that's the main communication mechanism

00:44:24,250 --> 00:44:27,070
it was a using that news group you

00:44:25,720 --> 00:44:29,320
Google bought you isn't it now it's a

00:44:27,070 --> 00:44:31,120
Google News group so questions and

00:44:29,320 --> 00:44:33,190
requests and discussions complaints and

00:44:31,120 --> 00:44:35,830
everything go to the new go to the news

00:44:33,190 --> 00:44:37,260
group so the conclusion is I think

00:44:35,830 --> 00:44:40,030
current operations are kind of bloated

00:44:37,260 --> 00:44:43,180
you know and its intent to build the

00:44:40,030 --> 00:44:45,760
smaller more reliable secure operating

00:44:43,180 --> 00:44:47,770
system kernels very small about 13,000

00:44:45,760 --> 00:44:50,230
lines of code the operating system

00:44:47,770 --> 00:44:51,670
itself is a full tiny kernel plus all

00:44:50,230 --> 00:44:53,410
these you know drivers and servers

00:44:51,670 --> 00:44:55,930
running its protected user mode

00:44:53,410 --> 00:44:58,210
processes with very strong restrictions

00:44:55,930 --> 00:45:00,220
on what each one can do each drivers a

00:44:58,210 --> 00:45:01,870
separate process each component has you

00:45:00,220 --> 00:45:04,150
know limit amount of power of what it

00:45:01,870 --> 00:45:05,380
can pull off faulty drivers can be

00:45:04,150 --> 00:45:07,210
placed on the fly we're trying to be

00:45:05,380 --> 00:45:09,010
able to replace the stateful components

00:45:07,210 --> 00:45:11,680
on the fly but it's trickier some of the

00:45:09,010 --> 00:45:13,660
components like say the audio you know

00:45:11,680 --> 00:45:15,070
driver has state but it doesn't have a

00:45:13,660 --> 00:45:16,930
lot of state it's got like the volume

00:45:15,070 --> 00:45:19,180
level in the trouble level and there's a

00:45:16,930 --> 00:45:21,940
way for it to say there's a piece called

00:45:19,180 --> 00:45:23,680
the the data store an audio driver can

00:45:21,940 --> 00:45:25,690
never the volume levels change and go to

00:45:23,680 --> 00:45:28,060
the data store and say here store this

00:45:25,690 --> 00:45:29,530
number you know is 7 DB and if it

00:45:28,060 --> 00:45:31,300
crashes the new one comes back goes to

00:45:29,530 --> 00:45:33,700
the data store and says give me my state

00:45:31,300 --> 00:45:35,200
you know it doesn't work as well for the

00:45:33,700 --> 00:45:36,760
things that where the state changes

00:45:35,200 --> 00:45:38,950
rapidly like a file system but working

00:45:36,760 --> 00:45:40,840
on that - ok

00:45:38,950 --> 00:45:42,340
so live update as I said it's possible

00:45:40,840 --> 00:45:45,010
it's not on the current release you know

00:45:42,340 --> 00:45:46,150
stay tunes users the net bsd packages

00:45:45,010 --> 00:45:47,800
and everything

00:45:46,150 --> 00:45:50,290
one other thing we're trying to do a

00:45:47,800 --> 00:45:51,820
survey we you know we have like 14,000

00:45:50,290 --> 00:45:53,620
downloads this month we've got no idea

00:45:51,820 --> 00:45:55,750
who they are what they're doing or

00:45:53,620 --> 00:45:57,010
anything so if you give it a try you

00:45:55,750 --> 00:45:59,650
know there's a server on the main page

00:45:57,010 --> 00:46:01,510
there's a little this will work yeah

00:45:59,650 --> 00:46:03,460
over here it says you know please take

00:46:01,510 --> 00:46:05,050
our survey so if you download it after

00:46:03,460 --> 00:46:06,730
you've done please take the survey and

00:46:05,050 --> 00:46:07,870
you know tell us a little bit about what

00:46:06,730 --> 00:46:08,960
you're doing with it we kind of like to

00:46:07,870 --> 00:46:10,400
know

00:46:08,960 --> 00:46:11,600
we're trying to build the community and

00:46:10,400 --> 00:46:13,280
you know so we've had six hundred

00:46:11,600 --> 00:46:14,480
thousand downloads but you know who they

00:46:13,280 --> 00:46:16,670
are what they're doing or anything so

00:46:14,480 --> 00:46:18,770
we're trying to get a little wiser on

00:46:16,670 --> 00:46:20,990
that okay one last thing if you want to

00:46:18,770 --> 00:46:23,090
get a masters degree in systems we have

00:46:20,990 --> 00:46:24,800
a really cool systems master's degree

00:46:23,090 --> 00:46:27,140
that's almost theory free its complete

00:46:24,800 --> 00:46:29,390
theory theory free very practical and so

00:46:27,140 --> 00:46:31,760
on just google me find my home page go

00:46:29,390 --> 00:46:34,760
there's a movie on youtube link there

00:46:31,760 --> 00:46:37,160
about the the master's degree okay that

00:46:34,760 --> 00:46:54,350
was it and if you have any questions I

00:46:37,160 --> 00:46:56,660
can try to answer them so we at our

00:46:54,350 --> 00:47:00,440
company have some experience with l4

00:46:56,660 --> 00:47:04,610
microkernel and such projects like l4

00:47:00,440 --> 00:47:07,190
Linux which is Linux kernel which is

00:47:04,610 --> 00:47:09,500
adopted to run on top of l4 so like a

00:47:07,190 --> 00:47:12,610
user LAN process to understand correctly

00:47:09,500 --> 00:47:15,770
that in this case you don't have any

00:47:12,610 --> 00:47:19,960
netbsd kernel bits and instead of it

00:47:15,770 --> 00:47:22,730
your implement self for nut beastie API

00:47:19,960 --> 00:47:24,140
the thing about the all for Linux is if

00:47:22,730 --> 00:47:27,080
there's a bug in Linux

00:47:24,140 --> 00:47:27,650
Lennie's crashes the l4 kernel is still

00:47:27,080 --> 00:47:30,020
running

00:47:27,650 --> 00:47:31,700
you could reboot Linux from scratch the

00:47:30,020 --> 00:47:33,830
only thing is rebooting Linux from

00:47:31,700 --> 00:47:36,230
scratch on top of l4 is a little bit

00:47:33,830 --> 00:47:38,840
faster than rebooting Linux and the bare

00:47:36,230 --> 00:47:41,660
hardware but one bug in the audio driver

00:47:38,840 --> 00:47:43,520
in Linux on l4 brings down all of Linux

00:47:41,660 --> 00:47:45,410
same way it does on the bare metal all

00:47:43,520 --> 00:47:47,120
you get is a little bit faster reboot

00:47:45,410 --> 00:47:49,040
that's not true here so it's a

00:47:47,120 --> 00:47:50,450
completely different idea

00:47:49,040 --> 00:47:52,610
you know the idea there is that want to

00:47:50,450 --> 00:47:54,320
have Linux running as is in terms of

00:47:52,610 --> 00:47:56,150
fault tolerance it's no more fault

00:47:54,320 --> 00:47:57,680
tolerant than regular Linux is because

00:47:56,150 --> 00:47:59,750
one bug in Linux brings down all of

00:47:57,680 --> 00:48:00,650
Linux just that they can reboot it a

00:47:59,750 --> 00:48:03,820
little bit faster

00:48:00,650 --> 00:48:03,820
it was all forrestel there

00:48:11,329 --> 00:48:19,079
how do you deal with poisonous requests

00:48:14,099 --> 00:48:20,339
in terms of restarting services how do

00:48:19,079 --> 00:48:23,519
you deal with the situation of a

00:48:20,339 --> 00:48:27,119
poisonous or a poisonous of requests

00:48:23,519 --> 00:48:29,460
which kills which causes a service to

00:48:27,119 --> 00:48:32,609
kill itself if there's a request that

00:48:29,460 --> 00:48:35,220
comes in absolutely you know if it's a

00:48:32,609 --> 00:48:37,049
deterministic bug because the request

00:48:35,220 --> 00:48:40,259
contains something in it which causes

00:48:37,049 --> 00:48:41,940
the component to die then basically we

00:48:40,259 --> 00:48:44,130
can't handle it you know I just you know

00:48:41,940 --> 00:48:46,650
that's simply a fatal error that our

00:48:44,130 --> 00:48:48,119
experience has been that most of the I

00:48:46,650 --> 00:48:50,279
think probably everybody's experience is

00:48:48,119 --> 00:48:52,079
most of the errors are not absolute

00:48:50,279 --> 00:48:53,700
deterministic failures that'll always

00:48:52,079 --> 00:48:55,079
fail the same way but they typically are

00:48:53,700 --> 00:48:57,119
transient failures of under certain

00:48:55,079 --> 00:48:58,980
peculiar circumstances something happens

00:48:57,119 --> 00:49:00,210
and nobody counted on and if you run it

00:48:58,980 --> 00:49:01,559
again you don't get exactly those

00:49:00,210 --> 00:49:03,119
circumstances but if it's a

00:49:01,559 --> 00:49:04,589
deterministic thing if it doesn't you

00:49:03,119 --> 00:49:06,420
know but truly doesn't know how to carry

00:49:04,589 --> 00:49:08,069
out the read system call and you ask you

00:49:06,420 --> 00:49:10,589
to do a read again it's gonna fail the

00:49:08,069 --> 00:49:12,210
same way again so we can't handle

00:49:10,589 --> 00:49:14,369
deterministic failures but those are the

00:49:12,210 --> 00:49:16,130
ones that testing tends to find the hard

00:49:14,369 --> 00:49:18,839
ones are the ones where it's you know

00:49:16,130 --> 00:49:20,819
unlikely because it depends upon a bunch

00:49:18,839 --> 00:49:22,500
of coincidences and next time you're

00:49:20,819 --> 00:49:24,660
probably not going to hit it even though

00:49:22,500 --> 00:49:25,950
it's still there so we can't handle the

00:49:24,660 --> 00:49:30,240
deterministic Falls but they're

00:49:25,950 --> 00:49:32,940
relatively rare so you you make mention

00:49:30,240 --> 00:49:34,529
of the issue of performance and that

00:49:32,940 --> 00:49:36,900
you're not currently looking at that but

00:49:34,529 --> 00:49:38,849
is that something that's planted as part

00:49:36,900 --> 00:49:40,589
of MINIX 3 because that's the usual

00:49:38,849 --> 00:49:43,230
accusation against microkernel

00:49:40,589 --> 00:49:45,450
architecture it's a very small staff and

00:49:43,230 --> 00:49:47,009
group we simply haven't had the time and

00:49:45,450 --> 00:49:48,799
also being academics and want to publish

00:49:47,009 --> 00:49:50,970
papers and you know that kind of stuff

00:49:48,799 --> 00:49:53,220
you know we're brought me to work in

00:49:50,970 --> 00:49:54,750
Hell for and L for Linux particular has

00:49:53,220 --> 00:49:56,519
demonstrated that even with the

00:49:54,750 --> 00:49:57,990
microkernel you can get the performance

00:49:56,519 --> 00:49:59,960
hit down to about five to ten percent

00:49:57,990 --> 00:50:02,910
and so they've shown that it's possible

00:49:59,960 --> 00:50:05,430
okay we haven't put in the engineering

00:50:02,910 --> 00:50:07,079
effort to do it but if they did it

00:50:05,430 --> 00:50:08,940
presumably we could do it does it sound

00:50:07,079 --> 00:50:10,440
the same you know we have the same

00:50:08,940 --> 00:50:12,390
problem they have Noel's message passing

00:50:10,440 --> 00:50:14,460
and if one went to the effort to

00:50:12,390 --> 00:50:16,170
optimize it my guess is we could

00:50:14,460 --> 00:50:18,010
probably also get it down to and maybe

00:50:16,170 --> 00:50:20,290
20% or 30% I know with

00:50:18,010 --> 00:50:21,820
but if they did it in theory but we

00:50:20,290 --> 00:50:23,170
channels do it so we just haven't had

00:50:21,820 --> 00:50:25,480
the manpower it's only been you know for

00:50:23,170 --> 00:50:26,770
programmers and these other more

00:50:25,480 --> 00:50:28,869
interesting research things have taken

00:50:26,770 --> 00:50:31,180
priority but they've shown it can be

00:50:28,869 --> 00:50:41,740
done so there is a per I hit or we're

00:50:31,180 --> 00:50:43,720
talking tens of percent at most you

00:50:41,740 --> 00:50:47,050
mentioned you're using the MMU to

00:50:43,720 --> 00:50:48,670
protect the kernel from being tampered

00:50:47,050 --> 00:50:53,740
with by the usual iron processes

00:50:48,670 --> 00:50:57,089
including drivers are using an iommu to

00:50:53,740 --> 00:51:12,579
protect against DMA from the hardware

00:50:57,089 --> 00:51:15,220
sent a driver hello everyone so I have

00:51:12,579 --> 00:51:18,210
abused the iommu business we are aware

00:51:15,220 --> 00:51:21,190
of the the DMA problem of course but

00:51:18,210 --> 00:51:24,339
there's not a really neatly integrated I

00:51:21,190 --> 00:51:26,770
are um mu solution in mainline that's

00:51:24,339 --> 00:51:28,990
just something that we have experimented

00:51:26,770 --> 00:51:30,730
with with whether we started looking at

00:51:28,990 --> 00:51:33,400
it there's a it was very hard to get

00:51:30,730 --> 00:51:35,530
years ago when when we started looking

00:51:33,400 --> 00:51:37,150
at everyone was different there was no

00:51:35,530 --> 00:51:39,990
documentation we've got working on one

00:51:37,150 --> 00:51:43,750
driver and kind of abandoned for now

00:51:39,990 --> 00:51:46,329
getting that neatly integrated with

00:51:43,750 --> 00:51:49,540
MINIX but that would definitely be a

00:51:46,329 --> 00:51:50,770
good addition but so at this moment no

00:51:49,540 --> 00:51:54,510
there's no good protection against

00:51:50,770 --> 00:51:54,510
physical memory access by DMA

00:52:07,150 --> 00:52:10,690
no more questions

00:52:24,080 --> 00:52:27,510
Thanks

00:52:25,290 --> 00:52:29,760
since the the DMA question was brought

00:52:27,510 --> 00:52:34,020
up I'm also curious to know what the was

00:52:29,760 --> 00:52:37,160
the state of DRM I'm sorry of any

00:52:34,020 --> 00:52:40,800
graphics related buffering issues like

00:52:37,160 --> 00:52:44,580
it is there a short-term plan to bring

00:52:40,800 --> 00:52:47,760
up something like DRM from from Linux

00:52:44,580 --> 00:52:49,440
land since yes the the the direct

00:52:47,760 --> 00:52:51,600
rendering manager basically did the

00:52:49,440 --> 00:52:54,300
piece of the piece of software that is

00:52:51,600 --> 00:52:58,830
kernel and user site that takes control

00:52:54,300 --> 00:53:00,840
I mean take take basic frame buffer into

00:52:58,830 --> 00:53:06,060
a you know some process that

00:53:00,840 --> 00:53:08,940
authorization okay so so basically the

00:53:06,060 --> 00:53:12,030
kernel stages is frame buffer and and

00:53:08,940 --> 00:53:13,830
that's it there's no we haven't put any

00:53:12,030 --> 00:53:16,530
other effort into the graphical part of

00:53:13,830 --> 00:53:28,860
it okay that tons there's much question

00:53:16,530 --> 00:53:36,360
thank you any other question thank you

00:53:28,860 --> 00:53:43,619
[Applause]

00:53:36,360 --> 00:53:43,619

YouTube URL: https://www.youtube.com/watch?v=jMkR9VF2GNY


