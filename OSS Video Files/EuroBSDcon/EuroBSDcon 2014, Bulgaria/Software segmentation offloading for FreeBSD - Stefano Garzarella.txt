Title: Software segmentation offloading for FreeBSD - Stefano Garzarella
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

The use of large frames makes network communication much less demanding for the CPU. Yet, backward compatibility and slow links requires the use of 1500 byte or smaller frames.
Modern NICs with hardware TCP segmentation offloading (TSO) address this problem. However, a generic software version (GSO) provided by the OS has reason to exist, for use on paths with no suitable hardware, such as between virtual machines or with older or buggy NICs.
In this paper we present our work to add GSO to FreeBSD. Our preliminary implementation, depending on CPU speed, shows up to 90% speedup compared to segmentation done in the TCP stack, saturating a 10 Gbit link at 2 GHz with checksum offloading.

Speaker biography:

Stefano Garzarella is a Research Fellow in Luigi Rizzo’s research group at the Dipartimento di Ingegneria dell’Informazione of the University of Pisa, Italy. He received a Master’s Degree (summa cum laude) in Computer Engineering from the University of Pisa in February 2014.
He has been a FreeBSD developer since 2013. Now he is working on various kernel and user space projects, particularly in the virtualization and networking fields.
Captions: 
	00:00:08,400 --> 00:00:15,269
until the tcp/ip and eternal leaders in

00:00:13,240 --> 00:00:19,770
this way are

00:00:15,269 --> 00:00:21,180
the only only one and this provide this

00:00:19,770 --> 00:00:22,230
provides an advantage because the

00:00:21,180 --> 00:00:24,449
computational cost

00:00:22,230 --> 00:00:27,630
it's almost independent of the payload

00:00:24,449 --> 00:00:31,879
Lang but depends strongly of the number

00:00:27,630 --> 00:00:35,219
of crosses instead on the on the right

00:00:31,879 --> 00:00:37,910
we can see the behavior when the TSO is

00:00:35,219 --> 00:00:40,860
not present in this case the TCP layer

00:00:37,910 --> 00:00:45,870
segments the data and each packet must

00:00:40,860 --> 00:00:49,200
cross all level of the natural stack the

00:00:45,870 --> 00:00:51,690
TSO out the sander instead the error see

00:00:49,200 --> 00:00:55,890
receive side coalition or abdul-allah

00:00:51,690 --> 00:00:59,550
row at the receiver there are see a

00:00:55,890 --> 00:01:02,100
louse an ich to combine in r12 incoming

00:00:59,550 --> 00:01:05,009
TCP IP packets from the same connection

00:01:02,100 --> 00:01:08,070
into one large received segment before

00:01:05,009 --> 00:01:10,770
passing it on operating system it

00:01:08,070 --> 00:01:14,610
reduced CPU who is because the tcp/ip

00:01:10,770 --> 00:01:17,090
stack is executed only one for only once

00:01:14,610 --> 00:01:21,469
for a set of receiver bitternutt frames

00:01:17,090 --> 00:01:26,310
basically the RC is the dual of the TSO

00:01:21,469 --> 00:01:29,670
this diagram show on the left the RAC of

00:01:26,310 --> 00:01:33,179
our receive works there I see a low at

00:01:29,670 --> 00:01:36,359
the aggregation and then it's possible

00:01:33,179 --> 00:01:38,759
to the operating system in this way only

00:01:36,359 --> 00:01:43,380
the aggregate system will cross the

00:01:38,759 --> 00:01:44,969
natural stack okay why do we need a

00:01:43,380 --> 00:01:47,369
software implementation there are

00:01:44,969 --> 00:01:49,649
several reason for example if we have an

00:01:47,369 --> 00:01:52,249
old Nick that support only IP version 4

00:01:49,649 --> 00:01:55,380
the hardware upgrade is really difficult

00:01:52,249 --> 00:01:59,459
or if the car has a malfunction in the

00:01:55,380 --> 00:02:00,869
floating system it cannot be used or if

00:01:59,459 --> 00:02:02,759
we don't have the hardware in the

00:02:00,869 --> 00:02:05,219
communication for example between

00:02:02,759 --> 00:02:07,560
virtual machines we need a software

00:02:05,219 --> 00:02:11,340
mechanism to do a segmentation in all

00:02:07,560 --> 00:02:13,890
these cases the is it's useful to have a

00:02:11,340 --> 00:02:17,130
software solution to allows us to obtain

00:02:13,890 --> 00:02:19,410
the same benefit finally the software is

00:02:17,130 --> 00:02:24,440
easier to extend than our bro to support

00:02:19,410 --> 00:02:27,240
new protocol or to fix the bags ok since

00:02:24,440 --> 00:02:29,170
freebsd 7.1 we have a software

00:02:27,240 --> 00:02:32,950
implementation of RC called

00:02:29,170 --> 00:02:35,700
large receiver float this software

00:02:32,950 --> 00:02:38,709
mechanism that requires to change every

00:02:35,700 --> 00:02:40,870
each the bus driver allowed the obtain

00:02:38,709 --> 00:02:44,080
the same event advantage of the receiver

00:02:40,870 --> 00:02:45,820
on the left there is a racy hardware RC

00:02:44,080 --> 00:02:48,850
and on the light there is a software

00:02:45,820 --> 00:02:50,440
error in the device driver in the same

00:02:48,850 --> 00:02:52,950
interrupt context the packet from the

00:02:50,440 --> 00:02:56,590
same connection our aggregate in the one

00:02:52,950 --> 00:02:58,690
single in the one segment and then it's

00:02:56,590 --> 00:03:01,360
posted to the operating system to the

00:02:58,690 --> 00:03:04,209
nectar stack at this point the behavior

00:03:01,360 --> 00:03:07,900
is the same to the Rob that is only one

00:03:04,209 --> 00:03:10,090
big segment that cross the stack now I

00:03:07,900 --> 00:03:12,250
will introduce a software mechanism that

00:03:10,090 --> 00:03:15,610
we have developed for the sender side

00:03:12,250 --> 00:03:18,160
it's called gso generic segmentation of

00:03:15,610 --> 00:03:19,870
flowed basically is the software

00:03:18,160 --> 00:03:23,680
implementation of the TSO but it's

00:03:19,870 --> 00:03:27,220
important Allah TCP but also UDP on AP

00:03:23,680 --> 00:03:30,370
version 4 and version 6 the GSA is

00:03:27,220 --> 00:03:33,670
available for FreeBSD current unstable

00:03:30,370 --> 00:03:35,350
and nine stable to avoiding changing

00:03:33,670 --> 00:03:37,269
every device driver we have the

00:03:35,350 --> 00:03:39,610
segmentation just before the device

00:03:37,269 --> 00:03:43,769
driver we can see it in the next slide

00:03:39,610 --> 00:03:47,230
on the left there is a Geo source game

00:03:43,769 --> 00:03:50,769
diagram and on the right there is with

00:03:47,230 --> 00:03:53,829
without DSO support much of the

00:03:50,769 --> 00:03:56,769
advantage of the hardware TSO comes from

00:03:53,829 --> 00:04:00,070
crossing the natural stack only once the

00:03:56,769 --> 00:04:01,870
GSO that does the same by doing the

00:04:00,070 --> 00:04:04,480
segmentation in software as late as

00:04:01,870 --> 00:04:08,590
possible ideally this could be done

00:04:04,480 --> 00:04:11,310
within the the device driver but that

00:04:08,590 --> 00:04:13,989
would require modification all drivers a

00:04:11,310 --> 00:04:16,479
more convenient similar effective

00:04:13,989 --> 00:04:19,359
approach is to do the segmentation and

00:04:16,479 --> 00:04:26,050
just before the packet is passing to the

00:04:19,359 --> 00:04:30,370
driver this diagram shows an example of

00:04:26,050 --> 00:04:32,530
TCP data flow our modification to add

00:04:30,370 --> 00:04:34,990
the GSO support are referred to the

00:04:32,530 --> 00:04:38,650
network stack in particular we change a

00:04:34,990 --> 00:04:40,500
tcp output IP output a Trotwood and we

00:04:38,650 --> 00:04:42,240
added gso dispatch

00:04:40,500 --> 00:04:52,340
function to do the segmentation just

00:04:42,240 --> 00:04:55,170
before the driver TCP output sorry for

00:04:52,340 --> 00:04:59,070
Mississippi are two checks if gso is

00:04:55,170 --> 00:05:01,890
enabled there is some CTO to enable the

00:04:59,070 --> 00:05:05,310
GS or to change some parameters that we

00:05:01,890 --> 00:05:07,710
will discuss later and after that tracks

00:05:05,310 --> 00:05:14,100
if the packet length exceeds the EMA to

00:05:07,710 --> 00:05:17,430
in this case our set TCP outputs at GS o

00:05:14,100 --> 00:05:21,570
flag in amber pocket either fuel called

00:05:17,430 --> 00:05:25,680
she some see some flag we use it for bit

00:05:21,570 --> 00:05:28,650
in in this field both to indicate the

00:05:25,680 --> 00:05:32,010
gesture is required and to specify the

00:05:28,650 --> 00:05:33,840
type of segmentation in this way GS o

00:05:32,010 --> 00:05:36,290
dispatch will avoid to inspect the

00:05:33,840 --> 00:05:40,230
heater to understand the type of

00:05:36,290 --> 00:05:45,210
segmentation then the packet is positive

00:05:40,230 --> 00:05:48,570
EP IP output if GS o is enabled and

00:05:45,210 --> 00:05:51,660
required EP output avoid to calculate

00:05:48,570 --> 00:05:53,870
the checksum both TCP and IP because

00:05:51,660 --> 00:05:56,790
they will be calculated for

00:05:53,870 --> 00:06:02,880
after segmentation on each new pocket

00:05:56,790 --> 00:06:03,810
and it avoids to do IP fragmentation at

00:06:02,880 --> 00:06:06,870
last

00:06:03,810 --> 00:06:10,440
either output after building the the

00:06:06,870 --> 00:06:12,660
heater at the eternity either other if

00:06:10,440 --> 00:06:18,080
GS o is required called

00:06:12,660 --> 00:06:22,169
GS o dispatch instead of if transmitted

00:06:18,080 --> 00:06:27,840
in GS o dispatch using the information

00:06:22,169 --> 00:06:29,760
contained in the system flag field the

00:06:27,840 --> 00:06:31,910
appropriate function is invoked to

00:06:29,760 --> 00:06:38,880
perform the segmentation we use a simple

00:06:31,910 --> 00:06:41,970
array of function to do this in for

00:06:38,880 --> 00:06:46,560
example in the case of TCP on IP version

00:06:41,970 --> 00:06:50,099
4 the function is a GS o underscore IP

00:06:46,560 --> 00:06:52,100
for unscored tcp this function similar

00:06:50,099 --> 00:06:56,780
to the others for example to

00:06:52,100 --> 00:07:01,820
P or TCP on IP version 6 performed three

00:06:56,780 --> 00:07:05,840
main operation one called the M side

00:07:01,820 --> 00:07:09,820
function this function return m buff q

00:07:05,840 --> 00:07:13,970
that contains the new segment after that

00:07:09,820 --> 00:07:16,880
number to fix the TCP and IP either's in

00:07:13,970 --> 00:07:19,370
each new segment because then this

00:07:16,880 --> 00:07:23,540
either's are simply copied from original

00:07:19,370 --> 00:07:28,850
packet into a new segment and then some

00:07:23,540 --> 00:07:33,380
new segments to the device driver these

00:07:28,850 --> 00:07:38,180
are M sag function this is the m/sec

00:07:33,380 --> 00:07:42,500
function in from the original packet to

00:07:38,180 --> 00:07:44,870
an buffer in in them sec function there

00:07:42,500 --> 00:07:48,670
is some parameter the m0 is the original

00:07:44,870 --> 00:07:52,790
packet header LAN is the land the first

00:07:48,670 --> 00:07:56,660
byte in the m0 the tar copied in new

00:07:52,790 --> 00:08:00,770
segment in each new segment and MSS is

00:07:56,660 --> 00:08:02,990
the maximum segment size after the

00:08:00,770 --> 00:08:08,860
segmentation we need to fix the TCP IP

00:08:02,990 --> 00:08:08,860
either in this case TCP on IP version 4

00:08:09,010 --> 00:08:19,130
the red the red field 2 must be changed

00:08:13,700 --> 00:08:21,640
in more detail in for AP EP header total

00:08:19,130 --> 00:08:24,110
M will contain the new pocket site's

00:08:21,640 --> 00:08:28,040
identification will be increased and

00:08:24,110 --> 00:08:30,950
will be will recalculate the checksum of

00:08:28,040 --> 00:08:33,400
the of the IP header for the TCP header

00:08:30,950 --> 00:08:37,219
the sequence number will refer the data

00:08:33,400 --> 00:08:42,410
container in the in the segment some

00:08:37,219 --> 00:08:46,370
flag are only set in the first segment

00:08:42,410 --> 00:08:48,530
for example CBS CW a-- and other flat

00:08:46,370 --> 00:08:52,250
only in the last segment push and pin

00:08:48,530 --> 00:08:57,410
and we will recalculate the TCP check

00:08:52,250 --> 00:09:00,820
sum if the artwork is not capable for

00:08:57,410 --> 00:09:04,270
TCP on IP version 6 the

00:09:00,820 --> 00:09:08,140
changes in the TCP other is the same in

00:09:04,270 --> 00:09:11,200
the AP other there is only payload

00:09:08,140 --> 00:09:13,050
length to that contain the length of

00:09:11,200 --> 00:09:16,930
this segment

00:09:13,050 --> 00:09:19,330
as we say the GSO also support UDP

00:09:16,930 --> 00:09:22,750
traffic in this case we need to perform

00:09:19,330 --> 00:09:25,330
ap fragmentation but we delete this just

00:09:22,750 --> 00:09:31,210
before to call the device driver as we

00:09:25,330 --> 00:09:32,980
can see in the interview monolith on the

00:09:31,210 --> 00:09:35,950
right if Gio is not enabled the

00:09:32,980 --> 00:09:38,280
fermentation is done in AP level and

00:09:35,950 --> 00:09:41,770
each fragment must cross pattern

00:09:38,280 --> 00:09:46,960
Ethernet level that adds the same other

00:09:41,770 --> 00:09:50,290
to all problems okay the steps that are

00:09:46,960 --> 00:09:52,360
performing with the P 4 and IP

00:09:50,290 --> 00:09:56,500
fragmentation are the same that we've

00:09:52,360 --> 00:09:58,840
already described i'm sag fix the error

00:09:56,500 --> 00:10:02,050
and send the packet the only difference

00:09:58,840 --> 00:10:07,080
is the IP header changes because in this

00:10:02,050 --> 00:10:10,390
case we must do IP fragmentation and

00:10:07,080 --> 00:10:15,700
modify the upper part felt like fragment

00:10:10,390 --> 00:10:20,740
offset more field and we calculate the

00:10:15,700 --> 00:10:23,560
checksum for TP version 6 to do a big

00:10:20,740 --> 00:10:25,150
fragmentation IP fragmentation we need

00:10:23,560 --> 00:10:28,510
to add an additional header

00:10:25,150 --> 00:10:33,760
fragmentation error in in rad that

00:10:28,510 --> 00:10:38,170
contains the fragment information ok to

00:10:33,760 --> 00:10:43,420
manage the GSO parameter we add some C's

00:10:38,170 --> 00:10:48,220
CTL there are 260 TL to disable enable

00:10:43,420 --> 00:10:50,950
gesso or TCP or UDP communication for

00:10:48,220 --> 00:10:54,220
example nap that I naught dot TCP dot

00:10:50,950 --> 00:10:57,670
gesso and enable or disable the gesso on

00:10:54,220 --> 00:11:00,700
all TCP communication and there is other

00:10:57,670 --> 00:11:02,980
two for each interface to limit the GSO

00:11:00,700 --> 00:11:08,860
past and to disable enable

00:11:02,980 --> 00:11:12,430
GSO on individual interface our code is

00:11:08,860 --> 00:11:14,779
available in choose death to

00:11:12,430 --> 00:11:18,979
repositories the first

00:11:14,779 --> 00:11:21,739
contain their pages utilities and pickup

00:11:18,979 --> 00:11:24,399
Esad images and a brief description of

00:11:21,739 --> 00:11:27,399
gso and the second one contained the

00:11:24,399 --> 00:11:29,959
freebsd source code we just saw support

00:11:27,399 --> 00:11:33,229
to compile the cattle with gesso support

00:11:29,959 --> 00:11:39,949
you just need to option gesso in Colonel

00:11:33,229 --> 00:11:43,069
counting in in this slide we can see the

00:11:39,949 --> 00:11:45,829
changes to address or support in FreeBSD

00:11:43,069 --> 00:11:49,339
current we added to file gesso dot see

00:11:45,829 --> 00:11:52,339
it just so that agencies not and a

00:11:49,339 --> 00:11:55,009
little very small piece of code in in

00:11:52,339 --> 00:12:01,309
the network stack files like ap TCP and

00:11:55,009 --> 00:12:03,739
UDP okay at the end I show you the

00:12:01,309 --> 00:12:05,899
results that we have obtained in in the

00:12:03,739 --> 00:12:08,659
experiments this hour this is our

00:12:05,899 --> 00:12:10,909
testing environment we use it not path

00:12:08,659 --> 00:12:14,569
as a benchmark tool and the ten gigabit

00:12:10,909 --> 00:12:17,629
links between the machines to see the

00:12:14,569 --> 00:12:22,449
effect of GSO or TSO the receiver must

00:12:17,629 --> 00:12:26,539
have Hal ro software or Hardware enabled

00:12:22,449 --> 00:12:29,689
in in this slide we see the result with

00:12:26,539 --> 00:12:31,429
TCP IP for traffic on the or is run

00:12:29,689 --> 00:12:33,739
horizontal axis we have the CPU

00:12:31,429 --> 00:12:38,539
frequency on the vertical axis we have

00:12:33,739 --> 00:12:40,849
the throughput the red curve is obtained

00:12:38,539 --> 00:12:44,529
with the hardware TSO the blue curve is

00:12:40,849 --> 00:12:48,259
attainment with gso software and with

00:12:44,529 --> 00:12:50,449
the red curve is without any any

00:12:48,259 --> 00:12:52,849
segmentation of loading we perform an

00:12:50,449 --> 00:12:56,029
experiment by scaling the frequency of

00:12:52,849 --> 00:12:59,659
CPU because as you can see from the

00:12:56,029 --> 00:13:03,259
graph we like frequency the tang gigabit

00:12:59,659 --> 00:13:07,279
links becomes the bottleneck from the

00:13:03,259 --> 00:13:10,309
graph we can see at two gigahertz the

00:13:07,279 --> 00:13:16,009
GSO saturates the link and from the

00:13:10,309 --> 00:13:18,529
table at one gig and all the GSO is

00:13:16,009 --> 00:13:21,129
almost twice fast without

00:13:18,529 --> 00:13:21,129
offloading

00:13:22,720 --> 00:13:28,300
in this other slide we can see the

00:13:24,880 --> 00:13:31,960
result with TCP on IP version 6

00:13:28,300 --> 00:13:35,350
there is the same DSO on the red curve

00:13:31,960 --> 00:13:39,310
is TSO blue curve is gso and green curve

00:13:35,350 --> 00:13:43,930
is without segmentation also in this

00:13:39,310 --> 00:13:49,720
case GSO alo has to double throughput

00:13:43,930 --> 00:13:52,570
compared with without of floating with

00:13:49,720 --> 00:13:56,230
would be traffic we have a speed of

00:13:52,570 --> 00:13:58,240
about 20% this is because the GSO in in

00:13:56,230 --> 00:14:01,270
this case only prevents the crossing of

00:13:58,240 --> 00:14:05,050
heater output would you be out with an

00:14:01,270 --> 00:14:12,100
IP output or crosses only once both gso

00:14:05,050 --> 00:14:18,490
and both gesso is enabled or not for DP

00:14:12,100 --> 00:14:20,620
on AP version 6 is the same okay

00:14:18,490 --> 00:14:23,170
filtered works will try to down to do

00:14:20,620 --> 00:14:25,870
more performance measurement for example

00:14:23,170 --> 00:14:28,720
by using a multiple concurrent stream we

00:14:25,870 --> 00:14:31,150
try to optimize critical path and

00:14:28,720 --> 00:14:41,890
support you know a new protocol for

00:14:31,150 --> 00:14:44,310
example SCTP thank you do you have any

00:14:41,890 --> 00:14:44,310
question

00:14:54,770 --> 00:15:04,170
is it possible to make the GSO option

00:15:00,020 --> 00:15:09,990
enabling by default automatic I mean

00:15:04,170 --> 00:15:11,790
so if depending on whether segmentation

00:15:09,990 --> 00:15:18,420
of holding is supported by the hardware

00:15:11,790 --> 00:15:23,480
or not to make it the - to have it

00:15:18,420 --> 00:15:23,480
enabled automatically or not enabled

00:15:25,240 --> 00:15:33,300
[Music]

00:15:27,080 --> 00:15:35,870
used or if you disable that you saw for

00:15:33,300 --> 00:15:43,230
with the counting for example the

00:15:35,870 --> 00:15:46,940
enabled the GSO with the ccd up now I

00:15:43,230 --> 00:15:49,830
mean can you make it so that the system

00:15:46,940 --> 00:15:51,810
selects whether to enable gso or not

00:15:49,830 --> 00:15:56,190
depending on the hardware support of

00:15:51,810 --> 00:16:00,990
segmentation of folding if you enable

00:15:56,190 --> 00:16:04,050
DSO for example in this way also both in

00:16:00,990 --> 00:16:06,990
the NIC and in the step if then if the

00:16:04,050 --> 00:16:13,790
Nick didn't have the the TSO is

00:16:06,990 --> 00:16:13,790
automatically uh-huh okay okay thank you

00:16:14,930 --> 00:16:19,920
and have you tested this feature

00:16:17,100 --> 00:16:23,760
together with packet filters PF for

00:16:19,920 --> 00:16:26,630
something to see how networks network

00:16:23,760 --> 00:16:26,630
address translation

00:16:39,560 --> 00:16:56,540
hello question is how much extra load

00:16:45,680 --> 00:17:03,350
does does it add to the CPU the CPU is

00:16:56,540 --> 00:17:06,760
not very high but you said currently

00:17:03,350 --> 00:17:06,760
it's single-threaded

00:17:20,020 --> 00:17:27,470
hi I was just wondering why he is so so

00:17:24,290 --> 00:17:30,830
much faster than non offloading in lower

00:17:27,470 --> 00:17:33,500
frequencies than her like in 1.5

00:17:30,830 --> 00:17:40,640
gigahertz it was twice as fast button to

00:17:33,500 --> 00:17:46,160
get hurt it wasn't because the

00:17:40,640 --> 00:17:51,140
bottleneck in for example the bottleneck

00:17:46,160 --> 00:17:51,980
is there is the link is the link the

00:17:51,140 --> 00:18:01,310
link is saturated

00:17:51,980 --> 00:18:14,210
yeah okay thanks these tests

00:18:01,310 --> 00:18:16,870
what MTU was used on the network T any

00:18:14,210 --> 00:18:16,870
other questions

00:18:19,540 --> 00:18:24,400
let

00:18:20,750 --> 00:18:24,400
thank us be our speaker then

00:18:25,560 --> 00:18:31,980

YouTube URL: https://www.youtube.com/watch?v=lP-il89FgSY


