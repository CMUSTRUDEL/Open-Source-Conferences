Title: Subversion for FreeBSD developers - Stefan Sperling
Publication date: 2019-10-13
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Description:

FreeBSD switched from CVS to Apache Subversion in 2008. It is the only
major BSD operating system using Subversion for version control and one
of the largest open source projects using it. This tutorial provides a
solid introduction to Subversion geared towards FreeBSD developers.We’ll start with a quick review of Subversion’s design from its conception
in the year 2000 and all the features and quirks added during its still
on-going evolution.We’ll talk about Subversion’s repository and working copy, merging and
merge-tracking, how Subversion’s tree conflict detection feature can
help but also get in the way, the why and how of pitfalls associated
with renames, and more.FreeBSD’s workflow built around Subversion will be discussed with
attendees and reviewed for problems and possible improvements.
Attendees are welcome to present any issues they’ve run into with
Subversion during FreeBSD development.

Speaker biography:

Stefan Sperling works as Subversion developer and consultant at elego
Software Solutions GmbH based in Berlin. He has been contributing to
the Subversion project since 2007. He’s been involved in OpenBSD
development since 2008 even though code he produces during hackathons
is the result of sleep deprivation more than anything else.
At elego he has colleagues working on git and they all get along very well.
Captions: 
	00:00:04,069 --> 00:00:09,020
this is better if I turn it on

00:00:12,480 --> 00:00:15,860
okay so

00:00:19,590 --> 00:00:25,580
but I probably do is I start with an

00:00:23,310 --> 00:00:26,689
introduction that we usually do in

00:00:25,580 --> 00:00:29,489
[Music]

00:00:26,689 --> 00:00:36,030
workshops at my company that we run

00:00:29,489 --> 00:00:37,230
subversion workshops for people and it

00:00:36,030 --> 00:00:38,940
might be boring for people who are

00:00:37,230 --> 00:00:41,550
already know subversion to some extent

00:00:38,940 --> 00:00:46,470
but it's also useful to review basics

00:00:41,550 --> 00:00:49,379
and sort of get caught up with with

00:00:46,470 --> 00:00:51,150
terms that we use in the subversion

00:00:49,379 --> 00:00:53,640
project to describe things that happen

00:00:51,150 --> 00:00:56,369
in subversion because often people don't

00:00:53,640 --> 00:00:59,250
really aren't really aware of all the

00:00:56,369 --> 00:01:01,619
terminology and what it means so usually

00:00:59,250 --> 00:01:02,760
we try to get people to do or get

00:01:01,619 --> 00:01:07,890
everything they know and start from

00:01:02,760 --> 00:01:09,659
scratch but if you if you use the

00:01:07,890 --> 00:01:12,360
subversion for a couple of years and it

00:01:09,659 --> 00:01:16,229
might be a bit boring at the start but I

00:01:12,360 --> 00:01:19,110
hope that we can quickly get to stuff

00:01:16,229 --> 00:01:21,420
that is a bit harder to to run across

00:01:19,110 --> 00:01:23,220
when you're just using subversion and in

00:01:21,420 --> 00:01:31,979
a basic setting and you're not really

00:01:23,220 --> 00:01:33,829
doing many complicated things with it so

00:01:31,979 --> 00:01:37,490
now we're complete right we can actually

00:01:33,829 --> 00:01:37,490
just start the workshop

00:02:56,720 --> 00:03:05,660
I don't think I know the complete list I

00:02:58,910 --> 00:03:07,310
know the list I know some like six I saw

00:03:05,660 --> 00:03:08,660
like six addresses on a mirror was EC

00:03:07,310 --> 00:03:10,840
done that otherwise I didn't see

00:03:08,660 --> 00:03:10,840
anything

00:03:18,360 --> 00:03:25,419
yeah okay so

00:03:22,340 --> 00:03:25,419
[Music]

00:03:44,180 --> 00:03:48,349
maybe you can already tell me a bit

00:03:45,950 --> 00:03:52,430
about what you use subversion for what

00:03:48,349 --> 00:04:06,110
we already like is what are you using it

00:03:52,430 --> 00:04:08,269
for okay what kind of source code okay

00:04:06,110 --> 00:04:11,769
and are there like many isolated

00:04:08,269 --> 00:04:11,769
projects or do you have a big project

00:04:17,620 --> 00:04:31,430
okay our branch so they all share okay

00:04:23,800 --> 00:04:36,410
and and so you have one repository and

00:04:31,430 --> 00:04:38,780
each project has a directory in it and

00:04:36,410 --> 00:04:48,260
you have so they all share like a single

00:04:38,780 --> 00:04:49,490
revision number space okay so yeah

00:04:48,260 --> 00:04:54,610
that's when you waste a Saturday yeah

00:04:49,490 --> 00:04:57,440
and and are there do you have like

00:04:54,610 --> 00:04:59,650
release branches or feature branches in

00:04:57,440 --> 00:04:59,650
there

00:05:05,840 --> 00:05:22,920
so tag releases right so you switch from

00:05:16,860 --> 00:05:30,990
CVS when okay so those probably

00:05:22,920 --> 00:05:32,820
subversion one one for anyone else wants

00:05:30,990 --> 00:05:34,800
to share what they what they do just for

00:05:32,820 --> 00:05:37,280
me to get an impression of what kind of

00:05:34,800 --> 00:05:37,280
things you do

00:05:44,910 --> 00:05:49,770
and what what kind of products are you

00:05:47,199 --> 00:05:49,770
building there

00:06:12,530 --> 00:06:24,860
okay so you have copies of I save copies

00:06:18,290 --> 00:06:27,850
of the of the freebsd source tree so you

00:06:24,860 --> 00:06:30,350
check out freebsd from previous tspn and

00:06:27,850 --> 00:06:31,550
then you have your own code like kernel

00:06:30,350 --> 00:06:34,810
modules you can compile them externally

00:06:31,550 --> 00:06:38,930
from the source tree right to build it

00:06:34,810 --> 00:06:41,180
okay and you don't actually take FreeBSD

00:06:38,930 --> 00:06:47,390
code and change it and keep managing

00:06:41,180 --> 00:06:49,450
patches to it okay what do you use it

00:06:47,390 --> 00:06:49,450
for

00:06:50,800 --> 00:06:53,800
okay

00:06:59,070 --> 00:07:04,940
Oh No

00:07:02,430 --> 00:07:04,940
okay

00:07:06,580 --> 00:07:09,240
you know

00:07:18,169 --> 00:07:23,749
yeah you'll have a very different

00:07:19,669 --> 00:07:25,969
branching merging experience and a lot

00:07:23,749 --> 00:07:28,340
of things in good work sort of more

00:07:25,969 --> 00:07:31,840
automatically especially if you have

00:07:28,340 --> 00:07:33,830
lots of renames in different branches

00:07:31,840 --> 00:07:38,469
submerged encountering to do that right

00:07:33,830 --> 00:07:41,949
now when we get to that and you can ask

00:07:38,469 --> 00:07:41,949
okay okay

00:08:28,210 --> 00:08:33,880
so when you run when you're on FreeBSD

00:08:30,440 --> 00:08:37,640
you're honest you know update yeah yeah

00:08:33,880 --> 00:08:39,830
okay do you check out your slash EDC

00:08:37,640 --> 00:08:42,620
configurations from this the end or do

00:08:39,830 --> 00:08:45,280
you copy things somewhere and then take

00:08:42,620 --> 00:08:45,280
it to a working copy

00:08:52,900 --> 00:08:58,760
okay so you basically you stand there

00:08:57,350 --> 00:09:01,070
and you keep track of changes that

00:08:58,760 --> 00:09:02,800
people make but you don't force the et

00:09:01,070 --> 00:09:10,250
Cie system to be under version control

00:09:02,800 --> 00:09:11,390
it basically takes snapshots of do you

00:09:10,250 --> 00:09:13,820
use subversion for anything we're

00:09:11,390 --> 00:09:20,390
currently doing who use the separator

00:09:13,820 --> 00:09:23,690
for what around okay do you also commit

00:09:20,390 --> 00:09:27,920
to the sheet no so we have no source

00:09:23,690 --> 00:09:29,720
computers which is no problem it's just

00:09:27,920 --> 00:09:31,160
that we gotta do exercises later that we

00:09:29,720 --> 00:09:39,530
design for those computers so don't be

00:09:31,160 --> 00:09:42,080
don't be afraid okay so then what I'll

00:09:39,530 --> 00:09:45,380
do is though I also have also brought in

00:09:42,080 --> 00:09:48,110
some introductory training materials

00:09:45,380 --> 00:09:51,380
which we usually use in a course that

00:09:48,110 --> 00:09:53,690
lasts for a day so you probably won't be

00:09:51,380 --> 00:09:56,810
able to do all of it but those who don't

00:09:53,690 --> 00:09:59,000
know separation yet like very well could

00:09:56,810 --> 00:10:01,130
probably do those instead and then it

00:09:59,000 --> 00:10:03,470
exercises but they they run you through

00:10:01,130 --> 00:10:05,690
all the basic work steps that you would

00:10:03,470 --> 00:10:10,520
do and and and explain some quirks

00:10:05,690 --> 00:10:12,820
along the way and and eventually after

00:10:10,520 --> 00:10:15,350
doing this you're able to actually think

00:10:12,820 --> 00:10:18,130
about problems in in terms of how

00:10:15,350 --> 00:10:18,130
surprising works

00:10:20,480 --> 00:10:29,700
okay then I guess we'll start with a

00:10:23,720 --> 00:10:32,820
with an introduction that is pretty much

00:10:29,700 --> 00:10:36,000
the same introduction to any workshop I

00:10:32,820 --> 00:10:41,060
we do about SEM and I would like to know

00:10:36,000 --> 00:10:41,060
who knows how who used CVS in the past

00:10:42,020 --> 00:10:48,860
so you underst you have a fairly good

00:10:45,510 --> 00:10:51,350
understanding of of CVS was modeled and

00:10:48,860 --> 00:10:53,910
when you look at subversion the first

00:10:51,350 --> 00:10:55,680
when you look at it from from a design

00:10:53,910 --> 00:10:58,980
perspective how it was made what it was

00:10:55,680 --> 00:11:01,110
I was built it really helps to

00:10:58,980 --> 00:11:04,110
understand what the problem CVS had

00:11:01,110 --> 00:11:07,920
because subversion exists to replace CVS

00:11:04,110 --> 00:11:12,780
it was the was conceived to be a project

00:11:07,920 --> 00:11:14,250
to replace CVS and that means that the

00:11:12,780 --> 00:11:15,900
whole design is basically based on

00:11:14,250 --> 00:11:17,970
quirks of CVS that people didn't like

00:11:15,900 --> 00:11:20,520
it's not like people went out to build a

00:11:17,970 --> 00:11:22,320
perfect motor control system that could

00:11:20,520 --> 00:11:25,080
do anything under the sound what they

00:11:22,320 --> 00:11:27,180
did was they look at CVS use cases and

00:11:25,080 --> 00:11:29,490
figured out which parts didn't really

00:11:27,180 --> 00:11:31,140
work well enough for daily use or where

00:11:29,490 --> 00:11:34,050
people have problems with CVS in general

00:11:31,140 --> 00:11:37,410
and then they fixed those with the new

00:11:34,050 --> 00:11:39,420
design and wrote an implementation of it

00:11:37,410 --> 00:11:41,760
basically and this implementation has

00:11:39,420 --> 00:11:43,800
been growing and people have been using

00:11:41,760 --> 00:11:45,060
it exceedingly for much more complex

00:11:43,800 --> 00:11:47,580
stuff than people would have done with

00:11:45,060 --> 00:11:50,450
CVS in the first place so right now the

00:11:47,580 --> 00:11:55,380
subversion project has the problem that

00:11:50,450 --> 00:11:59,070
we have to integrate a lot more features

00:11:55,380 --> 00:12:01,740
that were not there in CVS into a design

00:11:59,070 --> 00:12:05,610
that's based around basically to see the

00:12:01,740 --> 00:12:07,350
s model of working but which people have

00:12:05,610 --> 00:12:09,690
been starting to use and totally

00:12:07,350 --> 00:12:13,670
unexpected ways or different ways than

00:12:09,690 --> 00:12:16,920
the system was originally intended for

00:12:13,670 --> 00:12:18,420
this is this is why so much shift has

00:12:16,920 --> 00:12:19,710
been happening from subversion to other

00:12:18,420 --> 00:12:22,170
projects in the open source world

00:12:19,710 --> 00:12:23,970
because there are use cases that the

00:12:22,170 --> 00:12:28,389
distributed systems cover a lot better

00:12:23,970 --> 00:12:36,610
than subversion does because of this so

00:12:28,389 --> 00:12:38,769
in CVS you had problems like where right

00:12:36,610 --> 00:12:41,290
so you know that each each file is

00:12:38,769 --> 00:12:43,629
represented with a comma V file and the

00:12:41,290 --> 00:12:44,920
repository so if I have a full file I

00:12:43,629 --> 00:12:47,379
have a fukken movie file in the

00:12:44,920 --> 00:12:51,610
repository and every version of that

00:12:47,379 --> 00:12:53,980
file is numbered on 1 1 2 and all of

00:12:51,610 --> 00:12:57,480
them refer to the comma V file in the

00:12:53,980 --> 00:13:00,850
repository right and I could have

00:12:57,480 --> 00:13:08,170
multiple files instead of just one so I

00:13:00,850 --> 00:13:13,569
have a bar file which also has say three

00:13:08,170 --> 00:13:16,360
versions and all of these are also

00:13:13,569 --> 00:13:20,529
reflected in the file of barca movie

00:13:16,360 --> 00:13:22,809
so one of the one of the most basic

00:13:20,529 --> 00:13:26,139
design issues of CVS is that if you want

00:13:22,809 --> 00:13:29,920
to label your software state like a

00:13:26,139 --> 00:13:36,669
product state you have to say ok this is

00:13:29,920 --> 00:13:40,389
our say release 1 or release 1 0 you

00:13:36,669 --> 00:13:44,410
have to for each file say in this food

00:13:40,389 --> 00:13:47,319
we use version 1 or 2 and Bobby use or

00:13:44,410 --> 00:13:52,360
whatever for this state so the operation

00:13:47,319 --> 00:13:53,889
to to set the tag and and read the tag

00:13:52,360 --> 00:13:56,199
it's taking forever because you have to

00:13:53,889 --> 00:13:58,299
check every comma V file open it see if

00:13:56,199 --> 00:14:00,999
the tags inside there which version

00:13:58,299 --> 00:14:03,100
would apply to this tag and use it so we

00:14:00,999 --> 00:14:05,230
had people who migrated off CVS to

00:14:03,100 --> 00:14:08,499
subversion who said we can now finally

00:14:05,230 --> 00:14:10,059
label on Fridays because Fridays used to

00:14:08,499 --> 00:14:15,160
be blocked for commits because people

00:14:10,059 --> 00:14:17,589
were labeling in the repository and one

00:14:15,160 --> 00:14:19,209
particular design point in SVN is that

00:14:17,589 --> 00:14:20,980
branching is very fast the tagging is

00:14:19,209 --> 00:14:23,379
very fast it was supposed to be a

00:14:20,980 --> 00:14:27,160
hummock operation that completes within

00:14:23,379 --> 00:14:30,929
a couple of milliseconds another thing

00:14:27,160 --> 00:14:33,790
is that if you rename a file in CVS

00:14:30,929 --> 00:14:36,100
using the standard user interface not

00:14:33,790 --> 00:14:40,149
doing like repo copy hacks or whatever

00:14:36,100 --> 00:14:40,980
you end up with a deleted like dead

00:14:40,149 --> 00:14:43,820
version of

00:14:40,980 --> 00:14:50,339
Saifu is dead and then there is another

00:14:43,820 --> 00:14:54,329
fool - and you create also a new food -

00:14:50,339 --> 00:14:55,949
comma V file in the repository and these

00:14:54,329 --> 00:14:57,480
two have no historic link or anything

00:14:55,949 --> 00:14:58,949
unless you put something in a lot

00:14:57,480 --> 00:15:00,329
message here that says this file is

00:14:58,949 --> 00:15:02,459
deleted and moved over there you don't

00:15:00,329 --> 00:15:07,170
know what happened the data model

00:15:02,459 --> 00:15:09,870
doesn't tell you and this was another

00:15:07,170 --> 00:15:11,690
thing that people looked at in SEN when

00:15:09,870 --> 00:15:16,500
they designed it and they found a way to

00:15:11,690 --> 00:15:18,089
to fix that problem yeah I won't go into

00:15:16,500 --> 00:15:21,570
too much detail here because you all

00:15:18,089 --> 00:15:26,389
know the stuff you know why why CVS was

00:15:21,570 --> 00:15:31,170
eventually supplanted by other systems

00:15:26,389 --> 00:15:32,730
so at the end I think it was a

00:15:31,170 --> 00:15:34,260
believable stream blondie who came up

00:15:32,730 --> 00:15:36,899
with the original design of the

00:15:34,260 --> 00:15:39,779
repository which represents a tree of

00:15:36,899 --> 00:15:42,810
snapshots and all the snapshots are

00:15:39,779 --> 00:15:44,670
numbered and you have a couple of

00:15:42,810 --> 00:15:46,980
operations you can do on a tree

00:15:44,670 --> 00:15:49,050
so the first revision or we say revision

00:15:46,980 --> 00:15:53,279
for each each version of the tree that

00:15:49,050 --> 00:15:56,870
we create first is Mt and then you could

00:15:53,279 --> 00:16:03,779
say add of file in the directory and

00:15:56,870 --> 00:16:09,449
maybe you could create another file you

00:16:03,779 --> 00:16:12,930
could have a directory and change one of

00:16:09,449 --> 00:16:18,510
the files say change a line here or

00:16:12,930 --> 00:16:24,029
something and you can of course also

00:16:18,510 --> 00:16:27,889
remove things so you could remove the

00:16:24,029 --> 00:16:27,889
file you just edited for example

00:16:29,570 --> 00:16:43,490
and you could read something there with

00:16:37,880 --> 00:16:46,399
the same name but different content

00:16:43,490 --> 00:16:50,180
so let's is it this is big enough for

00:16:46,399 --> 00:16:52,970
you to see okay so let's label these so

00:16:50,180 --> 00:16:54,940
the directories get big letters it's

00:16:52,970 --> 00:17:06,319
called any of the files are again called

00:16:54,940 --> 00:17:08,329
foo and bar so the system does the

00:17:06,319 --> 00:17:11,000
snapshotting stuff because people wanted

00:17:08,329 --> 00:17:12,709
atomic comments they didn't want the

00:17:11,000 --> 00:17:15,260
problem of having a connection bright

00:17:12,709 --> 00:17:17,959
within a commit when they when they

00:17:15,260 --> 00:17:19,910
change 30 files and they they only

00:17:17,959 --> 00:17:21,260
change end up changing 50 15 of them in

00:17:19,910 --> 00:17:24,199
the repository because the network

00:17:21,260 --> 00:17:25,520
connection broke halfway and so any

00:17:24,199 --> 00:17:27,770
update to this tree is fully

00:17:25,520 --> 00:17:30,410
transactional the client gives the

00:17:27,770 --> 00:17:34,340
server information upfront about what it

00:17:30,410 --> 00:17:36,230
wants to do and then the server checks

00:17:34,340 --> 00:17:37,340
once the client says I'm done with

00:17:36,230 --> 00:17:39,740
filling in information in the

00:17:37,340 --> 00:17:41,929
transaction the server goes and checks

00:17:39,740 --> 00:17:43,970
to see if this can still be folded into

00:17:41,929 --> 00:17:45,590
the head revision of the repository and

00:17:43,970 --> 00:17:47,630
creates a new revision if this is the

00:17:45,590 --> 00:17:53,570
case so you either commit everything or

00:17:47,630 --> 00:17:55,400
nothing at all and that's how that's

00:17:53,570 --> 00:17:59,090
that's how they make a snapshot model

00:17:55,400 --> 00:18:02,809
and because everything is you still use

00:17:59,090 --> 00:18:04,340
path to address everything because you

00:18:02,809 --> 00:18:06,230
also have like it's modeled like a file

00:18:04,340 --> 00:18:10,040
system isn't like the file system you'd

00:18:06,230 --> 00:18:12,919
have on disk and there are some some

00:18:10,040 --> 00:18:17,000
issues with identifying or pointing at

00:18:12,919 --> 00:18:19,130
objects so if I go and say please and

00:18:17,000 --> 00:18:22,070
get me the file a food from the

00:18:19,130 --> 00:18:25,010
repository subversion would usually give

00:18:22,070 --> 00:18:26,630
you this but I might remember that there

00:18:25,010 --> 00:18:29,000
was a red line at the top of the file

00:18:26,630 --> 00:18:30,320
and I don't I don't find it so I know

00:18:29,000 --> 00:18:34,880
that there must have been something else

00:18:30,320 --> 00:18:37,880
and the reason for this is that you have

00:18:34,880 --> 00:18:40,930
to tell the system which revision we

00:18:37,880 --> 00:18:44,560
want to look for the path in right

00:18:40,930 --> 00:18:50,280
and usually on the command line you

00:18:44,560 --> 00:18:53,470
write this as say give me a fool

00:18:50,280 --> 00:18:57,520
the default would be in the head

00:18:53,470 --> 00:19:00,460
revision but you can also specify any

00:18:57,520 --> 00:19:02,560
other revision you saw you so this app

00:19:00,460 --> 00:19:04,240
notation this is called the peg revision

00:19:02,560 --> 00:19:06,760
you know you'd like to take a peg and

00:19:04,240 --> 00:19:08,830
hold a particular revision and then look

00:19:06,760 --> 00:19:11,370
for the path in there so if we have a

00:19:08,830 --> 00:19:14,260
few or three we actually get this one

00:19:11,370 --> 00:19:18,370
because it looks in religiously for the

00:19:14,260 --> 00:19:20,230
path name and this is normally very

00:19:18,370 --> 00:19:23,080
transparent to the user so usually you

00:19:20,230 --> 00:19:25,360
don't really see that in the interface a

00:19:23,080 --> 00:19:26,830
lot sometimes when people do crazy tips

00:19:25,360 --> 00:19:29,350
or murders they will have to use these

00:19:26,830 --> 00:19:32,050
ad plus revision numbers but generally

00:19:29,350 --> 00:19:33,820
people do sort of simple use cases they

00:19:32,050 --> 00:19:36,450
don't need that so they usually always

00:19:33,820 --> 00:19:38,530
default to either at hat or some other

00:19:36,450 --> 00:19:44,470
reasonable default that submersion

00:19:38,530 --> 00:19:47,559
chooses for them okay so

00:19:44,470 --> 00:19:47,559
[Music]

00:19:49,170 --> 00:20:00,270
so we had modified the operation we had

00:19:53,930 --> 00:20:05,070
add delete and there's another one which

00:20:00,270 --> 00:20:06,870
is a copy and this is interesting in the

00:20:05,070 --> 00:20:15,630
sense that it solved the history

00:20:06,870 --> 00:20:21,240
traversal issue that CBS had so if we if

00:20:15,630 --> 00:20:23,630
we copy something like say directory and

00:20:21,240 --> 00:20:23,630
you copy

00:20:27,540 --> 00:20:43,680
the copy bar to bar to what you get is

00:20:40,880 --> 00:20:45,510
it looks sort of like an ad because the

00:20:43,680 --> 00:20:47,760
new child is added to the directory here

00:20:45,510 --> 00:20:54,600
but you also get what's called a copy

00:20:47,760 --> 00:20:56,190
from pointer so this points at something

00:20:54,600 --> 00:20:59,430
in an older revision which is at which

00:20:56,190 --> 00:21:01,980
it is based on and how exactly do we

00:20:59,430 --> 00:21:05,670
create a pointer like that in this model

00:21:01,980 --> 00:21:07,350
well we know that there is a unique one

00:21:05,670 --> 00:21:09,870
way of uniquely addressing objects which

00:21:07,350 --> 00:21:11,730
is this so the copy from information

00:21:09,870 --> 00:21:16,260
contained is a path at a particular

00:21:11,730 --> 00:21:19,500
revision it says this would be the copy

00:21:16,260 --> 00:21:22,260
from would say bar from five or

00:21:19,500 --> 00:21:24,510
something like that and you can also

00:21:22,260 --> 00:21:26,250
copy from any other older revision you

00:21:24,510 --> 00:21:31,530
can copy from anywhere in history to the

00:21:26,250 --> 00:21:34,080
to the hetero region subversion does not

00:21:31,530 --> 00:21:38,490
have a rename operation at this level

00:21:34,080 --> 00:21:40,890
and in this model so at least currently

00:21:38,490 --> 00:21:42,810
it doesn't and solving this has been an

00:21:40,890 --> 00:21:44,370
ongoing problem for several years so I'm

00:21:42,810 --> 00:21:49,440
starting to get a bit pessimistic about

00:21:44,370 --> 00:21:57,750
ever fixing it model three names as a

00:21:49,440 --> 00:22:01,410
delete and a copy and so you would see

00:21:57,750 --> 00:22:03,800
something like if we say rename this

00:22:01,410 --> 00:22:03,800
file

00:22:05,179 --> 00:22:17,929
- food - we would just or we would see

00:22:07,879 --> 00:22:25,039
the spy disappear and so the bar - and

00:22:17,929 --> 00:22:27,529
then we'd have our renamed foo which

00:22:25,039 --> 00:22:28,879
might have the same contents I'll do

00:22:27,529 --> 00:22:31,460
that in this case but it's not required

00:22:28,879 --> 00:22:35,749
to have the same because it's it's a

00:22:31,460 --> 00:22:38,509
copy which can also be modified in the

00:22:35,749 --> 00:22:45,289
same region as it's being copied so this

00:22:38,509 --> 00:22:50,239
goes back here and it says through from

00:22:45,289 --> 00:22:51,889
six it's all when you when they see a

00:22:50,239 --> 00:22:53,539
commit that doesn't rename what you will

00:22:51,889 --> 00:23:00,129
see in the in the log history is a

00:22:53,539 --> 00:23:06,339
delete of a foo and an addition of a

00:23:00,129 --> 00:23:14,690
food - and it says something like from a

00:23:06,339 --> 00:23:17,029
through revision six and in at the

00:23:14,690 --> 00:23:20,359
server side right now there's nothing

00:23:17,029 --> 00:23:22,399
that connects these two pieces of

00:23:20,359 --> 00:23:24,109
information or these two operations so

00:23:22,399 --> 00:23:27,469
when the client doesn't update or merge

00:23:24,109 --> 00:23:29,809
these will happen independently and the

00:23:27,469 --> 00:23:31,190
server will to say delete this and later

00:23:29,809 --> 00:23:32,649
it might say copy this or they could

00:23:31,190 --> 00:23:36,019
happen in the other the other way around

00:23:32,649 --> 00:23:38,389
and this makes it very hard to deal with

00:23:36,019 --> 00:23:42,979
some rearrangements people making the

00:23:38,389 --> 00:23:45,259
tree automatically we can we can find we

00:23:42,979 --> 00:23:46,609
can spot places where this is a where we

00:23:45,259 --> 00:23:49,519
should be there could be a problem but

00:23:46,609 --> 00:23:52,489
often we flag cases as problems which

00:23:49,519 --> 00:23:53,719
are not problems and this is annoying

00:23:52,489 --> 00:23:55,279
people who are doing a lot of

00:23:53,719 --> 00:23:58,059
reshuffling of their trees

00:23:55,279 --> 00:23:58,059
did you have a christening

00:24:01,799 --> 00:24:10,529
you can you can't ever change anything

00:24:05,110 --> 00:24:14,139
based on an out-of-date revision ever so

00:24:10,529 --> 00:24:20,200
the way this works is that if you need

00:24:14,139 --> 00:24:21,669
to commit can just look at what the

00:24:20,200 --> 00:24:24,039
working copy looks like to put all this

00:24:21,669 --> 00:24:27,850
all this stuff in here in a small box on

00:24:24,039 --> 00:24:29,769
the top so you have your tree in here

00:24:27,850 --> 00:24:31,840
and now you have people actually making

00:24:29,769 --> 00:24:33,669
changes and for that they will need to

00:24:31,840 --> 00:24:36,490
get working copies and working copies

00:24:33,669 --> 00:24:41,769
are created with the check out operation

00:24:36,490 --> 00:24:43,299
and that creates possibly a subtree

00:24:41,769 --> 00:24:45,220
representation of contents of the

00:24:43,299 --> 00:24:46,929
repository and this is also where

00:24:45,220 --> 00:24:49,720
subversion is significantly different

00:24:46,929 --> 00:24:52,269
from the current like the newer

00:24:49,720 --> 00:24:54,129
centralized systems the working copy and

00:24:52,269 --> 00:24:56,320
the repository are totally different

00:24:54,129 --> 00:24:58,720
databases and they they work in entirely

00:24:56,320 --> 00:25:00,190
different ways CVS had a very simple

00:24:58,720 --> 00:25:02,289
working copy where it has a CVS

00:25:00,190 --> 00:25:05,049
directory and one entries file with some

00:25:02,289 --> 00:25:10,440
lines of information about everything

00:25:05,049 --> 00:25:12,759
subversion has now CQ light-based

00:25:10,440 --> 00:25:16,629
database in here which is insanely

00:25:12,759 --> 00:25:18,970
complex and does allow you to perform

00:25:16,629 --> 00:25:20,529
arbitrary remodeling of your tree inside

00:25:18,970 --> 00:25:25,600
the working copy and it will track all

00:25:20,529 --> 00:25:27,279
your tree modifications and for instance

00:25:25,600 --> 00:25:29,619
correctly identify when you when you

00:25:27,279 --> 00:25:31,539
when you replace the directory right we

00:25:29,619 --> 00:25:33,369
had subversion one six with the old

00:25:31,539 --> 00:25:35,799
working copy that had the old model had

00:25:33,369 --> 00:25:37,419
problems with when you when you deleted

00:25:35,799 --> 00:25:40,119
the directory and created new one on top

00:25:37,419 --> 00:25:42,869
of it by copying something else say

00:25:40,119 --> 00:25:45,669
right so you have one tree basically

00:25:42,869 --> 00:25:48,580
replaced by another and then you delete

00:25:45,669 --> 00:25:49,960
a file inside the copy the data model

00:25:48,580 --> 00:25:52,299
didn't know whether the deletion was

00:25:49,960 --> 00:25:55,779
part of the thing you deleted or whether

00:25:52,299 --> 00:25:58,929
it was a deletion of something in the

00:25:55,779 --> 00:26:00,549
copy there are different layers and so

00:25:58,929 --> 00:26:03,850
the the new working copy has always

00:26:00,549 --> 00:26:05,740
fixed and it has a layer data structure

00:26:03,850 --> 00:26:08,559
model that I won't go into details about

00:26:05,740 --> 00:26:12,490
because it's too much for this session

00:26:08,559 --> 00:26:16,030
but it is basically designed to

00:26:12,490 --> 00:26:17,860
staged arbitrary modifications to the

00:26:16,030 --> 00:26:20,740
repository based on what's called a

00:26:17,860 --> 00:26:22,450
based revision and the base revision is

00:26:20,740 --> 00:26:26,860
what you last checked out or updated to

00:26:22,450 --> 00:26:28,690
and that is usually but if this written

00:26:26,860 --> 00:26:30,370
basically sir version keeps in its

00:26:28,690 --> 00:26:33,309
working copy it keeps a metadata say

00:26:30,370 --> 00:26:35,470
just you've checked out revision ten so

00:26:33,309 --> 00:26:37,960
all of these nodes will have a revision

00:26:35,470 --> 00:26:40,480
ten marker on them so these are files or

00:26:37,960 --> 00:26:48,880
directories it doesn't matter and then

00:26:40,480 --> 00:26:51,790
someone else could do the same and they

00:26:48,880 --> 00:26:53,890
also check our revision ten right so

00:26:51,790 --> 00:26:55,179
basically for those who've already used

00:26:53,890 --> 00:26:57,250
as we and there's nothing new here it's

00:26:55,179 --> 00:27:00,100
just you should probably already know

00:26:57,250 --> 00:27:06,640
this however do you know what happens

00:27:00,100 --> 00:27:10,120
when so it's personal over here changes

00:27:06,640 --> 00:27:15,340
of file and then runs the commit

00:27:10,120 --> 00:27:19,360
operation to to transfer the change and

00:27:15,340 --> 00:27:23,110
and what happens now is that server will

00:27:19,360 --> 00:27:25,480
check if this is your question anything

00:27:23,110 --> 00:27:31,809
has happened since revision ten to this

00:27:25,480 --> 00:27:35,140
file right because we can change any

00:27:31,809 --> 00:27:38,080
part of the tree in any revision and so

00:27:35,140 --> 00:27:39,880
every node has something associated with

00:27:38,080 --> 00:27:41,320
it which is called the last changed

00:27:39,880 --> 00:27:45,070
revision it's the revision which lot

00:27:41,320 --> 00:27:49,240
this which last touch this thing and if

00:27:45,070 --> 00:27:50,530
your base revision is below that then we

00:27:49,240 --> 00:27:51,730
know that you're going to overwrite

00:27:50,530 --> 00:27:53,590
changes other people have already

00:27:51,730 --> 00:27:57,790
committed so we don't allow it you say

00:27:53,590 --> 00:28:00,580
you are dead you have to update okay so

00:27:57,790 --> 00:28:02,020
you can't ever change anything unless

00:28:00,580 --> 00:28:06,490
you're fully up-to-date with all the

00:28:02,020 --> 00:28:08,260
nodes you want to change and what might

00:28:06,490 --> 00:28:10,840
happen here now is that the server says

00:28:08,260 --> 00:28:12,610
okay everything is fine you can make

00:28:10,840 --> 00:28:13,890
your change to the file here based on

00:28:12,610 --> 00:28:16,540
revision ten no problem

00:28:13,890 --> 00:28:20,280
and it says to the client you've just

00:28:16,540 --> 00:28:22,560
committed revision 50

00:28:20,280 --> 00:28:29,010
what can we do with the information we

00:28:22,560 --> 00:28:31,230
have here we have three nodes all check

00:28:29,010 --> 00:28:33,510
out from revision ten we changed one of

00:28:31,230 --> 00:28:36,450
them and we know this node is now the

00:28:33,510 --> 00:28:53,970
same as the one in the revision 50 what

00:28:36,450 --> 00:29:04,290
do we do about the others well it's not

00:28:53,970 --> 00:29:06,330
a problem no because you see this file s

00:29:04,290 --> 00:29:07,880
has ever changed in the entire drawing I

00:29:06,330 --> 00:29:09,960
made no it hasn't

00:29:07,880 --> 00:29:12,270
it doesn't matter which version you

00:29:09,960 --> 00:29:14,550
check out the server will always be able

00:29:12,270 --> 00:29:24,240
to correctly apply the data to this file

00:29:14,550 --> 00:29:25,650
because it's the same version oh yeah

00:29:24,240 --> 00:29:29,870
that's a problem but that's your problem

00:29:25,650 --> 00:29:32,670
you can you you can of course you can

00:29:29,870 --> 00:29:35,910
you will you will merge in these cases

00:29:32,670 --> 00:29:39,240
with other tree changes but you know

00:29:35,910 --> 00:29:41,370
this is required to make commit right

00:29:39,240 --> 00:29:43,290
only operation and update the read

00:29:41,370 --> 00:29:46,470
operation we don't want to force you to

00:29:43,290 --> 00:29:47,670
update so this is the base we could have

00:29:46,470 --> 00:29:49,740
made a trade of the other way saying you

00:29:47,670 --> 00:29:51,240
always have to update everything but

00:29:49,740 --> 00:29:52,650
then imagine somebody constantly

00:29:51,240 --> 00:29:54,570
updating user source not winning the

00:29:52,650 --> 00:29:57,720
race right the race gets a lot smaller

00:29:54,570 --> 00:30:00,300
this way and of course people can commit

00:29:57,720 --> 00:30:04,880
stuff they haven't tested but you know

00:30:00,300 --> 00:30:04,880
nothing we can do can prevent that so

00:30:05,070 --> 00:30:08,770
[Applause]

00:30:06,870 --> 00:30:11,740
so this is another thing that many

00:30:08,770 --> 00:30:12,970
people don't really see in user

00:30:11,740 --> 00:30:15,040
interface what we're about to see next

00:30:12,970 --> 00:30:17,590
but what happens to the information you

00:30:15,040 --> 00:30:19,360
know what can I do with the 10 year can

00:30:17,590 --> 00:30:24,220
I raise that to 50 safely knowing that

00:30:19,360 --> 00:30:26,200
my file is fine this way yes right

00:30:24,220 --> 00:30:27,610
because I just committed it so it's the

00:30:26,200 --> 00:30:34,900
version that's in the repository now at

00:30:27,610 --> 00:30:37,870
50 so we update this to say 50 but what

00:30:34,900 --> 00:30:40,270
do we do about the other ones we have to

00:30:37,870 --> 00:30:42,760
leave them as they are because we don't

00:30:40,270 --> 00:30:44,200
know something between these 40

00:30:42,760 --> 00:30:47,380
revisions that we're missing something

00:30:44,200 --> 00:30:49,330
else happened over here that could maybe

00:30:47,380 --> 00:30:53,260
remove this subtree or make arbitrary

00:30:49,330 --> 00:30:57,640
changes to it so after every commit you

00:30:53,260 --> 00:31:04,000
have what's called a mixed revision

00:30:57,640 --> 00:31:07,240
working copy that contains something

00:31:04,000 --> 00:31:10,060
that does not exist in the repository as

00:31:07,240 --> 00:31:11,980
such it contains notes from separate

00:31:10,060 --> 00:31:13,420
revisions in the repository you can

00:31:11,980 --> 00:31:16,810
basically create arbitrary mixed

00:31:13,420 --> 00:31:20,040
revision working copies and view every

00:31:16,810 --> 00:31:22,540
node from any revision you want

00:31:20,040 --> 00:31:24,010
you can also create mixed riverton

00:31:22,540 --> 00:31:29,890
copies just by updating sub trees to

00:31:24,010 --> 00:31:32,740
other revisions and this used to be a

00:31:29,890 --> 00:31:34,390
bigger problem before we stopped

00:31:32,740 --> 00:31:38,320
allowing people making merges into

00:31:34,390 --> 00:31:40,570
states like this so right now the 1/7

00:31:38,320 --> 00:31:42,040
and further clients will say please

00:31:40,570 --> 00:31:45,340
update your working copy before your run

00:31:42,040 --> 00:31:47,110
emerged because you're essentially if

00:31:45,340 --> 00:31:49,270
you do this with a mixer little button

00:31:47,110 --> 00:31:50,440
copy you are essentially editing a tree

00:31:49,270 --> 00:31:52,120
that doesn't even exist in the

00:31:50,440 --> 00:31:54,580
repository in this way and this can lead

00:31:52,120 --> 00:31:56,050
to potentially crazy conflicts that

00:31:54,580 --> 00:32:00,160
people don't understand can make sense

00:31:56,050 --> 00:32:01,780
off so there are situations where

00:32:00,160 --> 00:32:03,190
subversion will tell users please update

00:32:01,780 --> 00:32:04,540
your working copy for us before you can

00:32:03,190 --> 00:32:10,240
perform this operation but this is a

00:32:04,540 --> 00:32:12,040
fairly recent thing that we added apart

00:32:10,240 --> 00:32:13,360
from that it's fairly transparent you

00:32:12,040 --> 00:32:15,340
don't really see it but it's happening

00:32:13,360 --> 00:32:20,170
that's it's important to know about it

00:32:15,340 --> 00:32:23,260
so when this person over here runs an

00:32:20,170 --> 00:32:27,040
update and they have a another for the

00:32:23,260 --> 00:32:29,290
same file change in the way say they

00:32:27,040 --> 00:32:32,410
will usually bump all of their revisions

00:32:29,290 --> 00:32:34,990
to 50 here the next update and

00:32:32,410 --> 00:32:37,660
potentially merge the nodes that they've

00:32:34,990 --> 00:32:41,710
also changed so this is essentially how

00:32:37,660 --> 00:32:43,930
the working copy operator very

00:32:41,710 --> 00:32:52,450
high-level and it explains to you what

00:32:43,930 --> 00:32:54,280
the base revisions are and what the last

00:32:52,450 --> 00:32:56,550
changed revision is it's also important

00:32:54,280 --> 00:32:56,550
to know

00:33:01,720 --> 00:33:05,289
essentially in many other systems you

00:33:03,789 --> 00:33:07,480
will always have a single base revision

00:33:05,289 --> 00:33:10,210
for the entire tree and there's I'm not

00:33:07,480 --> 00:33:12,789
aware of any system that does it like

00:33:10,210 --> 00:33:15,879
separation does it here but it is a

00:33:12,789 --> 00:33:24,159
consequence of the of the tree storage

00:33:15,879 --> 00:33:25,389
model that it uses okay there are some

00:33:24,159 --> 00:33:28,480
other features which are nice to know

00:33:25,389 --> 00:33:31,389
about which is you can put arbitrary

00:33:28,480 --> 00:33:33,159
metadata on files which are essentially

00:33:31,389 --> 00:33:35,740
key value pairs that subversion stores

00:33:33,159 --> 00:33:37,509
for you and also versions so you can

00:33:35,740 --> 00:33:38,889
change them add them modify them and

00:33:37,509 --> 00:33:40,570
some of them influence of versus

00:33:38,889 --> 00:33:42,639
behavior like you probably know the one

00:33:40,570 --> 00:33:47,429
that sets the end-of-line style of a

00:33:42,639 --> 00:33:50,409
file or expands keywords inside the

00:33:47,429 --> 00:33:53,679
beside farms and we can add more over

00:33:50,409 --> 00:33:56,789
time I was before this conference I was

00:33:53,679 --> 00:34:01,120
looking at adding logs implied property

00:33:56,789 --> 00:34:04,539
which is basically a an enhanced version

00:34:01,120 --> 00:34:06,179
of FreeBSD x' custom patch that they

00:34:04,539 --> 00:34:10,389
used to have a lock template in the

00:34:06,179 --> 00:34:12,520
commit message editor but that is not

00:34:10,389 --> 00:34:15,030
done yet but it's also possible to add

00:34:12,520 --> 00:34:17,859
features like that with properties and

00:34:15,030 --> 00:34:19,419
you can also add your own and subversion

00:34:17,859 --> 00:34:22,329
won't care as long as you don't use the

00:34:19,419 --> 00:34:25,899
name that starts with SVN : it can be

00:34:22,329 --> 00:34:29,230
used arbitrarily as you like they're

00:34:25,899 --> 00:34:31,149
also revision properties which are not

00:34:29,230 --> 00:34:34,569
tied to a path like this one but are

00:34:31,149 --> 00:34:37,149
tied to a revision and they also start

00:34:34,569 --> 00:34:40,240
with the names also start with SEM SVN

00:34:37,149 --> 00:34:42,369
Colin and there's currently only three

00:34:40,240 --> 00:34:45,089
of those so there's a scene log which

00:34:42,369 --> 00:34:48,970
stores the log message for the commit

00:34:45,089 --> 00:34:51,399
there's SVN author which does the

00:34:48,970 --> 00:34:53,609
restores the author name which is

00:34:51,399 --> 00:34:56,530
usually given to subversion by apache or

00:34:53,609 --> 00:34:59,890
by ssh or depending on how your

00:34:56,530 --> 00:35:01,420
authenticate and then you have sv index

00:34:59,890 --> 00:35:03,400
which contains the timestamp of the

00:35:01,420 --> 00:35:05,290
pivot which you see in the log output

00:35:03,400 --> 00:35:08,079
basically this is tough the first time

00:35:05,290 --> 00:35:09,880
you see a neat lock message when it

00:35:08,079 --> 00:35:12,010
happens we in law contains this these

00:35:09,880 --> 00:35:12,960
two and then the log itself is taken

00:35:12,010 --> 00:35:15,420
from this property

00:35:12,960 --> 00:35:18,720
you can change them also you can use the

00:35:15,420 --> 00:35:20,339
Sen provided command to modify them by

00:35:18,720 --> 00:35:21,720
default this is disabled because these

00:35:20,339 --> 00:35:23,430
are not versions so we don't want people

00:35:21,720 --> 00:35:23,819
to accidentally overwrite them and loose

00:35:23,430 --> 00:35:27,329
them

00:35:23,819 --> 00:35:29,640
however the admin can turn on the proper

00:35:27,329 --> 00:35:31,829
editing and allow people to fix like

00:35:29,640 --> 00:35:33,980
typos and alarmist interest stuff like

00:35:31,829 --> 00:35:33,980
that

00:35:42,330 --> 00:35:48,550
any castles so far about what we've

00:35:45,550 --> 00:35:51,160
heard so far as anything new already in

00:35:48,550 --> 00:35:53,460
here or is it all your new all that

00:35:51,160 --> 00:35:53,460
already

00:36:02,120 --> 00:36:15,470
okay how are we for time when we have

00:36:05,000 --> 00:36:26,660
another hour or okay good we have we

00:36:15,470 --> 00:36:30,250
have half an hour done very good coffee

00:36:26,660 --> 00:36:30,250
breakers are now in an hour and a half

00:36:32,590 --> 00:36:36,250
okay so

00:36:48,680 --> 00:36:58,730
okay so let's look at so when people

00:36:54,760 --> 00:37:03,200
when people use these sort of update

00:36:58,730 --> 00:37:07,789
comment workflows and they all edit the

00:37:03,200 --> 00:37:11,750
same sub part of the tree you've

00:37:07,789 --> 00:37:13,279
essentially made a system where people

00:37:11,750 --> 00:37:15,559
see each other's changes as soon as they

00:37:13,279 --> 00:37:17,680
come in and update and there is no way

00:37:15,559 --> 00:37:20,750
for people to avoid each other because

00:37:17,680 --> 00:37:22,579
they cannot be out of date right so they

00:37:20,750 --> 00:37:33,970
they have to react to other people's

00:37:22,579 --> 00:37:35,990
changes right away and to avoid that

00:37:33,970 --> 00:37:38,180
sometimes you don't want that kind of

00:37:35,990 --> 00:37:44,119
thing because if you want to have stable

00:37:38,180 --> 00:37:47,720
branches or stuff like that you create

00:37:44,119 --> 00:37:49,039
copies of off say I'm going to used I'm

00:37:47,720 --> 00:37:52,220
going to try to use the FreeBSD

00:37:49,039 --> 00:37:57,410
terminology here so we have the head

00:37:52,220 --> 00:38:00,049
branch and if everyone was always

00:37:57,410 --> 00:38:04,190
working on head then we would run into

00:38:00,049 --> 00:38:06,710
issues when we want to identify exactly

00:38:04,190 --> 00:38:08,960
which version we actually released to

00:38:06,710 --> 00:38:11,210
users and which version they're running

00:38:08,960 --> 00:38:16,220
and which version we can just fix this

00:38:11,210 --> 00:38:18,440
with and stuff so the the labeling and

00:38:16,220 --> 00:38:20,180
branching is is a core feature of any

00:38:18,440 --> 00:38:25,970
version control system and subversion

00:38:20,180 --> 00:38:28,369
models just buy copies because they

00:38:25,970 --> 00:38:31,119
recall that copies always refer to

00:38:28,369 --> 00:38:34,490
things that have already been committed

00:38:31,119 --> 00:38:37,099
we pretty much already have that the tag

00:38:34,490 --> 00:38:39,349
for example sitting at each of those

00:38:37,099 --> 00:38:40,760
revision numbers we just don't have a

00:38:39,349 --> 00:38:43,609
friendly name for it we could remember

00:38:40,760 --> 00:38:45,079
this right we could remember had at two

00:38:43,609 --> 00:38:48,859
thousand three hundred sixty or

00:38:45,079 --> 00:38:49,970
something was FreeBSD nine but that's

00:38:48,859 --> 00:38:53,210
that's a bit silly

00:38:49,970 --> 00:38:56,809
so essentially subversion allows people

00:38:53,210 --> 00:39:00,470
to create aliases for these kinds of

00:38:56,809 --> 00:39:03,800
names by copying them to most to speak

00:39:00,470 --> 00:39:05,810
and subversion we'll just note down the

00:39:03,800 --> 00:39:08,300
copy from and it will exactly contain

00:39:05,810 --> 00:39:12,560
the state that people they are point to

00:39:08,300 --> 00:39:13,970
the state that people have labeled so in

00:39:12,560 --> 00:39:22,220
FreeBSD I think what they do is they

00:39:13,970 --> 00:39:24,859
have a copy head to stable then they

00:39:22,220 --> 00:39:27,730
create will appear releases and then

00:39:24,859 --> 00:39:30,619
from that they create another branch

00:39:27,730 --> 00:39:34,090
called relaying and then they create

00:39:30,619 --> 00:39:37,400
their actual release which is I think a

00:39:34,090 --> 00:39:39,710
tagging has never changed so first of

00:39:37,400 --> 00:39:41,840
all those branches as copies which are

00:39:39,710 --> 00:39:43,369
changed further and tags as copies which

00:39:41,840 --> 00:39:45,470
are not changed but the data model

00:39:43,369 --> 00:39:47,349
doesn't really care you can take a tag

00:39:45,470 --> 00:39:50,210
and make it into a branch is just a

00:39:47,349 --> 00:39:54,609
convention for the user how the user

00:39:50,210 --> 00:39:54,609
would use it that's all

00:39:58,880 --> 00:40:06,320
this is the kind of branching that's

00:40:00,860 --> 00:40:08,900
that that we do to identify versions

00:40:06,320 --> 00:40:11,150
that end users or other vendors are

00:40:08,900 --> 00:40:15,950
using as a basis for their or their

00:40:11,150 --> 00:40:18,620
system and we use them so that when they

00:40:15,950 --> 00:40:22,040
have a bug that that we need to fix for

00:40:18,620 --> 00:40:24,950
them we can fix it here and give them a

00:40:22,040 --> 00:40:27,560
version that is this good state that we

00:40:24,950 --> 00:40:29,600
have branched off plus the fixes that

00:40:27,560 --> 00:40:35,000
doesn't contain crazy new features which

00:40:29,600 --> 00:40:38,680
are only half done in the head and this

00:40:35,000 --> 00:40:38,680
is what we call release branches

00:40:43,770 --> 00:40:51,150
and then real hot we also have feature

00:40:46,440 --> 00:40:56,070
branches which freebsd currently go to

00:40:51,150 --> 00:40:57,810
the products directory people can create

00:40:56,070 --> 00:41:00,740
their own branches there and usually

00:40:57,810 --> 00:41:04,500
they copy the entire head and then they

00:41:00,740 --> 00:41:06,480
work in isolation of other people who

00:41:04,500 --> 00:41:09,300
are working on the in the head directory

00:41:06,480 --> 00:41:14,310
so they so these people update and

00:41:09,300 --> 00:41:20,370
commit here and these people update and

00:41:14,310 --> 00:41:22,260
commit down here and the idea is that if

00:41:20,370 --> 00:41:23,910
you're making some change which will

00:41:22,260 --> 00:41:25,500
destabilize head and prevent other

00:41:23,910 --> 00:41:27,570
people from working maybe you break the

00:41:25,500 --> 00:41:29,870
compiler for three weeks which is not

00:41:27,570 --> 00:41:33,570
very realistic but you might have to

00:41:29,870 --> 00:41:36,210
change many substance subsystems which

00:41:33,570 --> 00:41:38,100
interact and in some ways that you

00:41:36,210 --> 00:41:42,440
cannot just fix all at once because it

00:41:38,100 --> 00:41:45,870
takes time and so stuff like that and

00:41:42,440 --> 00:41:48,330
the goal of this branch though is to to

00:41:45,870 --> 00:41:50,370
always be like head plus the feature

00:41:48,330 --> 00:41:53,820
that's being developed it's not the

00:41:50,370 --> 00:41:58,130
point is not to stop following the head

00:41:53,820 --> 00:42:00,750
branch the point of the release branches

00:41:58,130 --> 00:42:03,120
is to actually never change

00:42:00,750 --> 00:42:04,740
basically the first the perfect release

00:42:03,120 --> 00:42:06,930
branch is created and then never changed

00:42:04,740 --> 00:42:09,000
if we could if the code was so good that

00:42:06,930 --> 00:42:11,190
we could just ship this to users like

00:42:09,000 --> 00:42:12,630
the state over here that'd be really

00:42:11,190 --> 00:42:14,510
nice because we could just they could

00:42:12,630 --> 00:42:16,590
just install it and be happy forever and

00:42:14,510 --> 00:42:19,260
there would be no problem and we could

00:42:16,590 --> 00:42:21,000
just develop here but in reality that

00:42:19,260 --> 00:42:22,830
never happens so you anticipate that

00:42:21,000 --> 00:42:26,360
there will be problems to fix which is

00:42:22,830 --> 00:42:26,360
why all these branches are created and

00:42:27,350 --> 00:42:32,040
of course you also need to you need to

00:42:30,150 --> 00:42:34,170
put the bug fixes that you make unstable

00:42:32,040 --> 00:42:35,880
or or these other branches over here to

00:42:34,170 --> 00:42:37,470
or vice versa so if you have an

00:42:35,880 --> 00:42:41,070
important fix on head you want to put it

00:42:37,470 --> 00:42:42,750
there and but you want to be selective

00:42:41,070 --> 00:42:44,370
about what you but you get so you don't

00:42:42,750 --> 00:42:45,870
want to merge all the changes that

00:42:44,370 --> 00:42:48,210
happen here you just want to merge some

00:42:45,870 --> 00:42:52,020
of them well usually you want to merge

00:42:48,210 --> 00:42:53,880
all the bug fixes down to the head but

00:42:52,020 --> 00:42:57,390
maybe you make version number adjustment

00:42:53,880 --> 00:42:59,010
changes or or other things that don't

00:42:57,390 --> 00:43:01,440
in the head so you also need to be

00:42:59,010 --> 00:43:02,970
selective in the other direction whereas

00:43:01,440 --> 00:43:05,430
this project thing is basically just

00:43:02,970 --> 00:43:06,990
give me all the changes from head that

00:43:05,430 --> 00:43:09,360
have happened within the last week or

00:43:06,990 --> 00:43:11,460
month or whatever and I want to merge

00:43:09,360 --> 00:43:13,980
them and basically rebase my work on top

00:43:11,460 --> 00:43:19,080
of those so that eventually when I go

00:43:13,980 --> 00:43:23,130
back I don't have any surprises and this

00:43:19,080 --> 00:43:27,630
is exactly how 3ds D currently operates

00:43:23,130 --> 00:43:29,610
in the subversion repository now the

00:43:27,630 --> 00:43:33,800
process of transferring these changes

00:43:29,610 --> 00:43:33,800
across these different copies of things

00:43:34,490 --> 00:43:49,710
could be done manually also and how that

00:43:46,710 --> 00:43:51,150
works is that you basically say you want

00:43:49,710 --> 00:43:55,130
to serve your projects branch to the

00:43:51,150 --> 00:43:59,730
head branch you get a working copy of it

00:43:55,130 --> 00:44:02,310
say from from this point say the project

00:43:59,730 --> 00:44:10,380
was in this development at this stage

00:44:02,310 --> 00:44:12,330
and you would say please give me all

00:44:10,380 --> 00:44:14,150
outstanding branches from a lot of the

00:44:12,330 --> 00:44:16,890
name changes from from the head

00:44:14,150 --> 00:44:19,140
what subversion does is it it follows

00:44:16,890 --> 00:44:20,940
the copy from information it has to

00:44:19,140 --> 00:44:25,560
pinpoint the common ancestor of the

00:44:20,940 --> 00:44:27,870
branches and then it can run a three-way

00:44:25,560 --> 00:44:29,010
merge of the original file here the

00:44:27,870 --> 00:44:31,620
modified version over here and the

00:44:29,010 --> 00:44:35,820
modified version over here so you know

00:44:31,620 --> 00:44:38,670
how diff the three the diff 3 tool takes

00:44:35,820 --> 00:44:40,950
three files one original one and two

00:44:38,670 --> 00:44:46,650
modified versions which are both without

00:44:40,950 --> 00:44:48,450
which are both based on the original so

00:44:46,650 --> 00:44:51,510
you have say the original version and

00:44:48,450 --> 00:44:55,110
file alpha B and they look like this so

00:44:51,510 --> 00:44:59,190
original was one two three four five six

00:44:55,110 --> 00:45:02,090
and said this was seven eight five six

00:44:59,190 --> 00:45:02,090
and this was

00:45:02,699 --> 00:45:08,409
no this is a simple example to two files

00:45:06,459 --> 00:45:11,859
these could be lines or chunks of files

00:45:08,409 --> 00:45:16,739
the file content or whatever and the

00:45:11,859 --> 00:45:21,039
algorithm goes and finds sections were a

00:45:16,739 --> 00:45:23,679
differs from oh and sections where B

00:45:21,039 --> 00:45:25,869
differs from all and if the sections

00:45:23,679 --> 00:45:31,650
don't overlap it just spits out the

00:45:25,869 --> 00:45:35,489
result as a sequence and you get that

00:45:31,650 --> 00:45:40,619
result if there are conflicts it will

00:45:35,489 --> 00:45:40,619
say if the conflicting case

00:46:05,010 --> 00:46:13,770
so like here it would say edifice from

00:46:08,670 --> 00:46:18,660
oh this range and B difference from all

00:46:13,770 --> 00:46:22,560
in this range and now you have an

00:46:18,660 --> 00:46:26,640
overlapping pattern so the output in

00:46:22,560 --> 00:46:30,480
this case is 1 2 and then you have an

00:46:26,640 --> 00:46:34,109
alternative it doesn't know what to do

00:46:30,480 --> 00:46:35,609
here so it writes both and this is why

00:46:34,109 --> 00:46:37,560
you see these conflict markers with the

00:46:35,609 --> 00:46:40,590
two versions right when you when you

00:46:37,560 --> 00:46:42,600
have a text conflict in the file and so

00:46:40,590 --> 00:46:46,680
to run emerge like this we always need

00:46:42,600 --> 00:46:48,420
three files and the task of eat after

00:46:46,680 --> 00:46:49,590
merges to find the relevant version of

00:46:48,420 --> 00:46:52,590
the files and put them through this

00:46:49,590 --> 00:46:57,859
algorithm to produce the nernst version

00:46:52,590 --> 00:47:01,830
and so the first time you you merge and

00:46:57,859 --> 00:47:04,050
subversion can really use the copy from

00:47:01,830 --> 00:47:06,480
point as a reference so say this was

00:47:04,050 --> 00:47:10,770
revision 50 where you created the branch

00:47:06,480 --> 00:47:14,400
and the merge would say ok for every

00:47:10,770 --> 00:47:18,570
file I use the file here in this review

00:47:14,400 --> 00:47:21,000
in head as my oh and the file in the

00:47:18,570 --> 00:47:24,540
current head revision of the the head

00:47:21,000 --> 00:47:28,680
which would be this as a and the file on

00:47:24,540 --> 00:47:31,170
the branch as B for example and then it

00:47:28,680 --> 00:47:35,340
edits the working copy accordingly so

00:47:31,170 --> 00:47:38,220
you get local changes here which you can

00:47:35,340 --> 00:47:40,859
then tweak further in any way you want

00:47:38,220 --> 00:47:42,150
and you can eventually commit them to

00:47:40,859 --> 00:47:45,090
the branch and that's when the merge

00:47:42,150 --> 00:47:48,330
happens or vertically it's like any

00:47:45,090 --> 00:47:51,180
other commit it's just you you could go

00:47:48,330 --> 00:47:52,380
and manually type all this all these

00:47:51,180 --> 00:47:53,369
things in here in the written copy but

00:47:52,380 --> 00:47:56,700
you don't have to the merge

00:47:53,369 --> 00:47:59,250
come on does it for you and then you

00:47:56,700 --> 00:48:03,359
come in it back to the branch and this

00:47:59,250 --> 00:48:06,450
will say okay we've merged all of these

00:48:03,359 --> 00:48:10,320
changes over here and you get a single

00:48:06,450 --> 00:48:11,880
commit which represents many other

00:48:10,320 --> 00:48:13,680
commits that might have happened here

00:48:11,880 --> 00:48:16,400
basically collapses all of them in a

00:48:13,680 --> 00:48:16,400
giant change sir

00:48:16,940 --> 00:48:22,770
so the next time you do this if you

00:48:21,270 --> 00:48:25,140
still use this version over here you

00:48:22,770 --> 00:48:28,260
have a problem because you will reapply

00:48:25,140 --> 00:48:30,990
changes that have happened here and you

00:48:28,260 --> 00:48:33,210
will get conflicts which which don't

00:48:30,990 --> 00:48:34,830
make sense because for example if this

00:48:33,210 --> 00:48:36,420
whole committee you deleted the line

00:48:34,830 --> 00:48:38,010
subversion will try again to delete the

00:48:36,420 --> 00:48:40,740
line and the line is not there anymore

00:48:38,010 --> 00:48:42,180
stuff like that simple example so

00:48:40,740 --> 00:48:45,780
instead you need to move your point of

00:48:42,180 --> 00:48:48,930
reference to the time you last so to the

00:48:45,780 --> 00:48:51,630
branch and say this was revision 100

00:48:48,930 --> 00:48:56,070
here you would essentially say okay

00:48:51,630 --> 00:49:01,590
we're merging now the the always at 100

00:48:56,070 --> 00:49:05,010
and my BAC ma is here and it's tedious

00:49:01,590 --> 00:49:09,330
if you have to keep giving separations

00:49:05,010 --> 00:49:11,790
to revision numbers to properly identify

00:49:09,330 --> 00:49:15,120
common ancestors but this used to be the

00:49:11,790 --> 00:49:18,060
case in as in subversion one for still

00:49:15,120 --> 00:49:22,230
so that here and merges you have to

00:49:18,060 --> 00:49:28,740
exactly say which version you want to

00:49:22,230 --> 00:49:31,380
use as a reference so you emerge and in

00:49:28,740 --> 00:49:33,650
subversion one five people try to go to

00:49:31,380 --> 00:49:38,520
implement it a system that tracks

00:49:33,650 --> 00:49:41,960
revision information for you so you

00:49:38,520 --> 00:49:41,960
don't have to specify it manually

00:49:42,380 --> 00:49:48,780
maybe we'll briefly look at how our

00:49:45,690 --> 00:49:51,510
merge needs to be parametrized each time

00:49:48,780 --> 00:49:58,920
it's wrong so what the merge needs to

00:49:51,510 --> 00:50:03,780
know is it needs a path one which is

00:49:58,920 --> 00:50:08,220
usually called the merge source and it

00:50:03,780 --> 00:50:12,810
needs to add a particular revision and

00:50:08,220 --> 00:50:17,880
it needs another path at a particular

00:50:12,810 --> 00:50:21,980
version usually these are called merge

00:50:17,880 --> 00:50:21,980
left and merge right

00:50:23,039 --> 00:50:32,799
and then it needs a merge target which

00:50:25,989 --> 00:50:35,739
is a working copy and a working copy by

00:50:32,799 --> 00:50:38,799
definition is also essentially coming

00:50:35,739 --> 00:50:43,809
from some paths at some revision but

00:50:38,799 --> 00:50:45,400
it's it's implicit so the most general

00:50:43,809 --> 00:50:48,579
kind of merge you can do in subversion

00:50:45,400 --> 00:50:50,739
is you plug you check out your working

00:50:48,579 --> 00:50:53,410
copy from anywhere you like from any

00:50:50,739 --> 00:50:55,029
revision you want and you put any path

00:50:53,410 --> 00:50:57,910
you want here and new revision you want

00:50:55,029 --> 00:51:01,119
here and here and here and then it will

00:50:57,910 --> 00:51:02,890
do something but really you want to

00:51:01,119 --> 00:51:05,410
choose the parameters so that something

00:51:02,890 --> 00:51:08,140
sensible happens because if you choose

00:51:05,410 --> 00:51:13,180
them wrong and it will just do silly

00:51:08,140 --> 00:51:14,920
stuff and you can look at how you would

00:51:13,180 --> 00:51:17,799
parameterize it here in this kind of

00:51:14,920 --> 00:51:24,279
suit merge so you you're sinking changes

00:51:17,799 --> 00:51:26,470
from the head and you would have the

00:51:24,279 --> 00:51:28,690
target of course is your project branch

00:51:26,470 --> 00:51:30,369
at the root at the head revision of the

00:51:28,690 --> 00:51:35,079
of this branch so at the newest revision

00:51:30,369 --> 00:51:37,630
and the merge left would be the head at

00:51:35,079 --> 00:51:44,980
50 in this case and the merge right

00:51:37,630 --> 00:51:48,549
would be the head at 100 and later on

00:51:44,980 --> 00:51:54,489
when we merged a second time the words

00:51:48,549 --> 00:51:56,019
left is the head at 100 and the newest

00:51:54,489 --> 00:51:58,029
revision of the head is the merge right

00:51:56,019 --> 00:52:00,489
and the head original Hubert and copy

00:51:58,029 --> 00:52:03,900
which already contains all the changes

00:52:00,489 --> 00:52:07,539
image previously will be the target and

00:52:03,900 --> 00:52:10,720
you can you can basically just you know

00:52:07,539 --> 00:52:14,319
type in the numbers every time but since

00:52:10,720 --> 00:52:15,819
the version 1 5 it records the numbers

00:52:14,319 --> 00:52:18,420
it had used it has used the previous

00:52:15,819 --> 00:52:21,849
merge in a property called merging for

00:52:18,420 --> 00:52:25,150
property is called su emergent 4 and as

00:52:21,849 --> 00:52:30,039
a general rule it will be created at the

00:52:25,150 --> 00:52:34,250
merge target so wherever your whichever

00:52:30,039 --> 00:52:37,020
party you're using in plugging into the

00:52:34,250 --> 00:52:39,630
as the merge target that will get motive

00:52:37,020 --> 00:52:41,339
or recorded on it and in this case for

00:52:39,630 --> 00:52:43,230
instance if the merge target is our

00:52:41,339 --> 00:52:45,660
products branch or the written copy the

00:52:43,230 --> 00:52:49,799
product perhaps and it's rooted we get a

00:52:45,660 --> 00:52:54,390
merger for property that says from head

00:52:49,799 --> 00:52:59,789
we've merged any changes that occur

00:52:54,390 --> 00:53:01,380
between 50 and 100 it does not record

00:52:59,789 --> 00:53:03,299
anything that is part of what we call

00:53:01,380 --> 00:53:05,460
the natural history of the branch which

00:53:03,299 --> 00:53:08,460
is if you trace back the copy from and

00:53:05,460 --> 00:53:11,190
you reach the common ancestor and you go

00:53:08,460 --> 00:53:12,480
further back here all these changes are

00:53:11,190 --> 00:53:15,059
implicitly part of that branch there

00:53:12,480 --> 00:53:16,920
won't be merged with some tricks you

00:53:15,059 --> 00:53:19,950
could actually merge them all so you can

00:53:16,920 --> 00:53:21,630
merge from anywhere but in this simpler

00:53:19,950 --> 00:53:25,190
scenario you usually don't want to hurt

00:53:21,630 --> 00:53:25,190
any from anything from there and

00:53:26,270 --> 00:53:31,829
essentially you can think of this as a

00:53:28,910 --> 00:53:37,020
filter so because when you run the

00:53:31,829 --> 00:53:38,700
second merge subversion will still do

00:53:37,020 --> 00:53:40,260
all the copy from tracing and stuff and

00:53:38,700 --> 00:53:41,880
find the common ancestor however it will

00:53:40,260 --> 00:53:44,190
then use the merger for to shift your

00:53:41,880 --> 00:53:45,690
point of reference it filters out

00:53:44,190 --> 00:53:48,900
revisions you've already merged from

00:53:45,690 --> 00:53:51,529
there and not the terminology merging

00:53:48,900 --> 00:53:54,299
your revision is very peculiar because

00:53:51,529 --> 00:53:56,160
revisions are global and any revision

00:53:54,299 --> 00:53:58,349
can change any branch or any number of

00:53:56,160 --> 00:54:01,799
branches so what you should really be

00:53:58,349 --> 00:54:04,230
saying is I emerged changes that

00:54:01,799 --> 00:54:07,500
happened at this path in this revision

00:54:04,230 --> 00:54:11,279
right I'm not changes that happened in

00:54:07,500 --> 00:54:13,319
head at at 51 but original 51 could also

00:54:11,279 --> 00:54:16,950
have changed other branches or other

00:54:13,319 --> 00:54:19,589
things other tags are or it could have

00:54:16,950 --> 00:54:21,119
not changed head at all so I would not

00:54:19,589 --> 00:54:24,500
receive any changes but I would still

00:54:21,119 --> 00:54:26,970
get the revision marked as merged

00:54:24,500 --> 00:54:28,440
essentially saying we've checked as a

00:54:26,970 --> 00:54:30,990
revision it didn't have any changes for

00:54:28,440 --> 00:54:33,990
head so we don't need to apply them to

00:54:30,990 --> 00:54:36,960
the word copy we're merging into it but

00:54:33,990 --> 00:54:38,809
you still get a recorded and in a sort

00:54:36,960 --> 00:54:40,920
of well maintained

00:54:38,809 --> 00:54:43,880
feature branch like this usually you

00:54:40,920 --> 00:54:46,400
will see entire may rangers merge

00:54:43,880 --> 00:54:49,220
branches maybe you wanna maybe several

00:54:46,400 --> 00:54:55,310
but you will always have continuous set

00:54:49,220 --> 00:54:57,500
of revisions usually and if you merge if

00:54:55,310 --> 00:54:59,660
you merge that's a bug-fix from a stable

00:54:57,500 --> 00:55:03,140
branch to the head

00:54:59,660 --> 00:55:07,100
subversion will also create merger fall

00:55:03,140 --> 00:55:09,290
on the head for this revision but if you

00:55:07,100 --> 00:55:13,940
do this a couple of times you you might

00:55:09,290 --> 00:55:19,930
see murder for that says something like

00:55:13,940 --> 00:55:24,140
from stable ten I've merged revisions

00:55:19,930 --> 00:55:26,750
sixty and sixty three little notation

00:55:24,140 --> 00:55:28,610
like that I think in FreeBSD people

00:55:26,750 --> 00:55:29,780
generally merge from here to stable so

00:55:28,610 --> 00:55:31,850
it will be the other way around

00:55:29,780 --> 00:55:33,860
but a stable branch forget the merchant

00:55:31,850 --> 00:55:37,870
for and it's actually quite some history

00:55:33,860 --> 00:55:40,310
I think in the repository in terms of

00:55:37,870 --> 00:55:42,080
where merciful was created and how it

00:55:40,310 --> 00:55:43,250
was distributed in between the path and

00:55:42,080 --> 00:55:45,860
the repository and how people were

00:55:43,250 --> 00:55:49,100
supposed to get rid of it or not get rid

00:55:45,860 --> 00:55:52,010
of it we get into that later so this is

00:55:49,100 --> 00:55:54,740
the ideal model of how this is supposed

00:55:52,010 --> 00:55:58,880
to work it gets complicated by the fact

00:55:54,740 --> 00:56:01,160
that people can essentially merge at any

00:55:58,880 --> 00:56:03,740
depth of a path in the target can also

00:56:01,160 --> 00:56:07,610
be at any depth in the repository so

00:56:03,740 --> 00:56:09,080
sometimes you have merchants for on one

00:56:07,610 --> 00:56:12,530
directory and then its child will also

00:56:09,080 --> 00:56:13,820
have merchants for and the question then

00:56:12,530 --> 00:56:16,730
becomes what do we do with that kind of

00:56:13,820 --> 00:56:22,940
situation what applies where and the

00:56:16,730 --> 00:56:28,510
rules are that if you have merchants

00:56:22,940 --> 00:56:28,510
were on a path so you have

00:56:29,660 --> 00:56:37,380
the murder for property at a and you

00:56:34,380 --> 00:56:45,420
have another directory B which also has

00:56:37,380 --> 00:56:48,080
version 4 then generally the murder for

00:56:45,420 --> 00:56:51,030
on B overrides anything above it so

00:56:48,080 --> 00:56:53,310
nothing will apply from the top of the

00:56:51,030 --> 00:56:55,650
tree to B B has its own version fo and

00:56:53,310 --> 00:57:02,460
its own it basically its own murder for

00:56:55,650 --> 00:57:06,210
universe if if the version finds that

00:57:02,460 --> 00:57:09,960
the murder for in a and B is essentially

00:57:06,210 --> 00:57:13,170
the same they're very strict sense it

00:57:09,960 --> 00:57:19,080
basically what it does is it would take

00:57:13,170 --> 00:57:23,100
both property values and it will create

00:57:19,080 --> 00:57:26,280
a path adjusted version of both so that

00:57:23,100 --> 00:57:28,380
the path differences disappear so say

00:57:26,280 --> 00:57:32,400
you have murder over here that says I've

00:57:28,380 --> 00:57:36,930
merged from from head and this one said

00:57:32,400 --> 00:57:39,900
I've merged from had a to remove all

00:57:36,930 --> 00:57:41,250
these past differences but it's

00:57:39,900 --> 00:57:43,920
essentially pretending that this version

00:57:41,250 --> 00:57:46,170
4 was up here and then it does a text

00:57:43,920 --> 00:57:48,900
wise comparison and if that matches

00:57:46,170 --> 00:57:51,630
entirely then this Russia four will be

00:57:48,900 --> 00:57:54,840
deleted this is what we call merging for

00:57:51,630 --> 00:57:58,020
religion however in practice it turns

00:57:54,840 --> 00:58:00,120
out that this rarely happens so I think

00:57:58,020 --> 00:58:02,700
that in the original design the idea was

00:58:00,120 --> 00:58:09,810
that murder four would regularly light

00:58:02,700 --> 00:58:11,730
up the top words but because because the

00:58:09,810 --> 00:58:14,130
elision strategy right now is very

00:58:11,730 --> 00:58:17,430
simple and other strategies have been

00:58:14,130 --> 00:58:19,290
tried but they introduced problems what

00:58:17,430 --> 00:58:20,640
happens is that you end up in some

00:58:19,290 --> 00:58:22,680
situations with lots of what we call

00:58:20,640 --> 00:58:25,190
subtly immersion for that that populates

00:58:22,680 --> 00:58:28,170
the tree and it's not bad as such

00:58:25,190 --> 00:58:31,980
however it sometimes creates problems

00:58:28,170 --> 00:58:33,630
with either bars and subversion where it

00:58:31,980 --> 00:58:36,530
doesn't really handle the merging of the

00:58:33,630 --> 00:58:39,480
various medical properties properly or

00:58:36,530 --> 00:58:41,300
it just makes things very slow or it

00:58:39,480 --> 00:58:43,590
complicates

00:58:41,300 --> 00:58:46,640
the answer to questions like what has

00:58:43,590 --> 00:58:46,640
been merged into this branch

00:58:50,330 --> 00:58:58,020
okay so there's also non inheritable

00:58:53,690 --> 00:59:01,190
merging for which is signified by having

00:58:58,020 --> 00:59:03,660
a revision like say R 60 with a star

00:59:01,190 --> 00:59:06,119
that essentially means that only this

00:59:03,660 --> 00:59:07,830
path has gotten the changes but the

00:59:06,119 --> 00:59:12,300
children have not even if they don't

00:59:07,830 --> 00:59:16,440
have merjan for so we could of course

00:59:12,300 --> 00:59:20,250
overwrite this but say another child C

00:59:16,440 --> 00:59:21,930
which has enumerated for essentially

00:59:20,250 --> 00:59:25,619
would inherit the merger for without

00:59:21,930 --> 00:59:29,910
this revision from a so this can happen

00:59:25,619 --> 00:59:36,450
if for example you run a merge in a

00:59:29,910 --> 00:59:39,050
working copy which contains a path that

00:59:36,450 --> 00:59:41,670
you don't have access permission for

00:59:39,050 --> 00:59:43,230
right so you check out the the tree and

00:59:41,670 --> 00:59:45,060
some of the subdirectory is forbidden

00:59:43,230 --> 00:59:47,070
for you in the root side of the access

00:59:45,060 --> 00:59:48,480
rules and you don't get to see it

00:59:47,070 --> 00:59:50,010
because we want to hide it from you we

00:59:48,480 --> 00:59:52,560
don't want people to see secret

00:59:50,010 --> 00:59:55,920
information and repositories that's what

00:59:52,560 --> 00:59:59,670
this often this path access feature is

00:59:55,920 --> 01:00:01,230
for and so instead of something on the

00:59:59,670 --> 01:00:03,000
disk you just get a small marker in the

01:00:01,230 --> 01:00:06,180
in the database which says this path

01:00:03,000 --> 01:00:08,010
isn't here and when a merge run runs

01:00:06,180 --> 01:00:10,830
into that and has changes for that path

01:00:08,010 --> 01:00:12,300
to merge it won't apply them but it said

01:00:10,830 --> 01:00:15,510
murder for like this on the parent to

01:00:12,300 --> 01:00:17,280
say well we we merged everything up to

01:00:15,510 --> 01:00:18,780
here but further down we can't do it we

01:00:17,280 --> 01:00:21,150
couldn't do it in this this time maybe

01:00:18,780 --> 01:00:23,099
next time someone else will run the

01:00:21,150 --> 01:00:28,560
merge and who has access permission and

01:00:23,099 --> 01:00:33,260
the changes will follow along and it can

01:00:28,560 --> 01:00:35,460
also happen if you are on purpose hide

01:00:33,260 --> 01:00:37,500
subtrees of your working copy so if you

01:00:35,460 --> 01:00:39,690
use the depth feature the sparse

01:00:37,500 --> 01:00:45,480
checkout feature where in the working

01:00:39,690 --> 01:00:47,070
copy you can hide paths even though they

01:00:45,480 --> 01:00:49,109
exist in the repositories so you have a

01:00:47,070 --> 01:00:51,570
very large directory that you don't

01:00:49,109 --> 01:00:53,630
really want to check out every time you

01:00:51,570 --> 01:00:57,840
cut

01:00:53,630 --> 01:01:01,800
check out the parent with what we call

01:00:57,840 --> 01:01:04,770
depth empty per LP and then you have a

01:01:01,800 --> 01:01:09,750
copy of P with no children and you can

01:01:04,770 --> 01:01:17,160
go inside there and say update and then

01:01:09,750 --> 01:01:25,950
you set the depth of a directory P child

01:01:17,160 --> 01:01:29,760
1 to infinity for example would edit

01:01:25,950 --> 01:01:32,130
here then C 1 will appear with all its

01:01:29,760 --> 01:01:37,800
children and other values you can put a

01:01:32,130 --> 01:01:40,080
set of infinity R immediate which gets

01:01:37,800 --> 01:01:41,820
all the immediate children or files

01:01:40,080 --> 01:01:49,770
which will only get the file children of

01:01:41,820 --> 01:01:51,660
this directory P don't see one so this

01:01:49,770 --> 01:01:56,460
can also create situations where the

01:01:51,660 --> 01:01:58,560
merge might run into paths that don't

01:01:56,460 --> 01:02:00,210
exist all that are just simply locking

01:01:58,560 --> 01:02:09,090
in the word copy and then you get that

01:02:00,210 --> 01:02:11,610
kind of thing and okay so when you do

01:02:09,090 --> 01:02:13,590
this depths check out and you have

01:02:11,610 --> 01:02:15,450
what's called the ambient depth which I

01:02:13,590 --> 01:02:16,980
think it's a really cool term for little

01:02:15,450 --> 01:02:19,200
control system to use because it sounds

01:02:16,980 --> 01:02:23,850
like it's like some a fixed or a record

01:02:19,200 --> 01:02:25,530
or something it's it's recorded in the

01:02:23,850 --> 01:02:27,270
written copy as being the death of this

01:02:25,530 --> 01:02:29,160
node and when you run an OL update it

01:02:27,270 --> 01:02:30,480
doesn't change it because otherwise if

01:02:29,160 --> 01:02:32,850
you had this large directory you want to

01:02:30,480 --> 01:02:34,260
exclude you check out the working copy

01:02:32,850 --> 01:02:35,640
and then you will update the last work

01:02:34,260 --> 01:02:38,100
you would come down you probably not be

01:02:35,640 --> 01:02:40,500
very happy so it records the depth that

01:02:38,100 --> 01:02:42,960
you used the last time and it stores it

01:02:40,500 --> 01:02:44,490
and whenever you use the normal depth

01:02:42,960 --> 01:02:48,570
option it applies to the current

01:02:44,490 --> 01:02:51,990
operation and we are we often have say

01:02:48,570 --> 01:02:55,440
you could dip your working copy to depth

01:02:51,990 --> 01:02:57,240
immediate instead of infinity to only

01:02:55,440 --> 01:02:59,220
see changes made to nodes which are

01:02:57,240 --> 01:03:02,790
within the depth of infinity of

01:02:59,220 --> 01:03:04,650
immediate and in this case it doesn't

01:03:02,790 --> 01:03:05,940
change the ambient death of the node

01:03:04,650 --> 01:03:08,400
right

01:03:05,940 --> 01:03:10,079
and this is what setups is for so the

01:03:08,400 --> 01:03:11,280
setups you tell her and copy look I want

01:03:10,079 --> 01:03:17,490
to have a different enemy on tap for

01:03:11,280 --> 01:03:20,700
this node right but and this is also

01:03:17,490 --> 01:03:22,460
mentioned in the freebsd handbook and i

01:03:20,700 --> 01:03:27,210
think people use that quite a lot

01:03:22,460 --> 01:03:29,430
because you see quite a lot of non

01:03:27,210 --> 01:03:32,789
inheritable version for in freebsd it's

01:03:29,430 --> 01:03:33,960
all straight if you go look for i don't

01:03:32,789 --> 01:03:35,760
think it's access permissions because

01:03:33,960 --> 01:03:37,950
generally normal source projects the

01:03:35,760 --> 01:03:39,240
access permissions are not trigger for

01:03:37,950 --> 01:03:41,910
this problem because everyone can read

01:03:39,240 --> 01:03:43,470
everything but in corporations usually

01:03:41,910 --> 01:03:45,299
it's the access permissions that caused

01:03:43,470 --> 01:03:47,510
this problem but it's the same same

01:03:45,299 --> 01:03:47,510
issue

01:03:51,650 --> 01:04:00,480
okay so we've had two types of merges

01:03:57,240 --> 01:04:02,720
we've had to sync and this is what we

01:04:00,480 --> 01:04:08,069
call cherry-picking here will you

01:04:02,720 --> 01:04:10,349
deliberately take particular revisions

01:04:08,069 --> 01:04:13,980
and and our changes that happened in

01:04:10,349 --> 01:04:15,960
particular innocent merge just them this

01:04:13,980 --> 01:04:20,700
is not strictly the same as git

01:04:15,960 --> 01:04:22,349
cherry-pick because it triggers treats

01:04:20,700 --> 01:04:24,839
this as a difference patch thing sort of

01:04:22,349 --> 01:04:26,700
more or less its from the equivalent but

01:04:24,839 --> 01:04:28,079
they don't track it and so subversion

01:04:26,700 --> 01:04:29,730
actually tracks to cherry-pick you can

01:04:28,079 --> 01:04:31,859
ask a branch what has been

01:04:29,730 --> 01:04:33,270
cherry-picking to you and it will be in

01:04:31,859 --> 01:04:35,549
the merger formation not in the lower

01:04:33,270 --> 01:04:40,829
messages so there's a slight difference

01:04:35,549 --> 01:04:42,270
there to get and so this is generally

01:04:40,829 --> 01:04:43,950
used for release branches use for

01:04:42,270 --> 01:04:46,410
project branches and then you have

01:04:43,950 --> 01:04:50,640
another merge which is the reintegrate

01:04:46,410 --> 01:04:55,829
merge and why does even exists is a big

01:04:50,640 --> 01:04:57,690
mystery to many people because ambert

01:04:55,829 --> 01:05:00,539
operation is essentially symmetric right

01:04:57,690 --> 01:05:02,700
I can I can put one branch on the left

01:05:00,539 --> 01:05:05,700
and one parent on the right and I can

01:05:02,700 --> 01:05:06,750
swap them around and if I compare them

01:05:05,700 --> 01:05:09,000
the other way I would just get the

01:05:06,750 --> 01:05:10,589
different verdict and if I merged in the

01:05:09,000 --> 01:05:12,779
other way I would just get changes over

01:05:10,589 --> 01:05:15,619
here played over there instead of the

01:05:12,779 --> 01:05:18,210
other way around so why is it different

01:05:15,619 --> 01:05:19,859
in many systems the

01:05:18,210 --> 01:05:21,300
control systems you don't have that

01:05:19,859 --> 01:05:25,980
difference so generally a merge

01:05:21,300 --> 01:05:28,050
operation like it would say take the two

01:05:25,980 --> 01:05:31,109
heads that you want to merge and create

01:05:28,050 --> 01:05:33,990
a new child of them that has both of

01:05:31,109 --> 01:05:36,480
them as ancestors and merge them all in

01:05:33,990 --> 01:05:39,440
some way and there's no concept of

01:05:36,480 --> 01:05:45,420
direction right and in subversion you

01:05:39,440 --> 01:05:49,410
because of the way you do parametrize to

01:05:45,420 --> 01:05:51,119
merge you think of it in this firm in

01:05:49,410 --> 01:05:52,830
terms of this it sort of makes sense I

01:05:51,119 --> 01:05:55,140
don't think it's really the best

01:05:52,830 --> 01:05:56,970
exploration because it's really like why

01:05:55,140 --> 01:05:58,770
there are two different implementations

01:05:56,970 --> 01:06:01,859
of emerges pretty much an implementation

01:05:58,770 --> 01:06:03,869
detail but it's possible to understand

01:06:01,859 --> 01:06:06,570
it a bit by figuring out how to

01:06:03,869 --> 01:06:09,119
parameterize a really great merge these

01:06:06,570 --> 01:06:12,450
parameters and comparing that to Houston

01:06:09,119 --> 01:06:20,270
submerges done so we said that for the

01:06:12,450 --> 01:06:23,430
ascent merge we had first one we had was

01:06:20,270 --> 01:06:26,820
the path was head and revision 50 was

01:06:23,430 --> 01:06:32,220
the merge left the merge right was head

01:06:26,820 --> 01:06:34,430
at 100 must emerge right then we have

01:06:32,220 --> 01:06:37,830
the working copy of the projects branch

01:06:34,430 --> 01:06:40,970
so that's that's always oh yeah the

01:06:37,830 --> 01:06:40,970
working copy is products

01:06:44,060 --> 01:06:48,530
okay now if I want to merge the other

01:06:45,920 --> 01:06:50,960
way like I've done this a few times

01:06:48,530 --> 01:06:55,310
right I've I've done it a second time

01:06:50,960 --> 01:06:59,930
putting putting the number 100 here and

01:06:55,310 --> 01:07:04,040
maybe say we have provision 200 over

01:06:59,930 --> 01:07:06,770
here and maybe I put put 200 here or

01:07:04,040 --> 01:07:09,590
something right the second time so this

01:07:06,770 --> 01:07:12,890
goes on and on and on the religions keep

01:07:09,590 --> 01:07:14,990
changing the paths don't now if you want

01:07:12,890 --> 01:07:21,860
to merge the feature that was developed

01:07:14,990 --> 01:07:24,940
here to the head you have to take just

01:07:21,860 --> 01:07:30,340
the changes that implement the feature

01:07:24,940 --> 01:07:32,570
but you have to omit the merge commits

01:07:30,340 --> 01:07:36,770
because those are changes from head that

01:07:32,570 --> 01:07:39,080
you already haven't had okay so if you

01:07:36,770 --> 01:07:40,850
if you do the same kind of thing the

01:07:39,080 --> 01:07:46,700
same parameterization just swap the

01:07:40,850 --> 01:07:54,010
paths out so if you say merge I use a

01:07:46,700 --> 01:07:54,010
new run for this so say if you said

01:07:54,310 --> 01:08:03,770
merge projects from it's common ounces

01:07:58,580 --> 01:08:08,140
2.50 and projects at the current

01:08:03,770 --> 01:08:15,080
revision 200 into a working copy of head

01:08:08,140 --> 01:08:18,530
what would happen you would you would

01:08:15,080 --> 01:08:21,799
merge this this collection of changes

01:08:18,530 --> 01:08:23,720
including the black ones but including

01:08:21,799 --> 01:08:26,089
the ones that contain merge commits so

01:08:23,720 --> 01:08:28,540
because this doesn't happen in get

01:08:26,089 --> 01:08:30,950
because if Mississippi already has these

01:08:28,540 --> 01:08:33,170
hidden inside the dag right it doesn't

01:08:30,950 --> 01:08:34,910
see them anymore but it's a version they

01:08:33,170 --> 01:08:38,030
are still there they appear as local

01:08:34,910 --> 01:08:39,170
changes selective to the head in the

01:08:38,030 --> 01:08:41,180
merge history even though they're not

01:08:39,170 --> 01:08:42,680
because because these are just like it's

01:08:41,180 --> 01:08:45,230
just a series of commits and subversion

01:08:42,680 --> 01:08:46,609
doesn't really know or care what the

01:08:45,230 --> 01:08:49,339
changes are that are inside these

01:08:46,609 --> 01:08:51,620
commits it will run a diff from here to

01:08:49,339 --> 01:08:53,120
here if you do this kind of he put in

01:08:51,620 --> 01:08:55,400
these parameters that we just put in and

01:08:53,120 --> 01:08:57,770
it will merge all that the working copy

01:08:55,400 --> 01:08:59,390
of this and then all the changes were

01:08:57,770 --> 01:09:03,279
down we'll come back and bounce up back

01:08:59,390 --> 01:09:09,109
at you and you got lots of conflicts and

01:09:03,279 --> 01:09:19,850
to fix that how do you need to change

01:09:09,109 --> 01:09:26,750
this what I need to change around what

01:09:19,850 --> 01:09:28,069
do I need to change in which way yeah

01:09:26,750 --> 01:09:37,370
how do I do that by changing these

01:09:28,069 --> 01:09:39,440
parameters so you could you could split

01:09:37,370 --> 01:09:42,980
you could specify although you could

01:09:39,440 --> 01:09:44,450
cherry-pick everything which is what

01:09:42,980 --> 01:09:46,100
previously does currently in some cases

01:09:44,450 --> 01:09:50,870
because the reintegrate doesn't always

01:09:46,100 --> 01:09:54,680
work for them however that's of the

01:09:50,870 --> 01:09:56,120
intended solution because it requires

01:09:54,680 --> 01:09:57,860
you to do a lot of work it requires you

01:09:56,120 --> 01:09:59,900
to to manually pick all the changes

01:09:57,860 --> 01:10:01,760
you've already made you basically just

01:09:59,900 --> 01:10:05,540
want everything from that branch over in

01:10:01,760 --> 01:10:08,990
the hand right so there's a trick to do

01:10:05,540 --> 01:10:13,070
it basically you think about what the oh

01:10:08,990 --> 01:10:15,670
and a and B need to be so we said the

01:10:13,070 --> 01:10:17,660
merge left is basically the original and

01:10:15,670 --> 01:10:23,750
this is one more occurred version this

01:10:17,660 --> 01:10:26,540
is the other right if you move your

01:10:23,750 --> 01:10:30,710
original to the latest revision of head

01:10:26,540 --> 01:10:35,300
which you last assumed to what happens

01:10:30,710 --> 01:10:36,980
so say you you have it sent up to here

01:10:35,300 --> 01:10:40,430
right and there are other changes over

01:10:36,980 --> 01:10:42,470
here which you don't have yet all these

01:10:40,430 --> 01:10:48,530
changes you've got where you've merged

01:10:42,470 --> 01:10:51,370
them so this can be you but now you now

01:10:48,530 --> 01:10:51,370
you're your other

01:10:58,250 --> 01:11:02,130
this still needs to be the branch that

01:11:00,420 --> 01:11:04,860
you get a different that contains the

01:11:02,130 --> 01:11:14,040
branch tangles so essentially instead of

01:11:04,860 --> 01:11:22,980
doing bad you do head say at 200 and you

01:11:14,040 --> 01:11:25,520
say projects projects at head into a

01:11:22,980 --> 01:11:29,580
working copy of head at head which is

01:11:25,520 --> 01:11:32,220
potentially different than then 200

01:11:29,580 --> 01:11:35,300
because it's in the past and that will

01:11:32,220 --> 01:11:38,910
give you it essentially emerged that

01:11:35,300 --> 01:11:41,850
filters out the big merge changes and

01:11:38,910 --> 01:11:45,000
apply just these try it out it works it

01:11:41,850 --> 01:11:46,980
works this way but the thing is um the

01:11:45,000 --> 01:11:48,900
reintegrate option that we used to have

01:11:46,980 --> 01:11:50,430
before I see emerge does just that it

01:11:48,900 --> 01:11:52,530
changes the parameters and then

01:11:50,430 --> 01:11:54,270
internally also which is why this isn't

01:11:52,530 --> 01:11:55,800
the full explanation runs an indifferent

01:11:54,270 --> 01:11:59,970
merge algorithm the different

01:11:55,800 --> 01:12:01,950
implementation of the merge to put just

01:11:59,970 --> 01:12:06,450
the right changes back on to the one to

01:12:01,950 --> 01:12:09,570
the head and we used to require users to

01:12:06,450 --> 01:12:12,510
specify the direction they merge to into

01:12:09,570 --> 01:12:14,490
so you used to have to say okay I'm

01:12:12,510 --> 01:12:18,270
sinking so I'm not using the original

01:12:14,490 --> 01:12:20,010
adoption and now if you're going back to

01:12:18,270 --> 01:12:21,690
the head you need to suddenly use it

01:12:20,010 --> 01:12:24,870
because you're changing merge directions

01:12:21,690 --> 01:12:30,800
and this got confused many people it was

01:12:24,870 --> 01:12:30,800
just too cumbersome to use and then

01:12:30,920 --> 01:12:36,720
subversion developer to enfold figured

01:12:33,600 --> 01:12:40,230
out how to automate the parameterization

01:12:36,720 --> 01:12:42,450
better so that it submersible can tell

01:12:40,230 --> 01:12:44,010
from the kind of merger doing whether

01:12:42,450 --> 01:12:46,500
you're trying to do a sync or integrate

01:12:44,010 --> 01:12:47,910
and then we run it automatically so in

01:12:46,500 --> 01:12:49,530
1/8 you don't have to use this option

01:12:47,910 --> 01:12:52,410
anymore but it still works exactly the

01:12:49,530 --> 01:12:56,160
same way it will the UI is basically

01:12:52,410 --> 01:12:58,260
just hiding it from you so now you say

01:12:56,160 --> 01:13:05,100
you really want to let's just merge

01:12:58,260 --> 01:13:11,790
everything going back to this it's

01:13:05,100 --> 01:13:15,300
enough to say SVN merge and you give a

01:13:11,790 --> 01:13:16,560
merge solves and it gets all the

01:13:15,300 --> 01:13:18,780
information that needs from copy from

01:13:16,560 --> 01:13:22,170
for immersion for from your target and

01:13:18,780 --> 01:13:23,940
it plugs in the parameters for you no

01:13:22,170 --> 01:13:26,640
matter whether you just soak or

01:13:23,940 --> 01:13:31,380
integrate it will work or should that's

01:13:26,640 --> 01:13:33,390
the idea it doesn't work perfectly it

01:13:31,380 --> 01:13:35,550
has problems with subtly immersion for

01:13:33,390 --> 01:13:38,180
in some cases and I've actually found a

01:13:35,550 --> 01:13:41,340
case where in FreeBSD you have a branch

01:13:38,180 --> 01:13:44,250
one of the Beehive branches in project

01:13:41,340 --> 01:13:45,840
if you try to reintegrate it subversion

01:13:44,250 --> 01:13:49,230
tells you oh you haven't really soaked

01:13:45,840 --> 01:13:50,580
up the branch properly they have some

01:13:49,230 --> 01:13:53,580
changes over here which you haven't

01:13:50,580 --> 01:13:58,440
synced up and this means that this

01:13:53,580 --> 01:14:00,270
really great trick won't work so when

01:13:58,440 --> 01:14:01,830
you go it requires you to have fully

01:14:00,270 --> 01:14:04,620
zoomed everything up to a particular

01:14:01,830 --> 01:14:06,960
revision and it says well you're missing

01:14:04,620 --> 01:14:08,700
all such such visions from the sub sub

01:14:06,960 --> 01:14:11,730
sub path right it gives you long list of

01:14:08,700 --> 01:14:13,410
things and and then you say ok you go

01:14:11,730 --> 01:14:15,030
back to the to the branch and you try to

01:14:13,410 --> 01:14:17,550
merge from the head like this and it

01:14:15,030 --> 01:14:21,630
does nothing it says everything is

01:14:17,550 --> 01:14:24,930
already there and and this is this is a

01:14:21,630 --> 01:14:28,110
bugged I think I haven't really found

01:14:24,930 --> 01:14:30,060
out why it happens but it's probably got

01:14:28,110 --> 01:14:32,810
to do with either non inheritable ranges

01:14:30,060 --> 01:14:36,600
and immersion for subtree immersion for

01:14:32,810 --> 01:14:39,420
handling bugs but anyway the idea is

01:14:36,600 --> 01:14:40,350
that it should work like this so when it

01:14:39,420 --> 01:14:43,560
doesn't work like this usually

01:14:40,350 --> 01:14:47,010
subversion has a problem or really the

01:14:43,560 --> 01:14:49,830
user has done things like merged like

01:14:47,010 --> 01:14:53,310
into a partial working copy or merge

01:14:49,830 --> 01:14:54,890
without access permissions and created a

01:14:53,310 --> 01:14:59,670
situation where a branch isn't fully up

01:14:54,890 --> 01:15:03,720
after sync it can also happen in doing

01:14:59,670 --> 01:15:06,960
merge mistakes especially with the

01:15:03,720 --> 01:15:10,369
conflict resolution that can sometimes

01:15:06,960 --> 01:15:13,119
be quite overwhelming for

01:15:10,369 --> 01:15:15,199
people who haven't practiced it a lot

01:15:13,119 --> 01:15:18,739
especially when there are renames

01:15:15,199 --> 01:15:21,019
involved so are there any questions

01:15:18,739 --> 01:15:24,649
about this merger for stuff and they're

01:15:21,019 --> 01:15:26,389
much tracking stuff what's this new did

01:15:24,649 --> 01:15:31,300
you use this before did any of you

01:15:26,389 --> 01:15:31,300
already use this okay

01:15:32,050 --> 01:15:41,719
so another thing that becomes

01:15:38,869 --> 01:15:51,469
complicated quite quickly is dealing

01:15:41,719 --> 01:15:58,099
with what we call G conflicts and what

01:15:51,469 --> 01:16:00,699
happens here is that people make

01:15:58,099 --> 01:16:03,949
structural changes to a project in

01:16:00,699 --> 01:16:05,479
conflicting ways like someone edits a

01:16:03,949 --> 01:16:07,639
fire where some other person deletes it

01:16:05,479 --> 01:16:09,530
for example there needs to be some sort

01:16:07,639 --> 01:16:15,469
of resolution to this because it's not

01:16:09,530 --> 01:16:18,499
possible to do both and all the

01:16:15,469 --> 01:16:20,149
subversion versions like subversion 1 5

01:16:18,499 --> 01:16:27,519
I think we're doing things like this

01:16:20,149 --> 01:16:29,899
where if you have a file say foo and

01:16:27,519 --> 01:16:32,809
someone checks out a working copy or foo

01:16:29,899 --> 01:16:35,780
and edits it like it's the file in here

01:16:32,809 --> 01:16:39,579
creates a modified version and someone

01:16:35,780 --> 01:16:44,590
else decides to delete the file and

01:16:39,579 --> 01:16:44,590
commits that user here doesn't update

01:16:47,199 --> 01:16:53,030
what's a version 1 5 did was it said oh

01:16:51,289 --> 01:16:56,179
I have to delete this file well ok I'm

01:16:53,030 --> 01:16:57,709
gonna remove it from metadata and then

01:16:56,179 --> 01:16:59,840
I'm going to check it's under state and

01:16:57,709 --> 01:17:03,139
if it's modified relative to the

01:16:59,840 --> 01:17:05,840
metadata and then I'm going to keep it

01:17:03,139 --> 01:17:08,959
on disk but you know because it's gone

01:17:05,840 --> 01:17:11,530
from version control essentially before

01:17:08,959 --> 01:17:14,030
they update you saw like a modified fool

01:17:11,530 --> 01:17:15,469
and after the update you saw a question

01:17:14,030 --> 01:17:16,729
mark foo which means foo is no unwritten

01:17:15,469 --> 01:17:19,080
and not tracked anymore

01:17:16,729 --> 01:17:21,780
because it was deleted

01:17:19,080 --> 01:17:23,610
so the user builds the project and

01:17:21,780 --> 01:17:24,930
everything works fine and they don't see

01:17:23,610 --> 01:17:26,610
that there's a small question mark in

01:17:24,930 --> 01:17:28,650
the SEO status output and they committed

01:17:26,610 --> 01:17:31,140
they break the bill for everyone because

01:17:28,650 --> 01:17:36,120
some change somewhere else required this

01:17:31,140 --> 01:17:39,530
fight from right and people who were

01:17:36,120 --> 01:17:44,790
versioning code with subversion building

01:17:39,530 --> 01:17:49,020
ct-scan equipment had to get it had to

01:17:44,790 --> 01:17:50,820
get it certified from the FCC and said

01:17:49,020 --> 01:17:53,790
if we're going to lose changes like this

01:17:50,820 --> 01:17:56,040
in our in our process then we cannot use

01:17:53,790 --> 01:17:58,500
this tool to possible the FCC will never

01:17:56,040 --> 01:17:59,160
allow us to use that it's right to

01:17:58,500 --> 01:18:03,000
dangerous

01:17:59,160 --> 01:18:05,760
and they said what can be done about

01:18:03,000 --> 01:18:07,140
this and at the time this was actually

01:18:05,760 --> 01:18:10,620
the time when I got involved in the

01:18:07,140 --> 01:18:13,740
project and my company ended up getting

01:18:10,620 --> 01:18:17,850
a small contract to try to fix this

01:18:13,740 --> 01:18:21,120
problem and we work with the subversion

01:18:17,850 --> 01:18:23,040
project to decide what to do about this

01:18:21,120 --> 01:18:25,740
and also with the company that builds

01:18:23,040 --> 01:18:27,450
these machines and what we ended up

01:18:25,740 --> 01:18:29,310
doing is that we said well at least

01:18:27,450 --> 01:18:30,660
there should be a warning there should

01:18:29,310 --> 01:18:32,370
be something that tells to use it as

01:18:30,660 --> 01:18:36,150
something is wrong or potentially

01:18:32,370 --> 01:18:37,830
harmful so instead of the question mark

01:18:36,150 --> 01:18:42,330
we managed to make subversion show a

01:18:37,830 --> 01:18:43,590
conflict and we also so you get a seed

01:18:42,330 --> 01:18:45,300
and through and you also get some

01:18:43,590 --> 01:18:50,640
information about what this conflict is

01:18:45,300 --> 01:19:01,080
it would say something like incoming

01:18:50,640 --> 01:19:02,760
delete versus local edit right so so and

01:19:01,080 --> 01:19:04,050
and and one other thing that's important

01:19:02,760 --> 01:19:06,480
to know here is that if you have a

01:19:04,050 --> 01:19:08,670
conflicted file or directory' and you

01:19:06,480 --> 01:19:10,020
try to commit it and it's still marked

01:19:08,670 --> 01:19:11,700
as conflicted subversion says no you

01:19:10,020 --> 01:19:13,110
haven't dear dealt with that tell me

01:19:11,700 --> 01:19:15,540
that you've dealt with it before you can

01:19:13,110 --> 01:19:17,700
commit it so we require people to

01:19:15,540 --> 01:19:20,910
actively touch the thing and say I've

01:19:17,700 --> 01:19:23,010
resolved this conflict to commit their

01:19:20,910 --> 01:19:25,470
changes again until all them - to

01:19:23,010 --> 01:19:26,400
proceed so we are forcing the user to

01:19:25,470 --> 01:19:29,160
deal with it

01:19:26,400 --> 01:19:31,440
the problem is that it becomes very hard

01:19:29,160 --> 01:19:32,310
if there's a lot of them so it's a lot

01:19:31,440 --> 01:19:34,020
of manual works and

01:19:32,310 --> 01:19:36,060
times to resolve them and some people

01:19:34,020 --> 01:19:37,890
just get lost in the complexity and just

01:19:36,060 --> 01:19:42,240
say I have resolved resort resolve

01:19:37,890 --> 01:19:45,540
uncommitted happens a lot and and then

01:19:42,240 --> 01:19:47,970
you get exactly the same bogus results

01:19:45,540 --> 01:19:49,830
as you had before maybe slightly

01:19:47,970 --> 01:19:52,230
different because we also try to change

01:19:49,830 --> 01:19:53,970
the default behavior to preserve the

01:19:52,230 --> 01:19:56,130
local change in favor of the incoming

01:19:53,970 --> 01:19:57,720
change because that incoming changes

01:19:56,130 --> 01:19:59,250
already in the repository the local

01:19:57,720 --> 01:20:01,200
change is not so the local change is

01:19:59,250 --> 01:20:02,670
more important to get in there and even

01:20:01,200 --> 01:20:04,230
then if the history needs to be fixed or

01:20:02,670 --> 01:20:08,630
used to be reverted whatever it's better

01:20:04,230 --> 01:20:12,930
than having lost change right so am

01:20:08,630 --> 01:20:14,930
another case for instance is oh yeah

01:20:12,930 --> 01:20:17,880
what it will happen here is actually

01:20:14,930 --> 01:20:20,730
because of that what I just mentioned

01:20:17,880 --> 01:20:23,070
you actually just get a conflict a true

01:20:20,730 --> 01:20:26,400
not only but you also get a copy of foo

01:20:23,070 --> 01:20:30,450
you'll say a plus and foo is now a copy

01:20:26,400 --> 01:20:34,350
of the base revision you had before the

01:20:30,450 --> 01:20:36,570
update this is not perfect but it allows

01:20:34,350 --> 01:20:39,540
you to just say ok mark resolve and

01:20:36,570 --> 01:20:41,310
commit and retain your change you're

01:20:39,540 --> 01:20:42,720
over writing the the deletion

01:20:41,310 --> 01:20:44,640
you're basically recreating the thing

01:20:42,720 --> 01:20:46,650
from history as you had it originally

01:20:44,640 --> 01:20:51,270
and and your change makes it a

01:20:46,650 --> 01:20:52,410
repository if you just do the default

01:20:51,270 --> 01:20:55,110
thing that most people do is just

01:20:52,410 --> 01:20:56,700
resolve and commit however generally

01:20:55,110 --> 01:20:58,410
people should really start to engage

01:20:56,700 --> 01:21:01,340
their brains when they see this and try

01:20:58,410 --> 01:21:05,700
to figure out what's going on because

01:21:01,340 --> 01:21:08,340
iteration and subversion is possibly not

01:21:05,700 --> 01:21:13,970
just a deletion because if you remember

01:21:08,340 --> 01:21:13,970
how the repository works

01:21:15,869 --> 01:21:23,849
it doesn't say move anywhere right

01:21:18,400 --> 01:21:30,070
I said moves are modeled as copy entity

01:21:23,849 --> 01:21:32,710
so if you see this and I've actually

01:21:30,070 --> 01:21:36,460
changed this in 1 9 2 to say something

01:21:32,710 --> 01:21:38,050
else in 1 9 and we'll say this because I

01:21:36,460 --> 01:21:39,789
got annoyed at people not realizing that

01:21:38,050 --> 01:21:41,849
and I think the interface is still very

01:21:39,789 --> 01:21:48,670
bad and we still need to improve it but

01:21:41,849 --> 01:21:51,039
it now says this I think I'll move so it

01:21:48,670 --> 01:21:52,840
says incoming delete or move versus

01:21:51,039 --> 01:21:55,210
local Abbott people still don't

01:21:52,840 --> 01:21:57,039
understand this at first sight they will

01:21:55,210 --> 01:21:58,179
say what are you trying to tell me you

01:21:57,039 --> 01:22:08,199
don't know what to move or what's the

01:21:58,179 --> 01:22:11,190
delete yeah exactly we don't know so

01:22:08,199 --> 01:22:18,039
many things it becomes really complex

01:22:11,190 --> 01:22:19,389
there so we are doing yeah what we're

01:22:18,039 --> 01:22:23,170
doing right now is the best we can do

01:22:19,389 --> 01:22:25,179
with the current model and and extending

01:22:23,170 --> 01:22:27,159
the model is something that is hard

01:22:25,179 --> 01:22:30,280
because the project has some other rules

01:22:27,159 --> 01:22:31,690
like back let's go part and we need to

01:22:30,280 --> 01:22:36,119
keep operating against all clients you

01:22:31,690 --> 01:22:38,170
don't want to require people to you know

01:22:36,119 --> 01:22:40,150
change any applications they've written

01:22:38,170 --> 01:22:42,519
against subversion to to keep working

01:22:40,150 --> 01:22:43,900
and because I've written a set of

01:22:42,519 --> 01:22:45,760
libraries it's not just a command our

01:22:43,900 --> 01:22:47,559
client is it has maybe five or six

01:22:45,760 --> 01:22:49,090
libraries with public API is that we

01:22:47,559 --> 01:22:51,820
version and that are backwards

01:22:49,090 --> 01:22:53,170
compatible up to subversion 1-0 at the

01:22:51,820 --> 01:22:55,599
binary level so you can actually run

01:22:53,170 --> 01:22:57,190
code written against a version one zero

01:22:55,599 --> 01:22:59,050
base subversion one eight libraries and

01:22:57,190 --> 01:23:00,610
the client is just a small wrapper

01:22:59,050 --> 01:23:02,979
around those libraries and torrez's

01:23:00,610 --> 01:23:04,809
Rhian furnaces on windows it uses the

01:23:02,979 --> 01:23:06,610
Explorer stuff to display gooey and

01:23:04,809 --> 01:23:08,139
eternal later on it's the same code as

01:23:06,610 --> 01:23:11,249
to command-line client because it has

01:23:08,139 --> 01:23:11,249
all the API is available

01:23:16,930 --> 01:23:29,240
so it won't but it doesn't solve the

01:23:26,150 --> 01:23:31,580
problem because what you need to do then

01:23:29,240 --> 01:23:32,120
is the hard part is not how to recall

01:23:31,580 --> 01:23:34,130
the move

01:23:32,120 --> 01:23:36,470
we have several implementations and

01:23:34,130 --> 01:23:40,190
branches of that the hard part is

01:23:36,470 --> 01:23:43,280
resolving the conflicts and giving

01:23:40,190 --> 01:23:46,220
people reasonable choices and operations

01:23:43,280 --> 01:23:48,200
they can use to resolve them and no

01:23:46,220 --> 01:23:49,970
there's there has to be research

01:23:48,200 --> 01:23:52,160
research has to be done on this because

01:23:49,970 --> 01:23:54,470
there's I mean I've looked at get right

01:23:52,160 --> 01:23:55,280
what kid does in cases like this in the

01:23:54,470 --> 01:23:57,260
merge algorithm

01:23:55,280 --> 01:23:59,120
in the merge algorithm implementation

01:23:57,260 --> 01:24:02,030
they find a case where something has

01:23:59,120 --> 01:24:04,090
moved away and they run printf and scanf

01:24:02,030 --> 01:24:07,970
for an answer for what should happen

01:24:04,090 --> 01:24:10,220
inside the algorithm i think that's

01:24:07,970 --> 01:24:12,320
stupid what we need is something that

01:24:10,220 --> 01:24:14,630
has proper representation of the API

01:24:12,320 --> 01:24:16,460
levels so that clients no matter whether

01:24:14,630 --> 01:24:18,380
they're gree clients are web clients or

01:24:16,460 --> 01:24:20,570
whatever have all the options available

01:24:18,380 --> 01:24:23,450
and are all the same offer the same

01:24:20,570 --> 01:24:25,370
functionality and are stable in the

01:24:23,450 --> 01:24:28,510
sense that they that they will keep

01:24:25,370 --> 01:24:33,950
offering these options for all releases

01:24:28,510 --> 01:24:35,750
after that and if you if you if you look

01:24:33,950 --> 01:24:37,370
at this problem space this is one case

01:24:35,750 --> 01:24:41,150
it gets really large very quickly

01:24:37,370 --> 01:24:43,840
because you have to you have to consider

01:24:41,150 --> 01:24:49,340
not just update but merges as well and

01:24:43,840 --> 01:24:51,350
then you have to have to consider ad

01:24:49,340 --> 01:24:54,080
versus ad you have to consider a copy

01:24:51,350 --> 01:24:56,360
for this ad if to consider move versus

01:24:54,080 --> 01:24:58,700
move Africa so the movers to lead either

01:24:56,360 --> 01:25:02,240
side and it just explodes it's a lot of

01:24:58,700 --> 01:25:04,780
cases and so what this really could be

01:25:02,240 --> 01:25:08,000
right this this incoming really could be

01:25:04,780 --> 01:25:09,950
incoming delete or a move so instead of

01:25:08,000 --> 01:25:14,090
deleting this the person also added a

01:25:09,950 --> 01:25:17,290
new food to over here which is now in

01:25:14,090 --> 01:25:21,800
your working copy after the update right

01:25:17,290 --> 01:25:24,500
and some person doesn't know that your

01:25:21,800 --> 01:25:26,480
changes should now be here but you

01:25:24,500 --> 01:25:28,169
should know because you know that you

01:25:26,480 --> 01:25:35,340
should go and figure out that it's

01:25:28,169 --> 01:25:36,780
and so this for for-4 for changes that

01:25:35,340 --> 01:25:38,999
move around lots of things this gets

01:25:36,780 --> 01:25:40,199
really annoying and tedious but in

01:25:38,999 --> 01:25:42,809
simple cases is actually pretty

01:25:40,199 --> 01:25:44,459
straightforward so you would have to

01:25:42,809 --> 01:25:45,929
figure out okay what happened why did

01:25:44,459 --> 01:25:47,130
why did the duty took courage somebody

01:25:45,929 --> 01:25:49,139
moves something into someone you read

01:25:47,130 --> 01:25:50,550
something and then you find out in the

01:25:49,139 --> 01:25:51,809
log history what's going on maybe you

01:25:50,550 --> 01:25:56,329
talk to the person who made the change

01:25:51,809 --> 01:25:58,829
and you try to figure out okay and

01:25:56,329 --> 01:26:00,389
usually in in case of an incoming move

01:25:58,829 --> 01:26:01,829
the resolution is trivial you would just

01:26:00,389 --> 01:26:04,499
apply your edits over there once you

01:26:01,829 --> 01:26:08,489
found it right but in cases where you

01:26:04,499 --> 01:26:12,329
also moved it or in cases where I don't

01:26:08,489 --> 01:26:14,249
know people add like two Java packages

01:26:12,329 --> 01:26:15,630
with the same name and then they work on

01:26:14,249 --> 01:26:17,820
different branches and they merge them

01:26:15,630 --> 01:26:22,019
later and they didn't know what the

01:26:17,820 --> 01:26:24,179
other person was doing something needs

01:26:22,019 --> 01:26:27,179
to happen that resolves the conflict no

01:26:24,179 --> 01:26:28,919
reasonable way at the semantic level and

01:26:27,179 --> 01:26:34,979
the version control system doesn't know

01:26:28,919 --> 01:26:36,570
that how to do that yeah so this for

01:26:34,979 --> 01:26:38,280
example is the case where you flag ad

01:26:36,570 --> 01:26:40,169
versus ad as well you can't have the

01:26:38,280 --> 01:26:48,959
same object occupying the same path it's

01:26:40,169 --> 01:26:50,399
impossible and also it gets very

01:26:48,959 --> 01:26:54,119
complicated when you look at

01:26:50,399 --> 01:26:56,360
replacements so people can also delete

01:26:54,119 --> 01:26:59,159
and add something in the same revision

01:26:56,360 --> 01:27:03,449
which will then first delete and added

01:26:59,159 --> 01:27:05,369
in a single update or merge and thereby

01:27:03,449 --> 01:27:08,550
it might change the copy from

01:27:05,369 --> 01:27:11,280
information that the node and the

01:27:08,550 --> 01:27:17,959
working copy has like maybe this say

01:27:11,280 --> 01:27:17,959
you're merging from another branch and

01:27:20,170 --> 01:27:28,460
we're good

01:27:22,340 --> 01:27:30,889
Oh his imputation so say we have the

01:27:28,460 --> 01:27:38,570
head branch here and we create two

01:27:30,889 --> 01:27:45,469
branches B 1 and B 2 and both of them

01:27:38,570 --> 01:27:48,170
add a new directory called D and both of

01:27:45,469 --> 01:27:50,000
them want to merge you need to decide

01:27:48,170 --> 01:27:53,270
whether it's reasonable to have a single

01:27:50,000 --> 01:27:54,409
D or rename one of them right I mean

01:27:53,270 --> 01:27:58,250
it's obvious if you look at it like this

01:27:54,409 --> 01:27:59,900
but the problem is that there are many

01:27:58,250 --> 01:28:02,600
many combinations and we haven't yet

01:27:59,900 --> 01:28:05,090
found a good way of teaching the client

01:28:02,600 --> 01:28:06,520
to tell users what happened because

01:28:05,090 --> 01:28:11,179
sometimes you just lack the information

01:28:06,520 --> 01:28:13,340
for example if you consider the lead

01:28:11,179 --> 01:28:15,800
firs delete is a very popular conflict

01:28:13,340 --> 01:28:19,760
that people get a lot but you could have

01:28:15,800 --> 01:28:24,080
it could be this or it could be move

01:28:19,760 --> 01:28:30,350
first delete or it could be delete first

01:28:24,080 --> 01:28:32,150
move or it could be movers move and

01:28:30,350 --> 01:28:34,100
subversion currently has in general no

01:28:32,150 --> 01:28:36,350
way of knowing which which of these it

01:28:34,100 --> 01:28:38,030
is which of these cases happened because

01:28:36,350 --> 01:28:42,440
all the copies and deletes I've missed

01:28:38,030 --> 01:28:44,719
are destroyed and therefore we cannot

01:28:42,440 --> 01:28:46,310
offer reasonable options currently we

01:28:44,719 --> 01:28:47,810
just don't know we have to tell the user

01:28:46,310 --> 01:28:53,770
look please figure out what happened and

01:28:47,810 --> 01:28:53,770
fix it so whatever way of doing it and

01:28:53,949 --> 01:29:01,969
so if you have if you have replacements

01:28:58,190 --> 01:29:04,550
like in this case right say this person

01:29:01,969 --> 01:29:06,590
commits the deed first the D will be

01:29:04,550 --> 01:29:07,820
copied by the merge from the branch the

01:29:06,590 --> 01:29:10,760
trunk and it will have copy from

01:29:07,820 --> 01:29:12,380
pointing back to the branch it will say

01:29:10,760 --> 01:29:15,770
this directly was copied from B to a

01:29:12,380 --> 01:29:19,280
traditional for T and then the next

01:29:15,770 --> 01:29:20,690
person goes and wants to add their D but

01:29:19,280 --> 01:29:22,100
now you have to copy from pointer this

01:29:20,690 --> 01:29:24,560
way or that way which will do you use

01:29:22,100 --> 01:29:26,900
and sometimes people would we delete the

01:29:24,560 --> 01:29:28,550
D here and add the other one with

01:29:26,900 --> 01:29:29,400
different copy but some copy from

01:29:28,550 --> 01:29:31,410
information

01:29:29,400 --> 01:29:34,440
and so now if you if you do the log

01:29:31,410 --> 01:29:35,700
history you suddenly end up here instead

01:29:34,440 --> 01:29:38,670
of there if you go from the head

01:29:35,700 --> 01:29:40,680
revision backwards but if you go to a

01:29:38,670 --> 01:29:43,530
revision before this was merged you will

01:29:40,680 --> 01:29:45,480
see the other path because at that point

01:29:43,530 --> 01:29:47,190
the heat maybe I should have told us

01:29:45,480 --> 01:29:51,720
differently so imagine this didn't exist

01:29:47,190 --> 01:29:54,840
for me here so so in this range copy

01:29:51,720 --> 01:29:57,480
from tracing goes down here and once we

01:29:54,840 --> 01:30:01,350
if we placed the D copy from tracing

01:29:57,480 --> 01:30:03,450
goes this way and if you if you peg your

01:30:01,350 --> 01:30:06,780
look up here so if you zap a conversion

01:30:03,450 --> 01:30:09,060
that is past that revision from B from B

01:30:06,780 --> 01:30:11,550
one you will always see the B 2 history

01:30:09,060 --> 01:30:16,530
so nothing is lost it's just that it's

01:30:11,550 --> 01:30:17,970
very awkward to to figure out some of

01:30:16,530 --> 01:30:21,830
the history when you when you're looking

01:30:17,970 --> 01:30:24,120
from from the future into it and also I

01:30:21,830 --> 01:30:27,330
noticed that in previously people

01:30:24,120 --> 01:30:29,720
complain about log history diverting

01:30:27,330 --> 01:30:32,970
from the head so you have a file here

01:30:29,720 --> 01:30:35,010
that already existed back there and for

01:30:32,970 --> 01:30:36,680
some reason you you're on a log on it

01:30:35,010 --> 01:30:39,330
and it points back to some branch

01:30:36,680 --> 01:30:42,210
instead of staying in the head and this

01:30:39,330 --> 01:30:44,100
happens when people I believe run into

01:30:42,210 --> 01:30:46,470
tree conflicts and don't really know

01:30:44,100 --> 01:30:49,560
what to do and do something and maybe

01:30:46,470 --> 01:30:52,890
copy their files on top or run the merge

01:30:49,560 --> 01:30:55,080
again or do whatever they they think is

01:30:52,890 --> 01:30:56,160
right to fix the situation but then

01:30:55,080 --> 01:30:57,660
uncheck whether the copy from

01:30:56,160 --> 01:30:59,580
information actually still points to the

01:30:57,660 --> 01:31:02,130
head of the weather to the same branch

01:30:59,580 --> 01:31:04,490
and then they basically create an

01:31:02,130 --> 01:31:08,550
alternate line of history for that file

01:31:04,490 --> 01:31:10,920
right and this is not a problem again

01:31:08,550 --> 01:31:12,360
it's generally once you have this

01:31:10,920 --> 01:31:14,820
situation you can either keep going back

01:31:12,360 --> 01:31:17,700
here to see the original history or you

01:31:14,820 --> 01:31:19,410
can even change it back by copying stuff

01:31:17,700 --> 01:31:23,690
from the past to the front that works

01:31:19,410 --> 01:31:26,190
you can fix it in further revisions but

01:31:23,690 --> 01:31:27,750
it's it's not very convenient and it's

01:31:26,190 --> 01:31:29,310
something that also doesn't really apply

01:31:27,750 --> 01:31:31,910
to other systems because they don't have

01:31:29,310 --> 01:31:31,910
this concern

01:31:38,760 --> 01:31:43,600
and another issue with these three

01:31:41,590 --> 01:31:46,800
conflicts is that we don't really have a

01:31:43,600 --> 01:31:49,870
recipe that works for everything and

01:31:46,800 --> 01:31:51,460
it's a lot of practice to fix them a lot

01:31:49,870 --> 01:31:53,230
of understanding the data model and

01:31:51,460 --> 01:31:56,410
navigating it and figuring out what

01:31:53,230 --> 01:31:57,699
happened and and putting changes in the

01:31:56,410 --> 01:32:01,090
right places and fixing up a written

01:31:57,699 --> 01:32:02,680
copy in a consistent way and in several

01:32:01,090 --> 01:32:04,420
respects that you might want like you

01:32:02,680 --> 01:32:06,910
want to make sure a copy form enforce to

01:32:04,420 --> 01:32:10,540
correct or as you wanted and merger for

01:32:06,910 --> 01:32:12,130
is there or not there where you want and

01:32:10,540 --> 01:32:13,810
so there's a lot of there's a lot of

01:32:12,130 --> 01:32:15,850
freedom that subversion gives to people

01:32:13,810 --> 01:32:18,550
and sort of how they how they use this

01:32:15,850 --> 01:32:20,170
this model but it also makes it very

01:32:18,550 --> 01:32:21,699
easy to make mistakes that people regret

01:32:20,170 --> 01:32:24,070
later because it's in history and they

01:32:21,699 --> 01:32:25,239
can't fix it or they can it will always

01:32:24,070 --> 01:32:26,620
be there they can fix it in the head

01:32:25,239 --> 01:32:34,989
revision but their kinetics in the old

01:32:26,620 --> 01:32:36,550
ones okay do you want to walk through

01:32:34,989 --> 01:32:37,870
some of these cases ours is not so

01:32:36,550 --> 01:32:41,199
interesting I mean we could probably

01:32:37,870 --> 01:32:42,940
look for another two or three to see

01:32:41,199 --> 01:32:44,860
what people would do if they run into

01:32:42,940 --> 01:32:47,050
these sorts of situations like have a

01:32:44,860 --> 01:32:49,719
concrete example that shows you how to

01:32:47,050 --> 01:32:52,739
resolve ad versus ad or something like

01:32:49,719 --> 01:32:59,199
the test being commands would that help

01:32:52,739 --> 01:33:02,020
or is it just is enough as an don't know

01:32:59,199 --> 01:33:04,390
have you ever had this kind of coffee

01:33:02,020 --> 01:33:07,600
can you use do you remember what

01:33:04,390 --> 01:33:09,719
happened when you did okay what did you

01:33:07,600 --> 01:33:09,719
do

01:33:16,910 --> 01:33:23,730
okay what's interesting is that because

01:33:22,380 --> 01:33:25,530
of mixed revision working copies you can

01:33:23,730 --> 01:33:27,540
actually construct cases where you're

01:33:25,530 --> 01:33:29,490
the only person working on a repository

01:33:27,540 --> 01:33:33,120
but you still got three conflicts for

01:33:29,490 --> 01:33:34,650
yourself so I forgot how to do that but

01:33:33,120 --> 01:33:36,960
it's a nice trick but sometimes it

01:33:34,650 --> 01:33:39,090
happens to people and and they need to

01:33:36,960 --> 01:33:40,950
understand mixed revisions copy form

01:33:39,090 --> 01:33:44,340
information and all the stuff too to

01:33:40,950 --> 01:33:46,620
understand what's going on and I believe

01:33:44,340 --> 01:33:49,380
that most users get by without all of

01:33:46,620 --> 01:33:52,380
this they just they just see update add

01:33:49,380 --> 01:33:54,900
delete and and they don't see any of the

01:33:52,380 --> 01:33:56,580
portal even look at the metadata exactly

01:33:54,900 --> 01:33:59,610
I know what it means and then it becomes

01:33:56,580 --> 01:34:01,910
pretty difficult to deal with complex

01:33:59,610 --> 01:34:01,910
cases

01:34:06,130 --> 01:34:09,750
okay where's time off you got left

01:34:25,579 --> 01:34:30,250
how long is the second half is it is it

01:34:27,590 --> 01:34:30,250
the same Thanks

01:34:41,949 --> 01:34:46,570
good so you guys are not asking very

01:34:44,050 --> 01:34:48,610
many questions so I'm sort of running

01:34:46,570 --> 01:34:50,620
out of interesting stories to tell I

01:34:48,610 --> 01:34:52,270
don't know if you want to know more

01:34:50,620 --> 01:34:55,239
about anything in particular or any

01:34:52,270 --> 01:34:59,800
other thing you would like to know more

01:34:55,239 --> 01:35:01,620
about or any things you had happened to

01:34:59,800 --> 01:35:06,510
me in the past with this system that you

01:35:01,620 --> 01:35:06,510
couldn't deal with or that no surprising

01:35:17,520 --> 01:35:24,800
ah the default ignores list yeah well

01:35:22,140 --> 01:35:39,090
you can but you have to add them yes

01:35:24,800 --> 01:35:40,410
yeah okay so there's so there's well

01:35:39,090 --> 01:35:42,810
that was a bit that was change recently

01:35:40,410 --> 01:35:44,730
so so some things we're trying to fix

01:35:42,810 --> 01:35:47,430
some of that so a couple of the problems

01:35:44,730 --> 01:35:51,390
are like the ignore list like ignore any

01:35:47,430 --> 01:35:52,890
files ignoring the inversion files right

01:35:51,390 --> 01:35:55,290
by default when you see that in your

01:35:52,890 --> 01:35:56,850
working copy and Espeon status somewhere

01:35:55,290 --> 01:36:01,320
under stairs you I'm not looking at this

01:35:56,850 --> 01:36:02,820
I don't care and if you don't want them

01:36:01,320 --> 01:36:04,350
if you don't want to see them in status

01:36:02,820 --> 01:36:05,750
if you want to filter them there are

01:36:04,350 --> 01:36:09,720
several ways of doing that

01:36:05,750 --> 01:36:11,250
what's commonly used one is the yes we

01:36:09,720 --> 01:36:13,680
can ignore property that you set on the

01:36:11,250 --> 01:36:15,390
directory and you just say ignore all

01:36:13,680 --> 01:36:19,320
text files in this directory so the

01:36:15,390 --> 01:36:20,700
value to a multi-line they stop they CDF

01:36:19,320 --> 01:36:24,080
and match patterns we've mentioned this

01:36:20,700 --> 01:36:26,490
with a PRN much implementation and then

01:36:24,080 --> 01:36:27,660
you don't see them anymore they still

01:36:26,490 --> 01:36:29,400
there but you just don't see them and

01:36:27,660 --> 01:36:30,960
you for example tortoise would not

01:36:29,400 --> 01:36:34,890
suggest them for commit and stuff like

01:36:30,960 --> 01:36:38,730
that there's also the global ignores

01:36:34,890 --> 01:36:41,160
list on the client side and that by

01:36:38,730 --> 01:36:46,320
default this is miscible in config file

01:36:41,160 --> 01:36:51,300
and home dot subversion conflict I think

01:36:46,320 --> 01:36:58,530
and that by default contains some

01:36:51,300 --> 01:37:00,630
patterns like a you know but actually if

01:36:58,530 --> 01:37:03,630
you want to commit them you don't have

01:37:00,630 --> 01:37:06,210
to change this you just add them with SV

01:37:03,630 --> 01:37:07,350
an add even though they ignored and

01:37:06,210 --> 01:37:09,090
suddenly you will have them added

01:37:07,350 --> 01:37:11,370
because if you explicitly say I want

01:37:09,090 --> 01:37:14,160
this added then it will be but if you

01:37:11,370 --> 01:37:15,930
add a directory recursively and it

01:37:14,160 --> 01:37:17,640
contains these files somewhere then they

01:37:15,930 --> 01:37:19,200
will be filtered by the global ignore so

01:37:17,640 --> 01:37:20,670
you don't end up with them by default

01:37:19,200 --> 01:37:23,450
but you can actually still explicitly

01:37:20,670 --> 01:37:23,450
add the more my want

01:37:25,450 --> 01:37:30,080
no this is by default the you can

01:37:28,820 --> 01:37:32,000
comment it out and it will always be

01:37:30,080 --> 01:37:37,670
applied but you can change it at per

01:37:32,000 --> 01:37:45,920
client another thing that was added in

01:37:37,670 --> 01:37:50,360
1/8 is a global ignores property which I

01:37:45,920 --> 01:37:52,490
think it Ottomans this one so I'm not

01:37:50,360 --> 01:37:54,380
sure if it overrides it maybe it even

01:37:52,490 --> 01:37:55,940
overrides it are I have to look it up I

01:37:54,380 --> 01:37:57,410
don't remember but anyway you can put

01:37:55,940 --> 01:38:00,230
the same kinds of patterns as with this

01:37:57,410 --> 01:38:03,020
one and it's an inherited property which

01:38:00,230 --> 01:38:05,330
is something that we added in 1/8 the

01:38:03,020 --> 01:38:08,390
problem with the original implementation

01:38:05,330 --> 01:38:10,460
of this ignore mechanism is that you had

01:38:08,390 --> 01:38:12,500
to set it on every directory explicitly

01:38:10,460 --> 01:38:13,970
because you can check out from any

01:38:12,500 --> 01:38:16,910
directory and the client had no way of

01:38:13,970 --> 01:38:19,100
knowing what is what is set outside of

01:38:16,910 --> 01:38:21,080
the working copy so say you check out

01:38:19,100 --> 01:38:22,940
some deep deep subdirectory and you have

01:38:21,080 --> 01:38:26,300
an ignore property summary set up

01:38:22,940 --> 01:38:28,820
further up the tree and you wouldn't see

01:38:26,300 --> 01:38:29,630
it so all the ignores would not apply to

01:38:28,820 --> 01:38:32,000
your working copy

01:38:29,630 --> 01:38:33,890
so the original invitation required you

01:38:32,000 --> 01:38:37,030
to set as we ignore in every directory

01:38:33,890 --> 01:38:39,200
where you wanted to ignore files and

01:38:37,030 --> 01:38:43,910
since of Ursula night there is a concept

01:38:39,200 --> 01:38:46,790
of an inherit of the property that is a

01:38:43,910 --> 01:38:48,440
property that the client will go look

01:38:46,790 --> 01:38:51,020
for in the repository in addition to

01:38:48,440 --> 01:38:54,740
local path even on parents and cash the

01:38:51,020 --> 01:38:58,490
value in the local database and now it

01:38:54,740 --> 01:39:00,020
will pull up the fill if they'll recast

01:38:58,490 --> 01:39:02,450
them on every update or every time in

01:39:00,020 --> 01:39:04,610
context to the repository but now you

01:39:02,450 --> 01:39:07,460
have a way of telling clients from the

01:39:04,610 --> 01:39:08,660
repository side what will ignore right

01:39:07,460 --> 01:39:09,920
globally you set it on the root

01:39:08,660 --> 01:39:12,530
directory of your project or your

01:39:09,920 --> 01:39:17,420
repository and it will work as long as

01:39:12,530 --> 01:39:23,120
the clients at one age another inherited

01:39:17,420 --> 01:39:26,230
property we added was Auto props that is

01:39:23,120 --> 01:39:30,710
the same as the auto prop setting in the

01:39:26,230 --> 01:39:35,720
in the config file as well and what this

01:39:30,710 --> 01:39:36,709
does is for example you can say any XML

01:39:35,720 --> 01:39:42,800
file should have

01:39:36,709 --> 01:39:48,459
and SVN mimetype property with the

01:39:42,800 --> 01:39:50,800
content tech / XML or whatever you know

01:39:48,459 --> 01:39:56,850
something like that

01:39:50,800 --> 01:39:58,360
so this configures or you could say any

01:39:56,850 --> 01:40:05,209
[Music]

01:39:58,360 --> 01:40:10,070
text file should have said sv n yo L

01:40:05,209 --> 01:40:12,729
star - native write which which would

01:40:10,070 --> 01:40:14,809
then apply recursively to all the

01:40:12,729 --> 01:40:17,389
anytime that someone wants as be an ad

01:40:14,809 --> 01:40:19,249
of a text file will automatically get

01:40:17,389 --> 01:40:21,380
the property and set the 9th dies down

01:40:19,249 --> 01:40:22,820
to native so that when people use

01:40:21,380 --> 01:40:27,369
different systems they will get the

01:40:22,820 --> 01:40:27,369
native newline convention in each file

01:40:32,530 --> 01:40:37,639
yeah once we set it at one node and if

01:40:36,559 --> 01:40:39,530
you could take our children off that

01:40:37,639 --> 01:40:42,110
ordinate same node then they will they

01:40:39,530 --> 01:40:45,369
will see it but only one it clients will

01:40:42,110 --> 01:40:45,369
do that the other ones would ignore it

01:40:55,600 --> 01:41:00,610
yeah the one feature I'd like to add as

01:40:58,090 --> 01:41:03,210
a lock template because previously uses

01:41:00,610 --> 01:41:05,530
that as a custom patch currently and

01:41:03,210 --> 01:41:07,480
there is a branch that implements our

01:41:05,530 --> 01:41:10,330
inheritable lock template property where

01:41:07,480 --> 01:41:12,790
you can put a subtext and that will then

01:41:10,330 --> 01:41:15,310
fire up in the editor when you when you

01:41:12,790 --> 01:41:18,910
open the commit message editor it will

01:41:15,310 --> 01:41:20,740
be there but currently it's not clear

01:41:18,910 --> 01:41:23,350
whether this is enough to satisfy even

01:41:20,740 --> 01:41:25,480
previous these use case because to add

01:41:23,350 --> 01:41:28,680
some magic fields that can disappear or

01:41:25,480 --> 01:41:31,180
when people don't set them and they

01:41:28,680 --> 01:41:34,750
document their field separately from the

01:41:31,180 --> 01:41:38,070
actual fields so they have stuff like PR

01:41:34,750 --> 01:41:40,900
and then they have this ignore line

01:41:38,070 --> 01:41:42,430
which says anything below this will be

01:41:40,900 --> 01:41:43,900
ignored you type a lot message up here

01:41:42,430 --> 01:41:47,800
and in this for this is just for

01:41:43,900 --> 01:41:51,280
information but here they document the R

01:41:47,800 --> 01:41:53,140
is a number and it's also and so if

01:41:51,280 --> 01:41:54,670
people don't set the PR it will be it

01:41:53,140 --> 01:41:59,380
will vanish from the final comment

01:41:54,670 --> 01:42:01,150
message and I need to find a way of

01:41:59,380 --> 01:42:03,010
generically expressing this kind of

01:42:01,150 --> 01:42:06,250
these kinds of rules to actually make

01:42:03,010 --> 01:42:09,850
FreeBSD users switch because if we offer

01:42:06,250 --> 01:42:11,560
something that does not have the same

01:42:09,850 --> 01:42:12,520
behavior as their custom patch I don't

01:42:11,560 --> 01:42:14,890
think they're going to be willing to

01:42:12,520 --> 01:42:17,650
drop the patch which I'd like them to do

01:42:14,890 --> 01:42:19,390
that we have to find something where you

01:42:17,650 --> 01:42:21,580
can set a property and and explain the

01:42:19,390 --> 01:42:24,400
rules of how the template should work

01:42:21,580 --> 01:42:26,680
and then it should work that way but I'm

01:42:24,400 --> 01:42:28,780
not yet sure how to make it so generic

01:42:26,680 --> 01:42:31,120
that everyone is a version can make use

01:42:28,780 --> 01:42:34,170
of it if you have any suggestions I

01:42:31,120 --> 01:42:34,170
would be very happy

01:42:39,969 --> 01:42:44,809
okay

01:42:41,149 --> 01:42:52,669
no more questions and I would suggest we

01:42:44,809 --> 01:42:54,789
start with you guys doing something you

01:42:52,669 --> 01:42:57,829
can you can crack some riddles that I've

01:42:54,789 --> 01:43:02,089
that other people working on FreeBSD

01:42:57,829 --> 01:43:05,510
have cracked in the past where they had

01:43:02,089 --> 01:43:08,389
situations they couldn't figure out and

01:43:05,510 --> 01:43:09,949
asked for help or ask each other for

01:43:08,389 --> 01:43:13,119
help and I found their mailing list post

01:43:09,949 --> 01:43:15,499
so they were confused and helpless and I

01:43:13,119 --> 01:43:17,109
devised solutions to all these problems

01:43:15,499 --> 01:43:22,099
which I will share with you at the end

01:43:17,109 --> 01:43:24,169
after you've tried to solve them and or

01:43:22,099 --> 01:43:26,959
you can if you if you don't want to do

01:43:24,169 --> 01:43:28,519
anything if you don't feel very you

01:43:26,959 --> 01:43:30,199
never use subversion maybe you will just

01:43:28,519 --> 01:43:32,300
want to do is sort of like walk through

01:43:30,199 --> 01:43:33,769
through all the all the commands that

01:43:32,300 --> 01:43:36,649
are there what you can do with them and

01:43:33,769 --> 01:43:40,729
and this will just require you to to

01:43:36,649 --> 01:43:43,129
read and and and type on the terminal

01:43:40,729 --> 01:43:44,539
and and try some stuff out and there

01:43:43,129 --> 01:43:46,010
won't be any challenge it will just be

01:43:44,539 --> 01:43:51,679
explaining the system to you

01:43:46,010 --> 01:43:53,300
interactively as you go so those are the

01:43:51,679 --> 01:43:55,219
things I have an offer you can pick

01:43:53,300 --> 01:43:57,319
either of them whichever suits you best

01:43:55,219 --> 01:43:59,419
I think I have more I brought more

01:43:57,319 --> 01:44:02,709
copies of the FreeBSD exercises because

01:43:59,419 --> 01:44:05,829
I expected many FreeBSD developers to me

01:44:02,709 --> 01:44:08,449
so I I think I have 10 printouts of the

01:44:05,829 --> 01:44:11,689
exercises for FreeBSD and I've three or

01:44:08,449 --> 01:44:13,609
four of the others so you can I also

01:44:11,689 --> 01:44:16,209
have them in PDF soon so you can also

01:44:13,609 --> 01:44:16,209
read them on the screen

01:44:20,280 --> 01:44:27,930
and you will need subversion

01:44:23,940 --> 01:44:29,430
command-line client installed on the

01:44:27,930 --> 01:44:36,900
system but I think I told you that an

01:44:29,430 --> 01:44:38,150
email before it's personal yeah it's

01:44:36,900 --> 01:44:42,300
perfect

01:44:38,150 --> 01:44:52,890
you're running current right you're

01:44:42,300 --> 01:44:55,260
logging beasty with this yes okay so I

01:44:52,890 --> 01:44:58,530
would suggest you get up for a change

01:44:55,260 --> 01:45:07,440
and grab your exercises that you want to

01:44:58,530 --> 01:45:09,710
do so there's four of these and ten of

01:45:07,440 --> 01:45:09,710
these

01:45:13,689 --> 01:45:21,459
oh and you also get data and you have to

01:45:19,570 --> 01:45:28,539
pass around a couple of USB sticks to

01:45:21,459 --> 01:45:32,459
get the data but the data is only for

01:45:28,539 --> 01:45:32,459

YouTube URL: https://www.youtube.com/watch?v=3yGfXBCtXvE


